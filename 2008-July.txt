From mean at mail.berlios.de  Thu Jul  3 21:29:22 2008
From: mean at mail.berlios.de (mean at BerliOS)
Date: Thu, 3 Jul 2008 21:29:22 +0200
Subject: [Avidemux-svn-commit] r4183 -
	branches/avidemux_2.5_branch_gruntster/plugins
Message-ID: <200807031929.m63JTMvJ029092@sheep.berlios.de>

Author: mean
Date: 2008-07-03 21:29:21 +0200 (Thu, 03 Jul 2008)
New Revision: 4183

Modified:
   branches/avidemux_2.5_branch_gruntster/plugins/CMakeLists.txt
Log:
[AudioDevice] pluging


Modified: branches/avidemux_2.5_branch_gruntster/plugins/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/CMakeLists.txt	2008-06-30 18:30:09 UTC (rev 4182)
+++ branches/avidemux_2.5_branch_gruntster/plugins/CMakeLists.txt	2008-07-03 19:29:21 UTC (rev 4183)
@@ -127,6 +127,7 @@
 # Actual work to do..
 ########################################
 ADD_SUBDIRECTORY(ADM_audiodecoder)
+ADD_SUBDIRECTORY(ADM_audioDevices)
 ADD_SUBDIRECTORY(ADM_videoEncoder)
 ADD_SUBDIRECTORY(ADM_videoFilters)
 
@@ -134,4 +135,4 @@
 # Config Summary
 ########################################
 INCLUDE(admPluginConfigSummary)
-MESSAGE("")
\ No newline at end of file
+MESSAGE("")



From mean at mail.berlios.de  Thu Jul  3 21:29:27 2008
From: mean at mail.berlios.de (mean at BerliOS)
Date: Thu, 3 Jul 2008 21:29:27 +0200
Subject: [Avidemux-svn-commit] r4184 - in
	branches/avidemux_2.5_branch_gruntster: avidemux
	avidemux/ADM_audiodevice
	avidemux/ADM_userInterfaces/ADM_commonUI cmake plugins
	plugins/ADM_audioDevices plugins/ADM_audioDevices/Alsa
	plugins/ADM_audioDevices/Arts plugins/ADM_audioDevices/AudioCore
	plugins/ADM_audioDevices/Esd plugins/ADM_audioDevices/Jack
	plugins/ADM_audioDevices/Oss plugins/ADM_audioDevices/Sdl
	plugins/ADM_audioDevices/Win32
Message-ID: <200807031929.m63JTRrA029122@sheep.berlios.de>

Author: mean
Date: 2008-07-03 21:29:25 +0200 (Thu, 03 Jul 2008)
New Revision: 4184

Added:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_audioDeviceInternal.h
   branches/avidemux_2.5_branch_gruntster/cmake/av_plugin.cmake
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Alsa/
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Alsa/ADM_deviceALSA.cpp
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Alsa/ADM_deviceALSA.h
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Alsa/CMakeLists.txt
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Arts/
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Arts/ADM_deviceArts.cpp
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Arts/ADM_deviceArts.h
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Arts/CMakeLists.txt
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/AudioCore/
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/AudioCore/ADM_deviceAudioCore.cpp
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/AudioCore/ADM_deviceAudioCore.h
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/AudioCore/CMakeLists.txt
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/CMakeLists.txt
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Esd/
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Esd/ADM_deviceEsd.cpp
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Esd/ADM_deviceEsd.h
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Esd/CMakeLists.txt
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Jack/
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Jack/ADM_deviceJack.cpp
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Jack/ADM_deviceJack.h
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Jack/CMakeLists.txt
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Oss/
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Oss/ADM_deviceoss.cpp
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Oss/ADM_deviceoss.h
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Oss/CMakeLists.txt
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Sdl/
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Sdl/ADM_deviceSDL.cpp
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Sdl/ADM_deviceSDL.h
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Sdl/CMakeLists.txt
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Win32/
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Win32/ADM_deviceWin32.cpp
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Win32/ADM_deviceWin32.h
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Win32/CMakeLists.txt
Removed:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceALSA.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceALSA.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceArts.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceArts.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceAudioCore.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceAudioCore.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceEsd.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceEsd.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceJack.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceJack.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceSDL.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceSDL.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceWin32.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceWin32.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceoss.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceoss.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/oss_out.cpp
Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_audiodevice.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_audiodevice.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/CMakeLists.txt
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/audio_out.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_plugins.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_prefs.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/gtk_gui.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/main.cpp
Log:
[AudioDevice] Skeleton for plugins


Added: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_audioDeviceInternal.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_audioDeviceInternal.h	2008-07-03 19:29:21 UTC (rev 4183)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_audioDeviceInternal.h	2008-07-03 19:29:25 UTC (rev 4184)
@@ -0,0 +1,82 @@
+/**
+    \fn ADM_audioDeviceInternal.h
+    \brief Macros and stuff to write audioDevice plugins
+
+
+
+*/
+#ifndef ADM_audioDeviceInternal_H
+#define ADM_audioDeviceInternal_H
+
+#define ADM_AUDIO_DEVICE_API_VERSION 1
+#include "ADM_dynamicLoading.h"
+class ADM_AudioDevices :public ADM_LibWrapper
+{
+public:
+        int         initialised;
+        audioDevice *(*createAudioDevice)();
+        void         (*deleteAudioDevice)(audioDevice *device);
+        uint8_t      (*getVersion)(uint32_t *major,uint32_t *minor,uint32_t *patch);
+        // Only initialized once
+        const char    *name;
+        const char    *descriptor;
+        uint32_t apiVersion;
+
+        ADM_AudioDevices(const char *file) : ADM_LibWrapper()
+		{
+        const char   *(*getDescriptor)();
+        uint32_t     (*getApiVersion)();
+        const char  *(*getAudioDeviceName)();
+
+			initialised = (loadLibrary(file) && getSymbols(6,
+				&createAudioDevice, "create",
+				&deleteAudioDevice, "destroy",
+
+				&getAudioDeviceName, "getName",
+				&getApiVersion, "getApiVersion",
+				&getVersion, "getVersion",
+				&getDescriptor, "getDescriptor"));
+                if(initialised)
+                {
+                    name=getAudioDeviceName();
+                    apiVersion=getApiVersion();
+                    descriptor=getDescriptor();
+                    printf("Name :%s ApiVersion :%d\n",name,apiVersion);
+                }else
+                {
+                    printf("Symbol loading failed for %s\n",file);
+                }
+		}
+        ADM_AudioDevices(const char *name,const char *desc, 
+                                uint8_t      (*getVersion)(uint32_t *major,uint32_t *minor,uint32_t *patch),
+                                audioDevice *(*createAudioDevice)(),
+                                void         (*deleteAudioDevice)(audioDevice *device)) : ADM_LibWrapper()
+		{
+
+                    this->name=name;
+                    this->descriptor=desc;
+                    this->apiVersion=ADM_AUDIO_DEVICE_API_VERSION;
+                    this->createAudioDevice=createAudioDevice;
+                    this->deleteAudioDevice=deleteAudioDevice;
+                    this->getVersion=getVersion;
+                    
+		}
+      
+};
+
+#define ADM_DECLARE_AUDIODEVICE(name,Class,major,minor,patch,desc) \
+extern "C" { \
+const char *getName(void) {return #name;}\
+uint32_t getApiVersion(void) {return ADM_AUDIO_DEVICE_API_VERSION;} \
+const char *getDescriptor(void ) {return desc;} \
+ audioDevice *create(void){return new Class;} \
+ void destroy(audioDevice *z){Class *a=(Class *)z;delete a;} \
+uint8_t getVersion(uint32_t *mmajor,uint32_t *mminor,uint32_t *ppatch) \
+    {\
+        *mmajor=major;\
+        *mminor=minor;\
+        *ppatch=patch;\
+        return 1;\
+    } \
+}
+#endif

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_audiodevice.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_audiodevice.cpp	2008-07-03 19:29:21 UTC (rev 4183)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_audiodevice.cpp	2008-07-03 19:29:25 UTC (rev 4184)
@@ -14,169 +14,199 @@
  *   (at your option) any later version.                                   *
  *                                                                         *
  ***************************************************************************/
-#include "config.h"
+#include <vector>
+#include "ADM_default.h"
+#include "ADM_audiodevice.h"
+#include "audio_out.h"
+#include "ADM_audioDeviceInternal.h"
+#include "prefs.h"
 
-#ifdef HAVE_AUDIO
-#include <stdio.h>
-#include <stdlib.h>
-#include <errno.h>
+std::vector <ADM_AudioDevices *> ListOfAudioDevices;
 
-#include "avi_vars.h"
-#include "prefs.h"
 
-#include "ADM_assert.h"
-#include "ADM_audiodevice.h"
+static audioDevice *device=NULL;
+static AUDIO_DEVICE  currentDevice=0; //0 is always dummy
 
-#include "ADM_audiodevice/ADM_deviceoss.h"
+static AUDIO_DEVICE ADM_audioByName(const char *name);
+static const char *ADM_audioById(AUDIO_DEVICE id);
 
-#ifdef USE_ARTS
-#include <artsc.h>
-#include "ADM_audiodevice/ADM_deviceArts.h"
-#endif
 
-#ifdef ALSA_SUPPORT
-#include "ADM_audiodevice/ADM_deviceALSA.h"
-#endif
+// --------- couple of stubs for dummy device  -------------
+static uint8_t      DummyGetVersion(uint32_t *major,uint32_t *minor,uint32_t *patch)
+{
+    *major=1;
+    *minor=0;
+    *patch=0;
+    return 0;
+}
+audioDevice *DummyCreateAudioDevice(void)
+{
+    return new dummyAudioDevice;
+}
+void DummyDeleteAudioDevice(audioDevice *z)
+{
+    dummyAudioDevice *a=(dummyAudioDevice *)z;
+}
+// --------- couple of stubs for dummy device  -------------
+uint32_t ADM_av_getNbDevices(void);
+bool     ADM_av_getDeviceInfo(int filter, const char **name, uint32_t *major,uint32_t *minor,uint32_t *patch);
 
-#ifdef USE_SDL
-#include "ADM_audiodevice/ADM_deviceSDL.h"
-#endif
+/**
+        \fn ADM_av_getNbDevices
+        \brief Returns the number of av filter plugins except one
+*/
+uint32_t ADM_av_getNbDevices(void)
+{
+    return ListOfAudioDevices.size()-1;
+}
+/**
+    \fn     ADM_av_getDeviceInfo
+    \brief  Get Infos about the filter#th plugin
+*/
+bool     ADM_av_getDeviceInfo(int filter, const char **name, uint32_t *major,uint32_t *minor,uint32_t *patch)
+{
+    filter++;
+    ADM_assert(filter<ListOfAudioDevices.size());
+    ListOfAudioDevices[filter]->getVersion(major,minor,patch);
+    *name=ListOfAudioDevices[filter]->name;
+    return true;
+}
+/**
+    \fn tryLoadingFilterPlugin
+    \brief Try loading the file given as argument as an audio device plugin
 
-#ifdef __WIN32
-#include "ADM_audiodevice/ADM_deviceWin32.h"
-#endif
+*/
+#define Fail(x) {printf("%s:"#x"\n",file);goto er;}
+static bool tryLoadingFilterPlugin(const char *file)
+{
+	ADM_AudioDevices *dll=new ADM_AudioDevices(file);
+    if(!dll->initialised) Fail(CannotLoad);
+    if(dll->apiVersion!=ADM_AUDIO_DEVICE_API_VERSION) Fail(WrongApiVersion);
 
-#ifdef USE_ESD
-#include "ADM_deviceEsd.h"
-#endif
+    ListOfAudioDevices.push_back(dll); // Needed for cleanup. FIXME TODO Delete it.
+    printf("[Filters] Registered filter %s as  %s\n",file,dll->descriptor);
+    return true;
+	// Fail!
+er:
+	delete dll;
+	return false;
 
-#ifdef USE_JACK
-#include "ADM_deviceJack.h"
+}
+/**
+ * 	\fn ADM_av_loadPlugins
+ *  \brief load all audio device plugins
+ */
+uint8_t ADM_av_loadPlugins(const char *path)
+{
+#define MAX_EXTERNAL_FILTER 100
+// FIXME Factorize
+#ifdef __WIN32
+#define SHARED_LIB_EXT "dll"
+#elif defined(__APPLE__)
+#define SHARED_LIB_EXT "dylib"
+#else
+#define SHARED_LIB_EXT "so"
 #endif
 
-#ifdef __APPLE__
-#include "ADM_audiodevice/ADM_deviceAudioCore.h"
-#endif
+	char *files[MAX_EXTERNAL_FILTER];
+	uint32_t nbFile;
 
-#include "gui_action.hxx"
-#include "audio_out.h"
 
+    // PushBack our dummy one : TODO FIXME
+    ADM_AudioDevices *dummyDevice=new ADM_AudioDevices("Dummy","Dummy audio device", 
+                                DummyGetVersion,
+                                DummyCreateAudioDevice,
+                                DummyDeleteAudioDevice);
+    
+    ListOfAudioDevices.push_back(dummyDevice); 
+	memset(files,0,sizeof(char *)*MAX_EXTERNAL_FILTER);
+	printf("[ADM_av_plugin] Scanning directory %s\n",path);
 
+	if(!buildDirectoryContent(&nbFile, path, files, MAX_EXTERNAL_FILTER, SHARED_LIB_EXT))
+	{
+		printf("[ADM_av_plugin] Cannot parse plugin\n");
+		return 0;
+	}
 
+	for(int i=0;i<nbFile;i++)
+		tryLoadingFilterPlugin(files[i]);
 
+	printf("[ADM_av_plugin] Scanning done\n");
 
-audioDevice::audioDevice(void) {
+	return 1;
 }
-
 /**
-		in=0 -> arts1
-		in=1 -> alsa
+    \fn AVDM_audioSave
+    \brief Save in Prefs the current audio Device
+
 */
 
-audioDevice *device=NULL;
-static AUDIO_DEVICE  currentDevice=DEVICE_DUMMY;
-static AUDIO_DEVICE ADM_audioByName(const char *name);
-static const char *ADM_audioById(AUDIO_DEVICE id);
-
 void AVDM_audioSave( void )
 {
 const char *string;
 		string=ADM_audioById(currentDevice);
 		prefs->set(DEVICE_AUDIODEVICE, string);
-	
-
 }
+/**
+    \fn ADM_audioByName
+    \brief Returns the Id of the given string 
+
+*/
 AUDIO_DEVICE ADM_audioByName(const char *name)
 {
 	if(!name) return (AUDIO_DEVICE)0;
-	for(uint32_t i=0;i<sizeof(audioDeviceList)/sizeof(DEVICELIST);i++)
+	for(uint32_t i=0;i<ListOfAudioDevices.size();i++)
 	{
-		if(!strcmp(name,audioDeviceList[i].name))
+		if(!strcasecmp(name,ListOfAudioDevices[i]->name))
 		{
-			return audioDeviceList[i].id;
+			return i;
 		}	
 	}
 	printf("Device not found :%s\n",name);
 	return (AUDIO_DEVICE)0;
 
 }
+/**
+    \fn ADM_audioById
+    \brief Returns the name of a device from its Id
+*/
 const char *ADM_audioById(AUDIO_DEVICE id)
 {
-	
-	for(uint32_t i=0;i<sizeof(audioDeviceList)/sizeof(DEVICELIST);i++)
-	{
-		if(audioDeviceList[i].id==id)
-		{
-			return audioDeviceList[i].name;
-		}	
-	}
-	printf("Device not found :%d\n",id);
-	return (const char *)"Unknown!";
-
+	ADM_assert(id<ListOfAudioDevices.size());
+    return ListOfAudioDevices[id]->name;
 }
-
+/**
+    \fn AVDM_getCurrentDevice
+    \brief
+*/
 AUDIO_DEVICE AVDM_getCurrentDevice( void)
 {
 	return currentDevice;
 }
-
+/**
+    \fn AVDM_audioInit
+    \brief
+*/
 void AVDM_audioInit(void )
 {
 uint8_t init=0;
 char *name=NULL;
-AUDIO_DEVICE id;
+AUDIO_DEVICE id=0;
 
 		if(prefs->get(DEVICE_AUDIODEVICE, &name))
 		{
 		id=ADM_audioByName(name);
 		ADM_dealloc(name);
 		name=NULL;	
-		if(!id) id=DEVICE_DUMMY;
-		switch(id)
-		{
-
-			case DEVICE_ARTS:									
-			case DEVICE_ALSA:
-			case DEVICE_COREAUDIO:
-			case DEVICE_SDL:
-			case DEVICE_WIN32:
-			case DEVICE_ESD:
-			case DEVICE_JACK:
-			
-						printf("Using real audio device\n");
-						AVDM_switch(id);
-						init=1;	
-						break;				
-			case DEVICE_DUMMY:
-			default:
-						printf("Using dummy audio device\n");
-						init=1;
-						AVDM_switch(id);
-						break;
+        }
 		
-		}
-		}
-		// Fallback
-		if(init==0)
-		{
-		#ifdef OSS_SUPPORT
-			AVDM_switch(DEVICE_OSS);			
-			printf("\n Using OSS\n");
-		#else
-			#ifdef __WIN32
-			AVDM_switch(DEVICE_WIN32);
-			#else
-                #ifdef USE_ESD
-			        AVDM_switch(DEVICE_ESD);
-                #else
-			        AVDM_switch(DEVICE_DUMMY);
-			        printf("\n Using dummy\n");
-                #endif
-			#endif
-		#endif
-		}
+		
+        AVDM_switch(id);
 }
-
+/**
+        \fn AVDM_cleanup
+        \brief Current device is no longer used, delete
+*/
 void AVDM_cleanup(void)
 {
 	if(device)
@@ -194,93 +224,37 @@
 		delete device;
 		device=NULL;
 	}
+    ADM_assert(action<ListOfAudioDevices.size());
+    device=ListOfAudioDevices[action]->createAudioDevice();
+    currentDevice=action;
 
-	 currentDevice=DEVICE_DUMMY;
-	switch(action)
-	{
-#ifdef __APPLE__
-		  case  DEVICE_COREAUDIO :
-								device=new 	 coreAudioDevice;
-								currentDevice=DEVICE_COREAUDIO;;
-								printf("Using Darwin coreaudio i/f\n");
-								break;
-
-#endif
-#if defined(OSS_SUPPORT)
-		  case  DEVICE_OSS :
-								device=new 	 ossAudioDevice;
-								currentDevice=DEVICE_OSS;;
-								break;
-#endif
-#if defined(USE_ESD)
-		  case  DEVICE_ESD :
-								device=new 	 esdAudioDevice;
-								currentDevice=DEVICE_ESD;;
-								break;
-#endif
-#if defined(USE_JACK)
-		  case  DEVICE_JACK:
-								device=new 	 jackAudioDevice;
-								currentDevice=DEVICE_JACK;
-								break;
-#endif
-#ifdef USE_ARTS
-		case DEVICE_ARTS:
-								device=new 	 artsAudioDevice;
-							 	currentDevice=DEVICE_ARTS;
-								break;
-
-#endif
-#ifdef ALSA_SUPPORT
-		case DEVICE_ALSA:
-								device=new 	 alsaAudioDevice;
-							 	currentDevice=DEVICE_ALSA;
-								break;
-
-#endif
-#ifdef USE_SDL
-		case DEVICE_SDL:
-								device=new sdlAudioDevice;
-								currentDevice=DEVICE_SDL;
-								break;
-#endif
-
-#ifdef __WIN32
-		case DEVICE_WIN32:
-								device=new win32AudioDevice;
-								currentDevice=DEVICE_WIN32;
-								break;
-#endif
-
-
-		 case  DEVICE_DUMMY:
-					default:
-								device=new 	 dummyAudioDevice;
-								currentDevice=DEVICE_DUMMY;
-								break;
-
-	}
-
 }
+/**
+    \fn AVDM_AudioClose
+    \brief Stop playback
 
-//_______________________________________________
-//
-//
-//_______________________________________________
+*/
 void AVDM_AudioClose(void)
 {
 	device->stop();
 }
 
-//_______________________________________________
-//
-//
-//_______________________________________________
+/**
+    \fn AVDM_AudioSetup
+    \brief Initialize a device
+
+*/
 uint32_t AVDM_AudioSetup(uint32_t fq, uint8_t channel)
 {
 	
 	return device->init(channel,fq);
 }
+/**
+    \fn AVDM_setVolume
+    \brief Set the volume (0..100)
+
+*/
+
 uint8_t         AVDM_setVolume(int volume)
 {
         printf("New volume :%d\n",volume);
@@ -288,18 +262,24 @@
         return 1;
 
 }
-//_______________________________________________
-//
-//
-//_______________________________________________
+/**
+    \fn AVDM_AudioPlay
+    \brief Send float data to be played immediately by the device
+
+*/
 uint8_t AVDM_AudioPlay(float *ptr, uint32_t nb)
 {
 	return device->play(nb,ptr);
 }
-#else
-void dummy_func_make_gcc_happy( void );
-void dummy_func_make_gcc_happy( void )
-{
-}
+//**
+dummyAudioDevice::dummyAudioDevice(void) {};
+dummyAudioDevice::~dummyAudioDevice(void) {};
+uint8_t dummyAudioDevice::init(uint32_t channels, uint32_t fq)
+                                {printf("Null audio device\n"); UNUSED_ARG(fq); UNUSED_ARG(channels); return 1;}
+uint8_t dummyAudioDevice::play(uint32_t len, float *data)
+                                {UNUSED_ARG(len); UNUSED_ARG(data); return 1;}
+uint8_t dummyAudioDevice::stop(void)
+                                { return 1;}
 
-#endif
+
+//**

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_audiodevice.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_audiodevice.h	2008-07-03 19:29:21 UTC (rev 4183)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_audiodevice.h	2008-07-03 19:29:25 UTC (rev 4184)
@@ -12,32 +12,36 @@
 #ifndef ADM_AUDIODEVICE_H
 #define ADM_AUDIODEVICE_H
 
-#include "ADM_assert.h"
+// Converts float to int16_t with dithering
+extern void dither16(float *start, uint32_t nb, uint8_t channels);
 
-void dither16(float *start, uint32_t nb, uint8_t channels);
-
  class audioDevice
  {
         protected:
-			uint8_t _channels;
+                        uint32_t _channels; /// # of channels we want to setup
+                        uint32_t _frequency;/// Frequency we want to setup
 
         public:
-                                        audioDevice(void);
-                        virtual uint8_t init(uint8_t channel, uint32_t fq ) {ADM_assert(0);return 0;}
-                        virtual uint8_t stop(void) {ADM_assert(0);return 0;}
-                        virtual uint8_t play(uint32_t len, float *data) {ADM_assert(0);return 0;}
-                        virtual uint8_t setVolume(int volume) {return 1;}
+                                        audioDevice(void) {};
+                        virtual         ~audioDevice() {};
+                        virtual uint8_t  init(uint32_t channel, uint32_t fq ) =0;
+                        virtual uint8_t  stop(void)=0;
+                        virtual uint8_t  play(uint32_t len, float *data) =0;
+                        virtual uint8_t  setVolume(int volume) {return 1;}
+                        virtual uint32_t getLatencyMs(void) {return 0;}
 }   ;
-
+/**
+    \class dummyAudioDevice
+    \brief this dummy is used when no suitable device have been found.
+*/
 class dummyAudioDevice : public audioDevice
 {
 		  public:
-                                        dummyAudioDevice(void) {};
-                        virtual uint8_t init(uint8_t channels, uint32_t fq)
-                                {printf("Null audio device\n"); UNUSED_ARG(fq); UNUSED_ARG(channels); return 1;}
-                        virtual uint8_t play(uint32_t len, float *data)
-                                {UNUSED_ARG(len); UNUSED_ARG(data); return 1;}
-                        virtual uint8_t stop(void) {return 1;}
+                                        dummyAudioDevice(void) ;
+                                        ~dummyAudioDevice(void);
+                        virtual uint8_t init(uint32_t channels, uint32_t fq);
+                        virtual uint8_t play(uint32_t len, float *data);
+                        virtual uint8_t stop(void) ;
 }   ;
 
 #endif

Deleted: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceALSA.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceALSA.cpp	2008-07-03 19:29:21 UTC (rev 4183)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceALSA.cpp	2008-07-03 19:29:25 UTC (rev 4184)
@@ -1,355 +0,0 @@
-/***************************************************************************
-                          ADM_deviceAlsa.cpp  -  description
-                             -------------------
-
-	Strongly derivated from code sample from alsa-project.org with some bits
-		from mplayer concerning the swparams
-
-    begin                : Sat Sep 28 2002
-    copyright            : (C) 2002 by mean
-    email                : fixounet at free.fr
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#include "config.h"
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <unistd.h>
-#include <errno.h>
-#include <sys/types.h>
-#include "prefs.h"
-
-
-#ifdef ALSA_SUPPORT
-#include <alsa/asoundlib.h>
-#include "ADM_assert.h"
-
-#include "ADM_default.h"
-
-
-#include "ADM_audiodevice.h"
-#include  "ADM_audiodevice/ADM_deviceALSA.h"
-
-#include "ADM_assert.h"
-
-/* Handle for the PCM device */
-snd_pcm_t *pcm_handle;
-
-    alsaAudioDevice::alsaAudioDevice( void )
-    {
-		_init=0;
-    }
-
-uint8_t alsaAudioDevice::init( uint8_t channel,uint32_t fq )
-{
-	int dir=0;
-
-	_channels=channel;
-	_init=0;
-   /* Playback stream */
-    snd_pcm_stream_t stream = SND_PCM_STREAM_PLAYBACK;
-
-    /* This structure contains information about    */
-    /* the hardware and can be used to specify the  */
-    /* configuration to be used for the PCM stream. */
-    snd_pcm_hw_params_t *hwparams;
-    snd_pcm_sw_params_t *swparams;
-
-
-  static char *pcm_name;
-  if( prefs->get(DEVICE_AUDIO_ALSA_DEVICE, &pcm_name) != RC_OK )
-               pcm_name = ADM_strdup("plughw:0,0");
-
- /* Allocate the snd_pcm_hw_params_t structure on the stack. */
-    snd_pcm_hw_params_alloca(&hwparams);
-    snd_pcm_sw_params_alloca(&swparams);
-    /* Open PCM. The last parameter of this function is the mode. */
-    /* If this is set to 0, the standard mode is used. Possible   */
-    /* other values are SND_PCM_NONBLOCK and SND_PCM_ASYNC.       */
-    /* If SND_PCM_NONBLOCK is used, read / write access to the    */
-    /* PCM device will return immediately. If SND_PCM_ASYNC is    */
-    /* specified, SIGIO will be emitted whenever a period has     */
-    /* been completely processed by the soundcard.                */
-    if (snd_pcm_open(&pcm_handle, pcm_name, stream, SND_PCM_NONBLOCK) < 0) {
-      fprintf(stderr, "Error opening PCM device %s\n", pcm_name);
-      return(0);
-    }
-    // past this point we got _init=1 -> partially initialized
-    _init=1;
-      /* Init hwparams with full configuration space */
-    if (snd_pcm_hw_params_any(pcm_handle, hwparams) < 0) {
-      fprintf(stderr, "Can not configure this PCM device.\n");
-      ADM_dealloc(pcm_name);
-      return(0);
-    }
-    ADM_dealloc(pcm_name);
-    /* Set access type. This can be either    */
-    /* SND_PCM_ACCESS_RW_INTERLEAVED or       */
-    /* SND_PCM_ACCESS_RW_NONINTERLEAVED.      */
-    /* There are also access types for MMAPed */
-    /* access, but this is beyond the scope   */
-    /* of this introduction.                  */
-    if (snd_pcm_hw_params_set_access(pcm_handle, hwparams, SND_PCM_ACCESS_RW_INTERLEAVED) < 0) {
-      fprintf(stderr, "Error setting access.\n");
-      return(0);
-    }
-
-    /* Set sample format */
-//    if (snd_pcm_hw_params_set_format(pcm_handle, hwparams, SND_PCM_FORMAT_FLOAT) < 0) { //need more test
-    //  fprintf(stderr, "Error setting float format.\n");
-
-#ifdef ADM_BIG_ENDIAN
-    if (snd_pcm_hw_params_set_format(pcm_handle, hwparams, SND_PCM_FORMAT_S16_BE) < 0)
-#else
-    if (snd_pcm_hw_params_set_format(pcm_handle, hwparams, SND_PCM_FORMAT_S16_LE) < 0)
-#endif
-    {
-      fprintf(stderr, "Error setting format.\n");
-      return(0);
-    }
-	//}
-    /* Set sample rate. If the exact rate is not supported */
-    /* by the hardware, use nearest possible rate.         */
-    int exact_rate;
-    dir=0;
-    exact_rate = snd_pcm_hw_params_set_rate_near(pcm_handle, hwparams, &fq, &dir);
-    if (dir != 0) {
-      fprintf(stderr, "The rate %lu Hz is not supported by your hardware.\n  ==> Using %d Hz instead.\n", fq, exact_rate);
-    }
-
-    /* Set number of channels */
-    if (snd_pcm_hw_params_set_channels(pcm_handle, hwparams, channel) < 0) {
-      fprintf(stderr, "Error setting channels.\n");
-      return(0);
-    }
-#if 0
-    	uint32_t periods=fq*2*channel*10;
-	uint32_t periodsize=1;
-    /* Set number of periods. Periods used to be called fragments. */
-    if (snd_pcm_hw_params_set_periods(pcm_handle, hwparams, periods, 0) < 0) {
-      fprintf(stderr, "Error setting periods.\n");
-      return(0);
-    }
-#else
-
- 	unsigned int buffer_time = 800000;
-	int er;
-	unsigned int buff;
-	dir=0;
-
-	if ((er=snd_pcm_hw_params_set_buffer_time_near(pcm_handle, hwparams, &buffer_time, &dir)) < 0)
-	  {
-	    printf("Error : hw_params_set_buffer_time\n");
-	    return(0);
-	  }
-	  // unsigned ?
-	  dir=0;
-	  buff=buffer_time>>2;
-	snd_pcm_hw_params_set_period_time_near(pcm_handle, hwparams, &buff, &dir) ;
-#if 0
-	if (snd_pcm_hw_params_set_period_time_near(pcm_handle, hwparams, buffer_time>>2, 0) < 0)
-	  /* original: alsa_buffer_time/ao_data.bps */
-	  {
-	    printf("Error : hw_params_set_period_time\n");
-	    return(0);
-	  }
-#endif
-#endif
-
-
-/*
-If your hardware does not support a buffersize of 2^n, you can use the function snd_pcm_hw_params_set_buffer_size_near. This works similar to snd_pcm_hw_params_set_rate_near. Now we apply the configuration to the PCM device pointed to by pcm_handle. This will also prepare the PCM device.
-*/
-
-
-    /* Apply HW parameter settings to */
-    /* PCM device and prepare device  */
-    if (snd_pcm_hw_params(pcm_handle, hwparams) < 0) {
-      fprintf(stderr, "Error setting HW params.\n");
-      return(0);
-    }
-
- 	if (snd_pcm_sw_params_current(pcm_handle, swparams) < 0)
-	    {
-	      printf("Error setting SW params.\n");
-	      return(0);
-	    }
-
- 	// be sure that playback starts immediatly (or near)
-	  if (snd_pcm_sw_params_set_avail_min(pcm_handle, swparams, 4) < 0)
-	    {
-	      printf("Error setting set_avail_min \n");
-	      return(0);
-	    }
-
-	  if (snd_pcm_sw_params(pcm_handle, swparams) < 0)
-	    {
-	      printf("Error:snd_pcm_sw_params\n ");
-	      return(0);
-	    }
-
-
-      if ( snd_pcm_prepare(pcm_handle) < 0)
-	{
-	  printf("Error : snd_pcm_prepare\n");
-	  return(0);
-	}
-
-        printf("[Alsa]Success initializing: fq :%u channel %u\n",fq,channel);
-
-    // 2=fully initialized
-    _init=2;
-    return 1;
-}
-
-
-uint8_t alsaAudioDevice::play( uint32_t len, float *data )
-{
-	int ret;
-        int16_t *pcm;
-	/* Write num_frames frames from buffer data to    */
-	/* the PCM device pointed to by pcm_handle.       */
-	/* Returns the number of frames actually written. */
-
-	dither16(data, len, _channels);
-
-	if(2!=_init) return 0;
-        len=len/_channels;
-        pcm=(int16_t *)data;
-    	while(1)
-	{
-        	ret=snd_pcm_writei(pcm_handle, pcm, len);
-		if(ret==(int)len)
-		{
-			return 1;
-		}
-
-		if(ret<0)
-		{
-			switch(ret)
-			{
-				case    -EAGAIN :
-					//wait a bit to flush datas
-					printf("ALSA EAGAIN\n");
-					snd_pcm_wait(pcm_handle, 1000);
-					continue;
-
-				case    -EPIPE:
-					printf("ALSA EPIPE\n");
-					snd_pcm_prepare(pcm_handle);
-					continue;
-				default:
-					printf("ALSA Error %d : Play %s (len=%lu)\n",ret, snd_strerror(ret),len);
-					return 1;
-			}
-		}
-		else
-		{
-			//if(len<2) return 1;
-			len-=ret;
-                        pcm+=(ret*_channels);
-		}
-	}
-	return 1;
-}
-
- uint8_t alsaAudioDevice::stop( void )
- {
- // we have at least a partial initialization
- if(_init)
- {
-       /* Stop PCM device and drop pending frames */
-    snd_pcm_drop(pcm_handle);
-
-    /* Stop PCM device after pending frames have been played */
-    snd_pcm_drain(pcm_handle);
-      if (snd_pcm_close(pcm_handle) < 0)
-      {
-		printf("\n Troubles closing alsa\n");
-
-      }
-     }
-     _init=0;
-     return 1;
-}
-
-uint8_t alsaAudioDevice::setVolume(int volume){
-  snd_mixer_t *mixer_handle;
-  char *pcm_name;
-  uint32_t which_vol;
-  int rc;
-
-	if( prefs->get(DEVICE_AUDIO_ALSA_DEVICE, &pcm_name) != RC_OK )
-		pcm_name = ADM_strdup("hw:0");
-	if( prefs->get(FEATURE_AUDIOBAR_USES_MASTER,&which_vol) != RC_OK )
-		which_vol = 0;
-
-	if( (rc=snd_mixer_open(&mixer_handle,0)) < 0 ){
-		printf("ALSA: snd_mixer_open failed: %d\n",rc);
-		ADM_dealloc(pcm_name);
-		return 0;
-	}
-// MEANX: Cannot use the real name, does not work with dmix
-	if( (rc=snd_mixer_attach(mixer_handle,"hw:0")) < 0 ){
-		printf("ALSA: snd_mixer_attach failed: %d, %s\n",rc, snd_strerror (rc));
-		snd_mixer_close(mixer_handle);
-		ADM_dealloc(pcm_name);
-		return 0;
-	}
-	ADM_dealloc(pcm_name);
-	if( (rc=snd_mixer_selem_register(mixer_handle,NULL,NULL)) < 0 ){
-		printf("ALSA: snd_mixer_selem_register failed: %d\n",rc);
-		snd_mixer_close(mixer_handle);
-		return 0;
-	}
-	if( (rc=snd_mixer_load(mixer_handle)) < 0 ){
-		printf("ALSA: snd_mixer_load failed: %d\n",rc);
-		snd_mixer_close(mixer_handle);
-		return 0;
-	}
-	{ snd_mixer_elem_t *elem;
-	  snd_mixer_selem_id_t *sid;
-	  const char *str;
-		snd_mixer_selem_id_alloca(&sid);
-		for (elem = snd_mixer_first_elem(mixer_handle);
-		     elem;
-		     elem = snd_mixer_elem_next(elem)) {
-			snd_mixer_selem_get_id(elem, sid);
-			str = snd_mixer_selem_id_get_name(sid);
-			if( (which_vol == 0 && !strcmp(str,"PCM"))   ||
-			    (which_vol == 1 && !strcmp(str,"Master"))  ){
-			  long val=0, min=0, max=0;
-				snd_mixer_selem_get_playback_volume_range(elem,&min,&max);
-				/*
-				if( (rc=snd_mixer_selem_get_playback_volume(elem,SND_MIXER_SCHN_FRONT_LEFT,&val)) < 0 ){
-					printf("ALSA: snd_mixer_selem_get_playback_volume failed: %d\n",rc);
-				}
-				printf("ALSA: old val: %lu\n",val*100/max);
-				*/
-				if( (rc=snd_mixer_selem_set_playback_volume_all(elem,volume*max/100)) < 0 ){
-					printf("ALSA: snd_mixer_selem_set_playback_volume_all failed: %d\n",rc);
-				}
-				printf("ALSA: new %s val: %lu\n",(which_vol?"master":"pcm"),volume);
-				break;
-			}
-		}
-	}
-	snd_mixer_close(mixer_handle);
-	return 0;
-}
-
-#else
-void dummy_alsa_fun( void);
-void dummy_alsa_fun( void)
- {
-}
-
-#endif

Deleted: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceALSA.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceALSA.h	2008-07-03 19:29:21 UTC (rev 4183)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceALSA.h	2008-07-03 19:29:25 UTC (rev 4184)
@@ -1,35 +0,0 @@
-/***************************************************************************
-                          ADM_deviceAlsa.h  -  description
-                             -------------------
-    begin                : Sat Sep 28 2002
-    copyright            : (C) 2002 by mean
-    email                : fixounet at free.fr
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-#ifdef ALSA_SUPPORT
-	 class alsaAudioDevice : public audioDevice
-	 {
-		 protected :
-				//	0-> no init done
-				//	1-> device opened but init failed
-				//	2->fully initialized
-				uint32_t _init;
-		  public:
-					alsaAudioDevice(void);
-		     		virtual uint8_t init(uint8_t channel,uint32_t fq);
-	    			virtual uint8_t play(uint32_t len, float *data);
-		      		virtual uint8_t stop(void) ;
-				uint8_t setVolume(int volume);
-		 }     ;
-#endif
-
-

Deleted: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceArts.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceArts.cpp	2008-07-03 19:29:21 UTC (rev 4183)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceArts.cpp	2008-07-03 19:29:25 UTC (rev 4184)
@@ -1,121 +0,0 @@
-/***************************************************************************
-                          ADM_deviceArts.cpp  -  description
-                             -------------------
-    begin                : Sat Sep 28 2002
-    copyright            : (C) 2002 by mean
-    email                : fixounet at free.fr
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-#include "config.h"
-#include "ADM_default.h"
-
-#ifdef USE_ARTS
-#include <artsc.h>
-
-#include "ADM_audiodevice.h"
-#include  "ADM_audiodevice/ADM_deviceoss.h"
-#include  "ADM_audiodevice/ADM_deviceArts.h"
-
-uint8_t artsInitialized=0;
-//_______________________________________________
-//
-//
-//_______________________________________________
-uint8_t  artsAudioDevice::stop(void) {
-		if(!_stream)
-		{
-			printf("\n Arts: no stream\n");
-			return 0;
-		}
-
-		arts_close_stream(_stream);
-		// apparently arts 3.2 alpha does not like this
-	   	//arts_free();
-		_stream=NULL;
-		printf("\n Arts stopped\n");
-    	return 1;
-}
-
-//_______________________________________________
-//
-//
-//_______________________________________________
-uint8_t artsAudioDevice::init(uint8_t channels, uint32_t fq)
-{
-	_channels = channels;
-
-    if(_stream)
-    	{
-			printf("\n purging previous instance\n");
-			stop();
-		}
-    printf("\n Arts  : %lu Hz, %lu channels", fq, channels);
-	if(!artsInitialized)
-	{
-		if(arts_init())
-		{
-			printf("\n Error initializing artsd\n");
-			return 0;
-		}
-		artsInitialized=1;
-	}
-
-	_stream=arts_play_stream(fq, 16,channels, "Avidemux");
-
-	if(!_stream)
-	 {
-		printf("\n Problem setting fq/channel, aborting\n");
-		arts_free();
-		return 0;
-	}
-	arts_stream_set(_stream, ARTS_P_BLOCKING, 1);
-	arts_stream_set(_stream, ARTS_P_BUFFER_TIME, 50); // Ask for 1 sec buffer
-	//arts_stream_set(_stream,  ARTS_P_PACKET_SETTINGS, (11<<16)+10);
-
-
-    return 1;
-}
-
-//_______________________________________________
-//
-//
-//_______________________________________________
-uint8_t artsAudioDevice::play(uint32_t len, float *data)
- {
-
-	if(!_stream) return 0;
-
-	dither16(data, len, _channels);
-
-	return arts_write(_stream, data, len*2);
-}
-
-/*
-** JSC     Mon Nov 28 19:20:06 CET 2005
-** based on http://www.arts-project.org/doc/mcop-doc/artsd-faq.html
-** arts only works with OSS devices (or alsa devices using oss emulation)
-** so we only need OSS support here
-*/
-uint8_t artsAudioDevice::setVolume(int volume){
-#ifdef OSS_SUPPORT
-        ossAudioDevice dev;
-        dev.setVolume(volume);
-#endif
-        return 1;
-}
-
-#else
-void dummy_art_func( void);
-void dummy_art_func( void)
- {
-}
-#endif

Deleted: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceArts.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceArts.h	2008-07-03 19:29:21 UTC (rev 4183)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceArts.h	2008-07-03 19:29:25 UTC (rev 4184)
@@ -1,33 +0,0 @@
-/***************************************************************************
-                          ADM_deviceArts.h  -  description
-                             -------------------
-    begin                : Sat Sep 28 2002
-    copyright            : (C) 2002 by mean
-    email                : fixounet at free.fr
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
- #ifdef USE_ARTS
-                 class artsAudioDevice : public audioDevice
-	 {
-		 protected :
-		 		arts_stream_t _stream;
-		  public:
-		  			artsAudioDevice() {_stream=NULL;}
-				virtual ~artsAudioDevice() {stop();}
-		     		virtual uint8_t init(uint8_t channels, uint32_t fq);
-	    			virtual uint8_t play(uint32_t len, float *data);
-		      		virtual uint8_t stop(void);
-				uint8_t setVolume(int volume);
-		 };
-#endif
-
-

Deleted: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceAudioCore.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceAudioCore.cpp	2008-07-03 19:29:21 UTC (rev 4183)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceAudioCore.cpp	2008-07-03 19:29:25 UTC (rev 4184)
@@ -1,260 +0,0 @@
-/***************************************************************************
-                          ADM_deviceAudioCore.cpp  -  description
-                             -------------------
-    begin                : Sat Sep 28 2002
-    copyright            : (C) 2002 by mean
-    email                : fixounet at free.fr
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#include "config.h"
-
-#ifdef __APPLE__
-#include <stdio.h>
-#include <stdlib.h>
-#include <pthread.h>
-#include <AudioUnit/AudioUnit.h>
-
-#include "ADM_default.h"
-#include "ADM_assert.h"
-#include "ADM_audiodevice.h"
-#include "ADM_audiodevice/ADM_deviceAudioCore.h"
-#include "ADM_osSupport/ADM_debugID.h"
-#define MODULE_NAME  MODULE_ADEVICE
-#include "ADM_osSupport/ADM_debug.h"
-
-#define BUFFER_SIZE (500*48000)
-
-static Component comp = NULL;
-static int16_t audioBuffer[BUFFER_SIZE];
-static AudioUnit theOutputUnit;
-static uint32_t rd_ptr = 0;
-static uint32_t wr_ptr = 0;
-static pthread_mutex_t lock;
-
-static OSStatus MyRenderer(void *inRefCon, AudioUnitRenderActionFlags *inActionFlags,
-	const AudioTimeStamp *inTimeStamp, UInt32 inBusNumber, UInt32 inNumberFrames, AudioBufferList *ioData);
-static OSStatus OverloadListenerProc(AudioDeviceID inDevice, UInt32 inChannel, Boolean isInput,
-	AudioDevicePropertyID inPropertyID, void* inClientData);
-
-OSStatus OverloadListenerProc(AudioDeviceID inDevice, UInt32 inChannel, Boolean isInput,
-	AudioDevicePropertyID inPropertyID, void* inClientData)
-{
-	printf ("[CoreAudio] *** Overload detected on device playing audio ***\n");
-	return noErr;
-}
-
-uint8_t coreAudioDevice::setVolume(int volume) {}
-
-coreAudioDevice::coreAudioDevice(void) 
-{
-	printf("[CoreAudio] Creating CoreAudio device\n");
-	_inUse=0;
-	pthread_mutex_init(&lock, NULL);
-	pthread_mutex_unlock(&lock);
-}
-
-uint8_t coreAudioDevice::stop(void) 
-{
-	if (_inUse)
-		verify_noerr(AudioOutputUnitStop(theOutputUnit));
-
-	// Clean up
-	CloseComponent(theOutputUnit);
-	_inUse=0;
-
-	return 1;
-}
-
-OSStatus MyRenderer(void *inRefCon, AudioUnitRenderActionFlags *inActionFlags, const AudioTimeStamp *inTimeStamp,
-	UInt32 inBusNumber, UInt32 inChannel, AudioBufferList *ioData)
-{
-	pthread_mutex_lock(&lock);
-	uint32_t nb_sample = ioData->mBuffers[0].mDataByteSize >> 1;
-	uint32_t left = 0;
-	uint8_t *in, *out;
-
-	in = (uint8_t*)&audioBuffer[rd_ptr];
-	out = (uint8_t*)ioData->mBuffers[0].mData;
-	aprintf("[CoreAudio] Fill: rd %lu, wr %lu, nb asked %lu\n", rd_ptr, wr_ptr, nb_sample);
-
-	if(wr_ptr>rd_ptr)
-	{
-		left=wr_ptr-rd_ptr-1;
-
-		if(left>nb_sample)
-		{
-			memcpy(out,in,nb_sample*2);
-			rd_ptr+=nb_sample;
-		}
-
-		else
-		{
-			memcpy(out,in,left*2);
-			memset(out+left*2,0,(nb_sample-left)*2);
-			rd_ptr+=left;
-		}
-	}
-	else
-	{
-		// wrap
-		left=BUFFER_SIZE-rd_ptr-1;
-		if(left>nb_sample)
-		{
-			memcpy(out,in,nb_sample*2);
-			rd_ptr+=nb_sample;
-		}
-		else
-		{
-			memcpy(out,in,left*2);
-			out+=left*2;
-			rd_ptr=0;
-			in=(uint8_t *)&audioBuffer[0];
-			nb_sample-=left;
-			if(nb_sample>wr_ptr-1) nb_sample=wr_ptr-1;
-			memcpy(out,in,nb_sample*2);
-			rd_ptr=nb_sample;	
-		}
-	}
-
-	pthread_mutex_unlock(&lock);
-	return 0;
-}
-
-#define CHECK_RESULT(msg) \
-    if (err != noErr) \
-	{ \
-		printf("[CoreAudio] Failed to initialise CoreAudio: " msg "\n"); \
-        return 0; \
-    }
-
-uint8_t coreAudioDevice::init(uint8_t channels, uint32_t fq) 
-{
-	_channels = channels;
-
-	OSStatus err;
-	ComponentDescription desc;
-	AURenderCallbackStruct input;
-	AudioStreamBasicDescription streamFormat;
-	AudioDeviceID theDevice;
-
-	desc.componentType = kAudioUnitType_Output;
-	desc.componentSubType = kAudioUnitSubType_HALOutput;
-	desc.componentManufacturer = kAudioUnitManufacturer_Apple;
-	desc.componentFlags = 0;
-	desc.componentFlagsMask = 0;
-
-	comp = FindNextComponent(NULL, &desc);
-
-	if (comp == NULL)
-	{
-		printf("[CoreAudio] Failed to find component\n");
-		return 0;
-	}
-
-	err = OpenAComponent(comp, &theOutputUnit);
-	CHECK_RESULT("OpenAComponent")
-
-	err = AudioUnitInitialize(theOutputUnit);
-	CHECK_RESULT("AudioUnitInitialize")
-	
-	// Set up a callback function to generate output to the output unit
-	input.inputProc = MyRenderer;
-	input.inputProcRefCon = NULL;
-	
-	err = AudioUnitSetProperty(theOutputUnit, 
-					kAudioUnitProperty_SetRenderCallback,
-					kAudioUnitScope_Global,
-					0,
-					&input, 
-					sizeof(input));
-	CHECK_RESULT("AudioUnitSetProperty [SetInputCallback]")
-
-	streamFormat.mSampleRate = fq;
-	streamFormat.mFormatID = kAudioFormatLinearPCM;
-	streamFormat.mFormatFlags = kLinearPCMFormatFlagIsSignedInteger | kLinearPCMFormatFlagIsPacked;
-
-	streamFormat.mBytesPerPacket = channels * sizeof (UInt16);
-	streamFormat.mFramesPerPacket = 1;
-	streamFormat.mBytesPerFrame = channels * sizeof (UInt16);
-	streamFormat.mChannelsPerFrame = channels;
-	streamFormat.mBitsPerChannel = sizeof (UInt16) * 8;
-	
-	err = AudioUnitSetProperty(theOutputUnit,
-		kAudioUnitProperty_StreamFormat,
-		kAudioUnitScope_Input,
-		0,
-		&streamFormat,
-		sizeof(streamFormat));
-	CHECK_RESULT("AudioUnitSetProperty [StreamFormat]")
-	
-	printf("[CoreAudio] Rendering source:\n");
-	printf("[CoreAudio] \tSampleRate = %f,\n", streamFormat.mSampleRate);
-	printf("[CoreAudio] \tBytesPerPacket = %ld,\n", streamFormat.mBytesPerPacket);
-	printf("[CoreAudio] \tFramesPerPacket = %ld,\n", streamFormat.mFramesPerPacket);
-	printf("[CoreAudio] \tBytesPerFrame = %ld,\n", streamFormat.mBytesPerFrame);
-	printf("[CoreAudio] \tBitsPerChannel = %ld,\n", streamFormat.mBitsPerChannel);
-	printf("[CoreAudio] \tChannelsPerFrame = %ld\n", streamFormat.mChannelsPerFrame);
-
-    return 1;
-}
-
-uint8_t coreAudioDevice::play(uint32_t len, float *data)
- {
- 	// First put stuff into the buffer
-	uint8_t *src;
-	uint32_t left;
-
-	dither16(data, len, _channels);
-
-	pthread_mutex_lock(&lock);
-
-	// Check we have room left
-	if(wr_ptr>=rd_ptr)
-		left=BUFFER_SIZE-(wr_ptr-rd_ptr);
-	else
-		left=rd_ptr-wr_ptr;
-
-	if(len+1>left)
-	{
-		printf("[CoreAudio] Buffer full!\n");
-		pthread_mutex_unlock(&lock);
-		return 0;
-	}
-
-	// We have room left, copy it
-	src=(uint8_t *)&audioBuffer[wr_ptr];
-
-	if(wr_ptr+len<BUFFER_SIZE)
-	{
-		memcpy(src,data,len*2);
-		wr_ptr+=len;
-	}
-	else
-	{
-		left=BUFFER_SIZE-wr_ptr-1;
-		memcpy(src,data,left*2);
-		memcpy(audioBuffer,data+left*2,(len-left)*2);
-		wr_ptr=len-left;	
-	}
-	//aprintf("AudioCore: Putting %lu bytes rd:%lu wr:%lu \n",len*2,rd_ptr,wr_ptr);
-	pthread_mutex_unlock(&lock);	
-
-	_inUse=1;
-	verify_noerr(AudioOutputUnitStart(theOutputUnit));
-
-	return 1;
-}
-#else
-void dummy_ac_func(void);
-void dummy_ac_func(void)
-{
-}
-#endif

Deleted: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceAudioCore.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceAudioCore.h	2008-07-03 19:29:21 UTC (rev 4183)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceAudioCore.h	2008-07-03 19:29:25 UTC (rev 4184)
@@ -1,26 +0,0 @@
-//
-// C++ Interface: ADM_deviceAudioCore
-//
-// Description: 
-//
-//
-// Author: mean <fixounet at free.fr>, (C) 2004
-//
-// Copyright: See COPYING file that comes with this distribution
-//
-//
-#ifdef __APPLE__
-
-	        class coreAudioDevice : public audioDevice
-	 {
-		 protected :
-					uint8_t				_inUse;
-		  public:
-		  				coreAudioDevice(void);
-		     		virtual uint8_t init(uint8_t channels, uint32_t fq);
-	    			virtual uint8_t play(uint32_t len, float *data);
-		      		virtual uint8_t stop(void);
-					virtual uint8_t setVolume(int volume);
-		 }     ;
-
-#endif

Deleted: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceEsd.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceEsd.cpp	2008-07-03 19:29:21 UTC (rev 4183)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceEsd.cpp	2008-07-03 19:29:25 UTC (rev 4184)
@@ -1,111 +0,0 @@
-/***************************************************************************
-                          ADM_deviceEsd.cpp  -  description
-
-  ESD support as output audio device
-                          
-    copyright            : (C) 2005 by mean
-    email                : fixounet at free.fr
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#include "config.h"
-
-#if defined(USE_ESD)
-#include <stdio.h>
-#include <stdlib.h>
-#include <unistd.h>
-#include <errno.h>
-
-#include <fcntl.h>
-#include <sys/ioctl.h>
-#include <esd.h>
-
-#include "ADM_default.h"
-#include "ADM_audiodevice.h"
-#include "ADM_assert.h"
-#include "ADM_audiodevice/ADM_deviceoss.h"
-#include "ADM_audiodevice/ADM_deviceALSA.h"
-#include  "ADM_audiodevice/ADM_deviceEsd.h"
-
-
-//_______________________________________________
-//
-//
-//_______________________________________________
-uint8_t  esdAudioDevice::stop(void) {
-    if (esdDevice > 0) {
-        esd_close(esdDevice);
-        esdDevice = 0;
-    }
-    return 1;
-}
-
-//_______________________________________________
-//
-//
-//_______________________________________________
-uint8_t esdAudioDevice::init(uint8_t channels, uint32_t fq) 
-{
-esd_format_t format;
-_channels = channels;
-
-    format=ESD_STREAM | ESD_PLAY | ESD_BITS16;
-    if(channels==1) format|=ESD_MONO;
-        else format|=ESD_STEREO;
-
-    printf("\n ESD  : %lu Hz, %lu channels", fq, channels);
-    esdDevice=esd_play_stream(format,fq,NULL,"avidemux");
-    if(esdDevice<=0) 
-    {
-        printf("Esd open failed\n");
-        return 0;
-    }
-    printf("Esd open succeedeed\n");
-    /*
-#ifdef ADM_BIG_ENDIAN    
-    int fmt = AFMT_S16_BE;
-#else
-    int fmt = AFMT_S16_LE;
-#endif    
-*/
-    return 1;
-}
-
-//_______________________________________________
-//
-//
-//_______________________________________________
-uint8_t esdAudioDevice::play(uint32_t len, float *data)
-{
-	dither16(data, len, _channels);
-	write(esdDevice, data, len*2);
-	return 1;
-}
-
-uint8_t esdAudioDevice::setVolume(int volume){
-#ifdef OSS_SUPPORT
-	ossAudioDevice dev;
-	dev.setVolume(volume);
-#else
-#ifdef ALSA_SUPPORT
-	alsaAudioDevice dev;
-	dev.setVolume(volume);
-#endif
-#endif
-	return 1;
-}
-
-#else
-void dummy_ess_func( void);
-void dummy_ess_func( void)
- {
-}
-
-#endif

Deleted: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceEsd.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceEsd.h	2008-07-03 19:29:21 UTC (rev 4183)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceEsd.h	2008-07-03 19:29:25 UTC (rev 4184)
@@ -1,29 +0,0 @@
-/***************************************************************************
-                          ADM_deviceEsd.h  -  description
-                             -------------------
-                             Audio device for ESD sound daemon
-    copyright            : (C) 2005 by mean
-    email                : fixounet at free.fr
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#ifdef USE_ESD
-class esdAudioDevice : public audioDevice
-	 {
-		 protected :
-                    int esdDevice;
-		  public:
-		  			esdAudioDevice(void) {esdDevice=-1;}
-		     		virtual uint8_t init(uint8_t channels, uint32_t fq);
-	    			virtual uint8_t play(uint32_t len, float *data);
-		      		virtual uint8_t stop(void);
-				uint8_t setVolume(int volume);
-		 }     ;
-#endif

Deleted: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceJack.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceJack.cpp	2008-07-03 19:29:21 UTC (rev 4183)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceJack.cpp	2008-07-03 19:29:25 UTC (rev 4184)
@@ -1,251 +0,0 @@
-//
-// Author: Mihail Zenkov <mihail.zenkov at gmail.com>, (C) 2007
-//
-// Copyright: See COPYING file that comes with this distribution
-//
-//
-
-#include "config.h"
-
-#if defined(USE_JACK)
-#include <unistd.h>
-#include <stdio.h>
-#include <stdint.h>
-
-#include "ADM_default.h"
-#include "ADM_audiodevice.h"
-#include "ADM_assert.h"
-#include "ADM_audiodevice/ADM_deviceoss.h"
-#include "ADM_audiodevice/ADM_deviceALSA.h"
-#include "ADM_audiodevice/ADM_deviceJack.h"
-
-
-#define BUFSIZE 16385
-
-jackAudioDevice::jackAudioDevice()
-{
-	client = NULL;
-	ringbuffer = NULL;
-	#ifdef USE_SRC
-	src_out_buf = NULL;
-	src_state = NULL;
-	#endif
-}
-
-void jackAudioDevice::jack_shutdown(void *arg)
-{
-	((jackAudioDevice*)arg)->stop();
-}
-
-uint8_t jackAudioDevice::stop()
-{
-	if (client) {
-		printf("[JACK] Stop\n");
-		jack_client_close(client);
-		client = NULL;
-		if (ringbuffer)
-			jack_ringbuffer_free(ringbuffer);
-		ringbuffer = NULL;
-		#ifdef USE_SRC
-		delete src_out_buf;
-		src_out_buf = NULL;
-		src_delete(src_state);
-		src_state = NULL;
-		#endif
-	}
-
-	return 1;
-}
-
-uint8_t jackAudioDevice::init(uint8_t channels, uint32_t fq)
-{
-	jack_status_t status;
-	_channels = channels;
-
-	if (sizeof(jack_default_audio_sample_t) != sizeof(float)) {
-		printf("[JACK] jack_default_audio_sample_t != float\n");
-		return 0;
-	}
-
-	client = jack_client_open("avidemux", JackNullOption, &status, NULL);
-
-	if (client == NULL) {
-		printf("[JACK] jack_client_open() failed, status = 0x%2.0x\n", status);
-		if (status & JackServerFailed)
-			printf(("[JACK] Unable to connect to server\n"));
-		return 0;
-	}
-
-	if (status & JackServerStarted)
-		printf("[JACK] Server started\n");
-
-	if (jack_get_sample_rate(client) == fq) {
-		jack_set_process_callback(client, process_callback, this);
-	} else {
-		printf("[JACK] audio stream sample rate: %i\n", fq);
-		printf("[JACK] jack server sample rate: %i\n", (int)jack_get_sample_rate(client));
-		#ifdef USE_SRC
-			src_out_buf = new float[BUFSIZE * channels];
-			src_state = src_new(SRC_SINC_FASTEST, channels, NULL);
-			if (!src_state) {
-				printf("[JACK] Can't init libsamplerate\n");
-				stop();
-				return 0;
-			}
-			src_data.data_out = src_out_buf;
-			src_data.output_frames = BUFSIZE;
-			src_data.src_ratio = jack_get_sample_rate(client) / (double)fq;
-			src_data.end_of_input = 0;
-//			printf("[JACK] ratio: %f\n", src_data.src_ratio);
-		#else
-			printf("[JACK] For play this, you need avidemux compiled with libsamplerate support\n");
-			stop();
-			return 0;
-		#endif
-	}
-
-	ringbuffer = jack_ringbuffer_create(BUFSIZE * channels * sizeof(jack_default_audio_sample_t));
-
-	jack_set_process_callback(client, process_callback, this);
-	jack_on_shutdown(client, jack_shutdown, this);
-
-	char name[10];
-	for (int i = 0; i < channels; i++) {
-		snprintf(name, 10, "output-%d", i);
-		ports[i] = jack_port_register(client, name, JACK_DEFAULT_AUDIO_TYPE, JackPortIsOutput, 0);
-		if (!ports[i]) {
-			printf("[JACK] Can't create new port\n");
-			stop();
-			return 0;
-		}
-	}
-
-	if (jack_activate(client)) {
-		printf("[JACK] Cannot activate client\n");
-		stop();
-		return 0;
-	}
-
-	const char **input_ports = jack_get_ports(client, NULL, NULL, JackPortIsInput|JackPortIsPhysical);
-
-	for (int i = 0; i < channels && input_ports[i]; i++) {
-		if (jack_connect(client, jack_port_name(ports[i]), input_ports[i]))
-			printf("[JACK] Connecting failed\n");
-	}
-
-	if (channels == 1 && input_ports[1])
-		if (jack_connect(client, jack_port_name(ports[0]), input_ports[1]))
-			printf("[JACK] Connecting failed\n");
-
-	return 1;
-}
-
-int jackAudioDevice::process(jack_nframes_t nframes)
-{
-	jack_default_audio_sample_t *pbuf[_channels];
-	for (int c = 0; c < _channels; c++)
-		pbuf[c] = (jack_default_audio_sample_t *) jack_port_get_buffer(ports[c], nframes);
-
-	size_t read = jack_ringbuffer_read_space(ringbuffer) / sizeof(jack_default_audio_sample_t) / _channels;
-
-	if (read > nframes)
-		read = nframes;
-
-	int i;
-	for (i = 0; i < read; i++)
-		for (int c = 0; c < _channels; c++) {
-			jack_ringbuffer_read(ringbuffer, (char *)pbuf[c], sizeof(jack_default_audio_sample_t));
-			pbuf[c]++;
-		}
-
-	for (; i < nframes; i++)
-		for (int c = 0; c < _channels; c++) {
-			pbuf[c] = 0;
-			pbuf[c]++;
-		}
-
-	if (read != nframes)
-		printf("[JACK] UNDERRUN!\n");
-
-	return 0;
-}
-
-int jackAudioDevice::process_callback(jack_nframes_t nframes, void* arg)
-{
-	return ((jackAudioDevice*)arg)->process(nframes);
-}
-
-
-uint8_t jackAudioDevice::play(uint32_t len, float *data)
-{
-//	static int min = 5000;
-	static int sleep = (int)((float)BUFSIZE / jack_get_sample_rate(client) / 2. * 1000000.);
-	size_t write;
-	float writef;
-	len /= _channels;
-
-	#ifdef USE_SRC
-	if (src_out_buf) {
-		while (len) {
-			writef = jack_ringbuffer_write_space(ringbuffer);
-			writef /= src_data.src_ratio * sizeof(jack_default_audio_sample_t) * _channels;
-			write = (size_t)writef;
-			if (write >= len) {
-				src_data.data_in = data;
-				src_data.input_frames = len;
-				src_process(src_state, &src_data);
-				jack_ringbuffer_write(ringbuffer,
-					(char *)src_out_buf,
-					src_data.output_frames_gen * sizeof(jack_default_audio_sample_t) * _channels);
-/*
-				if (len != src_data.input_frames_used)
-					printf("[JACK] len %i != %i input_frames_used\n", len, src_data.input_frames_used);
-				if (len < min)
-					min = len;
-				printf("[JACK] %i %i %i %f %i\n",min, src_data.input_frames_used, src_data.output_frames_gen, writef, len);
-				data += src_data.input_frames_used * _channels;
-				len -= src_data.input_frames_used;
-*/
-				return 1;
-			} else {
-				printf("[JACK] OVERRUN!\n");
-				usleep(sleep);
-			}
-		}
-	} else
-	#endif
-	while (len) {
-		writef = jack_ringbuffer_write_space(ringbuffer);
-		writef /= sizeof(jack_default_audio_sample_t) * _channels;
-		write = (size_t)writef;
-		if (write >= len) {
-			jack_ringbuffer_write(ringbuffer, (char *)data, len * sizeof(jack_default_audio_sample_t) * _channels);
-			return 1;
-		} else {
-			printf("[JACK] OVERRUN!\n");
-			usleep(sleep);
-		}
-	}
-
-        return 1;
-}
-
-uint8_t jackAudioDevice::setVolume(int volume){
-#ifdef OSS_SUPPORT
-	ossAudioDevice dev;
-	dev.setVolume(volume);
-#else
-#ifdef ALSA_SUPPORT
-	alsaAudioDevice dev;
-	dev.setVolume(volume);
-#endif
-#endif
-	return 1;
-}
-
-#else
-void dummy_jack_func( void);
-void dummy_jack_func( void)
-{
-}
-#endif

Deleted: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceJack.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceJack.h	2008-07-03 19:29:21 UTC (rev 4183)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceJack.h	2008-07-03 19:29:25 UTC (rev 4184)
@@ -1,43 +0,0 @@
-//
-// Author: Mihail Zenkov <mihail.zenkov at gmail.com>, (C) 2007
-//
-// Copyright: See COPYING file that comes with this distribution
-//
-//
-
-#ifdef USE_JACK
-
-
-#include <jack/jack.h>
-#include <jack/ringbuffer.h>
-
-#ifdef USE_SRC
-#include <samplerate.h>
-#endif
-
-#define MAX_CHANNELS 9
-
-class jackAudioDevice : public audioDevice
-{
-public:
-	jackAudioDevice();
-	virtual uint8_t init(uint8_t channel,uint32_t fq);
-	virtual uint8_t play(uint32_t len, float *data);
-	virtual uint8_t stop();
-	uint8_t setVolume(int volume);
-	int process(jack_nframes_t nframes);
-
-protected:
-	static void jack_shutdown(void *arg);
-	static int process_callback(jack_nframes_t nframes, void *arg);
-
-	jack_port_t *ports[MAX_CHANNELS];
-	jack_client_t *client;
-	jack_ringbuffer_t *ringbuffer;
-	#ifdef USE_SRC
-	float *src_out_buf;
-	SRC_STATE *src_state;
-	SRC_DATA src_data;
-	#endif
-};
-#endif

Deleted: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceSDL.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceSDL.cpp	2008-07-03 19:29:21 UTC (rev 4183)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceSDL.cpp	2008-07-03 19:29:25 UTC (rev 4184)
@@ -1,276 +0,0 @@
-//
-// C++ Implementation: ADM_deviceSDL
-//
-// Description: 
-//
-//
-// Author: mean <fixounet at free.fr>, (C) 2004
-//
-// Copyright: See COPYING file that comes with this distribution
-//
-//
-
-#include "config.h"
-#include <errno.h>
-
-
-#include "ADM_default.h"
-  
- 
-#ifdef USE_SDL
-#include "SDL.h"
-
-
-
-#include "ADM_audiodevice.h"
-#include "ADM_audiodevice/ADM_deviceoss.h"
-#include "ADM_audiodevice/ADM_deviceALSA.h"
-#include "ADM_audiodevice/ADM_deviceSDL.h"
-#include "ADM_osSupport/ADM_debugID.h"
-#define MODULE_NAME  MODULE_ADEVICE
-#include "ADM_osSupport/ADM_debug.h"
-
-static int16_t  		*audioBuffer=NULL;
-static uint32_t 		frameCount=0;
-static uint32_t			rd_ptr=0;
-static uint32_t			wr_ptr=0;
-
-extern "C"
-{
-static void SDL_callback(void *userdata, Uint8 *stream, int len);
-}
-
-#ifdef __APPLE__
-#define BUFFER_SIZE (500*48000)
-#else
-#define BUFFER_SIZE (2*48000)
-#endif
-
-//_______________________________________________
-//
-//_______________________________________________
-
-
-//_______________________________________________
-//
-//_______________________________________________
-
-sdlAudioDevice::sdlAudioDevice(void) 
-{
-	printf("Creating SDL Audio device\n");
-	_inUse=0;
-	wr_ptr=rd_ptr=0;
-}
-//_______________________________________________
-//
-//_______________________________________________
-uint8_t  sdlAudioDevice::stop(void) 
-{
-	if(audioBuffer)
-	{
-		delete [] audioBuffer;
-		audioBuffer=NULL;
-	}
-	
-		SDL_PauseAudio(1); // First pause it
-		SDL_CloseAudio();
-		SDL_QuitSubSystem(SDL_INIT_AUDIO);
-	
-	// Clean up
-	//CloseComponent(theOutputUnit);
-	_inUse=0;
-    	wr_ptr=rd_ptr=0;
-	printf("Closing SDL audio\n");
-	return 1;
-}
-//_______________________________________________
-//  We have to fill len data to stream pointer
-//_______________________________________________
-void SDL_callback(void *userdata, Uint8 *stream, int len)
-{
-
-
-	
-	uint32_t nb_sample=len>>1;
-	uint32_t left=0;
-	uint8_t *in,*out;
-
-	in=(uint8_t *)&audioBuffer[rd_ptr];
-	out=(uint8_t *)stream;
-	aprintf("sdl : Fill : rd %lu wr:%lu nb asked:%lu \n",rd_ptr,wr_ptr,nb_sample);
-	if(wr_ptr>rd_ptr)
-	{
-		left=wr_ptr-rd_ptr-1;	
-		if(left>nb_sample)
-		{
-			memcpy(out,in,nb_sample*2);
-			rd_ptr+=nb_sample;
-		}
-		else
-		{
-			memcpy(out,in,left*2);
-			memset(out+left*2,0,(nb_sample-left)*2);
-			rd_ptr+=left;
-		}
-	}
-	else
-	{
-		// wrap
-		left=BUFFER_SIZE-rd_ptr-1;
-		if(left>nb_sample)
-		{
-			memcpy(out,in,nb_sample*2);
-			rd_ptr+=nb_sample;
-		}
-		else
-		{
-			memcpy(out,in,left*2);
-			out+=left*2;
-			rd_ptr=0;
-			in=(uint8_t *)&audioBuffer[0];
-			nb_sample-=left;
-			if(nb_sample>wr_ptr-1) nb_sample=wr_ptr-1;
-			memcpy(out,in,nb_sample*2);
-			rd_ptr=nb_sample;	
-		}
-	}
-	
-
-}
-
-//_______________________________________________
-//
-//
-//_______________________________________________
-uint8_t sdlAudioDevice::init(uint8_t channels, uint32_t fq) 
-{
-SDL_AudioSpec spec,result;
-_channels = channels;
-		
-		printf("[SDL] Opening audio, fq=%d\n",fq);
-
-		if(_inUse) 
-		{
-			printf("[SDL] Already running ?\n");
-			return 1; // ???
-		}
-		
-		if (SDL_InitSubSystem(SDL_INIT_AUDIO) < 0) 
-		{
-			printf("[SDL] FAILED initialising Audio subsystem\n");
-			printf("[SDL] ERROR: %s\n", SDL_GetError());
-			return 0;
-		}
-		memset(&spec,0,sizeof(spec));
-		memset(&result,0,sizeof(result));
-		spec.freq=fq;
-		spec.channels=channels;
-		spec.samples=65536>>4; // 1 second worth of audio
-		spec.callback=SDL_callback;
-		spec.userdata=NULL;
-		spec.format=AUDIO_S16;
-	
-		int res=SDL_OpenAudio(&spec,&result);
-		if(res<0)
-		{
-			printf("[SDL] Audio device FAILED to open\n");
-			printf("[SDL] ERROR: %s\n", SDL_GetError());
-
-			printf("fq   %d \n",spec.freq);
-			printf("chan %d \n", spec.channels);
-			printf("samples %d \n",spec.samples);
-			printf("format %d \n",spec.format);
-			
-			printf("fq   %d \n",result.freq);
-			printf("chan %d \n", result.channels);
-			printf("samples %d \n",result.samples);
-			printf("format %d \n",result.format);
-
-			return 0;
-		}
-		
-	frameCount=0;
-	
-	audioBuffer=new int16_t[BUFFER_SIZE]; // between hald a sec and a sec should be enough :)
-	
-    return 1;
-}
-
-//_______________________________________________
-//
-//
-//_______________________________________________
-uint8_t sdlAudioDevice::play(uint32_t len, float *data)
- {
- 	// First put stuff into the buffer
-	uint8_t *src;
-	uint32_t left;
-
-	dither16(data, len, _channels);
-	
-	// Check we have room left
-	if(wr_ptr>=rd_ptr)
-	{
-		left=BUFFER_SIZE-(wr_ptr-rd_ptr);
-	}
-	else
-	{
-		left=rd_ptr-wr_ptr;
-	}
-	if(len+1>left)
-	{
-		printf("AudioCore:Buffer full!\n");
-		
-		return 0;
-	}
-
-	// We have room left, copy it
-	src=(uint8_t *)&audioBuffer[wr_ptr];
-	
-	SDL_LockAudio();
-	
-	if(wr_ptr+len<BUFFER_SIZE)
-	{
-		memcpy(src,data,len*2);
-		wr_ptr+=len;
-	}
-	else
-	{
-		left=BUFFER_SIZE-wr_ptr-1;
-		memcpy(src,data,left*2);
-		memcpy(audioBuffer,data+left*2,(len-left)*2);
-		wr_ptr=len-left;	
-	}
-	
-	//aprintf("AudioSDL: Putting %lu bytes rd:%lu wr:%lu \n",len*2,rd_ptr,wr_ptr);
-	SDL_UnlockAudio();
- 	if(!frameCount)
-	{
-		_inUse=1;
-		SDL_PauseAudio(0);;
-	}
-	
-	return 1;
-}
-
-uint8_t sdlAudioDevice::setVolume(int volume){
-#ifdef OSS_SUPPORT
-        ossAudioDevice dev;
-        dev.setVolume(volume);
-#else
-#ifdef ALSA_SUPPORT
-        alsaAudioDevice dev;
-        dev.setVolume(volume);
-#endif
-#endif
-	return 1;
-}
-
-#else
-void dummy_as_func( void);
-void dummy_as_func( void)
- {
-}
-
-#endif
-

Deleted: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceSDL.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceSDL.h	2008-07-03 19:29:21 UTC (rev 4183)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceSDL.h	2008-07-03 19:29:25 UTC (rev 4184)
@@ -1,26 +0,0 @@
-//
-// C++ Interface: ADM_deviceSDL
-//
-// Description: 
-//
-//
-// Author: mean <fixounet at free.fr>, (C) 2004
-//
-// Copyright: See COPYING file that comes with this distribution
-//
-//
-#ifdef USE_SDL
-
-	        class sdlAudioDevice : public audioDevice
-	 {
-		 protected :
-					uint8_t				_inUse;
-		  public:
-		  				sdlAudioDevice(void);
-		     		virtual uint8_t init(uint8_t channels, uint32_t fq);
-	    			virtual uint8_t play(uint32_t len, float *data);
-		      		virtual uint8_t stop(void);
-				uint8_t setVolume(int volume);
-		 }     ;
-
-#endif

Deleted: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceWin32.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceWin32.cpp	2008-07-03 19:29:21 UTC (rev 4183)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceWin32.cpp	2008-07-03 19:29:25 UTC (rev 4184)
@@ -1,192 +0,0 @@
-//
-// C++ Implementation: ADM_deviceWin32
-//
-// Description: 
-// C++ Implementation: ADM_deviceWin32
-// Use MM layer to output sound
-//
-// Author: mean <fixounet at free.fr>, (C) 2004
-//
-// Copyright: See COPYING file that comes with this distribution
-//
-
-#include "config.h"
-
-#ifdef __WIN32
-#include <stdio.h>
-#include <stdlib.h>
-#include <errno.h>
-#include <windows.h>
-
-#include "fourcc.h" 
-#include "ADM_assert.h"
-#include "ADM_audiodevice.h"
-#include "ADM_audiodevice/ADM_deviceWin32.h"
-
-#define MODULE_NAME  MODULE_ADEVICE
-#include "ADM_osSupport/ADM_debugID.h"
-#include "ADM_osSupport/ADM_debug.h"
-
-#define NB_BUCKET 8
-
-static uint32_t bucketSize;
-static HWAVEOUT myDevice;
-static MMRESULT myError;
-
-static void handleMM(MMRESULT err);
-
-WAVEHDR waveHdr[NB_BUCKET];	
-
-win32AudioDevice::win32AudioDevice(void) 
-{
-	printf("[Win32] Creating audio device\n");
-	_inUse=0;
-}
-
-uint8_t win32AudioDevice::stop(void) 
-{
-	if (!_inUse)
-		return 0;
-
-	printf("[Win32] Closing audio\n");
-
-	waveOutReset(myDevice);		
-
-	for (uint32_t i = 0; i < NB_BUCKET; i++)
-		waveOutUnprepareHeader(myDevice, &waveHdr[i], sizeof(WAVEHDR));
-
-	myError = waveOutClose(myDevice);
-
-	if (myError != MMSYSERR_NOERROR)
-	{
-		printf("[Win32] Close failed %d\n", myError);
-		handleMM(myError);
-		return 0;
-	}
-
-	for (uint32_t i = 0; i < NB_BUCKET; i++)
-		delete[] waveHdr[i].lpData;
-
-	_inUse=0;
-	myDevice = NULL;
-
-	return 1;
-}
-
-uint8_t win32AudioDevice::init(uint8_t channels, uint32_t fq) 
-{
-	printf("[Win32] Opening Audio, channels=%u freq=%u\n",channels, fq);
-
-	if (_inUse) 
-	{
-		printf("[Win32] Already running?\n");
-		return 0;
-	}
-
-	_inUse = 1;
-	_channels = channels;
-	bucketSize = channels * fq;
-
-	WAVEFORMATEX wav;
-
-	memset(&wav, 0, sizeof(WAVEFORMATEX));
-
-	wav.wFormatTag = WAVE_FORMAT_PCM;
-	wav.nSamplesPerSec = fq;
-	wav.nChannels = channels;
-	wav.nBlockAlign = 2 * channels;
-	wav.nAvgBytesPerSec = 2 * channels * fq;
-	wav.wBitsPerSample = 16;
-
-	myError = waveOutOpen(&myDevice, WAVE_MAPPER, &wav, NULL, NULL, CALLBACK_NULL);
-
-	if (MMSYSERR_NOERROR != myError)
-	{
-		printf("[Win32] waveOutOpen failed\n");
-		handleMM(myError);
-		return 0;
-	}
-
-	for (uint32_t i = 0; i < NB_BUCKET; i++)
-	{
-		memset(&waveHdr[i], 0, sizeof(WAVEHDR));
-
-		waveHdr[i].dwBufferLength = bucketSize;
-		waveHdr[i].lpData = (char*)new uint8_t[bucketSize];
-
-		if (waveOutPrepareHeader(myDevice, &waveHdr[i], sizeof(WAVEHDR)) != MMSYSERR_NOERROR)
-			printf("[Win32] waveOutPrepareHeader error\n");
-
-		waveHdr[i].dwBufferLength = 0;
-		waveHdr[i].dwFlags |= WHDR_DONE;
-	}
-
-	return 1;
-}
-
-uint8_t  win32AudioDevice::setVolume(int volume) 
-{
-	uint32_t value;
-
-	value = (0xffff * volume) / 100;
-	value = value + (value << 16);
-
-	waveOutSetVolume(myDevice, value);
-
-	return 1;
-}
-
-uint8_t win32AudioDevice::play(uint32_t len, float *data)
-{
-	if (len == 0)
-		return 1;
-
-	dither16(data, len, _channels);
-	len *= 2;
-	uint8_t success = 0;
-
-	for (uint32_t i = 0; i < NB_BUCKET; i++)
-	{
-		if (waveHdr[i].dwFlags & WHDR_DONE)
-		{
-			waveHdr[i].dwFlags &= ~WHDR_DONE;
-
-			if (len > bucketSize)
-				waveHdr[i].dwBufferLength = bucketSize;
-			else
-				waveHdr[i].dwBufferLength = len;
-
-			memcpy(waveHdr[i].lpData, data, waveHdr[i].dwBufferLength);
-			data += waveHdr[i].dwBufferLength;
-			len -= waveHdr[i].dwBufferLength;
-
-			if (waveOutWrite(myDevice, &waveHdr[i], sizeof(WAVEHDR)) == MMSYSERR_NOERROR)
-				success = 1;
-			else
-				break;
-		}
-
-		if (len == 0)
-			break;
-	}
-
-	if (len != 0)
-	{
-		printf("[Win32] No audio buffer available, %u bytes discarded\n", len);
-		return 0;
-	}
-
-	return success;
-}
-
-void handleMM(MMRESULT err)
-{
-#define ERMM(x) if(err==x) printf("[Win32] "#x"\n");
-
-	ERMM(MMSYSERR_ALLOCATED);
-	ERMM(MMSYSERR_BADDEVICEID);
-	ERMM(MMSYSERR_NODRIVER);
-	ERMM(WAVERR_BADFORMAT);
-	ERMM(WAVERR_SYNC);
-}
-#endif

Deleted: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceWin32.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceWin32.h	2008-07-03 19:29:21 UTC (rev 4183)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceWin32.h	2008-07-03 19:29:25 UTC (rev 4184)
@@ -1,26 +0,0 @@
-//
-// C++ Interface: ADM_deviceWin32
-//
-// Description: 
-//
-//
-// Author: mean <fixounet at free.fr>, (C) 2004
-//
-// Copyright: See COPYING file that comes with this distribution
-//
-//
-#ifdef __WIN32
-
-class win32AudioDevice : public audioDevice
-{
-protected:
-	uint8_t	_inUse;
-public:
-	win32AudioDevice(void);
-	virtual uint8_t init(uint8_t channels, uint32_t fq);
-	virtual uint8_t play(uint32_t len, float *data);
-	virtual uint8_t stop(void);
-	virtual uint8_t setVolume(int volume);
-};
-
-#endif

Deleted: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceoss.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceoss.cpp	2008-07-03 19:29:21 UTC (rev 4183)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceoss.cpp	2008-07-03 19:29:25 UTC (rev 4184)
@@ -1,179 +0,0 @@
-/***************************************************************************
-                          ADM_deviceoss.cpp  -  description
-                             -------------------
-    begin                : Sat Sep 28 2002
-    copyright            : (C) 2002 by mean
-    email                : fixounet at free.fr
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#include "config.h"
-
-#ifdef OSS_SUPPORT
-#include <stdio.h>
-#include <stdlib.h>
-#include <unistd.h>
-#include <errno.h>
-
-#include <fcntl.h>
-#include <sys/ioctl.h>
-
-#if defined(ADM_BSD_FAMILY) && !defined(__FreeBSD__) && !defined(__OpenBSD__)
-	#include <soundcard.h>
-	const char *dsp = DEVOSSAUDIO;;
-
-#elif defined(__OpenBSD__)
-	#include <soundcard.h>
-	const char *dsp = "/dev/audio";
-	const char *device_mixer = "/dev/mixer";
-
-#else
-	#include <sys/soundcard.h>
-	const char *dsp = "/dev/dsp";
-        const char *device_mixer = "/dev/mixer";
-
-#endif
- 
- 
-
-#include "ADM_default.h"
-#include "ADM_audiodevice.h"
-#include "ADM_assert.h"
-#include  "ADM_audiodevice/ADM_deviceoss.h"
-#include "DIA_coreToolkit.h"
-#include "prefs.h"
-
-//_______________________________________________
-//
-//
-//_______________________________________________
-uint8_t  ossAudioDevice::setVolume(int volume) 
-{
-        int fd;
-	int ret;
-	uint32_t which_vol = 0;
-
-	prefs->get(FEATURE_AUDIOBAR_USES_MASTER,&which_vol);
-        fd=open(device_mixer,O_RDONLY);
-        if(!fd)
-        {
-                printf("OSS: cannot open mixer\n");
-                return 0;
-        }
-        printf("Oss: New %s volume %d\n",(which_vol?"master":"pcm"),volume);
-        // Assuming stereo
-        volume=volume+(volume<<8);
-	if( which_vol ){
-        	ret = ioctl(fd, MIXER_WRITE(SOUND_MIXER_VOLUME), &volume);
-	}else{
-        	ret = ioctl(fd, MIXER_WRITE(SOUND_MIXER_PCM   ), &volume);
-	}
-        close(fd);
-
-	if( ret ){
-		if( errno == EBADF ){
-			printf("set mixer failed: %u (possible access issue)\n",errno);
-		}else{
-			printf("set mixer failed: %u\n",errno);
-		}
-	}
-        return 1;
-
-}
-
-//_______________________________________________
-//
-//
-//_______________________________________________
-uint8_t  ossAudioDevice::stop(void) {
-    if (oss_fd > 0) {
-        close(oss_fd);
-        oss_fd = 0;
-    }
-    return 1;
-}
-
-//_______________________________________________
-//
-//
-//_______________________________________________
-uint8_t ossAudioDevice::init(uint8_t channels, uint32_t fq) 
-{
-	_channels = channels;
- 
-    printf("\n OSS  : %lu Hz, %lu channels", fq, channels);
-    // open OSS device
-    oss_fd = open(dsp, O_WRONLY | O_NONBLOCK);
-    if (oss_fd == -1) {
-	if( errno == EACCES )
-	{
-          GUI_Error_HIG(QT_TR_NOOP("Could not open OSS audio device"), QT_TR_NOOP("Check the permissions for /dev/dsp."));
-	  }
-	else
-           printf("\n Error initializing OSS: Error : %d", errno);
-        return 0;
-    }
-    // seems ok, set up audio 
-    if (ioctl (oss_fd, SNDCTL_DSP_SPEED, &fq) < 0) {
-        printf("\n Error setting up OSS(SPEED): Error : %d", errno);
-        return 0;
-    }
-    if (channels > 2) {
-        if (ioctl (oss_fd, SNDCTL_DSP_CHANNELS, &channels) < 0) {
-	    printf("\n Error setting up OSS(CHANNELS): Error : %d", errno);
-	    return 0;
-        }
-    } else {
-        int chan = channels - 1;
-        if (ioctl (oss_fd, SNDCTL_DSP_STEREO, &chan) < 0) {
-	    printf("\n Error setting up OSS(STEREO): Error : %d", errno);
-	    return 0;
-        }
-    }
-#ifdef ADM_BIG_ENDIAN    
-    int fmt = AFMT_S16_BE;
-#else
-    int fmt = AFMT_S16_LE;
-#endif    
-    if (ioctl (oss_fd, SNDCTL_DSP_SETFMT, &fmt) < 0) {
-        printf("\n Error setting up OSS(FORMAT): Error : %d", errno);
-        return 0;
-    }
-
-    return 1;
-}
-
-//_______________________________________________
-//
-//
-//_______________________________________________
-uint8_t ossAudioDevice::play(uint32_t len, float *data)
-{
-	uint32_t w;
-
-	if (!oss_fd)
-		return 0;
-
-	dither16(data, len, _channels);
-
-	w = write(oss_fd, data, len*2);
-        if(w!=len*2)
-        {
-          printf("[OSS] Warning : %u / %u\n",w,len*2); 
-        }
-	return 1;
-}
-#else
-void dummy_oss_func( void);
-void dummy_oss_func( void)
- {
-}
-
-#endif

Deleted: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceoss.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceoss.h	2008-07-03 19:29:21 UTC (rev 4183)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceoss.h	2008-07-03 19:29:25 UTC (rev 4184)
@@ -1,29 +0,0 @@
-/***************************************************************************
-                          ADM_deviceoss.h  -  description
-                             -------------------
-    begin                : Sat Sep 28 2002
-    copyright            : (C) 2002 by mean
-    email                : fixounet at free.fr
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#ifdef OSS_SUPPORT
-class ossAudioDevice : public audioDevice
-{
-protected :
-                                int oss_fd;
-public:
-                                        ossAudioDevice(void) {oss_fd=0;}
-                        virtual uint8_t init(uint8_t channels, uint32_t fq);
-                        virtual uint8_t play(uint32_t len, float *data);
-                        virtual uint8_t stop(void);
-			uint8_t setVolume(int volume);
-}     ;
-#endif

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/CMakeLists.txt	2008-07-03 19:29:21 UTC (rev 4183)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/CMakeLists.txt	2008-07-03 19:29:25 UTC (rev 4184)
@@ -1,11 +1,11 @@
 SET(ADM_audiodevice_SRCS 
-	ADM_audiodevice.cpp  ADM_deviceArts.cpp       ADM_deviceEsd.cpp  ADM_deviceSDL.cpp    oss_out.cpp
-	ADM_deviceALSA.cpp   ADM_deviceAudioCore.cpp  ADM_deviceoss.cpp  ADM_deviceWin32.cpp  ADM_deviceJack.cpp)
+	ADM_audiodevice.cpp  
+	)
 
 ADD_ADM_LIB_ALL_TARGETS(ADM_audiodevice ${ADM_audiodevice_SRCS})
 
-SDLify(ADM_deviceSDL.cpp)
+#SDLify(ADM_deviceSDL.cpp)
 
-IF (USE_ARTS)
-	ADD_CFLAGS_ALL_TARGETS(ADM_audiodevice ${ARTS_CFLAGS})
-ENDIF (USE_ARTS)
\ No newline at end of file
+#IF (USE_ARTS)
+	#ADD_CFLAGS_ALL_TARGETS(ADM_audiodevice ${ARTS_CFLAGS})
+#ENDIF (USE_ARTS)

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/audio_out.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/audio_out.h	2008-07-03 19:29:21 UTC (rev 4183)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/audio_out.h	2008-07-03 19:29:25 UTC (rev 4184)
@@ -17,60 +17,10 @@
 
 #ifndef AUDIOOUPUT_H
 #define AUDIOOUPUT_H
-//#include "avi_vars.h"
-#ifdef HAVE_AUDIO
-typedef enum
-{
-	DEVICE_OSS=1,
-	DEVICE_DUMMY,
-	DEVICE_ARTS,
-	DEVICE_ALSA,
-	DEVICE_COREAUDIO,
-	DEVICE_SDL,
-	DEVICE_WIN32,
-	DEVICE_ESD,
-	DEVICE_JACK
-}AUDIO_DEVICE;
 
-typedef struct 
-{
-	AUDIO_DEVICE id;
-	const char	     *name;
-}DEVICELIST;
-#define MKADID(x) {DEVICE_##x,#x}
-static const DEVICELIST audioDeviceList[]=
-{
-	
-#ifdef OSS_SUPPORT	
-	MKADID(OSS),
-#endif	
-#ifdef USE_ARTS
-	MKADID(ARTS),
-#endif	
-#ifdef ALSA_SUPPORT
-	MKADID(ALSA),
-#endif	
-#ifdef __APPLE__
-	MKADID(COREAUDIO),
-#endif
-#if	defined(USE_SDL) && !defined(__WIN32)	
-	MKADID(SDL),
-#endif	
-#ifdef __WIN32	
-	MKADID(WIN32),
-#endif	
-#ifdef USE_ESD	
-	MKADID(ESD),
-#endif	
-#ifdef USE_JACK	
-	MKADID(JACK),
-#endif	
+typedef int AUDIO_DEVICE;
 
-	MKADID(DUMMY)
-};
-
-
-void 		AVDM_audioSave( void );
+void 		AVDM_audioSave( void ); /// Save in Prefs the current audio Device
 void 		AVDM_audioInit( void );
 void		AVDM_cleanup(void);
 void 		AVDM_switch( AUDIO_DEVICE action );
@@ -82,4 +32,4 @@
 uint8_t         AVDM_setVolume(int volume);
 
 #endif
-#endif
+

Deleted: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/oss_out.cpp
===================================================================

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_plugins.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_plugins.cpp	2008-07-03 19:29:21 UTC (rev 4183)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_plugins.cpp	2008-07-03 19:29:25 UTC (rev 4184)
@@ -19,6 +19,8 @@
 /* Functions we need to get infos */
 uint32_t ADM_ad_getNbFilters(void);
 bool     ADM_ad_getFilterInfo(int filter, const char **name, uint32_t *major,uint32_t *minor,uint32_t *patch);
+uint32_t ADM_av_getNbDevices(void);
+bool     ADM_av_getDeviceInfo(int filter, const char **name, uint32_t *major,uint32_t *minor,uint32_t *patch);
 uint32_t ADM_ve_getNbEncoders(void);
 bool     ADM_ve_getEncoderInfo(int filter, const char **name, uint32_t *major,uint32_t *minor,uint32_t *patch);
 
@@ -32,6 +34,7 @@
 {
     uint32_t aNbPlugin=ADM_ad_getNbFilters();
     uint32_t veNbPlugin=ADM_ve_getNbEncoders();
+    uint32_t avNbPlugin=ADM_av_getNbDevices();
 
     // Audio Plugins
 
@@ -88,17 +91,48 @@
             veText[i]=new diaElemReadOnlyText(infoString,versionString);
             frameVE.swallow(veText[i]);
     }
+
     diaElem *diaVE[]={&frameVE};
     diaElemTabs tabVE(QT_TR_NOOP("Video Encoder"),1,diaVE);
 
+    // Audio Device
+    printf("[AudioDevice Plugins] Found %u plugins\n",avNbPlugin);
+    diaElemReadOnlyText *avText[avNbPlugin];
+    diaElemFrame frameAV(QT_TR_NOOP("Audio Device Plugins"));
+    
+ for(int i=0;i<avNbPlugin;i++)
+    {
+        const char *name;
+        uint32_t major,minor,patch;
+        char versionString[256];
+        char infoString[256];
+        char *end;
+            ADM_av_getDeviceInfo(i, &name,&major,&minor,&patch);
+            snprintf(versionString,255,"%02d.%02d.%02d",major,minor,patch);
+            strncpy(infoString,name,255);
+            if(strlen(infoString))
+            {
+                end=strlen(infoString)+infoString-1;
+                // Remove trailing line feed
+                while(*end==0x0a || *end==0x0d) *end--=0;
+            }
+            avText[i]=new diaElemReadOnlyText(infoString,versionString);
+            frameAV.swallow(avText[i]);
+    }
+    diaElem *diaAV[]={&frameAV};
+    diaElemTabs tabAV(QT_TR_NOOP("Audio Device"),1,diaAV);
+
     // /Encoder
-    diaElemTabs *tabs[]={&tabAudio,&tabVE};
-    diaFactoryRunTabs(QT_TR_NOOP("Plugins Info"),2,tabs);
 
+    diaElemTabs *tabs[]={&tabAudio,&tabVE,&tabAV};
+    diaFactoryRunTabs(QT_TR_NOOP("Plugins Info"),3,tabs);
+
     for(int i=0;i<aNbPlugin;i++)
         delete aText[i];
     for(int i=0;i<veNbPlugin;i++)
         delete veText[i];
+    for(int i=0;i<avNbPlugin;i++)
+        delete avText[i];
 
     return 1;
 }

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_prefs.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_prefs.cpp	2008-07-03 19:29:21 UTC (rev 4183)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_prefs.cpp	2008-07-03 19:29:25 UTC (rev 4184)
@@ -288,6 +288,7 @@
 
 		diaMenuEntry audioEntries[] =
 		{
+#if 0
 		#ifdef ALSA_SUPPORT
 			{DEVICE_ALSA, QT_TR_NOOP("ALSA")},
 		#endif
@@ -312,12 +313,13 @@
 		#ifdef __WIN32
 			{DEVICE_WIN32, QT_TR_NOOP("Win32")},
 		#endif
-			{DEVICE_DUMMY, QT_TR_NOOP("None")}
+#endif
+			{0, QT_TR_NOOP("None")}
 		};
 
         diaElemMenu menuAudio(&newdevice,QT_TR_NOOP("_Audio output:"), sizeof(audioEntries)/sizeof(diaMenuEntry),audioEntries,"");
                 
-#ifdef ALSA_SUPPORT
+#if 0 //def ALSA_SUPPORT
 		diaElemText entryAlsaDevice(&alsaDevice,QT_TR_NOOP("ALSA _device:"),NULL);
 
           int z,m;
@@ -372,16 +374,20 @@
         diaElemTabs tabOutput(QT_TR_NOOP("Output"),4,(diaElem **)diaOutput);
         
         /* Audio */
-#if defined(ALSA_SUPPORT)
+
+#if 0 //defined(ALSA_SUPPORT)
         diaElem *diaAudio[]={&menuMixer,&menuVolume,&menuAudio,&entryAlsaDevice};
         diaElemTabs tabAudio(QT_TR_NOOP("Audio"),4,(diaElem **)diaAudio);
-#elif defined(OSS_SUPPORT)
+//#elif defined(OSS_SUPPORT)
         diaElem *diaAudio[]={&menuMixer,&menuVolume,&menuAudio};
         diaElemTabs tabAudio(QT_TR_NOOP("Audio"),3,(diaElem **)diaAudio);
-#else
+#endif
+
+#if 1
         diaElem *diaAudio[]={&menuMixer,&menuAudio};
         diaElemTabs tabAudio(QT_TR_NOOP("Audio"),2,(diaElem **)diaAudio);
 #endif
+
         
         /* Video */
         diaElem *diaVideo[]={&menuVideoMode,&framePP};

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/gtk_gui.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/gtk_gui.cpp	2008-07-03 19:29:21 UTC (rev 4183)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/gtk_gui.cpp	2008-07-03 19:29:25 UTC (rev 4184)
@@ -294,20 +294,6 @@
       ADM_aviUISetMuxer();
       return;
       break;
-#ifdef HAVE_AUDIO      
-    	case ACT_SelectDevOSS:
-				   AVDM_switch (DEVICE_OSS);
-				   return;break;
-    	case ACT_SelectDevDummy:
-				   AVDM_switch (DEVICE_DUMMY);
-				   return;break;
-    	case ACT_SelectDevArts:
-				   AVDM_switch (DEVICE_ARTS);
-				   return;break;
-	case ACT_SelectDevALSA:
-				   AVDM_switch (DEVICE_ALSA);
-				   return;break;
-#endif                                  
     case ACT_Fast:
       ADM_assert(0);
       break;

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/main.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/main.cpp	2008-07-03 19:29:21 UTC (rev 4183)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/main.cpp	2008-07-03 19:29:25 UTC (rev 4184)
@@ -71,6 +71,7 @@
 extern void getUIDescription(char*);
 extern uint8_t ADM_ad_loadPlugins(const char *path);
 extern uint8_t ADM_vf_loadPlugins(const char *path);
+extern uint8_t ADM_av_loadPlugins(const char *path);
 extern void loadPlugins(void);
 extern void InitFactory(void);
 extern void InitCoreToolkit(void);
@@ -226,19 +227,24 @@
 	//***************Plugins *********************
 	// Load system wide audio decoder plugin
 #ifdef __APPLE__
-	char *adPlugins = ADM_getInstallRelativePath("../Resources/lib","ADM_plugins","audioDecoder");
-	char *vfPlugins = ADM_getInstallRelativePath("../Resources/lib","ADM_plugins","videoFilter");
+    const char *startDir="../Resources/lib";
 #else
-	char *adPlugins = ADM_getInstallRelativePath("lib","ADM_plugins","audioDecoder");
-	char *vfPlugins = ADM_getInstallRelativePath("lib","ADM_plugins","videoFilter");
+    const char *startDir="lib";
 #endif
+	char *adPlugins = ADM_getInstallRelativePath(startDir,"ADM_plugins","audioDecoder");
+	char *vfPlugins = ADM_getInstallRelativePath(startDir,"ADM_plugins","videoFilter");
+    char *avPlugins = ADM_getInstallRelativePath(startDir,"ADM_plugins","audioDevices");    
 
+
 	ADM_ad_loadPlugins(adPlugins);
 	delete [] adPlugins;
 
 	ADM_vf_loadPlugins(vfPlugins);
 	delete [] vfPlugins;
 
+    ADM_av_loadPlugins(avPlugins);
+    delete [] avPlugins;
+
 	// load local audio decoder plugins
 	adPlugins=ADM_getHomeRelativePath("plugins","audioDecoder");
 	ADM_ad_loadPlugins(adPlugins);

Added: branches/avidemux_2.5_branch_gruntster/cmake/av_plugin.cmake
===================================================================
--- branches/avidemux_2.5_branch_gruntster/cmake/av_plugin.cmake	2008-07-03 19:29:21 UTC (rev 4183)
+++ branches/avidemux_2.5_branch_gruntster/cmake/av_plugin.cmake	2008-07-03 19:29:25 UTC (rev 4184)
@@ -0,0 +1,8 @@
+MACRO(INIT_AUDIO_DEVICE _lib)
+	INCLUDE_DIRECTORIES("${CMAKE_SOURCE_DIR}/../avidemux/ADM_core/include")
+	INCLUDE_DIRECTORIES("${CMAKE_SOURCE_DIR}/../avidemux/ADM_audiodevice/")
+ENDMACRO(INIT_AUDIO_DEVICE)
+
+MACRO(INSTALL_AUDIODEVICE _lib)
+	INSTALL(TARGETS ${_lib} DESTINATION "${CMAKE_INSTALL_PREFIX}/lib/ADM_plugins/audioDevices/")
+ENDMACRO(INSTALL_AUDIODEVICE)

Copied: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Alsa/ADM_deviceALSA.cpp (from rev 4183, branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceALSA.cpp)
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceALSA.cpp	2008-07-03 19:29:21 UTC (rev 4183)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Alsa/ADM_deviceALSA.cpp	2008-07-03 19:29:25 UTC (rev 4184)
@@ -0,0 +1,346 @@
+/***************************************************************************
+                          ADM_deviceAlsa.cpp  -  description
+                             -------------------
+
+	Strongly derivated from code sample from alsa-project.org with some bits
+		from mplayer concerning the swparams
+
+    begin                : Sat Sep 28 2002
+    copyright            : (C) 2002 by mean
+    email                : fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include "ADM_default.h"
+#include <unistd.h>
+#include <errno.h>
+#include <sys/types.h>
+
+
+
+
+#include <alsa/asoundlib.h>
+#include  "ADM_audiodevice.h"
+#include  "ADM_audioDeviceInternal.h"
+#include  "ADM_deviceALSA.h"
+
+
+ADM_DECLARE_AUDIODEVICE(Alsa,alsaAudioDevice,1,0,0,"Alsa audio device (c) mean");
+
+/* Handle for the PCM device */
+snd_pcm_t *pcm_handle;
+
+    alsaAudioDevice::alsaAudioDevice( void )
+    {
+		_init=0;
+    }
+
+uint8_t alsaAudioDevice::init( uint32_t channel,uint32_t fq )
+{
+	int dir=0;
+
+	_channels=channel;
+	_init=0;
+   /* Playback stream */
+    snd_pcm_stream_t stream = SND_PCM_STREAM_PLAYBACK;
+
+    /* This structure contains information about    */
+    /* the hardware and can be used to specify the  */
+    /* configuration to be used for the PCM stream. */
+    snd_pcm_hw_params_t *hwparams;
+    snd_pcm_sw_params_t *swparams;
+
+
+  static char *pcm_name;
+//  if( prefs->get(DEVICE_AUDIO_ALSA_DEVICE, &pcm_name) != RC_OK )
+               pcm_name = ADM_strdup("dmix");
+
+ /* Allocate the snd_pcm_hw_params_t structure on the stack. */
+    snd_pcm_hw_params_alloca(&hwparams);
+    snd_pcm_sw_params_alloca(&swparams);
+    /* Open PCM. The last parameter of this function is the mode. */
+    /* If this is set to 0, the standard mode is used. Possible   */
+    /* other values are SND_PCM_NONBLOCK and SND_PCM_ASYNC.       */
+    /* If SND_PCM_NONBLOCK is used, read / write access to the    */
+    /* PCM device will return immediately. If SND_PCM_ASYNC is    */
+    /* specified, SIGIO will be emitted whenever a period has     */
+    /* been completely processed by the soundcard.                */
+    if (snd_pcm_open(&pcm_handle, pcm_name, stream, SND_PCM_NONBLOCK) < 0) {
+      fprintf(stderr, "Error opening PCM device %s\n", pcm_name);
+      return(0);
+    }
+    // past this point we got _init=1 -> partially initialized
+    _init=1;
+      /* Init hwparams with full configuration space */
+    if (snd_pcm_hw_params_any(pcm_handle, hwparams) < 0) {
+      fprintf(stderr, "Can not configure this PCM device.\n");
+      ADM_dealloc(pcm_name);
+      return(0);
+    }
+    ADM_dealloc(pcm_name);
+    /* Set access type. This can be either    */
+    /* SND_PCM_ACCESS_RW_INTERLEAVED or       */
+    /* SND_PCM_ACCESS_RW_NONINTERLEAVED.      */
+    /* There are also access types for MMAPed */
+    /* access, but this is beyond the scope   */
+    /* of this introduction.                  */
+    if (snd_pcm_hw_params_set_access(pcm_handle, hwparams, SND_PCM_ACCESS_RW_INTERLEAVED) < 0) {
+      fprintf(stderr, "Error setting access.\n");
+      return(0);
+    }
+
+    /* Set sample format */
+//    if (snd_pcm_hw_params_set_format(pcm_handle, hwparams, SND_PCM_FORMAT_FLOAT) < 0) { //need more test
+    //  fprintf(stderr, "Error setting float format.\n");
+
+#ifdef ADM_BIG_ENDIAN
+    if (snd_pcm_hw_params_set_format(pcm_handle, hwparams, SND_PCM_FORMAT_S16_BE) < 0)
+#else
+    if (snd_pcm_hw_params_set_format(pcm_handle, hwparams, SND_PCM_FORMAT_S16_LE) < 0)
+#endif
+    {
+      fprintf(stderr, "Error setting format.\n");
+      return(0);
+    }
+	//}
+    /* Set sample rate. If the exact rate is not supported */
+    /* by the hardware, use nearest possible rate.         */
+    int exact_rate;
+    dir=0;
+    exact_rate = snd_pcm_hw_params_set_rate_near(pcm_handle, hwparams, &fq, &dir);
+    if (dir != 0) {
+      fprintf(stderr, "The rate %lu Hz is not supported by your hardware.\n  ==> Using %d Hz instead.\n", fq, exact_rate);
+    }
+
+    /* Set number of channels */
+    if (snd_pcm_hw_params_set_channels(pcm_handle, hwparams, channel) < 0) {
+      fprintf(stderr, "Error setting channels.\n");
+      return(0);
+    }
+#if 0
+    	uint32_t periods=fq*2*channel*10;
+	uint32_t periodsize=1;
+    /* Set number of periods. Periods used to be called fragments. */
+    if (snd_pcm_hw_params_set_periods(pcm_handle, hwparams, periods, 0) < 0) {
+      fprintf(stderr, "Error setting periods.\n");
+      return(0);
+    }
+#else
+
+ 	unsigned int buffer_time = 800000;
+	int er;
+	unsigned int buff;
+	dir=0;
+
+	if ((er=snd_pcm_hw_params_set_buffer_time_near(pcm_handle, hwparams, &buffer_time, &dir)) < 0)
+	  {
+	    printf("Error : hw_params_set_buffer_time\n");
+	    return(0);
+	  }
+	  // unsigned ?
+	  dir=0;
+	  buff=buffer_time>>2;
+	snd_pcm_hw_params_set_period_time_near(pcm_handle, hwparams, &buff, &dir) ;
+#if 0
+	if (snd_pcm_hw_params_set_period_time_near(pcm_handle, hwparams, buffer_time>>2, 0) < 0)
+	  /* original: alsa_buffer_time/ao_data.bps */
+	  {
+	    printf("Error : hw_params_set_period_time\n");
+	    return(0);
+	  }
+#endif
+#endif
+
+
+/*
+If your hardware does not support a buffersize of 2^n, you can use the function snd_pcm_hw_params_set_buffer_size_near. This works similar to snd_pcm_hw_params_set_rate_near. Now we apply the configuration to the PCM device pointed to by pcm_handle. This will also prepare the PCM device.
+*/
+
+
+    /* Apply HW parameter settings to */
+    /* PCM device and prepare device  */
+    if (snd_pcm_hw_params(pcm_handle, hwparams) < 0) {
+      fprintf(stderr, "Error setting HW params.\n");
+      return(0);
+    }
+
+ 	if (snd_pcm_sw_params_current(pcm_handle, swparams) < 0)
+	    {
+	      printf("Error setting SW params.\n");
+	      return(0);
+	    }
+
+ 	// be sure that playback starts immediatly (or near)
+	  if (snd_pcm_sw_params_set_avail_min(pcm_handle, swparams, 4) < 0)
+	    {
+	      printf("Error setting set_avail_min \n");
+	      return(0);
+	    }
+
+	  if (snd_pcm_sw_params(pcm_handle, swparams) < 0)
+	    {
+	      printf("Error:snd_pcm_sw_params\n ");
+	      return(0);
+	    }
+
+
+      if ( snd_pcm_prepare(pcm_handle) < 0)
+	{
+	  printf("Error : snd_pcm_prepare\n");
+	  return(0);
+	}
+
+        printf("[Alsa]Success initializing: fq :%u channel %u\n",fq,channel);
+
+    // 2=fully initialized
+    _init=2;
+    return 1;
+}
+
+
+uint8_t alsaAudioDevice::play( uint32_t len, float *data )
+{
+	int ret;
+        int16_t *pcm;
+	/* Write num_frames frames from buffer data to    */
+	/* the PCM device pointed to by pcm_handle.       */
+	/* Returns the number of frames actually written. */
+
+	dither16(data, len, _channels);
+
+	if(2!=_init) return 0;
+        len=len/_channels;
+        pcm=(int16_t *)data;
+    	while(1)
+	{
+        	ret=snd_pcm_writei(pcm_handle, pcm, len);
+		if(ret==(int)len)
+		{
+			return 1;
+		}
+
+		if(ret<0)
+		{
+			switch(ret)
+			{
+				case    -EAGAIN :
+					//wait a bit to flush datas
+					printf("ALSA EAGAIN\n");
+					snd_pcm_wait(pcm_handle, 1000);
+					continue;
+
+				case    -EPIPE:
+					printf("ALSA EPIPE\n");
+					snd_pcm_prepare(pcm_handle);
+					continue;
+				default:
+					printf("ALSA Error %d : Play %s (len=%lu)\n",ret, snd_strerror(ret),len);
+					return 1;
+			}
+		}
+		else
+		{
+			//if(len<2) return 1;
+			len-=ret;
+                        pcm+=(ret*_channels);
+		}
+	}
+	return 1;
+}
+
+ uint8_t alsaAudioDevice::stop( void )
+ {
+ // we have at least a partial initialization
+ if(_init)
+ {
+       /* Stop PCM device and drop pending frames */
+    snd_pcm_drop(pcm_handle);
+
+    /* Stop PCM device after pending frames have been played */
+    snd_pcm_drain(pcm_handle);
+      if (snd_pcm_close(pcm_handle) < 0)
+      {
+		printf("\n Troubles closing alsa\n");
+
+      }
+     }
+     _init=0;
+     return 1;
+}
+
+uint8_t alsaAudioDevice::setVolume(int volume){
+  snd_mixer_t *mixer_handle;
+  char *pcm_name;
+  uint32_t which_vol;
+  int rc;
+/*
+	if( prefs->get(DEVICE_AUDIO_ALSA_DEVICE, &pcm_name) != RC_OK )
+		pcm_name = ADM_strdup("hw:0");
+	if( prefs->get(FEATURE_AUDIOBAR_USES_MASTER,&which_vol) != RC_OK )
+		which_vol = 0;
+*/
+    pcm_name = ADM_strdup("hw:0");
+    which_vol = 0;
+	if( (rc=snd_mixer_open(&mixer_handle,0)) < 0 ){
+		printf("ALSA: snd_mixer_open failed: %d\n",rc);
+		ADM_dealloc(pcm_name);
+		return 0;
+	}
+// MEANX: Cannot use the real name, does not work with dmix
+	if( (rc=snd_mixer_attach(mixer_handle,"hw:0")) < 0 ){
+		printf("ALSA: snd_mixer_attach failed: %d, %s\n",rc, snd_strerror (rc));
+		snd_mixer_close(mixer_handle);
+		ADM_dealloc(pcm_name);
+		return 0;
+	}
+	ADM_dealloc(pcm_name);
+	if( (rc=snd_mixer_selem_register(mixer_handle,NULL,NULL)) < 0 ){
+		printf("ALSA: snd_mixer_selem_register failed: %d\n",rc);
+		snd_mixer_close(mixer_handle);
+		return 0;
+	}
+	if( (rc=snd_mixer_load(mixer_handle)) < 0 ){
+		printf("ALSA: snd_mixer_load failed: %d\n",rc);
+		snd_mixer_close(mixer_handle);
+		return 0;
+	}
+	{ snd_mixer_elem_t *elem;
+	  snd_mixer_selem_id_t *sid;
+	  const char *str;
+		snd_mixer_selem_id_alloca(&sid);
+		for (elem = snd_mixer_first_elem(mixer_handle);
+		     elem;
+		     elem = snd_mixer_elem_next(elem)) {
+			snd_mixer_selem_get_id(elem, sid);
+			str = snd_mixer_selem_id_get_name(sid);
+			if( (which_vol == 0 && !strcmp(str,"PCM"))   ||
+			    (which_vol == 1 && !strcmp(str,"Master"))  ){
+			  long val=0, min=0, max=0;
+				snd_mixer_selem_get_playback_volume_range(elem,&min,&max);
+				/*
+				if( (rc=snd_mixer_selem_get_playback_volume(elem,SND_MIXER_SCHN_FRONT_LEFT,&val)) < 0 ){
+					printf("ALSA: snd_mixer_selem_get_playback_volume failed: %d\n",rc);
+				}
+				printf("ALSA: old val: %lu\n",val*100/max);
+				*/
+				if( (rc=snd_mixer_selem_set_playback_volume_all(elem,volume*max/100)) < 0 ){
+					printf("ALSA: snd_mixer_selem_set_playback_volume_all failed: %d\n",rc);
+				}
+				printf("ALSA: new %s val: %lu\n",(which_vol?"master":"pcm"),volume);
+				break;
+			}
+		}
+	}
+	snd_mixer_close(mixer_handle);
+	return 0;
+}
+
+//EOF

Copied: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Alsa/ADM_deviceALSA.h (from rev 4183, branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceALSA.h)
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceALSA.h	2008-07-03 19:29:21 UTC (rev 4183)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Alsa/ADM_deviceALSA.h	2008-07-03 19:29:25 UTC (rev 4184)
@@ -0,0 +1,35 @@
+/***************************************************************************
+                          ADM_deviceAlsa.h  -  description
+                             -------------------
+    begin                : Sat Sep 28 2002
+    copyright            : (C) 2002 by mean
+    email                : fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+
+	 class alsaAudioDevice : public audioDevice
+	 {
+		 protected :
+				//	0-> no init done
+				//	1-> device opened but init failed
+				//	2->fully initialized
+				uint32_t _init;
+		  public:
+                                    alsaAudioDevice(void);
+		     		virtual uint8_t init(uint32_t channel,uint32_t fq);
+	    			virtual uint8_t play(uint32_t len, float *data);
+		      		virtual uint8_t stop(void) ;
+                    virtual uint8_t setVolume(int volume);
+		 }     ;
+//EOF
+
+

Added: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Alsa/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Alsa/CMakeLists.txt	2008-07-03 19:29:21 UTC (rev 4183)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Alsa/CMakeLists.txt	2008-07-03 19:29:25 UTC (rev 4184)
@@ -0,0 +1,10 @@
+INCLUDE(av_plugin)
+
+
+SET(ADM_av_alsa_SRCS ADM_deviceALSA.cpp)
+
+ADD_LIBRARY(ADM_av_alsa SHARED ${ADM_av_alsa_SRCS})
+#TARGET_LINK_LIBRARIES(ADM_av_alsa ADM_libalsa)
+
+INIT_AUDIO_DEVICE(ADM_av_alsa)
+INSTALL_AUDIODEVICE(ADM_av_alsa)

Copied: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Arts/ADM_deviceArts.cpp (from rev 4183, branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceArts.cpp)
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceArts.cpp	2008-07-03 19:29:21 UTC (rev 4183)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Arts/ADM_deviceArts.cpp	2008-07-03 19:29:25 UTC (rev 4184)
@@ -0,0 +1,121 @@
+/***************************************************************************
+                          ADM_deviceArts.cpp  -  description
+                             -------------------
+    begin                : Sat Sep 28 2002
+    copyright            : (C) 2002 by mean
+    email                : fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include "config.h"
+#include "ADM_default.h"
+
+#ifdef USE_ARTS
+#include <artsc.h>
+
+#include "ADM_audiodevice.h"
+#include  "ADM_audiodevice/ADM_deviceoss.h"
+#include  "ADM_audiodevice/ADM_deviceArts.h"
+
+uint8_t artsInitialized=0;
+//_______________________________________________
+//
+//
+//_______________________________________________
+uint8_t  artsAudioDevice::stop(void) {
+		if(!_stream)
+		{
+			printf("\n Arts: no stream\n");
+			return 0;
+		}
+
+		arts_close_stream(_stream);
+		// apparently arts 3.2 alpha does not like this
+	   	//arts_free();
+		_stream=NULL;
+		printf("\n Arts stopped\n");
+    	return 1;
+}
+
+//_______________________________________________
+//
+//
+//_______________________________________________
+uint8_t artsAudioDevice::init(uint8_t channels, uint32_t fq)
+{
+	_channels = channels;
+
+    if(_stream)
+    	{
+			printf("\n purging previous instance\n");
+			stop();
+		}
+    printf("\n Arts  : %lu Hz, %lu channels", fq, channels);
+	if(!artsInitialized)
+	{
+		if(arts_init())
+		{
+			printf("\n Error initializing artsd\n");
+			return 0;
+		}
+		artsInitialized=1;
+	}
+
+	_stream=arts_play_stream(fq, 16,channels, "Avidemux");
+
+	if(!_stream)
+	 {
+		printf("\n Problem setting fq/channel, aborting\n");
+		arts_free();
+		return 0;
+	}
+	arts_stream_set(_stream, ARTS_P_BLOCKING, 1);
+	arts_stream_set(_stream, ARTS_P_BUFFER_TIME, 50); // Ask for 1 sec buffer
+	//arts_stream_set(_stream,  ARTS_P_PACKET_SETTINGS, (11<<16)+10);
+
+
+    return 1;
+}
+
+//_______________________________________________
+//
+//
+//_______________________________________________
+uint8_t artsAudioDevice::play(uint32_t len, float *data)
+ {
+
+	if(!_stream) return 0;
+
+	dither16(data, len, _channels);
+
+	return arts_write(_stream, data, len*2);
+}
+
+/*
+** JSC     Mon Nov 28 19:20:06 CET 2005
+** based on http://www.arts-project.org/doc/mcop-doc/artsd-faq.html
+** arts only works with OSS devices (or alsa devices using oss emulation)
+** so we only need OSS support here
+*/
+uint8_t artsAudioDevice::setVolume(int volume){
+#ifdef OSS_SUPPORT
+        ossAudioDevice dev;
+        dev.setVolume(volume);
+#endif
+        return 1;
+}
+
+#else
+void dummy_art_func( void);
+void dummy_art_func( void)
+ {
+}
+#endif

Copied: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Arts/ADM_deviceArts.h (from rev 4183, branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceArts.h)
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceArts.h	2008-07-03 19:29:21 UTC (rev 4183)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Arts/ADM_deviceArts.h	2008-07-03 19:29:25 UTC (rev 4184)
@@ -0,0 +1,33 @@
+/***************************************************************************
+                          ADM_deviceArts.h  -  description
+                             -------------------
+    begin                : Sat Sep 28 2002
+    copyright            : (C) 2002 by mean
+    email                : fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+ #ifdef USE_ARTS
+                 class artsAudioDevice : public audioDevice
+	 {
+		 protected :
+		 		arts_stream_t _stream;
+		  public:
+		  			artsAudioDevice() {_stream=NULL;}
+				virtual ~artsAudioDevice() {stop();}
+		     		virtual uint8_t init(uint8_t channels, uint32_t fq);
+	    			virtual uint8_t play(uint32_t len, float *data);
+		      		virtual uint8_t stop(void);
+				uint8_t setVolume(int volume);
+		 };
+#endif
+
+

Copied: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Arts/CMakeLists.txt (from rev 4183, branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/oss_out.cpp)
===================================================================

Copied: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/AudioCore/ADM_deviceAudioCore.cpp (from rev 4183, branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceAudioCore.cpp)
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceAudioCore.cpp	2008-07-03 19:29:21 UTC (rev 4183)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/AudioCore/ADM_deviceAudioCore.cpp	2008-07-03 19:29:25 UTC (rev 4184)
@@ -0,0 +1,260 @@
+/***************************************************************************
+                          ADM_deviceAudioCore.cpp  -  description
+                             -------------------
+    begin                : Sat Sep 28 2002
+    copyright            : (C) 2002 by mean
+    email                : fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include "config.h"
+
+#ifdef __APPLE__
+#include <stdio.h>
+#include <stdlib.h>
+#include <pthread.h>
+#include <AudioUnit/AudioUnit.h>
+
+#include "ADM_default.h"
+#include "ADM_assert.h"
+#include "ADM_audiodevice.h"
+#include "ADM_audiodevice/ADM_deviceAudioCore.h"
+#include "ADM_osSupport/ADM_debugID.h"
+#define MODULE_NAME  MODULE_ADEVICE
+#include "ADM_osSupport/ADM_debug.h"
+
+#define BUFFER_SIZE (500*48000)
+
+static Component comp = NULL;
+static int16_t audioBuffer[BUFFER_SIZE];
+static AudioUnit theOutputUnit;
+static uint32_t rd_ptr = 0;
+static uint32_t wr_ptr = 0;
+static pthread_mutex_t lock;
+
+static OSStatus MyRenderer(void *inRefCon, AudioUnitRenderActionFlags *inActionFlags,
+	const AudioTimeStamp *inTimeStamp, UInt32 inBusNumber, UInt32 inNumberFrames, AudioBufferList *ioData);
+static OSStatus OverloadListenerProc(AudioDeviceID inDevice, UInt32 inChannel, Boolean isInput,
+	AudioDevicePropertyID inPropertyID, void* inClientData);
+
+OSStatus OverloadListenerProc(AudioDeviceID inDevice, UInt32 inChannel, Boolean isInput,
+	AudioDevicePropertyID inPropertyID, void* inClientData)
+{
+	printf ("[CoreAudio] *** Overload detected on device playing audio ***\n");
+	return noErr;
+}
+
+uint8_t coreAudioDevice::setVolume(int volume) {}
+
+coreAudioDevice::coreAudioDevice(void) 
+{
+	printf("[CoreAudio] Creating CoreAudio device\n");
+	_inUse=0;
+	pthread_mutex_init(&lock, NULL);
+	pthread_mutex_unlock(&lock);
+}
+
+uint8_t coreAudioDevice::stop(void) 
+{
+	if (_inUse)
+		verify_noerr(AudioOutputUnitStop(theOutputUnit));
+
+	// Clean up
+	CloseComponent(theOutputUnit);
+	_inUse=0;
+
+	return 1;
+}
+
+OSStatus MyRenderer(void *inRefCon, AudioUnitRenderActionFlags *inActionFlags, const AudioTimeStamp *inTimeStamp,
+	UInt32 inBusNumber, UInt32 inChannel, AudioBufferList *ioData)
+{
+	pthread_mutex_lock(&lock);
+	uint32_t nb_sample = ioData->mBuffers[0].mDataByteSize >> 1;
+	uint32_t left = 0;
+	uint8_t *in, *out;
+
+	in = (uint8_t*)&audioBuffer[rd_ptr];
+	out = (uint8_t*)ioData->mBuffers[0].mData;
+	aprintf("[CoreAudio] Fill: rd %lu, wr %lu, nb asked %lu\n", rd_ptr, wr_ptr, nb_sample);
+
+	if(wr_ptr>rd_ptr)
+	{
+		left=wr_ptr-rd_ptr-1;
+
+		if(left>nb_sample)
+		{
+			memcpy(out,in,nb_sample*2);
+			rd_ptr+=nb_sample;
+		}
+
+		else
+		{
+			memcpy(out,in,left*2);
+			memset(out+left*2,0,(nb_sample-left)*2);
+			rd_ptr+=left;
+		}
+	}
+	else
+	{
+		// wrap
+		left=BUFFER_SIZE-rd_ptr-1;
+		if(left>nb_sample)
+		{
+			memcpy(out,in,nb_sample*2);
+			rd_ptr+=nb_sample;
+		}
+		else
+		{
+			memcpy(out,in,left*2);
+			out+=left*2;
+			rd_ptr=0;
+			in=(uint8_t *)&audioBuffer[0];
+			nb_sample-=left;
+			if(nb_sample>wr_ptr-1) nb_sample=wr_ptr-1;
+			memcpy(out,in,nb_sample*2);
+			rd_ptr=nb_sample;	
+		}
+	}
+
+	pthread_mutex_unlock(&lock);
+	return 0;
+}
+
+#define CHECK_RESULT(msg) \
+    if (err != noErr) \
+	{ \
+		printf("[CoreAudio] Failed to initialise CoreAudio: " msg "\n"); \
+        return 0; \
+    }
+
+uint8_t coreAudioDevice::init(uint8_t channels, uint32_t fq) 
+{
+	_channels = channels;
+
+	OSStatus err;
+	ComponentDescription desc;
+	AURenderCallbackStruct input;
+	AudioStreamBasicDescription streamFormat;
+	AudioDeviceID theDevice;
+
+	desc.componentType = kAudioUnitType_Output;
+	desc.componentSubType = kAudioUnitSubType_HALOutput;
+	desc.componentManufacturer = kAudioUnitManufacturer_Apple;
+	desc.componentFlags = 0;
+	desc.componentFlagsMask = 0;
+
+	comp = FindNextComponent(NULL, &desc);
+
+	if (comp == NULL)
+	{
+		printf("[CoreAudio] Failed to find component\n");
+		return 0;
+	}
+
+	err = OpenAComponent(comp, &theOutputUnit);
+	CHECK_RESULT("OpenAComponent")
+
+	err = AudioUnitInitialize(theOutputUnit);
+	CHECK_RESULT("AudioUnitInitialize")
+	
+	// Set up a callback function to generate output to the output unit
+	input.inputProc = MyRenderer;
+	input.inputProcRefCon = NULL;
+	
+	err = AudioUnitSetProperty(theOutputUnit, 
+					kAudioUnitProperty_SetRenderCallback,
+					kAudioUnitScope_Global,
+					0,
+					&input, 
+					sizeof(input));
+	CHECK_RESULT("AudioUnitSetProperty [SetInputCallback]")
+
+	streamFormat.mSampleRate = fq;
+	streamFormat.mFormatID = kAudioFormatLinearPCM;
+	streamFormat.mFormatFlags = kLinearPCMFormatFlagIsSignedInteger | kLinearPCMFormatFlagIsPacked;
+
+	streamFormat.mBytesPerPacket = channels * sizeof (UInt16);
+	streamFormat.mFramesPerPacket = 1;
+	streamFormat.mBytesPerFrame = channels * sizeof (UInt16);
+	streamFormat.mChannelsPerFrame = channels;
+	streamFormat.mBitsPerChannel = sizeof (UInt16) * 8;
+	
+	err = AudioUnitSetProperty(theOutputUnit,
+		kAudioUnitProperty_StreamFormat,
+		kAudioUnitScope_Input,
+		0,
+		&streamFormat,
+		sizeof(streamFormat));
+	CHECK_RESULT("AudioUnitSetProperty [StreamFormat]")
+	
+	printf("[CoreAudio] Rendering source:\n");
+	printf("[CoreAudio] \tSampleRate = %f,\n", streamFormat.mSampleRate);
+	printf("[CoreAudio] \tBytesPerPacket = %ld,\n", streamFormat.mBytesPerPacket);
+	printf("[CoreAudio] \tFramesPerPacket = %ld,\n", streamFormat.mFramesPerPacket);
+	printf("[CoreAudio] \tBytesPerFrame = %ld,\n", streamFormat.mBytesPerFrame);
+	printf("[CoreAudio] \tBitsPerChannel = %ld,\n", streamFormat.mBitsPerChannel);
+	printf("[CoreAudio] \tChannelsPerFrame = %ld\n", streamFormat.mChannelsPerFrame);
+
+    return 1;
+}
+
+uint8_t coreAudioDevice::play(uint32_t len, float *data)
+ {
+ 	// First put stuff into the buffer
+	uint8_t *src;
+	uint32_t left;
+
+	dither16(data, len, _channels);
+
+	pthread_mutex_lock(&lock);
+
+	// Check we have room left
+	if(wr_ptr>=rd_ptr)
+		left=BUFFER_SIZE-(wr_ptr-rd_ptr);
+	else
+		left=rd_ptr-wr_ptr;
+
+	if(len+1>left)
+	{
+		printf("[CoreAudio] Buffer full!\n");
+		pthread_mutex_unlock(&lock);
+		return 0;
+	}
+
+	// We have room left, copy it
+	src=(uint8_t *)&audioBuffer[wr_ptr];
+
+	if(wr_ptr+len<BUFFER_SIZE)
+	{
+		memcpy(src,data,len*2);
+		wr_ptr+=len;
+	}
+	else
+	{
+		left=BUFFER_SIZE-wr_ptr-1;
+		memcpy(src,data,left*2);
+		memcpy(audioBuffer,data+left*2,(len-left)*2);
+		wr_ptr=len-left;	
+	}
+	//aprintf("AudioCore: Putting %lu bytes rd:%lu wr:%lu \n",len*2,rd_ptr,wr_ptr);
+	pthread_mutex_unlock(&lock);	
+
+	_inUse=1;
+	verify_noerr(AudioOutputUnitStart(theOutputUnit));
+
+	return 1;
+}
+#else
+void dummy_ac_func(void);
+void dummy_ac_func(void)
+{
+}
+#endif

Copied: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/AudioCore/ADM_deviceAudioCore.h (from rev 4183, branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceAudioCore.h)
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceAudioCore.h	2008-07-03 19:29:21 UTC (rev 4183)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/AudioCore/ADM_deviceAudioCore.h	2008-07-03 19:29:25 UTC (rev 4184)
@@ -0,0 +1,26 @@
+//
+// C++ Interface: ADM_deviceAudioCore
+//
+// Description: 
+//
+//
+// Author: mean <fixounet at free.fr>, (C) 2004
+//
+// Copyright: See COPYING file that comes with this distribution
+//
+//
+#ifdef __APPLE__
+
+	        class coreAudioDevice : public audioDevice
+	 {
+		 protected :
+					uint8_t				_inUse;
+		  public:
+		  				coreAudioDevice(void);
+		     		virtual uint8_t init(uint8_t channels, uint32_t fq);
+	    			virtual uint8_t play(uint32_t len, float *data);
+		      		virtual uint8_t stop(void);
+					virtual uint8_t setVolume(int volume);
+		 }     ;
+
+#endif

Copied: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/AudioCore/CMakeLists.txt (from rev 4183, branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/oss_out.cpp)
===================================================================

Added: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/CMakeLists.txt	2008-07-03 19:29:21 UTC (rev 4183)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/CMakeLists.txt	2008-07-03 19:29:25 UTC (rev 4184)
@@ -0,0 +1 @@
+ADD_SUBDIRECTORY(Alsa)

Copied: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Esd/ADM_deviceEsd.cpp (from rev 4183, branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceEsd.cpp)
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceEsd.cpp	2008-07-03 19:29:21 UTC (rev 4183)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Esd/ADM_deviceEsd.cpp	2008-07-03 19:29:25 UTC (rev 4184)
@@ -0,0 +1,111 @@
+/***************************************************************************
+                          ADM_deviceEsd.cpp  -  description
+
+  ESD support as output audio device
+                          
+    copyright            : (C) 2005 by mean
+    email                : fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include "config.h"
+
+#if defined(USE_ESD)
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <errno.h>
+
+#include <fcntl.h>
+#include <sys/ioctl.h>
+#include <esd.h>
+
+#include "ADM_default.h"
+#include "ADM_audiodevice.h"
+#include "ADM_assert.h"
+#include "ADM_audiodevice/ADM_deviceoss.h"
+#include "ADM_audiodevice/ADM_deviceALSA.h"
+#include  "ADM_audiodevice/ADM_deviceEsd.h"
+
+
+//_______________________________________________
+//
+//
+//_______________________________________________
+uint8_t  esdAudioDevice::stop(void) {
+    if (esdDevice > 0) {
+        esd_close(esdDevice);
+        esdDevice = 0;
+    }
+    return 1;
+}
+
+//_______________________________________________
+//
+//
+//_______________________________________________
+uint8_t esdAudioDevice::init(uint8_t channels, uint32_t fq) 
+{
+esd_format_t format;
+_channels = channels;
+
+    format=ESD_STREAM | ESD_PLAY | ESD_BITS16;
+    if(channels==1) format|=ESD_MONO;
+        else format|=ESD_STEREO;
+
+    printf("\n ESD  : %lu Hz, %lu channels", fq, channels);
+    esdDevice=esd_play_stream(format,fq,NULL,"avidemux");
+    if(esdDevice<=0) 
+    {
+        printf("Esd open failed\n");
+        return 0;
+    }
+    printf("Esd open succeedeed\n");
+    /*
+#ifdef ADM_BIG_ENDIAN    
+    int fmt = AFMT_S16_BE;
+#else
+    int fmt = AFMT_S16_LE;
+#endif    
+*/
+    return 1;
+}
+
+//_______________________________________________
+//
+//
+//_______________________________________________
+uint8_t esdAudioDevice::play(uint32_t len, float *data)
+{
+	dither16(data, len, _channels);
+	write(esdDevice, data, len*2);
+	return 1;
+}
+
+uint8_t esdAudioDevice::setVolume(int volume){
+#ifdef OSS_SUPPORT
+	ossAudioDevice dev;
+	dev.setVolume(volume);
+#else
+#ifdef ALSA_SUPPORT
+	alsaAudioDevice dev;
+	dev.setVolume(volume);
+#endif
+#endif
+	return 1;
+}
+
+#else
+void dummy_ess_func( void);
+void dummy_ess_func( void)
+ {
+}
+
+#endif

Copied: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Esd/ADM_deviceEsd.h (from rev 4183, branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceEsd.h)
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceEsd.h	2008-07-03 19:29:21 UTC (rev 4183)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Esd/ADM_deviceEsd.h	2008-07-03 19:29:25 UTC (rev 4184)
@@ -0,0 +1,29 @@
+/***************************************************************************
+                          ADM_deviceEsd.h  -  description
+                             -------------------
+                             Audio device for ESD sound daemon
+    copyright            : (C) 2005 by mean
+    email                : fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#ifdef USE_ESD
+class esdAudioDevice : public audioDevice
+	 {
+		 protected :
+                    int esdDevice;
+		  public:
+		  			esdAudioDevice(void) {esdDevice=-1;}
+		     		virtual uint8_t init(uint8_t channels, uint32_t fq);
+	    			virtual uint8_t play(uint32_t len, float *data);
+		      		virtual uint8_t stop(void);
+				uint8_t setVolume(int volume);
+		 }     ;
+#endif

Copied: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Esd/CMakeLists.txt (from rev 4183, branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/oss_out.cpp)
===================================================================

Copied: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Jack/ADM_deviceJack.cpp (from rev 4183, branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceJack.cpp)
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceJack.cpp	2008-07-03 19:29:21 UTC (rev 4183)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Jack/ADM_deviceJack.cpp	2008-07-03 19:29:25 UTC (rev 4184)
@@ -0,0 +1,251 @@
+//
+// Author: Mihail Zenkov <mihail.zenkov at gmail.com>, (C) 2007
+//
+// Copyright: See COPYING file that comes with this distribution
+//
+//
+
+#include "config.h"
+
+#if defined(USE_JACK)
+#include <unistd.h>
+#include <stdio.h>
+#include <stdint.h>
+
+#include "ADM_default.h"
+#include "ADM_audiodevice.h"
+#include "ADM_assert.h"
+#include "ADM_audiodevice/ADM_deviceoss.h"
+#include "ADM_audiodevice/ADM_deviceALSA.h"
+#include "ADM_audiodevice/ADM_deviceJack.h"
+
+
+#define BUFSIZE 16385
+
+jackAudioDevice::jackAudioDevice()
+{
+	client = NULL;
+	ringbuffer = NULL;
+	#ifdef USE_SRC
+	src_out_buf = NULL;
+	src_state = NULL;
+	#endif
+}
+
+void jackAudioDevice::jack_shutdown(void *arg)
+{
+	((jackAudioDevice*)arg)->stop();
+}
+
+uint8_t jackAudioDevice::stop()
+{
+	if (client) {
+		printf("[JACK] Stop\n");
+		jack_client_close(client);
+		client = NULL;
+		if (ringbuffer)
+			jack_ringbuffer_free(ringbuffer);
+		ringbuffer = NULL;
+		#ifdef USE_SRC
+		delete src_out_buf;
+		src_out_buf = NULL;
+		src_delete(src_state);
+		src_state = NULL;
+		#endif
+	}
+
+	return 1;
+}
+
+uint8_t jackAudioDevice::init(uint8_t channels, uint32_t fq)
+{
+	jack_status_t status;
+	_channels = channels;
+
+	if (sizeof(jack_default_audio_sample_t) != sizeof(float)) {
+		printf("[JACK] jack_default_audio_sample_t != float\n");
+		return 0;
+	}
+
+	client = jack_client_open("avidemux", JackNullOption, &status, NULL);
+
+	if (client == NULL) {
+		printf("[JACK] jack_client_open() failed, status = 0x%2.0x\n", status);
+		if (status & JackServerFailed)
+			printf(("[JACK] Unable to connect to server\n"));
+		return 0;
+	}
+
+	if (status & JackServerStarted)
+		printf("[JACK] Server started\n");
+
+	if (jack_get_sample_rate(client) == fq) {
+		jack_set_process_callback(client, process_callback, this);
+	} else {
+		printf("[JACK] audio stream sample rate: %i\n", fq);
+		printf("[JACK] jack server sample rate: %i\n", (int)jack_get_sample_rate(client));
+		#ifdef USE_SRC
+			src_out_buf = new float[BUFSIZE * channels];
+			src_state = src_new(SRC_SINC_FASTEST, channels, NULL);
+			if (!src_state) {
+				printf("[JACK] Can't init libsamplerate\n");
+				stop();
+				return 0;
+			}
+			src_data.data_out = src_out_buf;
+			src_data.output_frames = BUFSIZE;
+			src_data.src_ratio = jack_get_sample_rate(client) / (double)fq;
+			src_data.end_of_input = 0;
+//			printf("[JACK] ratio: %f\n", src_data.src_ratio);
+		#else
+			printf("[JACK] For play this, you need avidemux compiled with libsamplerate support\n");
+			stop();
+			return 0;
+		#endif
+	}
+
+	ringbuffer = jack_ringbuffer_create(BUFSIZE * channels * sizeof(jack_default_audio_sample_t));
+
+	jack_set_process_callback(client, process_callback, this);
+	jack_on_shutdown(client, jack_shutdown, this);
+
+	char name[10];
+	for (int i = 0; i < channels; i++) {
+		snprintf(name, 10, "output-%d", i);
+		ports[i] = jack_port_register(client, name, JACK_DEFAULT_AUDIO_TYPE, JackPortIsOutput, 0);
+		if (!ports[i]) {
+			printf("[JACK] Can't create new port\n");
+			stop();
+			return 0;
+		}
+	}
+
+	if (jack_activate(client)) {
+		printf("[JACK] Cannot activate client\n");
+		stop();
+		return 0;
+	}
+
+	const char **input_ports = jack_get_ports(client, NULL, NULL, JackPortIsInput|JackPortIsPhysical);
+
+	for (int i = 0; i < channels && input_ports[i]; i++) {
+		if (jack_connect(client, jack_port_name(ports[i]), input_ports[i]))
+			printf("[JACK] Connecting failed\n");
+	}
+
+	if (channels == 1 && input_ports[1])
+		if (jack_connect(client, jack_port_name(ports[0]), input_ports[1]))
+			printf("[JACK] Connecting failed\n");
+
+	return 1;
+}
+
+int jackAudioDevice::process(jack_nframes_t nframes)
+{
+	jack_default_audio_sample_t *pbuf[_channels];
+	for (int c = 0; c < _channels; c++)
+		pbuf[c] = (jack_default_audio_sample_t *) jack_port_get_buffer(ports[c], nframes);
+
+	size_t read = jack_ringbuffer_read_space(ringbuffer) / sizeof(jack_default_audio_sample_t) / _channels;
+
+	if (read > nframes)
+		read = nframes;
+
+	int i;
+	for (i = 0; i < read; i++)
+		for (int c = 0; c < _channels; c++) {
+			jack_ringbuffer_read(ringbuffer, (char *)pbuf[c], sizeof(jack_default_audio_sample_t));
+			pbuf[c]++;
+		}
+
+	for (; i < nframes; i++)
+		for (int c = 0; c < _channels; c++) {
+			pbuf[c] = 0;
+			pbuf[c]++;
+		}
+
+	if (read != nframes)
+		printf("[JACK] UNDERRUN!\n");
+
+	return 0;
+}
+
+int jackAudioDevice::process_callback(jack_nframes_t nframes, void* arg)
+{
+	return ((jackAudioDevice*)arg)->process(nframes);
+}
+
+
+uint8_t jackAudioDevice::play(uint32_t len, float *data)
+{
+//	static int min = 5000;
+	static int sleep = (int)((float)BUFSIZE / jack_get_sample_rate(client) / 2. * 1000000.);
+	size_t write;
+	float writef;
+	len /= _channels;
+
+	#ifdef USE_SRC
+	if (src_out_buf) {
+		while (len) {
+			writef = jack_ringbuffer_write_space(ringbuffer);
+			writef /= src_data.src_ratio * sizeof(jack_default_audio_sample_t) * _channels;
+			write = (size_t)writef;
+			if (write >= len) {
+				src_data.data_in = data;
+				src_data.input_frames = len;
+				src_process(src_state, &src_data);
+				jack_ringbuffer_write(ringbuffer,
+					(char *)src_out_buf,
+					src_data.output_frames_gen * sizeof(jack_default_audio_sample_t) * _channels);
+/*
+				if (len != src_data.input_frames_used)
+					printf("[JACK] len %i != %i input_frames_used\n", len, src_data.input_frames_used);
+				if (len < min)
+					min = len;
+				printf("[JACK] %i %i %i %f %i\n",min, src_data.input_frames_used, src_data.output_frames_gen, writef, len);
+				data += src_data.input_frames_used * _channels;
+				len -= src_data.input_frames_used;
+*/
+				return 1;
+			} else {
+				printf("[JACK] OVERRUN!\n");
+				usleep(sleep);
+			}
+		}
+	} else
+	#endif
+	while (len) {
+		writef = jack_ringbuffer_write_space(ringbuffer);
+		writef /= sizeof(jack_default_audio_sample_t) * _channels;
+		write = (size_t)writef;
+		if (write >= len) {
+			jack_ringbuffer_write(ringbuffer, (char *)data, len * sizeof(jack_default_audio_sample_t) * _channels);
+			return 1;
+		} else {
+			printf("[JACK] OVERRUN!\n");
+			usleep(sleep);
+		}
+	}
+
+        return 1;
+}
+
+uint8_t jackAudioDevice::setVolume(int volume){
+#ifdef OSS_SUPPORT
+	ossAudioDevice dev;
+	dev.setVolume(volume);
+#else
+#ifdef ALSA_SUPPORT
+	alsaAudioDevice dev;
+	dev.setVolume(volume);
+#endif
+#endif
+	return 1;
+}
+
+#else
+void dummy_jack_func( void);
+void dummy_jack_func( void)
+{
+}
+#endif

Copied: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Jack/ADM_deviceJack.h (from rev 4183, branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceJack.h)
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceJack.h	2008-07-03 19:29:21 UTC (rev 4183)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Jack/ADM_deviceJack.h	2008-07-03 19:29:25 UTC (rev 4184)
@@ -0,0 +1,43 @@
+//
+// Author: Mihail Zenkov <mihail.zenkov at gmail.com>, (C) 2007
+//
+// Copyright: See COPYING file that comes with this distribution
+//
+//
+
+#ifdef USE_JACK
+
+
+#include <jack/jack.h>
+#include <jack/ringbuffer.h>
+
+#ifdef USE_SRC
+#include <samplerate.h>
+#endif
+
+#define MAX_CHANNELS 9
+
+class jackAudioDevice : public audioDevice
+{
+public:
+	jackAudioDevice();
+	virtual uint8_t init(uint8_t channel,uint32_t fq);
+	virtual uint8_t play(uint32_t len, float *data);
+	virtual uint8_t stop();
+	uint8_t setVolume(int volume);
+	int process(jack_nframes_t nframes);
+
+protected:
+	static void jack_shutdown(void *arg);
+	static int process_callback(jack_nframes_t nframes, void *arg);
+
+	jack_port_t *ports[MAX_CHANNELS];
+	jack_client_t *client;
+	jack_ringbuffer_t *ringbuffer;
+	#ifdef USE_SRC
+	float *src_out_buf;
+	SRC_STATE *src_state;
+	SRC_DATA src_data;
+	#endif
+};
+#endif

Copied: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Jack/CMakeLists.txt (from rev 4183, branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/oss_out.cpp)
===================================================================

Copied: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Oss/ADM_deviceoss.cpp (from rev 4183, branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceoss.cpp)
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceoss.cpp	2008-07-03 19:29:21 UTC (rev 4183)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Oss/ADM_deviceoss.cpp	2008-07-03 19:29:25 UTC (rev 4184)
@@ -0,0 +1,179 @@
+/***************************************************************************
+                          ADM_deviceoss.cpp  -  description
+                             -------------------
+    begin                : Sat Sep 28 2002
+    copyright            : (C) 2002 by mean
+    email                : fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include "config.h"
+
+#ifdef OSS_SUPPORT
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <errno.h>
+
+#include <fcntl.h>
+#include <sys/ioctl.h>
+
+#if defined(ADM_BSD_FAMILY) && !defined(__FreeBSD__) && !defined(__OpenBSD__)
+	#include <soundcard.h>
+	const char *dsp = DEVOSSAUDIO;;
+
+#elif defined(__OpenBSD__)
+	#include <soundcard.h>
+	const char *dsp = "/dev/audio";
+	const char *device_mixer = "/dev/mixer";
+
+#else
+	#include <sys/soundcard.h>
+	const char *dsp = "/dev/dsp";
+        const char *device_mixer = "/dev/mixer";
+
+#endif
+ 
+ 
+
+#include "ADM_default.h"
+#include "ADM_audiodevice.h"
+#include "ADM_assert.h"
+#include  "ADM_audiodevice/ADM_deviceoss.h"
+#include "DIA_coreToolkit.h"
+#include "prefs.h"
+
+//_______________________________________________
+//
+//
+//_______________________________________________
+uint8_t  ossAudioDevice::setVolume(int volume) 
+{
+        int fd;
+	int ret;
+	uint32_t which_vol = 0;
+
+	prefs->get(FEATURE_AUDIOBAR_USES_MASTER,&which_vol);
+        fd=open(device_mixer,O_RDONLY);
+        if(!fd)
+        {
+                printf("OSS: cannot open mixer\n");
+                return 0;
+        }
+        printf("Oss: New %s volume %d\n",(which_vol?"master":"pcm"),volume);
+        // Assuming stereo
+        volume=volume+(volume<<8);
+	if( which_vol ){
+        	ret = ioctl(fd, MIXER_WRITE(SOUND_MIXER_VOLUME), &volume);
+	}else{
+        	ret = ioctl(fd, MIXER_WRITE(SOUND_MIXER_PCM   ), &volume);
+	}
+        close(fd);
+
+	if( ret ){
+		if( errno == EBADF ){
+			printf("set mixer failed: %u (possible access issue)\n",errno);
+		}else{
+			printf("set mixer failed: %u\n",errno);
+		}
+	}
+        return 1;
+
+}
+
+//_______________________________________________
+//
+//
+//_______________________________________________
+uint8_t  ossAudioDevice::stop(void) {
+    if (oss_fd > 0) {
+        close(oss_fd);
+        oss_fd = 0;
+    }
+    return 1;
+}
+
+//_______________________________________________
+//
+//
+//_______________________________________________
+uint8_t ossAudioDevice::init(uint8_t channels, uint32_t fq) 
+{
+	_channels = channels;
+ 
+    printf("\n OSS  : %lu Hz, %lu channels", fq, channels);
+    // open OSS device
+    oss_fd = open(dsp, O_WRONLY | O_NONBLOCK);
+    if (oss_fd == -1) {
+	if( errno == EACCES )
+	{
+          GUI_Error_HIG(QT_TR_NOOP("Could not open OSS audio device"), QT_TR_NOOP("Check the permissions for /dev/dsp."));
+	  }
+	else
+           printf("\n Error initializing OSS: Error : %d", errno);
+        return 0;
+    }
+    // seems ok, set up audio 
+    if (ioctl (oss_fd, SNDCTL_DSP_SPEED, &fq) < 0) {
+        printf("\n Error setting up OSS(SPEED): Error : %d", errno);
+        return 0;
+    }
+    if (channels > 2) {
+        if (ioctl (oss_fd, SNDCTL_DSP_CHANNELS, &channels) < 0) {
+	    printf("\n Error setting up OSS(CHANNELS): Error : %d", errno);
+	    return 0;
+        }
+    } else {
+        int chan = channels - 1;
+        if (ioctl (oss_fd, SNDCTL_DSP_STEREO, &chan) < 0) {
+	    printf("\n Error setting up OSS(STEREO): Error : %d", errno);
+	    return 0;
+        }
+    }
+#ifdef ADM_BIG_ENDIAN    
+    int fmt = AFMT_S16_BE;
+#else
+    int fmt = AFMT_S16_LE;
+#endif    
+    if (ioctl (oss_fd, SNDCTL_DSP_SETFMT, &fmt) < 0) {
+        printf("\n Error setting up OSS(FORMAT): Error : %d", errno);
+        return 0;
+    }
+
+    return 1;
+}
+
+//_______________________________________________
+//
+//
+//_______________________________________________
+uint8_t ossAudioDevice::play(uint32_t len, float *data)
+{
+	uint32_t w;
+
+	if (!oss_fd)
+		return 0;
+
+	dither16(data, len, _channels);
+
+	w = write(oss_fd, data, len*2);
+        if(w!=len*2)
+        {
+          printf("[OSS] Warning : %u / %u\n",w,len*2); 
+        }
+	return 1;
+}
+#else
+void dummy_oss_func( void);
+void dummy_oss_func( void)
+ {
+}
+
+#endif

Copied: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Oss/ADM_deviceoss.h (from rev 4183, branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceoss.h)
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceoss.h	2008-07-03 19:29:21 UTC (rev 4183)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Oss/ADM_deviceoss.h	2008-07-03 19:29:25 UTC (rev 4184)
@@ -0,0 +1,29 @@
+/***************************************************************************
+                          ADM_deviceoss.h  -  description
+                             -------------------
+    begin                : Sat Sep 28 2002
+    copyright            : (C) 2002 by mean
+    email                : fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#ifdef OSS_SUPPORT
+class ossAudioDevice : public audioDevice
+{
+protected :
+                                int oss_fd;
+public:
+                                        ossAudioDevice(void) {oss_fd=0;}
+                        virtual uint8_t init(uint8_t channels, uint32_t fq);
+                        virtual uint8_t play(uint32_t len, float *data);
+                        virtual uint8_t stop(void);
+			uint8_t setVolume(int volume);
+}     ;
+#endif

Copied: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Oss/CMakeLists.txt (from rev 4183, branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/oss_out.cpp)
===================================================================

Copied: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Sdl/ADM_deviceSDL.cpp (from rev 4183, branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceSDL.cpp)
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceSDL.cpp	2008-07-03 19:29:21 UTC (rev 4183)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Sdl/ADM_deviceSDL.cpp	2008-07-03 19:29:25 UTC (rev 4184)
@@ -0,0 +1,276 @@
+//
+// C++ Implementation: ADM_deviceSDL
+//
+// Description: 
+//
+//
+// Author: mean <fixounet at free.fr>, (C) 2004
+//
+// Copyright: See COPYING file that comes with this distribution
+//
+//
+
+#include "config.h"
+#include <errno.h>
+
+
+#include "ADM_default.h"
+  
+ 
+#ifdef USE_SDL
+#include "SDL.h"
+
+
+
+#include "ADM_audiodevice.h"
+#include "ADM_audiodevice/ADM_deviceoss.h"
+#include "ADM_audiodevice/ADM_deviceALSA.h"
+#include "ADM_audiodevice/ADM_deviceSDL.h"
+#include "ADM_osSupport/ADM_debugID.h"
+#define MODULE_NAME  MODULE_ADEVICE
+#include "ADM_osSupport/ADM_debug.h"
+
+static int16_t  		*audioBuffer=NULL;
+static uint32_t 		frameCount=0;
+static uint32_t			rd_ptr=0;
+static uint32_t			wr_ptr=0;
+
+extern "C"
+{
+static void SDL_callback(void *userdata, Uint8 *stream, int len);
+}
+
+#ifdef __APPLE__
+#define BUFFER_SIZE (500*48000)
+#else
+#define BUFFER_SIZE (2*48000)
+#endif
+
+//_______________________________________________
+//
+//_______________________________________________
+
+
+//_______________________________________________
+//
+//_______________________________________________
+
+sdlAudioDevice::sdlAudioDevice(void) 
+{
+	printf("Creating SDL Audio device\n");
+	_inUse=0;
+	wr_ptr=rd_ptr=0;
+}
+//_______________________________________________
+//
+//_______________________________________________
+uint8_t  sdlAudioDevice::stop(void) 
+{
+	if(audioBuffer)
+	{
+		delete [] audioBuffer;
+		audioBuffer=NULL;
+	}
+	
+		SDL_PauseAudio(1); // First pause it
+		SDL_CloseAudio();
+		SDL_QuitSubSystem(SDL_INIT_AUDIO);
+	
+	// Clean up
+	//CloseComponent(theOutputUnit);
+	_inUse=0;
+    	wr_ptr=rd_ptr=0;
+	printf("Closing SDL audio\n");
+	return 1;
+}
+//_______________________________________________
+//  We have to fill len data to stream pointer
+//_______________________________________________
+void SDL_callback(void *userdata, Uint8 *stream, int len)
+{
+
+
+	
+	uint32_t nb_sample=len>>1;
+	uint32_t left=0;
+	uint8_t *in,*out;
+
+	in=(uint8_t *)&audioBuffer[rd_ptr];
+	out=(uint8_t *)stream;
+	aprintf("sdl : Fill : rd %lu wr:%lu nb asked:%lu \n",rd_ptr,wr_ptr,nb_sample);
+	if(wr_ptr>rd_ptr)
+	{
+		left=wr_ptr-rd_ptr-1;	
+		if(left>nb_sample)
+		{
+			memcpy(out,in,nb_sample*2);
+			rd_ptr+=nb_sample;
+		}
+		else
+		{
+			memcpy(out,in,left*2);
+			memset(out+left*2,0,(nb_sample-left)*2);
+			rd_ptr+=left;
+		}
+	}
+	else
+	{
+		// wrap
+		left=BUFFER_SIZE-rd_ptr-1;
+		if(left>nb_sample)
+		{
+			memcpy(out,in,nb_sample*2);
+			rd_ptr+=nb_sample;
+		}
+		else
+		{
+			memcpy(out,in,left*2);
+			out+=left*2;
+			rd_ptr=0;
+			in=(uint8_t *)&audioBuffer[0];
+			nb_sample-=left;
+			if(nb_sample>wr_ptr-1) nb_sample=wr_ptr-1;
+			memcpy(out,in,nb_sample*2);
+			rd_ptr=nb_sample;	
+		}
+	}
+	
+
+}
+
+//_______________________________________________
+//
+//
+//_______________________________________________
+uint8_t sdlAudioDevice::init(uint8_t channels, uint32_t fq) 
+{
+SDL_AudioSpec spec,result;
+_channels = channels;
+		
+		printf("[SDL] Opening audio, fq=%d\n",fq);
+
+		if(_inUse) 
+		{
+			printf("[SDL] Already running ?\n");
+			return 1; // ???
+		}
+		
+		if (SDL_InitSubSystem(SDL_INIT_AUDIO) < 0) 
+		{
+			printf("[SDL] FAILED initialising Audio subsystem\n");
+			printf("[SDL] ERROR: %s\n", SDL_GetError());
+			return 0;
+		}
+		memset(&spec,0,sizeof(spec));
+		memset(&result,0,sizeof(result));
+		spec.freq=fq;
+		spec.channels=channels;
+		spec.samples=65536>>4; // 1 second worth of audio
+		spec.callback=SDL_callback;
+		spec.userdata=NULL;
+		spec.format=AUDIO_S16;
+	
+		int res=SDL_OpenAudio(&spec,&result);
+		if(res<0)
+		{
+			printf("[SDL] Audio device FAILED to open\n");
+			printf("[SDL] ERROR: %s\n", SDL_GetError());
+
+			printf("fq   %d \n",spec.freq);
+			printf("chan %d \n", spec.channels);
+			printf("samples %d \n",spec.samples);
+			printf("format %d \n",spec.format);
+			
+			printf("fq   %d \n",result.freq);
+			printf("chan %d \n", result.channels);
+			printf("samples %d \n",result.samples);
+			printf("format %d \n",result.format);
+
+			return 0;
+		}
+		
+	frameCount=0;
+	
+	audioBuffer=new int16_t[BUFFER_SIZE]; // between hald a sec and a sec should be enough :)
+	
+    return 1;
+}
+
+//_______________________________________________
+//
+//
+//_______________________________________________
+uint8_t sdlAudioDevice::play(uint32_t len, float *data)
+ {
+ 	// First put stuff into the buffer
+	uint8_t *src;
+	uint32_t left;
+
+	dither16(data, len, _channels);
+	
+	// Check we have room left
+	if(wr_ptr>=rd_ptr)
+	{
+		left=BUFFER_SIZE-(wr_ptr-rd_ptr);
+	}
+	else
+	{
+		left=rd_ptr-wr_ptr;
+	}
+	if(len+1>left)
+	{
+		printf("AudioCore:Buffer full!\n");
+		
+		return 0;
+	}
+
+	// We have room left, copy it
+	src=(uint8_t *)&audioBuffer[wr_ptr];
+	
+	SDL_LockAudio();
+	
+	if(wr_ptr+len<BUFFER_SIZE)
+	{
+		memcpy(src,data,len*2);
+		wr_ptr+=len;
+	}
+	else
+	{
+		left=BUFFER_SIZE-wr_ptr-1;
+		memcpy(src,data,left*2);
+		memcpy(audioBuffer,data+left*2,(len-left)*2);
+		wr_ptr=len-left;	
+	}
+	
+	//aprintf("AudioSDL: Putting %lu bytes rd:%lu wr:%lu \n",len*2,rd_ptr,wr_ptr);
+	SDL_UnlockAudio();
+ 	if(!frameCount)
+	{
+		_inUse=1;
+		SDL_PauseAudio(0);;
+	}
+	
+	return 1;
+}
+
+uint8_t sdlAudioDevice::setVolume(int volume){
+#ifdef OSS_SUPPORT
+        ossAudioDevice dev;
+        dev.setVolume(volume);
+#else
+#ifdef ALSA_SUPPORT
+        alsaAudioDevice dev;
+        dev.setVolume(volume);
+#endif
+#endif
+	return 1;
+}
+
+#else
+void dummy_as_func( void);
+void dummy_as_func( void)
+ {
+}
+
+#endif
+

Copied: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Sdl/ADM_deviceSDL.h (from rev 4183, branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceSDL.h)
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceSDL.h	2008-07-03 19:29:21 UTC (rev 4183)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Sdl/ADM_deviceSDL.h	2008-07-03 19:29:25 UTC (rev 4184)
@@ -0,0 +1,26 @@
+//
+// C++ Interface: ADM_deviceSDL
+//
+// Description: 
+//
+//
+// Author: mean <fixounet at free.fr>, (C) 2004
+//
+// Copyright: See COPYING file that comes with this distribution
+//
+//
+#ifdef USE_SDL
+
+	        class sdlAudioDevice : public audioDevice
+	 {
+		 protected :
+					uint8_t				_inUse;
+		  public:
+		  				sdlAudioDevice(void);
+		     		virtual uint8_t init(uint8_t channels, uint32_t fq);
+	    			virtual uint8_t play(uint32_t len, float *data);
+		      		virtual uint8_t stop(void);
+				uint8_t setVolume(int volume);
+		 }     ;
+
+#endif

Copied: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Sdl/CMakeLists.txt (from rev 4183, branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/oss_out.cpp)
===================================================================

Copied: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Win32/ADM_deviceWin32.cpp (from rev 4183, branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceWin32.cpp)
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceWin32.cpp	2008-07-03 19:29:21 UTC (rev 4183)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Win32/ADM_deviceWin32.cpp	2008-07-03 19:29:25 UTC (rev 4184)
@@ -0,0 +1,192 @@
+//
+// C++ Implementation: ADM_deviceWin32
+//
+// Description: 
+// C++ Implementation: ADM_deviceWin32
+// Use MM layer to output sound
+//
+// Author: mean <fixounet at free.fr>, (C) 2004
+//
+// Copyright: See COPYING file that comes with this distribution
+//
+
+#include "config.h"
+
+#ifdef __WIN32
+#include <stdio.h>
+#include <stdlib.h>
+#include <errno.h>
+#include <windows.h>
+
+#include "fourcc.h" 
+#include "ADM_assert.h"
+#include "ADM_audiodevice.h"
+#include "ADM_audiodevice/ADM_deviceWin32.h"
+
+#define MODULE_NAME  MODULE_ADEVICE
+#include "ADM_osSupport/ADM_debugID.h"
+#include "ADM_osSupport/ADM_debug.h"
+
+#define NB_BUCKET 8
+
+static uint32_t bucketSize;
+static HWAVEOUT myDevice;
+static MMRESULT myError;
+
+static void handleMM(MMRESULT err);
+
+WAVEHDR waveHdr[NB_BUCKET];	
+
+win32AudioDevice::win32AudioDevice(void) 
+{
+	printf("[Win32] Creating audio device\n");
+	_inUse=0;
+}
+
+uint8_t win32AudioDevice::stop(void) 
+{
+	if (!_inUse)
+		return 0;
+
+	printf("[Win32] Closing audio\n");
+
+	waveOutReset(myDevice);		
+
+	for (uint32_t i = 0; i < NB_BUCKET; i++)
+		waveOutUnprepareHeader(myDevice, &waveHdr[i], sizeof(WAVEHDR));
+
+	myError = waveOutClose(myDevice);
+
+	if (myError != MMSYSERR_NOERROR)
+	{
+		printf("[Win32] Close failed %d\n", myError);
+		handleMM(myError);
+		return 0;
+	}
+
+	for (uint32_t i = 0; i < NB_BUCKET; i++)
+		delete[] waveHdr[i].lpData;
+
+	_inUse=0;
+	myDevice = NULL;
+
+	return 1;
+}
+
+uint8_t win32AudioDevice::init(uint8_t channels, uint32_t fq) 
+{
+	printf("[Win32] Opening Audio, channels=%u freq=%u\n",channels, fq);
+
+	if (_inUse) 
+	{
+		printf("[Win32] Already running?\n");
+		return 0;
+	}
+
+	_inUse = 1;
+	_channels = channels;
+	bucketSize = channels * fq;
+
+	WAVEFORMATEX wav;
+
+	memset(&wav, 0, sizeof(WAVEFORMATEX));
+
+	wav.wFormatTag = WAVE_FORMAT_PCM;
+	wav.nSamplesPerSec = fq;
+	wav.nChannels = channels;
+	wav.nBlockAlign = 2 * channels;
+	wav.nAvgBytesPerSec = 2 * channels * fq;
+	wav.wBitsPerSample = 16;
+
+	myError = waveOutOpen(&myDevice, WAVE_MAPPER, &wav, NULL, NULL, CALLBACK_NULL);
+
+	if (MMSYSERR_NOERROR != myError)
+	{
+		printf("[Win32] waveOutOpen failed\n");
+		handleMM(myError);
+		return 0;
+	}
+
+	for (uint32_t i = 0; i < NB_BUCKET; i++)
+	{
+		memset(&waveHdr[i], 0, sizeof(WAVEHDR));
+
+		waveHdr[i].dwBufferLength = bucketSize;
+		waveHdr[i].lpData = (char*)new uint8_t[bucketSize];
+
+		if (waveOutPrepareHeader(myDevice, &waveHdr[i], sizeof(WAVEHDR)) != MMSYSERR_NOERROR)
+			printf("[Win32] waveOutPrepareHeader error\n");
+
+		waveHdr[i].dwBufferLength = 0;
+		waveHdr[i].dwFlags |= WHDR_DONE;
+	}
+
+	return 1;
+}
+
+uint8_t  win32AudioDevice::setVolume(int volume) 
+{
+	uint32_t value;
+
+	value = (0xffff * volume) / 100;
+	value = value + (value << 16);
+
+	waveOutSetVolume(myDevice, value);
+
+	return 1;
+}
+
+uint8_t win32AudioDevice::play(uint32_t len, float *data)
+{
+	if (len == 0)
+		return 1;
+
+	dither16(data, len, _channels);
+	len *= 2;
+	uint8_t success = 0;
+
+	for (uint32_t i = 0; i < NB_BUCKET; i++)
+	{
+		if (waveHdr[i].dwFlags & WHDR_DONE)
+		{
+			waveHdr[i].dwFlags &= ~WHDR_DONE;
+
+			if (len > bucketSize)
+				waveHdr[i].dwBufferLength = bucketSize;
+			else
+				waveHdr[i].dwBufferLength = len;
+
+			memcpy(waveHdr[i].lpData, data, waveHdr[i].dwBufferLength);
+			data += waveHdr[i].dwBufferLength;
+			len -= waveHdr[i].dwBufferLength;
+
+			if (waveOutWrite(myDevice, &waveHdr[i], sizeof(WAVEHDR)) == MMSYSERR_NOERROR)
+				success = 1;
+			else
+				break;
+		}
+
+		if (len == 0)
+			break;
+	}
+
+	if (len != 0)
+	{
+		printf("[Win32] No audio buffer available, %u bytes discarded\n", len);
+		return 0;
+	}
+
+	return success;
+}
+
+void handleMM(MMRESULT err)
+{
+#define ERMM(x) if(err==x) printf("[Win32] "#x"\n");
+
+	ERMM(MMSYSERR_ALLOCATED);
+	ERMM(MMSYSERR_BADDEVICEID);
+	ERMM(MMSYSERR_NODRIVER);
+	ERMM(WAVERR_BADFORMAT);
+	ERMM(WAVERR_SYNC);
+}
+#endif

Copied: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Win32/ADM_deviceWin32.h (from rev 4183, branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceWin32.h)
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_deviceWin32.h	2008-07-03 19:29:21 UTC (rev 4183)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Win32/ADM_deviceWin32.h	2008-07-03 19:29:25 UTC (rev 4184)
@@ -0,0 +1,26 @@
+//
+// C++ Interface: ADM_deviceWin32
+//
+// Description: 
+//
+//
+// Author: mean <fixounet at free.fr>, (C) 2004
+//
+// Copyright: See COPYING file that comes with this distribution
+//
+//
+#ifdef __WIN32
+
+class win32AudioDevice : public audioDevice
+{
+protected:
+	uint8_t	_inUse;
+public:
+	win32AudioDevice(void);
+	virtual uint8_t init(uint8_t channels, uint32_t fq);
+	virtual uint8_t play(uint32_t len, float *data);
+	virtual uint8_t stop(void);
+	virtual uint8_t setVolume(int volume);
+};
+
+#endif

Copied: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Win32/CMakeLists.txt (from rev 4183, branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/oss_out.cpp)
===================================================================



From mean at mail.berlios.de  Thu Jul  3 21:29:32 2008
From: mean at mail.berlios.de (mean at BerliOS)
Date: Thu, 3 Jul 2008 21:29:32 +0200
Subject: [Avidemux-svn-commit] r4186 - in
	branches/avidemux_2.5_branch_gruntster/avidemux/ADM_core:
	include src
Message-ID: <200807031929.m63JTWcI029173@sheep.berlios.de>

Author: mean
Date: 2008-07-03 21:29:32 +0200 (Thu, 03 Jul 2008)
New Revision: 4186

Added:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_core/include/ADM_coreAudio.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_core/src/ADM_audioUtils.cpp
Log:
[AudioDevice] more, put dither16 in core to avoid missing symbols on win32


Added: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_core/include/ADM_coreAudio.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_core/include/ADM_coreAudio.h	2008-07-03 19:29:30 UTC (rev 4185)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_core/include/ADM_coreAudio.h	2008-07-03 19:29:32 UTC (rev 4186)
@@ -0,0 +1,19 @@
+/**
+        \file ADM_audioCore.h
+
+*/
+#ifndef ADM_audioCore_H
+#define ADM_audioCore_H
+
+
+
+#define DITHER_SIZE 4800
+#define DITHER_CHANNELS 6
+void            AUDMEncoder_initDither();
+void dither16(float *start, uint32_t nb, uint8_t channels);
+
+
+
+#endif
+//EOF
+

Added: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_core/src/ADM_audioUtils.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_core/src/ADM_audioUtils.cpp	2008-07-03 19:29:30 UTC (rev 4185)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_core/src/ADM_audioUtils.cpp	2008-07-03 19:29:32 UTC (rev 4186)
@@ -0,0 +1,48 @@
+/**
+    \fn ADM_audioUtils.cpp
+    \brief Will be moved later to ADM_coreAudio
+
+
+*/
+#include "ADM_default.h"
+#include "ADM_coreAudio.h"
+#include <math.h>
+
+static float rand_table[DITHER_CHANNELS][DITHER_SIZE];
+
+void AUDMEncoder_initDither(void)
+{
+  printf("Initializing Dithering tables\n");
+	float d, dp;
+	for (int c = 0; c < DITHER_CHANNELS; c++) {
+		dp = 0;
+		for (int i = 0; i < DITHER_SIZE-1; i++) {
+			d = rand() / (float)RAND_MAX - 0.5;
+			rand_table[c][i] = d - dp;
+			dp = d;
+		}
+  		rand_table[c][DITHER_SIZE-1] = 0 - dp;
+	}
+}
+
+void dither16(float *start, uint32_t len, uint8_t channels)
+{
+	static uint16_t nr = 0;
+	int16_t *data_int = (int16_t *)start;
+	float *data = start;
+
+	len /= channels;
+	for (int i = 0; i < len; i++) {
+		for (int c = 0; c < channels; c++) {
+			*data = roundf(*data * 32766 + rand_table[c][nr]);
+			if (*data > 32767.0f) *data = 32767;
+			if (*data < -32768.0f) *data = -32768;
+			*data_int = (int16_t) *data;
+			data++;
+			data_int++;
+		}
+		nr++;
+		if (nr >= DITHER_SIZE)
+			nr = 0;
+	}
+}
\ No newline at end of file



From mean at mail.berlios.de  Thu Jul  3 21:29:31 2008
From: mean at mail.berlios.de (mean at BerliOS)
Date: Thu, 3 Jul 2008 21:29:31 +0200
Subject: [Avidemux-svn-commit] r4185 - in
	branches/avidemux_2.5_branch_gruntster: . avidemux
	avidemux/ADM_audiodevice
	avidemux/ADM_userInterfaces/ADM_commonUI cmake
	plugins/ADM_audioDevices plugins/ADM_audioDevices/Alsa
	plugins/ADM_audioDevices/Esd
	plugins/ADM_audioDevices/PulseAudioSimple
Message-ID: <200807031929.m63JTViG029134@sheep.berlios.de>

Author: mean
Date: 2008-07-03 21:29:30 +0200 (Thu, 03 Jul 2008)
New Revision: 4185

Added:
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/PulseAudioSimple/
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/PulseAudioSimple/ADM_devicePulseSimple.cpp
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/PulseAudioSimple/ADM_devicePulseSimple.h
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/PulseAudioSimple/CMakeLists.txt
Modified:
   branches/avidemux_2.5_branch_gruntster/CMakeLists.txt
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_audiodevice.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/audio_out.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_prefs.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/CMakeLists.txt
   branches/avidemux_2.5_branch_gruntster/cmake/admCheckAudioDeviceLibs.cmake
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Alsa/ADM_deviceALSA.cpp
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Alsa/CMakeLists.txt
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/CMakeLists.txt
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Esd/ADM_deviceEsd.cpp
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Esd/ADM_deviceEsd.h
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Esd/CMakeLists.txt
Log:
[AudioDevices] Alsa fixup+Esd


Modified: branches/avidemux_2.5_branch_gruntster/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/CMakeLists.txt	2008-07-03 19:29:25 UTC (rev 4184)
+++ branches/avidemux_2.5_branch_gruntster/CMakeLists.txt	2008-07-03 19:29:30 UTC (rev 4185)
@@ -142,7 +142,7 @@
 ENDIF (NOT QT4_FOUND)
 
 INCLUDE(admCheckAudioCodecLibs)
-INCLUDE(admCheckAudioDeviceLibs)
+#INCLUDE(admCheckAudioDeviceLibs)
 INCLUDE(admCheckMiscLibs)
 
 ########################################

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_audiodevice.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_audiodevice.cpp	2008-07-03 19:29:25 UTC (rev 4184)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_audiodevice.cpp	2008-07-03 19:29:30 UTC (rev 4185)
@@ -48,8 +48,6 @@
     dummyAudioDevice *a=(dummyAudioDevice *)z;
 }
 // --------- couple of stubs for dummy device  -------------
-uint32_t ADM_av_getNbDevices(void);
-bool     ADM_av_getDeviceInfo(int filter, const char **name, uint32_t *major,uint32_t *minor,uint32_t *patch);
 
 /**
         \fn ADM_av_getNbDevices

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/audio_out.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/audio_out.h	2008-07-03 19:29:25 UTC (rev 4184)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/audio_out.h	2008-07-03 19:29:30 UTC (rev 4185)
@@ -30,6 +30,9 @@
 void 		AVDM_AudioClose(void);
 AUDIO_DEVICE 	AVDM_getCurrentDevice( void);
 uint8_t         AVDM_setVolume(int volume);
+// Get infos
+uint32_t ADM_av_getNbDevices(void);
+bool     ADM_av_getDeviceInfo(int filter, const char **name, uint32_t *major,uint32_t *minor,uint32_t *patch);
 
 #endif
 

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_prefs.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_prefs.cpp	2008-07-03 19:29:25 UTC (rev 4184)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_prefs.cpp	2008-07-03 19:29:30 UTC (rev 4185)
@@ -285,51 +285,21 @@
                               ,{3,      QT_TR_NOOP("Pro Logic II"),NULL}
          };
         diaElemMenu menuMixer(&downmix,QT_TR_NOOP("_Local playback downmixing:"), sizeof(mixerEntries)/sizeof(diaMenuEntry),mixerEntries,"");
-
-		diaMenuEntry audioEntries[] =
-		{
-#if 0
-		#ifdef ALSA_SUPPORT
-			{DEVICE_ALSA, QT_TR_NOOP("ALSA")},
-		#endif
-		#ifdef USE_ARTS
-			{DEVICE_ARTS, QT_TR_NOOP("aRts")},
-		#endif
-		#ifdef __APPLE__
-			{DEVICE_COREAUDIO, QT_TR_NOOP("Core Audio")},
-		#endif
-		#ifdef USE_ESD
-			{DEVICE_ESD, QT_TR_NOOP("ESD")},
-		#endif
-		#ifdef USE_JACK
-			{DEVICE_JACK, QT_TR_NOOP("JACK")},
-		#endif
-		#ifdef OSS_SUPPORT
-			{DEVICE_OSS, QT_TR_NOOP("OSS")},
-		#endif
-		#if	defined(USE_SDL) && !defined(__WIN32)
-			{DEVICE_SDL, QT_TR_NOOP("SDL")},
-		#endif
-		#ifdef __WIN32
-			{DEVICE_WIN32, QT_TR_NOOP("Win32")},
-		#endif
-#endif
-			{0, QT_TR_NOOP("None")}
-		};
-
-        diaElemMenu menuAudio(&newdevice,QT_TR_NOOP("_Audio output:"), sizeof(audioEntries)/sizeof(diaMenuEntry),audioEntries,"");
-                
-#if 0 //def ALSA_SUPPORT
-		diaElemText entryAlsaDevice(&alsaDevice,QT_TR_NOOP("ALSA _device:"),NULL);
-
-          int z,m;
-          m=sizeof(audioEntries)/sizeof(diaMenuEntry);
-          for(z=0;z<m;z++)
-          {
-            if(audioEntries[z].val==DEVICE_ALSA)
-                menuAudio.link(&(audioEntries[z]),1,&entryAlsaDevice);
-          }
-#endif
+//*********** AV_
+		
+//***AV
+        uint32_t nbAudioDevice=ADM_av_getNbDevices();
+        diaMenuEntryDynamic *audioDeviceItems[nbAudioDevice+1];
+        audioDeviceItems[0]=new diaMenuEntryDynamic(0,"Dummy","Dummy");
+        for(int i=0;i<nbAudioDevice;i++)
+        {
+            const char *name;
+            uint32_t major,minor,patch;
+            ADM_av_getDeviceInfo(i, &name, &major,&minor,&patch);
+            audioDeviceItems[i+1]=new diaMenuEntryDynamic(i+1,name,name);
+        }
+        diaElemMenuDynamic menuAudio(&newdevice,QT_TR_NOOP("_AudioDevice"), nbAudioDevice+1, 
+                    audioDeviceItems,NULL);
         // default Post proc
      diaElemToggle     fhzd(&hzd,QT_TR_NOOP("_Horizontal deblocking"));
      diaElemToggle     fvzd(&vzd,QT_TR_NOOP("_Vertical deblocking"));
@@ -516,6 +486,11 @@
 				initSdl(render);
 			#endif
 	}
+        for(int i=0;i<nbAudioDevice+1;i++)
+        {
+            
+            delete audioDeviceItems[i];
+        }
 
 	ADM_dealloc(filterPath);
 	ADM_dealloc(globalGlyphName);

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/CMakeLists.txt	2008-07-03 19:29:25 UTC (rev 4184)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/CMakeLists.txt	2008-07-03 19:29:30 UTC (rev 4185)
@@ -375,7 +375,7 @@
 		TARGET_LINK_LIBRARIES(avidemux2_qt4 ${SDL_LIBRARY})
 	ENDIF (ADM_UI_QT4)
 ENDIF (USE_SDL)
-
+if(0)
 # aRts
 IF (USE_ARTS)
 	IF (ADM_UI_GTK)
@@ -387,33 +387,11 @@
 	ENDIF (ADM_UI_QT4)
 ENDIF (USE_ARTS)
 
-# ALSA
-IF (ALSA_FOUND)
-	IF (ADM_UI_GTK)
-		TARGET_LINK_LIBRARIES(avidemux2_gtk ${ASOUND_LIBRARY})
-	ENDIF (ADM_UI_GTK)
-
-	IF (ADM_UI_QT4)
-		TARGET_LINK_LIBRARIES(avidemux2_qt4 ${ASOUND_LIBRARY})
-	ENDIF (ADM_UI_QT4)
-ENDIF (ALSA_FOUND)
-
-# ESD
-IF (USE_ESD)
-	IF (ADM_UI_GTK)
-		TARGET_LINK_LIBRARIES(avidemux2_gtk ${ESD_LIBRARY_DIR})
-	ENDIF (ADM_UI_GTK)
-
-	IF (ADM_UI_QT4)
-		TARGET_LINK_LIBRARIES(avidemux2_qt4 ${ESD_LIBRARY_DIR})
-	ENDIF (ADM_UI_QT4)
-ENDIF (USE_ESD)
-
 # JACK
 IF (USE_JACK)
 	ADD_LIB_ALL_TARGETS("${JACK_LIBRARY_DIR}")
 ENDIF (USE_JACK)
-
+endif(0)
 # LAME
 IF (HAVE_LIBMP3LAME)
 	ADD_LIB_ALL_TARGETS("${LAME_LIBRARY_DIR}")

Modified: branches/avidemux_2.5_branch_gruntster/cmake/admCheckAudioDeviceLibs.cmake
===================================================================
--- branches/avidemux_2.5_branch_gruntster/cmake/admCheckAudioDeviceLibs.cmake	2008-07-03 19:29:25 UTC (rev 4184)
+++ branches/avidemux_2.5_branch_gruntster/cmake/admCheckAudioDeviceLibs.cmake	2008-07-03 19:29:30 UTC (rev 4185)
@@ -142,4 +142,54 @@
 	MESSAGE("")
 ELSE (UNIX AND NOT APPLE)
 	SET(OSS_CAPABLE FALSE)
-ENDIF (UNIX AND NOT APPLE)
\ No newline at end of file
+ENDIF (UNIX AND NOT APPLE)
+########################################
+# PulseAudioSimple
+########################################
+IF (UNIX AND NOT APPLE)
+	OPTION(PULSEAUDIOSIMPLE "" ON)
+
+	MESSAGE(STATUS "Checking for PULSEAUDIOSIMPLE")
+	MESSAGE(STATUS "*****************************")
+        IF (PULSEAUDIOSIMPLE_INCLUDE_DIR AND PULSEAUDIOSIMPLE_LIBRARIES)
+        # in cache already
+         SET(PULSEAUDIOSIMPLE_FIND_QUIETLY TRUE)
+        ENDIF (PULSEAUDIOSIMPLE_INCLUDE_DIR AND PULSEAUDIOSIMPLE_LIBRARIES)
+
+           # use pkg-config to get the directories and then use these values
+        # in the FIND_PATH() and FIND_LIBRARY() calls
+        INCLUDE(UsePkgConfig)
+        PKGCONFIG(libpulse-simple _PASIncDir _PASLinkDir _PASLinkFlags _PASCflags)
+        SET(PULSEAUDIOSIMPLE_DEFINITIONS ${_PASCflags})
+
+        FIND_PATH(PULSEAUDIOSIMPLE_INCLUDE_DIR pulse/simple.h
+        PATHS
+        ${_PASIncDir}
+        PATH_SUFFIXES pulse
+        )
+
+        FIND_LIBRARY(PULSEAUDIOSIMPLE_LIBRARIES NAMES pulse-simple libpulse-simple
+        PATHS
+        ${_PASLinkDir}
+        )
+
+        IF (PULSEAUDIOSIMPLE_INCLUDE_DIR AND PULSEAUDIOSIMPLE_LIBRARIES)
+         SET(PULSEAUDIOSIMPLE_FOUND TRUE)
+        ELSE (PULSEAUDIOSIMPLE_INCLUDE_DIR AND PULSEAUDIOSIMPLE_LIBRARIES)
+         SET(PULSEAUDIOSIMPLE_FOUND FALSE)
+        ENDIF (PULSEAUDIOSIMPLE_INCLUDE_DIR AND PULSEAUDIOSIMPLE_LIBRARIES)
+
+        IF (PULSEAUDIOSIMPLE_FOUND)
+         IF (NOT PULSEAUDIOSIMPLE_FIND_QUIETLY)
+          MESSAGE(STATUS "Found PulseAudio Simple: ${PULSEAUDIOSIMPLE_LIBRARIES}")
+        ENDIF (NOT PULSEAUDIOSIMPLE_FIND_QUIETLY)
+        SET(USE_PULSE_SIMPLE 1)
+        ELSE (PULSEAUDIOSIMPLE_FOUND)
+         MESSAGE(STATUS "Could NOT find PulseAudioSimple")
+        ENDIF (PULSEAUDIOSIMPLE_FOUND)
+
+        MARK_AS_ADVANCED(PULSEAUDIOSIMPLE_INCLUDE_DIR PULSEAUDIOSIMPLE_LIBRARIES)
+
+ELSE (UNIX AND NOT APPLE)
+	SET(PULSEAUDIOSIMPLE_CAPABLE FALSE)
+ENDIF (UNIX AND NOT APPLE)

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Alsa/ADM_deviceALSA.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Alsa/ADM_deviceALSA.cpp	2008-07-03 19:29:25 UTC (rev 4184)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Alsa/ADM_deviceALSA.cpp	2008-07-03 19:29:30 UTC (rev 4185)
@@ -62,7 +62,7 @@
   static char *pcm_name;
 //  if( prefs->get(DEVICE_AUDIO_ALSA_DEVICE, &pcm_name) != RC_OK )
                pcm_name = ADM_strdup("dmix");
-
+    printf("[Alsa] Using device :%s\n",pcm_name);
  /* Allocate the snd_pcm_hw_params_t structure on the stack. */
     snd_pcm_hw_params_alloca(&hwparams);
     snd_pcm_sw_params_alloca(&swparams);
@@ -74,14 +74,14 @@
     /* specified, SIGIO will be emitted whenever a period has     */
     /* been completely processed by the soundcard.                */
     if (snd_pcm_open(&pcm_handle, pcm_name, stream, SND_PCM_NONBLOCK) < 0) {
-      fprintf(stderr, "Error opening PCM device %s\n", pcm_name);
+      fprintf(stderr, "[Alsa]Error opening PCM device %s\n", pcm_name);
       return(0);
     }
     // past this point we got _init=1 -> partially initialized
     _init=1;
       /* Init hwparams with full configuration space */
     if (snd_pcm_hw_params_any(pcm_handle, hwparams) < 0) {
-      fprintf(stderr, "Can not configure this PCM device.\n");
+      fprintf(stderr, "[Alsa]Can not configure this PCM device.\n");
       ADM_dealloc(pcm_name);
       return(0);
     }
@@ -93,7 +93,7 @@
     /* access, but this is beyond the scope   */
     /* of this introduction.                  */
     if (snd_pcm_hw_params_set_access(pcm_handle, hwparams, SND_PCM_ACCESS_RW_INTERLEAVED) < 0) {
-      fprintf(stderr, "Error setting access.\n");
+      fprintf(stderr, "[Alsa]Error setting access.\n");
       return(0);
     }
 
@@ -107,7 +107,7 @@
     if (snd_pcm_hw_params_set_format(pcm_handle, hwparams, SND_PCM_FORMAT_S16_LE) < 0)
 #endif
     {
-      fprintf(stderr, "Error setting format.\n");
+      fprintf(stderr, "[Alsa]Error setting format.\n");
       return(0);
     }
 	//}
@@ -117,12 +117,12 @@
     dir=0;
     exact_rate = snd_pcm_hw_params_set_rate_near(pcm_handle, hwparams, &fq, &dir);
     if (dir != 0) {
-      fprintf(stderr, "The rate %lu Hz is not supported by your hardware.\n  ==> Using %d Hz instead.\n", fq, exact_rate);
+      fprintf(stderr, "[Alsa]The rate %lu Hz is not supported by your hardware.\n  ==> Using %d Hz instead.\n", fq, exact_rate);
     }
 
     /* Set number of channels */
     if (snd_pcm_hw_params_set_channels(pcm_handle, hwparams, channel) < 0) {
-      fprintf(stderr, "Error setting channels.\n");
+      fprintf(stderr, "[Alsa]Error setting channels.\n");
       return(0);
     }
 #if 0
@@ -130,7 +130,7 @@
 	uint32_t periodsize=1;
     /* Set number of periods. Periods used to be called fragments. */
     if (snd_pcm_hw_params_set_periods(pcm_handle, hwparams, periods, 0) < 0) {
-      fprintf(stderr, "Error setting periods.\n");
+      fprintf(stderr, "[Alsa]Error setting periods.\n");
       return(0);
     }
 #else
@@ -142,7 +142,7 @@
 
 	if ((er=snd_pcm_hw_params_set_buffer_time_near(pcm_handle, hwparams, &buffer_time, &dir)) < 0)
 	  {
-	    printf("Error : hw_params_set_buffer_time\n");
+	    printf("[Alsa]Error : hw_params_set_buffer_time\n");
 	    return(0);
 	  }
 	  // unsigned ?
@@ -153,7 +153,7 @@
 	if (snd_pcm_hw_params_set_period_time_near(pcm_handle, hwparams, buffer_time>>2, 0) < 0)
 	  /* original: alsa_buffer_time/ao_data.bps */
 	  {
-	    printf("Error : hw_params_set_period_time\n");
+	    printf("[Alsa]Error : hw_params_set_period_time\n");
 	    return(0);
 	  }
 #endif
@@ -168,33 +168,33 @@
     /* Apply HW parameter settings to */
     /* PCM device and prepare device  */
     if (snd_pcm_hw_params(pcm_handle, hwparams) < 0) {
-      fprintf(stderr, "Error setting HW params.\n");
+      fprintf(stderr, "[Alsa]Error setting HW params.\n");
       return(0);
     }
 
  	if (snd_pcm_sw_params_current(pcm_handle, swparams) < 0)
 	    {
-	      printf("Error setting SW params.\n");
+	      printf("[Alsa]Error setting SW params.\n");
 	      return(0);
 	    }
 
  	// be sure that playback starts immediatly (or near)
 	  if (snd_pcm_sw_params_set_avail_min(pcm_handle, swparams, 4) < 0)
 	    {
-	      printf("Error setting set_avail_min \n");
+	      printf("[Alsa]Error setting set_avail_min \n");
 	      return(0);
 	    }
 
 	  if (snd_pcm_sw_params(pcm_handle, swparams) < 0)
 	    {
-	      printf("Error:snd_pcm_sw_params\n ");
+	      printf("[Alsa]Error:snd_pcm_sw_params\n ");
 	      return(0);
 	    }
 
 
       if ( snd_pcm_prepare(pcm_handle) < 0)
 	{
-	  printf("Error : snd_pcm_prepare\n");
+	  printf("[Alsa]Error : snd_pcm_prepare\n");
 	  return(0);
 	}
 
@@ -233,16 +233,16 @@
 			{
 				case    -EAGAIN :
 					//wait a bit to flush datas
-					printf("ALSA EAGAIN\n");
+					printf("[Alsa]ALSA EAGAIN\n");
 					snd_pcm_wait(pcm_handle, 1000);
 					continue;
 
 				case    -EPIPE:
-					printf("ALSA EPIPE\n");
+					printf("[Alsa]ALSA EPIPE\n");
 					snd_pcm_prepare(pcm_handle);
 					continue;
 				default:
-					printf("ALSA Error %d : Play %s (len=%lu)\n",ret, snd_strerror(ret),len);
+					printf("[Alsa]ALSA Error %d : Play %s (len=%lu)\n",ret, snd_strerror(ret),len);
 					return 1;
 			}
 		}
@@ -268,7 +268,7 @@
     snd_pcm_drain(pcm_handle);
       if (snd_pcm_close(pcm_handle) < 0)
       {
-		printf("\n Troubles closing alsa\n");
+		printf("[Alsa] Troubles closing alsa\n");
 
       }
      }
@@ -290,25 +290,25 @@
     pcm_name = ADM_strdup("hw:0");
     which_vol = 0;
 	if( (rc=snd_mixer_open(&mixer_handle,0)) < 0 ){
-		printf("ALSA: snd_mixer_open failed: %d\n",rc);
+		printf("[Alsa]: snd_mixer_open failed: %d\n",rc);
 		ADM_dealloc(pcm_name);
 		return 0;
 	}
 // MEANX: Cannot use the real name, does not work with dmix
 	if( (rc=snd_mixer_attach(mixer_handle,"hw:0")) < 0 ){
-		printf("ALSA: snd_mixer_attach failed: %d, %s\n",rc, snd_strerror (rc));
+		printf("[Alsa]: snd_mixer_attach failed: %d, %s\n",rc, snd_strerror (rc));
 		snd_mixer_close(mixer_handle);
 		ADM_dealloc(pcm_name);
 		return 0;
 	}
 	ADM_dealloc(pcm_name);
 	if( (rc=snd_mixer_selem_register(mixer_handle,NULL,NULL)) < 0 ){
-		printf("ALSA: snd_mixer_selem_register failed: %d\n",rc);
+		printf("[Alsa]: snd_mixer_selem_register failed: %d\n",rc);
 		snd_mixer_close(mixer_handle);
 		return 0;
 	}
 	if( (rc=snd_mixer_load(mixer_handle)) < 0 ){
-		printf("ALSA: snd_mixer_load failed: %d\n",rc);
+		printf("[Alsa]: snd_mixer_load failed: %d\n",rc);
 		snd_mixer_close(mixer_handle);
 		return 0;
 	}
@@ -332,9 +332,9 @@
 				printf("ALSA: old val: %lu\n",val*100/max);
 				*/
 				if( (rc=snd_mixer_selem_set_playback_volume_all(elem,volume*max/100)) < 0 ){
-					printf("ALSA: snd_mixer_selem_set_playback_volume_all failed: %d\n",rc);
+					printf("[Alsa]: snd_mixer_selem_set_playback_volume_all failed: %d\n",rc);
 				}
-				printf("ALSA: new %s val: %lu\n",(which_vol?"master":"pcm"),volume);
+				printf("[Alsa]: new %s val: %lu\n",(which_vol?"master":"pcm"),volume);
 				break;
 			}
 		}

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Alsa/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Alsa/CMakeLists.txt	2008-07-03 19:29:25 UTC (rev 4184)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Alsa/CMakeLists.txt	2008-07-03 19:29:30 UTC (rev 4185)
@@ -4,7 +4,7 @@
 SET(ADM_av_alsa_SRCS ADM_deviceALSA.cpp)
 
 ADD_LIBRARY(ADM_av_alsa SHARED ${ADM_av_alsa_SRCS})
-#TARGET_LINK_LIBRARIES(ADM_av_alsa ADM_libalsa)
+TARGET_LINK_LIBRARIES(ADM_av_alsa ${ASOUND_LIBRARY})
 
 INIT_AUDIO_DEVICE(ADM_av_alsa)
 INSTALL_AUDIODEVICE(ADM_av_alsa)

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/CMakeLists.txt	2008-07-03 19:29:25 UTC (rev 4184)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/CMakeLists.txt	2008-07-03 19:29:30 UTC (rev 4185)
@@ -1 +1,12 @@
+include(admCheckAudioDeviceLibs)
+if(ALSA_SUPPORT)
 ADD_SUBDIRECTORY(Alsa)
+endif(ALSA_SUPPORT)
+
+if(USE_PULSE_SIMPLE)
+ADD_SUBDIRECTORY(PulseAudioSimple)
+endif(USE_PULSE_SIMPLE)
+
+if(USE_ESD)
+ADD_SUBDIRECTORY(Esd)
+endif(USE_ESD)

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Esd/ADM_deviceEsd.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Esd/ADM_deviceEsd.cpp	2008-07-03 19:29:25 UTC (rev 4184)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Esd/ADM_deviceEsd.cpp	2008-07-03 19:29:30 UTC (rev 4185)
@@ -15,26 +15,16 @@
  *   (at your option) any later version.                                   *
  *                                                                         *
  ***************************************************************************/
-#include "config.h"
-
-#if defined(USE_ESD)
-#include <stdio.h>
-#include <stdlib.h>
-#include <unistd.h>
-#include <errno.h>
-
-#include <fcntl.h>
-#include <sys/ioctl.h>
-#include <esd.h>
-
 #include "ADM_default.h"
 #include "ADM_audiodevice.h"
-#include "ADM_assert.h"
-#include "ADM_audiodevice/ADM_deviceoss.h"
-#include "ADM_audiodevice/ADM_deviceALSA.h"
-#include  "ADM_audiodevice/ADM_deviceEsd.h"
 
 
+#include  "ADM_audiodevice.h"
+#include  "ADM_audioDeviceInternal.h"
+
+#include  "ADM_deviceEsd.h"
+#include <esd.h>
+ADM_DECLARE_AUDIODEVICE(Esd,esdAudioDevice,1,0,0,"Esd audio device (c) mean");
 //_______________________________________________
 //
 //
@@ -51,7 +41,7 @@
 //
 //
 //_______________________________________________
-uint8_t esdAudioDevice::init(uint8_t channels, uint32_t fq) 
+uint8_t esdAudioDevice::init(uint32_t channels, uint32_t fq) 
 {
 esd_format_t format;
 _channels = channels;
@@ -102,10 +92,4 @@
 	return 1;
 }
 
-#else
-void dummy_ess_func( void);
-void dummy_ess_func( void)
- {
-}
-
-#endif
+//EOF

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Esd/ADM_deviceEsd.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Esd/ADM_deviceEsd.h	2008-07-03 19:29:25 UTC (rev 4184)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Esd/ADM_deviceEsd.h	2008-07-03 19:29:30 UTC (rev 4185)
@@ -14,16 +14,16 @@
  *   (at your option) any later version.                                   *
  *                                                                         *
  ***************************************************************************/
-#ifdef USE_ESD
+
 class esdAudioDevice : public audioDevice
 	 {
 		 protected :
                     int esdDevice;
 		  public:
 		  			esdAudioDevice(void) {esdDevice=-1;}
-		     		virtual uint8_t init(uint8_t channels, uint32_t fq);
+		     		virtual uint8_t init(uint32_t channels, uint32_t fq);
 	    			virtual uint8_t play(uint32_t len, float *data);
 		      		virtual uint8_t stop(void);
-				uint8_t setVolume(int volume);
+                            uint8_t setVolume(int volume);
 		 }     ;
-#endif
+

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Esd/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Esd/CMakeLists.txt	2008-07-03 19:29:25 UTC (rev 4184)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Esd/CMakeLists.txt	2008-07-03 19:29:30 UTC (rev 4185)
@@ -0,0 +1,12 @@
+INCLUDE(av_plugin)
+
+
+SET(ADM_av_esd_SRCS ADM_deviceEsd.cpp)
+
+ADD_LIBRARY(ADM_av_esd SHARED ${ADM_av_esd_SRCS})
+INCLUDE_DIRECTORIES(${ESD_INCLUDE_DIR})
+TARGET_LINK_LIBRARIES(ADM_av_esd ${ESD_LIBRARY_DIR})
+
+
+INIT_AUDIO_DEVICE(ADM_av_esd)
+INSTALL_AUDIODEVICE(ADM_av_esd)

Added: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/PulseAudioSimple/ADM_devicePulseSimple.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/PulseAudioSimple/ADM_devicePulseSimple.cpp	2008-07-03 19:29:25 UTC (rev 4184)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/PulseAudioSimple/ADM_devicePulseSimple.cpp	2008-07-03 19:29:30 UTC (rev 4185)
@@ -0,0 +1,123 @@
+/***************************************************************************
+                          ADM_devicePulseSimple.cpp  -  description
+
+  Simple Pulse audio out
+                          
+    copyright            : (C) 2008 by mean
+    email                : fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include "ADM_default.h"
+#include "ADM_audiodevice.h"
+
+
+#include  "ADM_audiodevice.h"
+#include  "ADM_audioDeviceInternal.h"
+#include  "ADM_devicePulseSimple.h"
+#include  "pulse/simple.h"
+
+ADM_DECLARE_AUDIODEVICE(PulseAudioS,pulseSimpleAudioDevice,1,0,0,"PulseAudioSimple audio device (c) mean");
+
+//#define ADM_PULSE_INT16
+/**
+    \fn pulseSimpleAudioDevice
+    \brief Constructor
+
+*/
+pulseSimpleAudioDevice::pulseSimpleAudioDevice()
+{
+    instance=NULL;
+}
+
+#define INSTANCE  ((pa_simple *)instance)
+/**
+    \fn stop
+    \brief stop & release device
+
+*/
+
+uint8_t  pulseSimpleAudioDevice::stop(void) 
+{
+int er;
+    if(!instance) return 1;
+    ADM_assert(instance);
+    pa_simple_flush(INSTANCE,&er);
+    pa_simple_free(INSTANCE);
+    instance=NULL;
+    printf("[PulseAudio] Stopped\n");
+    return 1;
+}
+
+/**
+    \fn init
+    \brief Take & initialize the device
+
+*/
+uint8_t pulseSimpleAudioDevice::init(uint32_t channels, uint32_t fq) 
+{
+
+pa_simple *s;
+pa_sample_spec ss;
+int er;
+ 
+#ifdef ADM_PULSE_INT16
+  ss.format = PA_SAMPLE_S16NE;
+#else
+    ss.format = PA_SAMPLE_FLOAT32NE;//PA_SAMPLE_S16NE; //FIXME big endian
+#endif
+  ss.channels = channels;
+  ss.rate =fq;
+ 
+  instance= pa_simple_new(NULL,               // Use the default server.
+                    "Avidemux2",           // Our application's name.
+                    PA_STREAM_PLAYBACK,
+                    NULL,               // Use the default device.
+                    "Sound",            // Description of our stream.
+                    &ss,                // Our sample format.
+                    NULL,               // Use default channel map
+                    NULL ,             // Use default buffering attributes.
+                    &er               // Ignore error code.
+                    );
+  if(!instance)
+    {
+        printf("[PulseSimple] open failed\n");
+        return 0;
+    }
+    printf("[PulseSimple] open ok\n");
+    return 1;
+
+}
+
+/**
+    \fn play
+    \brief Playback samples
+
+*/
+uint8_t pulseSimpleAudioDevice::play(uint32_t len, float *data)
+{
+int er;
+#ifdef ADM_PULSE_INT16
+	dither16(data, len, _channels);
+    pa_simple_write(INSTANCE,data,len*2,&er);
+#else
+    pa_simple_write(INSTANCE,data,len*4,&er);
+#endif
+	return 1;
+}
+/**
+    \fn setVolume
+    \brief Cannot be done with pulse simple
+*/
+uint8_t pulseSimpleAudioDevice::setVolume(int volume)
+{
+	return 1;
+}
+//EOF
\ No newline at end of file

Copied: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/PulseAudioSimple/ADM_devicePulseSimple.h (from rev 4184, branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Esd/ADM_deviceEsd.h)
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Esd/ADM_deviceEsd.h	2008-07-03 19:29:25 UTC (rev 4184)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/PulseAudioSimple/ADM_devicePulseSimple.h	2008-07-03 19:29:30 UTC (rev 4185)
@@ -0,0 +1,29 @@
+/***************************************************************************
+                          ADM_deviceEsd.h  -  description
+                             -------------------
+                             Audio device for ESD sound daemon
+    copyright            : (C) 2005 by mean
+    email                : fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+class pulseSimpleAudioDevice : public audioDevice
+	 {
+		 protected :
+                    void  *instance;
+		  public:
+		  			pulseSimpleAudioDevice(void);
+		     		virtual uint8_t init(uint32_t channels, uint32_t fq);
+	    			virtual uint8_t play(uint32_t len, float *data);
+		      		virtual uint8_t stop(void);
+				    uint8_t setVolume(int volume);
+		 }     ;
+

Added: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/PulseAudioSimple/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/PulseAudioSimple/CMakeLists.txt	2008-07-03 19:29:25 UTC (rev 4184)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/PulseAudioSimple/CMakeLists.txt	2008-07-03 19:29:30 UTC (rev 4185)
@@ -0,0 +1,10 @@
+INCLUDE(av_plugin)
+
+
+SET(ADM_av_pulseAudioSimple_SRCS ADM_devicePulseSimple.cpp)
+
+ADD_LIBRARY(ADM_av_pulseAudioSimple SHARED ${ADM_av_pulseAudioSimple_SRCS})
+ADD_DEFINITIONS(${PULSEAUDIOSIMPLE_DEFINITIONS})
+TARGET_LINK_LIBRARIES(ADM_av_pulseAudioSimple ${PULSEAUDIOSIMPLE_LIBRARIES})
+INIT_AUDIO_DEVICE(ADM_av_pulseAudioSimple)
+INSTALL_AUDIODEVICE(ADM_av_pulseAudioSimple)



From mean at mail.berlios.de  Thu Jul  3 21:29:35 2008
From: mean at mail.berlios.de (mean at BerliOS)
Date: Thu, 3 Jul 2008 21:29:35 +0200
Subject: [Avidemux-svn-commit] r4187 - in
	branches/avidemux_2.5_branch_gruntster:
	avidemux/ADM_audiodevice avidemux/ADM_audiofilter
	avidemux/ADM_core/src cmake plugins/ADM_audioDevices
	plugins/ADM_audioDevices/Arts plugins/ADM_audioDevices/Jack
	plugins/ADM_audioDevices/Oss plugins/ADM_audioDevices/Sdl
Message-ID: <200807031929.m63JTZ0v029198@sheep.berlios.de>

Author: mean
Date: 2008-07-03 21:29:34 +0200 (Thu, 03 Jul 2008)
New Revision: 4187

Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_audiodevice.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioencoder.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioencoder.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_core/src/CMakeLists.txt
   branches/avidemux_2.5_branch_gruntster/cmake/admCheckAudioDeviceLibs.cmake
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Arts/ADM_deviceArts.cpp
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Arts/ADM_deviceArts.h
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Arts/CMakeLists.txt
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/CMakeLists.txt
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Jack/CMakeLists.txt
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Oss/ADM_deviceoss.cpp
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Oss/ADM_deviceoss.h
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Oss/CMakeLists.txt
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Sdl/ADM_deviceSDL.cpp
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Sdl/ADM_deviceSDL.h
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Sdl/CMakeLists.txt
Log:
[AudioDevice] more, put dither16 in core to avoid missing symbols on win32


Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_audiodevice.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_audiodevice.h	2008-07-03 19:29:32 UTC (rev 4186)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_audiodevice.h	2008-07-03 19:29:34 UTC (rev 4187)
@@ -13,7 +13,7 @@
 #define ADM_AUDIODEVICE_H
 
 // Converts float to int16_t with dithering
-extern void dither16(float *start, uint32_t nb, uint8_t channels);
+#include "ADM_coreAudio.h"
 
  class audioDevice
  {

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioencoder.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioencoder.cpp	2008-07-03 19:29:32 UTC (rev 4186)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioencoder.cpp	2008-07-03 19:29:34 UTC (rev 4187)
@@ -95,44 +95,7 @@
   }
 }
 
-static float rand_table[DITHER_CHANNELS][DITHER_SIZE];
 
-void AUDMEncoder_initDither(void)
-{
-  printf("Initializing Dithering tables\n");
-	float d, dp;
-	for (int c = 0; c < DITHER_CHANNELS; c++) {
-		dp = 0;
-		for (int i = 0; i < DITHER_SIZE-1; i++) {
-			d = rand() / (float)RAND_MAX - 0.5;
-			rand_table[c][i] = d - dp;
-			dp = d;
-		}
-  		rand_table[c][DITHER_SIZE-1] = 0 - dp;
-	}
-}
-
-void dither16(float *start, uint32_t len, uint8_t channels)
-{
-	static uint16_t nr = 0;
-	int16_t *data_int = (int16_t *)start;
-	float *data = start;
-
-	len /= channels;
-	for (int i = 0; i < len; i++) {
-		for (int c = 0; c < channels; c++) {
-			*data = roundf(*data * 32766 + rand_table[c][nr]);
-			if (*data > 32767.0f) *data = 32767;
-			if (*data < -32768.0f) *data = -32768;
-			*data_int = (int16_t) *data;
-			data++;
-			data_int++;
-		}
-		nr++;
-		if (nr >= DITHER_SIZE)
-			nr = 0;
-	}
-}
 /**
  * 	\fn reorderChannels
  *  \brief Reorder the channels

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioencoder.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioencoder.h	2008-07-03 19:29:32 UTC (rev 4186)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioencoder.h	2008-07-03 19:29:34 UTC (rev 4187)
@@ -15,6 +15,7 @@
   \param maxChannels The maximum # of channels this codec supports
   \param param : An opaque structure that contains the codec specific configuration datas
 */
+#include "ADM_coreAudio.h"
 #include "audioeng_buildfilters.h"
 
 typedef struct ADM_audioEncoderDescriptor
@@ -32,10 +33,6 @@
   Base class for all audio encoder.It does the reverse of the bridge class and offers a proper GenericAudioStreamAPI
 
 */
-#define DITHER_SIZE 4800
-#define DITHER_CHANNELS 6
-void            AUDMEncoder_initDither();
-void dither16(float *start, uint32_t nb, uint8_t channels);
 
  //_____________________________________________
 class AUDMEncoder : public AVDMGenericAudioStream

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_core/src/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_core/src/CMakeLists.txt	2008-07-03 19:29:32 UTC (rev 4186)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_core/src/CMakeLists.txt	2008-07-03 19:29:34 UTC (rev 4187)
@@ -1,6 +1,8 @@
 SET(ADM_core_SRCS 
 	ADM_cpuCap.cpp  ADM_memcpy.cpp  ADM_memsupport.cpp  ADM_threads.cpp  ADM_win32.cpp
-	ADM_memory.cpp  ADM_misc.cpp  TLK_clock.cpp  ADM_crashdump.cpp  ADM_fileio.cpp ADM_dynamicLoading.cpp)
+	ADM_memory.cpp  ADM_misc.cpp  TLK_clock.cpp  ADM_crashdump.cpp  ADM_fileio.cpp ADM_dynamicLoading.cpp
+        ADM_audioUtils.cpp
+)
 
 ADD_LIBRARY(ADM_core SHARED ${ADM_core_SRCS})
 ADD_TARGET_DEFINITIONS(ADM_core ADM_DEBUG FIND_LEAKS)
@@ -14,4 +16,4 @@
 
 REMOVE_DEFINITIONS(-DHAVE_CONFIG_H)
 
-INSTALL(TARGETS ADM_core RUNTIME DESTINATION ${BIN_DIR}  LIBRARY DESTINATION lib  ARCHIVE DESTINATION lib)
\ No newline at end of file
+INSTALL(TARGETS ADM_core RUNTIME DESTINATION ${BIN_DIR}  LIBRARY DESTINATION lib  ARCHIVE DESTINATION lib)

Modified: branches/avidemux_2.5_branch_gruntster/cmake/admCheckAudioDeviceLibs.cmake
===================================================================
--- branches/avidemux_2.5_branch_gruntster/cmake/admCheckAudioDeviceLibs.cmake	2008-07-03 19:29:32 UTC (rev 4186)
+++ branches/avidemux_2.5_branch_gruntster/cmake/admCheckAudioDeviceLibs.cmake	2008-07-03 19:29:34 UTC (rev 4187)
@@ -16,7 +16,7 @@
 			MESSAGE(STATUS "  version: ${alsaVersion}")
 			PRINT_LIBRARY_INFO("ALSA" ALSA_FOUND "${_ALSA_INCLUDE_DIR}" "${ASOUND_LIBRARY}")
 
-			SET(ALSA_SUPPORT 1)
+			SET(USE_ALSA 1)
 		ENDIF (ALSA_FOUND)
 	ELSE (ALSA)
 		MESSAGE("${MSG_DISABLE_OPTION}")
@@ -133,7 +133,7 @@
 		PRINT_LIBRARY_INFO("OSS" OSS_FOUND "${OSS_INCLUDE_DIR}" "")
 
 		IF (OSS_FOUND)
-			SET(OSS_SUPPORT 1)
+			SET(USE_OSS 1)
 		ENDIF (OSS_FOUND)
 	ELSE (OSS)
 		MESSAGE("${MSG_DISABLE_OPTION}")

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Arts/ADM_deviceArts.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Arts/ADM_deviceArts.cpp	2008-07-03 19:29:32 UTC (rev 4186)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Arts/ADM_deviceArts.cpp	2008-07-03 19:29:34 UTC (rev 4187)
@@ -15,17 +15,18 @@
  *                                                                         *
  ***************************************************************************/
 
-#include "config.h"
+
 #include "ADM_default.h"
 
-#ifdef USE_ARTS
+
 #include <artsc.h>
 
-#include "ADM_audiodevice.h"
-#include  "ADM_audiodevice/ADM_deviceoss.h"
-#include  "ADM_audiodevice/ADM_deviceArts.h"
+#include  "ADM_audiodevice.h"
+#include  "ADM_audioDeviceInternal.h"
+#include  "ADM_deviceArts.h"
 
 uint8_t artsInitialized=0;
+ADM_DECLARE_AUDIODEVICE(Arts,artsAudioDevice,1,0,0,"Arts audio device (c) mean");
 //_______________________________________________
 //
 //
@@ -49,7 +50,7 @@
 //
 //
 //_______________________________________________
-uint8_t artsAudioDevice::init(uint8_t channels, uint32_t fq)
+uint8_t artsAudioDevice::init(uint32_t channels, uint32_t fq)
 {
 	_channels = channels;
 

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Arts/ADM_deviceArts.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Arts/ADM_deviceArts.h	2008-07-03 19:29:32 UTC (rev 4186)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Arts/ADM_deviceArts.h	2008-07-03 19:29:34 UTC (rev 4187)
@@ -15,19 +15,19 @@
  *                                                                         *
  ***************************************************************************/
 
- #ifdef USE_ARTS
-                 class artsAudioDevice : public audioDevice
+ 
+     class artsAudioDevice : public audioDevice
 	 {
 		 protected :
 		 		arts_stream_t _stream;
 		  public:
 		  			artsAudioDevice() {_stream=NULL;}
 				virtual ~artsAudioDevice() {stop();}
-		     		virtual uint8_t init(uint8_t channels, uint32_t fq);
+		     		virtual uint8_t init(uint32_t channels, uint32_t fq);
 	    			virtual uint8_t play(uint32_t len, float *data);
 		      		virtual uint8_t stop(void);
 				uint8_t setVolume(int volume);
 		 };
-#endif
 
 
+

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Arts/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Arts/CMakeLists.txt	2008-07-03 19:29:32 UTC (rev 4186)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Arts/CMakeLists.txt	2008-07-03 19:29:34 UTC (rev 4187)
@@ -0,0 +1,10 @@
+INCLUDE(av_plugin)
+
+
+SET(ADM_av_arts_SRCS ADM_deviceArts.cpp)
+
+ADD_LIBRARY(ADM_av_arts SHARED ${ADM_av_arts_SRCS})
+TARGET_LINK_LIBRARIES(ADM_av_arts ${ARTS_LDFLAGS})
+ADD_DEFINITIONS(${ARTS_CFLAGS})
+INIT_AUDIO_DEVICE(ADM_av_arts)
+INSTALL_AUDIODEVICE(ADM_av_arts)

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/CMakeLists.txt	2008-07-03 19:29:32 UTC (rev 4186)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/CMakeLists.txt	2008-07-03 19:29:34 UTC (rev 4187)
@@ -1,7 +1,7 @@
 include(admCheckAudioDeviceLibs)
-if(ALSA_SUPPORT)
+if(USE_ALSA)
 ADD_SUBDIRECTORY(Alsa)
-endif(ALSA_SUPPORT)
+endif(USE_ALSA)
 
 if(USE_PULSE_SIMPLE)
 ADD_SUBDIRECTORY(PulseAudioSimple)
@@ -10,3 +10,20 @@
 if(USE_ESD)
 ADD_SUBDIRECTORY(Esd)
 endif(USE_ESD)
+
+if(USE_SDL)
+ADD_SUBDIRECTORY(Sdl)
+endif(USE_SDL)
+
+if(USE_OSS)
+ADD_SUBDIRECTORY(Oss)
+endif(USE_OSS)
+
+if(USE_ARTS)
+ADD_SUBDIRECTORY(Arts)
+endif(USE_ARTS)
+
+if(USE_JACK)
+ADD_SUBDIRECTORY(Jack)
+endif(USE_JACK)
+#

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Jack/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Jack/CMakeLists.txt	2008-07-03 19:29:32 UTC (rev 4186)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Jack/CMakeLists.txt	2008-07-03 19:29:34 UTC (rev 4187)
@@ -0,0 +1,11 @@
+INCLUDE(av_plugin)
+
+
+SET(ADM_av_jack_SRCS ADM_deviceJack.cpp)
+
+ADD_LIBRARY(ADM_av_jack SHARED ${ADM_av_jack_SRCS})
+TARGET_LINK_LIBRARIES(ADM_av_jack ${JACK_LIBRARY_DIR})
+include_directories(${JACK_INCLUDE_DIR})
+
+INIT_AUDIO_DEVICE(ADM_av_jack)
+INSTALL_AUDIODEVICE(ADM_av_jack)

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Oss/ADM_deviceoss.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Oss/ADM_deviceoss.cpp	2008-07-03 19:29:32 UTC (rev 4186)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Oss/ADM_deviceoss.cpp	2008-07-03 19:29:34 UTC (rev 4187)
@@ -14,12 +14,12 @@
  *   (at your option) any later version.                                   *
  *                                                                         *
  ***************************************************************************/
-#include "config.h"
 
-#ifdef OSS_SUPPORT
-#include <stdio.h>
-#include <stdlib.h>
-#include <unistd.h>
+#include "ADM_default.h"
+
+#include  "ADM_audiodevice.h"
+#include  "ADM_audioDeviceInternal.h"
+
 #include <errno.h>
 
 #include <fcntl.h>
@@ -38,18 +38,12 @@
 	#include <sys/soundcard.h>
 	const char *dsp = "/dev/dsp";
         const char *device_mixer = "/dev/mixer";
-
 #endif
- 
- 
 
-#include "ADM_default.h"
-#include "ADM_audiodevice.h"
-#include "ADM_assert.h"
-#include  "ADM_audiodevice/ADM_deviceoss.h"
-#include "DIA_coreToolkit.h"
-#include "prefs.h"
+#include  "ADM_deviceoss.h"
 
+ADM_DECLARE_AUDIODEVICE(Oss,ossAudioDevice,1,0,0,"Oss audio device (c) mean");
+
 //_______________________________________________
 //
 //
@@ -60,14 +54,14 @@
 	int ret;
 	uint32_t which_vol = 0;
 
-	prefs->get(FEATURE_AUDIOBAR_USES_MASTER,&which_vol);
+	//prefs->get(FEATURE_AUDIOBAR_USES_MASTER,&which_vol);
         fd=open(device_mixer,O_RDONLY);
         if(!fd)
         {
-                printf("OSS: cannot open mixer\n");
+                printf("[OSSS]: cannot open mixer\n");
                 return 0;
         }
-        printf("Oss: New %s volume %d\n",(which_vol?"master":"pcm"),volume);
+        printf("[OSSS]: New %s volume %d\n",(which_vol?"master":"pcm"),volume);
         // Assuming stereo
         volume=volume+(volume<<8);
 	if( which_vol ){
@@ -79,9 +73,9 @@
 
 	if( ret ){
 		if( errno == EBADF ){
-			printf("set mixer failed: %u (possible access issue)\n",errno);
+			printf("[OSSS]set mixer failed: %u (possible access issue)\n",errno);
 		}else{
-			printf("set mixer failed: %u\n",errno);
+			printf("[OSSS]set mixer failed: %u\n",errno);
 		}
 	}
         return 1;
@@ -104,36 +98,38 @@
 //
 //
 //_______________________________________________
-uint8_t ossAudioDevice::init(uint8_t channels, uint32_t fq) 
+uint8_t ossAudioDevice::init(uint32_t channels, uint32_t fq) 
 {
 	_channels = channels;
  
-    printf("\n OSS  : %lu Hz, %lu channels", fq, channels);
+    printf("[OSSS]: %lu Hz, %lu channels\n", fq, channels);
     // open OSS device
     oss_fd = open(dsp, O_WRONLY | O_NONBLOCK);
     if (oss_fd == -1) {
+/*
 	if( errno == EACCES )
 	{
           GUI_Error_HIG(QT_TR_NOOP("Could not open OSS audio device"), QT_TR_NOOP("Check the permissions for /dev/dsp."));
 	  }
 	else
-           printf("\n Error initializing OSS: Error : %d", errno);
+*/
+           printf("[OSSS] Error initializing OSS: Error : %d\n", errno);
         return 0;
     }
     // seems ok, set up audio 
     if (ioctl (oss_fd, SNDCTL_DSP_SPEED, &fq) < 0) {
-        printf("\n Error setting up OSS(SPEED): Error : %d", errno);
+        printf("[OSSS] Error setting up OSS(SPEED): Error : %d\n", errno);
         return 0;
     }
     if (channels > 2) {
         if (ioctl (oss_fd, SNDCTL_DSP_CHANNELS, &channels) < 0) {
-	    printf("\n Error setting up OSS(CHANNELS): Error : %d", errno);
+	    printf("[OSSS] Error setting up OSS(CHANNELS): Error : %d\n", errno);
 	    return 0;
         }
     } else {
         int chan = channels - 1;
         if (ioctl (oss_fd, SNDCTL_DSP_STEREO, &chan) < 0) {
-	    printf("\n Error setting up OSS(STEREO): Error : %d", errno);
+	    printf("[OSSS] Error setting up OSS(STEREO): Error : %d\n", errno);
 	    return 0;
         }
     }
@@ -143,7 +139,7 @@
     int fmt = AFMT_S16_LE;
 #endif    
     if (ioctl (oss_fd, SNDCTL_DSP_SETFMT, &fmt) < 0) {
-        printf("\n Error setting up OSS(FORMAT): Error : %d", errno);
+        printf("[OSSS] Error setting up OSS(FORMAT): Error : %d\n", errno);
         return 0;
     }
 
@@ -170,10 +166,4 @@
         }
 	return 1;
 }
-#else
-void dummy_oss_func( void);
-void dummy_oss_func( void)
- {
-}
-
-#endif
+//EOF

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Oss/ADM_deviceoss.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Oss/ADM_deviceoss.h	2008-07-03 19:29:32 UTC (rev 4186)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Oss/ADM_deviceoss.h	2008-07-03 19:29:34 UTC (rev 4187)
@@ -14,16 +14,16 @@
  *   (at your option) any later version.                                   *
  *                                                                         *
  ***************************************************************************/
-#ifdef OSS_SUPPORT
+
 class ossAudioDevice : public audioDevice
 {
 protected :
                                 int oss_fd;
 public:
                                         ossAudioDevice(void) {oss_fd=0;}
-                        virtual uint8_t init(uint8_t channels, uint32_t fq);
+                        virtual uint8_t init(uint32_t channels, uint32_t fq);
                         virtual uint8_t play(uint32_t len, float *data);
                         virtual uint8_t stop(void);
 			uint8_t setVolume(int volume);
 }     ;
-#endif
+

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Oss/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Oss/CMakeLists.txt	2008-07-03 19:29:32 UTC (rev 4186)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Oss/CMakeLists.txt	2008-07-03 19:29:34 UTC (rev 4187)
@@ -0,0 +1,9 @@
+INCLUDE(av_plugin)
+
+
+SET(ADM_av_oss_SRCS ADM_deviceoss.cpp)
+
+ADD_LIBRARY(ADM_av_oss SHARED ${ADM_av_oss_SRCS})
+include_directories(${OSS_INCLUDE_DIR})
+INIT_AUDIO_DEVICE(ADM_av_oss)
+INSTALL_AUDIODEVICE(ADM_av_oss)

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Sdl/ADM_deviceSDL.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Sdl/ADM_deviceSDL.cpp	2008-07-03 19:29:32 UTC (rev 4186)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Sdl/ADM_deviceSDL.cpp	2008-07-03 19:29:34 UTC (rev 4187)
@@ -4,32 +4,21 @@
 // Description: 
 //
 //
-// Author: mean <fixounet at free.fr>, (C) 2004
+// Author: mean <fixounet at free.fr>, (C) 2004-2008
 //
 // Copyright: See COPYING file that comes with this distribution
 //
 //
 
-#include "config.h"
-#include <errno.h>
 
-
 #include "ADM_default.h"
-  
- 
-#ifdef USE_SDL
 #include "SDL.h"
 
+#include  "ADM_audiodevice.h"
+#include  "ADM_audioDeviceInternal.h"
 
+#include "ADM_deviceSDL.h"
 
-#include "ADM_audiodevice.h"
-#include "ADM_audiodevice/ADM_deviceoss.h"
-#include "ADM_audiodevice/ADM_deviceALSA.h"
-#include "ADM_audiodevice/ADM_deviceSDL.h"
-#include "ADM_osSupport/ADM_debugID.h"
-#define MODULE_NAME  MODULE_ADEVICE
-#include "ADM_osSupport/ADM_debug.h"
-
 static int16_t  		*audioBuffer=NULL;
 static uint32_t 		frameCount=0;
 static uint32_t			rd_ptr=0;
@@ -46,6 +35,9 @@
 #define BUFFER_SIZE (2*48000)
 #endif
 
+ADM_DECLARE_AUDIODEVICE(Sdl,sdlAudioDevice,1,0,0,"Sdl audio device (c) mean");
+
+#define aprintf(...) {}
 //_______________________________________________
 //
 //_______________________________________________
@@ -142,7 +134,7 @@
 //
 //
 //_______________________________________________
-uint8_t sdlAudioDevice::init(uint8_t channels, uint32_t fq) 
+uint8_t sdlAudioDevice::init(uint32_t channels, uint32_t fq) 
 {
 SDL_AudioSpec spec,result;
 _channels = channels;
@@ -266,11 +258,5 @@
 	return 1;
 }
 
-#else
-void dummy_as_func( void);
-void dummy_as_func( void)
- {
-}
 
-#endif
 

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Sdl/ADM_deviceSDL.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Sdl/ADM_deviceSDL.h	2008-07-03 19:29:32 UTC (rev 4186)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Sdl/ADM_deviceSDL.h	2008-07-03 19:29:34 UTC (rev 4187)
@@ -9,18 +9,17 @@
 // Copyright: See COPYING file that comes with this distribution
 //
 //
-#ifdef USE_SDL
 
-	        class sdlAudioDevice : public audioDevice
+
+    class sdlAudioDevice : public audioDevice
 	 {
 		 protected :
 					uint8_t				_inUse;
 		  public:
 		  				sdlAudioDevice(void);
-		     		virtual uint8_t init(uint8_t channels, uint32_t fq);
+		     		virtual uint8_t init(uint32_t channels, uint32_t fq);
 	    			virtual uint8_t play(uint32_t len, float *data);
 		      		virtual uint8_t stop(void);
 				uint8_t setVolume(int volume);
 		 }     ;
 
-#endif

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Sdl/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Sdl/CMakeLists.txt	2008-07-03 19:29:32 UTC (rev 4186)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Sdl/CMakeLists.txt	2008-07-03 19:29:34 UTC (rev 4187)
@@ -0,0 +1,11 @@
+INCLUDE(av_plugin)
+
+
+SET(ADM_av_sdl_SRCS ADM_deviceSDL.cpp)
+
+ADD_LIBRARY(ADM_av_sdl SHARED ${ADM_av_sdl_SRCS})
+TARGET_LINK_LIBRARIES(ADM_av_sdl ${SDL_LIBRARY})
+SDLify(ADM_deviceSDL.cpp)
+
+INIT_AUDIO_DEVICE(ADM_av_sdl)
+INSTALL_AUDIODEVICE(ADM_av_sdl)



From mean at mail.berlios.de  Thu Jul  3 21:29:38 2008
From: mean at mail.berlios.de (mean at BerliOS)
Date: Thu, 3 Jul 2008 21:29:38 +0200
Subject: [Avidemux-svn-commit] r4188 - in
	branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices:
	. Win32
Message-ID: <200807031929.m63JTcQa029208@sheep.berlios.de>

Author: mean
Date: 2008-07-03 21:29:38 +0200 (Thu, 03 Jul 2008)
New Revision: 4188

Modified:
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/CMakeLists.txt
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Win32/ADM_deviceWin32.cpp
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Win32/ADM_deviceWin32.h
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Win32/CMakeLists.txt
Log:
[AudioDevice] Win32 (untested)


Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/CMakeLists.txt	2008-07-03 19:29:34 UTC (rev 4187)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/CMakeLists.txt	2008-07-03 19:29:38 UTC (rev 4188)
@@ -26,4 +26,8 @@
 if(USE_JACK)
 ADD_SUBDIRECTORY(Jack)
 endif(USE_JACK)
+
+if(WIN32)
+ADD_SUBDIRECTORY(Win32)
+endif(WIN32)
 #

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Win32/ADM_deviceWin32.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Win32/ADM_deviceWin32.cpp	2008-07-03 19:29:34 UTC (rev 4187)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Win32/ADM_deviceWin32.cpp	2008-07-03 19:29:38 UTC (rev 4188)
@@ -10,22 +10,18 @@
 // Copyright: See COPYING file that comes with this distribution
 //
 
-#include "config.h"
+#include "ADM_default.h"
+#include "ADM_audiodevice.h"
 
-#ifdef __WIN32
-#include <stdio.h>
-#include <stdlib.h>
-#include <errno.h>
+
+#include  "ADM_audiodevice.h"
+#include  "ADM_audioDeviceInternal.h"
+
 #include <windows.h>
 
-#include "fourcc.h" 
-#include "ADM_assert.h"
-#include "ADM_audiodevice.h"
-#include "ADM_audiodevice/ADM_deviceWin32.h"
+#include "ADM_deviceWin32.h"
 
-#define MODULE_NAME  MODULE_ADEVICE
-#include "ADM_osSupport/ADM_debugID.h"
-#include "ADM_osSupport/ADM_debug.h"
+#define aprintf(...) {}
 
 #define NB_BUCKET 8
 
@@ -36,7 +32,7 @@
 static void handleMM(MMRESULT err);
 
 WAVEHDR waveHdr[NB_BUCKET];	
-
+ADM_DECLARE_AUDIODEVICE(Win32,win32AudioDevice,1,0,0,"Win32 audio device (c) mean");
 win32AudioDevice::win32AudioDevice(void) 
 {
 	printf("[Win32] Creating audio device\n");
@@ -73,7 +69,7 @@
 	return 1;
 }
 
-uint8_t win32AudioDevice::init(uint8_t channels, uint32_t fq) 
+uint8_t win32AudioDevice::init(uint32_t channels, uint32_t fq) 
 {
 	printf("[Win32] Opening Audio, channels=%u freq=%u\n",channels, fq);
 

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Win32/ADM_deviceWin32.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Win32/ADM_deviceWin32.h	2008-07-03 19:29:34 UTC (rev 4187)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Win32/ADM_deviceWin32.h	2008-07-03 19:29:38 UTC (rev 4188)
@@ -9,18 +9,18 @@
 // Copyright: See COPYING file that comes with this distribution
 //
 //
-#ifdef __WIN32
 
+
 class win32AudioDevice : public audioDevice
 {
 protected:
 	uint8_t	_inUse;
 public:
 	win32AudioDevice(void);
-	virtual uint8_t init(uint8_t channels, uint32_t fq);
+	virtual uint8_t init(uint32_t channels, uint32_t fq);
 	virtual uint8_t play(uint32_t len, float *data);
 	virtual uint8_t stop(void);
 	virtual uint8_t setVolume(int volume);
 };
 
-#endif
+

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Win32/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Win32/CMakeLists.txt	2008-07-03 19:29:34 UTC (rev 4187)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Win32/CMakeLists.txt	2008-07-03 19:29:38 UTC (rev 4188)
@@ -0,0 +1,9 @@
+INCLUDE(av_plugin)
+
+
+SET(ADM_av_win32_SRCS ADM_deviceWin32.cpp)
+
+ADD_LIBRARY(ADM_av_win32 SHARED ${ADM_av_win32_SRCS})
+
+INIT_AUDIO_DEVICE(ADM_av_win32)
+INSTALL_AUDIODEVICE(ADM_av_win32)



From mean at mail.berlios.de  Fri Jul  4 08:02:59 2008
From: mean at mail.berlios.de (mean at BerliOS)
Date: Fri, 4 Jul 2008 08:02:59 +0200
Subject: [Avidemux-svn-commit] r4189 -
	branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Win32
Message-ID: <200807040602.m6462xxD010635@sheep.berlios.de>

Author: mean
Date: 2008-07-04 08:02:58 +0200 (Fri, 04 Jul 2008)
New Revision: 4189

Modified:
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Win32/ADM_deviceWin32.cpp
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Win32/CMakeLists.txt
Log:
[AudioDevices] Win32 fixes


Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Win32/ADM_deviceWin32.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Win32/ADM_deviceWin32.cpp	2008-07-03 19:29:38 UTC (rev 4188)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Win32/ADM_deviceWin32.cpp	2008-07-04 06:02:58 UTC (rev 4189)
@@ -185,4 +185,3 @@
 	ERMM(WAVERR_BADFORMAT);
 	ERMM(WAVERR_SYNC);
 }
-#endif

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Win32/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Win32/CMakeLists.txt	2008-07-03 19:29:38 UTC (rev 4188)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Win32/CMakeLists.txt	2008-07-04 06:02:58 UTC (rev 4189)
@@ -4,6 +4,6 @@
 SET(ADM_av_win32_SRCS ADM_deviceWin32.cpp)
 
 ADD_LIBRARY(ADM_av_win32 SHARED ${ADM_av_win32_SRCS})
-
+TARGET_LINK_LIBRARIES("-lwinmm -lADM_core")
 INIT_AUDIO_DEVICE(ADM_av_win32)
 INSTALL_AUDIODEVICE(ADM_av_win32)



From mean at mail.berlios.de  Fri Jul  4 08:04:21 2008
From: mean at mail.berlios.de (mean at BerliOS)
Date: Fri, 4 Jul 2008 08:04:21 +0200
Subject: [Avidemux-svn-commit] r4190 -
	branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Win32
Message-ID: <200807040604.m6464L12012805@sheep.berlios.de>

Author: mean
Date: 2008-07-04 08:04:20 +0200 (Fri, 04 Jul 2008)
New Revision: 4190

Modified:
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Win32/CMakeLists.txt
Log:
[AudioDevices] Win32 fixes


Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Win32/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Win32/CMakeLists.txt	2008-07-04 06:02:58 UTC (rev 4189)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Win32/CMakeLists.txt	2008-07-04 06:04:20 UTC (rev 4190)
@@ -4,6 +4,6 @@
 SET(ADM_av_win32_SRCS ADM_deviceWin32.cpp)
 
 ADD_LIBRARY(ADM_av_win32 SHARED ${ADM_av_win32_SRCS})
-TARGET_LINK_LIBRARIES("-lwinmm -lADM_core")
+TARGET_LINK_LIBRARIES(ADM_av_win32 "-lwinmm -lADM_core")
 INIT_AUDIO_DEVICE(ADM_av_win32)
 INSTALL_AUDIODEVICE(ADM_av_win32)



From mean at mail.berlios.de  Sat Jul  5 15:51:59 2008
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sat, 5 Jul 2008 15:51:59 +0200
Subject: [Avidemux-svn-commit] r4191 -
	branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat
Message-ID: <200807051351.m65Dpx8s003383@sheep.berlios.de>

Author: mean
Date: 2008-07-05 15:51:54 +0200 (Sat, 05 Jul 2008)
New Revision: 4191

Modified:
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/ADM_lavformat.cpp
Log:
[MKV/FLV OUT] Correctly rescale video timestamps

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/ADM_lavformat.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/ADM_lavformat.cpp	2008-07-04 06:04:20 UTC (rev 4190)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/ADM_lavformat.cpp	2008-07-05 13:51:54 UTC (rev 4191)
@@ -414,7 +414,7 @@
 
           switch(audioheader->encoding)
           {
-                  case WAV_AC3: c->codec_id = CODEC_ID_AC3;break;
+                  case WAV_AC3: c->codec_id = CODEC_ID_AC3;c->frame_size=6*256;break;
                   case WAV_MP2: c->codec_id = CODEC_ID_MP2;break;
                   case WAV_MP3:
   #warning FIXME : Probe deeper
@@ -530,29 +530,30 @@
         AVPacket pkt;
         double f;
         int64_t timeInUs;
-
+        static int sz=0;
             //printf("Audio paclet : size %u, sample %u\n",len,sample);
 
            if(!audio_st) return 0;
            if(!len) return 1;
             av_init_packet(&pkt);
-
             timeInUs=(int64_t)sample2time_us(sample);
+            aprintf("Sample :%u time :%u size :%u this round:%u\n",sample,timeInUs,sz,len);
+            sz+=len;
             /* Rescale to ?? */
             if(_type==MUXER_FLV || _type==MUXER_MATROSKA) /* The FLV muxer expects packets dated in ms, there is something i did not get... WTF */
             {
-            			f=timeInUs/1000;
+            			f=timeInUs/1000; // ms
             			f=floor(f+0.4);
             }
             else
             {
             	f=timeInUs;
-            	f/=1000000.; // In ms seconds
-            	f*=_audioFq;
+            	f/=1000000.; // In sec
+            	f*=_audioFq; // In samples
             	f=floor(f+0.4);
             }
             pkt.dts=pkt.pts=(int)(f);
-
+            aprintf("Adm audio dts=:%u\n",pkt.dts);
             //printf("F:%f Q:%u D=%u\n",f,pkt.pts,timeInUs-_lastAudioDts);
 
             pkt.flags |= PKT_FLAG_KEY;
@@ -566,8 +567,8 @@
             _lastAudioDts=timeInUs;
             if(ret)
             {
-                        printf("Error writing audio packet\n");
-                        printf("pts %llu dts %llu\n",pkt.pts,pkt.dts);
+                        printf("[LavFormat]Error writing audio packet\n");
+                        printf("[LavFormat]pts %llu dts %llu\n",pkt.pts,pkt.dts);
                         return 0;
             }
             return 1;
@@ -622,21 +623,30 @@
 
 
 	_curDTS=(int64_t)floor(d);
-
+    aprintf("Adm video unscaled dts=:%u\n",(uint32_t)d);
         // Rescale
-#define RESCALE(x) x=x*video_st->codec->time_base.den*1000.;\
+#define RESCALE(x) x=x*1000.;\
                    x=x/_fps1000;
 
         p=bitstream->ptsFrame+1;
         RESCALE(p);
-
-        d=bitstream->dtsFrame;
+// MP4/ TS
+        d=bitstream->dtsFrame;  // p & d are now in seconds
         RESCALE(d);
-
-        if(_type==MUXER_FLV || _type==MUXER_MATROSKA) /* The FLV muxer expects packets dated in ms, there is something i did not get... WTF */
+        switch(_type)  // video_st->codec->time_base.den
         {
-        			p=p*1000/_fps1000;
-        			d=d*1000/_fps1000;
+        case MUXER_FLV :
+        case MUXER_MATROSKA:
+                    {
+                        p=p*1000;
+                        d=d*1000; // in milliseconds
+                        break;
+                    }
+        
+        default:
+                    p=p*video_st->codec->time_base.den;
+                    d=d*video_st->codec->time_base.den;
+                    break;
         }
     	pkt.dts=(int64_t)floor(d);
     	pkt.pts=(int64_t)floor(p);
@@ -659,11 +669,11 @@
 		pkt.flags |= PKT_FLAG_KEY;
 		//printf("Intra\n");
 	}
-
+    //printf("Adm video dts=:%u\n",pkt.dts);
 	ret =av_write_frame(oc, &pkt);
 	if(ret)
 	{
-		printf("Error writing video packet\n");
+		printf("[LavFormat]Error writing video packet\n");
 		return 0;
 	}
         aprintf("V: frame %lu pts%d\n",bitstream->dtsFrame,pkt.pts);



From gruntster at mail.berlios.de  Sat Jul  5 20:12:42 2008
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Sat, 5 Jul 2008 20:12:42 +0200
Subject: [Avidemux-svn-commit] r4193 -
	branches/avidemux_2.4_branch/avidemux/winInstaller
Message-ID: <200807051812.m65ICglh011141@sheep.berlios.de>

Author: gruntster
Date: 2008-07-05 20:12:36 +0200 (Sat, 05 Jul 2008)
New Revision: 4193

Modified:
   branches/avidemux_2.4_branch/avidemux/winInstaller/avidemux.nsi
Log:
[Win32] add French Qt4 translation to installer

Modified: branches/avidemux_2.4_branch/avidemux/winInstaller/avidemux.nsi
===================================================================
--- branches/avidemux_2.4_branch/avidemux/winInstaller/avidemux.nsi	2008-07-05 16:55:07 UTC (rev 4192)
+++ branches/avidemux_2.4_branch/avidemux/winInstaller/avidemux.nsi	2008-07-05 18:12:36 UTC (rev 4193)
@@ -6,7 +6,7 @@
 !include WinMessages.nsh
 !include revision.nsh
 
-Name "Avidemux 2.4.1 r${REVISION}"
+Name "Avidemux 2.4.2 r${REVISION}"
 
 SetCompressor /SOLID lzma
 SetCompressorDictSize 96
@@ -17,7 +17,7 @@
 !define INTERNALNAME "Avidemux 2.4"
 !define REGKEY "SOFTWARE\${INTERNALNAME}"
 !define UNINST_REGKEY "SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\${INTERNALNAME}"
-!define VERSION 2.4.1.${REVISION}
+!define VERSION 2.4.2.${REVISION}
 !define COMPANY "Free Software Foundation"
 !define URL "http://www.avidemux.org"
 
@@ -93,7 +93,7 @@
 CRCCheck on
 XPStyle on
 ShowInstDetails nevershow
-VIProductVersion 2.4.1.${REVISION}
+VIProductVersion 2.4.2.${REVISION}
 VIAddVersionKey ProductName Avidemux
 VIAddVersionKey ProductVersion "${VERSION}"
 VIAddVersionKey FileVersion ""
@@ -260,9 +260,10 @@
         !insertmacro InstallGtkLanguage Czech cs
     SectionEnd
 
-    Section "French (GTK+ only)" SecLangFrench
+    Section "French" SecLangFrench
         SectionIn 2
         !insertmacro InstallGtkLanguage French fr
+        !insertmacro InstallQt4Language French fr
     SectionEnd
 
     Section "German (GTK+ only)" SecLangGerman
@@ -508,7 +509,7 @@
     Delete /REBOOTOK $INSTDIR\ogg.dll
     Delete /REBOOTOK $INSTDIR\libxml2.dll
     Delete /REBOOTOK $INSTDIR\libx264.dll
-    Delete /REBOOTOK $INSTDIR\libpng13.dll
+    Delete /REBOOTOK $INSTDIR\libpng12-0.dll
     Delete /REBOOTOK $INSTDIR\libmp3lame-0.dll
     Delete /REBOOTOK $INSTDIR\libglib-2.0-0.dll
     Delete /REBOOTOK $INSTDIR\libfontconfig-1.dll



From gruntster at mail.berlios.de  Sat Jul  5 20:17:00 2008
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Sat, 5 Jul 2008 20:17:00 +0200
Subject: [Avidemux-svn-commit] r4194 -
	branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_commonUI
Message-ID: <200807051817.m65IH0oD011364@sheep.berlios.de>

Author: gruntster
Date: 2008-07-05 20:16:55 +0200 (Sat, 05 Jul 2008)
New Revision: 4194

Modified:
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_srt.cpp
Log:
[Subs] support for Arabic, Baltic, Greek, Hebrew and Turkish to SRT subtitles (patch by surfer)

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_srt.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_srt.cpp	2008-07-05 18:12:36 UTC (rev 4193)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_srt.cpp	2008-07-05 18:16:55 UTC (rev 4194)
@@ -48,13 +48,17 @@
 
   static unicd  names[]=
 {
+	{QT_TR_NOOP("Arabic"), "ISO-8859-6"}, 
+	{QT_TR_NOOP("Baltic"), "ISO-8859-4"}, // 
 	{QT_TR_NOOP("Chinese Simplified (GB2312)"), "CP936"},		// UTF8
 	{QT_TR_NOOP("Chinese Traditional (Big5)"), "CP950"}	,	// UTF8
-	{QT_TR_NOOP("Cyrillic"), "WINDOWS-1251"}, // ru
-	{QT_TR_NOOP("Czech"), "ISO-8859-2"},	// cz
-	{QT_TR_NOOP("German"), "ISO-8859-9"},		// german ?
-	{QT_TR_NOOP("Latin-1"), "ISO-8859-1"},
+	{QT_TR_NOOP("Cyrillic"), "ISO-8859-5"}, // ru
+	{QT_TR_NOOP("Latin-1 (Western European)"), "ISO-8859-1"}, // german
+	{QT_TR_NOOP("Latin-2 (Central European)"), "ISO-8859-2"},       // cz
+	{QT_TR_NOOP("Greek"), "ISO-8859-7"}, // greek
+	{QT_TR_NOOP("Hebrew"), "ISO-8859-8"},           // Hebrew
 	{QT_TR_NOOP("Slovene"), "CP1250"},		// UTF8
+	{QT_TR_NOOP("Turkish"), "ISO-8859-9"},          // Turkish
 	{QT_TR_NOOP("UTF-8"), "UTF-8"},		// UTF8
 	{QT_TR_NOOP("UTF-16"), "UTF-16"}		// UTF16
 };



From gruntster at mail.berlios.de  Sat Jul  5 20:24:10 2008
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Sat, 5 Jul 2008 20:24:10 +0200
Subject: [Avidemux-svn-commit] r4195 - branches/avidemux_2.4_branch
Message-ID: <200807051824.m65IOAn6011938@sheep.berlios.de>

Author: gruntster
Date: 2008-07-05 20:24:01 +0200 (Sat, 05 Jul 2008)
New Revision: 4195

Modified:
   branches/avidemux_2.4_branch/ConfigureChecks.cmake
   branches/avidemux_2.4_branch/configure.in.in
Log:
[Release] stamp as 2.4.2

Modified: branches/avidemux_2.4_branch/ConfigureChecks.cmake
===================================================================
--- branches/avidemux_2.4_branch/ConfigureChecks.cmake	2008-07-05 18:16:55 UTC (rev 4194)
+++ branches/avidemux_2.4_branch/ConfigureChecks.cmake	2008-07-05 18:24:01 UTC (rev 4195)
@@ -127,8 +127,8 @@
 ########################################
 # Standard Avidemux defines
 ########################################
-SET(VERSION 2.4.1)
-SET(PACKAGE_VERSION 2.4.1)
+SET(VERSION 2.4.2)
+SET(PACKAGE_VERSION 2.4.2)
 
 SET(HAVE_BUILTIN_VECTOR 1)
 SET(HAVE_AUDIO 1)

Modified: branches/avidemux_2.4_branch/configure.in.in
===================================================================
--- branches/avidemux_2.4_branch/configure.in.in	2008-07-05 18:16:55 UTC (rev 4194)
+++ branches/avidemux_2.4_branch/configure.in.in	2008-07-05 18:24:01 UTC (rev 4195)
@@ -38,7 +38,7 @@
 dnl Perform program name transformation
 AC_ARG_PROGRAM
 dnl Automake doc recommends to do this only here. (Janos)
-AM_INIT_AUTOMAKE(avidemux,"2.4.1")
+AM_INIT_AUTOMAKE(avidemux,"2.4.2")
 ADM_SUBVERSION="0"
 
 if [[ -f .svn/entries ]]; then



From mean at mail.berlios.de  Sat Jul  5 20:35:55 2008
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sat, 5 Jul 2008 20:35:55 +0200
Subject: [Avidemux-svn-commit] r4196 - tags
Message-ID: <200807051835.m65IZti0012871@sheep.berlios.de>

Author: mean
Date: 2008-07-05 20:35:54 +0200 (Sat, 05 Jul 2008)
New Revision: 4196

Added:
   tags/avidemux_2.4.2/
Log:


Copied: tags/avidemux_2.4.2 (from rev 4195, branches/avidemux_2.4_branch)



From mean at mail.berlios.de  Sun Jul  6 10:05:14 2008
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sun, 6 Jul 2008 10:05:14 +0200
Subject: [Avidemux-svn-commit] r4197 -
	branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer
Message-ID: <200807060805.m6685EtA032314@sheep.berlios.de>

Author: mean
Date: 2008-07-06 10:05:14 +0200 (Sun, 06 Jul 2008)
New Revision: 4197

Modified:
   branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_demuxerMSDVR.cpp
Log:
[Memleak/ASF] Memleak fix by Wesley Wright

Modified: branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_demuxerMSDVR.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_demuxerMSDVR.cpp	2008-07-05 18:35:54 UTC (rev 4196)
+++ branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_demuxerMSDVR.cpp	2008-07-06 08:05:14 UTC (rev 4197)
@@ -359,12 +359,14 @@
                   {
                     seen[bit->stream]+=bit->len;
                   }
+		  if (bit->data) delete[] bit->data;
                   delete bit;
                 }else
                 {
                   _pesBufferStart=bit->packet;
                   memcpy(&(_pesBuffer[_pesBufferLen]),bit->data,bit->len);
                   _pesBufferLen+=bit->len;
+                  if (bit->data) delete[] bit->data;
                   delete bit;
                 }
               }



From mean at mail.berlios.de  Sun Jul  6 14:54:43 2008
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sun, 6 Jul 2008 14:54:43 +0200
Subject: [Avidemux-svn-commit] r4198 -
	branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_matroska
Message-ID: <200807061254.m66CshpH013558@sheep.berlios.de>

Author: mean
Date: 2008-07-06 14:54:43 +0200 (Sun, 06 Jul 2008)
New Revision: 4198

Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_matroska/ADM_mkv.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_matroska/ADM_mkv.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_matroska/ADM_mkvIndexer.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_matroska/ADM_mkv_audio.cpp
Log:
[fwd port] Fix mkv duration


Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_matroska/ADM_mkv.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_matroska/ADM_mkv.cpp	2008-07-06 08:05:14 UTC (rev 4197)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_matroska/ADM_mkv.cpp	2008-07-06 12:54:43 UTC (rev 4198)
@@ -122,7 +122,7 @@
         if(track->_defaultFrameDuration) return 1; // No need to change
         float samples=1000.;
         samples*=durationMs;
-        samples/=track->nbPackets;  // 1000 * sample per packet
+        samples/=track->nbFrames;  // 1000 * sample per packet
         track->_defaultFrameDuration=(uint32_t)samples;
         return 1;
 

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_matroska/ADM_mkv.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_matroska/ADM_mkv.h	2008-07-06 08:05:14 UTC (rev 4197)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_matroska/ADM_mkv.h	2008-07-06 12:54:43 UTC (rev 4198)
@@ -40,7 +40,8 @@
 
   /* Used for audio */
   WAVHeader wavHeader;
-  uint32_t  nbPackets;
+  uint32_t  nbPackets; // number of blocks (used for audio)
+  uint32_t  nbFrames;  // number of distinct frames
   uint32_t  length;
   /* Used for both */
   uint8_t    *extraData;

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_matroska/ADM_mkvIndexer.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_matroska/ADM_mkvIndexer.cpp	2008-07-06 08:05:14 UTC (rev 4197)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_matroska/ADM_mkvIndexer.cpp	2008-07-06 12:54:43 UTC (rev 4198)
@@ -160,6 +160,7 @@
               {
                 _tracks[track]._sizeInBytes+=remaining; // keep some stat, useful for audio
                 _tracks[track].nbPackets++;
+                _tracks[track].nbFrames++;
               }
               break;
         case 2 : // Constant size lacing
@@ -183,6 +184,7 @@
                     {
                        _tracks[track]._sizeInBytes+=remaining;
                        _tracks[track].nbPackets++;
+                       _tracks[track].nbFrames+=nbLaces;
                     }
                     //printf("tid:%u track %u Remaining : %llu laces %u blksize %d er%d\n",tid,track,remaining,nbLaces,remaining/nbLaces,remaining-(remaining/nbLaces)*nbLaces);
             }
@@ -205,6 +207,7 @@
                                 {
                                     _tracks[track]._sizeInBytes+=tail-parser->tell();
                                     _tracks[track].nbPackets++;
+                                    _tracks[track].nbFrames+=nbLaces+1;
                                 }
 
                               }
@@ -226,6 +229,7 @@
                                 ADM_assert(track); // Not video!
                                 _tracks[track]._sizeInBytes+=(tail-parser->tell());
                                 _tracks[track].nbPackets++;
+                                _tracks[track].nbFrames+=nbLaces+1;
                                 //printf("This round %lld total:%lld\n",tail-parser->tell(),    _tracks[track]._sizeInBytes);
                                 break;
 

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_matroska/ADM_mkv_audio.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_matroska/ADM_mkv_audio.cpp	2008-07-06 08:05:14 UTC (rev 4197)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_matroska/ADM_mkv_audio.cpp	2008-07-06 12:54:43 UTC (rev 4198)
@@ -83,6 +83,7 @@
   ADM_MKV_TYPE type;
   const char *ss;
   vprintf("Enter: Currently at :%llx\n",_clusterParser->tell());
+  *samples=_frameDurationInSample;
     // Have we still lace to go ?
     if(_currentLace<_maxLace)
     {
@@ -90,22 +91,7 @@
       *packlen= _Laces[_currentLace];
       vprintf("Continuing lacing : %u bytes, lacing %u/%u\n",*packlen,_currentLace,_maxLace);
 
-      if(_currentLace==_maxLace-1)
-      {
-          float f;
-          f=_frameDurationInSample;
-          f/=_maxLace;
-          uint32_t total=(uint32_t)floor(f);
-          total*=(_maxLace-1);
-          *samples=_frameDurationInSample-total;
-          ADM_assert(_frameDurationInSample>=total);
-      }else
-      {
-          float f;
-          f=_frameDurationInSample;
-          f/=_maxLace;
-          *samples=(uint32_t )floor(f);
-      }
+     
       *timecode=_curTimeCode;
       _currentLace++;
       return 1;
@@ -175,7 +161,7 @@
                               vprintf("No lacing :%d bytes\n",remaining);
                               _clusterParser->readBin(dest,remaining);
                               *packlen=remaining;
-                              *samples=_frameDurationInSample;
+                              
                               _currentLace=_maxLace=0;
 
                               return 1;
@@ -315,6 +301,7 @@
   _wavheader=new WAVHeader;
   memcpy(_wavheader,&(_track->wavHeader),sizeof(WAVHeader));
   printf("[MKVAUDIO] found %lu packets\n",track->nbPackets);
+  printf("[MKVAUDIO] found %lu frames\n",track->nbFrames);
   printf("[MKVAUDIO] Default duration %u us\n",_track->_defaultFrameDuration);
   printf("[MKVAUDIO] found %lu bytes, %u samples per frame\n",_length,_frameDurationInSample);
   _currentLace=_maxLace=0;



From mean at mail.berlios.de  Sun Jul  6 14:54:46 2008
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sun, 6 Jul 2008 14:54:46 +0200
Subject: [Avidemux-svn-commit] r4199 -
	branches/avidemux_2.5_branch_gruntster/avidemux/ADM_outputs
Message-ID: <200807061254.m66Csk1C013576@sheep.berlios.de>

Author: mean
Date: 2008-07-06 14:54:46 +0200 (Sun, 06 Jul 2008)
New Revision: 4199

Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_outputs/ADM_lavformat.cpp
Log:
[Fwd port] Fix mkv/flv timestamps


Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_outputs/ADM_lavformat.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_outputs/ADM_lavformat.cpp	2008-07-06 12:54:43 UTC (rev 4198)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_outputs/ADM_lavformat.cpp	2008-07-06 12:54:46 UTC (rev 4199)
@@ -413,7 +413,7 @@
 
           switch(audioheader->encoding)
           {
-                  case WAV_AC3: c->codec_id = CODEC_ID_AC3;break;
+                  case WAV_AC3: c->codec_id = CODEC_ID_AC3;c->frame_size=6*256;break;
                   case WAV_MP2: c->codec_id = CODEC_ID_MP2;break;
                   case WAV_MP3:
   #warning FIXME : Probe deeper
@@ -528,29 +528,30 @@
         AVPacket pkt;
         double f;
         int64_t timeInUs;
-
+        static int sz=0;
             //printf("Audio paclet : size %u, sample %u\n",len,sample);
 
            if(!audio_st) return 0;
            if(!len) return 1;
             av_init_packet(&pkt);
-
             timeInUs=(int64_t)sample2time_us(sample);
+            aprintf("Sample :%u time :%u size :%u this round:%u\n",sample,timeInUs,sz,len);
+            sz+=len;
             /* Rescale to ?? */
             if(_type==MUXER_FLV || _type==MUXER_MATROSKA) /* The FLV muxer expects packets dated in ms, there is something i did not get... WTF */
             {
-            			f=timeInUs/1000;
+            			f=timeInUs/1000; // ms
             			f=floor(f+0.4);
             }
             else
             {
             	f=timeInUs;
-            	f/=1000000.; // In ms seconds
-            	f*=_audioFq;
+            	f/=1000000.; // In sec
+            	f*=_audioFq; // In samples
             	f=floor(f+0.4);
             }
             pkt.dts=pkt.pts=(int)(f);
-
+            aprintf("Adm audio dts=:%u\n",pkt.dts);
             //printf("F:%f Q:%u D=%u\n",f,pkt.pts,timeInUs-_lastAudioDts);
 
             pkt.flags |= PKT_FLAG_KEY;
@@ -564,8 +565,8 @@
             _lastAudioDts=timeInUs;
             if(ret)
             {
-                        printf("Error writing audio packet\n");
-                        printf("pts %llu dts %llu\n",pkt.pts,pkt.dts);
+                        printf("[LavFormat]Error writing audio packet\n");
+                        printf("[LavFormat]pts %llu dts %llu\n",pkt.pts,pkt.dts);
                         return 0;
             }
             return 1;
@@ -620,21 +621,30 @@
 
 
 	_curDTS=(int64_t)floor(d);
-
+    aprintf("Adm video unscaled dts=:%u\n",(uint32_t)d);
         // Rescale
-#define RESCALE(x) x=x*video_st->codec->time_base.den*1000.;\
+#define RESCALE(x) x=x*1000.;\
                    x=x/_fps1000;
 
         p=bitstream->ptsFrame+1;
         RESCALE(p);
-
-        d=bitstream->dtsFrame;
+// MP4/ TS
+        d=bitstream->dtsFrame;  // p & d are now in seconds
         RESCALE(d);
-
-        if(_type==MUXER_FLV || _type==MUXER_MATROSKA) /* The FLV muxer expects packets dated in ms, there is something i did not get... WTF */
+        switch(_type)  // video_st->codec->time_base.den
         {
-        			p=p*1000/_fps1000;
-        			d=d*1000/_fps1000;
+        case MUXER_FLV :
+        case MUXER_MATROSKA:
+                    {
+                        p=p*1000;
+                        d=d*1000; // in milliseconds
+                        break;
+                    }
+        
+        default:
+                    p=p*video_st->codec->time_base.den;
+                    d=d*video_st->codec->time_base.den;
+                    break;
         }
     	pkt.dts=(int64_t)floor(d);
     	pkt.pts=(int64_t)floor(p);
@@ -657,11 +667,11 @@
 		pkt.flags |= PKT_FLAG_KEY;
 		//printf("Intra\n");
 	}
-
+    //printf("Adm video dts=:%u\n",pkt.dts);
 	ret =av_write_frame(oc, &pkt);
 	if(ret)
 	{
-		printf("Error writing video packet\n");
+		printf("[LavFormat]Error writing video packet\n");
 		return 0;
 	}
         aprintf("V: frame %lu pts%d\n",bitstream->dtsFrame,pkt.pts);



From mean at mail.berlios.de  Sun Jul  6 14:54:49 2008
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sun, 6 Jul 2008 14:54:49 +0200
Subject: [Avidemux-svn-commit] r4200 - in
	branches/avidemux_2.5_branch_gruntster: avidemux
	avidemux/ADM_audiodevice plugins/ADM_audioDevices/Esd
	plugins/ADM_audioDevices/PulseAudioSimple
Message-ID: <200807061254.m66CsngR013593@sheep.berlios.de>

Author: mean
Date: 2008-07-06 14:54:48 +0200 (Sun, 06 Jul 2008)
New Revision: 4200

Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_audiodevice.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/audio_out.h
   branches/avidemux_2.5_branch_gruntster/avidemux/guiplay.cpp
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Esd/ADM_deviceEsd.cpp
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Esd/ADM_deviceEsd.h
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/PulseAudioSimple/ADM_devicePulseSimple.cpp
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/PulseAudioSimple/ADM_devicePulseSimple.h
Log:
[AudioDevice] Try to handle latency induced by audio playback (not working)


Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_audiodevice.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_audiodevice.cpp	2008-07-06 12:54:46 UTC (rev 4199)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_audiodevice.cpp	2008-07-06 12:54:48 UTC (rev 4200)
@@ -269,6 +269,15 @@
 {
 	return device->play(nb,ptr);
 }
+/**
+    \fn AVDM_GetLayencyMs
+    \brief Return playback latency in ms
+
+*/
+uint32_t AVDM_GetLayencyMs(void)
+{
+	return device->getLatencyMs();
+}
 //**
 dummyAudioDevice::dummyAudioDevice(void) {};
 dummyAudioDevice::~dummyAudioDevice(void) {};

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/audio_out.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/audio_out.h	2008-07-06 12:54:46 UTC (rev 4199)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/audio_out.h	2008-07-06 12:54:48 UTC (rev 4200)
@@ -28,6 +28,7 @@
 uint8_t 	AVDM_AudioPlay(float *ptr, uint32_t nb);
 uint32_t 	AVDM_AudioSetup(uint32_t fq, uint8_t channel);
 void 		AVDM_AudioClose(void);
+uint32_t    AVDM_GetLayencyMs(void);
 AUDIO_DEVICE 	AVDM_getCurrentDevice( void);
 uint8_t         AVDM_setVolume(int volume);
 // Get infos

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/guiplay.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/guiplay.cpp	2008-07-06 12:54:46 UTC (rev 4199)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/guiplay.cpp	2008-07-06 12:54:48 UTC (rev 4200)
@@ -302,7 +302,7 @@
 void ComputePreload(void)
 //_______________________________________
 {
-    uint32_t latency, one_sec;
+    uint32_t state,latency, one_sec;
     uint32_t small_;
     uint32_t channels;
 
@@ -342,11 +342,12 @@
     wavbuf =  (float *)  ADM_alloc((3 *  channels * wavinfo->frequency*wavinfo->channels));
     ADM_assert(wavbuf);
     // Call it twice to be sure it is properly setup
-     latency = AVDM_AudioSetup(playback->getInfo()->frequency,  channels );
+     state = AVDM_AudioSetup(playback->getInfo()->frequency,  channels );
      AVDM_AudioClose();
-     latency = AVDM_AudioSetup(playback->getInfo()->frequency,  channels );
-
-      if (!latency)
+     state = AVDM_AudioSetup(playback->getInfo()->frequency,  channels );
+     latency=AVDM_GetLayencyMs();
+     printf("[Playback] Latency : %d ms\n",latency);
+      if (!state)
       {
           GUI_Error_HIG(QT_TR_NOOP("Trouble initializing audio device"), NULL);
           return;
@@ -356,7 +357,7 @@
     // we preload 1/4 a second
      currentaudiostream->beginDecompress();
      one_sec = (wavinfo->frequency *  channels)  >> 2;
-    
+     one_sec+=(latency*wavinfo->frequency *  channels*2)/1000;
      AUD_Status status;
     uint32_t fill=0;
     while(fill<one_sec)
@@ -369,6 +370,8 @@
     }
     dauds += fill/channels;  // In sample
     AVDM_AudioPlay(wavbuf, fill);
+    // Let audio latency sets in...
+    ADM_usleep(latency*1000);
     audio_available = 1;
 }
 

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Esd/ADM_deviceEsd.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Esd/ADM_deviceEsd.cpp	2008-07-06 12:54:46 UTC (rev 4199)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Esd/ADM_deviceEsd.cpp	2008-07-06 12:54:48 UTC (rev 4200)
@@ -25,6 +25,14 @@
 #include  "ADM_deviceEsd.h"
 #include <esd.h>
 ADM_DECLARE_AUDIODEVICE(Esd,esdAudioDevice,1,0,0,"Esd audio device (c) mean");
+/**
+        \fn getLatencyMs
+        \brief Returns device latency in ms
+*/
+uint32_t esdAudioDevice::getLatencyMs(void)
+{
+    return latency;
+}
 //_______________________________________________
 //
 //
@@ -45,19 +53,20 @@
 {
 esd_format_t format;
 _channels = channels;
+latency=0;
 
     format=ESD_STREAM | ESD_PLAY | ESD_BITS16;
     if(channels==1) format|=ESD_MONO;
         else format|=ESD_STEREO;
 
-    printf("\n ESD  : %lu Hz, %lu channels", fq, channels);
+    printf("[ESD]  : %lu Hz, %lu channels\n", fq, channels);
     esdDevice=esd_play_stream(format,fq,NULL,"avidemux");
     if(esdDevice<=0) 
     {
-        printf("Esd open failed\n");
+        printf("[ESD] open failed\n");
         return 0;
     }
-    printf("Esd open succeedeed\n");
+    printf("[ESD] open succeedeed\n");
     /*
 #ifdef ADM_BIG_ENDIAN    
     int fmt = AFMT_S16_BE;
@@ -65,6 +74,9 @@
     int fmt = AFMT_S16_LE;
 #endif    
 */
+    float f=(float)esd_get_latency(esdDevice);
+    f=f/44.1;
+    latency=(uint32_t)f;
     return 1;
 }
 

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Esd/ADM_deviceEsd.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Esd/ADM_deviceEsd.h	2008-07-06 12:54:46 UTC (rev 4199)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Esd/ADM_deviceEsd.h	2008-07-06 12:54:48 UTC (rev 4200)
@@ -19,11 +19,13 @@
 	 {
 		 protected :
                     int esdDevice;
+                    uint32_t latency;
 		  public:
 		  			esdAudioDevice(void) {esdDevice=-1;}
 		     		virtual uint8_t init(uint32_t channels, uint32_t fq);
 	    			virtual uint8_t play(uint32_t len, float *data);
 		      		virtual uint8_t stop(void);
                             uint8_t setVolume(int volume);
+                            uint32_t getLatencyMs(void);
 		 }     ;
 

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/PulseAudioSimple/ADM_devicePulseSimple.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/PulseAudioSimple/ADM_devicePulseSimple.cpp	2008-07-06 12:54:46 UTC (rev 4199)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/PulseAudioSimple/ADM_devicePulseSimple.cpp	2008-07-06 12:54:48 UTC (rev 4200)
@@ -25,7 +25,9 @@
 #include  "pulse/simple.h"
 
 ADM_DECLARE_AUDIODEVICE(PulseAudioS,pulseSimpleAudioDevice,1,0,0,"PulseAudioSimple audio device (c) mean");
+#define INSTANCE  ((pa_simple *)instance)
 
+// By default we use float
 //#define ADM_PULSE_INT16
 /**
     \fn pulseSimpleAudioDevice
@@ -36,8 +38,21 @@
 {
     instance=NULL;
 }
+/**
+    \fn pulseSimpleAudioDevice
+    \brief Returns delay in ms
+*/
+uint32_t pulseSimpleAudioDevice::getLatencyMs(void)
+{
+    if(!instance) return 0;
+    int er;
+    pa_usec_t l=0;
+    l=pa_simple_get_latency(INSTANCE, &er);
+    printf("[Pulse] Latency :%lu\n",l);
+    l/=1000;
+    return (uint32_t )l;
+}
 
-#define INSTANCE  ((pa_simple *)instance)
 /**
     \fn stop
     \brief stop & release device
@@ -91,6 +106,10 @@
         printf("[PulseSimple] open failed\n");
         return 0;
     }
+ pa_usec_t l=0;
+    l=pa_simple_get_latency(INSTANCE, &er);
+    printf("[Pulse] Latency :%lu\n",l);
+
     printf("[PulseSimple] open ok\n");
     return 1;
 
@@ -104,6 +123,7 @@
 uint8_t pulseSimpleAudioDevice::play(uint32_t len, float *data)
 {
 int er;
+    if(!instance) return 0;
 #ifdef ADM_PULSE_INT16
 	dither16(data, len, _channels);
     pa_simple_write(INSTANCE,data,len*2,&er);
@@ -120,4 +140,4 @@
 {
 	return 1;
 }
-//EOF
\ No newline at end of file
+//EOF

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/PulseAudioSimple/ADM_devicePulseSimple.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/PulseAudioSimple/ADM_devicePulseSimple.h	2008-07-06 12:54:46 UTC (rev 4199)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/PulseAudioSimple/ADM_devicePulseSimple.h	2008-07-06 12:54:48 UTC (rev 4200)
@@ -25,5 +25,6 @@
 	    			virtual uint8_t play(uint32_t len, float *data);
 		      		virtual uint8_t stop(void);
 				    uint8_t setVolume(int volume);
+                    uint32_t getLatencyMs(void);
 		 }     ;
 



From mean at mail.berlios.de  Sun Jul  6 14:54:51 2008
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sun, 6 Jul 2008 14:54:51 +0200
Subject: [Avidemux-svn-commit] r4201 -
	branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Esd
Message-ID: <200807061254.m66Cspwx013617@sheep.berlios.de>

Author: mean
Date: 2008-07-06 14:54:50 +0200 (Sun, 06 Jul 2008)
New Revision: 4201

Modified:
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Esd/ADM_deviceEsd.cpp
Log:
[AudioDevice] Disable get_latency, cause freeze with esdcompat


Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Esd/ADM_deviceEsd.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Esd/ADM_deviceEsd.cpp	2008-07-06 12:54:48 UTC (rev 4200)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Esd/ADM_deviceEsd.cpp	2008-07-06 12:54:50 UTC (rev 4201)
@@ -74,7 +74,7 @@
     int fmt = AFMT_S16_LE;
 #endif    
 */
-    float f=(float)esd_get_latency(esdDevice);
+    float f=0; // FIXE Cause a freeze with esdcompat =(float)esd_get_latency(esdDevice);
     f=f/44.1;
     latency=(uint32_t)f;
     return 1;



From mean at mail.berlios.de  Sun Jul  6 14:54:52 2008
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sun, 6 Jul 2008 14:54:52 +0200
Subject: [Avidemux-svn-commit] r4202 -
	branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_mpegdemuxer
Message-ID: <200807061254.m66CsqRb013627@sheep.berlios.de>

Author: mean
Date: 2008-07-06 14:54:52 +0200 (Sun, 06 Jul 2008)
New Revision: 4202

Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_demuxerMSDVR.cpp
Log:
[Memleak/MSDVR] Fwd port


Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_demuxerMSDVR.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_demuxerMSDVR.cpp	2008-07-06 12:54:50 UTC (rev 4201)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_demuxerMSDVR.cpp	2008-07-06 12:54:52 UTC (rev 4202)
@@ -359,12 +359,14 @@
                   {
                     seen[bit->stream]+=bit->len;
                   }
+		  if (bit->data) delete[] bit->data;
                   delete bit;
                 }else
                 {
                   _pesBufferStart=bit->packet;
                   memcpy(&(_pesBuffer[_pesBufferLen]),bit->data,bit->len);
                   _pesBufferLen+=bit->len;
+                  if (bit->data) delete[] bit->data;
                   delete bit;
                 }
               }



From gruntster at mail.berlios.de  Mon Jul  7 15:27:15 2008
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Mon, 7 Jul 2008 15:27:15 +0200
Subject: [Avidemux-svn-commit] r4203 -
	branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_commonUI
Message-ID: <200807071327.m67DRFYo012009@sheep.berlios.de>

Author: gruntster
Date: 2008-07-07 15:27:08 +0200 (Mon, 07 Jul 2008)
New Revision: 4203

Modified:
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_srt.cpp
Log:
[Subs] restore missing codepages to SRT subtitler

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_srt.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_srt.cpp	2008-07-06 12:54:52 UTC (rev 4202)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_srt.cpp	2008-07-07 13:27:08 UTC (rev 4203)
@@ -86,7 +86,12 @@
   Mitem(5),
   Mitem(6),
   Mitem(7),
-  Mitem(8)
+  Mitem(8),
+  Mitem(9),
+  Mitem(10),
+  Mitem(11),
+  Mitem(12),
+  Mitem(13)
 };       
 
 #define PX(x) &(param->x)
@@ -106,7 +111,7 @@
       {
           if(!strcmp(param->_charset,names[i].name)) myEncoding=i;
       }
-      diaElemMenu      encodingM(&myEncoding,QT_TR_NOOP("_Encoding:"),9,encoding);
+      diaElemMenu      encodingM(&myEncoding,QT_TR_NOOP("_Encoding:"),13,encoding);
     //  diaElemUInteger  fontSize(PX(_fontsize),QT_TR_NOOP("Font Si_Ze:"),8,120);
       diaElemButton    color(QT_TR_NOOP("S_elect C_olor"), colorCallBack,&(colors[0]));
       diaElemButton    setBase(QT_TR_NOOP("Set Size and _Position"), sizePositionCallback,&sizePos);



From gruntster at mail.berlios.de  Mon Jul  7 15:50:33 2008
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Mon, 7 Jul 2008 15:50:33 +0200
Subject: [Avidemux-svn-commit] r4204 -
	branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Sdl
Message-ID: <200807071350.m67DoXq5015876@sheep.berlios.de>

Author: gruntster
Date: 2008-07-07 15:50:23 +0200 (Mon, 07 Jul 2008)
New Revision: 4204

Modified:
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Sdl/CMakeLists.txt
Log:
[Cmake] fix for Win32

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Sdl/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Sdl/CMakeLists.txt	2008-07-07 13:27:08 UTC (rev 4203)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Sdl/CMakeLists.txt	2008-07-07 13:50:23 UTC (rev 4204)
@@ -4,7 +4,7 @@
 SET(ADM_av_sdl_SRCS ADM_deviceSDL.cpp)
 
 ADD_LIBRARY(ADM_av_sdl SHARED ${ADM_av_sdl_SRCS})
-TARGET_LINK_LIBRARIES(ADM_av_sdl ${SDL_LIBRARY})
+TARGET_LINK_LIBRARIES(ADM_av_sdl ADM_core ${SDL_LIBRARY})
 SDLify(ADM_deviceSDL.cpp)
 
 INIT_AUDIO_DEVICE(ADM_av_sdl)



From gruntster at mail.berlios.de  Wed Jul  9 13:03:18 2008
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Wed, 9 Jul 2008 13:03:18 +0200
Subject: [Avidemux-svn-commit] r4209 -
	branches/avidemux_2.4_branch/avidemux/ADM_encoder
Message-ID: <200807091103.m69B3I5L017357@sheep.berlios.de>

Author: gruntster
Date: 2008-07-09 13:03:10 +0200 (Wed, 09 Jul 2008)
New Revision: 4209

Modified:
   branches/avidemux_2.4_branch/avidemux/ADM_encoder/adm_encx264.cpp
Log:
[x264] reset delayed frame count for 2nd pass

Modified: branches/avidemux_2.4_branch/avidemux/ADM_encoder/adm_encx264.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_encoder/adm_encx264.cpp	2008-07-09 09:33:06 UTC (rev 4208)
+++ branches/avidemux_2.4_branch/avidemux/ADM_encoder/adm_encx264.cpp	2008-07-09 11:03:10 UTC (rev 4209)
@@ -271,6 +271,7 @@
 {
   uint32_t    bitrate;
 
+  _delayed = 0;
   ADM_assert (_state == enc_Pass1);
   printf ("\n[x264] Starting pass 2 (%d x %d)\n", _w, _h);
 



From gruntster at mail.berlios.de  Thu Jul 10 20:24:44 2008
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Thu, 10 Jul 2008 20:24:44 +0200
Subject: [Avidemux-svn-commit] r4210 -
	branches/avidemux_2.4_branch/avidemux/ADM_osSupport
Message-ID: <200807101824.m6AIOiai012203@sheep.berlios.de>

Author: gruntster
Date: 2008-07-10 20:20:33 +0200 (Thu, 10 Jul 2008)
New Revision: 4210

Modified:
   branches/avidemux_2.4_branch/avidemux/ADM_osSupport/win32.cpp
Log:
[Win32] prevent crash if log file fails to open

Modified: branches/avidemux_2.4_branch/avidemux/ADM_osSupport/win32.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_osSupport/win32.cpp	2008-07-09 11:03:10 UTC (rev 4209)
+++ branches/avidemux_2.4_branch/avidemux/ADM_osSupport/win32.cpp	2008-07-10 18:20:33 UTC (rev 4210)
@@ -400,14 +400,10 @@
 	// so the output can be printed to the terminal for debugging purposes.
 
 #ifdef USE_SDL
-	// Close SDL generated logs
-	fclose(stdout);
-	fclose(stderr);
+	// Close SDL generated logs and briefly redirect to NUL
+	freopen("NUL", "w", stdout);
+	freopen("NUL", "w", stderr);
 
-	// Briefly redirect to console
-	freopen("CON", "w", stdout);
-	freopen("CON", "w", stderr);
-
 	// Remove SDL logs to avoid confusion
 	char path[MAX_PATH];
 	char stdoutPath[MAX_PATH];
@@ -431,19 +427,18 @@
 	const char* logFile = "admlog.txt";
 	char* baseDir = ADM_getBaseDir();
 	char *logPath = new char[strlen(baseDir) + 2 + strlen(logFile)];
-	FILE* stream;
 
 	strcpy(logPath, baseDir);
 	strcat(logPath, "/");
 	strcat(logPath, logFile);
 
-	fclose(stdout);
-	fclose(stderr);
+	FILE *stream = fopen(logPath, "w");
 
-	stream = fopen(logPath, "w");
-
 	if (stream)
 	{
+		fclose(stdout);
+		fclose(stderr);
+
 		*stdout = *stream;
 		*stderr = *stream;
 	}



From gruntster at mail.berlios.de  Thu Jul 10 21:48:03 2008
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Thu, 10 Jul 2008 21:48:03 +0200
Subject: [Avidemux-svn-commit] r4211 - branches/avidemux_2.4_branch
Message-ID: <200807101948.m6AJm39U021667@sheep.berlios.de>

Author: gruntster
Date: 2008-07-10 21:47:58 +0200 (Thu, 10 Jul 2008)
New Revision: 4211

Modified:
   branches/avidemux_2.4_branch/INSTALL
Log:
[install] update installation instructions

Modified: branches/avidemux_2.4_branch/INSTALL
===================================================================
--- branches/avidemux_2.4_branch/INSTALL	2008-07-10 18:20:33 UTC (rev 4210)
+++ branches/avidemux_2.4_branch/INSTALL	2008-07-10 19:47:58 UTC (rev 4211)
@@ -1,167 +1,52 @@
-Basic Installation
-==================
-
-   These are generic installation instructions.
-
-   The `configure' shell script attempts to guess correct values for
-various system-dependent variables used during compilation.  It uses
-those values to create a `Makefile' in each directory of the package.
-It may also create one or more `.h' files containing system-dependent
-definitions.  Finally, it creates a shell script `config.status' that
-you can run in the future to recreate the current configuration, a file
-`config.cache' that saves the results of its tests to speed up
-reconfiguring, and a file `config.log' containing compiler output
-(useful mainly for debugging `configure').
-
-   If you need to do unusual things to compile the package, please try
-to figure out how `configure' could check whether to do them, and mail
-diffs or instructions to the address given in the `README' so they can
-be considered for the next release.  If at some point `config.cache'
-contains results you don't want to keep, you may remove or edit it.
-
-   The file `configure.in' is used to create `configure' by a program
-called `autoconf'.  You only need `configure.in' if you want to change
-it or regenerate `configure' using a newer version of `autoconf'.
-
-The simplest way to compile this package is:
-
-  1. `cd' to the directory containing the package's source code and type
-     `./configure' to configure the package for your system.  If you're
-     using `csh' on an old version of System V, you might need to type
-     `sh ./configure' instead to prevent `csh' from trying to execute
-     `configure' itself.
-
-     Running `configure' takes a while.  While running, it prints some
-     messages telling which features it is checking for.
-
-  2. Type `make' to compile the package.
-
-  3. Type `make install' to install the programs and any data files and
-     documentation.
-
-  4. You can remove the program binaries and object files from the
-     source code directory by typing `make clean'.  
-
-Compilers and Options
-=====================
-
-   Some systems require unusual options for compilation or linking that
-the `configure' script does not know about.  You can give `configure'
-initial values for variables by setting them in the environment.  Using
-a Bourne-compatible shell, you can do that on the command line like
-this:
-     CC=c89 CFLAGS=-O2 LIBS=-lposix ./configure
-
-Or on systems that have the `env' program, you can do it like this:
-     env CPPFLAGS=-I/usr/local/include LDFLAGS=-s ./configure
-
-Compiling For Multiple Architectures
-====================================
-
-   You can compile the package for more than one kind of computer at the
-same time, by placing the object files for each architecture in their
-own directory.  To do this, you must use a version of `make' that
-supports the `VPATH' variable, such as GNU `make'.  `cd' to the
-directory where you want the object files and executables to go and run
-the `configure' script.  `configure' automatically checks for the
-source code in the directory that `configure' is in and in `..'.
-
-   If you have to use a `make' that does not supports the `VPATH'
-variable, you have to compile the package for one architecture at a time
-in the source code directory.  After you have installed the package for
-one architecture, use `make distclean' before reconfiguring for another
-architecture.
-
-Installation Names
-==================
-
-   By default, `make install' will install the package's files in
-`/usr/local/bin', `/usr/local/man', etc.  You can specify an
-installation prefix other than `/usr/local' by giving `configure' the
-option `--prefix=PATH'.
-
-   You can specify separate installation prefixes for
-architecture-specific files and architecture-independent files.  If you
-give `configure' the option `--exec-prefix=PATH', the package will use
-PATH as the prefix for installing programs and libraries.
-Documentation and other data files will still use the regular prefix.
-
-   If the package supports it, you can cause programs to be installed
-with an extra prefix or suffix on their names by giving `configure' the
-option `--program-prefix=PREFIX' or `--program-suffix=SUFFIX'.
-
-Optional Features
+Building Avidemux
 =================
 
-   Some packages pay attention to `--enable-FEATURE' options to
-`configure', where FEATURE indicates an optional part of the package.
-They may also pay attention to `--with-PACKAGE' options, where PACKAGE
-is something like `gnu-as' or `x' (for the X Window System).  The
-`README' should mention any `--enable-' and `--with-' options that the
-package recognizes.
+Avidemux uses CMake (www.cmake.org) to manage its build process.  CMake is a 
+cross-platform, open-source build system that generates native makefiles and 
+workspaces for the compiler environment of your choice.
 
-   For packages that use the X Window System, `configure' can usually
-find the X include and library files automatically, but if it doesn't,
-you can use the `configure' options `--x-includes=DIR' and
-`--x-libraries=DIR' to specify their locations.
+This document explains briefly how to build Avidemux with CMake:
 
-Specifying the System Type
-==========================
+-	Change to the top-level directory containing the Avidemux sources:
+        cd avidemux_src
+-	Create a directory, e.g. "build", and change into it:
+        mkdir build
+        cd build
+-	Use CMake to generate makefiles:
+        cmake ..
+-	Build Avidemux and install it:
+        make
+        make install
 
-   There may be some features `configure' can not figure out
-automatically, but needs to determine by the type of host the package
-will run on.  Usually `configure' can figure that out, but if it prints
-a message saying it can not guess the host type, give it the
-`--host=TYPE' option.  TYPE can either be a short name for the system
-type, such as `sun4', or a canonical name with three fields:
-     CPU-COMPANY-SYSTEM
+Avidemux is installed to the directory relative to the installation prefix, 
+which can be set by adding the following flag to the cmake command:
+    -DCMAKE_INSTALL_PREFIX=<dir>
 
-See the file `config.sub' for the possible values of each field.  If
-`config.sub' isn't included in this package, then this package doesn't
-need to know the host type.
+By default a release build is created.  To perform a debug build, add the 
+following flag to the cmake command:
+    ?DCMAKE_BUILD_TYPE=Debug
 
-   If you are building compiler tools for cross-compiling, you can also
-use the `--target=TYPE' option to select the type of system they will
-produce code for and the `--build=TYPE' option to select the type of
-system on which you are compiling the package.
+The default makefile generator may need to be overridden on some systems.  To 
+do so, add one of the following flags to the cmake command:
+    For MSYS:
+        -G"MSYS Makefiles"
 
-Sharing Defaults
-================
+    For MinGW:
+        -G"MinGW Makefiles"
 
-   If you want to set default values for `configure' scripts to share,
-you can create a site shell script called `config.site' that gives
-default values for variables like `CC', `cache_file', and `prefix'.
-`configure' looks for `PREFIX/share/config.site' if it exists, then
-`PREFIX/etc/config.site' if it exists.  Or, you can set the
-`CONFIG_SITE' environment variable to the location of the site script.
-A warning: not all `configure' scripts look for a site script.
+    For Code::Blocks (requires CMake 2.6 or later):
+        -G"CodeBlocks ? Unix Makefiles"   or
+        -G"CodeBlocks - MinGW Makefiles"
 
-Operation Controls
-==================
+    For Eclipse (requires CMake 2.6 or later):
+        -G"Eclipse CDT4 ? Unix Makefiles"   or
+        -G"Eclipse CDT4 ? MinGW Makefiles"
 
-   `configure' recognizes the following options to control how it
-operates.
+An example cmake command:
+    cmake ?G"CodeBlocks ? Unix Makefiles" ?DCMAKE_INSTALL_PREFIX=/usr/local ..
 
-`--cache-file=FILE'
-     Use and save the results of the tests in FILE instead of
-     `./config.cache'.  Set FILE to `/dev/null' to disable caching, for
-     debugging `configure'.
+In order to force CMake to perform every test again during the configuration 
+process, delete CMakeCache.txt.
 
-`--help'
-     Print a summary of the options to `configure', and exit.
-
-`--quiet'
-`--silent'
-`-q'
-     Do not print messages saying which checks are being made.
-
-`--srcdir=DIR'
-     Look for the package's source code in directory DIR.  Usually
-     `configure' can determine that directory automatically.
-
-`--version'
-     Print the version of Autoconf used to generate the `configure'
-     script, and exit.
-
-`configure' also accepts some other, not widely useful, options.
-
+Use the console GUI named ccmake on Unix or the CMake GUI on Microsoft Windows 
+to discover other available options.



From gruntster at mail.berlios.de  Tue Jul 15 19:03:22 2008
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Tue, 15 Jul 2008 19:03:22 +0200
Subject: [Avidemux-svn-commit] r4212 - in branches/avidemux_2.4_branch: .
	avidemux
Message-ID: <200807151703.m6FH3MGl013049@sheep.berlios.de>

Author: gruntster
Date: 2008-07-15 19:03:10 +0200 (Tue, 15 Jul 2008)
New Revision: 4212

Modified:
   branches/avidemux_2.4_branch/INSTALL
   branches/avidemux_2.4_branch/avidemux/main.cpp
Log:
[misc] cosmetics

Modified: branches/avidemux_2.4_branch/INSTALL
===================================================================
--- branches/avidemux_2.4_branch/INSTALL	2008-07-10 19:47:58 UTC (rev 4211)
+++ branches/avidemux_2.4_branch/INSTALL	2008-07-15 17:03:10 UTC (rev 4212)
@@ -24,7 +24,7 @@
 
 By default a release build is created.  To perform a debug build, add the 
 following flag to the cmake command:
-    ?DCMAKE_BUILD_TYPE=Debug
+    -DCMAKE_BUILD_TYPE=Debug
 
 The default makefile generator may need to be overridden on some systems.  To 
 do so, add one of the following flags to the cmake command:
@@ -35,15 +35,15 @@
         -G"MinGW Makefiles"
 
     For Code::Blocks (requires CMake 2.6 or later):
-        -G"CodeBlocks ? Unix Makefiles"   or
+        -G"CodeBlocks - Unix Makefiles"   or
         -G"CodeBlocks - MinGW Makefiles"
 
     For Eclipse (requires CMake 2.6 or later):
-        -G"Eclipse CDT4 ? Unix Makefiles"   or
-        -G"Eclipse CDT4 ? MinGW Makefiles"
+        -G"Eclipse CDT4 - Unix Makefiles"   or
+        -G"Eclipse CDT4 - MinGW Makefiles"
 
 An example cmake command:
-    cmake ?G"CodeBlocks ? Unix Makefiles" ?DCMAKE_INSTALL_PREFIX=/usr/local ..
+    cmake -G"CodeBlocks - Unix Makefiles" -DCMAKE_INSTALL_PREFIX=/usr/local ..
 
 In order to force CMake to perform every test again during the configuration 
 process, delete CMakeCache.txt.

Modified: branches/avidemux_2.4_branch/avidemux/main.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/main.cpp	2008-07-10 19:47:58 UTC (rev 4211)
+++ branches/avidemux_2.4_branch/avidemux/main.cpp	2008-07-15 17:03:10 UTC (rev 4212)
@@ -124,7 +124,7 @@
     installSigHandler();
 #endif
 
-    printf("*************************\n");
+    printf("***************************\n");
     printf("  Avidemux v" VERSION);
 
   	if(ADM_SUBVERSION)
@@ -132,7 +132,7 @@
 		printf(" (r%04u)", ADM_SUBVERSION);
 	}
 
-    printf("\n*************************\n");
+    printf("\n***************************\n");
     printf(" http://www.avidemux.org\n");
     printf(" Code      : Mean, JSC, Gruntster \n");
     printf(" GFX       : Nestor Di , nestordi at augcyl.org\n");



From gruntster at mail.berlios.de  Tue Jul 15 19:56:17 2008
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Tue, 15 Jul 2008 19:56:17 +0200
Subject: [Avidemux-svn-commit] r4213 -
	branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mp4
Message-ID: <200807151756.m6FHuHRe004298@sheep.berlios.de>

Author: gruntster
Date: 2008-07-15 19:56:08 +0200 (Tue, 15 Jul 2008)
New Revision: 4213

Modified:
   branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mp4/ADM_atom.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mp4/ADM_atom.h
   branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mp4/ADM_mp4.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mp4/ADM_mp4.h
   branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mp4/ADM_mp4Analyzer.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mp4/ADM_mp4Indexer.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mp4/ADM_mp4audio.cpp
Log:
[MP4] support for 64-bit input

Modified: branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mp4/ADM_atom.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mp4/ADM_atom.cpp	2008-07-15 17:03:10 UTC (rev 4212)
+++ branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mp4/ADM_atom.cpp	2008-07-15 17:56:08 UTC (rev 4213)
@@ -21,15 +21,13 @@
 
 #include <stdio.h>
 #include <stdlib.h>
-
 #include <string.h>
+#include <math.h>
 
-#include "math.h"
-#include <ADM_assert.h>
+#include "ADM_assert.h"
 #include "default.h"
 #include "ADM_editor/ADM_Video.h"
 
-
 #include "fourcc.h"
 #include "ADM_mp4/ADM_atom.h"
 #include "ADM_osSupport/ADM_debugID.h"
@@ -39,7 +37,7 @@
 adm_atom::adm_atom(adm_atom *atom)
 {
 	_fd=atom->_fd;
-	_atomStart=ftell(_fd);
+	_atomStart=ftello(_fd);
 	_atomSize=read32();
 	_atomFCC=read32();
 	// Gross hack for some (buggy ?) movie
@@ -48,10 +46,14 @@
 		printf("3GP:Workaround: detected wrong sized atom!\nTrying to continue\n");
 		_atomStart+=4;
 		_atomSize-=4;
-		fseek(_fd,_atomStart,SEEK_SET);
+		fseeko(_fd,_atomStart,SEEK_SET);
 		_atomSize=read32();
 		_atomFCC=read32();
 	}
+
+	if (fourCC::check(_atomFCC, (uint8_t *)"tadm") && _atomSize == 1)	// mdat
+		_atomSize=read64();
+
 #ifdef ATOM_DEBUG
 	dumpAtom();
 #endif
@@ -66,14 +68,14 @@
 }
 adm_atom::adm_atom(FILE *fd )
 {
-uint32_t orgpos;
+int64_t orgpos;
 	_fd=fd;
         orgpos=ftello(fd);
-	fseek(_fd,0,SEEK_END);
+	fseeko(_fd,0,SEEK_END);
 	_atomFCC=fourCC::get((uint8_t *)"MOVI");
-	_atomSize=ftell(_fd);//-orgpos;
+	_atomSize=ftello(_fd);//-orgpos;
 
-	fseek(_fd,orgpos,SEEK_SET);
+	fseeko(_fd,orgpos,SEEK_SET);
 	_atomStart=0;
 #ifdef ATOM_DEBUG
 	dumpAtom();
@@ -87,9 +89,9 @@
 }
 uint8_t adm_atom::skipBytes( uint32_t nb )
 {
-uint32_t pos;
-	fseek(_fd,nb,SEEK_CUR);
-	pos=ftell(_fd);
+int64_t pos;
+	fseeko(_fd,nb,SEEK_CUR);
+	pos=ftello(_fd);
 	if(pos>_atomStart+_atomSize+1) ADM_assert(0);	
 	return 1;
 }
@@ -126,16 +128,20 @@
 
 }
 
+uint64_t adm_atom::read64( void )
+{
+	uint64_t a1 = read32();
+
+	return (a1 << 32) + read32();
+}
+
 uint32_t adm_atom::getFCC( void )
 {
 	return _atomFCC;
 }
-uint32_t adm_atom::getSize( void )
+
+int64_t adm_atom::getRemainingSize( void )
 {
-	return _atomSize-8;
-}
-uint32_t adm_atom::getRemainingSize( void )
-{
         int64_t pos=ftello(_fd);
         
         return _atomStart+_atomSize-pos;
@@ -143,9 +149,9 @@
 
 uint8_t adm_atom::readPayload( uint8_t *whereto, uint32_t rd)
 {
-	uint32_t pos;
+	int64_t pos;
 
-	pos=ftell(_fd);
+	pos=ftello(_fd);
 	if(pos+rd>_atomSize+_atomStart)
 	{
 		printf("\n Going out of atom's bound!! (%ld  / %ld )\n",pos+rd,_atomSize+_atomStart);
@@ -174,7 +180,7 @@
 
 uint8_t adm_atom::skipAtom( void )
 {
-	fseek(_fd,_atomStart+_atomSize,SEEK_SET);
+	fseeko(_fd,_atomStart+_atomSize,SEEK_SET);
 #ifdef _3G_LOGO
         printf("Branching to %x ending atom ",_atomStart+_atomSize);
         fourCC::printBE(_atomFCC);
@@ -186,7 +192,7 @@
 }
 uint8_t adm_atom::isDone( void )
 {
-	uint32_t pos=ftell(_fd);
+	int64_t pos=ftello(_fd);
 
 	if(pos>=(_atomStart+_atomSize)) return 1;
 	return 0;

Modified: branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mp4/ADM_atom.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mp4/ADM_atom.h	2008-07-15 17:03:10 UTC (rev 4212)
+++ branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mp4/ADM_atom.h	2008-07-15 17:56:08 UTC (rev 4213)
@@ -23,7 +23,7 @@
 {
 private:
 		FILE 		*_fd;
-		uint32_t	_atomStart,_atomSize;
+		int64_t		_atomStart,_atomSize;
 		uint32_t	_atomFCC;
 		uint8_t		dumpAtom( void );
 public:
@@ -33,12 +33,12 @@
 		uint8_t	        skipAtom( void );
                 uint32_t        getStartPos(void) {return _atomStart;}
 		uint32_t	getFCC( void );
-		uint32_t	getSize( void );
-                uint32_t        getRemainingSize( void );
+		int64_t        getRemainingSize( void );
 		uint8_t		readPayload( uint8_t *whereto, uint32_t rd );
 		uint8_t		isDone(void );
 		uint8_t		skipBytes(uint32_t nb );
 
+		uint64_t	read64( void );
 		uint32_t	read32( void );
 		uint16_t	read16( void );
 		uint8_t	        read( void );

Modified: branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mp4/ADM_mp4.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mp4/ADM_mp4.cpp	2008-07-15 17:03:10 UTC (rev 4212)
+++ branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mp4/ADM_mp4.cpp	2008-07-15 17:56:08 UTC (rev 4213)
@@ -56,12 +56,10 @@
 
 #include <stdio.h>
 #include <stdlib.h>
-
 #include <string.h>
+#include <math.h>
 
-#include "math.h"
-
-#include <ADM_assert.h>
+#include "ADM_assert.h"
 #include "default.h"
 #include "ADM_editor/ADM_Video.h"
 
@@ -126,7 +124,7 @@
     {
       return 0; 
     }
-    uint32_t offset=VDEO.index[framenum].offset; //+_mdatOffset;
+    uint64_t offset=VDEO.index[framenum].offset; //+_mdatOffset;
 
 
     fseeko(_fd,offset,SEEK_SET);
@@ -229,14 +227,14 @@
         fseeko(_fd,0,SEEK_SET);
         if(check[0]=='m' && check[1]=='d' &&check[2]=='a' && check[3]=='t')
         {
-                        uint32_t of;
+                        uint64_t of;
                                         printf("Data first, header later...\n");
                                         of=atom->read32();
                                         if(of==1)
                                         {
-                                          atom->read32();
-                                          atom->read32();
-                                          of=atom->read32();
+                                          atom->read32();	// size
+                                          atom->read32();	// fcc
+                                          of=atom->read64();
                                         }
                                         fseeko(_fd,of,SEEK_SET);        
                                         printf("Header starts at %x\n",of);
@@ -333,7 +331,7 @@
             _audioTracks[audio]=new MP4Audio(name,&(_tracks[1+audio]));   
             
         }
-        fseek(_fd,0,SEEK_SET);
+        fseeko(_fd,0,SEEK_SET);
         printf("3gp/mov file successfully read..\n");
         return 1;
 }

Modified: branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mp4/ADM_mp4.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mp4/ADM_mp4.h	2008-07-15 17:03:10 UTC (rev 4212)
+++ branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mp4/ADM_mp4.h	2008-07-15 17:56:08 UTC (rev 4213)
@@ -38,7 +38,7 @@
       uint32_t nbSync;
       uint32_t nbCtts;
       
-      uint32_t *Co;
+	  uint64_t *Co;
       uint32_t *Sz;
       uint32_t *Sc;
       uint32_t *Sn;
@@ -86,15 +86,12 @@
 protected:
 
            	uint32_t 					_nb_chunks;
-		uint64_t					_abs_position;
-		uint32_t					_rel_position;
-
               	uint32_t 					_current_index;
 	    	MP4Index 					*_index;
 		FILE						*_fd;
 		uint32_t					_extraLen;
 		uint8_t						*_extraData;
-		uint32_t                                         _audioDuration;
+		uint64_t                                         _audioDuration;
 		
 		
 public:
@@ -129,7 +126,7 @@
           uint8_t                       decodeEsds(void *ztom,uint32_t trackType);
           uint8_t                       updateCtts(MPsampleinfo *info );
           uint32_t                      _videoScale;
-          uint32_t                      _movieDuration; // in ms
+          int64_t						_movieDuration; // in ms
           uint32_t                      _videoFound;
           uint8_t	                indexify(
                                                 MP4Track *track,   
@@ -141,7 +138,7 @@
         uint8_t                       _reordered;		
         FILE                          *_fd;
         MP4Track                      _tracks[_3GP_MAX_TRACKS];
-        uint32_t                      _audioDuration;
+        int64_t                      _audioDuration;
         uint32_t                      _currentAudioTrack;
         uint8_t                       parseAtomTree(adm_atom *atom);
         MP4Audio                      *_audioTracks[_3GP_MAX_TRACKS-1];

Modified: branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mp4/ADM_mp4Analyzer.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mp4/ADM_mp4Analyzer.cpp	2008-07-15 17:03:10 UTC (rev 4212)
+++ branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mp4/ADM_mp4Analyzer.cpp	2008-07-15 17:56:08 UTC (rev 4213)
@@ -17,12 +17,10 @@
 
 #include <stdio.h>
 #include <stdlib.h>
-
 #include <string.h>
+#include <math.h>
 
-#include "math.h"
-
-#include <ADM_assert.h>
+#include "ADM_assert.h"
 #include "default.h"
 #include "ADM_editor/ADM_Video.h"
 
@@ -110,23 +108,36 @@
 */
 void MP4Header::parseMvhd(void *ztom)
 {
-  adm_atom *tom=(adm_atom *)ztom;
-  tom->skipBytes(12);
-  uint32_t scale,duration=1000;
+	adm_atom *tom = (adm_atom*)ztom;
+	int version = tom->read();
 
-        scale=tom->read32();
-        duration=tom->read32();
-        _videoScale=scale;
-        printf("Warning : scale is not in ms %lu !\n",_videoScale);
-        if(_videoScale)
-        {
-                        duration=1000*duration; // In ms
-                        duration/=_videoScale;
-        }else
-          _videoScale=1000;
-        printf("Movie duration :%s\n",ms2timedisplay(duration));
-        _movieDuration=duration;
+	tom->skipBytes(3);	// flags
+
+	if (version == 1)
+		tom->skipBytes(16);
+	else
+		tom->skipBytes(8);
+
+	int scale = tom->read32();
+	uint64_t duration = (version == 1) ? tom->read64() : tom->read32();
+
+	_videoScale = scale;
+
+	printf("Warning: scale is not in ms %lu!\n", _videoScale);
+
+	if (_videoScale)
+	{
+		duration = 1000 * duration; // In ms
+		duration /= _videoScale;
+	}
+	else
+		_videoScale = 1000;
+
+	printf("Movie duration: %s\n", ms2timedisplay(duration));
+
+	_movieDuration = duration;
 }
+
 /**
       \fn parseMvhd
       \brief Parse mvhd header
@@ -154,20 +165,31 @@
      {
        case ADM_MP4_TKHD:
               {
-                      son.skipBytes(12);
-                      adm_printf(ADM_PRINT_DEBUG,"Track Id: %lu\n",son.read32());
-                      son.skipBytes(4);
-                      adm_printf(ADM_PRINT_DEBUG,"Duration: %lu (ms)\n",(son.read32()*1000)/_videoScale);
-                      son.skipBytes(8);
-                      son.skipBytes(4); // layers
-                      son.skipBytes(40); // layers
+				  int version = son.read();
 
-                      w=son.read32()>>16;
-                      h=son.read32()>>16;
-                      adm_printf(ADM_PRINT_DEBUG,"tkhd : %ld %ld\n",w,h);
+				  son.skipBytes(3);
 
+				  if (version == 1)
+					  tom->skipBytes(16);
+				  else
+					  tom->skipBytes(8);
+
+				  adm_printf(ADM_PRINT_DEBUG,"Track Id: %lu\n", son.read32());
+				  son.skipBytes(4);
+
+				  uint64_t duration = (version == 1) ? son.read64() : son.read32();
+
+				  adm_printf(ADM_PRINT_DEBUG, "Duration: %lu (ms)\n", (duration * 1000) / _videoScale);
+				  son.skipBytes(8);
+				  son.skipBytes(8);
+				  son.skipBytes(36);
+
+				  w = son.read32() >> 16;
+				  h = son.read32() >> 16;
+
+				  adm_printf(ADM_PRINT_DEBUG,"tkhd: %ld %ld\n", w, h);
+				  break;
               }
-              break;
         case ADM_MP4_MDIA:
         {
             parseMdia(&son,&trackType,w,h);
@@ -190,7 +212,7 @@
   ADMAtoms id;
   uint32_t container;
   uint32_t trackScale=_videoScale;
-  uint32_t trackDuration;
+  uint64_t trackDuration;
   *trackType=TRACK_OTHER;
   uint8_t r=0;
   printf("<<Parsing Mdia>>\n");
@@ -207,21 +229,31 @@
      {
        case ADM_MP4_MDHD:
        {
-                uint32_t version=son.read(),duration;
-                son.skipBytes(3); // flags + version
-                son.skipBytes(4); // creation time
-                son.skipBytes(4); // mod time
-                if(version==1) son.skipBytes(8);
-                trackScale=son.read32(); //
-                adm_printf(ADM_PRINT_DEBUG,"MDHD,Trackscale in mdhd:%u\n",trackScale);
-                if(!trackScale) trackScale=600; // default
-                duration=son.read32();
-                adm_printf(ADM_PRINT_DEBUG,"MDHD,duration in mdhd:%u (unscaled)\n",duration);
-                duration=(uint32_t)((duration*1000.)/trackScale);
-                adm_printf(ADM_PRINT_DEBUG,"MDHD,duration in mdhd:%u (scaled ms)\n",duration);
-                trackDuration=duration;
-                printf("MDHD,Track duration :%s, trackScale :%u\n",ms2timedisplay((1000*duration)/trackScale),trackScale);
-                break;
+		   int version = son.read();
+
+		   son.skipBytes(3); // flags
+
+		   if (version == 1)
+			   son.skipBytes(16);
+		   else
+			   son.skipBytes(8);
+
+		   trackScale = son.read32();
+
+		   adm_printf(ADM_PRINT_DEBUG, "MDHD, Trackscale in mdhd: %u\n", trackScale);
+
+		   if (!trackScale)
+			   trackScale = 600; // default
+
+		   uint64_t duration = (version == 1) ? son.read64() : son.read32();
+
+		   adm_printf(ADM_PRINT_DEBUG, "MDHD, duration in mdhd: %u (unscaled)\n", duration);
+		   duration = (duration * 1000.) / trackScale;
+		   adm_printf(ADM_PRINT_DEBUG, "MDHD, duration in mdhd: %u (scaled ms)\n", duration);
+		   trackDuration = duration;
+		   printf("MDHD, Track duration: %s, trackScale: %u\n", ms2timedisplay((1000 * duration) / trackScale), trackScale);
+
+		   break;
        }
        case ADM_MP4_HDLR:
        {
@@ -346,7 +378,7 @@
                 printf("Using myscale %lu\n",trackScale);
                 info.SttsN=new uint32_t[info.nbStts];
                 info.SttsC=new uint32_t[info.nbStts];
-                double dur;
+                //double dur;
                 for(int i=0;i<info.nbStts;i++)
                 {
 
@@ -449,32 +481,34 @@
             break;
        case ADM_MP4_STCO:
        {
-          son.read32();
-          info.nbCo=son.read32();
-          printf("\t\tnbCo:%u\n",info.nbCo);
-          info.Co=new uint32_t[info.nbCo];
-          for(int j=0;j< info.nbCo;j++)
-          {
-                  info.Co[j]=son.read32();
-                  adm_printf(ADM_PRINT_VERY_VERBOSE,"Chunk offset : %u / %u  : %u\n",  j,info.nbCo,info.Co[j]);
-          }
+		   son.skipBytes(4);
 
+		   info.nbCo = son.read32();
+		   printf("\t\tnbCo: %u\n", info.nbCo);
+
+		   info.Co = new uint64_t[info.nbCo];
+
+		   for(int j = 0; j < info.nbCo; j++)
+		   {
+			   info.Co[j] = son.read32();
+			   adm_printf(ADM_PRINT_VERY_VERBOSE, "Chunk offset: %u / %u : %"LLU"\n", j, info.nbCo - 1, info.Co[j]);
+		   }
        }
        break;
        case ADM_MP4_STCO64:
        {
-         printf("Incomplete support for 64 bits quicktime!!\n");
-          son.read32();
-          info.nbCo=son.read32();
-          printf("\t\tnbCo:%u\n",info.nbCo);
-          info.Co=new uint32_t[info.nbCo];
-          for(int j=0;j< info.nbCo;j++)
-          {
-                  son.read32(); // Ignore MSB
-                  info.Co[j]=son.read32();
-                  adm_printf(ADM_PRINT_VERY_VERBOSE,"Chunk offset : %u / %u  : %lu\n",  j,info.nbCo,info.Co[j]);
-          }
+		   son.skipBytes(4);
 
+		   info.nbCo = son.read32();
+		   printf("\t\tnbCo: %u\n", info.nbCo);
+
+		   info.Co = new uint64_t[info.nbCo];
+
+		   for(int j = 0; j< info.nbCo; j++)
+		   {
+			   info.Co[j] = son.read64();
+			   adm_printf(ADM_PRINT_VERY_VERBOSE, "Chunk offset: %u / %u : %"LLU"\n", j, info.nbCo - 1, info.Co[j]);
+		   }
        }
        break;
        case ADM_MP4_STSD:
@@ -800,7 +834,7 @@
                                             break;
                                     case MKFCCR('Q','D','M','2'):
                                         {
-                                            uint32_t sz;
+                                            int64_t sz;
                                               audioCodec(QDM2);
                                               sz=son.getRemainingSize();
                                               _tracks[1+nbAudioTrack].extraDataSize=sz;
@@ -927,7 +961,7 @@
             // Mark keyframes
             for(int i=0;i<info.nbSync;i++)
             {
-              int sync=info.Sync[i];
+              uint32_t sync=info.Sync[i];
               if(sync) sync--;
               _tracks[0].index[sync].intra=AVI_KEY_FRAME;
             }

Modified: branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mp4/ADM_mp4Indexer.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mp4/ADM_mp4Indexer.cpp	2008-07-15 17:03:10 UTC (rev 4212)
+++ branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mp4/ADM_mp4Indexer.cpp	2008-07-15 17:56:08 UTC (rev 4213)
@@ -17,12 +17,10 @@
 
 #include <stdio.h>
 #include <stdlib.h>
-
 #include <string.h>
+#include <math.h>
 
-#include "math.h"
-
-#include <ADM_assert.h>
+#include "ADM_assert.h"
 #include "default.h"
 #include "ADM_editor/ADM_Video.h"
 
@@ -56,7 +54,7 @@
         printf("Build Track index\n");
 	*outNbChunk=0;
 	aprintf("+_+_+_+_+_+\n");
-	aprintf("co : %lu sz: %lu sc: %lu co[0]%lu \n",info->nbCo,info->nbSz,info->nbSc,info->Co[0]);
+	aprintf("co : %lu sz: %lu sc: %lu co[0] %"LLU"\n",info->nbCo,info->nbSz,info->nbSc,info->Co[0]);
 	aprintf("+_+_+_+_+_+\n");
 
 	ADM_assert(info->Sc);
@@ -74,7 +72,7 @@
           
           
           uint32_t totalBytes=info->SzIndentical*info->nbSz;
-          printf("All the same size : %u (total size %u bytes)\n",info->SzIndentical,totalBytes);
+          printf("All the same size: %u (total size %u bytes)\n",info->SzIndentical,totalBytes);
               //
               // Each chunk contains N samples=N bytes
               int samplePerChunk[info->nbCo];
@@ -85,8 +83,7 @@
 
                   for(int j=info->Sc[i]-1;j<info->nbCo;j++)
                   {
-                    uint32_t mx;
-                        adm_printf(ADM_PRINT_VERY_VERBOSE,"For chunk %lu , %lu samples\n",j,info->Sn[i]);
+                        adm_printf(ADM_PRINT_VERY_VERBOSE,"For chunk %lu, %lu samples\n",j,info->Sn[i]);
                         samplePerChunk[j]=info->Sn[i];
                   }
               }
@@ -247,7 +244,7 @@
           }
 	// if no sample to chunk we map directly
 	// first build the # of sample per chunk table
-        uint32_t totalchunk=0,max=0;
+        uint32_t totalchunk=0;
 
         // Search the maximum
         for(i=0;i<info->nbSc-1;i++)
@@ -256,9 +253,9 @@
         }
         totalchunk+=(info->nbCo-info->Sc[info->nbSc-1]+1)*info->Sn[info->nbSc-1];
 
-        adm_printf(ADM_PRINT_VERY_VERBOSE,"#of chunk %d max per chunk %d Max # of sample %d\n",info->nbCo,max,totalchunk);
+        adm_printf(ADM_PRINT_VERY_VERBOSE,"# of chunks %d, max # of samples %d\n",info->nbCo, totalchunk);
 
-        uint32_t chunkCount[totalchunk+1];
+        uint32_t *chunkCount = new uint32_t[totalchunk+1];
 	for(i=0;i<info->nbSc;i++)
 	{
 		for(j=info->Sc[i]-1;j<info->nbCo;j++)
@@ -289,6 +286,8 @@
 
 
 	}
+
+	delete [] chunkCount;
         
         
         track->nbIndex=cur;;

Modified: branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mp4/ADM_mp4audio.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mp4/ADM_mp4audio.cpp	2008-07-15 17:03:10 UTC (rev 4212)
+++ branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mp4/ADM_mp4audio.cpp	2008-07-15 17:56:08 UTC (rev 4213)
@@ -27,8 +27,8 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
-#include "math.h"
-#include <ADM_assert.h>
+#include <math.h>
+#include "ADM_assert.h"
 
 #include "default.h"
 #include "ADM_editor/ADM_Video.h"
@@ -46,8 +46,6 @@
 	_fd=fopen(name,"rb");
         ADM_assert(_fd);
 	_current_index=0;
-	_abs_position=0;
-	_rel_position=0;
 	_pos=0;
 	_index=track->index;
 
@@ -63,9 +61,8 @@
 	// compute length
 	_length=0;
 	for(uint32_t i=0;i<_nb_chunks;i++)
-		{
-			_length+=track->index[i].size;
-		}
+		_length+=track->index[i].size;
+
 	printf("\n [MP4 audio] : %lu bytes (%lu chunks)\n",_length,_nb_chunks);
 
 	printf("Byterate     :%d\n",_wavheader->byterate);
@@ -125,13 +122,8 @@
 	  fseeko(_fd,_index[_current_index].offset,SEEK_SET);
 	  r=fread(dest,1,_index[_current_index].size,_fd);
           if(!r)
-          {
             printf("[MP4 Audio] Cannot read \n"); 
-          }
-          else
-          {
-            
-          }
+
 	  if(_current_index==_nb_chunks-1)
 	  {
 	  	
@@ -147,10 +139,12 @@
                         delta*=_wavheader->frequency;
                         delta/=1000.; // mss -> second
                         *samples=(uint32_t)floor(delta);
-                }else *samples=1024;
+                }
+				else
+					*samples=1024;
+
                 printf("[MP4Audio]: Last sample %d current chunk %d nb chunk %d\n",
                                 *samples,_current_index,_nb_chunks);
-                
 	  }
 	  else
 	  {
@@ -161,7 +155,6 @@
 		delta*=_wavheader->frequency;
 		delta/=1000.*1000.; // us -> second
 		*samples=(uint32_t)floor(delta);
-	     
 	  }
 #if 0
           printf("[MP4Audio]Read %u bytes\n", r);



From gruntster at mail.berlios.de  Tue Jul 15 20:11:51 2008
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Tue, 15 Jul 2008 20:11:51 +0200
Subject: [Avidemux-svn-commit] r4214 -
	branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat
Message-ID: <200807151811.m6FIBpDu007510@sheep.berlios.de>

Author: gruntster
Date: 2008-07-15 20:11:43 +0200 (Tue, 15 Jul 2008)
New Revision: 4214

Modified:
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/ADM_lavformat.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/file.c
Log:
[MP4] support for 64-bit output

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/ADM_lavformat.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/ADM_lavformat.cpp	2008-07-15 17:56:08 UTC (rev 4213)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/ADM_lavformat.cpp	2008-07-15 18:11:43 UTC (rev 4214)
@@ -530,14 +530,14 @@
         AVPacket pkt;
         double f;
         int64_t timeInUs;
-        static int sz=0;
+        static uint64_t sz = 0;
             //printf("Audio paclet : size %u, sample %u\n",len,sample);
 
            if(!audio_st) return 0;
            if(!len) return 1;
             av_init_packet(&pkt);
             timeInUs=(int64_t)sample2time_us(sample);
-            aprintf("Sample :%u time :%u size :%u this round:%u\n",sample,timeInUs,sz,len);
+            aprintf("Sample: %u, time: %"LLU", size: %"LLU", this round: %u\n",sample, timeInUs, sz, len);
             sz+=len;
             /* Rescale to ?? */
             if(_type==MUXER_FLV || _type==MUXER_MATROSKA) /* The FLV muxer expects packets dated in ms, there is something i did not get... WTF */
@@ -552,8 +552,8 @@
             	f*=_audioFq; // In samples
             	f=floor(f+0.4);
             }
-            pkt.dts=pkt.pts=(int)(f);
-            aprintf("Adm audio dts=:%u\n",pkt.dts);
+            pkt.dts=pkt.pts=f;
+            aprintf("Adm audio dts: %"LLU"\n",pkt.dts);
             //printf("F:%f Q:%u D=%u\n",f,pkt.pts,timeInUs-_lastAudioDts);
 
             pkt.flags |= PKT_FLAG_KEY;
@@ -561,7 +561,7 @@
             pkt.size= len;
             pkt.stream_index=1;
             //pkt.duration=pkt.dts-_lastAudioDts; // Duration
-            aprintf("A: sample: %d frame_pts: %d fq: %d\n",(int32_t )sample,(int32_t )pkt.dts,audio_st->codec->sample_rate);
+            aprintf("A: sample: %d, frame_pts: %"LLU", fq: %d\n", sample, pkt.dts, audio_st->codec->sample_rate);
 
             ret = av_write_frame(oc, &pkt);
             _lastAudioDts=timeInUs;

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/file.c
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/file.c	2008-07-15 17:56:08 UTC (rev 4213)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/file.c	2008-07-15 18:11:43 UTC (rev 4214)
@@ -28,6 +28,7 @@
 #ifdef __WIN32
 extern int ADM_open(const char *path, int oflag, ...);
 #define open ADM_open
+#define lseek(f,p,w) _lseeki64((f), (p), (w))
 #endif
 // GRUNTSTER end
 



From gruntster at mail.berlios.de  Tue Jul 15 20:16:01 2008
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Tue, 15 Jul 2008 20:16:01 +0200
Subject: [Avidemux-svn-commit] r4215 -
	branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mp4
Message-ID: <200807151816.m6FIG12x008250@sheep.berlios.de>

Author: gruntster
Date: 2008-07-15 20:15:55 +0200 (Tue, 15 Jul 2008)
New Revision: 4215

Modified:
   branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mp4/ADM_mp4.cpp
Log:
[MP4] set frame flags for correct indexing

Modified: branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mp4/ADM_mp4.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mp4/ADM_mp4.cpp	2008-07-15 18:11:43 UTC (rev 4214)
+++ branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mp4/ADM_mp4.cpp	2008-07-15 18:15:55 UTC (rev 4215)
@@ -130,6 +130,8 @@
     fseeko(_fd,offset,SEEK_SET);
     fread(img->data, VDEO.index[framenum].size, 1, _fd);
     img->dataLength=VDEO.index[framenum].size;
+	img->flags = VDEO.index[framenum].intra;
+
     return 1;
 }
 MP4Header::~MP4Header()



From gruntster at mail.berlios.de  Tue Jul 15 20:17:31 2008
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Tue, 15 Jul 2008 20:17:31 +0200
Subject: [Avidemux-svn-commit] r4216 -
	branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mp4
Message-ID: <200807151817.m6FIHVZo008672@sheep.berlios.de>

Author: gruntster
Date: 2008-07-15 20:17:25 +0200 (Tue, 15 Jul 2008)
New Revision: 4216

Modified:
   branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mp4/ADM_mp4Analyzer.cpp
Log:
[MP4] improve fps accuracy

Modified: branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mp4/ADM_mp4Analyzer.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mp4/ADM_mp4Analyzer.cpp	2008-07-15 18:15:55 UTC (rev 4215)
+++ branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mp4/ADM_mp4Analyzer.cpp	2008-07-15 18:17:25 UTC (rev 4216)
@@ -953,7 +953,7 @@
           float f=_videostream.dwLength;
           if(_movieDuration) f=1000000.*f/_movieDuration;
               else  f=25000;
-          _videostream.dwRate=(uint32_t)floor(f);
+          _videostream.dwRate=(uint32_t)floor(f+0.49);
            _mainaviheader.dwMicroSecPerFrame=ADM_UsecFromFps1000(_videostream.dwRate);
           // if we have a sync atom ???
           if(info.nbSync)



From gruntster at mail.berlios.de  Tue Jul 15 20:18:59 2008
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Tue, 15 Jul 2008 20:18:59 +0200
Subject: [Avidemux-svn-commit] r4217 -
	branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mp4
Message-ID: <200807151818.m6FIIxWU008844@sheep.berlios.de>

Author: gruntster
Date: 2008-07-15 20:18:52 +0200 (Tue, 15 Jul 2008)
New Revision: 4217

Modified:
   branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mp4/ADM_mp4audio.cpp
Log:
[MP4] enable building of VBR time map

Modified: branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mp4/ADM_mp4audio.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mp4/ADM_mp4audio.cpp	2008-07-15 18:17:25 UTC (rev 4216)
+++ branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mp4/ADM_mp4audio.cpp	2008-07-15 18:18:52 UTC (rev 4217)
@@ -105,7 +105,7 @@
 //_______________________________________________________
 uint8_t MP4Audio::goTo(uint32_t newoffset)
 {
-   ADM_assert(0);
+   goToTime(0);
     return 1;
 }
 //______________________________________



From gruntster at mail.berlios.de  Tue Jul 15 20:22:05 2008
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Tue, 15 Jul 2008 20:22:05 +0200
Subject: [Avidemux-svn-commit] r4218 - in
	branches/avidemux_2.4_branch/avidemux: ADM_inputs/ADM_mp4
	ADM_libraries/ADM_lavformat
Message-ID: <200807151822.m6FIM5ss009499@sheep.berlios.de>

Author: gruntster
Date: 2008-07-15 20:21:57 +0200 (Tue, 15 Jul 2008)
New Revision: 4218

Modified:
   branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mp4/ADM_mp4Analyzer.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/isom.c
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/movenc.c
Log:
[MP4] support MP2 audio (FS#308)

Modified: branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mp4/ADM_mp4Analyzer.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mp4/ADM_mp4Analyzer.cpp	2008-07-15 18:18:52 UTC (rev 4217)
+++ branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mp4/ADM_mp4Analyzer.cpp	2008-07-15 18:21:57 UTC (rev 4218)
@@ -1045,7 +1045,7 @@
                                       switch(objectTypeIndication)
                                       {
                                           case 0x69:ADIO.encoding=WAV_MP3;break;
-                                          case 0x6b:ADIO.encoding=WAV_MP3;break;
+                                          case 0x6b:ADIO.encoding=WAV_MP2;break;
                                           case 0x6d:ADIO.encoding=WAV_MP3;break;
                                           case 226:ADIO.encoding=WAV_AC3;break;
                                           break;

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/isom.c
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/isom.c	2008-07-15 18:18:52 UTC (rev 4217)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/isom.c	2008-07-15 18:21:57 UTC (rev 4218)
@@ -156,6 +156,7 @@
      { CODEC_ID_MP3, MKTAG( 'm', 'p', '4','a') },
 
     // /MEANX
+	{ CODEC_ID_MP2, MKTAG( 'm', 'p', '4', 'a') },
     { CODEC_ID_MP3, 0x6D730055 }, /* MPEG layer 3 */
     { CODEC_ID_MP3, MKTAG('m', 's', 0x00, 0x55) }, /* MPEG layer 3 *//* XXX: check endianness */
 

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/movenc.c
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/movenc.c	2008-07-15 18:18:52 UTC (rev 4217)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/movenc.c	2008-07-15 18:21:57 UTC (rev 4218)
@@ -385,7 +385,8 @@
         track->enc->codec_id == CODEC_ID_PCM_S32LE))
         mov_write_wave_tag(pb, track);
     else if(track->enc->codec_id == CODEC_ID_AAC // MEANX)
-       || track->enc->codec_id == CODEC_ID_MP3) // MEANX
+       || track->enc->codec_id == CODEC_ID_MP3
+	   || track->enc->codec_id == CODEC_ID_MP2) // MEANX
         mov_write_esds_tag(pb, track);
     else if(track->enc->codec_id == CODEC_ID_AMR_NB)
         mov_write_amr_tag(pb, track);



From gruntster at mail.berlios.de  Wed Jul 16 03:20:05 2008
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Wed, 16 Jul 2008 03:20:05 +0200
Subject: [Avidemux-svn-commit] r4219 - in branches/avidemux_2.4_branch:
	avidemux platforms/windows platforms/windows/build_scripts
	platforms/windows/build_scripts/avidemux_2.4
	platforms/windows/build_scripts/avidemux_2.4/Tools
	platforms/windows/installer
Message-ID: <200807160120.m6G1K5X7018399@sheep.berlios.de>

Author: gruntster
Date: 2008-07-16 03:19:49 +0200 (Wed, 16 Jul 2008)
New Revision: 4219

Added:
   branches/avidemux_2.4_branch/platforms/windows/build_scripts/
   branches/avidemux_2.4_branch/platforms/windows/build_scripts/Set Common Environment Variables.bat
   branches/avidemux_2.4_branch/platforms/windows/build_scripts/avidemux_2.4/
   branches/avidemux_2.4_branch/platforms/windows/build_scripts/avidemux_2.4/1. Perform Build.bat
   branches/avidemux_2.4_branch/platforms/windows/build_scripts/avidemux_2.4/1b. Continue Build.bat
   branches/avidemux_2.4_branch/platforms/windows/build_scripts/avidemux_2.4/2. Create Packages.bat
   branches/avidemux_2.4_branch/platforms/windows/build_scripts/avidemux_2.4/2a. Update Notes.bat
   branches/avidemux_2.4_branch/platforms/windows/build_scripts/avidemux_2.4/2b. Package Build.bat
   branches/avidemux_2.4_branch/platforms/windows/build_scripts/avidemux_2.4/Package Notes.xml
   branches/avidemux_2.4_branch/platforms/windows/build_scripts/avidemux_2.4/Set Avidemux 2.4 Environment Variables.bat
   branches/avidemux_2.4_branch/platforms/windows/build_scripts/avidemux_2.4/Tools/
   branches/avidemux_2.4_branch/platforms/windows/build_scripts/avidemux_2.4/Tools/Get Revision Number.bat
   branches/avidemux_2.4_branch/platforms/windows/build_scripts/avidemux_2.4/Tools/Revision No template.bat
   branches/avidemux_2.4_branch/platforms/windows/build_scripts/avidemux_2.4/Tools/gennotes.sh
   branches/avidemux_2.4_branch/platforms/windows/build_scripts/avidemux_2.4/Tools/gentouch.sh
   branches/avidemux_2.4_branch/platforms/windows/build_scripts/avidemux_2.4/Tools/package_notes.xslt
   branches/avidemux_2.4_branch/platforms/windows/build_scripts/avidemux_2.4/Tools/touch_files.xslt
   branches/avidemux_2.4_branch/platforms/windows/installer/
Removed:
   branches/avidemux_2.4_branch/avidemux/winInstaller/
Modified:
   branches/avidemux_2.4_branch/platforms/windows/installer/avidemux.nsi
   branches/avidemux_2.4_branch/platforms/windows/installer/genlog.sh
Log:
[Win32] build scripts

Added: branches/avidemux_2.4_branch/platforms/windows/build_scripts/Set Common Environment Variables.bat
===================================================================
--- branches/avidemux_2.4_branch/platforms/windows/build_scripts/Set Common Environment Variables.bat	2008-07-15 18:21:57 UTC (rev 4218)
+++ branches/avidemux_2.4_branch/platforms/windows/build_scripts/Set Common Environment Variables.bat	2008-07-16 01:19:49 UTC (rev 4219)
@@ -0,0 +1,78 @@
+ at echo off
+
+set ProgramFiles32=%ProgramFiles%
+if "%PROCESSOR_ARCHITECTURE%" == "AMD64" for /D %%d in ("%ProgramFiles(x86)%") do set ProgramFiles32=%%~fsd
+set nsisDir=%ProgramFiles32%\NSIS
+
+set devDir=C:\Dev
+set mingwDir=%devDir%\MinGW
+set msysDir=C:/Dev/MSYS
+set usrLocalDir=%msysDir%/local
+set CMAKE_INCLUDE_PATH=%usrLocalDir%/include
+set CMAKE_LIBRARY_PATH=%usrLocalDir%/lib
+set PKG_CONFIG_PATH=%usrLocalDir%\lib\pkgconfig
+set SDLDIR=%usrLocalDir%
+set CFLAGS=-I%CMAKE_INCLUDE_PATH% -L%CMAKE_LIBRARY_PATH%
+set CXXFLAGS=-I%CMAKE_INCLUDE_PATH% -L%CMAKE_LIBRARY_PATH%
+set qtDir=%devDir%\Qt
+
+if exist "%qtDir%" (
+	for /f %%d in ('dir /b /ad /on %qtDir%') do set qtVer=%%d
+) else (
+	echo Qt 4 could not be found at "%qtDir%".  Please download from http://www.trolltech.com
+	goto error
+)
+
+set qtDir=%qtDir%\%qtVer%
+
+if exist "%devDir%\CMake 2.4\bin" (
+	set cmakeDir=%devDir%\CMake 2.4\bin
+	goto foundCMake
+)
+
+if exist "%ProgramFiles32%\CMake 2.4\bin" (
+	set cmakeDir=%ProgramFiles32%\CMake 2.4\bin
+	goto foundCMake
+)
+
+if exist "%devDir%\CMake 2.6\bin" (
+	set cmakeDir=%devDir%\CMake 2.6\bin
+	goto foundCMake
+)
+
+if exist "%ProgramFiles32%\CMake 2.6\bin" (
+	set cmakeDir=%ProgramFiles32%\CMake 2.6\bin
+) else (
+	echo CMake could not be found.  Please download from http://www.cmake.org
+	goto error
+)
+
+:foundCMake
+if not exist "%mingwDir%" (
+	echo MinGW could not be found at "%mingwDir%".  Please download from http://www.mingw.org
+	goto error
+)
+
+if not exist "%CMAKE_INCLUDE_PATH%" (
+	echo Include path could not be found at "%CMAKE_INCLUDE_PATH%".
+	goto error
+)
+
+if not exist "%CMAKE_LIBRARY_PATH%" (
+	echo Library path could not be found at "%CMAKE_LIBRARY_PATH%".
+	goto error
+)
+
+if not exist "%nsisDir%" (
+	echo NSIS could not be found at "%nsisDir%".  Please download from http://nsis.sourceforge.net
+	goto error
+)
+
+set PATH=%cmakeDir%;%mingwDir%\bin;%usrLocalDir%\bin;%msysDir%\bin;%qtDir%\bin;%PATH%
+
+goto end
+
+:error
+set ERRORLEVEL=1
+
+:end
\ No newline at end of file

Added: branches/avidemux_2.4_branch/platforms/windows/build_scripts/avidemux_2.4/1. Perform Build.bat
===================================================================
--- branches/avidemux_2.4_branch/platforms/windows/build_scripts/avidemux_2.4/1. Perform Build.bat	2008-07-15 18:21:57 UTC (rev 4218)
+++ branches/avidemux_2.4_branch/platforms/windows/build_scripts/avidemux_2.4/1. Perform Build.bat	2008-07-16 01:19:49 UTC (rev 4219)
@@ -0,0 +1,35 @@
+ at echo off
+
+set curDir=%CD%
+call "Set Avidemux 2.4 Environment Variables"
+
+if errorlevel 1 goto error
+
+cd "%sourceDir%"
+echo Cleaning build directories
+rmdir /s /q build 2> NULL
+rmdir /s /q buildcli 2> NULL
+
+if exist build goto removalFailure
+if exist buildcli goto removalFailure
+
+mkdir buildcli
+mkdir build
+
+echo Performing Subversion update
+svn up .
+
+cd %curDir%
+call "1b. Continue Build"
+
+goto end
+
+:removalFailure
+echo ERROR - build or buildcli could not be fully deleted.
+echo Aborting.
+pause
+
+:error
+set ERRORLEVEL=1
+
+:end

Added: branches/avidemux_2.4_branch/platforms/windows/build_scripts/avidemux_2.4/1b. Continue Build.bat
===================================================================
--- branches/avidemux_2.4_branch/platforms/windows/build_scripts/avidemux_2.4/1b. Continue Build.bat	2008-07-15 18:21:57 UTC (rev 4218)
+++ branches/avidemux_2.4_branch/platforms/windows/build_scripts/avidemux_2.4/1b. Continue Build.bat	2008-07-16 01:19:49 UTC (rev 4219)
@@ -0,0 +1,34 @@
+ at echo off
+
+call "Set Avidemux 2.4 Environment Variables"
+
+cd "%sourceDir%\build"
+
+cmake -DUSE_LATE_BINDING=1 -G"MinGW Makefiles" ..
+
+if errorlevel 1 goto error
+
+pause
+mingw32-make avidemux2_gtk
+mingw32-make avidemux2_qt4
+mingw32-make mofiles
+mingw32-make qmfiles
+
+copy /y .\avidemux\avidemux2_gtk.exe "%buildDir%"
+copy /y .\avidemux\avidemux2_qt4.exe "%buildDir%"
+
+cd ..\buildcli
+
+cmake -DUSE_LATE_BINDING=1 -G"MinGW Makefiles" -DNO_SDL=1 ..
+mingw32-make avidemux2_cli
+
+copy /y .\avidemux\avidemux2_cli.exe "%buildDir%"
+
+echo Finished!
+goto end
+
+:error
+set ERRORLEVEL=1
+
+:end
+pause
\ No newline at end of file

Added: branches/avidemux_2.4_branch/platforms/windows/build_scripts/avidemux_2.4/2. Create Packages.bat
===================================================================
--- branches/avidemux_2.4_branch/platforms/windows/build_scripts/avidemux_2.4/2. Create Packages.bat	2008-07-15 18:21:57 UTC (rev 4218)
+++ branches/avidemux_2.4_branch/platforms/windows/build_scripts/avidemux_2.4/2. Create Packages.bat	2008-07-16 01:19:49 UTC (rev 4219)
@@ -0,0 +1,12 @@
+ at call "2a. Update Notes.bat"
+
+if errorlevel 1 goto error
+
+ at call "2b. Package Build.bat"
+
+goto end
+
+:error
+set ERRORLEVEL 1
+
+:end
\ No newline at end of file

Added: branches/avidemux_2.4_branch/platforms/windows/build_scripts/avidemux_2.4/2a. Update Notes.bat
===================================================================
--- branches/avidemux_2.4_branch/platforms/windows/build_scripts/avidemux_2.4/2a. Update Notes.bat	2008-07-15 18:21:57 UTC (rev 4218)
+++ branches/avidemux_2.4_branch/platforms/windows/build_scripts/avidemux_2.4/2a. Update Notes.bat	2008-07-16 01:19:49 UTC (rev 4219)
@@ -0,0 +1,29 @@
+ at echo off
+
+call "Set Avidemux 2.4 Environment Variables"
+if errorlevel 1 goto error
+
+set curDir=%CD%
+
+echo -- Generating Change Log.html --
+cd "..\..\installer"
+sh genlog.sh
+
+echo -- Generating Package Notes.html --
+cd "%curDir%\Tools"
+sh gennotes.sh
+
+echo -- Generating Touch Files.html --
+sh gentouch.sh
+
+echo -- Generating avidemux.pot --
+cd "%sourceDir%\po"
+sh update_pot.bash
+
+goto end
+
+:error
+set ERRORLEVEL=1
+
+:end
+pause
\ No newline at end of file

Added: branches/avidemux_2.4_branch/platforms/windows/build_scripts/avidemux_2.4/2b. Package Build.bat
===================================================================
--- branches/avidemux_2.4_branch/platforms/windows/build_scripts/avidemux_2.4/2b. Package Build.bat	2008-07-15 18:21:57 UTC (rev 4218)
+++ branches/avidemux_2.4_branch/platforms/windows/build_scripts/avidemux_2.4/2b. Package Build.bat	2008-07-16 01:19:49 UTC (rev 4219)
@@ -0,0 +1,32 @@
+ at echo off
+
+call "Set Avidemux 2.4 Environment Variables"
+
+cd Tools
+call "Get Revision Number"
+cd ..
+
+set curDir=%CD%
+set zipFile=avidemux_2.4_r%revisionNo%_win32.zip
+set exeFile=avidemux_2.4_r%revisionNo%_win32.exe
+set packageDir=%CD%\%revisionNo%
+
+echo %packageDir%
+mkdir %packageDir%
+
+copy "%buildDir%\Change Log.html" "%packageDir%"
+move "Tools\Package Notes.html" "%packageDir%"
+copy "%sourceDir%\po\avidemux.pot" "%packageDir%"
+
+cd %buildDir%
+zip -r "%packageDir%\%zipFile%" *
+cd %curDir%
+advzip -z -4 "%packageDir%\%zipFile%"
+
+echo -- Generating %exeFile% --
+echo !define BUILDDIR %buildDir% > "..\..\installer\builddir.nsh"
+"%nsisDir%\makensis" /V2 "..\..\installer\avidemux.nsi"
+
+move "..\..\installer\%exeFile%" "%packageDir%"
+
+pause
\ No newline at end of file

Added: branches/avidemux_2.4_branch/platforms/windows/build_scripts/avidemux_2.4/Package Notes.xml
===================================================================
--- branches/avidemux_2.4_branch/platforms/windows/build_scripts/avidemux_2.4/Package Notes.xml	2008-07-15 18:21:57 UTC (rev 4218)
+++ branches/avidemux_2.4_branch/platforms/windows/build_scripts/avidemux_2.4/Package Notes.xml	2008-07-16 01:19:49 UTC (rev 4219)
@@ -0,0 +1,328 @@
+<?xml version="1.0"?>
+<log>
+  <buildentry revision="4211" date="2008-07-13">
+    <comment>Updated GLib to version 2.16.4.</comment>
+    <comment>Updated GTK+ to version 2.12.11.</comment>
+    <comment>Updated Pango to version 1.20.5.</comment>
+    <comment>Updated x264 to r912 (patched).</comment>
+  </buildentry>  
+  <buildentry revision="4195 [2.4.2 Final]" date="2008-07-06">
+    <comment>Updated LAME to version 3.98.</comment>
+    <comment>Updated x264 to r899 (patched).</comment>
+  </buildentry>
+  <buildentry revision="4182" date="2008-06-30">
+  </buildentry>
+  <buildentry revision="4170" date="2008-06-27">
+  </buildentry>
+  <buildentry revision="4160" date="2008-06-25">
+    <comment>Updated x264 to r891 (patched).</comment>
+  </buildentry>
+  <buildentry revision="4145" date="2008-06-22">
+    <comment>Updated x264 to r889 (patched).</comment>
+  </buildentry>
+  <buildentry revision="4123" date="2008-06-18">
+  </buildentry>
+  <buildentry revision="4114" date="2008-06-17">
+    <comment>Updated Freetype to version 2.3.6.</comment>
+    <comment>Updated x264 to r886 (patched).</comment>
+  </buildentry>
+  <buildentry revision="4090" date="2008-06-12">
+    <comment>Updated GTK+ to version 2.12.10.</comment>
+    <comment>Updated x264 to r881, patched and compiled with MinGW GCC 4.2.1-sjlj-2.</comment>
+  </buildentry>
+  <buildentry revision="4081" date="2008-06-01">
+    <comment>Updated Cairo to version 1.6.4-2.</comment>
+    <comment>Updated libpng to version 1.2.29.</comment>
+    <comment>Updated Pango to version 1.20.3.</comment>
+  </buildentry>
+  <buildentry revision="4028" date="2008-05-14">
+    <comment>Updated Libxml2 to version 2.6.32+.</comment>
+    <comment>Updated Qt to version 4.4.0.</comment>
+    <comment>Updated x264 to r845.</comment>
+  </buildentry>
+  <buildentry revision="4017" date="2008-05-03">
+    <comment>Updated x264 to r839.</comment>
+  </buildentry>
+  <buildentry revision="3982" date="2008-04-24">
+    <comment>Updated Cairo to version 1.6.4-1.</comment>
+    <comment>Updated GLib to version 2.16.3.</comment>
+    <comment>Updated Pango to version 1.20.2.</comment>
+    <comment>Updated x264 to r828.</comment>
+  </buildentry>
+  <buildentry revision="3974" date="2008-04-10">
+    <comment>Updated GLib to version 2.16.2.</comment>
+    <comment>Updated x264 to r816.</comment>
+  </buildentry>
+  <buildentry revision="3947" date="2008-04-01">
+    <comment>Updated x264 to r808, compiled with Microsoft Visual C++ 6 SP5.</comment>
+  </buildentry>
+  <buildentry revision="3945" date="2008-03-30">
+    <comment>Updated win_iconv to version 20080320.</comment>
+    <comment>Updated x264 to r798, compiled with Microsoft Visual C++ 9.</comment>
+  </buildentry>
+  <buildentry revision="3908" date="2008-03-19">
+    <comment>Updated GTK+ to version 2.12.9.</comment>
+    <comment>Recompiled Aften 0.0.8 with Microsoft Visual C++ 9 (to enable SSE3).</comment>
+    <comment>Recompiled Avidemux and LAME with MinGW's GCC 4.2.1-sjlj-2.</comment>
+    <comment>Replaced libiconv with win_iconv (20080317).</comment>
+    <comment>Reverted x264 back to SVN revision 741.</comment>
+  </buildentry>
+  <buildentry revision="3872" date="2008-03-13">
+    <comment>Updated ATK to version 1.22.0.</comment>
+    <comment>Updated Avisynth Proxy GUI to version 2.04.</comment>
+    <comment>Updated Fontconfig to version 2.4.2 (20071015).</comment>
+    <comment>Updated GLib to version 2.16.1.</comment>
+    <comment>Updated Qt to version 4.3.4.</comment>
+    <comment>Updated Pango to version 1.20.0.</comment>
+    <comment>Updated x264 to SVN revision 745.</comment>
+  </buildentry>
+  <buildentry revision="3791 [2.4.1 Final]" date="2008-02-15">
+  </buildentry>
+  <buildentry revision="3789" date="2008-02-08">
+    <comment>Updated GLib to version 2.14.6-1.</comment>
+  </buildentry>
+  <buildentry revision="3784" date="2008-02-02">
+    <comment>Compiled CLI without SDL so output is directed to the console instead of log files.</comment>
+  </buildentry>
+  <buildentry revision="3779" date="2008-01-29">
+    <comment>Updated x264 to SVN revision 736.</comment>
+  </buildentry>
+  <buildentry revision="3775" date="2008-01-28">
+    <comment>Updated gettext to version 0.17-1.</comment>
+    <comment>Updated Libxml2 to version 2.6.30+.</comment>
+    <comment>Updated x264 to SVN revision 735.</comment>
+  </buildentry>
+  <buildentry revision="3764" date="2008-01-22">
+    <comment>Updated gettext to version 0.17.</comment>
+  </buildentry>
+  <buildentry revision="3756" date="2008-01-18">
+    <comment>Updated Cairo to version 1.4.14.</comment>
+    <comment>Updated GLib to version 2.14.5.</comment>
+    <comment>Updated Pango to version 1.18.4.</comment>
+    <comment>Updated SDL to version 1.2.13.</comment>
+    <comment>Updated x264 to SVN revision 721.</comment>
+  </buildentry>
+  <buildentry revision="3731 [2.4.0 Final]" date="2007-12-24">
+    <comment>Updated x264 to SVN revision 712.</comment>
+  </buildentry>
+  <buildentry revision="3728" date="2007-12-13">
+    <comment>Updated Qt to version 4.3.3.</comment>
+    <comment>Updated x264 to SVN revision 711.</comment>
+  </buildentry>
+  <buildentry revision="3718" date="2007-12-03">
+    <comment>Updated x264 to SVN revision 708.</comment>
+  </buildentry>
+  <buildentry revision="3707" date="2007-11-29">
+    <comment>Updated GLib to version 2.14.4.</comment>
+    <comment>Updated x264 to SVN revision 702.</comment>
+  </buildentry>
+  <buildentry revision="3699" date="2007-11-22">
+    <comment>Updated GLib to version 2.14.3.</comment>
+    <comment>Updated FAAD2 to version 2.6.1.</comment>
+    <comment>Updated x264 to SVN revision 700.</comment>
+  </buildentry>
+  <buildentry revision="3688 [2.4.0 Preview 3.1]" date="2007-11-12">
+    <comment>FAAC support was missing from the earlier preview 3 build.</comment>
+  </buildentry>
+  <buildentry revision="3688 [2.4.0 Preview 3]" date="2007-11-11">
+  </buildentry>
+  <buildentry revision="3676" date="2007-10-31">
+    <comment>Updated FAAC to version 1.26.</comment>
+    <comment>Updated FAAD2 to version 2.6.</comment>
+    <comment>Updated x264 to SVN revision 681.</comment>
+  </buildentry>
+  <buildentry revision="3665" date="2007-10-23">
+    <comment>Updated GLib to version 2.14.2.</comment>
+    <comment>Updated Pango to version 1.18.3.</comment>
+  </buildentry>
+  <buildentry revision="3658" date="2007-10-17">
+  </buildentry>
+  <buildentry revision="3639" date="2007-10-10">
+    <comment>Reverted GTK+ back to version 2.10.14 (due to reports of instability).</comment>
+  </buildentry>
+  <buildentry revision="3625" date="2007-10-07">
+    <comment>Updated Qt to version 4.3.2.</comment>
+  </buildentry>
+  <buildentry revision="3600" date="2007-09-26">
+    <comment>Updated Aften to version 0.0.8</comment>
+    <comment>Updated ATK to version 1.20.0.</comment>
+    <comment>Updated Cairo to version 1.4.10.</comment>
+    <comment>Updated GLib to version 2.14.1.</comment>
+    <comment>Updated GTK+ to version 2.12.0.</comment>
+    <comment>Updated Libxml2 to 2.6.30.</comment>
+    <comment>Updated Pango to version 1.18.2.</comment>
+    <comment>Updated SDL to version 1.2.12.</comment>
+    <comment>Updated x264 to SVN revision 680.</comment>
+  </buildentry>
+  <buildentry revision="3591" date="2007-09-22">
+    <comment>Updated x264 to SVN revision 677.</comment>
+  </buildentry>
+  <buildentry revision="3587" date="2007-09-11">
+    <comment>Updated x264 to SVN revision 674.</comment>
+  </buildentry>
+  <buildentry revision="3579" date="2007-09-05">
+  </buildentry>
+  <buildentry revision="3570" date="2007-08-31">
+  </buildentry>
+  <buildentry revision="3563" date="2007-08-26">
+  </buildentry>
+  <buildentry revision="3553" date="2007-08-23">
+  </buildentry>
+  <buildentry revision="3535" date="2007-08-19">
+  </buildentry>
+  <buildentry revision="3516" date="2007-08-16">
+    <comment>Updated Freetype to version 2.3.5.</comment>
+    <comment>Updated GLib to version 2.14.0.</comment>
+  </buildentry>
+  <buildentry revision="3500" date="2007-08-13">
+    <comment>Updated Qt to version 4.3.1.</comment>
+  </buildentry>
+  <buildentry revision="3488" date="2007-08-08">
+  </buildentry>
+  <buildentry revision="3475" date="2007-08-05">
+    <comment>Updated GTK+ to version 2.10.14.</comment>
+  </buildentry>
+  <buildentry revision="3465" date="2007-08-01">
+    <comment>Packaged using NSIS 2.29.</comment>
+  </buildentry>
+  <buildentry revision="3451" date="2007-07-28">
+    <comment>Updated GLib to version 2.12.13.</comment>
+    <comment>Updated Xvid to CVS HEAD 2007-07-26.</comment>
+    <comment>Updated Vorbis to version 1.2.0.</comment>
+  </buildentry>
+  <buildentry revision="3441" date="2007-07-24">
+    <comment>Updated GCC to version 4.2.1.</comment>
+  </buildentry>
+  <buildentry revision="3412" date="2007-07-18">
+    <comment>Updated x264 to SVN revision 667.</comment>
+  </buildentry>
+  <buildentry revision="3374" date="2007-07-16">
+  </buildentry>
+  <buildentry revision="3364" date="2007-07-14">
+  </buildentry>
+  <buildentry revision="3353" date="2007-07-10">
+    <comment>Updated GCC to version 4.2.0 again.</comment>
+  </buildentry>
+  <buildentry revision="3342" date="2007-07-08">
+  </buildentry>
+  <buildentry revision="3332" date="2007-07-06">
+    <comment>Updated x264 to SVN revision 663.</comment>
+    <comment>Updated Xvid to CVS HEAD 2007-06-28.</comment>
+  </buildentry>
+  <buildentry revision="3322 [2.4.0 Preview 2]" date="2007-06-30">
+    <comment>Reverted GCC back to version 4.1.2 (due to video issues).</comment>
+  </buildentry>
+  <buildentry revision="3317" date="2007-06-28">
+    <comment>Updated Xvid to CVS HEAD 2007-06-27.</comment>
+    <comment>Reverted GTK+ back to version 2.10.9 (due to reports of instability).</comment>
+  </buildentry>
+  <buildentry revision="3310" date="2007-06-26">
+  </buildentry>
+  <buildentry revision="3294" date="2007-06-24">
+    <comment>Updated Freetype to version 2.3.4.</comment>
+    <comment>Updated Libxml2 to version 2.6.28.</comment>
+    <comment>Updated x264 to SVN revision 662.</comment>
+    <comment>Recompiled Aften 0.07 with Microsoft Visual C++ 8 (to fix SSE2 threading issue).</comment>
+  </buildentry>
+  <buildentry revision="3283" date="2007-06-21">
+    <comment>Updated x264 to SVN revision 661.</comment>
+  </buildentry>
+  <buildentry revision="3273" date="2007-06-18">
+  </buildentry>
+  <buildentry revision="3253" date="2007-06-15">
+    <comment>Updated GCC to version 4.2.0 (also recompiled LAME).</comment>
+    <comment>Updated Aften to version 0.07 (R522 to fix GCC alignment issue).</comment>
+    <comment>Updated Cairo to version 1.4.8.</comment>
+    <comment>Updated Fontconfig to version 2.4.2.</comment>
+    <comment>Updated GLib to version 2.12.12.</comment>
+    <comment>Updated GTK+ to version 2.10.13.</comment>
+    <comment>Updated Pango to version 1.16.4.</comment>
+    <comment>Updated Qt to version 4.3.0.</comment>
+    <comment>Updated x264 to SVN revision 659.</comment>
+    <comment>Updated Xvid to CVS HEAD 2007-06-03.</comment>
+    <comment>Avidemux was built using new CMake scripts.</comment>
+    <comment>Packaged using NSIS 2.28.</comment>
+  </buildentry>
+  <buildentry revision="3140" date="2007-05-25">
+  </buildentry>
+  <buildentry revision="3124" date="2007-05-22">
+  </buildentry>
+  <buildentry revision="3110" date="2007-05-18">
+  </buildentry>
+  <buildentry revision="3099" date="2007-05-16">
+  </buildentry>
+  <buildentry revision="3086" date="2007-05-14">
+  </buildentry>
+  <buildentry revision="3070" date="2007-05-13">
+  </buildentry>
+  <buildentry revision="3059" date="2007-05-10">
+  </buildentry>
+  <buildentry revision="3048" date="2007-05-09">
+  </buildentry>
+  <buildentry revision="3040" date="2007-05-07">
+    <comment>Updated Avisynth Proxy GUI to 2007-05-04.</comment>
+    <comment>Removed ADM Tools.</comment>
+    <comment>Installer now prompts to remove previous version before installing.</comment>
+  </buildentry>
+  <buildentry revision="3015" date="2007-05-04">
+    <comment>Updated x264 to SVN revision 655.</comment>
+    <comment>Updated Avisynth Proxy GUI to 2007-05-02.</comment>
+    <comment>Installer now adds Avisynth Proxy GUI to Start Menu.</comment>
+  </buildentry>
+  <buildentry revision="3003" date="2007-05-02">
+    <comment>Added Avisynth Proxy GUI to Installer.</comment>
+  </buildentry>
+  <buildentry revision="2994" date="2007-04-30">
+    <comment>Updated Xvid to CVS HEAD 2007-04-29.</comment>
+    <comment>Added Avisynth Proxy to Installer.</comment>
+  </buildentry>
+  <buildentry revision="2975" date="2007-04-27">
+  </buildentry>
+  <buildentry revision="2960" date="2007-04-24">
+    <comment>Updated x264 to SVN revision 654.</comment>
+    <comment>Added GTK translations to installer.  Standard GTK windows (e.g. Open and Save) are now correctly translated.</comment>
+    <comment>The Installer now prohibits ADM Tools from being installed if the GTK+ user interface isn't also chosen.</comment>
+  </buildentry>
+  <buildentry revision="2955" date="2007-04-23">
+    <comment>Updated x264 to SVN revision 652.</comment>
+    <comment>Updated ADM Tools to 2007-04-20.</comment>
+    <comment>Installer now remembers previous installation folder (thanks LoRd_MuldeR).</comment>
+    <comment>Translations now work when starting Avidemux via the shortcuts created by the Installer (thanks Tetsuro).</comment>
+  </buildentry>
+  <buildentry revision="2953" date="2007-04-19">
+  </buildentry>
+  <buildentry revision="2951" date="2007-04-20">
+    <comment>Updated Xvid to CVS HEAD 2007-04-17.</comment>
+    <comment>Updated ADM Tools to 2007-04-18.</comment>
+  </buildentry>
+  <buildentry revision="2948" date="2007-04-17">
+  </buildentry>
+  <buildentry revision="2945" date="2007-04-15">
+    <comment>A bug in the Avidemux configure script prevented full compiler optimisations from being enabled. This has now been rectified, which means the main Avidemux executables are larger but hopefully faster in certain areas.</comment>
+    <comment>The installer now uses improved compression so the file size is smaller than the last release.</comment>
+    <comment>Included ADM Tools.</comment>
+  </buildentry>
+  <buildentry revision="2934" date="2007-04-13">
+    <comment>Updated x264 to SVN revision 650.</comment>
+    <comment>Introduced a new installer.</comment>
+  </buildentry>
+  <buildentry revision="2926 [Release 2]" date="2007-04-11">
+    <comment>Updated x264 to SVN revision 649.</comment>
+    <comment>
+      FAAC and FAAD2 have been rebuilt. Prior builds incorrectly included DRM versions
+      of both libraries, which aren't appropriate for Avidemux.
+    </comment>
+  </buildentry>
+  <buildentry revision="2926" date="2007-04-07">
+    <comment>Updated Aften to version 0.06</comment>
+    <comment>Updated x264 to SVN revision 648.</comment>
+  </buildentry>
+  <buildentry revision="2922" date="2007-04-05">
+    <comment>Updated x264 to SVN revision 641.</comment>
+  </buildentry>
+  <buildentry revision="2916" date="2007-04-02">
+    <comment>Updated x264 to SVN revision 636.</comment>
+  </buildentry>
+  <buildentry revision="2910" date="2007-03-29">
+  </buildentry>
+</log>

Added: branches/avidemux_2.4_branch/platforms/windows/build_scripts/avidemux_2.4/Set Avidemux 2.4 Environment Variables.bat
===================================================================
--- branches/avidemux_2.4_branch/platforms/windows/build_scripts/avidemux_2.4/Set Avidemux 2.4 Environment Variables.bat	2008-07-15 18:21:57 UTC (rev 4218)
+++ branches/avidemux_2.4_branch/platforms/windows/build_scripts/avidemux_2.4/Set Avidemux 2.4 Environment Variables.bat	2008-07-16 01:19:49 UTC (rev 4219)
@@ -0,0 +1,50 @@
+call "..\Set Common Environment Variables"
+
+if errorlevel 1 goto error
+
+zip > NUL 2> NUL
+if errorlevel 1 (
+	echo Info-ZIP could not be found in the PATH.  Please download from http://www.info-zip.org
+	goto error
+)
+
+advzip > NUL 2> NUL
+if errorlevel 1 (
+	echo AdvanceCOMP could not be found in the PATH.  Please download from http://advancemame.sourceforge.net
+	goto error
+)
+
+svn help > NUL 2> NUL
+if errorlevel 1 (
+	echo Subversion could not be found in the PATH.  Please download from http://subversion.tigris.org/
+	goto error
+)
+
+xsltproc --version > NUL 2> NUL
+if errorlevel 1 (
+	echo xsltproc could not be found in the PATH.  Please download from http://www.zlatkovic.com
+	goto error
+)
+
+set buildDir=%devDir%\avidemux_2.4_build
+set curDir=%CD%
+cd ..\..\..\..
+set sourceDir=%CD%
+cd "%curDir%"
+
+if not exist "%buildDir%" (
+	echo Build directory could not be found at "%buildDir%".
+	goto error
+)
+
+if not exist "%sourceDir%" (
+	echo Source directory could not be found at "%sourceDir%".
+	goto error
+)
+
+goto end
+
+:error
+set ERRORLEVEL=1
+
+:end
\ No newline at end of file

Added: branches/avidemux_2.4_branch/platforms/windows/build_scripts/avidemux_2.4/Tools/Get Revision Number.bat
===================================================================
--- branches/avidemux_2.4_branch/platforms/windows/build_scripts/avidemux_2.4/Tools/Get Revision Number.bat	2008-07-15 18:21:57 UTC (rev 4218)
+++ branches/avidemux_2.4_branch/platforms/windows/build_scripts/avidemux_2.4/Tools/Get Revision Number.bat	2008-07-16 01:19:49 UTC (rev 4219)
@@ -0,0 +1,10 @@
+if not exist "..\..\..\installer\revision.nsh" goto end
+
+copy "Revision No template.bat" + "..\..\..\installer\revision.nsh" temp.bat > NUL
+
+call temp.bat
+del temp.bat
+
+set revisionNo=%revisionNo:~17,4%
+
+:end
\ No newline at end of file

Added: branches/avidemux_2.4_branch/platforms/windows/build_scripts/avidemux_2.4/Tools/Revision No template.bat
===================================================================
--- branches/avidemux_2.4_branch/platforms/windows/build_scripts/avidemux_2.4/Tools/Revision No template.bat	2008-07-15 18:21:57 UTC (rev 4218)
+++ branches/avidemux_2.4_branch/platforms/windows/build_scripts/avidemux_2.4/Tools/Revision No template.bat	2008-07-16 01:19:49 UTC (rev 4219)
@@ -0,0 +1 @@
+set revisionNo=
\ No newline at end of file

Added: branches/avidemux_2.4_branch/platforms/windows/build_scripts/avidemux_2.4/Tools/gennotes.sh
===================================================================
--- branches/avidemux_2.4_branch/platforms/windows/build_scripts/avidemux_2.4/Tools/gennotes.sh	2008-07-15 18:21:57 UTC (rev 4218)
+++ branches/avidemux_2.4_branch/platforms/windows/build_scripts/avidemux_2.4/Tools/gennotes.sh	2008-07-16 01:19:49 UTC (rev 4219)
@@ -0,0 +1 @@
+xsltproc package_notes.xslt "../Package Notes.xml" > "Package Notes.html"
\ No newline at end of file

Added: branches/avidemux_2.4_branch/platforms/windows/build_scripts/avidemux_2.4/Tools/gentouch.sh
===================================================================
--- branches/avidemux_2.4_branch/platforms/windows/build_scripts/avidemux_2.4/Tools/gentouch.sh	2008-07-15 18:21:57 UTC (rev 4218)
+++ branches/avidemux_2.4_branch/platforms/windows/build_scripts/avidemux_2.4/Tools/gentouch.sh	2008-07-16 01:19:49 UTC (rev 4219)
@@ -0,0 +1 @@
+xsltproc touch_files.xslt "../Package Notes.xml" > "../Touch 2.4 Files.html"
\ No newline at end of file

Added: branches/avidemux_2.4_branch/platforms/windows/build_scripts/avidemux_2.4/Tools/package_notes.xslt
===================================================================
--- branches/avidemux_2.4_branch/platforms/windows/build_scripts/avidemux_2.4/Tools/package_notes.xslt	2008-07-15 18:21:57 UTC (rev 4218)
+++ branches/avidemux_2.4_branch/platforms/windows/build_scripts/avidemux_2.4/Tools/package_notes.xslt	2008-07-16 01:19:49 UTC (rev 4219)
@@ -0,0 +1,127 @@
+<?xml version="1.0" encoding="utf-8"?>
+
+<xsl:stylesheet version="1.0"
+    xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
+  <xsl:output method="html" indent="yes" />
+
+  <xsl:template match="log">
+    <html>
+      <head>
+        <meta content="text/html; charset=ISO-8859-1" http-equiv="content-type" />
+        <style type="text/css">
+          body {
+          margin: 10px 15px 0px 15px;
+          height: 100%;
+          font-size: 82%;
+          }
+
+          h1 {
+          padding: 0;
+          font-family: Helvetica,Arial,sans-serif;
+          font-size: 1.7em;
+          font-weight: bold;
+          color: #1B57B1;
+          vertical-align: bottom;
+          text-align: center;
+          width: 100%;
+          }
+
+          div, p, table, td, th {
+          font-family: Tahoma,Helvetica,Arial,sans-serif;
+          font-size: 1em;
+          color: #333;
+          }
+
+          table.build {
+          border-collapse: collapse;
+          border: 1px solid #ccc;
+          }
+
+          table.build td, table.roadmap th {
+          border: 1px solid #ccc;
+          }
+
+          table.build th {
+          background: #ddd;
+          padding: 5px;
+          }
+
+          table.build td {
+          background: #f7f7f7;
+          padding-left: 15px;
+          padding-right: 15px;
+          padding-top: 5px;
+          padding-bottom: 5px;
+          }
+        </style>
+        <title>Avidemux 2.4 Win32 Package Notes</title>
+      </head>
+      <body>
+        <h1>Avidemux 2.4 Win32 Package Notes</h1>
+        <div>
+          <xsl:apply-templates select="buildentry" />
+        </div>
+      </body>
+    </html>
+  </xsl:template>
+
+  <xsl:template match="buildentry">
+    <p>
+      <b>
+        <xsl:text>Revision&#160;</xsl:text>
+        <xsl:value-of select="@revision"/>
+      </b>
+      <xsl:text>&#160;(</xsl:text>
+      <xsl:call-template name="FormatDate">
+        <xsl:with-param name="Date" select="@date" />
+      </xsl:call-template>
+      <xsl:text>)</xsl:text>
+      <br/>
+
+      <xsl:for-each select="comment">
+        <li>
+          <xsl:value-of select="."/>
+        </li>
+      </xsl:for-each>
+    </p>
+  </xsl:template>
+
+  <xsl:template name="FormatDate">
+    <xsl:param name="Date"/>
+
+    <!-- Day -->
+    <xsl:value-of select="substring($Date, 9, 2)" />
+    <xsl:text>&#160;</xsl:text>
+
+    <!-- Month -->
+    <xsl:call-template name="FormatMonth">
+      <xsl:with-param name="Month" select="substring($Date, 6, 2)" />
+    </xsl:call-template>
+    <xsl:text>&#160;</xsl:text>
+
+    <!-- Year -->
+    <xsl:value-of select="substring($Date, 1, 4)"/>
+    <!-- <xsl:text>&#160;</xsl:text>-->
+
+    <!-- Time -->
+    <!-- <xsl:value-of select="substring($Date, 12, 8)"/>-->
+  </xsl:template>
+
+  <xsl:template name="FormatMonth">
+    <xsl:param name="Month"/>
+    <xsl:choose>
+      <xsl:when test="$Month = '01'">Jan</xsl:when>
+      <xsl:when test="$Month = '02'">Feb</xsl:when>
+      <xsl:when test="$Month = '03'">Mar</xsl:when>
+      <xsl:when test="$Month = '04'">Apr</xsl:when>
+      <xsl:when test="$Month = '05'">May</xsl:when>
+      <xsl:when test="$Month = '06'">Jun</xsl:when>
+      <xsl:when test="$Month = '07'">Jul</xsl:when>
+      <xsl:when test="$Month = '08'">Aug</xsl:when>
+      <xsl:when test="$Month = '09'">Sep</xsl:when>
+      <xsl:when test="$Month = '10'">Oct</xsl:when>
+      <xsl:when test="$Month = '11'">Nov</xsl:when>
+      <xsl:when test="$Month = '12'">Dec</xsl:when>
+    </xsl:choose>
+  </xsl:template>
+</xsl:stylesheet>
\ No newline at end of file

Added: branches/avidemux_2.4_branch/platforms/windows/build_scripts/avidemux_2.4/Tools/touch_files.xslt
===================================================================
--- branches/avidemux_2.4_branch/platforms/windows/build_scripts/avidemux_2.4/Tools/touch_files.xslt	2008-07-15 18:21:57 UTC (rev 4218)
+++ branches/avidemux_2.4_branch/platforms/windows/build_scripts/avidemux_2.4/Tools/touch_files.xslt	2008-07-16 01:19:49 UTC (rev 4219)
@@ -0,0 +1,152 @@
+<xsl:stylesheet version="1.0"
+    xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
+  <xsl:output method="html" indent="yes" />
+
+  <xsl:template match="/">
+    <xsl:text disable-output-escaping="yes">&lt;?php
+      function touchDirContents($path, $time)
+      {
+        $dirHandle = opendir($path);
+
+        while (($resource = readdir($dirHandle)) != false)
+        {
+          if (is_file($path . "/" . $resource))
+          {
+            touch($path . "/" . $resource, $time);
+          }
+        }
+
+        closedir($dirHandle);
+      }
+      </xsl:text>
+    <xsl:apply-templates select="log" />
+    <xsl:text disable-output-escaping="yes">?&gt;</xsl:text>
+  </xsl:template>
+
+  <xsl:template match="log" mode="php">
+    <script language="php">
+      <xsl:apply-templates select="buildentry" />
+    </script>
+  </xsl:template>
+
+  <xsl:template match="buildentry">
+    <xsl:variable name="fileName">
+      <xsl:call-template name="getFileName">
+        <xsl:with-param name="revision" select="@revision" />
+      </xsl:call-template>
+    </xsl:variable>
+    <xsl:variable name="day">
+      <xsl:call-template name="getDay">
+        <xsl:with-param name="date" select="@date" />
+      </xsl:call-template>
+    </xsl:variable>
+    <xsl:variable name="month">
+      <xsl:call-template name="getMonth">
+        <xsl:with-param name="date" select="@date" />
+      </xsl:call-template>
+    </xsl:variable>
+    <xsl:variable name="year">
+      <xsl:call-template name="getYear">
+        <xsl:with-param name="date" select="@date" />
+      </xsl:call-template>
+    </xsl:variable>
+
+    <xsl:text>touch("</xsl:text>
+    <xsl:value-of select="$fileName" />
+    <xsl:text>", mktime(0, 0, 0, </xsl:text>
+    <xsl:value-of select="$month" />
+    <xsl:text>, </xsl:text>
+    <xsl:value-of select="$day" />
+    <xsl:text>, </xsl:text>
+    <xsl:value-of select="$year" />
+    <xsl:text>)); </xsl:text>
+
+    <xsl:text>touchDirContents("</xsl:text>
+    <xsl:value-of select="$fileName" />
+    <xsl:text>", mktime(0, 0, 0, </xsl:text>
+    <xsl:value-of select="$month" />
+    <xsl:text>, </xsl:text>
+    <xsl:value-of select="$day" />
+    <xsl:text>, </xsl:text>
+    <xsl:value-of select="$year" />
+    <xsl:text>)); </xsl:text>
+  </xsl:template>
+
+  <xsl:template name='getDay'>
+    <xsl:param name='date' />
+    <xsl:variable name="day" select="substring(@date, 9, 2)"/>
+    <xsl:choose>
+      <xsl:when test="starts-with($day, '0')">
+        <xsl:value-of select="substring($day, 2)" />
+      </xsl:when>
+      <xsl:otherwise>
+        <xsl:value-of select="$day" />
+      </xsl:otherwise>
+    </xsl:choose>
+  </xsl:template>
+
+  <xsl:template name='getMonth'>
+    <xsl:param name='date' />
+    <xsl:variable name="month" select="substring(@date, 6, 2)"/>
+    <xsl:choose>
+      <xsl:when test="starts-with($month, '0')">
+        <xsl:value-of select="substring($month, 2)" />
+      </xsl:when>
+      <xsl:otherwise>
+        <xsl:value-of select="$month" />
+      </xsl:otherwise>
+    </xsl:choose>
+  </xsl:template>
+
+  <xsl:template name='getYear'>
+    <xsl:param name='date' />
+    <xsl:value-of select="substring(@date, 1, 4)"/>
+  </xsl:template>
+
+  <xsl:template name='getFileName'>
+    <xsl:param name='revision' />
+
+    <xsl:text>2.4/</xsl:text>
+
+    <xsl:choose>
+      <xsl:when test="contains($revision, 'Final')">
+        <xsl:text>Milestone/</xsl:text>
+        <xsl:variable name="version" select="substring-after($revision, ' [')"/>
+        <xsl:value-of select="substring-before($version, ' ')" />
+        <xsl:text>_(</xsl:text>
+        <xsl:value-of select="substring-before($revision, ' [')" />
+        <xsl:text>)</xsl:text>
+      </xsl:when>
+      <xsl:otherwise>
+        <xsl:text>SVN/</xsl:text>
+        <xsl:choose>
+          <xsl:when test="contains($revision, 'Preview')">
+            <xsl:variable name="version" select="substring-after($revision, ' [')"/>
+            <xsl:variable name="minorVersion" select="substring-after($version, ' ')"/>
+            <xsl:value-of select="substring-before($revision, ' [')"/>
+            <xsl:text>_</xsl:text>
+            <xsl:call-template name="convertToLower">
+              <xsl:with-param name="toconvert" select="translate(substring-before($minorVersion, ']'), ' ', '_')" />
+            </xsl:call-template>
+          </xsl:when>
+          <xsl:when test="contains($revision, 'Release')">
+            <xsl:value-of select="substring-before($revision, ' [')" />
+            <xsl:text>_r</xsl:text>
+            <xsl:variable name="version" select="substring-after($revision, ' [Release ')"/>
+            <xsl:value-of select="substring-before($version, ']')" />
+          </xsl:when>
+          <xsl:otherwise>
+            <xsl:value-of select="$revision"/>
+          </xsl:otherwise>
+        </xsl:choose>
+      </xsl:otherwise>
+    </xsl:choose>
+  </xsl:template>
+
+  <xsl:template name='convertToLower'>
+    <xsl:param name='toconvert' />
+    <xsl:variable name="lcletters">abcdefghijklmnopqrstuvwxyz</xsl:variable>
+    <xsl:variable name="ucletters">ABCDEFGHIJKLMNOPQRSTUVWXYZ</xsl:variable>
+    <xsl:value-of select="translate($toconvert,$ucletters,$lcletters)" />
+  </xsl:template>
+</xsl:stylesheet>
\ No newline at end of file

Copied: branches/avidemux_2.4_branch/platforms/windows/installer (from rev 4218, branches/avidemux_2.4_branch/avidemux/winInstaller)


Property changes on: branches/avidemux_2.4_branch/platforms/windows/installer
___________________________________________________________________
Name: svn:mergeinfo
   + 

Modified: branches/avidemux_2.4_branch/platforms/windows/installer/avidemux.nsi
===================================================================
--- branches/avidemux_2.4_branch/avidemux/winInstaller/avidemux.nsi	2008-07-15 18:21:57 UTC (rev 4218)
+++ branches/avidemux_2.4_branch/platforms/windows/installer/avidemux.nsi	2008-07-16 01:19:49 UTC (rev 4219)
@@ -5,6 +5,7 @@
 !include MUI.nsh
 !include WinMessages.nsh
 !include revision.nsh
+!include builddir.nsh
 
 Name "Avidemux 2.4.2 r${REVISION}"
 
@@ -36,7 +37,7 @@
 !define MUI_STARTMENUPAGE_DEFAULTFOLDER Avidemux
 !define MUI_STARTMENUPAGE_NODISABLE
 !define MUI_WELCOMEFINISHPAGE_BITMAP "WelcomeFinishStrip.bmp"
-!define MUI_UNICON "..\xpm\adm.ico"
+!define MUI_UNICON "..\..\..\avidemux\xpm\adm.ico"
 !define MUI_UNFINISHPAGE_NOAUTOCLOSE
 !define MUI_COMPONENTSPAGE_NODESC
 
@@ -115,8 +116,8 @@
 
 installGtk${LANG_CODE}:
     SetOutPath $INSTDIR\share\locale\${LANG_CODE}\LC_MESSAGES
-    File ..\..\..\avidemux_2.4_build\share\locale\${LANG_CODE}\LC_MESSAGES\avidemux.mo
-    File ..\..\..\avidemux_2.4_build\share\locale\${LANG_CODE}\LC_MESSAGES\gtk20.mo
+    File ${BUILDDIR}\share\locale\${LANG_CODE}\LC_MESSAGES\avidemux.mo
+    File ${BUILDDIR}\share\locale\${LANG_CODE}\LC_MESSAGES\gtk20.mo
 
     WriteRegStr HKLM "${REGKEY}\Components" ${LANG_NAME} 1
 endGtk${LANG_CODE}:
@@ -129,8 +130,8 @@
 
 installQt4${LANG_CODE}:	
 	SetOutPath $INSTDIR\i18n
-    File ..\..\..\avidemux_2.4_build\i18n\avidemux_${LANG_CODE}.qm
-    File ..\..\..\avidemux_2.4_build\i18n\qt_${LANG_CODE}.qm
+    File ${BUILDDIR}\i18n\avidemux_${LANG_CODE}.qm
+    File ${BUILDDIR}\i18n\qt_${LANG_CODE}.qm
     
     WriteRegStr HKLM "${REGKEY}\Components" ${LANG_NAME} 1
 endQt4${LANG_CODE}:    
@@ -164,31 +165,31 @@
     SectionIn 1 2 RO
     SetOutPath $INSTDIR
     SetOverwrite on
-    File "..\..\..\avidemux_2.4_build\Build Info.txt"
-    File "..\..\..\avidemux_2.4_build\Change Log.html"
-    File ..\..\..\avidemux_2.4_build\zlib1.dll
-    File ..\..\..\avidemux_2.4_build\freetype6.dll
-    File ..\..\..\avidemux_2.4_build\iconv.dll
-    File ..\..\..\avidemux_2.4_build\intl.dll
-    File ..\..\..\avidemux_2.4_build\libaften.dll
-    File ..\..\..\avidemux_2.4_build\libexpat.dll
-    File ..\..\..\avidemux_2.4_build\libfaac.dll
-    File ..\..\..\avidemux_2.4_build\libfaad2.dll
-    File ..\..\..\avidemux_2.4_build\libfontconfig-1.dll
-    File ..\..\..\avidemux_2.4_build\libglib-2.0-0.dll
-    File ..\..\..\avidemux_2.4_build\libmp3lame-0.dll
-    File ..\..\..\avidemux_2.4_build\libpng12-0.dll
-    File ..\..\..\avidemux_2.4_build\libx264.dll
-    File ..\..\..\avidemux_2.4_build\libxml2.dll
-    File ..\..\..\avidemux_2.4_build\ogg.dll
-    File ..\..\..\avidemux_2.4_build\pthreadGC2.dll
-    File ..\..\..\avidemux_2.4_build\SDL.dll
-    File ..\..\..\avidemux_2.4_build\vorbis.dll
-    File ..\..\..\avidemux_2.4_build\vorbisenc.dll
-    File ..\..\..\avidemux_2.4_build\xmltok.dll
-    File ..\..\..\avidemux_2.4_build\xvidcore.dll
+    File "${BUILDDIR}\Build Info.txt"
+    File "${BUILDDIR}\Change Log.html"
+    File ${BUILDDIR}\zlib1.dll
+    File ${BUILDDIR}\freetype6.dll
+    File ${BUILDDIR}\iconv.dll
+    File ${BUILDDIR}\intl.dll
+    File ${BUILDDIR}\libaften.dll
+    File ${BUILDDIR}\libexpat.dll
+    File ${BUILDDIR}\libfaac.dll
+    File ${BUILDDIR}\libfaad2.dll
+    File ${BUILDDIR}\libfontconfig-1.dll
+    File ${BUILDDIR}\libglib-2.0-0.dll
+    File ${BUILDDIR}\libmp3lame-0.dll
+    File ${BUILDDIR}\libpng12-0.dll
+    File ${BUILDDIR}\libx264.dll
+    File ${BUILDDIR}\libxml2.dll
+    File ${BUILDDIR}\ogg.dll
+    File ${BUILDDIR}\pthreadGC2.dll
+    File ${BUILDDIR}\SDL.dll
+    File ${BUILDDIR}\vorbis.dll
+    File ${BUILDDIR}\vorbisenc.dll
+    File ${BUILDDIR}\xmltok.dll
+    File ${BUILDDIR}\xvidcore.dll
     SetOutPath $INSTDIR\etc\fonts
-    File /r ..\..\..\avidemux_2.4_build\etc\fonts\*
+    File /r ${BUILDDIR}\etc\fonts\*
 
     # if $PROFILE\avidemux exists and $APPDATA\avidemux doesn't, then move it
     IfFileExists "$PROFILE\avidemux" 0 end
@@ -205,7 +206,7 @@
         SectionIn 1 2
         SetOutPath $INSTDIR
         SetOverwrite on
-        File ..\..\..\avidemux_2.4_build\avidemux2_cli.exe
+        File ${BUILDDIR}\avidemux2_cli.exe
         WriteRegStr HKLM "${REGKEY}\Components" "Command line" 1
     SectionEnd
 
@@ -213,27 +214,27 @@
         SectionIn 1 2
         SetOverwrite on
         SetOutPath $INSTDIR\etc\gtk-2.0
-        File /r ..\..\..\avidemux_2.4_build\etc\gtk-2.0\*
+        File /r ${BUILDDIR}\etc\gtk-2.0\*
         SetOutPath $INSTDIR\etc\pango
-        File /r ..\..\..\avidemux_2.4_build\etc\pango\*
+        File /r ${BUILDDIR}\etc\pango\*
         SetOutPath $INSTDIR\lib\gtk-2.0
-        File /r ..\..\..\avidemux_2.4_build\lib\gtk-2.0\*
+        File /r ${BUILDDIR}\lib\gtk-2.0\*
         SetOutPath $INSTDIR\share\themes
-        File /r ..\..\..\avidemux_2.4_build\share\themes\*
+        File /r ${BUILDDIR}\share\themes\*
         SetOutPath $INSTDIR
-        File ..\..\..\avidemux_2.4_build\avidemux2_gtk.exe
-        File ..\..\..\avidemux_2.4_build\gtk2_prefs.exe
-        File ..\..\..\avidemux_2.4_build\libatk-1.0-0.dll
-        File ..\..\..\avidemux_2.4_build\libcairo-2.dll
-        File ..\..\..\avidemux_2.4_build\libgdk_pixbuf-2.0-0.dll
-        File ..\..\..\avidemux_2.4_build\libgdk-win32-2.0-0.dll
-        File ..\..\..\avidemux_2.4_build\libgmodule-2.0-0.dll
-        File ..\..\..\avidemux_2.4_build\libgobject-2.0-0.dll
-        File ..\..\..\avidemux_2.4_build\libgthread-2.0-0.dll
-        File ..\..\..\avidemux_2.4_build\libgtk-win32-2.0-0.dll
-        File ..\..\..\avidemux_2.4_build\libpango-1.0-0.dll
-        File ..\..\..\avidemux_2.4_build\libpangocairo-1.0-0.dll
-        File ..\..\..\avidemux_2.4_build\libpangowin32-1.0-0.dll
+        File ${BUILDDIR}\avidemux2_gtk.exe
+        File ${BUILDDIR}\gtk2_prefs.exe
+        File ${BUILDDIR}\libatk-1.0-0.dll
+        File ${BUILDDIR}\libcairo-2.dll
+        File ${BUILDDIR}\libgdk_pixbuf-2.0-0.dll
+        File ${BUILDDIR}\libgdk-win32-2.0-0.dll
+        File ${BUILDDIR}\libgmodule-2.0-0.dll
+        File ${BUILDDIR}\libgobject-2.0-0.dll
+        File ${BUILDDIR}\libgthread-2.0-0.dll
+        File ${BUILDDIR}\libgtk-win32-2.0-0.dll
+        File ${BUILDDIR}\libpango-1.0-0.dll
+        File ${BUILDDIR}\libpangocairo-1.0-0.dll
+        File ${BUILDDIR}\libpangowin32-1.0-0.dll
         WriteRegStr HKLM "${REGKEY}\Components" GTK+ 1
     SectionEnd
     
@@ -241,10 +242,10 @@
         SectionIn 2
         SetOutPath $INSTDIR
         SetOverwrite on
-        File ..\..\..\avidemux_2.4_build\QtGui4.dll
-        File ..\..\..\avidemux_2.4_build\avidemux2_qt4.exe
-        File ..\..\..\avidemux_2.4_build\mingwm10.dll
-        File ..\..\..\avidemux_2.4_build\QtCore4.dll
+        File ${BUILDDIR}\QtGui4.dll
+        File ${BUILDDIR}\avidemux2_qt4.exe
+        File ${BUILDDIR}\mingwm10.dll
+        File ${BUILDDIR}\QtCore4.dll
         WriteRegStr HKLM "${REGKEY}\Components" Qt4 1
     SectionEnd    
 SectionGroupEnd
@@ -317,8 +318,8 @@
     SectionIn 2
     SetOutPath $INSTDIR
     SetOverwrite on
-    File /r ..\..\..\avidemux_2.4_build\avsproxy.exe
-    File /r ..\..\..\avidemux_2.4_build\avsproxy_gui.exe
+    File /r ${BUILDDIR}\avsproxy.exe
+    File /r ${BUILDDIR}\avsproxy_gui.exe
     WriteRegStr HKLM "${REGKEY}\Components" "AvsProxy" 1
 SectionEnd
 
@@ -326,7 +327,7 @@
     SectionIn 2
     SetOutPath $INSTDIR\plugin
     SetOverwrite on
-    File /r ..\..\..\avidemux_2.4_build\plugin\*
+    File /r ${BUILDDIR}\plugin\*
     WriteRegStr HKLM "${REGKEY}\Components" "Sample external filter" 1
 SectionEnd
 

Modified: branches/avidemux_2.4_branch/platforms/windows/installer/genlog.sh
===================================================================
--- branches/avidemux_2.4_branch/avidemux/winInstaller/genlog.sh	2008-07-15 18:21:57 UTC (rev 4218)
+++ branches/avidemux_2.4_branch/platforms/windows/installer/genlog.sh	2008-07-16 01:19:49 UTC (rev 4219)
@@ -1,4 +1,4 @@
-svn log --stop-on-copy --xml ../.. > svn.xml
-xsltproc svnlog.xslt svn.xml > "../../../avidemux_2.4_build/Change Log.html"
+svn log --stop-on-copy --xml $SOURCEDIR > svn.xml
+xsltproc svnlog.xslt svn.xml > "$BUILDDIR/Change Log.html"
 xsltproc revision.xslt svn.xml > revision.nsh
 rm svn.xml



From gruntster at mail.berlios.de  Wed Jul 16 15:07:31 2008
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Wed, 16 Jul 2008 15:07:31 +0200
Subject: [Avidemux-svn-commit] r4220 -
	branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mp4
Message-ID: <200807161307.m6GD7VW5005639@sheep.berlios.de>

Author: gruntster
Date: 2008-07-16 15:07:21 +0200 (Wed, 16 Jul 2008)
New Revision: 4220

Modified:
   branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mp4/ADM_mp4Analyzer.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mp4/ADM_mp4audio.cpp
Log:
[MP4] improve detection of MP2 audio

Modified: branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mp4/ADM_mp4Analyzer.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mp4/ADM_mp4Analyzer.cpp	2008-07-16 01:19:49 UTC (rev 4219)
+++ branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mp4/ADM_mp4Analyzer.cpp	2008-07-16 13:07:21 UTC (rev 4220)
@@ -1044,9 +1044,11 @@
                                     {
                                       switch(objectTypeIndication)
                                       {
-                                          case 0x69:ADIO.encoding=WAV_MP3;break;
-                                          case 0x6b:ADIO.encoding=WAV_MP2;break;
-                                          case 0x6d:ADIO.encoding=WAV_MP3;break;
+                                          case 0x69:
+                                          case 0x6b:
+                                          case 0x6d:
+											  ADIO.encoding=WAV_MP3;
+											  break;
                                           case 226:ADIO.encoding=WAV_AC3;break;
                                           break;
 

Modified: branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mp4/ADM_mp4audio.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mp4/ADM_mp4audio.cpp	2008-07-16 01:19:49 UTC (rev 4219)
+++ branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mp4/ADM_mp4audio.cpp	2008-07-16 13:07:21 UTC (rev 4220)
@@ -51,7 +51,22 @@
 
 	_extraLen=track->extraDataSize;
 	_extraData=track->extraData;
-	
+
+	// Check if MP3 track is actually MP2
+	if (track->_rdWav.encoding == WAV_MP3 && _nb_chunks && _index[0].size >= 4)
+	{
+		uint8_t sample[4];
+
+		fseeko(_fd, _index[0].offset, SEEK_SET);
+		fread(&sample, 1, 4, _fd);
+
+		uint32_t fcc = sample[0] << 24 | sample[1] << 16 | sample[2] << 8 | sample[3];
+		int layer = 4 - ((fcc >> 17) & 0x3);
+
+		if (layer == 2)
+			track->_rdWav.encoding = WAV_MP2;
+	}
+
 	_wavheader=new WAVHeader;
         memcpy(_wavheader,&(track->_rdWav),sizeof(WAVHeader));
 	



From mean at mail.berlios.de  Wed Jul 16 19:39:43 2008
From: mean at mail.berlios.de (mean at BerliOS)
Date: Wed, 16 Jul 2008 19:39:43 +0200
Subject: [Avidemux-svn-commit] r4221 - in
	branches/avidemux_2.5_branch_gruntster/avidemux: . ADM_audio
	ADM_audioEncoder ADM_audioEncoder/include
	ADM_audioEncoder/src ADM_audiocodec ADM_audiodevice
	ADM_audiofilter ADM_core/include ADM_core/src ADM_coreAudio
	ADM_coreAudio/include ADM_coreAudio/src ADM_libraries/ADM_utilities
	ADM_userInterfaces/ADM_NONE/ADM_dialog
	ADM_userInterfaces/ADM_QT4/ADM_dialog
	ADM_userInterfaces/ADM_QT4/ADM_filters
	ADM_userInterfaces/ADM_commonUI
Message-ID: <200807161739.m6GHdhJv021064@sheep.berlios.de>

Author: mean
Date: 2008-07-16 19:39:39 +0200 (Wed, 16 Jul 2008)
New Revision: 4221

Added:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/include/
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/include/audioencoder_aften.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/include/audioencoder_aften_param.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/include/audioencoder_config.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/include/audioencoder_enum.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/include/audioencoder_faac.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/include/audioencoder_faac_param.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/include/audioencoder_lame.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/include/audioencoder_lame_param.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/include/audioencoder_lavcodec.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/include/audioencoder_pcm.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/include/audioencoder_twolame.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/include/audioencoder_twolame_param.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/include/audioencoder_vorbis.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/include/audioencoder_vorbis_param.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/src/
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/src/audioencoder_aften.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/src/audioencoder_faac.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/src/audioencoder_lame.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/src/audioencoder_lavcodec.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/src/audioencoder_pcm.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/src/audioencoder_twolame.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/src/audioencoder_vorbis.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/CMakeLists.txt
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/include/
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/include/ADM_audiodef.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/include/ADM_coreAudio.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/include/audioencoder.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/src/
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/src/ADM_audioUtils.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/src/CMakeLists.txt
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/src/audioencoder.cpp
Removed:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audio/ADM_audiodef.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioencoder.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioencoder.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioencoder_aften.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioencoder_aften.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioencoder_aften_param.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioencoder_config.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioencoder_faac.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioencoder_faac.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioencoder_faac_param.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioencoder_lame.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioencoder_lame.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioencoder_lame_param.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioencoder_lavcodec.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioencoder_lavcodec.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioencoder_pcm.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioencoder_pcm.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioencoder_twolame.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioencoder_twolame.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioencoder_twolame_param.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioencoder_vorbis.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioencoder_vorbis.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioencoder_vorbis_param.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_core/include/ADM_coreAudio.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_core/src/ADM_audioUtils.cpp
Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audio/aviaudio.hxx
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiocodec/ADM_ad_plugin.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/CMakeLists.txt
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/CMakeLists.txt
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audiodeng_buildfilters.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioeng_buildfilters.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioeng_process.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audiofilter_buildchain.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_core/src/CMakeLists.txt
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_libraries/ADM_utilities/avifmt2.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_NONE/ADM_dialog/DIA_none.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/DIA_none.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_filters/Q_mainfilter.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_audioconfig.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/CMakeLists.txt
Log:
[Audio] Create coreAudio + begin moving away audioEncoder


Deleted: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audio/ADM_audiodef.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audio/ADM_audiodef.h	2008-07-16 13:07:21 UTC (rev 4220)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audio/ADM_audiodef.h	2008-07-16 17:39:39 UTC (rev 4221)
@@ -1,69 +0,0 @@
-/*
-
-
-*/
-#ifndef AUDIO_DEF
-#define AUDIO_DEF
-#include <string.h>
-typedef struct
-{
-    uint16_t	encoding;	
-    uint16_t	channels;					/* 1 = mono, 2 = stereo */
-    uint32_t	frequency;				/* One of 11025, 22050, or 44100 48000 Hz */
-    uint32_t	byterate;					/* Average bytes per second */
-    uint16_t	blockalign;				/* Bytes per sample block */
-    uint16_t	bitspersample;		/* One of 8, 12, 16, or 4 for ADPCM */
-} WAVHeader;
-void printWavHeader(WAVHeader *hdr);
-
-typedef enum 
-{
-    CHANNEL_INVALID=0,
-    CHANNEL_MONO,
-    CHANNEL_STEREO,
-    CHANNEL_2F_1R,
-    CHANNEL_3F,
-    CHANNEL_3F_1R,
-    CHANNEL_2F_2R,
-    CHANNEL_3F_2R,
-    CHANNEL_3F_2R_LFE,
-    CHANNEL_DOLBY_PROLOGIC,
-    CHANNEL_DOLBY_PROLOGIC2,
-    CHANNEL_LAST
-} CHANNEL_CONF;
-
-#define MAX_CHANNELS 9
-
-typedef enum 
-{
-	CH_INVALID=0,
-	CH_MONO,
-	CH_FRONT_LEFT,
-	CH_FRONT_RIGHT,
-	CH_FRONT_CENTER,
-	CH_REAR_LEFT,
-	CH_REAR_RIGHT,
-	CH_REAR_CENTER,
-	CH_SIDE_LEFT,
-	CH_SIDE_RIGHT,
-	CH_LFE
-}CHANNEL_TYPE;
-// returns true if channel mapping is identical
-bool ADM_audioCompareChannelMapping(WAVHeader *wh1, WAVHeader *wh2,CHANNEL_TYPE *map1,CHANNEL_TYPE *map2);
-
-
-typedef struct
-{
-  const char    *desc;
-  CHANNEL_CONF  conf;
-}AudioChannelDesc;
-const AudioChannelDesc localDownmixing[]=
-{
-  {"No downmixing (multichannel)", CHANNEL_INVALID},
-  {"Stereo", CHANNEL_STEREO},
-  {"Dolby Prologic", CHANNEL_DOLBY_PROLOGIC},
-  {"Dolby Prologic II", CHANNEL_DOLBY_PROLOGIC2}
-  
-};
-#define NB_LOCAL_DOWNMIX (sizeof(localDownmixing)/sizeof(AudioChannelDesc))
-#endif

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audio/aviaudio.hxx
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audio/aviaudio.hxx	2008-07-16 13:07:21 UTC (rev 4220)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audio/aviaudio.hxx	2008-07-16 17:39:39 UTC (rev 4221)
@@ -22,7 +22,7 @@
 class AviList;
 
 
-#include "../ADM_audio/ADM_audiodef.h"
+#include "ADM_coreAudio/include/ADM_coreAudio.h"
 typedef struct
 {
 	uint16_t	encoding;	

Copied: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/include/audioencoder_aften.h (from rev 4205, branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioencoder_aften.h)
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioencoder_aften.h	2008-07-07 17:43:08 UTC (rev 4205)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/include/audioencoder_aften.h	2008-07-16 17:39:39 UTC (rev 4221)
@@ -0,0 +1,31 @@
+
+/***************************************************************************
+    copyright            : (C) 2002-6 by mean
+    email                : fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#ifndef AUDMaudioAften
+#define AUDMaudioAften
+#ifdef USE_AFTEN
+ //_____________________________________________
+class AUDMEncoder_Aften : public AUDMEncoder
+{
+protected:
+         void           *_handle;
+         
+public:
+                        uint8_t init(ADM_audioEncoderDescriptor *config);
+                virtual ~AUDMEncoder_Aften();
+                        AUDMEncoder_Aften(AUDMAudioFilter *instream);	
+                virtual uint8_t	getPacket(uint8_t *dest, uint32_t *len, uint32_t *samples);
+};
+#endif
+#endif

Copied: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/include/audioencoder_aften_param.h (from rev 4205, branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioencoder_aften_param.h)
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioencoder_aften_param.h	2008-07-07 17:43:08 UTC (rev 4205)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/include/audioencoder_aften_param.h	2008-07-16 17:39:39 UTC (rev 4221)
@@ -0,0 +1,10 @@
+#ifndef AUDM_AFTEN_PARAM_H
+#define AUDM_AFTEN_PARAM_H
+#ifdef USE_AFTEN
+
+typedef struct AFTEN_encoderParam
+{
+  ADM_mode        mode;
+};
+#endif
+#endif

Copied: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/include/audioencoder_config.h (from rev 4205, branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioencoder_config.h)
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioencoder_config.h	2008-07-07 17:43:08 UTC (rev 4205)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/include/audioencoder_config.h	2008-07-16 17:39:39 UTC (rev 4221)
@@ -0,0 +1,180 @@
+#ifndef AUDIOENCODER_CONFIG_H
+#define AUDIOENCODER_CONFIG_H
+
+#include "audioencoder_faac_param.h"
+#include "audioencoder_lame_param.h"
+#include "audioencoder_twolame_param.h"
+#include "audioencoder_vorbis_param.h"
+#include "audioencoder_aften_param.h"
+
+
+
+extern int DIA_defaultSettings(ADM_audioEncoderDescriptor *descriptor);
+/**** Copy ****/
+
+ADM_audioEncoderDescriptor copyDescriptor=
+{
+  AUDIOENC_COPY,
+  DIA_defaultSettings,
+  "Copy encoder",
+  128,
+  99,
+  0,
+  NULL
+};
+/**** FAAC ****/
+#ifdef USE_FAAC
+FAAC_encoderParam aacParam={128};
+ADM_audioEncoderDescriptor aacDescriptor=
+{
+        AUDIOENC_FAAC,
+        DIA_defaultSettings,
+        "FAAC encoder",
+        128,
+        6,      // AAC can do 5.1
+        sizeof(aacParam),
+        &aacParam
+};
+#endif
+/**** LAME ****/
+LAME_encoderParam lameParam=
+{
+  ADM_LAME_PRESET_CBR,
+  ADM_STEREO,
+  2,
+  0 /* Reservoir enable by default */
+};
+#ifdef HAVE_LIBMP3LAME
+extern int DIA_getLameSettings(ADM_audioEncoderDescriptor *descriptor);
+ADM_audioEncoderDescriptor  lameDescriptor=
+{
+  AUDIOENC_MP3,
+  DIA_getLameSettings,
+  "Lame encoder",
+  128,
+  2,      // Lame can only do stereo
+  sizeof(lameParam),
+  &lameParam
+};
+#endif
+/**** TWOLAME ****/
+TWOLAME_encoderParam twolameParam=
+{
+  ADM_STEREO
+};
+ADM_audioEncoderDescriptor  twolameDescriptor=
+{
+  AUDIOENC_2LAME,
+  DIA_defaultSettings,
+  "TwoLame encoder",
+  128,
+  2,      // Lame can only do stereo
+  sizeof(twolameParam),
+  &twolameParam
+};
+/********** Lavcodec **************/
+ADM_audioEncoderDescriptor  lavcodecMP2Descriptor=
+{
+  AUDIOENC_MP2,
+  DIA_defaultSettings,
+  "LAvcodec MP2 encoder",
+  128,
+  2,    
+  0,
+  NULL
+};
+ADM_audioEncoderDescriptor  lavcodecAC3Descriptor=
+{
+  AUDIOENC_AC3,
+  DIA_defaultSettings,
+  "LAvcodec AC3 encoder",
+  128,
+  6,    
+  0,
+  NULL
+};
+
+/************** Vorbis **************/
+#ifdef USE_VORBIS
+extern int DIA_getVorbisSettings(ADM_audioEncoderDescriptor *descriptor);
+VORBIS_encoderParam vorbisParam=
+{
+  ADM_VORBIS_VBR,
+  3
+  
+};
+ADM_audioEncoderDescriptor  vorbisDescriptor=
+{
+  AUDIOENC_VORBIS,
+  DIA_getVorbisSettings,
+  "Vorbis encoder",
+  128,
+  6,      // Lame can only do stereo
+  sizeof(vorbisParam),
+  &vorbisParam
+};
+#endif
+/********** PCM **************/
+ADM_audioEncoderDescriptor  pcmDescriptor=
+{
+  AUDIOENC_NONE,
+  NULL,
+  "PCM encoder",
+  128,
+  6,    
+  0,
+  NULL
+};
+ADM_audioEncoderDescriptor  lpcmDescriptor=
+{
+  AUDIOENC_LPCM,
+  NULL,
+  "LPCM encoder",
+  128,
+  6,    
+  0,
+  NULL
+};
+//---------------- AFTEN ------------------
+#ifdef USE_AFTEN
+AFTEN_encoderParam aftenParam =
+{
+  ADM_STEREO
+};
+
+ADM_audioEncoderDescriptor  aftenDescriptor=
+{
+  AUDIOENC_AFTEN,
+  DIA_defaultSettings,
+  "Aften AC3 encoder",
+  128,
+  6,      // Lame can only do stereo
+  sizeof(aftenParam),
+  &aftenParam
+};
+#endif
+ADM_audioEncoderDescriptor *allDescriptors[]=
+{
+      &copyDescriptor,
+#ifdef USE_FAAC
+      &aacDescriptor,
+#endif
+      &twolameDescriptor,
+      &lavcodecAC3Descriptor,
+      &lavcodecMP2Descriptor,
+#ifdef USE_VORBIS
+      &vorbisDescriptor ,
+#endif      
+      &pcmDescriptor,
+      &lpcmDescriptor
+#ifdef USE_AFTEN
+      ,&aftenDescriptor
+#endif
+#ifdef HAVE_LIBMP3LAME
+      ,&lameDescriptor
+#endif
+};
+#define NB_AUDIO_DESCRIPTOR (sizeof(allDescriptors)/sizeof(ADM_audioEncoderDescriptor *))
+#endif
+//EOF
+

Added: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/include/audioencoder_enum.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/include/audioencoder_enum.h	2008-07-16 13:07:21 UTC (rev 4220)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/include/audioencoder_enum.h	2008-07-16 17:39:39 UTC (rev 4221)
@@ -0,0 +1,24 @@
+/**
+    \fn audioencoder_enum
+    \brief Temporary, will be removed
+*/
+
+#ifndef audioencoder_enum_h
+#define audioencoder_enum_h
+
+typedef enum 
+{
+	AUDIOENC_NONE,
+	AUDIOENC_MP3,
+	AUDIOENC_MP2,
+	AUDIOENC_AC3,
+	AUDIOENC_2LAME,
+	AUDIOENC_FAAC,
+	AUDIOENC_VORBIS,
+    AUDIOENC_COPY,
+    AUDIOENC_LPCM,
+    AUDIOENC_AFTEN,
+    AUDIOENC_DUMMY
+}AUDIOENCODER;
+
+#endif
\ No newline at end of file

Copied: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/include/audioencoder_faac.h (from rev 4205, branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioencoder_faac.h)
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioencoder_faac.h	2008-07-07 17:43:08 UTC (rev 4205)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/include/audioencoder_faac.h	2008-07-16 17:39:39 UTC (rev 4221)
@@ -0,0 +1,31 @@
+
+/***************************************************************************
+    copyright            : (C) 2002-6 by mean
+    email                : fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#ifndef AUDMaudioAAC
+#define AUDMaudioAAC
+
+ //_____________________________________________
+class AUDMEncoder_Faac : public AUDMEncoder
+{
+protected:
+         void           *_handle;
+         uint8_t        refillBuffer(int minimum);
+public:
+                        uint8_t init(ADM_audioEncoderDescriptor *config);
+                virtual ~AUDMEncoder_Faac();
+                        AUDMEncoder_Faac(AUDMAudioFilter *instream);	
+                virtual uint8_t	getPacket(uint8_t *dest, uint32_t *len, uint32_t *samples);
+};
+
+#endif

Copied: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/include/audioencoder_faac_param.h (from rev 4205, branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioencoder_faac_param.h)
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioencoder_faac_param.h	2008-07-07 17:43:08 UTC (rev 4205)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/include/audioencoder_faac_param.h	2008-07-16 17:39:39 UTC (rev 4221)
@@ -0,0 +1,8 @@
+
+#ifndef FAAC_PARAM_H
+#define FAAC_PARAM_H
+typedef struct 
+{
+  uint32_t dummy;
+}FAAC_encoderParam;
+#endif

Copied: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/include/audioencoder_lame.h (from rev 4205, branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioencoder_lame.h)
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioencoder_lame.h	2008-07-07 17:43:08 UTC (rev 4205)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/include/audioencoder_lame.h	2008-07-16 17:39:39 UTC (rev 4221)
@@ -0,0 +1,35 @@
+
+/***************************************************************************
+    copyright            : (C) 2002-6 by mean
+    email                : fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#ifndef AUDMaudioLame
+#define AUDMaudioLame
+
+ //_____________________________________________
+class AUDMEncoder_Lame : public AUDMEncoder
+{
+  protected:
+   
+    void              *lameFlags;
+    ADM_LAME_PRESET   _preset;
+         
+  public:
+            uint8_t     init(ADM_audioEncoderDescriptor *config);
+    virtual             ~AUDMEncoder_Lame();
+                        AUDMEncoder_Lame(AUDMAudioFilter *instream);	
+            uint8_t	isVBR(void );
+            
+   virtual uint8_t	getPacket(uint8_t *dest, uint32_t *len, uint32_t *samples);
+};
+
+#endif

Copied: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/include/audioencoder_lame_param.h (from rev 4205, branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioencoder_lame_param.h)
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioencoder_lame_param.h	2008-07-07 17:43:08 UTC (rev 4205)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/include/audioencoder_lame_param.h	2008-07-16 17:39:39 UTC (rev 4221)
@@ -0,0 +1,31 @@
+#ifndef AUDM_LAME_PARAM_H
+#define AUDM_LAME_PARAM_H
+
+typedef enum 
+{
+  ADM_LAME_PRESET_CBR,
+  ADM_LAME_PRESET_ABR,
+  ADM_LAME_PRESET_EXTREME
+}ADM_LAME_PRESET;
+
+typedef struct 
+{
+  ADM_LAME_PRESET preset;
+  const char	*name;
+}ADM_PRESET_DEFINITION;
+static const ADM_PRESET_DEFINITION      presetDefinition[]=
+{
+  {ADM_LAME_PRESET_CBR,"CBR"},
+  {ADM_LAME_PRESET_ABR,"ABR"},
+  {ADM_LAME_PRESET_EXTREME,"Extreme"}
+};    
+
+typedef struct 
+{
+  ADM_LAME_PRESET preset;
+  ADM_mode        mode;
+  uint32_t        quality;
+  uint32_t        disableReservoir; // usefull for strict CBR (FLV)
+}LAME_encoderParam;
+
+#endif

Copied: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/include/audioencoder_lavcodec.h (from rev 4205, branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioencoder_lavcodec.h)
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioencoder_lavcodec.h	2008-07-07 17:43:08 UTC (rev 4205)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/include/audioencoder_lavcodec.h	2008-07-16 17:39:39 UTC (rev 4221)
@@ -0,0 +1,32 @@
+
+/***************************************************************************
+    copyright            : (C) 2002-6 by mean
+    email                : fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#ifndef AUDMaudioLavcodec
+#define AUDMaudioLavcodec
+ //_____________________________________________
+class AUDMEncoder_Lavcodec : public AUDMEncoder
+{
+  protected:
+   
+    void              *_context;
+    uint32_t          _fourcc;
+         
+  public:
+            uint8_t     init(ADM_audioEncoderDescriptor *config);
+   virtual             ~AUDMEncoder_Lavcodec();
+                        AUDMEncoder_Lavcodec(uint32_t fourcc,AUDMAudioFilter *instream);	
+   virtual uint8_t	getPacket(uint8_t *dest, uint32_t *len, uint32_t *samples);
+};
+
+#endif

Copied: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/include/audioencoder_pcm.h (from rev 4205, branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioencoder_pcm.h)
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioencoder_pcm.h	2008-07-07 17:43:08 UTC (rev 4205)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/include/audioencoder_pcm.h	2008-07-16 17:39:39 UTC (rev 4221)
@@ -0,0 +1,36 @@
+/***************************************************************************
+    copyright            : (C) 2002-6 by mean
+    email                : fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#ifndef AUDMaudioPCM
+#define AUDMaudioPCM
+
+/*!
+    This class is the float->PCM encoder.
+    It is somehow special as it can alsa be a LPCM encoder and a bigendian/littleendian swapper
+*/
+class AUDMEncoder_PCM : public AUDMEncoder
+{
+  protected:
+    uint32_t            revert;
+         
+  public:
+            uint8_t     init(ADM_audioEncoderDescriptor *config);
+            virtual     ~AUDMEncoder_PCM();
+                        /*! \param reverted : Should the endianness be reverted compared to system  
+                            \param fourCC   : FourCC to use (WAV_PCM/WAV_LPCM)
+                        */
+                         AUDMEncoder_PCM(uint32_t reverted,uint32_t fourCC,AUDMAudioFilter * instream);
+    virtual uint8_t	getPacket(uint8_t *dest, uint32_t *len, uint32_t *samples);
+};
+
+#endif

Copied: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/include/audioencoder_twolame.h (from rev 4205, branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioencoder_twolame.h)
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioencoder_twolame.h	2008-07-07 17:43:08 UTC (rev 4205)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/include/audioencoder_twolame.h	2008-07-16 17:39:39 UTC (rev 4221)
@@ -0,0 +1,30 @@
+/***************************************************************************
+    copyright            : (C) 2002-6 by mean
+    email                : fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#ifndef AUDMaudioTwoLame
+#define AUDMaudioTwoLame
+
+ //_____________________________________________
+class AUDMEncoder_Twolame : public AUDMEncoder
+{
+  protected:
+    void           *_twolameOptions;
+         
+  public:
+            uint8_t     init(ADM_audioEncoderDescriptor *config);
+    virtual             ~AUDMEncoder_Twolame();
+                        AUDMEncoder_Twolame(AUDMAudioFilter *instream);	
+    virtual uint8_t	getPacket(uint8_t *dest, uint32_t *len, uint32_t *samples);
+};
+
+#endif

Copied: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/include/audioencoder_twolame_param.h (from rev 4205, branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioencoder_twolame_param.h)
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioencoder_twolame_param.h	2008-07-07 17:43:08 UTC (rev 4205)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/include/audioencoder_twolame_param.h	2008-07-16 17:39:39 UTC (rev 4221)
@@ -0,0 +1,10 @@
+#ifndef AUDM_TWOLAME_PARAM_H
+#define AUDM_TWOLAME_PARAM_H
+
+
+typedef struct 
+{
+  ADM_mode        mode;
+}TWOLAME_encoderParam;
+
+#endif

Copied: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/include/audioencoder_vorbis.h (from rev 4205, branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioencoder_vorbis.h)
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioencoder_vorbis.h	2008-07-07 17:43:08 UTC (rev 4205)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/include/audioencoder_vorbis.h	2008-07-16 17:39:39 UTC (rev 4221)
@@ -0,0 +1,35 @@
+
+/***************************************************************************
+    copyright            : (C) 2002-6 by mean
+    email                : fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#ifndef AUDMaudioVorbis
+#define AUDMaudioVorbis
+
+ //_____________________________________________
+class AUDMEncoder_Vorbis : public AUDMEncoder
+{
+  protected:
+   
+    void              *_handle;
+    uint64_t          _oldpos;
+
+         
+  public:
+            uint8_t     init(ADM_audioEncoderDescriptor *config);
+            virtual     ~AUDMEncoder_Vorbis();
+                        AUDMEncoder_Vorbis(AUDMAudioFilter *instream);	
+            
+   virtual uint8_t	getPacket(uint8_t *dest, uint32_t *len, uint32_t *samples);
+};
+
+#endif

Copied: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/include/audioencoder_vorbis_param.h (from rev 4205, branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioencoder_vorbis_param.h)
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioencoder_vorbis_param.h	2008-07-07 17:43:08 UTC (rev 4205)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/include/audioencoder_vorbis_param.h	2008-07-16 17:39:39 UTC (rev 4221)
@@ -0,0 +1,17 @@
+#ifndef AUDM_VORBIS_PARAM_H
+#define AUDM_VORBIS_PARAM_H
+
+typedef enum 
+{
+  ADM_VORBIS_CBR,
+  ADM_VORBIS_VBR,
+  ADM_VORBIS_QUALITY
+  
+}ADM_VORBIS_MODE;
+
+typedef struct 
+{
+  ADM_VORBIS_MODE    mode;   // 0 cbr 1 vbr 2 quality
+  float              quality;
+}VORBIS_encoderParam;
+#endif

Copied: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/src/audioencoder_aften.cpp (from rev 4205, branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioencoder_aften.cpp)
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioencoder_aften.cpp	2008-07-07 17:43:08 UTC (rev 4205)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/src/audioencoder_aften.cpp	2008-07-16 17:39:39 UTC (rev 4221)
@@ -0,0 +1,166 @@
+
+/***************************************************************************
+    copyright            : (C) 2002-6 by mean
+    email                : fixounet at free.fr
+
+    Interface to Aften
+
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include "config.h"
+#ifdef USE_AFTEN
+#include "config.h"
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <math.h>
+
+
+#include "ADM_default.h"
+
+#include "audioprocess.hxx"
+#include "audioeng_process.h"
+#include "audioencoder.h"
+//
+extern "C"
+{
+#if defined(USE_AFTEN_06)
+	#include "aften.h"
+#else	// Aften 0.05 & 0.07 onwards
+	#include "aften/aften.h"
+#endif
+};
+#include "audioencoder_aften_param.h"
+#include "audioencoder_aften.h"
+
+#define _HANDLE ((AftenContext *)_handle)
+AUDMEncoder_Aften::AUDMEncoder_Aften(AUDMAudioFilter * instream)  :AUDMEncoder    (instream)
+{
+  uint32_t channels;
+  channels=instream->getInfo()->channels;
+  _handle=(void *)new AftenContext;
+  memset(_handle,0,sizeof(AftenContext));
+  aften_set_defaults(_HANDLE);
+  _wavheader->encoding=WAV_AC3;
+#if defined(USE_AFTEN_05) || defined(USE_AFTEN_06)
+#elif defined(USE_AFTEN_07)
+  _HANDLE->params.n_threads=1; // MThread collides with avidemux multithreading
+#else
+  _HANDLE->system.n_threads=1;
+#endif
+};
+
+
+AUDMEncoder_Aften::~AUDMEncoder_Aften()
+{
+    if(_handle)
+      aften_encode_close(_HANDLE);
+    delete(_HANDLE);
+    _handle=NULL;
+
+    printf("[Aften] Deleting aften\n");
+    cleanup();
+};
+
+
+//________________________________________________
+//   Init lame encoder
+// frequence    : Impose frequency , 0 means reuse the incoming fq
+// mode                         : ADM_STEREO etc...
+// bitrate              : Bitrate in kbps (96,192...)
+// return 0 : init failed
+//                              1 : init succeeded
+//_______________________________________________
+uint8_t AUDMEncoder_Aften::init(ADM_audioEncoderDescriptor *config)
+{
+
+
+int ret=0;
+
+#if defined(USE_AFTEN_05) || defined(USE_AFTEN_06)
+int mask;
+#else
+unsigned int mask;
+#endif
+
+    _wavheader->byterate=(config->bitrate*1000)/8;
+    _HANDLE->sample_format=A52_SAMPLE_FMT_FLT;
+    _HANDLE->channels=_wavheader->channels;
+    _HANDLE->samplerate=_wavheader->frequency;
+    
+    _HANDLE->params.bitrate=config->bitrate;
+    switch(_wavheader->channels)
+    {
+        case 1: mask = 0x04;  break;
+        case 2: mask = 0x03;  break;
+        case 3: mask = 0x07;  break;
+        case 4: mask = 0x107; break;
+        case 5: mask = 0x37;  break;
+        case 6: mask = 0x3F;  break;
+      }
+
+#if defined(USE_AFTEN_05) || defined(USE_AFTEN_06)
+	aften_wav_chmask_to_acmod(_wavheader->channels, mask, &(_HANDLE->acmod), &(_HANDLE->lfe));
+#else
+	aften_wav_channels_to_acmod(_wavheader->channels, mask, &(_HANDLE->acmod), &(_HANDLE->lfe));
+#endif
+
+   //   _HANDLE->params.verbose=2;
+    int er= aften_encode_init(_HANDLE);
+    if(er<0)
+    {
+      printf("[Aften] init error %d\n",er); 
+      return 0;
+    }
+    _chunk=256*6*_wavheader->channels;
+    printf("[Aften] Initialized with fd %u Channels %u bitrate %u\n",_HANDLE->samplerate,
+                                                                    _HANDLE->channels,_HANDLE->params.bitrate);
+    return 1;
+}
+
+
+//______________________________________________
+uint8_t	AUDMEncoder_Aften::getPacket(uint8_t *dest, uint32_t *len, uint32_t *samples)
+{
+  uint32_t count=0;
+  int r;
+  void *ptr;
+_again:
+        *len = 0;
+        _chunk=256*6*_wavheader->channels;
+        if(!refillBuffer(_chunk ))
+        {
+          return 0; 
+        }
+        ptr=(void *)&(tmpbuffer[tmphead]);
+        ADM_assert(tmptail>=tmphead);
+
+#ifdef USE_AFTEN_05
+		aften_remap_wav_to_a52(ptr, 256*6, _wavheader->channels, A52_SAMPLE_FMT_FLT, _HANDLE->acmod, _HANDLE->lfe);
+#else
+		aften_remap_wav_to_a52(ptr, 256*6, _wavheader->channels, A52_SAMPLE_FMT_FLT, _HANDLE->acmod);
+#endif
+
+        r=aften_encode_frame(_HANDLE, dest,(void *)ptr);
+        if(r<0)
+        {
+          printf("[Aften] Encoding error %d\n",r);
+          return 0; 
+        }
+        
+        *samples=256*6;
+        *len=r;
+        tmphead+=_chunk;
+        return 1;
+}
+
+#endif		
+// EOF

Copied: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/src/audioencoder_faac.cpp (from rev 4205, branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioencoder_faac.cpp)
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioencoder_faac.cpp	2008-07-07 17:43:08 UTC (rev 4205)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/src/audioencoder_faac.cpp	2008-07-16 17:39:39 UTC (rev 4221)
@@ -0,0 +1,223 @@
+
+/***************************************************************************
+    copyright            : (C) 2002-6 by mean
+    email                : fixounet at free.fr
+
+    Interface to FAAC
+
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include "config.h"
+#ifdef USE_FAAC
+#include "config.h"
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <math.h>
+
+
+#include "ADM_default.h"
+
+#include "audioprocess.hxx"
+#include "audioeng_process.h"
+#include "audioencoder.h"
+//
+
+#include "faac.h"
+#include "audioencoder_faac.h"
+
+AUDMEncoder_Faac::AUDMEncoder_Faac(AUDMAudioFilter * instream)  :AUDMEncoder    (instream)
+{
+  uint32_t channels;
+  channels=instream->getInfo()->channels;
+  switch(channels)
+  {
+    case 1:outputChannelMapping[1] = CH_FRONT_LEFT;break;
+    case 2:
+    	outputChannelMapping[0] = CH_FRONT_LEFT;
+    	outputChannelMapping[1] = CH_FRONT_RIGHT;
+      break;
+    default :
+    	outputChannelMapping[0] = CH_FRONT_CENTER;
+    	outputChannelMapping[1] = CH_FRONT_LEFT;
+    	outputChannelMapping[2] = CH_FRONT_RIGHT;
+    	outputChannelMapping[3] = CH_REAR_LEFT;
+    	outputChannelMapping[4] = CH_REAR_RIGHT;
+    	outputChannelMapping[5] = CH_LFE;
+  }
+};
+
+
+AUDMEncoder_Faac::~AUDMEncoder_Faac()
+{
+    if(_handle)
+        faacEncClose(_handle);
+    _handle=NULL;
+
+    printf("[FAAC] Deleting faac\n");
+    cleanup();
+};
+
+
+//________________________________________________
+//   Init lame encoder
+// frequence    : Impose frequency , 0 means reuse the incoming fq
+// mode                         : ADM_STEREO etc...
+// bitrate              : Bitrate in kbps (96,192...)
+// return 0 : init failed
+//                              1 : init succeeded
+//_______________________________________________
+uint8_t AUDMEncoder_Faac::init(ADM_audioEncoderDescriptor *config)
+{
+unsigned long int samples_input, max_bytes_output;
+faacEncConfigurationPtr cfg;
+int ret=0;
+
+    printf("[FAAC] Incoming Fq :%u\n",_wavheader->frequency);
+     _handle = faacEncOpen(_wavheader->frequency,
+                                 _wavheader->channels,
+                                 &samples_input,
+                                &max_bytes_output);
+    if(!_handle)
+    {
+          printf("Cannot open faac with fq=%lu chan=%lu br=%lu\n",
+          _wavheader->frequency,_wavheader->channels,config->bitrate);
+          return 0;
+    }
+    printf(" [FAAC] : Sample input:%d, max byte output%d \n",samples_input,max_bytes_output);
+    cfg= faacEncGetCurrentConfiguration(_handle);
+    
+    // Set default conf, same as ffmpeg
+    cfg->aacObjectType = LOW;
+    cfg->mpegVersion = MPEG4;
+    cfg->bandWidth= (_wavheader->frequency*3)/4; // Should be relevant
+    cfg->useTns = 0;
+    cfg->allowMidside = 0;
+    cfg->bitRate = (config->bitrate*1000)/_wavheader->channels; // It is per channel
+    cfg->outputFormat = 0; // 0 Raw 1 ADTS
+    cfg->inputFormat = FAAC_INPUT_FLOAT;
+    cfg->useLfe=0;	
+    if (!(ret=faacEncSetConfiguration(_handle, cfg))) 
+    {
+        printf("[FAAC] Cannot set conf for faac with fq=%lu chan=%lu br=%lu (err:%d)\n",
+				_wavheader->frequency,_wavheader->channels,config->bitrate,ret);
+	return 0;
+    }
+     unsigned char *data=NULL;
+     unsigned long size=0;
+     if((ret=faacEncGetDecoderSpecificInfo(_handle, &data,&size)))
+     {
+        printf("FAAC: GetDecoderSpecific info failed (err:%d)\n",ret);
+        return 0;
+     }
+     _extraSize=size;
+     _extraData=new uint8_t[size];
+     memcpy(_extraData,data,size);
+
+    // update
+     _wavheader->byterate=(config->bitrate*1000)/8;
+//    _wavheader->dwScale=1024;
+//    _wavheader->dwSampleSize=0;
+    _wavheader->blockalign=4096;
+    _wavheader->bitspersample=0;
+
+    _chunk=samples_input;
+
+
+    printf("[Faac] Initialized :\n");
+    
+    printf("[Faac]Version        : %s\n",cfg->name);
+    printf("[Faac]Bitrate        : %lu\n",cfg->bitRate);
+    printf("[Faac]Mpeg2 (1)/4(0) : %u\n",cfg->mpegVersion);
+    printf("[Faac]Use lfe      ) : %u\n",cfg->useLfe);
+    printf("[Faac]Sample output  : %lu\n",_chunk / _wavheader->channels);
+    printf("[Faac]Bitrate        : %lu\n",cfg->bitRate*_wavheader->channels);
+
+    
+    return 1;
+}
+
+//_____________________________________________
+//  Need to multiply the float by 32767, can't use
+//  generic fill buffer
+//----------------------------------------------
+uint8_t AUDMEncoder_Faac::refillBuffer(int minimum)
+{
+  uint32_t filler=_wavheader->frequency*_wavheader->channels;
+  uint32_t nb;
+  AUD_Status status;
+  if(eof_met) return 0;
+  while(1)
+  {
+    ADM_assert(tmptail>=tmphead);
+    if((tmptail-tmphead)>=minimum) return 1;
+  
+    if(tmphead && tmptail>filler/2)
+    {
+      memmove(&tmpbuffer[0],&tmpbuffer[tmphead],(tmptail-tmphead)*sizeof(float)); 
+      tmptail-=tmphead;
+      tmphead=0;
+    }
+    ADM_assert(filler>tmptail);
+    nb=_incoming->fill( (filler-tmptail)/2,&tmpbuffer[tmptail],&status);
+    if(!nb)
+    {
+      if(status!=AUD_END_OF_STREAM) ADM_assert(0);
+      
+      if((tmptail-tmphead)<minimum)
+      {
+        memset(&tmpbuffer[tmptail],0,sizeof(float)*(minimum-(tmptail-tmphead)));
+        tmptail=tmphead+minimum;
+        eof_met=1;  
+        return minimum;
+      }
+      else continue;
+    } else
+    {
+      float *s=&(tmpbuffer[tmptail]);
+      for(int i=0;i<nb;i++)
+      {
+        *s=*s*32767.;
+        s++;
+      }
+      tmptail+=nb;
+    }
+  }
+}
+
+#define FA_BUFFER_SIZE (SIZE_INTERNAL/4)
+//______________________________________________
+uint8_t	AUDMEncoder_Faac::getPacket(uint8_t *dest, uint32_t *len, uint32_t *samples)
+{
+  uint32_t count=0;
+_again:
+        *samples = _chunk/_wavheader->channels;
+        *len = 0;
+
+        if(!refillBuffer(_chunk ))
+        {
+          return 0; 
+        }
+        ADM_assert(tmptail>=tmphead);
+        reorderChannels(&(tmpbuffer[tmphead]),*samples,_incoming->getChannelMapping(),outputChannelMapping);
+        *len = faacEncEncode(_handle, (int32_t *)&(tmpbuffer[tmphead]), _chunk, dest, FA_BUFFER_SIZE);
+        if(!*len) 
+        {
+          count++;
+          if(count<20)
+            goto _again;
+          *samples=0;
+        }
+        tmphead+=_chunk;
+        return 1;
+}
+#endif		
+// EOF

Copied: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/src/audioencoder_lame.cpp (from rev 4205, branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioencoder_lame.cpp)
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioencoder_lame.cpp	2008-07-07 17:43:08 UTC (rev 4205)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/src/audioencoder_lame.cpp	2008-07-16 17:39:39 UTC (rev 4221)
@@ -0,0 +1,258 @@
+/***************************************************************************
+    copyright            : (C) 2006 by mean
+    email                : fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include "config.h"
+
+#ifdef HAVE_LIBMP3LAME
+#include <lame/lame.h>
+
+#include "ADM_default.h"
+#include "audioprocess.hxx"
+#include "audioeng_process.h"
+#include "audioencoder.h"
+
+#include "audioencoder_lame_param.h"
+#include "audioencoder_lame.h"
+
+
+
+#define MYFLAGS (lame_global_flags *)lameFlags
+
+AUDMEncoder_Lame::AUDMEncoder_Lame(AUDMAudioFilter * instream)  :AUDMEncoder    (instream)
+{
+  printf("[Lame] Creating lame\n");
+  lameFlags=NULL;
+  _wavheader->encoding=WAV_MP3;
+};
+
+AUDMEncoder_Lame::~AUDMEncoder_Lame()
+{
+  printf("[Lame] Deleting lame\n");
+  if(lameFlags)
+  {
+    lame_close(MYFLAGS);
+  }
+  lameFlags=NULL;
+  cleanup();
+};
+
+
+//________________________________________________
+//   Init lame encoder
+// frequence    : Impose frequency , 0 means reuse the incoming fq
+// mode                         : ADM_STEREO etc...
+// bitrate              : Bitrate in kbps (96,192...)
+// return 0 : init failed
+//                              1 : init succeeded
+//_______________________________________________
+uint8_t AUDMEncoder_Lame::init(ADM_audioEncoderDescriptor *config)
+{
+  int ret;
+  MPEG_mode_e mmode;
+  uint32_t frequence;
+  LAME_encoderParam *lameConf=(LAME_encoderParam *)config->param;
+      ADM_assert(config->paramSize==sizeof(LAME_encoderParam));
+
+      lameFlags = lame_init();
+      if (lameFlags == NULL)
+          return 0;
+      
+      if(_incoming->getInfo()->channels>2)
+      {
+        printf("Too many channels\n");
+        return 0; 
+      }
+
+	// recompute output length
+	
+      
+      ret = lame_set_in_samplerate(MYFLAGS, _wavheader->frequency);
+      ret = lame_set_num_channels(MYFLAGS, _wavheader->channels);
+
+    
+      frequence = _wavheader->frequency;
+    printf("\n output frequency : %lu\n", frequence);
+    ret = lame_set_out_samplerate(MYFLAGS, frequence);
+
+    ret = lame_set_quality(MYFLAGS, 2);
+    
+    if (_wavheader->channels == 2)
+      {
+        switch (lameConf->mode)
+	    {
+	    case ADM_STEREO:
+		mmode = STEREO;
+		break;
+	    case ADM_JSTEREO:
+		mmode = JOINT_STEREO;
+		break;
+	    default:
+		printf("\n **** unknown mode ***\n");
+		mmode = STEREO;
+		break;
+
+	    }
+    } else
+    {
+		mmode = MONO;
+     	printf("\n mono audio mp3");
+  	}
+
+        ret = lame_set_brate(MYFLAGS, config->bitrate);
+        ret = lame_set_mode(MYFLAGS, mmode);	// 0 stereo 1 jstero
+        ret = lame_set_quality(MYFLAGS, lameConf->quality);	// 0 stereo 1 jstero
+        ret = lame_set_disable_reservoir(MYFLAGS,lameConf->disableReservoir);
+        printf("[Lame]Using quality of %d\n",lame_get_quality(MYFLAGS));
+        ret = lame_init_params(MYFLAGS);
+    if (ret == -1)
+	return 0;
+    // update bitrate in header
+    _wavheader->byterate = (config->bitrate >> 3) * 1000;
+#define BLOCK_SIZE 1152
+    // configure CBR/ABR/...
+    _preset=lameConf->preset;
+    switch(_preset)
+    {
+    	default:
+    	case ADM_LAME_PRESET_CBR: 
+          break;
+	case ADM_LAME_PRESET_ABR:
+	  
+          lame_set_preset( MYFLAGS, config->bitrate);
+	  _wavheader->blockalign=BLOCK_SIZE;
+	 break;
+	case ADM_LAME_PRESET_EXTREME: 
+	  _wavheader->blockalign=BLOCK_SIZE;
+          lame_set_preset( MYFLAGS, EXTREME);	
+	break;
+    
+    
+    }
+
+    lame_print_config(MYFLAGS);
+    lame_print_internals(MYFLAGS);
+    _chunk=BLOCK_SIZE*_wavheader->channels;
+    return 1;
+}
+uint8_t	AUDMEncoder_Lame::isVBR(void )
+{
+	if(_preset==ADM_LAME_PRESET_CBR) return 0;
+	return 1;
+
+}
+
+uint8_t	AUDMEncoder_Lame::getPacket(uint8_t *dest, uint32_t *len, uint32_t *samples)
+{
+  int32_t nbout;
+  
+        *samples = BLOCK_SIZE; //FIXME
+        *len = 0;
+
+        if(!refillBuffer(_chunk ))
+        {
+          return 0; 
+        }
+        
+        if(tmptail-tmphead<_chunk)
+        {
+          return 0; 
+        }
+        dither16(&(tmpbuffer[tmphead]),_chunk,_wavheader->channels);
+        ADM_assert(tmptail>=tmphead);
+        if (_wavheader->channels == 1)
+        {
+          nbout = lame_encode_buffer(MYFLAGS, (int16_t *)&(tmpbuffer[tmphead]),(int16_t *)&(tmpbuffer[tmphead]), _chunk, dest, 16 * 1024);
+          
+        }
+        else
+        {
+          nbout = lame_encode_buffer_interleaved(MYFLAGS, (int16_t *)&(tmpbuffer[tmphead]), _chunk/2, dest, 16 * 1024);
+        }
+        tmphead+=_chunk;
+        if (nbout < 0) {
+          printf("\n Error !!! : %ld\n", nbout);
+          return 0;
+        }
+        *len=nbout;
+        if(!*len) *samples=0;
+        //printf("Audio packet : size %u, sample %u\n",*len,*samples);
+        return 1;
+}
+/**
+      \fn DIA_getLameSettings
+      \brief Dialog to set lame settings
+      @return 1 on success, 0 on failure
+
+*/
+#include "DIA_factory.h"
+int DIA_getLameSettings(ADM_audioEncoderDescriptor *descriptor)
+  {
+    int ret=0;
+    char string[400];
+    uint32_t mmode,ppreset;
+#define SZT(x) sizeof(x)/sizeof(diaMenuEntry )
+#define PX(x) &(lameParam->x)
+    
+    
+    LAME_encoderParam *lameParam;
+    ADM_assert(sizeof(LAME_encoderParam)==descriptor->paramSize);
+  
+    lameParam=(LAME_encoderParam*)descriptor->param;
+    mmode=lameParam->mode;
+    ppreset=lameParam->preset;
+    diaMenuEntry channelMode[]={
+                             {ADM_STEREO,      QT_TR_NOOP("Stereo"),NULL},
+                             {ADM_JSTEREO,   QT_TR_NOOP("Joint stereo"),NULL},
+                             {ADM_MONO,      QT_TR_NOOP("Mono"),NULL}};
+          
+    diaElemMenu menuMode(&mmode,   QT_TR_NOOP("C_hannel mode:"), SZT(channelMode),channelMode);
+    
+    diaMenuEntry encodingMode[]={
+                             {ADM_LAME_PRESET_CBR,      QT_TR_NOOP("CBR"),NULL},
+                             {ADM_LAME_PRESET_ABR,   QT_TR_NOOP("ABR"),NULL},
+#if 0
+                             {ADM_LAME_PRESET_EXTREME,      QT_TR_NOOP("Extreme"),NULL}
+#endif
+    }; 
+    diaElemMenu Mode(&ppreset,   QT_TR_NOOP("Bit_rate mode:"), SZT(encodingMode),encodingMode);
+#define BITRATE(x) {x,QT_TR_NOOP(#x)}
+    diaMenuEntry bitrateM[]={
+                              BITRATE(56),
+                              BITRATE(64),
+                              BITRATE(80),
+                              BITRATE(96),
+                              BITRATE(112),
+                              BITRATE(128),
+                              BITRATE(160),
+                              BITRATE(192),
+                              BITRATE(224)
+                          };
+    diaElemMenu bitrate(&(descriptor->bitrate),   QT_TR_NOOP("_Bitrate:"), SZT(bitrateM),bitrateM);
+    
+    
+    
+    
+    diaElemUInteger quality(PX(quality),QT_TR_NOOP("_Quality:"),0,9);
+    diaElemToggle reservoir(PX(disableReservoir),QT_TR_NOOP("_Disable reservoir:"));
+  
+      diaElem *elems[]={&menuMode,&Mode,&quality,&bitrate,&reservoir};
+    
+  if( diaFactoryRun(QT_TR_NOOP("LAME Configuration"),5,elems))
+  {
+    lameParam->mode=(ADM_mode)mmode; 
+    lameParam->preset=(ADM_LAME_PRESET)ppreset;
+    return 1;
+  }
+  return 0;
+}  
+#endif

Copied: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/src/audioencoder_lavcodec.cpp (from rev 4205, branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioencoder_lavcodec.cpp)
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioencoder_lavcodec.cpp	2008-07-07 17:43:08 UTC (rev 4205)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/src/audioencoder_lavcodec.cpp	2008-07-16 17:39:39 UTC (rev 4221)
@@ -0,0 +1,149 @@
+/***************************************************************************
+                        
+    copyright            : (C) 2002-2006 by mean
+    email                : fixounet at free.fr
+    
+    Interface to FFmpeg mpeg1/2 audio encoder
+    
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <math.h>
+
+#include "ADM_default.h"
+
+#include "audioprocess.hxx"
+#include "audioeng_process.h"
+#include "audioencoder.h"
+//
+#include "audioencoder_lavcodec.h"
+
+#include "ADM_lavcodec.h"
+
+#include "ADM_osSupport/ADM_debugID.h"
+#define MODULE_NAME MODULE_AUDIO_FILTER
+#include "ADM_osSupport/ADM_debug.h"
+
+
+#define CONTEXT ((AVCodecContext  	*)_context)
+
+
+// Ctor: Duplicate
+//__________
+
+AUDMEncoder_Lavcodec::AUDMEncoder_Lavcodec(uint32_t fourcc,AUDMAudioFilter * instream)  :AUDMEncoder    (instream)
+{
+  _fourcc=fourcc;
+  if(_fourcc!=WAV_MP2 && _fourcc!=WAV_AC3) ADM_assert(0);
+  _context=NULL;
+  _wavheader->encoding=_fourcc;
+  printf("[Lavcodec] Creating Lavcodec\n");
+};
+
+
+AUDMEncoder_Lavcodec::~AUDMEncoder_Lavcodec()
+{
+  printf("[Lavcodec] Deleting Lavcodec\n");
+  if(_context)
+  {
+    avcodec_close(CONTEXT);
+    ADM_dealloc(_context);
+  }
+  _context=NULL;
+  cleanup();
+};
+
+//________________________________________________
+//   Init lame encoder
+//_______________________________________________
+uint8_t AUDMEncoder_Lavcodec::init(ADM_audioEncoderDescriptor *config)
+{
+  int ret;
+  _context=( void *)avcodec_alloc_context();
+  _wavheader->byterate=(config->bitrate*1000)>>3;
+
+      
+  if(_fourcc==WAV_MP2 && _incoming->getInfo()->channels>2)
+  {
+    printf("[Lavcodec]Too many channels\n");
+    return 0; 
+  }
+  _wavheader->byterate=(config->bitrate*1000)>>3;         
+      
+  if(_fourcc==WAV_MP2)
+    _chunk = 1152*_wavheader->channels;
+  else
+    _chunk = 1536*_wavheader->channels; // AC3
+
+  printf("[Lavcodec]Incoming : fq : %lu, channel : %lu bitrate: %lu \n",
+         _wavheader->frequency,_wavheader->channels,config->bitrate);
+  
+  
+  CONTEXT->channels     =  _wavheader->channels;
+  CONTEXT->sample_rate  =  _wavheader->frequency;
+  CONTEXT->bit_rate     = (config->bitrate*1000); // bits -> kbits
+
+  AVCodec *codec;
+  CodecID codecID;
+  
+  if(_fourcc==WAV_MP2) codecID=CODEC_ID_MP2;
+        else codecID=CODEC_ID_AC3;
+  codec = avcodec_find_encoder(codecID);
+  ADM_assert(codec);
+  
+  ret = avcodec_open(CONTEXT, codec);
+  if (0> ret) 
+  {
+    printf("[Lavcodec] init failed err : %d!\n",ret);
+    return 0;
+  }
+
+
+  printf("[Lavcodec]Lavcodec successfully initialized\n");
+  return 1;       
+}
+//*********************************
+uint8_t	AUDMEncoder_Lavcodec::getPacket(uint8_t *dest, uint32_t *len, uint32_t *samples)
+{
+  uint32_t nbout;
+  
+  *samples = _chunk/_wavheader->channels; //FIXME
+  *len = 0;
+
+  if(!refillBuffer(_chunk ))
+  {
+    return 0; 
+  }
+        
+  if(tmptail-tmphead<_chunk)
+  {
+    return 0; 
+  }
+
+  dither16(&(tmpbuffer[tmphead]),_chunk,_wavheader->channels);
+
+  ADM_assert(tmptail>=tmphead);
+  nbout = avcodec_encode_audio(CONTEXT, dest, 5000, (short *) &(tmpbuffer[tmphead]));
+
+  tmphead+=_chunk;
+  if (nbout < 0) 
+  {
+    printf("[Lavcodec] Error !!! : %ld\n", nbout);
+    return 0;
+  }
+  *len=nbout;
+  return 1;
+}
+
+// EOF

Copied: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/src/audioencoder_pcm.cpp (from rev 4205, branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioencoder_pcm.cpp)
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioencoder_pcm.cpp	2008-07-07 17:43:08 UTC (rev 4205)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/src/audioencoder_pcm.cpp	2008-07-16 17:39:39 UTC (rev 4221)
@@ -0,0 +1,114 @@
+/***************************************************************************
+    copyright            : (C) 2006 by mean
+    email                : fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <math.h>
+
+#include "ADM_default.h"
+
+#include "audioprocess.hxx"
+#include "audioeng_process.h"
+#include "audioencoder.h"
+//
+#include "audioencoder_pcm.h"
+
+
+#include "ADM_osSupport/ADM_debugID.h"
+#define MODULE_NAME MODULE_AUDIO_FILTER
+#include "ADM_osSupport/ADM_debug.h"
+
+
+
+
+// Ctor: Duplicate
+//__________
+
+AUDMEncoder_PCM::AUDMEncoder_PCM(uint32_t reverted,uint32_t fourCC,AUDMAudioFilter * instream)  :AUDMEncoder    (instream)
+{
+  printf("[PCM] Creating PCM\n");
+  ADM_assert(fourCC==WAV_PCM || fourCC==WAV_LPCM);
+  _wavheader->encoding=fourCC;
+  revert=reverted;
+};
+
+
+AUDMEncoder_PCM::~AUDMEncoder_PCM()
+{
+  printf("[PCM] Deleting PCM\n");
+  cleanup();
+};
+
+//________________________________________________
+//   Init lame encoder
+// frequence    : Impose frequency , 0 means reuse the incoming fq
+// mode                         : ADM_STEREO etc...
+// bitrate              : Bitrate in kbps (96,192...)
+// return 0 : init failed
+//                              1 : init succeeded
+//_______________________________________________
+uint8_t AUDMEncoder_PCM::init(ADM_audioEncoderDescriptor *config)
+{
+  
+  _wavheader->byterate=_wavheader->channels*_wavheader->frequency*2;
+  _chunk = (_wavheader->frequency/100)*_wavheader->channels*2;
+  
+
+ 
+  printf("[PCM]Incoming :fq : %lu, channel : %lu \n",_wavheader->frequency,_wavheader->channels);
+  printf("[PCM]PCM successfully initialized\n");
+  return 1;       
+}
+
+uint8_t	AUDMEncoder_PCM::getPacket(uint8_t *dest, uint32_t *len, uint32_t *samples)
+{
+  uint32_t nbout;
+  
+  *samples = _chunk; //FIXME
+  *len = 0;
+
+  if(!refillBuffer(_chunk ))
+  {
+    return 0; 
+  }
+        
+  if(tmptail-tmphead<_chunk)
+  {
+    return 0; 
+  }
+        // Do in place replace
+  dither16(&(tmpbuffer[tmphead]),_chunk,_wavheader->channels);
+  if(!revert)
+    memcpy(dest,&(tmpbuffer[tmphead]),_chunk*2);
+  else
+  {
+    uint16_t *in,*out,tmp;
+    in=(uint16_t*)&(tmpbuffer[tmphead]);
+    out=(uint16_t *)dest;
+    for(int i=0;i<_chunk;i++)
+    {
+      tmp=*in++;
+      tmp=((tmp&0xff)<<8)+(tmp>>8);
+      *out++=tmp;
+    }
+  }
+  tmphead+=_chunk;
+  *len=_chunk*2;
+  *samples=_chunk/_wavheader->channels;
+  return 1;
+}
+
+
+// EOF

Copied: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/src/audioencoder_twolame.cpp (from rev 4205, branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioencoder_twolame.cpp)
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioencoder_twolame.cpp	2008-07-07 17:43:08 UTC (rev 4205)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/src/audioencoder_twolame.cpp	2008-07-16 17:39:39 UTC (rev 4221)
@@ -0,0 +1,176 @@
+/***************************************************************************
+    copyright            : (C) 2006 by mean
+    email                : fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <math.h>
+
+#include "ADM_default.h"
+
+#include "audioprocess.hxx"
+#include "audioeng_process.h"
+#include "audioencoder.h"
+//
+#include "audioencoder_twolame.h"
+#include "audioencoder_twolame_param.h"
+
+extern "C"
+{
+#include "ADM_libraries/ADM_libtwolame/twolame.h"
+}
+#include "ADM_osSupport/ADM_debugID.h"
+#define MODULE_NAME MODULE_AUDIO_FILTER
+#include "ADM_osSupport/ADM_debug.h"
+
+
+#define OPTIONS (twolame_options_struct *)_twolameOptions
+
+// Ctor: Duplicate
+//__________
+
+AUDMEncoder_Twolame::AUDMEncoder_Twolame(AUDMAudioFilter * instream)  :AUDMEncoder    (instream)
+{
+  printf("[TwoLame] Creating Twolame\n");
+  _twolameOptions=NULL;
+  _wavheader->encoding=WAV_MP2;
+};
+
+
+AUDMEncoder_Twolame::~AUDMEncoder_Twolame()
+{
+  printf("[TwoLame] Deleting TwoLame\n");
+  if(_twolameOptions)
+  {
+    twolame_close((twolame_options_struct **)&_twolameOptions);
+  }
+  _twolameOptions=NULL;
+  cleanup();
+};
+
+//________________________________________________
+//   Init lame encoder
+// frequence    : Impose frequency , 0 means reuse the incoming fq
+// mode                         : ADM_STEREO etc...
+// bitrate              : Bitrate in kbps (96,192...)
+// return 0 : init failed
+//                              1 : init succeeded
+//_______________________________________________
+uint8_t AUDMEncoder_Twolame::init(ADM_audioEncoderDescriptor *config)
+{
+  int ret;
+  TWOLAME_MPEG_mode mmode;    	
+  uint32_t frequence;
+  TWOLAME_encoderParam *lameConf=(TWOLAME_encoderParam *)config->param;
+  ADM_assert(config->paramSize==sizeof(TWOLAME_encoderParam));
+
+  _twolameOptions = twolame_init();
+  if (_twolameOptions == NULL)
+    return 0;
+      
+  if(_wavheader->channels>2)
+  {
+    printf("[TwoLame]Too many channels\n");
+    return 0; 
+  }
+  _wavheader->byterate=(config->bitrate*1000)>>3;         
+      
+ 
+  _chunk = 1152*_wavheader->channels;
+
+ 
+  printf("[TwoLame]Incoming :fq : %lu, channel : %lu bitrate: %lu \n",
+        _wavheader->frequency,_wavheader->channels,config->bitrate);
+		
+ 
+  twolame_set_in_samplerate(OPTIONS, _wavheader->frequency);
+  twolame_set_out_samplerate (OPTIONS, _wavheader->frequency);
+  twolame_set_num_channels(OPTIONS, _wavheader->channels);
+  if(_wavheader->channels==1) mmode=TWOLAME_MONO;
+  else
+    switch (lameConf->mode)
+  {
+    case ADM_STEREO:
+      mmode = TWOLAME_STEREO;
+      break;
+    case ADM_JSTEREO:
+      mmode = TWOLAME_JOINT_STEREO;
+      break;
+    case ADM_MONO:
+      mmode=TWOLAME_MONO;
+      break;
+				
+    default:
+      printf("\n **** unknown mode, going stereo ***\n");
+      mmode = TWOLAME_STEREO;
+      break;
+
+  }
+  twolame_set_mode(OPTIONS,mmode);
+  twolame_set_error_protection(OPTIONS,TRUE);	
+    	//toolame_setPadding (options,TRUE);
+  twolame_set_bitrate (OPTIONS,config->bitrate);
+  twolame_set_verbosity(OPTIONS, 2);
+  if(twolame_init_params(OPTIONS))
+  {
+    printf("[TwoLame]Twolame init failed\n");
+    return 0;
+  }
+	
+ 
+
+  printf("[TwoLame]Libtoolame successfully initialized\n");
+  return 1;       
+}
+
+uint8_t	AUDMEncoder_Twolame::getPacket(uint8_t *dest, uint32_t *len, uint32_t *samples)
+{
+  int nbout;
+  
+  *samples = 1152; //FIXME
+  *len = 0;
+  ADM_assert(tmptail>=tmphead);
+  if(!refillBuffer(_chunk ))
+  {
+    return 0; 
+  }
+        
+  if(tmptail-tmphead<_chunk)
+  {
+    return 0; 
+  }
+
+  dither16(&(tmpbuffer[tmphead]),_chunk,_wavheader->channels);
+
+  ADM_assert(tmptail>=tmphead);
+  if (_wavheader->channels == 1)
+  {
+    nbout =twolame_encode_buffer(OPTIONS, (int16_t *)&(tmpbuffer[tmphead]),(int16_t *)&(tmpbuffer[tmphead]), _chunk, dest, 16 * 1024);
+  }
+  else
+  {
+    nbout = twolame_encode_buffer_interleaved(OPTIONS, (int16_t *)&(tmpbuffer[tmphead]), _chunk/2, dest, 16 * 1024);
+  }
+  tmphead+=_chunk;
+  ADM_assert(tmptail>=tmphead);
+  if (nbout < 0) {
+    printf("\n Error !!! : %ld\n", nbout);
+    return 0;
+  }
+  *len=nbout;
+  return 1;
+}
+
+
+// EOF

Copied: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/src/audioencoder_vorbis.cpp (from rev 4205, branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioencoder_vorbis.cpp)
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioencoder_vorbis.cpp	2008-07-07 17:43:08 UTC (rev 4205)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/src/audioencoder_vorbis.cpp	2008-07-16 17:39:39 UTC (rev 4221)
@@ -0,0 +1,307 @@
+/***************************************************************************
+    copyright            : (C) 2006 by mean
+    email                : fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include "config.h"
+#ifdef USE_VORBIS
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <math.h>
+
+#include "ADM_default.h"
+
+#include "audioprocess.hxx"
+#include "audioeng_process.h"
+#include "audioencoder.h"
+//
+#include "audioencoder_vorbis_param.h"
+#include "audioencoder_vorbis.h"
+
+
+#include "vorbis/vorbisenc.h"
+#include "ADM_osSupport/ADM_debugID.h"
+#define MODULE_NAME MODULE_AUDIO_FILTER
+#include "ADM_osSupport/ADM_debug.h"
+
+
+#define OPTIONS (twolame_options_struct *)_twolameOptions
+
+#define VD (((vorbisStruct *)_handle)->vd)
+#define VI (((vorbisStruct *)_handle)->vi)
+#define VB (((vorbisStruct *)_handle)->vb)
+#define VC (((vorbisStruct *)_handle)->vc)
+typedef struct vorbisStruct
+{ 
+	vorbis_info 	 vi ;
+	vorbis_dsp_state vd ;
+	vorbis_block     vb ;
+	vorbis_comment   vc ;
+}vorbisStruct;
+//__________
+
+AUDMEncoder_Vorbis::AUDMEncoder_Vorbis(AUDMAudioFilter * instream)  :AUDMEncoder    (instream)
+{
+  printf("[Vorbis] Creating Vorbis\n");
+  _handle=NULL;
+  _wavheader->encoding=WAV_OGG;
+  _oldpos=0;
+  _handle=(void *)new  vorbisStruct; 
+  outputChannelMapping[0] = CH_FRONT_LEFT;
+  outputChannelMapping[1] = CH_FRONT_RIGHT;
+  outputChannelMapping[2] = CH_REAR_LEFT;
+  outputChannelMapping[3] = CH_REAR_RIGHT;
+  outputChannelMapping[4] = CH_FRONT_CENTER;
+  outputChannelMapping[5] = CH_LFE;
+};
+
+
+AUDMEncoder_Vorbis::~AUDMEncoder_Vorbis()
+{
+  printf("[Vorbis] Deleting Vorbis\n");
+  if(_handle)
+  {
+    vorbis_block_clear(&VB);
+    vorbis_dsp_clear(&VD);
+    vorbis_info_clear(&VI);
+    delete (vorbisStruct *)_handle;
+  }    	
+  _handle=NULL;
+  
+  cleanup();
+};
+
+//________________________________________________
+//   Init lame encoder
+// frequence    : Impose frequency , 0 means reuse the incoming fq
+// mode                         : ADM_STEREO etc...
+// bitrate              : Bitrate in kbps (96,192...)
+// return 0 : init failed
+//                              1 : init succeeded
+//_______________________________________________
+uint8_t AUDMEncoder_Vorbis::init(ADM_audioEncoderDescriptor *config)
+{
+  int ret;
+  VORBIS_encoderParam *vorbisConf=(VORBIS_encoderParam *)config->param;
+  ADM_assert(config->paramSize==sizeof(VORBIS_encoderParam));
+
+  ogg_packet header1,header2,header3;
+  int err;
+
+  
+  
+  vorbis_info_init(&VI) ;
+
+  switch(vorbisConf->mode)
+  {
+    
+    case ADM_VORBIS_VBR:
+                      err=vorbis_encode_init(&VI,
+                              _wavheader->channels,
+                              _wavheader->frequency,
+                              -1, // Max bitrate      
+                              config->bitrate*1000, //long nominal_bitrate,
+                              -1 //long min_bitrate))
+                            );
+                      break;
+    case  ADM_VORBIS_QUALITY :
+                    err=vorbis_encode_init_vbr(&VI,
+                                _wavheader->channels,
+                                _wavheader->frequency,
+                                vorbisConf->quality/10
+                              );
+                    break;
+      
+    default:
+      ADM_assert(0);
+  }
+  if (err!=0) 
+  {
+	  delete (vorbisStruct*)_handle;
+	  _handle = NULL;
+
+    printf("[vorbis] init error %d\n",err);
+    return 0;
+  }
+  vorbis_analysis_init(&VD, &VI) ;
+  vorbis_block_init(&VD, &VB);
+  vorbis_comment_init(&VC);
+  vorbis_comment_add_tag(&VC, "encoder", "AVIDEMUX2") ;
+
+  vorbis_analysis_headerout(&VD, &VC, &header1,
+                             &header2, &header3);
+
+
+// Store all headers as extra data
+// see ogg vorbis decode for details
+// we need 3 packets
+
+  _extraSize=header1.bytes+header2.bytes+header3.bytes+3*sizeof(uint32_t);
+  _extraData=new uint8_t[_extraSize];
+
+  uint32_t *ex=(uint32_t *)_extraData;
+  uint8_t *d;
+  d=_extraData+sizeof(uint32_t)*3;
+  ex[0]=header1.bytes;
+  ex[1]=header2.bytes;
+  ex[2]=header3.bytes;
+  memcpy(d,header1.packet,ex[0]);
+  d+=ex[0];
+  memcpy(d,header2.packet,ex[1]);
+  d+=ex[1];
+  memcpy(d,header3.packet,ex[2]);
+  vorbis_comment_clear(&VC);
+			
+  printf("\n[Vorbis]Vorbis encoder initialized\n");
+  switch(vorbisConf->mode)
+  {
+    case ADM_VORBIS_VBR:
+      printf("[Vorbis]CBR Bitrate:%lu\n",config->bitrate);
+      break;
+    case ADM_VORBIS_QUALITY: //FIXME FIXME FIXME
+      printf("[Vorbis]VBR Quality:%.1f\n",vorbisConf->quality);
+    break;
+    default:
+      ADM_assert(0);
+  }
+   
+  printf("[Vorbis]Channels  :%lu\n",_wavheader->channels);
+  printf("[Vorbis]Frequency :%lu\n",_wavheader->frequency);
+  return 1;
+}
+
+#define ROUNDMAX 3000
+
+uint8_t	AUDMEncoder_Vorbis::getPacket(uint8_t *dest, uint32_t *len, uint32_t *samples)
+{
+  uint32_t nbout;
+  uint32_t consumed=0;
+  float **float_samples;
+  ogg_packet op ;
+
+  *len = 0;
+  _chunk=1024*_wavheader->channels;
+  int count=ROUNDMAX;
+// Check that we have packet from previous pass
+  while(count--)
+  {
+    if(!refillBuffer(_chunk ))
+    {
+      return 0; 
+    }
+        
+    if(tmptail-tmphead<_chunk)
+    {
+      return 0; 
+    }
+    
+	//printf("Round %d\n",ROUNDMAX-count);
+    if(vorbis_analysis_blockout(&VD, &VB) == 1) 
+    {
+      vorbis_analysis(&VB, NULL);
+      vorbis_bitrate_addblock(&VB) ;
+	//printf("Blockout\n");
+	
+      if(vorbis_bitrate_flushpacket(&VD, &op)) 
+      {
+        memcpy(dest, op.packet,op.bytes);
+        *len=op.bytes;
+        *samples=op.granulepos-_oldpos;
+        _oldpos=op.granulepos;
+        //  aprintf("1st packet :sampl:%lu len :%lu sample:%lu abs:%llu\n",*samples,op.bytes,total,op.granulepos);
+        return 1;
+      }
+    }
+
+    
+    uint32_t nbSample=(tmptail-tmphead)/_wavheader->channels;
+    if(nbSample>1024) nbSample=1024;
+    float_samples=vorbis_analysis_buffer(&VD, nbSample) ;
+    int index=tmphead;
+    // Put our samples in incoming buffer
+    reorderChannels(&(tmpbuffer[tmphead]), nbSample,_incoming->getChannelMapping(),outputChannelMapping);
+    for (int i = 0; i < nbSample; i++)
+      for (int j = 0; j < _wavheader->channels; j++) {
+      float_samples[j][i] = tmpbuffer[index++];
+      if (float_samples[j][i] > 1) float_samples[j][i] = 1;
+      if (float_samples[j][i] < -1) float_samples[j][i] = -1;
+      }
+      // Buffer full, go go go
+      vorbis_analysis_wrote(&VD, nbSample) ;  
+      tmphead+=nbSample*_wavheader->channels;	
+  }
+  return 0;
+	
+}
+/**
+      \fn DIA_getLameSettings
+      \brief Dialog to set lame settings
+      @return 1 on success, 0 on failure
+
+*/
+#include "DIA_factory.h"
+int DIA_getVorbisSettings(ADM_audioEncoderDescriptor *descriptor)
+  {
+    int ret=0;
+    char string[400];
+    uint32_t mmode,ppreset;
+    ELEM_TYPE_FLOAT qqual;
+#define SZT(x) sizeof(x)/sizeof(diaMenuEntry )
+#define PX(x) &(lameParam->x)
+    
+    
+   VORBIS_encoderParam *vorbisParam;
+  ADM_assert(sizeof(VORBIS_encoderParam)==descriptor->paramSize);
+  vorbisParam=(VORBIS_encoderParam*)descriptor->param;
+  
+    mmode=vorbisParam->mode;
+    qqual=(ELEM_TYPE_FLOAT)vorbisParam->quality;
+    
+    diaMenuEntry channelMode[]={
+                             {ADM_VORBIS_VBR,      QT_TR_NOOP("VBR"),NULL},
+                             {ADM_VORBIS_QUALITY,   QT_TR_NOOP("Quality based"),NULL}};
+          
+    diaElemMenu menuMode(&mmode,   QT_TR_NOOP("_Mode:"), SZT(channelMode),channelMode);
+    
+#define BITRATE(x) {x,QT_TR_NOOP(#x)}
+    diaMenuEntry bitrateM[]={
+                              BITRATE(56),
+                              BITRATE(64),
+                              BITRATE(80),
+                              BITRATE(96),
+                              BITRATE(112),
+                              BITRATE(128),
+                              BITRATE(160),
+                              BITRATE(192),
+                              BITRATE(224)
+                          };
+    diaElemMenu bitrate(&(descriptor->bitrate),   QT_TR_NOOP("_Bitrate:"), SZT(bitrateM),bitrateM);
+    
+    diaElemFloat quality(&qqual,QT_TR_NOOP("_Quality:"),-1.,10.);
+    
+    
+    
+  
+      diaElem *elems[]={&menuMode,&bitrate,&quality};
+    
+  if( diaFactoryRun(QT_TR_NOOP("Vorbis Configuration"),3,elems))
+  {
+    vorbisParam->mode=(ADM_VORBIS_MODE)mmode;
+    vorbisParam->quality=(float)qqual;
+    
+    return 1;
+  }
+  return 0;
+}  
+
+#endif		
+// EOF

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiocodec/ADM_ad_plugin.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiocodec/ADM_ad_plugin.h	2008-07-16 13:07:21 UTC (rev 4220)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiocodec/ADM_ad_plugin.h	2008-07-16 17:39:39 UTC (rev 4221)
@@ -5,7 +5,7 @@
 #ifndef ADM_ad_plugin_h
 #define ADM_ad_plugin_h
 #include "ADM_default.h"
-#include "../ADM_audio/ADM_audiodef.h"
+#include "ADM_coreAudio/include/ADM_coreAudio.h"
 #include "ADM_audiocodec.h"
 #include "../ADM_audio/aviaudio.hxx"
 

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/CMakeLists.txt	2008-07-16 13:07:21 UTC (rev 4220)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/CMakeLists.txt	2008-07-16 17:39:39 UTC (rev 4221)
@@ -3,6 +3,7 @@
 	)
 
 ADD_ADM_LIB_ALL_TARGETS(ADM_audiodevice ${ADM_audiodevice_SRCS})
+INCLUDE_DIRECTORIES(${CMAKE_SOURCE_DIR}/avidemux/ADM_coreAudio/include)
 
 #SDLify(ADM_deviceSDL.cpp)
 

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/CMakeLists.txt	2008-07-16 13:07:21 UTC (rev 4220)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/CMakeLists.txt	2008-07-16 17:39:39 UTC (rev 4221)
@@ -1,24 +1,11 @@
 SET(ADMaudiofilter_SRCS 
-	audiodeng_buildfilters.cpp  audioencoder_lavcodec.cpp  audioeng_process.cpp           audiofilter_film2pal.cpp   audiolib_sox.cpp
-	audioencoder_aften.cpp      audioencoder_pcm.cpp       audiofilter_bridge.cpp         audiofilter_limiter.cpp    audio_raw.cpp
-	audioencoder.cpp            audioencoder_twolame.cpp   audiofilter_buildchain.cpp     audiofilter_mixer.cpp
-	audioencoder_faac.cpp       audioencoder_vorbis.cpp    audiofilter_normalize.cpp
-	audioencoder_lame.cpp       audioeng_buff.cpp          audiofilter_dolby.cpp          audiofilter_sox.cpp)
+	audiodeng_buildfilters.cpp    audioeng_process.cpp           audiofilter_film2pal.cpp   audiolib_sox.cpp
+	audiofilter_bridge.cpp         audiofilter_limiter.cpp    audio_raw.cpp
+	audiofilter_buildchain.cpp     audiofilter_mixer.cpp
+	audiofilter_normalize.cpp
+	audioeng_buff.cpp          audiofilter_dolby.cpp          audiofilter_sox.cpp)
 	
 ADD_ADM_LIB_ALL_TARGETS(ADM_audiofilter ${ADMaudiofilter_SRCS})
+INCLUDE_DIRECTORIES(${CMAKE_SOURCE_DIR}/avidemux/ADM_coreAudio/include)
+INCLUDE_DIRECTORIES(${CMAKE_SOURCE_DIR}/avidemux/ADM_audioEncoder/include)
 
-IF (USE_AFTEN)
-	ADD_SOURCE_CFLAGS(audioencoder_aften.cpp -I${AFTEN_INCLUDE_DIR})
-ENDIF (USE_AFTEN)
-
-IF (USE_FAAC)
-	ADD_SOURCE_CFLAGS(audioencoder_faac.cpp -I${FAAC_INCLUDE_DIR})
-ENDIF (USE_FAAC)
-
-IF (HAVE_LIBMP3LAME)
-	ADD_SOURCE_CFLAGS(audioencoder_lame.cpp -I${LAME_INCLUDE_DIR})
-ENDIF (HAVE_LIBMP3LAME)
-
-IF (USE_VORBIS)
-	ADD_SOURCE_CFLAGS(audioencoder_vorbis.cpp -I${VORBIS_INCLUDE_DIR})
-ENDIF (USE_VORBIS)

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audiodeng_buildfilters.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audiodeng_buildfilters.cpp	2008-07-16 13:07:21 UTC (rev 4220)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audiodeng_buildfilters.cpp	2008-07-16 17:39:39 UTC (rev 4221)
@@ -29,7 +29,7 @@
 #include "ADM_audiofilter/audioeng_buildfilters.h"
 
 
-#include "ADM_audiofilter/audioencoder.h"
+#include "audioencoder.h"
 
 #include "ADM_audiocodec/ADM_audiocodeclist.h"
 

Deleted: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioencoder.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioencoder.cpp	2008-07-16 13:07:21 UTC (rev 4220)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioencoder.cpp	2008-07-16 17:39:39 UTC (rev 4221)
@@ -1,154 +0,0 @@
- 
-/***************************************************************************
-    copyright            : (C) 2002-6 by mean
-    email                : fixounet at free.fr
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#include "config.h"
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <math.h>
-
-#include "ADM_assert.h"
-
-#include "ADM_default.h"
-
-#include "audioprocess.hxx"
-#include "audioeng_process.h"
-#include "audioencoder.h"
-
-AUDMEncoder::AUDMEncoder(AUDMAudioFilter *in)  :AVDMGenericAudioStream  ()
-{
-  _wavheader = new WAVHeader;
-  _incoming=in;
-  memcpy(_wavheader, _incoming->getInfo(), sizeof(WAVHeader));
-  _wavheader->encoding=WAV_AAC;
-  _incoming->rewind();	// rewind
-  _extraData=NULL;
-  _extraSize=0;
-  tmpbuffer=new float[_wavheader->frequency*_wavheader->channels];
-  tmphead=tmptail=0;
-  eof_met=0;
-  
-};
-/********************/
-AUDMEncoder::~AUDMEncoder()
-{
-  cleanup();
-};
-/********************/
-uint8_t AUDMEncoder::cleanup(void)
-{
-  if(_wavheader) delete(_wavheader);
-  _wavheader=NULL;
-
-  if(_extraData) delete [] _extraData;
-  _extraData=NULL;
-  
-  if(tmpbuffer) delete [] tmpbuffer;
-  tmpbuffer=NULL;
-};
-/********************/
-
-uint8_t AUDMEncoder::refillBuffer(int minimum)
-{
-  uint32_t filler=_wavheader->frequency*_wavheader->channels;
-  uint32_t nb;
-  AUD_Status status;
-  if(eof_met) return 0;
-  while(1)
-  {
-    ADM_assert(tmptail>=tmphead);
-    if((tmptail-tmphead)>=minimum) return 1;
-  
-    if(tmphead && tmptail>filler/2)
-    {
-      memmove(&tmpbuffer[0],&tmpbuffer[tmphead],(tmptail-tmphead)*sizeof(float)); 
-      tmptail-=tmphead;
-      tmphead=0;
-    }
-    ADM_assert(filler>tmptail);
-    nb=_incoming->fill( (filler-tmptail)/2,&tmpbuffer[tmptail],&status);
-    if(!nb)
-    {
-      if(status!=AUD_END_OF_STREAM) ADM_assert(0);
-      
-      if((tmptail-tmphead)<minimum)
-      {
-        memset(&tmpbuffer[tmptail],0,sizeof(float)*(minimum-(tmptail-tmphead)));
-        tmptail=tmphead+minimum;
-        eof_met=1;  
-        return minimum;
-      }
-      else continue;
-    } else
-      tmptail+=nb;
-  }
-}
-
-
-/**
- * 	\fn reorderChannels
- *  \brief Reorder the channels
- */
-void AUDMEncoder::reorderChannels(float *data, uint32_t nb,CHANNEL_TYPE *input,CHANNEL_TYPE *output)
-{
-	float tmp [_wavheader->channels];
-	static uint8_t reorder[MAX_CHANNELS];
-	static bool reorder_on;
-	
-	
-		reorder_on = 0;
-		int j = 0;
-		// Should we reorder the channels (might be needed for encoder ?
-		if (_wavheader->channels > 2) 
-		{
-			CHANNEL_TYPE *p_ch_type;
-			for (int i = 0; i < _wavheader->channels; i++) 
-			{
-				for (int c = 0; c < _wavheader->channels; c++) 
-				{
-					if (input[c] == output[i]) 
-					{
-						if (j != c)
-							reorder_on = 1;
-						reorder[j++] = c;
-					}
-				}
-			}
-		}
-	
-
-	if (reorder_on)
-		for (int i = 0; i < nb; i++) {
-			memcpy(tmp, data, sizeof(tmp));
-			for (int c = 0; c < _wavheader->channels; c++)
-				*data++ = tmp[reorder[c]];
-		}
-
-}
-
-uint32_t AUDMEncoder::read(uint32_t len,uint8_t *buffer)
-{
-  ADM_assert(0);
-  return 0; 
-}
-
-uint32_t AUDMEncoder::grab(uint8_t * obuffer)
-{
-  uint32_t len,sam;
-  if(getPacket(obuffer,&len,&sam))
-    return len;
-  return MINUS_ONE;
-}
-
-//EOF

Deleted: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioencoder.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioencoder.h	2008-07-16 13:07:21 UTC (rev 4220)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioencoder.h	2008-07-16 17:39:39 UTC (rev 4221)
@@ -1,75 +0,0 @@
-/***************************************************************************
-    copyright            : (C) 2006 by mean
-    email                : fixounet at free.fr
- ***************************************************************************/
-
-
-#ifndef AUDIO_ENCODER_H
-#define AUDIO_ENCODER_H
-/*!
-  This structure defines an audio encoder
-  \param encoder Encoder attached to this descriptor
-   \param name The name of the codec
-  \param bitrate The bitrate in kb/s
-  \param configure Function to call to configure the codec
-  \param maxChannels The maximum # of channels this codec supports
-  \param param : An opaque structure that contains the codec specific configuration datas
-*/
-#include "ADM_coreAudio.h"
-#include "audioeng_buildfilters.h"
-
-typedef struct ADM_audioEncoderDescriptor
-{
-  AUDIOENCODER encoder;
-  int       (*configure)(ADM_audioEncoderDescriptor *descritor);
-  const     char *name;
-  uint32_t  bitrate;
-  uint32_t  maxChannels;
-  uint32_t  paramSize;
-  void     *param;
-} ADM_audioEncoderDescriptor;
-
-/*!
-  Base class for all audio encoder.It does the reverse of the bridge class and offers a proper GenericAudioStreamAPI
-
-*/
-
- //_____________________________________________
-class AUDMEncoder : public AVDMGenericAudioStream
-{
-  protected:
-    //
-    uint32_t grab(uint8_t *outbuffer);
-    uint32_t grab(float *outbuffer) {ADM_assert(0);return 1;}
-    uint32_t  eof_met;
-    uint32_t  _chunk;
-    //
-    uint8_t         *_extraData;
-    uint32_t        _extraSize;
-    AUDMAudioFilter *_incoming;
-    uint8_t         cleanup(void);
-    
-    float          *tmpbuffer;
-    uint8_t        refillBuffer(int minimum); // Mininum is in float
-
-    
-    void reorderChannels(float *data, uint32_t nb,CHANNEL_TYPE *input,CHANNEL_TYPE *output);
-
-    uint32_t       tmphead,tmptail;
-    // The encoder can remap the audio channel (or not). If so, let's store the the configuration here
-    CHANNEL_TYPE outputChannelMapping[MAX_CHANNELS];
-  public:
-    //
-    uint32_t read(uint32_t len,uint8_t *buffer);
-    uint32_t read(uint32_t len,float *buffer) {ADM_assert(0);return 1;}
-    //
-    virtual ~AUDMEncoder();
-    AUDMEncoder(AUDMAudioFilter *in);	
-    virtual uint8_t init(ADM_audioEncoderDescriptor *config)=0;
-    virtual uint8_t getPacket(uint8_t *dest, uint32_t *len, uint32_t *samples)=0;
-    virtual uint8_t packetPerFrame( void) {return 1;}
-    virtual uint8_t extraData(uint32_t *l,uint8_t **d) {*l=_extraSize;*d=_extraData;return 1;}
-            uint8_t  goTo(uint32_t timeMS) {ADM_assert(0);return 1;}
-};
-
-#endif

Deleted: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioencoder_aften.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioencoder_aften.cpp	2008-07-16 13:07:21 UTC (rev 4220)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioencoder_aften.cpp	2008-07-16 17:39:39 UTC (rev 4221)
@@ -1,166 +0,0 @@
-
-/***************************************************************************
-    copyright            : (C) 2002-6 by mean
-    email                : fixounet at free.fr
-
-    Interface to Aften
-
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#include "config.h"
-#ifdef USE_AFTEN
-#include "config.h"
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <math.h>
-
-
-#include "ADM_default.h"
-
-#include "audioprocess.hxx"
-#include "audioeng_process.h"
-#include "audioencoder.h"
-//
-extern "C"
-{
-#if defined(USE_AFTEN_06)
-	#include "aften.h"
-#else	// Aften 0.05 & 0.07 onwards
-	#include "aften/aften.h"
-#endif
-};
-#include "ADM_audiofilter/audioencoder_aften_param.h"
-#include "ADM_audiofilter/audioencoder_aften.h"
-
-#define _HANDLE ((AftenContext *)_handle)
-AUDMEncoder_Aften::AUDMEncoder_Aften(AUDMAudioFilter * instream)  :AUDMEncoder    (instream)
-{
-  uint32_t channels;
-  channels=instream->getInfo()->channels;
-  _handle=(void *)new AftenContext;
-  memset(_handle,0,sizeof(AftenContext));
-  aften_set_defaults(_HANDLE);
-  _wavheader->encoding=WAV_AC3;
-#if defined(USE_AFTEN_05) || defined(USE_AFTEN_06)
-#elif defined(USE_AFTEN_07)
-  _HANDLE->params.n_threads=1; // MThread collides with avidemux multithreading
-#else
-  _HANDLE->system.n_threads=1;
-#endif
-};
-
-
-AUDMEncoder_Aften::~AUDMEncoder_Aften()
-{
-    if(_handle)
-      aften_encode_close(_HANDLE);
-    delete(_HANDLE);
-    _handle=NULL;
-
-    printf("[Aften] Deleting aften\n");
-    cleanup();
-};
-
-
-//________________________________________________
-//   Init lame encoder
-// frequence    : Impose frequency , 0 means reuse the incoming fq
-// mode                         : ADM_STEREO etc...
-// bitrate              : Bitrate in kbps (96,192...)
-// return 0 : init failed
-//                              1 : init succeeded
-//_______________________________________________
-uint8_t AUDMEncoder_Aften::init(ADM_audioEncoderDescriptor *config)
-{
-
-
-int ret=0;
-
-#if defined(USE_AFTEN_05) || defined(USE_AFTEN_06)
-int mask;
-#else
-unsigned int mask;
-#endif
-
-    _wavheader->byterate=(config->bitrate*1000)/8;
-    _HANDLE->sample_format=A52_SAMPLE_FMT_FLT;
-    _HANDLE->channels=_wavheader->channels;
-    _HANDLE->samplerate=_wavheader->frequency;
-    
-    _HANDLE->params.bitrate=config->bitrate;
-    switch(_wavheader->channels)
-    {
-        case 1: mask = 0x04;  break;
-        case 2: mask = 0x03;  break;
-        case 3: mask = 0x07;  break;
-        case 4: mask = 0x107; break;
-        case 5: mask = 0x37;  break;
-        case 6: mask = 0x3F;  break;
-      }
-
-#if defined(USE_AFTEN_05) || defined(USE_AFTEN_06)
-	aften_wav_chmask_to_acmod(_wavheader->channels, mask, &(_HANDLE->acmod), &(_HANDLE->lfe));
-#else
-	aften_wav_channels_to_acmod(_wavheader->channels, mask, &(_HANDLE->acmod), &(_HANDLE->lfe));
-#endif
-
-   //   _HANDLE->params.verbose=2;
-    int er= aften_encode_init(_HANDLE);
-    if(er<0)
-    {
-      printf("[Aften] init error %d\n",er); 
-      return 0;
-    }
-    _chunk=256*6*_wavheader->channels;
-    printf("[Aften] Initialized with fd %u Channels %u bitrate %u\n",_HANDLE->samplerate,
-                                                                    _HANDLE->channels,_HANDLE->params.bitrate);
-    return 1;
-}
-
-
-//______________________________________________
-uint8_t	AUDMEncoder_Aften::getPacket(uint8_t *dest, uint32_t *len, uint32_t *samples)
-{
-  uint32_t count=0;
-  int r;
-  void *ptr;
-_again:
-        *len = 0;
-        _chunk=256*6*_wavheader->channels;
-        if(!refillBuffer(_chunk ))
-        {
-          return 0; 
-        }
-        ptr=(void *)&(tmpbuffer[tmphead]);
-        ADM_assert(tmptail>=tmphead);
-
-#ifdef USE_AFTEN_05
-		aften_remap_wav_to_a52(ptr, 256*6, _wavheader->channels, A52_SAMPLE_FMT_FLT, _HANDLE->acmod, _HANDLE->lfe);
-#else
-		aften_remap_wav_to_a52(ptr, 256*6, _wavheader->channels, A52_SAMPLE_FMT_FLT, _HANDLE->acmod);
-#endif
-
-        r=aften_encode_frame(_HANDLE, dest,(void *)ptr);
-        if(r<0)
-        {
-          printf("[Aften] Encoding error %d\n",r);
-          return 0; 
-        }
-        
-        *samples=256*6;
-        *len=r;
-        tmphead+=_chunk;
-        return 1;
-}
-
-#endif		
-// EOF

Deleted: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioencoder_aften.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioencoder_aften.h	2008-07-16 13:07:21 UTC (rev 4220)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioencoder_aften.h	2008-07-16 17:39:39 UTC (rev 4221)
@@ -1,31 +0,0 @@
-
-/***************************************************************************
-    copyright            : (C) 2002-6 by mean
-    email                : fixounet at free.fr
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#ifndef AUDMaudioAften
-#define AUDMaudioAften
-#ifdef USE_AFTEN
- //_____________________________________________
-class AUDMEncoder_Aften : public AUDMEncoder
-{
-protected:
-         void           *_handle;
-         
-public:
-                        uint8_t init(ADM_audioEncoderDescriptor *config);
-                virtual ~AUDMEncoder_Aften();
-                        AUDMEncoder_Aften(AUDMAudioFilter *instream);	
-                virtual uint8_t	getPacket(uint8_t *dest, uint32_t *len, uint32_t *samples);
-};
-#endif
-#endif

Deleted: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioencoder_aften_param.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioencoder_aften_param.h	2008-07-16 13:07:21 UTC (rev 4220)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioencoder_aften_param.h	2008-07-16 17:39:39 UTC (rev 4221)
@@ -1,10 +0,0 @@
-#ifndef AUDM_AFTEN_PARAM_H
-#define AUDM_AFTEN_PARAM_H
-#ifdef USE_AFTEN
-
-typedef struct AFTEN_encoderParam
-{
-  ADM_mode        mode;
-};
-#endif
-#endif

Deleted: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioencoder_config.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioencoder_config.h	2008-07-16 13:07:21 UTC (rev 4220)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioencoder_config.h	2008-07-16 17:39:39 UTC (rev 4221)
@@ -1,180 +0,0 @@
-#ifndef AUDIOENCODER_CONFIG_H
-#define AUDIOENCODER_CONFIG_H
-
-#include "audioencoder_faac_param.h"
-#include "audioencoder_lame_param.h"
-#include "audioencoder_twolame_param.h"
-#include "audioencoder_vorbis_param.h"
-#include "audioencoder_aften_param.h"
-
-
-
-extern int DIA_defaultSettings(ADM_audioEncoderDescriptor *descriptor);
-/**** Copy ****/
-
-ADM_audioEncoderDescriptor copyDescriptor=
-{
-  AUDIOENC_COPY,
-  DIA_defaultSettings,
-  "Copy encoder",
-  128,
-  99,
-  0,
-  NULL
-};
-/**** FAAC ****/
-#ifdef USE_FAAC
-FAAC_encoderParam aacParam={128};
-ADM_audioEncoderDescriptor aacDescriptor=
-{
-        AUDIOENC_FAAC,
-        DIA_defaultSettings,
-        "FAAC encoder",
-        128,
-        6,      // AAC can do 5.1
-        sizeof(aacParam),
-        &aacParam
-};
-#endif
-/**** LAME ****/
-LAME_encoderParam lameParam=
-{
-  ADM_LAME_PRESET_CBR,
-  ADM_STEREO,
-  2,
-  0 /* Reservoir enable by default */
-};
-#ifdef HAVE_LIBMP3LAME
-extern int DIA_getLameSettings(ADM_audioEncoderDescriptor *descriptor);
-ADM_audioEncoderDescriptor  lameDescriptor=
-{
-  AUDIOENC_MP3,
-  DIA_getLameSettings,
-  "Lame encoder",
-  128,
-  2,      // Lame can only do stereo
-  sizeof(lameParam),
-  &lameParam
-};
-#endif
-/**** TWOLAME ****/
-TWOLAME_encoderParam twolameParam=
-{
-  ADM_STEREO
-};
-ADM_audioEncoderDescriptor  twolameDescriptor=
-{
-  AUDIOENC_2LAME,
-  DIA_defaultSettings,
-  "TwoLame encoder",
-  128,
-  2,      // Lame can only do stereo
-  sizeof(twolameParam),
-  &twolameParam
-};
-/********** Lavcodec **************/
-ADM_audioEncoderDescriptor  lavcodecMP2Descriptor=
-{
-  AUDIOENC_MP2,
-  DIA_defaultSettings,
-  "LAvcodec MP2 encoder",
-  128,
-  2,    
-  0,
-  NULL
-};
-ADM_audioEncoderDescriptor  lavcodecAC3Descriptor=
-{
-  AUDIOENC_AC3,
-  DIA_defaultSettings,
-  "LAvcodec AC3 encoder",
-  128,
-  6,    
-  0,
-  NULL
-};
-
-/************** Vorbis **************/
-#ifdef USE_VORBIS
-extern int DIA_getVorbisSettings(ADM_audioEncoderDescriptor *descriptor);
-VORBIS_encoderParam vorbisParam=
-{
-  ADM_VORBIS_VBR,
-  3
-  
-};
-ADM_audioEncoderDescriptor  vorbisDescriptor=
-{
-  AUDIOENC_VORBIS,
-  DIA_getVorbisSettings,
-  "Vorbis encoder",
-  128,
-  6,      // Lame can only do stereo
-  sizeof(vorbisParam),
-  &vorbisParam
-};
-#endif
-/********** PCM **************/
-ADM_audioEncoderDescriptor  pcmDescriptor=
-{
-  AUDIOENC_NONE,
-  NULL,
-  "PCM encoder",
-  128,
-  6,    
-  0,
-  NULL
-};
-ADM_audioEncoderDescriptor  lpcmDescriptor=
-{
-  AUDIOENC_LPCM,
-  NULL,
-  "LPCM encoder",
-  128,
-  6,    
-  0,
-  NULL
-};
-//---------------- AFTEN ------------------
-#ifdef USE_AFTEN
-AFTEN_encoderParam aftenParam =
-{
-  ADM_STEREO
-};
-
-ADM_audioEncoderDescriptor  aftenDescriptor=
-{
-  AUDIOENC_AFTEN,
-  DIA_defaultSettings,
-  "Aften AC3 encoder",
-  128,
-  6,      // Lame can only do stereo
-  sizeof(aftenParam),
-  &aftenParam
-};
-#endif
-ADM_audioEncoderDescriptor *allDescriptors[]=
-{
-      &copyDescriptor,
-#ifdef USE_FAAC
-      &aacDescriptor,
-#endif
-      &twolameDescriptor,
-      &lavcodecAC3Descriptor,
-      &lavcodecMP2Descriptor,
-#ifdef USE_VORBIS
-      &vorbisDescriptor ,
-#endif      
-      &pcmDescriptor,
-      &lpcmDescriptor
-#ifdef USE_AFTEN
-      ,&aftenDescriptor
-#endif
-#ifdef HAVE_LIBMP3LAME
-      ,&lameDescriptor
-#endif
-};
-#define NB_AUDIO_DESCRIPTOR (sizeof(allDescriptors)/sizeof(ADM_audioEncoderDescriptor *))
-#endif
-//EOF
-

Deleted: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioencoder_faac.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioencoder_faac.cpp	2008-07-16 13:07:21 UTC (rev 4220)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioencoder_faac.cpp	2008-07-16 17:39:39 UTC (rev 4221)
@@ -1,223 +0,0 @@
-
-/***************************************************************************
-    copyright            : (C) 2002-6 by mean
-    email                : fixounet at free.fr
-
-    Interface to FAAC
-
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#include "config.h"
-#ifdef USE_FAAC
-#include "config.h"
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <math.h>
-
-
-#include "ADM_default.h"
-
-#include "audioprocess.hxx"
-#include "audioeng_process.h"
-#include "audioencoder.h"
-//
-
-#include "faac.h"
-#include "ADM_audiofilter/audioencoder_faac.h"
-
-AUDMEncoder_Faac::AUDMEncoder_Faac(AUDMAudioFilter * instream)  :AUDMEncoder    (instream)
-{
-  uint32_t channels;
-  channels=instream->getInfo()->channels;
-  switch(channels)
-  {
-    case 1:outputChannelMapping[1] = CH_FRONT_LEFT;break;
-    case 2:
-    	outputChannelMapping[0] = CH_FRONT_LEFT;
-    	outputChannelMapping[1] = CH_FRONT_RIGHT;
-      break;
-    default :
-    	outputChannelMapping[0] = CH_FRONT_CENTER;
-    	outputChannelMapping[1] = CH_FRONT_LEFT;
-    	outputChannelMapping[2] = CH_FRONT_RIGHT;
-    	outputChannelMapping[3] = CH_REAR_LEFT;
-    	outputChannelMapping[4] = CH_REAR_RIGHT;
-    	outputChannelMapping[5] = CH_LFE;
-  }
-};
-
-
-AUDMEncoder_Faac::~AUDMEncoder_Faac()
-{
-    if(_handle)
-        faacEncClose(_handle);
-    _handle=NULL;
-
-    printf("[FAAC] Deleting faac\n");
-    cleanup();
-};
-
-
-//________________________________________________
-//   Init lame encoder
-// frequence    : Impose frequency , 0 means reuse the incoming fq
-// mode                         : ADM_STEREO etc...
-// bitrate              : Bitrate in kbps (96,192...)
-// return 0 : init failed
-//                              1 : init succeeded
-//_______________________________________________
-uint8_t AUDMEncoder_Faac::init(ADM_audioEncoderDescriptor *config)
-{
-unsigned long int samples_input, max_bytes_output;
-faacEncConfigurationPtr cfg;
-int ret=0;
-
-    printf("[FAAC] Incoming Fq :%u\n",_wavheader->frequency);
-     _handle = faacEncOpen(_wavheader->frequency,
-                                 _wavheader->channels,
-                                 &samples_input,
-                                &max_bytes_output);
-    if(!_handle)
-    {
-          printf("Cannot open faac with fq=%lu chan=%lu br=%lu\n",
-          _wavheader->frequency,_wavheader->channels,config->bitrate);
-          return 0;
-    }
-    printf(" [FAAC] : Sample input:%d, max byte output%d \n",samples_input,max_bytes_output);
-    cfg= faacEncGetCurrentConfiguration(_handle);
-    
-    // Set default conf, same as ffmpeg
-    cfg->aacObjectType = LOW;
-    cfg->mpegVersion = MPEG4;
-    cfg->bandWidth= (_wavheader->frequency*3)/4; // Should be relevant
-    cfg->useTns = 0;
-    cfg->allowMidside = 0;
-    cfg->bitRate = (config->bitrate*1000)/_wavheader->channels; // It is per channel
-    cfg->outputFormat = 0; // 0 Raw 1 ADTS
-    cfg->inputFormat = FAAC_INPUT_FLOAT;
-    cfg->useLfe=0;	
-    if (!(ret=faacEncSetConfiguration(_handle, cfg))) 
-    {
-        printf("[FAAC] Cannot set conf for faac with fq=%lu chan=%lu br=%lu (err:%d)\n",
-				_wavheader->frequency,_wavheader->channels,config->bitrate,ret);
-	return 0;
-    }
-     unsigned char *data=NULL;
-     unsigned long size=0;
-     if((ret=faacEncGetDecoderSpecificInfo(_handle, &data,&size)))
-     {
-        printf("FAAC: GetDecoderSpecific info failed (err:%d)\n",ret);
-        return 0;
-     }
-     _extraSize=size;
-     _extraData=new uint8_t[size];
-     memcpy(_extraData,data,size);
-
-    // update
-     _wavheader->byterate=(config->bitrate*1000)/8;
-//    _wavheader->dwScale=1024;
-//    _wavheader->dwSampleSize=0;
-    _wavheader->blockalign=4096;
-    _wavheader->bitspersample=0;
-
-    _chunk=samples_input;
-
-
-    printf("[Faac] Initialized :\n");
-    
-    printf("[Faac]Version        : %s\n",cfg->name);
-    printf("[Faac]Bitrate        : %lu\n",cfg->bitRate);
-    printf("[Faac]Mpeg2 (1)/4(0) : %u\n",cfg->mpegVersion);
-    printf("[Faac]Use lfe      ) : %u\n",cfg->useLfe);
-    printf("[Faac]Sample output  : %lu\n",_chunk / _wavheader->channels);
-    printf("[Faac]Bitrate        : %lu\n",cfg->bitRate*_wavheader->channels);
-
-    
-    return 1;
-}
-
-//_____________________________________________
-//  Need to multiply the float by 32767, can't use
-//  generic fill buffer
-//----------------------------------------------
-uint8_t AUDMEncoder_Faac::refillBuffer(int minimum)
-{
-  uint32_t filler=_wavheader->frequency*_wavheader->channels;
-  uint32_t nb;
-  AUD_Status status;
-  if(eof_met) return 0;
-  while(1)
-  {
-    ADM_assert(tmptail>=tmphead);
-    if((tmptail-tmphead)>=minimum) return 1;
-  
-    if(tmphead && tmptail>filler/2)
-    {
-      memmove(&tmpbuffer[0],&tmpbuffer[tmphead],(tmptail-tmphead)*sizeof(float)); 
-      tmptail-=tmphead;
-      tmphead=0;
-    }
-    ADM_assert(filler>tmptail);
-    nb=_incoming->fill( (filler-tmptail)/2,&tmpbuffer[tmptail],&status);
-    if(!nb)
-    {
-      if(status!=AUD_END_OF_STREAM) ADM_assert(0);
-      
-      if((tmptail-tmphead)<minimum)
-      {
-        memset(&tmpbuffer[tmptail],0,sizeof(float)*(minimum-(tmptail-tmphead)));
-        tmptail=tmphead+minimum;
-        eof_met=1;  
-        return minimum;
-      }
-      else continue;
-    } else
-    {
-      float *s=&(tmpbuffer[tmptail]);
-      for(int i=0;i<nb;i++)
-      {
-        *s=*s*32767.;
-        s++;
-      }
-      tmptail+=nb;
-    }
-  }
-}
-
-#define FA_BUFFER_SIZE (SIZE_INTERNAL/4)
-//______________________________________________
-uint8_t	AUDMEncoder_Faac::getPacket(uint8_t *dest, uint32_t *len, uint32_t *samples)
-{
-  uint32_t count=0;
-_again:
-        *samples = _chunk/_wavheader->channels;
-        *len = 0;
-
-        if(!refillBuffer(_chunk ))
-        {
-          return 0; 
-        }
-        ADM_assert(tmptail>=tmphead);
-        reorderChannels(&(tmpbuffer[tmphead]),*samples,_incoming->getChannelMapping(),outputChannelMapping);
-        *len = faacEncEncode(_handle, (int32_t *)&(tmpbuffer[tmphead]), _chunk, dest, FA_BUFFER_SIZE);
-        if(!*len) 
-        {
-          count++;
-          if(count<20)
-            goto _again;
-          *samples=0;
-        }
-        tmphead+=_chunk;
-        return 1;
-}
-#endif		
-// EOF

Deleted: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioencoder_faac.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioencoder_faac.h	2008-07-16 13:07:21 UTC (rev 4220)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioencoder_faac.h	2008-07-16 17:39:39 UTC (rev 4221)
@@ -1,31 +0,0 @@
-
-/***************************************************************************
-    copyright            : (C) 2002-6 by mean
-    email                : fixounet at free.fr
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#ifndef AUDMaudioAAC
-#define AUDMaudioAAC
-
- //_____________________________________________
-class AUDMEncoder_Faac : public AUDMEncoder
-{
-protected:
-         void           *_handle;
-         uint8_t        refillBuffer(int minimum);
-public:
-                        uint8_t init(ADM_audioEncoderDescriptor *config);
-                virtual ~AUDMEncoder_Faac();
-                        AUDMEncoder_Faac(AUDMAudioFilter *instream);	
-                virtual uint8_t	getPacket(uint8_t *dest, uint32_t *len, uint32_t *samples);
-};
-
-#endif

Deleted: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioencoder_faac_param.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioencoder_faac_param.h	2008-07-16 13:07:21 UTC (rev 4220)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioencoder_faac_param.h	2008-07-16 17:39:39 UTC (rev 4221)
@@ -1,8 +0,0 @@
-
-#ifndef FAAC_PARAM_H
-#define FAAC_PARAM_H
-typedef struct 
-{
-  uint32_t dummy;
-}FAAC_encoderParam;
-#endif

Deleted: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioencoder_lame.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioencoder_lame.cpp	2008-07-16 13:07:21 UTC (rev 4220)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioencoder_lame.cpp	2008-07-16 17:39:39 UTC (rev 4221)
@@ -1,258 +0,0 @@
-/***************************************************************************
-    copyright            : (C) 2006 by mean
-    email                : fixounet at free.fr
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#include "config.h"
-
-#ifdef HAVE_LIBMP3LAME
-#include <lame/lame.h>
-
-#include "ADM_default.h"
-#include "audioprocess.hxx"
-#include "audioeng_process.h"
-#include "audioencoder.h"
-
-#include "ADM_audiofilter/audioencoder_lame_param.h"
-#include "ADM_audiofilter/audioencoder_lame.h"
-
-
-
-#define MYFLAGS (lame_global_flags *)lameFlags
-
-AUDMEncoder_Lame::AUDMEncoder_Lame(AUDMAudioFilter * instream)  :AUDMEncoder    (instream)
-{
-  printf("[Lame] Creating lame\n");
-  lameFlags=NULL;
-  _wavheader->encoding=WAV_MP3;
-};
-
-AUDMEncoder_Lame::~AUDMEncoder_Lame()
-{
-  printf("[Lame] Deleting lame\n");
-  if(lameFlags)
-  {
-    lame_close(MYFLAGS);
-  }
-  lameFlags=NULL;
-  cleanup();
-};
-
-
-//________________________________________________
-//   Init lame encoder
-// frequence    : Impose frequency , 0 means reuse the incoming fq
-// mode                         : ADM_STEREO etc...
-// bitrate              : Bitrate in kbps (96,192...)
-// return 0 : init failed
-//                              1 : init succeeded
-//_______________________________________________
-uint8_t AUDMEncoder_Lame::init(ADM_audioEncoderDescriptor *config)
-{
-  int ret;
-  MPEG_mode_e mmode;
-  uint32_t frequence;
-  LAME_encoderParam *lameConf=(LAME_encoderParam *)config->param;
-      ADM_assert(config->paramSize==sizeof(LAME_encoderParam));
-
-      lameFlags = lame_init();
-      if (lameFlags == NULL)
-          return 0;
-      
-      if(_incoming->getInfo()->channels>2)
-      {
-        printf("Too many channels\n");
-        return 0; 
-      }
-
-	// recompute output length
-	
-      
-      ret = lame_set_in_samplerate(MYFLAGS, _wavheader->frequency);
-      ret = lame_set_num_channels(MYFLAGS, _wavheader->channels);
-
-    
-      frequence = _wavheader->frequency;
-    printf("\n output frequency : %lu\n", frequence);
-    ret = lame_set_out_samplerate(MYFLAGS, frequence);
-
-    ret = lame_set_quality(MYFLAGS, 2);
-    
-    if (_wavheader->channels == 2)
-      {
-        switch (lameConf->mode)
-	    {
-	    case ADM_STEREO:
-		mmode = STEREO;
-		break;
-	    case ADM_JSTEREO:
-		mmode = JOINT_STEREO;
-		break;
-	    default:
-		printf("\n **** unknown mode ***\n");
-		mmode = STEREO;
-		break;
-
-	    }
-    } else
-    {
-		mmode = MONO;
-     	printf("\n mono audio mp3");
-  	}
-
-        ret = lame_set_brate(MYFLAGS, config->bitrate);
-        ret = lame_set_mode(MYFLAGS, mmode);	// 0 stereo 1 jstero
-        ret = lame_set_quality(MYFLAGS, lameConf->quality);	// 0 stereo 1 jstero
-        ret = lame_set_disable_reservoir(MYFLAGS,lameConf->disableReservoir);
-        printf("[Lame]Using quality of %d\n",lame_get_quality(MYFLAGS));
-        ret = lame_init_params(MYFLAGS);
-    if (ret == -1)
-	return 0;
-    // update bitrate in header
-    _wavheader->byterate = (config->bitrate >> 3) * 1000;
-#define BLOCK_SIZE 1152
-    // configure CBR/ABR/...
-    _preset=lameConf->preset;
-    switch(_preset)
-    {
-    	default:
-    	case ADM_LAME_PRESET_CBR: 
-          break;
-	case ADM_LAME_PRESET_ABR:
-	  
-          lame_set_preset( MYFLAGS, config->bitrate);
-	  _wavheader->blockalign=BLOCK_SIZE;
-	 break;
-	case ADM_LAME_PRESET_EXTREME: 
-	  _wavheader->blockalign=BLOCK_SIZE;
-          lame_set_preset( MYFLAGS, EXTREME);	
-	break;
-    
-    
-    }
-
-    lame_print_config(MYFLAGS);
-    lame_print_internals(MYFLAGS);
-    _chunk=BLOCK_SIZE*_wavheader->channels;
-    return 1;
-}
-uint8_t	AUDMEncoder_Lame::isVBR(void )
-{
-	if(_preset==ADM_LAME_PRESET_CBR) return 0;
-	return 1;
-
-}
-
-uint8_t	AUDMEncoder_Lame::getPacket(uint8_t *dest, uint32_t *len, uint32_t *samples)
-{
-  int32_t nbout;
-  
-        *samples = BLOCK_SIZE; //FIXME
-        *len = 0;
-
-        if(!refillBuffer(_chunk ))
-        {
-          return 0; 
-        }
-        
-        if(tmptail-tmphead<_chunk)
-        {
-          return 0; 
-        }
-        dither16(&(tmpbuffer[tmphead]),_chunk,_wavheader->channels);
-        ADM_assert(tmptail>=tmphead);
-        if (_wavheader->channels == 1)
-        {
-          nbout = lame_encode_buffer(MYFLAGS, (int16_t *)&(tmpbuffer[tmphead]),(int16_t *)&(tmpbuffer[tmphead]), _chunk, dest, 16 * 1024);
-          
-        }
-        else
-        {
-          nbout = lame_encode_buffer_interleaved(MYFLAGS, (int16_t *)&(tmpbuffer[tmphead]), _chunk/2, dest, 16 * 1024);
-        }
-        tmphead+=_chunk;
-        if (nbout < 0) {
-          printf("\n Error !!! : %ld\n", nbout);
-          return 0;
-        }
-        *len=nbout;
-        if(!*len) *samples=0;
-        //printf("Audio packet : size %u, sample %u\n",*len,*samples);
-        return 1;
-}
-/**
-      \fn DIA_getLameSettings
-      \brief Dialog to set lame settings
-      @return 1 on success, 0 on failure
-
-*/
-#include "DIA_factory.h"
-int DIA_getLameSettings(ADM_audioEncoderDescriptor *descriptor)
-  {
-    int ret=0;
-    char string[400];
-    uint32_t mmode,ppreset;
-#define SZT(x) sizeof(x)/sizeof(diaMenuEntry )
-#define PX(x) &(lameParam->x)
-    
-    
-    LAME_encoderParam *lameParam;
-    ADM_assert(sizeof(LAME_encoderParam)==descriptor->paramSize);
-  
-    lameParam=(LAME_encoderParam*)descriptor->param;
-    mmode=lameParam->mode;
-    ppreset=lameParam->preset;
-    diaMenuEntry channelMode[]={
-                             {ADM_STEREO,      QT_TR_NOOP("Stereo"),NULL},
-                             {ADM_JSTEREO,   QT_TR_NOOP("Joint stereo"),NULL},
-                             {ADM_MONO,      QT_TR_NOOP("Mono"),NULL}};
-          
-    diaElemMenu menuMode(&mmode,   QT_TR_NOOP("C_hannel mode:"), SZT(channelMode),channelMode);
-    
-    diaMenuEntry encodingMode[]={
-                             {ADM_LAME_PRESET_CBR,      QT_TR_NOOP("CBR"),NULL},
-                             {ADM_LAME_PRESET_ABR,   QT_TR_NOOP("ABR"),NULL},
-#if 0
-                             {ADM_LAME_PRESET_EXTREME,      QT_TR_NOOP("Extreme"),NULL}
-#endif
-    }; 
-    diaElemMenu Mode(&ppreset,   QT_TR_NOOP("Bit_rate mode:"), SZT(encodingMode),encodingMode);
-#define BITRATE(x) {x,QT_TR_NOOP(#x)}
-    diaMenuEntry bitrateM[]={
-                              BITRATE(56),
-                              BITRATE(64),
-                              BITRATE(80),
-                              BITRATE(96),
-                              BITRATE(112),
-                              BITRATE(128),
-                              BITRATE(160),
-                              BITRATE(192),
-                              BITRATE(224)
-                          };
-    diaElemMenu bitrate(&(descriptor->bitrate),   QT_TR_NOOP("_Bitrate:"), SZT(bitrateM),bitrateM);
-    
-    
-    
-    
-    diaElemUInteger quality(PX(quality),QT_TR_NOOP("_Quality:"),0,9);
-    diaElemToggle reservoir(PX(disableReservoir),QT_TR_NOOP("_Disable reservoir:"));
-  
-      diaElem *elems[]={&menuMode,&Mode,&quality,&bitrate,&reservoir};
-    
-  if( diaFactoryRun(QT_TR_NOOP("LAME Configuration"),5,elems))
-  {
-    lameParam->mode=(ADM_mode)mmode; 
-    lameParam->preset=(ADM_LAME_PRESET)ppreset;
-    return 1;
-  }
-  return 0;
-}  
-#endif

Deleted: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioencoder_lame.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioencoder_lame.h	2008-07-16 13:07:21 UTC (rev 4220)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioencoder_lame.h	2008-07-16 17:39:39 UTC (rev 4221)
@@ -1,35 +0,0 @@
-
-/***************************************************************************
-    copyright            : (C) 2002-6 by mean
-    email                : fixounet at free.fr
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#ifndef AUDMaudioLame
-#define AUDMaudioLame
-
- //_____________________________________________
-class AUDMEncoder_Lame : public AUDMEncoder
-{
-  protected:
-   
-    void              *lameFlags;
-    ADM_LAME_PRESET   _preset;
-         
-  public:
-            uint8_t     init(ADM_audioEncoderDescriptor *config);
-    virtual             ~AUDMEncoder_Lame();
-                        AUDMEncoder_Lame(AUDMAudioFilter *instream);	
-            uint8_t	isVBR(void );
-            
-   virtual uint8_t	getPacket(uint8_t *dest, uint32_t *len, uint32_t *samples);
-};
-
-#endif

Deleted: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioencoder_lame_param.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioencoder_lame_param.h	2008-07-16 13:07:21 UTC (rev 4220)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioencoder_lame_param.h	2008-07-16 17:39:39 UTC (rev 4221)
@@ -1,31 +0,0 @@
-#ifndef AUDM_LAME_PARAM_H
-#define AUDM_LAME_PARAM_H
-
-typedef enum 
-{
-  ADM_LAME_PRESET_CBR,
-  ADM_LAME_PRESET_ABR,
-  ADM_LAME_PRESET_EXTREME
-}ADM_LAME_PRESET;
-
-typedef struct 
-{
-  ADM_LAME_PRESET preset;
-  const char	*name;
-}ADM_PRESET_DEFINITION;
-static const ADM_PRESET_DEFINITION      presetDefinition[]=
-{
-  {ADM_LAME_PRESET_CBR,"CBR"},
-  {ADM_LAME_PRESET_ABR,"ABR"},
-  {ADM_LAME_PRESET_EXTREME,"Extreme"}
-};    
-
-typedef struct 
-{
-  ADM_LAME_PRESET preset;
-  ADM_mode        mode;
-  uint32_t        quality;
-  uint32_t        disableReservoir; // usefull for strict CBR (FLV)
-}LAME_encoderParam;
-
-#endif

Deleted: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioencoder_lavcodec.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioencoder_lavcodec.cpp	2008-07-16 13:07:21 UTC (rev 4220)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioencoder_lavcodec.cpp	2008-07-16 17:39:39 UTC (rev 4221)
@@ -1,149 +0,0 @@
-/***************************************************************************
-                        
-    copyright            : (C) 2002-2006 by mean
-    email                : fixounet at free.fr
-    
-    Interface to FFmpeg mpeg1/2 audio encoder
-    
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <math.h>
-
-#include "ADM_default.h"
-
-#include "audioprocess.hxx"
-#include "audioeng_process.h"
-#include "audioencoder.h"
-//
-#include "ADM_audiofilter/audioencoder_lavcodec.h"
-
-#include "ADM_lavcodec.h"
-
-#include "ADM_osSupport/ADM_debugID.h"
-#define MODULE_NAME MODULE_AUDIO_FILTER
-#include "ADM_osSupport/ADM_debug.h"
-
-
-#define CONTEXT ((AVCodecContext  	*)_context)
-
-
-// Ctor: Duplicate
-//__________
-
-AUDMEncoder_Lavcodec::AUDMEncoder_Lavcodec(uint32_t fourcc,AUDMAudioFilter * instream)  :AUDMEncoder    (instream)
-{
-  _fourcc=fourcc;
-  if(_fourcc!=WAV_MP2 && _fourcc!=WAV_AC3) ADM_assert(0);
-  _context=NULL;
-  _wavheader->encoding=_fourcc;
-  printf("[Lavcodec] Creating Lavcodec\n");
-};
-
-
-AUDMEncoder_Lavcodec::~AUDMEncoder_Lavcodec()
-{
-  printf("[Lavcodec] Deleting Lavcodec\n");
-  if(_context)
-  {
-    avcodec_close(CONTEXT);
-    ADM_dealloc(_context);
-  }
-  _context=NULL;
-  cleanup();
-};
-
-//________________________________________________
-//   Init lame encoder
-//_______________________________________________
-uint8_t AUDMEncoder_Lavcodec::init(ADM_audioEncoderDescriptor *config)
-{
-  int ret;
-  _context=( void *)avcodec_alloc_context();
-  _wavheader->byterate=(config->bitrate*1000)>>3;
-
-      
-  if(_fourcc==WAV_MP2 && _incoming->getInfo()->channels>2)
-  {
-    printf("[Lavcodec]Too many channels\n");
-    return 0; 
-  }
-  _wavheader->byterate=(config->bitrate*1000)>>3;         
-      
-  if(_fourcc==WAV_MP2)
-    _chunk = 1152*_wavheader->channels;
-  else
-    _chunk = 1536*_wavheader->channels; // AC3
-
-  printf("[Lavcodec]Incoming : fq : %lu, channel : %lu bitrate: %lu \n",
-         _wavheader->frequency,_wavheader->channels,config->bitrate);
-  
-  
-  CONTEXT->channels     =  _wavheader->channels;
-  CONTEXT->sample_rate  =  _wavheader->frequency;
-  CONTEXT->bit_rate     = (config->bitrate*1000); // bits -> kbits
-
-  AVCodec *codec;
-  CodecID codecID;
-  
-  if(_fourcc==WAV_MP2) codecID=CODEC_ID_MP2;
-        else codecID=CODEC_ID_AC3;
-  codec = avcodec_find_encoder(codecID);
-  ADM_assert(codec);
-  
-  ret = avcodec_open(CONTEXT, codec);
-  if (0> ret) 
-  {
-    printf("[Lavcodec] init failed err : %d!\n",ret);
-    return 0;
-  }
-
-
-  printf("[Lavcodec]Lavcodec successfully initialized\n");
-  return 1;       
-}
-//*********************************
-uint8_t	AUDMEncoder_Lavcodec::getPacket(uint8_t *dest, uint32_t *len, uint32_t *samples)
-{
-  uint32_t nbout;
-  
-  *samples = _chunk/_wavheader->channels; //FIXME
-  *len = 0;
-
-  if(!refillBuffer(_chunk ))
-  {
-    return 0; 
-  }
-        
-  if(tmptail-tmphead<_chunk)
-  {
-    return 0; 
-  }
-
-  dither16(&(tmpbuffer[tmphead]),_chunk,_wavheader->channels);
-
-  ADM_assert(tmptail>=tmphead);
-  nbout = avcodec_encode_audio(CONTEXT, dest, 5000, (short *) &(tmpbuffer[tmphead]));
-
-  tmphead+=_chunk;
-  if (nbout < 0) 
-  {
-    printf("[Lavcodec] Error !!! : %ld\n", nbout);
-    return 0;
-  }
-  *len=nbout;
-  return 1;
-}
-
-// EOF

Deleted: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioencoder_lavcodec.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioencoder_lavcodec.h	2008-07-16 13:07:21 UTC (rev 4220)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioencoder_lavcodec.h	2008-07-16 17:39:39 UTC (rev 4221)
@@ -1,32 +0,0 @@
-
-/***************************************************************************
-    copyright            : (C) 2002-6 by mean
-    email                : fixounet at free.fr
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#ifndef AUDMaudioLavcodec
-#define AUDMaudioLavcodec
- //_____________________________________________
-class AUDMEncoder_Lavcodec : public AUDMEncoder
-{
-  protected:
-   
-    void              *_context;
-    uint32_t          _fourcc;
-         
-  public:
-            uint8_t     init(ADM_audioEncoderDescriptor *config);
-   virtual             ~AUDMEncoder_Lavcodec();
-                        AUDMEncoder_Lavcodec(uint32_t fourcc,AUDMAudioFilter *instream);	
-   virtual uint8_t	getPacket(uint8_t *dest, uint32_t *len, uint32_t *samples);
-};
-
-#endif

Deleted: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioencoder_pcm.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioencoder_pcm.cpp	2008-07-16 13:07:21 UTC (rev 4220)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioencoder_pcm.cpp	2008-07-16 17:39:39 UTC (rev 4221)
@@ -1,114 +0,0 @@
-/***************************************************************************
-    copyright            : (C) 2006 by mean
-    email                : fixounet at free.fr
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <math.h>
-
-#include "ADM_default.h"
-
-#include "audioprocess.hxx"
-#include "audioeng_process.h"
-#include "audioencoder.h"
-//
-#include "ADM_audiofilter/audioencoder_pcm.h"
-
-
-#include "ADM_osSupport/ADM_debugID.h"
-#define MODULE_NAME MODULE_AUDIO_FILTER
-#include "ADM_osSupport/ADM_debug.h"
-
-
-
-
-// Ctor: Duplicate
-//__________
-
-AUDMEncoder_PCM::AUDMEncoder_PCM(uint32_t reverted,uint32_t fourCC,AUDMAudioFilter * instream)  :AUDMEncoder    (instream)
-{
-  printf("[PCM] Creating PCM\n");
-  ADM_assert(fourCC==WAV_PCM || fourCC==WAV_LPCM);
-  _wavheader->encoding=fourCC;
-  revert=reverted;
-};
-
-
-AUDMEncoder_PCM::~AUDMEncoder_PCM()
-{
-  printf("[PCM] Deleting PCM\n");
-  cleanup();
-};
-
-//________________________________________________
-//   Init lame encoder
-// frequence    : Impose frequency , 0 means reuse the incoming fq
-// mode                         : ADM_STEREO etc...
-// bitrate              : Bitrate in kbps (96,192...)
-// return 0 : init failed
-//                              1 : init succeeded
-//_______________________________________________
-uint8_t AUDMEncoder_PCM::init(ADM_audioEncoderDescriptor *config)
-{
-  
-  _wavheader->byterate=_wavheader->channels*_wavheader->frequency*2;
-  _chunk = (_wavheader->frequency/100)*_wavheader->channels*2;
-  
-
- 
-  printf("[PCM]Incoming :fq : %lu, channel : %lu \n",_wavheader->frequency,_wavheader->channels);
-  printf("[PCM]PCM successfully initialized\n");
-  return 1;       
-}
-
-uint8_t	AUDMEncoder_PCM::getPacket(uint8_t *dest, uint32_t *len, uint32_t *samples)
-{
-  uint32_t nbout;
-  
-  *samples = _chunk; //FIXME
-  *len = 0;
-
-  if(!refillBuffer(_chunk ))
-  {
-    return 0; 
-  }
-        
-  if(tmptail-tmphead<_chunk)
-  {
-    return 0; 
-  }
-        // Do in place replace
-  dither16(&(tmpbuffer[tmphead]),_chunk,_wavheader->channels);
-  if(!revert)
-    memcpy(dest,&(tmpbuffer[tmphead]),_chunk*2);
-  else
-  {
-    uint16_t *in,*out,tmp;
-    in=(uint16_t*)&(tmpbuffer[tmphead]);
-    out=(uint16_t *)dest;
-    for(int i=0;i<_chunk;i++)
-    {
-      tmp=*in++;
-      tmp=((tmp&0xff)<<8)+(tmp>>8);
-      *out++=tmp;
-    }
-  }
-  tmphead+=_chunk;
-  *len=_chunk*2;
-  *samples=_chunk/_wavheader->channels;
-  return 1;
-}
-
-
-// EOF

Deleted: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioencoder_pcm.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioencoder_pcm.h	2008-07-16 13:07:21 UTC (rev 4220)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioencoder_pcm.h	2008-07-16 17:39:39 UTC (rev 4221)
@@ -1,36 +0,0 @@
-/***************************************************************************
-    copyright            : (C) 2002-6 by mean
-    email                : fixounet at free.fr
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#ifndef AUDMaudioPCM
-#define AUDMaudioPCM
-
-/*!
-    This class is the float->PCM encoder.
-    It is somehow special as it can alsa be a LPCM encoder and a bigendian/littleendian swapper
-*/
-class AUDMEncoder_PCM : public AUDMEncoder
-{
-  protected:
-    uint32_t            revert;
-         
-  public:
-            uint8_t     init(ADM_audioEncoderDescriptor *config);
-            virtual     ~AUDMEncoder_PCM();
-                        /*! \param reverted : Should the endianness be reverted compared to system  
-                            \param fourCC   : FourCC to use (WAV_PCM/WAV_LPCM)
-                        */
-                         AUDMEncoder_PCM(uint32_t reverted,uint32_t fourCC,AUDMAudioFilter * instream);
-    virtual uint8_t	getPacket(uint8_t *dest, uint32_t *len, uint32_t *samples);
-};
-
-#endif

Deleted: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioencoder_twolame.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioencoder_twolame.cpp	2008-07-16 13:07:21 UTC (rev 4220)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioencoder_twolame.cpp	2008-07-16 17:39:39 UTC (rev 4221)
@@ -1,176 +0,0 @@
-/***************************************************************************
-    copyright            : (C) 2006 by mean
-    email                : fixounet at free.fr
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <math.h>
-
-#include "ADM_default.h"
-
-#include "audioprocess.hxx"
-#include "audioeng_process.h"
-#include "audioencoder.h"
-//
-#include "ADM_audiofilter/audioencoder_twolame.h"
-#include "ADM_audiofilter/audioencoder_twolame_param.h"
-
-extern "C"
-{
-#include "ADM_libraries/ADM_libtwolame/twolame.h"
-}
-#include "ADM_osSupport/ADM_debugID.h"
-#define MODULE_NAME MODULE_AUDIO_FILTER
-#include "ADM_osSupport/ADM_debug.h"
-
-
-#define OPTIONS (twolame_options_struct *)_twolameOptions
-
-// Ctor: Duplicate
-//__________
-
-AUDMEncoder_Twolame::AUDMEncoder_Twolame(AUDMAudioFilter * instream)  :AUDMEncoder    (instream)
-{
-  printf("[TwoLame] Creating Twolame\n");
-  _twolameOptions=NULL;
-  _wavheader->encoding=WAV_MP2;
-};
-
-
-AUDMEncoder_Twolame::~AUDMEncoder_Twolame()
-{
-  printf("[TwoLame] Deleting TwoLame\n");
-  if(_twolameOptions)
-  {
-    twolame_close((twolame_options_struct **)&_twolameOptions);
-  }
-  _twolameOptions=NULL;
-  cleanup();
-};
-
-//________________________________________________
-//   Init lame encoder
-// frequence    : Impose frequency , 0 means reuse the incoming fq
-// mode                         : ADM_STEREO etc...
-// bitrate              : Bitrate in kbps (96,192...)
-// return 0 : init failed
-//                              1 : init succeeded
-//_______________________________________________
-uint8_t AUDMEncoder_Twolame::init(ADM_audioEncoderDescriptor *config)
-{
-  int ret;
-  TWOLAME_MPEG_mode mmode;    	
-  uint32_t frequence;
-  TWOLAME_encoderParam *lameConf=(TWOLAME_encoderParam *)config->param;
-  ADM_assert(config->paramSize==sizeof(TWOLAME_encoderParam));
-
-  _twolameOptions = twolame_init();
-  if (_twolameOptions == NULL)
-    return 0;
-      
-  if(_wavheader->channels>2)
-  {
-    printf("[TwoLame]Too many channels\n");
-    return 0; 
-  }
-  _wavheader->byterate=(config->bitrate*1000)>>3;         
-      
- 
-  _chunk = 1152*_wavheader->channels;
-
- 
-  printf("[TwoLame]Incoming :fq : %lu, channel : %lu bitrate: %lu \n",
-        _wavheader->frequency,_wavheader->channels,config->bitrate);
-		
- 
-  twolame_set_in_samplerate(OPTIONS, _wavheader->frequency);
-  twolame_set_out_samplerate (OPTIONS, _wavheader->frequency);
-  twolame_set_num_channels(OPTIONS, _wavheader->channels);
-  if(_wavheader->channels==1) mmode=TWOLAME_MONO;
-  else
-    switch (lameConf->mode)
-  {
-    case ADM_STEREO:
-      mmode = TWOLAME_STEREO;
-      break;
-    case ADM_JSTEREO:
-      mmode = TWOLAME_JOINT_STEREO;
-      break;
-    case ADM_MONO:
-      mmode=TWOLAME_MONO;
-      break;
-				
-    default:
-      printf("\n **** unknown mode, going stereo ***\n");
-      mmode = TWOLAME_STEREO;
-      break;
-
-  }
-  twolame_set_mode(OPTIONS,mmode);
-  twolame_set_error_protection(OPTIONS,TRUE);	
-    	//toolame_setPadding (options,TRUE);
-  twolame_set_bitrate (OPTIONS,config->bitrate);
-  twolame_set_verbosity(OPTIONS, 2);
-  if(twolame_init_params(OPTIONS))
-  {
-    printf("[TwoLame]Twolame init failed\n");
-    return 0;
-  }
-	
- 
-
-  printf("[TwoLame]Libtoolame successfully initialized\n");
-  return 1;       
-}
-
-uint8_t	AUDMEncoder_Twolame::getPacket(uint8_t *dest, uint32_t *len, uint32_t *samples)
-{
-  int nbout;
-  
-  *samples = 1152; //FIXME
-  *len = 0;
-  ADM_assert(tmptail>=tmphead);
-  if(!refillBuffer(_chunk ))
-  {
-    return 0; 
-  }
-        
-  if(tmptail-tmphead<_chunk)
-  {
-    return 0; 
-  }
-
-  dither16(&(tmpbuffer[tmphead]),_chunk,_wavheader->channels);
-
-  ADM_assert(tmptail>=tmphead);
-  if (_wavheader->channels == 1)
-  {
-    nbout =twolame_encode_buffer(OPTIONS, (int16_t *)&(tmpbuffer[tmphead]),(int16_t *)&(tmpbuffer[tmphead]), _chunk, dest, 16 * 1024);
-  }
-  else
-  {
-    nbout = twolame_encode_buffer_interleaved(OPTIONS, (int16_t *)&(tmpbuffer[tmphead]), _chunk/2, dest, 16 * 1024);
-  }
-  tmphead+=_chunk;
-  ADM_assert(tmptail>=tmphead);
-  if (nbout < 0) {
-    printf("\n Error !!! : %ld\n", nbout);
-    return 0;
-  }
-  *len=nbout;
-  return 1;
-}
-
-
-// EOF

Deleted: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioencoder_twolame.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioencoder_twolame.h	2008-07-16 13:07:21 UTC (rev 4220)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioencoder_twolame.h	2008-07-16 17:39:39 UTC (rev 4221)
@@ -1,30 +0,0 @@
-/***************************************************************************
-    copyright            : (C) 2002-6 by mean
-    email                : fixounet at free.fr
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#ifndef AUDMaudioTwoLame
-#define AUDMaudioTwoLame
-
- //_____________________________________________
-class AUDMEncoder_Twolame : public AUDMEncoder
-{
-  protected:
-    void           *_twolameOptions;
-         
-  public:
-            uint8_t     init(ADM_audioEncoderDescriptor *config);
-    virtual             ~AUDMEncoder_Twolame();
-                        AUDMEncoder_Twolame(AUDMAudioFilter *instream);	
-    virtual uint8_t	getPacket(uint8_t *dest, uint32_t *len, uint32_t *samples);
-};
-
-#endif

Deleted: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioencoder_twolame_param.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioencoder_twolame_param.h	2008-07-16 13:07:21 UTC (rev 4220)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioencoder_twolame_param.h	2008-07-16 17:39:39 UTC (rev 4221)
@@ -1,10 +0,0 @@
-#ifndef AUDM_TWOLAME_PARAM_H
-#define AUDM_TWOLAME_PARAM_H
-
-
-typedef struct 
-{
-  ADM_mode        mode;
-}TWOLAME_encoderParam;
-
-#endif

Deleted: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioencoder_vorbis.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioencoder_vorbis.cpp	2008-07-16 13:07:21 UTC (rev 4220)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioencoder_vorbis.cpp	2008-07-16 17:39:39 UTC (rev 4221)
@@ -1,307 +0,0 @@
-/***************************************************************************
-    copyright            : (C) 2006 by mean
-    email                : fixounet at free.fr
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#include "config.h"
-#ifdef USE_VORBIS
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <math.h>
-
-#include "ADM_default.h"
-
-#include "audioprocess.hxx"
-#include "audioeng_process.h"
-#include "audioencoder.h"
-//
-#include "ADM_audiofilter/audioencoder_vorbis_param.h"
-#include "ADM_audiofilter/audioencoder_vorbis.h"
-
-
-#include "vorbis/vorbisenc.h"
-#include "ADM_osSupport/ADM_debugID.h"
-#define MODULE_NAME MODULE_AUDIO_FILTER
-#include "ADM_osSupport/ADM_debug.h"
-
-
-#define OPTIONS (twolame_options_struct *)_twolameOptions
-
-#define VD (((vorbisStruct *)_handle)->vd)
-#define VI (((vorbisStruct *)_handle)->vi)
-#define VB (((vorbisStruct *)_handle)->vb)
-#define VC (((vorbisStruct *)_handle)->vc)
-typedef struct vorbisStruct
-{ 
-	vorbis_info 	 vi ;
-	vorbis_dsp_state vd ;
-	vorbis_block     vb ;
-	vorbis_comment   vc ;
-}vorbisStruct;
-//__________
-
-AUDMEncoder_Vorbis::AUDMEncoder_Vorbis(AUDMAudioFilter * instream)  :AUDMEncoder    (instream)
-{
-  printf("[Vorbis] Creating Vorbis\n");
-  _handle=NULL;
-  _wavheader->encoding=WAV_OGG;
-  _oldpos=0;
-  _handle=(void *)new  vorbisStruct; 
-  outputChannelMapping[0] = CH_FRONT_LEFT;
-  outputChannelMapping[1] = CH_FRONT_RIGHT;
-  outputChannelMapping[2] = CH_REAR_LEFT;
-  outputChannelMapping[3] = CH_REAR_RIGHT;
-  outputChannelMapping[4] = CH_FRONT_CENTER;
-  outputChannelMapping[5] = CH_LFE;
-};
-
-
-AUDMEncoder_Vorbis::~AUDMEncoder_Vorbis()
-{
-  printf("[Vorbis] Deleting Vorbis\n");
-  if(_handle)
-  {
-    vorbis_block_clear(&VB);
-    vorbis_dsp_clear(&VD);
-    vorbis_info_clear(&VI);
-    delete (vorbisStruct *)_handle;
-  }    	
-  _handle=NULL;
-  
-  cleanup();
-};
-
-//________________________________________________
-//   Init lame encoder
-// frequence    : Impose frequency , 0 means reuse the incoming fq
-// mode                         : ADM_STEREO etc...
-// bitrate              : Bitrate in kbps (96,192...)
-// return 0 : init failed
-//                              1 : init succeeded
-//_______________________________________________
-uint8_t AUDMEncoder_Vorbis::init(ADM_audioEncoderDescriptor *config)
-{
-  int ret;
-  VORBIS_encoderParam *vorbisConf=(VORBIS_encoderParam *)config->param;
-  ADM_assert(config->paramSize==sizeof(VORBIS_encoderParam));
-
-  ogg_packet header1,header2,header3;
-  int err;
-
-  
-  
-  vorbis_info_init(&VI) ;
-
-  switch(vorbisConf->mode)
-  {
-    
-    case ADM_VORBIS_VBR:
-                      err=vorbis_encode_init(&VI,
-                              _wavheader->channels,
-                              _wavheader->frequency,
-                              -1, // Max bitrate      
-                              config->bitrate*1000, //long nominal_bitrate,
-                              -1 //long min_bitrate))
-                            );
-                      break;
-    case  ADM_VORBIS_QUALITY :
-                    err=vorbis_encode_init_vbr(&VI,
-                                _wavheader->channels,
-                                _wavheader->frequency,
-                                vorbisConf->quality/10
-                              );
-                    break;
-      
-    default:
-      ADM_assert(0);
-  }
-  if (err!=0) 
-  {
-	  delete (vorbisStruct*)_handle;
-	  _handle = NULL;
-
-    printf("[vorbis] init error %d\n",err);
-    return 0;
-  }
-  vorbis_analysis_init(&VD, &VI) ;
-  vorbis_block_init(&VD, &VB);
-  vorbis_comment_init(&VC);
-  vorbis_comment_add_tag(&VC, "encoder", "AVIDEMUX2") ;
-
-  vorbis_analysis_headerout(&VD, &VC, &header1,
-                             &header2, &header3);
-
-
-// Store all headers as extra data
-// see ogg vorbis decode for details
-// we need 3 packets
-
-  _extraSize=header1.bytes+header2.bytes+header3.bytes+3*sizeof(uint32_t);
-  _extraData=new uint8_t[_extraSize];
-
-  uint32_t *ex=(uint32_t *)_extraData;
-  uint8_t *d;
-  d=_extraData+sizeof(uint32_t)*3;
-  ex[0]=header1.bytes;
-  ex[1]=header2.bytes;
-  ex[2]=header3.bytes;
-  memcpy(d,header1.packet,ex[0]);
-  d+=ex[0];
-  memcpy(d,header2.packet,ex[1]);
-  d+=ex[1];
-  memcpy(d,header3.packet,ex[2]);
-  vorbis_comment_clear(&VC);
-			
-  printf("\n[Vorbis]Vorbis encoder initialized\n");
-  switch(vorbisConf->mode)
-  {
-    case ADM_VORBIS_VBR:
-      printf("[Vorbis]CBR Bitrate:%lu\n",config->bitrate);
-      break;
-    case ADM_VORBIS_QUALITY: //FIXME FIXME FIXME
-      printf("[Vorbis]VBR Quality:%.1f\n",vorbisConf->quality);
-    break;
-    default:
-      ADM_assert(0);
-  }
-   
-  printf("[Vorbis]Channels  :%lu\n",_wavheader->channels);
-  printf("[Vorbis]Frequency :%lu\n",_wavheader->frequency);
-  return 1;
-}
-
-#define ROUNDMAX 3000
-
-uint8_t	AUDMEncoder_Vorbis::getPacket(uint8_t *dest, uint32_t *len, uint32_t *samples)
-{
-  uint32_t nbout;
-  uint32_t consumed=0;
-  float **float_samples;
-  ogg_packet op ;
-
-  *len = 0;
-  _chunk=1024*_wavheader->channels;
-  int count=ROUNDMAX;
-// Check that we have packet from previous pass
-  while(count--)
-  {
-    if(!refillBuffer(_chunk ))
-    {
-      return 0; 
-    }
-        
-    if(tmptail-tmphead<_chunk)
-    {
-      return 0; 
-    }
-    
-	//printf("Round %d\n",ROUNDMAX-count);
-    if(vorbis_analysis_blockout(&VD, &VB) == 1) 
-    {
-      vorbis_analysis(&VB, NULL);
-      vorbis_bitrate_addblock(&VB) ;
-	//printf("Blockout\n");
-	
-      if(vorbis_bitrate_flushpacket(&VD, &op)) 
-      {
-        memcpy(dest, op.packet,op.bytes);
-        *len=op.bytes;
-        *samples=op.granulepos-_oldpos;
-        _oldpos=op.granulepos;
-        //  aprintf("1st packet :sampl:%lu len :%lu sample:%lu abs:%llu\n",*samples,op.bytes,total,op.granulepos);
-        return 1;
-      }
-    }
-
-    
-    uint32_t nbSample=(tmptail-tmphead)/_wavheader->channels;
-    if(nbSample>1024) nbSample=1024;
-    float_samples=vorbis_analysis_buffer(&VD, nbSample) ;
-    int index=tmphead;
-    // Put our samples in incoming buffer
-    reorderChannels(&(tmpbuffer[tmphead]), nbSample,_incoming->getChannelMapping(),outputChannelMapping);
-    for (int i = 0; i < nbSample; i++)
-      for (int j = 0; j < _wavheader->channels; j++) {
-      float_samples[j][i] = tmpbuffer[index++];
-      if (float_samples[j][i] > 1) float_samples[j][i] = 1;
-      if (float_samples[j][i] < -1) float_samples[j][i] = -1;
-      }
-      // Buffer full, go go go
-      vorbis_analysis_wrote(&VD, nbSample) ;  
-      tmphead+=nbSample*_wavheader->channels;	
-  }
-  return 0;
-	
-}
-/**
-      \fn DIA_getLameSettings
-      \brief Dialog to set lame settings
-      @return 1 on success, 0 on failure
-
-*/
-#include "DIA_factory.h"
-int DIA_getVorbisSettings(ADM_audioEncoderDescriptor *descriptor)
-  {
-    int ret=0;
-    char string[400];
-    uint32_t mmode,ppreset;
-    ELEM_TYPE_FLOAT qqual;
-#define SZT(x) sizeof(x)/sizeof(diaMenuEntry )
-#define PX(x) &(lameParam->x)
-    
-    
-   VORBIS_encoderParam *vorbisParam;
-  ADM_assert(sizeof(VORBIS_encoderParam)==descriptor->paramSize);
-  vorbisParam=(VORBIS_encoderParam*)descriptor->param;
-  
-    mmode=vorbisParam->mode;
-    qqual=(ELEM_TYPE_FLOAT)vorbisParam->quality;
-    
-    diaMenuEntry channelMode[]={
-                             {ADM_VORBIS_VBR,      QT_TR_NOOP("VBR"),NULL},
-                             {ADM_VORBIS_QUALITY,   QT_TR_NOOP("Quality based"),NULL}};
-          
-    diaElemMenu menuMode(&mmode,   QT_TR_NOOP("_Mode:"), SZT(channelMode),channelMode);
-    
-#define BITRATE(x) {x,QT_TR_NOOP(#x)}
-    diaMenuEntry bitrateM[]={
-                              BITRATE(56),
-                              BITRATE(64),
-                              BITRATE(80),
-                              BITRATE(96),
-                              BITRATE(112),
-                              BITRATE(128),
-                              BITRATE(160),
-                              BITRATE(192),
-                              BITRATE(224)
-                          };
-    diaElemMenu bitrate(&(descriptor->bitrate),   QT_TR_NOOP("_Bitrate:"), SZT(bitrateM),bitrateM);
-    
-    diaElemFloat quality(&qqual,QT_TR_NOOP("_Quality:"),-1.,10.);
-    
-    
-    
-  
-      diaElem *elems[]={&menuMode,&bitrate,&quality};
-    
-  if( diaFactoryRun(QT_TR_NOOP("Vorbis Configuration"),3,elems))
-  {
-    vorbisParam->mode=(ADM_VORBIS_MODE)mmode;
-    vorbisParam->quality=(float)qqual;
-    
-    return 1;
-  }
-  return 0;
-}  
-
-#endif		
-// EOF

Deleted: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioencoder_vorbis.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioencoder_vorbis.h	2008-07-16 13:07:21 UTC (rev 4220)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioencoder_vorbis.h	2008-07-16 17:39:39 UTC (rev 4221)
@@ -1,35 +0,0 @@
-
-/***************************************************************************
-    copyright            : (C) 2002-6 by mean
-    email                : fixounet at free.fr
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#ifndef AUDMaudioVorbis
-#define AUDMaudioVorbis
-
- //_____________________________________________
-class AUDMEncoder_Vorbis : public AUDMEncoder
-{
-  protected:
-   
-    void              *_handle;
-    uint64_t          _oldpos;
-
-         
-  public:
-            uint8_t     init(ADM_audioEncoderDescriptor *config);
-            virtual     ~AUDMEncoder_Vorbis();
-                        AUDMEncoder_Vorbis(AUDMAudioFilter *instream);	
-            
-   virtual uint8_t	getPacket(uint8_t *dest, uint32_t *len, uint32_t *samples);
-};
-
-#endif

Deleted: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioencoder_vorbis_param.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioencoder_vorbis_param.h	2008-07-16 13:07:21 UTC (rev 4220)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioencoder_vorbis_param.h	2008-07-16 17:39:39 UTC (rev 4221)
@@ -1,17 +0,0 @@
-#ifndef AUDM_VORBIS_PARAM_H
-#define AUDM_VORBIS_PARAM_H
-
-typedef enum 
-{
-  ADM_VORBIS_CBR,
-  ADM_VORBIS_VBR,
-  ADM_VORBIS_QUALITY
-  
-}ADM_VORBIS_MODE;
-
-typedef struct 
-{
-  ADM_VORBIS_MODE    mode;   // 0 cbr 1 vbr 2 quality
-  float              quality;
-}VORBIS_encoderParam;
-#endif

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioeng_buildfilters.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioeng_buildfilters.h	2008-07-16 13:07:21 UTC (rev 4220)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioeng_buildfilters.h	2008-07-16 17:39:39 UTC (rev 4221)
@@ -37,23 +37,9 @@
 void audioFilter_MP3DisableReservoir(int onoff);
 uint32_t audioFilter_getOuputCodec(void);
 uint32_t audioFilter_getOuputFrequency(uint32_t inputFrequency);
-typedef enum 
-{
-	AUDIOENC_NONE,
-	AUDIOENC_MP3,
-	AUDIOENC_MP2,
-	AUDIOENC_AC3,
-	AUDIOENC_2LAME,
-	AUDIOENC_FAAC,
-	AUDIOENC_VORBIS,
-        AUDIOENC_COPY,
-        AUDIOENC_LPCM,
-#ifdef USE_AFTEN        
-        AUDIOENC_AFTEN,
-#endif        
-	AUDIOENC_DUMMY
-}AUDIOENCODER;
 
+#include "ADM_audioEncoder/include/audioencoder_enum.h"
+
 typedef enum 
 {
 	RESAMPLING_NONE=0,

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioeng_process.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioeng_process.h	2008-07-16 13:07:21 UTC (rev 4220)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioeng_process.h	2008-07-16 17:39:39 UTC (rev 4221)
@@ -19,7 +19,7 @@
 #define __Audio_ENG_Process__
 
 #define AUD_PROCESS_BUFFER_SIZE 48000*2*4 // should be enougth 4 seconds of stereo
-#include "ADM_audio/ADM_audiodef.h"
+#include "ADM_coreAudio/include/ADM_coreAudio.h"
 /**
   This enumerate is used to give a more accurate error when no audio is output from
   an audio filter.

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audiofilter_buildchain.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audiofilter_buildchain.cpp	2008-07-16 13:07:21 UTC (rev 4220)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audiofilter_buildchain.cpp	2008-07-16 17:39:39 UTC (rev 4221)
@@ -21,38 +21,38 @@
 
 #include "ADM_audio/audiomode.hxx"
 #include "ADM_audiofilter/audiofilter_limiter_param.h"
-#include "ADM_audiofilter/audioencoder_lame_param.h"
-#include "ADM_audiofilter/audioencoder_twolame_param.h"
-#include "ADM_audiofilter/audioencoder_faac_param.h"
-#include "ADM_audiofilter/audioencoder_vorbis_param.h"
-#include "ADM_audiofilter/audioencoder_aften_param.h"
-#include "ADM_audiofilter/audiofilter_normalize_param.h"
+#include "audioencoder_lame_param.h"
+#include "audioencoder_twolame_param.h"
+#include "audioencoder_faac_param.h"
+#include "audioencoder_vorbis_param.h"
+#include "audioencoder_aften_param.h"
+#include "audiofilter_normalize_param.h"
 
 #include "audioprocess.hxx"
 #include "ADM_audiofilter/audioeng_buildfilters.h"
 #include "ADM_audiofilter/audio_raw.h"
 
 /* ************* Encoder *********** */
-#include "ADM_audiofilter/audioencoder.h"
+#include "audioencoder.h"
 #ifdef USE_FAAC
-#include "ADM_audiofilter/audioencoder_faac.h"
+#include "audioencoder_faac.h"
 #endif
 #ifdef HAVE_LIBMP3LAME
-#include "ADM_audiofilter/audioencoder_lame.h"
+#include "audioencoder_lame.h"
 #endif
 #ifdef USE_VORBIS
-#include "ADM_audiofilter/audioencoder_vorbis.h"
+#include "audioencoder_vorbis.h"
 #endif
 #ifdef USE_AFTEN
-#include "ADM_audiofilter/audioencoder_aften.h"
+#include "audioencoder_aften.h"
 #endif
 
-#include "ADM_audiofilter/audioencoder_twolame.h"
-#include "ADM_audiofilter/audioencoder_lavcodec.h"
+#include "audioencoder_twolame.h"
+#include "audioencoder_lavcodec.h"
 
 
 #include "ADM_audiocodec/ADM_audiocodeclist.h"
-#include "ADM_audiofilter/audioencoder_pcm.h"
+#include "audioencoder_pcm.h"
 
 #include "prefs.h"
 

Deleted: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_core/include/ADM_coreAudio.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_core/include/ADM_coreAudio.h	2008-07-16 13:07:21 UTC (rev 4220)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_core/include/ADM_coreAudio.h	2008-07-16 17:39:39 UTC (rev 4221)
@@ -1,19 +0,0 @@
-/**
-        \file ADM_audioCore.h
-
-*/
-#ifndef ADM_audioCore_H
-#define ADM_audioCore_H
-
-
-
-#define DITHER_SIZE 4800
-#define DITHER_CHANNELS 6
-void            AUDMEncoder_initDither();
-void dither16(float *start, uint32_t nb, uint8_t channels);
-
-
-
-#endif
-//EOF
-

Deleted: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_core/src/ADM_audioUtils.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_core/src/ADM_audioUtils.cpp	2008-07-16 13:07:21 UTC (rev 4220)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_core/src/ADM_audioUtils.cpp	2008-07-16 17:39:39 UTC (rev 4221)
@@ -1,48 +0,0 @@
-/**
-    \fn ADM_audioUtils.cpp
-    \brief Will be moved later to ADM_coreAudio
-
-
-*/
-#include "ADM_default.h"
-#include "ADM_coreAudio.h"
-#include <math.h>
-
-static float rand_table[DITHER_CHANNELS][DITHER_SIZE];
-
-void AUDMEncoder_initDither(void)
-{
-  printf("Initializing Dithering tables\n");
-	float d, dp;
-	for (int c = 0; c < DITHER_CHANNELS; c++) {
-		dp = 0;
-		for (int i = 0; i < DITHER_SIZE-1; i++) {
-			d = rand() / (float)RAND_MAX - 0.5;
-			rand_table[c][i] = d - dp;
-			dp = d;
-		}
-  		rand_table[c][DITHER_SIZE-1] = 0 - dp;
-	}
-}
-
-void dither16(float *start, uint32_t len, uint8_t channels)
-{
-	static uint16_t nr = 0;
-	int16_t *data_int = (int16_t *)start;
-	float *data = start;
-
-	len /= channels;
-	for (int i = 0; i < len; i++) {
-		for (int c = 0; c < channels; c++) {
-			*data = roundf(*data * 32766 + rand_table[c][nr]);
-			if (*data > 32767.0f) *data = 32767;
-			if (*data < -32768.0f) *data = -32768;
-			*data_int = (int16_t) *data;
-			data++;
-			data_int++;
-		}
-		nr++;
-		if (nr >= DITHER_SIZE)
-			nr = 0;
-	}
-}
\ No newline at end of file

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_core/src/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_core/src/CMakeLists.txt	2008-07-16 13:07:21 UTC (rev 4220)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_core/src/CMakeLists.txt	2008-07-16 17:39:39 UTC (rev 4221)
@@ -1,7 +1,6 @@
 SET(ADM_core_SRCS 
 	ADM_cpuCap.cpp  ADM_memcpy.cpp  ADM_memsupport.cpp  ADM_threads.cpp  ADM_win32.cpp
 	ADM_memory.cpp  ADM_misc.cpp  TLK_clock.cpp  ADM_crashdump.cpp  ADM_fileio.cpp ADM_dynamicLoading.cpp
-        ADM_audioUtils.cpp
 )
 
 ADD_LIBRARY(ADM_core SHARED ${ADM_core_SRCS})

Added: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/CMakeLists.txt	2008-07-16 13:07:21 UTC (rev 4220)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/CMakeLists.txt	2008-07-16 17:39:39 UTC (rev 4221)
@@ -0,0 +1 @@
+ADD_SUBDIRECTORY(src)

Copied: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/include/ADM_audiodef.h (from rev 4205, branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audio/ADM_audiodef.h)
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audio/ADM_audiodef.h	2008-07-07 17:43:08 UTC (rev 4205)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/include/ADM_audiodef.h	2008-07-16 17:39:39 UTC (rev 4221)
@@ -0,0 +1,69 @@
+/*
+
+
+*/
+#ifndef AUDIO_DEF
+#define AUDIO_DEF
+#include <string.h>
+typedef struct
+{
+    uint16_t	encoding;	
+    uint16_t	channels;					/* 1 = mono, 2 = stereo */
+    uint32_t	frequency;				/* One of 11025, 22050, or 44100 48000 Hz */
+    uint32_t	byterate;					/* Average bytes per second */
+    uint16_t	blockalign;				/* Bytes per sample block */
+    uint16_t	bitspersample;		/* One of 8, 12, 16, or 4 for ADPCM */
+} WAVHeader;
+void printWavHeader(WAVHeader *hdr);
+
+typedef enum 
+{
+    CHANNEL_INVALID=0,
+    CHANNEL_MONO,
+    CHANNEL_STEREO,
+    CHANNEL_2F_1R,
+    CHANNEL_3F,
+    CHANNEL_3F_1R,
+    CHANNEL_2F_2R,
+    CHANNEL_3F_2R,
+    CHANNEL_3F_2R_LFE,
+    CHANNEL_DOLBY_PROLOGIC,
+    CHANNEL_DOLBY_PROLOGIC2,
+    CHANNEL_LAST
+} CHANNEL_CONF;
+
+#define MAX_CHANNELS 9
+
+typedef enum 
+{
+	CH_INVALID=0,
+	CH_MONO,
+	CH_FRONT_LEFT,
+	CH_FRONT_RIGHT,
+	CH_FRONT_CENTER,
+	CH_REAR_LEFT,
+	CH_REAR_RIGHT,
+	CH_REAR_CENTER,
+	CH_SIDE_LEFT,
+	CH_SIDE_RIGHT,
+	CH_LFE
+}CHANNEL_TYPE;
+// returns true if channel mapping is identical
+bool ADM_audioCompareChannelMapping(WAVHeader *wh1, WAVHeader *wh2,CHANNEL_TYPE *map1,CHANNEL_TYPE *map2);
+
+
+typedef struct
+{
+  const char    *desc;
+  CHANNEL_CONF  conf;
+}AudioChannelDesc;
+const AudioChannelDesc localDownmixing[]=
+{
+  {"No downmixing (multichannel)", CHANNEL_INVALID},
+  {"Stereo", CHANNEL_STEREO},
+  {"Dolby Prologic", CHANNEL_DOLBY_PROLOGIC},
+  {"Dolby Prologic II", CHANNEL_DOLBY_PROLOGIC2}
+  
+};
+#define NB_LOCAL_DOWNMIX (sizeof(localDownmixing)/sizeof(AudioChannelDesc))
+#endif

Copied: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/include/ADM_coreAudio.h (from rev 4205, branches/avidemux_2.5_branch_gruntster/avidemux/ADM_core/include/ADM_coreAudio.h)
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_core/include/ADM_coreAudio.h	2008-07-07 17:43:08 UTC (rev 4205)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/include/ADM_coreAudio.h	2008-07-16 17:39:39 UTC (rev 4221)
@@ -0,0 +1,19 @@
+/**
+        \file ADM_audioCore.h
+
+*/
+#ifndef ADM_audioCore_H
+#define ADM_audioCore_H
+
+
+
+#define DITHER_SIZE 4800
+#define DITHER_CHANNELS 6
+void            AUDMEncoder_initDither();
+void dither16(float *start, uint32_t nb, uint8_t channels);
+
+#include "ADM_audiodef.h"
+
+#endif
+//EOF
+

Copied: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/include/audioencoder.h (from rev 4205, branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioencoder.h)
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioencoder.h	2008-07-07 17:43:08 UTC (rev 4205)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/include/audioencoder.h	2008-07-16 17:39:39 UTC (rev 4221)
@@ -0,0 +1,75 @@
+/***************************************************************************
+    copyright            : (C) 2006 by mean
+    email                : fixounet at free.fr
+ ***************************************************************************/
+
+
+#ifndef AUDIO_ENCODER_H
+#define AUDIO_ENCODER_H
+/*!
+  This structure defines an audio encoder
+  \param encoder Encoder attached to this descriptor
+   \param name The name of the codec
+  \param bitrate The bitrate in kb/s
+  \param configure Function to call to configure the codec
+  \param maxChannels The maximum # of channels this codec supports
+  \param param : An opaque structure that contains the codec specific configuration datas
+*/
+#include "ADM_coreAudio.h"
+#include "ADM_audioEncoder/include/audioencoder_enum.h"
+typedef struct ADM_audioEncoderDescriptor
+{
+  AUDIOENCODER encoder;
+  int       (*configure)(ADM_audioEncoderDescriptor *descritor);
+  const     char *name;
+  uint32_t  bitrate;
+  uint32_t  maxChannels;
+  uint32_t  paramSize;
+  void     *param;
+} ADM_audioEncoderDescriptor;
+
+/*!
+  Base class for all audio encoder.It does the reverse of the bridge class and offers a proper GenericAudioStreamAPI
+
+*/
+#include "ADM_audio/aviaudio.hxx" // FIXME!!!!
+#include "ADM_audiofilter/audioeng_process.h" // FIXME!!!
+ //_____________________________________________
+class AUDMEncoder : public AVDMGenericAudioStream
+{
+  protected:
+    //
+    uint32_t grab(uint8_t *outbuffer);
+    uint32_t grab(float *outbuffer) {ADM_assert(0);return 1;}
+    uint32_t  eof_met;
+    uint32_t  _chunk;
+    //
+    uint8_t         *_extraData;
+    uint32_t        _extraSize;
+    AUDMAudioFilter *_incoming;
+    uint8_t         cleanup(void);
+    
+    float          *tmpbuffer;
+    uint8_t        refillBuffer(int minimum); // Mininum is in float
+
+    
+    void reorderChannels(float *data, uint32_t nb,CHANNEL_TYPE *input,CHANNEL_TYPE *output);
+
+    uint32_t       tmphead,tmptail;
+    // The encoder can remap the audio channel (or not). If so, let's store the the configuration here
+    CHANNEL_TYPE outputChannelMapping[MAX_CHANNELS];
+  public:
+    //
+    uint32_t read(uint32_t len,uint8_t *buffer);
+    uint32_t read(uint32_t len,float *buffer) {ADM_assert(0);return 1;}
+    //
+    virtual ~AUDMEncoder();
+    AUDMEncoder(AUDMAudioFilter *in);	
+    virtual uint8_t init(ADM_audioEncoderDescriptor *config)=0;
+    virtual uint8_t getPacket(uint8_t *dest, uint32_t *len, uint32_t *samples)=0;
+    virtual uint8_t packetPerFrame( void) {return 1;}
+    virtual uint8_t extraData(uint32_t *l,uint8_t **d) {*l=_extraSize;*d=_extraData;return 1;}
+            uint8_t  goTo(uint32_t timeMS) {ADM_assert(0);return 1;}
+};
+
+#endif

Copied: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/src/ADM_audioUtils.cpp (from rev 4205, branches/avidemux_2.5_branch_gruntster/avidemux/ADM_core/src/ADM_audioUtils.cpp)
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_core/src/ADM_audioUtils.cpp	2008-07-07 17:43:08 UTC (rev 4205)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/src/ADM_audioUtils.cpp	2008-07-16 17:39:39 UTC (rev 4221)
@@ -0,0 +1,48 @@
+/**
+    \fn ADM_audioUtils.cpp
+    \brief Will be moved later to ADM_coreAudio
+
+
+*/
+#include "ADM_default.h"
+#include "ADM_coreAudio.h"
+#include <math.h>
+
+static float rand_table[DITHER_CHANNELS][DITHER_SIZE];
+
+void AUDMEncoder_initDither(void)
+{
+  printf("Initializing Dithering tables\n");
+	float d, dp;
+	for (int c = 0; c < DITHER_CHANNELS; c++) {
+		dp = 0;
+		for (int i = 0; i < DITHER_SIZE-1; i++) {
+			d = rand() / (float)RAND_MAX - 0.5;
+			rand_table[c][i] = d - dp;
+			dp = d;
+		}
+  		rand_table[c][DITHER_SIZE-1] = 0 - dp;
+	}
+}
+
+void dither16(float *start, uint32_t len, uint8_t channels)
+{
+	static uint16_t nr = 0;
+	int16_t *data_int = (int16_t *)start;
+	float *data = start;
+
+	len /= channels;
+	for (int i = 0; i < len; i++) {
+		for (int c = 0; c < channels; c++) {
+			*data = roundf(*data * 32766 + rand_table[c][nr]);
+			if (*data > 32767.0f) *data = 32767;
+			if (*data < -32768.0f) *data = -32768;
+			*data_int = (int16_t) *data;
+			data++;
+			data_int++;
+		}
+		nr++;
+		if (nr >= DITHER_SIZE)
+			nr = 0;
+	}
+}
\ No newline at end of file

Added: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/src/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/src/CMakeLists.txt	2008-07-16 13:07:21 UTC (rev 4220)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/src/CMakeLists.txt	2008-07-16 17:39:39 UTC (rev 4221)
@@ -0,0 +1,8 @@
+SET(ADMaudioCore_SRCS
+ADM_audioUtils.cpp
+audioencoder.cpp
+)	
+ADD_LIBRARY(ADM_coreAudio SHARED ${ADMaudioCore_SRCS})
+INCLUDE_DIRECTORIES(${CMAKE_SOURCE_DIR}/avidemux/ADM_coreAudio/include)
+
+INSTALL(TARGETS ADM_coreAudio RUNTIME DESTINATION ${BIN_DIR}  LIBRARY DESTINATION lib  ARCHIVE DESTINATION lib)

Copied: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/src/audioencoder.cpp (from rev 4205, branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioencoder.cpp)
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioencoder.cpp	2008-07-07 17:43:08 UTC (rev 4205)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/src/audioencoder.cpp	2008-07-16 17:39:39 UTC (rev 4221)
@@ -0,0 +1,147 @@
+ 
+/***************************************************************************
+    copyright            : (C) 2002-6 by mean
+    email                : fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include "ADM_default.h"
+#include "ADM_coreAudio.h"
+#include "ADM_audiofilter/audioprocess.hxx"
+#include "ADM_audiofilter/audioeng_process.h"
+#include "audioencoder.h"
+
+AUDMEncoder::AUDMEncoder(AUDMAudioFilter *in)  :AVDMGenericAudioStream  ()
+{
+  _wavheader = new WAVHeader;
+  _incoming=in;
+  memcpy(_wavheader, _incoming->getInfo(), sizeof(WAVHeader));
+  _wavheader->encoding=WAV_AAC;
+  _incoming->rewind();	// rewind
+  _extraData=NULL;
+  _extraSize=0;
+  tmpbuffer=new float[_wavheader->frequency*_wavheader->channels];
+  tmphead=tmptail=0;
+  eof_met=0;
+  
+};
+/********************/
+AUDMEncoder::~AUDMEncoder()
+{
+  cleanup();
+};
+/********************/
+uint8_t AUDMEncoder::cleanup(void)
+{
+  if(_wavheader) delete(_wavheader);
+  _wavheader=NULL;
+
+  if(_extraData) delete [] _extraData;
+  _extraData=NULL;
+  
+  if(tmpbuffer) delete [] tmpbuffer;
+  tmpbuffer=NULL;
+};
+/********************/
+
+uint8_t AUDMEncoder::refillBuffer(int minimum)
+{
+  uint32_t filler=_wavheader->frequency*_wavheader->channels;
+  uint32_t nb;
+  AUD_Status status;
+  if(eof_met) return 0;
+  while(1)
+  {
+    ADM_assert(tmptail>=tmphead);
+    if((tmptail-tmphead)>=minimum) return 1;
+  
+    if(tmphead && tmptail>filler/2)
+    {
+      memmove(&tmpbuffer[0],&tmpbuffer[tmphead],(tmptail-tmphead)*sizeof(float)); 
+      tmptail-=tmphead;
+      tmphead=0;
+    }
+    ADM_assert(filler>tmptail);
+    nb=_incoming->fill( (filler-tmptail)/2,&tmpbuffer[tmptail],&status);
+    if(!nb)
+    {
+      if(status!=AUD_END_OF_STREAM) ADM_assert(0);
+      
+      if((tmptail-tmphead)<minimum)
+      {
+        memset(&tmpbuffer[tmptail],0,sizeof(float)*(minimum-(tmptail-tmphead)));
+        tmptail=tmphead+minimum;
+        eof_met=1;  
+        return minimum;
+      }
+      else continue;
+    } else
+      tmptail+=nb;
+  }
+}
+
+
+/**
+ * 	\fn reorderChannels
+ *  \brief Reorder the channels
+ */
+void AUDMEncoder::reorderChannels(float *data, uint32_t nb,CHANNEL_TYPE *input,CHANNEL_TYPE *output)
+{
+	float tmp [_wavheader->channels];
+	static uint8_t reorder[MAX_CHANNELS];
+	static bool reorder_on;
+	
+	
+		reorder_on = 0;
+		int j = 0;
+		// Should we reorder the channels (might be needed for encoder ?
+		if (_wavheader->channels > 2) 
+		{
+			CHANNEL_TYPE *p_ch_type;
+			for (int i = 0; i < _wavheader->channels; i++) 
+			{
+				for (int c = 0; c < _wavheader->channels; c++) 
+				{
+					if (input[c] == output[i]) 
+					{
+						if (j != c)
+							reorder_on = 1;
+						reorder[j++] = c;
+					}
+				}
+			}
+		}
+	
+
+	if (reorder_on)
+		for (int i = 0; i < nb; i++) {
+			memcpy(tmp, data, sizeof(tmp));
+			for (int c = 0; c < _wavheader->channels; c++)
+				*data++ = tmp[reorder[c]];
+		}
+
+}
+
+uint32_t AUDMEncoder::read(uint32_t len,uint8_t *buffer)
+{
+  ADM_assert(0);
+  return 0; 
+}
+
+uint32_t AUDMEncoder::grab(uint8_t * obuffer)
+{
+  uint32_t len,sam;
+  if(getPacket(obuffer,&len,&sam))
+    return len;
+  return MINUS_ONE;
+}
+
+//EOF

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_libraries/ADM_utilities/avifmt2.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_libraries/ADM_utilities/avifmt2.h	2008-07-16 13:07:21 UTC (rev 4220)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_libraries/ADM_utilities/avifmt2.h	2008-07-16 17:39:39 UTC (rev 4221)
@@ -44,7 +44,7 @@
 #define AVI_KEY_FRAME   0x10
 #define AVI_B_FRAME	0x4000	 // hopefully it is not used..
 
-#include "../../ADM_audio/ADM_audiodef.h"
+#include "ADM_coreAudio/include/ADM_coreAudio.h"
 
 void Endian_AviMainHeader(MainAVIHeader *m);
 void Endian_BitMapInfo( ADM_BITMAPINFOHEADER *b);

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_NONE/ADM_dialog/DIA_none.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_NONE/ADM_dialog/DIA_none.cpp	2008-07-16 13:07:21 UTC (rev 4220)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_NONE/ADM_dialog/DIA_none.cpp	2008-07-16 17:39:39 UTC (rev 4221)
@@ -34,7 +34,7 @@
 #include "ADM_videoFilter/ADM_vidVobSub.h"
 
 #include "ADM_encoder/ADM_vidEncode.hxx"
-#include "ADM_audiofilter/audioencoder.h"
+#include "ADM_coreAudio/include/audioencoder.h"
 #include "ADM_lavcodec.h"
 #include "ADM_codecs/ADM_ffmpegConfig.h"
 

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/DIA_none.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/DIA_none.cpp	2008-07-16 13:07:21 UTC (rev 4220)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/DIA_none.cpp	2008-07-16 17:39:39 UTC (rev 4221)
@@ -22,8 +22,9 @@
 
 
 #include "ADM_encoder/ADM_vidEncode.hxx"
-#include "ADM_audiofilter/audioencoder.h"
+#include "ADM_audioEncoder/include/audioencoder_enum.h"
 
+
 #ifdef USE_XX_XVID 
 #include "xvid.h"
 int  DIA_getXvidCompressParams(COMPRESSION_MODE * mode, uint32_t * qz,

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_filters/Q_mainfilter.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_filters/Q_mainfilter.cpp	2008-07-16 13:07:21 UTC (rev 4220)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_filters/Q_mainfilter.cpp	2008-07-16 17:39:39 UTC (rev 4221)
@@ -32,7 +32,6 @@
 
 # include "prefs.h"
 #include "ADM_audiodevice/audio_out.h"
-#include "ADM_audio/ADM_audiodef.h"
 
 #include "ADM_userInterfaces/ADM_render/GUI_render.h"
 

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_audioconfig.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_audioconfig.cpp	2008-07-16 13:07:21 UTC (rev 4220)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_audioconfig.cpp	2008-07-16 17:39:39 UTC (rev 4221)
@@ -20,7 +20,7 @@
 #include "DIA_factory.h"
 #include "../../ADM_audiofilter/audioprocess.hxx"
 #include "../../ADM_audiofilter/audioeng_process.h"
-#include "../../ADM_audiofilter/audioencoder.h"
+#include "ADM_coreAudio/include/audioencoder.h"
 
 /**
       \fn DIA_defaultSettings

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/CMakeLists.txt	2008-07-16 13:07:21 UTC (rev 4220)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/CMakeLists.txt	2008-07-16 17:39:39 UTC (rev 4221)
@@ -56,6 +56,7 @@
 INCLUDE_DIRECTORIES("${CMAKE_CURRENT_SOURCE_DIR}/ADM_core/include")
 INCLUDE_DIRECTORIES("${CMAKE_CURRENT_SOURCE_DIR}/ADM_coreUI/include")
 INCLUDE_DIRECTORIES("${CMAKE_CURRENT_SOURCE_DIR}/ADM_coreImage/include")
+INCLUDE_DIRECTORIES("${CMAKE_CURRENT_SOURCE_DIR}/ADM_coreAudio/include")
 INCLUDE_DIRECTORIES("${CMAKE_CURRENT_SOURCE_DIR}/ADM_libraries/ADM_utilities")
 INCLUDE_DIRECTORIES("${CMAKE_CURRENT_SOURCE_DIR}/ADM_libraries/ADM_ffmpeg/ADM_lavutil")
 INCLUDE_DIRECTORIES("${CMAKE_CURRENT_SOURCE_DIR}/ADM_libraries/ADM_ffmpeg/ADM_lavcodec")
@@ -151,6 +152,7 @@
 ########################################
 SET(ADM_SUBDIR 
 	ADM_audiofilter
+	ADM_audioEncoder
 	ADM_editor
 	ADM_audiocodec
 	ADM_audio
@@ -220,7 +222,6 @@
 	ADD_SUBDIRECTORY(${_current})
 	ADD_ADMLIB_ALL_TARGETS(${_current})
 ENDFOREACH(_current ${ADM_TAILS})
-
 ###########################################
 # Construct ADM_libraries
 ###########################################
@@ -316,7 +317,12 @@
 ADD_LIB_ALL_TARGETS(ADM_coreUI)
 ADD_SUBDIRECTORY(ADM_coreImage)
 ADD_LIB_ALL_TARGETS(ADM_coreImage)
+ADD_SUBDIRECTORY(ADM_coreAudio)
+ADD_LIB_ALL_TARGETS(ADM_coreAudio)
 
+# To be removed
+ADD_SUBDIRECTORY(ADM_audioEncoder)
+
 ###########################################
 # External libs
 ###########################################
@@ -375,23 +381,6 @@
 		TARGET_LINK_LIBRARIES(avidemux2_qt4 ${SDL_LIBRARY})
 	ENDIF (ADM_UI_QT4)
 ENDIF (USE_SDL)
-if(0)
-# aRts
-IF (USE_ARTS)
-	IF (ADM_UI_GTK)
-		ADD_TARGET_LDFLAGS(avidemux2_gtk ${ARTS_LDFLAGS})
-	ENDIF (ADM_UI_GTK)
-
-	IF (ADM_UI_QT4)
-		ADD_TARGET_LDFLAGS(avidemux2_qt4 ${ARTS_LDFLAGS})
-	ENDIF (ADM_UI_QT4)
-ENDIF (USE_ARTS)
-
-# JACK
-IF (USE_JACK)
-	ADD_LIB_ALL_TARGETS("${JACK_LIBRARY_DIR}")
-ENDIF (USE_JACK)
-endif(0)
 # LAME
 IF (HAVE_LIBMP3LAME)
 	ADD_LIB_ALL_TARGETS("${LAME_LIBRARY_DIR}")



From mean at mail.berlios.de  Wed Jul 16 19:39:46 2008
From: mean at mail.berlios.de (mean at BerliOS)
Date: Wed, 16 Jul 2008 19:39:46 +0200
Subject: [Avidemux-svn-commit] r4222 - in
	branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder:
	. src
Message-ID: <200807161739.m6GHdkqI021076@sheep.berlios.de>

Author: mean
Date: 2008-07-16 19:39:46 +0200 (Wed, 16 Jul 2008)
New Revision: 4222

Added:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/CMakeLists.txt
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/src/CMakeLists.txt
Log:
[Audio] Create coreAudio + begin moving away audioEncoder


Added: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/CMakeLists.txt	2008-07-16 17:39:39 UTC (rev 4221)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/CMakeLists.txt	2008-07-16 17:39:46 UTC (rev 4222)
@@ -0,0 +1 @@
+ADD_SUBDIRECTORY(src)

Added: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/src/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/src/CMakeLists.txt	2008-07-16 17:39:39 UTC (rev 4221)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/src/CMakeLists.txt	2008-07-16 17:39:46 UTC (rev 4222)
@@ -0,0 +1,30 @@
+SET(ADMaudioEncoder_SRCS
+audioencoder_aften.cpp
+audioencoder_faac.cpp
+audioencoder_lame.cpp
+audioencoder_lavcodec.cpp
+audioencoder_pcm.cpp
+audioencoder_twolame.cpp
+audioencoder_vorbis.cpp 
+)	
+ADD_ADM_LIB_ALL_TARGETS(ADM_audioEncoder ${ADMaudioEncoder_SRCS})
+INCLUDE_DIRECTORIES(${CMAKE_SOURCE_DIR}/avidemux/ADM_coreAudio/include)
+INCLUDE_DIRECTORIES(${CMAKE_SOURCE_DIR}/avidemux/ADM_audioEncoder/include)
+INCLUDE_DIRECTORIES(${CMAKE_SOURCE_DIR}/avidemux/ADM_audiofilter/)
+INCLUDE_DIRECTORIES(${CMAKE_SOURCE_DIR}/avidemux/ADM_audioEncoder/include)
+IF (USE_AFTEN)
+	ADD_SOURCE_CFLAGS(audioencoder_aften.cpp -I${AFTEN_INCLUDE_DIR})
+ENDIF (USE_AFTEN)
+
+IF (USE_FAAC)
+	ADD_SOURCE_CFLAGS(audioencoder_faac.cpp -I${FAAC_INCLUDE_DIR})
+ENDIF (USE_FAAC)
+
+IF (HAVE_LIBMP3LAME)
+	ADD_SOURCE_CFLAGS(audioencoder_lame.cpp -I${LAME_INCLUDE_DIR})
+ENDIF (HAVE_LIBMP3LAME)
+
+IF (USE_VORBIS)
+	ADD_SOURCE_CFLAGS(audioencoder_vorbis.cpp -I${VORBIS_INCLUDE_DIR})
+ENDIF (USE_VORBIS)
+



From mean at mail.berlios.de  Wed Jul 16 19:39:52 2008
From: mean at mail.berlios.de (mean at BerliOS)
Date: Wed, 16 Jul 2008 19:39:52 +0200
Subject: [Avidemux-svn-commit] r4223 - in
	branches/avidemux_2.5_branch_gruntster/avidemux: ADM_audio
	ADM_audioEncoder/include ADM_audioEncoder/src ADM_audiofilter
	ADM_coreAudio/include ADM_coreAudio/src
Message-ID: <200807161739.m6GHdq6R021096@sheep.berlios.de>

Author: mean
Date: 2008-07-16 19:39:47 +0200 (Wed, 16 Jul 2008)
New Revision: 4223

Added:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/include/ADM_baseAudioStream.h
Removed:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audio/audiomode.hxx
Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audio/aviaudio.hxx
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/include/audioencoder_twolame_param.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/src/audioencoder_lame.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/CMakeLists.txt
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audiofilter_buildchain.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/include/audioencoder.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/src/audioencoder.cpp
Log:
[AudioEncoder] Created wrapper to decorrelate encoder from generic audio stream


Deleted: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audio/audiomode.hxx
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audio/audiomode.hxx	2008-07-16 17:39:46 UTC (rev 4222)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audio/audiomode.hxx	2008-07-16 17:39:47 UTC (rev 4223)
@@ -1,26 +0,0 @@
-/***************************************************************************
-                          audiomode.hxx  -  description
-                             -------------------
-    begin                : Sun Jan 20 2002
-    copyright            : (C) 2002 by mean
-    email                : fixounet at free.fr
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-#ifndef __AUDIOMODE
-#define __AUDIOMODE
-typedef enum  
-{
-   	ADM_STEREO=1,
-   	ADM_JSTEREO,
-   	ADM_MONO
-} ADM_mode;
-#endif

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audio/aviaudio.hxx
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audio/aviaudio.hxx	2008-07-16 17:39:46 UTC (rev 4222)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audio/aviaudio.hxx	2008-07-16 17:39:47 UTC (rev 4223)
@@ -17,7 +17,6 @@
 #ifndef __WAV_Audio
 #define __WAV_Audio
 
-#include "audiomode.hxx"
 
 class AviList;
 

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/include/audioencoder_twolame_param.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/include/audioencoder_twolame_param.h	2008-07-16 17:39:46 UTC (rev 4222)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/include/audioencoder_twolame_param.h	2008-07-16 17:39:47 UTC (rev 4223)
@@ -1,3 +1,8 @@
+/**
+        \file 
+
+*/
+
 #ifndef AUDM_TWOLAME_PARAM_H
 #define AUDM_TWOLAME_PARAM_H
 

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/src/audioencoder_lame.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/src/audioencoder_lame.cpp	2008-07-16 17:39:46 UTC (rev 4222)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/src/audioencoder_lame.cpp	2008-07-16 17:39:47 UTC (rev 4223)
@@ -20,7 +20,6 @@
 #include "audioprocess.hxx"
 #include "audioeng_process.h"
 #include "audioencoder.h"
-
 #include "audioencoder_lame_param.h"
 #include "audioencoder_lame.h"
 

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/CMakeLists.txt	2008-07-16 17:39:46 UTC (rev 4222)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/CMakeLists.txt	2008-07-16 17:39:47 UTC (rev 4223)
@@ -1,11 +1,20 @@
 SET(ADMaudiofilter_SRCS 
-	audiodeng_buildfilters.cpp    audioeng_process.cpp           audiofilter_film2pal.cpp   audiolib_sox.cpp
-	audiofilter_bridge.cpp         audiofilter_limiter.cpp    audio_raw.cpp
-	audiofilter_buildchain.cpp     audiofilter_mixer.cpp
+	audiodeng_buildfilters.cpp    
+        audioeng_process.cpp           
+        audiofilter_film2pal.cpp   
+	audiofilter_bridge.cpp         
+        audiofilter_limiter.cpp    
+	audiofilter_buildchain.cpp     
+        audiofilter_mixer.cpp
 	audiofilter_normalize.cpp
-	audioeng_buff.cpp          audiofilter_dolby.cpp          audiofilter_sox.cpp)
+        audiofilter_dolby.cpp          
+        audiofilter_sox.cpp
+        audio_raw.cpp
+        audiolib_sox.cpp
+	audioeng_buff.cpp          
+        audio_encoderWrapper.cpp
+)
 	
 ADD_ADM_LIB_ALL_TARGETS(ADM_audiofilter ${ADMaudiofilter_SRCS})
-INCLUDE_DIRECTORIES(${CMAKE_SOURCE_DIR}/avidemux/ADM_coreAudio/include)
 INCLUDE_DIRECTORIES(${CMAKE_SOURCE_DIR}/avidemux/ADM_audioEncoder/include)
 

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audiofilter_buildchain.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audiofilter_buildchain.cpp	2008-07-16 17:39:46 UTC (rev 4222)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audiofilter_buildchain.cpp	2008-07-16 17:39:47 UTC (rev 4223)
@@ -19,7 +19,8 @@
 #include "ADM_default.h"
 #include "DIA_coreToolkit.h"
 
-#include "ADM_audio/audiomode.hxx"
+#include "audioencoder.h"
+
 #include "ADM_audiofilter/audiofilter_limiter_param.h"
 #include "audioencoder_lame_param.h"
 #include "audioencoder_twolame_param.h"
@@ -27,13 +28,13 @@
 #include "audioencoder_vorbis_param.h"
 #include "audioencoder_aften_param.h"
 #include "audiofilter_normalize_param.h"
+#include "audio_encoderWrapper.h"
 
 #include "audioprocess.hxx"
 #include "ADM_audiofilter/audioeng_buildfilters.h"
 #include "ADM_audiofilter/audio_raw.h"
 
 /* ************* Encoder *********** */
-#include "audioencoder.h"
 #ifdef USE_FAAC
 #include "audioencoder_faac.h"
 #endif
@@ -405,10 +406,10 @@
     tmpfilter=NULL;
     GUI_Error_HIG(QT_TR_NOOP("Encoder initialization failed"), QT_TR_NOOP("Not activated."));
   }
-  output=tmpfilter;
-
+  ADM_audioEncoderWrapper *wrapper=new ADM_audioEncoderWrapper(tmpfilter);
+  output=wrapper;
   currentaudiostream->beginDecompress();
-
+  ADM_assert(output);
   return output;
 }
 

Copied: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/include/ADM_baseAudioStream.h (from rev 4222, branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audio/aviaudio.hxx)
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audio/aviaudio.hxx	2008-07-16 17:39:46 UTC (rev 4222)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/include/ADM_baseAudioStream.h	2008-07-16 17:39:47 UTC (rev 4223)
@@ -0,0 +1,177 @@
+/***************************************************************************
+                          aviaudio.hxx  -  description
+                             -------------------
+    begin                : Thu Nov 22 2001
+    copyright            : (C) 2001 by mean
+    email                : fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#ifndef __WAV_Audio
+#define __WAV_Audio
+
+#include "audiomode.hxx"
+
+class AviList;
+
+
+#include "ADM_coreAudio/include/ADM_coreAudio.h"
+typedef struct
+{
+	uint16_t	encoding;	
+	uint16_t	channels;					/* 1 = mono, 2 = stereo */
+	uint32_t	frequency;				/* One of 11025, 22050, or 44100 48000 Hz */
+	uint32_t	byterate;					/* Average bytes per second */
+	uint16_t	blockalign;				/* Bytes per sample block */
+	uint16_t	bitspersample;		/* One of 8, 12, 16, or 4 for ADPCM */
+ // 16 bytes up to here, 14 left
+ // Used for VBR mp3
+  uint16_t   		cbsize ;
+  uint16_t          wId ;
+  uint32_t         	fdwflags ;
+  uint16_t          nblocksize ;
+  uint16_t          nframesperblock  ;
+  uint16_t          ncodecdelay ;
+} WAVHeaderVBR;
+
+typedef struct
+{
+    uint32_t foffset;
+    uint32_t woffset;
+
+}ST_point;
+
+#define WAV_MP3 	85
+#define WAV_MP2 	80
+#define WAV_WMA 	353
+#define WAV_PCM 	1
+#define WAV_MSADPCM 	2
+#define WAV_LPCM 	3
+#define WAV_AC3 	0x2000
+#define WAV_DTS 	0x2001
+#define WAV_OGG 0x676f
+#define WAV_8BITS 	53 // dummy id
+#define WAV_MP4 	54 // dummy id
+#define WAV_AAC 	0xff // dummy id
+#define WAV_AAC_HE 	0xfe // dummy id
+#define WAV_8BITS_UNSIGNED 	55 // dummy id
+#define WAV_AMRNB 	56 // dummy id
+#define WAV_ULAW	57 // dummy id
+#define WAV_QDM2 	58
+#define WAV_IMAADPCM    17
+#define WAV_AMV_ADPCM    9900
+#define WAV_NELLYMOSER   9901
+#define WAV_UNKNOWN     9999
+#include "../ADM_audiocodec/ADM_audiocodec.h"
+#include "../ADM_osSupport/ADM_fileio.h"
+
+
+
+class AVDMGenericAudioStream
+{
+   	protected:
+   				
+    #define SIZE_INTERNAL 64*1024 
+					uint8_t 	internalBuffer[2 * SIZE_INTERNAL];
+					float 	internalBuffer_float[SIZE_INTERNAL];
+					uint8_t 	packetBuffer[2 * SIZE_INTERNAL];
+					uint32_t	packetHead,packetTail;
+					uint8_t		isPaketizable( void);
+            				WAVHeader	*_wavheader;
+                			ADM_Audiocodec 	*_codec;
+					uint32_t	_length;
+       					uint32_t	_pos;
+					uint8_t		_destroyable;
+					char   		_name[20];
+					uint8_t	_eos;
+         					// This is for writing..
+			              	uint32_t	_dlen;
+					AviList		*_LAll;
+                                        ADMFile         *_file;
+       					// This is for VBR MP3
+       					ST_point	*_audioMap;
+            				uint32_t	_nbMap;
+                        		uint32_t	_current;
+					uint8_t		_mpegSync[3];
+					uint8_t 	shrink( void );
+					uint8_t		getPacketMP3(uint8_t *dest, uint32_t *len, 
+										uint32_t *samples);
+					uint8_t		getPacketAC3(uint8_t *dest, uint32_t *len, 
+									uint32_t *samples);
+					uint8_t		getPacketDTS(uint8_t *dest, uint32_t *len, 
+									uint32_t *samples);
+
+					uint8_t		getPacketPCM(uint8_t *dest, uint32_t *len, 
+								uint32_t *samples);
+					uint8_t		getPacketWMA(uint8_t *dest, uint32_t *len, 
+								uint32_t *samples);
+					uint8_t		getPacketAAC(uint8_t *dest, uint32_t *len, 
+								uint32_t *samples);
+                                        uint8_t         getPacketADPCM(uint8_t *dest, uint32_t *len,
+                                                                uint32_t *samples);
+
+       protected:
+				       	uint8_t  	readc( uint8_t *c);
+			      
+		public:
+					                           AVDMGenericAudioStream( void);
+			virtual 				~AVDMGenericAudioStream() ;
+          				uint8_t			beginDecompress( void );
+        		     		uint32_t		getPos( void ) {return _pos;};
+	             		virtual	uint8_t			buildAudioTimeLine( void );
+				virtual		uint8_t 	flushPacket(void);
+               
+               
+				  	uint8_t			endDecompress( void );
+					uint8_t			isDestroyable( void ) { return _destroyable;}
+					uint8_t			isCompressed( void );
+					uint8_t			isDecompressable( void );
+          			virtual uint32_t		readDecompress( uint32_t size,uint8_t *ptr );//deprecated
+          			virtual uint32_t		readDecompress(uint32_t size, float *ptr);
+				virtual uint8_t		 	goTo(uint32_t offset)=0;
+				virtual uint32_t		read(uint32_t size,uint8_t *ptr)=0;//deprecated
+				virtual uint32_t		read(uint32_t size,float *ptr){return 0;}
+//-----------------
+					WAVHeader 		*getInfo(void) { return _wavheader;}
+					
+  					uint32_t		getLength(void ){ return _length;};
+//----------------
+        			uint8_t 			goToSync(uint32_t offset);
+			virtual uint8_t				goToTime(uint32_t mstime);
+				uint32_t 			convTime2Offset(uint32_t time);
+//__________________
+				uint8_t				writeHeader(FILE *out);
+         			uint8_t				endWrite(FILE *out,uint32_t len);
+            	virtual 	uint8_t				isVBR(void ) { if( _audioMap) return 1; else return 0;};
+                 		uint32_t			nbFrameSlice( void )
+                 						{ if(!_audioMap) {printf("OOOOpppps!");return 1000;}; return  _nbMap;}
+//___________________                 
+		virtual 	uint8_t				extraData(uint32_t *l,uint8_t **d)
+									{
+										*l=0;
+										*d=NULL;
+										return 0;
+									}
+					// Get Packet
+			virtual	uint8_t				getPacket(uint8_t *dest, uint32_t *len, 
+										uint32_t *samples);
+		// Return 1 if needs special muxing mode (AAC)			
+			virtual uint8_t packetPerFrame( void)	{return 0;} 
+				// The channel mapping for this stream
+				// Only used by decoder...
+			virtual CHANNEL_TYPE *getChannelMapping(void) {if(_codec) return _codec->channelMapping; else return NULL;}
+}
+;
+/* Describe the channel mapping */
+
+//
+uint8_t mpegAudioIdentify(uint8_t *ptr, uint32_t maxLookUp, WAVHeader *header, uint8_t *tokens=NULL);
+
+#endif

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/include/audioencoder.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/include/audioencoder.h	2008-07-16 17:39:46 UTC (rev 4222)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/include/audioencoder.h	2008-07-16 17:39:47 UTC (rev 4223)
@@ -35,9 +35,10 @@
 #include "ADM_audio/aviaudio.hxx" // FIXME!!!!
 #include "ADM_audiofilter/audioeng_process.h" // FIXME!!!
  //_____________________________________________
-class AUDMEncoder : public AVDMGenericAudioStream
+class AUDMEncoder //: public AVDMGenericAudioStream
 {
   protected:
+    
     //
     uint32_t grab(uint8_t *outbuffer);
     uint32_t grab(float *outbuffer) {ADM_assert(0);return 1;}
@@ -60,6 +61,8 @@
     CHANNEL_TYPE outputChannelMapping[MAX_CHANNELS];
   public:
     //
+    WAVHeader       *_wavheader;
+    //
     uint32_t read(uint32_t len,uint8_t *buffer);
     uint32_t read(uint32_t len,float *buffer) {ADM_assert(0);return 1;}
     //
@@ -71,5 +74,12 @@
     virtual uint8_t extraData(uint32_t *l,uint8_t **d) {*l=_extraSize;*d=_extraData;return 1;}
             uint8_t  goTo(uint32_t timeMS) {ADM_assert(0);return 1;}
 };
+// Used by some old code (lame/twolame) OBSOLETE   / DO NOT USE
+typedef enum  
+{
+   	ADM_STEREO=1,
+   	ADM_JSTEREO,
+   	ADM_MONO
+} ADM_mode;
 
 #endif

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/src/audioencoder.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/src/audioencoder.cpp	2008-07-16 17:39:46 UTC (rev 4222)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/src/audioencoder.cpp	2008-07-16 17:39:47 UTC (rev 4223)
@@ -19,7 +19,7 @@
 #include "ADM_audiofilter/audioeng_process.h"
 #include "audioencoder.h"
 
-AUDMEncoder::AUDMEncoder(AUDMAudioFilter *in)  :AVDMGenericAudioStream  ()
+AUDMEncoder::AUDMEncoder(AUDMAudioFilter *in) // :AVDMGenericAudioStream  ()
 {
   _wavheader = new WAVHeader;
   _incoming=in;



From mean at mail.berlios.de  Wed Jul 16 19:39:57 2008
From: mean at mail.berlios.de (mean at BerliOS)
Date: Wed, 16 Jul 2008 19:39:57 +0200
Subject: [Avidemux-svn-commit] r4224 - in
	branches/avidemux_2.5_branch_gruntster/avidemux:
	ADM_audioEncoder/src ADM_audiofilter ADM_coreAudio/include
	ADM_coreAudio/src ADM_userInterfaces/ADM_commonUI
Message-ID: <200807161739.m6GHdvBA021106@sheep.berlios.de>

Author: mean
Date: 2008-07-16 19:39:56 +0200 (Wed, 16 Jul 2008)
New Revision: 4224

Added:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/include/ADM_audioFilter.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/src/ADM_audioFilter.cpp
Removed:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioeng_process.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioeng_process.h
Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/src/audioencoder_faac.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/src/audioencoder_lame.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/src/audioencoder_lavcodec.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/src/audioencoder_pcm.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/src/audioencoder_twolame.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/src/audioencoder_vorbis.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/CMakeLists.txt
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audiodeng_buildfilters.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioeng_buildfilters.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audiofilter_bridge.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audiofilter_bridge.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audiofilter_film2pal.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audiofilter_film2pal.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audiofilter_limiter.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audiofilter_limiter.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audiofilter_normalize.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audiofilter_normalize.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioprocess.hxx
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/include/ADM_coreAudio.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/include/audioencoder.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/src/CMakeLists.txt
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/src/audioencoder.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_audioconfig.cpp
Log:
[Audio] Dispatch files


Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/src/audioencoder_faac.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/src/audioencoder_faac.cpp	2008-07-16 17:39:47 UTC (rev 4223)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/src/audioencoder_faac.cpp	2008-07-16 17:39:56 UTC (rev 4224)
@@ -26,8 +26,6 @@
 
 #include "ADM_default.h"
 
-#include "audioprocess.hxx"
-#include "audioeng_process.h"
 #include "audioencoder.h"
 //
 

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/src/audioencoder_lame.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/src/audioencoder_lame.cpp	2008-07-16 17:39:47 UTC (rev 4223)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/src/audioencoder_lame.cpp	2008-07-16 17:39:56 UTC (rev 4224)
@@ -17,8 +17,6 @@
 #include <lame/lame.h>
 
 #include "ADM_default.h"
-#include "audioprocess.hxx"
-#include "audioeng_process.h"
 #include "audioencoder.h"
 #include "audioencoder_lame_param.h"
 #include "audioencoder_lame.h"

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/src/audioencoder_lavcodec.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/src/audioencoder_lavcodec.cpp	2008-07-16 17:39:47 UTC (rev 4223)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/src/audioencoder_lavcodec.cpp	2008-07-16 17:39:56 UTC (rev 4224)
@@ -23,8 +23,6 @@
 
 #include "ADM_default.h"
 
-#include "audioprocess.hxx"
-#include "audioeng_process.h"
 #include "audioencoder.h"
 //
 #include "audioencoder_lavcodec.h"

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/src/audioencoder_pcm.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/src/audioencoder_pcm.cpp	2008-07-16 17:39:47 UTC (rev 4223)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/src/audioencoder_pcm.cpp	2008-07-16 17:39:56 UTC (rev 4224)
@@ -19,8 +19,6 @@
 
 #include "ADM_default.h"
 
-#include "audioprocess.hxx"
-#include "audioeng_process.h"
 #include "audioencoder.h"
 //
 #include "audioencoder_pcm.h"

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/src/audioencoder_twolame.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/src/audioencoder_twolame.cpp	2008-07-16 17:39:47 UTC (rev 4223)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/src/audioencoder_twolame.cpp	2008-07-16 17:39:56 UTC (rev 4224)
@@ -19,8 +19,6 @@
 
 #include "ADM_default.h"
 
-#include "audioprocess.hxx"
-#include "audioeng_process.h"
 #include "audioencoder.h"
 //
 #include "audioencoder_twolame.h"

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/src/audioencoder_vorbis.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/src/audioencoder_vorbis.cpp	2008-07-16 17:39:47 UTC (rev 4223)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/src/audioencoder_vorbis.cpp	2008-07-16 17:39:56 UTC (rev 4224)
@@ -20,8 +20,6 @@
 
 #include "ADM_default.h"
 
-#include "audioprocess.hxx"
-#include "audioeng_process.h"
 #include "audioencoder.h"
 //
 #include "audioencoder_vorbis_param.h"

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/CMakeLists.txt	2008-07-16 17:39:47 UTC (rev 4223)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/CMakeLists.txt	2008-07-16 17:39:56 UTC (rev 4224)
@@ -1,6 +1,5 @@
 SET(ADMaudiofilter_SRCS 
 	audiodeng_buildfilters.cpp    
-        audioeng_process.cpp           
         audiofilter_film2pal.cpp   
 	audiofilter_bridge.cpp         
         audiofilter_limiter.cpp    

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audiodeng_buildfilters.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audiodeng_buildfilters.cpp	2008-07-16 17:39:47 UTC (rev 4223)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audiodeng_buildfilters.cpp	2008-07-16 17:39:56 UTC (rev 4224)
@@ -15,16 +15,12 @@
  *                                                                         *
  ***************************************************************************/
 #include "config.h"
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
 #include <math.h>
 
 #include "ADM_default.h"
 
 #include "ADM_audiofilter/audiofilter_limiter_param.h"
 #include "ADM_audiofilter/audiofilter_normalize_param.h"
-#include "audioprocess.hxx"
 
 #include "ADM_audiofilter/audioeng_buildfilters.h"
 
@@ -33,7 +29,6 @@
 
 #include "ADM_audiocodec/ADM_audiocodeclist.h"
 
-#include "audioeng_process.h"
 
 #include "audiofilter_bridge.h"
 #include "audiofilter_mixer.h"

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioeng_buildfilters.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioeng_buildfilters.h	2008-07-16 17:39:47 UTC (rev 4223)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioeng_buildfilters.h	2008-07-16 17:39:56 UTC (rev 4224)
@@ -17,9 +17,7 @@
 #ifndef ADM_AUDIO_BUILDFILTER_H
 #define  ADM_AUDIO_BUILDFILTER_H
 
-#include "ADM_audiofilter/audioeng_process.h"
-#include "ADM_audiofilter/audioprocess.hxx"
-#include "ADM_audiofilter/audioeng_process.h"
+#include "audioencoder.h"
 
 
 

Deleted: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioeng_process.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioeng_process.cpp	2008-07-16 17:39:47 UTC (rev 4223)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioeng_process.cpp	2008-07-16 17:39:56 UTC (rev 4224)
@@ -1,102 +0,0 @@
-/***************************************************************************
-                          audioeng_process
-                             -------------------
-    copyright            : (C) 2002/2006 by mean
-    email                : fixounet at free.fr
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <math.h>
-
-#include "ADM_default.h"
-
-#include "audioprocess.hxx"
-
-#include "audioeng_process.h"
-
-#include "ADM_osSupport/ADM_debugID.h"
-#define MODULE_NAME MODULE_AUDIO_FILTER
-#include "ADM_osSupport/ADM_debug.h"
-
-
-
-AUDMAudioFilter::AUDMAudioFilter(AUDMAudioFilter *previous)
-{
-  _previous=previous;
-  if(_previous)
-  {
-      memcpy(&_wavHeader,_previous->getInfo(),sizeof(_wavHeader));
-      _length=previous->getLength();
-  }
-  _head=_tail=0; 
-}
-AUDMAudioFilter::~AUDMAudioFilter()
-{
-}
-
-uint8_t  AUDMAudioFilter::rewind(void)
-{
-  _head=_tail=0;
-  return _previous->rewind();
-}
-
-uint8_t AUDMAudioFilter::shrink(void)
-{
-  if(_tail>AUD_PROCESS_BUFFER_SIZE/2)
-  {
-    memmove(&_incomingBuffer[0],&_incomingBuffer[_head],sizeof(float)*(_tail-_head));
-    _tail-=_head;
-    _head=0;
-  }
-  if(_head==_tail)
-  {
-    _head=_tail=0;
-  }
-  return 1;
-}
-/*
-    If the incoming data is getting low (less than 1/4) fill it up 
-*/
-uint8_t AUDMAudioFilter::fillIncomingBuffer(AUD_Status *status)
-{
-  uint32_t asked;
-  *status=AUD_OK;
-  // Hysteresis
-  if((_tail-_head)<(AUD_PROCESS_BUFFER_SIZE>>2)) // Less than 1/4 full
- {
-
-  while ((  _tail < (3*AUD_PROCESS_BUFFER_SIZE)/5)) // Fill up to 3/5--3/4
-  {
-      // don't ask too much front.
-    asked = (3*AUD_PROCESS_BUFFER_SIZE)/4-_tail;
-    //asked = _incoming->readDecompress(asked, &(_incomingBuffer[_tail]));
-    asked=_previous->fill(asked,&(_incomingBuffer[_tail]),status);
-
-    if (!asked )
-    {
-      *status=AUD_END_OF_STREAM;
-      break;
-    }
-    _tail+=asked;
-  }
- }
- return 1;
-}
-
-
-WAVHeader  *AUDMAudioFilter::getInfo(void)
-{
-  return &(_wavHeader);
-}
-//EOF

Deleted: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioeng_process.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioeng_process.h	2008-07-16 17:39:47 UTC (rev 4223)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioeng_process.h	2008-07-16 17:39:56 UTC (rev 4224)
@@ -1,94 +0,0 @@
-/***************************************************************************
-                          audioeng_process.h
-                             -------------------
-    begin                : 2006
-    copyright            : (C) 2002-2006 by mean
-    email                : fixounet at free.fr
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-#ifndef __Audio_ENG_Process__
-#define __Audio_ENG_Process__
-
-#define AUD_PROCESS_BUFFER_SIZE 48000*2*4 // should be enougth 4 seconds of stereo
-#include "ADM_coreAudio/include/ADM_coreAudio.h"
-/**
-  This enumerate is used to give a more accurate error when no audio is output from
-  an audio filter.
-*/
-typedef enum 
-{
-  AUD_OK=1,           ///< No error
-  AUD_ERROR,          ///< No data was caused by an error
-  AUD_NEED_DATA,      ///< Filter was stalled, should not happend
-  AUD_END_OF_STREAM   ///< End of incoming stream, this is the nominal error case
-} AUD_Status;
-/*
-    incoming --> incomingBuffer  || Processing  --> fill (into next in chain buffer)
-          
-                   
-*/
-
-
-/**
-  This class is the base class for all audio filter.
-  Note that all datas are handled as float!
-*/
-class AUDMAudioFilter
-{
-  protected:
-    //! This will be used to store data coming from the previous filter
-    float           _incomingBuffer[AUD_PROCESS_BUFFER_SIZE]; 
-    //! Pointer to read/write indeces in the _incomingBuffer
-    uint32_t        _head;
-    uint32_t        _tail;
-
-    //! Describe the output wav format, _wavHeader->byterate holds the size in # of float (NOT SAMPLE)
-    WAVHeader       _wavHeader;
-
-    //! Pointer to the previous filter in the chain
-    AUDMAudioFilter *_previous;
-
-    //! Fill up the incoming buffer, it is called to pull data from the previous filter
-    //! \param status Status of the fill operation
-    virtual uint8_t fillIncomingBuffer(AUD_Status *status);
-    //! length in float
-    uint32_t        _length;
-    
-  public:
-/** Constructor
-    \param previous : Pointer to previous in chain filter 
-*/
-    AUDMAudioFilter(AUDMAudioFilter *previous);
-    
-//! Destructor                                
-    virtual                ~AUDMAudioFilter();
-                                
-//! Compact the _incomingBuffer to avoid overflow
-    uint8_t    shrink( void); 
-
-//! To be called by the next in chain filter. Fills output with processed datas up to max float
-//! \param max : Max number of float to put
-//! \param output : Where to store output float
-//! \param status : Status of the fill operation
-    virtual    uint32_t   fill(uint32_t max,float *output,AUD_Status *status)=0;
-                                                                                     
-//! Returns the output wavheader infos field
-        virtual    WAVHeader  *getInfo(void);
-        
-//! Rewind the stream to the beginning. Used mainly by the normalize filter 
-        virtual   uint8_t    rewind(void)  ;
-                  uint32_t   getLength(void) {return _length;};
-// Returns the channel mapping, by default it is the on from the previous
-// The value returned is an array up to MAX_CHANNELS                  
-        virtual   CHANNEL_TYPE    *getChannelMapping(void ) {return _previous->getChannelMapping();}
-};
-#endif

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audiofilter_bridge.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audiofilter_bridge.cpp	2008-07-16 17:39:47 UTC (rev 4223)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audiofilter_bridge.cpp	2008-07-16 17:39:56 UTC (rev 4224)
@@ -16,13 +16,7 @@
 #include "ADM_default.h"
 #include <math.h>
 
-#include "avifmt.h"
-#include "avifmt2.h"
-// Needed for incoming ..
-#include "audioprocess.hxx"
-
-#include "audioeng_process.h"
-
+#include "ADM_audioFilter.h"
 #include "audiofilter_bridge.h"
 
 #include "ADM_osSupport/ADM_debugID.h"

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audiofilter_bridge.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audiofilter_bridge.h	2008-07-16 17:39:47 UTC (rev 4223)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audiofilter_bridge.h	2008-07-16 17:39:56 UTC (rev 4224)
@@ -15,7 +15,7 @@
  *                                                                         *
  ***************************************************************************/
 #ifndef AUDM_BRIDGE_H
-
+#include "audioencoder.h"
 class AUDMAudioFilter_Bridge : public AUDMAudioFilter
 {
   protected:

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audiofilter_film2pal.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audiofilter_film2pal.cpp	2008-07-16 17:39:47 UTC (rev 4223)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audiofilter_film2pal.cpp	2008-07-16 17:39:56 UTC (rev 4224)
@@ -15,19 +15,11 @@
  *                                                                         *
  ***************************************************************************/
 #include "config.h"
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
 #include <math.h>
 
-#include "ADM_assert.h"
+#include "ADM_default.h"
 
-#include "avifmt.h"
-#include "avifmt2.h"
-
-
-//#include "ADM_dialog/DIA_working.h"
-#include "audioeng_process.h"
+#include "ADM_audioFilter.h"
 #include "audiofilter_film2pal.h"
 
 //__________

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audiofilter_film2pal.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audiofilter_film2pal.h	2008-07-16 17:39:47 UTC (rev 4223)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audiofilter_film2pal.h	2008-07-16 17:39:56 UTC (rev 4224)
@@ -16,7 +16,7 @@
 #ifndef AUDIO_F_FILM2PAL_H
 #define AUDIO_F_FILM2PAL_H
 
-#include "audioeng_process.h"
+#include "ADM_audioFilter.h"
 #include "audiofilter_limiter_param.h"
 class AUDMAudioFilterFilm2Pal : public AUDMAudioFilter
 {

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audiofilter_limiter.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audiofilter_limiter.cpp	2008-07-16 17:39:47 UTC (rev 4223)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audiofilter_limiter.cpp	2008-07-16 17:39:56 UTC (rev 4224)
@@ -28,21 +28,12 @@
  ***************************************************************************/
 
 #include "config.h"
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
 #include <math.h>
 
-#include "ADM_assert.h"
+#include "ADM_default.h"
 
 
-
-#include "avifmt.h"
-#include "avifmt2.h"
-
-
-
-#include "audioeng_process.h"
+#include "ADM_audioFilter.h"
 #include "audiofilter_limiter.h"
 
 

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audiofilter_limiter.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audiofilter_limiter.h	2008-07-16 17:39:47 UTC (rev 4223)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audiofilter_limiter.h	2008-07-16 17:39:56 UTC (rev 4224)
@@ -16,7 +16,7 @@
 #ifndef AUDIO_F_LIMITER_H
 #define AUDIO_F_LIMITER_H
 
-#include "audioeng_process.h"
+#include "ADM_audioFilter.h"
 #include "audiofilter_limiter_param.h"
 class AUDMAudioFilterLimiter : public AUDMAudioFilter
 {

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audiofilter_normalize.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audiofilter_normalize.cpp	2008-07-16 17:39:47 UTC (rev 4223)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audiofilter_normalize.cpp	2008-07-16 17:39:56 UTC (rev 4224)
@@ -20,17 +20,11 @@
 #include "config.h"
 #include <stdio.h>
 #include <stdlib.h>
-#include <string.h>
+
 #include <math.h>
 
-#include "ADM_assert.h"
-
-#include "avifmt.h"
-#include "avifmt2.h"
-
-
-//#include "ADM_dialog/DIA_working.h"
-#include "audioeng_process.h"
+#include "ADM_default.h"
+#include "ADM_audioFilter.h"
 #include "audiofilter_normalize_param.h"
 #include "audiofilter_normalize.h"
 #include "audiofilter_dolby.h"

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audiofilter_normalize.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audiofilter_normalize.h	2008-07-16 17:39:47 UTC (rev 4223)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audiofilter_normalize.h	2008-07-16 17:39:56 UTC (rev 4224)
@@ -1,7 +1,7 @@
 #ifndef AUDIO_F_NORMALIZE_H
 #define AUDIO_F_NORMALIZE_H
 
-#include "audioeng_process.h"
+#include "ADM_audioFilter.h"
 class AUDMAudioFilterNormalize : public AUDMAudioFilter
 {
   protected:

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioprocess.hxx
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioprocess.hxx	2008-07-16 17:39:47 UTC (rev 4223)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioprocess.hxx	2008-07-16 17:39:56 UTC (rev 4224)
@@ -19,7 +19,7 @@
 #define __AudioProcess__
 
 #include "ADM_audio/aviaudio.hxx"
-#define MINUS_ONE 0xffffffff
+
 #define PROCESS_BUFFER_SIZE 48000*4*4 // should be enougth
 #define MINIMUM_BUFFER   8192*4
 /*! Base class for chained action. This class is derivated from AVDMGenericAudioStream and has two

Copied: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/include/ADM_audioFilter.h (from rev 4223, branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioeng_process.h)
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioeng_process.h	2008-07-16 17:39:47 UTC (rev 4223)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/include/ADM_audioFilter.h	2008-07-16 17:39:56 UTC (rev 4224)
@@ -0,0 +1,94 @@
+/***************************************************************************
+                          audioeng_process.h
+                             -------------------
+    begin                : 2006
+    copyright            : (C) 2002-2006 by mean
+    email                : fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#ifndef __Audio_ENG_Process__
+#define __Audio_ENG_Process__
+
+#define AUD_PROCESS_BUFFER_SIZE 48000*2*4 // should be enougth 4 seconds of stereo
+#include "ADM_coreAudio/include/ADM_coreAudio.h"
+/**
+  This enumerate is used to give a more accurate error when no audio is output from
+  an audio filter.
+*/
+typedef enum 
+{
+  AUD_OK=1,           ///< No error
+  AUD_ERROR,          ///< No data was caused by an error
+  AUD_NEED_DATA,      ///< Filter was stalled, should not happend
+  AUD_END_OF_STREAM   ///< End of incoming stream, this is the nominal error case
+} AUD_Status;
+/*
+    incoming --> incomingBuffer  || Processing  --> fill (into next in chain buffer)
+          
+                   
+*/
+
+
+/**
+  This class is the base class for all audio filter.
+  Note that all datas are handled as float!
+*/
+class AUDMAudioFilter
+{
+  protected:
+    //! This will be used to store data coming from the previous filter
+    float           _incomingBuffer[AUD_PROCESS_BUFFER_SIZE]; 
+    //! Pointer to read/write indeces in the _incomingBuffer
+    uint32_t        _head;
+    uint32_t        _tail;
+
+    //! Describe the output wav format, _wavHeader->byterate holds the size in # of float (NOT SAMPLE)
+    WAVHeader       _wavHeader;
+
+    //! Pointer to the previous filter in the chain
+    AUDMAudioFilter *_previous;
+
+    //! Fill up the incoming buffer, it is called to pull data from the previous filter
+    //! \param status Status of the fill operation
+    virtual uint8_t fillIncomingBuffer(AUD_Status *status);
+    //! length in float
+    uint32_t        _length;
+    
+  public:
+/** Constructor
+    \param previous : Pointer to previous in chain filter 
+*/
+    AUDMAudioFilter(AUDMAudioFilter *previous);
+    
+//! Destructor                                
+    virtual                ~AUDMAudioFilter();
+                                
+//! Compact the _incomingBuffer to avoid overflow
+    uint8_t    shrink( void); 
+
+//! To be called by the next in chain filter. Fills output with processed datas up to max float
+//! \param max : Max number of float to put
+//! \param output : Where to store output float
+//! \param status : Status of the fill operation
+    virtual    uint32_t   fill(uint32_t max,float *output,AUD_Status *status)=0;
+                                                                                     
+//! Returns the output wavheader infos field
+        virtual    WAVHeader  *getInfo(void);
+        
+//! Rewind the stream to the beginning. Used mainly by the normalize filter 
+        virtual   uint8_t    rewind(void)  ;
+                  uint32_t   getLength(void) {return _length;};
+// Returns the channel mapping, by default it is the on from the previous
+// The value returned is an array up to MAX_CHANNELS                  
+        virtual   CHANNEL_TYPE    *getChannelMapping(void ) {return _previous->getChannelMapping();}
+};
+#endif

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/include/ADM_coreAudio.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/include/ADM_coreAudio.h	2008-07-16 17:39:47 UTC (rev 4223)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/include/ADM_coreAudio.h	2008-07-16 17:39:56 UTC (rev 4224)
@@ -6,6 +6,7 @@
 #define ADM_audioCore_H
 
 
+#define MINUS_ONE 0xffffffff
 
 #define DITHER_SIZE 4800
 #define DITHER_CHANNELS 6

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/include/audioencoder.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/include/audioencoder.h	2008-07-16 17:39:47 UTC (rev 4223)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/include/audioencoder.h	2008-07-16 17:39:56 UTC (rev 4224)
@@ -33,7 +33,7 @@
 
 */
 #include "ADM_audio/aviaudio.hxx" // FIXME!!!!
-#include "ADM_audiofilter/audioeng_process.h" // FIXME!!!
+#include "ADM_audioFilter.h" // FIXME!!!
  //_____________________________________________
 class AUDMEncoder //: public AVDMGenericAudioStream
 {

Copied: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/src/ADM_audioFilter.cpp (from rev 4223, branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioeng_process.cpp)
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioeng_process.cpp	2008-07-16 17:39:47 UTC (rev 4223)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/src/ADM_audioFilter.cpp	2008-07-16 17:39:56 UTC (rev 4224)
@@ -0,0 +1,97 @@
+/***************************************************************************
+                          audioeng_process
+                             -------------------
+    copyright            : (C) 2002/2006 by mean
+    email                : fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include <math.h>
+
+#include "ADM_default.h"
+
+#include "ADM_audioFilter.h"
+
+#include "ADM_osSupport/ADM_debugID.h"
+#define MODULE_NAME MODULE_AUDIO_FILTER
+#include "ADM_osSupport/ADM_debug.h"
+
+
+
+AUDMAudioFilter::AUDMAudioFilter(AUDMAudioFilter *previous)
+{
+  _previous=previous;
+  if(_previous)
+  {
+      memcpy(&_wavHeader,_previous->getInfo(),sizeof(_wavHeader));
+      _length=previous->getLength();
+  }
+  _head=_tail=0; 
+}
+AUDMAudioFilter::~AUDMAudioFilter()
+{
+}
+
+uint8_t  AUDMAudioFilter::rewind(void)
+{
+  _head=_tail=0;
+  return _previous->rewind();
+}
+
+uint8_t AUDMAudioFilter::shrink(void)
+{
+  if(_tail>AUD_PROCESS_BUFFER_SIZE/2)
+  {
+    memmove(&_incomingBuffer[0],&_incomingBuffer[_head],sizeof(float)*(_tail-_head));
+    _tail-=_head;
+    _head=0;
+  }
+  if(_head==_tail)
+  {
+    _head=_tail=0;
+  }
+  return 1;
+}
+/*
+    If the incoming data is getting low (less than 1/4) fill it up 
+*/
+uint8_t AUDMAudioFilter::fillIncomingBuffer(AUD_Status *status)
+{
+  uint32_t asked;
+  *status=AUD_OK;
+  // Hysteresis
+  if((_tail-_head)<(AUD_PROCESS_BUFFER_SIZE>>2)) // Less than 1/4 full
+ {
+
+  while ((  _tail < (3*AUD_PROCESS_BUFFER_SIZE)/5)) // Fill up to 3/5--3/4
+  {
+      // don't ask too much front.
+    asked = (3*AUD_PROCESS_BUFFER_SIZE)/4-_tail;
+    //asked = _incoming->readDecompress(asked, &(_incomingBuffer[_tail]));
+    asked=_previous->fill(asked,&(_incomingBuffer[_tail]),status);
+
+    if (!asked )
+    {
+      *status=AUD_END_OF_STREAM;
+      break;
+    }
+    _tail+=asked;
+  }
+ }
+ return 1;
+}
+
+
+WAVHeader  *AUDMAudioFilter::getInfo(void)
+{
+  return &(_wavHeader);
+}
+//EOF

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/src/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/src/CMakeLists.txt	2008-07-16 17:39:47 UTC (rev 4223)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/src/CMakeLists.txt	2008-07-16 17:39:56 UTC (rev 4224)
@@ -1,6 +1,7 @@
 SET(ADMaudioCore_SRCS
 ADM_audioUtils.cpp
 audioencoder.cpp
+ADM_audioFilter.cpp
 )	
 ADD_LIBRARY(ADM_coreAudio SHARED ${ADMaudioCore_SRCS})
 INCLUDE_DIRECTORIES(${CMAKE_SOURCE_DIR}/avidemux/ADM_coreAudio/include)

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/src/audioencoder.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/src/audioencoder.cpp	2008-07-16 17:39:47 UTC (rev 4223)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/src/audioencoder.cpp	2008-07-16 17:39:56 UTC (rev 4224)
@@ -15,8 +15,7 @@
 
 #include "ADM_default.h"
 #include "ADM_coreAudio.h"
-#include "ADM_audiofilter/audioprocess.hxx"
-#include "ADM_audiofilter/audioeng_process.h"
+#include "ADM_audioFilter.h"
 #include "audioencoder.h"
 
 AUDMEncoder::AUDMEncoder(AUDMAudioFilter *in) // :AVDMGenericAudioStream  ()

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_audioconfig.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_audioconfig.cpp	2008-07-16 17:39:47 UTC (rev 4223)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_audioconfig.cpp	2008-07-16 17:39:56 UTC (rev 4224)
@@ -18,8 +18,6 @@
 #include "ADM_default.h"
 
 #include "DIA_factory.h"
-#include "../../ADM_audiofilter/audioprocess.hxx"
-#include "../../ADM_audiofilter/audioeng_process.h"
 #include "ADM_coreAudio/include/audioencoder.h"
 
 /**



From mean at mail.berlios.de  Wed Jul 16 19:40:02 2008
From: mean at mail.berlios.de (mean at BerliOS)
Date: Wed, 16 Jul 2008 19:40:02 +0200
Subject: [Avidemux-svn-commit] r4225 - in
	branches/avidemux_2.5_branch_gruntster/avidemux: .
	ADM_audioEncoder/include ADM_audioEncoder/src ADM_audiocodec
	ADM_audiodevice ADM_audiofilter ADM_coreAudio/include
	ADM_toolkit ADM_userInterfaces/ADM_GTK/ADM_dialog
	ADM_userInterfaces/ADM_GTK/ADM_gui2
	ADM_userInterfaces/ADM_QT4/ADM_dialog
	ADM_userInterfaces/ADM_commonUI
Message-ID: <200807161740.m6GHe2oJ021146@sheep.berlios.de>

Author: mean
Date: 2008-07-16 19:39:59 +0200 (Wed, 16 Jul 2008)
New Revision: 4225

Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/include/audioencoder_config.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/include/audioencoder_enum.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/include/audioencoder_faac.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/include/audioencoder_lame.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/include/audioencoder_lavcodec.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/include/audioencoder_pcm.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/include/audioencoder_twolame.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/include/audioencoder_vorbis.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/src/audioencoder_faac.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/src/audioencoder_lame.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiocodec/ADM_audiocodeclist.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_audiodevice.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/CMakeLists.txt
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audiodeng_buildfilters.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioeng_buildfilters.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audiofilter_buildchain.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/include/audioencoder.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_toolkit/automation.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_acodec.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_GTK/ADM_gui2/GUI_bindings.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/DIA_none.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_audioconfig.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/CMakeLists.txt
   branches/avidemux_2.5_branch_gruntster/avidemux/gui_autodrive.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/main.cpp
Log:
[AudioEncoder] Disabled old audio encoder scheme, it builds


Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/include/audioencoder_config.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/include/audioencoder_config.h	2008-07-16 17:39:56 UTC (rev 4224)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/include/audioencoder_config.h	2008-07-16 17:39:59 UTC (rev 4225)
@@ -1,6 +1,7 @@
 #ifndef AUDIOENCODER_CONFIG_H
 #define AUDIOENCODER_CONFIG_H
 
+#if 0
 #include "audioencoder_faac_param.h"
 #include "audioencoder_lame_param.h"
 #include "audioencoder_twolame_param.h"
@@ -178,3 +179,4 @@
 #endif
 //EOF
 
+#endif
\ No newline at end of file

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/include/audioencoder_enum.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/include/audioencoder_enum.h	2008-07-16 17:39:56 UTC (rev 4224)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/include/audioencoder_enum.h	2008-07-16 17:39:59 UTC (rev 4225)
@@ -5,7 +5,7 @@
 
 #ifndef audioencoder_enum_h
 #define audioencoder_enum_h
-
+#if 0
 typedef enum 
 {
 	AUDIOENC_NONE,
@@ -20,5 +20,5 @@
     AUDIOENC_AFTEN,
     AUDIOENC_DUMMY
 }AUDIOENCODER;
-
+#endif
 #endif
\ No newline at end of file

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/include/audioencoder_faac.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/include/audioencoder_faac.h	2008-07-16 17:39:56 UTC (rev 4224)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/include/audioencoder_faac.h	2008-07-16 17:39:59 UTC (rev 4225)
@@ -22,7 +22,7 @@
          void           *_handle;
          uint8_t        refillBuffer(int minimum);
 public:
-                        uint8_t init(ADM_audioEncoderDescriptor *config);
+//                        uint8_t init(ADM_audioEncoderDescriptor *config);
                 virtual ~AUDMEncoder_Faac();
                         AUDMEncoder_Faac(AUDMAudioFilter *instream);	
                 virtual uint8_t	getPacket(uint8_t *dest, uint32_t *len, uint32_t *samples);

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/include/audioencoder_lame.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/include/audioencoder_lame.h	2008-07-16 17:39:56 UTC (rev 4224)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/include/audioencoder_lame.h	2008-07-16 17:39:59 UTC (rev 4225)
@@ -24,7 +24,7 @@
     ADM_LAME_PRESET   _preset;
          
   public:
-            uint8_t     init(ADM_audioEncoderDescriptor *config);
+//            uint8_t     init(ADM_audioEncoderDescriptor *config);
     virtual             ~AUDMEncoder_Lame();
                         AUDMEncoder_Lame(AUDMAudioFilter *instream);	
             uint8_t	isVBR(void );

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/include/audioencoder_lavcodec.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/include/audioencoder_lavcodec.h	2008-07-16 17:39:56 UTC (rev 4224)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/include/audioencoder_lavcodec.h	2008-07-16 17:39:59 UTC (rev 4225)
@@ -23,7 +23,7 @@
     uint32_t          _fourcc;
          
   public:
-            uint8_t     init(ADM_audioEncoderDescriptor *config);
+//            uint8_t     init(ADM_audioEncoderDescriptor *config);
    virtual             ~AUDMEncoder_Lavcodec();
                         AUDMEncoder_Lavcodec(uint32_t fourcc,AUDMAudioFilter *instream);	
    virtual uint8_t	getPacket(uint8_t *dest, uint32_t *len, uint32_t *samples);

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/include/audioencoder_pcm.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/include/audioencoder_pcm.h	2008-07-16 17:39:56 UTC (rev 4224)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/include/audioencoder_pcm.h	2008-07-16 17:39:59 UTC (rev 4225)
@@ -24,7 +24,7 @@
     uint32_t            revert;
          
   public:
-            uint8_t     init(ADM_audioEncoderDescriptor *config);
+//            uint8_t     init(ADM_audioEncoderDescriptor *config);
             virtual     ~AUDMEncoder_PCM();
                         /*! \param reverted : Should the endianness be reverted compared to system  
                             \param fourCC   : FourCC to use (WAV_PCM/WAV_LPCM)

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/include/audioencoder_twolame.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/include/audioencoder_twolame.h	2008-07-16 17:39:56 UTC (rev 4224)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/include/audioencoder_twolame.h	2008-07-16 17:39:59 UTC (rev 4225)
@@ -21,7 +21,7 @@
     void           *_twolameOptions;
          
   public:
-            uint8_t     init(ADM_audioEncoderDescriptor *config);
+//            uint8_t     init(ADM_audioEncoderDescriptor *config);
     virtual             ~AUDMEncoder_Twolame();
                         AUDMEncoder_Twolame(AUDMAudioFilter *instream);	
     virtual uint8_t	getPacket(uint8_t *dest, uint32_t *len, uint32_t *samples);

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/include/audioencoder_vorbis.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/include/audioencoder_vorbis.h	2008-07-16 17:39:56 UTC (rev 4224)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/include/audioencoder_vorbis.h	2008-07-16 17:39:59 UTC (rev 4225)
@@ -25,7 +25,7 @@
 
          
   public:
-            uint8_t     init(ADM_audioEncoderDescriptor *config);
+//            uint8_t     init(ADM_audioEncoderDescriptor *config);
             virtual     ~AUDMEncoder_Vorbis();
                         AUDMEncoder_Vorbis(AUDMAudioFilter *instream);	
             

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/src/audioencoder_faac.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/src/audioencoder_faac.cpp	2008-07-16 17:39:56 UTC (rev 4224)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/src/audioencoder_faac.cpp	2008-07-16 17:39:59 UTC (rev 4225)
@@ -73,6 +73,7 @@
 // return 0 : init failed
 //                              1 : init succeeded
 //_______________________________________________
+#if 0
 uint8_t AUDMEncoder_Faac::init(ADM_audioEncoderDescriptor *config)
 {
 unsigned long int samples_input, max_bytes_output;
@@ -142,7 +143,7 @@
     
     return 1;
 }
-
+#endif
 //_____________________________________________
 //  Need to multiply the float by 32767, can't use
 //  generic fill buffer

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/src/audioencoder_lame.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/src/audioencoder_lame.cpp	2008-07-16 17:39:56 UTC (rev 4224)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/src/audioencoder_lame.cpp	2008-07-16 17:39:59 UTC (rev 4225)
@@ -52,6 +52,7 @@
 // return 0 : init failed
 //                              1 : init succeeded
 //_______________________________________________
+
 uint8_t AUDMEncoder_Lame::init(ADM_audioEncoderDescriptor *config)
 {
   int ret;

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiocodec/ADM_audiocodeclist.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiocodec/ADM_audiocodeclist.h	2008-07-16 17:39:56 UTC (rev 4224)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiocodec/ADM_audiocodeclist.h	2008-07-16 17:39:59 UTC (rev 4225)
@@ -1,6 +1,7 @@
 
 #ifndef CODECA_LIST
 #define CODECA_LIST
+#if 0
 typedef struct {
         const char *name;
         const char *menuName;
@@ -30,3 +31,4 @@
                 {"lpcm", "WAV LPCM",AUDIOENC_LPCM,WAV_LPCM}
 };
 #endif
+#endif

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_audiodevice.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_audiodevice.cpp	2008-07-16 17:39:56 UTC (rev 4224)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiodevice/ADM_audiodevice.cpp	2008-07-16 17:39:59 UTC (rev 4225)
@@ -20,7 +20,7 @@
 #include "audio_out.h"
 #include "ADM_audioDeviceInternal.h"
 #include "prefs.h"
-
+#include "ADM_dynamicLoading.h"
 std::vector <ADM_AudioDevices *> ListOfAudioDevices;
 
 

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/CMakeLists.txt	2008-07-16 17:39:56 UTC (rev 4224)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/CMakeLists.txt	2008-07-16 17:39:59 UTC (rev 4225)
@@ -12,6 +12,7 @@
         audiolib_sox.cpp
 	audioeng_buff.cpp          
         audio_encoderWrapper.cpp
+        audio_encoderPlugin.cpp
 )
 	
 ADD_ADM_LIB_ALL_TARGETS(ADM_audiofilter ${ADMaudiofilter_SRCS})

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audiodeng_buildfilters.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audiodeng_buildfilters.cpp	2008-07-16 17:39:56 UTC (rev 4224)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audiodeng_buildfilters.cpp	2008-07-16 17:39:59 UTC (rev 4225)
@@ -89,7 +89,7 @@
 
 extern void UI_PrintCurrentACodec( const char *s);
 
-AUDIOENCODER  activeAudioEncoder=  AUDIOENC_COPY;
+
 /*----------------------------------*/
 GAINparam audioGain;
 int  audioFreq=48000;
@@ -190,23 +190,8 @@
 //
 
 
-void audioCodecChanged(int newcodec)
-{
-      ADM_assert(newcodec<sizeof(myCodecList) /sizeof(CODECLIST));
-      activeAudioEncoder=myCodecList[newcodec].codec;
 
-}
 
-uint32_t audioFilterGetNbEncoder(void)
-{
-	return sizeof(myCodecList) /sizeof(CODECLIST);
-}
-const char* audioFilterGetIndexedName(uint32_t i)
-{
- 	ADM_assert(i<sizeof(myCodecList) /sizeof(CODECLIST));
-	return myCodecList[i].menuName;
-}
-
 void audioFilterNormalizeMode(uint8_t onoff)
 {
   audioGain.mode=(ADM_GAINMode)onoff;
@@ -288,36 +273,7 @@
 
 */
 
-uint8_t audioCodecSetByName( const char *name)
-{
-		for(uint32_t i=0;i<sizeof(myCodecList)/sizeof(CODECLIST);i++)
-		{
-			if(!strcasecmp(name,myCodecList[i].name))
-			{
-
-				audioCodecSetcodec(myCodecList[i].codec);
-				return 1;
-			}
-
-		}
-		printf("\n Mmmm Select audio codec by name failed...(%s).\n",name);
-		return 0;
-}
-AudioSource audioCodecGetFromName( const char *name)
-{
-                for(uint32_t i=0;i<sizeof(myCodecList)/sizeof(CODECLIST);i++)
-                {
-                        if(!strcasecmp(name,Sources[i].name))
-                        {
-
-                                return Sources[i].type;
-                        }
-
-                }
-                printf("\n Mmmm Select audio codec by name failed...(%s).\n",name);
-                return AudioNone;
-}
-	#define Read(x) { \
+#define Read(x) { \
 		tmp=name; \
 		if((tmp=strstr(name,#x))) \
 			{ \
@@ -329,21 +285,7 @@
 			{ printf("*** %s not found !***\n",#x);} \
 		}
 #define Add(x) {sprintf(tmp,"%s=%d ",#x,x);strcat(conf,tmp);}
-
-
-const char *audioCodecGetName( void )
-{
-	for(uint32_t i=0;i<sizeof(myCodecList)/sizeof(CODECLIST);i++)
-	{
-		if(activeAudioEncoder==myCodecList[i].codec)
-		{
-			return myCodecList[i].name;
-		}
-
-	}
-	printf("\n Mmmm get audio  codec  name failed..\n");
-	return NULL;
-}
+	
 uint8_t audioFilterSetByName( const char *name)
 {
 	const char *tmp;
@@ -378,39 +320,8 @@
 	return conf;
 
 }
-void audioPrintCurrentCodec(void)
-{
+ 
 
-	for(uint32_t i=0;i<sizeof(myCodecList)/sizeof(CODECLIST);i++)
-	{
-		if(activeAudioEncoder==myCodecList[i].codec)
-		{
-			UI_setAudioCodec(i);
-			return;
-		}
-	
-	}
-	ADM_assert(0);
-}
- void audioCodecSetcodec(AUDIOENCODER codec)
-{
-
-	activeAudioEncoder=codec;
-	audioPrintCurrentCodec();
-
-}
-void audioCodecSelect( void )
-{
-	DIA_audioCodec( &activeAudioEncoder );
-	audioPrintCurrentCodec();
-
-
-}
-uint32_t audioProcessMode(void)
-{
-        if(activeAudioEncoder==AUDIOENC_COPY) return 0;
-        return 1;
-}
 /*
 	Refresh   activeAudioEncoder value
 	depending on what's selected
@@ -426,33 +337,35 @@
 	audioFreq=fq;
 }
 /**
- * 	\fn getAudioOuputTag
- *  \brief Return the encoding of the currently selected codec
- *  Must be called only in process mode, else it is meaningless.
- */
-uint32_t audioFilter_getOuputCodec(void)
-{
-	
-	for(uint32_t i=0;i<sizeof(myCodecList)/sizeof(CODECLIST);i++)
-		{
-			if(activeAudioEncoder==myCodecList[i].codec)
-			{
-				return myCodecList[i].wavTag;
-			}
-		
-		}
-	ADM_assert(0);
-	return WAV_PCM;
-}
-/**
  * 	\fn getAudioOuputFrequency
  *  \brief Return the encoding of the currently selected codec
  */
+uint32_t audioProcessMode(void);
 uint32_t audioFilter_getOuputFrequency(uint32_t inputFrequency)
 {
-	if(activeAudioEncoder==AUDIOENC_COPY) return inputFrequency;
+	if(!audioProcessMode()) return inputFrequency;
 	if(audioResampleMode == RESAMPLING_NONE) return inputFrequency;
 	return audioFreq;
 }
+/**
+    \fn audioCodecGetName
+    \brief Returns the current codec tagname
+*/
+
+AudioSource audioCodecGetFromName( const char *name)
+{
+                for(uint32_t i=0;i<sizeof(Sources)/sizeof(externalSource);i++)
+                {
+                        if(!strcasecmp(name,Sources[i].name))
+                        {
+
+                                return Sources[i].type;
+                        }
+
+                }
+                printf("\n Mmmm Select audio codec by name failed...(%s).\n",name);
+                return AudioNone;
+}
+
 //EOF
 

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioeng_buildfilters.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioeng_buildfilters.h	2008-07-16 17:39:56 UTC (rev 4224)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioeng_buildfilters.h	2008-07-16 17:39:59 UTC (rev 4225)
@@ -35,6 +35,7 @@
 void audioFilter_MP3DisableReservoir(int onoff);
 uint32_t audioFilter_getOuputCodec(void);
 uint32_t audioFilter_getOuputFrequency(uint32_t inputFrequency);
+uint32_t audioFilter_getMaxChannels(void);
 
 #include "ADM_audioEncoder/include/audioencoder_enum.h"
 
@@ -109,5 +110,6 @@
 uint8_t getAudioExtraConf(uint32_t *bitrate,uint32_t *extraDataSize, uint8_t **extradata);
 uint8_t setAudioExtraConf(uint32_t bitrate,uint32_t extraDataSize, uint8_t *extradata);
 //
+AUDMEncoder *audioEncoderCreate(AUDMAudioFilter *filter);
 #endif
 

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audiofilter_buildchain.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audiofilter_buildchain.cpp	2008-07-16 17:39:56 UTC (rev 4224)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audiofilter_buildchain.cpp	2008-07-16 17:39:59 UTC (rev 4225)
@@ -111,8 +111,8 @@
   -12.0 ,//double   mThresholdDB;
 };
 
-static ADM_audioEncoderDescriptor *getAudioDescriptor( AUDIOENCODER encoder);
 
+
 //
 // Build audio filters
 // Starttime : starttime in ms
@@ -300,111 +300,26 @@
 
 //_______________________________________________________
   uint8_t init;
-  ADM_audioEncoderDescriptor *descriptor=getAudioDescriptor( activeAudioEncoder);
   
   if(!lastFilter)
   {
     printf(" buildInternalAudioFilter failed\n");
     return 0;
   }
-  if(lastFilter->getInfo()->channels > descriptor->maxChannels)
+  if(lastFilter->getInfo()->channels > audioFilter_getMaxChannels())
   {
     GUI_Error_HIG(QT_TR_NOOP("Codec Error"),QT_TR_NOOP("The number of channels is greater than what the selected audio codec can do.\n"
         "Either change codec or use the mixer filter to have less channels."));
     deleteAudioFilter(NULL);
     return 0; 
   }
-  switch(activeAudioEncoder)
-  {
 
-                  case AUDIOENC_LPCM:
-                  case AUDIOENC_NONE:
-                  {
-                    AUDMEncoder_PCM *pcm;
-                    uint32_t fourcc,revert=0;
-                    
-                    if(activeAudioEncoder==AUDIOENC_LPCM) fourcc=WAV_LPCM;
-                    else          fourcc=WAV_PCM;
-                    
-#ifdef ADM_BIG_ENDIAN                    
-                    if(fourcc==WAV_PCM)
-#else
-                    if(fourcc==WAV_LPCM)
-#endif
-                        revert=1;
-                    pcm = new AUDMEncoder_PCM(revert,fourcc,lastFilter);
-                    tmpfilter=pcm;
-                  }
-                  break;
-#ifdef USE_VORBIS
-             case AUDIOENC_VORBIS:
-                {
-                  AUDMEncoder_Vorbis *vorbis;
-                  vorbis = new AUDMEncoder_Vorbis(lastFilter);
-                  tmpfilter=vorbis;
-                  break;
-                }
-#endif		
-#ifdef USE_AFTEN
-              case AUDIOENC_AFTEN:
-                {
-                  AUDMEncoder_Aften *aften;
-                  aften = new AUDMEncoder_Aften(lastFilter);
-                  tmpfilter=aften;
-                }
-                break;
-#endif
-#ifdef USE_FAAC
-    case AUDIOENC_FAAC:
-                  {
-                      AUDMEncoder_Faac *faac;
-                          faac = new AUDMEncoder_Faac(lastFilter);
-                          tmpfilter=faac;
-                  }
-                  break;
-#endif		
-
-#ifdef HAVE_LIBMP3LAME
-    case AUDIOENC_MP3:
-              {
-                AUDMEncoder_Lame *plame = NULL;
-
-                            plame = new AUDMEncoder_Lame(lastFilter);
-                            tmpfilter=plame;
-                }
-              break;
-#endif
-    case AUDIOENC_AC3:
-    case AUDIOENC_MP2:
-                    {
-                      AUDMEncoder_Lavcodec *lavcodec = NULL;
-                      uint32_t fourc;
-                      
-                      if(activeAudioEncoder==AUDIOENC_AC3) fourc=WAV_AC3;
-                      else fourc=WAV_MP2;
-                    
-                      lavcodec = new AUDMEncoder_Lavcodec(fourc,lastFilter);
-                      tmpfilter=lavcodec;
-                    }
-              break;
-    case  AUDIOENC_2LAME:
-              {
-                  AUDMEncoder_Twolame *toolame_enc = NULL;
-                          toolame_enc = new AUDMEncoder_Twolame(lastFilter);
-                          tmpfilter=toolame_enc;
-              }
-    	  break;
-
-    default:
-      ADM_assert(0);
-  }
-//_______________________________________________________
-
-  if(!tmpfilter->init(descriptor))
+  tmpfilter=audioEncoderCreate(lastFilter);
+  if(!tmpfilter || !tmpfilter->initialize())
   {
-    delete tmpfilter;
+    if(tmpfilter) delete tmpfilter;
     tmpfilter=NULL;
-    GUI_Error_HIG(QT_TR_NOOP("Encoder initialization failed"), QT_TR_NOOP("Not activated."));
+    GUI_Error_HIG(QT_TR_NOOP("[BuildChain] Encoder initialization failed"), QT_TR_NOOP("Not activated."));
   }
   ADM_audioEncoderWrapper *wrapper=new ADM_audioEncoderWrapper(tmpfilter);
   output=wrapper;
@@ -440,41 +355,33 @@
 */
 void audioFilter_MP3DisableReservoir(int onoff)
 {
+#if 0
       if(activeAudioEncoder!=AUDIOENC_MP3) return;
       ADM_audioEncoderDescriptor *desc=getAudioDescriptor( activeAudioEncoder);
       ADM_assert(desc);
       LAME_encoderParam *param=(LAME_encoderParam *)desc->param;
       ADM_assert(param);
       param->disableReservoir=onoff;
-  
+#endif
 }
 
 /**********************************************/
-ADM_audioEncoderDescriptor *getAudioDescriptor( AUDIOENCODER encoder)
-{
-  for(int i=0;i<NB_AUDIO_DESCRIPTOR;i++)
-  {
-    if(allDescriptors[i]->encoder==encoder)
-    {
-      return    allDescriptors[i];
-    }
-  }
-  ADM_assert(0);
-  return NULL;
-}
 
 uint8_t getAudioExtraConf(uint32_t *bitrate,uint32_t *extraDataSize, uint8_t **extradata)
 {
-  ADM_audioEncoderDescriptor *descriptor=getAudioDescriptor(activeAudioEncoder);
-  
+#define FIXME_ZAZA
+#if 0  
   *bitrate=descriptor->bitrate;
   *extraDataSize=descriptor->paramSize;
   *extradata=(uint8_t *)descriptor->param;
+#endif
   return 1;
   
 }
 uint8_t setAudioExtraConf(uint32_t bitrate,uint32_t extraDataSize, uint8_t *extradata)
 {
+#define FIXME_ZAZA
+#if 0
   ADM_audioEncoderDescriptor *descriptor=getAudioDescriptor(activeAudioEncoder);
   if(extraDataSize!=descriptor->paramSize)
   {
@@ -484,27 +391,11 @@
   printf("Valid descriptor found for audio codec\n");
   descriptor->bitrate=bitrate;
   memcpy(descriptor->param,extradata,extraDataSize);
+#endif
   return 1;
   
 }
 
-void audioCodecConfigure( void )
-{
-  ADM_audioEncoderDescriptor *descriptor=getAudioDescriptor(activeAudioEncoder);
-  if(descriptor->configure)
-  {
-    descriptor->configure(descriptor); 
-  }
-}
-uint32_t audioGetBitrate(void)
-{
-  ADM_audioEncoderDescriptor *descriptor=getAudioDescriptor(activeAudioEncoder);
-  return descriptor->bitrate;
-} 
-void audioFilter_SetBitrate( int i)
-{
-  ADM_audioEncoderDescriptor *descriptor=getAudioDescriptor(activeAudioEncoder);
-  descriptor->bitrate=i;
-}
 
 
+

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/include/audioencoder.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/include/audioencoder.h	2008-07-16 17:39:56 UTC (rev 4224)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/include/audioencoder.h	2008-07-16 17:39:59 UTC (rev 4225)
@@ -16,7 +16,31 @@
   \param param : An opaque structure that contains the codec specific configuration datas
 */
 #include "ADM_coreAudio.h"
-#include "ADM_audioEncoder/include/audioencoder_enum.h"
+
+#define ADM_AUDIO_ENCODER_API_VERSION 1
+
+#define AUDIOENC_COPY 0
+
+class AUDMEncoder;
+typedef struct
+{
+    AUDMEncoder *(*create)(WAVHeader *head);  
+    void         (*destroy)(AUDMEncoder *codec);
+    int          (*configure)(void);    
+    uint32_t     bitrate;           // Can be changed
+    const char   *codecName;        // Internal name (tag)
+    const char   *menuName;         // Displayed name (in menu)
+    const char   *description;
+    uint32_t     maxChannels;       // Const
+    uint32_t     major,minor,patch;     // Const
+    uint32_t     apiVersion;            // const
+    uint32_t     wavTag;                // const Avi fourcc
+    uint32_t     priority;              // const Higher means the codec is prefered and should appear first in the list
+    void         *opaque;
+}ADM_audioEncoder;
+
+typedef int AUDIOENCODER;
+/*
 typedef struct ADM_audioEncoderDescriptor
 {
   AUDIOENCODER encoder;
@@ -27,7 +51,7 @@
   uint32_t  paramSize;
   void     *param;
 } ADM_audioEncoderDescriptor;
-
+*/
 /*!
   Base class for all audio encoder.It does the reverse of the bridge class and offers a proper GenericAudioStreamAPI
 
@@ -68,7 +92,8 @@
     //
     virtual ~AUDMEncoder();
     AUDMEncoder(AUDMAudioFilter *in);	
-    virtual uint8_t init(ADM_audioEncoderDescriptor *config)=0;
+
+    virtual uint8_t initialize(void)=0;
     virtual uint8_t getPacket(uint8_t *dest, uint32_t *len, uint32_t *samples)=0;
     virtual uint8_t packetPerFrame( void) {return 1;}
     virtual uint8_t extraData(uint32_t *l,uint8_t **d) {*l=_extraSize;*d=_extraData;return 1;}

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_toolkit/automation.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_toolkit/automation.cpp	2008-07-16 17:39:56 UTC (rev 4224)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_toolkit/automation.cpp	2008-07-16 17:39:59 UTC (rev 4225)
@@ -385,6 +385,8 @@
 }
 void call_audiocodec(char *p)
 {
+#define FIXME_ZAZA
+#if 0
 	if(!strcasecmp(p,"MP2"))
 		audioCodecSetcodec( AUDIOENC_MP2 );
 	else if(!strcasecmp(p,"AC3"))
@@ -407,6 +409,7 @@
 		audioCodecSetcodec( AUDIOENC_NONE );
 		fprintf(stderr,"audio codec \"%s\" unknown.\n",p);
 	}
+#endif
 }
 void call_probePat(char *p)
 {

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_acodec.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_acodec.cpp	2008-07-16 17:39:56 UTC (rev 4224)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_acodec.cpp	2008-07-16 17:39:59 UTC (rev 4225)
@@ -51,7 +51,7 @@
 										-1);
 	gtk_register_dialog(dialog);
 
-	
+#if FIXME_ZAZA	
 	// now set the input one
 	for(uint32_t i=0;i<sizeof(myCodecList)/sizeof(CODECLIST);i++)
 		if(*codec==myCodecList[i].codec)
@@ -70,6 +70,7 @@
 	{
 		*codec=old;
 	}
+#endif
         gtk_unregister_dialog(dialog);
 	gtk_widget_destroy(dialog);
 	
@@ -78,11 +79,13 @@
 
 AUDIOENCODER findCodec( void )
 {
+#ifdef FIXME_ZAZA
 uint8_t j;
 			j=getRangeInMenu(lookup_widget(dialog,"optionmenu_CodecList"));
 		
 			if(j>=sizeof(myCodecList)/sizeof(CODECLIST)) ADM_assert(0);
 			return myCodecList[j].codec;
+ #endif
 			
 
 }
@@ -133,12 +136,14 @@
   menu1 = gtk_menu_new ();
 
  /***************/
+#if FIXME_ZAZA
         for(int i=0;i<sizeof(myCodecList)/sizeof(CODECLIST);i++)
         {
                 acodec[i]=gtk_menu_item_new_with_mnemonic(myCodecList[i].menuName);
                 gtk_widget_show(acodec[i]);
                 gtk_container_add(GTK_CONTAINER(menu1),acodec[i]);
         }  
+#endif
  /***************/ 
   gtk_option_menu_set_menu (GTK_OPTION_MENU (optionmenu_CodecList), menu1);
 
@@ -167,11 +172,12 @@
   GLADE_HOOKUP_OBJECT (dialogAudioCodec, optionmenu_CodecList, "optionmenu_CodecList");
   GLADE_HOOKUP_OBJECT (dialogAudioCodec, menu1, "menu1");
 /****/
+#if FIXME_ZAZA
    for(int i=0;i<sizeof(myCodecList)/sizeof(CODECLIST);i++)
         {
                 GLADE_HOOKUP_OBJECT (dialogAudioCodec, acodec[i],myCodecList[i].name );
         }
-
+#endif
 /****/
   GLADE_HOOKUP_OBJECT (dialogAudioCodec, buttonConfigure, "buttonConfigure");
   GLADE_HOOKUP_OBJECT_NO_REF (dialogAudioCodec, dialog_action_area1, "dialog_action_area1");

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_GTK/ADM_gui2/GUI_bindings.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_GTK/ADM_gui2/GUI_bindings.cpp	2008-07-16 17:39:56 UTC (rev 4224)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_GTK/ADM_gui2/GUI_bindings.cpp	2008-07-16 17:39:59 UTC (rev 4225)
@@ -515,7 +515,7 @@
                         gtk_combo_box_append_text      (combo_box,QT_TR_NOOP(name));	
                 }
         gtk_combo_box_set_active(combo_box,0);
-	on_audio_change();
+// FIXME_ZAZA	on_audio_change();
         /*   Fill in output format window */
         uint32_t nbFormat;
 

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/DIA_none.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/DIA_none.cpp	2008-07-16 17:39:56 UTC (rev 4224)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/DIA_none.cpp	2008-07-16 17:39:59 UTC (rev 4225)
@@ -34,7 +34,7 @@
 
 
 uint8_t DIA_videoCodec(int *codecIndex) {return 0;}
-uint8_t DIA_audioCodec( AUDIOENCODER *codec ) {return 0;}
+//uint8_t DIA_audioCodec( AUDIOENCODER *codec ) {return 0;}
 uint8_t DIA_quota(char *) {return 0;}
 uint8_t DIA_RecentFiles( char **name ){return 0;}
 uint8_t initGUI( void ) {return 1;}

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_audioconfig.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_audioconfig.cpp	2008-07-16 17:39:56 UTC (rev 4224)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_audioconfig.cpp	2008-07-16 17:39:59 UTC (rev 4225)
@@ -26,8 +26,10 @@
       @return 1 on success, 0 on failure
 
 */
+#if FIXME_ZAZA
 int DIA_defaultSettings(ADM_audioEncoderDescriptor *descriptor)
   {
+
     int ret=0;
     char string[400];
     uint32_t mmode,ppreset;
@@ -51,6 +53,8 @@
     
   return ( diaFactoryRun(QT_TR_NOOP("Audio Configuration"),1,elems));
 
+    return 0;
 } 
+#endif
 //EOF 
 

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/CMakeLists.txt	2008-07-16 17:39:56 UTC (rev 4224)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/CMakeLists.txt	2008-07-16 17:39:59 UTC (rev 4225)
@@ -152,7 +152,7 @@
 ########################################
 SET(ADM_SUBDIR 
 	ADM_audiofilter
-	ADM_audioEncoder
+	#ADM_audioEncoder
 	ADM_editor
 	ADM_audiocodec
 	ADM_audio
@@ -321,7 +321,7 @@
 ADD_LIB_ALL_TARGETS(ADM_coreAudio)
 
 # To be removed
-ADD_SUBDIRECTORY(ADM_audioEncoder)
+#ADD_SUBDIRECTORY(ADM_audioEncoder)
 
 ###########################################
 # External libs

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/gui_autodrive.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/gui_autodrive.cpp	2008-07-16 17:39:56 UTC (rev 4224)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/gui_autodrive.cpp	2008-07-16 17:39:59 UTC (rev 4225)
@@ -99,7 +99,7 @@
         						}
         				else
         				{
-#ifdef HAVE_LIBMP3LAME
+#ifdef FIXME_ZAZA //HAVE_LIBMP3LAME
         					audioCodecSetcodec(AUDIOENC_MP3);
         					audioFilter_SetBitrate(128);
                                                 audioFilter_MP3DisableReservoir(1);
@@ -180,7 +180,7 @@
                     }
                     else
                     {
-#ifdef USE_FAAC
+#if FIXME_ZAZA //def USE_FAAC
                           audioCodecSetcodec(AUDIOENC_FAAC);
 #else
                           GUI_Error_HIG(QT_TR_NOOP("Codec Error"),
@@ -210,7 +210,7 @@
                                 }
                                 else
                                 {
-                                        audioCodecSetcodec(AUDIOENC_2LAME);
+                                 // FIXME_ZAZA       audioCodecSetcodec(AUDIOENC_2LAME);
                                         if(currentaudiostream->getInfo()->frequency!=44100)
                                         {
                                                 audioFilterResample(44100);
@@ -240,7 +240,7 @@
                                 }
                                 else
                                 {
-                                        audioCodecSetcodec(AUDIOENC_2LAME);
+                                       // FIXME_ZAZA audioCodecSetcodec(AUDIOENC_2LAME);
                                         if(currentaudiostream->getInfo()->frequency!=44100)
                                         {
                                                 audioFilterResample(44100);
@@ -269,7 +269,7 @@
                                         || (currentaudiostream->getInfo()->encoding!=WAV_MP2 &&
                                          currentaudiostream->getInfo()->encoding!=WAV_AC3))
                                 {
-                                        audioCodecSetcodec(AUDIOENC_2LAME);
+                                       // FIXME_ZAZA audioCodecSetcodec(AUDIOENC_2LAME);
                                         audioFilterResample(48000);
                                         audioFilter_SetBitrate(160);
                                         if(currentaudiostream->getInfo()->channels!=2)

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/main.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/main.cpp	2008-07-16 17:39:56 UTC (rev 4224)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/main.cpp	2008-07-16 17:39:59 UTC (rev 4225)
@@ -72,6 +72,7 @@
 extern uint8_t ADM_ad_loadPlugins(const char *path);
 extern uint8_t ADM_vf_loadPlugins(const char *path);
 extern uint8_t ADM_av_loadPlugins(const char *path);
+extern uint8_t ADM_ae_loadPlugins(const char *path);
 extern void loadPlugins(void);
 extern void InitFactory(void);
 extern void InitCoreToolkit(void);
@@ -232,6 +233,7 @@
 	char *adPlugins = ADM_getInstallRelativePath(startDir,"ADM_plugins","audioDecoder");
 	char *vfPlugins = ADM_getInstallRelativePath(startDir,"ADM_plugins","videoFilter");
     char *avPlugins = ADM_getInstallRelativePath(startDir,"ADM_plugins","audioDevices");    
+    char *aePlugins = ADM_getInstallRelativePath(startDir,"ADM_plugins","audioEncoders");    
 
 
 	ADM_ad_loadPlugins(adPlugins);
@@ -243,6 +245,9 @@
     ADM_av_loadPlugins(avPlugins);
     delete [] avPlugins;
 
+    ADM_ae_loadPlugins(aePlugins);
+    delete [] aePlugins;
+
 	// load local audio decoder plugins
 	adPlugins=ADM_getHomeRelativePath("plugins","audioDecoder");
 	ADM_ad_loadPlugins(adPlugins);



From mean at mail.berlios.de  Wed Jul 16 19:40:21 2008
From: mean at mail.berlios.de (mean at BerliOS)
Date: Wed, 16 Jul 2008 19:40:21 +0200
Subject: [Avidemux-svn-commit] r4227 - in
	branches/avidemux_2.5_branch_gruntster:
	avidemux/ADM_audiofilter plugins/ADM_audioEncoders
	plugins/ADM_audioEncoders/lame
Message-ID: <200807161740.m6GHeLoT021245@sheep.berlios.de>

Author: mean
Date: 2008-07-16 19:40:20 +0200 (Wed, 16 Jul 2008)
New Revision: 4227

Added:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audio_encoderPlugin.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audio_encoderPlugin.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audio_encoderWrapper.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audio_encoderWrapper.h
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/CMakeLists.txt
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/lame/CMakeLists.txt
Log:
[AudioEncoder] Began implementing lame


Added: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audio_encoderPlugin.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audio_encoderPlugin.cpp	2008-07-16 17:40:07 UTC (rev 4226)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audio_encoderPlugin.cpp	2008-07-16 17:40:20 UTC (rev 4227)
@@ -0,0 +1,390 @@
+/***************************************************************************
+                          audio_encoderPlugin.cpp  -  description
+                             -------------------
+    
+    copyright            : (C) 2008 by mean
+    email                : fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include <vector>
+#include "ADM_default.h"
+#include "audioencoderInternal.h"
+#include "ADM_dynamicLoading.h"
+std::vector <ADM_audioEncoder *> ListOfAudioEncoder;
+
+static AUDIOENCODER  currentEncoder=0; //0 is always dummy
+
+static AUDIOENCODER ADM_encoderByName(const char *name);
+static const char *ADM_audioEncoderById(AUDIOENCODER id);
+
+
+class ADM_AudioEncoderLoader :public ADM_LibWrapper
+{
+
+public:
+        int                 initialised;
+        ADM_audioEncoder    *encoderBlock;
+        
+
+
+        ADM_AudioEncoderLoader(const char *file) : ADM_LibWrapper()
+		{
+                ADM_audioEncoder    *e;
+                ADM_audioEncoder *(*getInfo)(void);
+                initialised = loadLibrary(file) && getSymbols(1,
+				&getInfo, "getInfo"
+                );
+                encoderBlock=NULL;
+                if(initialised)
+                {
+                    e=getInfo();
+                    if(e->apiVersion!=ADM_AUDIO_ENCODER_API_VERSION)
+                    {
+                        e=NULL;
+                        initialised=0;
+                    }else
+                    {
+                        printf("[AudioEncoder] Loaded %s version %02d.%02d.%02d\n",e->codecName,
+                                e->major,e->minor,e->patch);
+                        encoderBlock=new ADM_audioEncoder;
+                        *encoderBlock=*e;
+                        encoderBlock->opaque=(void *)this;
+                    } 
+                }else
+                {
+                    printf("Symbol loading failed for %s\n",file);
+                }
+		}
+        ADM_AudioEncoderLoader(const char *name, const char *menuName) : ADM_LibWrapper()
+		{
+                    encoderBlock=new ADM_audioEncoder;
+                    encoderBlock->codecName=name;
+                    encoderBlock->menuName=menuName;                    
+                    encoderBlock->opaque=(void *)this;
+		}
+        ~ADM_AudioEncoderLoader()
+        {
+            if(encoderBlock) delete encoderBlock;
+            encoderBlock=NULL;
+            
+        }
+};
+
+/**
+        \fn ADM_ae_getNbEncoders
+        \brief Returns the number of av filter plugins except one
+*/
+uint32_t ADM_ae_getNbEncoders(void)
+{
+    return ListOfAudioEncoder.size()-1;
+}
+/**
+    \fn     ADM_ae_getEncoderInfo
+    \brief  Get Infos about the encoder #th plugin (plugin display)
+*/
+bool     ADM_ae_getEncoderInfo(int filter, const char **name, uint32_t *major,uint32_t *minor,uint32_t *patch)
+{
+    filter++;
+    ADM_assert(filter<ListOfAudioEncoder.size());
+    *major=ListOfAudioEncoder[filter]->major;
+    *minor=ListOfAudioEncoder[filter]->minor;
+    *patch=ListOfAudioEncoder[filter]->patch;
+    *name=ListOfAudioEncoder[filter]->description;
+    return true;
+}
+/**
+    \fn tryLoadingFilterPlugin
+    \brief Try loading the file given as argument as an audio device plugin
+
+*/
+#define Fail(x) {printf("%s:"#x"\n",file);goto er;}
+static bool tryLoadingFilterPlugin(const char *file)
+{
+	ADM_AudioEncoderLoader *dll=new ADM_AudioEncoderLoader(file);
+    if(!dll->initialised) Fail(CannotLoad);
+    
+
+    ListOfAudioEncoder.push_back(dll->encoderBlock); // Needed for cleanup. FIXME TODO Delete it.
+    printf("[AudioEncoder] Registered filter %s as  %s\n",file,dll->encoderBlock->description);
+    return true;
+	// Fail!
+er:
+	delete dll;
+	return false;
+
+}
+/**
+ * 	\fn ADM_ae_loadPlugins
+ *  \brief load all audio encoder plugins
+ */
+uint8_t ADM_ae_loadPlugins(const char *path)
+{
+#define MAX_EXTERNAL_FILTER 100
+// FIXME Factorize
+#ifdef __WIN32
+#define SHARED_LIB_EXT "dll"
+#elif defined(__APPLE__)
+#define SHARED_LIB_EXT "dylib"
+#else
+#define SHARED_LIB_EXT "so"
+#endif
+
+	char *files[MAX_EXTERNAL_FILTER];
+	uint32_t nbFile;
+    // Add the copy encoder
+    ADM_AudioEncoderLoader *copy=new ADM_AudioEncoderLoader("copy","Copy");
+    ListOfAudioEncoder.push_back(copy->encoderBlock);
+    //
+	memset(files,0,sizeof(char *)*MAX_EXTERNAL_FILTER);
+	printf("[ADM_ae_plugin] Scanning directory %s\n",path);
+
+	if(!buildDirectoryContent(&nbFile, path, files, MAX_EXTERNAL_FILTER, SHARED_LIB_EXT))
+	{
+		printf("[ADM_ae_plugin] Cannot parse plugin\n");
+		return 0;
+	}
+
+	for(int i=0;i<nbFile;i++)
+		tryLoadingFilterPlugin(files[i]);
+
+	printf("[ADM_ae_plugin] Scanning done\n");
+
+	return 1;
+}
+
+/**
+    \fn ADM_encoderByName
+    \brief Returns the Id of the given string 
+
+*/
+AUDIOENCODER ADM_encoderByName(const char *name)
+{
+	if(!name) return (AUDIOENCODER)0;
+    if(!strcasecmp(name,"copy")) return (AUDIOENCODER)0; // copy
+	for(uint32_t i=1;i<ListOfAudioEncoder.size();i++)
+	{
+		if(!strcasecmp(name,ListOfAudioEncoder[i]->codecName))
+		{
+			return i;
+		}	
+	}
+	printf("[AudioEncoder] Encoder not found :%s\n",name);
+	return (AUDIOENCODER)0;
+
+}
+/**
+    \fn    ADM_audioEncoderById
+    \brief Returns the name of a device from its Id
+*/
+static const char *ADM_audioEncoderById(AUDIOENCODER id)
+{
+
+	ADM_assert(id<ListOfAudioEncoder.size());
+    return ListOfAudioEncoder[id]->codecName;
+}
+/**
+    \fn AVDM_getCurrentAudioEncoder
+    \brief
+*/
+AUDIOENCODER AVDM_getCurrentAudioEncoder( void)
+{
+	return currentEncoder;
+}
+//*******************************************************************
+/**
+    \fn     
+    \brief
+*/
+void audioCodecChanged(int newcodec)
+{
+      ADM_assert(newcodec<ListOfAudioEncoder.size());
+      currentEncoder=newcodec;
+
+}
+
+/**
+    \fn     
+    \brief
+*/
+void audioCodecSetcodec(AUDIOENCODER codec);
+uint8_t audioCodecSetByName( const char *name)
+{
+		for(uint32_t i=0;i<ListOfAudioEncoder.size();i++)
+		{
+			if(!strcasecmp(name,ListOfAudioEncoder[i]->codecName))
+			{
+
+				audioCodecSetcodec(i);
+				return 1;
+			}
+
+		}
+		printf("\n Mmmm Select audio codec by name failed...(%s).\n",name);
+		return 0;
+}
+
+
+/**
+    \fn audioCodecGetName
+    \brief Returns the current codec tagname
+*/
+const char *audioCodecGetName( void )
+{
+	  ADM_assert(currentEncoder<ListOfAudioEncoder.size());
+      return ListOfAudioEncoder[currentEncoder]->codecName;
+
+}
+/**
+    \fn audioPrintCurrentCodec
+    \brief updates the UI with the current selected audio encoder
+*/
+void UI_setAudioCodec( int i);
+void audioPrintCurrentCodec(void)
+{
+			UI_setAudioCodec(currentEncoder);
+}
+/**
+      \fn audioCodecSetcodec
+      \brief Set & update current audio encoder
+*/
+void audioCodecSetcodec(AUDIOENCODER codec)
+{
+
+	currentEncoder=codec;
+	audioPrintCurrentCodec();
+
+}
+/**
+    \fn audioCodecSelect
+    \brief
+*/
+uint8_t DIA_audioCodec( int *codec );
+void audioCodecSelect( void )
+{
+ 
+	DIA_audioCodec( &currentEncoder );
+	audioPrintCurrentCodec();
+
+
+}
+/**
+    \fn audioProcessMode
+    \brief
+    @return 1 in process mode, 0 in copy mode
+*/
+uint32_t audioProcessMode(void)
+{
+        if(!currentEncoder) return 0;
+        return 1;
+}
+/**
+ * 	\fn getAudioOuputTag
+ *  \brief Return the encoding of the currently selected codec
+ *  Must be called only in process mode, else it is meaningless.
+ */
+uint32_t audioFilter_getOuputCodec(void)
+{
+	ADM_assert(!currentEncoder);
+    return ListOfAudioEncoder[currentEncoder]->wavTag;
+}
+
+/**
+ * 	\fn audioFilter_getMaxChannels
+ *  \brief Return the max # of channels a codec supports
+ */
+uint32_t audioFilter_getMaxChannels(void)
+{
+    ADM_assert(currentEncoder<ListOfAudioEncoder.size());
+	if(!currentEncoder) return 99999;
+	return ListOfAudioEncoder[currentEncoder]->maxChannels;
+}
+/**
+    \fn audioCodecConfigure
+    \brief
+*/
+void audioCodecConfigure( void )
+{
+    if(ListOfAudioEncoder[currentEncoder]->configure)
+    ListOfAudioEncoder[currentEncoder]->configure();
+}
+/**
+    \fn audioGetBitrate
+*/
+uint32_t audioGetBitrate(void)
+{
+    ADM_assert(currentEncoder<ListOfAudioEncoder.size());
+    return ListOfAudioEncoder[currentEncoder]->bitrate;
+} 
+void audioFilter_SetBitrate( int i)
+{
+    ADM_assert(currentEncoder<ListOfAudioEncoder.size());
+    ListOfAudioEncoder[currentEncoder]->bitrate=i;
+}
+/**
+    \fn audioEncoderGetNumberOfEncoders
+*/
+uint32_t audioEncoderGetNumberOfEncoders(void)
+{
+    return ListOfAudioEncoder.size();
+}
+/**
+    \fn audioEncoderGetDisplayName
+*/
+const char  *audioEncoderGetDisplayName(uint32_t i)
+{
+     ADM_assert(currentEncoder<ListOfAudioEncoder.size());
+     return ListOfAudioEncoder[currentEncoder]->menuName;
+}
+/**
+        \fn audioEncoderCreate
+        \brief Spawn an audio encoder
+*/
+AUDMEncoder *audioEncoderCreate(AUDMAudioFilter *filter)
+{
+      ADM_assert(currentEncoder<ListOfAudioEncoder.size());
+     return ListOfAudioEncoder[currentEncoder]->create(filter);
+}
+/**
+        \fn getAudioExtraConf
+        \brief 
+*/
+
+uint8_t getAudioExtraConf(uint32_t *bitrate,uint32_t *extraDataSize, uint8_t **extradata)
+{
+    if(!currentEncoder)
+    {
+        printf("[AudioEncoder] Cannot get conf on copy!\n");
+        return 0;
+    }
+     ADM_assert(currentEncoder<ListOfAudioEncoder.size());
+     ADM_audioEncoder *encoder= ListOfAudioEncoder[currentEncoder];
+     if(encoder->getConfigurationData)
+        return encoder->getConfigurationData(extraDataSize,extradata);
+     else return 1;
+}
+/**
+    \fn setAudioExtraConf
+*/
+uint8_t setAudioExtraConf(uint32_t bitrate,uint32_t extraDataSize, uint8_t *extradata)
+{
+    if(!currentEncoder)
+    {
+        printf("[AudioEncoder] Cannot set conf on copy!\n");
+        return 0;
+    }
+     ADM_assert(currentEncoder<ListOfAudioEncoder.size());
+     ADM_audioEncoder *encoder= ListOfAudioEncoder[currentEncoder];
+     if(encoder->setConfigurationData)
+        return encoder->setConfigurationData(extraDataSize,extradata);
+    else return 1;
+}     
+
+//**

Added: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audio_encoderPlugin.h
===================================================================

Added: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audio_encoderWrapper.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audio_encoderWrapper.cpp	2008-07-16 17:40:07 UTC (rev 4226)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audio_encoderWrapper.cpp	2008-07-16 17:40:20 UTC (rev 4227)
@@ -0,0 +1,82 @@
+/**
+        \file audio_encoderWrapper.cpp
+        \bried proxy between AUDMEncoder class and AVDMGenericAudioStream
+
+*/
+
+#include "ADM_default.h"
+#include "ADM_coreAudio.h"
+
+#include "audioencoder.h"
+
+#include "audio_encoderWrapper.h"
+
+/**
+    \fn ADM_audioEncoderWrapper
+    \brief Constructor to wrap an encoder inside ADMgenericblah blah
+
+*/
+ADM_audioEncoderWrapper::ADM_audioEncoderWrapper( AUDMEncoder *coder) : AVDMGenericAudioStream()
+{
+    _wavheader=new WAVHeader;
+    memcpy(_wavheader,coder->_wavheader,sizeof(WAVHeader));
+    _encoder=coder;
+}
+/**
+    \fn ~ADM_audioEncoderWrapper
+    \brief Destructor
+
+*/
+
+ADM_audioEncoderWrapper::~ADM_audioEncoderWrapper()
+{
+    if(_encoder) delete _encoder;
+    if(_wavheader) delete _wavheader;
+    _encoder=NULL;
+    _wavheader=NULL;
+}
+/**
+    \fn getPacket
+    \brief Trampoline
+
+*/
+
+uint8_t		ADM_audioEncoderWrapper::getPacket(uint8_t *dest, uint32_t *len, uint32_t *samples)
+{
+    ADM_assert(_encoder);
+    return _encoder->getPacket(dest,len,samples);
+}
+/**
+    \fn packetPerFrame
+    \brief Trampoline
+
+*/
+uint8_t     ADM_audioEncoderWrapper::packetPerFrame( void)
+{
+    ADM_assert(_encoder);
+    return _encoder->packetPerFrame();
+}
+/**
+    \fn read
+    \brief Trampoline
+
+*/
+uint32_t	ADM_audioEncoderWrapper::read(uint32_t size,uint8_t *ptr)
+{
+    ADM_assert(_encoder);
+    return _encoder->read(size,ptr);
+}
+/**
+    \fn extraData
+    \brief Trampoline
+
+*/
+uint8_t		ADM_audioEncoderWrapper::extraData(uint32_t *l,uint8_t **d)
+{
+
+    ADM_assert(_encoder);
+    return _encoder->extraData(l,d);
+
+}
+
+//EOF
\ No newline at end of file

Added: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audio_encoderWrapper.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audio_encoderWrapper.h	2008-07-16 17:40:07 UTC (rev 4226)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audio_encoderWrapper.h	2008-07-16 17:40:20 UTC (rev 4227)
@@ -0,0 +1,27 @@
+/**
+    \file audio_encoderWrapper.h
+    \brief Do the opposite of the bridge. Transform an ADM_audioEncoder stream to a ADMGenericVideoStream
+
+*/
+#ifndef audio_encoderWrapper_H
+#define audio_encoderWrapper_H
+#include "ADM_audio/aviaudio.hxx"
+class ADM_audioEncoderWrapper :  public AVDMGenericAudioStream
+{
+protected:
+        AUDMEncoder *_encoder;
+
+public:
+                            ADM_audioEncoderWrapper( AUDMEncoder *coder);
+        virtual             ~ADM_audioEncoderWrapper();
+        virtual	uint8_t		getPacket(uint8_t *dest, uint32_t *len, uint32_t *samples);
+		virtual uint8_t     packetPerFrame( void);
+
+        virtual uint8_t		goTo(uint32_t offset) {ADM_assert(0);return 0;} // Not supposed to seek..
+        virtual uint32_t	read(uint32_t size,uint8_t *ptr);
+        virtual uint8_t		extraData(uint32_t *l,uint8_t **d);
+};
+
+#endif
+
+//EOF

Added: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/CMakeLists.txt	2008-07-16 17:40:07 UTC (rev 4226)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/CMakeLists.txt	2008-07-16 17:40:20 UTC (rev 4227)
@@ -0,0 +1,3 @@
+#######################################
+ADD_SUBDIRECTORY(lame)
+

Added: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/lame/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/lame/CMakeLists.txt	2008-07-16 17:40:07 UTC (rev 4226)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/lame/CMakeLists.txt	2008-07-16 17:40:20 UTC (rev 4227)
@@ -0,0 +1,12 @@
+	INCLUDE(ae_plugin)
+
+	SET(ADM_ae_lame_SRCS audioencoder_lame.cpp)
+
+	ADD_LIBRARY(ADM_ae_lame SHARED ${ADM_ae_lame_SRCS})
+
+	#TARGET_LINK_LIBRARIES(ADM_ae_lame ${VORBISENC_LIBRARY_DIR})
+
+	#ADD_TARGET_CFLAGS(ADM_ae_lame "-I${VORBIS_INCLUDE_DIR}")
+
+	INIT_AUDIO_ENCODER(ADM_ae_lame)
+	INSTALL_AUDIOENCODER(ADM_ae_lame)



From mean at mail.berlios.de  Wed Jul 16 19:40:23 2008
From: mean at mail.berlios.de (mean at BerliOS)
Date: Wed, 16 Jul 2008 19:40:23 +0200
Subject: [Avidemux-svn-commit] r4228 - in
	branches/avidemux_2.5_branch_gruntster/avidemux:
	ADM_audiofilter ADM_userInterfaces/ADM_commonUI
Message-ID: <200807161740.m6GHeN3a021255@sheep.berlios.de>

Author: mean
Date: 2008-07-16 19:40:22 +0200 (Wed, 16 Jul 2008)
New Revision: 4228

Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audio_encoderPlugin.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_plugins.cpp
Log:
[UI] Update plugin display


Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audio_encoderPlugin.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audio_encoderPlugin.cpp	2008-07-16 17:40:20 UTC (rev 4227)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audio_encoderPlugin.cpp	2008-07-16 17:40:22 UTC (rev 4228)
@@ -79,18 +79,18 @@
 };
 
 /**
-        \fn ADM_ae_getNbEncoders
+        \fn ADM_ae_getPluginNbEncoders
         \brief Returns the number of av filter plugins except one
 */
-uint32_t ADM_ae_getNbEncoders(void)
+uint32_t ADM_ae_getPluginNbEncoders(void)
 {
     return ListOfAudioEncoder.size()-1;
 }
 /**
-    \fn     ADM_ae_getEncoderInfo
+    \fn     ADM_ae_getAPluginEncoderInfo
     \brief  Get Infos about the encoder #th plugin (plugin display)
 */
-bool     ADM_ae_getEncoderInfo(int filter, const char **name, uint32_t *major,uint32_t *minor,uint32_t *patch)
+bool     ADM_ae_getAPluginEncoderInfo(int filter, const char **name, uint32_t *major,uint32_t *minor,uint32_t *patch)
 {
     filter++;
     ADM_assert(filter<ListOfAudioEncoder.size());

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_plugins.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_plugins.cpp	2008-07-16 17:40:20 UTC (rev 4227)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_plugins.cpp	2008-07-16 17:40:22 UTC (rev 4228)
@@ -23,6 +23,8 @@
 bool     ADM_av_getDeviceInfo(int filter, const char **name, uint32_t *major,uint32_t *minor,uint32_t *patch);
 uint32_t ADM_ve_getNbEncoders(void);
 bool     ADM_ve_getEncoderInfo(int filter, const char **name, uint32_t *major,uint32_t *minor,uint32_t *patch);
+uint32_t ADM_ae_getPluginNbEncoders(void);
+bool     ADM_ae_getAPluginEncoderInfo(int filter, const char **name, uint32_t *major,uint32_t *minor,uint32_t *patch);
 
 /* /Functions */
 /**
@@ -35,7 +37,7 @@
     uint32_t aNbPlugin=ADM_ad_getNbFilters();
     uint32_t veNbPlugin=ADM_ve_getNbEncoders();
     uint32_t avNbPlugin=ADM_av_getNbDevices();
-
+    uint32_t aeNbPlugin=ADM_ae_getPluginNbEncoders();
     // Audio Plugins
 
     printf("[Audio Plugins] Found %u plugins\n",aNbPlugin);
@@ -124,15 +126,48 @@
 
     // /Encoder
 
-    diaElemTabs *tabs[]={&tabAudio,&tabVE,&tabAV};
-    diaFactoryRunTabs(QT_TR_NOOP("Plugins Info"),3,tabs);
+  // Audio Encoder
+    printf("[AudioEncoder Plugins] Found %u plugins\n",aeNbPlugin);
+    diaElemReadOnlyText *aeText[aeNbPlugin];
+    diaElemFrame frameAE(QT_TR_NOOP("Audio Encoder Plugins"));
+    
+ for(int i=0;i<aeNbPlugin;i++)
+    {
+        const char *name;
+        uint32_t major,minor,patch;
+        char versionString[256];
+        char infoString[256];
+        char *end;
+            ADM_ae_getAPluginEncoderInfo(i, &name,&major,&minor,&patch);
+            snprintf(versionString,255,"%02d.%02d.%02d",major,minor,patch);
+            strncpy(infoString,name,255);
+            if(strlen(infoString))
+            {
+                end=strlen(infoString)+infoString-1;
+                // Remove trailing line feed
+                while(*end==0x0a || *end==0x0d) *end--=0;
+            }
+            aeText[i]=new diaElemReadOnlyText(infoString,versionString);
+            frameAE.swallow(aeText[i]);
+    }
+    diaElem *diaAE[]={&frameAE};
+    diaElemTabs tabAE(QT_TR_NOOP("Audio Encoders"),1,diaAE);
 
+    // /Audio Encoder
+
+
+
+    diaElemTabs *tabs[]={&tabAudio,&tabVE,&tabAV,&tabAE};
+    diaFactoryRunTabs(QT_TR_NOOP("Plugins Info"),4,tabs);
+
     for(int i=0;i<aNbPlugin;i++)
         delete aText[i];
     for(int i=0;i<veNbPlugin;i++)
         delete veText[i];
     for(int i=0;i<avNbPlugin;i++)
         delete avText[i];
+    for(int i=0;i<aeNbPlugin;i++)
+        delete aeText[i];
 
     return 1;
 }



From mean at mail.berlios.de  Wed Jul 16 19:40:25 2008
From: mean at mail.berlios.de (mean at BerliOS)
Date: Wed, 16 Jul 2008 19:40:25 +0200
Subject: [Avidemux-svn-commit] r4229 -
	branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Jack
Message-ID: <200807161740.m6GHePT0021265@sheep.berlios.de>

Author: mean
Date: 2008-07-16 19:40:24 +0200 (Wed, 16 Jul 2008)
New Revision: 4229

Modified:
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Jack/ADM_deviceJack.cpp
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Jack/ADM_deviceJack.h
Log:
[Device] Jack fix


Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Jack/ADM_deviceJack.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Jack/ADM_deviceJack.cpp	2008-07-16 17:40:22 UTC (rev 4228)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Jack/ADM_deviceJack.cpp	2008-07-16 17:40:24 UTC (rev 4229)
@@ -5,9 +5,7 @@
 //
 //
 
-#include "config.h"
 
-#if defined(USE_JACK)
 #include <unistd.h>
 #include <stdio.h>
 #include <stdint.h>
@@ -15,9 +13,7 @@
 #include "ADM_default.h"
 #include "ADM_audiodevice.h"
 #include "ADM_assert.h"
-#include "ADM_audiodevice/ADM_deviceoss.h"
-#include "ADM_audiodevice/ADM_deviceALSA.h"
-#include "ADM_audiodevice/ADM_deviceJack.h"
+#include "ADM_deviceJack.h"
 
 
 #define BUFSIZE 16385
@@ -231,6 +227,7 @@
 }
 
 uint8_t jackAudioDevice::setVolume(int volume){
+#if 0
 #ifdef OSS_SUPPORT
 	ossAudioDevice dev;
 	dev.setVolume(volume);
@@ -240,12 +237,7 @@
 	dev.setVolume(volume);
 #endif
 #endif
+#endif
 	return 1;
 }
 
-#else
-void dummy_jack_func( void);
-void dummy_jack_func( void)
-{
-}
-#endif

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Jack/ADM_deviceJack.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Jack/ADM_deviceJack.h	2008-07-16 17:40:22 UTC (rev 4228)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Jack/ADM_deviceJack.h	2008-07-16 17:40:24 UTC (rev 4229)
@@ -5,7 +5,6 @@
 //
 //
 
-#ifdef USE_JACK
 
 
 #include <jack/jack.h>
@@ -40,4 +39,3 @@
 	SRC_DATA src_data;
 	#endif
 };
-#endif



From mean at mail.berlios.de  Wed Jul 16 19:40:27 2008
From: mean at mail.berlios.de (mean at BerliOS)
Date: Wed, 16 Jul 2008 19:40:27 +0200
Subject: [Avidemux-svn-commit] r4230 -
	branches/avidemux_2.5_branch_gruntster/cmake
Message-ID: <200807161740.m6GHeR5H021275@sheep.berlios.de>

Author: mean
Date: 2008-07-16 19:40:26 +0200 (Wed, 16 Jul 2008)
New Revision: 4230

Added:
   branches/avidemux_2.5_branch_gruntster/cmake/admCheckAudioEncoderLibs.cmake
Removed:
   branches/avidemux_2.5_branch_gruntster/cmake/admCheckAudioCodecLibs.cmake
Log:
[AudioEncoder] Better integration with build system


Deleted: branches/avidemux_2.5_branch_gruntster/cmake/admCheckAudioCodecLibs.cmake
===================================================================
--- branches/avidemux_2.5_branch_gruntster/cmake/admCheckAudioCodecLibs.cmake	2008-07-16 17:40:24 UTC (rev 4229)
+++ branches/avidemux_2.5_branch_gruntster/cmake/admCheckAudioCodecLibs.cmake	2008-07-16 17:40:26 UTC (rev 4230)
@@ -1,111 +0,0 @@
-########################################
-# Aften
-########################################
-OPTION(AFTEN "" ON)
-
-MESSAGE(STATUS "Checking for Aften")
-MESSAGE(STATUS "******************")
-
-IF (AFTEN)
-	FIND_HEADER_AND_LIB(AFTEN aften/aften.h aften aften_encode_init)
-	PRINT_LIBRARY_INFO("Aften" AFTEN_FOUND "${AFTEN_INCLUDE_DIR}" "${AFTEN_LIBRARY_DIR}")
-
-	IF (AFTEN_FOUND)
-		SET(USE_AFTEN 1)
-		
-		IF (NOT DEFINED AFTEN_TEST_RUN_RESULT)
-			TRY_RUN(AFTEN_TEST_RUN_RESULT
-				AFTEN_TEST_COMPILE_RESULT
-				${CMAKE_BINARY_DIR}
-				"${CMAKE_SOURCE_DIR}/cmake_compile_check/aften_check.cpp"
-				CMAKE_FLAGS "-DINCLUDE_DIRECTORIES=${AFTEN_INCLUDE_DIR}" "-DLINK_LIBRARIES=${AFTEN_LIBRARY_DIR}")
-		ENDIF (NOT DEFINED AFTEN_TEST_RUN_RESULT)
-
-		IF (AFTEN_TEST_RUN_RESULT EQUAL 8)
-			MESSAGE(STATUS "  version: 0.0.8")
-			SET(USE_AFTEN_08 1)
-		ELSEIF (AFTEN_TEST_RUN_RESULT EQUAL 7)
-			MESSAGE(STATUS "  version: 0.07")
-			SET(USE_AFTEN_07 1)
-		ELSE (AFTEN_TEST_RUN_RESULT EQUAL 8)
-			MESSAGE(STATUS "Warning: Unable to determine Aften version - support for Aften will be turned off")
-			SET(USE_AFTEN 0)
-		ENDIF (AFTEN_TEST_RUN_RESULT EQUAL 8)
-	ENDIF (AFTEN_FOUND)
-ELSE (AFTEN)
-	MESSAGE("${MSG_DISABLE_OPTION}")
-ENDIF (AFTEN)
-
-MESSAGE("")
-
-########################################
-# LAME
-########################################
-OPTION(LAME "" ON)
-
-MESSAGE(STATUS "Checking for LAME")
-MESSAGE(STATUS "*****************")
-
-IF (LAME)
-	IF (UNIX)
-		SET(LAME_REQUIRED_FLAGS "-lm")
-	ENDIF (UNIX)
-
-	FIND_HEADER_AND_LIB(LAME lame/lame.h mp3lame lame_init ${LAME_REQUIRED_FLAGS})
-	PRINT_LIBRARY_INFO("LAME" LAME_FOUND "${LAME_INCLUDE_DIR}" "${LAME_LIBRARY_DIR}")
-
-	IF (LAME_FOUND)
-		SET(HAVE_LIBMP3LAME 1)
-	ENDIF (LAME_FOUND)
-ELSE (LAME)
-	MESSAGE("${MSG_DISABLE_OPTION}")
-ENDIF (LAME)
-
-MESSAGE("")
-
-
-########################################
-# FAAC
-########################################
-OPTION(FAAC "" ON)
-
-MESSAGE(STATUS "Checking for FAAC")
-MESSAGE(STATUS "*****************")
-
-IF (FAAC)
-	FIND_HEADER_AND_LIB(FAAC faac.h faac faacEncClose)
-	PRINT_LIBRARY_INFO("FAAC" FAAC_FOUND "${FAAC_INCLUDE_DIR}" "${FAAC_LIBRARY_DIR}")
-
-	IF (FAAC_FOUND)
-		SET(USE_FAAC 1)
-	ENDIF (FAAC_FOUND)
-ELSE (FAAC)
-	MESSAGE("${MSG_DISABLE_OPTION}")
-ENDIF (FAAC)
-
-MESSAGE("")
-
-########################################
-# Vorbis
-########################################
-OPTION(VORBIS "" ON)
-
-MESSAGE(STATUS "Checking for Vorbis")
-MESSAGE(STATUS "*******************")
-
-IF (VORBIS)
-	FIND_HEADER_AND_LIB(VORBIS vorbis/vorbisenc.h vorbis vorbis_info_init)
-	FIND_HEADER_AND_LIB(VORBISENC "" vorbisenc vorbis_encode_init)
-
-	IF (VORBIS_FOUND AND VORBISENC_FOUND)
-		SET(USE_VORBIS 1)
-	ELSE (VORBIS_FOUND AND VORBISENC_FOUND)
-		SET(VORBIS_FOUND 0 CACHE INTERNAL "")
-	ENDIF (VORBIS_FOUND AND VORBISENC_FOUND)
-
-	PRINT_LIBRARY_INFO("Vorbis" VORBIS_FOUND "${VORBIS_INCLUDE_DIR}" "${VORBIS_LIBRARY_DIR} ${VORBISENC_LIBRARY_DIR}")
-ELSE (VORBIS)
-	MESSAGE("${MSG_DISABLE_OPTION}")
-ENDIF (VORBIS)
-
-MESSAGE ("")

Copied: branches/avidemux_2.5_branch_gruntster/cmake/admCheckAudioEncoderLibs.cmake (from rev 4229, branches/avidemux_2.5_branch_gruntster/cmake/admCheckAudioCodecLibs.cmake)
===================================================================
--- branches/avidemux_2.5_branch_gruntster/cmake/admCheckAudioCodecLibs.cmake	2008-07-16 17:40:24 UTC (rev 4229)
+++ branches/avidemux_2.5_branch_gruntster/cmake/admCheckAudioEncoderLibs.cmake	2008-07-16 17:40:26 UTC (rev 4230)
@@ -0,0 +1,111 @@
+########################################
+# Aften
+########################################
+OPTION(AFTEN "" ON)
+
+MESSAGE(STATUS "Checking for Aften")
+MESSAGE(STATUS "******************")
+
+IF (AFTEN)
+	FIND_HEADER_AND_LIB(AFTEN aften/aften.h aften aften_encode_init)
+	PRINT_LIBRARY_INFO("Aften" AFTEN_FOUND "${AFTEN_INCLUDE_DIR}" "${AFTEN_LIBRARY_DIR}")
+
+	IF (AFTEN_FOUND)
+		SET(USE_AFTEN 1)
+		
+		IF (NOT DEFINED AFTEN_TEST_RUN_RESULT)
+			TRY_RUN(AFTEN_TEST_RUN_RESULT
+				AFTEN_TEST_COMPILE_RESULT
+				${CMAKE_BINARY_DIR}
+				"${CMAKE_SOURCE_DIR}/cmake_compile_check/aften_check.cpp"
+				CMAKE_FLAGS "-DINCLUDE_DIRECTORIES=${AFTEN_INCLUDE_DIR}" "-DLINK_LIBRARIES=${AFTEN_LIBRARY_DIR}")
+		ENDIF (NOT DEFINED AFTEN_TEST_RUN_RESULT)
+
+		IF (AFTEN_TEST_RUN_RESULT EQUAL 8)
+			MESSAGE(STATUS "  version: 0.0.8")
+			SET(USE_AFTEN_08 1)
+		ELSEIF (AFTEN_TEST_RUN_RESULT EQUAL 7)
+			MESSAGE(STATUS "  version: 0.07")
+			SET(USE_AFTEN_07 1)
+		ELSE (AFTEN_TEST_RUN_RESULT EQUAL 8)
+			MESSAGE(STATUS "Warning: Unable to determine Aften version - support for Aften will be turned off")
+			SET(USE_AFTEN 0)
+		ENDIF (AFTEN_TEST_RUN_RESULT EQUAL 8)
+	ENDIF (AFTEN_FOUND)
+ELSE (AFTEN)
+	MESSAGE("${MSG_DISABLE_OPTION}")
+ENDIF (AFTEN)
+
+MESSAGE("")
+
+########################################
+# LAME
+########################################
+OPTION(LAME "" ON)
+
+MESSAGE(STATUS "Checking for LAME")
+MESSAGE(STATUS "*****************")
+
+IF (LAME)
+	IF (UNIX)
+		SET(LAME_REQUIRED_FLAGS "-lm")
+	ENDIF (UNIX)
+
+	FIND_HEADER_AND_LIB(LAME lame/lame.h mp3lame lame_init ${LAME_REQUIRED_FLAGS})
+	PRINT_LIBRARY_INFO("LAME" LAME_FOUND "${LAME_INCLUDE_DIR}" "${LAME_LIBRARY_DIR}")
+
+	IF (LAME_FOUND)
+		SET(USE_LAME 1)
+	ENDIF (LAME_FOUND)
+ELSE (LAME)
+	MESSAGE("${MSG_DISABLE_OPTION}")
+ENDIF (LAME)
+
+MESSAGE("")
+
+
+########################################
+# FAAC
+########################################
+OPTION(FAAC "" ON)
+
+MESSAGE(STATUS "Checking for FAAC")
+MESSAGE(STATUS "*****************")
+
+IF (FAAC)
+	FIND_HEADER_AND_LIB(FAAC faac.h faac faacEncClose)
+	PRINT_LIBRARY_INFO("FAAC" FAAC_FOUND "${FAAC_INCLUDE_DIR}" "${FAAC_LIBRARY_DIR}")
+
+	IF (FAAC_FOUND)
+		SET(USE_FAAC 1)
+	ENDIF (FAAC_FOUND)
+ELSE (FAAC)
+	MESSAGE("${MSG_DISABLE_OPTION}")
+ENDIF (FAAC)
+
+MESSAGE("")
+
+########################################
+# Vorbis
+########################################
+OPTION(VORBIS "" ON)
+
+MESSAGE(STATUS "Checking for Vorbis")
+MESSAGE(STATUS "*******************")
+
+IF (VORBIS)
+	FIND_HEADER_AND_LIB(VORBIS vorbis/vorbisenc.h vorbis vorbis_info_init)
+	FIND_HEADER_AND_LIB(VORBISENC "" vorbisenc vorbis_encode_init)
+
+	IF (VORBIS_FOUND AND VORBISENC_FOUND)
+		SET(USE_VORBIS 1)
+	ELSE (VORBIS_FOUND AND VORBISENC_FOUND)
+		SET(VORBIS_FOUND 0 CACHE INTERNAL "")
+	ENDIF (VORBIS_FOUND AND VORBISENC_FOUND)
+
+	PRINT_LIBRARY_INFO("Vorbis" VORBIS_FOUND "${VORBIS_INCLUDE_DIR}" "${VORBIS_LIBRARY_DIR} ${VORBISENC_LIBRARY_DIR}")
+ELSE (VORBIS)
+	MESSAGE("${MSG_DISABLE_OPTION}")
+ENDIF (VORBIS)
+
+MESSAGE ("")



From mean at mail.berlios.de  Wed Jul 16 19:40:37 2008
From: mean at mail.berlios.de (mean at BerliOS)
Date: Wed, 16 Jul 2008 19:40:37 +0200
Subject: [Avidemux-svn-commit] r4231 - in
	branches/avidemux_2.5_branch_gruntster: .
	avidemux/ADM_audiofilter avidemux/ADM_coreAudio/include
	avidemux/ADM_userInterfaces/ADM_GTK/ADM_gui2 cmake
	plugins/ADM_audioEncoders plugins/ADM_audioEncoders/lame
Message-ID: <200807161740.m6GHeb2u021307@sheep.berlios.de>

Author: mean
Date: 2008-07-16 19:40:36 +0200 (Wed, 16 Jul 2008)
New Revision: 4231

Modified:
   branches/avidemux_2.5_branch_gruntster/CMakeLists.txt
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audio_encoderPlugin.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/include/audioencoderInternal.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_GTK/ADM_gui2/GUI_bindings.cpp
   branches/avidemux_2.5_branch_gruntster/cmake/admConfigSummary.cmake
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/CMakeLists.txt
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/lame/CMakeLists.txt
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/lame/audioencoder_lame.cpp
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/lame/audioencoder_lame_param.h
Log:
[AudioEncoder] Better integration with build system


Modified: branches/avidemux_2.5_branch_gruntster/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/CMakeLists.txt	2008-07-16 17:40:26 UTC (rev 4230)
+++ branches/avidemux_2.5_branch_gruntster/CMakeLists.txt	2008-07-16 17:40:36 UTC (rev 4231)
@@ -141,7 +141,7 @@
 	SET(ADM_UI_QT4 0)
 ENDIF (NOT QT4_FOUND)
 
-INCLUDE(admCheckAudioCodecLibs)
+#INCLUDE(admCheckAudioCodecLibs)
 #INCLUDE(admCheckAudioDeviceLibs)
 INCLUDE(admCheckMiscLibs)
 

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audio_encoderPlugin.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audio_encoderPlugin.cpp	2008-07-16 17:40:26 UTC (rev 4230)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audio_encoderPlugin.cpp	2008-07-16 17:40:36 UTC (rev 4231)
@@ -321,12 +321,16 @@
 uint32_t audioGetBitrate(void)
 {
     ADM_assert(currentEncoder<ListOfAudioEncoder.size());
-    return ListOfAudioEncoder[currentEncoder]->bitrate;
+    if(ListOfAudioEncoder[currentEncoder]->getBitrate)
+        return ListOfAudioEncoder[currentEncoder]->getBitrate();
+    return 0;
 } 
 void audioFilter_SetBitrate( int i)
 {
     ADM_assert(currentEncoder<ListOfAudioEncoder.size());
-    ListOfAudioEncoder[currentEncoder]->bitrate=i;
+    if(ListOfAudioEncoder[currentEncoder]->setBitrate)
+        ListOfAudioEncoder[currentEncoder]->setBitrate(i);
+    
 }
 /**
     \fn audioEncoderGetNumberOfEncoders
@@ -341,7 +345,7 @@
 const char  *audioEncoderGetDisplayName(uint32_t i)
 {
      ADM_assert(currentEncoder<ListOfAudioEncoder.size());
-     return ListOfAudioEncoder[currentEncoder]->menuName;
+     return ListOfAudioEncoder[i]->menuName;
 }
 /**
         \fn audioEncoderCreate

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/include/audioencoderInternal.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/include/audioencoderInternal.h	2008-07-16 17:40:26 UTC (rev 4230)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/include/audioencoderInternal.h	2008-07-16 17:40:36 UTC (rev 4231)
@@ -18,7 +18,6 @@
     AUDMEncoder *(*create)(AUDMAudioFilter *head);  
     void         (*destroy)(AUDMEncoder *codec);
     uint8_t      (*configure)(void);    
-    uint32_t     bitrate;           // Can be changed
     const char   *codecName;        // Internal name (tag)
     const char   *menuName;         // Displayed name (in menu)
     const char   *description;
@@ -28,8 +27,16 @@
     uint32_t     priority;              // const Higher means the codec is prefered and should appear first in the list
     uint8_t      (*getConfigurationData)(uint32_t *l, uint8_t **d); // Get the encoder private conf
     uint8_t      (*setConfigurationData)(uint32_t l, uint8_t *d); // Get the encoder private conf
+
+    uint32_t     (*getBitrate)(void);
+    void         (*setBitrate)(uint32_t br);
+ 
+    uint8_t      (*setOption)(const char *paramName, uint32_t value);
+
     void         *opaque;               // Hide stuff in here
 }ADM_audioEncoder;
 
+// Macros to declare audio encoder
+
 #endif
 //EOF

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_GTK/ADM_gui2/GUI_bindings.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_GTK/ADM_gui2/GUI_bindings.cpp	2008-07-16 17:40:26 UTC (rev 4230)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_GTK/ADM_gui2/GUI_bindings.cpp	2008-07-16 17:40:36 UTC (rev 4231)
@@ -511,6 +511,7 @@
                 for(uint32_t i=0;i<nbAud;i++)
                 {
                         name=audioEncoderGetDisplayName(i); //audioFilterGetIndexedName(i);
+                        printf("Found %d %s audio encoder\n",i,name);		       
                         gtk_combo_box_append_text      (combo_box,QT_TR_NOOP(name));	
                 }
         gtk_combo_box_set_active(combo_box,0);

Modified: branches/avidemux_2.5_branch_gruntster/cmake/admConfigSummary.cmake
===================================================================
--- branches/avidemux_2.5_branch_gruntster/cmake/admConfigSummary.cmake	2008-07-16 17:40:26 UTC (rev 4230)
+++ branches/avidemux_2.5_branch_gruntster/cmake/admConfigSummary.cmake	2008-07-16 17:40:36 UTC (rev 4231)
@@ -23,20 +23,14 @@
 ADM_DISPLAY("GTK+      " "${ADM_UI_GTK}")
 ADM_DISPLAY("Qt 4      " "${ADM_UI_QT4}")
 
-MESSAGE("***  Audio Codec  ***")
-ADM_DISPLAY("Aften     " "${USE_AFTEN}")
-ADM_DISPLAY("LAME      " "${HAVE_LIBMP3LAME}")
-ADM_DISPLAY("FAAC      " "${USE_FAAC}")
-ADM_DISPLAY("Vorbis    " "${USE_VORBIS}")
+#MESSAGE("*** Audio Device  ***")
+#ADM_DISPLAY("ALSA      " "${ALSA_SUPPORT}" "${ALSA_CAPABLE}")
+#ADM_DISPLAY("aRts      " "${USE_ARTS}" "${ARTS_CAPABLE}")
+#ADM_DISPLAY("ESD       " "${USE_ESD}" "${ESD_CAPABLE}")
+#ADM_DISPLAY("JACK      " "${USE_JACK}" "${JACK_CAPABLE}")
+#ADM_DISPLAY("OSS       " "${OSS_SUPPORT}" "${OSS_CAPABLE}")
+#ADM_DISPLAY("SRC       " "${USE_SRC}" "${JACK_CAPABLE}")
 
-MESSAGE("*** Audio Device  ***")
-ADM_DISPLAY("ALSA      " "${ALSA_SUPPORT}" "${ALSA_CAPABLE}")
-ADM_DISPLAY("aRts      " "${USE_ARTS}" "${ARTS_CAPABLE}")
-ADM_DISPLAY("ESD       " "${USE_ESD}" "${ESD_CAPABLE}")
-ADM_DISPLAY("JACK      " "${USE_JACK}" "${JACK_CAPABLE}")
-ADM_DISPLAY("OSS       " "${OSS_SUPPORT}" "${OSS_CAPABLE}")
-ADM_DISPLAY("SRC       " "${USE_SRC}" "${JACK_CAPABLE}")
-
 IF (WIN32)
 	ADM_DISPLAY("Win32     " 1)
 ENDIF (WIN32)

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/CMakeLists.txt	2008-07-16 17:40:26 UTC (rev 4230)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/CMakeLists.txt	2008-07-16 17:40:36 UTC (rev 4231)
@@ -1,3 +1,15 @@
 #######################################
+include (admCheckAudioEncoderLibs)
+include (admConfigSummary)
+MESSAGE("***  Audio Codec  ***")
+ADM_DISPLAY("Aften     " "${USE_AFTEN}")
+ADM_DISPLAY("LAME      " "${USE_LAME}")
+ADM_DISPLAY("FAAC      " "${USE_FAAC}")
+ADM_DISPLAY("Vorbis    " "${USE_VORBIS}")
+MESSAGE("***  /Audio Codec  ***")
+
+
+if(USE_LAME)
 ADD_SUBDIRECTORY(lame)
+endif(USE_LAME)
 

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/lame/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/lame/CMakeLists.txt	2008-07-16 17:40:26 UTC (rev 4230)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/lame/CMakeLists.txt	2008-07-16 17:40:36 UTC (rev 4231)
@@ -4,9 +4,9 @@
 
 	ADD_LIBRARY(ADM_ae_lame SHARED ${ADM_ae_lame_SRCS})
 
-	#TARGET_LINK_LIBRARIES(ADM_ae_lame ${VORBISENC_LIBRARY_DIR})
+	TARGET_LINK_LIBRARIES(ADM_ae_lame ${LAME_LIBRARY_DIR})
 
-	#ADD_TARGET_CFLAGS(ADM_ae_lame "-I${VORBIS_INCLUDE_DIR}")
+	ADD_TARGET_CFLAGS(ADM_ae_lame "-I${LAME_INCLUDE_DIR}")
 
 	INIT_AUDIO_ENCODER(ADM_ae_lame)
 	INSTALL_AUDIOENCODER(ADM_ae_lame)

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/lame/audioencoder_lame.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/lame/audioencoder_lame.cpp	2008-07-16 17:40:26 UTC (rev 4230)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/lame/audioencoder_lame.cpp	2008-07-16 17:40:36 UTC (rev 4231)
@@ -38,6 +38,7 @@
 
 static LAME_encoderParam myLameParam=
 {
+  128,
   ADM_LAME_PRESET_CBR, // preset;
   ADM_STEREO, //ADM_mode        mode;
   2, //uint32_t        quality;
@@ -49,7 +50,6 @@
     create,                        // AUDMEncoder *(*create)(AUDMAudioFilter *head);  
     destroy,                       // void         (*destroy)(AUDMEncoder *codec);
     configure,                     // int          (*configure)(void);    
-    128,           // bitrate in kbps
     "LAME",
     "MP3 (Lame)",
     "Lame encoding plugin (c) 2008 Mean",
@@ -59,6 +59,12 @@
     200,              // const Higher means the codec is prefered and should appear first in the list
     getConfigurationData, // Get the encoder private conf
     setConfigurationData,
+
+    NULL,  // GetBitrate
+    NULL,  // SetBitrate
+
+    NULL, // Set Option
+
     NULL              // Hide stuff in here
 };
 

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/lame/audioencoder_lame_param.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/lame/audioencoder_lame_param.h	2008-07-16 17:40:26 UTC (rev 4230)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/lame/audioencoder_lame_param.h	2008-07-16 17:40:36 UTC (rev 4231)
@@ -19,9 +19,12 @@
   {ADM_LAME_PRESET_ABR,"ABR"},
   {ADM_LAME_PRESET_EXTREME,"Extreme"}
 };    
+/**
 
+*/
 typedef struct 
 {
+  uint32_t        bitrate; // in kbps
   ADM_LAME_PRESET preset;
   ADM_mode        mode;
   uint32_t        quality;



From mean at mail.berlios.de  Wed Jul 16 19:40:57 2008
From: mean at mail.berlios.de (mean at BerliOS)
Date: Wed, 16 Jul 2008 19:40:57 +0200
Subject: [Avidemux-svn-commit] r4234 - in
	branches/avidemux_2.5_branch_gruntster:
	avidemux/ADM_audioEncoder/include
	avidemux/ADM_audioEncoder/src plugins/ADM_audioEncoders
	plugins/ADM_audioEncoders/aften plugins/ADM_audioEncoders/faac
	plugins/ADM_audioEncoders/lavcodec plugins/ADM_audioEncoders/pcm
	plugins/ADM_audioEncoders/twolame plugins/ADM_audioEncoders/vorbis
Message-ID: <200807161740.m6GHeviW021384@sheep.berlios.de>

Author: mean
Date: 2008-07-16 19:40:55 +0200 (Wed, 16 Jul 2008)
New Revision: 4234

Added:
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/aften/
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/aften/CMakeLists.txt
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/aften/audioencoder_aften.cpp
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/aften/audioencoder_aften.h
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/aften/audioencoder_aften_param.h
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/faac/
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/faac/CMakeLists.txt
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/faac/audioencoder_faac.cpp
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/faac/audioencoder_faac.h
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/faac/audioencoder_faac_param.h
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/lavcodec/
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/lavcodec/audioencoder_lavcodec.cpp
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/lavcodec/audioencoder_lavcodec.h
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/pcm/
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/pcm/CMakeLists.txt
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/pcm/audioencoder_pcm.cpp
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/pcm/audioencoder_pcm.h
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/twolame/CMakeLists.txt
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/vorbis/
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/vorbis/audioencoder_vorbis.cpp
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/vorbis/audioencoder_vorbis.h
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/vorbis/audioencoder_vorbis_param.h
Removed:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/include/audioencoder_aften.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/include/audioencoder_aften_param.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/include/audioencoder_faac.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/include/audioencoder_faac_param.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/include/audioencoder_lavcodec.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/include/audioencoder_pcm.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/include/audioencoder_vorbis.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/include/audioencoder_vorbis_param.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/src/audioencoder_aften.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/src/audioencoder_faac.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/src/audioencoder_lavcodec.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/src/audioencoder_pcm.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/src/audioencoder_vorbis.cpp
Modified:
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/CMakeLists.txt
Log:
[AudioEncoder] PCM


Deleted: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/include/audioencoder_aften.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/include/audioencoder_aften.h	2008-07-16 17:40:50 UTC (rev 4233)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/include/audioencoder_aften.h	2008-07-16 17:40:55 UTC (rev 4234)
@@ -1,31 +0,0 @@
-
-/***************************************************************************
-    copyright            : (C) 2002-6 by mean
-    email                : fixounet at free.fr
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#ifndef AUDMaudioAften
-#define AUDMaudioAften
-#ifdef USE_AFTEN
- //_____________________________________________
-class AUDMEncoder_Aften : public AUDMEncoder
-{
-protected:
-         void           *_handle;
-         
-public:
-                        uint8_t init(ADM_audioEncoderDescriptor *config);
-                virtual ~AUDMEncoder_Aften();
-                        AUDMEncoder_Aften(AUDMAudioFilter *instream);	
-                virtual uint8_t	getPacket(uint8_t *dest, uint32_t *len, uint32_t *samples);
-};
-#endif
-#endif

Deleted: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/include/audioencoder_aften_param.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/include/audioencoder_aften_param.h	2008-07-16 17:40:50 UTC (rev 4233)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/include/audioencoder_aften_param.h	2008-07-16 17:40:55 UTC (rev 4234)
@@ -1,10 +0,0 @@
-#ifndef AUDM_AFTEN_PARAM_H
-#define AUDM_AFTEN_PARAM_H
-#ifdef USE_AFTEN
-
-typedef struct AFTEN_encoderParam
-{
-  ADM_mode        mode;
-};
-#endif
-#endif

Deleted: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/include/audioencoder_faac.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/include/audioencoder_faac.h	2008-07-16 17:40:50 UTC (rev 4233)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/include/audioencoder_faac.h	2008-07-16 17:40:55 UTC (rev 4234)
@@ -1,31 +0,0 @@
-
-/***************************************************************************
-    copyright            : (C) 2002-6 by mean
-    email                : fixounet at free.fr
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#ifndef AUDMaudioAAC
-#define AUDMaudioAAC
-
- //_____________________________________________
-class AUDMEncoder_Faac : public AUDMEncoder
-{
-protected:
-         void           *_handle;
-         uint8_t        refillBuffer(int minimum);
-public:
-//                        uint8_t init(ADM_audioEncoderDescriptor *config);
-                virtual ~AUDMEncoder_Faac();
-                        AUDMEncoder_Faac(AUDMAudioFilter *instream);	
-                virtual uint8_t	getPacket(uint8_t *dest, uint32_t *len, uint32_t *samples);
-};
-
-#endif

Deleted: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/include/audioencoder_faac_param.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/include/audioencoder_faac_param.h	2008-07-16 17:40:50 UTC (rev 4233)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/include/audioencoder_faac_param.h	2008-07-16 17:40:55 UTC (rev 4234)
@@ -1,8 +0,0 @@
-
-#ifndef FAAC_PARAM_H
-#define FAAC_PARAM_H
-typedef struct 
-{
-  uint32_t dummy;
-}FAAC_encoderParam;
-#endif

Deleted: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/include/audioencoder_lavcodec.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/include/audioencoder_lavcodec.h	2008-07-16 17:40:50 UTC (rev 4233)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/include/audioencoder_lavcodec.h	2008-07-16 17:40:55 UTC (rev 4234)
@@ -1,32 +0,0 @@
-
-/***************************************************************************
-    copyright            : (C) 2002-6 by mean
-    email                : fixounet at free.fr
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#ifndef AUDMaudioLavcodec
-#define AUDMaudioLavcodec
- //_____________________________________________
-class AUDMEncoder_Lavcodec : public AUDMEncoder
-{
-  protected:
-   
-    void              *_context;
-    uint32_t          _fourcc;
-         
-  public:
-//            uint8_t     init(ADM_audioEncoderDescriptor *config);
-   virtual             ~AUDMEncoder_Lavcodec();
-                        AUDMEncoder_Lavcodec(uint32_t fourcc,AUDMAudioFilter *instream);	
-   virtual uint8_t	getPacket(uint8_t *dest, uint32_t *len, uint32_t *samples);
-};
-
-#endif

Deleted: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/include/audioencoder_pcm.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/include/audioencoder_pcm.h	2008-07-16 17:40:50 UTC (rev 4233)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/include/audioencoder_pcm.h	2008-07-16 17:40:55 UTC (rev 4234)
@@ -1,36 +0,0 @@
-/***************************************************************************
-    copyright            : (C) 2002-6 by mean
-    email                : fixounet at free.fr
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#ifndef AUDMaudioPCM
-#define AUDMaudioPCM
-
-/*!
-    This class is the float->PCM encoder.
-    It is somehow special as it can alsa be a LPCM encoder and a bigendian/littleendian swapper
-*/
-class AUDMEncoder_PCM : public AUDMEncoder
-{
-  protected:
-    uint32_t            revert;
-         
-  public:
-//            uint8_t     init(ADM_audioEncoderDescriptor *config);
-            virtual     ~AUDMEncoder_PCM();
-                        /*! \param reverted : Should the endianness be reverted compared to system  
-                            \param fourCC   : FourCC to use (WAV_PCM/WAV_LPCM)
-                        */
-                         AUDMEncoder_PCM(uint32_t reverted,uint32_t fourCC,AUDMAudioFilter * instream);
-    virtual uint8_t	getPacket(uint8_t *dest, uint32_t *len, uint32_t *samples);
-};
-
-#endif

Deleted: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/include/audioencoder_vorbis.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/include/audioencoder_vorbis.h	2008-07-16 17:40:50 UTC (rev 4233)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/include/audioencoder_vorbis.h	2008-07-16 17:40:55 UTC (rev 4234)
@@ -1,35 +0,0 @@
-
-/***************************************************************************
-    copyright            : (C) 2002-6 by mean
-    email                : fixounet at free.fr
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#ifndef AUDMaudioVorbis
-#define AUDMaudioVorbis
-
- //_____________________________________________
-class AUDMEncoder_Vorbis : public AUDMEncoder
-{
-  protected:
-   
-    void              *_handle;
-    uint64_t          _oldpos;
-
-         
-  public:
-//            uint8_t     init(ADM_audioEncoderDescriptor *config);
-            virtual     ~AUDMEncoder_Vorbis();
-                        AUDMEncoder_Vorbis(AUDMAudioFilter *instream);	
-            
-   virtual uint8_t	getPacket(uint8_t *dest, uint32_t *len, uint32_t *samples);
-};
-
-#endif

Deleted: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/include/audioencoder_vorbis_param.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/include/audioencoder_vorbis_param.h	2008-07-16 17:40:50 UTC (rev 4233)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/include/audioencoder_vorbis_param.h	2008-07-16 17:40:55 UTC (rev 4234)
@@ -1,17 +0,0 @@
-#ifndef AUDM_VORBIS_PARAM_H
-#define AUDM_VORBIS_PARAM_H
-
-typedef enum 
-{
-  ADM_VORBIS_CBR,
-  ADM_VORBIS_VBR,
-  ADM_VORBIS_QUALITY
-  
-}ADM_VORBIS_MODE;
-
-typedef struct 
-{
-  ADM_VORBIS_MODE    mode;   // 0 cbr 1 vbr 2 quality
-  float              quality;
-}VORBIS_encoderParam;
-#endif

Deleted: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/src/audioencoder_aften.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/src/audioencoder_aften.cpp	2008-07-16 17:40:50 UTC (rev 4233)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/src/audioencoder_aften.cpp	2008-07-16 17:40:55 UTC (rev 4234)
@@ -1,166 +0,0 @@
-
-/***************************************************************************
-    copyright            : (C) 2002-6 by mean
-    email                : fixounet at free.fr
-
-    Interface to Aften
-
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#include "config.h"
-#ifdef USE_AFTEN
-#include "config.h"
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <math.h>
-
-
-#include "ADM_default.h"
-
-#include "audioprocess.hxx"
-#include "audioeng_process.h"
-#include "audioencoder.h"
-//
-extern "C"
-{
-#if defined(USE_AFTEN_06)
-	#include "aften.h"
-#else	// Aften 0.05 & 0.07 onwards
-	#include "aften/aften.h"
-#endif
-};
-#include "audioencoder_aften_param.h"
-#include "audioencoder_aften.h"
-
-#define _HANDLE ((AftenContext *)_handle)
-AUDMEncoder_Aften::AUDMEncoder_Aften(AUDMAudioFilter * instream)  :AUDMEncoder    (instream)
-{
-  uint32_t channels;
-  channels=instream->getInfo()->channels;
-  _handle=(void *)new AftenContext;
-  memset(_handle,0,sizeof(AftenContext));
-  aften_set_defaults(_HANDLE);
-  _wavheader->encoding=WAV_AC3;
-#if defined(USE_AFTEN_05) || defined(USE_AFTEN_06)
-#elif defined(USE_AFTEN_07)
-  _HANDLE->params.n_threads=1; // MThread collides with avidemux multithreading
-#else
-  _HANDLE->system.n_threads=1;
-#endif
-};
-
-
-AUDMEncoder_Aften::~AUDMEncoder_Aften()
-{
-    if(_handle)
-      aften_encode_close(_HANDLE);
-    delete(_HANDLE);
-    _handle=NULL;
-
-    printf("[Aften] Deleting aften\n");
-    cleanup();
-};
-
-
-//________________________________________________
-//   Init lame encoder
-// frequence    : Impose frequency , 0 means reuse the incoming fq
-// mode                         : ADM_STEREO etc...
-// bitrate              : Bitrate in kbps (96,192...)
-// return 0 : init failed
-//                              1 : init succeeded
-//_______________________________________________
-uint8_t AUDMEncoder_Aften::init(ADM_audioEncoderDescriptor *config)
-{
-
-
-int ret=0;
-
-#if defined(USE_AFTEN_05) || defined(USE_AFTEN_06)
-int mask;
-#else
-unsigned int mask;
-#endif
-
-    _wavheader->byterate=(config->bitrate*1000)/8;
-    _HANDLE->sample_format=A52_SAMPLE_FMT_FLT;
-    _HANDLE->channels=_wavheader->channels;
-    _HANDLE->samplerate=_wavheader->frequency;
-    
-    _HANDLE->params.bitrate=config->bitrate;
-    switch(_wavheader->channels)
-    {
-        case 1: mask = 0x04;  break;
-        case 2: mask = 0x03;  break;
-        case 3: mask = 0x07;  break;
-        case 4: mask = 0x107; break;
-        case 5: mask = 0x37;  break;
-        case 6: mask = 0x3F;  break;
-      }
-
-#if defined(USE_AFTEN_05) || defined(USE_AFTEN_06)
-	aften_wav_chmask_to_acmod(_wavheader->channels, mask, &(_HANDLE->acmod), &(_HANDLE->lfe));
-#else
-	aften_wav_channels_to_acmod(_wavheader->channels, mask, &(_HANDLE->acmod), &(_HANDLE->lfe));
-#endif
-
-   //   _HANDLE->params.verbose=2;
-    int er= aften_encode_init(_HANDLE);
-    if(er<0)
-    {
-      printf("[Aften] init error %d\n",er); 
-      return 0;
-    }
-    _chunk=256*6*_wavheader->channels;
-    printf("[Aften] Initialized with fd %u Channels %u bitrate %u\n",_HANDLE->samplerate,
-                                                                    _HANDLE->channels,_HANDLE->params.bitrate);
-    return 1;
-}
-
-
-//______________________________________________
-uint8_t	AUDMEncoder_Aften::getPacket(uint8_t *dest, uint32_t *len, uint32_t *samples)
-{
-  uint32_t count=0;
-  int r;
-  void *ptr;
-_again:
-        *len = 0;
-        _chunk=256*6*_wavheader->channels;
-        if(!refillBuffer(_chunk ))
-        {
-          return 0; 
-        }
-        ptr=(void *)&(tmpbuffer[tmphead]);
-        ADM_assert(tmptail>=tmphead);
-
-#ifdef USE_AFTEN_05
-		aften_remap_wav_to_a52(ptr, 256*6, _wavheader->channels, A52_SAMPLE_FMT_FLT, _HANDLE->acmod, _HANDLE->lfe);
-#else
-		aften_remap_wav_to_a52(ptr, 256*6, _wavheader->channels, A52_SAMPLE_FMT_FLT, _HANDLE->acmod);
-#endif
-
-        r=aften_encode_frame(_HANDLE, dest,(void *)ptr);
-        if(r<0)
-        {
-          printf("[Aften] Encoding error %d\n",r);
-          return 0; 
-        }
-        
-        *samples=256*6;
-        *len=r;
-        tmphead+=_chunk;
-        return 1;
-}
-
-#endif		
-// EOF

Deleted: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/src/audioencoder_faac.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/src/audioencoder_faac.cpp	2008-07-16 17:40:50 UTC (rev 4233)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/src/audioencoder_faac.cpp	2008-07-16 17:40:55 UTC (rev 4234)
@@ -1,222 +0,0 @@
-
-/***************************************************************************
-    copyright            : (C) 2002-6 by mean
-    email                : fixounet at free.fr
-
-    Interface to FAAC
-
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#include "config.h"
-#ifdef USE_FAAC
-#include "config.h"
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <math.h>
-
-
-#include "ADM_default.h"
-
-#include "audioencoder.h"
-//
-
-#include "faac.h"
-#include "audioencoder_faac.h"
-
-AUDMEncoder_Faac::AUDMEncoder_Faac(AUDMAudioFilter * instream)  :AUDMEncoder    (instream)
-{
-  uint32_t channels;
-  channels=instream->getInfo()->channels;
-  switch(channels)
-  {
-    case 1:outputChannelMapping[1] = CH_FRONT_LEFT;break;
-    case 2:
-    	outputChannelMapping[0] = CH_FRONT_LEFT;
-    	outputChannelMapping[1] = CH_FRONT_RIGHT;
-      break;
-    default :
-    	outputChannelMapping[0] = CH_FRONT_CENTER;
-    	outputChannelMapping[1] = CH_FRONT_LEFT;
-    	outputChannelMapping[2] = CH_FRONT_RIGHT;
-    	outputChannelMapping[3] = CH_REAR_LEFT;
-    	outputChannelMapping[4] = CH_REAR_RIGHT;
-    	outputChannelMapping[5] = CH_LFE;
-  }
-};
-
-
-AUDMEncoder_Faac::~AUDMEncoder_Faac()
-{
-    if(_handle)
-        faacEncClose(_handle);
-    _handle=NULL;
-
-    printf("[FAAC] Deleting faac\n");
-    cleanup();
-};
-
-
-//________________________________________________
-//   Init lame encoder
-// frequence    : Impose frequency , 0 means reuse the incoming fq
-// mode                         : ADM_STEREO etc...
-// bitrate              : Bitrate in kbps (96,192...)
-// return 0 : init failed
-//                              1 : init succeeded
-//_______________________________________________
-#if 0
-uint8_t AUDMEncoder_Faac::init(ADM_audioEncoderDescriptor *config)
-{
-unsigned long int samples_input, max_bytes_output;
-faacEncConfigurationPtr cfg;
-int ret=0;
-
-    printf("[FAAC] Incoming Fq :%u\n",_wavheader->frequency);
-     _handle = faacEncOpen(_wavheader->frequency,
-                                 _wavheader->channels,
-                                 &samples_input,
-                                &max_bytes_output);
-    if(!_handle)
-    {
-          printf("Cannot open faac with fq=%lu chan=%lu br=%lu\n",
-          _wavheader->frequency,_wavheader->channels,config->bitrate);
-          return 0;
-    }
-    printf(" [FAAC] : Sample input:%d, max byte output%d \n",samples_input,max_bytes_output);
-    cfg= faacEncGetCurrentConfiguration(_handle);
-    
-    // Set default conf, same as ffmpeg
-    cfg->aacObjectType = LOW;
-    cfg->mpegVersion = MPEG4;
-    cfg->bandWidth= (_wavheader->frequency*3)/4; // Should be relevant
-    cfg->useTns = 0;
-    cfg->allowMidside = 0;
-    cfg->bitRate = (config->bitrate*1000)/_wavheader->channels; // It is per channel
-    cfg->outputFormat = 0; // 0 Raw 1 ADTS
-    cfg->inputFormat = FAAC_INPUT_FLOAT;
-    cfg->useLfe=0;	
-    if (!(ret=faacEncSetConfiguration(_handle, cfg))) 
-    {
-        printf("[FAAC] Cannot set conf for faac with fq=%lu chan=%lu br=%lu (err:%d)\n",
-				_wavheader->frequency,_wavheader->channels,config->bitrate,ret);
-	return 0;
-    }
-     unsigned char *data=NULL;
-     unsigned long size=0;
-     if((ret=faacEncGetDecoderSpecificInfo(_handle, &data,&size)))
-     {
-        printf("FAAC: GetDecoderSpecific info failed (err:%d)\n",ret);
-        return 0;
-     }
-     _extraSize=size;
-     _extraData=new uint8_t[size];
-     memcpy(_extraData,data,size);
-
-    // update
-     _wavheader->byterate=(config->bitrate*1000)/8;
-//    _wavheader->dwScale=1024;
-//    _wavheader->dwSampleSize=0;
-    _wavheader->blockalign=4096;
-    _wavheader->bitspersample=0;
-
-    _chunk=samples_input;
-
-
-    printf("[Faac] Initialized :\n");
-    
-    printf("[Faac]Version        : %s\n",cfg->name);
-    printf("[Faac]Bitrate        : %lu\n",cfg->bitRate);
-    printf("[Faac]Mpeg2 (1)/4(0) : %u\n",cfg->mpegVersion);
-    printf("[Faac]Use lfe      ) : %u\n",cfg->useLfe);
-    printf("[Faac]Sample output  : %lu\n",_chunk / _wavheader->channels);
-    printf("[Faac]Bitrate        : %lu\n",cfg->bitRate*_wavheader->channels);
-
-    
-    return 1;
-}
-#endif
-//_____________________________________________
-//  Need to multiply the float by 32767, can't use
-//  generic fill buffer
-//----------------------------------------------
-uint8_t AUDMEncoder_Faac::refillBuffer(int minimum)
-{
-  uint32_t filler=_wavheader->frequency*_wavheader->channels;
-  uint32_t nb;
-  AUD_Status status;
-  if(eof_met) return 0;
-  while(1)
-  {
-    ADM_assert(tmptail>=tmphead);
-    if((tmptail-tmphead)>=minimum) return 1;
-  
-    if(tmphead && tmptail>filler/2)
-    {
-      memmove(&tmpbuffer[0],&tmpbuffer[tmphead],(tmptail-tmphead)*sizeof(float)); 
-      tmptail-=tmphead;
-      tmphead=0;
-    }
-    ADM_assert(filler>tmptail);
-    nb=_incoming->fill( (filler-tmptail)/2,&tmpbuffer[tmptail],&status);
-    if(!nb)
-    {
-      if(status!=AUD_END_OF_STREAM) ADM_assert(0);
-      
-      if((tmptail-tmphead)<minimum)
-      {
-        memset(&tmpbuffer[tmptail],0,sizeof(float)*(minimum-(tmptail-tmphead)));
-        tmptail=tmphead+minimum;
-        eof_met=1;  
-        return minimum;
-      }
-      else continue;
-    } else
-    {
-      float *s=&(tmpbuffer[tmptail]);
-      for(int i=0;i<nb;i++)
-      {
-        *s=*s*32767.;
-        s++;
-      }
-      tmptail+=nb;
-    }
-  }
-}
-
-#define FA_BUFFER_SIZE (SIZE_INTERNAL/4)
-//______________________________________________
-uint8_t	AUDMEncoder_Faac::getPacket(uint8_t *dest, uint32_t *len, uint32_t *samples)
-{
-  uint32_t count=0;
-_again:
-        *samples = _chunk/_wavheader->channels;
-        *len = 0;
-
-        if(!refillBuffer(_chunk ))
-        {
-          return 0; 
-        }
-        ADM_assert(tmptail>=tmphead);
-        reorderChannels(&(tmpbuffer[tmphead]),*samples,_incoming->getChannelMapping(),outputChannelMapping);
-        *len = faacEncEncode(_handle, (int32_t *)&(tmpbuffer[tmphead]), _chunk, dest, FA_BUFFER_SIZE);
-        if(!*len) 
-        {
-          count++;
-          if(count<20)
-            goto _again;
-          *samples=0;
-        }
-        tmphead+=_chunk;
-        return 1;
-}
-#endif		
-// EOF

Deleted: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/src/audioencoder_lavcodec.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/src/audioencoder_lavcodec.cpp	2008-07-16 17:40:50 UTC (rev 4233)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/src/audioencoder_lavcodec.cpp	2008-07-16 17:40:55 UTC (rev 4234)
@@ -1,147 +0,0 @@
-/***************************************************************************
-                        
-    copyright            : (C) 2002-2006 by mean
-    email                : fixounet at free.fr
-    
-    Interface to FFmpeg mpeg1/2 audio encoder
-    
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <math.h>
-
-#include "ADM_default.h"
-
-#include "audioencoder.h"
-//
-#include "audioencoder_lavcodec.h"
-
-#include "ADM_lavcodec.h"
-
-#include "ADM_osSupport/ADM_debugID.h"
-#define MODULE_NAME MODULE_AUDIO_FILTER
-#include "ADM_osSupport/ADM_debug.h"
-
-
-#define CONTEXT ((AVCodecContext  	*)_context)
-
-
-// Ctor: Duplicate
-//__________
-
-AUDMEncoder_Lavcodec::AUDMEncoder_Lavcodec(uint32_t fourcc,AUDMAudioFilter * instream)  :AUDMEncoder    (instream)
-{
-  _fourcc=fourcc;
-  if(_fourcc!=WAV_MP2 && _fourcc!=WAV_AC3) ADM_assert(0);
-  _context=NULL;
-  _wavheader->encoding=_fourcc;
-  printf("[Lavcodec] Creating Lavcodec\n");
-};
-
-
-AUDMEncoder_Lavcodec::~AUDMEncoder_Lavcodec()
-{
-  printf("[Lavcodec] Deleting Lavcodec\n");
-  if(_context)
-  {
-    avcodec_close(CONTEXT);
-    ADM_dealloc(_context);
-  }
-  _context=NULL;
-  cleanup();
-};
-
-//________________________________________________
-//   Init lame encoder
-//_______________________________________________
-uint8_t AUDMEncoder_Lavcodec::init(ADM_audioEncoderDescriptor *config)
-{
-  int ret;
-  _context=( void *)avcodec_alloc_context();
-  _wavheader->byterate=(config->bitrate*1000)>>3;
-
-      
-  if(_fourcc==WAV_MP2 && _incoming->getInfo()->channels>2)
-  {
-    printf("[Lavcodec]Too many channels\n");
-    return 0; 
-  }
-  _wavheader->byterate=(config->bitrate*1000)>>3;         
-      
-  if(_fourcc==WAV_MP2)
-    _chunk = 1152*_wavheader->channels;
-  else
-    _chunk = 1536*_wavheader->channels; // AC3
-
-  printf("[Lavcodec]Incoming : fq : %lu, channel : %lu bitrate: %lu \n",
-         _wavheader->frequency,_wavheader->channels,config->bitrate);
-  
-  
-  CONTEXT->channels     =  _wavheader->channels;
-  CONTEXT->sample_rate  =  _wavheader->frequency;
-  CONTEXT->bit_rate     = (config->bitrate*1000); // bits -> kbits
-
-  AVCodec *codec;
-  CodecID codecID;
-  
-  if(_fourcc==WAV_MP2) codecID=CODEC_ID_MP2;
-        else codecID=CODEC_ID_AC3;
-  codec = avcodec_find_encoder(codecID);
-  ADM_assert(codec);
-  
-  ret = avcodec_open(CONTEXT, codec);
-  if (0> ret) 
-  {
-    printf("[Lavcodec] init failed err : %d!\n",ret);
-    return 0;
-  }
-
-
-  printf("[Lavcodec]Lavcodec successfully initialized\n");
-  return 1;       
-}
-//*********************************
-uint8_t	AUDMEncoder_Lavcodec::getPacket(uint8_t *dest, uint32_t *len, uint32_t *samples)
-{
-  uint32_t nbout;
-  
-  *samples = _chunk/_wavheader->channels; //FIXME
-  *len = 0;
-
-  if(!refillBuffer(_chunk ))
-  {
-    return 0; 
-  }
-        
-  if(tmptail-tmphead<_chunk)
-  {
-    return 0; 
-  }
-
-  dither16(&(tmpbuffer[tmphead]),_chunk,_wavheader->channels);
-
-  ADM_assert(tmptail>=tmphead);
-  nbout = avcodec_encode_audio(CONTEXT, dest, 5000, (short *) &(tmpbuffer[tmphead]));
-
-  tmphead+=_chunk;
-  if (nbout < 0) 
-  {
-    printf("[Lavcodec] Error !!! : %ld\n", nbout);
-    return 0;
-  }
-  *len=nbout;
-  return 1;
-}
-
-// EOF

Deleted: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/src/audioencoder_pcm.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/src/audioencoder_pcm.cpp	2008-07-16 17:40:50 UTC (rev 4233)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/src/audioencoder_pcm.cpp	2008-07-16 17:40:55 UTC (rev 4234)
@@ -1,112 +0,0 @@
-/***************************************************************************
-    copyright            : (C) 2006 by mean
-    email                : fixounet at free.fr
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <math.h>
-
-#include "ADM_default.h"
-
-#include "audioencoder.h"
-//
-#include "audioencoder_pcm.h"
-
-
-#include "ADM_osSupport/ADM_debugID.h"
-#define MODULE_NAME MODULE_AUDIO_FILTER
-#include "ADM_osSupport/ADM_debug.h"
-
-
-
-
-// Ctor: Duplicate
-//__________
-
-AUDMEncoder_PCM::AUDMEncoder_PCM(uint32_t reverted,uint32_t fourCC,AUDMAudioFilter * instream)  :AUDMEncoder    (instream)
-{
-  printf("[PCM] Creating PCM\n");
-  ADM_assert(fourCC==WAV_PCM || fourCC==WAV_LPCM);
-  _wavheader->encoding=fourCC;
-  revert=reverted;
-};
-
-
-AUDMEncoder_PCM::~AUDMEncoder_PCM()
-{
-  printf("[PCM] Deleting PCM\n");
-  cleanup();
-};
-
-//________________________________________________
-//   Init lame encoder
-// frequence    : Impose frequency , 0 means reuse the incoming fq
-// mode                         : ADM_STEREO etc...
-// bitrate              : Bitrate in kbps (96,192...)
-// return 0 : init failed
-//                              1 : init succeeded
-//_______________________________________________
-uint8_t AUDMEncoder_PCM::init(ADM_audioEncoderDescriptor *config)
-{
-  
-  _wavheader->byterate=_wavheader->channels*_wavheader->frequency*2;
-  _chunk = (_wavheader->frequency/100)*_wavheader->channels*2;
-  
-
- 
-  printf("[PCM]Incoming :fq : %lu, channel : %lu \n",_wavheader->frequency,_wavheader->channels);
-  printf("[PCM]PCM successfully initialized\n");
-  return 1;       
-}
-
-uint8_t	AUDMEncoder_PCM::getPacket(uint8_t *dest, uint32_t *len, uint32_t *samples)
-{
-  uint32_t nbout;
-  
-  *samples = _chunk; //FIXME
-  *len = 0;
-
-  if(!refillBuffer(_chunk ))
-  {
-    return 0; 
-  }
-        
-  if(tmptail-tmphead<_chunk)
-  {
-    return 0; 
-  }
-        // Do in place replace
-  dither16(&(tmpbuffer[tmphead]),_chunk,_wavheader->channels);
-  if(!revert)
-    memcpy(dest,&(tmpbuffer[tmphead]),_chunk*2);
-  else
-  {
-    uint16_t *in,*out,tmp;
-    in=(uint16_t*)&(tmpbuffer[tmphead]);
-    out=(uint16_t *)dest;
-    for(int i=0;i<_chunk;i++)
-    {
-      tmp=*in++;
-      tmp=((tmp&0xff)<<8)+(tmp>>8);
-      *out++=tmp;
-    }
-  }
-  tmphead+=_chunk;
-  *len=_chunk*2;
-  *samples=_chunk/_wavheader->channels;
-  return 1;
-}
-
-
-// EOF

Deleted: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/src/audioencoder_vorbis.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/src/audioencoder_vorbis.cpp	2008-07-16 17:40:50 UTC (rev 4233)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/src/audioencoder_vorbis.cpp	2008-07-16 17:40:55 UTC (rev 4234)
@@ -1,305 +0,0 @@
-/***************************************************************************
-    copyright            : (C) 2006 by mean
-    email                : fixounet at free.fr
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#include "config.h"
-#ifdef USE_VORBIS
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <math.h>
-
-#include "ADM_default.h"
-
-#include "audioencoder.h"
-//
-#include "audioencoder_vorbis_param.h"
-#include "audioencoder_vorbis.h"
-
-
-#include "vorbis/vorbisenc.h"
-#include "ADM_osSupport/ADM_debugID.h"
-#define MODULE_NAME MODULE_AUDIO_FILTER
-#include "ADM_osSupport/ADM_debug.h"
-
-
-#define OPTIONS (twolame_options_struct *)_twolameOptions
-
-#define VD (((vorbisStruct *)_handle)->vd)
-#define VI (((vorbisStruct *)_handle)->vi)
-#define VB (((vorbisStruct *)_handle)->vb)
-#define VC (((vorbisStruct *)_handle)->vc)
-typedef struct vorbisStruct
-{ 
-	vorbis_info 	 vi ;
-	vorbis_dsp_state vd ;
-	vorbis_block     vb ;
-	vorbis_comment   vc ;
-}vorbisStruct;
-//__________
-
-AUDMEncoder_Vorbis::AUDMEncoder_Vorbis(AUDMAudioFilter * instream)  :AUDMEncoder    (instream)
-{
-  printf("[Vorbis] Creating Vorbis\n");
-  _handle=NULL;
-  _wavheader->encoding=WAV_OGG;
-  _oldpos=0;
-  _handle=(void *)new  vorbisStruct; 
-  outputChannelMapping[0] = CH_FRONT_LEFT;
-  outputChannelMapping[1] = CH_FRONT_RIGHT;
-  outputChannelMapping[2] = CH_REAR_LEFT;
-  outputChannelMapping[3] = CH_REAR_RIGHT;
-  outputChannelMapping[4] = CH_FRONT_CENTER;
-  outputChannelMapping[5] = CH_LFE;
-};
-
-
-AUDMEncoder_Vorbis::~AUDMEncoder_Vorbis()
-{
-  printf("[Vorbis] Deleting Vorbis\n");
-  if(_handle)
-  {
-    vorbis_block_clear(&VB);
-    vorbis_dsp_clear(&VD);
-    vorbis_info_clear(&VI);
-    delete (vorbisStruct *)_handle;
-  }    	
-  _handle=NULL;
-  
-  cleanup();
-};
-
-//________________________________________________
-//   Init lame encoder
-// frequence    : Impose frequency , 0 means reuse the incoming fq
-// mode                         : ADM_STEREO etc...
-// bitrate              : Bitrate in kbps (96,192...)
-// return 0 : init failed
-//                              1 : init succeeded
-//_______________________________________________
-uint8_t AUDMEncoder_Vorbis::init(ADM_audioEncoderDescriptor *config)
-{
-  int ret;
-  VORBIS_encoderParam *vorbisConf=(VORBIS_encoderParam *)config->param;
-  ADM_assert(config->paramSize==sizeof(VORBIS_encoderParam));
-
-  ogg_packet header1,header2,header3;
-  int err;
-
-  
-  
-  vorbis_info_init(&VI) ;
-
-  switch(vorbisConf->mode)
-  {
-    
-    case ADM_VORBIS_VBR:
-                      err=vorbis_encode_init(&VI,
-                              _wavheader->channels,
-                              _wavheader->frequency,
-                              -1, // Max bitrate      
-                              config->bitrate*1000, //long nominal_bitrate,
-                              -1 //long min_bitrate))
-                            );
-                      break;
-    case  ADM_VORBIS_QUALITY :
-                    err=vorbis_encode_init_vbr(&VI,
-                                _wavheader->channels,
-                                _wavheader->frequency,
-                                vorbisConf->quality/10
-                              );
-                    break;
-      
-    default:
-      ADM_assert(0);
-  }
-  if (err!=0) 
-  {
-	  delete (vorbisStruct*)_handle;
-	  _handle = NULL;
-
-    printf("[vorbis] init error %d\n",err);
-    return 0;
-  }
-  vorbis_analysis_init(&VD, &VI) ;
-  vorbis_block_init(&VD, &VB);
-  vorbis_comment_init(&VC);
-  vorbis_comment_add_tag(&VC, "encoder", "AVIDEMUX2") ;
-
-  vorbis_analysis_headerout(&VD, &VC, &header1,
-                             &header2, &header3);
-
-
-// Store all headers as extra data
-// see ogg vorbis decode for details
-// we need 3 packets
-
-  _extraSize=header1.bytes+header2.bytes+header3.bytes+3*sizeof(uint32_t);
-  _extraData=new uint8_t[_extraSize];
-
-  uint32_t *ex=(uint32_t *)_extraData;
-  uint8_t *d;
-  d=_extraData+sizeof(uint32_t)*3;
-  ex[0]=header1.bytes;
-  ex[1]=header2.bytes;
-  ex[2]=header3.bytes;
-  memcpy(d,header1.packet,ex[0]);
-  d+=ex[0];
-  memcpy(d,header2.packet,ex[1]);
-  d+=ex[1];
-  memcpy(d,header3.packet,ex[2]);
-  vorbis_comment_clear(&VC);
-			
-  printf("\n[Vorbis]Vorbis encoder initialized\n");
-  switch(vorbisConf->mode)
-  {
-    case ADM_VORBIS_VBR:
-      printf("[Vorbis]CBR Bitrate:%lu\n",config->bitrate);
-      break;
-    case ADM_VORBIS_QUALITY: //FIXME FIXME FIXME
-      printf("[Vorbis]VBR Quality:%.1f\n",vorbisConf->quality);
-    break;
-    default:
-      ADM_assert(0);
-  }
-   
-  printf("[Vorbis]Channels  :%lu\n",_wavheader->channels);
-  printf("[Vorbis]Frequency :%lu\n",_wavheader->frequency);
-  return 1;
-}
-
-#define ROUNDMAX 3000
-
-uint8_t	AUDMEncoder_Vorbis::getPacket(uint8_t *dest, uint32_t *len, uint32_t *samples)
-{
-  uint32_t nbout;
-  uint32_t consumed=0;
-  float **float_samples;
-  ogg_packet op ;
-
-  *len = 0;
-  _chunk=1024*_wavheader->channels;
-  int count=ROUNDMAX;
-// Check that we have packet from previous pass
-  while(count--)
-  {
-    if(!refillBuffer(_chunk ))
-    {
-      return 0; 
-    }
-        
-    if(tmptail-tmphead<_chunk)
-    {
-      return 0; 
-    }
-    
-	//printf("Round %d\n",ROUNDMAX-count);
-    if(vorbis_analysis_blockout(&VD, &VB) == 1) 
-    {
-      vorbis_analysis(&VB, NULL);
-      vorbis_bitrate_addblock(&VB) ;
-	//printf("Blockout\n");
-	
-      if(vorbis_bitrate_flushpacket(&VD, &op)) 
-      {
-        memcpy(dest, op.packet,op.bytes);
-        *len=op.bytes;
-        *samples=op.granulepos-_oldpos;
-        _oldpos=op.granulepos;
-        //  aprintf("1st packet :sampl:%lu len :%lu sample:%lu abs:%llu\n",*samples,op.bytes,total,op.granulepos);
-        return 1;
-      }
-    }
-
-    
-    uint32_t nbSample=(tmptail-tmphead)/_wavheader->channels;
-    if(nbSample>1024) nbSample=1024;
-    float_samples=vorbis_analysis_buffer(&VD, nbSample) ;
-    int index=tmphead;
-    // Put our samples in incoming buffer
-    reorderChannels(&(tmpbuffer[tmphead]), nbSample,_incoming->getChannelMapping(),outputChannelMapping);
-    for (int i = 0; i < nbSample; i++)
-      for (int j = 0; j < _wavheader->channels; j++) {
-      float_samples[j][i] = tmpbuffer[index++];
-      if (float_samples[j][i] > 1) float_samples[j][i] = 1;
-      if (float_samples[j][i] < -1) float_samples[j][i] = -1;
-      }
-      // Buffer full, go go go
-      vorbis_analysis_wrote(&VD, nbSample) ;  
-      tmphead+=nbSample*_wavheader->channels;	
-  }
-  return 0;
-	
-}
-/**
-      \fn DIA_getLameSettings
-      \brief Dialog to set lame settings
-      @return 1 on success, 0 on failure
-
-*/
-#include "DIA_factory.h"
-int DIA_getVorbisSettings(ADM_audioEncoderDescriptor *descriptor)
-  {
-    int ret=0;
-    char string[400];
-    uint32_t mmode,ppreset;
-    ELEM_TYPE_FLOAT qqual;
-#define SZT(x) sizeof(x)/sizeof(diaMenuEntry )
-#define PX(x) &(lameParam->x)
-    
-    
-   VORBIS_encoderParam *vorbisParam;
-  ADM_assert(sizeof(VORBIS_encoderParam)==descriptor->paramSize);
-  vorbisParam=(VORBIS_encoderParam*)descriptor->param;
-  
-    mmode=vorbisParam->mode;
-    qqual=(ELEM_TYPE_FLOAT)vorbisParam->quality;
-    
-    diaMenuEntry channelMode[]={
-                             {ADM_VORBIS_VBR,      QT_TR_NOOP("VBR"),NULL},
-                             {ADM_VORBIS_QUALITY,   QT_TR_NOOP("Quality based"),NULL}};
-          
-    diaElemMenu menuMode(&mmode,   QT_TR_NOOP("_Mode:"), SZT(channelMode),channelMode);
-    
-#define BITRATE(x) {x,QT_TR_NOOP(#x)}
-    diaMenuEntry bitrateM[]={
-                              BITRATE(56),
-                              BITRATE(64),
-                              BITRATE(80),
-                              BITRATE(96),
-                              BITRATE(112),
-                              BITRATE(128),
-                              BITRATE(160),
-                              BITRATE(192),
-                              BITRATE(224)
-                          };
-    diaElemMenu bitrate(&(descriptor->bitrate),   QT_TR_NOOP("_Bitrate:"), SZT(bitrateM),bitrateM);
-    
-    diaElemFloat quality(&qqual,QT_TR_NOOP("_Quality:"),-1.,10.);
-    
-    
-    
-  
-      diaElem *elems[]={&menuMode,&bitrate,&quality};
-    
-  if( diaFactoryRun(QT_TR_NOOP("Vorbis Configuration"),3,elems))
-  {
-    vorbisParam->mode=(ADM_VORBIS_MODE)mmode;
-    vorbisParam->quality=(float)qqual;
-    
-    return 1;
-  }
-  return 0;
-}  
-
-#endif		
-// EOF

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/CMakeLists.txt	2008-07-16 17:40:50 UTC (rev 4233)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/CMakeLists.txt	2008-07-16 17:40:55 UTC (rev 4234)
@@ -1,17 +1,29 @@
-#######################################
-include (admCheckAudioEncoderLibs)
-include (admConfigSummary)
-MESSAGE("***  Audio Codec  ***")
-ADM_DISPLAY("Aften     " "${USE_AFTEN}")
-ADM_DISPLAY("LAME      " "${USE_LAME}")
-ADM_DISPLAY("FAAC      " "${USE_FAAC}")
-ADM_DISPLAY("Vorbis    " "${USE_VORBIS}")
-MESSAGE("***  /Audio Codec  ***")
-
-
+#######################################
+include (admCheckAudioEncoderLibs)
+include (admConfigSummary)
+MESSAGE("***  Audio Codec  ***")
+ADM_DISPLAY("Aften     " "${USE_AFTEN}")
+ADM_DISPLAY("LAME      " "${USE_LAME}")
+ADM_DISPLAY("FAAC      " "${USE_FAAC}")
+ADM_DISPLAY("Vorbis    " "${USE_VORBIS}")
+MESSAGE("***  /Audio Codec  ***")
+
+
 ADD_SUBDIRECTORY(twolame)
-
-if(USE_LAME)
-ADD_SUBDIRECTORY(lame)
-endif(USE_LAME)
-
+ADD_SUBDIRECTORY(pcm)
+
+if(USE_LAME)
+ADD_SUBDIRECTORY(lame)
+endif(USE_LAME)
+
+if(USE_AFTEN)
+# not tested ADD_SUBDIRECTORY(aften)
+endif(USE_AFTEN)
+
+if(USE_VORBIS)
+ADD_SUBDIRECTORY(vorbis)
+endif(USE_VORBIS)
+
+if(USE_FAAC)
+#ADD_SUBDIRECTORY(faac)
+endif(USE_FAAC)

Added: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/aften/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/aften/CMakeLists.txt	2008-07-16 17:40:50 UTC (rev 4233)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/aften/CMakeLists.txt	2008-07-16 17:40:55 UTC (rev 4234)
@@ -0,0 +1,12 @@
+	INCLUDE(ae_plugin)
+
+	SET(ADM_ae_aften_SRCS audioencoder_aften.cpp)
+
+	ADD_LIBRARY(ADM_ae_aften SHARED ${ADM_ae_aften_SRCS})
+
+	TARGET_LINK_LIBRARIES(ADM_ae_aften ${AFTEN_LIBRARY_DIR})
+
+	ADD_TARGET_CFLAGS(ADM_ae_aften "-I${AFTEN_INCLUDE_DIR}")
+
+	INIT_AUDIO_ENCODER(ADM_ae_aften)
+	INSTALL_AUDIOENCODER(ADM_ae_aften)

Copied: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/aften/audioencoder_aften.cpp (from rev 4233, branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/src/audioencoder_aften.cpp)
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/src/audioencoder_aften.cpp	2008-07-16 17:40:50 UTC (rev 4233)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/aften/audioencoder_aften.cpp	2008-07-16 17:40:55 UTC (rev 4234)
@@ -0,0 +1,166 @@
+
+/***************************************************************************
+    copyright            : (C) 2002-6 by mean
+    email                : fixounet at free.fr
+
+    Interface to Aften
+
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include "config.h"
+#ifdef USE_AFTEN
+#include "config.h"
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <math.h>
+
+
+#include "ADM_default.h"
+
+#include "audioprocess.hxx"
+#include "audioeng_process.h"
+#include "audioencoder.h"
+//
+extern "C"
+{
+#if defined(USE_AFTEN_06)
+	#include "aften.h"
+#else	// Aften 0.05 & 0.07 onwards
+	#include "aften/aften.h"
+#endif
+};
+#include "audioencoder_aften_param.h"
+#include "audioencoder_aften.h"
+
+#define _HANDLE ((AftenContext *)_handle)
+AUDMEncoder_Aften::AUDMEncoder_Aften(AUDMAudioFilter * instream)  :AUDMEncoder    (instream)
+{
+  uint32_t channels;
+  channels=instream->getInfo()->channels;
+  _handle=(void *)new AftenContext;
+  memset(_handle,0,sizeof(AftenContext));
+  aften_set_defaults(_HANDLE);
+  _wavheader->encoding=WAV_AC3;
+#if defined(USE_AFTEN_05) || defined(USE_AFTEN_06)
+#elif defined(USE_AFTEN_07)
+  _HANDLE->params.n_threads=1; // MThread collides with avidemux multithreading
+#else
+  _HANDLE->system.n_threads=1;
+#endif
+};
+
+
+AUDMEncoder_Aften::~AUDMEncoder_Aften()
+{
+    if(_handle)
+      aften_encode_close(_HANDLE);
+    delete(_HANDLE);
+    _handle=NULL;
+
+    printf("[Aften] Deleting aften\n");
+    cleanup();
+};
+
+
+//________________________________________________
+//   Init lame encoder
+// frequence    : Impose frequency , 0 means reuse the incoming fq
+// mode                         : ADM_STEREO etc...
+// bitrate              : Bitrate in kbps (96,192...)
+// return 0 : init failed
+//                              1 : init succeeded
+//_______________________________________________
+uint8_t AUDMEncoder_Aften::init(ADM_audioEncoderDescriptor *config)
+{
+
+
+int ret=0;
+
+#if defined(USE_AFTEN_05) || defined(USE_AFTEN_06)
+int mask;
+#else
+unsigned int mask;
+#endif
+
+    _wavheader->byterate=(config->bitrate*1000)/8;
+    _HANDLE->sample_format=A52_SAMPLE_FMT_FLT;
+    _HANDLE->channels=_wavheader->channels;
+    _HANDLE->samplerate=_wavheader->frequency;
+    
+    _HANDLE->params.bitrate=config->bitrate;
+    switch(_wavheader->channels)
+    {
+        case 1: mask = 0x04;  break;
+        case 2: mask = 0x03;  break;
+        case 3: mask = 0x07;  break;
+        case 4: mask = 0x107; break;
+        case 5: mask = 0x37;  break;
+        case 6: mask = 0x3F;  break;
+      }
+
+#if defined(USE_AFTEN_05) || defined(USE_AFTEN_06)
+	aften_wav_chmask_to_acmod(_wavheader->channels, mask, &(_HANDLE->acmod), &(_HANDLE->lfe));
+#else
+	aften_wav_channels_to_acmod(_wavheader->channels, mask, &(_HANDLE->acmod), &(_HANDLE->lfe));
+#endif
+
+   //   _HANDLE->params.verbose=2;
+    int er= aften_encode_init(_HANDLE);
+    if(er<0)
+    {
+      printf("[Aften] init error %d\n",er); 
+      return 0;
+    }
+    _chunk=256*6*_wavheader->channels;
+    printf("[Aften] Initialized with fd %u Channels %u bitrate %u\n",_HANDLE->samplerate,
+                                                                    _HANDLE->channels,_HANDLE->params.bitrate);
+    return 1;
+}
+
+
+//______________________________________________
+uint8_t	AUDMEncoder_Aften::getPacket(uint8_t *dest, uint32_t *len, uint32_t *samples)
+{
+  uint32_t count=0;
+  int r;
+  void *ptr;
+_again:
+        *len = 0;
+        _chunk=256*6*_wavheader->channels;
+        if(!refillBuffer(_chunk ))
+        {
+          return 0; 
+        }
+        ptr=(void *)&(tmpbuffer[tmphead]);
+        ADM_assert(tmptail>=tmphead);
+
+#ifdef USE_AFTEN_05
+		aften_remap_wav_to_a52(ptr, 256*6, _wavheader->channels, A52_SAMPLE_FMT_FLT, _HANDLE->acmod, _HANDLE->lfe);
+#else
+		aften_remap_wav_to_a52(ptr, 256*6, _wavheader->channels, A52_SAMPLE_FMT_FLT, _HANDLE->acmod);
+#endif
+
+        r=aften_encode_frame(_HANDLE, dest,(void *)ptr);
+        if(r<0)
+        {
+          printf("[Aften] Encoding error %d\n",r);
+          return 0; 
+        }
+        
+        *samples=256*6;
+        *len=r;
+        tmphead+=_chunk;
+        return 1;
+}
+
+#endif		
+// EOF

Copied: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/aften/audioencoder_aften.h (from rev 4233, branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/include/audioencoder_aften.h)
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/include/audioencoder_aften.h	2008-07-16 17:40:50 UTC (rev 4233)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/aften/audioencoder_aften.h	2008-07-16 17:40:55 UTC (rev 4234)
@@ -0,0 +1,31 @@
+
+/***************************************************************************
+    copyright            : (C) 2002-6 by mean
+    email                : fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#ifndef AUDMaudioAften
+#define AUDMaudioAften
+#ifdef USE_AFTEN
+ //_____________________________________________
+class AUDMEncoder_Aften : public AUDMEncoder
+{
+protected:
+         void           *_handle;
+         
+public:
+                        uint8_t init(ADM_audioEncoderDescriptor *config);
+                virtual ~AUDMEncoder_Aften();
+                        AUDMEncoder_Aften(AUDMAudioFilter *instream);	
+                virtual uint8_t	getPacket(uint8_t *dest, uint32_t *len, uint32_t *samples);
+};
+#endif
+#endif

Copied: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/aften/audioencoder_aften_param.h (from rev 4233, branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/include/audioencoder_aften_param.h)
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/include/audioencoder_aften_param.h	2008-07-16 17:40:50 UTC (rev 4233)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/aften/audioencoder_aften_param.h	2008-07-16 17:40:55 UTC (rev 4234)
@@ -0,0 +1,10 @@
+#ifndef AUDM_AFTEN_PARAM_H
+#define AUDM_AFTEN_PARAM_H
+#ifdef USE_AFTEN
+
+typedef struct AFTEN_encoderParam
+{
+  ADM_mode        mode;
+};
+#endif
+#endif

Added: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/faac/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/faac/CMakeLists.txt	2008-07-16 17:40:50 UTC (rev 4233)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/faac/CMakeLists.txt	2008-07-16 17:40:55 UTC (rev 4234)
@@ -0,0 +1,12 @@
+	INCLUDE(ae_plugin)
+
+	SET(ADM_ae_faac_SRCS audioencoder_faac.cpp)
+
+	ADD_LIBRARY(ADM_ae_faac SHARED ${ADM_ae_faac_SRCS})
+
+	TARGET_LINK_LIBRARIES(ADM_ae_faac ${FAAC_LIBRARY_DIR})
+
+	ADD_TARGET_CFLAGS(ADM_ae_faac "-I${FAAC_INCLUDE_DIR}")
+
+	INIT_AUDIO_ENCODER(ADM_ae_faac)
+	INSTALL_AUDIOENCODER(ADM_ae_faac)

Copied: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/faac/audioencoder_faac.cpp (from rev 4233, branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/src/audioencoder_faac.cpp)
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/src/audioencoder_faac.cpp	2008-07-16 17:40:50 UTC (rev 4233)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/faac/audioencoder_faac.cpp	2008-07-16 17:40:55 UTC (rev 4234)
@@ -0,0 +1,215 @@
+
+/***************************************************************************
+    copyright            : (C) 2002-6 by mean
+    email                : fixounet at free.fr
+
+    Interface to FAAC
+
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include <math.h>
+
+#include "ADM_default.h"
+
+#include "audioencoder.h"
+//
+
+#include "faac.h"
+#include "audioencoder_faac.h"
+
+AUDMEncoder_Faac::AUDMEncoder_Faac(AUDMAudioFilter * instream)  :AUDMEncoder    (instream)
+{
+  uint32_t channels;
+  channels=instream->getInfo()->channels;
+  switch(channels)
+  {
+    case 1:outputChannelMapping[1] = CH_FRONT_LEFT;break;
+    case 2:
+    	outputChannelMapping[0] = CH_FRONT_LEFT;
+    	outputChannelMapping[1] = CH_FRONT_RIGHT;
+      break;
+    default :
+    	outputChannelMapping[0] = CH_FRONT_CENTER;
+    	outputChannelMapping[1] = CH_FRONT_LEFT;
+    	outputChannelMapping[2] = CH_FRONT_RIGHT;
+    	outputChannelMapping[3] = CH_REAR_LEFT;
+    	outputChannelMapping[4] = CH_REAR_RIGHT;
+    	outputChannelMapping[5] = CH_LFE;
+  }
+};
+
+
+AUDMEncoder_Faac::~AUDMEncoder_Faac()
+{
+    if(_handle)
+        faacEncClose(_handle);
+    _handle=NULL;
+
+    printf("[FAAC] Deleting faac\n");
+    cleanup();
+};
+
+
+//________________________________________________
+//   Init lame encoder
+// frequence    : Impose frequency , 0 means reuse the incoming fq
+// mode                         : ADM_STEREO etc...
+// bitrate              : Bitrate in kbps (96,192...)
+// return 0 : init failed
+//                              1 : init succeeded
+//_______________________________________________
+#if 0
+uint8_t AUDMEncoder_Faac::init(ADM_audioEncoderDescriptor *config)
+{
+unsigned long int samples_input, max_bytes_output;
+faacEncConfigurationPtr cfg;
+int ret=0;
+
+    printf("[FAAC] Incoming Fq :%u\n",_wavheader->frequency);
+     _handle = faacEncOpen(_wavheader->frequency,
+                                 _wavheader->channels,
+                                 &samples_input,
+                                &max_bytes_output);
+    if(!_handle)
+    {
+          printf("Cannot open faac with fq=%lu chan=%lu br=%lu\n",
+          _wavheader->frequency,_wavheader->channels,config->bitrate);
+          return 0;
+    }
+    printf(" [FAAC] : Sample input:%d, max byte output%d \n",samples_input,max_bytes_output);
+    cfg= faacEncGetCurrentConfiguration(_handle);
+    
+    // Set default conf, same as ffmpeg
+    cfg->aacObjectType = LOW;
+    cfg->mpegVersion = MPEG4;
+    cfg->bandWidth= (_wavheader->frequency*3)/4; // Should be relevant
+    cfg->useTns = 0;
+    cfg->allowMidside = 0;
+    cfg->bitRate = (config->bitrate*1000)/_wavheader->channels; // It is per channel
+    cfg->outputFormat = 0; // 0 Raw 1 ADTS
+    cfg->inputFormat = FAAC_INPUT_FLOAT;
+    cfg->useLfe=0;	
+    if (!(ret=faacEncSetConfiguration(_handle, cfg))) 
+    {
+        printf("[FAAC] Cannot set conf for faac with fq=%lu chan=%lu br=%lu (err:%d)\n",
+				_wavheader->frequency,_wavheader->channels,config->bitrate,ret);
+	return 0;
+    }
+     unsigned char *data=NULL;
+     unsigned long size=0;
+     if((ret=faacEncGetDecoderSpecificInfo(_handle, &data,&size)))
+     {
+        printf("FAAC: GetDecoderSpecific info failed (err:%d)\n",ret);
+        return 0;
+     }
+     _extraSize=size;
+     _extraData=new uint8_t[size];
+     memcpy(_extraData,data,size);
+
+    // update
+     _wavheader->byterate=(config->bitrate*1000)/8;
+//    _wavheader->dwScale=1024;
+//    _wavheader->dwSampleSize=0;
+    _wavheader->blockalign=4096;
+    _wavheader->bitspersample=0;
+
+    _chunk=samples_input;
+
+
+    printf("[Faac] Initialized :\n");
+    
+    printf("[Faac]Version        : %s\n",cfg->name);
+    printf("[Faac]Bitrate        : %lu\n",cfg->bitRate);
+    printf("[Faac]Mpeg2 (1)/4(0) : %u\n",cfg->mpegVersion);
+    printf("[Faac]Use lfe      ) : %u\n",cfg->useLfe);
+    printf("[Faac]Sample output  : %lu\n",_chunk / _wavheader->channels);
+    printf("[Faac]Bitrate        : %lu\n",cfg->bitRate*_wavheader->channels);
+
+    
+    return 1;
+}
+#endif
+//_____________________________________________
+//  Need to multiply the float by 32767, can't use
+//  generic fill buffer
+//----------------------------------------------
+uint8_t AUDMEncoder_Faac::refillBuffer(int minimum)
+{
+  uint32_t filler=_wavheader->frequency*_wavheader->channels;
+  uint32_t nb;
+  AUD_Status status;
+  if(eof_met) return 0;
+  while(1)
+  {
+    ADM_assert(tmptail>=tmphead);
+    if((tmptail-tmphead)>=minimum) return 1;
+  
+    if(tmphead && tmptail>filler/2)
+    {
+      memmove(&tmpbuffer[0],&tmpbuffer[tmphead],(tmptail-tmphead)*sizeof(float)); 
+      tmptail-=tmphead;
+      tmphead=0;
+    }
+    ADM_assert(filler>tmptail);
+    nb=_incoming->fill( (filler-tmptail)/2,&tmpbuffer[tmptail],&status);
+    if(!nb)
+    {
+      if(status!=AUD_END_OF_STREAM) ADM_assert(0);
+      
+      if((tmptail-tmphead)<minimum)
+      {
+        memset(&tmpbuffer[tmptail],0,sizeof(float)*(minimum-(tmptail-tmphead)));
+        tmptail=tmphead+minimum;
+        eof_met=1;  
+        return minimum;
+      }
+      else continue;
+    } else
+    {
+      float *s=&(tmpbuffer[tmptail]);
+      for(int i=0;i<nb;i++)
+      {
+        *s=*s*32767.;
+        s++;
+      }
+      tmptail+=nb;
+    }
+  }
+}
+
+#define FA_BUFFER_SIZE (SIZE_INTERNAL/4)
+//______________________________________________
+uint8_t	AUDMEncoder_Faac::getPacket(uint8_t *dest, uint32_t *len, uint32_t *samples)
+{
+  uint32_t count=0;
+_again:
+        *samples = _chunk/_wavheader->channels;
+        *len = 0;
+
+        if(!refillBuffer(_chunk ))
+        {
+          return 0; 
+        }
+        ADM_assert(tmptail>=tmphead);
+        reorderChannels(&(tmpbuffer[tmphead]),*samples,_incoming->getChannelMapping(),outputChannelMapping);
+        *len = faacEncEncode(_handle, (int32_t *)&(tmpbuffer[tmphead]), _chunk, dest, FA_BUFFER_SIZE);
+        if(!*len) 
+        {
+          count++;
+          if(count<20)
+            goto _again;
+          *samples=0;
+        }
+        tmphead+=_chunk;
+        return 1;
+}
+#endif		
+// EOF

Copied: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/faac/audioencoder_faac.h (from rev 4233, branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/include/audioencoder_faac.h)
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/include/audioencoder_faac.h	2008-07-16 17:40:50 UTC (rev 4233)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/faac/audioencoder_faac.h	2008-07-16 17:40:55 UTC (rev 4234)
@@ -0,0 +1,31 @@
+
+/***************************************************************************
+    copyright            : (C) 2002-6 by mean
+    email                : fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#ifndef AUDMaudioAAC
+#define AUDMaudioAAC
+
+ //_____________________________________________
+class AUDMEncoder_Faac : public AUDMEncoder
+{
+protected:
+         void           *_handle;
+         uint8_t        refillBuffer(int minimum);
+public:
+//                        uint8_t init(ADM_audioEncoderDescriptor *config);
+                virtual ~AUDMEncoder_Faac();
+                        AUDMEncoder_Faac(AUDMAudioFilter *instream);	
+                virtual uint8_t	getPacket(uint8_t *dest, uint32_t *len, uint32_t *samples);
+};
+
+#endif

Copied: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/faac/audioencoder_faac_param.h (from rev 4233, branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/include/audioencoder_faac_param.h)
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/include/audioencoder_faac_param.h	2008-07-16 17:40:50 UTC (rev 4233)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/faac/audioencoder_faac_param.h	2008-07-16 17:40:55 UTC (rev 4234)
@@ -0,0 +1,8 @@
+
+#ifndef FAAC_PARAM_H
+#define FAAC_PARAM_H
+typedef struct 
+{
+  uint32_t dummy;
+}FAAC_encoderParam;
+#endif

Copied: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/lavcodec/audioencoder_lavcodec.cpp (from rev 4233, branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/src/audioencoder_lavcodec.cpp)
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/src/audioencoder_lavcodec.cpp	2008-07-16 17:40:50 UTC (rev 4233)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/lavcodec/audioencoder_lavcodec.cpp	2008-07-16 17:40:55 UTC (rev 4234)
@@ -0,0 +1,147 @@
+/***************************************************************************
+                        
+    copyright            : (C) 2002-2006 by mean
+    email                : fixounet at free.fr
+    
+    Interface to FFmpeg mpeg1/2 audio encoder
+    
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <math.h>
+
+#include "ADM_default.h"
+
+#include "audioencoder.h"
+//
+#include "audioencoder_lavcodec.h"
+
+#include "ADM_lavcodec.h"
+
+#include "ADM_osSupport/ADM_debugID.h"
+#define MODULE_NAME MODULE_AUDIO_FILTER
+#include "ADM_osSupport/ADM_debug.h"
+
+
+#define CONTEXT ((AVCodecContext  	*)_context)
+
+
+// Ctor: Duplicate
+//__________
+
+AUDMEncoder_Lavcodec::AUDMEncoder_Lavcodec(uint32_t fourcc,AUDMAudioFilter * instream)  :AUDMEncoder    (instream)
+{
+  _fourcc=fourcc;
+  if(_fourcc!=WAV_MP2 && _fourcc!=WAV_AC3) ADM_assert(0);
+  _context=NULL;
+  _wavheader->encoding=_fourcc;
+  printf("[Lavcodec] Creating Lavcodec\n");
+};
+
+
+AUDMEncoder_Lavcodec::~AUDMEncoder_Lavcodec()
+{
+  printf("[Lavcodec] Deleting Lavcodec\n");
+  if(_context)
+  {
+    avcodec_close(CONTEXT);
+    ADM_dealloc(_context);
+  }
+  _context=NULL;
+  cleanup();
+};
+
+//________________________________________________
+//   Init lame encoder
+//_______________________________________________
+uint8_t AUDMEncoder_Lavcodec::init(ADM_audioEncoderDescriptor *config)
+{
+  int ret;
+  _context=( void *)avcodec_alloc_context();
+  _wavheader->byterate=(config->bitrate*1000)>>3;
+
+      
+  if(_fourcc==WAV_MP2 && _incoming->getInfo()->channels>2)
+  {
+    printf("[Lavcodec]Too many channels\n");
+    return 0; 
+  }
+  _wavheader->byterate=(config->bitrate*1000)>>3;         
+      
+  if(_fourcc==WAV_MP2)
+    _chunk = 1152*_wavheader->channels;
+  else
+    _chunk = 1536*_wavheader->channels; // AC3
+
+  printf("[Lavcodec]Incoming : fq : %lu, channel : %lu bitrate: %lu \n",
+         _wavheader->frequency,_wavheader->channels,config->bitrate);
+  
+  
+  CONTEXT->channels     =  _wavheader->channels;
+  CONTEXT->sample_rate  =  _wavheader->frequency;
+  CONTEXT->bit_rate     = (config->bitrate*1000); // bits -> kbits
+
+  AVCodec *codec;
+  CodecID codecID;
+  
+  if(_fourcc==WAV_MP2) codecID=CODEC_ID_MP2;
+        else codecID=CODEC_ID_AC3;
+  codec = avcodec_find_encoder(codecID);
+  ADM_assert(codec);
+  
+  ret = avcodec_open(CONTEXT, codec);
+  if (0> ret) 
+  {
+    printf("[Lavcodec] init failed err : %d!\n",ret);
+    return 0;
+  }
+
+
+  printf("[Lavcodec]Lavcodec successfully initialized\n");
+  return 1;       
+}
+//*********************************
+uint8_t	AUDMEncoder_Lavcodec::getPacket(uint8_t *dest, uint32_t *len, uint32_t *samples)
+{
+  uint32_t nbout;
+  
+  *samples = _chunk/_wavheader->channels; //FIXME
+  *len = 0;
+
+  if(!refillBuffer(_chunk ))
+  {
+    return 0; 
+  }
+        
+  if(tmptail-tmphead<_chunk)
+  {
+    return 0; 
+  }
+
+  dither16(&(tmpbuffer[tmphead]),_chunk,_wavheader->channels);
+
+  ADM_assert(tmptail>=tmphead);
+  nbout = avcodec_encode_audio(CONTEXT, dest, 5000, (short *) &(tmpbuffer[tmphead]));
+
+  tmphead+=_chunk;
+  if (nbout < 0) 
+  {
+    printf("[Lavcodec] Error !!! : %ld\n", nbout);
+    return 0;
+  }
+  *len=nbout;
+  return 1;
+}
+
+// EOF

Copied: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/lavcodec/audioencoder_lavcodec.h (from rev 4233, branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/include/audioencoder_lavcodec.h)
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/include/audioencoder_lavcodec.h	2008-07-16 17:40:50 UTC (rev 4233)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/lavcodec/audioencoder_lavcodec.h	2008-07-16 17:40:55 UTC (rev 4234)
@@ -0,0 +1,32 @@
+
+/***************************************************************************
+    copyright            : (C) 2002-6 by mean
+    email                : fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#ifndef AUDMaudioLavcodec
+#define AUDMaudioLavcodec
+ //_____________________________________________
+class AUDMEncoder_Lavcodec : public AUDMEncoder
+{
+  protected:
+   
+    void              *_context;
+    uint32_t          _fourcc;
+         
+  public:
+//            uint8_t     init(ADM_audioEncoderDescriptor *config);
+   virtual             ~AUDMEncoder_Lavcodec();
+                        AUDMEncoder_Lavcodec(uint32_t fourcc,AUDMAudioFilter *instream);	
+   virtual uint8_t	getPacket(uint8_t *dest, uint32_t *len, uint32_t *samples);
+};
+
+#endif

Added: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/pcm/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/pcm/CMakeLists.txt	2008-07-16 17:40:50 UTC (rev 4233)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/pcm/CMakeLists.txt	2008-07-16 17:40:55 UTC (rev 4234)
@@ -0,0 +1,9 @@
+	INCLUDE(ae_plugin)
+
+	SET(ADM_ae_pcm_SRCS audioencoder_pcm.cpp)
+
+	ADD_LIBRARY(ADM_ae_pcm SHARED ${ADM_ae_pcm_SRCS})
+
+
+	INIT_AUDIO_ENCODER(ADM_ae_pcm)
+	INSTALL_AUDIOENCODER(ADM_ae_pcm)

Copied: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/pcm/audioencoder_pcm.cpp (from rev 4233, branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/src/audioencoder_pcm.cpp)
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/src/audioencoder_pcm.cpp	2008-07-16 17:40:50 UTC (rev 4233)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/pcm/audioencoder_pcm.cpp	2008-07-16 17:40:55 UTC (rev 4234)
@@ -0,0 +1,138 @@
+/***************************************************************************
+    copyright            : (C) 2006 by mean
+    email                : fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <math.h>
+
+#include "ADM_default.h"
+
+#include "audioencoder.h"
+#include "audioencoderInternal.h"
+#include "audioencoder_pcm.h"
+
+
+
+
+/********************* Declare Plugin *****************************************************/
+ADM_DECLARE_AUDIO_ENCODER_PREAMBLE(AUDMEncoder_PCM);
+
+static ADM_audioEncoder encoderDesc = { 
+  ADM_AUDIO_ENCODER_API_VERSION,
+  create,			// Defined by macro automatically
+  destroy,			// Defined by macro automatically
+  NULL,		//** put your own function here**
+  "PCM",            
+  "PCM",      
+  "PCM encoder plugin Mean 2008",             
+  6,                    // Max channels
+  1,0,0,                // Version
+  WAV_PCM,
+  200,                  // Priority
+  NULL,  // Defined by macro automatically
+  NULL,  // Defined by macro automatically
+
+  NULL,           // Defined by macro automatically
+  NULL,            // Defined by macro automatically 
+
+  NULL,         //** put your own function here**
+
+  NULL
+};
+//ADM_DECLARE_AUDIO_ENCODER_CONFIG(NULL);
+extern "C" ADM_audioEncoder *getInfo (void) 
+{ 
+  return &encoderDesc; 
+}  
+
+/******************* / Declare plugin*******************************************************/
+
+
+
+// Ctor: Duplicate
+//__________
+
+AUDMEncoder_PCM::AUDMEncoder_PCM(AUDMAudioFilter * instream)  :AUDMEncoder    (instream)
+{
+  printf("[PCM] Creating PCM\n");
+  _wavheader->encoding=WAV_PCM;
+  
+};
+
+
+AUDMEncoder_PCM::~AUDMEncoder_PCM()
+{
+  printf("[PCM] Deleting PCM\n");
+  cleanup();
+};
+
+/**
+    \fn initialize
+*/
+uint8_t AUDMEncoder_PCM::initialize(void)
+{
+  
+  _wavheader->byterate=_wavheader->channels*_wavheader->frequency*2;
+  _chunk = (_wavheader->frequency/100)*_wavheader->channels*2;
+  
+
+ 
+  printf("[PCM]Incoming :fq : %lu, channel : %lu \n",_wavheader->frequency,_wavheader->channels);
+  printf("[PCM]PCM successfully initialized\n");
+  return 1;       
+}
+/**
+    \fn getPacket
+*/
+
+uint8_t	AUDMEncoder_PCM::getPacket(uint8_t *dest, uint32_t *len, uint32_t *samples)
+{
+  uint32_t nbout;
+  
+  *samples = _chunk; //FIXME
+  *len = 0;
+
+  if(!refillBuffer(_chunk ))
+  {
+    return 0; 
+  }
+        
+  if(tmptail-tmphead<_chunk)
+  {
+    return 0; 
+  }
+        // Do in place replace
+  dither16(&(tmpbuffer[tmphead]),_chunk,_wavheader->channels);
+  if(1) //!revert)
+    memcpy(dest,&(tmpbuffer[tmphead]),_chunk*2);
+  else
+  {
+    uint16_t *in,*out,tmp;
+    in=(uint16_t*)&(tmpbuffer[tmphead]);
+    out=(uint16_t *)dest;
+    for(int i=0;i<_chunk;i++)
+    {
+      tmp=*in++;
+      tmp=((tmp&0xff)<<8)+(tmp>>8);
+      *out++=tmp;
+    }
+  }
+  tmphead+=_chunk;
+  *len=_chunk*2;
+  *samples=_chunk/_wavheader->channels;
+  return 1;
+}
+
+// EOF

Copied: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/pcm/audioencoder_pcm.h (from rev 4233, branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/include/audioencoder_pcm.h)
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/include/audioencoder_pcm.h	2008-07-16 17:40:50 UTC (rev 4233)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/pcm/audioencoder_pcm.h	2008-07-16 17:40:55 UTC (rev 4234)
@@ -0,0 +1,36 @@
+/***************************************************************************
+    copyright            : (C) 2002-6 by mean
+    email                : fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#ifndef AUDMaudioPCM
+#define AUDMaudioPCM
+
+/*!
+    This class is the float->PCM encoder.
+    It is somehow special as it can alsa be a LPCM encoder and a bigendian/littleendian swapper
+*/
+class AUDMEncoder_PCM : public AUDMEncoder
+{
+  protected:
+    uint32_t            revert;
+         
+  public:
+            uint8_t     initialize(void);
+            virtual     ~AUDMEncoder_PCM();
+                        /*! \param reverted : Should the endianness be reverted compared to system  
+                            \param fourCC   : FourCC to use (WAV_PCM/WAV_LPCM)
+                        */
+                         AUDMEncoder_PCM(AUDMAudioFilter * instream);
+    virtual uint8_t	     getPacket(uint8_t *dest, uint32_t *len, uint32_t *samples);
+};
+
+#endif

Added: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/twolame/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/twolame/CMakeLists.txt	2008-07-16 17:40:50 UTC (rev 4233)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/twolame/CMakeLists.txt	2008-07-16 17:40:55 UTC (rev 4234)
@@ -0,0 +1,13 @@
+	INCLUDE(ae_plugin)
+        subdirs(PREORDER ADM_libtwolame)
+
+	SET(ADM_ae_twolame_SRCS audioencoder_twolame.cpp)
+
+	ADD_LIBRARY(ADM_ae_twolame SHARED ${ADM_ae_twolame_SRCS})
+
+	TARGET_LINK_LIBRARIES(ADM_ae_twolame ADM_libtwolame)
+        include_directories(ADM_libtwolame)
+
+
+	INIT_AUDIO_ENCODER(ADM_ae_twolame)
+	INSTALL_AUDIOENCODER(ADM_ae_twolame)

Copied: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/vorbis/audioencoder_vorbis.cpp (from rev 4233, branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/src/audioencoder_vorbis.cpp)
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/src/audioencoder_vorbis.cpp	2008-07-16 17:40:50 UTC (rev 4233)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/vorbis/audioencoder_vorbis.cpp	2008-07-16 17:40:55 UTC (rev 4234)
@@ -0,0 +1,305 @@
+/***************************************************************************
+    copyright            : (C) 2006 by mean
+    email                : fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include "config.h"
+#ifdef USE_VORBIS
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <math.h>
+
+#include "ADM_default.h"
+
+#include "audioencoder.h"
+//
+#include "audioencoder_vorbis_param.h"
+#include "audioencoder_vorbis.h"
+
+
+#include "vorbis/vorbisenc.h"
+#include "ADM_osSupport/ADM_debugID.h"
+#define MODULE_NAME MODULE_AUDIO_FILTER
+#include "ADM_osSupport/ADM_debug.h"
+
+
+#define OPTIONS (twolame_options_struct *)_twolameOptions
+
+#define VD (((vorbisStruct *)_handle)->vd)
+#define VI (((vorbisStruct *)_handle)->vi)
+#define VB (((vorbisStruct *)_handle)->vb)
+#define VC (((vorbisStruct *)_handle)->vc)
+typedef struct vorbisStruct
+{ 
+	vorbis_info 	 vi ;
+	vorbis_dsp_state vd ;
+	vorbis_block     vb ;
+	vorbis_comment   vc ;
+}vorbisStruct;
+//__________
+
+AUDMEncoder_Vorbis::AUDMEncoder_Vorbis(AUDMAudioFilter * instream)  :AUDMEncoder    (instream)
+{
+  printf("[Vorbis] Creating Vorbis\n");
+  _handle=NULL;
+  _wavheader->encoding=WAV_OGG;
+  _oldpos=0;
+  _handle=(void *)new  vorbisStruct; 
+  outputChannelMapping[0] = CH_FRONT_LEFT;
+  outputChannelMapping[1] = CH_FRONT_RIGHT;
+  outputChannelMapping[2] = CH_REAR_LEFT;
+  outputChannelMapping[3] = CH_REAR_RIGHT;
+  outputChannelMapping[4] = CH_FRONT_CENTER;
+  outputChannelMapping[5] = CH_LFE;
+};
+
+
+AUDMEncoder_Vorbis::~AUDMEncoder_Vorbis()
+{
+  printf("[Vorbis] Deleting Vorbis\n");
+  if(_handle)
+  {
+    vorbis_block_clear(&VB);
+    vorbis_dsp_clear(&VD);
+    vorbis_info_clear(&VI);
+    delete (vorbisStruct *)_handle;
+  }    	
+  _handle=NULL;
+  
+  cleanup();
+};
+
+//________________________________________________
+//   Init lame encoder
+// frequence    : Impose frequency , 0 means reuse the incoming fq
+// mode                         : ADM_STEREO etc...
+// bitrate              : Bitrate in kbps (96,192...)
+// return 0 : init failed
+//                              1 : init succeeded
+//_______________________________________________
+uint8_t AUDMEncoder_Vorbis::init(ADM_audioEncoderDescriptor *config)
+{
+  int ret;
+  VORBIS_encoderParam *vorbisConf=(VORBIS_encoderParam *)config->param;
+  ADM_assert(config->paramSize==sizeof(VORBIS_encoderParam));
+
+  ogg_packet header1,header2,header3;
+  int err;
+
+  
+  
+  vorbis_info_init(&VI) ;
+
+  switch(vorbisConf->mode)
+  {
+    
+    case ADM_VORBIS_VBR:
+                      err=vorbis_encode_init(&VI,
+                              _wavheader->channels,
+                              _wavheader->frequency,
+                              -1, // Max bitrate      
+                              config->bitrate*1000, //long nominal_bitrate,
+                              -1 //long min_bitrate))
+                            );
+                      break;
+    case  ADM_VORBIS_QUALITY :
+                    err=vorbis_encode_init_vbr(&VI,
+                                _wavheader->channels,
+                                _wavheader->frequency,
+                                vorbisConf->quality/10
+                              );
+                    break;
+      
+    default:
+      ADM_assert(0);
+  }
+  if (err!=0) 
+  {
+	  delete (vorbisStruct*)_handle;
+	  _handle = NULL;
+
+    printf("[vorbis] init error %d\n",err);
+    return 0;
+  }
+  vorbis_analysis_init(&VD, &VI) ;
+  vorbis_block_init(&VD, &VB);
+  vorbis_comment_init(&VC);
+  vorbis_comment_add_tag(&VC, "encoder", "AVIDEMUX2") ;
+
+  vorbis_analysis_headerout(&VD, &VC, &header1,
+                             &header2, &header3);
+
+
+// Store all headers as extra data
+// see ogg vorbis decode for details
+// we need 3 packets
+
+  _extraSize=header1.bytes+header2.bytes+header3.bytes+3*sizeof(uint32_t);
+  _extraData=new uint8_t[_extraSize];
+
+  uint32_t *ex=(uint32_t *)_extraData;
+  uint8_t *d;
+  d=_extraData+sizeof(uint32_t)*3;
+  ex[0]=header1.bytes;
+  ex[1]=header2.bytes;
+  ex[2]=header3.bytes;
+  memcpy(d,header1.packet,ex[0]);
+  d+=ex[0];
+  memcpy(d,header2.packet,ex[1]);
+  d+=ex[1];
+  memcpy(d,header3.packet,ex[2]);
+  vorbis_comment_clear(&VC);
+			
+  printf("\n[Vorbis]Vorbis encoder initialized\n");
+  switch(vorbisConf->mode)
+  {
+    case ADM_VORBIS_VBR:
+      printf("[Vorbis]CBR Bitrate:%lu\n",config->bitrate);
+      break;
+    case ADM_VORBIS_QUALITY: //FIXME FIXME FIXME
+      printf("[Vorbis]VBR Quality:%.1f\n",vorbisConf->quality);
+    break;
+    default:
+      ADM_assert(0);
+  }
+   
+  printf("[Vorbis]Channels  :%lu\n",_wavheader->channels);
+  printf("[Vorbis]Frequency :%lu\n",_wavheader->frequency);
+  return 1;
+}
+
+#define ROUNDMAX 3000
+
+uint8_t	AUDMEncoder_Vorbis::getPacket(uint8_t *dest, uint32_t *len, uint32_t *samples)
+{
+  uint32_t nbout;
+  uint32_t consumed=0;
+  float **float_samples;
+  ogg_packet op ;
+
+  *len = 0;
+  _chunk=1024*_wavheader->channels;
+  int count=ROUNDMAX;
+// Check that we have packet from previous pass
+  while(count--)
+  {
+    if(!refillBuffer(_chunk ))
+    {
+      return 0; 
+    }
+        
+    if(tmptail-tmphead<_chunk)
+    {
+      return 0; 
+    }
+    
+	//printf("Round %d\n",ROUNDMAX-count);
+    if(vorbis_analysis_blockout(&VD, &VB) == 1) 
+    {
+      vorbis_analysis(&VB, NULL);
+      vorbis_bitrate_addblock(&VB) ;
+	//printf("Blockout\n");
+	
+      if(vorbis_bitrate_flushpacket(&VD, &op)) 
+      {
+        memcpy(dest, op.packet,op.bytes);
+        *len=op.bytes;
+        *samples=op.granulepos-_oldpos;
+        _oldpos=op.granulepos;
+        //  aprintf("1st packet :sampl:%lu len :%lu sample:%lu abs:%llu\n",*samples,op.bytes,total,op.granulepos);
+        return 1;
+      }
+    }
+
+    
+    uint32_t nbSample=(tmptail-tmphead)/_wavheader->channels;
+    if(nbSample>1024) nbSample=1024;
+    float_samples=vorbis_analysis_buffer(&VD, nbSample) ;
+    int index=tmphead;
+    // Put our samples in incoming buffer
+    reorderChannels(&(tmpbuffer[tmphead]), nbSample,_incoming->getChannelMapping(),outputChannelMapping);
+    for (int i = 0; i < nbSample; i++)
+      for (int j = 0; j < _wavheader->channels; j++) {
+      float_samples[j][i] = tmpbuffer[index++];
+      if (float_samples[j][i] > 1) float_samples[j][i] = 1;
+      if (float_samples[j][i] < -1) float_samples[j][i] = -1;
+      }
+      // Buffer full, go go go
+      vorbis_analysis_wrote(&VD, nbSample) ;  
+      tmphead+=nbSample*_wavheader->channels;	
+  }
+  return 0;
+	
+}
+/**
+      \fn DIA_getLameSettings
+      \brief Dialog to set lame settings
+      @return 1 on success, 0 on failure
+
+*/
+#include "DIA_factory.h"
+int DIA_getVorbisSettings(ADM_audioEncoderDescriptor *descriptor)
+  {
+    int ret=0;
+    char string[400];
+    uint32_t mmode,ppreset;
+    ELEM_TYPE_FLOAT qqual;
+#define SZT(x) sizeof(x)/sizeof(diaMenuEntry )
+#define PX(x) &(lameParam->x)
+    
+    
+   VORBIS_encoderParam *vorbisParam;
+  ADM_assert(sizeof(VORBIS_encoderParam)==descriptor->paramSize);
+  vorbisParam=(VORBIS_encoderParam*)descriptor->param;
+  
+    mmode=vorbisParam->mode;
+    qqual=(ELEM_TYPE_FLOAT)vorbisParam->quality;
+    
+    diaMenuEntry channelMode[]={
+                             {ADM_VORBIS_VBR,      QT_TR_NOOP("VBR"),NULL},
+                             {ADM_VORBIS_QUALITY,   QT_TR_NOOP("Quality based"),NULL}};
+          
+    diaElemMenu menuMode(&mmode,   QT_TR_NOOP("_Mode:"), SZT(channelMode),channelMode);
+    
+#define BITRATE(x) {x,QT_TR_NOOP(#x)}
+    diaMenuEntry bitrateM[]={
+                              BITRATE(56),
+                              BITRATE(64),
+                              BITRATE(80),
+                              BITRATE(96),
+                              BITRATE(112),
+                              BITRATE(128),
+                              BITRATE(160),
+                              BITRATE(192),
+                              BITRATE(224)
+                          };
+    diaElemMenu bitrate(&(descriptor->bitrate),   QT_TR_NOOP("_Bitrate:"), SZT(bitrateM),bitrateM);
+    
+    diaElemFloat quality(&qqual,QT_TR_NOOP("_Quality:"),-1.,10.);
+    
+    
+    
+  
+      diaElem *elems[]={&menuMode,&bitrate,&quality};
+    
+  if( diaFactoryRun(QT_TR_NOOP("Vorbis Configuration"),3,elems))
+  {
+    vorbisParam->mode=(ADM_VORBIS_MODE)mmode;
+    vorbisParam->quality=(float)qqual;
+    
+    return 1;
+  }
+  return 0;
+}  
+
+#endif		
+// EOF

Copied: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/vorbis/audioencoder_vorbis.h (from rev 4233, branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/include/audioencoder_vorbis.h)
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/include/audioencoder_vorbis.h	2008-07-16 17:40:50 UTC (rev 4233)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/vorbis/audioencoder_vorbis.h	2008-07-16 17:40:55 UTC (rev 4234)
@@ -0,0 +1,35 @@
+
+/***************************************************************************
+    copyright            : (C) 2002-6 by mean
+    email                : fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#ifndef AUDMaudioVorbis
+#define AUDMaudioVorbis
+
+ //_____________________________________________
+class AUDMEncoder_Vorbis : public AUDMEncoder
+{
+  protected:
+   
+    void              *_handle;
+    uint64_t          _oldpos;
+
+         
+  public:
+//            uint8_t     init(ADM_audioEncoderDescriptor *config);
+            virtual     ~AUDMEncoder_Vorbis();
+                        AUDMEncoder_Vorbis(AUDMAudioFilter *instream);	
+            
+   virtual uint8_t	getPacket(uint8_t *dest, uint32_t *len, uint32_t *samples);
+};
+
+#endif

Copied: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/vorbis/audioencoder_vorbis_param.h (from rev 4233, branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/include/audioencoder_vorbis_param.h)
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/include/audioencoder_vorbis_param.h	2008-07-16 17:40:50 UTC (rev 4233)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/vorbis/audioencoder_vorbis_param.h	2008-07-16 17:40:55 UTC (rev 4234)
@@ -0,0 +1,17 @@
+#ifndef AUDM_VORBIS_PARAM_H
+#define AUDM_VORBIS_PARAM_H
+
+typedef enum 
+{
+  ADM_VORBIS_CBR,
+  ADM_VORBIS_VBR,
+  ADM_VORBIS_QUALITY
+  
+}ADM_VORBIS_MODE;
+
+typedef struct 
+{
+  ADM_VORBIS_MODE    mode;   // 0 cbr 1 vbr 2 quality
+  float              quality;
+}VORBIS_encoderParam;
+#endif



From mean at mail.berlios.de  Wed Jul 16 19:40:59 2008
From: mean at mail.berlios.de (mean at BerliOS)
Date: Wed, 16 Jul 2008 19:40:59 +0200
Subject: [Avidemux-svn-commit] r4235 -
	branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/vorbis
Message-ID: <200807161740.m6GHexuC021394@sheep.berlios.de>

Author: mean
Date: 2008-07-16 19:40:59 +0200 (Wed, 16 Jul 2008)
New Revision: 4235

Added:
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/vorbis/CMakeLists.txt
Log:
[AudioEncoder] Vorbis


Added: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/vorbis/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/vorbis/CMakeLists.txt	2008-07-16 17:40:55 UTC (rev 4234)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/vorbis/CMakeLists.txt	2008-07-16 17:40:59 UTC (rev 4235)
@@ -0,0 +1,12 @@
+	INCLUDE(ae_plugin)
+
+	SET(ADM_ae_vorbis_SRCS audioencoder_vorbis.cpp)
+
+	ADD_LIBRARY(ADM_ae_vorbis SHARED ${ADM_ae_vorbis_SRCS})
+
+	TARGET_LINK_LIBRARIES(ADM_ae_vorbis ${VORBIS_LIBRARY_DIR} ${VORBISENC_LIBRARY_DIR})
+
+	ADD_TARGET_CFLAGS(ADM_ae_vorbis "-I${VORBIS_INCLUDE_DIR}")
+
+	INIT_AUDIO_ENCODER(ADM_ae_vorbis)
+	INSTALL_AUDIOENCODER(ADM_ae_vorbis)



From mean at mail.berlios.de  Wed Jul 16 19:40:51 2008
From: mean at mail.berlios.de (mean at BerliOS)
Date: Wed, 16 Jul 2008 19:40:51 +0200
Subject: [Avidemux-svn-commit] r4233 - in
	branches/avidemux_2.5_branch_gruntster:
	avidemux/ADM_coreAudio/include plugins/ADM_audioEncoders/twolame
	plugins/ADM_audioEncoders/twolame/ADM_libtwolame
Message-ID: <200807161740.m6GHepZ5021361@sheep.berlios.de>

Author: mean
Date: 2008-07-16 19:40:50 +0200 (Wed, 16 Jul 2008)
New Revision: 4233

Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/include/audioencoderInternal.h
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/twolame/ADM_libtwolame/CMakeLists.txt
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/twolame/ADM_libtwolame/twolame.c
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/twolame/ADM_libtwolame/util.c
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/twolame/audioencoder_twolame.cpp
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/twolame/audioencoder_twolame.h
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/twolame/audioencoder_twolame_param.h
Log:
[AudioEncoder] TwoLame


Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/include/audioencoderInternal.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/include/audioencoderInternal.h	2008-07-16 17:40:40 UTC (rev 4232)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/include/audioencoderInternal.h	2008-07-16 17:40:50 UTC (rev 4233)
@@ -81,6 +81,8 @@
 uint32_t     getBitrate(void) {return configData.bitrate;};\
 void         setBitrate(uint32_t br) {configData.bitrate=br;}
 
-
+#ifndef QT_TR_NOOP
+#define QT_TR_NOOP(x) x
 #endif
+#endif
 //EOF

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/twolame/ADM_libtwolame/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/twolame/ADM_libtwolame/CMakeLists.txt	2008-07-16 17:40:40 UTC (rev 4232)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/twolame/ADM_libtwolame/CMakeLists.txt	2008-07-16 17:40:50 UTC (rev 4233)
@@ -4,5 +4,9 @@
 	ath.c        bitbuffer.c  crc.c  encode.c      energy.c  get_set.c  psycho_0.c  psycho_2.c  psycho_4.c   subband.c  twolame.c
 	availbits.c  dab.c   fft.c     mem.c      psycho_1.c  psycho_3.c  psycho_n1.c     util.c)
 
-ADD_ADM_LIB_ALL_TARGETS(${ADM_LIB} ${${ADM_LIB}_SRCS})
-ADD_CFLAGS_ALL_TARGETS(${ADM_LIB} "-DNDEBUG -DINLINE=inline")
\ No newline at end of file
+
+ADD_LIBRARY(${ADM_LIB} STATIC ${${ADM_LIB}_SRCS})
+ADD_DEFINITIONS( "-DNDEBUG -DINLINE=inline")
+if(UNIX)
+ADD_DEFINITIONS( "-fPIC")
+endif(UNIX)

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/twolame/ADM_libtwolame/twolame.c
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/twolame/ADM_libtwolame/twolame.c	2008-07-16 17:40:40 UTC (rev 4232)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/twolame/ADM_libtwolame/twolame.c	2008-07-16 17:40:50 UTC (rev 4233)
@@ -20,14 +20,7 @@
  *  
  */
 
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <math.h>
-#include <assert.h>
-
-#include "config.h"
-
+#include "ADM_default.h"
 #include "twolame.h"
 #include "common.h"
 #include "bitbuffer.h"

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/twolame/ADM_libtwolame/util.c
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/twolame/ADM_libtwolame/util.c	2008-07-16 17:40:40 UTC (rev 4232)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/twolame/ADM_libtwolame/util.c	2008-07-16 17:40:50 UTC (rev 4233)
@@ -20,14 +20,9 @@
  *  
  */
 
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
+#include "ADM_default.h"
 #include <math.h>
-#include <assert.h>
 
-#include "config.h"
-
 #include "twolame.h"
 #include "common.h"
 #include "util.h"

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/twolame/audioencoder_twolame.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/twolame/audioencoder_twolame.cpp	2008-07-16 17:40:40 UTC (rev 4232)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/twolame/audioencoder_twolame.cpp	2008-07-16 17:40:50 UTC (rev 4233)
@@ -12,32 +12,59 @@
  *                                                                         *
  ***************************************************************************/
 
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
 #include <math.h>
 
 #include "ADM_default.h"
+#include "DIA_factory.h"
+#include "DIA_coreToolkit.h"
 
 #include "audioencoder.h"
-//
+#include "audioencoderInternal.h"
 #include "audioencoder_twolame.h"
 #include "audioencoder_twolame_param.h"
 
 extern "C"
 {
-#include "ADM_libraries/ADM_libtwolame/twolame.h"
+#include "twolame.h"
 }
-#include "ADM_osSupport/ADM_debugID.h"
-#define MODULE_NAME MODULE_AUDIO_FILTER
-#include "ADM_osSupport/ADM_debug.h"
 
-
 #define OPTIONS (twolame_options_struct *)_twolameOptions
 
-// Ctor: Duplicate
-//__________
+static TWOLAME_encoderParam twolameParam=
+{
+    128,
+    ADM_STEREO
+};
+static uint8_t configure (void);
+/********************* Declare Plugin *****************************************************/
+ADM_DECLARE_AUDIO_ENCODER_PREAMBLE(AUDMEncoder_Twolame);
 
+static ADM_audioEncoder encoderDesc = { 
+  ADM_AUDIO_ENCODER_API_VERSION,
+  create,			// Defined by macro automatically
+  destroy,			// Defined by macro automatically
+  configure,		//** put your own function here**
+  "TwoLame",            
+  "MP2 (Twolame)",      
+  "TwoLame MP2 encoder plugin Mean 2008",             
+  2,                    // Max channels
+  1,0,0,                // Version
+  WAV_MP2,
+  200,                  // Priority
+  getConfigurationData,  // Defined by macro automatically
+  setConfigurationData,  // Defined by macro automatically
+
+  getBitrate,           // Defined by macro automatically
+  setBitrate,            // Defined by macro automatically 
+
+  NULL,         //** put your own function here**
+
+  NULL
+};
+ADM_DECLARE_AUDIO_ENCODER_CONFIG(twolameParam);
+
+/******************* / Declare plugin*******************************************************/
+
 AUDMEncoder_Twolame::AUDMEncoder_Twolame(AUDMAudioFilter * instream)  :AUDMEncoder    (instream)
 {
   printf("[TwoLame] Creating Twolame\n");
@@ -56,22 +83,17 @@
   _twolameOptions=NULL;
   cleanup();
 };
+/**
+    \fn initialize
 
-//________________________________________________
-//   Init lame encoder
-// frequence    : Impose frequency , 0 means reuse the incoming fq
-// mode                         : ADM_STEREO etc...
-// bitrate              : Bitrate in kbps (96,192...)
-// return 0 : init failed
-//                              1 : init succeeded
-//_______________________________________________
-uint8_t AUDMEncoder_Twolame::init(ADM_audioEncoderDescriptor *config)
+*/
+uint8_t AUDMEncoder_Twolame::initialize(void)
 {
   int ret;
   TWOLAME_MPEG_mode mmode;    	
   uint32_t frequence;
-  TWOLAME_encoderParam *lameConf=(TWOLAME_encoderParam *)config->param;
-  ADM_assert(config->paramSize==sizeof(TWOLAME_encoderParam));
+  TWOLAME_encoderParam *lameConf=&twolameParam;
+  
 
   _twolameOptions = twolame_init();
   if (_twolameOptions == NULL)
@@ -82,14 +104,14 @@
     printf("[TwoLame]Too many channels\n");
     return 0; 
   }
-  _wavheader->byterate=(config->bitrate*1000)>>3;         
+  _wavheader->byterate=(lameConf->bitrate*1000)>>3;         
       
  
   _chunk = 1152*_wavheader->channels;
 
  
   printf("[TwoLame]Incoming :fq : %lu, channel : %lu bitrate: %lu \n",
-        _wavheader->frequency,_wavheader->channels,config->bitrate);
+        _wavheader->frequency,_wavheader->channels,lameConf->bitrate);
 		
  
   twolame_set_in_samplerate(OPTIONS, _wavheader->frequency);
@@ -118,7 +140,7 @@
   twolame_set_mode(OPTIONS,mmode);
   twolame_set_error_protection(OPTIONS,TRUE);	
     	//toolame_setPadding (options,TRUE);
-  twolame_set_bitrate (OPTIONS,config->bitrate);
+  twolame_set_bitrate (OPTIONS,lameConf->bitrate);
   twolame_set_verbosity(OPTIONS, 2);
   if(twolame_init_params(OPTIONS))
   {
@@ -131,7 +153,9 @@
   printf("[TwoLame]Libtoolame successfully initialized\n");
   return 1;       
 }
-
+/**
+        \fn getPacket
+*/
 uint8_t	AUDMEncoder_Twolame::getPacket(uint8_t *dest, uint32_t *len, uint32_t *samples)
 {
   int nbout;
@@ -169,6 +193,48 @@
   *len=nbout;
   return 1;
 }
+#define SZT(x) sizeof(x)/sizeof(diaMenuEntry )
+#define BITRATE(x) {x,QT_TR_NOOP(#x)}
 
+/**
+    \fn configure
+*/
+uint8_t configure (void)
+{
+ int ret=0;
+  
+  uint32_t m=(uint32_t)twolameParam.mode;  
+    
+    diaMenuEntry channelMode[] = 
+    {
+        {ADM_STEREO, QT_TR_NOOP ("Stereo"), NULL},
+        {ADM_JSTEREO, QT_TR_NOOP ("Joint stereo"), NULL},
+        {ADM_MONO, QT_TR_NOOP ("Mono"), NULL}
+    };
+    diaMenuEntry bitrateM[]={
+                              BITRATE(56),
+                              BITRATE(64),
+                              BITRATE(80),
+                              BITRATE(96),
+                              BITRATE(112),
+                              BITRATE(128),
+                              BITRATE(160),
+                              BITRATE(192),
+                              BITRATE(224),
+                              BITRATE(384)
+                          };
+    diaElemMenu bitrate(&(twolameParam.bitrate),   QT_TR_NOOP("_Bitrate:"), SZT(bitrateM),bitrateM);
+  
+    diaElemMenu menuMode (&m, QT_TR_NOOP ("C_hannel mode:"),SZT (channelMode), channelMode);
 
+    diaElem *elems[]={&bitrate,&menuMode};
+    
+    if( diaFactoryRun(QT_TR_NOOP("TwoLame Configuration"),2,elems))
+    {
+        twolameParam.mode=(ADM_mode)m;
+        return 1;
+    }
+
+    return 0;
+}
 // EOF

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/twolame/audioencoder_twolame.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/twolame/audioencoder_twolame.h	2008-07-16 17:40:40 UTC (rev 4232)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/twolame/audioencoder_twolame.h	2008-07-16 17:40:50 UTC (rev 4233)
@@ -21,10 +21,10 @@
     void           *_twolameOptions;
          
   public:
-//            uint8_t     init(ADM_audioEncoderDescriptor *config);
+            uint8_t     initialize(void);
     virtual             ~AUDMEncoder_Twolame();
                         AUDMEncoder_Twolame(AUDMAudioFilter *instream);	
-    virtual uint8_t	getPacket(uint8_t *dest, uint32_t *len, uint32_t *samples);
+    virtual uint8_t	    getPacket(uint8_t *dest, uint32_t *len, uint32_t *samples);
 };
 
 #endif

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/twolame/audioencoder_twolame_param.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/twolame/audioencoder_twolame_param.h	2008-07-16 17:40:40 UTC (rev 4232)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/twolame/audioencoder_twolame_param.h	2008-07-16 17:40:50 UTC (rev 4233)
@@ -9,6 +9,7 @@
 
 typedef struct 
 {
+  uint32_t        bitrate;
   ADM_mode        mode;
 }TWOLAME_encoderParam;
 



From mean at mail.berlios.de  Wed Jul 16 19:41:01 2008
From: mean at mail.berlios.de (mean at BerliOS)
Date: Wed, 16 Jul 2008 19:41:01 +0200
Subject: [Avidemux-svn-commit] r4236 - in
	branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders:
	aften pcm vorbis
Message-ID: <200807161741.m6GHf16a021404@sheep.berlios.de>

Author: mean
Date: 2008-07-16 19:41:00 +0200 (Wed, 16 Jul 2008)
New Revision: 4236

Modified:
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/aften/audioencoder_aften.cpp
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/aften/audioencoder_aften.h
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/aften/audioencoder_aften_param.h
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/pcm/audioencoder_pcm.cpp
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/vorbis/audioencoder_vorbis.cpp
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/vorbis/audioencoder_vorbis.h
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/vorbis/audioencoder_vorbis_param.h
Log:
[AudioEncoder] Aften+pcm+vorbis


Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/aften/audioencoder_aften.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/aften/audioencoder_aften.cpp	2008-07-16 17:40:59 UTC (rev 4235)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/aften/audioencoder_aften.cpp	2008-07-16 17:41:00 UTC (rev 4236)
@@ -15,20 +15,13 @@
  *   (at your option) any later version.                                   *
  *                                                                         *
  ***************************************************************************/
-#include "config.h"
-#ifdef USE_AFTEN
-#include "config.h"
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
 #include <math.h>
-
-
 #include "ADM_default.h"
+#include "DIA_factory.h"
+#include "DIA_coreToolkit.h"
+#include "audioencoder.h"
+#include "audioencoderInternal.h"
 
-#include "audioprocess.hxx"
-#include "audioeng_process.h"
-#include "audioencoder.h"
 //
 extern "C"
 {
@@ -42,6 +35,47 @@
 #include "audioencoder_aften.h"
 
 #define _HANDLE ((AftenContext *)_handle)
+
+static AFTEN_encoderParam aftenParam= {
+  128
+  
+};
+static uint8_t configure (void);
+/********************* Declare Plugin *****************************************************/
+ADM_DECLARE_AUDIO_ENCODER_PREAMBLE(AUDMEncoder_Aften);
+
+static ADM_audioEncoder encoderDesc = { 
+  ADM_AUDIO_ENCODER_API_VERSION,
+  create,			// Defined by macro automatically
+  destroy,			// Defined by macro automatically
+  configure,		//** put your own function here**
+  "Aften",            
+  "AC3 (Aften)",      
+  "Aften AC3 encoder plugin Mean/Gruntster 2008",             
+  6,                    // Max channels
+  1,0,0,                // Version
+  WAV_AC3,
+  200,                  // Priority
+  getConfigurationData,  // Defined by macro automatically
+  setConfigurationData,  // Defined by macro automatically
+
+  getBitrate,           // Defined by macro automatically
+  setBitrate,            // Defined by macro automatically 
+
+  NULL,         //** put your own function here**
+
+  NULL
+};
+ADM_DECLARE_AUDIO_ENCODER_CONFIG(aftenParam);
+
+/******************* / Declare plugin*******************************************************/
+
+
+/**
+    \fn AUDMEncoder_Aften
+
+*/
+
 AUDMEncoder_Aften::AUDMEncoder_Aften(AUDMAudioFilter * instream)  :AUDMEncoder    (instream)
 {
   uint32_t channels;
@@ -58,7 +92,11 @@
 #endif
 };
 
+/**
+    \fn ~AUDMEncoder_Aften
 
+*/
+
 AUDMEncoder_Aften::~AUDMEncoder_Aften()
 {
     if(_handle)
@@ -71,15 +109,11 @@
 };
 
 
-//________________________________________________
-//   Init lame encoder
-// frequence    : Impose frequency , 0 means reuse the incoming fq
-// mode                         : ADM_STEREO etc...
-// bitrate              : Bitrate in kbps (96,192...)
-// return 0 : init failed
-//                              1 : init succeeded
-//_______________________________________________
-uint8_t AUDMEncoder_Aften::init(ADM_audioEncoderDescriptor *config)
+/**
+    \fn initialize
+
+*/
+uint8_t AUDMEncoder_Aften::initialize(void)
 {
 
 
@@ -91,12 +125,12 @@
 unsigned int mask;
 #endif
 
-    _wavheader->byterate=(config->bitrate*1000)/8;
+    _wavheader->byterate=(aftenParam.bitrate*1000)/8;
     _HANDLE->sample_format=A52_SAMPLE_FMT_FLT;
     _HANDLE->channels=_wavheader->channels;
     _HANDLE->samplerate=_wavheader->frequency;
     
-    _HANDLE->params.bitrate=config->bitrate;
+    _HANDLE->params.bitrate=aftenParam.bitrate;
     switch(_wavheader->channels)
     {
         case 1: mask = 0x04;  break;
@@ -127,7 +161,9 @@
 }
 
 
-//______________________________________________
+/**
+        \fn getPacket
+*/
 uint8_t	AUDMEncoder_Aften::getPacket(uint8_t *dest, uint32_t *len, uint32_t *samples)
 {
   uint32_t count=0;
@@ -162,5 +198,32 @@
         return 1;
 }
 
-#endif		
+/**
+    \fn configure
+*/
+uint8_t configure (void)
+{
+ int ret=0;
+
+    diaMenuEntry bitrateM[]={
+                              BITRATE(56),
+                              BITRATE(64),
+                              BITRATE(80),
+                              BITRATE(96),
+                              BITRATE(112),
+                              BITRATE(128),
+                              BITRATE(160),
+                              BITRATE(192),
+                              BITRATE(224),
+                              BITRATE(384)
+                          };
+    diaElemMenu bitrate(&(aftenParam.bitrate),   QT_TR_NOOP("_Bitrate:"), SZT(bitrateM),bitrateM);
+  
+    
+
+    diaElem *elems[]={&bitrate};
+    
+    return ( diaFactoryRun(QT_TR_NOOP("Aften Configuration"),1,elems));
+    
+}
 // EOF

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/aften/audioencoder_aften.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/aften/audioencoder_aften.h	2008-07-16 17:40:59 UTC (rev 4235)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/aften/audioencoder_aften.h	2008-07-16 17:41:00 UTC (rev 4236)
@@ -14,7 +14,7 @@
  ***************************************************************************/
 #ifndef AUDMaudioAften
 #define AUDMaudioAften
-#ifdef USE_AFTEN
+
  //_____________________________________________
 class AUDMEncoder_Aften : public AUDMEncoder
 {
@@ -22,10 +22,10 @@
          void           *_handle;
          
 public:
-                        uint8_t init(ADM_audioEncoderDescriptor *config);
+                uint8_t initialize(void);
                 virtual ~AUDMEncoder_Aften();
                         AUDMEncoder_Aften(AUDMAudioFilter *instream);	
-                virtual uint8_t	getPacket(uint8_t *dest, uint32_t *len, uint32_t *samples);
+        virtual uint8_t	getPacket(uint8_t *dest, uint32_t *len, uint32_t *samples);
 };
 #endif
-#endif
+

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/aften/audioencoder_aften_param.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/aften/audioencoder_aften_param.h	2008-07-16 17:40:59 UTC (rev 4235)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/aften/audioencoder_aften_param.h	2008-07-16 17:41:00 UTC (rev 4236)
@@ -1,10 +1,11 @@
 #ifndef AUDM_AFTEN_PARAM_H
 #define AUDM_AFTEN_PARAM_H
-#ifdef USE_AFTEN
 
+
 typedef struct AFTEN_encoderParam
 {
+  uint32_t        bitrate;
   ADM_mode        mode;
 };
+
 #endif
-#endif

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/pcm/audioencoder_pcm.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/pcm/audioencoder_pcm.cpp	2008-07-16 17:40:59 UTC (rev 4235)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/pcm/audioencoder_pcm.cpp	2008-07-16 17:41:00 UTC (rev 4236)
@@ -12,9 +12,6 @@
  *                                                                         *
  ***************************************************************************/
 
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
 #include <math.h>
 
 #include "ADM_default.h"

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/vorbis/audioencoder_vorbis.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/vorbis/audioencoder_vorbis.cpp	2008-07-16 17:40:59 UTC (rev 4235)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/vorbis/audioencoder_vorbis.cpp	2008-07-16 17:41:00 UTC (rev 4236)
@@ -11,27 +11,22 @@
  *   (at your option) any later version.                                   *
  *                                                                         *
  ***************************************************************************/
-#include "config.h"
-#ifdef USE_VORBIS
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
 #include <math.h>
 
+#include <math.h>
+
 #include "ADM_default.h"
+#include "DIA_factory.h"
+#include "DIA_coreToolkit.h"
 
 #include "audioencoder.h"
-//
+#include "audioencoderInternal.h"
 #include "audioencoder_vorbis_param.h"
 #include "audioencoder_vorbis.h"
 
 
 #include "vorbis/vorbisenc.h"
-#include "ADM_osSupport/ADM_debugID.h"
-#define MODULE_NAME MODULE_AUDIO_FILTER
-#include "ADM_osSupport/ADM_debug.h"
 
-
 #define OPTIONS (twolame_options_struct *)_twolameOptions
 
 #define VD (((vorbisStruct *)_handle)->vd)
@@ -45,6 +40,45 @@
 	vorbis_block     vb ;
 	vorbis_comment   vc ;
 }vorbisStruct;
+//___________
+static VORBIS_encoderParam vorbisParam=
+{
+    128,
+    ADM_VORBIS_VBR,
+    9
+};
+
+static uint8_t configure(void);
+/********************* Declare Plugin *****************************************************/
+ADM_DECLARE_AUDIO_ENCODER_PREAMBLE(AUDMEncoder_Vorbis);
+
+static ADM_audioEncoder encoderDesc = { 
+  ADM_AUDIO_ENCODER_API_VERSION,
+  create,			// Defined by macro automatically
+  destroy,			// Defined by macro automatically
+  configure,		//** put your own function here**
+  "Vorbis",            
+  "Vorbis",      
+  "Vorbis encoder plugin Mean 2008",             
+  6,                    // Max channels
+  1,0,0,                // Version
+  WAV_OGG,
+  200,                  // Priority
+  getConfigurationData,  // Defined by macro automatically
+  setConfigurationData,  // Defined by macro automatically
+
+  getBitrate,           // Defined by macro automatically
+  setBitrate,            // Defined by macro automatically 
+
+  NULL,         //** put your own function here**
+
+  NULL
+};
+ADM_DECLARE_AUDIO_ENCODER_CONFIG(vorbisParam);
+
+/******************* / Declare plugin*******************************************************/
+
+
 //__________
 
 AUDMEncoder_Vorbis::AUDMEncoder_Vorbis(AUDMAudioFilter * instream)  :AUDMEncoder    (instream)
@@ -62,7 +96,9 @@
   outputChannelMapping[5] = CH_LFE;
 };
 
+/**
 
+*/
 AUDMEncoder_Vorbis::~AUDMEncoder_Vorbis()
 {
   printf("[Vorbis] Deleting Vorbis\n");
@@ -78,19 +114,15 @@
   cleanup();
 };
 
-//________________________________________________
-//   Init lame encoder
-// frequence    : Impose frequency , 0 means reuse the incoming fq
-// mode                         : ADM_STEREO etc...
-// bitrate              : Bitrate in kbps (96,192...)
-// return 0 : init failed
-//                              1 : init succeeded
-//_______________________________________________
-uint8_t AUDMEncoder_Vorbis::init(ADM_audioEncoderDescriptor *config)
+/**
+    \fn initialize
+
+*/
+uint8_t AUDMEncoder_Vorbis::initialize(void)
 {
   int ret;
-  VORBIS_encoderParam *vorbisConf=(VORBIS_encoderParam *)config->param;
-  ADM_assert(config->paramSize==sizeof(VORBIS_encoderParam));
+  VORBIS_encoderParam *vorbisConf=&vorbisParam;
+  
 
   ogg_packet header1,header2,header3;
   int err;
@@ -107,7 +139,7 @@
                               _wavheader->channels,
                               _wavheader->frequency,
                               -1, // Max bitrate      
-                              config->bitrate*1000, //long nominal_bitrate,
+                              vorbisConf->bitrate*1000, //long nominal_bitrate,
                               -1 //long min_bitrate))
                             );
                       break;
@@ -163,7 +195,7 @@
   switch(vorbisConf->mode)
   {
     case ADM_VORBIS_VBR:
-      printf("[Vorbis]CBR Bitrate:%lu\n",config->bitrate);
+      printf("[Vorbis]CBR Bitrate:%lu\n",vorbisConf->bitrate);
       break;
     case ADM_VORBIS_QUALITY: //FIXME FIXME FIXME
       printf("[Vorbis]VBR Quality:%.1f\n",vorbisConf->quality);
@@ -178,7 +210,10 @@
 }
 
 #define ROUNDMAX 3000
+/**
+    \fn getPacket
 
+*/
 uint8_t	AUDMEncoder_Vorbis::getPacket(uint8_t *dest, uint32_t *len, uint32_t *samples)
 {
   uint32_t nbout;
@@ -240,29 +275,27 @@
   return 0;
 	
 }
+#define SZT(x) sizeof(x)/sizeof(diaMenuEntry )
+#define PX(x) &(lameParam->x)
+#define BITRATE(x) {x,QT_TR_NOOP(#x)}
 /**
-      \fn DIA_getLameSettings
-      \brief Dialog to set lame settings
+      \fn configure
+      \brief Dialog to set vorbis settings
       @return 1 on success, 0 on failure
 
 */
-#include "DIA_factory.h"
-int DIA_getVorbisSettings(ADM_audioEncoderDescriptor *descriptor)
-  {
-    int ret=0;
-    char string[400];
+
+uint8_t configure(void)
+{
+    
     uint32_t mmode,ppreset;
     ELEM_TYPE_FLOAT qqual;
-#define SZT(x) sizeof(x)/sizeof(diaMenuEntry )
-#define PX(x) &(lameParam->x)
     
     
-   VORBIS_encoderParam *vorbisParam;
-  ADM_assert(sizeof(VORBIS_encoderParam)==descriptor->paramSize);
-  vorbisParam=(VORBIS_encoderParam*)descriptor->param;
+   VORBIS_encoderParam *vParam=&vorbisParam;
   
-    mmode=vorbisParam->mode;
-    qqual=(ELEM_TYPE_FLOAT)vorbisParam->quality;
+    mmode=vParam->mode;
+    qqual=(ELEM_TYPE_FLOAT)vParam->quality;
     
     diaMenuEntry channelMode[]={
                              {ADM_VORBIS_VBR,      QT_TR_NOOP("VBR"),NULL},
@@ -270,7 +303,7 @@
           
     diaElemMenu menuMode(&mmode,   QT_TR_NOOP("_Mode:"), SZT(channelMode),channelMode);
     
-#define BITRATE(x) {x,QT_TR_NOOP(#x)}
+
     diaMenuEntry bitrateM[]={
                               BITRATE(56),
                               BITRATE(64),
@@ -282,7 +315,7 @@
                               BITRATE(192),
                               BITRATE(224)
                           };
-    diaElemMenu bitrate(&(descriptor->bitrate),   QT_TR_NOOP("_Bitrate:"), SZT(bitrateM),bitrateM);
+    diaElemMenu bitrate(&(vParam->bitrate),   QT_TR_NOOP("_Bitrate:"), SZT(bitrateM),bitrateM);
     
     diaElemFloat quality(&qqual,QT_TR_NOOP("_Quality:"),-1.,10.);
     
@@ -293,13 +326,11 @@
     
   if( diaFactoryRun(QT_TR_NOOP("Vorbis Configuration"),3,elems))
   {
-    vorbisParam->mode=(ADM_VORBIS_MODE)mmode;
-    vorbisParam->quality=(float)qqual;
-    
+    vParam->mode=(ADM_VORBIS_MODE)mmode;
+    vParam->quality=(float)qqual;
     return 1;
   }
   return 0;
 }  
 
-#endif		
 // EOF

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/vorbis/audioencoder_vorbis.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/vorbis/audioencoder_vorbis.h	2008-07-16 17:40:59 UTC (rev 4235)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/vorbis/audioencoder_vorbis.h	2008-07-16 17:41:00 UTC (rev 4236)
@@ -25,7 +25,7 @@
 
          
   public:
-//            uint8_t     init(ADM_audioEncoderDescriptor *config);
+            uint8_t     initialize(void);
             virtual     ~AUDMEncoder_Vorbis();
                         AUDMEncoder_Vorbis(AUDMAudioFilter *instream);	
             

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/vorbis/audioencoder_vorbis_param.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/vorbis/audioencoder_vorbis_param.h	2008-07-16 17:40:59 UTC (rev 4235)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/vorbis/audioencoder_vorbis_param.h	2008-07-16 17:41:00 UTC (rev 4236)
@@ -11,6 +11,7 @@
 
 typedef struct 
 {
+  uint32_t           bitrate;
   ADM_VORBIS_MODE    mode;   // 0 cbr 1 vbr 2 quality
   float              quality;
 }VORBIS_encoderParam;



From mean at mail.berlios.de  Wed Jul 16 19:41:03 2008
From: mean at mail.berlios.de (mean at BerliOS)
Date: Wed, 16 Jul 2008 19:41:03 +0200
Subject: [Avidemux-svn-commit] r4237 - in
	branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders:
	. faac
Message-ID: <200807161741.m6GHf39t021414@sheep.berlios.de>

Author: mean
Date: 2008-07-16 19:41:02 +0200 (Wed, 16 Jul 2008)
New Revision: 4237

Modified:
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/CMakeLists.txt
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/faac/audioencoder_faac.cpp
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/faac/audioencoder_faac.h
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/faac/audioencoder_faac_param.h
Log:
[AudioEncoder] FAAC


Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/CMakeLists.txt	2008-07-16 17:41:00 UTC (rev 4236)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/CMakeLists.txt	2008-07-16 17:41:02 UTC (rev 4237)
@@ -25,5 +25,5 @@
 endif(USE_VORBIS)
 
 if(USE_FAAC)
-#ADD_SUBDIRECTORY(faac)
+ADD_SUBDIRECTORY(faac)
 endif(USE_FAAC)

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/faac/audioencoder_faac.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/faac/audioencoder_faac.cpp	2008-07-16 17:41:00 UTC (rev 4236)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/faac/audioencoder_faac.cpp	2008-07-16 17:41:02 UTC (rev 4237)
@@ -18,13 +18,50 @@
 #include <math.h>
 
 #include "ADM_default.h"
+#include "DIA_factory.h"
+#include "DIA_coreToolkit.h"
 
 #include "audioencoder.h"
-//
+#include "audioencoderInternal.h"
 
 #include "faac.h"
 #include "audioencoder_faac.h"
+#include "audioencoder_faac_param.h"
 
+static uint8_t configure(void);
+
+static FAAC_encoderParam faacParm={
+    128
+};
+/********************* Declare Plugin *****************************************************/
+ADM_DECLARE_AUDIO_ENCODER_PREAMBLE(AUDMEncoder_Faac);
+
+static ADM_audioEncoder encoderDesc = { 
+  ADM_AUDIO_ENCODER_API_VERSION,
+  create,			// Defined by macro automatically
+  destroy,			// Defined by macro automatically
+  configure,		//** put your own function here**
+  "Faac",            
+  "AAC (Faac)",      
+  "Faac AAC encoder plugin Mean 2008",             
+  6,                    // Max channels
+  1,0,0,                // Version
+  WAV_AAC,
+  200,                  // Priority
+  getConfigurationData,  // Defined by macro automatically
+  setConfigurationData,  // Defined by macro automatically
+
+  getBitrate,           // Defined by macro automatically
+  setBitrate,            // Defined by macro automatically 
+
+  NULL,         //** put your own function here**
+
+  NULL
+};
+ADM_DECLARE_AUDIO_ENCODER_CONFIG( faacParm);
+
+/******************* / Declare plugin*******************************************************/
+
 AUDMEncoder_Faac::AUDMEncoder_Faac(AUDMAudioFilter * instream)  :AUDMEncoder    (instream)
 {
   uint32_t channels;
@@ -58,16 +95,11 @@
 };
 
 
-//________________________________________________
-//   Init lame encoder
-// frequence    : Impose frequency , 0 means reuse the incoming fq
-// mode                         : ADM_STEREO etc...
-// bitrate              : Bitrate in kbps (96,192...)
-// return 0 : init failed
-//                              1 : init succeeded
-//_______________________________________________
-#if 0
-uint8_t AUDMEncoder_Faac::init(ADM_audioEncoderDescriptor *config)
+/**
+    \fn initialize
+
+*/
+uint8_t AUDMEncoder_Faac::initialize(void)
 {
 unsigned long int samples_input, max_bytes_output;
 faacEncConfigurationPtr cfg;
@@ -81,7 +113,7 @@
     if(!_handle)
     {
           printf("Cannot open faac with fq=%lu chan=%lu br=%lu\n",
-          _wavheader->frequency,_wavheader->channels,config->bitrate);
+          _wavheader->frequency,_wavheader->channels,faacParm.bitrate);
           return 0;
     }
     printf(" [FAAC] : Sample input:%d, max byte output%d \n",samples_input,max_bytes_output);
@@ -93,14 +125,14 @@
     cfg->bandWidth= (_wavheader->frequency*3)/4; // Should be relevant
     cfg->useTns = 0;
     cfg->allowMidside = 0;
-    cfg->bitRate = (config->bitrate*1000)/_wavheader->channels; // It is per channel
+    cfg->bitRate = (faacParm.bitrate*1000)/_wavheader->channels; // It is per channel
     cfg->outputFormat = 0; // 0 Raw 1 ADTS
     cfg->inputFormat = FAAC_INPUT_FLOAT;
     cfg->useLfe=0;	
     if (!(ret=faacEncSetConfiguration(_handle, cfg))) 
     {
         printf("[FAAC] Cannot set conf for faac with fq=%lu chan=%lu br=%lu (err:%d)\n",
-				_wavheader->frequency,_wavheader->channels,config->bitrate,ret);
+				_wavheader->frequency,_wavheader->channels,faacParm.bitrate,ret);
 	return 0;
     }
      unsigned char *data=NULL;
@@ -115,7 +147,7 @@
      memcpy(_extraData,data,size);
 
     // update
-     _wavheader->byterate=(config->bitrate*1000)/8;
+     _wavheader->byterate=(faacParm.bitrate*1000)/8;
 //    _wavheader->dwScale=1024;
 //    _wavheader->dwSampleSize=0;
     _wavheader->blockalign=4096;
@@ -136,7 +168,7 @@
     
     return 1;
 }
-#endif
+
 //_____________________________________________
 //  Need to multiply the float by 32767, can't use
 //  generic fill buffer
@@ -184,7 +216,7 @@
     }
   }
 }
-
+#define SIZE_INTERNAL 64*1024 
 #define FA_BUFFER_SIZE (SIZE_INTERNAL/4)
 //______________________________________________
 uint8_t	AUDMEncoder_Faac::getPacket(uint8_t *dest, uint32_t *len, uint32_t *samples)
@@ -211,5 +243,35 @@
         tmphead+=_chunk;
         return 1;
 }
-#endif		
+#define SZT(x) sizeof(x)/sizeof(diaMenuEntry )
+#define BITRATE(x) {x,QT_TR_NOOP(#x)}
+
+/**
+    \fn configure
+*/
+uint8_t configure (void)
+{
+ int ret=0;
+
+    diaMenuEntry bitrateM[]={
+                              BITRATE(56),
+                              BITRATE(64),
+                              BITRATE(80),
+                              BITRATE(96),
+                              BITRATE(112),
+                              BITRATE(128),
+                              BITRATE(160),
+                              BITRATE(192),
+                              BITRATE(224),
+                              BITRATE(384)
+                          };
+    diaElemMenu bitrate(&(faacParm.bitrate),   QT_TR_NOOP("_Bitrate:"), SZT(bitrateM),bitrateM);
+  
+    
+
+    diaElem *elems[]={&bitrate};
+    
+    return ( diaFactoryRun(QT_TR_NOOP("Aften Configuration"),1,elems));
+    
+}	
 // EOF

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/faac/audioencoder_faac.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/faac/audioencoder_faac.h	2008-07-16 17:41:00 UTC (rev 4236)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/faac/audioencoder_faac.h	2008-07-16 17:41:02 UTC (rev 4237)
@@ -22,7 +22,7 @@
          void           *_handle;
          uint8_t        refillBuffer(int minimum);
 public:
-//                        uint8_t init(ADM_audioEncoderDescriptor *config);
+                 uint8_t initialize(void);
                 virtual ~AUDMEncoder_Faac();
                         AUDMEncoder_Faac(AUDMAudioFilter *instream);	
                 virtual uint8_t	getPacket(uint8_t *dest, uint32_t *len, uint32_t *samples);

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/faac/audioencoder_faac_param.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/faac/audioencoder_faac_param.h	2008-07-16 17:41:00 UTC (rev 4236)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/faac/audioencoder_faac_param.h	2008-07-16 17:41:02 UTC (rev 4237)
@@ -3,6 +3,6 @@
 #define FAAC_PARAM_H
 typedef struct 
 {
-  uint32_t dummy;
+  uint32_t bitrate;
 }FAAC_encoderParam;
 #endif



From mean at mail.berlios.de  Wed Jul 16 19:41:06 2008
From: mean at mail.berlios.de (mean at BerliOS)
Date: Wed, 16 Jul 2008 19:41:06 +0200
Subject: [Avidemux-svn-commit] r4238 - in
	branches/avidemux_2.5_branch_gruntster/avidemux: .
	ADM_audiofilter ADM_toolkit ADM_userInterfaces/ADM_GTK/ADM_gui2
	ADM_userInterfaces/ADM_commonUI
Message-ID: <200807161741.m6GHf65d021424@sheep.berlios.de>

Author: mean
Date: 2008-07-16 19:41:05 +0200 (Wed, 16 Jul 2008)
New Revision: 4238

Removed:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_audioconfig.cpp
Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audio_encoderPlugin.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioeng_buildfilters.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audiofilter_buildchain.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audiofilter_mixer.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audiofilter_sox.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_toolkit/automation.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_GTK/ADM_gui2/GUI_bindings.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_commonUI/CMakeLists.txt
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_builtin.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/gui_autodrive.cpp
Log:
[] cleanup


Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audio_encoderPlugin.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audio_encoderPlugin.cpp	2008-07-16 17:41:02 UTC (rev 4237)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audio_encoderPlugin.cpp	2008-07-16 17:41:05 UTC (rev 4238)
@@ -390,5 +390,42 @@
         return encoder->setConfigurationData(extraDataSize,extradata);
     else return 1;
 }     
+/**
+        \fn audio_selectCodecByTag
+        \brief Select the "best" encoder outputing tag codec
+*/
+uint8_t audio_selectCodecByTag(uint32_t tag)
+{
+    int selected=-1,priority=-1;
+    for(int i=1;i<ListOfAudioEncoder.size();i++)
+    {
+        ADM_audioEncoder *c=ListOfAudioEncoder[i];
+        if(c->wavTag==tag)
+        {
+            if((int)c->priority>priority)
+            {
+                selected=i;
+                priority=c->priority;
+            }
+        }
+    }
+    if(selected!=-1)
+    {
+        currentEncoder=selected;
+        printf("[AudioEncoder] Selected %s for tag %d (%s)\n",ListOfAudioEncoder[currentEncoder],tag,"");
+        return 1;
+    }
+    return 0;
+}
+/**
+         \fn audioSetOption
+         \brief Allow per codec switch
+*/
+uint8_t audioSetOption(const char *option, uint32_t value)
+{
+    ADM_audioEncoder *c=ListOfAudioEncoder[currentEncoder];
+    if(!c->setOption) return 0;
+    return c->setOption(option,value);
 
+}
 //**

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioeng_buildfilters.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioeng_buildfilters.h	2008-07-16 17:41:02 UTC (rev 4237)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioeng_buildfilters.h	2008-07-16 17:41:05 UTC (rev 4238)
@@ -110,6 +110,10 @@
 uint8_t getAudioExtraConf(uint32_t *bitrate,uint32_t *extraDataSize, uint8_t **extradata);
 uint8_t setAudioExtraConf(uint32_t bitrate,uint32_t extraDataSize, uint8_t *extradata);
 //
+uint8_t audio_selectCodecByTag(uint32_t tag);
+void audioCodecChanged(int newcodec);
+uint8_t audioSetOption(const char *option, uint32_t value);
+//
 AUDMEncoder *audioEncoderCreate(AUDMAudioFilter *filter);
 #endif
 

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audiofilter_buildchain.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audiofilter_buildchain.cpp	2008-07-16 17:41:02 UTC (rev 4237)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audiofilter_buildchain.cpp	2008-07-16 17:41:05 UTC (rev 4238)
@@ -22,14 +22,6 @@
 #include "audioencoder.h"
 
 #include "ADM_audiofilter/audiofilter_limiter_param.h"
-#define FIXME_ZAZA
-#if 0
-#include "audioencoder_lame_param.h"
-#include "audioencoder_twolame_param.h"
-#include "audioencoder_faac_param.h"
-#include "audioencoder_vorbis_param.h"
-#include "audioencoder_aften_param.h"
-#endif
 #include "audiofilter_normalize_param.h"
 #include "audio_encoderWrapper.h"
 
@@ -38,27 +30,10 @@
 #include "ADM_audiofilter/audio_raw.h"
 
 /* ************* Encoder *********** */
-#if 0 // FIXME_ZAZA
-#ifdef USE_FAAC
-#include "audioencoder_faac.h"
-#endif
-#ifdef HAVE_LIBMP3LAME
-#include "audioencoder_lame.h"
-#endif
-#ifdef USE_VORBIS
-#include "audioencoder_vorbis.h"
-#endif
-#ifdef USE_AFTEN
-#include "audioencoder_aften.h"
-#endif
 
-#include "audioencoder_twolame.h"
-#include "audioencoder_lavcodec.h"
-#endif
-
 #include "ADM_audiocodec/ADM_audiocodeclist.h"
-#include "audioencoder_pcm.h"
 
+
 #include "prefs.h"
 
 

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audiofilter_mixer.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audiofilter_mixer.cpp	2008-07-16 17:41:02 UTC (rev 4237)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audiofilter_mixer.cpp	2008-07-16 17:41:05 UTC (rev 4238)
@@ -14,7 +14,7 @@
 
 #include "ADM_default.h"
 
-#include "audioeng_process.h"
+#include "ADM_audioFilter.h"
 #include "audiofilter_mixer.h"
 #include "audiofilter_dolby.h"
 #include <math.h>

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audiofilter_sox.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audiofilter_sox.cpp	2008-07-16 17:41:02 UTC (rev 4237)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audiofilter_sox.cpp	2008-07-16 17:41:05 UTC (rev 4238)
@@ -21,7 +21,7 @@
 
 #include "ADM_default.h"
 
-#include "audioeng_process.h"
+#include "ADM_audioFilter.h"
 #include "audiofilter_sox.h"
 
 AUDMAudioFilterSox::AUDMAudioFilterSox(AUDMAudioFilter *instream,uint32_t  tgt):AUDMAudioFilter (instream)

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_toolkit/automation.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_toolkit/automation.cpp	2008-07-16 17:41:02 UTC (rev 4237)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_toolkit/automation.cpp	2008-07-16 17:41:05 UTC (rev 4238)
@@ -385,31 +385,22 @@
 }
 void call_audiocodec(char *p)
 {
-#define FIXME_ZAZA
-#if 0
 	if(!strcasecmp(p,"MP2"))
-		audioCodecSetcodec( AUDIOENC_MP2 );
+		audio_selectCodecByTag(WAV_MP2);
 	else if(!strcasecmp(p,"AC3"))
-		audioCodecSetcodec( AUDIOENC_AC3 );
-#ifdef HAVE_LIBMP3LAME		
+		audio_selectCodecByTag( WAV_AC3 );
 	else if(!strcasecmp(p,"MP3"))
-		 audioCodecSetcodec( AUDIOENC_MP3 );
-#endif
-	else if(!strcasecmp(p,"NONE"))
-		audioCodecSetcodec( AUDIOENC_NONE );
-	else if(!strcasecmp(p,"TWOLAME"))
-		audioCodecSetcodec( AUDIOENC_2LAME );		
-#ifdef USE_VORBIS		
+		 audio_selectCodecByTag( WAV_MP3 );
+	else if(!strcasecmp(p,"PCM"))
+		audio_selectCodecByTag( WAV_PCM );
 	else if(!strcasecmp(p,"VORBIS"))
-		audioCodecSetcodec( AUDIOENC_VORBIS );		
-#endif		
+		audioCodecSetcodec( WAV_OGG );		
 	else if(!strcasecmp(p,"COPY"))
-		audioCodecSetcodec( AUDIOENC_COPY );		
+		audioCodecChanged( AUDIOENC_COPY );		
 	else{
-		audioCodecSetcodec( AUDIOENC_NONE );
+		audio_selectCodecByTag( WAV_PCM );
 		fprintf(stderr,"audio codec \"%s\" unknown.\n",p);
 	}
-#endif
 }
 void call_probePat(char *p)
 {

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_GTK/ADM_gui2/GUI_bindings.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_GTK/ADM_gui2/GUI_bindings.cpp	2008-07-16 17:41:02 UTC (rev 4237)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_GTK/ADM_gui2/GUI_bindings.cpp	2008-07-16 17:41:05 UTC (rev 4238)
@@ -515,7 +515,7 @@
                         gtk_combo_box_append_text      (combo_box,QT_TR_NOOP(name));	
                 }
         gtk_combo_box_set_active(combo_box,0);
-// FIXME_ZAZA	on_audio_change();
+        on_audio_change();
         /*   Fill in output format window */
         uint32_t nbFormat;
 

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_commonUI/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_commonUI/CMakeLists.txt	2008-07-16 17:41:02 UTC (rev 4237)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_commonUI/CMakeLists.txt	2008-07-16 17:41:05 UTC (rev 4238)
@@ -1,7 +1,6 @@
 SET(ADM_LIB ADM_commonUI)
 
 SET(${ADM_LIB}_SRCS
-DIA_audioconfig.cpp   
 DIA_DVDff.cpp           
 DIA_mjpeg.cpp     
 DIA_resizeWiz.cpp  

Deleted: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_audioconfig.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_audioconfig.cpp	2008-07-16 17:41:02 UTC (rev 4237)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_audioconfig.cpp	2008-07-16 17:41:05 UTC (rev 4238)
@@ -1,60 +0,0 @@
-/***************************************************************************
-                          DIA_audioConfig.cpp
-  
-  (C) Mean 2007 fixounet at free.fr
-
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-#include "config.h"
-#include "ADM_default.h"
-
-#include "DIA_factory.h"
-#include "ADM_coreAudio/include/audioencoder.h"
-
-/**
-      \fn DIA_defaultSettings
-      \brief Dialog to set lame settings
-      @return 1 on success, 0 on failure
-
-*/
-#if FIXME_ZAZA
-int DIA_defaultSettings(ADM_audioEncoderDescriptor *descriptor)
-  {
-
-    int ret=0;
-    char string[400];
-    uint32_t mmode,ppreset;
-#define SZT(x) sizeof(x)/sizeof(diaMenuEntry )
-#define BITRATE(x) {x,QT_TR_NOOP(#x)}
-    diaMenuEntry bitrateM[]={
-                              BITRATE(56),
-                              BITRATE(64),
-                              BITRATE(80),
-                              BITRATE(96),
-                              BITRATE(112),
-                              BITRATE(128),
-                              BITRATE(160),
-                              BITRATE(192),
-                              BITRATE(224),
-                              BITRATE(384)
-                          };
-    diaElemMenu bitrate(&(descriptor->bitrate),   QT_TR_NOOP("_Bitrate:"), SZT(bitrateM),bitrateM);
-  
-      diaElem *elems[]={&bitrate};
-    
-  return ( diaFactoryRun(QT_TR_NOOP("Audio Configuration"),1,elems));
-
-    return 0;
-} 
-#endif
-//EOF 
-

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_builtin.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_builtin.cpp	2008-07-16 17:41:02 UTC (rev 4237)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_builtin.cpp	2008-07-16 17:41:05 UTC (rev 4238)
@@ -130,27 +130,9 @@
 	videoFrame.swallow(&tXvid4);
 	videoFrame.swallow(&tX264);
 
-	diaElemFrame audioFrame(QT_TR_NOOP("Audio Codecs"));	
-	diaElemNotch tAften(aften, QT_TR_NOOP("Aften"));	
-	diaElemNotch tLibamrnb(libamrnb, QT_TR_NOOP("amrnb"));
-    diaElemNotch tFaac(faac, QT_TR_NOOP("FAAC"));
-    diaElemNotch tFaad(faad, QT_TR_NOOP("FAAD2"));
-	diaElemNotch tLame(lame, QT_TR_NOOP("LAME"));
-	diaElemNotch tA52dec(a52dec, QT_TR_NOOP("liba52"));
-	diaElemNotch tLibdca(libdca, QT_TR_NOOP("libdca"));
-	diaElemNotch tMad(mad, QT_TR_NOOP("MAD"));
-	diaElemNotch tVorbis(vorbis, QT_TR_NOOP("Vorbis"));
 
-	audioFrame.swallow(&tAften);
-	audioFrame.swallow(&tLibamrnb);	
-	audioFrame.swallow(&tFaac);
-	audioFrame.swallow(&tFaad);
-	audioFrame.swallow(&tLame);
-	audioFrame.swallow(&tA52dec);
-	audioFrame.swallow(&tLibdca);
-	audioFrame.swallow(&tMad);
-	audioFrame.swallow(&tVorbis);
 
+
 	diaElemNotch tArts(arts, QT_TR_NOOP("aRts"));
 	diaElemNotch tEsd(esd, QT_TR_NOOP("ESD"));
         diaElemNotch tFontConfig(adm_fontconfig, QT_TR_NOOP("Fontconfig"));
@@ -167,11 +149,11 @@
 	diaElemNotch tX86_64(x86_64, QT_TR_NOOP("x86-64"));
 
 
-	diaElem *codecElems[] = {&videoFrame, &audioFrame};
+	diaElem *codecElems[] = {&videoFrame};
 	diaElem *libsElems[] = {&tArts, &tEsd, &tFontConfig, &tFreetype, &tGettext, &tAlsa, &tOss, &tSdl, &tXvideo};
 	diaElem *CPUElems[] = {&tAltivec, &tPowerPc, &tX86, &tX86_64};
 
-	diaElemTabs tabCodec(QT_TR_NOOP("Codecs"), 2, codecElems);
+	diaElemTabs tabCodec(QT_TR_NOOP("Codecs"), 1, codecElems);
 	diaElemTabs tabLibs(QT_TR_NOOP("Libraries"), 9, libsElems);
 	diaElemTabs tabCPU(QT_TR_NOOP("CPU"), 4, CPUElems);
 

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/gui_autodrive.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/gui_autodrive.cpp	2008-07-16 17:41:02 UTC (rev 4237)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/gui_autodrive.cpp	2008-07-16 17:41:05 UTC (rev 4238)
@@ -99,16 +99,20 @@
         						}
         				else
         				{
-#ifdef FIXME_ZAZA //HAVE_LIBMP3LAME
-        					audioCodecSetcodec(AUDIOENC_MP3);
-        					audioFilter_SetBitrate(128);
-                                                audioFilter_MP3DisableReservoir(1);
-        					// set fq
-        					
-#else
+                            if(audio_selectCodecByTag(WAV_MP3))
+                            {
+                                    audioFilter_SetBitrate(128);
+                                    if(!audioSetOption("MP3DisableReservoir",1))
+                                    {
         					 GUI_Error_HIG(QT_TR_NOOP("Codec Error"),
+        					        QT_TR_NOOP( "The MP3 codec does not allow disabling reservoir.\nInstall lame plugin"));
+
+                                    }
+        					}else
+        					{
+        					 GUI_Error_HIG(QT_TR_NOOP("Codec Error"),
         					        QT_TR_NOOP( "You don't have LAME!.\nIt is needed to create FLV  video."));
-#endif
+                             }
         					 if(fq==44100 || fq==22050 || fq==11025)
         					         						{}
         					 else
@@ -180,12 +184,11 @@
                     }
                     else
                     {
-#if FIXME_ZAZA //def USE_FAAC
-                          audioCodecSetcodec(AUDIOENC_FAAC);
-#else
-                          GUI_Error_HIG(QT_TR_NOOP("Codec Error"),
+
+
+                          if(!audio_selectCodecByTag(WAV_AAC))
+                            GUI_Error_HIG(QT_TR_NOOP("Codec Error"),
                                         QT_TR_NOOP( "You don't have FAAC!.\nIt is needed to create PSP compatible video."));
-#endif
                                     // ? Needed ?
                           if(currentaudiostream->getInfo()->frequency!=fq)
                           {
@@ -210,7 +213,7 @@
                                 }
                                 else
                                 {
-                                 // FIXME_ZAZA       audioCodecSetcodec(AUDIOENC_2LAME);
+                                        audio_selectCodecByTag(WAV_MP2);
                                         if(currentaudiostream->getInfo()->frequency!=44100)
                                         {
                                                 audioFilterResample(44100);
@@ -240,7 +243,7 @@
                                 }
                                 else
                                 {
-                                       // FIXME_ZAZA audioCodecSetcodec(AUDIOENC_2LAME);
+                                        audio_selectCodecByTag(WAV_MP2);
                                         if(currentaudiostream->getInfo()->frequency!=44100)
                                         {
                                                 audioFilterResample(44100);
@@ -269,7 +272,7 @@
                                         || (currentaudiostream->getInfo()->encoding!=WAV_MP2 &&
                                          currentaudiostream->getInfo()->encoding!=WAV_AC3))
                                 {
-                                       // FIXME_ZAZA audioCodecSetcodec(AUDIOENC_2LAME);
+                                        audio_selectCodecByTag(WAV_MP2);
                                         audioFilterResample(48000);
                                         audioFilter_SetBitrate(160);
                                         if(currentaudiostream->getInfo()->channels!=2)



From mean at mail.berlios.de  Wed Jul 16 19:41:12 2008
From: mean at mail.berlios.de (mean at BerliOS)
Date: Wed, 16 Jul 2008 19:41:12 +0200
Subject: [Avidemux-svn-commit] r4240 -
	branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/lame
Message-ID: <200807161741.m6GHfCup021444@sheep.berlios.de>

Author: mean
Date: 2008-07-16 19:41:11 +0200 (Wed, 16 Jul 2008)
New Revision: 4240

Modified:
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/lame/audioencoder_lame.cpp
Log:
[Lame] Setoption for disable bitrate reservoir


Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/lame/audioencoder_lame.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/lame/audioencoder_lame.cpp	2008-07-16 17:41:08 UTC (rev 4239)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/lame/audioencoder_lame.cpp	2008-07-16 17:41:11 UTC (rev 4240)
@@ -28,7 +28,11 @@
   2,				//uint32_t        quality;
   0,				//uint32_t        disableReservoir; // usefull for strict CBR (FLV)
 };
+extern "C"
+{
 static uint8_t configure (void);
+static uint8_t setOption(const char *paramName, uint32_t value);
+};
 /********************* Declare Plugin *****************************************************/
 ADM_DECLARE_AUDIO_ENCODER_PREAMBLE(AUDMEncoder_Lame);
 
@@ -50,7 +54,7 @@
   getBitrate,           // Defined by macro automatically
   setBitrate,            // Defined by macro automatically 
 
-  NULL,         //** put your own function here**
+  setOption,         //** put your own function here**
 
   NULL
 };
@@ -322,5 +326,17 @@
     }
   return 0;
 }
-
+/**
+     \fn setOption
+     \brief Allow giving codec specific options as string+value
+*/
+uint8_t setOption(const char *paramName, uint32_t value)
+{
+    if(!strcasecmp(paramName,"MP3DisableReservoir"))
+    {
+        myLameParam.disableReservoir=value;
+        return 1;
+    }
+    return 0;
+}
 // EOF



From mean at mail.berlios.de  Wed Jul 16 19:41:10 2008
From: mean at mail.berlios.de (mean at BerliOS)
Date: Wed, 16 Jul 2008 19:41:10 +0200
Subject: [Avidemux-svn-commit] r4239 - in
	branches/avidemux_2.5_branch_gruntster: avidemux
	avidemux/ADM_audiofilter avidemux/ADM_toolkit
	avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog
	plugins/ADM_audioEncoders plugins/ADM_audioEncoders/lavcodec
Message-ID: <200807161741.m6GHfAbr021434@sheep.berlios.de>

Author: mean
Date: 2008-07-16 19:41:08 +0200 (Wed, 16 Jul 2008)
New Revision: 4239

Added:
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/lavcodec/CMakeLists.txt
Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audio_encoderPlugin.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioeng_buildfilters.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_toolkit/automation.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_acodec.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/gui_autodrive.cpp
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/CMakeLists.txt
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/lavcodec/audioencoder_lavcodec.cpp
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/lavcodec/audioencoder_lavcodec.h
Log:
[AudioEncoder] Cleanup


Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audio_encoderPlugin.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audio_encoderPlugin.cpp	2008-07-16 17:41:05 UTC (rev 4238)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audio_encoderPlugin.cpp	2008-07-16 17:41:08 UTC (rev 4239)
@@ -214,7 +214,6 @@
     \fn     
     \brief
 */
-void audioCodecSetcodec(AUDIOENCODER codec);
 uint8_t audioCodecSetByName( const char *name)
 {
 		for(uint32_t i=0;i<ListOfAudioEncoder.size();i++)
@@ -222,7 +221,7 @@
 			if(!strcasecmp(name,ListOfAudioEncoder[i]->codecName))
 			{
 
-				audioCodecSetcodec(i);
+				currentEncoder=i;
 				return 1;
 			}
 
@@ -230,8 +229,17 @@
 		printf("\n Mmmm Select audio codec by name failed...(%s).\n",name);
 		return 0;
 }
+/**
+    \fn audioCodecSetByIndex
+    \brief To be used by UI code only!
+*/
+uint8_t audioCodecSetByIndex(int i)
+{
+    ADM_assert(i<ListOfAudioEncoder.size());
+    currentEncoder=i;
+    return 1;
 
-
+}
 /**
     \fn audioCodecGetName
     \brief Returns the current codec tagname
@@ -255,13 +263,14 @@
       \fn audioCodecSetcodec
       \brief Set & update current audio encoder
 */
+/*
 void audioCodecSetcodec(AUDIOENCODER codec)
 {
 
 	currentEncoder=codec;
 	audioPrintCurrentCodec();
 
-}
+}*/
 /**
     \fn audioCodecSelect
     \brief
@@ -412,6 +421,7 @@
     if(selected!=-1)
     {
         currentEncoder=selected;
+        UI_setAudioCodec( (int)currentEncoder);
         printf("[AudioEncoder] Selected %s for tag %d (%s)\n",ListOfAudioEncoder[currentEncoder],tag,"");
         return 1;
     }
@@ -428,4 +438,15 @@
     return c->setOption(option,value);
 
 }
+/**
+         \fn audio_setCopyCodec
+         \brief Set audio codec to copy
+*/
+uint8_t audio_setCopyCodec(void)
+{
+    currentEncoder=0;
+    return 1;
+
+}
+
 //**

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioeng_buildfilters.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioeng_buildfilters.h	2008-07-16 17:41:05 UTC (rev 4238)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioeng_buildfilters.h	2008-07-16 17:41:08 UTC (rev 4239)
@@ -113,6 +113,8 @@
 uint8_t audio_selectCodecByTag(uint32_t tag);
 void audioCodecChanged(int newcodec);
 uint8_t audioSetOption(const char *option, uint32_t value);
+uint8_t audio_setCopyCodec(void);
+uint8_t audioCodecSetByIndex(int i);
 //
 AUDMEncoder *audioEncoderCreate(AUDMAudioFilter *filter);
 #endif

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_toolkit/automation.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_toolkit/automation.cpp	2008-07-16 17:41:05 UTC (rev 4238)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_toolkit/automation.cpp	2008-07-16 17:41:08 UTC (rev 4239)
@@ -394,7 +394,7 @@
 	else if(!strcasecmp(p,"PCM"))
 		audio_selectCodecByTag( WAV_PCM );
 	else if(!strcasecmp(p,"VORBIS"))
-		audioCodecSetcodec( WAV_OGG );		
+		audio_selectCodecByTag( WAV_OGG );		
 	else if(!strcasecmp(p,"COPY"))
 		audioCodecChanged( AUDIOENC_COPY );		
 	else{

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_acodec.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_acodec.cpp	2008-07-16 17:41:05 UTC (rev 4238)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_acodec.cpp	2008-07-16 17:41:08 UTC (rev 4239)
@@ -10,8 +10,8 @@
 
 extern uint32_t audioEncoderGetNumberOfEncoders(void);
 extern const char  *audioEncoderGetDisplayName(uint32_t i);
+extern uint8_t audioCodecSetByIndex(int i);
 
-
 #define GLADE_HOOKUP_OBJECT(component,widget,name) \
   g_object_set_data_full (G_OBJECT (component), name, \
     gtk_widget_ref (widget), (GDestroyNotify) gtk_widget_unref)
@@ -35,7 +35,7 @@
 		UNUSED_ARG(user_data);
 
 		cur=findCodec();
-		audioCodecSetcodec(cur);
+		audioCodecSetByIndex(cur);
 		audioCodecConfigure();
 
 }

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/gui_autodrive.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/gui_autodrive.cpp	2008-07-16 17:41:05 UTC (rev 4238)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/gui_autodrive.cpp	2008-07-16 17:41:08 UTC (rev 4239)
@@ -54,10 +54,6 @@
         switch(action)
         {
                 case ACT_AUTO_IPOD:
-#if !defined(USE_XVID_4) || !defined(USE_FAAC)
-					GUI_Error_HIG(QT_TR_NOOP("Codec Error"),
-						QT_TR_NOOP( "Xvid4 and FAAC support is required for the iPod profile."));
-#else
 					if(!setIPOD())
 						return 0;
 
@@ -68,21 +64,27 @@
 						GUI_Error_HIG(QT_TR_NOOP("Codec Error"),QT_TR_NOOP( "Cannot select the MPEG-4 SP codec."));
 						return 0;
 					}
-					setIpod_Xvid4Preset();
+                    GUI_Info_HIG(ADM_LOG_INFO,"CODE DISABLED","XVID4 PROFILE FOR IPOD");
+					//setIpod_Xvid4Preset();
 					// Set mode & bitrate
 					setVideoEncoderSettings(COMPRESS_CBR,400,0,NULL);
 					// Audio Codec
 					if((currentaudiostream->getInfo()->channels == 2)&& currentaudiostream->getInfo()->encoding == WAV_AAC)
-						audioCodecSetcodec(AUDIOENC_COPY);
+						audio_setCopyCodec();
 					else
 					{
-						audioCodecSetcodec(AUDIOENC_FAAC);
-						audioFilter_SetBitrate(128);
+						if(audio_selectCodecByTag(WAV_AAC))
+                        {
+                            GUI_Error_HIG(QT_TR_NOOP("Codec Error"),QT_TR_NOOP( "No AAC audio encoder plugin found."));
+                        }else
+                        {
+                            audioFilter_SetBitrate(128);
 
-						if (currentaudiostream->getInfo()->channels != 2)
-							setCurrentMixerFromString("STEREO");
+                            if (currentaudiostream->getInfo()->channels != 2)
+                                setCurrentMixerFromString("STEREO");
+                        }
 					}
-#endif
+
                       break;
 //******************************** IPOD *******************************
                           
@@ -95,7 +97,7 @@
         				fq=currentaudiostream->getInfo()->frequency;
         				if(currentaudiostream->getInfo()->encoding==WAV_MP3 && (fq==44100 || fq==22050 || fq==11025))
         						{
-        	                		audioCodecSetcodec(AUDIOENC_COPY);
+        	                		audio_setCopyCodec();
         						}
         				else
         				{
@@ -180,7 +182,7 @@
                         (currentaudiostream->getInfo()->channels==2)&&
                         (currentaudiostream->getInfo()->encoding==WAV_AAC))
                     {
-                        audioCodecSetcodec(AUDIOENC_COPY);
+                        audio_setCopyCodec();
                     }
                     else
                     {
@@ -209,7 +211,7 @@
                                                 (currentaudiostream->getInfo()->encoding==WAV_MP2)&&
                                                         (currentaudiostream->getInfo()->byterate==28000))
                                 {
-                                        audioCodecSetcodec(AUDIOENC_COPY);
+                                        audio_setCopyCodec();
                                 }
                                 else
                                 {
@@ -239,7 +241,7 @@
                                         (currentaudiostream->getInfo()->channels==2)&&
                                                 (currentaudiostream->getInfo()->encoding==WAV_MP2))
                                 {
-                                        audioCodecSetcodec(AUDIOENC_COPY);
+                                        audio_setCopyCodec();
                                 }
                                 else
                                 {
@@ -285,7 +287,7 @@
                                 }
                                 else
                                 {
-                                        audioCodecSetcodec(AUDIOENC_COPY);
+                                        audio_setCopyCodec();
                                 }
                                 break;
 

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/CMakeLists.txt	2008-07-16 17:41:05 UTC (rev 4238)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/CMakeLists.txt	2008-07-16 17:41:08 UTC (rev 4239)
@@ -11,6 +11,7 @@
 
 ADD_SUBDIRECTORY(twolame)
 ADD_SUBDIRECTORY(pcm)
+ADD_SUBDIRECTORY(lavcodec)
 
 if(USE_LAME)
 ADD_SUBDIRECTORY(lame)

Added: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/lavcodec/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/lavcodec/CMakeLists.txt	2008-07-16 17:41:05 UTC (rev 4238)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/lavcodec/CMakeLists.txt	2008-07-16 17:41:08 UTC (rev 4239)
@@ -0,0 +1,20 @@
+	INCLUDE(ae_plugin)
+        INCLUDE_DIRECTORIES("${CMAKE_SOURCE_DIR}/../avidemux/")
+        INCLUDE_DIRECTORIES("${CMAKE_SOURCE_DIR}/../avidemux/ADM_libraries/ADM_ffmpeg/ADM_lavcodec/")
+        INCLUDE_DIRECTORIES("${CMAKE_SOURCE_DIR}/../avidemux/ADM_libraries/ADM_ffmpeg/ADM_lavutil/")
+
+	SET(ADM_ae_lav_mp2_SRCS audioencoder_lavcodec.cpp)
+
+	ADD_LIBRARY(ADM_ae_lav_mp2 SHARED ${ADM_ae_lav_mp2_SRCS})
+	ADD_TARGET_CFLAGS(ADM_ae_lav_mp2 "-DADM_LAV_MP2")
+
+	INIT_AUDIO_ENCODER(ADM_ae_lav_mp2)
+	INSTALL_AUDIOENCODER(ADM_ae_lav_mp2)
+
+	SET(ADM_ae_lav_ac3_SRCS audioencoder_lavcodec.cpp)
+
+	ADD_LIBRARY(ADM_ae_lav_ac3 SHARED ${ADM_ae_lav_ac3_SRCS})
+	ADD_TARGET_CFLAGS(ADM_ae_lav_ac3 "-DADM_LAV_AC3")
+
+	INIT_AUDIO_ENCODER(ADM_ae_lav_ac3)
+	INSTALL_AUDIOENCODER(ADM_ae_lav_ac3)

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/lavcodec/audioencoder_lavcodec.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/lavcodec/audioencoder_lavcodec.cpp	2008-07-16 17:41:05 UTC (rev 4238)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/lavcodec/audioencoder_lavcodec.cpp	2008-07-16 17:41:08 UTC (rev 4239)
@@ -16,37 +16,76 @@
  *                                                                         *
  ***************************************************************************/
 
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <math.h>
-
 #include "ADM_default.h"
-
+#include "DIA_factory.h"
+#include "DIA_coreToolkit.h"
+#include <lame/lame.h>
 #include "audioencoder.h"
+#include "audioencoderInternal.h"
 //
 #include "audioencoder_lavcodec.h"
 
 #include "ADM_lavcodec.h"
 
-#include "ADM_osSupport/ADM_debugID.h"
-#define MODULE_NAME MODULE_AUDIO_FILTER
-#include "ADM_osSupport/ADM_debug.h"
+typedef struct 
+{
+    uint32_t bitrate;
+}LavAudioEncoder_PARAM;
+static LavAudioEncoder_PARAM lavConfig={128};
+static uint8_t configure (void);
+/********************* Declare Plugin *****************************************************/
+ADM_DECLARE_AUDIO_ENCODER_PREAMBLE(AUDMEncoder_Lavcodec);
 
+static ADM_audioEncoder encoderDesc = { 
+  ADM_AUDIO_ENCODER_API_VERSION,
+  create,			// Defined by macro automatically
+  destroy,			// Defined by macro automatically
+  configure,		//** put your own function here**
+#ifdef ADM_LAV_MP2      
+  "LavMP2",            
+  "MP2 (lav)",      
+  "MP2 LavCodec encoder plugin Mean 2008",             
+  2,                    // Max channels
+  1,0,0,                // Version
+  WAV_MP2,
+#else
+ "LavAC3",            
+  "AC3 (lav)",      
+  "AC3 LavEncoder encoder plugin Mean 2008",             
+  6,                    // Max channels
+  1,0,0,                // Version
+  WAV_AC3,
+#endif
+  100,                  // Priority
+  getConfigurationData,  // Defined by macro automatically
+  setConfigurationData,  // Defined by macro automatically
 
+  getBitrate,           // Defined by macro automatically
+  setBitrate,            // Defined by macro automatically 
+
+  NULL,         //** put your own function here**
+
+  NULL
+};
+ADM_DECLARE_AUDIO_ENCODER_CONFIG(lavConfig);
+
+/******************* / Declare plugin*******************************************************/
 #define CONTEXT ((AVCodecContext  	*)_context)
 
 
 // Ctor: Duplicate
 //__________
 
-AUDMEncoder_Lavcodec::AUDMEncoder_Lavcodec(uint32_t fourcc,AUDMAudioFilter * instream)  :AUDMEncoder    (instream)
+AUDMEncoder_Lavcodec::AUDMEncoder_Lavcodec(AUDMAudioFilter * instream)  :AUDMEncoder    (instream)
 {
-  _fourcc=fourcc;
-  if(_fourcc!=WAV_MP2 && _fourcc!=WAV_AC3) ADM_assert(0);
+  
   _context=NULL;
-  _wavheader->encoding=_fourcc;
-  printf("[Lavcodec] Creating Lavcodec\n");
+#ifdef ADM_LAV_MP2     
+  _wavheader->encoding=WAV_MP2;
+#else
+    _wavheader->encoding=WAV_AC3;
+#endif
+  printf("[Lavcodec] Creating Lavcodec audio encoder\n");
 };
 
 
@@ -65,38 +104,43 @@
 //________________________________________________
 //   Init lame encoder
 //_______________________________________________
-uint8_t AUDMEncoder_Lavcodec::init(ADM_audioEncoderDescriptor *config)
+uint8_t AUDMEncoder_Lavcodec::initialize(void)
 {
   int ret;
   _context=( void *)avcodec_alloc_context();
-  _wavheader->byterate=(config->bitrate*1000)>>3;
+  _wavheader->byterate=(lavConfig.bitrate*1000)>>3;
 
-      
-  if(_fourcc==WAV_MP2 && _incoming->getInfo()->channels>2)
+#ifdef ADM_LAV_MP2      
+  if( _incoming->getInfo()->channels>2)
   {
     printf("[Lavcodec]Too many channels\n");
     return 0; 
   }
-  _wavheader->byterate=(config->bitrate*1000)>>3;         
+#endif
+  _wavheader->byterate=(lavConfig.bitrate*1000)>>3;         
       
-  if(_fourcc==WAV_MP2)
+#ifdef ADM_LAV_MP2 
     _chunk = 1152*_wavheader->channels;
-  else
+#else
     _chunk = 1536*_wavheader->channels; // AC3
-
+#endif
   printf("[Lavcodec]Incoming : fq : %lu, channel : %lu bitrate: %lu \n",
-         _wavheader->frequency,_wavheader->channels,config->bitrate);
+         _wavheader->frequency,_wavheader->channels,lavConfig.bitrate);
   
   
   CONTEXT->channels     =  _wavheader->channels;
   CONTEXT->sample_rate  =  _wavheader->frequency;
-  CONTEXT->bit_rate     = (config->bitrate*1000); // bits -> kbits
+  CONTEXT->bit_rate     = (lavConfig.bitrate*1000); // bits -> kbits
 
   AVCodec *codec;
   CodecID codecID;
-  
-  if(_fourcc==WAV_MP2) codecID=CODEC_ID_MP2;
-        else codecID=CODEC_ID_AC3;
+#ifdef ADM_LAV_MP2  
+  printf("[LavAudio] Mp2 encoder\n"); 
+  codecID=CODEC_ID_MP2;
+#else
+  printf("[LavAudio] Ac3 encoder\n"); 
+  codecID=CODEC_ID_AC3;
+#endif
   codec = avcodec_find_encoder(codecID);
   ADM_assert(codec);
   
@@ -143,5 +187,37 @@
   *len=nbout;
   return 1;
 }
+#define SZT(x) sizeof(x)/sizeof(diaMenuEntry )
+#define BITRATE(x) {x,QT_TR_NOOP(#x)}
 
+/**
+    \fn configure
+*/
+uint8_t configure (void)
+{
+ int ret=0;
+
+    diaMenuEntry bitrateM[]={
+                              BITRATE(56),
+                              BITRATE(64),
+                              BITRATE(80),
+                              BITRATE(96),
+                              BITRATE(112),
+                              BITRATE(128),
+                              BITRATE(160),
+                              BITRATE(192),
+                              BITRATE(224),
+                              BITRATE(384)
+                          };
+    diaElemMenu bitrate(&(lavConfig.bitrate),   QT_TR_NOOP("_Bitrate:"), SZT(bitrateM),bitrateM);
+  
+    
+
+    diaElem *elems[]={&bitrate};
+    
+    return ( diaFactoryRun(QT_TR_NOOP("Aften Configuration"),1,elems));
+    
+}	
 // EOF
+
+// EOF

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/lavcodec/audioencoder_lavcodec.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/lavcodec/audioencoder_lavcodec.h	2008-07-16 17:41:05 UTC (rev 4238)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/lavcodec/audioencoder_lavcodec.h	2008-07-16 17:41:08 UTC (rev 4239)
@@ -20,13 +20,13 @@
   protected:
    
     void              *_context;
-    uint32_t          _fourcc;
+    
          
   public:
-//            uint8_t     init(ADM_audioEncoderDescriptor *config);
+            uint8_t     initialize(void);
    virtual             ~AUDMEncoder_Lavcodec();
-                        AUDMEncoder_Lavcodec(uint32_t fourcc,AUDMAudioFilter *instream);	
-   virtual uint8_t	getPacket(uint8_t *dest, uint32_t *len, uint32_t *samples);
+                        AUDMEncoder_Lavcodec(AUDMAudioFilter *instream);	
+   virtual uint8_t	    getPacket(uint8_t *dest, uint32_t *len, uint32_t *samples);
 };
 
 #endif



From gruntster at mail.berlios.de  Wed Jul 16 21:07:48 2008
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Wed, 16 Jul 2008 21:07:48 +0200
Subject: [Avidemux-svn-commit] r4241 - in
	branches/avidemux_2.5_branch_gruntster:
	avidemux/ADM_coreAudio/src cmake plugins/ADM_audioDevices/Sdl
	plugins/ADM_audioDevices/Win32 plugins/ADM_audioEncoders/aften
	plugins/ADM_audioEncoders/faac plugins/ADM_audioEncoders/lame
	plugins/ADM_audioEncoders/lavcodec plugins/ADM_audioEncoders/pcm
	plugins/ADM_audioEncoders/twolame plugins/ADM_audioEncoders/vorbis
Message-ID: <200807161907.m6GJ7mOn031613@sheep.berlios.de>

Author: gruntster
Date: 2008-07-16 21:07:37 +0200 (Wed, 16 Jul 2008)
New Revision: 4241

Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/src/CMakeLists.txt
   branches/avidemux_2.5_branch_gruntster/cmake/admCheckAudioEncoderLibs.cmake
   branches/avidemux_2.5_branch_gruntster/cmake/admConfigSummary.cmake
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Sdl/CMakeLists.txt
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Win32/CMakeLists.txt
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/aften/CMakeLists.txt
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/faac/CMakeLists.txt
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/lame/CMakeLists.txt
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/lavcodec/CMakeLists.txt
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/pcm/CMakeLists.txt
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/twolame/CMakeLists.txt
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/vorbis/CMakeLists.txt
Log:
[Plugins] Win32 compilation fixes

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/src/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/src/CMakeLists.txt	2008-07-16 17:41:11 UTC (rev 4240)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/src/CMakeLists.txt	2008-07-16 19:07:37 UTC (rev 4241)
@@ -5,5 +5,6 @@
 )	
 ADD_LIBRARY(ADM_coreAudio SHARED ${ADMaudioCore_SRCS})
 INCLUDE_DIRECTORIES(${CMAKE_SOURCE_DIR}/avidemux/ADM_coreAudio/include)
+TARGET_LINK_LIBRARIES(ADM_coreAudio ADM_core)
 
 INSTALL(TARGETS ADM_coreAudio RUNTIME DESTINATION ${BIN_DIR}  LIBRARY DESTINATION lib  ARCHIVE DESTINATION lib)

Modified: branches/avidemux_2.5_branch_gruntster/cmake/admCheckAudioEncoderLibs.cmake
===================================================================
--- branches/avidemux_2.5_branch_gruntster/cmake/admCheckAudioEncoderLibs.cmake	2008-07-16 17:41:11 UTC (rev 4240)
+++ branches/avidemux_2.5_branch_gruntster/cmake/admCheckAudioEncoderLibs.cmake	2008-07-16 19:07:37 UTC (rev 4241)
@@ -17,7 +17,7 @@
 			TRY_RUN(AFTEN_TEST_RUN_RESULT
 				AFTEN_TEST_COMPILE_RESULT
 				${CMAKE_BINARY_DIR}
-				"${CMAKE_SOURCE_DIR}/cmake_compile_check/aften_check.cpp"
+				"${AVIDEMUX_SOURCE_DIR}/cmake_compile_check/aften_check.cpp"
 				CMAKE_FLAGS "-DINCLUDE_DIRECTORIES=${AFTEN_INCLUDE_DIR}" "-DLINK_LIBRARIES=${AFTEN_LIBRARY_DIR}")
 		ENDIF (NOT DEFINED AFTEN_TEST_RUN_RESULT)
 

Modified: branches/avidemux_2.5_branch_gruntster/cmake/admConfigSummary.cmake
===================================================================
--- branches/avidemux_2.5_branch_gruntster/cmake/admConfigSummary.cmake	2008-07-16 17:41:11 UTC (rev 4240)
+++ branches/avidemux_2.5_branch_gruntster/cmake/admConfigSummary.cmake	2008-07-16 19:07:37 UTC (rev 4241)
@@ -31,9 +31,9 @@
 #ADM_DISPLAY("OSS       " "${OSS_SUPPORT}" "${OSS_CAPABLE}")
 #ADM_DISPLAY("SRC       " "${USE_SRC}" "${JACK_CAPABLE}")
 
-IF (WIN32)
-	ADM_DISPLAY("Win32     " 1)
-ENDIF (WIN32)
+#IF (WIN32)
+#	ADM_DISPLAY("Win32     " 1)
+#ENDIF (WIN32)
 
 MESSAGE("*** Miscellaneous ***")
 ADM_DISPLAY("gettext   " "${HAVE_GETTEXT}")

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Sdl/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Sdl/CMakeLists.txt	2008-07-16 17:41:11 UTC (rev 4240)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Sdl/CMakeLists.txt	2008-07-16 19:07:37 UTC (rev 4241)
@@ -4,7 +4,7 @@
 SET(ADM_av_sdl_SRCS ADM_deviceSDL.cpp)
 
 ADD_LIBRARY(ADM_av_sdl SHARED ${ADM_av_sdl_SRCS})
-TARGET_LINK_LIBRARIES(ADM_av_sdl ADM_core ${SDL_LIBRARY})
+TARGET_LINK_LIBRARIES(ADM_av_sdl ADM_core ADM_coreAudio ${SDL_LIBRARY})
 SDLify(ADM_deviceSDL.cpp)
 
 INIT_AUDIO_DEVICE(ADM_av_sdl)

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Win32/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Win32/CMakeLists.txt	2008-07-16 17:41:11 UTC (rev 4240)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Win32/CMakeLists.txt	2008-07-16 19:07:37 UTC (rev 4241)
@@ -4,6 +4,6 @@
 SET(ADM_av_win32_SRCS ADM_deviceWin32.cpp)
 
 ADD_LIBRARY(ADM_av_win32 SHARED ${ADM_av_win32_SRCS})
-TARGET_LINK_LIBRARIES(ADM_av_win32 "-lwinmm -lADM_core")
+TARGET_LINK_LIBRARIES(ADM_av_win32 winmm ADM_core ADM_coreAudio)
 INIT_AUDIO_DEVICE(ADM_av_win32)
 INSTALL_AUDIODEVICE(ADM_av_win32)

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/aften/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/aften/CMakeLists.txt	2008-07-16 17:41:11 UTC (rev 4240)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/aften/CMakeLists.txt	2008-07-16 19:07:37 UTC (rev 4241)
@@ -4,7 +4,7 @@
 
 	ADD_LIBRARY(ADM_ae_aften SHARED ${ADM_ae_aften_SRCS})
 
-	TARGET_LINK_LIBRARIES(ADM_ae_aften ${AFTEN_LIBRARY_DIR})
+	TARGET_LINK_LIBRARIES(ADM_ae_aften ${AFTEN_LIBRARY_DIR} ADM_core ADM_coreAudio ADM_coreUI)
 
 	ADD_TARGET_CFLAGS(ADM_ae_aften "-I${AFTEN_INCLUDE_DIR}")
 

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/faac/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/faac/CMakeLists.txt	2008-07-16 17:41:11 UTC (rev 4240)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/faac/CMakeLists.txt	2008-07-16 19:07:37 UTC (rev 4241)
@@ -4,7 +4,7 @@
 
 	ADD_LIBRARY(ADM_ae_faac SHARED ${ADM_ae_faac_SRCS})
 
-	TARGET_LINK_LIBRARIES(ADM_ae_faac ${FAAC_LIBRARY_DIR})
+	TARGET_LINK_LIBRARIES(ADM_ae_faac ${FAAC_LIBRARY_DIR} ADM_core ADM_coreAudio ADM_coreUI)
 
 	ADD_TARGET_CFLAGS(ADM_ae_faac "-I${FAAC_INCLUDE_DIR}")
 

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/lame/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/lame/CMakeLists.txt	2008-07-16 17:41:11 UTC (rev 4240)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/lame/CMakeLists.txt	2008-07-16 19:07:37 UTC (rev 4241)
@@ -4,7 +4,7 @@
 
 	ADD_LIBRARY(ADM_ae_lame SHARED ${ADM_ae_lame_SRCS})
 
-	TARGET_LINK_LIBRARIES(ADM_ae_lame ${LAME_LIBRARY_DIR})
+	TARGET_LINK_LIBRARIES(ADM_ae_lame ${LAME_LIBRARY_DIR} ADM_core ADM_coreAudio ADM_coreUI)
 
 	ADD_TARGET_CFLAGS(ADM_ae_lame "-I${LAME_INCLUDE_DIR}")
 

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/lavcodec/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/lavcodec/CMakeLists.txt	2008-07-16 17:41:11 UTC (rev 4240)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/lavcodec/CMakeLists.txt	2008-07-16 19:07:37 UTC (rev 4241)
@@ -7,6 +7,7 @@
 
 	ADD_LIBRARY(ADM_ae_lav_mp2 SHARED ${ADM_ae_lav_mp2_SRCS})
 	ADD_TARGET_CFLAGS(ADM_ae_lav_mp2 "-DADM_LAV_MP2")
+	TARGET_LINK_LIBRARIES(ADM_ae_lav_mp2 ADM_core ADM_coreAudio ADM_coreUI ADM_libavcodec)
 
 	INIT_AUDIO_ENCODER(ADM_ae_lav_mp2)
 	INSTALL_AUDIOENCODER(ADM_ae_lav_mp2)
@@ -15,6 +16,7 @@
 
 	ADD_LIBRARY(ADM_ae_lav_ac3 SHARED ${ADM_ae_lav_ac3_SRCS})
 	ADD_TARGET_CFLAGS(ADM_ae_lav_ac3 "-DADM_LAV_AC3")
+	TARGET_LINK_LIBRARIES(ADM_ae_lav_ac3 ADM_core ADM_coreAudio ADM_coreUI ADM_libavcodec)
 
 	INIT_AUDIO_ENCODER(ADM_ae_lav_ac3)
 	INSTALL_AUDIOENCODER(ADM_ae_lav_ac3)

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/pcm/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/pcm/CMakeLists.txt	2008-07-16 17:41:11 UTC (rev 4240)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/pcm/CMakeLists.txt	2008-07-16 19:07:37 UTC (rev 4241)
@@ -3,7 +3,7 @@
 	SET(ADM_ae_pcm_SRCS audioencoder_pcm.cpp)
 
 	ADD_LIBRARY(ADM_ae_pcm SHARED ${ADM_ae_pcm_SRCS})
+	TARGET_LINK_LIBRARIES(ADM_ae_pcm ADM_core ADM_coreAudio)
 
-
 	INIT_AUDIO_ENCODER(ADM_ae_pcm)
 	INSTALL_AUDIOENCODER(ADM_ae_pcm)

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/twolame/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/twolame/CMakeLists.txt	2008-07-16 17:41:11 UTC (rev 4240)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/twolame/CMakeLists.txt	2008-07-16 19:07:37 UTC (rev 4241)
@@ -5,7 +5,7 @@
 
 	ADD_LIBRARY(ADM_ae_twolame SHARED ${ADM_ae_twolame_SRCS})
 
-	TARGET_LINK_LIBRARIES(ADM_ae_twolame ADM_libtwolame)
+	TARGET_LINK_LIBRARIES(ADM_ae_twolame ADM_libtwolame ADM_core ADM_coreAudio ADM_coreUI)
         include_directories(ADM_libtwolame)
 
 

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/vorbis/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/vorbis/CMakeLists.txt	2008-07-16 17:41:11 UTC (rev 4240)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/vorbis/CMakeLists.txt	2008-07-16 19:07:37 UTC (rev 4241)
@@ -4,7 +4,7 @@
 
 	ADD_LIBRARY(ADM_ae_vorbis SHARED ${ADM_ae_vorbis_SRCS})
 
-	TARGET_LINK_LIBRARIES(ADM_ae_vorbis ${VORBIS_LIBRARY_DIR} ${VORBISENC_LIBRARY_DIR})
+	TARGET_LINK_LIBRARIES(ADM_ae_vorbis ${VORBIS_LIBRARY_DIR} ${VORBISENC_LIBRARY_DIR} ADM_core ADM_coreAudio ADM_coreUI)
 
 	ADD_TARGET_CFLAGS(ADM_ae_vorbis "-I${VORBIS_INCLUDE_DIR}")
 



From gruntster at mail.berlios.de  Fri Jul 18 17:04:44 2008
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Fri, 18 Jul 2008 17:04:44 +0200
Subject: [Avidemux-svn-commit] r4242 -
	branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_utilities
Message-ID: <200807181504.m6IF4i09022633@sheep.berlios.de>

Author: gruntster
Date: 2008-07-18 17:04:22 +0200 (Fri, 18 Jul 2008)
New Revision: 4242

Modified:
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_utilities/avifmt.h
Log:
[Win32] fix size of AVI stream header

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_utilities/avifmt.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_utilities/avifmt.h	2008-07-16 19:07:37 UTC (rev 4241)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_utilities/avifmt.h	2008-07-18 15:04:22 UTC (rev 4242)
@@ -21,17 +21,6 @@
 #define HIWORD(l)              ((uint16_t)((uint32_t)(l) >> 16))
 
 #define MAKELONG(low,high)     ((int32_t)(((uint16_t)(low)) | (((uint32_t)((uint16_t)(high))) << 16)))
-
-
-
-typedef struct __attribute__((__packed__))
-{
-    int16_t	left;
-    int16_t	top;
-    int16_t	right;
-    int16_t	bottom;
-} RECT, *PRECT, *LPRECT;
-
 #endif
 
 #endif // __WINE_WINDEF_H
@@ -215,20 +204,25 @@
 
 typedef struct  __attribute__((__packed__))
 {
-    uint32_t	fccType;
-    uint32_t	fccHandler;
-    int32_t	dwFlags;	/* Contains AVITF_* flags */
-    int16_t	wPriority;	/* dwPriority - splited for audio */
-    int16_t	wLanguage;
-    int32_t	dwInitialFrames;
-    int32_t	dwScale;
-    int32_t	dwRate;		/* dwRate / dwScale == samples/second */
-    int32_t	dwStart;
-    int32_t	dwLength;	/* In units above... */
-    int32_t	dwSuggestedBufferSize;
-    int32_t	dwQuality;
-    int32_t	dwSampleSize;
-    RECT	rcFrame;
+	uint32_t	fccType;
+	uint32_t	fccHandler;
+	int32_t	dwFlags;	/* Contains AVITF_* flags */
+	int16_t	wPriority;	/* dwPriority - splited for audio */
+	int16_t	wLanguage;
+	int32_t	dwInitialFrames;
+	int32_t	dwScale;
+	int32_t	dwRate;		/* dwRate / dwScale == samples/second */
+	int32_t	dwStart;
+	int32_t	dwLength;	/* In units above... */
+	int32_t	dwSuggestedBufferSize;
+	int32_t	dwQuality;
+	int32_t	dwSampleSize;
+	struct {
+		int16_t left;
+		int16_t top;
+		int16_t right;
+		int16_t bottom;
+	} rcFrame;
 } AVIStreamHeader;
 
 /* Flags for index */



From gruntster at mail.berlios.de  Fri Jul 18 17:08:53 2008
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Fri, 18 Jul 2008 17:08:53 +0200
Subject: [Avidemux-svn-commit] r4243 - in
	branches/avidemux_2.4_branch/platforms/windows/build_scripts:
	. avidemux_2.4
Message-ID: <200807181508.m6IF8rJ0022983@sheep.berlios.de>

Author: gruntster
Date: 2008-07-18 17:08:47 +0200 (Fri, 18 Jul 2008)
New Revision: 4243

Modified:
   branches/avidemux_2.4_branch/platforms/windows/build_scripts/Set Common Environment Variables.bat
   branches/avidemux_2.4_branch/platforms/windows/build_scripts/avidemux_2.4/2a. Update Notes.bat
Log:
[Win32] tweak build scripts

Modified: branches/avidemux_2.4_branch/platforms/windows/build_scripts/Set Common Environment Variables.bat
===================================================================
--- branches/avidemux_2.4_branch/platforms/windows/build_scripts/Set Common Environment Variables.bat	2008-07-18 15:04:22 UTC (rev 4242)
+++ branches/avidemux_2.4_branch/platforms/windows/build_scripts/Set Common Environment Variables.bat	2008-07-18 15:08:47 UTC (rev 4243)
@@ -68,7 +68,7 @@
 	goto error
 )
 
-set PATH=%cmakeDir%;%mingwDir%\bin;%usrLocalDir%\bin;%msysDir%\bin;%qtDir%\bin;%PATH%
+set PATH=%cmakeDir%;%mingwDir%\bin;%usrLocalDir%\bin;%qtDir%\bin;%PATH%
 
 goto end
 

Modified: branches/avidemux_2.4_branch/platforms/windows/build_scripts/avidemux_2.4/2a. Update Notes.bat
===================================================================
--- branches/avidemux_2.4_branch/platforms/windows/build_scripts/avidemux_2.4/2a. Update Notes.bat	2008-07-18 15:04:22 UTC (rev 4242)
+++ branches/avidemux_2.4_branch/platforms/windows/build_scripts/avidemux_2.4/2a. Update Notes.bat	2008-07-18 15:08:47 UTC (rev 4243)
@@ -3,6 +3,7 @@
 call "Set Avidemux 2.4 Environment Variables"
 if errorlevel 1 goto error
 
+set PATH=%msysDir%\bin;%PATH%
 set curDir=%CD%
 
 echo -- Generating Change Log.html --



From mean at mail.berlios.de  Sat Jul 19 18:01:00 2008
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sat, 19 Jul 2008 18:01:00 +0200
Subject: [Avidemux-svn-commit] r4244 -
	branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter
Message-ID: <200807191601.m6JG10c1024315@sheep.berlios.de>

Author: mean
Date: 2008-07-19 18:00:59 +0200 (Sat, 19 Jul 2008)
New Revision: 4244

Added:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioEncoderApi.h
Log:
[AudioFilter] Cleanup, removed deprecated func, split headers


Added: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioEncoderApi.h
===================================================================



From mean at mail.berlios.de  Sat Jul 19 18:01:04 2008
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sat, 19 Jul 2008 18:01:04 +0200
Subject: [Avidemux-svn-commit] r4245 - in
	branches/avidemux_2.5_branch_gruntster/avidemux: .
	ADM_audioEncoder ADM_audioEncoder/include
	ADM_audioEncoder/src ADM_audiofilter ADM_script ADM_toolkit
	ADM_userInterfaces/ADM_QT4/ADM_dialog
Message-ID: <200807191601.m6JG14kp024368@sheep.berlios.de>

Author: mean
Date: 2008-07-19 18:01:02 +0200 (Sat, 19 Jul 2008)
New Revision: 4245

Removed:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/CMakeLists.txt
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/include/audioencoder_config.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/include/audioencoder_enum.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/src/CMakeLists.txt
Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioEncoderApi.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audio_encoderPlugin.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioeng_buildfilters.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audiofilter_buildchain.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSAvidemuxAudio.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_toolkit/automation.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/DIA_none.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/gtk_gui.cpp
Log:
[AudioEncode] Cleanup


Deleted: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/CMakeLists.txt	2008-07-19 16:00:59 UTC (rev 4244)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/CMakeLists.txt	2008-07-19 16:01:02 UTC (rev 4245)
@@ -1 +0,0 @@
-ADD_SUBDIRECTORY(src)

Deleted: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/include/audioencoder_config.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/include/audioencoder_config.h	2008-07-19 16:00:59 UTC (rev 4244)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/include/audioencoder_config.h	2008-07-19 16:01:02 UTC (rev 4245)
@@ -1,182 +0,0 @@
-#ifndef AUDIOENCODER_CONFIG_H
-#define AUDIOENCODER_CONFIG_H
-
-#if 0
-#include "audioencoder_faac_param.h"
-#include "audioencoder_lame_param.h"
-#include "audioencoder_twolame_param.h"
-#include "audioencoder_vorbis_param.h"
-#include "audioencoder_aften_param.h"
-
-
-
-extern int DIA_defaultSettings(ADM_audioEncoderDescriptor *descriptor);
-/**** Copy ****/
-
-ADM_audioEncoderDescriptor copyDescriptor=
-{
-  AUDIOENC_COPY,
-  DIA_defaultSettings,
-  "Copy encoder",
-  128,
-  99,
-  0,
-  NULL
-};
-/**** FAAC ****/
-#ifdef USE_FAAC
-FAAC_encoderParam aacParam={128};
-ADM_audioEncoderDescriptor aacDescriptor=
-{
-        AUDIOENC_FAAC,
-        DIA_defaultSettings,
-        "FAAC encoder",
-        128,
-        6,      // AAC can do 5.1
-        sizeof(aacParam),
-        &aacParam
-};
-#endif
-/**** LAME ****/
-LAME_encoderParam lameParam=
-{
-  ADM_LAME_PRESET_CBR,
-  ADM_STEREO,
-  2,
-  0 /* Reservoir enable by default */
-};
-#ifdef HAVE_LIBMP3LAME
-extern int DIA_getLameSettings(ADM_audioEncoderDescriptor *descriptor);
-ADM_audioEncoderDescriptor  lameDescriptor=
-{
-  AUDIOENC_MP3,
-  DIA_getLameSettings,
-  "Lame encoder",
-  128,
-  2,      // Lame can only do stereo
-  sizeof(lameParam),
-  &lameParam
-};
-#endif
-/**** TWOLAME ****/
-TWOLAME_encoderParam twolameParam=
-{
-  ADM_STEREO
-};
-ADM_audioEncoderDescriptor  twolameDescriptor=
-{
-  AUDIOENC_2LAME,
-  DIA_defaultSettings,
-  "TwoLame encoder",
-  128,
-  2,      // Lame can only do stereo
-  sizeof(twolameParam),
-  &twolameParam
-};
-/********** Lavcodec **************/
-ADM_audioEncoderDescriptor  lavcodecMP2Descriptor=
-{
-  AUDIOENC_MP2,
-  DIA_defaultSettings,
-  "LAvcodec MP2 encoder",
-  128,
-  2,    
-  0,
-  NULL
-};
-ADM_audioEncoderDescriptor  lavcodecAC3Descriptor=
-{
-  AUDIOENC_AC3,
-  DIA_defaultSettings,
-  "LAvcodec AC3 encoder",
-  128,
-  6,    
-  0,
-  NULL
-};
-
-/************** Vorbis **************/
-#ifdef USE_VORBIS
-extern int DIA_getVorbisSettings(ADM_audioEncoderDescriptor *descriptor);
-VORBIS_encoderParam vorbisParam=
-{
-  ADM_VORBIS_VBR,
-  3
-  
-};
-ADM_audioEncoderDescriptor  vorbisDescriptor=
-{
-  AUDIOENC_VORBIS,
-  DIA_getVorbisSettings,
-  "Vorbis encoder",
-  128,
-  6,      // Lame can only do stereo
-  sizeof(vorbisParam),
-  &vorbisParam
-};
-#endif
-/********** PCM **************/
-ADM_audioEncoderDescriptor  pcmDescriptor=
-{
-  AUDIOENC_NONE,
-  NULL,
-  "PCM encoder",
-  128,
-  6,    
-  0,
-  NULL
-};
-ADM_audioEncoderDescriptor  lpcmDescriptor=
-{
-  AUDIOENC_LPCM,
-  NULL,
-  "LPCM encoder",
-  128,
-  6,    
-  0,
-  NULL
-};
-//---------------- AFTEN ------------------
-#ifdef USE_AFTEN
-AFTEN_encoderParam aftenParam =
-{
-  ADM_STEREO
-};
-
-ADM_audioEncoderDescriptor  aftenDescriptor=
-{
-  AUDIOENC_AFTEN,
-  DIA_defaultSettings,
-  "Aften AC3 encoder",
-  128,
-  6,      // Lame can only do stereo
-  sizeof(aftenParam),
-  &aftenParam
-};
-#endif
-ADM_audioEncoderDescriptor *allDescriptors[]=
-{
-      &copyDescriptor,
-#ifdef USE_FAAC
-      &aacDescriptor,
-#endif
-      &twolameDescriptor,
-      &lavcodecAC3Descriptor,
-      &lavcodecMP2Descriptor,
-#ifdef USE_VORBIS
-      &vorbisDescriptor ,
-#endif      
-      &pcmDescriptor,
-      &lpcmDescriptor
-#ifdef USE_AFTEN
-      ,&aftenDescriptor
-#endif
-#ifdef HAVE_LIBMP3LAME
-      ,&lameDescriptor
-#endif
-};
-#define NB_AUDIO_DESCRIPTOR (sizeof(allDescriptors)/sizeof(ADM_audioEncoderDescriptor *))
-#endif
-//EOF
-
-#endif
\ No newline at end of file

Deleted: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/include/audioencoder_enum.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/include/audioencoder_enum.h	2008-07-19 16:00:59 UTC (rev 4244)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/include/audioencoder_enum.h	2008-07-19 16:01:02 UTC (rev 4245)
@@ -1,24 +0,0 @@
-/**
-    \fn audioencoder_enum
-    \brief Temporary, will be removed
-*/
-
-#ifndef audioencoder_enum_h
-#define audioencoder_enum_h
-#if 0
-typedef enum 
-{
-	AUDIOENC_NONE,
-	AUDIOENC_MP3,
-	AUDIOENC_MP2,
-	AUDIOENC_AC3,
-	AUDIOENC_2LAME,
-	AUDIOENC_FAAC,
-	AUDIOENC_VORBIS,
-    AUDIOENC_COPY,
-    AUDIOENC_LPCM,
-    AUDIOENC_AFTEN,
-    AUDIOENC_DUMMY
-}AUDIOENCODER;
-#endif
-#endif
\ No newline at end of file

Deleted: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/src/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/src/CMakeLists.txt	2008-07-19 16:00:59 UTC (rev 4244)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audioEncoder/src/CMakeLists.txt	2008-07-19 16:01:02 UTC (rev 4245)
@@ -1,30 +0,0 @@
-SET(ADMaudioEncoder_SRCS
-audioencoder_aften.cpp
-audioencoder_faac.cpp
-audioencoder_lame.cpp
-audioencoder_lavcodec.cpp
-audioencoder_pcm.cpp
-audioencoder_twolame.cpp
-audioencoder_vorbis.cpp 
-)	
-ADD_ADM_LIB_ALL_TARGETS(ADM_audioEncoder ${ADMaudioEncoder_SRCS})
-INCLUDE_DIRECTORIES(${CMAKE_SOURCE_DIR}/avidemux/ADM_coreAudio/include)
-INCLUDE_DIRECTORIES(${CMAKE_SOURCE_DIR}/avidemux/ADM_audioEncoder/include)
-INCLUDE_DIRECTORIES(${CMAKE_SOURCE_DIR}/avidemux/ADM_audiofilter/)
-INCLUDE_DIRECTORIES(${CMAKE_SOURCE_DIR}/avidemux/ADM_audioEncoder/include)
-IF (USE_AFTEN)
-	ADD_SOURCE_CFLAGS(audioencoder_aften.cpp -I${AFTEN_INCLUDE_DIR})
-ENDIF (USE_AFTEN)
-
-IF (USE_FAAC)
-	ADD_SOURCE_CFLAGS(audioencoder_faac.cpp -I${FAAC_INCLUDE_DIR})
-ENDIF (USE_FAAC)
-
-IF (HAVE_LIBMP3LAME)
-	ADD_SOURCE_CFLAGS(audioencoder_lame.cpp -I${LAME_INCLUDE_DIR})
-ENDIF (HAVE_LIBMP3LAME)
-
-IF (USE_VORBIS)
-	ADD_SOURCE_CFLAGS(audioencoder_vorbis.cpp -I${VORBIS_INCLUDE_DIR})
-ENDIF (USE_VORBIS)
-

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioEncoderApi.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioEncoderApi.h	2008-07-19 16:00:59 UTC (rev 4244)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioEncoderApi.h	2008-07-19 16:01:02 UTC (rev 4245)
@@ -0,0 +1,35 @@
+/**
+    \file audioEncoderApi.h
+    \brief Helper functions to deal with audioEncoders
+
+*/
+#ifndef AUDIOENCODERAPI_H
+#define AUDIOENCODERAPI_H
+
+/// Select the best encoder using the audio fourcc : WAV_MP3 etc...
+uint8_t audio_selectCodecByTag(uint32_t tag);
+/// Set an option for example "DISABLERESERVOIR",1
+uint8_t audioSetOption(const char *option, uint32_t value);
+/// Select the copy Codec
+uint8_t audio_setCopyCodec(void);
+/// Directly set the codec, *only to be used
+uint8_t audioCodecSetByIndex(int i);
+/// Spawn a new encoder
+AUDMEncoder *audioEncoderCreate(AUDMAudioFilter *filter);
+/// Select a encoder by its name e.g. "lame"
+uint8_t audioCodecSetByName( const char *name);
+/// Returns the name of the currently selected codec
+const char *audioCodecGetName( void );
+/// Update the UI with the currently selected codec
+void audioPrintCurrentCodec(void);
+/// Returns 1 if we are in process mode, 0 if in copy mode
+uint32_t audioProcessMode(void);
+/// Retrieve current audio encoder configuration
+uint8_t getAudioExtraConf(uint32_t *bitrate,uint32_t *extraDataSize, uint8_t **extradata);
+/// Set current audio encoder configuration
+uint8_t setAudioExtraConf(uint32_t bitrate,uint32_t extraDataSize, uint8_t *extradata);
+
+
+
+#endif
+// EOF

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audio_encoderPlugin.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audio_encoderPlugin.cpp	2008-07-19 16:00:59 UTC (rev 4244)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audio_encoderPlugin.cpp	2008-07-19 16:01:02 UTC (rev 4245)
@@ -25,7 +25,10 @@
 static AUDIOENCODER ADM_encoderByName(const char *name);
 static const char *ADM_audioEncoderById(AUDIOENCODER id);
 
-
+/**
+    \class ADM_AudioEncoderLoader
+    \brief Helper class to load plugins
+*/
 class ADM_AudioEncoderLoader :public ADM_LibWrapper
 {
 
@@ -198,18 +201,7 @@
 {
 	return currentEncoder;
 }
-//*******************************************************************
-/**
-    \fn     
-    \brief
-*/
-void audioCodecChanged(int newcodec)
-{
-      ADM_assert(newcodec<ListOfAudioEncoder.size());
-      currentEncoder=newcodec;
 
-}
-
 /**
     \fn     
     \brief
@@ -260,18 +252,6 @@
 			UI_setAudioCodec(currentEncoder);
 }
 /**
-      \fn audioCodecSetcodec
-      \brief Set & update current audio encoder
-*/
-/*
-void audioCodecSetcodec(AUDIOENCODER codec)
-{
-
-	currentEncoder=codec;
-	audioPrintCurrentCodec();
-
-}*/
-/**
     \fn audioCodecSelect
     \brief
 */

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioeng_buildfilters.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioeng_buildfilters.h	2008-07-19 16:00:59 UTC (rev 4244)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioeng_buildfilters.h	2008-07-19 16:01:02 UTC (rev 4245)
@@ -20,6 +20,7 @@
 #include "audioencoder.h"
 #include "ADM_audio/aviaudio.hxx"
 
+#include "ADM_audiofilter/audioEncoderApi.h"
 
  AVDMGenericAudioStream *buildAudioFilter(AVDMGenericAudioStream *stream, uint32_t startTime);
  AUDMAudioFilter *buildPlaybackFilter(AVDMGenericAudioStream *currentaudiostream,
@@ -37,7 +38,7 @@
 uint32_t audioFilter_getOuputFrequency(uint32_t inputFrequency);
 uint32_t audioFilter_getMaxChannels(void);
 
-#include "ADM_audioEncoder/include/audioencoder_enum.h"
+//#include "ADM_audioEncoder/include/audioencoder_enum.h"
 
 typedef enum 
 {
@@ -65,19 +66,12 @@
 
 }AudioSource;
 
-void audioCodecSetcodec(AUDIOENCODER codec);
+//void audioCodecSetcodec(AUDIOENCODER codec);
 uint8_t audioReset(void);
 /*  for job/workspace stuff  */
-uint8_t audioCodecSetByName( const char *name);
-AudioSource audioCodecGetFromName( const char *name);
-const char *audioCodecGetName( void );
-
 const char *audioFilterGetName( void );
 uint8_t audioFilterSetByName( const char *name);
 
-const char *audioCodecGetConf( void );
-uint8_t audioCodecSetConf(char *conf );
-
 AVDMGenericAudioStream *mpt_getAudioStream(void);
 
 /* -- Set filter --*/
@@ -105,17 +99,8 @@
 AudioSource             audioSourceFromString(const char *name);
 const char              *getCurrentMixerString(void);
 uint8_t                 setCurrentMixerFromString(const char *string);
-uint8_t                 audioLamePreset(const char *name);
+
 //*****
-uint8_t getAudioExtraConf(uint32_t *bitrate,uint32_t *extraDataSize, uint8_t **extradata);
-uint8_t setAudioExtraConf(uint32_t bitrate,uint32_t extraDataSize, uint8_t *extradata);
 //
-uint8_t audio_selectCodecByTag(uint32_t tag);
-void audioCodecChanged(int newcodec);
-uint8_t audioSetOption(const char *option, uint32_t value);
-uint8_t audio_setCopyCodec(void);
-uint8_t audioCodecSetByIndex(int i);
-//
-AUDMEncoder *audioEncoderCreate(AUDMAudioFilter *filter);
 #endif
 

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audiofilter_buildchain.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audiofilter_buildchain.cpp	2008-07-19 16:00:59 UTC (rev 4244)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audiofilter_buildchain.cpp	2008-07-19 16:01:02 UTC (rev 4245)
@@ -46,7 +46,7 @@
 #include "audiofilter_film2pal.h"
 
 /* ************ Conf *********** */
-#include "audioencoder_config.h"
+//#include "audioencoder_config.h"
 
 
 #include "ADM_osSupport/ADM_debugID.h"

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSAvidemuxAudio.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSAvidemuxAudio.cpp	2008-07-19 16:00:59 UTC (rev 4244)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSAvidemuxAudio.cpp	2008-07-19 16:01:02 UTC (rev 4245)
@@ -456,7 +456,7 @@
         ADM_LowerCase(name);
         // First search the codec by its name
         AudioSource source;
-        if(AudioInvalid==(source=audioCodecGetFromName(name)))
+        if(AudioInvalid==(source=audioSourceFromString(name)))
                 return JS_FALSE;
         // Now get the name
         name = JS_GetStringBytes(JSVAL_TO_STRING(argv[1]));

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_toolkit/automation.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_toolkit/automation.cpp	2008-07-19 16:00:59 UTC (rev 4244)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_toolkit/automation.cpp	2008-07-19 16:01:02 UTC (rev 4245)
@@ -396,7 +396,7 @@
 	else if(!strcasecmp(p,"VORBIS"))
 		audio_selectCodecByTag( WAV_OGG );		
 	else if(!strcasecmp(p,"COPY"))
-		audioCodecChanged( AUDIOENC_COPY );		
+		audio_setCopyCodec();		
 	else{
 		audio_selectCodecByTag( WAV_PCM );
 		fprintf(stderr,"audio codec \"%s\" unknown.\n",p);

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/DIA_none.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/DIA_none.cpp	2008-07-19 16:00:59 UTC (rev 4244)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/DIA_none.cpp	2008-07-19 16:01:02 UTC (rev 4245)
@@ -22,7 +22,7 @@
 
 
 #include "ADM_encoder/ADM_vidEncode.hxx"
-#include "ADM_audioEncoder/include/audioencoder_enum.h"
+//#include "ADM_audioEncoder/include/audioencoder_enum.h"
 
 
 #ifdef USE_XX_XVID 

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/gtk_gui.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/gtk_gui.cpp	2008-07-19 16:00:59 UTC (rev 4244)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/gtk_gui.cpp	2008-07-19 16:01:02 UTC (rev 4245)
@@ -238,7 +238,7 @@
 		return;
    case ACT_AudioCodecChanged:
                 nw=UI_getCurrentACodec();
-   		audioCodecChanged(nw);
+                audioCodecSetByIndex(nw);
     		
 		return;
     case ACT_PLUGIN_INFO:



From mean at mail.berlios.de  Sat Jul 19 18:01:08 2008
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sat, 19 Jul 2008 18:01:08 +0200
Subject: [Avidemux-svn-commit] r4246 - in
	branches/avidemux_2.5_branch_gruntster:
	avidemux/ADM_audiofilter plugins/ADM_audioEncoders/lavcodec
Message-ID: <200807191601.m6JG18ui024398@sheep.berlios.de>

Author: mean
Date: 2008-07-19 18:01:06 +0200 (Sat, 19 Jul 2008)
New Revision: 4246

Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audio_encoderPlugin.cpp
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/lavcodec/audioencoder_lavcodec.cpp
Log:
[AudioEncoder] More verbose audio encoders, prevent symbol clash in audioEncoders


Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audio_encoderPlugin.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audio_encoderPlugin.cpp	2008-07-19 16:01:02 UTC (rev 4245)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audio_encoderPlugin.cpp	2008-07-19 16:01:06 UTC (rev 4246)
@@ -55,8 +55,8 @@
                         initialised=0;
                     }else
                     {
-                        printf("[AudioEncoder] Loaded %s version %02d.%02d.%02d\n",e->codecName,
-                                e->major,e->minor,e->patch);
+                        printf("[AudioEncoder] Loaded %s version %02d.%02d.%02d wavTag :0x%x\n",e->codecName,
+                                e->major,e->minor,e->patch,e->wavTag);
                         encoderBlock=new ADM_audioEncoder;
                         *encoderBlock=*e;
                         encoderBlock->opaque=(void *)this;
@@ -229,6 +229,7 @@
 {
     ADM_assert(i<ListOfAudioEncoder.size());
     currentEncoder=i;
+    printf("[AudioEncoder] Selected %s for index %d, tag 0x%x \n",ListOfAudioEncoder[currentEncoder]->codecName,i,ListOfAudioEncoder[currentEncoder]->wavTag);
     return 1;
 
 }
@@ -343,7 +344,8 @@
 AUDMEncoder *audioEncoderCreate(AUDMAudioFilter *filter)
 {
       ADM_assert(currentEncoder<ListOfAudioEncoder.size());
-     return ListOfAudioEncoder[currentEncoder]->create(filter);
+      static ADM_audioEncoder *enc=ListOfAudioEncoder[currentEncoder];
+     return enc->create(filter);
 }
 /**
         \fn getAudioExtraConf
@@ -402,7 +404,7 @@
     {
         currentEncoder=selected;
         UI_setAudioCodec( (int)currentEncoder);
-        printf("[AudioEncoder] Selected %s for tag %d (%s)\n",ListOfAudioEncoder[currentEncoder],tag,"");
+        printf("[AudioEncoder] Selected %s for tag %d (%s)\n",ListOfAudioEncoder[currentEncoder]->codecName,tag,"");
         return 1;
     }
     return 0;

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/lavcodec/audioencoder_lavcodec.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/lavcodec/audioencoder_lavcodec.cpp	2008-07-19 16:01:02 UTC (rev 4245)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/lavcodec/audioencoder_lavcodec.cpp	2008-07-19 16:01:06 UTC (rev 4246)
@@ -23,10 +23,27 @@
 #include "audioencoder.h"
 #include "audioencoderInternal.h"
 //
-#include "audioencoder_lavcodec.h"
 
+
 #include "ADM_lavcodec.h"
 
+
+
+#define Join(x,y) x##_##y
+#if defined(ADM_LAV_MP2) && !defined(ADM_LAV_AC3)
+  #define makeName(x) Join(x,MP2)
+  #define AUDMEncoder_Lavcodec AUDMEncoder_Lavcodec_MP2
+#else
+ #if !defined(ADM_LAV_MP2) && defined(ADM_LAV_AC3)
+  #define makeName(x) Join(x,AC3)
+  #define AUDMEncoder_Lavcodec AUDMEncoder_Lavcodec_AC3
+ #else
+   #error
+ #endif
+#endif
+
+#include "audioencoder_lavcodec.h"
+
 typedef struct 
 {
     uint32_t bitrate;
@@ -47,15 +64,17 @@
   "MP2 LavCodec encoder plugin Mean 2008",             
   2,                    // Max channels
   1,0,0,                // Version
-  WAV_MP2,
 #else
+  
+
  "LavAC3",            
   "AC3 (lav)",      
   "AC3 LavEncoder encoder plugin Mean 2008",             
   6,                    // Max channels
   1,0,0,                // Version
-  WAV_AC3,
 #endif
+  makeName(WAV),
+
   100,                  // Priority
   getConfigurationData,  // Defined by macro automatically
   setConfigurationData,  // Defined by macro automatically
@@ -80,12 +99,11 @@
 {
   
   _context=NULL;
-#ifdef ADM_LAV_MP2     
-  _wavheader->encoding=WAV_MP2;
-#else
-    _wavheader->encoding=WAV_AC3;
-#endif
-  printf("[Lavcodec] Creating Lavcodec audio encoder\n");
+   printf("[Lavcodec] Creating Lavcodec audio encoder (0x%x)\n",makeName(WAV));
+
+  _wavheader->encoding=makeName(WAV);
+  
+  
 };
 
 
@@ -134,13 +152,9 @@
 
   AVCodec *codec;
   CodecID codecID;
-#ifdef ADM_LAV_MP2  
-  printf("[LavAudio] Mp2 encoder\n"); 
-  codecID=CODEC_ID_MP2;
-#else
-  printf("[LavAudio] Ac3 encoder\n"); 
-  codecID=CODEC_ID_AC3;
-#endif
+
+  
+  codecID=makeName(CODEC_ID);
   codec = avcodec_find_encoder(codecID);
   ADM_assert(codec);
   
@@ -152,7 +166,7 @@
   }
 
 
-  printf("[Lavcodec]Lavcodec successfully initialized\n");
+  printf("[Lavcodec]Lavcodec successfully initialized,wavTag : 0x%x\n",makeName(WAV));
   return 1;       
 }
 //*********************************



From mean at mail.berlios.de  Sat Jul 19 18:12:51 2008
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sat, 19 Jul 2008 18:12:51 +0200
Subject: [Avidemux-svn-commit] r4247 - in
	branches/avidemux_2.5_branch_gruntster: cmake
	plugins/ADM_audioDecoders/ADM_ad_faad
Message-ID: <200807191612.m6JGCpNI025407@sheep.berlios.de>

Author: mean
Date: 2008-07-19 18:12:51 +0200 (Sat, 19 Jul 2008)
New Revision: 4247

Modified:
   branches/avidemux_2.5_branch_gruntster/cmake/admCheckFaad.cmake
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDecoders/ADM_ad_faad/CMakeLists.txt
Log:
[AudioDecoder] Fix faad built


Modified: branches/avidemux_2.5_branch_gruntster/cmake/admCheckFaad.cmake
===================================================================
--- branches/avidemux_2.5_branch_gruntster/cmake/admCheckFaad.cmake	2008-07-19 16:01:06 UTC (rev 4246)
+++ branches/avidemux_2.5_branch_gruntster/cmake/admCheckFaad.cmake	2008-07-19 16:12:51 UTC (rev 4247)
@@ -30,7 +30,7 @@
 
 			IF (FAAD_FOUND)
 				CHECK_CFLAGS_REQUIRED(faad_check.cpp "-DOLD_FAAD_PROTO" "${FAAD_INCLUDE_DIR}" "${FAAD_LIBRARY_DIR}" FAAD_CFLAGS_REQUIRED)
-
+                                SET(USE_FAAD 1)
 				IF (FAAD_CFLAGS_REQUIRED)
 					SET(FAAD_OLD_PROTOTYPE 1)
 				ENDIF (FAAD_CFLAGS_REQUIRED)
@@ -44,4 +44,4 @@
 
 		MESSAGE("")
 	ENDIF (NOT FAAD_CHECKED)
-ENDMACRO(checkFaad)
\ No newline at end of file
+ENDMACRO(checkFaad)

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDecoders/ADM_ad_faad/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDecoders/ADM_ad_faad/CMakeLists.txt	2008-07-19 16:01:06 UTC (rev 4246)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDecoders/ADM_ad_faad/CMakeLists.txt	2008-07-19 16:12:51 UTC (rev 4247)
@@ -1,7 +1,7 @@
 INCLUDE(admCheckFaad)
 checkFaad()
 
-IF (HAVE_FAAD)
+IF (USE_FAAD)
 	INCLUDE(ad_plugin)
 	
 	SET(ADM_ad_faad_SRCS ADM_ad_faad.cpp)
@@ -14,4 +14,4 @@
 
 	INIT_AUDIO_PLUGIN(ADM_ad_faad)
 	INSTALL_AUDIODECODER(ADM_ad_faad)
-ENDIF (HAVE_FAAD)
+ENDIF (USE_FAAD)



From mean at mail.berlios.de  Sat Jul 19 19:58:14 2008
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sat, 19 Jul 2008 19:58:14 +0200
Subject: [Avidemux-svn-commit] r4248 -
	branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_mp4
Message-ID: <200807191758.m6JHwEEp025429@sheep.berlios.de>

Author: mean
Date: 2008-07-19 19:58:13 +0200 (Sat, 19 Jul 2008)
New Revision: 4248

Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_mp4/ADM_atom.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_mp4/ADM_atom.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_mp4/ADM_mp4.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_mp4/ADM_mp4.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_mp4/ADM_mp4Analyzer.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_mp4/ADM_mp4Indexer.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_mp4/ADM_mp4Leaf.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_mp4/ADM_mp4audio.cpp
Log:
[Merge] r4213, 64 Bits mp4 support


Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_mp4/ADM_atom.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_mp4/ADM_atom.cpp	2008-07-19 16:12:51 UTC (rev 4247)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_mp4/ADM_atom.cpp	2008-07-19 17:58:13 UTC (rev 4248)
@@ -19,12 +19,9 @@
  ***************************************************************************/
 #include "config.h"
 
-#include <stdio.h>
-#include <stdlib.h>
 #include <string.h>
 #include <math.h>
 
-#include "ADM_assert.h"
 #include "ADM_default.h"
 #include "ADM_editor/ADM_Video.h"
 
@@ -37,7 +34,7 @@
 adm_atom::adm_atom(adm_atom *atom)
 {
 	_fd=atom->_fd;
-	_atomStart=ftell(_fd);
+	_atomStart=ftello(_fd);
 	_atomSize=read32();
 	_atomFCC=read32();
 	// Gross hack for some (buggy ?) movie
@@ -46,10 +43,14 @@
 		printf("3GP:Workaround: detected wrong sized atom!\nTrying to continue\n");
 		_atomStart+=4;
 		_atomSize-=4;
-		fseek(_fd,_atomStart,SEEK_SET);
+		fseeko(_fd,_atomStart,SEEK_SET);
 		_atomSize=read32();
 		_atomFCC=read32();
 	}
+
+	if (fourCC::check(_atomFCC, (uint8_t *)"tadm") && _atomSize == 1)	// mdat
+		_atomSize=read64();
+
 #ifdef ATOM_DEBUG
 	dumpAtom();
 #endif
@@ -64,14 +65,14 @@
 }
 adm_atom::adm_atom(FILE *fd )
 {
-uint32_t orgpos;
+int64_t orgpos;
 	_fd=fd;
         orgpos=ftello(fd);
-	fseek(_fd,0,SEEK_END);
+	fseeko(_fd,0,SEEK_END);
 	_atomFCC=fourCC::get((uint8_t *)"MOVI");
-	_atomSize=ftell(_fd);//-orgpos;
+	_atomSize=ftello(_fd);//-orgpos;
 
-	fseek(_fd,orgpos,SEEK_SET);
+	fseeko(_fd,orgpos,SEEK_SET);
 	_atomStart=0;
 #ifdef ATOM_DEBUG
 	dumpAtom();
@@ -85,9 +86,9 @@
 }
 uint8_t adm_atom::skipBytes( uint32_t nb )
 {
-uint32_t pos;
-	fseek(_fd,nb,SEEK_CUR);
-	pos=ftell(_fd);
+int64_t pos;
+	fseeko(_fd,nb,SEEK_CUR);
+	pos=ftello(_fd);
 	if(pos>_atomStart+_atomSize+1) ADM_assert(0);	
 	return 1;
 }
@@ -124,16 +125,20 @@
 
 }
 
+uint64_t adm_atom::read64( void )
+{
+	uint64_t a1 = read32();
+
+	return (a1 << 32) + read32();
+}
+
 uint32_t adm_atom::getFCC( void )
 {
 	return _atomFCC;
 }
-uint32_t adm_atom::getSize( void )
+
+int64_t adm_atom::getRemainingSize( void )
 {
-	return _atomSize-8;
-}
-uint32_t adm_atom::getRemainingSize( void )
-{
         int64_t pos=ftello(_fd);
         
         return _atomStart+_atomSize-pos;
@@ -141,9 +146,9 @@
 
 uint8_t adm_atom::readPayload( uint8_t *whereto, uint32_t rd)
 {
-	uint32_t pos;
+	int64_t pos;
 
-	pos=ftell(_fd);
+	pos=ftello(_fd);
 	if(pos+rd>_atomSize+_atomStart)
 	{
 		printf("\n Going out of atom's bound!! (%ld  / %ld )\n",pos+rd,_atomSize+_atomStart);
@@ -172,7 +177,7 @@
 
 uint8_t adm_atom::skipAtom( void )
 {
-	fseek(_fd,_atomStart+_atomSize,SEEK_SET);
+	fseeko(_fd,_atomStart+_atomSize,SEEK_SET);
 #ifdef _3G_LOGO
         printf("Branching to %x ending atom ",_atomStart+_atomSize);
         fourCC::printBE(_atomFCC);
@@ -184,7 +189,7 @@
 }
 uint8_t adm_atom::isDone( void )
 {
-	uint32_t pos=ftell(_fd);
+	int64_t pos=ftello(_fd);
 
 	if(pos>=(_atomStart+_atomSize)) return 1;
 	return 0;

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_mp4/ADM_atom.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_mp4/ADM_atom.h	2008-07-19 16:12:51 UTC (rev 4247)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_mp4/ADM_atom.h	2008-07-19 17:58:13 UTC (rev 4248)
@@ -23,7 +23,7 @@
 {
 private:
 		FILE 		*_fd;
-		uint32_t	_atomStart,_atomSize;
+		int64_t		_atomStart,_atomSize;
 		uint32_t	_atomFCC;
 		uint8_t		dumpAtom( void );
 public:
@@ -33,12 +33,12 @@
 		uint8_t	        skipAtom( void );
                 uint32_t        getStartPos(void) {return _atomStart;}
 		uint32_t	getFCC( void );
-		uint32_t	getSize( void );
-                uint32_t        getRemainingSize( void );
+		int64_t        getRemainingSize( void );
 		uint8_t		readPayload( uint8_t *whereto, uint32_t rd );
 		uint8_t		isDone(void );
 		uint8_t		skipBytes(uint32_t nb );
 
+		uint64_t	read64( void );
 		uint32_t	read32( void );
 		uint16_t	read16( void );
 		uint8_t	        read( void );

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_mp4/ADM_mp4.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_mp4/ADM_mp4.cpp	2008-07-19 16:12:51 UTC (rev 4247)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_mp4/ADM_mp4.cpp	2008-07-19 17:58:13 UTC (rev 4248)
@@ -54,12 +54,9 @@
  ***************************************************************************/
 #include "config.h"
 
-#include <stdio.h>
-#include <stdlib.h>
 #include <string.h>
 #include <math.h>
 
-#include "ADM_assert.h"
 #include "ADM_default.h"
 #include "ADM_editor/ADM_Video.h"
 
@@ -123,7 +120,7 @@
     {
       return 0; 
     }
-    uint32_t offset=VDEO.index[framenum].offset; //+_mdatOffset;
+    uint64_t offset=VDEO.index[framenum].offset; //+_mdatOffset;
 
 
     fseeko(_fd,offset,SEEK_SET);
@@ -226,14 +223,14 @@
         fseeko(_fd,0,SEEK_SET);
         if(check[0]=='m' && check[1]=='d' &&check[2]=='a' && check[3]=='t')
         {
-                        uint32_t of;
+                        uint64_t of;
                                         printf("Data first, header later...\n");
                                         of=atom->read32();
                                         if(of==1)
                                         {
-                                          atom->read32();
-                                          atom->read32();
-                                          of=atom->read32();
+                                          atom->read32();	// size
+                                          atom->read32();	// fcc
+                                          of=atom->read64();
                                         }
                                         fseeko(_fd,of,SEEK_SET);        
                                         printf("Header starts at %x\n",of);
@@ -330,7 +327,7 @@
             _audioTracks[audio]=new MP4Audio(name,&(_tracks[1+audio]));   
             
         }
-        fseek(_fd,0,SEEK_SET);
+        fseeko(_fd,0,SEEK_SET);
         printf("3gp/mov file successfully read..\n");
         return 1;
 }

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_mp4/ADM_mp4.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_mp4/ADM_mp4.h	2008-07-19 16:12:51 UTC (rev 4247)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_mp4/ADM_mp4.h	2008-07-19 17:58:13 UTC (rev 4248)
@@ -38,7 +38,7 @@
       uint32_t nbSync;
       uint32_t nbCtts;
       
-      uint32_t *Co;
+	  uint64_t *Co;
       uint32_t *Sz;
       uint32_t *Sc;
       uint32_t *Sn;
@@ -86,15 +86,12 @@
 protected:
 
            	uint32_t 					_nb_chunks;
-		uint64_t					_abs_position;
-		uint32_t					_rel_position;
-
               	uint32_t 					_current_index;
 	    	MP4Index 					*_index;
 		FILE						*_fd;
 		uint32_t					_extraLen;
 		uint8_t						*_extraData;
-		uint32_t                                         _audioDuration;
+		uint64_t                                         _audioDuration;
 		
 		
 public:
@@ -129,7 +126,7 @@
           uint8_t                       decodeEsds(void *ztom,uint32_t trackType);
           uint8_t                       updateCtts(MPsampleinfo *info );
           uint32_t                      _videoScale;
-          uint32_t                      _movieDuration; // in ms
+          int64_t						_movieDuration; // in ms
           uint32_t                      _videoFound;
           uint8_t	                indexify(
                                                 MP4Track *track,   
@@ -141,7 +138,7 @@
         uint8_t                       _reordered;		
         FILE                          *_fd;
         MP4Track                      _tracks[_3GP_MAX_TRACKS];
-        uint32_t                      _audioDuration;
+        int64_t                      _audioDuration;
         uint32_t                      _currentAudioTrack;
         uint8_t                       parseAtomTree(adm_atom *atom);
         MP4Audio                      *_audioTracks[_3GP_MAX_TRACKS-1];

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_mp4/ADM_mp4Analyzer.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_mp4/ADM_mp4Analyzer.cpp	2008-07-19 16:12:51 UTC (rev 4247)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_mp4/ADM_mp4Analyzer.cpp	2008-07-19 17:58:13 UTC (rev 4248)
@@ -15,12 +15,8 @@
  ***************************************************************************/
 #include "config.h"
 
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
 #include <math.h>
 
-#include "ADM_assert.h"
 #include "ADM_default.h"
 #include "ADM_editor/ADM_Video.h"
 
@@ -107,23 +103,36 @@
 */
 void MP4Header::parseMvhd(void *ztom)
 {
-  adm_atom *tom=(adm_atom *)ztom;
-  tom->skipBytes(12);
-  uint32_t scale,duration=1000;
+	adm_atom *tom = (adm_atom*)ztom;
+	int version = tom->read();
 
-        scale=tom->read32();
-        duration=tom->read32();
-        _videoScale=scale;
-        printf("Warning : scale is not in ms %lu !\n",_videoScale);
-        if(_videoScale)
-        {
-                        duration=1000*duration; // In ms
-                        duration/=_videoScale;
-        }else
-          _videoScale=1000;
-        printf("Movie duration :%s\n",ms2timedisplay(duration));
-        _movieDuration=duration;
+	tom->skipBytes(3);	// flags
+
+	if (version == 1)
+		tom->skipBytes(16);
+	else
+		tom->skipBytes(8);
+
+	int scale = tom->read32();
+	uint64_t duration = (version == 1) ? tom->read64() : tom->read32();
+
+	_videoScale = scale;
+
+	printf("Warning: scale is not in ms %lu!\n", _videoScale);
+
+	if (_videoScale)
+	{
+		duration = 1000 * duration; // In ms
+		duration /= _videoScale;
+	}
+	else
+		_videoScale = 1000;
+
+	printf("Movie duration: %s\n", ms2timedisplay(duration));
+
+	_movieDuration = duration;
 }
+
 /**
       \fn parseMvhd
       \brief Parse mvhd header
@@ -151,20 +160,31 @@
      {
        case ADM_MP4_TKHD:
               {
-                      son.skipBytes(12);
-                      adm_printf(ADM_PRINT_DEBUG,"Track Id: %lu\n",son.read32());
-                      son.skipBytes(4);
-                      adm_printf(ADM_PRINT_DEBUG,"Duration: %lu (ms)\n",(son.read32()*1000)/_videoScale);
-                      son.skipBytes(8);
-                      son.skipBytes(4); // layers
-                      son.skipBytes(40); // layers
+				  int version = son.read();
 
-                      w=son.read32()>>16;
-                      h=son.read32()>>16;
-                      adm_printf(ADM_PRINT_DEBUG,"tkhd : %ld %ld\n",w,h);
+				  son.skipBytes(3);
 
+				  if (version == 1)
+					  tom->skipBytes(16);
+				  else
+					  tom->skipBytes(8);
+
+				  adm_printf(ADM_PRINT_DEBUG,"Track Id: %lu\n", son.read32());
+				  son.skipBytes(4);
+
+				  uint64_t duration = (version == 1) ? son.read64() : son.read32();
+
+				  adm_printf(ADM_PRINT_DEBUG, "Duration: %lu (ms)\n", (duration * 1000) / _videoScale);
+				  son.skipBytes(8);
+				  son.skipBytes(8);
+				  son.skipBytes(36);
+
+				  w = son.read32() >> 16;
+				  h = son.read32() >> 16;
+
+				  adm_printf(ADM_PRINT_DEBUG,"tkhd: %ld %ld\n", w, h);
+				  break;
               }
-              break;
         case ADM_MP4_MDIA:
         {
             parseMdia(&son,&trackType,w,h);
@@ -187,7 +207,7 @@
   ADMAtoms id;
   uint32_t container;
   uint32_t trackScale=_videoScale;
-  uint32_t trackDuration;
+  uint64_t trackDuration;
   *trackType=TRACK_OTHER;
   uint8_t r=0;
   printf("<<Parsing Mdia>>\n");
@@ -204,21 +224,31 @@
      {
        case ADM_MP4_MDHD:
        {
-                uint32_t version=son.read(),duration;
-                son.skipBytes(3); // flags + version
-                son.skipBytes(4); // creation time
-                son.skipBytes(4); // mod time
-                if(version==1) son.skipBytes(8);
-                trackScale=son.read32(); //
-                adm_printf(ADM_PRINT_DEBUG,"MDHD,Trackscale in mdhd:%u\n",trackScale);
-                if(!trackScale) trackScale=600; // default
-                duration=son.read32();
-                adm_printf(ADM_PRINT_DEBUG,"MDHD,duration in mdhd:%u (unscaled)\n",duration);
-                duration=(uint32_t)((duration*1000.)/trackScale);
-                adm_printf(ADM_PRINT_DEBUG,"MDHD,duration in mdhd:%u (scaled ms)\n",duration);
-                trackDuration=duration;
-                printf("MDHD,Track duration :%s, trackScale :%u\n",ms2timedisplay((1000*duration)/trackScale),trackScale);
-                break;
+		   int version = son.read();
+
+		   son.skipBytes(3); // flags
+
+		   if (version == 1)
+			   son.skipBytes(16);
+		   else
+			   son.skipBytes(8);
+
+		   trackScale = son.read32();
+
+		   adm_printf(ADM_PRINT_DEBUG, "MDHD, Trackscale in mdhd: %u\n", trackScale);
+
+		   if (!trackScale)
+			   trackScale = 600; // default
+
+		   uint64_t duration = (version == 1) ? son.read64() : son.read32();
+
+		   adm_printf(ADM_PRINT_DEBUG, "MDHD, duration in mdhd: %u (unscaled)\n", duration);
+		   duration = (duration * 1000.) / trackScale;
+		   adm_printf(ADM_PRINT_DEBUG, "MDHD, duration in mdhd: %u (scaled ms)\n", duration);
+		   trackDuration = duration;
+		   printf("MDHD, Track duration: %s, trackScale: %u\n", ms2timedisplay((1000 * duration) / trackScale), trackScale);
+
+		   break;
        }
        case ADM_MP4_HDLR:
        {
@@ -343,7 +373,7 @@
                 printf("Using myscale %lu\n",trackScale);
                 info.SttsN=new uint32_t[info.nbStts];
                 info.SttsC=new uint32_t[info.nbStts];
-                double dur;
+                //double dur;
                 for(int i=0;i<info.nbStts;i++)
                 {
 
@@ -446,32 +476,34 @@
             break;
        case ADM_MP4_STCO:
        {
-          son.read32();
-          info.nbCo=son.read32();
-          printf("\t\tnbCo:%u\n",info.nbCo);
-          info.Co=new uint32_t[info.nbCo];
-          for(int j=0;j< info.nbCo;j++)
-          {
-                  info.Co[j]=son.read32();
-                  adm_printf(ADM_PRINT_VERY_VERBOSE,"Chunk offset : %u / %u  : %u\n",  j,info.nbCo,info.Co[j]);
-          }
+		   son.skipBytes(4);
 
+		   info.nbCo = son.read32();
+		   printf("\t\tnbCo: %u\n", info.nbCo);
+
+		   info.Co = new uint64_t[info.nbCo];
+
+		   for(int j = 0; j < info.nbCo; j++)
+		   {
+			   info.Co[j] = son.read32();
+			   adm_printf(ADM_PRINT_VERY_VERBOSE, "Chunk offset: %u / %u : %"LLU"\n", j, info.nbCo - 1, info.Co[j]);
+		   }
        }
        break;
        case ADM_MP4_STCO64:
        {
-         printf("Incomplete support for 64 bits quicktime!!\n");
-          son.read32();
-          info.nbCo=son.read32();
-          printf("\t\tnbCo:%u\n",info.nbCo);
-          info.Co=new uint32_t[info.nbCo];
-          for(int j=0;j< info.nbCo;j++)
-          {
-                  son.read32(); // Ignore MSB
-                  info.Co[j]=son.read32();
-                  adm_printf(ADM_PRINT_VERY_VERBOSE,"Chunk offset : %u / %u  : %lu\n",  j,info.nbCo,info.Co[j]);
-          }
+		   son.skipBytes(4);
 
+		   info.nbCo = son.read32();
+		   printf("\t\tnbCo: %u\n", info.nbCo);
+
+		   info.Co = new uint64_t[info.nbCo];
+
+		   for(int j = 0; j< info.nbCo; j++)
+		   {
+			   info.Co[j] = son.read64();
+			   adm_printf(ADM_PRINT_VERY_VERBOSE, "Chunk offset: %u / %u : %"LLU"\n", j, info.nbCo - 1, info.Co[j]);
+		   }
        }
        break;
        case ADM_MP4_STSD:
@@ -797,7 +829,7 @@
                                             break;
                                     case MKFCCR('Q','D','M','2'):
                                         {
-                                            uint32_t sz;
+                                            int64_t sz;
                                               audioCodec(QDM2);
                                               sz=son.getRemainingSize();
                                               _tracks[1+nbAudioTrack].extraDataSize=sz;
@@ -924,7 +956,7 @@
             // Mark keyframes
             for(int i=0;i<info.nbSync;i++)
             {
-              int sync=info.Sync[i];
+              uint32_t sync=info.Sync[i];
               if(sync) sync--;
               _tracks[0].index[sync].intra=AVI_KEY_FRAME;
             }

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_mp4/ADM_mp4Indexer.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_mp4/ADM_mp4Indexer.cpp	2008-07-19 16:12:51 UTC (rev 4247)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_mp4/ADM_mp4Indexer.cpp	2008-07-19 17:58:13 UTC (rev 4248)
@@ -15,12 +15,9 @@
  ***************************************************************************/
 #include "config.h"
 
-#include <stdio.h>
-#include <stdlib.h>
 #include <string.h>
 #include <math.h>
 
-#include "ADM_assert.h"
 #include "ADM_default.h"
 #include "ADM_editor/ADM_Video.h"
 
@@ -53,7 +50,7 @@
         printf("Build Track index\n");
 	*outNbChunk=0;
 	aprintf("+_+_+_+_+_+\n");
-	aprintf("co : %lu sz: %lu sc: %lu co[0]%lu \n",info->nbCo,info->nbSz,info->nbSc,info->Co[0]);
+	aprintf("co : %lu sz: %lu sc: %lu co[0] %"LLU"\n",info->nbCo,info->nbSz,info->nbSc,info->Co[0]);
 	aprintf("+_+_+_+_+_+\n");
 
 	ADM_assert(info->Sc);
@@ -71,7 +68,7 @@
           
           
           uint32_t totalBytes=info->SzIndentical*info->nbSz;
-          printf("All the same size : %u (total size %u bytes)\n",info->SzIndentical,totalBytes);
+          printf("All the same size: %u (total size %u bytes)\n",info->SzIndentical,totalBytes);
               //
               // Each chunk contains N samples=N bytes
               int samplePerChunk[info->nbCo];
@@ -82,8 +79,7 @@
 
                   for(int j=info->Sc[i]-1;j<info->nbCo;j++)
                   {
-                    uint32_t mx;
-                        adm_printf(ADM_PRINT_VERY_VERBOSE,"For chunk %lu , %lu samples\n",j,info->Sn[i]);
+                        adm_printf(ADM_PRINT_VERY_VERBOSE,"For chunk %lu, %lu samples\n",j,info->Sn[i]);
                         samplePerChunk[j]=info->Sn[i];
                   }
               }
@@ -244,7 +240,7 @@
           }
 	// if no sample to chunk we map directly
 	// first build the # of sample per chunk table
-        uint32_t totalchunk=0,max=0;
+        uint32_t totalchunk=0;
 
         // Search the maximum
         for(i=0;i<info->nbSc-1;i++)
@@ -253,9 +249,9 @@
         }
         totalchunk+=(info->nbCo-info->Sc[info->nbSc-1]+1)*info->Sn[info->nbSc-1];
 
-        adm_printf(ADM_PRINT_VERY_VERBOSE,"#of chunk %d max per chunk %d Max # of sample %d\n",info->nbCo,max,totalchunk);
+        adm_printf(ADM_PRINT_VERY_VERBOSE,"# of chunks %d, max # of samples %d\n",info->nbCo, totalchunk);
 
-        uint32_t chunkCount[totalchunk+1];
+        uint32_t *chunkCount = new uint32_t[totalchunk+1];
 	for(i=0;i<info->nbSc;i++)
 	{
 		for(j=info->Sc[i]-1;j<info->nbCo;j++)
@@ -286,6 +282,8 @@
 
 
 	}
+
+	delete [] chunkCount;
         
         
         track->nbIndex=cur;;

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_mp4/ADM_mp4Leaf.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_mp4/ADM_mp4Leaf.cpp	2008-07-19 16:12:51 UTC (rev 4247)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_mp4/ADM_mp4Leaf.cpp	2008-07-19 17:58:13 UTC (rev 4248)
@@ -16,9 +16,6 @@
  ***************************************************************************/
 #include "config.h"
 
-#include <stdio.h>
-#include <stdlib.h>
-
 #include <string.h>
 
 #include <math.h>

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_mp4/ADM_mp4audio.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_mp4/ADM_mp4audio.cpp	2008-07-19 16:12:51 UTC (rev 4247)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_mp4/ADM_mp4audio.cpp	2008-07-19 17:58:13 UTC (rev 4248)
@@ -23,8 +23,6 @@
  ***************************************************************************/
 #include "config.h"
 
-#include <stdio.h>
-#include <stdlib.h>
 #include <string.h>
 #include <math.h>
 
@@ -44,8 +42,6 @@
 	_fd=fopen(name,"rb");
         ADM_assert(_fd);
 	_current_index=0;
-	_abs_position=0;
-	_rel_position=0;
 	_pos=0;
 	_index=track->index;
 
@@ -61,9 +57,8 @@
 	// compute length
 	_length=0;
 	for(uint32_t i=0;i<_nb_chunks;i++)
-		{
-			_length+=track->index[i].size;
-		}
+		_length+=track->index[i].size;
+
 	printf("\n [MP4 audio] : %lu bytes (%lu chunks)\n",_length,_nb_chunks);
 
 	printf("Byterate     :%d\n",_wavheader->byterate);
@@ -123,13 +118,8 @@
 	  fseeko(_fd,_index[_current_index].offset,SEEK_SET);
 	  r=fread(dest,1,_index[_current_index].size,_fd);
           if(!r)
-          {
             printf("[MP4 Audio] Cannot read \n"); 
-          }
-          else
-          {
-            
-          }
+
 	  if(_current_index==_nb_chunks-1)
 	  {
 	  	
@@ -145,10 +135,12 @@
                         delta*=_wavheader->frequency;
                         delta/=1000.; // mss -> second
                         *samples=(uint32_t)floor(delta);
-                }else *samples=1024;
+                }
+				else
+					*samples=1024;
+
                 printf("[MP4Audio]: Last sample %d current chunk %d nb chunk %d\n",
                                 *samples,_current_index,_nb_chunks);
-                
 	  }
 	  else
 	  {
@@ -159,7 +151,6 @@
 		delta*=_wavheader->frequency;
 		delta/=1000.*1000.; // us -> second
 		*samples=(uint32_t)floor(delta);
-	     
 	  }
 #if 0
           printf("[MP4Audio]Read %u bytes\n", r);



From mean at mail.berlios.de  Sat Jul 19 19:58:17 2008
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sat, 19 Jul 2008 19:58:17 +0200
Subject: [Avidemux-svn-commit] r4249 - in
	branches/avidemux_2.5_branch_gruntster/avidemux:
	ADM_libraries/ADM_ffmpeg/ADM_lavformat ADM_outputs
Message-ID: <200807191758.m6JHwHbC025439@sheep.berlios.de>

Author: mean
Date: 2008-07-19 19:58:16 +0200 (Sat, 19 Jul 2008)
New Revision: 4249

Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_libraries/ADM_ffmpeg/ADM_lavformat/file.c
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_outputs/ADM_lavformat.cpp
Log:
[Merge] r4214 MP4 64 bits output


Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_libraries/ADM_ffmpeg/ADM_lavformat/file.c
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_libraries/ADM_ffmpeg/ADM_lavformat/file.c	2008-07-19 17:58:13 UTC (rev 4248)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_libraries/ADM_ffmpeg/ADM_lavformat/file.c	2008-07-19 17:58:16 UTC (rev 4249)
@@ -30,6 +30,7 @@
 #ifdef __WIN32
 extern int ADM_open(const char *path, int oflag, ...);
 #define open ADM_open
+#define lseek(f,p,w) _lseeki64((f), (p), (w))
 #endif
 // GRUNTSTER end
 

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_outputs/ADM_lavformat.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_outputs/ADM_lavformat.cpp	2008-07-19 17:58:13 UTC (rev 4248)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_outputs/ADM_lavformat.cpp	2008-07-19 17:58:16 UTC (rev 4249)
@@ -528,14 +528,14 @@
         AVPacket pkt;
         double f;
         int64_t timeInUs;
-        static int sz=0;
+        static uint64_t sz = 0;
             //printf("Audio paclet : size %u, sample %u\n",len,sample);
 
            if(!audio_st) return 0;
            if(!len) return 1;
             av_init_packet(&pkt);
             timeInUs=(int64_t)sample2time_us(sample);
-            aprintf("Sample :%u time :%u size :%u this round:%u\n",sample,timeInUs,sz,len);
+            aprintf("Sample: %u, time: %"LLU", size: %"LLU", this round: %u\n",sample, timeInUs, sz, len);
             sz+=len;
             /* Rescale to ?? */
             if(_type==MUXER_FLV || _type==MUXER_MATROSKA) /* The FLV muxer expects packets dated in ms, there is something i did not get... WTF */
@@ -550,8 +550,8 @@
             	f*=_audioFq; // In samples
             	f=floor(f+0.4);
             }
-            pkt.dts=pkt.pts=(int)(f);
-            aprintf("Adm audio dts=:%u\n",pkt.dts);
+            pkt.dts=pkt.pts=f;
+            aprintf("Adm audio dts: %"LLU"\n",pkt.dts);
             //printf("F:%f Q:%u D=%u\n",f,pkt.pts,timeInUs-_lastAudioDts);
 
             pkt.flags |= PKT_FLAG_KEY;
@@ -559,7 +559,7 @@
             pkt.size= len;
             pkt.stream_index=1;
             //pkt.duration=pkt.dts-_lastAudioDts; // Duration
-            aprintf("A: sample: %d frame_pts: %d fq: %d\n",(int32_t )sample,(int32_t )pkt.dts,audio_st->codec->sample_rate);
+            aprintf("A: sample: %d, frame_pts: %"LLU", fq: %d\n", sample, pkt.dts, audio_st->codec->sample_rate);
 
             ret = av_write_frame(oc, &pkt);
             _lastAudioDts=timeInUs;



From mean at mail.berlios.de  Sat Jul 19 19:58:18 2008
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sat, 19 Jul 2008 19:58:18 +0200
Subject: [Avidemux-svn-commit] r4250 -
	branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_mp4
Message-ID: <200807191758.m6JHwI5g025449@sheep.berlios.de>

Author: mean
Date: 2008-07-19 19:58:18 +0200 (Sat, 19 Jul 2008)
New Revision: 4250

Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_mp4/ADM_mp4.cpp
Log:
[Merge] r4215 MP4: Flags


Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_mp4/ADM_mp4.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_mp4/ADM_mp4.cpp	2008-07-19 17:58:16 UTC (rev 4249)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_mp4/ADM_mp4.cpp	2008-07-19 17:58:18 UTC (rev 4250)
@@ -126,6 +126,8 @@
     fseeko(_fd,offset,SEEK_SET);
     fread(img->data, VDEO.index[framenum].size, 1, _fd);
     img->dataLength=VDEO.index[framenum].size;
+	img->flags = VDEO.index[framenum].intra;
+
     return 1;
 }
 MP4Header::~MP4Header()



From mean at mail.berlios.de  Sat Jul 19 19:58:20 2008
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sat, 19 Jul 2008 19:58:20 +0200
Subject: [Avidemux-svn-commit] r4251 -
	branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_mp4
Message-ID: <200807191758.m6JHwKBf025459@sheep.berlios.de>

Author: mean
Date: 2008-07-19 19:58:20 +0200 (Sat, 19 Jul 2008)
New Revision: 4251

Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_mp4/ADM_mp4Analyzer.cpp
Log:
[Merge] 4216 MP4 : Accurate fps


Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_mp4/ADM_mp4Analyzer.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_mp4/ADM_mp4Analyzer.cpp	2008-07-19 17:58:18 UTC (rev 4250)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_mp4/ADM_mp4Analyzer.cpp	2008-07-19 17:58:20 UTC (rev 4251)
@@ -948,7 +948,7 @@
           float f=_videostream.dwLength;
           if(_movieDuration) f=1000000.*f/_movieDuration;
               else  f=25000;
-          _videostream.dwRate=(uint32_t)floor(f);
+          _videostream.dwRate=(uint32_t)floor(f+0.49);
            _mainaviheader.dwMicroSecPerFrame=ADM_UsecFromFps1000(_videostream.dwRate);
           // if we have a sync atom ???
           if(info.nbSync)



From mean at mail.berlios.de  Sat Jul 19 19:58:21 2008
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sat, 19 Jul 2008 19:58:21 +0200
Subject: [Avidemux-svn-commit] r4252 -
	branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_mp4
Message-ID: <200807191758.m6JHwLZC025469@sheep.berlios.de>

Author: mean
Date: 2008-07-19 19:58:21 +0200 (Sat, 19 Jul 2008)
New Revision: 4252

Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_mp4/ADM_mp4audio.cpp
Log:
[Merge] 4217 MP4: VBR map


Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_mp4/ADM_mp4audio.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_mp4/ADM_mp4audio.cpp	2008-07-19 17:58:20 UTC (rev 4251)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_mp4/ADM_mp4audio.cpp	2008-07-19 17:58:21 UTC (rev 4252)
@@ -101,7 +101,7 @@
 //_______________________________________________________
 uint8_t MP4Audio::goTo(uint32_t newoffset)
 {
-   ADM_assert(0);
+   goToTime(0);
     return 1;
 }
 //______________________________________



From mean at mail.berlios.de  Sat Jul 19 19:58:26 2008
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sat, 19 Jul 2008 19:58:26 +0200
Subject: [Avidemux-svn-commit] r4253 - in
	branches/avidemux_2.5_branch_gruntster/avidemux:
	ADM_inputs/ADM_mp4 ADM_libraries/ADM_ffmpeg/ADM_lavformat
Message-ID: <200807191758.m6JHwQ1a025479@sheep.berlios.de>

Author: mean
Date: 2008-07-19 19:58:25 +0200 (Sat, 19 Jul 2008)
New Revision: 4253

Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_mp4/ADM_mp4Analyzer.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_libraries/ADM_ffmpeg/ADM_lavformat/isom.c
Log:
[Merge] r4218, partial merge, the other part should not be needed : Put MP2 into MP4


Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_mp4/ADM_mp4Analyzer.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_mp4/ADM_mp4Analyzer.cpp	2008-07-19 17:58:21 UTC (rev 4252)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_mp4/ADM_mp4Analyzer.cpp	2008-07-19 17:58:25 UTC (rev 4253)
@@ -1040,7 +1040,7 @@
                                       switch(objectTypeIndication)
                                       {
                                           case 0x69:ADIO.encoding=WAV_MP3;break;
-                                          case 0x6b:ADIO.encoding=WAV_MP3;break;
+                                          case 0x6b:ADIO.encoding=WAV_MP2;break;
                                           case 0x6d:ADIO.encoding=WAV_MP3;break;
                                           case 226:ADIO.encoding=WAV_AC3;break;
                                           break;

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_libraries/ADM_ffmpeg/ADM_lavformat/isom.c
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_libraries/ADM_ffmpeg/ADM_lavformat/isom.c	2008-07-19 17:58:21 UTC (rev 4252)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_libraries/ADM_ffmpeg/ADM_lavformat/isom.c	2008-07-19 17:58:25 UTC (rev 4253)
@@ -151,6 +151,7 @@
 
     //MEANX { CODEC_ID_MP3, MKTAG('.', 'm', 'p', '3') }, /* MPEG layer 3 */ /* sample files at http://www.3ivx.com/showcase.html use this tag */
      { CODEC_ID_MP3, MKTAG( 'm', 'p', '4','a') },
+     { CODEC_ID_MP2, MKTAG( 'm', 'p', '4', 'a') },
     // /MEANX
     { CODEC_ID_MP3, 0x6D730055 }, /* MPEG layer 3 */
     { CODEC_ID_MP3, MKTAG('m', 's', 0x00, 0x55) }, /* MPEG layer 3 *//* XXX: check endianness */



From mean at mail.berlios.de  Sat Jul 19 19:58:28 2008
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sat, 19 Jul 2008 19:58:28 +0200
Subject: [Avidemux-svn-commit] r4254 -
	branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_mp4
Message-ID: <200807191758.m6JHwS94025496@sheep.berlios.de>

Author: mean
Date: 2008-07-19 19:58:27 +0200 (Sat, 19 Jul 2008)
New Revision: 4254

Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_mp4/ADM_mp4Analyzer.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_mp4/ADM_mp4audio.cpp
Log:
[Merge] 4220 :improve detection of mp2 auido


Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_mp4/ADM_mp4Analyzer.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_mp4/ADM_mp4Analyzer.cpp	2008-07-19 17:58:25 UTC (rev 4253)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_mp4/ADM_mp4Analyzer.cpp	2008-07-19 17:58:27 UTC (rev 4254)
@@ -1039,9 +1039,11 @@
                                     {
                                       switch(objectTypeIndication)
                                       {
-                                          case 0x69:ADIO.encoding=WAV_MP3;break;
-                                          case 0x6b:ADIO.encoding=WAV_MP2;break;
-                                          case 0x6d:ADIO.encoding=WAV_MP3;break;
+                                          case 0x69:
+                                          case 0x6b:
+                                          case 0x6d:
+											  ADIO.encoding=WAV_MP3;
+											  break;
                                           case 226:ADIO.encoding=WAV_AC3;break;
                                           break;
 

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_mp4/ADM_mp4audio.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_mp4/ADM_mp4audio.cpp	2008-07-19 17:58:25 UTC (rev 4253)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_mp4/ADM_mp4audio.cpp	2008-07-19 17:58:27 UTC (rev 4254)
@@ -47,7 +47,22 @@
 
 	_extraLen=track->extraDataSize;
 	_extraData=track->extraData;
-	
+
+	// Check if MP3 track is actually MP2
+	if (track->_rdWav.encoding == WAV_MP3 && _nb_chunks && _index[0].size >= 4)
+	{
+		uint8_t sample[4];
+
+		fseeko(_fd, _index[0].offset, SEEK_SET);
+		fread(&sample, 1, 4, _fd);
+
+		uint32_t fcc = sample[0] << 24 | sample[1] << 16 | sample[2] << 8 | sample[3];
+		int layer = 4 - ((fcc >> 17) & 0x3);
+
+		if (layer == 2)
+			track->_rdWav.encoding = WAV_MP2;
+	}
+
 	_wavheader=new WAVHeader;
         memcpy(_wavheader,&(track->_rdWav),sizeof(WAVHeader));
 	



From mean at mail.berlios.de  Sat Jul 19 19:58:29 2008
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sat, 19 Jul 2008 19:58:29 +0200
Subject: [Avidemux-svn-commit] r4255 -
	branches/avidemux_2.5_branch_gruntster/avidemux/ADM_libraries/ADM_utilities
Message-ID: <200807191758.m6JHwThF025506@sheep.berlios.de>

Author: mean
Date: 2008-07-19 19:58:29 +0200 (Sat, 19 Jul 2008)
New Revision: 4255

Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_libraries/ADM_utilities/avifmt.h
Log:
[Merge] r4242 : fix size of avi stream header


Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_libraries/ADM_utilities/avifmt.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_libraries/ADM_utilities/avifmt.h	2008-07-19 17:58:27 UTC (rev 4254)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_libraries/ADM_utilities/avifmt.h	2008-07-19 17:58:29 UTC (rev 4255)
@@ -21,13 +21,6 @@
 
 #define MAKELONG(low,high)     ((int32_t)(((uint16_t)(low)) | (((uint32_t)((uint16_t)(high))) << 16)))
 
-typedef struct __attribute__((__packed__))
-{
-    int16_t	left;
-    int16_t	top;
-    int16_t	right;
-    int16_t	bottom;
-} RECT, *PRECT, *LPRECT;
 #endif // __WINE_WINDEF_H
 
 #ifdef _MSC_VER
@@ -209,20 +202,25 @@
 
 typedef struct  __attribute__((__packed__))
 {
-    uint32_t	fccType;
-    uint32_t	fccHandler;
-    int32_t	dwFlags;	/* Contains AVITF_* flags */
-    int16_t	wPriority;	/* dwPriority - splited for audio */
-    int16_t	wLanguage;
-    int32_t	dwInitialFrames;
-    int32_t	dwScale;
-    int32_t	dwRate;		/* dwRate / dwScale == samples/second */
-    int32_t	dwStart;
-    int32_t	dwLength;	/* In units above... */
-    int32_t	dwSuggestedBufferSize;
-    int32_t	dwQuality;
-    int32_t	dwSampleSize;
-    RECT	rcFrame;
+	uint32_t	fccType;
+	uint32_t	fccHandler;
+	int32_t	dwFlags;	/* Contains AVITF_* flags */
+	int16_t	wPriority;	/* dwPriority - splited for audio */
+	int16_t	wLanguage;
+	int32_t	dwInitialFrames;
+	int32_t	dwScale;
+	int32_t	dwRate;		/* dwRate / dwScale == samples/second */
+	int32_t	dwStart;
+	int32_t	dwLength;	/* In units above... */
+	int32_t	dwSuggestedBufferSize;
+	int32_t	dwQuality;
+	int32_t	dwSampleSize;
+	struct {
+		int16_t left;
+		int16_t top;
+		int16_t right;
+		int16_t bottom;
+	} rcFrame;
 } AVIStreamHeader;
 
 /* Flags for index */



From mean at mail.berlios.de  Sat Jul 19 19:58:31 2008
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sat, 19 Jul 2008 19:58:31 +0200
Subject: [Avidemux-svn-commit] r4256 -
	branches/avidemux_2.5_branch_gruntster/avidemux/ADM_core/src
Message-ID: <200807191758.m6JHwVAL025516@sheep.berlios.de>

Author: mean
Date: 2008-07-19 19:58:31 +0200 (Sat, 19 Jul 2008)
New Revision: 4256

Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_core/src/ADM_win32.cpp
Log:
[Merge] 4210 : Win32 : prevent crash if log file does not open


Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_core/src/ADM_win32.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_core/src/ADM_win32.cpp	2008-07-19 17:58:29 UTC (rev 4255)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_core/src/ADM_win32.cpp	2008-07-19 17:58:31 UTC (rev 4256)
@@ -400,14 +400,10 @@
 	// This allows us to optionally compile all EXEs as console applications
 	// so the output can be printed to the terminal for debugging purposes.
 
-	// Close SDL generated logs
-	fclose(stdout);
-	fclose(stderr);
+ 	// Close SDL generated logs and briefly redirect to NUL
+ 	freopen("NUL", "w", stdout);
+ 	freopen("NUL", "w", stderr);
 
-	// Briefly redirect to console
-	freopen("CON", "w", stdout);
-	freopen("CON", "w", stderr);
-
 	// Remove SDL logs to avoid confusion
 	char path[MAX_PATH];
 	char stdoutPath[MAX_PATH];
@@ -431,19 +427,18 @@
 	const char* logFile = "admlog.txt";
 	char* baseDir = ADM_getBaseDir();
 	char *logPath = new char[strlen(baseDir) + 2 + strlen(logFile)];
-	FILE* stream;
 
 	strcpy(logPath, baseDir);
 	strcat(logPath, "/");
 	strcat(logPath, logFile);
 
-	fclose(stdout);
-	fclose(stderr);
+	FILE *stream = fopen(logPath, "w");
 
-	stream = fopen(logPath, "w");
-
 	if (stream)
 	{
+		fclose(stdout);
+		fclose(stderr);
+
 		*stdout = *stream;
 		*stderr = *stream;
 	}



From mean at mail.berlios.de  Sun Jul 20 09:17:06 2008
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sun, 20 Jul 2008 09:17:06 +0200
Subject: [Avidemux-svn-commit] r4257 -
	branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec
Message-ID: <200807200717.m6K7H6ta023792@sheep.berlios.de>

Author: mean
Date: 2008-07-20 09:17:05 +0200 (Sun, 20 Jul 2008)
New Revision: 4257

Added:
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/rawdec.c
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/rawenc.c
Modified:
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/CMakeLists.txt
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/Makefile.am
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/ffconf.c
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/ffconf.h
Log:
[Codec] Support for y800 codec (patch by compholio)

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/CMakeLists.txt
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/CMakeLists.txt	2008-07-19 17:58:31 UTC (rev 4256)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/CMakeLists.txt	2008-07-20 07:17:05 UTC (rev 4257)
@@ -32,6 +32,7 @@
                 dvbsubdec.c
                 dvbsub.c xiph.c
                 sp5xdec.c nellymoserdec.c
+                rawdec.c rawenc.c
 )
 # ADD x86 ones
 

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/Makefile.am
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/Makefile.am	2008-07-19 17:58:31 UTC (rev 4256)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/Makefile.am	2008-07-20 07:17:05 UTC (rev 4257)
@@ -49,6 +49,7 @@
 		jfdctfst.c 	jfdctint.c 	jrevdct.c 	mace.c 	mdct.c 	 	mjpeg.c \
 		motion_est.c 	mpeg12.c 	mpegaudio.c 	mpegaudiodec.c 	mpegvideo.c 	msmpeg4.c 	 \
 		pcm.c 	ratecontrol.c 	raw.c 	resample.c 	rv10.c 	simple_idct.c 	svq1.c \
+		rawdec.c rawenc.c \
 		utils.c 	wmadec.c 	indeo3.c 	vp3.c 	vp3dsp.c 	h264.c 	ffv1.c 	ra144.c 	ra288.c \
 		golomb.c 	4xm.c 	cabac.c 	asv1.c vcr1.c cljr.c 	faandct.c 	 	parser.c \
 		roqvideo.c 	xan.c 	rpza.c 	msrle.c 	msvideo1.c 	cinepak.c 	vqavideo.c \
@@ -101,6 +102,7 @@
 beosthread.c    flac.c      mem.c      rangecoder.c w32thread.c \
 bitstream.c   flacenc.c     mjpeg.c      ratecontrol.c  wmadec.c \
 bitstream_filter.c  flashsv.c     mmvideo.c      raw.c    wmv2.c \
+rawdec.c rawenc.c \
 bmp.c     flicvideo.c   motion_est.c     resample.c   wnv1.c \
 cabac.c     fraps.c     motion_est_template.c  resample2.c  ws-snd1.c \
 cavs.c      g726.c      motion_test.c    roqvideo.c   x264.c \

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/ffconf.c
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/ffconf.c	2008-07-19 17:58:31 UTC (rev 4256)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/ffconf.c	2008-07-20 07:17:05 UTC (rev 4257)
@@ -54,6 +54,7 @@
     DECLARE_DECODER (FLV, flv);
     DECLARE_DECODER (SNOW, snow);
     DECLARE_DECODER (AMV, amv);
+    DECLARE_DECODER (RAWVIDEO, rawvideo);
 #undef DECLARE_DECODER
 #define DECLARE_DECODER(a,b); printf("#define ENABLE_"#a"_DECODER 0\n"); 
 
@@ -137,7 +138,6 @@
     DECLARE_DECODER (JPEGLS, jpegls);
     DECLARE_DECODER (PNG, png);
     DECLARE_DECODER (QTRLE, qtrle);
-    DECLARE_DECODER (RAWVIDEO, rawvideo);
     DECLARE_DECODER (ROQ, roq);
     DECLARE_DECODER (SGI, sgi);
     DECLARE_DECODER (SVQ1, svq1);
@@ -235,6 +235,7 @@
     DECLARE_ENCODER (HUFFYUV, huffyuv);
     DECLARE_ENCODER (DVBSUB, dvbsub);
     DECLARE_ENCODER (SNOW, snow);
+    DECLARE_ENCODER (RAWVIDEO, rawvideo);
 
 #undef DECLARE_ENCODER
 #define DECLARE_ENCODER(a,b); printf("#define ENABLE_"#a"_ENCODER 0\n"); 
@@ -263,7 +264,6 @@
     DECLARE_ENCODER (MSMPEG4V2, msmpeg4v2);
     DECLARE_ENCODER (PNG, png);
     DECLARE_ENCODER (QTRLE, qtrle);
-    DECLARE_ENCODER (RAWVIDEO, rawvideo);
     DECLARE_ENCODER (ROQ, roq);
     DECLARE_ENCODER (RV10, rv10);
     DECLARE_ENCODER (RV20, rv20);

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/ffconf.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/ffconf.h	2008-07-19 17:58:31 UTC (rev 4256)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/ffconf.h	2008-07-20 07:17:05 UTC (rev 4257)
@@ -1,321 +1,321 @@
-#include "config.h"
-
-#define ENABLE_NELLYMOSER_DECODER 1
-#define ENABLE_ADPCM_IMA_AMV_DECODER 1
-#define ENABLE_CINEPAK_DECODER 1
-#define ENABLE_DNXHD_DECODER 1
-#define ENABLE_FOURXM_DECODER 1
-#define ENABLE_FRAPS_DECODER 1
-#define ENABLE_H263_DECODER 1
-#define ENABLE_H264_DECODER 1
-#define ENABLE_INDEO2_DECODER 1
-#define ENABLE_INDEO3_DECODER 1
-#define ENABLE_INTERPLAY_VIDEO_DECODER 1
-#define ENABLE_MPEGVIDEO_DECODER 1
-#define ENABLE_MSVIDEO1_DECODER 1
-#define ENABLE_VC1_DECODER 1
-#define ENABLE_VCR1_DECODER 1
-#define ENABLE_VP5_DECODER 1
-#define ENABLE_VP6_DECODER 1
-#define ENABLE_VP6F_DECODER 1
-#define ENABLE_WMV3_DECODER 1
-#define ENABLE_WMV1_DECODER 1
-#define ENABLE_WMV2_DECODER 1
-#define ENABLE_VP3_DECODER 1
-#define ENABLE_MPEG4_DECODER 1
-#define ENABLE_MSMPEG4V1_DECODER 1
-#define ENABLE_MSMPEG4V2_DECODER 1
-#define ENABLE_MSMPEG4V3_DECODER 1
-#define ENABLE_MJPEGB_DECODER 1
-#define ENABLE_MJPEG_DECODER 1
-#define ENABLE_WMAV2_DECODER 1
-#define ENABLE_DVVIDEO_DECODER 1
-#define ENABLE_HUFFYUV_DECODER 1
-#define ENABLE_FFVHUFF_DECODER 1
-#define ENABLE_SVQ3_DECODER 1
-#define ENABLE_TSCC_DECODER 1
-#define ENABLE_QDM2_DECODER 1
-#define ENABLE_FFV1_DECODER 1
-#define ENABLE_MPEG1VIDEO_DECODER 1
-#define ENABLE_MPEG2VIDEO_DECODER 1
-#define ENABLE_RV10_DECODER 1
-#define ENABLE_RV20_DECODER 1
-#define ENABLE_DVBSUB_DECODER 1
-#define ENABLE_FLV_DECODER 1
-#define ENABLE_SNOW_DECODER 1
-#define ENABLE_AMV_DECODER 1
-#define ENABLE_AASC_DECODER 0
-#define ENABLE_AVS_DECODER 0
-#define ENABLE_BETHSOFTVID_DECODER 0
-#define ENABLE_C93_DECODER 0
-#define ENABLE_CAVS_DECODER 0
-#define ENABLE_CLJR_DECODER 0
-#define ENABLE_CSCD_DECODER 0
-#define ENABLE_CYUV_DECODER 0
-#define ENABLE_DSICINVIDEO_DECODER 0
-#define ENABLE_DXA_DECODER 0
-#define ENABLE_EIGHTBPS_DECODER 0
-#define ENABLE_FLIC_DECODER 0
-#define ENABLE_IDCIN_DECODER 0
-#define ENABLE_KMVC_DECODER 0
-#define ENABLE_LOCO_DECODER 0
-#define ENABLE_MDEC_DECODER 0
-#define ENABLE_MMVIDEO_DECODER 0
-#define ENABLE_MPEG_XVMC_DECODER 0
-#define ENABLE_MSRLE_DECODER 0
-#define ENABLE_MSZH_DECODER 0
-#define ENABLE_NUV_DECODER 0
-#define ENABLE_PTX_DECODER 0
-#define ENABLE_QDRAW_DECODER 0
-#define ENABLE_QPEG_DECODER 0
-#define ENABLE_RPZA_DECODER 0
-#define ENABLE_SMACKER_DECODER 0
-#define ENABLE_SMC_DECODER 0
-#define ENABLE_SP5X_DECODER 0
-#define ENABLE_THEORA_DECODER 0
-#define ENABLE_THP_DECODER 0
-#define ENABLE_TIERTEXSEQVIDEO_DECODER 0
-#define ENABLE_TRUEMOTION1_DECODER 0
-#define ENABLE_TRUEMOTION2_DECODER 0
-#define ENABLE_TXD_DECODER 0
-#define ENABLE_ULTI_DECODER 0
-#define ENABLE_VMDVIDEO_DECODER 0
-#define ENABLE_VMNC_DECODER 0
-#define ENABLE_VQA_DECODER 0
-#define ENABLE_WNV1_DECODER 0
-#define ENABLE_XAN_WC3_DECODER 0
-#define ENABLE_XL_DECODER 0
-#define ENABLE_MPEG4AAC_DECODER 0
-#define ENABLE_ALAC_DECODER 0
-#define ENABLE_ATRAC3_DECODER 0
-#define ENABLE_COOK_DECODER 0
-#define ENABLE_DCA_DECODER 0
-#define ENABLE_DSICINAUDIO_DECODER 0
-#define ENABLE_IMC_DECODER 0
-#define ENABLE_LIBA52_DECODER 0
-#define ENABLE_LIBFAAD_DECODER 0
-#define ENABLE_MACE3_DECODER 0
-#define ENABLE_MACE6_DECODER 0
-#define ENABLE_MP3_DECODER 0
-#define ENABLE_MP3ADU_DECODER 0
-#define ENABLE_MP3ON4_DECODER 0
-#define ENABLE_MPC7_DECODER 0
-#define ENABLE_RA_144_DECODER 0
-#define ENABLE_RA_288_DECODER 0
-#define ENABLE_SHORTEN_DECODER 0
-#define ENABLE_SMACKAUD_DECODER 0
-#define ENABLE_TRUESPEECH_DECODER 0
-#define ENABLE_TTA_DECODER 0
-#define ENABLE_VMDAUDIO_DECODER 0
-#define ENABLE_WAVPACK_DECODER 0
-#define ENABLE_WS_SND1_DECODER 0
-#define ENABLE_INTERPLAY_DPCM_DECODER 0
-#define ENABLE_SOL_DPCM_DECODER 0
-#define ENABLE_XAN_DPCM_DECODER 0
-#define ENABLE_ADPCM_THP_DECODER 0
-#define ENABLE_ASV1_DECODER 0
-#define ENABLE_ASV2_DECODER 0
-#define ENABLE_BMP_DECODER 0
-#define ENABLE_FLASHSV_DECODER 0
-#define ENABLE_GIF_DECODER 0
-#define ENABLE_H261_DECODER 0
-#define ENABLE_H263I_DECODER 0
-#define ENABLE_JPEGLS_DECODER 0
-#define ENABLE_PNG_DECODER 0
-#define ENABLE_QTRLE_DECODER 0
-#define ENABLE_RAWVIDEO_DECODER 0
-#define ENABLE_ROQ_DECODER 0
-#define ENABLE_SGI_DECODER 0
-#define ENABLE_SVQ1_DECODER 0
-#define ENABLE_TARGA_DECODER 0
-#define ENABLE_TIFF_DECODER 0
-#define ENABLE_ZLIB_DECODER 0
-#define ENABLE_ZMBV_DECODER 0
-#define ENABLE_FLAC_DECODER 0
-#define ENABLE_LIBAMR_WB_DECODER 0
-#define ENABLE_LIBGSM_DECODER 0
-#define ENABLE_LIBGSM_MS_DECODER 0
-#define ENABLE_MP2_DECODER 0
-#define ENABLE_SONIC_DECODER 0
-#define ENABLE_VORBIS_DECODER 0
-#define ENABLE_WMAV1_DECODER 0
-#define ENABLE_PCM_ALAW_DECODER 0
-#define ENABLE_PCM_MULAW_DECODER 0
-#define ENABLE_PCM_S8_DECODER 0
-#define ENABLE_PCM_S16BE_DECODER 0
-#define ENABLE_PCM_S16LE_DECODER 0
-#define ENABLE_PCM_S24BE_DECODER 0
-#define ENABLE_PCM_S24DAUD_DECODER 0
-#define ENABLE_PCM_S24LE_DECODER 0
-#define ENABLE_PCM_S32BE_DECODER 0
-#define ENABLE_PCM_S32LE_DECODER 0
-#define ENABLE_PCM_U8_DECODER 0
-#define ENABLE_PCM_U16BE_DECODER 0
-#define ENABLE_PCM_U16LE_DECODER 0
-#define ENABLE_PCM_U24BE_DECODER 0
-#define ENABLE_PCM_U24LE_DECODER 0
-#define ENABLE_PCM_U32BE_DECODER 0
-#define ENABLE_PCM_U32LE_DECODER 0
-#define ENABLE_ROQ_DPCM_DECODER 0
-#define ENABLE_ADPCM_4XM_DECODER 0
-#define ENABLE_ADPCM_ADX_DECODER 0
-#define ENABLE_ADPCM_CT_DECODER 0
-#define ENABLE_ADPCM_EA_DECODER 0
-#define ENABLE_ADPCM_G726_DECODER 0
-#define ENABLE_ADPCM_IMA_DK3_DECODER 0
-#define ENABLE_ADPCM_IMA_DK4_DECODER 0
-#define ENABLE_ADPCM_IMA_QT_DECODER 0
-#define ENABLE_ADPCM_IMA_SMJPEG_DECODER 0
-#define ENABLE_ADPCM_IMA_WAV_DECODER 0
-#define ENABLE_ADPCM_IMA_WS_DECODER 0
-#define ENABLE_ADPCM_MS_DECODER 0
-#define ENABLE_ADPCM_SBPRO_2_DECODER 0
-#define ENABLE_ADPCM_SBPRO_3_DECODER 0
-#define ENABLE_ADPCM_SBPRO_4_DECODER 0
-#define ENABLE_ADPCM_SWF_DECODER 0
-#define ENABLE_ADPCM_XA_DECODER 0
-#define ENABLE_ADPCM_YAMAHA_DECODER 0
-#define ENABLE_DVDSUB_DECODER 0
-#ifdef USE_AMR_NB
-#define ENABLE_LIBAMR_NB_DECODER 1
-#else
-#define ENABLE_LIBAMR_NB_DECODER 0
-#endif
-#define ENABLE_H263_PARSER 1
-#define ENABLE_H264_PARSER 1
-#define ENABLE_MPEG4VIDEO_PARSER 1
-#define ENABLE_AAC_PARSER 0
-#define ENABLE_AC3_PARSER 0
-#define ENABLE_CAVSVIDEO_PARSER 0
-#define ENABLE_DCA_PARSER 0
-#define ENABLE_DVBSUB_PARSER 0
-#define ENABLE_DVDSUB_PARSER 0
-#define ENABLE_H261_PARSER 0
-#define ENABLE_MJPEG_PARSER 0
-#define ENABLE_MPEGAUDIO_PARSER 0
-#define ENABLE_MPEGVIDEO_PARSER 0
-#define ENABLE_PNM_PARSER 0
-#define ENABLE_VC1_PARSER 0
-#define ENABLE_MJPEG_ENCODER 1
-#define ENABLE_MSMPEG4V3_ENCODER 1
-#define ENABLE_H263P_ENCODER 1
-#define ENABLE_AC3_ENCODER 1
-#define ENABLE_FFV1_ENCODER 1
-#define ENABLE_FLV1_ENCODER 1
-#define ENABLE_FFVHUFF_ENCODER 1
-#define ENABLE_H263_ENCODER 1
-#define ENABLE_MPEG1VIDEO_ENCODER 1
-#define ENABLE_MPEG2VIDEO_ENCODER 1
-#define ENABLE_MPEG4_ENCODER 1
-#define ENABLE_FLV_ENCODER 1
-#define ENABLE_MP2_ENCODER 1
-#define ENABLE_DVVIDEO_ENCODER 1
-#define ENABLE_HUFFYUV_ENCODER 1
-#define ENABLE_DVBSUB_ENCODER 1
-#define ENABLE_SNOW_ENCODER 1
-#define ENABLE_ADPCM_IMA_AMV_ENCODER 0
-#define ENABLE_LIBX264_ENCODER 0
-#define ENABLE_LIBXVID_ENCODER 0
-#define ENABLE_LJPEG_ENCODER 0
-#define ENABLE_PAM_ENCODER 0
-#define ENABLE_PBM_ENCODER 0
-#define ENABLE_PGM_ENCODER 0
-#define ENABLE_PGMYUV_ENCODER 0
-#define ENABLE_PPM_ENCODER 0
-#define ENABLE_LIBFAAC_ENCODER 0
-#define ENABLE_LIBMP3LAME_ENCODER 0
-#define ENABLE_LIBTHEORA_ENCODER 0
-#define ENABLE_SONIC_LS_ENCODER 0
-#define ENABLE_ASV1_ENCODER 0
-#define ENABLE_ASV2_ENCODER 0
-#define ENABLE_BMP_ENCODER 0
-#define ENABLE_FLASHSV_ENCODER 0
-#define ENABLE_GIF_ENCODER 0
-#define ENABLE_H261_ENCODER 0
-#define ENABLE_JPEGLS_ENCODER 0
-#define ENABLE_MSMPEG4V1_ENCODER 0
-#define ENABLE_MSMPEG4V2_ENCODER 0
-#define ENABLE_PNG_ENCODER 0
-#define ENABLE_QTRLE_ENCODER 0
-#define ENABLE_RAWVIDEO_ENCODER 0
-#define ENABLE_ROQ_ENCODER 0
-#define ENABLE_RV10_ENCODER 0
-#define ENABLE_RV20_ENCODER 0
-#define ENABLE_SGI_ENCODER 0
-#define ENABLE_SVQ1_ENCODER 0
-#define ENABLE_TARGA_ENCODER 0
-#define ENABLE_TIFF_ENCODER 0
-#define ENABLE_WMV1_ENCODER 0
-#define ENABLE_WMV2_ENCODER 0
-#define ENABLE_ZLIB_ENCODER 0
-#define ENABLE_ZMBV_ENCODER 0
-#define ENABLE_FLAC_ENCODER 0
-#define ENABLE_LIBAMR_NB_ENCODER 0
-#define ENABLE_LIBAMR_WB_ENCODER 0
-#define ENABLE_LIBGSM_ENCODER 0
-#define ENABLE_LIBGSM_MS_ENCODER 0
-#define ENABLE_SONIC_ENCODER 0
-#define ENABLE_VORBIS_ENCODER 0
-#define ENABLE_WMAV1_ENCODER 0
-#define ENABLE_WMAV2_ENCODER 0
-#define ENABLE_PCM_ALAW_ENCODER 0
-#define ENABLE_PCM_MULAW_ENCODER 0
-#define ENABLE_PCM_S8_ENCODER 0
-#define ENABLE_PCM_S16BE_ENCODER 0
-#define ENABLE_PCM_S16LE_ENCODER 0
-#define ENABLE_PCM_S24BE_ENCODER 0
-#define ENABLE_PCM_S24DAUD_ENCODER 0
-#define ENABLE_PCM_S24LE_ENCODER 0
-#define ENABLE_PCM_S32BE_ENCODER 0
-#define ENABLE_PCM_S32LE_ENCODER 0
-#define ENABLE_PCM_U8_ENCODER 0
-#define ENABLE_PCM_U16BE_ENCODER 0
-#define ENABLE_PCM_U16LE_ENCODER 0
-#define ENABLE_PCM_U24BE_ENCODER 0
-#define ENABLE_PCM_U24LE_ENCODER 0
-#define ENABLE_PCM_U32BE_ENCODER 0
-#define ENABLE_PCM_U32LE_ENCODER 0
-#define ENABLE_ROQ_DPCM_ENCODER 0
-#define ENABLE_ADPCM_4XM_ENCODER 0
-#define ENABLE_ADPCM_ADX_ENCODER 0
-#define ENABLE_ADPCM_CT_ENCODER 0
-#define ENABLE_ADPCM_EA_ENCODER 0
-#define ENABLE_ADPCM_G726_ENCODER 0
-#define ENABLE_ADPCM_IMA_DK3_ENCODER 0
-#define ENABLE_ADPCM_IMA_DK4_ENCODER 0
-#define ENABLE_ADPCM_IMA_QT_ENCODER 0
-#define ENABLE_ADPCM_IMA_SMJPEG_ENCODER 0
-#define ENABLE_ADPCM_IMA_WAV_ENCODER 0
-#define ENABLE_ADPCM_IMA_WS_ENCODER 0
-#define ENABLE_ADPCM_MS_ENCODER 0
-#define ENABLE_ADPCM_SBPRO_2_ENCODER 0
-#define ENABLE_ADPCM_SBPRO_3_ENCODER 0
-#define ENABLE_ADPCM_SBPRO_4_ENCODER 0
-#define ENABLE_ADPCM_SWF_ENCODER 0
-#define ENABLE_ADPCM_XA_ENCODER 0
-#define ENABLE_ADPCM_YAMAHA_ENCODER 0
-#define ENABLE_DVDSUB_ENCODER 0
-#define ENABLE_LIBVORBIS_ENCODER        0
-#define ENABLE_LIBVORBIS_DECODER        0
-#define ENABLE_MP3_HEADER_COMPRESS_BSF  0
-#define ENABLE_IMX_DUMP_HEADER_BSF      0
-#define ENABLE_DUMP_EXTRADATA_BSF       0
-#define ENABLE_REMOVE_EXTRADATA_BSF     0
-#define ENABLE_NOISE_BSF                0
-#define ENABLE_MP3_HEADER_DECOMPRESS_BSF 0
-#define ENABLE_MJPEGA_DUMP_HEADER_BSF   0
-#define ENABLE_IMX_DUMP_HEADER_BSF      0
-#define ENABLE_ARMV4L      0
-#define ENABLE_MLIB      0
-#define ENABLE_SPARC      0
-#define ENABLE_ALPHA      0
-#ifdef ARCH_POWERPC
-#define ENABLE_POWERPC      1
-#else
-#define ENABLE_POWERPC      0
-#endif
-#define ENABLE_MMI      0
-#define ENABLE_SH4      0
-#define ENABLE_BFIN      0
-#define ENABLE_SMALL      0
-#define CONFIG_SNOW_ENCODER      1
+#include "config.h"
+
+#define ENABLE_NELLYMOSER_DECODER 1
+#define ENABLE_ADPCM_IMA_AMV_DECODER 1
+#define ENABLE_CINEPAK_DECODER 1
+#define ENABLE_DNXHD_DECODER 1
+#define ENABLE_FOURXM_DECODER 1
+#define ENABLE_FRAPS_DECODER 1
+#define ENABLE_H263_DECODER 1
+#define ENABLE_H264_DECODER 1
+#define ENABLE_INDEO2_DECODER 1
+#define ENABLE_INDEO3_DECODER 1
+#define ENABLE_INTERPLAY_VIDEO_DECODER 1
+#define ENABLE_MPEGVIDEO_DECODER 1
+#define ENABLE_MSVIDEO1_DECODER 1
+#define ENABLE_VC1_DECODER 1
+#define ENABLE_VCR1_DECODER 1
+#define ENABLE_VP5_DECODER 1
+#define ENABLE_VP6_DECODER 1
+#define ENABLE_VP6F_DECODER 1
+#define ENABLE_WMV3_DECODER 1
+#define ENABLE_WMV1_DECODER 1
+#define ENABLE_WMV2_DECODER 1
+#define ENABLE_VP3_DECODER 1
+#define ENABLE_MPEG4_DECODER 1
+#define ENABLE_MSMPEG4V1_DECODER 1
+#define ENABLE_MSMPEG4V2_DECODER 1
+#define ENABLE_MSMPEG4V3_DECODER 1
+#define ENABLE_MJPEGB_DECODER 1
+#define ENABLE_MJPEG_DECODER 1
+#define ENABLE_WMAV2_DECODER 1
+#define ENABLE_DVVIDEO_DECODER 1
+#define ENABLE_HUFFYUV_DECODER 1
+#define ENABLE_FFVHUFF_DECODER 1
+#define ENABLE_SVQ3_DECODER 1
+#define ENABLE_TSCC_DECODER 1
+#define ENABLE_QDM2_DECODER 1
+#define ENABLE_FFV1_DECODER 1
+#define ENABLE_MPEG1VIDEO_DECODER 1
+#define ENABLE_MPEG2VIDEO_DECODER 1
+#define ENABLE_RV10_DECODER 1
+#define ENABLE_RV20_DECODER 1
+#define ENABLE_DVBSUB_DECODER 1
+#define ENABLE_FLV_DECODER 1
+#define ENABLE_SNOW_DECODER 1
+#define ENABLE_AMV_DECODER 1
+#define ENABLE_RAWVIDEO_DECODER 1
+#define ENABLE_AASC_DECODER 0
+#define ENABLE_AVS_DECODER 0
+#define ENABLE_BETHSOFTVID_DECODER 0
+#define ENABLE_C93_DECODER 0
+#define ENABLE_CAVS_DECODER 0
+#define ENABLE_CLJR_DECODER 0
+#define ENABLE_CSCD_DECODER 0
+#define ENABLE_CYUV_DECODER 0
+#define ENABLE_DSICINVIDEO_DECODER 0
+#define ENABLE_DXA_DECODER 0
+#define ENABLE_EIGHTBPS_DECODER 0
+#define ENABLE_FLIC_DECODER 0
+#define ENABLE_IDCIN_DECODER 0
+#define ENABLE_KMVC_DECODER 0
+#define ENABLE_LOCO_DECODER 0
+#define ENABLE_MDEC_DECODER 0
+#define ENABLE_MMVIDEO_DECODER 0
+#define ENABLE_MPEG_XVMC_DECODER 0
+#define ENABLE_MSRLE_DECODER 0
+#define ENABLE_MSZH_DECODER 0
+#define ENABLE_NUV_DECODER 0
+#define ENABLE_PTX_DECODER 0
+#define ENABLE_QDRAW_DECODER 0
+#define ENABLE_QPEG_DECODER 0
+#define ENABLE_RPZA_DECODER 0
+#define ENABLE_SMACKER_DECODER 0
+#define ENABLE_SMC_DECODER 0
+#define ENABLE_SP5X_DECODER 0
+#define ENABLE_THEORA_DECODER 0
+#define ENABLE_THP_DECODER 0
+#define ENABLE_TIERTEXSEQVIDEO_DECODER 0
+#define ENABLE_TRUEMOTION1_DECODER 0
+#define ENABLE_TRUEMOTION2_DECODER 0
+#define ENABLE_TXD_DECODER 0
+#define ENABLE_ULTI_DECODER 0
+#define ENABLE_VMDVIDEO_DECODER 0
+#define ENABLE_VMNC_DECODER 0
+#define ENABLE_VQA_DECODER 0
+#define ENABLE_WNV1_DECODER 0
+#define ENABLE_XAN_WC3_DECODER 0
+#define ENABLE_XL_DECODER 0
+#define ENABLE_MPEG4AAC_DECODER 0
+#define ENABLE_ALAC_DECODER 0
+#define ENABLE_ATRAC3_DECODER 0
+#define ENABLE_COOK_DECODER 0
+#define ENABLE_DCA_DECODER 0
+#define ENABLE_DSICINAUDIO_DECODER 0
+#define ENABLE_IMC_DECODER 0
+#define ENABLE_LIBA52_DECODER 0
+#define ENABLE_LIBFAAD_DECODER 0
+#define ENABLE_MACE3_DECODER 0
+#define ENABLE_MACE6_DECODER 0
+#define ENABLE_MP3_DECODER 0
+#define ENABLE_MP3ADU_DECODER 0
+#define ENABLE_MP3ON4_DECODER 0
+#define ENABLE_MPC7_DECODER 0
+#define ENABLE_RA_144_DECODER 0
+#define ENABLE_RA_288_DECODER 0
+#define ENABLE_SHORTEN_DECODER 0
+#define ENABLE_SMACKAUD_DECODER 0
+#define ENABLE_TRUESPEECH_DECODER 0
+#define ENABLE_TTA_DECODER 0
+#define ENABLE_VMDAUDIO_DECODER 0
+#define ENABLE_WAVPACK_DECODER 0
+#define ENABLE_WS_SND1_DECODER 0
+#define ENABLE_INTERPLAY_DPCM_DECODER 0
+#define ENABLE_SOL_DPCM_DECODER 0
+#define ENABLE_XAN_DPCM_DECODER 0
+#define ENABLE_ADPCM_THP_DECODER 0
+#define ENABLE_ASV1_DECODER 0
+#define ENABLE_ASV2_DECODER 0
+#define ENABLE_BMP_DECODER 0
+#define ENABLE_FLASHSV_DECODER 0
+#define ENABLE_GIF_DECODER 0
+#define ENABLE_H261_DECODER 0
+#define ENABLE_H263I_DECODER 0
+#define ENABLE_JPEGLS_DECODER 0
+#define ENABLE_PNG_DECODER 0
+#define ENABLE_QTRLE_DECODER 0
+#define ENABLE_ROQ_DECODER 0
+#define ENABLE_SGI_DECODER 0
+#define ENABLE_SVQ1_DECODER 0
+#define ENABLE_TARGA_DECODER 0
+#define ENABLE_TIFF_DECODER 0
+#define ENABLE_ZLIB_DECODER 0
+#define ENABLE_ZMBV_DECODER 0
+#define ENABLE_FLAC_DECODER 0
+#define ENABLE_LIBAMR_WB_DECODER 0
+#define ENABLE_LIBGSM_DECODER 0
+#define ENABLE_LIBGSM_MS_DECODER 0
+#define ENABLE_MP2_DECODER 0
+#define ENABLE_SONIC_DECODER 0
+#define ENABLE_VORBIS_DECODER 0
+#define ENABLE_WMAV1_DECODER 0
+#define ENABLE_PCM_ALAW_DECODER 0
+#define ENABLE_PCM_MULAW_DECODER 0
+#define ENABLE_PCM_S8_DECODER 0
+#define ENABLE_PCM_S16BE_DECODER 0
+#define ENABLE_PCM_S16LE_DECODER 0
+#define ENABLE_PCM_S24BE_DECODER 0
+#define ENABLE_PCM_S24DAUD_DECODER 0
+#define ENABLE_PCM_S24LE_DECODER 0
+#define ENABLE_PCM_S32BE_DECODER 0
+#define ENABLE_PCM_S32LE_DECODER 0
+#define ENABLE_PCM_U8_DECODER 0
+#define ENABLE_PCM_U16BE_DECODER 0
+#define ENABLE_PCM_U16LE_DECODER 0
+#define ENABLE_PCM_U24BE_DECODER 0
+#define ENABLE_PCM_U24LE_DECODER 0
+#define ENABLE_PCM_U32BE_DECODER 0
+#define ENABLE_PCM_U32LE_DECODER 0
+#define ENABLE_ROQ_DPCM_DECODER 0
+#define ENABLE_ADPCM_4XM_DECODER 0
+#define ENABLE_ADPCM_ADX_DECODER 0
+#define ENABLE_ADPCM_CT_DECODER 0
+#define ENABLE_ADPCM_EA_DECODER 0
+#define ENABLE_ADPCM_G726_DECODER 0
+#define ENABLE_ADPCM_IMA_DK3_DECODER 0
+#define ENABLE_ADPCM_IMA_DK4_DECODER 0
+#define ENABLE_ADPCM_IMA_QT_DECODER 0
+#define ENABLE_ADPCM_IMA_SMJPEG_DECODER 0
+#define ENABLE_ADPCM_IMA_WAV_DECODER 0
+#define ENABLE_ADPCM_IMA_WS_DECODER 0
+#define ENABLE_ADPCM_MS_DECODER 0
+#define ENABLE_ADPCM_SBPRO_2_DECODER 0
+#define ENABLE_ADPCM_SBPRO_3_DECODER 0
+#define ENABLE_ADPCM_SBPRO_4_DECODER 0
+#define ENABLE_ADPCM_SWF_DECODER 0
+#define ENABLE_ADPCM_XA_DECODER 0
+#define ENABLE_ADPCM_YAMAHA_DECODER 0
+#define ENABLE_DVDSUB_DECODER 0
+#ifdef USE_AMR_NB
+#define ENABLE_LIBAMR_NB_DECODER 1
+#else
+#define ENABLE_LIBAMR_NB_DECODER 0
+#endif
+#define ENABLE_H263_PARSER 1
+#define ENABLE_H264_PARSER 1
+#define ENABLE_MPEG4VIDEO_PARSER 1
+#define ENABLE_AAC_PARSER 0
+#define ENABLE_AC3_PARSER 0
+#define ENABLE_CAVSVIDEO_PARSER 0
+#define ENABLE_DCA_PARSER 0
+#define ENABLE_DVBSUB_PARSER 0
+#define ENABLE_DVDSUB_PARSER 0
+#define ENABLE_H261_PARSER 0
+#define ENABLE_MJPEG_PARSER 0
+#define ENABLE_MPEGAUDIO_PARSER 0
+#define ENABLE_MPEGVIDEO_PARSER 0
+#define ENABLE_PNM_PARSER 0
+#define ENABLE_VC1_PARSER 0
+#define ENABLE_MJPEG_ENCODER 1
+#define ENABLE_MSMPEG4V3_ENCODER 1
+#define ENABLE_H263P_ENCODER 1
+#define ENABLE_AC3_ENCODER 1
+#define ENABLE_FFV1_ENCODER 1
+#define ENABLE_FLV1_ENCODER 1
+#define ENABLE_FFVHUFF_ENCODER 1
+#define ENABLE_H263_ENCODER 1
+#define ENABLE_MPEG1VIDEO_ENCODER 1
+#define ENABLE_MPEG2VIDEO_ENCODER 1
+#define ENABLE_MPEG4_ENCODER 1
+#define ENABLE_FLV_ENCODER 1
+#define ENABLE_MP2_ENCODER 1
+#define ENABLE_DVVIDEO_ENCODER 1
+#define ENABLE_HUFFYUV_ENCODER 1
+#define ENABLE_DVBSUB_ENCODER 1
+#define ENABLE_SNOW_ENCODER 1
+#define ENABLE_RAWVIDEO_ENCODER 1
+#define ENABLE_ADPCM_IMA_AMV_ENCODER 0
+#define ENABLE_LIBX264_ENCODER 0
+#define ENABLE_LIBXVID_ENCODER 0
+#define ENABLE_LJPEG_ENCODER 0
+#define ENABLE_PAM_ENCODER 0
+#define ENABLE_PBM_ENCODER 0
+#define ENABLE_PGM_ENCODER 0
+#define ENABLE_PGMYUV_ENCODER 0
+#define ENABLE_PPM_ENCODER 0
+#define ENABLE_LIBFAAC_ENCODER 0
+#define ENABLE_LIBMP3LAME_ENCODER 0
+#define ENABLE_LIBTHEORA_ENCODER 0
+#define ENABLE_SONIC_LS_ENCODER 0
+#define ENABLE_ASV1_ENCODER 0
+#define ENABLE_ASV2_ENCODER 0
+#define ENABLE_BMP_ENCODER 0
+#define ENABLE_FLASHSV_ENCODER 0
+#define ENABLE_GIF_ENCODER 0
+#define ENABLE_H261_ENCODER 0
+#define ENABLE_JPEGLS_ENCODER 0
+#define ENABLE_MSMPEG4V1_ENCODER 0
+#define ENABLE_MSMPEG4V2_ENCODER 0
+#define ENABLE_PNG_ENCODER 0
+#define ENABLE_QTRLE_ENCODER 0
+#define ENABLE_ROQ_ENCODER 0
+#define ENABLE_RV10_ENCODER 0
+#define ENABLE_RV20_ENCODER 0
+#define ENABLE_SGI_ENCODER 0
+#define ENABLE_SVQ1_ENCODER 0
+#define ENABLE_TARGA_ENCODER 0
+#define ENABLE_TIFF_ENCODER 0
+#define ENABLE_WMV1_ENCODER 0
+#define ENABLE_WMV2_ENCODER 0
+#define ENABLE_ZLIB_ENCODER 0
+#define ENABLE_ZMBV_ENCODER 0
+#define ENABLE_FLAC_ENCODER 0
+#define ENABLE_LIBAMR_NB_ENCODER 0
+#define ENABLE_LIBAMR_WB_ENCODER 0
+#define ENABLE_LIBGSM_ENCODER 0
+#define ENABLE_LIBGSM_MS_ENCODER 0
+#define ENABLE_SONIC_ENCODER 0
+#define ENABLE_VORBIS_ENCODER 0
+#define ENABLE_WMAV1_ENCODER 0
+#define ENABLE_WMAV2_ENCODER 0
+#define ENABLE_PCM_ALAW_ENCODER 0
+#define ENABLE_PCM_MULAW_ENCODER 0
+#define ENABLE_PCM_S8_ENCODER 0
+#define ENABLE_PCM_S16BE_ENCODER 0
+#define ENABLE_PCM_S16LE_ENCODER 0
+#define ENABLE_PCM_S24BE_ENCODER 0
+#define ENABLE_PCM_S24DAUD_ENCODER 0
+#define ENABLE_PCM_S24LE_ENCODER 0
+#define ENABLE_PCM_S32BE_ENCODER 0
+#define ENABLE_PCM_S32LE_ENCODER 0
+#define ENABLE_PCM_U8_ENCODER 0
+#define ENABLE_PCM_U16BE_ENCODER 0
+#define ENABLE_PCM_U16LE_ENCODER 0
+#define ENABLE_PCM_U24BE_ENCODER 0
+#define ENABLE_PCM_U24LE_ENCODER 0
+#define ENABLE_PCM_U32BE_ENCODER 0
+#define ENABLE_PCM_U32LE_ENCODER 0
+#define ENABLE_ROQ_DPCM_ENCODER 0
+#define ENABLE_ADPCM_4XM_ENCODER 0
+#define ENABLE_ADPCM_ADX_ENCODER 0
+#define ENABLE_ADPCM_CT_ENCODER 0
+#define ENABLE_ADPCM_EA_ENCODER 0
+#define ENABLE_ADPCM_G726_ENCODER 0
+#define ENABLE_ADPCM_IMA_DK3_ENCODER 0
+#define ENABLE_ADPCM_IMA_DK4_ENCODER 0
+#define ENABLE_ADPCM_IMA_QT_ENCODER 0
+#define ENABLE_ADPCM_IMA_SMJPEG_ENCODER 0
+#define ENABLE_ADPCM_IMA_WAV_ENCODER 0
+#define ENABLE_ADPCM_IMA_WS_ENCODER 0
+#define ENABLE_ADPCM_MS_ENCODER 0
+#define ENABLE_ADPCM_SBPRO_2_ENCODER 0
+#define ENABLE_ADPCM_SBPRO_3_ENCODER 0
+#define ENABLE_ADPCM_SBPRO_4_ENCODER 0
+#define ENABLE_ADPCM_SWF_ENCODER 0
+#define ENABLE_ADPCM_XA_ENCODER 0
+#define ENABLE_ADPCM_YAMAHA_ENCODER 0
+#define ENABLE_DVDSUB_ENCODER 0
+#define ENABLE_LIBVORBIS_ENCODER        0
+#define ENABLE_LIBVORBIS_DECODER        0
+#define ENABLE_MP3_HEADER_COMPRESS_BSF  0
+#define ENABLE_IMX_DUMP_HEADER_BSF      0
+#define ENABLE_DUMP_EXTRADATA_BSF       0
+#define ENABLE_REMOVE_EXTRADATA_BSF     0
+#define ENABLE_NOISE_BSF                0
+#define ENABLE_MP3_HEADER_DECOMPRESS_BSF 0
+#define ENABLE_MJPEGA_DUMP_HEADER_BSF   0
+#define ENABLE_IMX_DUMP_HEADER_BSF      0
+#define ENABLE_ARMV4L      0
+#define ENABLE_MLIB      0
+#define ENABLE_SPARC      0
+#define ENABLE_ALPHA      0
+#ifdef ARCH_POWERPC
+#define ENABLE_POWERPC      1
+#else
+#define ENABLE_POWERPC      0
+#endif
+#define ENABLE_MMI      0
+#define ENABLE_SH4      0
+#define ENABLE_BFIN      0
+#define ENABLE_SMALL      0
+#define CONFIG_SNOW_ENCODER      1

Added: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/rawdec.c
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/rawdec.c	2008-07-19 17:58:31 UTC (rev 4256)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/rawdec.c	2008-07-20 07:17:05 UTC (rev 4257)
@@ -0,0 +1,174 @@
+/*
+ * Raw Video Decoder
+ * Copyright (c) 2001 Fabrice Bellard.
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+/**
+ * @file rawdec.c
+ * Raw Video Decoder
+ */
+
+#include "avcodec.h"
+#include "raw.h"
+
+typedef struct RawVideoContext {
+    unsigned char * buffer;  /* block of memory for holding one frame */
+    int             length;  /* number of bytes in buffer */
+    AVFrame pic;             ///< AVCodecContext.coded_frame
+} RawVideoContext;
+
+static const PixelFormatTag pixelFormatBpsAVI[] = {
+    { PIX_FMT_PAL8,    4 },
+    { PIX_FMT_PAL8,    8 },
+    { PIX_FMT_RGB555, 15 },
+    { PIX_FMT_RGB555, 16 },
+    { PIX_FMT_BGR24,  24 },
+    { PIX_FMT_RGB32,  32 },
+    { -1, 0 },
+};
+
+static const PixelFormatTag pixelFormatBpsMOV[] = {
+    /* FIXME fix swscaler to support those */
+    /* http://developer.apple.com/documentation/QuickTime/QTFF/QTFFChap3/chapter_4_section_2.html */
+    { PIX_FMT_PAL8,      4 },
+    { PIX_FMT_PAL8,      8 },
+    { PIX_FMT_BGR555,   16 },
+    { PIX_FMT_RGB24,    24 },
+    { PIX_FMT_BGR32_1,  32 },
+    { -1, 0 },
+};
+
+static int findPixelFormat(const PixelFormatTag *tags, unsigned int fourcc)
+{
+    while (tags->pix_fmt >= 0) {
+        if (tags->fourcc == fourcc)
+            return tags->pix_fmt;
+        tags++;
+    }
+    return PIX_FMT_YUV420P;
+}
+
+static int raw_init_decoder(AVCodecContext *avctx)
+{
+    RawVideoContext *context = avctx->priv_data;
+
+    if (avctx->codec_tag == MKTAG('r','a','w',' '))
+        avctx->pix_fmt = findPixelFormat(pixelFormatBpsMOV, avctx->bits_per_sample);
+    else if (avctx->codec_tag)
+        avctx->pix_fmt = findPixelFormat(ff_raw_pixelFormatTags, avctx->codec_tag);
+    else if (avctx->bits_per_sample)
+        avctx->pix_fmt = findPixelFormat(pixelFormatBpsAVI, avctx->bits_per_sample);
+
+    context->length = avpicture_get_size(avctx->pix_fmt, avctx->width, avctx->height);
+    context->buffer = av_malloc(context->length);
+    context->pic.pict_type = FF_I_TYPE;
+    context->pic.key_frame = 1;
+
+    avctx->coded_frame= &context->pic;
+
+    if (!context->buffer)
+        return -1;
+
+    return 0;
+}
+
+static void flip(AVCodecContext *avctx, AVPicture * picture){
+    if(!avctx->codec_tag && avctx->bits_per_sample && picture->linesize[2]==0){
+        picture->data[0] += picture->linesize[0] * (avctx->height-1);
+        picture->linesize[0] *= -1;
+    }
+}
+
+#undef printf
+#include <stdlib.h>
+static int raw_decode(AVCodecContext *avctx,
+                            void *data, int *data_size,
+                            const uint8_t *buf, int buf_size)
+{
+    RawVideoContext *context = avctx->priv_data;
+
+    AVFrame * frame = (AVFrame *) data;
+    AVPicture * picture = (AVPicture *) data;
+
+    frame->interlaced_frame = avctx->coded_frame->interlaced_frame;
+    frame->top_field_first = avctx->coded_frame->top_field_first;
+
+    //4bpp raw in avi and mov (yes this is ugly ...)
+    if(avctx->bits_per_sample == 4 && avctx->pix_fmt==PIX_FMT_PAL8 &&
+       (!avctx->codec_tag || avctx->codec_tag == MKTAG('r','a','w',' '))){
+        int i;
+        for(i=256*2; i+1 < context->length>>1; i++){
+            context->buffer[2*i+0]= buf[i-256*2]>>4;
+            context->buffer[2*i+1]= buf[i-256*2]&15;
+        }
+        buf= context->buffer + 256*4;
+        buf_size= context->length - 256*4;
+    }
+
+/*
+    if(buf_size < context->length - (avctx->pix_fmt==PIX_FMT_PAL8 ? 256*4 : 0))
+{
+printf("ERROR %s (%d %d %d)\n", __FUNCTION__, buf_size, context->length, (avctx->pix_fmt==PIX_FMT_PAL8 ? 256*4 : 0));
+        return -1;
+}
+*/
+
+    avpicture_fill(picture, buf, avctx->pix_fmt, avctx->width, avctx->height);
+    if(avctx->pix_fmt==PIX_FMT_PAL8 && buf_size < context->length){
+        frame->data[1]= context->buffer;
+    }
+    if (avctx->palctrl && avctx->palctrl->palette_changed) {
+        memcpy(frame->data[1], avctx->palctrl->palette, AVPALETTE_SIZE);
+        avctx->palctrl->palette_changed = 0;
+    }
+
+    flip(avctx, picture);
+
+    if (avctx->codec_tag == MKTAG('Y', 'V', '1', '2'))
+    {
+        // swap fields
+        unsigned char *tmp = picture->data[1];
+        picture->data[1] = picture->data[2];
+        picture->data[2] = tmp;
+    }
+
+    *data_size = sizeof(AVPicture);
+    return buf_size;
+}
+
+static int raw_close_decoder(AVCodecContext *avctx)
+{
+    RawVideoContext *context = avctx->priv_data;
+
+    av_freep(&context->buffer);
+    return 0;
+}
+
+AVCodec rawvideo_decoder = {
+    "rawvideo",
+    CODEC_TYPE_VIDEO,
+    CODEC_ID_RAWVIDEO,
+    sizeof(RawVideoContext),
+    raw_init_decoder,
+    NULL,
+    raw_close_decoder,
+    raw_decode,
+    CODEC_CAP_DR1,
+};
+

Added: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/rawenc.c
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/rawenc.c	2008-07-19 17:58:31 UTC (rev 4256)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/rawenc.c	2008-07-20 07:17:05 UTC (rev 4257)
@@ -0,0 +1,55 @@
+/*
+ * Raw Video Encoder
+ * Copyright (c) 2001 Fabrice Bellard.
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+/**
+ * @file rawenc.c
+ * Raw Video Encoder
+ */
+
+#include "avcodec.h"
+#include "raw.h"
+
+static int raw_init_encoder(AVCodecContext *avctx)
+{
+    avctx->coded_frame = (AVFrame *)avctx->priv_data;
+    avctx->coded_frame->pict_type = FF_I_TYPE;
+    avctx->coded_frame->key_frame = 1;
+    if(!avctx->codec_tag)
+        avctx->codec_tag = avcodec_pix_fmt_to_codec_tag(avctx->pix_fmt);
+    return 0;
+}
+
+static int raw_encode(AVCodecContext *avctx,
+                            unsigned char *frame, int buf_size, void *data)
+{
+    return avpicture_layout((AVPicture *)data, avctx->pix_fmt, avctx->width,
+                                               avctx->height, frame, buf_size);
+}
+
+AVCodec rawvideo_encoder = {
+    "rawvideo",
+    CODEC_TYPE_VIDEO,
+    CODEC_ID_RAWVIDEO,
+    sizeof(AVFrame),
+    raw_init_encoder,
+    raw_encode,
+//    .long_name = NULL_IF_CONFIG_SMALL("raw video"),
+};



From mean at mail.berlios.de  Sun Jul 20 09:17:44 2008
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sun, 20 Jul 2008 09:17:44 +0200
Subject: [Avidemux-svn-commit] r4258 -
	branches/avidemux_2.4_branch/avidemux/ADM_encoder
Message-ID: <200807200717.m6K7HhtK023845@sheep.berlios.de>

Author: mean
Date: 2008-07-20 09:17:43 +0200 (Sun, 20 Jul 2008)
New Revision: 4258

Added:
   branches/avidemux_2.4_branch/avidemux/ADM_encoder/adm_ency800.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_encoder/adm_ency800.h
   branches/avidemux_2.4_branch/avidemux/ADM_encoder/adm_ency800_param.h
Modified:
   branches/avidemux_2.4_branch/avidemux/ADM_encoder/ADM_encCodecDesc.h
   branches/avidemux_2.4_branch/avidemux/ADM_encoder/ADM_vidEncode.hxx
   branches/avidemux_2.4_branch/avidemux/ADM_encoder/CMakeLists.txt
   branches/avidemux_2.4_branch/avidemux/ADM_encoder/Makefile.am
   branches/avidemux_2.4_branch/avidemux/ADM_encoder/adm_encConfig.cpp
Log:
[Codec] Support for y800 encoder (patch by compholio)

Modified: branches/avidemux_2.4_branch/avidemux/ADM_encoder/ADM_encCodecDesc.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_encoder/ADM_encCodecDesc.h	2008-07-20 07:17:05 UTC (rev 4257)
+++ branches/avidemux_2.4_branch/avidemux/ADM_encoder/ADM_encCodecDesc.h	2008-07-20 07:17:43 UTC (rev 4258)
@@ -266,6 +266,24 @@
   &DIA_mjpegCodecSetting
 };
 
+//*********************** FFMpeg raw video ********************
+COMPRES_PARAMS Y800Codec = {
+  CodecY800,
+  QT_TR_NOOP("Y800 (lavc)"),
+  "Y800",
+  "Y800 (lavcodec)",
+  COMPRESS_SAME,
+  1,
+  1500,
+  700,
+  1000,
+  ADM_ENC_CAP_SAME,
+  0,
+  NULL,
+  0,
+  NULL
+};
+
 //************************* FFMpeg mpeg1 **********************
 FFcodecSetting ffmpeg1Extra = {
   ME_EPZS,			//     ME
@@ -856,6 +874,7 @@
   &ffmpegH263Codec,
   &MjpegCodec,
   &ffmpegFLV1,
+  &Y800Codec,
   &DUMMYONE
 };
 #endif

Modified: branches/avidemux_2.4_branch/avidemux/ADM_encoder/ADM_vidEncode.hxx
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_encoder/ADM_vidEncode.hxx	2008-07-20 07:17:05 UTC (rev 4257)
+++ branches/avidemux_2.4_branch/avidemux/ADM_encoder/ADM_vidEncode.hxx	2008-07-20 07:17:43 UTC (rev 4258)
@@ -45,6 +45,7 @@
   CodecRequant,
   CodecDV,
   CodecFLV1,
+  CodecY800,
   CodecDummy
 }SelectCodecType;
 

Modified: branches/avidemux_2.4_branch/avidemux/ADM_encoder/CMakeLists.txt
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_encoder/CMakeLists.txt	2008-07-20 07:17:05 UTC (rev 4257)
+++ branches/avidemux_2.4_branch/avidemux/ADM_encoder/CMakeLists.txt	2008-07-20 07:17:43 UTC (rev 4258)
@@ -1,5 +1,7 @@
 
 SET(ADM_encoder_SRCS 
 adm_encConfig.cpp  adm_encdivx2p.cpp  adm_encffmpeg1.cpp  adm_encmjpeg.cpp     adm_encoder.cpp     adm_encx264.cpp   adm_encxvid.cpp
-adm_encCopy.cpp    adm_encdivx.cpp    adm_encffmpeg.cpp   adm_encmpeg2enc.cpp  adm_encRequant.cpp  adm_encXvid4.cpp  adm_encyv12.cpp)
+adm_encCopy.cpp    adm_encdivx.cpp    adm_encffmpeg.cpp   adm_encmpeg2enc.cpp  adm_encRequant.cpp  adm_encXvid4.cpp  adm_encyv12.cpp
+adm_ency800.cpp
+)
 ADD_LIBRARY(ADM_encoder STATIC ${ADM_encoder_SRCS})

Modified: branches/avidemux_2.4_branch/avidemux/ADM_encoder/Makefile.am
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_encoder/Makefile.am	2008-07-20 07:17:05 UTC (rev 4257)
+++ branches/avidemux_2.4_branch/avidemux/ADM_encoder/Makefile.am	2008-07-20 07:17:43 UTC (rev 4258)
@@ -9,17 +9,18 @@
 	adm_encoder.cpp adm_encmjpeg.cpp adm_encffmpeg.cpp adm_encdivx2p.cpp adm_encdivx.cpp \
 	adm_encffmpeg1.cpp adm_encffmatrix.h adm_encXvid4.cpp adm_encx264.cpp \
 	adm_encCopy.cpp adm_encyv12.cpp adm_encmpeg2enc.cpp adm_encmpeg2enc.h \
-	adm_encRequant.cpp 
+	adm_encRequant.cpp adm_ency800.cpp
 
 
 EXTRA_DIST =  ADM_encCodecDesc.h    adm_encCopy.h   \
-adm_encffmatrix.h   adm_encmjpeg_param.h  adm_encxvid.h \
+adm_encffmatrix.h   adm_encmjpeg_param.h  adm_encxvid.h adm_ency800.h \
 ADM_vidEncode.hxx     adm_encXvid4.cpp   adm_encffmpeg.cpp   adm_encoder.cpp       adm_encyv12.cpp \
 ADM_videocodeclist.h  adm_encXvid4.h     adm_encffmpeg.h     adm_encoder.h         adm_encyv12.h \
 adm_encConfig.cpp     adm_encdivx.cpp    adm_encffmpeg1.cpp  adm_encx264.cpp       xvid_vbr.h \
 adm_encConfig.h       adm_encdivx.h      adm_encmjpeg.cpp    adm_encx264.h \
 adm_encCopy.cpp       adm_encdivx2p.cpp  adm_encmjpeg.h      adm_encxvid.cpp \
-adm_encmpeg2enc.cpp adm_encmpeg2enc.h adm_encRequant.cpp adm_encRequant.h
+adm_encmpeg2enc.cpp adm_encmpeg2enc.h adm_encRequant.cpp adm_encRequant.h \
+adm_ency800.cpp adm_ency800.h
 
 
 

Modified: branches/avidemux_2.4_branch/avidemux/ADM_encoder/adm_encConfig.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_encoder/adm_encConfig.cpp	2008-07-20 07:17:05 UTC (rev 4257)
+++ branches/avidemux_2.4_branch/avidemux/ADM_encoder/adm_encConfig.cpp	2008-07-20 07:17:43 UTC (rev 4258)
@@ -76,6 +76,7 @@
 #include "adm_encmjpeg.h"
 #include "adm_encCopy.h"
 #include "adm_encyv12.h"
+#include "adm_ency800.h"
 
 #define FF_TRELLIS 0		// use treillis for mpeg1 encoding
 /*
@@ -688,8 +689,9 @@
     case CodecMjpeg:
       e = new EncoderMjpeg (&MjpegCodec);
       break;
-
-
+    case CodecY800:
+      e = new EncoderY800 (&Y800Codec);
+      break;
     case CodecFFhuff:
       e = new EncoderFFMPEGFFHuff (&ffmpegFFHUFF);
       break;

Added: branches/avidemux_2.4_branch/avidemux/ADM_encoder/adm_ency800.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_encoder/adm_ency800.cpp	2008-07-20 07:17:05 UTC (rev 4257)
+++ branches/avidemux_2.4_branch/avidemux/ADM_encoder/adm_ency800.cpp	2008-07-20 07:17:43 UTC (rev 4258)
@@ -0,0 +1,125 @@
+/***************************************************************************
+                          adm_ency800.cpp  -  description
+                             -------------------
+    begin                : Tue Jul 23 2002
+    copyright            : (C) 2002 by mean
+    email                : fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include "config.h"
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <math.h>
+#include <unistd.h>
+
+
+#include <time.h>
+#include <sys/time.h>
+
+#ifdef USE_FFMPEG
+#include "ADM_lavcodec.h"
+#include "fourcc.h"
+#include "avi_vars.h"
+#include "ADM_toolkit/toolkit.hxx"
+#include <ADM_assert.h>
+#include "ADM_encoder/ADM_vidEncode.hxx"
+
+
+#include "ADM_video/ADM_genvideo.hxx"
+#include "ADM_codecs/ADM_ffmpeg.h"
+
+#include "ADM_encoder/adm_encoder.h"
+
+
+
+#include "ADM_codecs/ADM_y800.h"
+
+
+#include "ADM_encoder/adm_ency800.h"
+
+/*_________________________________________________*/
+EncoderY800::EncoderY800 (COMPRES_PARAMS * conf)
+{
+  _codec = NULL;
+  fd = NULL;
+  entries = NULL;
+  strcpy (_logname, "");
+  _frametogo = 0;
+};
+//--------------------------------
+uint8_t
+EncoderY800::configure (AVDMGenericVideoStream * instream)
+{
+  ADV_Info *info;
+//         int q,s;
+
+  ADM_assert (instream);
+  _in = instream;
+
+  info = instream->getInfo ();
+  _w = info->width;
+  _h = info->height;
+
+
+//              _vbuffer=new uint8_t[_w*_h*3];
+  _vbuffer = new ADMImage (_w, _h);
+  ADM_assert (_vbuffer);
+
+  //   _codec=new mjpegEncoder(_w,_h);
+  _codec = new ffmpegEncoderFFY800 (_w, _h, FF_Y800);
+
+  _codec->init (info->fps1000, 0);
+
+  return 1;
+}
+
+
+
+
+
+//______________________________
+uint8_t
+EncoderY800::encode (uint32_t frame, ADMBitstream *out)
+{
+  uint32_t l, f;
+
+
+  ADM_assert (_codec);
+  ADM_assert (_in);
+
+  if (!_in->getFrameNumberNoAlloc (frame, &l, _vbuffer, &f))
+    {
+      printf ("\n Error : Cannot read incoming frame !");
+      return 0;
+    }
+  return _codec->encode (_vbuffer, out);
+}
+
+//_______________________________
+uint8_t
+EncoderY800::stop (void)
+{
+  delete _codec;
+  _codec = 0;
+  return 1;
+
+}
+
+uint8_t
+EncoderY800::setLogFile (const char *p, uint32_t fr)
+{				// for dual pass only
+
+  UNUSED_ARG (p);
+  UNUSED_ARG (fr);
+  return 1;
+}
+#endif

Added: branches/avidemux_2.4_branch/avidemux/ADM_encoder/adm_ency800.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_encoder/adm_ency800.h	2008-07-20 07:17:05 UTC (rev 4257)
+++ branches/avidemux_2.4_branch/avidemux/ADM_encoder/adm_ency800.h	2008-07-20 07:17:43 UTC (rev 4258)
@@ -0,0 +1,63 @@
+/***************************************************************************
+                          adm_ency800.h  -  description
+                             -------------------
+    begin                : Tue Jul 23 2002
+    copyright            : (C) 2002 by mean
+    email                : fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#ifndef __ADM_encoder_y800__
+#define __ADM_encoder_y800__
+
+#ifdef USE_FFMPEG
+#include "ADM_encoder/adm_ency800_param.h"
+
+class EncoderY800:public Encoder
+{
+
+protected:
+  ffmpegEncoderFFY800 * _codec;
+public:
+    EncoderY800 (COMPRES_PARAMS * conf);
+  virtual uint8_t isDualPass (void)
+  {
+    return 0;
+  };				// mjpeg is always monopass
+  virtual uint8_t configure (AVDMGenericVideoStream * instream);
+  virtual uint8_t encode (uint32_t frame, ADMBitstream *out);
+  virtual uint8_t setLogFile (const char *p, uint32_t fr);	// for dual pass only
+  virtual uint8_t stop (void);
+  virtual uint8_t startPass2 (void)
+  {
+    assert (0);
+  };				// for dual pass only
+  virtual uint8_t startPass1 (void)
+  {
+    assert (0);
+  };				// for dual pass only
+  virtual const char *getCodecName (void)
+  {
+    return "Y800";
+  }
+  virtual const char *getFCCHandler (void)
+  {
+    return "Y800";
+  }
+  virtual const char *getDisplayName (void)
+  {
+    return QT_TR_NOOP("Y800");
+  }
+};
+
+
+#endif
+#endif

Added: branches/avidemux_2.4_branch/avidemux/ADM_encoder/adm_ency800_param.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_encoder/adm_ency800_param.h	2008-07-20 07:17:05 UTC (rev 4257)
+++ branches/avidemux_2.4_branch/avidemux/ADM_encoder/adm_ency800_param.h	2008-07-20 07:17:43 UTC (rev 4258)
@@ -0,0 +1,28 @@
+/***************************************************************************
+                          adm_ency800.h  -  description
+                             -------------------
+    begin                : Tue Jul 23 2002
+    copyright            : (C) 2002 by mean
+    email                : fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#ifndef __ADM_encoder_y800P__
+#define __ADM_encoder_y800P__
+
+typedef struct Y800Config
+{
+
+  uint32_t qual;
+  uint32_t swapped;
+} Y800Config;
+
+#endif



From mean at mail.berlios.de  Sun Jul 20 09:18:59 2008
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sun, 20 Jul 2008 09:18:59 +0200
Subject: [Avidemux-svn-commit] r4259 -
	branches/avidemux_2.4_branch/avidemux/ADM_codecs
Message-ID: <200807200718.m6K7Ixeu023921@sheep.berlios.de>

Author: mean
Date: 2008-07-20 09:18:58 +0200 (Sun, 20 Jul 2008)
New Revision: 4259

Added:
   branches/avidemux_2.4_branch/avidemux/ADM_codecs/ADM_y800.h
Modified:
   branches/avidemux_2.4_branch/avidemux/ADM_codecs/ADM_codecs.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_codecs/ADM_ffmp43.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_codecs/ADM_ffmp43.h
   branches/avidemux_2.4_branch/avidemux/ADM_codecs/ADM_ffmpeg.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_codecs/ADM_ffmpeg.h
   branches/avidemux_2.4_branch/avidemux/ADM_codecs/CMakeLists.txt
   branches/avidemux_2.4_branch/avidemux/ADM_codecs/Makefile.am
Log:
[Codec] Support for y800 admcodecs (patch by compholio)

Modified: branches/avidemux_2.4_branch/avidemux/ADM_codecs/ADM_codecs.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_codecs/ADM_codecs.cpp	2008-07-20 07:17:43 UTC (rev 4258)
+++ branches/avidemux_2.4_branch/avidemux/ADM_codecs/ADM_codecs.cpp	2008-07-20 07:18:58 UTC (rev 4259)
@@ -251,6 +251,11 @@
 
 
 #ifdef USE_FFMPEG
+  if (fourCC::check (fcc, (uint8_t *) "Y800"))
+    {
+
+      return (decoders *) (new decoderFFY800 (w, h));
+    }
   if (fourCC::check (fcc, (uint8_t *) "H263"))
     {
 

Modified: branches/avidemux_2.4_branch/avidemux/ADM_codecs/ADM_ffmp43.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_codecs/ADM_ffmp43.cpp	2008-07-20 07:17:43 UTC (rev 4258)
+++ branches/avidemux_2.4_branch/avidemux/ADM_codecs/ADM_ffmp43.cpp	2008-07-20 07:18:58 UTC (rev 4259)
@@ -42,7 +42,7 @@
 #define WRAP_Open(x) \
 {\
 AVCodec *codec=avcodec_find_decoder(x);\
-if(!codec) {GUI_Alert(QT_TR_NOOP("Internal error finding codec"#x));ADM_assert(0);} \
+if(!codec) {GUI_Alert(QT_TR_NOOP("Internal error finding codec '"#x"'"));ADM_assert(0);} \
   codecId=x; \
   _context->workaround_bugs=1*FF_BUG_AUTODETECT +0*FF_BUG_NO_PADDING;/**/ \
   _context->error_concealment=3; \
@@ -424,6 +424,10 @@
     case PIX_FMT_RGB555:
       out->_colorspace = ADM_COLOR_RGB555;
       break;
+    case PIX_FMT_GRAY8:
+//      out->_colorspace = ADM_COLOR_RGB555;
+      out->_colorspace = ADM_COLOR_GRAY8;
+      break;
     default:
       printf ("[lavc] Unhandled colorspace: %d\n", _context->pix_fmt);
       return 0;
@@ -543,6 +547,13 @@
   _refCopy = 1;			// YUV420 only
   WRAP_Open (CODEC_ID_FFV1);
 }
+
+decoderFFY800::decoderFFY800 (uint32_t w, uint32_t h):decoderFF (w, h)
+{
+  WRAP_Open (CODEC_ID_RAWVIDEO);
+  _context->pix_fmt = PIX_FMT_GRAY8;
+}
+
 decoderFF_ffhuff::decoderFF_ffhuff (uint32_t w, uint32_t h, uint32_t l, uint8_t * d,uint32_t bpp):decoderFF (w,
 	   h)
 {

Modified: branches/avidemux_2.4_branch/avidemux/ADM_codecs/ADM_ffmp43.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_codecs/ADM_ffmp43.h	2008-07-20 07:17:43 UTC (rev 4258)
+++ branches/avidemux_2.4_branch/avidemux/ADM_codecs/ADM_ffmp43.h	2008-07-20 07:18:58 UTC (rev 4259)
@@ -252,6 +252,15 @@
   decoderFFV1 (uint32_t w, uint32_t h);
 
 };
+class decoderFFY800:public decoderFF
+{
+protected:
+
+
+public:
+  decoderFFY800 (uint32_t w, uint32_t h);
+};
+
 class decoderFFMJPEG:public decoderFF
 {
 protected:

Modified: branches/avidemux_2.4_branch/avidemux/ADM_codecs/ADM_ffmpeg.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_codecs/ADM_ffmpeg.cpp	2008-07-20 07:17:43 UTC (rev 4258)
+++ branches/avidemux_2.4_branch/avidemux/ADM_codecs/ADM_ffmpeg.cpp	2008-07-20 07:18:58 UTC (rev 4259)
@@ -356,7 +356,9 @@
     case FF_SNOW:
       WRAP_Open (CODEC_ID_SNOW);
       break;
-      
+    case FF_Y800:
+      WRAP_Open (CODEC_ID_RAWVIDEO);
+      break;
     case FF_DV:
       if(_context->width!=720 || _context->height!=576) 
             return 0; // should be caught by upper layers before going here...
@@ -958,3 +960,28 @@
   return ffmpegEncoder::encode(in,out);
 }
 
+/*---
+*/
+uint8_t
+  ffmpegEncoderFFY800::init (uint32_t fps1000, uint8_t vbr)
+{
+  UNUSED_ARG (vbr);
+  mplayer_init ();
+
+  _context->time_base = (AVRational) { 1000, fps1000};
+  _context->flags = 0;
+  _context->bit_rate = 0;
+  _context->bit_rate_tolerance = 1024 * 8 * 1000;
+  _context->gop_size = 250;
+  printf ("[LAVCODEC]FF Mjpeg codec initializing...\n");
+  return initContext ();
+}
+
+
+
+uint8_t
+ffmpegEncoderFFY800::encode (ADMImage * in, ADMBitstream * out)
+{
+  return ffmpegEncoder::encode(in,out);
+}
+

Modified: branches/avidemux_2.4_branch/avidemux/ADM_codecs/ADM_ffmpeg.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_codecs/ADM_ffmpeg.h	2008-07-20 07:17:43 UTC (rev 4258)
+++ branches/avidemux_2.4_branch/avidemux/ADM_codecs/ADM_ffmpeg.h	2008-07-20 07:18:58 UTC (rev 4259)
@@ -37,6 +37,7 @@
   FF_FFHUFF = 11,
   FF_DV=12,
   FF_FLV1=13,
+  FF_Y800=14,
 } FF_CODEC_ID;
 
 /*
@@ -220,7 +221,24 @@
   }
 };
 
+class ffmpegEncoderFFY800:public ffmpegEncoder
+{
+protected:uint32_t _qual;
 
+public:ffmpegEncoderFFY800 (uint32_t width, uint32_t height,FF_CODEC_ID id)
+    :ffmpegEncoder (width, height,id)
+  {
+    _qual = 4;
+  };
 
+  virtual uint8_t init (uint32_t fps1000, uint8_t vbr = 0);
+  virtual uint8_t encode (ADMImage * in, ADMBitstream * out);
+  virtual ~ ffmpegEncoderFFY800 ()
+  {
+    stopEncoder ();
 
+  }
+};
+
+
 #endif

Added: branches/avidemux_2.4_branch/avidemux/ADM_codecs/ADM_y800.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_codecs/ADM_y800.h	2008-07-20 07:17:43 UTC (rev 4258)
+++ branches/avidemux_2.4_branch/avidemux/ADM_codecs/ADM_y800.h	2008-07-20 07:18:58 UTC (rev 4259)
@@ -0,0 +1,40 @@
+/***************************************************************************
+                          ADM_y800.h  -  description
+                             -------------------
+    begin                : Tue Jul 23 2002
+    copyright            : (C) 2002 by mean
+    email                : fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#ifndef __Y800_ENC__
+#define   __Y800_ENC__
+
+class Y800Encoder:public encoder
+{
+protected:uint8_t _qual;
+  uint8_t _swap;
+public:  Y800Encoder (uint32_t width, uint32_t height):encoder (width,
+							    height)
+  {
+    _qual = 75;
+    _swap = 0;
+
+  };
+  uint8_t stopEncoder (void);
+  virtual uint8_t init (uint32_t val, uint32_t fps1000);
+  uint8_t init (uint32_t val, uint32_t fps1000, uint8_t sw);
+  virtual uint8_t encode (uint8_t * in,
+			  uint8_t * out, uint32_t * len, uint32_t * flags);
+
+};
+
+#endif
+

Modified: branches/avidemux_2.4_branch/avidemux/ADM_codecs/CMakeLists.txt
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_codecs/CMakeLists.txt	2008-07-20 07:17:43 UTC (rev 4258)
+++ branches/avidemux_2.4_branch/avidemux/ADM_codecs/CMakeLists.txt	2008-07-20 07:18:58 UTC (rev 4259)
@@ -1,5 +1,6 @@
 
 SET(ADM_codecs_SRCS 
 ADM_codecs.cpp  ADM_ffmpeg.cpp  ADM_mjpegEncode.cpp  ADM_png.cpp    ADM_theora_dec.cpp  ADM_x264.cpp   ADM_xvid.cpp     ADM_xvideco.cpp
-ADM_ffmp43.cpp  ADM_mjpeg.cpp   ADM_mpeg.cpp         ADM_rgb16.cpp  ADM_uyvy.cpp        ADM_xvid4.cpp  ADM_xvidcvs.cpp)
+ADM_ffmp43.cpp  ADM_mjpeg.cpp   ADM_mpeg.cpp         ADM_rgb16.cpp  ADM_uyvy.cpp        ADM_xvid4.cpp  ADM_xvidcvs.cpp
+)
 ADD_LIBRARY(ADM_codecs STATIC ${ADM_codecs_SRCS})

Modified: branches/avidemux_2.4_branch/avidemux/ADM_codecs/Makefile.am
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_codecs/Makefile.am	2008-07-20 07:17:43 UTC (rev 4258)
+++ branches/avidemux_2.4_branch/avidemux/ADM_codecs/Makefile.am	2008-07-20 07:18:58 UTC (rev 4259)
@@ -20,7 +20,8 @@
 ADM_ffmpeg.h        ADM_png.h            ADM_xvidcvs.cpp \
 ADM_ffmpegConfig.h  ADM_rgb16.cpp        ADM_x264.cpp      ADM_xvideco.cpp \
 ADM_mjpeg.cpp       ADM_rgb16.h          ADM_x264.h        ADM_xvideco.h \
-ADM_mjpeg.h         ADM_theora_dec.cpp   ADM_x264param.h
+ADM_mjpeg.h         ADM_theora_dec.cpp   ADM_x264param.h \
+ADM_y800.h
 
 
 ####### kdevelop will overwrite this part!!! (end)############



From mean at mail.berlios.de  Sun Jul 20 09:19:20 2008
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sun, 20 Jul 2008 09:19:20 +0200
Subject: [Avidemux-svn-commit] r4260 -
	branches/avidemux_2.4_branch/avidemux/ADM_colorspace
Message-ID: <200807200719.m6K7JKhE023972@sheep.berlios.de>

Author: mean
Date: 2008-07-20 09:19:20 +0200 (Sun, 20 Jul 2008)
New Revision: 4260

Modified:
   branches/avidemux_2.4_branch/avidemux/ADM_colorspace/ADM_rgb.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_colorspace/ADM_rgb.h
Log:
[Codec] Support for y800 colorspace (patch by compholio)

Modified: branches/avidemux_2.4_branch/avidemux/ADM_colorspace/ADM_rgb.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_colorspace/ADM_rgb.cpp	2008-07-20 07:18:58 UTC (rev 4259)
+++ branches/avidemux_2.4_branch/avidemux/ADM_colorspace/ADM_rgb.cpp	2008-07-20 07:19:20 UTC (rev 4260)
@@ -511,7 +511,8 @@
                 case ADM_COLOR_RGB16:c=PIX_FMT_RGB565;break;
                 case ADM_COLOR_YUV411:c=PIX_FMT_YUV411P;break;
 				case ADM_COLOR_YUV422:c=PIX_FMT_YUV422P;break;
-				case ADM_COLOR_YUV444:c=PIX_FMT_YUV444P;break;
+				case ADM_COLOR_YUV444:c=PIX_FMT_YUV444P;break;
+                case ADM_COLOR_GRAY8:c=PIX_FMT_GRAY8;break;
                 default: ADM_assert(0);
     }
          _context=(void *)sws_getContext(

Modified: branches/avidemux_2.4_branch/avidemux/ADM_colorspace/ADM_rgb.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_colorspace/ADM_rgb.h	2008-07-20 07:18:58 UTC (rev 4259)
+++ branches/avidemux_2.4_branch/avidemux/ADM_colorspace/ADM_rgb.h	2008-07-20 07:19:20 UTC (rev 4260)
@@ -33,7 +33,8 @@
     ADM_COLOR_YUV422,
     ADM_COLOR_YUV422P,
 	ADM_COLOR_YUV411,
-	ADM_COLOR_YUV444
+	ADM_COLOR_YUV444,
+	ADM_COLOR_GRAY8
  } ADM_colorspace;
 #define ADM_COLOR_BACKWARD 0x8000
 #define ADM_COLOR_MASK     0x7FFF



From mean at mail.berlios.de  Sun Jul 20 19:27:28 2008
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sun, 20 Jul 2008 19:27:28 +0200
Subject: [Avidemux-svn-commit] r4264 - in
	branches/avidemux_2.5_branch_gruntster: avidemux
	plugins/ADM_audioDevices/Esd
Message-ID: <200807201727.m6KHRSXg003719@sheep.berlios.de>

Author: mean
Date: 2008-07-20 19:27:28 +0200 (Sun, 20 Jul 2008)
New Revision: 4264

Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/guiplay.cpp
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Esd/ADM_deviceEsd.cpp
Log:
[AudioDevice] Increase playbacl buffer, ESD latency=0, crash otherwise


Modified: branches/avidemux_2.5_branch_gruntster/avidemux/guiplay.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/guiplay.cpp	2008-07-20 17:24:58 UTC (rev 4263)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/guiplay.cpp	2008-07-20 17:27:28 UTC (rev 4264)
@@ -339,7 +339,7 @@
     one_audio_frame /= 1000; // In elemtary info (float)
     printf("1 audio frame = %lu bytes\n", one_audio_frame);
     // 3 sec buffer..               
-    wavbuf =  (float *)  ADM_alloc((3 *  channels * wavinfo->frequency*wavinfo->channels));
+    wavbuf =  (float *)  ADM_alloc((3 *  2*channels * wavinfo->frequency*wavinfo->channels));
     ADM_assert(wavbuf);
     // Call it twice to be sure it is properly setup
      state = AVDM_AudioSetup(playback->getInfo()->frequency,  channels );

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Esd/ADM_deviceEsd.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Esd/ADM_deviceEsd.cpp	2008-07-20 17:24:58 UTC (rev 4263)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDevices/Esd/ADM_deviceEsd.cpp	2008-07-20 17:27:28 UTC (rev 4264)
@@ -24,6 +24,7 @@
 
 #include  "ADM_deviceEsd.h"
 #include <esd.h>
+#include <sys/time.h>
 ADM_DECLARE_AUDIODEVICE(Esd,esdAudioDevice,1,0,0,"Esd audio device (c) mean");
 /**
         \fn getLatencyMs
@@ -74,9 +75,29 @@
     int fmt = AFMT_S16_LE;
 #endif    
 */
-    float f=0; // FIXE Cause a freeze with esdcompat =(float)esd_get_latency(esdDevice);
-    f=f/44.1;
-    latency=(uint32_t)f;
+// Compute latency  esd_get_latency is causing a freeze
+// from VLC...
+#if 0
+        struct timeval start, stop;
+        esd_server_info_t * p_info;
+
+        gettimeofday( &start, NULL );
+        p_info = esd_get_server_info( esdDevice);
+        gettimeofday( &stop, NULL );
+
+        uint64_t serv_lat= (uint64_t)( stop.tv_sec - start.tv_sec )
+                           * 1000;
+        serv_lat += stop.tv_usec - start.tv_usec;
+    
+
+  
+  
+    latency=(uint32_t)(serv_lat);
+#else
+    latency=0; // harcoded value.... does not work with pulse+esd compat
+#endif
+    printf("[ESD] Latency %u ms\n",latency);
+    //printf("[ESD] get_esd_latency %u \n",esd_get_latency(esdDevice));
     return 1;
 }
 



From mean at mail.berlios.de  Sun Jul 20 19:30:12 2008
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sun, 20 Jul 2008 19:30:12 +0200
Subject: [Avidemux-svn-commit] r4266 - in
	branches/avidemux_2.5_branch_gruntster/avidemux:
	ADM_audiofilter ADM_coreAudio/src
Message-ID: <200807201730.m6KHUC8f010753@sheep.berlios.de>

Author: mean
Date: 2008-07-20 19:30:11 +0200 (Sun, 20 Jul 2008)
New Revision: 4266

Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audiofilter_film2pal.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audiofilter_film2pal.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/src/ADM_audioFilter.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/src/ADM_audioResample.cpp
Log:
[Pal2film] use SRC to do the Pal/Film conversion, better quality, much worse speed :(


Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audiofilter_film2pal.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audiofilter_film2pal.cpp	2008-07-20 17:27:33 UTC (rev 4265)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audiofilter_film2pal.cpp	2008-07-20 17:30:11 UTC (rev 4266)
@@ -14,7 +14,7 @@
  *   (at your option) any later version.                                   *
  *                                                                         *
  ***************************************************************************/
-#include "config.h"
+
 #include <math.h>
 
 #include "ADM_default.h"
@@ -22,149 +22,74 @@
 #include "ADM_audioFilter.h"
 #include "audiofilter_film2pal.h"
 
-//__________
-
-AUDMAudioFilterFilm2Pal::AUDMAudioFilterFilm2Pal(AUDMAudioFilter * instream):AUDMAudioFilter (instream)
+AUDMAudioFilterFilm2Pal::AUDMAudioFilterFilm2Pal(AUDMAudioFilter *previous) : 
+            AUDMAudioFilterFilmChange(previous,1001,960)
 {
-    // nothing special here...
-  _target=0;
-  _removed=0;
-  _previous->rewind();
-  _modulo=0;
-  printf("[Film2Pal] Creating\n");
-};
-
-AUDMAudioFilterFilm2Pal::~AUDMAudioFilterFilm2Pal()
-{
-  printf("[Film2Pal] Destroying\n");
+    printf("[Film2Pal] Created\n");
 }
-//
-//___________________________________________
-uint32_t AUDMAudioFilterFilm2Pal::fill( uint32_t max, float * buffer,AUD_Status *status)
+AUDMAudioFilterPal2Film::AUDMAudioFilterPal2Film(AUDMAudioFilter *previous) : 
+            AUDMAudioFilterFilmChange(previous,960,1001)
 {
-  uint32_t len,i,rendered;
-  uint32_t min=_wavHeader.channels;
-  float *start;
-  
-  shrink();
-  fillIncomingBuffer(status);
-  
-  len=_tail-_head;
-  if(len>max) len=max;
-  
-  len=len/min;
+    printf("[Pal2Film] Created\n");
+}
+#define CONTECT ((SRC_STATE *)context))
+//__________
 
-  rendered=0;
-  start=&_incomingBuffer[_head];
-
-  while(len--) // in sample
-  {
-        //_______________________________________
-        // FilmToPal : 24 fps to 25 fps -> shorten frame
-        // 1001 samples -> 960 samples
-        //______________________________________
-       if(_removed) // Fixme , use dither or something
-        { 
-              _removed--;
-        }
-        else
-        {
-        
-            memcpy(buffer,start,min*sizeof(float));
-            buffer+=min;
-            rendered+=min;    
-        }
-        _target++; // nb Processed
-     // Consume it
-        start+=min;
-        _head+=min;
-        _modulo++;
-        if(_target>1001)
-        {
-            _removed+=41;
-            _target-=1001;
-        }
-  }
-  return rendered;
-};
-//****************************************************
-AUDMAudioFilterPal2Film::AUDMAudioFilterPal2Film(AUDMAudioFilter * instream):AUDMAudioFilter (instream)
+AUDMAudioFilterFilmChange::AUDMAudioFilterFilmChange(AUDMAudioFilter * instream,uint32_t from, uint32_t to):AUDMAudioFilter (instream)
 {
-    // nothing special here...
-  _target=0;
-  _removed=0;
-  _modulo=0;
-  _previous->rewind();
-  printf("[Pal2Film] Creating\n");
+    // The parameter are in sample, we deal with fq
+    if(true!=resampler.init(from,to,_wavHeader.channels))
+    {
+        printf("[AudioFilter Resample] Init failed! \n");
+        ADM_assert(0);
+    }
+    printf("[FilmChange] Creating\n");
 };
 
-AUDMAudioFilterPal2Film::~AUDMAudioFilterPal2Film()
+AUDMAudioFilterFilmChange::~AUDMAudioFilterFilmChange()
 {
-  printf("[Film2Pal] Destroying\n");
+  
+  printf("[FilmChange] Destroying\n");
 }
 //
 //___________________________________________
-uint32_t AUDMAudioFilterPal2Film::fill( uint32_t max, float * buffer,AUD_Status *status)
-//uint32_t AUDMAudioFilterFilm2Pal::fill( uint32_t max, float * buffer,AUD_Status *status)
+uint32_t AUDMAudioFilterFilmChange::fill( uint32_t max, float * buffer,AUD_Status *status)
 {
   uint32_t len,i,rendered;
-  uint32_t min=_wavHeader.channels;
+  uint32_t chan=_wavHeader.channels;
   float *start;
   
   shrink();
   fillIncomingBuffer(status);
   
-  ADM_assert(_tail>=_head);
-  
-  len=_tail-_head;  // How much float available ?
+  len=_tail-_head;
+  if(max>64)
+    max-=64; // Prevent overflow
+
   if(len>max) len=max;
   
-  len=len/min; // convert to sample
-  
-  if(len==0)
-  {
-        printf("**oops**\n");
-  }
-  rendered=0;
-  start=&_incomingBuffer[_head];
-  while(len--)
-  {
-        memcpy(buffer,start,min*sizeof(float));
-       // printf(" Target :%d removed :%d\n",_target,_removed);
-        buffer+=min;
-        rendered+=min;
+  len=len/chan; // in sample
 
-       
-        _target++; // _target is the number of sample we processed
-
-        _modulo++;
-
-        if(_target>960) // Time to duplicate samples
+        uint32_t maxSample=max/chan; // in sample
+        uint32_t nbOut=0;
+        uint32_t nbIn=len;
+        uint32_t nbInTaken=0;
+        float *from,*to;
+        from=_incomingBuffer+_head;
+        to=buffer;
+        if(true!=resampler.process(from,to, 
+                    nbIn,
+                    maxSample,
+                    &nbInTaken, 
+                    &nbOut))
         {
-            _removed+=41;
-            _target-=960;
+            printf("[FilmChange] EOF ??\n");
+            *status=AUD_END_OF_STREAM;
+            return 0;
         }
-        if(rendered>=max-1)
-        {
-            start+=min;
-            _head+=min;
-            return rendered;
-        }
-        //_______________________________________
-        // Pal2Film : 25 fps to 24 fps -> Duplicate samples
-        // by 41 samples every 960 samples 960->1001
-        //______________________________________
-        if(_removed /*&& ((_modulo&15)==1)*/) // Spread the duplication
-        {
-          memcpy(buffer,start,min*sizeof(float));
-          buffer+=min;
-          rendered+=min;			
-          _removed--;
-        }  
-        start+=min;
-        _head+=min;
-  }
-  return rendered;
+      _head=_head+(nbInTaken*chan);
+      return nbOut*chan;
 };
+
 //EOF
 

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audiofilter_film2pal.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audiofilter_film2pal.h	2008-07-20 17:27:33 UTC (rev 4265)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audiofilter_film2pal.h	2008-07-20 17:30:11 UTC (rev 4266)
@@ -17,29 +17,29 @@
 #define AUDIO_F_FILM2PAL_H
 
 #include "ADM_audioFilter.h"
-#include "audiofilter_limiter_param.h"
-class AUDMAudioFilterFilm2Pal : public AUDMAudioFilter
+#include "audiofilter_SRC.h"
+#define BLK_SIZE 512
+
+class AUDMAudioFilterFilmChange : public AUDMAudioFilter
 {
   protected:
-    uint32_t   _target;
-    uint32_t _removed;
-    uint32_t _modulo;
+    ADM_resample          resampler;
   public:
-                          AUDMAudioFilterFilm2Pal(AUDMAudioFilter *previous);
-    virtual                ~AUDMAudioFilterFilm2Pal();
+                          AUDMAudioFilterFilmChange(AUDMAudioFilter *previous,uint32_t from, uint32_t to);
+    virtual                ~AUDMAudioFilterFilmChange();
     virtual    uint32_t   fill(uint32_t max,float *output,AUD_Status *status);
 };
-class AUDMAudioFilterPal2Film : public AUDMAudioFilter
+class AUDMAudioFilterPal2Film : public AUDMAudioFilterFilmChange
 {
   protected:
-    uint32_t   _target;
-    uint32_t _removed;
-    uint32_t _modulo;
-
   public:
                             AUDMAudioFilterPal2Film(AUDMAudioFilter *previous);
-    virtual                ~AUDMAudioFilterPal2Film();
-    virtual    uint32_t   fill(uint32_t max,float *output,AUD_Status *status);
 };
+class AUDMAudioFilterFilm2Pal : public AUDMAudioFilterFilmChange
+{
+  protected:
+  public:
+                            AUDMAudioFilterFilm2Pal(AUDMAudioFilter *previous);
+};
 
 #endif

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/src/ADM_audioFilter.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/src/ADM_audioFilter.cpp	2008-07-20 17:27:33 UTC (rev 4265)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/src/ADM_audioFilter.cpp	2008-07-20 17:30:11 UTC (rev 4266)
@@ -32,6 +32,7 @@
   if(_previous)
   {
       memcpy(&_wavHeader,_previous->getInfo(),sizeof(_wavHeader));
+      _wavHeader.bitspersample=16; // We deal with PCM here...
       _length=previous->getLength();
   }
   _head=_tail=0; 

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/src/ADM_audioResample.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/src/ADM_audioResample.cpp	2008-07-20 17:27:33 UTC (rev 4265)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/src/ADM_audioResample.cpp	2008-07-20 17:30:11 UTC (rev 4266)
@@ -48,7 +48,7 @@
     fromFrequency=from;
     toFrequency=to;
     nbChannels=channel;
-    context=(void *)src_new (SRC_SINC_MEDIUM_QUALITY, channel, &er) ;
+    context=(void *)src_new (SRC_SINC_FASTEST*0+1*SRC_SINC_MEDIUM_QUALITY, channel, &er) ;
     if(!context) 
     {
         printf("[SRC] Error :%d\n",er);



From mean at mail.berlios.de  Sun Jul 20 19:30:51 2008
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sun, 20 Jul 2008 19:30:51 +0200
Subject: [Avidemux-svn-commit] r4267 -
	branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter
Message-ID: <200807201730.m6KHUpYT011404@sheep.berlios.de>

Author: mean
Date: 2008-07-20 19:30:51 +0200 (Sun, 20 Jul 2008)
New Revision: 4267

Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audiofilter_film2pal.cpp
Log:
[pal2film] Prevent overflow


Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audiofilter_film2pal.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audiofilter_film2pal.cpp	2008-07-20 17:30:11 UTC (rev 4266)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audiofilter_film2pal.cpp	2008-07-20 17:30:51 UTC (rev 4267)
@@ -63,8 +63,8 @@
   fillIncomingBuffer(status);
   
   len=_tail-_head;
-  if(max>64)
-    max-=64; // Prevent overflow
+  int nbBlock=max/1001;
+  max=nbBlock*960; // Prevent overflow when slowing down
 
   if(len>max) len=max;
   



From gruntster at mail.berlios.de  Mon Jul 21 17:58:58 2008
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Mon, 21 Jul 2008 17:58:58 +0200
Subject: [Avidemux-svn-commit] r4268 - in branches/avidemux_2.4_branch: .
	avidemux avidemux/testing
Message-ID: <200807211558.m6LFwwTA031408@sheep.berlios.de>

Author: gruntster
Date: 2008-07-21 17:58:49 +0200 (Mon, 21 Jul 2008)
New Revision: 4268

Added:
   branches/avidemux_2.4_branch/avidemux/testing/
   branches/avidemux_2.4_branch/avidemux/testing/CMakeLists.txt
   branches/avidemux_2.4_branch/avidemux/testing/tester.cpp
Modified:
   branches/avidemux_2.4_branch/CMakeLists.txt
   branches/avidemux_2.4_branch/avidemux/CMakeLists.txt
Log:
[CTest] preliminary test scripts

Modified: branches/avidemux_2.4_branch/CMakeLists.txt
===================================================================
--- branches/avidemux_2.4_branch/CMakeLists.txt	2008-07-20 17:30:51 UTC (rev 4267)
+++ branches/avidemux_2.4_branch/CMakeLists.txt	2008-07-21 15:58:49 UTC (rev 4268)
@@ -8,6 +8,7 @@
 PROJECT(Avidemux2)
 CMAKE_MINIMUM_REQUIRED(VERSION 2.4.4)
 SET(CMAKE_COLOR_MAKEFILE ON)
+enable_testing()
 
 # where to look first for cmake modules, before ${CMAKE_ROOT}/Modules/ is checked
 SET(CMAKE_MODULE_PATH "${CMAKE_SOURCE_DIR}/cmake")

Modified: branches/avidemux_2.4_branch/avidemux/CMakeLists.txt
===================================================================
--- branches/avidemux_2.4_branch/avidemux/CMakeLists.txt	2008-07-20 17:30:51 UTC (rev 4267)
+++ branches/avidemux_2.4_branch/avidemux/CMakeLists.txt	2008-07-21 15:58:49 UTC (rev 4268)
@@ -455,4 +455,9 @@
 
 INSTALL(TARGETS ${ADM_EXES} RUNTIME DESTINATION bin LIBRARY DESTINATION lib)
 
+###############
+# Testing
+###############
+add_subdirectory(testing)
+
 # EOF

Added: branches/avidemux_2.4_branch/avidemux/testing/CMakeLists.txt
===================================================================
--- branches/avidemux_2.4_branch/avidemux/testing/CMakeLists.txt	2008-07-20 17:30:51 UTC (rev 4267)
+++ branches/avidemux_2.4_branch/avidemux/testing/CMakeLists.txt	2008-07-21 15:58:49 UTC (rev 4268)
@@ -0,0 +1,41 @@
+macro(admTest category url_dir url_filename video_codec audio_codec output_format md5sum)
+	if (${output_format} STREQUAL "AVI_UNP")
+		set(params "--force-unpack")
+	else (${output_format} STREQUAL "AVI_UNP")
+		set(params)
+	endif (${output_format} STREQUAL "AVI_UNP")
+
+	add_test(
+		${category}
+		${CMAKE_CURRENT_BINARY_DIR}/tester
+		samples/${category}
+		${url_filename}
+		"${url_dir}/${url_filename}"
+		"--nogui --autoindex ${params} --load samples/${category}/${url_filename} --video-codec ${video_codec} --audio-codec ${audio_codec} --output-format ${output_format} --save ${OUTPUT_PATH}/${OUTPUT_FILE} --quit"
+		${md5sum}
+	)
+endmacro(admTest)
+
+add_executable(tester tester.cpp)
+
+if (WIN32)
+	target_link_libraries(tester "-Wl,-subsystem,console")
+endif (WIN32)
+
+find_program(WGET_PATH wget)
+find_program(MD5SUM_PATH md5sum)
+find_program(AVIDEMUX_PATH avidemux2_cli PATHS "${CMAKE_BINARY_DIR}/avidemux")
+set(OUTPUT_PATH "${CMAKE_CURRENT_BINARY_DIR}/_output")
+set(OUTPUT_FILE "output")
+
+file(WRITE "${CMAKE_CURRENT_BINARY_DIR}/tester.cfg" "${WGET_PATH}\n")
+file(APPEND "${CMAKE_CURRENT_BINARY_DIR}/tester.cfg" "${MD5SUM_PATH}\n")
+file(APPEND "${CMAKE_CURRENT_BINARY_DIR}/tester.cfg" "${AVIDEMUX_PATH}\n")
+file(APPEND "${CMAKE_CURRENT_BINARY_DIR}/tester.cfg" "${OUTPUT_PATH}\n")
+file(APPEND "${CMAKE_CURRENT_BINARY_DIR}/tester.cfg" "${OUTPUT_FILE}\n")
+
+add_test(basic_run ${AVIDEMUX_PATH})
+admTest(asf http://samples.mplayerhq.hu/asf-wmv elephant.asf XVID4 MP3 AVI 6d65a64f0ad4f4fedc139ac37a9127a5)
+admTest(ts http://samples.mplayerhq.hu/MPEG2 foxksaz.ts Copy AC3 AVI 0)
+admTest(avi http://samples.mplayerhq.hu/avi verona60avi56k.avi XVID4 MP3 AVI 0)
+admTest(avi_unpack http://samples.mplayerhq.hu/avi GoneNutty.avi Copy Copy AVI_UNP d472495e2e8a19535ba9fb09b444c859)
\ No newline at end of file

Added: branches/avidemux_2.4_branch/avidemux/testing/tester.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/testing/tester.cpp	2008-07-20 17:30:51 UTC (rev 4267)
+++ branches/avidemux_2.4_branch/avidemux/testing/tester.cpp	2008-07-21 15:58:49 UTC (rev 4268)
@@ -0,0 +1,220 @@
+#include <sys/stat.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <string.h>
+#include <dirent.h>
+
+static char wgetPath[255];
+static char md5sumPath[255];
+static char avidemuxPath[255];
+static char outputPath[255];
+static char outputFile[255];
+
+bool wipeOutputDirectory(void)
+{
+	DIR *dir = opendir(outputPath);
+
+	if (dir)
+	{
+		struct dirent *ent;
+		char path[255];
+		bool error = false;
+
+		getcwd(path, 255);
+		chdir(outputPath);
+
+		while ((ent = readdir(dir)) != NULL)
+		{
+			if (strcmp(ent->d_name, ".") != 0 && strcmp(ent->d_name, "..") != 0)
+			{
+				if (remove(ent->d_name) != 0)
+				{
+					fprintf(stderr, "Error removing file (%s) from output directory\n", ent->d_name);
+					error = true;
+					break;
+				}
+			}
+		}
+
+		chdir(path);
+		closedir(dir);
+
+		return !error;
+	}
+	else
+#ifdef __WIN32
+		return mkdir(outputPath) == 0;
+#else
+		return mkdir(outputPath, ACCESSPERMS) == 0;
+#endif
+}
+
+bool removeIdxFile(const char* inputDirectory, const char* inputFilename)
+{
+	char curDir[255];
+	char idxPath[255 * 2];
+	bool success = false;
+
+	getcwd(curDir, 255);
+
+	strcpy(idxPath, inputFilename);
+	strcat(idxPath, ".idx");
+
+	chdir(inputDirectory);
+
+	FILE* fp = fopen(idxPath, "rb");
+
+	if (fp == NULL)
+		success = true;
+	else
+	{
+		fclose(fp);
+
+		success = (remove(idxPath) == 0);
+
+		if (!success)
+			fprintf(stderr, "Unable to delete idx file %s/%s\n", inputDirectory, idxPath);
+	}
+
+	chdir(curDir);
+
+	return success;
+}
+
+bool performTest(const char* inputDirectory, const char* inputFilename, const char* url, const char* avidemuxParams, const char* md5sum)
+{
+	char cmdline[2000];
+
+	strcpy(cmdline, wgetPath);
+	strcat(cmdline, " --directory-prefix ");
+	strcat(cmdline, inputDirectory);
+	strcat(cmdline, " --timestamping ");
+	strcat(cmdline, url);
+
+	if (system(cmdline) != 0)
+	{
+		fprintf(stderr, "Error executing %s\n", cmdline);
+		return false;
+	}
+
+	if (!removeIdxFile(inputDirectory, inputFilename))
+		return false;
+
+	strcpy(cmdline, avidemuxPath);
+	strcat(cmdline, " ");
+	strcat(cmdline, avidemuxParams);
+
+	if (system(cmdline) != 0)
+	{
+		fprintf(stderr, "Error executing %s\n", avidemuxPath);
+		return false;
+	}
+
+	if (!removeIdxFile(inputDirectory, inputFilename))
+		return false;
+
+	char path[255 * 2];
+
+	strcpy(path, md5sumPath);
+	strcat(path, " -b ");
+	strcat(path, outputPath);
+	strcat(path, "/");
+	strcat(path, outputFile);
+
+	FILE *outputStream = popen(path, "r");
+	char result[35];
+
+	if (outputStream)
+	{
+		memset(result, 0, sizeof(result));
+		fread(result, 1, sizeof(result) - 1, outputStream);
+		fclose(outputStream);
+
+		if (strcmp(result + strlen(result) - 2, " *") == 0)
+			result[strlen(result) - 2] = 0;
+		else
+		{
+			fprintf(stderr, "Error parsing MD5 sum: %s\n", result);
+			return false;
+		}
+	}
+	else
+	{
+		fprintf(stderr, "Error executing %s\n", path);
+		return false;
+	}
+
+	printf("original md5 sum: %s\n", md5sum);
+	printf("new md5 sum     : %s\n", result);
+
+	if (strcmp(md5sum, result) != 0)
+	{
+		fprintf(stderr, "MD5 sums do not match\n");
+		return false;
+	}
+
+	return true;
+}
+
+int main(int argc, char *argv[])
+{
+	bool success = false;
+	FILE* configFile = fopen("tester.cfg", "rt");
+
+	while (true)
+	{
+		if (argc != 6)
+		{
+			fprintf(stderr, "Incorrect number of arguments (%d instead of 5)\n", argc);
+			break;
+		}
+
+		if (!configFile)
+		{
+			char path[255];
+
+			getcwd(path, 255);
+			fprintf(stderr, "Error opening %s/tester.cfg\n", path);
+
+			break;
+		}
+
+		if (fgets(wgetPath, 255, configFile))
+			wgetPath[strlen(wgetPath) - 1] = 0;
+		else
+			break;
+
+		if (fgets(md5sumPath, 255, configFile))
+			md5sumPath[strlen(md5sumPath) - 1] = 0;
+		else
+			break;
+
+		if (fgets(avidemuxPath, 255, configFile))
+			avidemuxPath[strlen(avidemuxPath) - 1] = 0;
+		else
+			break;
+
+		if (fgets(outputPath, 255, configFile))
+			outputPath[strlen(outputPath) - 1] = 0;
+		else
+			break;
+
+		if (fgets(outputFile, 255, configFile))
+			outputFile[strlen(outputFile) - 1] = 0;
+		else
+			break;
+
+		if (!wipeOutputDirectory())
+			break;
+
+		success = performTest(argv[1], argv[2], argv[3], argv[4], argv[5]);
+
+		break;
+	}
+
+	if (configFile)
+		fclose(configFile);
+
+	return !success;
+}



From mean at mail.berlios.de  Mon Jul 21 19:24:21 2008
From: mean at mail.berlios.de (mean at BerliOS)
Date: Mon, 21 Jul 2008 19:24:21 +0200
Subject: [Avidemux-svn-commit] r4269 - in
	branches/avidemux_2.4_branch/avidemux: ADM_codecs
	ADM_libraries/ADM_lavformat
Message-ID: <200807211724.m6LHOLL8009331@sheep.berlios.de>

Author: mean
Date: 2008-07-21 19:24:20 +0200 (Mon, 21 Jul 2008)
New Revision: 4269

Modified:
   branches/avidemux_2.4_branch/avidemux/ADM_codecs/ADM_x264.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/ADM_lavformat.h
Log:
[x264] Dont delay pts, it is already delayed by one by the muxer

Modified: branches/avidemux_2.4_branch/avidemux/ADM_codecs/ADM_x264.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_codecs/ADM_x264.cpp	2008-07-21 15:58:49 UTC (rev 4268)
+++ branches/avidemux_2.4_branch/avidemux/ADM_codecs/ADM_x264.cpp	2008-07-21 17:24:20 UTC (rev 4269)
@@ -290,7 +290,7 @@
     if(admParam.BasReference)
     {
     //  printf("%u +=%u\n",out->ptsFrame,admParam.MaxBFrame);
-      out->ptsFrame+=admParam.MaxBFrame;
+    //  out->ptsFrame+=1;
     }
   //printf("Frame :%lld \n",pic_out.i_pts);
   switch (pic_out.i_type)

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/ADM_lavformat.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/ADM_lavformat.h	2008-07-21 15:58:49 UTC (rev 4268)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/ADM_lavformat.h	2008-07-21 17:24:20 UTC (rev 4269)
@@ -42,6 +42,8 @@
                 ADM_MUXER_TYPE _type;
                 uint8_t  _restamp;
                 ADM_MUXER_TYPE _muxerType;
+                uint64_t  _curDTS;  // Current decoder time stamp in us (for video)
+                uint32_t one;       // Duration of one video frame in us
 
 public:
         virtual uint8_t open(const char *filename,uint32_t inbitrate, ADM_MUXER_TYPE type, 



From mean at mail.berlios.de  Mon Jul 21 19:59:12 2008
From: mean at mail.berlios.de (mean at BerliOS)
Date: Mon, 21 Jul 2008 19:59:12 +0200
Subject: [Avidemux-svn-commit] r4270 -
	branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat
Message-ID: <200807211759.m6LHxCZc006378@sheep.berlios.de>

Author: mean
Date: 2008-07-21 19:59:11 +0200 (Mon, 21 Jul 2008)
New Revision: 4270

Modified:
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/ADM_lavformat.cpp
Log:
[LavFormat] cleanup

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/ADM_lavformat.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/ADM_lavformat.cpp	2008-07-21 17:24:20 UTC (rev 4269)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/ADM_lavformat.cpp	2008-07-21 17:59:11 UTC (rev 4270)
@@ -58,9 +58,6 @@
 static    AVStream *audio_st, *video_st;
 static    double audio_pts, video_pts;
 
-static uint32_t one;
-uint64_t  _curDTS;
-
 static uint8_t ADM_4cc_to_lavcodec(const char *fcc, CodecID *outlavid);
 static uint8_t ADM_WaveTag_to_lavcodec(uint32_t tag, CodecID *outlavid);
 



From mean at mail.berlios.de  Mon Jul 21 21:15:55 2008
From: mean at mail.berlios.de (mean at BerliOS)
Date: Mon, 21 Jul 2008 21:15:55 +0200
Subject: [Avidemux-svn-commit] r4271 -
	branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter
Message-ID: <200807211915.m6LJFtvH003934@sheep.berlios.de>

Author: mean
Date: 2008-07-21 21:15:54 +0200 (Mon, 21 Jul 2008)
New Revision: 4271

Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioEncoderApi.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audio_encoderPlugin.cpp
Log:
[AudioCodec] Fix save/load bitrate through JavaScript + update UI when set by JS


Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioEncoderApi.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioEncoderApi.h	2008-07-21 17:59:11 UTC (rev 4270)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audioEncoderApi.h	2008-07-21 19:15:54 UTC (rev 4271)
@@ -16,7 +16,7 @@
 uint8_t audioCodecSetByIndex(int i);
 /// Spawn a new encoder
 AUDMEncoder *audioEncoderCreate(AUDMAudioFilter *filter);
-/// Select a encoder by its name e.g. "lame"
+/// Select a encoder by its name e.g. "lame", used only by JS. Update UI as well
 uint8_t audioCodecSetByName( const char *name);
 /// Returns the name of the currently selected codec
 const char *audioCodecGetName( void );

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audio_encoderPlugin.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audio_encoderPlugin.cpp	2008-07-21 17:59:11 UTC (rev 4270)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiofilter/audio_encoderPlugin.cpp	2008-07-21 19:15:54 UTC (rev 4271)
@@ -162,6 +162,15 @@
 
 	return 1;
 }
+/**
+    \fn audioPrintCurrentCodec
+    \brief updates the UI with the current selected audio encoder
+*/
+void UI_setAudioCodec( int i);
+void audioPrintCurrentCodec(void)
+{
+			UI_setAudioCodec(currentEncoder);
+}
 
 /**
     \fn ADM_encoderByName
@@ -201,11 +210,21 @@
 {
 	return currentEncoder;
 }
-
 /**
-    \fn     
-    \brief
+    \fn audioCodecSelect
+    \brief Update UI
 */
+uint8_t DIA_audioCodec( int *codec );
+void audioCodecSelect( void )
+{
+ 
+	DIA_audioCodec( &currentEncoder );
+	audioPrintCurrentCodec();
+}
+/**
+    \fn     audioCodecSetByName
+    \brief  only called by JS, we have to update UI as well
+*/
 uint8_t audioCodecSetByName( const char *name)
 {
 		for(uint32_t i=0;i<ListOfAudioEncoder.size();i++)
@@ -214,6 +233,7 @@
 			{
 
 				currentEncoder=i;
+                audioPrintCurrentCodec(); // Update UI
 				return 1;
 			}
 
@@ -243,28 +263,7 @@
       return ListOfAudioEncoder[currentEncoder]->codecName;
 
 }
-/**
-    \fn audioPrintCurrentCodec
-    \brief updates the UI with the current selected audio encoder
-*/
-void UI_setAudioCodec( int i);
-void audioPrintCurrentCodec(void)
-{
-			UI_setAudioCodec(currentEncoder);
-}
-/**
-    \fn audioCodecSelect
-    \brief
-*/
-uint8_t DIA_audioCodec( int *codec );
-void audioCodecSelect( void )
-{
- 
-	DIA_audioCodec( &currentEncoder );
-	audioPrintCurrentCodec();
 
-
-}
 /**
     \fn audioProcessMode
     \brief
@@ -361,6 +360,7 @@
     }
      ADM_assert(currentEncoder<ListOfAudioEncoder.size());
      ADM_audioEncoder *encoder= ListOfAudioEncoder[currentEncoder];
+     *bitrate=encoder->getBitrate();
      if(encoder->getConfigurationData)
         return encoder->getConfigurationData(extraDataSize,extradata);
      else return 1;
@@ -377,6 +377,7 @@
     }
      ADM_assert(currentEncoder<ListOfAudioEncoder.size());
      ADM_audioEncoder *encoder= ListOfAudioEncoder[currentEncoder];
+     encoder->setBitrate(bitrate);
      if(encoder->setConfigurationData)
         return encoder->setConfigurationData(extraDataSize,extradata);
     else return 1;



From gruntster at mail.berlios.de  Wed Jul 23 17:43:00 2008
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Wed, 23 Jul 2008 17:43:00 +0200
Subject: [Avidemux-svn-commit] r4273 - in
	branches/avidemux_2.4_branch/avidemux: ADM_infoExtractor
	ADM_inputs/ADM_mpegdemuxer
Message-ID: <200807231543.m6NFh0eL017321@sheep.berlios.de>

Author: gruntster
Date: 2008-07-23 17:42:52 +0200 (Wed, 23 Jul 2008)
New Revision: 4273

Modified:
   branches/avidemux_2.4_branch/avidemux/ADM_infoExtractor/ADM_infoextractor.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_indexer_h264.cpp
Log:
[M2TS] determine correct width/height when reading high profile H.264 in TS container

Modified: branches/avidemux_2.4_branch/avidemux/ADM_infoExtractor/ADM_infoextractor.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_infoExtractor/ADM_infoextractor.cpp	2008-07-22 13:09:57 UTC (rev 4272)
+++ branches/avidemux_2.4_branch/avidemux/ADM_infoExtractor/ADM_infoextractor.cpp	2008-07-23 15:42:52 UTC (rev 4273)
@@ -363,8 +363,9 @@
             get_ue_golomb(&s);  //bit_depth_luma_minus8
             get_ue_golomb(&s);  //bit_depth_chroma_minus8
             get_bits1(&s);
-            get_bits1(&s); //incomplete FIXME
-           }    // /??
+			if (get_bits1(&s))
+				get_bits(&s, 8);
+           }
            
 
            dum=get_ue_golomb(&s); // log2_max_frame_num_minus4

Modified: branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_indexer_h264.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_indexer_h264.cpp	2008-07-22 13:09:57 UTC (rev 4272)
+++ branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_indexer_h264.cpp	2008-07-23 15:42:52 UTC (rev 4273)
@@ -150,7 +150,7 @@
               {
                     // Our firt frame is here
                     // Important to initialize the mpeg decoder !
-                    
+                    _run->imageAR = 1;	// 1:1 to suppress warning
                     _run->imageFPS=25000; 
                     //
                     



From gruntster at mail.berlios.de  Wed Jul 23 18:47:50 2008
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Wed, 23 Jul 2008 18:47:50 +0200
Subject: [Avidemux-svn-commit] r4274 - in
	branches/avidemux_2.4_branch/avidemux: . ADM_codecs
	ADM_libraries/ADM_utilities ADM_outputs/oplug_mpeg
	ADM_userInterfaces/ADM_commonUI
Message-ID: <200807231647.m6NGlo90010692@sheep.berlios.de>

Author: gruntster
Date: 2008-07-23 18:47:32 +0200 (Wed, 23 Jul 2008)
New Revision: 4274

Modified:
   branches/avidemux_2.4_branch/avidemux/ADM_codecs/ADM_codecs.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_utilities/prefs.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_outputs/oplug_mpeg/op_mpegpass.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_prefs.cpp
   branches/avidemux_2.4_branch/avidemux/prefs.h
   branches/avidemux_2.4_branch/avidemux/prefs.in
Log:
[Pref] use libavcodec as default MPEG-2 decoder

Modified: branches/avidemux_2.4_branch/avidemux/ADM_codecs/ADM_codecs.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_codecs/ADM_codecs.cpp	2008-07-23 15:42:52 UTC (rev 4273)
+++ branches/avidemux_2.4_branch/avidemux/ADM_codecs/ADM_codecs.cpp	2008-07-23 16:47:32 UTC (rev 4274)
@@ -418,7 +418,7 @@
     {
       uint32_t lavcodec_mpeg = 0;
       printf ("\n using Mpeg1/2 codec (libmpeg2)\n");
-      if (!prefs->get (FEATURE_USE_LAVCODEC_MPEG, &lavcodec_mpeg))
+      if (!prefs->get (FEATURE_USE_LAVCODEC_MPEG2, &lavcodec_mpeg))
 	{
 	  lavcodec_mpeg = 0;
 	}

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_utilities/prefs.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_utilities/prefs.cpp	2008-07-23 15:42:52 UTC (rev 4273)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_utilities/prefs.cpp	2008-07-23 16:47:32 UTC (rev 4274)
@@ -127,7 +127,7 @@
 	{"feature.svcdres.preferedsourceratio",		STRING,"1:1",	NULL, NULL, NULL },
 	{"feature.saveprefsonexit",		UINT,	"1",	NULL,	"0",	"1"	},
 	{"feature.ignoresavedmarkers",		UINT,	"0",	NULL,	"0",	"1"	},
-	{"feature.use_lavcodec_mpeg",		UINT,	"0",	NULL,	"0",	"1"	},
+	{"feature.use_lavcodec_mpeg2",		UINT,	"1",	NULL,	"0",	"1"	},
 	{"feature.disable_nuv_resync",		UINT,	"0",	NULL,	"0",	"1"	},
 	{"feature.tryautoidx",		UINT,	"0",	NULL,	"0",	"1"	},
 	{"feature.use_odml",		UINT,	"0",	NULL,	"0",	"1"	},

Modified: branches/avidemux_2.4_branch/avidemux/ADM_outputs/oplug_mpeg/op_mpegpass.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_outputs/oplug_mpeg/op_mpegpass.cpp	2008-07-23 15:42:52 UTC (rev 4273)
+++ branches/avidemux_2.4_branch/avidemux/ADM_outputs/oplug_mpeg/op_mpegpass.cpp	2008-07-23 16:47:32 UTC (rev 4274)
@@ -117,7 +117,7 @@
 	WAVHeader *hdr=audio->getInfo();
 	uint32_t isMpeg1;
 	uint32_t isLav;
-	if(!prefs->get(FEATURE_USE_LAVCODEC_MPEG, &isLav))
+	if(!prefs->get(FEATURE_USE_LAVCODEC_MPEG2, &isLav))
 		{
 		 isLav=0;
 		}

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_prefs.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_prefs.cpp	2008-07-23 15:42:52 UTC (rev 4273)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_prefs.cpp	2008-07-23 16:47:32 UTC (rev 4274)
@@ -154,7 +154,7 @@
         if(!prefs->get(SETTINGS_MPEGSPLIT, &autosplit))
                 autosplit=690;		
                         
-        if(!prefs->get(FEATURE_USE_LAVCODEC_MPEG, &lavcodec_mpeg))
+        if(!prefs->get(FEATURE_USE_LAVCODEC_MPEG2, &lavcodec_mpeg))
                 lavcodec_mpeg=0;
         // Open DML (Gmv)
         if(!prefs->get(FEATURE_USE_ODML, &use_odml))
@@ -490,7 +490,7 @@
                 // Video render
                 prefs->set(DEVICE_VIDEODEVICE,render);
                 // Mpeg /lavcodec
-                prefs->set(FEATURE_USE_LAVCODEC_MPEG, lavcodec_mpeg);
+                prefs->set(FEATURE_USE_LAVCODEC_MPEG2, lavcodec_mpeg);
                 // Odml
                 prefs->set(FEATURE_USE_ODML, use_odml);
 				// Split

Modified: branches/avidemux_2.4_branch/avidemux/prefs.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/prefs.h	2008-07-23 15:42:52 UTC (rev 4273)
+++ branches/avidemux_2.4_branch/avidemux/prefs.h	2008-07-23 16:47:32 UTC (rev 4274)
@@ -65,7 +65,7 @@
 	FEATURE_SVCDRES_PREFEREDSOURCERATIO,
 	FEATURE_SAVEPREFSONEXIT,
 	FEATURE_IGNORESAVEDMARKERS,
-	FEATURE_USE_LAVCODEC_MPEG,
+	FEATURE_USE_LAVCODEC_MPEG2,
 	FEATURE_DISABLE_NUV_RESYNC,
 	FEATURE_TRYAUTOIDX,
 	FEATURE_USE_ODML,

Modified: branches/avidemux_2.4_branch/avidemux/prefs.in
===================================================================
--- branches/avidemux_2.4_branch/avidemux/prefs.in	2008-07-23 15:42:52 UTC (rev 4273)
+++ branches/avidemux_2.4_branch/avidemux/prefs.in	2008-07-23 16:47:32 UTC (rev 4274)
@@ -82,7 +82,7 @@
 feature.svcdres.preferedsourceratio,	STRING, "1:1"
 feature.saveprefsonexit,		UINT,	1,	0,	1
 feature.ignoresavedmarkers,		UINT,	0,	0,	1
-feature.use_lavcodec_mpeg,		UINT,	0,	0,	1
+feature.use_lavcodec_mpeg2,		UINT,	1,	0,	1
 feature.disable_nuv_resync,		UINT,	0,	0,	1
 feature.tryautoidx,			UINT,	0,	0,	1
 feature.use_odml,                       UINT,   0,      0,      1



From mean at mail.berlios.de  Wed Jul 23 20:58:15 2008
From: mean at mail.berlios.de (mean at BerliOS)
Date: Wed, 23 Jul 2008 20:58:15 +0200
Subject: [Avidemux-svn-commit] r4275 - branches/avidemux_2.4_branch
Message-ID: <200807231858.m6NIwFPg030187@sheep.berlios.de>

Author: mean
Date: 2008-07-23 20:58:15 +0200 (Wed, 23 Jul 2008)
New Revision: 4275

Modified:
   branches/avidemux_2.4_branch/ConfigureChecks.cmake
   branches/avidemux_2.4_branch/configure.in.in
Log:
[2.4.3] Bump version number

Modified: branches/avidemux_2.4_branch/ConfigureChecks.cmake
===================================================================
--- branches/avidemux_2.4_branch/ConfigureChecks.cmake	2008-07-23 16:47:32 UTC (rev 4274)
+++ branches/avidemux_2.4_branch/ConfigureChecks.cmake	2008-07-23 18:58:15 UTC (rev 4275)
@@ -127,8 +127,8 @@
 ########################################
 # Standard Avidemux defines
 ########################################
-SET(VERSION 2.4.2)
-SET(PACKAGE_VERSION 2.4.2)
+SET(VERSION 2.4.3)
+SET(PACKAGE_VERSION 2.4.3)
 
 SET(HAVE_BUILTIN_VECTOR 1)
 SET(HAVE_AUDIO 1)

Modified: branches/avidemux_2.4_branch/configure.in.in
===================================================================
--- branches/avidemux_2.4_branch/configure.in.in	2008-07-23 16:47:32 UTC (rev 4274)
+++ branches/avidemux_2.4_branch/configure.in.in	2008-07-23 18:58:15 UTC (rev 4275)
@@ -38,7 +38,7 @@
 dnl Perform program name transformation
 AC_ARG_PROGRAM
 dnl Automake doc recommends to do this only here. (Janos)
-AM_INIT_AUTOMAKE(avidemux,"2.4.2")
+AM_INIT_AUTOMAKE(avidemux,"2.4.3")
 ADM_SUBVERSION="0"
 
 if [[ -f .svn/entries ]]; then



From mean at mail.berlios.de  Wed Jul 23 21:00:41 2008
From: mean at mail.berlios.de (mean at BerliOS)
Date: Wed, 23 Jul 2008 21:00:41 +0200
Subject: [Avidemux-svn-commit] r4276 - tags
Message-ID: <200807231900.m6NJ0fIe030476@sheep.berlios.de>

Author: mean
Date: 2008-07-23 21:00:41 +0200 (Wed, 23 Jul 2008)
New Revision: 4276

Added:
   tags/avidemux_2.4.3/
Log:


Copied: tags/avidemux_2.4.3 (from rev 4275, branches/avidemux_2.4_branch)



From gruntster at mail.berlios.de  Thu Jul 24 12:51:28 2008
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Thu, 24 Jul 2008 12:51:28 +0200
Subject: [Avidemux-svn-commit] r4277 -
	branches/avidemux_2.4_branch/avidemux/ADM_script
Message-ID: <200807241051.m6OApSDr008612@sheep.berlios.de>

Author: gruntster
Date: 2008-07-24 12:50:36 +0200 (Thu, 24 Jul 2008)
New Revision: 4277

Modified:
   branches/avidemux_2.4_branch/avidemux/ADM_script/ADM_JSDirectorySearch.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_script/ADM_JSDirectorySearch.h
   branches/avidemux_2.4_branch/avidemux/ADM_script/DirectorySearch.cpp
Log:
[ECMA] add GetFilePath to DirectorySearch class

Modified: branches/avidemux_2.4_branch/avidemux/ADM_script/ADM_JSDirectorySearch.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_script/ADM_JSDirectorySearch.cpp	2008-07-23 19:00:41 UTC (rev 4276)
+++ branches/avidemux_2.4_branch/avidemux/ADM_script/ADM_JSDirectorySearch.cpp	2008-07-24 10:50:36 UTC (rev 4277)
@@ -29,6 +29,7 @@
 	{ "Close", Close, 0, 0, 0 },	// Close the search
 	{ "GetFileName", GetFileName, 0, 0, 0 },	// return the current file name
 	{ "GetFileDirectory", GetFileDirectory, 0, 0, 0 },	// returns the directory of the file
+	{ "GetFilePath", GetFilePath, 0, 0, 0 },	// returns the full path of the file
 	{ "NextFile", NextFile, 0, 0, 0 },	// Advance search to the next file
 	{ "GetFileSize", GetFileSize, 0, 0, 0 },	// Returns the size of the file in bytes
 	{ "GetExtension", GetExtension, 0, 0, 0 },	// Returns the extension of the current file
@@ -214,6 +215,17 @@
 	return JS_TRUE;
 }// end GetFileDirectory
 
+JSBool ADM_JSDirectorySearch::GetFilePath(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
+{// begin GetFilePath
+	ADM_JSDirectorySearch *p = (ADM_JSDirectorySearch *)JS_GetPrivate(cx, obj);
+	// default return value
+	*rval = BOOLEAN_TO_JSVAL(false);
+	if(argc != 0)
+		return JS_FALSE;
+	*rval = STRING_TO_JSVAL(JS_NewStringCopyZ(cx,p->getObject()->GetFilePath().c_str()));
+	return JS_TRUE;
+}// end GetFilePath
+
 JSBool ADM_JSDirectorySearch::GetFileName(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
 {// begin GetFileName
 	ADM_JSDirectorySearch *p = (ADM_JSDirectorySearch *)JS_GetPrivate(cx, obj);

Modified: branches/avidemux_2.4_branch/avidemux/ADM_script/ADM_JSDirectorySearch.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_script/ADM_JSDirectorySearch.h	2008-07-23 19:00:41 UTC (rev 4276)
+++ branches/avidemux_2.4_branch/avidemux/ADM_script/ADM_JSDirectorySearch.h	2008-07-24 10:50:36 UTC (rev 4277)
@@ -26,6 +26,7 @@
 	static JSBool Init(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval);
 	static JSBool GetFileSize(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval);
 	static JSBool GetFileDirectory(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval);
+	static JSBool GetFilePath(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval);
 	static JSBool GetFileName(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval);
 	static JSBool Close(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval);
 

Modified: branches/avidemux_2.4_branch/avidemux/ADM_script/DirectorySearch.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_script/DirectorySearch.cpp	2008-07-23 19:00:41 UTC (rev 4276)
+++ branches/avidemux_2.4_branch/avidemux/ADM_script/DirectorySearch.cpp	2008-07-24 10:50:36 UTC (rev 4277)
@@ -113,11 +113,9 @@
 		printf("Find first failed\n");
 		return false;
 	}
-#ifdef ADM_WIN32   //ndef __unix__
-	m_sDirectory = GetFileDirectory(sDirectory);
-#else
+
 	m_sDirectory = sDirectory;
-#endif
+
 	return true;
 }// end Init
 



From gruntster at mail.berlios.de  Thu Jul 24 13:15:04 2008
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Thu, 24 Jul 2008 13:15:04 +0200
Subject: [Avidemux-svn-commit] r4278 -
	branches/avidemux_2.4_branch/avidemux/ADM_script
Message-ID: <200807241115.m6OBF4Os005381@sheep.berlios.de>

Author: gruntster
Date: 2008-07-24 13:14:21 +0200 (Thu, 24 Jul 2008)
New Revision: 4278

Modified:
   branches/avidemux_2.4_branch/avidemux/ADM_script/ADM_JSFunctions.cpp
Log:
[ECMA] implement exec() for MinGW

Modified: branches/avidemux_2.4_branch/avidemux/ADM_script/ADM_JSFunctions.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_script/ADM_JSFunctions.cpp	2008-07-24 10:50:36 UTC (rev 4277)
+++ branches/avidemux_2.4_branch/avidemux/ADM_script/ADM_JSFunctions.cpp	2008-07-24 11:14:21 UTC (rev 4278)
@@ -313,14 +313,8 @@
         *rval=STRING_TO_JSVAL(JS_NewStringCopyZ(cx,n));
         return JS_TRUE;
 }
-#ifdef ADM_WIN32
 
 JSBool systemExecute(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
-{
-		return JS_FALSE;
-}
-#else
-JSBool systemExecute(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
 {// begin systemExecute
 	// default return value
 	*rval = INT_TO_JSVAL(-1);
@@ -355,6 +349,8 @@
 		}// end failure to get item
 		args[JSVAL_TO_INT(i)] = JS_GetStringBytes(JSVAL_TO_STRING(jsValue));
 	}
+
+#ifndef __MINGW32__
 	if(getuid() == 0)
 	{// begin running as root
 		JS_ReportError(cx, "exec() disallowed while running as root.");
@@ -370,6 +366,7 @@
 		JS_ReportError(cx, "exec() disallowed execution of \"%s\" since it is a setuid/setgid file.", pExecutable);
 		return JS_FALSE;
 	}// end setuid/setgid files disallowed
+#endif
 
         enterLock();
 	// clear file descriptor table of forked process and fork
@@ -378,6 +375,11 @@
 #elif defined(__FreeBSD__) || defined(__OpenBSD__)
 	pid_t pidRtn = rfork(RFPROC|RFCFDG);
 #endif
+
+#ifdef __MINGW32__
+	intptr_t pidRtn = spawnvpe(bWait ? P_WAIT : P_NOWAIT, pExecutable, args, environ);
+	#define WEXITSTATUS
+#else
 	if(pidRtn == 0)
 	{// begin child process
 #if defined( __linux__) || defined(__macosx__) || defined(__APPLE__)
@@ -405,6 +407,8 @@
 	{// begin rfork failure
 		printf("Error: execve failure errno(%d)\n",errno);
 	}// end rfork failure
+#endif
+
         leaveLock();
 
 	// cleanup
@@ -415,7 +419,7 @@
 		*rval = INT_TO_JSVAL(-1);	// failure
 	return JS_TRUE;
 }// end systemExecute
-#endif
+
 #ifdef ADM_WIN32
 
 JSBool systemInclude(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)



From gruntster at mail.berlios.de  Thu Jul 24 13:24:01 2008
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Thu, 24 Jul 2008 13:24:01 +0200
Subject: [Avidemux-svn-commit] r4279 -
	branches/avidemux_2.4_branch/avidemux/ADM_script
Message-ID: <200807241124.m6OBO165016590@sheep.berlios.de>

Author: gruntster
Date: 2008-07-24 13:23:44 +0200 (Thu, 24 Jul 2008)
New Revision: 4279

Modified:
   branches/avidemux_2.4_branch/avidemux/ADM_script/ADM_JSFunctions.cpp
Log:
[ECMA] fix passing of args to exec()

Modified: branches/avidemux_2.4_branch/avidemux/ADM_script/ADM_JSFunctions.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_script/ADM_JSFunctions.cpp	2008-07-24 11:14:21 UTC (rev 4278)
+++ branches/avidemux_2.4_branch/avidemux/ADM_script/ADM_JSFunctions.cpp	2008-07-24 11:23:44 UTC (rev 4279)
@@ -336,18 +336,18 @@
 		return JS_FALSE;
 
 	JS_GetArrayLength(cx,pArgs,&nArgsLength);
-	char **args = new char *[JSVAL_TO_INT(nArgsLength)+2];
+	char **args = new char *[nArgsLength + 2];
 	args[0] = pExecutable;
-	args[JSVAL_TO_INT(nArgsLength)+1] = NULL;
+	args[nArgsLength + 1] = NULL;
 
-	for(jsuint i = 1;i <= nArgsLength;i++)
+	for(int i = 0; i < nArgsLength; i++)
 	{
 		if(JS_GetElement(cx, pArgs, i, &jsValue) == JS_FALSE)
 		{// begin failure to get item
 			JS_ReportError(cx, "exec() JS_GetElement failed to get an array item.");
 			return JS_FALSE;
 		}// end failure to get item
-		args[JSVAL_TO_INT(i)] = JS_GetStringBytes(JSVAL_TO_STRING(jsValue));
+		args[i + 1] = JS_GetStringBytes(JSVAL_TO_STRING(jsValue));
 	}
 
 #ifndef __MINGW32__



From gruntster at mail.berlios.de  Thu Jul 24 13:50:04 2008
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Thu, 24 Jul 2008 13:50:04 +0200
Subject: [Avidemux-svn-commit] r4280 -
	branches/avidemux_2.4_branch/avidemux/ADM_script
Message-ID: <200807241150.m6OBo4Ig011340@sheep.berlios.de>

Author: gruntster
Date: 2008-07-24 13:49:40 +0200 (Thu, 24 Jul 2008)
New Revision: 4280

Modified:
   branches/avidemux_2.4_branch/avidemux/ADM_script/ADM_JSFunctions.cpp
Log:
[ECMA] implement include() for MinGW

Modified: branches/avidemux_2.4_branch/avidemux/ADM_script/ADM_JSFunctions.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_script/ADM_JSFunctions.cpp	2008-07-24 11:23:44 UTC (rev 4279)
+++ branches/avidemux_2.4_branch/avidemux/ADM_script/ADM_JSFunctions.cpp	2008-07-24 11:49:40 UTC (rev 4280)
@@ -420,15 +420,7 @@
 	return JS_TRUE;
 }// end systemExecute
 
-#ifdef ADM_WIN32
-
 JSBool systemInclude(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
-{
-		return JS_FALSE;
-}
-#else
-
-JSBool systemInclude(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
 {// begin systemInclude
 	// default return value
 	*rval = BOOLEAN_TO_JSVAL(false);
@@ -442,7 +434,12 @@
 	// make sure we haven't included this already to avoid a recursive
 	// dependency loop
 	char *pTempStr = new char[PATH_MAX+1];
+
+#ifdef __MINGW32__
+	if(_fullpath(pTempStr,pIncludeFile,PATH_MAX) == NULL)
+#else
 	if(realpath(pIncludeFile,pTempStr) == NULL)
+#endif
 	{// begin can't resolve path
 		JS_ReportError(cx, "include() can't resolve the path of \"%s\".", pIncludeFile);
 		return JS_FALSE;
@@ -480,7 +477,6 @@
 	}// end error including
 	return JS_TRUE;
 }// end systemInclude
-#endif
 
 /********************** Extract Path from a filename **************/
 JSBool pathOnly(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)



From gruntster at mail.berlios.de  Thu Jul 24 20:20:40 2008
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Thu, 24 Jul 2008 20:20:40 +0200
Subject: [Avidemux-svn-commit] r4281 - in
	branches/avidemux_2.4_branch/avidemux/ADM_libraries:
	ADM_lavcodec ADM_lavutil
Message-ID: <200807241820.m6OIKeLf005759@sheep.berlios.de>

Author: gruntster
Date: 2008-07-24 20:20:17 +0200 (Thu, 24 Jul 2008)
New Revision: 4281

Added:
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/h264pred.c
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/h264pred.h
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/rectangle.h
Modified:
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/CMakeLists.txt
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/h264.c
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/h264.h
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/h264_parser.h
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/h264data.h
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/svq3.c
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/common.h
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/mem.h
Log:
[h264] update H.264 decoder (libavcodec r14288)

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/CMakeLists.txt
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/CMakeLists.txt	2008-07-24 11:49:40 UTC (rev 4280)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/CMakeLists.txt	2008-07-24 18:20:17 UTC (rev 4281)
@@ -10,7 +10,7 @@
 		jfdctfst.c 	jfdctint.c 	jrevdct.c 	mace.c 	mdct.c 	 	mjpeg.c 
 		motion_est.c 	mpeg12.c 	mpegaudio.c 	mpegaudiodec.c 	mpegvideo.c 	msmpeg4.c 	 
 		pcm.c 	ratecontrol.c 	raw.c 	resample.c 	rv10.c 	simple_idct.c 	svq1.c 
-		utils.c 	wmadec.c 	indeo3.c 	vp3.c 	vp3dsp.c 	h264.c 	ffv1.c 	ra144.c 	ra288.c 
+		utils.c 	wmadec.c 	indeo3.c 	vp3.c 	vp3dsp.c 	h264.c 	h264pred.c  ffv1.c 	ra144.c 	ra288.c 
 		golomb.c 	4xm.c 	cabac.c 	asv1.c vcr1.c cljr.c 	faandct.c 	 	parser.c 
 		roqvideo.c 	xan.c 	rpza.c 	msrle.c 	msvideo1.c 	cinepak.c 	vqavideo.c 
 		idcinvideo.c 	smc.c 	flicvideo.c 	interplayvideo.c 	dpcm.c 	8bps.c vmdav.c 

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/h264.c
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/h264.c	2008-07-24 11:49:40 UTC (rev 4280)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/h264.c	2008-07-24 18:20:17 UTC (rev 4281)
@@ -32,12 +32,23 @@
 #include "h264data.h"
 #include "h264_parser.h"
 #include "golomb.h"
+#include "rectangle.h"
 
 #include "cabac.h"
+#ifdef ARCH_X86
+//#include "i386/h264_i386.h"
+#endif
 
 //#undef NDEBUG
 #include <assert.h>
 
+/**
+ * Value of Picture.reference when Picture is not a reference picture, but
+ * is held for delayed output.
+ */
+#define DELAYED_PIC_REF 4
+#define ENABLE_GRAY 0
+
 static VLC coeff_token_vlc[4];
 static VLC chroma_dc_coeff_token_vlc;
 
@@ -80,110 +91,24 @@
   }
 /* MeanX */
 
-
-/**
- * fill a rectangle.
- * @param h height of the rectangle, should be a constant
- * @param w width of the rectangle, should be a constant
- * @param size the size of val (1 or 4), should be a constant
- */
-static av_always_inline void fill_rectangle(void *vp, int w, int h, int stride, uint32_t val, int size){
-    uint8_t *p= (uint8_t*)vp;
-    assert(size==1 || size==4);
-    assert(w<=4);
-
-    w      *= size;
-    stride *= size;
-
-    assert((((long)vp)&(FFMIN(w, STRIDE_ALIGN)-1)) == 0);
-    assert((stride&(w-1))==0);
-    if(w==2){
-        const uint16_t v= size==4 ? val : val*0x0101;
-        *(uint16_t*)(p + 0*stride)= v;
-        if(h==1) return;
-        *(uint16_t*)(p + 1*stride)= v;
-        if(h==2) return;
-        *(uint16_t*)(p + 2*stride)=
-        *(uint16_t*)(p + 3*stride)= v;
-    }else if(w==4){
-        const uint32_t v= size==4 ? val : val*0x01010101;
-        *(uint32_t*)(p + 0*stride)= v;
-        if(h==1) return;
-        *(uint32_t*)(p + 1*stride)= v;
-        if(h==2) return;
-        *(uint32_t*)(p + 2*stride)=
-        *(uint32_t*)(p + 3*stride)= v;
-    }else if(w==8){
-    //gcc can't optimize 64bit math on x86_32
-#if defined(ARCH_X86_64) || (defined(MP_WORDSIZE) && MP_WORDSIZE >= 64)
-        const uint64_t v= val*0x0100000001ULL;
-        *(uint64_t*)(p + 0*stride)= v;
-        if(h==1) return;
-        *(uint64_t*)(p + 1*stride)= v;
-        if(h==2) return;
-        *(uint64_t*)(p + 2*stride)=
-        *(uint64_t*)(p + 3*stride)= v;
-    }else if(w==16){
-        const uint64_t v= val*0x0100000001ULL;
-        *(uint64_t*)(p + 0+0*stride)=
-        *(uint64_t*)(p + 8+0*stride)=
-        *(uint64_t*)(p + 0+1*stride)=
-        *(uint64_t*)(p + 8+1*stride)= v;
-        if(h==2) return;
-        *(uint64_t*)(p + 0+2*stride)=
-        *(uint64_t*)(p + 8+2*stride)=
-        *(uint64_t*)(p + 0+3*stride)=
-        *(uint64_t*)(p + 8+3*stride)= v;
-#else
-        *(uint32_t*)(p + 0+0*stride)=
-        *(uint32_t*)(p + 4+0*stride)= val;
-        if(h==1) return;
-        *(uint32_t*)(p + 0+1*stride)=
-        *(uint32_t*)(p + 4+1*stride)= val;
-        if(h==2) return;
-        *(uint32_t*)(p + 0+2*stride)=
-        *(uint32_t*)(p + 4+2*stride)=
-        *(uint32_t*)(p + 0+3*stride)=
-        *(uint32_t*)(p + 4+3*stride)= val;
-    }else if(w==16){
-        *(uint32_t*)(p + 0+0*stride)=
-        *(uint32_t*)(p + 4+0*stride)=
-        *(uint32_t*)(p + 8+0*stride)=
-        *(uint32_t*)(p +12+0*stride)=
-        *(uint32_t*)(p + 0+1*stride)=
-        *(uint32_t*)(p + 4+1*stride)=
-        *(uint32_t*)(p + 8+1*stride)=
-        *(uint32_t*)(p +12+1*stride)= val;
-        if(h==2) return;
-        *(uint32_t*)(p + 0+2*stride)=
-        *(uint32_t*)(p + 4+2*stride)=
-        *(uint32_t*)(p + 8+2*stride)=
-        *(uint32_t*)(p +12+2*stride)=
-        *(uint32_t*)(p + 0+3*stride)=
-        *(uint32_t*)(p + 4+3*stride)=
-        *(uint32_t*)(p + 8+3*stride)=
-        *(uint32_t*)(p +12+3*stride)= val;
-#endif
-    }else
-        assert(0);
-    assert(h==4);
-}
-
 static void fill_caches(H264Context *h, int mb_type, int for_deblock){
     MpegEncContext * const s = &h->s;
-    const int mb_xy= s->mb_x + s->mb_y*s->mb_stride;
+    const int mb_xy= h->mb_xy;
     int topleft_xy, top_xy, topright_xy, left_xy[2];
     int topleft_type, top_type, topright_type, left_type[2];
     int left_block[8];
+    int topleft_partition= -1;
     int i;
 
+    top_xy     = mb_xy  - (s->mb_stride << FIELD_PICTURE);
+
     //FIXME deblocking could skip the intra and nnz parts.
-    if(for_deblock && (h->slice_num == 1 || h->slice_table[mb_xy] == h->slice_table[mb_xy-s->mb_stride]) && !FRAME_MBAFF)
+    if(for_deblock && (h->slice_num == 1 || h->slice_table[mb_xy] == h->slice_table[top_xy]) && !FRAME_MBAFF)
         return;
 
-    //wow what a mess, why didn't they simplify the interlacing&intra stuff, i can't imagine that these complex rules are worth it
+    /* Wow, what a mess, why didn't they simplify the interlacing & intra
+     * stuff, I can't imagine that these complex rules are worth it. */
 
-    top_xy     = mb_xy  - s->mb_stride;
     topleft_xy = top_xy - 1;
     topright_xy= top_xy + 1;
     left_xy[1] = left_xy[0] = mb_xy-1;
@@ -218,6 +143,10 @@
                 : (!curr_mb_frame_flag && !topleft_mb_frame_flag) // top macroblock
                 ) {
             topleft_xy -= s->mb_stride;
+        } else if(bottom && curr_mb_frame_flag && !left_mb_frame_flag) {
+            topleft_xy += s->mb_stride;
+            // take topleft mv from the middle of the mb, as opposed to all other modes which use the bottom-right partition
+            topleft_partition = 0;
         }
         if (bottom
                 ? !curr_mb_frame_flag // bottom macroblock
@@ -495,8 +424,8 @@
                 continue;
 
             if(USES_LIST(topleft_type, list)){
-                const int b_xy = h->mb2b_xy[topleft_xy] + 3 + 3*h->b_stride;
-                const int b8_xy= h->mb2b8_xy[topleft_xy] + 1 + h->b8_stride;
+                const int b_xy = h->mb2b_xy[topleft_xy] + 3 + h->b_stride + (topleft_partition & 2*h->b_stride);
+                const int b8_xy= h->mb2b8_xy[topleft_xy] + 1 + (topleft_partition & h->b8_stride);
                 *(uint32_t*)h->mv_cache[list][scan8[0] - 1 - 1*8]= *(uint32_t*)s->current_picture.motion_val[list][b_xy];
                 h->ref_cache[list][scan8[0] - 1 - 1*8]= s->current_picture.ref_index[list][b8_xy];
             }else{
@@ -564,7 +493,7 @@
                 *(uint32_t*)h->mvd_cache [list][scan8[4 ]]=
                 *(uint32_t*)h->mvd_cache [list][scan8[12]]= 0;
 
-                if(h->slice_type == B_TYPE){
+                if(h->slice_type == FF_B_TYPE){
                     fill_rectangle(&h->direct_cache[scan8[0]], 4, 4, 8, 0, 1);
 
                     if(IS_DIRECT(top_type)){
@@ -633,8 +562,7 @@
 }
 
 static inline void write_back_intra_pred_mode(H264Context *h){
-    MpegEncContext * const s = &h->s;
-    const int mb_xy= s->mb_x + s->mb_y*s->mb_stride;
+    const int mb_xy= h->mb_xy;
 
     h->intra4x4_pred_mode[mb_xy][0]= h->intra4x4_pred_mode_cache[7+8*1];
     h->intra4x4_pred_mode[mb_xy][1]= h->intra4x4_pred_mode_cache[7+8*2];
@@ -729,8 +657,7 @@
 }
 
 static inline void write_back_non_zero_count(H264Context *h){
-    MpegEncContext * const s = &h->s;
-    const int mb_xy= s->mb_x + s->mb_y*s->mb_stride;
+    const int mb_xy= h->mb_xy;
 
     h->non_zero_count[mb_xy][0]= h->non_zero_count_cache[7+8*1];
     h->non_zero_count[mb_xy][1]= h->non_zero_count_cache[7+8*2];
@@ -793,7 +720,7 @@
 #define SET_DIAG_MV(MV_OP, REF_OP, X4, Y4)\
                 const int x4 = X4, y4 = Y4;\
                 const int mb_type = mb_types[(x4>>2)+(y4>>2)*s->mb_stride];\
-                if(!USES_LIST(mb_type,list) && !IS_8X8(mb_type))\
+                if(!USES_LIST(mb_type,list))\
                     return LIST_NOT_USED;\
                 mv = s->current_picture_ptr->motion_val[list][x4 + y4*h->b_stride];\
                 h->mv_cache[list][scan8[0]-2][0] = mv[0];\
@@ -814,7 +741,7 @@
                && !IS_INTERLACED(mb_types[h->left_mb_xy[0]])
                && i >= scan8[0]+8){
                 // leftshift will turn LIST_NOT_USED into PART_NOT_AVAILABLE, but that's ok.
-                SET_DIAG_MV(>>1, <<1, s->mb_x*4-1, (s->mb_y&~1)*4 - 1 + ((i-scan8[0])>>3)*2);
+                SET_DIAG_MV(/2, <<1, s->mb_x*4-1, (s->mb_y&~1)*4 - 1 + ((i-scan8[0])>>3)*2);
             }
         }
 #undef SET_DIAG_MV
@@ -1005,16 +932,16 @@
     Picture * const ref1 = &h->ref_list[1][0];
     Picture * const cur = s->current_picture_ptr;
     int list, i, j;
-    if(cur->pict_type == I_TYPE)
+    if(cur->pict_type == FF_I_TYPE)
         cur->ref_count[0] = 0;
-    if(cur->pict_type != B_TYPE)
+    if(cur->pict_type != FF_B_TYPE)
         cur->ref_count[1] = 0;
     for(list=0; list<2; list++){
         cur->ref_count[list] = h->ref_count[list];
         for(j=0; j<h->ref_count[list]; j++)
             cur->ref_poc[list][j] = h->ref_list[list][j].poc;
     }
-    if(cur->pict_type != B_TYPE || h->direct_spatial_mv_pred)
+    if(cur->pict_type != FF_B_TYPE || h->direct_spatial_mv_pred)
         return;
     for(list=0; list<2; list++){
         for(i=0; i<ref1->ref_count[list]; i++){
@@ -1040,7 +967,7 @@
 
 static inline void pred_direct_motion(H264Context * const h, int *mb_type){
     MpegEncContext * const s = &h->s;
-    const int mb_xy =   s->mb_x +   s->mb_y*s->mb_stride;
+    const int mb_xy =   h->mb_xy;
     const int b8_xy = 2*s->mb_x + 2*s->mb_y*h->b8_stride;
     const int b4_xy = 4*s->mb_x + 4*s->mb_y*h->b_stride;
     const int mb_type_col = h->ref_list[1][0].mb_type[mb_xy];
@@ -1109,14 +1036,76 @@
         }
 
         if(ref[1] < 0){
-            *mb_type &= ~MB_TYPE_P0L1;
-            sub_mb_type &= ~MB_TYPE_P0L1;
+            if(!is_b8x8)
+                *mb_type &= ~MB_TYPE_L1;
+            sub_mb_type &= ~MB_TYPE_L1;
         }else if(ref[0] < 0){
-            *mb_type &= ~MB_TYPE_P0L0;
-            sub_mb_type &= ~MB_TYPE_P0L0;
+            if(!is_b8x8)
+                *mb_type &= ~MB_TYPE_L0;
+            sub_mb_type &= ~MB_TYPE_L0;
         }
 
-        if(IS_16X16(*mb_type)){
+        if(IS_INTERLACED(*mb_type) != IS_INTERLACED(mb_type_col)){
+            int pair_xy = s->mb_x + (s->mb_y&~1)*s->mb_stride;
+            int mb_types_col[2];
+            int b8_stride = h->b8_stride;
+            int b4_stride = h->b_stride;
+
+            *mb_type = (*mb_type & ~MB_TYPE_16x16) | MB_TYPE_8x8;
+
+            if(IS_INTERLACED(*mb_type)){
+                mb_types_col[0] = h->ref_list[1][0].mb_type[pair_xy];
+                mb_types_col[1] = h->ref_list[1][0].mb_type[pair_xy+s->mb_stride];
+                if(s->mb_y&1){
+                    l1ref0 -= 2*b8_stride;
+                    l1ref1 -= 2*b8_stride;
+                    l1mv0 -= 4*b4_stride;
+                    l1mv1 -= 4*b4_stride;
+                }
+                b8_stride *= 3;
+                b4_stride *= 6;
+            }else{
+                int cur_poc = s->current_picture_ptr->poc;
+                int *col_poc = h->ref_list[1]->field_poc;
+                int col_parity = FFABS(col_poc[0] - cur_poc) >= FFABS(col_poc[1] - cur_poc);
+                int dy = 2*col_parity - (s->mb_y&1);
+                mb_types_col[0] =
+                mb_types_col[1] = h->ref_list[1][0].mb_type[pair_xy + col_parity*s->mb_stride];
+                l1ref0 += dy*b8_stride;
+                l1ref1 += dy*b8_stride;
+                l1mv0 += 2*dy*b4_stride;
+                l1mv1 += 2*dy*b4_stride;
+                b8_stride = 0;
+            }
+
+            for(i8=0; i8<4; i8++){
+                int x8 = i8&1;
+                int y8 = i8>>1;
+                int xy8 = x8+y8*b8_stride;
+                int xy4 = 3*x8+y8*b4_stride;
+                int a=0, b=0;
+
+                if(is_b8x8 && !IS_DIRECT(h->sub_mb_type[i8]))
+                    continue;
+                h->sub_mb_type[i8] = sub_mb_type;
+
+                fill_rectangle(&h->ref_cache[0][scan8[i8*4]], 2, 2, 8, (uint8_t)ref[0], 1);
+                fill_rectangle(&h->ref_cache[1][scan8[i8*4]], 2, 2, 8, (uint8_t)ref[1], 1);
+                if(!IS_INTRA(mb_types_col[y8])
+                   && (   (l1ref0[xy8] == 0 && FFABS(l1mv0[xy4][0]) <= 1 && FFABS(l1mv0[xy4][1]) <= 1)
+                       || (l1ref0[xy8]  < 0 && l1ref1[xy8] == 0 && FFABS(l1mv1[xy4][0]) <= 1 && FFABS(l1mv1[xy4][1]) <= 1))){
+                    if(ref[0] > 0)
+                        a= pack16to32(mv[0][0],mv[0][1]);
+                    if(ref[1] > 0)
+                        b= pack16to32(mv[1][0],mv[1][1]);
+                }else{
+                    a= pack16to32(mv[0][0],mv[0][1]);
+                    b= pack16to32(mv[1][0],mv[1][1]);
+                }
+                fill_rectangle(&h->mv_cache[0][scan8[i8*4]], 2, 2, 8, a, 4);
+                fill_rectangle(&h->mv_cache[1][scan8[i8*4]], 2, 2, 8, b, 4);
+            }
+        }else if(IS_16X16(*mb_type)){
             int a=0, b=0;
 
             fill_rectangle(&h->ref_cache[0][scan8[0]], 4, 4, 8, (uint8_t)ref[0], 1);
@@ -1383,7 +1372,7 @@
         }
     }
 
-    if(h->slice_type == B_TYPE && h->pps.cabac){
+    if(h->slice_type == FF_B_TYPE && h->pps.cabac){
         if(IS_8X8(mb_type)){
             uint8_t *direct_table = &h->direct_table[b8_xy];
             direct_table[1+0*h->b8_stride] = IS_DIRECT(h->sub_mb_type[1]) ? 1 : 0;
@@ -1400,7 +1389,7 @@
  * @param dst_length is the number of decoded bytes FIXME here or a decode rbsp tailing?
  * @returns decoded bytes, might be src+1 if no escapes
  */
-static uint8_t *decode_nal(H264Context *h, uint8_t *src, int *dst_length, int *consumed, int length){
+static const uint8_t *decode_nal(H264Context *h, const uint8_t *src, int *dst_length, int *consumed, int length){
     int i, si, di;
     uint8_t *dst;
     int bufidx;
@@ -1467,7 +1456,7 @@
  * identifies the exact end of the bitstream
  * @return the length of the trailing, or 0 if damaged
  */
-static int decode_rbsp_trailing(H264Context *h, uint8_t *src){
+static int decode_rbsp_trailing(H264Context *h, const uint8_t *src){
     int v= *src;
     int r;
 
@@ -1614,7 +1603,7 @@
     return h->pps.chroma_qp_table[t][qscale & 0xff];
 }
 
-//FIXME need to check that this does not overflow signed 32 bit for low qp, i am not sure, it's very close
+//FIXME need to check that this does not overflow signed 32 bit for low qp, I am not sure, it's very close
 //FIXME check that gcc inlines this (and optimizes intra & separate_dc stuff away)
 static inline int quantize_c(DCTELEM *block, uint8_t *scantable, int qscale, int intra, int separate_dc){
     int i;
@@ -1693,719 +1682,6 @@
     return last_non_zero;
 }
 
-static void pred4x4_vertical_c(uint8_t *src, uint8_t *topright, int stride){
-    const uint32_t a= ((uint32_t*)(src-stride))[0];
-    ((uint32_t*)(src+0*stride))[0]= a;
-    ((uint32_t*)(src+1*stride))[0]= a;
-    ((uint32_t*)(src+2*stride))[0]= a;
-    ((uint32_t*)(src+3*stride))[0]= a;
-}
-
-static void pred4x4_horizontal_c(uint8_t *src, uint8_t *topright, int stride){
-    ((uint32_t*)(src+0*stride))[0]= src[-1+0*stride]*0x01010101;
-    ((uint32_t*)(src+1*stride))[0]= src[-1+1*stride]*0x01010101;
-    ((uint32_t*)(src+2*stride))[0]= src[-1+2*stride]*0x01010101;
-    ((uint32_t*)(src+3*stride))[0]= src[-1+3*stride]*0x01010101;
-}
-
-static void pred4x4_dc_c(uint8_t *src, uint8_t *topright, int stride){
-    const int dc= (  src[-stride] + src[1-stride] + src[2-stride] + src[3-stride]
-                   + src[-1+0*stride] + src[-1+1*stride] + src[-1+2*stride] + src[-1+3*stride] + 4) >>3;
-
-    ((uint32_t*)(src+0*stride))[0]=
-    ((uint32_t*)(src+1*stride))[0]=
-    ((uint32_t*)(src+2*stride))[0]=
-    ((uint32_t*)(src+3*stride))[0]= dc* 0x01010101;
-}
-
-static void pred4x4_left_dc_c(uint8_t *src, uint8_t *topright, int stride){
-    const int dc= (  src[-1+0*stride] + src[-1+1*stride] + src[-1+2*stride] + src[-1+3*stride] + 2) >>2;
-
-    ((uint32_t*)(src+0*stride))[0]=
-    ((uint32_t*)(src+1*stride))[0]=
-    ((uint32_t*)(src+2*stride))[0]=
-    ((uint32_t*)(src+3*stride))[0]= dc* 0x01010101;
-}
-
-static void pred4x4_top_dc_c(uint8_t *src, uint8_t *topright, int stride){
-    const int dc= (  src[-stride] + src[1-stride] + src[2-stride] + src[3-stride] + 2) >>2;
-
-    ((uint32_t*)(src+0*stride))[0]=
-    ((uint32_t*)(src+1*stride))[0]=
-    ((uint32_t*)(src+2*stride))[0]=
-    ((uint32_t*)(src+3*stride))[0]= dc* 0x01010101;
-}
-
-static void pred4x4_128_dc_c(uint8_t *src, uint8_t *topright, int stride){
-    ((uint32_t*)(src+0*stride))[0]=
-    ((uint32_t*)(src+1*stride))[0]=
-    ((uint32_t*)(src+2*stride))[0]=
-    ((uint32_t*)(src+3*stride))[0]= 128U*0x01010101U;
-}
-
-
-#define LOAD_TOP_RIGHT_EDGE\
-    const int av_unused t4= topright[0];\
-    const int av_unused t5= topright[1];\
-    const int av_unused t6= topright[2];\
-    const int av_unused t7= topright[3];\
-
-#define LOAD_LEFT_EDGE\
-    const int av_unused l0= src[-1+0*stride];\
-    const int av_unused l1= src[-1+1*stride];\
-    const int av_unused l2= src[-1+2*stride];\
-    const int av_unused l3= src[-1+3*stride];\
-
-#define LOAD_TOP_EDGE\
-    const int av_unused t0= src[ 0-1*stride];\
-    const int av_unused t1= src[ 1-1*stride];\
-    const int av_unused t2= src[ 2-1*stride];\
-    const int av_unused t3= src[ 3-1*stride];\
-
-static void pred4x4_down_right_c(uint8_t *src, uint8_t *topright, int stride){
-    const int lt= src[-1-1*stride];
-    LOAD_TOP_EDGE
-    LOAD_LEFT_EDGE
-
-    src[0+3*stride]=(l3 + 2*l2 + l1 + 2)>>2;
-    src[0+2*stride]=
-    src[1+3*stride]=(l2 + 2*l1 + l0 + 2)>>2;
-    src[0+1*stride]=
-    src[1+2*stride]=
-    src[2+3*stride]=(l1 + 2*l0 + lt + 2)>>2;
-    src[0+0*stride]=
-    src[1+1*stride]=
-    src[2+2*stride]=
-    src[3+3*stride]=(l0 + 2*lt + t0 + 2)>>2;
-    src[1+0*stride]=
-    src[2+1*stride]=
-    src[3+2*stride]=(lt + 2*t0 + t1 + 2)>>2;
-    src[2+0*stride]=
-    src[3+1*stride]=(t0 + 2*t1 + t2 + 2)>>2;
-    src[3+0*stride]=(t1 + 2*t2 + t3 + 2)>>2;
-}
-
-static void pred4x4_down_left_c(uint8_t *src, uint8_t *topright, int stride){
-    LOAD_TOP_EDGE
-    LOAD_TOP_RIGHT_EDGE
-//    LOAD_LEFT_EDGE
-
-    src[0+0*stride]=(t0 + t2 + 2*t1 + 2)>>2;
-    src[1+0*stride]=
-    src[0+1*stride]=(t1 + t3 + 2*t2 + 2)>>2;
-    src[2+0*stride]=
-    src[1+1*stride]=
-    src[0+2*stride]=(t2 + t4 + 2*t3 + 2)>>2;
-    src[3+0*stride]=
-    src[2+1*stride]=
-    src[1+2*stride]=
-    src[0+3*stride]=(t3 + t5 + 2*t4 + 2)>>2;
-    src[3+1*stride]=
-    src[2+2*stride]=
-    src[1+3*stride]=(t4 + t6 + 2*t5 + 2)>>2;
-    src[3+2*stride]=
-    src[2+3*stride]=(t5 + t7 + 2*t6 + 2)>>2;
-    src[3+3*stride]=(t6 + 3*t7 + 2)>>2;
-}
-
-static void pred4x4_vertical_right_c(uint8_t *src, uint8_t *topright, int stride){
-    const int lt= src[-1-1*stride];
-    LOAD_TOP_EDGE
-    LOAD_LEFT_EDGE
-
-    src[0+0*stride]=
-    src[1+2*stride]=(lt + t0 + 1)>>1;
-    src[1+0*stride]=
-    src[2+2*stride]=(t0 + t1 + 1)>>1;
-    src[2+0*stride]=
-    src[3+2*stride]=(t1 + t2 + 1)>>1;
-    src[3+0*stride]=(t2 + t3 + 1)>>1;
-    src[0+1*stride]=
-    src[1+3*stride]=(l0 + 2*lt + t0 + 2)>>2;
-    src[1+1*stride]=
-    src[2+3*stride]=(lt + 2*t0 + t1 + 2)>>2;
-    src[2+1*stride]=
-    src[3+3*stride]=(t0 + 2*t1 + t2 + 2)>>2;
-    src[3+1*stride]=(t1 + 2*t2 + t3 + 2)>>2;
-    src[0+2*stride]=(lt + 2*l0 + l1 + 2)>>2;
-    src[0+3*stride]=(l0 + 2*l1 + l2 + 2)>>2;
-}
-
-static void pred4x4_vertical_left_c(uint8_t *src, uint8_t *topright, int stride){
-    LOAD_TOP_EDGE
-    LOAD_TOP_RIGHT_EDGE
-
-    src[0+0*stride]=(t0 + t1 + 1)>>1;
-    src[1+0*stride]=
-    src[0+2*stride]=(t1 + t2 + 1)>>1;
-    src[2+0*stride]=
-    src[1+2*stride]=(t2 + t3 + 1)>>1;
-    src[3+0*stride]=
-    src[2+2*stride]=(t3 + t4+ 1)>>1;
-    src[3+2*stride]=(t4 + t5+ 1)>>1;
-    src[0+1*stride]=(t0 + 2*t1 + t2 + 2)>>2;
-    src[1+1*stride]=
-    src[0+3*stride]=(t1 + 2*t2 + t3 + 2)>>2;
-    src[2+1*stride]=
-    src[1+3*stride]=(t2 + 2*t3 + t4 + 2)>>2;
-    src[3+1*stride]=
-    src[2+3*stride]=(t3 + 2*t4 + t5 + 2)>>2;
-    src[3+3*stride]=(t4 + 2*t5 + t6 + 2)>>2;
-}
-
-static void pred4x4_horizontal_up_c(uint8_t *src, uint8_t *topright, int stride){
-    LOAD_LEFT_EDGE
-
-    src[0+0*stride]=(l0 + l1 + 1)>>1;
-    src[1+0*stride]=(l0 + 2*l1 + l2 + 2)>>2;
-    src[2+0*stride]=
-    src[0+1*stride]=(l1 + l2 + 1)>>1;
-    src[3+0*stride]=
-    src[1+1*stride]=(l1 + 2*l2 + l3 + 2)>>2;
-    src[2+1*stride]=
-    src[0+2*stride]=(l2 + l3 + 1)>>1;
-    src[3+1*stride]=
-    src[1+2*stride]=(l2 + 2*l3 + l3 + 2)>>2;
-    src[3+2*stride]=
-    src[1+3*stride]=
-    src[0+3*stride]=
-    src[2+2*stride]=
-    src[2+3*stride]=
-    src[3+3*stride]=l3;
-}
-
-static void pred4x4_horizontal_down_c(uint8_t *src, uint8_t *topright, int stride){
-    const int lt= src[-1-1*stride];
-    LOAD_TOP_EDGE
-    LOAD_LEFT_EDGE
-
-    src[0+0*stride]=
-    src[2+1*stride]=(lt + l0 + 1)>>1;
-    src[1+0*stride]=
-    src[3+1*stride]=(l0 + 2*lt + t0 + 2)>>2;
-    src[2+0*stride]=(lt + 2*t0 + t1 + 2)>>2;
-    src[3+0*stride]=(t0 + 2*t1 + t2 + 2)>>2;
-    src[0+1*stride]=
-    src[2+2*stride]=(l0 + l1 + 1)>>1;
-    src[1+1*stride]=
-    src[3+2*stride]=(lt + 2*l0 + l1 + 2)>>2;
-    src[0+2*stride]=
-    src[2+3*stride]=(l1 + l2+ 1)>>1;
-    src[1+2*stride]=
-    src[3+3*stride]=(l0 + 2*l1 + l2 + 2)>>2;
-    src[0+3*stride]=(l2 + l3 + 1)>>1;
-    src[1+3*stride]=(l1 + 2*l2 + l3 + 2)>>2;
-}
-
-void ff_pred16x16_vertical_c(uint8_t *src, int stride){
-    int i;
-    const uint32_t a= ((uint32_t*)(src-stride))[0];
-    const uint32_t b= ((uint32_t*)(src-stride))[1];
-    const uint32_t c= ((uint32_t*)(src-stride))[2];
-    const uint32_t d= ((uint32_t*)(src-stride))[3];
-
-    for(i=0; i<16; i++){
-        ((uint32_t*)(src+i*stride))[0]= a;
-        ((uint32_t*)(src+i*stride))[1]= b;
-        ((uint32_t*)(src+i*stride))[2]= c;
-        ((uint32_t*)(src+i*stride))[3]= d;
-    }
-}
-
-void ff_pred16x16_horizontal_c(uint8_t *src, int stride){
-    int i;
-
-    for(i=0; i<16; i++){
-        ((uint32_t*)(src+i*stride))[0]=
-        ((uint32_t*)(src+i*stride))[1]=
-        ((uint32_t*)(src+i*stride))[2]=
-        ((uint32_t*)(src+i*stride))[3]= src[-1+i*stride]*0x01010101;
-    }
-}
-
-void ff_pred16x16_dc_c(uint8_t *src, int stride){
-    int i, dc=0;
-
-    for(i=0;i<16; i++){
-        dc+= src[-1+i*stride];
-    }
-
-    for(i=0;i<16; i++){
-        dc+= src[i-stride];
-    }
-
-    dc= 0x01010101*((dc + 16)>>5);
-
-    for(i=0; i<16; i++){
-        ((uint32_t*)(src+i*stride))[0]=
-        ((uint32_t*)(src+i*stride))[1]=
-        ((uint32_t*)(src+i*stride))[2]=
-        ((uint32_t*)(src+i*stride))[3]= dc;
-    }
-}
-
-void ff_pred16x16_left_dc_c(uint8_t *src, int stride){
-    int i, dc=0;
-
-    for(i=0;i<16; i++){
-        dc+= src[-1+i*stride];
-    }
-
-    dc= 0x01010101*((dc + 8)>>4);
-
-    for(i=0; i<16; i++){
-        ((uint32_t*)(src+i*stride))[0]=
-        ((uint32_t*)(src+i*stride))[1]=
-        ((uint32_t*)(src+i*stride))[2]=
-        ((uint32_t*)(src+i*stride))[3]= dc;
-    }
-}
-
-void ff_pred16x16_top_dc_c(uint8_t *src, int stride){
-    int i, dc=0;
-
-    for(i=0;i<16; i++){
-        dc+= src[i-stride];
-    }
-    dc= 0x01010101*((dc + 8)>>4);
-
-    for(i=0; i<16; i++){
-        ((uint32_t*)(src+i*stride))[0]=
-        ((uint32_t*)(src+i*stride))[1]=
-        ((uint32_t*)(src+i*stride))[2]=
-        ((uint32_t*)(src+i*stride))[3]= dc;
-    }
-}
-
-void ff_pred16x16_128_dc_c(uint8_t *src, int stride){
-    int i;
-
-    for(i=0; i<16; i++){
-        ((uint32_t*)(src+i*stride))[0]=
-        ((uint32_t*)(src+i*stride))[1]=
-        ((uint32_t*)(src+i*stride))[2]=
-        ((uint32_t*)(src+i*stride))[3]= 0x01010101U*128U;
-    }
-}
-
-static inline void pred16x16_plane_compat_c(uint8_t *src, int stride, const int svq3){
-  int i, j, k;
-  int a;
-  uint8_t *cm = ff_cropTbl + MAX_NEG_CROP;
-  const uint8_t * const src0 = src+7-stride;
-  const uint8_t *src1 = src+8*stride-1;
-  const uint8_t *src2 = src1-2*stride;      // == src+6*stride-1;
-  int H = src0[1] - src0[-1];
-  int V = src1[0] - src2[ 0];
-  for(k=2; k<=8; ++k) {
-    src1 += stride; src2 -= stride;
-    H += k*(src0[k] - src0[-k]);
-    V += k*(src1[0] - src2[ 0]);
-  }
-  if(svq3){
-    H = ( 5*(H/4) ) / 16;
-    V = ( 5*(V/4) ) / 16;
-
-    /* required for 100% accuracy */
-    i = H; H = V; V = i;
-  }else{
-    H = ( 5*H+32 ) >> 6;
-    V = ( 5*V+32 ) >> 6;
-  }
-
-  a = 16*(src1[0] + src2[16] + 1) - 7*(V+H);
-  for(j=16; j>0; --j) {
-    int b = a;
-    a += V;
-    for(i=-16; i<0; i+=4) {
-      src[16+i] = cm[ (b    ) >> 5 ];
-      src[17+i] = cm[ (b+  H) >> 5 ];
-      src[18+i] = cm[ (b+2*H) >> 5 ];
-      src[19+i] = cm[ (b+3*H) >> 5 ];
-      b += 4*H;
-    }
-    src += stride;
-  }
-}
-
-void ff_pred16x16_plane_c(uint8_t *src, int stride){
-    pred16x16_plane_compat_c(src, stride, 0);
-}
-
-void ff_pred8x8_vertical_c(uint8_t *src, int stride){
-    int i;
-    const uint32_t a= ((uint32_t*)(src-stride))[0];
-    const uint32_t b= ((uint32_t*)(src-stride))[1];
-
-    for(i=0; i<8; i++){
-        ((uint32_t*)(src+i*stride))[0]= a;
-        ((uint32_t*)(src+i*stride))[1]= b;
-    }
-}
-
-void ff_pred8x8_horizontal_c(uint8_t *src, int stride){
-    int i;
-
-    for(i=0; i<8; i++){
-        ((uint32_t*)(src+i*stride))[0]=
-        ((uint32_t*)(src+i*stride))[1]= src[-1+i*stride]*0x01010101;
-    }
-}
-
-void ff_pred8x8_128_dc_c(uint8_t *src, int stride){
-    int i;
-
-    for(i=0; i<8; i++){
-        ((uint32_t*)(src+i*stride))[0]=
-        ((uint32_t*)(src+i*stride))[1]= 0x01010101U*128U;
-    }
-}
-
-void ff_pred8x8_left_dc_c(uint8_t *src, int stride){
-    int i;
-    int dc0, dc2;
-
-    dc0=dc2=0;
-    for(i=0;i<4; i++){
-        dc0+= src[-1+i*stride];
-        dc2+= src[-1+(i+4)*stride];
-    }
-    dc0= 0x01010101*((dc0 + 2)>>2);
-    dc2= 0x01010101*((dc2 + 2)>>2);
-
-    for(i=0; i<4; i++){
-        ((uint32_t*)(src+i*stride))[0]=
-        ((uint32_t*)(src+i*stride))[1]= dc0;
-    }
-    for(i=4; i<8; i++){
-        ((uint32_t*)(src+i*stride))[0]=
-        ((uint32_t*)(src+i*stride))[1]= dc2;
-    }
-}
-
-void ff_pred8x8_top_dc_c(uint8_t *src, int stride){
-    int i;
-    int dc0, dc1;
-
-    dc0=dc1=0;
-    for(i=0;i<4; i++){
-        dc0+= src[i-stride];
-        dc1+= src[4+i-stride];
-    }
-    dc0= 0x01010101*((dc0 + 2)>>2);
-    dc1= 0x01010101*((dc1 + 2)>>2);
-
-    for(i=0; i<4; i++){
-        ((uint32_t*)(src+i*stride))[0]= dc0;
-        ((uint32_t*)(src+i*stride))[1]= dc1;
-    }
-    for(i=4; i<8; i++){
-        ((uint32_t*)(src+i*stride))[0]= dc0;
-        ((uint32_t*)(src+i*stride))[1]= dc1;
-    }
-}
-
-
-void ff_pred8x8_dc_c(uint8_t *src, int stride){
-    int i;
-    int dc0, dc1, dc2, dc3;
-
-    dc0=dc1=dc2=0;
-    for(i=0;i<4; i++){
-        dc0+= src[-1+i*stride] + src[i-stride];
-        dc1+= src[4+i-stride];
-        dc2+= src[-1+(i+4)*stride];
-    }
-    dc3= 0x01010101*((dc1 + dc2 + 4)>>3);
-    dc0= 0x01010101*((dc0 + 4)>>3);
-    dc1= 0x01010101*((dc1 + 2)>>2);
-    dc2= 0x01010101*((dc2 + 2)>>2);
-
-    for(i=0; i<4; i++){
-        ((uint32_t*)(src+i*stride))[0]= dc0;
-        ((uint32_t*)(src+i*stride))[1]= dc1;
-    }
-    for(i=4; i<8; i++){
-        ((uint32_t*)(src+i*stride))[0]= dc2;
-        ((uint32_t*)(src+i*stride))[1]= dc3;
-    }
-}
-
-void ff_pred8x8_plane_c(uint8_t *src, int stride){
-  int j, k;
-  int a;
-  uint8_t *cm = ff_cropTbl + MAX_NEG_CROP;
-  const uint8_t * const src0 = src+3-stride;
-  const uint8_t *src1 = src+4*stride-1;
-  const uint8_t *src2 = src1-2*stride;      // == src+2*stride-1;
-  int H = src0[1] - src0[-1];
-  int V = src1[0] - src2[ 0];
-  for(k=2; k<=4; ++k) {
-    src1 += stride; src2 -= stride;
-    H += k*(src0[k] - src0[-k]);
-    V += k*(src1[0] - src2[ 0]);
-  }
-  H = ( 17*H+16 ) >> 5;
-  V = ( 17*V+16 ) >> 5;
-
-  a = 16*(src1[0] + src2[8]+1) - 3*(V+H);
-  for(j=8; j>0; --j) {
-    int b = a;
-    a += V;
-    src[0] = cm[ (b    ) >> 5 ];
-    src[1] = cm[ (b+  H) >> 5 ];
-    src[2] = cm[ (b+2*H) >> 5 ];
-    src[3] = cm[ (b+3*H) >> 5 ];
-    src[4] = cm[ (b+4*H) >> 5 ];
-    src[5] = cm[ (b+5*H) >> 5 ];
-    src[6] = cm[ (b+6*H) >> 5 ];
-    src[7] = cm[ (b+7*H) >> 5 ];
-    src += stride;
-  }
-}
-
-#define SRC(x,y) src[(x)+(y)*stride]
-#define PL(y) \
-    const int l##y = (SRC(-1,y-1) + 2*SRC(-1,y) + SRC(-1,y+1) + 2) >> 2;
-#define PREDICT_8x8_LOAD_LEFT \
-    const int l0 = ((has_topleft ? SRC(-1,-1) : SRC(-1,0)) \
-                     + 2*SRC(-1,0) + SRC(-1,1) + 2) >> 2; \
-    PL(1) PL(2) PL(3) PL(4) PL(5) PL(6) \
-    const int l7 av_unused = (SRC(-1,6) + 3*SRC(-1,7) + 2) >> 2
-
-#define PT(x) \
-    const int t##x = (SRC(x-1,-1) + 2*SRC(x,-1) + SRC(x+1,-1) + 2) >> 2;
-#define PREDICT_8x8_LOAD_TOP \
-    const int t0 = ((has_topleft ? SRC(-1,-1) : SRC(0,-1)) \
-                     + 2*SRC(0,-1) + SRC(1,-1) + 2) >> 2; \
-    PT(1) PT(2) PT(3) PT(4) PT(5) PT(6) \
-    const int t7 av_unused = ((has_topright ? SRC(8,-1) : SRC(7,-1)) \
-                     + 2*SRC(7,-1) + SRC(6,-1) + 2) >> 2
-
-#define PTR(x) \
-    t##x = (SRC(x-1,-1) + 2*SRC(x,-1) + SRC(x+1,-1) + 2) >> 2;
-#define PREDICT_8x8_LOAD_TOPRIGHT \
-    int t8, t9, t10, t11, t12, t13, t14, t15; \
-    if(has_topright) { \
-        PTR(8) PTR(9) PTR(10) PTR(11) PTR(12) PTR(13) PTR(14) \
-        t15 = (SRC(14,-1) + 3*SRC(15,-1) + 2) >> 2; \
-    } else t8=t9=t10=t11=t12=t13=t14=t15= SRC(7,-1);
-
-#define PREDICT_8x8_LOAD_TOPLEFT \
-    const int lt = (SRC(-1,0) + 2*SRC(-1,-1) + SRC(0,-1) + 2) >> 2
-
-#define PREDICT_8x8_DC(v) \
-    int y; \
-    for( y = 0; y < 8; y++ ) { \
-        ((uint32_t*)src)[0] = \
-        ((uint32_t*)src)[1] = v; \
-        src += stride; \
-    }
-
-static void pred8x8l_128_dc_c(uint8_t *src, int has_topleft, int has_topright, int stride)
-{
-    PREDICT_8x8_DC(0x80808080);
-}
-static void pred8x8l_left_dc_c(uint8_t *src, int has_topleft, int has_topright, int stride)
-{
-    PREDICT_8x8_LOAD_LEFT;
-    const uint32_t dc = ((l0+l1+l2+l3+l4+l5+l6+l7+4) >> 3) * 0x01010101;
-    PREDICT_8x8_DC(dc);
-}
-static void pred8x8l_top_dc_c(uint8_t *src, int has_topleft, int has_topright, int stride)
-{
-    PREDICT_8x8_LOAD_TOP;
-    const uint32_t dc = ((t0+t1+t2+t3+t4+t5+t6+t7+4) >> 3) * 0x01010101;
-    PREDICT_8x8_DC(dc);
-}
-static void pred8x8l_dc_c(uint8_t *src, int has_topleft, int has_topright, int stride)
-{
-    PREDICT_8x8_LOAD_LEFT;
-    PREDICT_8x8_LOAD_TOP;
-    const uint32_t dc = ((l0+l1+l2+l3+l4+l5+l6+l7
-                         +t0+t1+t2+t3+t4+t5+t6+t7+8) >> 4) * 0x01010101;
-    PREDICT_8x8_DC(dc);
-}
-static void pred8x8l_horizontal_c(uint8_t *src, int has_topleft, int has_topright, int stride)
-{
-    PREDICT_8x8_LOAD_LEFT;
-#define ROW(y) ((uint32_t*)(src+y*stride))[0] =\
-               ((uint32_t*)(src+y*stride))[1] = 0x01010101 * l##y
-    ROW(0); ROW(1); ROW(2); ROW(3); ROW(4); ROW(5); ROW(6); ROW(7);
-#undef ROW
-}
-static void pred8x8l_vertical_c(uint8_t *src, int has_topleft, int has_topright, int stride)
-{
-    int y;
-    PREDICT_8x8_LOAD_TOP;
-    src[0] = t0;
-    src[1] = t1;
-    src[2] = t2;
-    src[3] = t3;
-    src[4] = t4;
-    src[5] = t5;
-    src[6] = t6;
-    src[7] = t7;
-    for( y = 1; y < 8; y++ )
-        *(uint64_t*)(src+y*stride) = *(uint64_t*)src;
-}
-static void pred8x8l_down_left_c(uint8_t *src, int has_topleft, int has_topright, int stride)
-{
-    PREDICT_8x8_LOAD_TOP;
-    PREDICT_8x8_LOAD_TOPRIGHT;
-    SRC(0,0)= (t0 + 2*t1 + t2 + 2) >> 2;
-    SRC(0,1)=SRC(1,0)= (t1 + 2*t2 + t3 + 2) >> 2;
-    SRC(0,2)=SRC(1,1)=SRC(2,0)= (t2 + 2*t3 + t4 + 2) >> 2;
-    SRC(0,3)=SRC(1,2)=SRC(2,1)=SRC(3,0)= (t3 + 2*t4 + t5 + 2) >> 2;
-    SRC(0,4)=SRC(1,3)=SRC(2,2)=SRC(3,1)=SRC(4,0)= (t4 + 2*t5 + t6 + 2) >> 2;
-    SRC(0,5)=SRC(1,4)=SRC(2,3)=SRC(3,2)=SRC(4,1)=SRC(5,0)= (t5 + 2*t6 + t7 + 2) >> 2;
-    SRC(0,6)=SRC(1,5)=SRC(2,4)=SRC(3,3)=SRC(4,2)=SRC(5,1)=SRC(6,0)= (t6 + 2*t7 + t8 + 2) >> 2;
-    SRC(0,7)=SRC(1,6)=SRC(2,5)=SRC(3,4)=SRC(4,3)=SRC(5,2)=SRC(6,1)=SRC(7,0)= (t7 + 2*t8 + t9 + 2) >> 2;
-    SRC(1,7)=SRC(2,6)=SRC(3,5)=SRC(4,4)=SRC(5,3)=SRC(6,2)=SRC(7,1)= (t8 + 2*t9 + t10 + 2) >> 2;
-    SRC(2,7)=SRC(3,6)=SRC(4,5)=SRC(5,4)=SRC(6,3)=SRC(7,2)= (t9 + 2*t10 + t11 + 2) >> 2;
-    SRC(3,7)=SRC(4,6)=SRC(5,5)=SRC(6,4)=SRC(7,3)= (t10 + 2*t11 + t12 + 2) >> 2;
-    SRC(4,7)=SRC(5,6)=SRC(6,5)=SRC(7,4)= (t11 + 2*t12 + t13 + 2) >> 2;
-    SRC(5,7)=SRC(6,6)=SRC(7,5)= (t12 + 2*t13 + t14 + 2) >> 2;
-    SRC(6,7)=SRC(7,6)= (t13 + 2*t14 + t15 + 2) >> 2;
-    SRC(7,7)= (t14 + 3*t15 + 2) >> 2;
-}
-static void pred8x8l_down_right_c(uint8_t *src, int has_topleft, int has_topright, int stride)
-{
-    PREDICT_8x8_LOAD_TOP;
-    PREDICT_8x8_LOAD_LEFT;
-    PREDICT_8x8_LOAD_TOPLEFT;
-    SRC(0,7)= (l7 + 2*l6 + l5 + 2) >> 2;
-    SRC(0,6)=SRC(1,7)= (l6 + 2*l5 + l4 + 2) >> 2;
-    SRC(0,5)=SRC(1,6)=SRC(2,7)= (l5 + 2*l4 + l3 + 2) >> 2;
-    SRC(0,4)=SRC(1,5)=SRC(2,6)=SRC(3,7)= (l4 + 2*l3 + l2 + 2) >> 2;
-    SRC(0,3)=SRC(1,4)=SRC(2,5)=SRC(3,6)=SRC(4,7)= (l3 + 2*l2 + l1 + 2) >> 2;
-    SRC(0,2)=SRC(1,3)=SRC(2,4)=SRC(3,5)=SRC(4,6)=SRC(5,7)= (l2 + 2*l1 + l0 + 2) >> 2;
-    SRC(0,1)=SRC(1,2)=SRC(2,3)=SRC(3,4)=SRC(4,5)=SRC(5,6)=SRC(6,7)= (l1 + 2*l0 + lt + 2) >> 2;
-    SRC(0,0)=SRC(1,1)=SRC(2,2)=SRC(3,3)=SRC(4,4)=SRC(5,5)=SRC(6,6)=SRC(7,7)= (l0 + 2*lt + t0 + 2) >> 2;
-    SRC(1,0)=SRC(2,1)=SRC(3,2)=SRC(4,3)=SRC(5,4)=SRC(6,5)=SRC(7,6)= (lt + 2*t0 + t1 + 2) >> 2;
-    SRC(2,0)=SRC(3,1)=SRC(4,2)=SRC(5,3)=SRC(6,4)=SRC(7,5)= (t0 + 2*t1 + t2 + 2) >> 2;
-    SRC(3,0)=SRC(4,1)=SRC(5,2)=SRC(6,3)=SRC(7,4)= (t1 + 2*t2 + t3 + 2) >> 2;
-    SRC(4,0)=SRC(5,1)=SRC(6,2)=SRC(7,3)= (t2 + 2*t3 + t4 + 2) >> 2;
-    SRC(5,0)=SRC(6,1)=SRC(7,2)= (t3 + 2*t4 + t5 + 2) >> 2;
-    SRC(6,0)=SRC(7,1)= (t4 + 2*t5 + t6 + 2) >> 2;
-    SRC(7,0)= (t5 + 2*t6 + t7 + 2) >> 2;
-
-}
-static void pred8x8l_vertical_right_c(uint8_t *src, int has_topleft, int has_topright, int stride)
-{
-    PREDICT_8x8_LOAD_TOP;
-    PREDICT_8x8_LOAD_LEFT;
-    PREDICT_8x8_LOAD_TOPLEFT;
-    SRC(0,6)= (l5 + 2*l4 + l3 + 2) >> 2;
-    SRC(0,7)= (l6 + 2*l5 + l4 + 2) >> 2;
-    SRC(0,4)=SRC(1,6)= (l3 + 2*l2 + l1 + 2) >> 2;
-    SRC(0,5)=SRC(1,7)= (l4 + 2*l3 + l2 + 2) >> 2;
-    SRC(0,2)=SRC(1,4)=SRC(2,6)= (l1 + 2*l0 + lt + 2) >> 2;
-    SRC(0,3)=SRC(1,5)=SRC(2,7)= (l2 + 2*l1 + l0 + 2) >> 2;
-    SRC(0,1)=SRC(1,3)=SRC(2,5)=SRC(3,7)= (l0 + 2*lt + t0 + 2) >> 2;
-    SRC(0,0)=SRC(1,2)=SRC(2,4)=SRC(3,6)= (lt + t0 + 1) >> 1;
-    SRC(1,1)=SRC(2,3)=SRC(3,5)=SRC(4,7)= (lt + 2*t0 + t1 + 2) >> 2;
-    SRC(1,0)=SRC(2,2)=SRC(3,4)=SRC(4,6)= (t0 + t1 + 1) >> 1;
-    SRC(2,1)=SRC(3,3)=SRC(4,5)=SRC(5,7)= (t0 + 2*t1 + t2 + 2) >> 2;
-    SRC(2,0)=SRC(3,2)=SRC(4,4)=SRC(5,6)= (t1 + t2 + 1) >> 1;
-    SRC(3,1)=SRC(4,3)=SRC(5,5)=SRC(6,7)= (t1 + 2*t2 + t3 + 2) >> 2;
-    SRC(3,0)=SRC(4,2)=SRC(5,4)=SRC(6,6)= (t2 + t3 + 1) >> 1;
-    SRC(4,1)=SRC(5,3)=SRC(6,5)=SRC(7,7)= (t2 + 2*t3 + t4 + 2) >> 2;
-    SRC(4,0)=SRC(5,2)=SRC(6,4)=SRC(7,6)= (t3 + t4 + 1) >> 1;
-    SRC(5,1)=SRC(6,3)=SRC(7,5)= (t3 + 2*t4 + t5 + 2) >> 2;
-    SRC(5,0)=SRC(6,2)=SRC(7,4)= (t4 + t5 + 1) >> 1;
-    SRC(6,1)=SRC(7,3)= (t4 + 2*t5 + t6 + 2) >> 2;
-    SRC(6,0)=SRC(7,2)= (t5 + t6 + 1) >> 1;
-    SRC(7,1)= (t5 + 2*t6 + t7 + 2) >> 2;
-    SRC(7,0)= (t6 + t7 + 1) >> 1;
-}
-static void pred8x8l_horizontal_down_c(uint8_t *src, int has_topleft, int has_topright, int stride)
-{
-    PREDICT_8x8_LOAD_TOP;
-    PREDICT_8x8_LOAD_LEFT;
-    PREDICT_8x8_LOAD_TOPLEFT;
-    SRC(0,7)= (l6 + l7 + 1) >> 1;
-    SRC(1,7)= (l5 + 2*l6 + l7 + 2) >> 2;
-    SRC(0,6)=SRC(2,7)= (l5 + l6 + 1) >> 1;
-    SRC(1,6)=SRC(3,7)= (l4 + 2*l5 + l6 + 2) >> 2;
-    SRC(0,5)=SRC(2,6)=SRC(4,7)= (l4 + l5 + 1) >> 1;
-    SRC(1,5)=SRC(3,6)=SRC(5,7)= (l3 + 2*l4 + l5 + 2) >> 2;
-    SRC(0,4)=SRC(2,5)=SRC(4,6)=SRC(6,7)= (l3 + l4 + 1) >> 1;
-    SRC(1,4)=SRC(3,5)=SRC(5,6)=SRC(7,7)= (l2 + 2*l3 + l4 + 2) >> 2;
-    SRC(0,3)=SRC(2,4)=SRC(4,5)=SRC(6,6)= (l2 + l3 + 1) >> 1;
-    SRC(1,3)=SRC(3,4)=SRC(5,5)=SRC(7,6)= (l1 + 2*l2 + l3 + 2) >> 2;
-    SRC(0,2)=SRC(2,3)=SRC(4,4)=SRC(6,5)= (l1 + l2 + 1) >> 1;
-    SRC(1,2)=SRC(3,3)=SRC(5,4)=SRC(7,5)= (l0 + 2*l1 + l2 + 2) >> 2;
-    SRC(0,1)=SRC(2,2)=SRC(4,3)=SRC(6,4)= (l0 + l1 + 1) >> 1;
-    SRC(1,1)=SRC(3,2)=SRC(5,3)=SRC(7,4)= (lt + 2*l0 + l1 + 2) >> 2;
-    SRC(0,0)=SRC(2,1)=SRC(4,2)=SRC(6,3)= (lt + l0 + 1) >> 1;
-    SRC(1,0)=SRC(3,1)=SRC(5,2)=SRC(7,3)= (l0 + 2*lt + t0 + 2) >> 2;
-    SRC(2,0)=SRC(4,1)=SRC(6,2)= (t1 + 2*t0 + lt + 2) >> 2;
-    SRC(3,0)=SRC(5,1)=SRC(7,2)= (t2 + 2*t1 + t0 + 2) >> 2;
-    SRC(4,0)=SRC(6,1)= (t3 + 2*t2 + t1 + 2) >> 2;
-    SRC(5,0)=SRC(7,1)= (t4 + 2*t3 + t2 + 2) >> 2;
-    SRC(6,0)= (t5 + 2*t4 + t3 + 2) >> 2;
-    SRC(7,0)= (t6 + 2*t5 + t4 + 2) >> 2;
-}
-static void pred8x8l_vertical_left_c(uint8_t *src, int has_topleft, int has_topright, int stride)
-{
-    PREDICT_8x8_LOAD_TOP;
-    PREDICT_8x8_LOAD_TOPRIGHT;
-    SRC(0,0)= (t0 + t1 + 1) >> 1;
-    SRC(0,1)= (t0 + 2*t1 + t2 + 2) >> 2;
-    SRC(0,2)=SRC(1,0)= (t1 + t2 + 1) >> 1;
-    SRC(0,3)=SRC(1,1)= (t1 + 2*t2 + t3 + 2) >> 2;
-    SRC(0,4)=SRC(1,2)=SRC(2,0)= (t2 + t3 + 1) >> 1;
-    SRC(0,5)=SRC(1,3)=SRC(2,1)= (t2 + 2*t3 + t4 + 2) >> 2;
-    SRC(0,6)=SRC(1,4)=SRC(2,2)=SRC(3,0)= (t3 + t4 + 1) >> 1;
-    SRC(0,7)=SRC(1,5)=SRC(2,3)=SRC(3,1)= (t3 + 2*t4 + t5 + 2) >> 2;
-    SRC(1,6)=SRC(2,4)=SRC(3,2)=SRC(4,0)= (t4 + t5 + 1) >> 1;
-    SRC(1,7)=SRC(2,5)=SRC(3,3)=SRC(4,1)= (t4 + 2*t5 + t6 + 2) >> 2;
-    SRC(2,6)=SRC(3,4)=SRC(4,2)=SRC(5,0)= (t5 + t6 + 1) >> 1;
-    SRC(2,7)=SRC(3,5)=SRC(4,3)=SRC(5,1)= (t5 + 2*t6 + t7 + 2) >> 2;
-    SRC(3,6)=SRC(4,4)=SRC(5,2)=SRC(6,0)= (t6 + t7 + 1) >> 1;
-    SRC(3,7)=SRC(4,5)=SRC(5,3)=SRC(6,1)= (t6 + 2*t7 + t8 + 2) >> 2;
-    SRC(4,6)=SRC(5,4)=SRC(6,2)=SRC(7,0)= (t7 + t8 + 1) >> 1;
-    SRC(4,7)=SRC(5,5)=SRC(6,3)=SRC(7,1)= (t7 + 2*t8 + t9 + 2) >> 2;
-    SRC(5,6)=SRC(6,4)=SRC(7,2)= (t8 + t9 + 1) >> 1;
-    SRC(5,7)=SRC(6,5)=SRC(7,3)= (t8 + 2*t9 + t10 + 2) >> 2;
-    SRC(6,6)=SRC(7,4)= (t9 + t10 + 1) >> 1;
-    SRC(6,7)=SRC(7,5)= (t9 + 2*t10 + t11 + 2) >> 2;
-    SRC(7,6)= (t10 + t11 + 1) >> 1;
-    SRC(7,7)= (t10 + 2*t11 + t12 + 2) >> 2;
-}
-static void pred8x8l_horizontal_up_c(uint8_t *src, int has_topleft, int has_topright, int stride)
-{
-    PREDICT_8x8_LOAD_LEFT;
-    SRC(0,0)= (l0 + l1 + 1) >> 1;
-    SRC(1,0)= (l0 + 2*l1 + l2 + 2) >> 2;
-    SRC(0,1)=SRC(2,0)= (l1 + l2 + 1) >> 1;
-    SRC(1,1)=SRC(3,0)= (l1 + 2*l2 + l3 + 2) >> 2;
-    SRC(0,2)=SRC(2,1)=SRC(4,0)= (l2 + l3 + 1) >> 1;
-    SRC(1,2)=SRC(3,1)=SRC(5,0)= (l2 + 2*l3 + l4 + 2) >> 2;
-    SRC(0,3)=SRC(2,2)=SRC(4,1)=SRC(6,0)= (l3 + l4 + 1) >> 1;
-    SRC(1,3)=SRC(3,2)=SRC(5,1)=SRC(7,0)= (l3 + 2*l4 + l5 + 2) >> 2;
-    SRC(0,4)=SRC(2,3)=SRC(4,2)=SRC(6,1)= (l4 + l5 + 1) >> 1;
-    SRC(1,4)=SRC(3,3)=SRC(5,2)=SRC(7,1)= (l4 + 2*l5 + l6 + 2) >> 2;
-    SRC(0,5)=SRC(2,4)=SRC(4,3)=SRC(6,2)= (l5 + l6 + 1) >> 1;
-    SRC(1,5)=SRC(3,4)=SRC(5,3)=SRC(7,2)= (l5 + 2*l6 + l7 + 2) >> 2;
-    SRC(0,6)=SRC(2,5)=SRC(4,4)=SRC(6,3)= (l6 + l7 + 1) >> 1;
-    SRC(1,6)=SRC(3,5)=SRC(5,4)=SRC(7,3)= (l6 + 3*l7 + 2) >> 2;
-    SRC(0,7)=SRC(1,7)=SRC(2,6)=SRC(2,7)=SRC(3,6)=
-    SRC(3,7)=SRC(4,5)=SRC(4,6)=SRC(4,7)=SRC(5,5)=
-    SRC(5,6)=SRC(5,7)=SRC(6,4)=SRC(6,5)=SRC(6,6)=
-    SRC(6,7)=SRC(7,4)=SRC(7,5)=SRC(7,6)=SRC(7,7)= l7;
-}
-#undef PREDICT_8x8_LOAD_LEFT
-#undef PREDICT_8x8_LOAD_TOP
-#undef PREDICT_8x8_LOAD_TOPLEFT
-#undef PREDICT_8x8_LOAD_TOPRIGHT
-#undef PREDICT_8x8_DC
-#undef PTR
-#undef PT
-#undef PL
-#undef SRC
-
 static inline void mc_dir_part(H264Context *h, Picture *pic, int n, int square, int chroma_height, int delta, int list,
                            uint8_t *dest_y, uint8_t *dest_cb, uint8_t *dest_cr,
                            int src_x_offset, int src_y_offset,
@@ -2422,7 +1698,7 @@
     const int full_mx= mx>>2;
     const int full_my= my>>2;
     const int pic_width  = 16*s->mb_width;
-    const int pic_height = 16*s->mb_height >> MB_MBAFF;
+    const int pic_height = 16*s->mb_height >> MB_FIELD;
 
     if(!pic->data[0]) //FIXME this is unacceptable, some senseable error concealment must be done for missing reference frames
         return;
@@ -2444,11 +1720,11 @@
         qpix_op[luma_xy](dest_y + delta, src_y + delta, h->mb_linesize);
     }
 
-    if(s->flags&CODEC_FLAG_GRAY) return;
+    if(ENABLE_GRAY && s->flags&CODEC_FLAG_GRAY) return;
 
-    if(MB_MBAFF){
+    if(MB_FIELD){
         // chroma offset when predicting from a field of opposite parity
-        my += 2 * ((s->mb_y & 1) - (h->ref_cache[list][scan8[n]] & 1));
+        my += 2 * ((s->mb_y & 1) - (pic->reference - 1));
         emu |= (my>>3) < 0 || (my>>3) + 8 >= (pic_height>>1);
     }
     src_cb= pic->data[1] + (mx>>3) + (my>>3)*h->mb_uvlinesize;
@@ -2481,7 +1757,7 @@
     dest_cb +=   x_offset +   y_offset*h->mb_uvlinesize;
     dest_cr +=   x_offset +   y_offset*h->mb_uvlinesize;
     x_offset += 8*s->mb_x;
-    y_offset += 8*(s->mb_y >> MB_MBAFF);
+    y_offset += 8*(s->mb_y >> MB_FIELD);
 
     if(list0){
         Picture *ref= &h->ref_list[0][ h->ref_cache[0][ scan8[n] ] ];
@@ -2514,7 +1790,7 @@
     dest_cb +=   x_offset +   y_offset*h->mb_uvlinesize;
     dest_cr +=   x_offset +   y_offset*h->mb_uvlinesize;
     x_offset += 8*s->mb_x;
-    y_offset += 8*(s->mb_y >> MB_MBAFF);
+    y_offset += 8*(s->mb_y >> MB_FIELD);
 
     if(list0 && list1){
         /* don't optimize for luma-only case, since B-frames usually
@@ -2607,7 +1883,7 @@
                       qpel_mc_func (*qpix_avg)[16], h264_chroma_mc_func (*chroma_avg),
                       h264_weight_func *weight_op, h264_biweight_func *weight_avg){
     MpegEncContext * const s = &h->s;
-    const int mb_xy= s->mb_x + s->mb_y*s->mb_stride;
+    const int mb_xy= h->mb_xy;
     const int mb_type= s->current_picture.mb_type[mb_xy];
 
     assert(IS_INTER(mb_type));
@@ -2728,57 +2004,9 @@
     }
 }
 
-/**
- * Sets the intra prediction function pointers.
- */
-static void init_pred_ptrs(H264Context *h){
-//    MpegEncContext * const s = &h->s;
-
-    h->pred4x4[VERT_PRED           ]= pred4x4_vertical_c;
-    h->pred4x4[HOR_PRED            ]= pred4x4_horizontal_c;
-    h->pred4x4[DC_PRED             ]= pred4x4_dc_c;
-    h->pred4x4[DIAG_DOWN_LEFT_PRED ]= pred4x4_down_left_c;
-    h->pred4x4[DIAG_DOWN_RIGHT_PRED]= pred4x4_down_right_c;
-    h->pred4x4[VERT_RIGHT_PRED     ]= pred4x4_vertical_right_c;
-    h->pred4x4[HOR_DOWN_PRED       ]= pred4x4_horizontal_down_c;
-    h->pred4x4[VERT_LEFT_PRED      ]= pred4x4_vertical_left_c;
-    h->pred4x4[HOR_UP_PRED         ]= pred4x4_horizontal_up_c;
-    h->pred4x4[LEFT_DC_PRED        ]= pred4x4_left_dc_c;
-    h->pred4x4[TOP_DC_PRED         ]= pred4x4_top_dc_c;
-    h->pred4x4[DC_128_PRED         ]= pred4x4_128_dc_c;
-
-    h->pred8x8l[VERT_PRED           ]= pred8x8l_vertical_c;
-    h->pred8x8l[HOR_PRED            ]= pred8x8l_horizontal_c;
-    h->pred8x8l[DC_PRED             ]= pred8x8l_dc_c;
-    h->pred8x8l[DIAG_DOWN_LEFT_PRED ]= pred8x8l_down_left_c;
-    h->pred8x8l[DIAG_DOWN_RIGHT_PRED]= pred8x8l_down_right_c;
-    h->pred8x8l[VERT_RIGHT_PRED     ]= pred8x8l_vertical_right_c;
-    h->pred8x8l[HOR_DOWN_PRED       ]= pred8x8l_horizontal_down_c;
-    h->pred8x8l[VERT_LEFT_PRED      ]= pred8x8l_vertical_left_c;
-    h->pred8x8l[HOR_UP_PRED         ]= pred8x8l_horizontal_up_c;
-    h->pred8x8l[LEFT_DC_PRED        ]= pred8x8l_left_dc_c;
-    h->pred8x8l[TOP_DC_PRED         ]= pred8x8l_top_dc_c;
-    h->pred8x8l[DC_128_PRED         ]= pred8x8l_128_dc_c;
-
-    h->pred8x8[DC_PRED8x8     ]= ff_pred8x8_dc_c;
-    h->pred8x8[VERT_PRED8x8   ]= ff_pred8x8_vertical_c;
-    h->pred8x8[HOR_PRED8x8    ]= ff_pred8x8_horizontal_c;
-    h->pred8x8[PLANE_PRED8x8  ]= ff_pred8x8_plane_c;
-    h->pred8x8[LEFT_DC_PRED8x8]= ff_pred8x8_left_dc_c;
-    h->pred8x8[TOP_DC_PRED8x8 ]= ff_pred8x8_top_dc_c;
-    h->pred8x8[DC_128_PRED8x8 ]= ff_pred8x8_128_dc_c;
-
-    h->pred16x16[DC_PRED8x8     ]= ff_pred16x16_dc_c;
-    h->pred16x16[VERT_PRED8x8   ]= ff_pred16x16_vertical_c;
-    h->pred16x16[HOR_PRED8x8    ]= ff_pred16x16_horizontal_c;
-    h->pred16x16[PLANE_PRED8x8  ]= ff_pred16x16_plane_c;
-    h->pred16x16[LEFT_DC_PRED8x8]= ff_pred16x16_left_dc_c;
-    h->pred16x16[TOP_DC_PRED8x8 ]= ff_pred16x16_top_dc_c;
-    h->pred16x16[DC_128_PRED8x8 ]= ff_pred16x16_128_dc_c;
-}
-
 static void free_tables(H264Context *h){
     int i;
+    H264Context *hx;
     av_freep(&h->intra4x4_pred_mode);
     av_freep(&h->chroma_pred_mode_table);
     av_freep(&h->cbp_table);
@@ -2787,20 +2015,24 @@
     av_freep(&h->direct_table);
     av_freep(&h->non_zero_count);
     av_freep(&h->slice_table_base);
-    av_freep(&h->top_borders[1]);
-    av_freep(&h->top_borders[0]);
     h->slice_table= NULL;
 
     av_freep(&h->mb2b_xy);
     av_freep(&h->mb2b8_xy);
 
-    av_freep(&h->s.obmc_scratchpad);
-
     for(i = 0; i < MAX_SPS_COUNT; i++)
         av_freep(h->sps_buffers + i);
 
     for(i = 0; i < MAX_PPS_COUNT; i++)
         av_freep(h->pps_buffers + i);
+
+    for(i = 0; i < h->s.avctx->thread_count; i++) {
+        hx = h->thread_context[i];
+        if(!hx) continue;
+        av_freep(&hx->top_borders[1]);
+        av_freep(&hx->top_borders[0]);
+        av_freep(&hx->s.obmc_scratchpad);
+    }
 }
 
 static void init_dequant8_coeff_table(H264Context *h){
@@ -2881,16 +2113,12 @@
 
     CHECKED_ALLOCZ(h->non_zero_count    , big_mb_num * 16 * sizeof(uint8_t))
     CHECKED_ALLOCZ(h->slice_table_base  , (big_mb_num+s->mb_stride) * sizeof(uint8_t))
-    CHECKED_ALLOCZ(h->top_borders[0]    , s->mb_width * (16+8+8) * sizeof(uint8_t))
-    CHECKED_ALLOCZ(h->top_borders[1]    , s->mb_width * (16+8+8) * sizeof(uint8_t))
     CHECKED_ALLOCZ(h->cbp_table, big_mb_num * sizeof(uint16_t))
 
-    if( h->pps.cabac ) {
-        CHECKED_ALLOCZ(h->chroma_pred_mode_table, big_mb_num * sizeof(uint8_t))
-        CHECKED_ALLOCZ(h->mvd_table[0], 32*big_mb_num * sizeof(uint16_t));
-        CHECKED_ALLOCZ(h->mvd_table[1], 32*big_mb_num * sizeof(uint16_t));
-        CHECKED_ALLOCZ(h->direct_table, 32*big_mb_num * sizeof(uint8_t));
-    }
+    CHECKED_ALLOCZ(h->chroma_pred_mode_table, big_mb_num * sizeof(uint8_t))
+    CHECKED_ALLOCZ(h->mvd_table[0], 32*big_mb_num * sizeof(uint16_t));
+    CHECKED_ALLOCZ(h->mvd_table[1], 32*big_mb_num * sizeof(uint16_t));
+    CHECKED_ALLOCZ(h->direct_table, 32*big_mb_num * sizeof(uint8_t));
 
     memset(h->slice_table_base, -1, (big_mb_num+s->mb_stride)  * sizeof(uint8_t));
     h->slice_table= h->slice_table_base + s->mb_stride*2 + 1;
@@ -2919,6 +2147,38 @@
     return -1;
 }
 
+/**
+ * Mimic alloc_tables(), but for every context thread.
+ */
+static void clone_tables(H264Context *dst, H264Context *src){
+    dst->intra4x4_pred_mode       = src->intra4x4_pred_mode;
+    dst->non_zero_count           = src->non_zero_count;
+    dst->slice_table              = src->slice_table;
+    dst->cbp_table                = src->cbp_table;
+    dst->mb2b_xy                  = src->mb2b_xy;
+    dst->mb2b8_xy                 = src->mb2b8_xy;
+    dst->chroma_pred_mode_table   = src->chroma_pred_mode_table;
+    dst->mvd_table[0]             = src->mvd_table[0];
+    dst->mvd_table[1]             = src->mvd_table[1];
+    dst->direct_table             = src->direct_table;
+
+    dst->s.obmc_scratchpad = NULL;
+    ff_h264_pred_init(&dst->hpc, src->s.codec_id);
+}
+
+/**
+ * Init context
+ * Allocate buffers which are not shared amongst multiple threads.
+ */
+static int context_init(H264Context *h){
+    CHECKED_ALLOCZ(h->top_borders[0], h->s.mb_width * (16+8+8) * sizeof(uint8_t))
+    CHECKED_ALLOCZ(h->top_borders[1], h->s.mb_width * (16+8+8) * sizeof(uint8_t))
+
+    return 0;
+fail:
+    return -1; // free_tables will clean up for us
+}
+
 static void common_init(H264Context *h){
     MpegEncContext * const s = &h->s;
 
@@ -2926,7 +2186,7 @@
     s->height = s->avctx->height;
     s->codec_id= s->avctx->codec->id;
 
-    init_pred_ptrs(h);
+    ff_h264_pred_init(&h->hpc, s->codec_id);
 
     h->dequant_coeff_pps= -1;
     s->unrestricted_mv=1;
@@ -2950,9 +2210,14 @@
 
     // set defaults
 //    s->decode_mb= ff_h263_decode_mb;
+    s->quarter_sample = 1;
     s->low_delay= 1;
-    avctx->pix_fmt= PIX_FMT_YUV420P;
 
+    if(avctx->codec_id == CODEC_ID_SVQ3)
+        avctx->pix_fmt= PIX_FMT_YUVJ420P;
+    else
+        avctx->pix_fmt= PIX_FMT_YUV420P;
+
     decode_init_vlc();
 
     if(avctx->extradata_size > 0 && avctx->extradata &&
@@ -2963,6 +2228,7 @@
         h->is_avc = 0;
     }
 
+    h->thread_context[0] = h;
     return 0;
 }
 
@@ -2973,6 +2239,13 @@
     if(MPV_frame_start(s, s->avctx) < 0)
         return -1;
     ff_er_frame_start(s);
+    /*
+     * MPV_frame_start uses pict_type to derive key_frame.
+     * This is incorrect for H.264; IDR markings must be used.
+     * Zero here; IDR markings per slice in frame or fields are OR'd in later.
+     * See decode_nal_units().
+     */
+    s->current_picture_ptr->key_frame= 0;
 
     assert(s->linesize && s->uvlinesize);
 
@@ -2989,14 +2262,16 @@
 
     /* can't be in alloc_tables because linesize isn't known there.
      * FIXME: redo bipred weight to not require extra buffer? */
-    if(!s->obmc_scratchpad)
-        s->obmc_scratchpad = av_malloc(16*2*s->linesize + 8*2*s->uvlinesize);
+    for(i = 0; i < s->avctx->thread_count; i++)
+        if(!h->thread_context[i]->s.obmc_scratchpad)
+            h->thread_context[i]->s.obmc_scratchpad = av_malloc(16*2*s->linesize + 8*2*s->uvlinesize);
 
     /* some macroblocks will be accessed before they're available */
-    if(FRAME_MBAFF)
+    if(FRAME_MBAFF || s->avctx->thread_count > 1)
         memset(h->slice_table, -1, (s->mb_height*s->mb_stride-1) * sizeof(uint8_t));
 
 //    s->decode= (s->flags&CODEC_FLAG_PSNR) || !s->encoding || s->current_picture.reference /*|| h->contains_intra*/ || 1;
+    s->current_picture_ptr->reference= 0;
     return 0;
 }
 
@@ -3018,7 +2293,7 @@
     *(uint64_t*)(h->top_borders[0][s->mb_x]+0)= *(uint64_t*)(src_y +  16*linesize);
     *(uint64_t*)(h->top_borders[0][s->mb_x]+8)= *(uint64_t*)(src_y +8+16*linesize);
 
-    if(simple || !(s->flags&CODEC_FLAG_GRAY)){
+    if(simple || !ENABLE_GRAY || !(s->flags&CODEC_FLAG_GRAY)){
         h->left_border[17  ]= h->top_borders[0][s->mb_x][16+7];
         h->left_border[17+9]= h->top_borders[0][s->mb_x][24+7];
         for(i=1; i<9; i++){
@@ -3039,7 +2314,7 @@
     int mb_xy;
 
     if(h->deblocking_filter == 2) {
-        mb_xy = s->mb_x + s->mb_y*s->mb_stride;
+        mb_xy = h->mb_xy;
         deblock_left = h->slice_table[mb_xy] == h->slice_table[mb_xy - 1];
         deblock_top  = h->slice_table[mb_xy] == h->slice_table[h->top_mb_xy];
     } else {
@@ -3071,7 +2346,7 @@
         }
     }
 
-    if(simple || !(s->flags&CODEC_FLAG_GRAY)){
+    if(simple || !ENABLE_GRAY || !(s->flags&CODEC_FLAG_GRAY)){
         if(deblock_left){
             for(i = !deblock_top; i<9; i++){
                 XCHG(h->left_border[i+17  ], src_cb[i*uvlinesize], temp8, xchg);
@@ -3106,7 +2381,7 @@
     *(uint64_t*)(h->top_borders[1][s->mb_x]+0)= *(uint64_t*)(src_y +  33*linesize);
     *(uint64_t*)(h->top_borders[1][s->mb_x]+8)= *(uint64_t*)(src_y +8+33*linesize);
 
-    if(!(s->flags&CODEC_FLAG_GRAY)){
+    if(!ENABLE_GRAY || !(s->flags&CODEC_FLAG_GRAY)){
         h->left_border[34     ]= h->top_borders[0][s->mb_x][16+7];
         h->left_border[34+   1]= h->top_borders[1][s->mb_x][16+7];
         h->left_border[34+18  ]= h->top_borders[0][s->mb_x][24+7];
@@ -3158,7 +2433,7 @@
         }
     }
 
-    if(!(s->flags&CODEC_FLAG_GRAY)){
+    if(!ENABLE_GRAY || !(s->flags&CODEC_FLAG_GRAY)){
         if(deblock_left){
             for(i = (!deblock_top) << 1; i<18; i++){
                 XCHG(h->left_border[i+34   ], src_cb[i*uvlinesize], temp8, xchg);
@@ -3178,7 +2453,7 @@
     MpegEncContext * const s = &h->s;
     const int mb_x= s->mb_x;
     const int mb_y= s->mb_y;
-    const int mb_xy= mb_x + mb_y*s->mb_stride;
+    const int mb_xy= h->mb_xy;
     const int mb_type= s->current_picture.mb_type[mb_xy];
     uint8_t  *dest_y, *dest_cb, *dest_cr;
     int linesize, uvlinesize /*dct_offset*/;
@@ -3212,13 +2487,13 @@
                     continue;
                 if(IS_16X16(mb_type)){
                     int8_t *ref = &h->ref_cache[list][scan8[0]];
-                    fill_rectangle(ref, 4, 4, 8, 16+*ref^(s->mb_y&1), 1);
+                    fill_rectangle(ref, 4, 4, 8, (16+*ref)^(s->mb_y&1), 1);
                 }else{
                     for(i=0; i<16; i+=4){
                         //FIXME can refs be smaller than 8x8 when !direct_8x8_inference ?
                         int ref = h->ref_cache[list][scan8[i]];
                         if(ref >= 0)
-                            fill_rectangle(&h->ref_cache[list][scan8[i]], 2, 2, 8, 16+ref^(s->mb_y&1), 1);
+                            fill_rectangle(&h->ref_cache[list][scan8[i]], 2, 2, 8, (16+ref)^(s->mb_y&1), 1);
                     }
                 }
             }
@@ -3280,9 +2555,9 @@
             if(h->deblocking_filter && (simple || !FRAME_MBAFF))
                 xchg_mb_border(h, dest_y, dest_cb, dest_cr, linesize, uvlinesize, 1, simple);
 
-            if(simple || !(s->flags&CODEC_FLAG_GRAY)){
-                h->pred8x8[ h->chroma_pred_mode ](dest_cb, uvlinesize);
-                h->pred8x8[ h->chroma_pred_mode ](dest_cr, uvlinesize);
+            if(simple || !ENABLE_GRAY || !(s->flags&CODEC_FLAG_GRAY)){
+                h->hpc.pred8x8[ h->chroma_pred_mode ](dest_cb, uvlinesize);
+                h->hpc.pred8x8[ h->chroma_pred_mode ](dest_cr, uvlinesize);
             }
 
             if(IS_INTRA4x4(mb_type)){
@@ -3292,7 +2567,7 @@
                             uint8_t * const ptr= dest_y + block_offset[i];
                             const int dir= h->intra4x4_pred_mode_cache[ scan8[i] ];
                             const int nnz = h->non_zero_count_cache[ scan8[i] ];
-                            h->pred8x8l[ dir ](ptr, (h->topleft_samples_available<<i)&0x8000,
+                            h->hpc.pred8x8l[ dir ](ptr, (h->topleft_samples_available<<i)&0x8000,
                                                    (h->topright_samples_available<<i)&0x4000, linesize);
                             if(nnz){
                                 if(nnz == 1 && h->mb[i*16])
@@ -3319,7 +2594,7 @@
                         }else
                             topright= NULL;
 
-                        h->pred4x4[ dir ](ptr, topright, linesize);
+                        h->hpc.pred4x4[ dir ](ptr, topright, linesize);
                         nnz = h->non_zero_count_cache[ scan8[i] ];
                         if(nnz){
                             if(is_h264){
@@ -3333,10 +2608,10 @@
                     }
                 }
             }else{
-                h->pred16x16[ h->intra16x16_pred_mode ](dest_y , linesize);
+                h->hpc.pred16x16[ h->intra16x16_pred_mode ](dest_y , linesize);
                 if(is_h264){
                     if(!transform_bypass)
-                        h264_luma_dc_dequant_idct_c(h->mb, s->qscale, h->dequant4_coeff[IS_INTRA(mb_type) ? 0:3][s->qscale][0]);
+                        h264_luma_dc_dequant_idct_c(h->mb, s->qscale, h->dequant4_coeff[0][s->qscale][0]);
                 }else
                     svq3_luma_dc_dequant_idct_c(h->mb, s->qscale);
             }
@@ -3381,7 +2656,7 @@
             }
         }
 
-        if(simple || !(s->flags&CODEC_FLAG_GRAY)){
+        if(simple || !ENABLE_GRAY || !(s->flags&CODEC_FLAG_GRAY)){
             uint8_t *dest[2] = {dest_cb, dest_cr};
             if(transform_bypass){
                 idct_add = idct_dc_add = s->dsp.add_pixels4;
@@ -3428,14 +2703,14 @@
             backup_pair_border(h, pair_dest_y, pair_dest_cb, pair_dest_cr, s->linesize, s->uvlinesize);
             // deblock a pair
             // top
-            s->mb_y--;
+            s->mb_y--; h->mb_xy -= s->mb_stride;
             tprintf(h->s.avctx, "call mbaff filter_mb mb_x:%d mb_y:%d pair_dest_y = %p, dest_y = %p\n", mb_x, mb_y, pair_dest_y, dest_y);
             fill_caches(h, mb_type_top, 1); //FIXME don't fill stuff which isn't used by filter_mb
             h->chroma_qp[0] = get_chroma_qp(h, 0, s->current_picture.qscale_table[mb_xy]);
             h->chroma_qp[1] = get_chroma_qp(h, 1, s->current_picture.qscale_table[mb_xy]);
             filter_mb(h, mb_x, mb_y, pair_dest_y, pair_dest_cb, pair_dest_cr, linesize, uvlinesize);
             // bottom
-            s->mb_y++;
+            s->mb_y++; h->mb_xy += s->mb_stride;
             tprintf(h->s.avctx, "call mbaff filter_mb\n");
             fill_caches(h, mb_type_bottom, 1); //FIXME don't fill stuff which isn't used by filter_mb
             h->chroma_qp[0] = get_chroma_qp(h, 0, s->current_picture.qscale_table[mb_xy+s->mb_stride]);
@@ -3466,13 +2741,12 @@
 
 static void hl_decode_mb(H264Context *h){
     MpegEncContext * const s = &h->s;
-    const int mb_x= s->mb_x;
-    const int mb_y= s->mb_y;
-    const int mb_xy= mb_x + mb_y*s->mb_stride;
+    const int mb_xy= h->mb_xy;
     const int mb_type= s->current_picture.mb_type[mb_xy];
-    int is_complex = FRAME_MBAFF || MB_FIELD || IS_INTRA_PCM(mb_type) || s->codec_id != CODEC_ID_H264 || (s->flags&CODEC_FLAG_GRAY) || s->encoding;
+    int is_complex = FRAME_MBAFF || MB_FIELD || IS_INTRA_PCM(mb_type) || s->codec_id != CODEC_ID_H264 ||
+                    (ENABLE_GRAY && (s->flags&CODEC_FLAG_GRAY)) || (ENABLE_H264_ENCODER && s->encoding) || ENABLE_SMALL;
 
-    if(!s->decode)
+    if(ENABLE_H264_ENCODER && !s->decode)
         return;
 
     if (is_complex)
@@ -3480,16 +2754,131 @@
     else hl_decode_mb_simple(h);
 }
 
+static void pic_as_field(Picture *pic, const int parity){
+    int i;
+    for (i = 0; i < 4; ++i) {
+        if (parity == PICT_BOTTOM_FIELD)
+            pic->data[i] += pic->linesize[i];
+        pic->reference = parity;
+        pic->linesize[i] *= 2;
+    }
+}
+
+static int split_field_copy(Picture *dest, Picture *src,
+                            int parity, int id_add){
+    int match = !!(src->reference & parity);
+
+    if (match) {
+        *dest = *src;
+        pic_as_field(dest, parity);
+        dest->pic_id *= 2;
+        dest->pic_id += id_add;
+    }
+
+    return match;
+}
+
 /**
+ * Split one reference list into field parts, interleaving by parity
+ * as per H.264 spec section 8.2.4.2.5. Output fields have their data pointers
+ * set to look at the actual start of data for that field.
+ *
+ * @param dest output list
+ * @param dest_len maximum number of fields to put in dest
+ * @param src the source reference list containing fields and/or field pairs
+ *            (aka short_ref/long_ref, or
+ *             refFrameListXShortTerm/refFrameListLongTerm in spec-speak)
+ * @param src_len number of Picture's in source (pairs and unmatched fields)
+ * @param parity the parity of the picture being decoded/needing
+ *        these ref pics (PICT_{TOP,BOTTOM}_FIELD)
+ * @return number of fields placed in dest
+ */
+static int split_field_half_ref_list(Picture *dest, int dest_len,
+                                     Picture *src,  int src_len,  int parity){
+    int same_parity   = 1;
+    int same_i        = 0;
+    int opp_i         = 0;
+    int out_i;
+    int field_output;
+
+    for (out_i = 0; out_i < dest_len; out_i += field_output) {
+        if (same_parity && same_i < src_len) {
+            field_output = split_field_copy(dest + out_i, src + same_i,
+                                            parity, 1);
+            same_parity = !field_output;
+            same_i++;
+
+        } else if (opp_i < src_len) {
+            field_output = split_field_copy(dest + out_i, src + opp_i,
+                                            PICT_FRAME - parity, 0);
+            same_parity = field_output;
+            opp_i++;
+
+        } else {
+            break;
+        }
+    }
+
+    return out_i;
+}
+
+/**
+ * Split the reference frame list into a reference field list.
+ * This implements H.264 spec 8.2.4.2.5 for a combined input list.
+ * The input list contains both reference field pairs and
+ * unmatched reference fields; it is ordered as spec describes
+ * RefPicListX for frames in 8.2.4.2.1 and 8.2.4.2.3, except that
+ * unmatched field pairs are also present. Conceptually this is equivalent
+ * to concatenation of refFrameListXShortTerm with refFrameListLongTerm.
+ *
+ * @param dest output reference list where ordered fields are to be placed
+ * @param dest_len max number of fields to place at dest
+ * @param src source reference list, as described above
+ * @param src_len number of pictures (pairs and unmatched fields) in src
+ * @param parity parity of field being currently decoded
+ *        (one of PICT_{TOP,BOTTOM}_FIELD)
+ * @param long_i index into src array that holds first long reference picture,
+ *        or src_len if no long refs present.
+ */
+static int split_field_ref_list(Picture *dest, int dest_len,
+                                Picture *src,  int src_len,
+                                int parity,    int long_i){
+
+    int i = split_field_half_ref_list(dest, dest_len, src, long_i, parity);
+    dest += i;
+    dest_len -= i;
+
+    i += split_field_half_ref_list(dest, dest_len, src + long_i,
+                                   src_len - long_i, parity);
+    return i;
+}
+
+/**
  * fills the default_ref_list.
  */
 static int fill_default_ref_list(H264Context *h){
     MpegEncContext * const s = &h->s;
     int i;
     int smallest_poc_greater_than_current = -1;
+    int structure_sel;
     Picture sorted_short_ref[32];
+    Picture field_entry_list[2][32];
+    Picture *frame_list[2];
 
-    if(h->slice_type==B_TYPE){
+    if (FIELD_PICTURE) {
+        structure_sel = PICT_FRAME;
+        frame_list[0] = field_entry_list[0];
+        frame_list[1] = field_entry_list[1];
+    } else {
+        structure_sel = 0;
+        frame_list[0] = h->default_ref_list[0];
+        frame_list[1] = h->default_ref_list[1];
+    }
+
+    if(h->slice_type==FF_B_TYPE){
+        int list;
+        int len[2];
+        int short_len[2];
         int out_i;
         int limit= INT_MIN;
 
@@ -3517,79 +2906,100 @@
                 }
             }
         }
-    }
 
-    if(s->picture_structure == PICT_FRAME){
-        if(h->slice_type==B_TYPE){
-            int list;
-            tprintf(h->s.avctx, "current poc: %d, smallest_poc_greater_than_current: %d\n", s->current_picture_ptr->poc, smallest_poc_greater_than_current);
+        tprintf(h->s.avctx, "current poc: %d, smallest_poc_greater_than_current: %d\n", s->current_picture_ptr->poc, smallest_poc_greater_than_current);
 
-            // find the largest poc
-            for(list=0; list<2; list++){
-                int index = 0;
-                int j= -99;
-                int step= list ? -1 : 1;
+        // find the largest poc
+        for(list=0; list<2; list++){
+            int index = 0;
+            int j= -99;
+            int step= list ? -1 : 1;
 
-                for(i=0; i<h->short_ref_count && index < h->ref_count[list]; i++, j+=step) {
-                    while(j<0 || j>= h->short_ref_count){
-                        if(j != -99 && step == (list ? -1 : 1))
-                            return -1;
-                        step = -step;
-                        j= smallest_poc_greater_than_current + (step>>1);
-                    }
-                    if(sorted_short_ref[j].reference != 3) continue;
-                    h->default_ref_list[list][index  ]= sorted_short_ref[j];
-                    h->default_ref_list[list][index++].pic_id= sorted_short_ref[j].frame_num;
+            for(i=0; i<h->short_ref_count && index < h->ref_count[list]; i++, j+=step) {
+                int sel;
+                while(j<0 || j>= h->short_ref_count){
+                    if(j != -99 && step == (list ? -1 : 1))
+                        return -1;
+                    step = -step;
+                    j= smallest_poc_greater_than_current + (step>>1);
                 }
+                sel = sorted_short_ref[j].reference | structure_sel;
+                if(sel != PICT_FRAME) continue;
+                frame_list[list][index  ]= sorted_short_ref[j];
+                frame_list[list][index++].pic_id= sorted_short_ref[j].frame_num;
+            }
+            short_len[list] = index;
 
-                for(i = 0; i < 16 && index < h->ref_count[ list ]; i++){
-                    if(h->long_ref[i] == NULL) continue;
-                    if(h->long_ref[i]->reference != 3) continue;
+            for(i = 0; i < 16 && index < h->ref_count[ list ]; i++){
+                int sel;
+                if(h->long_ref[i] == NULL) continue;
+                sel = h->long_ref[i]->reference | structure_sel;
+                if(sel != PICT_FRAME) continue;
 
-                    h->default_ref_list[ list ][index  ]= *h->long_ref[i];
-                    h->default_ref_list[ list ][index++].pic_id= i;;
-                }
+                frame_list[ list ][index  ]= *h->long_ref[i];
+                frame_list[ list ][index++].pic_id= i;
+            }
+            len[list] = index;
+        }
 
-                if(list && (smallest_poc_greater_than_current<=0 || smallest_poc_greater_than_current>=h->short_ref_count) && (1 < index)){
-                    // swap the two first elements of L1 when
-                    // L0 and L1 are identical
-                    Picture temp= h->default_ref_list[1][0];
-                    h->default_ref_list[1][0] = h->default_ref_list[1][1];
-                    h->default_ref_list[1][1] = temp;
-                }
+        for(list=0; list<2; list++){
+            if (FIELD_PICTURE)
+                len[list] = split_field_ref_list(h->default_ref_list[list],
+                                                 h->ref_count[list],
+                                                 frame_list[list],
+                                                 len[list],
+                                                 s->picture_structure,
+                                                 short_len[list]);
 
-                if(index < h->ref_count[ list ])
-                    memset(&h->default_ref_list[list][index], 0, sizeof(Picture)*(h->ref_count[ list ] - index));
-            }
-        }else{
-            int index=0;
-            for(i=0; i<h->short_ref_count; i++){
-                if(h->short_ref[i]->reference != 3) continue; //FIXME refernce field shit
-                h->default_ref_list[0][index  ]= *h->short_ref[i];
-                h->default_ref_list[0][index++].pic_id= h->short_ref[i]->frame_num;
-            }
-            for(i = 0; i < 16; i++){
-                if(h->long_ref[i] == NULL) continue;
-                if(h->long_ref[i]->reference != 3) continue;
-                h->default_ref_list[0][index  ]= *h->long_ref[i];
-                h->default_ref_list[0][index++].pic_id= i;;
-            }
-            if(index < h->ref_count[0])
-                memset(&h->default_ref_list[0][index], 0, sizeof(Picture)*(h->ref_count[0] - index));
+            // swap the two first elements of L1 when L0 and L1 are identical
+            if(list && len[0] > 1 && len[0] == len[1])
+                for(i=0; h->default_ref_list[0][i].data[0] == h->default_ref_list[1][i].data[0]; i++)
+                    if(i == len[0]){
+                        FFSWAP(Picture, h->default_ref_list[1][0], h->default_ref_list[1][1]);
+                        break;
+                    }
+
+            if(len[list] < h->ref_count[ list ])
+                memset(&h->default_ref_list[list][len[list]], 0, sizeof(Picture)*(h->ref_count[ list ] - len[list]));
         }
-    }else{ //FIELD
-        if(h->slice_type==B_TYPE){
-        }else{
-            //FIXME second field balh
+
+
+    }else{
+        int index=0;
+        int short_len;
+        for(i=0; i<h->short_ref_count; i++){
+            int sel;
+            sel = h->short_ref[i]->reference | structure_sel;
+            if(sel != PICT_FRAME) continue;
+            frame_list[0][index  ]= *h->short_ref[i];
+            frame_list[0][index++].pic_id= h->short_ref[i]->frame_num;
         }
+        short_len = index;
+        for(i = 0; i < 16; i++){
+            int sel;
+            if(h->long_ref[i] == NULL) continue;
+            sel = h->long_ref[i]->reference | structure_sel;
+            if(sel != PICT_FRAME) continue;
+            frame_list[0][index  ]= *h->long_ref[i];
+            frame_list[0][index++].pic_id= i;
+        }
+
+        if (FIELD_PICTURE)
+            index = split_field_ref_list(h->default_ref_list[0],
+                                         h->ref_count[0], frame_list[0],
+                                         index, s->picture_structure,
+                                         short_len);
+
+        if(index < h->ref_count[0])
+            memset(&h->default_ref_list[0][index], 0, sizeof(Picture)*(h->ref_count[0] - index));
     }
 #ifdef TRACE
     for (i=0; i<h->ref_count[0]; i++) {
         tprintf(h->s.avctx, "List0: %s fn:%d 0x%p\n", (h->default_ref_list[0][i].long_ref ? "LT" : "ST"), h->default_ref_list[0][i].pic_id, h->default_ref_list[0][i].data[0]);
     }
-    if(h->slice_type==B_TYPE){
+    if(h->slice_type==FF_B_TYPE){
         for (i=0; i<h->ref_count[1]; i++) {
-            tprintf(h->s.avctx, "List1: %s fn:%d 0x%p\n", (h->default_ref_list[1][i].long_ref ? "LT" : "ST"), h->default_ref_list[1][i].pic_id, h->default_ref_list[0][i].data[0]);
+            tprintf(h->s.avctx, "List1: %s fn:%d 0x%p\n", (h->default_ref_list[1][i].long_ref ? "LT" : "ST"), h->default_ref_list[1][i].pic_id, h->default_ref_list[1][i].data[0]);
         }
     }
 #endif
@@ -3599,13 +3009,37 @@
 static void print_short_term(H264Context *h);
 static void print_long_term(H264Context *h);
 
+/**
+ * Extract structure information about the picture described by pic_num in
+ * the current decoding context (frame or field). Note that pic_num is
+ * picture number without wrapping (so, 0<=pic_num<max_pic_num).
+ * @param pic_num picture number for which to extract structure information
+ * @param structure one of PICT_XXX describing structure of picture
+ *                      with pic_num
+ * @return frame number (short term) or long term index of picture
+ *         described by pic_num
+ */
+static int pic_num_extract(H264Context *h, int pic_num, int *structure){
+    MpegEncContext * const s = &h->s;
+
+    *structure = s->picture_structure;
+    if(FIELD_PICTURE){
+        if (!(pic_num & 1))
+            /* opposite field */
+            *structure ^= PICT_FRAME;
+        pic_num >>= 1;
+    }
+
+    return pic_num;
+}
+
 static int decode_ref_pic_list_reordering(H264Context *h){
     MpegEncContext * const s = &h->s;
-    int list, index;
+    int list, index, pic_structure;
 
     print_short_term(h);
     print_long_term(h);
-    if(h->slice_type==I_TYPE || h->slice_type==SI_TYPE) return 0; //FIXME move before func
+    if(h->slice_type==FF_I_TYPE || h->slice_type==FF_SI_TYPE) return 0; //FIXME move before func
 
     for(list=0; list<h->list_count; list++){
         memcpy(h->ref_list[list], h->default_ref_list[list], sizeof(Picture)*h->ref_count[list]);
@@ -3630,8 +3064,9 @@
                 if(reordering_of_pic_nums_idc<3){
                     if(reordering_of_pic_nums_idc<2){
                         const unsigned int abs_diff_pic_num= get_ue_golomb(&s->gb) + 1;
+                        int frame_num;
 
-                        if(abs_diff_pic_num >= h->max_pic_num){
+                        if(abs_diff_pic_num > h->max_pic_num){
                             av_log(h->s.avctx, AV_LOG_ERROR, "abs_diff_pic_num overflow\n");
                             return -1;
                         }
@@ -3640,25 +3075,34 @@
                         else                                pred+= abs_diff_pic_num;
                         pred &= h->max_pic_num - 1;
 
+                        frame_num = pic_num_extract(h, pred, &pic_structure);
+
                         for(i= h->short_ref_count-1; i>=0; i--){
                             ref = h->short_ref[i];
-                            assert(ref->reference == 3);
+                            assert(ref->reference);
                             assert(!ref->long_ref);
-                            if(ref->data[0] != NULL && ref->frame_num == pred && ref->long_ref == 0) // ignore non existing pictures by testing data[0] pointer
+                            if(ref->data[0] != NULL &&
+                                   ref->frame_num == frame_num &&
+                                   (ref->reference & pic_structure) &&
+                                   ref->long_ref == 0) // ignore non existing pictures by testing data[0] pointer
                                 break;
                         }
                         if(i>=0)
-                            ref->pic_id= ref->frame_num;
+                            ref->pic_id= pred;
                     }else{
+                        int long_idx;
                         pic_id= get_ue_golomb(&s->gb); //long_term_pic_idx
-                        if(pic_id>31){
+
+                        long_idx= pic_num_extract(h, pic_id, &pic_structure);
+
+                        if(long_idx>31){
                             av_log(h->s.avctx, AV_LOG_ERROR, "long_term_pic_idx overflow\n");
                             return -1;
                         }
-                        ref = h->long_ref[pic_id];
-                        if(ref){
+                        ref = h->long_ref[long_idx];
+                        assert(!(ref && !ref->reference));
+                        if(ref && (ref->reference & pic_structure)){
                             ref->pic_id= pic_id;
-                            assert(ref->reference == 3);
                             assert(ref->long_ref);
                             i=0;
                         }else{
@@ -3678,6 +3122,9 @@
                             h->ref_list[list][i]= h->ref_list[list][i-1];
                         }
                         h->ref_list[list][index]= *ref;
+                        if (FIELD_PICTURE){
+                            pic_as_field(&h->ref_list[list][index], pic_structure);
+                        }
                     }
                 }else{
                     av_log(h->s.avctx, AV_LOG_ERROR, "illegal reordering_of_pic_nums_idc\n");
@@ -3693,7 +3140,7 @@
         }
     }
 
-    if(h->slice_type==B_TYPE && !h->direct_spatial_mv_pred)
+    if(h->slice_type==FF_B_TYPE && !h->direct_spatial_mv_pred)
         direct_dist_scale_factor(h);
     direct_ref_list_init(h);
     return 0;
@@ -3708,9 +3155,11 @@
             field[0] = *frame;
             for(j=0; j<3; j++)
                 field[0].linesize[j] <<= 1;
+            field[0].reference = PICT_TOP_FIELD;
             field[1] = field[0];
             for(j=0; j<3; j++)
                 field[1].data[j] += frame->linesize[j];
+            field[1].reference = PICT_BOTTOM_FIELD;
 
             h->luma_weight[list][16+2*i] = h->luma_weight[list][16+2*i+1] = h->luma_weight[list][i];
             h->luma_offset[list][16+2*i] = h->luma_offset[list][16+2*i+1] = h->luma_offset[list][i];
@@ -3774,7 +3223,7 @@
                 }
             }
         }
-        if(h->slice_type != B_TYPE) break;
+        if(h->slice_type != FF_B_TYPE) break;
     }
     h->use_weight= h->use_weight || h->use_weight_chroma;
     return 0;
@@ -3816,17 +3265,32 @@
     }
 }
 
-static inline void unreference_pic(H264Context *h, Picture *pic){
+/**
+ * Mark a picture as no longer needed for reference. The refmask
+ * argument allows unreferencing of individual fields or the whole frame.
+ * If the picture becomes entirely unreferenced, but is being held for
+ * display purposes, it is marked as such.
+ * @param refmask mask of fields to unreference; the mask is bitwise
+ *                anded with the reference marking of pic
+ * @return non-zero if pic becomes entirely unreferenced (except possibly
+ *         for display purposes) zero if one of the fields remains in
+ *         reference
+ */
+static inline int unreference_pic(H264Context *h, Picture *pic, int refmask){
     int i;
-    pic->reference=0;
-    if(pic == h->delayed_output_pic)
-        pic->reference=1;
-    else{
-        for(i = 0; h->delayed_pic[i]; i++)
-            if(pic == h->delayed_pic[i]){
-                pic->reference=1;
-                break;
-            }
+    if (pic->reference &= refmask) {
+        return 0;
+    } else {
+        if(pic == h->delayed_output_pic)
+            pic->reference=DELAYED_PIC_REF;
+        else{
+            for(i = 0; h->delayed_pic[i]; i++)
+                if(pic == h->delayed_pic[i]){
+                    pic->reference=DELAYED_PIC_REF;
+                    break;
+                }
+        }
+        return 1;
     }
 }
 
@@ -3838,14 +3302,14 @@
 
     for(i=0; i<16; i++){
         if (h->long_ref[i] != NULL) {
-            unreference_pic(h, h->long_ref[i]);
+            unreference_pic(h, h->long_ref[i], 0);
             h->long_ref[i]= NULL;
         }
     }
     h->long_ref_count=0;
 
     for(i=0; i<h->short_ref_count; i++){
-        unreference_pic(h, h->short_ref[i]);
+        unreference_pic(h, h->short_ref[i], 0);
         h->short_ref[i]= NULL;
     }
     h->short_ref_count=0;
@@ -3855,7 +3319,7 @@
 static void flush_dpb(AVCodecContext *avctx){
     H264Context *h= avctx->priv_data;
     int i;
-    for(i=0; i<16; i++) {
+    for(i=0; i<MAX_DELAYED_PIC_COUNT; i++) {
         if(h->delayed_pic[i])
             h->delayed_pic[i]->reference= 0;
         h->delayed_pic[i]= NULL;
@@ -3866,27 +3330,28 @@
     idr(h);
     if(h->s.current_picture_ptr)
         h->s.current_picture_ptr->reference= 0;
+    h->s.first_field= 0;
+    ff_mpeg_flush(avctx);
 }
 
 /**
- *
- * @return the removed picture or NULL if an error occurs
+ * Find a Picture in the short term reference list by frame number.
+ * @param frame_num frame number to search for
+ * @param idx the index into h->short_ref where returned picture is found
+ *            undefined if no picture found.
+ * @return pointer to the found picture, or NULL if no pic with the provided
+ *                 frame number is found
  */
-static Picture * remove_short(H264Context *h, int frame_num){
+static Picture * find_short(H264Context *h, int frame_num, int *idx){
     MpegEncContext * const s = &h->s;
     int i;
 
-    if(s->avctx->debug&FF_DEBUG_MMCO)
-        av_log(h->s.avctx, AV_LOG_DEBUG, "remove short %d count %d\n", frame_num, h->short_ref_count);
-
     for(i=0; i<h->short_ref_count; i++){
         Picture *pic= h->short_ref[i];
         if(s->avctx->debug&FF_DEBUG_MMCO)
             av_log(h->s.avctx, AV_LOG_DEBUG, "%d %d %p\n", i, pic->frame_num, pic);
-        if(pic->frame_num == frame_num){
-            h->short_ref[i]= NULL;
-            memmove(&h->short_ref[i], &h->short_ref[i+1], (h->short_ref_count - i - 1)*sizeof(Picture*));
-            h->short_ref_count--;
+        if(pic->frame_num == frame_num) {
+            *idx = i;
             return pic;
         }
     }
@@ -3894,15 +3359,58 @@
 }
 
 /**
+ * Remove a picture from the short term reference list by its index in
+ * that list.  This does no checking on the provided index; it is assumed
+ * to be valid. Other list entries are shifted down.
+ * @param i index into h->short_ref of picture to remove.
+ */
+static void remove_short_at_index(H264Context *h, int i){
+    assert(i >= 0 && i < h->short_ref_count);
+    h->short_ref[i]= NULL;
+    if (--h->short_ref_count)
+        memmove(&h->short_ref[i], &h->short_ref[i+1], (h->short_ref_count - i)*sizeof(Picture*));
+}
+
+/**
  *
  * @return the removed picture or NULL if an error occurs
  */
+static Picture * remove_short(H264Context *h, int frame_num){
+    MpegEncContext * const s = &h->s;
+    Picture *pic;
+    int i;
+
+    if(s->avctx->debug&FF_DEBUG_MMCO)
+        av_log(h->s.avctx, AV_LOG_DEBUG, "remove short %d count %d\n", frame_num, h->short_ref_count);
+
+    pic = find_short(h, frame_num, &i);
+    if (pic)
+        remove_short_at_index(h, i);
+
+    return pic;
+}
+
+/**
+ * Remove a picture from the long term reference list by its index in
+ * that list.  This does no checking on the provided index; it is assumed
+ * to be valid. The removed entry is set to NULL. Other entries are unaffected.
+ * @param i index into h->long_ref of picture to remove.
+ */
+static void remove_long_at_index(H264Context *h, int i){
+    h->long_ref[i]= NULL;
+    h->long_ref_count--;
+}
+
+/**
+ *
+ * @return the removed picture or NULL if an error occurs
+ */
 static Picture * remove_long(H264Context *h, int i){
     Picture *pic;
 
     pic= h->long_ref[i];
-    h->long_ref[i]= NULL;
-    if(pic) h->long_ref_count--;
+    if (pic)
+        remove_long_at_index(h, i);
 
     return pic;
 }
@@ -3943,77 +3451,143 @@
 static int execute_ref_pic_marking(H264Context *h, MMCO *mmco, int mmco_count){
     MpegEncContext * const s = &h->s;
     int i, j;
-    int current_is_long=0;
+    int current_ref_assigned=0;
     Picture *pic;
 
     if((s->avctx->debug&FF_DEBUG_MMCO) && mmco_count==0)
         av_log(h->s.avctx, AV_LOG_DEBUG, "no mmco here\n");
 
     for(i=0; i<mmco_count; i++){
+        int structure, frame_num, unref_pic;
         if(s->avctx->debug&FF_DEBUG_MMCO)
-            av_log(h->s.avctx, AV_LOG_DEBUG, "mmco:%d %d %d\n", h->mmco[i].opcode, h->mmco[i].short_frame_num, h->mmco[i].long_index);
+            av_log(h->s.avctx, AV_LOG_DEBUG, "mmco:%d %d %d\n", h->mmco[i].opcode, h->mmco[i].short_pic_num, h->mmco[i].long_arg);
 
         switch(mmco[i].opcode){
         case MMCO_SHORT2UNUSED:
-            pic= remove_short(h, mmco[i].short_frame_num);
-            if(pic)
-                unreference_pic(h, pic);
-            else if(s->avctx->debug&FF_DEBUG_MMCO)
-                av_log(h->s.avctx, AV_LOG_DEBUG, "mmco: remove_short() failure\n");
+            if(s->avctx->debug&FF_DEBUG_MMCO)
+                av_log(h->s.avctx, AV_LOG_DEBUG, "mmco: unref short %d count %d\n", h->mmco[i].short_pic_num, h->short_ref_count);
+            frame_num = pic_num_extract(h, mmco[i].short_pic_num, &structure);
+            pic = find_short(h, frame_num, &j);
+            if (pic) {
+                if (unreference_pic(h, pic, structure ^ PICT_FRAME))
+                    remove_short_at_index(h, j);
+            } else if(s->avctx->debug&FF_DEBUG_MMCO)
+                av_log(h->s.avctx, AV_LOG_DEBUG, "mmco: unref short failure\n");
             break;
         case MMCO_SHORT2LONG:
-            pic= remove_long(h, mmco[i].long_index);
-            if(pic) unreference_pic(h, pic);
+            if (FIELD_PICTURE && mmco[i].long_arg < h->long_ref_count &&
+                    h->long_ref[mmco[i].long_arg]->frame_num ==
+                                              mmco[i].short_pic_num / 2) {
+                /* do nothing, we've already moved this field pair. */
+            } else {
+                int frame_num = mmco[i].short_pic_num >> FIELD_PICTURE;
 
-            h->long_ref[ mmco[i].long_index ]= remove_short(h, mmco[i].short_frame_num);
-            if (h->long_ref[ mmco[i].long_index ]){
-                h->long_ref[ mmco[i].long_index ]->long_ref=1;
-                h->long_ref_count++;
+                pic= remove_long(h, mmco[i].long_arg);
+                if(pic) unreference_pic(h, pic, 0);
+
+                h->long_ref[ mmco[i].long_arg ]= remove_short(h, frame_num);
+                if (h->long_ref[ mmco[i].long_arg ]){
+                    h->long_ref[ mmco[i].long_arg ]->long_ref=1;
+                    h->long_ref_count++;
+                }
             }
             break;
         case MMCO_LONG2UNUSED:
-            pic= remove_long(h, mmco[i].long_index);
-            if(pic)
-                unreference_pic(h, pic);
-            else if(s->avctx->debug&FF_DEBUG_MMCO)
-                av_log(h->s.avctx, AV_LOG_DEBUG, "mmco: remove_long() failure\n");
+            j = pic_num_extract(h, mmco[i].long_arg, &structure);
+            pic = h->long_ref[j];
+            if (pic) {
+                if (unreference_pic(h, pic, structure ^ PICT_FRAME))
+                    remove_long_at_index(h, j);
+            } else if(s->avctx->debug&FF_DEBUG_MMCO)
+                av_log(h->s.avctx, AV_LOG_DEBUG, "mmco: unref long failure\n");
             break;
         case MMCO_LONG:
-            pic= remove_long(h, mmco[i].long_index);
-            if(pic) unreference_pic(h, pic);
+            unref_pic = 1;
+            if (FIELD_PICTURE && !s->first_field) {
+                if (h->long_ref[mmco[i].long_arg] == s->current_picture_ptr) {
+                    /* Just mark second field as referenced */
+                    unref_pic = 0;
+                } else if (s->current_picture_ptr->reference) {
+                    /* First field in pair is in short term list or
+                     * at a different long term index.
+                     * This is not allowed; see 7.4.3, notes 2 and 3.
+                     * Report the problem and keep the pair where it is,
+                     * and mark this field valid.
+                     */
+                    av_log(h->s.avctx, AV_LOG_ERROR,
+                        "illegal long term reference assignment for second "
+                        "field in complementary field pair (first field is "
+                        "short term or has non-matching long index)\n");
+                    unref_pic = 0;
+                }
+            }
 
-            h->long_ref[ mmco[i].long_index ]= s->current_picture_ptr;
-            h->long_ref[ mmco[i].long_index ]->long_ref=1;
-            h->long_ref_count++;
+            if (unref_pic) {
+                pic= remove_long(h, mmco[i].long_arg);
+                if(pic) unreference_pic(h, pic, 0);
 
-            current_is_long=1;
+                h->long_ref[ mmco[i].long_arg ]= s->current_picture_ptr;
+                h->long_ref[ mmco[i].long_arg ]->long_ref=1;
+                h->long_ref_count++;
+            }
+
+            s->current_picture_ptr->reference |= s->picture_structure;
+            current_ref_assigned=1;
             break;
         case MMCO_SET_MAX_LONG:
-            assert(mmco[i].long_index <= 16);
+            assert(mmco[i].long_arg <= 16);
             // just remove the long term which index is greater than new max
-            for(j = mmco[i].long_index; j<16; j++){
+            for(j = mmco[i].long_arg; j<16; j++){
                 pic = remove_long(h, j);
-                if (pic) unreference_pic(h, pic);
+                if (pic) unreference_pic(h, pic, 0);
             }
             break;
         case MMCO_RESET:
             while(h->short_ref_count){
                 pic= remove_short(h, h->short_ref[0]->frame_num);
-                if(pic) unreference_pic(h, pic);
+                if(pic) unreference_pic(h, pic, 0);
             }
             for(j = 0; j < 16; j++) {
                 pic= remove_long(h, j);
-                if(pic) unreference_pic(h, pic);
+                if(pic) unreference_pic(h, pic, 0);
             }
             break;
         default: assert(0);
         }
     }
 
-    if(!current_is_long){
+    if (!current_ref_assigned && FIELD_PICTURE &&
+            !s->first_field && s->current_picture_ptr->reference) {
+
+        /* Second field of complementary field pair; the first field of
+         * which is already referenced. If short referenced, it
+         * should be first entry in short_ref. If not, it must exist
+         * in long_ref; trying to put it on the short list here is an
+         * error in the encoded bit stream (ref: 7.4.3, NOTE 2 and 3).
+         */
+        if (h->short_ref_count && h->short_ref[0] == s->current_picture_ptr) {
+            /* Just mark the second field valid */
+            s->current_picture_ptr->reference = PICT_FRAME;
+        } else if (s->current_picture_ptr->long_ref) {
+            av_log(h->s.avctx, AV_LOG_ERROR, "illegal short term reference "
+                                             "assignment for second field "
+                                             "in complementary field pair "
+                                             "(first field is long term)\n");
+        } else {
+            /*
+             * First field in reference, but not in any sensible place on our
+             * reference lists. This shouldn't happen unless reference
+             * handling somewhere else is wrong.
+             */
+            assert(0);
+        }
+        current_ref_assigned = 1;
+    }
+
+    if(!current_ref_assigned){
         pic= remove_short(h, s->current_picture_ptr->frame_num);
         if(pic){
-            unreference_pic(h, pic);
+            unreference_pic(h, pic, 0);
             av_log(h->s.avctx, AV_LOG_ERROR, "illegal short term buffer state detected\n");
         }
 
@@ -4023,8 +3597,34 @@
         h->short_ref[0]= s->current_picture_ptr;
         h->short_ref[0]->long_ref=0;
         h->short_ref_count++;
+        s->current_picture_ptr->reference |= s->picture_structure;
     }
 
+    if (h->long_ref_count + h->short_ref_count > h->sps.ref_frame_count){
+
+        /* We have too many reference frames, probably due to corrupted
+         * stream. Need to discard one frame. Prevents overrun of the
+         * short_ref and long_ref buffers.
+         */
+        av_log(h->s.avctx, AV_LOG_ERROR,
+               "number of reference frames exceeds max (probably "
+               "corrupt input), discarding one\n");
+
+        if (h->long_ref_count) {
+            for (i = 0; i < 16; ++i)
+                if (h->long_ref[i])
+                    break;
+
+            assert(i < 16);
+            pic = h->long_ref[i];
+            remove_long_at_index(h, i);
+        } else {
+            pic = h->short_ref[h->short_ref_count - 1];
+            remove_short_at_index(h, h->short_ref_count - 1);
+        }
+        unreference_pic(h, pic, 0);
+    }
+
     print_short_term(h);
     print_long_term(h);
     return 0;
@@ -4036,8 +3636,8 @@
 
     if(h->nal_unit_type == NAL_IDR_SLICE){ //FIXME fields
         s->broken_link= get_bits1(gb) -1;
-        h->mmco[0].long_index= get_bits1(gb) - 1; // current_long_term_idx
-        if(h->mmco[0].long_index == -1)
+        h->mmco[0].long_arg= get_bits1(gb) - 1; // current_long_term_idx
+        if(h->mmco[0].long_arg == -1)
             h->mmco_index= 0;
         else{
             h->mmco[0].opcode= MMCO_LONG;
@@ -4050,19 +3650,19 @@
 
                 h->mmco[i].opcode= opcode;
                 if(opcode==MMCO_SHORT2UNUSED || opcode==MMCO_SHORT2LONG){
-                    h->mmco[i].short_frame_num= (h->frame_num - get_ue_golomb(gb) - 1) & ((1<<h->sps.log2_max_frame_num)-1); //FIXME fields
-/*                    if(h->mmco[i].short_frame_num >= h->short_ref_count || h->short_ref[ h->mmco[i].short_frame_num ] == NULL){
+                    h->mmco[i].short_pic_num= (h->curr_pic_num - get_ue_golomb(gb) - 1) & (h->max_pic_num - 1);
+/*                    if(h->mmco[i].short_pic_num >= h->short_ref_count || h->short_ref[ h->mmco[i].short_pic_num ] == NULL){
                         av_log(s->avctx, AV_LOG_ERROR, "illegal short ref in memory management control operation %d\n", mmco);
                         return -1;
                     }*/
                 }
                 if(opcode==MMCO_SHORT2LONG || opcode==MMCO_LONG2UNUSED || opcode==MMCO_LONG || opcode==MMCO_SET_MAX_LONG){
-                    unsigned int long_index= get_ue_golomb(gb);
-                    if(/*h->mmco[i].long_index >= h->long_ref_count || h->long_ref[ h->mmco[i].long_index ] == NULL*/ long_index >= 16){
+                    unsigned int long_arg= get_ue_golomb(gb);
+                    if(long_arg >= 32 || (long_arg >= 16 && !(opcode == MMCO_LONG2UNUSED && FIELD_PICTURE))){
                         av_log(h->s.avctx, AV_LOG_ERROR, "illegal long ref in memory management control operation %d\n", opcode);
                         return -1;
                     }
-                    h->mmco[i].long_index= long_index;
+                    h->mmco[i].long_arg= long_arg;
                 }
 
                 if(opcode > (unsigned)MMCO_LONG){
@@ -4076,10 +3676,17 @@
         }else{
             assert(h->long_ref_count + h->short_ref_count <= h->sps.ref_frame_count);
 
-            if(h->long_ref_count + h->short_ref_count == h->sps.ref_frame_count){ //FIXME fields
+            if(h->short_ref_count && h->long_ref_count + h->short_ref_count == h->sps.ref_frame_count &&
+                    !(FIELD_PICTURE && !s->first_field && s->current_picture_ptr->reference)) {
                 h->mmco[0].opcode= MMCO_SHORT2UNUSED;
-                h->mmco[0].short_frame_num= h->short_ref[ h->short_ref_count - 1 ]->frame_num;
+                h->mmco[0].short_pic_num= h->short_ref[ h->short_ref_count - 1 ]->frame_num;
                 h->mmco_index= 1;
+                if (FIELD_PICTURE) {
+                    h->mmco[0].short_pic_num *= 2;
+                    h->mmco[1].opcode= MMCO_SHORT2UNUSED;
+                    h->mmco[1].short_pic_num= h->mmco[0].short_pic_num + 1;
+                    h->mmco_index= 2;
+                }
             }else
                 h->mmco_index= 0;
         }
@@ -4167,12 +3774,18 @@
         field_poc[1]= poc;
     }
 
-    if(s->picture_structure != PICT_BOTTOM_FIELD)
+    if(s->picture_structure != PICT_BOTTOM_FIELD) {
         s->current_picture_ptr->field_poc[0]= field_poc[0];
-    if(s->picture_structure != PICT_TOP_FIELD)
+        s->current_picture_ptr->poc = field_poc[0];
+    }
+    if(s->picture_structure != PICT_TOP_FIELD) {
         s->current_picture_ptr->field_poc[1]= field_poc[1];
-    if(s->picture_structure == PICT_FRAME) // FIXME field pix?
-        s->current_picture_ptr->poc= FFMIN(field_poc[0], field_poc[1]);
+        s->current_picture_ptr->poc = field_poc[1];
+    }
+    if(!FIELD_PICTURE || !s->first_field) {
+        Picture *cur = s->current_picture_ptr;
+        cur->poc= FFMIN(cur->field_poc[0], cur->field_poc[1]);
+    }
 
     return 0;
 }
@@ -4226,27 +3839,70 @@
         h->field_scan8x8_cavlc_q0  = h->field_scan8x8_cavlc;
     }
 }
+
 /**
+ * Replicates H264 "master" context to thread contexts.
+ */
+static void clone_slice(H264Context *dst, H264Context *src)
+{
+    memcpy(dst->block_offset,     src->block_offset, sizeof(dst->block_offset));
+    dst->s.current_picture_ptr  = src->s.current_picture_ptr;
+    dst->s.current_picture      = src->s.current_picture;
+    dst->s.linesize             = src->s.linesize;
+    dst->s.uvlinesize           = src->s.uvlinesize;
+    dst->s.first_field          = src->s.first_field;
+
+    dst->prev_poc_msb           = src->prev_poc_msb;
+    dst->prev_poc_lsb           = src->prev_poc_lsb;
+    dst->prev_frame_num_offset  = src->prev_frame_num_offset;
+    dst->prev_frame_num         = src->prev_frame_num;
+    dst->short_ref_count        = src->short_ref_count;
+
+    memcpy(dst->short_ref,        src->short_ref,        sizeof(dst->short_ref));
+    memcpy(dst->long_ref,         src->long_ref,         sizeof(dst->long_ref));
+    memcpy(dst->default_ref_list, src->default_ref_list, sizeof(dst->default_ref_list));
+    memcpy(dst->ref_list,         src->ref_list,         sizeof(dst->ref_list));
+
+    memcpy(dst->dequant4_coeff,   src->dequant4_coeff,   sizeof(src->dequant4_coeff));
+    memcpy(dst->dequant8_coeff,   src->dequant8_coeff,   sizeof(src->dequant8_coeff));
+}
+
+/**
  * decodes a slice header.
- * this will allso call MPV_common_init() and frame_start() as needed
+ * This will also call MPV_common_init() and frame_start() as needed.
+ *
+ * @param h h264context
+ * @param h0 h264 master context (differs from 'h' when doing sliced based parallel decoding)
+ *
+ * @return 0 if okay, <0 if an error occurred, 1 if decoding must not be multithreaded
  */
-static int decode_slice_header(H264Context *h){
+static int decode_slice_header(H264Context *h, H264Context *h0){
     MpegEncContext * const s = &h->s;
+    MpegEncContext * const s0 = &h0->s;
     unsigned int first_mb_in_slice;
     unsigned int pps_id;
     int num_ref_idx_active_override_flag;
-    static const uint8_t slice_type_map[5]= {P_TYPE, B_TYPE, I_TYPE, SP_TYPE, SI_TYPE};
-    unsigned int slice_type, tmp;
+    static const uint8_t slice_type_map[5]= {FF_P_TYPE, FF_B_TYPE, FF_I_TYPE, FF_SP_TYPE, FF_SI_TYPE};
+    unsigned int slice_type, tmp, i;
     int default_ref_list_done = 0;
+    int last_pic_structure;
 
-    s->current_picture.reference= h->nal_ref_idc != 0;
     s->dropable= h->nal_ref_idc == 0;
 
+    if((s->avctx->flags2 & CODEC_FLAG2_FAST) && !h->nal_ref_idc){
+        s->me.qpel_put= s->dsp.put_2tap_qpel_pixels_tab;
+        s->me.qpel_avg= s->dsp.avg_2tap_qpel_pixels_tab;
+    }else{
+        s->me.qpel_put= s->dsp.put_h264_qpel_pixels_tab;
+        s->me.qpel_avg= s->dsp.avg_h264_qpel_pixels_tab;
+    }
+
     first_mb_in_slice= get_ue_golomb(&s->gb);
 
     if((s->flags2 & CODEC_FLAG2_CHUNKS) && first_mb_in_slice == 0){
-        h->slice_num = 0;
-        s->current_picture_ptr= NULL;
+        h0->current_slice = 0;
+        if (!s0->first_field)
+            s->current_picture_ptr= NULL;
     }
 
     slice_type= get_ue_golomb(&s->gb);
@@ -4261,32 +3917,37 @@
         h->slice_type_fixed=0;
 
     slice_type= slice_type_map[ slice_type ];
-    if (slice_type == I_TYPE
-        || (h->slice_num != 0 && slice_type == h->slice_type) ) {
+    if (slice_type == FF_I_TYPE
+        || (h0->current_slice != 0 && slice_type == h0->last_slice_type) ) {
         default_ref_list_done = 1;
     }
     h->slice_type= slice_type;
 
     s->pict_type= h->slice_type; // to make a few old func happy, it's wrong though
+    if (s->pict_type == FF_B_TYPE && s0->last_picture_ptr == NULL) {
+        av_log(h->s.avctx, AV_LOG_ERROR,
+               "B picture before any references, skipping\n");
+        return -1;
+    }
 
     pps_id= get_ue_golomb(&s->gb);
     if(pps_id>=MAX_PPS_COUNT){
         av_log(h->s.avctx, AV_LOG_ERROR, "pps_id out of range\n");
         return -1;
     }
-    if(!h->pps_buffers[pps_id]) {
+    if(!h0->pps_buffers[pps_id]) {
         av_log(h->s.avctx, AV_LOG_ERROR, "non existing PPS referenced\n");
         return -1;
     }
-    h->pps= *h->pps_buffers[pps_id];
+    h->pps= *h0->pps_buffers[pps_id];
 
-    if(!h->sps_buffers[h->pps.sps_id]) {
+    if(!h0->sps_buffers[h->pps.sps_id]) {
         av_log(h->s.avctx, AV_LOG_ERROR, "non existing SPS referenced\n");
         return -1;
     }
-    h->sps = *h->sps_buffers[h->pps.sps_id];
+    h->sps = *h0->sps_buffers[h->pps.sps_id];
 
-    if(h->dequant_coeff_pps != pps_id){
+    if(h == h0 && h->dequant_coeff_pps != pps_id){
         h->dequant_coeff_pps = pps_id;
         init_dequant_tables(h);
     }
@@ -4297,24 +3958,44 @@
     h->b_stride=  s->mb_width*4;
     h->b8_stride= s->mb_width*2;
 
-    s->width = 16*s->mb_width - 2*(h->sps.crop_left + h->sps.crop_right );
+    s->width = 16*s->mb_width - 2*FFMIN(h->sps.crop_right, 7);
     if(h->sps.frame_mbs_only_flag)
-        s->height= 16*s->mb_height - 2*(h->sps.crop_top  + h->sps.crop_bottom);
+        s->height= 16*s->mb_height - 2*FFMIN(h->sps.crop_bottom, 7);
     else
-        s->height= 16*s->mb_height - 4*(h->sps.crop_top  + h->sps.crop_bottom); //FIXME recheck
+        s->height= 16*s->mb_height - 4*FFMIN(h->sps.crop_bottom, 3);
 
     if (s->context_initialized
         && (   s->width != s->avctx->width || s->height != s->avctx->height)) {
+        if(h != h0)
+            return -1;   // width / height changed during parallelized decoding
         free_tables(h);
         MPV_common_end(s);
     }
     if (!s->context_initialized) {
+        if(h != h0)
+            return -1;  // we cant (re-)initialize context during parallel decoding
         if (MPV_common_init(s) < 0)
             return -1;
+        s->first_field = 0;
 
         init_scan_tables(h);
         alloc_tables(h);
 
+        for(i = 1; i < s->avctx->thread_count; i++) {
+            H264Context *c;
+            c = h->thread_context[i] = av_malloc(sizeof(H264Context));
+            memcpy(c, h->s.thread_context[i], sizeof(MpegEncContext));
+            memset(&c->s + 1, 0, sizeof(H264Context) - sizeof(MpegEncContext));
+            c->sps = h->sps;
+            c->pps = h->pps;
+            init_scan_tables(c);
+            clone_tables(c, h);
+        }
+
+        for(i = 0; i < s->avctx->thread_count; i++)
+            if(context_init(h->thread_context[i]) < 0)
+                return -1;
+
         s->avctx->width = s->width;
         s->avctx->height = s->height;
         s->avctx->sample_aspect_ratio= h->sps.sar;
@@ -4330,42 +4011,90 @@
         }
     }
 
-    if(h->slice_num == 0){
-        if(frame_start(h) < 0)
-            return -1;
-    }
-
-    s->current_picture_ptr->frame_num= //FIXME frame_num cleanup
     h->frame_num= get_bits(&s->gb, h->sps.log2_max_frame_num);
 
     h->mb_mbaff = 0;
     h->mb_aff_frame = 0;
+    last_pic_structure = s0->picture_structure;
     if(h->sps.frame_mbs_only_flag){
         s->picture_structure= PICT_FRAME;
     }else{
         if(get_bits1(&s->gb)) { //field_pic_flag
             s->picture_structure= PICT_TOP_FIELD + get_bits1(&s->gb); //bottom_field_flag
-            av_log(h->s.avctx, AV_LOG_ERROR, "PAFF interlacing is not implemented\n");
         } else {
             s->picture_structure= PICT_FRAME;
             h->mb_aff_frame = h->sps.mb_aff;
         }
     }
+
+    if(h0->current_slice == 0){
+        /* See if we have a decoded first field looking for a pair... */
+        if (s0->first_field) {
+            assert(s0->current_picture_ptr);
+            assert(s0->current_picture_ptr->data[0]);
+            assert(s0->current_picture_ptr->reference != DELAYED_PIC_REF);
+
+            /* figure out if we have a complementary field pair */
+            if (!FIELD_PICTURE || s->picture_structure == last_pic_structure) {
+                /*
+                 * Previous field is unmatched. Don't display it, but let it
+                 * remain for reference if marked as such.
+                 */
+                s0->current_picture_ptr = NULL;
+                s0->first_field = FIELD_PICTURE;
+
+            } else {
+                if (h->nal_ref_idc &&
+                        s0->current_picture_ptr->reference &&
+                        s0->current_picture_ptr->frame_num != h->frame_num) {
+                    /*
+                     * This and previous field were reference, but had
+                     * different frame_nums. Consider this field first in
+                     * pair. Throw away previous field except for reference
+                     * purposes.
+                     */
+                    s0->first_field = 1;
+                    s0->current_picture_ptr = NULL;
+
+                } else {
+                    /* Second field in complementary pair */
+                    s0->first_field = 0;
+                }
+            }
+
+        } else {
+            /* Frame or first field in a potentially complementary pair */
+            assert(!s0->current_picture_ptr);
+            s0->first_field = FIELD_PICTURE;
+        }
+
+        if((!FIELD_PICTURE || s0->first_field) && frame_start(h) < 0) {
+            s0->first_field = 0;
+            return -1;
+        }
+    }
+    if(h != h0)
+        clone_slice(h, h0);
+
+    s->current_picture_ptr->frame_num= h->frame_num; //FIXME frame_num cleanup
+
     assert(s->mb_num == s->mb_width * s->mb_height);
-    if(first_mb_in_slice << h->mb_aff_frame >= s->mb_num ||
+    if(first_mb_in_slice << FIELD_OR_MBAFF_PICTURE >= s->mb_num ||
        first_mb_in_slice                    >= s->mb_num){
         av_log(h->s.avctx, AV_LOG_ERROR, "first_mb_in_slice overflow\n");
         return -1;
     }
     s->resync_mb_x = s->mb_x = first_mb_in_slice % s->mb_width;
-    s->resync_mb_y = s->mb_y = (first_mb_in_slice / s->mb_width) << h->mb_aff_frame;
+    s->resync_mb_y = s->mb_y = (first_mb_in_slice / s->mb_width) << FIELD_OR_MBAFF_PICTURE;
+    if (s->picture_structure == PICT_BOTTOM_FIELD)
+        s->resync_mb_y = s->mb_y = s->mb_y + 1;
     assert(s->mb_y < s->mb_height);
 
     if(s->picture_structure==PICT_FRAME){
         h->curr_pic_num=   h->frame_num;
         h->max_pic_num= 1<< h->sps.log2_max_frame_num;
     }else{
-        h->curr_pic_num= 2*h->frame_num;
+        h->curr_pic_num= 2*h->frame_num + 1;
         h->max_pic_num= 1<<(h->sps.log2_max_frame_num + 1);
     }
 
@@ -4398,17 +4127,17 @@
     h->ref_count[0]= h->pps.ref_count[0];
     h->ref_count[1]= h->pps.ref_count[1];
 
-    if(h->slice_type == P_TYPE || h->slice_type == SP_TYPE || h->slice_type == B_TYPE){
-        if(h->slice_type == B_TYPE){
+    if(h->slice_type == FF_P_TYPE || h->slice_type == FF_SP_TYPE || h->slice_type == FF_B_TYPE){
+        if(h->slice_type == FF_B_TYPE){
             h->direct_spatial_mv_pred= get_bits1(&s->gb);
-            if(h->sps.mb_aff && h->direct_spatial_mv_pred)
-                av_log(h->s.avctx, AV_LOG_ERROR, "MBAFF + spatial direct mode is not implemented\n");
+            if(FIELD_PICTURE && h->direct_spatial_mv_pred)
+                av_log(h->s.avctx, AV_LOG_ERROR, "PAFF + spatial direct mode is not implemented\n");
         }
         num_ref_idx_active_override_flag= get_bits1(&s->gb);
 
         if(num_ref_idx_active_override_flag){
             h->ref_count[0]= get_ue_golomb(&s->gb) + 1;
-            if(h->slice_type==B_TYPE)
+            if(h->slice_type==FF_B_TYPE)
                 h->ref_count[1]= get_ue_golomb(&s->gb) + 1;
 
             if(h->ref_count[0]-1 > 32-1 || h->ref_count[1]-1 > 32-1){
@@ -4417,7 +4146,7 @@
                 return -1;
             }
         }
-        if(h->slice_type == B_TYPE)
+        if(h->slice_type == FF_B_TYPE)
             h->list_count= 2;
         else
             h->list_count= 1;
@@ -4431,21 +4160,21 @@
     if(decode_ref_pic_list_reordering(h) < 0)
         return -1;
 
-    if(   (h->pps.weighted_pred          && (h->slice_type == P_TYPE || h->slice_type == SP_TYPE ))
-       || (h->pps.weighted_bipred_idc==1 && h->slice_type==B_TYPE ) )
+    if(   (h->pps.weighted_pred          && (h->slice_type == FF_P_TYPE || h->slice_type == FF_SP_TYPE ))
+       || (h->pps.weighted_bipred_idc==1 && h->slice_type==FF_B_TYPE ) )
         pred_weight_table(h);
-    else if(h->pps.weighted_bipred_idc==2 && h->slice_type==B_TYPE)
+    else if(h->pps.weighted_bipred_idc==2 && h->slice_type==FF_B_TYPE)
         implicit_weight_table(h);
     else
         h->use_weight = 0;
 
-    if(s->current_picture.reference)
-        decode_ref_pic_marking(h, &s->gb);
+    if(h->nal_ref_idc)
+        decode_ref_pic_marking(h0, &s->gb);
 
     if(FRAME_MBAFF)
         fill_mbaff_ref_list(h);
 
-    if( h->slice_type != I_TYPE && h->slice_type != SI_TYPE && h->pps.cabac ){
+    if( h->slice_type != FF_I_TYPE && h->slice_type != FF_SI_TYPE && h->pps.cabac ){
         tmp = get_ue_golomb(&s->gb);
         if(tmp > 2){
             av_log(s->avctx, AV_LOG_ERROR, "cabac_init_idc overflow\n");
@@ -4464,10 +4193,10 @@
     h->chroma_qp[0] = get_chroma_qp(h, 0, s->qscale);
     h->chroma_qp[1] = get_chroma_qp(h, 1, s->qscale);
     //FIXME qscale / qp ... stuff
-    if(h->slice_type == SP_TYPE){
+    if(h->slice_type == FF_SP_TYPE){
         get_bits1(&s->gb); /* sp_for_switch_flag */
     }
-    if(h->slice_type==SP_TYPE || h->slice_type == SI_TYPE){
+    if(h->slice_type==FF_SP_TYPE || h->slice_type == FF_SI_TYPE){
         get_se_golomb(&s->gb); /* slice_qs_delta */
     }
 
@@ -4489,24 +4218,42 @@
             h->slice_beta_offset = get_se_golomb(&s->gb) << 1;
         }
     }
+
     if(   s->avctx->skip_loop_filter >= AVDISCARD_ALL
-       ||(s->avctx->skip_loop_filter >= AVDISCARD_NONKEY && h->slice_type != I_TYPE)
-       ||(s->avctx->skip_loop_filter >= AVDISCARD_BIDIR  && h->slice_type == B_TYPE)
+       ||(s->avctx->skip_loop_filter >= AVDISCARD_NONKEY && h->slice_type != FF_I_TYPE)
+       ||(s->avctx->skip_loop_filter >= AVDISCARD_BIDIR  && h->slice_type == FF_B_TYPE)
        ||(s->avctx->skip_loop_filter >= AVDISCARD_NONREF && h->nal_ref_idc == 0))
         h->deblocking_filter= 0;
 
+    if(h->deblocking_filter == 1 && h0->max_contexts > 1) {
+        if(s->avctx->flags2 & CODEC_FLAG2_FAST) {
+            /* Cheat slightly for speed:
+               Do not bother to deblock across slices. */
+            h->deblocking_filter = 2;
+        } else {
+            h0->max_contexts = 1;
+            if(!h0->single_decode_warning) {
+                av_log(s->avctx, AV_LOG_INFO, "Cannot parallelize deblocking type 1, decoding such frames in sequential order\n");
+                h0->single_decode_warning = 1;
+            }
+            if(h != h0)
+                return 1; // deblocking switched inside frame
+        }
+    }
+
 #if 0 //FMO
     if( h->pps.num_slice_groups > 1  && h->pps.mb_slice_group_map_type >= 3 && h->pps.mb_slice_group_map_type <= 5)
         slice_group_change_cycle= get_bits(&s->gb, ?);
 #endif
 
-    h->slice_num++;
+    h0->last_slice_type = slice_type;
+    h->slice_num = ++h0->current_slice;
 
     h->emu_edge_width= (s->flags&CODEC_FLAG_EMU_EDGE) ? 0 : 16;
-    h->emu_edge_height= FRAME_MBAFF ? 0 : h->emu_edge_width;
+    h->emu_edge_height= (FRAME_MBAFF || FIELD_PICTURE) ? 0 : h->emu_edge_width;
 
     if(s->avctx->debug&FF_DEBUG_PICT_INFO){
-        av_log(h->s.avctx, AV_LOG_DEBUG, "slice:%d %s mb:%d %c pps:%u frame:%d poc:%d/%d ref:%d/%d qp:%d loop:%d:%d:%d weight:%d%s\n",
+        av_log(h->s.avctx, AV_LOG_DEBUG, "slice:%d %s mb:%d %c pps:%u frame:%d poc:%d/%d ref:%d/%d qp:%d loop:%d:%d:%d weight:%d%s %s\n",
                h->slice_num,
                (s->picture_structure==PICT_FRAME ? "F" : s->picture_structure==PICT_TOP_FIELD ? "T" : "B"),
                first_mb_in_slice,
@@ -4517,18 +4264,11 @@
                s->qscale,
                h->deblocking_filter, h->slice_alpha_c0_offset/2, h->slice_beta_offset/2,
                h->use_weight,
-               h->use_weight==1 && h->use_weight_chroma ? "c" : ""
+               h->use_weight==1 && h->use_weight_chroma ? "c" : "",
+               h->slice_type == FF_B_TYPE ? (h->direct_spatial_mv_pred ? "SPAT" : "TEMP") : ""
                );
     }
 
-    if((s->avctx->flags2 & CODEC_FLAG2_FAST) && !s->current_picture.reference){
-        s->me.qpel_put= s->dsp.put_2tap_qpel_pixels_tab;
-        s->me.qpel_avg= s->dsp.avg_2tap_qpel_pixels_tab;
-    }else{
-        s->me.qpel_put= s->dsp.put_h264_qpel_pixels_tab;
-        s->me.qpel_avg= s->dsp.avg_h264_qpel_pixels_tab;
-    }
-
     return 0;
 }
 
@@ -4570,7 +4310,7 @@
  * @param n block index
  * @param scantable scantable
  * @param max_coeff number of coefficients in the block
- * @return <0 if an error occured
+ * @return <0 if an error occurred
  */
 static int decode_residual(H264Context *h, GetBitContext *gb, DCTELEM *block, int n, const uint8_t *scantable, const uint32_t *qmul, int max_coeff){
     MpegEncContext * const s = &h->s;
@@ -4629,12 +4369,11 @@
                 level_code= (prefix<<suffix_length) + get_bits(gb, suffix_length); //part
             else
                 level_code= prefix + get_bits(gb, 4); //part
-        }else if(prefix==15){
-            level_code= (prefix<<suffix_length) + get_bits(gb, 12); //part
-            if(suffix_length==0) level_code+=15; //FIXME doesn't make (much)sense
         }else{
-            av_log(h->s.avctx, AV_LOG_ERROR, "prefix too large at %d %d\n", s->mb_x, s->mb_y);
-            return -1;
+            level_code= (15<<suffix_length) + get_bits(gb, prefix-3); //part
+            if(suffix_length==0) level_code+=15; //FIXME doesn't make (much)sense
+            if(prefix>=16)
+                level_code += (1<<(prefix-3))-4096;
         }
 
         if(trailing_ones < 3) level_code += 2;
@@ -4652,11 +4391,10 @@
             prefix = get_level_prefix(gb);
             if(prefix<15){
                 level_code = (prefix<<suffix_length) + get_bits(gb, suffix_length);
-            }else if(prefix==15){
-                level_code =  (prefix<<suffix_length) + get_bits(gb, 12);
             }else{
-                av_log(h->s.avctx, AV_LOG_ERROR, "prefix too large at %d %d\n", s->mb_x, s->mb_y);
-                return -1;
+                level_code = (15<<suffix_length) + get_bits(gb, prefix-3);
+                if(prefix>=16)
+                    level_code += (1<<(prefix-3))-4096;
             }
             mask= -(level_code&1);
             level[i]= (((2+level_code)>>1) ^ mask) - mask;
@@ -4720,7 +4458,7 @@
 
 static void predict_field_decoding_flag(H264Context *h){
     MpegEncContext * const s = &h->s;
-    const int mb_xy= s->mb_x + s->mb_y*s->mb_stride;
+    const int mb_xy= h->mb_xy;
     int mb_type = (h->slice_table[mb_xy-1] == h->slice_num)
                 ? s->current_picture.mb_type[mb_xy-1]
                 : (h->slice_table[mb_xy-s->mb_stride] == h->slice_num)
@@ -4734,7 +4472,7 @@
  */
 static void decode_mb_skip(H264Context *h){
     MpegEncContext * const s = &h->s;
-    const int mb_xy= s->mb_x + s->mb_y*s->mb_stride;
+    const int mb_xy= h->mb_xy;
     int mb_type=0;
 
     memset(h->non_zero_count[mb_xy], 0, 16);
@@ -4743,7 +4481,7 @@
     if(MB_FIELD)
         mb_type|= MB_TYPE_INTERLACED;
 
-    if( h->slice_type == B_TYPE )
+    if( h->slice_type == FF_B_TYPE )
     {
         // just for fill_caches. pred_direct_motion will set the real mb_type
         mb_type|= MB_TYPE_16x16|MB_TYPE_P0L0|MB_TYPE_P0L1|MB_TYPE_DIRECT2|MB_TYPE_SKIP;
@@ -4776,17 +4514,19 @@
  */
 static int decode_mb_cavlc(H264Context *h){
     MpegEncContext * const s = &h->s;
-    const int mb_xy= s->mb_x + s->mb_y*s->mb_stride;
+    int mb_xy;
     int partition_count;
     unsigned int mb_type, cbp;
     int dct8x8_allowed= h->pps.transform_8x8_mode;
 
+    mb_xy = h->mb_xy = s->mb_x + s->mb_y*s->mb_stride;
+
     s->dsp.clear_blocks(h->mb); //FIXME avoid if already clear (move after skip handlong?
 
     tprintf(s->avctx, "pic:%d mb:%d/%d\n", h->frame_num, s->mb_x, s->mb_y);
     cbp = 0; /* avoid warning. FIXME: find a solution without slowing
                 down the code */
-    if(h->slice_type != I_TYPE && h->slice_type != SI_TYPE){
+    if(h->slice_type != FF_I_TYPE && h->slice_type != FF_SI_TYPE){
         if(s->mb_skip_run==-1)
             s->mb_skip_run= get_ue_golomb(&s->gb);
 
@@ -4810,7 +4550,7 @@
     h->prev_mb_skipped= 0;
 
     mb_type= get_ue_golomb(&s->gb);
-    if(h->slice_type == B_TYPE){
+    if(h->slice_type == FF_B_TYPE){
         if(mb_type < 23){
             partition_count= b_mb_type_info[mb_type].partition_count;
             mb_type=         b_mb_type_info[mb_type].type;
@@ -4818,7 +4558,7 @@
             mb_type -= 23;
             goto decode_intra_mb;
         }
-    }else if(h->slice_type == P_TYPE /*|| h->slice_type == SP_TYPE */){
+    }else if(h->slice_type == FF_P_TYPE /*|| h->slice_type == FF_SP_TYPE */){
         if(mb_type < 5){
             partition_count= p_mb_type_info[mb_type].partition_count;
             mb_type=         p_mb_type_info[mb_type].type;
@@ -4827,7 +4567,7 @@
             goto decode_intra_mb;
         }
     }else{
-       assert(h->slice_type == I_TYPE);
+       assert(h->slice_type == FF_I_TYPE);
 decode_intra_mb:
         if(mb_type > 25){
             av_log(h->s.avctx, AV_LOG_ERROR, "mb_type %d in %c slice too large at %d %d\n", mb_type, av_get_pict_type_char(h->slice_type), s->mb_x, s->mb_y);
@@ -4933,7 +4673,7 @@
     }else if(partition_count==4){
         int i, j, sub_partition_count[4], list, ref[2][4];
 
-        if(h->slice_type == B_TYPE){
+        if(h->slice_type == FF_B_TYPE){
             for(i=0; i<4; i++){
                 h->sub_mb_type[i]= get_ue_golomb(&s->gb);
                 if(h->sub_mb_type[i] >=13){
@@ -4952,7 +4692,7 @@
                 h->ref_cache[1][scan8[12]] = PART_NOT_AVAILABLE;
             }
         }else{
-            assert(h->slice_type == P_TYPE || h->slice_type == SP_TYPE); //FIXME SP correct ?
+            assert(h->slice_type == FF_P_TYPE || h->slice_type == FF_SP_TYPE); //FIXME SP correct ?
             for(i=0; i<4; i++){
                 h->sub_mb_type[i]= get_ue_golomb(&s->gb);
                 if(h->sub_mb_type[i] >=4){
@@ -5323,9 +5063,9 @@
 static int decode_cabac_mb_type( H264Context *h ) {
     MpegEncContext * const s = &h->s;
 
-    if( h->slice_type == I_TYPE ) {
+    if( h->slice_type == FF_I_TYPE ) {
         return decode_cabac_intra_mb_type(h, 3, 1);
-    } else if( h->slice_type == P_TYPE ) {
+    } else if( h->slice_type == FF_P_TYPE ) {
         if( get_cabac_noinline( &h->cabac, &h->cabac_state[14] ) == 0 ) {
             /* P-type */
             if( get_cabac_noinline( &h->cabac, &h->cabac_state[15] ) == 0 ) {
@@ -5338,7 +5078,7 @@
         } else {
             return decode_cabac_intra_mb_type(h, 17, 0) + 5;
         }
-    } else if( h->slice_type == B_TYPE ) {
+    } else if( h->slice_type == FF_B_TYPE ) {
         const int mba_xy = h->left_mb_xy[0];
         const int mbb_xy = h->top_mb_xy;
         int ctx = 0;
@@ -5398,9 +5138,9 @@
         }else
             mbb_xy = mb_x + (mb_y-1)*s->mb_stride;
     }else{
-        int mb_xy = mb_x + mb_y*s->mb_stride;
+        int mb_xy = h->mb_xy;
         mba_xy = mb_xy - 1;
-        mbb_xy = mb_xy - s->mb_stride;
+        mbb_xy = mb_xy - (s->mb_stride << FIELD_PICTURE);
     }
 
     if( h->slice_table[mba_xy] == h->slice_num && !IS_SKIP( s->current_picture.mb_type[mba_xy] ))
@@ -5408,7 +5148,7 @@
     if( h->slice_table[mbb_xy] == h->slice_num && !IS_SKIP( s->current_picture.mb_type[mbb_xy] ))
         ctx++;
 
-    if( h->slice_type == B_TYPE )
+    if( h->slice_type == FF_B_TYPE )
         ctx += 13;
     return get_cabac_noinline( &h->cabac, &h->cabac_state[11+ctx] );
 }
@@ -5453,65 +5193,20 @@
         return 3;
 }
 
-static const uint8_t block_idx_x[16] = {
-    0, 1, 0, 1, 2, 3, 2, 3, 0, 1, 0, 1, 2, 3, 2, 3
-};
-static const uint8_t block_idx_y[16] = {
-    0, 0, 1, 1, 0, 0, 1, 1, 2, 2, 3, 3, 2, 2, 3, 3
-};
-static const uint8_t block_idx_xy[4][4] = {
-    { 0, 2, 8,  10},
-    { 1, 3, 9,  11},
-    { 4, 6, 12, 14},
-    { 5, 7, 13, 15}
-};
-
 static int decode_cabac_mb_cbp_luma( H264Context *h) {
-    int cbp = 0;
-    int cbp_b = -1;
-    int i8x8;
+    int cbp_b, cbp_a, ctx, cbp = 0;
 
-    if( h->slice_table[h->top_mb_xy] == h->slice_num ) {
-        cbp_b = h->top_cbp;
-        tprintf(h->s.avctx, "cbp_b = top_cbp = %x\n", cbp_b);
-    }
+    cbp_a = h->slice_table[h->left_mb_xy[0]] == h->slice_num ? h->left_cbp : -1;
+    cbp_b = h->slice_table[h->top_mb_xy]     == h->slice_num ? h->top_cbp  : -1;
 
-    for( i8x8 = 0; i8x8 < 4; i8x8++ ) {
-        int cbp_a = -1;
-        int x, y;
-        int ctx = 0;
-
-        x = block_idx_x[4*i8x8];
-        y = block_idx_y[4*i8x8];
-
-        if( x > 0 )
-            cbp_a = cbp;
-        else if( h->slice_table[h->left_mb_xy[0]] == h->slice_num ) {
-            cbp_a = h->left_cbp;
-            tprintf(h->s.avctx, "cbp_a = left_cbp = %x\n", cbp_a);
-        }
-
-        if( y > 0 )
-            cbp_b = cbp;
-
-        /* No need to test for skip as we put 0 for skip block */
-        /* No need to test for IPCM as we put 1 for IPCM block */
-        if( cbp_a >= 0 ) {
-            int i8x8a = block_idx_xy[(x-1)&0x03][y]/4;
-            if( ((cbp_a >> i8x8a)&0x01) == 0 )
-                ctx++;
-        }
-
-        if( cbp_b >= 0 ) {
-            int i8x8b = block_idx_xy[x][(y-1)&0x03]/4;
-            if( ((cbp_b >> i8x8b)&0x01) == 0 )
-                ctx += 2;
-        }
-
-        if( get_cabac( &h->cabac, &h->cabac_state[73 + ctx] ) ) {
-            cbp |= 1 << i8x8;
-        }
-    }
+    ctx = !(cbp_a & 0x02) + 2 * !(cbp_b & 0x04);
+    cbp |= get_cabac_noinline(&h->cabac, &h->cabac_state[73 + ctx]);
+    ctx = !(cbp   & 0x01) + 2 * !(cbp_b & 0x08);
+    cbp |= get_cabac_noinline(&h->cabac, &h->cabac_state[73 + ctx]) << 1;
+    ctx = !(cbp_a & 0x08) + 2 * !(cbp   & 0x01);
+    cbp |= get_cabac_noinline(&h->cabac, &h->cabac_state[73 + ctx]) << 2;
+    ctx = !(cbp   & 0x04) + 2 * !(cbp   & 0x02);
+    cbp |= get_cabac_noinline(&h->cabac, &h->cabac_state[73 + ctx]) << 3;
     return cbp;
 }
 static int decode_cabac_mb_cbp_chroma( H264Context *h) {
@@ -5533,16 +5228,9 @@
     return 1 + get_cabac_noinline( &h->cabac, &h->cabac_state[77 + ctx] );
 }
 static int decode_cabac_mb_dqp( H264Context *h) {
-    MpegEncContext * const s = &h->s;
-    int mbn_xy;
     int   ctx = 0;
     int   val = 0;
 
-    if( s->mb_x > 0 )
-        mbn_xy = s->mb_x + s->mb_y*s->mb_stride - 1;
-    else
-        mbn_xy = s->mb_width - 1 + (s->mb_y-1)*s->mb_stride;
-
     if( h->last_qscale_diff != 0 )
         ctx++;
 
@@ -5597,7 +5285,7 @@
     int ref  = 0;
     int ctx  = 0;
 
-    if( h->slice_type == B_TYPE) {
+    if( h->slice_type == FF_B_TYPE) {
         if( refa > 0 && !h->direct_cache[scan8[n] - 1] )
             ctx++;
         if( refb > 0 && !h->direct_cache[scan8[n] - 8] )
@@ -5665,23 +5353,27 @@
     return get_cabac_bypass_sign( &h->cabac, -mvd );
 }
 
-static inline int get_cabac_cbf_ctx( H264Context *h, int cat, int idx ) {
+static av_always_inline int get_cabac_cbf_ctx( H264Context *h, int cat, int idx, int is_dc ) {
     int nza, nzb;
     int ctx = 0;
 
-    if( cat == 0 ) {
-        nza = h->left_cbp&0x100;
-        nzb = h-> top_cbp&0x100;
-    } else if( cat == 1 || cat == 2 ) {
-        nza = h->non_zero_count_cache[scan8[idx] - 1];
-        nzb = h->non_zero_count_cache[scan8[idx] - 8];
-    } else if( cat == 3 ) {
-        nza = (h->left_cbp>>(6+idx))&0x01;
-        nzb = (h-> top_cbp>>(6+idx))&0x01;
+    if( is_dc ) {
+        if( cat == 0 ) {
+            nza = h->left_cbp&0x100;
+            nzb = h-> top_cbp&0x100;
+        } else {
+            nza = (h->left_cbp>>(6+idx))&0x01;
+            nzb = (h-> top_cbp>>(6+idx))&0x01;
+        }
     } else {
-        assert(cat == 4);
-        nza = h->non_zero_count_cache[scan8[16+idx] - 1];
-        nzb = h->non_zero_count_cache[scan8[16+idx] - 8];
+        if( cat == 4 ) {
+            nza = h->non_zero_count_cache[scan8[16+idx] - 1];
+            nzb = h->non_zero_count_cache[scan8[16+idx] - 8];
+        } else {
+            assert(cat == 1 || cat == 2);
+            nza = h->non_zero_count_cache[scan8[idx] - 1];
+            nzb = h->non_zero_count_cache[scan8[idx] - 8];
+        }
     }
 
     if( nza > 0 )
@@ -5693,15 +5385,14 @@
     return ctx + 4 * cat;
 }
 
-static const attribute_used uint8_t last_coeff_flag_offset_8x8[63] = {
+DECLARE_ASM_CONST(1, uint8_t, last_coeff_flag_offset_8x8[63]) = {
     0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
     2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
     3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4,
     5, 5, 5, 5, 6, 6, 6, 6, 7, 7, 7, 7, 8, 8, 8
 };
 
-static int decode_cabac_residual( H264Context *h, DCTELEM *block, int cat, int n, const uint8_t *scantable, const uint32_t *qmul, int max_coeff) {
-    const int mb_xy  = h->s.mb_x + h->s.mb_y*h->s.mb_stride;
+static av_always_inline void decode_cabac_residual_internal( H264Context *h, DCTELEM *block, int cat, int n, const uint8_t *scantable, const uint32_t *qmul, int max_coeff, int is_dc ) {
     static const int significant_coeff_flag_offset[2][6] = {
       { 105+0, 105+15, 105+29, 105+44, 105+47, 402 },
       { 277+0, 277+15, 277+29, 277+44, 277+47, 436 }
@@ -5723,15 +5414,25 @@
         9, 9,10,10, 8,11,12,11, 9, 9,10,10, 8,13,13, 9,
         9,10,10, 8,13,13, 9, 9,10,10,14,14,14,14,14 }
     };
+    /* node ctx: 0..3: abslevel1 (with abslevelgt1 == 0).
+     * 4..7: abslevelgt1 + 3 (and abslevel1 doesn't matter).
+     * map node ctx => cabac ctx for level=1 */
+    static const uint8_t coeff_abs_level1_ctx[8] = { 1, 2, 3, 4, 0, 0, 0, 0 };
+    /* map node ctx => cabac ctx for level>1 */
+    static const uint8_t coeff_abs_levelgt1_ctx[8] = { 5, 5, 5, 5, 6, 7, 8, 9 };
+    static const uint8_t coeff_abs_level_transition[2][8] = {
+    /* update node ctx after decoding a level=1 */
+        { 1, 2, 3, 3, 4, 5, 6, 7 },
+    /* update node ctx after decoding a level>1 */
+        { 4, 4, 4, 4, 5, 6, 7, 7 }
+    };
 
     int index[64];
 
     int av_unused last;
     int coeff_count = 0;
+    int node_ctx = 0;
 
-    int abslevel1 = 1;
-    int abslevelgt1 = 0;
-
     uint8_t *significant_coeff_ctx_base;
     uint8_t *last_coeff_ctx_base;
     uint8_t *abs_level_m1_ctx_base;
@@ -5759,18 +5460,21 @@
      */
 
     /* read coded block flag */
-    if( cat != 5 ) {
-        if( get_cabac( CC, &h->cabac_state[85 + get_cabac_cbf_ctx( h, cat, n ) ] ) == 0 ) {
-            if( cat == 1 || cat == 2 )
-                h->non_zero_count_cache[scan8[n]] = 0;
-            else if( cat == 4 )
-                h->non_zero_count_cache[scan8[16+n]] = 0;
+    if( is_dc || cat != 5 ) {
+        if( get_cabac( CC, &h->cabac_state[85 + get_cabac_cbf_ctx( h, cat, n, is_dc ) ] ) == 0 ) {
+            if( !is_dc ) {
+                if( cat == 4 )
+                    h->non_zero_count_cache[scan8[16+n]] = 0;
+                else
+                    h->non_zero_count_cache[scan8[n]] = 0;
+            }
+
 #ifdef CABAC_ON_STACK
             h->cabac.range     = cc.range     ;
             h->cabac.low       = cc.low       ;
             h->cabac.bytestream= cc.bytestream;
 #endif
-            return 0;
+            return;
         }
     }
 
@@ -5781,7 +5485,7 @@
     abs_level_m1_ctx_base = h->cabac_state
         + coeff_abs_level_m1_offset[cat];
 
-    if( cat == 5 ) {
+    if( !is_dc && cat == 5 ) {
 #define DECODE_SIGNIFICANCE( coefs, sig_off, last_off ) \
         for(last= 0; last < coefs; last++) { \
             uint8_t *sig_ctx = significant_coeff_ctx_base + sig_off; \
@@ -5798,7 +5502,7 @@
             index[coeff_count++] = last;\
         }
         const uint8_t *sig_off = significant_coeff_flag_offset_8x8[MB_FIELD];
-#if defined(ARCH_X86) && defined(CONFIG_7REGS) && defined(HAVE_EBX_AVAILABLE) && !defined(BROKEN_RELOCATIONS)
+#if defined(ARCH_X86) && defined(HAVE_7REGS) && defined(HAVE_EBX_AVAILABLE) && !defined(BROKEN_RELOCATIONS)
         coeff_count= decode_significance_8x8_x86(CC, significant_coeff_ctx_base, index, sig_off);
     } else {
         coeff_count= decode_significance_x86(CC, max_coeff, significant_coeff_ctx_base, index);
@@ -5810,34 +5514,39 @@
     }
     assert(coeff_count > 0);
 
-    if( cat == 0 )
-        h->cbp_table[mb_xy] |= 0x100;
-    else if( cat == 1 || cat == 2 )
-        h->non_zero_count_cache[scan8[n]] = coeff_count;
-    else if( cat == 3 )
-        h->cbp_table[mb_xy] |= 0x40 << n;
-    else if( cat == 4 )
-        h->non_zero_count_cache[scan8[16+n]] = coeff_count;
-    else {
-        assert( cat == 5 );
-        fill_rectangle(&h->non_zero_count_cache[scan8[n]], 2, 2, 8, coeff_count, 1);
+    if( is_dc ) {
+        if( cat == 0 )
+            h->cbp_table[h->mb_xy] |= 0x100;
+        else
+            h->cbp_table[h->mb_xy] |= 0x40 << n;
+    } else {
+        if( cat == 5 )
+            fill_rectangle(&h->non_zero_count_cache[scan8[n]], 2, 2, 8, coeff_count, 1);
+        else if( cat == 4 )
+            h->non_zero_count_cache[scan8[16+n]] = coeff_count;
+        else {
+            assert( cat == 1 || cat == 2 );
+            h->non_zero_count_cache[scan8[n]] = coeff_count;
+        }
     }
 
-    for( coeff_count--; coeff_count >= 0; coeff_count-- ) {
-        uint8_t *ctx = (abslevelgt1 != 0 ? 0 : FFMIN( 4, abslevel1 )) + abs_level_m1_ctx_base;
+    while( coeff_count-- ) {
+        uint8_t *ctx = coeff_abs_level1_ctx[node_ctx] + abs_level_m1_ctx_base;
+
         int j= scantable[index[coeff_count]];
 
         if( get_cabac( CC, ctx ) == 0 ) {
-            if( !qmul ) {
+            node_ctx = coeff_abs_level_transition[0][node_ctx];
+            if( is_dc ) {
                 block[j] = get_cabac_bypass_sign( CC, -1);
             }else{
-                block[j] = (get_cabac_bypass_sign( CC, -qmul[j]) + 32) >> 6;;
+                block[j] = (get_cabac_bypass_sign( CC, -qmul[j]) + 32) >> 6;
             }
-
-            abslevel1++;
         } else {
             int coeff_abs = 2;
-            ctx = 5 + FFMIN( 4, abslevelgt1 ) + abs_level_m1_ctx_base;
+            ctx = coeff_abs_levelgt1_ctx[node_ctx] + abs_level_m1_ctx_base;
+            node_ctx = coeff_abs_level_transition[1][node_ctx];
+
             while( coeff_abs < 15 && get_cabac( CC, ctx ) ) {
                 coeff_abs++;
             }
@@ -5855,15 +5564,11 @@
                 coeff_abs+= 14;
             }
 
-            if( !qmul ) {
-                if( get_cabac_bypass( CC ) ) block[j] = -coeff_abs;
-                else                                block[j] =  coeff_abs;
+            if( is_dc ) {
+                block[j] = get_cabac_bypass_sign( CC, -coeff_abs );
             }else{
-                if( get_cabac_bypass( CC ) ) block[j] = (-coeff_abs * qmul[j] + 32) >> 6;
-                else                                block[j] = ( coeff_abs * qmul[j] + 32) >> 6;
+                block[j] = (get_cabac_bypass_sign( CC, -coeff_abs ) * qmul[j] + 32) >> 6;
             }
-
-            abslevelgt1++;
         }
     }
 #ifdef CABAC_ON_STACK
@@ -5871,13 +5576,32 @@
             h->cabac.low       = cc.low       ;
             h->cabac.bytestream= cc.bytestream;
 #endif
-    return 0;
+
 }
 
+#ifndef CONFIG_SMALL
+static void decode_cabac_residual_dc( H264Context *h, DCTELEM *block, int cat, int n, const uint8_t *scantable, const uint32_t *qmul, int max_coeff ) {
+    decode_cabac_residual_internal(h, block, cat, n, scantable, qmul, max_coeff, 1);
+}
+
+static void decode_cabac_residual_nondc( H264Context *h, DCTELEM *block, int cat, int n, const uint8_t *scantable, const uint32_t *qmul, int max_coeff ) {
+    decode_cabac_residual_internal(h, block, cat, n, scantable, qmul, max_coeff, 0);
+}
+#endif
+
+static void decode_cabac_residual( H264Context *h, DCTELEM *block, int cat, int n, const uint8_t *scantable, const uint32_t *qmul, int max_coeff ) {
+#ifdef CONFIG_SMALL
+    decode_cabac_residual_internal(h, block, cat, n, scantable, qmul, max_coeff, cat == 0 || cat == 3);
+#else
+    if( cat == 0 || cat == 3 ) decode_cabac_residual_dc(h, block, cat, n, scantable, qmul, max_coeff);
+    else decode_cabac_residual_nondc(h, block, cat, n, scantable, qmul, max_coeff);
+#endif
+}
+
 static inline void compute_mb_neighbors(H264Context *h)
 {
     MpegEncContext * const s = &h->s;
-    const int mb_xy  = s->mb_x + s->mb_y*s->mb_stride;
+    const int mb_xy  = h->mb_xy;
     h->top_mb_xy     = mb_xy - s->mb_stride;
     h->left_mb_xy[0] = mb_xy - 1;
     if(FRAME_MBAFF){
@@ -5896,6 +5620,8 @@
         if (left_mb_frame_flag != curr_mb_frame_flag) {
             h->left_mb_xy[0] = pair_xy - 1;
         }
+    } else if (FIELD_PICTURE) {
+        h->top_mb_xy -= s->mb_stride;
     }
     return;
 }
@@ -5906,14 +5632,16 @@
  */
 static int decode_mb_cabac(H264Context *h) {
     MpegEncContext * const s = &h->s;
-    const int mb_xy= s->mb_x + s->mb_y*s->mb_stride;
+    int mb_xy;
     int mb_type, partition_count, cbp = 0;
     int dct8x8_allowed= h->pps.transform_8x8_mode;
 
+    mb_xy = h->mb_xy = s->mb_x + s->mb_y*s->mb_stride;
+
     s->dsp.clear_blocks(h->mb); //FIXME avoid if already clear (move after skip handlong?)
 
     tprintf(s->avctx, "pic:%d mb:%d/%d\n", h->frame_num, s->mb_x, s->mb_y);
-    if( h->slice_type != I_TYPE && h->slice_type != SI_TYPE ) {
+    if( h->slice_type != FF_I_TYPE && h->slice_type != FF_SI_TYPE ) {
         int skip;
         /* a skipped mb needs the aff flag from the following mb */
         if( FRAME_MBAFF && s->mb_x==0 && (s->mb_y&1)==0 )
@@ -5958,7 +5686,7 @@
         return -1;
     }
 
-    if( h->slice_type == B_TYPE ) {
+    if( h->slice_type == FF_B_TYPE ) {
         if( mb_type < 23 ){
             partition_count= b_mb_type_info[mb_type].partition_count;
             mb_type=         b_mb_type_info[mb_type].type;
@@ -5966,7 +5694,7 @@
             mb_type -= 23;
             goto decode_intra_mb;
         }
-    } else if( h->slice_type == P_TYPE ) {
+    } else if( h->slice_type == FF_P_TYPE ) {
         if( mb_type < 5) {
             partition_count= p_mb_type_info[mb_type].partition_count;
             mb_type=         p_mb_type_info[mb_type].type;
@@ -5975,7 +5703,7 @@
             goto decode_intra_mb;
         }
     } else {
-       assert(h->slice_type == I_TYPE);
+       assert(h->slice_type == FF_I_TYPE);
 decode_intra_mb:
         partition_count = 0;
         cbp= i_mb_type_info[mb_type].cbp;
@@ -6035,6 +5763,7 @@
         // All coeffs are present
         memset(h->non_zero_count[mb_xy], 16, 16);
         s->current_picture.mb_type[mb_xy]= mb_type;
+        h->last_qscale_diff = 0;
         return 0;
     }
 
@@ -6078,7 +5807,7 @@
     } else if( partition_count == 4 ) {
         int i, j, sub_partition_count[4], list, ref[2][4];
 
-        if( h->slice_type == B_TYPE ) {
+        if( h->slice_type == FF_B_TYPE ) {
             for( i = 0; i < 4; i++ ) {
                 h->sub_mb_type[i] = decode_cabac_b_mb_sub_type( h );
                 sub_partition_count[i]= b_sub_mb_type_info[ h->sub_mb_type[i] ].partition_count;
@@ -6087,6 +5816,10 @@
             if( IS_DIRECT(h->sub_mb_type[0] | h->sub_mb_type[1] |
                           h->sub_mb_type[2] | h->sub_mb_type[3]) ) {
                 pred_direct_motion(h, &mb_type);
+                h->ref_cache[0][scan8[4]] =
+                h->ref_cache[1][scan8[4]] =
+                h->ref_cache[0][scan8[12]] =
+                h->ref_cache[1][scan8[12]] = PART_NOT_AVAILABLE;
                 if( h->ref_count[0] > 1 || h->ref_count[1] > 1 ) {
                     for( i = 0; i < 4; i++ )
                         if( IS_DIRECT(h->sub_mb_type[i]) )
@@ -6122,11 +5855,11 @@
 
         for(list=0; list<h->list_count; list++){
             for(i=0; i<4; i++){
+                h->ref_cache[list][ scan8[4*i]   ]=h->ref_cache[list][ scan8[4*i]+1 ];
                 if(IS_DIRECT(h->sub_mb_type[i])){
                     fill_rectangle(h->mvd_cache[list][scan8[4*i]], 2, 2, 8, 0, 4);
                     continue;
                 }
-                h->ref_cache[list][ scan8[4*i]   ]=h->ref_cache[list][ scan8[4*i]+1 ];
 
                 if(IS_DIR(h->sub_mb_type[i], 0, list) && !IS_DIRECT(h->sub_mb_type[i])){
                     const int sub_mb_type= h->sub_mb_type[i];
@@ -6285,6 +6018,7 @@
 
     if( cbp || IS_INTRA16x16( mb_type ) ) {
         const uint8_t *scan, *scan8x8, *dc_scan;
+        const uint32_t *qmul;
         int dqp;
 
         if(IS_INTERLACED(mb_type)){
@@ -6313,13 +6047,13 @@
         if( IS_INTRA16x16( mb_type ) ) {
             int i;
             //av_log( s->avctx, AV_LOG_ERROR, "INTRA16x16 DC\n" );
-            if( decode_cabac_residual( h, h->mb, 0, 0, dc_scan, NULL, 16) < 0)
-                return -1;
+            decode_cabac_residual( h, h->mb, 0, 0, dc_scan, NULL, 16);
+
             if( cbp&15 ) {
+                qmul = h->dequant4_coeff[0][s->qscale];
                 for( i = 0; i < 16; i++ ) {
                     //av_log( s->avctx, AV_LOG_ERROR, "INTRA16x16 AC:%d\n", i );
-                    if( decode_cabac_residual(h, h->mb + 16*i, 1, i, scan + 1, h->dequant4_coeff[0][s->qscale], 15) < 0 )
-                        return -1;
+                    decode_cabac_residual(h, h->mb + 16*i, 1, i, scan + 1, qmul, 15);
                 }
             } else {
                 fill_rectangle(&h->non_zero_count_cache[scan8[0]], 4, 4, 8, 0, 1);
@@ -6329,17 +6063,17 @@
             for( i8x8 = 0; i8x8 < 4; i8x8++ ) {
                 if( cbp & (1<<i8x8) ) {
                     if( IS_8x8DCT(mb_type) ) {
-                        if( decode_cabac_residual(h, h->mb + 64*i8x8, 5, 4*i8x8,
-                            scan8x8, h->dequant8_coeff[IS_INTRA( mb_type ) ? 0:1][s->qscale], 64) < 0 )
-                            return -1;
-                    } else
-                    for( i4x4 = 0; i4x4 < 4; i4x4++ ) {
-                        const int index = 4*i8x8 + i4x4;
-                        //av_log( s->avctx, AV_LOG_ERROR, "Luma4x4: %d\n", index );
+                        decode_cabac_residual(h, h->mb + 64*i8x8, 5, 4*i8x8,
+                            scan8x8, h->dequant8_coeff[IS_INTRA( mb_type ) ? 0:1][s->qscale], 64);
+                    } else {
+                        qmul = h->dequant4_coeff[IS_INTRA( mb_type ) ? 0:3][s->qscale];
+                        for( i4x4 = 0; i4x4 < 4; i4x4++ ) {
+                            const int index = 4*i8x8 + i4x4;
+                            //av_log( s->avctx, AV_LOG_ERROR, "Luma4x4: %d\n", index );
 //START_TIMER
-                        if( decode_cabac_residual(h, h->mb + 16*index, 2, index, scan, h->dequant4_coeff[IS_INTRA( mb_type ) ? 0:3][s->qscale], 16) < 0 )
-                            return -1;
+                            decode_cabac_residual(h, h->mb + 16*index, 2, index, scan, qmul, 16);
 //STOP_TIMER("decode_residual")
+                        }
                     }
                 } else {
                     uint8_t * const nnz= &h->non_zero_count_cache[ scan8[4*i8x8] ];
@@ -6352,20 +6086,18 @@
             int c;
             for( c = 0; c < 2; c++ ) {
                 //av_log( s->avctx, AV_LOG_ERROR, "INTRA C%d-DC\n",c );
-                if( decode_cabac_residual(h, h->mb + 256 + 16*4*c, 3, c, chroma_dc_scan, NULL, 4) < 0)
-                    return -1;
+                decode_cabac_residual(h, h->mb + 256 + 16*4*c, 3, c, chroma_dc_scan, NULL, 4);
             }
         }
 
         if( cbp&0x20 ) {
             int c, i;
             for( c = 0; c < 2; c++ ) {
-                const uint32_t *qmul = h->dequant4_coeff[c+1+(IS_INTRA( mb_type ) ? 0:3)][h->chroma_qp[c]];
+                qmul = h->dequant4_coeff[c+1+(IS_INTRA( mb_type ) ? 0:3)][h->chroma_qp[c]];
                 for( i = 0; i < 4; i++ ) {
                     const int index = 16 + 4 * c + i;
                     //av_log( s->avctx, AV_LOG_ERROR, "INTRA C%d-AC %d\n",c, index - 16 );
-                    if( decode_cabac_residual(h, h->mb + 16*index, 4, index - 16, scan + 1, qmul, 15) < 0)
-                        return -1;
+                    decode_cabac_residual(h, h->mb + 16*index, 4, index - 16, scan + 1, qmul, 15);
                 }
             }
         } else {
@@ -6699,12 +6431,13 @@
 
 static void filter_mb_fast( H264Context *h, int mb_x, int mb_y, uint8_t *img_y, uint8_t *img_cb, uint8_t *img_cr, unsigned int linesize, unsigned int uvlinesize) {
     MpegEncContext * const s = &h->s;
+    int mb_y_firstrow = s->picture_structure == PICT_BOTTOM_FIELD;
     int mb_xy, mb_type;
     int qp, qp0, qp1, qpc, qpc0, qpc1, qp_thresh;
 
-    mb_xy = mb_x + mb_y*s->mb_stride;
+    mb_xy = h->mb_xy;
 
-    if(mb_x==0 || mb_y==0 || !s->dsp.h264_loop_filter_strength || h->pps.chroma_qp_diff ||
+    if(mb_x==0 || mb_y==mb_y_firstrow || !s->dsp.h264_loop_filter_strength || h->pps.chroma_qp_diff ||
        (h->deblocking_filter == 2 && (h->slice_table[mb_xy] != h->slice_table[h->top_mb_xy] ||
                                       h->slice_table[mb_xy] != h->slice_table[mb_xy - 1]))) {
         filter_mb(h, mb_x, mb_y, img_y, img_cb, img_cr, linesize, uvlinesize);
@@ -6731,17 +6464,18 @@
     if( IS_INTRA(mb_type) ) {
         int16_t bS4[4] = {4,4,4,4};
         int16_t bS3[4] = {3,3,3,3};
+        int16_t *bSH = FIELD_PICTURE ? bS3 : bS4;
         if( IS_8x8DCT(mb_type) ) {
             filter_mb_edgev( h, &img_y[4*0], linesize, bS4, qp0 );
             filter_mb_edgev( h, &img_y[4*2], linesize, bS3, qp );
-            filter_mb_edgeh( h, &img_y[4*0*linesize], linesize, bS4, qp1 );
+            filter_mb_edgeh( h, &img_y[4*0*linesize], linesize, bSH, qp1 );
             filter_mb_edgeh( h, &img_y[4*2*linesize], linesize, bS3, qp );
         } else {
             filter_mb_edgev( h, &img_y[4*0], linesize, bS4, qp0 );
             filter_mb_edgev( h, &img_y[4*1], linesize, bS3, qp );
             filter_mb_edgev( h, &img_y[4*2], linesize, bS3, qp );
             filter_mb_edgev( h, &img_y[4*3], linesize, bS3, qp );
-            filter_mb_edgeh( h, &img_y[4*0*linesize], linesize, bS4, qp1 );
+            filter_mb_edgeh( h, &img_y[4*0*linesize], linesize, bSH, qp1 );
             filter_mb_edgeh( h, &img_y[4*1*linesize], linesize, bS3, qp );
             filter_mb_edgeh( h, &img_y[4*2*linesize], linesize, bS3, qp );
             filter_mb_edgeh( h, &img_y[4*3*linesize], linesize, bS3, qp );
@@ -6750,9 +6484,9 @@
         filter_mb_edgecv( h, &img_cb[2*2], uvlinesize, bS3, qpc );
         filter_mb_edgecv( h, &img_cr[2*0], uvlinesize, bS4, qpc0 );
         filter_mb_edgecv( h, &img_cr[2*2], uvlinesize, bS3, qpc );
-        filter_mb_edgech( h, &img_cb[2*0*uvlinesize], uvlinesize, bS4, qpc1 );
+        filter_mb_edgech( h, &img_cb[2*0*uvlinesize], uvlinesize, bSH, qpc1 );
         filter_mb_edgech( h, &img_cb[2*2*uvlinesize], uvlinesize, bS3, qpc );
-        filter_mb_edgech( h, &img_cr[2*0*uvlinesize], uvlinesize, bS4, qpc1 );
+        filter_mb_edgech( h, &img_cr[2*0*uvlinesize], uvlinesize, bSH, qpc1 );
         filter_mb_edgech( h, &img_cr[2*2*uvlinesize], uvlinesize, bS3, qpc );
         return;
     } else {
@@ -6771,12 +6505,12 @@
             int step = IS_8x8DCT(mb_type) ? 2 : 1;
             edges = (mb_type & MB_TYPE_16x16) && !(h->cbp & 15) ? 1 : 4;
             s->dsp.h264_loop_filter_strength( bS, h->non_zero_count_cache, h->ref_cache, h->mv_cache,
-                                              (h->slice_type == B_TYPE), edges, step, mask_edge0, mask_edge1 );
+                                              (h->slice_type == FF_B_TYPE), edges, step, mask_edge0, mask_edge1 );
         }
         if( IS_INTRA(s->current_picture.mb_type[mb_xy-1]) )
             bSv[0][0] = 0x0004000400040004ULL;
         if( IS_INTRA(s->current_picture.mb_type[h->top_mb_xy]) )
-            bSv[1][0] = 0x0004000400040004ULL;
+            bSv[1][0] = FIELD_PICTURE ? 0x0003000300030003ULL : 0x0004000400040004ULL;
 
 #define FILTER(hv,dir,edge)\
         if(bSv[dir][edge]) {\
@@ -6817,14 +6551,14 @@
     int dir;
     /* FIXME: A given frame may occupy more than one position in
      * the reference list. So ref2frm should be populated with
-     * frame numbers, not indices. */
+     * frame numbers, not indexes. */
     static const int ref2frm[34] = {-1,-1,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,
                                     16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31};
 
     //for sufficiently low qp, filtering wouldn't do anything
     //this is a conservative estimate: could also check beta_offset and more accurate chroma_qp
     if(!FRAME_MBAFF){
-        int qp_thresh = 15 - h->slice_alpha_c0_offset - FFMAX(0, FFMAX(h->pps.chroma_qp_index_offset[0], h->pps.chroma_qp_index_offset[1]));
+        int qp_thresh = 15 - h->slice_alpha_c0_offset - FFMAX3(0, h->pps.chroma_qp_index_offset[0], h->pps.chroma_qp_index_offset[1]);
         int qp = s->current_picture.qscale_table[mb_xy];
         if(qp <= qp_thresh
            && (mb_x == 0 || ((qp + s->current_picture.qscale_table[mb_xy-1] + 1)>>1) <= qp_thresh)
@@ -7002,7 +6736,7 @@
                     int b_idx= 8 + 4 + edge * (dir ? 8:1);
                     int bn_idx= b_idx - (dir ? 8:1);
                     int v = 0;
-                    for( l = 0; !v && l < 1 + (h->slice_type == B_TYPE); l++ ) {
+                    for( l = 0; !v && l < 1 + (h->slice_type == FF_B_TYPE); l++ ) {
                         v |= ref2frm[h->ref_cache[l][b_idx]+2] != ref2frm[h->ref_cache[l][bn_idx]+2] ||
                              FFABS( h->mv_cache[l][b_idx][0] - h->mv_cache[l][bn_idx][0] ) >= 4 ||
                              FFABS( h->mv_cache[l][b_idx][1] - h->mv_cache[l][bn_idx][1] ) >= mvy_limit;
@@ -7026,7 +6760,7 @@
                     else if(!mv_done)
                     {
                         bS[i] = 0;
-                        for( l = 0; l < 1 + (h->slice_type == B_TYPE); l++ ) {
+                        for( l = 0; l < 1 + (h->slice_type == FF_B_TYPE); l++ ) {
                             if( ref2frm[h->ref_cache[l][b_idx]+2] != ref2frm[h->ref_cache[l][bn_idx]+2] ||
                                 FFABS( h->mv_cache[l][b_idx][0] - h->mv_cache[l][bn_idx][0] ) >= 4 ||
                                 FFABS( h->mv_cache[l][b_idx][1] - h->mv_cache[l][bn_idx][1] ) >= mvy_limit ) {
@@ -7069,7 +6803,7 @@
     }
 }
 
-static int decode_slice(H264Context *h){
+static int decode_slice(struct AVCodecContext *avctx, H264Context *h){
     MpegEncContext * const s = &h->s;
     const int part_mask= s->partitioned_frame ? (AC_END|AC_ERROR) : 0x7F;
 
@@ -7089,7 +6823,7 @@
         /* calculate pre-state */
         for( i= 0; i < 460; i++ ) {
             int pre;
-            if( h->slice_type == I_TYPE )
+            if( h->slice_type == FF_I_TYPE )
                 pre = av_clip( ((cabac_context_init_I[i][0] * s->qscale) >>4 ) + cabac_context_init_I[i][1], 1, 126 );
             else
                 pre = av_clip( ((cabac_context_init_PB[h->cabac_init_idc][i][0] * s->qscale) >>4 ) + cabac_context_init_PB[h->cabac_init_idc][i][1], 1, 126 );
@@ -7128,7 +6862,7 @@
                 s->mb_x = 0;
                 ff_draw_horiz_band(s, 16*s->mb_y, 16);
                 ++s->mb_y;
-                if(FRAME_MBAFF) {
+                if(FIELD_OR_MBAFF_PICTURE) {
                     ++s->mb_y;
                 }
             }
@@ -7165,7 +6899,7 @@
                 s->mb_x=0;
                 ff_draw_horiz_band(s, 16*s->mb_y, 16);
                 ++s->mb_y;
-                if(FRAME_MBAFF) {
+                if(FIELD_OR_MBAFF_PICTURE) {
                     ++s->mb_y;
                 }
                 if(s->mb_y >= s->mb_height){
@@ -7334,7 +7068,7 @@
         if( aspect_ratio_idc == EXTENDED_SAR ) {
             sps->sar.num= get_bits(&s->gb, 16);
             sps->sar.den= get_bits(&s->gb, 16);
-        }else if(aspect_ratio_idc < 14){
+        }else if(aspect_ratio_idc < sizeof(pixel_aspect)/sizeof(*pixel_aspect)){
             sps->sar=  pixel_aspect[aspect_ratio_idc];
         }else{
             av_log(h->s.avctx, AV_LOG_ERROR, "illegal aspect ratio\n");
@@ -7529,8 +7263,9 @@
     }
 
     tmp= get_ue_golomb(&s->gb);
-    if(tmp > MAX_PICTURE_COUNT-2){
+    if(tmp > MAX_PICTURE_COUNT-2 || tmp >= 32){
         av_log(h->s.avctx, AV_LOG_ERROR, "too many reference frames\n");
+        return -1;
     }
     sps->ref_frame_count= tmp;
     sps->gaps_in_frame_num_allowed_flag= get_bits1(&s->gb);
@@ -7568,6 +7303,9 @@
         if(sps->crop_left || sps->crop_top){
             av_log(h->s.avctx, AV_LOG_ERROR, "insane cropping not completely supported, this could look slightly wrong ...\n");
         }
+        if(sps->crop_right >= 8 || sps->crop_bottom >= (8>> !h->sps.frame_mbs_only_flag)){
+            av_log(h->s.avctx, AV_LOG_ERROR, "brainfart cropping not supported, this could look slightly wrong ...\n");
+        }
     }else{
         sps->crop_left  =
         sps->crop_right =
@@ -7714,10 +7452,50 @@
     return 0;
 }
 
-static int decode_nal_units(H264Context *h, uint8_t *buf, int buf_size){
+/**
+ * Call decode_slice() for each context.
+ *
+ * @param h h264 master context
+ * @param context_count number of contexts to execute
+ */
+static void execute_decode_slices(H264Context *h, int context_count){
     MpegEncContext * const s = &h->s;
     AVCodecContext * const avctx= s->avctx;
+    H264Context *hx;
+    int i;
+
+    if(context_count == 1) {
+        decode_slice(avctx, h);
+    } else {
+        for(i = 1; i < context_count; i++) {
+            hx = h->thread_context[i];
+            hx->s.error_resilience = avctx->error_resilience;
+            hx->s.error_count = 0;
+        }
+
+        avctx->execute(avctx, (void *)decode_slice,
+                       (void **)h->thread_context, NULL, context_count);
+
+        /* pull back stuff from slices to master context */
+        hx = h->thread_context[context_count - 1];
+        s->mb_x = hx->s.mb_x;
+        s->mb_y = hx->s.mb_y;
+        s->dropable = hx->s.dropable;
+        s->picture_structure = hx->s.picture_structure;
+        for(i = 1; i < context_count; i++)
+            h->s.error_count += h->thread_context[i]->s.error_count;
+    }
+}
+
+
+static int decode_nal_units(H264Context *h, const uint8_t *buf, int buf_size){
+    MpegEncContext * const s = &h->s;
+    AVCodecContext * const avctx= s->avctx;
     int buf_index=0;
+    H264Context *hx; ///< thread context
+    int context_count = 0;
+
+    h->max_contexts = avctx->thread_count;
 #if 0
     int i;
     for(i=0; i<50; i++){
@@ -7725,16 +7503,18 @@
     }
 #endif
     if(!(s->flags2 & CODEC_FLAG2_CHUNKS)){
-        h->slice_num = 0;
-        s->current_picture_ptr= NULL;
+        h->current_slice = 0;
+        if (!s->first_field)
+            s->current_picture_ptr= NULL;
     }
 
     for(;;){
         int consumed;
         int dst_length;
         int bit_length;
-        uint8_t *ptr;
+        const uint8_t *ptr;
         int i, nalsize = 0;
+        int err;
 
         if(h->is_avc) {
             if(buf_index >= buf_size) break;
@@ -7763,7 +7543,9 @@
             buf_index+=3;
         }
 
-        ptr= decode_nal(h, buf + buf_index, &dst_length, &consumed, h->is_avc ? nalsize : buf_size - buf_index);
+        hx = h->thread_context[context_count];
+
+        ptr= decode_nal(hx, buf + buf_index, &dst_length, &consumed, h->is_avc ? nalsize : buf_size - buf_index);
         if (ptr==NULL || dst_length < 0){
             return -1;
         }
@@ -7772,11 +7554,13 @@
         bit_length= !dst_length ? 0 : (8*dst_length - decode_rbsp_trailing(h, ptr + dst_length - 1));
 
         if(s->avctx->debug&FF_DEBUG_STARTCODE){
-            av_log(h->s.avctx, AV_LOG_DEBUG, "NAL %d at %d/%d length %d\n", h->nal_unit_type, buf_index, buf_size, dst_length);
+            av_log(h->s.avctx, AV_LOG_DEBUG, "NAL %d at %d/%d length %d\n", hx->nal_unit_type, buf_index, buf_size, dst_length);
         }
 
-        if (h->is_avc && (nalsize != consumed))
+        if (h->is_avc && (nalsize != consumed)){
             av_log(h->s.avctx, AV_LOG_ERROR, "AVC: Consumed only %d bytes instead of %d\n", consumed, nalsize);
+            consumed= nalsize;
+        }
 
         buf_index += consumed;
 
@@ -7784,53 +7568,56 @@
            ||(avctx->skip_frame >= AVDISCARD_NONREF && h->nal_ref_idc  == 0))
             continue;
 
-        switch(h->nal_unit_type){
+      again:
+        err = 0;
+        switch(hx->nal_unit_type){
         case NAL_IDR_SLICE:
+            if (h->nal_unit_type != NAL_IDR_SLICE) {
+                av_log(h->s.avctx, AV_LOG_ERROR, "Invalid mix of idr and non-idr slices");
+                return -1;
+            }
             idr(h); //FIXME ensure we don't loose some frames if there is reordering
         case NAL_SLICE:
-            init_get_bits(&s->gb, ptr, bit_length);
-            h->intra_gb_ptr=
-            h->inter_gb_ptr= &s->gb;
-            s->data_partitioning = 0;
+            init_get_bits(&hx->s.gb, ptr, bit_length);
+            hx->intra_gb_ptr=
+            hx->inter_gb_ptr= &hx->s.gb;
+            hx->s.data_partitioning = 0;
 
-            if(decode_slice_header(h) < 0){
-                av_log(h->s.avctx, AV_LOG_ERROR, "decode_slice_header error\n");
-                break;
-            }
-            s->current_picture_ptr->key_frame= (h->nal_unit_type == NAL_IDR_SLICE);
-            if(h->redundant_pic_count==0 && s->hurry_up < 5
-               && (avctx->skip_frame < AVDISCARD_NONREF || h->nal_ref_idc)
-               && (avctx->skip_frame < AVDISCARD_BIDIR  || h->slice_type!=B_TYPE)
-               && (avctx->skip_frame < AVDISCARD_NONKEY || h->slice_type==I_TYPE)
+            if((err = decode_slice_header(hx, h)))
+               break;
+
+            s->current_picture_ptr->key_frame|= (hx->nal_unit_type == NAL_IDR_SLICE);
+            if(hx->redundant_pic_count==0 && hx->s.hurry_up < 5
+               && (avctx->skip_frame < AVDISCARD_NONREF || hx->nal_ref_idc)
+               && (avctx->skip_frame < AVDISCARD_BIDIR  || hx->slice_type!=FF_B_TYPE)
+               && (avctx->skip_frame < AVDISCARD_NONKEY || hx->slice_type==FF_I_TYPE)
                && avctx->skip_frame < AVDISCARD_ALL)
-                decode_slice(h);
+                context_count++;
             break;
         case NAL_DPA:
-            init_get_bits(&s->gb, ptr, bit_length);
-            h->intra_gb_ptr=
-            h->inter_gb_ptr= NULL;
-            s->data_partitioning = 1;
+            init_get_bits(&hx->s.gb, ptr, bit_length);
+            hx->intra_gb_ptr=
+            hx->inter_gb_ptr= NULL;
+            hx->s.data_partitioning = 1;
 
-            if(decode_slice_header(h) < 0){
-                av_log(h->s.avctx, AV_LOG_ERROR, "decode_slice_header error\n");
-            }
+            err = decode_slice_header(hx, h);
             break;
         case NAL_DPB:
-            init_get_bits(&h->intra_gb, ptr, bit_length);
-            h->intra_gb_ptr= &h->intra_gb;
+            init_get_bits(&hx->intra_gb, ptr, bit_length);
+            hx->intra_gb_ptr= &hx->intra_gb;
             break;
         case NAL_DPC:
-            init_get_bits(&h->inter_gb, ptr, bit_length);
-            h->inter_gb_ptr= &h->inter_gb;
+            init_get_bits(&hx->inter_gb, ptr, bit_length);
+            hx->inter_gb_ptr= &hx->inter_gb;
 
-            if(h->redundant_pic_count==0 && h->intra_gb_ptr && s->data_partitioning
+            if(hx->redundant_pic_count==0 && hx->intra_gb_ptr && hx->s.data_partitioning
                && s->context_initialized
                && s->hurry_up < 5
-               && (avctx->skip_frame < AVDISCARD_NONREF || h->nal_ref_idc)
-               && (avctx->skip_frame < AVDISCARD_BIDIR  || h->slice_type!=B_TYPE)
-               && (avctx->skip_frame < AVDISCARD_NONKEY || h->slice_type==I_TYPE)
+               && (avctx->skip_frame < AVDISCARD_NONREF || hx->nal_ref_idc)
+               && (avctx->skip_frame < AVDISCARD_BIDIR  || hx->slice_type!=FF_B_TYPE)
+               && (avctx->skip_frame < AVDISCARD_NONKEY || hx->slice_type==FF_I_TYPE)
                && avctx->skip_frame < AVDISCARD_ALL)
-                decode_slice(h);
+                context_count++;
             break;
         case NAL_SEI:
             init_get_bits(&s->gb, ptr, bit_length);
@@ -7860,10 +7647,29 @@
         case NAL_AUXILIARY_SLICE:
             break;
         default:
-            av_log(avctx, AV_LOG_ERROR, "Unknown NAL code: %d\n", h->nal_unit_type);
+            av_log(avctx, AV_LOG_DEBUG, "Unknown NAL code: %d (%d bits)\n", h->nal_unit_type, bit_length);
         }
-    }
 
+        if(context_count == h->max_contexts) {
+            execute_decode_slices(h, context_count);
+            context_count = 0;
+        }
+
+        if (err < 0)
+            av_log(h->s.avctx, AV_LOG_ERROR, "decode_slice_header error\n");
+        else if(err == 1) {
+            /* Slice could not be decoded in parallel mode, copy down
+             * NAL unit stuff to context 0 and restart. Note that
+             * rbsp_buffer is not transfered, but since we no longer
+             * run in parallel mode this should not be an issue. */
+            h->nal_unit_type = hx->nal_unit_type;
+            h->nal_ref_idc   = hx->nal_ref_idc;
+            hx = h;
+            goto again;
+        }
+    }
+    if(context_count)
+        execute_decode_slices(h, context_count);
     return buf_index;
 }
 
@@ -7886,7 +7692,7 @@
 
 static int decode_frame(AVCodecContext *avctx,
                              void *data, int *data_size,
-                             uint8_t *buf, int buf_size)
+                             const uint8_t *buf, int buf_size)
 {
     H264Context *h = avctx->priv_data;
     MpegEncContext *s = &h->s;
@@ -7896,6 +7702,15 @@
     s->flags= avctx->flags;
     s->flags2= avctx->flags2;
 
+    if(s->flags&CODEC_FLAG_TRUNCATED){
+        const int next= ff_h264_find_frame_end(h, buf, buf_size);
+        assert((buf_size > 0) || (next == END_NOT_FOUND));
+
+        if( ff_combine_frame(&s->parse_context, next, &buf, &buf_size) < 0 )
+          return buf_size;
+//printf("next:%d buf_size:%d last_index:%d\n", next, buf_size, s->parse_context.last_index);
+    }
+
    /* no supplementary picture */
     if (buf_size == 0) {
         Picture *out;
@@ -7921,14 +7736,6 @@
         return 0;
     }
 
-    if(s->flags&CODEC_FLAG_TRUNCATED){
-        int next= ff_h264_find_frame_end(h, buf, buf_size);
-
-        if( ff_combine_frame(&s->parse_context, next, (const uint8_t **)&buf, &buf_size) < 0 )
-            return buf_size;
-//printf("next:%d buf_size:%d last_index:%d\n", next, buf_size, s->parse_context.last_index);
-    }
-
     if(h->is_avc && !h->got_avcC) {
         int i, cnt, nalsize;
         unsigned char *p = avctx->extradata;
@@ -7980,6 +7787,7 @@
         return -1;
 
     if(!(s->flags2 & CODEC_FLAG2_CHUNKS) && !s->current_picture_ptr){
+        if (avctx->skip_frame >= AVDISCARD_NONREF || s->hurry_up) return 0;
         av_log(avctx, AV_LOG_ERROR, "no frame!\n");
         return -1;
     }
@@ -7997,87 +7805,109 @@
 
         h->prev_frame_num_offset= h->frame_num_offset;
         h->prev_frame_num= h->frame_num;
-        if(s->current_picture_ptr->reference){
+        if(!s->dropable) {
             h->prev_poc_msb= h->poc_msb;
             h->prev_poc_lsb= h->poc_lsb;
-        }
-        if(s->current_picture_ptr->reference)
             execute_ref_pic_marking(h, h->mmco, h->mmco_index);
+        }
 
-        ff_er_frame_end(s);
+        /*
+         * FIXME: Error handling code does not seem to support interlaced
+         * when slices span multiple rows
+         * The ff_er_add_slice calls don't work right for bottom
+         * fields; they cause massive erroneous error concealing
+         * Error marking covers both fields (top and bottom).
+         * This causes a mismatched s->error_count
+         * and a bad error table. Further, the error count goes to
+         * INT_MAX when called for bottom field, because mb_y is
+         * past end by one (callers fault) and resync_mb_y != 0
+         * causes problems for the first MB line, too.
+         */
+        if (!FIELD_PICTURE)
+            ff_er_frame_end(s);
 
         MPV_frame_end(s);
 
-    //FIXME do something with unavailable reference frames
+        if (s->first_field) {
+            /* Wait for second field. */
+            *data_size = 0;
 
+        } else {
+            cur->interlaced_frame = FIELD_OR_MBAFF_PICTURE;
+            /* Derive top_field_first from field pocs. */
+            cur->top_field_first = cur->field_poc[0] < cur->field_poc[1];
+
+        //FIXME do something with unavailable reference frames
+
 #if 0 //decode order
-        *data_size = sizeof(AVFrame);
+            *data_size = sizeof(AVFrame);
 #else
-        /* Sort B-frames into display order */
+            /* Sort B-frames into display order */
 
-        if(h->sps.bitstream_restriction_flag
-           && s->avctx->has_b_frames < h->sps.num_reorder_frames){
-            s->avctx->has_b_frames = h->sps.num_reorder_frames;
-            s->low_delay = 0;
-        }
+            if(h->sps.bitstream_restriction_flag
+               && s->avctx->has_b_frames < h->sps.num_reorder_frames){
+                s->avctx->has_b_frames = h->sps.num_reorder_frames;
+                s->low_delay = 0;
+            }
 
-        pics = 0;
-        while(h->delayed_pic[pics]) pics++;
+            pics = 0;
+            while(h->delayed_pic[pics]) pics++;
 
-        assert(pics+1 < sizeof(h->delayed_pic) / sizeof(h->delayed_pic[0]));
+            assert(pics <= MAX_DELAYED_PIC_COUNT);
 
-        h->delayed_pic[pics++] = cur;
-        if(cur->reference == 0)
-            cur->reference = 1;
+            h->delayed_pic[pics++] = cur;
+            if(cur->reference == 0)
+                cur->reference = DELAYED_PIC_REF;
 
-        cross_idr = 0;
-        for(i=0; h->delayed_pic[i]; i++)
-            if(h->delayed_pic[i]->key_frame || h->delayed_pic[i]->poc==0)
-                cross_idr = 1;
+            cross_idr = 0;
+            for(i=0; h->delayed_pic[i]; i++)
+                if(h->delayed_pic[i]->key_frame || h->delayed_pic[i]->poc==0)
+                    cross_idr = 1;
 
-        out = h->delayed_pic[0];
-        out_idx = 0;
-        for(i=1; h->delayed_pic[i] && !h->delayed_pic[i]->key_frame; i++)
-            if(h->delayed_pic[i]->poc < out->poc){
-                out = h->delayed_pic[i];
-                out_idx = i;
-            }
+            out = h->delayed_pic[0];
+            out_idx = 0;
+            for(i=1; h->delayed_pic[i] && !h->delayed_pic[i]->key_frame; i++)
+                if(h->delayed_pic[i]->poc < out->poc){
+                    out = h->delayed_pic[i];
+                    out_idx = i;
+                }
 
-        out_of_order = !cross_idr && prev && out->poc < prev->poc;
-        if(h->sps.bitstream_restriction_flag && s->avctx->has_b_frames >= h->sps.num_reorder_frames)
-            { }
-        else if(prev && pics <= s->avctx->has_b_frames)
-            out = prev;
-        else if((out_of_order && pics-1 == s->avctx->has_b_frames && pics < 15)
-           || (s->low_delay &&
-            ((!cross_idr && prev && out->poc > prev->poc + 2)
-             || cur->pict_type == B_TYPE)))
-        {
-            s->low_delay = 0;
-            s->avctx->has_b_frames++;
-            out = prev;
-        }
-        else if(out_of_order)
-            out = prev;
+            out_of_order = !cross_idr && prev && out->poc < prev->poc;
 
-        if(out_of_order || pics > s->avctx->has_b_frames){
-            for(i=out_idx; h->delayed_pic[i]; i++)
-                h->delayed_pic[i] = h->delayed_pic[i+1];
-        }
+            if(prev && pics <= s->avctx->has_b_frames || out_of_order)
+                out = prev;
 
-        if(prev == out)
-            *data_size = 0;
-        else
-            *data_size = sizeof(AVFrame);
-        if(prev && prev != out && prev->reference == 1)
-            prev->reference = 0;
-        h->delayed_output_pic = out;
+            if(h->sps.bitstream_restriction_flag && s->avctx->has_b_frames >= h->sps.num_reorder_frames)
+                { }
+            else if((out_of_order && pics-1 == s->avctx->has_b_frames && pics < 15)
+               || (s->low_delay &&
+                ((!cross_idr && prev && out->poc > prev->poc + 2)
+                 || cur->pict_type == FF_B_TYPE)))
+            {
+                s->low_delay = 0;
+                s->avctx->has_b_frames++;
+                out = prev;
+            }
+
+            if(out_of_order || pics > s->avctx->has_b_frames){
+                for(i=out_idx; h->delayed_pic[i]; i++)
+                    h->delayed_pic[i] = h->delayed_pic[i+1];
+            }
+
+            if(prev == out)
+                *data_size = 0;
+            else
+                *data_size = sizeof(AVFrame);
+            if(prev && prev != out && prev->reference == DELAYED_PIC_REF)
+                prev->reference = 0;
+            h->delayed_output_pic = out;
 #endif
 
-        if(out)
-            *pict= *(AVFrame*)out;
-        else
-            av_log(avctx, AV_LOG_DEBUG, "no picture\n");
+            if(out)
+                *pict= *(AVFrame*)out;
+            else
+                av_log(avctx, AV_LOG_DEBUG, "no picture\n");
+        }
     }
 
     assert(pict->data[0] || !*data_size);
@@ -8086,7 +7916,7 @@
 #if 0 //?
 
     /* Return the Picture timestamp as the frame number */
-    /* we substract 1 because it is added on utils.c    */
+    /* we subtract 1 because it is added on utils.c     */
     avctx->frame_number = s->picture_number - 1;
 #endif
     return get_consumed_bytes(s, buf_index, buf_size);
@@ -8111,10 +7941,12 @@
 }
 #endif
 
-#if 0 //selftest
+#ifdef TEST
+#undef printf
+#undef random
 #define COUNT 8000
 #define SIZE (COUNT*40)
-int main(){
+int main(void){
     int i;
     uint8_t temp[SIZE];
     PutBitContext pb;
@@ -8174,6 +8006,7 @@
         STOP_TIMER("get_se_golomb");
     }
 
+#if 0
     printf("testing 4x4 (I)DCT\n");
 
     DCTELEM block[16];
@@ -8213,14 +8046,12 @@
         }
     }
     printf("error=%f max_error=%d\n", ((float)error)/COUNT/16, (int)max_error );
-#if 0
     printf("testing quantizer\n");
     for(qp=0; qp<52; qp++){
         for(i=0; i<16; i++)
             src1_block[i]= src2_block[i]= random()%255;
 
     }
-#endif
     printf("Testing NAL layer\n");
 
     uint8_t bitstream[COUNT];
@@ -8276,13 +8107,14 @@
             return -1;
         }
     }
+#endif
 
     printf("Testing RBSP\n");
 
 
     return 0;
 }
-#endif
+#endif /* TEST */
 
 
 static int decode_end(AVCodecContext *avctx)

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/h264.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/h264.h	2008-07-24 11:49:40 UTC (rev 4280)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/h264.h	2008-07-24 18:20:17 UTC (rev 4281)
@@ -1,387 +1,427 @@
-/*
- * H.26L/H.264/AVC/JVT/14496-10/... encoder/decoder
- * Copyright (c) 2003 Michael Niedermayer <michaelni at gmx.at>
- *
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with FFmpeg; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- */
-
-/**
- * @file h264.h
- * H.264 / AVC / MPEG4 part10 codec.
- * @author Michael Niedermayer <michaelni at gmx.at>
- */
-
-#ifndef H264_H
-#define H264_H
-
-#include "dsputil.h"
-#include "cabac.h"
-#include "mpegvideo.h"
-
-#define interlaced_dct interlaced_dct_is_a_bad_name
-#define mb_intra mb_intra_is_not_initialized_see_mb_type
-
-#define LUMA_DC_BLOCK_INDEX   25
-#define CHROMA_DC_BLOCK_INDEX 26
-
-#define CHROMA_DC_COEFF_TOKEN_VLC_BITS 8
-#define COEFF_TOKEN_VLC_BITS           8
-#define TOTAL_ZEROS_VLC_BITS           9
-#define CHROMA_DC_TOTAL_ZEROS_VLC_BITS 3
-#define RUN_VLC_BITS                   3
-#define RUN7_VLC_BITS                  6
-
-#define MAX_SPS_COUNT 32
-#define MAX_PPS_COUNT 256
-
-#define MAX_MMCO_COUNT 66
-
-/* Compiling in interlaced support reduces the speed
- * of progressive decoding by about 2%. */
-#define ALLOW_INTERLACE
-
-#ifdef ALLOW_INTERLACE
-#define MB_MBAFF h->mb_mbaff
-#define MB_FIELD h->mb_field_decoding_flag
-#define FRAME_MBAFF h->mb_aff_frame
-#else
-#define MB_MBAFF 0
-#define MB_FIELD 0
-#define FRAME_MBAFF 0
-#undef  IS_INTERLACED
-#define IS_INTERLACED(mb_type) 0
-#endif
-
-/**
- * Sequence parameter set
- */
-typedef struct SPS{
-
-    int profile_idc;
-    int level_idc;
-    int transform_bypass;              ///< qpprime_y_zero_transform_bypass_flag
-    int log2_max_frame_num;            ///< log2_max_frame_num_minus4 + 4
-    int poc_type;                      ///< pic_order_cnt_type
-    int log2_max_poc_lsb;              ///< log2_max_pic_order_cnt_lsb_minus4
-    int delta_pic_order_always_zero_flag;
-    int offset_for_non_ref_pic;
-    int offset_for_top_to_bottom_field;
-    int poc_cycle_length;              ///< num_ref_frames_in_pic_order_cnt_cycle
-    int ref_frame_count;               ///< num_ref_frames
-    int gaps_in_frame_num_allowed_flag;
-    int mb_width;                      ///< frame_width_in_mbs_minus1 + 1
-    int mb_height;                     ///< frame_height_in_mbs_minus1 + 1
-    int frame_mbs_only_flag;
-    int mb_aff;                        ///<mb_adaptive_frame_field_flag
-    int direct_8x8_inference_flag;
-    int crop;                   ///< frame_cropping_flag
-    int crop_left;              ///< frame_cropping_rect_left_offset
-    int crop_right;             ///< frame_cropping_rect_right_offset
-    int crop_top;               ///< frame_cropping_rect_top_offset
-    int crop_bottom;            ///< frame_cropping_rect_bottom_offset
-    int vui_parameters_present_flag;
-    AVRational sar;
-    int timing_info_present_flag;
-    uint32_t num_units_in_tick;
-    uint32_t time_scale;
-    int fixed_frame_rate_flag;
-    short offset_for_ref_frame[256]; //FIXME dyn aloc?
-    int bitstream_restriction_flag;
-    int num_reorder_frames;
-    int scaling_matrix_present;
-    uint8_t scaling_matrix4[6][16];
-    uint8_t scaling_matrix8[2][64];
-}SPS;
-
-/**
- * Picture parameter set
- */
-typedef struct PPS{
-    unsigned int sps_id;
-    int cabac;                  ///< entropy_coding_mode_flag
-    int pic_order_present;      ///< pic_order_present_flag
-    int slice_group_count;      ///< num_slice_groups_minus1 + 1
-    int mb_slice_group_map_type;
-    unsigned int ref_count[2];  ///< num_ref_idx_l0/1_active_minus1 + 1
-    int weighted_pred;          ///< weighted_pred_flag
-    int weighted_bipred_idc;
-    int init_qp;                ///< pic_init_qp_minus26 + 26
-    int init_qs;                ///< pic_init_qs_minus26 + 26
-    int chroma_qp_index_offset[2];
-    int deblocking_filter_parameters_present; ///< deblocking_filter_parameters_present_flag
-    int constrained_intra_pred; ///< constrained_intra_pred_flag
-    int redundant_pic_cnt_present; ///< redundant_pic_cnt_present_flag
-    int transform_8x8_mode;     ///< transform_8x8_mode_flag
-    uint8_t scaling_matrix4[6][16];
-    uint8_t scaling_matrix8[2][64];
-    uint8_t chroma_qp_table[2][256];  ///< pre-scaled (with chroma_qp_index_offset) version of qp_table
-    int chroma_qp_diff;
-}PPS;
-
-/**
- * Memory management control operation opcode.
- */
-typedef enum MMCOOpcode{
-    MMCO_END=0,
-    MMCO_SHORT2UNUSED,
-    MMCO_LONG2UNUSED,
-    MMCO_SHORT2LONG,
-    MMCO_SET_MAX_LONG,
-    MMCO_RESET,
-    MMCO_LONG,
-} MMCOOpcode;
-
-/**
- * Memory management control operation.
- */
-typedef struct MMCO{
-    MMCOOpcode opcode;
-    int short_frame_num;
-    int long_index;
-} MMCO;
-
-/**
- * H264Context
- */
-typedef struct H264Context{
-    MpegEncContext s;
-    int nal_ref_idc;
-    int nal_unit_type;
-    uint8_t *rbsp_buffer[2];
-    unsigned int rbsp_buffer_size[2];
-
-    /**
-      * Used to parse AVC variant of h264
-      */
-    int is_avc; ///< this flag is != 0 if codec is avc1
-    int got_avcC; ///< flag used to parse avcC data only once
-    int nal_length_size; ///< Number of bytes used for nal length (1, 2 or 4)
-
-    int chroma_qp[2]; //QPc
-
-    int prev_mb_skipped;
-    int next_mb_skipped;
-
-    //prediction stuff
-    int chroma_pred_mode;
-    int intra16x16_pred_mode;
-
-    int top_mb_xy;
-    int left_mb_xy[2];
-
-    int8_t intra4x4_pred_mode_cache[5*8];
-    int8_t (*intra4x4_pred_mode)[8];
-    void (*pred4x4  [9+3])(uint8_t *src, uint8_t *topright, int stride);//FIXME move to dsp?
-    void (*pred8x8l [9+3])(uint8_t *src, int topleft, int topright, int stride);
-    void (*pred8x8  [4+3])(uint8_t *src, int stride);
-    void (*pred16x16[4+3])(uint8_t *src, int stride);
-    unsigned int topleft_samples_available;
-    unsigned int top_samples_available;
-    unsigned int topright_samples_available;
-    unsigned int left_samples_available;
-    uint8_t (*top_borders[2])[16+2*8];
-    uint8_t left_border[2*(17+2*9)];
-
-    /**
-     * non zero coeff count cache.
-     * is 64 if not available.
-     */
-    DECLARE_ALIGNED_8(uint8_t, non_zero_count_cache[6*8]);
-    uint8_t (*non_zero_count)[16];
-
-    /**
-     * Motion vector cache.
-     */
-    DECLARE_ALIGNED_8(int16_t, mv_cache[2][5*8][2]);
-    DECLARE_ALIGNED_8(int8_t, ref_cache[2][5*8]);
-#define LIST_NOT_USED -1 //FIXME rename?
-#define PART_NOT_AVAILABLE -2
-
-    /**
-     * is 1 if the specific list MV&references are set to 0,0,-2.
-     */
-    int mv_cache_clean[2];
-
-    /**
-     * number of neighbors (top and/or left) that used 8x8 dct
-     */
-    int neighbor_transform_size;
-
-    /**
-     * block_offset[ 0..23] for frame macroblocks
-     * block_offset[24..47] for field macroblocks
-     */
-    int block_offset[2*(16+8)];
-
-    uint32_t *mb2b_xy; //FIXME are these 4 a good idea?
-    uint32_t *mb2b8_xy;
-    int b_stride; //FIXME use s->b4_stride
-    int b8_stride;
-
-    int mb_linesize;   ///< may be equal to s->linesize or s->linesize*2, for mbaff
-    int mb_uvlinesize;
-
-    int emu_edge_width;
-    int emu_edge_height;
-
-    int halfpel_flag;
-    int thirdpel_flag;
-
-    int unknown_svq3_flag;
-    int next_slice_index;
-
-    SPS *sps_buffers[MAX_SPS_COUNT];
-    SPS sps; ///< current sps
-
-    PPS *pps_buffers[MAX_PPS_COUNT];
-    /**
-     * current pps
-     */
-    PPS pps; //FIXME move to Picture perhaps? (->no) do we need that?
-
-    uint32_t dequant4_buffer[6][52][16];
-    uint32_t dequant8_buffer[2][52][64];
-    uint32_t (*dequant4_coeff[6])[16];
-    uint32_t (*dequant8_coeff[2])[64];
-    int dequant_coeff_pps;     ///< reinit tables when pps changes
-
-    int slice_num;
-    uint8_t *slice_table_base;
-    uint8_t *slice_table;      ///< slice_table_base + 2*mb_stride + 1
-    int slice_type;
-    int slice_type_fixed;
-
-    //interlacing specific flags
-    int mb_aff_frame;
-    int mb_field_decoding_flag;
-    int mb_mbaff;              ///< mb_aff_frame && mb_field_decoding_flag
-
-    unsigned int sub_mb_type[4];
-
-    //POC stuff
-    int poc_lsb;
-    int poc_msb;
-    int delta_poc_bottom;
-    int delta_poc[2];
-    int frame_num;
-    int prev_poc_msb;             ///< poc_msb of the last reference pic for POC type 0
-    int prev_poc_lsb;             ///< poc_lsb of the last reference pic for POC type 0
-    int frame_num_offset;         ///< for POC type 2
-    int prev_frame_num_offset;    ///< for POC type 2
-    int prev_frame_num;           ///< frame_num of the last pic for POC type 1/2
-
-    /**
-     * frame_num for frames or 2*frame_num for field pics.
-     */
-    int curr_pic_num;
-
-    /**
-     * max_frame_num or 2*max_frame_num for field pics.
-     */
-    int max_pic_num;
-
-    //Weighted pred stuff
-    int use_weight;
-    int use_weight_chroma;
-    int luma_log2_weight_denom;
-    int chroma_log2_weight_denom;
-    int luma_weight[2][48];
-    int luma_offset[2][48];
-    int chroma_weight[2][48][2];
-    int chroma_offset[2][48][2];
-    int implicit_weight[48][48];
-
-    //deblock
-    int deblocking_filter;         ///< disable_deblocking_filter_idc with 1<->0
-    int slice_alpha_c0_offset;
-    int slice_beta_offset;
-
-    int redundant_pic_count;
-
-    int direct_spatial_mv_pred;
-    int dist_scale_factor[16];
-    int dist_scale_factor_field[32];
-    int map_col_to_list0[2][16];
-    int map_col_to_list0_field[2][32];
-
-    /**
-     * num_ref_idx_l0/1_active_minus1 + 1
-     */
-    unsigned int ref_count[2];   ///< counts frames or fields, depending on current mb mode
-    unsigned int list_count;
-    Picture *short_ref[32];
-    Picture *long_ref[32];
-    Picture default_ref_list[2][32];
-    Picture ref_list[2][48];     ///< 0..15: frame refs, 16..47: mbaff field refs
-    Picture *delayed_pic[18]; //FIXME size?
-    Picture *delayed_output_pic;
-
-    /**
-     * memory management control operations buffer.
-     */
-    MMCO mmco[MAX_MMCO_COUNT];
-    int mmco_index;
-
-    int long_ref_count;  ///< number of actual long term references
-    int short_ref_count; ///< number of actual short term references
-
-    //data partitioning
-    GetBitContext intra_gb;
-    GetBitContext inter_gb;
-    GetBitContext *intra_gb_ptr;
-    GetBitContext *inter_gb_ptr;
-
-    DECLARE_ALIGNED_8(DCTELEM, mb[16*24]);
-    DCTELEM mb_padding[256];        ///< as mb is addressed by scantable[i] and scantable is uint8_t we can either check that i is not to large or ensure that there is some unused stuff after mb
-
-    /**
-     * Cabac
-     */
-    CABACContext cabac;
-    uint8_t      cabac_state[460];
-    int          cabac_init_idc;
-
-    /* 0x100 -> non null luma_dc, 0x80/0x40 -> non null chroma_dc (cb/cr), 0x?0 -> chroma_cbp(0,1,2), 0x0? luma_cbp */
-    uint16_t     *cbp_table;
-    int cbp;
-    int top_cbp;
-    int left_cbp;
-    /* chroma_pred_mode for i4x4 or i16x16, else 0 */
-    uint8_t     *chroma_pred_mode_table;
-    int         last_qscale_diff;
-    int16_t     (*mvd_table[2])[2];
-    DECLARE_ALIGNED_8(int16_t, mvd_cache[2][5*8][2]);
-    uint8_t     *direct_table;
-    uint8_t     direct_cache[5*8];
-
-    uint8_t zigzag_scan[16];
-    uint8_t zigzag_scan8x8[64];
-    uint8_t zigzag_scan8x8_cavlc[64];
-    uint8_t field_scan[16];
-    uint8_t field_scan8x8[64];
-    uint8_t field_scan8x8_cavlc[64];
-    const uint8_t *zigzag_scan_q0;
-    const uint8_t *zigzag_scan8x8_q0;
-    const uint8_t *zigzag_scan8x8_cavlc_q0;
-    const uint8_t *field_scan_q0;
-    const uint8_t *field_scan8x8_q0;
-    const uint8_t *field_scan8x8_cavlc_q0;
-
-    int x264_build;
-}H264Context;
-
-#endif /* H264_H */
+/*
+ * H.26L/H.264/AVC/JVT/14496-10/... encoder/decoder
+ * Copyright (c) 2003 Michael Niedermayer <michaelni at gmx.at>
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+/**
+ * @file h264.h
+ * H.264 / AVC / MPEG4 part10 codec.
+ * @author Michael Niedermayer <michaelni at gmx.at>
+ */
+
+#ifndef FFMPEG_H264_H
+#define FFMPEG_H264_H
+
+#include "dsputil.h"
+#include "cabac.h"
+#include "mpegvideo.h"
+#include "h264pred.h"
+
+#define interlaced_dct interlaced_dct_is_a_bad_name
+#define mb_intra mb_intra_is_not_initialized_see_mb_type
+
+#define LUMA_DC_BLOCK_INDEX   25
+#define CHROMA_DC_BLOCK_INDEX 26
+
+#define CHROMA_DC_COEFF_TOKEN_VLC_BITS 8
+#define COEFF_TOKEN_VLC_BITS           8
+#define TOTAL_ZEROS_VLC_BITS           9
+#define CHROMA_DC_TOTAL_ZEROS_VLC_BITS 3
+#define RUN_VLC_BITS                   3
+#define RUN7_VLC_BITS                  6
+
+#define MAX_SPS_COUNT 32
+#define MAX_PPS_COUNT 256
+
+#define MAX_MMCO_COUNT 66
+
+#define MAX_DELAYED_PIC_COUNT 16
+
+/* Compiling in interlaced support reduces the speed
+ * of progressive decoding by about 2%. */
+#define ALLOW_INTERLACE
+
+#ifdef ALLOW_INTERLACE
+#define MB_MBAFF h->mb_mbaff
+#define MB_FIELD h->mb_field_decoding_flag
+#define FRAME_MBAFF h->mb_aff_frame
+#define FIELD_PICTURE (s->picture_structure != PICT_FRAME)
+#else
+#define MB_MBAFF 0
+#define MB_FIELD 0
+#define FRAME_MBAFF 0
+#define FIELD_PICTURE 0
+#undef  IS_INTERLACED
+#define IS_INTERLACED(mb_type) 0
+#endif
+#define FIELD_OR_MBAFF_PICTURE (FRAME_MBAFF || FIELD_PICTURE)
+
+#ifndef ENABLE_H264_ENCODER
+#define ENABLE_H264_ENCODER 0
+#endif
+
+/**
+ * Sequence parameter set
+ */
+typedef struct SPS{
+
+    int profile_idc;
+    int level_idc;
+    int transform_bypass;              ///< qpprime_y_zero_transform_bypass_flag
+    int log2_max_frame_num;            ///< log2_max_frame_num_minus4 + 4
+    int poc_type;                      ///< pic_order_cnt_type
+    int log2_max_poc_lsb;              ///< log2_max_pic_order_cnt_lsb_minus4
+    int delta_pic_order_always_zero_flag;
+    int offset_for_non_ref_pic;
+    int offset_for_top_to_bottom_field;
+    int poc_cycle_length;              ///< num_ref_frames_in_pic_order_cnt_cycle
+    int ref_frame_count;               ///< num_ref_frames
+    int gaps_in_frame_num_allowed_flag;
+    int mb_width;                      ///< pic_width_in_mbs_minus1 + 1
+    int mb_height;                     ///< pic_height_in_map_units_minus1 + 1
+    int frame_mbs_only_flag;
+    int mb_aff;                        ///<mb_adaptive_frame_field_flag
+    int direct_8x8_inference_flag;
+    int crop;                   ///< frame_cropping_flag
+    unsigned int crop_left;            ///< frame_cropping_rect_left_offset
+    unsigned int crop_right;           ///< frame_cropping_rect_right_offset
+    unsigned int crop_top;             ///< frame_cropping_rect_top_offset
+    unsigned int crop_bottom;          ///< frame_cropping_rect_bottom_offset
+    int vui_parameters_present_flag;
+    AVRational sar;
+    int timing_info_present_flag;
+    uint32_t num_units_in_tick;
+    uint32_t time_scale;
+    int fixed_frame_rate_flag;
+    short offset_for_ref_frame[256]; //FIXME dyn aloc?
+    int bitstream_restriction_flag;
+    int num_reorder_frames;
+    int scaling_matrix_present;
+    uint8_t scaling_matrix4[6][16];
+    uint8_t scaling_matrix8[2][64];
+}SPS;
+
+/**
+ * Picture parameter set
+ */
+typedef struct PPS{
+    unsigned int sps_id;
+    int cabac;                  ///< entropy_coding_mode_flag
+    int pic_order_present;      ///< pic_order_present_flag
+    int slice_group_count;      ///< num_slice_groups_minus1 + 1
+    int mb_slice_group_map_type;
+    unsigned int ref_count[2];  ///< num_ref_idx_l0/1_active_minus1 + 1
+    int weighted_pred;          ///< weighted_pred_flag
+    int weighted_bipred_idc;
+    int init_qp;                ///< pic_init_qp_minus26 + 26
+    int init_qs;                ///< pic_init_qs_minus26 + 26
+    int chroma_qp_index_offset[2];
+    int deblocking_filter_parameters_present; ///< deblocking_filter_parameters_present_flag
+    int constrained_intra_pred; ///< constrained_intra_pred_flag
+    int redundant_pic_cnt_present; ///< redundant_pic_cnt_present_flag
+    int transform_8x8_mode;     ///< transform_8x8_mode_flag
+    uint8_t scaling_matrix4[6][16];
+    uint8_t scaling_matrix8[2][64];
+    uint8_t chroma_qp_table[2][256];  ///< pre-scaled (with chroma_qp_index_offset) version of qp_table
+    int chroma_qp_diff;
+}PPS;
+
+/**
+ * Memory management control operation opcode.
+ */
+typedef enum MMCOOpcode{
+    MMCO_END=0,
+    MMCO_SHORT2UNUSED,
+    MMCO_LONG2UNUSED,
+    MMCO_SHORT2LONG,
+    MMCO_SET_MAX_LONG,
+    MMCO_RESET,
+    MMCO_LONG,
+} MMCOOpcode;
+
+/**
+ * Memory management control operation.
+ */
+typedef struct MMCO{
+    MMCOOpcode opcode;
+    int short_pic_num;  ///< pic_num without wrapping (pic_num & max_pic_num)
+    int long_arg;       ///< index, pic_num, or num long refs depending on opcode
+} MMCO;
+
+/**
+ * H264Context
+ */
+typedef struct H264Context{
+    MpegEncContext s;
+    int nal_ref_idc;
+    int nal_unit_type;
+    uint8_t *rbsp_buffer[2];
+    unsigned int rbsp_buffer_size[2];
+
+    /**
+      * Used to parse AVC variant of h264
+      */
+    int is_avc; ///< this flag is != 0 if codec is avc1
+    int got_avcC; ///< flag used to parse avcC data only once
+    int nal_length_size; ///< Number of bytes used for nal length (1, 2 or 4)
+
+    int chroma_qp[2]; //QPc
+
+    int prev_mb_skipped;
+    int next_mb_skipped;
+
+    //prediction stuff
+    int chroma_pred_mode;
+    int intra16x16_pred_mode;
+
+    int top_mb_xy;
+    int left_mb_xy[2];
+
+    int8_t intra4x4_pred_mode_cache[5*8];
+    int8_t (*intra4x4_pred_mode)[8];
+    H264PredContext hpc;
+    unsigned int topleft_samples_available;
+    unsigned int top_samples_available;
+    unsigned int topright_samples_available;
+    unsigned int left_samples_available;
+    uint8_t (*top_borders[2])[16+2*8];
+    uint8_t left_border[2*(17+2*9)];
+
+    /**
+     * non zero coeff count cache.
+     * is 64 if not available.
+     */
+    DECLARE_ALIGNED_8(uint8_t, non_zero_count_cache[6*8]);
+    uint8_t (*non_zero_count)[16];
+
+    /**
+     * Motion vector cache.
+     */
+    DECLARE_ALIGNED_8(int16_t, mv_cache[2][5*8][2]);
+    DECLARE_ALIGNED_8(int8_t, ref_cache[2][5*8]);
+#define LIST_NOT_USED -1 //FIXME rename?
+#define PART_NOT_AVAILABLE -2
+
+    /**
+     * is 1 if the specific list MV&references are set to 0,0,-2.
+     */
+    int mv_cache_clean[2];
+
+    /**
+     * number of neighbors (top and/or left) that used 8x8 dct
+     */
+    int neighbor_transform_size;
+
+    /**
+     * block_offset[ 0..23] for frame macroblocks
+     * block_offset[24..47] for field macroblocks
+     */
+    int block_offset[2*(16+8)];
+
+    uint32_t *mb2b_xy; //FIXME are these 4 a good idea?
+    uint32_t *mb2b8_xy;
+    int b_stride; //FIXME use s->b4_stride
+    int b8_stride;
+
+    int mb_linesize;   ///< may be equal to s->linesize or s->linesize*2, for mbaff
+    int mb_uvlinesize;
+
+    int emu_edge_width;
+    int emu_edge_height;
+
+    int halfpel_flag;
+    int thirdpel_flag;
+
+    int unknown_svq3_flag;
+    int next_slice_index;
+
+    SPS *sps_buffers[MAX_SPS_COUNT];
+    SPS sps; ///< current sps
+
+    PPS *pps_buffers[MAX_PPS_COUNT];
+    /**
+     * current pps
+     */
+    PPS pps; //FIXME move to Picture perhaps? (->no) do we need that?
+
+    uint32_t dequant4_buffer[6][52][16];
+    uint32_t dequant8_buffer[2][52][64];
+    uint32_t (*dequant4_coeff[6])[16];
+    uint32_t (*dequant8_coeff[2])[64];
+    int dequant_coeff_pps;     ///< reinit tables when pps changes
+
+    int slice_num;
+    uint8_t *slice_table_base;
+    uint8_t *slice_table;      ///< slice_table_base + 2*mb_stride + 1
+    int slice_type;
+    int slice_type_fixed;
+
+    //interlacing specific flags
+    int mb_aff_frame;
+    int mb_field_decoding_flag;
+    int mb_mbaff;              ///< mb_aff_frame && mb_field_decoding_flag
+
+    unsigned int sub_mb_type[4];
+
+    //POC stuff
+    int poc_lsb;
+    int poc_msb;
+    int delta_poc_bottom;
+    int delta_poc[2];
+    int frame_num;
+    int prev_poc_msb;             ///< poc_msb of the last reference pic for POC type 0
+    int prev_poc_lsb;             ///< poc_lsb of the last reference pic for POC type 0
+    int frame_num_offset;         ///< for POC type 2
+    int prev_frame_num_offset;    ///< for POC type 2
+    int prev_frame_num;           ///< frame_num of the last pic for POC type 1/2
+
+    /**
+     * frame_num for frames or 2*frame_num+1 for field pics.
+     */
+    int curr_pic_num;
+
+    /**
+     * max_frame_num or 2*max_frame_num for field pics.
+     */
+    int max_pic_num;
+
+    //Weighted pred stuff
+    int use_weight;
+    int use_weight_chroma;
+    int luma_log2_weight_denom;
+    int chroma_log2_weight_denom;
+    int luma_weight[2][48];
+    int luma_offset[2][48];
+    int chroma_weight[2][48][2];
+    int chroma_offset[2][48][2];
+    int implicit_weight[48][48];
+
+    //deblock
+    int deblocking_filter;         ///< disable_deblocking_filter_idc with 1<->0
+    int slice_alpha_c0_offset;
+    int slice_beta_offset;
+
+    int redundant_pic_count;
+
+    int direct_spatial_mv_pred;
+    int dist_scale_factor[16];
+    int dist_scale_factor_field[32];
+    int map_col_to_list0[2][16];
+    int map_col_to_list0_field[2][32];
+
+    /**
+     * num_ref_idx_l0/1_active_minus1 + 1
+     */
+    unsigned int ref_count[2];   ///< counts frames or fields, depending on current mb mode
+    unsigned int list_count;
+    Picture *short_ref[32];
+    Picture *long_ref[32];
+    Picture default_ref_list[2][32]; ///< base reference list for all slices of a coded picture
+    Picture ref_list[2][48];         /**< 0..15: frame refs, 16..47: mbaff field refs.
+                                          Reordered version of default_ref_list
+                                          according to picture reordering in slice header */
+    Picture *delayed_pic[MAX_DELAYED_PIC_COUNT+2]; //FIXME size?
+    Picture *delayed_output_pic;
+
+    /**
+     * memory management control operations buffer.
+     */
+    MMCO mmco[MAX_MMCO_COUNT];
+    int mmco_index;
+
+    int long_ref_count;  ///< number of actual long term references
+    int short_ref_count; ///< number of actual short term references
+
+    //data partitioning
+    GetBitContext intra_gb;
+    GetBitContext inter_gb;
+    GetBitContext *intra_gb_ptr;
+    GetBitContext *inter_gb_ptr;
+
+    DECLARE_ALIGNED_16(DCTELEM, mb[16*24]);
+    DCTELEM mb_padding[256];        ///< as mb is addressed by scantable[i] and scantable is uint8_t we can either check that i is not too large or ensure that there is some unused stuff after mb
+
+    /**
+     * Cabac
+     */
+    CABACContext cabac;
+    uint8_t      cabac_state[460];
+    int          cabac_init_idc;
+
+    /* 0x100 -> non null luma_dc, 0x80/0x40 -> non null chroma_dc (cb/cr), 0x?0 -> chroma_cbp(0,1,2), 0x0? luma_cbp */
+    uint16_t     *cbp_table;
+    int cbp;
+    int top_cbp;
+    int left_cbp;
+    /* chroma_pred_mode for i4x4 or i16x16, else 0 */
+    uint8_t     *chroma_pred_mode_table;
+    int         last_qscale_diff;
+    int16_t     (*mvd_table[2])[2];
+    DECLARE_ALIGNED_8(int16_t, mvd_cache[2][5*8][2]);
+    uint8_t     *direct_table;
+    uint8_t     direct_cache[5*8];
+
+    uint8_t zigzag_scan[16];
+    uint8_t zigzag_scan8x8[64];
+    uint8_t zigzag_scan8x8_cavlc[64];
+    uint8_t field_scan[16];
+    uint8_t field_scan8x8[64];
+    uint8_t field_scan8x8_cavlc[64];
+    const uint8_t *zigzag_scan_q0;
+    const uint8_t *zigzag_scan8x8_q0;
+    const uint8_t *zigzag_scan8x8_cavlc_q0;
+    const uint8_t *field_scan_q0;
+    const uint8_t *field_scan8x8_q0;
+    const uint8_t *field_scan8x8_cavlc_q0;
+
+    int x264_build;
+
+    /**
+     * @defgroup multithreading Members for slice based multithreading
+     * @{
+     */
+    struct H264Context *thread_context[MAX_THREADS];
+
+    /**
+     * current slice number, used to initalize slice_num of each thread/context
+     */
+    int current_slice;
+
+    /**
+     * Max number of threads / contexts.
+     * This is equal to AVCodecContext.thread_count unless
+     * multithreaded decoding is impossible, in which case it is
+     * reduced to 1.
+     */
+    int max_contexts;
+
+    /**
+     *  1 if the single thread fallback warning has already been
+     *  displayed, 0 otherwise.
+     */
+    int single_decode_warning;
+
+    int last_slice_type;
+    /** @} */
+
+    int mb_xy;
+
+}H264Context;
+
+#endif /* FFMPEG_H264_H */

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/h264_parser.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/h264_parser.h	2008-07-24 11:49:40 UTC (rev 4280)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/h264_parser.h	2008-07-24 18:20:17 UTC (rev 4281)
@@ -1,39 +1,39 @@
-/*
- * H.26L/H.264/AVC/JVT/14496-10/... parser
- * Copyright (c) 2003 Michael Niedermayer <michaelni at gmx.at>
- *
- * This file is part of FFmpeg.
- *
- * FFmpeg is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * FFmpeg is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with FFmpeg; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- */
-
-/**
- * @file h264_parser.h
- * H.264 / AVC / MPEG4 part10 parser.
- * @author Michael Niedermayer <michaelni at gmx.at>
- */
-
-#ifndef H264_PARSER_H
-#define H264_PARSER_H
-
-#include "h264.h"
-
-/**
- * finds the end of the current frame in the bitstream.
- * @return the position of the first byte of the next frame, or -1
- */
-int ff_h264_find_frame_end(H264Context *h, const uint8_t *buf, int buf_size);
-
-#endif /* H264_PARSER_H */
+/*
+ * H.26L/H.264/AVC/JVT/14496-10/... parser
+ * Copyright (c) 2003 Michael Niedermayer <michaelni at gmx.at>
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+/**
+ * @file h264_parser.h
+ * H.264 / AVC / MPEG4 part10 parser.
+ * @author Michael Niedermayer <michaelni at gmx.at>
+ */
+
+#ifndef FFMPEG_H264_PARSER_H
+#define FFMPEG_H264_PARSER_H
+
+#include "h264.h"
+
+/**
+ * finds the end of the current frame in the bitstream.
+ * @return the position of the first byte of the next frame, or -1
+ */
+int ff_h264_find_frame_end(H264Context *h, const uint8_t *buf, int buf_size);
+
+#endif /* FFMPEG_H264_PARSER_H */

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/h264data.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/h264data.h	2008-07-24 11:49:40 UTC (rev 4280)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/h264data.h	2008-07-24 18:20:17 UTC (rev 4281)
@@ -26,37 +26,14 @@
  * @author Michael Niedermayer <michaelni at gmx.at>
  */
 
-#ifndef AVCODEC_H264DATA_H
-#define AVCODEC_H264DATA_H
+#ifndef FFMPEG_H264DATA_H
+#define FFMPEG_H264DATA_H
 
 #include <stdint.h>
-#include "mpegvideo.h"
 #include "rational.h"
+#include "mpegvideo.h"
 
-#define VERT_PRED             0
-#define HOR_PRED              1
-#define DC_PRED               2
-#define DIAG_DOWN_LEFT_PRED   3
-#define DIAG_DOWN_RIGHT_PRED  4
-#define VERT_RIGHT_PRED       5
-#define HOR_DOWN_PRED         6
-#define VERT_LEFT_PRED        7
-#define HOR_UP_PRED           8
 
-#define LEFT_DC_PRED          9
-#define TOP_DC_PRED           10
-#define DC_128_PRED           11
-
-
-#define DC_PRED8x8            0
-#define HOR_PRED8x8           1
-#define VERT_PRED8x8          2
-#define PLANE_PRED8x8         3
-
-#define LEFT_DC_PRED8x8       4
-#define TOP_DC_PRED8x8        5
-#define DC_128_PRED8x8        6
-
 #define EXTENDED_SAR          255
 
 /* NAL unit types */
@@ -77,7 +54,7 @@
 NAL_AUXILIARY_SLICE=19
 };
 
-static const AVRational pixel_aspect[14]={
+static const AVRational pixel_aspect[17]={
  {0, 1},
  {1, 1},
  {12, 11},
@@ -92,10 +69,13 @@
  {15, 11},
  {64, 33},
  {160,99},
+ {4, 3},
+ {3, 2},
+ {2, 1},
 };
 
 static const uint8_t golomb_to_pict_type[5]=
-{P_TYPE, B_TYPE, I_TYPE, SP_TYPE, SI_TYPE};
+{FF_P_TYPE, FF_B_TYPE, FF_I_TYPE, FF_SP_TYPE, FF_SI_TYPE};
 
 static const uint8_t pict_type_to_golomb[7]=
 {-1, 2, 0, 1, -1, 4, 3};
@@ -544,7 +524,7 @@
    24,25,27,28,30,32,33,35
 }};
 
-static const int dequant4_coeff_init[6][3]={
+static const uint8_t dequant4_coeff_init[6][3]={
   {10,13,16},
   {11,14,18},
   {13,16,20},
@@ -553,10 +533,10 @@
   {18,23,29},
 };
 
-static const int dequant8_coeff_init_scan[16] = {
+static const uint8_t dequant8_coeff_init_scan[16] = {
   0,3,4,3, 3,1,5,1, 4,5,2,5, 3,1,5,1
 };
-static const int dequant8_coeff_init[6][6]={
+static const uint8_t dequant8_coeff_init[6][6]={
   {20,18,32,19,25,24},
   {22,19,35,21,28,26},
   {26,23,42,24,33,31},
@@ -624,7 +604,7 @@
 
 
 /* Deblocking filter (p153) */
-static const int alpha_table[52*3] = {
+static const uint8_t alpha_table[52*3] = {
      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
@@ -640,7 +620,7 @@
    255,255,255,255,255,255,255,255,255,255,255,255,255,
    255,255,255,255,255,255,255,255,255,255,255,255,255,
 };
-static const int beta_table[52*3] = {
+static const uint8_t beta_table[52*3] = {
      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
      0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
@@ -656,7 +636,7 @@
     18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18,
     18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18,
 };
-static const int tc0_table[52*3][3] = {
+static const uint8_t tc0_table[52*3][3] = {
     { 0, 0, 0 }, { 0, 0, 0 }, { 0, 0, 0 }, { 0, 0, 0 }, { 0, 0, 0 }, { 0, 0, 0 },
     { 0, 0, 0 }, { 0, 0, 0 }, { 0, 0, 0 }, { 0, 0, 0 }, { 0, 0, 0 }, { 0, 0, 0 },
     { 0, 0, 0 }, { 0, 0, 0 }, { 0, 0, 0 }, { 0, 0, 0 }, { 0, 0, 0 }, { 0, 0, 0 },
@@ -688,7 +668,7 @@
 
 /* Cabac pre state table */
 
-static const int cabac_context_init_I[460][2] =
+static const int8_t cabac_context_init_I[460][2] =
 {
     /* 0 - 10 */
     { 20, -15 }, {  2, 54 },  {  3,  74 }, { 20, -15 },
@@ -857,7 +837,7 @@
     {  29,   9 }, {  35,  20 }, {  29,  36 }, {  14,  67 }
 };
 
-static const int cabac_context_init_PB[3][460][2] =
+static const int8_t cabac_context_init_PB[3][460][2] =
 {
     /* i_cabac_init_idc == 0 */
     {
@@ -1328,4 +1308,4 @@
     }
 };
 
-#endif // AVCODEC_H264DATA_H
+#endif /* FFMPEG_H264DATA_H */

Added: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/h264pred.c
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/h264pred.c	2008-07-24 11:49:40 UTC (rev 4280)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/h264pred.c	2008-07-24 18:20:17 UTC (rev 4281)
@@ -0,0 +1,1073 @@
+/*
+ * H.26L/H.264/AVC/JVT/14496-10/... encoder/decoder
+ * Copyright (c) 2003 Michael Niedermayer <michaelni at gmx.at>
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+/**
+ * @file h264pred.c
+ * H.264 / AVC / MPEG4 part10 prediction functions.
+ * @author Michael Niedermayer <michaelni at gmx.at>
+ */
+
+#include "avcodec.h"
+#include "mpegvideo.h"
+#include "h264pred.h"
+
+static void pred4x4_vertical_c(uint8_t *src, uint8_t *topright, int stride){
+    const uint32_t a= ((uint32_t*)(src-stride))[0];
+    ((uint32_t*)(src+0*stride))[0]= a;
+    ((uint32_t*)(src+1*stride))[0]= a;
+    ((uint32_t*)(src+2*stride))[0]= a;
+    ((uint32_t*)(src+3*stride))[0]= a;
+}
+
+static void pred4x4_horizontal_c(uint8_t *src, uint8_t *topright, int stride){
+    ((uint32_t*)(src+0*stride))[0]= src[-1+0*stride]*0x01010101;
+    ((uint32_t*)(src+1*stride))[0]= src[-1+1*stride]*0x01010101;
+    ((uint32_t*)(src+2*stride))[0]= src[-1+2*stride]*0x01010101;
+    ((uint32_t*)(src+3*stride))[0]= src[-1+3*stride]*0x01010101;
+}
+
+static void pred4x4_dc_c(uint8_t *src, uint8_t *topright, int stride){
+    const int dc= (  src[-stride] + src[1-stride] + src[2-stride] + src[3-stride]
+                   + src[-1+0*stride] + src[-1+1*stride] + src[-1+2*stride] + src[-1+3*stride] + 4) >>3;
+
+    ((uint32_t*)(src+0*stride))[0]=
+    ((uint32_t*)(src+1*stride))[0]=
+    ((uint32_t*)(src+2*stride))[0]=
+    ((uint32_t*)(src+3*stride))[0]= dc* 0x01010101;
+}
+
+static void pred4x4_left_dc_c(uint8_t *src, uint8_t *topright, int stride){
+    const int dc= (  src[-1+0*stride] + src[-1+1*stride] + src[-1+2*stride] + src[-1+3*stride] + 2) >>2;
+
+    ((uint32_t*)(src+0*stride))[0]=
+    ((uint32_t*)(src+1*stride))[0]=
+    ((uint32_t*)(src+2*stride))[0]=
+    ((uint32_t*)(src+3*stride))[0]= dc* 0x01010101;
+}
+
+static void pred4x4_top_dc_c(uint8_t *src, uint8_t *topright, int stride){
+    const int dc= (  src[-stride] + src[1-stride] + src[2-stride] + src[3-stride] + 2) >>2;
+
+    ((uint32_t*)(src+0*stride))[0]=
+    ((uint32_t*)(src+1*stride))[0]=
+    ((uint32_t*)(src+2*stride))[0]=
+    ((uint32_t*)(src+3*stride))[0]= dc* 0x01010101;
+}
+
+static void pred4x4_128_dc_c(uint8_t *src, uint8_t *topright, int stride){
+    ((uint32_t*)(src+0*stride))[0]=
+    ((uint32_t*)(src+1*stride))[0]=
+    ((uint32_t*)(src+2*stride))[0]=
+    ((uint32_t*)(src+3*stride))[0]= 128U*0x01010101U;
+}
+
+
+#define LOAD_TOP_RIGHT_EDGE\
+    const int av_unused t4= topright[0];\
+    const int av_unused t5= topright[1];\
+    const int av_unused t6= topright[2];\
+    const int av_unused t7= topright[3];\
+
+#define LOAD_DOWN_LEFT_EDGE\
+    const int av_unused l4= src[-1+4*stride];\
+    const int av_unused l5= src[-1+5*stride];\
+    const int av_unused l6= src[-1+6*stride];\
+    const int av_unused l7= src[-1+7*stride];\
+
+#define LOAD_LEFT_EDGE\
+    const int av_unused l0= src[-1+0*stride];\
+    const int av_unused l1= src[-1+1*stride];\
+    const int av_unused l2= src[-1+2*stride];\
+    const int av_unused l3= src[-1+3*stride];\
+
+#define LOAD_TOP_EDGE\
+    const int av_unused t0= src[ 0-1*stride];\
+    const int av_unused t1= src[ 1-1*stride];\
+    const int av_unused t2= src[ 2-1*stride];\
+    const int av_unused t3= src[ 3-1*stride];\
+
+static void pred4x4_down_right_c(uint8_t *src, uint8_t *topright, int stride){
+    const int lt= src[-1-1*stride];
+    LOAD_TOP_EDGE
+    LOAD_LEFT_EDGE
+
+    src[0+3*stride]=(l3 + 2*l2 + l1 + 2)>>2;
+    src[0+2*stride]=
+    src[1+3*stride]=(l2 + 2*l1 + l0 + 2)>>2;
+    src[0+1*stride]=
+    src[1+2*stride]=
+    src[2+3*stride]=(l1 + 2*l0 + lt + 2)>>2;
+    src[0+0*stride]=
+    src[1+1*stride]=
+    src[2+2*stride]=
+    src[3+3*stride]=(l0 + 2*lt + t0 + 2)>>2;
+    src[1+0*stride]=
+    src[2+1*stride]=
+    src[3+2*stride]=(lt + 2*t0 + t1 + 2)>>2;
+    src[2+0*stride]=
+    src[3+1*stride]=(t0 + 2*t1 + t2 + 2)>>2;
+    src[3+0*stride]=(t1 + 2*t2 + t3 + 2)>>2;
+}
+
+static void pred4x4_down_left_c(uint8_t *src, uint8_t *topright, int stride){
+    LOAD_TOP_EDGE
+    LOAD_TOP_RIGHT_EDGE
+//    LOAD_LEFT_EDGE
+
+    src[0+0*stride]=(t0 + t2 + 2*t1 + 2)>>2;
+    src[1+0*stride]=
+    src[0+1*stride]=(t1 + t3 + 2*t2 + 2)>>2;
+    src[2+0*stride]=
+    src[1+1*stride]=
+    src[0+2*stride]=(t2 + t4 + 2*t3 + 2)>>2;
+    src[3+0*stride]=
+    src[2+1*stride]=
+    src[1+2*stride]=
+    src[0+3*stride]=(t3 + t5 + 2*t4 + 2)>>2;
+    src[3+1*stride]=
+    src[2+2*stride]=
+    src[1+3*stride]=(t4 + t6 + 2*t5 + 2)>>2;
+    src[3+2*stride]=
+    src[2+3*stride]=(t5 + t7 + 2*t6 + 2)>>2;
+    src[3+3*stride]=(t6 + 3*t7 + 2)>>2;
+}
+
+static void pred4x4_down_left_svq3_c(uint8_t *src, uint8_t *topright, int stride){
+    LOAD_TOP_EDGE
+    LOAD_LEFT_EDGE
+    const av_unused int unu0= t0;
+    const av_unused int unu1= l0;
+
+    src[0+0*stride]=(l1 + t1)>>1;
+    src[1+0*stride]=
+    src[0+1*stride]=(l2 + t2)>>1;
+    src[2+0*stride]=
+    src[1+1*stride]=
+    src[0+2*stride]=
+    src[3+0*stride]=
+    src[2+1*stride]=
+    src[1+2*stride]=
+    src[0+3*stride]=
+    src[3+1*stride]=
+    src[2+2*stride]=
+    src[1+3*stride]=
+    src[3+2*stride]=
+    src[2+3*stride]=
+    src[3+3*stride]=(l3 + t3)>>1;
+}
+
+static void pred4x4_down_left_rv40_c(uint8_t *src, uint8_t *topright, int stride){
+    LOAD_TOP_EDGE
+    LOAD_TOP_RIGHT_EDGE
+    LOAD_LEFT_EDGE
+    LOAD_DOWN_LEFT_EDGE
+
+    src[0+0*stride]=(t0 + t2 + 2*t1 + 2 + l0 + l2 + 2*l1 + 2)>>3;
+    src[1+0*stride]=
+    src[0+1*stride]=(t1 + t3 + 2*t2 + 2 + l1 + l3 + 2*l2 + 2)>>3;
+    src[2+0*stride]=
+    src[1+1*stride]=
+    src[0+2*stride]=(t2 + t4 + 2*t3 + 2 + l2 + l4 + 2*l3 + 2)>>3;
+    src[3+0*stride]=
+    src[2+1*stride]=
+    src[1+2*stride]=
+    src[0+3*stride]=(t3 + t5 + 2*t4 + 2 + l3 + l5 + 2*l4 + 2)>>3;
+    src[3+1*stride]=
+    src[2+2*stride]=
+    src[1+3*stride]=(t4 + t6 + 2*t5 + 2 + l4 + l6 + 2*l5 + 2)>>3;
+    src[3+2*stride]=
+    src[2+3*stride]=(t5 + t7 + 2*t6 + 2 + l5 + l7 + 2*l6 + 2)>>3;
+    src[3+3*stride]=(t6 + t7 + 1 + l6 + l7 + 1)>>2;
+}
+
+static void pred4x4_down_left_rv40_notop_c(uint8_t *src, uint8_t *topright, int stride){
+    LOAD_LEFT_EDGE
+    LOAD_DOWN_LEFT_EDGE
+
+    src[0+0*stride]=(l0 + l2 + 2*l1 + 2)>>2;
+    src[1+0*stride]=
+    src[0+1*stride]=(l1 + l3 + 2*l2 + 2)>>2;
+    src[2+0*stride]=
+    src[1+1*stride]=
+    src[0+2*stride]=(l2 + l4 + 2*l3 + 2)>>2;
+    src[3+0*stride]=
+    src[2+1*stride]=
+    src[1+2*stride]=
+    src[0+3*stride]=(l3 + l5 + 2*l4 + 2)>>2;
+    src[3+1*stride]=
+    src[2+2*stride]=
+    src[1+3*stride]=(l4 + l6 + 2*l5 + 2)>>2;
+    src[3+2*stride]=
+    src[2+3*stride]=(l5 + l7 + 2*l6 + 2)>>2;
+    src[3+3*stride]=(l6 + l7 + 1)>>1;
+}
+
+static void pred4x4_down_left_rv40_nodown_c(uint8_t *src, uint8_t *topright, int stride){
+    LOAD_TOP_EDGE
+    LOAD_TOP_RIGHT_EDGE
+    LOAD_LEFT_EDGE
+
+    src[0+0*stride]=(t0 + t2 + 2*t1 + 2 + l0 + l2 + 2*l1 + 2)>>3;
+    src[1+0*stride]=
+    src[0+1*stride]=(t1 + t3 + 2*t2 + 2 + l1 + l3 + 2*l2 + 2)>>3;
+    src[2+0*stride]=
+    src[1+1*stride]=
+    src[0+2*stride]=(t2 + t4 + 2*t3 + 2 + l2 + 3*l3 + 2)>>3;
+    src[3+0*stride]=
+    src[2+1*stride]=
+    src[1+2*stride]=
+    src[0+3*stride]=(t3 + t5 + 2*t4 + 2 + l3*4 + 2)>>3;
+    src[3+1*stride]=
+    src[2+2*stride]=
+    src[1+3*stride]=(t4 + t6 + 2*t5 + 2 + l3*4 + 2)>>3;
+    src[3+2*stride]=
+    src[2+3*stride]=(t5 + t7 + 2*t6 + 2 + l3*4 + 2)>>3;
+    src[3+3*stride]=(t6 + t7 + 1 + 2*l3 + 1)>>2;
+}
+
+static void pred4x4_vertical_right_c(uint8_t *src, uint8_t *topright, int stride){
+    const int lt= src[-1-1*stride];
+    LOAD_TOP_EDGE
+    LOAD_LEFT_EDGE
+
+    src[0+0*stride]=
+    src[1+2*stride]=(lt + t0 + 1)>>1;
+    src[1+0*stride]=
+    src[2+2*stride]=(t0 + t1 + 1)>>1;
+    src[2+0*stride]=
+    src[3+2*stride]=(t1 + t2 + 1)>>1;
+    src[3+0*stride]=(t2 + t3 + 1)>>1;
+    src[0+1*stride]=
+    src[1+3*stride]=(l0 + 2*lt + t0 + 2)>>2;
+    src[1+1*stride]=
+    src[2+3*stride]=(lt + 2*t0 + t1 + 2)>>2;
+    src[2+1*stride]=
+    src[3+3*stride]=(t0 + 2*t1 + t2 + 2)>>2;
+    src[3+1*stride]=(t1 + 2*t2 + t3 + 2)>>2;
+    src[0+2*stride]=(lt + 2*l0 + l1 + 2)>>2;
+    src[0+3*stride]=(l0 + 2*l1 + l2 + 2)>>2;
+}
+
+static void pred4x4_vertical_left_c(uint8_t *src, uint8_t *topright, int stride){
+    LOAD_TOP_EDGE
+    LOAD_TOP_RIGHT_EDGE
+
+    src[0+0*stride]=(t0 + t1 + 1)>>1;
+    src[1+0*stride]=
+    src[0+2*stride]=(t1 + t2 + 1)>>1;
+    src[2+0*stride]=
+    src[1+2*stride]=(t2 + t3 + 1)>>1;
+    src[3+0*stride]=
+    src[2+2*stride]=(t3 + t4+ 1)>>1;
+    src[3+2*stride]=(t4 + t5+ 1)>>1;
+    src[0+1*stride]=(t0 + 2*t1 + t2 + 2)>>2;
+    src[1+1*stride]=
+    src[0+3*stride]=(t1 + 2*t2 + t3 + 2)>>2;
+    src[2+1*stride]=
+    src[1+3*stride]=(t2 + 2*t3 + t4 + 2)>>2;
+    src[3+1*stride]=
+    src[2+3*stride]=(t3 + 2*t4 + t5 + 2)>>2;
+    src[3+3*stride]=(t4 + 2*t5 + t6 + 2)>>2;
+}
+
+static void pred4x4_vertical_left_rv40(uint8_t *src, uint8_t *topright, int stride,
+                                      const int l0, const int l1, const int l2, const int l3, const int l4){
+    LOAD_TOP_EDGE
+    LOAD_TOP_RIGHT_EDGE
+
+    src[0+0*stride]=(2*t0 + 2*t1 + l1 + 2*l2 + l3 + 4)>>3;
+    src[1+0*stride]=
+    src[0+2*stride]=(t1 + t2 + 1)>>1;
+    src[2+0*stride]=
+    src[1+2*stride]=(t2 + t3 + 1)>>1;
+    src[3+0*stride]=
+    src[2+2*stride]=(t3 + t4+ 1)>>1;
+    src[3+2*stride]=(t4 + t5+ 1)>>1;
+    src[0+1*stride]=(t0 + 2*t1 + t2 + l2 + 2*l3 + l4 + 4)>>3;
+    src[1+1*stride]=
+    src[0+3*stride]=(t1 + 2*t2 + t3 + 2)>>2;
+    src[2+1*stride]=
+    src[1+3*stride]=(t2 + 2*t3 + t4 + 2)>>2;
+    src[3+1*stride]=
+    src[2+3*stride]=(t3 + 2*t4 + t5 + 2)>>2;
+    src[3+3*stride]=(t4 + 2*t5 + t6 + 2)>>2;
+}
+
+static void pred4x4_vertical_left_rv40_c(uint8_t *src, uint8_t *topright, int stride){
+    LOAD_LEFT_EDGE
+    LOAD_DOWN_LEFT_EDGE
+
+    pred4x4_vertical_left_rv40(src, topright, stride, l0, l1, l2, l3, l4);
+}
+
+static void pred4x4_vertical_left_rv40_nodown_c(uint8_t *src, uint8_t *topright, int stride){
+    LOAD_LEFT_EDGE
+
+    pred4x4_vertical_left_rv40(src, topright, stride, l0, l1, l2, l3, l3);
+}
+
+static void pred4x4_horizontal_up_c(uint8_t *src, uint8_t *topright, int stride){
+    LOAD_LEFT_EDGE
+
+    src[0+0*stride]=(l0 + l1 + 1)>>1;
+    src[1+0*stride]=(l0 + 2*l1 + l2 + 2)>>2;
+    src[2+0*stride]=
+    src[0+1*stride]=(l1 + l2 + 1)>>1;
+    src[3+0*stride]=
+    src[1+1*stride]=(l1 + 2*l2 + l3 + 2)>>2;
+    src[2+1*stride]=
+    src[0+2*stride]=(l2 + l3 + 1)>>1;
+    src[3+1*stride]=
+    src[1+2*stride]=(l2 + 2*l3 + l3 + 2)>>2;
+    src[3+2*stride]=
+    src[1+3*stride]=
+    src[0+3*stride]=
+    src[2+2*stride]=
+    src[2+3*stride]=
+    src[3+3*stride]=l3;
+}
+
+static void pred4x4_horizontal_up_rv40_c(uint8_t *src, uint8_t *topright, int stride){
+    LOAD_LEFT_EDGE
+    LOAD_DOWN_LEFT_EDGE
+    LOAD_TOP_EDGE
+    LOAD_TOP_RIGHT_EDGE
+
+    src[0+0*stride]=(t1 + 2*t2 + t3 + 2*l0 + 2*l1 + 4)>>3;
+    src[1+0*stride]=(t2 + 2*t3 + t4 + l0 + 2*l1 + l2 + 4)>>3;
+    src[2+0*stride]=
+    src[0+1*stride]=(t3 + 2*t4 + t5 + 2*l1 + 2*l2 + 4)>>3;
+    src[3+0*stride]=
+    src[1+1*stride]=(t4 + 2*t5 + t6 + l1 + 2*l2 + l3 + 4)>>3;
+    src[2+1*stride]=
+    src[0+2*stride]=(t5 + 2*t6 + t7 + 2*l2 + 2*l3 + 4)>>3;
+    src[3+1*stride]=
+    src[1+2*stride]=(t6 + 3*t7 + l2 + 3*l3 + 4)>>3;
+    src[3+2*stride]=
+    src[1+3*stride]=(l3 + 2*l4 + l5 + 2)>>2;
+    src[0+3*stride]=
+    src[2+2*stride]=(t6 + t7 + l3 + l4 + 2)>>2;
+    src[2+3*stride]=(l4 + l5 + 1)>>1;
+    src[3+3*stride]=(l4 + 2*l5 + l6 + 2)>>2;
+}
+
+static void pred4x4_horizontal_up_rv40_nodown_c(uint8_t *src, uint8_t *topright, int stride){
+    LOAD_LEFT_EDGE
+    LOAD_TOP_EDGE
+    LOAD_TOP_RIGHT_EDGE
+
+    src[0+0*stride]=(t1 + 2*t2 + t3 + 2*l0 + 2*l1 + 4)>>3;
+    src[1+0*stride]=(t2 + 2*t3 + t4 + l0 + 2*l1 + l2 + 4)>>3;
+    src[2+0*stride]=
+    src[0+1*stride]=(t3 + 2*t4 + t5 + 2*l1 + 2*l2 + 4)>>3;
+    src[3+0*stride]=
+    src[1+1*stride]=(t4 + 2*t5 + t6 + l1 + 2*l2 + l3 + 4)>>3;
+    src[2+1*stride]=
+    src[0+2*stride]=(t5 + 2*t6 + t7 + 2*l2 + 2*l3 + 4)>>3;
+    src[3+1*stride]=
+    src[1+2*stride]=(t6 + 3*t7 + l2 + 3*l3 + 4)>>3;
+    src[3+2*stride]=
+    src[1+3*stride]=l3;
+    src[0+3*stride]=
+    src[2+2*stride]=(t6 + t7 + 2*l3 + 2)>>2;
+    src[2+3*stride]=
+    src[3+3*stride]=l3;
+}
+
+static void pred4x4_horizontal_down_c(uint8_t *src, uint8_t *topright, int stride){
+    const int lt= src[-1-1*stride];
+    LOAD_TOP_EDGE
+    LOAD_LEFT_EDGE
+
+    src[0+0*stride]=
+    src[2+1*stride]=(lt + l0 + 1)>>1;
+    src[1+0*stride]=
+    src[3+1*stride]=(l0 + 2*lt + t0 + 2)>>2;
+    src[2+0*stride]=(lt + 2*t0 + t1 + 2)>>2;
+    src[3+0*stride]=(t0 + 2*t1 + t2 + 2)>>2;
+    src[0+1*stride]=
+    src[2+2*stride]=(l0 + l1 + 1)>>1;
+    src[1+1*stride]=
+    src[3+2*stride]=(lt + 2*l0 + l1 + 2)>>2;
+    src[0+2*stride]=
+    src[2+3*stride]=(l1 + l2+ 1)>>1;
+    src[1+2*stride]=
+    src[3+3*stride]=(l0 + 2*l1 + l2 + 2)>>2;
+    src[0+3*stride]=(l2 + l3 + 1)>>1;
+    src[1+3*stride]=(l1 + 2*l2 + l3 + 2)>>2;
+}
+
+static void pred16x16_vertical_c(uint8_t *src, int stride){
+    int i;
+    const uint32_t a= ((uint32_t*)(src-stride))[0];
+    const uint32_t b= ((uint32_t*)(src-stride))[1];
+    const uint32_t c= ((uint32_t*)(src-stride))[2];
+    const uint32_t d= ((uint32_t*)(src-stride))[3];
+
+    for(i=0; i<16; i++){
+        ((uint32_t*)(src+i*stride))[0]= a;
+        ((uint32_t*)(src+i*stride))[1]= b;
+        ((uint32_t*)(src+i*stride))[2]= c;
+        ((uint32_t*)(src+i*stride))[3]= d;
+    }
+}
+
+static void pred16x16_horizontal_c(uint8_t *src, int stride){
+    int i;
+
+    for(i=0; i<16; i++){
+        ((uint32_t*)(src+i*stride))[0]=
+        ((uint32_t*)(src+i*stride))[1]=
+        ((uint32_t*)(src+i*stride))[2]=
+        ((uint32_t*)(src+i*stride))[3]= src[-1+i*stride]*0x01010101;
+    }
+}
+
+static void pred16x16_dc_c(uint8_t *src, int stride){
+    int i, dc=0;
+
+    for(i=0;i<16; i++){
+        dc+= src[-1+i*stride];
+    }
+
+    for(i=0;i<16; i++){
+        dc+= src[i-stride];
+    }
+
+    dc= 0x01010101*((dc + 16)>>5);
+
+    for(i=0; i<16; i++){
+        ((uint32_t*)(src+i*stride))[0]=
+        ((uint32_t*)(src+i*stride))[1]=
+        ((uint32_t*)(src+i*stride))[2]=
+        ((uint32_t*)(src+i*stride))[3]= dc;
+    }
+}
+
+static void pred16x16_left_dc_c(uint8_t *src, int stride){
+    int i, dc=0;
+
+    for(i=0;i<16; i++){
+        dc+= src[-1+i*stride];
+    }
+
+    dc= 0x01010101*((dc + 8)>>4);
+
+    for(i=0; i<16; i++){
+        ((uint32_t*)(src+i*stride))[0]=
+        ((uint32_t*)(src+i*stride))[1]=
+        ((uint32_t*)(src+i*stride))[2]=
+        ((uint32_t*)(src+i*stride))[3]= dc;
+    }
+}
+
+static void pred16x16_top_dc_c(uint8_t *src, int stride){
+    int i, dc=0;
+
+    for(i=0;i<16; i++){
+        dc+= src[i-stride];
+    }
+    dc= 0x01010101*((dc + 8)>>4);
+
+    for(i=0; i<16; i++){
+        ((uint32_t*)(src+i*stride))[0]=
+        ((uint32_t*)(src+i*stride))[1]=
+        ((uint32_t*)(src+i*stride))[2]=
+        ((uint32_t*)(src+i*stride))[3]= dc;
+    }
+}
+
+static void pred16x16_128_dc_c(uint8_t *src, int stride){
+    int i;
+
+    for(i=0; i<16; i++){
+        ((uint32_t*)(src+i*stride))[0]=
+        ((uint32_t*)(src+i*stride))[1]=
+        ((uint32_t*)(src+i*stride))[2]=
+        ((uint32_t*)(src+i*stride))[3]= 0x01010101U*128U;
+    }
+}
+
+static inline void pred16x16_plane_compat_c(uint8_t *src, int stride, const int svq3, const int rv40){
+  int i, j, k;
+  int a;
+  uint8_t *cm = ff_cropTbl + MAX_NEG_CROP;
+  const uint8_t * const src0 = src+7-stride;
+  const uint8_t *src1 = src+8*stride-1;
+  const uint8_t *src2 = src1-2*stride;      // == src+6*stride-1;
+  int H = src0[1] - src0[-1];
+  int V = src1[0] - src2[ 0];
+  for(k=2; k<=8; ++k) {
+    src1 += stride; src2 -= stride;
+    H += k*(src0[k] - src0[-k]);
+    V += k*(src1[0] - src2[ 0]);
+  }
+  if(svq3){
+    H = ( 5*(H/4) ) / 16;
+    V = ( 5*(V/4) ) / 16;
+
+    /* required for 100% accuracy */
+    i = H; H = V; V = i;
+  }else if(rv40){
+    H = ( H + (H>>2) ) >> 4;
+    V = ( V + (V>>2) ) >> 4;
+  }else{
+    H = ( 5*H+32 ) >> 6;
+    V = ( 5*V+32 ) >> 6;
+  }
+
+  a = 16*(src1[0] + src2[16] + 1) - 7*(V+H);
+  for(j=16; j>0; --j) {
+    int b = a;
+    a += V;
+    for(i=-16; i<0; i+=4) {
+      src[16+i] = cm[ (b    ) >> 5 ];
+      src[17+i] = cm[ (b+  H) >> 5 ];
+      src[18+i] = cm[ (b+2*H) >> 5 ];
+      src[19+i] = cm[ (b+3*H) >> 5 ];
+      b += 4*H;
+    }
+    src += stride;
+  }
+}
+
+static void pred16x16_plane_c(uint8_t *src, int stride){
+    pred16x16_plane_compat_c(src, stride, 0, 0);
+}
+
+static void pred16x16_plane_svq3_c(uint8_t *src, int stride){
+    pred16x16_plane_compat_c(src, stride, 1, 0);
+}
+
+static void pred16x16_plane_rv40_c(uint8_t *src, int stride){
+    pred16x16_plane_compat_c(src, stride, 0, 1);
+}
+
+static void pred8x8_vertical_c(uint8_t *src, int stride){
+    int i;
+    const uint32_t a= ((uint32_t*)(src-stride))[0];
+    const uint32_t b= ((uint32_t*)(src-stride))[1];
+
+    for(i=0; i<8; i++){
+        ((uint32_t*)(src+i*stride))[0]= a;
+        ((uint32_t*)(src+i*stride))[1]= b;
+    }
+}
+
+static void pred8x8_horizontal_c(uint8_t *src, int stride){
+    int i;
+
+    for(i=0; i<8; i++){
+        ((uint32_t*)(src+i*stride))[0]=
+        ((uint32_t*)(src+i*stride))[1]= src[-1+i*stride]*0x01010101;
+    }
+}
+
+static void pred8x8_128_dc_c(uint8_t *src, int stride){
+    int i;
+
+    for(i=0; i<8; i++){
+        ((uint32_t*)(src+i*stride))[0]=
+        ((uint32_t*)(src+i*stride))[1]= 0x01010101U*128U;
+    }
+}
+
+static void pred8x8_left_dc_c(uint8_t *src, int stride){
+    int i;
+    int dc0, dc2;
+
+    dc0=dc2=0;
+    for(i=0;i<4; i++){
+        dc0+= src[-1+i*stride];
+        dc2+= src[-1+(i+4)*stride];
+    }
+    dc0= 0x01010101*((dc0 + 2)>>2);
+    dc2= 0x01010101*((dc2 + 2)>>2);
+
+    for(i=0; i<4; i++){
+        ((uint32_t*)(src+i*stride))[0]=
+        ((uint32_t*)(src+i*stride))[1]= dc0;
+    }
+    for(i=4; i<8; i++){
+        ((uint32_t*)(src+i*stride))[0]=
+        ((uint32_t*)(src+i*stride))[1]= dc2;
+    }
+}
+
+static void pred8x8_left_dc_rv40_c(uint8_t *src, int stride){
+    int i;
+    int dc0;
+
+    dc0=0;
+    for(i=0;i<8; i++)
+        dc0+= src[-1+i*stride];
+    dc0= 0x01010101*((dc0 + 4)>>3);
+
+    for(i=0; i<8; i++){
+        ((uint32_t*)(src+i*stride))[0]=
+        ((uint32_t*)(src+i*stride))[1]= dc0;
+    }
+}
+
+static void pred8x8_top_dc_c(uint8_t *src, int stride){
+    int i;
+    int dc0, dc1;
+
+    dc0=dc1=0;
+    for(i=0;i<4; i++){
+        dc0+= src[i-stride];
+        dc1+= src[4+i-stride];
+    }
+    dc0= 0x01010101*((dc0 + 2)>>2);
+    dc1= 0x01010101*((dc1 + 2)>>2);
+
+    for(i=0; i<4; i++){
+        ((uint32_t*)(src+i*stride))[0]= dc0;
+        ((uint32_t*)(src+i*stride))[1]= dc1;
+    }
+    for(i=4; i<8; i++){
+        ((uint32_t*)(src+i*stride))[0]= dc0;
+        ((uint32_t*)(src+i*stride))[1]= dc1;
+    }
+}
+
+static void pred8x8_top_dc_rv40_c(uint8_t *src, int stride){
+    int i;
+    int dc0;
+
+    dc0=0;
+    for(i=0;i<8; i++)
+        dc0+= src[i-stride];
+    dc0= 0x01010101*((dc0 + 4)>>3);
+
+    for(i=0; i<8; i++){
+        ((uint32_t*)(src+i*stride))[0]=
+        ((uint32_t*)(src+i*stride))[1]= dc0;
+    }
+}
+
+
+static void pred8x8_dc_c(uint8_t *src, int stride){
+    int i;
+    int dc0, dc1, dc2, dc3;
+
+    dc0=dc1=dc2=0;
+    for(i=0;i<4; i++){
+        dc0+= src[-1+i*stride] + src[i-stride];
+        dc1+= src[4+i-stride];
+        dc2+= src[-1+(i+4)*stride];
+    }
+    dc3= 0x01010101*((dc1 + dc2 + 4)>>3);
+    dc0= 0x01010101*((dc0 + 4)>>3);
+    dc1= 0x01010101*((dc1 + 2)>>2);
+    dc2= 0x01010101*((dc2 + 2)>>2);
+
+    for(i=0; i<4; i++){
+        ((uint32_t*)(src+i*stride))[0]= dc0;
+        ((uint32_t*)(src+i*stride))[1]= dc1;
+    }
+    for(i=4; i<8; i++){
+        ((uint32_t*)(src+i*stride))[0]= dc2;
+        ((uint32_t*)(src+i*stride))[1]= dc3;
+    }
+}
+
+static void pred8x8_dc_rv40_c(uint8_t *src, int stride){
+    int i;
+    int dc0=0;
+
+    for(i=0;i<4; i++){
+        dc0+= src[-1+i*stride] + src[i-stride];
+        dc0+= src[4+i-stride];
+        dc0+= src[-1+(i+4)*stride];
+    }
+    dc0= 0x01010101*((dc0 + 8)>>4);
+
+    for(i=0; i<4; i++){
+        ((uint32_t*)(src+i*stride))[0]= dc0;
+        ((uint32_t*)(src+i*stride))[1]= dc0;
+    }
+    for(i=4; i<8; i++){
+        ((uint32_t*)(src+i*stride))[0]= dc0;
+        ((uint32_t*)(src+i*stride))[1]= dc0;
+    }
+}
+
+static void pred8x8_plane_c(uint8_t *src, int stride){
+  int j, k;
+  int a;
+  uint8_t *cm = ff_cropTbl + MAX_NEG_CROP;
+  const uint8_t * const src0 = src+3-stride;
+  const uint8_t *src1 = src+4*stride-1;
+  const uint8_t *src2 = src1-2*stride;      // == src+2*stride-1;
+  int H = src0[1] - src0[-1];
+  int V = src1[0] - src2[ 0];
+  for(k=2; k<=4; ++k) {
+    src1 += stride; src2 -= stride;
+    H += k*(src0[k] - src0[-k]);
+    V += k*(src1[0] - src2[ 0]);
+  }
+  H = ( 17*H+16 ) >> 5;
+  V = ( 17*V+16 ) >> 5;
+
+  a = 16*(src1[0] + src2[8]+1) - 3*(V+H);
+  for(j=8; j>0; --j) {
+    int b = a;
+    a += V;
+    src[0] = cm[ (b    ) >> 5 ];
+    src[1] = cm[ (b+  H) >> 5 ];
+    src[2] = cm[ (b+2*H) >> 5 ];
+    src[3] = cm[ (b+3*H) >> 5 ];
+    src[4] = cm[ (b+4*H) >> 5 ];
+    src[5] = cm[ (b+5*H) >> 5 ];
+    src[6] = cm[ (b+6*H) >> 5 ];
+    src[7] = cm[ (b+7*H) >> 5 ];
+    src += stride;
+  }
+}
+
+#define SRC(x,y) src[(x)+(y)*stride]
+#define PL(y) \
+    const int l##y = (SRC(-1,y-1) + 2*SRC(-1,y) + SRC(-1,y+1) + 2) >> 2;
+#define PREDICT_8x8_LOAD_LEFT \
+    const int l0 = ((has_topleft ? SRC(-1,-1) : SRC(-1,0)) \
+                     + 2*SRC(-1,0) + SRC(-1,1) + 2) >> 2; \
+    PL(1) PL(2) PL(3) PL(4) PL(5) PL(6) \
+    const int l7 av_unused = (SRC(-1,6) + 3*SRC(-1,7) + 2) >> 2
+
+#define PT(x) \
+    const int t##x = (SRC(x-1,-1) + 2*SRC(x,-1) + SRC(x+1,-1) + 2) >> 2;
+#define PREDICT_8x8_LOAD_TOP \
+    const int t0 = ((has_topleft ? SRC(-1,-1) : SRC(0,-1)) \
+                     + 2*SRC(0,-1) + SRC(1,-1) + 2) >> 2; \
+    PT(1) PT(2) PT(3) PT(4) PT(5) PT(6) \
+    const int t7 av_unused = ((has_topright ? SRC(8,-1) : SRC(7,-1)) \
+                     + 2*SRC(7,-1) + SRC(6,-1) + 2) >> 2
+
+#define PTR(x) \
+    t##x = (SRC(x-1,-1) + 2*SRC(x,-1) + SRC(x+1,-1) + 2) >> 2;
+#define PREDICT_8x8_LOAD_TOPRIGHT \
+    int t8, t9, t10, t11, t12, t13, t14, t15; \
+    if(has_topright) { \
+        PTR(8) PTR(9) PTR(10) PTR(11) PTR(12) PTR(13) PTR(14) \
+        t15 = (SRC(14,-1) + 3*SRC(15,-1) + 2) >> 2; \
+    } else t8=t9=t10=t11=t12=t13=t14=t15= SRC(7,-1);
+
+#define PREDICT_8x8_LOAD_TOPLEFT \
+    const int lt = (SRC(-1,0) + 2*SRC(-1,-1) + SRC(0,-1) + 2) >> 2
+
+#define PREDICT_8x8_DC(v) \
+    int y; \
+    for( y = 0; y < 8; y++ ) { \
+        ((uint32_t*)src)[0] = \
+        ((uint32_t*)src)[1] = v; \
+        src += stride; \
+    }
+
+static void pred8x8l_128_dc_c(uint8_t *src, int has_topleft, int has_topright, int stride)
+{
+    PREDICT_8x8_DC(0x80808080);
+}
+static void pred8x8l_left_dc_c(uint8_t *src, int has_topleft, int has_topright, int stride)
+{
+    PREDICT_8x8_LOAD_LEFT;
+    const uint32_t dc = ((l0+l1+l2+l3+l4+l5+l6+l7+4) >> 3) * 0x01010101;
+    PREDICT_8x8_DC(dc);
+}
+static void pred8x8l_top_dc_c(uint8_t *src, int has_topleft, int has_topright, int stride)
+{
+    PREDICT_8x8_LOAD_TOP;
+    const uint32_t dc = ((t0+t1+t2+t3+t4+t5+t6+t7+4) >> 3) * 0x01010101;
+    PREDICT_8x8_DC(dc);
+}
+static void pred8x8l_dc_c(uint8_t *src, int has_topleft, int has_topright, int stride)
+{
+    PREDICT_8x8_LOAD_LEFT;
+    PREDICT_8x8_LOAD_TOP;
+    const uint32_t dc = ((l0+l1+l2+l3+l4+l5+l6+l7
+                         +t0+t1+t2+t3+t4+t5+t6+t7+8) >> 4) * 0x01010101;
+    PREDICT_8x8_DC(dc);
+}
+static void pred8x8l_horizontal_c(uint8_t *src, int has_topleft, int has_topright, int stride)
+{
+    PREDICT_8x8_LOAD_LEFT;
+#define ROW(y) ((uint32_t*)(src+y*stride))[0] =\
+               ((uint32_t*)(src+y*stride))[1] = 0x01010101 * l##y
+    ROW(0); ROW(1); ROW(2); ROW(3); ROW(4); ROW(5); ROW(6); ROW(7);
+#undef ROW
+}
+static void pred8x8l_vertical_c(uint8_t *src, int has_topleft, int has_topright, int stride)
+{
+    int y;
+    PREDICT_8x8_LOAD_TOP;
+    src[0] = t0;
+    src[1] = t1;
+    src[2] = t2;
+    src[3] = t3;
+    src[4] = t4;
+    src[5] = t5;
+    src[6] = t6;
+    src[7] = t7;
+    for( y = 1; y < 8; y++ )
+        *(uint64_t*)(src+y*stride) = *(uint64_t*)src;
+}
+static void pred8x8l_down_left_c(uint8_t *src, int has_topleft, int has_topright, int stride)
+{
+    PREDICT_8x8_LOAD_TOP;
+    PREDICT_8x8_LOAD_TOPRIGHT;
+    SRC(0,0)= (t0 + 2*t1 + t2 + 2) >> 2;
+    SRC(0,1)=SRC(1,0)= (t1 + 2*t2 + t3 + 2) >> 2;
+    SRC(0,2)=SRC(1,1)=SRC(2,0)= (t2 + 2*t3 + t4 + 2) >> 2;
+    SRC(0,3)=SRC(1,2)=SRC(2,1)=SRC(3,0)= (t3 + 2*t4 + t5 + 2) >> 2;
+    SRC(0,4)=SRC(1,3)=SRC(2,2)=SRC(3,1)=SRC(4,0)= (t4 + 2*t5 + t6 + 2) >> 2;
+    SRC(0,5)=SRC(1,4)=SRC(2,3)=SRC(3,2)=SRC(4,1)=SRC(5,0)= (t5 + 2*t6 + t7 + 2) >> 2;
+    SRC(0,6)=SRC(1,5)=SRC(2,4)=SRC(3,3)=SRC(4,2)=SRC(5,1)=SRC(6,0)= (t6 + 2*t7 + t8 + 2) >> 2;
+    SRC(0,7)=SRC(1,6)=SRC(2,5)=SRC(3,4)=SRC(4,3)=SRC(5,2)=SRC(6,1)=SRC(7,0)= (t7 + 2*t8 + t9 + 2) >> 2;
+    SRC(1,7)=SRC(2,6)=SRC(3,5)=SRC(4,4)=SRC(5,3)=SRC(6,2)=SRC(7,1)= (t8 + 2*t9 + t10 + 2) >> 2;
+    SRC(2,7)=SRC(3,6)=SRC(4,5)=SRC(5,4)=SRC(6,3)=SRC(7,2)= (t9 + 2*t10 + t11 + 2) >> 2;
+    SRC(3,7)=SRC(4,6)=SRC(5,5)=SRC(6,4)=SRC(7,3)= (t10 + 2*t11 + t12 + 2) >> 2;
+    SRC(4,7)=SRC(5,6)=SRC(6,5)=SRC(7,4)= (t11 + 2*t12 + t13 + 2) >> 2;
+    SRC(5,7)=SRC(6,6)=SRC(7,5)= (t12 + 2*t13 + t14 + 2) >> 2;
+    SRC(6,7)=SRC(7,6)= (t13 + 2*t14 + t15 + 2) >> 2;
+    SRC(7,7)= (t14 + 3*t15 + 2) >> 2;
+}
+static void pred8x8l_down_right_c(uint8_t *src, int has_topleft, int has_topright, int stride)
+{
+    PREDICT_8x8_LOAD_TOP;
+    PREDICT_8x8_LOAD_LEFT;
+    PREDICT_8x8_LOAD_TOPLEFT;
+    SRC(0,7)= (l7 + 2*l6 + l5 + 2) >> 2;
+    SRC(0,6)=SRC(1,7)= (l6 + 2*l5 + l4 + 2) >> 2;
+    SRC(0,5)=SRC(1,6)=SRC(2,7)= (l5 + 2*l4 + l3 + 2) >> 2;
+    SRC(0,4)=SRC(1,5)=SRC(2,6)=SRC(3,7)= (l4 + 2*l3 + l2 + 2) >> 2;
+    SRC(0,3)=SRC(1,4)=SRC(2,5)=SRC(3,6)=SRC(4,7)= (l3 + 2*l2 + l1 + 2) >> 2;
+    SRC(0,2)=SRC(1,3)=SRC(2,4)=SRC(3,5)=SRC(4,6)=SRC(5,7)= (l2 + 2*l1 + l0 + 2) >> 2;
+    SRC(0,1)=SRC(1,2)=SRC(2,3)=SRC(3,4)=SRC(4,5)=SRC(5,6)=SRC(6,7)= (l1 + 2*l0 + lt + 2) >> 2;
+    SRC(0,0)=SRC(1,1)=SRC(2,2)=SRC(3,3)=SRC(4,4)=SRC(5,5)=SRC(6,6)=SRC(7,7)= (l0 + 2*lt + t0 + 2) >> 2;
+    SRC(1,0)=SRC(2,1)=SRC(3,2)=SRC(4,3)=SRC(5,4)=SRC(6,5)=SRC(7,6)= (lt + 2*t0 + t1 + 2) >> 2;
+    SRC(2,0)=SRC(3,1)=SRC(4,2)=SRC(5,3)=SRC(6,4)=SRC(7,5)= (t0 + 2*t1 + t2 + 2) >> 2;
+    SRC(3,0)=SRC(4,1)=SRC(5,2)=SRC(6,3)=SRC(7,4)= (t1 + 2*t2 + t3 + 2) >> 2;
+    SRC(4,0)=SRC(5,1)=SRC(6,2)=SRC(7,3)= (t2 + 2*t3 + t4 + 2) >> 2;
+    SRC(5,0)=SRC(6,1)=SRC(7,2)= (t3 + 2*t4 + t5 + 2) >> 2;
+    SRC(6,0)=SRC(7,1)= (t4 + 2*t5 + t6 + 2) >> 2;
+    SRC(7,0)= (t5 + 2*t6 + t7 + 2) >> 2;
+
+}
+static void pred8x8l_vertical_right_c(uint8_t *src, int has_topleft, int has_topright, int stride)
+{
+    PREDICT_8x8_LOAD_TOP;
+    PREDICT_8x8_LOAD_LEFT;
+    PREDICT_8x8_LOAD_TOPLEFT;
+    SRC(0,6)= (l5 + 2*l4 + l3 + 2) >> 2;
+    SRC(0,7)= (l6 + 2*l5 + l4 + 2) >> 2;
+    SRC(0,4)=SRC(1,6)= (l3 + 2*l2 + l1 + 2) >> 2;
+    SRC(0,5)=SRC(1,7)= (l4 + 2*l3 + l2 + 2) >> 2;
+    SRC(0,2)=SRC(1,4)=SRC(2,6)= (l1 + 2*l0 + lt + 2) >> 2;
+    SRC(0,3)=SRC(1,5)=SRC(2,7)= (l2 + 2*l1 + l0 + 2) >> 2;
+    SRC(0,1)=SRC(1,3)=SRC(2,5)=SRC(3,7)= (l0 + 2*lt + t0 + 2) >> 2;
+    SRC(0,0)=SRC(1,2)=SRC(2,4)=SRC(3,6)= (lt + t0 + 1) >> 1;
+    SRC(1,1)=SRC(2,3)=SRC(3,5)=SRC(4,7)= (lt + 2*t0 + t1 + 2) >> 2;
+    SRC(1,0)=SRC(2,2)=SRC(3,4)=SRC(4,6)= (t0 + t1 + 1) >> 1;
+    SRC(2,1)=SRC(3,3)=SRC(4,5)=SRC(5,7)= (t0 + 2*t1 + t2 + 2) >> 2;
+    SRC(2,0)=SRC(3,2)=SRC(4,4)=SRC(5,6)= (t1 + t2 + 1) >> 1;
+    SRC(3,1)=SRC(4,3)=SRC(5,5)=SRC(6,7)= (t1 + 2*t2 + t3 + 2) >> 2;
+    SRC(3,0)=SRC(4,2)=SRC(5,4)=SRC(6,6)= (t2 + t3 + 1) >> 1;
+    SRC(4,1)=SRC(5,3)=SRC(6,5)=SRC(7,7)= (t2 + 2*t3 + t4 + 2) >> 2;
+    SRC(4,0)=SRC(5,2)=SRC(6,4)=SRC(7,6)= (t3 + t4 + 1) >> 1;
+    SRC(5,1)=SRC(6,3)=SRC(7,5)= (t3 + 2*t4 + t5 + 2) >> 2;
+    SRC(5,0)=SRC(6,2)=SRC(7,4)= (t4 + t5 + 1) >> 1;
+    SRC(6,1)=SRC(7,3)= (t4 + 2*t5 + t6 + 2) >> 2;
+    SRC(6,0)=SRC(7,2)= (t5 + t6 + 1) >> 1;
+    SRC(7,1)= (t5 + 2*t6 + t7 + 2) >> 2;
+    SRC(7,0)= (t6 + t7 + 1) >> 1;
+}
+static void pred8x8l_horizontal_down_c(uint8_t *src, int has_topleft, int has_topright, int stride)
+{
+    PREDICT_8x8_LOAD_TOP;
+    PREDICT_8x8_LOAD_LEFT;
+    PREDICT_8x8_LOAD_TOPLEFT;
+    SRC(0,7)= (l6 + l7 + 1) >> 1;
+    SRC(1,7)= (l5 + 2*l6 + l7 + 2) >> 2;
+    SRC(0,6)=SRC(2,7)= (l5 + l6 + 1) >> 1;
+    SRC(1,6)=SRC(3,7)= (l4 + 2*l5 + l6 + 2) >> 2;
+    SRC(0,5)=SRC(2,6)=SRC(4,7)= (l4 + l5 + 1) >> 1;
+    SRC(1,5)=SRC(3,6)=SRC(5,7)= (l3 + 2*l4 + l5 + 2) >> 2;
+    SRC(0,4)=SRC(2,5)=SRC(4,6)=SRC(6,7)= (l3 + l4 + 1) >> 1;
+    SRC(1,4)=SRC(3,5)=SRC(5,6)=SRC(7,7)= (l2 + 2*l3 + l4 + 2) >> 2;
+    SRC(0,3)=SRC(2,4)=SRC(4,5)=SRC(6,6)= (l2 + l3 + 1) >> 1;
+    SRC(1,3)=SRC(3,4)=SRC(5,5)=SRC(7,6)= (l1 + 2*l2 + l3 + 2) >> 2;
+    SRC(0,2)=SRC(2,3)=SRC(4,4)=SRC(6,5)= (l1 + l2 + 1) >> 1;
+    SRC(1,2)=SRC(3,3)=SRC(5,4)=SRC(7,5)= (l0 + 2*l1 + l2 + 2) >> 2;
+    SRC(0,1)=SRC(2,2)=SRC(4,3)=SRC(6,4)= (l0 + l1 + 1) >> 1;
+    SRC(1,1)=SRC(3,2)=SRC(5,3)=SRC(7,4)= (lt + 2*l0 + l1 + 2) >> 2;
+    SRC(0,0)=SRC(2,1)=SRC(4,2)=SRC(6,3)= (lt + l0 + 1) >> 1;
+    SRC(1,0)=SRC(3,1)=SRC(5,2)=SRC(7,3)= (l0 + 2*lt + t0 + 2) >> 2;
+    SRC(2,0)=SRC(4,1)=SRC(6,2)= (t1 + 2*t0 + lt + 2) >> 2;
+    SRC(3,0)=SRC(5,1)=SRC(7,2)= (t2 + 2*t1 + t0 + 2) >> 2;
+    SRC(4,0)=SRC(6,1)= (t3 + 2*t2 + t1 + 2) >> 2;
+    SRC(5,0)=SRC(7,1)= (t4 + 2*t3 + t2 + 2) >> 2;
+    SRC(6,0)= (t5 + 2*t4 + t3 + 2) >> 2;
+    SRC(7,0)= (t6 + 2*t5 + t4 + 2) >> 2;
+}
+static void pred8x8l_vertical_left_c(uint8_t *src, int has_topleft, int has_topright, int stride)
+{
+    PREDICT_8x8_LOAD_TOP;
+    PREDICT_8x8_LOAD_TOPRIGHT;
+    SRC(0,0)= (t0 + t1 + 1) >> 1;
+    SRC(0,1)= (t0 + 2*t1 + t2 + 2) >> 2;
+    SRC(0,2)=SRC(1,0)= (t1 + t2 + 1) >> 1;
+    SRC(0,3)=SRC(1,1)= (t1 + 2*t2 + t3 + 2) >> 2;
+    SRC(0,4)=SRC(1,2)=SRC(2,0)= (t2 + t3 + 1) >> 1;
+    SRC(0,5)=SRC(1,3)=SRC(2,1)= (t2 + 2*t3 + t4 + 2) >> 2;
+    SRC(0,6)=SRC(1,4)=SRC(2,2)=SRC(3,0)= (t3 + t4 + 1) >> 1;
+    SRC(0,7)=SRC(1,5)=SRC(2,3)=SRC(3,1)= (t3 + 2*t4 + t5 + 2) >> 2;
+    SRC(1,6)=SRC(2,4)=SRC(3,2)=SRC(4,0)= (t4 + t5 + 1) >> 1;
+    SRC(1,7)=SRC(2,5)=SRC(3,3)=SRC(4,1)= (t4 + 2*t5 + t6 + 2) >> 2;
+    SRC(2,6)=SRC(3,4)=SRC(4,2)=SRC(5,0)= (t5 + t6 + 1) >> 1;
+    SRC(2,7)=SRC(3,5)=SRC(4,3)=SRC(5,1)= (t5 + 2*t6 + t7 + 2) >> 2;
+    SRC(3,6)=SRC(4,4)=SRC(5,2)=SRC(6,0)= (t6 + t7 + 1) >> 1;
+    SRC(3,7)=SRC(4,5)=SRC(5,3)=SRC(6,1)= (t6 + 2*t7 + t8 + 2) >> 2;
+    SRC(4,6)=SRC(5,4)=SRC(6,2)=SRC(7,0)= (t7 + t8 + 1) >> 1;
+    SRC(4,7)=SRC(5,5)=SRC(6,3)=SRC(7,1)= (t7 + 2*t8 + t9 + 2) >> 2;
+    SRC(5,6)=SRC(6,4)=SRC(7,2)= (t8 + t9 + 1) >> 1;
+    SRC(5,7)=SRC(6,5)=SRC(7,3)= (t8 + 2*t9 + t10 + 2) >> 2;
+    SRC(6,6)=SRC(7,4)= (t9 + t10 + 1) >> 1;
+    SRC(6,7)=SRC(7,5)= (t9 + 2*t10 + t11 + 2) >> 2;
+    SRC(7,6)= (t10 + t11 + 1) >> 1;
+    SRC(7,7)= (t10 + 2*t11 + t12 + 2) >> 2;
+}
+static void pred8x8l_horizontal_up_c(uint8_t *src, int has_topleft, int has_topright, int stride)
+{
+    PREDICT_8x8_LOAD_LEFT;
+    SRC(0,0)= (l0 + l1 + 1) >> 1;
+    SRC(1,0)= (l0 + 2*l1 + l2 + 2) >> 2;
+    SRC(0,1)=SRC(2,0)= (l1 + l2 + 1) >> 1;
+    SRC(1,1)=SRC(3,0)= (l1 + 2*l2 + l3 + 2) >> 2;
+    SRC(0,2)=SRC(2,1)=SRC(4,0)= (l2 + l3 + 1) >> 1;
+    SRC(1,2)=SRC(3,1)=SRC(5,0)= (l2 + 2*l3 + l4 + 2) >> 2;
+    SRC(0,3)=SRC(2,2)=SRC(4,1)=SRC(6,0)= (l3 + l4 + 1) >> 1;
+    SRC(1,3)=SRC(3,2)=SRC(5,1)=SRC(7,0)= (l3 + 2*l4 + l5 + 2) >> 2;
+    SRC(0,4)=SRC(2,3)=SRC(4,2)=SRC(6,1)= (l4 + l5 + 1) >> 1;
+    SRC(1,4)=SRC(3,3)=SRC(5,2)=SRC(7,1)= (l4 + 2*l5 + l6 + 2) >> 2;
+    SRC(0,5)=SRC(2,4)=SRC(4,3)=SRC(6,2)= (l5 + l6 + 1) >> 1;
+    SRC(1,5)=SRC(3,4)=SRC(5,3)=SRC(7,2)= (l5 + 2*l6 + l7 + 2) >> 2;
+    SRC(0,6)=SRC(2,5)=SRC(4,4)=SRC(6,3)= (l6 + l7 + 1) >> 1;
+    SRC(1,6)=SRC(3,5)=SRC(5,4)=SRC(7,3)= (l6 + 3*l7 + 2) >> 2;
+    SRC(0,7)=SRC(1,7)=SRC(2,6)=SRC(2,7)=SRC(3,6)=
+    SRC(3,7)=SRC(4,5)=SRC(4,6)=SRC(4,7)=SRC(5,5)=
+    SRC(5,6)=SRC(5,7)=SRC(6,4)=SRC(6,5)=SRC(6,6)=
+    SRC(6,7)=SRC(7,4)=SRC(7,5)=SRC(7,6)=SRC(7,7)= l7;
+}
+#undef PREDICT_8x8_LOAD_LEFT
+#undef PREDICT_8x8_LOAD_TOP
+#undef PREDICT_8x8_LOAD_TOPLEFT
+#undef PREDICT_8x8_LOAD_TOPRIGHT
+#undef PREDICT_8x8_DC
+#undef PTR
+#undef PT
+#undef PL
+#undef SRC
+
+/**
+ * Sets the intra prediction function pointers.
+ */
+void ff_h264_pred_init(H264PredContext *h, int codec_id){
+//    MpegEncContext * const s = &h->s;
+
+    if(codec_id != CODEC_ID_RV40){
+        h->pred4x4[VERT_PRED           ]= pred4x4_vertical_c;
+        h->pred4x4[HOR_PRED            ]= pred4x4_horizontal_c;
+        h->pred4x4[DC_PRED             ]= pred4x4_dc_c;
+        if(codec_id == CODEC_ID_SVQ3)
+            h->pred4x4[DIAG_DOWN_LEFT_PRED ]= pred4x4_down_left_svq3_c;
+        else
+            h->pred4x4[DIAG_DOWN_LEFT_PRED ]= pred4x4_down_left_c;
+        h->pred4x4[DIAG_DOWN_RIGHT_PRED]= pred4x4_down_right_c;
+        h->pred4x4[VERT_RIGHT_PRED     ]= pred4x4_vertical_right_c;
+        h->pred4x4[HOR_DOWN_PRED       ]= pred4x4_horizontal_down_c;
+        h->pred4x4[VERT_LEFT_PRED      ]= pred4x4_vertical_left_c;
+        h->pred4x4[HOR_UP_PRED         ]= pred4x4_horizontal_up_c;
+        h->pred4x4[LEFT_DC_PRED        ]= pred4x4_left_dc_c;
+        h->pred4x4[TOP_DC_PRED         ]= pred4x4_top_dc_c;
+        h->pred4x4[DC_128_PRED         ]= pred4x4_128_dc_c;
+    }else{
+        h->pred4x4[VERT_PRED           ]= pred4x4_vertical_c;
+        h->pred4x4[HOR_PRED            ]= pred4x4_horizontal_c;
+        h->pred4x4[DC_PRED             ]= pred4x4_dc_c;
+        h->pred4x4[DIAG_DOWN_LEFT_PRED ]= pred4x4_down_left_rv40_c;
+        h->pred4x4[DIAG_DOWN_RIGHT_PRED]= pred4x4_down_right_c;
+        h->pred4x4[VERT_RIGHT_PRED     ]= pred4x4_vertical_right_c;
+        h->pred4x4[HOR_DOWN_PRED       ]= pred4x4_horizontal_down_c;
+        h->pred4x4[VERT_LEFT_PRED      ]= pred4x4_vertical_left_rv40_c;
+        h->pred4x4[HOR_UP_PRED         ]= pred4x4_horizontal_up_rv40_c;
+        h->pred4x4[LEFT_DC_PRED        ]= pred4x4_left_dc_c;
+        h->pred4x4[TOP_DC_PRED         ]= pred4x4_top_dc_c;
+        h->pred4x4[DC_128_PRED         ]= pred4x4_128_dc_c;
+        h->pred4x4[DIAG_DOWN_LEFT_PRED_RV40_NODOWN]= pred4x4_down_left_rv40_nodown_c;
+        h->pred4x4[HOR_UP_PRED_RV40_NODOWN]= pred4x4_horizontal_up_rv40_nodown_c;
+        h->pred4x4[VERT_LEFT_PRED_RV40_NODOWN]= pred4x4_vertical_left_rv40_nodown_c;
+    }
+
+    h->pred8x8l[VERT_PRED           ]= pred8x8l_vertical_c;
+    h->pred8x8l[HOR_PRED            ]= pred8x8l_horizontal_c;
+    h->pred8x8l[DC_PRED             ]= pred8x8l_dc_c;
+    h->pred8x8l[DIAG_DOWN_LEFT_PRED ]= pred8x8l_down_left_c;
+    h->pred8x8l[DIAG_DOWN_RIGHT_PRED]= pred8x8l_down_right_c;
+    h->pred8x8l[VERT_RIGHT_PRED     ]= pred8x8l_vertical_right_c;
+    h->pred8x8l[HOR_DOWN_PRED       ]= pred8x8l_horizontal_down_c;
+    h->pred8x8l[VERT_LEFT_PRED      ]= pred8x8l_vertical_left_c;
+    h->pred8x8l[HOR_UP_PRED         ]= pred8x8l_horizontal_up_c;
+    h->pred8x8l[LEFT_DC_PRED        ]= pred8x8l_left_dc_c;
+    h->pred8x8l[TOP_DC_PRED         ]= pred8x8l_top_dc_c;
+    h->pred8x8l[DC_128_PRED         ]= pred8x8l_128_dc_c;
+
+    h->pred8x8[VERT_PRED8x8   ]= pred8x8_vertical_c;
+    h->pred8x8[HOR_PRED8x8    ]= pred8x8_horizontal_c;
+    h->pred8x8[PLANE_PRED8x8  ]= pred8x8_plane_c;
+    if(codec_id != CODEC_ID_RV40){
+        h->pred8x8[DC_PRED8x8     ]= pred8x8_dc_c;
+        h->pred8x8[LEFT_DC_PRED8x8]= pred8x8_left_dc_c;
+        h->pred8x8[TOP_DC_PRED8x8 ]= pred8x8_top_dc_c;
+    }else{
+        h->pred8x8[DC_PRED8x8     ]= pred8x8_dc_rv40_c;
+        h->pred8x8[LEFT_DC_PRED8x8]= pred8x8_left_dc_rv40_c;
+        h->pred8x8[TOP_DC_PRED8x8 ]= pred8x8_top_dc_rv40_c;
+    }
+    h->pred8x8[DC_128_PRED8x8 ]= pred8x8_128_dc_c;
+
+    h->pred16x16[DC_PRED8x8     ]= pred16x16_dc_c;
+    h->pred16x16[VERT_PRED8x8   ]= pred16x16_vertical_c;
+    h->pred16x16[HOR_PRED8x8    ]= pred16x16_horizontal_c;
+    h->pred16x16[PLANE_PRED8x8  ]= pred16x16_plane_c;
+    switch(codec_id){
+    case CODEC_ID_SVQ3:
+       h->pred16x16[PLANE_PRED8x8  ]= pred16x16_plane_svq3_c;
+       break;
+    case CODEC_ID_RV40:
+       h->pred16x16[PLANE_PRED8x8  ]= pred16x16_plane_rv40_c;
+       break;
+    default:
+       h->pred16x16[PLANE_PRED8x8  ]= pred16x16_plane_c;
+    }
+    h->pred16x16[LEFT_DC_PRED8x8]= pred16x16_left_dc_c;
+    h->pred16x16[TOP_DC_PRED8x8 ]= pred16x16_top_dc_c;
+    h->pred16x16[DC_128_PRED8x8 ]= pred16x16_128_dc_c;
+}

Added: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/h264pred.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/h264pred.h	2008-07-24 11:49:40 UTC (rev 4280)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/h264pred.h	2008-07-24 18:20:17 UTC (rev 4281)
@@ -0,0 +1,77 @@
+/*
+ * H.26L/H.264/AVC/JVT/14496-10/... encoder/decoder
+ * Copyright (c) 2003 Michael Niedermayer <michaelni at gmx.at>
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+/**
+ * @file h264pred.h
+ * H.264 / AVC / MPEG4 prediction functions.
+ * @author Michael Niedermayer <michaelni at gmx.at>
+ */
+
+#ifndef FFMPEG_H264PRED_H
+#define FFMPEG_H264PRED_H
+
+#include "common.h"
+
+/**
+ * Prediction types
+ */
+//@{
+#define VERT_PRED             0
+#define HOR_PRED              1
+#define DC_PRED               2
+#define DIAG_DOWN_LEFT_PRED   3
+#define DIAG_DOWN_RIGHT_PRED  4
+#define VERT_RIGHT_PRED       5
+#define HOR_DOWN_PRED         6
+#define VERT_LEFT_PRED        7
+#define HOR_UP_PRED           8
+
+#define LEFT_DC_PRED          9
+#define TOP_DC_PRED           10
+#define DC_128_PRED           11
+
+#define DIAG_DOWN_LEFT_PRED_RV40_NODOWN   12
+#define HOR_UP_PRED_RV40_NODOWN           13
+#define VERT_LEFT_PRED_RV40_NODOWN        14
+
+#define DC_PRED8x8            0
+#define HOR_PRED8x8           1
+#define VERT_PRED8x8          2
+#define PLANE_PRED8x8         3
+
+#define LEFT_DC_PRED8x8       4
+#define TOP_DC_PRED8x8        5
+#define DC_128_PRED8x8        6
+//@}
+
+/**
+ * Context for storing H.264 prediction functions
+ */
+typedef struct H264PredContext{
+    void (*pred4x4  [9+3+3])(uint8_t *src, uint8_t *topright, int stride);//FIXME move to dsp?
+    void (*pred8x8l [9+3])(uint8_t *src, int topleft, int topright, int stride);
+    void (*pred8x8  [4+3])(uint8_t *src, int stride);
+    void (*pred16x16[4+3])(uint8_t *src, int stride);
+}H264PredContext;
+
+void ff_h264_pred_init(H264PredContext *h, int codec_id);
+
+#endif /* FFMPEG_H264PRED_H */

Added: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/rectangle.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/rectangle.h	2008-07-24 11:49:40 UTC (rev 4280)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/rectangle.h	2008-07-24 18:20:17 UTC (rev 4281)
@@ -0,0 +1,121 @@
+/*
+ * rectangle filling function
+ * Copyright (c) 2003 Michael Niedermayer <michaelni at gmx.at>
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+/**
+ * @file rectangle.h
+ * useful rectangle filling function
+ * @author Michael Niedermayer <michaelni at gmx.at>
+ */
+
+#ifndef FFMPEG_RECTANGLE_H
+#define FFMPEG_RECTANGLE_H
+
+#include "common.h"
+
+/**
+ * fill a rectangle.
+ * @param h height of the rectangle, should be a constant
+ * @param w width of the rectangle, should be a constant
+ * @param size the size of val (1 or 4), should be a constant
+ */
+static av_always_inline void fill_rectangle(void *vp, int w, int h, int stride, uint32_t val, int size){
+    uint8_t *p= (uint8_t*)vp;
+    assert(size==1 || size==4);
+    assert(w<=4);
+
+    w      *= size;
+    stride *= size;
+
+    assert((((long)vp)&(FFMIN(w, STRIDE_ALIGN)-1)) == 0);
+    assert((stride&(w-1))==0);
+    if(w==2){
+        const uint16_t v= size==4 ? val : val*0x0101;
+        *(uint16_t*)(p + 0*stride)= v;
+        if(h==1) return;
+        *(uint16_t*)(p + 1*stride)= v;
+        if(h==2) return;
+        *(uint16_t*)(p + 2*stride)= v;
+        *(uint16_t*)(p + 3*stride)= v;
+    }else if(w==4){
+        const uint32_t v= size==4 ? val : val*0x01010101;
+        *(uint32_t*)(p + 0*stride)= v;
+        if(h==1) return;
+        *(uint32_t*)(p + 1*stride)= v;
+        if(h==2) return;
+        *(uint32_t*)(p + 2*stride)= v;
+        *(uint32_t*)(p + 3*stride)= v;
+    }else if(w==8){
+    //gcc can't optimize 64bit math on x86_32
+#ifdef HAVE_FAST_64BIT
+        const uint64_t v= val*0x0100000001ULL;
+        *(uint64_t*)(p + 0*stride)= v;
+        if(h==1) return;
+        *(uint64_t*)(p + 1*stride)= v;
+        if(h==2) return;
+        *(uint64_t*)(p + 2*stride)= v;
+        *(uint64_t*)(p + 3*stride)= v;
+    }else if(w==16){
+        const uint64_t v= val*0x0100000001ULL;
+        *(uint64_t*)(p + 0+0*stride)= v;
+        *(uint64_t*)(p + 8+0*stride)= v;
+        *(uint64_t*)(p + 0+1*stride)= v;
+        *(uint64_t*)(p + 8+1*stride)= v;
+        if(h==2) return;
+        *(uint64_t*)(p + 0+2*stride)= v;
+        *(uint64_t*)(p + 8+2*stride)= v;
+        *(uint64_t*)(p + 0+3*stride)= v;
+        *(uint64_t*)(p + 8+3*stride)= v;
+#else
+        *(uint32_t*)(p + 0+0*stride)= val;
+        *(uint32_t*)(p + 4+0*stride)= val;
+        if(h==1) return;
+        *(uint32_t*)(p + 0+1*stride)= val;
+        *(uint32_t*)(p + 4+1*stride)= val;
+        if(h==2) return;
+        *(uint32_t*)(p + 0+2*stride)= val;
+        *(uint32_t*)(p + 4+2*stride)= val;
+        *(uint32_t*)(p + 0+3*stride)= val;
+        *(uint32_t*)(p + 4+3*stride)= val;
+    }else if(w==16){
+        *(uint32_t*)(p + 0+0*stride)= val;
+        *(uint32_t*)(p + 4+0*stride)= val;
+        *(uint32_t*)(p + 8+0*stride)= val;
+        *(uint32_t*)(p +12+0*stride)= val;
+        *(uint32_t*)(p + 0+1*stride)= val;
+        *(uint32_t*)(p + 4+1*stride)= val;
+        *(uint32_t*)(p + 8+1*stride)= val;
+        *(uint32_t*)(p +12+1*stride)= val;
+        if(h==2) return;
+        *(uint32_t*)(p + 0+2*stride)= val;
+        *(uint32_t*)(p + 4+2*stride)= val;
+        *(uint32_t*)(p + 8+2*stride)= val;
+        *(uint32_t*)(p +12+2*stride)= val;
+        *(uint32_t*)(p + 0+3*stride)= val;
+        *(uint32_t*)(p + 4+3*stride)= val;
+        *(uint32_t*)(p + 8+3*stride)= val;
+        *(uint32_t*)(p +12+3*stride)= val;
+#endif
+    }else
+        assert(0);
+    assert(h==4);
+}
+
+#endif /* FFMPEG_RECTANGLE_H */

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/svq3.c
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/svq3.c	2008-07-24 11:49:40 UTC (rev 4280)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/svq3.c	2008-07-24 18:20:17 UTC (rev 4281)
@@ -180,34 +180,6 @@
     }
 }
 
-static void pred4x4_down_left_svq3_c(uint8_t *src, uint8_t *topright, int stride){
-    LOAD_TOP_EDGE
-    LOAD_LEFT_EDGE
-    const av_unused int unu0= t0;
-    const av_unused int unu1= l0;
-
-    src[0+0*stride]=(l1 + t1)>>1;
-    src[1+0*stride]=
-    src[0+1*stride]=(l2 + t2)>>1;
-    src[2+0*stride]=
-    src[1+1*stride]=
-    src[0+2*stride]=
-    src[3+0*stride]=
-    src[2+1*stride]=
-    src[1+2*stride]=
-    src[0+3*stride]=
-    src[3+1*stride]=
-    src[2+2*stride]=
-    src[1+3*stride]=
-    src[3+2*stride]=
-    src[2+3*stride]=
-    src[3+3*stride]=(l3 + t3)>>1;
-}
-
-static void pred16x16_plane_svq3_c(uint8_t *src, int stride){
-    pred16x16_plane_compat_c(src, stride, 1);
-}
-
 static inline int svq3_decode_block (GetBitContext *gb, DCTELEM *block,
                                      int index, const int type) {
 
@@ -439,7 +411,7 @@
   uint32_t vlc;
   int8_t *top, *left;
   MpegEncContext *const s = (MpegEncContext *) h;
-  const int mb_xy = s->mb_x + s->mb_y*s->mb_stride;
+  const int mb_xy = h->mb_xy;
   const int b_xy = 4*s->mb_x + 4*s->mb_y*h->b_stride;
 
   h->top_samples_available        = (s->mb_y == 0) ? 0x33FF : 0xFFFF;
@@ -447,10 +419,10 @@
   h->topright_samples_available        = 0xFFFF;
 
   if (mb_type == 0) {           /* SKIP */
-    if (s->pict_type == P_TYPE || s->next_picture.mb_type[mb_xy] == -1) {
+    if (s->pict_type == FF_P_TYPE || s->next_picture.mb_type[mb_xy] == -1) {
       svq3_mc_dir_part (s, 16*s->mb_x, 16*s->mb_y, 16, 16, 0, 0, 0, 0, 0, 0);
 
-      if (s->pict_type == B_TYPE) {
+      if (s->pict_type == FF_B_TYPE) {
         svq3_mc_dir_part (s, 16*s->mb_x, 16*s->mb_y, 16, 16, 0, 0, 0, 0, 1, 1);
       }
 
@@ -465,9 +437,9 @@
       mb_type = MB_TYPE_16x16;
     }
   } else if (mb_type < 8) {     /* INTER */
-    if (h->thirdpel_flag && h->halfpel_flag == !get_bits (&s->gb, 1)) {
+    if (h->thirdpel_flag && h->halfpel_flag == !get_bits1 (&s->gb)) {
       mode = THIRDPEL_MODE;
-    } else if (h->halfpel_flag && h->thirdpel_flag == !get_bits (&s->gb, 1)) {
+    } else if (h->halfpel_flag && h->thirdpel_flag == !get_bits1 (&s->gb)) {
       mode = HALFPEL_MODE;
     } else {
       mode = FULLPEL_MODE;
@@ -511,15 +483,15 @@
       }else
         memset (&h->ref_cache[m][scan8[0] - 1*8 - 1], PART_NOT_AVAILABLE, 8);
 
-      if (s->pict_type != B_TYPE)
+      if (s->pict_type != FF_B_TYPE)
         break;
     }
 
     /* decode motion vector(s) and form prediction(s) */
-    if (s->pict_type == P_TYPE) {
+    if (s->pict_type == FF_P_TYPE) {
       if(svq3_mc_dir (h, (mb_type - 1), mode, 0, 0) < 0)
         return -1;
-    } else {        /* B_TYPE */
+    } else {        /* FF_B_TYPE */
       if (mb_type != 2) {
         if(svq3_mc_dir (h, 0, mode, 0, 0) < 0)
           return -1;
@@ -618,11 +590,11 @@
     mb_type = MB_TYPE_INTRA16x16;
   }
 
-  if (!IS_INTER(mb_type) && s->pict_type != I_TYPE) {
+  if (!IS_INTER(mb_type) && s->pict_type != FF_I_TYPE) {
     for (i=0; i < 4; i++) {
       memset (s->current_picture.motion_val[0][b_xy + i*h->b_stride], 0, 4*2*sizeof(int16_t));
     }
-    if (s->pict_type == B_TYPE) {
+    if (s->pict_type == FF_B_TYPE) {
       for (i=0; i < 4; i++) {
         memset (s->current_picture.motion_val[1][b_xy + i*h->b_stride], 0, 4*2*sizeof(int16_t));
       }
@@ -631,12 +603,12 @@
   if (!IS_INTRA4x4(mb_type)) {
     memset (h->intra4x4_pred_mode[mb_xy], DC_PRED, 8);
   }
-  if (!IS_SKIP(mb_type) || s->pict_type == B_TYPE) {
+  if (!IS_SKIP(mb_type) || s->pict_type == FF_B_TYPE) {
     memset (h->non_zero_count_cache + 8, 0, 4*9*sizeof(uint8_t));
     s->dsp.clear_blocks(h->mb);
   }
 
-  if (!IS_INTRA16x16(mb_type) && (!IS_SKIP(mb_type) || s->pict_type == B_TYPE)) {
+  if (!IS_INTRA16x16(mb_type) && (!IS_SKIP(mb_type) || s->pict_type == FF_B_TYPE)) {
     if ((vlc = svq3_get_ue_golomb (&s->gb)) >= 48){
       av_log(h->s.avctx, AV_LOG_ERROR, "cbp_vlc=%d\n", vlc);
       return -1;
@@ -644,7 +616,7 @@
 
     cbp = IS_INTRA(mb_type) ? golomb_to_intra4x4_cbp[vlc] : golomb_to_inter_cbp[vlc];
   }
-  if (IS_INTRA16x16(mb_type) || (s->pict_type != I_TYPE && s->adaptive_quant && cbp)) {
+  if (IS_INTRA16x16(mb_type) || (s->pict_type != FF_I_TYPE && s->adaptive_quant && cbp)) {
     s->qscale += svq3_get_se_golomb (&s->gb);
 
     if (s->qscale > 31){
@@ -709,7 +681,7 @@
 
 static int svq3_decode_slice_header (H264Context *h) {
   MpegEncContext *const s = (MpegEncContext *) h;
-  const int mb_xy = s->mb_x + s->mb_y*s->mb_stride;
+  const int mb_xy = h->mb_xy;
   int i, header;
 
   header = get_bits (&s->gb, 8);
@@ -748,7 +720,7 @@
     i = (s->mb_num < 64) ? 6 : (1 + av_log2 (s->mb_num - 1));
     s->mb_skip_run = get_bits (&s->gb, i) - (s->mb_x + (s->mb_y * s->mb_width));
   } else {
-    get_bits1 (&s->gb);
+    skip_bits1 (&s->gb);
     s->mb_skip_run = 0;
   }
 
@@ -757,17 +729,17 @@
   s->adaptive_quant = get_bits1 (&s->gb);
 
   /* unknown fields */
-  get_bits1 (&s->gb);
+  skip_bits1 (&s->gb);
 
   if (h->unknown_svq3_flag) {
-    get_bits1 (&s->gb);
+    skip_bits1 (&s->gb);
   }
 
-  get_bits1 (&s->gb);
-  get_bits (&s->gb, 2);
+  skip_bits1 (&s->gb);
+  skip_bits (&s->gb, 2);
 
   while (get_bits1 (&s->gb)) {
-    get_bits (&s->gb, 8);
+    skip_bits (&s->gb, 8);
   }
 
   /* reset intra predictors and invalidate motion vector references */
@@ -788,7 +760,7 @@
 
 static int svq3_decode_frame (AVCodecContext *avctx,
                               void *data, int *data_size,
-                              uint8_t *buf, int buf_size) {
+                              const uint8_t *buf, int buf_size) {
   MpegEncContext *const s = avctx->priv_data;
   H264Context *const h = avctx->priv_data;
   int m, mb_type;
@@ -802,8 +774,6 @@
   if (!s->context_initialized) {
     s->width = avctx->width;
     s->height = avctx->height;
-    h->pred4x4[DIAG_DOWN_LEFT_PRED] = pred4x4_down_left_svq3_c;
-    h->pred16x16[PLANE_PRED8x8] = pred16x16_plane_svq3_c;
     h->halfpel_flag = 1;
     h->thirdpel_flag = 1;
     h->unknown_svq3_flag = 0;
@@ -834,26 +804,26 @@
 
       /* 'frame size code' and optional 'width, height' */
       if (get_bits (&gb, 3) == 7) {
-        get_bits (&gb, 12);
-        get_bits (&gb, 12);
+        skip_bits (&gb, 12);
+        skip_bits (&gb, 12);
       }
 
       h->halfpel_flag = get_bits1 (&gb);
       h->thirdpel_flag = get_bits1 (&gb);
 
       /* unknown fields */
-      get_bits1 (&gb);
-      get_bits1 (&gb);
-      get_bits1 (&gb);
-      get_bits1 (&gb);
+      skip_bits1 (&gb);
+      skip_bits1 (&gb);
+      skip_bits1 (&gb);
+      skip_bits1 (&gb);
 
       s->low_delay = get_bits1 (&gb);
 
       /* unknown field */
-      get_bits1 (&gb);
+      skip_bits1 (&gb);
 
       while (get_bits1 (&gb)) {
-        get_bits (&gb, 8);
+        skip_bits (&gb, 8);
       }
 
       h->unknown_svq3_flag = get_bits1 (&gb);
@@ -865,6 +835,7 @@
   if (buf_size == 0) {
     if (s->next_picture_ptr && !s->low_delay) {
       *(AVFrame *) data = *(AVFrame *) &s->next_picture;
+      s->next_picture_ptr= NULL;
       *data_size = sizeof(AVFrame);
     }
     return 0;
@@ -872,7 +843,7 @@
 
   init_get_bits (&s->gb, buf, 8*buf_size);
 
-  s->mb_x = s->mb_y = 0;
+  s->mb_x = s->mb_y = h->mb_xy = 0;
 
   if (svq3_decode_slice_header (h))
     return -1;
@@ -881,29 +852,29 @@
   s->picture_number = h->slice_num;
 
   if(avctx->debug&FF_DEBUG_PICT_INFO){
-      av_log(h->s.avctx, AV_LOG_DEBUG, "%c hpel:%d, tpel:%d aqp:%d qp:%d\n",
+      av_log(h->s.avctx, AV_LOG_DEBUG, "%c hpel:%d, tpel:%d aqp:%d qp:%d, slice_num:%02X\n",
       av_get_pict_type_char(s->pict_type), h->halfpel_flag, h->thirdpel_flag,
-      s->adaptive_quant, s->qscale
+      s->adaptive_quant, s->qscale, h->slice_num
       );
   }
 
   /* for hurry_up==5 */
   s->current_picture.pict_type = s->pict_type;
-  s->current_picture.key_frame = (s->pict_type == I_TYPE);
+  s->current_picture.key_frame = (s->pict_type == FF_I_TYPE);
 
   /* Skip B-frames if we do not have reference frames. */
-  if (s->last_picture_ptr == NULL && s->pict_type == B_TYPE) return 0;
+  if (s->last_picture_ptr == NULL && s->pict_type == FF_B_TYPE) return 0;
   /* Skip B-frames if we are in a hurry. */
-  if (avctx->hurry_up && s->pict_type == B_TYPE) return 0;
+  if (avctx->hurry_up && s->pict_type == FF_B_TYPE) return 0;
   /* Skip everything if we are in a hurry >= 5. */
   if (avctx->hurry_up >= 5) return 0;
-  if(  (avctx->skip_frame >= AVDISCARD_NONREF && s->pict_type==B_TYPE)
-     ||(avctx->skip_frame >= AVDISCARD_NONKEY && s->pict_type!=I_TYPE)
+  if(  (avctx->skip_frame >= AVDISCARD_NONREF && s->pict_type==FF_B_TYPE)
+     ||(avctx->skip_frame >= AVDISCARD_NONKEY && s->pict_type!=FF_I_TYPE)
      || avctx->skip_frame >= AVDISCARD_ALL)
       return 0;
 
   if (s->next_p_frame_damaged) {
-    if (s->pict_type == B_TYPE)
+    if (s->pict_type == FF_B_TYPE)
       return 0;
     else
       s->next_p_frame_damaged = 0;
@@ -912,7 +883,7 @@
   if (frame_start (h) < 0)
     return -1;
 
-  if (s->pict_type == B_TYPE) {
+  if (s->pict_type == FF_B_TYPE) {
     h->frame_num_offset = (h->slice_num - h->prev_frame_num);
 
     if (h->frame_num_offset < 0) {
@@ -945,6 +916,7 @@
 
   for (s->mb_y=0; s->mb_y < s->mb_height; s->mb_y++) {
     for (s->mb_x=0; s->mb_x < s->mb_width; s->mb_x++) {
+      h->mb_xy = s->mb_x + s->mb_y*s->mb_stride;
 
       if ( (get_bits_count(&s->gb) + 7) >= s->gb.size_in_bits &&
           ((get_bits_count(&s->gb) & 7) == 0 || show_bits (&s->gb, (-get_bits_count(&s->gb) & 7)) == 0)) {
@@ -960,9 +932,9 @@
 
       mb_type = svq3_get_ue_golomb (&s->gb);
 
-      if (s->pict_type == I_TYPE) {
+      if (s->pict_type == FF_I_TYPE) {
         mb_type += 8;
-      } else if (s->pict_type == B_TYPE && mb_type >= 4) {
+      } else if (s->pict_type == FF_B_TYPE && mb_type >= 4) {
         mb_type += 4;
       }
       if (mb_type > 33 || svq3_decode_mb (h, mb_type)) {
@@ -974,9 +946,9 @@
         hl_decode_mb (h);
       }
 
-      if (s->pict_type != B_TYPE && !s->low_delay) {
+      if (s->pict_type != FF_B_TYPE && !s->low_delay) {
         s->current_picture.mb_type[s->mb_x + s->mb_y*s->mb_stride] =
-                        (s->pict_type == P_TYPE && mb_type < 8) ? (mb_type - 1) : -1;
+                        (s->pict_type == FF_P_TYPE && mb_type < 8) ? (mb_type - 1) : -1;
       }
     }
 
@@ -985,7 +957,7 @@
 
   MPV_frame_end(s);
 
-  if (s->pict_type == B_TYPE || s->low_delay) {
+  if (s->pict_type == FF_B_TYPE || s->low_delay) {
     *(AVFrame *) data = *(AVFrame *) &s->current_picture;
   } else {
     *(AVFrame *) data = *(AVFrame *) &s->last_picture;

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/common.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/common.h	2008-07-24 11:49:40 UTC (rev 4280)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/common.h	2008-07-24 18:20:17 UTC (rev 4281)
@@ -81,7 +81,9 @@
 #define FFSIGN(a) ((a) > 0 ? 1 : -1)
 
 #define FFMAX(a,b) ((a) > (b) ? (a) : (b))
+#define FFMAX3(a,b,c) FFMAX(FFMAX(a,b),c)
 #define FFMIN(a,b) ((a) > (b) ? (b) : (a))
+#define FFMIN3(a,b,c) FFMIN(FFMIN(a,b),c)
 
 #define FFSWAP(type,a,b) do{type SWAP_tmp= b; b= a; a= SWAP_tmp;}while(0)
 

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/mem.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/mem.h	2008-07-24 11:49:40 UTC (rev 4280)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/mem.h	2008-07-24 18:20:17 UTC (rev 4281)
@@ -26,10 +26,20 @@
 #ifndef AV_MEM_H
 #define AV_MEM_H
 
-#ifdef __GNUC__
-  #define DECLARE_ALIGNED(n,t,v)       t v __attribute__ ((aligned (n)))
-#else
-  #define DECLARE_ALIGNED(n,t,v)      __declspec(align(n)) t v
+#ifdef __ICC
+    #define DECLARE_ALIGNED(n,t,v)      t v __attribute__ ((aligned (n)))
+    #define DECLARE_ASM_CONST(n,t,v)    const t __attribute__ ((aligned (n))) v
+#elif defined(__GNUC__)
+    #define DECLARE_ALIGNED(n,t,v)      t v __attribute__ ((aligned (n)))
+    #define DECLARE_ASM_CONST(n,t,v)    static const t v attribute_used __attribute__ ((aligned (n)))
+#elif defined(_MSC_VER)
+    #define DECLARE_ALIGNED(n,t,v)      __declspec(align(n)) t v
+    #define DECLARE_ASM_CONST(n,t,v)    __declspec(align(n)) static const t v
+#elif defined(HAVE_INLINE_ASM)
+    #error The asm code needs alignment, but we do not know how to do it for this compiler.
+#else
+    #define DECLARE_ALIGNED(n,t,v)      t v
+    #define DECLARE_ASM_CONST(n,t,v)    static const t v
 #endif
 
 /**



From gruntster at mail.berlios.de  Fri Jul 25 04:41:35 2008
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Fri, 25 Jul 2008 04:41:35 +0200
Subject: [Avidemux-svn-commit] r4282 -
	branches/avidemux_2.4_branch/avidemux/ADM_infoExtractor
Message-ID: <200807250241.m6P2fZLH026366@sheep.berlios.de>

Author: gruntster
Date: 2008-07-25 04:41:29 +0200 (Fri, 25 Jul 2008)
New Revision: 4282

Modified:
   branches/avidemux_2.4_branch/avidemux/ADM_infoExtractor/ADM_infoextractor.cpp
Log:
[TS] use frame_mbs_only flag to calculate height of H.264 in TS files

Modified: branches/avidemux_2.4_branch/avidemux/ADM_infoExtractor/ADM_infoextractor.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_infoExtractor/ADM_infoextractor.cpp	2008-07-24 18:20:17 UTC (rev 4281)
+++ branches/avidemux_2.4_branch/avidemux/ADM_infoExtractor/ADM_infoextractor.cpp	2008-07-25 02:41:29 UTC (rev 4282)
@@ -342,7 +342,7 @@
 {
    GetBitContext s;
    
-   uint32_t profile,constraint,level,pic_order_cnt_type,w,h,z;
+   uint32_t profile,constraint,level,pic_order_cnt_type,w,h, mbh, frame_mbs_only;
    uint8_t buf[len];
    uint32_t outlen;
    uint32_t id,dum;
@@ -398,15 +398,17 @@
            dum=get_ue_golomb(&s);     //num_ref_frames
            printf("[H264] # of ref frames : %u\n",dum);
            get_bits1(&s);         // gaps_in_frame_num_value_allowed_flag
-           w=get_ue_golomb(&s);   //pic_width_in_mbs_minus1
-           h=get_ue_golomb(&s);   //pic_height_in_mbs_minus1
-           z=get_ue_golomb(&s); 
+		   w = get_ue_golomb(&s) + 1;   //pic_width_in_mbs_minus1
+
+		   mbh = get_ue_golomb(&s) + 1;
+		   frame_mbs_only = get_bits1(&s);
+		   h = (2 - frame_mbs_only) * mbh;   //pic_height_in_mbs_minus1
+
            printf("[H264] Width in mb -1  :%d\n",w); 
            printf("[H264] Height in mb -1 :%d\n", h);
-           printf("[H264] z               :%d\n", z);  
-            *wwidth=(w+1)*16;
-            *hheight=(h+1)*16*2; /* Fixme : frame_mbs_only_flag in slice header!! */
 
+		   *wwidth = w * 16;
+		   *hheight= h * 16;
            
            return 1;
 }



From gruntster at mail.berlios.de  Fri Jul 25 19:50:52 2008
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Fri, 25 Jul 2008 19:50:52 +0200
Subject: [Avidemux-svn-commit] r4283 - in
	branches/avidemux_2.4_branch/avidemux: ADM_infoExtractor
	ADM_inputs/ADM_mpegdemuxer
Message-ID: <200807251750.m6PHoqq4006714@sheep.berlios.de>

Author: gruntster
Date: 2008-07-25 19:50:39 +0200 (Fri, 25 Jul 2008)
New Revision: 4283

Modified:
   branches/avidemux_2.4_branch/avidemux/ADM_infoExtractor/ADM_infoextractor.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_indexer_h264.cpp
Log:
[TS] determine fps of H.264 in MPEG-TS files

Modified: branches/avidemux_2.4_branch/avidemux/ADM_infoExtractor/ADM_infoextractor.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_infoExtractor/ADM_infoextractor.cpp	2008-07-25 02:41:29 UTC (rev 4282)
+++ branches/avidemux_2.4_branch/avidemux/ADM_infoExtractor/ADM_infoextractor.cpp	2008-07-25 17:50:39 UTC (rev 4283)
@@ -333,12 +333,65 @@
     return outlen;
     
 }
+
+static uint8_t extractVUIInfo(GetBitContext *s, uint32_t *fps1000)
+{
+	*fps1000 = 0;
+
+	if (get_bits1(s))
+	{
+		unsigned int aspect_ratio_information = get_bits(s, 8);
+
+		if (aspect_ratio_information == 255)
+		{
+			get_bits(s, 16);
+			get_bits(s, 16);
+		}
+	}
+
+	if (get_bits1(s))	// overscan
+		get_bits1(s);
+
+	if (get_bits1(s))	// vsp_color
+	{
+		get_bits(s, 4);
+
+		if (get_bits1(s))
+		{
+			get_bits(s, 8);
+			get_bits(s, 8);
+			get_bits(s, 8);
+		}
+	}
+
+	if (get_bits1(s))	// chroma
+	{
+		get_ue_golomb(s);
+		get_ue_golomb(s);
+	}
+
+	if (get_bits1(s))	// timing
+	{
+		uint32_t timeinc_unit = get_bits_long(s, 32);
+		uint32_t timeinc_resolution = get_bits_long(s, 32);
+		uint32_t fixed_fps = get_bits1(s);
+
+		if (timeinc_unit > 0 && timeinc_resolution > 0)
+			*fps1000 = (uint32_t)(((float)timeinc_resolution / (float)timeinc_unit) * 1000);
+
+		if (fixed_fps)
+			*fps1000 /= 2;
+	}
+
+	return 1;
+}
+
 /**
     \fn extractSPSInfo
     \brief Extract info from H264 SPS
     See 7.3.2.1 of 14496-10
 */
-uint8_t extractSPSInfo(uint8_t *data, uint32_t len,uint32_t *wwidth,uint32_t *hheight)
+uint8_t extractSPSInfo(uint8_t *data, uint32_t len,uint32_t *wwidth,uint32_t *hheight, uint32_t *fps1000)
 {
    GetBitContext s;
    
@@ -410,6 +463,22 @@
 		   *wwidth = w * 16;
 		   *hheight= h * 16;
            
+		   if (!frame_mbs_only)
+			   get_bits1(&s);
+
+		   get_bits1(&s);
+
+		   if(get_bits1(&s))
+		   {
+			   get_ue_golomb(&s);
+			   get_ue_golomb(&s);
+			   get_ue_golomb(&s);
+			   get_ue_golomb(&s);
+		   }
+
+		   if(get_bits1(&s))
+			   extractVUIInfo(&s, fps1000);
+
            return 1;
 }
 /**

Modified: branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_indexer_h264.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_indexer_h264.cpp	2008-07-25 02:41:29 UTC (rev 4282)
+++ branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_indexer_h264.cpp	2008-07-25 17:50:39 UTC (rev 4283)
@@ -54,7 +54,7 @@
 static const char Type[5]={'X','I','P','B','P'};
 
 
-extern uint8_t extractSPSInfo(uint8_t *data, uint32_t len,uint32_t *wwidth,uint32_t *hheight);
+extern uint8_t extractSPSInfo(uint8_t *data, uint32_t len,uint32_t *wwidth,uint32_t *hheight, uint32_t *fps1000);
 
 dmx_videoIndexerH264::dmx_videoIndexerH264(dmx_runData *run) : dmx_videoIndexer(run)
 {
@@ -151,14 +151,12 @@
                     // Our firt frame is here
                     // Important to initialize the mpeg decoder !
                     _run->imageAR = 1;	// 1:1 to suppress warning
-                    _run->imageFPS=25000; 
-                    //
-                    
+
                       uint8_t buffer[60] ; // should be enough
                       uint64_t xA,xR;
                       _run->demuxer->getPos(&xA,&xR);
                       _run->demuxer->read(buffer,60);
-                      if(extractSPSInfo(buffer,60,&( _run->imageW),&( _run->imageH)))
+                      if(extractSPSInfo(buffer,60,&( _run->imageW),&( _run->imageH),&(_run->imageFPS)))
                       {
                             seq_found=1;
                             startFrame(1,syncAbs,syncRel);



From gruntster at mail.berlios.de  Sat Jul 26 14:36:30 2008
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Sat, 26 Jul 2008 14:36:30 +0200
Subject: [Avidemux-svn-commit] r4284 - in
	branches/avidemux_2.4_branch/avidemux: ADM_infoExtractor
	ADM_inputs/ADM_mpegdemuxer
Message-ID: <200807261236.m6QCaUhP005873@sheep.berlios.de>

Author: gruntster
Date: 2008-07-26 14:36:11 +0200 (Sat, 26 Jul 2008)
New Revision: 4284

Modified:
   branches/avidemux_2.4_branch/avidemux/ADM_infoExtractor/ADM_infoextractor.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_indexer.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_indexer_h264.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_indexer_internal.h
   branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_indexer_mpeg2.cpp
Log:
[TS] extract DAR from H.264 in MPEG-TS files

Modified: branches/avidemux_2.4_branch/avidemux/ADM_infoExtractor/ADM_infoextractor.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_infoExtractor/ADM_infoextractor.cpp	2008-07-25 17:50:39 UTC (rev 4283)
+++ branches/avidemux_2.4_branch/avidemux/ADM_infoExtractor/ADM_infoextractor.cpp	2008-07-26 12:36:11 UTC (rev 4284)
@@ -1,352 +1,355 @@
-/***************************************************************************
-                          ADM_infoextractor
-                             -------------------
-           - extract additionnal info from header (mp4/h263)                  
-**************************************************************************/
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#include "config.h"
-
-#include <stdio.h>
-#include <stdlib.h>
-
-#include <string.h>
-
-#include "math.h"
-
-#include <ADM_assert.h>
-#include "default.h"
-#include "ADM_editor/ADM_Video.h"
-
-
-#include "fourcc.h"
-#include "ADM_mp4/ADM_mp4.h"
-#include "ADM_toolkit/toolkit.hxx"
-
-#include "ADM_osSupport/ADM_debugID.h"
-#define MODULE_NAME MODULE_3GP
-#include "ADM_osSupport/ADM_debug.h"
-
-extern "C"
-{
-#include "common.h"
-#include "bswap.h"
-#define INT_MAX (0x7FFFFFFF)
-#include "ADM_lavcodec/bitstream.h"
-#include "ADM_lavcodec/golomb.h"
-}
-
-#include "ADM_infoExtractor/ADM_h264_tag.h"
-
-static void refineH264FrameType(uint8_t *head,uint8_t *tail,uint32_t *flags);
-/*
-    Extract width & height from vol header passed as arg
-
-
-*/
-uint8_t extractMpeg4Info(uint8_t *data,uint32_t dataSize,uint32_t *w,uint32_t *h,uint32_t *time_inc)
-{
-    // Search startcode
-    uint8_t b;
-    uint32_t idx=0;
-    uint32_t mw,mh;
-    uint32_t timeVal;
-    
-    //mixDump(data,dataSize);
-    //printf("\n");
-    while(1)
-    {
-        uint32_t startcode=0xffffffff;
-        while(dataSize>2)
-        {
-            startcode=(startcode<<8)+data[idx];
-            idx++;
-            dataSize--;
-            if((startcode&0xffffff)==1) break;
-        }
-        if(dataSize>2)
-        {
-            //printf("Startcodec:%x\n",data[idx]);
-            if((data[idx]&0xF0)==0x20) //VOL start
-            {
-                dataSize--;
-                idx++;
-#if 0
-                printf("VOL Header:\n");
-
-                if(dataSize<16)
-                {
-                  mixDump(data+idx,dataSize);printf("\n");
-                }
-                else
-                {
-                  mixDump(data+idx,16);printf("\n");
-                }
-#endif
-                // Here we go !
-                GetBitContext s;
-                init_get_bits( &s,data+idx, dataSize*8);
-                //
-                skip_bits1(&s); // Random access
-                skip_bits(&s,8); // Obj type indication
-                if(get_bits(&s,1)) // VO od 
-                {
-                      skip_bits(&s,4); // Ver
-                      skip_bits(&s,3);  // Priority
-                }
-                if(get_bits(&s,4)==15) // custom A/R
-                {
-                      skip_bits(&s,8);
-                      skip_bits(&s,8);
-                }
-                if(get_bits(&s,1)) // Vol control param
-                {
-                      skip_bits(&s,2);   //Chroma
-                      skip_bits(&s,1);   // Low delay
-                      if(get_bits(&s,1)) // VBV Info
-                      {
-                        skip_bits(&s,16);
-                        skip_bits(&s,16);
-                        skip_bits(&s,16);
-                        skip_bits(&s,15);
-                        skip_bits(&s,16);
-                      }
-                  }
-                 skip_bits(&s,2); //  Shape
-                 skip_bits(&s,1); //  Marker
-                 timeVal=get_bits(&s,16); // Time increment
-                 *time_inc = av_log2(timeVal - 1) + 1;
-                 if (*time_inc < 1)
-                    *time_inc = 1;
-                 skip_bits(&s,1); //  Marker
-                 if(get_bits(&s,1)) // Fixed vop rate, compute how much bits needed
-                 {
-                     get_bits(&s, *time_inc);
-                 }
-                  skip_bits(&s,1); //  Marker
-                  mw=get_bits(&s,13);
-                  skip_bits(&s,1); //  Marker
-                  mh=get_bits(&s,13);
-                // /Here we go
-                //printf("%d x %d \n",mw,mh);
-                *h=mh;
-                *w=mw;
-                return 1;;
-                // Free get bits ?
-                // WTF ?
-            }
-            continue;
-        }
-        else
-        {
-            printf("No more startcode\n");
-            // Free get bits ?
-            return 0;
-            
-        }
-    }
-    
-    return 0;
-}
-/**
-    \fn extractVopInfo
-    \brief extract info from vop : Vop type, module time base, time inc
-    
-    Warning this function expects data to start AFTER startcode, contrarily to other functions here!
-*/
-
-uint8_t extractVopInfo(uint8_t *data, uint32_t len,uint32_t timeincbits,uint32_t *vopType,uint32_t *modulo, uint32_t *time_inc,uint32_t *vopcoded)
-{
-   GetBitContext s;
-   int vop;
-   uint32_t vp,tinc;
-           init_get_bits( &s,data, len*8);
-           vop=get_bits(&s,2);
-           switch(vop)
-           {
-             case 0: vp=AVI_KEY_FRAME;break;
-             case 1: vp=0;break;
-             case 2: vp=AVI_B_FRAME;break;
-             case 3: vp=0;break;  // D FRAME ????
-             default:
-                printf("Unknown vop type :%d\n",vop);
-                return 0;
-           }
-           /* Read modulo */
-           int imodulo=0;
-           while (get_bits1(&s) != 0)
-                  imodulo++;
-           if(!get_bits1(&s))
-           {
-              printf("Wrong marker1\n");
-              return 0; 
-           }
-           
-           /* Read time */
-           tinc=get_bits(&s,timeincbits);
-           /* Marker */
-            if(!get_bits1(&s))
-           {
-              printf("Wrong marker2\n");
-              return 0; 
-           }
-           /* Vop coded */
-           *modulo=imodulo;
-           *vopcoded=get_bits1(&s);
-           *vopType=vp;
-           *time_inc=tinc;
-           return 1;
-}
-/**
-      \brief extractH263FLVInfo
-      \fn Extract width/height from FLV header
-*/
-uint8_t extractH263FLVInfo(uint8_t *buffer,uint32_t len,uint32_t *w,uint32_t *h)
-{
-        GetBitContext gb;
-        int format;
-        init_get_bits( &gb,buffer, len*8);
-        if (get_bits_long(&gb, 17) != 1) {
-            printf("[FLV]Wrong FLV1 header\n");
-            return 0;
-        }
-        format = get_bits(&gb, 5);
-        if (format != 0 && format != 1) {
-            printf("[FLV]Wrong FLV1 header format\n");
-            return 0;        }
-        
-        get_bits(&gb, 8); /* picture timestamp */
-        format = get_bits(&gb, 3);
-        switch (format) {
-        case 0:
-            *w = get_bits(&gb, 8);
-            *h = get_bits(&gb, 8);
-            break;
-        case 1:
-            *w = get_bits(&gb, 16);
-            *h = get_bits(&gb, 16);
-            break;
-        case 2:
-            *w = 352;
-            *h = 288;
-            break;
-        case 3:
-            *w = 176;
-            *h = 144;
-            break;
-        case 4:
-            *w = 128;
-            *h = 96;
-            break;
-        case 5:
-            *w = 320;
-            *h = 240;
-            break;
-        case 6:
-            *w = 160;
-            *h = 120;
-            break;
-        default:
-             printf("[FLV]Wrong width format\n");
-             return 0;
-            break;
-        }
-        return 1;
-}
-/*
-        Extract H263 width & height from header
-
-*/
-uint8_t extractH263Info(uint8_t *data,uint32_t dataSize,uint32_t *w,uint32_t *h)
-{
-uint32_t val;
-                GetBitContext s;
-                init_get_bits( &s,data, dataSize*8);
-                
-                 mixDump(data,10);
-                 val=get_bits(&s,16);
-                 if(val)
-                 {
-                    printf("incorrect H263 header sync\n");
-                    return 0;
-                 }
-                 val=get_bits(&s,6);
-                 if(val!=0x20)
-                 {
-                    printf("incorrect H263 header sync (2)\n");
-                    return 0;
-                 }
-                 //
-                 skip_bits(&s,8); // timestamps in 30 fps tick
-                 skip_bits(&s,1); // Marker
-                 skip_bits(&s,1); // Id
-                 skip_bits(&s,1); // Split
-                 skip_bits(&s,1); // Document Camera indicator
-                 skip_bits(&s,1); // Full Picture Freeze Release
-                 val=get_bits(&s,3);
-                 switch(val)
-                 {
-                   
-                    case 1: *w=128;*h=96;return 1;break;
-                    case 2: *w=176;*h=144;return 1;break;
-                    case 6:
-                    case 7:
-                            printf("H263+:Todo\n");
-                    default:
-                        printf("Invalid format\n");return 0;break;
-                 }
-                 return 0;
-}
-/**
-    \fn unescapeH264
-    \brief Remove escape stuff
-
-*/
-static uint32_t unescapeH264(uint32_t len,uint8_t *in, uint8_t *out)
-{
-  uint32_t outlen=0;
-  uint8_t *tail=in+len;
-    if(len<3) return 0;
-    while(in<tail-3)
-    {
-      if(!in[0]  && !in[1] && in[2]==3)
-      {
-        out[0]=0;
-        out[1]=0;
-        out+=2;
-        outlen+=2;
-        in+=3; 
-      }
-      *out++=*in++;
-      outlen++;
-    }
-    // copy last bytes
-    uint32_t left=tail-in;
-    memcpy(out,in,left);
-    outlen+=left;
-    return outlen;
-    
-}
-
-static uint8_t extractVUIInfo(GetBitContext *s, uint32_t *fps1000)
-{
-	*fps1000 = 0;
-
+/***************************************************************************
+                          ADM_infoextractor
+                             -------------------
+           - extract additionnal info from header (mp4/h263)                  
+**************************************************************************/
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include "config.h"
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <math.h>
+
+#include "ADM_assert.h"
+#include "default.h"
+#include "ADM_editor/ADM_Video.h"
+
+
+#include "fourcc.h"
+#include "ADM_mp4/ADM_mp4.h"
+#include "ADM_toolkit/toolkit.hxx"
+
+#include "ADM_osSupport/ADM_debugID.h"
+#define MODULE_NAME MODULE_3GP
+#include "ADM_osSupport/ADM_debug.h"
+
+extern "C"
+{
+#include "common.h"
+#include "bswap.h"
+#define INT_MAX (0x7FFFFFFF)
+#include "ADM_lavcodec/bitstream.h"
+#include "ADM_lavcodec/golomb.h"
+}
+
+#include "ADM_infoExtractor/ADM_h264_tag.h"
+
+static void refineH264FrameType(uint8_t *head,uint8_t *tail,uint32_t *flags);
+/*
+    Extract width & height from vol header passed as arg
+
+
+*/
+uint8_t extractMpeg4Info(uint8_t *data,uint32_t dataSize,uint32_t *w,uint32_t *h,uint32_t *time_inc)
+{
+    // Search startcode
+    uint8_t b;
+    uint32_t idx=0;
+    uint32_t mw,mh;
+    uint32_t timeVal;
+    
+    //mixDump(data,dataSize);
+    //printf("\n");
+    while(1)
+    {
+        uint32_t startcode=0xffffffff;
+        while(dataSize>2)
+        {
+            startcode=(startcode<<8)+data[idx];
+            idx++;
+            dataSize--;
+            if((startcode&0xffffff)==1) break;
+        }
+        if(dataSize>2)
+        {
+            //printf("Startcodec:%x\n",data[idx]);
+            if((data[idx]&0xF0)==0x20) //VOL start
+            {
+                dataSize--;
+                idx++;
+#if 0
+                printf("VOL Header:\n");
+
+                if(dataSize<16)
+                {
+                  mixDump(data+idx,dataSize);printf("\n");
+                }
+                else
+                {
+                  mixDump(data+idx,16);printf("\n");
+                }
+#endif
+                // Here we go !
+                GetBitContext s;
+                init_get_bits( &s,data+idx, dataSize*8);
+                //
+                skip_bits1(&s); // Random access
+                skip_bits(&s,8); // Obj type indication
+                if(get_bits(&s,1)) // VO od 
+                {
+                      skip_bits(&s,4); // Ver
+                      skip_bits(&s,3);  // Priority
+                }
+                if(get_bits(&s,4)==15) // custom A/R
+                {
+                      skip_bits(&s,8);
+                      skip_bits(&s,8);
+                }
+                if(get_bits(&s,1)) // Vol control param
+                {
+                      skip_bits(&s,2);   //Chroma
+                      skip_bits(&s,1);   // Low delay
+                      if(get_bits(&s,1)) // VBV Info
+                      {
+                        skip_bits(&s,16);
+                        skip_bits(&s,16);
+                        skip_bits(&s,16);
+                        skip_bits(&s,15);
+                        skip_bits(&s,16);
+                      }
+                  }
+                 skip_bits(&s,2); //  Shape
+                 skip_bits(&s,1); //  Marker
+                 timeVal=get_bits(&s,16); // Time increment
+                 *time_inc = av_log2(timeVal - 1) + 1;
+                 if (*time_inc < 1)
+                    *time_inc = 1;
+                 skip_bits(&s,1); //  Marker
+                 if(get_bits(&s,1)) // Fixed vop rate, compute how much bits needed
+                 {
+                     get_bits(&s, *time_inc);
+                 }
+                  skip_bits(&s,1); //  Marker
+                  mw=get_bits(&s,13);
+                  skip_bits(&s,1); //  Marker
+                  mh=get_bits(&s,13);
+                // /Here we go
+                //printf("%d x %d \n",mw,mh);
+                *h=mh;
+                *w=mw;
+                return 1;;
+                // Free get bits ?
+                // WTF ?
+            }
+            continue;
+        }
+        else
+        {
+            printf("No more startcode\n");
+            // Free get bits ?
+            return 0;
+            
+        }
+    }
+    
+    return 0;
+}
+/**
+    \fn extractVopInfo
+    \brief extract info from vop : Vop type, module time base, time inc
+    
+    Warning this function expects data to start AFTER startcode, contrarily to other functions here!
+*/
+
+uint8_t extractVopInfo(uint8_t *data, uint32_t len,uint32_t timeincbits,uint32_t *vopType,uint32_t *modulo, uint32_t *time_inc,uint32_t *vopcoded)
+{
+   GetBitContext s;
+   int vop;
+   uint32_t vp,tinc;
+           init_get_bits( &s,data, len*8);
+           vop=get_bits(&s,2);
+           switch(vop)
+           {
+             case 0: vp=AVI_KEY_FRAME;break;
+             case 1: vp=0;break;
+             case 2: vp=AVI_B_FRAME;break;
+             case 3: vp=0;break;  // D FRAME ????
+             default:
+                printf("Unknown vop type :%d\n",vop);
+                return 0;
+           }
+           /* Read modulo */
+           int imodulo=0;
+           while (get_bits1(&s) != 0)
+                  imodulo++;
+           if(!get_bits1(&s))
+           {
+              printf("Wrong marker1\n");
+              return 0; 
+           }
+           
+           /* Read time */
+           tinc=get_bits(&s,timeincbits);
+           /* Marker */
+            if(!get_bits1(&s))
+           {
+              printf("Wrong marker2\n");
+              return 0; 
+           }
+           /* Vop coded */
+           *modulo=imodulo;
+           *vopcoded=get_bits1(&s);
+           *vopType=vp;
+           *time_inc=tinc;
+           return 1;
+}
+/**
+      \brief extractH263FLVInfo
+      \fn Extract width/height from FLV header
+*/
+uint8_t extractH263FLVInfo(uint8_t *buffer,uint32_t len,uint32_t *w,uint32_t *h)
+{
+        GetBitContext gb;
+        int format;
+        init_get_bits( &gb,buffer, len*8);
+        if (get_bits_long(&gb, 17) != 1) {
+            printf("[FLV]Wrong FLV1 header\n");
+            return 0;
+        }
+        format = get_bits(&gb, 5);
+        if (format != 0 && format != 1) {
+            printf("[FLV]Wrong FLV1 header format\n");
+            return 0;        }
+        
+        get_bits(&gb, 8); /* picture timestamp */
+        format = get_bits(&gb, 3);
+        switch (format) {
+        case 0:
+            *w = get_bits(&gb, 8);
+            *h = get_bits(&gb, 8);
+            break;
+        case 1:
+            *w = get_bits(&gb, 16);
+            *h = get_bits(&gb, 16);
+            break;
+        case 2:
+            *w = 352;
+            *h = 288;
+            break;
+        case 3:
+            *w = 176;
+            *h = 144;
+            break;
+        case 4:
+            *w = 128;
+            *h = 96;
+            break;
+        case 5:
+            *w = 320;
+            *h = 240;
+            break;
+        case 6:
+            *w = 160;
+            *h = 120;
+            break;
+        default:
+             printf("[FLV]Wrong width format\n");
+             return 0;
+            break;
+        }
+        return 1;
+}
+/*
+        Extract H263 width & height from header
+
+*/
+uint8_t extractH263Info(uint8_t *data,uint32_t dataSize,uint32_t *w,uint32_t *h)
+{
+uint32_t val;
+                GetBitContext s;
+                init_get_bits( &s,data, dataSize*8);
+                
+                 mixDump(data,10);
+                 val=get_bits(&s,16);
+                 if(val)
+                 {
+                    printf("incorrect H263 header sync\n");
+                    return 0;
+                 }
+                 val=get_bits(&s,6);
+                 if(val!=0x20)
+                 {
+                    printf("incorrect H263 header sync (2)\n");
+                    return 0;
+                 }
+                 //
+                 skip_bits(&s,8); // timestamps in 30 fps tick
+                 skip_bits(&s,1); // Marker
+                 skip_bits(&s,1); // Id
+                 skip_bits(&s,1); // Split
+                 skip_bits(&s,1); // Document Camera indicator
+                 skip_bits(&s,1); // Full Picture Freeze Release
+                 val=get_bits(&s,3);
+                 switch(val)
+                 {
+                   
+                    case 1: *w=128;*h=96;return 1;break;
+                    case 2: *w=176;*h=144;return 1;break;
+                    case 6:
+                    case 7:
+                            printf("H263+:Todo\n");
+                    default:
+                        printf("Invalid format\n");return 0;break;
+                 }
+                 return 0;
+}
+/**
+    \fn unescapeH264
+    \brief Remove escape stuff
+
+*/
+static uint32_t unescapeH264(uint32_t len,uint8_t *in, uint8_t *out)
+{
+  uint32_t outlen=0;
+  uint8_t *tail=in+len;
+    if(len<3) return 0;
+    while(in<tail-3)
+    {
+      if(!in[0]  && !in[1] && in[2]==3)
+      {
+        out[0]=0;
+        out[1]=0;
+        out+=2;
+        outlen+=2;
+        in+=3; 
+      }
+      *out++=*in++;
+      outlen++;
+    }
+    // copy last bytes
+    uint32_t left=tail-in;
+    memcpy(out,in,left);
+    outlen+=left;
+    return outlen;
+    
+}
+
+static uint8_t extractVUIInfo(GetBitContext *s, uint32_t *fps1000, uint32_t *darNum, uint32_t *darDen)
+{
+	*fps1000 = *darNum = *darDen = 0;
+
 	if (get_bits1(s))
 	{
 		unsigned int aspect_ratio_information = get_bits(s, 8);
 
 		if (aspect_ratio_information == 255)
 		{
-			get_bits(s, 16);
-			get_bits(s, 16);
+			*darNum = get_bits_long(s, 16);
+			*darDen = get_bits_long(s, 16);
 		}
+		else if (aspect_ratio_information < sizeof(pixel_aspect) / sizeof(*pixel_aspect))
+		{
+			*darNum = pixel_aspect[aspect_ratio_information].num;
+			*darDen = pixel_aspect[aspect_ratio_information].den;
+		}
 	}
 
 	if (get_bits1(s))	// overscan
@@ -383,86 +386,86 @@
 			*fps1000 /= 2;
 	}
 
-	return 1;
-}
-
-/**
-    \fn extractSPSInfo
-    \brief Extract info from H264 SPS
-    See 7.3.2.1 of 14496-10
-*/
-uint8_t extractSPSInfo(uint8_t *data, uint32_t len,uint32_t *wwidth,uint32_t *hheight, uint32_t *fps1000)
-{
-   GetBitContext s;
-   
-   uint32_t profile,constraint,level,pic_order_cnt_type,w,h, mbh, frame_mbs_only;
-   uint8_t buf[len];
-   uint32_t outlen;
-   uint32_t id,dum;
-   
-           outlen=unescapeH264(len,data,buf);
-           init_get_bits( &s,buf, outlen*8);
-            
-           profile=get_bits(&s,8);
-           constraint=get_bits(&s,8)>>5;
-           level=get_bits(&s,8);
-           id=get_ue_golomb(&s); // Seq parameter set id           
-           printf("[H264]Profile : %u, Level :%u, SPSid:%u\n",profile,level,id);
-           if(profile>=100) // ?? Borrowed from H264.C/FFMPEG
-           {
-              printf("[H264]Warning : High profile\n");
-              if(get_ue_golomb(&s) == 3) //chroma_format_idc
-                get_bits1(&s);  //residual_color_transform_flag
-            get_ue_golomb(&s);  //bit_depth_luma_minus8
-            get_ue_golomb(&s);  //bit_depth_chroma_minus8
-            get_bits1(&s);
-			if (get_bits1(&s))
-				get_bits(&s, 8);
-           }
-           
-
-           dum=get_ue_golomb(&s); // log2_max_frame_num_minus4
-           printf("[H264]Log2maxFrame-4:%u\n",dum);
-           pic_order_cnt_type=get_ue_golomb(&s);
-           printf("[H264]Pic Order Cnt Type:%u\n",pic_order_cnt_type);
-           if(!pic_order_cnt_type) // pic_order_cnt_type
-           {
-              dum=get_ue_golomb(&s); //log2_max_pic_order_cnt_lsb_minus4
-              printf("[H264]Log2maxPix-4:%u\n",dum);
-           }else
-           {
-             if(pic_order_cnt_type==1)
-             {
-                 get_bits1(&s);   //delta_pic_order_always_zero_flag
-                 get_se_golomb(&s);   //offset_for_non_ref_pic
-                 get_se_golomb(&s);  // offset_for_top_to_bottom_field
-                 int i=get_ue_golomb(&s);  //num_ref_frames_in_pic_order_cnt_cycle
-
-                 for(int j=0;j<i;j++)
-                 {
-                      get_se_golomb(&s);
-                 }
-             }else 
-             {
-               printf("Error in SPS\n");
-               return 0;
-             }
-           }
-           dum=get_ue_golomb(&s);     //num_ref_frames
-           printf("[H264] # of ref frames : %u\n",dum);
-           get_bits1(&s);         // gaps_in_frame_num_value_allowed_flag
-		   w = get_ue_golomb(&s) + 1;   //pic_width_in_mbs_minus1
-
-		   mbh = get_ue_golomb(&s) + 1;
-		   frame_mbs_only = get_bits1(&s);
-		   h = (2 - frame_mbs_only) * mbh;   //pic_height_in_mbs_minus1
-
-           printf("[H264] Width in mb -1  :%d\n",w); 
-           printf("[H264] Height in mb -1 :%d\n", h);
-
-		   *wwidth = w * 16;
-		   *hheight= h * 16;
-           
+	return 1;
+}
+
+/**
+    \fn extractSPSInfo
+    \brief Extract info from H264 SPS
+    See 7.3.2.1 of 14496-10
+*/
+uint8_t extractSPSInfo(uint8_t *data, uint32_t len,uint32_t *wwidth,uint32_t *hheight, uint32_t *fps1000, uint32_t *darNum, uint32_t *darDen)
+{
+   GetBitContext s;
+   
+   uint32_t profile,constraint,level,pic_order_cnt_type,w,h, mbh, frame_mbs_only;
+   uint8_t buf[len];
+   uint32_t outlen;
+   uint32_t id,dum;
+   
+           outlen=unescapeH264(len,data,buf);
+           init_get_bits( &s,buf, outlen*8);
+            
+           profile=get_bits(&s,8);
+           constraint=get_bits(&s,8)>>5;
+           level=get_bits(&s,8);
+           id=get_ue_golomb(&s); // Seq parameter set id           
+           printf("[H264]Profile : %u, Level :%u, SPSid:%u\n",profile,level,id);
+           if(profile>=100) // ?? Borrowed from H264.C/FFMPEG
+           {
+              printf("[H264]Warning : High profile\n");
+              if(get_ue_golomb(&s) == 3) //chroma_format_idc
+                get_bits1(&s);  //residual_color_transform_flag
+            get_ue_golomb(&s);  //bit_depth_luma_minus8
+            get_ue_golomb(&s);  //bit_depth_chroma_minus8
+            get_bits1(&s);
+			if (get_bits1(&s))
+				get_bits(&s, 8);
+           }
+           
+
+           dum=get_ue_golomb(&s); // log2_max_frame_num_minus4
+           printf("[H264]Log2maxFrame-4:%u\n",dum);
+           pic_order_cnt_type=get_ue_golomb(&s);
+           printf("[H264]Pic Order Cnt Type:%u\n",pic_order_cnt_type);
+           if(!pic_order_cnt_type) // pic_order_cnt_type
+           {
+              dum=get_ue_golomb(&s); //log2_max_pic_order_cnt_lsb_minus4
+              printf("[H264]Log2maxPix-4:%u\n",dum);
+           }else
+           {
+             if(pic_order_cnt_type==1)
+             {
+                 get_bits1(&s);   //delta_pic_order_always_zero_flag
+                 get_se_golomb(&s);   //offset_for_non_ref_pic
+                 get_se_golomb(&s);  // offset_for_top_to_bottom_field
+                 int i=get_ue_golomb(&s);  //num_ref_frames_in_pic_order_cnt_cycle
+
+                 for(int j=0;j<i;j++)
+                 {
+                      get_se_golomb(&s);
+                 }
+             }else 
+             {
+               printf("Error in SPS\n");
+               return 0;
+             }
+           }
+           dum=get_ue_golomb(&s);     //num_ref_frames
+           printf("[H264] # of ref frames : %u\n",dum);
+           get_bits1(&s);         // gaps_in_frame_num_value_allowed_flag
+		   w = get_ue_golomb(&s) + 1;   //pic_width_in_mbs_minus1
+
+		   mbh = get_ue_golomb(&s) + 1;
+		   frame_mbs_only = get_bits1(&s);
+		   h = (2 - frame_mbs_only) * mbh;   //pic_height_in_mbs_minus1
+
+           printf("[H264] Width in mb -1  :%d\n",w); 
+           printf("[H264] Height in mb -1 :%d\n", h);
+
+		   *wwidth = w * 16;
+		   *hheight= h * 16;
+           
 		   if (!frame_mbs_only)
 			   get_bits1(&s);
 
@@ -477,128 +480,128 @@
 		   }
 
 		   if(get_bits1(&s))
-			   extractVUIInfo(&s, fps1000);
-
-           return 1;
-}
-/**
-      \fn extractH264FrameType
-      \brief return frametype in flags (KEY_FRAME or 0). To be used only with  mkv/mp4 nal type (i.e. no startcode)
-      
-*/
-uint8_t extractH264FrameType(uint32_t nalSize,uint8_t *buffer,uint32_t len,uint32_t *flags)
-{
-  uint8_t *head=buffer, *tail=buffer+len;
-  uint8_t stream;
-  
-  uint32_t val,hnt;  
-  
-// FIXME :  no startcode only !
-  
-  while(head+4<tail)
-  {
-    
-              uint32_t length=(head[0]<<24) + (head[1]<<16) +(head[2]<<8)+(head[3]);
-              if(length>len||length<6)
-              {
-                printf("Warning , incomplete nal (%u/%u),(%0x/%0x)\n",length,len,length,len);
-                *flags=0;
-                return 0;
-              }
-              head+=4; // Skip nal lenth
-              length-=4;
-              stream=*(head++)&0x1F;
-                switch(stream)
-                {
-                  case NAL_IDR: 
-                                  *flags=AVI_KEY_FRAME;
-                                  
-                                  return 1;
-                                  break; 
-                  case NAL_NON_IDR: 
-                                  refineH264FrameType(head,tail,flags);
-                                  return 1;
-                                  break;
-                  default:
-                          printf("??0x%x\n",stream);
-                          head+=length-5;
-                          continue;
-                }
-  }
-  printf("No stream\n");
-  return 0;
-}
-
-/**
-      \fn extractH264FrameType_startCode
-      \brief return frametype in flags (KEY_FRAME or 0). To be used only with  avi / mpeg TS nal type (i.e. with startcode)
-      
-*/
-uint8_t extractH264FrameType_startCode(uint32_t nalSize,uint8_t *buffer,uint32_t len,uint32_t *flags)
-{
-  uint8_t *head=buffer, *tail=buffer+len;
-  uint8_t stream;
-#define NAL_NON_IDR       1
-#define NAL_IDR           5
-#define NAL_SEI           6
-
-  uint32_t val,hnt;  
-  
-// FIXME :  no startcode only !
-  
-  while(head+4<tail)
-  {
-          // Search startcode
-      
-                hnt=(head[0]<<24) + (head[1]<<16) +(head[2]<<8)+(head[3]);
-                head+=4;
-                while((hnt!=1) && head<tail)
-                {
-
-                        hnt<<=8;
-                        val=*head++;
-                        hnt+=val;
-                }
-                if(head>=tail) break;
-                stream=*(head++) &0x1f;
-                switch(stream)
-                {
-                  case NAL_IDR: 
-                                  *flags=AVI_KEY_FRAME;
-                                 // printf("IDR\n");
-                                  return 1;
-                                  break; 
-                  case NAL_NON_IDR: 
-                                  refineH264FrameType(head,tail,flags);
-                                  return 1;
-                                  break;
-                  default:
-                          printf("??0x%x\n",stream);
-                          continue;
-                }
-  }
-  printf("No stream\n");
-  return 0;
-}
-/**
-    \fn refineH264FrameType
-    \brief Try to detect B slice, warning the stream is not escaped!
-*/
-void refineH264FrameType(uint8_t *head,uint8_t *tail,uint32_t *flags)
-{
-GetBitContext s;
-uint32_t sliceType;
-            *flags=0;
-            init_get_bits(&s,head, (tail-head)*8);
-            get_ue_golomb(&s);
-            sliceType= get_ue_golomb(&s);
-            if(sliceType > 9) 
-            {
-              printf("Weird Slice %d\n",sliceType);
-              return ;
-            }
-            if(sliceType > 4)
-                sliceType -= 5;
-            if(sliceType==3) *flags=AVI_B_FRAME;  
-}
-//EOF
+			   extractVUIInfo(&s, fps1000, darNum, darDen);
+
+           return 1;
+}
+/**
+      \fn extractH264FrameType
+      \brief return frametype in flags (KEY_FRAME or 0). To be used only with  mkv/mp4 nal type (i.e. no startcode)
+      
+*/
+uint8_t extractH264FrameType(uint32_t nalSize,uint8_t *buffer,uint32_t len,uint32_t *flags)
+{
+  uint8_t *head=buffer, *tail=buffer+len;
+  uint8_t stream;
+  
+  uint32_t val,hnt;  
+  
+// FIXME :  no startcode only !
+  
+  while(head+4<tail)
+  {
+    
+              uint32_t length=(head[0]<<24) + (head[1]<<16) +(head[2]<<8)+(head[3]);
+              if(length>len||length<6)
+              {
+                printf("Warning , incomplete nal (%u/%u),(%0x/%0x)\n",length,len,length,len);
+                *flags=0;
+                return 0;
+              }
+              head+=4; // Skip nal lenth
+              length-=4;
+              stream=*(head++)&0x1F;
+                switch(stream)
+                {
+                  case NAL_IDR: 
+                                  *flags=AVI_KEY_FRAME;
+                                  
+                                  return 1;
+                                  break; 
+                  case NAL_NON_IDR: 
+                                  refineH264FrameType(head,tail,flags);
+                                  return 1;
+                                  break;
+                  default:
+                          printf("??0x%x\n",stream);
+                          head+=length-5;
+                          continue;
+                }
+  }
+  printf("No stream\n");
+  return 0;
+}
+
+/**
+      \fn extractH264FrameType_startCode
+      \brief return frametype in flags (KEY_FRAME or 0). To be used only with  avi / mpeg TS nal type (i.e. with startcode)
+      
+*/
+uint8_t extractH264FrameType_startCode(uint32_t nalSize,uint8_t *buffer,uint32_t len,uint32_t *flags)
+{
+  uint8_t *head=buffer, *tail=buffer+len;
+  uint8_t stream;
+#define NAL_NON_IDR       1
+#define NAL_IDR           5
+#define NAL_SEI           6
+
+  uint32_t val,hnt;  
+  
+// FIXME :  no startcode only !
+  
+  while(head+4<tail)
+  {
+          // Search startcode
+      
+                hnt=(head[0]<<24) + (head[1]<<16) +(head[2]<<8)+(head[3]);
+                head+=4;
+                while((hnt!=1) && head<tail)
+                {
+
+                        hnt<<=8;
+                        val=*head++;
+                        hnt+=val;
+                }
+                if(head>=tail) break;
+                stream=*(head++) &0x1f;
+                switch(stream)
+                {
+                  case NAL_IDR: 
+                                  *flags=AVI_KEY_FRAME;
+                                 // printf("IDR\n");
+                                  return 1;
+                                  break; 
+                  case NAL_NON_IDR: 
+                                  refineH264FrameType(head,tail,flags);
+                                  return 1;
+                                  break;
+                  default:
+                          printf("??0x%x\n",stream);
+                          continue;
+                }
+  }
+  printf("No stream\n");
+  return 0;
+}
+/**
+    \fn refineH264FrameType
+    \brief Try to detect B slice, warning the stream is not escaped!
+*/
+void refineH264FrameType(uint8_t *head,uint8_t *tail,uint32_t *flags)
+{
+GetBitContext s;
+uint32_t sliceType;
+            *flags=0;
+            init_get_bits(&s,head, (tail-head)*8);
+            get_ue_golomb(&s);
+            sliceType= get_ue_golomb(&s);
+            if(sliceType > 9) 
+            {
+              printf("Weird Slice %d\n",sliceType);
+              return ;
+            }
+            if(sliceType > 4)
+                sliceType -= 5;
+            if(sliceType==3) *flags=AVI_B_FRAME;  
+}
+//EOF

Modified: branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_indexer.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_indexer.cpp	2008-07-25 17:50:39 UTC (rev 4283)
+++ branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_indexer.cpp	2008-07-26 12:36:11 UTC (rev 4284)
@@ -240,15 +240,10 @@
               
         printf("*********Indexing Ended (%d audio tracks)***********\n",nbTracks);
 
-         switch(run.imageAR)
-         {
-           case 1: 	qfprintf(out,"# Video Aspect Ratio : %s\n", "1:1" );break;
-           case 2: 	qfprintf(out,"# Video Aspect Ratio : %s\n", "4:3" );break;
-           case 3: 	qfprintf(out,"# Video Aspect Ratio : %s\n", "16:9" );break;
-           default:
-              printf("imageAR=%u\n",run.imageAR);
-              GUI_Error_HIG(QT_TR_NOOP("Can't determine aspect ratio"),NULL);
-	}
+		if (run.imageDarNum == 0 || run.imageDarDen == 0)
+			GUI_Error_HIG(QT_TR_NOOP("Can't determine aspect ratio"),NULL);
+		else
+			qfprintf(out,"# Video Aspect Ratio : %d:%d\n", run.imageDarNum, run.imageDarDen);
 
         /* Now update......... */
           fseeko(out,0,SEEK_SET);

Modified: branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_indexer_h264.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_indexer_h264.cpp	2008-07-25 17:50:39 UTC (rev 4283)
+++ branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_indexer_h264.cpp	2008-07-26 12:36:11 UTC (rev 4284)
@@ -22,7 +22,7 @@
 #include <math.h>
 
 #include "default.h"
-#include <ADM_assert.h>
+#include "ADM_assert.h"
 
 
 #include "ADM_toolkit/toolkit.hxx"
@@ -54,7 +54,7 @@
 static const char Type[5]={'X','I','P','B','P'};
 
 
-extern uint8_t extractSPSInfo(uint8_t *data, uint32_t len,uint32_t *wwidth,uint32_t *hheight, uint32_t *fps1000);
+extern uint8_t extractSPSInfo(uint8_t *data, uint32_t len,uint32_t *wwidth,uint32_t *hheight, uint32_t *fps1000, uint32_t *darNum, uint32_t *darDen);
 
 dmx_videoIndexerH264::dmx_videoIndexerH264(dmx_runData *run) : dmx_videoIndexer(run)
 {
@@ -150,13 +150,11 @@
               {
                     // Our firt frame is here
                     // Important to initialize the mpeg decoder !
-                    _run->imageAR = 1;	// 1:1 to suppress warning
-
                       uint8_t buffer[60] ; // should be enough
                       uint64_t xA,xR;
                       _run->demuxer->getPos(&xA,&xR);
                       _run->demuxer->read(buffer,60);
-                      if(extractSPSInfo(buffer,60,&( _run->imageW),&( _run->imageH),&(_run->imageFPS)))
+                      if(extractSPSInfo(buffer,60,&( _run->imageW),&( _run->imageH),&(_run->imageFPS),&(_run->imageDarNum),&(_run->imageDarDen)))
                       {
                             seq_found=1;
                             startFrame(1,syncAbs,syncRel);

Modified: branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_indexer_internal.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_indexer_internal.h	2008-07-25 17:50:39 UTC (rev 4283)
+++ branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_indexer_internal.h	2008-07-26 12:36:11 UTC (rev 4284)
@@ -47,7 +47,7 @@
       uint32_t nbImage;
       uint32_t nbPushed,nbGop;      
       uint32_t nbTrack;
-      uint32_t imageW,imageH,imageFPS,imageAR;
+      uint32_t imageW,imageH,imageFPS, imageDarNum, imageDarDen;
       TimeStamp firstStamp,lastStamp; /* Time code hh:mm:ss */
       
 }dmx_runData;

Modified: branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_indexer_mpeg2.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_indexer_mpeg2.cpp	2008-07-25 17:50:39 UTC (rev 4283)
+++ branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_indexer_mpeg2.cpp	2008-07-26 12:36:11 UTC (rev 4284)
@@ -22,7 +22,7 @@
 #include <math.h>
 
 #include "default.h"
-#include <ADM_assert.h>
+#include "ADM_assert.h"
 
 
 #include "ADM_toolkit/toolkit.hxx"
@@ -107,7 +107,7 @@
 uint8_t streamid;   
 uint32_t temporal_ref,ftype,val;
 uint64_t pts,dts;
-
+uint32_t imageAR;
       
 
       while(1)
@@ -147,7 +147,29 @@
                               _run->imageW=val>>20;
                               _run->imageW=((_run->imageW+15)&~15);
                               _run->imageH= (((val>>8) & 0xfff)+15)& ~15;
-                              _run->imageAR=(val>>4)&0xf;
+
+							  imageAR = (val >> 4) & 0xf;
+
+							  switch (imageAR)
+							  {
+								  case 1:
+									  _run->imageDarNum = 1;
+									  _run->imageDarDen = 1;
+									  break;
+								  case 2:
+									  _run->imageDarNum = 4;
+									  _run->imageDarDen = 3;
+									  break;
+								  case 3:
+									  _run->imageDarNum = 16;
+									  _run->imageDarDen = 9;
+									  break;
+								  default:
+									  _run->imageDarNum = 0;
+									  _run->imageDarDen = 0;
+									  printf("imageAR = %u\n", imageAR);
+							  }
+
                               _run->imageFPS= FPS[val & 0xf];
                               demuxer->forward(4);
                               break;



From mean at mail.berlios.de  Sat Jul 26 20:58:33 2008
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sat, 26 Jul 2008 20:58:33 +0200
Subject: [Avidemux-svn-commit] r4285 - in
	branches/avidemux_2.5_branch_gruntster/avidemux:
	ADM_infoExtractor ADM_inputs/ADM_mpegdemuxer
Message-ID: <200807261858.m6QIwXfc014179@sheep.berlios.de>

Author: mean
Date: 2008-07-26 20:58:33 +0200 (Sat, 26 Jul 2008)
New Revision: 4285

Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_infoExtractor/ADM_infoextractor.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_indexer_h264.cpp
Log:
[Merge] 4273


Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_infoExtractor/ADM_infoextractor.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_infoExtractor/ADM_infoextractor.cpp	2008-07-26 12:36:11 UTC (rev 4284)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_infoExtractor/ADM_infoextractor.cpp	2008-07-26 18:58:33 UTC (rev 4285)
@@ -354,8 +354,9 @@
             get_ue_golomb(&s);  //bit_depth_luma_minus8
             get_ue_golomb(&s);  //bit_depth_chroma_minus8
             get_bits1(&s);
-            get_bits1(&s); //incomplete FIXME
-           }    // /??
+			if (get_bits1(&s))
+				get_bits(&s, 8);
+           }
            
 
            dum=get_ue_golomb(&s); // log2_max_frame_num_minus4

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_indexer_h264.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_indexer_h264.cpp	2008-07-26 12:36:11 UTC (rev 4284)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_indexer_h264.cpp	2008-07-26 18:58:33 UTC (rev 4285)
@@ -143,7 +143,7 @@
               {
                     // Our firt frame is here
                     // Important to initialize the mpeg decoder !
-                    
+                    _run->imageAR = 1;	// 1:1 to suppress warning
                     _run->imageFPS=25000; 
                     //
                     



From mean at mail.berlios.de  Sat Jul 26 20:58:34 2008
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sat, 26 Jul 2008 20:58:34 +0200
Subject: [Avidemux-svn-commit] r4286 -
	branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script
Message-ID: <200807261858.m6QIwYVO014189@sheep.berlios.de>

Author: mean
Date: 2008-07-26 20:58:34 +0200 (Sat, 26 Jul 2008)
New Revision: 4286

Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSDirectorySearch.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSDirectorySearch.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/DirectorySearch.cpp
Log:
[Merge] 4277


Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSDirectorySearch.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSDirectorySearch.cpp	2008-07-26 18:58:33 UTC (rev 4285)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSDirectorySearch.cpp	2008-07-26 18:58:34 UTC (rev 4286)
@@ -29,6 +29,7 @@
 	{ "Close", Close, 0, 0, 0 },	// Close the search
 	{ "GetFileName", GetFileName, 0, 0, 0 },	// return the current file name
 	{ "GetFileDirectory", GetFileDirectory, 0, 0, 0 },	// returns the directory of the file
+	{ "GetFilePath", GetFilePath, 0, 0, 0 },	// returns the full path of the file
 	{ "NextFile", NextFile, 0, 0, 0 },	// Advance search to the next file
 	{ "GetFileSize", GetFileSize, 0, 0, 0 },	// Returns the size of the file in bytes
 	{ "GetExtension", GetExtension, 0, 0, 0 },	// Returns the extension of the current file
@@ -214,6 +215,17 @@
 	return JS_TRUE;
 }// end GetFileDirectory
 
+JSBool ADM_JSDirectorySearch::GetFilePath(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
+{// begin GetFilePath
+	ADM_JSDirectorySearch *p = (ADM_JSDirectorySearch *)JS_GetPrivate(cx, obj);
+	// default return value
+	*rval = BOOLEAN_TO_JSVAL(false);
+	if(argc != 0)
+		return JS_FALSE;
+	*rval = STRING_TO_JSVAL(JS_NewStringCopyZ(cx,p->getObject()->GetFilePath().c_str()));
+	return JS_TRUE;
+}// end GetFilePath
+
 JSBool ADM_JSDirectorySearch::GetFileName(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
 {// begin GetFileName
 	ADM_JSDirectorySearch *p = (ADM_JSDirectorySearch *)JS_GetPrivate(cx, obj);

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSDirectorySearch.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSDirectorySearch.h	2008-07-26 18:58:33 UTC (rev 4285)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSDirectorySearch.h	2008-07-26 18:58:34 UTC (rev 4286)
@@ -28,6 +28,7 @@
 	static JSBool Init(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval);
 	static JSBool GetFileSize(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval);
 	static JSBool GetFileDirectory(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval);
+	static JSBool GetFilePath(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval);
 	static JSBool GetFileName(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval);
 	static JSBool Close(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval);
 

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/DirectorySearch.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/DirectorySearch.cpp	2008-07-26 18:58:33 UTC (rev 4285)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/DirectorySearch.cpp	2008-07-26 18:58:34 UTC (rev 4286)
@@ -113,11 +113,7 @@
 		printf("Find first failed\n");
 		return false;
 	}
-#ifdef __WIN32   //ndef __unix__
-	m_sDirectory = GetFileDirectory(sDirectory);
-#else
 	m_sDirectory = sDirectory;
-#endif
 	return true;
 }// end Init
 



From mean at mail.berlios.de  Sat Jul 26 20:58:36 2008
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sat, 26 Jul 2008 20:58:36 +0200
Subject: [Avidemux-svn-commit] r4287 -
	branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script
Message-ID: <200807261858.m6QIwaK8014206@sheep.berlios.de>

Author: mean
Date: 2008-07-26 20:58:36 +0200 (Sat, 26 Jul 2008)
New Revision: 4287

Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSFunctions.cpp
Log:
[Merge] 4278


Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSFunctions.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSFunctions.cpp	2008-07-26 18:58:34 UTC (rev 4286)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSFunctions.cpp	2008-07-26 18:58:36 UTC (rev 4287)
@@ -14,7 +14,7 @@
 #include <unistd.h>
 #include <sys/types.h>
 #include <sys/stat.h>
-#ifndef __MINGW32__
+#ifndef ADM_WIN32
 #include <sys/wait.h>
 #include <sys/param.h>
 #endif
@@ -317,14 +317,8 @@
         *rval=STRING_TO_JSVAL(JS_NewStringCopyZ(cx,n));
         return JS_TRUE;
 }
-#ifdef __MINGW32__
 
 JSBool systemExecute(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
-{
-		return JS_FALSE;
-}
-#else
-JSBool systemExecute(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
 {// begin systemExecute
 	// default return value
 	*rval = INT_TO_JSVAL(-1);
@@ -359,6 +353,8 @@
 		}// end failure to get item
 		args[JSVAL_TO_INT(i)] = JS_GetStringBytes(JSVAL_TO_STRING(jsValue));
 	}
+
+#ifndef ADM_WIN32
 	if(getuid() == 0)
 	{// begin running as root
 		JS_ReportError(cx, "exec() disallowed while running as root.");
@@ -374,6 +370,7 @@
 		JS_ReportError(cx, "exec() disallowed execution of \"%s\" since it is a setuid/setgid file.", pExecutable);
 		return JS_FALSE;
 	}// end setuid/setgid files disallowed
+#endif
 
         enterLock();
 	// clear file descriptor table of forked process and fork
@@ -382,6 +379,11 @@
 #elif defined(__FreeBSD__) || defined(__OpenBSD__)
 	pid_t pidRtn = rfork(RFPROC|RFCFDG);
 #endif
+
+#ifdef ADM_WIN32
+	intptr_t pidRtn = spawnvpe(bWait ? P_WAIT : P_NOWAIT, pExecutable, args, environ);
+	#define WEXITSTATUS
+#else
 	if(pidRtn == 0)
 	{// begin child process
 #if defined( __linux__) || defined(__macosx__) || defined(__APPLE__) || defined(__CYGWIN__)
@@ -409,6 +411,8 @@
 	{// begin rfork failure
 		printf("Error: execve failure errno(%d)\n",errno);
 	}// end rfork failure
+#endif
+
         leaveLock();
 
 	// cleanup
@@ -419,8 +423,7 @@
 		*rval = INT_TO_JSVAL(-1);	// failure
 	return JS_TRUE;
 }// end systemExecute
-#endif
-#ifdef __MINGW32__
+#ifdef ADM_WIN32
 
 JSBool systemInclude(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
 {



From mean at mail.berlios.de  Sat Jul 26 20:58:39 2008
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sat, 26 Jul 2008 20:58:39 +0200
Subject: [Avidemux-svn-commit] r4289 -
	branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script
Message-ID: <200807261858.m6QIwcLq014256@sheep.berlios.de>

Author: mean
Date: 2008-07-26 20:58:38 +0200 (Sat, 26 Jul 2008)
New Revision: 4289

Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSFunctions.cpp
Log:
[Merge] 4280


Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSFunctions.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSFunctions.cpp	2008-07-26 18:58:37 UTC (rev 4288)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSFunctions.cpp	2008-07-26 18:58:38 UTC (rev 4289)
@@ -423,15 +423,7 @@
 		*rval = INT_TO_JSVAL(-1);	// failure
 	return JS_TRUE;
 }// end systemExecute
-#ifdef ADM_WIN32
-
 JSBool systemInclude(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
-{
-		return JS_FALSE;
-}
-#else
-
-JSBool systemInclude(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
 {// begin systemInclude
 	// default return value
 	*rval = BOOLEAN_TO_JSVAL(false);
@@ -445,7 +437,11 @@
 	// make sure we haven't included this already to avoid a recursive
 	// dependency loop
 	char *pTempStr = new char[PATH_MAX+1];
+ #ifdef __MINGW32__
+ 	if(_fullpath(pTempStr,pIncludeFile,PATH_MAX) == NULL)
+ #else
 	if(realpath(pIncludeFile,pTempStr) == NULL)
+#endif
 	{// begin can't resolve path
 		JS_ReportError(cx, "include() can't resolve the path of \"%s\".", pIncludeFile);
 		return JS_FALSE;
@@ -483,7 +479,6 @@
 	}// end error including
 	return JS_TRUE;
 }// end systemInclude
-#endif
 
 /********************** Extract Path from a filename **************/
 JSBool pathOnly(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)



From mean at mail.berlios.de  Sat Jul 26 20:58:40 2008
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sat, 26 Jul 2008 20:58:40 +0200
Subject: [Avidemux-svn-commit] r4290 -
	branches/avidemux_2.5_branch_gruntster/avidemux/ADM_infoExtractor
Message-ID: <200807261858.m6QIweo9014266@sheep.berlios.de>

Author: mean
Date: 2008-07-26 20:58:40 +0200 (Sat, 26 Jul 2008)
New Revision: 4290

Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_infoExtractor/ADM_infoextractor.cpp
Log:
[Merge] 4282


Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_infoExtractor/ADM_infoextractor.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_infoExtractor/ADM_infoextractor.cpp	2008-07-26 18:58:38 UTC (rev 4289)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_infoExtractor/ADM_infoextractor.cpp	2008-07-26 18:58:40 UTC (rev 4290)
@@ -333,7 +333,7 @@
 {
    GetBitContext s;
    
-   uint32_t profile,constraint,level,pic_order_cnt_type,w,h,z;
+   uint32_t profile,constraint,level,pic_order_cnt_type,w,h, mbh, frame_mbs_only;
    uint8_t buf[len];
    uint32_t outlen;
    uint32_t id,dum;
@@ -389,15 +389,17 @@
            dum=get_ue_golomb(&s);     //num_ref_frames
            printf("[H264] # of ref frames : %u\n",dum);
            get_bits1(&s);         // gaps_in_frame_num_value_allowed_flag
-           w=get_ue_golomb(&s);   //pic_width_in_mbs_minus1
-           h=get_ue_golomb(&s);   //pic_height_in_mbs_minus1
-           z=get_ue_golomb(&s); 
+		   w = get_ue_golomb(&s) + 1;   //pic_width_in_mbs_minus1
+
+		   mbh = get_ue_golomb(&s) + 1;
+		   frame_mbs_only = get_bits1(&s);
+		   h = (2 - frame_mbs_only) * mbh;   //pic_height_in_mbs_minus1
+
            printf("[H264] Width in mb -1  :%d\n",w); 
            printf("[H264] Height in mb -1 :%d\n", h);
-           printf("[H264] z               :%d\n", z);  
-            *wwidth=(w+1)*16;
-            *hheight=(h+1)*16*2; /* Fixme : frame_mbs_only_flag in slice header!! */
 
+		   *wwidth = w * 16;
+		   *hheight= h * 16;
            
            return 1;
 }



From mean at mail.berlios.de  Sat Jul 26 20:58:37 2008
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sat, 26 Jul 2008 20:58:37 +0200
Subject: [Avidemux-svn-commit] r4288 -
	branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script
Message-ID: <200807261858.m6QIwbnG014246@sheep.berlios.de>

Author: mean
Date: 2008-07-26 20:58:37 +0200 (Sat, 26 Jul 2008)
New Revision: 4288

Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSFunctions.cpp
Log:
[Merge] 4279


Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSFunctions.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSFunctions.cpp	2008-07-26 18:58:36 UTC (rev 4287)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSFunctions.cpp	2008-07-26 18:58:37 UTC (rev 4288)
@@ -340,18 +340,18 @@
 		return JS_FALSE;
 
 	JS_GetArrayLength(cx,pArgs,&nArgsLength);
-	char **args = new char *[JSVAL_TO_INT(nArgsLength)+2];
+	char **args = new char *[nArgsLength + 2];
 	args[0] = pExecutable;
-	args[JSVAL_TO_INT(nArgsLength)+1] = NULL;
+	args[nArgsLength + 1] = NULL;
 
-	for(jsuint i = 1;i <= nArgsLength;i++)
+	for(int i = 0; i < nArgsLength; i++)
 	{
 		if(JS_GetElement(cx, pArgs, i, &jsValue) == JS_FALSE)
 		{// begin failure to get item
 			JS_ReportError(cx, "exec() JS_GetElement failed to get an array item.");
 			return JS_FALSE;
 		}// end failure to get item
-		args[JSVAL_TO_INT(i)] = JS_GetStringBytes(JSVAL_TO_STRING(jsValue));
+		args[i + 1] = JS_GetStringBytes(JSVAL_TO_STRING(jsValue));
 	}
 
 #ifndef ADM_WIN32



From mean at mail.berlios.de  Sat Jul 26 20:58:45 2008
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sat, 26 Jul 2008 20:58:45 +0200
Subject: [Avidemux-svn-commit] r4291 - in
	branches/avidemux_2.5_branch_gruntster/avidemux:
	ADM_infoExtractor ADM_inputs/ADM_mpegdemuxer
Message-ID: <200807261858.m6QIwjcA014323@sheep.berlios.de>

Author: mean
Date: 2008-07-26 20:58:41 +0200 (Sat, 26 Jul 2008)
New Revision: 4291

Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_infoExtractor/ADM_infoextractor.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_indexer_h264.cpp
Log:
[Merge] 4283


Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_infoExtractor/ADM_infoextractor.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_infoExtractor/ADM_infoextractor.cpp	2008-07-26 18:58:40 UTC (rev 4290)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_infoExtractor/ADM_infoextractor.cpp	2008-07-26 18:58:41 UTC (rev 4291)
@@ -324,12 +324,65 @@
     return outlen;
     
 }
+
+static uint8_t extractVUIInfo(GetBitContext *s, uint32_t *fps1000)
+{
+	*fps1000 = 0;
+
+	if (get_bits1(s))
+	{
+		unsigned int aspect_ratio_information = get_bits(s, 8);
+
+		if (aspect_ratio_information == 255)
+		{
+			get_bits(s, 16);
+			get_bits(s, 16);
+		}
+	}
+
+	if (get_bits1(s))	// overscan
+		get_bits1(s);
+
+	if (get_bits1(s))	// vsp_color
+	{
+		get_bits(s, 4);
+
+		if (get_bits1(s))
+		{
+			get_bits(s, 8);
+			get_bits(s, 8);
+			get_bits(s, 8);
+		}
+	}
+
+	if (get_bits1(s))	// chroma
+	{
+		get_ue_golomb(s);
+		get_ue_golomb(s);
+	}
+
+	if (get_bits1(s))	// timing
+	{
+		uint32_t timeinc_unit = get_bits_long(s, 32);
+		uint32_t timeinc_resolution = get_bits_long(s, 32);
+		uint32_t fixed_fps = get_bits1(s);
+
+		if (timeinc_unit > 0 && timeinc_resolution > 0)
+			*fps1000 = (uint32_t)(((float)timeinc_resolution / (float)timeinc_unit) * 1000);
+
+		if (fixed_fps)
+			*fps1000 /= 2;
+	}
+
+	return 1;
+}
+
 /**
     \fn extractSPSInfo
     \brief Extract info from H264 SPS
     See 7.3.2.1 of 14496-10
 */
-uint8_t extractSPSInfo(uint8_t *data, uint32_t len,uint32_t *wwidth,uint32_t *hheight)
+uint8_t extractSPSInfo(uint8_t *data, uint32_t len,uint32_t *wwidth,uint32_t *hheight, uint32_t *fps1000)
 {
    GetBitContext s;
    
@@ -401,6 +454,22 @@
 		   *wwidth = w * 16;
 		   *hheight= h * 16;
            
+		   if (!frame_mbs_only)
+			   get_bits1(&s);
+
+		   get_bits1(&s);
+
+		   if(get_bits1(&s))
+		   {
+			   get_ue_golomb(&s);
+			   get_ue_golomb(&s);
+			   get_ue_golomb(&s);
+			   get_ue_golomb(&s);
+		   }
+
+		   if(get_bits1(&s))
+			   extractVUIInfo(&s, fps1000);
+
            return 1;
 }
 /**

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_indexer_h264.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_indexer_h264.cpp	2008-07-26 18:58:40 UTC (rev 4290)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_indexer_h264.cpp	2008-07-26 18:58:41 UTC (rev 4291)
@@ -47,7 +47,7 @@
 static const char Type[5]={'X','I','P','B','P'};
 
 
-extern uint8_t extractSPSInfo(uint8_t *data, uint32_t len,uint32_t *wwidth,uint32_t *hheight);
+extern uint8_t extractSPSInfo(uint8_t *data, uint32_t len,uint32_t *wwidth,uint32_t *hheight, uint32_t *fps1000);
 
 dmx_videoIndexerH264::dmx_videoIndexerH264(dmx_runData *run) : dmx_videoIndexer(run)
 {
@@ -144,14 +144,12 @@
                     // Our firt frame is here
                     // Important to initialize the mpeg decoder !
                     _run->imageAR = 1;	// 1:1 to suppress warning
-                    _run->imageFPS=25000; 
-                    //
-                    
+
                       uint8_t buffer[60] ; // should be enough
                       uint64_t xA,xR;
                       _run->demuxer->getPos(&xA,&xR);
                       _run->demuxer->read(buffer,60);
-                      if(extractSPSInfo(buffer,60,&( _run->imageW),&( _run->imageH)))
+                      if(extractSPSInfo(buffer,60,&( _run->imageW),&( _run->imageH),&(_run->imageFPS)))
                       {
                             seq_found=1;
                             startFrame(1,syncAbs,syncRel);



From gruntster at mail.berlios.de  Sun Jul 27 04:54:51 2008
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Sun, 27 Jul 2008 04:54:51 +0200
Subject: [Avidemux-svn-commit] r4292 -
	branches/avidemux_2.4_branch/avidemux/ADM_infoExtractor
Message-ID: <200807270254.m6R2sp5d025657@sheep.berlios.de>

Author: gruntster
Date: 2008-07-27 04:54:44 +0200 (Sun, 27 Jul 2008)
New Revision: 4292

Modified:
   branches/avidemux_2.4_branch/avidemux/ADM_infoExtractor/ADM_h264_tag.h
Log:
[TS] compilation fix

Modified: branches/avidemux_2.4_branch/avidemux/ADM_infoExtractor/ADM_h264_tag.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_infoExtractor/ADM_h264_tag.h	2008-07-26 18:58:41 UTC (rev 4291)
+++ branches/avidemux_2.4_branch/avidemux/ADM_infoExtractor/ADM_h264_tag.h	2008-07-27 02:54:44 UTC (rev 4292)
@@ -1,23 +1,48 @@
-/***************************************************************************
-                      NAL TYPE for H264
-                      
-**************************************************************************/
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#ifndef ADM_H264_TAG_H
-#define ADM_H264_TAG_H
-#define NAL_NON_IDR       1
-#define NAL_IDR           5
-#define NAL_SEI           6
-#define NAL_SPS           7
-#define NAL_PPS           8
-#define NAL_AU_DELIMITER  9
-#define NAL_FILLER        12
-#endif
-//EOF
+/***************************************************************************
+                      NAL TYPE for H264
+                      
+**************************************************************************/
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#ifndef ADM_H264_TAG_H
+#define ADM_H264_TAG_H
+#define NAL_NON_IDR       1
+#define NAL_IDR           5
+#define NAL_SEI           6
+#define NAL_SPS           7
+#define NAL_PPS           8
+#define NAL_AU_DELIMITER  9
+#define NAL_FILLER        12
+
+typedef struct AspectRatio {
+    int num;
+    int den;
+} AspectRatio;
+
+const AspectRatio pixel_aspect[17] = {
+	{0, 1},
+	{1, 1},
+	{12, 11},
+	{10, 11},
+	{16, 11},
+	{40, 33},
+	{24, 11},
+	{20, 11},
+	{32, 11},
+	{80, 33},
+	{18, 11},
+	{15, 11},
+	{64, 33},
+	{160,99},
+	{4, 3},
+	{3, 2},
+	{2, 1},
+};
+#endif
+//EOF



From gruntster at mail.berlios.de  Tue Jul 29 23:55:40 2008
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Tue, 29 Jul 2008 23:55:40 +0200
Subject: [Avidemux-svn-commit] r4293 -
	branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer
Message-ID: <200807292155.m6TLteDS002200@sheep.berlios.de>

Author: gruntster
Date: 2008-07-29 23:55:32 +0200 (Tue, 29 Jul 2008)
New Revision: 4293

Modified:
   branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_demuxerTS.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_io.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_io.h
   branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_probeTS.cpp
Log:
[m2ts] rework parsing of PAT/PMT in m2ts demuxer

Modified: branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_demuxerTS.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_demuxerTS.cpp	2008-07-27 02:54:44 UTC (rev 4292)
+++ branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_demuxerTS.cpp	2008-07-29 21:55:32 UTC (rev 4293)
@@ -552,8 +552,12 @@
         pid=parser->read16i();
         if((pid>>8) & TS_UNIT_START) payloadunit=1;
         pid&=0x1fff; // remove flags
+
+#ifdef TS_VERBOSE
         if(discarded)
                 printf("Ts: Discontinuity of %lu at %"LLX" pid:%lx\n",discarded,abs,pid);
+#endif
+
         // Start of packet..
         left=TS_PacketSize-3;
         if(_probeSize)

Modified: branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_io.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_io.cpp	2008-07-27 02:54:44 UTC (rev 4292)
+++ branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_io.cpp	2008-07-29 21:55:32 UTC (rev 4293)
@@ -26,7 +26,7 @@
 #include <math.h>
 
 #include "default.h"
-#include <ADM_assert.h>
+#include "ADM_assert.h"
 
 #include "dmx_io.h"
 
@@ -505,3 +505,40 @@
         return r;
 }
 #endif
+
+void fileParser::hexDump(uint8_t *buf, int size)
+{
+	int len, i, j, c;
+
+	for(i=0;i<size;i+=16)
+	{
+		len = size - i;
+
+		if (len > 16)
+			len = 16;
+
+		printf("%08x ", i);
+
+		for(j=0;j<16;j++)
+		{
+			if (j < len)
+				printf(" %02x", buf[i+j]);
+			else
+				printf("   ");
+		}
+
+		printf(" ");
+
+		for(j=0;j<len;j++)
+		{
+			c = buf[i+j];
+
+			if (c < ' ' || c > '~')
+				c = '.';
+
+			printf("%c", c);
+		}
+
+		printf("\n");
+	}
+}

Modified: branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_io.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_io.h	2008-07-27 02:54:44 UTC (rev 4292)
+++ branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_io.h	2008-07-29 21:55:32 UTC (rev 4293)
@@ -58,6 +58,7 @@
                         uint64_t getSize( void ) ;
                         uint32_t read32(uint32_t l, uint8_t *buffer);
                         uint8_t  end(void) { return _off==_size-1;};
+						void hexDump(uint8_t *buf, int size);
 #ifdef NO_INLINE_FP
                         uint32_t read32i(void );
                         uint16_t read16i(void );

Modified: branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_probeTS.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_probeTS.cpp	2008-07-27 02:54:44 UTC (rev 4292)
+++ branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_probeTS.cpp	2008-07-29 21:55:32 UTC (rev 4293)
@@ -22,7 +22,7 @@
 #include <math.h>
 
 #include "default.h"
-#include <ADM_assert.h>
+#include "ADM_assert.h"
 
 
 #include "ADM_toolkit/toolkit.hxx"
@@ -47,51 +47,48 @@
 
 
 
-#define MAX_PROBE (10*1024*1024LL) // Scans the 4 first meg
+#define MAX_PROBE 2000000 // Scans the first 2 meg
 #define MIN_DETECT (10*1024) // Need this to say the stream is present
 #define MAX_NB_PMT 50
+#define MAX_NB_TRACK 50
 
 //#define PROBE_TS_VERBOSE
 
-//****************************************************************************************
 typedef struct MPEG_PMT
 {
-   uint32_t         programNumber;
-   uint32_t         tid;
-}MPEG_PMT;
-//****************************************************************************************
+	uint16_t programNumber;
+	uint16_t tid;
+} MPEG_PMT;
 
 uint8_t dmx_probeTS(const char *file,  uint32_t *nbTracks,MPEG_TRACK **tracks,DMX_TYPE t);
-//****************************************************************************************
+
 static uint8_t dmx_probeTSBruteForce(const char *file,  uint32_t *nbTracks,MPEG_TRACK **tracks,DMX_TYPE type);
-static uint8_t dmx_probeTSPat(const char *file, uint32_t *nbTracks,MPEG_TRACK **tracks,DMX_TYPE type);
-static uint8_t dmx_probePat(dmx_demuxerTS *demuxer, uint32_t *nbPmt,MPEG_PMT *pmts,uint32_t maxPmt);
-static uint8_t dmx_probePMT(dmx_demuxerTS *demuxer, uint32_t pmtId,MPEG_TRACK *pmts,uint32_t *cur, uint32_t max);
+static uint8_t dmx_probeTsPatPmt(const char *file, uint32_t *nbTracks, MPEG_TRACK **tracks, DMX_TYPE type);
+static int dmx_parsePat(dmx_demuxerTS *demuxer, int *nbPmt, MPEG_PMT *pmts, int maxPmt);
+static int dmx_parsePmt(dmx_demuxerTS *demuxer, int pid, MPEG_TRACK *pmts, int *cur, int max);
 
+static const char *dmx_streamType(uint32_t type,ADM_STREAM_TYPE *streamType);
 static const char *dmx_streamTypeAsString(ADM_STREAM_TYPE st);
  
 extern uint32_t mpegTsCRC(uint8_t *data, uint32_t len);
-//*********************************************************
+
 uint8_t runProbe(const char *file)
 {
   uint32_t nb;
   MPEG_TRACK *t;
-  return  dmx_probeTSPat(file, &nb,&t,DMX_MPG_TS);
-  
+  return dmx_probeTsPatPmt(file, &nb,&t,DMX_MPG_TS);
 }
 
 uint8_t dmx_probeTS(const char *file,  uint32_t *nbTracks,MPEG_TRACK **tracks,DMX_TYPE type)
 {
-  
-    // Try through PMT/PAT first
-      if( type==DMX_MPG_TS2 || !dmx_probeTSPat(file,nbTracks,tracks,type))
-      //if( !dmx_probeTSPat(file,nbTracks,tracks,type))
-      {
-        
-        printf("PAT/PMT Failed, using brute force\n");
-        return dmx_probeTSBruteForce(file,nbTracks,tracks,type);
-      }
-      return 1;
+	// Try through PMT/PAT first
+	if (!dmx_probeTsPatPmt(file, nbTracks, tracks, type))
+	{
+		printf("PAT/PMT Failed, using brute force\n");
+		return dmx_probeTSBruteForce(file,nbTracks,tracks,type);
+	}
+
+	return 1;
 }
 /**************************************
 ****************************************************************
@@ -136,8 +133,8 @@
         {
           return 0;
         }
-    // Set probe to 10 Meg
-      demuxer.setProbeSize(10*1024*1024L);
+
+      demuxer.setProbeSize(MAX_PROBE);
       parser=demuxer.getParser();
       // And run
 
@@ -264,216 +261,193 @@
       @param **tracks : contains info about the tracks found (out)
 
 */
-uint8_t dmx_probeTSPat(const char *file, uint32_t *nbTracks,MPEG_TRACK **tracks,DMX_TYPE type)
+uint8_t dmx_probeTsPatPmt(const char *file, uint32_t *nbTracks, MPEG_TRACK **tracks, DMX_TYPE type)
 {
-MPEG_TRACK dummy[TS_ALL_PID];
-fileParser *parser;
-uint32_t   foundPid=0;
-myPid      allPid[MAX_FOUND_PID];
-uint8_t    buffer[BUFFER_SIZE];
-MpegAudioInfo mpegInfo; 
-#define MAX_STREAM 50
-#define MAX_NB_TRACK 50
-    dummy[0].pid=0x00; // should no be in use
-    dummy[0].pes=0xE0;
+	MPEG_TRACK dummy[TS_ALL_PID];
+	fileParser *parser;
+	uint32_t pid, left, cc, isPayloadStart;
+	uint64_t abso;
+	int nbPmt = 0, cur = 0;
+	MPEG_PMT pmts[MAX_NB_PMT];
+	MPEG_TRACK xtracks[MAX_NB_TRACK];
 
-        dmx_demuxerTS demuxer(1,dummy,1,type);
-        if(!demuxer.open(file))
-        {
-          return 0;
-        }
-    // Set probe to 10 Meg
-      demuxer.setProbeSize(10*1024*1024L);
-      uint32_t nbPmt;
-      MPEG_PMT pmts[MAX_NB_PMT];
-      MPEG_TRACK xtracks[MAX_NB_TRACK];
-      
-      if(!dmx_probePat(&demuxer,&nbPmt,pmts,MAX_NB_PMT))
-      {
-        aprintf("[PSI Probe]Cannot find Pat\n"); 
-        parser=NULL;
-        return 0;
-      }
-      printf("Found %d PMT..\n",nbPmt);
-      demuxer.setProbeSize(40*1024*1024L); // We can can increase the probe size
-      uint32_t cur=0;
-      for(int i=0;i<nbPmt;i++)
-      {
-         dmx_probePMT(&demuxer, pmts[i].tid,xtracks,&cur,MAX_NB_TRACK);
-      }
-      printf("***********************\n");
-      printf("***********************\n");
-      printf("Summary of stream found\n");
-      printf("***********************\n");
-      printf("***********************\n");
-      for(int i=0;i<cur;i++)
-      {
-        printf("Tid : %04x Type :%d %s\n", xtracks[i].pid,xtracks[i].streamType,
-               dmx_streamTypeAsString(xtracks[i].streamType));
-      }
-      printf("******************************\n");
-      printf("******************************\n");
-      printf("End of summary of stream found\n");
-      printf("******************************\n");
-      printf("******************************\n");
-      
-      if(!cur)        return 0;
-      
-      // Search first video track
-      *tracks=new MPEG_TRACK[cur];
-      int found=-1;
-      for(int j=0;j<cur;j++)
-      {
-        ADM_STREAM_TYPE type=xtracks[j].streamType;
-        if(type==ADM_STREAM_MPEG_VIDEO ||  type==ADM_STREAM_MPEG4 || type==ADM_STREAM_H264)
-        {
-          found=j;
-          break;  
-        }
-      }
-      if(found<0)
-      {
-        printf("No video track\n");
-        delete [] *tracks;
-        return 0; 
-      }
-      memcpy(*tracks,&(xtracks[found]),sizeof(MPEG_TRACK));
-      *nbTracks=1;
-      // Now do audio
-      for(int j=0;j<cur;j++)
-      {
-         MPEG_TRACK *t=&(xtracks[j]);
-         ADM_STREAM_TYPE type=t->streamType;
-          if(type!=ADM_STREAM_MPEG_AUDIO && type!=ADM_STREAM_AC3
-            &&type!=ADM_STREAM_AAC) continue; // Only mpega & AC3 for now
-          switch(type)
-          {
-            case ADM_STREAM_AAC:
-                  t->pes=0xb0;
-            case ADM_STREAM_MPEG_AUDIO:
-            case ADM_STREAM_AC3:
-            
-              memcpy(&((*tracks)[*nbTracks]),t,sizeof(MPEG_TRACK));
-              ADM_assert(*nbTracks<cur);
-              (*nbTracks)++;
-              break;
-            
-            default: ADM_assert(0); 
-          }
-      }
-      printf("Found %u tracks\n",*nbTracks);
-      //
-      return 1;
-      
+	dummy[0].pid=0x00; // should not be in use
+	dummy[0].pes=0xE0;
+
+	dmx_demuxerTS demuxer(TS_ALL_PID, dummy, 1, type);
+
+	if (!demuxer.open(file))
+		return 0;
+
+	demuxer.setProbeSize(MAX_PROBE);
+
+	parser = demuxer.getParser();
+
+	while (demuxer.readPacket(&pid, &left, &isPayloadStart, &abso, &cc))
+	{
+		if (!isPayloadStart || left <= (9 + 4))
+		{
+			parser->forward(left);
+			continue;
+		}
+
+		if (pid == 0)
+		{
+			aprintf("[TS] parse PAT: (pid: %d)\n", pid);
+			dmx_parsePat(&demuxer, &nbPmt, pmts, MAX_NB_PMT);
+		}
+		else
+		{
+			aprintf("[TS] PMT found (pid: %d)\n", pid);
+
+			for (int i = 0; i < nbPmt; i++)
+			{
+				if (pmts[i].tid == pid)
+				{
+					aprintf("[TS] parse PMT (pid: %d)\n", pid);
+					dmx_parsePmt(&demuxer, pid, xtracks, &cur, MAX_NB_TRACK);
+
+					break;
+				}
+			}
+		}
+	}
+
+	if (!cur)
+		return 0;
+
+	for(int i = 0; i < cur; i++)
+		printf("Tid: %04x Type: %d (%s)\n", xtracks[i].pid, xtracks[i].streamType, dmx_streamTypeAsString(xtracks[i].streamType));
+
+	// Search first video track
+	*tracks = new MPEG_TRACK[cur];
+	int found = -1;
+
+	for(int j = 0; j < cur; j++)
+	{
+		ADM_STREAM_TYPE type = xtracks[j].streamType;
+
+		if(type == ADM_STREAM_MPEG_VIDEO || type==ADM_STREAM_MPEG4 || type==ADM_STREAM_H264)
+		{
+			found = j;
+			break;
+		}
+	}
+
+	if (found < 0)
+	{
+		printf("No video track\n");
+		delete [] *tracks;
+
+		return 0; 
+	}
+
+	memcpy(*tracks, &(xtracks[found]), sizeof(MPEG_TRACK));
+	*nbTracks = 1;
+
+	// Now do audio
+	for (int j = 0; j < cur; j++)
+	{
+		MPEG_TRACK *t = &(xtracks[j]);
+		ADM_STREAM_TYPE type = t->streamType;
+
+		if (type != ADM_STREAM_MPEG_AUDIO && type != ADM_STREAM_AC3 && type != ADM_STREAM_AAC)
+			continue; // Only mpega & AC3 for now
+
+		switch(type)
+		{
+			case ADM_STREAM_AAC:
+				t->pes = 0xb0;
+			case ADM_STREAM_MPEG_AUDIO:
+			case ADM_STREAM_AC3:
+				memcpy(&((*tracks)[*nbTracks]), t, sizeof(MPEG_TRACK));
+				ADM_assert(*nbTracks < cur);
+				(*nbTracks)++;
+
+				break;
+			default:
+				ADM_assert(0); 
+		}
+	}
+
+	printf("Found %u tracks\n", *nbTracks);
+
+	return 1;
 }
+
 /**
-      \fn     dmx_searchAndSkipHeader
-      \brief  Search for a given PSI and skip header
+      \fn     dmx_probePat(dmx_demuxerTS *demuxer, uint32_t *nbPmt,MPEG_PMT *pmts,uint32_t maxPMT)
+      \brief  Search for PAT and returns PMT info if found
       @return 1 on success, 0 on failure
-      @param myPid : Pid of the looked for psi
-      @param demuxer: mpegTS demuxer *(input)
-      @param *currentSec : current section (output)
-      @param *maxSec : #of sections (output)
-      @param *leftbyte : Total #of bytes left in the packet
-      @param *payloadSize : #of bytes of usable payload
+      @param demuxer: mpegTS demuxer (input)
+      @param *nbPmt : number of PMTS found (output)
+      @param *pmts : contains info about the PMT found (out but must be allocated by caller)
+      @param maxPMT : Maximum # of PMT we accept in pmts (in)
 
 */
-uint8_t dmx_searchAndSkipHeader(uint32_t myPid,dmx_demuxerTS *demuxer,uint32_t *currentSec, uint32_t *maxSec,
-                                    uint32_t *leftbyte,uint32_t *payloadSize)
+int dmx_parsePat(dmx_demuxerTS *demuxer, int *nbPmt, MPEG_PMT *pmts, int maxPmt)
 {
-  
-  uint8_t packet[TS_PACKET_SIZE*2];
-  uint32_t tableId;
-  uint32_t misc;
-  uint32_t sectionLength;
-  uint32_t tId,pid,left,cc,nbPmt;
-  uint32_t version,isPayloadStart;
-  uint32_t sectionNumber;
-  uint32_t lastSectionNumber;
-  uint32_t programInfoLength;
-  uint32_t crc,crccomputed;
-  uint64_t startPos,endPos,abso;
-  fileParser *parser;
-      demuxer->changePid(myPid,myPid); // Search PAT
-      parser=demuxer->getParser();
-      
-        while(demuxer->readPacket(&pid,&left, &isPayloadStart,&abso,&cc))
-        {
-          if(pid!=myPid)
-          {
-            printf("Wrong Pid %x/%x\n",pid,myPid);
-            parser->forward(left);
-            continue;
-          }
-          if(!isPayloadStart || left <= (9+4))
-          {
-            parser->forward(left);
-            continue;
-          }
+	uint8_t tableId, sectionNumber, lastSectionNumber;
+	uint16_t sectionLength, progId;
+	uint64_t startPos;
+	fileParser *parser = demuxer->getParser();
+	int entries;
 
-          /* Found something that looks good...*/
-            
-            /* Decode PSI header */
-            parser->read8i(); /* Pointer field, can be ignored (?) */
-              
-              parser->getpos(&startPos); /* Memorize beginning */
-              tableId=parser->read8i();
-              misc=parser->read16i(); // +3
-              tId=parser->read16i();  
-              version=parser->read8i(); // +6
-              sectionNumber=parser->read8i();
-              lastSectionNumber=parser->read8i(); // +8
-              
-              sectionLength=misc&0xFFF;
-              
-              if(sectionLength<=9 || sectionLength > (left-4) || left<9)
-              {
-                printf("SectionLength too short :%d,left %d\n", sectionLength,left);
-                 parser->setpos(startPos-1+left); // skip packet
-                 continue;
-              }
-              
-#ifdef PROBE_TS_VERBOSE
-              printf("******************************************\n");
-              printf("tableId        : %d\n",tableId);
-              
-              printf("sectionLength  : %d\n",sectionLength);
-              printf("0              : %x\n",misc&0x40);
-              printf("section syntax : %x\n",misc&0x80);
-              printf("Transport ID   : 0x%x\n",tId);
-              printf("Version Number : 0x%x\n",(version>>1)&0x1F);
-              printf("CurrentNext    : 0x%x\n",version&1);
-              
-              printf("Section        : %d\n",sectionNumber);
-              printf("LastSection    : %d\n",lastSectionNumber);
-              
-#endif
-              // Check for error FIXME TODO
-              
-              // Check CRC
-              parser->getpos(&endPos); // Here payload begins
-              parser->setpos(startPos);
-              parser->read32(sectionLength-1,packet); // Go back & Read Whole packet +3 for header -4 CRC
-              crc=parser->read32i();
-              crccomputed=mpegTsCRC(packet,sectionLength-1);
-              if(crc!=crccomputed) // Bad CRC, skip packet
-              {
-                aprintf("Bad CRC\n");
-                parser->setpos( startPos+left-1); // skip
-                continue;
-              }
-              // CRC is ok, go back to interesting place
-              aprintf("CRC OK\n");
-              parser->setpos(endPos);
-              *currentSec=sectionNumber;
-              *maxSec=lastSectionNumber;
-              
-              *leftbyte=left-9;               // Total bytes left in packet
-              *payloadSize=sectionLength-9; // No CRC, No header
-              return 1;
-          } // /while
-      return 0;
+	parser->getpos(&startPos);
+
+	// Decode PSI header
+	parser->read8i();	// Pointer field, can be ignored (?)
+
+	tableId = parser->read8i();	// 0
+
+	if (tableId != 0)
+	{
+		parser->setpos(startPos);
+		return 0;
+	}
+
+	sectionLength = ((parser->read8i() & 0x03) << 8 ) | parser->read8i();	// 1 & 2
+	parser->read16i();	// 3 & 4
+	parser->read8i(); // 5
+	sectionNumber = parser->read8i();	// 6
+	lastSectionNumber = parser->read8i(); // 7	
+
+	aprintf("[TS] parsePat: sectionLength: %d, section %d/%d @ %"LLU"\n", sectionLength, sectionNumber, lastSectionNumber, startPos);
+
+	entries = (int)(sectionLength - 9) / 4;	// entries per section
+	*nbPmt = 0;
+
+	for (int i = 0; i < entries; i++)
+	{
+		bool foundProg = false;
+
+		progId = (parser->read8i() << 8) | parser->read8i();
+
+		for (int j = 0; j < *nbPmt; j++)
+		{
+			if (pmts[j].programNumber == progId)
+			{
+				foundProg = true;
+				break;
+			}
+		}
+
+		if (!foundProg && *nbPmt < maxPmt)
+		{
+			pmts[*nbPmt].programNumber = progId;
+			pmts[*nbPmt].tid = ((parser->read8i() & 0x1F) << 8) | parser->read8i();
+
+			aprintf("[TS] parsePat: programNumber: %d (%d/%d), PMT: %d\n", pmts[*nbPmt].programNumber, i + 1, entries, pmts[*nbPmt].tid);
+
+			(*nbPmt)++;
+		}
+	}
+
+	parser->setpos(startPos);
+
+	return 1;
 }
+
 /**
       \fn     dmx_probePat(dmx_demuxerTS *demuxer, uint32_t *nbPmt,MPEG_PMT *pmts,uint32_t maxPMT)
       \brief  Search for PAT and returns PMT info if found
@@ -484,36 +458,103 @@
       @param maxPMT : Maximum # of PMT we accept in pmts (in)
 
 */
-uint8_t dmx_probePat(dmx_demuxerTS *demuxer, uint32_t *nbPmt,MPEG_PMT *pmts,uint32_t maxPmt)
+int dmx_parsePmt(dmx_demuxerTS *demuxer, int pid, MPEG_TRACK *pmts, int *cur, int max)
 {
-  
-  fileParser *parser;
-  uint32_t curSection,maxSection;
-  uint32_t left,toScan;
-  
-      parser=demuxer->getParser();
-      *nbPmt=0;
-      if(dmx_searchAndSkipHeader(0,demuxer,&curSection, &maxSection,&left,&toScan))
-      {
-        
-              while(toScan >=4 && left>=8)
-              {
-                  printf("**\n");
-                  pmts[*nbPmt].programNumber=parser->read16i()&0xFFFF;
-                  pmts[*nbPmt].tid=parser->read16i()&0x1FFF;
-                  aprintf(" [PAT]Program Number :%03x\n",pmts[*nbPmt].programNumber);
-                  aprintf(" [PAT]PID for this   :%03x\n",pmts[*nbPmt].tid);
-                  aprintf(" toScan :%u left :%u\n",toScan,left);
-                  if((*nbPmt)<maxPmt)
-                      (*nbPmt)++;
-                  left-=4;
-                  toScan-=4;
-              }
-              return 1;
-        
-      }
-      return 0;
+	uint8_t tableId, sectionNumber, lastSectionNumber;
+	uint16_t sectionLength, progId, progDescLength;
+	int32_t sectionBytes;
+	uint64_t startPos;
+	fileParser *parser = demuxer->getParser();
+	int entries;
+
+	parser->getpos(&startPos);
+
+	// Decode PSI header
+	parser->read8i();	// Pointer field, can be ignored (?)
+
+	tableId = parser->read8i();	// 0
+
+	if (tableId != 2)
+	{
+		parser->setpos(startPos);
+		return 0;
+	}
+
+	sectionLength = ((parser->read8i() & 0xf) << 8 ) | parser->read8i();	// 1 & 2
+	parser->read16i();	// 3 & 4
+	parser->read8i(); // 5
+	sectionNumber = parser->read8i();	// 6
+	lastSectionNumber = parser->read8i(); // 7
+	parser->read16i(); // 8 & 9
+	progDescLength = ((parser->read8i() & 0xf) << 8 ) | parser->read8i();	// 10 & 11
+
+	if (progDescLength > sectionLength - 9)
+	{
+		printf("[TS] parsePmt: Invalid progDesc length (%d/%d)\n", progDescLength, sectionLength - 9);
+		parser->setpos(startPos);
+
+		return 0;
+	}
+
+	parser->forward(progDescLength);
+
+	sectionBytes = sectionLength - 13 - progDescLength;	
+
+	while (sectionBytes >= 5)
+	{
+		int esType, esPid, esDescLength;
+		const char *idString;
+		ADM_STREAM_TYPE streamType;
+		bool streamFound = false;
+
+		esType = parser->read8i();
+		esPid = ((parser->read8i() & 0x1f) << 8) | parser->read8i();
+		esDescLength = ((parser->read8i() & 0xf) << 8) | parser->read8i();
+		idString = dmx_streamType(esType, &streamType);
+
+		if (esDescLength > sectionBytes - 5)
+		{
+			printf("[TS] parsePmt: esDescLength too large %d > %d\n", esDescLength, sectionBytes - 5);
+			return 0;
+		}
+
+		for (int i = 0; i < *cur; i++)
+		{
+			if (pmts[i].pid == esPid)
+			{
+				streamFound = true;
+				break;
+			}
+		}
+
+		if (!streamFound && *cur < max)
+		{
+			pmts[*cur].pid = esPid;
+			pmts[*cur].streamType = streamType;
+
+			if (streamType == ADM_STREAM_MPEG_AUDIO)
+				pmts[*cur].pes = 0xC0;
+			else if(streamType == ADM_STREAM_MPEG_VIDEO)
+				pmts[*cur].pes = 0xE0;
+			else
+				pmts[*cur].pes = 0;
+
+			(*cur)++;
+		}
+
+		if (esDescLength)
+			parser->forward(esDescLength);
+
+		sectionBytes -= 5 + esDescLength;
+
+		aprintf("[TS] parsePmt: esPid: %d, esType: 0x%x (%s), esDescLength: %d, bytes left: %d\n", esPid, esType, idString, esDescLength, sectionBytes);
+	}
+
+	parser->setpos(startPos);
+
+	return 1;
 }
+
 const char *dmx_streamType(uint32_t type,ADM_STREAM_TYPE *streamType)
 {
  switch(type)
@@ -528,76 +569,7 @@
  *streamType=ADM_STREAM_UNKNOWN;
   return "???";
 }
-/**
-      \fn     dmx_probePat(dmx_demuxerTS *demuxer, uint32_t *nbPmt,MPEG_PMT *pmts,uint32_t maxPMT)
-      \brief  Search for PAT and returns PMT info if found
-      @return 1 on success, 0 on failure
-      @param demuxer: mpegTS demuxer (input)
-      @param *nbPmt : number of PMTS found (output)
-      @param *pmts : contains info about the PMT found (out but must be allocated by caller)
-      @param maxPMT : Maximum # of PMT we accept in pmts (in)
 
-*/
-uint8_t dmx_probePMT(dmx_demuxerTS *demuxer, uint32_t pmtId,MPEG_TRACK *pmts,uint32_t *cur, uint32_t max)
-{
-  
-  fileParser *parser;
-  uint32_t curSection,maxSection;
-  uint32_t left=0,toScan,programInfo=0;
-  
-      printf("Searching for PMT, pid=0x%x\n",pmtId);
-      demuxer->changePid(pmtId,pmtId); // change pid as setPos will seek for them
-      demuxer->setPos(0,0);
-      parser=demuxer->getParser();
-      if(dmx_searchAndSkipHeader(pmtId,demuxer,&curSection, &maxSection,&left,&toScan))
-      {
-          uint16_t alpha;
-               alpha=parser->read16i();
-               aprintf("[PMT]PCR for it    :x%x\n",alpha&0x1FFF);
-               programInfo=parser->read16i() & 0x0FFF;
-               aprintf("[PMT]Program Info  :%d\n",programInfo);
-               if( (programInfo+2 > left) || (programInfo+2>toScan))
-               {
-                 printf("Program Info too big :%u\n",programInfo);
-                 return 0;
-               }
-               parser->forward(programInfo);
-               toScan-=(2+programInfo);
-               left-=(2+programInfo);
-               while(toScan >=5 )
-              {
-                  uint8_t stream;
-                  uint32_t pid,esDescLen;
-                  const char *idString;
-                  ADM_STREAM_TYPE streamType;
-                  aprintf("**\n");
-                  stream    =parser->read8i();
-                  pid       =parser->read16i()&0x1FFF;
-                  esDescLen =parser->read16i()&0x0FFF;
-                  idString=dmx_streamType(stream,&streamType);
-                  aprintf("[PMT]Stream Type :0x%x (%s)\n",stream,idString);
-                  aprintf("[PMT]Pid         :0x%x\n",pid);
-                  aprintf("[PMT]ES Len      :%d\n",esDescLen);
-                  
-                  parser->forward(esDescLen);
-                  left-=(5+esDescLen);
-                  toScan-=(5+esDescLen);
-                  if(*cur<max)
-                  {
-                    pmts[*cur].pid=pid;
-                    pmts[*cur].streamType=streamType;
-                    pmts[*cur].pes=0x0;
-                    if(streamType==ADM_STREAM_MPEG_AUDIO) pmts[*cur].pes=0xC0;
-                    if(streamType==ADM_STREAM_MPEG_VIDEO) pmts[*cur].pes=0xE0;
-                    
-                    (*cur)++;
-                  }
-                  aprintf("[PMT]left %u toscan %u\n",left,toScan);
-              }
-              
-      }
-      return 0;
-}
 /**
       \fn dmx_streamTypeAsSTring
       \brief returns stream type as a printable string



From gruntster at mail.berlios.de  Wed Jul 30 15:59:08 2008
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Wed, 30 Jul 2008 15:59:08 +0200
Subject: [Avidemux-svn-commit] r4294 -
	branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer
Message-ID: <200807301359.m6UDx8wk024058@sheep.berlios.de>

Author: gruntster
Date: 2008-07-30 15:58:52 +0200 (Wed, 30 Jul 2008)
New Revision: 4294

Modified:
   branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_probeTS.cpp
Log:
[m2ts] parse program descriptor to detect audio streams

Modified: branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_probeTS.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_probeTS.cpp	2008-07-29 21:55:32 UTC (rev 4293)
+++ branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_probeTS.cpp	2008-07-30 13:58:52 UTC (rev 4294)
@@ -66,7 +66,7 @@
 static uint8_t dmx_probeTsPatPmt(const char *file, uint32_t *nbTracks, MPEG_TRACK **tracks, DMX_TYPE type);
 static int dmx_parsePat(dmx_demuxerTS *demuxer, int *nbPmt, MPEG_PMT *pmts, int maxPmt);
 static int dmx_parsePmt(dmx_demuxerTS *demuxer, int pid, MPEG_TRACK *pmts, int *cur, int max);
-
+static int parseProgramDescriptors(uint8_t *progDescBuffer, int progDescLength, int *esType);
 static const char *dmx_streamType(uint32_t type,ADM_STREAM_TYPE *streamType);
 static const char *dmx_streamTypeAsString(ADM_STREAM_TYPE st);
  
@@ -510,7 +510,6 @@
 		esType = parser->read8i();
 		esPid = ((parser->read8i() & 0x1f) << 8) | parser->read8i();
 		esDescLength = ((parser->read8i() & 0xf) << 8) | parser->read8i();
-		idString = dmx_streamType(esType, &streamType);
 
 		if (esDescLength > sectionBytes - 5)
 		{
@@ -527,6 +526,16 @@
 			}
 		}
 
+		if (esDescLength)
+		{
+			uint8_t esProgDesc[esDescLength];
+
+			parser->read32(esDescLength, esProgDesc);
+			parseProgramDescriptors(esProgDesc, esDescLength, &esType);
+		}
+
+		idString = dmx_streamType(esType, &streamType);
+
 		if (!streamFound && *cur < max)
 		{
 			pmts[*cur].pid = esPid;
@@ -542,9 +551,6 @@
 			(*cur)++;
 		}
 
-		if (esDescLength)
-			parser->forward(esDescLength);
-
 		sectionBytes -= 5 + esDescLength;
 
 		aprintf("[TS] parsePmt: esPid: %d, esType: 0x%x (%s), esDescLength: %d, bytes left: %d\n", esPid, esType, idString, esDescLength, sectionBytes);
@@ -555,6 +561,50 @@
 	return 1;
 }
 
+int parseProgramDescriptors(uint8_t *progDescBuffer, int progDescLength, int *esType)
+{
+	int i, descLen, len;
+
+	i = 0;
+	len = progDescLength;
+
+	while (len > 2)
+	{
+		descLen = progDescBuffer[i + 1];
+		aprintf("[TS]\tdescriptor id: 0x%x, len = %d (bytes left: %d)\n", progDescBuffer[i], descLen, len);
+
+		if (descLen > len)
+		{
+			printf("[TS] Invalid descriptor length for id %02x: %d (bytes left: %d)\n", progDescBuffer[i], descLen, len);
+			return 0;
+		}
+
+		if ((progDescBuffer[i] == 0x6a || progDescBuffer[i] == 0x7a) && *esType == 0x6)	// AC3
+			*esType = 0x81;
+		//else if (progDescBuffer[i] == 0x7b && *esType == 0x6)	// DTS
+		else if (progDescBuffer[i] == 0x5)
+		{
+			if (descLen < 4)
+				printf("[TS] Registration descriptor too short: %d\n", descLen);
+			else
+			{
+				uint8_t *d = &progDescBuffer[i + 2];
+
+				if (d[0] == 'A' && d[1] == 'C' && d[2] == '-' && d[3] == '3')	// AC3
+					*esType = 0x81;
+				//else if (d[0] == 'D' && d[1] == 'T' && d[2] == 'S' && d[3] == '1')	// DTS
+				//else if (d[0] == 'D' && d[1] == 'T' && d[2] == 'S' && d[3] == '2')	// DTS
+				//else if (d[0] == 'V' && d[1] == 'C' && d[2] == '-' && d[3] == '1')	// VC-1
+			}
+		}
+
+		len -= 2 + descLen;
+		i += 2 + descLen;
+	}
+
+	return 1;
+}
+
 const char *dmx_streamType(uint32_t type,ADM_STREAM_TYPE *streamType)
 {
  switch(type)



From gruntster at mail.berlios.de  Wed Jul 30 19:08:37 2008
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Wed, 30 Jul 2008 19:08:37 +0200
Subject: [Avidemux-svn-commit] r4295 -
	branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer
Message-ID: <200807301708.m6UH8bio017371@sheep.berlios.de>

Author: gruntster
Date: 2008-07-30 19:08:29 +0200 (Wed, 30 Jul 2008)
New Revision: 4295

Modified:
   branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_demuxerTS.cpp
Log:
[m2ts] fix syncing of H.264 for Blu-ray

Modified: branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_demuxerTS.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_demuxerTS.cpp	2008-07-30 13:58:52 UTC (rev 4294)
+++ branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_demuxerTS.cpp	2008-07-30 17:08:29 UTC (rev 4295)
@@ -782,15 +782,12 @@
 */
 uint8_t         dmx_demuxerTS::syncH264( uint8_t *stream,uint64_t *abs,uint64_t *r,uint64_t *pts,uint64_t *dts)
 {
-uint32_t val,hnt;
+uint32_t hnt;
 retry:
          *r=0;
 
-                val=0;
-                hnt=0;
+				hnt = read8i();
 
-                // preload
-                hnt=(read8i()<<24) + (read8i()<<16) +(read8i()<<8)+(read8i());
                 if(_lastErr)
                 {
                         _lastErr=0;
@@ -798,12 +795,9 @@
                         return 0;       
                 }
 
-                while((hnt!=1))
+                while (hnt >> 8 != 1)
                 {
-
-                        hnt<<=8;
-                        val=read8i();
-                        hnt+=val;
+					hnt = (hnt << 8) | read8i();
  
                         if(_lastErr)
                         {
@@ -811,10 +805,10 @@
                             printf("\n io error , aborting sync\n");
                             return 0;
                          }
-
                 }
 
-                *stream=read8i();
+				*stream = hnt;
+
                 // Case 1 : assume we are still in the same packet
                 if(_pesBufferIndex>=5)
                 {
@@ -831,7 +825,7 @@
                                  { // previous Packet which len is very shoty
                                    // Ignore
                                    _pesBufferIndex=0;
-                                   printf("Ignoring too short packet");
+                                   printf("Ignoring too short packet\n");
                                    goto retry;
                                  }
                                  left=_oldPesLen-left;



From mean at mail.berlios.de  Wed Jul 30 19:53:53 2008
From: mean at mail.berlios.de (mean at BerliOS)
Date: Wed, 30 Jul 2008 19:53:53 +0200
Subject: [Avidemux-svn-commit] r4296 -
	branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mp4
Message-ID: <200807301753.m6UHrrgR000428@sheep.berlios.de>

Author: mean
Date: 2008-07-30 19:53:52 +0200 (Wed, 30 Jul 2008)
New Revision: 4296

Modified:
   branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mp4/ADM_mp4Analyzer.cpp
Log:
[MP4] Fix over-read

Modified: branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mp4/ADM_mp4Analyzer.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mp4/ADM_mp4Analyzer.cpp	2008-07-30 17:08:29 UTC (rev 4295)
+++ branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mp4/ADM_mp4Analyzer.cpp	2008-07-30 17:53:52 UTC (rev 4296)
@@ -567,8 +567,11 @@
                                 son.skipBytes(32-1-u32);
                                 left-=32;
                                 //
-                                son.read32();
-                                left-=4; //Depth & color Id
+                                if(left>=4)
+                                {
+                                    son.read32();
+                                    left-=4; //Depth & color Id
+                                }else left=0;
                                 //
                                 printf("LEFT:%d\n",left);
 



From gruntster at mail.berlios.de  Wed Jul 30 23:39:31 2008
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Wed, 30 Jul 2008 23:39:31 +0200
Subject: [Avidemux-svn-commit] r4297 -
	branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer
Message-ID: <200807302139.m6ULdVVg029740@sheep.berlios.de>

Author: gruntster
Date: 2008-07-30 23:39:23 +0200 (Wed, 30 Jul 2008)
New Revision: 4297

Modified:
   branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_demuxerTS.cpp
Log:
[m2ts] tweak H.264 sync

Modified: branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_demuxerTS.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_demuxerTS.cpp	2008-07-30 17:53:52 UTC (rev 4296)
+++ branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_demuxerTS.cpp	2008-07-30 21:39:23 UTC (rev 4297)
@@ -35,7 +35,7 @@
 #include <math.h>
 
 #include "default.h"
-#include <ADM_assert.h>
+#include "ADM_assert.h"
 
 //#define TS_VERBOSE 1
 
@@ -786,15 +786,8 @@
 retry:
          *r=0;
 
-				hnt = read8i();
+		 hnt = (read8i() << 16) | (read8i() << 8) | read8i();
 
-                if(_lastErr)
-                {
-                        _lastErr=0;
-                        printf("\n io error , aborting sync\n");
-                        return 0;       
-                }
-
                 while (hnt >> 8 != 1)
                 {
 					hnt = (hnt << 8) | read8i();



