<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Avidemux-svn-commit] r5743 - in	branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_avcodec:	. xvidRateCtl
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/avidemux-svn-commit/2009-December/index.html" >
   <LINK REL="made" HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r5743%20-%20in%0A%09branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_avcodec%3A%0A%09.%20xvidRateCtl&In-Reply-To=%3C200912281204.nBSC4iL2010318%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="002949.html">
   <LINK REL="Next"  HREF="002951.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Avidemux-svn-commit] r5743 - in	branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_avcodec:	. xvidRateCtl</H1>
    <B>gruntster at mail.berlios.de</B> 
    <A HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r5743%20-%20in%0A%09branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_avcodec%3A%0A%09.%20xvidRateCtl&In-Reply-To=%3C200912281204.nBSC4iL2010318%40sheep.berlios.de%3E"
       TITLE="[Avidemux-svn-commit] r5743 - in	branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_avcodec:	. xvidRateCtl">gruntster at mail.berlios.de
       </A><BR>
    <I>Mon Dec 28 13:04:44 CET 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="002949.html">[Avidemux-svn-commit] r5742 -	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDevices/PulseAudioSimple
</A></li>
        <LI>Next message: <A HREF="002951.html">[Avidemux-svn-commit] r5744 -	branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_avcodec/xvidRateCtl
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2950">[ date ]</a>
              <a href="thread.html#2950">[ thread ]</a>
              <a href="subject.html#2950">[ subject ]</a>
              <a href="author.html#2950">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: gruntster
Date: 2009-12-28 13:04:18 +0100 (Mon, 28 Dec 2009)
New Revision: 5743

Added:
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_avcodec/xvidRateCtl/
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_avcodec/xvidRateCtl/CMakeLists.txt
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_avcodec/xvidRateCtl/rateControl.cpp
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_avcodec/xvidRateCtl/rateControl.h
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_avcodec/xvidRateCtl/xvid.h
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_avcodec/xvidRateCtl/xvidRateCtl.cpp
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_avcodec/xvidRateCtl/xvidRateCtl.h
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_avcodec/xvidRateCtl/xvidRateCtlVbv.cpp
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_avcodec/xvidRateCtl/xvidRateCtlVbv.h
Modified:
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_avcodec/CMakeLists.txt
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_avcodec/interface.c
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_avcodec/mpeg1Encoder.cpp
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_avcodec/mpeg1Encoder.h
Log:
[mpeg-1] add Xvid rate control to MPEG-1 avcodec video plugin

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_avcodec/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_avcodec/CMakeLists.txt	2009-12-28 06:39:12 UTC (rev 5742)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_avcodec/CMakeLists.txt	2009-12-28 12:04:18 UTC (rev 5743)
@@ -24,8 +24,10 @@
 add_library(ADM_libavcodec UNKNOWN IMPORTED)
 set_property(TARGET ADM_libavcodec PROPERTY IMPORTED_LOCATION &quot;${FFMPEG_INSTALL_DIR}/${LIBAVCODEC_LIB}&quot;)
 
+add_subdirectory(xvidRateCtl)
+
 ADD_LIBRARY(ADM_vidEnc_avcodec SHARED ${ADM_vidEnc_avcodec_SRCS})
-TARGET_LINK_LIBRARIES(ADM_vidEnc_avcodec ${LIBXML2_LIBRARIES} ADM_core ADM_coreUI ADM_libavcodec)
+TARGET_LINK_LIBRARIES(ADM_vidEnc_avcodec ${LIBXML2_LIBRARIES} ADM_xvidRateCtl ADM_core ADM_coreUI ADM_libavcodec)
 
 INIT_VIDEO_ENCODER_PLUGIN(ADM_vidEnc_avcodec)
 INSTALL_VIDEO_ENCODER(ADM_vidEnc_avcodec)

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_avcodec/interface.c
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_avcodec/interface.c	2009-12-28 06:39:12 UTC (rev 5742)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_avcodec/interface.c	2009-12-28 12:04:18 UTC (rev 5743)
@@ -72,7 +72,7 @@
 {
 	*major = 1;
 	*minor = 0;
-	*patch = 0;
+	*patch = 1;
 }
 
 const char* vidEncGetEncoderGuid(int encoderId)

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_avcodec/mpeg1Encoder.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_avcodec/mpeg1Encoder.cpp	2009-12-28 06:39:12 UTC (rev 5742)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_avcodec/mpeg1Encoder.cpp	2009-12-28 12:04:18 UTC (rev 5743)
@@ -43,6 +43,7 @@
 	_bitrateParam.finalsize = 700;
 
 	_statFile = NULL;
+	_xvidRc = NULL;
 }
 
 int Mpeg1Encoder::initContext(const char* logFileName)
@@ -95,6 +96,7 @@
 	_context-&gt;max_b_frames = 2;
 	_context-&gt;luma_elim_threshold = -2;
 	_context-&gt;chroma_elim_threshold = -5;
+	_context-&gt;lumi_masking = 0.05;
 	_context-&gt;me_range = 255;
 	_context-&gt;mb_decision = FF_MB_DECISION_RD;
 	_context-&gt;scenechange_threshold = 0xfffffff;
@@ -114,16 +116,26 @@
 	}
 	else 
 	{
-		if (_encodeOptions.encodeMode == ADM_VIDENC_MODE_2PASS_SIZE)
-			_context-&gt;bit_rate = calculateBitrate(_fpsNum, _fpsDen, _frameCount, _encodeOptions.encodeModeParameter);
+		if (_options.getXvidRateControl())
+		{
+			_context-&gt;max_qdiff = 10;
+			_context-&gt;bit_rate = 2500 * 1000 * 8;
+			_context-&gt;bit_rate_tolerance = 1024 * 8 * 1000;
+			_context-&gt;flags |= CODEC_FLAG_QSCALE;
+		}
 		else
-			_context-&gt;bit_rate = _encodeOptions.encodeModeParameter * 1000;
+		{
+			_context-&gt;bit_rate_tolerance = 8000000;
+			_context-&gt;flags |= CODEC_FLAG_PASS2;
 
-		if (_context-&gt;bit_rate &gt; _options.getMaxBitrate() * 1000)
-			_context-&gt;bit_rate = _options.getMaxBitrate() * 1000;
+			if (_encodeOptions.encodeMode == ADM_VIDENC_MODE_2PASS_SIZE)
+				_context-&gt;bit_rate = calculateBitrate(_fpsNum, _fpsDen, _frameCount, _encodeOptions.encodeModeParameter);
+			else
+				_context-&gt;bit_rate = _encodeOptions.encodeModeParameter * 1000;
 
-		_context-&gt;bit_rate_tolerance = 8000000;
-		_context-&gt;flags |= CODEC_FLAG_PASS2;
+			if (_context-&gt;bit_rate &gt; _options.getMaxBitrate() * 1000)
+				_context-&gt;bit_rate = _options.getMaxBitrate() * 1000;
+		}		
 	}
 
 	if (_encodeOptions.encodeMode == ADM_VIDENC_MODE_2PASS_SIZE || _encodeOptions.encodeMode == ADM_VIDENC_MODE_2PASS_ABR)
@@ -137,8 +149,12 @@
 		strcpy(log, logFileName);
 #endif
 
-		if (_currentPass == 1)
+		if (_options.getXvidRateControl())
 		{
+			_xvidRc = new ADM_newXvidRcVBV((_fpsNum * 1000) / _fpsDen, log);
+		}
+		else if (_currentPass == 1)
+		{
 			_statFile = fopen(log, &quot;wb&quot;);
 
 			if (!_statFile)
@@ -166,7 +182,7 @@
 		}
 	}
 
-	if (_encodeOptions.encodeMode == ADM_VIDENC_MODE_CQP || _currentPass == 2)
+	if (_encodeOptions.encodeMode == ADM_VIDENC_MODE_CQP || (_currentPass == 2 &amp;&amp; !_options.getXvidRateControl()))
 	{
 		_context-&gt;rc_max_rate = _context-&gt;rc_max_rate_header;
 		_context-&gt;rc_buffer_size = _context-&gt;rc_buffer_size_header;
@@ -415,9 +431,40 @@
 
 	if (_encodeOptions.encodeMode == ADM_VIDENC_MODE_CQP)
 		qz = _encodeOptions.encodeModeParameter;
-	else if (_currentPass == 1)
-		qz = 2;
+	else if (_encodeOptions.encodeMode == ADM_VIDENC_MODE_2PASS_SIZE || _encodeOptions.encodeMode == ADM_VIDENC_MODE_2PASS_ABR)
+	{
+		if (_currentPass == 1)
+		{
+			qz = 2;
 
+			if (_options.getXvidRateControl())
+				_xvidRc-&gt;startPass1();
+		}
+		else if (_currentPass == 2 &amp;&amp; _options.getXvidRateControl())
+		{
+			double d = _frameCount;
+			uint32_t maxBitrate = _options.getMaxBitrate() * 1000;
+			uint32_t bitrate;
+
+			if (_encodeOptions.encodeMode == ADM_VIDENC_MODE_2PASS_SIZE)
+				bitrate = calculateBitrate(_fpsNum, _fpsDen, _frameCount, _encodeOptions.encodeModeParameter);
+			else
+				bitrate = _encodeOptions.encodeModeParameter * 1000;
+
+			if (bitrate &gt; maxBitrate)
+				bitrate = maxBitrate;
+
+			d *= 1000.;
+			d /= (_fpsNum * 1000) / _fpsDen;   // D is a duration in second
+			d *= bitrate;   // * bitrate = total bits
+			d /= 8;   // Byte
+			d /= 1024 * 1024;   // MB
+
+			_xvidRc-&gt;setVBVInfo(_options.getMaxBitrate(), _options.getMinBitrate(), _options.getBufferSize());
+			_xvidRc-&gt;startPass2((uint32_t)d, _frameCount);
+		}
+	}
+
 	if (qz)
 		_frame.quality = (int)floor(FF_QP2LAMBDA * qz + 0.5);
 
@@ -434,6 +481,12 @@
 		_statFile = NULL;
 	}
 
+	if (_xvidRc)
+	{
+		delete _xvidRc;
+		_xvidRc = NULL;
+	}
+
 	if (_context &amp;&amp; _context-&gt;stats_in)
 	{
 		delete [] _context-&gt;stats_in;
@@ -445,11 +498,48 @@
 
 int Mpeg1Encoder::encodeFrame(vidEncEncodeParameters *encodeParams)
 {
+	ADM_rframe rf;
+	uint32_t qz;
+
+	if (_options.getXvidRateControl() &amp;&amp; _currentPass == 2)
+	{
+		_xvidRc-&gt;getQz(&amp;qz, &amp;rf);
+
+		if (qz &lt; 2)
+			qz = 2;
+
+		if (qz &gt; 28)
+			qz = 28;
+
+		_frame.quality = (int)floor(FF_QP2LAMBDA * qz + 0.5);
+	}
+
 	int ret = AvcodecEncoder::encodeFrame(encodeParams);
 
 	if (_context-&gt;stats_out)
 		fprintf (_statFile, &quot;%s&quot;, _context-&gt;stats_out);
 
+	if (_options.getXvidRateControl() &amp;&amp; encodeParams-&gt;encodedDataSize &amp;&amp; (_encodeOptions.encodeMode == ADM_VIDENC_MODE_2PASS_SIZE || _encodeOptions.encodeMode == ADM_VIDENC_MODE_2PASS_ABR))
+	{
+		switch (encodeParams-&gt;frameType)
+		{
+			case ADM_VIDENC_FRAMETYPE_IDR:
+				rf = RF_I;
+				break;
+			case ADM_VIDENC_FRAMETYPE_B:
+				rf = RF_B;
+				break;
+			case ADM_VIDENC_FRAMETYPE_P:
+				rf = RF_P;
+				break;
+		}
+
+		if (_currentPass == 1)
+			_xvidRc-&gt;logPass1(encodeParams-&gt;quantiser, rf, encodeParams-&gt;encodedDataSize);
+		else
+			_xvidRc-&gt;logPass2(qz, rf, encodeParams-&gt;encodedDataSize);
+	}
+
 	return ret;
 }
 

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_avcodec/mpeg1Encoder.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_avcodec/mpeg1Encoder.h	2009-12-28 06:39:12 UTC (rev 5742)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_avcodec/mpeg1Encoder.h	2009-12-28 12:04:18 UTC (rev 5743)
@@ -25,8 +25,8 @@
 
 #include &quot;encoder.h&quot;
 #include &quot;mpeg1EncoderOptions.h&quot;
-#include &quot;../../ADM_encoder/ADM_vidEncode.hxx&quot;
 #include &quot;DIA_factory.h&quot;
+#include &quot;xvidRateCtl/xvidRateCtlVbv.h&quot;
 
 class Mpeg1Encoder : public AvcodecEncoder
 {
@@ -41,6 +41,7 @@
 		vidEncOptions _encodeOptions;
 
 		FILE *_statFile;
+		ADM_newXvidRcVBV *_xvidRc;
 
 		void updateEncodeProperties(vidEncOptions *encodeOptions);
 		unsigned int calculateBitrate(unsigned int fpsNum, unsigned int fpsDen, unsigned int frameCount, unsigned int sizeInMb);

Added: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_avcodec/xvidRateCtl/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_avcodec/xvidRateCtl/CMakeLists.txt	2009-12-28 06:39:12 UTC (rev 5742)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_avcodec/xvidRateCtl/CMakeLists.txt	2009-12-28 12:04:18 UTC (rev 5743)
@@ -0,0 +1 @@
+add_library(ADM_xvidRateCtl rateControl.cpp  xvidRateCtl.cpp  xvidRateCtlVbv.cpp)
\ No newline at end of file

Added: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_avcodec/xvidRateCtl/rateControl.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_avcodec/xvidRateCtl/rateControl.cpp	2009-12-28 06:39:12 UTC (rev 5742)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_avcodec/xvidRateCtl/rateControl.cpp	2009-12-28 12:04:18 UTC (rev 5743)
@@ -0,0 +1,27 @@
+//
+// C++ Implementation: %{MODULE}
+//
+// Description:
+//
+//
+// Author: %{AUTHOR} &lt;%{EMAIL}&gt;, (C) %{YEAR}
+//
+// Copyright: See COPYING file that comes with this distribution
+//
+//
+#include &lt;string.h&gt;
+#include &lt;stdlib.h&gt;
+#include &quot;rateControl.h&quot;
+
+ADM_ratecontrol::ADM_ratecontrol(uint32_t fps1000, char *logname)
+{
+	_fps1000 = fps1000;
+	_logname = strdup(logname);
+	_state = RS_IDLE;
+	_nbFrames++;
+}
+
+ADM_ratecontrol::~ADM_ratecontrol()
+{
+	free(_logname);
+}

Added: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_avcodec/xvidRateCtl/rateControl.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_avcodec/xvidRateCtl/rateControl.h	2009-12-28 06:39:12 UTC (rev 5742)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_avcodec/xvidRateCtl/rateControl.h	2009-12-28 12:04:18 UTC (rev 5743)
@@ -0,0 +1,60 @@
+//
+// C++ Interface: %{MODULE}
+//
+// Description: 
+//
+//
+// Author: Mean (<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>)
+//
+// Copyright: See COPYING file that comes with this distribution GPL.
+//
+// FIXME : We need total frame # to do only pass2
+//
+#ifndef ADM_RTCL
+#define ADM_RTCL
+
+#include &lt;inttypes.h&gt;
+
+typedef enum 
+{
+	RF_I=1,
+	RF_P=2,
+	RF_B=3,
+} ADM_rframe;
+
+typedef enum
+{
+	RS_IDLE,
+	RS_PASS1,
+	RS_PASS2
+} ADM_rstate;
+
+typedef struct
+{
+	uint32_t quant;
+	uint32_t size;
+	ADM_rframe type;
+} ADM_pass_stat;
+
+class ADM_ratecontrol
+{
+protected:
+	uint32_t _nbFrames;
+	uint32_t _fps1000;
+	char 	*_logname;
+	ADM_rstate _state;
+
+public:
+	ADM_ratecontrol(uint32_t fps1000, char *logname);
+	virtual ~ADM_ratecontrol();
+	/** Maxbr &amp; minbr in Bps, vbvsize in kBytes); Default is none */
+	virtual uint8_t setVBVInfo(uint32_t maxbr, uint32_t minbr, uint32_t vbvsize) = 0;
+	virtual	uint8_t startPass1(void) = 0;
+	virtual	uint8_t logPass1(uint32_t qz, ADM_rframe ftype, uint32_t size) = 0;
+	virtual	uint8_t startPass2(uint32_t size, uint32_t nbFrame) = 0;
+	virtual	uint8_t getQz(uint32_t *qz, ADM_rframe *type) = 0;
+	virtual	uint8_t logPass2(uint32_t qz, ADM_rframe ftype, uint32_t size) = 0;
+};
+
+#endif
+//EOF

Added: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_avcodec/xvidRateCtl/xvid.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_avcodec/xvidRateCtl/xvid.h	2009-12-28 06:39:12 UTC (rev 5742)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_avcodec/xvidRateCtl/xvid.h	2009-12-28 12:04:18 UTC (rev 5743)
@@ -0,0 +1,780 @@
+/*****************************************************************************
+ *
+ * XVID MPEG-4 VIDEO CODEC
+ * - XviD Main header file -
+ *
+ *  Copyright(C) 2001-2003 Peter Ross &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">pross at xvid.org</A>&gt;
+ *
+ *  This program is free software ; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation ; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY ; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program ; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ *
+ * $Id: ADM_xvidr_internal.h 1039 2005-05-17 19:01:18Z mean $
+ *
+ ****************************************************************************/
+
+#ifndef _XVID_H_
+#define _XVID_H_
+
+
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+/*****************************************************************************
+ * versioning
+ ****************************************************************************/
+
+/* versioning
+	version takes the form &quot;$major.$minor.$patch&quot;
+	$patch is incremented when there is no api change
+	$minor is incremented when the api is changed, but remains backwards compatible
+	$major is incremented when the api is changed significantly
+
+	when initialising an xvid structure, you must always zero it, and set the version field.
+		memset(&amp;struct,0,sizeof(struct));
+		struct.version = XVID_VERSION;
+
+	XVID_UNSTABLE is defined only during development.
+	*/
+
+#define XVID_MAKE_VERSION(a,b,c) ((((a)&amp;0xff)&lt;&lt;16) | (((b)&amp;0xff)&lt;&lt;8) | ((c)&amp;0xff))
+#define XVID_VERSION_MAJOR(a)    ((char)(((a)&gt;&gt;16) &amp; 0xff))
+#define XVID_VERSION_MINOR(a)    ((char)(((a)&gt;&gt; 8) &amp; 0xff))
+#define XVID_VERSION_PATCH(a)    ((char)(((a)&gt;&gt; 0) &amp; 0xff))
+
+#define XVID_MAKE_API(a,b)       ((((a)&amp;0xff)&lt;&lt;16) | (((b)&amp;0xff)&lt;&lt;0))
+#define XVID_API_MAJOR(a)        (((a)&gt;&gt;16) &amp; 0xff)
+#define XVID_API_MINOR(a)        (((a)&gt;&gt; 0) &amp; 0xff)
+
+#define XVID_VERSION             XVID_MAKE_VERSION(1,0,-124)
+#define XVID_API                 XVID_MAKE_API(4, 0)
+
+#define XVID_UNSTABLE
+
+/* Bitstream Version
+ * this will be writen into the bitstream to allow easy detection of xvid
+ * encoder bugs in the decoder, without this it might not possible to
+ * automatically distinquish between a file which has been encoded with an
+ * old &amp; buggy XVID from a file which has been encoded with a bugfree version
+ * see the infamous interlacing bug ...
+ *
+ * this MUST be increased if an encoder bug is fixed, increasing it too often
+ * doesnt hurt but not increasing it could cause difficulty for decoders in the
+ * future
+ */
+#define XVID_BS_VERSION &quot;0030&quot;
+
+
+/*****************************************************************************
+ * error codes
+ ****************************************************************************/
+
+	/*	all functions return values &lt;0 indicate error */
+
+#define XVID_ERR_FAIL		-1		/* general fault */
+#define XVID_ERR_MEMORY		-2		/* memory allocation error */
+#define XVID_ERR_FORMAT		-3		/* file format error */
+#define XVID_ERR_VERSION	-4		/* structure version not supported */
+#define XVID_ERR_END		-5		/* encoder only; end of stream reached */
+
+
+
+/*****************************************************************************
+ * xvid_image_t
+ ****************************************************************************/
+
+/* colorspace values */
+
+#define XVID_CSP_PLANAR   (1&lt;&lt; 0) /* 4:2:0 planar (==I420, except for pointers/strides) */
+#define XVID_CSP_USER	  XVID_CSP_PLANAR
+#define XVID_CSP_I420     (1&lt;&lt; 1) /* 4:2:0 planar */
+#define XVID_CSP_YV12     (1&lt;&lt; 2) /* 4:2:0 planar */
+#define XVID_CSP_YUY2     (1&lt;&lt; 3) /* 4:2:2 packed */
+#define XVID_CSP_UYVY     (1&lt;&lt; 4) /* 4:2:2 packed */
+#define XVID_CSP_YVYU     (1&lt;&lt; 5) /* 4:2:2 packed */
+#define XVID_CSP_BGRA     (1&lt;&lt; 6) /* 32-bit bgra packed */
+#define XVID_CSP_ABGR     (1&lt;&lt; 7) /* 32-bit abgr packed */
+#define XVID_CSP_RGBA     (1&lt;&lt; 8) /* 32-bit rgba packed */
+#define XVID_CSP_ARGB     (1&lt;&lt;15) /* 32-bit argb packed */
+#define XVID_CSP_BGR      (1&lt;&lt; 9) /* 24-bit bgr packed */
+#define XVID_CSP_RGB555   (1&lt;&lt;10) /* 16-bit rgb555 packed */
+#define XVID_CSP_RGB565   (1&lt;&lt;11) /* 16-bit rgb565 packed */
+#define XVID_CSP_SLICE    (1&lt;&lt;12) /* decoder only: 4:2:0 planar, per slice rendering */
+#define XVID_CSP_INTERNAL (1&lt;&lt;13) /* decoder only: 4:2:0 planar, returns ptrs to internal buffers */
+#define XVID_CSP_NULL     (1&lt;&lt;14) /* decoder only: dont output anything */
+#define XVID_CSP_VFLIP    (1&lt;&lt;31) /* vertical flip mask */
+
+/* xvid_image_t
+	for non-planar colorspaces use only plane[0] and stride[0]
+	four plane reserved for alpha*/
+typedef struct {
+	int csp;				/* [in] colorspace; or with XVID_CSP_VFLIP to perform vertical flip */
+	void * plane[4];		/* [in] image plane ptrs */
+	int stride[4];			/* [in] image stride; &quot;bytes per row&quot;*/
+} xvid_image_t;
+
+/* video-object-sequence profiles */
+#define XVID_PROFILE_S_L0    0x08 /* simple */
+#define XVID_PROFILE_S_L1    0x01
+#define XVID_PROFILE_S_L2    0x02
+#define XVID_PROFILE_S_L3    0x03
+#define XVID_PROFILE_ARTS_L1 0x91 /* advanced realtime simple */
+#define XVID_PROFILE_ARTS_L2 0x92
+#define XVID_PROFILE_ARTS_L3 0x93
+#define XVID_PROFILE_ARTS_L4 0x94
+#define XVID_PROFILE_AS_L0   0xf0 /* advanced simple */
+#define XVID_PROFILE_AS_L1   0xf1
+#define XVID_PROFILE_AS_L2   0xf2
+#define XVID_PROFILE_AS_L3   0xf3
+#define XVID_PROFILE_AS_L4   0xf4
+
+/* aspect ratios */
+#define XVID_PAR_11_VGA    1 /* 1:1 vga (square), default if supplied PAR is not a valid value */
+#define XVID_PAR_43_PAL    2 /* 4:3 pal (12:11 625-line) */
+#define XVID_PAR_43_NTSC   3 /* 4:3 ntsc (10:11 525-line) */
+#define XVID_PAR_169_PAL   4 /* 16:9 pal (16:11 625-line) */
+#define XVID_PAR_169_NTSC  5 /* 16:9 ntsc (40:33 525-line) */
+#define XVID_PAR_EXT      15 /* extended par; use par_width, par_height */
+
+/* frame type flags */
+#define XVID_TYPE_VOL     -1 /* decoder only: vol was decoded */
+#define XVID_TYPE_NOTHING  0 /* decoder only (encoder stats): nothing was decoded/encoded */
+#define XVID_TYPE_AUTO     0 /* encoder: automatically determine coding type */
+#define XVID_TYPE_IVOP     1 /* intra frame */
+#define XVID_TYPE_PVOP     2 /* predicted frame */
+#define XVID_TYPE_BVOP     3 /* bidirectionally encoded */
+#define XVID_TYPE_SVOP     4 /* predicted+sprite frame */
+
+
+/*****************************************************************************
+ * xvid_global()
+ ****************************************************************************/
+
+/* cpu_flags definitions (make sure to sync this with cpuid.asm for ia32) */
+
+#define XVID_CPU_FORCE    (1&lt;&lt;31) /* force passed cpu flags */
+#define XVID_CPU_ASM      (1&lt;&lt; 7) /* native assembly */
+/* ARCH_IS_IA32 */
+#define XVID_CPU_MMX      (1&lt;&lt; 0) /*       mmx : pentiumMMX,k6 */
+#define XVID_CPU_MMXEXT   (1&lt;&lt; 1) /*   mmx-ext : pentium2, athlon */
+#define XVID_CPU_SSE      (1&lt;&lt; 2) /*       sse : pentium3, athlonXP */
+#define XVID_CPU_SSE2     (1&lt;&lt; 3) /*      sse2 : pentium4, athlon64 */
+#define XVID_CPU_3DNOW    (1&lt;&lt; 4) /*     3dnow : k6-2 */
+#define XVID_CPU_3DNOWEXT (1&lt;&lt; 5) /* 3dnow-ext : athlon */
+#define XVID_CPU_TSC      (1&lt;&lt; 6) /*       tsc : Pentium */
+/* ARCH_IS_PPC */
+#define XVID_CPU_ALTIVEC  (1&lt;&lt; 0) /* altivec */
+
+
+#define XVID_DEBUG_ERROR     (1&lt;&lt; 0)
+#define XVID_DEBUG_STARTCODE (1&lt;&lt; 1)
+#define XVID_DEBUG_HEADER    (1&lt;&lt; 2)
+#define XVID_DEBUG_TIMECODE  (1&lt;&lt; 3)
+#define XVID_DEBUG_MB        (1&lt;&lt; 4)
+#define XVID_DEBUG_COEFF     (1&lt;&lt; 5)
+#define XVID_DEBUG_MV        (1&lt;&lt; 6)
+#define XVID_DEBUG_RC        (1&lt;&lt; 7)
+#define XVID_DEBUG_DEBUG     (1&lt;&lt;31)
+
+/* XVID_GBL_INIT param1 */
+typedef struct {
+	int version;
+	unsigned int cpu_flags; /* [in:opt] zero = autodetect cpu; XVID_CPU_FORCE|{cpu features} = force cpu features */
+	int debug;     /* [in:opt] debug level */
+} xvid_gbl_init_t;
+
+
+/* XVID_GBL_INFO param1 */
+typedef struct {
+	int version;
+	int actual_version; /* [out] returns the actual xvidcore version */
+	const char * build; /* [out] if !null, points to description of this xvid core build */
+	unsigned int cpu_flags;      /* [out] detected cpu features */
+	int num_threads;    /* [out] detected number of cpus/threads */
+} xvid_gbl_info_t;
+
+
+/* XVID_GBL_CONVERT param1 */
+typedef struct {
+	int version;
+	xvid_image_t input;  /* [in] input image &amp; colorspace */
+	xvid_image_t output; /* [in] output image &amp; colorspace */
+	int width;           /* [in] width */
+	int height;          /* [in] height */
+	int interlacing;     /* [in] interlacing */
+} xvid_gbl_convert_t;
+
+
+#define XVID_GBL_INIT    0 /* initialize xvidcore; must be called before using xvid_decore, or xvid_encore) */
+#define XVID_GBL_INFO    1 /* return some info about xvidcore, and the host computer */
+#define XVID_GBL_CONVERT 2 /* colorspace conversion utility */
+
+extern int xvid_global(void *handle, int opt, void *param1, void *param2);
+
+
+/*****************************************************************************
+ * xvid_decore()
+ ****************************************************************************/
+
+#define XVID_DEC_CREATE  0 /* create decore instance; return 0 on success */
+#define XVID_DEC_DESTROY 1 /* destroy decore instance: return 0 on success */
+#define XVID_DEC_DECODE  2 /* decode a frame: returns number of bytes consumed &gt;= 0 */
+
+extern int xvid_decore(void *handle, int opt, void *param1, void *param2);
+
+/* XVID_DEC_CREATE param 1
+	image width &amp; height may be specified here when the dimensions are
+	known in advance. */
+typedef struct {
+	int version;
+	int width;     /* [in:opt] image width */
+	int height;    /* [in:opt] image width */
+	void * handle; /* [out]	   decore context handle */
+} xvid_dec_create_t;
+
+
+/* XVID_DEC_DECODE param1 */
+/* general flags */
+#define XVID_LOWDELAY      (1&lt;&lt;0) /* lowdelay mode  */
+#define XVID_DISCONTINUITY (1&lt;&lt;1) /* indicates break in stream */
+#define XVID_DEBLOCKY      (1&lt;&lt;2) /* perform luma deblocking */
+#define XVID_DEBLOCKUV     (1&lt;&lt;3) /* perform chroma deblocking */
+#define XVID_FILMEFFECT    (1&lt;&lt;4) /* adds film grain */
+
+typedef struct {
+	int version;
+	int general;         /* [in:opt] general flags */
+	void *bitstream;     /* [in]     bitstream (read from)*/
+	int length;          /* [in]     bitstream length */
+	xvid_image_t output; /* [in]     output image (written to) */
+} xvid_dec_frame_t;
+
+
+/* XVID_DEC_DECODE param2 :: optional */
+typedef struct
+{
+	int version;
+
+	int type;                   /* [out] output data type */
+	union {
+		struct { /* type&gt;0 {XVID_TYPE_IVOP,XVID_TYPE_PVOP,XVID_TYPE_BVOP,XVID_TYPE_SVOP} */
+			int general;        /* [out] flags */
+			int time_base;      /* [out] time base */
+			int time_increment; /* [out] time increment */
+
+			/* XXX: external deblocking stuff */
+			int * qscale;	    /* [out] pointer to quantizer table */
+			int qscale_stride;  /* [out] quantizer scale stride */
+
+		} vop;
+		struct {	/* XVID_TYPE_VOL */
+			int general;        /* [out] flags */
+			int width;          /* [out] width */
+			int height;         /* [out] height */
+			int par;            /* [out] pixel aspect ratio (refer to XVID_PAR_xxx above) */
+			int par_width;      /* [out] aspect ratio width  [1..255] */
+			int par_height;     /* [out] aspect ratio height [1..255] */
+		} vol;
+	} data;
+} xvid_dec_stats_t;
+
+#define XVID_ZONE_QUANT  (1&lt;&lt;0)
+#define XVID_ZONE_WEIGHT (1&lt;&lt;1)
+
+typedef struct
+{
+	int frame;
+	int mode;
+	int increment;
+	int base;
+} xvid_enc_zone_t;
+
+
+/*----------------------------------------------------------------------------
+ * xvid_enc_stats_t structure
+ *
+ * Used in:
+ *  - xvid_plg_data_t structure
+ *  - optional parameter in xvid_encore() function
+ *
+ * .coding_type = XVID_TYPE_NOTHING if the stats are not given
+ *--------------------------------------------------------------------------*/
+
+typedef struct {
+	int version;
+
+	/* encoding parameters */
+	int type;      /* [out] coding type */
+	int quant;     /* [out] frame quantizer */
+	int vol_flags; /* [out] vol flags (see above) */
+	int vop_flags; /* [out] vop flags (see above) */
+
+	/* bitrate */
+	int length;    /* [out] frame length */
+
+	int hlength;   /* [out] header length (bytes) */
+	int kblks;     /* [out] number of blocks compressed as Intra */
+	int mblks;     /* [out] number of blocks compressed as Inter */
+	int ublks;     /* [out] number of blocks marked as not_coded */
+
+	int sse_y;     /* [out] Y plane's sse */
+	int sse_u;     /* [out] U plane's sse */
+	int sse_v;     /* [out] V plane's sse */
+} xvid_enc_stats_t;
+
+/*****************************************************************************
+  xvid plugin system -- internals
+
+  xvidcore will call XVID_PLG_INFO and XVID_PLG_CREATE during XVID_ENC_CREATE
+  before encoding each frame xvidcore will call XVID_PLG_BEFORE
+  after encoding each frame xvidcore will call XVID_PLG_AFTER
+  xvidcore will call XVID_PLG_DESTROY during XVID_ENC_DESTROY
+ ****************************************************************************/
+
+
+#define XVID_PLG_CREATE  (1&lt;&lt;0)
+#define XVID_PLG_DESTROY (1&lt;&lt;1)
+#define XVID_PLG_INFO    (1&lt;&lt;2)
+#define XVID_PLG_BEFORE  (1&lt;&lt;3)
+#define XVID_PLG_FRAME   (1&lt;&lt;4)
+#define XVID_PLG_AFTER   (1&lt;&lt;5)
+
+/* xvid_plg_info_t.flags */
+#define XVID_REQORIGINAL (1&lt;&lt;0) /* plugin requires a copy of the original (uncompressed) image */
+#define XVID_REQPSNR     (1&lt;&lt;1) /* plugin requires psnr between the uncompressed and compressed image*/
+#define XVID_REQDQUANTS  (1&lt;&lt;2) /* plugin requires access to the dquant table */
+
+
+typedef struct
+{
+	int version;
+	int flags;   /* [in:opt] plugin flags */
+} xvid_plg_info_t;
+
+
+typedef struct
+{
+	int version;
+
+	int num_zones;           /* [out] */
+	xvid_enc_zone_t * zones; /* [out] */
+
+	int width;               /* [out] */
+	int height;              /* [out] */
+	int mb_width;            /* [out] */
+	int mb_height;           /* [out] */
+	int fincr;               /* [out] */
+	int fbase;               /* [out] */
+
+	void * param;            /* [out] */
+} xvid_plg_create_t;
+
+
+typedef struct
+{
+	int version;
+
+	int num_frames; /* [out] total frame encoded */
+} xvid_plg_destroy_t;
+
+typedef struct
+{
+	int version;
+
+	xvid_enc_zone_t * zone; /* [out] current zone */
+
+	int width;              /* [out] */
+	int height;             /* [out] */
+	int mb_width;           /* [out] */
+	int mb_height;          /* [out] */
+	int fincr;              /* [out] */
+	int fbase;              /* [out] */
+
+	int min_quant[3];       /* [out] */
+	int max_quant[3];       /* [out] */
+
+	xvid_image_t reference; /* [out] -&gt; [out] */
+	xvid_image_t current;   /* [out] -&gt; [in,out] */
+	xvid_image_t original;  /* [out] after: points the original (uncompressed) copy of the current frame */
+	int frame_num;          /* [out] frame number */
+
+	int type;               /* [in,out] */
+	int quant;              /* [in,out] */
+
+	int * dquant;           /* [in,out]	pointer to diff quantizer table */
+	int dquant_stride;      /* [in,out]	diff quantizer stride */
+
+	int vop_flags;          /* [in,out] */
+	int vol_flags;          /* [in,out] */
+	int motion_flags;       /* [in,out] */
+
+/* Deprecated, use the stats field instead.
+ * Will disapear before 1.0 */
+	int length;             /* [out] after: length of encoded frame */
+	int kblks;              /* [out] number of blocks compressed as Intra */
+	int mblks;              /* [out] number of blocks compressed as Inter */
+	int ublks;              /* [out] number of blocks marked not_coded */
+	int sse_y;              /* [out] Y plane's sse */
+	int sse_u;              /* [out] U plane's sse */
+	int sse_v;              /* [out] V plane's sse */
+/* End of duplicated data, kept only for binary compatibility */
+
+	int bquant_ratio;       /* [in] */
+	int bquant_offset;      /* [in] */
+
+	xvid_enc_stats_t stats; /* [out] frame statistics */
+} xvid_plg_data_t;
+
+/*****************************************************************************
+  xvid plugin system -- external
+
+  the application passes xvid an array of &quot;xvid_plugin_t&quot; at XVID_ENC_CREATE. the array
+  indicates the plugin function pointer and plugin-specific data.
+  xvidcore handles the rest. example:
+
+  xvid_enc_create_t create;
+  xvid_enc_plugin_t plugins[2];
+
+  plugins[0].func = xvid_psnr_func;
+  plugins[0].param = NULL;
+  plugins[1].func = xvid_cbr_func;
+  plugins[1].param = &amp;cbr_data;
+
+  create.num_plugins = 2;
+  create.plugins = plugins;
+
+ ****************************************************************************/
+
+typedef int (xvid_plugin_func)(void * handle, int opt, void * param1, void * param2);
+
+typedef struct
+{
+	xvid_plugin_func * func;
+	void * param;
+} xvid_enc_plugin_t;
+
+
+extern xvid_plugin_func xvid_plugin_single;   /* single-pass rate control */
+//extern xvid_plugin_func xvid_plugin_2pass1;   /* two-pass rate control: first pass */
+//extern xvid_plugin_func xvid_plugin_2pass2;   /* two-pass rate control: second pass */
+
+extern xvid_plugin_func xvid_plugin_lumimasking;  /* lumimasking */
+
+extern xvid_plugin_func xvid_plugin_psnr;	/* write psnr values to stdout */
+extern xvid_plugin_func xvid_plugin_dump;	/* dump before and after yuvpgms */
+
+
+/* single pass rate control
+ * CBR and Constant quantizer modes */
+typedef struct
+{
+	int version;
+
+	int bitrate;               /* [in] bits per second */
+	int reaction_delay_factor; /* [in] */
+	int averaging_period;      /* [in] */
+	int buffer;                /* [in] */
+} xvid_plugin_single_t;
+
+
+typedef struct {
+	int version;
+
+	char * filename;
+} xvid_plugin_2pass1_t;
+
+
+#define XVID_PAYBACK_BIAS 0 /* payback with bias */
+#define XVID_PAYBACK_PROP 1 /* payback proportionally */
+
+typedef struct {
+	int version;
+
+	int bitrate;                  /* [in] bits per second */
+	char * filename;              /* [in] first pass stats filename */
+
+	int keyframe_boost;           /* [in] keyframe boost percentage: [0..100] */
+	int curve_compression_high;   /* [in] percentage of compression performed on the high part of the curve (above average) */
+	int curve_compression_low;    /* [in] percentage of compression performed on the low  part of the curve (below average) */
+	int overflow_control_strength;/* [in] Payback delay expressed in number of frames */
+	int max_overflow_improvement; /* [in] percentage of allowed range for a frame that gets bigger because of overflow bonus */
+	int max_overflow_degradation; /* [in] percentage of allowed range for a frame that gets smaller because of overflow penalty */
+
+	int kfreduction;              /* [in] maximum bitrate reduction applied to an iframe under the kfthreshold distance limit */
+	int kfthreshold;              /* [in] if an iframe is closer to the next iframe than this distance, a quantity of bits
+								   *      is substracted from its bit allocation. The reduction is computed as multiples of
+								   *      kfreduction/kthreshold. It reaches kfreduction when the distance == kfthreshold,
+								   *      0 for 1&lt;distance&lt;kfthreshold */
+
+	int container_frame_overhead; /* [in] How many bytes the controller has to compensate per frame due to container format overhead */
+
+#ifdef VBV
+  int vbv_size;
+  int vbv_initial;
+  int vbv_maxrate;
+  int vbv_peakrate;
+#endif
+
+}xvid_plugin_2pass2_t;
+
+/*****************************************************************************
+ *                             ENCODER API
+ ****************************************************************************/
+
+/*----------------------------------------------------------------------------
+ * Encoder operations
+ *--------------------------------------------------------------------------*/
+
+#define XVID_ENC_CREATE  0 /* create encoder instance; returns 0 on success */
+#define XVID_ENC_DESTROY 1 /* destroy encoder instance; returns 0 on success */
+#define XVID_ENC_ENCODE  2 /* encode a frame: returns number of ouput bytes
+                            * 0 means this frame should not be written (ie. encoder lag) */
+
+
+/*----------------------------------------------------------------------------
+ * Encoder entry point
+ *--------------------------------------------------------------------------*/
+
+extern int xvid_encore(void *handle, int opt, void *param1, void *param2);
+
+/* Quick API reference
+ *
+ * XVID_ENC_CREATE operation
+ *  - handle: ignored
+ *  - opt: XVID_ENC_CREATE
+ *  - param1: address of a xvid_enc_create_t structure
+ *  - param2: ignored
+ *
+ * XVID_ENC_ENCODE operation
+ *  - handle: an instance returned by a CREATE op
+ *  - opt: XVID_ENC_ENCODE
+ *  - param1: address of a xvid_enc_frame_t structure
+ *  - param2: address of a xvid_enc_stats_t structure (optional)
+ *            its return value is asynchronous to what is written to the buffer
+ *            depending on the delay introduced by bvop use. It's display
+ *            ordered.
+ *
+ * XVID_ENC_DESTROY operation
+ *  - handle: an instance returned by a CREATE op
+ *  - opt: XVID_ENC_DESTROY
+ *  - param1: ignored
+ *  - param2: ignored
+ */
+
+
+/*----------------------------------------------------------------------------
+ * &quot;Global&quot; flags
+ *
+ * These flags are used for xvid_enc_create_t-&gt;global field during instance
+ * creation (operation XVID_ENC_CREATE)
+ *--------------------------------------------------------------------------*/
+
+#define XVID_GLOBAL_PACKED            (1&lt;&lt;0) /* packed bitstream */
+#define XVID_GLOBAL_CLOSED_GOP        (1&lt;&lt;1) /* closed_gop:	was DX50BVOP dx50 bvop compatibility */
+#define XVID_GLOBAL_EXTRASTATS_ENABLE (1&lt;&lt;2)
+#if 0
+#define XVID_GLOBAL_VOL_AT_IVOP       (1&lt;&lt;3) /* write vol at every ivop: WIN32/divx compatibility */
+#define XVID_GLOBAL_FORCE_VOL         (1&lt;&lt;4) /* when vol-based parameters are changed, insert an ivop NOT recommended */
+#endif
+
+
+/*----------------------------------------------------------------------------
+ * &quot;VOL&quot; flags
+ *
+ * These flags are used for xvid_enc_frame_t-&gt;vol_flags field during frame
+ * encoding (operation XVID_ENC_ENCODE)
+ *--------------------------------------------------------------------------*/
+
+#define XVID_VOL_MPEGQUANT      (1&lt;&lt;0) /* enable MPEG type quantization */
+#define XVID_VOL_EXTRASTATS     (1&lt;&lt;1) /* enable plane sse stats */
+#define XVID_VOL_QUARTERPEL     (1&lt;&lt;2) /* enable quarterpel: frames will encoded as quarterpel */
+#define XVID_VOL_GMC            (1&lt;&lt;3) /* enable GMC; frames will be checked for gmc suitability */
+#define XVID_VOL_REDUCED_ENABLE (1&lt;&lt;4) /* enable reduced resolution vops: frames will be checked for rrv suitability */
+#define XVID_VOL_INTERLACING    (1&lt;&lt;5) /* enable interlaced encoding */
+
+
+/*----------------------------------------------------------------------------
+ * &quot;VOP&quot; flags
+ *
+ * These flags are used for xvid_enc_frame_t-&gt;vop_flags field during frame
+ * encoding (operation XVID_ENC_ENCODE)
+ *--------------------------------------------------------------------------*/
+
+/* Always valid */
+#define XVID_VOP_DEBUG                (1&lt;&lt; 0) /* print debug messages in frames */
+#define XVID_VOP_HALFPEL              (1&lt;&lt; 1) /* use halfpel interpolation */
+#define XVID_VOP_INTER4V              (1&lt;&lt; 2) /* use 4 motion vectors per MB */
+#define XVID_VOP_TRELLISQUANT         (1&lt;&lt; 3) /* use trellis based R-D &quot;optimal&quot; quantization */
+#define XVID_VOP_CHROMAOPT            (1&lt;&lt; 4) /* enable chroma optimization pre-filter */
+#define XVID_VOP_CARTOON              (1&lt;&lt; 5) /* use 'cartoon mode' */
+#define XVID_VOP_GREYSCALE            (1&lt;&lt; 6) /* enable greyscale only mode (even for  color input material chroma is ignored) */
+#define XVID_VOP_HQACPRED             (1&lt;&lt; 7) /* high quality ac prediction */
+#define XVID_VOP_MODEDECISION_RD      (1&lt;&lt; 8) /* enable DCT-ME and use it for mode decision */
+#define XVID_VOP_FAST_MODEDECISION_RD (1&lt;&lt;12) /* use simplified R-D mode decision */
+
+/* Only valid for vol_flags|=XVID_VOL_INTERLACING */
+#define XVID_VOP_TOPFIELDFIRST        (1&lt;&lt; 9) /* set top-field-first flag  */
+#define XVID_VOP_ALTERNATESCAN        (1&lt;&lt;10) /* set alternate vertical scan flag */
+
+/* only valid for vol_flags|=XVID_VOL_REDUCED_ENABLED */
+#define XVID_VOP_REDUCED              (1&lt;&lt;11) /* reduced resolution vop */
+
+
+/*----------------------------------------------------------------------------
+ * &quot;Motion&quot; flags
+ *
+ * These flags are used for xvid_enc_frame_t-&gt;motion field during frame
+ * encoding (operation XVID_ENC_ENCODE)
+ *--------------------------------------------------------------------------*/
+
+/* Motion Estimation Search Patterns */
+#define XVID_ME_ADVANCEDDIAMOND16     (1&lt;&lt; 0) /* use advdiamonds instead of diamonds as search pattern */
+#define XVID_ME_ADVANCEDDIAMOND8      (1&lt;&lt; 1) /* use advdiamond for XVID_ME_EXTSEARCH8 */
+#define XVID_ME_USESQUARES16          (1&lt;&lt; 2) /* use squares instead of diamonds as search pattern */
+#define XVID_ME_USESQUARES8           (1&lt;&lt; 3) /* use square for XVID_ME_EXTSEARCH8 */
+
+/* SAD operator based flags */
+#define XVID_ME_HALFPELREFINE16       (1&lt;&lt; 4)
+#define XVID_ME_HALFPELREFINE8        (1&lt;&lt; 6)
+#define XVID_ME_QUARTERPELREFINE16    (1&lt;&lt; 7)
+#define XVID_ME_QUARTERPELREFINE8     (1&lt;&lt; 8)
+#define XVID_ME_GME_REFINE            (1&lt;&lt; 9)
+#define XVID_ME_EXTSEARCH16           (1&lt;&lt;10) /* extend PMV by more searches */
+#define XVID_ME_EXTSEARCH8            (1&lt;&lt;11) /* use diamond/square for extended 8x8 search */
+#define XVID_ME_CHROMA_PVOP           (1&lt;&lt;12) /* also use chroma for P_VOP/S_VOP ME */
+#define XVID_ME_CHROMA_BVOP           (1&lt;&lt;13) /* also use chroma for B_VOP ME */
+#define XVID_ME_FASTREFINE16          (1&lt;&lt;25) /* use low-complexity refinement functions */
+#define XVID_ME_FASTREFINE8           (1&lt;&lt;29) /* low-complexity 8x8 sub-block refinement */
+
+/* Rate Distortion based flags
+ * Valid when XVID_VOP_MODEDECISION_RD is enabled */
+#define XVID_ME_HALFPELREFINE16_RD    (1&lt;&lt;14) /* perform RD-based halfpel refinement */
+#define XVID_ME_HALFPELREFINE8_RD     (1&lt;&lt;15) /* perform RD-based halfpel refinement for 8x8 mode */
+#define XVID_ME_QUARTERPELREFINE16_RD (1&lt;&lt;16) /* perform RD-based qpel refinement */
+#define XVID_ME_QUARTERPELREFINE8_RD  (1&lt;&lt;17) /* perform RD-based qpel refinement for 8x8 mode */
+#define XVID_ME_EXTSEARCH_RD          (1&lt;&lt;18) /* perform RD-based search using square pattern enable XVID_ME_EXTSEARCH8 to do this in 8x8 search as well */
+#define XVID_ME_CHECKPREDICTION_RD    (1&lt;&lt;19) /* always check vector equal to prediction */
+
+/* Other */
+#define XVID_ME_DETECT_STATIC_MOTION  (1&lt;&lt;24) /* speed-up ME by detecting stationary scenes */
+#define XVID_ME_SKIP_DELTASEARCH      (1&lt;&lt;26) /* speed-up by skipping b-frame delta search */
+#define XVID_ME_FAST_MODEINTERPOLATE  (1&lt;&lt;27) /* speed-up by partly skipping interpolate mode */
+#define XVID_ME_BFRAME_EARLYSTOP      (1&lt;&lt;28) /* speed-up by early exiting b-search */
+
+/* Unused */
+#define XVID_ME_UNRESTRICTED16        (1&lt;&lt;20) /* unrestricted ME, not implemented */
+#define XVID_ME_OVERLAPPING16         (1&lt;&lt;21) /* overlapping ME, not implemented */
+#define XVID_ME_UNRESTRICTED8         (1&lt;&lt;22) /* unrestricted ME, not implemented */
+#define XVID_ME_OVERLAPPING8          (1&lt;&lt;23) /* overlapping ME, not implemented */
+
+
+/*----------------------------------------------------------------------------
+ * xvid_enc_create_t structure definition
+ *
+ * This structure is passed as param1 during an instance creation (operation
+ * XVID_ENC_CREATE)
+ *--------------------------------------------------------------------------*/
+
+typedef struct {
+	int version;
+
+	int profile;                 /* [in] <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">profile at level</A>; refer to XVID_PROFILE_xxx */
+	int width;                   /* [in] frame dimensions; width, pixel units */
+	int height;                  /* [in] frame dimensions; height, pixel units */
+
+	int num_zones;               /* [in:opt] number of bitrate zones */
+	xvid_enc_zone_t * zones;     /*          ^^ zone array */
+
+	int num_plugins;             /* [in:opt] number of plugins */
+	xvid_enc_plugin_t * plugins; /*          ^^ plugin array */
+
+	int num_threads;             /* [in:opt] number of threads */
+	int max_bframes;             /* [in:opt] max sequential bframes (0=disable bframes) */
+
+	int global;                  /* [in:opt] global flags; controls encoding behavior */
+
+	/* --- vol-based stuff; included here for convenience */
+	int fincr;                   /* [in:opt] framerate increment; set to zero for variable framerate */
+	int fbase;                   /* [in] framerate base frame_duration = fincr/fbase seconds*/
+    /* ---------------------------------------------- */
+
+	/* --- vop-based; included here for convenience */
+	int max_key_interval;        /* [in:opt] the maximum interval between key frames */
+
+	int frame_drop_ratio;        /* [in:opt] frame dropping: 0=drop none... 100=drop all */
+
+	int bquant_ratio;            /* [in:opt] bframe quantizer multipier/offeset; used to decide bframes quant when bquant==-1 */
+	int bquant_offset;           /* bquant = (avg(past_ref_quant,future_ref_quant)*bquant_ratio + bquant_offset) / 100 */
+
+	int min_quant[3];            /* [in:opt] */
+	int max_quant[3];            /* [in:opt] */
+	/* ---------------------------------------------- */
+
+	void *handle;                /* [out] encoder instance handle */
+} xvid_enc_create_t;
+
+
+/*----------------------------------------------------------------------------
+ * xvid_enc_frame_t structure definition
+ *
+ * This structure is passed as param1 during a frame encoding (operation
+ * XVID_ENC_ENCODE)
+ *--------------------------------------------------------------------------*/
+
+/* out value for the frame structure-&gt;type field
+ * unlike stats output in param2, this field is not asynchronous and tells
+ * the client app, if the frame written into the stream buffer is an ivop
+ * usually used for indexing purpose in the container */
+#define XVID_KEYFRAME (1&lt;&lt;1)
+
+/* The structure */
+typedef struct {
+	int version;
+
+	/* VOL related stuff
+	 * unless XVID_FORCEVOL is set, the encoder will not react to any changes
+	 * here until the next VOL (keyframe). */
+
+	int vol_flags;                     /* [in] vol flags */
+	unsigned char *quant_intra_matrix; /* [in:opt] custom intra qmatrix */
+	unsigned char *quant_inter_matrix; /* [in:opt] custom inter qmatrix */
+
+	int par;                           /* [in:opt] pixel aspect ratio (refer to XVID_PAR_xxx above) */
+	int par_width;                     /* [in:opt] aspect ratio width */
+	int par_height;                    /* [in:opt] aspect ratio height */
+
+	/* Other fields that can change on a frame base */
+
+	int fincr;                         /* [in:opt] framerate increment, for variable framerate only */
+	int vop_flags;                     /* [in] (general)vop-based flags */
+	int motion;                        /* [in] ME options */
+
+	xvid_image_t input;                /* [in] input image (read from) */
+
+	int type;                          /* [in:opt] coding type */
+	int quant;                         /* [in] frame quantizer; if &lt;=0, automatic (ratecontrol) */
+	int bframe_threshold;
+
+	void *bitstream;                   /* [in:opt] bitstream ptr (written to)*/
+	int length;                        /* [in:opt] bitstream length (bytes) */
+
+	int out_flags;                     /* [out] bitstream output flags */
+} xvid_enc_frame_t;
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+

Added: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_avcodec/xvidRateCtl/xvidRateCtl.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_avcodec/xvidRateCtl/xvidRateCtl.cpp	2009-12-28 06:39:12 UTC (rev 5742)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_avcodec/xvidRateCtl/xvidRateCtl.cpp	2009-12-28 12:04:18 UTC (rev 5743)
@@ -0,0 +1,2359 @@
+ // Port of below to use with mpeg2enc/lavcodec
+ // port by mean, see below for original copyright/authors
+ 
+ /******************************************************************************
+ *
+ *  XviD Bit Rate Controller Library
+ *  - VBR 2 pass bitrate controller implementation -
+ *
+ *  Copyright (C)      2002 Foxer &lt;email?&gt;
+ *                     2002 Dirk Knop &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">dknop at gwdg.de</A>&gt;
+ *                2002-2003 Edouard Gomez &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">ed.gomez at free.fr</A>&gt;
+ *                     2003 Pete Ross &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">pross at xvid.org</A>&gt;
+ *
+ *  This curve treatment algorithm is the one originally implemented by Foxer
+ *  and tuned by Dirk Knop for the XviD vfw frontend.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * $Id: ADM_xvidratectl.cpp 3832 2008-03-06 18:32:32Z gruntster $
+ *
+ *****************************************************************************/
+
+//#define BQUANT_PRESCALE
+#undef BQUANT_PRESCALE
+#undef COMPENSATE_FORMULA
+#define MEANX_RESCALE
+/* forces second pass not to be bigger than first */
+#undef PASS_SMALLER
+
+/* automatically alters overflow controls (strength and improvement/degradation)
+to fight most common problems without user's knowladge */
+#define SMART_OVERFLOW_SETTING
+#define VBV
+
+#include &lt;stdio.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;string.h&gt;
+#include &lt;limits.h&gt;
+#include &lt;math.h&gt;
+
+#undef NDEBUG
+#include &lt;assert.h&gt;
+
+#include &quot;xvidRateCtl.h&quot;
+#include &quot;xvid.h&quot;
+
+#define aprintf(prt, args...);
+#define DPRINTF(a,b, args...) aprintf(b,## args);
+
+/*****************************************************************************
+* Some default settings
+****************************************************************************/
+
+#define DEFAULT_KEYFRAME_BOOST 0
+#define DEFAULT_OVERFLOW_CONTROL_STRENGTH 10
+#define DEFAULT_CURVE_COMPRESSION_HIGH 0
+#define DEFAULT_CURVE_COMPRESSION_LOW 0
+#define DEFAULT_MAX_OVERFLOW_IMPROVEMENT 10
+#define DEFAULT_MAX_OVERFLOW_DEGRADATION 10
+
+/* Keyframe settings */
+#define DEFAULT_KFREDUCTION 20
+#define DEFAULT_KFTHRESHOLD 1
+
+/*****************************************************************************
+* Some default constants (can be tuned)
+****************************************************************************/
+
+/* Specify the invariant part of the headers bits (header+MV)
+* as  hlength/cst */
+#define INVARIANT_HEADER_PART_IVOP 1 /* factor 1.0f   */
+#define INVARIANT_HEADER_PART_PVOP 2 /* factor 0.5f   */
+#define INVARIANT_HEADER_PART_BVOP 8 /* factor 0.125f */
+
+/*****************************************************************************
+* Structures
+****************************************************************************/
+
+/* Statistics */
+typedef struct {
+	int type;               /* first pass type */
+	int quant;              /* first pass quant */
+	int blks[3];            /* k,m,y blks */
+	int length;             /* first pass length */
+	int invariant;          /* what we assume as being invariant between the two passes, it's a sub part of header + MV bits */
+	int scaled_length;      /* scaled length */
+	int desired_length;     /* desired length; calculated during encoding */
+	int error;
+
+	int zone_mode;   /* XVID_ZONE_xxx */
+	double weight;
+} twopass_stat_t;
+
+typedef struct
+{
+	FILE * stat_file;
+	double fq_error;
+} rc_2pass1_t;
+
+/* Context struct */
+typedef struct
+{
+	xvid_plugin_2pass2_t param;
+
+	/*----------------------------------
+	* constant statistical data
+	*--------------------------------*/
+
+	/* Number of frames of the sequence */
+	int num_frames;
+
+	/* Number of Intra frames of the sequence */
+	int num_keyframes;
+
+	/* Target filesize to reach */
+	uint64_t target;
+
+	/* Count of each frame types */
+	int count[3];
+
+	/* Total length of each frame types (1st pass) */
+	uint64_t tot_length[3];
+	uint64_t tot_invariant[3];
+
+	/* Average length of each frame types (used first for 1st pass data and
+	* then for scaled averages */
+	double avg_length[3];
+
+	/* Minimum frame length allowed for each frame type */
+	int min_length[3];
+
+	/* Total bytes per frame type once the curve has been scaled
+	* NB: advanced parameters do not change this value. This field
+	*     represents the total scaled w/o any advanced settings */
+	uint64_t tot_scaled_length[3];
+
+	/* Maximum observed frame size observed during the first pass, the RC
+	* will try tp force all frame sizes in the second pass to be under that
+	* limit */
+	int max_length;
+
+	/*----------------------------------
+	* Zones statistical data
+	*--------------------------------*/
+
+	/* Total length used by XVID_ZONE_QUANT zones */
+	uint64_t tot_quant;
+	uint64_t tot_quant_invariant;
+
+	/* Holds the total amount of frame bytes, zone weighted (only scalable
+	* part of frame bytes) */
+	uint64_t tot_weighted;
+
+	/*----------------------------------
+	* Advanced settings helper ratios
+	*--------------------------------*/
+
+	/* This the ratio that has to be applied to all p/b frames in order
+	* to reserve/retrieve bits for/from keyframe boosting and consecutive
+	* keyframe penalty */
+	double pb_iboost_tax_ratio;
+
+	/* This the ratio to apply to all b/p frames in order to respect the
+	* assymetric curve compression while respecting a target filesize
+	* NB: The assymetric delta gain has to be computed before this ratio
+	*     is applied, and then the delta is added to the scaled size */
+	double assymetric_tax_ratio;
+
+	/*----------------------------------
+	* Data from the stats file kept
+	* into RAM for easy access
+	*--------------------------------*/
+
+	/* Array of keyframe locations
+	* eg: rc-&gt;keyframe_locations[100] returns the frame number of the 100th
+	*     keyframe */
+	int *keyframe_locations;
+
+	/* Index of the last keyframe used in the keyframe_location */
+	int KF_idx;
+
+	/* Array of all 1st pass data file -- see the twopass_stat_t structure
+	* definition for more details */
+	twopass_stat_t * stats;
+
+	/*----------------------------------
+	* Hysteresis helpers
+	*--------------------------------*/
+
+	/* This field holds the int2float conversion errors of each quant per
+	* frame type, this allow the RC to keep track of rouding error and thus
+	* increase or decrease the chosen quant according to this residue */
+	double quant_error[3][32];
+
+	/* This fields stores the count of each quant usage per frame type
+	* No real role but for debugging */
+	int quant_count[3][32];
+
+	/* Last valid quantizer used per frame type, it allows quantizer
+	* increament/decreament limitation in order to avoid big image quality
+	* &quot;jumps&quot; */
+	int last_quant[3];
+
+	/*----------------------------------
+	* Overflow control
+	*--------------------------------*/
+
+	/* Current overflow that has to be distributed to p/b frames */
+	double overflow;
+
+	/* Total overflow for keyframes -- not distributed directly */
+	double KFoverflow;
+
+	/* Amount of keyframe overflow to introduce to the global p/b frame
+	* overflow counter at each encoded frame */
+	double KFoverflow_partial;
+
+	/* Unknown ???
+	* ToDo: description */
+	double fq_error;
+
+	int min_quant; /* internal minimal quant, prevents wrong quants from being used */
+
+	/*----------------------------------
+	* Debug
+	*--------------------------------*/
+	double desired_total;
+	double real_total;
+} rc_2pass2_t;
+
+static xvid_plg_data_t  _2pass_data;
+/*****************************************************************************
+* Sub plugin functions prototypes
+****************************************************************************/
+
+static int rc_2pass2_create(xvid_plg_create_t * create, rc_2pass2_t ** handle);
+static int rc_2pass2_before(rc_2pass2_t * rc, xvid_plg_data_t * data);
+static int rc_2pass2_after(rc_2pass2_t * rc, xvid_plg_data_t * data);
+static int rc_2pass2_destroy(rc_2pass2_t * rc, xvid_plg_destroy_t * destroy);
+
+//MEANX: cpp
+static int scale_curve_for_vbv_compliancy(rc_2pass2_t * rc, const float fps);
+static int check_curve_for_vbv_compliancy(rc_2pass2_t * rc, const float fps);
+static void scaled_curve_apply_advanced_parameters(rc_2pass2_t * rc);
+static void first_pass_scale_curve_internal(rc_2pass2_t *rc);
+static void zone_process(rc_2pass2_t *rc, const xvid_plg_create_t * create);
+static void first_pass_stats_prepare_data(rc_2pass2_t * rc);
+static int  statsfile_load(rc_2pass2_t *rc, char * filename);
+static  int statsfile_count_frames(rc_2pass2_t * rc, char * filename);
+static char *skipspaces(char *string);
+static int iscomment(char *string);
+static char *readline(FILE *f);
+static int rc_2pass2_after(rc_2pass2_t * rc, xvid_plg_data_t * data);
+static int rc_2pass2_before(rc_2pass2_t * rc, xvid_plg_data_t * data);
+static int rc_2pass2_destroy(rc_2pass2_t * rc, xvid_plg_destroy_t * destroy);
+static int rc_2pass2_create(xvid_plg_create_t * create, rc_2pass2_t **handle);
+static int xvid_plugin_2pass1(void * handle, int opt, void * param1, void * param2);
+static  int rc_2pass1_after(rc_2pass1_t * rc, xvid_plg_data_t * data);
+
+static int rc_2pass1_before(rc_2pass1_t * rc, xvid_plg_data_t * data);
+static  int rc_2pass1_destroy(rc_2pass1_t * rc, xvid_plg_destroy_t * destroy);
+static  int rc_2pass1_create(xvid_plg_create_t * create, rc_2pass1_t ** handle);
+
+static void writeQuantStat(rc_2pass2_t * rc);
+
+//****************************************************************************************
+//****************************************************************************************
+//****************************************************************************************
+#define FAKE_VERSION  XVID_MAKE_VERSION(1,1,99) 
+static void *myHandle = NULL;
+
+ADM_newXvidRc::~ADM_newXvidRc()
+{
+	xvid_plg_destroy_t data;
+	printf(&quot;Destroying new xvid ratecontrol\n&quot;);
+	data.version=FAKE_VERSION;
+
+	switch(_state)
+	{
+		case RS_IDLE:
+			break;
+		case RS_PASS1:
+			rc_2pass1_destroy((rc_2pass1_t *)myHandle,&amp;data);
+			break;
+		case RS_PASS2:writeQuantStat((rc_2pass2_t *)myHandle);
+			rc_2pass2_destroy((rc_2pass2_t *)myHandle,&amp;data);
+			break;
+	}
+	_state = RS_IDLE;
+	myHandle = 0;
+}
+
+ADM_newXvidRc::ADM_newXvidRc(uint32_t fps1000, char *logname) : ADM_ratecontrol(fps1000,logname)
+{
+	_totalFrame=0;
+}
+
+uint8_t ADM_newXvidRc::setVBVInfo(uint32_t maxbr,uint32_t minbr, uint32_t vbvsize)
+{
+	return 1;
+}
+
+uint8_t ADM_newXvidRc::startPass1( void )
+{
+	xvid_plugin_2pass1_t 	data;
+	xvid_plg_create_t	create;
+	assert(_state==RS_IDLE);
+
+	create.version=FAKE_VERSION;
+	create.param=&data;	
+
+	data.version=FAKE_VERSION; // Fake 1.1
+	data.filename=_logname;
+
+	if(rc_2pass1_create(&amp;create, (rc_2pass1_t **)&amp;myHandle))
+	{
+		printf(&quot;XvidRC(new): pass1 failed\n&quot;);
+		return 0;
+	}
+
+	_state=RS_PASS1;
+
+	return 1;
+}
+
+uint8_t ADM_newXvidRc::logPass1(uint32_t qz, ADM_rframe ftype,uint32_t size)
+{
+	xvid_plg_data_t  data;
+
+	memset(&amp;data,0,sizeof(data));
+	data.stats.version=FAKE_VERSION;
+	data.version=FAKE_VERSION;
+
+	switch(ftype)
+	{
+		case RF_I:
+			data.stats.type=XVID_TYPE_IVOP;
+			break;
+		case RF_P:
+			data.stats.type=XVID_TYPE_PVOP;
+			break;
+		case RF_B:
+			data.stats.type=XVID_TYPE_BVOP;
+			break;
+	}
+
+	data.stats.quant=qz;
+	data.stats.length=size;
+
+	rc_2pass1_after((rc_2pass1_t *)myHandle,&amp;data);
+	_nbFrames++;
+
+	return 1;
+}
+uint8_t ADM_newXvidRc::getInfo(uint32_t framenum, uint32_t *qz, uint32_t *size,ADM_rframe *type )
+{
+	rc_2pass2_t * rc;
+	int override=0;
+
+	assert(_state==RS_PASS2);
+	rc=(rc_2pass2_t *)myHandle;
+	assert(rc);
+
+	assert(framenum&lt;_totalFrame);
+	if(framenum&gt;=rc-&gt;num_frames) // We may have 2 stray frames due to encoder lag
+	{
+		// but only 2
+		//ADM_assert(framenum&lt;rc-&gt;num_frames+2)
+		override=1;
+	}
+
+	if(framenum&gt;=_totalFrame-2)
+	{
+		override=1;
+	}
+
+	if(override)
+	{
+		printf(&quot;[Xvid rc] Override\n&quot;);
+		*type=RF_I;
+		*qz=4;
+		*size=1000;
+		return 1;
+	}
+
+	*qz=rc-&gt;stats[framenum].quant;
+	*size=rc-&gt;stats[framenum].length;
+
+	switch(rc-&gt;stats[framenum].type)
+	{
+		case XVID_TYPE_IVOP:
+			*type=RF_I;
+			break;
+		case XVID_TYPE_PVOP:
+			*type=RF_P;
+			break;
+		case XVID_TYPE_BVOP:
+			*type=RF_B;
+			break;
+		default:
+			printf(&quot;f:%lu Type : %d\n&quot;,framenum,rc-&gt;stats[framenum].type);
+			assert(0);
+	}
+
+	return 1;
+
+}
+//
+uint8_t ADM_newXvidRc::startPass2( uint32_t final_size,uint32_t nbFrame )
+{
+	xvid_plugin_2pass2_t 	data;
+	xvid_plg_create_t	create;
+
+	assert((_state==RS_IDLE)||(_state==RS_PASS1));
+
+	if (_state==RS_PASS1)
+	{
+		xvid_plg_destroy_t data;
+		printf(&quot;Destroying new xvid ratecontrol(pass1)\n&quot;);
+		data.version=FAKE_VERSION;
+		rc_2pass1_destroy((rc_2pass1_t *)myHandle,&amp;data);
+		myHandle=NULL;
+	}
+
+	printf(&quot;[Xvid RC] Starting pass2 , %u frames\n&quot;,nbFrame);
+	_totalFrame=_nbFrames=nbFrame;
+	memset(&amp;data,0,sizeof(data));
+	memset(&amp;create,0,sizeof(create));
+
+	//avg/=1000; //bps / kbps
+
+	printf(&quot;Xvidr: pass2 : %lu MB, avg:%d, nbframe:%lu\n&quot;,final_size,0,_nbFrames);
+
+	create.version=FAKE_VERSION;
+	create.param=&data;	
+
+	data.version=FAKE_VERSION; // Fake 1.1
+	data.filename=_logname;
+
+	create.width=720;
+	create.height=576;
+
+	// incr/base =1000/fps1000
+	//base*1000=incr*fps1000
+	// base=fps1000 incr=1000
+	create.fbase=_fps1000;
+	create.fincr=1000;
+
+	data.bitrate=-1024*final_size;
+	data.keyframe_boost=10;
+	/*
+	data.curve_compression_high=10;
+	data.curve_compression_low=10;
+	data.overflow_control_strength=10;
+	data.max_overflow_improvement=10;
+	data.max_overflow_degradation=10;
+	data.kfreduction=10;
+	data.kfthreshold=10;
+	*/
+
+	if(rc_2pass2_create(&amp;create, (rc_2pass2_t **)&amp;myHandle))
+	{
+		printf(&quot;XvidRC(new): pass2 failed\n&quot;);
+		_state=RS_IDLE;
+		return 0;
+	}
+
+	_state=RS_PASS2;
+	_nbFrames=0;
+	memset(&amp;_2pass_data,0,sizeof(_2pass_data));
+	_2pass_data.bquant_ratio=130;
+	_2pass_data.bquant_offset=100;
+	_2pass_data.version=FAKE_VERSION;
+
+	return 1;
+}
+
+uint8_t ADM_newXvidRc::getQz( uint32_t *qz, ADM_rframe *type )
+{
+	_2pass_data.frame_num=_nbFrames;
+	_2pass_data.quant=0;
+
+	rc_2pass2_before((rc_2pass2_t *)myHandle, &amp;_2pass_data);
+	*qz=_2pass_data.quant;
+
+	switch(_2pass_data.type)
+	{
+		case XVID_TYPE_IVOP:
+			*type=RF_I;
+			break;
+		case XVID_TYPE_PVOP:
+			*type=RF_P;
+			break;
+		case XVID_TYPE_BVOP:
+			*type=RF_B;
+			break;
+		default:
+			assert(0);
+	}
+
+	return 1;
+}
+uint8_t ADM_newXvidRc::logPass2( uint32_t qz, ADM_rframe ftype,uint32_t size)
+{
+	switch(ftype)
+	{
+		case RF_I:
+			_2pass_data.type=XVID_TYPE_IVOP;
+			break;
+		case RF_P:
+			_2pass_data.type=XVID_TYPE_PVOP;
+			break;
+		case RF_B:
+			_2pass_data.type=XVID_TYPE_BVOP;
+			break;
+		default:
+			assert(0);		
+	}
+
+	_2pass_data.quant=qz;
+	_2pass_data.length=size;
+	_2pass_data.frame_num=_nbFrames;
+
+	for(int i=0;i&lt;3;i++)
+	{
+		_2pass_data.min_quant[i]=2;
+		_2pass_data.max_quant[i]=31;
+
+	}
+
+	//rc_2pass2_after(rc_2pass2_t * rc, xvid_plg_data_t * data);
+	rc_2pass2_after((rc_2pass2_t *)myHandle,&amp;_2pass_data);
+	_nbFrames++;
+
+	return 1;
+}
+
+/*****************************************************************************
+* Sub plugin functions definitions
+****************************************************************************/
+
+/* First a few local helping function prototypes */
+
+
+/*----------------------------------------------------------------------------
+*--------------------------------------------------------------------------*/
+
+int
+rc_2pass2_create(xvid_plg_create_t * create, rc_2pass2_t **handle)
+{
+	xvid_plugin_2pass2_t * param = (xvid_plugin_2pass2_t *)create-&gt;param;
+	rc_2pass2_t * rc;
+	int i;
+
+	rc =(rc_2pass2_t *) malloc(sizeof(rc_2pass2_t));
+	if (rc == NULL)
+		return XVID_ERR_MEMORY;
+
+	/* v1.0.x */
+	rc-&gt;param.version = param-&gt;version;
+	rc-&gt;param.bitrate = param-&gt;bitrate;
+	rc-&gt;param.filename = param-&gt;filename;
+	rc-&gt;param.keyframe_boost = param-&gt;keyframe_boost;
+	rc-&gt;param.curve_compression_high = param-&gt;curve_compression_high;
+	rc-&gt;param.curve_compression_low = param-&gt;curve_compression_low;
+	rc-&gt;param.overflow_control_strength = param-&gt;overflow_control_strength;
+	rc-&gt;param.max_overflow_improvement = param-&gt;max_overflow_improvement;
+	rc-&gt;param.max_overflow_degradation = param-&gt;max_overflow_degradation;
+	rc-&gt;param.kfreduction = param-&gt;kfreduction;
+	rc-&gt;param.kfthreshold = param-&gt;kfthreshold;
+	rc-&gt;param.container_frame_overhead = param-&gt;container_frame_overhead;
+
+	if (XVID_VERSION_MINOR(param-&gt;version) &gt;= 1) {
+		rc-&gt;param.vbv_size = param-&gt;vbv_size;
+		rc-&gt;param.vbv_initial = param-&gt;vbv_initial;
+		rc-&gt;param.vbv_maxrate = param-&gt;vbv_maxrate;
+		rc-&gt;param.vbv_peakrate = param-&gt;vbv_peakrate;
+	}else{
+		rc-&gt;param.vbv_size =
+			rc-&gt;param.vbv_initial =
+			rc-&gt;param.vbv_maxrate =
+			rc-&gt;param.vbv_peakrate = 0;
+	}
+
+	/* Initialize all defaults */
+#define _INIT(a, b) if((a) &lt;= 0) (a) = (b)
+	/* Let's set our defaults if needed */
+	_INIT(rc-&gt;param.keyframe_boost, DEFAULT_KEYFRAME_BOOST);
+	_INIT(rc-&gt;param.overflow_control_strength, DEFAULT_OVERFLOW_CONTROL_STRENGTH);
+	_INIT(rc-&gt;param.curve_compression_high, DEFAULT_CURVE_COMPRESSION_HIGH);
+	_INIT(rc-&gt;param.curve_compression_low, DEFAULT_CURVE_COMPRESSION_LOW);
+	_INIT(rc-&gt;param.max_overflow_improvement, DEFAULT_MAX_OVERFLOW_IMPROVEMENT);
+	_INIT(rc-&gt;param.max_overflow_degradation,  DEFAULT_MAX_OVERFLOW_DEGRADATION);
+
+	/* Keyframe settings */
+	_INIT(rc-&gt;param.kfreduction, DEFAULT_KFREDUCTION);
+	_INIT(rc-&gt;param.kfthreshold, DEFAULT_KFTHRESHOLD);
+#undef _INIT
+
+	/* Initialize some stuff to zero */
+	for(i=0; i&lt;3; i++) {
+		int j;
+		for (j=0; j&lt;32; j++) {
+			rc-&gt;quant_error[i][j] = 0;
+			rc-&gt;quant_count[i][j] = 0;
+		}
+	}
+
+	for (i=0; i&lt;3; i++) rc-&gt;last_quant[i] = 0;
+
+	rc-&gt;fq_error = 0;
+	rc-&gt;min_quant = 1;
+
+	/* Count frames (and intra frames) in the stats file, store the result into
+	* the rc structure */
+	if (statsfile_count_frames(rc, param-&gt;filename) == -1) {
+		DPRINTF(XVID_DEBUG_RC,&quot;[xvid rc] -- ERROR: fopen %s failed\n&quot;, param-&gt;filename);
+		free(rc);
+		return(XVID_ERR_FAIL);
+	}
+	printf(&quot;[xvid rc] -- found %d frames %d keyframes\n&quot;,rc-&gt;num_frames,rc-&gt;num_keyframes);
+	/* Allocate the stats' memory */
+	if ((rc-&gt;stats =(twopass_stat_t *) malloc(rc-&gt;num_frames * sizeof(twopass_stat_t))) == NULL) {
+		free(rc);
+		return(XVID_ERR_MEMORY);
+	}
+
+	/* Allocate keyframes location's memory
+	* PS: see comment in pre_process0 for the +1 location requirement */
+	rc-&gt;keyframe_locations = (int *)malloc((rc-&gt;num_keyframes + 1) * sizeof(int));
+	if (rc-&gt;keyframe_locations == NULL) {
+		free(rc-&gt;stats);
+		free(rc);
+		return(XVID_ERR_MEMORY);
+	}
+
+	/* Load the first pass stats */
+	if (statsfile_load(rc, param-&gt;filename) == -1) {
+		DPRINTF(XVID_DEBUG_RC,&quot;[xvid rc] -- ERROR: fopen %s failed\n&quot;, param-&gt;filename);
+		free(rc-&gt;keyframe_locations);
+		free(rc-&gt;stats);
+		free(rc);
+		return XVID_ERR_FAIL;
+	}
+
+	/* Compute the target filesize */
+	if (rc-&gt;param.bitrate&lt;0) {
+		/* if negative, bitrate equals the target (in kbytes) */
+		rc-&gt;target = ((uint64_t)(-rc-&gt;param.bitrate)) * 1024;
+	} else if (rc-&gt;num_frames  &lt; create-&gt;fbase/create-&gt;fincr) {
+		/* Source sequence is less than 1s long, we do as if it was 1s long */
+		rc-&gt;target = rc-&gt;param.bitrate / 8;
+	} else {
+		/* Target filesize = bitrate/8 * numframes / framerate */
+		rc-&gt;target =
+			((uint64_t)rc-&gt;param.bitrate * (uint64_t)rc-&gt;num_frames * \
+			(uint64_t)create-&gt;fincr) / \
+			((uint64_t)create-&gt;fbase * 8);
+	}
+
+	DPRINTF(XVID_DEBUG_RC, &quot;[xvid rc] -- Frame rate: %d/%d (%ffps)\n&quot;,
+		create-&gt;fbase, create-&gt;fincr,
+		(double)create-&gt;fbase/(double)create-&gt;fincr);
+	DPRINTF(XVID_DEBUG_RC, &quot;[xvid rc] -- Number of frames: %d\n&quot;, rc-&gt;num_frames);
+	if(rc-&gt;param.bitrate&gt;=0)
+		DPRINTF(XVID_DEBUG_RC, &quot;[xvid rc] -- Target bitrate: %ld\n&quot;, rc-&gt;param.bitrate);
+	DPRINTF(XVID_DEBUG_RC, &quot;[xvid rc] -- Target filesize: %lld\n&quot;, rc-&gt;target);
+
+	/* Compensate the average frame overhead caused by the container */
+	rc-&gt;target -= rc-&gt;num_frames*rc-&gt;param.container_frame_overhead;
+	DPRINTF(XVID_DEBUG_RC, &quot;[xvid rc] -- Container Frame overhead: %d\n&quot;, rc-&gt;param.container_frame_overhead);
+	if(rc-&gt;param.container_frame_overhead)
+		DPRINTF(XVID_DEBUG_RC, &quot;[xvid rc] -- New target filesize after container compensation: %lld\n&quot;, rc-&gt;target);
+
+	/* When bitrate is not given it means it has been scaled by an external
+	* application */
+	if (rc-&gt;param.bitrate) {
+		/* Apply zone settings
+		* - set rc-&gt;tot_quant which represents the total num of bytes spent in
+		*   fixed quant zones
+		* - set rc-&gt;tot_weighted which represents the total amount of bytes
+		*   spent in normal or weighted zones in first pass (normal zones can
+		*   be considered weight=1)
+		* - set rc-&gt;tot_quant_invariant which represents the total num of bytes
+		*   spent in fixed quant zones for headers */
+		zone_process(rc, create);
+	} else {
+		/* External scaling -- zones are ignored */
+		for (i=0;i&lt;rc-&gt;num_frames;i++) {
+			rc-&gt;stats[i].zone_mode = XVID_ZONE_WEIGHT;
+			rc-&gt;stats[i].weight = 1.0;
+		}
+		rc-&gt;tot_quant = 0;
+	}
+
+	/* Gathers some information about first pass stats:
+	*  - finds the minimum frame length for each frame type during 1st pass.
+	*     rc-&gt;min_size[]
+	*  - determines the maximum frame length observed (no frame type distinction).
+	*     rc-&gt;max_size
+	*  - count how many times each frame type has been used.
+	*     rc-&gt;count[]
+	*  - total bytes used per frame type
+	*     rc-&gt;tot_length[]
+	*  - total bytes considered invariant between the 2 passes
+	*  - store keyframe location
+	*     rc-&gt;keyframe_locations[]
+	*/
+	first_pass_stats_prepare_data(rc);
+
+	/* If we have a user bitrate, it means it's an internal curve scaling */
+	if (rc-&gt;param.bitrate) {
+		/* Perform internal curve scaling */
+		first_pass_scale_curve_internal(rc);
+	}
+
+	/* Apply advanced curve options, and compute some parameters in order to
+	* shape the curve in the BEFORE/AFTER pair of functions */
+	scaled_curve_apply_advanced_parameters(rc);
+
+	/* Check curve for VBV compliancy and rescale if necessary */
+#ifdef VBV_FORCE
+	if (rc-&gt;param.vbv_size==0) {
+		rc-&gt;param.vbv_size      =  3145728;
+		rc-&gt;param.vbv_initial   =  2359296;
+		rc-&gt;param.vbv_maxrate  =  4000000;
+		rc-&gt;param.vbv_peakrate = 10000000;
+	}
+#endif
+
+	/* vbv_size==0 switches VBV check off */
+	if (rc-&gt;param.vbv_size &gt; 0)  {
+		const double fps = (double)create-&gt;fbase/(double)create-&gt;fincr;
+		int status = check_curve_for_vbv_compliancy(rc, fps);
+
+		if (status) {
+			DPRINTF(XVID_DEBUG_RC, &quot;[xvid rc] Underflow detected - Scaling Curve for compliancy.\n&quot;);
+		}
+
+		status = scale_curve_for_vbv_compliancy(rc, fps);
+
+		if (status == 0) {
+			DPRINTF(XVID_DEBUG_RC, &quot;[xvid rc] VBV compliant curve scaling done.\n&quot;);
+		} else {
+			DPRINTF(XVID_DEBUG_RC, &quot;[xvid rc] VBV compliant curve scaling impossible.\n&quot;);
+		}
+	}
+	*handle = rc;
+	return(0);
+}
+
+/*----------------------------------------------------------------------------
+*--------------------------------------------------------------------------*/
+
+int
+rc_2pass2_destroy(rc_2pass2_t * rc, xvid_plg_destroy_t * destroy)
+{
+	DPRINTF(XVID_DEBUG_RC, &quot;[xvid rc] -- target_total:%lld desired_total:%.2f (%.2f%%) actual_total:%.2f (%.2f%%)\n&quot;,
+		rc-&gt;target,
+		rc-&gt;desired_total,
+		100*rc-&gt;desired_total/(double)rc-&gt;target,
+		rc-&gt;real_total,
+		100*rc-&gt;real_total/(double)rc-&gt;target);
+
+	free(rc-&gt;keyframe_locations);
+	free(rc-&gt;stats);
+	free(rc);
+	return(0);
+}
+
+/*----------------------------------------------------------------------------
+*--------------------------------------------------------------------------*/
+
+int
+rc_2pass2_before(rc_2pass2_t * rc, xvid_plg_data_t * data)
+{
+	twopass_stat_t * s = &amp;rc-&gt;stats[data-&gt;frame_num];
+	static double dbytes=0;
+	double scaled_quant;
+	double overflow;
+	int capped_to_max_framesize = 0;
+
+	/* This function is quite long but easy to understand. In order to simplify
+	* the code path (a bit), we treat 3 cases that can return immediatly. */
+
+	/* First case: Another plugin has already set a quantizer */
+	if (data-&gt;quant &gt; 0)
+		return(0);
+
+	/* Second case: insufficent stats data
+	* We can't guess much what we should do, let core decide all alone */
+	if (data-&gt;frame_num &gt;= rc-&gt;num_frames) {
+		DPRINTF(XVID_DEBUG_RC,&quot;[xvid rc] -- stats file too short (now processing frame %d)&quot;,
+			data-&gt;frame_num);
+		return(0);
+	}
+
+	/* Third case: We are in a Quant zone
+	* Quant zones must just ensure we use the same settings as first pass
+	* So set the quantizer and the type */
+	if (s-&gt;zone_mode == XVID_ZONE_QUANT) {
+		/* Quant stuff */
+		rc-&gt;fq_error += s-&gt;weight;
+		data-&gt;quant = (int)rc-&gt;fq_error;
+		rc-&gt;fq_error -= data-&gt;quant;
+
+		/* The type stuff */
+		data-&gt;type = s-&gt;type;
+
+		/* The only required data for AFTER step is this one for the overflow
+		* control */
+		s-&gt;desired_length = s-&gt;length;
+
+		return(0);
+	}
+
+
+	/*************************************************************************/
+	/*************************************************************************/
+	/*************************************************************************/
+
+	/*-------------------------------------------------------------------------
+	* Frame bit allocation first part
+	*
+	* First steps apply user settings, just like it is done in the theoritical
+	* scaled_curve_apply_advanced_parameters
+	*-----------------------------------------------------------------------*/
+
+	/* Set desired to what we are wanting to obtain for this frame */
+	dbytes = (double)s-&gt;scaled_length;
+
+	/* IFrame user settings*/
+	if (s-&gt;type == XVID_TYPE_IVOP) {
+		/* Keyframe boosting -- All keyframes benefit from it */
+		dbytes += dbytes*rc-&gt;param.keyframe_boost / 100;
+
+#if 0 /* ToDo: decide how to apply kfthresholding */
+#endif
+	} else {
+
+		/* P/S/B frames must reserve some bits for iframe boosting */
+		dbytes *= rc-&gt;pb_iboost_tax_ratio;
+
+		/* Apply assymetric curve compression */
+		if (rc-&gt;param.curve_compression_high || rc-&gt;param.curve_compression_low) {
+			double assymetric_delta;
+
+			/* Compute the assymetric delta, this is computed before applying
+			* the tax, as done in the pre_process function */
+			if (dbytes &gt; rc-&gt;avg_length[s-&gt;type-1])
+				assymetric_delta = (rc-&gt;avg_length[s-&gt;type-1] - dbytes) * rc-&gt;param.curve_compression_high / 100.0;
+			else
+				assymetric_delta = (rc-&gt;avg_length[s-&gt;type-1] - dbytes) * rc-&gt;param.curve_compression_low  / 100.0;
+
+			/* Now we must apply the assymetric tax, else our curve compression
+			* would not give a theoritical target size equal to what it is
+			* expected */
+			dbytes *= rc-&gt;assymetric_tax_ratio;
+
+			/* Now we can add the assymetric delta */
+			dbytes += assymetric_delta;
+		}
+	}
+
+	/* That is what we would like to have -- Don't put that chunk after
+	* overflow control, otherwise, overflow is counted twice and you obtain
+	* half sized bitrate sequences */
+	s-&gt;desired_length  = (int)dbytes;
+	rc-&gt;desired_total += dbytes;
+
+	/*------------------------------------------------------------------------
+	* Frame bit allocation: overflow control part.
+	*
+	* Unlike the theoritical scaled_curve_apply_advanced_parameters, here
+	* it's real encoding and we need to make sure we don't go so far from
+	* what is our ideal scaled curve.
+	*-----------------------------------------------------------------------*/
+
+	/* Compute the overflow we should compensate */
+	if (s-&gt;type != XVID_TYPE_IVOP || rc-&gt;overflow &gt; 0) {
+		double frametype_factor;
+		double framesize_factor;
+
+		/* Take only the desired part of overflow */
+		overflow = rc-&gt;overflow;
+
+		/* Factor that will take care to decrease the overflow applied
+		* according to the importance of this frame type in term of
+		* overall size */
+		frametype_factor  = rc-&gt;count[XVID_TYPE_IVOP-1]*rc-&gt;avg_length[XVID_TYPE_IVOP-1];
+		frametype_factor += rc-&gt;count[XVID_TYPE_PVOP-1]*rc-&gt;avg_length[XVID_TYPE_PVOP-1];
+		frametype_factor += rc-&gt;count[XVID_TYPE_BVOP-1]*rc-&gt;avg_length[XVID_TYPE_BVOP-1];
+		frametype_factor /= rc-&gt;count[s-&gt;type-1]*rc-&gt;avg_length[s-&gt;type-1];
+		frametype_factor  = 1/frametype_factor;
+
+		/* Factor that will take care not to compensate too much for this frame
+		* size */
+		framesize_factor  = dbytes;
+		framesize_factor /= rc-&gt;avg_length[s-&gt;type-1];
+
+		/* Treat only the overflow part concerned by this frame type and size */
+		overflow *= frametype_factor;
+#if 0
+		/* Leave this one alone, as it impacts badly on quality */
+		overflow *= framesize_factor;
+#endif
+
+		/* Apply the overflow strength imposed by the user */
+		overflow *= (rc-&gt;param.overflow_control_strength/100.0f);
+	} else {
+		/* no negative overflow applied in IFrames because:
+		*  - their role is important as they're references for P/BFrames.
+		*  - there aren't much in typical sequences, so if an IFrame overflows too
+		*    much, this overflow may impact the next IFrame too much and generate
+		*    a sequence of poor quality frames */
+		overflow = 0;
+	}
+
+	/* Make sure we are not trying to compensate more overflow than we even have */
+	if (fabs(overflow) &gt; fabs(rc-&gt;overflow))
+		overflow = rc-&gt;overflow;
+
+	/* Make sure the overflow doesn't make the frame size to get out of the range
+	* [-max_degradation..+max_improvment] */
+	if (overflow &gt; dbytes*rc-&gt;param.max_overflow_improvement / 100) {
+		if(overflow &lt;= dbytes)
+			dbytes += dbytes * rc-&gt;param.max_overflow_improvement / 100;
+		else
+			dbytes += overflow * rc-&gt;param.max_overflow_improvement / 100;
+	} else if (overflow &lt; - dbytes * rc-&gt;param.max_overflow_degradation / 100) {
+		dbytes -= dbytes * rc-&gt;param.max_overflow_degradation / 100;
+	} else {
+		dbytes += overflow;
+	}
+
+	/*-------------------------------------------------------------------------
+	* Frame bit allocation last part:
+	*
+	* Cap frame length so we don't reach neither bigger frame sizes than first
+	* pass nor smaller than the allowed minimum.
+	*-----------------------------------------------------------------------*/
+
+#ifdef PASS_SMALLER
+	if (dbytes &gt; s-&gt;length) {
+		dbytes = s-&gt;length;
+	}
+#endif
+
+	/* Prevent stupid desired sizes under logical values */
+	if (dbytes &lt; rc-&gt;min_length[s-&gt;type-1]) {
+		dbytes = rc-&gt;min_length[s-&gt;type-1];
+	}
+
+	/*------------------------------------------------------------------------
+	* Desired frame length &lt;-&gt; quantizer mapping
+	*-----------------------------------------------------------------------*/
+	// Meanx
+	// For raw mpeg2 encoding access we will use bquant etc directly
+	// as for that, we do final=1squant*100/bquant_ratio+
+
+#ifdef BQUANT_PRESCALE 
+	if(s-&gt;type == XVID_TYPE_BVOP) {
+
+		twopass_stat_t *b_ref = s;
+
+		/* Find the reference frame */
+		while(b_ref != &amp;rc-&gt;stats[0] &amp;&amp; b_ref-&gt;type == XVID_TYPE_BVOP)
+			b_ref--;
+
+		/* Compute the original quant */
+		s-&gt;quant  = 2*(100*s-&gt;quant - data-&gt;bquant_offset);
+		s-&gt;quant += data-&gt;bquant_ratio - 1; /* to avoid rounding issues */
+		s-&gt;quant  = s-&gt;quant/data-&gt;bquant_ratio - b_ref-&gt;quant;
+	}
+
+#endif
+#ifdef MEANX_RESCALE
+	/* For bframes we prescale the quantizer to avoid too high quant scaling */
+	if(s-&gt;type == XVID_TYPE_BVOP) 
+	{
+		int newquant;
+
+		newquant=data-&gt;bquant_ratio*s-&gt;quant+data-&gt;bquant_offset;;
+		newquant/=100;
+
+		s-&gt;quant=newquant;		
+	}
+#endif
+
+	/* Don't laugh at this very 'simple' quant&lt;-&gt;size relationship, it
+	* proves to be acurate enough for our algorithm */
+	scaled_quant = (double)s-&gt;quant*(double)s-&gt;length/(double)dbytes;
+
+#ifdef COMPENSATE_FORMULA
+	/* We know xvidcore will apply the bframe formula again, so we compensate
+	* it right now to make sure we would not apply it twice */
+	if(s-&gt;type == XVID_TYPE_BVOP) {
+
+		twopass_stat_t *b_ref = s;
+
+		/* Find the reference frame */
+		while(b_ref != &amp;rc-&gt;stats[0] &amp;&amp; b_ref-&gt;type == XVID_TYPE_BVOP)
+			b_ref--;
+
+		/* Compute the quant it would be if the core did not apply the bframe
+		* formula */
+		scaled_quant  = 100*scaled_quant - data-&gt;bquant_offset;
+		scaled_quant += data-&gt;bquant_ratio - 1; /* to avoid rouding issues */
+		scaled_quant /= data-&gt;bquant_ratio;
+	}
+#endif
+
+	/* Quantizer has been scaled using floating point operations/results, we
+	* must cast it to integer */
+	data-&gt;quant = (int)scaled_quant;
+
+	/* Let's clip the computed quantizer, if needed */
+	if (data-&gt;quant &lt; 1) {
+		data-&gt;quant = 1;
+	} else if (data-&gt;quant &gt; 31) {
+		data-&gt;quant = 31;
+	} else {
+
+		/* The frame quantizer has not been clipped, this appears to be a good
+		* computed quantizer, do not loose quantizer decimal part that we
+		* accumulate for later reuse when its sum represents a complete
+		* unit. */
+		rc-&gt;quant_error[s-&gt;type-1][data-&gt;quant] += scaled_quant - (double)data-&gt;quant;
+
+		if (rc-&gt;quant_error[s-&gt;type-1][data-&gt;quant] &gt;= 1.0) {
+			rc-&gt;quant_error[s-&gt;type-1][data-&gt;quant] -= 1.0;
+			data-&gt;quant++;
+		} else if (rc-&gt;quant_error[s-&gt;type-1][data-&gt;quant] &lt;= -1.0) {
+			rc-&gt;quant_error[s-&gt;type-1][data-&gt;quant] += 1.0;
+			data-&gt;quant--;
+		}
+	}
+
+	/* Now we have a computed quant that is in the right quante range, with a
+	* possible +1 correction due to cumulated error. We can now safely clip
+	* the quantizer again with user's quant ranges. &quot;Safely&quot; means the Rate
+	* Control could learn more about this quantizer, this knowledge is useful
+	* for future frames even if it this quantizer won't be really used atm,
+	* that's why we don't perform this clipping earlier. */
+	if (data-&gt;quant &lt; data-&gt;min_quant[s-&gt;type-1]) {
+		data-&gt;quant = data-&gt;min_quant[s-&gt;type-1];
+	} else if (data-&gt;quant &gt; data-&gt;max_quant[s-&gt;type-1]) {
+		data-&gt;quant = data-&gt;max_quant[s-&gt;type-1];
+	}
+
+	if (data-&gt;quant &lt; rc-&gt;min_quant) data-&gt;quant = rc-&gt;min_quant;
+
+	/* To avoid big quality jumps from frame to frame, we apply a &quot;security&quot;
+	* rule that makes |last_quant - new_quant| &lt;= 2. This rule only applies
+	* to predicted frames (P and B) */
+	if (s-&gt;type != XVID_TYPE_IVOP &amp;&amp; rc-&gt;last_quant[s-&gt;type-1] &amp;&amp; capped_to_max_framesize == 0) {
+
+		if (data-&gt;quant &gt; rc-&gt;last_quant[s-&gt;type-1] + 2) {
+			data-&gt;quant = rc-&gt;last_quant[s-&gt;type-1] + 2;
+			DPRINTF(XVID_DEBUG_RC,
+				&quot;[xvid rc] -- frame %d p/b-frame quantizer prevented from rising too steeply\n&quot;,
+				data-&gt;frame_num);
+		}
+		if (data-&gt;quant &lt; rc-&gt;last_quant[s-&gt;type-1] - 2) {
+			data-&gt;quant = rc-&gt;last_quant[s-&gt;type-1] - 2;
+			DPRINTF(XVID_DEBUG_RC,
+				&quot;[xvid rc] -- frame:%d p/b-frame quantizer prevented from falling too steeply\n&quot;,
+				data-&gt;frame_num);
+		}
+	}
+
+	/* We don't want to pollute the RC histerisis when our computed quant has
+	* been computed from a capped frame size */
+	if (capped_to_max_framesize == 0)
+		rc-&gt;last_quant[s-&gt;type-1] = data-&gt;quant;
+
+	/* Don't forget to force 1st pass frame type ;-) */
+	data-&gt;type = s-&gt;type;
+
+	return 0;
+}
+
+/*----------------------------------------------------------------------------
+*--------------------------------------------------------------------------*/
+
+int
+rc_2pass2_after(rc_2pass2_t * rc, xvid_plg_data_t * data)
+{
+	const char frame_type[4] = { 'i', 'p', 'b', 's'};
+	twopass_stat_t * s = &amp;rc-&gt;stats[data-&gt;frame_num];
+
+	/* Insufficent stats data */
+	if (data-&gt;frame_num &gt;= rc-&gt;num_frames)
+		return 0;
+
+	/* Update the quantizer counter */
+	rc-&gt;quant_count[s-&gt;type-1][data-&gt;quant]++;
+
+	/* Update the frame type overflow */
+	if (data-&gt;type == XVID_TYPE_IVOP) {
+		int kfdiff = 0;
+
+		if(rc-&gt;KF_idx != rc-&gt;num_frames -1) {
+			kfdiff  = rc-&gt;keyframe_locations[rc-&gt;KF_idx+1];
+			kfdiff -= rc-&gt;keyframe_locations[rc-&gt;KF_idx];
+		}
+
+		/* Flush Keyframe overflow accumulator */
+		rc-&gt;overflow += rc-&gt;KFoverflow;
+
+		/* Store the frame overflow to the keyframe accumulator */
+		rc-&gt;KFoverflow = s-&gt;desired_length - data-&gt;length;
+
+		if (kfdiff &gt; 1) {
+			/* Non-consecutive keyframes case:
+			* We can then divide this total keyframe overflow into equal parts
+			* that we will distribute into regular overflow at each frame
+			* between the sequence bounded by two IFrames */
+			rc-&gt;KFoverflow_partial = rc-&gt;KFoverflow / (kfdiff - 1);
+		} else {
+			/* Consecutive keyframes case:
+			* Flush immediatly the keyframe overflow and reset keyframe
+			* overflow */
+			rc-&gt;overflow += rc-&gt;KFoverflow;
+			rc-&gt;KFoverflow = 0;
+			rc-&gt;KFoverflow_partial = 0;
+		}
+		rc-&gt;KF_idx++;
+	} else {
+		/* Accumulate the frame overflow */
+		rc-&gt;overflow += s-&gt;desired_length - data-&gt;length;
+
+		/* Distribute part of the keyframe overflow */
+		rc-&gt;overflow += rc-&gt;KFoverflow_partial;
+
+		/* Don't forget to substract that same amount from the total keyframe
+		* overflow */
+		rc-&gt;KFoverflow -= rc-&gt;KFoverflow_partial;
+	}
+
+	rc-&gt;overflow += (s-&gt;error = s-&gt;desired_length - data-&gt;length);
+	rc-&gt;real_total += data-&gt;length;
+
+	DPRINTF(XVID_DEBUG_RC, &quot;[xvid rc] -- frame:%d type:%c quant:%d stats:%d scaled:%d desired:%d actual:%d error:%d overflow:%.2f\n&quot;,
+		data-&gt;frame_num,
+		frame_type[data-&gt;type-1],
+		data-&gt;quant,
+		s-&gt;length,
+		s-&gt;scaled_length,
+		s-&gt;desired_length,
+		s-&gt;desired_length - s-&gt;error,
+		-s-&gt;error,
+		rc-&gt;overflow);
+
+	return(0);
+}
+
+void writeQuantStat(rc_2pass2_t * rc){
+	unsigned int i,j;
+	unsigned int sum,sum2,frames;
+	char str[strlen(rc-&gt;param.filename) + 4];
+	char *dot;
+	FILE *fd;
+	strcpy(str,rc-&gt;param.filename);
+	if( (dot = strrchr(str,'.')) ){
+		*dot = '\0';
+	}
+	strcat(str,&quot;.qs&quot;);
+	if( (fd=fopen(str,&quot;wb&quot;)) ){
+		sum2=frames=0;
+		for(j=2;j&lt;32;j++){
+			sum=0;
+			fprintf(fd,&quot;q%02u: &quot;,j);
+			for(i=0;i&lt;3;i++){
+				sum+=rc-&gt;quant_count[i][j];
+				fprintf(fd,&quot;%u: %6u &quot;,i,rc-&gt;quant_count[i][j]);
+			}
+			sum2+=sum*j;
+			frames+=sum;
+			fprintf(fd,&quot;sum: %6u\n&quot;,sum);
+		}
+		fprintf(fd,&quot;\nQuant over all: %2.2f\n&quot;,(float)sum2/(float)frames);
+		fclose(fd);
+	}
+}
+
+/*****************************************************************************
+* Helper functions definition
+****************************************************************************/
+
+/* Default buffer size for reading lines */
+#define BUF_SZ   1024
+
+/* Helper functions for reading/parsing the stats file */
+
+/* This function counts the number of frame entries in the stats file
+* It also counts the number of I Frames */
+int
+statsfile_count_frames(rc_2pass2_t * rc, char * filename)
+{
+	FILE * f;
+	char *line;
+	int lines;
+
+	rc-&gt;num_frames = 0;
+	rc-&gt;num_keyframes = 0;
+
+	if ((f = fopen(filename, &quot;rb&quot;)) == NULL)
+		return(-1);
+
+	lines = 0;
+	while ((line = readline(f)) != NULL) {
+
+		char *ptr;
+		char type;
+		int fields;
+
+		lines++;
+
+		/* We skip spaces */
+		ptr = skipspaces(line);
+
+		/* Skip coment lines or empty lines */
+		if(iscomment(ptr) || *ptr == '\0') {
+			free(line);
+			continue;
+		}
+
+		/* Read the stat line from buffer */
+		fields = sscanf(ptr, &quot;%c&quot;, &amp;type);
+
+		/* Valid stats files have at least 7 fields */
+		if (fields == 1) {
+			switch(type) {
+			case 'i':
+			case 'I':
+				rc-&gt;num_keyframes++;
+			case 'p':
+			case 'P':
+			case 'b':
+			case 'B':
+			case 's':
+			case 'S':
+				rc-&gt;num_frames++;
+				break;
+			default:
+				DPRINTF(XVID_DEBUG_RC,
+					&quot;[xvid rc] -- WARNING: L%d unknown frame type used (%c).\n&quot;,
+					lines, type);
+			}
+		} else {
+			DPRINTF(XVID_DEBUG_RC,
+				&quot;[xvid rc] -- WARNING: L%d misses some stat fields (%d).\n&quot;,
+				lines, 7-fields);
+		}
+
+		/* Free the line buffer */
+		free(line);
+	}
+
+	/* We are done with the file */
+	fclose(f);
+
+	return(0);
+}
+
+/* open stats file(s) and read into rc-&gt;stats array */
+int
+statsfile_load(rc_2pass2_t *rc, char * filename)
+{
+	FILE * f;
+	int processed_entries;
+
+	/* Opens the file */
+	if ((f = fopen(filename, &quot;rb&quot;))==NULL)
+		return(-1);
+
+	processed_entries = 0;
+	while(processed_entries &lt; rc-&gt;num_frames) {
+		char type;
+		int fields;
+		twopass_stat_t * s = &amp;rc-&gt;stats[processed_entries];
+		char *line, *ptr;
+
+		/* Read the line from the file */
+		if((line = readline(f)) == NULL)
+			break;
+
+		/* We skip spaces */
+		ptr = skipspaces(line);
+
+		/* Skip comment lines or empty lines */
+		if(iscomment(ptr) || *ptr == '\0') {
+			free(line);
+			continue;
+		}
+
+		/* Reset this field that is optional */
+		s-&gt;scaled_length = 0;
+
+		/* Convert the fields */
+		fields = sscanf(ptr,
+			&quot;%c %d %d %d %d %d %d %d\n&quot;,
+			&amp;type,
+			&amp;s-&gt;quant,
+			&amp;s-&gt;blks[0], &amp;s-&gt;blks[1], &amp;s-&gt;blks[2],
+			&amp;s-&gt;length, &amp;s-&gt;invariant /* not really yet */,
+			&amp;s-&gt;scaled_length);
+
+		/* Free line buffer, we don't need it anymore */
+		free(line);
+
+		/* Fail silently, this has probably been warned in
+		* statsfile_count_frames */
+		if(fields != 7 &amp;&amp; fields != 8)
+			continue;
+
+		/* Convert frame type and compute the invariant length part */
+		switch(type) {
+		case 'i':
+		case 'I':
+			s-&gt;type = XVID_TYPE_IVOP;
+			s-&gt;invariant /= INVARIANT_HEADER_PART_IVOP;
+			break;
+		case 'p':
+		case 'P':
+		case 's':
+		case 'S':
+			s-&gt;type = XVID_TYPE_PVOP;
+			s-&gt;invariant /= INVARIANT_HEADER_PART_PVOP;
+			break;
+		case 'b':
+		case 'B':
+			s-&gt;type = XVID_TYPE_BVOP;
+			s-&gt;invariant /= INVARIANT_HEADER_PART_BVOP;
+			break;
+		default:
+			/* Same as before, fail silently */
+			continue;
+		}
+
+		/* Ok it seems it's been processed correctly */
+		processed_entries++;
+	}
+
+	/* Close the file */
+	fclose(f);
+
+	return(0);
+}
+
+/* pre-process the statistics data
+* - for each type, count, tot_length, min_length, max_length
+* - set keyframes_locations, tot_prescaled */
+void
+first_pass_stats_prepare_data(rc_2pass2_t * rc)
+{
+	int i,j;
+
+	/* *rc fields initialization
+	* NB: INT_MAX and INT_MIN are used in order to be immediately replaced
+	*     with real values of the 1pass */
+	for (i=0; i&lt;3; i++) {
+		rc-&gt;count[i]=0;
+		rc-&gt;tot_length[i] = 0;
+		rc-&gt;tot_invariant[i] = 0;
+		rc-&gt;min_length[i] = INT_MAX;
+	}
+
+	rc-&gt;max_length = INT_MIN;
+	rc-&gt;tot_weighted = 0;
+
+	/* Loop through all frames and find/compute all the stuff this function
+	* is supposed to do */
+	for (i=j=0; i&lt;rc-&gt;num_frames; i++) {
+		twopass_stat_t * s = &amp;rc-&gt;stats[i];
+
+		rc-&gt;count[s-&gt;type-1]++;
+		rc-&gt;tot_length[s-&gt;type-1] += s-&gt;length;
+		rc-&gt;tot_invariant[s-&gt;type-1] += s-&gt;invariant;
+		if (s-&gt;zone_mode != XVID_ZONE_QUANT)
+			rc-&gt;tot_weighted += (int)(s-&gt;weight*(s-&gt;length - s-&gt;invariant));
+
+		if (s-&gt;length &lt; rc-&gt;min_length[s-&gt;type-1]) {
+			rc-&gt;min_length[s-&gt;type-1] = s-&gt;length;
+		}
+
+		if (s-&gt;length &gt; rc-&gt;max_length) {
+			rc-&gt;max_length = s-&gt;length;
+		}
+
+		if (s-&gt;type == XVID_TYPE_IVOP) {
+			rc-&gt;keyframe_locations[j] = i;
+			j++;
+		}
+	}
+
+	/* NB:
+	* The &quot;per sequence&quot; overflow system considers a natural sequence to be
+	* formed by all frames between two iframes, so if we want to make sure
+	* the system does not go nuts during last sequence, we force the last
+	* frame to appear in the keyframe locations array. */
+	rc-&gt;keyframe_locations[j] = i;
+
+	DPRINTF(XVID_DEBUG_RC, &quot;[xvid rc] -- Min 1st pass IFrame length: %d\n&quot;, rc-&gt;min_length[0]);
+	DPRINTF(XVID_DEBUG_RC, &quot;[xvid rc] -- Min 1st pass PFrame length: %d\n&quot;, rc-&gt;min_length[1]);
+	DPRINTF(XVID_DEBUG_RC, &quot;[xvid rc] -- Min 1st pass BFrame length: %d\n&quot;, rc-&gt;min_length[2]);
+}
+
+/* calculate zone weight &quot;center&quot; */
+void
+zone_process(rc_2pass2_t *rc, const xvid_plg_create_t * create)
+{
+	int i,j;
+	int n = 0;
+
+	rc-&gt;tot_quant = 0;
+	rc-&gt;tot_quant_invariant = 0;
+
+	if (create-&gt;num_zones == 0) {
+		for (j = 0; j &lt; rc-&gt;num_frames; j++) {
+			rc-&gt;stats[j].zone_mode = XVID_ZONE_WEIGHT;
+			rc-&gt;stats[j].weight = 1.0;
+		}
+		n += rc-&gt;num_frames;
+	}
+
+
+	for(i=0; i &lt; create-&gt;num_zones; i++) {
+
+		int next = (i+1&lt;create-&gt;num_zones) ? create-&gt;zones[i+1].frame : rc-&gt;num_frames;
+
+		/* Zero weight make no sense */
+		if (create-&gt;zones[i].increment == 0) create-&gt;zones[i].increment = 1;
+		/* And obviously an undetermined infinite makes even less sense */
+		if (create-&gt;zones[i].base == 0) create-&gt;zones[i].base = 1;
+
+		if (i==0 &amp;&amp; create-&gt;zones[i].frame &gt; 0) {
+			for (j = 0; j &lt; create-&gt;zones[i].frame &amp;&amp; j &lt; rc-&gt;num_frames; j++) {
+				rc-&gt;stats[j].zone_mode = XVID_ZONE_WEIGHT;
+				rc-&gt;stats[j].weight = 1.0;
+			}
+			n += create-&gt;zones[i].frame;
+		}
+
+		if (create-&gt;zones[i].mode == XVID_ZONE_WEIGHT) {
+			for (j = create-&gt;zones[i].frame; j &lt; next &amp;&amp; j &lt; rc-&gt;num_frames; j++ ) {
+				rc-&gt;stats[j].zone_mode = XVID_ZONE_WEIGHT;
+				rc-&gt;stats[j].weight = (double)create-&gt;zones[i].increment / (double)create-&gt;zones[i].base;
+			}
+			next -= create-&gt;zones[i].frame;
+			n += next;
+		} else{  /* XVID_ZONE_QUANT */
+			for (j = create-&gt;zones[i].frame; j &lt; next &amp;&amp; j &lt; rc-&gt;num_frames; j++ ) {
+				rc-&gt;stats[j].zone_mode = XVID_ZONE_QUANT;
+				rc-&gt;stats[j].weight = (double)create-&gt;zones[i].increment / (double)create-&gt;zones[i].base;
+				rc-&gt;tot_quant += rc-&gt;stats[j].length;
+				rc-&gt;tot_quant_invariant += rc-&gt;stats[j].invariant;
+			}
+		}
+	}
+}
+
+
+/* scale the curve */
+void
+first_pass_scale_curve_internal(rc_2pass2_t *rc)
+{
+	int64_t target;
+	int64_t total_invariant;
+	double scaler;
+	int i, num_MBs;
+
+	/* We only scale texture data ! */
+	total_invariant	 = rc-&gt;tot_invariant[XVID_TYPE_IVOP-1];
+	total_invariant += rc-&gt;tot_invariant[XVID_TYPE_PVOP-1];
+	total_invariant += rc-&gt;tot_invariant[XVID_TYPE_BVOP-1];
+	/* don't forget to substract header bytes used in quant zones, otherwise we
+	* counting them twice */
+	total_invariant -= rc-&gt;tot_quant_invariant;
+
+	/* We remove the bytes used by the fixed quantizer zones during first pass
+	* with the same quants, so we know very precisely how much that
+	* represents */
+	target	= rc-&gt;target;
+	target -= rc-&gt;tot_quant;
+
+	/* Let's compute a linear scaler in order to perform curve scaling */
+	scaler = (double)(target - total_invariant) / (double)(rc-&gt;tot_weighted);
+
+#ifdef SMART_OVERFLOW_SETTING
+	if (scaler &gt; 0.9) {
+		rc-&gt;param.max_overflow_degradation *= 5;
+		rc-&gt;param.max_overflow_improvement *= 5;
+		rc-&gt;param.overflow_control_strength *= 3;
+	} else if (scaler &gt; 0.6) {
+		rc-&gt;param.max_overflow_degradation *= 2;
+		rc-&gt;param.max_overflow_improvement *= 2;
+		rc-&gt;param.overflow_control_strength *= 2;
+	} else {
+		rc-&gt;min_quant = 2;
+	}
+#endif
+
+	/* Compute min frame lengths (for each frame type) according to the number
+	* of MBs. We sum all block type counters of frame 0, this gives us the
+	* number of MBs.
+	*
+	* We compare these hardcoded values with observed values in first pass
+	* (determined in pre_process0).Then we keep the real minimum. */
+
+	/* Number of MBs */
+	num_MBs  = rc-&gt;stats[0].blks[0];
+	num_MBs += rc-&gt;stats[0].blks[1];
+	num_MBs += rc-&gt;stats[0].blks[2];
+
+	/* Minimum for I frames */
+	if(rc-&gt;min_length[XVID_TYPE_IVOP-1] &gt; ((num_MBs*22) + 240) / 8)
+		rc-&gt;min_length[XVID_TYPE_IVOP-1] = ((num_MBs*22) + 240) / 8;
+
+	/* Minimum for P/S frames */
+	if(rc-&gt;min_length[XVID_TYPE_PVOP-1] &gt; ((num_MBs) + 88)  / 8)
+		rc-&gt;min_length[XVID_TYPE_PVOP-1] = ((num_MBs) + 88)  / 8;
+
+	/* Minimum for B frames */
+	if(rc-&gt;min_length[XVID_TYPE_BVOP-1] &gt; 8)
+		rc-&gt;min_length[XVID_TYPE_BVOP-1] = 8;
+
+	/* Perform an initial scale pass.
+	*
+	* If a frame size is scaled underneath our hardcoded minimums, then we
+	* force the frame size to the minimum, and deduct the original &amp; scaled
+	* frame length from the original and target total lengths */
+	for (i=0; i&lt;rc-&gt;num_frames; i++) {
+		twopass_stat_t * s = &amp;rc-&gt;stats[i];
+		int len;
+
+		/* No need to scale frame length for which a specific quantizer is
+		* specified thanks to zones */
+		if (s-&gt;zone_mode == XVID_ZONE_QUANT) {
+			s-&gt;scaled_length = s-&gt;length;
+			continue;
+		}
+
+		/* Compute the scaled length -- only non invariant data length is scaled */
+		len = s-&gt;invariant + (int)((double)(s-&gt;length-s-&gt;invariant) * scaler * s-&gt;weight);
+
+		/* Compare with the computed minimum */
+		if (len &lt; rc-&gt;min_length[s-&gt;type-1]) {
+			/* This is a 'forced size' frame, set its frame size to the
+			* computed minimum */
+			s-&gt;scaled_length = rc-&gt;min_length[s-&gt;type-1];
+
+			/* Remove both scaled and original size from their respective
+			* total counters, as we prepare a second pass for 'regular'
+			* frames */
+			target -= s-&gt;scaled_length;
+		} else {
+			/* Do nothing for now, we'll scale this later */
+			s-&gt;scaled_length = 0;
+		}
+	}
+
+	/* The first pass on data substracted all 'forced size' frames from the
+	* total counters. Now, it's possible to scale the 'regular' frames. */
+
+	/* Scaling factor for 'regular' frames */
+	scaler = (double)(target - total_invariant) / (double)(rc-&gt;tot_weighted);
+
+	/* Do another pass with the new scaler */
+	for (i=0; i&lt;rc-&gt;num_frames; i++) {
+		twopass_stat_t * s = &amp;rc-&gt;stats[i];
+
+		/* Ignore frame with forced frame sizes */
+		if (s-&gt;scaled_length == 0)
+			s-&gt;scaled_length = s-&gt;invariant + (int)((double)(s-&gt;length-s-&gt;invariant) * scaler * s-&gt;weight);
+	}
+
+	/* Job done */
+	return;
+}
+
+/* Apply all user settings to the scaled curve
+* This implies:
+*   keyframe boosting
+*   high/low compression */
+void
+scaled_curve_apply_advanced_parameters(rc_2pass2_t * rc)
+{
+	int i;
+	int64_t ivop_boost_total;
+
+	/* Reset the rate controller (per frame type) total byte counters */
+	for (i=0; i&lt;3; i++) rc-&gt;tot_scaled_length[i] = 0;
+
+	/* Compute total bytes for each frame type */
+	for (i=0; i&lt;rc-&gt;num_frames;i++) {
+		twopass_stat_t *s = &amp;rc-&gt;stats[i];
+		rc-&gt;tot_scaled_length[s-&gt;type-1] += s-&gt;scaled_length;
+	}
+
+	/* First we compute the total amount of bits needed, as being described by
+	* the scaled distribution. During this pass over the complete stats data,
+	* we see how much bits two user settings will get/give from/to p&amp;b frames:
+	*  - keyframe boosting
+	*  - keyframe distance penalty */
+	rc-&gt;KF_idx = 0;
+	ivop_boost_total = 0;
+	for (i=0; i&lt;rc-&gt;num_frames; i++) {
+		twopass_stat_t * s = &amp;rc-&gt;stats[i];
+
+		/* Some more work is needed for I frames */
+		if (s-&gt;type == XVID_TYPE_IVOP) {
+			int ivop_boost;
+
+			/* Accumulate bytes needed for keyframe boosting */
+			ivop_boost = s-&gt;scaled_length*rc-&gt;param.keyframe_boost/100;
+
+#if 0 /* ToDo: decide how to apply kfthresholding */
+#endif
+			/* If the frame size drops under the minimum length, then cap ivop_boost */
+			if (ivop_boost + s-&gt;scaled_length &lt; rc-&gt;min_length[XVID_TYPE_IVOP-1])
+				ivop_boost = rc-&gt;min_length[XVID_TYPE_IVOP-1] - s-&gt;scaled_length;
+
+			/* Accumulate the ivop boost */
+			ivop_boost_total += ivop_boost;
+
+			/* Don't forget to update the keyframe index */
+			rc-&gt;KF_idx++;
+		}
+	}
+
+	/* Initialize the IBoost tax ratio for P/S/B frames
+	*
+	* This ratio has to be applied to p/b/s frames in order to reserve
+	* additional bits for keyframes (keyframe boosting) or if too much
+	* keyframe distance is applied, bits retrieved from the keyframes.
+	*
+	* ie pb_length *= rc-&gt;pb_iboost_tax_ratio;
+	*
+	*    gives the ideal length of a p/b frame */
+
+	/* Compute the total length of p/b/s frames (temporary storage into
+	* movie_curve) */
+	rc-&gt;pb_iboost_tax_ratio  = (double)rc-&gt;tot_scaled_length[XVID_TYPE_PVOP-1];
+	rc-&gt;pb_iboost_tax_ratio += (double)rc-&gt;tot_scaled_length[XVID_TYPE_BVOP-1];
+
+	/* Compute the ratio described above
+	*     taxed_total = sum(0, n, tax*scaled_length)
+	* &lt;=&gt; taxed_total = tax.sum(0, n, scaled_length)
+	* &lt;=&gt; tax = taxed_total / original_total */
+	rc-&gt;pb_iboost_tax_ratio =
+		(rc-&gt;pb_iboost_tax_ratio - ivop_boost_total) /
+		rc-&gt;pb_iboost_tax_ratio;
+
+	DPRINTF(XVID_DEBUG_RC, &quot;[xvid rc] -- IFrame boost tax ratio:%.2f\n&quot;,
+		rc-&gt;pb_iboost_tax_ratio);
+
+	/* Compute the average size of frames per frame type */
+	for(i=0; i&lt;3; i++) {
+		/* Special case for missing type or weird case */
+		if (rc-&gt;count[i] == 0 || rc-&gt;pb_iboost_tax_ratio == 0) {
+			rc-&gt;avg_length[i] = 1;
+		} else {
+			rc-&gt;avg_length[i] = rc-&gt;tot_scaled_length[i];
+
+			if (i == (XVID_TYPE_IVOP-1)) {
+				/* I Frames total has to be added the boost total */
+				rc-&gt;avg_length[i] += ivop_boost_total;
+			} else {
+				/* P/B frames has to taxed */
+				rc-&gt;avg_length[i] *= rc-&gt;pb_iboost_tax_ratio;
+			}
+
+			/* Finally compute the average frame size */
+			rc-&gt;avg_length[i] /= (double)rc-&gt;count[i];
+		}
+	}
+
+	/* Assymetric curve compression */
+	if (rc-&gt;param.curve_compression_high || rc-&gt;param.curve_compression_low) {
+		double symetric_total;
+		double assymetric_delta_total;
+
+		/* Like I frame boosting, assymetric curve compression modifies the total
+		* amount of needed bits, we must compute the ratio so we can prescale
+		lengths */
+		symetric_total = 0;
+		assymetric_delta_total = 0;
+		for (i=0; i&lt;rc-&gt;num_frames; i++) {
+			double assymetric_delta;
+			double dbytes;
+			twopass_stat_t * s = &amp;rc-&gt;stats[i];
+
+			/* I Frames are not concerned by assymetric scaling */
+			if (s-&gt;type == XVID_TYPE_IVOP)
+				continue;
+
+			/* During the real run, we would have to apply the iboost tax */
+			dbytes = s-&gt;scaled_length * rc-&gt;pb_iboost_tax_ratio;
+
+			/* Update the symmetric curve compression total */
+			symetric_total += dbytes;
+
+			/* Apply assymetric curve compression */
+			if (dbytes &gt; rc-&gt;avg_length[s-&gt;type-1])
+				assymetric_delta = (rc-&gt;avg_length[s-&gt;type-1] - dbytes) * (double)rc-&gt;param.curve_compression_high / 100.0f;
+			else
+				assymetric_delta = (rc-&gt;avg_length[s-&gt;type-1] - dbytes) * (double)rc-&gt;param.curve_compression_low  / 100.0f;
+
+			/* Cap to the minimum frame size if needed */
+			if (dbytes + assymetric_delta &lt; rc-&gt;min_length[s-&gt;type-1])
+				assymetric_delta = rc-&gt;min_length[s-&gt;type-1] - dbytes;
+
+			/* Accumulate after assymetric curve compression */
+			assymetric_delta_total += assymetric_delta;
+		}
+
+		/* Compute the tax that all p/b frames have to pay in order to respect the
+		* bit distribution changes that the assymetric compression curve imposes
+		* We want assymetric_total = sum(0, n-1, tax.scaled_length)
+		*      ie assymetric_total = ratio.sum(0, n-1, scaled_length)
+		*         ratio = assymetric_total / symmetric_total */
+		rc-&gt;assymetric_tax_ratio = ((double)symetric_total - (double)assymetric_delta_total) / (double)symetric_total;
+	} else {
+		rc-&gt;assymetric_tax_ratio = 1.0f;
+	}
+
+	DPRINTF(XVID_DEBUG_RC, &quot;[xvid rc] -- Assymetric tax ratio:%.2f\n&quot;, rc-&gt;assymetric_tax_ratio);
+
+	/* Last bits that need to be reset */
+	rc-&gt;overflow = 0;
+	rc-&gt;KFoverflow = 0;
+	rc-&gt;KFoverflow_partial = 0;
+	rc-&gt;KF_idx = 0;
+	rc-&gt;desired_total = 0;
+	rc-&gt;real_total = 0;
+
+	/* Job done */
+	return;
+}
+
+/*****************************************************************************
+* VBV compliancy check and scale
+* MPEG-4 standard specifies certain restrictions for bitrate/framesize in VBR
+* to enable playback on devices with limited readspeed and memory (and which
+* aren't...)
+*
+* DivX profiles have 2 criteria: VBV as in MPEG standard
+*                                a limit on peak bitrate for any 3 seconds
+*
+* But if VBV is fulfilled, peakrate is automatically fulfilled in any profile
+* define so far, so we check for it (for completeness) but correct only VBV
+*
+*****************************************************************************/
+
+#define VBV_COMPLIANT 0
+#define VBV_UNDERFLOW 1 /* video buffer runs empty */
+#define VBV_OVERFLOW 2  /* doesn't exist for VBR encoding */
+#define VBV_PEAKRATE 4  /* peak bitrate (within 3s) violated */
+
+int
+check_curve_for_vbv_compliancy(rc_2pass2_t * rc, const float fps)
+{
+	/* We do all calculations in float, for higher accuracy,
+	* and in bytes for convenience.
+	*
+	* typical values from DivX Home Theater profile:
+	*  vbv_size= 384*1024 (384kB)
+	*  vbv_initial= 288*1024 (75% fill)
+	*  maxrate= 4000000 (4MBps)
+	*  peakrate= 10000000 (10MBps)
+	*
+	*  PAL: offset3s = 75 (3 seconds of 25fps)
+	*  NTSC: offset3s = 90 (3 seconds of 29.97fps) or 72 (3 seconds of 23.976fps)
+	*/
+
+	const float vbv_size = (float)rc-&gt;param.vbv_size/8.f;
+	float vbvfill = (float)rc-&gt;param.vbv_initial/8.f;
+	float vbvmin;
+
+	const float maxrate = (float)rc-&gt;param.vbv_maxrate;
+	const float peakrate = (float)rc-&gt;param.vbv_peakrate;
+	const float r0 = (int)(maxrate/fps+0.5)/8.f;
+
+	int bytes3s = 0;
+	int offset3s = (int)(3.f*fps+0.5);
+	int i;
+
+	/* 1Gbit should be enough to inuitialize the vbvmin
+	*	an arbitrary high value */
+	vbvmin = 1000*1000*1000;
+
+	for (i=0; i&lt;rc-&gt;num_frames; i++) {
+		/* DivX 3s peak bitrate check  */
+		bytes3s += rc-&gt;stats[i].scaled_length;
+		if (i&gt;=offset3s)
+			bytes3s -= rc-&gt;stats[i-offset3s].scaled_length;
+
+		if (8.f*bytes3s &gt; 3*peakrate)
+			return(VBV_PEAKRATE);
+
+		/* update vbv fill level */
+		vbvfill += r0 - rc-&gt;stats[i].scaled_length;
+
+		/* this check is _NOT_ an &quot;overflow&quot;! only reading from disk stops then */
+		if (vbvfill &gt; vbv_size)
+			vbvfill = vbv_size;
+
+		/* but THIS would be an underflow. report it! */
+		if (vbvfill &lt; 0)
+			return(VBV_UNDERFLOW);
+
+		/* Store the minimum buffer filling */
+		if (vbvfill &lt; vbvmin)
+			vbvmin = vbvfill;
+	}
+
+	DPRINTF(XVID_DEBUG_RC, &quot;[xvid rc] Minimum buffer fill: %f bytes\n&quot;, vbvmin);
+
+	return(VBV_COMPLIANT);
+}
+
+
+int
+scale_curve_for_vbv_compliancy(rc_2pass2_t * rc, const float fps)
+{
+	/* correct any VBV violations. Peak bitrate violations disappears
+	* by this automatically
+	*
+	* This implementation follows
+	*
+	* Westerink, Rajagopalan, Gonzales &quot;Two-pass MPEG-2 variable-bitrate encoding&quot;
+	* IBM J. RES. DEVELOP. VOL 43, No. 4, July 1999, p.471--488
+	*
+	* Thanks, guys! This paper rocks!!! */
+
+	/* For each scene of len N, we have to check up to N^2 possible buffer fills.
+	* This works well with MPEG-2 where N==12 or so, but for MPEG-4 it's a
+	* little slow...
+	*
+	* TODO: Better control on VBVfill between scenes */
+
+	const float vbv_size = (float)rc-&gt;param.vbv_size/8.f;
+	const float vbv_initial = (float)rc-&gt;param.vbv_initial/8.f;
+
+	const float maxrate = 0.9*rc-&gt;param.vbv_maxrate;
+	const float vbv_low = 0.10f*vbv_size;
+	const float r0 = (int)(maxrate/fps+0.5)/8.f;
+
+	int i,k,l,n,violation = 0;
+	float *scenefactor;
+	int *scenestart;
+	int *scenelength;
+
+	/* first step: determine how many &quot;scenes&quot; there are and store their
+	* boundaries we could get all this from existing keyframe_positions,
+	* somehow, but there we don't have a min_scenelength, and it's no big
+	* deal to get it again. */
+
+	const int min_scenelength = (int)(fps+0.5);
+	int num_scenes = 0;
+	int last_scene = -999;
+	for (i=0; i&lt;rc-&gt;num_frames; i++) {
+		if ((rc-&gt;stats[i].type == XVID_TYPE_IVOP) &amp;&amp; (i-last_scene&gt;min_scenelength)) {
+			last_scene = i;
+			num_scenes++;
+		}
+	}
+
+	scenefactor = (float*)malloc(num_scenes*sizeof(float));
+	scenestart = (int*)malloc(num_scenes*sizeof(int));
+	scenelength = (int*)malloc(num_scenes*sizeof(int));
+
+	if ((!scenefactor) || (!scenestart) || (!scenelength) ) {
+		free(scenefactor);
+		free(scenestart);
+		free(scenelength);
+		/* remember: free(0) is valid and does exactly nothing. */
+		return(-1);
+	}
+
+	/* count again and safe the length/position */
+
+	num_scenes = 0;
+	last_scene = -999;
+	for (i=0; i&lt;rc-&gt;num_frames; i++) {
+		if ((rc-&gt;stats[i].type == XVID_TYPE_IVOP) &amp;&amp; (i-last_scene&gt;min_scenelength)) {
+			if (num_scenes&gt;0) {
+				scenelength[num_scenes-1]=i-last_scene;
+			}
+			scenestart[num_scenes]=i;
+			num_scenes++;
+			last_scene = i;
+		}
+	}
+	scenelength[num_scenes-1]=i-last_scene;
+
+	/* second step: check for each scene, how much we can scale its frames up or
+	* down such that the VBV restriction is just fulfilled */
+#define R(k,n) (((n)+1-(k))*r0)     /* how much enters the buffer between frame k and n */
+	for (l=0; l&lt;num_scenes;l++) {
+		const int start = scenestart[l];
+		const int length = scenelength[l];
+		twopass_stat_t * frames = &amp;rc-&gt;stats[start];
+
+		float S0n,Skn;
+		float f,minf = 99999.f;
+
+		S0n=0.;
+		for (n=0;n&lt;=length-1;n++) {
+			S0n += frames[n].scaled_length;
+
+			k = 0;
+			Skn = S0n;
+			f = (R(k,n-1) + (vbv_initial - vbv_low)) / Skn;
+			if (f &lt; minf)
+				minf = f;
+
+			for (k=1;k&lt;=n;k++) {
+				Skn -= frames[k].scaled_length;
+
+				f = (R(k,n-1) + (vbv_size - vbv_low)) / Skn;
+				if (f &lt; minf)
+					minf = f;
+			}
+		}
+
+		/* special case: at the end, fill buffer up to vbv_initial again
+		*
+		* TODO: Allow other values for buffer fill between scenes
+		* e.g. if n=N is smallest f-value, then check for better value */
+
+		n=length;
+		k=0;
+		Skn = S0n;
+		f = R(k,n-1)/Skn;
+		if (f &lt; minf)
+			minf = f;
+
+		for (k=1;k&lt;=n-1;k++) {
+			Skn -= frames[k].scaled_length;
+
+			f = (R(k,n-1) + (vbv_initial - vbv_low)) / Skn;
+			if (f &lt; minf)
+				minf = f;
+		}
+
+		DPRINTF(XVID_DEBUG_RC, &quot;[xvid rc] Scene %d (Frames %d-%d): VBVfactor %f\n&quot;,
+			l, start, start+length-1 , minf);
+
+		scenefactor[l] = minf;
+	}
+#undef R
+
+	/* last step: now we know of any scene how much it can be scaled up or down
+	* without violating VBV. Next, distribute bits from the evil scenes to the
+	* good ones */
+	do {
+		float S_red = 0.f;    /* how much to redistribute */
+		float S_elig = 0.f;   /* sum of bit for those scenes you can still swallow something*/
+		float f_red;
+		int l;
+
+		/* check how much is wrong */
+		for (l=0;l&lt;num_scenes;l++) {
+			const int start = scenestart[l];
+			const int length = scenelength[l];
+			twopass_stat_t * frames = &amp;rc-&gt;stats[start];
+
+			/* exactly 1 means &quot;don't touch this anymore!&quot; */
+			if (scenefactor[l] == 1.)
+				continue;
+
+			/* within limits */
+			if (scenefactor[l] &gt; 1.) {
+				for (n= 0; n &lt; length; n++)
+					S_elig += frames[n].scaled_length;
+			} else {
+				/* underflowing segment */
+				for (n= 0; n &lt; length; n++) {
+					float newbytes = (float)frames[n].scaled_length * scenefactor[l];
+					S_red += (float)frames[n].scaled_length - (float)newbytes;
+					frames[n].scaled_length =(int)newbytes;
+				}
+				scenefactor[l] = 1.f;
+			}
+		}
+
+		/* no more underflows */
+		if (S_red &lt; 1.f)
+			break;
+
+		if (S_elig &lt; 1.f) {
+			DPRINTF(XVID_DEBUG_RC, &quot;[xvid rc] Everything underflowing.\n&quot;);
+			free(scenefactor);
+			free(scenestart);
+			free(scenelength);
+			return(-2);
+		}
+
+		f_red = (1.f + S_red/S_elig);
+
+		DPRINTF(XVID_DEBUG_RC, &quot;[xvid rc] Moving %.0f kB to avoid buffer underflow, correction factor: %.5f\n&quot;,
+			S_red/1024.f, f_red);
+
+		violation=0;
+		/* scale remaining scenes up to meet total size */
+		for (l=0; l&lt;num_scenes; l++) {
+			const int start = scenestart[l];
+			const int length = scenelength[l];
+			twopass_stat_t * frames = &amp;rc-&gt;stats[start];
+
+			if (scenefactor[l] == 1.)
+				continue;
+
+			/* there shouldn't be any segments with factor&lt;1 left, so all the rest is &gt;1 */
+			for (n= 0; n &lt; length; n++) {
+				frames[n].scaled_length = (int)(frames[n].scaled_length * f_red + 0.5);
+			}
+
+			scenefactor[l] /= f_red;
+			if (scenefactor[l] &lt; 1.f)
+				violation=1;
+		}
+
+	} while (violation);
+
+	free(scenefactor);
+	free(scenestart);
+	free(scenelength);
+	return(0);
+}
+
+
+/*****************************************************************************
+* Still more low level stuff (nothing to do with stats treatment)
+****************************************************************************/
+
+/* This function returns an allocated string containing a complete line read
+* from the file starting at the current position */
+char *
+readline(FILE *f)
+{
+	char *buffer = NULL;
+	int buffer_size = 0;
+	int pos = 0;
+
+	do {
+		int c;
+
+		/* Read a character from the stream */
+		c = fgetc(f);
+
+		/* Is that EOF or new line ? */
+		if(c == EOF || c == '\n')
+			break;
+
+		/* Do we have to update buffer ? */
+		if(pos &gt;= buffer_size - 1) {
+			buffer_size += BUF_SZ;
+			buffer = (char*)realloc(buffer, buffer_size);
+			if (buffer == NULL)
+				return(NULL);
+		}
+
+		buffer[pos] = c;
+		pos++;
+	} while(1);
+
+	/* Read \n or EOF */
+	if (buffer == NULL) {
+		/* EOF, so we reached the end of the file, return NULL */
+		if(feof(f))
+			return(NULL);
+
+		/* Just an empty line with just a newline, allocate a 1 byte buffer to
+		* store a zero length string */
+		buffer = (char*)malloc(1);
+		if(buffer == NULL)
+			return(NULL);
+	}
+
+	/* Zero terminated string */
+	buffer[pos] = '\0';
+
+	return(buffer);
+}
+
+/* This function returns a pointer to the first non space char in the given
+* string */
+char *
+skipspaces(char *string)
+{
+	const char spaces[] =
+	{
+		' ','\t','\0'
+	};
+	const char *spacechar = spaces;
+
+	if (string == NULL) return(NULL);
+
+	while (*string != '\0') {
+		/* Test against space chars */
+		while (*spacechar != '\0') {
+			if (*string == *spacechar) {
+				string++;
+				spacechar = spaces;
+				break;
+			}
+			spacechar++;
+		}
+
+		/* No space char */
+		if (*spacechar == '\0') return(string);
+	}
+
+	return(string);
+}
+
+/* This function returns a boolean that tells if the string is only a
+* comment */
+int
+iscomment(char *string)
+{
+	const char comments[] =
+	{
+		'#',';', '%', '\0'
+	};
+	const char *cmtchar = comments;
+	int iscomment = 0;
+
+	if (string == NULL) return(1);
+
+	string = skipspaces(string);
+
+	while(*cmtchar != '\0') {
+		if(*string == *cmtchar) {
+			iscomment = 1;
+			break;
+		}
+		cmtchar++;
+	}
+
+	return(iscomment);
+}
+
+// Merged from xvid Pass1
+
+
+int rc_2pass1_create(xvid_plg_create_t * create, rc_2pass1_t ** handle)
+{
+	xvid_plugin_2pass1_t * param = (xvid_plugin_2pass1_t *)create-&gt;param;
+	rc_2pass1_t * rc;
+
+	/* check filename */
+	if ((param-&gt;filename == NULL) ||
+		(param-&gt;filename != NULL &amp;&amp; param-&gt;filename[0] == '\0'))
+		return XVID_ERR_FAIL;
+
+	/* allocate context struct */
+	if((rc = (rc_2pass1_t *)malloc(sizeof(rc_2pass1_t))) == NULL)
+		return(XVID_ERR_MEMORY);
+
+	/* Initialize safe defaults for 2pass 1 */
+	rc-&gt;stat_file = NULL;
+
+	/* Open the 1st pass file */
+	if((rc-&gt;stat_file = fopen(param-&gt;filename, &quot;w+b&quot;)) == NULL)
+		return(XVID_ERR_FAIL);
+
+	/* I swear xvidcore isn't buggy, but when using mencoder+xvid4 i observe
+	* this weird bug.
+	*
+	* Symptoms: The stats file grows until it's fclosed, but at this moment
+	*           a large part of the file is filled by 0x00 bytes w/o any
+	*           reasonable cause. The stats file is then completly unusable
+	*
+	* So far, i think i found &quot;the why&quot;:
+	*  - take a MPEG stream containing 2 sequences (concatenate 2 MPEG files
+	*    together)
+	*  - Encode this MPEG file
+	*
+	* It should trigger the bug
+	*
+	* I think this is caused by some kind of race condition on mencoder module
+	* start/stop.
+	*  - mencoder encodes the first sequence
+	*    + xvid4 module opens xvid-twopass.stats and writes stats in it.
+	*  - mencoder detects the second sequence and initialize a second
+	*    module and stops the old encoder
+	*    + new xvid4 module opens a new xvid-twopass.stats, old xvid4
+	*      module closes it
+	*
+	* This is IT, got a racing condition.
+	* Unbuffered IO, may help ... */
+	setbuf(rc-&gt;stat_file, NULL);
+
+	/*
+	* The File Header
+	*/
+	fprintf(rc-&gt;stat_file, &quot;# XviD 2pass stat file (core version %d.%d.%d)\n&quot;,
+		XVID_VERSION_MAJOR(XVID_VERSION),
+		XVID_VERSION_MINOR(XVID_VERSION),
+		XVID_VERSION_PATCH(XVID_VERSION));
+	fprintf(rc-&gt;stat_file, &quot;# Please do not modify this file\n\n&quot;);
+
+	rc-&gt;fq_error = 0;
+
+	*handle = rc;
+	return(0);
+}
+
+
+int rc_2pass1_destroy(rc_2pass1_t * rc, xvid_plg_destroy_t * destroy)
+{
+	if (rc-&gt;stat_file) {
+		if (fclose(rc-&gt;stat_file) == EOF) {
+			DPRINTF(XVID_DEBUG_RC, &quot;Error closing stats file (%s)&quot;, strerror(errno));
+		}
+	}
+	rc-&gt;stat_file = NULL; /* Just a paranoid reset */
+	free(rc); /* as the container structure is freed anyway */
+	return(0);
+}
+
+
+int rc_2pass1_before(rc_2pass1_t * rc, xvid_plg_data_t * data)
+{
+	if (data-&gt;quant &lt;= 0) {
+		if (data-&gt;zone &amp;&amp; data-&gt;zone-&gt;mode == XVID_ZONE_QUANT) {
+			/* We disable no options in quant zones, as their implementation is
+			* based on the fact we do first pass exactly the same way as the
+			* second one to have exact zone size */
+			rc-&gt;fq_error += (double)data-&gt;zone-&gt;increment / (double)data-&gt;zone-&gt;base;
+			data-&gt;quant = (int)rc-&gt;fq_error;
+			rc-&gt;fq_error -= data-&gt;quant;
+		} else {
+			data-&gt;quant = 2;
+
+#ifdef FAST1PASS
+			/* Given the fact our 2pass algorithm is based on very simple
+			* rules, we can disable some options that are too CPU intensive
+			* and do not provide the 2nd pass any benefit */
+
+			/* First disable some motion flags */
+			data-&gt;motion_flags &amp;= ~XVID_ME_CHROMA_PVOP;
+			data-&gt;motion_flags &amp;= ~XVID_ME_CHROMA_BVOP;
+			data-&gt;motion_flags &amp;= ~XVID_ME_USESQUARES16;
+			data-&gt;motion_flags &amp;= ~XVID_ME_ADVANCEDDIAMOND16;
+			data-&gt;motion_flags &amp;= ~XVID_ME_EXTSEARCH16;
+
+			/* And enable fast replacements */
+			data-&gt;motion_flags |= XVID_ME_FAST_MODEINTERPOLATE;
+			data-&gt;motion_flags |= XVID_ME_SKIP_DELTASEARCH;
+			data-&gt;motion_flags |= XVID_ME_FASTREFINE16;
+			data-&gt;motion_flags |= XVID_ME_BFRAME_EARLYSTOP;
+
+			/* Now VOP flags (no fast replacements) */
+			data-&gt;vop_flags &amp;= ~XVID_VOP_MODEDECISION_RD;
+			data-&gt;vop_flags &amp;= ~XVID_VOP_FAST_MODEDECISION_RD;
+			data-&gt;vop_flags &amp;= ~XVID_VOP_TRELLISQUANT;
+			data-&gt;vop_flags &amp;= ~XVID_VOP_INTER4V;
+			data-&gt;vop_flags &amp;= ~XVID_VOP_HQACPRED;
+
+			/* Finnaly VOL flags
+			*
+			* NB: Qpel cannot be disable because this option really changes
+			*     too much the texture data compressibility, and thus the
+			*     second pass gets confused by too much impredictability
+			*     of frame sizes, and actually hurts quality */
+#ifdef FAST1PASS_QPEL_TOO
+			/* or maybe we can disable it after all? */
+			data-&gt;vol_flags &amp;= ~XVID_VOL_QUARTERPEL;
+#endif
+			data-&gt;vol_flags &amp;= ~XVID_VOL_GMC;
+#endif
+		}
+	}
+	return(0);
+}
+
+
+int rc_2pass1_after(rc_2pass1_t * rc, xvid_plg_data_t * data)
+{
+	char type;
+	xvid_enc_stats_t *stats = &amp;data-&gt;stats;
+
+	/* Frame type in ascii I/P/B */
+	switch(stats-&gt;type) {
+	case XVID_TYPE_IVOP:
+		type = 'i';
+		break;
+	case XVID_TYPE_PVOP:
+		type = 'p';
+		break;
+	case XVID_TYPE_BVOP:
+		type = 'b';
+		break;
+	case XVID_TYPE_SVOP:
+		type = 's';
+		break;
+	default: /* Should not go here */
+		return(XVID_ERR_FAIL);
+	}
+
+	/* write the resulting statistics */
+
+	fprintf(rc-&gt;stat_file, &quot;%c %d %d %d %d %d %d\n&quot;,
+		type,
+		stats-&gt;quant,
+		stats-&gt;kblks,
+		stats-&gt;mblks,
+		stats-&gt;ublks,
+		stats-&gt;length,
+		stats-&gt;hlength);
+
+	return(0);
+}
+
+
+
+int xvid_plugin_2pass1(void * handle, int opt, void * param1, void * param2)
+{
+	switch(opt)
+	{
+	case XVID_PLG_INFO :
+	case XVID_PLG_FRAME :
+		return 0;
+
+	case XVID_PLG_CREATE :
+		return rc_2pass1_create((xvid_plg_create_t*)param1,(rc_2pass1_t **) param2);
+
+	case XVID_PLG_DESTROY :
+		return rc_2pass1_destroy((rc_2pass1_t*)handle, (xvid_plg_destroy_t*)param1);
+
+	case XVID_PLG_BEFORE :
+		return rc_2pass1_before((rc_2pass1_t*)handle, (xvid_plg_data_t*)param1);
+
+	case XVID_PLG_AFTER :
+		return rc_2pass1_after((rc_2pass1_t*)handle, (xvid_plg_data_t*)param1);
+	}
+
+	return XVID_ERR_FAIL;
+}
+
+//

Added: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_avcodec/xvidRateCtl/xvidRateCtl.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_avcodec/xvidRateCtl/xvidRateCtl.h	2009-12-28 06:39:12 UTC (rev 5742)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_avcodec/xvidRateCtl/xvidRateCtl.h	2009-12-28 12:04:18 UTC (rev 5743)
@@ -0,0 +1,25 @@
+#ifndef XVIDRATECTL_H
+#define XVIDRATECTL_H
+
+#include &lt;inttypes.h&gt;
+#include &quot;rateControl.h&quot;
+
+class ADM_newXvidRc : public ADM_ratecontrol
+{
+protected:
+	uint32_t _totalFrame;
+public:
+	ADM_newXvidRc(uint32_t fps1000, char *logname);
+	virtual 	~ADM_newXvidRc();
+	/** Maxbr &amp; minbr in kbps, vbvsize in kBytes); Default is none */
+	virtual 	uint8_t setVBVInfo(uint32_t maxbr,uint32_t minbr, uint32_t vbvsize);
+	virtual		uint8_t startPass1( void );
+	virtual		uint8_t logPass1(uint32_t qz, ADM_rframe ftype,uint32_t size);
+	virtual		uint8_t startPass2( uint32_t size,uint32_t nbFrame );
+	virtual		uint8_t getQz( uint32_t *qz, ADM_rframe *type );
+	virtual		uint8_t logPass2( uint32_t qz, ADM_rframe ftype,uint32_t size);
+	// Used for VBV
+	uint8_t getInfo(uint32_t framenum, uint32_t *qz, uint32_t *size,ADM_rframe *type);
+
+};
+#endif

Added: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_avcodec/xvidRateCtl/xvidRateCtlVbv.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_avcodec/xvidRateCtl/xvidRateCtlVbv.cpp	2009-12-28 06:39:12 UTC (rev 5742)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_avcodec/xvidRateCtl/xvidRateCtlVbv.cpp	2009-12-28 12:04:18 UTC (rev 5743)
@@ -0,0 +1,335 @@
+//
+// C++ Implementation: %{MODULE}
+//
+// Description:
+//
+//
+// Author:Mean (<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.Fr</A>)
+//
+// Copyright: See COPYING file that comes with this distribution GPL
+//	Use xvid cvs ratecontrol, including some VBV max bitrate constraints
+//		so that it can be used for mpeg1/2 with tight constraints
+//
+//	Reuse some of Peter Cheat predictor model
+//
+
+#include &lt;string.h&gt;
+#include &lt;stdio.h&gt;
+#include &lt;math.h&gt;
+
+#undef NDEBUG
+#include &lt;assert.h&gt;
+
+#include &quot;xvidRateCtlVbv.h&quot;
+
+#define aprintf(prt, args...);
+
+ADM_newXvidRcVBV::ADM_newXvidRcVBV(uint32_t fps1000, char *logname) : ADM_ratecontrol(fps1000,logname)
+{
+	rc=new ADM_newXvidRc(fps1000,logname);
+	_state=RS_IDLE; 
+	_minbr=0;
+	_maxbr=2*9*1000*1000; // ~ 9MB*2
+	_vbvsize=5*224*1024;	// 1MB vbv buffer size
+	_stat=NULL;
+	_lastSize=NULL;
+
+	_idxI=_idxP=_idxB=0;
+}
+ADM_newXvidRcVBV::~ADM_newXvidRcVBV()
+{
+	if(rc)
+		delete rc;
+	if(_stat)
+		delete [] _stat;
+	if(_lastSize)
+		delete [] _lastSize;
+	rc=NULL;
+	_stat=NULL;
+	_lastSize=NULL;
+}
+uint8_t ADM_newXvidRcVBV::setVBVInfo(uint32_t maxbr,uint32_t minbr, uint32_t vbvsize)
+{
+	_maxbr=maxbr*1000; // in b/s
+	_minbr=minbr*1000;
+	_vbvsize=vbvsize*1024;
+	printf(&quot;RC: Initializing vbv buffer \n&quot;);
+	printf(&quot;RC: with min br= %lu kbps\n&quot;,(minbr)/1000);
+	printf(&quot;RC:      max br= %lu kbps\n&quot;,(maxbr)/1000);
+	printf(&quot;Rc:      VBV   = %lu kB\n&quot;,_vbvsize/1024);
+
+	return 1;
+}
+
+uint8_t ADM_newXvidRcVBV::startPass1( void )
+{
+	return rc-&gt;startPass1();
+}
+uint8_t ADM_newXvidRcVBV::startPass2( uint32_t size,uint32_t nbFrame )
+{
+	printf(&quot;Starting Xvid VBV with %lu frames, target size :%lu MB\n&quot;,nbFrame,size);
+	_nbFrames=nbFrame;
+	if(! rc-&gt;startPass2(size,nbFrame)) return 0;
+	// Built pass 1 stat file in memory
+	// we will need it later to project
+	//________________________________
+	_stat=new ADM_pass_stat[nbFrame];
+	ADM_pass_stat *cur=_stat;
+
+	for(uint32_t i=0;i&lt;nbFrame;i++)
+	{
+		rc-&gt;getInfo(i,&amp;(cur-&gt;quant),&amp;(cur-&gt;size),&amp;(cur-&gt;type));
+		cur++;
+	}
+	// a roundup is close to fps
+	_roundup=(uint32_t )floor((_fps1000+500)/1000);
+	// Do so check
+	_vbv_fullness=(_vbvsize*8)/10; // Buffer starts 80% full
+	_byte_per_image=(_maxbr&gt;&gt;3)/_roundup;
+	_lastSize=new uint32_t[_roundup];
+	memset(_lastSize,0,_roundup*sizeof(uint32_t));
+	_frame=0;
+	for(uint32_t i=0;i&lt;AVG_LOOKUP;i++)
+	{
+		_compr[0][i]=1.0;
+		_compr[1][i]=1.0;
+		_compr[2][i]=1.0;
+	}
+	printf(&quot;Rc: Byte per image : %lu \n&quot;,_byte_per_image);
+	return 1;
+}
+uint8_t ADM_newXvidRcVBV::logPass1(uint32_t qz, ADM_rframe ftype,uint32_t size)
+{
+	return rc-&gt;logPass1(qz,ftype,size);
+}
+uint8_t ADM_newXvidRcVBV::logPass2(uint32_t qz, ADM_rframe ftype,uint32_t size)
+{
+	// update stored value
+	_lastSize[_frame%_roundup]=size;
+
+	_vbv_fullness+=_byte_per_image;
+	if(_vbv_fullness&lt;size)
+	{
+		printf(&quot;VBV buffer underflow :frame %lu, underflow : %lu\n&quot;,_frame,size-_vbv_fullness);
+	}
+	else
+	{
+		_vbv_fullness-=size;
+	}
+	if(_vbv_fullness&gt;_vbvsize)
+	{
+		// not an error printf(&quot;VBV buffer overflow :frame %lu, overflow : %lu\n&quot;,_frame,_vbv_fullness-_vbvsize);
+		_vbv_fullness=_vbvsize;
+	}
+	// update compr
+	uint32_t rank;
+#define BLEND(x) case RF_##x: rank=_idx##x;_idx##x=_idx##x+1;_idx##x%=AVG_LOOKUP;break;	
+	switch(ftype)
+	{
+		BLEND(I)
+		BLEND(P)
+		BLEND(B)
+		default:
+			assert(0);
+	}    
+
+	_compr[ftype-1][rank]=getComp(_stat[_frame].size,_stat[_frame].quant,size,qz);
+	//
+	aprintf(&quot;Frame %08lu size %d type:%d vbv fullness %u, kbytes :%lu qz used :%d\n&quot;,_frame,size, ftype,(100*_vbv_fullness)/_vbvsize,_vbv_fullness/1024,qz);
+	// compute instantaneous br
+	uint32_t br=0;
+	for(uint32_t i=0;i&lt;_roundup;i++)
+	{
+		br+=_lastSize[i];
+	}
+	br*=8;
+	br/=1000;
+	aprintf(&quot;br : %lu\n&quot;,br);
+	_frame++;
+	return rc-&gt;logPass2(qz,ftype,size);
+}
+uint8_t ADM_newXvidRcVBV::getQz( uint32_t *qz, ADM_rframe *type )
+{
+	if(! rc-&gt;getQz(qz,type)) return 0;
+	// Now we have the temptative quant
+	// Check that both the vbv buffer &amp; bitrate stays full enough
+	if(*qz&lt;2) *qz=2;
+	while(*qz&lt;31 &amp;&amp; project(_frame,*qz,*type)) (*qz)++;
+
+
+	return 1;
+}
+
+/**
+\fn ADM_newXvidRcVBV::verifyLog
+\brief Verify the file is correct and not corrupted as far as 2pass is concerned
<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">+ at return</A> 1 on success (file not corrupted), 0 else.
+
+A note of warning, the actual nbFrame can depend on the encoder/codec as there might be some
+encoder-delay that is more or less ignored
+Normally nbFrame should be actual nb frame +2 (to compensate for the 2 comment lines in xvid rc file)
+but as it is, when you use lavc based mpeg codec, the whole process will eat up 2 frames.
+
+*/
+uint8_t ADM_newXvidRcVBV::verifyLog(const char *file,uint32_t nbFrame)
+{
+	FILE *in;
+	char oneLine[1024];
+	uint32_t nb=0;
+	in=fopen(file,&quot;rt&quot;);
+	if(!in) return 0;
+	while(fgets(oneLine,1023,in)) nb++;
+	fclose(in);
+	if(nbFrame+1==nb) 
+	{
+		printf(&quot;[XvidRC]Logfile Seems ok\n&quot;);
+		return 1;
+	}
+	printf(&quot;[XvidRC]Logfile Seems corrupted (%u/%u)\n&quot;,nb,nbFrame);
+	return 0;
+}
+//
+// Return 1 if the frame and Qz fails the sanity check
+//
+uint8_t ADM_newXvidRcVBV::project(uint32_t framenum, uint32_t q, ADM_rframe frame)
+{
+	if(!checkVBV(framenum,q,frame)) return 1;
+	//	if(!checkBitrate(framenum,q,frame)) return 1;
+	return 0;
+}
+uint8_t ADM_newXvidRcVBV::checkVBV(uint32_t framenum, uint32_t q, ADM_rframe frame)
+{
+
+	// Project the next frames with the same Q factor reduction as now
+	// and check
+
+	// A bit simplistic...
+
+	if(framenum&lt;_nbFrames-_roundup)
+	{
+		uint32_t projected_vbv=(_vbv_fullness*9)/10; // Only use 90% of the buffer
+		uint32_t framesize;
+
+		// Q increase ratio
+
+		float compI=0,compP=0,compB=0,comp=0,size,qr;
+		float ratioI,ratioP,ratioB,ratio;
+
+		for(uint32_t i=0;i&lt;AVG_LOOKUP;i++)
+		{
+			compI+=_compr[0][i];
+			compP+=_compr[1][i];
+			compB+=_compr[2][i];
+		}
+
+		compI=compI/AVG_LOOKUP;	// Average compression ratio
+		compP=compP/AVG_LOOKUP;	// Average compression ratio
+		compB=compB/AVG_LOOKUP;	// Average compression ratio
+		ratioI=getRatio(q,_stat[framenum].quant,compI);
+		ratioP=getRatio(q,_stat[framenum].quant,compP);
+		ratioB=getRatio(q,_stat[framenum].quant,compB);
+
+
+		for(uint32_t i=0;i&lt;_roundup&gt;&gt;1;i++)
+		{
+			switch(_stat[framenum+i].type)
+			{
+				case RF_I:ratio=ratioI;comp=compI;break;
+				case RF_P:ratio=ratioP;comp=compP;break;
+				case RF_B:ratio=ratioB;comp=compB;break;
+				default:
+					assert(0);
+			}
+			size=ratio;
+			size*=_stat[framenum+i].size;
+			framesize=(uint32_t)floor(size);	// predicted size
+
+			if(frame==RF_I) // Keep a margin and anticipate BIG I frame
+				framesize=(framesize*12)/10;
+
+			aprintf(&quot;\t Org: %lu projected :%d VBV:%d q:%d ratio:%f alpha:%f  type :%d\n&quot;,_stat[framenum+i].size,framesize,
+				projected_vbv/1024,q,ratio,comp,_stat[framenum+i].type);
+			if(projected_vbv&lt;framesize)
+			{
+				aprintf(&quot;potential underflow at %d + %d , q:%d\n&quot;,framenum,i,q);
+				return 0;
+			}
+			projected_vbv-=framesize;
+			projected_vbv+=_byte_per_image;
+			if(projected_vbv&gt;_vbvsize)
+			{
+				projected_vbv=_vbvsize;
+			}
+		}
+	}
+	else
+	{
+		if(q&lt;9) return 0;
+	}		
+	return 1;
+
+}
+
+
+/*__________________________________________________________________
+
+Reverse the below formula
+newbits/oldbuts=newquang^ -comp
+log(newq^ -comp)=log(newbit/oldbits)
+comp=-log(newbits/oldbits)/log(newq/oldq)
+*/
+float ADM_newXvidRcVBV::getComp(int oldbits, int qporg, int newbits, int qpused)
+{
+	float comp;
+	/*	
+	comp=newbits;
+	comp/=oldbits;
+	comp=log(comp);
+	comp/=log(qpused/qporg);
+	printf(&quot;Old q:%d new q : %d oldBits:%d newbits:%d comp:%f\n&quot;,
+	qporg,qpused,oldbits,newbits,-comp);
+	comp= -comp;
+	if(comp&gt;3) comp=3;
+	if(comp&lt;0.5) comp=0.5;
+	return comp;
+	*/
+	// Linear
+	// comp=(Nb*Nq)/(Ob*Oq);
+	comp=newbits;
+	comp*=qpused;
+	comp/=qporg;
+	comp/=oldbits;
+	// Clamp between max alpha/min alpha
+#define MAX_ALPHA 6
+#define MIN_ALPHA (1.0/MAX_ALPHA)
+	if(comp&gt;MAX_ALPHA) comp=MAX_ALPHA;
+	if(comp&lt;MIN_ALPHA) comp=MIN_ALPHA;
+	return comp;
+}
+/*_______________________________________________________________
+Predict the size of the image
+Using a exp(-comp) formula instead of linear formula
+
+Idea by Peter Cheat
+__________________________________________________________________
+*/
+float ADM_newXvidRcVBV::getRatio(uint32_t newq, uint32_t oldq, float alpha)
+{
+	// Peter Cheat formula :Pridicted Bits Frame 10 Will Use = (Bits Used At Quantiser 1) * (New Quantiser ^ -Compressibility)
+	// avg lookup compressibility
+	/*			exponential
+	qr=q;
+	qr=qr/_stat[framenum].quant;	// average size reduction
+	qr=pow(qr,-comp);
+	*/
+	// Linear
+	// Ob*Oq*alpha=Nb*Nq
+	// Nb/Ob=Oq/Nq*alpha
+	//alpha=1;
+	float comp;
+
+	comp=oldq;	
+	comp/=newq;
+	comp*=alpha;
+	return comp;
+}

Added: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_avcodec/xvidRateCtl/xvidRateCtlVbv.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_avcodec/xvidRateCtl/xvidRateCtlVbv.h	2009-12-28 06:39:12 UTC (rev 5742)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_avcodec/xvidRateCtl/xvidRateCtlVbv.h	2009-12-28 12:04:18 UTC (rev 5743)
@@ -0,0 +1,40 @@
+#ifndef XVIDRATECTLVBV_H
+#define XVIDRATECTLVBV_H
+
+#include &lt;inttypes.h&gt;
+#include &quot;rateControl.h&quot;
+#include &quot;xvidRateCtl.h&quot;
+
+#define AVG_LOOKUP 5
+class ADM_newXvidRcVBV : public ADM_ratecontrol
+{
+protected:
+	ADM_newXvidRc	*rc;
+	uint32_t	_minbr,_maxbr,_vbvsize;
+	ADM_pass_stat  *_stat;
+	uint32_t	*_lastSize;
+	uint32_t	_roundup;
+	uint32_t	_frame;
+	uint32_t	_vbv_fullness;
+	uint32_t	_byte_per_image;
+	double		_compr[3][AVG_LOOKUP];  
+	uint32_t   _idxI,_idxP,_idxB;
+
+	uint8_t 	project(uint32_t framenum, uint32_t q, ADM_rframe frame);
+	uint8_t 	checkVBV(uint32_t framenum, uint32_t q, ADM_rframe frame);
+	float 		getRatio(uint32_t newq, uint32_t oldq, float alpha);
+	float 		getComp(int oldbits, int qporg, int newbits, int qpused);
+
+public:
+	ADM_newXvidRcVBV(uint32_t fps1000, char *logname);
+	virtual 	~ADM_newXvidRcVBV() ;
+	/** Maxbr &amp; minbr in kbps, vbvsize in kBytes); Default is none */
+	virtual 	uint8_t setVBVInfo(uint32_t maxbr,uint32_t minbr, uint32_t vbvsize);
+	virtual		uint8_t startPass1( void );
+	virtual		uint8_t logPass1(uint32_t qz, ADM_rframe ftype,uint32_t size);
+	virtual		uint8_t startPass2( uint32_t size,uint32_t nbFrame );
+	virtual		uint8_t getQz( uint32_t *qz, ADM_rframe *type );
+	virtual		uint8_t logPass2( uint32_t qz, ADM_rframe ftype,uint32_t size);
+	uint8_t verifyLog(const char *file,uint32_t nbFrame);
+};
+#endif


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="002949.html">[Avidemux-svn-commit] r5742 -	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDevices/PulseAudioSimple
</A></li>
	<LI>Next message: <A HREF="002951.html">[Avidemux-svn-commit] r5744 -	branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_avcodec/xvidRateCtl
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2950">[ date ]</a>
              <a href="thread.html#2950">[ thread ]</a>
              <a href="subject.html#2950">[ subject ]</a>
              <a href="author.html#2950">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">More information about the Avidemux-svn-commit
mailing list</a><br>
</body></html>
