<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Avidemux-svn-commit] r5627 - in	branches/avidemux_2.6_branch_mean/avidemux: . common	common/ADM_script2 common/ADM_script2/include	common/ADM_script2/src common/ADM_toolkit qt4
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/avidemux-svn-commit/2009-December/index.html" >
   <LINK REL="made" HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r5627%20-%20in%0A%09branches/avidemux_2.6_branch_mean/avidemux%3A%20.%20common%0A%09common/ADM_script2%20common/ADM_script2/include%0A%09common/ADM_script2/src%20common/ADM_toolkit%20qt4&In-Reply-To=%3C200912090641.nB96fZMS022990%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="002834.html">
   <LINK REL="Next"  HREF="002837.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Avidemux-svn-commit] r5627 - in	branches/avidemux_2.6_branch_mean/avidemux: . common	common/ADM_script2 common/ADM_script2/include	common/ADM_script2/src common/ADM_toolkit qt4</H1>
    <B>mean at BerliOS</B> 
    <A HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r5627%20-%20in%0A%09branches/avidemux_2.6_branch_mean/avidemux%3A%20.%20common%0A%09common/ADM_script2%20common/ADM_script2/include%0A%09common/ADM_script2/src%20common/ADM_toolkit%20qt4&In-Reply-To=%3C200912090641.nB96fZMS022990%40sheep.berlios.de%3E"
       TITLE="[Avidemux-svn-commit] r5627 - in	branches/avidemux_2.6_branch_mean/avidemux: . common	common/ADM_script2 common/ADM_script2/include	common/ADM_script2/src common/ADM_toolkit qt4">mean at mail.berlios.de
       </A><BR>
    <I>Wed Dec  9 07:41:35 CET 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="002834.html">[Avidemux-svn-commit] r5626 -	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDecoders/ADM_ad_vorbis
</A></li>
        <LI>Next message: <A HREF="002837.html">[Avidemux-svn-commit] r5628 -	branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_gui
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2836">[ date ]</a>
              <a href="thread.html#2836">[ thread ]</a>
              <a href="subject.html#2836">[ subject ]</a>
              <a href="author.html#2836">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: mean
Date: 2009-12-09 07:41:29 +0100 (Wed, 09 Dec 2009)
New Revision: 5627

Added:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/include/
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/include/ADM_js.h
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/include/ADM_jsDebug.h
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/include/ADM_jsIf.h
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/include/ADM_jsShell.h
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/include/ADM_jsUtils.h
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/include/StdFile.h
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/include/adm_scanner.h
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsDebug.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsIf.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsIf_js.c
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsIf_js.idl
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsTestFactory.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsTestFactory_js.c
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsTestFactory_js.idl
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsUtils.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/idl.make
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/updateIdl.sh
Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_toolkit/automation.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/avidemux/common/main.cpp
   branches/avidemux_2.6_branch_mean/avidemux/commonCmakeApplication.cmake
   branches/avidemux_2.6_branch_mean/avidemux/qt4/CMakeLists.txt
Log:
[JS] Replace old jscript hooks by new ones

Added: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/CMakeLists.txt	2009-12-06 11:01:40 UTC (rev 5626)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/CMakeLists.txt	2009-12-09 06:41:29 UTC (rev 5627)
@@ -0,0 +1 @@
+subdirs (src)

Added: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/include/ADM_js.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/include/ADM_js.h	2009-12-06 11:01:40 UTC (rev 5626)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/include/ADM_js.h	2009-12-09 06:41:29 UTC (rev 5627)
@@ -0,0 +1,39 @@
+/**
+    \file ADM_js
+    \brief Standard includes and defines
+*/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#ifndef ADM_JS_H
+#define ADM_JS_H
+
+
+#include &quot;ADM_default.h&quot;
+#include &lt;string.h&gt;
+#include &lt;pthread.h&gt;
+#include &quot;DIA_coreToolkit.h&quot;
+#include &quot;jsapi.h&quot;
+
+#include &quot;ADM_jsUtils.h&quot;
+#include &quot;ADM_jsShell.h&quot;
+#include &quot;ADM_jsDebug.h&quot;
+
+typedef JSBool JS_PROTOTYPE(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval);
+
+#if !defined(ADM_JS_THREADSAFE)
+#define enterLock() {}
+#define leaveLock() {}
+#else
+#define enterLock() jsrefcount nRefCount = JS_SuspendRequest(cx)
+#define leaveLock() {JS_ResumeRequest(cx,nRefCount); }
+
+#endif
+
+#endif

Added: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/include/ADM_jsDebug.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/include/ADM_jsDebug.h	2009-12-06 11:01:40 UTC (rev 5626)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/include/ADM_jsDebug.h	2009-12-09 06:41:29 UTC (rev 5627)
@@ -0,0 +1,26 @@
+/**
+    \file ADM_JSDebug.h
+    \brief Debug oriented functions for avidemux JS/JS shell
+    \author mean (c) 2009 <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
+
+
+*/
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#ifndef ADMJS_DEBUG_H
+#define ADMJS_DEBUG_H
+extern &quot;C&quot;
+{
+void jsPopupError(const char *s);
+void jsPopupInfo(const char *s);
+};
+
+
+#endif
\ No newline at end of file

Added: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/include/ADM_jsIf.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/include/ADM_jsIf.h	2009-12-06 11:01:40 UTC (rev 5626)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/include/ADM_jsIf.h	2009-12-09 06:41:29 UTC (rev 5627)
@@ -0,0 +1,51 @@
+/**
+    \file ADM_JSif.cpp
+    \brief interface to js
+*/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#ifndef ADM_JS_IF_H
+#define ADM_JS_IF_H
+
+/**
+    \enum JS_LOG_TYPE
+*/
+typedef enum
+{
+    JS_LOG_NORMAL,
+    JS_LOG_ERROR
+}JS_LOG_TYPE;
+/**
+    \typedef jsLoggerFunc
+*/
+typedef bool (jsLoggerFunc)(void *cookie,JS_LOG_TYPE type,const char *);
+/*
+
+*/
+bool ADM_jsRegisterLogger(void *cookie,jsLoggerFunc *fun);
+bool ADM_jsUnregisterLogger(void);
+
+/**
+    \fn parseECMAScript
+    \brief Compile &amp; execute ecma script
+*/
+bool parseECMAScript(const char *name);
+
+/**
+    \fn    interactiveECMAScript
+    \brief interprete &amp; execute ecma script (interactive)
+*/
+bool interactiveECMAScript(const char *name);
+/**
+    \fn jsLog
+
+*/
+bool jsLog(JS_LOG_TYPE type, const char *fmt,...);
+#endif

Added: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/include/ADM_jsShell.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/include/ADM_jsShell.h	2009-12-06 11:01:40 UTC (rev 5626)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/include/ADM_jsShell.h	2009-12-09 06:41:29 UTC (rev 5627)
@@ -0,0 +1,23 @@
+/**
+    \file ADM_jsShell.h
+    \brief Base class for js interactive shell
+    \author mean, <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
+*/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#ifndef ADM_JS_SHELL_H
+#define ADM_JS_SHELL_H
+#include &quot;ADM_jsIf.h&quot;
+typedef bool (jsShellEvaluate)(const char *str);
+bool ADM_startShell(jsShellEvaluate *eval);
+
+
+#endif // ADM_JS_SHELL_H
\ No newline at end of file

Added: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/include/ADM_jsUtils.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/include/ADM_jsUtils.h	2009-12-06 11:01:40 UTC (rev 5626)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/include/ADM_jsUtils.h	2009-12-09 06:41:29 UTC (rev 5627)
@@ -0,0 +1,40 @@
+/**
+    \file ADM_jsUtils
+    \brief Simple param -&gt; type utilities
+    \author mean <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A> 2009
+*/
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#ifndef ADM_JS_UTILS_H
+#define ADM_JS_UTILS_H
+
+typedef enum
+{
+    ADM_JS_INVALID=0,
+    ADM_JS_UINT32_T=1,
+    ADM_JS_INT32_T,
+    ADM_JS_UINT64_T,
+    ADM_JS_INT64_T,
+    ADM_JS_STRING,
+    ADM_JS_BOOL,
+    ADM_JS_MAX
+}ADM_PARAM_TYPE;
+
+typedef struct
+{
+    ADM_PARAM_TYPE type;
+    void           *value;
+
+}ADM_PARAM_LIST;
+
+// since long int will be coded by js as double, we need a centralized version to convert
+bool ADM_jsArg2Vars(const char *caller, int argc, jsval *argv, int paramNumber, ADM_PARAM_LIST *param);
+
+
+#endif

Added: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/include/StdFile.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/include/StdFile.h	2009-12-06 11:01:40 UTC (rev 5626)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/include/StdFile.h	2009-12-09 06:41:29 UTC (rev 5627)
@@ -0,0 +1,63 @@
+// StdFile.h: interface for the CStdFile class.
+//
+//////////////////////////////////////////////////////////////////////
+/*
+Copyright 2001-2005 Anish Mistry. All rights reserved.
+
+Note:  This file is available under a BSD license.  Contact the author
+at <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">amistry at am-productions.biz</A>
+*/
+
+#if !defined(AFX_STDFILE_H__44214218_8F1A_4792_8D4D_8147F50E168D__INCLUDED_)
+#define AFX_STDFILE_H__44214218_8F1A_4792_8D4D_8147F50E168D__INCLUDED_
+
+#if _MSC_VER &gt; 1000
+#pragma once
+#endif // _MSC_VER &gt; 1000
+
+#include &lt;iostream&gt;
+#include &lt;iomanip&gt;
+#include &lt;fstream&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;string&gt;
+
+using namespace std;
+
+#ifdef __WIN32
+	const char DIRECTORY_DELIMITOR = '\\';
+#else
+	const char DIRECTORY_DELIMITOR = '/';
+	#define _MAX_PATH 1024
+#endif
+
+class CStdFile
+{
+public:
+	char Peek();
+	int WriteString(const char *pBuffer);
+	char * ReadString(char *pBuffer, int nMaxLen,char cDelim = ' ');
+	unsigned long int GetPos();
+	unsigned long int Seek(unsigned long int pos,ios::seekdir start);
+	unsigned long int GetLength();
+	unsigned long int Write(const char *buffer, unsigned long int bytesToWrite);
+	unsigned long int Read(char *buffer, unsigned long int bytesToRead);
+	const char * GetFilePath();
+	const char * GetFileName();
+	CStdFile(void);
+	virtual ~CStdFile(void);
+//	static bool Copy(const char *source,const char *dest, bool bOverwrite);
+	static int Rename(const char *source,const char *dest);
+	static int Delete(const char *fileName);
+	virtual bool Open(const char *filename, ios::openmode accessFlags);
+	unsigned long int WriteLine(const char *);
+	unsigned long int ReadLine(char *bufferOut);
+	virtual bool Close();
+
+protected:
+	void GetName(const char *fileString,char *fileBufferOut);
+	char *m_pPath;
+	char *m_pName;
+	fstream m_fsFile;
+};
+
+#endif // !defined(AFX_STDFILE_H__44214218_8F1A_4792_8D4D_8147F50E168D__INCLUDED_)

Added: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/include/adm_scanner.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/include/adm_scanner.h	2009-12-06 11:01:40 UTC (rev 5626)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/include/adm_scanner.h	2009-12-09 06:41:29 UTC (rev 5627)
@@ -0,0 +1,26 @@
+/*
+	Type used by scanner
+
+*/
+#ifndef ADMSCANNER
+#define ADMSCANNER
+
+#define ADM_MAX_VAR 50
+//#include &quot;ADM_videoFilter_iface.h&quot;
+
+typedef enum
+{
+	ASC_OK,
+	ASC_UNKNOWN_FUNC,
+	ASC_BAD_NUM_PARAM,
+	ASC_BAD_PARAM,
+	ASC_EXEC_FAILED
+}ASC_ERROR;
+
+//int PushParam(APM_TYPE, char *value);
+int Call(char *string);
+
+
+#endif
+//END
+

Added: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsDebug.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsDebug.cpp	2009-12-06 11:01:40 UTC (rev 5626)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsDebug.cpp	2009-12-09 06:41:29 UTC (rev 5627)
@@ -0,0 +1,201 @@
+/**
+    \file ADM_JSDebug.cpp
+    \brief Debug oriented functions for avidemux JS/JS shell
+    \author mean (c) 2009 <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
+
+
+*/
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include &quot;ADM_js.h&quot;
+#include &quot;ADM_editor/ADM_edit.hxx&quot;
+/**/
+/**/
+
+extern JSFunctionSpec *ADM_JsAudioGetFunctions(void);
+extern JSFunctionSpec *ADM_JsVideoGetFunctions(void);
+extern JSFunctionSpec *ADM_JsClassGetFunctions(void);
+extern JSFunctionSpec *ADM_JsDebugGetFunctions(void);
+extern JSFunctionSpec *ADM_JsFunctionGetFunctions(void);
+
+extern ADM_Composer *video_body;
+void ADM_dumpJSHooks(void);
+#if 0
+/**
+    \fn JS_AvidemuxRegisterDebugFunction
+*/
+bool JS_AvidemuxRegisterDebugFunction(JSContext *cx,JSObject *global)
+{
+	if(JS_DefineFunctions(cx, global, adm_debug_functions) == true)
+		return true;
+
+	ADM_warning(&quot;Unable to define functions\n&quot;);
+	return false;
+}
+
+/**
+    \fn ADM_JsDebugGetFunctions
+
+*/
+JSFunctionSpec *ADM_JsDebugGetFunctions(void)
+{
+    return adm_debug_functions;
+}
+#endif
+/**
+    \fn displayError
+    \brief error popup
+*/
+void jsPopupError(const char *s)
+{// begin displayError
+	
+	GUI_Verbose();
+	GUI_Error_HIG(&quot;Error&quot;,s);
+	GUI_Quiet();
+
+}// end displayError
+/**
+    \fn displayInfo
+    \brief info popup
+*/
+
+void jsPopupInfo(const char *s)
+{// begin displayInfo
+	
+	GUI_Verbose();
+	GUI_Info_HIG(ADM_LOG_IMPORTANT,&quot;Info&quot;,s);
+	GUI_Quiet();
+	
+}// end displayInfo
+ /**
+    \fn print
+*/
+void jsPrint(const char *s)
+{// begin print
+        jsLog(JS_LOG_NORMAL,&quot;%s&quot;,s);
+}// end print
+
+
+static void dumpFunc(JSFunctionSpec *f)
+{
+    while(f-&gt;name)
+    {
+        jsLog(JS_LOG_NORMAL,&quot;     %s(..)&quot;,f-&gt;name);
+        f++;
+    }
+}
+/**
+    \fn help
+    \brief dump avidemux specific functions
+*/
+JSBool help(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
+{
+#if 0
+        if(!argc)
+        {
+            jsLog(JS_LOG_NORMAL,&quot;help(\&quot;class\&quot;); or help(\&quot;video\&quot;); or help(\&quot;audio\&quot;); or help(\&quot;debug\&quot;); or debug(\&quot;functions\&quot;&quot;);
+            return JS_TRUE;
+        }
+        if(argc != 1)
+        {
+          jsLog(JS_LOG_ERROR,&quot;help accepts only one arg, type help() to get them\n&quot;);
+          return JS_FALSE;
+        } 
+        JSFunctionSpec *table=NULL;
+        char *f=JS_GetStringBytes(JSVAL_TO_STRING(argv[0]));
+        
+#define DUMPTABLE(x,y) if(!strcasecmp(f,#x)) table=y();
+        if(f)
+        {
+            DUMPTABLE(audio,ADM_JsAudioGetFunctions);
+            DUMPTABLE(video,ADM_JsVideoGetFunctions);
+            DUMPTABLE(debug,ADM_JsDebugGetFunctions);
+            DUMPTABLE(functions,ADM_JsFunctionGetFunctions);
+            DUMPTABLE(class,ADM_JsClassGetFunctions);
+        }
+        if(table) dumpFunc(table);
+        else jsLog(JS_LOG_ERROR,&quot;%s not found&quot;,f);
+#endif  
+  return JS_TRUE;
+}
+/**
+    \fn dumpEditing
+    \brief dump segment, video &amp; all
+*/
+JSBool dumpEditing(JSContext *cx, JSObject *obj, uintN argc, 
+                                       jsval *argv, jsval *rval)
+{// begin PostProcess
+uint32_t info;
+uint32_t frame;
+uint32_t sz;
+        if(argc)
+        {
+            return JS_FALSE;
+        }
+        enterLock();
+        video_body-&gt;dumpEditing();
+        leaveLock(); 
+        
+        return JS_TRUE;
+}// end PostProcess
+/**
+    \fn dumpTiming
+    \brief dump segment, video &amp; all
+*/
+JSBool dumpTiming(JSContext *cx, JSObject *obj, uintN argc, 
+                                       jsval *argv, jsval *rval)
+{// begin PostProcess
+uint32_t info;
+uint32_t frame;
+uint32_t sz;
+        if(argc != 0)
+          return JS_FALSE;
+  
+        enterLock();
+        video_body-&gt;dumpTiming();
+        leaveLock(); 
+        
+        return JS_TRUE;
+}// end PostProcess
+/**
+    \fn printJSError
+*/
+void  printJSError(JSContext *cx, const char *message, JSErrorReport *report)
+{// begin printJSError
+int quiet=GUI_isQuiet();
+char buf[4];
+FILE *fd = ADM_fopen(report-&gt;filename,&quot;rb&quot;);
+    if(quiet)
+            GUI_Verbose();
+	if( fd )
+    {
+		fread(buf,1,4,fd);
+		fclose(fd);
+	}
+	if( strncmp(buf,&quot;//AD&quot;,4) )
+    {
+            if (report-&gt;filename || report-&gt;lineno)
+                jsLog(JS_LOG_ERROR,&quot;%s: line %d:\nMsg: %s\n&quot;
+                              &quot;Not an ECMAScript file. Try open it with 'File' -&gt; 'Open...'&quot;,
+                              report-&gt;filename,
+                              report-&gt;lineno,
+                              message);
+            else
+                jsLog(JS_LOG_ERROR,&quot;Not an ECMAScript file. Try open it with 'File' -&gt; 'Open...'&quot;);
+    
+	}else
+    {
+            jsLog(JS_LOG_ERROR,&quot;%s: line %d:\nMsg: %s\n&quot;,report-&gt;filename,report-&gt;lineno,message);
+	}
+       
+    if(quiet)
+            GUI_Quiet();
+
+}// end printJSError
+// EOF
\ No newline at end of file

Added: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsIf.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsIf.cpp	2009-12-06 11:01:40 UTC (rev 5626)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsIf.cpp	2009-12-09 06:41:29 UTC (rev 5627)
@@ -0,0 +1,232 @@
+/**
+    \file ADM_JSif.cpp
+    \brief interface to js
+*/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include &quot;ADM_js.h&quot;
+#include &lt;stdarg.h&gt;
+void    A_Resync(void);
+static jsLoggerFunc *jsLogger=NULL;
+static void *jsLoggerCookie=NULL;
+extern char * actual_workbench_file;
+
+#define JSVAR(a,b,c) a b=c
+
+#if defined( __MINGW32__) &amp;&amp; defined(JSDECLARE)
+ pthread_t g_pThreadSpidermonkey ;
+#else
+JSVAR( pthread_t, g_pThreadSpidermonkey , 0);
+#endif
+JSVAR( pthread_mutex_t, g_pSpiderMonkeyMutex , PTHREAD_MUTEX_INITIALIZER);
+// expose our main javascript context to the entire program
+JSVAR( bool, g_bJSSuccess , 0);
+JSVAR( JSObject, *g_pObject,NULL);
+JSVAR( JSContext, *g_pCx,NULL);
+JSVAR( JSRuntime, *g_pRt,NULL);
+
+extern void  printJSError(JSContext *cx, const char *message, JSErrorReport *report);
+/**
+    \fn parseECMAScript
+    \brief Compile &amp; execute ecma script
+*/
+bool parseECMAScript(const char *name)
+{// begin parseECMAScript
+	jsval rval;
+	uintN lineno = 0;
+	g_bJSSuccess = 0;
+	printf(&quot;Spidermonkey compiling \&quot;%s\&quot;...&quot;,name);
+	JSScript *pJSScript = JS_CompileFile(g_pCx, g_pObject, name);
+	printf(&quot;Done.\n&quot;);
+	if(pJSScript != NULL)
+	{// begin execute external file
+		printf(&quot;Spidermonkey executing \&quot;%s\&quot;...&quot;,name);
+		JSBool ok = JS_ExecuteScript(g_pCx, g_pObject, pJSScript, &amp;rval);
+		JS_DestroyScript(g_pCx,pJSScript);
+		printf(&quot;Done.\n&quot;);
+	}// end execute external file
+        // Run garbage collector now, it is safe
+    JS_GC(g_pCx);
+	A_Resync();
+	return g_bJSSuccess;
+}// end parseECMAScript
+/**
+    \fn jsLogger
+*/
+bool isJsLogRedirected(void)
+{
+    if(jsLogger) return true;
+    return false;
+}
+/**
+    \fn jsEvaluate
+*/
+static bool jsEvaluate(const char *str)
+{
+jsval rval;
+   JS_EvaluateScript(g_pCx,g_pObject,str,strlen(str),&quot;dummy&quot;,1,&amp;rval);
+   return true; 
+}
+/**
+    \fn    interactiveECMAScript
+    \brief interprete &amp; execute ecma script (interactive)
+*/
+bool interactiveECMAScript(const char *name)
+{
+    ADM_startShell(jsEvaluate);
+    JS_GC(g_pCx);
+	A_Resync();
+    ADM_info(&quot;Ending JS shell...\n&quot;);
+	return true;
+}
+/**
+    \fn jsLog
+*/
+bool jsLog(JS_LOG_TYPE type, const char *prf,...)
+{
+ static char print_buffer[1024];
+  	
+		va_list 	list;
+		va_start(list,	prf);
+		vsnprintf(print_buffer,1023,prf,list);
+		va_end(list);
+		print_buffer[1023]=0; // ensure the string is terminated
+        if(true==isJsLogRedirected())
+            jsLogger(jsLoggerCookie,type,print_buffer);
+        else
+        {
+            if(type==JS_LOG_ERROR)
+                GUI_Error_HIG(&quot;Spidermonkey ECMAScript Error&quot;,&quot;%s&quot;,print_buffer);
+            else
+                ADM_warning(&quot;[JS]%s\n&quot;,print_buffer);
+        }
+        return true;
+}
+
+/**
+    \fn ADM_jsRegisterLogger
+*/
+bool ADM_jsRegisterLogger(void *cookie,jsLoggerFunc *fun)
+{
+    jsLoggerCookie=cookie;
+    jsLogger=fun;
+    return true;
+}
+/**
+    \fn ADM_jsUnregisterLogger
+*/
+bool ADM_jsUnregisterLogger(void)
+{
+    jsLogger=NULL;
+    return true;
+}
+
+/**
+    \fn SpidermonkeyInit
+*/
+bool SpidermonkeyInit()
+{// begin SpidermonkeyInit
+	// setup JS
+	g_pCx = NULL;
+	g_pObject = NULL;
+	g_pRt = NULL;
+	JSRuntime *rt = JS_NewRuntime(1000000L);
+	g_pRt = rt;
+	if ( rt == NULL )
+	{
+		// Do some error reporting
+		printf(&quot;Spidermonkey failed to initialize runtime!\n&quot;);
+	}
+	else
+	{// begin runtime created
+		JSContext *cx = JS_NewContext(rt, 8192);
+		g_pCx = cx;
+		if ( cx == NULL )
+		{
+			// Do some error reporting
+			printf(&quot;Spidermonkey failed to initialize context!\n&quot;);
+		}
+		else
+		{// begin context created
+
+			// register error handler
+			JS_SetErrorReporter(cx, printJSError);
+            //JS_AvidemuxFunction(cx,global);
+            
+			return true;
+		}// end context created
+	}// end runtime created
+	return false;
+}// end SpidermonkeyInit
+/**
+    \fn SpidermonkeyDestroy
+*/
+void SpidermonkeyDestroy()
+{// begin SpidermonkeyDestroy
+#ifdef ADM_JS_THREADSAFE
+	JS_SetContextThread(g_pCx);	
+#endif
+	JS_DestroyContext(g_pCx);
+	JS_DestroyRuntime(g_pRt);
+}// end SpidermonkeyDestroy
+
+void *StartThreadSpidermonkey(void *pData)
+{// begin StartThreadSpidermonkey
+        pthread_mutex_lock(&amp;g_pSpiderMonkeyMutex);
+        /*
+        The following mailling list post describes how to CORRECTLY use
+        the threading API support with Spidermonkey
+        &quot;Thread from SpiderMonkey newsgroup&quot;
+        <A HREF="http://archive.gingerall.cz/archives/public/sablot2004/msg00117.html">http://archive.gingerall.cz/archives/public/sablot2004/msg00117.html</A>
+        */
+        // Notify the Spidermonkey that we'll be processing in a thread
+#ifdef ADM_JS_THREADSAFE
+        JS_SetContextThread(g_pCx);
+        JS_BeginRequest(g_pCx);
+#endif
+        bool ret = false;
+        const char *pScriptFile = static_cast&lt;const char *&gt;(pData);
+        ret = parseECMAScript(pScriptFile);
+        if(ret == false)
+        {
+                if( actual_workbench_file )
+                        ADM_dealloc(actual_workbench_file);
+                actual_workbench_file = ADM_strdup(pScriptFile);
+        }
+        // Notify Spidermonkey that our thread processing has finished
+#ifdef ADM_JS_THREADSAFE
+        JS_EndRequest(g_pCx);
+        JS_ClearContextThread(g_pCx);
+#endif
+        pthread_mutex_unlock(&amp;g_pSpiderMonkeyMutex);
+
+        return NULL;
+}// end StartThreadSpidermonkey
+/**
+    \fn JS_setSuccess
+*/
+void JS_setSuccess(bool bSuccess)
+{// begin JS_setSuccess
+	g_bJSSuccess = bSuccess;
+	printf(&quot;[ECMA] success : %d\n&quot;, g_bJSSuccess);
+}// end JS_setSuccess
+/**
+    \fn ADM_jsExit
+*/
+bool ADM_jsExit(void)
+{
+    ADM_info(&quot;Waiting for Spidermonkey to finish...\n&quot;);
+    pthread_mutex_lock(&amp;g_pSpiderMonkeyMutex);
+    ADM_info(&quot;Cleaning up Spidermonkey.\n&quot;);
+    SpidermonkeyDestroy();
+    pthread_mutex_unlock(&amp;g_pSpiderMonkeyMutex);
+    return true;
+}
\ No newline at end of file

Added: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsIf_js.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsIf_js.c	2009-12-06 11:01:40 UTC (rev 5626)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsIf_js.c	2009-12-09 06:41:29 UTC (rev 5627)
@@ -0,0 +1,260 @@
+/*
+--- DO NOT EDIT THIS FILE !!! ---
+
+This file has been generated automatically with 'jsapigen'.
+
+jsapigen is a glue-code generator for SpiderMonkey. It is distributed
+under the conditions of version 3 of the GNU General Public License.
+Please have a look at <A HREF="http://jsapigen.sourceforge.net.">http://jsapigen.sourceforge.net.</A>
+
+This file is NOT part of jsapigen and is NOT necessarily covered by
+jsapigen's license. For licensing information regarding this file,
+please refer to the software package which it is part of.
+
+*/
+#include &lt;string.h&gt;
+#include &lt;wchar.h&gt;
+#include &lt;jsapi.h&gt;
+#ifndef JS_THREADSAFE
+#if JS_VERSION &lt;= 170
+#define jsrefcount int
+#define JS_BeginRequest(cx)
+#define JS_EndRequest(cx)
+#define JS_SuspendRequest(cx)
+#define JS_ResumeRequest(cx, saveDepth)
+#endif
+#endif
+#ifndef JS_FS
+#define JS_FS(name, call, nargs, flags, extra) {name, call, nargs, flags, extra}
+#endif
+#ifndef JS_FS_END
+#define JS_FS_END {NULL, NULL, 0, 0, 0}
+#endif
+static JSBool
+jjjsPopupError(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
+{
+    JSObject *var2;
+    char *var7;
+    int var6;
+    int var8;
+    jsval var9;
+    JSString *var10;
+    jsval var43;
+    size_t var11;
+    size_t var12;
+    int var14;
+    jschar *var13;
+    jsval var44;
+    JSBool var1;
+    var2 = NULL;
+    var7 = NULL;
+    var6 = 0;
+    var8 = 0;
+    var9 = JSVAL_NULL;
+    var10 = NULL;
+    var43 = JSVAL_NULL;
+    var11 = 0;
+    var12 = 0;
+    var14 = 0;
+    var13 = NULL;
+    var44 = JSVAL_NULL;
+    var1 = JS_FALSE;
+    var2 = obj;
+    var6 = argc;
+    var8 = 0;
+    var8 = var8 &lt; var6;
+    if (var8) {
+    var9 = argv[0];
+    var10 = JS_ValueToString(cx, var9);
+    if (!var10) {
+        goto do_return;
+    }
+    var43 = STRING_TO_JSVAL(var10);
+    argv[argc+0] = var43;
+    var11 = JS_GetStringLength(var10);
+    var12 = 1;
+    var12 += var11;
+    var7 = JS_malloc(cx, var12);
+    if (!var7) {
+        goto do_return;
+    }
+    var14 = 1;
+    var13 = JS_GetStringChars(var10);
+    var44 = STRING_TO_JSVAL(var10);
+    argv[argc+1] = var44;
+    {
+        size_t i;
+        for (i = 0; i &lt; var11; ++i) {
+            var7[i] = wctob(var13[i]);
+        }
+        var7[var11] = '\0';
+    }
+    }
+    admPopupError(var7);
+    var1 = JS_TRUE;
+    do_return:
+    if (var14) {
+        JS_free(cx, var7);
+        var7 = NULL;
+        var14 = 0;
+    }
+    return var1;
+}
+static JSBool
+jjjspPopupInfo(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
+{
+    JSObject *var16;
+    char *var21;
+    int var20;
+    int var22;
+    jsval var23;
+    JSString *var24;
+    jsval var45;
+    size_t var25;
+    size_t var26;
+    int var28;
+    jschar *var27;
+    jsval var46;
+    JSBool var15;
+    var16 = NULL;
+    var21 = NULL;
+    var20 = 0;
+    var22 = 0;
+    var23 = JSVAL_NULL;
+    var24 = NULL;
+    var45 = JSVAL_NULL;
+    var25 = 0;
+    var26 = 0;
+    var28 = 0;
+    var27 = NULL;
+    var46 = JSVAL_NULL;
+    var15 = JS_FALSE;
+    var16 = obj;
+    var20 = argc;
+    var22 = 0;
+    var22 = var22 &lt; var20;
+    if (var22) {
+    var23 = argv[0];
+    var24 = JS_ValueToString(cx, var23);
+    if (!var24) {
+        goto do_return;
+    }
+    var45 = STRING_TO_JSVAL(var24);
+    argv[argc+0] = var45;
+    var25 = JS_GetStringLength(var24);
+    var26 = 1;
+    var26 += var25;
+    var21 = JS_malloc(cx, var26);
+    if (!var21) {
+        goto do_return;
+    }
+    var28 = 1;
+    var27 = JS_GetStringChars(var24);
+    var46 = STRING_TO_JSVAL(var24);
+    argv[argc+1] = var46;
+    {
+        size_t i;
+        for (i = 0; i &lt; var25; ++i) {
+            var21[i] = wctob(var27[i]);
+        }
+        var21[var25] = '\0';
+    }
+    }
+    admPopupInfo(var21);
+    var15 = JS_TRUE;
+    do_return:
+    if (var28) {
+        JS_free(cx, var21);
+        var21 = NULL;
+        var28 = 0;
+    }
+    return var15;
+}
+static JSBool
+jjjsPrint(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
+{
+    JSObject *var30;
+    char *var35;
+    int var34;
+    int var36;
+    jsval var37;
+    JSString *var38;
+    jsval var47;
+    size_t var39;
+    size_t var40;
+    int var42;
+    jschar *var41;
+    jsval var48;
+    JSBool var29;
+    var30 = NULL;
+    var35 = NULL;
+    var34 = 0;
+    var36 = 0;
+    var37 = JSVAL_NULL;
+    var38 = NULL;
+    var47 = JSVAL_NULL;
+    var39 = 0;
+    var40 = 0;
+    var42 = 0;
+    var41 = NULL;
+    var48 = JSVAL_NULL;
+    var29 = JS_FALSE;
+    var30 = obj;
+    var34 = argc;
+    var36 = 0;
+    var36 = var36 &lt; var34;
+    if (var36) {
+    var37 = argv[0];
+    var38 = JS_ValueToString(cx, var37);
+    if (!var38) {
+        goto do_return;
+    }
+    var47 = STRING_TO_JSVAL(var38);
+    argv[argc+0] = var47;
+    var39 = JS_GetStringLength(var38);
+    var40 = 1;
+    var40 += var39;
+    var35 = JS_malloc(cx, var40);
+    if (!var35) {
+        goto do_return;
+    }
+    var42 = 1;
+    var41 = JS_GetStringChars(var38);
+    var48 = STRING_TO_JSVAL(var38);
+    argv[argc+1] = var48;
+    {
+        size_t i;
+        for (i = 0; i &lt; var39; ++i) {
+            var35[i] = wctob(var41[i]);
+        }
+        var35[var39] = '\0';
+    }
+    }
+    admPrint(var35);
+    var29 = JS_TRUE;
+    do_return:
+    if (var42) {
+        JS_free(cx, var35);
+        var35 = NULL;
+        var42 = 0;
+    }
+    return var29;
+}
+static JSPropertySpec jj_static_ps[] = {
+    {NULL, 0, 0, NULL, NULL}
+};
+static JSPropertySpec jj_ps[] = {
+    {NULL, 0, 0, NULL, NULL}
+};
+static JSFunctionSpec jj_static_fs[] = {
+    JS_FS(&quot;jsPopupError&quot;, jjjsPopupError, 1, 0, 2),
+    JS_FS(&quot;jspPopupInfo&quot;, jjjspPopupInfo, 1, 0, 2),
+    JS_FS(&quot;jsPrint&quot;, jjjsPrint, 1, 0, 2),
+    JS_FS_END
+};
+static JSFunctionSpec jj_fs[] = {
+    JS_FS(&quot;jsPopupError&quot;, jjjsPopupError, 1, 0, 2),
+    JS_FS(&quot;jspPopupInfo&quot;, jjjspPopupInfo, 1, 0, 2),
+    JS_FS(&quot;jsPrint&quot;, jjjsPrint, 1, 0, 2),
+    JS_FS_END
+};

Added: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsIf_js.idl
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsIf_js.idl	2009-12-06 11:01:40 UTC (rev 5626)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsIf_js.idl	2009-12-09 06:41:29 UTC (rev 5627)
@@ -0,0 +1,10 @@
+/*
+###############################################################
+       return C function     JS Function  params
+###############################################################
+*/
+function void jsPopupError : admPopupError   (cstring  ) &lt;static&gt;;
+function void jspPopupInfo : admPopupInfo    (cstring  ) &lt;static&gt;;
+function void jsPrint      : admPrint        (cstring  ) &lt;static&gt;;
+
+

Added: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsTestFactory.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsTestFactory.cpp	2009-12-06 11:01:40 UTC (rev 5626)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsTestFactory.cpp	2009-12-09 06:41:29 UTC (rev 5627)
@@ -0,0 +1,429 @@
+/**
+    \file ADM_JSif.cpp
+    \brief interface to js
+
+ Author: Anish Mistry/mean/gruntster
+*/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include &quot;ADM_js.h&quot;
+#include &quot;ADM_editor/ADM_edit.hxx&quot;
+#include &quot;DIA_fileSel.h&quot;
+#include &quot;DIA_factory.h&quot;
+
+
+extern &quot;C&quot;
+{
+    void jsCrashTest(void);
+    void jsAssertTest(void);
+}
+
+/**
+    \fn crashTest
+    \brief Force a crash
+*/
+void jsCrashTest(void)
+{
+  
+  int *foobar=NULL;
+  *foobar=0; // CRASH!
+
+}
+/**
+    \fn assertTest
+    \brief Force a crash
+*/
+void jsAssertTest(void)
+{
+  
+  ADM_assert(0);
+
+}
+
+
+/**
+    \fn jsFacInt
+*/
+bool jsFacInt(void)
+{
+  uint32_t tog=0;
+   diaElemUInteger blend(&amp;tog,QT_TR_NOOP(&quot;Uinteger&quot;),0,255);
+    diaElem *elems[]={&amp;blend   };
+    
+  if(diaFactoryRun(QT_TR_NOOP(&quot;Test uinteger&quot;),1,elems))
+  {
+    jsLog(JS_LOG_NORMAL,&quot;Value : %u\n&quot;,tog);
+    return true;
+  }
+  return false;
+}
+
+/**
+    \fn jsFacFloat
+*/
+bool jsFacFloat(void)
+{
+  ELEM_TYPE_FLOAT tog=0;
+   diaElemFloat blend(&amp;tog,QT_TR_NOOP(&quot;Float&quot;),0,255);
+    diaElem *elems[]={&amp;blend   };
+    
+  if(diaFactoryRun(&quot;Test float&quot;,1,elems))
+  {
+    jsLog(JS_LOG_NORMAL,&quot;Value : %f\n&quot;,(float)tog);
+    return true;
+  }
+  return false;
+}
+
+/**
+    \fn jsFacToggle
+*/
+bool jsFacToggle(void)
+{
+  uint32_t tog=0;
+  uint32_t test=0;
+   diaElemToggle blend(&amp;tog,QT_TR_NOOP(&quot;Toggle&quot;));
+    diaElemUInteger     bt(&amp;test,&quot;Entry&quot;,0,10);
+    diaElemUInteger     bt2(&amp;test,&quot;Entry&quot;,0,10);
+    diaElem *elems[]={&amp;blend,&amp;bt,&amp;bt2   };
+    blend.link(1,&amp;bt);
+    blend.link(0,&amp;bt2);
+    
+  if(diaFactoryRun(&quot;Test Toggle&quot;,3,elems))
+   {
+    jsLog(JS_LOG_NORMAL,&quot;Value : %u\n&quot;,tog);
+    return true;
+  }
+  return false;
+}
+
+/**
+    \fn jsFacMenu
+*/
+bool jsFacMenu(void)
+{
+   uint32_t tog=4;
+   ELEM_TYPE_FLOAT f=1; 
+   
+    diaMenuEntry menu[]={
+                             {2,   QT_TR_NOOP(&quot;No Strategy&quot;),NULL},
+                             {4,     QT_TR_NOOP(&quot;3:2 Pulldown&quot;),NULL},
+                             {6,     QT_TR_NOOP(&quot;Pal/Secam&quot;),NULL},
+                             {7,  QT_TR_NOOP(&quot;NTSC converted from PAL&quot;),NULL}
+                          };
+   diaElemMenu blend(&amp;tog,QT_TR_NOOP(&quot;menu&quot;),4,menu);
+    
+    // Link it to another
+    diaElemFloat toggle(&amp;f,&quot;Linked float&quot;,1,2);
+    blend.link(&amp;(menu[1]),1,&amp;toggle);
+    //
+diaElem *elems[]={&amp;blend,&amp;toggle   };
+  if(diaFactoryRun(&quot;Test Menu&quot;,2,elems))
+   {
+    jsLog(JS_LOG_NORMAL,&quot;Value : %&quot;LU&quot;\n&quot;,tog);
+    return true;
+  }
+  return false;
+}
+
+/**
+    \fn jsFacFile
+*/
+bool jsFacFile(void)
+{
+   uint32_t tog=0;
+   char *test=ADM_strdup(&quot;Entry test1&quot;);
+    
+      diaElemFile fread(0,&amp;test,&quot;Entry&quot;);
+      diaElem *elems[]={&amp;fread   };
+  if(diaFactoryRun(&quot;Test FileRead&quot;,1,elems))
+   {
+    jsLog(JS_LOG_NORMAL,&quot;Value : %s\n&quot;,test);
+    if(test) ADM_dealloc(test);
+    return true;
+  }
+ if(test) ADM_dealloc(test);
+  return false;
+}
+
+/**
+    \fn jsFacDirSel
+*/
+bool jsFacDirSel(void)
+{
+   uint32_t tog=0;
+   char *test=ADM_strdup(&quot;Entry test1&quot;);
+    
+  diaElemDirSelect fread(&amp;test,&quot;Entry&quot;);
+  diaElem *elems[]={&amp;fread   };
+  if(diaFactoryRun(&quot;Test DirSel&quot;,1,elems))
+  {
+    jsLog(JS_LOG_NORMAL,&quot;Value : %s\n&quot;,test);
+    if(test) ADM_dealloc(test);
+    return true;
+  }
+ if(test) ADM_dealloc(test);
+  return false;
+}
+
+/**
+    \fn jsFacBitrate
+*/
+bool jsFacBitrate(void)
+{
+
+   COMPRES_PARAMS test={
+  COMPRESS_CQ,
+  1,
+  1500,
+  700,
+  1000,
+  ADM_ENC_CAP_CQ+ADM_ENC_CAP_2PASS+ADM_ENC_CAP_CBR+ADM_ENC_CAP_SAME
+  };
+    
+      diaElemBitrate bt(&amp;test,&quot;Entry&quot;);
+      diaElem *elems[]={&amp;bt   };
+  if(diaFactoryRun(&quot;Test BitRate&quot;,1,elems))
+   {
+    
+    return true;
+  }
+  return false;
+}
+
+/**
+    \fn jsFacInt
+*/
+bool jsFacBar(void)
+{
+    
+      diaElemBar bar1(25,&quot;25&quot;);
+      diaElemBar bar2(65,&quot;65&quot;);
+      diaElem *elems[]={&amp;bar1,&amp;bar2   };
+  if(diaFactoryRun(&quot;Test FileRead&quot;,2,elems))
+  {
+   return true;
+  }
+  return false;
+}
+
+void clickMe(void *cookie)
+{
+  GUI_Error_HIG(&quot;Button&quot;,&quot;Button pressed!&quot;); 
+}
+
+/**
+    \fn jsFacButton
+*/
+bool jsFacButton(void)
+{
+    
+      diaElemButton bar1(&quot;Button&quot;,clickMe,NULL);
+      diaElem *elems[]={&amp;bar1   };
+  if(diaFactoryRun(&quot;Test Button&quot;,1,elems))
+  {
+    return true;
+  }
+  return false;
+}
+
+/**
+    \fn jsFacSlider
+*/
+bool jsFacSlider(void)
+{
+  int32_t val=4;
+      diaElemSlider slide(&amp;val,&quot;foo&quot;, 0,10);
+      
+      diaElem *elems[]={&amp;slide   };
+  if(diaFactoryRun(&quot;Test Slider&quot;,1,elems))
+  {
+    jsLog(JS_LOG_NORMAL,&quot;Value : %d\n&quot;,(int)val);
+    return true;
+  }
+  return false;
+}
+
+/**
+    \fn jsFacInt
+*/
+bool jsFacRoText(void)
+
+{
+    
+      diaElemReadOnlyText txt(&quot;blah blah&quot;,&quot;Value:&quot;);
+      
+      diaElem *elems[]={&amp;txt   };
+  if(diaFactoryRun(&quot;Test FileRead&quot;,1,elems))
+  {
+    return true;
+  }
+  return false;
+}
+
+/**
+    \fn jsFacText
+*/
+bool jsFacText(void)
+{
+    
+      char *foo=ADM_strdup(&quot;blah&quot;);
+      diaElemText txt(&amp;foo,&quot;Text&quot;,NULL);
+      
+      diaElem *elems[]={&amp;txt   };
+  if(diaFactoryRun(&quot;Test FileRead&quot;,1,elems))
+ {
+    jsLog(JS_LOG_NORMAL,&quot;Out:%s&quot;,foo);
+    if(foo) ADM_dealloc(foo);
+    return true;
+  }
+  if(foo) ADM_dealloc(foo);
+  return false;
+}
+
+/**
+    \fn jsFacInt
+*/
+bool jsFacTab(void)
+{
+    
+      uint32_t test,test2;
+      
+      diaElemReadOnlyText txt(&quot;blah blah&quot;,&quot;Value:&quot;);
+      diaElemUInteger     bt(&amp;test,&quot;Entry&quot;,0,10);
+      diaElemUInteger     bt2(&amp;test2,&quot;Entry&quot;,0,10);
+      
+      
+      diaElem *elems1[]={&amp;txt   };
+      diaElem *elems2[]={&amp;bt,&amp;bt2   };
+      
+      diaElemTabs tab1(&quot;T1&quot;,1,(diaElem **)elems1);
+      diaElemTabs tab2(&quot;T2&quot;,2,(diaElem **)elems2);
+      
+      diaElemTabs *tabs[2]={&amp;tab1,&amp;tab2};
+          
+      
+  if(diaFactoryRunTabs(&quot;Test FileRead&quot;,2,tabs))
+ {
+    return true;
+  }
+  return false;
+}
+
+/**
+    \fn jsFacInt
+*/
+bool jsFacFrame(void)
+{
+    
+      uint32_t test,test2;
+      
+      diaElemReadOnlyText align(&quot;*****&quot;,&quot;Value:&quot;);
+      diaElemReadOnlyText txt(&quot;blah blah&quot;,&quot;Value:&quot;);
+      diaElemUInteger     bt(&amp;test,&quot;Entry1&quot;,0,10);
+      diaElemUInteger     bt2(&amp;test2,&quot;Entry2&quot;,0,10);
+      diaElemFrame        frm(&quot;Frame1&quot;);
+      
+      frm.swallow(&amp;txt);
+      frm.swallow(&amp;bt);
+      frm.swallow(&amp;bt2);
+      
+         diaElem *elems[]={&amp;align,&amp;frm   };
+  if(diaFactoryRun(&quot;Test frame&quot;,2,elems))
+ {
+    return true;
+  }
+  return false;
+}
+
+
+/**
+    \fn jsFacHex
+*/
+bool jsFacHex(void)
+{
+    
+      uint8_t data[100];
+      for(int i=0;i&lt;100;i++) data[i]=i;
+      
+      diaElemHex binhex(&quot;*****&quot;,100,data);
+      
+      
+         diaElem *elems[]={&amp;binhex   };
+  if(diaFactoryRun(&quot;Test binHex&quot;,1,elems))
+  {
+    return true;
+  }
+  return false;
+      
+}
+
+/**
+    \fn jsFacMatrix
+*/
+bool jsFacMatrix(void)
+{
+    
+      uint8_t data[16];
+      for(int i=0;i&lt;100;i++) data[i]=i;
+      
+      diaElemMatrix Matrix(data,&quot;Matrix&quot;,4);
+      
+      
+         diaElem *elems[]={&amp;Matrix   };
+  if(diaFactoryRun(&quot;Test Matrix&quot;,1,elems))
+  {
+      for(int x=0;x&lt;4*4;x++)
+      {
+          if(x &amp;&amp; !(x&amp;3)) printf(&quot;\n&quot;);
+          jsLog(JS_LOG_NORMAL,&quot;%02x &quot;,data[x]);
+          
+      }
+      return true;
+  }
+  return false;
+}
+
+/**
+    \fn jsFacThreadcount
+*/
+bool jsFacThreadcount(void)
+{
+	uint32_t val=1;
+	diaElemThreadCount threadcount(&amp;val,&quot;ThreadCount&quot;);
+      
+    diaElem *elems[]={&amp;threadcount   };
+    
+  if(diaFactoryRun(&quot;Test ThreadCount&quot;,1,elems))
+  {
+         jsLog(JS_LOG_NORMAL,&quot;Thread: %u &quot;,(unsigned int)val);
+        return true;
+  }
+  return false;
+}
+
+/**
+    \fn jsFacNotch
+*/
+bool jsFacNotch(void)
+{
+    
+	diaElemNotch notch(1,&quot;Notch&quot;);
+      
+         diaElem *elems[]={&amp;notch   };
+  if(diaFactoryRun(&quot;Test Notch&quot;,1,elems))
+  {
+    return true;
+  }
+  return false;
+      
+}
+
+//EOF 

Added: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsTestFactory_js.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsTestFactory_js.c	2009-12-06 11:01:40 UTC (rev 5626)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsTestFactory_js.c	2009-12-09 06:41:29 UTC (rev 5627)
@@ -0,0 +1,1500 @@
+/*
+--- DO NOT EDIT THIS FILE !!! ---
+
+This file has been generated automatically with 'jsapigen'.
+
+jsapigen is a glue-code generator for SpiderMonkey. It is distributed
+under the conditions of version 3 of the GNU General Public License.
+Please have a look at <A HREF="http://jsapigen.sourceforge.net.">http://jsapigen.sourceforge.net.</A>
+
+This file is NOT part of jsapigen and is NOT necessarily covered by
+jsapigen's license. For licensing information regarding this file,
+please refer to the software package which it is part of.
+
+*/
+#include &lt;string.h&gt;
+#include &lt;wchar.h&gt;
+#include &lt;jsapi.h&gt;
+#ifndef JS_THREADSAFE
+#if JS_VERSION &lt;= 170
+#define jsrefcount int
+#define JS_BeginRequest(cx)
+#define JS_EndRequest(cx)
+#define JS_SuspendRequest(cx)
+#define JS_ResumeRequest(cx, saveDepth)
+#endif
+#endif
+#ifndef JS_FS
+#define JS_FS(name, call, nargs, flags, extra) {name, call, nargs, flags, extra}
+#endif
+#ifndef JS_FS_END
+#define JS_FS_END {NULL, NULL, 0, 0, 0}
+#endif
+static JSBool
+jjjsTestFacInt(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
+{
+    JSObject *var2;
+    void *var3;
+    int var6;
+    jsval var7;
+    JSObject *var8;
+    JSObject *var9;
+    JSClass *var10;
+    char *var12;
+    JSBool var14;
+    jsval var15;
+    JSObject *var16;
+    jsval var373;
+    char *var20;
+    JSBool var17;
+    jsval var18;
+    JSObject *var19;
+    jsval var374;
+    JSObject *var11;
+    jsval var375;
+    JSBool var1;
+    var2 = NULL;
+    var3 = NULL;
+    var6 = 0;
+    var7 = JSVAL_NULL;
+    var8 = NULL;
+    var9 = NULL;
+    var10 = NULL;
+    var12 = NULL;
+    var14 = JS_FALSE;
+    var15 = JSVAL_NULL;
+    var16 = NULL;
+    var373 = JSVAL_NULL;
+    var20 = NULL;
+    var17 = JS_FALSE;
+    var18 = JSVAL_NULL;
+    var19 = NULL;
+    var374 = JSVAL_NULL;
+    var11 = NULL;
+    var375 = JSVAL_NULL;
+    var1 = JS_FALSE;
+    var2 = obj;
+    var6 = argc;
+    var3 = admFacInt();
+    var9 = JS_GetGlobalObject(cx);
+    var12 = &quot;bool&quot;;
+    var14 = JS_GetProperty(cx, var9, var12, &amp;var15);
+    if (JS_ValueToObject(cx, var15, &amp;var16) != JS_TRUE) {
+        goto do_return;
+    }
+    var373 = OBJECT_TO_JSVAL(var16);
+    argv[argc+0] = var373;
+    var20 = &quot;prototype&quot;;
+    var17 = JS_GetProperty(cx, var16, var20, &amp;var18);
+    if (JS_ValueToObject(cx, var18, &amp;var19) != JS_TRUE) {
+        goto do_return;
+    }
+    var374 = OBJECT_TO_JSVAL(var19);
+    argv[argc+1] = var374;
+    var10 = JS_GET_CLASS(cx, var19);
+    var11 = NULL;
+    var8 = JS_NewObject(cx, var10, var11, var9);
+    var375 = OBJECT_TO_JSVAL(var8);
+    argv[argc+2] = var375;
+    if (JS_SetPrivate(cx, var8, var3) != JS_TRUE) {
+        goto do_return;
+    }
+    var7 = OBJECT_TO_JSVAL(var8);
+    if (rval) {
+        *rval = var7;
+    }
+    var1 = JS_TRUE;
+    do_return:
+    return var1;
+}
+static JSBool
+jjjsTestFacFloat(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
+{
+    JSObject *var22;
+    void *var23;
+    int var26;
+    jsval var27;
+    JSObject *var28;
+    JSObject *var29;
+    JSClass *var30;
+    char *var32;
+    JSBool var34;
+    jsval var35;
+    JSObject *var36;
+    jsval var376;
+    char *var40;
+    JSBool var37;
+    jsval var38;
+    JSObject *var39;
+    jsval var377;
+    JSObject *var31;
+    jsval var378;
+    JSBool var21;
+    var22 = NULL;
+    var23 = NULL;
+    var26 = 0;
+    var27 = JSVAL_NULL;
+    var28 = NULL;
+    var29 = NULL;
+    var30 = NULL;
+    var32 = NULL;
+    var34 = JS_FALSE;
+    var35 = JSVAL_NULL;
+    var36 = NULL;
+    var376 = JSVAL_NULL;
+    var40 = NULL;
+    var37 = JS_FALSE;
+    var38 = JSVAL_NULL;
+    var39 = NULL;
+    var377 = JSVAL_NULL;
+    var31 = NULL;
+    var378 = JSVAL_NULL;
+    var21 = JS_FALSE;
+    var22 = obj;
+    var26 = argc;
+    var23 = admFacFloat();
+    var29 = JS_GetGlobalObject(cx);
+    var32 = &quot;bool&quot;;
+    var34 = JS_GetProperty(cx, var29, var32, &amp;var35);
+    if (JS_ValueToObject(cx, var35, &amp;var36) != JS_TRUE) {
+        goto do_return;
+    }
+    var376 = OBJECT_TO_JSVAL(var36);
+    argv[argc+0] = var376;
+    var40 = &quot;prototype&quot;;
+    var37 = JS_GetProperty(cx, var36, var40, &amp;var38);
+    if (JS_ValueToObject(cx, var38, &amp;var39) != JS_TRUE) {
+        goto do_return;
+    }
+    var377 = OBJECT_TO_JSVAL(var39);
+    argv[argc+1] = var377;
+    var30 = JS_GET_CLASS(cx, var39);
+    var31 = NULL;
+    var28 = JS_NewObject(cx, var30, var31, var29);
+    var378 = OBJECT_TO_JSVAL(var28);
+    argv[argc+2] = var378;
+    if (JS_SetPrivate(cx, var28, var23) != JS_TRUE) {
+        goto do_return;
+    }
+    var27 = OBJECT_TO_JSVAL(var28);
+    if (rval) {
+        *rval = var27;
+    }
+    var21 = JS_TRUE;
+    do_return:
+    return var21;
+}
+static JSBool
+jjjsTestFacToggle(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
+{
+    JSObject *var42;
+    void *var43;
+    int var46;
+    jsval var47;
+    JSObject *var48;
+    JSObject *var49;
+    JSClass *var50;
+    char *var52;
+    JSBool var54;
+    jsval var55;
+    JSObject *var56;
+    jsval var379;
+    char *var60;
+    JSBool var57;
+    jsval var58;
+    JSObject *var59;
+    jsval var380;
+    JSObject *var51;
+    jsval var381;
+    JSBool var41;
+    var42 = NULL;
+    var43 = NULL;
+    var46 = 0;
+    var47 = JSVAL_NULL;
+    var48 = NULL;
+    var49 = NULL;
+    var50 = NULL;
+    var52 = NULL;
+    var54 = JS_FALSE;
+    var55 = JSVAL_NULL;
+    var56 = NULL;
+    var379 = JSVAL_NULL;
+    var60 = NULL;
+    var57 = JS_FALSE;
+    var58 = JSVAL_NULL;
+    var59 = NULL;
+    var380 = JSVAL_NULL;
+    var51 = NULL;
+    var381 = JSVAL_NULL;
+    var41 = JS_FALSE;
+    var42 = obj;
+    var46 = argc;
+    var43 = admFacToggle();
+    var49 = JS_GetGlobalObject(cx);
+    var52 = &quot;bool&quot;;
+    var54 = JS_GetProperty(cx, var49, var52, &amp;var55);
+    if (JS_ValueToObject(cx, var55, &amp;var56) != JS_TRUE) {
+        goto do_return;
+    }
+    var379 = OBJECT_TO_JSVAL(var56);
+    argv[argc+0] = var379;
+    var60 = &quot;prototype&quot;;
+    var57 = JS_GetProperty(cx, var56, var60, &amp;var58);
+    if (JS_ValueToObject(cx, var58, &amp;var59) != JS_TRUE) {
+        goto do_return;
+    }
+    var380 = OBJECT_TO_JSVAL(var59);
+    argv[argc+1] = var380;
+    var50 = JS_GET_CLASS(cx, var59);
+    var51 = NULL;
+    var48 = JS_NewObject(cx, var50, var51, var49);
+    var381 = OBJECT_TO_JSVAL(var48);
+    argv[argc+2] = var381;
+    if (JS_SetPrivate(cx, var48, var43) != JS_TRUE) {
+        goto do_return;
+    }
+    var47 = OBJECT_TO_JSVAL(var48);
+    if (rval) {
+        *rval = var47;
+    }
+    var41 = JS_TRUE;
+    do_return:
+    return var41;
+}
+static JSBool
+jjjsTestFacMenu(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
+{
+    JSObject *var62;
+    void *var63;
+    int var66;
+    jsval var67;
+    JSObject *var68;
+    JSObject *var69;
+    JSClass *var70;
+    char *var72;
+    JSBool var74;
+    jsval var75;
+    JSObject *var76;
+    jsval var382;
+    char *var80;
+    JSBool var77;
+    jsval var78;
+    JSObject *var79;
+    jsval var383;
+    JSObject *var71;
+    jsval var384;
+    JSBool var61;
+    var62 = NULL;
+    var63 = NULL;
+    var66 = 0;
+    var67 = JSVAL_NULL;
+    var68 = NULL;
+    var69 = NULL;
+    var70 = NULL;
+    var72 = NULL;
+    var74 = JS_FALSE;
+    var75 = JSVAL_NULL;
+    var76 = NULL;
+    var382 = JSVAL_NULL;
+    var80 = NULL;
+    var77 = JS_FALSE;
+    var78 = JSVAL_NULL;
+    var79 = NULL;
+    var383 = JSVAL_NULL;
+    var71 = NULL;
+    var384 = JSVAL_NULL;
+    var61 = JS_FALSE;
+    var62 = obj;
+    var66 = argc;
+    var63 = admFacMenu();
+    var69 = JS_GetGlobalObject(cx);
+    var72 = &quot;bool&quot;;
+    var74 = JS_GetProperty(cx, var69, var72, &amp;var75);
+    if (JS_ValueToObject(cx, var75, &amp;var76) != JS_TRUE) {
+        goto do_return;
+    }
+    var382 = OBJECT_TO_JSVAL(var76);
+    argv[argc+0] = var382;
+    var80 = &quot;prototype&quot;;
+    var77 = JS_GetProperty(cx, var76, var80, &amp;var78);
+    if (JS_ValueToObject(cx, var78, &amp;var79) != JS_TRUE) {
+        goto do_return;
+    }
+    var383 = OBJECT_TO_JSVAL(var79);
+    argv[argc+1] = var383;
+    var70 = JS_GET_CLASS(cx, var79);
+    var71 = NULL;
+    var68 = JS_NewObject(cx, var70, var71, var69);
+    var384 = OBJECT_TO_JSVAL(var68);
+    argv[argc+2] = var384;
+    if (JS_SetPrivate(cx, var68, var63) != JS_TRUE) {
+        goto do_return;
+    }
+    var67 = OBJECT_TO_JSVAL(var68);
+    if (rval) {
+        *rval = var67;
+    }
+    var61 = JS_TRUE;
+    do_return:
+    return var61;
+}
+static JSBool
+jjjsTestFacFile(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
+{
+    JSObject *var82;
+    void *var83;
+    int var86;
+    jsval var87;
+    JSObject *var88;
+    JSObject *var89;
+    JSClass *var90;
+    char *var92;
+    JSBool var94;
+    jsval var95;
+    JSObject *var96;
+    jsval var385;
+    char *var100;
+    JSBool var97;
+    jsval var98;
+    JSObject *var99;
+    jsval var386;
+    JSObject *var91;
+    jsval var387;
+    JSBool var81;
+    var82 = NULL;
+    var83 = NULL;
+    var86 = 0;
+    var87 = JSVAL_NULL;
+    var88 = NULL;
+    var89 = NULL;
+    var90 = NULL;
+    var92 = NULL;
+    var94 = JS_FALSE;
+    var95 = JSVAL_NULL;
+    var96 = NULL;
+    var385 = JSVAL_NULL;
+    var100 = NULL;
+    var97 = JS_FALSE;
+    var98 = JSVAL_NULL;
+    var99 = NULL;
+    var386 = JSVAL_NULL;
+    var91 = NULL;
+    var387 = JSVAL_NULL;
+    var81 = JS_FALSE;
+    var82 = obj;
+    var86 = argc;
+    var83 = admFacFile();
+    var89 = JS_GetGlobalObject(cx);
+    var92 = &quot;bool&quot;;
+    var94 = JS_GetProperty(cx, var89, var92, &amp;var95);
+    if (JS_ValueToObject(cx, var95, &amp;var96) != JS_TRUE) {
+        goto do_return;
+    }
+    var385 = OBJECT_TO_JSVAL(var96);
+    argv[argc+0] = var385;
+    var100 = &quot;prototype&quot;;
+    var97 = JS_GetProperty(cx, var96, var100, &amp;var98);
+    if (JS_ValueToObject(cx, var98, &amp;var99) != JS_TRUE) {
+        goto do_return;
+    }
+    var386 = OBJECT_TO_JSVAL(var99);
+    argv[argc+1] = var386;
+    var90 = JS_GET_CLASS(cx, var99);
+    var91 = NULL;
+    var88 = JS_NewObject(cx, var90, var91, var89);
+    var387 = OBJECT_TO_JSVAL(var88);
+    argv[argc+2] = var387;
+    if (JS_SetPrivate(cx, var88, var83) != JS_TRUE) {
+        goto do_return;
+    }
+    var87 = OBJECT_TO_JSVAL(var88);
+    if (rval) {
+        *rval = var87;
+    }
+    var81 = JS_TRUE;
+    do_return:
+    return var81;
+}
+static JSBool
+jjjsTestFacBitrate(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
+{
+    JSObject *var102;
+    void *var103;
+    int var106;
+    jsval var107;
+    JSObject *var108;
+    JSObject *var109;
+    JSClass *var110;
+    char *var112;
+    JSBool var114;
+    jsval var115;
+    JSObject *var116;
+    jsval var388;
+    char *var120;
+    JSBool var117;
+    jsval var118;
+    JSObject *var119;
+    jsval var389;
+    JSObject *var111;
+    jsval var390;
+    JSBool var101;
+    var102 = NULL;
+    var103 = NULL;
+    var106 = 0;
+    var107 = JSVAL_NULL;
+    var108 = NULL;
+    var109 = NULL;
+    var110 = NULL;
+    var112 = NULL;
+    var114 = JS_FALSE;
+    var115 = JSVAL_NULL;
+    var116 = NULL;
+    var388 = JSVAL_NULL;
+    var120 = NULL;
+    var117 = JS_FALSE;
+    var118 = JSVAL_NULL;
+    var119 = NULL;
+    var389 = JSVAL_NULL;
+    var111 = NULL;
+    var390 = JSVAL_NULL;
+    var101 = JS_FALSE;
+    var102 = obj;
+    var106 = argc;
+    var103 = admFacBitrate();
+    var109 = JS_GetGlobalObject(cx);
+    var112 = &quot;bool&quot;;
+    var114 = JS_GetProperty(cx, var109, var112, &amp;var115);
+    if (JS_ValueToObject(cx, var115, &amp;var116) != JS_TRUE) {
+        goto do_return;
+    }
+    var388 = OBJECT_TO_JSVAL(var116);
+    argv[argc+0] = var388;
+    var120 = &quot;prototype&quot;;
+    var117 = JS_GetProperty(cx, var116, var120, &amp;var118);
+    if (JS_ValueToObject(cx, var118, &amp;var119) != JS_TRUE) {
+        goto do_return;
+    }
+    var389 = OBJECT_TO_JSVAL(var119);
+    argv[argc+1] = var389;
+    var110 = JS_GET_CLASS(cx, var119);
+    var111 = NULL;
+    var108 = JS_NewObject(cx, var110, var111, var109);
+    var390 = OBJECT_TO_JSVAL(var108);
+    argv[argc+2] = var390;
+    if (JS_SetPrivate(cx, var108, var103) != JS_TRUE) {
+        goto do_return;
+    }
+    var107 = OBJECT_TO_JSVAL(var108);
+    if (rval) {
+        *rval = var107;
+    }
+    var101 = JS_TRUE;
+    do_return:
+    return var101;
+}
+static JSBool
+jjjsTestFacBar(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
+{
+    JSObject *var122;
+    void *var123;
+    int var126;
+    jsval var127;
+    JSObject *var128;
+    JSObject *var129;
+    JSClass *var130;
+    char *var132;
+    JSBool var134;
+    jsval var135;
+    JSObject *var136;
+    jsval var391;
+    char *var140;
+    JSBool var137;
+    jsval var138;
+    JSObject *var139;
+    jsval var392;
+    JSObject *var131;
+    jsval var393;
+    JSBool var121;
+    var122 = NULL;
+    var123 = NULL;
+    var126 = 0;
+    var127 = JSVAL_NULL;
+    var128 = NULL;
+    var129 = NULL;
+    var130 = NULL;
+    var132 = NULL;
+    var134 = JS_FALSE;
+    var135 = JSVAL_NULL;
+    var136 = NULL;
+    var391 = JSVAL_NULL;
+    var140 = NULL;
+    var137 = JS_FALSE;
+    var138 = JSVAL_NULL;
+    var139 = NULL;
+    var392 = JSVAL_NULL;
+    var131 = NULL;
+    var393 = JSVAL_NULL;
+    var121 = JS_FALSE;
+    var122 = obj;
+    var126 = argc;
+    var123 = admFacBar();
+    var129 = JS_GetGlobalObject(cx);
+    var132 = &quot;bool&quot;;
+    var134 = JS_GetProperty(cx, var129, var132, &amp;var135);
+    if (JS_ValueToObject(cx, var135, &amp;var136) != JS_TRUE) {
+        goto do_return;
+    }
+    var391 = OBJECT_TO_JSVAL(var136);
+    argv[argc+0] = var391;
+    var140 = &quot;prototype&quot;;
+    var137 = JS_GetProperty(cx, var136, var140, &amp;var138);
+    if (JS_ValueToObject(cx, var138, &amp;var139) != JS_TRUE) {
+        goto do_return;
+    }
+    var392 = OBJECT_TO_JSVAL(var139);
+    argv[argc+1] = var392;
+    var130 = JS_GET_CLASS(cx, var139);
+    var131 = NULL;
+    var128 = JS_NewObject(cx, var130, var131, var129);
+    var393 = OBJECT_TO_JSVAL(var128);
+    argv[argc+2] = var393;
+    if (JS_SetPrivate(cx, var128, var123) != JS_TRUE) {
+        goto do_return;
+    }
+    var127 = OBJECT_TO_JSVAL(var128);
+    if (rval) {
+        *rval = var127;
+    }
+    var121 = JS_TRUE;
+    do_return:
+    return var121;
+}
+static JSBool
+jjjsTestFacRoText(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
+{
+    JSObject *var142;
+    void *var143;
+    int var146;
+    jsval var147;
+    JSObject *var148;
+    JSObject *var149;
+    JSClass *var150;
+    char *var152;
+    JSBool var154;
+    jsval var155;
+    JSObject *var156;
+    jsval var394;
+    char *var160;
+    JSBool var157;
+    jsval var158;
+    JSObject *var159;
+    jsval var395;
+    JSObject *var151;
+    jsval var396;
+    JSBool var141;
+    var142 = NULL;
+    var143 = NULL;
+    var146 = 0;
+    var147 = JSVAL_NULL;
+    var148 = NULL;
+    var149 = NULL;
+    var150 = NULL;
+    var152 = NULL;
+    var154 = JS_FALSE;
+    var155 = JSVAL_NULL;
+    var156 = NULL;
+    var394 = JSVAL_NULL;
+    var160 = NULL;
+    var157 = JS_FALSE;
+    var158 = JSVAL_NULL;
+    var159 = NULL;
+    var395 = JSVAL_NULL;
+    var151 = NULL;
+    var396 = JSVAL_NULL;
+    var141 = JS_FALSE;
+    var142 = obj;
+    var146 = argc;
+    var143 = admFacRoText();
+    var149 = JS_GetGlobalObject(cx);
+    var152 = &quot;bool&quot;;
+    var154 = JS_GetProperty(cx, var149, var152, &amp;var155);
+    if (JS_ValueToObject(cx, var155, &amp;var156) != JS_TRUE) {
+        goto do_return;
+    }
+    var394 = OBJECT_TO_JSVAL(var156);
+    argv[argc+0] = var394;
+    var160 = &quot;prototype&quot;;
+    var157 = JS_GetProperty(cx, var156, var160, &amp;var158);
+    if (JS_ValueToObject(cx, var158, &amp;var159) != JS_TRUE) {
+        goto do_return;
+    }
+    var395 = OBJECT_TO_JSVAL(var159);
+    argv[argc+1] = var395;
+    var150 = JS_GET_CLASS(cx, var159);
+    var151 = NULL;
+    var148 = JS_NewObject(cx, var150, var151, var149);
+    var396 = OBJECT_TO_JSVAL(var148);
+    argv[argc+2] = var396;
+    if (JS_SetPrivate(cx, var148, var143) != JS_TRUE) {
+        goto do_return;
+    }
+    var147 = OBJECT_TO_JSVAL(var148);
+    if (rval) {
+        *rval = var147;
+    }
+    var141 = JS_TRUE;
+    do_return:
+    return var141;
+}
+static JSBool
+jjjsTestFacText(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
+{
+    JSObject *var162;
+    void *var163;
+    int var166;
+    jsval var167;
+    JSObject *var168;
+    JSObject *var169;
+    JSClass *var170;
+    char *var172;
+    JSBool var174;
+    jsval var175;
+    JSObject *var176;
+    jsval var397;
+    char *var180;
+    JSBool var177;
+    jsval var178;
+    JSObject *var179;
+    jsval var398;
+    JSObject *var171;
+    jsval var399;
+    JSBool var161;
+    var162 = NULL;
+    var163 = NULL;
+    var166 = 0;
+    var167 = JSVAL_NULL;
+    var168 = NULL;
+    var169 = NULL;
+    var170 = NULL;
+    var172 = NULL;
+    var174 = JS_FALSE;
+    var175 = JSVAL_NULL;
+    var176 = NULL;
+    var397 = JSVAL_NULL;
+    var180 = NULL;
+    var177 = JS_FALSE;
+    var178 = JSVAL_NULL;
+    var179 = NULL;
+    var398 = JSVAL_NULL;
+    var171 = NULL;
+    var399 = JSVAL_NULL;
+    var161 = JS_FALSE;
+    var162 = obj;
+    var166 = argc;
+    var163 = admFacText();
+    var169 = JS_GetGlobalObject(cx);
+    var172 = &quot;bool&quot;;
+    var174 = JS_GetProperty(cx, var169, var172, &amp;var175);
+    if (JS_ValueToObject(cx, var175, &amp;var176) != JS_TRUE) {
+        goto do_return;
+    }
+    var397 = OBJECT_TO_JSVAL(var176);
+    argv[argc+0] = var397;
+    var180 = &quot;prototype&quot;;
+    var177 = JS_GetProperty(cx, var176, var180, &amp;var178);
+    if (JS_ValueToObject(cx, var178, &amp;var179) != JS_TRUE) {
+        goto do_return;
+    }
+    var398 = OBJECT_TO_JSVAL(var179);
+    argv[argc+1] = var398;
+    var170 = JS_GET_CLASS(cx, var179);
+    var171 = NULL;
+    var168 = JS_NewObject(cx, var170, var171, var169);
+    var399 = OBJECT_TO_JSVAL(var168);
+    argv[argc+2] = var399;
+    if (JS_SetPrivate(cx, var168, var163) != JS_TRUE) {
+        goto do_return;
+    }
+    var167 = OBJECT_TO_JSVAL(var168);
+    if (rval) {
+        *rval = var167;
+    }
+    var161 = JS_TRUE;
+    do_return:
+    return var161;
+}
+static JSBool
+jjjsTestFacTab(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
+{
+    JSObject *var182;
+    void *var183;
+    int var186;
+    jsval var187;
+    JSObject *var188;
+    JSObject *var189;
+    JSClass *var190;
+    char *var192;
+    JSBool var194;
+    jsval var195;
+    JSObject *var196;
+    jsval var400;
+    char *var200;
+    JSBool var197;
+    jsval var198;
+    JSObject *var199;
+    jsval var401;
+    JSObject *var191;
+    jsval var402;
+    JSBool var181;
+    var182 = NULL;
+    var183 = NULL;
+    var186 = 0;
+    var187 = JSVAL_NULL;
+    var188 = NULL;
+    var189 = NULL;
+    var190 = NULL;
+    var192 = NULL;
+    var194 = JS_FALSE;
+    var195 = JSVAL_NULL;
+    var196 = NULL;
+    var400 = JSVAL_NULL;
+    var200 = NULL;
+    var197 = JS_FALSE;
+    var198 = JSVAL_NULL;
+    var199 = NULL;
+    var401 = JSVAL_NULL;
+    var191 = NULL;
+    var402 = JSVAL_NULL;
+    var181 = JS_FALSE;
+    var182 = obj;
+    var186 = argc;
+    var183 = admFacTab();
+    var189 = JS_GetGlobalObject(cx);
+    var192 = &quot;bool&quot;;
+    var194 = JS_GetProperty(cx, var189, var192, &amp;var195);
+    if (JS_ValueToObject(cx, var195, &amp;var196) != JS_TRUE) {
+        goto do_return;
+    }
+    var400 = OBJECT_TO_JSVAL(var196);
+    argv[argc+0] = var400;
+    var200 = &quot;prototype&quot;;
+    var197 = JS_GetProperty(cx, var196, var200, &amp;var198);
+    if (JS_ValueToObject(cx, var198, &amp;var199) != JS_TRUE) {
+        goto do_return;
+    }
+    var401 = OBJECT_TO_JSVAL(var199);
+    argv[argc+1] = var401;
+    var190 = JS_GET_CLASS(cx, var199);
+    var191 = NULL;
+    var188 = JS_NewObject(cx, var190, var191, var189);
+    var402 = OBJECT_TO_JSVAL(var188);
+    argv[argc+2] = var402;
+    if (JS_SetPrivate(cx, var188, var183) != JS_TRUE) {
+        goto do_return;
+    }
+    var187 = OBJECT_TO_JSVAL(var188);
+    if (rval) {
+        *rval = var187;
+    }
+    var181 = JS_TRUE;
+    do_return:
+    return var181;
+}
+static JSBool
+jjjsTestFrame(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
+{
+    JSObject *var202;
+    void *var203;
+    int var206;
+    jsval var207;
+    JSObject *var208;
+    JSObject *var209;
+    JSClass *var210;
+    char *var212;
+    JSBool var214;
+    jsval var215;
+    JSObject *var216;
+    jsval var403;
+    char *var220;
+    JSBool var217;
+    jsval var218;
+    JSObject *var219;
+    jsval var404;
+    JSObject *var211;
+    jsval var405;
+    JSBool var201;
+    var202 = NULL;
+    var203 = NULL;
+    var206 = 0;
+    var207 = JSVAL_NULL;
+    var208 = NULL;
+    var209 = NULL;
+    var210 = NULL;
+    var212 = NULL;
+    var214 = JS_FALSE;
+    var215 = JSVAL_NULL;
+    var216 = NULL;
+    var403 = JSVAL_NULL;
+    var220 = NULL;
+    var217 = JS_FALSE;
+    var218 = JSVAL_NULL;
+    var219 = NULL;
+    var404 = JSVAL_NULL;
+    var211 = NULL;
+    var405 = JSVAL_NULL;
+    var201 = JS_FALSE;
+    var202 = obj;
+    var206 = argc;
+    var203 = admFacFrame();
+    var209 = JS_GetGlobalObject(cx);
+    var212 = &quot;bool&quot;;
+    var214 = JS_GetProperty(cx, var209, var212, &amp;var215);
+    if (JS_ValueToObject(cx, var215, &amp;var216) != JS_TRUE) {
+        goto do_return;
+    }
+    var403 = OBJECT_TO_JSVAL(var216);
+    argv[argc+0] = var403;
+    var220 = &quot;prototype&quot;;
+    var217 = JS_GetProperty(cx, var216, var220, &amp;var218);
+    if (JS_ValueToObject(cx, var218, &amp;var219) != JS_TRUE) {
+        goto do_return;
+    }
+    var404 = OBJECT_TO_JSVAL(var219);
+    argv[argc+1] = var404;
+    var210 = JS_GET_CLASS(cx, var219);
+    var211 = NULL;
+    var208 = JS_NewObject(cx, var210, var211, var209);
+    var405 = OBJECT_TO_JSVAL(var208);
+    argv[argc+2] = var405;
+    if (JS_SetPrivate(cx, var208, var203) != JS_TRUE) {
+        goto do_return;
+    }
+    var207 = OBJECT_TO_JSVAL(var208);
+    if (rval) {
+        *rval = var207;
+    }
+    var201 = JS_TRUE;
+    do_return:
+    return var201;
+}
+static JSBool
+jjjsTestHex(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
+{
+    JSObject *var222;
+    void *var223;
+    int var226;
+    jsval var227;
+    JSObject *var228;
+    JSObject *var229;
+    JSClass *var230;
+    char *var232;
+    JSBool var234;
+    jsval var235;
+    JSObject *var236;
+    jsval var406;
+    char *var240;
+    JSBool var237;
+    jsval var238;
+    JSObject *var239;
+    jsval var407;
+    JSObject *var231;
+    jsval var408;
+    JSBool var221;
+    var222 = NULL;
+    var223 = NULL;
+    var226 = 0;
+    var227 = JSVAL_NULL;
+    var228 = NULL;
+    var229 = NULL;
+    var230 = NULL;
+    var232 = NULL;
+    var234 = JS_FALSE;
+    var235 = JSVAL_NULL;
+    var236 = NULL;
+    var406 = JSVAL_NULL;
+    var240 = NULL;
+    var237 = JS_FALSE;
+    var238 = JSVAL_NULL;
+    var239 = NULL;
+    var407 = JSVAL_NULL;
+    var231 = NULL;
+    var408 = JSVAL_NULL;
+    var221 = JS_FALSE;
+    var222 = obj;
+    var226 = argc;
+    var223 = admFacHex();
+    var229 = JS_GetGlobalObject(cx);
+    var232 = &quot;bool&quot;;
+    var234 = JS_GetProperty(cx, var229, var232, &amp;var235);
+    if (JS_ValueToObject(cx, var235, &amp;var236) != JS_TRUE) {
+        goto do_return;
+    }
+    var406 = OBJECT_TO_JSVAL(var236);
+    argv[argc+0] = var406;
+    var240 = &quot;prototype&quot;;
+    var237 = JS_GetProperty(cx, var236, var240, &amp;var238);
+    if (JS_ValueToObject(cx, var238, &amp;var239) != JS_TRUE) {
+        goto do_return;
+    }
+    var407 = OBJECT_TO_JSVAL(var239);
+    argv[argc+1] = var407;
+    var230 = JS_GET_CLASS(cx, var239);
+    var231 = NULL;
+    var228 = JS_NewObject(cx, var230, var231, var229);
+    var408 = OBJECT_TO_JSVAL(var228);
+    argv[argc+2] = var408;
+    if (JS_SetPrivate(cx, var228, var223) != JS_TRUE) {
+        goto do_return;
+    }
+    var227 = OBJECT_TO_JSVAL(var228);
+    if (rval) {
+        *rval = var227;
+    }
+    var221 = JS_TRUE;
+    do_return:
+    return var221;
+}
+static JSBool
+jjjsTestDirSel(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
+{
+    JSObject *var242;
+    void *var243;
+    int var246;
+    jsval var247;
+    JSObject *var248;
+    JSObject *var249;
+    JSClass *var250;
+    char *var252;
+    JSBool var254;
+    jsval var255;
+    JSObject *var256;
+    jsval var409;
+    char *var260;
+    JSBool var257;
+    jsval var258;
+    JSObject *var259;
+    jsval var410;
+    JSObject *var251;
+    jsval var411;
+    JSBool var241;
+    var242 = NULL;
+    var243 = NULL;
+    var246 = 0;
+    var247 = JSVAL_NULL;
+    var248 = NULL;
+    var249 = NULL;
+    var250 = NULL;
+    var252 = NULL;
+    var254 = JS_FALSE;
+    var255 = JSVAL_NULL;
+    var256 = NULL;
+    var409 = JSVAL_NULL;
+    var260 = NULL;
+    var257 = JS_FALSE;
+    var258 = JSVAL_NULL;
+    var259 = NULL;
+    var410 = JSVAL_NULL;
+    var251 = NULL;
+    var411 = JSVAL_NULL;
+    var241 = JS_FALSE;
+    var242 = obj;
+    var246 = argc;
+    var243 = admFacDirSel();
+    var249 = JS_GetGlobalObject(cx);
+    var252 = &quot;bool&quot;;
+    var254 = JS_GetProperty(cx, var249, var252, &amp;var255);
+    if (JS_ValueToObject(cx, var255, &amp;var256) != JS_TRUE) {
+        goto do_return;
+    }
+    var409 = OBJECT_TO_JSVAL(var256);
+    argv[argc+0] = var409;
+    var260 = &quot;prototype&quot;;
+    var257 = JS_GetProperty(cx, var256, var260, &amp;var258);
+    if (JS_ValueToObject(cx, var258, &amp;var259) != JS_TRUE) {
+        goto do_return;
+    }
+    var410 = OBJECT_TO_JSVAL(var259);
+    argv[argc+1] = var410;
+    var250 = JS_GET_CLASS(cx, var259);
+    var251 = NULL;
+    var248 = JS_NewObject(cx, var250, var251, var249);
+    var411 = OBJECT_TO_JSVAL(var248);
+    argv[argc+2] = var411;
+    if (JS_SetPrivate(cx, var248, var243) != JS_TRUE) {
+        goto do_return;
+    }
+    var247 = OBJECT_TO_JSVAL(var248);
+    if (rval) {
+        *rval = var247;
+    }
+    var241 = JS_TRUE;
+    do_return:
+    return var241;
+}
+static JSBool
+jjjsTestButton(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
+{
+    JSObject *var262;
+    void *var263;
+    int var266;
+    jsval var267;
+    JSObject *var268;
+    JSObject *var269;
+    JSClass *var270;
+    char *var272;
+    JSBool var274;
+    jsval var275;
+    JSObject *var276;
+    jsval var412;
+    char *var280;
+    JSBool var277;
+    jsval var278;
+    JSObject *var279;
+    jsval var413;
+    JSObject *var271;
+    jsval var414;
+    JSBool var261;
+    var262 = NULL;
+    var263 = NULL;
+    var266 = 0;
+    var267 = JSVAL_NULL;
+    var268 = NULL;
+    var269 = NULL;
+    var270 = NULL;
+    var272 = NULL;
+    var274 = JS_FALSE;
+    var275 = JSVAL_NULL;
+    var276 = NULL;
+    var412 = JSVAL_NULL;
+    var280 = NULL;
+    var277 = JS_FALSE;
+    var278 = JSVAL_NULL;
+    var279 = NULL;
+    var413 = JSVAL_NULL;
+    var271 = NULL;
+    var414 = JSVAL_NULL;
+    var261 = JS_FALSE;
+    var262 = obj;
+    var266 = argc;
+    var263 = admFacButton();
+    var269 = JS_GetGlobalObject(cx);
+    var272 = &quot;bool&quot;;
+    var274 = JS_GetProperty(cx, var269, var272, &amp;var275);
+    if (JS_ValueToObject(cx, var275, &amp;var276) != JS_TRUE) {
+        goto do_return;
+    }
+    var412 = OBJECT_TO_JSVAL(var276);
+    argv[argc+0] = var412;
+    var280 = &quot;prototype&quot;;
+    var277 = JS_GetProperty(cx, var276, var280, &amp;var278);
+    if (JS_ValueToObject(cx, var278, &amp;var279) != JS_TRUE) {
+        goto do_return;
+    }
+    var413 = OBJECT_TO_JSVAL(var279);
+    argv[argc+1] = var413;
+    var270 = JS_GET_CLASS(cx, var279);
+    var271 = NULL;
+    var268 = JS_NewObject(cx, var270, var271, var269);
+    var414 = OBJECT_TO_JSVAL(var268);
+    argv[argc+2] = var414;
+    if (JS_SetPrivate(cx, var268, var263) != JS_TRUE) {
+        goto do_return;
+    }
+    var267 = OBJECT_TO_JSVAL(var268);
+    if (rval) {
+        *rval = var267;
+    }
+    var261 = JS_TRUE;
+    do_return:
+    return var261;
+}
+static JSBool
+jjjsTestMatrix(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
+{
+    JSObject *var282;
+    void *var283;
+    int var286;
+    jsval var287;
+    JSObject *var288;
+    JSObject *var289;
+    JSClass *var290;
+    char *var292;
+    JSBool var294;
+    jsval var295;
+    JSObject *var296;
+    jsval var415;
+    char *var300;
+    JSBool var297;
+    jsval var298;
+    JSObject *var299;
+    jsval var416;
+    JSObject *var291;
+    jsval var417;
+    JSBool var281;
+    var282 = NULL;
+    var283 = NULL;
+    var286 = 0;
+    var287 = JSVAL_NULL;
+    var288 = NULL;
+    var289 = NULL;
+    var290 = NULL;
+    var292 = NULL;
+    var294 = JS_FALSE;
+    var295 = JSVAL_NULL;
+    var296 = NULL;
+    var415 = JSVAL_NULL;
+    var300 = NULL;
+    var297 = JS_FALSE;
+    var298 = JSVAL_NULL;
+    var299 = NULL;
+    var416 = JSVAL_NULL;
+    var291 = NULL;
+    var417 = JSVAL_NULL;
+    var281 = JS_FALSE;
+    var282 = obj;
+    var286 = argc;
+    var283 = admFacMatrix();
+    var289 = JS_GetGlobalObject(cx);
+    var292 = &quot;bool&quot;;
+    var294 = JS_GetProperty(cx, var289, var292, &amp;var295);
+    if (JS_ValueToObject(cx, var295, &amp;var296) != JS_TRUE) {
+        goto do_return;
+    }
+    var415 = OBJECT_TO_JSVAL(var296);
+    argv[argc+0] = var415;
+    var300 = &quot;prototype&quot;;
+    var297 = JS_GetProperty(cx, var296, var300, &amp;var298);
+    if (JS_ValueToObject(cx, var298, &amp;var299) != JS_TRUE) {
+        goto do_return;
+    }
+    var416 = OBJECT_TO_JSVAL(var299);
+    argv[argc+1] = var416;
+    var290 = JS_GET_CLASS(cx, var299);
+    var291 = NULL;
+    var288 = JS_NewObject(cx, var290, var291, var289);
+    var417 = OBJECT_TO_JSVAL(var288);
+    argv[argc+2] = var417;
+    if (JS_SetPrivate(cx, var288, var283) != JS_TRUE) {
+        goto do_return;
+    }
+    var287 = OBJECT_TO_JSVAL(var288);
+    if (rval) {
+        *rval = var287;
+    }
+    var281 = JS_TRUE;
+    do_return:
+    return var281;
+}
+static JSBool
+jjjsTestNotch(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
+{
+    JSObject *var302;
+    void *var303;
+    int var306;
+    jsval var307;
+    JSObject *var308;
+    JSObject *var309;
+    JSClass *var310;
+    char *var312;
+    JSBool var314;
+    jsval var315;
+    JSObject *var316;
+    jsval var418;
+    char *var320;
+    JSBool var317;
+    jsval var318;
+    JSObject *var319;
+    jsval var419;
+    JSObject *var311;
+    jsval var420;
+    JSBool var301;
+    var302 = NULL;
+    var303 = NULL;
+    var306 = 0;
+    var307 = JSVAL_NULL;
+    var308 = NULL;
+    var309 = NULL;
+    var310 = NULL;
+    var312 = NULL;
+    var314 = JS_FALSE;
+    var315 = JSVAL_NULL;
+    var316 = NULL;
+    var418 = JSVAL_NULL;
+    var320 = NULL;
+    var317 = JS_FALSE;
+    var318 = JSVAL_NULL;
+    var319 = NULL;
+    var419 = JSVAL_NULL;
+    var311 = NULL;
+    var420 = JSVAL_NULL;
+    var301 = JS_FALSE;
+    var302 = obj;
+    var306 = argc;
+    var303 = admFacNotch();
+    var309 = JS_GetGlobalObject(cx);
+    var312 = &quot;bool&quot;;
+    var314 = JS_GetProperty(cx, var309, var312, &amp;var315);
+    if (JS_ValueToObject(cx, var315, &amp;var316) != JS_TRUE) {
+        goto do_return;
+    }
+    var418 = OBJECT_TO_JSVAL(var316);
+    argv[argc+0] = var418;
+    var320 = &quot;prototype&quot;;
+    var317 = JS_GetProperty(cx, var316, var320, &amp;var318);
+    if (JS_ValueToObject(cx, var318, &amp;var319) != JS_TRUE) {
+        goto do_return;
+    }
+    var419 = OBJECT_TO_JSVAL(var319);
+    argv[argc+1] = var419;
+    var310 = JS_GET_CLASS(cx, var319);
+    var311 = NULL;
+    var308 = JS_NewObject(cx, var310, var311, var309);
+    var420 = OBJECT_TO_JSVAL(var308);
+    argv[argc+2] = var420;
+    if (JS_SetPrivate(cx, var308, var303) != JS_TRUE) {
+        goto do_return;
+    }
+    var307 = OBJECT_TO_JSVAL(var308);
+    if (rval) {
+        *rval = var307;
+    }
+    var301 = JS_TRUE;
+    do_return:
+    return var301;
+}
+static JSBool
+jjjsTestThreadCount(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
+{
+    JSObject *var322;
+    void *var323;
+    int var326;
+    jsval var327;
+    JSObject *var328;
+    JSObject *var329;
+    JSClass *var330;
+    char *var332;
+    JSBool var334;
+    jsval var335;
+    JSObject *var336;
+    jsval var421;
+    char *var340;
+    JSBool var337;
+    jsval var338;
+    JSObject *var339;
+    jsval var422;
+    JSObject *var331;
+    jsval var423;
+    JSBool var321;
+    var322 = NULL;
+    var323 = NULL;
+    var326 = 0;
+    var327 = JSVAL_NULL;
+    var328 = NULL;
+    var329 = NULL;
+    var330 = NULL;
+    var332 = NULL;
+    var334 = JS_FALSE;
+    var335 = JSVAL_NULL;
+    var336 = NULL;
+    var421 = JSVAL_NULL;
+    var340 = NULL;
+    var337 = JS_FALSE;
+    var338 = JSVAL_NULL;
+    var339 = NULL;
+    var422 = JSVAL_NULL;
+    var331 = NULL;
+    var423 = JSVAL_NULL;
+    var321 = JS_FALSE;
+    var322 = obj;
+    var326 = argc;
+    var323 = admFacThreadCount();
+    var329 = JS_GetGlobalObject(cx);
+    var332 = &quot;bool&quot;;
+    var334 = JS_GetProperty(cx, var329, var332, &amp;var335);
+    if (JS_ValueToObject(cx, var335, &amp;var336) != JS_TRUE) {
+        goto do_return;
+    }
+    var421 = OBJECT_TO_JSVAL(var336);
+    argv[argc+0] = var421;
+    var340 = &quot;prototype&quot;;
+    var337 = JS_GetProperty(cx, var336, var340, &amp;var338);
+    if (JS_ValueToObject(cx, var338, &amp;var339) != JS_TRUE) {
+        goto do_return;
+    }
+    var422 = OBJECT_TO_JSVAL(var339);
+    argv[argc+1] = var422;
+    var330 = JS_GET_CLASS(cx, var339);
+    var331 = NULL;
+    var328 = JS_NewObject(cx, var330, var331, var329);
+    var423 = OBJECT_TO_JSVAL(var328);
+    argv[argc+2] = var423;
+    if (JS_SetPrivate(cx, var328, var323) != JS_TRUE) {
+        goto do_return;
+    }
+    var327 = OBJECT_TO_JSVAL(var328);
+    if (rval) {
+        *rval = var327;
+    }
+    var321 = JS_TRUE;
+    do_return:
+    return var321;
+}
+static JSBool
+jjjsTestSlider(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
+{
+    JSObject *var342;
+    void *var343;
+    int var346;
+    jsval var347;
+    JSObject *var348;
+    JSObject *var349;
+    JSClass *var350;
+    char *var352;
+    JSBool var354;
+    jsval var355;
+    JSObject *var356;
+    jsval var424;
+    char *var360;
+    JSBool var357;
+    jsval var358;
+    JSObject *var359;
+    jsval var425;
+    JSObject *var351;
+    jsval var426;
+    JSBool var341;
+    var342 = NULL;
+    var343 = NULL;
+    var346 = 0;
+    var347 = JSVAL_NULL;
+    var348 = NULL;
+    var349 = NULL;
+    var350 = NULL;
+    var352 = NULL;
+    var354 = JS_FALSE;
+    var355 = JSVAL_NULL;
+    var356 = NULL;
+    var424 = JSVAL_NULL;
+    var360 = NULL;
+    var357 = JS_FALSE;
+    var358 = JSVAL_NULL;
+    var359 = NULL;
+    var425 = JSVAL_NULL;
+    var351 = NULL;
+    var426 = JSVAL_NULL;
+    var341 = JS_FALSE;
+    var342 = obj;
+    var346 = argc;
+    var343 = admFacSlider();
+    var349 = JS_GetGlobalObject(cx);
+    var352 = &quot;bool&quot;;
+    var354 = JS_GetProperty(cx, var349, var352, &amp;var355);
+    if (JS_ValueToObject(cx, var355, &amp;var356) != JS_TRUE) {
+        goto do_return;
+    }
+    var424 = OBJECT_TO_JSVAL(var356);
+    argv[argc+0] = var424;
+    var360 = &quot;prototype&quot;;
+    var357 = JS_GetProperty(cx, var356, var360, &amp;var358);
+    if (JS_ValueToObject(cx, var358, &amp;var359) != JS_TRUE) {
+        goto do_return;
+    }
+    var425 = OBJECT_TO_JSVAL(var359);
+    argv[argc+1] = var425;
+    var350 = JS_GET_CLASS(cx, var359);
+    var351 = NULL;
+    var348 = JS_NewObject(cx, var350, var351, var349);
+    var426 = OBJECT_TO_JSVAL(var348);
+    argv[argc+2] = var426;
+    if (JS_SetPrivate(cx, var348, var343) != JS_TRUE) {
+        goto do_return;
+    }
+    var347 = OBJECT_TO_JSVAL(var348);
+    if (rval) {
+        *rval = var347;
+    }
+    var341 = JS_TRUE;
+    do_return:
+    return var341;
+}
+static JSBool
+jjjsCrashTest(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
+{
+    JSObject *var362;
+    int var366;
+    JSBool var361;
+    var362 = NULL;
+    var366 = 0;
+    var361 = JS_FALSE;
+    var362 = obj;
+    var366 = argc;
+    crashTest();
+    var361 = JS_TRUE;
+    return var361;
+}
+static JSBool
+jjjsAssertTest(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
+{
+    JSObject *var368;
+    int var372;
+    JSBool var367;
+    var368 = NULL;
+    var372 = 0;
+    var367 = JS_FALSE;
+    var368 = obj;
+    var372 = argc;
+    assertTest();
+    var367 = JS_TRUE;
+    return var367;
+}
+static JSPropertySpec jj_static_ps[] = {
+    {NULL, 0, 0, NULL, NULL}
+};
+static JSPropertySpec jj_ps[] = {
+    {NULL, 0, 0, NULL, NULL}
+};
+static JSFunctionSpec jj_static_fs[] = {
+    JS_FS(&quot;jsTestFacInt&quot;, jjjsTestFacInt, 0, 0, 3),
+    JS_FS(&quot;jsTestFacFloat&quot;, jjjsTestFacFloat, 0, 0, 3),
+    JS_FS(&quot;jsTestFacToggle&quot;, jjjsTestFacToggle, 0, 0, 3),
+    JS_FS(&quot;jsTestFacMenu&quot;, jjjsTestFacMenu, 0, 0, 3),
+    JS_FS(&quot;jsTestFacFile&quot;, jjjsTestFacFile, 0, 0, 3),
+    JS_FS(&quot;jsTestFacBitrate&quot;, jjjsTestFacBitrate, 0, 0, 3),
+    JS_FS(&quot;jsTestFacBar&quot;, jjjsTestFacBar, 0, 0, 3),
+    JS_FS(&quot;jsTestFacRoText&quot;, jjjsTestFacRoText, 0, 0, 3),
+    JS_FS(&quot;jsTestFacText&quot;, jjjsTestFacText, 0, 0, 3),
+    JS_FS(&quot;jsTestFacTab&quot;, jjjsTestFacTab, 0, 0, 3),
+    JS_FS(&quot;jsTestFrame&quot;, jjjsTestFrame, 0, 0, 3),
+    JS_FS(&quot;jsTestHex&quot;, jjjsTestHex, 0, 0, 3),
+    JS_FS(&quot;jsTestDirSel&quot;, jjjsTestDirSel, 0, 0, 3),
+    JS_FS(&quot;jsTestButton&quot;, jjjsTestButton, 0, 0, 3),
+    JS_FS(&quot;jsTestMatrix&quot;, jjjsTestMatrix, 0, 0, 3),
+    JS_FS(&quot;jsTestNotch&quot;, jjjsTestNotch, 0, 0, 3),
+    JS_FS(&quot;jsTestThreadCount&quot;, jjjsTestThreadCount, 0, 0, 3),
+    JS_FS(&quot;jsTestSlider&quot;, jjjsTestSlider, 0, 0, 3),
+    JS_FS(&quot;jsCrashTest&quot;, jjjsCrashTest, 0, 0, 0),
+    JS_FS(&quot;jsAssertTest&quot;, jjjsAssertTest, 0, 0, 0),
+    JS_FS_END
+};
+static JSFunctionSpec jj_fs[] = {
+    JS_FS(&quot;jsTestFacInt&quot;, jjjsTestFacInt, 0, 0, 3),
+    JS_FS(&quot;jsTestFacFloat&quot;, jjjsTestFacFloat, 0, 0, 3),
+    JS_FS(&quot;jsTestFacToggle&quot;, jjjsTestFacToggle, 0, 0, 3),
+    JS_FS(&quot;jsTestFacMenu&quot;, jjjsTestFacMenu, 0, 0, 3),
+    JS_FS(&quot;jsTestFacFile&quot;, jjjsTestFacFile, 0, 0, 3),
+    JS_FS(&quot;jsTestFacBitrate&quot;, jjjsTestFacBitrate, 0, 0, 3),
+    JS_FS(&quot;jsTestFacBar&quot;, jjjsTestFacBar, 0, 0, 3),
+    JS_FS(&quot;jsTestFacRoText&quot;, jjjsTestFacRoText, 0, 0, 3),
+    JS_FS(&quot;jsTestFacText&quot;, jjjsTestFacText, 0, 0, 3),
+    JS_FS(&quot;jsTestFacTab&quot;, jjjsTestFacTab, 0, 0, 3),
+    JS_FS(&quot;jsTestFrame&quot;, jjjsTestFrame, 0, 0, 3),
+    JS_FS(&quot;jsTestHex&quot;, jjjsTestHex, 0, 0, 3),
+    JS_FS(&quot;jsTestDirSel&quot;, jjjsTestDirSel, 0, 0, 3),
+    JS_FS(&quot;jsTestButton&quot;, jjjsTestButton, 0, 0, 3),
+    JS_FS(&quot;jsTestMatrix&quot;, jjjsTestMatrix, 0, 0, 3),
+    JS_FS(&quot;jsTestNotch&quot;, jjjsTestNotch, 0, 0, 3),
+    JS_FS(&quot;jsTestThreadCount&quot;, jjjsTestThreadCount, 0, 0, 3),
+    JS_FS(&quot;jsTestSlider&quot;, jjjsTestSlider, 0, 0, 3),
+    JS_FS(&quot;jsCrashTest&quot;, jjjsCrashTest, 0, 0, 0),
+    JS_FS(&quot;jsAssertTest&quot;, jjjsAssertTest, 0, 0, 0),
+    JS_FS_END
+};

Added: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsTestFactory_js.idl
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsTestFactory_js.idl	2009-12-06 11:01:40 UTC (rev 5626)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsTestFactory_js.idl	2009-12-09 06:41:29 UTC (rev 5627)
@@ -0,0 +1,27 @@
+/*
+###############################################################
+       return C function     JS Function  params
+###############################################################
+*/
+function bool jsTestFacInt : admFacInt   (void  ) &lt;static&gt;;
+function bool jsTestFacFloat : admFacFloat   (void  ) &lt;static&gt;;
+function bool jsTestFacToggle : admFacToggle   (void  ) &lt;static&gt;;
+function bool jsTestFacMenu : admFacMenu   (void  ) &lt;static&gt;;
+function bool jsTestFacFile : admFacFile   (void  ) &lt;static&gt;;
+function bool jsTestFacBitrate : admFacBitrate   (void  ) &lt;static&gt;;
+function bool jsTestFacBar : admFacBar   (void  ) &lt;static&gt;;
+function bool jsTestFacRoText : admFacRoText   (void  ) &lt;static&gt;;
+function bool jsTestFacText : admFacText   (void  ) &lt;static&gt;;
+function bool jsTestFacTab :  admFacTab   (void  ) &lt;static&gt;;
+function bool jsTestFrame :   admFacFrame   (void  ) &lt;static&gt;;
+function bool jsTestHex :     admFacHex   (void  ) &lt;static&gt;;
+function bool jsTestDirSel :  admFacDirSel   (void  ) &lt;static&gt;;
+function bool jsTestButton :  admFacButton   (void  ) &lt;static&gt;;
+function bool jsTestMatrix :  admFacMatrix   (void  ) &lt;static&gt;;
+function bool jsTestNotch :   admFacNotch   (void  ) &lt;static&gt;;
+function bool jsTestThreadCount : admFacThreadCount   (void  ) &lt;static&gt;;
+function bool jsTestSlider :  admFacSlider   (void  ) &lt;static&gt;;
+function void jsCrashTest :   crashTest   (void  ) &lt;static&gt;;
+function void jsAssertTest :  assertTest   (void  ) &lt;static&gt;;
+
+

Added: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsUtils.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsUtils.cpp	2009-12-06 11:01:40 UTC (rev 5626)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsUtils.cpp	2009-12-09 06:41:29 UTC (rev 5627)
@@ -0,0 +1,95 @@
+/**
+    \file ADM_jsUtils
+    \brief Simple param -&gt; type utilities
+    \author mean <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A> 2009
+*/
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include &quot;ADM_js.h&quot;
+/**
+    \fn ADM_jsArg2Vars  
+    \brief convert jsvals to native type with checking
+*/
+bool ADM_jsArg2Vars(const char *caller, int argc, jsval *argv, int paramNumber, ADM_PARAM_LIST *param)
+{
+    if(paramNumber!=argc)
+    {
+        ADM_warning(&quot;[%s]Wrong number of parameters : %d vs %d\n&quot;,caller,argc,paramNumber);
+        return false;
+    }
+    for(int i=0;i&lt;argc;i++)
+    {
+        jsval j=argv[i];
+        ADM_PARAM_LIST *p=param+i;
+        switch(p-&gt;type)
+        {
+            case ADM_JS_UINT64_T:
+            case ADM_JS_UINT32_T:
+            case ADM_JS_INT64_T:
+            case ADM_JS_INT32_T:
+                {
+                        if(!JSVAL_IS_NUMBER(j))
+                        {
+                            ADM_warning(&quot;[%s]Expected number and got %d\n&quot;,caller,j);
+                            return false;
+                        }
+                        // If it is an int...
+                        double v=0;
+                        if(JSVAL_IS_INT(j)) 
+                        {
+                            v=(int64_t)JSVAL_TO_INT(j);
+                            //ADM_warning(&quot;Value is int :%&quot;LLD&quot;\n&quot;,JSVAL_TO_INT(j));
+                        }
+                        if(JSVAL_IS_DOUBLE(j)) 
+                        {
+                            v=(int64_t)*(JSVAL_TO_DOUBLE(j));
+                            //ADM_warning(&quot;Value is float :%f\n&quot;,(float)*(JSVAL_TO_DOUBLE(j)));
+                        }
+                        // 
+                        //ADM_warning(&quot;%f\n&quot;,(float)v);
+                        // Affect
+                        switch(p-&gt;type)
+                        {
+                            case ADM_JS_UINT64_T: *(uint64_t *)p-&gt;value=(uint64_t)v;break;
+                            case ADM_JS_UINT32_T: *(uint32_t *)p-&gt;value=(uint32_t)v;break;
+                            case ADM_JS_INT64_T:  *(int64_t *)p-&gt;value=(int64_t)v;break;
+                            case ADM_JS_INT32_T:  *(int32_t *)p-&gt;value=(int32_t)v;break;
+                            default: ADM_assert(0);break;
+                        }
+                 }
+                        break;
+            case  ADM_JS_STRING:
+                {
+                        if(!JSVAL_IS_STRING(j))
+                        {
+                            ADM_warning(&quot;[%s]Expected string and got %d\n&quot;,caller,j);
+                            return false;
+                        }
+                        char *out=JS_GetStringBytes(JSVAL_TO_STRING(j));
+                        char **m=(char **)(p-&gt;value);
+                        *m=out;
+                }
+                        break;
+            case  ADM_JS_BOOL:
+                        if(!JSVAL_IS_BOOLEAN(j))
+                        {
+                            ADM_warning(&quot;[%s]Expected boolean and got %d\n&quot;,caller,j);
+                            return false;
+                        }
+                        *(bool *)p-&gt;value=JSVAL_TO_BOOLEAN(j);
+                        break;
+            default:
+                    ADM_assert(0);
+                    break;
+        }
+
+    }
+    return true;
+}
+// EOF

Added: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/CMakeLists.txt	2009-12-06 11:01:40 UTC (rev 5626)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/CMakeLists.txt	2009-12-09 06:41:29 UTC (rev 5627)
@@ -0,0 +1,16 @@
+SET(ADM_script_SRCS
+        ADM_jsIf.cpp
+        ADM_jsDebug.cpp
+        ADM_jsUtils.cpp
+# Wrapper code
+        ADM_jsIf_js.c
+# Factory test
+        ADM_jsTestFactory.cpp  
+        ADM_jsTestFactory_js.c
+
+)
+
+ADD_LIBRARY(ADM_script26 STATIC ${ADM_script_SRCS})
+ADD_DEFINITIONS(&quot;-DJS_THREADSAFE -DXP_UNIX&quot;)
+include_directories(${CMAKE_CURRENT_SOURCE_DIR}/../include)
+include_directories(${AVIDEMUX_TOP_SOURCE_DIR}/avidemux_core/ADM_smjs)

Added: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/idl.make
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/idl.make	2009-12-06 11:01:40 UTC (rev 5626)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/idl.make	2009-12-09 06:41:29 UTC (rev 5627)
@@ -0,0 +1,6 @@
+idls:=$(shell ls *.idl)
+cs:=$(subst .idl,.c,$(idls))
+%.c : %.idl
+	echo processing $@
+	jsapigen &lt; $&lt; &gt; $@ 
+all: $(cs)

Added: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/updateIdl.sh
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/updateIdl.sh	2009-12-06 11:01:40 UTC (rev 5626)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/updateIdl.sh	2009-12-09 06:41:29 UTC (rev 5627)
@@ -0,0 +1 @@
+jsapigen &lt; ADM_jsIf_js.idl  &gt; ADM_jsIf_js.c

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_toolkit/automation.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_toolkit/automation.cpp	2009-12-06 11:01:40 UTC (rev 5626)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_toolkit/automation.cpp	2009-12-09 06:41:29 UTC (rev 5627)
@@ -96,9 +96,9 @@
 extern int A_saveDVDPS(char *name);
 extern void A_saveWorkbench (const char *name);
 extern uint8_t A_rebuildKeyFrame (void);
-extern uint8_t A_setContainer(const char *cont);
+//extern uint8_t A_setContainer(const char *cont);
 uint8_t scriptAddVar(char *var,char *value);
-extern void ADM_dumpJSHooks(void);
+//extern void ADM_dumpJSHooks(void);
 extern uint8_t ADM_vob2vobsub(char *nameVob, char *nameVobSub, char *nameIfo);
 
 #ifdef __WIN32
@@ -138,7 +138,7 @@
 
 AUTOMATON reaction_table[]=
 {
-        {&quot;js&quot;,                  0,&quot;Dump the javascript functions&quot;,(one_arg_type)ADM_dumpJSHooks},
+        //{&quot;js&quot;,                  0,&quot;Dump the javascript functions&quot;,(one_arg_type)ADM_dumpJSHooks},
         {&quot;nogui&quot;,               0,&quot;Run in silent mode&quot;,		(one_arg_type)GUI_Quiet}   ,
 //        {&quot;listfilters&quot;,		0,&quot;list all filters by name&quot;,		(one_arg_type)filterListAll}   ,
         {&quot;run&quot;,			1,&quot;load and run a script&quot;,		(one_arg_type)A_parseECMAScript},
@@ -570,7 +570,8 @@
 	return 1;
 }
 int set_output_format(const char *str){
-  	return A_setContainer(str);
+  	//return A_setContainer(str);
+    return 0;
 }
 
 /*

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/CMakeLists.txt	2009-12-06 11:01:40 UTC (rev 5626)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/CMakeLists.txt	2009-12-09 06:41:29 UTC (rev 5627)
@@ -15,6 +15,7 @@
 ADD_SUBDIRECTORY(ADM_render)
 ADD_SUBDIRECTORY(ADM_requant)
 ADD_SUBDIRECTORY(ADM_script)
+ADD_SUBDIRECTORY(ADM_script2)
 ADD_SUBDIRECTORY(ADM_toolkit)
 #ADD_SUBDIRECTORY(ADM_video)
 #ADD_SUBDIRECTORY(ADM_videoFilter)

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/main.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/main.cpp	2009-12-06 11:01:40 UTC (rev 5626)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/main.cpp	2009-12-09 06:41:29 UTC (rev 5627)
@@ -103,8 +103,7 @@
 // Spidermonkey/Scripting stuff  
 bool SpidermonkeyInit(void);
 void SpidermonkeyDestroy(void);
-
-extern pthread_mutex_t g_pSpiderMonkeyMutex;
+bool ADM_jsExit(void);
 #if defined(ADM_DEBUG) &amp;&amp; defined(FIND_LEAKS)
 extern const char* new_progname;
 extern int check_leaks();
@@ -314,11 +313,7 @@
 	printf(&quot;Cleaning up\n&quot;);
     delete video_body;	
     // wait for thread to finish executing
-    printf(&quot;Waiting for Spidermonkey to finish...\n&quot;);
-    pthread_mutex_lock(&amp;g_pSpiderMonkeyMutex);
-    printf(&quot;Cleaning up Spidermonkey.\n&quot;);
-    SpidermonkeyDestroy();
-    pthread_mutex_unlock(&amp;g_pSpiderMonkeyMutex);
+    ADM_jsExit();
 //    filterCleanUp();
 	ADM_lavDestroy();
 

Modified: branches/avidemux_2.6_branch_mean/avidemux/commonCmakeApplication.cmake
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/commonCmakeApplication.cmake	2009-12-06 11:01:40 UTC (rev 5626)
+++ branches/avidemux_2.6_branch_mean/avidemux/commonCmakeApplication.cmake	2009-12-09 06:41:29 UTC (rev 5627)
@@ -95,10 +95,11 @@
 #ADM_filter6 
 ADM_osSupport6 
 ADM_requant6 
-ADM_script6 
-ADM_toolkit6
+#ADM_script6 
+ADM_script26 
 ADM_videoEncoder6 
 ADM_internalVideoFilter6
+ADM_toolkit6
 
 #ADM_video6 
 #ADM_videoFilter6 

Modified: branches/avidemux_2.6_branch_mean/avidemux/qt4/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/qt4/CMakeLists.txt	2009-12-06 11:01:40 UTC (rev 5626)
+++ branches/avidemux_2.6_branch_mean/avidemux/qt4/CMakeLists.txt	2009-12-09 06:41:29 UTC (rev 5627)
@@ -85,6 +85,7 @@
 TARGET_LINK_LIBRARIES(avidemux3_qt4 ADM_guiQt4)
 TARGET_LINK_LIBRARIES(avidemux3_qt4 ADM_UI_QT4)
 TARGET_LINK_LIBRARIES(avidemux3_qt4 ADM_shellQt4)
+TARGET_LINK_LIBRARIES(avidemux3_qt4 ADM_toolkit6)
 ###########################################
 # Construct Core libraries
 ###########################################


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="002834.html">[Avidemux-svn-commit] r5626 -	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDecoders/ADM_ad_vorbis
</A></li>
	<LI>Next message: <A HREF="002837.html">[Avidemux-svn-commit] r5628 -	branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_gui
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2836">[ date ]</a>
              <a href="thread.html#2836">[ thread ]</a>
              <a href="subject.html#2836">[ subject ]</a>
              <a href="author.html#2836">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">More information about the Avidemux-svn-commit
mailing list</a><br>
</body></html>
