From mean at mail.berlios.de  Thu Jun  2 13:43:49 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Thu,  2 Jun 2011 13:43:49 +0200
Subject: [Avidemux-svn-commit] r7248 -
	branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audioFilter/src/ADM_libsamplerate
Message-ID: <20110602114349.C1965480BAD@sheep.berlios.de>

Author: mean
Date: 2011-06-02 13:43:49 +0200 (Thu, 02 Jun 2011)
New Revision: 7248

Added:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audioFilter/src/ADM_libsamplerate/admPackage.txt
Log:
[src] add admPackage.txt

Added: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audioFilter/src/ADM_libsamplerate/admPackage.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audioFilter/src/ADM_libsamplerate/admPackage.txt	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audioFilter/src/ADM_libsamplerate/admPackage.txt	2011-06-02 11:43:49 UTC (rev 7248)
@@ -0,0 +1,3 @@
+Name    : Secret Rabit Code
+URL     : http://www.mega-nerd.com/SRC
+License : GPL 



From mean at mail.berlios.de  Thu Jun  2 13:43:51 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Thu,  2 Jun 2011 13:43:51 +0200
Subject: [Avidemux-svn-commit] r7249 - in branches/avidemux_2.6_branch_mean:
	. avidemux/common/ADM_audioFilter/src/ADM_libsamplerate
	avidemux_core/ADM_coreSqlLight3 avidemux_core/ADM_coreTinyPy
	avidemux_core/ADM_smjs avidemux_core/ffmpeg_package
	avidemux_plugins/ADM_audioDecoders/ADM_ad_ac3
	avidemux_plugins/ADM_audioDecoders/ADM_ad_mad
	avidemux_plugins/ADM_audioEncoders/twolame
Message-ID: <20110602114351.E7469480BAD@sheep.berlios.de>

Author: mean
Date: 2011-06-02 13:43:51 +0200 (Thu, 02 Jun 2011)
New Revision: 7249

Added:
   branches/avidemux_2.6_branch_mean/License.txt
   branches/avidemux_2.6_branch_mean/License.txt.in
   branches/avidemux_2.6_branch_mean/update_license.sh
Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audioFilter/src/ADM_libsamplerate/admPackage.txt
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreSqlLight3/admPackage.txt
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreTinyPy/admPackage.txt
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_smjs/admPackage.txt
   branches/avidemux_2.6_branch_mean/avidemux_core/ffmpeg_package/admPackage.txt
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDecoders/ADM_ad_ac3/admPackage.txt
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDecoders/ADM_ad_mad/admPackage.txt
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioEncoders/twolame/admPackage.txt
Log:
[all] update license

Added: branches/avidemux_2.6_branch_mean/License.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/License.txt	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/License.txt	2011-06-02 11:43:51 UTC (rev 7249)
@@ -0,0 +1,36 @@
+Avidemux is GPL V2.
+It contains other software included as source with the following licenses :
+Name    : Secret Rabit Code
+URL     : http://www.mega-nerd.com/SRC
+License : GPL 
+
+Name : Tinypy
+URL: http://www.tinypy.org
+License : MIT + PYTHON SOFTWARE FOUNDATION LICENSE VERSION 2 
+
+Name    : ffmpeg
+URL     : http://www.ffmpeg.org
+License : GPL >=2
+
+Name   : SQLite3
+URL    : http://www.sqlite.org
+License: Public Domain
+
+Name   : Spidermonky
+URL    : https://developer.mozilla.org/en/SpiderMonkey
+License: GPLv2
+
+URL    : http://resare.com/libmp4v2
+License: LGPL
+Name   : liba52
+URL    : http://liba52.sf.net
+License: GPL
+
+Name    : Mad
+URL     : http://www.underbit.com/products/mad
+License : GPL
+
+Name   :  TwoLame
+URL    :  http://twolame.sf.net
+License:  LGPL
+

Added: branches/avidemux_2.6_branch_mean/License.txt.in
===================================================================
--- branches/avidemux_2.6_branch_mean/License.txt.in	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/License.txt.in	2011-06-02 11:43:51 UTC (rev 7249)
@@ -0,0 +1,2 @@
+Avidemux is GPL V2.
+It contains other software included as source with the following licenses :

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audioFilter/src/ADM_libsamplerate/admPackage.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audioFilter/src/ADM_libsamplerate/admPackage.txt	2011-06-02 11:43:49 UTC (rev 7248)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audioFilter/src/ADM_libsamplerate/admPackage.txt	2011-06-02 11:43:51 UTC (rev 7249)
@@ -1,3 +1,4 @@
 Name    : Secret Rabit Code
 URL     : http://www.mega-nerd.com/SRC
 License : GPL 
+

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreSqlLight3/admPackage.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreSqlLight3/admPackage.txt	2011-06-02 11:43:49 UTC (rev 7248)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreSqlLight3/admPackage.txt	2011-06-02 11:43:51 UTC (rev 7249)
@@ -1,2 +1,4 @@
-URL: http://www.sqlite.org
+Name   : SQLite3
+URL    : http://www.sqlite.org
 License: Public Domain
+

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreTinyPy/admPackage.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreTinyPy/admPackage.txt	2011-06-02 11:43:49 UTC (rev 7248)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreTinyPy/admPackage.txt	2011-06-02 11:43:51 UTC (rev 7249)
@@ -1,2 +1,4 @@
+Name : Tinypy
 URL: http://www.tinypy.org
 License : MIT + PYTHON SOFTWARE FOUNDATION LICENSE VERSION 2 
+

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_smjs/admPackage.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_smjs/admPackage.txt	2011-06-02 11:43:49 UTC (rev 7248)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_smjs/admPackage.txt	2011-06-02 11:43:51 UTC (rev 7249)
@@ -1,2 +1,4 @@
-URL: https://developer.mozilla.org/en/SpiderMonkey
+Name   : Spidermonky
+URL    : https://developer.mozilla.org/en/SpiderMonkey
 License: GPLv2
+

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ffmpeg_package/admPackage.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ffmpeg_package/admPackage.txt	2011-06-02 11:43:49 UTC (rev 7248)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ffmpeg_package/admPackage.txt	2011-06-02 11:43:51 UTC (rev 7249)
@@ -1,2 +1,4 @@
+Name    : ffmpeg
 URL     : http://www.ffmpeg.org
 License : GPL >=2
+

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDecoders/ADM_ad_ac3/admPackage.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDecoders/ADM_ad_ac3/admPackage.txt	2011-06-02 11:43:49 UTC (rev 7248)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDecoders/ADM_ad_ac3/admPackage.txt	2011-06-02 11:43:51 UTC (rev 7249)
@@ -1,2 +1,4 @@
-URL : http://liba52.sf.net
+Name   : liba52
+URL    : http://liba52.sf.net
 License: GPL
+

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDecoders/ADM_ad_mad/admPackage.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDecoders/ADM_ad_mad/admPackage.txt	2011-06-02 11:43:49 UTC (rev 7248)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDecoders/ADM_ad_mad/admPackage.txt	2011-06-02 11:43:51 UTC (rev 7249)
@@ -1,2 +1,4 @@
-URL: http://www.underbit.com/products/mad
+Name    : Mad
+URL     : http://www.underbit.com/products/mad
 License : GPL
+

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioEncoders/twolame/admPackage.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioEncoders/twolame/admPackage.txt	2011-06-02 11:43:49 UTC (rev 7248)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioEncoders/twolame/admPackage.txt	2011-06-02 11:43:51 UTC (rev 7249)
@@ -1,2 +1,4 @@
+Name   :  TwoLame
 URL    :  http://twolame.sf.net
 License:  LGPL
+

Added: branches/avidemux_2.6_branch_mean/update_license.sh
===================================================================
--- branches/avidemux_2.6_branch_mean/update_license.sh	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/update_license.sh	2011-06-02 11:43:51 UTC (rev 7249)
@@ -0,0 +1,4 @@
+#!/bin/sh
+cp License.txt.in License.txt
+find . -name "admPackage*.txt" | xargs cat >> License.txt
+echo "Done"



From mean at mail.berlios.de  Thu Jun  2 13:43:53 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Thu,  2 Jun 2011 13:43:53 +0200
Subject: [Avidemux-svn-commit] r7250 - in
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6:
	. changeFps
Message-ID: <20110602114353.AE5C8480BAD@sheep.berlios.de>

Author: mean
Date: 2011-06-02 13:43:53 +0200 (Thu, 02 Jun 2011)
New Revision: 7250

Added:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/changeFps/
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/changeFps/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/changeFps/changeFps.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/changeFps/confChangeFps.conf
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/changeFps/confChangeFps.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/changeFps/confChangeFps_desc.cpp
Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/CMakeLists.txt
Log:
[videoFilter] Skeleton for change fps filter

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/CMakeLists.txt	2011-06-02 11:43:51 UTC (rev 7249)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/CMakeLists.txt	2011-06-02 11:43:53 UTC (rev 7250)
@@ -1,6 +1,7 @@
 ADD_SUBDIRECTORY(addBorder)
 ADD_SUBDIRECTORY(ass)
 ADD_SUBDIRECTORY(blackenBorder)
+ADD_SUBDIRECTORY(changeFps)
 ADD_SUBDIRECTORY(colorYUV)
 ADD_SUBDIRECTORY(crop)
 ADD_SUBDIRECTORY(dummy)

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/changeFps/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/changeFps/CMakeLists.txt	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/changeFps/CMakeLists.txt	2011-06-02 11:43:53 UTC (rev 7250)
@@ -0,0 +1,8 @@
+INCLUDE(vf_plugin)
+
+SET(ADM_vf_changeFps_SRCS changeFps.cpp)
+
+ADD_VIDEO_FILTER(ADM_vf_changeFps ${ADM_vf_changeFps_SRCS})
+
+INIT_VIDEO_FILTER(ADM_vf_changeFps)
+INSTALL_VIDEO_FILTER(ADM_vf_changeFps)

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/changeFps/changeFps.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/changeFps/changeFps.cpp	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/changeFps/changeFps.cpp	2011-06-02 11:43:53 UTC (rev 7250)
@@ -0,0 +1,210 @@
+/***************************************************************************
+    \file ADM_vidchangeFps
+    \author mean fixounet at free.fr
+    \brief Simple filter that rescales timing from oldFps to newFps
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include <math.h>
+#include "ADM_default.h"
+#include "ADM_coreVideoFilterInternal.h"
+#include "DIA_coreToolkit.h"
+#include "DIA_factory.h"
+
+#include "confChangeFps.h"
+#include "confChangeFps_desc.cpp"
+
+#if 1
+    #define aprintf(...) {}
+#else
+    #define aprintf ADM_info
+#endif
+
+typedef struct 
+{
+    const char *desc;
+    uint32_t num;
+    uint32_t den;
+}PredefinedFps_t;
+
+const PredefinedFps_t predefinedFps[]=
+{
+ {QT_TR_NOOP("Custom"),         10000,1000},
+ {QT_TR_NOOP("25  (PAL)"),      25000,1000},
+ {QT_TR_NOOP("23.976 (Film)"),  24000,1001},
+ {QT_TR_NOOP("29.97 (NTSC)"),   30000,1001},
+ {QT_TR_NOOP("50 (Pal)"),       50000,1000},
+ {QT_TR_NOOP("59.93  (NTSC)"),  60000,1001}
+};
+
+#define nbPredefined (sizeof(predefinedFps)/sizeof(PredefinedFps_t))
+
+/**
+    \class changeFps
+
+*/
+class  changeFps:public ADM_coreVideoFilter
+{
+protected:
+        confChangeFps       configuration;
+public:
+                            changeFps(ADM_coreVideoFilter *previous,CONFcouple *conf);
+                            ~changeFps();
+        bool                goToTime(uint64_t usSeek);
+        virtual const char   *getConfiguration(void);                   /// Return  current configuration as a human readable string
+        virtual bool         getNextFrame(uint32_t *fn,ADMImage *image);    /// Return the next image
+        virtual bool         getCoupledConf(CONFcouple **couples) ;   /// Return the current filter configuration
+        virtual bool         configure(void) ;           /// Start graphical user interface
+};
+//***********************************
+// Add the hook to make it valid plugin
+DECLARE_VIDEO_FILTER(   changeFps,   // Class
+                        1,0,0,              // Version
+                        ADM_UI_ALL,         // UI
+                        VF_TRANSFORM,            // Category
+                        "changeFps",            // internal name (must be uniq!)
+                        "Change FPS",            // Display name
+                        "Speed up/slow down the video as if altering fps. This filter changes duration." // Description
+                    );
+
+/**
+    \fn getConfiguration
+*/
+const char *changeFps::getConfiguration( void )
+{
+static char buf[100];
+ snprintf(buf,99," Resample from %2.2f to %2.2f fps",
+        (double)configuration.oldFpsNum/configuration.oldFpsDen,
+        (double)configuration.newFpsNum/configuration.newFpsDen);
+ return buf;  
+}
+/**
+    \fn ctor
+*/
+changeFps::changeFps(  ADM_coreVideoFilter *previous,CONFcouple *setup) : ADM_coreVideoFilter(previous,setup)
+{
+    if(!setup || !ADM_paramLoad(setup,confChangeFps_param,&configuration))
+    {
+        // Default value
+        configuration.newMode=0;
+        configuration.newFpsNum=ADM_Fps1000FromUs(previous->getInfo()->frameIncrement);
+        configuration.newFpsDen=1000;
+        configuration.oldMode=0;
+        configuration.oldFpsNum=ADM_Fps1000FromUs(previous->getInfo()->frameIncrement);
+        configuration.oldFpsDen=1000;
+
+    }
+}
+/**
+    \fn dtor
+
+*/
+changeFps::~changeFps()
+{
+}
+
+/**
+    \fn goToTime
+    \brief called when seeking. Need to cleanup our stuff.
+*/
+bool         changeFps::goToTime(uint64_t usSeek)
+{
+#warning TODO rescale time
+    if(false==ADM_coreVideoFilter::goToTime(usSeek)) return false;
+    return true;
+}
+
+/**
+    \fn getCoupledConf
+*/ 
+bool         changeFps::getCoupledConf(CONFcouple **couples)
+{
+    return ADM_paramSave(couples, confChangeFps_param,&configuration);
+}
+/**
+    \fn getNextFrame
+*/
+ bool         changeFps::getNextFrame(uint32_t *fn,ADMImage *image)
+{
+
+
+    return true;
+}
+
+/**
+    \fn configure
+*/
+bool changeFps::configure(void)
+{
+
+    float f=configuration.newFpsNum; 
+    f/=configuration.newFpsDen;
+
+    float f2=configuration.oldFpsNum; 
+    f2/=configuration.oldFpsDen;
+
+
+ADM_assert(nbPredefined == 6);
+  
+   diaMenuEntry tFps[]={
+#define Z(x)                 {x,     predefinedFps[x].desc}
+                    Z(0),Z(1),Z(2),Z(3),Z(4),Z(5)
+
+          };
+    
+    
+
+    diaElemMenu mFps(&(configuration.oldMode),   QT_TR_NOOP("Source Fps:"), 6,tFps);
+    diaElemFloat fps(&f2,QT_TR_NOOP("Source frame rate:"),1,200.);
+
+    mFps.link(tFps+0,1,&fps); // only activate entry in custom mode
+
+    diaElemMenu targetmFps(&(configuration.newMode),   QT_TR_NOOP("Source Fps:"), 6,tFps);
+    diaElemFloat targetfps(&f,QT_TR_NOOP("Source frame rate:"),1,200.);
+
+    targetmFps.link(tFps+0,1,&targetfps); // only activate entry in custom mode
+
+
+
+    diaElem *elems[4]={&mFps,&fps,&targetmFps,&targetfps};
+  
+    if( !diaFactoryRun(QT_TR_NOOP("Change fps"),4,elems))
+        return false;
+    
+      // 
+      if(!configuration.newMode) // Custom mode
+      {
+          f*=1000;
+          configuration.newFpsNum=(uint32_t)floor(f+0.4);
+          configuration.newFpsDen=(uint32_t)1000;
+      }else   // Preset
+        {
+            const PredefinedFps_t *me=&(predefinedFps[configuration.newMode]);
+            configuration.newFpsNum=me->num;
+            configuration.newFpsDen=me->den;
+        }
+
+    if(!configuration.oldMode) // Custom mode
+      {
+          f2*=1000;
+          configuration.oldFpsNum=(uint32_t)floor(f2+0.4);
+          configuration.oldFpsDen=(uint32_t)1000;
+      }else   // Preset
+        {
+            const PredefinedFps_t *me=&(predefinedFps[configuration.oldMode]);
+            configuration.oldFpsNum=me->num;
+            configuration.oldFpsDen=me->den;
+        }
+
+      return true;
+}
+
+//EOF

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/changeFps/confChangeFps.conf
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/changeFps/confChangeFps.conf	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/changeFps/confChangeFps.conf	2011-06-02 11:43:53 UTC (rev 7250)
@@ -0,0 +1,8 @@
+confChangeFps{
+uint32_t:oldMode
+uint32_t:oldFpsDen
+uint32_t:oldFpsNum
+uint32_t:newMode
+uint32_t:newFpsDen
+uint32_t:newFpsNum
+}

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/changeFps/confChangeFps.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/changeFps/confChangeFps.h	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/changeFps/confChangeFps.h	2011-06-02 11:43:53 UTC (rev 7250)
@@ -0,0 +1,12 @@
+// automatically generated by admSerialization.py do not edit
+#ifndef ADM_confChangeFps_CONF_H
+#define ADM_confChangeFps_CONF_H
+typedef struct {
+uint32_t oldMode;
+uint32_t oldFpsDen;
+uint32_t oldFpsNum;
+uint32_t newMode;
+uint32_t newFpsDen;
+uint32_t newFpsNum;
+}confChangeFps;
+#endif

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/changeFps/confChangeFps_desc.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/changeFps/confChangeFps_desc.cpp	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/changeFps/confChangeFps_desc.cpp	2011-06-02 11:43:53 UTC (rev 7250)
@@ -0,0 +1,10 @@
+// automatically generated by admSerialization.py, do not edit!
+extern const ADM_paramList confChangeFps_param[]={
+ {"oldMode",offsetof(confChangeFps,oldMode),"uint32_t",ADM_param_uint32_t},
+ {"oldFpsDen",offsetof(confChangeFps,oldFpsDen),"uint32_t",ADM_param_uint32_t},
+ {"oldFpsNum",offsetof(confChangeFps,oldFpsNum),"uint32_t",ADM_param_uint32_t},
+ {"newMode",offsetof(confChangeFps,newMode),"uint32_t",ADM_param_uint32_t},
+ {"newFpsDen",offsetof(confChangeFps,newFpsDen),"uint32_t",ADM_param_uint32_t},
+ {"newFpsNum",offsetof(confChangeFps,newFpsNum),"uint32_t",ADM_param_uint32_t},
+{NULL,0,NULL}
+};



From mean at mail.berlios.de  Thu Jun  2 13:43:55 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Thu,  2 Jun 2011 13:43:55 +0200
Subject: [Avidemux-svn-commit] r7251 -
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6
Message-ID: <20110602114355.330D7480BAD@sheep.berlios.de>

Author: mean
Date: 2011-06-02 13:43:55 +0200 (Thu, 02 Jun 2011)
New Revision: 7251

Removed:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/resampleFps.hResampleFps.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/resampleFps_desc.cppResampleFps_desc.cpp
Log:
[videoFilter] Remove file that were put there by errors

Deleted: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/resampleFps.hResampleFps.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/resampleFps.hResampleFps.h	2011-06-02 11:43:53 UTC (rev 7250)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/resampleFps.hResampleFps.h	2011-06-02 11:43:55 UTC (rev 7251)
@@ -1,10 +0,0 @@
-// automatically generated by admSerialization.py, do not edit!
-// automatically generated by admSerialization.py do not edit
-#ifndef ADM_resampleFps_CONF_H
-#define ADM_resampleFps_CONF_H
-typedef struct {
-uint32_t mode;
-uint32_t newFpsDen;
-uint32_t newFpsNum;
-}resampleFps;
-#endif

Deleted: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/resampleFps_desc.cppResampleFps_desc.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/resampleFps_desc.cppResampleFps_desc.cpp	2011-06-02 11:43:53 UTC (rev 7250)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/resampleFps_desc.cppResampleFps_desc.cpp	2011-06-02 11:43:55 UTC (rev 7251)
@@ -1,6 +0,0 @@
-const ADM_paramList resampleFps_param[]={
- {"mode",offsetof(resampleFps,mode),"uint32_t",ADM_param_uint32_t},
- {"newFpsDen",offsetof(resampleFps,newFpsDen),"uint32_t",ADM_param_uint32_t},
- {"newFpsNum",offsetof(resampleFps,newFpsNum),"uint32_t",ADM_param_uint32_t},
-{NULL,0,NULL}
-};



From mean at mail.berlios.de  Thu Jun  2 13:43:56 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Thu,  2 Jun 2011 13:43:56 +0200
Subject: [Avidemux-svn-commit] r7252 -
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/changeFps
Message-ID: <20110602114356.60A76480BAD@sheep.berlios.de>

Author: mean
Date: 2011-06-02 13:43:56 +0200 (Thu, 02 Jun 2011)
New Revision: 7252

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/changeFps/changeFps.cpp
Log:
[changeFps] Working filter

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/changeFps/changeFps.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/changeFps/changeFps.cpp	2011-06-02 11:43:55 UTC (rev 7251)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/changeFps/changeFps.cpp	2011-06-02 11:43:56 UTC (rev 7252)
@@ -55,6 +55,7 @@
 {
 protected:
         confChangeFps       configuration;
+        bool                updateTimingInfo(void);
 public:
                             changeFps(ADM_coreVideoFilter *previous,CONFcouple *conf);
                             ~changeFps();
@@ -102,6 +103,7 @@
         configuration.oldFpsDen=1000;
 
     }
+    updateTimingInfo();
 }
 /**
     \fn dtor
@@ -117,8 +119,12 @@
 */
 bool         changeFps::goToTime(uint64_t usSeek)
 {
-#warning TODO rescale time
-    if(false==ADM_coreVideoFilter::goToTime(usSeek)) return false;
+    double timing=(double)usSeek;
+    timing/=configuration.oldFpsNum;
+    timing/=configuration.newFpsDen;
+    timing*=configuration.newFpsNum;
+    timing*=configuration.oldFpsDen;
+    if(false==ADM_coreVideoFilter::goToTime((uint64_t)timing)) return false;
     return true;
 }
 
@@ -134,24 +140,55 @@
 */
  bool         changeFps::getNextFrame(uint32_t *fn,ADMImage *image)
 {
+    if(false==previousFilter->getNextFrame(fn,image))
+            return false;
+    if(image->Pts==ADM_NO_PTS)
+        return true;
+    double timing=image->Pts;
 
+    timing*=configuration.oldFpsNum;
+    timing*=configuration.newFpsDen;
+    timing/=configuration.newFpsNum;
+    timing/=configuration.oldFpsDen;
 
+    image->Pts=(uint64_t)timing;
+
     return true;
 }
+/**
+    \fn updateTimingInfo
+    \brief update the info part with new fps
+*/
+bool changeFps::updateTimingInfo(void)
+{
+    
+    double fps1000=configuration.newFpsNum*1000;
+    fps1000/=configuration.newFpsDen;
+    // 1 update frame increment...
+    info.frameIncrement=ADM_Fps1000FromUs( (uint64_t)fps1000);
 
+    // 2 update duration
+    double timing=previousFilter->getInfo()->totalDuration;
+    timing*=configuration.oldFpsNum;
+    timing*=configuration.newFpsDen;
+    timing/=configuration.newFpsNum;
+    timing/=configuration.oldFpsDen;
+    info.totalDuration=(uint64_t)timing;
+    return true;
+}
 /**
     \fn configure
 */
 bool changeFps::configure(void)
 {
+again:
+    float newFrac=configuration.newFpsNum; 
+    newFrac/=configuration.newFpsDen;
 
-    float f=configuration.newFpsNum; 
-    f/=configuration.newFpsDen;
+    float oldFrac=configuration.oldFpsNum; 
+    oldFrac/=configuration.oldFpsDen;
 
-    float f2=configuration.oldFpsNum; 
-    f2/=configuration.oldFpsDen;
 
-
 ADM_assert(nbPredefined == 6);
   
    diaMenuEntry tFps[]={
@@ -163,12 +200,12 @@
     
 
     diaElemMenu mFps(&(configuration.oldMode),   QT_TR_NOOP("Source Fps:"), 6,tFps);
-    diaElemFloat fps(&f2,QT_TR_NOOP("Source frame rate:"),1,200.);
+    diaElemFloat fps(&oldFrac,QT_TR_NOOP("Source frame rate:"),1,200.);
 
     mFps.link(tFps+0,1,&fps); // only activate entry in custom mode
 
     diaElemMenu targetmFps(&(configuration.newMode),   QT_TR_NOOP("Source Fps:"), 6,tFps);
-    diaElemFloat targetfps(&f,QT_TR_NOOP("Source frame rate:"),1,200.);
+    diaElemFloat targetfps(&newFrac,QT_TR_NOOP("Source frame rate:"),1,200.);
 
     targetmFps.link(tFps+0,1,&targetfps); // only activate entry in custom mode
 
@@ -179,11 +216,16 @@
     if( !diaFactoryRun(QT_TR_NOOP("Change fps"),4,elems))
         return false;
     
+    if(newFrac==0 || oldFrac==0)
+    {
+        GUI_Error_HIG("Error","Invalid fps");
+        goto again;
+    }
       // 
       if(!configuration.newMode) // Custom mode
       {
-          f*=1000;
-          configuration.newFpsNum=(uint32_t)floor(f+0.4);
+          newFrac*=1000;
+          configuration.newFpsNum=(uint32_t)floor(newFrac+0.4);
           configuration.newFpsDen=(uint32_t)1000;
       }else   // Preset
         {
@@ -194,8 +236,8 @@
 
     if(!configuration.oldMode) // Custom mode
       {
-          f2*=1000;
-          configuration.oldFpsNum=(uint32_t)floor(f2+0.4);
+          oldFrac*=1000;
+          configuration.oldFpsNum=(uint32_t)floor(oldFrac+0.4);
           configuration.oldFpsDen=(uint32_t)1000;
       }else   // Preset
         {
@@ -203,7 +245,7 @@
             configuration.oldFpsNum=me->num;
             configuration.oldFpsDen=me->den;
         }
-
+      updateTimingInfo();
       return true;
 }
 



From mean at mail.berlios.de  Thu Jun  2 13:43:57 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Thu,  2 Jun 2011 13:43:57 +0200
Subject: [Avidemux-svn-commit] r7253 -
	branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor
Message-ID: <20110602114357.8EC79480BAD@sheep.berlios.de>

Author: mean
Date: 2011-06-02 13:43:57 +0200 (Thu, 02 Jun 2011)
New Revision: 7253

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edPtsDts.cpp
Log:
[TS/H264] Fill missing PTS when top/bottom scheme is used (avchd like)

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edPtsDts.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edPtsDts.cpp	2011-06-02 11:43:56 UTC (rev 7252)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edPtsDts.cpp	2011-06-02 11:43:57 UTC (rev 7253)
@@ -249,17 +249,21 @@
     ADM_info("Some PTS are missing, try to guess them...\n");
     fail=0;
     //
-    for(int i=0;i<nbFrames-1;i+=2)
+    for(int i=0;i<nbFrames-1;i+=1)
     {
         hdr->getFlags(i,&flags);
         hdr->getFlags(i+1,&flagsNext);
         hdr->getPtsDts(i,&pts,&dts);
         hdr->getPtsDts(i+1,&ptsNext,&dtsNext);
+        if(!(flags & AVI_TOP_FIELD))
+        {
+            continue;
+        }
         if(!(flagsNext & AVI_BOTTOM_FIELD)) 
         {
-            fail++; 
             continue;
         }
+        // TOP / BOTTOM
         if(pts==ADM_NO_PTS)
         {
             fail++;
@@ -271,14 +275,22 @@
     {
     ADM_info("Filling 2nd field PTS\n");
     uint32_t fixed=0;
-    for(int i=0;i<nbFrames-1;i+=2)
+    for(int i=0;i<nbFrames-1;i+=1)
     {
         hdr->getFlags(i,&flags);
         hdr->getFlags(i+1,&flagsNext);
         hdr->getPtsDts(i,&pts,&dts);
         hdr->getPtsDts(i+1,&ptsNext,&dtsNext);
-        if(ptsNext==ADM_NO_PTS)
+        if(!(flags & AVI_TOP_FIELD))
         {
+            continue;
+        }
+        if(!(flagsNext & AVI_BOTTOM_FIELD)) 
+        {
+            continue;
+        }
+        if(pts!=ADM_NO_PTS && ptsNext==ADM_NO_PTS)
+        {
             ptsNext=pts+timeIncrementUs;
             hdr->setPtsDts(i+1,ptsNext,dtsNext);
             fixed++;



From mean at mail.berlios.de  Thu Jun  2 13:43:58 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Thu,  2 Jun 2011 13:43:58 +0200
Subject: [Avidemux-svn-commit] r7254 -
	branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/src
Message-ID: <20110602114358.C6776480BAD@sheep.berlios.de>

Author: mean
Date: 2011-06-02 13:43:58 +0200 (Thu, 02 Jun 2011)
New Revision: 7254

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/src/ADM_coreMuxerFfmpeg.cpp
Log:
[muxer] Provide  random pts instead of none. The video will be borked, but there will be a video

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/src/ADM_coreMuxerFfmpeg.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/src/ADM_coreMuxerFfmpeg.cpp	2011-06-02 11:43:57 UTC (rev 7253)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/src/ADM_coreMuxerFfmpeg.cpp	2011-06-02 11:43:58 UTC (rev 7254)
@@ -374,6 +374,7 @@
     int ret;
     int written=0;
     bool result=true;
+    int missingPts=0;
     
     float f=(float)vStream->getAvgFps1000();
     f=1000./f;
@@ -418,6 +419,14 @@
             {
                 lastVideoDts=out.dts;
             }
+            if(out.pts==ADM_NO_PTS)
+            {
+                ADM_warning("No PTS information for frame %"LU"\n",written);
+                missingPts++;
+                out.pts=lastVideoDts;
+            }
+
+
             encoding->pushVideoFrame(out.len,out.out_quantizer,lastVideoDts);
             muxerRescaleVideoTimeDts(&(out.dts),lastVideoDts);
             muxerRescaleVideoTime(&(out.pts));
@@ -514,6 +523,7 @@
         result=false;
     }
     ADM_info("[FF] Wrote %d frames, nb audio streams %d\n",written,nbAStreams);
+    ADM_info("[FF] Found %d missing PTS / %d total frames\n",missingPts,written);
     delete [] audioPackets;
     audioPackets=NULL;
     return result;



From mean at mail.berlios.de  Thu Jun  2 13:43:59 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Thu,  2 Jun 2011 13:43:59 +0200
Subject: [Avidemux-svn-commit] r7255 -
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/changeFps
Message-ID: <20110602114400.00C3F480BAD@sheep.berlios.de>

Author: mean
Date: 2011-06-02 13:43:59 +0200 (Thu, 02 Jun 2011)
New Revision: 7255

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/changeFps/changeFps.cpp
Log:
[changeFps/videoFilter] fix field description in dialog

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/changeFps/changeFps.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/changeFps/changeFps.cpp	2011-06-02 11:43:58 UTC (rev 7254)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/changeFps/changeFps.cpp	2011-06-02 11:43:59 UTC (rev 7255)
@@ -204,8 +204,8 @@
 
     mFps.link(tFps+0,1,&fps); // only activate entry in custom mode
 
-    diaElemMenu targetmFps(&(configuration.newMode),   QT_TR_NOOP("Source Fps:"), 6,tFps);
-    diaElemFloat targetfps(&newFrac,QT_TR_NOOP("Source frame rate:"),1,200.);
+    diaElemMenu targetmFps(&(configuration.newMode),   QT_TR_NOOP("Destination Fps:"), 6,tFps);
+    diaElemFloat targetfps(&newFrac,QT_TR_NOOP("Destination frame rate:"),1,200.);
 
     targetmFps.link(tFps+0,1,&targetfps); // only activate entry in custom mode
 



From mean at mail.berlios.de  Fri Jun  3 18:30:32 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Fri,  3 Jun 2011 18:30:32 +0200
Subject: [Avidemux-svn-commit] r7256 - tags
Message-ID: <20110603163032.6C3BD480C67@sheep.berlios.de>

Author: mean
Date: 2011-06-03 18:30:32 +0200 (Fri, 03 Jun 2011)
New Revision: 7256

Added:
   tags/avidemux_2.5.5/
Log:
tag 2.5.5




From mean at mail.berlios.de  Fri Jun  3 18:39:59 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Fri,  3 Jun 2011 18:39:59 +0200
Subject: [Avidemux-svn-commit] r7257 - tags/avidemux_2.5.5
Message-ID: <20110603163959.E6A65480C67@sheep.berlios.de>

Author: mean
Date: 2011-06-03 18:39:59 +0200 (Fri, 03 Jun 2011)
New Revision: 7257

Modified:
   tags/avidemux_2.5.5/CMakeLists.txt
Log:
[2.5.5] Set version to 2.5.5

Modified: tags/avidemux_2.5.5/CMakeLists.txt
===================================================================
--- tags/avidemux_2.5.5/CMakeLists.txt	2011-06-03 16:30:32 UTC (rev 7256)
+++ tags/avidemux_2.5.5/CMakeLists.txt	2011-06-03 16:39:59 UTC (rev 7257)
@@ -97,7 +97,7 @@
 ########################################
 # Standard Avidemux defines
 ########################################
-SET(VERSION 2.5.4)
+SET(VERSION 2.5.5)
 
 # Define internal flags for GTK+ and Qt4 builds.  These are turned off
 # if a showstopper is found.  CLI is automatically assumed as possible
@@ -118,18 +118,7 @@
 OPTION(SVN "" ON)
 SET(ADM_SUBVERSION 0)
 
-IF (SVN)
-	MESSAGE(STATUS "Checking for SCM Revision")
-	MESSAGE(STATUS "*************************")
 
-	SET(Subversion_FIND_REQUIRED OFF)
-	include(admGetRevision)
-	admGetRevision(${PROJECT_SOURCE_DIR} ADM_SUBVERSION)
-	MESSAGE(STATUS "  revision: ${ADM_SUBVERSION}")
-
-	MESSAGE("")
-ENDIF (SVN)
-
 ########################################
 # Check for libraries
 ########################################



From mean at mail.berlios.de  Tue Jun  7 20:08:18 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Tue,  7 Jun 2011 20:08:18 +0200
Subject: [Avidemux-svn-commit] r7258 -
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/crop
Message-ID: <20110607180818.C1491480EB1@sheep.berlios.de>

Author: mean
Date: 2011-06-07 20:08:18 +0200 (Tue, 07 Jun 2011)
New Revision: 7258

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/crop/ADM_vidCrop.cpp
Log:
[crop patch]

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/crop/ADM_vidCrop.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/crop/ADM_vidCrop.cpp	2011-06-03 16:39:59 UTC (rev 7257)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/crop/ADM_vidCrop.cpp	2011-06-07 18:08:18 UTC (rev 7258)
@@ -116,32 +116,32 @@
        		src=YPLANE(original)+configuration.top*x+configuration.left;
        		dest=YPLANE(image);
        		
-       		for(uint32_t k=info.height;k>0;k--)
-       			{
-       			 	    memcpy(dest,src,line);
-       			 	    src+=x;
-       			 	    dest+=line;
-       			}
-         // Crop U  & V
-            src=UPLANE(original)+(x*configuration.top>>2)+(configuration.left>>1);
-            src2=VPLANE(original)+(x*configuration.top>>2)+(configuration.left>>1);
-            dest=UPLANE(image);
-            line>>=1;
-            x>>=1;       		       		 	
-            uint32_t loop=(info.height)>>1;
-            for(uint32_t k=loop;k>0;k--)
-                {
-                        memcpy(dest,src,line);
-                        src+=x;
-                        dest+=line;
-                }
-                dest=VPLANE(image);	
-                for(uint32_t k=((info.height)>>1);k>0;k--)
-                {
-                        memcpy(dest,src2,line);
-                        src2+=x;
-                        dest+=line;
-                }	
+            
+
+            for(int i=0;i<3;i++)
+            {
+                    uint32_t srcPitch=original->GetPitch((ADM_PLANE )i);
+                    uint32_t dstPitch=image->GetPitch((ADM_PLANE )i);
+                    uint8_t  *src=original->GetReadPtr((ADM_PLANE)i);
+                    uint8_t  *dst=image->GetWritePtr((ADM_PLANE)i);
+                    uint32_t w=image->_width;
+                    uint32_t h=image->_height;
+
+                    uint32_t wOffset=configuration.left;
+                    uint32_t hOffset=configuration.top;
+
+                    if(i)
+                    {
+                        w>>=1;
+                        h>>=1;
+                        wOffset>>=1;
+                        hOffset>>=1;
+                    }
+                    src+=wOffset+hOffset*srcPitch;
+                    BitBlit(dst, dstPitch,
+                        src,srcPitch,
+                        w,h);
+            }
             //printf("Cropt:Dts = %"LLU"\n",image->Pts);
             image->copyInfo(original);     
             return 1;



From mean at mail.berlios.de  Thu Jun  9 20:04:12 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Thu,  9 Jun 2011 20:04:12 +0200
Subject: [Avidemux-svn-commit] r7259 - in branches/avidemux_2.6_branch_mean:
	avidemux/common/ADM_editor avidemux/common/ADM_render
	avidemux/common/ADM_videoCodec/src
	avidemux_core/ADM_coreImage/include avidemux_core/ADM_coreImage/src
Message-ID: <20110609180412.F198C4812F0@sheep.berlios.de>

Author: mean
Date: 2011-06-09 20:04:12 +0200 (Thu, 09 Jun 2011)
New Revision: 7259

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRenderInternal.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_render/GUI_vdpauRender.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoCodec/src/ADM_ffmpeg_vdpau.cpp
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImage/include/ADM_image.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImage/src/ADM_image.cpp
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImage/src/ADM_imageOperation.cpp
Log:
[image] Introduce hw ref image, reference to an hw surface (e.g. vdpau). For the moment it is used as side information to the real image.

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRenderInternal.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRenderInternal.cpp	2011-06-07 18:08:18 UTC (rev 7258)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRenderInternal.cpp	2011-06-09 18:04:12 UTC (rev 7259)
@@ -317,7 +317,9 @@
         }
         aprintf("[::Decompress] in:%"LU" out:%"LU" flags:%x\n",in->demuxerPts,out->Pts,out->flags);
 	// If not quant and it is already YV12, we can stop here
-	if((!tmpImage->quant || !tmpImage->_qStride) && tmpImage->_colorspace==ADM_COLOR_YV12)
+    // Also, if the image is decoded through hw, dont do post proc
+	if(tmpImage->refType!=ADM_HW_NONE || 
+                    (!tmpImage->quant || !tmpImage->_qStride) && tmpImage->_colorspace==ADM_COLOR_YV12)
 	{
 		out->_Qp=2;
 		out->duplicate(tmpImage);

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_render/GUI_vdpauRender.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_render/GUI_vdpauRender.cpp	2011-06-07 18:08:18 UTC (rev 7258)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_render/GUI_vdpauRender.cpp	2011-06-09 18:04:12 UTC (rev 7259)
@@ -16,12 +16,18 @@
 
 #include "ADM_default.h"
 #ifdef USE_VDPAU
+extern "C" {
+#include "libavcodec/avcodec.h"
+#include "libavcodec/vdpau.h"
+}
+
+
 #include "GUI_render.h"
 
 #include "GUI_accelRender.h"
 #include "GUI_vdpauRender.h"
 #include "ADM_coreVdpau/include/ADM_coreVdpau.h"
-
+#include "ADM_videoCodec/include/ADM_ffmpeg_vdpau_internal.h"
 static VdpOutputSurface     surface[2]={VDP_INVALID_HANDLE,VDP_INVALID_HANDLE};
 static VdpVideoSurface      input=VDP_INVALID_HANDLE;
 static VdpVideoMixer        mixer=VDP_INVALID_HANDLE;
@@ -127,6 +133,7 @@
 bool vdpauRender::displayImage(ADMImage *pic)
 {
     // Blit pic into our video Surface
+    VdpVideoSurface myInput=input;
     int next=currentSurface^1;
     uint32_t pitches[3];
     uint8_t *planes[3];
@@ -134,17 +141,25 @@
     pic->GetReadPlanes(planes);
 
     // Put out stuff in input...
-
-    if(VDP_STATUS_OK!=admVdpau::surfacePutBits( 
-            input,
-            planes,pitches))
+    // if input is already a VDPAU surface, no need to reupload it...
+    if(pic->refType==ADM_HW_VDPAU)
     {
-        ADM_warning("[Vdpau] video surface : Cannot putbits\n");
-        return false;
+        // cookie is a render...
+        struct vdpau_render_state *rndr = (struct vdpau_render_state *)pic->refDescriptor.refCookie;
+        myInput=rndr->surface;
+        printf("Skipping blit surface=%d\n",(int)myInput);
+    }else
+    {
+        if(VDP_STATUS_OK!=admVdpau::surfacePutBits( 
+                input,
+                planes,pitches))
+        {
+            ADM_warning("[Vdpau] video surface : Cannot putbits\n");
+            return false;
+        }
     }
-
     // Call mixer...
-    if(VDP_STATUS_OK!=admVdpau::mixerRender( mixer,input,surface[next], pic->_width,pic->_height))
+    if(VDP_STATUS_OK!=admVdpau::mixerRender( mixer,myInput,surface[next], pic->_width,pic->_height))
 
     {
         ADM_warning("[Vdpau] Cannot mixerRender\n");

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoCodec/src/ADM_ffmpeg_vdpau.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoCodec/src/ADM_ffmpeg_vdpau.cpp	2011-06-07 18:08:18 UTC (rev 7258)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoCodec/src/ADM_ffmpeg_vdpau.cpp	2011-06-09 18:04:12 UTC (rev 7259)
@@ -53,7 +53,32 @@
     ADM_VDPAU_MPEG2=2,
     ADM_VDPAU_VC1=3
 }ADM_VDPAU_TYPE;
+/**
+    \fn markSurfaceUsed
+    \brief mark the surfave as used. Can be called multiple time.
+*/
+static bool vdpauMarkSurfaceUsed(void *v, void * cookie)
+{
+    vdpauContext *vd=(vdpauContext*)v;
+    vdpau_render_state *render=(vdpau_render_state *)cookie;
+    render->refCount++;
+    return true;
+}
+/**
+    \fn markSurfaceUnused
+    \brief mark the surfave as unused by the caller. Can be called multiple time.
+*/
+static bool vdpauMarkSurfaceUnused(void *v, void * cookie)
+{
+    vdpauContext *vd=(vdpauContext*)v;
+    vdpau_render_state *render=(vdpau_render_state *)cookie;
+    render->refCount--;
+    if(!render->refCount)
+        vd->freeQueue.push_back(render);
+    return true;
+}
 
+
 /**
     \fn vdpauUsable
     \brief Return true if  vdpau can be used...
@@ -116,7 +141,9 @@
     }
     // Get an image   
     render=VDPAU->freeQueue.front();
+    render->refCount=0;
     VDPAU->freeQueue.erase(VDPAU->freeQueue.begin());
+    vdpauMarkSurfaceUsed(VDPAU,(void *)render);
     render->state=0;
     pic->data[0]=(uint8_t *)render;
     pic->data[1]=(uint8_t *)render;
@@ -152,12 +179,12 @@
   if(destroying==true) return; // They are already freed...
   render=(vdpau_render_state*)pic->data[0];
   ADM_assert(render);
-
+  ADM_assert(render->refCount);
   render->state &= ~FF_VDPAU_STATE_USED_FOR_REFERENCE;
   for(i=0; i<4; i++){
     pic->data[i]= NULL;
   }
-  VDPAU->freeQueue.push_back(render);
+  vdpauMarkSurfaceUnused(VDPAU,(void *)render);
 }
 /**
     \fn ADM_VDPAUreleaseBuffer
@@ -307,6 +334,13 @@
     // First let ffmpeg prepare datas...
     vdpau_copy=out;
     decode_status=false;
+
+    if(out->refType==ADM_HW_VDPAU)
+    {
+            vdpauMarkSurfaceUnused(VDPAU,out->refDescriptor.refCookie);
+            out->refType=ADM_HW_NONE;
+    }
+
     if(!decoderFF::uncompress (in, scratch))
     {
         aprintf("[VDPAU] No data from libavcodec\n");
@@ -329,7 +363,8 @@
 
     
    // Copy back the decoded image to our output ADM_image
-   aprintf("[VDPAU] Getting datas from surface %d\n",surface);
+    aprintf("[VDPAU] Getting datas from surface %d\n",surface);
+ 
     status=admVdpau::getDataSurface(surface,planes, stride );
     if(VDP_STATUS_OK!=status)
     {
@@ -338,6 +373,15 @@
         decode_status=false;
         return 0 ;
     }
+    if(decode_status)
+    {
+        out->refType=ADM_HW_VDPAU;
+        out->refDescriptor.refCookie=(void *)rndr;
+        out->refDescriptor.refInstance=VDPAU;
+        out->refDescriptor.refMarkUsed=vdpauMarkSurfaceUsed;
+        out->refDescriptor.refMarkUnused=vdpauMarkSurfaceUnused;
+        vdpauMarkSurfaceUsed(VDPAU,(void *)rndr);
+    }
     out->Pts=scratch->Pts;
     out->flags=scratch->flags;
     return (uint8_t)decode_status;

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImage/include/ADM_image.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImage/include/ADM_image.h	2011-06-07 18:08:18 UTC (rev 7258)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImage/include/ADM_image.h	2011-06-09 18:04:12 UTC (rev 7259)
@@ -51,9 +51,31 @@
 typedef enum
 {
     ADM_IMAGE_DEFAULT,
-    ADM_IMAGE_REF,
-    ADM_IMAGE_VDPAU
+    ADM_IMAGE_REF    
 }ADM_IMAGE_TYPE;
+
+typedef enum
+{
+        ADM_HW_NONE,
+        ADM_HW_VDPAU
+}ADM_HW_IMAGE;
+
+
+typedef bool refFunction(void *instance,void *cookie);
+typedef bool refDownloadFunction(ADMImage *image, void *instance, void *cookie);
+/**
+    \struct hwRefDescriptor
+    \brief  Used to deal with hw accelerated stuff
+*/
+typedef struct
+{
+        void            *refInstance;  ///
+        void            *refCookie;  /// Ref to a hw image
+        refFunction     *refMarkUsed;   ///
+        refFunction     *refMarkUnused; ///
+        refDownloadFunction     *refDownload;
+}hwRefDescriptor;
+
 #define YPLANE(x) ((x)->GetReadPtr(PLANAR_Y))
 #define UPLANE(x) ((x)->GetReadPtr(PLANAR_U))
 #define VPLANE(x) ((x)->GetReadPtr(PLANAR_V))
@@ -79,6 +101,9 @@
         ADM_colorspace  _colorspace;    /// Colorspace we are moving, default is YV12
         uint8_t         _noPicture;     /// No picture to display
         ADM_ASPECT	    _aspect;	/// Aspect ratio
+        //
+        ADM_HW_IMAGE    refType;    /// if not none, it means the field below is a ref to a hw image
+        hwRefDescriptor refDescriptor;
         // Quant info
         uint8_t         *quant;
         int             _qStride;
@@ -100,6 +125,10 @@
 protected:
         ADMImage(uint32_t width, uint32_t height,ADM_IMAGE_TYPE type);
 public:
+                     bool            hwIncRefCount(void);
+                     bool            hwDecRefCount(void);
+                     bool            hwDownloadFromRef(void);
+public:
         virtual      uint32_t        GetPitch(ADM_PLANE plane)=0;
         virtual      uint8_t        *GetWritePtr(ADM_PLANE plane)=0;
         virtual      uint8_t        *GetReadPtr(ADM_PLANE plane)=0;

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImage/src/ADM_image.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImage/src/ADM_image.cpp	2011-06-07 18:08:18 UTC (rev 7258)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImage/src/ADM_image.cpp	2011-06-09 18:04:12 UTC (rev 7259)
@@ -38,6 +38,9 @@
 */
 ADMImage::ADMImage(uint32_t width, uint32_t height,ADM_IMAGE_TYPE type)
 {
+        refType=ADM_HW_NONE;
+        memset(&refDescriptor,0,sizeof(refDescriptor));
+
         _width=width;
         _height=height;
         _Qp=2;
@@ -60,11 +63,53 @@
 ADMImage::~ADMImage()
 {
 	imgCurNb--;
+    hwDecRefCount();
+}
+/**
+    \fn hwIncRefCount
+    \brief hwIncRefCount
 
+*/
+
+ bool            ADMImage::hwIncRefCount(void)
+{
+        if(refType==ADM_HW_NONE) return true;
+        ADM_assert(refDescriptor.refMarkUsed);
+        return refDescriptor.refMarkUsed(refDescriptor.refInstance,refDescriptor.refCookie); 
 }
+/**
+    \fn hwDecRefCount
+    \brief hwDecRefCount
 
+*/
 
+ bool            ADMImage::hwDecRefCount(void)
+{
+        if(refType==ADM_HW_NONE) return true;
+        ADM_assert(refDescriptor.refMarkUnused);
+        bool r=refDescriptor.refMarkUnused(refDescriptor.refInstance,refDescriptor.refCookie); 
+        refType=ADM_HW_NONE;
+        return r;
+        
+}
 /**
+    \fn    hwDownloadFromRef
+    \brief Convert an HW ref image to a regular image
+
+*/
+ bool            ADMImage::hwDownloadFromRef(void)
+{
+bool r=false;
+        if(refType==ADM_HW_NONE) return true;
+        ADM_assert(refDescriptor.refDownload);
+        r=refDescriptor.refDownload(this,refDescriptor.refInstance,refDescriptor.refCookie);
+        hwDecRefCount();
+        refType=ADM_HW_NONE;
+        return r;
+
+}
+
+/**
  * 		\fn BitBlitAlpha
  * 		\brief Alpha blit from dst to src
  */

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImage/src/ADM_imageOperation.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImage/src/ADM_imageOperation.cpp	2011-06-07 18:08:18 UTC (rev 7258)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImage/src/ADM_imageOperation.cpp	2011-06-09 18:04:12 UTC (rev 7259)
@@ -30,6 +30,8 @@
         uint32_t sourceStride,destStride;
         uint8_t  *source,*dest;
 
+        hwDecRefCount(); // free hw ref image if any..
+
         for(int plane=PLANAR_Y;plane<PLANAR_LAST;plane++)
         {
             source=src->GetReadPtr((ADM_PLANE)plane);
@@ -45,6 +47,16 @@
             }
             BitBlit(dest, destStride,source,sourceStride,opWidth, opHeight);
         }
+        if(src->refType!=ADM_HW_NONE)
+        {
+            refType      =src->refType;
+            refDescriptor.refCookie    =src->refDescriptor.refCookie;
+            refDescriptor.refInstance  =src->refDescriptor.refInstance;
+            refDescriptor.refMarkUsed  =src->refDescriptor.refMarkUsed;
+            refDescriptor.refMarkUnused=src->refDescriptor.refMarkUnused;
+            refDescriptor.refDownload  =src->refDescriptor.refDownload;
+            hwIncRefCount();
+        }
         return true;
 }
 /**



From mean at mail.berlios.de  Thu Jun  9 20:04:14 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Thu,  9 Jun 2011 20:04:14 +0200
Subject: [Avidemux-svn-commit] r7260 - in branches/avidemux_2.6_branch_mean:
	avidemux/common/ADM_videoCodec/src
	avidemux/common/ADM_videoFilter2/include
	avidemux/common/ADM_videoFilter2/src
	avidemux_core/ADM_coreVideoFilter/include
	avidemux_core/ADM_coreVideoFilter/src
Message-ID: <20110609180414.C32A64812F0@sheep.berlios.de>

Author: mean
Date: 2011-06-09 20:04:14 +0200 (Thu, 09 Jun 2011)
New Revision: 7260

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoCodec/src/ADM_ffmpeg_vdpau.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter2/include/ADM_videoFilterBridge.h
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter2/src/ADM_videoFilterBridge.cpp
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/include/ADM_coreVideoFilter.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/src/ADM_coreVideoFilter.cpp
Log:
[core/editor] Add getNextFrameAs to request (if possible) a hw surface (vdpau)

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoCodec/src/ADM_ffmpeg_vdpau.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoCodec/src/ADM_ffmpeg_vdpau.cpp	2011-06-09 18:04:12 UTC (rev 7259)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoCodec/src/ADM_ffmpeg_vdpau.cpp	2011-06-09 18:04:14 UTC (rev 7260)
@@ -38,12 +38,12 @@
 #include "prefs.h"
 #include "ADM_coreVdpau/include/ADM_coreVdpau.h"
 #include "ADM_codecVdpau.h"
+#include "ADM_threads.h"
 
 
+static bool         vdpauWorking=false;
+static admMutex     surfaceMutex;
 
-static bool vdpauWorking=false;
-
-
 #define aprintf(...) {}
 
 typedef enum 
@@ -74,11 +74,54 @@
     vdpau_render_state *render=(vdpau_render_state *)cookie;
     render->refCount--;
     if(!render->refCount)
+    {
+        surfaceMutex.lock();
         vd->freeQueue.push_back(render);
+        surfaceMutex.unlock();
+    }
     return true;
 }
+/**
+    \fn vdpauRefDownload
+    \brief Convert a VDPAU image to a regular image
+*/
 
+static bool vdpauRefDownload(ADMImage *image, void *instance, void *cookie)
+{
+    vdpauContext *vd=(vdpauContext*)instance;
+    vdpau_render_state *render=(vdpau_render_state *)cookie;
+    ADM_assert(render->refCount);
+    ADM_assert(image->refType==ADM_HW_VDPAU);
+    
+    // other part will be done in goOn
+    VdpVideoSurface  surface;
 
+    surface=render->surface;
+    uint8_t *planes[3];
+    uint32_t stride[3];
+
+     image->GetWritePlanes(planes);
+     image->GetPitches(stride);
+
+    //ADM_info("Getting surface %d\n",(int)surface);
+    // Copy back the decoded image to our output ADM_image
+    aprintf("[VDPAU] Getting datas from surface %d\n",surface);
+ 
+    VdpStatus status=admVdpau::getDataSurface(surface,planes, stride );
+    if(VDP_STATUS_OK!=status)
+    {
+        ADM_error("[VDPAU] Cannot get data from surface <%s>\n",admVdpau::getErrorString(status));
+    }
+    image->refType=ADM_HW_NONE;
+    bool r=vdpauMarkSurfaceUnused(instance,cookie);
+    if(r==false || status!=VDP_STATUS_OK) 
+    {
+        ADM_warning("Cannot get VDPAU content from surface %d\n",(int)surface);
+        return false;
+    }
+    return true;
+}
+
 /**
     \fn vdpauUsable
     \brief Return true if  vdpau can be used...
@@ -140,9 +183,11 @@
         return -1;
     }
     // Get an image   
+    surfaceMutex.lock();
     render=VDPAU->freeQueue.front();
     render->refCount=0;
     VDPAU->freeQueue.erase(VDPAU->freeQueue.begin());
+    surfaceMutex.unlock();
     vdpauMarkSurfaceUsed(VDPAU,(void *)render);
     render->state=0;
     pic->data[0]=(uint8_t *)render;
@@ -349,42 +394,23 @@
     if(decode_status!=true)
     {
         printf("[VDPAU] error in renderDecode\n");
-        return 0;
+        return false;
     }
-    // other part will be done in goOn
-   struct vdpau_render_state *rndr = (struct vdpau_render_state *)scratch->GetReadPtr(PLANAR_Y);
-   VdpVideoSurface  surface;
-
-    surface=rndr->surface;
-    uint8_t *planes[3];
-    uint32_t stride[3];
-             vdpau_copy->GetWritePlanes(planes);
-             vdpau_copy->GetPitches(stride);
-
-    
-   // Copy back the decoded image to our output ADM_image
-    aprintf("[VDPAU] Getting datas from surface %d\n",surface);
- 
-    status=admVdpau::getDataSurface(surface,planes, stride );
-    if(VDP_STATUS_OK!=status)
-    {
-        
-        printf("[VDPAU] Cannot get data from surface <%s>\n",admVdpau::getErrorString(status));
-        decode_status=false;
-        return 0 ;
-    }
+    ADM_info("Surface used %d\n",VDPAU->freeQueue.size());
     if(decode_status)
     {
+        struct vdpau_render_state *rndr = (struct vdpau_render_state *)scratch->GetReadPtr(PLANAR_Y);
         out->refType=ADM_HW_VDPAU;
         out->refDescriptor.refCookie=(void *)rndr;
         out->refDescriptor.refInstance=VDPAU;
         out->refDescriptor.refMarkUsed=vdpauMarkSurfaceUsed;
         out->refDescriptor.refMarkUnused=vdpauMarkSurfaceUnused;
+        out->refDescriptor.refDownload=vdpauRefDownload;
         vdpauMarkSurfaceUsed(VDPAU,(void *)rndr);
     }
     out->Pts=scratch->Pts;
     out->flags=scratch->flags;
-    return (uint8_t)decode_status;
+    return (bool)decode_status;
 }
 /**
     \fn goOn

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter2/include/ADM_videoFilterBridge.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter2/include/ADM_videoFilterBridge.h	2011-06-09 18:04:12 UTC (rev 7259)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter2/include/ADM_videoFilterBridge.h	2011-06-09 18:04:14 UTC (rev 7260)
@@ -31,11 +31,13 @@
         FilterInfo          bridgeInfo;
         bool                firstImage;
         uint32_t            lastSentImage;
+        bool                getNextFrameBase(uint32_t *frameNumber,ADMImage *image);      
 public:
                             ADM_videoFilterBridge(uint64_t startTime, uint64_t endTime);
                             ~ADM_videoFilterBridge();
        virtual bool         goToTime(uint64_t usSeek);  
        virtual bool         getNextFrame(uint32_t *frameNumber,ADMImage *image);      
+               bool         getNextFrameAs(ADM_HW_IMAGE type,uint32_t *frameNumber,ADMImage *image);
        virtual FilterInfo  *getInfo(void);                                      /// Return picture parameters after this filter
        virtual bool         getCoupledConf(CONFcouple **couples) {*couples=NULL;return true;} ; /// Return the current filter configuration
        virtual uint64_t     getAbsoluteStartTime(void)  

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter2/src/ADM_videoFilterBridge.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter2/src/ADM_videoFilterBridge.cpp	2011-06-09 18:04:12 UTC (rev 7259)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter2/src/ADM_videoFilterBridge.cpp	2011-06-09 18:04:14 UTC (rev 7260)
@@ -46,27 +46,10 @@
     rewind();
 }
 /**
-    \fn rewind
-    \brief go or return to the original position...
-*/
-bool ADM_videoFilterBridge::rewind(void)
-{
-    return goToTime(0);
-}
-
-/**
-    \fn ADM_videoFilterBridge
-
-*/
-ADM_videoFilterBridge::~ADM_videoFilterBridge()
-{
-
-}
-/**
-    \fn getNextFrame
+    \fn     getNextFrameBase
     \brief
 */
-bool         ADM_videoFilterBridge::getNextFrame(uint32_t *frameNumber,ADMImage *image)
+bool         ADM_videoFilterBridge::getNextFrameBase(uint32_t *frameNumber,ADMImage *image)
 {
 again:
     bool r=false;
@@ -88,22 +71,67 @@
     int64_t pts=image->Pts;
     if(pts>endTime)
     {
-        printf("[VideoBridge] This frame is too late (%"LLD" vs %"LLU")\n",pts,endTime);
+        ADM_warning("[VideoBridge] This frame is too late (%"LLD" vs %"LLU")\n",pts,endTime);
         return false;
     }
     if(pts<startTime) 
     {
-            printf("[VideoBridge] This frame is too early (%"LLD" vs %"LLU")\n",pts,startTime);
+            ADM_warning("[VideoBridge] This frame is too early (%"LLD" vs %"LLU")\n",pts,startTime);
             goto again;
     }
     // Rescale time
     image->Pts-=startTime;
     return true;
 }
+
 /**
+    \fn rewind
+    \brief go or return to the original position...
+*/
+bool ADM_videoFilterBridge::rewind(void)
+{
+    return goToTime(0);
+}
+
+/**
     \fn ADM_videoFilterBridge
 
 */
+ADM_videoFilterBridge::~ADM_videoFilterBridge()
+{
+
+}
+/**
+    \fn getNextFrame
+    \brief
+*/
+bool         ADM_videoFilterBridge::getNextFrame(uint32_t *frameNumber,ADMImage *image)
+{
+    return getNextFrameAs(ADM_HW_NONE,frameNumber,image);
+}
+/**
+    \fn getNextFrameAs
+    \brief
+*/
+bool         ADM_videoFilterBridge::getNextFrameAs(ADM_HW_IMAGE type,uint32_t *frameNumber,ADMImage *image)
+{
+    if(false==getNextFrameBase(frameNumber,image)) 
+    {
+        ADM_warning("[Bridge] Base did not get an image\n");
+        return false;
+    }
+    // Check if image is 
+    if(type!=image->refType)
+    {        
+        return image->hwDownloadFromRef(); // nope, revert to base type
+    }
+    return true; 
+}
+
+/**
+    \fn ADM_videoFilterBridge
+
+*/
 FilterInfo  *ADM_videoFilterBridge::getInfo(void)
 {
     return &bridgeInfo;

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/include/ADM_coreVideoFilter.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/include/ADM_coreVideoFilter.h	2011-06-09 18:04:12 UTC (rev 7259)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/include/ADM_coreVideoFilter.h	2011-06-09 18:04:14 UTC (rev 7260)
@@ -49,6 +49,7 @@
        virtual const char   *getConfiguration(void);                   /// Return  current configuration as a human readable string
        virtual bool         goToTime(uint64_t usSeek);                 /// Overide this if you have cleanup to do after a jump      
        virtual bool         getNextFrame(uint32_t *frameNumber,ADMImage *image)=0;              /// Dont mix getFrame & getNextFrame !
+       virtual bool         getNextFrameAs(ADM_HW_IMAGE type,uint32_t *frameNumber,ADMImage *image);              /// Request frame as type (hw accel)
        virtual FilterInfo  *getInfo(void);                             /// Return picture parameters after this filter
        virtual bool         getCoupledConf(CONFcouple **couples)=0 ;   /// Return the current filter configuration
        virtual bool         configure(void) {return true;}             /// Start graphical user interface

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/src/ADM_coreVideoFilter.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/src/ADM_coreVideoFilter.cpp	2011-06-09 18:04:12 UTC (rev 7259)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/src/ADM_coreVideoFilter.cpp	2011-06-09 18:04:14 UTC (rev 7260)
@@ -58,6 +58,14 @@
     return "base";
 }  
 /**
+    \fn getNextFrameAs
+*/
+
+bool         ADM_coreVideoFilter::getNextFrameAs(ADM_HW_IMAGE type,uint32_t *frameNumber,ADMImage *image)
+{
+    return getNextFrame(frameNumber,image);
+}
+/**
     \fn getInfo
     \brief default behaviour, we return the Info as is from the previous filter in the chain
 */



From mean at mail.berlios.de  Thu Jun  9 20:04:16 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Thu,  9 Jun 2011 20:04:16 +0200
Subject: [Avidemux-svn-commit] r7261 - in
	branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImage:
	include src
Message-ID: <20110609180416.5F7D84812F0@sheep.berlios.de>

Author: mean
Date: 2011-06-09 20:04:16 +0200 (Thu, 09 Jun 2011)
New Revision: 7261

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImage/include/ADM_image.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImage/src/ADM_imageOperation.cpp
Log:
[core] When image is a hwRefImage, dont copy it, just add one more ref to that image

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImage/include/ADM_image.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImage/include/ADM_image.h	2011-06-09 18:04:14 UTC (rev 7260)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImage/include/ADM_image.h	2011-06-09 18:04:16 UTC (rev 7261)
@@ -57,7 +57,8 @@
 typedef enum
 {
         ADM_HW_NONE,
-        ADM_HW_VDPAU
+        ADM_HW_VDPAU,
+        ADM_HW_ANY=0xff
 }ADM_HW_IMAGE;
 
 

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImage/src/ADM_imageOperation.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImage/src/ADM_imageOperation.cpp	2011-06-09 18:04:14 UTC (rev 7260)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImage/src/ADM_imageOperation.cpp	2011-06-09 18:04:16 UTC (rev 7261)
@@ -31,25 +31,27 @@
         uint8_t  *source,*dest;
 
         hwDecRefCount(); // free hw ref image if any..
-
-        for(int plane=PLANAR_Y;plane<PLANAR_LAST;plane++)
+        if(src->refType==ADM_HW_NONE)
         {
-            source=src->GetReadPtr((ADM_PLANE)plane);
-            dest=this->GetWritePtr((ADM_PLANE)plane);
-            sourceStride=src->GetPitch((ADM_PLANE)plane);
-            destStride=this->GetPitch((ADM_PLANE)plane);
-            int opHeight=_height;
-            int opWidth=_width;
-            if(plane!=PLANAR_Y)
+            for(int plane=PLANAR_Y;plane<PLANAR_LAST;plane++)
             {
-                opHeight>>=1;
-                opWidth>>=1;
+                source=src->GetReadPtr((ADM_PLANE)plane);
+                dest=this->GetWritePtr((ADM_PLANE)plane);
+                sourceStride=src->GetPitch((ADM_PLANE)plane);
+                destStride=this->GetPitch((ADM_PLANE)plane);
+                int opHeight=_height;
+                int opWidth=_width;
+                if(plane!=PLANAR_Y)
+                {
+                    opHeight>>=1;
+                    opWidth>>=1;
+                }
+                BitBlit(dest, destStride,source,sourceStride,opWidth, opHeight);
             }
-            BitBlit(dest, destStride,source,sourceStride,opWidth, opHeight);
         }
-        if(src->refType!=ADM_HW_NONE)
+         else // it is a hw surface
         {
-            refType      =src->refType;
+            refType                    =src->refType;
             refDescriptor.refCookie    =src->refDescriptor.refCookie;
             refDescriptor.refInstance  =src->refDescriptor.refInstance;
             refDescriptor.refMarkUsed  =src->refDescriptor.refMarkUsed;



From mean at mail.berlios.de  Thu Jun  9 20:04:17 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Thu,  9 Jun 2011 20:04:17 +0200
Subject: [Avidemux-svn-commit] r7262 -
	branches/avidemux_2.6_branch_mean/avidemux/common/ADM_render
Message-ID: <20110609180417.B26B84812F0@sheep.berlios.de>

Author: mean
Date: 2011-06-09 20:04:17 +0200 (Thu, 09 Jun 2011)
New Revision: 7262

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_render/GUI_accelRender.h
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_render/GUI_render.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_render/GUI_render.h
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_render/GUI_vdpauRender.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_render/GUI_vdpauRender.h
Log:
[render] Add support for hwRefImage

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_render/GUI_accelRender.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_render/GUI_accelRender.h	2011-06-09 18:04:16 UTC (rev 7261)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_render/GUI_accelRender.h	2011-06-09 18:04:17 UTC (rev 7262)
@@ -36,5 +36,6 @@
               virtual   bool    refresh(void) {return true;}
               virtual   bool    changeZoom(renderZoom newzoom)=0;
               virtual   bool    usingUIRedraw(void)=0;
+              virtual   ADM_HW_IMAGE getPreferedImage(void ) {return ADM_HW_NONE;}
 };
 #endif

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_render/GUI_render.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_render/GUI_render.cpp	2011-06-09 18:04:16 UTC (rev 7261)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_render/GUI_render.cpp	2011-06-09 18:04:17 UTC (rev 7262)
@@ -197,6 +197,8 @@
 uint8_t renderUpdateImage(ADMImage *image)
 {
     ADM_assert(!_lock);
+    if(renderer->getPreferedImage()!=image->refType)
+            image->hwDownloadFromRef();
     renderer->displayImage(image);
     return 1;
 }
@@ -357,6 +359,16 @@
     return false;
 
 }
+/**
+    \fn renderGetPreferedImageFormat
+    \brief get the prefered hw accelerated image format (NONE,VDPAU,...)
+*/  
+ADM_HW_IMAGE renderGetPreferedImageFormat(void)
+{
+    if(!renderer) return ADM_HW_NONE;
+    return renderer->getPreferedImage();
+}
+
 //***************************************
 /**
     \fn bool calcDisplayFromZoom(renderZoom zoom);

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_render/GUI_render.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_render/GUI_render.h	2011-06-09 18:04:16 UTC (rev 7261)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_render/GUI_render.h	2011-06-09 18:04:17 UTC (rev 7262)
@@ -44,7 +44,7 @@
 uint8_t renderStartPlaying( void );
 uint8_t renderStopPlaying( void );
 bool    renderExposeEventFromUI(void); // This is called by UI, return true if UI should redraw, false else
-
+ADM_HW_IMAGE renderGetPreferedImageFormat(void);
 uint8_t renderLock(void);
 uint8_t renderUnlock(void);
 bool renderHookRefreshRequest(refreshSB cb);

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_render/GUI_vdpauRender.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_render/GUI_vdpauRender.cpp	2011-06-09 18:04:16 UTC (rev 7261)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_render/GUI_vdpauRender.cpp	2011-06-09 18:04:17 UTC (rev 7262)
@@ -147,9 +147,10 @@
         // cookie is a render...
         struct vdpau_render_state *rndr = (struct vdpau_render_state *)pic->refDescriptor.refCookie;
         myInput=rndr->surface;
-        printf("Skipping blit surface=%d\n",(int)myInput);
+        //printf("Skipping blit surface=%d\n",(int)myInput);
     }else
     {
+        //printf("Blitting surface\n");
         if(VDP_STATUS_OK!=admVdpau::surfacePutBits( 
                 input,
                 planes,pitches))

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_render/GUI_vdpauRender.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_render/GUI_vdpauRender.h	2011-06-09 18:04:16 UTC (rev 7261)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_render/GUI_vdpauRender.h	2011-06-09 18:04:17 UTC (rev 7262)
@@ -35,6 +35,7 @@
               virtual   bool changeZoom(renderZoom newzoom);
               virtual   bool refresh(void);
               virtual   bool usingUIRedraw(void) {return false;}; // we can redraw by ourself
+              virtual   ADM_HW_IMAGE getPreferedImage(void ) {return ADM_HW_VDPAU;}
 };
 #endif
 



From mean at mail.berlios.de  Thu Jun  9 20:04:19 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Thu,  9 Jun 2011 20:04:19 +0200
Subject: [Avidemux-svn-commit] r7263 - in
	branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter2:
	include src
Message-ID: <20110609180419.37B264812F0@sheep.berlios.de>

Author: mean
Date: 2011-06-09 20:04:18 +0200 (Thu, 09 Jun 2011)
New Revision: 7263

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter2/include/ADM_filterThread.h
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter2/src/ADM_filterThread.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter2/src/ADM_videoFilterBridge.cpp
Log:
[bridge/queue] When creating videoBridge and the associated image queue, keep them as hwRef as long as possible if they are not native image

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter2/include/ADM_filterThread.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter2/include/ADM_filterThread.h	2011-06-09 18:04:17 UTC (rev 7262)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter2/include/ADM_filterThread.h	2011-06-09 18:04:18 UTC (rev 7263)
@@ -34,7 +34,8 @@
        virtual bool         configure(void) {return true;}             /// Start graphical user interface
 /**/
        virtual bool         goToTime(uint64_t usSeek); 
-       virtual bool         getNextFrame(uint32_t *frameNumber,ADMImage *image);     
+       virtual bool         getNextFrame(uint32_t *frameNumber,ADMImage *image);    
+       virtual bool         getNextFrameAs( ADM_HW_IMAGE type,uint32_t *frameNumber,ADMImage *image) ;
        virtual FilterInfo  *getInfo(void)    ;
 
 protected:

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter2/src/ADM_filterThread.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter2/src/ADM_filterThread.cpp	2011-06-09 18:04:17 UTC (rev 7262)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter2/src/ADM_filterThread.cpp	2011-06-09 18:04:18 UTC (rev 7263)
@@ -72,6 +72,11 @@
 */
 bool         ADM_videoFilterQueue::getNextFrame(uint32_t *frameNumber,ADMImage *image)
 {
+    return getNextFrameAs(ADM_HW_NONE,frameNumber,image);
+}
+bool         ADM_videoFilterQueue::getNextFrameAs( ADM_HW_IMAGE type,uint32_t *frameNumber,ADMImage *image)
+{
+
      if(false==started)
         {
             startThread();      
@@ -148,7 +153,7 @@
         freeList.erase(freeList.begin());
         mutex->unlock();
 
-        if(false==previousFilter->getNextFrame(&fn,source))
+        if(false==previousFilter->getNextFrameAs(ADM_HW_ANY,&fn,source))
         {
            
             ADM_info("Video Thread, no more data\n");

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter2/src/ADM_videoFilterBridge.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter2/src/ADM_videoFilterBridge.cpp	2011-06-09 18:04:17 UTC (rev 7262)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter2/src/ADM_videoFilterBridge.cpp	2011-06-09 18:04:18 UTC (rev 7263)
@@ -121,6 +121,7 @@
         return false;
     }
     // Check if image is 
+    if(ADM_HW_ANY==type) return true;
     if(type!=image->refType)
     {        
         return image->hwDownloadFromRef(); // nope, revert to base type



From mean at mail.berlios.de  Thu Jun  9 20:04:20 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Thu,  9 Jun 2011 20:04:20 +0200
Subject: [Avidemux-svn-commit] r7264 -
	branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoCodec/src
Message-ID: <20110609180420.6D0C54812F0@sheep.berlios.de>

Author: mean
Date: 2011-06-09 20:04:20 +0200 (Thu, 09 Jun 2011)
New Revision: 7264

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoCodec/src/ADM_ffmpeg_vdpau.cpp
Log:
[adm vdpau] silence

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoCodec/src/ADM_ffmpeg_vdpau.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoCodec/src/ADM_ffmpeg_vdpau.cpp	2011-06-09 18:04:18 UTC (rev 7263)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoCodec/src/ADM_ffmpeg_vdpau.cpp	2011-06-09 18:04:20 UTC (rev 7264)
@@ -396,7 +396,7 @@
         printf("[VDPAU] error in renderDecode\n");
         return false;
     }
-    ADM_info("Surface used %d\n",VDPAU->freeQueue.size());
+    //ADM_info("Surface used %d\n",VDPAU->freeQueue.size());
     if(decode_status)
     {
         struct vdpau_render_state *rndr = (struct vdpau_render_state *)scratch->GetReadPtr(PLANAR_Y);



From mean at mail.berlios.de  Thu Jun  9 20:04:21 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Thu,  9 Jun 2011 20:04:21 +0200
Subject: [Avidemux-svn-commit] r7265 -
	branches/avidemux_2.6_branch_mean/avidemux/common
Message-ID: <20110609180421.8B34D4812F0@sheep.berlios.de>

Author: mean
Date: 2011-06-09 20:04:21 +0200 (Thu, 09 Jun 2011)
New Revision: 7265

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_preview.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_preview.h
   branches/avidemux_2.6_branch_mean/avidemux/common/gui_play.cpp
Log:
[preview/playback] Handle hwRef image case

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_preview.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_preview.cpp	2011-06-09 18:04:20 UTC (rev 7264)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_preview.cpp	2011-06-09 18:04:21 UTC (rev 7265)
@@ -70,6 +70,13 @@
     return rdrImage;
 }
 /**
+    \fn getPreferedHwImageFormat
+*/
+ADM_HW_IMAGE admPreview::getPreferedHwImageFormat(void)
+{
+    return renderGetPreferedImageFormat();
+}
+/**
       \fn admPreview::setMainDimension
       \brief Update width & height of input video
       @param w : width

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_preview.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_preview.h	2011-06-09 18:04:20 UTC (rev 7264)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_preview.h	2011-06-09 18:04:21 UTC (rev 7265)
@@ -44,5 +44,6 @@
       static bool previousFrame(void);
       static void destroy(void);
       static bool updateImage(void);
+      static ADM_HW_IMAGE getPreferedHwImageFormat(void);
 };
 #endif

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/gui_play.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/gui_play.cpp	2011-06-09 18:04:20 UTC (rev 7264)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/gui_play.cpp	2011-06-09 18:04:21 UTC (rev 7265)
@@ -234,12 +234,14 @@
     ticktock.reset();
     vuMeterPts=0;
     ADMImage *previewBuffer=admPreview::getBuffer();
+    ADM_HW_IMAGE hwImageFormat=admPreview::getPreferedHwImageFormat();
+
     do
     {
 
         admPreview::displayNow();;
         GUI_setCurrentFrameAndTime(firstPts);
-        if(false==videoFilter->getNextFrame(&fn,previewBuffer))
+        if(false==videoFilter->getNextFrameAs(hwImageFormat,&fn,previewBuffer))
         {
             printf("[Play] Cancelling playback, nextPicture failed\n");
             break;



From mean at mail.berlios.de  Thu Jun  9 20:05:16 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Thu,  9 Jun 2011 20:05:16 +0200
Subject: [Avidemux-svn-commit] r7266 -
	branches/avidemux_2.6_branch_mean/avidemux/cli/ADM_UIs/src
Message-ID: <20110609180516.E0D144812F0@sheep.berlios.de>

Author: mean
Date: 2011-06-09 20:05:16 +0200 (Thu, 09 Jun 2011)
New Revision: 7266

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/cli/ADM_UIs/src/FAC_toggle.cpp
Log:
[CLI] Use new toggle widget interface

Modified: branches/avidemux_2.6_branch_mean/avidemux/cli/ADM_UIs/src/FAC_toggle.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/cli/ADM_UIs/src/FAC_toggle.cpp	2011-06-09 18:04:21 UTC (rev 7265)
+++ branches/avidemux_2.6_branch_mean/avidemux/cli/ADM_UIs/src/FAC_toggle.cpp	2011-06-09 18:05:16 UTC (rev 7266)
@@ -27,7 +27,7 @@
 
 
 
-diaElemToggle::diaElemToggle(uint32_t *toggleValue,const char *toggleTitle, const char *tip)
+diaElemToggle::diaElemToggle(bool *toggleValue,const char *toggleTitle, const char *tip)
   : diaElemToggleBase()
 {
 }



From mean at mail.berlios.de  Thu Jun  9 21:20:30 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Thu,  9 Jun 2011 21:20:30 +0200
Subject: [Avidemux-svn-commit] r7267 -
	branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter2/src
Message-ID: <20110609192031.1F69A48137E@sheep.berlios.de>

Author: mean
Date: 2011-06-09 21:20:30 +0200 (Thu, 09 Jun 2011)
New Revision: 7267

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter2/src/ADM_filterThread.cpp
Log:
[image queue] Convert to regular image if the client request it

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter2/src/ADM_filterThread.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter2/src/ADM_filterThread.cpp	2011-06-09 18:05:16 UTC (rev 7266)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter2/src/ADM_filterThread.cpp	2011-06-09 19:20:30 UTC (rev 7267)
@@ -93,6 +93,8 @@
                 ADMImage *source=(ADMImage *)pkt.data;
                 *frameNumber=pkt.pts;
                 image->duplicateFull(source);
+                if(type!=image->refType && type!=ADM_HW_ANY)
+                    image->hwDownloadFromRef();
                 list.erase(list.begin());
                 freeList.push_back(pkt);
                 if(cond->iswaiting())



From mean at mail.berlios.de  Thu Jun  9 21:45:39 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Thu,  9 Jun 2011 21:45:39 +0200
Subject: [Avidemux-svn-commit] r7268 -
	branches/avidemux_2.6_branch_mean/avidemux_core/ffmpeg_package/patches
Message-ID: <20110609194540.2EC1848137E@sheep.berlios.de>

Author: mean
Date: 2011-06-09 21:45:39 +0200 (Thu, 09 Jun 2011)
New Revision: 7268

Added:
   branches/avidemux_2.6_branch_mean/avidemux_core/ffmpeg_package/patches/vdpau.h.patch
Log:
[vdpau] add refcount to ffmpeg vdpau descriptor

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ffmpeg_package/patches/vdpau.h.patch
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ffmpeg_package/patches/vdpau.h.patch	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ffmpeg_package/patches/vdpau.h.patch	2011-06-09 19:45:39 UTC (rev 7268)
@@ -0,0 +1,11 @@
+--- ./libavcodec/vdpau.h.old	2011-06-04 08:57:49.618318959 +0200
++++ ./libavcodec/vdpau.h	2011-06-04 08:58:14.098318959 +0200
+@@ -66,7 +66,7 @@
+     VdpVideoSurface surface; ///< Used as rendered surface, never changed.
+ 
+     int state; ///< Holds FF_VDPAU_STATE_* values.
+-
++    int refCount; /// Used by how many client
+     /** Describe size/location of the compressed video data.
+         Set to 0 when freeing bitstream_buffers. */
+     int bitstream_buffers_allocated;



From mean at mail.berlios.de  Fri Jun 10 19:58:16 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Fri, 10 Jun 2011 19:58:16 +0200
Subject: [Avidemux-svn-commit] r7269 - in branches/avidemux_2.6_branch_mean:
	avidemux_core/ADM_coreVideoFilter/include
	avidemux_core/ADM_coreVideoFilter/src
	avidemux_plugins/ADM_videoFilters6/vdpauFilters
Message-ID: <20110610175816.6B2D94801AA@sheep.berlios.de>

Author: mean
Date: 2011-06-10 19:58:16 +0200 (Fri, 10 Jun 2011)
New Revision: 7269

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/include/ADM_videoFilterCache.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/src/ADM_videoFilterCache.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/vdpauFilters/ADM_vidVdpauFilter.cpp
Log:
[filterCache] Handle hw images + make vdpau resize handle hw image

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/include/ADM_videoFilterCache.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/include/ADM_videoFilterCache.h	2011-06-09 19:45:39 UTC (rev 7268)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/include/ADM_videoFilterCache.h	2011-06-10 17:58:16 UTC (rev 7269)
@@ -41,12 +41,13 @@
 		int32_t 	        searchFrame( uint32_t frame);
 		int32_t 	        searchPtr( ADMImage *ptr);
         int                 searchFreeEntry(void);
-		
+		ADMImage            *getImageBase(uint32_t frame);
 	public:
 		VideoCache(uint32_t nb,ADM_coreVideoFilter *in);
 		~VideoCache(void);
 		
 		ADMImage *getImage(uint32_t frame);
+        ADMImage *getImageAs(ADM_HW_IMAGE type,uint32_t frame);
 		uint8_t unlockAll(void);
 		uint8_t unlock(ADMImage  *frame);
 		uint8_t flush(void);

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/src/ADM_videoFilterCache.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/src/ADM_videoFilterCache.cpp	2011-06-09 19:45:39 UTC (rev 7268)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/src/ADM_videoFilterCache.cpp	2011-06-10 17:58:16 UTC (rev 7269)
@@ -144,10 +144,11 @@
     ADM_assert(target!=0xfff);
     return target;
 }
+
 /**
-    \fn getImage
+    \fn getImageBase
 */
-ADMImage *VideoCache::getImage(uint32_t frame)
+ADMImage *VideoCache::getImageBase(uint32_t frame)
 {
 int32_t i;
 uint32_t tryz=nbEntry;
@@ -166,7 +167,7 @@
 	int target=searchFreeEntry();
     uint32_t nb;
     ADMImage *img=entry[target].image;
-    if(!incoming->getNextFrame(&nb,img)) return NULL;
+    if(!incoming->getNextFrameAs(ADM_HW_ANY,&nb,img)) return NULL;
     if(nb!=frame)
     {
         ADM_error("Expected frame %d, got frame %d\n",(int)frame,(int)nb);
@@ -184,6 +185,29 @@
     return img;
 }
 /**
+    \fn getImageAs
+*/
+ADMImage *VideoCache::getImage(uint32_t frame)
+{
+    return getImageAs(ADM_HW_NONE,frame);
+}
+
+/**
+    \fn getImageAs
+*/
+ADMImage *VideoCache::getImageAs(ADM_HW_IMAGE type,uint32_t frame)
+{
+    ADMImage *img=getImageBase(frame);
+    if(!img) return NULL;
+    if(type==ADM_HW_ANY) return img;
+    if(type!=img->refType)
+    {
+        img->hwDownloadFromRef();
+    }
+    return img;
+}   
+
+/**
     \fn dump
 */
 void VideoCache::dump(void)

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/vdpauFilters/ADM_vidVdpauFilter.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/vdpauFilters/ADM_vidVdpauFilter.cpp	2011-06-09 19:45:39 UTC (rev 7268)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/vdpauFilters/ADM_vidVdpauFilter.cpp	2011-06-10 17:58:16 UTC (rev 7269)
@@ -7,12 +7,20 @@
 */
 
 #include "ADM_default.h"
+extern "C" {
+#include "libavcodec/avcodec.h"
+#include "libavcodec/vdpau.h"
+}
+
 #include "ADM_coreVideoFilterInternal.h"
 #include "ADM_videoFilterCache.h"
 #include "DIA_factory.h"
 #include "vdpauFilter.h"
 #include "vdpauFilter_desc.cpp"
 #ifdef USE_VDPAU
+
+
+
 #include "ADM_coreVdpau/include/ADM_coreVdpau.h"
 //
 #define ADM_INVALID_FRAME_NUM 0x80000000
@@ -31,7 +39,7 @@
 
                     uint8_t             *tempBuffer;
                     vdpauFilter          configuration;
-                    VdpOutputSurface     surface;
+                    VdpOutputSurface     outputSurface;
                     VdpVideoSurface      input[ADM_NB_SURFACES];
                     uint32_t             frameDesc[ADM_NB_SURFACES];
                     uint32_t             currentIndex;
@@ -54,9 +62,9 @@
                         1,0,0,              // Version
                         ADM_UI_GTK+ADM_UI_QT4,     // We need a display for VDPAU; so no cli...
                         VF_TRANSFORM,            // Category
-                        "vdpau",            // internal name (must be uniq!)
-                        "vdpau",            // Display name
-                        "vdpau, vdpau filters." // Description
+                        "vdpauResize",            // internal name (must be uniq!)
+                        "vdpau: Resize",            // Display name
+                        "vdpau: Resize image using vdpau." // Description
                     );
 
 //
@@ -89,7 +97,7 @@
     if(info.width==previousFilter->getInfo()->width &&  info.height==previousFilter->getInfo()->height)
         return false;
     if(VDP_STATUS_OK!=admVdpau::outputSurfaceCreate(VDP_RGBA_FORMAT_B8G8R8A8,
-                        info.width,info.height,&surface)) 
+                        info.width,info.height,&outputSurface)) 
     {
         ADM_error("Cannot create outputSurface0\n");
         return false;
@@ -110,7 +118,7 @@
         goto badInit;
     } 
     tempBuffer=new uint8_t[info.width*info.height*4];
-    scaler=new ADMColorScalerSimple( info.width,info.height, ADM_COLOR_BGR32A,ADM_COLOR_YV12);
+    scaler=new ADMColorScalerSimple( info.width,info.height, ADM_COLOR_RGB32A,ADM_COLOR_YV12);
     ADM_info("VDPAU setup ok\n");
     return true;
 badInit:
@@ -125,9 +133,9 @@
 {
     for(int i=0;i<ADM_NB_SURFACES;i++)
         if(input[i]!=VDP_INVALID_HANDLE) admVdpau::surfaceDestroy(input[i]);
-    if(surface!=VDP_INVALID_HANDLE)  admVdpau::outputSurfaceDestroy(surface);
+    if(outputSurface!=VDP_INVALID_HANDLE)  admVdpau::outputSurfaceDestroy(outputSurface);
     if(mixer!=VDP_INVALID_HANDLE) admVdpau::mixerDestroy(mixer);
-    surface=VDP_INVALID_HANDLE;
+    outputSurface=VDP_INVALID_HANDLE;
     for(int i=0;i<ADM_NB_SURFACES;i++)
         input[i]=VDP_INVALID_HANDLE;
     mixer=VDP_INVALID_HANDLE;
@@ -145,7 +153,7 @@
     for(int i=0;i<ADM_NB_SURFACES;i++)
         input[i]=VDP_INVALID_HANDLE;
     mixer=VDP_INVALID_HANDLE;
-    surface=VDP_INVALID_HANDLE;
+    outputSurface=VDP_INVALID_HANDLE;
     if(!setup || !ADM_paramLoad(setup,vdpauFilter_param,&configuration))
     {
         // Default value
@@ -261,19 +269,30 @@
     
      if(passThrough) return previousFilter->getNextFrame(fn,image);
     // regular image, in fact we get the next image here
-    ADMImage *next= vidCache->getImage(nextFrame);
-    if(false==uploadImage(next,0,nextFrame)) 
-            {
-                vidCache->unlockAll();
-                return false;
-            }
+    VdpVideoSurface tmpSurface=VDP_INVALID_HANDLE;
+    ADMImage *next= vidCache->getImageAs(ADM_HW_VDPAU,nextFrame);
+    if(next->refType==ADM_HW_VDPAU)
+    {
+        
+        struct vdpau_render_state *rndr = (struct vdpau_render_state *)next->refDescriptor.refCookie;
+        tmpSurface=rndr->surface;
+        printf("image is already vdpau %d\n",(int)tmpSurface);
+    }else
+    {
+        printf("Uploading image to vdpau\n");
+        if(false==uploadImage(next,0,nextFrame)) 
+                {
+                    vidCache->unlockAll();
+                    return false;
+                }
+        tmpSurface=input[0];
+    }
     
-   
     // Call mixer...
     if(VDP_STATUS_OK!=admVdpau::mixerRender( 
                 mixer,
-                input[0],
-                surface, 
+                tmpSurface,
+                outputSurface, 
                 info.width,info.height))
 
     {
@@ -282,7 +301,7 @@
         return false;
     }
     // Now get our image back from surface...
-    if(VDP_STATUS_OK!=admVdpau::outputSurfaceGetBitsNative(surface,tempBuffer, info.width,info.height))
+    if(VDP_STATUS_OK!=admVdpau::outputSurfaceGetBitsNative(outputSurface,tempBuffer, info.width,info.height))
     {
         ADM_warning("[Vdpau] Cannot copy back data from output surface\n");
         vidCache->unlockAll();
@@ -300,10 +319,10 @@
     // Invert U&V
     uint32_t ts;
     uint8_t  *td;
-
+#if 0
     ts=destStride[2];destStride[2]=destStride[1];destStride[1]=ts;
     td=destData[2];destData[2]=destData[1];destData[1]=td;
-
+#endif
     scaler->convertPlanes(  sourceStride,destStride,     
                             sourceData,destData);
     nextFrame++;



From mean at mail.berlios.de  Sat Jun 11 09:10:47 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Sat, 11 Jun 2011 09:10:47 +0200
Subject: [Avidemux-svn-commit] r7270 -
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/vdpauFilters
Message-ID: <20110611071048.1E79D480CBB@sheep.berlios.de>

Author: mean
Date: 2011-06-11 09:10:47 +0200 (Sat, 11 Jun 2011)
New Revision: 7270

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/vdpauFilters/ADM_vidVdpauFilter.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/vdpauFilters/ADM_vidVdpauFilterDeint.cpp
Log:
 [vdpau plugins] dont build vdpau if not present

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/vdpauFilters/ADM_vidVdpauFilter.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/vdpauFilters/ADM_vidVdpauFilter.cpp	2011-06-10 17:58:16 UTC (rev 7269)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/vdpauFilters/ADM_vidVdpauFilter.cpp	2011-06-11 07:10:47 UTC (rev 7270)
@@ -7,6 +7,7 @@
 */
 
 #include "ADM_default.h"
+#ifdef USE_VDPAU
 extern "C" {
 #include "libavcodec/avcodec.h"
 #include "libavcodec/vdpau.h"
@@ -17,10 +18,10 @@
 #include "DIA_factory.h"
 #include "vdpauFilter.h"
 #include "vdpauFilter_desc.cpp"
-#ifdef USE_VDPAU
 
 
 
+
 #include "ADM_coreVdpau/include/ADM_coreVdpau.h"
 //
 #define ADM_INVALID_FRAME_NUM 0x80000000
@@ -330,6 +331,11 @@
     vidCache->unlockAll();
     return true;
 }
-#endif
+#else // USE_VDPAU
+static void dumy_func2(voi)
+{
+    return;
+}
+#endif 
 //****************
 // EOF

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/vdpauFilters/ADM_vidVdpauFilterDeint.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/vdpauFilters/ADM_vidVdpauFilterDeint.cpp	2011-06-10 17:58:16 UTC (rev 7269)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/vdpauFilters/ADM_vidVdpauFilterDeint.cpp	2011-06-11 07:10:47 UTC (rev 7270)
@@ -6,13 +6,14 @@
 
 */
 #include "ADM_default.h"
+#ifdef USE_VDPAU
 #include "ADM_coreVideoFilterInternal.h"
 #include "ADM_videoFilterCache.h"
 #include "DIA_factory.h"
 #include "ADM_vidMisc.h"
 #include "vdpauFilterDeint.h"
 #include "vdpauFilterDeint_desc.cpp"
-#ifdef USE_VDPAU
+
 #include "ADM_coreVdpau/include/ADM_coreVdpau.h"
 //
 #define ADM_INVALID_FRAME_NUM 0x80000000
@@ -47,7 +48,7 @@
                     bool                 updateConf(void);
                     uint8_t             *tempBuffer;
                     vdpauFilterDeint     configuration;
-                    VdpOutputSurface     surface;
+                    VdpOutputSurface     outputSurface;
                     VdpVideoSurface      input[ADM_NB_SURFACES];
                     uint32_t             frameDesc[ADM_NB_SURFACES];
                     VdpVideoMixer        mixer;
@@ -131,7 +132,7 @@
         return false;
     }   
     if(VDP_STATUS_OK!=admVdpau::outputSurfaceCreate(VDP_RGBA_FORMAT_B8G8R8A8,
-                        info.width,info.height,&surface)) 
+                        info.width,info.height,&outputSurface)) 
     {
         ADM_error("Cannot create outputSurface0\n");
         return false;
@@ -167,9 +168,9 @@
 {
     for(int i=0;i<ADM_NB_SURFACES;i++)
         if(input[i]!=VDP_INVALID_HANDLE) admVdpau::surfaceDestroy(input[i]);
-    if(surface!=VDP_INVALID_HANDLE)  admVdpau::outputSurfaceDestroy(surface);
+    if(outputSurface!=VDP_INVALID_HANDLE)  admVdpau::outputSurfaceDestroy(outputSurface);
     if(mixer!=VDP_INVALID_HANDLE) admVdpau::mixerDestroy(mixer);
-    surface=VDP_INVALID_HANDLE;
+    outputSurface=VDP_INVALID_HANDLE;
     for(int i=0;i<ADM_NB_SURFACES;i++)
         input[i]=VDP_INVALID_HANDLE;
     mixer=VDP_INVALID_HANDLE;
@@ -189,7 +190,7 @@
     for(int i=0;i<ADM_NB_SURFACES;i++)
         input[i]=VDP_INVALID_HANDLE;
     mixer=VDP_INVALID_HANDLE;
-    surface=VDP_INVALID_HANDLE;
+    outputSurface=VDP_INVALID_HANDLE;
     if(!setup || !ADM_paramLoad(setup,vdpauFilterDeint_param,&configuration))
     {
         // Default value
@@ -346,7 +347,7 @@
     if(VDP_STATUS_OK!=admVdpau::mixerRenderWithPastAndFuture(topField, 
                 mixer,
                 in,
-                surface, 
+                outputSurface, 
                 previousFilter->getInfo()->width,previousFilter->getInfo()->height))
 
     {
@@ -362,7 +363,7 @@
 */
 bool vdpauVideoFilterDeint::getResult(ADMImage *image)
 {
- if(VDP_STATUS_OK!=admVdpau::outputSurfaceGetBitsNative(surface,
+    if(VDP_STATUS_OK!=admVdpau::outputSurfaceGetBitsNative(outputSurface,
                                                             tempBuffer, 
                                                             info.width,info.height))
     {
@@ -478,7 +479,12 @@
    // printf("VDPAU OUT PTS= %"LLU"\n",image->Pts);
     return r;
 }
-#endif
+#else // USE_VDPAU
+static void dummy_fun(void)
+{
+    return ;
+}
+#endif // use VDPAU
 
 //****************
 // EOF



From mean at mail.berlios.de  Sat Jun 11 09:29:24 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Sat, 11 Jun 2011 09:29:24 +0200
Subject: [Avidemux-svn-commit] r7271 -
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/vdpauFilters
Message-ID: <20110611072924.E9F50480CBB@sheep.berlios.de>

Author: mean
Date: 2011-06-11 09:29:24 +0200 (Sat, 11 Jun 2011)
New Revision: 7271

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/vdpauFilters/ADM_vidVdpauFilter.cpp
Log:
 [vdpau plugins] dont build vdpau if not present

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/vdpauFilters/ADM_vidVdpauFilter.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/vdpauFilters/ADM_vidVdpauFilter.cpp	2011-06-11 07:10:47 UTC (rev 7270)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/vdpauFilters/ADM_vidVdpauFilter.cpp	2011-06-11 07:29:24 UTC (rev 7271)
@@ -332,7 +332,7 @@
     return true;
 }
 #else // USE_VDPAU
-static void dumy_func2(voi)
+static void dumy_func2(void)
 {
     return;
 }



From mean at mail.berlios.de  Sat Jun 11 16:32:03 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Sat, 11 Jun 2011 16:32:03 +0200
Subject: [Avidemux-svn-commit] r7272 -
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/swapUV
Message-ID: <20110611143203.7E0D3480CBB@sheep.berlios.de>

Author: mean
Date: 2011-06-11 16:32:02 +0200 (Sat, 11 Jun 2011)
New Revision: 7272

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/swapUV/swapUV.cpp
Log:
[swapuv] Set PTS + return we dont have parameters

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/swapUV/swapUV.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/swapUV/swapUV.cpp	2011-06-11 07:29:24 UTC (rev 7271)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/swapUV/swapUV.cpp	2011-06-11 14:32:02 UTC (rev 7272)
@@ -73,6 +73,7 @@
 */
 bool         swapUv::getCoupledConf(CONFcouple **couples)
 {
+    *couples=NULL;
     return true;
 }
 /**
@@ -102,7 +103,7 @@
         ADM_warning("swapUV : Cannot get frame\n");
         return false;
     }
-   
+    image->Pts=ref.Pts;
     return true;
 }
 



From mean at mail.berlios.de  Sat Jun 11 16:32:04 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Sat, 11 Jun 2011 16:32:04 +0200
Subject: [Avidemux-svn-commit] r7273 -
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/vdpauFilters
Message-ID: <20110611143204.80BE1480CBB@sheep.berlios.de>

Author: mean
Date: 2011-06-11 16:32:04 +0200 (Sat, 11 Jun 2011)
New Revision: 7273

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/vdpauFilters/ADM_vidVdpauFilter.cpp
Log:
[vdpauResize] extra check to avoid dealing with null pointer

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/vdpauFilters/ADM_vidVdpauFilter.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/vdpauFilters/ADM_vidVdpauFilter.cpp	2011-06-11 14:32:02 UTC (rev 7272)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/vdpauFilters/ADM_vidVdpauFilter.cpp	2011-06-11 14:32:04 UTC (rev 7273)
@@ -272,6 +272,12 @@
     // regular image, in fact we get the next image here
     VdpVideoSurface tmpSurface=VDP_INVALID_HANDLE;
     ADMImage *next= vidCache->getImageAs(ADM_HW_VDPAU,nextFrame);
+    if(!next)
+    {
+        ADM_warning("vdpauResize : cannot get image\n");
+        return false;
+    }
+    image->Pts=next->Pts;
     if(next->refType==ADM_HW_VDPAU)
     {
         
@@ -329,6 +335,7 @@
     nextFrame++;
     currentIndex++;
     vidCache->unlockAll();
+    
     return true;
 }
 #else // USE_VDPAU



From mean at mail.berlios.de  Mon Jun 13 08:39:40 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Mon, 13 Jun 2011 08:39:40 +0200
Subject: [Avidemux-svn-commit] r7274 -
	branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor
Message-ID: <20110613063941.27554480DB2@sheep.berlios.de>

Author: mean
Date: 2011-06-13 08:39:40 +0200 (Mon, 13 Jun 2011)
New Revision: 7274

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edSearch.cpp
Log:
[editor] Only applies the shift if we deal with the very beginning of the video. That shift is needed when the very first frame of the video does not start at 0. A case this commit fixes is when the 1st frame does not start at zero, and we cut the beginning of the file. The actual first frame was not the real first one, but was shifted nonetheless

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edSearch.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edSearch.cpp	2011-06-11 14:32:04 UTC (rev 7273)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edSearch.cpp	2011-06-13 06:39:40 UTC (rev 7274)
@@ -87,14 +87,19 @@
         return false;
     }   
     // Special case : The very first frame FIXME
-    if(*frameTime<=1)
+    // Only applies if the first segment as a 0 ref time, i.e. beginning of video..
+    if(*frameTime<=1 && seg==0)
       {
           _VIDEOS *vid=_segments.getRefVideo(0);
-          uint64_t pts=vid->firstFramePts;
-          //
-          *frameTime+=pts;
-          ADM_warning("This video does not start at 0 but at %"LLU" ms, compensating\n",pts/1000);
-          _segments.convertLinearTimeToSeg(  *frameTime, &seg, &segTime);
+          _SEGMENT *s=_segments.getSegment(seg);
+          if(!s->_refStartTimeUs)
+          {
+              uint64_t pts=vid->firstFramePts;
+              //
+              *frameTime+=pts;
+              ADM_warning("This video does not start at 0 but at %"LLU" ms, compensating\n",pts/1000);
+              _segments.convertLinearTimeToSeg(  *frameTime, &seg, &segTime);
+           }
       }
     // 
 again:



From mean at mail.berlios.de  Mon Jun 13 08:39:42 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Mon, 13 Jun 2011 08:39:42 +0200
Subject: [Avidemux-svn-commit] r7275 -
	branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/js
Message-ID: <20110613063942.70904480DB2@sheep.berlios.de>

Author: mean
Date: 2011-06-13 08:39:42 +0200 (Mon, 13 Jun 2011)
New Revision: 7275

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/js/ADM_jsEditor.cpp
Log:
[js/py] Dump pts/dts in mm:ss:ms form in addition to full ms

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/js/ADM_jsEditor.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/js/ADM_jsEditor.cpp	2011-06-13 06:39:40 UTC (rev 7274)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/js/ADM_jsEditor.cpp	2011-06-13 06:39:42 UTC (rev 7275)
@@ -18,6 +18,7 @@
 #include <vector>
 #include "ADM_scriptEditor.h"
 #include "ADM_editor/ADM_edit.hxx"
+#include "ADM_vidMisc.h"
 extern ADM_Composer *video_body;
 void mixDump(uint8_t *ptr, uint32_t len);;
 /**
@@ -34,8 +35,8 @@
         if(flags & AVI_BOTTOM_FIELD) field='B';
         if(flags & AVI_TOP_FIELD) field='T';
         if(pts!=ADM_NO_PTS && dts!=ADM_NO_PTS) delta=(int64_t)pts-(int64_t)dts;
-        jsLog("Frame %"LU" PIC:%c : Flags 0x%"LX" pts=%"LLD" dts=%"LLD" delta=%"LLD" ms\n",
-                framenumber,field,flags,pts,dts,delta/1000LL);
+        jsLog("Frame %"LU" PIC:%c : Flags 0x%"LX" pts=%"LLD" pts=%s dts=%"LLD" delta=%"LLD" ms\n",
+                framenumber,field,flags,pts,ADM_us2plain(pts),dts,delta/1000LL);
     }else
     {
         jsLog("Cannot get info for frame %"LU,framenumber);



From mean at mail.berlios.de  Mon Jun 13 08:39:43 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Mon, 13 Jun 2011 08:39:43 +0200
Subject: [Avidemux-svn-commit] r7276 - in
	branches/avidemux_2.6_branch_mean/avidemux/common: . ADM_editor
Message-ID: <20110613063943.BDC53480DB2@sheep.berlios.de>

Author: mean
Date: 2011-06-13 08:39:43 +0200 (Mon, 13 Jun 2011)
New Revision: 7276

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edVideoCopy.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.hxx
   branches/avidemux_2.6_branch_mean/avidemux/common/gui_savenew.cpp
Log:
[editor] When saving in copy mode, check the cut points are on intra frame, warn otherwise. When saving check we dont have frames from the past wrt cut points, discard them if so

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edVideoCopy.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edVideoCopy.cpp	2011-06-13 06:39:42 UTC (rev 7275)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edVideoCopy.cpp	2011-06-13 06:39:43 UTC (rev 7276)
@@ -19,7 +19,7 @@
 #include <math.h>
 #include "ADM_default.h"
 #include "ADM_editor/ADM_edit.hxx"
-
+#include "ADM_vidMisc.h"
 #if defined(ADM_DEBUG) && 0
 #define aprintf printf
 #else
@@ -27,6 +27,52 @@
 #endif
 
 /**
+    \fn checkCutsAreOnIntra
+    \brief In copy mode, if the cuts are not on intra we will run into trouble :
+            * We include skipped ref frames: we will have DTS going back error
+            * We skip them, we have borked video at cut points due to missing ref framesz
+    \return true if everything ok
+*/
+bool ADM_Composer::checkCutsAreOnIntra(void)
+{
+    bool fail=false;
+    int nbSeg=_segments.getNbSegments();
+
+    ADMCompressedImage img;
+    uint8_t buffer[1920*1080*3];
+    img.data=buffer;
+    ADM_info("Checking cuts start on keyframe..\n");
+    for(int i=0;i<nbSeg;i++)
+    {
+        _SEGMENT *seg=_segments.getSegment(i);
+        _VIDEOS *vid=_segments.getRefVideo(seg->_reference);
+        vidHeader *demuxer=vid->_aviheader;
+
+        if(false==switchToSegment(i,true))
+        {
+            fail=true;
+            break;
+        }
+        if(false==demuxer->getFrame (vid->lastSentFrame,&img))
+        {
+            fail=true;
+            break;
+        }
+        if(img.flags & AVI_KEY_FRAME)
+        {
+            ADM_info("Segment %d starts on a keyframe\n",i);
+        }else   
+        {
+            ADM_warning("Segment %d does not start on a keyframe (%s)\n",i,ADM_us2plain(img.demuxerPts));
+            fail=true;
+             break;
+        }
+    }   
+
+    return fail;
+}
+
+/**
         \fn getCompressedPicture
         \brief bypass decoder and directly get the source image
 
@@ -60,6 +106,7 @@
         ADM_info("Failed to get next frame for ref %"LU"\n",seg->_reference);
         goto nextSeg;
     }
+
     vid->lastSentFrame++;
     //
     if(img->flags & AVI_B_FRAME)
@@ -78,6 +125,19 @@
             default: break;
         }
     }
+    // after a segment switch, we may have some frames from "the past"
+    // if the cut point is not a keyframe, drop them
+#if 1
+    if(_currentSegment && img->demuxerDts!=ADM_NO_PTS)
+    {
+        if(img->demuxerDts<seg->_refStartDts)
+        {
+            ADM_info("Frame %d is in the past for this segment (%s)",vid->lastSentFrame,ADM_us2plain(img->demuxerPts));
+            ADM_info("vs %s\n",ADM_us2plain(seg->_refStartDts));
+            goto againGet;
+        }
+    }
+#endif
     // Need to switch seg ?
     tail=seg->_refStartTimeUs+seg->_durationUs;
     // Guess DTS

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.hxx
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.hxx	2011-06-13 06:39:42 UTC (rev 7275)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.hxx	2011-06-13 06:39:43 UTC (rev 7276)
@@ -164,6 +164,7 @@
                     bool        getCompressedPicture(uint64_t delay,ADMCompressedImage *img);     //COPYMODE                
                     // Use only for debug purpose !!!
                     bool        getDirectImageForDebug(uint32_t frameNum,ADMCompressedImage *img);             
+                    bool        checkCutsAreOnIntra(void);
 public:
                     uint8_t	    updateVideoInfo(aviInfo *info);
                     uint32_t 	getSpecificMpeg4Info( void );

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/gui_savenew.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/gui_savenew.cpp	2011-06-13 06:39:42 UTC (rev 7275)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/gui_savenew.cpp	2011-06-13 06:39:43 UTC (rev 7276)
@@ -241,6 +241,19 @@
     uint64_t startAudioTime=markerA; // Actual start time (for both audio & video actually)
     ADM_info("Audio starting time %s\n",ADM_us2plain(startAudioTime));
     ADM_info("[A_Save] Saving..\n");
+    ADM_audioStream *astreams[1]={NULL};
+    if(!videoEncoderIndex) 
+    {
+        if(false==video_body-> checkCutsAreOnIntra())
+        {
+            if(!GUI_Question("The video is in copy mode but the cut points are not on keyframes.\n"
+                            "The video will be saved but there will corruption at cut point(s).\n"
+                             "Do you want to continue anyway ?"))
+            {
+                return false;
+            }
+        }
+    }
 
     if(!(muxer=ADM_MuxerSpawnFromIndex(muxerIndex)))
     {
@@ -265,6 +278,8 @@
     {
         aviInfo info;
         video_body->getVideoInfo(&info);
+       
+
         uint8_t *extra;
         uint32_t extraLen;
         video_body->getExtraHeaderData(&extraLen,&extra);
@@ -341,7 +356,7 @@
         }
     }
     //
-    ADM_audioStream *astreams[1]={NULL};
+
     if (!audioProcessMode())
     {
         if(audio)
@@ -370,7 +385,9 @@
         ret=muxer->save();
         muxer->close();
     }
-    delete video;
+abort123:
+    if(video)
+        delete video;
     video=NULL;
     for(int i=0;i<nbAStream;i++)
     {



From mean at mail.berlios.de  Mon Jun 13 15:54:53 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Mon, 13 Jun 2011 15:54:53 +0200
Subject: [Avidemux-svn-commit] r7277 -
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/x264
Message-ID: <20110613135453.BC809480DB2@sheep.berlios.de>

Author: mean
Date: 2011-06-13 15:54:53 +0200 (Mon, 13 Jun 2011)
New Revision: 7277

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/x264/ADM_x264Setup.cpp
Log:
[x264] cosmetic

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/x264/ADM_x264Setup.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/x264/ADM_x264Setup.cpp	2011-06-13 06:39:43 UTC (rev 7276)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/x264/ADM_x264Setup.cpp	2011-06-13 13:54:53 UTC (rev 7277)
@@ -77,9 +77,14 @@
     if(!x264Settings.MaxBFrame)  encoderDelay=0;
     else    
     {
-        if(2>=x264Settings.MaxRefFrames) encoderDelay=f*2*2;
+        if(2>=x264Settings.MaxRefFrames) 
+        {
+            encoderDelay=f*2*2;
+        }
         else
+        {
                 encoderDelay=2*f*(x264Settings.MaxRefFrames-1);
+        }
     }
 #define MKPARAM(x,y) {param.x = x264Settings.y;aprintf("[x264] "#x" = %d\n",param.x);}
 #define MKPARAMF(x,y) {param.x = (float)x264Settings.y / 100; aprintf("[x264] "#x" = %.2f\n",param.x);}



From mean at mail.berlios.de  Mon Jun 13 15:54:54 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Mon, 13 Jun 2011 15:54:54 +0200
Subject: [Avidemux-svn-commit] r7278 -
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioEncoders/lavcodec
Message-ID: <20110613135454.C65BB480DB2@sheep.berlios.de>

Author: mean
Date: 2011-06-13 15:54:54 +0200 (Mon, 13 Jun 2011)
New Revision: 7278

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioEncoders/lavcodec/audioencoder_lavcodec.cpp
Log:
[audioEncoder/lav] When lavcodec pops out a null sized packet, retry. it just means it needs more samples

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioEncoders/lavcodec/audioencoder_lavcodec.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioEncoders/lavcodec/audioencoder_lavcodec.cpp	2011-06-13 13:54:53 UTC (rev 7277)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioEncoders/lavcodec/audioencoder_lavcodec.cpp	2011-06-13 13:54:54 UTC (rev 7278)
@@ -193,6 +193,8 @@
 bool	AUDMEncoder_Lavcodec::encode(uint8_t *dest, uint32_t *len, uint32_t *samples)
 {
   uint32_t nbout;
+  int retries=16;
+again:
   int channels=wavheader.channels;
   *samples = _chunk/channels; //FIXME
   *len = 0;
@@ -250,6 +252,12 @@
 
   tmphead+=_chunk;
 cnt:
+  if(!nbout && retries)
+  {
+    retries--;
+    ADM_info("Audio encoder (lav): no packet, retrying\n");
+    goto again;
+  }
   if (nbout < 0)
   {
     ADM_error("[Lavcodec] Error !!! : %"LD"\n", nbout);



From mean at mail.berlios.de  Mon Jun 13 15:54:55 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Mon, 13 Jun 2011 15:54:55 +0200
Subject: [Avidemux-svn-commit] r7279 -
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2
Message-ID: <20110613135456.01EE6480DB2@sheep.berlios.de>

Author: mean
Date: 2011-06-13 15:54:55 +0200 (Mon, 13 Jun 2011)
New Revision: 7279

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2Audio.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2Video.cpp
Log:
[muxermp4v2] cosmetic

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2Audio.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2Audio.cpp	2011-06-13 13:54:54 UTC (rev 7278)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2Audio.cpp	2011-06-13 13:54:55 UTC (rev 7279)
@@ -23,6 +23,7 @@
 #include "muxerMp4v2.h"
 #include "ADM_codecType.h"
 #include "ADM_imageFlags.h"
+#include "ADM_vidMisc.h"
 #if 1
 #define aprintf(...) {}
 #define bprintf(...) {} // ADM_info
@@ -98,7 +99,7 @@
             ADM_error("Error adding audio track %i of type 0x%x\n",index,header->encoding);
             return false;
         }
-        aprintf("Add Track %d fq %d (AC3)\n",audioTrackIds[i],header->frequency);
+        aprintf("Add Track %d fq %d (AC3)\n",audioTrackIds[index],header->frequency);
         return true;
 }
 /**
@@ -204,6 +205,7 @@
             blk->dts+=audioDelay;
         blk->present=true;
         pkt->nextWrite=!pkt->nextWrite;
+        aprintf("Read audio block, size=%d bytes, dts=%s\n",blk->sizeInBytes,ADM_us2plain(blk->dts));
         return true;
 }
 /**
@@ -268,6 +270,8 @@
                                 // We have a hole, increase duration of current packet
                                 double holeDurationUs=currentBlock->dts-currentDts;
                                 ADM_warning("Hole detected in audio of %d ms, track %d\n",(int)(holeDurationUs/1000),audioIndex);
+                                ADM_warning("we got a timing of %s",ADM_us2plain(currentBlock->dts));
+                                ADM_warning("and expected %s\n",ADM_us2plain(currentDts));
                                 holeDurationUs*=fq;
                                 holeDurationUs/=1000*1000;
                                 ADM_warning("Increasing hole duration by %d samples\n",(int)holeDurationUs);

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2Video.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2Video.cpp	2011-06-13 13:54:54 UTC (rev 7278)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMp4v2/muxerMp4v2Video.cpp	2011-06-13 13:54:55 UTC (rev 7279)
@@ -171,7 +171,7 @@
                 return false;
             }
             
-            // if we dont have extraData, it is annexB 100 % sire
+            // if we dont have extraData, it is annexB 100 % sure
             needToConvertFromAnnexB=true;
             if(extraLen)
                 if(extra[0]==1) needToConvertFromAnnexB=false;



From mean at mail.berlios.de  Wed Jun 15 08:23:22 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Wed, 15 Jun 2011 08:23:22 +0200
Subject: [Avidemux-svn-commit] r7280 -
	branches/avidemux_2.6_branch_mean/avidemux/common/ADM_commonUI
Message-ID: <20110615062323.396B9481412@sheep.berlios.de>

Author: mean
Date: 2011-06-15 08:23:22 +0200 (Wed, 15 Jun 2011)
New Revision: 7280

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_commonUI/DIA_builtin.cpp
Log:
[ui] Add vdpau to the builtin dialog

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_commonUI/DIA_builtin.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_commonUI/DIA_builtin.cpp	2011-06-13 13:54:55 UTC (rev 7279)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_commonUI/DIA_builtin.cpp	2011-06-15 06:23:22 UTC (rev 7280)
@@ -44,6 +44,10 @@
   uint32_t altivec=0,freetype=0,win32=0;
   uint32_t sdl=0,oss=0,xvideo=0,x86=0,x86_64=0;
   uint32_t adm_powerpc=0,adm_gettext=0,adm_fontconfig=0;
+  uint32_t adm_vdpau=0;
+#ifdef USE_VDPAU
+    adm_vdpau=1;
+#endif
 #ifdef USE_FONTCONFIG
   adm_fontconfig=1;
 #endif
@@ -85,6 +89,7 @@
 	diaElemNotch tGettext(adm_gettext, QT_TR_NOOP("Gettext"));
     diaElemNotch tSdl(sdl, QT_TR_NOOP("SDL"));
 	diaElemNotch tXvideo(xvideo, QT_TR_NOOP("XVideo"));
+    diaElemNotch tVdpau(adm_vdpau, QT_TR_NOOP("VDPAU"));
 
 	diaElemNotch tAltivec(altivec, QT_TR_NOOP("AltiVec"));
 	diaElemNotch tPowerPc(adm_powerpc, QT_TR_NOOP("PowerPC"));
@@ -92,11 +97,11 @@
 	diaElemNotch tX86_64(x86_64, QT_TR_NOOP("x86-64"));
 
 
-	diaElem *libsElems[] = { &tFontConfig, &tFreetype, &tGettext, &tSdl, &tXvideo};
+	diaElem *libsElems[] = { &tFontConfig, &tFreetype, &tGettext, &tSdl, &tXvideo,&tVdpau};
 	diaElem *CPUElems[] = {&tAltivec, &tPowerPc, &tX86, &tX86_64};
 
 	
-	diaElemTabs tabLibs(QT_TR_NOOP("Libraries"), 5, libsElems);
+	diaElemTabs tabLibs(QT_TR_NOOP("Libraries"), 6, libsElems);
 	diaElemTabs tabCPU(QT_TR_NOOP("CPU"), 4, CPUElems);
 
 	diaElemTabs *tabs[] = {&tabLibs, &tabCPU};



From mean at mail.berlios.de  Wed Jun 15 08:23:24 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Wed, 15 Jun 2011 08:23:24 +0200
Subject: [Avidemux-svn-commit] r7281 -
	branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_gui
Message-ID: <20110615062324.6E4EE481412@sheep.berlios.de>

Author: mean
Date: 2011-06-15 08:23:24 +0200 (Wed, 15 Jun 2011)
New Revision: 7281

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_gui/Q_gui2.cpp
Log:
[Q_gui] convert to unix crlf

Modified: branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_gui/Q_gui2.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_gui/Q_gui2.cpp	2011-06-15 06:23:22 UTC (rev 7280)
+++ branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_gui/Q_gui2.cpp	2011-06-15 06:23:24 UTC (rev 7281)
@@ -1,1205 +1,1205 @@
-/***************************************************************************
-    copyright            : (C) 2001 by mean
-    email                : fixounet at free.fr
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#include "config.h"
-#include "ADM_inttype.h"
-#include <QtCore/QFileInfo>
-#include <QtCore/QUrl>
-#include <QtGui/QKeyEvent>
-#include <QtGui/QGraphicsView>
-
-#define MENU_DECLARE
-#include "Q_gui2.h"
-#include "ADM_default.h"
-
-#include "DIA_fileSel.h"
-#include "ADM_vidMisc.h"
-#include "prefs.h"
-#include "avi_vars.h"
-
-#include "ADM_render/GUI_renderInternal.h"
-#include "ADM_coreVideoEncoderInternal.h"
-#include "ADM_muxerProto.h"
-#include "T_vumeter.h"
-#include "DIA_coreToolkit.h"
-
-extern int global_argc;
-extern char **global_argv;
-
-extern uint8_t UI_getPhysicalScreenSize(void* window, uint32_t *w,uint32_t *h);
-extern int automation(void );
-extern void HandleAction(Action a);
-extern int encoderGetEncoderCount (void);
-extern const char *encoderGetIndexedName (uint32_t i);
-uint32_t audioEncoderGetNumberOfEncoders(void);
-const char  *audioEncoderGetDisplayName(uint32_t i);
-extern void checkCrashFile(void);
-extern void UI_QT4VideoWidget(QFrame *frame);
-extern void loadTranslator(void);
-extern void initTranslator(void);
-extern void destroyTranslator(void);
-extern ADM_RENDER_TYPE UI_getPreferredRender(void);
-extern int A_openAvi(const char *name);
-extern int A_appendAvi(const char *name);
-extern void FileSel_ReadWrite(SELFILE_CB *cb, int rw, const char *name, const char *actual_workbench_file);
-
-
-int SliderIsShifted=0;
-static void setupMenus(void);
-static int shiftKeyHeld=0;
-static ADM_QSlider *slider=NULL;
-static int _upd_in_progres=0;
-static int currentFps = 0;
-static int frameCount = 0;
-static int currentFrame = 0;
-bool     ADM_ve6_getEncoderInfo(int filter, const char **name, uint32_t *major,uint32_t *minor,uint32_t *patch);
-uint32_t ADM_ve6_getNbEncoders(void);
-void UI_refreshCustomMenu(void);
-QWidget *QuiMainWindows=NULL;
-QGraphicsView *drawWindow=NULL;
-uint8_t UI_updateRecentMenu( void );
-extern void saveCrashProject(void);
-extern uint8_t AVDM_setVolume(int volume);
-extern bool ADM_QPreviewCleanup(void);
-#define WIDGET(x)  (((MainWindow *)QuiMainWindows)->ui.x)
-
-#define CONNECT(object,zzz) connect( (ui.object),SIGNAL(triggered()),this,SLOT(buttonPressed()));
-#define CONNECT_TB(object,zzz) connect( (ui.object),SIGNAL(clicked(bool)),this,SLOT(toolButtonPressed(bool)));
-#define DECLARE_VAR(object,signal_name) {#object,signal_name},
-
-#include "translation_table.h"   
-
-/*
-    Declare the table converting widget name to our internal signal           
-*/
-typedef struct 
-{
-	const char *name;
-	Action     action; 
-}adm_qt4_translation;
-
-const adm_qt4_translation myTranslationTable[]=
-{
-#define PROCESS DECLARE_VAR
-	LIST_OF_BUTTONS
-#undef PROCESS
-};
-static Action searchTranslationTable(const char *name);
-#define SIZEOF_MY_TRANSLATION sizeof(myTranslationTable)/sizeof(adm_qt4_translation)
-
-int UI_readCurTime(uint16_t &hh, uint16_t &mm, uint16_t &ss, uint16_t &ms);
-void UI_updateFrameCount(uint32_t curFrame);
-void UI_updateTimeCount(uint32_t curFrame,uint32_t fps);
-extern void UI_purge(void);
-/*
-    Declare the class that will be our main window
-
-*/
-
-void MainWindow::comboChanged(int z)
-{
-	const char *source=qPrintable(sender()->objectName());
-
-	if(!strcmp(source,"comboBoxVideo"))  
-	{
-		bool b=FALSE;
-		if(ui.comboBoxVideo->currentIndex())
-		{
-			b=TRUE;
-		}
-		ui.pushButtonVideoConf->setEnabled(b);
-		ui.pushButtonVideoFilter->setEnabled(b);
-		HandleAction (ACT_VIDEO_CODEC_CHANGED) ;
-	}
-	else if(!strcmp(source,"comboBoxAudio"))  
-	{
-		bool b=FALSE;
-		if(ui.comboBoxAudio->currentIndex())
-		{
-			b=TRUE;
-		}
-		ui.pushButtonAudioConf->setEnabled(b);
-		ui.pushButtonAudioFilter->setEnabled(b);
-		HandleAction (ACT_AUDIO_CODEC_CHANGED) ;
-	}
-	else
-		printf("From +: %s\n",source);
-}
-
-void MainWindow::sliderValueChanged(int u) 
-{
-	if(!_upd_in_progres)
-		HandleAction(ACT_Scale);
-}
-
-void MainWindow::sliderMoved(int value)
-{
-	SliderIsShifted = shiftKeyHeld;
-}
-
-void MainWindow::sliderReleased(void)
-{
-	SliderIsShifted = 0;
-}
-
-void MainWindow::thumbSlider_valueEmitted(int value)
-{
-        if (value > 0)
-                nextIntraFrame();
-        else
-                previousIntraFrame();
-}
-
-void MainWindow::volumeChange( int u )
-{
-	if (_upd_in_progres || !ui.toolButtonAudioToggle->isChecked())
-		return;
-
-	_upd_in_progres++;
-
-	int vol = ui.horizontalSlider_2->value();
-
-	AVDM_setVolume(vol);
-	_upd_in_progres--;
-}
-
-void MainWindow::audioToggled(bool checked)
-{
-	if (checked)
-		AVDM_setVolume(ui.horizontalSlider_2->value());
-	else
-		AVDM_setVolume(0);
-}
-
-void MainWindow::previewModeChanged(QAction *action)
-{
-	HandleAction(ACT_PreviewChanged);
-}
-
-void MainWindow::timeChangeFinished(void)
-{
-	this->setFocus(Qt::OtherFocusReason);
-}
-
-void MainWindow::currentFrameChanged(void)
-{
-//	HandleAction(ACT_JumpToFrame);
-
-	this->setFocus(Qt::OtherFocusReason);
-}
-
-void MainWindow::currentTimeChanged(void)
-{
-	HandleAction(ACT_GotoTime);
-
-	this->setFocus(Qt::OtherFocusReason);
-}
-
-/**
-    \fn ctor
-*/
-MainWindow::MainWindow() : QMainWindow()
-{
-	ui.setupUi(this);
-
-#if defined(__APPLE__) && defined(USE_SDL)
-	ui.actionAbout_avidemux->setMenuRole(QAction::NoRole);
-	ui.actionPreferences->setMenuRole(QAction::NoRole);
-	ui.actionQuit->setMenuRole(QAction::NoRole);
-#endif
-
-	// Preview modes
-	QActionGroup *groupPreviewModes = new QActionGroup(this);
-
-	groupPreviewModes->addAction(ui.actionPreviewInput);
-	groupPreviewModes->addAction(ui.actionPreviewOutput);
-	connect(groupPreviewModes, SIGNAL(triggered(QAction*)), this, SLOT(previewModeChanged(QAction*)));
-
-	/*
-	Connect our button to buttonPressed
-	*/
-#define PROCESS CONNECT_TB
-	LIST_OF_BUTTONS
-#undef PROCESS
-
-	//ACT_VideoCodecChanged
-	connect( ui.comboBoxVideo,SIGNAL(activated(int)),this,SLOT(comboChanged(int)));
-	connect( ui.comboBoxAudio,SIGNAL(activated(int)),this,SLOT(comboChanged(int)));
-
-	// Slider
-	slider=ui.horizontalSlider;
-	slider->setMinimum(0);
-	slider->setMaximum(1000000000);
-	connect( slider,SIGNAL(valueChanged(int)),this,SLOT(sliderValueChanged(int)));
-	connect( slider,SIGNAL(sliderMoved(int)),this,SLOT(sliderMoved(int)));
-	connect( slider,SIGNAL(sliderReleased()),this,SLOT(sliderReleased()));
-
-   // Thumb slider
-    ui.sliderPlaceHolder->installEventFilter(this);
-    thumbSlider = new ThumbSlider(ui.sliderPlaceHolder);
-    connect(thumbSlider, SIGNAL(valueEmitted(int)), this, SLOT(thumbSlider_valueEmitted(int)));
-
-	// Volume slider
-	QSlider *volSlider=ui.horizontalSlider_2;
-	volSlider->setMinimum(0);
-	volSlider->setMaximum(100);
-	connect(volSlider,SIGNAL(valueChanged(int)),this,SLOT(volumeChange(int)));
-	connect(ui.toolButtonAudioToggle,SIGNAL(clicked(bool)),this,SLOT(audioToggled(bool)));
-
-	// default state
-	bool b=0;
-	ui.pushButtonVideoConf->setEnabled(b);
-	ui.pushButtonVideoFilter->setEnabled(b);
-	ui.pushButtonAudioConf->setEnabled(b);
-	ui.pushButtonAudioFilter->setEnabled(b);
-
-	/* Time Shift */
-	connect(ui.checkBox_TimeShift,SIGNAL(stateChanged(int)),this,SLOT(timeChanged(int)));
-	connect(ui.spinBox_TimeValue,SIGNAL(valueChanged(int)),this,SLOT(timeChanged(int)));
-	connect(ui.spinBox_TimeValue, SIGNAL(editingFinished()), this, SLOT(timeChangeFinished()));
-
-	QRegExp timeRegExp("^[0-9]{2}:[0-5][0-9]:[0-5][0-9]\\.[0-9]{3}$");
-	QRegExpValidator *timeValidator = new QRegExpValidator(timeRegExp, this);
-	ui.currentTime->setValidator(timeValidator);
-	ui.currentTime->setInputMask("99:99:99.999");
-
-	//connect(ui.currentTime, SIGNAL(editingFinished()), this, SLOT(currentTimeChanged()));
-
-    // Build file,... menu
-    buildMyMenu();
-
-	/* Build the custom menu */
-    jsMenu=new QMenu("javaScript");
+/***************************************************************************
+    copyright            : (C) 2001 by mean
+    email                : fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include "config.h"
+#include "ADM_inttype.h"
+#include <QtCore/QFileInfo>
+#include <QtCore/QUrl>
+#include <QtGui/QKeyEvent>
+#include <QtGui/QGraphicsView>
+
+#define MENU_DECLARE
+#include "Q_gui2.h"
+#include "ADM_default.h"
+
+#include "DIA_fileSel.h"
+#include "ADM_vidMisc.h"
+#include "prefs.h"
+#include "avi_vars.h"
+
+#include "ADM_render/GUI_renderInternal.h"
+#include "ADM_coreVideoEncoderInternal.h"
+#include "ADM_muxerProto.h"
+#include "T_vumeter.h"
+#include "DIA_coreToolkit.h"
+
+extern int global_argc;
+extern char **global_argv;
+
+extern uint8_t UI_getPhysicalScreenSize(void* window, uint32_t *w,uint32_t *h);
+extern int automation(void );
+extern void HandleAction(Action a);
+extern int encoderGetEncoderCount (void);
+extern const char *encoderGetIndexedName (uint32_t i);
+uint32_t audioEncoderGetNumberOfEncoders(void);
+const char  *audioEncoderGetDisplayName(uint32_t i);
+extern void checkCrashFile(void);
+extern void UI_QT4VideoWidget(QFrame *frame);
+extern void loadTranslator(void);
+extern void initTranslator(void);
+extern void destroyTranslator(void);
+extern ADM_RENDER_TYPE UI_getPreferredRender(void);
+extern int A_openAvi(const char *name);
+extern int A_appendAvi(const char *name);
+extern void FileSel_ReadWrite(SELFILE_CB *cb, int rw, const char *name, const char *actual_workbench_file);
+
+
+int SliderIsShifted=0;
+static void setupMenus(void);
+static int shiftKeyHeld=0;
+static ADM_QSlider *slider=NULL;
+static int _upd_in_progres=0;
+static int currentFps = 0;
+static int frameCount = 0;
+static int currentFrame = 0;
+bool     ADM_ve6_getEncoderInfo(int filter, const char **name, uint32_t *major,uint32_t *minor,uint32_t *patch);
+uint32_t ADM_ve6_getNbEncoders(void);
+void UI_refreshCustomMenu(void);
+QWidget *QuiMainWindows=NULL;
+QGraphicsView *drawWindow=NULL;
+uint8_t UI_updateRecentMenu( void );
+extern void saveCrashProject(void);
+extern uint8_t AVDM_setVolume(int volume);
+extern bool ADM_QPreviewCleanup(void);
+#define WIDGET(x)  (((MainWindow *)QuiMainWindows)->ui.x)
+
+#define CONNECT(object,zzz) connect( (ui.object),SIGNAL(triggered()),this,SLOT(buttonPressed()));
+#define CONNECT_TB(object,zzz) connect( (ui.object),SIGNAL(clicked(bool)),this,SLOT(toolButtonPressed(bool)));
+#define DECLARE_VAR(object,signal_name) {#object,signal_name},
+
+#include "translation_table.h"   
+
+/*
+    Declare the table converting widget name to our internal signal           
+*/
+typedef struct 
+{
+	const char *name;
+	Action     action; 
+}adm_qt4_translation;
+
+const adm_qt4_translation myTranslationTable[]=
+{
+#define PROCESS DECLARE_VAR
+	LIST_OF_BUTTONS
+#undef PROCESS
+};
+static Action searchTranslationTable(const char *name);
+#define SIZEOF_MY_TRANSLATION sizeof(myTranslationTable)/sizeof(adm_qt4_translation)
+
+int UI_readCurTime(uint16_t &hh, uint16_t &mm, uint16_t &ss, uint16_t &ms);
+void UI_updateFrameCount(uint32_t curFrame);
+void UI_updateTimeCount(uint32_t curFrame,uint32_t fps);
+extern void UI_purge(void);
+/*
+    Declare the class that will be our main window
+
+*/
+
+void MainWindow::comboChanged(int z)
+{
+	const char *source=qPrintable(sender()->objectName());
+
+	if(!strcmp(source,"comboBoxVideo"))  
+	{
+		bool b=FALSE;
+		if(ui.comboBoxVideo->currentIndex())
+		{
+			b=TRUE;
+		}
+		ui.pushButtonVideoConf->setEnabled(b);
+		ui.pushButtonVideoFilter->setEnabled(b);
+		HandleAction (ACT_VIDEO_CODEC_CHANGED) ;
+	}
+	else if(!strcmp(source,"comboBoxAudio"))  
+	{
+		bool b=FALSE;
+		if(ui.comboBoxAudio->currentIndex())
+		{
+			b=TRUE;
+		}
+		ui.pushButtonAudioConf->setEnabled(b);
+		ui.pushButtonAudioFilter->setEnabled(b);
+		HandleAction (ACT_AUDIO_CODEC_CHANGED) ;
+	}
+	else
+		printf("From +: %s\n",source);
+}
+
+void MainWindow::sliderValueChanged(int u) 
+{
+	if(!_upd_in_progres)
+		HandleAction(ACT_Scale);
+}
+
+void MainWindow::sliderMoved(int value)
+{
+	SliderIsShifted = shiftKeyHeld;
+}
+
+void MainWindow::sliderReleased(void)
+{
+	SliderIsShifted = 0;
+}
+
+void MainWindow::thumbSlider_valueEmitted(int value)
+{
+        if (value > 0)
+                nextIntraFrame();
+        else
+                previousIntraFrame();
+}
+
+void MainWindow::volumeChange( int u )
+{
+	if (_upd_in_progres || !ui.toolButtonAudioToggle->isChecked())
+		return;
+
+	_upd_in_progres++;
+
+	int vol = ui.horizontalSlider_2->value();
+
+	AVDM_setVolume(vol);
+	_upd_in_progres--;
+}
+
+void MainWindow::audioToggled(bool checked)
+{
+	if (checked)
+		AVDM_setVolume(ui.horizontalSlider_2->value());
+	else
+		AVDM_setVolume(0);
+}
+
+void MainWindow::previewModeChanged(QAction *action)
+{
+	HandleAction(ACT_PreviewChanged);
+}
+
+void MainWindow::timeChangeFinished(void)
+{
+	this->setFocus(Qt::OtherFocusReason);
+}
+
+void MainWindow::currentFrameChanged(void)
+{
+//	HandleAction(ACT_JumpToFrame);
+
+	this->setFocus(Qt::OtherFocusReason);
+}
+
+void MainWindow::currentTimeChanged(void)
+{
+	HandleAction(ACT_GotoTime);
+
+	this->setFocus(Qt::OtherFocusReason);
+}
+
+/**
+    \fn ctor
+*/
+MainWindow::MainWindow() : QMainWindow()
+{
+	ui.setupUi(this);
+
+#if defined(__APPLE__) && defined(USE_SDL)
+	ui.actionAbout_avidemux->setMenuRole(QAction::NoRole);
+	ui.actionPreferences->setMenuRole(QAction::NoRole);
+	ui.actionQuit->setMenuRole(QAction::NoRole);
+#endif
+
+	// Preview modes
+	QActionGroup *groupPreviewModes = new QActionGroup(this);
+
+	groupPreviewModes->addAction(ui.actionPreviewInput);
+	groupPreviewModes->addAction(ui.actionPreviewOutput);
+	connect(groupPreviewModes, SIGNAL(triggered(QAction*)), this, SLOT(previewModeChanged(QAction*)));
+
+	/*
+	Connect our button to buttonPressed
+	*/
+#define PROCESS CONNECT_TB
+	LIST_OF_BUTTONS
+#undef PROCESS
+
+	//ACT_VideoCodecChanged
+	connect( ui.comboBoxVideo,SIGNAL(activated(int)),this,SLOT(comboChanged(int)));
+	connect( ui.comboBoxAudio,SIGNAL(activated(int)),this,SLOT(comboChanged(int)));
+
+	// Slider
+	slider=ui.horizontalSlider;
+	slider->setMinimum(0);
+	slider->setMaximum(1000000000);
+	connect( slider,SIGNAL(valueChanged(int)),this,SLOT(sliderValueChanged(int)));
+	connect( slider,SIGNAL(sliderMoved(int)),this,SLOT(sliderMoved(int)));
+	connect( slider,SIGNAL(sliderReleased()),this,SLOT(sliderReleased()));
+
+   // Thumb slider
+    ui.sliderPlaceHolder->installEventFilter(this);
+    thumbSlider = new ThumbSlider(ui.sliderPlaceHolder);
+    connect(thumbSlider, SIGNAL(valueEmitted(int)), this, SLOT(thumbSlider_valueEmitted(int)));
+
+	// Volume slider
+	QSlider *volSlider=ui.horizontalSlider_2;
+	volSlider->setMinimum(0);
+	volSlider->setMaximum(100);
+	connect(volSlider,SIGNAL(valueChanged(int)),this,SLOT(volumeChange(int)));
+	connect(ui.toolButtonAudioToggle,SIGNAL(clicked(bool)),this,SLOT(audioToggled(bool)));
+
+	// default state
+	bool b=0;
+	ui.pushButtonVideoConf->setEnabled(b);
+	ui.pushButtonVideoFilter->setEnabled(b);
+	ui.pushButtonAudioConf->setEnabled(b);
+	ui.pushButtonAudioFilter->setEnabled(b);
+
+	/* Time Shift */
+	connect(ui.checkBox_TimeShift,SIGNAL(stateChanged(int)),this,SLOT(timeChanged(int)));
+	connect(ui.spinBox_TimeValue,SIGNAL(valueChanged(int)),this,SLOT(timeChanged(int)));
+	connect(ui.spinBox_TimeValue, SIGNAL(editingFinished()), this, SLOT(timeChangeFinished()));
+
+	QRegExp timeRegExp("^[0-9]{2}:[0-5][0-9]:[0-5][0-9]\\.[0-9]{3}$");
+	QRegExpValidator *timeValidator = new QRegExpValidator(timeRegExp, this);
+	ui.currentTime->setValidator(timeValidator);
+	ui.currentTime->setInputMask("99:99:99.999");
+
+	//connect(ui.currentTime, SIGNAL(editingFinished()), this, SLOT(currentTimeChanged()));
+
+    // Build file,... menu
+    buildMyMenu();
+
+	/* Build the custom menu */
+    jsMenu=new QMenu("javaScript");
     pyMenu=new QMenu("tinyPython");
-    autoMenu=ui.menuAuto ;//new QMenu("autoPython");
-    ui.menuCustom->addMenu(jsMenu);
+    autoMenu=ui.menuAuto ;//new QMenu("autoPython");
+    ui.menuCustom->addMenu(jsMenu);
     ui.menuCustom->addMenu(pyMenu);
-    //ui.menuAuto->addMenu(autoMenu);
-	buildCustomMenu();
-
-    recentFiles=new QMenu("Recent Files");
-    recentProjects=new QMenu("Recent Projects");
-    ui.menuRecent->addMenu(recentFiles);
-    ui.menuRecent->addMenu(recentProjects);
-    connect( ui.menuRecent,SIGNAL(triggered(QAction*)),this,SLOT(searchRecentFiles(QAction*)));
-
-	this->installEventFilter(this);
-	slider->installEventFilter(this);
-    
-	//ui.currentTime->installEventFilter(this);
-
-	this->setFocus(Qt::OtherFocusReason);
-
-	setAcceptDrops(true);
-    setWindowIcon(QIcon(":/new/prefix1/pics/avidemux_icon_small.png"));
-
-    // Hook also the toolbar
-    connect(ui.toolBar,  SIGNAL(actionTriggered ( QAction *)),this,SLOT(searchToolBar(QAction *)));
-    connect(ui.toolBar_2,SIGNAL(actionTriggered ( QAction *)),this,SLOT(searchToolBar(QAction *)));
-
-	QWidget* dummy0 = new QWidget();
-	QWidget* dummy1 = new QWidget();
-	QWidget* dummy2 = new QWidget();
-	QWidget* dummy3 = new QWidget();
-	QWidget* dummy4 = new QWidget();
-
-	ui.codecWidget->setTitleBarWidget(dummy0);
-	ui.navigationWidget->setTitleBarWidget(dummy1);
-	ui.selectionWidget->setTitleBarWidget(dummy2);
-	ui.volumeWidget->setTitleBarWidget(dummy3);
-	ui.audioMetreWidget->setTitleBarWidget(dummy4);
-
-	this->resize(1, 1);
-}
-/**
-    \fn searchToolBar
-*/
-typedef struct 
-{
-    const char *name;
-    Action event;
-}toolBarTranslate;
-
-toolBarTranslate toolbar[]=
-{
-{"actionOpen",              ACT_OPEN_VIDEO},
-{"actionSave_video",        ACT_SAVE_VIDEO},
-{"actionProperties",        ACT_VIDEO_PROPERTIES},
-{"actionLoad_run_project",  ACT_RUN_PY_PROJECT},
-{"actionSave_project",      ACT_SAVE_PY_PROJECT},
-//{"actionPreviewInput",ACT_PreviewToggle},
-//{"actionPreviewOutput",ACT_PreviewToggle},
-
-{NULL,ACT_DUMMY}
-};
-void MainWindow::searchToolBar(QAction *action)
-{
-        toolBarTranslate *t=toolbar;
-        QString me(action->objectName());
-        const char *name=me.toUtf8().constData();
-        while(t->name)
-        {
-            if(!strcmp(name,t->name))
-            {
-                HandleAction(t->event);
-                return;
-            }
-            t++;
-        }
-        ADM_warning("Toolbar:Cannot handle %s\n",name);
-}
-/**
-    \fn buildFileMenu
-*/
-bool MainWindow::buildMenu(QMenu *root,MenuEntry *menu, int nb)
-{
-    QMenu *subMenu=NULL;
-    for(int i=0;i<nb;i++)
-    {
-        MenuEntry *m=menu+i;
-        switch(m->type)
-        {
-            case MENU_SEPARATOR:
-                root->addSeparator();
-                break;
-            case MENU_SUBMENU:
-                {
-                    subMenu=root->addMenu(m->text);
-                }
-                break;
-            case MENU_SUBACTION:
-            case MENU_ACTION:
-                {   
-                        QMenu *insert=root;
-                        if(m->type==MENU_SUBACTION) insert=subMenu;
-                        QAction *a=NULL;
-                        if(m->icon) 
-                        {
-                            QIcon icon(m->icon);
-                            a=insert->addAction(icon,m->text);
-                        }else
-                            a=insert->addAction(m->text);
-                        m->cookie=(void *)a;
-                        if(m->shortCut)
-                        {
-                            QKeySequence s(m->shortCut);
-                            a->setShortcut(s);
-                        }
-                        break;
-                }
-            default:
-                break;
-        }
-    }
-    return true;
-}
-/**
-    buildFileMenu
-*/
-bool MainWindow::buildMyMenu(void)
-{
-    connect( ui.menuFile,SIGNAL(triggered(QAction*)),this,SLOT(searchFileMenu(QAction*)));
-    buildMenu(ui.menuFile,myMenuFile, sizeof(myMenuFile)/sizeof(MenuEntry));
-
-    connect( ui.menuEdit,SIGNAL(triggered(QAction*)),this,SLOT(searchEditMenu(QAction*)));
-    buildMenu(ui.menuEdit,myMenuEdit, sizeof(myMenuEdit)/sizeof(MenuEntry));
-
-    connect( ui.menuVideo,SIGNAL(triggered(QAction*)),this,SLOT(searchVideoMenu(QAction*)));
-    buildMenu(ui.menuVideo,myMenuVideo, sizeof(myMenuVideo)/sizeof(MenuEntry));
-
-    connect( ui.menuAudio,SIGNAL(triggered(QAction*)),this,SLOT(searchAudioMenu(QAction*)));
-    buildMenu(ui.menuAudio,myMenuAudio, sizeof(myMenuAudio)/sizeof(MenuEntry));
-
-    connect( ui.menuHelp,SIGNAL(triggered(QAction*)),this,SLOT(searchHelpMenu(QAction*)));
-    buildMenu(ui.menuHelp,myMenuHelp, sizeof(myMenuHelp)/sizeof(MenuEntry));
-
-    connect( ui.menuTools,SIGNAL(triggered(QAction*)),this,SLOT(searchToolMenu(QAction*)));
-    buildMenu(ui.menuTools,myMenuTool, sizeof(myMenuTool)/sizeof(MenuEntry));
-
-    connect( ui.menuGo,SIGNAL(triggered(QAction*)),this,SLOT(searchGoMenu(QAction*)));
-    buildMenu(ui.menuGo,myMenuGo, sizeof(myMenuGo)/sizeof(MenuEntry));
-
-    connect( ui.menuView,SIGNAL(triggered(QAction*)),this,SLOT(searchViewMenu(QAction*)));
-    buildMenu(ui.menuView,myMenuView, sizeof(myMenuView)/sizeof(MenuEntry));
-
-    return true;
-}
-
-/**
-    \fn timeChanged
-    \brief Called whenever timeshift is on/off'ed or value changes
-*/
-void MainWindow::timeChanged(int)
-{
-	HandleAction (ACT_TimeShift) ;
-}
-/**
-    \fn searchMenu
-*/
-void MainWindow::searchMenu(QAction * action,MenuEntry *menu, int nb)
-{
-    for(int i=0;i<nb;i++)
-    {
-        MenuEntry *m=menu+i;
-        if(m->cookie==(void*)action)
-        {
-            HandleAction (m->event);
-        }
-    }
-}
-
-/**
-    \fn searchFileMenu
-*/
-#define MKMENU(name) void MainWindow::search##name##Menu(QAction * action) \
-    {searchMenu(action,myMenu##name,sizeof(myMenu##name)/sizeof(MenuEntry));}
-
-MKMENU(File)
-MKMENU(Edit)
-//MKMENU(Recent)
-MKMENU(View)
-MKMENU(Tool)
-MKMENU(Go)
-//MKMENU(Custom)
-MKMENU(Audio)
-MKMENU(Video)
-MKMENU(Help)
-
-
-
-/*
-      We receive a button press event
-*/
-void MainWindow::buttonPressed(void)
-{
-	// Receveid a key press Event, look into table..
-    QObject *obj=sender();
-    if(!obj) return;
-    QString me(obj->objectName());
-    
-	Action action=searchTranslationTable(qPrintable(me));
-    
-
-	if(action!=ACT_DUMMY)
-		HandleAction (action);
-
-}
-void MainWindow::toolButtonPressed(bool i)
-{
-	buttonPressed();
-}
-
-bool MainWindow::eventFilter(QObject* watched, QEvent* event)
-{
-	QKeyEvent *keyEvent;
-
-	switch (event->type())
-	{
-		case QEvent::KeyPress:
-			keyEvent = (QKeyEvent*)event;
-
-			if (watched == slider)
-			{
-				switch (keyEvent->key())
-				{
-					case Qt::Key_Left:
-						if (keyEvent->modifiers() == Qt::ShiftModifier)
-							HandleAction(ACT_Back25Frames);
-						else if (keyEvent->modifiers() == Qt::ControlModifier)
-							HandleAction(ACT_Back50Frames);
-						else
-							HandleAction(ACT_PreviousFrame);
-
-						return true;
-					case Qt::Key_Right:
-						if (keyEvent->modifiers() == Qt::ShiftModifier)
-							HandleAction(ACT_Forward25Frames);
-						else if (keyEvent->modifiers() == Qt::ControlModifier)
-							HandleAction(ACT_Forward50Frames);
-						else
-							HandleAction(ACT_NextFrame);
-
-						return true;
-					case Qt::Key_Up:
-						HandleAction(ACT_NextKFrame);
-						return true;
-					case Qt::Key_Down:
-						HandleAction(ACT_PreviousKFrame);
-						return true;
-					case Qt::Key_Shift:
-						shiftKeyHeld = 1;
-						break;
-				}
-			}
-			else if (keyEvent->key() == Qt::Key_Space)
-			{
-				HandleAction(ACT_PlayAvi);
-				return true;
-			}
-
-			break;
-        case QEvent::Resize:
-            if (watched == ui.sliderPlaceHolder)
-            {
-                    thumbSlider->resize(ui.sliderPlaceHolder->width(), 16);
-                    thumbSlider->move(0, (ui.sliderPlaceHolder->height() - thumbSlider->height()) / 2);
-            }
-            break;
-
-		case QEvent::KeyRelease:
-			keyEvent = (QKeyEvent*)event;
-
-			if (keyEvent->key() == Qt::Key_Shift)
-				shiftKeyHeld = 0;
-
-			break;
-		case QEvent::FocusOut:
-            break;
-        default:
-            break;
-	}
-
-	return QObject::eventFilter(watched, event);
-}
-/**
-    \fn buildRecentMenu
-*/
-bool MainWindow::buildRecentMenu(void)
-{
-    const char **names;
-	names=prefs->get_lastfiles();
-    // Purge entries...
-    recentFiles->clear();
-    for(int i=0;i<4;i++)
-    {
-        if(names[i])
-        {
-            recentFileAction[i]=recentFiles->addAction(QString('0'+i)+QString(":")+QString::fromUtf8(names[i]));
-        }else
-            recentFileAction[i]=NULL;
-    }
-	return true;
-}
-/**
-    \fn searchRecentFiles
-*/
-void MainWindow::searchRecentFiles(QAction * action)
-{
-    for(int i=0;i<4;i++)
-    {
-            QAction *a= recentFileAction[i];
-            if(!a) continue;
-
-            if(a==action) 
-            {
-                HandleAction((Action)(ACT_RECENT0+i));
-                return;
-            }
-    }
-}
-void MainWindow::mousePressEvent(QMouseEvent* event)
-{
-	this->setFocus(Qt::OtherFocusReason);
-}
-
-void MainWindow::dragEnterEvent(QDragEnterEvent *event)
-{
-	if (event->mimeData()->hasFormat("text/uri-list"))
-		event->acceptProposedAction();
-}
-
-void MainWindow::dropEvent(QDropEvent *event)
-{
-	QList<QUrl> urlList;
-	QString fileName;
-	QFileInfo info;
-
-	if (event->mimeData()->hasUrls())
-	{
-		urlList = event->mimeData()->urls();
-
-		for (int fileIndex = 0; fileIndex < urlList.size(); fileIndex++)
-		{
-			fileName = urlList[fileIndex].toLocalFile();
-			info.setFile(fileName);
-#warning FIXME
-#if 0
-			if (info.isFile())
-			{
-				if (avifileinfo)
-					FileSel_ReadWrite(reinterpret_cast <void (*)(const char *)> (A_appendAvi), 0, fileName.toUtf8().data(), actual_workbench_file);
-				else
-					FileSel_ReadWrite(reinterpret_cast <void (*)(const char *)> (A_openAvi), 0, fileName.toUtf8().data(), actual_workbench_file);
-			}
-#endif
-		}
-	}
-
-	event->acceptProposedAction();
-}
-
-void MainWindow::previousIntraFrame(void)
-{
-	if (ui.spinBox_TimeValue->hasFocus())
-		ui.spinBox_TimeValue->stepDown();
-	else
-		HandleAction(ACT_PreviousKFrame);
-}
-
-void MainWindow::nextIntraFrame(void)
-{
-	if (ui.spinBox_TimeValue->hasFocus())
-		ui.spinBox_TimeValue->stepUp();
-	else
-		HandleAction(ACT_NextKFrame);
-}
-
-MainWindow::~MainWindow()
-{
-	clearCustomMenu();
-    delete thumbSlider;
-    thumbSlider=NULL;
-}
-
-void MainWindow::closeEvent(QCloseEvent *event)
-{
-static bool first=true;
-    ADM_warning("Close event\n");
-    if(first)
-    {
-        first=false;
-        HandleAction(ACT_EXIT);
-    }
-    event->accept();
-//         event->ignore();
-
-}
-
-
-static const UI_FUNCTIONS_T UI_Hooks=
-    {
-        ADM_RENDER_API_VERSION_NUMBER,
-        UI_getWindowInfo,
-        UI_updateDrawWindowSize,
-        UI_rgbDraw,
-        UI_getDrawWidget,
-        UI_getPreferredRender
-        
-    };
-QApplication *myApplication=NULL;
-/**
-    \fn  UI_Init
-    \brief First part of UI initialization
-
-*/
-int UI_Init(int nargc,char **nargv)
-{
-    ADM_info("Starting QT4 GUI...\n");
-	initTranslator();
-
-	global_argc=nargc;
-	global_argv=nargv;
-	ADM_renderLibInit(&UI_Hooks);
-    Q_INIT_RESOURCE(avidemux);
-	Q_INIT_RESOURCE(filter);
-
-	myApplication=new QApplication (global_argc, global_argv);
-	myApplication->connect(myApplication, SIGNAL(lastWindowClosed()), myApplication, SLOT(quit()));
-
-	loadTranslator();
-
-	MainWindow *mw = new MainWindow();
-	mw->show();
-
-	QuiMainWindows = (QWidget*)mw;
-
-	uint32_t w, h;
-
-	UI_getPhysicalScreenSize(QuiMainWindows, &w,&h);
-	printf("The screen seems to be %u x %u px\n",w,h);
-
-	UI_QT4VideoWidget(mw->ui.frame_video);  // Add the widget that will handle video display
-	UI_updateRecentMenu();
-
-    // Init vumeter
-    UI_InitVUMeter(mw->ui.frameVU);
-	return 0;
-}
-/**
-
-*/
-bool UI_End(void)
-{
-    ADM_QPreviewCleanup();
-    return true;
-}
-void UI_refreshCustomMenu(void)
-{
-	((MainWindow*)QuiMainWindows)->buildCustomMenu();
-}
-
-/**
-    \fn UI_getCurrentPreview(void)
-    \brief Read previewmode from comboxbox 
-*/
-int UI_getCurrentPreview(void)
-{
-	int index;
-
-	if (WIDGET(actionPreviewOutput)->isChecked())
-		index = 1;
-	else if (WIDGET(actionPreviewSide)->isChecked())
-		index = 2;
-	else if (WIDGET(actionPreviewTop)->isChecked())
-		index = 3;
-	else if (WIDGET(actionPreviewSeparate)->isChecked())
-		index = 4;
-	else
-		index = 0;
-
-	return index;
-}
-
-/**
-    \fn UI_setCurrentPreview(int ne)
-    \brief Update comboxbox with previewmode
-*/
-void UI_setCurrentPreview(int ne)
-{
-	switch (ne)
-	{
-		case 1:
-			WIDGET(actionPreviewOutput)->setChecked(true);
-			break;
-		case 2:
-			WIDGET(actionPreviewSide)->setChecked(true);
-			break;
-		case 3:
-			WIDGET(actionPreviewTop)->setChecked(true);
-			break;
-		case 4:
-			WIDGET(actionPreviewSeparate)->setChecked(true);
-			break;
-		default:
-			WIDGET(actionPreviewInput)->setChecked(true);
-	}
-}
-/**
-        \fn FatalFunctionQt
-*/
-static void FatalFunctionQt(const char *title, const char *info)
-{
-	GUI_Info_HIG(ADM_LOG_IMPORTANT, title, info);
-}
-
-/**
-    \fn UI_RunApp(void)
-    \brief Main entry point for the GUI application
-*/
-int UI_RunApp(void)
-{
-	
-	setupMenus();
-    ADM_setCrashHook(&saveCrashProject, &FatalFunctionQt);
-	checkCrashFile();
-
-	if (global_argc >= 2)
-		automation();
-
-	myApplication->exec();
-
-	destroyTranslator();
-    delete myApplication;
-    myApplication=NULL;
-    return 1;
-}
-/**
-    \fn searchTranslationTable(const char *name))
-    \brief return the action corresponding to a give button. The translation table is in translation_table.h
-*/
-Action searchTranslationTable(const char *name)
-{
-	for(int i=0;i< SIZEOF_MY_TRANSLATION;i++)
-	{
-		if(!strcmp(name, myTranslationTable[i].name))
-		{
-			return  myTranslationTable[i].action;
-		}
-	}
-	printf("WARNING: Signal not found in translation table %s\n",name);
-	return ACT_DUMMY;
-}
-/**
-    \fn     UI_updateRecentMenu( void )
-    \brief  Update the recent submenu with the latest files loaded
-*/
-uint8_t UI_updateRecentMenu( void )
-{
-    return  ((MainWindow *)QuiMainWindows)->buildRecentMenu();
-}
-/** 
-  \fn    setupMenus(void)
-  \brief Fill in video & audio co
-*/
-void setupMenus(void)
-{
-	uint32_t nbVid;
-    uint32_t maj,mn,pa;
-	const char *name;
-
-	nbVid=ADM_ve6_getNbEncoders();
-	printf("Found %d video encoder(s)\n",nbVid);
-	for(uint32_t i=1;i<nbVid;i++)
-	{
-		ADM_ve6_getEncoderInfo(i,&name,&maj,&mn,&pa);
-		WIDGET(comboBoxVideo)->addItem(name);
-	}
-
-	// And A codec
-
-	uint32_t nbAud;
-
-    nbAud=audioEncoderGetNumberOfEncoders();
-	printf("Found %d audio encoder(s)\n",nbAud);		       
-	for(uint32_t i=1;i<nbAud;i++)
-	{
-		name=audioEncoderGetDisplayName(i);
-		WIDGET(comboBoxAudio)->addItem(name);
-	}
-
-	/*   Fill in output format window */
-	uint32_t nbFormat=ADM_mx_getNbMuxers();
-
-	printf("Found %d format(s)\n",nbFormat);
-	for(uint32_t i=0;i<nbFormat;i++)
-	{
-        const char *name=ADM_mx_getDisplayName(i);
-		WIDGET(comboBoxFormat)->addItem(name);	
-	}
-
-}
-/*
-    Return % of scale (between 0 and 1)
-*/
-double 	UI_readScale( void )
-{
-	double v;
-	if(!slider) v=0;
-	v= (double)(slider->value());
-	v/=10000000;
-	return v;
-}
-void UI_setScale( double val )
-{
-	if(_upd_in_progres) return;
-	_upd_in_progres++;
-	slider->setValue( (int)(val * 10000000));
-	_upd_in_progres--;
-}
-
-int UI_readCurFrame(void)
-{
-	return 0;
-}
-
-int UI_readCurTime(uint16_t &hh, uint16_t &mm, uint16_t &ss, uint16_t &ms)
-{
-	int success = 0;
-
-	QString timeText = WIDGET(currentTime)->text();
-	int pos;
-
-	if (WIDGET(currentTime)->validator()->validate(timeText, pos) == QValidator::Acceptable)
-	{
-		uint32_t frame;
-
-		hh = (uint16_t)timeText.left(2).toUInt();
-		mm = (uint16_t)timeText.mid(3, 2).toUInt();
-		ss = (uint16_t)timeText.mid(6, 2).toUInt();
-		ms = (uint16_t)timeText.right(3).toUInt();
-
-		time2frame(&frame, currentFps, hh, mm, ss, ms);
-
-		if (frame <= frameCount)
-			success = 1;
-	}
-
-	return success;
-}
-
-
-
-//*******************************************
-
-/**
-    \fn UI_setTitle(char *name)
-    \brief Set the main window title, usually name if the file being edited
-*/
-void UI_setTitle(const char *name)
-{
-	char *title;
-	const char* defaultTitle = "Avidemux";
-
-	if (name && (*name) )
-	{
-		title = new char[strlen(defaultTitle) + strlen(name) + 3 + 1];
-
-		strcpy(title, name);
-		strcat(title, " - ");
-		strcat(title, defaultTitle);
-	}
-	else
-	{
-		title = new char[strlen(defaultTitle) + 1];
-
-		strcpy(title, defaultTitle);
-	}
-
-	QuiMainWindows->setWindowTitle(QString::fromUtf8(title));
-	delete [] title;
-}
-
-/**
-    \fn     UI_setFrameType( uint32_t frametype,uint32_t qp)
-    \brief  Display frametype (I/P/B) and associated quantizer
-*/
-
-void UI_setFrameType( uint32_t frametype,uint32_t qp)
-{
-	char string[100];
-	char	c='?';
-    const char *f="???";
-	switch(frametype&AVI_FRAME_TYPE_MASK)
-	{
-	case AVI_KEY_FRAME: c='I';break;
-	case AVI_B_FRAME: c='B';break;
-	case 0: c='P';break;
-	default:c='?';break;
-
-	}
-    switch(frametype&AVI_STRUCTURE_TYPE_MASK)
-	{
-	case AVI_TOP_FIELD+AVI_FIELD_STRUCTURE: f="TFF";break;
-    case AVI_BOTTOM_FIELD+AVI_FIELD_STRUCTURE: f="BFF";break;
-    case AVI_FRAME_STRUCTURE: f="FRM";break;
-	default:f="???";
-
-                    break;
-	}
-	sprintf(string,QT_TR_NOOP("%c-%s (%02d)"),c,f,qp);
-	WIDGET(label_8)->setText(string);	
-
-}
-
-/**
-    \fn     UI_updateFrameCount(uint32_t curFrame)
-    \brief  Display the current displayed frame #
-*/
-void UI_updateFrameCount(uint32_t curFrame)
-{
-	
-}
-
-/**
-    \fn      UI_setFrameCount(uint32_t curFrame,uint32_t total)
-    \brief  Display the current displayed frame # and total frame #
-*/
-void UI_setFrameCount(uint32_t curFrame,uint32_t total)
-{
-	
-}
-
-/**
-    \fn     UI_updateTimeCount(uint32_t curFrame,uint32_t fps)
-    \brief  Display the time corresponding to current frame according to fps (fps1000)
-*/
-void UI_updateTimeCount(uint32_t curFrame,uint32_t fps)
-{
-	char text[80];   
-	uint32_t mm,hh,ss,ms;
-
-	frame2time(curFrame,fps, &hh, &mm, &ss, &ms);
-	sprintf(text, "%02d:%02d:%02d.%03d", hh, mm, ss, ms);
-	WIDGET(currentTime)->setText(text);
-}
-
-
-
-/**
-    \fn UI_setCurrentTime
-    \brief Set current PTS of displayed video
-*/
-void UI_setCurrentTime(uint64_t curTime)
-{
-  char text[80];
- uint32_t mm,hh,ss,ms;
- uint32_t shorty=(uint32_t)(curTime/1000);
-
-    ms2time(shorty,&hh,&mm,&ss,&ms);
-  	sprintf(text, "%02d:%02d:%02d.%03d", hh, mm, ss, ms);
-	WIDGET(currentTime)->setText(text);
-
-}
-
-/**
-    \fn UI_setTotalTime
-    \brief SEt the total duration of video
-*/
-void UI_setTotalTime(uint64_t curTime)
-{
-  char text[80];
- uint32_t mm,hh,ss,ms;
- uint32_t shorty=(uint32_t)(curTime/1000);
-
-    ms2time(shorty,&hh,&mm,&ss,&ms);
-  	sprintf(text, "/%02d:%02d:%02d.%03d", hh, mm, ss, ms);
-    WIDGET(totalTime)->setText(text);
-    slider->setTotalDuration(curTime);
-}
-/**
-    \fn     UI_setMarkers(uint64_t Ptsa, uint32_t Ptsb )
-    \brief  Display frame # for marker A & B
-*/
-void UI_setMarkers(uint64_t a, uint64_t b)
-{
-	char text[80];
-    uint64_t absoluteA=a,absoluteB=b;
-    uint32_t hh,mm,ss,ms;
-    uint32_t timems;
-    a/=1000;
-    b/=1000;
-
-    timems=(uint32_t)(a);
-    ms2time(timems,&hh,&mm,&ss,&ms);
-	snprintf(text,79,"%02"LU":%02"LU":%02"LU".%02"LU,hh,mm,ss,ms);
-	WIDGET(pushButtonJumpToMarkerA)->setText(text);
-
-	timems=(uint32_t)(b);
-    ms2time(timems,&hh,&mm,&ss,&ms);
-	snprintf(text,79,"%02"LU":%02"LU":%02"LU".%02"LU,hh,mm,ss,ms);
-	WIDGET(pushButtonJumpToMarkerB)->setText(text);
-
-	slider->setMarkers(absoluteA, absoluteB);
-}
-
-/**
-    \fn     UI_getCurrentVCodec(void)
-    \brief  Returns the current selected video code in menu, i.e its number (0 being the first)
-*/
-int 	UI_getCurrentVCodec(void)
-{
-	int i=WIDGET(comboBoxVideo)->currentIndex();
-	if(i<0) i=0;
-	return i; 
-}
-/**
-    \fn     UI_setVideoCodec( int i)
-    \brief  Select the video codec which is # x in pulldown menu (starts at zero :copy)
-*/
-
-void UI_setVideoCodec( int i)
-{
-	int b=!!i;
-	WIDGET(comboBoxVideo)->setCurrentIndex(i);
-
-	WIDGET(pushButtonVideoConf)->setEnabled(b);
-	WIDGET(pushButtonVideoFilter)->setEnabled(b);
-}
-/**
-    \fn     UI_getCurrentACodec(void)
-    \brief  Returns the current selected audio code in menu, i.e its number (0 being the first)
-*/
-
-int 	UI_getCurrentACodec(void)
-{
-	int i=WIDGET(comboBoxAudio)->currentIndex();
-	if(i<0) i=0;
-	return i; 
-}
-/**
-    \fn     UI_setAudioCodec( int i)
-    \brief  Select the audio codec which is # x in pulldown menu (starts at zero :copy)
-*/
-
-void UI_setAudioCodec( int i)
-{ int b=!!i;
-WIDGET(comboBoxAudio)->setCurrentIndex(i);
-WIDGET(pushButtonAudioConf)->setEnabled(b);
-WIDGET(pushButtonAudioFilter)->setEnabled(b);
-}
-/**
-    \fn     UI_GetCurrentFormat(void)
-    \brief  Returns the current selected output format
-*/
-
-int 	UI_GetCurrentFormat( void )
-{
-	int i=WIDGET(comboBoxFormat)->currentIndex();
-	if(i<0) i=0;
-	return (int)i; 
-}
-/**
-    \fn     UI_SetCurrentFormat( ADM_OUT_FORMAT fmt )
-    \brief  Select  output format
-*/
-uint8_t 	UI_SetCurrentFormat( uint32_t fmt )
-{
-	WIDGET(comboBoxFormat)->setCurrentIndex((int)fmt);
-    return 1;
-}
-
-/**
-      \fn UI_getTimeShift
-      \brief get state (on/off) and value for time Shift
-*/
-uint8_t UI_getTimeShift(int *onoff,int *value)
-{
-	if(WIDGET(checkBox_TimeShift)->checkState()==Qt::Checked)
-		*onoff=1;
-	else
-		*onoff=0;
-	*value=WIDGET(spinBox_TimeValue)->value();
-	return 1;
-}
-/**
-      \fn UI_setTimeShift
-      \brief get state (on/off) and value for time Shift
-*/
-
-uint8_t UI_setTimeShift(int onoff,int value)
-{
-	if (onoff && value)
-		WIDGET(checkBox_TimeShift)->setCheckState(Qt::Checked);
-	else
-		WIDGET(checkBox_TimeShift)->setCheckState(Qt::Unchecked);
-	WIDGET(spinBox_TimeValue)->setValue(value);
-	return 1;
-}
-/**
-    \fn UI_setVUMeter
-*/
-bool UI_setVUMeter( uint32_t volume[6])
-{
-    UI_vuUpdate( volume);
-    return true;
-}
-/**
-    \fn setDecodeName
-*/
-bool UI_setDecoderName(const char *name)
-{
-    WIDGET(labelVideoDecoder)->setText(name);	
-    return true;
-}
-//********************************************
-//EOF
+    //ui.menuAuto->addMenu(autoMenu);
+	buildCustomMenu();
+
+    recentFiles=new QMenu("Recent Files");
+    recentProjects=new QMenu("Recent Projects");
+    ui.menuRecent->addMenu(recentFiles);
+    ui.menuRecent->addMenu(recentProjects);
+    connect( ui.menuRecent,SIGNAL(triggered(QAction*)),this,SLOT(searchRecentFiles(QAction*)));
+
+	this->installEventFilter(this);
+	slider->installEventFilter(this);
+    
+	//ui.currentTime->installEventFilter(this);
+
+	this->setFocus(Qt::OtherFocusReason);
+
+	setAcceptDrops(true);
+    setWindowIcon(QIcon(":/new/prefix1/pics/avidemux_icon_small.png"));
+
+    // Hook also the toolbar
+    connect(ui.toolBar,  SIGNAL(actionTriggered ( QAction *)),this,SLOT(searchToolBar(QAction *)));
+    connect(ui.toolBar_2,SIGNAL(actionTriggered ( QAction *)),this,SLOT(searchToolBar(QAction *)));
+
+	QWidget* dummy0 = new QWidget();
+	QWidget* dummy1 = new QWidget();
+	QWidget* dummy2 = new QWidget();
+	QWidget* dummy3 = new QWidget();
+	QWidget* dummy4 = new QWidget();
+
+	ui.codecWidget->setTitleBarWidget(dummy0);
+	ui.navigationWidget->setTitleBarWidget(dummy1);
+	ui.selectionWidget->setTitleBarWidget(dummy2);
+	ui.volumeWidget->setTitleBarWidget(dummy3);
+	ui.audioMetreWidget->setTitleBarWidget(dummy4);
+
+	this->resize(1, 1);
+}
+/**
+    \fn searchToolBar
+*/
+typedef struct 
+{
+    const char *name;
+    Action event;
+}toolBarTranslate;
+
+toolBarTranslate toolbar[]=
+{
+{"actionOpen",              ACT_OPEN_VIDEO},
+{"actionSave_video",        ACT_SAVE_VIDEO},
+{"actionProperties",        ACT_VIDEO_PROPERTIES},
+{"actionLoad_run_project",  ACT_RUN_PY_PROJECT},
+{"actionSave_project",      ACT_SAVE_PY_PROJECT},
+//{"actionPreviewInput",ACT_PreviewToggle},
+//{"actionPreviewOutput",ACT_PreviewToggle},
+
+{NULL,ACT_DUMMY}
+};
+void MainWindow::searchToolBar(QAction *action)
+{
+        toolBarTranslate *t=toolbar;
+        QString me(action->objectName());
+        const char *name=me.toUtf8().constData();
+        while(t->name)
+        {
+            if(!strcmp(name,t->name))
+            {
+                HandleAction(t->event);
+                return;
+            }
+            t++;
+        }
+        ADM_warning("Toolbar:Cannot handle %s\n",name);
+}
+/**
+    \fn buildFileMenu
+*/
+bool MainWindow::buildMenu(QMenu *root,MenuEntry *menu, int nb)
+{
+    QMenu *subMenu=NULL;
+    for(int i=0;i<nb;i++)
+    {
+        MenuEntry *m=menu+i;
+        switch(m->type)
+        {
+            case MENU_SEPARATOR:
+                root->addSeparator();
+                break;
+            case MENU_SUBMENU:
+                {
+                    subMenu=root->addMenu(m->text);
+                }
+                break;
+            case MENU_SUBACTION:
+            case MENU_ACTION:
+                {   
+                        QMenu *insert=root;
+                        if(m->type==MENU_SUBACTION) insert=subMenu;
+                        QAction *a=NULL;
+                        if(m->icon) 
+                        {
+                            QIcon icon(m->icon);
+                            a=insert->addAction(icon,m->text);
+                        }else
+                            a=insert->addAction(m->text);
+                        m->cookie=(void *)a;
+                        if(m->shortCut)
+                        {
+                            QKeySequence s(m->shortCut);
+                            a->setShortcut(s);
+                        }
+                        break;
+                }
+            default:
+                break;
+        }
+    }
+    return true;
+}
+/**
+    buildFileMenu
+*/
+bool MainWindow::buildMyMenu(void)
+{
+    connect( ui.menuFile,SIGNAL(triggered(QAction*)),this,SLOT(searchFileMenu(QAction*)));
+    buildMenu(ui.menuFile,myMenuFile, sizeof(myMenuFile)/sizeof(MenuEntry));
+
+    connect( ui.menuEdit,SIGNAL(triggered(QAction*)),this,SLOT(searchEditMenu(QAction*)));
+    buildMenu(ui.menuEdit,myMenuEdit, sizeof(myMenuEdit)/sizeof(MenuEntry));
+
+    connect( ui.menuVideo,SIGNAL(triggered(QAction*)),this,SLOT(searchVideoMenu(QAction*)));
+    buildMenu(ui.menuVideo,myMenuVideo, sizeof(myMenuVideo)/sizeof(MenuEntry));
+
+    connect( ui.menuAudio,SIGNAL(triggered(QAction*)),this,SLOT(searchAudioMenu(QAction*)));
+    buildMenu(ui.menuAudio,myMenuAudio, sizeof(myMenuAudio)/sizeof(MenuEntry));
+
+    connect( ui.menuHelp,SIGNAL(triggered(QAction*)),this,SLOT(searchHelpMenu(QAction*)));
+    buildMenu(ui.menuHelp,myMenuHelp, sizeof(myMenuHelp)/sizeof(MenuEntry));
+
+    connect( ui.menuTools,SIGNAL(triggered(QAction*)),this,SLOT(searchToolMenu(QAction*)));
+    buildMenu(ui.menuTools,myMenuTool, sizeof(myMenuTool)/sizeof(MenuEntry));
+
+    connect( ui.menuGo,SIGNAL(triggered(QAction*)),this,SLOT(searchGoMenu(QAction*)));
+    buildMenu(ui.menuGo,myMenuGo, sizeof(myMenuGo)/sizeof(MenuEntry));
+
+    connect( ui.menuView,SIGNAL(triggered(QAction*)),this,SLOT(searchViewMenu(QAction*)));
+    buildMenu(ui.menuView,myMenuView, sizeof(myMenuView)/sizeof(MenuEntry));
+
+    return true;
+}
+
+/**
+    \fn timeChanged
+    \brief Called whenever timeshift is on/off'ed or value changes
+*/
+void MainWindow::timeChanged(int)
+{
+	HandleAction (ACT_TimeShift) ;
+}
+/**
+    \fn searchMenu
+*/
+void MainWindow::searchMenu(QAction * action,MenuEntry *menu, int nb)
+{
+    for(int i=0;i<nb;i++)
+    {
+        MenuEntry *m=menu+i;
+        if(m->cookie==(void*)action)
+        {
+            HandleAction (m->event);
+        }
+    }
+}
+
+/**
+    \fn searchFileMenu
+*/
+#define MKMENU(name) void MainWindow::search##name##Menu(QAction * action) \
+    {searchMenu(action,myMenu##name,sizeof(myMenu##name)/sizeof(MenuEntry));}
+
+MKMENU(File)
+MKMENU(Edit)
+//MKMENU(Recent)
+MKMENU(View)
+MKMENU(Tool)
+MKMENU(Go)
+//MKMENU(Custom)
+MKMENU(Audio)
+MKMENU(Video)
+MKMENU(Help)
+
+
+
+/*
+      We receive a button press event
+*/
+void MainWindow::buttonPressed(void)
+{
+	// Receveid a key press Event, look into table..
+    QObject *obj=sender();
+    if(!obj) return;
+    QString me(obj->objectName());
+    
+	Action action=searchTranslationTable(qPrintable(me));
+    
+
+	if(action!=ACT_DUMMY)
+		HandleAction (action);
+
+}
+void MainWindow::toolButtonPressed(bool i)
+{
+	buttonPressed();
+}
+
+bool MainWindow::eventFilter(QObject* watched, QEvent* event)
+{
+	QKeyEvent *keyEvent;
+
+	switch (event->type())
+	{
+		case QEvent::KeyPress:
+			keyEvent = (QKeyEvent*)event;
+
+			if (watched == slider)
+			{
+				switch (keyEvent->key())
+				{
+					case Qt::Key_Left:
+						if (keyEvent->modifiers() == Qt::ShiftModifier)
+							HandleAction(ACT_Back25Frames);
+						else if (keyEvent->modifiers() == Qt::ControlModifier)
+							HandleAction(ACT_Back50Frames);
+						else
+							HandleAction(ACT_PreviousFrame);
+
+						return true;
+					case Qt::Key_Right:
+						if (keyEvent->modifiers() == Qt::ShiftModifier)
+							HandleAction(ACT_Forward25Frames);
+						else if (keyEvent->modifiers() == Qt::ControlModifier)
+							HandleAction(ACT_Forward50Frames);
+						else
+							HandleAction(ACT_NextFrame);
+
+						return true;
+					case Qt::Key_Up:
+						HandleAction(ACT_NextKFrame);
+						return true;
+					case Qt::Key_Down:
+						HandleAction(ACT_PreviousKFrame);
+						return true;
+					case Qt::Key_Shift:
+						shiftKeyHeld = 1;
+						break;
+				}
+			}
+			else if (keyEvent->key() == Qt::Key_Space)
+			{
+				HandleAction(ACT_PlayAvi);
+				return true;
+			}
+
+			break;
+        case QEvent::Resize:
+            if (watched == ui.sliderPlaceHolder)
+            {
+                    thumbSlider->resize(ui.sliderPlaceHolder->width(), 16);
+                    thumbSlider->move(0, (ui.sliderPlaceHolder->height() - thumbSlider->height()) / 2);
+            }
+            break;
+
+		case QEvent::KeyRelease:
+			keyEvent = (QKeyEvent*)event;
+
+			if (keyEvent->key() == Qt::Key_Shift)
+				shiftKeyHeld = 0;
+
+			break;
+		case QEvent::FocusOut:
+            break;
+        default:
+            break;
+	}
+
+	return QObject::eventFilter(watched, event);
+}
+/**
+    \fn buildRecentMenu
+*/
+bool MainWindow::buildRecentMenu(void)
+{
+    const char **names;
+	names=prefs->get_lastfiles();
+    // Purge entries...
+    recentFiles->clear();
+    for(int i=0;i<4;i++)
+    {
+        if(names[i])
+        {
+            recentFileAction[i]=recentFiles->addAction(QString('0'+i)+QString(":")+QString::fromUtf8(names[i]));
+        }else
+            recentFileAction[i]=NULL;
+    }
+	return true;
+}
+/**
+    \fn searchRecentFiles
+*/
+void MainWindow::searchRecentFiles(QAction * action)
+{
+    for(int i=0;i<4;i++)
+    {
+            QAction *a= recentFileAction[i];
+            if(!a) continue;
+
+            if(a==action) 
+            {
+                HandleAction((Action)(ACT_RECENT0+i));
+                return;
+            }
+    }
+}
+void MainWindow::mousePressEvent(QMouseEvent* event)
+{
+	this->setFocus(Qt::OtherFocusReason);
+}
+
+void MainWindow::dragEnterEvent(QDragEnterEvent *event)
+{
+	if (event->mimeData()->hasFormat("text/uri-list"))
+		event->acceptProposedAction();
+}
+
+void MainWindow::dropEvent(QDropEvent *event)
+{
+	QList<QUrl> urlList;
+	QString fileName;
+	QFileInfo info;
+
+	if (event->mimeData()->hasUrls())
+	{
+		urlList = event->mimeData()->urls();
+
+		for (int fileIndex = 0; fileIndex < urlList.size(); fileIndex++)
+		{
+			fileName = urlList[fileIndex].toLocalFile();
+			info.setFile(fileName);
+#warning FIXME
+#if 0
+			if (info.isFile())
+			{
+				if (avifileinfo)
+					FileSel_ReadWrite(reinterpret_cast <void (*)(const char *)> (A_appendAvi), 0, fileName.toUtf8().data(), actual_workbench_file);
+				else
+					FileSel_ReadWrite(reinterpret_cast <void (*)(const char *)> (A_openAvi), 0, fileName.toUtf8().data(), actual_workbench_file);
+			}
+#endif
+		}
+	}
+
+	event->acceptProposedAction();
+}
+
+void MainWindow::previousIntraFrame(void)
+{
+	if (ui.spinBox_TimeValue->hasFocus())
+		ui.spinBox_TimeValue->stepDown();
+	else
+		HandleAction(ACT_PreviousKFrame);
+}
+
+void MainWindow::nextIntraFrame(void)
+{
+	if (ui.spinBox_TimeValue->hasFocus())
+		ui.spinBox_TimeValue->stepUp();
+	else
+		HandleAction(ACT_NextKFrame);
+}
+
+MainWindow::~MainWindow()
+{
+	clearCustomMenu();
+    delete thumbSlider;
+    thumbSlider=NULL;
+}
+
+void MainWindow::closeEvent(QCloseEvent *event)
+{
+static bool first=true;
+    ADM_warning("Close event\n");
+    if(first)
+    {
+        first=false;
+        HandleAction(ACT_EXIT);
+    }
+    event->accept();
+//         event->ignore();
+
+}
+
+
+static const UI_FUNCTIONS_T UI_Hooks=
+    {
+        ADM_RENDER_API_VERSION_NUMBER,
+        UI_getWindowInfo,
+        UI_updateDrawWindowSize,
+        UI_rgbDraw,
+        UI_getDrawWidget,
+        UI_getPreferredRender
+        
+    };
+QApplication *myApplication=NULL;
+/**
+    \fn  UI_Init
+    \brief First part of UI initialization
+
+*/
+int UI_Init(int nargc,char **nargv)
+{
+    ADM_info("Starting QT4 GUI...\n");
+	initTranslator();
+
+	global_argc=nargc;
+	global_argv=nargv;
+	ADM_renderLibInit(&UI_Hooks);
+    Q_INIT_RESOURCE(avidemux);
+	Q_INIT_RESOURCE(filter);
+
+	myApplication=new QApplication (global_argc, global_argv);
+	myApplication->connect(myApplication, SIGNAL(lastWindowClosed()), myApplication, SLOT(quit()));
+
+	loadTranslator();
+
+	MainWindow *mw = new MainWindow();
+	mw->show();
+
+	QuiMainWindows = (QWidget*)mw;
+
+	uint32_t w, h;
+
+	UI_getPhysicalScreenSize(QuiMainWindows, &w,&h);
+	printf("The screen seems to be %u x %u px\n",w,h);
+
+	UI_QT4VideoWidget(mw->ui.frame_video);  // Add the widget that will handle video display
+	UI_updateRecentMenu();
+
+    // Init vumeter
+    UI_InitVUMeter(mw->ui.frameVU);
+	return 0;
+}
+/**
+
+*/
+bool UI_End(void)
+{
+    ADM_QPreviewCleanup();
+    return true;
+}
+void UI_refreshCustomMenu(void)
+{
+	((MainWindow*)QuiMainWindows)->buildCustomMenu();
+}
+
+/**
+    \fn UI_getCurrentPreview(void)
+    \brief Read previewmode from comboxbox 
+*/
+int UI_getCurrentPreview(void)
+{
+	int index;
+
+	if (WIDGET(actionPreviewOutput)->isChecked())
+		index = 1;
+	else if (WIDGET(actionPreviewSide)->isChecked())
+		index = 2;
+	else if (WIDGET(actionPreviewTop)->isChecked())
+		index = 3;
+	else if (WIDGET(actionPreviewSeparate)->isChecked())
+		index = 4;
+	else
+		index = 0;
+
+	return index;
+}
+
+/**
+    \fn UI_setCurrentPreview(int ne)
+    \brief Update comboxbox with previewmode
+*/
+void UI_setCurrentPreview(int ne)
+{
+	switch (ne)
+	{
+		case 1:
+			WIDGET(actionPreviewOutput)->setChecked(true);
+			break;
+		case 2:
+			WIDGET(actionPreviewSide)->setChecked(true);
+			break;
+		case 3:
+			WIDGET(actionPreviewTop)->setChecked(true);
+			break;
+		case 4:
+			WIDGET(actionPreviewSeparate)->setChecked(true);
+			break;
+		default:
+			WIDGET(actionPreviewInput)->setChecked(true);
+	}
+}
+/**
+        \fn FatalFunctionQt
+*/
+static void FatalFunctionQt(const char *title, const char *info)
+{
+	GUI_Info_HIG(ADM_LOG_IMPORTANT, title, info);
+}
+
+/**
+    \fn UI_RunApp(void)
+    \brief Main entry point for the GUI application
+*/
+int UI_RunApp(void)
+{
+	
+	setupMenus();
+    ADM_setCrashHook(&saveCrashProject, &FatalFunctionQt);
+	checkCrashFile();
+
+	if (global_argc >= 2)
+		automation();
+
+	myApplication->exec();
+
+	destroyTranslator();
+    delete myApplication;
+    myApplication=NULL;
+    return 1;
+}
+/**
+    \fn searchTranslationTable(const char *name))
+    \brief return the action corresponding to a give button. The translation table is in translation_table.h
+*/
+Action searchTranslationTable(const char *name)
+{
+	for(int i=0;i< SIZEOF_MY_TRANSLATION;i++)
+	{
+		if(!strcmp(name, myTranslationTable[i].name))
+		{
+			return  myTranslationTable[i].action;
+		}
+	}
+	printf("WARNING: Signal not found in translation table %s\n",name);
+	return ACT_DUMMY;
+}
+/**
+    \fn     UI_updateRecentMenu( void )
+    \brief  Update the recent submenu with the latest files loaded
+*/
+uint8_t UI_updateRecentMenu( void )
+{
+    return  ((MainWindow *)QuiMainWindows)->buildRecentMenu();
+}
+/** 
+  \fn    setupMenus(void)
+  \brief Fill in video & audio co
+*/
+void setupMenus(void)
+{
+	uint32_t nbVid;
+    uint32_t maj,mn,pa;
+	const char *name;
+
+	nbVid=ADM_ve6_getNbEncoders();
+	printf("Found %d video encoder(s)\n",nbVid);
+	for(uint32_t i=1;i<nbVid;i++)
+	{
+		ADM_ve6_getEncoderInfo(i,&name,&maj,&mn,&pa);
+		WIDGET(comboBoxVideo)->addItem(name);
+	}
+
+	// And A codec
+
+	uint32_t nbAud;
+
+    nbAud=audioEncoderGetNumberOfEncoders();
+	printf("Found %d audio encoder(s)\n",nbAud);		       
+	for(uint32_t i=1;i<nbAud;i++)
+	{
+		name=audioEncoderGetDisplayName(i);
+		WIDGET(comboBoxAudio)->addItem(name);
+	}
+
+	/*   Fill in output format window */
+	uint32_t nbFormat=ADM_mx_getNbMuxers();
+
+	printf("Found %d format(s)\n",nbFormat);
+	for(uint32_t i=0;i<nbFormat;i++)
+	{
+        const char *name=ADM_mx_getDisplayName(i);
+		WIDGET(comboBoxFormat)->addItem(name);	
+	}
+
+}
+/*
+    Return % of scale (between 0 and 1)
+*/
+double 	UI_readScale( void )
+{
+	double v;
+	if(!slider) v=0;
+	v= (double)(slider->value());
+	v/=10000000;
+	return v;
+}
+void UI_setScale( double val )
+{
+	if(_upd_in_progres) return;
+	_upd_in_progres++;
+	slider->setValue( (int)(val * 10000000));
+	_upd_in_progres--;
+}
+
+int UI_readCurFrame(void)
+{
+	return 0;
+}
+
+int UI_readCurTime(uint16_t &hh, uint16_t &mm, uint16_t &ss, uint16_t &ms)
+{
+	int success = 0;
+
+	QString timeText = WIDGET(currentTime)->text();
+	int pos;
+
+	if (WIDGET(currentTime)->validator()->validate(timeText, pos) == QValidator::Acceptable)
+	{
+		uint32_t frame;
+
+		hh = (uint16_t)timeText.left(2).toUInt();
+		mm = (uint16_t)timeText.mid(3, 2).toUInt();
+		ss = (uint16_t)timeText.mid(6, 2).toUInt();
+		ms = (uint16_t)timeText.right(3).toUInt();
+
+		time2frame(&frame, currentFps, hh, mm, ss, ms);
+
+		if (frame <= frameCount)
+			success = 1;
+	}
+
+	return success;
+}
+
+
+
+//*******************************************
+
+/**
+    \fn UI_setTitle(char *name)
+    \brief Set the main window title, usually name if the file being edited
+*/
+void UI_setTitle(const char *name)
+{
+	char *title;
+	const char* defaultTitle = "Avidemux";
+
+	if (name && (*name) )
+	{
+		title = new char[strlen(defaultTitle) + strlen(name) + 3 + 1];
+
+		strcpy(title, name);
+		strcat(title, " - ");
+		strcat(title, defaultTitle);
+	}
+	else
+	{
+		title = new char[strlen(defaultTitle) + 1];
+
+		strcpy(title, defaultTitle);
+	}
+
+	QuiMainWindows->setWindowTitle(QString::fromUtf8(title));
+	delete [] title;
+}
+
+/**
+    \fn     UI_setFrameType( uint32_t frametype,uint32_t qp)
+    \brief  Display frametype (I/P/B) and associated quantizer
+*/
+
+void UI_setFrameType( uint32_t frametype,uint32_t qp)
+{
+	char string[100];
+	char	c='?';
+    const char *f="???";
+	switch(frametype&AVI_FRAME_TYPE_MASK)
+	{
+	case AVI_KEY_FRAME: c='I';break;
+	case AVI_B_FRAME: c='B';break;
+	case 0: c='P';break;
+	default:c='?';break;
+
+	}
+    switch(frametype&AVI_STRUCTURE_TYPE_MASK)
+	{
+	case AVI_TOP_FIELD+AVI_FIELD_STRUCTURE: f="TFF";break;
+    case AVI_BOTTOM_FIELD+AVI_FIELD_STRUCTURE: f="BFF";break;
+    case AVI_FRAME_STRUCTURE: f="FRM";break;
+	default:f="???";
+
+                    break;
+	}
+	sprintf(string,QT_TR_NOOP("%c-%s (%02d)"),c,f,qp);
+	WIDGET(label_8)->setText(string);	
+
+}
+
+/**
+    \fn     UI_updateFrameCount(uint32_t curFrame)
+    \brief  Display the current displayed frame #
+*/
+void UI_updateFrameCount(uint32_t curFrame)
+{
+	
+}
+
+/**
+    \fn      UI_setFrameCount(uint32_t curFrame,uint32_t total)
+    \brief  Display the current displayed frame # and total frame #
+*/
+void UI_setFrameCount(uint32_t curFrame,uint32_t total)
+{
+	
+}
+
+/**
+    \fn     UI_updateTimeCount(uint32_t curFrame,uint32_t fps)
+    \brief  Display the time corresponding to current frame according to fps (fps1000)
+*/
+void UI_updateTimeCount(uint32_t curFrame,uint32_t fps)
+{
+	char text[80];   
+	uint32_t mm,hh,ss,ms;
+
+	frame2time(curFrame,fps, &hh, &mm, &ss, &ms);
+	sprintf(text, "%02d:%02d:%02d.%03d", hh, mm, ss, ms);
+	WIDGET(currentTime)->setText(text);
+}
+
+
+
+/**
+    \fn UI_setCurrentTime
+    \brief Set current PTS of displayed video
+*/
+void UI_setCurrentTime(uint64_t curTime)
+{
+  char text[80];
+ uint32_t mm,hh,ss,ms;
+ uint32_t shorty=(uint32_t)(curTime/1000);
+
+    ms2time(shorty,&hh,&mm,&ss,&ms);
+  	sprintf(text, "%02d:%02d:%02d.%03d", hh, mm, ss, ms);
+	WIDGET(currentTime)->setText(text);
+
+}
+
+/**
+    \fn UI_setTotalTime
+    \brief SEt the total duration of video
+*/
+void UI_setTotalTime(uint64_t curTime)
+{
+  char text[80];
+ uint32_t mm,hh,ss,ms;
+ uint32_t shorty=(uint32_t)(curTime/1000);
+
+    ms2time(shorty,&hh,&mm,&ss,&ms);
+  	sprintf(text, "/%02d:%02d:%02d.%03d", hh, mm, ss, ms);
+    WIDGET(totalTime)->setText(text);
+    slider->setTotalDuration(curTime);
+}
+/**
+    \fn     UI_setMarkers(uint64_t Ptsa, uint32_t Ptsb )
+    \brief  Display frame # for marker A & B
+*/
+void UI_setMarkers(uint64_t a, uint64_t b)
+{
+	char text[80];
+    uint64_t absoluteA=a,absoluteB=b;
+    uint32_t hh,mm,ss,ms;
+    uint32_t timems;
+    a/=1000;
+    b/=1000;
+
+    timems=(uint32_t)(a);
+    ms2time(timems,&hh,&mm,&ss,&ms);
+	snprintf(text,79,"%02"LU":%02"LU":%02"LU".%02"LU,hh,mm,ss,ms);
+	WIDGET(pushButtonJumpToMarkerA)->setText(text);
+
+	timems=(uint32_t)(b);
+    ms2time(timems,&hh,&mm,&ss,&ms);
+	snprintf(text,79,"%02"LU":%02"LU":%02"LU".%02"LU,hh,mm,ss,ms);
+	WIDGET(pushButtonJumpToMarkerB)->setText(text);
+
+	slider->setMarkers(absoluteA, absoluteB);
+}
+
+/**
+    \fn     UI_getCurrentVCodec(void)
+    \brief  Returns the current selected video code in menu, i.e its number (0 being the first)
+*/
+int 	UI_getCurrentVCodec(void)
+{
+	int i=WIDGET(comboBoxVideo)->currentIndex();
+	if(i<0) i=0;
+	return i; 
+}
+/**
+    \fn     UI_setVideoCodec( int i)
+    \brief  Select the video codec which is # x in pulldown menu (starts at zero :copy)
+*/
+
+void UI_setVideoCodec( int i)
+{
+	int b=!!i;
+	WIDGET(comboBoxVideo)->setCurrentIndex(i);
+
+	WIDGET(pushButtonVideoConf)->setEnabled(b);
+	WIDGET(pushButtonVideoFilter)->setEnabled(b);
+}
+/**
+    \fn     UI_getCurrentACodec(void)
+    \brief  Returns the current selected audio code in menu, i.e its number (0 being the first)
+*/
+
+int 	UI_getCurrentACodec(void)
+{
+	int i=WIDGET(comboBoxAudio)->currentIndex();
+	if(i<0) i=0;
+	return i; 
+}
+/**
+    \fn     UI_setAudioCodec( int i)
+    \brief  Select the audio codec which is # x in pulldown menu (starts at zero :copy)
+*/
+
+void UI_setAudioCodec( int i)
+{ int b=!!i;
+WIDGET(comboBoxAudio)->setCurrentIndex(i);
+WIDGET(pushButtonAudioConf)->setEnabled(b);
+WIDGET(pushButtonAudioFilter)->setEnabled(b);
+}
+/**
+    \fn     UI_GetCurrentFormat(void)
+    \brief  Returns the current selected output format
+*/
+
+int 	UI_GetCurrentFormat( void )
+{
+	int i=WIDGET(comboBoxFormat)->currentIndex();
+	if(i<0) i=0;
+	return (int)i; 
+}
+/**
+    \fn     UI_SetCurrentFormat( ADM_OUT_FORMAT fmt )
+    \brief  Select  output format
+*/
+uint8_t 	UI_SetCurrentFormat( uint32_t fmt )
+{
+	WIDGET(comboBoxFormat)->setCurrentIndex((int)fmt);
+    return 1;
+}
+
+/**
+      \fn UI_getTimeShift
+      \brief get state (on/off) and value for time Shift
+*/
+uint8_t UI_getTimeShift(int *onoff,int *value)
+{
+	if(WIDGET(checkBox_TimeShift)->checkState()==Qt::Checked)
+		*onoff=1;
+	else
+		*onoff=0;
+	*value=WIDGET(spinBox_TimeValue)->value();
+	return 1;
+}
+/**
+      \fn UI_setTimeShift
+      \brief get state (on/off) and value for time Shift
+*/
+
+uint8_t UI_setTimeShift(int onoff,int value)
+{
+	if (onoff && value)
+		WIDGET(checkBox_TimeShift)->setCheckState(Qt::Checked);
+	else
+		WIDGET(checkBox_TimeShift)->setCheckState(Qt::Unchecked);
+	WIDGET(spinBox_TimeValue)->setValue(value);
+	return 1;
+}
+/**
+    \fn UI_setVUMeter
+*/
+bool UI_setVUMeter( uint32_t volume[6])
+{
+    UI_vuUpdate( volume);
+    return true;
+}
+/**
+    \fn setDecodeName
+*/
+bool UI_setDecoderName(const char *name)
+{
+    WIDGET(labelVideoDecoder)->setText(name);	
+    return true;
+}
+//********************************************
+//EOF



From mean at mail.berlios.de  Wed Jun 15 08:23:25 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Wed, 15 Jun 2011 08:23:25 +0200
Subject: [Avidemux-svn-commit] r7282 -
	branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_gui
Message-ID: <20110615062325.96D55481412@sheep.berlios.de>

Author: mean
Date: 2011-06-15 08:23:25 +0200 (Wed, 15 Jun 2011)
New Revision: 7282

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_gui/Q_gui2.cpp
Log:
[ui] Fix drag n drop, may not be working on win32

Modified: branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_gui/Q_gui2.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_gui/Q_gui2.cpp	2011-06-15 06:23:24 UTC (rev 7281)
+++ branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_gui/Q_gui2.cpp	2011-06-15 06:23:25 UTC (rev 7282)
@@ -623,6 +623,7 @@
 	QList<QUrl> urlList;
 	QString fileName;
 	QFileInfo info;
+    const char *cFileName;
 
 	if (event->mimeData()->hasUrls())
 	{
@@ -632,16 +633,24 @@
 		{
 			fileName = urlList[fileIndex].toLocalFile();
 			info.setFile(fileName);
-#warning FIXME
-#if 0
+            cFileName=fileName.toUtf8().constData();
+            ADM_info("Drop event %s\n",cFileName);
 			if (info.isFile())
 			{
 				if (avifileinfo)
-					FileSel_ReadWrite(reinterpret_cast <void (*)(const char *)> (A_appendAvi), 0, fileName.toUtf8().data(), actual_workbench_file);
+                {
+                    ADM_info("Appending..\n");
+                    A_appendAvi(cFileName);
+                }
 				else
-					FileSel_ReadWrite(reinterpret_cast <void (*)(const char *)> (A_openAvi), 0, fileName.toUtf8().data(), actual_workbench_file);
-			}
-#endif
+                {
+                    ADM_info("Opening..\n");
+                    A_openAvi(cFileName);
+                }
+			}else
+            {
+                ADM_warning("Dropped item is not a file\n");
+            }
 		}
 	}
 



From mean at mail.berlios.de  Wed Jun 15 08:23:26 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Wed, 15 Jun 2011 08:23:26 +0200
Subject: [Avidemux-svn-commit] r7283 -
	branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_gui
Message-ID: <20110615062326.CF852481412@sheep.berlios.de>

Author: mean
Date: 2011-06-15 08:23:26 +0200 (Wed, 15 Jun 2011)
New Revision: 7283

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_gui/Q_gui2.cpp
Log:
[ui] duplicate dropped item name, as it is valid only for a while

Modified: branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_gui/Q_gui2.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_gui/Q_gui2.cpp	2011-06-15 06:23:25 UTC (rev 7282)
+++ branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_gui/Q_gui2.cpp	2011-06-15 06:23:26 UTC (rev 7283)
@@ -633,7 +633,7 @@
 		{
 			fileName = urlList[fileIndex].toLocalFile();
 			info.setFile(fileName);
-            cFileName=fileName.toUtf8().constData();
+            cFileName=ADM_strdup(fileName.toUtf8().constData());
             ADM_info("Drop event %s\n",cFileName);
 			if (info.isFile())
 			{
@@ -651,6 +651,7 @@
             {
                 ADM_warning("Dropped item is not a file\n");
             }
+            ADM_dealloc(cFileName);
 		}
 	}
 



From mean at mail.berlios.de  Wed Jun 15 08:23:27 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Wed, 15 Jun 2011 08:23:27 +0200
Subject: [Avidemux-svn-commit] r7284 -
	branches/avidemux_2.6_branch_mean/cmake
Message-ID: <20110615062327.E35EC481412@sheep.berlios.de>

Author: mean
Date: 2011-06-15 08:23:27 +0200 (Wed, 15 Jun 2011)
New Revision: 7284

Modified:
   branches/avidemux_2.6_branch_mean/cmake/ADM_coreConfig.h.cmake
   branches/avidemux_2.6_branch_mean/cmake/admDetermineSystem.cmake
Log:
[build] Add armel

Modified: branches/avidemux_2.6_branch_mean/cmake/ADM_coreConfig.h.cmake
===================================================================
--- branches/avidemux_2.6_branch_mean/cmake/ADM_coreConfig.h.cmake	2011-06-15 06:23:26 UTC (rev 7283)
+++ branches/avidemux_2.6_branch_mean/cmake/ADM_coreConfig.h.cmake	2011-06-15 06:23:27 UTC (rev 7284)
@@ -8,6 +8,7 @@
 #cmakedefine ADM_BIG_ENDIAN
 #cmakedefine ADM_CPU_64BIT
 #cmakedefine ADM_CPU_ALTIVEC
+#cmakedefine ADM_CPU_ARMEL
 #cmakedefine ADM_CPU_DCBZL
 #cmakedefine ADM_CPU_PPC
 #cmakedefine ADM_CPU_MMX2

Modified: branches/avidemux_2.6_branch_mean/cmake/admDetermineSystem.cmake
===================================================================
--- branches/avidemux_2.6_branch_mean/cmake/admDetermineSystem.cmake	2011-06-15 06:23:26 UTC (rev 7283)
+++ branches/avidemux_2.6_branch_mean/cmake/admDetermineSystem.cmake	2011-06-15 06:23:27 UTC (rev 7284)
@@ -1,6 +1,7 @@
 # Determine CPU and Operating System for GCC
 #  ADM_BIG_ENDIAN  - big endian CPU detected
 #  ADM_BSD_FAMILY  - BSD family operating system was detected
+#  ADM_CPU_ARMEL   - ARM (min ARCH5) el
 #  ADM_CPU_64BIT   - 64-bit CPU was detected
 #  ADM_CPU_PPC     - PowerPC CPU architecture was detected
 #  ADM_CPU_ALTIVEC - PowerPC CPU with AltiVec instructions is supported
@@ -128,6 +129,11 @@
 			IF (DCBZL_SUPPORTED)
 				SET(ADM_CPU_DCBZL 1)
 			ENDIF (DCBZL_SUPPORTED)
+		ELSE (POWERPC_SUPPORTED)
+		        PERFORM_SYSTEM_TEST(cpu_armel_check.cpp "ARM EL" ARMEL_SUPPORTED)
+                        IF(ARMEL_SUPPORTED)
+			        SET(ADM_CPU_ARMEL 1)
+                        ENDIF(ARMEL_SUPPORTED)
 		ENDIF (POWERPC_SUPPORTED)
 	ENDIF (X86_32_SUPPORTED)
 ENDIF (X86_64_SUPPORTED)
@@ -146,9 +152,9 @@
 	ENDIF (SSSE3_SUPPORTED)
 ENDIF (ADM_CPU_X86)
 
-IF (NOT ADM_CPU_X86_32 AND NOT ADM_CPU_X86_64 AND NOT ADM_CPU_PPC)
+IF (NOT ADM_CPU_X86_32 AND NOT ADM_CPU_X86_64 AND NOT ADM_CPU_PPC AND NOT ADM_CPU_ARMEL)
 	MESSAGE(FATAL_ERROR "CPU not supported")
-ENDIF (NOT ADM_CPU_X86_32 AND NOT ADM_CPU_X86_64 AND NOT ADM_CPU_PPC)
+ENDIF (NOT ADM_CPU_X86_32 AND NOT ADM_CPU_X86_64 AND NOT ADM_CPU_PPC AND NOT ADM_CPU_ARMEL)
 
 TEST_BIG_ENDIAN(CMAKE_WORDS_BIGENDIAN)
 
@@ -156,4 +162,4 @@
 	SET(ADM_BIG_ENDIAN 1)
 ENDIF (CMAKE_WORDS_BIGENDIAN)
 
-MESSAGE("")
\ No newline at end of file
+MESSAGE("")



From mean at mail.berlios.de  Wed Jun 15 08:23:28 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Wed, 15 Jun 2011 08:23:28 +0200
Subject: [Avidemux-svn-commit] r7285 -
	branches/avidemux_2.6_branch_mean/cmake_compile_check
Message-ID: <20110615062328.EB8C2481412@sheep.berlios.de>

Author: mean
Date: 2011-06-15 08:23:28 +0200 (Wed, 15 Jun 2011)
New Revision: 7285

Added:
   branches/avidemux_2.6_branch_mean/cmake_compile_check/cpu_armel_check.cpp
Log:
[build] Add armel

Added: branches/avidemux_2.6_branch_mean/cmake_compile_check/cpu_armel_check.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/cmake_compile_check/cpu_armel_check.cpp	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/cmake_compile_check/cpu_armel_check.cpp	2011-06-15 06:23:28 UTC (rev 7285)
@@ -0,0 +1,10 @@
+int foo(void)
+{
+
+	asm volatile ("mov lr,pc " : : );
+}
+
+int main(int a, char **b)
+{
+	return 0;
+}



From mean at mail.berlios.de  Wed Jun 15 20:26:21 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Wed, 15 Jun 2011 20:26:21 +0200
Subject: [Avidemux-svn-commit] r7286 -
	branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor
Message-ID: <20110615182621.57BC2480D95@sheep.berlios.de>

Author: mean
Date: 2011-06-15 20:26:20 +0200 (Wed, 15 Jun 2011)
New Revision: 7286

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edVideoCopy.cpp
Log:
[editor] Dont allocate huge chunk on the heap + fine tune the not-cut-on-keyframe code. Still not reliable

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edVideoCopy.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edVideoCopy.cpp	2011-06-15 06:23:28 UTC (rev 7285)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edVideoCopy.cpp	2011-06-15 18:26:20 UTC (rev 7286)
@@ -39,7 +39,7 @@
     int nbSeg=_segments.getNbSegments();
 
     ADMCompressedImage img;
-    uint8_t buffer[1920*1080*3];
+    uint8_t *buffer=new uint8_t[1920*1080*3];
     img.data=buffer;
     ADM_info("Checking cuts start on keyframe..\n");
     for(int i=0;i<nbSeg;i++)
@@ -55,21 +55,40 @@
         }
         if(false==demuxer->getFrame (vid->lastSentFrame,&img))
         {
+            ADM_info("Cannot get 1st frame of segment %d\n",i);
             fail=true;
             break;
         }
-        if(img.flags & AVI_KEY_FRAME)
+        if(!img.flags & AVI_KEY_FRAME)
         {
-            ADM_info("Segment %d starts on a keyframe\n",i);
-        }else   
-        {
             ADM_warning("Segment %d does not start on a keyframe (%s)\n",i,ADM_us2plain(img.demuxerPts));
             fail=true;
-             break;
+            break;
         }
+        // After a seg switch we are at the keyframe before or equal to where we want to go
+        // if the dts do not match, it means we went back too much
+        // When re-encoding, it's not a problem, it is when copying.
+        ADM_info("seg:%d refDTS=%"LLU"\n",seg->_reference,seg->_refStartDts);
+        ADM_info("seg:%d imgDTS=%"LLU"\n",seg->_reference,img.demuxerDts);
+        if(!seg->_refStartDts && !seg->_reference)
+        {
+            ADM_info("Ignoring first seg (unreliable DTS)\n");
+            
+        }else
+        if(img.demuxerDts!=ADM_NO_PTS && seg->_refStartDts!=ADM_NO_PTS && 
+            img.demuxerDts!=seg->_refStartDts)
+        {
+            ADM_warning("Segment %d does not start on a known DTS (%s)\n",i,ADM_us2plain(img.demuxerPts));
+            ADM_warning("expected (%s)\n",ADM_us2plain(seg->_refStartDts));
+            fail=true;
+            break;
+        }
+        ADM_info("Segment %d ok\n",i);
     }   
-
-    return fail;
+    delete [] buffer;
+    buffer=NULL;
+    if(fail) return false;
+    return true;
 }
 
 /**



From gruntster at mail.berlios.de  Thu Jun 16 21:40:12 2011
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Thu, 16 Jun 2011 21:40:12 +0200
Subject: [Avidemux-svn-commit] r7287 -
	branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/lavcodec
Message-ID: <20110616194012.E970E481297@sheep.berlios.de>

Author: gruntster
Date: 2011-06-16 21:40:12 +0200 (Thu, 16 Jun 2011)
New Revision: 7287

Modified:
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/lavcodec/audioencoder_lavcodec.cpp
Log:
[lavc] fix libavcodec based audio encoders (patch by mean)

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/lavcodec/audioencoder_lavcodec.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/lavcodec/audioencoder_lavcodec.cpp	2011-06-15 18:26:20 UTC (rev 7286)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioEncoders/lavcodec/audioencoder_lavcodec.cpp	2011-06-16 19:40:12 UTC (rev 7287)
@@ -144,6 +144,8 @@
   CONTEXT->channels     =  _wavheader->channels;
   CONTEXT->sample_rate  =  _wavheader->frequency;
   CONTEXT->bit_rate     = (lavConfig.bitrate*1000); // bits -> kbits
+  CONTEXT->sample_fmt   = AV_SAMPLE_FMT_S16;
+  CONTEXT->request_sample_fmt = AV_SAMPLE_FMT_S16;
 
   AVCodec *codec;
   CodecID codecID;



From gruntster at mail.berlios.de  Thu Jun 16 21:46:07 2011
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Thu, 16 Jun 2011 21:46:07 +0200
Subject: [Avidemux-svn-commit] r7288 -
	branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264
Message-ID: <20110616194608.04DAB481297@sheep.berlios.de>

Author: gruntster
Date: 2011-06-16 21:46:07 +0200 (Thu, 16 Jun 2011)
New Revision: 7288

Modified:
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/encoder.cpp
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/x264Options.cpp
Log:
[x264] support core version 115

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/encoder.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/encoder.cpp	2011-06-16 19:40:12 UTC (rev 7287)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/encoder.cpp	2011-06-16 19:46:07 UTC (rev 7288)
@@ -488,7 +488,10 @@
 	printf("[x264] analyse.b_transform_8x8 = %d\n", x264Param->analyse.b_transform_8x8);
 	printf("[x264] analyse.inter = %d\n", x264Param->analyse.inter);
 	printf("[x264] b_cabac = %d\n", x264Param->b_cabac);
-#if X264_BUILD > 101
+#if X264_BUILD > 114
+	printf("[x264] b_open_gop = %d\n", x264Param->b_open_gop);
+	printf("[x264] b_bluray_compat = %d\n", x264Param->b_bluray_compat);
+#elif X264_BUILD > 101
 	printf("[x264] i_open_gop = %d\n", x264Param->i_open_gop);
 #endif
 	printf("[x264] b_interlaced = %d\n", x264Param->b_interlaced);

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/x264Options.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/x264Options.cpp	2011-06-16 19:40:12 UTC (rev 7287)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/x264Options.cpp	2011-06-16 19:46:07 UTC (rev 7288)
@@ -420,13 +420,34 @@
 #if X264_BUILD > 101
 unsigned int x264Options::getOpenGopMode(void)
 {
+#if X264_BUILD > 114
+	if (_param.b_open_gop == 1)
+	{
+		if (_param.b_bluray_compat == 1)
+		{
+			return 2;
+		}
+		else
+		{
+			return 1;
+		}
+	}
+
+	return 0;
+#else
 	return _param.i_open_gop;
+#endif
 }
 
 void x264Options::setOpenGopMode(unsigned int openGopMode)
 {
+#if X264_BUILD > 114
+	_param.b_open_gop = (openGopMode > 0 ? 1 : 0);
+	_param.b_bluray_compat = (openGopMode == 2 ? 1 : 0);
+#else
 	if (openGopMode < 3)
 		_param.i_open_gop = openGopMode;
+#endif
 }
 #endif
 



From gruntster at mail.berlios.de  Thu Jun 16 21:51:50 2011
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Thu, 16 Jun 2011 21:51:50 +0200
Subject: [Avidemux-svn-commit] r7289 - in
	branches/avidemux_2.5_branch_gruntster/platforms/windows/build_scripts:
	avidemux faac faad libvpx nspr x264 xvid
Message-ID: <20110616195150.A7A5E481297@sheep.berlios.de>

Author: gruntster
Date: 2011-06-16 21:51:50 +0200 (Thu, 16 Jun 2011)
New Revision: 7289

Added:
   branches/avidemux_2.5_branch_gruntster/platforms/windows/build_scripts/faac/makefile
   branches/avidemux_2.5_branch_gruntster/platforms/windows/build_scripts/faad/makefile
   branches/avidemux_2.5_branch_gruntster/platforms/windows/build_scripts/nspr/configure.patch
Modified:
   branches/avidemux_2.5_branch_gruntster/platforms/windows/build_scripts/avidemux/Set Avidemux Environment Variables.bat
   branches/avidemux_2.5_branch_gruntster/platforms/windows/build_scripts/faac/Perform Build.bat
   branches/avidemux_2.5_branch_gruntster/platforms/windows/build_scripts/faad/Perform Build.bat
   branches/avidemux_2.5_branch_gruntster/platforms/windows/build_scripts/libvpx/Perform Build.bat
   branches/avidemux_2.5_branch_gruntster/platforms/windows/build_scripts/libvpx/configure.sh.patch
   branches/avidemux_2.5_branch_gruntster/platforms/windows/build_scripts/nspr/Perform Build.bat
   branches/avidemux_2.5_branch_gruntster/platforms/windows/build_scripts/x264/Perform Build.bat
   branches/avidemux_2.5_branch_gruntster/platforms/windows/build_scripts/xvid/Perform Build.bat
   branches/avidemux_2.5_branch_gruntster/platforms/windows/build_scripts/xvid/configure.patch
Log:
[mswin] update build scripts

Modified: branches/avidemux_2.5_branch_gruntster/platforms/windows/build_scripts/avidemux/Set Avidemux Environment Variables.bat
===================================================================
--- branches/avidemux_2.5_branch_gruntster/platforms/windows/build_scripts/avidemux/Set Avidemux Environment Variables.bat	2011-06-16 19:46:07 UTC (rev 7288)
+++ branches/avidemux_2.5_branch_gruntster/platforms/windows/build_scripts/avidemux/Set Avidemux Environment Variables.bat	2011-06-16 19:51:50 UTC (rev 7289)
@@ -26,8 +26,8 @@
 	goto error
 )
 
-if exist "%ProgramFiles32%\7-zip" (
-	set SevenZipDir=%ProgramFiles32%\7-zip
+if exist "%ProgramFiles%\7-zip" (
+	set SevenZipDir=%ProgramFiles%\7-zip
 ) else (
 	echo 7-zip could not be found.  Please download from http://www.7-zip.org
 	goto error

Modified: branches/avidemux_2.5_branch_gruntster/platforms/windows/build_scripts/faac/Perform Build.bat
===================================================================
--- branches/avidemux_2.5_branch_gruntster/platforms/windows/build_scripts/faac/Perform Build.bat	2011-06-16 19:46:07 UTC (rev 7288)
+++ branches/avidemux_2.5_branch_gruntster/platforms/windows/build_scripts/faac/Perform Build.bat	2011-06-16 19:51:50 UTC (rev 7289)
@@ -49,10 +49,15 @@
 
 copy ".\include\*.h" "%usrLocalDir%\include"
 cd libfaac
-gcc -s -O3 -shared -I../include *.c -o"%usrLocalDir%/bin/libfaac.dll" -Wl,--out-implib,"%usrLocalDir%/lib/libfaac.a"
+copy "%curDir%\makefile."
+
+make
 if errorlevel 1 goto end
 
+copy libfaac.dll "%usrLocalDir%/bin"
+copy libfaac.a "%usrLocalDir%/lib"
 copy "%usrLocalDir%\bin\libfaac.dll" "%admBuildDir%"
+
 goto end
 
 :error

Added: branches/avidemux_2.5_branch_gruntster/platforms/windows/build_scripts/faac/makefile
===================================================================
--- branches/avidemux_2.5_branch_gruntster/platforms/windows/build_scripts/faac/makefile	                        (rev 0)
+++ branches/avidemux_2.5_branch_gruntster/platforms/windows/build_scripts/faac/makefile	2011-06-16 19:51:50 UTC (rev 7289)
@@ -0,0 +1,5 @@
+CFLAGS =-s -O3 -shared -I../include -Wl,--out-implib,libfaac.a
+SRC=$(wildcard *.c)
+
+libfaac.dll: $(SRC)
+	gcc -o $@ $^ $(CFLAGS)
\ No newline at end of file

Modified: branches/avidemux_2.5_branch_gruntster/platforms/windows/build_scripts/faad/Perform Build.bat
===================================================================
--- branches/avidemux_2.5_branch_gruntster/platforms/windows/build_scripts/faad/Perform Build.bat	2011-06-16 19:46:07 UTC (rev 7288)
+++ branches/avidemux_2.5_branch_gruntster/platforms/windows/build_scripts/faad/Perform Build.bat	2011-06-16 19:51:50 UTC (rev 7289)
@@ -49,10 +49,15 @@
 
 copy ".\include\*.h" "%usrLocalDir%\include"
 cd libfaad
-gcc -s -O3 -DHAVE_MEMCPY=1 -DHAVE_STRING_H=1 -DHAVE_STDINT_H=1 -I../include -I"." *.c -shared -o "%usrLocalDir%/bin/libfaad2.dll" -Wl,--out-implib,"%usrLocalDir%/lib/libfaad.a"
+copy "%curDir%\makefile."
+
+make
 if errorlevel 1 goto end
 
+copy libfaad2.dll "%usrLocalDir%/bin"
+copy libfaad.a "%usrLocalDir%/lib"
 copy "%usrLocalDir%\bin\libfaad2.dll" "%admBuildDir%"
+
 goto end
 
 :error

Added: branches/avidemux_2.5_branch_gruntster/platforms/windows/build_scripts/faad/makefile
===================================================================
--- branches/avidemux_2.5_branch_gruntster/platforms/windows/build_scripts/faad/makefile	                        (rev 0)
+++ branches/avidemux_2.5_branch_gruntster/platforms/windows/build_scripts/faad/makefile	2011-06-16 19:51:50 UTC (rev 7289)
@@ -0,0 +1,5 @@
+CFLAGS =-s -O3 -shared -DHAVE_MEMCPY=1 -DHAVE_STRING_H=1 -DHAVE_STDINT_H=1 -I../include -I"." -Wl,--out-implib,libfaad.a
+SRC=$(wildcard *.c)
+
+libfaad2.dll: $(SRC)
+	gcc -o $@ $^ $(CFLAGS)
\ No newline at end of file

Modified: branches/avidemux_2.5_branch_gruntster/platforms/windows/build_scripts/libvpx/Perform Build.bat
===================================================================
--- branches/avidemux_2.5_branch_gruntster/platforms/windows/build_scripts/libvpx/Perform Build.bat	2011-06-16 19:46:07 UTC (rev 7288)
+++ branches/avidemux_2.5_branch_gruntster/platforms/windows/build_scripts/libvpx/Perform Build.bat	2011-06-16 19:51:50 UTC (rev 7289)
@@ -17,9 +17,9 @@
 call "../Set Common Environment Variables"
 if errorlevel 1 goto end
 
-set package=libvpx-v0.9.5.tar.bz2
-set sourceFolder=libvpx-0.9.5-%BuildBits%
-set tarFolder=libvpx-v0.9.5
+set package=libvpx-v0.9.6.tar.bz2
+set sourceFolder=libvpx-0.9.6-%BuildBits%
+set tarFolder=libvpx-v0.9.6
 set curDir=%CD%
 
 if not exist %package% (

Modified: branches/avidemux_2.5_branch_gruntster/platforms/windows/build_scripts/libvpx/configure.sh.patch
===================================================================
--- branches/avidemux_2.5_branch_gruntster/platforms/windows/build_scripts/libvpx/configure.sh.patch	2011-06-16 19:46:07 UTC (rev 7288)
+++ branches/avidemux_2.5_branch_gruntster/platforms/windows/build_scripts/libvpx/configure.sh.patch	2011-06-16 19:51:50 UTC (rev 7289)
@@ -1,6 +1,6 @@
---- build/make/configure.sh.orig	2010-10-28 14:14:14 +0100
-+++ build/make/configure.sh	2010-11-27 11:45:42 +0000
-@@ -877,8 +877,12 @@
+--- build/make/configure.sh.old	2011-05-08 01:11:53 +0100
++++ build/make/configure.sh	2011-05-08 01:16:09 +0100
+@@ -900,8 +900,12 @@
          [ "${AS##*/}" = nasm ] && add_asflags -Ox
          AS_SFX=.asm
          case  ${tgt_os} in
@@ -8,10 +8,10 @@
 -                add_asflags -f win${bits}
 +            win32)
 +                add_asflags -f win32
-+                enabled debug && add_asflags -g dwarf2
++                enabled debug && add_asflags -g cv8
 +            ;;
-+			win64)
++            win64)
 +                add_asflags -f x64
-                 enabled debug && add_asflags -g dwarf2
+                 enabled debug && add_asflags -g cv8
              ;;
              linux*|solaris*)

Modified: branches/avidemux_2.5_branch_gruntster/platforms/windows/build_scripts/nspr/Perform Build.bat
===================================================================
--- branches/avidemux_2.5_branch_gruntster/platforms/windows/build_scripts/nspr/Perform Build.bat	2011-06-16 19:46:07 UTC (rev 7288)
+++ branches/avidemux_2.5_branch_gruntster/platforms/windows/build_scripts/nspr/Perform Build.bat	2011-06-16 19:51:50 UTC (rev 7289)
@@ -20,15 +20,15 @@
 call "../Set Common Environment Variables"
 if errorlevel 1 goto end
 
-set package=nspr-4.8.6.tar.gz
-set sourceFolder=nspr-4.8.6-%BuildBits%
-set tarFolder=nspr-4.8.6
+set package=nspr-4.8.8.tar.gz
+set sourceFolder=nspr-4.8.8-%BuildBits%
+set tarFolder=nspr-4.8.8
 set curDir=%CD%
 
 if not exist %package% (
 	echo.
 	echo Downloading
-	wget ftp://ftp.mozilla.org/pub/mozilla.org/nspr/releases/v4.8.6/src/%package%
+	wget ftp://ftp.mozilla.org/pub/mozilla.org/nspr/releases/v4.8.8/src/%package%
 )
 
 if errorlevel 1 goto end
@@ -51,6 +51,10 @@
 )
 
 echo.
+echo Patching
+patch -p0 -i "%curDir%\configure.patch"
+
+echo.
 echo Configuring
 cd mozilla\nsprpub
 sh ./configure --prefix="%usrLocalDir%" --enable-strip --enable-win32-target=WIN95 --enable-optimize --disable-debug

Added: branches/avidemux_2.5_branch_gruntster/platforms/windows/build_scripts/nspr/configure.patch
===================================================================
--- branches/avidemux_2.5_branch_gruntster/platforms/windows/build_scripts/nspr/configure.patch	                        (rev 0)
+++ branches/avidemux_2.5_branch_gruntster/platforms/windows/build_scripts/nspr/configure.patch	2011-06-16 19:51:50 UTC (rev 7289)
@@ -0,0 +1,11 @@
+--- mozilla/nsprpub/configure.orig	2011-05-04 23:26:56 +0100
++++ mozilla/nsprpub/configure	2011-05-22 11:32:30 +0100
+@@ -4206,8 +4206,6 @@
+     RESOLVE_LINK_SYMBOLS=1
+ 
+     if test -n "$GNU_CC"; then
+-        CC="$CC -mno-cygwin"
+-        CXX="$CXX -mno-cygwin"
+         DLL_SUFFIX=dll
+         MKSHLIB='$(CC) -shared -Wl,--export-all-symbols -Wl,--out-implib -Wl,$(IMPORT_LIBRARY) $(DLLBASE) -o $(subst $(OBJDIR)/,,$(SHARED_LIBRARY))'
+         RC=$WINDRES

Modified: branches/avidemux_2.5_branch_gruntster/platforms/windows/build_scripts/x264/Perform Build.bat
===================================================================
--- branches/avidemux_2.5_branch_gruntster/platforms/windows/build_scripts/x264/Perform Build.bat	2011-06-16 19:46:07 UTC (rev 7288)
+++ branches/avidemux_2.5_branch_gruntster/platforms/windows/build_scripts/x264/Perform Build.bat	2011-06-16 19:51:50 UTC (rev 7289)
@@ -29,7 +29,7 @@
 if errorlevel 1 goto end
 
 echo Downloading from git
-git clone git://git.videolan.org/x264.git %sourceFolder%
+call git clone git://git.videolan.org/x264.git %sourceFolder%
 if errorlevel 1 goto end
 
 cd "%devDir%/%sourceFolder%"

Modified: branches/avidemux_2.5_branch_gruntster/platforms/windows/build_scripts/xvid/Perform Build.bat
===================================================================
--- branches/avidemux_2.5_branch_gruntster/platforms/windows/build_scripts/xvid/Perform Build.bat	2011-06-16 19:46:07 UTC (rev 7288)
+++ branches/avidemux_2.5_branch_gruntster/platforms/windows/build_scripts/xvid/Perform Build.bat	2011-06-16 19:51:50 UTC (rev 7289)
@@ -17,8 +17,8 @@
 call "../Set Common Environment Variables"
 if errorlevel 1 goto end
 
-set package=xvidcore-1.2.2.tar.gz
-set sourceFolder=xvidcore-1.2.2-%BuildBits%
+set package=xvidcore-1.3.2.tar.gz
+set sourceFolder=xvidcore-1.3.2-%BuildBits%
 set curDir=%CD%
 
 if not exist %package% (

Modified: branches/avidemux_2.5_branch_gruntster/platforms/windows/build_scripts/xvid/configure.patch
===================================================================
--- branches/avidemux_2.5_branch_gruntster/platforms/windows/build_scripts/xvid/configure.patch	2011-06-16 19:46:07 UTC (rev 7288)
+++ branches/avidemux_2.5_branch_gruntster/platforms/windows/build_scripts/xvid/configure.patch	2011-06-16 19:51:50 UTC (rev 7289)
@@ -1,11 +1,12 @@
---- build/generic/configure.orig	2009-05-28 18:13:31 +0100
-+++ build/generic/configure	2010-11-27 10:25:35 +0000
-@@ -1319,7 +1319,7 @@
- API_MAJOR="4"
- API_MINOR="2"
- 
--minimum_yasm_minor_version=8
-+minimum_yasm_minor_version=1
- minimum_nasm_minor_version=0
- minimum_nasm_major_version=2
- nasm_prog="nasm"
+--- build/generic/configure.orig	2011-03-17 14:31:52 +0000
++++ build/generic/configure	2011-05-21 16:22:55 +0100
+@@ -4325,8 +4325,7 @@
+ $as_echo "ok" >&6; }
+ 	STATIC_LIB="xvidcore.\$(STATIC_EXTENSION)"
+ 	SHARED_LIB="xvidcore.\$(SHARED_EXTENSION)"
+-	SPECIFIC_LDFLAGS="-mno-cygwin -shared -Wl,--dll,--out-implib,\$@.a libxvidcore.def"
+-	SPECIFIC_CFLAGS="-mno-cygwin"
++	SPECIFIC_LDFLAGS="-shared -Wl,--dll,--out-implib,\$@.a libxvidcore.def"
+ 	;;
+      darwin*|raphsody*)
+ 	STATIC_LIB="libxvidcore.\$(STATIC_EXTENSION)"



From gruntster at mail.berlios.de  Thu Jun 16 21:55:20 2011
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Thu, 16 Jun 2011 21:55:20 +0200
Subject: [Avidemux-svn-commit] r7290 -
	branches/avidemux_2.5_branch_gruntster/avidemux
Message-ID: <20110616195521.1BEFC481297@sheep.berlios.de>

Author: gruntster
Date: 2011-06-16 21:55:20 +0200 (Thu, 16 Jun 2011)
New Revision: 7290

Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/CMakeLists.txt
Log:
[mswin] gcc 4.6 fix

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/CMakeLists.txt	2011-06-16 19:51:50 UTC (rev 7289)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/CMakeLists.txt	2011-06-16 19:55:20 UTC (rev 7290)
@@ -428,11 +428,6 @@
 ###########################################
 IF (WIN32)
 	ADD_ADMLIB_ALL_TARGETS(ADM_osSupport)
-
-	IF (MINGW)
-		ADD_LIB_ALL_TARGETS(-mno-cygwin)
-	ENDIF (MINGW)
-
 	ADD_LIB_ALL_TARGETS(winmm)
 
 	ADD_TARGET_LDFLAGS(avidemux2_cli "-Wl,-subsystem,console")
@@ -458,7 +453,6 @@
 ###########################################
 SET(ADM_EXES avidemux2_cli)
 
-
 IF (ADM_UI_QT4)
 	SET(ADM_EXES ${ADM_EXES} avidemux2_qt4)
 



From gruntster at mail.berlios.de  Thu Jun 16 22:01:16 2011
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Thu, 16 Jun 2011 22:01:16 +0200
Subject: [Avidemux-svn-commit] r7291 -
	branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script
Message-ID: <20110616200116.414F4481297@sheep.berlios.de>

Author: gruntster
Date: 2011-06-16 22:01:16 +0200 (Thu, 16 Jun 2011)
New Revision: 7291

Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSFunctions.cpp
Log:
[mswin] gcc 4.6 fix

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSFunctions.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSFunctions.cpp	2011-06-16 19:55:20 UTC (rev 7290)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSFunctions.cpp	2011-06-16 20:01:16 UTC (rev 7291)
@@ -10,6 +10,8 @@
 //
 //
 #include "config.h"
+#include "ADM_default.h"
+
 #include <stdlib.h>
 #include <unistd.h>
 #include <sys/types.h>
@@ -26,7 +28,6 @@
 #include <string>
 #include "ADM_JSAvidemux.h"
 #include "ADM_JSGlobal.h"
-#include "ADM_default.h"
 #include "DIA_coreToolkit.h"
 #include "ADM_editor/ADM_outputfmt.h"
 #include "ADM_audiofilter/audioeng_buildfilters.h"



From gruntster at mail.berlios.de  Thu Jun 16 22:17:53 2011
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Thu, 16 Jun 2011 22:17:53 +0200
Subject: [Avidemux-svn-commit] r7292 -
	branches/avidemux_2.5_branch_gruntster/avidemux/ADM_core/src
Message-ID: <20110616201754.01668481297@sheep.berlios.de>

Author: gruntster
Date: 2011-06-16 22:17:53 +0200 (Thu, 16 Jun 2011)
New Revision: 7292

Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_core/src/ADM_win32.cpp
Log:
[mswin] gcc 4.6 fix (GPF on startup)

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_core/src/ADM_win32.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_core/src/ADM_win32.cpp	2011-06-16 20:01:16 UTC (rev 7291)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_core/src/ADM_win32.cpp	2011-06-16 20:17:53 UTC (rev 7292)
@@ -387,7 +387,7 @@
 
 	if (hKernel)
 	{
-		typedef bool (*funcIsWow64Process)(void*, bool*);  
+		typedef bool (__stdcall *funcIsWow64Process)(void*, bool*);  
 
 	    funcIsWow64Process pIsWow64Process = (funcIsWow64Process)GetProcAddress(hKernel, "IsWow64Process"); 
 



From mean at mail.berlios.de  Fri Jun 17 07:52:50 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Fri, 17 Jun 2011 07:52:50 +0200
Subject: [Avidemux-svn-commit] r7293 -
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/x264
Message-ID: <20110617055251.1FCCB481342@sheep.berlios.de>

Author: mean
Date: 2011-06-17 07:52:50 +0200 (Fri, 17 Jun 2011)
New Revision: 7293

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/x264/CMakeLists.txt
Log:
[x264] Fix cmake (thanks hinterwaeldler)

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/x264/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/x264/CMakeLists.txt	2011-06-16 20:17:53 UTC (rev 7292)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoEncoder/x264/CMakeLists.txt	2011-06-17 05:52:50 UTC (rev 7293)
@@ -27,7 +27,7 @@
   #-----------------------/QT4 VERSION---------------------
   #-----------------------GTK or CLI VERSION---------------------
   if((DO_GTK) OR (DO_CLI))
-    ADD_VIDEO_ENCODER_(ADM_ve_x264_other   ADM_x264_noui.cpp ${x264_SRCS})
+    ADD_VIDEO_ENCODER(ADM_ve_x264_other   ADM_x264_noui.cpp ${x264_SRCS})
     TARGET_LINK_LIBRARIES(ADM_ve_x264_other x264 )
     INIT_VIDEO_ENCODER(ADM_ve_x264_other)
     INSTALL_VIDEO_ENCODER(ADM_ve_x264_other)



From mean at mail.berlios.de  Fri Jun 17 07:52:52 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Fri, 17 Jun 2011 07:52:52 +0200
Subject: [Avidemux-svn-commit] r7294 -
	branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor
Message-ID: <20110617055252.3A080481342@sheep.berlios.de>

Author: mean
Date: 2011-06-17 07:52:52 +0200 (Fri, 17 Jun 2011)
New Revision: 7294

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.cpp
Log:
[editor] Workaround a design flaw, where time start is assumed to = PTS of first frame. IT makes problem when computing DTS from PTS

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.cpp	2011-06-17 05:52:50 UTC (rev 7293)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_segment.cpp	2011-06-17 05:52:52 UTC (rev 7294)
@@ -272,9 +272,24 @@
     {
         _VIDEOS *vid=getRefVideo(segments[i]._reference);
         _SEGMENT *seg=getSegment(i);
+        vidHeader *demuxer=vid->_aviheader;
+    
 
         uint64_t pts,dts;
         pts=seg->_refStartTimeUs;
+        // Special case : If pts=0 it might mean beginning of seg i, but the PTS might be not 0
+        // in such a case the DTS is wrong
+        if(!pts)
+        {
+            uint64_t pts2,dts2;
+            demuxer->getPtsDts(0,&pts2,&dts2);
+            if(pts2!=ADM_NO_PTS) 
+            {
+                ADM_info("Using pts2=%s to get dts, as this video does not start at zero\n",ADM_us2plain(pts2));
+                pts=pts2;
+            }
+            
+        }
         dtsFromPts(seg->_reference,pts,&dts);
         seg->_refStartDts=dts;
     }



From gruntster at mail.berlios.de  Fri Jun 17 15:02:41 2011
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Fri, 17 Jun 2011 15:02:41 +0200
Subject: [Avidemux-svn-commit] r7295 -
	branches/avidemux_2.5_branch_gruntster/avidemux/ADM_core/src
Message-ID: <20110617130242.23F2F480F06@sheep.berlios.de>

Author: gruntster
Date: 2011-06-17 15:02:41 +0200 (Fri, 17 Jun 2011)
New Revision: 7295

Added:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_core/src/ADM_crashdump_apple.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_core/src/ADM_crashdump_mswin.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_core/src/ADM_crashdump_unix.cpp
Removed:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_core/src/ADM_crashdump.cpp
Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_core/src/CMakeLists.txt
Log:
[log] separate files for backtrace by platform

Deleted: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_core/src/ADM_crashdump.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_core/src/ADM_crashdump.cpp	2011-06-17 05:52:52 UTC (rev 7294)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_core/src/ADM_crashdump.cpp	2011-06-17 13:02:41 UTC (rev 7295)
@@ -1,363 +0,0 @@
-/***************************************************************************
-  Try to display interesting crash dump
-
-    copyright            : (C) 2007 by mean, (C) 2007 Gruntster
-    email                : fixounet at free.fr
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <stdarg.h>
-#include <string.h>
-#include <unistd.h>
-#include <math.h>
-
-#ifdef __MINGW32__
-#include <windows.h>
-#include <excpt.h>
-#include <imagehlp.h>
-#else
-#include <cxxabi.h>
-#endif
-
-#include "ADM_default.h"
-
-// Our callback to give UI formatted informations....
-static ADM_saveFunction *mysaveFunction=NULL;
-static ADM_fatalFunction *myFatalFunction=NULL;
-/**
-        \fn ADM_setCrashHook
-        \brief install crash handlers (save + display)
-*/
-void ADM_setCrashHook(ADM_saveFunction *save, ADM_fatalFunction *fatal)
-{
-        mysaveFunction=save;
-        myFatalFunction=fatal;
-}
-
-extern char *ADM_getBaseDir(void);
-extern void A_parseECMAScript(const char *name);
-
-#ifdef __APPLE__
-void installSigHandler() {}
-
-void ADM_backTrack(const char *info,int lineno,const char *file)
-{
-	char bfr[1024];
-
-	if (mysaveFunction)
-		mysaveFunction();
-
-	snprintf(bfr,1024,"%s\n file %s, line %d\n", info, file, lineno);
-
-	if(myFatalFunction)
-		myFatalFunction("Crash",bfr);
-
-	exit(-1);
-}
-#elif defined(__MINGW32__)
-typedef struct STACK_FRAME
-{
-    STACK_FRAME* ebp;	// address of the calling function frame
-    uint8_t* retAddr;	// return address
-    uint32_t param[0];	// parameter list (could be empty)
-} STACK_FRAME;
-
-static void dumpFrame(void* processId, void* frameAddr)
-{
-#ifdef ADM_CPU_X86_64
-#define ARCH_DWORD DWORD64
-#else
-#define ARCH_DWORD DWORD
-#endif
-
-	MEMORY_BASIC_INFORMATION mbi;
-	char moduleName[MAX_PATH];
-	HMODULE moduleAddr;
-	ARCH_DWORD symDisplacement;
-	IMAGEHLP_SYMBOL* pSymbol;
-
-	if (VirtualQuery(frameAddr, &mbi, sizeof(mbi)))
-	{
-		moduleName[0] = 0;
-		moduleAddr = (HMODULE)mbi.AllocationBase;
-		
-		GetModuleFileName(moduleAddr, moduleName, MAX_PATH);
-
-		printf("%s(", moduleName);
-
-		if (SymGetSymFromAddr(processId, (ARCH_DWORD)frameAddr, &symDisplacement, pSymbol))
-			printf("%s", pSymbol->Name);
-		else
-			printf("<unknown>");
-
-		printf("+0x%X) [0x%08X]\n", (ARCH_DWORD)frameAddr - (ARCH_DWORD)moduleAddr, frameAddr);
-
-		fflush(stdout);
-	}
-}
-	
-static void dumpExceptionInfo(void* processId, struct _EXCEPTION_RECORD* pExceptionRec, struct _CONTEXT* pContextRecord)
-{
-	printf("\n*********** EXCEPTION **************\n");
-	printf("Registers:\n");
-#ifdef ADM_CPU_X86_64
-	printf("RAX: %08X  RBX: %08X  RCX: %08X  RDX: %08X  RSI: %08X  RDI: %08X  RSP: %08X  RBP: %08X\n", pContextRecord->Rax, pContextRecord->Rbx, pContextRecord->Rcx, pContextRecord->Rdx, pContextRecord->Rsi, pContextRecord->Rdi, pContextRecord->Rsp, pContextRecord->Rbp);
-	printf("R8: %08X  R9: %08X  R10: %08X  R11: %08X  R12: %08X  R13: %08X  R14: %08X  R15: %08X\n", pContextRecord->R8, pContextRecord->R9, pContextRecord->R10, pContextRecord->R11, pContextRecord->R12, pContextRecord->R13, pContextRecord->R14, pContextRecord->R15);
-	printf("RIP: %08X  EFlags: %08X\n\n", pContextRecord->Rip, pContextRecord->EFlags);
-#else
-	printf("EAX: %08X  EBX: %08X  ECX: %08X  EDX: %08X  ESI: %08X\n", pContextRecord->Eax, pContextRecord->Ebx, pContextRecord->Ecx, pContextRecord->Edx, pContextRecord->Esi);
-	printf("EDI: %08X  ESP: %08X  EBP: %08X  EIP: %08X  EFlags: %08X\n\n", pContextRecord->Edi, pContextRecord->Esp, pContextRecord->Ebp, pContextRecord->Eip, pContextRecord->EFlags);
-#endif
-
-	printf("Exception Code: ");
-
-	switch (pExceptionRec->ExceptionCode)
-	{
-		case EXCEPTION_ACCESS_VIOLATION:
-			printf("EXCEPTION_ACCESS_VIOLATION");
-			break;
-		case EXCEPTION_ARRAY_BOUNDS_EXCEEDED:
-			printf("EXCEPTION_ARRAY_BOUNDS_EXCEEDED");
-			break;
-		case EXCEPTION_BREAKPOINT:
-			printf("EXCEPTION_BREAKPOINT");
-			break;
-		case EXCEPTION_DATATYPE_MISALIGNMENT:
-			printf("EXCEPTION_DATATYPE_MISALIGNMENT");
-			break;
-		case EXCEPTION_FLT_DENORMAL_OPERAND:
-			printf("EXCEPTION_FLT_DENORMAL_OPERAND");
-			break;
-		case EXCEPTION_FLT_DIVIDE_BY_ZERO:
-			printf("EXCEPTION_FLT_DIVIDE_BY_ZERO");
-			break;
-		case EXCEPTION_FLT_INEXACT_RESULT:
-			printf("EXCEPTION_FLT_INEXACT_RESULT");
-			break;
-		case EXCEPTION_FLT_INVALID_OPERATION:
-			printf("EXCEPTION_FLT_INVALID_OPERATION");
-			break;
-		case EXCEPTION_FLT_OVERFLOW:
-			printf("EXCEPTION_FLT_OVERFLOW");
-			break;
-		case EXCEPTION_FLT_STACK_CHECK:
-			printf("EXCEPTION_FLT_STACK_CHECK");
-			break;
-		case EXCEPTION_FLT_UNDERFLOW:
-			printf("EXCEPTION_FLT_UNDERFLOW");
-			break;
-		case EXCEPTION_ILLEGAL_INSTRUCTION:
-			printf("EXCEPTION_ILLEGAL_INSTRUCTION");
-			break;
-		case EXCEPTION_IN_PAGE_ERROR:
-			printf("EXCEPTION_IN_PAGE_ERROR");
-			break;
-		case EXCEPTION_INT_DIVIDE_BY_ZERO:
-			printf("EXCEPTION_INT_DIVIDE_BY_ZERO");
-			break;
-		case EXCEPTION_INT_OVERFLOW:
-			printf("EXCEPTION_INT_OVERFLOW");
-			break;
-		case EXCEPTION_INVALID_DISPOSITION:
-			printf("EXCEPTION_INVALID_DISPOSITION");
-			break;
-		case EXCEPTION_NONCONTINUABLE_EXCEPTION:
-			printf("EXCEPTION_NONCONTINUABLE_EXCEPTION");
-			break;
-		case EXCEPTION_PRIV_INSTRUCTION:
-			printf("EXCEPTION_PRIV_INSTRUCTION");
-			break;
-		case EXCEPTION_SINGLE_STEP:
-			printf("EXCEPTION_SINGLE_STEP");
-			break;
-		case EXCEPTION_STACK_OVERFLOW:
-			printf("EXCEPTION_STACK_OVERFLOW");
-			break;
-		default:
-			printf("UNKNOWN");
-	}
-	
-	printf(" (%08X)\n", pExceptionRec->ExceptionCode);
-	printf("Exception Flags: %08X\n", pExceptionRec->ExceptionFlags);
-
-	printf("\nOrigin:\n");
-
-#ifdef ADM_CPU_X86_64
-	dumpFrame(processId, (void*)pContextRecord->Rip);
-#else
-	dumpFrame(processId, (void*)pContextRecord->Eip);
-#endif
-
-	printf("*********** EXCEPTION **************\n");
-	fflush(stdout);
-}
-
-extern "C"
-{
-void dumpBackTrace(void* processId)
-{
-	if (!processId)
-		processId = GetCurrentProcess();
-
-	const int maxAddrCount = 32;
-
-	printf("\n*********** BACKTRACE **************\n");
-
-	// Get frame address using builtin GCC function.
-	STACK_FRAME* stackFrame = (STACK_FRAME*)__builtin_frame_address(0);
-
-    for (int retAddrCount = 0; (retAddrCount < maxAddrCount) && !IsBadReadPtr(stackFrame, sizeof(STACK_FRAME)) && !IsBadCodePtr(FARPROC(stackFrame->retAddr)); retAddrCount++, stackFrame = stackFrame->ebp)
-    {
-		printf("Frame %2d: ", retAddrCount);
-		dumpFrame(processId, stackFrame->retAddr);
-		fflush(stdout);
-    }
-
-	printf("*********** BACKTRACE **************\n\n");
-}
-}
-
-void ADM_backTrack(const char *info,int lineno,const char *file)
-{	
-	fflush(stderr);
-	fflush(stdout);
-
-	if (mysaveFunction)
-		mysaveFunction();
-
-	if (myFatalFunction)
-		myFatalFunction("Crash", "Press OK to build crash info");
-
-	void* currentProcessId = GetCurrentProcess();
-
-	SymInitialize(currentProcessId, NULL, TRUE);
-	dumpBackTrace(currentProcessId);
-	SymCleanup(currentProcessId);
-
-	printf("Assert failed at file %s, line %d\n\n",file,lineno);
-
-	exit(-1);
-}
-
-EXCEPTION_DISPOSITION exceptionHandler(struct _EXCEPTION_RECORD* pExceptionRec, void* pEstablisherFrame, struct _CONTEXT* pContextRecord, void* pDispatcherContext)
-{
-	fflush(stderr);
-	fflush(stdout);
-	static int running=0;
-
-	if(running)
-		exit(1);
-
-	running=1;
-
-	if (mysaveFunction)
-		mysaveFunction();
-
-	if (myFatalFunction)
-		myFatalFunction("Crash", "Press OK to build crash info");
-
-	void* currentProcessId = GetCurrentProcess();
-
-	SymInitialize(currentProcessId, NULL, TRUE);
-
-	dumpExceptionInfo(currentProcessId, pExceptionRec, pContextRecord);
-	fflush(stdout);
-	dumpBackTrace(currentProcessId);
-
-	SymCleanup(currentProcessId);
-
-	exit(1);
-}
-#else
-#include <signal.h>
-
-#ifndef __CYGWIN__
-#include <execinfo.h>
-#endif
-
-void sig_segfault_handler(int signo);
-void installSigHandler()
-{
-    signal(11, sig_segfault_handler); // show stacktrace on default
-}
-
-
-/**
-      \fn sig_segfault_handler
-      \brief our segfault handler
-
-*/
-void sig_segfault_handler(int signo)
-{
-     
-     static int running=0;
-      if(running) 
-      {
-        signo=0;
-        exit(1);
-      }
-      running=0; 
-      ADM_backTrack("Segfault",0,"??");
-}
-
-void ADM_backTrack(const char *info,int lineno,const char *file)
-{
-	char wholeStuff[2048];
-    char buffer[2048];
-    char in[2048];
-	void *stack[20];
-	char **functions;
-	int count, i;
-
-	wholeStuff[0]=0;
-
-	if(mysaveFunction)
-		mysaveFunction();
-
-#ifndef __CYGWIN__
-	printf("\n*********** BACKTRACK **************\n");
-
-	count = backtrace(stack, 20);
-	functions = backtrace_symbols(stack, count);
-	sprintf(wholeStuff,"%s\n at line %d, file %s",info,lineno,file);
-    int status;
-    size_t size=2047;
-    // it looks like that xxxx (functionName+0x***) XXXX
-	for (i=0; i < count; i++) 
-	{
-        char *s=strstr(functions[i],"(");
-        buffer[0]=0;
-        if(s && strstr(s+1,"+"))
-        {
-            strcpy(in,s+1);
-            char *e=strstr(in,"+");
-            *e=0;                
-            __cxxabiv1::__cxa_demangle(in,buffer,&size,&status);
-            if(status) strcpy(buffer,in);
-        }else       
-            strcpy(buffer,functions[i]);
-        printf("%s:%d:<%s>:%d\n",functions[i],i,buffer,status);
-		strcat(wholeStuff,buffer);
-		strcat(wholeStuff,"\n");
-	}
-
-	printf("*********** BACKTRACK **************\n");
-
-	if(myFatalFunction)
-		myFatalFunction("Crash", wholeStuff); // FIXME
-#endif	//__CYGWIN__
-
-	exit(-1); // _exit(1) ???
-}
-#endif
-//EOF

Added: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_core/src/ADM_crashdump_apple.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_core/src/ADM_crashdump_apple.cpp	                        (rev 0)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_core/src/ADM_crashdump_apple.cpp	2011-06-17 13:02:41 UTC (rev 7295)
@@ -0,0 +1,54 @@
+/***************************************************************************
+  Try to display interesting crash dump
+
+    copyright            : (C) 2007 by mean, (C) 2007 Gruntster
+    email                : fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdarg.h>
+#include <string.h>
+#include <unistd.h>
+#include <cxxabi.h>
+
+#include "ADM_default.h"
+
+// Our callback to give UI formatted informations....
+static ADM_saveFunction *mysaveFunction=NULL;
+static ADM_fatalFunction *myFatalFunction=NULL;
+/**
+        \fn ADM_setCrashHook
+        \brief install crash handlers (save + display)
+*/
+void ADM_setCrashHook(ADM_saveFunction *save, ADM_fatalFunction *fatal)
+{
+        mysaveFunction=save;
+        myFatalFunction=fatal;
+}
+
+void installSigHandler() {}
+
+void ADM_backTrack(const char *info,int lineno,const char *file)
+{
+	char bfr[1024];
+
+	if (mysaveFunction)
+		mysaveFunction();
+
+	snprintf(bfr,1024,"%s\n file %s, line %d\n", info, file, lineno);
+
+	if(myFatalFunction)
+		myFatalFunction("Crash",bfr);
+
+	exit(-1);
+}

Added: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_core/src/ADM_crashdump_mswin.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_core/src/ADM_crashdump_mswin.cpp	                        (rev 0)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_core/src/ADM_crashdump_mswin.cpp	2011-06-17 13:02:41 UTC (rev 7295)
@@ -0,0 +1,247 @@
+/***************************************************************************
+  Try to display interesting crash dump
+
+    copyright            : (C) 2007 by mean, (C) 2007 Gruntster
+    email                : fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include <windows.h>
+#include <imagehlp.h>
+
+#include "ADM_default.h"
+
+// Our callback to give UI formatted informations....
+static ADM_saveFunction *mysaveFunction=NULL;
+static ADM_fatalFunction *myFatalFunction=NULL;
+/**
+        \fn ADM_setCrashHook
+        \brief install crash handlers (save + display)
+*/
+void ADM_setCrashHook(ADM_saveFunction *save, ADM_fatalFunction *fatal)
+{
+        mysaveFunction=save;
+        myFatalFunction=fatal;
+}
+
+typedef struct STACK_FRAME
+{
+    STACK_FRAME* ebp;	// address of the calling function frame
+    uint8_t* retAddr;	// return address
+    uint32_t param[0];	// parameter list (could be empty)
+} STACK_FRAME;
+
+static void dumpFrame(void* processId, void* frameAddr)
+{
+#ifdef ADM_CPU_X86_64
+#define ARCH_DWORD DWORD64
+#else
+#define ARCH_DWORD DWORD
+#endif
+
+	MEMORY_BASIC_INFORMATION mbi;
+	char moduleName[MAX_PATH];
+	HMODULE moduleAddr;
+	ARCH_DWORD symDisplacement;
+	IMAGEHLP_SYMBOL* pSymbol;
+
+	if (VirtualQuery(frameAddr, &mbi, sizeof(mbi)))
+	{
+		moduleName[0] = 0;
+		moduleAddr = (HMODULE)mbi.AllocationBase;
+		
+		GetModuleFileName(moduleAddr, moduleName, MAX_PATH);
+
+		printf("%s(", moduleName);
+
+		if (SymGetSymFromAddr(processId, (ARCH_DWORD)frameAddr, &symDisplacement, pSymbol))
+			printf("%s", pSymbol->Name);
+		else
+			printf("<unknown>");
+
+		printf("+0x%X) [0x%08X]\n", (ARCH_DWORD)frameAddr - (ARCH_DWORD)moduleAddr, frameAddr);
+
+		fflush(stdout);
+	}
+}
+	
+static void dumpExceptionInfo(void* processId, struct _EXCEPTION_RECORD* pExceptionRec, struct _CONTEXT* pContextRecord)
+{
+	printf("\n*********** EXCEPTION **************\n");
+	printf("Registers:\n");
+#ifdef ADM_CPU_X86_64
+	printf("RAX: %08X  RBX: %08X  RCX: %08X  RDX: %08X  RSI: %08X  RDI: %08X  RSP: %08X  RBP: %08X\n", pContextRecord->Rax, pContextRecord->Rbx, pContextRecord->Rcx, pContextRecord->Rdx, pContextRecord->Rsi, pContextRecord->Rdi, pContextRecord->Rsp, pContextRecord->Rbp);
+	printf("R8: %08X  R9: %08X  R10: %08X  R11: %08X  R12: %08X  R13: %08X  R14: %08X  R15: %08X\n", pContextRecord->R8, pContextRecord->R9, pContextRecord->R10, pContextRecord->R11, pContextRecord->R12, pContextRecord->R13, pContextRecord->R14, pContextRecord->R15);
+	printf("RIP: %08X  EFlags: %08X\n\n", pContextRecord->Rip, pContextRecord->EFlags);
+#else
+	printf("EAX: %08X  EBX: %08X  ECX: %08X  EDX: %08X  ESI: %08X\n", pContextRecord->Eax, pContextRecord->Ebx, pContextRecord->Ecx, pContextRecord->Edx, pContextRecord->Esi);
+	printf("EDI: %08X  ESP: %08X  EBP: %08X  EIP: %08X  EFlags: %08X\n\n", pContextRecord->Edi, pContextRecord->Esp, pContextRecord->Ebp, pContextRecord->Eip, pContextRecord->EFlags);
+#endif
+
+	printf("Exception Code: ");
+
+	switch (pExceptionRec->ExceptionCode)
+	{
+		case EXCEPTION_ACCESS_VIOLATION:
+			printf("EXCEPTION_ACCESS_VIOLATION");
+			break;
+		case EXCEPTION_ARRAY_BOUNDS_EXCEEDED:
+			printf("EXCEPTION_ARRAY_BOUNDS_EXCEEDED");
+			break;
+		case EXCEPTION_BREAKPOINT:
+			printf("EXCEPTION_BREAKPOINT");
+			break;
+		case EXCEPTION_DATATYPE_MISALIGNMENT:
+			printf("EXCEPTION_DATATYPE_MISALIGNMENT");
+			break;
+		case EXCEPTION_FLT_DENORMAL_OPERAND:
+			printf("EXCEPTION_FLT_DENORMAL_OPERAND");
+			break;
+		case EXCEPTION_FLT_DIVIDE_BY_ZERO:
+			printf("EXCEPTION_FLT_DIVIDE_BY_ZERO");
+			break;
+		case EXCEPTION_FLT_INEXACT_RESULT:
+			printf("EXCEPTION_FLT_INEXACT_RESULT");
+			break;
+		case EXCEPTION_FLT_INVALID_OPERATION:
+			printf("EXCEPTION_FLT_INVALID_OPERATION");
+			break;
+		case EXCEPTION_FLT_OVERFLOW:
+			printf("EXCEPTION_FLT_OVERFLOW");
+			break;
+		case EXCEPTION_FLT_STACK_CHECK:
+			printf("EXCEPTION_FLT_STACK_CHECK");
+			break;
+		case EXCEPTION_FLT_UNDERFLOW:
+			printf("EXCEPTION_FLT_UNDERFLOW");
+			break;
+		case EXCEPTION_ILLEGAL_INSTRUCTION:
+			printf("EXCEPTION_ILLEGAL_INSTRUCTION");
+			break;
+		case EXCEPTION_IN_PAGE_ERROR:
+			printf("EXCEPTION_IN_PAGE_ERROR");
+			break;
+		case EXCEPTION_INT_DIVIDE_BY_ZERO:
+			printf("EXCEPTION_INT_DIVIDE_BY_ZERO");
+			break;
+		case EXCEPTION_INT_OVERFLOW:
+			printf("EXCEPTION_INT_OVERFLOW");
+			break;
+		case EXCEPTION_INVALID_DISPOSITION:
+			printf("EXCEPTION_INVALID_DISPOSITION");
+			break;
+		case EXCEPTION_NONCONTINUABLE_EXCEPTION:
+			printf("EXCEPTION_NONCONTINUABLE_EXCEPTION");
+			break;
+		case EXCEPTION_PRIV_INSTRUCTION:
+			printf("EXCEPTION_PRIV_INSTRUCTION");
+			break;
+		case EXCEPTION_SINGLE_STEP:
+			printf("EXCEPTION_SINGLE_STEP");
+			break;
+		case EXCEPTION_STACK_OVERFLOW:
+			printf("EXCEPTION_STACK_OVERFLOW");
+			break;
+		default:
+			printf("UNKNOWN");
+	}
+	
+	printf(" (%08X)\n", pExceptionRec->ExceptionCode);
+	printf("Exception Flags: %08X\n", pExceptionRec->ExceptionFlags);
+
+	printf("\nOrigin:\n");
+
+#ifdef ADM_CPU_X86_64
+	dumpFrame(processId, (void*)pContextRecord->Rip);
+#else
+	dumpFrame(processId, (void*)pContextRecord->Eip);
+#endif
+
+	printf("*********** EXCEPTION **************\n");
+	fflush(stdout);
+}
+
+extern "C"
+{
+void dumpBackTrace(void* processId)
+{
+	if (!processId)
+		processId = GetCurrentProcess();
+
+	const int maxAddrCount = 32;
+
+	printf("\n*********** BACKTRACE **************\n");
+
+	// Get frame address using builtin GCC function.
+	STACK_FRAME* stackFrame = (STACK_FRAME*)__builtin_frame_address(0);
+
+    for (int retAddrCount = 0; (retAddrCount < maxAddrCount) && !IsBadReadPtr(stackFrame, sizeof(STACK_FRAME)) && !IsBadCodePtr(FARPROC(stackFrame->retAddr)); retAddrCount++, stackFrame = stackFrame->ebp)
+    {
+		printf("Frame %2d: ", retAddrCount);
+		dumpFrame(processId, stackFrame->retAddr);
+		fflush(stdout);
+    }
+
+	printf("*********** BACKTRACE **************\n\n");
+}
+}
+
+void ADM_backTrack(const char *info,int lineno,const char *file)
+{	
+	fflush(stderr);
+	fflush(stdout);
+
+	if (mysaveFunction)
+		mysaveFunction();
+
+	if (myFatalFunction)
+		myFatalFunction("Crash", "Press OK to build crash info");
+
+	void* currentProcessId = GetCurrentProcess();
+
+	SymInitialize(currentProcessId, NULL, TRUE);
+	dumpBackTrace(currentProcessId);
+	SymCleanup(currentProcessId);
+
+	printf("Assert failed at file %s, line %d\n\n",file,lineno);
+
+	exit(-1);
+}
+
+EXCEPTION_DISPOSITION exceptionHandler(struct _EXCEPTION_RECORD* pExceptionRec, void* pEstablisherFrame, struct _CONTEXT* pContextRecord, void* pDispatcherContext)
+{
+	fflush(stderr);
+	fflush(stdout);
+	static int running=0;
+
+	if(running)
+		exit(1);
+
+	running=1;
+
+	if (mysaveFunction)
+		mysaveFunction();
+
+	if (myFatalFunction)
+		myFatalFunction("Crash", "Press OK to build crash info");
+
+	void* currentProcessId = GetCurrentProcess();
+
+	SymInitialize(currentProcessId, NULL, TRUE);
+
+	dumpExceptionInfo(currentProcessId, pExceptionRec, pContextRecord);
+	fflush(stdout);
+	dumpBackTrace(currentProcessId);
+
+	SymCleanup(currentProcessId);
+
+	exit(1);
+}

Copied: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_core/src/ADM_crashdump_unix.cpp (from rev 7286, branches/avidemux_2.5_branch_gruntster/avidemux/ADM_core/src/ADM_crashdump.cpp)
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_core/src/ADM_crashdump_unix.cpp	                        (rev 0)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_core/src/ADM_crashdump_unix.cpp	2011-06-17 13:02:41 UTC (rev 7295)
@@ -0,0 +1,109 @@
+/***************************************************************************
+  Try to display interesting crash dump
+
+    copyright            : (C) 2007 by mean, (C) 2007 Gruntster
+    email                : fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdarg.h>
+#include <string.h>
+#include <unistd.h>
+#include <cxxabi.h>
+#include <signal.h>
+#include <execinfo.h>
+
+#include "ADM_default.h"
+
+// Our callback to give UI formatted informations....
+static ADM_saveFunction *mysaveFunction=NULL;
+static ADM_fatalFunction *myFatalFunction=NULL;
+
+/**
+        \fn ADM_setCrashHook
+        \brief install crash handlers (save + display)
+*/
+void ADM_setCrashHook(ADM_saveFunction *save, ADM_fatalFunction *fatal)
+{
+        mysaveFunction=save;
+        myFatalFunction=fatal;
+}
+
+/**
+      \fn sig_segfault_handler
+      \brief our segfault handler
+*/
+void sig_segfault_handler(int signo)
+{
+     static int running=0;
+      if(running) 
+      {
+        signo=0;
+        exit(1);
+      }
+      running=0; 
+      ADM_backTrack("Segfault",0,"??");
+}
+
+void installSigHandler()
+{
+    signal(11, sig_segfault_handler); // show stacktrace on default
+}
+
+void ADM_backTrack(const char *info,int lineno,const char *file)
+{
+	char wholeStuff[2048];
+    char buffer[2048];
+    char in[2048];
+	void *stack[20];
+	char **functions;
+	int count, i;
+
+	wholeStuff[0]=0;
+
+	if(mysaveFunction)
+		mysaveFunction();
+
+	printf("\n*********** BACKTRACK **************\n");
+
+	count = backtrace(stack, 20);
+	functions = backtrace_symbols(stack, count);
+	sprintf(wholeStuff,"%s\n at line %d, file %s",info,lineno,file);
+    int status;
+    size_t size=2047;
+    // it looks like that xxxx (functionName+0x***) XXXX
+	for (i=0; i < count; i++) 
+	{
+        char *s=strstr(functions[i],"(");
+        buffer[0]=0;
+        if(s && strstr(s+1,"+"))
+        {
+            strcpy(in,s+1);
+            char *e=strstr(in,"+");
+            *e=0;                
+            __cxxabiv1::__cxa_demangle(in,buffer,&size,&status);
+            if(status) strcpy(buffer,in);
+        }else       
+            strcpy(buffer,functions[i]);
+        printf("%s:%d:<%s>:%d\n",functions[i],i,buffer,status);
+		strcat(wholeStuff,buffer);
+		strcat(wholeStuff,"\n");
+	}
+
+	printf("*********** BACKTRACK **************\n");
+
+	if(myFatalFunction)
+		myFatalFunction("Crash", wholeStuff); // FIXME
+
+	exit(-1); // _exit(1) ???
+}

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_core/src/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_core/src/CMakeLists.txt	2011-06-17 05:52:52 UTC (rev 7294)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_core/src/CMakeLists.txt	2011-06-17 13:02:41 UTC (rev 7295)
@@ -1,8 +1,15 @@
 SET(ADM_core_SRCS 
 	ADM_cpuCap.cpp  ADM_memcpy.cpp  ADM_memsupport.cpp  ADM_threads.cpp  ADM_win32.cpp  ADM_translate.cpp
-	ADM_memory.cpp  ADM_misc.cpp  TLK_clock.cpp  ADM_crashdump.cpp  ADM_fileio.cpp ADM_dynamicLoading.cpp
-)
+	ADM_memory.cpp  ADM_misc.cpp  TLK_clock.cpp  ADM_fileio.cpp ADM_dynamicLoading.cpp)
 
+IF (MINGW)
+	SET(ADM_core_SRCS ${ADM_core_SRCS} ADM_crashdump_mswin.cpp)
+ELSEIF (APPLE)
+	SET(ADM_core_SRCS ${ADM_core_SRCS} ADM_crashdump_apple.cpp)
+ELSE (MINGW)
+	SET(ADM_core_SRCS ${ADM_core_SRCS} ADM_crashdump_unix.cpp)
+ENDIF (MINGW)
+
 ADD_LIBRARY(ADM_core SHARED ${ADM_core_SRCS})
 ADD_TARGET_DEFINITIONS(ADM_core ADM_DEBUG FIND_LEAKS)
 



From gruntster at mail.berlios.de  Sun Jun 19 22:18:28 2011
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Sun, 19 Jun 2011 22:18:28 +0200
Subject: [Avidemux-svn-commit] r7296 - in
	branches/avidemux_2.5_branch_gruntster/avidemux: . ADM_core/src
Message-ID: <20110619201828.480474813CC@sheep.berlios.de>

Author: gruntster
Date: 2011-06-19 22:18:28 +0200 (Sun, 19 Jun 2011)
New Revision: 7296

Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_core/src/ADM_crashdump_mswin.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/CMakeLists.txt
   branches/avidemux_2.5_branch_gruntster/avidemux/main.cpp
Log:
[mswin] fix 32-bit backtrace to work with recent compilers and add 64-bit backtrace support (requires latest mingw-w64 runtime to work properly).  64-bit backtrace is far more comprehensive than 32-bit.  Also C++ ABI is now demangled.

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_core/src/ADM_crashdump_mswin.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_core/src/ADM_crashdump_mswin.cpp	2011-06-17 13:02:41 UTC (rev 7295)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_core/src/ADM_crashdump_mswin.cpp	2011-06-19 20:18:28 UTC (rev 7296)
@@ -14,81 +14,103 @@
  *                                                                         *
  ***************************************************************************/
 
+#include <stdio.h>
 #include <windows.h>
 #include <imagehlp.h>
+#include <cxxabi.h>
 
-#include "ADM_default.h"
+extern "C"
+{
+typedef void ADM_saveFunction(void);
+typedef void ADM_fatalFunction(const char *title, const char *info);
+void ADM_setCrashHook(ADM_saveFunction *save, ADM_fatalFunction *fatal);
+void ADM_backTrack(const char *info, int lineno, const char *file);
+}
 
-// Our callback to give UI formatted informations....
-static ADM_saveFunction *mysaveFunction=NULL;
-static ADM_fatalFunction *myFatalFunction=NULL;
-/**
-        \fn ADM_setCrashHook
-        \brief install crash handlers (save + display)
-*/
+static ADM_saveFunction *mysaveFunction = NULL;
+static ADM_fatalFunction *myFatalFunction = NULL;
+
 void ADM_setCrashHook(ADM_saveFunction *save, ADM_fatalFunction *fatal)
 {
-        mysaveFunction=save;
-        myFatalFunction=fatal;
+	mysaveFunction = save;
+	myFatalFunction = fatal;
 }
 
-typedef struct STACK_FRAME
+static void PrintFunction(const char *moduleName, const char *functionName, DWORD_PTR frameAddress, DWORD_PTR frameOffset)
 {
-    STACK_FRAME* ebp;	// address of the calling function frame
-    uint8_t* retAddr;	// return address
-    uint32_t param[0];	// parameter list (could be empty)
-} STACK_FRAME;
+	if (functionName)
+	{
+		char *cxaFunction = (char*)malloc(strlen(functionName) + 2);
 
-static void dumpFrame(void* processId, void* frameAddr)
-{
-#ifdef ADM_CPU_X86_64
-#define ARCH_DWORD DWORD64
-#else
-#define ARCH_DWORD DWORD
-#endif
+		cxaFunction[0] = '_';
+		strcpy(cxaFunction + 1, functionName);
 
-	MEMORY_BASIC_INFORMATION mbi;
-	char moduleName[MAX_PATH];
-	HMODULE moduleAddr;
-	ARCH_DWORD symDisplacement;
-	IMAGEHLP_SYMBOL* pSymbol;
+		int status;
+		char *demangledName = __cxxabiv1::__cxa_demangle(cxaFunction, NULL, NULL, &status);
 
-	if (VirtualQuery(frameAddr, &mbi, sizeof(mbi)))
-	{
-		moduleName[0] = 0;
-		moduleAddr = (HMODULE)mbi.AllocationBase;
-		
-		GetModuleFileName(moduleAddr, moduleName, MAX_PATH);
+		free(cxaFunction);
 
-		printf("%s(", moduleName);
-
-		if (SymGetSymFromAddr(processId, (ARCH_DWORD)frameAddr, &symDisplacement, pSymbol))
-			printf("%s", pSymbol->Name);
+		if (status == 0)
+			printf(demangledName);
 		else
-			printf("<unknown>");
+			printf(functionName);
 
-		printf("+0x%X) [0x%08X]\n", (ARCH_DWORD)frameAddr - (ARCH_DWORD)moduleAddr, frameAddr);
+		if (demangledName)
+			free(demangledName);
+	}
+	else
+		printf("unknown function");
 
-		fflush(stdout);
-	}
+	if (frameOffset)
+		printf(" <+0x%X>", frameOffset);
+
+	if (moduleName)
+		printf("  [%s]\n", moduleName);
+	else
+		printf("  [unknown module]\n");
+
+	fflush(stdout);
 }
-	
-static void dumpExceptionInfo(void* processId, struct _EXCEPTION_RECORD* pExceptionRec, struct _CONTEXT* pContextRecord)
+
+static bool DumpFrame(void *process, DWORD_PTR frameAddress)
 {
+	const int functionLength = 255;
+	IMAGEHLP_SYMBOL *symbol = (IMAGEHLP_SYMBOL*)malloc(sizeof(IMAGEHLP_SYMBOL) + functionLength);
+	DWORD_PTR moduleBase = SymGetModuleBase(process, frameAddress);
+	const char *moduleName = NULL, *functionName = NULL;
+	DWORD_PTR displacement;
+	char moduleFilename[MAX_PATH];
+
+	symbol->SizeOfStruct = (sizeof(*symbol)) + functionLength;
+	symbol->MaxNameLength = functionLength - 1;
+
+	if (moduleBase && GetModuleFileName((HINSTANCE)moduleBase, moduleFilename, MAX_PATH))
+		moduleName = moduleFilename;
+
+	if (SymGetSymFromAddr(process, frameAddress, &displacement, symbol))
+		functionName = symbol->Name;
+
+	PrintFunction(moduleName, functionName, frameAddress, displacement);
+
+	free(symbol);
+}
+
+static void DumpExceptionInfo(void *processId, struct _EXCEPTION_RECORD *exceptionRec, struct _CONTEXT *contextRecord)
+{
 	printf("\n*********** EXCEPTION **************\n");
 	printf("Registers:\n");
-#ifdef ADM_CPU_X86_64
-	printf("RAX: %08X  RBX: %08X  RCX: %08X  RDX: %08X  RSI: %08X  RDI: %08X  RSP: %08X  RBP: %08X\n", pContextRecord->Rax, pContextRecord->Rbx, pContextRecord->Rcx, pContextRecord->Rdx, pContextRecord->Rsi, pContextRecord->Rdi, pContextRecord->Rsp, pContextRecord->Rbp);
-	printf("R8: %08X  R9: %08X  R10: %08X  R11: %08X  R12: %08X  R13: %08X  R14: %08X  R15: %08X\n", pContextRecord->R8, pContextRecord->R9, pContextRecord->R10, pContextRecord->R11, pContextRecord->R12, pContextRecord->R13, pContextRecord->R14, pContextRecord->R15);
-	printf("RIP: %08X  EFlags: %08X\n\n", pContextRecord->Rip, pContextRecord->EFlags);
+#ifdef _WIN64
+	printf("RAX: %08X  RBX: %08X  RCX: %08X  RDX: %08X  RSI: %08X  RDI: %08X  RSP: %08X  RBP: %08X\n", contextRecord->Rax, contextRecord->Rbx, contextRecord->Rcx, contextRecord->Rdx, contextRecord->Rsi, contextRecord->Rdi, contextRecord->Rsp, contextRecord->Rbp);
+	printf("R8: %08X  R9: %08X  R10: %08X  R11: %08X  R12: %08X  R13: %08X  R14: %08X  R15: %08X\n", contextRecord->R8, contextRecord->R9, contextRecord->R10, contextRecord->R11, contextRecord->R12, contextRecord->R13, contextRecord->R14, contextRecord->R15);
+	printf("RIP: %08X  EFlags: %08X\n\n", contextRecord->Rip, contextRecord->EFlags);
 #else
-	printf("EAX: %08X  EBX: %08X  ECX: %08X  EDX: %08X  ESI: %08X\n", pContextRecord->Eax, pContextRecord->Ebx, pContextRecord->Ecx, pContextRecord->Edx, pContextRecord->Esi);
-	printf("EDI: %08X  ESP: %08X  EBP: %08X  EIP: %08X  EFlags: %08X\n\n", pContextRecord->Edi, pContextRecord->Esp, pContextRecord->Ebp, pContextRecord->Eip, pContextRecord->EFlags);
+	printf("EAX: %08X  EBX: %08X  ECX: %08X  EDX: %08X  ESI: %08X\n", contextRecord->Eax, contextRecord->Ebx, contextRecord->Ecx, contextRecord->Edx, contextRecord->Esi);
+	printf("EDI: %08X  ESP: %08X  EBP: %08X  EIP: %08X  EFlags: %08X\n\n", contextRecord->Edi, contextRecord->Esp, contextRecord->Ebp, contextRecord->Eip, contextRecord->EFlags);
 #endif
 
 	printf("Exception Code: ");
 
-	switch (pExceptionRec->ExceptionCode)
+	switch (exceptionRec->ExceptionCode)
 	{
 		case EXCEPTION_ACCESS_VIOLATION:
 			printf("EXCEPTION_ACCESS_VIOLATION");
@@ -154,78 +176,82 @@
 			printf("UNKNOWN");
 	}
 	
-	printf(" (%08X)\n", pExceptionRec->ExceptionCode);
-	printf("Exception Flags: %08X\n", pExceptionRec->ExceptionFlags);
+	printf(" (%08X)\n", exceptionRec->ExceptionCode);
+	printf("Exception Flags: %08X\n", exceptionRec->ExceptionFlags);
 
 	printf("\nOrigin:\n");
 
-#ifdef ADM_CPU_X86_64
-	dumpFrame(processId, (void*)pContextRecord->Rip);
+#ifdef _WIN64
+	DumpFrame(processId, contextRecord->Rip);
 #else
-	dumpFrame(processId, (void*)pContextRecord->Eip);
+	DumpFrame(processId, contextRecord->Eip);
 #endif
 
 	printf("*********** EXCEPTION **************\n");
 	fflush(stdout);
 }
 
-extern "C"
+void DumpBackTrace(void *processId)
 {
-void dumpBackTrace(void* processId)
-{
-	if (!processId)
-		processId = GetCurrentProcess();
+	printf("\n*********** BACKTRACE **************\n");
 
-	const int maxAddrCount = 32;
+	typedef VOID NTAPI RtlCaptureContext_(PCONTEXT ContextRecord);
 
-	printf("\n*********** BACKTRACE **************\n");
+	HANDLE process = GetCurrentProcess();
+	HANDLE thread = GetCurrentThread();
+	HINSTANCE hinstLib = LoadLibrary("kernel32.dll");
+	RtlCaptureContext_* contextFunc = (RtlCaptureContext_*)GetProcAddress(hinstLib, "RtlCaptureContext");
+	STACKFRAME frame;
+	CONTEXT context;
+	int limit = 50;
+	DWORD machineType;
 
-	// Get frame address using builtin GCC function.
-	STACK_FRAME* stackFrame = (STACK_FRAME*)__builtin_frame_address(0);
+	memset(&frame, 0, sizeof(STACKFRAME));
+	memset(&context, 0, sizeof(CONTEXT));
 
-    for (int retAddrCount = 0; (retAddrCount < maxAddrCount) && !IsBadReadPtr(stackFrame, sizeof(STACK_FRAME)) && !IsBadCodePtr(FARPROC(stackFrame->retAddr)); retAddrCount++, stackFrame = stackFrame->ebp)
-    {
-		printf("Frame %2d: ", retAddrCount);
-		dumpFrame(processId, stackFrame->retAddr);
-		fflush(stdout);
-    }
+	context.ContextFlags = CONTEXT_FULL;
+	contextFunc(&context);
 
-	printf("*********** BACKTRACE **************\n\n");
-}
-}
+#if _WIN64
+	machineType = IMAGE_FILE_MACHINE_AMD64;
 
-void ADM_backTrack(const char *info,int lineno,const char *file)
-{	
-	fflush(stderr);
-	fflush(stdout);
+    frame.AddrPC.Offset = context.Rip;
+	frame.AddrStack.Offset = context.Rsp;
+	frame.AddrFrame.Offset = context.Rbp;
+#else
+	machineType = IMAGE_FILE_MACHINE_I386;
 
-	if (mysaveFunction)
-		mysaveFunction();
+	frame.AddrPC.Offset = context.Eip;
+	frame.AddrStack.Offset = context.Esp;
+	frame.AddrFrame.Offset = context.Ebp;
+#endif
 
-	if (myFatalFunction)
-		myFatalFunction("Crash", "Press OK to build crash info");
+    frame.AddrPC.Mode = AddrModeFlat;
+    frame.AddrStack.Mode = AddrModeFlat;
+    frame.AddrFrame.Mode = AddrModeFlat;
 
-	void* currentProcessId = GetCurrentProcess();
+	while (StackWalk(machineType, process, thread, &frame, &context, 0, SymFunctionTableAccess, SymGetModuleBase, 0))
+	{
+        if (limit-- == 0)
+			break;
 
-	SymInitialize(currentProcessId, NULL, TRUE);
-	dumpBackTrace(currentProcessId);
-	SymCleanup(currentProcessId);
+		DumpFrame(process, frame.AddrPC.Offset);
+	}
 
-	printf("Assert failed at file %s, line %d\n\n",file,lineno);
-
-	exit(-1);
+	printf("*********** BACKTRACE **************\n\n");
 }
 
-EXCEPTION_DISPOSITION exceptionHandler(struct _EXCEPTION_RECORD* pExceptionRec, void* pEstablisherFrame, struct _CONTEXT* pContextRecord, void* pDispatcherContext)
+void HandleException(struct _EXCEPTION_RECORD *exceptionRecord, struct _CONTEXT *contextRecord)
 {
 	fflush(stderr);
-	fflush(stdout);
-	static int running=0;
+	fflush(stdout);	
 
-	if(running)
+	static int running = 0;
+
+	if (running)
 		exit(1);
 
-	running=1;
+	running = 1;
 
 	if (mysaveFunction)
 		mysaveFunction();
@@ -233,15 +259,32 @@
 	if (myFatalFunction)
 		myFatalFunction("Crash", "Press OK to build crash info");
 
-	void* currentProcessId = GetCurrentProcess();
+	void *process = GetCurrentProcess();
 
-	SymInitialize(currentProcessId, NULL, TRUE);
+	SymInitialize(process, NULL, TRUE);
 
-	dumpExceptionInfo(currentProcessId, pExceptionRec, pContextRecord);
-	fflush(stdout);
-	dumpBackTrace(currentProcessId);
+	if (exceptionRecord != NULL && contextRecord != NULL)
+	{
+		DumpExceptionInfo(process, exceptionRecord, contextRecord);
+	}
 
-	SymCleanup(currentProcessId);
+	DumpBackTrace(process);
+	SymCleanup(process);
 
 	exit(1);
 }
+
+EXCEPTION_DISPOSITION ExceptionHandler(struct _EXCEPTION_RECORD *exceptionRecord, void *establisherFrame, struct _CONTEXT *contextRecord, void *dispatcherContext)
+{
+	HandleException(exceptionRecord, contextRecord);
+}
+
+LONG WINAPI ExceptionFilter(struct _EXCEPTION_POINTERS *exceptionInfo)
+{
+	HandleException(exceptionInfo->ExceptionRecord, exceptionInfo->ContextRecord);
+}
+
+void ADM_backTrack(const char *info, int lineno, const char *file)
+{	
+	HandleException(NULL, NULL);
+}

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/CMakeLists.txt	2011-06-17 13:02:41 UTC (rev 7295)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/CMakeLists.txt	2011-06-19 20:18:28 UTC (rev 7296)
@@ -428,7 +428,7 @@
 ###########################################
 IF (WIN32)
 	ADD_ADMLIB_ALL_TARGETS(ADM_osSupport)
-	ADD_LIB_ALL_TARGETS(winmm)
+	ADD_LIB_ALL_TARGETS(winmm -Wl,--export-all-symbols)
 
 	ADD_TARGET_LDFLAGS(avidemux2_cli "-Wl,-subsystem,console")
 

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/main.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/main.cpp	2011-06-17 13:02:41 UTC (rev 7295)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/main.cpp	2011-06-19 20:18:28 UTC (rev 7296)
@@ -17,11 +17,6 @@
  *                                                                         *
  ***************************************************************************/
 
-#ifdef __MINGW32__
-#include <windows.h>
-#include <excpt.h>
-#endif
-
 #include "config.h"
 #include "ADM_default.h"
 #include "ADM_threads.h"
@@ -47,9 +42,7 @@
 #include "ADM_userInterfaces/ADM_render/GUI_sdlRender.h"
 #endif
 
-
 void onexit( void );
-//extern void automation(int argc, char **argv);
 
 extern void registerVideoFilters( void );
 extern void filterCleanUp( void );
@@ -69,13 +62,16 @@
 extern void loadPlugins(void);
 extern void InitFactory(void);
 extern void InitCoreToolkit(void);
-#ifdef __MINGW32__
-extern EXCEPTION_DISPOSITION exceptionHandler(struct _EXCEPTION_RECORD* pExceptionRec, void* pEstablisherFrame, struct _CONTEXT* pContextRecord, void* pDispatcherContext);
+
+#if defined(_WIN64)
+extern LONG WINAPI ExceptionFilter(struct _EXCEPTION_POINTERS *exceptionInfo);
+#elif defined(_WIN32)
+extern EXCEPTION_DISPOSITION ExceptionHandler(struct _EXCEPTION_RECORD *exceptionRecord, void *establisherFrame, struct _CONTEXT *contextRecord, void *dispatcherContext);
 #else
 extern void installSigHandler(void);
 #endif
 
-#ifdef __WIN32
+#ifdef _WIN32
 extern bool getWindowsVersion(char* version);
 extern void redirectStdoutToFile(void);
 #endif
@@ -103,7 +99,7 @@
 	char uiDesc[15];
 	getUIDescription(uiDesc);
 
-#if defined(__WIN32)
+#if defined(_WIN32)
 	if (strcmp(uiDesc, "CLI") != 0)
 		redirectStdoutToFile();
 #endif
@@ -112,7 +108,7 @@
 	new_progname = argv[0];
 #endif
 
-#ifndef __MINGW32__
+#ifndef _WIN32
 	// thx smurf uk :)
     installSigHandler();
 #endif
@@ -141,7 +137,7 @@
 
 	printf("Build Target: ");
 
-#if defined(__WIN32)
+#if defined(_WIN32)
 	printf("Microsoft Windows");
 #elif defined(__APPLE__)
 	printf("Apple");
@@ -159,7 +155,7 @@
 
 	printf("\nUser Interface: %s\n", uiDesc);
 
-#ifdef __WIN32
+#ifdef _WIN32
 	char version[250];
 
 	if (getWindowsVersion(version))
@@ -188,7 +184,7 @@
 
 	atexit(onexit);
 
-#ifdef __MINGW32__
+#ifdef _WIN32
     win32_netInit();
 #endif
 
@@ -270,14 +266,16 @@
     else
 		ADM_assert(0); 
 
-#ifdef __MINGW32__
-	__try1(exceptionHandler);
+#if defined(_WIN64)
+	SetUnhandledExceptionFilter(ExceptionFilter);
+#elif defined(_WIN32)
+	__try1(ExceptionHandler);
 #endif
 
     UI_RunApp();
 
-#ifdef __MINGW32__
-	__except1(exceptionHandler);
+#if defined(_WIN32) && defined(_X86_)
+	__except1;
 #endif
 
     printf("Normal exit\n");



From mean at mail.berlios.de  Tue Jun 21 08:22:39 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Tue, 21 Jun 2011 08:22:39 +0200
Subject: [Avidemux-svn-commit] r7297 -
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/vdpauFilters
Message-ID: <20110621062239.4E5FC480F81@sheep.berlios.de>

Author: mean
Date: 2011-06-21 08:22:38 +0200 (Tue, 21 Jun 2011)
New Revision: 7297

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/vdpauFilters/ADM_vidVdpauFilterDeint.cpp
Log:
[vdpau] Deinterlace, new code layout. Works when copying frame, not done for VDPAU fastpath yet

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/vdpauFilters/ADM_vidVdpauFilterDeint.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/vdpauFilters/ADM_vidVdpauFilterDeint.cpp	2011-06-19 20:18:28 UTC (rev 7296)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/vdpauFilters/ADM_vidVdpauFilterDeint.cpp	2011-06-21 06:22:38 UTC (rev 7297)
@@ -5,6 +5,8 @@
     
 
 */
+#include "ADM_cpp.h"
+#include <list>
 #include "ADM_default.h"
 #ifdef USE_VDPAU
 #include "ADM_coreVideoFilterInternal.h"
@@ -17,7 +19,7 @@
 #include "ADM_coreVdpau/include/ADM_coreVdpau.h"
 //
 #define ADM_INVALID_FRAME_NUM 0x80000000
-#define ADM_NB_SURFACES 3
+#define ADM_NB_SURFACES 5
 
 #if 0
 #define aprintf printf
@@ -31,13 +33,44 @@
     ADM_KEEP_BOTTOM=1,
     ADM_KEEP_BOTH=2
 };
+/**
+    \class VDPSlot
+*/
+class VDPSlot
+{
+public:
+                              VDPSlot() ;
+                             ~VDPSlot();
+            VdpVideoSurface   surface;
+            bool              isExternal;
+            uint64_t          pts;
+            uint32_t          frameNumber;
+            ADMImage          *image;
+};
 
+VDPSlot::VDPSlot()
+{
+    surface=VDP_INVALID_HANDLE;
+    image=NULL;
+}
+VDPSlot::~VDPSlot()
+{
+    if(image) delete image;
+    image=NULL;
+    if(surface!=VDP_INVALID_HANDLE)
+    {
+        // will be freed by the pool..
+    }
+    surface=VDP_INVALID_HANDLE;
+}
+
 /**
     \class vdpauVideoFilterDeint
 */
 class vdpauVideoFilterDeint : public  ADM_coreVideoFilter
 {
 protected:
+                    VDPSlot              slots[3];
                     bool                 eof;
                     bool                 secondField;
                     uint64_t             nextPts;
@@ -49,12 +82,16 @@
                     uint8_t             *tempBuffer;
                     vdpauFilterDeint     configuration;
                     VdpOutputSurface     outputSurface;
-                    VdpVideoSurface      input[ADM_NB_SURFACES];
-                    uint32_t             frameDesc[ADM_NB_SURFACES];
+                    std::list <VdpVideoSurface> freeSurface;
+                    VdpVideoSurface      surfacePool[ADM_NB_SURFACES];
                     VdpVideoMixer        mixer;
-                    bool                 uploadImage(ADMImage *next,uint32_t surfaceIndex,uint32_t frameNumber) ;
+protected:
+                    bool                 rotateSlots(void);
+                    bool                 clearSlots(void);
+                    bool                 uploadImage(ADMImage *next,const VdpVideoSurface surface) ;
+                    bool                 fillSlot(int slot,ADMImage *image);
                     bool                 getResult(ADMImage *image);
-                    bool                 sendField(bool topField,ADMImage *next);
+                    bool                 sendField(bool topField);
 
 public:
         virtual bool         goToTime(uint64_t usSeek); 
@@ -113,7 +150,7 @@
 {
     secondField=false;
     eof=false;
-    for(int i=0;i<ADM_NB_SURFACES;i++)             frameDesc[i]=ADM_INVALID_FRAME_NUM;
+    clearSlots();
     return ADM_coreVideoFilter::goToTime(usSeek);
 }
 
@@ -124,7 +161,6 @@
 {
     scaler=NULL;
     secondField=false;
-    for(int i=0;i<ADM_NB_SURFACES;i++)             frameDesc[i]=ADM_INVALID_FRAME_NUM;
     nextFrame=0;
     if(!admVdpau::isOperationnal())
     {
@@ -137,15 +173,23 @@
         ADM_error("Cannot create outputSurface0\n");
         return false;
     }
+    for(int i=0;i<ADM_NB_SURFACES;i++) surfacePool[i]=VDP_INVALID_HANDLE;
     for(int i=0;i<ADM_NB_SURFACES;i++)
     {
         if(VDP_STATUS_OK!=admVdpau::surfaceCreate(   previousFilter->getInfo()->width,
-                                                    previousFilter->getInfo()->height,input+i)) 
+                                                    previousFilter->getInfo()->height,
+                                                    &(surfacePool[i]))) 
         {
             ADM_error("Cannot create input Surface %d\n",i);
             goto badInit;
         }
+        aprintf("Created surface %d\n",(int)surfacePool[i]);
     }
+    // allocate our (dummy) images
+    for(int i=0;i<3;i++)
+        slots[i].image=new ADMImageDefault( previousFilter->getInfo()->width, 
+                                            previousFilter->getInfo()->height);
+                                            
     if(VDP_STATUS_OK!=admVdpau::mixerCreate(previousFilter->getInfo()->width,
                                             previousFilter->getInfo()->height,&mixer,true)) 
     {
@@ -154,6 +198,11 @@
     } 
     tempBuffer=new uint8_t[info.width*info.height*4];
     scaler=new ADMColorScalerSimple( info.width,info.height, ADM_COLOR_BGR32A,ADM_COLOR_YV12);
+
+    freeSurface.clear();
+    for(int i=0;i<ADM_NB_SURFACES;i++)  
+            freeSurface.push_back(surfacePool[i]);
+
     ADM_info("VDPAU setup ok\n");
     return true;
 badInit:
@@ -167,17 +216,24 @@
 bool vdpauVideoFilterDeint::cleanupVdpau(void)
 {
     for(int i=0;i<ADM_NB_SURFACES;i++)
-        if(input[i]!=VDP_INVALID_HANDLE) admVdpau::surfaceDestroy(input[i]);
+        if(surfacePool[i]!=VDP_INVALID_HANDLE) admVdpau::surfaceDestroy(surfacePool[i]);
     if(outputSurface!=VDP_INVALID_HANDLE)  admVdpau::outputSurfaceDestroy(outputSurface);
     if(mixer!=VDP_INVALID_HANDLE) admVdpau::mixerDestroy(mixer);
     outputSurface=VDP_INVALID_HANDLE;
     for(int i=0;i<ADM_NB_SURFACES;i++)
-        input[i]=VDP_INVALID_HANDLE;
+        surfacePool[i]=VDP_INVALID_HANDLE;
     mixer=VDP_INVALID_HANDLE;
     if(tempBuffer) delete [] tempBuffer;
     tempBuffer=NULL;
     if(scaler) delete scaler;
     scaler=NULL;
+    for(int i=0;i<3;i++)
+       if(slots[i].image)
+        {
+            delete slots[i].image;
+            slots[i].image=NULL;
+        }
+
     return true;
 }
 
@@ -188,7 +244,7 @@
 {
     eof=false;
     for(int i=0;i<ADM_NB_SURFACES;i++)
-        input[i]=VDP_INVALID_HANDLE;
+        surfacePool[i]=VDP_INVALID_HANDLE;
     mixer=VDP_INVALID_HANDLE;
     outputSurface=VDP_INVALID_HANDLE;
     if(!setup || !ADM_paramLoad(setup,vdpauFilterDeint_param,&configuration))
@@ -251,10 +307,6 @@
      }
      return 0;
      
-        cleanupVdpau();
-        passThrough=!setupVdpau();
-        return 1;
-     
 }
 /**
     \fn getCoupledConf
@@ -279,70 +331,128 @@
     \fn uploadImage
     \brief upload an image to a vdpau surface
 */
-bool vdpauVideoFilterDeint::uploadImage(ADMImage *next,uint32_t surfaceIndex,uint32_t frameNumber) 
+bool vdpauVideoFilterDeint::uploadImage(ADMImage *next,VdpVideoSurface surface) 
 {
     if(!next) // empty image
     {
-        frameDesc[surfaceIndex%ADM_NB_SURFACES]=ADM_INVALID_FRAME_NUM;
         ADM_warning("VdpauDeint:No image to upload\n");
         return true;
     }
+    if(surface==VDP_INVALID_HANDLE)
+    {
+        ADM_error("Surface provided is invalid\n");
+        return false;
+    }
   // Blit our image to surface
     uint32_t pitches[3];
     uint8_t *planes[3];
     next->GetPitches(pitches);
     next->GetReadPlanes(planes);
 
-  
+    aprintf("Putting image in surface %d\n",(int)surface);
     // Put out stuff in input...
 #if VDP_DEBUG
     printf("Uploading image to surface %d\n",surfaceIndex%ADM_NB_SURFACES);
 #endif
     if(VDP_STATUS_OK!=admVdpau::surfacePutBits( 
-            input[surfaceIndex%ADM_NB_SURFACES],
+            surface,
             planes,pitches))
     {
         ADM_warning("[Vdpau] video surface : Cannot putbits\n");
         return false;
     }
-    frameDesc[surfaceIndex%ADM_NB_SURFACES]=frameNumber;
     return true;
 }
 /**
+    \fn setSlot
+*/
+bool vdpauVideoFilterDeint::fillSlot(int slot,ADMImage *image)
+{
+    VdpVideoSurface tgt;
+    bool external=false;
+    if(true)
+    {   // Need to allocate a surface
+        ADM_assert(freeSurface.size());
+        tgt=freeSurface.front();
+        freeSurface.pop_front();  
+        aprintf("FillSlot : Popped %d\n",tgt);
+        //
+        if(false==uploadImage(image,tgt)) 
+        {
+            return false;
+        }
+        external=false;
+    }else
+    {   // use the provided surface
+
+    }
+    nextPts=image->Pts;
+    slots[slot].pts=image->Pts;
+    slots[slot].surface=tgt;
+    slots[slot].isExternal=external;
+    return true;
+}
+
+/**
+    \fn rotateSlots
+*/
+bool vdpauVideoFilterDeint::rotateSlots(void)
+{
+    VDPSlot *s=&(slots[0]);
+    ADMImage *img=slots[0].image;
+    if(s->surface!=VDP_INVALID_HANDLE)
+        if(!s->isExternal)
+        {
+            freeSurface.push_back(s->surface);
+            s->surface=VDP_INVALID_HANDLE;
+        }else
+        {
+            // Ref couting dec..
+        }
+    slots[0]=slots[1];
+    slots[1]=slots[2];
+    slots[2].surface=VDP_INVALID_HANDLE;
+    slots[2].image=img;
+    return true;
+}
+/**
+    \fn clearSlots
+*/
+bool vdpauVideoFilterDeint::clearSlots(void)
+{
+    for(int i=0;i<3;i++)
+    {
+           VDPSlot *s=&(slots[i]);  
+           if(s->surface!=VDP_INVALID_HANDLE)
+            {
+                if(s->isExternal)
+                {
+                    // TODO decrease refCount
+                }else
+                {
+                    freeSurface.push_back(s->surface);
+                }
+            }
+            s->surface=VDP_INVALID_HANDLE;
+    }
+    return true;
+}
+/**
     \fn sendField
     \brief Process a field (top or bottom). If null the next param means there is no successor (next image)
 */
-bool vdpauVideoFilterDeint::sendField(bool topField,ADMImage *next)
+bool vdpauVideoFilterDeint::sendField(bool topField)
 {
  // Call mixer...
     VdpVideoSurface in[3];
     bool r=true;
-        // PREVIOUS
-    if(!nextFrame) // First image, we dont have previous
+    // PREVIOUS
+    for(int i=0;i<3;i++)
     {
-             in[0]=VDP_INVALID_HANDLE;
-    }else
-    {
-             in[0]=input[(nextFrame+ADM_NB_SURFACES-1)%ADM_NB_SURFACES];
+        in[i]=slots[i].surface;
+        aprintf("Mixing %d %d\n",i,(int)in[i]);
     }
-        // CURRENT
-     in[1]=input[nextFrame%ADM_NB_SURFACES];
-        // NEXT
-    if(next)
-    {
-     in[2]=input[(nextFrame+1)%ADM_NB_SURFACES];
-    }
-    else
-    {
-      in[2]=VDP_INVALID_HANDLE;
-    }
-
     //
-#if VDP_DEBUG
-    printf("Current index=%d\n",(int)nextFrame);
-    for(int i=0;i<3;i++) printf("Calling with in[%d]=%d\n",i,in[i]);
-    for(int i=0;i<3;i++) printf("Desc[%d]=%d\n",i, frameDesc[i]);
-#endif
     // ---------- Top field ------------
     if(VDP_STATUS_OK!=admVdpau::mixerRenderWithPastAndFuture(topField, 
                 mixer,
@@ -353,8 +463,7 @@
     {
         ADM_warning("[Vdpau] Cannot mixerRender\n");
         r= false;
-    }
-    vidCache->unlockAll();
+    }    
     return r;
 }
 /**
@@ -417,36 +526,37 @@
             aprintf("2ndField : Pts=%s\n",ADM_us2plain(image->Pts));
             return true;
         }
-    
+     // shift frames;... free slot[0]
+    rotateSlots();
+
     // our first frame, we need to preload one frame
     if(!nextFrame)
     {
-            ADMImage *prev= vidCache->getImage( 0);
-            // Upload top field
-            if(false==uploadImage(prev,nextFrame,0)) 
+            aprintf("This is our first image, filling slot 1\n");
+            ADMImage *prev= vidCache->getImage(0);
+            if(false==fillSlot(1,prev))
             {
-                vidCache->unlockAll();
-                return false;
+                    vidCache->unlockAll();
+                    return false;
             }
-            nextPts=prev->Pts;
+            
     }
     // regular image, in fact we get the next image here
-    
     ADMImage *next= vidCache->getImage(nextFrame+1);
     if(next)
     {
-        //printf("VDPAU DEINT : incoming PTS=%"LLU"\n",next->Pts);
-    }
-    if(false==uploadImage(next,nextFrame+1,nextFrame+1)) 
+            if(false==fillSlot(2,next))
             {
                 vidCache->unlockAll();
-                
                 FAIL
             }
-   if(!next) eof=true; // End of stream
-   
+    }
+    if(!next) eof=true; // End of stream
+
+    // now we have slot 0 : prev Image, slot 1=current image, slot 2=next image
+
     // Now get our image back from surface...
-    sendField(true,next); // always send top field
+    sendField(true); // always send top field
     if(configuration.deintMode==ADM_KEEP_TOP || configuration.deintMode==ADM_KEEP_BOTH)
     {
           if(false==getResult(image)) 
@@ -456,7 +566,7 @@
           aprintf("TOP/BOTH : Pts=%s\n",ADM_us2plain(image->Pts));
     }
     // Send 2nd field
-    sendField(false,next); 
+    sendField(false); 
     if(configuration.deintMode==ADM_KEEP_BOTTOM)
     {
           if(false==getResult(image)) 
@@ -467,6 +577,7 @@
     }
     // Top Field..
 endit:  
+    vidCache->unlockAll();
     if(configuration.deintMode==ADM_KEEP_BOTH) 
     {
         *fn=nextFrame*2;



From mean at mail.berlios.de  Wed Jun 22 08:05:33 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Wed, 22 Jun 2011 08:05:33 +0200
Subject: [Avidemux-svn-commit] r7298 -
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/vdpauFilters
Message-ID: <20110622060533.6AE62481230@sheep.berlios.de>

Author: mean
Date: 2011-06-22 08:05:32 +0200 (Wed, 22 Jun 2011)
New Revision: 7298

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/vdpauFilters/ADM_vidVdpauFilterDeint.cpp
Log:
[vdpau deint] Fastpath if the video is already a vdpau surface. No real speedup at the moment

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/vdpauFilters/ADM_vidVdpauFilterDeint.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/vdpauFilters/ADM_vidVdpauFilterDeint.cpp	2011-06-21 06:22:38 UTC (rev 7297)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/vdpauFilters/ADM_vidVdpauFilterDeint.cpp	2011-06-22 06:05:32 UTC (rev 7298)
@@ -9,6 +9,11 @@
 #include <list>
 #include "ADM_default.h"
 #ifdef USE_VDPAU
+extern "C" {
+#include "libavcodec/avcodec.h"
+#include "libavcodec/vdpau.h"
+}
+
 #include "ADM_coreVideoFilterInternal.h"
 #include "ADM_videoFilterCache.h"
 #include "DIA_factory.h"
@@ -364,13 +369,14 @@
     return true;
 }
 /**
-    \fn setSlot
+    \fn fillSlot
+    \brief upload the image to the slot. 
 */
 bool vdpauVideoFilterDeint::fillSlot(int slot,ADMImage *image)
 {
     VdpVideoSurface tgt;
     bool external=false;
-    if(true)
+    if(image->refType!=ADM_HW_VDPAU)
     {   // Need to allocate a surface
         ADM_assert(freeSurface.size());
         tgt=freeSurface.front();
@@ -384,7 +390,15 @@
         external=false;
     }else
     {   // use the provided surface
-
+        aprintf("Deint Image is already vdpau, slot %d \n",slot);
+        ADMImage *img=slots[slot].image;
+        img->duplicateFull(image); // increment ref count
+        // get surface
+        img->hwDownloadFromRef();
+        vdpau_render_state *render=(vdpau_render_state *)img->refDescriptor.refCookie;
+        ADM_assert(render->refCount);
+        tgt=render->surface;
+        external=true;
     }
     nextPts=image->Pts;
     slots[slot].pts=image->Pts;
@@ -408,6 +422,8 @@
         }else
         {
             // Ref couting dec..
+            s->image->hwDecRefCount();
+            s->surface=VDP_INVALID_HANDLE;
         }
     slots[0]=slots[1];
     slots[1]=slots[2];
@@ -427,7 +443,7 @@
             {
                 if(s->isExternal)
                 {
-                    // TODO decrease refCount
+                    s->image->hwDecRefCount();
                 }else
                 {
                     freeSurface.push_back(s->surface);
@@ -533,7 +549,7 @@
     if(!nextFrame)
     {
             aprintf("This is our first image, filling slot 1\n");
-            ADMImage *prev= vidCache->getImage(0);
+            ADMImage *prev= vidCache->getImageAs(ADM_HW_VDPAU,0);
             if(false==fillSlot(1,prev))
             {
                     vidCache->unlockAll();
@@ -542,7 +558,7 @@
             
     }
     // regular image, in fact we get the next image here
-    ADMImage *next= vidCache->getImage(nextFrame+1);
+    ADMImage *next= vidCache->getImageAs(ADM_HW_VDPAU,nextFrame+1);
     if(next)
     {
             if(false==fillSlot(2,next))



From gruntster at mail.berlios.de  Fri Jun 24 19:43:57 2011
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Fri, 24 Jun 2011 19:43:57 +0200
Subject: [Avidemux-svn-commit] r7299 - in
	branches/avidemux_2.5_branch_gruntster:
	avidemux/ADM_audiocodec avidemux/ADM_codecs
	avidemux/ADM_core/src avidemux/ADM_libraries
	avidemux/ADM_outputs cmake cmake/patches
	plugins/ADM_videoEncoder/ADM_vidEnc_avcodec
Message-ID: <20110624174357.EDCB248294E@sheep.berlios.de>

Author: gruntster
Date: 2011-06-24 19:43:57 +0200 (Fri, 24 Jun 2011)
New Revision: 7299

Added:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_libraries/ffmpeg-0.8.tar.bz2
Removed:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_libraries/ffmpeg-0.7-rc1.tar.gz
Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiocodec/ADM_codecwma.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_codecs/ADM_ffmp43.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_core/src/ADM_memcpy.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_outputs/ADM_lavformat.cpp
   branches/avidemux_2.5_branch_gruntster/cmake/admFFmpegBuild.cmake
   branches/avidemux_2.5_branch_gruntster/cmake/admFFmpegPrepareTar.cmake
   branches/avidemux_2.5_branch_gruntster/cmake/patches/createPatches.sh
   branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_avcodec.h.patch
   branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_ffv1.c.patch
   branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_h263dec.c.patch
   branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_h264.c.patch
   branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_mpeg12.c.patch
   branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_mpeg12enc.c.patch
   branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_mpegvideo.c.patch
   branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_utils.c.patch
   branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_vc1dec.c.patch
   branches/avidemux_2.5_branch_gruntster/cmake/patches/libavformat_isom.c.patch
   branches/avidemux_2.5_branch_gruntster/cmake/patches/libavformat_matroskaenc.c.patch
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_avcodec/encoder.cpp
Log:
[ffmpeg] upgrade ffmpeg to 0.8

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiocodec/ADM_codecwma.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiocodec/ADM_codecwma.cpp	2011-06-22 06:05:32 UTC (rev 7298)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiocodec/ADM_codecwma.cpp	2011-06-24 17:43:57 UTC (rev 7299)
@@ -60,7 +60,7 @@
     _channels=info->channels;
     _blockalign=_context->block_align = info->blockalign;
     _context->bit_rate = info->byterate*8;
-    _context->codec_type=CODEC_TYPE_AUDIO;
+    _context->codec_type = AVMEDIA_TYPE_AUDIO;
     switch(fourcc)
     {
       case WAV_WMA:

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_codecs/ADM_ffmp43.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_codecs/ADM_ffmp43.cpp	2011-06-22 06:05:32 UTC (rev 7298)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_codecs/ADM_ffmp43.cpp	2011-06-24 17:43:57 UTC (rev 7299)
@@ -278,16 +278,15 @@
 }
 uint8_t decoderFF::decodeHeaderOnly (void)
 {
-  if (codecId == CODEC_ID_H264)
-    _context->hurry_up = 4;
-  else
-    _context->hurry_up = 5;
-  printf ("\n[lavc] Hurry up\n");
+  _context->skip_frame = AVDISCARD_ALL;
+
+  printf ("\n[lavc] decode header only\n");
   return 1;
 }
 uint8_t decoderFF::decodeFull (void)
 {
-  _context->hurry_up = 0;
+  _context->skip_frame = AVDISCARD_DEFAULT;
+
   printf ("\n[lavc] full decoding\n");
   return 1;
 }
@@ -340,13 +339,13 @@
 
   ret = avcodec_decode_video2(_context, &_frame, &got_picture, &avpkt);
   out->_qStride = 0;		//Default = no quant
-  if (0 > ret && !_context->hurry_up)
+  if (0 > ret && _context->skip_frame <= AVDISCARD_DEFAULT)
     {
       printf ("\n[lavc] error in FFMP43/mpeg4!\n");
       printf ("[lavc] Err: %d, size :%d\n", ret, in->dataLength);
       return 0;
     }
-  if (!got_picture && !_context->hurry_up)
+  if (!got_picture && _context->skip_frame <= AVDISCARD_DEFAULT)
     {
       // Some encoder code a vop header with the 
       // vop flag set to 0
@@ -385,7 +384,7 @@
       //return 1;
       return 0;
     }
-  if (_context->hurry_up)
+  if (_context->skip_frame > AVDISCARD_DEFAULT)
     {
       out->flags = frameType ();
       return 1;
@@ -601,7 +600,8 @@
 
 uint8_t   decoderFFH264::uncompress (ADMCompressedImage * in, ADMImage * out)
 {
-  if(!_context->hurry_up) return decoderFF::uncompress (in, out);
+  if (_context->skip_frame <= AVDISCARD_DEFAULT)
+	  return decoderFF::uncompress (in, out);
   
   uint32_t nalSize, isAvc;
   av_getAVCStreamInfo(_context,&nalSize,&isAvc);

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_core/src/ADM_memcpy.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_core/src/ADM_memcpy.cpp	2011-06-22 06:05:32 UTC (rev 7298)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_core/src/ADM_memcpy.cpp	2011-06-24 17:43:57 UTC (rev 7299)
@@ -375,33 +375,7 @@
 }
 #endif /* ARCH_X86 */
 
-static struct {
-  const char *name;
-  void *(* function)(void *to, const void *from, size_t len);
-
-  uint64_t time; /* This type could be used for non-MSC build too! */
-
-  uint32_t cpu_require;
-} memcpy_method[] =
-{
-  { NULL, NULL, 0, 0 },
-  { "libc memcpy()", memcpy, 0, 0 },
 #if defined(ADM_CPU_X86)
-  { "linux kernel memcpy()", linux_kernel_memcpy, 0, 0 },
-#if defined(ADM_CPU_X86)
-  { "MMX optimized memcpy()", mmx_memcpy, 0, FF_MM_MMX },
-  { "MMXEXT optimized memcpy()", mmx2_memcpy, 0, FF_MM_MMXEXT },
-  { "SSE optimized memcpy()", sse_memcpy, 0, FF_MM_MMXEXT|FF_MM_SSE },
-#endif
-#endif /* ARCH_X86 */
-#if 0 && defined(ADM_CPU_PPC) && !defined (__APPLE__)
-  { "ppcasm_memcpy()", ppcasm_memcpy, 0, 0 },
-  { "ppcasm_cacheable_memcpy()", ppcasm_cacheable_memcpy, 0, FF_MM_ACCEL_PPC_CACHE32 },
-#endif /* ARCH_PPC && !HOST_OS_DARWIN */
-  { NULL, NULL, 0, 0 }
-};
-
-#if defined(ADM_CPU_X86)
 static unsigned long long int rdtsc(void)
 {
   unsigned long long int x;

Deleted: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_libraries/ffmpeg-0.7-rc1.tar.gz
===================================================================
(Binary files differ)

Copied: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_libraries/ffmpeg-0.8.tar.bz2 (from rev 7295, branches/avidemux_2.5_branch_gruntster/avidemux/ADM_libraries/ffmpeg-0.7-rc1.tar.gz)
===================================================================
(Binary files differ)

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_outputs/ADM_lavformat.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_outputs/ADM_lavformat.cpp	2011-06-22 06:05:32 UTC (rev 7298)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_outputs/ADM_lavformat.cpp	2011-06-24 17:43:57 UTC (rev 7299)
@@ -190,8 +190,9 @@
 
 					 break;
                 case MUXER_MATROSKA:
-                        strcpy(oc->title,"Avidemux");
-                        strcpy(oc->author,"Avidemux");
+						av_dict_set(&oc->metadata, "title", "Avidemux", 0);
+						av_dict_set(&oc->metadata, "author", "Avidemux", 0);
+
                         if(isMpeg4Compatible(info->fcc))
                         {
                                 c->codec_id = CODEC_ID_MPEG4;
@@ -225,11 +226,9 @@
                 case MUXER_MP4:
                 case MUXER_PSP:
                 {
-                        // probably a memeleak here
-                        char *foo=ADM_strdup(filename);
+                        av_dict_set(&oc->metadata, "title", ADM_GetFileName(filename), 0);
+						av_dict_set(&oc->metadata, "author", "Avidemux", 0);
 
-                        strcpy(oc->title,ADM_GetFileName(foo));
-                        strcpy(oc->author,"Avidemux");
                         if(isMpeg4Compatible(info->fcc))
                         {
                                 c->codec_id = CODEC_ID_MPEG4;
@@ -335,7 +334,7 @@
 			ADM_assert(0);
 	}
 
-	c->codec_type = CODEC_TYPE_VIDEO;
+	c->codec_type = AVMEDIA_TYPE_VIDEO;
 	c->flags=CODEC_FLAG_QSCALE;
 	c->width = info->width;
 	c->height = info->height;
@@ -442,7 +441,7 @@
                           return 0;
                           break;
           }
-          c->codec_type = CODEC_TYPE_AUDIO;
+          c->codec_type = AVMEDIA_TYPE_AUDIO;
 
           c->bit_rate = audioheader->byterate*8;
           c->rc_buffer_size=(c->bit_rate/(2*8)); // 500 ms worth
@@ -546,7 +545,7 @@
             aprintf("Adm audio dts: %"LLU"\n",pkt.dts);
             //printf("F:%f Q:%u D=%u\n",f,pkt.pts,timeInUs-_lastAudioDts);
 
-            pkt.flags |= PKT_FLAG_KEY;
+            pkt.flags |= AV_PKT_FLAG_KEY;
             pkt.data= buf;
             pkt.size= len;
             pkt.stream_index=1;
@@ -640,12 +639,12 @@
         if(_type==MUXER_MP4 || _type==MUXER_PSP || _type==MUXER_FLV || _type==MUXER_MATROSKA)
         {
             if(bitstream->flags & AVI_KEY_FRAME)
-                        pkt.flags |= PKT_FLAG_KEY;
+                        pkt.flags |= AV_PKT_FLAG_KEY;
         }else
             if(!bitstream->data[0] &&  !bitstream->data[1] && bitstream->data[2]==1)
 	{
             if(bitstream->data[3]==0xb3 || bitstream->data[3]==0xb8 ) // Seq start or gop start
-		pkt.flags |= PKT_FLAG_KEY;
+		pkt.flags |= AV_PKT_FLAG_KEY;
 		//printf("Intra\n");
 	}
     //printf("Adm video dts=:%u\n",pkt.dts);

Modified: branches/avidemux_2.5_branch_gruntster/cmake/admFFmpegBuild.cmake
===================================================================
--- branches/avidemux_2.5_branch_gruntster/cmake/admFFmpegBuild.cmake	2011-06-22 06:05:32 UTC (rev 7298)
+++ branches/avidemux_2.5_branch_gruntster/cmake/admFFmpegBuild.cmake	2011-06-24 17:43:57 UTC (rev 7299)
@@ -1,7 +1,7 @@
 include(admFFmpegUtil)
 
-set(FFMPEG_VERSION 0.7-rc1)
-set(FFMPEG_SOURCE_ARCHIVE "ffmpeg-${FFMPEG_VERSION}.tar.gz")
+set(FFMPEG_VERSION 0.8)
+set(FFMPEG_SOURCE_ARCHIVE "ffmpeg-${FFMPEG_VERSION}.tar.bz2")
 set(FFMPEG_SOURCE_ARCHIVE_DIR "ffmpeg-${FFMPEG_VERSION}")
 
 #set(FFMPEG_VERSION 26061)	# http://git.ffmpeg.org/?p=ffmpeg;a=snapshot;h=2be4fa05c5528073bcfc472d1c23f2d77b679a9d;sf=tgz
@@ -18,6 +18,7 @@
 set(FFMPEG_MUXERS  flv  matroska  mpeg1vcd  mpeg2dvd  mpeg2svcd  mpegts  mov  mp4  psp)
 set(FFMPEG_PARSERS  ac3  h263  h264  mpeg4video)
 set(FFMPEG_PROTOCOLS  file)
+set(FFMPEG_FILTERS  buffersink)
 set(FFMPEG_FLAGS  --enable-shared --disable-static --disable-everything --enable-hwaccels --enable-postproc --enable-gpl 
 				  --enable-runtime-cpudetect --disable-network --disable-ffplay --disable-ffprobe --prefix=${CMAKE_INSTALL_PREFIX})
 
@@ -70,6 +71,10 @@
 	set(FFMPEG_FLAGS ${FFMPEG_FLAGS} --enable-protocol=${protocol})
 endforeach (protocol)
 
+foreach (filter ${FFMPEG_FILTERS})
+	set(FFMPEG_FLAGS ${FFMPEG_FLAGS} --enable-filter=${filter})
+endforeach (filter)
+
 if (WIN32)
 	if (ADM_CPU_X86_32)
 		set(FFMPEG_FLAGS ${FFMPEG_FLAGS} --enable-memalign-hack)

Modified: branches/avidemux_2.5_branch_gruntster/cmake/admFFmpegPrepareTar.cmake
===================================================================
--- branches/avidemux_2.5_branch_gruntster/cmake/admFFmpegPrepareTar.cmake	2011-06-22 06:05:32 UTC (rev 7298)
+++ branches/avidemux_2.5_branch_gruntster/cmake/admFFmpegPrepareTar.cmake	2011-06-24 17:43:57 UTC (rev 7299)
@@ -6,22 +6,23 @@
 #set(SWSCALE_SOURCE_ARCHIVE "libswscale_r${SWSCALE_VERSION}.tar.gz")
 
 if (EXISTS "${LIBRARY_SOURCE_DIR}/${FFMPEG_SOURCE_ARCHIVE}") # AND EXISTS "${LIBRARY_SOURCE_DIR}/${SWSCALE_SOURCE_ARCHIVE}")
-	if (NOT EXISTS "${FFMPEG_SOURCE_DIR}/ffmpeg.c" OR NOT ${LAST_FFMPEG_VERSION} EQUAL ${FFMPEG_VERSION})
+	if (NOT EXISTS "${FFMPEG_SOURCE_DIR}/ffmpeg.c" OR NOT "${LAST_FFMPEG_VERSION}" EQUAL "${FFMPEG_VERSION}")
 		find_package(Tar)
+		message(STATUS "Extracting FFmpeg")
 
 		execute_process(COMMAND ${CMAKE_COMMAND} -E remove_directory "ffmpeg"
 					WORKING_DIRECTORY "${LIBRARY_SOURCE_DIR}")
 
-		execute_process(COMMAND ${TAR_EXECUTABLE} xvf ${FFMPEG_SOURCE_ARCHIVE}
+		execute_process(COMMAND ${TAR_EXECUTABLE} xvfj ${FFMPEG_SOURCE_ARCHIVE}
 					WORKING_DIRECTORY "${LIBRARY_SOURCE_DIR}"
 					${ffmpegExtractOutput})
 
-		execute_process(COMMAND ${CMAKE_COMMAND} -E rename "ffmpeg-0.7-rc1" "ffmpeg"
+		execute_process(COMMAND ${CMAKE_COMMAND} -E rename "${FFMPEG_SOURCE_ARCHIVE_DIR}" "ffmpeg"
 					WORKING_DIRECTORY "${LIBRARY_SOURCE_DIR}")
 
 		set(FFMPEG_PERFORM_PATCH 1)
 		set(FFMPEG_PERFORM_BUILD 1)
-	endif (NOT EXISTS "${FFMPEG_SOURCE_DIR}/ffmpeg.c" OR NOT ${LAST_FFMPEG_VERSION} EQUAL ${FFMPEG_VERSION})
+	endif (NOT EXISTS "${FFMPEG_SOURCE_DIR}/ffmpeg.c" OR NOT "${LAST_FFMPEG_VERSION}" EQUAL "${FFMPEG_VERSION}")
 
 	#if (NOT EXISTS "${FFMPEG_SOURCE_DIR}/libswscale/swscale.c" OR NOT ${LAST_SWSCALE_VERSION} EQUAL ${SWSCALE_VERSION})
 		#find_package(Tar)

Modified: branches/avidemux_2.5_branch_gruntster/cmake/patches/createPatches.sh
===================================================================
--- branches/avidemux_2.5_branch_gruntster/cmake/patches/createPatches.sh	2011-06-22 06:05:32 UTC (rev 7298)
+++ branches/avidemux_2.5_branch_gruntster/cmake/patches/createPatches.sh	2011-06-24 17:43:57 UTC (rev 7299)
@@ -2,6 +2,7 @@
 
 export curDir=$PWD
 export ffmpegPath=../../avidemux/ADM_libraries/ffmpeg
+export origFfmpegPath=../ffmpeg-0.8
 
 function updatePatch {
 	#cd $ffmpegPath
@@ -18,8 +19,8 @@
 
 	cd $ffmpegPath
 	unix2dos $1/$2
-	unix2dos $1/$2.orig
-	diff -u $1/$2.orig $1/$2 > $curDir/$1_$2.patch
+	unix2dos $origFfmpegPath/$1/$2
+	diff -u $origFfmpegPath/$1/$2 $1/$2 > $curDir/$1_$2.patch
 	cd $curDir
 	dos2unix $1_$2.patch
 }

Modified: branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_avcodec.h.patch
===================================================================
--- branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_avcodec.h.patch	2011-06-22 06:05:32 UTC (rev 7298)
+++ branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_avcodec.h.patch	2011-06-24 17:43:57 UTC (rev 7299)
@@ -1,6 +1,6 @@
---- libavcodec/avcodec.h.orig	2011-05-10 22:40:28 +0100
-+++ libavcodec/avcodec.h	2011-05-10 22:40:28 +0100
-@@ -636,6 +636,8 @@
+--- ../ffmpeg-0.8/libavcodec/avcodec.h	2011-06-23 20:23:53 +0100
++++ libavcodec/avcodec.h	2011-06-23 20:23:53 +0100
+@@ -619,6 +619,8 @@
  #define CODEC_FLAG2_PSY           0x00080000 ///< Use psycho visual optimizations.
  #define CODEC_FLAG2_SSIM          0x00100000 ///< Compute SSIM during encoding, error[] values are undefined.
  #define CODEC_FLAG2_INTRA_REFRESH 0x00200000 ///< Use periodic insertion of intra blocks instead of keyframes.
@@ -9,7 +9,7 @@
  
  /* Unsupported options :
   *              Syntax Arithmetic coding (SAC)
-@@ -1589,6 +1591,7 @@
+@@ -1594,6 +1596,7 @@
       * - decoding: unused
       */
      int rc_max_rate;
@@ -17,7 +17,7 @@
  
      /**
       * minimum bitrate
-@@ -1603,6 +1606,8 @@
+@@ -1608,6 +1611,8 @@
       * - decoding: unused
       */
      int rc_buffer_size;

Modified: branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_ffv1.c.patch
===================================================================
--- branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_ffv1.c.patch	2011-06-22 06:05:32 UTC (rev 7298)
+++ branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_ffv1.c.patch	2011-06-24 17:43:57 UTC (rev 7299)
@@ -1,6 +1,6 @@
---- libavcodec/ffv1.c.old	2010-12-20 13:49:20 +0000
-+++ libavcodec/ffv1.c	2010-12-20 13:49:20 +0000
-@@ -1734,6 +1734,8 @@
+--- ../ffmpeg-0.8/libavcodec/ffv1.c	2011-06-23 20:23:53 +0100
++++ libavcodec/ffv1.c	2011-06-23 20:23:53 +0100
+@@ -1783,6 +1783,8 @@
          clear_state(f);
      }else{
          p->key_frame= 0;

Modified: branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_h263dec.c.patch
===================================================================
--- branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_h263dec.c.patch	2011-06-22 06:05:32 UTC (rev 7298)
+++ branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_h263dec.c.patch	2011-06-24 17:43:57 UTC (rev 7299)
@@ -1,6 +1,6 @@
---- libavcodec/h263dec.c.orig	2011-05-10 22:40:29 +0100
-+++ libavcodec/h263dec.c	2011-05-10 22:40:29 +0100
-@@ -121,6 +121,25 @@
+--- ../ffmpeg-0.8/libavcodec/h263dec.c	2011-06-23 20:23:53 +0100
++++ libavcodec/h263dec.c	2011-06-23 20:23:53 +0100
+@@ -115,6 +115,25 @@
  
      return 0;
  }
@@ -26,7 +26,7 @@
  
  av_cold int ff_h263_decode_end(AVCodecContext *avctx)
  {
-@@ -437,6 +456,12 @@
+@@ -431,6 +450,12 @@
      } else {
          ret = h263_decode_picture_header(s);
      }
@@ -39,18 +39,16 @@
  
      if(ret==FRAME_SKIPPED) return get_consumed_bytes(s, buf_size);
  
-@@ -738,6 +763,14 @@
+@@ -715,6 +740,12 @@
  
  assert(s->current_picture.pict_type == s->current_picture_ptr->pict_type);
  assert(s->current_picture.pict_type == s->pict_type);
++
 +/* MEANX */
-+  if(s->current_picture_ptr)
-+      s->current_picture_ptr->opaque=pict->opaque;
++    if(s->current_picture_ptr)
++        s->current_picture_ptr->opaque=pict->opaque;
 +/* MEANX */
 +
-+
-+
-+
-     if (s->pict_type == FF_B_TYPE || s->low_delay) {
+     if (s->pict_type == AV_PICTURE_TYPE_B || s->low_delay) {
          *pict= *(AVFrame*)s->current_picture_ptr;
      } else if (s->last_picture_ptr != NULL) {

Modified: branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_h264.c.patch
===================================================================
--- branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_h264.c.patch	2011-06-22 06:05:32 UTC (rev 7298)
+++ branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_h264.c.patch	2011-06-24 17:43:57 UTC (rev 7299)
@@ -1,6 +1,6 @@
---- libavcodec/h264.c.orig	2011-04-26 23:58:23 +0100
-+++ libavcodec/h264.c	2011-05-10 22:34:57 +0100
-@@ -3458,6 +3458,20 @@
+--- ../ffmpeg-0.8/libavcodec/h264.c	2011-06-23 20:23:54 +0100
++++ libavcodec/h264.c	2011-06-23 20:23:54 +0100
+@@ -4178,6 +4178,20 @@
      { FF_PROFILE_UNKNOWN },
  };
  

Modified: branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_mpeg12.c.patch
===================================================================
--- branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_mpeg12.c.patch	2011-06-22 06:05:32 UTC (rev 7298)
+++ branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_mpeg12.c.patch	2011-06-24 17:43:57 UTC (rev 7299)
@@ -1,6 +1,6 @@
---- libavcodec/mpeg12.c.orig	2011-05-10 22:40:29 +0100
-+++ libavcodec/mpeg12.c	2011-05-10 22:40:29 +0100
-@@ -1999,6 +1999,11 @@
+--- ../ffmpeg-0.8/libavcodec/mpeg12.c	2011-06-23 20:23:54 +0100
++++ libavcodec/mpeg12.c	2011-06-23 20:23:54 +0100
+@@ -1998,6 +1998,11 @@
          ff_er_frame_end(s);
  
          MPV_frame_end(s);
@@ -10,5 +10,5 @@
 +/* MEANX */
 +
  
-         if (s->pict_type == FF_B_TYPE || s->low_delay) {
+         if (s->pict_type == AV_PICTURE_TYPE_B || s->low_delay) {
              *pict= *(AVFrame*)s->current_picture_ptr;

Modified: branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_mpeg12enc.c.patch
===================================================================
--- branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_mpeg12enc.c.patch	2011-06-22 06:05:32 UTC (rev 7298)
+++ branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_mpeg12enc.c.patch	2011-06-24 17:43:57 UTC (rev 7299)
@@ -1,5 +1,5 @@
---- libavcodec/mpeg12enc.c.old	2010-12-20 13:49:24 +0000
-+++ libavcodec/mpeg12enc.c	2010-12-20 13:49:24 +0000
+--- ../ffmpeg-0.8/libavcodec/mpeg12enc.c	2011-06-23 20:23:54 +0100
++++ libavcodec/mpeg12enc.c	2011-06-23 20:23:54 +0100
 @@ -127,10 +127,19 @@
              s->frame_rate_index= i;
          }
@@ -156,7 +156,7 @@
 +
          put_header(s, EXT_START_CODE);
          put_bits(&s->pb, 4, 8); //pic ext
-         if (s->pict_type == FF_P_TYPE || s->pict_type == FF_B_TYPE) {
+         if (s->pict_type == AV_PICTURE_TYPE_P || s->pict_type == AV_PICTURE_TYPE_B) {
 @@ -393,11 +481,16 @@
  
          assert(s->picture_structure == PICT_FRAME);

Modified: branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_mpegvideo.c.patch
===================================================================
--- branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_mpegvideo.c.patch	2011-06-22 06:05:32 UTC (rev 7298)
+++ branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_mpegvideo.c.patch	2011-06-24 17:43:57 UTC (rev 7299)
@@ -1,6 +1,6 @@
---- libavcodec/mpegvideo.c.orig	2011-05-10 22:40:30 +0100
-+++ libavcodec/mpegvideo.c	2011-05-10 22:40:29 +0100
-@@ -735,7 +735,11 @@
+--- ../ffmpeg-0.8/libavcodec/mpegvideo.c	2011-06-23 20:23:54 +0100
++++ libavcodec/mpegvideo.c	2011-06-23 20:23:54 +0100
+@@ -736,7 +736,11 @@
      FF_ALLOCZ_OR_GOTO(s->avctx, s->prev_pict_types, PREV_PICT_TYPES_BUFFER_SIZE, fail);
  
      s->parse_context.state= -1;

Modified: branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_utils.c.patch
===================================================================
--- branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_utils.c.patch	2011-06-22 06:05:32 UTC (rev 7298)
+++ branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_utils.c.patch	2011-06-24 17:43:57 UTC (rev 7299)
@@ -1,6 +1,6 @@
---- libavcodec/utils.c.orig	2011-05-10 22:40:30 +0100
-+++ libavcodec/utils.c	2011-05-10 22:40:30 +0100
-@@ -766,10 +766,12 @@
+--- ../ffmpeg-0.8/libavcodec/utils.c	2011-06-23 20:23:55 +0100
++++ libavcodec/utils.c	2011-06-23 20:23:55 +0100
+@@ -783,10 +783,12 @@
  
      if((avctx->codec->capabilities & CODEC_CAP_DELAY) || avpkt->size){
          //FIXME remove the check below _after_ ensuring that all audio check that the available space is enough

Modified: branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_vc1dec.c.patch
===================================================================
--- branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_vc1dec.c.patch	2011-06-22 06:05:32 UTC (rev 7298)
+++ branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_vc1dec.c.patch	2011-06-24 17:43:57 UTC (rev 7299)
@@ -1,6 +1,6 @@
---- libavcodec/vc1dec.c.orig	2011-04-26 23:58:23 +0100
-+++ libavcodec/vc1dec.c	2011-05-10 21:01:54 +0100
-@@ -3390,6 +3390,11 @@
+--- ../ffmpeg-0.8/libavcodec/vc1dec.c	2011-06-23 20:23:55 +0100
++++ libavcodec/vc1dec.c	2011-06-23 20:23:55 +0100
+@@ -3587,6 +3587,11 @@
          int mby_start;
      } *slices = NULL;
  

Modified: branches/avidemux_2.5_branch_gruntster/cmake/patches/libavformat_isom.c.patch
===================================================================
--- branches/avidemux_2.5_branch_gruntster/cmake/patches/libavformat_isom.c.patch	2011-06-22 06:05:32 UTC (rev 7298)
+++ branches/avidemux_2.5_branch_gruntster/cmake/patches/libavformat_isom.c.patch	2011-06-24 17:43:57 UTC (rev 7299)
@@ -1,6 +1,6 @@
---- libavformat/isom.c.orig	2011-05-10 22:40:30 +0100
-+++ libavformat/isom.c	2011-05-10 22:40:30 +0100
-@@ -234,7 +234,10 @@
+--- ../ffmpeg-0.8/libavformat/isom.c	2011-06-23 20:23:55 +0100
++++ libavformat/isom.c	2011-06-23 20:23:55 +0100
+@@ -237,7 +237,10 @@
      { CODEC_ID_MP1, MKTAG('.', 'm', 'p', '1') }, /* MPEG layer 1 */
      { CODEC_ID_MP2, MKTAG('.', 'm', 'p', '2') }, /* MPEG layer 2 */
  

Modified: branches/avidemux_2.5_branch_gruntster/cmake/patches/libavformat_matroskaenc.c.patch
===================================================================
--- branches/avidemux_2.5_branch_gruntster/cmake/patches/libavformat_matroskaenc.c.patch	2011-06-22 06:05:32 UTC (rev 7298)
+++ branches/avidemux_2.5_branch_gruntster/cmake/patches/libavformat_matroskaenc.c.patch	2011-06-24 17:43:57 UTC (rev 7299)
@@ -1,6 +1,6 @@
---- libavformat/matroskaenc.c.orig	2011-05-10 22:40:30 +0100
-+++ libavformat/matroskaenc.c	2011-05-10 22:40:30 +0100
-@@ -410,6 +410,7 @@
+--- ../ffmpeg-0.8/libavformat/matroskaenc.c	2011-06-23 20:23:55 +0100
++++ libavformat/matroskaenc.c	2011-06-23 20:23:55 +0100
+@@ -409,6 +409,7 @@
  
  static int put_xiph_codecpriv(AVFormatContext *s, AVIOContext *pb, AVCodecContext *codec)
  {
@@ -8,7 +8,7 @@
      uint8_t *header_start[3];
      int header_len[3];
      int first_header_size;
-@@ -434,6 +435,28 @@
+@@ -433,6 +434,28 @@
          avio_write(pb, header_start[j], header_len[j]);
  
      return 0;
@@ -37,28 +37,28 @@
  }
  
  static void get_aac_sample_rates(AVFormatContext *s, AVCodecContext *codec, int *sample_rate, int *output_sample_rate)
-@@ -538,6 +561,24 @@
+@@ -537,6 +560,24 @@
          put_ebml_uint (pb, MATROSKA_ID_TRACKUID        , i + 1);
          put_ebml_uint (pb, MATROSKA_ID_TRACKFLAGLACING , 0);    // no lacing (yet)
  
 + 		/**  MEANX : Add a default duration for video **/
-+ 		if(codec->codec_type==CODEC_TYPE_VIDEO)
-+ 		{
-+ 			if(codec->time_base.den && codec->time_base.num)
-+ 			{
-+ 				int num = codec->time_base.num;
-+ 				int den = codec->time_base.den;
-+ 				unsigned int default_duration;
-+ 				float period = num;
++        if(codec->codec_type == AVMEDIA_TYPE_VIDEO)
++        {
++            if(codec->time_base.den && codec->time_base.num)
++            {
++                int num = codec->time_base.num;
++                int den = codec->time_base.den;
++                unsigned int default_duration;
++                float period = num;
 + 
-+ 				period /= den;
-+ 				period *= 1000*1000*1000; // in ns
-+ 				default_duration = (unsigned int)floor(period);
-+ 				put_ebml_uint(pb, MATROSKA_ID_TRACKDEFAULTDURATION, default_duration);
-+ 			}
-+ 		}
-+ 		/**  MEANX : Add a default duration for video **/
++                period /= den;
++                period *= 1000 * 1000 * 1000; // in ns
++                default_duration = (unsigned int)floor(period);
++                put_ebml_uint(pb, MATROSKA_ID_TRACKDEFAULTDURATION, default_duration);
++            }
++        }
++        /**  MEANX : Add a default duration for video **/
 +
-         if ((tag = av_metadata_get(st->metadata, "title", NULL, 0)))
+         if ((tag = av_dict_get(st->metadata, "title", NULL, 0)))
              put_ebml_string(pb, MATROSKA_ID_TRACKNAME, tag->value);
-         tag = av_metadata_get(st->metadata, "language", NULL, 0);
+         tag = av_dict_get(st->metadata, "language", NULL, 0);

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_avcodec/encoder.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_avcodec/encoder.cpp	2011-06-22 06:05:32 UTC (rev 7298)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_avcodec/encoder.cpp	2011-06-24 17:43:57 UTC (rev 7299)
@@ -358,7 +358,7 @@
 		return ADM_VIDENC_ERR_CLOSED;
 
 	_frame.key_frame = 0;
-	_frame.pict_type = 0;
+	_frame.pict_type = (AVPictureType)0;
 
 	if (_supportedCsps[0] == ADM_CSP_YV12)
 	{
@@ -433,7 +433,6 @@
 	printf("height: %d\n", _context->height);
 	printf("gop_size: %d\n", _context->gop_size);
 	printf("pix_fmt: %d\n", _context->pix_fmt);
-	printf("rate_emu: %d\n", _context->rate_emu);
 	printf("frame_size: %d\n", _context->frame_size);
 	printf("frame_number: %d\n", _context->frame_number);
 	printf("delay: %d\n", _context->delay);
@@ -446,7 +445,7 @@
 	printf("b_quant_factor: %f\n", _context->b_quant_factor);
 	printf("rc_strategy: %d\n", _context->rc_strategy);
 	printf("b_frame_strategy: %d\n", _context->b_frame_strategy);
-	printf("hurry_up: %d\n", _context->hurry_up);
+	printf("skip_frame: %d\n", _context->skip_frame);
 	printf("rtp_payload_size: %d\n", _context->rtp_payload_size);
 	printf("mv_bits: %d\n", _context->mv_bits);
 	printf("header_bits: %d\n", _context->header_bits);
@@ -501,8 +500,6 @@
 	printf("sample_aspect_ratio: %d, %d\n", _context->sample_aspect_ratio.num, _context->sample_aspect_ratio.den);
 	printf("debug: %d\n", _context->debug);
 	printf("debug_mv: %d\n", _context->debug_mv);
-	printf("mb_qmin: %d\n", _context->mb_qmin);
-	printf("mb_qmax: %d\n", _context->mb_qmax);
 	printf("me_cmp: %d\n", _context->me_cmp);
 	printf("me_sub_cmp: %d\n", _context->me_sub_cmp);
 	printf("mb_cmp: %d\n", _context->mb_cmp);
@@ -578,7 +575,6 @@
 	printf("mv0_threshold: %d\n", _context->mv0_threshold);
 	printf("b_sensitivity: %d\n", _context->b_sensitivity);
 	printf("compression_level: %d\n", _context->compression_level);
-	printf("use_lpc: %d\n", _context->use_lpc);
 	printf("lpc_coeff_precision: %d\n", _context->lpc_coeff_precision);
 	printf("min_prediction_order: %d\n", _context->min_prediction_order);
 	printf("max_prediction_order: %d\n", _context->max_prediction_order);



From mean at mail.berlios.de  Sun Jun 26 19:14:24 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Sun, 26 Jun 2011 19:14:24 +0200
Subject: [Avidemux-svn-commit] r7300 - in
	branches/avidemux_2.6_branch_mean/avidemux_core/ADM_core:
	include src
Message-ID: <20110626171424.5BE4C482442@sheep.berlios.de>

Author: mean
Date: 2011-06-26 19:14:23 +0200 (Sun, 26 Jun 2011)
New Revision: 7300

Added:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_core/src/ADM_benchmark.cpp
Modified:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_core/include/ADM_clock.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_core/src/CMakeLists.txt
Log:
[core] Add a small benchmarl helper class

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_core/include/ADM_clock.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_core/include/ADM_clock.h	2011-06-24 17:43:57 UTC (rev 7299)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_core/include/ADM_clock.h	2011-06-26 17:14:23 UTC (rev 7300)
@@ -29,4 +29,21 @@
 
 
 };
+/**
+    \class ADMBenchmark
+*/
+class ADMBenchmark
+{
+protected:
+        uint32_t bMin,bMax,bCumul;
+        uint32_t nbRound;
+        Clock    clk;
+public:
+        ADMBenchmark();
+        void start(void);
+        void end(void);
+        void printResult(void);
+    
+
+};
 #endif

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_core/src/ADM_benchmark.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_core/src/ADM_benchmark.cpp	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_core/src/ADM_benchmark.cpp	2011-06-26 17:14:23 UTC (rev 7300)
@@ -0,0 +1,71 @@
+/***************************************************************************
+                          TLK_clock.cpp  -  description
+                             -------------------
+	Handle a simple clock/timer class
+
+	The API used returns the amound of days/hour/minute/seconds since
+		1st Jan 1970
+	As we only use part of the information (seconds and useconds) it
+	may wrap around anytime
+
+	The first time a clock is created, we store the "now date" and
+	do the computation with getTime-"now date"
+	It will wrap after 25 days, so it can be considerate safe
+
+
+    begin                : Fri Apr 20 2003
+    copyright            : (C) 2003 by mean
+    email                : fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include "ADM_default.h"
+#include "ADM_clock.h"
+/**
+    \fn
+*/
+ADMBenchmark::ADMBenchmark(void)
+{
+    bMin=1000000;
+    bMax=0;
+    bCumul=0;
+    nbRound=0;
+}
+/**
+    \fn
+*/
+void ADMBenchmark::start(void)
+{
+    clk.reset();
+}
+/**
+    \fn
+*/
+void ADMBenchmark::end(void)
+{
+    uint32_t r=clk.getElapsedMS();
+    if(r<bMin) bMin=r;
+    if(r>bMax) bMax=r;
+    bCumul+=r;
+    nbRound++;
+}
+/**
+    \fn
+*/
+void ADMBenchmark::printResult(void)
+{
+    float f=bCumul;
+    f/=nbRound;
+    ADM_info("Average Time :%f ms\n",f);
+    ADM_info("Min Time     : %d ms\n",bMin);
+    ADM_info("Max Time     : %d ms\n",bMax);
+}
+// EOF

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_core/src/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_core/src/CMakeLists.txt	2011-06-24 17:43:57 UTC (rev 7299)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_core/src/CMakeLists.txt	2011-06-26 17:14:23 UTC (rev 7300)
@@ -3,6 +3,7 @@
 	ADM_memory.cpp  ADM_misc.cpp  TLK_clock.cpp  ADM_crashdump.cpp  ADM_fileio.cpp ADM_dynamicLoading.cpp
         ADM_debug.cpp 
         ADM_queue.cpp
+        ADM_benchmark.cpp
 )
 
 ADM_ADD_SHARED_LIBRARY(ADM_core6 ${ADM_core_SRCS})



From mean at mail.berlios.de  Sun Jun 26 19:14:25 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Sun, 26 Jun 2011 19:14:25 +0200
Subject: [Avidemux-svn-commit] r7301 -
	branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUtils/src
Message-ID: <20110626171425.B6311482442@sheep.berlios.de>

Author: mean
Date: 2011-06-26 19:14:25 +0200 (Sun, 26 Jun 2011)
New Revision: 7301

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUtils/src/prefs.cpp
Log:
[core] Blind fix for building prefs.cpp with gcc 4.6, stddef.h was missing

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUtils/src/prefs.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUtils/src/prefs.cpp	2011-06-26 17:14:23 UTC (rev 7300)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreUtils/src/prefs.cpp	2011-06-26 17:14:25 UTC (rev 7301)
@@ -17,6 +17,7 @@
 
 #include "ADM_cpp.h"
 #include "ADM_default.h"
+#include "stddef.h"
 #include "ADM_quota.h"
 #include "ADM_paramList.h" 
 #include "prefs.h"



From mean at mail.berlios.de  Sun Jun 26 19:14:26 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Sun, 26 Jun 2011 19:14:26 +0200
Subject: [Avidemux-svn-commit] r7302 -
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/vdpauFilters
Message-ID: <20110626171426.DE9C2482442@sheep.berlios.de>

Author: mean
Date: 2011-06-26 19:14:26 +0200 (Sun, 26 Jun 2011)
New Revision: 7302

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/vdpauFilters/ADM_vidVdpauFilterDeint.cpp
Log:
[vdpau] Benchmark vdpauDeint process

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/vdpauFilters/ADM_vidVdpauFilterDeint.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/vdpauFilters/ADM_vidVdpauFilterDeint.cpp	2011-06-26 17:14:25 UTC (rev 7301)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/vdpauFilters/ADM_vidVdpauFilterDeint.cpp	2011-06-26 17:14:26 UTC (rev 7302)
@@ -3,7 +3,15 @@
     \author mean (C) 2010
     This is slow as we copy back and forth data to/from the video cards
     
+    On a Q6600
 
+    FullHD: 
+            Readback ~ 5 ms, RGB 2 YUV ~ 20 ms : 100% CPU
+    720
+            Readback ~ 2 ms, RGB2YUV ~ 10 ms  : 50% CPU
+            
+
+
 */
 #include "ADM_cpp.h"
 #include <list>
@@ -26,6 +34,9 @@
 #define ADM_INVALID_FRAME_NUM 0x80000000
 #define ADM_NB_SURFACES 5
 
+//#define DO_BENCHMARK
+#define NB_BENCH 100
+
 #if 0
 #define aprintf printf
 #else
@@ -469,6 +480,15 @@
         aprintf("Mixing %d %d\n",i,(int)in[i]);
     }
     //
+
+#ifdef DO_BENCHMARK
+    ADMBenchmark bmark;
+    for(int i=0;i<NB_BENCH;i++)
+    {
+        bmark.start();
+#endif
+    
+       
     // ---------- Top field ------------
     if(VDP_STATUS_OK!=admVdpau::mixerRenderWithPastAndFuture(topField, 
                 mixer,
@@ -479,7 +499,14 @@
     {
         ADM_warning("[Vdpau] Cannot mixerRender\n");
         r= false;
-    }    
+    }   
+                     
+#ifdef DO_BENCHMARK
+        bmark.end();
+    }
+    ADM_warning("Mixer Benchmark\n");
+    bmark.printResult();
+#endif 
     return r;
 }
 /**
@@ -488,6 +515,14 @@
 */
 bool vdpauVideoFilterDeint::getResult(ADMImage *image)
 {
+
+#ifdef DO_BENCHMARK
+    ADMBenchmark bmark;
+    for(int i=0;i<NB_BENCH;i++)
+    {
+        bmark.start();
+#endif
+  
     if(VDP_STATUS_OK!=admVdpau::outputSurfaceGetBitsNative(outputSurface,
                                                             tempBuffer, 
                                                             info.width,info.height))
@@ -495,7 +530,14 @@
         ADM_warning("[Vdpau] Cannot copy back data from output surface\n");
         return false;
     }
-
+  
+                     
+#ifdef DO_BENCHMARK
+        bmark.end();
+    }
+    ADM_warning("Read surface Benchmark\n");
+    bmark.printResult();
+#endif 
     // Convert from VDP_RGBA_FORMAT_B8G8R8A8 to YV12
     uint32_t sourceStride[3]={info.width*4,0,0};
     uint8_t  *sourceData[3]={tempBuffer,NULL,NULL};
@@ -512,8 +554,23 @@
     ts=destStride[2];destStride[2]=destStride[1];destStride[1]=ts;
     td=destData[1];destData[2]=destData[2];destData[1]=td;
 #endif
+
+
+#ifdef DO_BENCHMARK
+    ADMBenchmark bmark2;
+    for(int i=0;i<NB_BENCH;i++)
+    {
+        bmark2.start();
+#endif
     scaler->convertPlanes(  sourceStride,destStride,     
                             sourceData,destData);
+#ifdef DO_BENCHMARK
+        bmark2.end();
+    }
+    ADM_warning("RGB->YUV Benchmark\n");
+    bmark2.printResult();
+#endif
+
     return true;
 }
 /**



From mean at mail.berlios.de  Sun Jun 26 19:14:28 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Sun, 26 Jun 2011 19:14:28 +0200
Subject: [Avidemux-svn-commit] r7303 - in
	branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImage:
	include src
Message-ID: <20110626171428.25F05482442@sheep.berlios.de>

Author: mean
Date: 2011-06-26 19:14:27 +0200 (Sun, 26 Jun 2011)
New Revision: 7303

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImage/include/ADM_colorspace.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImage/src/ADM_colorspace.cpp
Log:
[Core] Add FAST_BILINEAR sw scale mode

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImage/include/ADM_colorspace.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImage/include/ADM_colorspace.h	2011-06-26 17:14:26 UTC (rev 7302)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImage/include/ADM_colorspace.h	2011-06-26 17:14:27 UTC (rev 7303)
@@ -24,7 +24,8 @@
     ADM_CS_BICUBLIN,
     ADM_CS_GAUSS,
     ADM_CS_SINC,
-    ADM_CS_SPLINE
+    ADM_CS_SPLINE,
+    ADM_CS_FAST_BILINEAR
 }ADMColorScaler_algo;
 /**
     \class ADMColorScaler

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImage/src/ADM_colorspace.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImage/src/ADM_colorspace.cpp	2011-06-26 17:14:26 UTC (rev 7302)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImage/src/ADM_colorspace.cpp	2011-06-26 17:14:27 UTC (rev 7303)
@@ -259,6 +259,7 @@
 #define SETAL(x) case ADM_CS_##x: flags=SWS_##x;break;
 
     SETAL(BILINEAR);
+    SETAL(FAST_BILINEAR);
     SETAL(BICUBIC);
     SETAL(LANCZOS);
     SETAL(BICUBLIN);



From mean at mail.berlios.de  Sun Jun 26 19:14:29 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Sun, 26 Jun 2011 19:14:29 +0200
Subject: [Avidemux-svn-commit] r7304 -
	branches/avidemux_2.6_branch_mean/cmake
Message-ID: <20110626171429.2E299482442@sheep.berlios.de>

Author: mean
Date: 2011-06-26 19:14:28 +0200 (Sun, 26 Jun 2011)
New Revision: 7304

Added:
   branches/avidemux_2.6_branch_mean/cmake/debianArch.cmake
Log:
[build] Put everything related to architecture in debianArch.cmake, add support for armel

Added: branches/avidemux_2.6_branch_mean/cmake/debianArch.cmake
===================================================================
--- branches/avidemux_2.6_branch_mean/cmake/debianArch.cmake	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/cmake/debianArch.cmake	2011-06-26 17:14:28 UTC (rev 7304)
@@ -0,0 +1,12 @@
+MACRO (XX4 supp arch)
+        IF(${supp})
+                SET(CPACK_DEBIAN_PACKAGE_ARCHITECTURE ${arch})
+        ENDIF(${supp})
+ENDMACRO (XX4 supp arch)
+
+MACRO(SET_DEBIAN_ARCH)
+        XX4(X86_64_SUPPORTED "amd64")
+        XX4(X86_32_SUPPORTED "i386")
+        XX4(ARMEL_SUPPORTED  "armel")
+ENDMACRO(SET_DEBIAN_ARCH)
+



From mean at mail.berlios.de  Sun Jun 26 19:14:30 2011
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Sun, 26 Jun 2011 19:14:30 +0200
Subject: [Avidemux-svn-commit] r7305 - in branches/avidemux_2.6_branch_mean:
	avidemux/cli avidemux/gtk avidemux/qt4 avidemux_core
	avidemux_plugins
Message-ID: <20110626171430.AD362482442@sheep.berlios.de>

Author: mean
Date: 2011-06-26 19:14:30 +0200 (Sun, 26 Jun 2011)
New Revision: 7305

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/cli/cliPackageDebian.cmake
   branches/avidemux_2.6_branch_mean/avidemux/gtk/gtkPackageDebian.cmake
   branches/avidemux_2.6_branch_mean/avidemux/qt4/qt4PackageDebian.cmake
   branches/avidemux_2.6_branch_mean/avidemux_core/corePackageDebian.cmake
   branches/avidemux_2.6_branch_mean/avidemux_plugins/pluginsPackageDebian.cmake
Log:
[build] use debianArch.cmake

Modified: branches/avidemux_2.6_branch_mean/avidemux/cli/cliPackageDebian.cmake
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/cli/cliPackageDebian.cmake	2011-06-26 17:14:28 UTC (rev 7304)
+++ branches/avidemux_2.6_branch_mean/avidemux/cli/cliPackageDebian.cmake	2011-06-26 17:14:30 UTC (rev 7305)
@@ -1,15 +1,12 @@
 ##############################
 # DEBIAN
 ##############################
+include(debianArch)
 SET(CPACK_SET_DESTDIR "ON")
 SET(CPACK_DEBIAN_PACKAGE_NAME "avidemux3-cli")
 SET (CPACK_GENERATOR "DEB")
 # ARCH
-IF (X86_64_SUPPORTED)
-SET(CPACK_DEBIAN_PACKAGE_ARCHITECTURE "amd64")
-ELSE (X86_64_SUPPORTED)
-SET(CPACK_DEBIAN_PACKAGE_ARCHITECTURE "i386")
-ENDIF (X86_64_SUPPORTED)
+SET_DEBIAN_ARCH()
 # Mandatory
 SET(CPACK_DEBIAN_PACKAGE_MAINTAINER "mean")
 SET(CPACK_DEBIAN_PACKAGE_DESCRIPTION "Simple video editori,main program gtk version ")

Modified: branches/avidemux_2.6_branch_mean/avidemux/gtk/gtkPackageDebian.cmake
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/gtk/gtkPackageDebian.cmake	2011-06-26 17:14:28 UTC (rev 7304)
+++ branches/avidemux_2.6_branch_mean/avidemux/gtk/gtkPackageDebian.cmake	2011-06-26 17:14:30 UTC (rev 7305)
@@ -1,15 +1,12 @@
 ##############################
 # DEBIAN
 ##############################
+include(debianArch)
 SET(CPACK_SET_DESTDIR "ON")
 SET(CPACK_DEBIAN_PACKAGE_NAME "avidemux3-gtk")
 SET (CPACK_GENERATOR "DEB")
 # ARCH
-IF (X86_64_SUPPORTED)
-SET(CPACK_DEBIAN_PACKAGE_ARCHITECTURE "amd64")
-ELSE (X86_64_SUPPORTED)
-SET(CPACK_DEBIAN_PACKAGE_ARCHITECTURE "i386")
-ENDIF (X86_64_SUPPORTED)
+SET_DEBIAN_ARCH()
 # Mandatory
 SET(CPACK_DEBIAN_PACKAGE_MAINTAINER "mean")
 SET(CPACK_DEBIAN_PACKAGE_DESCRIPTION "Simple video editor,main program gtk version ")

Modified: branches/avidemux_2.6_branch_mean/avidemux/qt4/qt4PackageDebian.cmake
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/qt4/qt4PackageDebian.cmake	2011-06-26 17:14:28 UTC (rev 7304)
+++ branches/avidemux_2.6_branch_mean/avidemux/qt4/qt4PackageDebian.cmake	2011-06-26 17:14:30 UTC (rev 7305)
@@ -1,15 +1,12 @@
 ##############################
 # DEBIAN
 ##############################
+include(debianArch)
 SET(CPACK_SET_DESTDIR "ON")
 SET(CPACK_DEBIAN_PACKAGE_NAME "avidemux3-qt4")
 SET (CPACK_GENERATOR "DEB")
 # ARCH
-IF (X86_64_SUPPORTED)
-SET(CPACK_DEBIAN_PACKAGE_ARCHITECTURE "amd64")
-ELSE (X86_64_SUPPORTED)
-SET(CPACK_DEBIAN_PACKAGE_ARCHITECTURE "i386")
-ENDIF (X86_64_SUPPORTED)
+SET_DEBIAN_ARCH()
 # Mandatory
 SET(CPACK_DEBIAN_PACKAGE_MAINTAINER "mean")
 SET(CPACK_DEBIAN_PACKAGE_DESCRIPTION "Simple video editor,main program qt4 version ")

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/corePackageDebian.cmake
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/corePackageDebian.cmake	2011-06-26 17:14:28 UTC (rev 7304)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/corePackageDebian.cmake	2011-06-26 17:14:30 UTC (rev 7305)
@@ -1,15 +1,12 @@
 ##############################
 # DEBIAN
 ##############################
+include(debianArch)
 SET(CPACK_SET_DESTDIR "ON")
 SET(CPACK_DEBIAN_PACKAGE_NAME "avidemux3-core")
 SET (CPACK_GENERATOR "DEB")
 # ARCH
-IF (X86_64_SUPPORTED)
-SET(CPACK_DEBIAN_PACKAGE_ARCHITECTURE "amd64")
-ELSE (X86_64_SUPPORTED)
-SET(CPACK_DEBIAN_PACKAGE_ARCHITECTURE "i386")
-ENDIF (X86_64_SUPPORTED)
+SET_DEBIAN_ARCH()
 # Mandatory
 SET(CPACK_DEBIAN_PACKAGE_MAINTAINER "mean")
 SET(CPACK_DEBIAN_PACKAGE_DESCRIPTION "Simple video editori,core libraries")

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/pluginsPackageDebian.cmake
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/pluginsPackageDebian.cmake	2011-06-26 17:14:28 UTC (rev 7304)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/pluginsPackageDebian.cmake	2011-06-26 17:14:30 UTC (rev 7305)
@@ -1,15 +1,12 @@
 ##############################
 # DEBIAN
 ##############################
+include(debianArch)
 SET(CPACK_SET_DESTDIR "ON")
 SET(CPACK_DEBIAN_PACKAGE_NAME "avidemux3-plugins-${PLUGIN_UI}")
 SET (CPACK_GENERATOR "DEB")
 # ARCH
-IF (X86_64_SUPPORTED)
-SET(CPACK_DEBIAN_PACKAGE_ARCHITECTURE "amd64")
-ELSE (X86_64_SUPPORTED)
-SET(CPACK_DEBIAN_PACKAGE_ARCHITECTURE "i386")
-ENDIF (X86_64_SUPPORTED)
+SET_DEBIAN_ARCH()
 # Mandatory
 SET(CPACK_DEBIAN_PACKAGE_MAINTAINER "mean")
 SET(CPACK_DEBIAN_PACKAGE_DESCRIPTION "Simple video editor, plugins ")



