<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Avidemux-svn-commit] r5333 - in	branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters:	. CurveEditor CurveEditor/qt4
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/avidemux-svn-commit/2009-September/index.html" >
   <LINK REL="made" HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r5333%20-%20in%0A%09branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters%3A%0A%09.%20CurveEditor%20CurveEditor/qt4&In-Reply-To=%3C200909161747.n8GHlflP010207%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="002544.html">
   <LINK REL="Next"  HREF="002546.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Avidemux-svn-commit] r5333 - in	branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters:	. CurveEditor CurveEditor/qt4</H1>
    <B>mean at BerliOS</B> 
    <A HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r5333%20-%20in%0A%09branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters%3A%0A%09.%20CurveEditor%20CurveEditor/qt4&In-Reply-To=%3C200909161747.n8GHlflP010207%40sheep.berlios.de%3E"
       TITLE="[Avidemux-svn-commit] r5333 - in	branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters:	. CurveEditor CurveEditor/qt4">mean at mail.berlios.de
       </A><BR>
    <I>Wed Sep 16 19:47:41 CEST 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="002544.html">[Avidemux-svn-commit] r5332 - in	branches/avidemux_2.5_branch_gruntster/avidemux: ADM_codecs	ADM_infoExtractor ADM_inputs/ADM_matroska	ADM_inputs/ADM_openDML ADM_video
</A></li>
        <LI>Next message: <A HREF="002546.html">[Avidemux-svn-commit] r5334 - in branches/avidemux_2.6_branch_mean:	avidemux/common avidemux_core/ADM_coreAudio/include	avidemux_core/ADM_coreMuxer/src	avidemux_plugins/ADM_audioDecoders/ADM_ad_vorbis	avidemux_plugins/ADM_audioEncoders/vorbis	avidemux_plugins/ADM_demuxers/Matroska
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2545">[ date ]</a>
              <a href="thread.html#2545">[ thread ]</a>
              <a href="subject.html#2545">[ subject ]</a>
              <a href="author.html#2545">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: mean
Date: 2009-09-16 19:47:34 +0200 (Wed, 16 Sep 2009)
New Revision: 5333

Added:
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/CurveEditor/
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/CurveEditor/ADM_Point.h
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/CurveEditor/ADM_PointArrayList.cpp
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/CurveEditor/ADM_PointArrayList.h
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/CurveEditor/ADM_Utils.h
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/CurveEditor/ADM_vidCurveEditor.cpp
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/CurveEditor/ADM_vidCurveEditor.h
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/CurveEditor/ADM_vidCurveEditor_param.h
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/CurveEditor/CMakeLists.txt
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/CurveEditor/qt4/
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/CurveEditor/qt4/CurveDialog.ui
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/CurveEditor/qt4/Q_CurveDialog.cpp
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/CurveEditor/qt4/Q_CurveDialog.h
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/CurveEditor/qt4/T_PaintWidget.cpp
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/CurveEditor/qt4/T_PaintWidget.h
Modified:
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/CMakeLists.txt
Log:
[plugin] Curve editor, by janec

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/CMakeLists.txt	2009-09-16 17:36:23 UTC (rev 5332)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/CMakeLists.txt	2009-09-16 17:47:34 UTC (rev 5333)
@@ -56,3 +56,4 @@
 # Dependancy toward codec &amp; pics ADD_SUBDIRECTORY(Animated)
 #ADD_SUBDIRECTORY(leakKernelDeint)
 ADD_SUBDIRECTORY(TIsophote)
+ADD_SUBDIRECTORY(CurveEditor)

Added: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/CurveEditor/ADM_Point.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/CurveEditor/ADM_Point.h	2009-09-16 17:36:23 UTC (rev 5332)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/CurveEditor/ADM_Point.h	2009-09-16 17:47:34 UTC (rev 5333)
@@ -0,0 +1,33 @@
+#ifndef POINT_H
+#define POINT_H
+
+#include &lt;stdio.h&gt;
+#include &lt;math.h&gt;
+
+#define POINT_RADIUS 6.0f
+
+typedef struct point {
+    int x;
+    int y;
+    point(int x = 0, int y = 0): x(x), y(y) {}
+    point(const point &amp;src) { x = src.x; y = src.y; }
+    point(const char *str)
+    {
+        if (str) sscanf(str, &quot;[%d;%d]&quot;, &amp;x, &amp;y);
+        else x = y = -1;
+    }
+    void set(int newx, int newy) { x = newx; y = newy; }
+    bool contains(int testx, int testy) const
+    {
+        return sqrt((testx-x)*(testx-x) + (testy-y)*(testy-y)) &lt; POINT_RADIUS;
+    }
+    int serialize(char *str)
+    {
+        return sprintf(str, &quot;[%d;%d]&quot;, x, y);
+    }
+    void print() { printf(&quot;[%d;%d]&quot;, x, y); }
+    void println() { printf(&quot;[%d;%d]\n&quot;, x, y); }
+} Point, *p_Point;
+
+#endif
+

Added: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/CurveEditor/ADM_PointArrayList.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/CurveEditor/ADM_PointArrayList.cpp	2009-09-16 17:36:23 UTC (rev 5332)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/CurveEditor/ADM_PointArrayList.cpp	2009-09-16 17:47:34 UTC (rev 5333)
@@ -0,0 +1,260 @@
+/*
+                        ADM_PointArrayList.cpp
+                        ----------------------
+    This module is specialized implementation of array list. It can insert
+    or remove points from list at specified position. Maximum capacity
+    of PointArrayList is set to value 32 (ADM_PointArrayList.h).
+    PointArrayList can be also serialized (or deserialized) to convert
+    class data into string (from string).
+    email: <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">george.janec at gmail.com</A>
+    
+    Copyright (C) 2009 Jiri Janecek
+
+    This program is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+#include &lt;stdlib.h&gt;
+#include &lt;stdio.h&gt;
+#include &lt;string.h&gt;
+
+#include &quot;ADM_Utils.h&quot;
+#include &quot;ADM_PointArrayList.h&quot;
+
+
+/*
+ * Initialization of class parameters.
+ */
+PointArrayList::PointArrayList()
+{
+    itemCount = 0;
+    reset();
+}
+
+/*
+ * Destroying whole list.
+ */
+PointArrayList::~PointArrayList()
+{
+    freeMem();
+}
+
+/*
+ * Copies parameters from input object src.
+ */
+void PointArrayList::copy(const PointArrayList &amp;src)
+{
+    freeMem();
+    itemCount = src.itemCount;
+    for (register int i = 0; i &lt; itemCount; i++)
+    {
+        items[i] = new Point(*src.items[i]);
+    }
+}
+
+/*
+ * Frees all items of list.
+ */
+void PointArrayList::freeMem()
+{
+    for (register int i = 0; i &lt; itemCount; i++)
+    {
+        if (items[i]) delete items[i];
+    }
+    memset(items, 0, sizeof(items));
+    itemCount = 0;
+}
+
+/*
+ * Sets default list.
+ */
+void PointArrayList::reset()
+{
+    freeMem();
+    items[0] = new Point(0, 0);
+    items[1] = new Point(255, 255);
+    itemCount = 2;
+}
+
+/*
+ * If list is empty returns true else returns false.
+ */
+bool PointArrayList::isEmpty() const
+{
+    return itemCount == 0;
+}
+
+/*
+ * Returns item count.
+ */
+int PointArrayList::count() const
+{
+    return itemCount;
+}
+
+/*
+ * Returns pointer to structure Point on specified position index.
+ * If index is out of bounds then resulting value is NULL.
+ */
+p_Point PointArrayList::get(const int index) const
+{
+    if (index &gt;= 0 &amp;&amp; index &lt; itemCount) return items[index];
+    if (itemCount == 0)
+    {
+        printf(&quot;Error: List is empty!\n&quot;);
+    }
+    else
+    {
+        printf(&quot;Error: Index out of bounds (0,%d)! &quot;, itemCount-1);
+        PRINT_VAR(index);
+    }
+    return NULL;
+}
+
+/*
+ * Searches list for key x (member of Point).
+ * Returns position of Point if item exists. If item does not exist, method
+ * returns insert position coded as -(insert_position + 1).
+ */
+int PointArrayList::search(const int x) const
+{
+    register int i;
+    for (i = 0; i &lt; itemCount &amp;&amp; items[i]-&gt;x &lt; x; i++)
+        ;
+    if (i == itemCount || items[i]-&gt;x != x)
+        return -(i+1);  // can't find x, returns -(insert_position + 1)
+    else
+        return i;       // successfully found, returns item index.
+}
+
+/*
+ * Inserts new Point at position index.
+ */
+bool PointArrayList::insert(const int index, int x, int y)
+{
+    if (itemCount &gt;= LIST_CAPACITY) return false;
+    
+    if (index &lt; 0 || index &gt; itemCount)
+    {
+        printf(&quot;Error: Index out of bounds (0,%d)! &quot;, itemCount);
+        PRINT_VAR(index);
+        return false;
+    }
+
+    // data shifting to the right
+    for (register int i = itemCount - 1; i &gt;= index; i--)
+    {
+        items[i+1] = items[i];
+    }
+    items[index] = new Point(x, y);  // insert at position index
+    itemCount++;
+    return true;
+}
+
+/*
+ * Removes item at position index.
+ */
+void PointArrayList::remove(const int index)
+{
+    if (itemCount &lt; 3) return;
+
+    if (index &lt; 0 || index &gt; itemCount-1)
+    {
+        printf(&quot;Error: Index out of bounds (0,%d)! &quot;, itemCount-1);
+        PRINT_VAR(index);
+        return;
+    }
+    
+    if (items[index]) delete items[index];
+    
+    // data shifting to the left
+    if (index &lt; itemCount - 1)
+    {
+        memcpy(&amp;items[index], &amp;items[index+1], (itemCount - index - 1) * sizeof(p_Point));
+    }
+    items[itemCount - 1] = NULL;
+    itemCount--;
+}
+
+/*
+ * Serializes class parameters into string.
+ */
+char *PointArrayList::serialize() const
+{
+    char *tempPtr = new char[24 + itemCount * 26 + 1];
+    char itemStr[26];
+    char *p = tempPtr;
+    p += sprintf(p, &quot;%d;&quot;, itemCount);
+    for (int i = 0; i &lt; itemCount; i++)
+    {
+        p += items[i]-&gt;serialize(p);
+        *p++ = ' ';
+    }
+    *p = '\0';
+    return tempPtr;
+}
+
+/*
+ * Restores class parameters from string.
+ */
+void PointArrayList::deserialize(char *str)
+{
+    char itemStr[26];
+    if (!str)
+    {
+        printf(&quot;Can't deserialize, because no input string specified! &quot;);
+        PRINT_VAR(str);
+        return;
+    }
+    freeMem();
+    itemCount = atoi(strtok(str, &quot;;&quot;));
+    for (int i = 0; i &lt; itemCount; i++)
+    {
+        items[i] = new Point(strtok(NULL, &quot; &quot;));
+    }
+}
+
+/* ===== Item printing methods (only for debuging) ===== */
+
+void PointArrayList::println() const
+{
+    printf(&quot;PointArrayList(c:%d):\n{&quot;, itemCount);
+    items[0]-&gt;print();
+    for (register int i = 1; i &lt; itemCount; i++)
+    {
+        printf(&quot;,&quot;);
+        items[i]-&gt;print();
+    }
+    printf(&quot;}\n&quot;);
+}
+
+void PointArrayList::printAll() const
+{
+    printf(&quot;PointArrayList(c:%d):\n{&quot;, itemCount);
+    if (items[0] == NULL)
+        printf(&quot;NULL&quot;);
+    else {
+        printf(&quot;0x%X&quot;, items[0]); items[0]-&gt;print();
+    }
+    for (register int i = 1; i &lt; LIST_CAPACITY; i++)
+    {
+        printf(&quot;,&quot;);
+        if (items[i] == NULL)
+            printf(&quot;NULL&quot;);
+        else {
+            printf(&quot;0x%X&quot;, items[i]); items[i]-&gt;print();
+        }
+    }
+    printf(&quot;}\n&quot;);
+}
+

Added: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/CurveEditor/ADM_PointArrayList.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/CurveEditor/ADM_PointArrayList.h	2009-09-16 17:36:23 UTC (rev 5332)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/CurveEditor/ADM_PointArrayList.h	2009-09-16 17:47:34 UTC (rev 5333)
@@ -0,0 +1,32 @@
+#ifndef POINT_ARRAY_LIST_H
+#define POINT_ARRAY_LIST_H
+
+#include &quot;ADM_Point.h&quot;
+
+#define LIST_CAPACITY 32
+
+
+class PointArrayList {
+private:
+    int itemCount;
+    p_Point items[LIST_CAPACITY];
+
+public:
+    PointArrayList();
+    ~PointArrayList();
+    void copy(const PointArrayList &amp;src);
+    void freeMem();
+    void reset();
+    bool isEmpty() const;
+    int count() const;
+    p_Point get(const int index) const;
+    int search(const int x) const;
+    bool insert(const int index, int x, int y);
+    void remove(const int index);
+    char *serialize() const;
+    void deserialize(char *str);
+    void println() const;
+    void printAll() const;
+};
+
+#endif // POINT_ARRAY_LIST

Added: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/CurveEditor/ADM_Utils.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/CurveEditor/ADM_Utils.h	2009-09-16 17:36:23 UTC (rev 5332)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/CurveEditor/ADM_Utils.h	2009-09-16 17:47:34 UTC (rev 5333)
@@ -0,0 +1,21 @@
+#ifndef UTILS_H
+#define UTILS_H
+
+#define PRINT_VAR(x) printf(&quot;[%s:%d] &quot;#x&quot;=%d (0x%X)\n&quot;, __FILE__, __LINE__, x, x);
+
+//#ifdef __DEBUG__
+#define PRINT_BEGIN() printf(&quot;BEGIN[%s:%d]\n&quot;, __FILE__, __LINE__);
+#define PRINT_MARK() printf(&quot;MARK[%s:%d]\n&quot;, __FILE__, __LINE__);
+#define PRINT_END() printf(&quot;END[%s:%d]\n&quot;, __FILE__, __LINE__);
+/*#else
+#define PRINT_BEGIN()
+#define PRINT_MARK()
+#define PRINT_END()
+#endif*/
+
+#define ROUND(x) ((x)&gt;=0 ? (int)((x) + 0.5f) : (int)((x) - 0.5f))
+
+#define BOUNDS(index, max) ((index) &gt;= 0 &amp;&amp; (index) &lt;= (max))
+
+#endif
+

Added: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/CurveEditor/ADM_vidCurveEditor.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/CurveEditor/ADM_vidCurveEditor.cpp	2009-09-16 17:36:23 UTC (rev 5332)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/CurveEditor/ADM_vidCurveEditor.cpp	2009-09-16 17:47:34 UTC (rev 5333)
@@ -0,0 +1,256 @@
+/*
+                        ADM_vidCurveEditor.cpp
+                        ----------------------
+    This program is creating spline curves that can be used for colour
+    adjustment. You can edit three curves in YUV colour space.
+    email: <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">george.janec at gmail.com</A>
+    
+    Copyright (C) 2009 Jiri Janecek
+
+    This program is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+#include &quot;ADM_Utils.h&quot;
+#include &quot;ADM_PointArrayList.h&quot;
+#include &quot;ADM_vidCurveEditor.h&quot;
+
+#ifdef SETS
+#undef SETS
+#endif
+#define SETS(x,y) (*couples)-&gt;setCouple(x,y)
+
+#ifdef GETS
+#undef GETS
+#endif
+#define GETS(x,y) ADM_assert(couples-&gt;getCouple(x,&amp;y))
+
+
+static FILTER_PARAM curveParam = {6,
+    {&quot;pointsY&quot;, &quot;pointsU&quot;, &quot;pointsV&quot;, &quot;tableY&quot;, &quot;tableU&quot;, &quot;tableV&quot;}
+};
+
+VF_DEFINE_FILTER_UI(
+    CurveEditor,                            // class name
+    curveParam,                             // filter parameters
+    curveEditor,                            // library name
+    QT_TR_NOOP(&quot;Color Curve Editor&quot;),       // string name
+    1,                                      // version
+    VF_COLORS,                              // family
+    QT_TR_NOOP(&quot;Color adjustment by color curves in YUV color space.&quot;));
+
+
+extern uint8_t DIA_RunCurveDialog(p_ColorCurveParam param,
+    AVDMGenericVideoStream *in);
+
+
+/*
+ * Serializes transformation table into string representation. Created string
+ * is saved to couples.
+ */
+void CurveEditor::serializeTable(const uint8_t *table, const char *name,
+    CONFcouple **couples)
+{
+    ADM_assert(table);
+    ADM_assert(name);
+    char *tempStr = new char[256 * 4 + 1];
+    ADM_assert(tempStr);
+    char *p = tempStr;
+    for (int i = 0; i &lt; 256; i++)
+    {
+        p += sprintf(p, &quot;%d,&quot;, table[i]);
+    }
+    SETS(name, tempStr);
+    delete [] tempStr;
+}
+
+/*
+ * Restores transformation table from input string to table address table.
+ */
+void CurveEditor::deserializeTable(uint8_t *table, const char *name,
+    CONFcouple *couples)
+{
+    char *token = NULL;
+    ADM_assert(table);
+    ADM_assert(name);
+    GETS(name, token);
+    ADM_assert(token);
+    token = strtok(token, &quot;,&quot;);
+    for (int i = 0; i &lt; 256; i++)
+    {
+        table[i] = (uint8_t) atoi(token);
+        token = strtok(NULL, &quot;,&quot;);
+    }
+    ADM_dealloc(token);
+}
+
+/*
+ * Creates temporary image buffer _uncompressed for uncompressed frames.
+ * If couples is not NULL then filter parameters are restored from couples
+ * else default values are adjusted.
+ */
+CurveEditor::CurveEditor(AVDMGenericVideoStream *in, CONFcouple *couples)
+{
+    ADM_assert(in);
+    _in = in;
+    memcpy(&amp;_info, _in-&gt;getInfo(), sizeof(_info));
+    _info.encoding = 1;
+    _uncompressed = new ADMImage(_in-&gt;getInfo()-&gt;width, _in-&gt;getInfo()-&gt;height);
+    ADM_assert(_uncompressed);
+
+    if (couples != NULL)
+    {
+        char *tempStr = NULL;
+        GETS(&quot;pointsY&quot;,tempStr);
+        _param.points[0].deserialize(tempStr);
+        if (tempStr) ADM_dealloc(tempStr);
+        GETS(&quot;pointsU&quot;,tempStr);
+        _param.points[1].deserialize(tempStr);
+        if (tempStr) ADM_dealloc(tempStr);
+        GETS(&quot;pointsV&quot;,tempStr);
+        _param.points[2].deserialize(tempStr);
+        if (tempStr) ADM_dealloc(tempStr);
+        deserializeTable(_param.table[0], &quot;tableY&quot;, couples);
+        deserializeTable(_param.table[1], &quot;tableU&quot;, couples);
+        deserializeTable(_param.table[2], &quot;tableV&quot;, couples);
+    }
+    else
+    {
+        for (int i = 0; i &lt; 256; i++)
+        {
+            _param.table[0][i] = _param.table[1][i] = _param.table[2][i] = i;
+        }
+    }
+}
+
+/*
+ * Frees uncompressed image buffer.
+ */
+CurveEditor::~CurveEditor()
+{
+    delete _uncompressed;
+    _uncompressed = NULL;
+}
+
+/*
+ * Returns filter configuration in string.
+ */
+char *CurveEditor::printConf(void)
+{
+    static char buf[0xFF];
+    sprintf((char *) buf, QT_TR_NOOP(&quot;Control points count: Y:%d, U:%d, V:%d&quot;),
+        _param.points[0].count(),
+        _param.points[1].count(),
+        _param.points[2].count());
+    return buf;
+}
+
+/*
+ * Creates couples of current parameters.
+ */
+uint8_t CurveEditor::getCoupledConf(CONFcouple **couples)
+{
+    *couples = new CONFcouple(6); // Number of param in your structure
+    char *tempStr = _param.points[0].serialize();
+    SETS(&quot;pointsY&quot;, tempStr);
+    if (tempStr) delete [] tempStr;
+    tempStr = _param.points[1].serialize();
+    SETS(&quot;pointsU&quot;, tempStr);
+    if (tempStr) delete [] tempStr;
+    tempStr = _param.points[2].serialize();
+    SETS(&quot;pointsV&quot;, tempStr);
+    if (tempStr) delete [] tempStr;
+    serializeTable(_param.table[0], &quot;tableY&quot;, couples);
+    serializeTable(_param.table[1], &quot;tableU&quot;, couples);
+    serializeTable(_param.table[2], &quot;tableV&quot;, couples);
+    return 1;
+}
+
+/*
+ * Opens configuration dialog for adjusting parameters.
+ */
+uint8_t CurveEditor::configure(AVDMGenericVideoStream *in)
+{
+    _in=in;
+    return DIA_RunCurveDialog(&amp;_param, in);
+}
+
+/*
+ * Core method for applying filter at specified frame number.
+ */
+uint8_t CurveEditor::getFrameNumberNoAlloc(uint32_t frame,
+    uint32_t *len,
+    ADMImage *data,
+    uint32_t *flags)
+{
+    if(frame &gt;= _info.nb_frames)
+        return 0;
+    // read uncompressed frame
+    if(!_in-&gt;getFrameNumberNoAlloc(frame, len, _uncompressed, flags))
+        return 0;
+
+    uint8_t *in, *out;
+    uint8_t *currTable;
+
+    uint32_t stride = _info.width;
+    uint32_t hstride = stride / 2;
+    uint32_t h = _info.height;
+    uint32_t hh = h / 2;
+
+    // edit luma
+    in = YPLANE(_uncompressed);
+    out = YPLANE(data);
+    currTable = _param.table[0];
+    for (uint32_t y = 0; y &lt; h; y++)
+    {
+        for (uint32_t x = 0; x &lt; stride; x++)
+        {
+            *(out + x) = currTable[*(in + x)];  // colour transformation
+        }
+        in += stride;
+        out += stride;
+    }
+
+    // edit chroma (U)
+    in = UPLANE(_uncompressed);
+    out = UPLANE(data);
+    currTable = _param.table[1];
+    for(uint32_t y = 0; y &lt; hh; y++)
+    {
+        for (uint32_t x = 0; x &lt; hstride; x++)
+        {
+            *(out + x) = currTable[*(in + x)];
+        }
+        in += hstride;
+        out += hstride;
+    }
+
+    // edit chroma (V)
+    in = VPLANE(_uncompressed);
+    out = VPLANE(data);
+    currTable = _param.table[2];
+    for(uint32_t y = 0; y &lt; hh; y++)
+    {
+        for (uint32_t x = 0; x &lt; hstride; x++)
+        {
+            *(out + x) = currTable[*(in + x)];
+        }
+        in += hstride;
+        out += hstride;
+    }
+
+    data-&gt;copyInfo(_uncompressed);
+
+    return 1;
+}
+

Added: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/CurveEditor/ADM_vidCurveEditor.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/CurveEditor/ADM_vidCurveEditor.h	2009-09-16 17:36:23 UTC (rev 5332)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/CurveEditor/ADM_vidCurveEditor.h	2009-09-16 17:47:34 UTC (rev 5333)
@@ -0,0 +1,31 @@
+#ifndef CURVE_EDITOR_H
+#define CURVE_EDITOR_H
+
+#include &lt;stdlib.h&gt;
+#include &lt;stdio.h&gt;
+#include &lt;string.h&gt;
+
+#include &quot;ADM_default.h&quot;
+#include &quot;ADM_videoFilterDynamic.h&quot;
+
+#include &quot;ADM_vidCurveEditor_param.h&quot;
+
+
+class CurveEditor: public AVDMGenericVideoStream {
+    private:
+        void serializeTable(const uint8_t *table, const char *name, CONFcouple **couples);
+        void deserializeTable(uint8_t *table, const char *name, CONFcouple *couples);
+    protected:
+        AVDMGenericVideoStream *_in;
+        ColorCurveParam _param;
+        virtual char *printConf(void);
+    public:
+        CurveEditor(AVDMGenericVideoStream *in, CONFcouple *setup);
+        virtual ~CurveEditor();
+        virtual uint8_t getCoupledConf(CONFcouple **couples);
+        virtual uint8_t configure(AVDMGenericVideoStream *in);
+        virtual uint8_t getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
+            ADMImage *data, uint32_t *flags);
+};
+
+#endif // CURVE_EDITOR_H

Added: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/CurveEditor/ADM_vidCurveEditor_param.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/CurveEditor/ADM_vidCurveEditor_param.h	2009-09-16 17:36:23 UTC (rev 5332)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/CurveEditor/ADM_vidCurveEditor_param.h	2009-09-16 17:47:34 UTC (rev 5333)
@@ -0,0 +1,18 @@
+#ifndef CURVE_EDITOR_PARAM_H
+#define CURVE_EDITOR_PARAM_H
+
+#include &quot;ADM_PointArrayList.h&quot;
+
+/*
+ * Filter parameters.
+ */
+typedef struct
+{
+    // Lists of control points.
+    PointArrayList points[3];
+    // Transformation colour tables with bounds 0..255.
+    unsigned char table[3][256];
+} ColorCurveParam, *p_ColorCurveParam;
+
+#endif
+

Added: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/CurveEditor/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/CurveEditor/CMakeLists.txt	2009-09-16 17:36:23 UTC (rev 5332)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/CurveEditor/CMakeLists.txt	2009-09-16 17:47:34 UTC (rev 5333)
@@ -0,0 +1,16 @@
+INCLUDE(vf_plugin)
+
+
+SET(curveEditorCommon_SRCS
+    ADM_vidCurveEditor.cpp  ADM_PointArrayList.cpp
+)
+
+INCLUDE(vf_plugin_qt4)
+
+SET(curveEditorQT_SRCS  qt4/Q_CurveDialog.cpp qt4/T_PaintWidget.cpp)
+SET(curveEditorQT_HEADERS   qt4/Q_CurveDialog.h qt4/T_PaintWidget.h)
+SET(curveEditorQT_UI    qt4/CurveDialog)
+
+INIT_VIDEOFILTER_PLUGIN_QT4(ADM_vf_curveEditor_qt4
+    &quot;${curveEditorQT_SRCS}&quot; &quot;${curveEditorQT_HEADERS}&quot; &quot;${curveEditorQT_UI}&quot; &quot;${curveEditorCommon_SRCS}&quot;)
+

Added: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/CurveEditor/qt4/CurveDialog.ui
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/CurveEditor/qt4/CurveDialog.ui	2009-09-16 17:36:23 UTC (rev 5332)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/CurveEditor/qt4/CurveDialog.ui	2009-09-16 17:47:34 UTC (rev 5333)
@@ -0,0 +1,158 @@
+&lt;ui version=&quot;4.0&quot; &gt;
+ &lt;class&gt;CurveDialog&lt;/class&gt;
+ &lt;widget class=&quot;QDialog&quot; name=&quot;CurveDialog&quot; &gt;
+  &lt;property name=&quot;windowModality&quot; &gt;
+   &lt;enum&gt;Qt::WindowModal&lt;/enum&gt;
+  &lt;/property&gt;
+  &lt;property name=&quot;geometry&quot; &gt;
+   &lt;rect&gt;
+    &lt;x&gt;0&lt;/x&gt;
+    &lt;y&gt;0&lt;/y&gt;
+    &lt;width&gt;305&lt;/width&gt;
+    &lt;height&gt;100&lt;/height&gt;
+   &lt;/rect&gt;
+  &lt;/property&gt;
+  &lt;property name=&quot;focusPolicy&quot; &gt;
+   &lt;enum&gt;Qt::ClickFocus&lt;/enum&gt;
+  &lt;/property&gt;
+  &lt;property name=&quot;windowTitle&quot; &gt;
+   &lt;string&gt;Curve Editor&lt;/string&gt;
+  &lt;/property&gt;
+  &lt;layout class=&quot;QVBoxLayout&quot; name=&quot;mainVerticalLayout&quot; &gt;
+   &lt;item&gt;
+    &lt;layout class=&quot;QHBoxLayout&quot; name=&quot;curveToolsLayout&quot; &gt;
+     &lt;item&gt;
+      &lt;widget class=&quot;QComboBox&quot; name=&quot;channelComboBox&quot; &gt;
+       &lt;property name=&quot;toolTip&quot; &gt;
+        &lt;string&gt;Choose channel for editing&lt;/string&gt;
+       &lt;/property&gt;
+       &lt;property name=&quot;currentIndex&quot; &gt;
+        &lt;number&gt;0&lt;/number&gt;
+       &lt;/property&gt;
+       &lt;property name=&quot;maxCount&quot; &gt;
+        &lt;number&gt;4&lt;/number&gt;
+       &lt;/property&gt;
+       &lt;item&gt;
+        &lt;property name=&quot;text&quot; &gt;
+         &lt;string&gt;Luma (Y)&lt;/string&gt;
+        &lt;/property&gt;
+       &lt;/item&gt;
+       &lt;item&gt;
+        &lt;property name=&quot;text&quot; &gt;
+         &lt;string&gt;Chroma (U)&lt;/string&gt;
+        &lt;/property&gt;
+       &lt;/item&gt;
+       &lt;item&gt;
+        &lt;property name=&quot;text&quot; &gt;
+         &lt;string&gt;Chroma (V)&lt;/string&gt;
+        &lt;/property&gt;
+       &lt;/item&gt;
+      &lt;/widget&gt;
+     &lt;/item&gt;
+     &lt;item&gt;
+      &lt;widget class=&quot;QPushButton&quot; name=&quot;defaultButton&quot; &gt;
+       &lt;property name=&quot;sizePolicy&quot; &gt;
+        &lt;sizepolicy vsizetype=&quot;Fixed&quot; hsizetype=&quot;Fixed&quot; &gt;
+         &lt;horstretch&gt;0&lt;/horstretch&gt;
+         &lt;verstretch&gt;0&lt;/verstretch&gt;
+        &lt;/sizepolicy&gt;
+       &lt;/property&gt;
+       &lt;property name=&quot;toolTip&quot; &gt;
+        &lt;string&gt;Sets default curve&lt;/string&gt;
+       &lt;/property&gt;
+       &lt;property name=&quot;text&quot; &gt;
+        &lt;string&gt;Refresh&lt;/string&gt;
+       &lt;/property&gt;
+      &lt;/widget&gt;
+     &lt;/item&gt;
+     &lt;item&gt;
+      &lt;spacer name=&quot;horizontalSpacer&quot; &gt;
+       &lt;property name=&quot;orientation&quot; &gt;
+        &lt;enum&gt;Qt::Horizontal&lt;/enum&gt;
+       &lt;/property&gt;
+       &lt;property name=&quot;sizeType&quot; &gt;
+        &lt;enum&gt;QSizePolicy::Expanding&lt;/enum&gt;
+       &lt;/property&gt;
+       &lt;property name=&quot;sizeHint&quot; stdset=&quot;0&quot; &gt;
+        &lt;size&gt;
+         &lt;width&gt;10&lt;/width&gt;
+         &lt;height&gt;0&lt;/height&gt;
+        &lt;/size&gt;
+       &lt;/property&gt;
+      &lt;/spacer&gt;
+     &lt;/item&gt;
+     &lt;item&gt;
+      &lt;widget class=&quot;QPushButton&quot; name=&quot;helpButton&quot; &gt;
+       &lt;property name=&quot;sizePolicy&quot; &gt;
+        &lt;sizepolicy vsizetype=&quot;Fixed&quot; hsizetype=&quot;Fixed&quot; &gt;
+         &lt;horstretch&gt;0&lt;/horstretch&gt;
+         &lt;verstretch&gt;0&lt;/verstretch&gt;
+        &lt;/sizepolicy&gt;
+       &lt;/property&gt;
+       &lt;property name=&quot;text&quot; &gt;
+        &lt;string&gt;Help&lt;/string&gt;
+       &lt;/property&gt;
+      &lt;/widget&gt;
+     &lt;/item&gt;
+    &lt;/layout&gt;
+   &lt;/item&gt;
+   &lt;item&gt;
+    &lt;widget class=&quot;QDialogButtonBox&quot; name=&quot;buttonBox&quot; &gt;
+     &lt;property name=&quot;sizePolicy&quot; &gt;
+      &lt;sizepolicy vsizetype=&quot;Fixed&quot; hsizetype=&quot;Expanding&quot; &gt;
+       &lt;horstretch&gt;0&lt;/horstretch&gt;
+       &lt;verstretch&gt;0&lt;/verstretch&gt;
+      &lt;/sizepolicy&gt;
+     &lt;/property&gt;
+     &lt;property name=&quot;layoutDirection&quot; &gt;
+      &lt;enum&gt;Qt::LeftToRight&lt;/enum&gt;
+     &lt;/property&gt;
+     &lt;property name=&quot;orientation&quot; &gt;
+      &lt;enum&gt;Qt::Horizontal&lt;/enum&gt;
+     &lt;/property&gt;
+     &lt;property name=&quot;standardButtons&quot; &gt;
+      &lt;set&gt;QDialogButtonBox::Cancel|QDialogButtonBox::Ok&lt;/set&gt;
+     &lt;/property&gt;
+     &lt;property name=&quot;centerButtons&quot; &gt;
+      &lt;bool&gt;false&lt;/bool&gt;
+     &lt;/property&gt;
+    &lt;/widget&gt;
+   &lt;/item&gt;
+  &lt;/layout&gt;
+ &lt;/widget&gt;
+ &lt;resources/&gt;
+ &lt;connections&gt;
+  &lt;connection&gt;
+   &lt;sender&gt;buttonBox&lt;/sender&gt;
+   &lt;signal&gt;accepted()&lt;/signal&gt;
+   &lt;receiver&gt;CurveDialog&lt;/receiver&gt;
+   &lt;slot&gt;accept()&lt;/slot&gt;
+   &lt;hints&gt;
+    &lt;hint type=&quot;sourcelabel&quot; &gt;
+     &lt;x&gt;257&lt;/x&gt;
+     &lt;y&gt;491&lt;/y&gt;
+    &lt;/hint&gt;
+    &lt;hint type=&quot;destinationlabel&quot; &gt;
+     &lt;x&gt;157&lt;/x&gt;
+     &lt;y&gt;274&lt;/y&gt;
+    &lt;/hint&gt;
+   &lt;/hints&gt;
+  &lt;/connection&gt;
+  &lt;connection&gt;
+   &lt;sender&gt;buttonBox&lt;/sender&gt;
+   &lt;signal&gt;rejected()&lt;/signal&gt;
+   &lt;receiver&gt;CurveDialog&lt;/receiver&gt;
+   &lt;slot&gt;reject()&lt;/slot&gt;
+   &lt;hints&gt;
+    &lt;hint type=&quot;sourcelabel&quot; &gt;
+     &lt;x&gt;264&lt;/x&gt;
+     &lt;y&gt;491&lt;/y&gt;
+    &lt;/hint&gt;
+    &lt;hint type=&quot;destinationlabel&quot; &gt;
+     &lt;x&gt;273&lt;/x&gt;
+     &lt;y&gt;274&lt;/y&gt;
+    &lt;/hint&gt;
+   &lt;/hints&gt;
+  &lt;/connection&gt;
+ &lt;/connections&gt;
+&lt;/ui&gt;

Added: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/CurveEditor/qt4/Q_CurveDialog.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/CurveEditor/qt4/Q_CurveDialog.cpp	2009-09-16 17:36:23 UTC (rev 5332)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/CurveEditor/qt4/Q_CurveDialog.cpp	2009-09-16 17:47:34 UTC (rev 5333)
@@ -0,0 +1,141 @@
+/*
+                          Q_CurveDialog.cpp
+                          -----------------
+    This module including declaration of CurveDialog class that shows main
+    dialog window of this filter. Curve painting mechanism is located in
+    PaintWidget class (T_PaintWidget.cpp).
+    email: <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">george.janec at gmail.com</A>
+    
+    Copyright (C) 2009 Jiri Janecek
+
+    This program is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+#include &lt;string.h&gt;
+
+#include &lt;QtGui/QMessageBox&gt;
+#include &lt;QtGui/QApplication&gt;
+
+#include &quot;ADM_toolkitQt.h&quot;
+
+#include &quot;Q_CurveDialog.h&quot;
+#include &quot;ADM_Utils.h&quot;
+#include &quot;ADM_vidCurveEditor_param.h&quot;
+
+
+/* =========================== *
+ *    Method implementation    *
+ * =========================== */
+
+/*
+ * Initialization of all window components (widgets) and saving input filter
+ * parameters.
+ */
+CurveDialog::CurveDialog(QWidget *parent, p_ColorCurveParam param,
+    AVDMGenericVideoStream *in) : QDialog(parent)
+{
+    setupUi(this);
+    ADM_assert(param);
+    ADM_assert(in);
+    paintWidget = new PaintWidget(this, param);
+    mainVerticalLayout-&gt;insertWidget(mainVerticalLayout-&gt;count()-1, paintWidget);
+}
+
+/*
+ * Handles key pressing events.
+ */
+void CurveDialog::keyPressEvent(QKeyEvent *event)
+{
+    if (event-&gt;key() == Qt::Key_Delete &amp;&amp; paintWidget-&gt;isSelected())
+    {
+        paintWidget-&gt;removePoint(paintWidget-&gt;getSelectedIndex());
+    }
+    else
+    {
+        QWidget::keyPressEvent(event);
+    }
+}
+
+/*
+ * Handles key releasing events.
+ */
+void CurveDialog::keyReleaseEvent(QKeyEvent *event)
+{
+    QWidget::keyReleaseEvent(event);
+}
+
+/*
+ * Changes active color channel.
+ */
+void CurveDialog::on_channelComboBox_currentIndexChanged(int index)
+{
+    paintWidget-&gt;setCurrentChannel(index);
+}
+
+/*
+ * Sets default curve on current channel.
+ */
+void CurveDialog::on_defaultButton_clicked()
+{
+    paintWidget-&gt;resetPoints();
+}
+
+/*
+ * Shows help dialog.
+ */
+void CurveDialog::on_helpButton_clicked()
+{
+    static char msg[] = &quot;&lt;h2&gt;Color Curve Editor for Avidemux 2.5&lt;/h2&gt;\n&quot;
+    &quot;&lt;b&gt;email: <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">george.janec at gmail.com</A>&lt;/b&gt;\n&quot;
+    &quot;&lt;p&gt;This program is creating spline curves that can be used for colour &quot;
+    &quot;adjustment. You can edit three curves in YUV colour space.&lt;/p&gt;\n&quot;
+    &quot;&lt;i&gt;Copyright (C) 2009 Jiri Janecek&lt;/i&gt;\n&quot;
+    &quot;&lt;p&gt;&lt;i&gt;This program is distributed in the hope that it will be useful, &quot;
+    &quot;but WITHOUT ANY WARRANTY; without even the implied warranty of &quot;
+    &quot;MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the &quot;
+    &quot;GNU General Public License for more details.&lt;/i&gt;&lt;/p&gt;\n&quot;
+    &quot;&lt;h3&gt;Program usage&lt;/h3&gt;\n&quot;
+    &quot;&lt;p&gt;Colour channel can be selected by pop-up list located at top-left part &quot;
+    &quot;of dialog window. Each channel is edited separately. New points can be &quot;
+    &quot;created by clicking on marked area. Moving points can be done by dragging &quot;
+    &quot;a point to a different location. Refresh button loads default curve. &quot;
+    &quot;Selected points (marked by red colour) can by erased by pressing Delete key.&lt;/p&gt;&quot;;
+    QString qtitle = QString::fromUtf8(&quot;About&quot;);
+    QString qmsg = QString::fromUtf8(msg, sizeof(msg));
+    QMessageBox::information(this, qtitle, qmsg, QMessageBox::Ok, QMessageBox::Ok);
+}
+
+
+/* ============================================================== *
+ *     Implementation of function from ADM_vidCurveEditor.cpp     *
+ * ============================================================== */
+
+/*
+ * Shows filter dialog window. If dialog is confirmed by Ok button then local
+ * changes are applied on input parameters.
+ */
+uint8_t DIA_RunCurveDialog(p_ColorCurveParam param, AVDMGenericVideoStream *in)
+{
+    uint8_t retcode = 0;
+    CurveDialog mainDiag(qtLastRegisteredDialog(), param, in);
+    qtRegisterDialog(&amp;mainDiag);
+    if (mainDiag.exec() == QDialog::Accepted)
+    {
+        mainDiag.paintWidget-&gt;applyChanges();
+        retcode = 1;
+    }
+    qtUnregisterDialog(&amp;mainDiag);
+    return retcode;
+}
+

Added: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/CurveEditor/qt4/Q_CurveDialog.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/CurveEditor/qt4/Q_CurveDialog.h	2009-09-16 17:36:23 UTC (rev 5332)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/CurveEditor/qt4/Q_CurveDialog.h	2009-09-16 17:47:34 UTC (rev 5333)
@@ -0,0 +1,33 @@
+#ifndef CURVEDIALOG_H
+#define CURVEDIALOG_H
+
+#include &lt;QtGui/QWidget&gt;
+#include &lt;QtGui/QKeyEvent&gt;
+
+#include &quot;ADM_default.h&quot;
+#include &quot;ADM_videoFilterDynamic.h&quot;
+
+#include &quot;ui_CurveDialog.h&quot;
+#include &quot;T_PaintWidget.h&quot;
+#include &quot;ADM_vidCurveEditor_param.h&quot;
+
+
+class CurveDialog : public QDialog, public Ui::CurveDialog {
+    Q_OBJECT
+
+public:
+    PaintWidget *paintWidget;
+    CurveDialog(QWidget *parent, p_ColorCurveParam param, AVDMGenericVideoStream *in);
+
+protected:
+    void keyPressEvent(QKeyEvent *event);
+    void keyReleaseEvent(QKeyEvent *event);
+
+private slots:
+    void on_channelComboBox_currentIndexChanged(int index);
+    void on_defaultButton_clicked();
+    void on_helpButton_clicked();
+};
+
+#endif // CURVEDIALOG_H
+

Added: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/CurveEditor/qt4/T_PaintWidget.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/CurveEditor/qt4/T_PaintWidget.cpp	2009-09-16 17:36:23 UTC (rev 5332)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/CurveEditor/qt4/T_PaintWidget.cpp	2009-09-16 17:47:34 UTC (rev 5333)
@@ -0,0 +1,437 @@
+/*
+                          T_PaintWidget.cpp
+                          -----------------
+    This module including declaration of PaintWidget class that paints cubic
+    Hermite spline curve.
+    email: <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">george.janec at gmail.com</A>
+    
+    Copyright (C) 2009 Jiri Janecek
+
+    This program is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program.  If not, see &lt;<A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>&gt;.
+*/
+
+#include &lt;stdlib.h&gt;
+#include &lt;math.h&gt;
+
+#include &lt;QtCore/QString&gt;
+#include &lt;QtCore/QSize&gt;
+#include &lt;QtGui/QPainter&gt;
+#include &lt;QtGui/QSizePolicy&gt;
+
+#include &quot;ADM_default.h&quot;
+
+#include &quot;T_PaintWidget.h&quot;
+#include &quot;ADM_Utils.h&quot;
+
+
+/* ======================== *
+ *    Macro declaration     *
+ * ======================== */
+
+/*
+ * Crops input value in defined bounds (min, max).
+ * Result is saved to value.
+ */
+#define CLAMP(val, min, max) \
+    (val) = (val) &lt; (min) ? (min) : (val) &gt; (max) ? (max) : (val)
+
+/*
+ * Flips vertical coordinate to convert window coords to real coords.
+ */
+#define FLIP(y) (255 - (y))
+
+/*
+ * Calculates real coordinate by scaling factor.
+ */
+#define SCALE(x) ROUND((x) * scaleFactor)
+#define RESCALE(b) ROUND((b) / scaleFactor)
+
+/*
+ * CP = Current point(index)
+ * CT = Current table(index)
+ */
+#define CP(index) p_param-&gt;points[currentChannel].get(index)
+#define CT(index) p_param-&gt;table[currentChannel][index]
+
+/*
+ * Calculates one-sided difference from point at index k.
+ */
+#define DIFF(k) (float)(CP(k+1)-&gt;y - CP(k)-&gt;y) / (CP(k+1)-&gt;x - CP(k)-&gt;x)
+
+
+/* =========================== *
+ *    Method implementation    *
+ * =========================== */
+
+/*
+ * Components are initialized here and input parameters in_param are copied to
+ * temporary variable p_param.
+ */
+PaintWidget::PaintWidget(QWidget *parent, p_ColorCurveParam param)
+    : QWidget(parent)
+{
+    setObjectName(QString::fromUtf8(&quot;PaintWidget&quot;));
+    QSizePolicy sizePolicy1(QSizePolicy::Expanding, QSizePolicy::Expanding);
+    sizePolicy1.setHorizontalStretch(0);
+    sizePolicy1.setVerticalStretch(0);
+    sizePolicy1.setHeightForWidth(this-&gt;sizePolicy().hasHeightForWidth());
+    setSizePolicy(sizePolicy1);
+    setMinimumSize(QSize(256, 256));
+    setCursor(Qt::OpenHandCursor);
+    setMouseTracking(true);
+
+    in_param = param;   // save address of original parameters
+    p_param = new ColorCurveParam();
+    p_param-&gt;points[0].copy(in_param-&gt;points[0]);
+    p_param-&gt;points[1].copy(in_param-&gt;points[1]);
+    p_param-&gt;points[2].copy(in_param-&gt;points[2]);
+    memcpy(p_param-&gt;table, in_param-&gt;table, sizeof(in_param-&gt;table));
+
+    scaleFactor = 1.0f;
+    currentChannel = 0;
+    selectedIndex = -1;
+    dragging = false;
+    *posText = '\0';        // empty string
+}
+
+/*
+ * Delete local parameters.
+ */
+PaintWidget::~PaintWidget()
+{
+    if (p_param) delete p_param;
+}
+
+/*
+ * Overwrites original parameters in_param with values stored in p_param.
+ */
+void PaintWidget::applyChanges() const
+{
+    in_param-&gt;points[0].copy(p_param-&gt;points[0]);
+    in_param-&gt;points[1].copy(p_param-&gt;points[1]);
+    in_param-&gt;points[2].copy(p_param-&gt;points[2]);
+    memcpy(in_param-&gt;table , p_param-&gt;table, sizeof(p_param-&gt;table));
+}
+
+/*
+ * Set active channel. Value must be between 0 and 2.
+ */
+void PaintWidget::setCurrentChannel(const int index)
+{
+    currentChannel = (index &gt;= 0 &amp;&amp; index &lt;= 2) ? index : 0;
+    selectedIndex = -1;
+    update();
+}
+
+/*
+ * Returns true if some point is selected else false.
+ */
+bool PaintWidget::isSelected() const
+{
+    return selectedIndex != -1;
+}
+
+/*
+ * Returns index of selected point.
+ */
+int PaintWidget::getSelectedIndex() const
+{
+    return selectedIndex;
+}
+
+/*
+ * Removes point from list at index.
+ */
+void PaintWidget::removePoint(const int index)
+{
+    p_param-&gt;points[currentChannel].remove(index);
+    generateTable();
+    if (index == selectedIndex) selectedIndex = -1;
+    update();
+}
+
+/*
+ * Sets default curve.
+ */
+void PaintWidget::resetPoints()
+{
+    p_param-&gt;points[currentChannel].reset();
+    generateTable();
+    selectedIndex = -1;
+    update();
+}
+
+/*
+ * Calculates scaling factor for adjusting curve size.
+ */
+void PaintWidget::resizeEvent(QResizeEvent *event)
+{
+    QSize s = event-&gt;size();
+    if (s.width() != s.height())
+    {
+        int newSize = s.width() &lt; s.height() ? s.width() : s.height();
+        resize(newSize, newSize);
+        scaleFactor = 256.0f / newSize;
+    }
+}
+
+/*
+ * Handles moving points over painting area.
+ */
+void PaintWidget::mouseMoveEvent(QMouseEvent *event)
+{
+    int x = SCALE(event-&gt;x());
+    int y = FLIP(SCALE(event-&gt;y()));
+    int count = p_param-&gt;points[currentChannel].count();
+    if (dragging &amp;&amp; isSelected()) {
+        if (selectedIndex == 0) {
+            CLAMP(x, 0, CP(selectedIndex + 1)-&gt;x - 1);
+        } else if (selectedIndex == count-1) {
+            CLAMP(x, CP(selectedIndex - 1)-&gt;x + 1, 255);
+        } else {
+            CLAMP(x, CP(selectedIndex - 1)-&gt;x + 1, CP(selectedIndex + 1)-&gt;x - 1);
+        }
+        CLAMP(y, 0, 255);
+        CP(selectedIndex)-&gt;set(x, y);
+        generateTable();
+        sprintf(posText, &quot;input: %d output: %d&quot;, x, y);
+    } else {
+        QWidget::mouseMoveEvent(event);
+    }
+    update();
+}
+
+/*
+ * Handles creating and selecting points by mouse clicking.
+ */
+void PaintWidget::mousePressEvent(QMouseEvent *event)
+{
+    int insPos;
+    int max = p_param-&gt;points[currentChannel].count() - 1;
+    int x = SCALE(event-&gt;x());
+    int y = SCALE(event-&gt;y());
+    if (event-&gt;button() == Qt::LeftButton
+            &amp;&amp; x &gt;= 0 &amp;&amp; x &lt;= 255 &amp;&amp; y &gt;= 0 &amp;&amp; y &lt;= 255) {
+        y = FLIP(y);
+        insPos = p_param-&gt;points[currentChannel].search(x);
+        insPos = insPos &lt; 0 ? -(insPos + 1) : insPos;
+        // testing at most 3 points around middle point
+        int i = -1;
+        while (true)
+        {
+            if (BOUNDS(insPos + i, max) &amp;&amp; CP(insPos + i)-&gt;contains(x, y))
+            {
+                selectedIndex = insPos + i;
+                break;
+            }
+            // terminating condition
+            if (i == 1)
+            {
+                if (p_param-&gt;points[currentChannel].insert(insPos, x, y))
+                {
+                    generateTable();
+                    selectedIndex = insPos;
+                }
+                else
+                {
+                    selectedIndex = -1;
+                }
+                break;
+            }
+            i++;
+        }
+        sprintf(posText, &quot;input: %d output: %d&quot;, x, y);
+        dragging = true;
+        this-&gt;setCursor(Qt::ClosedHandCursor);
+        update();
+    } else if (event-&gt;button() == Qt::RightButton) {
+        selectedIndex = -1;
+        update();
+    } else {
+        QWidget::mousePressEvent(event);
+    }
+}
+
+/*
+ * Handles mouse release event.
+ */
+void PaintWidget::mouseReleaseEvent(QMouseEvent *event)
+{
+    if (event-&gt;button() == Qt::LeftButton) {
+        *posText = '\0';
+        dragging = false;
+        this-&gt;setCursor(Qt::OpenHandCursor);
+    }
+    else {
+        QWidget::mouseReleaseEvent(event);
+    }
+}
+
+/*
+ * Draws spline on widget.
+ */
+void PaintWidget::paintEvent(QPaintEvent *event)
+{
+    QWidget::paintEvent(event);
+    QPainter painter;
+
+    painter.begin(this);
+    painter.setRenderHint(QPainter::Antialiasing);
+    painter.setBrush(Qt::blue);
+    painter.fillRect(QRect(0, 0, this-&gt;width(), this-&gt;height()), QBrush(Qt::white));
+
+    painter.setPen(QColor::fromRgb(192, 192, 192));
+    painter.drawLine(RESCALE(63), RESCALE(0), RESCALE(63), RESCALE(255));
+    painter.drawLine(RESCALE(127), RESCALE(0), RESCALE(127), RESCALE(255));
+    painter.drawLine(RESCALE(191), RESCALE(0), RESCALE(191), RESCALE(255));
+
+    painter.drawLine(RESCALE(0), RESCALE(63), RESCALE(255), RESCALE(63));
+    painter.drawLine(RESCALE(0), RESCALE(127), RESCALE(255), RESCALE(127));
+    painter.drawLine(RESCALE(0), RESCALE(191), RESCALE(255), RESCALE(191));
+
+    painter.drawLine(RESCALE(0), RESCALE(255), RESCALE(255), RESCALE(0));
+
+    // drawing spline
+    painter.setPen(Qt::black);
+    for (int i = 1; i &lt; 256; i++)
+    {
+        painter.drawLine(
+            RESCALE(i-1), RESCALE(FLIP(CT(i-1))),
+            RESCALE(i), RESCALE(FLIP(CT(i)))
+        );
+    }
+
+    // drawing control points
+    for (int i = 0; i &lt; p_param-&gt;points[currentChannel].count(); i++) {
+        if (selectedIndex == i) {
+            painter.fillRect(
+                RESCALE(CP(i)-&gt;x) - 3,
+                RESCALE(FLIP(CP(i)-&gt;y)) - 3,
+                7, 7, QBrush(Qt::red)
+            );
+        }
+        else {
+            painter.fillRect(
+                RESCALE(CP(i)-&gt;x) - 3,
+                RESCALE(FLIP(CP(i)-&gt;y)) - 3,
+                7, 7, painter.brush()
+            );
+        }
+    }
+
+    if (posText[0] != '\0') {
+        painter.setFont(QFont(&quot;Arial&quot;, 10));
+        painter.drawText(6, 16, QString::fromUtf8(posText));
+    }
+
+    painter.end();
+}
+
+/*
+ * Calculates spline curve in segment between points pid1 and pid2 with
+ * tangents m1 and m2. Description of Cubic Hermite splines you can find at:
+ * <A HREF="http://en.wikipedia.org/wiki/Cubic_Hermite_spline">http://en.wikipedia.org/wiki/Cubic_Hermite_spline</A>
+ */
+inline void PaintWidget::hermiteInterp(int pid1, int pid2, float m1, float m2)
+{
+    float F1, F2, F3, F4;
+    int Q;
+    float Qf;
+    int intervalWidth = CP(pid2)-&gt;x - CP(pid1)-&gt;x;
+    float norm = 1.0f / intervalWidth;
+    float t, t2, t3;
+
+    CT(CP(pid1)-&gt;x) = CP(pid1)-&gt;y;
+    for (int i = 1; i &lt;= intervalWidth; i++) {
+        t = i * norm;
+        t2 = t * t;
+        t3 = t2 * t;
+
+        F1 = 2*t3 - 3*t2 + 1;
+        F2 = -2*t3 + 3*t2;
+        F3 = t3 - 2*t2 + t;
+        F4 = t3 - t2;
+
+        // Calculates interpolation
+        Qf = CP(pid1)-&gt;y*F1 + CP(pid2)-&gt;y*F2 + m1*intervalWidth*F3 + m2*intervalWidth*F4;
+
+        Q = ROUND(Qf);      // rounding to integer
+        CLAMP(Q, 0, 255);   // cropping values &lt;0, 255&gt;
+
+        CT(CP(pid1)-&gt;x + i) = (uint8_t) Q;
+    }
+}
+
+/*
+ * Creates transformation table. First tangents are calculated.
+ * Finally interpolation method is called.
+ * Tangents are generated by algorithm described at Wikipedia:
+ * Monotone cubic Hermite interpolation
+ * <A HREF="http://en.wikipedia.org/wiki/Monotone_cubic_interpolation">http://en.wikipedia.org/wiki/Monotone_cubic_interpolation</A>
+ */
+void PaintWidget::generateTable()
+{
+    int count = p_param-&gt;points[currentChannel].count();
+    float *m = new float[count];
+    float *sec = new float[count-1];
+
+    for (int i = 0; i &lt; CP(0)-&gt;x; i++) {
+        CT(i) = CP(0)-&gt;y;
+    }
+
+    // data preprocessing
+    for (int i = 0; i &lt; count - 1; i++) sec[i] = DIFF(i);
+
+    m[0] = DIFF(0);
+    m[count - 1] = DIFF(count - 2);
+    for (int i = 1; i &lt; count - 1; i++) m[i] = (sec[i-1] + sec[i]) / 2.0f;
+
+    for (int i = 0; i &lt; count - 1; i++)
+    {
+        float tmpSec = sec[i];
+        if (tmpSec == 0)
+        {
+            m[i] = m[i + 1] = 0;
+        }
+        else
+        {
+            float ak, bk;
+            float *m1 = &amp;m[i];
+            float *m2 = &amp;m[i + 1];
+            ak = *m1 / tmpSec;
+            bk = *m2 / tmpSec;
+            float cirEq = ak*ak + bk*bk;
+            if (cirEq &gt; 9.0f)
+            {
+                float tk = 3.0f / sqrt(cirEq);
+                *m1 = *m1 * tk;
+                *m2 = *m2 * tk;
+            }
+        }
+    }
+
+    // cubic interpolation
+    for (int i = 0; i &lt; count - 1; i++)
+    {
+        hermiteInterp(i, i + 1, m[i], m[i + 1]);
+    }
+
+    for (int i = CP(count-1)-&gt;x + 1; i &lt; 256; i++) {
+        CT(i) = CP(count-1)-&gt;y;
+    }
+    
+    delete [] m;
+    delete [] sec;
+}
+

Added: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/CurveEditor/qt4/T_PaintWidget.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/CurveEditor/qt4/T_PaintWidget.h	2009-09-16 17:36:23 UTC (rev 5332)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/CurveEditor/qt4/T_PaintWidget.h	2009-09-16 17:47:34 UTC (rev 5333)
@@ -0,0 +1,45 @@
+#ifndef PAINTWIDGET_H
+#define PAINTWIDGET_H
+
+#include &lt;QtGui/QWidget&gt;
+#include &lt;QtGui/QMouseEvent&gt;
+#include &lt;QtGui/QPaintEvent&gt;
+
+#include &quot;ADM_Point.h&quot;
+#include &quot;ADM_vidCurveEditor_param.h&quot;
+
+
+class PaintWidget : public QWidget {
+    Q_OBJECT
+
+public:
+    PaintWidget(QWidget *parent, p_ColorCurveParam param);
+    ~PaintWidget();
+    void applyChanges() const;
+    void setCurrentChannel(const int index);
+    bool isSelected() const;
+    int getSelectedIndex() const;
+    void removePoint(const int index);
+    void resetPoints();
+
+protected:
+    void resizeEvent(QResizeEvent *event);
+    void mouseMoveEvent(QMouseEvent *event);
+    void mousePressEvent(QMouseEvent *event);
+    void mouseReleaseEvent(QMouseEvent *event);
+    void paintEvent(QPaintEvent *event);
+
+private:
+    p_ColorCurveParam in_param; // input parameters
+    p_ColorCurveParam p_param;  // local copy of input parameters
+    float scaleFactor;
+    int currentChannel;
+    int selectedIndex;
+    bool dragging;
+    char posText[48];
+    void hermiteInterp(int pid1, int pid2, float m1, float m2);
+    void generateTable();
+};
+
+#endif // PAINTWIDGET_H
+


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="002544.html">[Avidemux-svn-commit] r5332 - in	branches/avidemux_2.5_branch_gruntster/avidemux: ADM_codecs	ADM_infoExtractor ADM_inputs/ADM_matroska	ADM_inputs/ADM_openDML ADM_video
</A></li>
	<LI>Next message: <A HREF="002546.html">[Avidemux-svn-commit] r5334 - in branches/avidemux_2.6_branch_mean:	avidemux/common avidemux_core/ADM_coreAudio/include	avidemux_core/ADM_coreMuxer/src	avidemux_plugins/ADM_audioDecoders/ADM_ad_vorbis	avidemux_plugins/ADM_audioEncoders/vorbis	avidemux_plugins/ADM_demuxers/Matroska
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2545">[ date ]</a>
              <a href="thread.html#2545">[ thread ]</a>
              <a href="subject.html#2545">[ subject ]</a>
              <a href="author.html#2545">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">More information about the Avidemux-svn-commit
mailing list</a><br>
</body></html>
