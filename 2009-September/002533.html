<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Avidemux-svn-commit] r5320 - in	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers:	. muxerMplex
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/avidemux-svn-commit/2009-September/index.html" >
   <LINK REL="made" HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r5320%20-%20in%0A%09branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers%3A%0A%09.%20muxerMplex&In-Reply-To=%3C200909050819.n858JDEp017038%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="002532.html">
   <LINK REL="Next"  HREF="002534.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Avidemux-svn-commit] r5320 - in	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers:	. muxerMplex</H1>
    <B>mean at BerliOS</B> 
    <A HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r5320%20-%20in%0A%09branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers%3A%0A%09.%20muxerMplex&In-Reply-To=%3C200909050819.n858JDEp017038%40sheep.berlios.de%3E"
       TITLE="[Avidemux-svn-commit] r5320 - in	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers:	. muxerMplex">mean at mail.berlios.de
       </A><BR>
    <I>Sat Sep  5 10:19:13 CEST 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="002532.html">[Avidemux-svn-commit] r5319 - in	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers:	. muxerffTS
</A></li>
        <LI>Next message: <A HREF="002534.html">[Avidemux-svn-commit] r5321 - in	branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer:	include src
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2533">[ date ]</a>
              <a href="thread.html#2533">[ thread ]</a>
              <a href="subject.html#2533">[ subject ]</a>
              <a href="author.html#2533">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: mean
Date: 2009-09-05 10:19:09 +0200 (Sat, 05 Sep 2009)
New Revision: 5320

Added:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/ADM_inout.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/ADM_mplexInput.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/ADM_mplexMuxer.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/ADM_mplexOutput.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/ADM_mthread.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/ADM_mthread.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/ADM_transfert.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/ADM_transfert.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/ac3strm_in.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/audiostrm.hpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/audiostrm_out.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/aunit.hpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/aunitbuffer.hpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/bits.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/bits.hpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/cpu_accel.c
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/cpu_accel.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/decodebufmodel.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/decodebufmodel.hpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/dtsstrm_in.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/format_codes.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/inputstrm.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/inputstrm.hpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/interact.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/interact.hpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/lpcmstrm_in.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/mjpeg_logging.c
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/mjpeg_logging.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/mjpeg_types.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/mpastrm_in.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/mpegconsts.c
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/mpegconsts.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/mplexconsts.hpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/multiplexor.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/multiplexor.hpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/outputstrm.hpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/padstrm.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/padstrm.hpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/stillsstream.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/stillsstream.hpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/streamType.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/stream_params.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/stream_params.hpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/systems.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/systems.hpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/videostrm.hpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/videostrm_in.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/videostrm_out.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/yuv4mpeg.c
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/yuv4mpeg.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/yuv4mpeg_intern.h
Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/CMakeLists.txt
Log:
[Muxer] Added mplex, verbatime from 2.5

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/CMakeLists.txt	2009-09-04 15:59:41 UTC (rev 5319)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/CMakeLists.txt	2009-09-05 08:19:09 UTC (rev 5320)
@@ -5,4 +5,5 @@
 ADD_SUBDIRECTORY(muxerFlv)
 ADD_SUBDIRECTORY(muxerMkv)
 ADD_SUBDIRECTORY(muxerffPS)
+ADD_SUBDIRECTORY(muxerMplex)
 ADD_SUBDIRECTORY(muxerffTS)

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/ADM_inout.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/ADM_inout.h	2009-09-04 15:59:41 UTC (rev 5319)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/ADM_inout.h	2009-09-05 08:19:09 UTC (rev 5320)
@@ -0,0 +1,53 @@
+//
+// C++ Interface: %{MODULE}
+//
+// Description: 
+//
+//
+// Author: %{AUTHOR} &lt;%{EMAIL}&gt;, (C) %{YEAR}
+//
+// Copyright: See COPYING file that comes with this distribution
+//
+//
+#ifndef _ADM_IN_OUT_
+#define _ADM_IN_OUT_
+
+#ifndef MAXPATHLEN
+#define MAXPATHLEN 1024
+#endif
+
+#include &quot;ADM_transfert.h&quot;
+
+class FileOutputStream : public OutputStream
+{
+public:
+    FileOutputStream( const char *filename_pat );
+    virtual int  Open( );
+    virtual void Close();
+    virtual off_t SegmentSize( );
+    virtual void NextSegment();
+    virtual void Write(uint8_t *data, unsigned int len);
+
+private:
+    FILE *strm;
+    int strm_fd;
+    char filename_pat[MAXPATHLEN];
+    char cur_filename[MAXPATHLEN];
+
+};
+
+class IFileBitStream : public IBitStream
+{
+public:
+        IFileBitStream( PacketQueue *inQueue, mplexStreamDescriptor *streamDesc,unsigned int buf_size = BUFFER_SIZE);
+        ~IFileBitStream();
+
+private:
+        PacketQueue       *queue;
+        virtual size_t ReadStreamBytes( uint8_t *buf, size_t number ) ;
+        virtual bool EndOfStream() ;
+        
+};
+
+#endif
+//EOF

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/ADM_mplexInput.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/ADM_mplexInput.cpp	2009-09-04 15:59:41 UTC (rev 5319)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/ADM_mplexInput.cpp	2009-09-05 08:19:09 UTC (rev 5320)
@@ -0,0 +1,90 @@
+
+#include &quot;ADM_default.h&quot;
+#include &quot;ADM_threads.h&quot;
+#include &quot;interact.hpp&quot;
+
+#undef malloc
+#undef realloc
+#undef free
+
+
+
+#include &quot;ADM_osSupport/ADM_debugID.h&quot;
+#define MODULE_NAME MODULE_LAVFORMAT
+#include &quot;ADM_osSupport/ADM_debug.h&quot;
+
+#include &quot;cpu_accel.h&quot;
+#include &quot;mjpeg_types.h&quot;
+#include &quot;mjpeg_logging.h&quot;
+#include &quot;mpegconsts.h&quot;
+
+#include &quot;bits.hpp&quot;
+#include &quot;outputstrm.hpp&quot;
+#include &quot;multiplexor.hpp&quot;
+
+#include &quot;ADM_inout.h&quot;
+#include &quot;ADM_transfert.h&quot;
+
+
+/******************************************************************************/
+/********************************
+ *
+ * IFileBitStream - Input bit stream class for bit streams sourced
+ * from standard file I/O (this of course *includes* network sockets,
+ * fifo's, et al).
+ *
+ * OLAF: To hook into your PES reader/reconstructor you need to define
+ * a class like this one, where 'ReadStreamBytes' calls you code to
+ * generate the required number of bytes of ES data and transfer it 
+ * to the specified buffer.  The logical way to do this would be to
+ * inherit IBitStream as a base class of the top-level classes for the ES
+ * reconstructors.
+ *
+ ********************************/
+
+bool IFileBitStream::EndOfStream(void) 
+{
+        if(queue-&gt;isEof()) return true;
+        return false;
+
+}
+
+IFileBitStream::IFileBitStream(PacketQueue *q, mplexStreamDescriptor *desc, unsigned int buf_size) : IBitStream(desc) //MEANX
+{
+        queue=q;        
+        SetBufSize(buf_size);
+        eobs = false;
+        byteidx = 0;
+        
+        if (!ReadIntoBuffer())
+        {
+                        ADM_assert(buffered);
+                
+        }
+        
+}
+
+
+/**
+   Destructor: close the device containing the bit stream after a read
+   process
+*/
+IFileBitStream::~IFileBitStream()
+{
+        
+        
+        Release();
+}
+/**
+
+*/
+ size_t IFileBitStream::ReadStreamBytes( uint8_t *buf, size_t number )
+ {
+uint32_t s,z;
+        if(!queue-&gt;Pop(buf,&amp;z,&amp;s)) return 0;
+      ADM_assert(z);
+      ADM_assert(z&lt;=number);
+        return z;
+ }
+ //EOF
+ 

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/ADM_mplexMuxer.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/ADM_mplexMuxer.cpp	2009-09-04 15:59:41 UTC (rev 5319)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/ADM_mplexMuxer.cpp	2009-09-05 08:19:09 UTC (rev 5320)
@@ -0,0 +1,377 @@
+//
+// C++ Implementation: %{MODULE}
+//
+// Description:
+//
+//
+// Author: %{AUTHOR} &lt;%{EMAIL}&gt;, (C) %{YEAR}
+//
+// Copyright: See COPYING file that comes with this distribution
+//
+//
+
+
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include &lt;sys/stat.h&gt;
+
+#include &quot;ADM_default.h&quot;
+#include &quot;ADM_threads.h&quot;
+
+#include &quot;interact.hpp&quot;
+
+#undef malloc
+#undef realloc
+#undef free
+
+
+#include &quot;ADM_audiofilter/audioprocess.hxx&quot;
+#include &quot;ADM_audio/ADM_a52info.h&quot;
+#include &quot;avifmt.h&quot;
+#include &quot;avifmt2.h&quot;
+#include &quot;ADM_editor/ADM_Video.h&quot;
+#include &quot;ADM_outputs/ADM_lavformat.h&quot;
+
+#include &quot;ADM_osSupport/ADM_debugID.h&quot;
+#define MODULE_NAME MODULE_LAVFORMAT
+#include &quot;ADM_osSupport/ADM_debug.h&quot;
+
+#include &quot;cpu_accel.h&quot;
+#include &quot;mjpeg_types.h&quot;
+#include &quot;mjpeg_logging.h&quot;
+#include &quot;mpegconsts.h&quot;
+
+#include &quot;bits.hpp&quot;
+#include &quot;outputstrm.hpp&quot;
+#include &quot;multiplexor.hpp&quot;
+
+#include &quot;ADM_inout.h&quot;
+#include &quot;multiplexor.hpp&quot;
+
+/* 
+        Define class to handle output stream(s)
+      
+*/
+
+
+//#define VERBOSE_GOP
+
+
+/***************************************************************************/
+
+
+static PacketQueue     *channelaudio=NULL;
+static PacketQueue     *channelvideo=NULL;
+static FileOutputStream *outputStream=NULL;
+static IFileBitStream   *audioin=NULL;
+static IFileBitStream   *videoin=NULL;
+static uint32_t         fps1000;
+static int              mux_format;
+static int              slaveRunning=0;
+
+static  vector&lt;IBitStream *&gt; inputs;
+
+static int slaveThread( WAVHeader *audioheader );
+
+admMutex mutex_slaveThread_problem(&quot;mutex_slaveThread_problem&quot;);
+admCond  *cond_slaveThread_problem;
+char * kind_of_slaveThread_problem;
+unsigned int kind_of_slaveThread_problem_rc;
+extern uint8_t DIA_quota( char * msg );
+
+typedef  void * (*THRINP)(void *p);
+//___________________________________________________________________________
+mplexMuxer::mplexMuxer( void )
+{
+        _running=0;
+        _restamp=0;
+	cond_slaveThread_problem = new admCond(&amp;mutex_slaveThread_problem);
+	kind_of_slaveThread_problem = 0;
+
+	mjpeg_default_handler_verbosity(1);
+}
+//___________________________________________________________________________
+mplexMuxer::~mplexMuxer()
+{
+        close();
+}
+//___________________________________________________________________________
+uint8_t mplexMuxer::audioEof(void)
+{
+        channelaudio-&gt;Abort();
+}
+uint8_t mplexMuxer::videoEof(void)
+{
+  channelvideo-&gt;Abort();
+}
+
+//___________________________________________________________________________
+uint8_t mplexMuxer::open(const char *filename, uint32_t inbitrate,ADM_MUXER_TYPE type, aviInfo *info, WAVHeader *audioheader)
+{
+        printf(&quot;Opening mplex muxer (%s)\n&quot;,filename);
+        _running=1;
+
+        
+        channelaudio=new PacketQueue(  &quot;Mplex audioQ&quot;,TRANSFERT_SLOT,TRANSFERT_BUFFER);
+        channelvideo=new PacketQueue(  &quot;Mplex videoQ&quot;,TRANSFERT_SLOT,TRANSFERT_BUFFER);
+        
+        outputStream=new FileOutputStream ( filename );
+        
+        fps1000=info-&gt;fps1000;
+        
+        switch(type)
+        {
+                case MUXER_DVD: mux_format=MPEG_FORMAT_DVD_NAV;break; //FIXME
+                case MUXER_VCD: mux_format=MPEG_FORMAT_VCD;break;
+                case MUXER_SVCD:mux_format=MPEG_FORMAT_SVCD;break;
+                default:
+                        printf(&quot;Unknown muxing type\n&quot;);
+                        ADM_assert(0);
+        }
+        printf(&quot;mplex type is :%d\n&quot;,mux_format);
+       
+       
+        
+        printf(&quot;creating slave thread\n&quot;);
+        
+        pthread_t slave;
+        slaveRunning=1;
+        ADM_assert(!pthread_create(&amp;slave,NULL,(THRINP)slaveThread,audioheader));
+
+        ADM_usleep(1000*50); // Allow slave thread to start
+        
+        printf(&quot;Init ok\n&quot;);
+        return 1;
+}
+
+extern const char *getStrFromAudioCodec( uint32_t codec);
+static uint8_t wavToStreamType(WAVHeader *hdr,mplexStreamDescriptor *desc)
+{
+    ADM_assert(hdr);
+    desc-&gt;frequency=hdr-&gt;frequency;
+    desc-&gt;channel=hdr-&gt;channels;
+    switch(hdr-&gt;encoding)
+    {
+        case WAV_LPCM:  desc-&gt;kind= LPCM_AUDIO;break;
+        case WAV_AC3:   desc-&gt;kind=  AC3_AUDIO;;break;
+        case WAV_MP2: case WAV_MP3:   desc-&gt;kind=  MPEG_AUDIO;;break;
+        case WAV_DTS:    desc-&gt;kind=  DTS_AUDIO;;break;
+        default: return 0;
+    }
+  return 1;
+}
+
+int slaveThread( WAVHeader *audioheader )
+{
+        MultiplexJob job;
+        mplexStreamDescriptor audioDesc;
+        mplexStreamDescriptor videoDesc;
+
+        printf(&quot;[Muxer Slave Thread] Creating job &amp; muxer\n&quot;);
+        wavToStreamType(audioheader,&amp;audioDesc);
+
+        printf(&quot;output file created\n&quot;);
+        audioin=new IFileBitStream(channelaudio,&amp;audioDesc);
+        
+        printf(&quot;audio done (%s), creating video bitstream\n&quot;,getStrFromAudioCodec(audioheader-&gt;encoding));
+        videoDesc.kind=MPEG_VIDEO;
+
+        videoin=new IFileBitStream(channelvideo,&amp;videoDesc);
+        
+        printf(&quot;Both stream ready\n&quot;);
+         
+        inputs.push_back( videoin );
+        inputs.push_back( audioin );
+        
+        job.mux_format=mux_format;
+        job.SetupInputStreams( inputs );
+
+        Multiplexor mux(job, *outputStream);
+               
+        printf(&quot;[Muxer Slave Thread] Muxing\n&quot;);
+        mux.Multiplex();
+
+        slaveRunning=0;
+        printf(&quot;[Muxer Slave Thread] Exiting\n&quot;);
+        pthread_exit(0);
+}        
+//___________________________________________________________________________
+uint8_t mplexMuxer::writeAudioPacket(uint32_t len, uint8_t *buf)
+{
+        
+        return channelaudio-&gt;Push(buf,len,0);
+}
+//___________________________________________________________________________
+uint8_t mplexMuxer::needAudio( void )
+{
+        
+       return 1;
+}
+static uint8_t seq_start_code [] = {0x00, 0x00, 0x01, 0xB3};
+static uint8_t gop_start_code [] = {0x00, 0x00, 0x01, 0xB8};
+
+//___________________________________________________________________________
+uint8_t mplexMuxer::writeVideoPacket(ADMBitstream *bitstream)
+{
+uint8_t r=0;   
+uint16_t a1,a2,a3,a4,ff;           
+        if(_restamp) // restamp timecode ?
+        {
+            if ( !memcmp(bitstream-&gt;data, seq_start_code, 4) || !memcmp(bitstream-&gt;data, gop_start_code, 4) )
+                {
+                        uint8_t *ptr;
+                        uint32_t size;
+                        
+                        ptr=bitstream-&gt;data;
+                        size=bitstream-&gt;len;
+                        // There is a gop a or seq header
+                        if(bitstream-&gt;data[3]==0xb3) // Seq
+                        {
+                                while((ptr[0] || ptr[1] || ptr[2]!=1 || ptr[3]!=0xB8 ) &amp;&amp; size&gt;0)
+                                {
+                                        ptr++;
+                                        size--;
+                                }
+                        
+                        }
+                        if(!size || size &lt; 8) 
+                        {
+                                printf(&quot;Mplex:Gop/seq inconsistency\n&quot;);
+                        }
+                        else
+                        {       // Now we are at gop start with a packet size
+                                // Compute the current gop timestamp
+                                double newtime=bitstream-&gt;ptsFrame;
+                                uint32_t hh,mm,ss,ms;
+                                
+                                ptr+=4; // skip gop header go to timestamp
+                                
+#ifdef VERBOSE_GOP              
+                               
+                                                       
+                                a1=*ptr;
+                                a2=*(ptr+1);
+                                a3=*(ptr+2);
+                                a4=*(ptr+3);
+                                hh=(a1&gt;&gt;2)&amp;0x1f;
+                                mm=((a1&amp;3)&lt;&lt;4)+(a2&gt;&gt;4);
+                                ss=((a2&amp;7)&lt;&lt;3)+(a3&gt;&gt;5);
+                                ff=((a3&amp;0x1f)&lt;&lt;1)+(a4&gt;&gt;7);
+
+                                printf(&quot;Old : h:%02d m:%02d s:%02d f:%02d\n&quot;,hh,mm,ss,ff);
+#endif  
+                                
+                                newtime=(newtime*1000);
+                                newtime/=fps1000; // in seconds
+                                
+                                hh=(uint32_t)newtime/3600;
+                                newtime-=hh*3600;
+                                mm=(uint32_t)newtime/60;
+                                newtime-=mm*60;
+                                ss=(uint32_t)newtime;
+                                newtime-=ss;
+                                newtime*=1000;
+                                ms=(uint32_t)newtime;
+                                
+                                *(ptr+0)=(hh&lt;&lt;2)+(mm&gt;&gt;4);
+                                *(ptr+1)=((mm&amp;0xf)&lt;&lt;4)+8+(ss&gt;&gt;3);
+                                *(ptr+2)= ((ss&amp;7)&lt;&lt;5)+(ms&gt;&gt;1);
+                                *(ptr+3)&amp;=0x7f;
+                                *(ptr+3)+=(ms&amp;1) &lt;&lt;7;
+                                
+#ifdef VERBOSE_GOP              
+                               
+                                                       
+                                a1=*ptr;
+                                a2=*(ptr+1);
+                                a3=*(ptr+2);
+                                a4=*(ptr+3);
+                                hh=(a1&gt;&gt;2)&amp;0x1f;
+                                mm=((a1&amp;3)&lt;&lt;4)+(a2&gt;&gt;4);
+                                ss=((a2&amp;7)&lt;&lt;3)+(a3&gt;&gt;5);
+                                ff=((a3&amp;0x1f)&lt;&lt;1)+(a4&gt;&gt;7);
+
+                                printf(&quot;New : h:%02d m:%02d s:%02d f:%02d\n&quot;,hh,mm,ss,ff);
+#endif  
+                                
+                        
+                        }
+        
+                }
+        }
+
+        if( cond_slaveThread_problem-&gt;iswaiting() )
+        {
+               kind_of_slaveThread_problem_rc = DIA_quota(kind_of_slaveThread_problem);
+               cond_slaveThread_problem-&gt;wakeup();
+         }
+        // Check for overflow
+        // Should not happen on audio
+#warning the value is set also in mplex as BitStreamBuffering::BUFFER_SIZE
+#define INPUT_MAX_BLOCK (64*1024-1)
+        uint8_t *ptr=bitstream-&gt;data;
+        uint32_t len=bitstream-&gt;len;
+
+        while(len)
+        {
+          if(len&gt;INPUT_MAX_BLOCK)
+          {
+              channelvideo-&gt;Push(ptr,INPUT_MAX_BLOCK,0);
+              len-=INPUT_MAX_BLOCK;
+              ptr+=INPUT_MAX_BLOCK;
+          }
+          else
+          {
+            channelvideo-&gt;Push(ptr,len,0);
+            len=0;
+          }
+        }
+        return 1;
+}
+//___________________________________________________________________________
+uint8_t mplexMuxer::forceRestamp(void)
+{
+        _restamp=1;
+        return 1;
+}
+//___________________________________________________________________________
+uint8_t mplexMuxer::close( void )
+{
+        if(_running)
+        {
+                _running=0;
+                channelvideo-&gt;Abort();
+                channelaudio-&gt;Abort();
+                while(slaveRunning)
+                {
+                        printf(&quot;Waiting for slave thread to end\n&quot;);
+                        ADM_usleep(100*1000);
+                }
+                        // Flush
+                        // Cause deadlock :
+                delete audioin;
+                delete videoin;
+                delete channelvideo;
+                delete channelaudio;
+                delete outputStream;
+                inputs.erase( inputs.begin(), inputs.end() );
+                printf(&quot;Mplex : All destroyed\n&quot;);
+        }
+        return 1;
+}
+//___________________________________________________________________________
+uint8_t mplexMuxer::audioEmpty( void)
+{
+        return 0;
+}
+
+
+//EOF

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/ADM_mplexOutput.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/ADM_mplexOutput.cpp	2009-09-04 15:59:41 UTC (rev 5319)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/ADM_mplexOutput.cpp	2009-09-05 08:19:09 UTC (rev 5320)
@@ -0,0 +1,148 @@
+//
+// C++ Implementation: %{MODULE}
+//
+// Description:
+//
+//
+// Author: %{AUTHOR} &lt;%{EMAIL}&gt;, (C) %{YEAR}
+//
+// Copyright: See COPYING file that comes with this distribution
+//
+//
+
+#include &lt;sys/stat.h&gt;
+#include &lt;errno.h&gt;
+
+#include &quot;ADM_default.h&quot;
+#include &quot;ADM_threads.h&quot;
+#include &quot;interact.hpp&quot;
+
+#undef malloc
+#undef realloc
+#undef free
+
+
+
+#include &quot;ADM_osSupport/ADM_debugID.h&quot;
+#define MODULE_NAME MODULE_LAVFORMAT
+#include &quot;ADM_osSupport/ADM_debug.h&quot;
+
+#include &quot;cpu_accel.h&quot;
+#include &quot;mjpeg_types.h&quot;
+#include &quot;mjpeg_logging.h&quot;
+#include &quot;mpegconsts.h&quot;
+
+#include &quot;bits.hpp&quot;
+#include &quot;outputstrm.hpp&quot;
+#include &quot;multiplexor.hpp&quot;
+
+#include &quot;ADM_inout.h&quot;
+
+extern admMutex mutex_slaveThread_problem;
+extern admCond  *cond_slaveThread_problem;
+extern char * kind_of_slaveThread_problem;
+extern unsigned int kind_of_slaveThread_problem_rc;
+
+FileOutputStream::FileOutputStream( const char *name_pat ) 
+{
+        strncpy( filename_pat, name_pat, MAXPATHLEN );
+        snprintf( cur_filename, MAXPATHLEN, filename_pat, segment_num );
+	strm_fd = -1;
+}
+      
+int FileOutputStream::Open()
+{
+  char msg[512];
+   while( !(strm = fopen( cur_filename, &quot;wb&quot; )) ){
+      if( errno == ENOSPC
+#ifndef __MINGW32__
+                          || errno == EDQUOT
+#endif
+                                             ){
+         ADM_assert(snprintf(msg,512,&quot;can't open \&quot;%s\&quot;: %s\n%s\n&quot;,
+                             cur_filename,
+                             (errno==ENOSPC?&quot;filesystem full&quot;:&quot;quota exceeded&quot;),
+                             &quot;Please free up some space and press RETRY to try again.&quot;)!=-1);
+         mutex_slaveThread_problem.lock();
+           kind_of_slaveThread_problem = ADM_strdup(msg);
+           cond_slaveThread_problem-&gt;wait(); /* implicit mutex_slaveThread_problem.unlock(); */
+           ADM_dealloc(kind_of_slaveThread_problem);
+           kind_of_slaveThread_problem = NULL;
+         if( kind_of_slaveThread_problem_rc == 0 ){ /* ignore */
+            /* it doesn't make any sense to continue */
+            mjpeg_error_exit1( &quot;Could not open for writing: %s&quot;, cur_filename );
+         }
+      }else{
+         fprintf(stderr,&quot;can't open \&quot;%s\&quot;: %u (%s)\n&quot;, cur_filename, errno, strerror(errno));
+         ADM_assert(0);
+      }
+   }
+   strm_fd = fileno(strm);
+   return 0;
+}
+
+void FileOutputStream::Close()
+{ 
+    fclose(strm);
+    strm_fd = -1;
+}
+
+
+off_t
+FileOutputStream::SegmentSize()
+{
+        struct stat stb;
+    fstat(fileno(strm), &amp;stb);
+        off_t written = stb.st_size;
+    return written;
+}
+
+void 
+FileOutputStream::NextSegment( )
+{
+        Close();
+        ++segment_num;
+    
+        cur_filename[strlen(cur_filename)-1]++; // increase
+        Open();
+}
+
+void
+FileOutputStream::Write( uint8_t *buf, unsigned int len )
+{
+  uint8_t *p = buf;
+  unsigned int plen = len;
+  int rc;
+   ADM_assert(strm_fd != -1);
+   while( (rc=write(strm_fd,p,plen)) != plen ){
+      if( rc &gt; 0 ){
+         p+=rc;
+         plen-=rc;
+         continue;
+      }
+      if( rc == -1 &amp;&amp; (errno == ENOSPC
+#ifndef __MINGW32__
+                                       || errno == EDQUOT
+#endif
+                                                          ) ){
+        char msg[512];
+         fprintf(stderr,&quot;slaveThread: we have a problem. errno=%u\n&quot;,errno);
+         ADM_assert(snprintf(msg,512,&quot;can't write to file \&quot;%s\&quot;: %s\n%s\n&quot;,
+                             cur_filename,
+                             (errno==ENOSPC?&quot;filesystem full&quot;:&quot;quota exceeded&quot;),
+                             &quot;Please free up some space and press RETRY to try again.&quot;)!=-1);
+         mutex_slaveThread_problem.lock();
+           kind_of_slaveThread_problem = ADM_strdup(msg);
+           cond_slaveThread_problem-&gt;wait(); /* implicit mutex_slaveThread_problem.unlock(); */
+           ADM_dealloc(kind_of_slaveThread_problem);
+           kind_of_slaveThread_problem = NULL;
+         if( kind_of_slaveThread_problem_rc == 0 ){ /* ignore */
+            /* it doesn't make any sense to continue */
+            mjpeg_error_exit1( &quot;Failed write: %s&quot;, cur_filename );
+         }
+      }else{
+         mjpeg_error_exit1( &quot;Failed write: %s&quot;, cur_filename );
+      }
+   }
+}
+

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/ADM_mthread.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/ADM_mthread.cpp	2009-09-04 15:59:41 UTC (rev 5319)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/ADM_mthread.cpp	2009-09-05 08:19:09 UTC (rev 5320)
@@ -0,0 +1,129 @@
+/***************************************************************************
+    copyright            : (C) 2006 by mean
+    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
+    
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+
+#include &quot;ADM_default.h&quot;
+#include &quot;ADM_threads.h&quot;
+
+
+#include &quot;ADM_editor/ADM_edit.hxx&quot;
+#include &quot;ADM_videoFilter.h&quot;
+#include &quot;ADM_encoder/ADM_vidEncode.hxx&quot;
+#include &quot;ADM_encoder/adm_encoder.h&quot;
+#include &quot;ADM_userInterfaces/ADM_commonUI/DIA_encoding.h&quot;
+#include &quot;ADM_audiofilter/audioprocess.hxx&quot;
+#include &quot;ADM_audiofilter/audioeng_buildfilters.h&quot;
+#include &quot;ADM_outputs/ADM_lavformat.h&quot;
+#include &quot;ADM_mthread.h&quot;
+
+admMutex accessMutex(&quot;accessMutex_MT_muxer&quot;);
+
+//*******************************************************
+int defaultAudioSlave( muxerMT *context )
+{
+DIA_encoding *work=(DIA_encoding *)context-&gt;opaque;
+  uint32_t total_sample=0;
+  uint32_t total_size=0;
+  uint32_t samples,audioLen;
+  printf(&quot;[AudioThread] Starting\n&quot;);
+  while(context-&gt;audioEncoder-&gt;getPacket(context-&gt;audioBuffer, &amp;audioLen, &amp;samples) &amp;&amp; total_sample&lt;context-&gt;audioTargetSample)
+  { 
+    total_sample+=samples;
+    total_size+=audioLen;
+    accessMutex.lock();
+    if(context-&gt;audioAbort)
+    {
+      context-&gt;audioDone=1;
+      context-&gt;muxer-&gt;audioEof();
+      accessMutex.unlock();
+      return 1;
+    }
+    work-&gt;setAudioSize(total_size);
+    accessMutex.unlock();
+      
+    while(!context-&gt;muxer-&gt;needAudio()) 
+    {
+      if(context-&gt;audioAbort)
+      {
+        context-&gt;muxer-&gt;audioEof();
+        context-&gt;audioDone=1;
+        return 1;
+      } 
+    };
+    if(audioLen) 
+    {
+      context-&gt;muxer-&gt;writeAudioPacket(audioLen,context-&gt;audioBuffer); 
+    }
+    accessMutex.lock();
+    context-&gt;feedAudio+=audioLen;
+    accessMutex.unlock();
+
+  }
+  accessMutex.lock();
+  // Let's say audio is always ok, shall we :)
+  context-&gt;audioDone=1;
+  context-&gt;muxer-&gt;audioEof();
+  accessMutex.unlock();
+  printf(&quot;[AudioThread] Exiting\n&quot;);
+  printf(&quot;[AudioThread] Target %u, got %u, %f %%\n&quot;,context-&gt;audioTargetSample,total_sample,
+         (float)total_sample/(float)context-&gt;audioTargetSample);
+  return 1;
+}
+//*******************************************************
+int defaultVideoSlave( muxerMT *context )
+{
+DIA_encoding *work=(DIA_encoding *)context-&gt;opaque;
+ADMBitstream *bitstream=context-&gt;bitstream;
+uint32_t mx=context-&gt;nbVideoFrame;
+  printf(&quot;[VideoThread] Starting\n&quot;);
+  for(uint32_t i=0;i&lt;mx;i++)
+  {
+
+    bitstream-&gt;cleanup(i);
+    if(context-&gt;videoAbort)
+    {
+      context-&gt;videoDone=1;
+      context-&gt;muxer-&gt;videoEof();
+      return 1;
+    }
+    if(!context-&gt;videoEncoder-&gt;encode( i,bitstream))
+    {
+      accessMutex.lock();
+      context-&gt;videoDone=2;
+      context-&gt;muxer-&gt;videoEof();
+      accessMutex.unlock();
+  
+      return 1;
+    }
+    if(bitstream-&gt;len)
+      context-&gt;muxer-&gt;writeVideoPacket(bitstream);
+    work-&gt;setFrame(i,bitstream-&gt;len,bitstream-&gt;out_quantizer,mx);
+    accessMutex.lock();
+    context-&gt;currentVideoFrame=i;
+    context-&gt;feedVideo+=bitstream-&gt;len;
+    accessMutex.unlock();
+          
+
+  }
+  accessMutex.lock();
+  context-&gt;videoDone=1;
+  context-&gt;muxer-&gt;videoEof();
+  accessMutex.unlock();
+
+  printf(&quot;[VideoThread] Exiting\n&quot;);
+  return 1;
+}
+//EOF
+

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/ADM_mthread.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/ADM_mthread.h	2009-09-04 15:59:41 UTC (rev 5319)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/ADM_mthread.h	2009-09-05 08:19:09 UTC (rev 5320)
@@ -0,0 +1,49 @@
+/***************************************************************************
+                         Fake encoder used for copy mode
+
+        We have to reorder !
+        TODO FIXME
+
+    begin                : Sun Jul 14 2002
+    copyright            : (C) 2002/2003 by mean
+    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#ifndef ADM_MTHREADS_H
+#define ADM_MTHREADS_H
+typedef  void * (*THRINP)(void *p);
+
+extern admMutex accessMutex;
+
+typedef struct 
+{
+  Encoder                   *videoEncoder;
+  AVDMGenericAudioStream    *audioEncoder;
+  mplexMuxer                *muxer;
+  ADMBitstream              *bitstream;
+  uint32_t                  nbVideoFrame;
+  uint32_t                  audioTargetSample;
+  uint8_t                   *audioBuffer;
+  uint32_t                  audioDone;
+  uint32_t                  videoDone;
+  uint32_t                  currentVideoFrame;
+  uint32_t                  feedAudio;
+  uint32_t                  feedVideo;
+  uint32_t                  audioAbort;
+  uint32_t                  videoAbort;
+  void                      *opaque;
+}muxerMT;
+
+extern int defaultAudioSlave( muxerMT *context );
+extern int defaultVideoSlave( muxerMT *context );
+
+
+#endif

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/ADM_transfert.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/ADM_transfert.cpp	2009-09-04 15:59:41 UTC (rev 5319)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/ADM_transfert.cpp	2009-09-05 08:19:09 UTC (rev 5320)
@@ -0,0 +1,231 @@
+//
+// C++ Implementation: %{MODULE}
+//
+// Description:
+//
+//
+// Author: %{AUTHOR} &lt;%{EMAIL}&gt;, (C) %{YEAR}
+//
+// Copyright: See COPYING file that comes with this distribution
+//
+//
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include &quot;ADM_default.h&quot;
+#include &quot;ADM_threads.h&quot;
+#include &quot;ADM_transfert.h&quot;
+
+#define HIGH_LVL        ((TRANSFERT_BUFFER*2)/3)
+#define LOW_LVL         (TRANSFERT_BUFFER/3)
+// minimum amount of audio buffer we need
+#define MIN_REQUIRED    (1024*1024)
+//#define MPLEX_D
+#define threadFailure(x) if(!(x)){printf(&quot;Condition &quot;#x&quot; failed at line %d\n&quot;,__LINE__);dumpStatus();ADM_assert(0);}
+
+//**************** Transfert *******************
+// *** Lot of race here : FIXME
+#if 0
+Transfert::Transfert(uint32_t minBuffer)
+{
+        cond=new admCond(&amp;mutex);
+        clientCond=new admCond(&amp;mutex);
+        _minRequired=minBuffer;
+        buffer=new uint8_t[TRANSFERT_BUFFER];
+
+        aborted=0;
+        transfered_r=0;
+        transfered_w=0;
+        
+        head=tail=0;
+        
+}
+Transfert::~Transfert()
+{
+        delete cond;
+        delete clientCond;
+        delete [] buffer;
+        
+}
+uint8_t Transfert::dumpStatus(void)
+{
+    printf(&quot;Mplex threading status : \n&quot;);
+    printf(&quot;Aborted :%d\n&quot;,aborted);
+    printf(&quot;head :%u\n&quot;,head);
+    printf(&quot;tail :%u\n&quot;,tail);
+    printf(&quot;mutex :%u\n&quot;,mutex.isLocked());
+    printf(&quot;cond :%u\n&quot;,cond-&gt;iswaiting());
+    printf(&quot;Clientcond :%u\n&quot;,clientCond-&gt;iswaiting());
+    printf(&quot;Written : %u bytes\n&quot;,transfered_w);
+    printf(&quot;Read : %u bytes\n&quot;,transfered_r);
+
+    printf(&quot;cond waiting :%u\n&quot;,cond-&gt;waiting);
+    printf(&quot;cond aborted :%u\n&quot;,cond-&gt;aborted);
+
+    printf(&quot;clientCond waiting :%u\n&quot;,clientCond-&gt;waiting);
+    printf(&quot;clientCond aborted :%u\n&quot;,clientCond-&gt;aborted);
+
+    
+    return 1;
+}
+uint32_t Transfert:: read(uint8_t *buf, uint32_t nb  )
+{
+uint32_t r=0;
+uint32_t fill=0;
+#ifdef MPLEX_D                 
+         printf(&quot;Reading %lu\n&quot;,nb);
+#endif          
+        
+  while(1)
+  {
+        mutex.lock();
+        fill=tail-head;        
+        if(fill&gt;=nb)
+        {
+                
+                memcpy(buf,buffer+head,nb);                
+                head+=nb;
+                r+=nb;
+                transfered_r+=nb;
+                goto endit;                                                    
+        }
+        
+        // Purge
+         memcpy(buf,buffer+head,fill);
+         buf+=fill;
+         nb-=fill;
+         r+=fill;         
+         head=tail=0;
+         if(aborted) 
+         {
+                
+                goto endit;
+         }
+         if(clientCond-&gt;iswaiting()) printf(&quot;Client : %d\n&quot;,clientCond-&gt;waiting);
+         threadFailure(!clientCond-&gt;iswaiting());
+         
+#ifdef MPLEX_D      
+         printf(&quot;Wanted : %lu , left :%lu\n&quot;,nb,fill);   
+         printf(&quot;Slave sleeping\n&quot;);
+#endif         
+         
+         cond-&gt;wait();         
+         
+         if(aborted) 
+         {         
+                mutex.lock();       
+                goto endit;
+         }                                   
+  }
+endit: 
+        if(clientCond-&gt;iswaiting()) // No need to protect as the client is locked
+        {
+                fill=tail-head;       
+                if(fill&lt;LOW_LVL)
+                {
+                        printf(&quot;Waking..\n&quot;);
+                        clientCond-&gt;wakeup();        
+                }
+        }
+        mutex.unlock();
+        transfered_w+=r;
+        return r;               
+}
+//*********************************
+uint8_t Transfert::fillingUp( void)
+{
+uint8_t r=0;
+
+        mutex.lock();
+        if((tail-head)&gt;HIGH_LVL)
+                r=1;
+        else r=0;
+        mutex.unlock();
+        return r;
+        
+
+}
+uint8_t Transfert:: write(uint8_t *buf, uint32_t nb  )
+{
+        if(aborted) return 0;
+        
+#ifdef MPLEX_D                 
+         printf(&quot;Writing %lu\n&quot;,nb);
+#endif          
+        mutex.lock(); 
+        // Need to pack ?
+        if(nb+tail&gt;=TRANSFERT_BUFFER)
+        {
+                memmove(buffer,buffer+head,tail-head);
+                tail-=head;
+                head=0;
+        }
+        // Overflow ?
+        if(nb+tail&gt;=TRANSFERT_BUFFER)
+        {
+                printf(&quot;\n When writting %lu bytes, we overflow the existing %lu bytes\n&quot;,nb,tail-head);
+                threadFailure(0);
+        
+        }
+        memcpy(buffer+tail,buf,nb);       
+        transfered_w+=nb;
+        tail+=nb;
+        
+        if(cond-&gt;iswaiting())
+        {
+#ifdef MPLEX_D      
+           
+         printf(&quot;Slave waking\n&quot;);
+#endif     
+                cond-&gt;wakeup();
+        }                
+        mutex.unlock();
+        return 1;
+}        
+uint8_t Transfert::needData( void )
+{
+  int32_t l;
+  uint8_t r=0;
+        mutex.lock(); 
+        l=tail-head;
+        threadFailure(l&gt;=0);
+        mutex.unlock();
+        if(l&lt;_minRequired) r=1;
+        if(cond-&gt;iswaiting()) r=1;
+//        return cond-&gt;iswaiting();
+        return r;
+ 
+ }
+uint8_t Transfert::abort( void )
+{
+        aborted=1;
+        if(cond-&gt;iswaiting())
+                cond-&gt;abort();
+        return 1;
+ 
+ }
+  
+uint8_t Transfert::clientLock( void )
+{
+#ifdef MPLEX_D               
+         printf(&quot;Slave sleeping (%lu)\n&quot;,tail-=head);
+#endif         
+
+        mutex.lock();
+        // Redo check under same mutex lock
+        if((tail-head)&lt;HIGH_LVL)
+        {
+            mutex.unlock();
+            return 1;
+        }
+        clientCond-&gt;wait();               
+        return 1;
+
+}
+#endif

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/ADM_transfert.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/ADM_transfert.h	2009-09-04 15:59:41 UTC (rev 5319)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/ADM_transfert.h	2009-09-05 08:19:09 UTC (rev 5320)
@@ -0,0 +1,22 @@
+//
+// C++ Interface: %{MODULE}
+//
+// Description: 
+//
+//
+// Author: %{AUTHOR} &lt;%{EMAIL}&gt;, (C) %{YEAR}
+//
+// Copyright: See COPYING file that comes with this distribution
+//
+//
+#ifndef _ADM_TRANSFERT_
+#define _ADM_TRANSFERT_
+
+#define TRANSFERT_BUFFER 1024*1024*10
+#define TRANSFERT_SLOT   10000
+
+
+#include &quot;ADM_toolkit/ADM_packetQueue.h&quot;
+#endif
+//EOF
+

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/CMakeLists.txt	2009-09-04 15:59:41 UTC (rev 5319)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/CMakeLists.txt	2009-09-05 08:19:09 UTC (rev 5320)
@@ -0,0 +1,33 @@
+include(mx_plugin)
+SET(ADM_LIB ADM_mx_mplex)
+
+SET(${ADM_LIB}_SRCS 
+	ADM_mplexMuxer.cpp  
+        ADM_mplexInput.cpp   
+	ADM_mplexOutput.cpp     
+	ac3strm_in.cpp      
+        audiostrm_out.cpp  dtsstrm_in.cpp  lpcmstrm_in.cpp   multiplexor.cpp   stream_params.cpp  videostrm_in.cpp
+        ADM_mthread.cpp    bits.cpp           inputstrm.cpp   padstrm.cpp       systems.cpp       videostrm_out.cpp
+        ADM_transfert.cpp  interact.cpp       mpastrm_in.cpp  stillsstream.cpp  mpegconsts.c      mjpeg_logging.c    decodebufmodel.cpp
+	yuv4mpeg.c          cpu_accel.c)
+
+include_directories(&quot;${PTHREAD_INCLUDE_DIR}&quot;)
+ADD_LIBRARY(${ADM_LIB} SHARED ${${ADM_LIB}_SRCS})
+ADD_DEFINITIONS(${ADM_LIB} &quot;-I${CMAKE_CURRENT_SOURCE_DIR} -DHAVE_FMAX -DRETSIGTYPE=void&quot;)
+
+IF (NOT APPLE)
+    ADD_DEFINITIONS(${ADM_LIB} &quot;-DHAVE_MEMALIGN&quot;)
+ENDIF (NOT APPLE)
+
+IF (ADM_CPU_X86)
+    ADD_DEFINITIONS(${ADM_LIB} &quot;-DHAVE_X86CPU&quot;)
+    
+    IF (ADM_CPU_X86_64)
+		ADD_DEFINITIONS(${ADM_LIB} &quot;-DHAVE_X86_64CPU&quot;)
+    ENDIF (ADM_CPU_X86_64)
+ELSEIF (ADM_CPU_ALTIVEC)
+    ADD_DEFINITIONS(${ADM_LIB} &quot;-DHAVE_ALTIVEC&quot;)
+ENDIF (ADM_CPU_X86)
+
+INIT_MUXER(${ADM_LIB})
+INSTALL_MUXER(${ADM_LIB})

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/ac3strm_in.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/ac3strm_in.cpp	2009-09-04 15:59:41 UTC (rev 5319)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/ac3strm_in.cpp	2009-09-05 08:19:09 UTC (rev 5320)
@@ -0,0 +1,478 @@
+/*
+ *  ac3strm_in.c: AC3 Audio strem class members handling scanning and
+ *  buffering raw input stream.
+ *
+ *  Copyright (C) 2001 Andrew Stevens &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">andrew.stevens at philips.com</A>&gt;
+ *  Copyright (C) 2000,2001 Brent Byeler for original header-structure
+ *                          parsing code.
+ *
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of version 2 of the GNU General Public License
+ *  as published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+#include &lt;config.h&gt;
+#include &lt;math.h&gt;
+#include &lt;stdlib.h&gt;
+
+#include &quot;audiostrm.hpp&quot;
+#include &quot;interact.hpp&quot;
+#include &quot;multiplexor.hpp&quot;
+
+//#define DEBUG_AC3_HEADERS
+#define AC3_SYNCWORD            0x0b77
+#define AC3_PACKET_SAMPLES      1536
+
+const unsigned int AC3Stream::default_buffer_size = 16*1024;
+
+/// table for the available AC3 bitrates
+static const unsigned int ac3_bitrate_index[32] =
+{ 32,40,48,56,64,80,96,112,128,160,192,
+  224,256,320,384,448,512,576,640,
+  0,0,0,0,0,0,0,0,0,0,0,0,0
+};
+
+static const unsigned int ac3_frame_size[3][32] =
+{
+    { 64,80,96,112,128,160,192,224,256,320,384,
+      448,512,640,768,896,1024, 1152,1280,
+      0,0,0,0,0,0,0,0,0,0,0,0,0
+    },
+    { 69,87,104,121,139,174,208,243,278,348,417,
+      487,557,696,835,975,1114, 1253,1393,
+          0,0,0,0,0,0,0,0,0,0,0,0,0
+    },
+    { 96,120,144,168,192,240,288,336,384,480,576,
+      672,768,960,1152,1344, 1536,1728,1920,
+      0,0,0,0,0,0,0,0,0,0,0,0,0
+    }
+}; 
+
+/// table for the available AC3 frequencies
+static const unsigned int ac3_frequency[4] = 
+{ 48000, 44100, 32000, 0};
+
+
+AC3Stream::AC3Stream(IBitStream &amp;ibs, Multiplexor &amp;into) : 
+	AudioStream( ibs, into )
+{
+num_frames = 0;
+}
+
+bool AC3Stream::Probe(IBitStream &amp;bs )
+{
+    return bs.GetBits(16) == AC3_SYNCWORD;
+}
+
+
+/*************************************************************************
+ *
+ * Reads initial stream parameters and displays feedback banner to users
+ * @param stream_num AC3 substream ID
+ *************************************************************************/
+
+
+void  AC3Stream::DisplayAc3HeaderInfo()
+{
+        /* Some stuff to generate frame-header information */
+        printf( &quot;bsid         = %d\n&quot;, bs.GetBits(5) );
+        printf( &quot;bsmode       = 0x%1x\n&quot;, bs.GetBits(3) ); 
+        int acmode = bs.GetBits(3);
+        int nfchans = 0;
+        switch( acmode )
+        {
+        case 0x0 :
+            nfchans = 2; break;
+        case 0x1 :
+            nfchans = 1; break;
+        case 0x2 :
+            nfchans = 2; break;
+        case 0x3 :
+        case 0x4 :
+            nfchans = 3; break;
+        case 0x5 :
+        case 0x6 :
+            nfchans = 4; break;
+        case 0x7 :
+            nfchans = 5; break;
+        }
+        printf( &quot;acmode       = 0x%1x (%d channels)\n&quot;, acmode, nfchans ); 
+        if( (acmode &amp; 0x1) &amp;&amp; (acmode != 1 ) )
+            printf( &quot;cmixlev  = %d\n&quot;, bs.GetBits(2) ); 
+        if( (acmode &amp; 0x4) )
+            printf( &quot;smixlev  = %d\n&quot;, bs.GetBits(2) ); 
+        if( acmode == 2 ) 
+            printf( &quot;dsurr    = %d\n&quot;, bs.GetBits(2) ); 
+        printf( &quot;lfeon        = %d\n&quot;, bs.GetBits(1) ); 
+        printf( &quot;dialnorm     = %02d\n&quot;, bs.GetBits(5) ); 
+        int compre = bs.GetBits(1);
+        printf( &quot;compre       = %d\n&quot;, compre ); 
+        if( compre )
+            printf( &quot;compr    = %02d\n&quot;, bs.GetBits(8) ); 
+        int langcode = bs.GetBits(1);
+        printf( &quot;langcode     = %d\n&quot;, langcode ); 
+        if( langcode )
+            printf( &quot;langcod  = 0x%02x\n&quot;, bs.GetBits(8) ); 
+        int audprodie =  bs.GetBits(1);
+        printf( &quot;audprodie    = %d\n&quot;, audprodie );
+        if( audprodie )
+        {
+            printf( &quot;mixlevel = 0x%02x\n&quot;, bs.GetBits(5) );
+            printf( &quot;roomtyp  = 0x%02x\n&quot;, bs.GetBits(2) );
+        }
+        if( acmode == 0 )
+        {
+            printf( &quot;Skipping 1+1 mode parameters\n&quot; );
+            bs.GetBits(5+1+8+1+8);
+            if( bs.GetBits(1) )
+                bs.GetBits(7);
+        }
+        printf( &quot;Copyright  = %d\n&quot;, bs.GetBits(1) ); 
+        printf( &quot;Original   = %d\n&quot;, bs.GetBits(1) ); 
+        int timecod1e = bs.GetBits(1);
+        if( timecod1e )
+        {
+            printf( &quot;timecod1 = 0x%03x\n&quot;, bs.GetBits(14) );
+        }
+        int timecod2e = bs.GetBits(1);
+        if( timecod2e )
+        {
+            printf( &quot;timecod2 = 0x%03x\n&quot;, bs.GetBits(14) );
+        }
+        int addbsie = bs.GetBits(1);
+        if( addbsie )
+        {
+            printf( &quot;addbsil  = %02x\n&quot;, bs.GetBits(6) );
+        }
+        
+
+        // FROM This point on we're actually right into the actual audio block
+        printf( &quot;Audio block header...\n&quot; );
+        printf( &quot;blksw  [ch] = %02x\n&quot;, bs.GetBits(nfchans) );
+        printf( &quot;dithflg[ch] = %02x\n&quot;, bs.GetBits(nfchans) );
+        int dynrnge = bs.GetBits(1);
+        printf( &quot;Dynrange    = %d\n&quot;, bs.GetBits(1) ); 
+        if( dynrnge )
+        {
+            printf( &quot;dynrng    = %02x\n&quot;, bs.GetBits(8) );
+        }
+        if( acmode == 0 &amp;&amp; bs.GetBits(1) )
+        {
+            printf( &quot;dynrng2   = %02x\n&quot;, bs.GetBits(8) );
+        }
+        int cplstre = bs.GetBits(1);
+        printf( &quot;cplstre     = %d\n&quot;, cplstre ); 
+        int cplinu = 0;
+        if( cplstre )
+        {
+            cplinu = bs.GetBits(1);
+            printf( &quot;cplinu    = %d\n&quot;, cplinu );
+            if( cplinu )
+            {
+                printf( &quot;Skipping cplinu=1 info...\n&quot;);
+                bs.GetBits(nfchans);
+                if( acmode == 2 )
+                    bs.GetBits(1);
+                int cplbegf = bs.GetBits(4);
+                int cplendf = bs.GetBits(4);
+                bs.GetBits(3+cplbegf-cplendf);
+            }
+        }
+        if( cplinu )
+        {
+            printf( &quot;Warning: no parser for coupling co-ordinates mess\n&quot;);
+            return;
+        }
+
+        if( acmode == 2 )
+        {
+            int rmatstr = bs.GetBits(1);
+            printf( &quot;rmatstr = %d\n&quot;, rmatstr );
+            printf( &quot;Warning: no parser for rematrixing...\n&quot; );
+        }
+        
+
+}
+
+void AC3Stream::Init ( const int _stream_num)
+
+{
+    unsigned int framesize_code;
+    stream_num = _stream_num;
+	MuxStream::Init( PRIVATE_STR_1, 
+					 1,  // Buffer scale
+					 default_buffer_size,
+					 false,
+					 muxinto.buffers_in_audio,
+					 muxinto.always_buffers_in_audio
+		);
+    mjpeg_info (&quot;Scanning for header info: AC3 Audio stream %02x (%s)&quot;,
+                stream_num,
+                bs.StreamName()
+                );
+
+	AU_start = bs.bitcount();
+    if (bs.GetBits(16)==AC3_SYNCWORD)
+    {
+		num_syncword++;
+        bs.GetBits(16);         // CRC field
+        frequency = bs.GetBits(2);  // Sample rate code
+        framesize_code = bs.GetBits(6); // Frame size code
+        framesize = ac3_frame_size[frequency][framesize_code&gt;&gt;1];
+        framesize = 
+            (framesize_code&amp;1) &amp;&amp; frequency == 1 ?
+            (framesize + 1) &lt;&lt; 1:
+            (framesize &lt;&lt;1);
+            
+        header_skip = 5;        // Initially skipped past  5 bytes of header 
+
+	num_frames++;
+        access_unit.start = AU_start;
+	access_unit.length = framesize;
+        mjpeg_info( &quot;AC3 frame size = %d&quot;, framesize );
+        bit_rate = ac3_bitrate_index[framesize_code&gt;&gt;1];
+		samples_per_second = ac3_frequency[frequency];
+
+		/* Presentation time-stamping  */
+		access_unit.PTS = static_cast&lt;clockticks&gt;(decoding_order) * 
+			static_cast&lt;clockticks&gt;(AC3_PACKET_SAMPLES) * 
+			static_cast&lt;clockticks&gt;(CLOCKS)	/ samples_per_second;
+		access_unit.DTS = access_unit.PTS;
+		access_unit.dorder = decoding_order;
+		++decoding_order;
+		aunits.Append( access_unit );
+
+    } else
+    {
+		mjpeg_error ( &quot;Invalid AC3 Audio stream header.&quot;);
+		exit (1);
+    }
+
+
+	OutputHdrInfo();
+}
+
+/// @returns the current bitrate
+unsigned int AC3Stream::NominalBitRate()
+{ 
+	return bit_rate*1024;
+}
+
+/// Prefills the internal buffer for output multiplexing.
+/// @param frames_to_buffer the number of audio frames to read ahead
+void AC3Stream::FillAUbuffer(unsigned int frames_to_buffer )
+{
+	unsigned int framesize_code;
+
+	last_buffered_AU += frames_to_buffer;
+	mjpeg_debug( &quot;Scanning %d AC3 audio frames to frame %d&quot;, 
+				 frames_to_buffer, last_buffered_AU );
+
+    int skip;
+	while( !bs.eos() 
+           &amp;&amp; decoding_order &lt; last_buffered_AU 
+           &amp;&amp; !muxinto.AfterMaxPTS(access_unit.PTS)
+        )
+	{
+		skip=access_unit.length-header_skip; 
+        bs.SeekFwdBits(skip);
+		prev_offset = AU_start;
+		AU_start = bs.bitcount();
+        if( AU_start - prev_offset != access_unit.length*8 )
+        {
+            mjpeg_warn( &quot;Discarding incomplete final frame AC3 stream %d!&quot;,
+                       stream_num);
+            aunits.DropLast();
+            --decoding_order;
+            break;
+        }
+
+		/* Check we have reached the end of have  another catenated 
+		   stream to process before finishing ... */
+		if ( (syncword = bs.GetBits(16))!=AC3_SYNCWORD )
+		{
+			if( !bs.eos()   )
+			{
+				mjpeg_error_exit1( &quot;Can't find next AC3 frame: @ %lld we have %04x - broken bit-stream?&quot;, AU_start/8, syncword );
+            }
+            break;
+		}
+
+        bs.GetBits(16);         // CRC field
+        bs.GetBits(2);          // Sample rate code TOOD: check for change!
+        framesize_code = bs.GetBits(6);
+        framesize = ac3_frame_size[frequency][framesize_code&gt;&gt;1];
+        framesize = 
+            (framesize_code&amp;1) &amp;&amp; frequency == 1 ?
+            (framesize + 1) &lt;&lt; 1:
+            (framesize &lt;&lt;1);
+		access_unit.start = AU_start;
+		access_unit.length = framesize;
+		access_unit.PTS = static_cast&lt;clockticks&gt;(decoding_order) * 
+			static_cast&lt;clockticks&gt;(AC3_PACKET_SAMPLES) * 
+			static_cast&lt;clockticks&gt;(CLOCKS)	/ samples_per_second;;
+		access_unit.DTS = access_unit.PTS;
+		access_unit.dorder = decoding_order;
+		decoding_order++;
+		aunits.Append( access_unit );
+		num_frames++;
+		
+		num_syncword++;
+
+		if (num_syncword &gt;= old_frames+10 )
+		{
+			mjpeg_debug (&quot;Got %d frame headers.&quot;, num_syncword);
+			old_frames=num_syncword;
+		}
+        
+    }
+	last_buffered_AU = decoding_order;
+	eoscan = bs.eos() || muxinto.AfterMaxPTS(access_unit.PTS);
+}
+
+
+/// Closes the AC3 stream and prints some statistics.
+void AC3Stream::Close()
+{
+    stream_length = AU_start &gt;&gt; 3;
+	mjpeg_info (&quot;AUDIO_STATISTICS: %02x&quot;, stream_id); 
+    mjpeg_info (&quot;Audio stream length %lld bytes.&quot;, stream_length);
+    mjpeg_info   (&quot;Frames         : %8u&quot;,  num_frames);
+}
+
+/*************************************************************************
+	OutputAudioInfo
+	gibt gesammelte Informationen zu den Audio Access Units aus.
+
+	Prints information on audio access units
+*************************************************************************/
+
+void AC3Stream::OutputHdrInfo ()
+{
+	mjpeg_info(&quot;AC3 AUDIO STREAM:&quot;);
+
+    mjpeg_info (&quot;Bit rate       : %8u bytes/sec (%3u kbit/sec)&quot;,
+				bit_rate*128, bit_rate);
+
+    if (frequency == 3)
+		mjpeg_info (&quot;Frequency      : reserved&quot;);
+    else
+		mjpeg_info (&quot;Frequency      :     %d Hz&quot;,
+				ac3_frequency[frequency]);
+
+}
+
+/**
+Reads the bytes neccessary to complete the current packet payload. 
<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">+ at param</A> to_read number of bytes to read
<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">+ at param</A> dst byte buffer pointer to read to 
<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">+ at returns</A> the number of bytes read
+ */
+unsigned int 
+AC3Stream::ReadPacketPayload(uint8_t *dst, unsigned int to_read)
+{
+    bitcount_t read_start = bs.GetBytePos();
+    // Remember to change StreamHeaderLen if you write a different
+    // length re-using this code...
+    unsigned int bytes_read = bs.GetBytes( dst+4, to_read-4 );
+    assert( bytes_read &gt; 0 );   // Should never try to read nothing
+    bs.Flush( read_start );
+	clockticks   decode_time;
+
+    unsigned int first_header = 
+        (new_au_next_sec || au_unsent &gt; bytes_read )
+        ? 0 
+        : au_unsent;
+
+    // BUG BUG BUG: how do we set the 1st header pointer if we have
+    // the *middle* part of a large frame?
+    assert( first_header+2 &lt;= to_read );
+
+    unsigned int syncwords = 0;
+    unsigned int bytes_muxed = bytes_read;
+  
+	if (bytes_muxed == 0 || MuxCompleted() )
+    {
+		goto completion;
+    }
+
+
+	/* Work through what's left of the current AU and the following AU's
+	   updating the info until we reach a point where an AU had to be
+	   split between packets.
+	   NOTE: It *is* possible for this loop to iterate. 
+
+	   The DTS/PTS field for the packet in this case would have been
+	   given the that for the first AU to start in the packet.
+
+	*/
+
+	decode_time = RequiredDTS();
+	while (au_unsent &lt; bytes_muxed)
+	{	  
+        // BUG BUG BUG: if we ever had odd payload / packet size we might
+        // split an AC3 frame in the middle of the syncword!
+        assert( bytes_muxed &gt; 1 );
+		bufmodel.Queued(au_unsent, decode_time);
+		bytes_muxed -= au_unsent;
+        if( new_au_next_sec )
+            ++syncwords;
+		if( !NextAU() )
+        {
+            goto completion;
+        }
+		new_au_next_sec = true;
+		decode_time = RequiredDTS();
+	};
+
+	// We've now reached a point where the current AU overran or
+	// fitted exactly.  We need to distinguish the latter case
+	// so we can record whether the next packet starts with an
+	// existing AU or not - info we need to decide what PTS/DTS
+	// info to write at the start of the next packet.
+	
+	if (au_unsent &gt; bytes_muxed)
+	{
+        if( new_au_next_sec )
+            ++syncwords;
+		bufmodel.Queued( bytes_muxed, decode_time);
+		au_unsent -= bytes_muxed;
+		new_au_next_sec = false;
+	} 
+	else //  if (au_unsent == bytes_muxed)
+	{
+		bufmodel.Queued(bytes_muxed, decode_time);
+        if( new_au_next_sec )
+            ++syncwords;
+        new_au_next_sec = NextAU();
+	}	   
+completion:
+    // Generate the AC3 header...
+    // Note the index counts from the low byte of the offset so
+    // the smallest value is 1!
+    dst[0] = AC3_SUB_STR_0 + stream_num;
+    dst[1] = syncwords;
+    dst[2] = (first_header+1)&gt;&gt;8;
+    dst[3] = (first_header+1)&amp;0xff;
+	return bytes_read+4;
+}
+
+
+
+/* 
+ * Local variables:
+ *  c-file-style: &quot;stroustrup&quot;
+ *  tab-width: 4
+ *  indent-tabs-mode: nil
+ * End:
+ */

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/audiostrm.hpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/audiostrm.hpp	2009-09-04 15:59:41 UTC (rev 5319)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/audiostrm.hpp	2009-09-05 08:19:09 UTC (rev 5320)
@@ -0,0 +1,218 @@
+
+/*
+ *  audiostrm.hpp:  Audio stream class sub-hierarchy for MPEG multiplexing
+ *
+ *  Copyright (C) 2001 Andrew Stevens &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">andrew.stevens at philips.com</A>&gt;
+ *
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of version 2 of the GNU General Public License
+ *  as published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+#ifndef __AUDIOSTRM_H__
+#define __AUDIOSTRM_H__
+
+#include &quot;inputstrm.hpp&quot;
+#include &quot;stream_params.hpp&quot;
+
+// TODO AudioStream is reall NonVideoStream as it is also a base for
+// SUBPStream (sub)classes
+
+class AudioStream : public ElementaryStream
+{
+public:   
+    AudioStream(IBitStream &amp;ibs, Multiplexor &amp;into );
+    virtual void Init(const int stream_num) = 0;
+    virtual void Close() = 0;
+
+    void OutputSector();
+    bool RunOutComplete();
+    virtual unsigned int NominalBitRate() = 0;
+
+    unsigned int num_syncword;
+
+protected:
+	virtual void FillAUbuffer(unsigned int frames_to_buffer) = 0;
+    
+	/* State variables for scanning source bit-stream */
+    AUnit access_unit;
+    unsigned int header_skip;
+}; 	
+
+class MPAStream : public AudioStream
+{
+public:   
+    MPAStream(IBitStream &amp;ibs, Multiplexor &amp;into );
+    virtual void Init(const int stream_num);
+    static bool Probe(IBitStream &amp;bs);
+    virtual void Close();
+    virtual unsigned int NominalBitRate();
+
+
+private:
+	void OutputHdrInfo();
+	unsigned int SizeFrame( int bit_rate, int padding_bit );
+	virtual void FillAUbuffer(unsigned int frames_to_buffer);
+
+
+    /* Stream information for logging and parsing purposes */
+    unsigned int samples_per_second;
+	unsigned int version_id ;
+    unsigned int layer		;
+    unsigned int protection	;
+    unsigned int bit_rate_code;
+    unsigned int frequency	;
+    unsigned int mode		;
+    unsigned int mode_extension ;
+    unsigned int copyright      ;
+    unsigned int original_copy  ;
+    unsigned int emphasis	;
+
+	/* State variables for scanning source bit-stream */
+    unsigned int framesize;
+    unsigned int num_frames [2];
+    unsigned int size_frames[2];
+
+}; 	
+
+
+
+class AC3Stream : public AudioStream
+{
+public:   
+    AC3Stream(IBitStream &amp;ibs,Multiplexor &amp;into );
+    virtual void Init(const int stream_num);
+    static bool Probe(IBitStream &amp;bs);
+    virtual void Close();
+    virtual unsigned int NominalBitRate();
+
+    virtual unsigned int ReadPacketPayload(uint8_t *dst, unsigned int to_read);
+    virtual unsigned int StreamHeaderSize() { return 4; }
+    
+
+private:
+	void OutputHdrInfo();
+    void DisplayAc3HeaderInfo();
+	virtual void FillAUbuffer(unsigned int frames_to_buffer);
+    
+    static const unsigned int default_buffer_size;
+	/* State variables for scanning source bit-stream */
+    unsigned int framesize;
+    unsigned int frequency;
+    unsigned int samples_per_second;
+    unsigned int bit_rate;
+    unsigned int stream_num;
+    unsigned int num_frames;
+}; 	
+
+class DTSStream : public AudioStream
+{
+public:   
+    DTSStream(IBitStream &amp;ibs,Multiplexor &amp;into );
+    virtual void Init(const int stream_num);
+    static bool Probe(IBitStream &amp;bs);
+    virtual void Close();
+    virtual unsigned int NominalBitRate();
+
+    virtual unsigned int ReadPacketPayload(uint8_t *dst, unsigned int to_read);
+    virtual unsigned int StreamHeaderSize() { return 4; }
+    
+
+private:
+	void OutputHdrInfo();
+#ifdef DEBUG_DTS
+    void DisplayDtsHeaderInfo();
+#endif
+	virtual void FillAUbuffer(unsigned int frames_to_buffer);
+    
+    static const unsigned int default_buffer_size;
+
+	/* State variables for scanning source bit-stream */
+    unsigned int framesize;
+    unsigned int samples_per_second;
+    unsigned int bit_rate;
+    unsigned int stream_num;
+    unsigned int frequency	;
+    unsigned int num_frames;
+}; 	
+
+class LPCMStream : public AudioStream
+{
+public:   
+    LPCMStream(IBitStream &amp;ibs, LpcmParams *parms, Multiplexor &amp;into );
+    virtual void Init(const int stream_num);
+    static bool Probe(IBitStream &amp;bs);
+    virtual void Close();
+    virtual unsigned int NominalBitRate();
+
+    virtual unsigned int ReadPacketPayload(uint8_t *dst, unsigned int to_read);
+    virtual unsigned int StreamHeaderSize() { return 7; }
+    
+
+private:
+	void OutputHdrInfo();
+	virtual void FillAUbuffer(unsigned int frames_to_buffer);
+    
+    static const unsigned int default_buffer_size;
+    static const unsigned int ticks_per_frame_90kHz;
+    unsigned int num_frames;
+
+	/* State variables for scanning source bit-stream */
+    unsigned int stream_num;
+    unsigned int samples_per_second;
+    unsigned int channels;
+    unsigned int bits_per_sample;
+    unsigned int bytes_per_frame;
+    unsigned int frame_index;
+    unsigned int dynamic_range_code;
+    LpcmParams *parms;
+}; 	
+
+class SUBPStream : public AudioStream
+{
+public:   
+    SUBPStream(IBitStream &amp;ibs,Multiplexor &amp;into );
+    virtual void Init(const int stream_num);
+    virtual void Close();
+    // TODO: rough and ready measure...
+    virtual unsigned int NominalBitRate() {return 50*1024;}
+    virtual unsigned int ReadPacketPayload(uint8_t *dst, unsigned int to_read);
+    virtual unsigned int StreamHeaderSize() { return 1; }
+    
+
+private:
+	void OutputHdrInfo();
+	virtual void FillAUbuffer(unsigned int frames_to_buffer);
+    
+    static const unsigned int default_buffer_size;
+
+	/* State variables for scanning source bit-stream */
+    unsigned int framesize;
+    unsigned int samples_per_second;
+    unsigned int bit_rate;
+    unsigned int stream_num;
+    unsigned int frequency	;
+    unsigned int num_frames;
+}; 	
+
+
+#endif // __AUDIOSTRM_H__
+
+
+/* 
+ * Local variables:
+ *  c-file-style: &quot;stroustrup&quot;
+ *  tab-width: 4
+ *  indent-tabs-mode: nil
+ * End:
+ */

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/audiostrm_out.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/audiostrm_out.cpp	2009-09-04 15:59:41 UTC (rev 5319)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/audiostrm_out.cpp	2009-09-05 08:19:09 UTC (rev 5320)
@@ -0,0 +1,149 @@
+
+/*
+ *  audiostrm_out.cpp: Members of audio stream classes related to
+ *  muxing out into the output stream.
+ *
+ *  Copyright (C) 2001 Andrew Stevens &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">andrew.stevens at philips.com</A>&gt;
+ *
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of version 2 of the GNU General Public License
+ *  as published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+
+#include &lt;config.h&gt;
+#include &lt;assert.h&gt;
+
+#include &quot;mjpeg_types.h&quot;
+#include &quot;audiostrm.hpp&quot;
+#include &quot;multiplexor.hpp&quot;
+
+
+AudioStream::AudioStream(IBitStream &amp;ibs, Multiplexor &amp;into) : 
+	ElementaryStream( ibs, into,  ElementaryStream::audio ),
+	num_syncword(0)
+{
+    FRAME_CHUNK = 24;
+}
+
+
+
+/*********************************
+ * Signals when audio stream has completed mux run-out specified
+ * in associated mux stream. 
+ *********************************/
+
+bool AudioStream::RunOutComplete()
+{
+	return (au_unsent == 0 || 
+			( muxinto.running_out &amp;&amp; RequiredPTS() &gt;= muxinto.runout_PTS));
+}
+
+
+/******************************************************************
+	Output_Audio
+	generates Pack/Sys Header/Packet information from the
+	audio stream and saves them into the sector
+******************************************************************/
+
+void AudioStream::OutputSector ( )
+
+{
+	clockticks   PTS;
+	unsigned int max_packet_data; 	 
+	unsigned int actual_payload;
+	unsigned int old_au_then_new_payload;
+
+	PTS = RequiredDTS();
+	old_au_then_new_payload = 
+		muxinto.PacketPayload( *this, buffers_in_header, false, false );
+    bool last_packet = Lookahead() == 0;
+    // Ensure we have access units data buffered to allow a sector to be
+    // written.
+	max_packet_data = 0;
+	if( (muxinto.running_out &amp;&amp; NextRequiredPTS() &gt; muxinto.runout_PTS)
+        || last_packet)
+	{
+		/* We're now in the last AU of a segment.  So we don't want to
+		   go beyond it's end when writing sectors. Hence we limit
+		   packet payload size to (remaining) AU length.
+		*/
+		max_packet_data = au_unsent+StreamHeaderSize();
+	}
+  
+	/* CASE: packet starts with new access unit			*/
+	
+	if (new_au_next_sec)
+    {
+		actual_payload = 
+			muxinto.WritePacket ( max_packet_data,
+								  *this,
+								  buffers_in_header, PTS, 0,
+								  TIMESTAMPBITS_PTS);
+
+    }
+
+
+	/* CASE: packet starts with old access unit, no new one	*/
+	/*       starts in this very same packet			*/
+	else if (!(new_au_next_sec) &amp;&amp; 
+			 (au_unsent &gt;= old_au_then_new_payload))
+    {
+		actual_payload = 
+			muxinto.WritePacket ( max_packet_data,
+								  *this,
+								  buffers_in_header, 0, 0,
+								  TIMESTAMPBITS_NO );
+    }
+
+
+	/* CASE: packet starts with old access unit, a new one	*/
+	/*       starts in this very same packet			*/
+	else /* !(new_au_next_sec) &amp;&amp;  (au_unsent &lt; old_au_then_new_payload)) */
+    {
+		/* is there another access unit anyway ? */
+		if( !last_packet )
+		{
+			PTS = NextRequiredDTS();
+			actual_payload = 
+				muxinto.WritePacket ( max_packet_data,
+									  *this,
+									  buffers_in_header, PTS, 0,
+									  TIMESTAMPBITS_PTS );
+
+		} 
+		else
+		{
+			actual_payload = muxinto.WritePacket ( max_packet_data,
+                                                   *this,
+                                                   buffers_in_header, 0, 0,
+                                                   TIMESTAMPBITS_NO );
+		};
+		
+    }
+
+    ++nsec;
+
+	buffers_in_header = always_buffers_in_header;
+	
+}
+
+
+
+/* 
+ * Local variables:
+ *  c-file-style: &quot;stroustrup&quot;
+ *  tab-width: 4
+ *  indent-tabs-mode: nil
+ * End:
+ */

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/aunit.hpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/aunit.hpp	2009-09-04 15:59:41 UTC (rev 5319)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/aunit.hpp	2009-09-05 08:19:09 UTC (rev 5320)
@@ -0,0 +1,36 @@
+#ifndef __AUNIT_H__
+#define __AUNIT_H__
+
+#include &quot;mjpeg_types.h&quot;
+#include &quot;bits.hpp&quot;
+
+typedef int64_t clockticks;		// This value *must* be signed
+                                // because we frequently compute *offsets*
+
+class AUnit
+{
+public:
+	AUnit() : length(0), PTS(0), DTS(0) {}
+	//
+	// How many payload bytes muxing AU will require.  Eventually will be more
+	// complex for input streams where AU are no contiguous
+	//
+	inline unsigned int PayloadSize() const { return length; }
+	void markempty() { length = 0; }
+	bitcount_t start;
+	unsigned int length;
+    clockticks PTS;
+    int        dorder;
+	//
+	// Remainder Used only for video AU's... 
+	//
+    clockticks DTS;
+    int		   porder;
+    unsigned int type;
+	bool	   seq_header;
+	bool	   end_seq;
+
+};
+
+
+#endif // __AUNIT_H__

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/aunitbuffer.hpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/aunitbuffer.hpp	2009-09-04 15:59:41 UTC (rev 5319)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/aunitbuffer.hpp	2009-09-05 08:19:09 UTC (rev 5320)
@@ -0,0 +1,65 @@
+#ifndef __AUNITBUFFER_H__
+#define __AUNITBUFFER_H__
+
+#include &lt;deque&gt;
+#include &quot;mjpeg_logging.h&quot;
+#include &quot;aunit.hpp&quot;
+
+class AUStream
+{
+public:
+	AUStream()  {}
+	~AUStream() 
+	{
+		for( std::deque&lt;AUnit *&gt;::iterator i = buf.begin(); i &lt; buf.end(); ++i )
+			delete *i;
+	}
+	
+	void Append( AUnit &amp;rec )
+	{
+		if( buf.size() &gt;= BUF_SIZE_SANITY )
+			mjpeg_error_exit1( &quot;INTERNAL ERROR: AU buffer overflow&quot; );
+		buf.push_back( new AUnit(rec) );
+	}
+
+	inline AUnit *Next( ) 
+	{ 
+		if( buf.size()==0 )
+		{
+			return 0;
+		}
+	    else
+		{
+			AUnit *res = buf.front();
+			buf.pop_front();
+			return res;
+		}
+	}
+
+	inline void DropLast()
+		{
+			if( buf.empty() )
+				mjpeg_error_exit1( &quot;INTERNAL ERROR: droplast empty AU buffer&quot; );
+			buf.pop_back();
+			
+		}
+
+	inline AUnit *Lookahead( unsigned int n)
+	{
+		return buf.size() &lt;= n ? 0 : buf[n];
+    }
+
+	inline unsigned int MaxAULookahead() const { return buf.size(); }
+
+private:
+	static const unsigned int BUF_SIZE_SANITY = 1000;
+
+
+	
+	std::deque&lt;AUnit *&gt; buf;
+};
+
+
+
+
+#endif // __AUSTREAM_H__

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/bits.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/bits.cpp	2009-09-04 15:59:41 UTC (rev 5319)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/bits.cpp	2009-09-05 08:19:09 UTC (rev 5320)
@@ -0,0 +1,502 @@
+/** @file bits.cc, bit-level output                                              */
+
+/* Copyright (C) 2001, Andrew Stevens &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">andrew.stevens at philips.com</A>&gt; *
+
+ *
+ * Disclaimer of Warranty
+ *
+ * These software programs are available to the user without any license fee or
+ * royalty on an &quot;as is&quot; basis.  The MPEG Software Simulation Group disclaims
+ * any and all warranties, whether express, implied, or statuary, including any
+ * implied warranties or merchantability or of fitness for a particular
+ * purpose.  In no event shall the copyright-holder be liable for any
+ * incidental, punitive, or consequential damages of any kind whatsoever
+ * arising from the use of these programs.
+ *
+ * This disclaimer of warranty extends to the user of these programs and user's
+ * customers, employees, agents, transferees, successors, and assigns.
+ *
+ * The MPEG Software Simulation Group does not represent or warrant that the
+ * programs furnished hereunder are free of infringement of any third-party
+ * patents.
+ *
+ * Commercial implementations of MPEG-1 and MPEG-2 video, including shareware,
+ * are subject to royalty fees to patent holders.  Many of these patents are
+ * general enough such that they are unavoidable regardless of implementation
+ * design.
+ *
+ */
+
+#include &lt;config.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;errno.h&gt;
+#include &lt;string.h&gt;
+#include &lt;assert.h&gt;
+#include &quot;mjpeg_logging.h&quot;
+#include &quot;bits.hpp&quot;
+
+
+const unsigned int BitStreamBuffering::BUFFER_SIZE = 64 * 1024;
+const unsigned int BitStreamBuffering::BUFFER_CEILING = 32 * 1024 * 1024;
+
+BitStreamBuffering::BitStreamBuffering() :
+    bfr(0),
+    bfr_size(0),
+    buffered(0)
+    
+{
+}
+
+
+/*****
+ *
+ * Pseudo-destructor. Frees the internal buffer and marks buffer as
+ * empty.
+ *
+ *****/
+void BitStreamBuffering::Release()
+{
+    if( bfr != 0)
+        delete[] bfr;
+    bfr = 0;
+    bfr_size = 0;
+    buffered = 0;
+}
+
+
+/*****
+ *
+ * Empty the buffer.
+ *
+ *****/
+
+void BitStreamBuffering::Empty()
+{
+    buffered = 0;
+}
+
+/** sets the internal buffer size. 
+    @param new_buf_size requests new internal buffer size 
+*/
+void BitStreamBuffering::SetBufSize( unsigned int new_buf_size)
+{
+    //
+    // If size has changed and we won't lose buffered data
+    // we adjust the buffer size, otherwise we ignore the request
+    //
+	if( new_buf_size &gt; BUFFER_CEILING )
+	{
+		mjpeg_error_exit1(&quot;INTERNAL ERROR: additional data required but &quot;
+                          &quot; input buffer size would exceed ceiling&quot;);
+	}
+    
+    if( new_buf_size &gt; buffered &amp;&amp; bfr_size != new_buf_size )
+	{
+		uint8_t *new_buf = new uint8_t[new_buf_size];
+		memcpy( new_buf, bfr, static_cast&lt;size_t&gt;(buffered) );
+        if( bfr != 0 )
+            delete [] bfr;
+		bfr_size = new_buf_size;
+		bfr = new_buf;
+	}
+
+}
+
+/****************************
+ *
+ * Return the pointer to where (after, if necessary extending the
+ * buffer) up to to_append bytes may be appended to the buffered bytes
+ *
+ ****************************/
+
+uint8_t *BitStreamBuffering::StartAppendPoint( unsigned int to_append )
+{
+    unsigned int resize_size = bfr_size;
+    assert( resize_size != 0 );
+    while( resize_size - buffered &lt; to_append )
+    {
+        resize_size *= 2;
+    }
+    if( resize_size != bfr_size )
+        SetBufSize( resize_size );
+    return bfr+buffered;
+}
+
+/**
+   Refills an IBitStream's input buffer based on the internal
+   variables buffered and bfr_size.
+   Strategy: we read 1/4 of a buffer, always.
+ */
+bool IBitStream::ReadIntoBuffer(unsigned int to_read)
+{
+	size_t i;
+    unsigned int read_pow2 = BUFFER_SIZE/4;
+    while( read_pow2 &lt; to_read ) 
+        read_pow2 &lt;&lt;= 1;
+
+
+    i = ReadStreamBytes( StartAppendPoint(read_pow2), 
+                         static_cast&lt;size_t&gt;(read_pow2) );      
+	//i = fread(StartAppendPoint(read_pow2), sizeof(uint8_t), 
+    //			  static_cast&lt;size_t&gt;(read_pow2), fileh);
+    Appended(static_cast&lt;unsigned int&gt;(i));
+
+	if ( i == 0 )
+	{
+		eobs = true;
+		return false;
+	}
+	return true;
+}
+
+
+
+
+#define masks(idx) (1&lt;&lt;(idx))
+
+/*read 1 bit from the bit stream 
<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">+ at returns</A> the read bit, 0 on EOF */
+uint32_t IBitStream::Get1Bit()
+{
+	unsigned int bit;
+
+	if (eobs)
+		return 0;
+
+	bit = (bfr[byteidx] &amp; masks(bitidx - 1)) &gt;&gt; (bitidx - 1);
+	bitreadpos++;
+	bitidx--;
+	if (!bitidx)
+	{
+		bitidx = 8;
+		byteidx++;
+		if (byteidx == buffered)
+		{
+			ReadIntoBuffer();
+		}
+	}
+
+	return bit;
+}
+
+/*read N bits from the bit stream 
<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">+ at returns</A> the read bits, 0 on EOF */
+uint32_t IBitStream::GetBits(int N)
+{
+	uint32_t val = 0;
+	int i = N;
+	unsigned int j;
+
+	// Optimize: we are on byte boundary and want to read multiple of bytes!
+	if ((bitidx == 8) &amp;&amp; ((N &amp; 7) == 0))
+	{
+		i = N &gt;&gt; 3;
+		while (i &gt; 0)
+		{
+			if (eobs)
+				return 0;
+			val = (val &lt;&lt; 8) | bfr[byteidx];
+			byteidx++;
+			bitreadpos += 8;
+			if (byteidx == buffered)
+			{
+				ReadIntoBuffer();
+			}
+			i--;
+		}
+	}
+	else
+	{
+		while (i &gt; 0)
+		{
+			if (eobs)
+				return 0;
+
+			j = (bfr[byteidx] &amp; masks(bitidx - 1)) &gt;&gt; (bitidx - 1);
+			bitreadpos++;
+			bitidx--;
+			if (!bitidx)
+			{
+				bitidx = 8;
+				byteidx++;
+				if (byteidx == buffered)
+				{
+					ReadIntoBuffer();
+				}
+			}
+			val = (val &lt;&lt; 1) | j;
+			i--;
+		}
+	}
+	return val;
+}
+
+
+/** This function seeks for a byte aligned sync word (max 32 bits) in the bit stream and
+    places the bit stream pointer right after the sync.
+    This function returns 1 if the sync was found otherwise it returns 0
<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">+ at param</A> sync the sync word to search for
<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">+ at param</A> N the number of bits to retrieve
<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">+ at param</A> lim number of bytes to search through
<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">+ at returns</A> false on error */
+
+bool IBitStream::SeekSync(uint32_t sync, int N, int lim)
+{
+	uint32_t val, val1;
+	uint32_t maxi = ((1U&lt;&lt;N)-1); /* pow(2.0, (double)N) - 1 */;
+	if( maxi == 0 )
+	{
+		maxi = 0xffffffff;
+	}
+	while (bitidx != 8)
+	{
+		Get1Bit();
+	}
+
+	val = GetBits(N);
+	if( eobs )
+		return false;
+	while ((val &amp; maxi) != sync &amp;&amp; --lim)
+	{
+		val &lt;&lt;= 8;
+		val1 = GetBits( 8 );
+		val |= val1;
+		if( eobs )
+			return false;
+	}
+  
+	return (!!lim);
+}
+
+/****************
+ *
+ * Move the bit read position forward a specified number of bytes
+ * buffering bytes skipped over that are not already buffered
+ *
+ ***************/
+
+void IBitStream::SeekFwdBits( unsigned int bytes_to_seek_fwd)
+{ 
+    assert(bitidx == 8);
+    unsigned int req_byteidx = byteidx + bytes_to_seek_fwd;
+    while( req_byteidx &gt;= buffered &amp;&amp; !eobs)
+    {
+        ReadIntoBuffer( req_byteidx - (buffered-1) );
+    }
+    
+    eobs = ( req_byteidx &gt;= buffered );
+    if( eobs )
+        bitreadpos += (buffered - byteidx)*8;
+    else
+        bitreadpos += bytes_to_seek_fwd*8;
+    byteidx = req_byteidx;
+}
+
+
+/**
+  Flushes all read input up-to *but not including* byte flush_upto.
+  @param flush_to the number of bits to flush
+*/
+
+void IBitStream::Flush(bitcount_t flush_upto )
+{
+	if( flush_upto &gt; bfr_start+buffered )
+		mjpeg_error_exit1(&quot;INTERNAL ERROR: attempt to flush input beyond buffered amount&quot; );
+
+	if( flush_upto &lt; bfr_start )
+		mjpeg_error_exit1(&quot;INTERNAL ERROR: attempt to flush input stream before  first buffered byte %lld last is %lld&quot;, flush_upto, bfr_start );
+
+	unsigned int bytes_to_flush = 
+		static_cast&lt;unsigned int&gt;(flush_upto - bfr_start);
+	//
+	// Don't bother actually flushing until a good fraction of a buffer
+	// will be cleared.
+	//
+
+	if( bytes_to_flush &lt; bfr_size/2 )
+		return;
+	buffered -= bytes_to_flush;
+	bfr_start = flush_upto;
+	byteidx -= bytes_to_flush;
+	memmove( bfr, bfr+bytes_to_flush, static_cast&lt;size_t&gt;(buffered));
+}
+
+
+/**
+  Undo scanning / reading
+  N.b buffer *must not* be flushed between prepareundo and undochanges.
+  @param undo handle to store the undo information
+*/
+void IBitStream::PrepareUndo( IBitStreamUndo &amp;undo)
+{
+	undo = *(static_cast&lt;IBitStreamUndo*&gt;(this));
+}
+
+/**
+Undoes changes committed to an IBitStream. 
<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">+ at param</A> undo handle to retrieve the undo information   
+ */
+void IBitStream::UndoChanges( IBitStreamUndo &amp;undo)
+{
+	*(static_cast&lt;IBitStreamUndo*&gt;(this)) = undo;
+}
+
+/**
+   Read a number bytes over an IBitStream, using the buffer. 
+   @param dst buffer to read to 
+   @param length the number of bytes to read
+ */
+unsigned int IBitStream::GetBytes(uint8_t *dst, unsigned int length)
+{
+	unsigned int to_read = length;
+	if( bytereadpos &lt; bfr_start)
+		mjpeg_error_exit1(&quot;INTERNAL ERROR: access to input stream buffer @ %lld: before first buffered byte (%lld)&quot;, bytereadpos, bfr_start );
+
+	if(  bytereadpos+length &gt; bfr_start+buffered )
+	{
+		if( !EndOfStream() )
+        {
+			mjpeg_error(&quot;INTERNAL ERROR: access to input stream buffer beyond last buffered byte @POS=%lld END=%d REQ=%lld + %d bytes&quot;, 
+                        bytereadpos,
+                        buffered, 
+                        bytereadpos-bfr_start,
+                        length  );
+            abort();
+        }
+		to_read = static_cast&lt;unsigned int&gt;( (bfr_start+buffered)- bytereadpos );
+	}
+	memcpy( dst, 
+			bfr+(static_cast&lt;unsigned int&gt;( bytereadpos-bfr_start)), 
+			to_read);
+	// We only ever flush up to the start of a read as we
+	// have only scanned up to a header *beginning* a block that is then
+	// read
+	//flush( bytereadpos );
+	bytereadpos += to_read;
+	return to_read;
+}
+
+
+#ifdef REDUNDANT_CODE
+/**
+   Initialize buffer, call once before first putbits or alignbits.
+  @param bs_filename output filename
+  @param buf_size size of the temporary output buffer to use
+*/
+void OBitStream::open(char *bs_filename, unsigned int buf_size)
+{
+	if ((fileh = fopen(bs_filename, &quot;wb&quot;)) == NULL)
+	{
+		mjpeg_error_exit1( &quot;Unable to open file %s for writing; %s&quot;, 
+						   bs_filename, strerror(errno));
+	}
+	filename = strcpy( new char[strlen(bs_filename)+1], bs_filename );
+    SetBufSize(buf_size);
+	// Save multiple buffering...
+	setvbuf(fileh, 0, _IONBF, 0 );
+	bitidx = 8;
+	byteidx = 0;
+	bitwritepos = 0LL;
+	outbyte = 0;
+}
+
+
+/** 
+    Closes the OBitStream. Flushes the output buffer and closes the output file if one was open. 
+ */
+void OBitStream::close()
+{
+	if (fileh)
+	{
+		if (byteidx != 0)
+			fwrite(bfr, sizeof(uint8_t), byteidx, fileh);
+		fclose(fileh);
+		delete filename;
+		fileh = NULL;
+	}
+}
+
+/**
+  Puts a byte into the OBitStream.  Puts the byte into the internal
+  buffer; if the buffer is full, it flushes the buffer to disk.
+ */
+void OBitStream::putbyte()
+{
+    bfr[byteidx++] = outbyte;
+    if (byteidx == bfr_size)
+    {
+		if (fwrite(bfr, sizeof(uint8_t), bfr_size, fileh) != bfr_size)
+			mjpeg_error_exit1( &quot;Write failed: %s&quot;, strerror(errno));
+		byteidx = 0;
+    }
+	bitidx = 8;
+}
+
+/** write rightmost n (0&lt;=n&lt;=32) bits of val to outfile 
<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">+ at param</A> val value to write bitwise
<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">+ at param</A> n number of bits to write
+*/
+void OBitStream::putbits(uint32_t val, int n)
+{
+	int i;
+	unsigned int mask;
+
+    bitwritepos += n;
+    while( n &gt;= bitidx )
+    {
+        outbyte = 
+            (outbyte&lt;&lt;bitidx) | ((val &gt;&gt; (n-bitidx)) &amp; ((1u&lt;&lt;bitidx)-1));
+        n -= bitidx;
+        putbyte();
+    }
+    if( n &gt; 0 )
+    {
+        bitidx -= n;
+        outbyte = val &amp; ((1u&lt;&lt;bitidx)-1);
+    }
+#ifdef ORIGINAL
+	mask = 1 &lt;&lt; (n - 1); /* selects first (leftmost, msb) bit */
+	for (i = 0; i &lt; n; i++)
+	{
+		bitwritepos += 1;
+		outbyte &lt;&lt;= 1;
+		if (val &amp; mask)
+			outbyte |= 1;
+		mask &gt;&gt;= 1; /* select next bit */
+		bitidx--;
+		if (bitidx == 0) /* 8 bit buffer full */
+			putbyte();
+	}
+#endif
+}
+
+/** write rightmost bit of val to outfile
+    @param val value to write one bit of
+*/
+void OBitStream::put1bit(int val)
+{
+	++bitwritepos;
+    outbyte = (outbyte&lt;&lt;1) | (val &amp; 0x1);
+	--bitidx;
+	if (bitidx == 0) /* 8 bit buffer full */
+		putbyte();
+}
+
+
+/** zero bit stuffing to next byte boundary (5.2.3, 6.2.1) */
+void OBitStream::alignbits()
+{
+	if (bitidx != 8)
+		putbits( 0, bitidx);
+    flush_bytes();
+}
+
+#endif
+
+/* 
+ * Local variables:
+ *  c-file-style: &quot;stroustrup&quot;
+ *  tab-width: 4
+ *  indent-tabs-mode: nil
+ * End:
+ */

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/bits.hpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/bits.hpp	2009-09-04 15:59:41 UTC (rev 5319)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/bits.hpp	2009-09-05 08:19:09 UTC (rev 5320)
@@ -0,0 +1,207 @@
+#ifndef __BITS_H__
+#define __BITS_H__
+
+#include &lt;stdio.h&gt;
+#include &lt;assert.h&gt;
+// MEANX
+#include &quot;streamType.h&quot;
+// /MEANX
+
+typedef uint64_t bitcount_t;
+
+
+class BitStreamBuffering
+{
+public:
+	BitStreamBuffering();
+	void Release();
+	void Empty();
+	void SetBufSize( unsigned int buf_size);
+	uint8_t *StartAppendPoint(unsigned int additional);
+	inline void Appended(unsigned int additional)
+		{
+			buffered += additional;
+			assert( buffered &lt;= bfr_size );
+		}
+private:
+	inline uint8_t *BufferEnd() { return bfr+buffered; }
+protected:
+	//
+	// TODO: really we should set these based on system parameters etc.
+	//
+	static const unsigned int BUFFER_SIZE;
+	static const unsigned int BUFFER_CEILING;
+	uint8_t *bfr;				// The read/write buffer tiself
+	unsigned int bfr_size;		// The physical size of the buffer =
+								// maximum buffered data-bytes possible
+	unsigned int buffered;		// Number of data-bytes in buffer
+};
+
+
+
+/*******
+ *
+ * the input bit stream class (see below) provides a mechanism to
+ * restore the scanning state to a marked point, provided no flush has
+ * taken place.
+ *
+ * This base class contains the state information needed to mark/restore
+ * between flushes.
+ *
+ * N.b. not that we override the BitStreamBuffering destructor so
+ * we don't cheerfully deallocate the buffer when an undo
+ * goes out of scope!
+ *
+ ******/
+ 
+class IBitStreamUndo : public BitStreamBuffering
+{
+public:
+	IBitStreamUndo() :
+		bfr_start(0),
+		bitreadpos(0),
+		bitidx(8),
+		bytereadpos(0),
+		eobs(true)
+		{}
+	inline bool eos() { return eobs; }
+	inline bitcount_t bitcount() { return bitreadpos; }
+
+protected:
+	bitcount_t bfr_start;	    // The position in the underlying
+								// data-stream of the first byte of
+								// the buffer.
+	unsigned int byteidx;		// Byte in buffer holding bit at current
+								// to current bit read position
+	bitcount_t bitreadpos;			// Total bits read at current bit read position
+	int bitidx;					// Position in byteidx buffer byte of
+								// bit at current bit read position
+								// N.b. coded as bits-left-to-read count-down
+	
+	bitcount_t bytereadpos;			// Bit position of the current *byte*
+								// read position
+	bool eobs;					// End-of-bitstream  flag: true iff
+								// Bit read position has reached the end
+								// of the underlying bitstream...
+};
+
+/***************************************
+ *
+ * IBitStream -  Input bit stream base class.  Supports the
+ * &quot;scanning&quot; of a stream held in a large buffer which is flushed
+ * once it has been &quot;read&quot;.
+ *
+ * I.e. there are in effect two file-pointers: 
+ *
+ * A bit-level parsing file-pointers intended for bit-level parsing
+ * through the 'Get*' and 'Seek*'.  Scanning/seeking using these entry
+ * points keeps appending the got/sought data from the underlying
+ * stream to a (dynamically sized) internal buffer.
+ *
+ * A byte-level I/O file pointer used for reading chunks of data
+ * identified through parsing.
+ *
+ * A final set of entry-points allow parsed/read data that no longer
+ * needs to buffered to be flushed from the buffer (and buffer space
+ * reclaimed!).
+ *
+ * INVARIANT: only data items up to the bit-level file-pointer can be 'read'
+ *
+ * The actual source of the bit stream to be parsed/read is *abstract*
+ * in this base class.  Access in derived classes is through the
+ * virtual member function 'ReadStreamBytes' which should behave in
+ * the same way as 'fread'.  I.e. it should only return a short count
+ * at EOF or ERROR and further calls after EOF or ERROR should return
+ * a zero count.
+ *
+ * Hence the actual source of the bit stream need not support seeking.
+ *
+ ******************************************/
+
+
+
+class IBitStream : public IBitStreamUndo 
+{
+public:
+           mplexStreamDescriptor      streamDesc; //MEANX
+
+ 	IBitStream(mplexStreamDescriptor *desc) :
+		IBitStreamUndo(),
+		streamname( &quot;unnamed&quot; )
+		{
+                streamDesc=*desc; // MEANX
+		}
+	virtual ~IBitStream() { Release(); }
+
+
+	// Bit-level Parsing file-pointer entry-points
+	uint32_t Get1Bit();
+	uint32_t GetBits(int N);
+	bool SeekSync( uint32_t sync, int N, int lim);
+	void SeekFwdBits( unsigned int bytes_to_seek_fwd );
+
+	// Bit-level parsing state undo mechanism
+	void PrepareUndo(IBitStreamUndo &amp;undobuf);
+	void UndoChanges(IBitStreamUndo &amp;undobuf);
+
+	// Byte-level file-I/O entry-points
+	inline bitcount_t GetBytePos() { return bytereadpos; }
+	inline unsigned int BufferedBytes()
+		{
+			return static_cast&lt;unsigned int&gt;(bfr_start+buffered-bytereadpos);
+		}
+	unsigned int GetBytes( uint8_t *dst,
+						   unsigned int length_bytes);
+
+	//
+	// Byte data buffer management
+	void Flush( bitcount_t byte_position );
+
+	inline const char *StreamName() { return streamname; }
+protected:
+	bool ReadIntoBuffer( unsigned int to_read = BUFFER_SIZE );
+	virtual size_t ReadStreamBytes( uint8_t *buf, size_t number ) = 0;
+	virtual bool EndOfStream() = 0;
+	const char *streamname;
+
+};
+
+#ifdef REDUNDANT_CODE
+class OBitStreamUndo : public BitStreamBuffering
+{
+protected:
+	uint8_t outbyte;
+	unsigned int byteidx;
+	unsigned int bitidx;
+	unsigned int buffered;
+	bitcount_t bitwritepos;
+	uint8_t *bfr;
+	unsigned int bfr_size;
+
+};
+
+
+class BitStream : public OBitStreamUndo
+{
+};
+
+
+
+class OBitStream : public OBitStreamUndo {
+public:
+	inline bitcount_t bitcount() { return bitwritepos; }
+	void open( char *bs_filename, unsigned int buf_size = BUFFER_SIZE);
+	void close();
+	void putbits( int val, int n);
+	void put1bit( int val);
+	void alignbits();
+private:
+	FILE *fileh;
+	const char *filename;
+	void putbyte();
+};
+
+#endif
+
+#endif  // __BITS_H__
+

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/cpu_accel.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/cpu_accel.c	2009-09-04 15:59:41 UTC (rev 5319)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/cpu_accel.c	2009-09-05 08:19:09 UTC (rev 5320)
@@ -0,0 +1,445 @@
+/*
+* cpu_accel.c
+* Copyright (C) 1999-2000 Aaron Holtzman &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">aholtzma at ess.engr.uvic.ca</A>&gt;
+*
+* This file is part of mpeg2dec, a free MPEG-2 video stream decoder.
+*
+* mpeg2dec is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* mpeg2dec is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
+
+#define ADM_LEGACY_PROGGY
+#include &quot;ADM_default.h&quot;
+
+#include &lt;signal.h&gt;
+#include &lt;setjmp.h&gt;
+#include &lt;unistd.h&gt;
+#include &lt;string.h&gt;
+#include &lt;errno.h&gt;
+#include &quot;cpu_accel.h&quot;
+#include &quot;mjpeg_logging.h&quot;
+
+#ifdef HAVE_ALTIVEC
+extern int altivec_copy_v0();
+#endif
+
+/*
+ * Don't add &quot;mblocks_sub44_mests&quot; to the list below because it does not
+ * have a C-reference code counterpart (mblocks_sub44_mests only exists as
+ * a SIMD routine).
+*/
+
+	const char *disable_simd_flags[] = {
+		&quot;sad_00&quot;,
+		&quot;sad_01&quot;,
+		&quot;sad_10&quot;,
+		&quot;sad_11&quot;,
+		&quot;sad_sub22&quot;,
+		&quot;sad_sub44&quot;,
+		&quot;bsad&quot;,
+		&quot;variance&quot;,
+		&quot;sumsq&quot;,
+		&quot;sumsq_sub22&quot;,
+		&quot;bsumsq_sub22&quot;,
+		&quot;bsumsq&quot;,
+		&quot;build_sub22_mests&quot;,
+		&quot;build_sub44_mests&quot;,
+		&quot;subsample_image&quot;,
+		&quot;find_best_one_pel&quot;,
+		&quot;quant_nonintra&quot;,
+		&quot;quant_weight_intra&quot;,
+		&quot;quant_weight_nonintra&quot;,
+		&quot;iquant_intra&quot;,
+		&quot;iquant_nonintra&quot;,
+		NULL
+		};
+
+static char *parse_next(char **, const char *);
+
+#ifdef HAVE_X86CPU 
+
+/* Some miscelaneous stuff to allow checking whether SSE instructions cause
+   illegal instruction errors.
+*/
+#if !defined(__MINGW32__)
+static sigjmp_buf sigill_recover;
+
+static RETSIGTYPE sigillhandler(int sig )
+{
+	siglongjmp( sigill_recover, 1 );
+}
+
+typedef RETSIGTYPE (*__sig_t)(int);
+#endif
+
+static int testsseill()
+{
+	int illegal;
+#if defined(__CYGWIN__) || defined(__MINGW32__)
+	/* SSE causes a crash on CYGWIN, apparently.
+	   Perhaps the wrong signal is being caught or something along
+	   those line ;-) or maybe SSE itself won't work...
+	*/
+	illegal = 1;
+#else
+	__sig_t old_handler = signal( SIGILL, sigillhandler);
+	if( sigsetjmp( sigill_recover, 1 ) == 0 )
+	{
+		asm ( &quot;movups %xmm0, %xmm0&quot; );
+		illegal = 0;
+	}
+	else
+		illegal = 1;
+	signal( SIGILL, old_handler );
+#endif
+	return illegal;
+}
+
+static int x86_accel (void)
+{
+    intptr_t eax, ebx, ecx, edx;
+    int32_t AMD;
+    int32_t caps;
+
+	/* Slightly weirdified cpuid that preserves the ebx and edi required
+	   by gcc for PIC offset table and frame pointer */
+
+#ifdef HAVE_X86_64CPU
+#  define REG_b &quot;rbx&quot;
+#  define REG_S &quot;rsi&quot;
+#else
+#  define REG_b &quot;ebx&quot;
+#  define REG_S &quot;esi&quot;
+#endif
+	   
+#define cpuid(op,eax,ebx,ecx,edx)	\
+    asm ( &quot;push %%&quot;REG_b&quot;\n&quot; \
+	      &quot;cpuid\n&quot; \
+	      &quot;mov   %%&quot;REG_b&quot;, %%&quot;REG_S&quot;\n&quot; \
+	      &quot;pop   %%&quot;REG_b&quot;\n&quot;  \
+	 : &quot;=a&quot; (eax),			\
+	   &quot;=S&quot; (ebx),			\
+	   &quot;=c&quot; (ecx),			\
+	   &quot;=d&quot; (edx)			\
+	 : &quot;a&quot; (op)			\
+	 : &quot;cc&quot;, &quot;edi&quot;)
+
+    asm (&quot;pushf\n\t&quot;
+	 &quot;pop %0\n\t&quot;
+	 &quot;mov %0,%1\n\t&quot;
+	 &quot;xor $0x200000,%0\n\t&quot;
+	 &quot;push %0\n\t&quot;
+	 &quot;popf\n\t&quot;
+	 &quot;pushf\n\t&quot;
+	 &quot;pop %0&quot;
+         : &quot;=a&quot; (eax),
+	       &quot;=c&quot; (ecx)
+	 :
+	 : &quot;cc&quot;);
+
+
+    if (eax == ecx)		// no cpuid
+	return 0;
+
+    cpuid (0x00000000, eax, ebx, ecx, edx);
+    if (!eax)			// vendor string only
+	return 0;
+
+    AMD = (ebx == 0x68747541) &amp;&amp; (ecx == 0x444d4163) &amp;&amp; (edx == 0x69746e65);
+
+    cpuid (0x00000001, eax, ebx, ecx, edx);
+    if (! (edx &amp; 0x00800000))	// no MMX
+	return 0;
+
+    caps = ACCEL_X86_MMX;
+    /* If SSE capable CPU has same MMX extensions as AMD
+	   and then some. However, to use SSE O.S. must have signalled
+	   it use of FXSAVE/FXRSTOR through CR4.OSFXSR and hence FXSR (bit 24)
+	   here
+	*/
+    if ((edx &amp; 0x02000000))	
+		caps = ACCEL_X86_MMX | ACCEL_X86_MMXEXT;
+	if( (edx &amp; 0x03000000) == 0x03000000 )
+	{
+		/* Check whether O.S. has SSE support... has to be done with
+		   exception 'cos those Intel morons put the relevant bit
+		   in a reg that is only accesible in ring 0... doh! 
+		*/
+		if( !testsseill() )
+			caps |= ACCEL_X86_SSE;
+	}
+
+    cpuid (0x80000000, eax, ebx, ecx, edx);
+    if (eax &lt; 0x80000001)	// no extended capabilities
+		return caps;
+
+    cpuid (0x80000001, eax, ebx, ecx, edx);
+
+    if (edx &amp; 0x80000000)
+	caps |= ACCEL_X86_3DNOW;
+
+    if (AMD &amp;&amp; (edx &amp; 0x00400000))	// AMD MMX extensions
+	{
+		caps |= ACCEL_X86_MMXEXT;
+	}
+
+    return caps;
+}
+#endif
+
+
+#ifdef HAVE_ALTIVEC
+/* AltiVec optimized library for MJPEG tools MPEG-1/2 Video Encoder
+ * Copyright (C) 2002  James Klicman &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">james at klicman.org</A>&gt;
+ *
+ * The altivec_detect() function has been moved here to workaround a bug in a
+ * released version of GCC (3.3.3). When -maltivec and -mabi=altivec are
+ * specified, the bug causes VRSAVE instructions at the beginning and end of
+ * functions which do not use AltiVec. GCC 3.3.3 also lacks support for
+ * '#pragma altivec_vrsave off' which would have been the preferred workaround.
+ *
+ * This AltiVec detection code relies on the operating system to provide an
+ * illegal instruction signal if AltiVec is not present. It is known to work
+ * on Mac OS X and Linux.
+ */
+
+static sigjmp_buf jmpbuf;
+
+static void sig_ill(int sig)
+{
+    siglongjmp(jmpbuf, 1);
+}
+
+int detect_altivec()
+{
+    volatile int detected = 0; /* volatile (modified after sigsetjmp) */
+    struct sigaction act, oact;
+
+    act.sa_handler = sig_ill;
+    sigemptyset(&amp;act.sa_mask);
+    act.sa_flags = 0;
+
+    if (sigaction(SIGILL, &amp;act, &amp;oact)) {
+	perror(&quot;sigaction&quot;);
+	return 0;
+    }
+
+    if (sigsetjmp(jmpbuf, 1))
+	goto noAltiVec;
+
+    /* try to read an AltiVec register */ 
+    altivec_copy_v0();
+
+    detected = 1;
+
+noAltiVec:
+    if (sigaction(SIGILL, &amp;oact, (struct sigaction *)0))
+	perror(&quot;sigaction&quot;);
+
+    return detected;
+}
+#endif
+
+
+int32_t cpu_accel (void)
+{
+#ifdef HAVE_X86CPU 
+    static int got_accel = 0;
+    static int accel;
+
+    if (!got_accel) {
+		got_accel = 1;
+		accel = x86_accel ();
+    }
+
+    return accel;
+#elif defined(HAVE_ALTIVEC)
+    return detect_altivec();
+#else
+    return 0;
+#endif
+}
+
+/*****************************
+ *
+ * Allocate memory aligned to suit SIMD 
+ *
+ ****************************/
+
+#define powerof2(x)     ((((x)-1)&amp;(x))==0)
+
+#if	!defined(HAVE_POSIX_MEMALIGN)
+
+int
+posix_memalign(void **ptr, size_t alignment, size_t size)
+{
+	void *mem;
+
+	if	(alignment % sizeof (void *) != 0 || !powerof2(alignment) != 0)
+		return(EINVAL);
+	mem = malloc((size + alignment - 1) &amp; ~(alignment - 1));
+	if	(mem != NULL)
+	{
+		*ptr = mem;
+		return(0);
+	}
+	return(ENOMEM);
+}
+#endif
+
+#if	!defined(HAVE_MEMALIGN)
+void *
+memalign(size_t alignment, size_t size)
+{
+
+	if 	(alignment % sizeof (void *) || !powerof2(alignment))
+	{
+		errno = EINVAL;
+		return(NULL);
+	}
+	return(malloc((size + alignment - 1) &amp; ~(alignment - 1)));
+}
+#endif
+
+/***********************
+ * Implement fmax() for systems which do not have it.  Not a strictly
+ * conforming implementation - we don't bother checking for NaN which if
+ * mpeg2enc gets means big trouble I suspect ;)
+************************/
+
+#if	!defined(HAVE_FMAX)
+double
+fmax(double x, double y)
+{
+	if	(x &gt; y)
+		return(x);
+	return(y);
+}
+#endif
+
+void *bufalloc( size_t size )
+{
+	static size_t simd_alignment = 16;
+	static int bufalloc_init = 0;
+	int  pgsize;
+	void *buf = NULL;
+
+	if( !bufalloc_init )
+	{
+#ifdef HAVE_X86CPU 
+		if( (cpu_accel() &amp;  (ACCEL_X86_SSE|ACCEL_X86_3DNOW)) != 0 )
+		{
+			simd_alignment = 64;
+			bufalloc_init = 1;
+		}
+#endif		
+	}
+		
+#ifdef __MINGW32__	// GRUNTSTER
+	pgsize = 4096;
+#else
+	pgsize = sysconf(_SC_PAGESIZE);
+#endif
+
+/*
+ * If posix_memalign fails it could be a broken glibc that caused the error,
+ * so try again with a page aligned memalign request
+*/
+	if (posix_memalign( &amp;buf, simd_alignment, size))
+		buf = memalign(pgsize, size);
+	if (buf &amp;&amp; ((size_t)buf &amp; (simd_alignment - 1)))
+	{
+		free(buf);
+		buf = memalign(pgsize, size);
+	}
+	if (buf == NULL)
+		mjpeg_error_exit1(&quot;malloc of %d bytes failed&quot;, (int)size);
+	if ((size_t)buf &amp; (simd_alignment - 1))
+		mjpeg_error_exit1(&quot;could not allocate %d bytes aligned on a %d byte boundary&quot;, (int)size, (int)simd_alignment);
+	return buf;
+}
+
+int
+disable_simd(char *name)
+	{
+	int	foundit;
+	char	*cp, *simd_env, *dup_backup;
+	const char **dft;
+
+	if	((cp = getenv(&quot;MJPEGTOOLS_SIMD_DISABLE&quot;)) == NULL)
+		return(0);
+
+/*
+ * Special case for &quot;all&quot; so that all 22 or whatever names don't have to be
+ * explicitly specified.  If &quot;all&quot; is seen as the only name in the environment
+ * variable then always return 1.
+*/
+	if	(strcasecmp(cp, &quot;all&quot;) == 0)
+		return(1);
+
+/*
+ * First check that the routine being tested for disabled status exists in
+ * the list of known functions.
+*/
+	foundit = 0;
+	for	(dft = disable_simd_flags; *dft; dft++)
+		{
+		if	(strcasecmp(name, *dft) == 0)
+			{
+			foundit = 1;
+			break;
+			}
+		}
+	if	(foundit == 0)
+		return(0);
+
+/*
+ * Next compare the function name passed as input to the comma separated
+ * names in the environment variable.  If a match is found then return 1
+*/
+	dup_backup = simd_env = strdup(cp);
+	while	((cp = parse_next(&amp;simd_env, &quot;,&quot;)))
+		{
+		foundit = 0;
+		if	(strcasecmp(cp, name) == 0)
+			{
+			foundit = 1;
+			break;
+			}
+		}
+	free(dup_backup);
+	return(foundit);
+	}
+
+static char *parse_next(char **sptr, const char *delim)
+{
+	char *start, *ret;
+	start = ret = *sptr;
+	if ((ret == NULL) || ret == '\0') {
+	   return (NULL);
+	}
+
+	while (*ret != '\0' &amp;&amp;
+		   strchr(delim, *ret) == NULL) {
+		ret++;
+	}
+	if (*ret == '\0') {
+		*sptr = NULL;
+	} else {
+	    *ret = '\0';
+	    ret++;
+	    *sptr = ret;
+	}
+	return (start);
+}

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/cpu_accel.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/cpu_accel.h	2009-09-04 15:59:41 UTC (rev 5319)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/cpu_accel.h	2009-09-05 08:19:09 UTC (rev 5320)
@@ -0,0 +1,58 @@
+/*
+ * cpu_accel.h
+ * Copyright (C) 1999-2000 Aaron Holtzman &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">aholtzma at ess.engr.uvic.ca</A>&gt;
+ *
+ * This file was part of mpeg2dec, a free MPEG-2 video stream decoder.
+ *
+ * mpeg2dec is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * mpeg2dec is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef _CPU_ACCEL_HH
+#define _CPU_ACCEL_HH
+
+#include &lt;stdlib.h&gt;
+#include &quot;mjpeg_types.h&quot;
+
+
+// x86 accelerations
+#define ACCEL_X86_MMX	0x80000000
+#define ACCEL_X86_3DNOW	0x40000000
+#define ACCEL_X86_MMXEXT 0x20000000
+#define ACCEL_X86_SSE   0x10000000
+
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+	int32_t cpu_accel (void);
+	void *bufalloc( size_t size );
+#if	!defined(HAVE_POSIX_MEMALIGN)
+	int posix_memalign(void **, size_t, size_t);
+#endif
+#if	!defined(HAVE_MEMALIGN)
+	void *memalign(size_t, size_t);
+#endif
+#if	!defined(HAVE_FMAX)
+	double fmax(double, double);
+#endif
+
+extern const char *disable_simd_flags[];
+extern int disable_simd(char *);
+
+#ifdef __cplusplus
+}
+#endif
+
+
+#endif

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/decodebufmodel.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/decodebufmodel.cpp	2009-09-04 15:59:41 UTC (rev 5319)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/decodebufmodel.cpp	2009-09-05 08:19:09 UTC (rev 5320)
@@ -0,0 +1,83 @@
+#ifdef HAVE_CONFIG_H
+#include &quot;config.h&quot;
+#endif
+
+#include &quot;decodebufmodel.hpp&quot;
+#include &lt;stdlib.h&gt;
+
+using std::deque;
+
+/******************************************************************
+ *	Remove entries from FIFO buffer list, if their DTS is less than
+ *	actual SCR. These packet data have been already decoded and have
+ *	been removed from the system target decoder's elementary stream
+ *	buffer.
+ *****************************************************************/
+
+void DecodeBufModel::Cleaned(clockticks SCR)
+{
+    while ( bufstate.size() != 0 &amp;&amp; bufstate.front().DTS &lt; SCR)
+    {
+		bufstate.pop_front();
+    }
+}
+
+/******************************************************************
+ * Return the SCR when there will next be some change in the
+ * buffer.
+ * If the buffer is empty return a zero timestamp.
+ *****************************************************************/
+
+clockticks DecodeBufModel::NextChange()
+{
+	if( bufstate.size() == 0 )
+		return static_cast&lt;clockticks&gt;(0);
+	else
+		return bufstate.front().DTS;
+}
+
+
+/******************************************************************
+ *
+ *	Remove all entries from FIFO buffer list.
+ *
+ *****************************************************************/
+
+void DecodeBufModel::Flushed ()
+{
+	bufstate.clear();
+}
+
+/******************************************************************
+	DecodeBufModel::Space
+
+	returns free space in the buffer
+******************************************************************/
+
+unsigned int DecodeBufModel::Space ()
+{
+	unsigned int used_bytes = 0;
+	for( std::deque&lt;DecodeBufEntry&gt;::iterator i = bufstate.begin(); 
+		 i &lt; bufstate.end();
+		 ++i )
+	{
+		used_bytes += i-&gt;size;
+    }
+
+    return (buffer_size - used_bytes);
+
+}
+
+/******************************************************************
+	Queue_Buffer
+
+	adds entry into the buffer FIFO queue
+******************************************************************/
+
+void DecodeBufModel::Queued (unsigned int bytes, clockticks TS)
+{
+	DecodeBufEntry entry;
+	entry.size = bytes;
+	entry.DTS = TS;
+	bufstate.push_back( entry );
+}

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/decodebufmodel.hpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/decodebufmodel.hpp	2009-09-04 15:59:41 UTC (rev 5319)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/decodebufmodel.hpp	2009-09-05 08:19:09 UTC (rev 5320)
@@ -0,0 +1,68 @@
+
+/*
+ *  buffer.hpp:  Classes for decoder buffer models for mux despatch
+ *
+ *  Copyright (C) 2001 Andrew Stevens &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">andrew.stevens at philips.com</A>&gt;
+ *
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of version 2 of the GNU General Public License
+ *  as published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+
+#ifndef __DECODEBUFMODEL_H__
+#define __DECODEBUFMODEL_H__
+
+#include &quot;aunit.hpp&quot;
+#include &lt;deque&gt;
+
+
+struct DecodeBufEntry
+{
+	unsigned int size	;	/* als verkettete Liste implementiert	*/
+    clockticks DTS	;
+};
+    
+
+class DecodeBufModel
+{
+public:
+  DecodeBufModel() : buffer_size(0) {}
+  void Init ( unsigned int size)
+  {
+    buffer_size = size;
+  }
+  
+  void Cleaned(  clockticks timenow);
+  clockticks NextChange();
+  void Flushed( );
+  unsigned int Space();
+  void Queued( unsigned int bytes, clockticks removaltime);
+  inline unsigned int Size() { return buffer_size; }
+private:
+  unsigned int buffer_size;
+  std::deque&lt;DecodeBufEntry&gt; bufstate ;
+};
+
+
+
+#endif // __DECODEBUFMODEL_H__
+
+
+/* 
+ * Local variables:
+ *  c-file-style: &quot;gnu&quot;
+ *  tab-width: 4
+ *  indent-tabs-mode: nil
+ * End:
+ */

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/dtsstrm_in.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/dtsstrm_in.cpp	2009-09-04 15:59:41 UTC (rev 5319)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/dtsstrm_in.cpp	2009-09-05 08:19:09 UTC (rev 5320)
@@ -0,0 +1,398 @@
+/*
+ *  dtsstrm_in.c: dts Audio stream class members handling scanning and
+ *  buffering raw input stream.
+ *
+ *  Copyright (C) 2003 Markus Plail &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">plail at web.de</A>&gt;
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of version 2 of the GNU General Public License
+ *  as published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+#include &lt;config.h&gt;
+#include &lt;math.h&gt;
+#include &lt;stdlib.h&gt;
+
+#include &quot;audiostrm.hpp&quot;
+#include &quot;interact.hpp&quot;
+#include &quot;multiplexor.hpp&quot;
+
+#define DTS_SYNCWORD            0x7ffe8001
+#define DTS_PACKET_SAMPLES      1536
+
+const unsigned int DTSStream::default_buffer_size = 16*1024;
+
+/// table for the available dts bitrates
+static const unsigned int dts_bitrate_index[32] =
+{ 32,56,64,96,112,128,192,224,
+  256,320,384,448,512,576,640,768,
+  960,1024,1152,1280,1344,1408,1411,1472,
+  1536,1920,2048,3072,3840,0,0,0
+};
+
+/// table for the available dts frequencies
+static const unsigned int dts_frequency[17] = 
+{ 0, 8000, 16000, 32000, 0, 0, 11025, 22050, 44100, 0, 0, 12000, 24000, 48000, 0, 0 };
+
+/// samples per frame
+static const unsigned int dts_packet_samples[4] = 
+{ 256, 512, 1024, 2048 };
+
+
+DTSStream::DTSStream(IBitStream &amp;ibs, Multiplexor &amp;into) : 
+	AudioStream( ibs, into )
+{
+	num_frames = 0;
+}
+
+bool DTSStream::Probe(IBitStream &amp;bs )
+{
+    return bs.GetBits(32) == DTS_SYNCWORD;
+}
+
+#ifdef DEBUG_DTS
+
+static char *binString(int value, int length)
+{
+    char *bin = (char *) malloc((length + 1) * sizeof(char));
+    int index;
+    int dummy = 1 &lt;&lt; (length - 1);
+
+    for(index = 0; index &lt; length; index++)
+    {
+        if(value &amp; dummy)
+            bin[index] = '1';
+        else
+            bin[index] = '0';
+
+        dummy &gt;&gt;= 1;
+    }
+    bin[index] = '\0';
+
+    return(bin);
+}
+
+
+/*************************************************************************
+ *
+ * Reads initial stream parameters and displays feedback banner to users
+ * @param stream_num dts substream ID
+ *************************************************************************/
+
+
+void  DTSStream::DisplayDtsHeaderInfo()
+{
+    /* Some stuff to generate frame-header information */
+    printf( &quot;normal/termination? = %i\n&quot;, bs.GetBits(1) ); 
+    printf( &quot;deficit sample count = %i\n&quot;, bs.GetBits(5) ); 
+    int crc = bs.GetBits(1);
+    printf( &quot;CRC present? = %i\n&quot;, crc ); 
+    printf( &quot;PCM samples = %i\n&quot;, bs.GetBits(7) ); 
+    printf( &quot;frame byte size = %i\n&quot;, bs.GetBits(14) ); 
+    int acmode = bs.GetBits(6);
+    printf( &quot;audio channel = %s\n&quot;, binString(acmode, 6) ); 
+    printf( &quot;audio sampling freqency = %s\n&quot;, binString(bs.GetBits(4), 4) ); 
+    printf( &quot;bit rate = %s\n&quot;, binString(bs.GetBits(5), 5) ); 
+    printf( &quot;downmix enabled = %i\n&quot;, bs.GetBits(1) ); 
+    printf( &quot;dynamic range flag = %i\n&quot;, bs.GetBits(1) ); 
+    printf( &quot;time stamp = %i\n&quot;, bs.GetBits(1) ); 
+    printf( &quot;auxiliary data = %i\n&quot;, bs.GetBits(1) ); 
+    printf( &quot;HDCD = %i\n&quot;, bs.GetBits(1) ); 
+    printf( &quot;extended coding flag = %i\n&quot;, bs.GetBits(1) ); 
+    printf( &quot;audio sync word insert = %i\n&quot;, bs.GetBits(1) ); 
+    printf( &quot;low frequency effects = %i\n&quot;, bs.GetBits(1) ); 
+    printf( &quot;predictor history = %i\n&quot;, bs.GetBits(1) ); 
+    if (crc) printf( &quot;CRC = %i\n&quot;, bs.GetBits(16) ); 
+    printf( &quot;multirate interpolator = %i\n&quot;, bs.GetBits(1) ); 
+    printf( &quot;encoder software revision = %i\n&quot;, bs.GetBits(4) ); 
+    printf( &quot;copy history = %i\n&quot;, bs.GetBits(2) ); 
+    printf( &quot;PCM resolution = %s\n&quot;, binString(bs.GetBits(3), 3) ); 
+    printf( &quot;front sums difference flags = %i\n&quot;, bs.GetBits(1) ); 
+    printf( &quot;surround sums difference flags = %i\n&quot;, bs.GetBits(1) ); 
+    printf( &quot;dialog normalization parameter = %i\n&quot;, bs.GetBits(4) ); 
+}
+#endif
+void DTSStream::Init ( const int _stream_num)
+
+{
+    stream_num = _stream_num;
+	MuxStream::Init( PRIVATE_STR_1, 
+					 1,  // Buffer scale
+					 default_buffer_size,
+					 false,
+					 muxinto.buffers_in_audio,
+					 muxinto.always_buffers_in_audio
+		);
+    mjpeg_info (&quot;Scanning for header info: dts Audio stream %02x (%s)&quot;,
+                stream_num,
+                bs.StreamName()
+                );
+
+	AU_start = bs.bitcount();
+    if (bs.GetBits(32)==DTS_SYNCWORD)
+    {
+		num_syncword++;
+        bs.GetBits(6);         // additional sync
+        bs.GetBits(1);         // CRC
+        bs.GetBits(7);         // pcm samples
+        framesize = bs.GetBits(14) + 1;        // frame size
+
+        bs.GetBits(6);         // audio channels
+        frequency = bs.GetBits(4);  // sample rate code
+        bit_rate = dts_bitrate_index[bs.GetBits(5)];
+        bs.GetBits(5);              // misc.
+
+        header_skip = 10;        // Initially skipped past 10 bytes of header 
+
+		num_frames++;
+        access_unit.start = AU_start;
+		access_unit.length = framesize;
+        mjpeg_info( &quot;dts frame size = %d&quot;, framesize );
+		samples_per_second = dts_frequency[frequency];
+
+		/* Presentation time-stamping  */
+		access_unit.PTS = static_cast&lt;clockticks&gt;(decoding_order) * 
+			static_cast&lt;clockticks&gt;(DTS_PACKET_SAMPLES) * 
+			static_cast&lt;clockticks&gt;(CLOCKS)	/ samples_per_second;
+		access_unit.DTS = access_unit.PTS;
+		access_unit.dorder = decoding_order;
+		++decoding_order;
+		aunits.Append( access_unit );
+
+    } else
+    {
+		mjpeg_error ( &quot;Invalid dts Audio stream header.&quot;);
+		exit (1);
+    }
+	OutputHdrInfo();
+}
+
+/// @returns the current bitrate
+unsigned int DTSStream::NominalBitRate()
+{ 
+	return bit_rate*1024;
+}
+
+/// Prefills the internal buffer for output multiplexing.
+/// @param frames_to_buffer the number of audio frames to read ahead
+void DTSStream::FillAUbuffer(unsigned int frames_to_buffer )
+{
+    unsigned int packet_samples;
+
+	last_buffered_AU += frames_to_buffer;
+	mjpeg_debug( &quot;Scanning %d dts audio frames to frame %d&quot;, 
+				 frames_to_buffer, last_buffered_AU );
+
+	while( !bs.eos() &amp;&amp; decoding_order &lt; last_buffered_AU 
+            &amp;&amp; !muxinto.AfterMaxPTS(access_unit.PTS) )
+	{
+		int skip = access_unit.length - header_skip; 
+        bs.SeekFwdBits(skip);
+		prev_offset = AU_start;
+		AU_start = bs.bitcount();
+
+        if( AU_start - prev_offset != access_unit.length*8 )
+        {
+            mjpeg_warn( &quot;Discarding incomplete final frame dts stream %d!&quot;,
+                       stream_num);
+            aunits.DropLast();
+            decoding_order--;
+            break;
+        }
+
+		/* Check if we have reached the end or have  another catenated 
+		   stream to process before finishing ... */
+		if ( (syncword = bs.GetBits(32))!=DTS_SYNCWORD )
+		{
+			if( !bs.eos()   )
+			{
+				mjpeg_error_exit1( &quot;Can't find next dts frame: @ %lld we have %04x - broken bit-stream?&quot;, AU_start/8, syncword );
+            }
+            break;
+		}
+
+        bs.GetBits(6);         // additional sync
+        bs.GetBits(1);         // CRC
+        packet_samples = (bs.GetBits(7) + 1) * 32;         // pcm samples
+        framesize = bs.GetBits(14) + 1;        // frame size
+
+        bs.GetBits(6);              // audio channels
+        bs.GetBits(4);              // sample rate code
+        bs.GetBits(5);              // bitrate
+        bs.GetBits(5);              // misc.
+
+        access_unit.start = AU_start;
+		access_unit.length = framesize;
+		access_unit.PTS = static_cast&lt;clockticks&gt;(decoding_order) * 
+			static_cast&lt;clockticks&gt;(packet_samples) * 
+			static_cast&lt;clockticks&gt;(CLOCKS)	/ samples_per_second;
+		access_unit.DTS = access_unit.PTS;
+		access_unit.dorder = decoding_order;
+		decoding_order++;
+		aunits.Append( access_unit );
+		num_frames++;
+
+		num_syncword++;
+
+		if (num_syncword &gt;= old_frames+10 )
+		{
+			mjpeg_debug (&quot;Got %d frame headers.&quot;, num_syncword);
+			old_frames=num_syncword;
+		}
+
+    }
+	last_buffered_AU = decoding_order;
+	eoscan = bs.eos() || muxinto.AfterMaxPTS(access_unit.PTS);
+}
+
+
+/// Closes the dts stream and prints some statistics.
+void DTSStream::Close()
+{
+    stream_length = AU_start &gt;&gt; 3;
+	mjpeg_info (&quot;DTS STATISTICS: %02x&quot;, stream_id); 
+    mjpeg_info (&quot;Audio stream length %lld bytes.&quot;, stream_length);
+    mjpeg_info   (&quot;Frames         : %8u&quot;,  num_frames);
+}
+
+/*************************************************************************
+	OutputAudioInfo
+	gibt gesammelte Informationen zu den Audio Access Units aus.
+
+	Prints information on audio access units
+*************************************************************************/
+
+void DTSStream::OutputHdrInfo ()
+{
+	mjpeg_info(&quot;dts AUDIO STREAM:&quot;);
+
+    mjpeg_info (&quot;Bit rate       : %8u bytes/sec (%3u kbit/sec)&quot;,
+				bit_rate*128, bit_rate);
+
+    if (frequency == 3)
+		mjpeg_info (&quot;Frequency      : reserved&quot;);
+    else
+		mjpeg_info (&quot;Frequency      :     %d Hz&quot;,
+				dts_frequency[frequency]);
+
+}
+
+/**
+Reads the bytes neccessary to complete the current packet payload. 
<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">+ at param</A> to_read number of bytes to read
<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">+ at param</A> dst byte buffer pointer to read to 
<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">+ at returns</A> the number of bytes read
+ */
+unsigned int 
+DTSStream::ReadPacketPayload(uint8_t *dst, unsigned int to_read)
+{
+	clockticks   decode_time;
+    // TODO: BUG BUG BUG: if there is a change in format in the stream
+    // this framesize will be invalid!  It only *looks* like it works...
+    // really each AU should store its own framesize...
+    unsigned int frames = to_read / framesize;
+    bitcount_t read_start = bs.GetBytePos();
+    unsigned int bytes_read =  bs.GetBytes( dst + 4, framesize * frames);
+    unsigned int bytes_muxed = bytes_read;
+
+    assert( bytes_read &gt; 0 );   // Should never try to read nothing
+
+    bs.Flush( read_start );
+
+    unsigned int first_header = 
+        (new_au_next_sec || au_unsent &gt; bytes_read )
+        ? 0 
+        : au_unsent;
+
+    // BUG BUG BUG: how do we set the 1st header pointer if we have
+    // the *middle* part of a large frame?
+    assert( first_header+2 &lt;= to_read );
+
+    unsigned int syncwords = 0;
+  
+	if (bytes_muxed == 0 || MuxCompleted() )
+    {
+		goto completion;
+    }
+
+
+	/* Work through what's left of the current AU and the following AU's
+	   updating the info until we reach a point where an AU had to be
+	   split between packets.
+	   NOTE: It *is* possible for this loop to iterate. 
+
+	   The DTS/PTS field for the packet in this case would have been
+	   given the that for the first AU to start in the packet.
+
+	*/
+
+	decode_time = RequiredDTS();
+	while (au_unsent &lt; bytes_muxed)
+	{	  
+        // BUG BUG BUG: if we ever had odd payload / packet size we might
+        // split a DTS frame in the middle of the syncword!
+        assert( bytes_muxed &gt; 1 );
+		bufmodel.Queued(au_unsent, decode_time);
+		bytes_muxed -= au_unsent;
+        if( new_au_next_sec )
+            ++syncwords;
+		if( !NextAU() )
+        {
+            goto completion;
+        }
+		new_au_next_sec = true;
+		decode_time = RequiredDTS();
+	};
+
+	// We've now reached a point where the current AU overran or
+	// fitted exactly.  We need to distinguish the latter case
+	// so we can record whether the next packet starts with an
+	// existing AU or not - info we need to decide what PTS/DTS
+	// info to write at the start of the next packet.
+	
+	if (au_unsent &gt; bytes_muxed)
+	{
+        if( new_au_next_sec )
+            ++syncwords;
+		bufmodel.Queued( bytes_muxed, decode_time);
+		au_unsent -= bytes_muxed;
+		new_au_next_sec = false;
+	} 
+	else //  if (au_unsent == bytes_muxed)
+	{
+		bufmodel.Queued(bytes_muxed, decode_time);
+        if( new_au_next_sec )
+            ++syncwords;
+        new_au_next_sec = NextAU();
+	}	   
+
+completion:
+    // Generate the dts header...
+    // Note the index counts from the low byte of the offset so
+    // the smallest value is 1!
+    dst[0] = DTS_SUB_STR_0 + stream_num;
+    dst[1] = frames;
+    dst[2] = (first_header+1)&gt;&gt;8;
+    dst[3] = (first_header+1)&amp;0xff;
+
+	return bytes_read + 4;
+}
+
+
+
+/* 
+ * Local variables:
+ *  c-file-style: &quot;stroustrup&quot;
+ *  tab-width: 4
+ *  indent-tabs-mode: nil
+ * End:
+ */

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/format_codes.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/format_codes.h	2009-09-04 15:59:41 UTC (rev 5319)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/format_codes.h	2009-09-05 08:19:09 UTC (rev 5320)
@@ -0,0 +1,39 @@
+/*
+    $Id: format_codes.h,v 1.9 2002/12/17 21:54:24 wackston2 Exp $
+
+    Copyright (C) 2001 Andrew Stevens &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">andrew.stevens at planet-interkom.de</A>&gt;
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
+
+#ifndef __FORMAT_CODES_H__
+#define __FORMAT_CODES_H__
+
+#define MPEG_FORMAT_MPEG1   0
+#define MPEG_FORMAT_VCD     1
+#define MPEG_FORMAT_VCD_NSR 2
+#define MPEG_FORMAT_MPEG2   3
+#define MPEG_FORMAT_SVCD     4
+#define MPEG_FORMAT_SVCD_NSR 5
+#define MPEG_FORMAT_VCD_STILL 6
+#define MPEG_FORMAT_SVCD_STILL 7
+#define MPEG_FORMAT_DVD_NAV 8
+#define MPEG_FORMAT_DVD      9
+
+#define MPEG_FORMAT_FIRST 0
+#define MPEG_FORMAT_LAST MPEG_FORMAT_DVD
+
+#define MPEG_STILLS_FORMAT(x) (x==MPEG_FORMAT_VCD_STILL||x==MPEG_FORMAT_SVCD_STILL)
+#endif /* __FORMAT_CODES_H__ */

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/inputstrm.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/inputstrm.cpp	2009-09-04 15:59:41 UTC (rev 5319)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/inputstrm.cpp	2009-09-05 08:19:09 UTC (rev 5320)
@@ -0,0 +1,283 @@
+
+/*
+ *  inputstrm.c:  Base classes related to muxing out input streams into
+ *                the output stream.
+ *
+ *  Copyright (C) 2001 Andrew Stevens &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">andrew.stevens at philips.com</A>&gt;
+ *
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of version 2 of the GNU General Public License
+ *  as published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+
+#include &lt;config.h&gt;
+#include &lt;assert.h&gt;
+#include &lt;limits.h&gt;
+
+#include &quot;mjpeg_types.h&quot;
+#include &quot;inputstrm.hpp&quot;
+#include &quot;multiplexor.hpp&quot;
+
+MuxStream::MuxStream() : init(false) 
+{
+}
+
+void MuxStream::Init( const int strm_id, 
+			const unsigned int _buf_scale,
+			const unsigned int buf_size,
+			const unsigned int _zero_stuffing,
+			bool bufs_in_first, 
+			bool always_bufs) 
+{
+	stream_id = strm_id;
+	nsec = 0;
+	zero_stuffing = _zero_stuffing;
+	buffer_scale = _buf_scale;
+	buffer_size = buf_size;
+	bufmodel.Init( buf_size );
+	buffers_in_header = bufs_in_first;
+	always_buffers_in_header = always_bufs;
+	new_au_next_sec = true;
+	init = true;
+    min_pes_header_len = 0;
+}
+
+
+unsigned int 
+MuxStream::BufferSizeCode()
+{
+	if( buffer_scale == 1 )
+		return buffer_size / 1024;
+	else if( buffer_scale == 0 )
+		return buffer_size / 128;
+	else
+		assert(false);
+    return 0;                   // Never reached...
+}
+
+
+ElementaryStream::ElementaryStream( IBitStream &amp;ibs,
+                                    Multiplexor &amp;into, stream_kind _kind) : 
+    InputStream( ibs ),
+    au(0),
+	muxinto( into ),
+	kind(_kind),
+    buffer_min(INT_MAX),
+    buffer_max(1)
+{
+}
+
+/***********************************
+ *
+ * Scan ahead to buffer enough info on the coming Access Units to
+ * permit look-ahead of look_ahead/processing AUs forward from the
+ * current AU *and* the muxing of at least one sector.
+ *
+ **********************************/
+
+void 
+ElementaryStream::AUBufferLookaheadFill( unsigned int look_ahead)
+{
+    while( !eoscan &amp;&amp;
+           ( look_ahead+1 &gt; aunits.MaxAULookahead() 
+             || bs.BufferedBytes() &lt; muxinto.sector_size ) )
+    {
+        FillAUbuffer(FRAME_CHUNK);
+    }
+}
+
+/******************************************
+ *
+ * Move on to the next Access unit in the Elementary stream
+ *
+ *****************************************/
+
+bool 
+ElementaryStream::NextAU()
+{
+    // Free up no longer needed AU record
+    if( au != 0 )
+        delete au;
+
+    // Ensure we have enough in the AU buffer!
+    AUBufferLookaheadFill(1);
+
+    // Get the details of the next AU to be muxed....
+	AUnit *p_au = aunits.Next();
+	if( p_au != NULL )
+	{
+		au = p_au;
+		au_unsent = p_au-&gt;length;
+		return true;
+	}
+	else
+	{
+		au_unsent = 0;
+		return false;
+	}
+}
+
+
+AUnit *
+ElementaryStream::Lookahead( unsigned int n)
+{
+    AUBufferLookaheadFill(n);
+    return aunits.Lookahead( n );
+}
+
+unsigned int 
+ElementaryStream::BytesToMuxAUEnd(unsigned int sector_transport_size)
+{
+	return (au_unsent/min_packet_data)*sector_transport_size +
+		(au_unsent%min_packet_data)+(sector_transport_size-min_packet_data);
+}
+
+
+/******************************************************************
+ *	ElementaryStream::ReadPacketPayload
+ *
+ *  Reads the stream data from actual input stream, updates decode
+ *  buffer model and current access unit information from the
+ *  look-ahead scanning buffer to account for bytes_muxed bytes being
+ *  muxed out.  Particular important is the maintenance of &quot;au_unsent&quot;
+ *  the count of how much data in the current AU remains umuxed.  It
+ *  not only allows us to keep track of AU's but is also used for
+ *  generating substream headers
+ *
+ *  Unless we need to over-ride it to handle sub-stream headers
+ * The packet payload for an elementary stream is simply the parsed and
+ * spliced buffered stream data..
+ *
+ ******************************************************************/
+
+
+unsigned int 
+ElementaryStream::ReadPacketPayload(uint8_t *dst, unsigned int to_read)
+{
+    //
+    // Allow for the possibility that stream sub-headers might be needed
+    // E.g. AC3, LPCM, DTS....
+    unsigned int header_size = StreamHeaderSize();
+    bitcount_t read_start = bs.GetBytePos();
+    unsigned int actually_read = bs.GetBytes( dst+header_size, to_read-header_size );
+    bs.Flush( read_start );
+    Muxed( actually_read );
+    ReadStreamHeader(dst, header_size);
+	return actually_read;
+}
+
+void ElementaryStream::Muxed (unsigned int bytes_muxed)
+{
+	clockticks   decode_time;
+  
+	if (bytes_muxed == 0 || MuxCompleted() )
+		return;
+
+
+	/* Work through what's left of the current AU and the following AU's
+	   updating the info until we reach a point where an AU had to be
+	   split between packets.
+	   NOTE: It *is* possible for this loop to iterate. 
+
+	   The DTS/PTS field for the packet in this case would have been
+	   given the that for the first AU to start in the packet.
+	   Whether Joe-Blow's hardware VCD player handles this properly is
+	   another matter of course!
+	*/
+
+	decode_time = RequiredDTS();
+	while (au_unsent &lt; bytes_muxed)
+	{	  
+        AUMuxed(true);          // Update stream specific tracking 
+                                // of AUs muxed...
+		bufmodel.Queued(au_unsent, decode_time);
+		bytes_muxed -= au_unsent;
+        new_au_next_sec = NextAU();
+        if( !new_au_next_sec )
+			return;
+		decode_time = RequiredDTS();
+	};
+
+	// We've now reached a point where the current AU overran or
+	// fitted exactly.  We need to distinguish the latter case
+	// so we can record whether the next packet starts with an
+	// existing AU or not - info we need to decide what PTS/DTS
+	// info to write at the start of the next packet.
+	
+	if (au_unsent &gt; bytes_muxed)
+	{
+        AUMuxed(false);
+		bufmodel.Queued( bytes_muxed, decode_time);
+		au_unsent -= bytes_muxed;
+		new_au_next_sec = false;
+	} 
+	else //  if (au_unsent == bytes_muxed)
+	{
+        AUMuxed(false);
+		bufmodel.Queued(bytes_muxed, decode_time);
+		new_au_next_sec = NextAU();
+	}	   
+
+}
+
+bool ElementaryStream::MuxPossible(clockticks currentSCR)
+{
+	return (!RunOutComplete() &amp;&amp;
+			bufmodel.Space() &gt; max_packet_data);
+}
+
+void ElementaryStream::UpdateBufferMinMax()
+{
+    buffer_min =  buffer_min &lt; bufmodel.Space() ? 
+        buffer_min : bufmodel.Space();
+    buffer_max = buffer_max &gt; bufmodel.Space() ? 
+        buffer_max : bufmodel.Space();
+}
+
+
+void ElementaryStream::AllDemuxed()
+{
+	bufmodel.Flushed();
+}
+
+void ElementaryStream::DemuxedTo( clockticks SCR )
+{
+	bufmodel.Cleaned( SCR );
+}
+
+bool ElementaryStream::MuxCompleted()
+{
+	return au_unsent == 0;
+}
+
+void 
+ElementaryStream::SetSyncOffset( clockticks sync_offset )
+{
+	timestamp_delay = sync_offset;
+}
+
+void ElementaryStream::BufferAndOutputSector( )
+{
+    AUBufferLookaheadFill(1);   // TODO is this really needed here?
+    OutputSector();
+}
+
+
+/* 
+ * Local variables:
+ *  c-file-style: &quot;stroustrup&quot;
+ *  tab-width: 4
+ *  indent-tabs-mode: nil
+ * End:
+ */

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/inputstrm.hpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/inputstrm.hpp	2009-09-04 15:59:41 UTC (rev 5319)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/inputstrm.hpp	2009-09-05 08:19:09 UTC (rev 5320)
@@ -0,0 +1,285 @@
+
+/*
+ *  inptstrm.hpp:  Input stream classes for MPEG multiplexing
+ *
+ *  Copyright (C) 2001 Andrew Stevens &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">andrew.stevens at philips.com</A>&gt;
+ *
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of version 2 of the GNU General Public License
+ *  as published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+#ifndef __INPUTSTRM_H__
+#define __INPUTSTRM_H__
+
+#include &lt;stdio.h&gt;
+#include &lt;vector&gt;
+#include &lt;sys/stat.h&gt;
+
+#include &quot;mjpeg_types.h&quot;
+#include &quot;mpegconsts.h&quot;
+#include &quot;format_codes.h&quot;
+#include &quot;mjpeg_logging.h&quot;
+
+#include &quot;mplexconsts.hpp&quot;
+#include &quot;bits.hpp&quot;
+#include &quot;aunitbuffer.hpp&quot;
+#include &quot;decodebufmodel.hpp&quot;
+
+using std::vector;
+
+class InputStream
+{
+public:
+	InputStream( IBitStream &amp;istream ) :
+		stream_length(0),
+        bs( istream ),
+		eoscan(false),
+		last_buffered_AU(0),
+		decoding_order(0),
+		old_frames(0)
+		{}
+
+	void SetBufSize( unsigned int buf_size )
+		{
+			bs.SetBufSize( buf_size );
+		}
+
+    bitcount_t stream_length;
+
+protected:
+	off_t      file_length;
+    IBitStream &bs;
+	bool eoscan;
+	
+	unsigned int last_buffered_AU;		// decode seq num of last buffered frame + 1
+   	bitcount_t AU_start;
+    uint32_t  syncword;
+    bitcount_t prev_offset;
+    unsigned int decoding_order;
+    unsigned int old_frames;
+
+};
+
+class Multiplexor;
+
+
+class MuxStream 
+{
+public:
+	MuxStream();
+
+    void Init( const int strm_id,
+               const unsigned int _buf_scale,
+			   const unsigned int buf_size,
+			   const unsigned int _zero_stuffing,
+			   const bool bufs_in_first, 
+			   const bool always_bufs
+		  );
+
+	unsigned int BufferSizeCode();
+	inline unsigned int BufferSize() { return buffer_size; }
+	inline unsigned int BufferScale() { return buffer_scale; }
+
+	
+	inline void SetMaxPacketData( unsigned int max )
+		{
+			max_packet_data = max;
+		}
+	inline void SetMinPacketData( unsigned int min )
+		{
+			min_packet_data = min;
+		}
+	inline unsigned int MaxPacketData() { return max_packet_data; }
+	inline unsigned int MinPacketData() { return min_packet_data; }
+    inline bool NewAUNextSector() { return new_au_next_sec; }
+
+	//
+	//  Read the next packet payload (sub-stream headers plus
+	//  parsed and spliced stream data) for a packet with the
+	//  specified payload capacity.  Update the AU info.
+	//
+
+	virtual unsigned int ReadPacketPayload(uint8_t *dst, unsigned int to_read) = 0;
+
+    //
+    // Return the size of the substream headers...
+    //
+    virtual unsigned int StreamHeaderSize() { return 0; }
+
+public:  // TODO should go protected once encapsulation complete
+	int        stream_id;
+	unsigned int    buffer_scale;
+	unsigned int 	buffer_size;
+	DecodeBufModel  bufmodel;
+	unsigned int 	max_packet_data;
+	unsigned int	min_packet_data;
+	unsigned int    zero_stuffing;
+	unsigned int    nsec;
+    unsigned int    min_pes_header_len;
+	bool buffers_in_header;
+	bool always_buffers_in_header;
+	bool new_au_next_sec;
+	bool init;
+};
+
+class DummyMuxStream : public MuxStream
+{
+public:
+    DummyMuxStream( const int strm_id,
+                    const unsigned int buf_scale, 
+                    unsigned int buf_size )
+        {
+            stream_id = strm_id;
+            buffer_scale = buf_scale;
+            buffer_size = buf_size;
+        }
+
+    unsigned int ReadPacketPayload(uint8_t *dst, unsigned int to_read)
+        {
+            abort();
+            return 0;
+        }
+};
+
+
+class ElementaryStream : public InputStream,
+						 public MuxStream
+{
+public:
+	enum stream_kind { audio, video, dummy };
+	ElementaryStream( IBitStream &amp;ibs,
+                      Multiplexor &amp;into, 
+					  stream_kind kind
+					  );
+    virtual ~ElementaryStream () { }
+	virtual void Close() = 0;
+
+	bool NextAU();
+	AUnit *Lookahead( unsigned int n = 0);
+	unsigned int BytesToMuxAUEnd(unsigned int sector_transport_size);
+	bool MuxCompleted();
+	virtual bool MuxPossible(clockticks currentSCR );
+	void DemuxedTo( clockticks SCR );
+	void SetTSOffset( clockticks baseTS );
+	void AllDemuxed();
+	inline stream_kind Kind() { return kind; }
+    inline unsigned int BufferMin() { return buffer_min; }
+    inline unsigned int BufferMax() { return buffer_max; }
+    inline clockticks BaseDTS() { return au-&gt;DTS; };
+    inline clockticks BasePTS() { return au-&gt;PTS; };
+
+    inline int        DecodeOrder() { return au-&gt;dorder; }
+
+    inline clockticks RequiredDTS( const AUnit *unit )  
+        { return unit-&gt;DTS + timestamp_delay; };
+    inline clockticks RequiredPTS( const AUnit *unit ) 
+        { return unit-&gt;PTS + timestamp_delay; };
+    inline clockticks RequiredDTS()  
+        { return RequiredDTS(au); };
+    inline clockticks RequiredPTS() 
+        { return  RequiredPTS(au); };
+    inline clockticks NextRequiredDTS()
+        { 
+            AUnit *next = Lookahead();
+            if( next != 0 )
+                return RequiredDTS(next); 
+            else
+                return 0;
+        };
+    inline clockticks NextRequiredPTS()
+        { 
+            AUnit *next = Lookahead();
+            if( next != 0 )
+                return RequiredPTS(next); 
+            else
+                return 0;
+        };
+
+    void UpdateBufferMinMax();
+
+	void SetSyncOffset( clockticks timestamp_delay );
+
+	void BufferAndOutputSector();
+ 
+	inline bool BuffersInHeader() { return buffers_in_header; }
+	virtual unsigned int NominalBitRate() = 0;
+	virtual bool RunOutComplete() = 0;
+
+
+    /******************************************************************
+     *  Reads the stream data from actual input stream, updates decode
+     *  buffer model and current access unit information from the
+     *  look-ahead scanning buffer to account for bytes_muxed bytes being
+     *  muxed out.  
+     * TODO: No longer needs to be virtual
+     *
+     ******************************************************************/
+	virtual unsigned int ReadPacketPayload(uint8_t *dst, unsigned int to_read);
+
+    /********************************************************************
+     * Update stream-specific mux state information to reflect muxing of
+     * current AU.  first_in_sector is set true if AU is first muxed into
+     * the current sector.
+     *
+     *******************************************************************/
+
+    virtual void AUMuxed( bool first_in_sector ) {}
+
+    /**************************************************************
+     * The size of the stream-specific  sub-header (if any)
+     *************************************************************/
+    virtual unsigned int StreamHeaderSize() { return 0; }
+    
+    /*****************************************************************
+     * Reads/generates the stream-specific sub-header for AUs muxed
+     * since last call AUMuxed( true );
+     ****************************************************************/
+
+    virtual void ReadStreamHeader( uint8_t *dst, unsigned int len ) {}
+
+    bitcount_t bytes_read;
+private:
+    void AUBufferLookaheadFill( unsigned int look_ahead);
+
+//protected:
+public:
+	virtual void FillAUbuffer(unsigned int frames_to_buffer) = 0;
+    virtual void OutputSector() = 0;
+	AUStream aunits;
+	void Muxed( unsigned int bytes_muxed );
+	AUnit *au;
+	clockticks timestamp_delay;
+
+	unsigned int au_unsent;
+	AUnit *OLDnext();
+	Multiplexor &muxinto;
+	stream_kind kind;
+    unsigned int buffer_min;
+    unsigned int buffer_max;
+    int FRAME_CHUNK;
+									
+};
+
+
+
+#endif // __INPUTSTRM_H__
+
+
+/* 
+ * Local variables:
+ *  c-file-style: &quot;stroustrup&quot;
+ *  tab-width: 4
+ *  indent-tabs-mode: nil
+ * End:
+ */

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/interact.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/interact.cpp	2009-09-04 15:59:41 UTC (rev 5319)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/interact.cpp	2009-09-05 08:19:09 UTC (rev 5320)
@@ -0,0 +1,293 @@
+
+/*
+ *  interact.cc:  Simple command-line front-end
+ *
+ *  Copyright (C) 2001 Andrew Stevens &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">andrew.stevens at philips.com</A>&gt;
+ *
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of version 2 of the GNU General Public License
+ *  as published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+
+#include &lt;config.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;ctype.h&gt;
+#include &lt;unistd.h&gt;
+#include &lt;sys/stat.h&gt;
+#include &lt;mjpeg_logging.h&gt;
+#include &lt;format_codes.h&gt;
+
+#include &quot;interact.hpp&quot;
+#include &quot;videostrm.hpp&quot;
+#include &quot;audiostrm.hpp&quot;
+#ifdef ZALPHA
+#include &quot;zalphastrm.hpp&quot;
+#endif
+#include &quot;mplexconsts.hpp&quot;
+#include &quot;aunit.hpp&quot;
+
+
+static const char *KindNames[] =
+{
+    &quot;MPEG audio&quot;,
+    &quot;AC3 audio&quot;,
+    &quot;LPCM audio&quot;,
+    &quot;DTS audio&quot;,
+    &quot;MPEG video&quot;,
+    &quot;Z Alpha channel&quot;
+};
+
+const char *JobStream::NameOfKind()
+{
+    return KindNames[kind];
+}
+
+Workarounds::Workarounds() 
+{
+}
+
+MultiplexJob::MultiplexJob()
+{
+    verbose = 1;
+    data_rate = 0;  /* 3486 = 174300B/sec would be right for VCD */
+    video_offset = 0;
+    audio_offset = 0;
+    sector_size = 2048;
+    VBR = false;
+    mpeg = 1;
+    mux_format = MPEG_FORMAT_MPEG1;
+    multifile_segment = false;
+    always_system_headers = false;
+    packets_per_pack = 1;
+    max_timeouts = 10;
+    max_PTS = 0;
+    max_segment_size = 0; // MB, default is unlimited (suitable for DVD)
+    outfile_pattern = 0;
+    packets_per_pack = 1;
+    audio_tracks = 0;
+    video_tracks = 0;
+    lpcm_tracks = 0;
+#ifdef ZALPHA
+    z_alpha_tracks = 0;
+#endif
+
+}
+
+
+MultiplexJob::~MultiplexJob()
+{
+	std::vector&lt;JobStream *&gt;::iterator i;
+    for( i = streams.begin(); i &lt; streams.end(); ++i )
+        delete *i;
+}
+
+
+unsigned int MultiplexJob::NumberOfTracks( StreamKind kind )
+{
+    unsigned int count = 0;
+	std::vector&lt;JobStream *&gt;::iterator i;
+    for( i = streams.begin(); i &lt; streams.end(); ++i )
+        if( (*i)-&gt;kind == kind )
+            ++count;
+    return count;
+    
+}
+
+void MultiplexJob::GetInputStreams( vector&lt;JobStream *&gt; &amp;res, StreamKind kind )
+{
+    res.erase( res.begin(), res.end() );
+	std::vector&lt;JobStream *&gt;::iterator i;
+    for( i = streams.begin(); i &lt; streams.end(); ++i )
+        if( (*i)-&gt;kind == kind )
+            res.push_back( *i );
+}
+
+
+// MEANX
+static const char *kindToString(StreamKind kind)
+{
+#define KID(x)  x##_AUDIO:return #x;
+    switch(kind)
+    {
+        case KID(MPEG)
+       case  KID(AC3)
+        case KID(LPCM)
+        case KID(DTS)
+        default: 
+            printf(&quot;Kind %d\n&quot;,kind);
+            assert(0);
+    }
+  return &quot;Oops&quot;;
+}
+
+// /MEANS
+void MultiplexJob::SetupInputStreams( std::vector&lt; IBitStream *&gt; &amp;inputs )
+{
+    IBitStream *bs;
+    IBitStreamUndo undo;
+    unsigned int i;
+    bool bad_file = false;
+    
+	for( i = 0; i &lt; inputs.size(); ++i )
+    {
+        bs = inputs[i];
+        // Remember the streams initial state...
+        bs-&gt;PrepareUndo( undo );
+// MEANX : Use the info we have to be sure of the stream type
+// Else we cannot detect safly LPCM/PCM/DTS
+        switch(bs-&gt;streamDesc.kind)
+        {
+            case MPEG_AUDIO:
+            case AC3_AUDIO:
+            case LPCM_AUDIO:
+            case DTS_AUDIO:
+                mjpeg_info (&quot;File %s looks like an %s Audio stream (fq %u, channel %u).\n&quot;, bs-&gt;StreamName() , kindToString(bs-&gt;streamDesc.kind),bs-&gt;streamDesc.frequency,bs-&gt;streamDesc.channel);
+                bs-&gt;UndoChanges( undo );
+                streams.push_back( new JobStream( bs, bs-&gt;streamDesc.kind) );
+                ++audio_tracks;
+                if(bs-&gt;streamDesc.kind==LPCM_AUDIO) 
+                    lpcm_param.push_back(LpcmParams::Checked(  bs-&gt;streamDesc.frequency,                                         
+                                                   bs-&gt;streamDesc.channel,16));//++lpcm_tracks;
+                continue;
+            case MPEG_VIDEO:
+                mjpeg_info (&quot;File %s looks like an Video stream.&quot;, bs-&gt;StreamName() );
+                bs-&gt;UndoChanges( undo );
+                streams.push_back( new JobStream( bs,MPEG_VIDEO) );
+                ++video_tracks;
+                continue;
+            default: assert(0);
+            
+        }
+    }
+
+#if 0 //MEANX
+        if( LPCMStream::Probe( *bs ) )
+        {
+            mjpeg_info (&quot;File %s looks like an LPCM Audio stream.&quot;,
+                        bs-&gt;StreamName());
+            bs-&gt;UndoChanges( undo );
+            streams.push_back( new JobStream( bs,  LPCM_AUDIO) );
+            ++audio_tracks;
+            ++lpcm_tracks;
+            continue;
+        }
+
+        bs-&gt;UndoChanges( undo );
+        if( MPAStream::Probe( *bs ) )
+        {
+            mjpeg_info (&quot;File %s looks like an MPEG Audio stream.&quot;, 
+                        bs-&gt;StreamName() );
+            bs-&gt;UndoChanges( undo );
+            streams.push_back( new JobStream( bs, MPEG_AUDIO) );
+            ++audio_tracks;
+            continue;
+        }
+
+        bs-&gt;UndoChanges( undo );
+        if( AC3Stream::Probe( *bs ) )
+        {
+            mjpeg_info (&quot;File %s looks like an AC3 Audio stream.&quot;,
+                        bs-&gt;StreamName());
+            bs-&gt;UndoChanges( undo );
+            streams.push_back( new JobStream( bs, AC3_AUDIO) );
+            ++audio_tracks;
+            continue;
+        }
+
+        bs-&gt;UndoChanges( undo );
+        if( DTSStream::Probe( *bs ) )
+        {
+            mjpeg_info (&quot;File %s looks like a dts Audio stream.&quot;,
+                        bs-&gt;StreamName());
+            bs-&gt;UndoChanges( undo);
+            streams.push_back( new JobStream( bs, DTS_AUDIO) );
+            ++audio_tracks;
+            continue;
+        }
+
+        bs-&gt;UndoChanges( undo );
+        if( VideoStream::Probe( *bs ) )
+        {
+            mjpeg_info (&quot;File %s looks like an MPEG Video stream.&quot;,
+                        bs-&gt;StreamName());
+            bs-&gt;UndoChanges( undo );
+            streams.push_back( new JobStream( bs, MPEG_VIDEO) );
+            ++video_tracks;
+            continue;
+        }
+
+        bs-&gt;UndoChanges( undo );
+#ifdef ZALPHA
+        if( ZAlphaStream::Probe( *bs ) )
+        {
+            mjpeg_info (&quot;File %s looks like an Z/Alpha Video stream.&quot;,
+                        bs-&gt;StreamName());
+            bs-&gt;UndoChanges( undo );
+            streams.push_back( new JobStream( bs, Z_ALPHA) );
+            ++video_tracks;
+            ++z_alpha_tracks;
+            continue;
+        }
+#endif
+        bad_file = true;
+        mjpeg_error (&quot;File %s unrecogniseable!&quot;, bs-&gt;StreamName());
+        delete bs;
+    }
+#endif // MEANX IF 0 
+    if( bad_file )
+    {
+        mjpeg_error_exit1( &quot;Unrecogniseable file(s)... exiting.&quot;);
+    }
+
+	//
+	// Where no parameters for streams have been specified
+	// simply set the default values (these will depend on the format
+	// we're muxing of course...)
+	//
+
+	for( i = video_param.size(); i &lt; video_tracks; ++i )
+	{
+		video_param.push_back(VideoParams::Default( mux_format ));
+	}
+	for( i = lpcm_param.size(); i &lt; lpcm_tracks; ++i )
+	{
+		lpcm_param.push_back(LpcmParams::Default(mux_format));
+	}
+
+	//
+	// Set standard values if the selected profile implies this...
+	//
+	for( i = 0; i &lt;video_tracks; ++i )
+	{
+		if( video_param[i]-&gt;Force(mux_format) )
+		{
+			mjpeg_info( &quot;Video stream %d: profile %d selected - ignoring non-standard options!&quot;, i, mux_format );
+		}
+	}
+
+	mjpeg_info( &quot;Found %d audio streams and %d video streams&quot;,
+                audio_tracks,
+				video_tracks
+        );
+        
+}
+
+
+/* 
+ * Local variables:
+ *  c-file-style: &quot;stroustrup&quot;
+ *  tab-width: 4
+ *  indent-tabs-mode: nil
+ * End:
+ */

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/interact.hpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/interact.hpp	2009-09-04 15:59:41 UTC (rev 5319)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/interact.hpp	2009-09-05 08:19:09 UTC (rev 5320)
@@ -0,0 +1,160 @@
+
+/*
+ *  interact.hpp:  Simple command-line front-end
+ *
+ *  Copyright (C) 2001 Andrew Stevens &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">andrew.stevens at philips.com</A>&gt;
+ *
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of version 2 of the GNU General Public License
+ *  as published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+#ifndef __INTERACT_HH__
+#define __INTERACT_HH__
+
+#ifndef _WIN32
+#include &lt;unistd.h&gt;
+#endif
+#include &lt;vector&gt;
+#include &quot;mjpeg_types.h&quot;
+#include &quot;stream_params.hpp&quot;
+#include &quot;systems.hpp&quot;
+
+// MEANX
+#include &quot;streamType.h&quot;
+// /MEANX
+class IBitStream;
+
+using std::vector;
+
+/*************************************************************************
+ *
+ * The Multiplexor job Parameters:
+ * The various parametes of a multiplexing job: muxing options
+ *
+ *************************************************************************/
+
+struct Workarounds
+{
+  Workarounds();
+};
+
+class MultiplexParams
+{
+public:
+  unsigned int data_rate;
+  unsigned int packets_per_pack;
+  int video_offset;             // A/V sync offset. Always one 0 and the
+                                // other positive. Specified in 
+  int audio_offset;             // MPEG-2 CLOCKS: 1/(90000*300)-th sec
+  unsigned int sector_size;
+  bool VBR;
+  int mpeg;
+  int mux_format;
+  bool multifile_segment;
+  bool always_system_headers;
+  unsigned int max_PTS;
+  bool stills;
+  int verbose;
+  int max_timeouts;
+  char *outfile_pattern;
+  int max_segment_size;
+  int min_pes_header_len;
+  Workarounds workarounds;      // Special work-around flags that
+                                // constrain the syntax to suit
+                                // the foibles of particular MPEG
+                                // parsers that are (guessed) to be
+                                // actually slightly broken.  Always
+                                // off by default...
+
+};
+
+/***********************************************************************
+ *
+ * Multiplexor job - paramters plus the streams to mux.
+ *
+ *
+ **********************************************************************/
+// MEANX MOVED TO STREAMTYPE.H
+#if 0
+enum StreamKind
+  {
+    MPEG_AUDIO,
+    AC3_AUDIO,
+    LPCM_AUDIO,
+    DTS_AUDIO,
+    MPEG_VIDEO
+#ifdef ZALPHA
+    ,
+    Z_ALPHA
+#endif
+  };
+#endif
+// MEANX MOVED TO STREAMTYPE.H
+
+class JobStream
+{
+public:
+
+  JobStream( IBitStream *_bs,  StreamKind _kind ) :
+    bs(_bs),
+    kind(_kind)
+  {
+  }
+
+  const char *NameOfKind();
+  IBitStream *bs;
+  StreamKind kind;
+};
+
+class MultiplexJob : public MultiplexParams
+{
+public:
+  MultiplexJob();
+  virtual ~MultiplexJob();
+  unsigned int NumberOfTracks( StreamKind kind );
+  void GetInputStreams( vector&lt;JobStream *&gt; &amp;streams, StreamKind kind );
+
+  void SetupInputStreams( vector&lt;IBitStream *&gt; &amp;inputs );
+protected:
+
+public:  
+  vector&lt;JobStream *&gt; streams;
+  vector&lt;LpcmParams *&gt; lpcm_param;
+  vector&lt;VideoParams *&gt; video_param;
+  unsigned int audio_tracks;
+  unsigned int video_tracks;
+  unsigned int lpcm_tracks;
+#ifdef ZALPHA
+  unsigned int z_alpha_tracks;
+#endif
+};
+
+
+/*************************************************************************
+    Program ID
+*************************************************************************/
+ 
+#define MPLEX_VER    &quot;2.2.4&quot;
+#define MPLEX_DATE   &quot;$Date$&quot;
+
+#endif // __INTERACT_H__
+
+
+/* 
+ * Local variables:
+ *  c-file-style: &quot;gnu&quot;
+ *  tab-width: 8
+ *  indent-tabs-mode: nil
+ * End:
+ */

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/lpcmstrm_in.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/lpcmstrm_in.cpp	2009-09-04 15:59:41 UTC (rev 5319)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/lpcmstrm_in.cpp	2009-09-05 08:19:09 UTC (rev 5320)
@@ -0,0 +1,323 @@
+/*
+ *  lpcmstrm_in.c: LPCM Audio strem class members handling scanning and
+ *  buffering raw input stream.
+ *
+ * Takes a *RAW* LPCM stream as input.
+ * This is *signed* linear 16, 20, or 24-bit sample PCM.
+ * Samples are stored msb first.
+ * How  20-bit samples are allocated to bytes? I just don't know, but
+ * believe 4 bits are appended after the lsb (samples are msb-byte aligned).
+ *
+ *  Copyright (C) 2001 Andrew Stevens &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">andrew.stevens at philips.com</A>&gt;
+ *  Copyright (C) 2000,2001 Brent Byeler for original header-structure
+ *                          parsing code.
+ *
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of version 2 of the GNU General Public License
+ *  as published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+#include &lt;config.h&gt;
+#include &lt;math.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;string.h&gt;
+
+#include &quot;audiostrm.hpp&quot;
+#include &quot;interact.hpp&quot;
+#include &quot;multiplexor.hpp&quot;
+
+
+const unsigned int LPCMStream::default_buffer_size = 58*1024;
+const unsigned int LPCMStream::ticks_per_frame_90kHz = 150;
+
+
+LPCMStream::LPCMStream(IBitStream &amp;ibs, LpcmParams *parms, Multiplexor &amp;into) : 
+	AudioStream( ibs, into ),
+    parms(parms)
+{
+	num_frames = 0;
+}
+
+
+
+
+bool LPCMStream::Probe(IBitStream &amp;bs )
+{
+    const char *last_dot = strrchr( bs.StreamName(), '.' );
+    return 
+        last_dot != NULL 
+        &amp;&amp; strcmp( last_dot+1, &quot;lpcm&quot;) == 0;
+
+}
+
+
+/*************************************************************************
+ *
+ * Reads initial stream parameters and displays feedback banner to users
+ *
+ *************************************************************************/
+
+
+void LPCMStream::Init ( const int _stream_num)
+
+{
+    stream_num = _stream_num;
+    header_skip = 0;
+	MuxStream::Init( PRIVATE_STR_1, 
+					 1,  // Buffer scale
+					 default_buffer_size,
+					 false,
+					 muxinto.buffers_in_audio,
+					 muxinto.always_buffers_in_audio
+		);
+
+    // This seems to be necessary not only for some software players but
+    // for some standalone players too.   Yuck... shades of the VCD audio
+    // sectors.
+    min_pes_header_len = 10;
+    mjpeg_info (&quot;Scanning for header info: LPCM Audio stream %02x (%s)&quot;,
+                stream_num,
+                bs.StreamName()
+                );
+
+    
+	AU_start = bs.bitcount();
+
+    // This is a dummy debug version that simply assumes 48kHz
+    // two channel 16 bit sample LPCM
+    
+    samples_per_second = parms-&gt;SamplesPerSec();
+    channels = parms-&gt;Channels();
+    bits_per_sample = parms-&gt;BitsPerSample();
+    bytes_per_frame = 
+        samples_per_second * channels * bits_per_sample / 8
+        * ticks_per_frame_90kHz
+        / 90000;
+    frame_index = 0;
+    dynamic_range_code = 0x80;
+
+    /* Presentation/decoding time-stamping  */
+    access_unit.start = AU_start;
+    access_unit.length = bytes_per_frame;
+    access_unit.PTS = static_cast&lt;clockticks&gt;(decoding_order) * 
+        (CLOCKS_per_90Kth_sec * ticks_per_frame_90kHz);
+    access_unit.DTS = access_unit.PTS;
+    access_unit.dorder = decoding_order;
+    decoding_order++;
+    aunits.Append( access_unit );
+    
+	OutputHdrInfo();
+}
+
+unsigned int LPCMStream::NominalBitRate()
+{ 
+	return samples_per_second * channels * bits_per_sample;
+}
+
+
+
+void LPCMStream::FillAUbuffer(unsigned int frames_to_buffer )
+{
+	last_buffered_AU += frames_to_buffer;
+	mjpeg_debug( &quot;Scanning %d MPEG LPCM audio frames to frame %d&quot;, 
+				 frames_to_buffer, last_buffered_AU );
+
+	while ( !bs.eos() 
+            &amp;&amp; decoding_order &lt; last_buffered_AU 
+            &amp;&amp; !muxinto.AfterMaxPTS(access_unit.PTS) )
+	{
+		int skip=access_unit.length; 
+        bs.SeekFwdBits( skip );
+		prev_offset = AU_start;
+		AU_start = bs.bitcount();
+        if( AU_start - prev_offset != access_unit.length*8 )
+        {
+            mjpeg_warn(&quot;Discarding incomplete final frame LPCM  stream %d&quot;,
+                       stream_num);
+            aunits.DropLast();
+            --decoding_order;
+            break;
+        }
+
+        // Here we would check for header data but LPCM has no headers...
+        if( bs.eos()   )
+            break;
+
+		access_unit.start = AU_start;
+		access_unit.length = bytes_per_frame;
+		access_unit.PTS = static_cast&lt;clockticks&gt;(decoding_order) * 
+            (CLOCKS_per_90Kth_sec * ticks_per_frame_90kHz);
+		access_unit.DTS = access_unit.PTS;
+		access_unit.dorder = decoding_order;
+		decoding_order++;
+		aunits.Append( access_unit );
+		num_frames++;
+		
+		num_syncword++;
+
+		if (num_syncword &gt;= old_frames+10 )
+		{
+			mjpeg_debug (&quot;Got %d frame headers.&quot;, num_syncword);
+			old_frames=num_syncword;
+		}
+        mjpeg_debug( &quot;Got frame %d\n&quot;, decoding_order );
+
+    }
+	last_buffered_AU = decoding_order;
+	eoscan =  bs.eos() || muxinto.AfterMaxPTS(access_unit.PTS);
+}
+
+
+
+void LPCMStream::Close()
+{
+    stream_length = AU_start / 8;
+	mjpeg_info (&quot;AUDIO_STATISTICS: %02x&quot;, stream_id); 
+    mjpeg_info (&quot;Audio stream length %lld bytes.&quot;, stream_length);
+    mjpeg_info   (&quot;Frames         : %8u &quot;,  num_frames);
+}
+
+/*************************************************************************
+	OutputAudioInfo
+	gibt gesammelte Informationen zu den Audio Access Units aus.
+
+	Prints information on audio access units
+*************************************************************************/
+
+void LPCMStream::OutputHdrInfo ()
+{
+	mjpeg_info(&quot;LPCM AUDIO STREAM:&quot;);
+
+    mjpeg_info (&quot;Bit rate       : %8u bytes/sec (%u) bit/sec)&quot;,
+                NominalBitRate()/8, NominalBitRate() );
+    mjpeg_info (&quot;Channels       :     %d&quot;, channels);
+    mjpeg_info (&quot;Bits per sample:     %d&quot;, bits_per_sample );
+    mjpeg_info (&quot;Frequency      :     %d Hz&quot;, samples_per_second );
+
+}
+
+
+unsigned int 
+LPCMStream::ReadPacketPayload(uint8_t *dst, unsigned int to_read)
+{
+    unsigned int header_size = LPCMStream::StreamHeaderSize();
+    bitcount_t read_start = bs.GetBytePos();
+    unsigned int bytes_read = bs.GetBytes( dst+header_size, 
+                                           to_read-header_size );
+    bs.Flush( read_start );
+    
+	clockticks   decode_time;
+    bool starting_frame_found = false;
+    uint8_t starting_frame_index = 0;
+
+    int starting_frame_offset = 
+        (new_au_next_sec || au_unsent &gt; bytes_read )
+        ? 0 
+        : au_unsent;
+
+    unsigned int frames = 0;
+    unsigned int bytes_muxed = bytes_read;
+  
+	if (bytes_muxed == 0 || MuxCompleted() )
+    {
+		goto completion;
+    }
+
+
+	/* Work through what's left of the current frames and the
+	   following frames's updating the info until we reach a point where
+	   an frame had to be split between packets. 
+
+	   The DTS/PTS field for the packet in this case would have been
+	   given the that for the first AU to start in the packet.
+
+	*/
+
+	decode_time = RequiredDTS();
+	while (au_unsent &lt; bytes_muxed)
+	{	  
+        assert( bytes_muxed &gt; 1 );
+		bufmodel.Queued(au_unsent, decode_time);
+		bytes_muxed -= au_unsent;
+        if( new_au_next_sec )
+        {
+            ++frames;
+            if( ! starting_frame_found )
+            {
+                starting_frame_index = static_cast&lt;uint8_t&gt;(au-&gt;dorder % 20);
+                starting_frame_found = true;
+            }
+        }
+		if( !NextAU() )
+        {
+            goto completion;
+        }
+		new_au_next_sec = true;
+		decode_time = RequiredDTS();
+	};
+
+	// We've now reached a point where the current AU overran or
+	// fitted exactly.  We need to distinguish the latter case so we
+	// can record whether the next packet starts with the tail end of
+	// // an already started frame or a new one. We need this info to
+	// decide what PTS/DTS info to write at the start of the next
+	// packet.
+	
+	if (au_unsent &gt; bytes_muxed)
+	{
+        if( new_au_next_sec )
+            ++frames;
+		bufmodel.Queued( bytes_muxed, decode_time);
+		au_unsent -= bytes_muxed;
+		new_au_next_sec = false;
+	} 
+	else //  if (au_unsent == bytes_muxed)
+	{
+		bufmodel.Queued(bytes_muxed, decode_time);
+        if( new_au_next_sec )
+            ++frames;
+        new_au_next_sec = NextAU();
+	}	   
+completion:
+    // Generate the LPCM header...
+    // Note the index counts from the low byte of the offset so
+    // the smallest value is 1!
+    dst[0] = LPCM_SUB_STR_0 + stream_num;
+    dst[1] = frames;
+    dst[2] = (starting_frame_offset+4)&gt;&gt;8;
+    dst[3] = (starting_frame_offset+4)&amp;0xff;
+    unsigned int bps_code;
+    switch( bits_per_sample )
+    {
+    case 16 : bps_code = 0; break;
+    case 20 : bps_code = 1; break;
+    case 24 : bps_code = 2; break;
+    default : bps_code = 3; break;
+    }
+    dst[4] = starting_frame_index;
+    unsigned int bsf_code = (samples_per_second == 48000) ? 0 : 1;
+    unsigned int channels_code = channels - 1;
+    dst[5] = (bps_code &lt;&lt; 6) | (bsf_code &lt;&lt; 4) | channels_code;
+    dst[6] = dynamic_range_code;
+	return bytes_read+header_size;
+}
+
+
+
+/* 
+ * Local variables:
+ *  c-file-style: &quot;stroustrup&quot;
+ *  tab-width: 4
+ *  indent-tabs-mode: nil
+ * End:
+ */

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/mjpeg_logging.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/mjpeg_logging.c	2009-09-04 15:59:41 UTC (rev 5319)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/mjpeg_logging.c	2009-09-05 08:19:09 UTC (rev 5320)
@@ -0,0 +1,229 @@
+/*
+    $Id: mjpeg_logging.c,v 1.14 2005/05/18 17:21:47 sms00 Exp $
+
+    Copyright (C) 2000 Herbert Valerio Riedel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">hvr at gnu.org</A>&gt;
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
+
+
+#ifdef HAVE_CONFIG_H
+# include &lt;config.h&gt;
+#endif
+
+#include &lt;stdlib.h&gt;
+#include &lt;stdarg.h&gt;
+#include &lt;stdio.h&gt;
+#include &lt;assert.h&gt;
+#include &lt;string.h&gt;
+
+#include &quot;mjpeg_logging.h&quot;
+
+#define MAX_DEFAULT_ID_SIZE 16
+#define DEFAULT_DEFAULT_ID &quot;???&quot;
+
+#ifdef HAVE___PROGNAME
+extern const char *__progname;
+#endif
+
+static log_level_t mjpeg_log_verbosity = LOG_NONE;
+static char default_handler_id[MAX_DEFAULT_ID_SIZE];
+static char default_handler_id_is_set = 0;
+
+static int default_mjpeg_log_filter( log_level_t level )
+{
+  int verb_from_env;
+  if( mjpeg_log_verbosity == 0 )
+    {
+      char *mjpeg_verb_env = getenv(&quot;MJPEG_VERBOSITY&quot;);
+      if( mjpeg_verb_env != NULL )
+        {
+          verb_from_env = LOG_WARN-atoi(mjpeg_verb_env);
+          if( verb_from_env &gt;= LOG_DEBUG &amp;&amp; verb_from_env &lt;= LOG_ERROR )
+            mjpeg_log_verbosity = (log_level_t)verb_from_env;
+        }
+    }
+  return (level &lt; LOG_WARN &amp;&amp; level &lt; mjpeg_log_verbosity);
+}
+
+static mjpeg_log_filter_t _filter = default_mjpeg_log_filter;
+
+static void
+default_mjpeg_log_handler(log_level_t level, const char message[])
+{
+  const char *ids;
+
+  if( (*_filter)( level ) )
+    return;
+  if (default_handler_id_is_set) {
+    ids = default_handler_id;
+  } else {
+#ifdef HAVE___PROGNAME
+    ids = __progname;
+#else
+    ids = DEFAULT_DEFAULT_ID;
+#endif
+  }
+  switch(level) {
+  case LOG_ERROR:
+    fprintf(stderr, &quot;**ERROR: [%s] %s\n&quot;, ids, message);
+    break;
+  case LOG_DEBUG:
+    //fprintf(stderr, &quot;--DEBUG: [%s] %s\n&quot;, ids, message);
+    break;
+  case LOG_WARN:
+    fprintf(stderr, &quot;++ WARN: [%s] %s\n&quot;, ids, message);
+    break;
+  case LOG_INFO:
+    fprintf(stderr, &quot;   INFO: [%s] %s\n&quot;, ids, message);
+    break;
+  default:
+    assert(0);
+  }
+}
+
+static mjpeg_log_handler_t _handler = default_mjpeg_log_handler;
+
+
+mjpeg_log_handler_t
+mjpeg_log_set_handler(mjpeg_log_handler_t new_handler)
+{
+  mjpeg_log_handler_t old_handler = _handler;
+
+  _handler = new_handler;
+
+  return old_handler;
+}
+
+/***************
+ *
+ * Set default log handlers degree of verboseity.
+ * 0 = quiet, 1 = info, 2 = debug
+ *
+ *************/
+
+int
+mjpeg_default_handler_verbosity(int verbosity)
+{
+  int prev_verb = mjpeg_log_verbosity;
+  mjpeg_log_verbosity = (log_level_t)(LOG_WARN - verbosity);
+  return prev_verb;
+}
+
+/*
+ * Set identifier string used by default handler
+ *
+ */
+int
+mjpeg_default_handler_identifier(const char *new_id)
+{
+  const char *s;
+  if (new_id == NULL) {
+    default_handler_id_is_set = 0;
+    return 0;
+  }
+  /* find basename of new_id (remove any directory prefix) */
+  if ((s = strrchr(new_id, '/')) == NULL)
+    s = new_id;
+  else
+    s = s + 1;
+  strncpy(default_handler_id, s, MAX_DEFAULT_ID_SIZE);
+  default_handler_id[MAX_DEFAULT_ID_SIZE-1] = '\0';
+  default_handler_id_is_set = 1;
+  return 0;
+}
+
+
+static void
+mjpeg_logv(log_level_t level, const char format[], va_list args)
+{
+  char buf[1024] = { 0, };
+
+  /* TODO: Original had a re-entrancy error trap to assist bug
+     finding.  To make this work with multi-threaded applications a
+     lock is needed hence delete.
+  */
+
+  
+  vsnprintf(buf, sizeof(buf)-1, format, args);
+
+  _handler(level, buf);
+}
+
+void
+mjpeg_log(log_level_t level, const char format[], ...)
+{
+  va_list args;
+  va_start (args, format);
+  mjpeg_logv(level, format, args);
+  va_end (args);
+}
+
+void
+mjpeg_debug(const char format[], ...)
+{
+  va_list args;
+  va_start (args, format);
+  mjpeg_logv(LOG_DEBUG, format, args);
+  va_end (args);
+}
+
+void
+mjpeg_info(const char format[], ...)
+{
+#if 0
+  va_list args;
+  va_start (args, format);
+  mjpeg_logv(LOG_INFO, format, args);
+  va_end (args);
+#endif
+}
+
+void
+mjpeg_warn(const char format[], ...)
+{
+  va_list args;
+  va_start (args, format);
+  mjpeg_logv(LOG_WARN, format, args);
+  va_end (args);
+}
+
+void
+mjpeg_error(const char format[], ...)
+{
+  va_list args;
+  va_start (args, format);
+  mjpeg_logv(LOG_ERROR, format, args);
+  va_end (args);
+}
+
+void
+mjpeg_error_exit1(const char format[], ...)
+{
+  va_list args;
+  va_start( args, format );
+  mjpeg_logv( LOG_ERROR, format, args);
+  va_end(args);           
+  exit(EXIT_FAILURE);
+}
+
+
+/* 
+ * Local variables:
+ *  c-file-style: &quot;gnu&quot;
+ *  tab-width: 8
+ *  indent-tabs-mode: nil
+ * End:
+ */

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/mjpeg_logging.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/mjpeg_logging.h	2009-09-04 15:59:41 UTC (rev 5319)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/mjpeg_logging.h	2009-09-05 08:19:09 UTC (rev 5320)
@@ -0,0 +1,80 @@
+/*
+    $Id: mjpeg_logging.h,v 1.8 2004/09/01 02:55:30 sms00 Exp $
+
+    Copyright (C) 2000 Herbert Valerio Riedel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">hvr at gnu.org</A>&gt;
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
+
+#ifndef __MJPEG_LOGGING_H__
+#define __MJPEG_LOGGING_H__
+
+#include &lt;mjpeg_types.h&gt;
+
+typedef enum {
+  LOG_NONE = 0,
+  LOG_DEBUG,
+  LOG_INFO,
+  LOG_WARN,
+  LOG_ERROR
+} log_level_t;
+
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+void
+mjpeg_log(log_level_t level, const char format[], ...) GNUC_PRINTF(2, 3);
+
+typedef int(*mjpeg_log_filter_t)(log_level_t level);
+    
+typedef void(*mjpeg_log_handler_t)(log_level_t level, const char message[]);
+
+mjpeg_log_handler_t
+mjpeg_log_set_handler(mjpeg_log_handler_t new_handler);
+
+int
+mjpeg_default_handler_identifier(const char *new_id);
+
+int
+mjpeg_default_handler_verbosity(int verbosity);
+
+void
+mjpeg_debug(const char format[], ...) GNUC_PRINTF(1,2);
+
+void
+mjpeg_info(const char format[], ...) GNUC_PRINTF(1,2);
+
+void
+mjpeg_warn(const char format[], ...) GNUC_PRINTF(1,2);
+
+void
+mjpeg_error(const char format[], ...) GNUC_PRINTF(1,2);
+
+void
+mjpeg_error_exit1(const char format[], ...) GNUC_PRINTF(1,2);
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* __MJPEG_LOGGING_H__ */
+
+
+/* 
+ * Local variables:
+ *  c-file-style: &quot;gnu&quot;
+ *  tab-width: 8
+ *  indent-tabs-mode: nil
+ * End:
+ */

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/mjpeg_types.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/mjpeg_types.h	2009-09-04 15:59:41 UTC (rev 5319)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/mjpeg_types.h	2009-09-05 08:19:09 UTC (rev 5320)
@@ -0,0 +1,42 @@
+/*
+    $Id: mjpeg_types.h,v 1.14 2005/05/18 17:21:47 sms00 Exp $
+
+    Copyright (C) 2000 Herbert Valerio Riedel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">hvr at gnu.org</A>&gt;
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
+
+#ifndef __MJPEG_TYPES_H__
+#define __MJPEG_TYPES_H__
+
+#include &quot;ADM_default.h&quot;
+
+#if __GNUC__ &gt; 2 || (__GNUC__ == 2 &amp;&amp; __GNUC_MINOR__ &gt; 4)
+#define GNUC_PRINTF( format_idx, arg_idx )    \
+  __attribute__((format (printf, format_idx, arg_idx)))
+#else   /* !__GNUC__ */
+#define GNUC_PRINTF( format_idx, arg_idx )
+#endif  /* !__GNUC__ */
+
+#endif /* __MJPEG_TYPES_H__ */
+
+
+/* 
+ * Local variables:
+ *  c-file-style: &quot;gnu&quot;
+ *  tab-width: 8
+ *  indent-tabs-mode: nil
+ * End:
+ */

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/mpastrm_in.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/mpastrm_in.cpp	2009-09-04 15:59:41 UTC (rev 5319)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/mpastrm_in.cpp	2009-09-05 08:19:09 UTC (rev 5320)
@@ -0,0 +1,335 @@
+/*
+ *  audiostrm_in.c: MPEG Audio strem class members handling scanning
+ *  and buffering raw input stream.
+ *
+ *  Copyright (C) 2001 Andrew Stevens &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">andrew.stevens at philips.com</A>&gt;
+ *
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of version 2 of the GNU General Public License
+ *  as published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+#include &lt;config.h&gt;
+#include &lt;math.h&gt;
+#include &lt;stdlib.h&gt;
+
+#include &quot;audiostrm.hpp&quot;
+#include &quot;interact.hpp&quot;
+#include &quot;multiplexor.hpp&quot;
+
+
+static const char *mpa_audio_version[4] =
+{
+	&quot;2.5&quot;,
+	&quot;2.0&quot;,
+	&quot;reserved&quot;,
+	&quot;1.0&quot;
+};
+
+static const unsigned int mpa_bitrates_kbps [4][3][16] =
+{
+	{ /* MPEG audio V2.5 */
+		{0,32,48,56,64,80,96,112,128,144,160,176,192,224,256,0},
+		{0,8,16,24,32,40,48,56,64,80,96,112,128,144,160,0},
+		{0,8,16,24,32,40,48,56,64,80,96,112,128,144,160,0}
+	},
+	{ /*RESERVED*/
+		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
+		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
+		{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}
+	},
+	{ /* MPEG audio V2 */
+		{0,32,48,56,64,80,96,112,128,144,160,176,192,224,256,0},
+		{0,8,16,24,32,40,48,56,64,80,96,112,128,144,160,0},
+		{0,8,16,24,32,40,48,56,64,80,96,112,128,144,160,0}
+	},
+	{ /* MPEG audio V1 */
+		{0,32,64,96,128,160,192,224,256,288,320,352,384,416,448,0},
+		{0,32,48,56,64,80,96,112,128,160,192,224,256,320,384,0},
+		{0,32,40,48,56,64,80,96,112,128,160,192,224,256,320,0}
+	}
+
+};
+
+
+static const int mpa_freq_table [4][4] = 
+{
+	/* MPEG audio V2.5 */
+	{11025,12000,8000,0},
+	/* RESERVED */
+	{ 0, 0, 0, 0 }, 
+	/* MPEG audio V2 */
+	{22050,24000, 16000,0},
+	/* MPEG audio V1 */
+	{44100, 48000, 32000, 0}
+};
+
+static const char mpa_stereo_mode [4][15] =
+{ &quot;stereo&quot;, &quot;joint stereo&quot;, &quot;dual channel&quot;, &quot;single channel&quot; };
+static const char mpa_copyright_status [2][20] =
+{ &quot;no copyright&quot;,&quot;copyright protected&quot; };
+static const char mpa_original_bit [2][10] =
+{ &quot;copy&quot;,&quot;original&quot; };
+static const char mpa_emphasis_mode [4][20] =
+{ &quot;none&quot;, &quot;50/15 microseconds&quot;, &quot;reserved&quot;, &quot;CCITT J.17&quot; };
+static const unsigned int mpa_slots [4] = {12, 144, 144, 0};
+static const unsigned int mpa_samples [4] = {384, 1152, 1152, 0};
+
+
+
+MPAStream::MPAStream(IBitStream &amp;ibs, Multiplexor &amp;into) : 
+	AudioStream( ibs, into )
+{
+	for( int i = 0; i &lt;2 ; ++i )
+		num_frames[i] = size_frames[i] = 0;
+}
+
+bool MPAStream::Probe(IBitStream &amp;bs )
+{
+    return bs.GetBits(11) == AUDIO_SYNCWORD;
+}
+
+
+/*************************************************************************
+ *
+ * Reads initial stream parameters and displays feedback banner to users
+ *
+ *************************************************************************/
+
+
+void MPAStream::Init ( const int stream_num )
+
+{
+	int padding_bit;
+
+	MuxStream::Init( AUDIO_STR_0 + stream_num, 
+					 0,  // Buffer scale
+					 muxinto.audio_buffer_size,
+					 muxinto.vcd_zero_stuffing,
+					 muxinto.buffers_in_audio,
+					 muxinto.always_buffers_in_audio
+		);
+    mjpeg_info (&quot;Scanning for header info: Audio stream %02x (%s)&quot;,
+                AUDIO_STR_0 + stream_num,
+                bs.StreamName()
+                );
+
+	/* A.Stevens 2000 - update to be compatible up to  MPEG2.5
+	 */
+    AU_start = bs.bitcount();
+    if (bs.GetBits(11)==AUDIO_SYNCWORD)
+    {
+		num_syncword++;
+		version_id = bs.GetBits( 2);
+		layer 		= 3-bs.GetBits( 2); /* 0..2 not 1..3!! */
+		protection 		= bs.Get1Bit();
+		bit_rate_code	= bs.GetBits( 4);
+		frequency 		= bs.GetBits( 2);
+		padding_bit     = bs.Get1Bit();
+		bs.Get1Bit();
+		mode 		= bs.GetBits( 2);
+		mode_extension 	= bs.GetBits( 2);
+		copyright 		= bs.Get1Bit();
+		original_copy 	= bs.Get1Bit ();
+		emphasis		= bs.GetBits( 2);
+
+		framesize =
+			mpa_bitrates_kbps[version_id][layer][bit_rate_code]  * 
+			mpa_slots[layer] *1000 /
+			mpa_freq_table[version_id][frequency];
+
+		size_frames[0] = framesize * ( layer == 0 ? 4 : 1);
+		size_frames[1] = (framesize+1) * ( layer == 0 ? 4 : 1);
+		num_frames[padding_bit]++;
+        access_unit.start  = AU_start;
+		access_unit.length = size_frames[padding_bit];
+	  
+		samples_per_second = mpa_freq_table[version_id][frequency];
+
+		/* Presentation time-stamping  */
+		access_unit.PTS = static_cast&lt;clockticks&gt;(decoding_order) * 
+			static_cast&lt;clockticks&gt;(mpa_samples [layer]) * 
+			static_cast&lt;clockticks&gt;(CLOCKS)	/ samples_per_second;
+		access_unit.DTS = access_unit.PTS;
+		access_unit.dorder = decoding_order;
+		++decoding_order;
+		aunits.Append( access_unit );
+
+    } else
+    {
+		mjpeg_error ( &quot;Invalid MPEG Audio stream header.&quot;);
+		exit (1);
+    }
+
+
+	OutputHdrInfo();
+}
+
+unsigned int MPAStream::NominalBitRate()
+{ 
+	return mpa_bitrates_kbps[version_id][layer][bit_rate_code]*1024;
+}
+
+
+unsigned int MPAStream::SizeFrame( int rate_code, int padding )
+{
+	return ( mpa_bitrates_kbps[version_id][layer][rate_code]  * 
+		mpa_slots [layer] *1000 /
+		mpa_freq_table[version_id][frequency] + padding ) * ( layer == 0 ? 4 : 1);
+}
+
+void MPAStream::FillAUbuffer(unsigned int frames_to_buffer )
+{
+	unsigned int padding_bit;
+	last_buffered_AU += frames_to_buffer;
+
+    if( eoscan )
+        return;
+
+    mjpeg_debug( &quot;Scanning %d MPA frames to frame %d&quot;, 
+                frames_to_buffer,
+                last_buffered_AU );
+	while( !bs.eos() 
+           &amp;&amp; decoding_order &lt; last_buffered_AU 
+           &amp;&amp; !muxinto.AfterMaxPTS(access_unit.PTS) )
+	{
+
+		int skip=access_unit.length-4;
+        bs.SeekFwdBits( skip );
+		prev_offset = AU_start;
+		AU_start = bs.bitcount();
+        if( AU_start - prev_offset != access_unit.length*8 )
+        {
+            mjpeg_warn(&quot;Discarding incomplete final frame MPEG audio stream %02x!&quot;,
+                       stream_id
+                       );
+            aunits.DropLast();
+            --decoding_order;
+            break;
+        }
+		/* Check we have reached the end of have  another catenated 
+		   stream to process before finishing ... */
+		if ( (syncword = bs.GetBits( 11))!=AUDIO_SYNCWORD )
+		{
+            //
+            // Handle a broken last frame...
+			if( !bs.eos()   )
+			{
+                mjpeg_warn( &quot;Data follows end of last recogniseable MPEG audio frame - bad stream?&quot;);
+                eoscan = true;
+                return;
+			}
+            break;
+		}
+		// Skip version_id:2, layer:2, protection:1
+		(void) bs.GetBits( 5);
+		int rate_code	= bs.GetBits( 4);
+		// Skip frequency
+		(void) bs.GetBits( 2);
+
+		padding_bit=bs.Get1Bit();
+		access_unit.start = AU_start;
+		access_unit.length = SizeFrame( rate_code, padding_bit );
+		access_unit.PTS = static_cast&lt;clockticks&gt;(decoding_order) * static_cast&lt;clockticks&gt;(mpa_samples[layer]) * static_cast&lt;clockticks&gt;(CLOCKS)
+			/ samples_per_second;
+		access_unit.DTS = access_unit.PTS;
+		access_unit.dorder = decoding_order;
+		decoding_order++;
+		aunits.Append( access_unit );
+		num_frames[padding_bit]++;
+
+		bs.GetBits( 9);
+		
+		num_syncword++;
+
+		if (num_syncword &gt;= old_frames+10 )
+		{
+			mjpeg_debug (&quot;Got %d frame headers.&quot;, num_syncword);
+			old_frames=num_syncword;
+		
+		}
+	
+
+
+    }
+	last_buffered_AU = decoding_order;
+	eoscan = bs.eos() || muxinto.AfterMaxPTS(access_unit.PTS);
+}
+
+
+
+void MPAStream::Close()
+{
+    stream_length = AU_start &gt;&gt; 3;
+	mjpeg_info (&quot;AUDIO_STATISTICS: %02x&quot;, stream_id); 
+    mjpeg_info (&quot;Audio stream length %lld bytes.&quot;, stream_length);
+    mjpeg_info   (&quot;Syncwords      : %8u&quot;,num_syncword);
+    mjpeg_info   (&quot;Frames         : %8u padded&quot;,  num_frames[0]);
+    mjpeg_info   (&quot;Frames         : %8u unpadded&quot;, num_frames[1]);
+	
+}
+
+/*************************************************************************
+	OutputAudioInfo
+	gibt gesammelte Informationen zu den Audio Access Units aus.
+
+	Prints information on audio access units
+*************************************************************************/
+
+void MPAStream::OutputHdrInfo ()
+{
+    unsigned int bitrate;
+    bitrate = mpa_bitrates_kbps[version_id][layer][bit_rate_code];
+
+
+	mjpeg_info(&quot;MPEG AUDIO STREAM: %02x&quot;, stream_id);
+	mjpeg_info(&quot;Audio version  : %s&quot;, mpa_audio_version[version_id]);
+    mjpeg_info(&quot;Layer          : %8u&quot;,layer+1);
+
+    if (protection == 0) mjpeg_info (&quot;CRC checksums  :      yes&quot;);
+    else  mjpeg_info (&quot;CRC checksums  :       no&quot;);
+
+    if (bit_rate_code == 0)
+		mjpeg_info (&quot;Bit rate       :     free&quot;);
+    else if (bit_rate_code == 0xf)
+		mjpeg_info (&quot;Bit rate       : reserved&quot;);
+    else
+		mjpeg_info (&quot;Bit rate       : %8u bytes/sec (%3u kbit/sec)&quot;,
+				bitrate*128, bitrate);
+
+    if (frequency == 3)
+		mjpeg_info (&quot;Frequency      : reserved&quot;);
+    else
+		mjpeg_info (&quot;Frequency      :     %d Hz&quot;,
+				mpa_freq_table[version_id][frequency]);
+
+    mjpeg_info   (&quot;Mode           : %8u %s&quot;,
+			  mode,mpa_stereo_mode[mode]);
+    mjpeg_info   (&quot;Mode extension : %8u&quot;,mode_extension);
+    mjpeg_info   (&quot;Copyright bit  : %8u %s&quot;,
+			  copyright,mpa_copyright_status[copyright]);
+    mjpeg_info   (&quot;Original/Copy  : %8u %s&quot;,
+			  original_copy,mpa_original_bit[original_copy]);
+    mjpeg_info   (&quot;Emphasis       : %8u %s&quot;,
+			  emphasis,mpa_emphasis_mode[emphasis]);
+}
+
+
+
+/* 
+ * Local variables:
+ *  c-file-style: &quot;stroustrup&quot;
+ *  tab-width: 4
+ *  indent-tabs-mode: nil
+ * End:
+ */

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/mpegconsts.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/mpegconsts.c	2009-09-04 15:59:41 UTC (rev 5319)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/mpegconsts.c	2009-09-05 08:19:09 UTC (rev 5320)
@@ -0,0 +1,484 @@
+
+/*
+ *  mpegconsts.c:  Video format constants for MPEG and utilities for display
+ *                 and conversion to format used for yuv4mpeg
+ *
+ *  Copyright (C) 2001 Andrew Stevens &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">andrew.stevens at philips.com</A>&gt;
+ *  Copyright (C) 2001 Matthew Marjanovic &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">maddog at mir.com</A>&gt;
+ *
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of version 2 of the GNU General Public License
+ *  as published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+#include &lt;config.h&gt;
+#include &quot;mpegconsts.h&quot;
+#include &quot;yuv4mpeg.h&quot;
+#include &quot;yuv4mpeg_intern.h&quot;
+
+static y4m_ratio_t
+mpeg_framerates[] = {
+  Y4M_FPS_UNKNOWN,
+  Y4M_FPS_NTSC_FILM,
+  Y4M_FPS_FILM,
+  Y4M_FPS_PAL,
+  Y4M_FPS_NTSC,
+  Y4M_FPS_30,
+  Y4M_FPS_PAL_FIELD,
+  Y4M_FPS_NTSC_FIELD,
+  Y4M_FPS_60
+};
+
+
+#define MPEG_NUM_RATES (sizeof(mpeg_framerates)/sizeof(mpeg_framerates[0]))
+static const mpeg_framerate_code_t mpeg_num_framerates = MPEG_NUM_RATES;
+
+//static const char *
+//framerate_definitions[MPEG_NUM_RATES] =
+//{
+//   &quot;illegal&quot;, 
+//  &quot;24000.0/1001.0 (NTSC 3:2 pulldown converted FILM)&quot;,
+//  &quot;24.0 (NATIVE FILM)&quot;,
+//  &quot;25.0 (PAL/SECAM VIDEO / converted FILM)&quot;,
+//  &quot;30000.0/1001.0 (NTSC VIDEO)&quot;,
+//  &quot;30.0&quot;,
+//  &quot;50.0 (PAL FIELD RATE)&quot;,
+//  &quot;60000.0/1001.0 (NTSC FIELD RATE)&quot;,
+//  &quot;60.0&quot;
+//};
+
+
+static const char *mpeg1_aspect_ratio_definitions[] =
+{
+    &quot;illegal&quot;,
+	&quot;1:1 (square pixels)&quot;,
+	&quot;1:0.6735&quot;,
+	&quot;1:0.7031 (16:9 Anamorphic PAL/SECAM for 720x578/352x288 images)&quot;,
+	&quot;1:0.7615&quot;,
+	&quot;1:0.8055&quot;,
+	&quot;1:0.8437 (16:9 Anamorphic NTSC for 720x480/352x240 images)&quot;,
+	&quot;1:0.8935&quot;,
+	&quot;1:0.9375 (4:3 PAL/SECAM for 720x578/352x288 images)&quot;,
+	&quot;1:0.9815&quot;,
+	&quot;1:1.0255&quot;,
+	&quot;1:1:0695&quot;,
+	&quot;1:1.1250 (4:3 NTSC for 720x480/352x240 images)&quot;,
+	&quot;1:1.1575&quot;,
+	&quot;1:1.2015&quot;
+};
+
+static const y4m_ratio_t mpeg1_aspect_ratios[] =
+{
+    Y4M_SAR_UNKNOWN,
+	Y4M_SAR_MPEG1_1,
+	Y4M_SAR_MPEG1_2,
+	Y4M_SAR_MPEG1_3, /* Anamorphic 16:9 PAL */
+	Y4M_SAR_MPEG1_4,
+	Y4M_SAR_MPEG1_5,
+	Y4M_SAR_MPEG1_6, /* Anamorphic 16:9 NTSC */
+	Y4M_SAR_MPEG1_7,
+	Y4M_SAR_MPEG1_8, /* PAL/SECAM 4:3 */
+	Y4M_SAR_MPEG1_9,
+	Y4M_SAR_MPEG1_10,
+	Y4M_SAR_MPEG1_11,
+	Y4M_SAR_MPEG1_12, /* NTSC 4:3 */
+	Y4M_SAR_MPEG1_13,
+	Y4M_SAR_MPEG1_14,
+};
+
+static const char *mpeg2_aspect_ratio_definitions[] = 
+{
+    &quot;illegal&quot;,
+	&quot;1:1 pixels&quot;,
+	&quot;4:3 display&quot;,
+	&quot;16:9 display&quot;,
+	&quot;2.21:1 display&quot;
+};
+
+
+static const y4m_ratio_t mpeg2_aspect_ratios[] =
+{
+    Y4M_DAR_UNKNOWN,
+	Y4M_DAR_MPEG2_1,
+	Y4M_DAR_MPEG2_2,
+ 	Y4M_DAR_MPEG2_3,
+	Y4M_DAR_MPEG2_4
+};
+
+static const char **aspect_ratio_definitions[2] = 
+{
+	mpeg1_aspect_ratio_definitions,
+	mpeg2_aspect_ratio_definitions
+};
+
+//static const y4m_ratio_t *mpeg_aspect_ratios[2] = 
+//{
+//	mpeg1_aspect_ratios,
+//	mpeg2_aspect_ratios
+//};
+
+static const mpeg_aspect_code_t mpeg_num_aspect_ratios[2] = 
+{
+  sizeof(mpeg1_aspect_ratios)/sizeof(mpeg1_aspect_ratios[0]),
+  sizeof(mpeg2_aspect_ratios)/sizeof(mpeg2_aspect_ratios[0])
+};
+
+
+/*
+ * Is code a valid MPEG framerate code?
+ */
+
+int
+MX_mpeg_valid_framerate_code( mpeg_framerate_code_t code )
+{
+    return ((code &gt; 0) &amp;&amp; (code &lt; mpeg_num_framerates)) ? 1 : 0;
+}
+
+
+/*
+ * Convert MPEG frame-rate code to corresponding frame-rate
+ */
+
+y4m_ratio_t
+MX_mpeg_framerate( mpeg_framerate_code_t code )
+{
+    if ((code &gt; 0) &amp;&amp; (code &lt; mpeg_num_framerates))
+		return mpeg_framerates[code];
+    else
+		return y4m_fps_UNKNOWN;
+}
+
+///*
+// * Look-up MPEG frame rate code for a (exact) frame rate.
+// */
+//
+//
+//mpeg_framerate_code_t 
+//mpeg_framerate_code( y4m_ratio_t framerate )
+//{
+//	mpeg_framerate_code_t i;
+//  
+//	y4m_ratio_reduce(&amp;framerate);
+//    /* start at '1', because 0 is unknown/illegal */
+//	for (i = 1; i &lt; mpeg_num_framerates; ++i) {
+//		if (Y4M_RATIO_EQL(framerate, mpeg_framerates[i]))
+//			return i;
+//	}
+//	return 0;
+//}
+//
+//
+///* small enough to distinguish 1/1000 from 1/1001 */
+//#define MPEG_FPS_TOLERANCE 0.0001
+//
+//
+//y4m_ratio_t
+//mpeg_conform_framerate( double fps )
+//{
+//	mpeg_framerate_code_t i;
+//	y4m_ratio_t result;
+//
+//	/* try to match it to a standard frame rate */
+//    /* (start at '1', because 0 is unknown/illegal) */
+//	for (i = 1; i &lt; mpeg_num_framerates; i++) 
+//	{
+//		double deviation = 1.0 - (Y4M_RATIO_DBL(mpeg_framerates[i]) / fps);
+//		if ( (deviation &gt; -MPEG_FPS_TOLERANCE) &amp;&amp;
+//			 (deviation &lt; +MPEG_FPS_TOLERANCE) )
+//			return mpeg_framerates[i];
+//	}
+//	/* no luck?  just turn it into a ratio (6 decimal place accuracy) */
+//	result.n = (int)((fps * 1000000.0) + 0.5);
+//	result.d = 1000000;
+//	y4m_ratio_reduce(&amp;result);
+//	return result;
+//}
+
+  
+
+/*
+ * Is code a valid MPEG aspect-ratio code?
+ */
+
+int
+MX_mpeg_valid_aspect_code( int version, mpeg_framerate_code_t c )
+{
+	if ((version == 1) || (version == 2))
+        return ((c &gt; 0) &amp;&amp; (c &lt; mpeg_num_aspect_ratios[version-1])) ? 1 : 0;
+    else
+        return 0;
+}
+
+
+///*
+// * Convert MPEG aspect-ratio code to corresponding aspect-ratio
+// */
+//
+//y4m_ratio_t 
+//mpeg_aspect_ratio( int mpeg_version,  mpeg_aspect_code_t code )
+//{
+//	y4m_ratio_t ratio;
+//    if ((mpeg_version &gt;= 1) &amp;&amp; (mpeg_version &lt;= 2) &amp;&amp;
+//        (code &gt; 0) &amp;&amp; (code &lt; mpeg_num_aspect_ratios[mpeg_version-1]))
+//	{
+//		ratio = mpeg_aspect_ratios[mpeg_version-1][code];
+//		y4m_ratio_reduce(&amp;ratio);
+//		return ratio;
+//	}
+//    else
+//		return y4m_sar_UNKNOWN;
+//}
+//
+//
+//
+///*
+// * Look-up corresponding MPEG aspect ratio code given an exact aspect ratio.
+// *
+// * WARNING: The semantics of aspect ratio coding *changed* between
+// * MPEG1 and MPEG2.  In MPEG1 it is the *pixel* aspect ratio. In
+// * MPEG2 it is the (far more sensible) aspect ratio of the eventual
+// * display.
+// *
+// */
+//
+//mpeg_aspect_code_t 
+//mpeg_frame_aspect_code( int mpeg_version, y4m_ratio_t aspect_ratio )
+//{
+//	mpeg_aspect_code_t i;
+//	y4m_ratio_t red_ratio = aspect_ratio;
+//	y4m_ratio_reduce( &amp;red_ratio );
+//	if( mpeg_version &lt; 1 || mpeg_version &gt; 2 )
+//		return 0;
+//    /* (start at '1', because 0 is unknown/illegal) */
+//	for( i = 1; i &lt; mpeg_num_aspect_ratios[mpeg_version-1]; ++i )
+//	{
+//		y4m_ratio_t red_entry =  mpeg_aspect_ratios[mpeg_version-1][i];
+//		y4m_ratio_reduce( &amp;red_entry );
+//		if(  Y4M_RATIO_EQL( red_entry, red_ratio) )
+//			return i;
+//	}
+//
+//	return 0;
+//			
+//}
+//
+//
+//
+///*
+// * Guess the correct MPEG aspect ratio code,
+// *  given the true sample aspect ratio and frame size of a video stream
+// *  (and the MPEG version, 1 or 2).
+// *
+// * Returns 0 if it has no good guess.
+// *
+// */
+//
+//
+///* this is big enough to accommodate the difference between 720 and 704 */
+//#define GUESS_ASPECT_TOLERANCE 0.03
+//
+//mpeg_aspect_code_t 
+//mpeg_guess_mpeg_aspect_code(int mpeg_version, y4m_ratio_t sampleaspect,
+//							int frame_width, int frame_height)
+//{
+//	if (Y4M_RATIO_EQL(sampleaspect, y4m_sar_UNKNOWN))
+//    {
+//		return 0;
+//    }
+//	switch (mpeg_version) {
+//	case 1:
+//		if (Y4M_RATIO_EQL(sampleaspect, y4m_sar_SQUARE))
+//		{
+//			return 1;
+//		} 
+//		else if (Y4M_RATIO_EQL(sampleaspect, y4m_sar_NTSC_CCIR601))
+//		{
+//			return 12;
+//		} 
+//		else if (Y4M_RATIO_EQL(sampleaspect, y4m_sar_NTSC_16_9))
+//		{
+//			return 6;
+//		} 
+//		else if (Y4M_RATIO_EQL(sampleaspect, y4m_sar_PAL_CCIR601))
+//		{
+//			return 8;
+//		} 
+//		else if (Y4M_RATIO_EQL(sampleaspect, y4m_sar_PAL_16_9))
+//		{
+//			return 3;
+//		} 
+//		return 0;
+//		break;
+//	case 2:
+//		if (Y4M_RATIO_EQL(sampleaspect, y4m_sar_SQUARE))
+//		{
+//			return 1;  /* '1' means square *pixels* in MPEG-2; go figure. */
+//		}
+//		else
+//		{
+//			int i;
+//			double true_far;  /* true frame aspect ratio */
+//			true_far = 
+//				(double)(sampleaspect.n * frame_width) /
+//				(double)(sampleaspect.d * frame_height);
+//			/* start at '2'... */
+//			for (i = 2; i &lt; (int)(mpeg_num_aspect_ratios[mpeg_version-1]); i++) 
+//			{
+//				double ratio = 
+//					true_far / Y4M_RATIO_DBL(mpeg_aspect_ratios[mpeg_version-1][i]);
+//				if ( (ratio &gt; (1.0 - GUESS_ASPECT_TOLERANCE)) &amp;&amp;
+//					 (ratio &lt; (1.0 + GUESS_ASPECT_TOLERANCE)) )
+//					return i;
+//			}
+//			return 0;
+//		}
+//		break;
+//	default:
+//		return 0;
+//		break;
+//	}
+//}
+//
+//
+//
+//
+///*
+// * Guess the true sample aspect ratio of a video stream,
+// *  given the MPEG aspect ratio code and the actual frame size
+// *  (and the MPEG version, 1 or 2).
+// *
+// * Returns y4m_sar_UNKNOWN if it has no good guess.
+// *
+// */
+//y4m_ratio_t 
+//mpeg_guess_sample_aspect_ratio(int mpeg_version,
+//							   mpeg_aspect_code_t code,
+//							   int frame_width, int frame_height)
+//{
+//	switch (mpeg_version) 
+//	{
+//	case 1:
+//		/* MPEG-1 codes turn into SAR's, just not quite the right ones.
+//		   For the common/known values, we provide the ratio used in practice,
+//		   otherwise say we don't know.*/
+//		switch (code)
+//		{
+//		case 1:  return y4m_sar_SQUARE;        break;
+//		case 3:  return y4m_sar_PAL_16_9;      break;
+//		case 6:  return y4m_sar_NTSC_16_9;     break;
+//		case 8:  return y4m_sar_PAL_CCIR601;   break;
+//		case 12: return y4m_sar_NTSC_CCIR601;  break;
+//		default:
+//			return y4m_sar_UNKNOWN;       break;
+//		}
+//		break;
+//	case 2:
+//		/* MPEG-2 codes turn into Display Aspect Ratios, though not exactly the
+//		   DAR's used in practice.  For common/standard frame sizes, we provide
+//		   the original SAR; otherwise, we say we don't know. */
+//		if (code == 1) 
+//		{
+//			return y4m_sar_SQUARE; /* '1' means square *pixels* in MPEG-2 */
+//		}
+//		else if ((code &gt;= 2) &amp;&amp; (code &lt;= 4))
+//		{
+//            return y4m_guess_sar(frame_width, frame_height,
+//                                 mpeg2_aspect_ratios[code]);
+//		} 
+//		else
+//		{
+//			return y4m_sar_UNKNOWN;
+//		}
+//		break;
+//	default:
+//		return y4m_sar_UNKNOWN;
+//		break;
+//	}
+//}
+//
+//
+//
+//
+//
+///*
+// * Look-up MPEG explanatory definition string for frame rate code
+// *
+// */
+//
+//
+//const char *
+//mpeg_framerate_code_definition(   mpeg_framerate_code_t code  )
+//{
+//	if( code == 0 || code &gt;=  mpeg_num_framerates )
+//		return &quot;UNDEFINED: illegal/reserved frame-rate ratio code&quot;;
+//
+//	return framerate_definitions[code];
+//}
+
+/*
+ * Look-up MPEG explanatory definition string aspect ratio code for an
+ * aspect ratio code
+ *
+ */
+
+const char *
+MX_mpeg_aspect_code_definition( int mpeg_version,  mpeg_aspect_code_t code  )
+{
+	if( mpeg_version &lt; 1 || mpeg_version &gt; 2 )
+		return &quot;UNDEFINED: illegal MPEG version&quot;;
+	
+	if( code &lt; 1 || code &gt;=  mpeg_num_aspect_ratios[mpeg_version-1] )
+		return &quot;UNDEFINED: illegal aspect ratio code&quot;;
+
+	return aspect_ratio_definitions[mpeg_version-1][code];
+}
+
+
+///*
+// * Look-up explanatory definition of interlace field order code
+// *
+// */
+//
+//const char *
+//mpeg_interlace_code_definition( int yuv4m_interlace_code )
+//{
+//	const char *def;
+//	switch( yuv4m_interlace_code )
+//	{
+//	case Y4M_UNKNOWN :
+//		def = &quot;unknown&quot;;
+//		break;
+//	case Y4M_ILACE_NONE :
+//		def = &quot;none/progressive&quot;;
+//		break;
+//	case Y4M_ILACE_TOP_FIRST :
+//		def = &quot;top-field-first&quot;;
+//		break;
+//	case Y4M_ILACE_BOTTOM_FIRST :
+//		def = &quot;bottom-field-first&quot;;
+//		break;
+//	default :
+//		def = &quot;UNDEFINED: illegal video interlacing type-code!&quot;;
+//		break;
+//	}
+//	return def;
+//}
+
+
+/* 
+ * Local variables:
+ *  c-file-style: &quot;stroustrup&quot;
+ *  tab-width: 4
+ *  indent-tabs-mode: nil
+ * End:
+ */

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/mpegconsts.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/mpegconsts.h	2009-09-04 15:59:41 UTC (rev 5319)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/mpegconsts.h	2009-09-05 08:19:09 UTC (rev 5320)
@@ -0,0 +1,165 @@
+
+/*
+ *  mpegconsts.c:  Video format constants for MPEG and utilities for display
+ *                 and conversion to format used for yuv4mpeg
+ *
+ *  Copyright (C) 2001 Andrew Stevens &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">andrew.stevens at philips.com</A>&gt;
+ *
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of version 2 of the GNU General Public License
+ *  as published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+#ifndef __MPEGCONSTS_H__
+#define __MPEGCONSTS_H__
+
+#include &lt;yuv4mpeg.h&gt;
+
+typedef unsigned int mpeg_framerate_code_t;
+typedef unsigned int mpeg_aspect_code_t;
+
+#ifdef __cplusplus
+#define START_CPP_WRAP extern &quot;C&quot; {
+#define END_CPP_WRAP };
+#else
+#define START_CPP_WRAP
+#define END_CPP_WRAP
+#endif
+
+START_CPP_WRAP
+
+
+/*
+ * Convert MPEG frame-rate code to corresponding frame-rate
+ *  y4m_fps_UNKNOWN = { 0, 0 } = Undefined/resrerved code.
+ */
+
+y4m_ratio_t
+MX_mpeg_framerate( mpeg_framerate_code_t code );
+
+
+/*
+ * Is code a valid MPEG frame-rate code?
+ * Return 1 if true; 0 otherwise.
+ */
+
+int
+MX_mpeg_valid_framerate_code( mpeg_framerate_code_t code );
+
+
+///*
+// * Look-up MPEG frame rate code for a (exact) frame rate.
+// *  0 = No MPEG code defined for frame-rate
+// */
+//
+//mpeg_framerate_code_t 
+//mpeg_framerate_code( y4m_ratio_t framerate );
+//
+//
+///*
+// * Convert floating-point framerate to an exact ratio.
+// *  Uses a standard MPEG rate, if it finds one within MPEG_FPS_TOLERANCE
+// *  (see mpegconsts.c), otherwise uses &quot;fps:1000000&quot; as the ratio.
+// */
+//
+//y4m_ratio_t
+//mpeg_conform_framerate( double fps );
+//
+//
+///*
+// * Convert MPEG aspect ratio code to corresponding aspect ratio
+// *
+// * WARNING: The semantics of aspect ratio coding *changed* between
+// * MPEG1 and MPEG2.  In MPEG1 it is the *pixel* aspect ratio. In
+// * MPEG2 it is the (far more sensible) aspect ratio of the eventual
+// * display.
+// *
+// */
+//
+//y4m_ratio_t
+//mpeg_aspect_ratio( int mpeg_version,  mpeg_aspect_code_t code );
+
+
+/*
+ * Is code a valid MPEG(1,2) aspect-ratio code?
+ * Return 1 if true; 0 otherwise.
+ */
+
+int
+MX_mpeg_valid_aspect_code( int mpeg_version, mpeg_aspect_code_t code );
+
+
+///*
+// * Look-up MPEG aspect ratio code for an aspect ratio - tolerance
+// * is Y4M_ASPECT_MULT used by YUV4MPEG (see yuv4mpeg_intern.h)
+// *
+// * WARNING: The semantics of aspect ratio coding *changed* between
+// * MPEG1 and MPEG2.  In MPEG1 it is the *pixel* aspect ratio. In
+// * MPEG2 it is the (far more sensible) aspect ratio of the eventual
+// * display.
+// *
+// */
+//
+//mpeg_aspect_code_t 
+//mpeg_frame_aspect_code( int mpeg_version, y4m_ratio_t aspect_ratio );
+
+/*
+ * Look-up MPEG explanatory definition string aspect ratio code for an
+ * aspect ratio code
+ *
+ */
+
+const char *
+MX_mpeg_aspect_code_definition( int mpeg_version,  mpeg_aspect_code_t code  );
+
+///*
+// * Look-up MPEG explanatory definition string aspect ratio code for an
+// * frame rate code
+// *
+// */
+//
+//const char *
+//mpeg_framerate_code_definition( mpeg_framerate_code_t code  );
+//
+//const char *
+//mpeg_interlace_code_definition( int yuv4m_interlace_code );
+//
+//
+///*
+// * Guess the correct MPEG aspect ratio code,
+// *  given the true sample aspect ratio and frame size of a video stream
+// *  (and the MPEG version, 1 or 2).
+// *
+// * Returns 0 if it has no good answer.
+// *
+// */
+//mpeg_aspect_code_t 
+//mpeg_guess_mpeg_aspect_code(int mpeg_version, y4m_ratio_t sampleaspect,
+//			    int frame_width, int frame_height);
+//
+///*
+// * Guess the true sample aspect ratio of a video stream,
+// *  given the MPEG aspect ratio code and the actual frame size
+// *  (and the MPEG version, 1 or 2).
+// *
+// * Returns y4m_sar_UNKNOWN if it has no good answer.
+// *
+// */
+//y4m_ratio_t 
+//mpeg_guess_sample_aspect_ratio(int mpeg_version,
+//			       mpeg_aspect_code_t code,
+//			       int frame_width, int frame_height);
+
+END_CPP_WRAP
+
+#endif /* __MPEGCONSTS_H__ */

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/mplexconsts.hpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/mplexconsts.hpp	2009-09-04 15:59:41 UTC (rev 5319)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/mplexconsts.hpp	2009-09-05 08:19:09 UTC (rev 5320)
@@ -0,0 +1,87 @@
+#ifndef __MPLEXCONSTS_H__
+#define __MPLEXCONSTS_H__
+
+
+#define SEQUENCE_HEADER 	0x000001b3
+#define SEQUENCE_END		0x000001b7
+#define PICTURE_START		0x00000100
+#define EXT_START_CODE 0x000001b5
+#define GROUP_START		0x000001b8
+#define SYNCWORD_START		0x000001
+
+#define ZA_SEQUENCE_HEADER      0x000001f8
+
+#define IFRAME                  1
+#define PFRAME                  2
+#define BFRAME                  3
+#define DFRAME                  4
+#define NOFRAME                 5
+
+#define PIC_TOP_FIELD 1
+#define PIC_BOT_FIELD 2
+#define PIC_FRAME 3
+
+#define CODING_EXT_ID       8
+#define AUDIO_SYNCWORD		0x7ff
+
+
+#define PACK_START		0x000001ba
+#define SYS_HEADER_START	0x000001bb
+#define ISO11172_END		0x000001b9
+#define PACKET_START		0x000001
+
+#define MAX_FFFFFFFF		4294967295.0 	/* = 0xffffffff in dec.	*/
+
+#define CLOCKS_per_90Kth_sec 300
+
+#define CLOCKS			(CLOCKS_per_90Kth_sec*90000)	
+/* MPEG-2 System Clock Hertz - we divide down by 300.0 for MPEG-1*/
+
+/* Range of sizes of the fields following the packet length field in packet header:
+	used to calculate if recieve buffers will have enough space... */
+
+#define MPEG2_BUFFERINFO_LENGTH 3
+#define MPEG1_BUFFERINFO_LENGTH 2
+#define DTS_PTS_TIMESTAMP_LENGTH 5
+#define MPEG2_AFTER_PACKET_LENGTH_MIN    3
+#define MPEG1_AFTER_PACKET_LENGTH_MIN    (0+1)
+
+	/* Sector under-size below which header stuffing rather than padding packets
+		or post-packet zero stuffing is used.  *Must* be less than 20 for VCD
+		multiplexing to work correctly!
+	 */
+	 
+#define MINIMUM_PADDING_PACKET_SIZE 10
+
+#define PACKET_HEADER_SIZE	6
+
+#define AUDIO_STREAMS		0xb8		/* Marker Audio Streams	*/
+#define VIDEO_STREAMS		0xb9		/* Marker Video Streams	*/
+#define AUDIO_STR_0		0xc0		/* Marker Audio Stream0	*/
+#define VIDEO_STR_0		0xe0		/* Marker Video Stream0	*/
+#define ZALPHA_STR_0		0xf8		/* Marker Z/Alpha Stream0 */
+#define PADDING_STR		0xbe		/* Marker Padding Stream*/
+#define PRIVATE_STR_1   0xbd            /* private stream 1 */
+#define PRIVATE_STR_2   0xbf            /* private stream 2 */
+#define AC3_SUB_STR_0   0x80            /* AC3 substream id 0 */
+#define DTS_SUB_STR_0   0x88            /* DTS substream id 0 */
+
+#define LPCM_SUB_STR_0  0xa0	        /* LPCM substream id 0 */
+
+#define ZERO_STUFFING_BYTE	0
+#define STUFFING_BYTE		0xff
+#define RESERVED_BYTE		0xff
+#define TIMESTAMPBITS_NO		0		/* Flag NO timestamps	*/
+#define TIMESTAMPBITS_PTS		2		/* Flag PTS timestamp	*/
+#define TIMESTAMPBITS_DTS		1		/* Flag PTS timestamp	*/
+#define TIMESTAMPBITS_PTS_DTS	(TIMESTAMPBITS_DTS|TIMESTAMPBITS_PTS)		/* Flag BOTH timestamps	*/
+
+#define MARKER_MPEG1_SCR		2		/* Marker SCR		*/
+#define MARKER_MPEG2_SCR        1		/* These don't need to be distinct! */
+#define MARKER_JUST_PTS			2		/* Marker only PTS	*/
+#define MARKER_PTS				3		/* Marker PTS		*/
+#define MARKER_DTS				1		/* Marker DTS		*/
+#define MARKER_NO_TIMESTAMPS	0x0f	/* Marker NO timestamps	*/
+
+
+#endif // __MPLEXCONSTS_H__

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/multiplexor.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/multiplexor.cpp	2009-09-04 15:59:41 UTC (rev 5319)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/multiplexor.cpp	2009-09-05 08:19:09 UTC (rev 5320)
@@ -0,0 +1,1502 @@
+/*
+ *  multiplexor.cpp:  Program/System stream Multiplex despatcher 
+ *
+ *  Copyright (C) 2003 Andrew Stevens &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">andrew.stevens at philips.com</A>&gt;
+ *
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of version 2 of the GNU General Public License
+ *  as published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+#define STREAM_LOGGING
+#include &lt;config.h&gt;
+#include &lt;math.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;string.h&gt;
+
+#include &lt;mjpeg_types.h&gt;
+#include &lt;mjpeg_logging.h&gt;
+#include &lt;format_codes.h&gt;
+
+#include &quot;interact.hpp&quot;
+#include &quot;videostrm.hpp&quot;
+#include &quot;stillsstream.hpp&quot;
+#include &quot;audiostrm.hpp&quot;
+#ifdef ZALPHA
+#include &quot;zalphastrm.hpp&quot;
+#endif
+#include &quot;multiplexor.hpp&quot;
+
+
+/****************
+ *
+ * Constructor - sets up per-run stuff and initialised parameters
+ * that control syntax of generated stream from the job options set
+ * by the user.
+ *
+ ***************/
+
+Multiplexor::Multiplexor(MultiplexJob &amp;job, OutputStream &amp;output)
+{
+    underrun_ignore = 0;
+    underruns = 0;
+	start_of_new_pack = false;
+    InitSyntaxParameters(job);
+    InitInputStreams(job);
+
+    psstrm = new PS_Stream(mpeg, sector_size, output, max_segment_size );
+
+}
+
+
+/******************************************************************
+ *
+ * Initialisation of stream syntax paramters based on selected user
+ * options.  Depending of mux_format some selections may only act as
+ * defaults or may simply be ignored if they are inconsistent with the
+ * selected output format.
+ *
+ ******************************************************************/
+
+
+void Multiplexor::InitSyntaxParameters(MultiplexJob &amp;job)
+{
+	seg_starts_with_video = false;
+	audio_buffer_size = 4 * 1024;
+    mux_format = job.mux_format;
+    vbr = job.VBR;
+    packets_per_pack = job.packets_per_pack;
+    data_rate = job.data_rate;
+    mpeg = job.mpeg;
+    always_sys_header_in_pack = job.always_system_headers;
+    sector_transport_size = job.sector_size;
+    sector_size = job.sector_size;
+	split_at_seq_end = !job.multifile_segment;
+    workarounds = job.workarounds;
+    max_segment_size = static_cast&lt;off_t&gt;(job.max_segment_size)
+                       * static_cast&lt;off_t&gt;(1024 * 1024);
+    max_PTS = static_cast&lt;clockticks&gt;(job.max_PTS) * CLOCKS;
+	video_delay = static_cast&lt;clockticks&gt;(job.video_offset);
+	audio_delay = static_cast&lt;clockticks&gt;(job.audio_offset);
+ 	switch( mux_format  )
+	{
+	case MPEG_FORMAT_VCD :
+		data_rate = 75*2352;  			 /* 75 raw CD sectors/sec */ 
+	case MPEG_FORMAT_VCD_NSR : /* VCD format, non-standard rate */
+		mjpeg_info( &quot;Selecting VCD output profile&quot;);
+		video_buffers_iframe_only = false;
+		mpeg = 1;
+	 	packets_per_pack = 1;
+	  	sys_header_in_pack1 = 0;
+	  	always_sys_header_in_pack = 0;
+	  	sector_transport_size = 2352;	      /* Each 2352 bytes with 2324 bytes payload */
+	  	transport_prefix_sectors = 30;
+	  	sector_size = 2324;
+		buffers_in_video = 1;
+		always_buffers_in_video = 0;
+		buffers_in_audio = 1;   		// This is needed as otherwise we have
+		always_buffers_in_audio = 1;	//  to stuff the packer header which 
+                                        // must be 13 bytes for VCD audio
+		vcd_zero_stuffing = 20;         // The famous 20 zero bytes for VCD
+                                        // audio sectors.
+		dtspts_for_all_vau = false;
+		sector_align_iframeAUs = false;
+        timestamp_iframe_only = false;
+		seg_starts_with_video = true;
+        if( job.video_tracks == 0 )
+        {
+            mjpeg_info( &quot;Audio-only VCD track - variable-bit-rate (VCD2.0)&quot;);
+            vbr = true;
+        }
+		break;
+		
+	case  MPEG_FORMAT_MPEG2 : 
+		mjpeg_info( &quot;Selecting generic MPEG2 output profile&quot;);
+		mpeg = 2;
+	 	packets_per_pack = 1;
+	  	sys_header_in_pack1 = 1;
+	  	always_sys_header_in_pack = 0;
+	  	sector_transport_size = 2048;	      /* Each 2352 bytes with 2324 bytes payload */
+	  	transport_prefix_sectors = 0;
+	  	sector_size = 2048;
+		buffers_in_video = 1;
+		always_buffers_in_video = 0;
+		buffers_in_audio = 1;
+		always_buffers_in_audio = 1;
+		vcd_zero_stuffing = 0;
+		vbr = true;
+        	dtspts_for_all_vau = 0;
+        	timestamp_iframe_only = false;
+        	video_buffers_iframe_only = false;
+		break;
+
+	case MPEG_FORMAT_SVCD :
+		data_rate = 150*2324;
+
+	case MPEG_FORMAT_SVCD_NSR :		/* Non-standard data-rate */
+		mjpeg_info( &quot;Selecting SVCD output profile&quot;);
+		mpeg = 2;
+	 	packets_per_pack = 1;
+	  	sys_header_in_pack1 = 0;
+	  	always_sys_header_in_pack = 0;
+	  	sector_transport_size = 2324;
+	  	transport_prefix_sectors = 0;
+	  	sector_size = 2324;
+		vbr = true;
+		buffers_in_video = 1;
+		always_buffers_in_video = 0;
+		buffers_in_audio = 1;
+		always_buffers_in_audio = 0;
+		vcd_zero_stuffing = 0;
+        dtspts_for_all_vau = 0;
+		sector_align_iframeAUs = true;
+		seg_starts_with_video = true;
+        timestamp_iframe_only = false;
+        video_buffers_iframe_only = false;
+		break;
+
+	case MPEG_FORMAT_VCD_STILL :
+		data_rate = 75*2352;  			 /* 75 raw CD sectors/sec */ 
+	  	vbr = false;
+		mpeg = 1;
+		split_at_seq_end = false;
+	 	packets_per_pack = 1;
+	  	sys_header_in_pack1 = 0;
+	  	always_sys_header_in_pack = 0;
+	  	sector_transport_size = 2352;	      /* Each 2352 bytes with 2324 bytes payload */
+	  	transport_prefix_sectors = 0;
+	  	sector_size = 2324;
+		buffers_in_video = 1;
+		always_buffers_in_video = 0;
+		buffers_in_audio = 1;
+		always_buffers_in_audio = 0;
+		vcd_zero_stuffing = 20;
+		dtspts_for_all_vau = 1;
+		sector_align_iframeAUs = true;
+        timestamp_iframe_only = false;
+        video_buffers_iframe_only = false;
+		break;
+
+	case MPEG_FORMAT_SVCD_STILL :
+		mjpeg_info( &quot;Selecting SVCD output profile&quot;);
+		if( data_rate == 0 )
+			data_rate = 150*2324;
+		mpeg = 2;
+	 	packets_per_pack = 1;
+	  	sys_header_in_pack1 = 0;
+	  	always_sys_header_in_pack = 0;
+	  	sector_transport_size = 2324;
+	  	transport_prefix_sectors = 0;
+	  	sector_size = 2324;
+		vbr = true;
+		buffers_in_video = 1;
+		always_buffers_in_video = 0;
+		buffers_in_audio = 1;
+		always_buffers_in_audio = 0;
+		vcd_zero_stuffing = 0;
+        dtspts_for_all_vau = 0;
+		sector_align_iframeAUs = true;
+        timestamp_iframe_only = false;
+        video_buffers_iframe_only = false;
+		break;
+
+    case MPEG_FORMAT_DVD :
+		mjpeg_info( &quot;Selecting generic DVD output profile (PROVISIONAL)&quot;);
+        if( data_rate == 0 )
+            data_rate = 1260000;
+		mpeg = 2;
+	 	packets_per_pack = 1;
+	  	sys_header_in_pack1 = false; // Handle by control packets
+	  	always_sys_header_in_pack = false;
+	  	sector_transport_size = 2048;
+	  	transport_prefix_sectors = 0;
+	  	sector_size = 2048;
+		buffers_in_video = true;
+		always_buffers_in_video = false;
+		buffers_in_audio = true;
+		always_buffers_in_audio = false;
+		vcd_zero_stuffing = 0;
+        dtspts_for_all_vau = 0;
+		sector_align_iframeAUs = true;
+        timestamp_iframe_only = true;
+        video_buffers_iframe_only = true;
+		vbr = true;
+        break;
+
+    case MPEG_FORMAT_DVD_NAV :
+		mjpeg_info( &quot;Selecting dvdauthor DVD output profile&quot;);
+        if( data_rate == 0 )
+            data_rate = 1260000;
+		mpeg = 2;
+	 	packets_per_pack = 1;
+	  	sys_header_in_pack1 = false; // Handle by control packets
+	  	always_sys_header_in_pack = false;
+	  	sector_transport_size = 2048;
+	  	transport_prefix_sectors = 0;
+	  	sector_size = 2048;
+		buffers_in_video = true;
+		always_buffers_in_video = false;
+		buffers_in_audio = true;
+		always_buffers_in_audio = false;
+		vcd_zero_stuffing = 0;
+        dtspts_for_all_vau = 0;
+		sector_align_iframeAUs = true;
+        timestamp_iframe_only = true;
+        video_buffers_iframe_only = true;
+		vbr = true;
+        seg_starts_with_video = true; // Needs special NAV sector 1st!
+        break;
+			 
+	default : /* MPEG_FORMAT_MPEG1 - auto format MPEG1 */
+		mjpeg_info( &quot;Selecting generic MPEG1 output profile&quot;);
+		//mpeg = 1;
+		sys_header_in_pack1 = 1;
+		transport_prefix_sectors = 0;
+		buffers_in_video = 1;
+		always_buffers_in_video = 1;
+		buffers_in_audio = 0;
+		always_buffers_in_audio = 1;
+		vcd_zero_stuffing = 0;
+        dtspts_for_all_vau = 0;
+		sector_align_iframeAUs = false;
+        timestamp_iframe_only = false;
+        video_buffers_iframe_only = false;
+		break;
+	}
+}
+
+/**************************************
+ *
+ * Initialise the elementary stream readers / output sector formatter
+ * objects for the various kinds of input stream.
+ *
+ *************************************/
+
+void Multiplexor::InitInputStreams(MultiplexJob &amp;job)
+{
+    //
+    // S(VCD) Stills are sufficiently unusual to require their own
+    // special initialisation
+    //
+	if( MPEG_STILLS_FORMAT(job.mux_format) )
+        InitInputStreamsForStills( job );
+    else
+        InitInputStreamsForVideo( job );
+}
+
+void Multiplexor::InitInputStreamsForStills(MultiplexJob &amp; job )
+{
+	std::vector&lt;VideoParams *&gt;::iterator vidparm = job.video_param.begin();
+    unsigned int frame_interval;
+    unsigned int i;
+    vector&lt;JobStream *&gt; video_strms;
+    job.GetInputStreams( video_strms, MPEG_VIDEO );
+    vector&lt;JobStream *&gt; mpa_strms;
+    job.GetInputStreams( mpa_strms, MPEG_AUDIO );
+
+    switch( job.mux_format )
+    {
+    case MPEG_FORMAT_VCD_STILL :
+        mjpeg_info( &quot;Multiplexing VCD stills: %d stills streams.&quot;, video_strms.size() );
+        {
+            frame_interval = 30; // 30 Frame periods
+            if( mpa_strms.size() &gt; 0 &amp;&amp; video_strms.size() &gt; 2  )
+                mjpeg_error_exit1(&quot;VCD stills: no more than two streams (one normal one hi-res) possible&quot;);
+
+
+            VCDStillsStream *str[2];
+            
+            for( i = 0; i&lt; video_strms.size(); ++i )
+            {
+                FrameIntervals *ints = 
+                    new ConstantFrameIntervals( frame_interval );
+                str[i] = 
+                    new VCDStillsStream( *(video_strms[i]-&gt;bs),
+                                         new StillsParams( *vidparm, ints),
+                                         *this );
+                estreams.push_back( str[i] );
+                vstreams.push_back( str[i] );
+                str[i]-&gt;Init();
+                ++vidparm;
+            }
+            if( video_strms.size() == 2 )
+            {
+                str[0]-&gt;SetSibling(str[1]);
+                str[1]-&gt;SetSibling(str[0]);
+            }
+        }
+        break;
+    case MPEG_FORMAT_SVCD_STILL :
+        mjpeg_info( &quot;Multiplexing SVCD stills: %d stills streams %d audio streams&quot;, video_strms.size(), mpa_strms.size() );
+        frame_interval = 30;
+        if( video_strms.size() &gt; 1 )
+        {
+            mjpeg_error_exit1(&quot;SVCD stills streams may only contain a single video stream&quot;);
+        }
+        else if( video_strms.size() &gt; 0 )
+        {
+            ConstantFrameIntervals *intervals;
+            StillsStream *str;
+            intervals = new ConstantFrameIntervals( frame_interval );
+            str = new StillsStream( *(video_strms[0]-&gt;bs),
+                                    new StillsParams( *vidparm, intervals ),
+                                    *this );
+            estreams.push_back( str );
+            vstreams.push_back( str );
+            str-&gt;Init();
+        }
+        for( i = 0 ; i &lt; mpa_strms.size() ; ++i )
+        {
+            AudioStream *audioStrm = new MPAStream( *(mpa_strms[i]-&gt;bs), *this);
+            audioStrm-&gt;Init ( i);
+            estreams.push_back(audioStrm);
+            astreams.push_back(audioStrm);
+        }
+        break;
+    default:
+        mjpeg_error_exit1(&quot;Only VCD and SVCD stills format for the moment...&quot;);
+    }
+
+}
+
+void Multiplexor::InitInputStreamsForVideo(MultiplexJob &amp; job )
+{
+    mjpeg_info( &quot;Multiplexing video program stream!&quot; );
+
+    unsigned int audio_track = 0;
+    unsigned int video_track = 0;
+	std::vector&lt;VideoParams *&gt;::iterator vidparm = job.video_param.begin();
+	std::vector&lt;LpcmParams *&gt;::iterator lpcmparm = job.lpcm_param.begin();
+
+
+    std::vector&lt;JobStream *&gt;::iterator i;
+    for( i = job.streams.begin() ; i &lt; job.streams.end() ; ++i )
+    {
+        switch( (*i)-&gt;kind )
+        {
+            
+        case MPEG_VIDEO :
+        {
+            VideoStream *videoStrm;
+            //
+            // The first video stream is made the master stream...
+            //
+            if( video_track == 0  &amp;&amp; job.mux_format ==  MPEG_FORMAT_DVD_NAV )
+                videoStrm = new DVDVideoStream( *(*i)-&gt;bs, 
+                                                *vidparm,
+                                                *this);
+            else
+                    videoStrm = new VideoStream( *(*i)-&gt;bs,
+                                                 *vidparm,
+                                                 *this);
+            videoStrm-&gt;Init( video_track );
+            ++video_track;
+            ++vidparm;
+            estreams.push_back( videoStrm );
+            vstreams.push_back( videoStrm );
+        }
+        break;
+        case MPEG_AUDIO :
+        {
+            AudioStream *audioStrm = new MPAStream( *(*i)-&gt;bs, *this);
+            audioStrm-&gt;Init ( audio_track );
+            estreams.push_back(audioStrm);
+            astreams.push_back(audioStrm);
+           ++audio_track;
+        }
+        break;
+        case AC3_AUDIO :
+        {
+            AudioStream *audioStrm =  new AC3Stream( *(*i)-&gt;bs, *this);
+            audioStrm-&gt;Init ( audio_track );
+            estreams.push_back(audioStrm);
+            astreams.push_back(audioStrm);
+            ++audio_track;
+        }
+        break;
+        case DTS_AUDIO :
+        {
+            AudioStream *audioStrm = new DTSStream( *(*i)-&gt;bs, *this);
+            audioStrm-&gt;Init ( audio_track );
+            estreams.push_back(audioStrm);
+            astreams.push_back(audioStrm);
+            ++audio_track;
+        }
+        break;
+        case LPCM_AUDIO :
+        {
+            AudioStream *audioStrm =  new LPCMStream( *(*i)-&gt;bs, *lpcmparm, *this);
+            audioStrm-&gt;Init ( audio_track );
+            estreams.push_back(audioStrm);
+            astreams.push_back(audioStrm);
+            ++lpcmparm;
+            ++audio_track;
+        }
+        break;
+#ifdef ZALPHA
+        // just copies the video parameters from the first video stream
+        case Z_ALPHA :
+        {
+            ZAlphaStream *zalphaStrm = new ZAlphaStream( *(*i)-&gt;bs, *(job.video_param.begin()), *this);
+            zalphaStrm-&gt;Init (0);
+            estreams.push_back(zalphaStrm);
+            vstreams.push_back(zalphaStrm);
+            //++vidparm;
+        }
+#endif		
+        }
+    }
+}
+
+
+/******************************************************************* 
+	Find the timecode corresponding to given position in the system stream
+   (assuming the SCR starts at 0 at the beginning of the stream 
<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">+ at param</A> bytepos byte position in the stream
<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">+ at param</A> ts returns the number of clockticks the bytepos is from the file start    
+****************************************************************** */
+
+void Multiplexor::ByteposTimecode(bitcount_t bytepos, clockticks &amp;ts)
+{
+	ts = (bytepos*CLOCKS)/static_cast&lt;bitcount_t&gt;(dmux_rate);
+}
+
+
+/**********
+ *
+ * NextPosAndSCR - Update nominal (may be &gt;= actual) byte count
+ * and SCR to next output sector.
+ *
+ ********/
+
+void Multiplexor::NextPosAndSCR()
+{
+	bytes_output += sector_transport_size;
+	ByteposTimecode( bytes_output, current_SCR );
+    if (start_of_new_pack)
+    {
+        psstrm-&gt;CreatePack (&amp;pack_header, current_SCR, mux_rate);
+        pack_header_ptr = &amp;pack_header;
+        if( include_sys_header )
+            sys_header_ptr = &amp;sys_header;
+        else
+            sys_header_ptr = NULL;
+        
+    }
+    else
+        pack_header_ptr = NULL;
+}
+
+
+/**********
+ *
+ * SetPosAndSCR - Update nominal (may be &gt;= actual) byte count
+ * and SCR to next output sector.
+ * @param bytepos byte position in the stream
+ ********/
+
+void Multiplexor::SetPosAndSCR( bitcount_t bytepos )
+{
+	bytes_output = bytepos;
+	ByteposTimecode( bytes_output, current_SCR );
+    if (start_of_new_pack)
+    {
+        psstrm-&gt;CreatePack (&amp;pack_header, current_SCR, mux_rate);
+        pack_header_ptr = &amp;pack_header;
+        if( include_sys_header )
+            sys_header_ptr = &amp;sys_header;
+        else
+            sys_header_ptr = NULL;
+        
+    }
+    else
+        pack_header_ptr = NULL;
+}
+
+/* 
+   Stream syntax parameters.
+*/
+		
+	
+
+
+
+typedef enum { start_segment, mid_segment, 
+			   runout_segment }
+segment_state;
+
+
+/**
+ * Compute the number of run-in sectors needed to fill up the buffers to
+ * suit the type of stream being muxed.
+ *
+ * For stills we have to ensure an entire buffer is loaded as we only
+ * ever process one frame at a time.
+ * @returns the number of run-in sectors needed to fill up the buffers to suit the type of stream being muxed.
+ */
+
+unsigned int Multiplexor::RunInSectors()
+{
+	std::vector&lt;ElementaryStream *&gt;::iterator str;
+	unsigned int sectors_delay = 1;
+
+	for( str = vstreams.begin(); str &lt; vstreams.end(); ++str )
+	{
+
+		if( MPEG_STILLS_FORMAT( mux_format ) )
+		{
+			sectors_delay += static_cast&lt;unsigned int&gt;(1.02*(*str)-&gt;BufferSize()) / sector_size+2;
+		}
+		else if( vbr )
+			sectors_delay += 3*(*str)-&gt;BufferSize() / ( 4 * sector_size );
+		else
+			sectors_delay += 5 *(*str)-&gt;BufferSize() / ( 6 * sector_size );
+	}
+    sectors_delay += astreams.size();
+	return sectors_delay;
+}
+
+/**********************************************************************
+ *
+ *  Initializes the output stream proper. Traverses the input files
+ *  and calculates their payloads.  Estimates the multiplex
+ *  rate. Estimates the necessary stream delay for the different
+ *  substreams.
+ *
+ *********************************************************************/
+
+
+void Multiplexor::Init()
+{
+	std::vector&lt;ElementaryStream *&gt;::iterator str;
+	clockticks delay;
+	unsigned int sectors_delay;
+
+	Pack_struc 			dummy_pack;
+	Sys_header_struc 	dummy_sys_header;	
+	Sys_header_struc *sys_hdr;
+	unsigned int nominal_rate_sum;
+	
+	mjpeg_info(&quot;SYSTEMS/PROGRAM stream:&quot;);
+	psstrm-&gt;Open();
+	
+    /* These are used to make (conservative) decisions
+	   about whether a packet should fit into the recieve buffers... 
+	   Audio packets always have PTS fields, video packets needn'.	
+	   TODO: Really this should be encapsulated in Elementary stream...?
+	*/ 
+	psstrm-&gt;CreatePack (&amp;dummy_pack, 0, mux_rate);
+	if( always_sys_header_in_pack )
+	{
+        vector&lt;MuxStream *&gt; muxstreams;
+        AppendMuxStreamsOf( estreams, muxstreams );
+		psstrm-&gt;CreateSysHeader (&amp;dummy_sys_header, mux_rate,  
+								 !vbr, 1,  true, true, muxstreams);
+		sys_hdr = &amp;dummy_sys_header;
+	}
+	else
+		sys_hdr = NULL;
+	
+	nominal_rate_sum = 0;
+	for( str = estreams.begin(); str &lt; estreams.end(); ++str )
+	{
+		switch( (*str)-&gt;Kind() )
+		{
+		case ElementaryStream::audio :
+			(*str)-&gt;SetMaxPacketData( 
+				psstrm-&gt;PacketPayload( **str, NULL, NULL, 
+									   false, true, false ) 
+				); 
+			(*str)-&gt;SetMinPacketData(
+				psstrm-&gt;PacketPayload( **str, sys_hdr, &amp;dummy_pack, 
+									   always_buffers_in_audio, true, false )
+				);
+				
+			break;
+		case ElementaryStream::video :
+			(*str)-&gt;SetMaxPacketData( 
+				psstrm-&gt;PacketPayload( **str, NULL, NULL, 
+									   false, false, false ) 
+				); 
+			(*str)-&gt;SetMinPacketData( 
+				psstrm-&gt;PacketPayload( **str, sys_hdr, &amp;dummy_pack, 
+									   always_buffers_in_video, true, true )
+				);
+			break;
+		default :
+			mjpeg_error_exit1(&quot;INTERNAL: Only audio and video payload calculations implemented!&quot;);
+			
+		}
+
+		if( (*str)-&gt;NominalBitRate() == 0 &amp;&amp; data_rate == 0)
+			mjpeg_error_exit1( &quot;Variable bit-rate stream present: output stream (max) data-rate *must* be specified!&quot;);
+		nominal_rate_sum += (*str)-&gt;NominalBitRate();
+	}
+		
+	/* Attempt to guess a sensible mux rate for the given video and *
+	 audio estreams. This is a rough and ready guess for MPEG-1 like
+	 formats. */
+	   
+	 
+	dmux_rate = static_cast&lt;int&gt;(1.0205 * nominal_rate_sum);
+	dmux_rate = (dmux_rate/50 + 25)*50/8;
+	
+	mjpeg_info (&quot;rough-guess multiplexed stream data rate    : %07d&quot;, dmux_rate*8 );
+	if( data_rate != 0 )
+		mjpeg_info (&quot;target data-rate specified               : %7d&quot;, data_rate*8 );
+
+	if( data_rate == 0 )
+	{
+		mjpeg_info( &quot;Setting best-guess data rate.&quot;);
+	}
+	else if ( data_rate &gt;= dmux_rate)
+	{
+		mjpeg_info( &quot;Setting specified specified data rate: %7d&quot;, data_rate*8 );
+		dmux_rate = data_rate;
+	}
+	else if ( data_rate &lt; dmux_rate )
+	{
+		mjpeg_warn( &quot;Target data rate lower than computed requirement!&quot;);
+		mjpeg_warn( &quot;N.b. a 20%% or so discrepancy in variable bit-rate&quot;);
+		mjpeg_warn( &quot;streams is common and harmless provided no time-outs will occur&quot;); 
+		dmux_rate = data_rate;
+	}
+
+	mux_rate = dmux_rate/50;
+
+
+	//
+	// Now that all mux parameters are set we can trigger parsing
+	// of actual input stream data and calculation of associated 
+	// PTS/DTS by causing the read of the first AU's...
+	//
+	for( str = estreams.begin(); str &lt; estreams.end(); ++str )
+	{
+		(*str)-&gt;NextAU();
+	}
+
+    //
+    // Now that we have both output and input streams initialised and
+    // data-rates set we can make a decent job of setting the maximum
+    // STD buffer delay in video streams.
+    //
+   
+    for( str = vstreams.begin(); str &lt; vstreams.end(); ++str )
+    {
+        static_cast&lt;VideoStream*&gt;(*str)-&gt;SetMaxStdBufferDelay( dmux_rate );
+    }				 
+
+	/* To avoid Buffer underflow, the DTS of the first video and audio AU's
+	   must be offset sufficiently	forward of the SCR to allow the buffer 
+	   time to fill before decoding starts. Calculate the necessary delays...
+	*/
+
+	sectors_delay = RunInSectors();
+
+	ByteposTimecode( 
+		static_cast&lt;bitcount_t&gt;(sectors_delay*sector_transport_size),
+		delay );
+    video_delay += delay;
+    audio_delay += delay;
+
+    /* 
+     * The PTS of the first frame may be different from its DTS.
+     * Thus to hit perfect A/V sync we need to delay audio by the difference
+     * PTS-DTS.
+     *
+     */
+    
+    if(  vstreams.size() != 0 )
+    {
+        audio_delay += vstreams[0]-&gt;BasePTS()-vstreams[0]-&gt;BaseDTS();
+    }
+
+	mjpeg_info( &quot;Run-in Sectors = %d Video delay = %lld Audio delay = %lld&quot;,
+				sectors_delay,
+				 video_delay / 300,
+				 audio_delay / 300 );
+
+    if( max_PTS != 0 )
+        
+        mjpeg_info( &quot;Multiplexed stream will be ended at %lld seconds playback time\n&quot;, max_PTS/CLOCKS );
+
+}
+
+/**
+   Prints the current status of the substreams. 
+   @param level the desired log level 
+ */
+void Multiplexor::MuxStatus(log_level_t level)
+{
+	std::vector&lt;ElementaryStream *&gt;::iterator str;
+	for( str = estreams.begin(); str &lt; estreams.end(); ++str )
+	{
+		switch( (*str)-&gt;Kind()  )
+		{
+		case ElementaryStream::video :
+			mjpeg_log( level,
+					   &quot;Video %02x: buf=%7d frame=%06d sector=%08d&quot;,
+					   (*str)-&gt;stream_id,
+					   (*str)-&gt;BufferSize()-(*str)-&gt;bufmodel.Space(),
+					   (*str)-&gt;DecodeOrder(),
+					   (*str)-&gt;nsec
+				);
+			break;
+		case ElementaryStream::audio :
+			mjpeg_log( level,
+					   &quot;Audio %02x: buf=%7d frame=%06d sector=%08d&quot;,
+					   (*str)-&gt;stream_id,
+					   (*str)-&gt;BufferSize()-(*str)-&gt;bufmodel.Space(),
+					   (*str)-&gt;DecodeOrder(),
+					   (*str)-&gt;nsec
+				);
+			break;
+		default :
+			mjpeg_log( level,
+					   &quot;Other %02x: buf=%7d sector=%08d&quot;,
+					   (*str)-&gt;stream_id,
+					   (*str)-&gt;bufmodel.Space(),
+					   (*str)-&gt;nsec
+				);
+			break;
+		}
+	}
+	if( !vbr )
+		mjpeg_log( level,
+				   &quot;Padding : sector=%08d&quot;,
+				   pstrm.nsec
+			);
+	
+	
+}
+
+
+/**
+   Append input substreams to the output multiplex stream.
+ */
+void Multiplexor::AppendMuxStreamsOf( vector&lt;ElementaryStream *&gt; &amp;elem, 
+                                       vector&lt;MuxStream *&gt; &amp;mux )
+{
+	std::vector&lt;ElementaryStream *&gt;::iterator str;
+    for( str = elem.begin(); str &lt; elem.end(); ++str )
+    {
+        mux.push_back( static_cast&lt;MuxStream *&gt;( *str ) );
+    }
+}
+
+/******************************************************************
+    Program start-up packets.  Generate any irregular packets						
+needed at the start of the stream...
+	Note: *must* leave a sensible in-stream system header in
+	sys_header.
+	TODO: get rid of this grotty sys_header global.
+******************************************************************/
+void Multiplexor::OutputPrefix( )
+{
+    vector&lt;MuxStream *&gt; vmux,amux,emux;
+    AppendMuxStreamsOf( vstreams, vmux );
+    AppendMuxStreamsOf( astreams, amux );
+    AppendMuxStreamsOf( estreams, emux );
+
+	/* Deal with transport padding */
+	SetPosAndSCR( bytes_output + 
+				  transport_prefix_sectors*sector_transport_size );
+	
+	/* VCD: Two padding packets with video and audio system headers */
+
+	switch (mux_format)
+	{
+	case MPEG_FORMAT_VCD :
+	case MPEG_FORMAT_VCD_NSR :
+
+		/* Annoyingly VCD generates seperate system headers for
+		   audio and video ... DOH... */
+		if( astreams.size() &gt; 1 || vstreams.size() &gt; 1 ||
+			astreams.size() + vstreams.size() != estreams.size() )
+		{
+				mjpeg_error_exit1(&quot;VCD man only have max. 1 audio and 1 video stream&quot;);
+		}
+
+        if( vstreams.size() &gt; 0 )
+        {
+		/* First packet carries video-info-only sys_header */
+		psstrm-&gt;CreateSysHeader (&amp;sys_header, mux_rate, 
+								 false, true, 
+								 true, true, vmux  );
+		sys_header_ptr = &amp;sys_header;
+		pack_header_ptr = &amp;pack_header;
+	  	OutputPadding( false);		
+        }
+
+        if( astreams.size() &gt; 0 )
+        {
+
+            /* Second packet carries audio-info-only sys_header */
+            psstrm-&gt;CreateSysHeader (&amp;sys_header, mux_rate,  
+                                     false, true, 
+                                     true, true, amux );
+            sys_header_ptr = &amp;sys_header;
+            pack_header_ptr = &amp;pack_header;
+            OutputPadding( true );
+        }
+        break;
+		
+	case MPEG_FORMAT_SVCD :
+	case MPEG_FORMAT_SVCD_NSR :
+		/* First packet carries sys_header */
+		psstrm-&gt;CreateSysHeader (&amp;sys_header, mux_rate,  !vbr, true, 
+                                 true, true, emux );
+		sys_header_ptr = &amp;sys_header;
+		pack_header_ptr = &amp;pack_header;
+	  	OutputPadding(false);
+        break;
+
+	case MPEG_FORMAT_VCD_STILL :
+		/* First packet carries small-still sys_header */
+		/* TODO No support mixed-mode stills sequences... */
+		psstrm-&gt;CreateSysHeader (&amp;sys_header, mux_rate, false, false,
+								 true, true, emux );
+		sys_header_ptr = &amp;sys_header;
+		pack_header_ptr = &amp;pack_header;
+		OutputPadding(  false);	
+        break;
+			
+	case MPEG_FORMAT_SVCD_STILL :
+		/* TODO: Video only at present */
+		/* First packet carries video-info-only sys_header */
+		psstrm-&gt;CreateSysHeader (&amp;sys_header, mux_rate, 
+								 false, true, 
+								 true, true, vmux );
+		sys_header_ptr = &amp;sys_header;
+		pack_header_ptr = &amp;pack_header;
+	  	OutputPadding( false);		
+		break;
+
+    case MPEG_FORMAT_DVD_NAV :
+        /* A DVD System header is a weird thing.  We seem to need to
+           include buffer info about streams 0xb8, 0xb9, 0xbd, 0xbf even if
+           they're not physically present but the buffers for the actual
+           video streams aren't included.  
+        */
+    {
+        // MANY DVD streams appear not to include system headers
+        // and some tools have weak parsers that can't handle all
+        // the possible variations. Soooo probably best not to generate
+        // them
+        DummyMuxStream dvd_0xb9_strm_dummy( 0xb9, 1, 232*1024 );
+        DummyMuxStream dvd_0xb8_strm_dummy( 0xb8, 0, 4096 );
+        DummyMuxStream dvd_0xbf_strm_dummy( 0xbf, 1, 2048 );
+        vector&lt;MuxStream *&gt; dvdmux;
+		std::vector&lt;MuxStream *&gt;::iterator muxstr;
+        dvdmux.push_back( &amp;dvd_0xb9_strm_dummy );
+        dvdmux.push_back( &amp;dvd_0xb8_strm_dummy );
+        unsigned int max_priv1_buffer = 58*1024;
+        for( muxstr = amux.begin(); muxstr &lt; amux.end(); ++muxstr )
+        {
+            // We mux *many* substreams on PRIVATE_STR_1
+            // we set the system header buffer size to the maximum
+            // of all those we find
+            if( (*muxstr)-&gt;stream_id == PRIVATE_STR_1 ) 
+            {
+                if( (*muxstr)-&gt;BufferSize() &gt; max_priv1_buffer )
+                    max_priv1_buffer = (*muxstr)-&gt;BufferSize();
+            }
+            // Now the *sane* thing to do if MPEG audio is present would be
+            // record this in the system header.  However, dvdauthor lacks
+            // a header parser and barfs if the system headers aren't exactly
+            // 18 bytes.  Soooo we simply skip them for now...
+            // TOOD: Add back in when dvdauthor can parse system headers
+            //else
+            //    dvdmux.push_back( *muxstr );
+        }
+        
+        DummyMuxStream dvd_priv1_strm_dummy( PRIVATE_STR_1, 1, 
+                                             max_priv1_buffer );
+        dvdmux.push_back( &amp;dvd_priv1_strm_dummy );
+            
+        dvdmux.push_back( &amp;dvd_0xbf_strm_dummy );
+        psstrm-&gt;CreateSysHeader (&amp;sys_header, mux_rate, !vbr, false, 
+                                 true, true, dvdmux );
+        sys_header_ptr = &amp;sys_header;
+        pack_header_ptr = &amp;pack_header;
+        /* It is then followed up by a pair of PRIVATE_STR_2 packets which
+            we keep empty 'cos we don't know what goes there...
+        */
+    }
+    break;
+
+    default :
+        /* Create the in-stream header in case it is needed */
+        psstrm-&gt;CreateSysHeader (&amp;sys_header, mux_rate, !vbr, false, 
+                                 true, true, emux );
+
+
+	}
+
+
+
+}
+
+
+
+/******************************************************************
+    Program shutdown packets.  Generate any irregular packets
+    needed at the end of the stream...
+   
+******************************************************************/
+
+void Multiplexor::OutputSuffix()
+{
+	psstrm-&gt;CreatePack (&amp;pack_header, current_SCR, mux_rate);
+	psstrm-&gt;CreateSector (&amp;pack_header, NULL,
+						  0,
+						  pstrm, 
+						  false,
+						  true,
+						  0, 0,
+						  TIMESTAMPBITS_NO );
+}
+
+/******************************************************************
+
+	Main multiplex iteration.
+	Opens and closes all needed files and manages the correct
+	call od the respective Video- and Audio- packet routines.
+	The basic multiplexing is done here. Buffer capacity and 
+	Timestamp checking is also done here, decision is taken
+	wether we should genereate a Video-, Audio- or Padding-
+	packet.
+******************************************************************/
+
+
+	
+void Multiplexor::Multiplex()
+
+{
+	segment_state seg_state;
+	std::vector&lt;bool&gt; completed;
+	std::vector&lt;bool&gt;::iterator pcomp;
+	std::vector&lt;ElementaryStream *&gt;::iterator str;
+
+	unsigned int packets_left_in_pack = 0; /* Suppress warning */
+	bool padding_packet;
+	bool video_first = true;
+
+	Init( );
+
+	unsigned int i;
+    for(i = 0; i &lt; estreams.size() ; ++i )
+		completed.push_back(false);
+
+    
+	/*  Let's try to read in unit after unit and to write it out into
+		the outputstream. The only difficulty herein lies into the
+		buffer management, and into the fact the the actual access
+		unit *has* to arrive in time, that means the whole unit
+		(better yet, packet data), has to arrive before arrival of
+		DTS. If both buffers are full we'll generate a padding packet
+	  
+		Of course, when we start we're starting a new segment with no
+		bytes output...
+	*/
+
+	ByteposTimecode( sector_transport_size, ticks_per_sector );
+	seg_state = start_segment;
+	running_out = false;
+	for(;;)
+	{
+		bool completion = true;
+
+		for( str = estreams.begin(); str &lt; estreams.end() ; ++str )
+			completion &amp;= (*str)-&gt;MuxCompleted();
+		if( completion )
+			break;
+
+		/* A little state-machine for handling the transition from one
+		   segment to the next 
+		*/
+		bool runout_incomplete;
+		VideoStream *master;
+		switch( seg_state )
+		{
+
+			/* Audio and slave video access units at end of segment.
+			   If there are any audio AU's whose PTS implies they
+			   should be played *before* the video AU starting the
+			   next segement is presented we mux them out.  Once
+			   they're gone we've finished this segment so we write
+			   the suffix switch file, and start muxing a new segment.
+			*/
+		case runout_segment :
+			runout_incomplete = false;
+			for( str = estreams.begin(); str &lt; estreams.end(); ++str )
+			{
+				runout_incomplete |= !(*str)-&gt;RunOutComplete();
+			}
+
+			if( runout_incomplete )
+				break;
+
+			/* Otherwise we write the stream suffix and start a new
+			   stream file */
+			OutputSuffix();
+			psstrm-&gt;NextSegment();
+
+			running_out = false;
+			seg_state = start_segment;
+
+			/* Starting a new segment.
+			   We send the segment prefix, video and audio reciever
+			   buffers are assumed to start empty.  We reset the segment
+			   length count and hence the SCR.
+			   
+			*/
+
+		case start_segment :
+			mjpeg_info( &quot;New sequence commences...&quot; );
+			SetPosAndSCR(0);
+			MuxStatus( LOG_INFO );
+
+			for( str = estreams.begin(); str &lt; estreams.end(); ++str )
+			{
+				(*str)-&gt;AllDemuxed();
+			}
+
+			packets_left_in_pack = packets_per_pack;
+            start_of_new_pack = true;
+			include_sys_header = sys_header_in_pack1;
+			buffers_in_video = always_buffers_in_video;
+			video_first = seg_starts_with_video &amp; (vstreams.size() &gt; 0);
+			OutputPrefix();
+
+			/* Set the offset applied to the raw PTS/DTS of AU's to
+               make the DTS of the first AU in the master (video) stream
+               precisely the video delay plus whatever time we wasted in
+               the sequence pre-amble.
+
+               The DTS of the remaining streams are set so that
+               (modulo the relevant delay offset) they maintain the
+               same relative timing to the master stream.
+               
+			*/
+
+            clockticks ZeroSCR;
+
+            if( vstreams.size() != 0 )
+                ZeroSCR = vstreams[0]-&gt;BaseDTS();
+            else
+                ZeroSCR = estreams[0]-&gt;BaseDTS();
+
+			for( str = vstreams.begin(); str &lt; vstreams.end(); ++str )
+				(*str)-&gt;SetSyncOffset(video_delay + current_SCR - ZeroSCR );
+			for( str = astreams.begin(); str &lt; astreams.end(); ++str )
+				(*str)-&gt;SetSyncOffset(audio_delay + current_SCR - ZeroSCR );
+			pstrm.nsec = 0;
+			for( str = estreams.begin(); str &lt; estreams.end(); ++str )
+				(*str)-&gt;nsec = 0;
+			seg_state = mid_segment;
+			break;
+
+		case mid_segment :
+			/* Once we exceed our file size limit, we need to
+			   start a new file soon.  If we want a single stream we
+			   simply switch.
+				
+			   Otherwise we're in the last gop of the current segment
+			   (and need to start running streams out ready for a
+			   clean continuation in the next segment).
+			   TODO: runout_PTS really needs to be expressed in
+			   sync delay adjusted units...
+			*/
+			
+			master = 
+				vstreams.size() &gt; 0 ? 
+				static_cast&lt;VideoStream*&gt;(vstreams[0]) : 0 ;
+			if( psstrm-&gt;SegmentLimReached() )
+			{
+				if( split_at_seq_end )
+                    mjpeg_warn( &quot;File size exceeded before split-point in video stream&quot; );
+                mjpeg_info( &quot;Starting new output file...&quot;);
+                psstrm-&gt;NextSegment();
+			}
+			else if( master != 0 &amp;&amp; master-&gt;SeqEndRunOut() )
+			{
+                const AUnit *nextIframe = master-&gt;NextIFrame();
+				if(  split_at_seq_end &amp;&amp; nextIframe != 0)
+				{
+					runout_PTS = master-&gt;RequiredPTS(nextIframe);
+                    mjpeg_info( &quot;Sequence end marker! Running out...&quot;);
+                    mjpeg_info(&quot;Run out PTS limit to AU %d %lld SCR=%lld&quot;, 
+                               nextIframe-&gt;dorder,
+                               runout_PTS/300, 
+                               current_SCR/300 );
+                    MuxStatus( LOG_INFO );
+					running_out = true;
+					seg_state = runout_segment;
+				}
+                else
+                {
+                    mjpeg_warn( &quot;Sequence end without following I-frame!&quot; );
+                }
+			}
+			break;
+			
+		}
+
+		padding_packet = false;
+		start_of_new_pack = (packets_left_in_pack == packets_per_pack); 
+        
+		for( str = estreams.begin(); str &lt; estreams.end(); ++str )
+		{
+			(*str)-&gt;DemuxedTo(current_SCR);
+		}
+
+
+		
+		//
+		// Find the ready-to-mux stream with the most urgent DTS
+		//
+		ElementaryStream *despatch = 0;
+		clockticks earliest = 0;
+		for( str = estreams.begin(); str &lt; estreams.end(); ++str )
+		{
+#ifdef STREAM_LOGGING
+            mjpeg_debug(&quot;%02x: SCR=%lld (%.3f) mux=%d %d reqDTS=%lld &quot;, 
+                        (*str)-&gt;stream_id,
+                        current_SCR,
+                        static_cast&lt;double&gt;(current_SCR) /(90.0*300.0),
+                        (*str)-&gt;MuxPossible(current_SCR),
+                        (*str)-&gt;BufferSize()-(*str)-&gt;bufmodel.Space(),
+                        (*str)-&gt;RequiredDTS()/300
+                        
+				);
+#endif
+			if( (*str)-&gt;MuxPossible(current_SCR) &amp;&amp; 
+				( !video_first || (*str)-&gt;Kind() == ElementaryStream::video )
+				 )
+			{
+				if( despatch == 0 || earliest &gt; (*str)-&gt;RequiredDTS() )
+				{
+					despatch = *str;
+					earliest = (*str)-&gt;RequiredDTS();
+				}
+			}
+		}
+		
+		if( underrun_ignore &gt; 0 )
+			--underrun_ignore;
+
+		if( despatch )
+		{
+			despatch-&gt;BufferAndOutputSector();
+			video_first = false;
+			if( current_SCR &gt;=  earliest &amp;&amp; underrun_ignore == 0)
+			{
+				mjpeg_warn( &quot;Stream %02x: data will arrive too late sent(SCR)=%lld required(DTS)=%lld&quot;, 
+							despatch-&gt;stream_id, 
+							current_SCR/300, 
+							earliest/300 );
+				MuxStatus( LOG_WARN );
+				// Give the stream a chance to recover
+				underrun_ignore = 300;
+				++underruns;
+				if( underruns &gt; 10  )
+				{
+					//mjpeg_error_exit1(&quot;Too many frame drops -exiting&quot; );
+				}
+			}
+            if( despatch-&gt;nsec &gt; 50 &amp;&amp;
+                despatch-&gt;Lookahead( ) != 0 &amp;&amp; ! running_out)
+                despatch-&gt;UpdateBufferMinMax();
+			padding_packet = false;
+
+		}
+		else
+		{
+            //
+            // If we got here no stream could be muxed out.
+            // We therefore generate padding packets if necessary
+            // usually this is because reciever buffers are likely to be
+            // full.  
+            //
+            if( vbr )
+            {
+                //
+                // VBR: For efficiency we bump SCR up to five times or
+                // until it looks like buffer status will change
+                NextPosAndSCR();
+                clockticks next_change = static_cast&lt;clockticks&gt;(0);
+                for( str = estreams.begin(); str &lt; estreams.end(); ++str )
+                {
+                    clockticks change_time = (*str)-&gt;bufmodel.NextChange();
+                    if( next_change == 0 || change_time &lt; next_change )
+                    {
+                        next_change = change_time;
+                    }
+                }
+
+                unsigned int bumps = 5;
+                while( bumps &gt; 0 
+                       &amp;&amp; next_change &gt; current_SCR + ticks_per_sector)
+                {
+                    NextPosAndSCR();
+                    --bumps;
+                }
+                            
+            }
+            else
+            {
+                // Just output a padding packet
+                OutputPadding (	false);
+            }
+			padding_packet = true;
+		}
+
+		/* Update the counter for pack packets.  VBR is a tricky 
+		   case as here padding packets are &quot;virtual&quot; */
+		
+		if( ! (vbr &amp;&amp; padding_packet) )
+		{
+			--packets_left_in_pack;
+			if (packets_left_in_pack == 0) 
+				packets_left_in_pack = packets_per_pack;
+		}
+
+		MuxStatus( LOG_DEBUG );
+		/* Unless sys headers are always required we turn them off after the first
+		   packet has been generated */
+		include_sys_header = always_sys_header_in_pack;
+
+		pcomp = completed.begin();
+		str = estreams.begin();
+		while( str &lt; estreams.end() )
+		{
+			if( !(*pcomp) &amp;&amp; (*str)-&gt;MuxCompleted() )
+			{
+				mjpeg_info( &quot;STREAM %02x completed @ frame %d.&quot;, (*str)-&gt;stream_id, (*str)-&gt;DecodeOrder() );
+				MuxStatus( LOG_DEBUG );
+				(*pcomp) = true;
+			}
+			++str;
+			++pcomp;
+		}
+	}
+	// Tidy up
+	
+	OutputSuffix( );
+	psstrm-&gt;Close();
+	mjpeg_info( &quot;Multiplex completion at SCR=%lld.&quot;, current_SCR/300);
+	MuxStatus( LOG_INFO );
+	for( str = estreams.begin(); str &lt; estreams.end(); ++str )
+	{
+		(*str)-&gt;Close();
+        if( (*str)-&gt;nsec &lt;= 50 )
+            mjpeg_info( &quot;BUFFERING stream too short for useful statistics&quot;);
+        else
+            mjpeg_info( &quot;BUFFERING min %d Buf max %d&quot;,
+                        (*str)-&gt;BufferMin(),
+                        (*str)-&gt;BufferMax() 
+                );
+	}
+
+    if( underruns&gt; 0 )
+	{
+		mjpeg_info( &quot;MUX STATUS: Frame data under-runs detected!&quot; ); // MEANX was exit
+	}
+	else
+	{
+		mjpeg_info( &quot;MUX STATUS: no under-runs detected.&quot;);
+	}
+}
+
+/**
+   Calculate the packet payload of the output stream at a certain timestamp. 
<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">+ at param</A> strm the output stream
<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">+ at param</A> buffers the number of buffers
<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">+ at param</A> PTSstamp presentation time stamp
<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">+ at param</A> DTSstamp decoding time stamp
+ */
+unsigned int Multiplexor::PacketPayload( MuxStream &amp;strm, bool buffers, 
+										  bool PTSstamp, bool DTSstamp )
+{
+	return psstrm-&gt;PacketPayload( strm, sys_header_ptr, pack_header_ptr, 
+								  buffers, 
+								  PTSstamp, DTSstamp)
+        - strm.StreamHeaderSize();
+}
+
+/***************************************************
+
+  WritePacket - Write out a normal packet carrying data from one of
+              the elementary stream being muxed.
<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">+ at param</A> max_packet_data_size the maximum packet data size allowed
<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">+ at param</A> strm output mux stream
<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">+ at param</A> buffers ?
<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">+ at param</A> PTSstamp presentation time stamp of the packet
<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">+ at param</A> DTSstamp decoding time stamp of the packet
<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">+ at param</A> timestamps ?
<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">+ at param</A> returns the written bytes/packets (?)
+***************************************************/
+
+unsigned int 
+Multiplexor::WritePacket( unsigned int     max_packet_data_size,
+                           MuxStream        &amp;strm,
+                           bool 	 buffers,
+                           clockticks   	 PTS,
+                           clockticks   	 DTS,
+                           uint8_t 	 timestamps
+	)
+{
+    unsigned int written =
+        psstrm-&gt;CreateSector ( pack_header_ptr,
+                               sys_header_ptr,
+                               max_packet_data_size,
+                               strm,
+                               buffers,
+                               false,
+                               PTS,
+                               DTS,
+                               timestamps );
+    NextPosAndSCR();
+    return written;
+}
+
+/***************************************************
+ *
+ * WriteRawSector - Write out a packet carrying data for
+ *                    a control packet with irregular content.
<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">+ at param</A> rawsector data for the raw sector
<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">+ at param</A> length length of the raw sector
+ ***************************************************/
+
+void
+Multiplexor::WriteRawSector(  uint8_t *rawsector,
+                               unsigned int     length
+	)
+{
+    //
+    // Writing raw sectors when packs stretch over multiple sectors
+    // is a recipe for disaster!
+    //
+    assert( packets_per_pack == 1 );
+	psstrm-&gt;RawWrite( rawsector, length );
+	NextPosAndSCR();
+
+}
+
+
+
+/******************************************************************
+	OutputPadding
+
+	generates Pack/Sys Header/Packet information for a 
+	padding stream and saves the sector
+
+	We have to pass in a special flag to cope with appalling mess VCD
+	makes of audio packets (the last 20 bytes being dropped thing) 0 =
+	Fill the packet completetely.  This include &quot;audio packets&quot; that
+    include no actual audio, only a system header and padding.
<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">+ at param</A> vcd_audio_pad flag for VCD audio padding
+******************************************************************/
+
+
+void Multiplexor::OutputPadding (bool vcd_audio_pad)
+
+{
+    if( vcd_audio_pad )
+        psstrm-&gt;CreateSector ( pack_header_ptr, sys_header_ptr,
+                               0,
+                               vcdapstrm,
+                               false, false,
+                               0, 0,
+                               TIMESTAMPBITS_NO );
+    else
+        psstrm-&gt;CreateSector ( pack_header_ptr, sys_header_ptr,
+                               0,
+                               pstrm,
+                               false, false,
+                               0, 0,
+                               TIMESTAMPBITS_NO );
+    ++pstrm.nsec;
+	NextPosAndSCR();
+
+}
+
+ /******************************************************************
+ *	OutputGOPControlSector
+ *  DVD System headers are carried in peculiar sectors carrying 2
+ *  PrivateStream2 packets.   We're sticking 0's in the packets
+ *  as we have no idea what's supposed to be in there.
+ *
+ * Thanks to Brent Byeler who worked out this work-around.
+ *
+ ******************************************************************/
+
+void Multiplexor::OutputDVDPriv2 (	)
+{
+    uint8_t *packet_size_field;
+    uint8_t *index;
+    uint8_t *sector_buf = new uint8_t[sector_size];
+    unsigned int tozero;
+    assert( sector_size == 2048 );
+    PS_Stream::BufferSectorHeader( sector_buf,
+                                pack_header_ptr,
+                                &amp;sys_header,
+                                index );
+    PS_Stream::BufferPacketHeader( index,
+                                   PRIVATE_STR_2,
+                                   2,      // MPEG 2
+                                   false,  // No buffers
+                                   0,
+                                   0,
+                                   0,      // No timestamps
+                                   0,
+                                   TIMESTAMPBITS_NO,
+                                   0, // Natural PES header length
+                                   packet_size_field,
+                                   index );
+    tozero = sector_buf+1024-index;
+    memset( index, 0, tozero);
+    index += tozero;
+    PS_Stream::BufferPacketSize( packet_size_field, index );    
+
+    PS_Stream::BufferPacketHeader( index,
+                                   PRIVATE_STR_2,
+                                   2,      // MPEG 2
+                                   false,  // No buffers
+                                   0,
+                                   0,
+                                   0,      // No timestamps
+                                   0,
+                                   TIMESTAMPBITS_NO,
+                                   0, // Natural PES header length
+                                   packet_size_field,
+                                   index );
+    tozero = sector_buf+2048-index;
+    memset( index, 0, tozero );
+    index += tozero;
+    PS_Stream::BufferPacketSize( packet_size_field, index );
+
+    WriteRawSector( sector_buf, sector_size );
+
+	delete [] sector_buf;
+}
+
+
+/* 
+ * Local variables:
+ *  c-file-style: &quot;stroustrup&quot;
+ *  tab-width: 4
+ *  indent-tabs-mode: nil
+ * End:
+ */

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/multiplexor.hpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/multiplexor.hpp	2009-09-04 15:59:41 UTC (rev 5319)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/multiplexor.hpp	2009-09-05 08:19:09 UTC (rev 5320)
@@ -0,0 +1,155 @@
+
+#ifndef __OUTPUTSTREAM_H__
+#define __OUTPUTSTREAM_H__
+
+#include &lt;stdio.h&gt;
+#include &quot;mjpeg_types.h&quot;
+#include &quot;interact.hpp&quot;
+#include &quot;inputstrm.hpp&quot;
+#include &quot;padstrm.hpp&quot;
+#include &quot;systems.hpp&quot;
+
+
+class Multiplexor
+{
+public:
+	Multiplexor(MultiplexJob &amp;job, OutputStream &amp;output);
+	void Multiplex ();
+
+
+	void ByteposTimecode( bitcount_t bytepos, clockticks &amp;ts );
+	
+	inline Sys_header_struc *SystemHeader() { return &amp;sys_header; }
+
+	unsigned int PacketPayload(	MuxStream &amp;strm,
+								bool buffers, bool PTSstamp, bool DTSstamp );
+	unsigned int WritePacket( unsigned int     max_packet_data_size,
+							  MuxStream        &amp;strm,
+							  bool 	 buffers,
+							  clockticks   	 PTS,
+							  clockticks   	 DTS,
+							  uint8_t 	 timestamps
+		);
+
+	bool AfterMaxPTS(clockticks &amp;timestamp) 
+		{ return max_PTS != 0 &amp;&amp; timestamp &gt;= max_PTS; }
+
+
+	/* Special &quot;unusual&quot; sector types needed for particular formats 
+	 */
+	  
+	void OutputDVDPriv2 ();
+
+	/* Syntax control parameters, public becaus they're partly referenced
+	   by the input stream objects.
+	 */
+	
+	bool always_sys_header_in_pack;
+	bool dtspts_for_all_vau;
+	bool sys_header_in_pack1;
+	bool buffers_in_video;
+	bool always_buffers_in_video;	
+	bool buffers_in_audio;
+	bool always_buffers_in_audio;
+	bool sector_align_iframeAUs;
+	bool split_at_seq_end;
+	bool seg_starts_with_video;
+	bool timestamp_iframe_only;
+	bool video_buffers_iframe_only;
+	unsigned int audio_buffer_size;
+	unsigned int packets_per_pack;
+	unsigned int min_pes_header_len;
+	clockticks max_PTS;
+
+	int mpeg;
+	int data_rate;
+	int mux_format;
+	off_t max_segment_size;
+
+	Workarounds workarounds;
+
+/* In some situations the system/PES packets are embedded with
+   external transport data which has to be taken into account for SCR
+   calculations to be correct.  E.g. VCD streams. Where each 2324 byte
+   system packet is embedded in a 2352 byte CD sector and the actual
+   MPEG data is preceded by 30 empty sectors.
+*/
+
+	unsigned int	sector_transport_size;
+	unsigned int    transport_prefix_sectors; 
+	unsigned int 	sector_size;
+	unsigned int	vcd_zero_stuffing;	/* VCD audio sectors have 20 0 bytes :-( */
+
+	int 		dmux_rate;	/* Actual data mux-rate for calculations always a multiple of 50  */
+	int 		mux_rate;	/* MPEG mux rate (50 byte/sec units      */
+
+
+	/* Sequence run-out control */
+	bool running_out;
+	clockticks runout_PTS;
+	
+private:	
+	
+    /* Stream packet component buffers */
+	
+	Sys_header_struc 	sys_header;
+	Pack_struc          pack_header;
+	Pack_struc *pack_header_ptr;
+	Sys_header_struc *sys_header_ptr;
+	bool start_of_new_pack;
+	bool include_sys_header;
+
+	/* Under-run error messages */
+	unsigned int underruns;
+	unsigned int underrun_ignore;
+
+	/* Output data stream... */
+	PS_Stream *psstrm;
+	bitcount_t bytes_output;
+    clockticks ticks_per_sector;
+
+public:
+	clockticks current_SCR;
+private:
+	clockticks audio_delay;
+	clockticks video_delay;
+	bool vbr;
+	/* Source data streams */
+	/* Note: 1st video stream is regarded as the &quot;master&quot; stream for
+	   the purpose of splitting sequences etc...
+	*/
+	vector&lt;ElementaryStream *&gt; estreams; // Complete set
+	vector&lt;ElementaryStream *&gt; vstreams; // Video streams in estreams
+	vector&lt;ElementaryStream *&gt; astreams; // Audio streams in estreams
+	
+	PaddingStream pstrm;
+	VCDAPadStream vcdapstrm;
+	DVDPriv2Stream dvdpriv2strm;
+
+private:
+	void InitSyntaxParameters(MultiplexJob &amp;job);
+	void InitInputStreams(MultiplexJob &amp;job);
+	void InitInputStreamsForStills(MultiplexJob &amp; job );
+	void InitInputStreamsForVideo(MultiplexJob &amp; job );
+	unsigned int RunInSectors();
+	void Init();
+	
+
+	void NextPosAndSCR();
+	void SetPosAndSCR( bitcount_t bytepos );
+
+	void OutputPrefix( );
+
+	void OutputSuffix();
+	void OutputPadding ( bool vcd_audio_pad );
+	void MuxStatus( log_level_t level );
+
+	void WriteRawSector( uint8_t *rawpackets,
+						 unsigned int     length
+		);
+	void AppendMuxStreamsOf( vector&lt;ElementaryStream *&gt; &amp;elem, 
+							 vector&lt;MuxStream *&gt; &amp;mux );
+};
+
+
+#endif //__OUTPUTSTREAM_H__

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/outputstrm.hpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/outputstrm.hpp	2009-09-04 15:59:41 UTC (rev 5319)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/outputstrm.hpp	2009-09-05 08:19:09 UTC (rev 5320)
@@ -0,0 +1,43 @@
+
+/*
+ *  outputstream.h: Base Class for output
+ *
+ *
+ *  Copyright (C) 2001 Andrew Stevens &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">andrew.stevens at philips.com</A>&gt;
+ *
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of version 2 of the GNU General Public License
+ *  as published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+
+#ifndef __OUTPUTSTRM_H__
+#define __OUTPUTSTRM_H__
+
+
+class OutputStream
+{
+public:
+    OutputStream() :
+        segment_num( 1 )
+        {}
+    virtual int  Open( ) = 0;
+    virtual void Close() = 0;
+    virtual off_t SegmentSize( ) = 0;
+    virtual void NextSegment() = 0;
+    virtual void Write(uint8_t *data, unsigned int len) = 0;
+protected:
+    int segment_num;
+};
+
+#endif /* __OUTPUTSTRM_H__ */

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/padstrm.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/padstrm.cpp	2009-09-04 15:59:41 UTC (rev 5319)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/padstrm.cpp	2009-09-05 08:19:09 UTC (rev 5320)
@@ -0,0 +1,61 @@
+
+/*
+ *  padstrm.cc:  Padding stream pseudo-input streams
+ *
+ *  Copyright (C) 2001 Andrew Stevens &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">andrew.stevens at philips.com</A>&gt;
+ *
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of version 2 of the GNU General Public License
+ *  as published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+
+#ifdef HAVE_CONFIG_H
+#include &quot;config.h&quot;
+#endif
+#include &lt;string.h&gt;
+
+#include &quot;padstrm.hpp&quot;
+
+
+
+//
+// Generator for padding packets in a padding stream...
+//
+
+
+unsigned int PaddingStream::ReadPacketPayload(uint8_t *dst, unsigned int to_read)
+{
+	memset( dst, STUFFING_BYTE, to_read );
+	return to_read;
+}
+
+unsigned int VCDAPadStream::ReadPacketPayload(uint8_t *dst, unsigned int to_read)
+{
+	memset( dst, STUFFING_BYTE, to_read );
+	return to_read;
+}
+
+unsigned int DVDPriv2Stream::ReadPacketPayload(uint8_t *dst, unsigned int to_read)
+{
+	memset( dst, 0, to_read );
+	return to_read;
+}
+
+/* 
+ * Local variables:
+ *  c-file-style: &quot;stroustrup&quot;
+ *  tab-width: 4
+ *  indent-tabs-mode: nil
+ * End:
+ */

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/padstrm.hpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/padstrm.hpp	2009-09-04 15:59:41 UTC (rev 5319)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/padstrm.hpp	2009-09-05 08:19:09 UTC (rev 5320)
@@ -0,0 +1,73 @@
+
+/*
+ *  padstrm.hpp:  Padding stream pseudo input-streamsin
+ *
+ *  Copyright (C) 2001 Andrew Stevens &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">andrew.stevens at philips.com</A>&gt;
+ *
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of version 2 of the GNU General Public License
+ *  as published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+#ifndef __PADSTRM_H__
+#define __PADSTRM_H__
+
+#include &quot;inputstrm.hpp&quot;
+
+
+class PaddingStream : public MuxStream
+{
+public:
+	PaddingStream()
+		{
+			MuxStream::Init( PADDING_STR, 0, 0,  0, false,false );
+		}
+
+	unsigned int ReadPacketPayload(uint8_t *dst, unsigned int to_read);
+};
+
+class VCDAPadStream : public MuxStream
+{
+public:
+	VCDAPadStream()
+		{
+			Init( PADDING_STR, 0, 0, 20, false, false );
+
+		}
+
+	unsigned int ReadPacketPayload(uint8_t *dst, unsigned int to_read);
+};
+
+class DVDPriv2Stream : public MuxStream
+{
+public:
+	DVDPriv2Stream()
+		{
+			Init( PRIVATE_STR_2, 0, 0, 0, false, false );
+
+		}
+
+	unsigned int ReadPacketPayload(uint8_t *dst, unsigned int to_read);
+};
+
+
+#endif // __PADSTRM_H__
+
+
+/* 
+ * Local variables:
+ *  c-file-style: &quot;stroustrup&quot;
+ *  tab-width: 4
+ *  indent-tabs-mode: nil
+ * End:
+ */

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/stillsstream.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/stillsstream.cpp	2009-09-04 15:59:41 UTC (rev 5319)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/stillsstream.cpp	2009-09-05 08:19:09 UTC (rev 5320)
@@ -0,0 +1,216 @@
+
+/*
+ *  stillsstreams.c: Class for elemenary still video streams
+ *                   Most functionality is inherited from VideoStream
+ *
+ *  Copyright (C) 2001 Andrew Stevens &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">andrew.stevens at philips.com</A>&gt;
+ *
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of version 2 of the GNU General Public License
+ *  as published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+
+#ifdef HAVE_CONFIG_H
+#include &quot;config.h&quot;
+#endif
+
+#include &lt;format_codes.h&gt;
+
+#include &quot;stillsstream.hpp&quot;
+#include &quot;interact.hpp&quot;
+#include &quot;multiplexor.hpp&quot;
+
+void StillsStream::Init ( )
+{
+	int stream_id = -1;
+	int buffer_size = -1;
+
+	SetBufSize( 4*1024*1024 );
+	ScanFirstSeqHeader();
+
+	mjpeg_debug( &quot;Stills: Video buffer suggestion ignored!&quot; );
+	switch( muxinto.mux_format )
+	{
+	case  MPEG_FORMAT_VCD_STILL :
+		if( horizontal_size &gt; 352 )
+		{
+			stream_id = VIDEO_STR_0+2 ;
+			buffer_size = vbv_buffer_size*2048;
+			mjpeg_info( &quot;Stills Stream %02x: high-resolution VCD stills %d KB each&quot;, 
+						stream_id,
+						buffer_size );
+			if( buffer_size &lt; 46*1024 )
+				mjpeg_error_exit1( &quot;I Can't multiplex high-res stills smaller than normal res stills - sorry!&quot;);
+
+		}
+		else
+		{
+			stream_id = VIDEO_STR_0+1 ;
+			buffer_size = 46*1024;
+			mjpeg_info( &quot;Stills Stream %02x: normal VCD stills&quot;, stream_id );
+		}
+		break;
+	case MPEG_FORMAT_SVCD_STILL :
+		if( horizontal_size &gt; 480 )
+		{
+			stream_id = VIDEO_STR_0+1;
+			buffer_size = 230*1024;
+			mjpeg_info( &quot;Stills Stream %02x: high-resolution SVCD stills.&quot;, 
+						stream_id );
+		}
+		else
+		{
+			stream_id = VIDEO_STR_0+1 ;
+			buffer_size = 230*1024;
+			mjpeg_info( &quot;Stills Stream %02x: normal-resolution SVCD stills.&quot;, stream_id );
+		}
+		break;
+	default:
+		mjpeg_error_exit1( &quot;Only SVCD and VCD Still currently supported&quot;);
+	}
+
+
+	MuxStream::Init( stream_id,
+					 1,  // Buffer scale
+					 buffer_size,
+					 0,  // Zero stuffing
+					 muxinto.buffers_in_video,
+					 muxinto.always_buffers_in_video);
+	
+	/* Skip to the end of the 1st AU (*2nd* Picture start!)
+	*/
+	AU_hdr = SEQUENCE_HEADER;
+	AU_pict_data = 0;
+	AU_start = 0;
+
+    OutputSeqhdrInfo();
+
+}
+
+
+
+
+/*
+ * Compute DTS / PTS for a VCD/SVCD Stills sequence
+ * TODO: Very crude. Simply assumes each still stays for the specified
+ * frame interval and that enough run-in delay is present for the first
+ * frame to be loaded.
+ *
+ */
+
+void StillsStream::NextDTSPTS( )
+{
+    StillsParams *sparms = static_cast&lt;StillsParams*&gt;(parms);
+
+	clockticks interval = static_cast&lt;clockticks&gt;
+		(sparms-&gt;Intervals()-&gt;NextFrameInterval() * CLOCKS / frame_rate);
+	clockticks time_for_xfer;
+	muxinto.ByteposTimecode( BufferSize(), time_for_xfer );
+		
+	access_unit.DTS = current_PTS + time_for_xfer;	// This frame decoded just after
+	                                    // Predecessor completed.
+	access_unit.PTS = current_PTS + time_for_xfer + interval;
+	current_PTS = access_unit.PTS;
+	current_DTS = access_unit.DTS;
+    fields_presented += 2;
+}
+
+/*
+ * VCD mixed stills segment items have the constraint that both stills
+ * streams must end together.  To do this each stream has to know
+ * about its &quot;sibling&quot;.
+ *
+ */
+
+void VCDStillsStream::SetSibling( VCDStillsStream *_sibling )
+{
+	assert( _sibling != 0 );
+	sibling = _sibling;
+	if( sibling-&gt;stream_id == stream_id )
+	{
+		mjpeg_error_exit1(&quot;VCD mixed stills stream cannot contain two streams of the same type!&quot;);
+	}
+
+}
+
+/*
+ * Check if we've reached the last sector of the last AU.  Note: that
+ * we know no PTS/DTS time-stamps will be needed because no new AU
+ * will appear in the last sector.  WARNING: We assume a still won't
+ * fit into a single secotr.
+ *
+ */
+
+bool VCDStillsStream::LastSectorLastAU()
+{
+	return ( Lookahead() == 0 &amp;&amp;
+			 au_unsent &lt;= muxinto.PacketPayload( *this,
+												 buffers_in_header, 
+												 false, false )
+		);
+}
+
+
+/*
+ * The requirement that VCD mixed stills segment items constituent streams
+ * end together means we can't mux the last sector of the last AU of
+ * such streams until its sibling has already completed muxing or is
+ * also ready to mux the last sector of its last AU.
+ *
+ * NOTE: Will not work right if sector_align_iframe_AUs not set as this
+ * will allow multiple AU's in  a sector.
+ *
+ */
+
+
+bool VCDStillsStream::MuxPossible(clockticks currentSCR)
+{
+    if( bufmodel.Size() &lt; au_unsent )
+    {
+        mjpeg_error_exit1( &quot;Illegal VCD still: larger than maximum permitted by its buffering parameters!&quot;);
+    }
+	if (RunOutComplete() ||	bufmodel.Space() &lt; au_unsent)
+	{
+		return false;
+	}
+	
+	if( LastSectorLastAU() )
+	{
+		if( sibling != 0 )
+        {
+            if( !stream_mismatch_warned &amp;&amp; sibling-&gt;NextAUType() != NOFRAME  )
+            {
+                mjpeg_warn( &quot;One VCD stills stream runs significantly longer than the other!&quot;);
+                mjpeg_warn( &quot;Simultaneous stream ending recommended by standard not possible&quot; );
+                return true;
+            }
+            return sibling-&gt;MuxCompleted() || sibling-&gt;LastSectorLastAU();
+        }
+        else
+            return true;
+	}
+	else
+		return true;
+}
+
+
+
+
+/* 
+ * Local variables:
+ *  c-file-style: &quot;stroustrup&quot;
+ *  tab-width: 4
+ *  indent-tabs-mode: nil
+ * End:
+ */

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/stillsstream.hpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/stillsstream.hpp	2009-09-04 15:59:41 UTC (rev 5319)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/stillsstream.hpp	2009-09-05 08:19:09 UTC (rev 5320)
@@ -0,0 +1,81 @@
+
+/*
+ *  stillsstreams.c: Class for elemenary still video streams
+ *                   Most functionality is inherited from VideoStream
+ *
+ *  Copyright (C) 2001 Andrew Stevens &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">andrew.stevens at philips.com</A>&gt;
+ *
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of version 2 of the GNU General Public License
+ *  as published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+
+#include &quot;videostrm.hpp&quot;
+
+//
+// Class for video stills sequence for (S)VCD non-mixed stills segment 
+// item
+//
+
+class StillsStream : public VideoStream
+{
+public:
+	StillsStream( IBitStream &amp;ibs, 
+                  StillsParams *parms,
+                  Multiplexor &amp;into) :
+		VideoStream( ibs, parms, into ),
+		current_PTS(0),
+		current_DTS(0)
+		{}
+	void Init( );
+private:
+	virtual void NextDTSPTS( );
+	clockticks current_PTS;
+	clockticks current_DTS;
+};
+
+//
+// Class for video stills sequence for VCD mixed stills Segment item.
+// 
+
+class VCDStillsStream : public StillsStream
+{
+public:
+	VCDStillsStream( IBitStream &amp;ibs,
+                     StillsParams *vparms,
+                     Multiplexor &amp;into ) :
+		StillsStream( ibs, vparms, into ),
+		sibling( 0 ),
+        stream_mismatch_warned( false )
+		{}
+	
+	void SetSibling( VCDStillsStream * );
+	virtual bool MuxPossible(clockticks currentSCR);
+private:
+	bool LastSectorLastAU();
+	VCDStillsStream *sibling;
+    bool stream_mismatch_warned;
+	
+};
+	
+
+
+
+/* 
+ * Local variables:
+ *  c-file-style: &quot;stroustrup&quot;
+ *  tab-width: 4
+ *  indent-tabs-mode: nil
+ * End:
+ */

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/streamType.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/streamType.h	2009-09-04 15:59:41 UTC (rev 5319)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/streamType.h	2009-09-05 08:19:09 UTC (rev 5320)
@@ -0,0 +1,22 @@
+#ifndef STREAM_TYPE_H
+#define STREAM_TYPE_H
+enum StreamKind
+  {
+      MPEG_AUDIO=1,
+      AC3_AUDIO,
+      LPCM_AUDIO,
+      DTS_AUDIO,
+      MPEG_VIDEO
+#ifdef ZALPHA
+        ,
+      Z_ALPHA
+#endif
+  };
+
+typedef struct mplexStreamDescriptor
+{
+  int channel;
+  int frequency;
+  StreamKind kind;
+}mplexStreamDescriptor;
+#endif

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/stream_params.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/stream_params.cpp	2009-09-04 15:59:41 UTC (rev 5319)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/stream_params.cpp	2009-09-05 08:19:09 UTC (rev 5320)
@@ -0,0 +1,125 @@
+/*
+ * params.hpp:  User specifiable parameters for various types of stream
+ *
+ *  The Check&lt;stream&gt;Params pseudo-constructors are constructed so that
+ *  they will only construct legal combinations of parameters.
+ *
+ *  Copyright (C) 2002 Andrew Stevens &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">andrew.stevens at philips.com</A>&gt;
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of version 2 of the GNU General Public License
+ *  as published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+
+#ifdef HAVE_CONFIG_H
+#include &quot;config.h&quot;
+#endif
+
+#include &quot;stream_params.hpp&quot;
+#include &quot;format_codes.h&quot;
+
+LpcmParams *LpcmParams::Default(unsigned int mux_format)
+{
+	return new LpcmParams(48000,2,16);
+}
+
+LpcmParams::LpcmParams( unsigned int samples,  
+						unsigned int chans, 
+						unsigned int bits ) :
+	samples_per_sec( samples ),
+	channels(chans),
+	bits_per_sample(bits)
+{
+}
+
+LpcmParams *LpcmParams::Checked(unsigned int samples,  
+								unsigned int chans, 
+								unsigned int bits )
+{
+    if( samples != 48000 &amp;&amp; samples != 96000 )
+        return 0;
+    if( chans &lt; 1 || chans &gt; 7 )
+        return 0;
+    if( bits != 16 &amp;&amp; bits != 20 &amp;&amp; bits != 24 )
+        return 0;
+
+    return new LpcmParams(samples,chans,bits);
+}
+
+bool VideoParams::Force( unsigned int mux_format )
+{
+	unsigned int bufsiz;
+	//
+	// Handle formats that force the buffer size parameter to a
+	// standard-conforming value
+	//
+	switch( mux_format )
+	{
+	case MPEG_FORMAT_SVCD :
+		bufsiz = 230;
+		break;
+	case MPEG_FORMAT_VCD :
+		bufsiz = 46;
+		break;
+	case MPEG_FORMAT_DVD :
+	case MPEG_FORMAT_DVD_NAV :
+		bufsiz = 232;
+		break;
+	default :
+		return false;
+	}
+	decode_buffer_size = bufsiz;
+	return true;
+}
+
+VideoParams *VideoParams::Checked( unsigned int bufsiz)
+{
+	if( bufsiz &lt; 20 &amp;&amp; bufsiz &gt;= 4096 )	// In KB here...
+		return 0;
+	return new VideoParams(bufsiz);
+}
+
+VideoParams::VideoParams( unsigned int bufsiz ) :
+	decode_buffer_size(bufsiz)
+{
+}
+
+VideoParams *VideoParams::Default(unsigned int mux_format)
+{
+	unsigned int bufsiz;
+	switch( mux_format )
+	{
+	case MPEG_FORMAT_MPEG2 :
+	case MPEG_FORMAT_SVCD :
+	case MPEG_FORMAT_SVCD_NSR :	
+	case MPEG_FORMAT_SVCD_STILL :
+		bufsiz = 230;
+		break;
+	case MPEG_FORMAT_DVD :		
+	case MPEG_FORMAT_DVD_NAV :		
+		bufsiz = 232;
+		break;
+	default :
+		bufsiz = 46;
+	}
+	return new VideoParams(bufsiz);
+}
+
+
+/* 
+ * Local variables:
+ *  c-file-style: &quot;stroustrup&quot;
+ *  tab-width: 4
+ *  indent-tabs-mode: nil
+ * End:
+ */

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/stream_params.hpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/stream_params.hpp	2009-09-04 15:59:41 UTC (rev 5319)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/stream_params.hpp	2009-09-05 08:19:09 UTC (rev 5320)
@@ -0,0 +1,109 @@
+/*
+ * streamparams.hpp:  User specifiable parameter classes for various types of stream
+ *
+ * The class constructors etc are defined so that it is impossible to build
+ * objects with illegal combinations of constructors.
+ *
+ *  Copyright (C) 2002 Andrew Stevens &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">andrew.stevens at philips.com</A>&gt;
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of version 2 of the GNU General Public License
+ *  as published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+#ifndef __STREAM_PARAMS_HH__
+#define __STREAM_PARAMS_HH__
+
+
+class LpcmParams
+{
+public:
+  static LpcmParams *Checked(  unsigned int samples,  
+                               unsigned int chans, 
+                               unsigned int bits );
+  static LpcmParams *Default(  unsigned int opt_mux_format );
+  inline unsigned int SamplesPerSec() { return samples_per_sec; }
+  inline unsigned int Channels() { return channels; }
+  inline unsigned int BitsPerSample() { return bits_per_sample; }
+  
+private:
+  LpcmParams(unsigned int samples,  
+             unsigned int chans, 
+             unsigned int bits);
+  unsigned int samples_per_sec;
+  unsigned int channels;
+  unsigned int bits_per_sample;
+};
+
+
+class VideoParams
+{
+public:
+  static VideoParams *Checked(unsigned int bufsiz);
+  static VideoParams *Default(unsigned int mux_format);
+  bool Force(unsigned int mux_format);
+  inline unsigned int DecodeBufferSize() { return decode_buffer_size; }
+private:
+  VideoParams(unsigned int bufsiz);
+  unsigned int decode_buffer_size;
+};
+
+
+
+//
+// Class of sequence of frame intervals.
+//
+
+
+
+class FrameIntervals
+{
+public:
+	virtual int NextFrameInterval() = 0;
+};
+
+
+class ConstantFrameIntervals : public FrameIntervals
+{
+public:
+	ConstantFrameIntervals( int _frame_interval ) :
+		frame_interval( _frame_interval )
+		{
+		}
+	int NextFrameInterval() { return frame_interval; };
+private:
+	int frame_interval;
+};
+
+
+class StillsParams : public VideoParams
+{
+public:
+  StillsParams( VideoParams *parms, FrameIntervals *ints ) :
+    VideoParams(*parms),
+    intervals(ints)
+  {}
+  inline FrameIntervals *Intervals() { return intervals; }
+private:
+  FrameIntervals *intervals;
+};
+
+
+#endif
+
+/* 
+ * Local variables:
+ *  c-file-style: &quot;gnu&quot;
+ *  tab-width: 8
+ *  indent-tabs-mode: nil
+ * End:
+ */

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/systems.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/systems.cpp	2009-09-04 15:59:41 UTC (rev 5319)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/systems.cpp	2009-09-05 08:19:09 UTC (rev 5320)
@@ -0,0 +1,739 @@
+
+/*
+ *  systems.cpp: Program/System stream packet generator 
+ *
+ *
+ *  Copyright (C) 2001 Andrew Stevens &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">andrew.stevens at philips.com</A>&gt;
+ *
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of version 2 of the GNU General Public License
+ *  as published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+
+#include &lt;config.h&gt;
+#include &lt;stdio.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;string.h&gt;
+
+#include &lt;sys/param.h&gt;
+#include &quot;systems.hpp&quot;
+#include &quot;mplexconsts.hpp&quot;
+
+PS_Stream:: PS_Stream( unsigned _mpeg,
+                       unsigned int _sector_size,
+                       OutputStream &amp;_output_strm, 
+                       off_t max_seg_size )
+    : mpeg_version( _mpeg),
+      sector_size( _sector_size ),
+      output_strm(_output_strm ),
+      max_segment_size( max_seg_size )
+{
+    sector_buf = new uint8_t[sector_size];
+	max_segment_size = max_seg_size;
+}
+
+PS_Stream::~PS_Stream()
+{
+    delete [] sector_buf;
+}
+
+
+bool
+PS_Stream::SegmentLimReached()
+{
+	off_t written = output_strm.SegmentSize();
+	return max_segment_size != 0 &amp;&amp; written &gt; max_segment_size;
+}
+
+
+
+
+/**************************************************************
+
+ 	 Packet payload compute how much payload a sector-sized packet with the 
+	 specified headers can carry...
+     TODO: Should really be called &quot;Sector Payload&quot;
+**************************************************************/
+	
+		
+unsigned int 
+PS_Stream::PacketPayload( MuxStream &amp;mux_strm,
+						  Sys_header_struc *sys_header, 
+						  Pack_struc *pack_header, 
+						  int buffers, int PTSstamp, int DTSstamp )
+{
+  int payload = sector_size - (PACKET_HEADER_SIZE + mux_strm.zero_stuffing);
+	if( sys_header != NULL )
+		payload -= sys_header-&gt;length;
+	if( mpeg_version == 2 )
+	{
+	  if( buffers )
+	    payload -= MPEG2_BUFFERINFO_LENGTH;
+
+	  payload -= MPEG2_AFTER_PACKET_LENGTH_MIN;
+	  if( pack_header != NULL )
+	    payload -= pack_header-&gt;length;
+	  if( DTSstamp )
+	    payload -= DTS_PTS_TIMESTAMP_LENGTH;
+	  if ( PTSstamp )
+	    payload -= DTS_PTS_TIMESTAMP_LENGTH;
+
+	}
+	else
+	{
+		if( buffers )
+			payload -= MPEG1_BUFFERINFO_LENGTH;
+
+		payload -= MPEG1_AFTER_PACKET_LENGTH_MIN;
+		if( pack_header != NULL )
+			payload -= pack_header-&gt;length;
+		if( DTSstamp )
+			payload -= DTS_PTS_TIMESTAMP_LENGTH;
+		if (PTSstamp )
+			payload -= DTS_PTS_TIMESTAMP_LENGTH;
+		if( DTSstamp || PTSstamp )
+			payload += 1;  /* No need for nostamp marker ... */
+
+	}
+	
+	return payload;
+}
+
+
+
+/*************************************************************************
+    Kopiert einen TimeCode in einen Bytebuffer. Dabei wird er nach
+    MPEG-Verfahren in bits aufgesplittet.
+
+    Makes a Copy of a TimeCode in a Buffer, splitting it into bitfields
+    for MPEG-1/2 DTS/PTS fields and MPEG-1 pack scr fields
+*************************************************************************/
+
+void 
+PS_Stream::BufferDtsPtsMpeg1ScrTimecode (clockticks    timecode,
+										 uint8_t  marker,
+										 uint8_t *&amp;buffer)
+
+{
+	clockticks thetime_base;
+    uint8_t temp;
+    unsigned int msb, lsb;
+     
+ 	/* MPEG-1 uses a 90KHz clock, extended to 300*90KHz = 27Mhz in MPEG-2 */
+	/* For these fields we only encode to MPEG-1 90Khz resolution... */
+	
+	thetime_base = timecode /300;
+	msb = (thetime_base &gt;&gt; 32) &amp; 1;
+	lsb = (thetime_base &amp; static_cast&lt;uint64_t&gt;(0xFFFFFFFF));
+		
+    temp = (marker &lt;&lt; 4) | (msb &lt;&lt;3) |
+		((lsb &gt;&gt; 29) &amp; 0x6) | 1;
+    *(buffer++)=temp;
+    temp = (lsb &amp; 0x3fc00000) &gt;&gt; 22;
+    *(buffer++)=temp;
+    temp = ((lsb &amp; 0x003f8000) &gt;&gt; 14) | 1;
+    *(buffer++)=temp;
+    temp = (lsb &amp; 0x7f80) &gt;&gt; 7;
+    *(buffer++)=temp;
+    temp = ((lsb &amp; 0x007f) &lt;&lt; 1) | 1;
+    *(buffer++)=temp;
+
+}
+
+/*************************************************************************
+    Makes a Copy of a TimeCode in a Buffer, splitting it into bitfields
+    for MPEG-2 pack scr fields  which use the full 27Mhz resolution
+    
+    Did they *really* need to put a 27Mhz
+    clock source into the system stream.  Does anyone really need it
+    for their decoders?  Get real... I guess they thought it might allow
+    someone somewhere to save on a proper clock circuit.
+*************************************************************************/
+
+
+void 
+PS_Stream::BufferMpeg2ScrTimecode( clockticks    timecode,
+								   uint8_t *&amp;buffer
+	)
+{
+ 	clockticks thetime_base;
+	unsigned int thetime_ext;
+    uint8_t temp;
+    unsigned int msb, lsb;
+     
+	thetime_base = timecode /300;
+	thetime_ext =  timecode % 300;
+	msb = (thetime_base&gt;&gt; 32) &amp; 1;
+	lsb = thetime_base &amp; static_cast&lt;uint64_t&gt;(0xFFFFFFFF);
+
+
+      temp = (MARKER_MPEG2_SCR &lt;&lt; 6) | (msb &lt;&lt; 5) |
+		  ((lsb &gt;&gt; 27) &amp; 0x18) | 0x4 | ((lsb &gt;&gt; 28) &amp; 0x3);
+      *(buffer++)=temp;
+      temp = (lsb &amp; 0x0ff00000) &gt;&gt; 20;
+      *(buffer++)=temp;
+      temp = ((lsb &amp; 0x000f8000) &gt;&gt; 12) | 0x4 |
+             ((lsb &amp; 0x00006000) &gt;&gt; 13);
+      *(buffer++)=temp;
+      temp = (lsb &amp; 0x00001fe0) &gt;&gt; 5;
+      *(buffer++)=temp;
+      temp = ((lsb &amp; 0x0000001f) &lt;&lt; 3) | 0x4 |
+             ((thetime_ext &amp; 0x00000180) &gt;&gt; 7);
+      *(buffer++)=temp;
+      temp = ((thetime_ext &amp; 0x0000007F) &lt;&lt; 1) | 1;
+      *(buffer++)=temp;
+}
+
+/*************************************************************************
+
+BufferPaddingPacket - Insert a padding packet of the desired length
+                      into the specified Program/System stream buffer
+
+**************************************************************************/
+
+void
+PS_Stream::BufferPaddingPacket( int padding,  uint8_t *&amp;buffer  )
+{
+    uint8_t *index = buffer;
+    int i;
+
+    assert( (mpeg_version == 2 &amp;&amp; padding &gt;= 6) ||
+            (mpeg_version == 1 &amp;&amp; padding &gt;= 7) );
+
+    *(index++) = static_cast&lt;uint8_t&gt;(PACKET_START)&gt;&gt;16;
+    *(index++) = static_cast&lt;uint8_t&gt;(PACKET_START &amp; 0x00ffff)&gt;&gt;8;
+    *(index++) = static_cast&lt;uint8_t&gt;(PACKET_START &amp; 0x0000ff);
+    *(index++) = PADDING_STR;
+    *(index++) = static_cast&lt;uint8_t&gt;((padding - 6) &gt;&gt; 8);
+    *(index++) = static_cast&lt;uint8_t&gt;((padding - 6) &amp; 0xff);
+    if (mpeg_version == 2)
+        {
+            for (i = 0; i &lt; padding - 6; i++)
+                *(index++) = static_cast&lt;uint8_t&gt;(STUFFING_BYTE);
+        }
+        else
+        {
+            *(index++) = 0x0F;
+            for (i = 0; i &lt; padding - 7; i++)
+                *(index++) = static_cast&lt;uint8_t&gt;(STUFFING_BYTE);
+        }
+
+    buffer = index;
+}
+
+
+void 
+PS_Stream::BufferSectorHeader( uint8_t *index,
+                               Pack_struc	 	 *pack,
+                               Sys_header_struc *sys_header,
+                               uint8_t     *&amp;header_end
+    )
+{
+    /* Pack header if present */
+
+    if (pack != NULL)
+    {
+		memcpy ( index, pack-&gt;buf, pack-&gt;length);
+		index += pack-&gt;length;
+    }
+
+    /* System header if present */
+
+    if (sys_header != NULL)
+    {
+		memcpy (index, sys_header-&gt;buf, sys_header-&gt;length);
+		index += sys_header-&gt;length;
+    }
+    header_end = index;
+}
+
+/******************************************
+ *
+ * BufferPacketHeader
+ * Construct an MPEG-1/2 header for a packet in the specified
+ * buffer (which *MUST* be long enough) and set points to the start of
+ * the payload and packet length fields.
+ *
+ ******************************************/
+
+
+void PS_Stream::BufferPacketHeader( uint8_t *buf,
+                                    uint8_t type,
+                                    unsigned int mpeg_version,
+                                    bool buffers,
+                                    unsigned int buffer_size,
+                                    uint8_t buffer_scale,
+                                    clockticks   	 PTS,
+                                    clockticks   	 DTS,
+                                    uint8_t 	 timestamps,
+                                    unsigned    int min_pes_hdr_len,
+                                    uint8_t     *&amp;size_field,
+                                    uint8_t     *&amp;header_end
+    )
+{
+
+    uint8_t *index = buf;
+	uint8_t *pes_header_len_field = 0;
+
+
+    /* konstante Packet Headerwerte eintragen */
+    /* write constant packet header data */
+
+    *(index++) = static_cast&lt;uint8_t&gt;(PACKET_START)&gt;&gt;16;
+    *(index++) = static_cast&lt;uint8_t&gt;(PACKET_START &amp; 0x00ffff)&gt;&gt;8;
+    *(index++) = static_cast&lt;uint8_t&gt;(PACKET_START &amp; 0x0000ff);
+    *(index++) = type;	
+
+
+    /* we remember this offset so we can fill in the packet size field once
+	   we know the actual size... */
+    size_field = index;   
+    index += 2;
+
+	if( mpeg_version == 1 )
+	{
+		/* MPEG-1: buffer information */
+		if (buffers)
+		{
+			*(index++) = static_cast&lt;uint8_t&gt; (0x40 |
+                                               (buffer_scale &lt;&lt; 5) | (buffer_size &gt;&gt; 8));
+			*(index++) = static_cast&lt;uint8_t&gt; (buffer_size &amp; 0xff);
+		}
+
+		/* MPEG-1: PTS, PTS &amp; DTS, oder gar nichts? */
+		/* should we write PTS, PTS &amp; DTS or nothing at all ? */
+
+		switch (timestamps)
+		{
+		case TIMESTAMPBITS_NO:
+			*(index++) = MARKER_NO_TIMESTAMPS;
+			break;
+		case TIMESTAMPBITS_PTS:
+			BufferDtsPtsMpeg1ScrTimecode (PTS, MARKER_JUST_PTS, index);
+			break;
+		case TIMESTAMPBITS_PTS_DTS:
+			BufferDtsPtsMpeg1ScrTimecode (PTS, MARKER_PTS, index);
+			BufferDtsPtsMpeg1ScrTimecode (DTS, MARKER_DTS, index);
+			break;
+		}
+	}
+	else if( type != PADDING_STR )
+	{
+	  	/* MPEG-2 packet syntax header flags. */
+        /* These *DO NOT* appear in padding packets 			*/
+        /* TODO: They don't appear in several others either!	*/
+		/* First byte:
+		   &lt;1,0&gt;&lt;PES_scrambling_control:2=0&gt;&lt;PES_priority&gt;&lt;data_alignment_ind.=0&gt;
+		   &lt;copyright=0&gt;&lt;original=1&gt; */
+		*(index++) = 0x81;
+		/* Second byte: PTS PTS_DTS or neither?  Buffer info?
+		   &lt;PTS_DTS:2&gt;&lt;ESCR=0&gt;&lt;ES_rate=0&gt;
+		   &lt;DSM_trick_mode:2=0&gt;&lt;PES_CRC=0&gt;&lt;PES_extension=(!!buffers)&gt;
+		*/
+		*(index++) = (timestamps &lt;&lt; 6) | (!!buffers);
+		/* Third byte:
+		   &lt;PES_header_length:8&gt; */
+		pes_header_len_field = index;  /* To fill in later! */
+		index++;
+		/* MPEG-2: the timecodes if required */
+		switch (timestamps)
+		{
+		case TIMESTAMPBITS_PTS:
+			BufferDtsPtsMpeg1ScrTimecode(PTS, MARKER_JUST_PTS, index);
+			break;
+
+		case TIMESTAMPBITS_PTS_DTS:
+			BufferDtsPtsMpeg1ScrTimecode(PTS, MARKER_PTS, index);
+			BufferDtsPtsMpeg1ScrTimecode(DTS, MARKER_DTS, index);
+			break;
+		}
+
+		/* MPEG-2 The buffer information in a PES_extension */
+		if( buffers )
+		{
+			/* MPEG-2 PES extension header
+			   &lt;PES_private_data:1=0&gt;&lt;pack_header_field=0&gt;
+			   &lt;program_packet_sequence_counter=0&gt;
+			   &lt;P-STD_buffer=1&gt;&lt;reserved:3=1&gt;&lt;{PES_extension_flag_2=0&gt; */
+			*(index++) = static_cast&lt;uint8_t&gt;(0x1e);
+			*(index++) = static_cast&lt;uint8_t&gt; (0x40 | (buffer_scale &lt;&lt; 5) | 
+                                               (buffer_size &gt;&gt; 8));
+			*(index++) = static_cast&lt;uint8_t&gt; (buffer_size &amp; 0xff);
+		}
+        /* If required pad the PES header: needed for some workarounds */
+        while( index-(pes_header_len_field+1) &lt; min_pes_hdr_len )
+            *(index++)=static_cast&lt;uint8_t&gt;(STUFFING_BYTE);
+	}
+
+    if( mpeg_version == 2 &amp;&amp; type != PADDING_STR )
+    {
+        *pes_header_len_field = 
+            static_cast&lt;uint8_t&gt;(index-(pes_header_len_field+1));	
+    }
+    header_end = index;
+}
+
+/*************************************************************************
+ *	CreateSector
+ *
+ *  Creates a complete sector to carry a padding packet or a packet
+ *  from one of the elementary streams.  Pack and System headers are
+ *  prepended if required.
+ *
+ *  We allow for situations where want to
+ *  deliberately reduce the payload carried by stuffing.
+ *  This allows us to deal with tricky situations where the
+ *	header overhead of adding in additional information
+ *	would exceed the remaining payload capacity.
+ *
+ *    Header stuffing and/or a padding packet is appended if the sector is
+ *    unfilled.   Zero stuffing after the end of a packet is also supported
+ *    to allow thos wretched audio packets from VCD's to be handled.
+ *
+ *  TODO: Should really be called &quot;WriteSector&quot; 
+ * 
+ * TODO: We need to add a generic mechanism for sub-headers of
+ * private streams to be generated...
+ *
+ *************************************************************************/
+
+
+unsigned int
+PS_Stream::CreateSector (Pack_struc	 	 *pack,
+						 Sys_header_struc *sys_header,
+						 unsigned int     max_packet_data_size,
+						 MuxStream        &amp;mux_strm,
+						 bool 	 buffers,
+						 bool    end_marker,
+						 clockticks   	 PTS,
+						 clockticks   	 DTS,
+						 uint8_t 	 timestamps
+	)
+
+{
+    int i;
+    uint8_t *index;
+    uint8_t *size_offset;
+	unsigned int target_packet_data_size;
+	unsigned int actual_packet_data_size;
+	int packet_data_to_read;
+	int bytes_short;
+	uint8_t 	 type = mux_strm.stream_id;
+	uint8_t 	 buffer_scale = mux_strm.BufferScale();
+	unsigned int buffer_size = mux_strm.BufferSizeCode();
+	unsigned int sector_pack_area;
+	index = sector_buf;
+
+	sector_pack_area = sector_size - mux_strm.zero_stuffing;
+	if( end_marker )
+		sector_pack_area -= 4;
+
+    BufferSectorHeader( index, pack, sys_header, index );
+    BufferPacketHeader( index, type, mpeg_version,
+                        buffers, buffer_size, buffer_scale,
+                        PTS, DTS, timestamps,
+                        mux_strm.min_pes_header_len,
+                        size_offset,
+                        index );
+
+    
+    /* MPEG-1, MPEG-2: data available to be filled is packet_size less
+     * header and MPEG-1 trailer... */
+
+    target_packet_data_size = sector_pack_area - (index - sector_buf );
+	
+		
+    /* DEBUG: A handy consistency check when we're messing around */
+#ifdef MUX_DEBUG		
+    if( type != PADDING_STR &amp;&amp;
+
+        (end_marker ? target_packet_data_size+4 : target_packet_data_size) 
+        != 
+        PacketPayload( mux_strm, sys_header, pack, buffers,
+                       timestamps &amp; TIMESTAMPBITS_PTS, timestamps &amp; TIMESTAMPBITS_DTS) )
+	
+    { 
+		printf(&quot;\nPacket size calculation error %d S%d P%d B%d %d %d!\n &quot;,
+               timestamps,
+			   sys_header!=0, pack!=0, buffers,
+			   target_packet_data_size , 
+			   PacketPayload( mux_strm, sys_header, pack, buffers,
+							  timestamps &amp; TIMESTAMPBITS_PTS, 
+                              timestamps &amp; TIMESTAMPBITS_DTS));
+        exit(1);
+    }
+#endif	
+              
+    /* If a maximum payload data size is specified (!=0) and is
+       smaller than the space available thats all we read (the
+       remaining space is stuffed) */
+    if( max_packet_data_size != 0 &amp;&amp; 
+        max_packet_data_size &lt; target_packet_data_size )
+    {
+        packet_data_to_read = max_packet_data_size;
+    }
+    else
+        packet_data_to_read = target_packet_data_size;
+              
+
+    /* MPEG-1, MPEG-2: read in available packet data ... */
+
+    actual_packet_data_size = mux_strm.ReadPacketPayload(index,packet_data_to_read);
+
+    bytes_short = target_packet_data_size - actual_packet_data_size;
+#ifdef MUX_DEBUG
+    if( type == PRIVATE_STR_1 )
+    {
+        mjpeg_info( &quot;Substream %02x short %d&quot;, index[0], bytes_short );
+
+    }
+#endif
+	
+    /* Handle the situations where we don't have enough data to fill
+       the packet size fully ...  small shortfalls are dealt with here
+       by stuffing, big ones dealt with later by appending padding packets.
+    */
+
+
+    if(  bytes_short &lt; MINIMUM_PADDING_PACKET_SIZE &amp;&amp; bytes_short &gt; 0 )
+    {
+        if (mpeg_version == 1 )
+        {
+            /* MPEG-1 stuffing happens *before* header data fields. */
+            uint8_t *fixed_packet_header_end = size_offset + 2;
+            memmove( fixed_packet_header_end+bytes_short, 
+                     fixed_packet_header_end, 
+                     actual_packet_data_size+(index-fixed_packet_header_end)
+                );
+            for( i=0; i&lt; bytes_short; ++i)
+                fixed_packet_header_end[i] = static_cast&lt;uint8_t&gt;(STUFFING_BYTE);
+        }
+        else
+        {
+            memmove( index+bytes_short, index,  actual_packet_data_size );
+            for( i=0; i&lt; bytes_short; ++i)
+                *(index+i)=static_cast&lt;uint8_t&gt;(STUFFING_BYTE);
+            // Correct PES length field (if present)
+            if( type != PADDING_STR )
+            {
+                uint8_t *pes_header_len_offset = size_offset + 4;
+                unsigned int pes_header_len = 
+                    index+bytes_short-(pes_header_len_offset+1);
+                *pes_header_len_offset = static_cast&lt;uint8_t&gt;(pes_header_len);	            }
+        }
+        index += bytes_short;
+        bytes_short = 0;
+    }
+
+	
+    /* MPEG-2: We now know the final PES header after padding...
+     */
+    index += actual_packet_data_size;	 
+    /* MPEG-1, MPEG-2: Now we know that actual packet size */
+    size_offset[0] = static_cast&lt;uint8_t&gt;((index-size_offset-2)&gt;&gt;8);
+    size_offset[1] = static_cast&lt;uint8_t&gt;((index-size_offset-2)&amp;0xff);
+	
+    /* The case where we have fallen short enough to allow it to be
+       dealt with by inserting a stuffing packet... */	
+    if ( bytes_short != 0 )
+    {
+        *(index++) = static_cast&lt;uint8_t&gt;(PACKET_START)&gt;&gt;16;
+        *(index++) = static_cast&lt;uint8_t&gt;(PACKET_START &amp; 0x00ffff)&gt;&gt;8;
+        *(index++) = static_cast&lt;uint8_t&gt;(PACKET_START &amp; 0x0000ff);
+        *(index++) = PADDING_STR;
+        *(index++) = static_cast&lt;uint8_t&gt;((bytes_short - 6) &gt;&gt; 8);
+        *(index++) = static_cast&lt;uint8_t&gt;((bytes_short - 6) &amp; 0xff);
+        if (mpeg_version == 2)
+        {
+            for (i = 0; i &lt; bytes_short - 6; i++)
+                *(index++) = static_cast&lt;uint8_t&gt;(STUFFING_BYTE);
+        }
+        else
+        {
+            *(index++) = 0x0F;
+            for (i = 0; i &lt; bytes_short - 7; i++)
+                *(index++) = static_cast&lt;uint8_t&gt;(STUFFING_BYTE);
+        }
+		
+        bytes_short = 0;
+    }
+	 
+    if( end_marker )
+    {
+        *(index++) = static_cast&lt;uint8_t&gt;((ISO11172_END)&gt;&gt;24);
+        *(index++) = static_cast&lt;uint8_t&gt;((ISO11172_END &amp; 0x00ff0000)&gt;&gt;16);
+        *(index++) = static_cast&lt;uint8_t&gt;((ISO11172_END &amp; 0x0000ff00)&gt;&gt;8);
+        *(index++) = static_cast&lt;uint8_t&gt;(ISO11172_END &amp; 0x000000ff);
+    }
+
+    unsigned int j;
+    for (j = 0; j &lt; mux_strm.zero_stuffing; j++)
+        *(index++) = static_cast&lt;uint8_t&gt;(0);
+	
+
+    /* At this point padding or stuffing will have ensured the packet
+       is filled to target_packet_data_size
+    */ 
+    RawWrite(sector_buf, sector_size);
+    return actual_packet_data_size;
+}
+
+
+
+
+/*************************************************************************
+	Create_Pack
+	erstellt in einem Buffer die spezifischen Pack-Informationen.
+	Diese werden dann spaeter von der Sector-Routine nochmals
+	in dem Sektor kopiert.
+
+	writes specifical pack header information into a buffer
+	later this will be copied from the sector routine into
+	the sector buffer
+*************************************************************************/
+
+void 
+PS_Stream::CreatePack ( Pack_struc	 *pack,
+                        clockticks   SCR,
+                        unsigned int 	 mux_rate
+    )
+{
+    uint8_t *index;
+
+    index = pack-&gt;buf;
+
+    *(index++) = static_cast&lt;uint8_t&gt;((PACK_START)&gt;&gt;24);
+    *(index++) = static_cast&lt;uint8_t&gt;((PACK_START &amp; 0x00ff0000)&gt;&gt;16);
+    *(index++) = static_cast&lt;uint8_t&gt;((PACK_START &amp; 0x0000ff00)&gt;&gt;8);
+    *(index++) = static_cast&lt;uint8_t&gt;(PACK_START &amp; 0x000000ff);
+        
+    if (mpeg_version == 2)
+    {
+        /* Annoying: MPEG-2's SCR pack header time is different from
+           all the rest... */
+        BufferMpeg2ScrTimecode(SCR, index);
+        *(index++) = static_cast&lt;uint8_t&gt;(mux_rate &gt;&gt; 14);
+        *(index++) = static_cast&lt;uint8_t&gt;(0xff &amp; (mux_rate &gt;&gt; 6));
+        *(index++) = static_cast&lt;uint8_t&gt;(0x03 | ((mux_rate &amp; 0x3f) &lt;&lt; 2));
+        *(index++) = (uint8_t)(RESERVED_BYTE &lt;&lt; 3 | 0); /* No pack stuffing */
+    }
+    else
+    {
+        BufferDtsPtsMpeg1ScrTimecode(SCR, MARKER_MPEG1_SCR, index);
+        *(index++) = static_cast&lt;uint8_t&gt;(0x80 | (mux_rate &gt;&gt; 15));
+        *(index++) = static_cast&lt;uint8_t&gt;(0xff &amp; (mux_rate &gt;&gt; 7));
+        *(index++) = static_cast&lt;uint8_t&gt;(0x01 | ((mux_rate &amp; 0x7f) &lt;&lt; 1));
+    }
+    pack-&gt;SCR = SCR;
+    pack-&gt;length = index-pack-&gt;buf;
+}
+
+
+/*************************************************************************
+	Create_Sys_Header
+	erstelle in einem Buffer die spezifischen Sys_Header
+	Informationen. Diese werden spaeter von der Sector-Routine
+	nochmals zum Sectorbuffer kopiert.
+
+	writes specifical system header information into a buffer
+	later this will be copied from the sector routine into
+	the sector buffer
+	RETURN: Length of header created...
+*************************************************************************/
+
+void 
+PS_Stream::CreateSysHeader (	Sys_header_struc *sys_header,
+                                unsigned int	 rate_bound,
+                                bool	 fixed,
+                                int	     CSPS,
+                                bool	 audio_lock,
+                                bool	 video_lock,
+                                vector&lt;MuxStream *&gt; &amp;streams
+    )
+
+{
+    uint8_t *index;
+    uint8_t *len_index;
+    int system_header_size;
+    index = sys_header-&gt;buf;
+    int video_bound = 0;
+    int audio_bound = 0;
+	std::vector&lt;MuxStream *&gt;::iterator str;
+    for( str = streams.begin(); str &lt; streams.end(); ++str )
+    {
+        switch( ((*str)-&gt;stream_id &amp; 0xf0) )
+        {
+        case 0xe0 :             // MPEG Video
+            ++video_bound;
+            break;
+        case 0xb0 :             // DVD seems to use these stream id in
+                                // system headers for buffer size counts
+            if( (*str)-&gt;stream_id == 0xb9 )
+                ++video_bound;   
+            if( (*str)-&gt;stream_id == 0xbd )
+                ++audio_bound;   
+            break;
+        case 0xc0 :
+            ++audio_bound;      // MPEG Audio
+            break;
+        default :
+            break;
+        }
+    }
+
+    /* if we are not using both streams, we should clear some
+       options here */
+
+    *(index++) = static_cast&lt;uint8_t&gt;((SYS_HEADER_START)&gt;&gt;24);
+    *(index++) = static_cast&lt;uint8_t&gt;((SYS_HEADER_START &amp; 0x00ff0000)&gt;&gt;16);
+    *(index++) = static_cast&lt;uint8_t&gt;((SYS_HEADER_START &amp; 0x0000ff00)&gt;&gt;8);
+    *(index++) = static_cast&lt;uint8_t&gt;(SYS_HEADER_START &amp; 0x000000ff);
+
+    len_index = index;	/* Skip length field for now... */
+    index +=2;
+
+    *(index++) = static_cast&lt;uint8_t&gt;(0x80 | (rate_bound &gt;&gt;15));
+    *(index++) = static_cast&lt;uint8_t&gt;(0xff &amp; (rate_bound &gt;&gt; 7));
+    *(index++) = static_cast&lt;uint8_t&gt;(0x01 | ((rate_bound &amp; 0x7f)&lt;&lt;1));
+    *(index++) = static_cast&lt;uint8_t&gt;((audio_bound &lt;&lt; 2)|(fixed &lt;&lt; 1)|CSPS);
+    *(index++) = static_cast&lt;uint8_t&gt;((audio_lock &lt;&lt; 7)|
+                                      (video_lock &lt;&lt; 6)|0x20|video_bound);
+
+    *(index++) = static_cast&lt;uint8_t&gt;(RESERVED_BYTE);
+    for( str = streams.begin(); str &lt; streams.end(); ++str )
+    {
+        *(index++) = (*str)-&gt;stream_id;
+        *(index++) = static_cast&lt;uint8_t&gt; 
+            (0xc0 |
+             ((*str)-&gt;BufferScale() &lt;&lt; 5) | ((*str)-&gt;BufferSizeCode() &gt;&gt; 8));
+        *(index++) = static_cast&lt;uint8_t&gt;((*str)-&gt;BufferSizeCode() &amp; 0xff);
+    }
+
+
+    system_header_size = (index - sys_header-&gt;buf);
+    len_index[0] = static_cast&lt;uint8_t&gt;((system_header_size-6) &gt;&gt; 8);
+    len_index[1] = static_cast&lt;uint8_t&gt;((system_header_size-6) &amp; 0xff);
+    sys_header-&gt;length = system_header_size;
+}
+
+
+
+
+/* 
+ * Local variables:
+ *  c-file-style: &quot;stroustrup&quot;
+ *  tab-width: 4
+ *  indent-tabs-mode: nil
+ * End:
+ */

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/systems.hpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/systems.hpp	2009-09-04 15:59:41 UTC (rev 5319)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/systems.hpp	2009-09-05 08:19:09 UTC (rev 5320)
@@ -0,0 +1,158 @@
+
+/*
+ *  interact.h:  Program/System stream packet generator
+ *
+ *  Copyright (C) 2003 Andrew Stevens &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">andrew.stevens at philips.com</A>&gt;
+ *
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of version 2 of the GNU General Public License
+ *  as published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+#ifndef __SYSTEMS_HH__
+#define __SYSTEMS_HH__
+
+#include &quot;inputstrm.hpp&quot;
+#include &quot;outputstrm.hpp&quot;
+#include &lt;vector&gt;
+
+using std::vector;
+
+/* Buffer size parameters */
+
+#define MAX_SECTOR_SIZE         16384
+#define MAX_PACK_HEADER_SIZE	255
+#define MAX_SYS_HEADER_SIZE     255
+
+
+typedef struct sector_struc	/* Ein Sektor, kann Pack, Sys Header	*/
+/* und Packet enthalten.		*/
+{   unsigned char  buf [MAX_SECTOR_SIZE] ;
+  unsigned int   length_of_packet_data ;
+  //clockticks TS                ;
+} Sector_struc;
+
+struct Pack_struc	/* Pack Info				*/
+{ 
+    uint8_t buf[MAX_PACK_HEADER_SIZE];
+    int length;
+    clockticks SCR;
+};
+
+struct Sys_header_struc	/* System Header Info			*/
+{   
+    uint8_t buf[MAX_SYS_HEADER_SIZE];
+    int length;
+};
+
+
+class PS_Stream
+{
+public:
+    PS_Stream( unsigned _mpeg,
+               unsigned int _sector_size,
+               OutputStream &amp;_output_strm, 
+               off_t max_segment_size // 0 = No Limit
+        );
+    virtual ~PS_Stream();
+
+    unsigned int PacketPayload( MuxStream &amp;strm,
+                                Sys_header_struc *sys_header, 
+                                Pack_struc *pack_header, 
+                                int buffers, int PTSstamp, int DTSstamp );
+
+    unsigned int CreateSector (Pack_struc	 	 *pack,
+                               Sys_header_struc *sys_header,
+                               unsigned int     max_packet_data_size,
+                               MuxStream        &amp;strm,
+                               bool 	 buffers,
+                               bool      end_marker,
+                               clockticks   	 PTS,
+                               clockticks   	 DTS,
+                               uint8_t 	 timestamps
+        );
+    static void BufferSectorHeader( uint8_t *buf,
+                             Pack_struc	 	 *pack,
+                             Sys_header_struc *sys_header,
+                             uint8_t *&amp;header_end );
+    static void BufferPacketHeader( uint8_t *buf,
+                                    uint8_t type,
+                                    unsigned int mpeg_version,
+                                    bool buffers,
+                                    unsigned int buffer_size,
+                                    uint8_t buffer_scale,
+                                    clockticks   	 PTS,
+                                    clockticks   	 DTS,
+                                    uint8_t 	 timestamps,
+                                    unsigned int min_pes_hdr_len,
+                                    uint8_t     *&amp;size_field,
+                                    uint8_t     *&amp;header_end );
+    
+    static inline void 
+    BufferPacketSize( uint8_t *size_field, uint8_t *packet_end )
+        {
+            unsigned int packet_size = packet_end-size_field-2;
+            size_field[0] = static_cast&lt;uint8_t&gt;(packet_size&gt;&gt;8);
+            size_field[1] = static_cast&lt;uint8_t&gt;(packet_size&amp;0xff);
+
+        }
+
+    virtual void CreatePack ( Pack_struc	 *pack,
+                      clockticks   SCR,
+                      unsigned int 	 mux_rate
+        );
+    virtual void CreateSysHeader ( Sys_header_struc *sys_header,
+                           unsigned int	 rate_bound,
+                           bool	 fixed,
+                           int	     CSPS,
+                           bool	 audio_lock,
+                           bool	 video_lock,
+                           vector&lt;MuxStream *&gt; &amp;streams
+        );
+
+    inline int Open() { return output_strm.Open(); }
+    inline void Close() { output_strm.Close(); }
+    inline void RawWrite(uint8_t *data, unsigned int len)
+        {
+            return output_strm.Write( data, len );
+        }
+    inline void NextSegment() { output_strm.NextSegment(); }
+    bool SegmentLimReached();
+
+
+private:
+    static void 
+    BufferDtsPtsMpeg1ScrTimecode (clockticks    timecode,
+                                  uint8_t  marker,
+                                  uint8_t *&amp;buffer);
+    static void BufferMpeg2ScrTimecode( clockticks    timecode,
+                                        uint8_t *&amp;buffer);
+    void BufferPaddingPacket( int padding,
+                              uint8_t *&amp;buffer );
+private:
+    OutputStream &amp;output_strm; 
+    unsigned int mpeg_version;
+    unsigned int sector_size;
+    off_t max_segment_size;
+    uint8_t *sector_buf;
+};
+#endif // __SYSTEMS_HH__
+
+
+/* 
+ * Local variables:
+ *  c-file-style: &quot;stroustrup&quot;
+ *  tab-width: 4
+ *  indent-tabs-mode: nil
+ * End:
+ */

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/videostrm.hpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/videostrm.hpp	2009-09-04 15:59:41 UTC (rev 5319)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/videostrm.hpp	2009-09-05 08:19:09 UTC (rev 5320)
@@ -0,0 +1,153 @@
+
+/*
+ *  videostrm.hpp:  Video stream elementary input stream
+ *
+ *  Copyright (C) 2001 Andrew Stevens &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">andrew.stevens at philips.com</A>&gt;
+ *
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of version 2 of the GNU General Public License
+ *  as published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+#ifndef __VIDEOSTRM_H__
+#define __VIDEOSTRM_H__
+
+#include &quot;inputstrm.hpp&quot;
+#include &quot;interact.hpp&quot;
+#include &quot;stream_params.hpp&quot;
+
+class VideoStream : public ElementaryStream
+{
+public:
+	VideoStream(IBitStream &amp;ibs, VideoParams *parms, 
+                Multiplexor &amp;into);
+	void Init( const int stream_num );
+
+    static bool Probe(IBitStream &amp;bs );
+
+	void Close();
+
+    inline int DecoderOrder() { return au-&gt;dorder; }
+	inline int AUType()	{ return au-&gt;type; }
+
+    bool SeqEndRunOut();
+
+    const AUnit *NextIFrame();
+
+
+	inline int NextAUType()
+		{
+			AUnit *p_au = Lookahead();
+			if( p_au != 0 )
+				return p_au-&gt;type;
+			else
+				return NOFRAME;
+		}
+
+
+	virtual unsigned int NominalBitRate() 
+		{ 
+			return bit_rate * 400;
+		}
+
+    virtual void OutputGOPControlSector();
+	bool RunOutComplete();
+	virtual bool MuxPossible(clockticks currentSCR);
+    virtual void AUMuxed( bool first_in_sector ) ;
+
+    void SetMaxStdBufferDelay( unsigned int demux_rate );
+	void OutputSector();
+
+
+protected:
+    static const unsigned int MAX_GOP_LENGTH = 128;
+	void OutputSeqhdrInfo();
+	virtual void FillAUbuffer(unsigned int frames_to_buffer);
+	virtual void NextDTSPTS(  );
+	void ScanFirstSeqHeader();
+    uint8_t NewAUTimestamps( int AUtype );
+    bool NewAUBuffers( int AUtype );
+
+    unsigned int ExcludeNextIFramePayload();
+
+public:	
+    unsigned int num_sequence 	;
+    unsigned int num_seq_end	;
+    unsigned int num_pictures 	;
+    unsigned int num_groups 	;
+    unsigned int num_frames[4] 	;
+         int64_t avg_frames[4]  ;
+    
+    unsigned int horizontal_size;
+    unsigned int vertical_size 	;
+     unsigned int aspect_ratio	;
+    unsigned int picture_rate	;
+    unsigned int bit_rate 	;
+    unsigned int vbv_buffer_size;
+    unsigned int CSPF 		;
+    double secs_per_frame;
+
+	
+	bool dtspts_for_all_au;     // Ensure every AU has a timestamp 
+                                // (no two AU can start in one sector)
+    bool gop_control_packet;
+
+protected:
+
+
+	/* State variables for scanning source bit-stream */
+    AUnit access_unit;
+	int fields_presented;
+    int group_start_pic;
+	int group_start_field;
+    int group_start_SCR;
+    int temporal_reference;
+    unsigned int pict_struct;
+	int pulldown_32;
+	int repeat_first_field;
+	int prev_temp_ref;
+    int ref_present;
+    int prev_ref_present;
+    double frame_rate;
+	double max_bits_persec;
+	int AU_pict_data;
+	int AU_hdr;
+    clockticks max_STD_buffer_delay;
+    VideoParams *parms;
+}; 	
+
+//
+// DVD's generate control sectors for each GOP...
+//
+
+class DVDVideoStream : public VideoStream
+{
+public:
+	DVDVideoStream(IBitStream &amp;ibs,VideoParams *parms,Multiplexor &amp;into) : 
+        VideoStream( ibs, parms, into )
+        {
+            gop_control_packet = true;
+        }
+    void OutputGOPControlSector();  
+};
+
+#endif // __INPUTSTRM_H__
+
+
+/* 
+ * Local variables:
+ *  c-file-style: &quot;stroustrup&quot;
+ *  tab-width: 4
+ *  indent-tabs-mode: nil
+ * End:
+ */

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/videostrm_in.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/videostrm_in.cpp	2009-09-04 15:59:41 UTC (rev 5319)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/videostrm_in.cpp	2009-09-05 08:19:09 UTC (rev 5320)
@@ -0,0 +1,498 @@
+/*
+ *  inptstrm.c:  Members of video stream class related to raw stream
+ *               scanning and buffering.
+ *
+ *  Copyright (C) 2001 Andrew Stevens &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">andrew.stevens at philips.com</A>&gt;
+ *
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of version 2 of the GNU General Public License
+ *  as published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+#include &lt;config.h&gt;
+#include &lt;math.h&gt;
+#include &lt;stdlib.h&gt;
+
+#include &quot;videostrm.hpp&quot;
+#include &quot;interact.hpp&quot;
+#include &quot;multiplexor.hpp&quot;
+
+
+
+static void marker_bit (IBitStream &amp;bs, unsigned int what)
+{
+    if (what != bs.Get1Bit())
+    {
+        mjpeg_error (&quot;Illegal MPEG stream at offset (bits) %lld: supposed marker bit not found.&quot;,bs.bitcount());
+        exit (1);
+    }
+}
+
+
+void VideoStream::ScanFirstSeqHeader()
+{
+    if (bs.GetBits( 32)==SEQUENCE_HEADER)
+    {
+		num_sequence++;
+		horizontal_size	= bs.GetBits( 12);
+		vertical_size	= bs.GetBits( 12);
+		aspect_ratio	= bs.GetBits(  4);
+		picture_rate 	= bs.GetBits(  4);
+		bit_rate		= bs.GetBits( 18);
+		marker_bit( bs, 1);
+		vbv_buffer_size	= bs.GetBits( 10);
+		CSPF		= bs.Get1Bit();
+
+    } else
+    {
+		mjpeg_error (&quot;Invalid MPEG Video stream header.&quot;);
+		exit (1);
+    }
+
+	if (MX_mpeg_valid_framerate_code(picture_rate))
+    {
+		frame_rate = Y4M_RATIO_DBL(MX_mpeg_framerate(picture_rate));
+	}
+    else
+    {
+		frame_rate = 25.0;
+	}
+
+}
+
+
+
+
+void VideoStream::Init ( const int stream_num )
+{
+	mjpeg_debug( &quot;SETTING video buffer to %d&quot;, parms-&gt;DecodeBufferSize() );
+	MuxStream::Init( VIDEO_STR_0+stream_num,
+					 1,  // Buffer scale
+					 parms-&gt;DecodeBufferSize()*1024,
+					 0,  // Zero stuffing
+					 muxinto.buffers_in_video,
+					 muxinto.always_buffers_in_video);
+    mjpeg_info( &quot;Scanning for header info: Video stream %02x (%s) &quot;,
+                VIDEO_STR_0+stream_num,
+                bs.StreamName()
+                );
+
+	SetBufSize( 4*1024*1024 );
+	ScanFirstSeqHeader();
+
+	/* Skip to the end of the 1st AU (*2nd* Picture start!)
+	*/
+	AU_hdr = SEQUENCE_HEADER;
+	AU_pict_data = 0;
+	AU_start = 0;
+    
+    fields_presented = 0;
+    group_start_pic = 0;
+    group_start_field = 0;
+    OutputSeqhdrInfo();
+}
+
+//
+// Set the Maximum STD buffer delay for this video stream.
+// By default we set 1 second but if we have specified a video
+// buffer that can hold more than 1.0 seconds demuxed data we
+// set the delay to the time to fill the buffer.
+//
+
+void VideoStream::SetMaxStdBufferDelay( unsigned int dmux_rate )
+{
+    double max_delay = CLOCKS;
+    if( static_cast&lt;double&gt;(BufferSize()) / dmux_rate &gt; 1.0 )
+        max_delay *= static_cast&lt;double&gt;(BufferSize()) / dmux_rate;
+
+    //
+    // To enforce a maximum STD buffer residency the
+    // calculation is a bit tricky as when we decide to mux we may
+    // (but not always) have some of the *previous* picture left to
+    // mux in which case it is the timestamp of the next picture that counts.
+    // For simplicity we simply reduce the limit by 1.5 frame intervals
+    // and use the timestamp for the current picture.
+    //
+    if( frame_rate &gt; 10.0 )
+        max_STD_buffer_delay = static_cast&lt;clockticks&gt;(max_delay * (frame_rate-1.5)/frame_rate);
+    else
+        max_STD_buffer_delay = static_cast&lt;clockticks&gt;(10.0 * max_delay / frame_rate);
+
+}
+
+
+//
+// Refill the AU unit buffer setting  AU PTS DTS from the scanned
+// header information...
+//
+
+void VideoStream::FillAUbuffer(unsigned int frames_to_buffer)
+{
+    if( eoscan )
+        return;
+
+	last_buffered_AU += frames_to_buffer;
+	mjpeg_debug( &quot;Scanning %d video frames to start of frame %d&quot;, 
+				 frames_to_buffer, last_buffered_AU );
+
+    // We set a limit of 2M to seek before we give up.
+    // This is intentionally very high because some heavily
+    // padded still frames may have a loooong gap before
+    // a following sequence end marker.
+    // IMPORTANT: SeekSync *must* come last otherwise a header
+    // will be lost!!!!
+	while(!bs.eos() 
+          &amp;&amp; decoding_order &lt; last_buffered_AU  
+          &amp;&amp; !muxinto.AfterMaxPTS(access_unit.PTS)
+		  &amp;&amp; bs.SeekSync( SYNCWORD_START, 24, 2*1024*1024)
+		)
+	{
+		syncword = (SYNCWORD_START&lt;&lt;8) + bs.GetBits( 8);
+		if( AU_pict_data )
+		{
+			
+			/* Handle the header *ending* an AU...
+			   If we have the AU picture data an AU and have now
+			   reached a header marking the end of an AU fill in the
+			   the AU length and append it to the list of AU's and
+			   start a new AU.  I.e. sequence and gop headers count as
+			   part of the AU of the corresponding picture
+			*/
+			stream_length = bs.bitcount()-static_cast&lt;bitcount_t&gt;(32);
+			switch (syncword) 
+			{
+			case SEQUENCE_HEADER :
+                mjpeg_debug( &quot;Seq hdr @ %lld&quot;, bs.bitcount() / 8-4 );
+			case GROUP_START :
+                mjpeg_debug( &quot;Group hdr @ %lld&quot;, bs.bitcount() / 8-4 );
+			case PICTURE_START :
+				access_unit.start = AU_start;
+				access_unit.length = static_cast&lt;int&gt;(stream_length - AU_start)&gt;&gt;3;
+				access_unit.end_seq = 0;
+				avg_frames[access_unit.type-1]+=access_unit.length;
+				mjpeg_debug( &quot;AU %d %d %d @ %lld: DTS=%ud&quot;, 
+                             decoding_order,
+                             access_unit.type,
+                             access_unit.length,
+                             bs.bitcount() / 8-4,
+							 static_cast&lt;unsigned int&gt;(access_unit.DTS/300) );
+
+
+				aunits.Append( access_unit );					
+                decoding_order++;
+				AU_hdr = syncword;
+				AU_start = stream_length;
+				AU_pict_data = 0;
+				break;
+			case SEQUENCE_END:
+				access_unit.length = ((stream_length - AU_start)&gt;&gt;3)+4;
+				access_unit.end_seq = 1;
+				aunits.Append( access_unit );
+				mjpeg_info( &quot;Scanned to end AU %d&quot;, access_unit.dorder );
+				avg_frames[access_unit.type-1]+=access_unit.length;
+
+				/* Do we have a sequence split in the video stream? */
+				if( !bs.eos() &amp;&amp; 
+					bs.GetBits( 32) ==SEQUENCE_HEADER )
+				{
+					stream_length = bs.bitcount()-static_cast&lt;bitcount_t&gt;(32);
+					AU_start = stream_length;
+					syncword  = AU_hdr = SEQUENCE_HEADER;
+					AU_pict_data = 0;
+					if( !muxinto.split_at_seq_end )
+						mjpeg_warn(&quot;Sequence end marker found in video stream but single-segment splitting specified!&quot; );
+				}
+				else
+				{
+					if( !bs.eos() &amp;&amp; muxinto.split_at_seq_end )
+						mjpeg_warn(&quot;No seq. header starting new sequence after seq. end!&quot;);
+				}
+                decoding_order++;
+				num_seq_end++;
+				break;
+			}
+		}
+
+		/* Handle the headers starting an AU... */
+		switch (syncword) 
+		{
+		case SEQUENCE_HEADER:
+			/* TODO: Really we should update the info here so we can handle
+			 streams where parameters change on-the-fly... */
+			num_sequence++;
+			break;
+			
+		case GROUP_START:
+			num_groups++;
+			break;
+			
+		case PICTURE_START:
+			/* We have reached AU's picture data... */
+			AU_pict_data = 1;
+            mjpeg_debug( &quot;Picture start @ %lld&quot;, bs.bitcount() / 8-4 );
+			
+            prev_temp_ref = temporal_reference;
+			temporal_reference = bs.GetBits( 10);
+			access_unit.type   = bs.GetBits( 3);
+
+			/* Now scan forward a little for an MPEG-2 picture coding extension
+			   so we can get pulldown info (if present) */
+			if( bs.SeekSync(EXT_START_CODE, 32, 64) &amp;&amp;
+                bs.GetBits(4) == CODING_EXT_ID)
+			{
+				/* Skip: 4 F-codes (4)... */
+				(void)bs.GetBits(16); 
+                /* Skip: DC Precision(2) */
+                (void)bs.GetBits(2);
+                pict_struct = bs.GetBits(2);
+                /* Skip: topfirst (1) frame pred dct (1),
+                   concealment_mv(1), q_scale_type (1), */
+				(void)bs.GetBits(4);	
+				/* Skip: intra_vlc_format(1), alternate_scan (1) */
+				(void)bs.GetBits(2);	
+				repeat_first_field = bs.Get1Bit();
+				pulldown_32 |= repeat_first_field;
+
+			}
+			else
+			{
+				repeat_first_field = 0;
+                pict_struct = PIC_FRAME;
+			}
+				
+			if( access_unit.type == IFRAME )
+			{
+                double bits_persec = 
+                    static_cast&lt;double&gt;( stream_length - prev_offset) 
+                    * 2.0 * frame_rate  
+                    / static_cast&lt;double&gt;(fields_presented - group_start_field);
+                
+				if( bits_persec &gt; max_bits_persec )
+				{
+					max_bits_persec = bits_persec;
+				}
+				prev_offset = stream_length;
+				group_start_pic = decoding_order;
+				group_start_field = fields_presented;
+			}
+
+			NextDTSPTS( );
+
+			access_unit.dorder = decoding_order;
+			access_unit.porder = temporal_reference + group_start_pic;
+
+			access_unit.seq_header = ( AU_hdr == SEQUENCE_HEADER);
+
+			if ((access_unit.type&gt;0) &amp;&amp; (access_unit.type&lt;5))
+			{
+				num_frames[access_unit.type-1]++;
+			}
+
+			
+			if ( decoding_order &gt;= old_frames+1000 )
+			{
+				mjpeg_debug(&quot;Got %d picture headers.&quot;, decoding_order);
+				old_frames = decoding_order;
+			}
+			
+			break;		    
+
+  
+				
+		}
+	}
+
+	last_buffered_AU = decoding_order;
+	num_pictures = decoding_order;	
+	eoscan = bs.eos() || muxinto.AfterMaxPTS(access_unit.PTS);
+}
+
+void VideoStream::Close()
+{
+    unsigned int comp_bit_rate	;
+    unsigned int peak_bit_rate  ;
+
+    stream_length = bs.bitcount() / 8;
+    for( int i=0; i&lt;4; i++)
+	{
+		avg_frames[i] /= num_frames[i] == 0 ? 1 : num_frames[i];
+	}
+
+	/* Average and Peak bit rate in 50B/sec units... */
+    comp_bit_rate = 
+        static_cast&lt;unsigned int&gt;( static_cast&lt;unsigned int&gt;( stream_length / fields_presented * 2 ) 
+                                   * frame_rate  + 25) / 50;
+
+	peak_bit_rate = static_cast&lt;unsigned int&gt;((max_bits_persec / 8 + 25) / 50);
+	mjpeg_info (&quot;VIDEO_STATISTICS: %02x&quot;, stream_id); 
+    mjpeg_info (&quot;Video Stream length: %11llu bytes&quot;, stream_length);
+    mjpeg_info (&quot;Sequence headers: %8u&quot;,num_sequence);
+    mjpeg_info (&quot;Sequence ends   : %8u&quot;,num_seq_end);
+    mjpeg_info (&quot;No. Pictures    : %8u&quot;,num_pictures);
+    mjpeg_info (&quot;No. Groups      : %8u&quot;,num_groups);
+    mjpeg_info (&quot;No. I Frames    : %8u avg. size%6u bytes&quot;,
+			  num_frames[0], (uint32_t)avg_frames[0]);
+    mjpeg_info (&quot;No. P Frames    : %8u avg. size%6u bytes&quot;,
+			  num_frames[1], (uint32_t)avg_frames[1]);
+    mjpeg_info (&quot;No. B Frames    : %8u avg. size%6u bytes&quot;,
+			  num_frames[2], (uint32_t)avg_frames[2]);
+    mjpeg_info(&quot;Average bit-rate : %8u bits/sec&quot;,comp_bit_rate*400);
+    mjpeg_info(&quot;Peak bit-rate    : %8u  bits/sec&quot;,peak_bit_rate*400);
+	
+}
+	
+
+
+
+/*************************************************************************
+	OutputSeqHdrInfo
+     Display sequence header parameters
+*************************************************************************/
+
+void VideoStream::OutputSeqhdrInfo ()
+{
+	const char *str;
+	mjpeg_info(&quot;VIDEO STREAM: %02x&quot;, stream_id);
+
+    mjpeg_info (&quot;Frame width     : %u&quot;,horizontal_size);
+    mjpeg_info (&quot;Frame height    : %u&quot;,vertical_size);
+	if (MX_mpeg_valid_aspect_code(muxinto.mpeg, aspect_ratio))
+		str =  MX_mpeg_aspect_code_definition(muxinto.mpeg,aspect_ratio);
+	else
+		str = &quot;forbidden&quot;;
+    mjpeg_info (&quot;Aspect ratio    : %s&quot;, str );
+				
+
+    if (picture_rate == 0)
+		mjpeg_info( &quot;Picture rate    : forbidden&quot;);
+    else if (MX_mpeg_valid_framerate_code(picture_rate))
+		mjpeg_info( &quot;Picture rate    : %2.3f frames/sec&quot;,
+					Y4M_RATIO_DBL(MX_mpeg_framerate(picture_rate)) );
+    else
+		mjpeg_info( &quot;Picture rate    : %x reserved&quot;,picture_rate);
+
+    if (bit_rate == 0x3ffff)
+		{
+			bit_rate = 0;
+			mjpeg_info( &quot;Bit rate        : variable&quot;); 
+		}
+    else if (bit_rate == 0)
+		mjpeg_info( &quot;Bit rate       : forbidden&quot;);
+    else
+		mjpeg_info( &quot;Bit rate        : %u bits/sec&quot;,
+					bit_rate*400);
+
+    mjpeg_info(&quot;Vbv buffer size : %u bytes&quot;,vbv_buffer_size*2048);
+    mjpeg_info(&quot;CSPF            : %u&quot;,CSPF);
+}
+
+//
+// Compute PTS DTS of current AU in the video sequence being
+// scanned.  This is is the PTS/DTS calculation for normal video only.
+// It is virtual and over-ridden for non-standard streams (Stills
+// etc!).
+//
+
+int gopfields_32pd( int temporal_ref, bool repeat_first_field )
+{
+    int frames2field;
+    int frames3field;
+    //
+    // Assume first presented frame of GOP has temporal ref 0
+    if( repeat_first_field )
+    {
+        frames2field = (temporal_ref+1) / 2;
+        frames3field = temporal_ref / 2;
+    }
+    else
+    {
+        frames2field = (temporal_ref) / 2;
+        frames3field = (temporal_ref+1) / 2;
+    }
+
+    return frames2field*2 + frames3field*3;
+
+}
+
+/****************************************************
+ *
+ * Work out DTS PTS stamps for the current AU.
+ * Note: Current strategy assumes decoders model 'ideal'
+ * timing with instantaneous decoding.
+ * This makes sense it is what is assumed for B-frames anyway
+ * (no seperate DTS).
+ *
+ ******************************************************/
+
+void VideoStream::NextDTSPTS()
+{
+    const int decode_delay = 0;
+    int startup_skew = 2;
+    int decode_fields, present_fields;
+    if( pict_struct != PIC_FRAME )
+    {
+		decode_fields = fields_presented;
+        present_fields = temporal_reference*2 + group_start_field+decode_delay/2;
+        if( temporal_reference == prev_temp_ref )
+            present_fields += 1;
+        fields_presented += 1;
+    }	
+    else if( pulldown_32 )
+	{
+        present_fields = group_start_field  + startup_skew + decode_delay +
+            gopfields_32pd( temporal_reference, repeat_first_field );
+        
+        if( decoding_order == 0 )
+        {
+            // Special case... first IFRAME is not decoded during presentation
+            // of previous ref frame but immediately at start
+            decode_fields = 0;
+            prev_ref_present = present_fields ;
+        }
+        else if( access_unit.type == IFRAME || access_unit.type == PFRAME )
+        {
+            decode_fields = prev_ref_present-decode_delay;
+            prev_ref_present = present_fields;
+        }
+        else
+        {
+            decode_fields = present_fields - decode_delay;
+        }
+        fields_presented += repeat_first_field ? 3 : 2;
+	}
+    else
+	{
+        decode_fields = decoding_order*2;
+        present_fields = (temporal_reference + group_start_pic)*2
+            + startup_skew + decode_delay;
+		fields_presented += 2;
+	}
+
+    access_unit.DTS = static_cast&lt;clockticks&gt;
+        (decode_fields * (double)(CLOCKS/2) / frame_rate);
+    
+    access_unit.PTS = static_cast&lt;clockticks&gt;
+        (present_fields * (double)(CLOCKS/2) / frame_rate);
+}
+
+
+
+
+
+/* 
+ * Local variables:
+ *  c-file-style: &quot;stroustrup&quot;
+ *  tab-width: 4
+ *  indent-tabs-mode: nil
+ * End:
+ */

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/videostrm_out.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/videostrm_out.cpp	2009-09-04 15:59:41 UTC (rev 5319)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/videostrm_out.cpp	2009-09-05 08:19:09 UTC (rev 5320)
@@ -0,0 +1,371 @@
+
+/*
+ *  inptstrm.c:  Members of input stream classes related to muxing out into
+ *               the output stream.
+ *
+ *  Copyright (C) 2001 Andrew Stevens &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">andrew.stevens at philips.com</A>&gt;
+ *
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of version 2 of the GNU General Public License
+ *  as published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+
+#include &lt;config.h&gt;
+#include &lt;assert.h&gt;
+
+#include &quot;mjpeg_types.h&quot;
+#include &quot;videostrm.hpp&quot;
+#include &quot;multiplexor.hpp&quot;
+
+VideoStream::VideoStream(IBitStream &amp;ibs, VideoParams *parms, 
+                         Multiplexor &amp;into ) :
+	ElementaryStream( ibs, into, ElementaryStream::video ),
+	num_sequence(0),
+	num_seq_end(0),
+	num_pictures(0),
+	num_groups(0),
+	dtspts_for_all_au( into.dtspts_for_all_vau ),
+    gop_control_packet( false ),
+    parms(parms)
+{
+	prev_offset=0;
+    decoding_order=0;
+	fields_presented=0;
+    group_start_pic=0;
+	group_start_field=0;
+    temporal_reference=0;
+	pulldown_32 = 0;
+    temporal_reference = -1;   // Needed to recognise 2nd field of 1st
+                               // frame in a field pic sequence
+	last_buffered_AU=0;
+	max_bits_persec = 0;
+	AU_hdr = SEQUENCE_HEADER;  /* GOP or SEQ Header starting AU? */
+	for( int i =0; i&lt;4; ++i )
+		num_frames[i] = avg_frames[i] = 0;
+    FRAME_CHUNK = 6;
+		
+}
+
+bool VideoStream::Probe(IBitStream &amp;bs )
+{
+    return bs.GetBits( 32)  == 0x1b3;
+}
+
+/*********************************
+ * Signals when video stream has completed mux run-out specified
+ * in associated mux stream.   Run-out is always to complete GOP's.
+ *********************************/
+
+bool VideoStream::RunOutComplete()
+{
+ 
+	return (au_unsent == 0 || 
+			( muxinto.running_out &amp;&amp;
+			  au-&gt;type == IFRAME &amp;&amp; RequiredPTS() &gt;= muxinto.runout_PTS));
+}
+
+/*********************************
+ * Signals if it is permissible/possible to Mux out a sector from the Stream.
+ * The universal constraints that muxing should not be complete and that
+ * that the reciever buffer should have sufficient it also insists that
+ * the muxed data won't hang around in the receiver buffer for more than
+ * one second.  This is mainly for the benefit of (S)VCD and DVD applications
+ * where long delays mess up random access.
+ *******************************/
+
+bool VideoStream::MuxPossible( clockticks currentSCR )
+{
+	return ( ElementaryStream::MuxPossible(currentSCR) &amp;&amp; 
+             RequiredDTS() &lt; currentSCR + max_STD_buffer_delay );
+}
+
+
+void VideoStream::AUMuxed( bool first_in_sector )
+{
+    //DEBUG
+    //mjpeg_info( &quot;VidMuxed: %d %lld &quot;, au-&gt;dorder, RequiredDTS()/300 );
+}
+
+
+/*********************************
+ * Work out the timestamps to be set in the header of sectors starting
+ * new AU's.
+ *********************************/
+
+uint8_t VideoStream::NewAUTimestamps( int AUtype )
+{
+	uint8_t timestamps;
+    if( AUtype == BFRAME)
+        timestamps=TIMESTAMPBITS_PTS;
+    else 
+        timestamps=TIMESTAMPBITS_PTS_DTS;
+
+    if( muxinto.timestamp_iframe_only &amp;&amp; AUtype != IFRAME)
+        timestamps=TIMESTAMPBITS_NO;
+    return timestamps;
+}
+
+/*********************************
+ * Work out the buffer records to be set in the header of sectors
+ * starting new AU's.
+ *********************************/
+
+bool VideoStream::NewAUBuffers( int AUtype )
+{
+    return buffers_in_header &amp; 
+        !(muxinto.video_buffers_iframe_only &amp;&amp; AUtype != IFRAME);
+}
+
+/********************************
+ *
+ * Check if the next sector could potentially include parts of AUs
+ * following a sequence end marker... in this case a run-out may be needed
+ *
+ *******************************/
+
+bool VideoStream::SeqEndRunOut()
+{
+    unsigned int payload = au_unsent;
+    unsigned int ahead = 0;
+    AUnit *next_au = au;
+    for(;;)
+    {
+        if( next_au-&gt;end_seq || payload &gt;= muxinto.sector_size)
+            break;  
+        ++ahead;
+        next_au = Lookahead(ahead);
+        if( next_au == 0 )
+            break;
+        payload += next_au-&gt;PayloadSize();
+    }
+    
+    // We don't need to start run-out if the next sector cannot contain
+    // next sequence or there is no next sequence (no AU after the one with
+    // the sequence end marker
+    return next_au != 0 &amp;&amp; next_au-&gt;end_seq 
+        &amp;&amp; payload &lt; muxinto.sector_size
+        &amp;&amp; Lookahead(ahead+1) != 0;
+
+}
+
+/********************************
+ *
+ * Check if the next sector could potentially include a seq_end marker
+ *
+ *******************************/
+
+const AUnit *VideoStream::NextIFrame()
+{
+    unsigned int ahead = 0;
+    AUnit *au_ahead = Lookahead(ahead);
+    while( au_ahead != 0 &amp;&amp; au_ahead-&gt;type != IFRAME 
+           &amp;&amp; ahead &lt; MAX_GOP_LENGTH )
+    {
+        ++ahead;
+        au_ahead = Lookahead(ahead);
+    }
+    return au_ahead;
+}
+
+/********************************
+ *
+ * Calculate how much payload can be muxed next sector without
+ * including the next IFRAME.
+ *
+ *******************************/
+
+unsigned int VideoStream::ExcludeNextIFramePayload()
+{
+    unsigned int payload = au_unsent;
+    unsigned int ahead = 0;
+    AUnit *au_ahead;
+    for(;;)
+    {
+        au_ahead = Lookahead(ahead);
+        if( au_ahead == 0 || payload &gt;= muxinto.sector_size || au_ahead-&gt;type == IFRAME )
+            break;
+        payload += au_ahead-&gt;PayloadSize();
+        ++ahead;
+    }
+    assert( eoscan || au_ahead != 0 );
+    return payload;
+}
+
+/******************************************************************
+	Output_Video
+	generiert Pack/Sys_Header/Packet Informationen aus dem
+	Video Stream und speichert den so erhaltenen Sektor ab.
+
+	generates Pack/Sys_Header/Packet information from the
+	video stream and writes out the new sector
+******************************************************************/
+
+void VideoStream::OutputSector ( )
+
+{
+	unsigned int max_packet_payload; 	 
+	unsigned int actual_payload;
+	unsigned int old_au_then_new_payload;
+	clockticks  DTS,PTS;
+    int autype;
+
+	max_packet_payload = 0;	/* 0 = Fill sector */
+  	/* 	
+       I-frame aligning.  For the last AU of segment or for formats
+       with ACCESS-POINT sectors where I-frame (and preceding headers)
+       are sector aligned.
+
+       We need to look ahead to see how much we may put into the current packet
+       without without touching the next I-frame (which is supposed to be
+       placed at the start of its own sector).
+
+       N.b.runout_PTS is the PTS of the after which the next I frame
+       marks the start of the next sequence.
+	*/
+    
+    /* TODO finish this: Need to look-ahead sufficiently far to
+       guarantee finding an I-FRAME even if its predecessors are very
+       small.  
+    */
+	if( muxinto.sector_align_iframeAUs || muxinto.running_out )
+	{
+		max_packet_payload = ExcludeNextIFramePayload();
+	}
+
+	/* Figure out the threshold payload size below which we can fit more
+	   than one AU into a packet N.b. because fitting more than one in
+	   imposses an overhead of additional header fields so there is a
+	   dead spot where we *have* to stuff the packet rather than start
+	   fitting in an extra AU.  Slightly over-conservative in the case
+	   of the last packet...  */
+
+	old_au_then_new_payload = muxinto.PacketPayload( *this,
+					buffers_in_header, 
+					true, true);
+
+	/* CASE: Packet starts with new access unit			*/
+	if (new_au_next_sec  )
+	{
+        autype = AUType();
+        //
+        // Some types of output format (e.g. DVD) require special
+        // control sectors before the sector starting a new GOP
+        // N.b. this implies muxinto.sector_align_iframeAUs
+        //
+        if( gop_control_packet &amp;&amp; autype == IFRAME )
+        {
+            OutputGOPControlSector();
+        }
+
+        //
+        // If we demand every AU should have its own timestamp
+        // We can't start two in the same sector...
+        //
+        if(  dtspts_for_all_au  &amp;&amp; max_packet_payload == 0 )
+            max_packet_payload = au_unsent;
+
+        PTS = RequiredPTS();
+        DTS = RequiredDTS();
+		actual_payload =
+			muxinto.WritePacket ( max_packet_payload,
+						*this,
+						NewAUBuffers(autype), 
+                                  		PTS, DTS,
+						NewAUTimestamps(autype) );
+
+	}
+
+	/* CASE: Packet begins with old access unit, no new one	*/
+	/*	     can begin in the very same packet					*/
+
+	else if ( au_unsent &gt;= old_au_then_new_payload ||
+              (max_packet_payload != 0 &amp;&amp; au_unsent &gt;= max_packet_payload) )
+	{
+		actual_payload = 
+			muxinto.WritePacket( au_unsent,
+							*this,
+							false, 0, 0,
+							TIMESTAMPBITS_NO );
+	}
+
+	/* CASE: Packet begins with old access unit, a new one	*/
+	/*	     could begin in the very same packet			*/
+	else /* if ( !new_au_next_sec  &amp;&amp; 
+			(au_unsent &lt; old_au_then_new_payload)) */
+	{
+		/* Is there a new access unit ? */
+		if( Lookahead() != 0 )
+		{
+            autype = NextAUType();
+			if(  dtspts_for_all_au  &amp;&amp; max_packet_payload == 0 )
+				max_packet_payload = au_unsent + Lookahead()-&gt;length;
+
+			PTS = NextRequiredPTS();
+			DTS = NextRequiredDTS();
+
+			actual_payload = 
+				muxinto.WritePacket ( max_packet_payload,
+						*this,
+						NewAUBuffers(autype), 
+                                      		PTS, DTS,
+						NewAUTimestamps(autype) );
+		} 
+		else
+		{
+			actual_payload = muxinto.WritePacket ( au_unsent, 
+							*this, false, 0, 0,
+							TIMESTAMPBITS_NO);
+		}
+	}
+	++nsec;
+	buffers_in_header = always_buffers_in_header;
+}
+
+
+/***********************************************
+   OutputControlSector - Write control sectors prefixing a GOP
+   For &quot;normal&quot; video streams this doesn't happen and so represents
+   a bug and triggers an abort.
+
+   In DVD's these sectors carry a system header and what is
+   presumably indexing and/or sub-title information in
+   private_stream_2 packets.  I have no idea what to put in here so we
+   simply pad the sector out.
+***********************************************/
+
+void VideoStream::OutputGOPControlSector()
+{
+    abort();
+}
+
+ /******************************************************************
+ *	OutputGOPControlSector
+ *  DVD System headers are carried in peculiar sectors carrying 2
+ *  PrivateStream2 packets.   We're sticking 0's in the packets
+ *  as we have no idea what's supposed to be in there.
+ ******************************************************************/
+
+void DVDVideoStream::OutputGOPControlSector()
+{
+    muxinto.OutputDVDPriv2 ();
+}
+
+
+/* 
+ * Local variables:
+ *  c-file-style: &quot;stroustrup&quot;
+ *  tab-width: 4
+ *  indent-tabs-mode: nil
+ * End:
+ */

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/yuv4mpeg.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/yuv4mpeg.c	2009-09-04 15:59:41 UTC (rev 5319)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/yuv4mpeg.c	2009-09-05 08:19:09 UTC (rev 5320)
@@ -0,0 +1,1334 @@
+/*
+ *  yuv4mpeg.c:  Functions for reading and writing &quot;new&quot; YUV4MPEG streams
+ *
+ *  Copyright (C) 2001 Matthew J. Marjanovic &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">maddog at mir.com</A>&gt;
+ *
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU General Public License
+ *  as published by the Free Software Foundation; either version 2
+ *  of the License, or (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ *
+ */
+#define ADM_LEGACY_PROGGY
+#include &quot;ADM_default.h&quot;
+#define INTERNAL_Y4M_LIBCODE_STUFF_QPX
+#include &quot;yuv4mpeg.h&quot;
+#include &quot;yuv4mpeg_intern.h&quot;
+#include &quot;mjpeg_logging.h&quot;
+
+
+static int _y4mparam_allow_unknown_tags = 1;  /* default is forgiveness */
+static int _y4mparam_feature_level = 0;       /* default is ol YUV4MPEG2 */
+
+static void *(*_y4m_alloc)(size_t bytes) = malloc;
+static void (*_y4m_free)(void *ptr) = free;
+
+
+
+int y4m_allow_unknown_tags(int yn)
+{
+  int old = _y4mparam_allow_unknown_tags;
+  if (yn &gt;= 0)
+    _y4mparam_allow_unknown_tags = (yn) ? 1 : 0;
+  return old;
+}
+
+
+int y4m_accept_extensions(int level)
+{
+  int old = _y4mparam_feature_level;
+  if (level &gt;= 0)
+    _y4mparam_feature_level = level;
+  return old;
+}
+
+
+
+/*************************************************************************
+ *
+ * Convenience functions for fd read/write
+ *
+ *   - guaranteed to transfer entire payload (or fail)
+ *   - returns:
+ *               0 on complete success
+ *               +(# of remaining bytes) on eof (for y4m_read)
+ *               -(# of rem. bytes) on error (and ERRNO should be set)
+ *     
+ *************************************************************************/
+
+
+ssize_t y4m_read(int fd, void *buf, size_t len)
+{
+   ssize_t n;
+   uint8_t *ptr = (uint8_t *)buf;
+
+   while (len &gt; 0) {
+     n = read(fd, ptr, len);
+     if (n &lt;= 0) {
+       /* return amount left to read */
+       if (n == 0)
+	 return len;  /* n == 0 --&gt; eof */
+       else
+	 return -len; /* n &lt; 0 --&gt; error */
+     }
+     ptr += n;
+     len -= n;
+   }
+   return 0;
+}
+
+
+ssize_t y4m_write(int fd, const void *buf, size_t len)
+{
+   ssize_t n;
+   const uint8_t *ptr = (const uint8_t *)buf;
+
+   while (len &gt; 0) {
+     n = write(fd, ptr, len);
+     if (n &lt;= 0) return -len;  /* return amount left to write */
+     ptr += n;
+     len -= n;
+   }
+   return 0;
+}
+
+
+
+
+/*************************************************************************
+ *
+ * &quot;Extra tags&quot; handling
+ *
+ *************************************************************************/
+
+
+static char *y4m_new_xtag(void)
+{
+  return _y4m_alloc(Y4M_MAX_XTAG_SIZE * sizeof(char));
+}
+
+
+void y4m_init_xtag_list(y4m_xtag_list_t *xtags)
+{
+  int i;
+  xtags-&gt;count = 0;
+  for (i = 0; i &lt; Y4M_MAX_XTAGS; i++) {
+    xtags-&gt;tags[i] = NULL;
+  }
+}
+
+
+void y4m_fini_xtag_list(y4m_xtag_list_t *xtags)
+{
+  int i;
+  for (i = 0; i &lt; Y4M_MAX_XTAGS; i++) {
+    if (xtags-&gt;tags[i] != NULL) {
+      _y4m_free(xtags-&gt;tags[i]);
+      xtags-&gt;tags[i] = NULL;
+    }
+  }
+  xtags-&gt;count = 0;
+}
+
+
+void y4m_copy_xtag_list(y4m_xtag_list_t *dest, const y4m_xtag_list_t *src)
+{
+  int i;
+  for (i = 0; i &lt; src-&gt;count; i++) {
+    if (dest-&gt;tags[i] == NULL) 
+      dest-&gt;tags[i] = y4m_new_xtag();
+    strncpy(dest-&gt;tags[i], src-&gt;tags[i], Y4M_MAX_XTAG_SIZE);
+  }
+  dest-&gt;count = src-&gt;count;
+}
+
+
+
+static int y4m_snprint_xtags(char *s, int maxn, const y4m_xtag_list_t *xtags)
+{
+  int i, room;
+  
+  for (i = 0, room = maxn - 1; i &lt; xtags-&gt;count; i++) {
+    int n = snprintf(s, room + 1, &quot; %s&quot;, xtags-&gt;tags[i]);
+    if ((n &lt; 0) || (n &gt; room)) return Y4M_ERR_HEADER;
+    s += n;
+    room -= n;
+  }
+  s[0] = '\n';  /* finish off header with newline */
+  s[1] = '\0';  /* ...and end-of-string           */
+  return Y4M_OK;
+}
+
+
+int y4m_xtag_count(const y4m_xtag_list_t *xtags)
+{
+  return xtags-&gt;count;
+}
+
+
+const char *y4m_xtag_get(const y4m_xtag_list_t *xtags, int n)
+{
+  if (n &gt;= xtags-&gt;count)
+    return NULL;
+  else
+    return xtags-&gt;tags[n];
+}
+
+
+int y4m_xtag_add(y4m_xtag_list_t *xtags, const char *tag)
+{
+  if (xtags-&gt;count &gt;= Y4M_MAX_XTAGS) return Y4M_ERR_XXTAGS;
+  if (xtags-&gt;tags[xtags-&gt;count] == NULL) 
+    xtags-&gt;tags[xtags-&gt;count] = y4m_new_xtag();
+  strncpy(xtags-&gt;tags[xtags-&gt;count], tag, Y4M_MAX_XTAG_SIZE);
+  (xtags-&gt;count)++;
+  return Y4M_OK;
+}
+
+
+int y4m_xtag_remove(y4m_xtag_list_t *xtags, int n)
+{
+  int i;
+  char *q;
+
+  if ((n &lt; 0) || (n &gt;= xtags-&gt;count)) return Y4M_ERR_RANGE;
+  q = xtags-&gt;tags[n];
+  for (i = n; i &lt; (xtags-&gt;count - 1); i++)
+    xtags-&gt;tags[i] = xtags-&gt;tags[i+1];
+  xtags-&gt;tags[i] = q;
+  (xtags-&gt;count)--;
+  return Y4M_OK;
+}
+
+
+int y4m_xtag_clearlist(y4m_xtag_list_t *xtags)
+{
+  xtags-&gt;count = 0;
+  return Y4M_OK;
+}
+
+
+int y4m_xtag_addlist(y4m_xtag_list_t *dest, const y4m_xtag_list_t *src)
+{
+  int i, j;
+
+  if ((dest-&gt;count + src-&gt;count) &gt; Y4M_MAX_XTAGS) return Y4M_ERR_XXTAGS;
+  for (i = dest-&gt;count, j = 0;
+       j &lt; src-&gt;count;
+       i++, j++) {
+    if (dest-&gt;tags[i] == NULL) 
+      dest-&gt;tags[i] = y4m_new_xtag();
+    strncpy(dest-&gt;tags[i], src-&gt;tags[i], Y4M_MAX_XTAG_SIZE);
+  }
+  dest-&gt;count += src-&gt;count;
+  return Y4M_OK;
+}  
+
+
+/*************************************************************************
+ *
+ * Creators/destructors for y4m_*_info_t structures
+ *
+ *************************************************************************/
+
+
+void y4m_init_stream_info(y4m_stream_info_t *info)
+{
+  if (info == NULL) return;
+  /* init substructures */
+  y4m_init_xtag_list(&amp;(info-&gt;x_tags));
+  /* set defaults */
+  y4m_clear_stream_info(info);
+}
+
+
+void y4m_clear_stream_info(y4m_stream_info_t *info)
+{
+  if (info == NULL) return;
+  /* clear/initialize info */
+  info-&gt;width = Y4M_UNKNOWN;
+  info-&gt;height = Y4M_UNKNOWN;
+  info-&gt;interlace = Y4M_UNKNOWN;
+  info-&gt;framerate = y4m_fps_UNKNOWN;
+  info-&gt;sampleaspect = y4m_sar_UNKNOWN;
+  if (_y4mparam_feature_level &lt; 1) {
+    info-&gt;chroma = Y4M_CHROMA_420JPEG;
+  } else {
+    info-&gt;chroma = Y4M_UNKNOWN;
+  }
+  y4m_xtag_clearlist(&amp;(info-&gt;x_tags));
+}
+
+
+void y4m_copy_stream_info(y4m_stream_info_t *dest,
+			  const y4m_stream_info_t *src)
+{
+  if ((dest == NULL) || (src == NULL)) return;
+  /* copy info */
+  dest-&gt;width = src-&gt;width;
+  dest-&gt;height = src-&gt;height;
+  dest-&gt;interlace = src-&gt;interlace;
+  dest-&gt;framerate = src-&gt;framerate;
+  dest-&gt;sampleaspect = src-&gt;sampleaspect;
+  dest-&gt;chroma = src-&gt;chroma;
+  y4m_copy_xtag_list(&amp;(dest-&gt;x_tags), &amp;(src-&gt;x_tags));
+}
+
+
+void y4m_fini_stream_info(y4m_stream_info_t *info)
+{
+  if (info == NULL) return;
+  y4m_fini_xtag_list(&amp;(info-&gt;x_tags));
+}
+
+
+void y4m_si_set_width(y4m_stream_info_t *si, int width)
+{
+  si-&gt;width = width;
+}
+
+int y4m_si_get_width(const y4m_stream_info_t *si)
+{ return si-&gt;width; }
+
+void y4m_si_set_height(y4m_stream_info_t *si, int height)
+{
+  si-&gt;height = height; 
+}
+
+int y4m_si_get_height(const y4m_stream_info_t *si)
+{ return si-&gt;height; }
+
+void y4m_si_set_interlace(y4m_stream_info_t *si, int interlace)
+{ si-&gt;interlace = interlace; }
+
+int y4m_si_get_interlace(const y4m_stream_info_t *si)
+{ return si-&gt;interlace; }
+
+void y4m_si_set_framerate(y4m_stream_info_t *si, y4m_ratio_t framerate)
+{ si-&gt;framerate = framerate; }
+
+y4m_ratio_t y4m_si_get_framerate(const y4m_stream_info_t *si)
+{ return si-&gt;framerate; }
+
+void y4m_si_set_sampleaspect(y4m_stream_info_t *si, y4m_ratio_t sar)
+{ si-&gt;sampleaspect = sar; }
+
+y4m_ratio_t y4m_si_get_sampleaspect(const y4m_stream_info_t *si)
+{ return si-&gt;sampleaspect; }
+
+void y4m_si_set_chroma(y4m_stream_info_t *si, int chroma_mode)
+{ si-&gt;chroma = chroma_mode; }
+
+int y4m_si_get_chroma(const y4m_stream_info_t *si)
+{ return si-&gt;chroma; }
+
+
+int y4m_si_get_plane_count(const y4m_stream_info_t *si)
+{
+  switch (si-&gt;chroma) {
+  case Y4M_CHROMA_420JPEG:
+  case Y4M_CHROMA_420MPEG2:
+  case Y4M_CHROMA_420PALDV:
+  case Y4M_CHROMA_444:
+  case Y4M_CHROMA_422:
+  case Y4M_CHROMA_411:
+    return 3;
+  case Y4M_CHROMA_MONO:
+    return 1;
+  case Y4M_CHROMA_444ALPHA:
+    return 4;
+  default:
+    return Y4M_UNKNOWN;
+  }
+}
+
+int y4m_si_get_plane_width(const y4m_stream_info_t *si, int plane)
+{
+  switch (plane) {
+  case 0:
+    return (si-&gt;width);
+  case 1:
+  case 2:
+    switch (si-&gt;chroma) {
+    case Y4M_CHROMA_420JPEG: 
+    case Y4M_CHROMA_420MPEG2:
+    case Y4M_CHROMA_420PALDV:
+      return (si-&gt;width) / 2;
+    case Y4M_CHROMA_444:
+    case Y4M_CHROMA_444ALPHA:
+      return (si-&gt;width);
+    case Y4M_CHROMA_422:
+      return (si-&gt;width) / 2;
+    case Y4M_CHROMA_411:
+      return (si-&gt;width) / 4;
+    default:
+      return Y4M_UNKNOWN;
+    }
+  case 3:
+    switch (si-&gt;chroma) {
+    case Y4M_CHROMA_444ALPHA:
+      return (si-&gt;width);
+    default:
+      return Y4M_UNKNOWN;
+    }
+  default:
+    return Y4M_UNKNOWN;
+  }
+}
+
+int y4m_si_get_plane_height(const y4m_stream_info_t *si, int plane)
+{
+  switch (plane) {
+  case 0:
+    return (si-&gt;height);
+  case 1:
+  case 2:
+    switch (si-&gt;chroma) {
+    case Y4M_CHROMA_420JPEG: 
+    case Y4M_CHROMA_420MPEG2:
+    case Y4M_CHROMA_420PALDV:
+      return (si-&gt;height) / 2;
+    case Y4M_CHROMA_444:
+    case Y4M_CHROMA_444ALPHA:
+    case Y4M_CHROMA_422:
+    case Y4M_CHROMA_411:
+      return (si-&gt;height);
+    default:
+      return Y4M_UNKNOWN;
+    }
+  case 3:
+    switch (si-&gt;chroma) {
+    case Y4M_CHROMA_444ALPHA:
+      return (si-&gt;height);
+    default:
+      return Y4M_UNKNOWN;
+    }
+  default:
+    return Y4M_UNKNOWN;
+  }
+}
+
+int y4m_si_get_plane_length(const y4m_stream_info_t *si, int plane)
+{
+  int w = y4m_si_get_plane_width(si, plane);
+  int h = y4m_si_get_plane_height(si, plane);
+  if ((w != Y4M_UNKNOWN) &amp;&amp; (h != Y4M_UNKNOWN))
+    return (w * h);
+  else
+    return Y4M_UNKNOWN;
+}
+
+int y4m_si_get_framelength(const y4m_stream_info_t *si)
+{
+  int total = 0;
+  int planes = y4m_si_get_plane_count(si);
+  int p;
+  for (p = 0; p &lt; planes; p++) {
+    int plen = y4m_si_get_plane_length(si, p);
+    if (plen == Y4M_UNKNOWN) return Y4M_UNKNOWN;
+    total += plen;
+  }
+  return total;
+}
+
+
+y4m_xtag_list_t *y4m_si_xtags(y4m_stream_info_t *si)
+{ return &amp;(si-&gt;x_tags); }
+
+
+
+void y4m_init_frame_info(y4m_frame_info_t *info)
+{
+  if (info == NULL) return;
+  /* init substructures */
+  y4m_init_xtag_list(&amp;(info-&gt;x_tags));
+  /* set defaults */
+  y4m_clear_frame_info(info);
+}
+
+
+void y4m_clear_frame_info(y4m_frame_info_t *info)
+{
+  if (info == NULL) return;
+  /* clear/initialize info */
+  info-&gt;spatial = Y4M_UNKNOWN;
+  info-&gt;temporal = Y4M_UNKNOWN;
+  info-&gt;presentation = Y4M_UNKNOWN;
+  y4m_xtag_clearlist(&amp;(info-&gt;x_tags));
+}
+
+
+void y4m_copy_frame_info(y4m_frame_info_t *dest, const y4m_frame_info_t *src)
+{
+  if ((dest == NULL) || (src == NULL)) return;
+  /* copy info */
+  dest-&gt;spatial = src-&gt;spatial;
+  dest-&gt;temporal = src-&gt;temporal;
+  dest-&gt;presentation = src-&gt;presentation;
+  y4m_copy_xtag_list(&amp;(dest-&gt;x_tags), &amp;(src-&gt;x_tags));
+}
+
+void y4m_fini_frame_info(y4m_frame_info_t *info)
+{
+  if (info == NULL) return;
+  y4m_fini_xtag_list(&amp;(info-&gt;x_tags));
+}
+
+
+void y4m_fi_set_presentation(y4m_frame_info_t *fi, int pres)
+{ fi-&gt;presentation = pres; }
+
+int y4m_fi_get_presentation(const y4m_frame_info_t *fi)
+{ return fi-&gt;presentation; }
+
+void y4m_fi_set_temporal(y4m_frame_info_t *fi, int sampling)
+{ fi-&gt;temporal = sampling; }
+
+int y4m_fi_get_temporal(const y4m_frame_info_t *fi)
+{ return fi-&gt;temporal; }
+
+void y4m_fi_set_spatial(y4m_frame_info_t *fi, int sampling)
+{ fi-&gt;spatial = sampling; }
+
+int y4m_fi_get_spatial(const y4m_frame_info_t *fi)
+{ return fi-&gt;spatial; }
+
+
+
+y4m_xtag_list_t *y4m_fi_xtags(y4m_frame_info_t *fi)
+{ return &amp;(fi-&gt;x_tags); }
+
+
+/*************************************************************************
+ *
+ * Tag parsing 
+ *
+ *************************************************************************/
+
+
+/* Parse (the first) old, unofficial X-tag chroma specification,
+   and then remove that tag from the X-tag list. */
+static int
+handle_old_chroma_xtag(y4m_stream_info_t *si)
+{
+  y4m_xtag_list_t *xtags = y4m_si_xtags(si);
+  const char *tag = NULL;
+  int n, chroma;
+
+  for (n = y4m_xtag_count(xtags) - 1; n &gt;= 0; n--) {
+    tag = y4m_xtag_get(xtags, n);
+    if (!strncmp(&quot;XYSCSS=&quot;, tag, 7)) break;
+  }
+  if ((tag == NULL) || (n &lt; 0)) return Y4M_UNKNOWN;
+  mjpeg_warn(&quot;Deprecated X-tag for chroma found in a stream header...&quot;);
+  mjpeg_warn(&quot;...pester someone to upgrade the source's program!&quot;);
+  /* parse the tag */
+  tag += 7;
+  if (!strcmp(&quot;411&quot;, tag))           chroma = Y4M_CHROMA_411;
+  else if (!strcmp(tag, &quot;420&quot;))      chroma = Y4M_CHROMA_420JPEG;
+  else if (!strcmp(tag, &quot;420MPEG2&quot;)) chroma = Y4M_CHROMA_420MPEG2;
+  else if (!strcmp(tag, &quot;420PALDV&quot;)) chroma = Y4M_CHROMA_420PALDV;
+  else if (!strcmp(tag, &quot;420JPEG&quot;))  chroma = Y4M_CHROMA_420JPEG;
+  else if (!strcmp(tag, &quot;444&quot;))      chroma = Y4M_CHROMA_444;
+  else chroma = Y4M_UNKNOWN;
+  /* Remove the 'X' tag so that no one has to worry about it any more. */
+  y4m_xtag_remove(xtags, n);
+  /* Hmm... what if there are more XYSCSS tags?  Broken is as broken does;
+     thank goodness this is temporary code. */
+  return chroma;
+}
+
+
+
+
+int y4m_parse_stream_tags(char *s, y4m_stream_info_t *i)
+{
+  char *token, *value;
+  char tag;
+  int err;
+
+  /* parse fields */
+  for (token = strtok(s, Y4M_DELIM); 
+       token != NULL; 
+       token = strtok(NULL, Y4M_DELIM)) {
+    if (token[0] == '\0') continue;   /* skip empty strings */
+    tag = token[0];
+    value = token + 1;
+    switch (tag) {
+    case 'W':  /* width */
+      i-&gt;width = atoi(value);
+      if (i-&gt;width &lt;= 0) return Y4M_ERR_RANGE;
+      break;
+    case 'H':  /* height */
+      i-&gt;height = atoi(value); 
+      if (i-&gt;height &lt;= 0) return Y4M_ERR_RANGE;
+      break;
+    case 'F':  /* frame rate (fps) */
+      if ((err = y4m_parse_ratio(&amp;(i-&gt;framerate), value)) != Y4M_OK)
+	return err;
+      if (i-&gt;framerate.n &lt; 0) return Y4M_ERR_RANGE;
+      break;
+    case 'I':  /* interlacing */
+      switch (value[0]) {
+      case 'p':  i-&gt;interlace = Y4M_ILACE_NONE; break;
+      case 't':  i-&gt;interlace = Y4M_ILACE_TOP_FIRST; break;
+      case 'b':  i-&gt;interlace = Y4M_ILACE_BOTTOM_FIRST; break;
+      case 'm':  i-&gt;interlace = Y4M_ILACE_MIXED; break;
+      case '?':
+      default:
+	i-&gt;interlace = Y4M_UNKNOWN; break;
+      }
+      break;
+    case 'A':  /* sample (pixel) aspect ratio */
+      if ((err = y4m_parse_ratio(&amp;(i-&gt;sampleaspect), value)) != Y4M_OK)
+	return err;
+      if (i-&gt;sampleaspect.n &lt; 0) return Y4M_ERR_RANGE;
+      break;
+    case 'C':
+      i-&gt;chroma = y4m_chroma_parse_keyword(value);
+      if (i-&gt;chroma == Y4M_UNKNOWN)
+	return Y4M_ERR_HEADER;
+      break;
+    case 'X':  /* 'X' meta-tag */
+      if ((err = y4m_xtag_add(&amp;(i-&gt;x_tags), token)) != Y4M_OK) return err;
+      break;
+    default:
+      /* possible error on unknown options */
+      if (_y4mparam_allow_unknown_tags) {
+	/* unknown tags ok:  store in xtag list and warn... */
+	if ((err = y4m_xtag_add(&amp;(i-&gt;x_tags), token)) != Y4M_OK) return err;
+	mjpeg_warn(&quot;Unknown stream tag encountered:  '%s'&quot;, token);
+      } else {
+	/* unknown tags are *not* ok */
+	return Y4M_ERR_BADTAG;
+      }
+      break;
+    }
+  }
+
+  /* If feature_level &gt; 0, then handle and/or remove any old-style XYSCSS
+     chroma tags.  The new-style 'C' tag takes precedence, however. */
+  if (_y4mparam_feature_level &gt; 0) {
+    int xt_chroma = handle_old_chroma_xtag(i);
+
+    if (i-&gt;chroma == Y4M_UNKNOWN)
+      i-&gt;chroma = xt_chroma;
+    else if ((xt_chroma != Y4M_UNKNOWN) &amp;&amp;
+             (xt_chroma != i-&gt;chroma))
+      mjpeg_warn(&quot;Old chroma X-tag (ignored) does not match new chroma tag.&quot;);
+  }
+
+  /* Without 'C' tag or any other chroma spec, default to 420jpeg */
+  if (i-&gt;chroma == Y4M_UNKNOWN) 
+    i-&gt;chroma = Y4M_CHROMA_420JPEG;
+
+  /* Error checking... */
+  /*      - Width and Height are required. */
+  if ((i-&gt;width == Y4M_UNKNOWN) || (i-&gt;height == Y4M_UNKNOWN))
+    return Y4M_ERR_HEADER;
+  /*      - Non-420 chroma and mixed interlace require level &gt;= 1 */
+  if (_y4mparam_feature_level &lt; 1) {
+    if ((i-&gt;chroma != Y4M_CHROMA_420JPEG) &amp;&amp;
+	(i-&gt;chroma != Y4M_CHROMA_420MPEG2) &amp;&amp;
+	(i-&gt;chroma != Y4M_CHROMA_420PALDV))
+      return Y4M_ERR_FEATURE;
+    if (i-&gt;interlace == Y4M_ILACE_MIXED)
+      return Y4M_ERR_FEATURE;
+  }
+
+  /* ta da!  done. */
+  return Y4M_OK;
+}
+
+
+
+static int y4m_parse_frame_tags(char *s, const y4m_stream_info_t *si,
+				y4m_frame_info_t *fi)
+{
+  char *token, *value;
+  char tag;
+  int err;
+
+  /* parse fields */
+  for (token = strtok(s, Y4M_DELIM); 
+       token != NULL; 
+       token = strtok(NULL, Y4M_DELIM)) {
+    if (token[0] == '\0') continue;   /* skip empty strings */
+    tag = token[0];
+    value = token + 1;
+    switch (tag) {
+    case 'I':
+      /* frame 'I' tag requires feature level &gt;= 1 */
+      if (_y4mparam_feature_level &lt; 1) return Y4M_ERR_FEATURE;
+      if (si-&gt;interlace != Y4M_ILACE_MIXED) return Y4M_ERR_BADTAG;
+      switch (value[0]) {
+      case 't':  fi-&gt;presentation = Y4M_PRESENT_TOP_FIRST;        break;
+      case 'T':  fi-&gt;presentation = Y4M_PRESENT_TOP_FIRST_RPT;    break;
+      case 'b':  fi-&gt;presentation = Y4M_PRESENT_BOTTOM_FIRST;     break;
+      case 'B':  fi-&gt;presentation = Y4M_PRESENT_BOTTOM_FIRST_RPT; break;
+      case '1':  fi-&gt;presentation = Y4M_PRESENT_PROG_SINGLE;      break;
+      case '2':  fi-&gt;presentation = Y4M_PRESENT_PROG_DOUBLE;      break;
+      case '3':  fi-&gt;presentation = Y4M_PRESENT_PROG_TRIPLE;      break;
+      default: 
+	return Y4M_ERR_BADTAG;
+      }
+      switch (value[1]) {
+      case 'p':  fi-&gt;temporal = Y4M_SAMPLING_PROGRESSIVE; break;
+      case 'i':  fi-&gt;temporal = Y4M_SAMPLING_INTERLACED;  break;
+      default: 
+	return Y4M_ERR_BADTAG;
+      }
+      switch (value[2]) {
+      case 'p':  fi-&gt;spatial = Y4M_SAMPLING_PROGRESSIVE; break;
+      case 'i':  fi-&gt;spatial = Y4M_SAMPLING_INTERLACED;  break;
+      case '?':  fi-&gt;spatial = Y4M_UNKNOWN;              break;
+      default: 
+	return Y4M_ERR_BADTAG;
+      }
+      break;
+    case 'X':  /* 'X' meta-tag */
+      if ((err = y4m_xtag_add(&amp;(fi-&gt;x_tags), token)) != Y4M_OK) return err;
+      break;
+    default:
+      /* possible error on unknown options */
+      if (_y4mparam_allow_unknown_tags) {
+	/* unknown tags ok:  store in xtag list and warn... */
+	if ((err = y4m_xtag_add(&amp;(fi-&gt;x_tags), token)) != Y4M_OK) return err;
+	mjpeg_warn(&quot;Unknown frame tag encountered:  '%s'&quot;, token);
+      } else {
+	/* unknown tags are *not* ok */
+	return Y4M_ERR_BADTAG;
+      }
+      break;
+    }
+  }
+  /* error-checking and/or non-mixed defaults */
+  switch (si-&gt;interlace) {
+  case Y4M_ILACE_MIXED:
+    /* T and P are required if stream &quot;Im&quot; */
+    if ((fi-&gt;presentation == Y4M_UNKNOWN) || (fi-&gt;temporal == Y4M_UNKNOWN))
+      return Y4M_ERR_HEADER;
+    /* and S is required if stream is also 4:2:0 */
+    if ( ((si-&gt;chroma == Y4M_CHROMA_420JPEG) ||
+          (si-&gt;chroma == Y4M_CHROMA_420MPEG2) ||
+          (si-&gt;chroma == Y4M_CHROMA_420PALDV)) &amp;&amp;
+         (fi-&gt;spatial == Y4M_UNKNOWN) )
+      return Y4M_ERR_HEADER;
+    break;
+  case Y4M_ILACE_NONE:
+    /* stream &quot;Ip&quot; --&gt; equivalent to frame &quot;I1pp&quot; */
+    fi-&gt;spatial = Y4M_SAMPLING_PROGRESSIVE;
+    fi-&gt;temporal = Y4M_SAMPLING_PROGRESSIVE;
+    fi-&gt;presentation = Y4M_PRESENT_PROG_SINGLE;
+    break;
+  case Y4M_ILACE_TOP_FIRST:
+    /* stream &quot;It&quot; --&gt; equivalent to frame &quot;Itii&quot; */
+    fi-&gt;spatial = Y4M_SAMPLING_INTERLACED;
+    fi-&gt;temporal = Y4M_SAMPLING_INTERLACED;
+    fi-&gt;presentation = Y4M_PRESENT_TOP_FIRST;
+    break;
+  case Y4M_ILACE_BOTTOM_FIRST:
+    /* stream &quot;Ib&quot; --&gt; equivalent to frame &quot;Ibii&quot; */
+    fi-&gt;spatial = Y4M_SAMPLING_INTERLACED;
+    fi-&gt;temporal = Y4M_SAMPLING_INTERLACED;
+    fi-&gt;presentation = Y4M_PRESENT_BOTTOM_FIRST;
+    break;
+  default:
+    /* stream unknown:  then, whatever */
+    break;
+  }
+  /* ta da!  done. */
+  return Y4M_OK;
+}
+
+
+
+
+
+/*************************************************************************
+ *
+ * Read/Write stream header
+ *
+ *************************************************************************/
+
+
+int y4m_read_stream_header(int fd, y4m_stream_info_t *i)
+{
+   char line[Y4M_LINE_MAX];
+   char *p;
+   int n;
+   int err;
+
+  /* start with a clean slate */
+  y4m_clear_stream_info(i);
+   /* read the header line */
+   for (n = 0, p = line; n &lt; Y4M_LINE_MAX; n++, p++) {
+     if (read(fd, p, 1) &lt; 1) 
+       return Y4M_ERR_SYSTEM;
+     if (*p == '\n') {
+       *p = '\0';           /* Replace linefeed by end of string */
+       break;
+     }
+   }
+   if (n &gt;= Y4M_LINE_MAX)
+      return Y4M_ERR_HEADER;
+   /* look for keyword in header */
+   if (strncmp(line, Y4M_MAGIC, strlen(Y4M_MAGIC)))
+    return Y4M_ERR_MAGIC;
+   if ((err = y4m_parse_stream_tags(line + strlen(Y4M_MAGIC), i)) != Y4M_OK)
+     return err;
+
+   return Y4M_OK;
+}
+
+
+
+int y4m_write_stream_header(int fd, const y4m_stream_info_t *i)
+{
+  char s[Y4M_LINE_MAX+1];
+  int n;
+  int err;
+  y4m_ratio_t rate = i-&gt;framerate;
+  y4m_ratio_t aspect = i-&gt;sampleaspect;
+  const char *chroma_keyword = y4m_chroma_keyword(i-&gt;chroma);
+
+  if ((i-&gt;chroma == Y4M_UNKNOWN) || (chroma_keyword == NULL))
+    return Y4M_ERR_HEADER;
+  if (_y4mparam_feature_level &lt; 1) {
+    if ((i-&gt;chroma != Y4M_CHROMA_420JPEG) &amp;&amp;
+	(i-&gt;chroma != Y4M_CHROMA_420MPEG2) &amp;&amp;
+	(i-&gt;chroma != Y4M_CHROMA_420PALDV))
+      return Y4M_ERR_FEATURE;
+    if (i-&gt;interlace == Y4M_ILACE_MIXED)
+      return Y4M_ERR_FEATURE;
+  }
+  y4m_ratio_reduce(&amp;rate);
+  y4m_ratio_reduce(&amp;aspect);
+  n = snprintf(s, sizeof(s), &quot;%s W%d H%d F%d:%d I%s A%d:%d C%s&quot;,
+	       Y4M_MAGIC,
+	       i-&gt;width,
+	       i-&gt;height,
+	       rate.n, rate.d,
+	       (i-&gt;interlace == Y4M_ILACE_NONE) ? &quot;p&quot; :
+	       (i-&gt;interlace == Y4M_ILACE_TOP_FIRST) ? &quot;t&quot; :
+	       (i-&gt;interlace == Y4M_ILACE_BOTTOM_FIRST) ? &quot;b&quot; :
+	       (i-&gt;interlace == Y4M_ILACE_MIXED) ? &quot;m&quot; : &quot;?&quot;,
+	       aspect.n, aspect.d,
+	       chroma_keyword
+	       );
+  if ((n &lt; 0) || (n &gt; Y4M_LINE_MAX)) return Y4M_ERR_HEADER;
+  if ((err = y4m_snprint_xtags(s + n, sizeof(s) - n - 1, &amp;(i-&gt;x_tags))) 
+      != Y4M_OK) 
+    return err;
+  /* non-zero on error */
+  return (y4m_write(fd, s, strlen(s)) ? Y4M_ERR_SYSTEM : Y4M_OK);
+}
+
+
+
+
+
+/*************************************************************************
+ *
+ * Read/Write frame header
+ *
+ *************************************************************************/
+
+int y4m_read_frame_header(int fd,
+			  const y4m_stream_info_t *si,
+			  y4m_frame_info_t *fi)
+{
+  char line[Y4M_LINE_MAX];
+  char *p;
+  int n;
+  ssize_t remain;
+  
+  /* start with a clean slate */
+  y4m_clear_frame_info(fi);
+  /* This is more clever than read_stream_header...
+     Try to read &quot;FRAME\n&quot; all at once, and don't try to parse
+     if nothing else is there...
+  */
+  remain = y4m_read(fd, line, sizeof(Y4M_FRAME_MAGIC)-1+1); /* -'\0', +'\n' */
+  if (remain &lt; 0) return Y4M_ERR_SYSTEM;
+  if (remain &gt; 0) {
+    /* A clean EOF should end exactly at a frame-boundary */
+    if (remain == sizeof(Y4M_FRAME_MAGIC))
+      return Y4M_ERR_EOF;
+    else
+      return Y4M_ERR_BADEOF;
+  }
+  if (strncmp(line, Y4M_FRAME_MAGIC, sizeof(Y4M_FRAME_MAGIC)-1))
+    return Y4M_ERR_MAGIC;
+  if (line[sizeof(Y4M_FRAME_MAGIC)-1] == '\n')
+    return Y4M_OK; /* done -- no tags:  that was the end-of-line. */
+
+  if (line[sizeof(Y4M_FRAME_MAGIC)-1] != Y4M_DELIM[0]) {
+    return Y4M_ERR_MAGIC; /* wasn't a space -- what was it? */
+  }
+
+  /* proceed to get the tags... (overwrite the magic) */
+  for (n = 0, p = line; n &lt; Y4M_LINE_MAX; n++, p++) {
+    if (y4m_read(fd, p, 1))
+      return Y4M_ERR_SYSTEM;
+    if (*p == '\n') {
+      *p = '\0';           /* Replace linefeed by end of string */
+      break;
+    }
+  }
+  if (n &gt;= Y4M_LINE_MAX) return Y4M_ERR_HEADER;
+  /* non-zero on error */
+  return y4m_parse_frame_tags(line, si, fi);
+}
+
+
+int y4m_write_frame_header(int fd,
+			   const y4m_stream_info_t *si,
+			   const y4m_frame_info_t *fi)
+{
+  char s[Y4M_LINE_MAX+1];
+  int n, err;
+
+  if (si-&gt;interlace == Y4M_ILACE_MIXED) {
+    if (_y4mparam_feature_level &lt; 1) return Y4M_ERR_FEATURE;
+    n = snprintf(s, sizeof(s), &quot;%s I%c%c%c&quot;, Y4M_FRAME_MAGIC,
+		 (fi-&gt;presentation == Y4M_PRESENT_TOP_FIRST)        ? 't' :
+		 (fi-&gt;presentation == Y4M_PRESENT_TOP_FIRST_RPT)    ? 'T' :
+		 (fi-&gt;presentation == Y4M_PRESENT_BOTTOM_FIRST)     ? 'b' :
+		 (fi-&gt;presentation == Y4M_PRESENT_BOTTOM_FIRST_RPT) ? 'B' :
+		 (fi-&gt;presentation == Y4M_PRESENT_PROG_SINGLE) ? '1' :
+		 (fi-&gt;presentation == Y4M_PRESENT_PROG_DOUBLE) ? '2' :
+		 (fi-&gt;presentation == Y4M_PRESENT_PROG_TRIPLE) ? '3' :
+		 '?',
+		 (fi-&gt;temporal == Y4M_SAMPLING_PROGRESSIVE) ? 'p' :
+		 (fi-&gt;temporal == Y4M_SAMPLING_INTERLACED)  ? 'i' :
+		 '?',
+		 (fi-&gt;spatial == Y4M_SAMPLING_PROGRESSIVE) ? 'p' :
+		 (fi-&gt;spatial == Y4M_SAMPLING_INTERLACED)  ? 'i' :
+		 '?'
+		 );
+  } else {
+    n = snprintf(s, sizeof(s), &quot;%s&quot;, Y4M_FRAME_MAGIC);
+  }
+  
+  if ((n &lt; 0) || (n &gt; Y4M_LINE_MAX)) return Y4M_ERR_HEADER;
+  if ((err = y4m_snprint_xtags(s + n, sizeof(s) - n - 1, &amp;(fi-&gt;x_tags))) 
+      != Y4M_OK) 
+    return err;
+  /* non-zero on error */
+  return (y4m_write(fd, s, strlen(s)) ? Y4M_ERR_SYSTEM : Y4M_OK);
+}
+
+
+
+/*************************************************************************
+ *
+ * Read/Write entire frame
+ *
+ *************************************************************************/
+
+int y4m_read_frame_data(int fd, const y4m_stream_info_t *si, 
+                        y4m_frame_info_t *fi, uint8_t * const *frame)
+{
+  int planes = y4m_si_get_plane_count(si);
+  int p;
+  
+  /* Read each plane */
+  for (p = 0; p &lt; planes; p++) {
+    int w = y4m_si_get_plane_width(si, p);
+    int h = y4m_si_get_plane_height(si, p);
+    if (y4m_read(fd, frame[p], w*h)) return Y4M_ERR_SYSTEM;
+  }
+  return Y4M_OK;
+}
+
+
+
+int y4m_read_frame(int fd, const y4m_stream_info_t *si, 
+		   y4m_frame_info_t *fi, uint8_t * const *frame)
+{
+  int err;
+  
+  /* Read frame header */
+  if ((err = y4m_read_frame_header(fd, si, fi)) != Y4M_OK) return err;
+  /* Read date */
+  return y4m_read_frame_data(fd, si, fi, frame);
+}
+
+
+
+
+int y4m_write_frame(int fd, const y4m_stream_info_t *si, 
+		    const y4m_frame_info_t *fi, uint8_t * const *frame)
+{
+  int planes = y4m_si_get_plane_count(si);
+  int err, p;
+
+  /* Write frame header */
+  if ((err = y4m_write_frame_header(fd, si, fi)) != Y4M_OK) return err;
+  /* Write each plane */
+  for (p = 0; p &lt; planes; p++) {
+    int w = y4m_si_get_plane_width(si, p);
+    int h = y4m_si_get_plane_height(si, p);
+    if (y4m_write(fd, frame[p], w*h)) return Y4M_ERR_SYSTEM;
+  }
+  return Y4M_OK;
+}
+
+
+
+/*************************************************************************
+ *
+ * Read/Write entire frame, (de)interleaved (to)from two separate fields
+ *
+ *************************************************************************/
+
+
+int y4m_read_fields_data(int fd, const y4m_stream_info_t *si,
+                         y4m_frame_info_t *fi,
+                         uint8_t * const *upper_field, 
+                         uint8_t * const *lower_field)
+{
+  int p;
+  int planes = y4m_si_get_plane_count(si);
+  const int maxrbuf=32*1024;
+  uint8_t *rbuf=_y4m_alloc(maxrbuf);
+  int rbufpos=0,rbuflen=0;
+  
+  /* Read each plane */
+  for (p = 0; p &lt; planes; p++) {
+    uint8_t *dsttop = upper_field[p];
+    uint8_t *dstbot = lower_field[p];
+    int height = y4m_si_get_plane_height(si, p);
+    int width = y4m_si_get_plane_width(si, p);
+    int y;
+    /* alternately read one line into each field */
+    for (y = 0; y &lt; height; y += 2) {
+      if( width*2 &gt;= maxrbuf ) {
+        if (y4m_read(fd, dsttop, width)) goto y4merr;
+        if (y4m_read(fd, dstbot, width)) goto y4merr;
+      } else {
+        if( rbufpos==rbuflen ) {
+          rbuflen=(height-y)*width;
+          if( rbuflen&gt;maxrbuf )
+            rbuflen=maxrbuf-maxrbuf%(2*width);
+          if( y4m_read(fd,rbuf,rbuflen) )
+            goto y4merr;
+          rbufpos=0;
+        }
+            
+        memcpy(dsttop,rbuf+rbufpos,width); rbufpos+=width;
+        memcpy(dstbot,rbuf+rbufpos,width); rbufpos+=width;
+      }
+      dsttop+=width;
+      dstbot+=width;
+    }
+  }
+  _y4m_free(rbuf);
+  return Y4M_OK;
+
+ y4merr:
+  _y4m_free(rbuf);
+  return Y4M_ERR_SYSTEM;
+}
+
+
+int y4m_read_fields(int fd, const y4m_stream_info_t *si, y4m_frame_info_t *fi,
+                    uint8_t * const *upper_field, 
+                    uint8_t * const *lower_field)
+{
+  int err;
+  /* Read frame header */
+  if ((err = y4m_read_frame_header(fd, si, fi)) != Y4M_OK) return err;
+  /* Read data */
+  return y4m_read_fields_data(fd, si, fi, upper_field, lower_field);
+}
+
+
+
+int y4m_write_fields(int fd, const y4m_stream_info_t *si,
+		     const y4m_frame_info_t *fi,
+		     uint8_t * const *upper_field, 
+		     uint8_t * const *lower_field)
+{
+  int p, err;
+  int planes = y4m_si_get_plane_count(si);
+  int numwbuf=0;
+  const int maxwbuf=32*1024;
+  uint8_t *wbuf;
+  
+  /* Write frame header */
+  if ((err = y4m_write_frame_header(fd, si, fi)) != Y4M_OK) return err;
+  /* Write each plane */
+  wbuf=_y4m_alloc(maxwbuf);
+  for (p = 0; p &lt; planes; p++) {
+    uint8_t *srctop = upper_field[p];
+    uint8_t *srcbot = lower_field[p];
+    int height = y4m_si_get_plane_height(si, p);
+    int width = y4m_si_get_plane_width(si, p);
+    int y;
+    /* alternately write one line from each field */
+    for (y = 0; y &lt; height; y += 2) {
+      if( width*2 &gt;= maxwbuf ) {
+        if (y4m_write(fd, srctop, width)) goto y4merr;
+        if (y4m_write(fd, srcbot, width)) goto y4merr;
+      } else {
+        if (numwbuf + 2 * width &gt; maxwbuf) {
+          if(y4m_write(fd, wbuf, numwbuf)) goto y4merr;
+          numwbuf=0;
+        }
+
+        memcpy(wbuf+numwbuf,srctop,width); numwbuf += width;
+        memcpy(wbuf+numwbuf,srcbot,width); numwbuf += width;
+      }
+      srctop  += width;
+      srcbot  += width;
+    }
+  }
+  if( numwbuf )
+    if( y4m_write(fd, wbuf, numwbuf) )
+      goto y4merr;
+  _y4m_free(wbuf);
+  return Y4M_OK;
+
+ y4merr:
+  _y4m_free(wbuf);
+  return Y4M_ERR_SYSTEM;
+}
+
+
+/*************************************************************************
+ *
+ * Handy logging of stream info
+ *
+ *************************************************************************/
+
+void y4m_log_stream_info(log_level_t level, const char *prefix,
+			 const y4m_stream_info_t *i)
+{
+  char s[256];
+
+  snprintf(s, sizeof(s), &quot;  frame size:  &quot;);
+  if (i-&gt;width == Y4M_UNKNOWN)
+    snprintf(s+strlen(s), sizeof(s)-strlen(s), &quot;(?)x&quot;);
+  else
+    snprintf(s+strlen(s), sizeof(s)-strlen(s), &quot;%dx&quot;, i-&gt;width);
+  if (i-&gt;height == Y4M_UNKNOWN)
+    snprintf(s+strlen(s), sizeof(s)-strlen(s), &quot;(?) pixels &quot;);
+  else
+    snprintf(s+strlen(s), sizeof(s)-strlen(s), &quot;%d pixels &quot;, i-&gt;height);
+  {
+    int framelength = y4m_si_get_framelength(i);
+    if (framelength == Y4M_UNKNOWN)
+      snprintf(s+strlen(s), sizeof(s)-strlen(s), &quot;(? bytes)&quot;);
+    else
+      snprintf(s+strlen(s), sizeof(s)-strlen(s), &quot;(%d bytes)&quot;, framelength);
+    mjpeg_log(level, &quot;%s%s&quot;, prefix, s);
+  }
+  {
+    const char *desc = y4m_chroma_description(i-&gt;chroma);
+    if (desc == NULL) desc = &quot;unknown!&quot;;
+    mjpeg_log(level, &quot;%s      chroma:  %s&quot;, prefix, desc);
+  }
+  if ((i-&gt;framerate.n == 0) &amp;&amp; (i-&gt;framerate.d == 0))
+    mjpeg_log(level, &quot;%s  frame rate:  ??? fps&quot;, prefix);
+  else
+    mjpeg_log(level, &quot;%s  frame rate:  %d/%d fps (~%f)&quot;, prefix,
+	      i-&gt;framerate.n, i-&gt;framerate.d, 
+	      (double) i-&gt;framerate.n / (double) i-&gt;framerate.d);
+  mjpeg_log(level, &quot;%s   interlace:  %s&quot;, prefix,
+	  (i-&gt;interlace == Y4M_ILACE_NONE) ? &quot;none/progressive&quot; :
+	  (i-&gt;interlace == Y4M_ILACE_TOP_FIRST) ? &quot;top-field-first&quot; :
+	  (i-&gt;interlace == Y4M_ILACE_BOTTOM_FIRST) ? &quot;bottom-field-first&quot; :
+	  (i-&gt;interlace == Y4M_ILACE_MIXED) ? &quot;mixed-mode&quot; :
+	  &quot;anyone's guess&quot;);
+  if ((i-&gt;sampleaspect.n == 0) &amp;&amp; (i-&gt;sampleaspect.d == 0))
+    mjpeg_log(level, &quot;%ssample aspect ratio:  ?:?&quot;, prefix);
+  else
+    mjpeg_log(level, &quot;%ssample aspect ratio:  %d:%d&quot;, prefix,
+	      i-&gt;sampleaspect.n, i-&gt;sampleaspect.d);
+}
+
+
+/*************************************************************************
+ *
+ * Convert error code to string
+ *
+ *************************************************************************/
+
+const char *y4m_strerr(int err)
+{
+  switch (err) {
+  case Y4M_OK:          return &quot;no error&quot;;
+  case Y4M_ERR_RANGE:   return &quot;parameter out of range&quot;;
+  case Y4M_ERR_SYSTEM:  return &quot;system error (failed read/write)&quot;;
+  case Y4M_ERR_HEADER:  return &quot;bad stream or frame header&quot;;
+  case Y4M_ERR_BADTAG:  return &quot;unknown header tag&quot;;
+  case Y4M_ERR_MAGIC:   return &quot;bad header magic&quot;;
+  case Y4M_ERR_XXTAGS:  return &quot;too many xtags&quot;;
+  case Y4M_ERR_EOF:     return &quot;end-of-file&quot;;
+  case Y4M_ERR_BADEOF:  return &quot;stream ended unexpectedly (EOF)&quot;;
+  case Y4M_ERR_FEATURE: return &quot;stream requires unsupported features&quot;;
+  default: 
+    return &quot;unknown error code&quot;;
+  }
+}
+
+
+/*************************************************************************
+ *
+ * Chroma subsampling stuff
+ *
+ *************************************************************************/
+
+y4m_ratio_t y4m_chroma_ss_x_ratio(int chroma_mode)
+{
+  y4m_ratio_t r;
+  switch (chroma_mode) {
+  case Y4M_CHROMA_444ALPHA:
+  case Y4M_CHROMA_444:
+  case Y4M_CHROMA_MONO:
+    r.n = 1; r.d = 1; break;
+  case Y4M_CHROMA_420JPEG:
+  case Y4M_CHROMA_420MPEG2:
+  case Y4M_CHROMA_420PALDV:
+  case Y4M_CHROMA_422:
+    r.n = 1; r.d = 2; break;
+  case Y4M_CHROMA_411:
+    r.n = 1; r.d = 4; break;
+  default:
+    r.n = 0; r.d = 0;
+  }
+  return r;
+}
+
+y4m_ratio_t y4m_chroma_ss_y_ratio(int chroma_mode)
+{
+  y4m_ratio_t r;
+  switch (chroma_mode) {
+  case Y4M_CHROMA_444ALPHA:
+  case Y4M_CHROMA_444:
+  case Y4M_CHROMA_MONO:
+  case Y4M_CHROMA_422:
+  case Y4M_CHROMA_411:
+    r.n = 1; r.d = 1; break;
+  case Y4M_CHROMA_420JPEG:
+  case Y4M_CHROMA_420MPEG2:
+  case Y4M_CHROMA_420PALDV:
+    r.n = 1; r.d = 2; break;
+  default:
+    r.n = 0; r.d = 0;
+  }
+  return r;
+}
+
+
+#if 0  /* unfinished work here */
+y4m_ratio_t y4m_chroma_ss_x_offset(int chroma_mode, int field, int plane)
+{
+  y4m_ratio_t r;
+  switch (chroma_mode) {
+  case Y4M_CHROMA_444ALPHA:
+  case Y4M_CHROMA_444:
+  case Y4M_CHROMA_MONO:
+  case Y4M_CHROMA_422:
+  case Y4M_CHROMA_411:
+    r.n = 0; r.d = 1; break;
+  case Y4M_CHROMA_420JPEG:
+  case Y4M_CHROMA_420MPEG2:
+  case Y4M_CHROMA_420PALDV:
+    r.n = 1; r.d = 2; break;
+  default:
+    r.n = 0; r.d = 0;
+  }
+  return r;
+}
+
+y4m_ratio_t y4m_chroma_ss_y_offset(int chroma_mode, int field, int plane);
+{
+  y4m_ratio_t r;
+  switch (chroma_mode) {
+  case Y4M_CHROMA_444ALPHA:
+  case Y4M_CHROMA_444:
+  case Y4M_CHROMA_MONO:
+  case Y4M_CHROMA_422:
+  case Y4M_CHROMA_411:
+    r.n = 0; r.d = 1; break;
+  case Y4M_CHROMA_420JPEG:
+  case Y4M_CHROMA_420MPEG2:
+  case Y4M_CHROMA_420PALDV:
+    r.n = 1; r.d = 2; break;
+  default:
+    r.n = 0; r.d = 0;
+  }
+  return r;
+}
+#endif
+
+
+
+int y4m_chroma_parse_keyword(const char *s)
+{
+  if (!strcasecmp(&quot;420jpeg&quot;, s))
+    return Y4M_CHROMA_420JPEG;
+  else if (!strcasecmp(&quot;420mpeg2&quot;, s))
+    return Y4M_CHROMA_420MPEG2;
+  else if (!strcasecmp(&quot;420paldv&quot;, s))
+    return Y4M_CHROMA_420PALDV;
+  else if (!strcasecmp(&quot;444&quot;, s))
+    return Y4M_CHROMA_444;
+  else if (!strcasecmp(&quot;422&quot;, s))
+    return Y4M_CHROMA_422;
+  else if (!strcasecmp(&quot;411&quot;, s))
+    return Y4M_CHROMA_411;
+  else if (!strcasecmp(&quot;mono&quot;, s))
+    return Y4M_CHROMA_MONO;
+  else if (!strcasecmp(&quot;444alpha&quot;, s))
+    return Y4M_CHROMA_444ALPHA;
+  else
+    return Y4M_UNKNOWN;
+}
+
+
+const char *y4m_chroma_keyword(int chroma_mode)
+{
+  switch (chroma_mode) {
+  case Y4M_CHROMA_420JPEG:  return &quot;420jpeg&quot;;
+  case Y4M_CHROMA_420MPEG2: return &quot;420mpeg2&quot;;
+  case Y4M_CHROMA_420PALDV: return &quot;420paldv&quot;;
+  case Y4M_CHROMA_444:      return &quot;444&quot;;
+  case Y4M_CHROMA_422:      return &quot;422&quot;;
+  case Y4M_CHROMA_411:      return &quot;411&quot;;
+  case Y4M_CHROMA_MONO:     return &quot;mono&quot;;
+  case Y4M_CHROMA_444ALPHA: return &quot;444alpha&quot;;
+  default:
+    return NULL;
+  }
+}  
+
+
+const char *y4m_chroma_description(int chroma_mode)
+{           
+  switch (chroma_mode) {
+  case Y4M_CHROMA_420JPEG:  return &quot;4:2:0 JPEG/MPEG-1 (interstitial)&quot;;
+  case Y4M_CHROMA_420MPEG2: return &quot;4:2:0 MPEG-2 (horiz. cositing)&quot;;
+  case Y4M_CHROMA_420PALDV: return &quot;4:2:0 PAL-DV (altern. siting)&quot;;
+  case Y4M_CHROMA_444:      return &quot;4:4:4 (no subsampling)&quot;;
+  case Y4M_CHROMA_422:      return &quot;4:2:2 (horiz. cositing)&quot;;
+  case Y4M_CHROMA_411:      return &quot;4:1:1 (horiz. cositing)&quot;;
+  case Y4M_CHROMA_MONO:     return &quot;luma plane only&quot;;
+  case Y4M_CHROMA_444ALPHA: return &quot;4:4:4 with alpha channel&quot;;
+  default:
+    return NULL;
+  }
+}

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/yuv4mpeg.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/yuv4mpeg.h	2009-09-04 15:59:41 UTC (rev 5319)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/yuv4mpeg.h	2009-09-05 08:19:09 UTC (rev 5320)
@@ -0,0 +1,666 @@
+/*
+ *  yuv4mpeg.h:  Functions for reading and writing &quot;new&quot; YUV4MPEG2 streams.
+ *
+ *               Stream format is described at the end of this file.
+ *
+ *
+ *  Copyright (C) 2004 Matthew J. Marjanovic &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">maddog at mir.com</A>&gt;
+ *
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU General Public License
+ *  as published by the Free Software Foundation; either version 2
+ *  of the License, or (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+#ifndef __YUV4MPEG_H__
+#define __YUV4MPEG_H__
+
+#include &lt;stdlib.h&gt;
+#include &lt;mjpeg_types.h&gt;
+#ifndef _WIN32
+#include &lt;unistd.h&gt;
+#endif
+#include &lt;mjpeg_logging.h&gt;
+
+
+/************************************************************************
+ *  error codes returned by y4m_* functions
+ ************************************************************************/
+#define Y4M_OK          0
+#define Y4M_ERR_RANGE   1  /* argument or tag value out of range */
+#define Y4M_ERR_SYSTEM  2  /* failed system call, check errno */
+#define Y4M_ERR_HEADER  3  /* illegal/malformed header */
+#define Y4M_ERR_BADTAG  4  /* illegal tag character */
+#define Y4M_ERR_MAGIC   5  /* bad header magic */
+#define Y4M_ERR_EOF     6  /* end-of-file (clean) */
+#define Y4M_ERR_XXTAGS  7  /* too many xtags */
+#define Y4M_ERR_BADEOF  8  /* unexpected end-of-file */
+#define Y4M_ERR_FEATURE 9  /* stream requires features beyond allowed level */
+
+
+/* generic 'unknown' value for integer parameters (e.g. interlace, height) */
+#define Y4M_UNKNOWN -1
+
+/************************************************************************
+ * values for the &quot;interlace&quot; parameter [y4m_*_interlace()]
+ ************************************************************************/
+#define Y4M_ILACE_NONE          0   /* non-interlaced, progressive frame */
+#define Y4M_ILACE_TOP_FIRST     1   /* interlaced, top-field first       */
+#define Y4M_ILACE_BOTTOM_FIRST  2   /* interlaced, bottom-field first    */
+#define Y4M_ILACE_MIXED         3   /* mixed, &quot;refer to frame header&quot;    */
+
+/************************************************************************
+ * values for the &quot;chroma&quot; parameter [y4m_*_chroma()]
+ ************************************************************************/
+#define Y4M_CHROMA_420JPEG     0  /* 4:2:0, H/V centered, for JPEG/MPEG-1 */
+#define Y4M_CHROMA_420MPEG2    1  /* 4:2:0, H cosited, for MPEG-2         */
+#define Y4M_CHROMA_420PALDV    2  /* 4:2:0, alternating Cb/Cr, for PAL-DV */
+#define Y4M_CHROMA_444         3  /* 4:4:4, no subsampling, phew.         */
+#define Y4M_CHROMA_422         4  /* 4:2:2, H cosited                     */
+#define Y4M_CHROMA_411         5  /* 4:1:1, H cosited                     */
+#define Y4M_CHROMA_MONO        6  /* luma plane only                      */
+#define Y4M_CHROMA_444ALPHA    7  /* 4:4:4 with an alpha channel          */
+
+/************************************************************************
+ * values for sampling parameters [y4m_*_spatial(), y4m_*_temporal()]
+ ************************************************************************/
+#define Y4M_SAMPLING_PROGRESSIVE 0
+#define Y4M_SAMPLING_INTERLACED  1
+
+/************************************************************************
+ * values for &quot;presentation&quot; parameter [y4m_*_presentation()]
+ ************************************************************************/
+#define Y4M_PRESENT_TOP_FIRST         0  /* top-field-first                 */
+#define Y4M_PRESENT_TOP_FIRST_RPT     1  /* top-first, repeat top           */
+#define Y4M_PRESENT_BOTTOM_FIRST      2  /* bottom-field-first              */
+#define Y4M_PRESENT_BOTTOM_FIRST_RPT  3  /* bottom-first, repeat bottom     */
+#define Y4M_PRESENT_PROG_SINGLE       4  /* single progressive frame        */
+#define Y4M_PRESENT_PROG_DOUBLE       5  /* progressive frame, repeat once  */
+#define Y4M_PRESENT_PROG_TRIPLE       6  /* progressive frame, repeat twice */
+
+#define Y4M_MAX_NUM_PLANES 4
+
+/************************************************************************
+ *  'ratio' datatype, for rational numbers
+ *                                     (see 'ratio' functions down below)
+ ************************************************************************/
+typedef struct _y4m_ratio {
+  int n;  /* numerator   */
+  int d;  /* denominator */
+} y4m_ratio_t;
+
+
+/************************************************************************
+ *  useful standard framerates (as ratios)
+ ************************************************************************/
+extern const y4m_ratio_t y4m_fps_UNKNOWN;
+extern const y4m_ratio_t y4m_fps_NTSC_FILM;  /* 24000/1001 film (in NTSC)  */
+extern const y4m_ratio_t y4m_fps_FILM;       /* 24fps film                 */
+extern const y4m_ratio_t y4m_fps_PAL;        /* 25fps PAL                  */
+extern const y4m_ratio_t y4m_fps_NTSC;       /* 30000/1001 NTSC            */
+extern const y4m_ratio_t y4m_fps_30;         /* 30fps                      */
+extern const y4m_ratio_t y4m_fps_PAL_FIELD;  /* 50fps PAL field rate       */
+extern const y4m_ratio_t y4m_fps_NTSC_FIELD; /* 60000/1001 NTSC field rate */
+extern const y4m_ratio_t y4m_fps_60;         /* 60fps                      */
+
+/************************************************************************
+ *  useful standard sample (pixel) aspect ratios (W:H)
+ ************************************************************************/
+extern const y4m_ratio_t y4m_sar_UNKNOWN; 
+extern const y4m_ratio_t y4m_sar_SQUARE;        /* square pixels */
+extern const y4m_ratio_t y4m_sar_NTSC_CCIR601;  /* 525-line (NTSC) Rec.601 */
+extern const y4m_ratio_t y4m_sar_NTSC_16_9;     /* 16:9 NTSC/Rec.601       */
+extern const y4m_ratio_t y4m_sar_NTSC_SVCD_4_3; /* NTSC SVCD 4:3           */
+extern const y4m_ratio_t y4m_sar_NTSC_SVCD_16_9;/* NTSC SVCD 16:9          */
+extern const y4m_ratio_t y4m_sar_PAL_CCIR601;   /* 625-line (PAL) Rec.601  */
+extern const y4m_ratio_t y4m_sar_PAL_16_9;      /* 16:9 PAL/Rec.601        */
+extern const y4m_ratio_t y4m_sar_PAL_SVCD_4_3;  /* PAL SVCD 4:3            */
+extern const y4m_ratio_t y4m_sar_PAL_SVCD_16_9; /* PAL SVCD 16:9           */
+extern const y4m_ratio_t y4m_sar_SQR_ANA16_9;   /* anamorphic 16:9 sampled */
+                                            /* from 4:3 with square pixels */
+
+/************************************************************************
+ *  useful standard display aspect ratios (W:H)
+ ************************************************************************/
+extern const y4m_ratio_t y4m_dar_UNKNOWN; 
+extern const y4m_ratio_t y4m_dar_4_3;     /* standard TV   */
+extern const y4m_ratio_t y4m_dar_16_9;    /* widescreen TV */
+extern const y4m_ratio_t y4m_dar_221_100; /* word-to-your-mother TV */
+
+
+#define Y4M_MAX_XTAGS 32        /* maximum number of xtags in list       */
+#define Y4M_MAX_XTAG_SIZE 32    /* max length of an xtag (including 'X') */
+
+typedef struct _y4m_xtag_list y4m_xtag_list_t;
+typedef struct _y4m_stream_info y4m_stream_info_t;
+typedef struct _y4m_frame_info y4m_frame_info_t;
+
+
+#ifdef __cplusplus
+#define BEGIN_CDECLS extern &quot;C&quot; {
+#define END_CDECLS   }
+#else
+#define BEGIN_CDECLS 
+#define END_CDECLS   
+#endif
+
+BEGIN_CDECLS
+
+/************************************************************************
+ *  'ratio' functions
+ ************************************************************************/
+
+/* 'normalize' a ratio (remove common factors) */
+void y4m_ratio_reduce(y4m_ratio_t *r);
+
+/* parse &quot;nnn:ddd&quot; into a ratio (returns Y4M_OK or Y4M_ERR_RANGE) */
+int y4m_parse_ratio(y4m_ratio_t *r, const char *s);
+
+/* quick test of two ratios for equality (i.e. identical components) */
+#define Y4M_RATIO_EQL(a,b) ( ((a).n == (b).n) &amp;&amp; ((a).d == (b).d) )
+
+/* quick conversion of a ratio to a double (no divide-by-zero check!) */
+#define Y4M_RATIO_DBL(r) ((double)(r).n / (double)(r).d)
+
+/*************************************************************************
+ *
+ * Guess the true SAR (sample aspect ratio) from a list of commonly 
+ * encountered values, given the &quot;suggested&quot; display aspect ratio (DAR),
+ * and the true frame width and height.
+ *
+ * Returns y4m_sar_UNKNOWN if no match is found.
+ *
+ *************************************************************************/
+y4m_ratio_t y4m_guess_sar(int width, int height, y4m_ratio_t dar);
+
+
+/*************************************************************************
+ *
+ * Chroma Subsampling Mode information
+ *
+ *  x_ratio, y_ratio  -  subsampling of chroma planes
+ *  x_offset, y_offset - offset of chroma sample grid,
+ *                        relative to luma (0,0) sample
+ *
+ *************************************************************************/
+
+y4m_ratio_t y4m_chroma_ss_x_ratio(int chroma_mode);
+y4m_ratio_t y4m_chroma_ss_y_ratio(int chroma_mode);
+#if 0
+y4m_ratio_t y4m_chroma_ss_x_offset(int chroma_mode, int field, int plane);
+y4m_ratio_t y4m_chroma_ss_y_offset(int chroma_mode, int field, int plane);
+#endif
+
+/* Given a string containing a (case-insensitive) chroma-tag keyword,
+   return appropriate chroma mode (or Y4M_UNKNOWN) */
+int y4m_chroma_parse_keyword(const char *s);
+
+/* Given a Y4M_CHROMA_* mode, return appropriate chroma-tag keyword,
+   or NULL if there is none. */
+const char *y4m_chroma_keyword(int chroma_mode);
+
+/* Given a Y4M_CHROMA_* mode, return appropriate chroma mode description,
+   or NULL if there is none. */
+const char *y4m_chroma_description(int chroma_mode);
+
+
+
+/************************************************************************
+ *  'xtag' functions
+ *
+ * o Before using an xtag_list (but after the structure/memory has been
+ *    allocated), you must initialize it via y4m_init_xtag_list().
+ * o After using an xtag_list (but before the structure is released),
+ *    call y4m_fini_xtag_list() to free internal memory.
+ *
+ ************************************************************************/
+
+/* initialize an xtag_list structure */
+void y4m_init_xtag_list(y4m_xtag_list_t *xtags);
+
+/* finalize an xtag_list structure */
+void y4m_fini_xtag_list(y4m_xtag_list_t *xtags);
+
+/* make one xtag_list into a copy of another */
+void y4m_copy_xtag_list(y4m_xtag_list_t *dest, const y4m_xtag_list_t *src);
+
+/* return number of tags in an xtag_list */
+int y4m_xtag_count(const y4m_xtag_list_t *xtags);
+
+/* access n'th tag in an xtag_list */
+const char *y4m_xtag_get(const y4m_xtag_list_t *xtags, int n);
+
+/* append a new tag to an xtag_list
+    returns:          Y4M_OK - success
+              Y4M_ERR_XXTAGS - list is already full */
+int y4m_xtag_add(y4m_xtag_list_t *xtags, const char *tag);
+
+/* remove a tag from an xtag_list 
+    returns:         Y4M_OK - success
+              Y4M_ERR_RANGE - n is out of range */
+int y4m_xtag_remove(y4m_xtag_list_t *xtags, int n);
+
+/* remove all tags from an xtag_list 
+    returns:   Y4M_OK - success       */
+int y4m_xtag_clearlist(y4m_xtag_list_t *xtags);
+
+/* append copies of tags from src list to dest list
+    returns:          Y4M_OK - success
+              Y4M_ERR_XXTAGS - operation would overfill dest list */
+int y4m_xtag_addlist(y4m_xtag_list_t *dest, const y4m_xtag_list_t *src);
+
+
+
+/************************************************************************
+ *  '*_info' functions
+ *
+ * o Before using a *_info structure (but after the structure/memory has
+ *    been allocated), you must initialize it via y4m_init_*_info().
+ * o After using a *_info structure (but before the structure is released),
+ *    call y4m_fini_*_info() to free internal memory.
+ * o Use the 'set' and 'get' accessors to modify or access the fields in
+ *    the structures; don't touch the structure directly.  (Ok, so there
+ *    is no really convenient C syntax to prevent you from doing this,
+ *    but we are all responsible programmers here, so just don't do it!)
+ *
+ ************************************************************************/
+
+/* initialize a stream_info structure */
+void y4m_init_stream_info(y4m_stream_info_t *i);
+
+/* finalize a stream_info structure */
+void y4m_fini_stream_info(y4m_stream_info_t *i);
+
+/* reset stream_info back to default/unknown values */
+void y4m_clear_stream_info(y4m_stream_info_t *info);
+
+/* make one stream_info into a copy of another */
+void y4m_copy_stream_info(y4m_stream_info_t *dest,
+			  const y4m_stream_info_t *src);
+
+/* access or set stream_info fields */
+/*      level 0                   */
+int y4m_si_get_width(const y4m_stream_info_t *si);
+int y4m_si_get_height(const y4m_stream_info_t *si);
+int y4m_si_get_interlace(const y4m_stream_info_t *si);
+y4m_ratio_t y4m_si_get_framerate(const y4m_stream_info_t *si);
+y4m_ratio_t y4m_si_get_sampleaspect(const y4m_stream_info_t *si);
+void y4m_si_set_width(y4m_stream_info_t *si, int width);
+void y4m_si_set_height(y4m_stream_info_t *si, int height);
+void y4m_si_set_interlace(y4m_stream_info_t *si, int interlace);
+void y4m_si_set_framerate(y4m_stream_info_t *si, y4m_ratio_t framerate);
+void y4m_si_set_sampleaspect(y4m_stream_info_t *si, y4m_ratio_t sar);
+/*      level 1                   */
+void y4m_si_set_chroma(y4m_stream_info_t *si, int chroma_mode);
+int y4m_si_get_chroma(const y4m_stream_info_t *si);
+
+/* derived quantities (no setter) */
+/*      level 0                   */
+int y4m_si_get_framelength(const y4m_stream_info_t *si);
+/*      level 1                   */
+int y4m_si_get_plane_count(const y4m_stream_info_t *si);
+int y4m_si_get_plane_width(const y4m_stream_info_t *si, int plane);
+int y4m_si_get_plane_height(const y4m_stream_info_t *si, int plane);
+int y4m_si_get_plane_length(const y4m_stream_info_t *si, int plane);
+
+
+/* access stream_info xtag_list */
+y4m_xtag_list_t *y4m_si_xtags(y4m_stream_info_t *si);
+
+
+/* initialize a frame_info structure */
+void y4m_init_frame_info(y4m_frame_info_t *i);
+
+/* finalize a frame_info structure */
+void y4m_fini_frame_info(y4m_frame_info_t *i);
+
+/* reset frame_info back to default/unknown values */
+void y4m_clear_frame_info(y4m_frame_info_t *info);
+
+/* make one frame_info into a copy of another */
+void y4m_copy_frame_info(y4m_frame_info_t *dest,
+			 const y4m_frame_info_t *src);
+
+
+/* access or set frame_info fields (level 1) */
+int y4m_fi_get_presentation(const y4m_frame_info_t *fi);
+int y4m_fi_get_temporal(const y4m_frame_info_t *fi);
+int y4m_fi_get_spatial(const y4m_frame_info_t *fi);
+
+void y4m_fi_set_presentation(y4m_frame_info_t *fi, int pres);
+void y4m_fi_set_temporal(y4m_frame_info_t *fi, int sampling);
+void y4m_fi_set_spatial(y4m_frame_info_t *fi, int sampling);
+
+
+/* access frame_info xtag_list */
+y4m_xtag_list_t *y4m_fi_xtags(y4m_frame_info_t *fi);
+
+
+
+/************************************************************************
+ *  blocking read and write functions
+ *
+ *  o guaranteed to transfer entire payload (or fail)
+ *  o return values:
+ *                         0 (zero)   complete success
+ *          -(# of remaining bytes)   error (and errno left set)
+ *          +(# of remaining bytes)   EOF (for y4m_read only)
+ *
+ ************************************************************************/
+
+/* read len bytes from fd into buf */
+ssize_t y4m_read(int fd, void *buf, size_t len);
+
+/* write len bytes from fd into buf */
+ssize_t y4m_write(int fd, const void *buf, size_t len);
+
+
+
+/************************************************************************
+ *  stream header processing functions
+ *  
+ *  o return values:
+ *                   Y4M_OK - success
+ *                Y4M_ERR_* - error (see y4m_strerr() for descriptions)
+ *
+ ************************************************************************/
+
+/* parse a string of stream header tags */
+int y4m_parse_stream_tags(char *s, y4m_stream_info_t *i);
+
+/* read a stream header from file descriptor fd
+   (the current contents of stream_info are erased first) */
+int y4m_read_stream_header(int fd, y4m_stream_info_t *i);
+
+/* write a stream header to file descriptor fd */
+int y4m_write_stream_header(int fd, const y4m_stream_info_t *i);
+
+
+
+/************************************************************************
+ *  frame processing functions
+ *  
+ *  o return values:
+ *                   Y4M_OK - success
+ *                Y4M_ERR_* - error (see y4m_strerr() for descriptions)
+ *
+ ************************************************************************/
+
+/* write a frame header to file descriptor fd */
+int y4m_write_frame_header(int fd,
+			   const y4m_stream_info_t *si,
+			   const y4m_frame_info_t *fi);
+
+/* write a complete frame (header + data)
+   o planes[] points to 1-4 buffers, one each for image plane */
+int y4m_write_frame(int fd, const y4m_stream_info_t *si, 
+		    const y4m_frame_info_t *fi, uint8_t * const *planes);
+
+
+/* write a complete frame (header + data), but interleave fields
+    from two separate buffers
+   o upper_field[] same as planes[] above, but for upper field only
+   o lower_field[] same as planes[] above, but for lower field only
+*/
+int y4m_write_fields(int fd, const y4m_stream_info_t *si, 
+		     const y4m_frame_info_t *fi,
+		     uint8_t * const *upper_field, 
+		     uint8_t * const *lower_field);
+
+
+/* read a frame header from file descriptor fd 
+   (the current contents of frame_info are erased first) */
+int y4m_read_frame_header(int fd,
+			  const y4m_stream_info_t *si,
+			  y4m_frame_info_t *fi);
+
+/* read frame data [to be called after y4m_read_frame_header()]
+   o planes[] points to 1-4 buffers, one each for image plane */
+int y4m_read_frame_data(int fd, const y4m_stream_info_t *si, 
+                        y4m_frame_info_t *fi, uint8_t * const *planes);
+
+/* read frame data, but de-interleave fields into two separate buffers
+    [to be called after y4m_read_frame_header()]
+   o upper_field[] same as planes[] above, but for upper field only
+   o lower_field[] same as planes[] above, but for lower field only
+*/
+int y4m_read_fields_data(int fd, const y4m_stream_info_t *si, 
+                         y4m_frame_info_t *fi,
+                         uint8_t * const *upper_field, 
+                         uint8_t * const *lower_field);
+
+/* read a complete frame (header + data)
+   o planes[] points to 1-4 buffers, one each for image plane */
+int y4m_read_frame(int fd, const y4m_stream_info_t *si, 
+		   y4m_frame_info_t *fi, uint8_t * const *planes);
+
+/* read a complete frame (header + data), but de-interleave fields
+    into two separate buffers
+   o upper_field[] same as planes[] above, but for upper field only
+   o lower_field[] same as planes[] above, but for lower field only
+*/
+int y4m_read_fields(int fd, const y4m_stream_info_t *si, 
+		    y4m_frame_info_t *fi,
+		    uint8_t * const *upper_field, 
+		    uint8_t * const *lower_field);
+
+
+/************************************************************************
+ *  miscellaneous functions
+ ************************************************************************/
+
+/* convenient dump of stream header info via mjpeg_log facility
+ *  - each logged/printed line is prefixed by 'prefix'
+ */
+void y4m_log_stream_info(log_level_t level, const char *prefix,
+			 const y4m_stream_info_t *i);
+
+/* convert a Y4M_ERR_* error code into mildly explanatory string */
+const char *y4m_strerr(int err);
+
+/* set 'allow_unknown_tag' flag for library...
+    o yn = 0 :  unknown header tags will produce a parsing error
+    o yn = 1 :  unknown header tags/values will produce a warning, but
+                 are otherwise passed along via the xtags list
+    o yn = -1:  don't change, just return current setting
+
+   return value:  previous setting of flag
+*/
+int y4m_allow_unknown_tags(int yn);
+
+
+/* set level of &quot;accepted extensions&quot; for the library...
+    o level = 0:  default - conform to original YUV4MPEG2 spec; yield errors
+                   when reading or writing a stream which exceeds it.
+    o level = 1:  allow reading/writing streams which contain non-420jpeg
+                   chroma and/or mixed-mode interlacing
+    o level = -1: don't change, just return current setting
+
+   return value:  previous setting of level
+ */
+int y4m_accept_extensions(int level);
+
+
+END_CDECLS
+
+
+/************************************************************************
+ ************************************************************************
+
+  Description of the (new!, forever?) YUV4MPEG2 stream format:
+
+  STREAM consists of
+    o one '\n' terminated STREAM-HEADER
+    o unlimited number of FRAMEs
+
+  FRAME consists of
+    o one '\n' terminated FRAME-HEADER
+    o &quot;length&quot; octets of planar YCrCb 4:2:0 image data
+        (if frame is interlaced, then the two fields are interleaved)
+
+
+  STREAM-HEADER consists of
+     o string &quot;YUV4MPEG2&quot;
+     o unlimited number TAGGED-FIELDs, each preceded by ' ' separator
+     o '\n' line terminator
+
+  FRAME-HEADER consists of
+     o string &quot;FRAME&quot;
+     o unlimited number of TAGGED-FIELDs, each preceded by ' ' separator
+     o '\n' line terminator
+
+
+  TAGGED-FIELD consists of
+     o single ascii character tag
+     o VALUE (which does not contain whitespace)
+
+  VALUE consists of
+     o integer (base 10 ascii representation)
+  or o RATIO
+  or o single ascii character
+  or o non-whitespace ascii string
+
+  RATIO consists of
+     o numerator (integer)
+     o ':' (a colon)
+     o denominator (integer)
+
+
+  The currently supported tags for the STREAM-HEADER:
+     W - [integer] frame width, pixels, should be &gt; 0
+     H - [integer] frame height, pixels, should be &gt; 0
+     C - [string]  chroma-subsampling/data format
+           420jpeg   (default)
+           420mpeg2
+           420paldv
+           411
+           422
+           444       - non-subsampled Y'CbCr
+	   444alpha  - Y'CbCr with alpha channel (with Y' black/white point)
+           mono      - Y' plane only
+     I - [char] interlacing:  p - progressive (none)
+                              t - top-field-first
+                              b - bottom-field-first
+                              m - mixed -- see 'I' tag in frame header
+                              ? - unknown
+     F - [ratio] frame-rate, 0:0 == unknown
+     A - [ratio] sample (pixel) aspect ratio, 0:0 == unknown
+     X - [character string] 'metadata' (unparsed, but passed around)
+
+  The currently supported tags for the FRAME-HEADER:
+     Ixyz - framing/sampling (required if-and-only-if stream is &quot;Im&quot;)
+          x:  t - top-field-first
+              T - top-field-first and repeat
+	      b - bottom-field-first
+              B - bottom-field-first and repeat
+              1 - single progressive frame
+              2 - double progressive frame (repeat)
+              3 - triple progressive frame (repeat twice)
+
+          y:  p - progressive:  fields sampled at same time
+              i - interlaced:   fields sampled at different times
+
+          z:  p - progressive:  subsampling over whole frame
+              i - interlaced:   each field subsampled independently
+              ? - unknown (allowed only for non-4:2:0 subsampling)           
+       
+     X - character string 'metadata' (unparsed, but passed around)
+
+ ************************************************************************
+ ************************************************************************/
+
+
+/*
+
+   THAT'S ALL FOLKS!
+
+   Thank you for reading the source code.  We hope you have thoroughly
+   enjoyed the experience.
+
+*/
+
+
+
+
+
+#ifdef INTERNAL_Y4M_LIBCODE_STUFF_QPX
+#define Y4MPRIVATIZE(identifier) identifier
+#else
+#define Y4MPRIVATIZE(identifier) PRIVATE##identifier
+#endif
+
+/* 
+ * Actual structure definitions of structures which you shouldn't touch.
+ *
+ */
+
+/************************************************************************
+ *  'xtag_list' --- list of unparsed and/or meta/X header tags
+ *
+ *     Do not touch this structure directly!
+ *
+ *     Use the y4m_xtag_*() functions (see below).
+ *     You must initialize/finalize this structure before/after use.
+ ************************************************************************/
+struct _y4m_xtag_list {
+  int Y4MPRIVATIZE(count);
+  char *Y4MPRIVATIZE(tags)[Y4M_MAX_XTAGS];
+};
+
+
+/************************************************************************
+ *  'stream_info' --- stream header information
+ *
+ *     Do not touch this structure directly!
+ *
+ *     Use the y4m_si_*() functions (see below).
+ *     You must initialize/finalize this structure before/after use.
+ ************************************************************************/
+struct _y4m_stream_info {
+  /* values from header/setters */
+  int Y4MPRIVATIZE(width);
+  int Y4MPRIVATIZE(height);
+  int Y4MPRIVATIZE(interlace);            /* see Y4M_ILACE_* definitions  */
+  y4m_ratio_t Y4MPRIVATIZE(framerate);    /* see Y4M_FPS_* definitions    */
+  y4m_ratio_t Y4MPRIVATIZE(sampleaspect); /* see Y4M_SAR_* definitions    */
+  int Y4MPRIVATIZE(chroma);               /* see Y4M_CHROMA_* definitions */
+
+  /* mystical X tags */
+  y4m_xtag_list_t Y4MPRIVATIZE(x_tags);
+};
+
+
+/************************************************************************
+ *  'frame_info' --- frame header information
+ *
+ *     Do not touch this structure directly!
+ *
+ *     Use the y4m_fi_*() functions (see below).
+ *     You must initialize/finalize this structure before/after use.
+ ************************************************************************/
+
+struct _y4m_frame_info {
+  int Y4MPRIVATIZE(spatial);      /* see Y4M_SAMPLING_* definitions */
+  int Y4MPRIVATIZE(temporal);     /* see Y4M_SAMPLING_* definitions */
+  int Y4MPRIVATIZE(presentation); /* see Y4M_PRESENT_* definitions  */
+  /* mystical X tags */
+  y4m_xtag_list_t Y4MPRIVATIZE(x_tags);
+};
+
+
+#undef Y4MPRIVATIZE
+
+
+#endif /* __YUV4MPEG_H__ */
+
+

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/yuv4mpeg_intern.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/yuv4mpeg_intern.h	2009-09-04 15:59:41 UTC (rev 5319)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerMplex/yuv4mpeg_intern.h	2009-09-05 08:19:09 UTC (rev 5320)
@@ -0,0 +1,85 @@
+/*
+ *  yuv4mpeg_intern.h:  Internal constants for &quot;new&quot; YUV4MPEG streams
+ *
+ *  Copyright (C) 2001 Andrew Stevens &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">andrew.stevens at philips.com</A>&gt;
+ *  Copyright (C) 2001 Matthew J. Marjanovic &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">maddog at mir.com</A>&gt;
+ *
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of version 2 of the GNU General Public License
+ *  as published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+#ifndef __YUV4MPEG_INTERN_H__
+#define __YUV4MPEG_INTERN_H__
+
+
+#define Y4M_MAGIC &quot;YUV4MPEG2&quot;
+#define Y4M_FRAME_MAGIC &quot;FRAME&quot;
+
+#define Y4M_DELIM &quot; &quot;  /* single-character(space) separating tagged fields */
+
+#define Y4M_LINE_MAX 256   /* max number of characters in a header line
+                               (including the '\n', but not the '\0') */
+
+
+/* standard framerate ratios */
+#define Y4M_FPS_UNKNOWN    { 0, 0 }
+#define Y4M_FPS_NTSC_FILM  { 24000, 1001 }
+#define Y4M_FPS_FILM       { 24, 1 }
+#define Y4M_FPS_PAL        { 25, 1 }
+#define Y4M_FPS_NTSC       { 30000, 1001 }
+#define Y4M_FPS_30         { 30, 1 }
+#define Y4M_FPS_PAL_FIELD  { 50, 1 }
+#define Y4M_FPS_NTSC_FIELD { 60000, 1001 }
+#define Y4M_FPS_60         { 60, 1 }
+
+/* standard sample/pixel aspect ratios */
+#define Y4M_SAR_UNKNOWN        {   0, 0  }
+#define Y4M_SAR_SQUARE         {   1, 1  }
+#define Y4M_SAR_SQR_ANA_16_9   {   4, 3  }
+#define Y4M_SAR_NTSC_CCIR601   {  10, 11 }
+#define Y4M_SAR_NTSC_16_9      {  40, 33 }
+#define Y4M_SAR_NTSC_SVCD_4_3  {  15, 11 }
+#define Y4M_SAR_NTSC_SVCD_16_9 {  20, 11 }
+#define Y4M_SAR_PAL_CCIR601    {  59, 54 }
+#define Y4M_SAR_PAL_16_9       { 118, 81 }
+#define Y4M_SAR_PAL_SVCD_4_3   {  59, 36 }
+#define Y4M_SAR_PAL_SVCD_16_9  {  59, 27 }
+
+#define Y4M_SAR_MPEG1_1  Y4M_SAR_SQUARE
+#define Y4M_SAR_MPEG1_2  { 10000, 6735 }
+#define Y4M_SAR_MPEG1_3  { 10000, 7031 } /* Anamorphic 16:9 PAL */
+#define Y4M_SAR_MPEG1_4  { 10000, 7615 }
+#define Y4M_SAR_MPEG1_5  { 10000, 8055 }
+#define Y4M_SAR_MPEG1_6  { 10000, 8437 } /* Anamorphic 16:9 NTSC */
+#define Y4M_SAR_MPEG1_7  { 10000, 8935 } 
+#define Y4M_SAR_MPEG1_8  { 10000, 9375 } /* PAL/SECAM 4:3 */
+#define Y4M_SAR_MPEG1_9  { 10000, 9815 }
+#define Y4M_SAR_MPEG1_10 { 10000, 10255 }
+#define Y4M_SAR_MPEG1_11 { 10000, 10695 }
+#define Y4M_SAR_MPEG1_12 { 10000, 11250 } /* NTSC 4:3 */
+#define Y4M_SAR_MPEG1_13 { 10000, 11575 }
+#define Y4M_SAR_MPEG1_14 { 10000, 12015 }
+
+#define Y4M_DAR_UNKNOWN  {   0, 0   }
+#define Y4M_DAR_4_3      {   4, 3   }
+#define Y4M_DAR_16_9     {  16, 9   }
+#define Y4M_DAR_221_100  { 221, 100 }
+
+#define Y4M_DAR_MPEG2_1 {   1, 1   }
+#define Y4M_DAR_MPEG2_2 {   4, 3   }
+#define Y4M_DAR_MPEG2_3 {  16, 9   }
+#define Y4M_DAR_MPEG2_4 { 221, 100 }
+
+#endif /* __YUV4MPEG_INTERN_H__ */
+


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="002532.html">[Avidemux-svn-commit] r5319 - in	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers:	. muxerffTS
</A></li>
	<LI>Next message: <A HREF="002534.html">[Avidemux-svn-commit] r5321 - in	branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer:	include src
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2533">[ date ]</a>
              <a href="thread.html#2533">[ thread ]</a>
              <a href="subject.html#2533">[ subject ]</a>
              <a href="author.html#2533">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">More information about the Avidemux-svn-commit
mailing list</a><br>
</body></html>
