<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Avidemux-svn-commit] r3158 - in branches/avidemux_2.4_branch: . autononreg/dialogFactory avidemux/ADM_libraries avidemux/ADM_libraries/ADM_lavcodec avidemux/ADM_libraries/ADM_lavformat avidemux/ADM_libraries/ADM_lavutil avidemux/ADM_libraries/ADM_libMad avidemux/ADM_libraries/ADM_libMpeg2Dec avidemux/ADM_libraries/ADM_liba52 avidemux/ADM_libraries/ADM_libass avidemux/ADM_libraries/ADM_libmpeg2enc avidemux/ADM_libraries/ADM_libpostproc avidemux/ADM_libraries/ADM_libswscale avidemux/ADM_libraries/ADM_libtwolame avidemux/ADM_libraries/ADM_libwrapper avidemux/ADM_libraries/ADM_lvemux avidemux/ADM_libraries/ADM_mplex avidemux/ADM_libraries/ADM_smjs avidemux/ADM_libraries/ADM_utilities avidemux/ADM_libraries/ADM_xvidratectl avidemux/ADM_outputs avidemux/ADM_outputs/oplug_avi avidemux/ADM_outputs/oplug_mp4 avidemux/ADM_outputs/oplug_mpeg avidemux/ADM_outputs/oplug_mpegFF avidemux/ADM_outputs/oplug_ogm avidemux/ADM_userInterfaces/ADM_GTK avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog avidemux/A! DM_userInterfaces/ADM_GTK/ADM_dialogFactory avidemux/ADM_userInterfaces/ADM_GTK/ADM_filters avidemux/ADM_userInterfaces/ADM_GTK/ADM_gui2 avidemux/ADM_userInterfaces/ADM_GTK/ADM_ocr avidemux/ADM_userInterfaces/ADM_GTK/ADM_toolkit_gtk cmake
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/avidemux-svn-commit/2007-May/index.html" >
   <LINK REL="made" HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r3158%20-%20in%20branches/avidemux_2.4_branch%3A%20.%0A%20autononreg/dialogFactory%20avidemux/ADM_libraries%0A%20avidemux/ADM_libraries/ADM_lavcodec%20avidemux/ADM_libraries/ADM_lavformat%0A%20avidemux/ADM_libraries/ADM_lavutil%20avidemux/ADM_libraries/ADM_libMad%0A%20avidemux/ADM_libraries/ADM_libMpeg2Dec%20avidemux/ADM_libraries/ADM_liba52%0A%20avidemux/ADM_libraries/ADM_libass%20avidemux/ADM_libraries/ADM_libmpeg2enc%0A%20avidemux/ADM_libraries/ADM_libpostproc%0A%20avidemux/ADM_libraries/ADM_libswscale%20avidemux/ADM_libraries/ADM_libtwolame%0A%20avidemux/ADM_libraries/ADM_libwrapper%20avidemux/ADM_libraries/ADM_lvemux%0A%20avidemux/ADM_libraries/ADM_mplex%20avidemux/ADM_libraries/ADM_smjs%0A%20avidemux/ADM_libraries/ADM_utilities%20avidemux/ADM_libraries/ADM_xvidratectl%0A%20avidemux/ADM_outputs%20avidemux/ADM_outputs/oplug_avi%0A%20avidemux/ADM_outputs/oplug_mp4%20avidemux/ADM_outputs/oplug_mpeg%0A%20avidemux/ADM_outputs/oplug_mpegFF%20avidemux/ADM_outputs/oplug_ogm%0A%20avidemux/ADM_userInterfaces/ADM_GTK%0A%20avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog%20avidemux/A%21%0A%20DM_userInterfaces/ADM_GTK/ADM_dialogFactory%0A%20avidemux/ADM_userInterfaces/ADM_GTK/ADM_filters%0A%20avidemux/ADM_userInterfaces/ADM_GTK/ADM_gui2%0A%20avidemux/ADM_userInterfaces/ADM_GTK/ADM_ocr%0A%20avidemux/ADM_userInterfaces/ADM_GTK/ADM_toolkit_gtk%20cmake&In-Reply-To=%3C200705281303.l4SD3qnJ011559%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000452.html">
   <LINK REL="Next"  HREF="000454.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Avidemux-svn-commit] r3158 - in branches/avidemux_2.4_branch: . autononreg/dialogFactory avidemux/ADM_libraries avidemux/ADM_libraries/ADM_lavcodec avidemux/ADM_libraries/ADM_lavformat avidemux/ADM_libraries/ADM_lavutil avidemux/ADM_libraries/ADM_libMad avidemux/ADM_libraries/ADM_libMpeg2Dec avidemux/ADM_libraries/ADM_liba52 avidemux/ADM_libraries/ADM_libass avidemux/ADM_libraries/ADM_libmpeg2enc avidemux/ADM_libraries/ADM_libpostproc avidemux/ADM_libraries/ADM_libswscale avidemux/ADM_libraries/ADM_libtwolame avidemux/ADM_libraries/ADM_libwrapper avidemux/ADM_libraries/ADM_lvemux avidemux/ADM_libraries/ADM_mplex avidemux/ADM_libraries/ADM_smjs avidemux/ADM_libraries/ADM_utilities avidemux/ADM_libraries/ADM_xvidratectl avidemux/ADM_outputs avidemux/ADM_outputs/oplug_avi avidemux/ADM_outputs/oplug_mp4 avidemux/ADM_outputs/oplug_mpeg avidemux/ADM_outputs/oplug_mpegFF avidemux/ADM_outputs/oplug_ogm avidemux/ADM_userInterfaces/ADM_GTK avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog avidemux/A! DM_userInterfaces/ADM_GTK/ADM_dialogFactory avidemux/ADM_userInterfaces/ADM_GTK/ADM_filters avidemux/ADM_userInterfaces/ADM_GTK/ADM_gui2 avidemux/ADM_userInterfaces/ADM_GTK/ADM_ocr avidemux/ADM_userInterfaces/ADM_GTK/ADM_toolkit_gtk cmake</H1>
    <B>mean at BerliOS</B> 
    <A HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r3158%20-%20in%20branches/avidemux_2.4_branch%3A%20.%0A%20autononreg/dialogFactory%20avidemux/ADM_libraries%0A%20avidemux/ADM_libraries/ADM_lavcodec%20avidemux/ADM_libraries/ADM_lavformat%0A%20avidemux/ADM_libraries/ADM_lavutil%20avidemux/ADM_libraries/ADM_libMad%0A%20avidemux/ADM_libraries/ADM_libMpeg2Dec%20avidemux/ADM_libraries/ADM_liba52%0A%20avidemux/ADM_libraries/ADM_libass%20avidemux/ADM_libraries/ADM_libmpeg2enc%0A%20avidemux/ADM_libraries/ADM_libpostproc%0A%20avidemux/ADM_libraries/ADM_libswscale%20avidemux/ADM_libraries/ADM_libtwolame%0A%20avidemux/ADM_libraries/ADM_libwrapper%20avidemux/ADM_libraries/ADM_lvemux%0A%20avidemux/ADM_libraries/ADM_mplex%20avidemux/ADM_libraries/ADM_smjs%0A%20avidemux/ADM_libraries/ADM_utilities%20avidemux/ADM_libraries/ADM_xvidratectl%0A%20avidemux/ADM_outputs%20avidemux/ADM_outputs/oplug_avi%0A%20avidemux/ADM_outputs/oplug_mp4%20avidemux/ADM_outputs/oplug_mpeg%0A%20avidemux/ADM_outputs/oplug_mpegFF%20avidemux/ADM_outputs/oplug_ogm%0A%20avidemux/ADM_userInterfaces/ADM_GTK%0A%20avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog%20avidemux/A%21%0A%20DM_userInterfaces/ADM_GTK/ADM_dialogFactory%0A%20avidemux/ADM_userInterfaces/ADM_GTK/ADM_filters%0A%20avidemux/ADM_userInterfaces/ADM_GTK/ADM_gui2%0A%20avidemux/ADM_userInterfaces/ADM_GTK/ADM_ocr%0A%20avidemux/ADM_userInterfaces/ADM_GTK/ADM_toolkit_gtk%20cmake&In-Reply-To=%3C200705281303.l4SD3qnJ011559%40sheep.berlios.de%3E"
       TITLE="[Avidemux-svn-commit] r3158 - in branches/avidemux_2.4_branch: . autononreg/dialogFactory avidemux/ADM_libraries avidemux/ADM_libraries/ADM_lavcodec avidemux/ADM_libraries/ADM_lavformat avidemux/ADM_libraries/ADM_lavutil avidemux/ADM_libraries/ADM_libMad avidemux/ADM_libraries/ADM_libMpeg2Dec avidemux/ADM_libraries/ADM_liba52 avidemux/ADM_libraries/ADM_libass avidemux/ADM_libraries/ADM_libmpeg2enc avidemux/ADM_libraries/ADM_libpostproc avidemux/ADM_libraries/ADM_libswscale avidemux/ADM_libraries/ADM_libtwolame avidemux/ADM_libraries/ADM_libwrapper avidemux/ADM_libraries/ADM_lvemux avidemux/ADM_libraries/ADM_mplex avidemux/ADM_libraries/ADM_smjs avidemux/ADM_libraries/ADM_utilities avidemux/ADM_libraries/ADM_xvidratectl avidemux/ADM_outputs avidemux/ADM_outputs/oplug_avi avidemux/ADM_outputs/oplug_mp4 avidemux/ADM_outputs/oplug_mpeg avidemux/ADM_outputs/oplug_mpegFF avidemux/ADM_outputs/oplug_ogm avidemux/ADM_userInterfaces/ADM_GTK avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog avidemux/A! DM_userInterfaces/ADM_GTK/ADM_dialogFactory avidemux/ADM_userInterfaces/ADM_GTK/ADM_filters avidemux/ADM_userInterfaces/ADM_GTK/ADM_gui2 avidemux/ADM_userInterfaces/ADM_GTK/ADM_ocr avidemux/ADM_userInterfaces/ADM_GTK/ADM_toolkit_gtk cmake">mean at mail.berlios.de
       </A><BR>
    <I>Mon May 28 15:03:52 CEST 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="000452.html">[Avidemux-svn-commit] r3157 - in branches/avidemux_2.4_branch: . avidemux avidemux/ADM_audio avidemux/ADM_audiocodec avidemux/ADM_audiodevice avidemux/ADM_audiofilter avidemux/ADM_codecs avidemux/ADM_colorspace avidemux/ADM_editor avidemux/ADM_encoder avidemux/ADM_filter avidemux/ADM_inputs avidemux/ADM_inputs/ADM_asf avidemux/ADM_inputs/ADM_avsproxy avidemux/ADM_inputs/ADM_h263 avidemux/ADM_inputs/ADM_inpics avidemux/ADM_inputs/ADM_matroska avidemux/ADM_inputs/ADM_mp4 avidemux/ADM_inputs/ADM_mpegdemuxer avidemux/ADM_inputs/ADM_nuv avidemux/ADM_inputs/ADM_ogm avidemux/ADM_inputs/ADM_openDML avidemux/ADM_libraries avidemux/ADM_ocr avidemux/ADM_osSupport avidemux/ADM_requant avidemux/ADM_script avidemux/ADM_toolkit avidemux/ADM_userInterfaces avidemux/ADM_userInterfaces/ADM_NONE avidemux/ADM_userInterfaces/ADM_NONE/ADM_dialog avidemux/ADM_userInterfaces/ADM_NONE/ADM_dialogFactory avidemux/ADM_userInterfaces/ADM_NONE/ADM_filters avidemux/ADM_userInterfaces/ADM_NONE/ADM_gui2 avidemux/ADM_use! rInterfaces/ADM_commonUI avidemux/ADM_video avidemux/ADM_videoFilter po
</A></li>
        <LI>Next message: <A HREF="000454.html">[Avidemux-svn-commit] r3159 - in branches/avidemux_2.4_branch: .	avidemux avidemux/ADM_editor avidemux/ADM_inputs	avidemux/ADM_inputs/ADM_asf avidemux/ADM_inputs/ADM_nuv	avidemux/ADM_libraries	avidemux/ADM_libraries/ADM_lavcodec/i386 avidemux/ADM_ocr	avidemux/ADM_userInterfaces	avidemux/ADM_userInterfaces/ADM_NONE/ADM_dialog	avidemux/ADM_userInterfaces/ADM_NONE/ADM_dialogFactory	avidemux/ADM_userInterfaces/ADM_NONE/ADM_filters	avidemux/ADM_userInterfaces/ADM_NONE/ADM_gui2	avidemux/ADM_userInterfaces/ADM_commonUI avidemux/ADM_video	avidemux/ADM_videoFilter
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#453">[ date ]</a>
              <a href="thread.html#453">[ thread ]</a>
              <a href="subject.html#453">[ subject ]</a>
              <a href="author.html#453">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: mean
Date: 2007-05-28 15:03:46 +0200 (Mon, 28 May 2007)
New Revision: 3158

Added:
   branches/avidemux_2.4_branch/ConfigureChecks.cmake
   branches/avidemux_2.4_branch/autononreg/dialogFactory/slider.js
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/CMakeLists.txt
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/CMakeLists.txt
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/CMakeLists.txt
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_libMad/CMakeLists.txt
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_libMpeg2Dec/CMakeLists.txt
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_liba52/CMakeLists.txt
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_libass/CMakeLists.txt
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_libmpeg2enc/CMakeLists.txt
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_libpostproc/
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_libpostproc/CMakeLists.txt
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_libpostproc/mangle.h
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_libpostproc/postprocess.c
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_libpostproc/postprocess.h
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_libpostproc/postprocess_altivec_template.c
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_libpostproc/postprocess_internal.h
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_libpostproc/postprocess_template.c
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_libswscale/CMakeLists.txt
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_libtwolame/CMakeLists.txt
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_libwrapper/CMakeLists.txt
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lvemux/CMakeLists.txt
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/CMakeLists.txt
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs/CMakeLists.txt
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_utilities/CMakeLists.txt
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_xvidratectl/CMakeLists.txt
   branches/avidemux_2.4_branch/avidemux/ADM_outputs/CMakeLists.txt
   branches/avidemux_2.4_branch/avidemux/ADM_outputs/oplug_avi/CMakeLists.txt
   branches/avidemux_2.4_branch/avidemux/ADM_outputs/oplug_mp4/CMakeLists.txt
   branches/avidemux_2.4_branch/avidemux/ADM_outputs/oplug_mpeg/CMakeLists.txt
   branches/avidemux_2.4_branch/avidemux/ADM_outputs/oplug_mpegFF/CMakeLists.txt
   branches/avidemux_2.4_branch/avidemux/ADM_outputs/oplug_ogm/CMakeLists.txt
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/CMakeLists.txt
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialogFactory/CMakeLists.txt
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_filters/CMakeLists.txt
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_gui2/CMakeLists.txt
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_ocr/
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_ocr/CMakeLists.txt
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_ocr/adm_ocr.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_toolkit_gtk/CMakeLists.txt
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/CMakeLists.txt
   branches/avidemux_2.4_branch/cmake/
   branches/avidemux_2.4_branch/cmake/AdmLib.cmake
   branches/avidemux_2.4_branch/cmake/FindGTK.cmake
   branches/avidemux_2.4_branch/cmake/FindLibXml2.cmake
   branches/avidemux_2.4_branch/cmake/FindQT4.cmake
   branches/avidemux_2.4_branch/cmake/FindX11.cmake
   branches/avidemux_2.4_branch/cmake/MacroEnsureOutOfSourceBuild.cmake
   branches/avidemux_2.4_branch/cmake/Po.cmake
   branches/avidemux_2.4_branch/cmake/UsePkgConfig.cmake
   branches/avidemux_2.4_branch/cmake/UseQt4.cmake
   branches/avidemux_2.4_branch/cmake/lavcodec.cmake
   branches/avidemux_2.4_branch/config.h.cmake
Log:
added cmake

Added: branches/avidemux_2.4_branch/ConfigureChecks.cmake
===================================================================
--- branches/avidemux_2.4_branch/ConfigureChecks.cmake	2007-05-27 18:44:33 UTC (rev 3157)
+++ branches/avidemux_2.4_branch/ConfigureChecks.cmake	2007-05-28 13:03:46 UTC (rev 3158)
@@ -0,0 +1,61 @@
+###############################
+# Part Of avidemux cmake conf #
+###############################
+##
+INCLUDE(CheckIncludeFiles)
+INCLUDE(CheckSymbolExists)
+INCLUDE(CheckFunctionExists)
+INCLUDE(CheckLibraryExists)
+include(lavcodec)
+#INCLUDE(CheckStructMember)
+check_function_exists(gettimeofday    HAVE_GETTIMEOFDAY)
+# Header
+CHECK_INCLUDE_FILES(inttypes.h      HAVE_INTTYPES_H)                    # simapi.h
+CHECK_INCLUDE_FILES(stddef.h        HAVE_STDDEF_H)                      # simapi.h
+CHECK_INCLUDE_FILES(stdint.h        HAVE_STDINT_H)                      # simapi.h
+CHECK_INCLUDE_FILES(stdlib.h        HAVE_STDLIB_H)                      # simapi.h
+CHECK_INCLUDE_FILES(string.h        HAVE_STRING_H)                      # _core/libintl.cpp
+CHECK_INCLUDE_FILES(sys/stat.h      HAVE_SYS_STAT_H)                    # gpg/gpg.cpp
+CHECK_INCLUDE_FILES(sys/types.h     HAVE_SYS_TYPES_H)                   # simapi.h
+CHECK_INCLUDE_FILES(unistd.h        HAVE_UNISTD_H)                      # simapi.h
+CHECK_INCLUDE_FILES(malloc.h        HAVE_MALLOC_H)                      # simapi.h
+# Set lavcodec/util/format configuration
+SET_LAVCODEC_FLAGS()
+
+# Symbols
+CHECK_SYMBOL_EXISTS(strcasecmp  &quot;strings.h&quot;         HAVE_STRCASECMP)    # simapi.h, various
+
+# Functions
+IF(NOT WIN32) # there is a chmod function on win32, but not usable the way we want...
+  CHECK_FUNCTION_EXISTS(chmod     HAVE_CHMOD)         # __homedir/homedir.cpp, gpg/gpg.cpp
+ENDIF(NOT WIN32)
+# VERSION(s)
+SET(VERSION 2.4)
+SET(PACKAGE_VERSION 2.4)
+
+# We use FFMPEG
+SET(USE_FFMPEG    1)
+SET(USE_MJPEG    1)
+SET(USE_LIBXML2    1)
+SET(HAVE_LRINTF    1)
+SET(EMULATE_FAST_INT    1)
+SET(RUNTIME_CPUDETECT    1)
+# to be better latter
+SET(ARCH_X86    1)
+SET(HAVE_MMX    1)
+SET(HAVE_AUDIO    1)
+SET(ARCH_X86_32    1)
+SET(ARCH_X86_64    1)
+SET(FPM_DEFAULT    1)
+SET(ARCH_64_BITS    1)
+SET(ADM_DEBUG    1)
+
+# We have Encoders
+
+#if win 32 ?
+if(WIN32)
+SET(ADM_WIN32 1)
+SET(CYG_MANGLING 1)
+endif(WIN32)
+
+# EOF

Copied: branches/avidemux_2.4_branch/autononreg/dialogFactory/slider.js (from rev 3098, branches/avidemux_2.4_branch/autononreg/dialogFactory/toggle.js)
===================================================================
--- branches/avidemux_2.4_branch/autononreg/dialogFactory/toggle.js	2007-05-15 15:15:31 UTC (rev 3098)
+++ branches/avidemux_2.4_branch/autononreg/dialogFactory/slider.js	2007-05-28 13:03:46 UTC (rev 3158)
@@ -0,0 +1,10 @@
+//AD  &lt;- These first 4 characters need to be the first 4 characters to identify the ECMAScript file to Avidemux
+var app = new Avidemux();
+var file=&quot;/work/samples/2mn.avi&quot;;
+var goodfcc=&quot;DIV3&quot;;
+var fps;
+
+	dialogFactorySlider();
+
+/* End of test
+*/

Added: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/CMakeLists.txt
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/CMakeLists.txt	2007-05-27 18:44:33 UTC (rev 3157)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec/CMakeLists.txt	2007-05-28 13:03:46 UTC (rev 3158)
@@ -0,0 +1,40 @@
+################################
+#
+################################
+include(AdmLib)
+SET(ADM_LIB ADM_lavcodec)
+#
+SET(${ADM_LIB}_SRCS 
+ac3enc.c  
+		adpcm.c 	allcodecs.c 	cyuv.c 	dsputil.c 	dv.c 
+		error_resilience.c 		fdctref.c 	fft.c 	h263.c 	h263dec.c 	huffyuv.c 	imgconvert.c 
+		jfdctfst.c 	jfdctint.c 	jrevdct.c 	mace.c 	mdct.c 	 	mjpeg.c 
+		motion_est.c 	mpeg12.c 	mpegaudio.c 	mpegaudiodec.c 	mpegvideo.c 	msmpeg4.c 	 
+		pcm.c 	ratecontrol.c 	raw.c 	resample.c 	rv10.c 	simple_idct.c 	svq1.c 
+		utils.c 	wmadec.c 	indeo3.c 	vp3.c 	vp3dsp.c 	h264.c 	ffv1.c 	ra144.c 	ra288.c 
+		golomb.c 	4xm.c 	cabac.c 	asv1.c vcr1.c cljr.c 	faandct.c 	 	parser.c 
+		roqvideo.c 	xan.c 	rpza.c 	msrle.c 	msvideo1.c 	cinepak.c 	vqavideo.c 
+		idcinvideo.c 	smc.c 	flicvideo.c 	interplayvideo.c 	dpcm.c 	8bps.c vmdav.c 
+		truemotion1.c flac.c g726.c 	qtrle.c lcl.c 	snow.c  
+		rangecoder.c bitstream.c h264idct.c h261.c amr.c tscc.c 
+		resample2.c pthread.c qdm2.c bitstream_filter.c eval.c 
+		vc1.c vc1dsp.c vp56.c vp56data.c vp6.c vp5.c indeo2.c smacker.c  opt.c
+)
+# ADD x86 ones
+SET(${ADM_LIB}_SRCS  ${${ADM_LIB}_SRCS}
+                        i386/cputest.c     
+			i386/mpegvideo_mmx.c     i386/vp3dsp_mmx.c 
+			i386/dsputil_mmx.c  i386/idct_mmx.c  
+			i386/fdct_mmx.c   i386/motion_est_mmx.c  i386/simple_idct_mmx.c 
+			i386/fft_sse.c i386/vp3dsp_sse2.c  
+			i386/idct_mmx_xvid.c i386/fft_3dn2.c 
+			i386/snowdsp_mmx.c i386/fft_3dn.c 
+)
+
+ADD_LIBRARY(${ADM_LIB} STATIC ${${ADM_LIB}_SRCS})
+ADD_ADM_LIB(${ADM_LIB} ADM_libraries)
+
+
+################################
+add_definitions(-I.. -DHAVE_AV_CONFIG_H  -O3 -I../.. -I../ADM_lavutil -Drestrict=__restrict__ -fomit-frame-pointer)
+

Added: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/CMakeLists.txt
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/CMakeLists.txt	2007-05-27 18:44:33 UTC (rev 3157)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/CMakeLists.txt	2007-05-28 13:03:46 UTC (rev 3158)
@@ -0,0 +1,17 @@
+################################
+#
+################################
+include(AdmLib)
+SET(ADM_LIB ADM_lavformat)
+#
+SET(${ADM_LIB}_SRCS 
+ mpeg.c utils.c avio.c ADM_lavformat.cpp 
+aviobuf.c cutils.c img2.c file.c mpegtsenc.c ADM_muxts.cpp movenc.c 
+avienc.c wav.c mov.c matroska.c isom.c isom.h riff.c
+)
+ADD_LIBRARY(${ADM_LIB} STATIC ${${ADM_LIB}_SRCS})
+ADD_ADM_LIB(${ADM_LIB} ADM_libraries)
+INCLUDE_DIRECTORIES(../ADM_lavcodec .. ../ADM_lavutil)
+
+################################
+add_definitions(-DHAVE_AV_CONFIG_H)

Added: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/CMakeLists.txt
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/CMakeLists.txt	2007-05-27 18:44:33 UTC (rev 3157)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil/CMakeLists.txt	2007-05-28 13:03:46 UTC (rev 3158)
@@ -0,0 +1,15 @@
+################################
+#
+################################
+include(AdmLib)
+SET(ADM_LIB ADM_lavutil)
+#
+SET(${ADM_LIB}_SRCS 
+integer.c  intfloat_readwrite.c  mathematics.c  rational.c md5.c crc.c log.c  adler32.c lls.c
+
+)
+ADD_LIBRARY(${ADM_LIB} STATIC ${${ADM_LIB}_SRCS})
+ADD_ADM_LIB(${ADM_LIB} ADM_libraries)
+
+################################
+add_definitions(-DHAVE_AV_CONFIG_H)

Added: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_libMad/CMakeLists.txt
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_libMad/CMakeLists.txt	2007-05-27 18:44:33 UTC (rev 3157)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_libMad/CMakeLists.txt	2007-05-28 13:03:46 UTC (rev 3158)
@@ -0,0 +1,24 @@
+
+SET(ADM_libMad_SRCS 
+bit.c  decoder.c  fixed.c  frame.c  huffman.c  layer12.c  layer3.c  
+#minimad.c  i
+stream.c  synth.c  timer.c  version.c
+)
+ADD_LIBRARY(ADM_libMad STATIC ${ADM_libMad_SRCS})
+
+################################
+#
+################################
+include(AdmLib)
+SET(ADM_LIB ADM_libMad)
+#
+SET(${ADM_LIB}_SRCS 
+bit.c  decoder.c  fixed.c  frame.c  huffman.c  layer12.c  layer3.c  
+#minimad.c  i
+stream.c  synth.c  timer.c  version.c
+)
+ADD_LIBRARY(${ADM_LIB} STATIC ${${ADM_LIB}_SRCS})
+ADD_ADM_LIB(${ADM_LIB} ADM_libraries)
+
+
+################################

Added: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_libMpeg2Dec/CMakeLists.txt
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_libMpeg2Dec/CMakeLists.txt	2007-05-27 18:44:33 UTC (rev 3157)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_libMpeg2Dec/CMakeLists.txt	2007-05-28 13:03:46 UTC (rev 3158)
@@ -0,0 +1,20 @@
+
+SET(ADM_libMpeg2dec_SRCS 
+alloc.c      cpu_state.c  header.c      idct_altivec.c  idct_mlib.c  motion_comp_alpha.c    motion_comp.c       motion_comp_mmx.c
+cpu_accel.c  decode.c     idct_alpha.c  idct.c          idct_mmx.c   motion_comp_altivec.c  motion_comp_mlib.c  slice.c
+)
+ADD_LIBRARY(ADM_libMpeg2dec STATIC ${ADM_libMpeg2dec_SRCS})
+################################
+#
+################################
+include(AdmLib)
+SET(ADM_LIB ADM_libMpeg2Dec)
+#
+SET(${ADM_LIB}_SRCS 
+alloc.c      cpu_state.c  header.c      idct_altivec.c  idct_mlib.c  motion_comp_alpha.c    motion_comp.c       motion_comp_mmx.c
+cpu_accel.c  decode.c     idct_alpha.c  idct.c          idct_mmx.c   motion_comp_altivec.c  motion_comp_mlib.c  slice.c
+)
+ADD_LIBRARY(${ADM_LIB} STATIC ${${ADM_LIB}_SRCS})
+ADD_ADM_LIB(${ADM_LIB} ADM_libraries)
+
+################################

Added: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_liba52/CMakeLists.txt
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_liba52/CMakeLists.txt	2007-05-27 18:44:33 UTC (rev 3157)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_liba52/CMakeLists.txt	2007-05-28 13:03:46 UTC (rev 3158)
@@ -0,0 +1,14 @@
+################################
+#
+################################
+include(AdmLib)
+SET(ADM_LIB ADM_liba52)
+#
+SET(${ADM_LIB}_SRCS 
+bit_allocate.c  bitstream.c  cmake_install.cmake  downmix.c  imdct.c  parse.c
+)
+ADD_LIBRARY(${ADM_LIB} STATIC ${${ADM_LIB}_SRCS})
+ADD_ADM_LIB(${ADM_LIB} ADM_libraries)
+
+
+################################

Added: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_libass/CMakeLists.txt
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_libass/CMakeLists.txt	2007-05-27 18:44:33 UTC (rev 3157)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_libass/CMakeLists.txt	2007-05-28 13:03:46 UTC (rev 3158)
@@ -0,0 +1,16 @@
+################################
+#
+################################
+include(AdmLib)
+SET(ADM_LIB ADM_libass)
+#
+if(FT_FOUND)
+SET(${ADM_LIB}_SRCS 
+ass_bitmap.c  ass.c  ass_cache.c  ass_fontconfig.c  ass_library.c  ass_mp.c  ass_render.c  ass_utils.c  mputils.c
+)
+ADD_LIBRARY(${ADM_LIB} STATIC ${${ADM_LIB}_SRCS})
+ADD_ADM_LIB(${ADM_LIB} ADM_libraries)
+endif(FT_FOUND)
+
+################################
+ADD_definitions(${FT_CFLAGS} )

Added: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_libmpeg2enc/CMakeLists.txt
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_libmpeg2enc/CMakeLists.txt	2007-05-27 18:44:33 UTC (rev 3157)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_libmpeg2enc/CMakeLists.txt	2007-05-28 13:03:46 UTC (rev 3158)
@@ -0,0 +1,22 @@
+################################
+#
+################################
+include(AdmLib)
+SET(ADM_LIB ADM_libmpeg2enc)
+#
+SET(${ADM_LIB}_SRCS 
+ad_layer.cc           fdct_x86.cc           mblock_bsad_mmx.cc          motionest.cc     predcomp_mmxe.cc  putpic.cc        readpic.cc       yuv4mpeg.cc
+build_sub22_mests.cc  feedframe.cc          mblock_bsumsq_mmx.cc        motionsearch.cc  predict.cc        putseq.cc        stats.cc         yuv4mpeg_ratio.cc
+build_sub44_mests.cc  find_best_one_pel.cc  mblock_sad_mmx.cc           mpeg2enc.cc      predict_mmx.cc    putvlc.cc        synchrolib.cc
+conform.cc            idct.cc               mblock_sad_mmxe.cc          mpeg2enc_if.cc   predict_ref.cc    quantize.cc      transfrm.cc
+cpu_accel.cc          idctdata.cc           mblock_sub44_sads_x86.cc    mpeg2param.cc    predict_x86.cc    quantize_ref.cc  transfrm_ref.cc
+fdctdata.cc           idct_mmx.cc           mpeg2setup.cc               putbits.cc        quantize_x86.cc  transfrm_x86.cc
+fdct_mmx.cc           ioio.c                mblock_sumsq_mmx.cc         mpegconsts.cc    puthdr.cc         quant_mmx2.cc    writepic.cc
+fdctref.cc            macroblock.cc         motion.cc                   predcomp_mmx.cc  putmpg.cc         ratectl.cc       xx.c 
+ADM_mpe2enc.cpp
+)
+ADD_LIBRARY(${ADM_LIB} STATIC ${${ADM_LIB}_SRCS})
+ADD_ADM_LIB(${ADM_LIB} ADM_libraries)
+
+################################
+INCLUDE_DIRECTORIES(.)

Added: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_libpostproc/CMakeLists.txt
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_libpostproc/CMakeLists.txt	2007-05-27 18:44:33 UTC (rev 3157)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_libpostproc/CMakeLists.txt	2007-05-28 13:03:46 UTC (rev 3158)
@@ -0,0 +1,17 @@
+################################
+#
+################################
+include(AdmLib)
+SET(ADM_LIB ADM_libpostproc)
+#
+SET(${ADM_LIB}_SRCS 
+postprocess.c
+)
+
+ADD_LIBRARY(${ADM_LIB} STATIC ${${ADM_LIB}_SRCS})
+ADD_ADM_LIB(${ADM_LIB} ADM_libraries)
+
+
+################################
+add_definitions(-I.. -DHAVE_AV_CONFIG_H  -O3 -I../.. -I../ADM_lavutil -Drestrict=__restrict__ -fomit-frame-pointer -msse )
+

Added: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_libpostproc/mangle.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_libpostproc/mangle.h	2007-05-27 18:44:33 UTC (rev 3157)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_libpostproc/mangle.h	2007-05-28 13:03:46 UTC (rev 3158)
@@ -0,0 +1,47 @@
+/*
+ * mangle.h - This file has some CPP macros to deal with different symbol
+ * mangling across binary formats.
+ *
+ * (c)2002 by Felix Buenemann &lt;atmosfear at users.sourceforge.net&gt;
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef __MANGLE_H
+#define __MANGLE_H
+
+/* Feel free to add more to the list, eg. a.out IMO */
+/* Use rip-relative addressing if compiling PIC code on x86-64. */
+#if defined(__CYGWIN__) || defined(__MINGW32__) || defined(__OS2__) || \
+   (defined(__OpenBSD__) &amp;&amp; !defined(__ELF__))
+#if defined(ARCH_X86_64) &amp;&amp; defined(PIC)
+#define MANGLE(a) &quot;_&quot; #a&quot;(%%rip)&quot;
+#else
+#define MANGLE(a) &quot;_&quot; #a
+#endif
+#else
+#if defined(ARCH_X86_64) &amp;&amp; defined(PIC)
+#define MANGLE(a) #a&quot;(%%rip)&quot;
+#elif defined(CONFIG_DARWIN)
+#define MANGLE(a) &quot;_&quot; #a
+#else
+#define MANGLE(a) #a
+#endif
+#endif
+
+#endif /* !__MANGLE_H */
+

Added: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_libpostproc/postprocess.c
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_libpostproc/postprocess.c	2007-05-27 18:44:33 UTC (rev 3157)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_libpostproc/postprocess.c	2007-05-28 13:03:46 UTC (rev 3158)
@@ -0,0 +1,1144 @@
+/*
+ * Copyright (C) 2001-2003 Michael Niedermayer (<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">michaelni at gmx.at</A>)
+ *
+ * AltiVec optimizations (C) 2004 Romain Dolbeau &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">romain at dolbeau.org</A>&gt;
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+/**
+ * @file postprocess.c
+ * postprocessing.
+ */
+
+/*
+                        C       MMX     MMX2    3DNow   AltiVec
+isVertDC                Ec      Ec                      Ec
+isVertMinMaxOk          Ec      Ec                      Ec
+doVertLowPass           E               e       e       Ec
+doVertDefFilter         Ec      Ec      e       e       Ec
+isHorizDC               Ec      Ec                      Ec
+isHorizMinMaxOk         a       E                       Ec
+doHorizLowPass          E               e       e       Ec
+doHorizDefFilter        Ec      Ec      e       e       Ec
+do_a_deblock            Ec      E       Ec      E
+deRing                  E               e       e*      Ecp
+Vertical RKAlgo1        E               a       a
+Horizontal RKAlgo1                      a       a
+Vertical X1#            a               E       E
+Horizontal X1#          a               E       E
+LinIpolDeinterlace      e               E       E*
+CubicIpolDeinterlace    a               e       e*
+LinBlendDeinterlace     e               E       E*
+MedianDeinterlace#      E       Ec      Ec
+TempDeNoiser#           E               e       e       Ec
+
+* i dont have a 3dnow CPU -&gt; its untested, but noone said it doesnt work so it seems to work
+# more or less selfinvented filters so the exactness isnt too meaningfull
+E = Exact implementation
+e = allmost exact implementation (slightly different rounding,...)
+a = alternative / approximate impl
+c = checked against the other implementations (-vo md5)
+p = partially optimized, still some work to do
+*/
+
+/*
+TODO:
+reduce the time wasted on the mem transfer
+unroll stuff if instructions depend too much on the prior one
+move YScale thing to the end instead of fixing QP
+write a faster and higher quality deblocking filter :)
+make the mainloop more flexible (variable number of blocks at once
+        (the if/else stuff per block is slowing things down)
+compare the quality &amp; speed of all filters
+split this huge file
+optimize c versions
+try to unroll inner for(x=0 ... loop to avoid these damn if(x ... checks
+...
+*/
+
+//Changelog: use the Subversion log
+
+#include &quot;config.h&quot;
+#include &quot;../ADM_lavutil/avutil.h&quot;
+#include &lt;inttypes.h&gt;
+#include &lt;stdio.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;string.h&gt;
+#ifdef HAVE_MALLOC_H
+#include &lt;malloc.h&gt;
+#endif
+//#undef HAVE_MMX2
+//#define HAVE_3DNOW
+//#undef HAVE_MMX
+//#undef ARCH_X86
+//#define DEBUG_BRIGHTNESS
+#ifdef USE_FASTMEMCPY
+#include &quot;libvo/fastmemcpy.h&quot;
+#endif
+#include &quot;postprocess.h&quot;
+#include &quot;postprocess_internal.h&quot;
+
+#include &quot;mangle.h&quot; //FIXME should be supressed
+
+#ifdef HAVE_ALTIVEC_H
+#include &lt;altivec.h&gt;
+#endif
+
+#define GET_MODE_BUFFER_SIZE 500
+#define OPTIONS_ARRAY_SIZE 10
+#define BLOCK_SIZE 8
+#define TEMP_STRIDE 8
+//#define NUM_BLOCKS_AT_ONCE 16 //not used yet
+
+#if defined(ARCH_X86)
+static uint64_t __attribute__((aligned(8))) attribute_used w05= 0x0005000500050005LL;
+static uint64_t __attribute__((aligned(8))) attribute_used w04= 0x0004000400040004LL;
+static uint64_t __attribute__((aligned(8))) attribute_used w20= 0x0020002000200020LL;
+static uint64_t __attribute__((aligned(8))) attribute_used b00= 0x0000000000000000LL;
+static uint64_t __attribute__((aligned(8))) attribute_used b01= 0x0101010101010101LL;
+static uint64_t __attribute__((aligned(8))) attribute_used b02= 0x0202020202020202LL;
+static uint64_t __attribute__((aligned(8))) attribute_used b08= 0x0808080808080808LL;
+static uint64_t __attribute__((aligned(8))) attribute_used b80= 0x8080808080808080LL;
+#endif
+
+static uint8_t clip_table[3*256];
+static uint8_t * const clip_tab= clip_table + 256;
+
+static const int attribute_used deringThreshold= 20;
+
+
+static struct PPFilter filters[]=
+{
+        {&quot;hb&quot;, &quot;hdeblock&quot;,              1, 1, 3, H_DEBLOCK},
+        {&quot;vb&quot;, &quot;vdeblock&quot;,              1, 2, 4, V_DEBLOCK},
+/*      {&quot;hr&quot;, &quot;rkhdeblock&quot;,            1, 1, 3, H_RK1_FILTER},
+        {&quot;vr&quot;, &quot;rkvdeblock&quot;,            1, 2, 4, V_RK1_FILTER},*/
+        {&quot;h1&quot;, &quot;x1hdeblock&quot;,            1, 1, 3, H_X1_FILTER},
+        {&quot;v1&quot;, &quot;x1vdeblock&quot;,            1, 2, 4, V_X1_FILTER},
+        {&quot;ha&quot;, &quot;ahdeblock&quot;,             1, 1, 3, H_A_DEBLOCK},
+        {&quot;va&quot;, &quot;avdeblock&quot;,             1, 2, 4, V_A_DEBLOCK},
+        {&quot;dr&quot;, &quot;dering&quot;,                1, 5, 6, DERING},
+        {&quot;al&quot;, &quot;autolevels&quot;,            0, 1, 2, LEVEL_FIX},
+        {&quot;lb&quot;, &quot;linblenddeint&quot;,         1, 1, 4, LINEAR_BLEND_DEINT_FILTER},
+        {&quot;li&quot;, &quot;linipoldeint&quot;,          1, 1, 4, LINEAR_IPOL_DEINT_FILTER},
+        {&quot;ci&quot;, &quot;cubicipoldeint&quot;,        1, 1, 4, CUBIC_IPOL_DEINT_FILTER},
+        {&quot;md&quot;, &quot;mediandeint&quot;,           1, 1, 4, MEDIAN_DEINT_FILTER},
+        {&quot;fd&quot;, &quot;ffmpegdeint&quot;,           1, 1, 4, FFMPEG_DEINT_FILTER},
+        {&quot;l5&quot;, &quot;lowpass5&quot;,              1, 1, 4, LOWPASS5_DEINT_FILTER},
+        {&quot;tn&quot;, &quot;tmpnoise&quot;,              1, 7, 8, TEMP_NOISE_FILTER},
+        {&quot;fq&quot;, &quot;forcequant&quot;,            1, 0, 0, FORCE_QUANT},
+        {NULL, NULL,0,0,0,0} //End Marker
+};
+
+static const char *replaceTable[]=
+{
+        &quot;default&quot;,      &quot;hdeblock:a,vdeblock:a,dering:a&quot;,
+        &quot;de&quot;,           &quot;hdeblock:a,vdeblock:a,dering:a&quot;,
+        &quot;fast&quot;,         &quot;x1hdeblock:a,x1vdeblock:a,dering:a&quot;,
+        &quot;fa&quot;,           &quot;x1hdeblock:a,x1vdeblock:a,dering:a&quot;,
+        &quot;ac&quot;,           &quot;ha:a:128:7,va:a,dering:a&quot;,
+        NULL //End Marker
+};
+
+
+#if defined(ARCH_X86)
+static inline void prefetchnta(void *p)
+{
+        asm volatile(   &quot;prefetchnta (%0)\n\t&quot;
+                : : &quot;r&quot; (p)
+        );
+}
+
+static inline void prefetcht0(void *p)
+{
+        asm volatile(   &quot;prefetcht0 (%0)\n\t&quot;
+                : : &quot;r&quot; (p)
+        );
+}
+
+static inline void prefetcht1(void *p)
+{
+        asm volatile(   &quot;prefetcht1 (%0)\n\t&quot;
+                : : &quot;r&quot; (p)
+        );
+}
+
+static inline void prefetcht2(void *p)
+{
+        asm volatile(   &quot;prefetcht2 (%0)\n\t&quot;
+                : : &quot;r&quot; (p)
+        );
+}
+#endif
+
+// The horizontal Functions exist only in C cuz the MMX code is faster with vertical filters and transposing
+
+/**
+ * Check if the given 8x8 Block is mostly &quot;flat&quot;
+ */
+static inline int isHorizDC_C(uint8_t src[], int stride, PPContext *c)
+{
+        int numEq= 0;
+        int y;
+        const int dcOffset= ((c-&gt;nonBQP*c-&gt;ppMode.baseDcDiff)&gt;&gt;8) + 1;
+        const int dcThreshold= dcOffset*2 + 1;
+
+        for(y=0; y&lt;BLOCK_SIZE; y++)
+        {
+                if(((unsigned)(src[0] - src[1] + dcOffset)) &lt; dcThreshold) numEq++;
+                if(((unsigned)(src[1] - src[2] + dcOffset)) &lt; dcThreshold) numEq++;
+                if(((unsigned)(src[2] - src[3] + dcOffset)) &lt; dcThreshold) numEq++;
+                if(((unsigned)(src[3] - src[4] + dcOffset)) &lt; dcThreshold) numEq++;
+                if(((unsigned)(src[4] - src[5] + dcOffset)) &lt; dcThreshold) numEq++;
+                if(((unsigned)(src[5] - src[6] + dcOffset)) &lt; dcThreshold) numEq++;
+                if(((unsigned)(src[6] - src[7] + dcOffset)) &lt; dcThreshold) numEq++;
+                src+= stride;
+        }
+        return numEq &gt; c-&gt;ppMode.flatnessThreshold;
+}
+
+/**
+ * Check if the middle 8x8 Block in the given 8x16 block is flat
+ */
+static inline int isVertDC_C(uint8_t src[], int stride, PPContext *c){
+        int numEq= 0;
+        int y;
+        const int dcOffset= ((c-&gt;nonBQP*c-&gt;ppMode.baseDcDiff)&gt;&gt;8) + 1;
+        const int dcThreshold= dcOffset*2 + 1;
+
+        src+= stride*4; // src points to begin of the 8x8 Block
+        for(y=0; y&lt;BLOCK_SIZE-1; y++)
+        {
+                if(((unsigned)(src[0] - src[0+stride] + dcOffset)) &lt; dcThreshold) numEq++;
+                if(((unsigned)(src[1] - src[1+stride] + dcOffset)) &lt; dcThreshold) numEq++;
+                if(((unsigned)(src[2] - src[2+stride] + dcOffset)) &lt; dcThreshold) numEq++;
+                if(((unsigned)(src[3] - src[3+stride] + dcOffset)) &lt; dcThreshold) numEq++;
+                if(((unsigned)(src[4] - src[4+stride] + dcOffset)) &lt; dcThreshold) numEq++;
+                if(((unsigned)(src[5] - src[5+stride] + dcOffset)) &lt; dcThreshold) numEq++;
+                if(((unsigned)(src[6] - src[6+stride] + dcOffset)) &lt; dcThreshold) numEq++;
+                if(((unsigned)(src[7] - src[7+stride] + dcOffset)) &lt; dcThreshold) numEq++;
+                src+= stride;
+        }
+        return numEq &gt; c-&gt;ppMode.flatnessThreshold;
+}
+
+static inline int isHorizMinMaxOk_C(uint8_t src[], int stride, int QP)
+{
+        int i;
+#if 1
+        for(i=0; i&lt;2; i++){
+                if((unsigned)(src[0] - src[5] + 2*QP) &gt; 4*QP) return 0;
+                src += stride;
+                if((unsigned)(src[2] - src[7] + 2*QP) &gt; 4*QP) return 0;
+                src += stride;
+                if((unsigned)(src[4] - src[1] + 2*QP) &gt; 4*QP) return 0;
+                src += stride;
+                if((unsigned)(src[6] - src[3] + 2*QP) &gt; 4*QP) return 0;
+                src += stride;
+        }
+#else
+        for(i=0; i&lt;8; i++){
+                if((unsigned)(src[0] - src[7] + 2*QP) &gt; 4*QP) return 0;
+                src += stride;
+        }
+#endif
+        return 1;
+}
+
+static inline int isVertMinMaxOk_C(uint8_t src[], int stride, int QP)
+{
+#if 1
+#if 1
+        int x;
+        src+= stride*4;
+        for(x=0; x&lt;BLOCK_SIZE; x+=4)
+        {
+                if((unsigned)(src[  x + 0*stride] - src[  x + 5*stride] + 2*QP) &gt; 4*QP) return 0;
+                if((unsigned)(src[1+x + 2*stride] - src[1+x + 7*stride] + 2*QP) &gt; 4*QP) return 0;
+                if((unsigned)(src[2+x + 4*stride] - src[2+x + 1*stride] + 2*QP) &gt; 4*QP) return 0;
+                if((unsigned)(src[3+x + 6*stride] - src[3+x + 3*stride] + 2*QP) &gt; 4*QP) return 0;
+        }
+#else
+        int x;
+        src+= stride*3;
+        for(x=0; x&lt;BLOCK_SIZE; x++)
+        {
+                if((unsigned)(src[x + stride] - src[x + (stride&lt;&lt;3)] + 2*QP) &gt; 4*QP) return 0;
+        }
+#endif
+        return 1;
+#else
+        int x;
+        src+= stride*4;
+        for(x=0; x&lt;BLOCK_SIZE; x++)
+        {
+                int min=255;
+                int max=0;
+                int y;
+                for(y=0; y&lt;8; y++){
+                        int v= src[x + y*stride];
+                        if(v&gt;max) max=v;
+                        if(v&lt;min) min=v;
+                }
+                if(max-min &gt; 2*QP) return 0;
+        }
+        return 1;
+#endif
+}
+
+static inline int horizClassify_C(uint8_t src[], int stride, PPContext *c){
+        if( isHorizDC_C(src, stride, c) ){
+                if( isHorizMinMaxOk_C(src, stride, c-&gt;QP) )
+                        return 1;
+                else
+                        return 0;
+        }else{
+                return 2;
+        }
+}
+
+static inline int vertClassify_C(uint8_t src[], int stride, PPContext *c){
+        if( isVertDC_C(src, stride, c) ){
+                if( isVertMinMaxOk_C(src, stride, c-&gt;QP) )
+                        return 1;
+                else
+                        return 0;
+        }else{
+                return 2;
+        }
+}
+
+static inline void doHorizDefFilter_C(uint8_t dst[], int stride, PPContext *c)
+{
+        int y;
+        for(y=0; y&lt;BLOCK_SIZE; y++)
+        {
+                const int middleEnergy= 5*(dst[4] - dst[3]) + 2*(dst[2] - dst[5]);
+
+                if(FFABS(middleEnergy) &lt; 8*c-&gt;QP)
+                {
+                        const int q=(dst[3] - dst[4])/2;
+                        const int leftEnergy=  5*(dst[2] - dst[1]) + 2*(dst[0] - dst[3]);
+                        const int rightEnergy= 5*(dst[6] - dst[5]) + 2*(dst[4] - dst[7]);
+
+                        int d= FFABS(middleEnergy) - FFMIN( FFABS(leftEnergy), FFABS(rightEnergy) );
+                        d= FFMAX(d, 0);
+
+                        d= (5*d + 32) &gt;&gt; 6;
+                        d*= FFSIGN(-middleEnergy);
+
+                        if(q&gt;0)
+                        {
+                                d= d&lt;0 ? 0 : d;
+                                d= d&gt;q ? q : d;
+                        }
+                        else
+                        {
+                                d= d&gt;0 ? 0 : d;
+                                d= d&lt;q ? q : d;
+                        }
+
+                        dst[3]-= d;
+                        dst[4]+= d;
+                }
+                dst+= stride;
+        }
+}
+
+/**
+ * Do a horizontal low pass filter on the 10x8 block (dst points to middle 8x8 Block)
+ * using the 9-Tap Filter (1,1,2,2,4,2,2,1,1)/16 (C version)
+ */
+static inline void doHorizLowPass_C(uint8_t dst[], int stride, PPContext *c)
+{
+        int y;
+        for(y=0; y&lt;BLOCK_SIZE; y++)
+        {
+                const int first= FFABS(dst[-1] - dst[0]) &lt; c-&gt;QP ? dst[-1] : dst[0];
+                const int last= FFABS(dst[8] - dst[7]) &lt; c-&gt;QP ? dst[8] : dst[7];
+
+                int sums[10];
+                sums[0] = 4*first + dst[0] + dst[1] + dst[2] + 4;
+                sums[1] = sums[0] - first  + dst[3];
+                sums[2] = sums[1] - first  + dst[4];
+                sums[3] = sums[2] - first  + dst[5];
+                sums[4] = sums[3] - first  + dst[6];
+                sums[5] = sums[4] - dst[0] + dst[7];
+                sums[6] = sums[5] - dst[1] + last;
+                sums[7] = sums[6] - dst[2] + last;
+                sums[8] = sums[7] - dst[3] + last;
+                sums[9] = sums[8] - dst[4] + last;
+
+                dst[0]= (sums[0] + sums[2] + 2*dst[0])&gt;&gt;4;
+                dst[1]= (sums[1] + sums[3] + 2*dst[1])&gt;&gt;4;
+                dst[2]= (sums[2] + sums[4] + 2*dst[2])&gt;&gt;4;
+                dst[3]= (sums[3] + sums[5] + 2*dst[3])&gt;&gt;4;
+                dst[4]= (sums[4] + sums[6] + 2*dst[4])&gt;&gt;4;
+                dst[5]= (sums[5] + sums[7] + 2*dst[5])&gt;&gt;4;
+                dst[6]= (sums[6] + sums[8] + 2*dst[6])&gt;&gt;4;
+                dst[7]= (sums[7] + sums[9] + 2*dst[7])&gt;&gt;4;
+
+                dst+= stride;
+        }
+}
+
+/**
+ * Experimental Filter 1 (Horizontal)
+ * will not damage linear gradients
+ * Flat blocks should look like they where passed through the (1,1,2,2,4,2,2,1,1) 9-Tap filter
+ * can only smooth blocks at the expected locations (it cant smooth them if they did move)
+ * MMX2 version does correct clipping C version doesnt
+ * not identical with the vertical one
+ */
+static inline void horizX1Filter(uint8_t *src, int stride, int QP)
+{
+        int y;
+        static uint64_t *lut= NULL;
+        if(lut==NULL)
+        {
+                int i;
+                lut = av_malloc(256*8);
+                for(i=0; i&lt;256; i++)
+                {
+                        int v= i &lt; 128 ? 2*i : 2*(i-256);
+/*
+//Simulate 112242211 9-Tap filter
+                        uint64_t a= (v/16) &amp; 0xFF;
+                        uint64_t b= (v/8) &amp; 0xFF;
+                        uint64_t c= (v/4) &amp; 0xFF;
+                        uint64_t d= (3*v/8) &amp; 0xFF;
+*/
+//Simulate piecewise linear interpolation
+                        uint64_t a= (v/16) &amp; 0xFF;
+                        uint64_t b= (v*3/16) &amp; 0xFF;
+                        uint64_t c= (v*5/16) &amp; 0xFF;
+                        uint64_t d= (7*v/16) &amp; 0xFF;
+                        uint64_t A= (0x100 - a)&amp;0xFF;
+                        uint64_t B= (0x100 - b)&amp;0xFF;
+                        uint64_t C= (0x100 - c)&amp;0xFF;
+                        uint64_t D= (0x100 - c)&amp;0xFF;
+
+                        lut[i]   = (a&lt;&lt;56) | (b&lt;&lt;48) | (c&lt;&lt;40) | (d&lt;&lt;32) |
+                                (D&lt;&lt;24) | (C&lt;&lt;16) | (B&lt;&lt;8) | (A);
+                        //lut[i] = (v&lt;&lt;32) | (v&lt;&lt;24);
+                }
+        }
+
+        for(y=0; y&lt;BLOCK_SIZE; y++)
+        {
+                int a= src[1] - src[2];
+                int b= src[3] - src[4];
+                int c= src[5] - src[6];
+
+                int d= FFMAX(FFABS(b) - (FFABS(a) + FFABS(c))/2, 0);
+
+                if(d &lt; QP)
+                {
+                        int v = d * FFSIGN(-b);
+
+                        src[1] +=v/8;
+                        src[2] +=v/4;
+                        src[3] +=3*v/8;
+                        src[4] -=3*v/8;
+                        src[5] -=v/4;
+                        src[6] -=v/8;
+
+                }
+                src+=stride;
+        }
+}
+
+/**
+ * accurate deblock filter
+ */
+static av_always_inline void do_a_deblock_C(uint8_t *src, int step, int stride, PPContext *c){
+        int y;
+        const int QP= c-&gt;QP;
+        const int dcOffset= ((c-&gt;nonBQP*c-&gt;ppMode.baseDcDiff)&gt;&gt;8) + 1;
+        const int dcThreshold= dcOffset*2 + 1;
+//START_TIMER
+        src+= step*4; // src points to begin of the 8x8 Block
+        for(y=0; y&lt;8; y++){
+                int numEq= 0;
+
+                if(((unsigned)(src[-1*step] - src[0*step] + dcOffset)) &lt; dcThreshold) numEq++;
+                if(((unsigned)(src[ 0*step] - src[1*step] + dcOffset)) &lt; dcThreshold) numEq++;
+                if(((unsigned)(src[ 1*step] - src[2*step] + dcOffset)) &lt; dcThreshold) numEq++;
+                if(((unsigned)(src[ 2*step] - src[3*step] + dcOffset)) &lt; dcThreshold) numEq++;
+                if(((unsigned)(src[ 3*step] - src[4*step] + dcOffset)) &lt; dcThreshold) numEq++;
+                if(((unsigned)(src[ 4*step] - src[5*step] + dcOffset)) &lt; dcThreshold) numEq++;
+                if(((unsigned)(src[ 5*step] - src[6*step] + dcOffset)) &lt; dcThreshold) numEq++;
+                if(((unsigned)(src[ 6*step] - src[7*step] + dcOffset)) &lt; dcThreshold) numEq++;
+                if(((unsigned)(src[ 7*step] - src[8*step] + dcOffset)) &lt; dcThreshold) numEq++;
+                if(numEq &gt; c-&gt;ppMode.flatnessThreshold){
+                        int min, max, x;
+
+                        if(src[0] &gt; src[step]){
+                            max= src[0];
+                            min= src[step];
+                        }else{
+                            max= src[step];
+                            min= src[0];
+                        }
+                        for(x=2; x&lt;8; x+=2){
+                                if(src[x*step] &gt; src[(x+1)*step]){
+                                        if(src[x    *step] &gt; max) max= src[ x   *step];
+                                        if(src[(x+1)*step] &lt; min) min= src[(x+1)*step];
+                                }else{
+                                        if(src[(x+1)*step] &gt; max) max= src[(x+1)*step];
+                                        if(src[ x   *step] &lt; min) min= src[ x   *step];
+                                }
+                        }
+                        if(max-min &lt; 2*QP){
+                                const int first= FFABS(src[-1*step] - src[0]) &lt; QP ? src[-1*step] : src[0];
+                                const int last= FFABS(src[8*step] - src[7*step]) &lt; QP ? src[8*step] : src[7*step];
+
+                                int sums[10];
+                                sums[0] = 4*first + src[0*step] + src[1*step] + src[2*step] + 4;
+                                sums[1] = sums[0] - first       + src[3*step];
+                                sums[2] = sums[1] - first       + src[4*step];
+                                sums[3] = sums[2] - first       + src[5*step];
+                                sums[4] = sums[3] - first       + src[6*step];
+                                sums[5] = sums[4] - src[0*step] + src[7*step];
+                                sums[6] = sums[5] - src[1*step] + last;
+                                sums[7] = sums[6] - src[2*step] + last;
+                                sums[8] = sums[7] - src[3*step] + last;
+                                sums[9] = sums[8] - src[4*step] + last;
+
+                                src[0*step]= (sums[0] + sums[2] + 2*src[0*step])&gt;&gt;4;
+                                src[1*step]= (sums[1] + sums[3] + 2*src[1*step])&gt;&gt;4;
+                                src[2*step]= (sums[2] + sums[4] + 2*src[2*step])&gt;&gt;4;
+                                src[3*step]= (sums[3] + sums[5] + 2*src[3*step])&gt;&gt;4;
+                                src[4*step]= (sums[4] + sums[6] + 2*src[4*step])&gt;&gt;4;
+                                src[5*step]= (sums[5] + sums[7] + 2*src[5*step])&gt;&gt;4;
+                                src[6*step]= (sums[6] + sums[8] + 2*src[6*step])&gt;&gt;4;
+                                src[7*step]= (sums[7] + sums[9] + 2*src[7*step])&gt;&gt;4;
+                        }
+                }else{
+                        const int middleEnergy= 5*(src[4*step] - src[3*step]) + 2*(src[2*step] - src[5*step]);
+
+                        if(FFABS(middleEnergy) &lt; 8*QP)
+                        {
+                                const int q=(src[3*step] - src[4*step])/2;
+                                const int leftEnergy=  5*(src[2*step] - src[1*step]) + 2*(src[0*step] - src[3*step]);
+                                const int rightEnergy= 5*(src[6*step] - src[5*step]) + 2*(src[4*step] - src[7*step]);
+
+                                int d= FFABS(middleEnergy) - FFMIN( FFABS(leftEnergy), FFABS(rightEnergy) );
+                                d= FFMAX(d, 0);
+
+                                d= (5*d + 32) &gt;&gt; 6;
+                                d*= FFSIGN(-middleEnergy);
+
+                                if(q&gt;0)
+                                {
+                                        d= d&lt;0 ? 0 : d;
+                                        d= d&gt;q ? q : d;
+                                }
+                                else
+                                {
+                                        d= d&gt;0 ? 0 : d;
+                                        d= d&lt;q ? q : d;
+                                }
+
+                                src[3*step]-= d;
+                                src[4*step]+= d;
+                        }
+                }
+
+                src += stride;
+        }
+/*if(step==16){
+    STOP_TIMER(&quot;step16&quot;)
+}else{
+    STOP_TIMER(&quot;stepX&quot;)
+}*/
+}
+
+//Note: we have C, MMX, MMX2, 3DNOW version there is no 3DNOW+MMX2 one
+//Plain C versions
+#if !defined (HAVE_MMX) || defined (RUNTIME_CPUDETECT)
+#define COMPILE_C
+#endif
+
+#ifdef ARCH_POWERPC
+#ifdef HAVE_ALTIVEC
+#define COMPILE_ALTIVEC
+#endif //HAVE_ALTIVEC
+#endif //ARCH_POWERPC
+
+#if defined(ARCH_X86)
+
+#if (defined (HAVE_MMX) &amp;&amp; !defined (HAVE_3DNOW) &amp;&amp; !defined (HAVE_MMX2)) || defined (RUNTIME_CPUDETECT)
+#define COMPILE_MMX
+#endif
+
+#if defined (HAVE_MMX2) || defined (RUNTIME_CPUDETECT)
+#define COMPILE_MMX2
+#endif
+
+#if (defined (HAVE_3DNOW) &amp;&amp; !defined (HAVE_MMX2)) || defined (RUNTIME_CPUDETECT)
+#define COMPILE_3DNOW
+#endif
+#endif /* defined(ARCH_X86) */
+
+#undef HAVE_MMX
+#undef HAVE_MMX2
+#undef HAVE_3DNOW
+#undef HAVE_ALTIVEC
+
+#ifdef COMPILE_C
+#undef HAVE_MMX
+#undef HAVE_MMX2
+#undef HAVE_3DNOW
+#define RENAME(a) a ## _C
+#include &quot;postprocess_template.c&quot;
+#endif
+
+#ifdef ARCH_POWERPC
+#ifdef COMPILE_ALTIVEC
+#undef RENAME
+#define HAVE_ALTIVEC
+#define RENAME(a) a ## _altivec
+#include &quot;postprocess_altivec_template.c&quot;
+#include &quot;postprocess_template.c&quot;
+#endif
+#endif //ARCH_POWERPC
+
+//MMX versions
+#ifdef COMPILE_MMX
+#undef RENAME
+#define HAVE_MMX
+#undef HAVE_MMX2
+#undef HAVE_3DNOW
+#define RENAME(a) a ## _MMX
+#include &quot;postprocess_template.c&quot;
+#endif
+
+//MMX2 versions
+#ifdef COMPILE_MMX2
+#undef RENAME
+#define HAVE_MMX
+#define HAVE_MMX2
+#undef HAVE_3DNOW
+#define RENAME(a) a ## _MMX2
+#include &quot;postprocess_template.c&quot;
+#endif
+
+//3DNOW versions
+#ifdef COMPILE_3DNOW
+#undef RENAME
+#define HAVE_MMX
+#undef HAVE_MMX2
+#define HAVE_3DNOW
+#define RENAME(a) a ## _3DNow
+#include &quot;postprocess_template.c&quot;
+#endif
+
+// minor note: the HAVE_xyz is messed up after that line so dont use it
+
+static inline void postProcess(uint8_t src[], int srcStride, uint8_t dst[], int dstStride, int width, int height,
+        QP_STORE_T QPs[], int QPStride, int isColor, pp_mode_t *vm, pp_context_t *vc)
+{
+        PPContext *c= (PPContext *)vc;
+        PPMode *ppMode= (PPMode *)vm;
+        c-&gt;ppMode= *ppMode; //FIXME
+
+        // useing ifs here as they are faster than function pointers allthough the
+        // difference wouldnt be messureable here but its much better because
+        // someone might exchange the cpu whithout restarting mplayer ;)
+#ifdef RUNTIME_CPUDETECT
+#if defined(ARCH_X86)
+        // ordered per speed fasterst first
+        if(c-&gt;cpuCaps &amp; PP_CPU_CAPS_MMX2)
+                postProcess_MMX2(src, srcStride, dst, dstStride, width, height, QPs, QPStride, isColor, c);
+        else if(c-&gt;cpuCaps &amp; PP_CPU_CAPS_3DNOW)
+                postProcess_3DNow(src, srcStride, dst, dstStride, width, height, QPs, QPStride, isColor, c);
+        else if(c-&gt;cpuCaps &amp; PP_CPU_CAPS_MMX)
+                postProcess_MMX(src, srcStride, dst, dstStride, width, height, QPs, QPStride, isColor, c);
+        else
+                postProcess_C(src, srcStride, dst, dstStride, width, height, QPs, QPStride, isColor, c);
+#else
+#ifdef ARCH_POWERPC
+#ifdef HAVE_ALTIVEC
+        if(c-&gt;cpuCaps &amp; PP_CPU_CAPS_ALTIVEC)
+                postProcess_altivec(src, srcStride, dst, dstStride, width, height, QPs, QPStride, isColor, c);
+        else
+#endif
+#endif
+                postProcess_C(src, srcStride, dst, dstStride, width, height, QPs, QPStride, isColor, c);
+#endif
+#else //RUNTIME_CPUDETECT
+#ifdef HAVE_MMX2
+                postProcess_MMX2(src, srcStride, dst, dstStride, width, height, QPs, QPStride, isColor, c);
+#elif defined (HAVE_3DNOW)
+                postProcess_3DNow(src, srcStride, dst, dstStride, width, height, QPs, QPStride, isColor, c);
+#elif defined (HAVE_MMX)
+                postProcess_MMX(src, srcStride, dst, dstStride, width, height, QPs, QPStride, isColor, c);
+#elif defined (HAVE_ALTIVEC)
+                postProcess_altivec(src, srcStride, dst, dstStride, width, height, QPs, QPStride, isColor, c);
+#else
+                postProcess_C(src, srcStride, dst, dstStride, width, height, QPs, QPStride, isColor, c);
+#endif
+#endif //!RUNTIME_CPUDETECT
+}
+
+//static void postProcess(uint8_t src[], int srcStride, uint8_t dst[], int dstStride, int width, int height,
+//        QP_STORE_T QPs[], int QPStride, int isColor, struct PPMode *ppMode);
+
+/* -pp Command line Help
+*/
+char *pp_help=
+&quot;Available postprocessing filters:\n&quot;
+&quot;Filters                        Options\n&quot;
+&quot;short  long name       short   long option     Description\n&quot;
+&quot;*      *               a       autoq           CPU power dependent enabler\n&quot;
+&quot;                       c       chrom           chrominance filtering enabled\n&quot;
+&quot;                       y       nochrom         chrominance filtering disabled\n&quot;
+&quot;                       n       noluma          luma filtering disabled\n&quot;
+&quot;hb     hdeblock        (2 threshold)           horizontal deblocking filter\n&quot;
+&quot;       1. difference factor: default=32, higher -&gt; more deblocking\n&quot;
+&quot;       2. flatness threshold: default=39, lower -&gt; more deblocking\n&quot;
+&quot;                       the h &amp; v deblocking filters share these\n&quot;
+&quot;                       so you can't set different thresholds for h / v\n&quot;
+&quot;vb     vdeblock        (2 threshold)           vertical deblocking filter\n&quot;
+&quot;ha     hadeblock       (2 threshold)           horizontal deblocking filter\n&quot;
+&quot;va     vadeblock       (2 threshold)           vertical deblocking filter\n&quot;
+&quot;h1     x1hdeblock                              experimental h deblock filter 1\n&quot;
+&quot;v1     x1vdeblock                              experimental v deblock filter 1\n&quot;
+&quot;dr     dering                                  deringing filter\n&quot;
+&quot;al     autolevels                              automatic brightness / contrast\n&quot;
+&quot;                       f        fullyrange     stretch luminance to (0..255)\n&quot;
+&quot;lb     linblenddeint                           linear blend deinterlacer\n&quot;
+&quot;li     linipoldeint                            linear interpolating deinterlace\n&quot;
+&quot;ci     cubicipoldeint                          cubic interpolating deinterlacer\n&quot;
+&quot;md     mediandeint                             median deinterlacer\n&quot;
+&quot;fd     ffmpegdeint                             ffmpeg deinterlacer\n&quot;
+&quot;l5     lowpass5                                FIR lowpass deinterlacer\n&quot;
+&quot;de     default                                 hb:a,vb:a,dr:a\n&quot;
+&quot;fa     fast                                    h1:a,v1:a,dr:a\n&quot;
+&quot;ac                                             ha:a:128:7,va:a,dr:a\n&quot;
+&quot;tn     tmpnoise        (3 threshold)           temporal noise reducer\n&quot;
+&quot;                     1. &lt;= 2. &lt;= 3.            larger -&gt; stronger filtering\n&quot;
+&quot;fq     forceQuant      &lt;quantizer&gt;             force quantizer\n&quot;
+&quot;Usage:\n&quot;
+&quot;&lt;filterName&gt;[:&lt;option&gt;[:&lt;option&gt;...]][[,|/][-]&lt;filterName&gt;[:&lt;option&gt;...]]...\n&quot;
+&quot;long form example:\n&quot;
+&quot;vdeblock:autoq/hdeblock:autoq/linblenddeint    default,-vdeblock\n&quot;
+&quot;short form example:\n&quot;
+&quot;vb:a/hb:a/lb                                   de,-vb\n&quot;
+&quot;more examples:\n&quot;
+&quot;tn:64:128:256\n&quot;
+&quot;\n&quot;
+;
+
+pp_mode_t *pp_get_mode_by_name_and_quality(char *name, int quality)
+{
+        char temp[GET_MODE_BUFFER_SIZE];
+        char *p= temp;
+        const char *filterDelimiters= &quot;,/&quot;;
+        const char *optionDelimiters= &quot;:&quot;;
+        struct PPMode *ppMode;
+        char *filterToken;
+
+        ppMode= av_malloc(sizeof(PPMode));
+
+        ppMode-&gt;lumMode= 0;
+        ppMode-&gt;chromMode= 0;
+        ppMode-&gt;maxTmpNoise[0]= 700;
+        ppMode-&gt;maxTmpNoise[1]= 1500;
+        ppMode-&gt;maxTmpNoise[2]= 3000;
+        ppMode-&gt;maxAllowedY= 234;
+        ppMode-&gt;minAllowedY= 16;
+        ppMode-&gt;baseDcDiff= 256/8;
+        ppMode-&gt;flatnessThreshold= 56-16-1;
+        ppMode-&gt;maxClippedThreshold= 0.01;
+        ppMode-&gt;error=0;
+
+        strncpy(temp, name, GET_MODE_BUFFER_SIZE);
+
+        av_log(NULL, AV_LOG_DEBUG, &quot;pp: %s\n&quot;, name);
+
+        for(;;){
+                char *filterName;
+                int q= 1000000; //PP_QUALITY_MAX;
+                int chrom=-1;
+                int luma=-1;
+                char *option;
+                char *options[OPTIONS_ARRAY_SIZE];
+                int i;
+                int filterNameOk=0;
+                int numOfUnknownOptions=0;
+                int enable=1; //does the user want us to enabled or disabled the filter
+
+                filterToken= strtok(p, filterDelimiters);
+                if(filterToken == NULL) break;
+                p+= strlen(filterToken) + 1; // p points to next filterToken
+                filterName= strtok(filterToken, optionDelimiters);
+                av_log(NULL, AV_LOG_DEBUG, &quot;pp: %s::%s\n&quot;, filterToken, filterName);
+
+                if(*filterName == '-')
+                {
+                        enable=0;
+                        filterName++;
+                }
+
+                for(;;){ //for all options
+                        option= strtok(NULL, optionDelimiters);
+                        if(option == NULL) break;
+
+                        av_log(NULL, AV_LOG_DEBUG, &quot;pp: option: %s\n&quot;, option);
+                        if(!strcmp(&quot;autoq&quot;, option) || !strcmp(&quot;a&quot;, option)) q= quality;
+                        else if(!strcmp(&quot;nochrom&quot;, option) || !strcmp(&quot;y&quot;, option)) chrom=0;
+                        else if(!strcmp(&quot;chrom&quot;, option) || !strcmp(&quot;c&quot;, option)) chrom=1;
+                        else if(!strcmp(&quot;noluma&quot;, option) || !strcmp(&quot;n&quot;, option)) luma=0;
+                        else
+                        {
+                                options[numOfUnknownOptions] = option;
+                                numOfUnknownOptions++;
+                        }
+                        if(numOfUnknownOptions &gt;= OPTIONS_ARRAY_SIZE-1) break;
+                }
+                options[numOfUnknownOptions] = NULL;
+
+                /* replace stuff from the replace Table */
+                for(i=0; replaceTable[2*i]!=NULL; i++)
+                {
+                        if(!strcmp(replaceTable[2*i], filterName))
+                        {
+                                int newlen= strlen(replaceTable[2*i + 1]);
+                                int plen;
+                                int spaceLeft;
+
+                                if(p==NULL) p= temp, *p=0;      //last filter
+                                else p--, *p=',';               //not last filter
+
+                                plen= strlen(p);
+                                spaceLeft= p - temp + plen;
+                                if(spaceLeft + newlen  &gt;= GET_MODE_BUFFER_SIZE)
+                                {
+                                        ppMode-&gt;error++;
+                                        break;
+                                }
+                                memmove(p + newlen, p, plen+1);
+                                memcpy(p, replaceTable[2*i + 1], newlen);
+                                filterNameOk=1;
+                        }
+                }
+
+                for(i=0; filters[i].shortName!=NULL; i++)
+                {
+                        if(   !strcmp(filters[i].longName, filterName)
+                           || !strcmp(filters[i].shortName, filterName))
+                        {
+                                ppMode-&gt;lumMode &amp;= ~filters[i].mask;
+                                ppMode-&gt;chromMode &amp;= ~filters[i].mask;
+
+                                filterNameOk=1;
+                                if(!enable) break; // user wants to disable it
+
+                                if(q &gt;= filters[i].minLumQuality &amp;&amp; luma)
+                                        ppMode-&gt;lumMode|= filters[i].mask;
+                                if(chrom==1 || (chrom==-1 &amp;&amp; filters[i].chromDefault))
+                                        if(q &gt;= filters[i].minChromQuality)
+                                                ppMode-&gt;chromMode|= filters[i].mask;
+
+                                if(filters[i].mask == LEVEL_FIX)
+                                {
+                                        int o;
+                                        ppMode-&gt;minAllowedY= 16;
+                                        ppMode-&gt;maxAllowedY= 234;
+                                        for(o=0; options[o]!=NULL; o++)
+                                        {
+                                                if(  !strcmp(options[o],&quot;fullyrange&quot;)
+                                                   ||!strcmp(options[o],&quot;f&quot;))
+                                                {
+                                                        ppMode-&gt;minAllowedY= 0;
+                                                        ppMode-&gt;maxAllowedY= 255;
+                                                        numOfUnknownOptions--;
+                                                }
+                                        }
+                                }
+                                else if(filters[i].mask == TEMP_NOISE_FILTER)
+                                {
+                                        int o;
+                                        int numOfNoises=0;
+
+                                        for(o=0; options[o]!=NULL; o++)
+                                        {
+                                                char *tail;
+                                                ppMode-&gt;maxTmpNoise[numOfNoises]=
+                                                        strtol(options[o], &amp;tail, 0);
+                                                if(tail!=options[o])
+                                                {
+                                                        numOfNoises++;
+                                                        numOfUnknownOptions--;
+                                                        if(numOfNoises &gt;= 3) break;
+                                                }
+                                        }
+                                }
+                                else if(filters[i].mask == V_DEBLOCK   || filters[i].mask == H_DEBLOCK
+                                     || filters[i].mask == V_A_DEBLOCK || filters[i].mask == H_A_DEBLOCK)
+                                {
+                                        int o;
+
+                                        for(o=0; options[o]!=NULL &amp;&amp; o&lt;2; o++)
+                                        {
+                                                char *tail;
+                                                int val= strtol(options[o], &amp;tail, 0);
+                                                if(tail==options[o]) break;
+
+                                                numOfUnknownOptions--;
+                                                if(o==0) ppMode-&gt;baseDcDiff= val;
+                                                else ppMode-&gt;flatnessThreshold= val;
+                                        }
+                                }
+                                else if(filters[i].mask == FORCE_QUANT)
+                                {
+                                        int o;
+                                        ppMode-&gt;forcedQuant= 15;
+
+                                        for(o=0; options[o]!=NULL &amp;&amp; o&lt;1; o++)
+                                        {
+                                                char *tail;
+                                                int val= strtol(options[o], &amp;tail, 0);
+                                                if(tail==options[o]) break;
+
+                                                numOfUnknownOptions--;
+                                                ppMode-&gt;forcedQuant= val;
+                                        }
+                                }
+                        }
+                }
+                if(!filterNameOk) ppMode-&gt;error++;
+                ppMode-&gt;error += numOfUnknownOptions;
+        }
+
+        av_log(NULL, AV_LOG_DEBUG, &quot;pp: lumMode=%X, chromMode=%X\n&quot;, ppMode-&gt;lumMode, ppMode-&gt;chromMode);
+        if(ppMode-&gt;error)
+        {
+                av_log(NULL, AV_LOG_ERROR, &quot;%d errors in postprocess string \&quot;%s\&quot;\n&quot;, ppMode-&gt;error, name);
+                av_free(ppMode);
+                return NULL;
+        }
+        return ppMode;
+}
+
+void pp_free_mode(pp_mode_t *mode){
+    av_free(mode);
+}
+
+static void reallocAlign(void **p, int alignment, int size){
+        av_free(*p);
+        *p= av_mallocz(size);
+}
+
+static void reallocBuffers(PPContext *c, int width, int height, int stride, int qpStride){
+        int mbWidth = (width+15)&gt;&gt;4;
+        int mbHeight= (height+15)&gt;&gt;4;
+        int i;
+
+        c-&gt;stride= stride;
+        c-&gt;qpStride= qpStride;
+
+        reallocAlign((void **)&amp;c-&gt;tempDst, 8, stride*24);
+        reallocAlign((void **)&amp;c-&gt;tempSrc, 8, stride*24);
+        reallocAlign((void **)&amp;c-&gt;tempBlocks, 8, 2*16*8);
+        reallocAlign((void **)&amp;c-&gt;yHistogram, 8, 256*sizeof(uint64_t));
+        for(i=0; i&lt;256; i++)
+                c-&gt;yHistogram[i]= width*height/64*15/256;
+
+        for(i=0; i&lt;3; i++)
+        {
+                //Note:the +17*1024 is just there so i dont have to worry about r/w over te end
+                reallocAlign((void **)&amp;c-&gt;tempBlured[i], 8, stride*mbHeight*16 + 17*1024);
+                reallocAlign((void **)&amp;c-&gt;tempBluredPast[i], 8, 256*((height+7)&amp;(~7))/2 + 17*1024);//FIXME size
+        }
+
+        reallocAlign((void **)&amp;c-&gt;deintTemp, 8, 2*width+32);
+        reallocAlign((void **)&amp;c-&gt;nonBQPTable, 8, qpStride*mbHeight*sizeof(QP_STORE_T));
+        reallocAlign((void **)&amp;c-&gt;stdQPTable, 8, qpStride*mbHeight*sizeof(QP_STORE_T));
+        reallocAlign((void **)&amp;c-&gt;forcedQPTable, 8, mbWidth*sizeof(QP_STORE_T));
+}
+
+static void global_init(void){
+        int i;
+        memset(clip_table, 0, 256);
+        for(i=256; i&lt;512; i++)
+                clip_table[i]= i;
+        memset(clip_table+512, 0, 256);
+}
+
+static const char * context_to_name(void * ptr) {
+    return &quot;postproc&quot;;
+}
+
+static AVClass av_codec_context_class = { &quot;Postproc&quot;, context_to_name, NULL };
+
+pp_context_t *pp_get_context(int width, int height, int cpuCaps){
+        PPContext *c= av_malloc(sizeof(PPContext));
+        int stride= (width+15)&amp;(~15);    //assumed / will realloc if needed
+        int qpStride= (width+15)/16 + 2; //assumed / will realloc if needed
+
+        global_init();
+
+        memset(c, 0, sizeof(PPContext));
+        c-&gt;av_class = &amp;av_codec_context_class;
+        c-&gt;cpuCaps= cpuCaps;
+        if(cpuCaps&amp;PP_FORMAT){
+                c-&gt;hChromaSubSample= cpuCaps&amp;0x3;
+                c-&gt;vChromaSubSample= (cpuCaps&gt;&gt;4)&amp;0x3;
+        }else{
+                c-&gt;hChromaSubSample= 1;
+                c-&gt;vChromaSubSample= 1;
+        }
+
+        reallocBuffers(c, width, height, stride, qpStride);
+
+        c-&gt;frameNum=-1;
+
+        return c;
+}
+
+void pp_free_context(void *vc){
+        PPContext *c = (PPContext*)vc;
+        int i;
+
+        for(i=0; i&lt;3; i++) av_free(c-&gt;tempBlured[i]);
+        for(i=0; i&lt;3; i++) av_free(c-&gt;tempBluredPast[i]);
+
+        av_free(c-&gt;tempBlocks);
+        av_free(c-&gt;yHistogram);
+        av_free(c-&gt;tempDst);
+        av_free(c-&gt;tempSrc);
+        av_free(c-&gt;deintTemp);
+        av_free(c-&gt;stdQPTable);
+        av_free(c-&gt;nonBQPTable);
+        av_free(c-&gt;forcedQPTable);
+
+        memset(c, 0, sizeof(PPContext));
+
+        av_free(c);
+}
+
+void  pp_postprocess(uint8_t * src[3], int srcStride[3],
+                 uint8_t * dst[3], int dstStride[3],
+                 int width, int height,
+                 QP_STORE_T *QP_store,  int QPStride,
+                 pp_mode_t *vm,  void *vc, int pict_type)
+{
+        int mbWidth = (width+15)&gt;&gt;4;
+        int mbHeight= (height+15)&gt;&gt;4;
+        PPMode *mode = (PPMode*)vm;
+        PPContext *c = (PPContext*)vc;
+        int minStride= FFMAX(FFABS(srcStride[0]), FFABS(dstStride[0]));
+        int absQPStride = FFABS(QPStride);
+
+        // c-&gt;stride and c-&gt;QPStride are always positive
+        if(c-&gt;stride &lt; minStride || c-&gt;qpStride &lt; absQPStride)
+                reallocBuffers(c, width, height,
+                                FFMAX(minStride, c-&gt;stride),
+                                FFMAX(c-&gt;qpStride, absQPStride));
+
+        if(QP_store==NULL || (mode-&gt;lumMode &amp; FORCE_QUANT))
+        {
+                int i;
+                QP_store= c-&gt;forcedQPTable;
+                absQPStride = QPStride = 0;
+                if(mode-&gt;lumMode &amp; FORCE_QUANT)
+                        for(i=0; i&lt;mbWidth; i++) QP_store[i]= mode-&gt;forcedQuant;
+                else
+                        for(i=0; i&lt;mbWidth; i++) QP_store[i]= 1;
+        }
+
+        if(pict_type &amp; PP_PICT_TYPE_QP2){
+                int i;
+                const int count= mbHeight * absQPStride;
+                for(i=0; i&lt;(count&gt;&gt;2); i++){
+                        ((uint32_t*)c-&gt;stdQPTable)[i] = (((uint32_t*)QP_store)[i]&gt;&gt;1) &amp; 0x7F7F7F7F;
+                }
+                for(i&lt;&lt;=2; i&lt;count; i++){
+                        c-&gt;stdQPTable[i] = QP_store[i]&gt;&gt;1;
+                }
+                QP_store= c-&gt;stdQPTable;
+                QPStride= absQPStride;
+        }
+
+if(0){
+int x,y;
+for(y=0; y&lt;mbHeight; y++){
+        for(x=0; x&lt;mbWidth; x++){
+                av_log(c, AV_LOG_INFO, &quot;%2d &quot;, QP_store[x + y*QPStride]);
+        }
+        av_log(c, AV_LOG_INFO, &quot;\n&quot;);
+}
+        av_log(c, AV_LOG_INFO, &quot;\n&quot;);
+}
+
+        if((pict_type&amp;7)!=3)
+        {
+                if (QPStride &gt;= 0) {
+                        int i;
+                        const int count= mbHeight * QPStride;
+                        for(i=0; i&lt;(count&gt;&gt;2); i++){
+                                ((uint32_t*)c-&gt;nonBQPTable)[i] = ((uint32_t*)QP_store)[i] &amp; 0x3F3F3F3F;
+                        }
+                        for(i&lt;&lt;=2; i&lt;count; i++){
+                                c-&gt;nonBQPTable[i] = QP_store[i] &amp; 0x3F;
+                        }
+                } else {
+                        int i,j;
+                        for(i=0; i&lt;mbHeight; i++) {
+                                    for(j=0; j&lt;absQPStride; j++) {
+                                        c-&gt;nonBQPTable[i*absQPStride+j] = QP_store[i*QPStride+j] &amp; 0x3F;
+                                }
+                        }
+                }
+        }
+
+        av_log(c, AV_LOG_DEBUG, &quot;using npp filters 0x%X/0x%X\n&quot;,
+               mode-&gt;lumMode, mode-&gt;chromMode);
+
+        postProcess(src[0], srcStride[0], dst[0], dstStride[0],
+                width, height, QP_store, QPStride, 0, mode, c);
+
+        width  = (width )&gt;&gt;c-&gt;hChromaSubSample;
+        height = (height)&gt;&gt;c-&gt;vChromaSubSample;
+
+        if(mode-&gt;chromMode)
+        {
+                postProcess(src[1], srcStride[1], dst[1], dstStride[1],
+                        width, height, QP_store, QPStride, 1, mode, c);
+                postProcess(src[2], srcStride[2], dst[2], dstStride[2],
+                        width, height, QP_store, QPStride, 2, mode, c);
+        }
+        else if(srcStride[1] == dstStride[1] &amp;&amp; srcStride[2] == dstStride[2])
+        {
+                linecpy(dst[1], src[1], height, srcStride[1]);
+                linecpy(dst[2], src[2], height, srcStride[2]);
+        }
+        else
+        {
+                int y;
+                for(y=0; y&lt;height; y++)
+                {
+                        memcpy(&amp;(dst[1][y*dstStride[1]]), &amp;(src[1][y*srcStride[1]]), width);
+                        memcpy(&amp;(dst[2][y*dstStride[2]]), &amp;(src[2][y*srcStride[2]]), width);
+                }
+        }
+}
+

Added: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_libpostproc/postprocess.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_libpostproc/postprocess.h	2007-05-27 18:44:33 UTC (rev 3157)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_libpostproc/postprocess.h	2007-05-28 13:03:46 UTC (rev 3158)
@@ -0,0 +1,84 @@
+/*
+ * Copyright (C) 2001-2003 Michael Niedermayer (<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">michaelni at gmx.at</A>)
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef NEWPOSTPROCESS_H
+#define NEWPOSTPROCESS_H
+
+/**
+ * @file postprocess.h
+ * @brief
+ *     external api for the pp stuff
+ */
+
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+#define LIBPOSTPROC_VERSION_INT ((51&lt;&lt;16)+(1&lt;&lt;8)+0)
+#define LIBPOSTPROC_VERSION     51.1.0
+#define LIBPOSTPROC_BUILD       LIBPOSTPROC_VERSION_INT
+
+#define LIBPOSTPROC_IDENT       &quot;postproc&quot; AV_STRINGIFY(LIBPOSTPROC_VERSION)
+
+#define PP_QUALITY_MAX 6
+
+#define QP_STORE_T int8_t
+
+typedef void pp_context_t;
+typedef void pp_mode_t;
+
+extern char *pp_help; ///&lt; a simple help text
+
+void  pp_postprocess(uint8_t * src[3], int srcStride[3],
+                 uint8_t * dst[3], int dstStride[3],
+                 int horizontalSize, int verticalSize,
+                 QP_STORE_T *QP_store,  int QP_stride,
+                 pp_mode_t *mode, pp_context_t *ppContext, int pict_type);
+
+
+/**
+ * returns a pp_mode_t or NULL if an error occured
+ * name is the string after &quot;-pp&quot; on the command line
+ * quality is a number from 0 to PP_QUALITY_MAX
+ */
+pp_mode_t *pp_get_mode_by_name_and_quality(char *name, int quality);
+void pp_free_mode(pp_mode_t *mode);
+
+pp_context_t *pp_get_context(int width, int height, int flags);
+void pp_free_context(pp_context_t *ppContext);
+
+#define PP_CPU_CAPS_MMX   0x80000000
+#define PP_CPU_CAPS_MMX2  0x20000000
+#define PP_CPU_CAPS_3DNOW 0x40000000
+#define PP_CPU_CAPS_ALTIVEC 0x10000000
+
+#define PP_FORMAT         0x00000008
+#define PP_FORMAT_420    (0x00000011|PP_FORMAT)
+#define PP_FORMAT_422    (0x00000001|PP_FORMAT)
+#define PP_FORMAT_411    (0x00000002|PP_FORMAT)
+#define PP_FORMAT_444    (0x00000000|PP_FORMAT)
+
+#define PP_PICT_TYPE_QP2  0x00000010 ///&lt; MPEG2 style QScale
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif

Added: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_libpostproc/postprocess_altivec_template.c
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_libpostproc/postprocess_altivec_template.c	2007-05-27 18:44:33 UTC (rev 3157)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_libpostproc/postprocess_altivec_template.c	2007-05-28 13:03:46 UTC (rev 3158)
@@ -0,0 +1,1191 @@
+/*
+ * AltiVec optimizations (C) 2004 Romain Dolbeau &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">romain at dolbeau.org</A>&gt;
+ *
+ * based on code by Copyright (C) 2001-2003 Michael Niedermayer (<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">michaelni at gmx.at</A>)
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+
+#ifdef CONFIG_DARWIN
+#define AVV(x...) (x)
+#else
+#define AVV(x...) {x}
+#endif
+
+#define ALTIVEC_TRANSPOSE_8x8_SHORT(src_a,src_b,src_c,src_d,src_e,src_f,src_g,src_h) \
+  do {                                                                  \
+    __typeof__(src_a) tempA1, tempB1, tempC1, tempD1;                   \
+    __typeof__(src_a) tempE1, tempF1, tempG1, tempH1;                   \
+    __typeof__(src_a) tempA2, tempB2, tempC2, tempD2;                   \
+    __typeof__(src_a) tempE2, tempF2, tempG2, tempH2;                   \
+    tempA1 = vec_mergeh (src_a, src_e);                                 \
+    tempB1 = vec_mergel (src_a, src_e);                                 \
+    tempC1 = vec_mergeh (src_b, src_f);                                 \
+    tempD1 = vec_mergel (src_b, src_f);                                 \
+    tempE1 = vec_mergeh (src_c, src_g);                                 \
+    tempF1 = vec_mergel (src_c, src_g);                                 \
+    tempG1 = vec_mergeh (src_d, src_h);                                 \
+    tempH1 = vec_mergel (src_d, src_h);                                 \
+    tempA2 = vec_mergeh (tempA1, tempE1);                               \
+    tempB2 = vec_mergel (tempA1, tempE1);                               \
+    tempC2 = vec_mergeh (tempB1, tempF1);                               \
+    tempD2 = vec_mergel (tempB1, tempF1);                               \
+    tempE2 = vec_mergeh (tempC1, tempG1);                               \
+    tempF2 = vec_mergel (tempC1, tempG1);                               \
+    tempG2 = vec_mergeh (tempD1, tempH1);                               \
+    tempH2 = vec_mergel (tempD1, tempH1);                               \
+    src_a = vec_mergeh (tempA2, tempE2);                                \
+    src_b = vec_mergel (tempA2, tempE2);                                \
+    src_c = vec_mergeh (tempB2, tempF2);                                \
+    src_d = vec_mergel (tempB2, tempF2);                                \
+    src_e = vec_mergeh (tempC2, tempG2);                                \
+    src_f = vec_mergel (tempC2, tempG2);                                \
+    src_g = vec_mergeh (tempD2, tempH2);                                \
+    src_h = vec_mergel (tempD2, tempH2);                                \
+  } while (0)
+
+
+static inline int vertClassify_altivec(uint8_t src[], int stride, PPContext *c) {
+  /*
+    this code makes no assumption on src or stride.
+    One could remove the recomputation of the perm
+    vector by assuming (stride % 16) == 0, unfortunately
+    this is not always true.
+  */
+  short __attribute__ ((aligned(16))) data[8];
+  int numEq;
+  uint8_t *src2 = src;
+  vector signed short v_dcOffset;
+  vector signed short v2QP;
+  vector unsigned short v4QP;
+  vector unsigned short v_dcThreshold;
+  const int properStride = (stride % 16);
+  const int srcAlign = ((unsigned long)src2 % 16);
+  const int two_vectors = ((srcAlign &gt; 8) || properStride) ? 1 : 0;
+  const vector signed int zero = vec_splat_s32(0);
+  const vector signed short mask = vec_splat_s16(1);
+  vector signed int v_numEq = vec_splat_s32(0);
+
+  data[0] = ((c-&gt;nonBQP*c-&gt;ppMode.baseDcDiff)&gt;&gt;8) + 1;
+  data[1] = data[0] * 2 + 1;
+  data[2] = c-&gt;QP * 2;
+  data[3] = c-&gt;QP * 4;
+  vector signed short v_data = vec_ld(0, data);
+  v_dcOffset = vec_splat(v_data, 0);
+  v_dcThreshold = (vector unsigned short)vec_splat(v_data, 1);
+  v2QP = vec_splat(v_data, 2);
+  v4QP = (vector unsigned short)vec_splat(v_data, 3);
+
+  src2 += stride * 4;
+
+  vector signed short v_srcAss0, v_srcAss1, v_srcAss2, v_srcAss3, v_srcAss4, v_srcAss5, v_srcAss6, v_srcAss7;
+
+#define LOAD_LINE(i)                                                    \
+  register int j##i = i * stride;                                       \
+  vector unsigned char perm##i = vec_lvsl(j##i, src2);                  \
+  const vector unsigned char v_srcA1##i = vec_ld(j##i, src2);           \
+  vector unsigned char v_srcA2##i;                                      \
+  if (two_vectors)                                                      \
+    v_srcA2##i = vec_ld(j##i + 16, src2);                               \
+  const vector unsigned char v_srcA##i =                                \
+    vec_perm(v_srcA1##i, v_srcA2##i, perm##i);                          \
+  v_srcAss##i =                                                         \
+    (vector signed short)vec_mergeh((vector signed char)zero,           \
+                                    (vector signed char)v_srcA##i)
+
+#define LOAD_LINE_ALIGNED(i)                                            \
+  register int j##i = i * stride;                                       \
+  const vector unsigned char v_srcA##i = vec_ld(j##i, src2);            \
+  v_srcAss##i =                                                         \
+    (vector signed short)vec_mergeh((vector signed char)zero,           \
+                                    (vector signed char)v_srcA##i)
+
+    // special casing the aligned case is worthwhile, as all call from
+    // the (transposed) horizontable deblocks will be aligned, i naddition
+    // to the naturraly aligned vertical deblocks.
+    if (properStride &amp;&amp; srcAlign) {
+      LOAD_LINE_ALIGNED(0);
+      LOAD_LINE_ALIGNED(1);
+      LOAD_LINE_ALIGNED(2);
+      LOAD_LINE_ALIGNED(3);
+      LOAD_LINE_ALIGNED(4);
+      LOAD_LINE_ALIGNED(5);
+      LOAD_LINE_ALIGNED(6);
+      LOAD_LINE_ALIGNED(7);
+    } else {
+      LOAD_LINE(0);
+      LOAD_LINE(1);
+      LOAD_LINE(2);
+      LOAD_LINE(3);
+      LOAD_LINE(4);
+      LOAD_LINE(5);
+      LOAD_LINE(6);
+      LOAD_LINE(7);
+    }
+#undef LOAD_LINE
+#undef LOAD_LINE_ALIGNED
+
+#define ITER(i, j)                                                      \
+  const vector signed short v_diff##i =                                 \
+    vec_sub(v_srcAss##i, v_srcAss##j);                                  \
+  const vector signed short v_sum##i =                                  \
+    vec_add(v_diff##i, v_dcOffset);                                     \
+  const vector signed short v_comp##i =                                 \
+    (vector signed short)vec_cmplt((vector unsigned short)v_sum##i,     \
+                                   v_dcThreshold);                      \
+  const vector signed short v_part##i = vec_and(mask, v_comp##i);       \
+  v_numEq = vec_sum4s(v_part##i, v_numEq);
+
+  ITER(0, 1);
+  ITER(1, 2);
+  ITER(2, 3);
+  ITER(3, 4);
+  ITER(4, 5);
+  ITER(5, 6);
+  ITER(6, 7);
+#undef ITER
+
+  v_numEq = vec_sums(v_numEq, zero);
+
+  v_numEq = vec_splat(v_numEq, 3);
+  vec_ste(v_numEq, 0, &amp;numEq);
+
+  if (numEq &gt; c-&gt;ppMode.flatnessThreshold)
+    {
+      const vector unsigned char mmoP1 = (const vector unsigned char)
+        AVV(0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f,
+            0x00, 0x01, 0x12, 0x13, 0x08, 0x09, 0x1A, 0x1B);
+      const vector unsigned char mmoP2 = (const vector unsigned char)
+        AVV(0x04, 0x05, 0x16, 0x17, 0x0C, 0x0D, 0x1E, 0x1F,
+            0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f);
+      const vector unsigned char mmoP = (const vector unsigned char)
+        vec_lvsl(8, (unsigned char*)0);
+
+      vector signed short mmoL1 = vec_perm(v_srcAss0, v_srcAss2, mmoP1);
+      vector signed short mmoL2 = vec_perm(v_srcAss4, v_srcAss6, mmoP2);
+      vector signed short mmoL = vec_perm(mmoL1, mmoL2, mmoP);
+      vector signed short mmoR1 = vec_perm(v_srcAss5, v_srcAss7, mmoP1);
+      vector signed short mmoR2 = vec_perm(v_srcAss1, v_srcAss3, mmoP2);
+      vector signed short mmoR = vec_perm(mmoR1, mmoR2, mmoP);
+      vector signed short mmoDiff = vec_sub(mmoL, mmoR);
+      vector unsigned short mmoSum = (vector unsigned short)vec_add(mmoDiff, v2QP);
+
+      if (vec_any_gt(mmoSum, v4QP))
+        return 0;
+      else
+        return 1;
+    }
+  else return 2;
+}
+
+static inline void doVertLowPass_altivec(uint8_t *src, int stride, PPContext *c) {
+  /*
+    this code makes no assumption on src or stride.
+    One could remove the recomputation of the perm
+    vector by assuming (stride % 16) == 0, unfortunately
+    this is not always true. Quite a lot of load/stores
+    can be removed by assuming proper alignement of
+    src &amp; stride :-(
+  */
+  uint8_t *src2 = src;
+  const vector signed int zero = vec_splat_s32(0);
+  const int properStride = (stride % 16);
+  const int srcAlign = ((unsigned long)src2 % 16);
+  short __attribute__ ((aligned(16))) qp[8];
+  qp[0] = c-&gt;QP;
+  vector signed short vqp = vec_ld(0, qp);
+  vqp = vec_splat(vqp, 0);
+
+  src2 += stride*3;
+
+  vector signed short vb0, vb1, vb2, vb3, vb4, vb5, vb6, vb7, vb8, vb9;
+  vector unsigned char vbA0, vbA1, vbA2, vbA3, vbA4, vbA5, vbA6, vbA7, vbA8, vbA9;
+  vector unsigned char vbB0, vbB1, vbB2, vbB3, vbB4, vbB5, vbB6, vbB7, vbB8, vbB9;
+  vector unsigned char vbT0, vbT1, vbT2, vbT3, vbT4, vbT5, vbT6, vbT7, vbT8, vbT9;
+
+#define LOAD_LINE(i)                                                    \
+  const vector unsigned char perml##i =                                 \
+    vec_lvsl(i * stride, src2);                                         \
+  vbA##i = vec_ld(i * stride, src2);                                    \
+  vbB##i = vec_ld(i * stride + 16, src2);                               \
+  vbT##i = vec_perm(vbA##i, vbB##i, perml##i);                          \
+  vb##i =                                                               \
+    (vector signed short)vec_mergeh((vector unsigned char)zero,         \
+                                    (vector unsigned char)vbT##i)
+
+#define LOAD_LINE_ALIGNED(i)                                            \
+  register int j##i = i * stride;                                       \
+  vbT##i = vec_ld(j##i, src2);                                          \
+  vb##i =                                                               \
+    (vector signed short)vec_mergeh((vector signed char)zero,           \
+                                    (vector signed char)vbT##i)
+
+    // special casing the aligned case is worthwhile, as all call from
+    // the (transposed) horizontable deblocks will be aligned, in addition
+    // to the naturraly aligned vertical deblocks.
+    if (properStride &amp;&amp; srcAlign) {
+      LOAD_LINE_ALIGNED(0);
+      LOAD_LINE_ALIGNED(1);
+      LOAD_LINE_ALIGNED(2);
+      LOAD_LINE_ALIGNED(3);
+      LOAD_LINE_ALIGNED(4);
+      LOAD_LINE_ALIGNED(5);
+      LOAD_LINE_ALIGNED(6);
+      LOAD_LINE_ALIGNED(7);
+      LOAD_LINE_ALIGNED(8);
+      LOAD_LINE_ALIGNED(9);
+    } else {
+      LOAD_LINE(0);
+      LOAD_LINE(1);
+      LOAD_LINE(2);
+      LOAD_LINE(3);
+      LOAD_LINE(4);
+      LOAD_LINE(5);
+      LOAD_LINE(6);
+      LOAD_LINE(7);
+      LOAD_LINE(8);
+      LOAD_LINE(9);
+    }
+#undef LOAD_LINE
+#undef LOAD_LINE_ALIGNED
+
+  const vector unsigned short v_2 = vec_splat_u16(2);
+  const vector unsigned short v_4 = vec_splat_u16(4);
+
+  const vector signed short v_diff01 = vec_sub(vb0, vb1);
+  const vector unsigned short v_cmp01 =
+    (const vector unsigned short) vec_cmplt(vec_abs(v_diff01), vqp);
+  const vector signed short v_first = vec_sel(vb1, vb0, v_cmp01);
+  const vector signed short v_diff89 = vec_sub(vb8, vb9);
+  const vector unsigned short v_cmp89 =
+    (const vector unsigned short) vec_cmplt(vec_abs(v_diff89), vqp);
+  const vector signed short v_last = vec_sel(vb8, vb9, v_cmp89);
+
+  const vector signed short temp01 = vec_mladd(v_first, (vector signed short)v_4, vb1);
+  const vector signed short temp02 = vec_add(vb2, vb3);
+  const vector signed short temp03 = vec_add(temp01, (vector signed short)v_4);
+  const vector signed short v_sumsB0 = vec_add(temp02, temp03);
+
+  const vector signed short temp11 = vec_sub(v_sumsB0, v_first);
+  const vector signed short v_sumsB1 = vec_add(temp11, vb4);
+
+  const vector signed short temp21 = vec_sub(v_sumsB1, v_first);
+  const vector signed short v_sumsB2 = vec_add(temp21, vb5);
+
+  const vector signed short temp31 = vec_sub(v_sumsB2, v_first);
+  const vector signed short v_sumsB3 = vec_add(temp31, vb6);
+
+  const vector signed short temp41 = vec_sub(v_sumsB3, v_first);
+  const vector signed short v_sumsB4 = vec_add(temp41, vb7);
+
+  const vector signed short temp51 = vec_sub(v_sumsB4, vb1);
+  const vector signed short v_sumsB5 = vec_add(temp51, vb8);
+
+  const vector signed short temp61 = vec_sub(v_sumsB5, vb2);
+  const vector signed short v_sumsB6 = vec_add(temp61, v_last);
+
+  const vector signed short temp71 = vec_sub(v_sumsB6, vb3);
+  const vector signed short v_sumsB7 = vec_add(temp71, v_last);
+
+  const vector signed short temp81 = vec_sub(v_sumsB7, vb4);
+  const vector signed short v_sumsB8 = vec_add(temp81, v_last);
+
+  const vector signed short temp91 = vec_sub(v_sumsB8, vb5);
+  const vector signed short v_sumsB9 = vec_add(temp91, v_last);
+
+#define COMPUTE_VR(i, j, k)                                             \
+  const vector signed short temps1##i =                                 \
+    vec_add(v_sumsB##i, v_sumsB##k);                                    \
+  const vector signed short temps2##i =                                 \
+    vec_mladd(vb##j, (vector signed short)v_2, temps1##i);              \
+  const vector signed short  vr##j = vec_sra(temps2##i, v_4)
+
+  COMPUTE_VR(0, 1, 2);
+  COMPUTE_VR(1, 2, 3);
+  COMPUTE_VR(2, 3, 4);
+  COMPUTE_VR(3, 4, 5);
+  COMPUTE_VR(4, 5, 6);
+  COMPUTE_VR(5, 6, 7);
+  COMPUTE_VR(6, 7, 8);
+  COMPUTE_VR(7, 8, 9);
+
+  const vector signed char neg1 = vec_splat_s8(-1);
+  const vector unsigned char permHH = (const vector unsigned char)AVV(0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
+                                                                      0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F);
+
+#define PACK_AND_STORE(i)                                       \
+  const vector unsigned char perms##i =                         \
+    vec_lvsr(i * stride, src2);                                 \
+  const vector unsigned char vf##i =                            \
+    vec_packsu(vr##i, (vector signed short)zero);               \
+  const vector unsigned char vg##i =                            \
+    vec_perm(vf##i, vbT##i, permHH);                            \
+  const vector unsigned char mask##i =                          \
+    vec_perm((vector unsigned char)zero, (vector unsigned char)neg1, perms##i); \
+  const vector unsigned char vg2##i =                           \
+    vec_perm(vg##i, vg##i, perms##i);                           \
+  const vector unsigned char svA##i =                           \
+    vec_sel(vbA##i, vg2##i, mask##i);                           \
+  const vector unsigned char svB##i =                           \
+    vec_sel(vg2##i, vbB##i, mask##i);                           \
+  vec_st(svA##i, i * stride, src2);                             \
+  vec_st(svB##i, i * stride + 16, src2)
+
+#define PACK_AND_STORE_ALIGNED(i)                               \
+  const vector unsigned char vf##i =                            \
+    vec_packsu(vr##i, (vector signed short)zero);               \
+  const vector unsigned char vg##i =                            \
+    vec_perm(vf##i, vbT##i, permHH);                            \
+  vec_st(vg##i, i * stride, src2)
+
+  // special casing the aligned case is worthwhile, as all call from
+  // the (transposed) horizontable deblocks will be aligned, in addition
+  // to the naturraly aligned vertical deblocks.
+  if (properStride &amp;&amp; srcAlign) {
+    PACK_AND_STORE_ALIGNED(1);
+    PACK_AND_STORE_ALIGNED(2);
+    PACK_AND_STORE_ALIGNED(3);
+    PACK_AND_STORE_ALIGNED(4);
+    PACK_AND_STORE_ALIGNED(5);
+    PACK_AND_STORE_ALIGNED(6);
+    PACK_AND_STORE_ALIGNED(7);
+    PACK_AND_STORE_ALIGNED(8);
+  } else {
+    PACK_AND_STORE(1);
+    PACK_AND_STORE(2);
+    PACK_AND_STORE(3);
+    PACK_AND_STORE(4);
+    PACK_AND_STORE(5);
+    PACK_AND_STORE(6);
+    PACK_AND_STORE(7);
+    PACK_AND_STORE(8);
+  }
+#undef PACK_AND_STORE
+#undef PACK_AND_STORE_ALIGNED
+}
+
+
+
+static inline void doVertDefFilter_altivec(uint8_t src[], int stride, PPContext *c) {
+  /*
+    this code makes no assumption on src or stride.
+    One could remove the recomputation of the perm
+    vector by assuming (stride % 16) == 0, unfortunately
+    this is not always true. Quite a lot of load/stores
+    can be removed by assuming proper alignement of
+    src &amp; stride :-(
+  */
+  uint8_t *src2 = src;
+  const vector signed int zero = vec_splat_s32(0);
+  short __attribute__ ((aligned(16))) qp[8];
+  qp[0] = 8*c-&gt;QP;
+  vector signed short vqp = vec_ld(0, qp);
+  vqp = vec_splat(vqp, 0);
+
+#define LOAD_LINE(i)                                                    \
+  const vector unsigned char perm##i =                                  \
+    vec_lvsl(i * stride, src2);                                         \
+  const vector unsigned char vbA##i =                                   \
+    vec_ld(i * stride, src2);                                           \
+  const vector unsigned char vbB##i =                                   \
+    vec_ld(i * stride + 16, src2);                                      \
+  const vector unsigned char vbT##i =                                   \
+    vec_perm(vbA##i, vbB##i, perm##i);                                  \
+  const vector signed short vb##i =                                     \
+    (vector signed short)vec_mergeh((vector unsigned char)zero,         \
+                                    (vector unsigned char)vbT##i)
+
+  src2 += stride*3;
+
+  LOAD_LINE(1);
+  LOAD_LINE(2);
+  LOAD_LINE(3);
+  LOAD_LINE(4);
+  LOAD_LINE(5);
+  LOAD_LINE(6);
+  LOAD_LINE(7);
+  LOAD_LINE(8);
+#undef LOAD_LINE
+
+  const vector signed short v_1 = vec_splat_s16(1);
+  const vector signed short v_2 = vec_splat_s16(2);
+  const vector signed short v_5 = vec_splat_s16(5);
+  const vector signed short v_32 = vec_sl(v_1,
+                                          (vector unsigned short)v_5);
+  /* middle energy */
+  const vector signed short l3minusl6 = vec_sub(vb3, vb6);
+  const vector signed short l5minusl4 = vec_sub(vb5, vb4);
+  const vector signed short twotimes_l3minusl6 = vec_mladd(v_2, l3minusl6, (vector signed short)zero);
+  const vector signed short mE = vec_mladd(v_5, l5minusl4, twotimes_l3minusl6);
+  const vector signed short absmE = vec_abs(mE);
+  /* left &amp; right energy */
+  const vector signed short l1minusl4 = vec_sub(vb1, vb4);
+  const vector signed short l3minusl2 = vec_sub(vb3, vb2);
+  const vector signed short l5minusl8 = vec_sub(vb5, vb8);
+  const vector signed short l7minusl6 = vec_sub(vb7, vb6);
+  const vector signed short twotimes_l1minusl4 = vec_mladd(v_2, l1minusl4, (vector signed short)zero);
+  const vector signed short twotimes_l5minusl8 = vec_mladd(v_2, l5minusl8, (vector signed short)zero);
+  const vector signed short lE = vec_mladd(v_5, l3minusl2, twotimes_l1minusl4);
+  const vector signed short rE = vec_mladd(v_5, l7minusl6, twotimes_l5minusl8);
+  /* d */
+  const vector signed short ddiff = vec_sub(absmE,
+                                            vec_min(vec_abs(lE),
+                                                    vec_abs(rE)));
+  const vector signed short ddiffclamp = vec_max(ddiff, (vector signed short)zero);
+  const vector signed short dtimes64 = vec_mladd(v_5, ddiffclamp, v_32);
+  const vector signed short d = vec_sra(dtimes64, vec_splat_u16(6));
+  const vector signed short minusd = vec_sub((vector signed short)zero, d);
+  const vector signed short finald = vec_sel(minusd,
+                                             d,
+                                             vec_cmpgt(vec_sub((vector signed short)zero, mE),
+                                                       (vector signed short)zero));
+  /* q */
+  const vector signed short qtimes2 = vec_sub(vb4, vb5);
+  /* for a shift right to behave like /2, we need to add one
+     to all negative integer */
+  const vector signed short rounddown = vec_sel((vector signed short)zero,
+                                                v_1,
+                                                vec_cmplt(qtimes2, (vector signed short)zero));
+  const vector signed short q = vec_sra(vec_add(qtimes2, rounddown), vec_splat_u16(1));
+  /* clamp */
+  const vector signed short dclamp_P1 = vec_max((vector signed short)zero, finald);
+  const vector signed short dclamp_P = vec_min(dclamp_P1, q);
+  const vector signed short dclamp_N1 = vec_min((vector signed short)zero, finald);
+  const vector signed short dclamp_N = vec_max(dclamp_N1, q);
+
+  const vector signed short dclampedfinal = vec_sel(dclamp_N,
+                                                    dclamp_P,
+                                                    vec_cmpgt(q, (vector signed short)zero));
+  const vector signed short dornotd = vec_sel((vector signed short)zero,
+                                              dclampedfinal,
+                                              vec_cmplt(absmE, vqp));
+  /* add/substract to l4 and l5 */
+  const vector signed short vb4minusd = vec_sub(vb4, dornotd);
+  const vector signed short vb5plusd = vec_add(vb5, dornotd);
+  /* finally, stores */
+  const vector unsigned char st4 = vec_packsu(vb4minusd, (vector signed short)zero);
+  const vector unsigned char st5 = vec_packsu(vb5plusd, (vector signed short)zero);
+
+  const vector signed char neg1 = vec_splat_s8(-1);
+  const vector unsigned char permHH = (const vector unsigned char)AVV(0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
+                                                                      0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F);
+
+#define STORE(i)                                                \
+  const vector unsigned char perms##i =                         \
+    vec_lvsr(i * stride, src2);                                 \
+  const vector unsigned char vg##i =                            \
+    vec_perm(st##i, vbT##i, permHH);                            \
+  const vector unsigned char mask##i =                          \
+    vec_perm((vector unsigned char)zero, (vector unsigned char)neg1, perms##i); \
+  const vector unsigned char vg2##i =                           \
+    vec_perm(vg##i, vg##i, perms##i);                           \
+  const vector unsigned char svA##i =                           \
+    vec_sel(vbA##i, vg2##i, mask##i);                           \
+  const vector unsigned char svB##i =                           \
+    vec_sel(vg2##i, vbB##i, mask##i);                           \
+  vec_st(svA##i, i * stride, src2);                             \
+  vec_st(svB##i, i * stride + 16, src2)
+
+  STORE(4);
+  STORE(5);
+}
+
+static inline void dering_altivec(uint8_t src[], int stride, PPContext *c) {
+  /*
+    this code makes no assumption on src or stride.
+    One could remove the recomputation of the perm
+    vector by assuming (stride % 16) == 0, unfortunately
+    this is not always true. Quite a lot of load/stores
+    can be removed by assuming proper alignement of
+    src &amp; stride :-(
+  */
+  uint8_t *srcCopy = src;
+  uint8_t __attribute__((aligned(16))) dt[16];
+  const vector signed int zero = vec_splat_s32(0);
+  vector unsigned char v_dt;
+  dt[0] = deringThreshold;
+  v_dt = vec_splat(vec_ld(0, dt), 0);
+
+#define LOAD_LINE(i)                                                    \
+  const vector unsigned char perm##i =                                  \
+    vec_lvsl(i * stride, srcCopy);                                      \
+  vector unsigned char sA##i = vec_ld(i * stride, srcCopy);             \
+  vector unsigned char sB##i = vec_ld(i * stride + 16, srcCopy);        \
+  vector unsigned char src##i = vec_perm(sA##i, sB##i, perm##i)
+
+  LOAD_LINE(0);
+  LOAD_LINE(1);
+  LOAD_LINE(2);
+  LOAD_LINE(3);
+  LOAD_LINE(4);
+  LOAD_LINE(5);
+  LOAD_LINE(6);
+  LOAD_LINE(7);
+  LOAD_LINE(8);
+  LOAD_LINE(9);
+#undef LOAD_LINE
+
+  vector unsigned char v_avg;
+  {
+    const vector unsigned char trunc_perm = (vector unsigned char)
+      AVV(0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,
+          0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18);
+    const vector unsigned char trunc_src12 = vec_perm(src1, src2, trunc_perm);
+    const vector unsigned char trunc_src34 = vec_perm(src3, src4, trunc_perm);
+    const vector unsigned char trunc_src56 = vec_perm(src5, src6, trunc_perm);
+    const vector unsigned char trunc_src78 = vec_perm(src7, src8, trunc_perm);
+
+#define EXTRACT(op) do {                                                \
+      const vector unsigned char s##op##_1 = vec_##op(trunc_src12, trunc_src34); \
+      const vector unsigned char s##op##_2 = vec_##op(trunc_src56, trunc_src78); \
+      const vector unsigned char s##op##_6 = vec_##op(s##op##_1, s##op##_2); \
+      const vector unsigned char s##op##_8h = vec_mergeh(s##op##_6, s##op##_6); \
+      const vector unsigned char s##op##_8l = vec_mergel(s##op##_6, s##op##_6); \
+      const vector unsigned char s##op##_9 = vec_##op(s##op##_8h, s##op##_8l); \
+      const vector unsigned char s##op##_9h = vec_mergeh(s##op##_9, s##op##_9); \
+      const vector unsigned char s##op##_9l = vec_mergel(s##op##_9, s##op##_9); \
+      const vector unsigned char s##op##_10 = vec_##op(s##op##_9h, s##op##_9l); \
+      const vector unsigned char s##op##_10h = vec_mergeh(s##op##_10, s##op##_10); \
+      const vector unsigned char s##op##_10l = vec_mergel(s##op##_10, s##op##_10); \
+      const vector unsigned char s##op##_11 = vec_##op(s##op##_10h, s##op##_10l); \
+      const vector unsigned char s##op##_11h = vec_mergeh(s##op##_11, s##op##_11); \
+      const vector unsigned char s##op##_11l = vec_mergel(s##op##_11, s##op##_11); \
+      v_##op = vec_##op(s##op##_11h, s##op##_11l); } while (0)
+
+    vector unsigned char v_min;
+    vector unsigned char v_max;
+    EXTRACT(min);
+    EXTRACT(max);
+#undef EXTRACT
+
+    if (vec_all_lt(vec_sub(v_max, v_min), v_dt))
+      return;
+
+    v_avg = vec_avg(v_min, v_max);
+  }
+
+  signed int __attribute__((aligned(16))) S[8];
+  {
+    const vector unsigned short mask1 = (vector unsigned short)
+      AVV(0x0001, 0x0002, 0x0004, 0x0008,
+          0x0010, 0x0020, 0x0040, 0x0080);
+    const vector unsigned short mask2 = (vector unsigned short)
+      AVV(0x0100, 0x0200, 0x0000, 0x0000,
+          0x0000, 0x0000, 0x0000, 0x0000);
+
+    const vector unsigned int vuint32_16 = vec_sl(vec_splat_u32(1), vec_splat_u32(4));
+    const vector unsigned int vuint32_1 = vec_splat_u32(1);
+
+#define COMPARE(i)                                                      \
+    vector signed int sum##i;                                           \
+    do {                                                                \
+      const vector unsigned char cmp##i =                               \
+        (vector unsigned char)vec_cmpgt(src##i, v_avg);                 \
+      const vector unsigned short cmpHi##i =                            \
+        (vector unsigned short)vec_mergeh(cmp##i, cmp##i);              \
+      const vector unsigned short cmpLi##i =                            \
+        (vector unsigned short)vec_mergel(cmp##i, cmp##i);              \
+      const vector signed short cmpHf##i =                              \
+        (vector signed short)vec_and(cmpHi##i, mask1);                  \
+      const vector signed short cmpLf##i =                              \
+        (vector signed short)vec_and(cmpLi##i, mask2);                  \
+      const vector signed int sump##i = vec_sum4s(cmpHf##i, zero);      \
+      const vector signed int sumq##i = vec_sum4s(cmpLf##i, sump##i);   \
+      sum##i  = vec_sums(sumq##i, zero); } while (0)
+
+    COMPARE(0);
+    COMPARE(1);
+    COMPARE(2);
+    COMPARE(3);
+    COMPARE(4);
+    COMPARE(5);
+    COMPARE(6);
+    COMPARE(7);
+    COMPARE(8);
+    COMPARE(9);
+#undef COMPARE
+
+    vector signed int sumA2;
+    vector signed int sumB2;
+    {
+      const vector signed int sump02 = vec_mergel(sum0, sum2);
+      const vector signed int sump13 = vec_mergel(sum1, sum3);
+      const vector signed int sumA = vec_mergel(sump02, sump13);
+
+      const vector signed int sump46 = vec_mergel(sum4, sum6);
+      const vector signed int sump57 = vec_mergel(sum5, sum7);
+      const vector signed int sumB = vec_mergel(sump46, sump57);
+
+      const vector signed int sump8A = vec_mergel(sum8, zero);
+      const vector signed int sump9B = vec_mergel(sum9, zero);
+      const vector signed int sumC = vec_mergel(sump8A, sump9B);
+
+      const vector signed int tA = vec_sl(vec_nor(zero, sumA), vuint32_16);
+      const vector signed int tB = vec_sl(vec_nor(zero, sumB), vuint32_16);
+      const vector signed int tC = vec_sl(vec_nor(zero, sumC), vuint32_16);
+      const vector signed int t2A = vec_or(sumA, tA);
+      const vector signed int t2B = vec_or(sumB, tB);
+      const vector signed int t2C = vec_or(sumC, tC);
+      const vector signed int t3A = vec_and(vec_sra(t2A, vuint32_1),
+                                            vec_sl(t2A, vuint32_1));
+      const vector signed int t3B = vec_and(vec_sra(t2B, vuint32_1),
+                                            vec_sl(t2B, vuint32_1));
+      const vector signed int t3C = vec_and(vec_sra(t2C, vuint32_1),
+                                            vec_sl(t2C, vuint32_1));
+      const vector signed int yA = vec_and(t2A, t3A);
+      const vector signed int yB = vec_and(t2B, t3B);
+      const vector signed int yC = vec_and(t2C, t3C);
+
+      const vector unsigned char strangeperm1 = vec_lvsl(4, (unsigned char*)0);
+      const vector unsigned char strangeperm2 = vec_lvsl(8, (unsigned char*)0);
+      const vector signed int sumAd4 = vec_perm(yA, yB, strangeperm1);
+      const vector signed int sumAd8 = vec_perm(yA, yB, strangeperm2);
+      const vector signed int sumBd4 = vec_perm(yB, yC, strangeperm1);
+      const vector signed int sumBd8 = vec_perm(yB, yC, strangeperm2);
+      const vector signed int sumAp = vec_and(yA,
+                                              vec_and(sumAd4,sumAd8));
+      const vector signed int sumBp = vec_and(yB,
+                                              vec_and(sumBd4,sumBd8));
+      sumA2 = vec_or(sumAp,
+                     vec_sra(sumAp,
+                             vuint32_16));
+      sumB2  = vec_or(sumBp,
+                      vec_sra(sumBp,
+                              vuint32_16));
+    }
+    vec_st(sumA2, 0, S);
+    vec_st(sumB2, 16, S);
+  }
+
+  /* I'm not sure the following is actually faster
+     than straight, unvectorized C code :-( */
+
+  int __attribute__((aligned(16))) tQP2[4];
+  tQP2[0]= c-&gt;QP/2 + 1;
+  vector signed int vQP2 = vec_ld(0, tQP2);
+  vQP2 = vec_splat(vQP2, 0);
+  const vector signed int vsint32_8 = vec_splat_s32(8);
+  const vector unsigned int vuint32_4 = vec_splat_u32(4);
+
+  const vector unsigned char permA1 = (vector unsigned char)
+    AVV(0x00, 0x01, 0x02, 0x10, 0x11, 0x12, 0x1F, 0x1F,
+        0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F);
+  const vector unsigned char permA2 = (vector unsigned char)
+    AVV(0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x10, 0x11,
+        0x12, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F);
+  const vector unsigned char permA1inc = (vector unsigned char)
+    AVV(0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00,
+        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00);
+  const vector unsigned char permA2inc = (vector unsigned char)
+    AVV(0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01,
+        0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00);
+  const vector unsigned char magic = (vector unsigned char)
+    AVV(0x01, 0x02, 0x01, 0x02, 0x04, 0x02, 0x01, 0x02,
+        0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00);
+  const vector unsigned char extractPerm = (vector unsigned char)
+    AVV(0x10, 0x10, 0x10, 0x01, 0x10, 0x10, 0x10, 0x01,
+        0x10, 0x10, 0x10, 0x01, 0x10, 0x10, 0x10, 0x01);
+  const vector unsigned char extractPermInc = (vector unsigned char)
+    AVV(0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01,
+        0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01);
+  const vector unsigned char identity = vec_lvsl(0,(unsigned char *)0);
+  const vector unsigned char tenRight = (vector unsigned char)
+    AVV(0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00);
+  const vector unsigned char eightLeft = (vector unsigned char)
+    AVV(0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08);
+
+
+#define F_INIT(i)                                       \
+  vector unsigned char tenRightM##i = tenRight;         \
+  vector unsigned char permA1M##i = permA1;             \
+  vector unsigned char permA2M##i = permA2;             \
+  vector unsigned char extractPermM##i = extractPerm
+
+#define F2(i, j, k, l)                                                  \
+  if (S[i] &amp; (1 &lt;&lt; (l+1))) {                                            \
+    const vector unsigned char a_##j##_A##l =                           \
+      vec_perm(src##i, src##j, permA1M##i);                             \
+    const vector unsigned char a_##j##_B##l =                           \
+      vec_perm(a_##j##_A##l, src##k, permA2M##i);                       \
+    const vector signed int a_##j##_sump##l =                           \
+      (vector signed int)vec_msum(a_##j##_B##l, magic,                  \
+                                  (vector unsigned int)zero);           \
+    vector signed int F_##j##_##l =                                     \
+      vec_sr(vec_sums(a_##j##_sump##l, vsint32_8), vuint32_4);          \
+    F_##j##_##l = vec_splat(F_##j##_##l, 3);                            \
+    const vector signed int p_##j##_##l =                               \
+      (vector signed int)vec_perm(src##j,                               \
+                                  (vector unsigned char)zero,           \
+                                  extractPermM##i);                     \
+    const vector signed int sum_##j##_##l = vec_add( p_##j##_##l, vQP2);\
+    const vector signed int diff_##j##_##l = vec_sub( p_##j##_##l, vQP2);\
+    vector signed int newpm_##j##_##l;                                  \
+    if (vec_all_lt(sum_##j##_##l, F_##j##_##l))                         \
+      newpm_##j##_##l = sum_##j##_##l;                                  \
+    else if (vec_all_gt(diff_##j##_##l, F_##j##_##l))                   \
+      newpm_##j##_##l = diff_##j##_##l;                                 \
+    else newpm_##j##_##l = F_##j##_##l;                                 \
+    const vector unsigned char newpm2_##j##_##l =                       \
+      vec_splat((vector unsigned char)newpm_##j##_##l, 15);             \
+    const vector unsigned char mask##j##l = vec_add(identity,           \
+                                                    tenRightM##i);      \
+    src##j = vec_perm(src##j, newpm2_##j##_##l, mask##j##l);            \
+  }                                                                     \
+  permA1M##i = vec_add(permA1M##i, permA1inc);                          \
+  permA2M##i = vec_add(permA2M##i, permA2inc);                          \
+  tenRightM##i = vec_sro(tenRightM##i, eightLeft);                      \
+  extractPermM##i = vec_add(extractPermM##i, extractPermInc)
+
+#define ITER(i, j, k)                           \
+  F_INIT(i);                                    \
+  F2(i, j, k, 0);                               \
+  F2(i, j, k, 1);                               \
+  F2(i, j, k, 2);                               \
+  F2(i, j, k, 3);                               \
+  F2(i, j, k, 4);                               \
+  F2(i, j, k, 5);                               \
+  F2(i, j, k, 6);                               \
+  F2(i, j, k, 7)
+
+  ITER(0, 1, 2);
+  ITER(1, 2, 3);
+  ITER(2, 3, 4);
+  ITER(3, 4, 5);
+  ITER(4, 5, 6);
+  ITER(5, 6, 7);
+  ITER(6, 7, 8);
+  ITER(7, 8, 9);
+
+  const vector signed char neg1 = vec_splat_s8(-1);
+
+#define STORE_LINE(i)                                   \
+  const vector unsigned char permST##i =                \
+    vec_lvsr(i * stride, srcCopy);                      \
+  const vector unsigned char maskST##i =                \
+    vec_perm((vector unsigned char)zero,                \
+             (vector unsigned char)neg1, permST##i);    \
+  src##i = vec_perm(src##i ,src##i, permST##i);         \
+  sA##i= vec_sel(sA##i, src##i, maskST##i);             \
+  sB##i= vec_sel(src##i, sB##i, maskST##i);             \
+  vec_st(sA##i, i * stride, srcCopy);                   \
+  vec_st(sB##i, i * stride + 16, srcCopy)
+
+  STORE_LINE(1);
+  STORE_LINE(2);
+  STORE_LINE(3);
+  STORE_LINE(4);
+  STORE_LINE(5);
+  STORE_LINE(6);
+  STORE_LINE(7);
+  STORE_LINE(8);
+
+#undef STORE_LINE
+#undef ITER
+#undef F2
+}
+
+#define doHorizLowPass_altivec(a...) doHorizLowPass_C(a)
+#define doHorizDefFilter_altivec(a...) doHorizDefFilter_C(a)
+#define do_a_deblock_altivec(a...) do_a_deblock_C(a)
+
+static inline void RENAME(tempNoiseReducer)(uint8_t *src, int stride,
+                                    uint8_t *tempBlured, uint32_t *tempBluredPast, int *maxNoise)
+{
+  const vector signed int zero = vec_splat_s32(0);
+  const vector signed short vsint16_1 = vec_splat_s16(1);
+  vector signed int v_dp = zero;
+  vector signed int v_sysdp = zero;
+  int d, sysd, i;
+
+  tempBluredPast[127]= maxNoise[0];
+  tempBluredPast[128]= maxNoise[1];
+  tempBluredPast[129]= maxNoise[2];
+
+#define LOAD_LINE(src, i)                                               \
+  register int j##src##i = i * stride;                                  \
+  vector unsigned char perm##src##i = vec_lvsl(j##src##i, src);         \
+  const vector unsigned char v_##src##A1##i = vec_ld(j##src##i, src);   \
+  const vector unsigned char v_##src##A2##i = vec_ld(j##src##i + 16, src); \
+  const vector unsigned char v_##src##A##i =                            \
+    vec_perm(v_##src##A1##i, v_##src##A2##i, perm##src##i);             \
+  vector signed short v_##src##Ass##i =                                 \
+    (vector signed short)vec_mergeh((vector signed char)zero,           \
+                                    (vector signed char)v_##src##A##i)
+
+  LOAD_LINE(src, 0);
+  LOAD_LINE(src, 1);
+  LOAD_LINE(src, 2);
+  LOAD_LINE(src, 3);
+  LOAD_LINE(src, 4);
+  LOAD_LINE(src, 5);
+  LOAD_LINE(src, 6);
+  LOAD_LINE(src, 7);
+
+  LOAD_LINE(tempBlured, 0);
+  LOAD_LINE(tempBlured, 1);
+  LOAD_LINE(tempBlured, 2);
+  LOAD_LINE(tempBlured, 3);
+  LOAD_LINE(tempBlured, 4);
+  LOAD_LINE(tempBlured, 5);
+  LOAD_LINE(tempBlured, 6);
+  LOAD_LINE(tempBlured, 7);
+#undef LOAD_LINE
+
+#define ACCUMULATE_DIFFS(i)                                     \
+  vector signed short v_d##i = vec_sub(v_tempBluredAss##i,      \
+                                       v_srcAss##i);            \
+  v_dp = vec_msums(v_d##i, v_d##i, v_dp);                       \
+  v_sysdp = vec_msums(v_d##i, vsint16_1, v_sysdp)
+
+  ACCUMULATE_DIFFS(0);
+  ACCUMULATE_DIFFS(1);
+  ACCUMULATE_DIFFS(2);
+  ACCUMULATE_DIFFS(3);
+  ACCUMULATE_DIFFS(4);
+  ACCUMULATE_DIFFS(5);
+  ACCUMULATE_DIFFS(6);
+  ACCUMULATE_DIFFS(7);
+#undef ACCUMULATE_DIFFS
+
+  v_dp = vec_sums(v_dp, zero);
+  v_sysdp = vec_sums(v_sysdp, zero);
+
+  v_dp = vec_splat(v_dp, 3);
+  v_sysdp = vec_splat(v_sysdp, 3);
+
+  vec_ste(v_dp, 0, &amp;d);
+  vec_ste(v_sysdp, 0, &amp;sysd);
+
+  i = d;
+  d = (4*d
+       +(*(tempBluredPast-256))
+       +(*(tempBluredPast-1))+ (*(tempBluredPast+1))
+       +(*(tempBluredPast+256))
+       +4)&gt;&gt;3;
+
+  *tempBluredPast=i;
+
+  if (d &gt; maxNoise[1]) {
+    if (d &lt; maxNoise[2]) {
+#define OP(i) v_tempBluredAss##i = vec_avg(v_tempBluredAss##i, v_srcAss##i);
+
+      OP(0);
+      OP(1);
+      OP(2);
+      OP(3);
+      OP(4);
+      OP(5);
+      OP(6);
+      OP(7);
+#undef OP
+    } else {
+#define OP(i) v_tempBluredAss##i = v_srcAss##i;
+
+      OP(0);
+      OP(1);
+      OP(2);
+      OP(3);
+      OP(4);
+      OP(5);
+      OP(6);
+      OP(7);
+#undef OP
+    }
+  } else {
+    if (d &lt; maxNoise[0]) {
+      const vector signed short vsint16_7 = vec_splat_s16(7);
+      const vector signed short vsint16_4 = vec_splat_s16(4);
+      const vector unsigned short vuint16_3 = vec_splat_u16(3);
+
+#define OP(i)                                                   \
+      const vector signed short v_temp##i =                     \
+        vec_mladd(v_tempBluredAss##i,                           \
+                  vsint16_7, v_srcAss##i);                      \
+      const vector signed short v_temp2##i =                    \
+        vec_add(v_temp##i, vsint16_4);                          \
+      v_tempBluredAss##i = vec_sr(v_temp2##i, vuint16_3)
+
+      OP(0);
+      OP(1);
+      OP(2);
+      OP(3);
+      OP(4);
+      OP(5);
+      OP(6);
+      OP(7);
+#undef OP
+    } else {
+      const vector signed short vsint16_3 = vec_splat_s16(3);
+      const vector signed short vsint16_2 = vec_splat_s16(2);
+
+#define OP(i)                                                   \
+      const vector signed short v_temp##i =                     \
+        vec_mladd(v_tempBluredAss##i,                           \
+                  vsint16_3, v_srcAss##i);                      \
+      const vector signed short v_temp2##i =                    \
+        vec_add(v_temp##i, vsint16_2);                          \
+      v_tempBluredAss##i = vec_sr(v_temp2##i, (vector unsigned short)vsint16_2)
+
+      OP(0);
+      OP(1);
+      OP(2);
+      OP(3);
+      OP(4);
+      OP(5);
+      OP(6);
+      OP(7);
+#undef OP
+    }
+  }
+
+  const vector signed char neg1 = vec_splat_s8(-1);
+  const vector unsigned char permHH = (const vector unsigned char)AVV(0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
+                                                                      0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F);
+
+#define PACK_AND_STORE(src, i)                                  \
+  const vector unsigned char perms##src##i =                    \
+    vec_lvsr(i * stride, src);                                  \
+  const vector unsigned char vf##src##i =                       \
+    vec_packsu(v_tempBluredAss##i, (vector signed short)zero);  \
+  const vector unsigned char vg##src##i =                       \
+    vec_perm(vf##src##i, v_##src##A##i, permHH);                \
+  const vector unsigned char mask##src##i =                     \
+    vec_perm((vector unsigned char)zero, (vector unsigned char)neg1, perms##src##i); \
+  const vector unsigned char vg2##src##i =                      \
+    vec_perm(vg##src##i, vg##src##i, perms##src##i);            \
+  const vector unsigned char svA##src##i =                      \
+    vec_sel(v_##src##A1##i, vg2##src##i, mask##src##i);         \
+  const vector unsigned char svB##src##i =                      \
+    vec_sel(vg2##src##i, v_##src##A2##i, mask##src##i);         \
+  vec_st(svA##src##i, i * stride, src);                         \
+  vec_st(svB##src##i, i * stride + 16, src)
+
+  PACK_AND_STORE(src, 0);
+  PACK_AND_STORE(src, 1);
+  PACK_AND_STORE(src, 2);
+  PACK_AND_STORE(src, 3);
+  PACK_AND_STORE(src, 4);
+  PACK_AND_STORE(src, 5);
+  PACK_AND_STORE(src, 6);
+  PACK_AND_STORE(src, 7);
+  PACK_AND_STORE(tempBlured, 0);
+  PACK_AND_STORE(tempBlured, 1);
+  PACK_AND_STORE(tempBlured, 2);
+  PACK_AND_STORE(tempBlured, 3);
+  PACK_AND_STORE(tempBlured, 4);
+  PACK_AND_STORE(tempBlured, 5);
+  PACK_AND_STORE(tempBlured, 6);
+  PACK_AND_STORE(tempBlured, 7);
+#undef PACK_AND_STORE
+}
+
+static inline void transpose_16x8_char_toPackedAlign_altivec(unsigned char* dst, unsigned char* src, int stride) {
+  const vector unsigned char zero = vec_splat_u8(0);
+
+#define LOAD_DOUBLE_LINE(i, j)                                          \
+  vector unsigned char perm1##i = vec_lvsl(i * stride, src);            \
+  vector unsigned char perm2##i = vec_lvsl(j * stride, src);            \
+  vector unsigned char srcA##i = vec_ld(i * stride, src);               \
+  vector unsigned char srcB##i = vec_ld(i * stride + 16, src);          \
+  vector unsigned char srcC##i = vec_ld(j * stride, src);               \
+  vector unsigned char srcD##i = vec_ld(j * stride+ 16, src);           \
+  vector unsigned char src##i = vec_perm(srcA##i, srcB##i, perm1##i);   \
+  vector unsigned char src##j = vec_perm(srcC##i, srcD##i, perm2##i)
+
+  LOAD_DOUBLE_LINE(0, 1);
+  LOAD_DOUBLE_LINE(2, 3);
+  LOAD_DOUBLE_LINE(4, 5);
+  LOAD_DOUBLE_LINE(6, 7);
+#undef LOAD_DOUBLE_LINE
+
+  vector unsigned char tempA = vec_mergeh(src0, zero);
+  vector unsigned char tempB = vec_mergel(src0, zero);
+  vector unsigned char tempC = vec_mergeh(src1, zero);
+  vector unsigned char tempD = vec_mergel(src1, zero);
+  vector unsigned char tempE = vec_mergeh(src2, zero);
+  vector unsigned char tempF = vec_mergel(src2, zero);
+  vector unsigned char tempG = vec_mergeh(src3, zero);
+  vector unsigned char tempH = vec_mergel(src3, zero);
+  vector unsigned char tempI = vec_mergeh(src4, zero);
+  vector unsigned char tempJ = vec_mergel(src4, zero);
+  vector unsigned char tempK = vec_mergeh(src5, zero);
+  vector unsigned char tempL = vec_mergel(src5, zero);
+  vector unsigned char tempM = vec_mergeh(src6, zero);
+  vector unsigned char tempN = vec_mergel(src6, zero);
+  vector unsigned char tempO = vec_mergeh(src7, zero);
+  vector unsigned char tempP = vec_mergel(src7, zero);
+
+  vector unsigned char temp0 = vec_mergeh(tempA, tempI);
+  vector unsigned char temp1 = vec_mergel(tempA, tempI);
+  vector unsigned char temp2 = vec_mergeh(tempB, tempJ);
+  vector unsigned char temp3 = vec_mergel(tempB, tempJ);
+  vector unsigned char temp4 = vec_mergeh(tempC, tempK);
+  vector unsigned char temp5 = vec_mergel(tempC, tempK);
+  vector unsigned char temp6 = vec_mergeh(tempD, tempL);
+  vector unsigned char temp7 = vec_mergel(tempD, tempL);
+  vector unsigned char temp8 = vec_mergeh(tempE, tempM);
+  vector unsigned char temp9 = vec_mergel(tempE, tempM);
+  vector unsigned char temp10 = vec_mergeh(tempF, tempN);
+  vector unsigned char temp11 = vec_mergel(tempF, tempN);
+  vector unsigned char temp12 = vec_mergeh(tempG, tempO);
+  vector unsigned char temp13 = vec_mergel(tempG, tempO);
+  vector unsigned char temp14 = vec_mergeh(tempH, tempP);
+  vector unsigned char temp15 = vec_mergel(tempH, tempP);
+
+  tempA = vec_mergeh(temp0, temp8);
+  tempB = vec_mergel(temp0, temp8);
+  tempC = vec_mergeh(temp1, temp9);
+  tempD = vec_mergel(temp1, temp9);
+  tempE = vec_mergeh(temp2, temp10);
+  tempF = vec_mergel(temp2, temp10);
+  tempG = vec_mergeh(temp3, temp11);
+  tempH = vec_mergel(temp3, temp11);
+  tempI = vec_mergeh(temp4, temp12);
+  tempJ = vec_mergel(temp4, temp12);
+  tempK = vec_mergeh(temp5, temp13);
+  tempL = vec_mergel(temp5, temp13);
+  tempM = vec_mergeh(temp6, temp14);
+  tempN = vec_mergel(temp6, temp14);
+  tempO = vec_mergeh(temp7, temp15);
+  tempP = vec_mergel(temp7, temp15);
+
+  temp0 = vec_mergeh(tempA, tempI);
+  temp1 = vec_mergel(tempA, tempI);
+  temp2 = vec_mergeh(tempB, tempJ);
+  temp3 = vec_mergel(tempB, tempJ);
+  temp4 = vec_mergeh(tempC, tempK);
+  temp5 = vec_mergel(tempC, tempK);
+  temp6 = vec_mergeh(tempD, tempL);
+  temp7 = vec_mergel(tempD, tempL);
+  temp8 = vec_mergeh(tempE, tempM);
+  temp9 = vec_mergel(tempE, tempM);
+  temp10 = vec_mergeh(tempF, tempN);
+  temp11 = vec_mergel(tempF, tempN);
+  temp12 = vec_mergeh(tempG, tempO);
+  temp13 = vec_mergel(tempG, tempO);
+  temp14 = vec_mergeh(tempH, tempP);
+  temp15 = vec_mergel(tempH, tempP);
+
+  vec_st(temp0, 0, dst);
+  vec_st(temp1, 16, dst);
+  vec_st(temp2, 32, dst);
+  vec_st(temp3, 48, dst);
+  vec_st(temp4, 64, dst);
+  vec_st(temp5, 80, dst);
+  vec_st(temp6, 96, dst);
+  vec_st(temp7, 112, dst);
+  vec_st(temp8, 128, dst);
+  vec_st(temp9, 144, dst);
+  vec_st(temp10, 160, dst);
+  vec_st(temp11, 176, dst);
+  vec_st(temp12, 192, dst);
+  vec_st(temp13, 208, dst);
+  vec_st(temp14, 224, dst);
+  vec_st(temp15, 240, dst);
+}
+
+static inline void transpose_8x16_char_fromPackedAlign_altivec(unsigned char* dst, unsigned char* src, int stride) {
+  const vector unsigned char zero = vec_splat_u8(0);
+
+#define LOAD_DOUBLE_LINE(i, j)                                  \
+  vector unsigned char src##i = vec_ld(i * 16, src);            \
+  vector unsigned char src##j = vec_ld(j * 16, src)
+
+  LOAD_DOUBLE_LINE(0, 1);
+  LOAD_DOUBLE_LINE(2, 3);
+  LOAD_DOUBLE_LINE(4, 5);
+  LOAD_DOUBLE_LINE(6, 7);
+  LOAD_DOUBLE_LINE(8, 9);
+  LOAD_DOUBLE_LINE(10, 11);
+  LOAD_DOUBLE_LINE(12, 13);
+  LOAD_DOUBLE_LINE(14, 15);
+#undef LOAD_DOUBLE_LINE
+
+  vector unsigned char tempA = vec_mergeh(src0, src8);
+  vector unsigned char tempB;
+  vector unsigned char tempC = vec_mergeh(src1, src9);
+  vector unsigned char tempD;
+  vector unsigned char tempE = vec_mergeh(src2, src10);
+  vector unsigned char tempG = vec_mergeh(src3, src11);
+  vector unsigned char tempI = vec_mergeh(src4, src12);
+  vector unsigned char tempJ;
+  vector unsigned char tempK = vec_mergeh(src5, src13);
+  vector unsigned char tempL;
+  vector unsigned char tempM = vec_mergeh(src6, src14);
+  vector unsigned char tempO = vec_mergeh(src7, src15);
+
+  vector unsigned char temp0 = vec_mergeh(tempA, tempI);
+  vector unsigned char temp1 = vec_mergel(tempA, tempI);
+  vector unsigned char temp2;
+  vector unsigned char temp3;
+  vector unsigned char temp4 = vec_mergeh(tempC, tempK);
+  vector unsigned char temp5 = vec_mergel(tempC, tempK);
+  vector unsigned char temp6;
+  vector unsigned char temp7;
+  vector unsigned char temp8 = vec_mergeh(tempE, tempM);
+  vector unsigned char temp9 = vec_mergel(tempE, tempM);
+  vector unsigned char temp12 = vec_mergeh(tempG, tempO);
+  vector unsigned char temp13 = vec_mergel(tempG, tempO);
+
+  tempA = vec_mergeh(temp0, temp8);
+  tempB = vec_mergel(temp0, temp8);
+  tempC = vec_mergeh(temp1, temp9);
+  tempD = vec_mergel(temp1, temp9);
+  tempI = vec_mergeh(temp4, temp12);
+  tempJ = vec_mergel(temp4, temp12);
+  tempK = vec_mergeh(temp5, temp13);
+  tempL = vec_mergel(temp5, temp13);
+
+  temp0 = vec_mergeh(tempA, tempI);
+  temp1 = vec_mergel(tempA, tempI);
+  temp2 = vec_mergeh(tempB, tempJ);
+  temp3 = vec_mergel(tempB, tempJ);
+  temp4 = vec_mergeh(tempC, tempK);
+  temp5 = vec_mergel(tempC, tempK);
+  temp6 = vec_mergeh(tempD, tempL);
+  temp7 = vec_mergel(tempD, tempL);
+
+
+  const vector signed char neg1 = vec_splat_s8(-1);
+#define STORE_DOUBLE_LINE(i, j)                                         \
+  vector unsigned char dstA##i = vec_ld(i * stride, dst);               \
+  vector unsigned char dstB##i = vec_ld(i * stride + 16, dst);          \
+  vector unsigned char dstA##j = vec_ld(j * stride, dst);               \
+  vector unsigned char dstB##j = vec_ld(j * stride+ 16, dst);           \
+  vector unsigned char align##i = vec_lvsr(i * stride, dst);            \
+  vector unsigned char align##j = vec_lvsr(j * stride, dst);            \
+  vector unsigned char mask##i = vec_perm(zero, (vector unsigned char)neg1, align##i); \
+  vector unsigned char mask##j = vec_perm(zero, (vector unsigned char)neg1, align##j); \
+  vector unsigned char dstR##i = vec_perm(temp##i, temp##i, align##i);  \
+  vector unsigned char dstR##j = vec_perm(temp##j, temp##j, align##j);  \
+  vector unsigned char dstAF##i = vec_sel(dstA##i, dstR##i, mask##i);   \
+  vector unsigned char dstBF##i = vec_sel(dstR##i, dstB##i, mask##i);   \
+  vector unsigned char dstAF##j = vec_sel(dstA##j, dstR##j, mask##j);   \
+  vector unsigned char dstBF##j = vec_sel(dstR##j, dstB##j, mask##j);   \
+  vec_st(dstAF##i, i * stride, dst);                                    \
+  vec_st(dstBF##i, i * stride + 16, dst);                               \
+  vec_st(dstAF##j, j * stride, dst);                                    \
+  vec_st(dstBF##j, j * stride + 16, dst)
+
+  STORE_DOUBLE_LINE(0,1);
+  STORE_DOUBLE_LINE(2,3);
+  STORE_DOUBLE_LINE(4,5);
+  STORE_DOUBLE_LINE(6,7);
+}

Added: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_libpostproc/postprocess_internal.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_libpostproc/postprocess_internal.h	2007-05-27 18:44:33 UTC (rev 3157)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_libpostproc/postprocess_internal.h	2007-05-28 13:03:46 UTC (rev 3158)
@@ -0,0 +1,183 @@
+/*
+ * Copyright (C) 2001-2002 Michael Niedermayer (<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">michaelni at gmx.at</A>)
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+/**
+ * @file postprocess_internal.h
+ * internal api header.
+ */
+
+#include &quot;../ADM_lavutil/avutil.h&quot;
+
+#define V_DEBLOCK       0x01
+#define H_DEBLOCK       0x02
+#define DERING          0x04
+#define LEVEL_FIX       0x08 ///&lt; Brightness &amp; Contrast
+
+#define LUM_V_DEBLOCK   V_DEBLOCK               //   1
+#define LUM_H_DEBLOCK   H_DEBLOCK               //   2
+#define CHROM_V_DEBLOCK (V_DEBLOCK&lt;&lt;4)          //  16
+#define CHROM_H_DEBLOCK (H_DEBLOCK&lt;&lt;4)          //  32
+#define LUM_DERING      DERING                  //   4
+#define CHROM_DERING    (DERING&lt;&lt;4)             //  64
+#define LUM_LEVEL_FIX   LEVEL_FIX               //   8
+#define CHROM_LEVEL_FIX (LEVEL_FIX&lt;&lt;4)          // 128 (not implemented yet)
+
+// Experimental vertical filters
+#define V_X1_FILTER     0x0200                  // 512
+#define V_A_DEBLOCK     0x0400
+
+// Experimental horizontal filters
+#define H_X1_FILTER     0x2000                  // 8192
+#define H_A_DEBLOCK     0x4000
+
+/// select between full y range (255-0) or standart one (234-16)
+#define FULL_Y_RANGE    0x8000                  // 32768
+
+//Deinterlacing Filters
+#define        LINEAR_IPOL_DEINT_FILTER         0x10000 // 65536
+#define        LINEAR_BLEND_DEINT_FILTER        0x20000 // 131072
+#define        CUBIC_BLEND_DEINT_FILTER         0x8000  // (not implemented yet)
+#define        CUBIC_IPOL_DEINT_FILTER          0x40000 // 262144
+#define        MEDIAN_DEINT_FILTER              0x80000 // 524288
+#define        FFMPEG_DEINT_FILTER              0x400000
+#define        LOWPASS5_DEINT_FILTER            0x800000
+
+#define TEMP_NOISE_FILTER               0x100000
+#define FORCE_QUANT                     0x200000
+
+#if ( defined(__PIC__) || defined(__pic__) ) &amp;&amp; ! defined(PIC)
+#    define PIC
+#endif
+
+//use if u want a faster postprocessing code
+//cant differentiate between chroma &amp; luma filters (both on or both off)
+//obviosly the -pp option at the commandline has no effect except turning the here selected
+//filters on
+//#define COMPILE_TIME_MODE 0x77
+
+#if 1
+static inline int CLIP(int a){
+        if(a&amp;256) return ((a)&gt;&gt;31)^(-1);
+        else      return a;
+}
+//#define CLIP(a) (((a)&amp;256) ? ((a)&gt;&gt;31)^(-1) : (a))
+#elif 0
+#define CLIP(a) clip_tab[a]
+#else
+#define CLIP(a) (a)
+#endif
+/**
+ * Postprocessng filter.
+ */
+struct PPFilter{
+        const char *shortName;
+        const char *longName;
+        int chromDefault;       ///&lt; is chrominance filtering on by default if this filter is manually activated
+        int minLumQuality;      ///&lt; minimum quality to turn luminance filtering on
+        int minChromQuality;    ///&lt; minimum quality to turn chrominance filtering on
+        int mask;               ///&lt; Bitmask to turn this filter on
+};
+
+/**
+ * Postprocessng mode.
+ */
+typedef struct PPMode{
+        int lumMode;                    ///&lt; acivates filters for luminance
+        int chromMode;                  ///&lt; acivates filters for chrominance
+        int error;                      ///&lt; non zero on error
+
+        int minAllowedY;                ///&lt; for brigtness correction
+        int maxAllowedY;                ///&lt; for brihtness correction
+        float maxClippedThreshold;      ///&lt; amount of &quot;black&quot; u r willing to loose to get a brightness corrected picture
+
+        int maxTmpNoise[3];             ///&lt; for Temporal Noise Reducing filter (Maximal sum of abs differences)
+
+        int baseDcDiff;
+        int flatnessThreshold;
+
+        int forcedQuant;                ///&lt; quantizer if FORCE_QUANT is used
+} PPMode;
+
+/**
+ * postprocess context.
+ */
+typedef struct PPContext{
+        /**
+         * info on struct for av_log
+         */
+        AVClass *av_class;
+
+        uint8_t *tempBlocks; ///&lt;used for the horizontal code
+
+        /**
+         * luma histogram.
+         * we need 64bit here otherwise we'll going to have a problem
+         * after watching a black picture for 5 hours
+         */
+        uint64_t *yHistogram;
+
+        DECLARE_ALIGNED(8, uint64_t, packedYOffset);
+        DECLARE_ALIGNED(8, uint64_t, packedYScale);
+
+        /** Temporal noise reducing buffers */
+        uint8_t *tempBlured[3];
+        int32_t *tempBluredPast[3];
+
+        /** Temporary buffers for handling the last row(s) */
+        uint8_t *tempDst;
+        uint8_t *tempSrc;
+
+        uint8_t *deintTemp;
+
+        DECLARE_ALIGNED(8, uint64_t, pQPb);
+        DECLARE_ALIGNED(8, uint64_t, pQPb2);
+
+        DECLARE_ALIGNED(8, uint64_t, mmxDcOffset[64]);
+        DECLARE_ALIGNED(8, uint64_t, mmxDcThreshold[64]);
+
+        QP_STORE_T *stdQPTable;       ///&lt; used to fix MPEG2 style qscale
+        QP_STORE_T *nonBQPTable;
+        QP_STORE_T *forcedQPTable;
+
+        int QP;
+        int nonBQP;
+
+        int frameNum;
+
+        int cpuCaps;
+
+        int qpStride; ///&lt;size of qp buffers (needed to realloc them if needed)
+        int stride;   ///&lt;size of some buffers (needed to realloc them if needed)
+
+        int hChromaSubSample;
+        int vChromaSubSample;
+
+        PPMode ppMode;
+} PPContext;
+
+
+static inline void linecpy(void *dest, void *src, int lines, int stride)
+{
+        if (stride &gt; 0) {
+                memcpy(dest, src, lines*stride);
+        } else {
+                memcpy(dest+(lines-1)*stride, src+(lines-1)*stride, -lines*stride);
+        }
+}

Added: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_libpostproc/postprocess_template.c
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_libpostproc/postprocess_template.c	2007-05-27 18:44:33 UTC (rev 3157)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_libpostproc/postprocess_template.c	2007-05-28 13:03:46 UTC (rev 3158)
@@ -0,0 +1,3843 @@
+/*
+ * Copyright (C) 2001-2002 Michael Niedermayer (<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">michaelni at gmx.at</A>)
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+*/
+
+/**
+ * @file postprocess_template.c
+ * mmx/mmx2/3dnow postprocess code.
+ */
+
+
+#ifdef ARCH_X86_64
+#  define REGa  rax
+#  define REGc  rcx
+#  define REGd  rdx
+#  define REG_a  &quot;rax&quot;
+#  define REG_c  &quot;rcx&quot;
+#  define REG_d  &quot;rdx&quot;
+#  define REG_SP &quot;rsp&quot;
+#  define ALIGN_MASK &quot;$0xFFFFFFFFFFFFFFF8&quot;
+#else
+#  define REGa  eax
+#  define REGc  ecx
+#  define REGd  edx
+#  define REG_a  &quot;eax&quot;
+#  define REG_c  &quot;ecx&quot;
+#  define REG_d  &quot;edx&quot;
+#  define REG_SP &quot;esp&quot;
+#  define ALIGN_MASK &quot;$0xFFFFFFF8&quot;
+#endif
+
+
+#undef PAVGB
+#undef PMINUB
+#undef PMAXUB
+
+#ifdef HAVE_MMX2
+#define REAL_PAVGB(a,b) &quot;pavgb &quot; #a &quot;, &quot; #b &quot; \n\t&quot;
+#elif defined (HAVE_3DNOW)
+#define REAL_PAVGB(a,b) &quot;pavgusb &quot; #a &quot;, &quot; #b &quot; \n\t&quot;
+#endif
+#define PAVGB(a,b)  REAL_PAVGB(a,b)
+
+#ifdef HAVE_MMX2
+#define PMINUB(a,b,t) &quot;pminub &quot; #a &quot;, &quot; #b &quot; \n\t&quot;
+#elif defined (HAVE_MMX)
+#define PMINUB(b,a,t) \
+        &quot;movq &quot; #a &quot;, &quot; #t &quot; \n\t&quot;\
+        &quot;psubusb &quot; #b &quot;, &quot; #t &quot; \n\t&quot;\
+        &quot;psubb &quot; #t &quot;, &quot; #a &quot; \n\t&quot;
+#endif
+
+#ifdef HAVE_MMX2
+#define PMAXUB(a,b) &quot;pmaxub &quot; #a &quot;, &quot; #b &quot; \n\t&quot;
+#elif defined (HAVE_MMX)
+#define PMAXUB(a,b) \
+        &quot;psubusb &quot; #a &quot;, &quot; #b &quot; \n\t&quot;\
+        &quot;paddb &quot; #a &quot;, &quot; #b &quot; \n\t&quot;
+#endif
+
+//FIXME? |255-0| = 1 (shouldnt be a problem ...)
+#ifdef HAVE_MMX
+/**
+ * Check if the middle 8x8 Block in the given 8x16 block is flat
+ */
+static inline int RENAME(vertClassify)(uint8_t src[], int stride, PPContext *c){
+        int numEq= 0, dcOk;
+        src+= stride*4; // src points to begin of the 8x8 Block
+asm volatile(
+                &quot;movq %0, %%mm7                         \n\t&quot;
+                &quot;movq %1, %%mm6                         \n\t&quot;
+                : : &quot;m&quot; (c-&gt;mmxDcOffset[c-&gt;nonBQP]),  &quot;m&quot; (c-&gt;mmxDcThreshold[c-&gt;nonBQP])
+                );
+
+asm volatile(
+                &quot;lea (%2, %3), %%&quot;REG_a&quot;                \n\t&quot;
+//      0       1       2       3       4       5       6       7       8       9
+//      %1      eax     eax+%2  eax+2%2 %1+4%2  ecx     ecx+%2  ecx+2%2 %1+8%2  ecx+4%2
+
+                &quot;movq (%2), %%mm0                       \n\t&quot;
+                &quot;movq (%%&quot;REG_a&quot;), %%mm1                \n\t&quot;
+                &quot;movq %%mm0, %%mm3                      \n\t&quot;
+                &quot;movq %%mm0, %%mm4                      \n\t&quot;
+                PMAXUB(%%mm1, %%mm4)
+                PMINUB(%%mm1, %%mm3, %%mm5)
+                &quot;psubb %%mm1, %%mm0                     \n\t&quot; // mm0 = differnece
+                &quot;paddb %%mm7, %%mm0                     \n\t&quot;
+                &quot;pcmpgtb %%mm6, %%mm0                   \n\t&quot;
+
+                &quot;movq (%%&quot;REG_a&quot;,%3), %%mm2             \n\t&quot;
+                PMAXUB(%%mm2, %%mm4)
+                PMINUB(%%mm2, %%mm3, %%mm5)
+                &quot;psubb %%mm2, %%mm1                     \n\t&quot;
+                &quot;paddb %%mm7, %%mm1                     \n\t&quot;
+                &quot;pcmpgtb %%mm6, %%mm1                   \n\t&quot;
+                &quot;paddb %%mm1, %%mm0                     \n\t&quot;
+
+                &quot;movq (%%&quot;REG_a&quot;, %3, 2), %%mm1         \n\t&quot;
+                PMAXUB(%%mm1, %%mm4)
+                PMINUB(%%mm1, %%mm3, %%mm5)
+                &quot;psubb %%mm1, %%mm2                     \n\t&quot;
+                &quot;paddb %%mm7, %%mm2                     \n\t&quot;
+                &quot;pcmpgtb %%mm6, %%mm2                   \n\t&quot;
+                &quot;paddb %%mm2, %%mm0                     \n\t&quot;
+
+                &quot;lea (%%&quot;REG_a&quot;, %3, 4), %%&quot;REG_a&quot;      \n\t&quot;
+
+                &quot;movq (%2, %3, 4), %%mm2                \n\t&quot;
+                PMAXUB(%%mm2, %%mm4)
+                PMINUB(%%mm2, %%mm3, %%mm5)
+                &quot;psubb %%mm2, %%mm1                     \n\t&quot;
+                &quot;paddb %%mm7, %%mm1                     \n\t&quot;
+                &quot;pcmpgtb %%mm6, %%mm1                   \n\t&quot;
+                &quot;paddb %%mm1, %%mm0                     \n\t&quot;
+
+                &quot;movq (%%&quot;REG_a&quot;), %%mm1                \n\t&quot;
+                PMAXUB(%%mm1, %%mm4)
+                PMINUB(%%mm1, %%mm3, %%mm5)
+                &quot;psubb %%mm1, %%mm2                     \n\t&quot;
+                &quot;paddb %%mm7, %%mm2                     \n\t&quot;
+                &quot;pcmpgtb %%mm6, %%mm2                   \n\t&quot;
+                &quot;paddb %%mm2, %%mm0                     \n\t&quot;
+
+                &quot;movq (%%&quot;REG_a&quot;, %3), %%mm2            \n\t&quot;
+                PMAXUB(%%mm2, %%mm4)
+                PMINUB(%%mm2, %%mm3, %%mm5)
+                &quot;psubb %%mm2, %%mm1                     \n\t&quot;
+                &quot;paddb %%mm7, %%mm1                     \n\t&quot;
+                &quot;pcmpgtb %%mm6, %%mm1                   \n\t&quot;
+                &quot;paddb %%mm1, %%mm0                     \n\t&quot;
+
+                &quot;movq (%%&quot;REG_a&quot;, %3, 2), %%mm1         \n\t&quot;
+                PMAXUB(%%mm1, %%mm4)
+                PMINUB(%%mm1, %%mm3, %%mm5)
+                &quot;psubb %%mm1, %%mm2                     \n\t&quot;
+                &quot;paddb %%mm7, %%mm2                     \n\t&quot;
+                &quot;pcmpgtb %%mm6, %%mm2                   \n\t&quot;
+                &quot;paddb %%mm2, %%mm0                     \n\t&quot;
+                &quot;psubusb %%mm3, %%mm4                   \n\t&quot;
+
+                &quot;                                       \n\t&quot;
+#ifdef HAVE_MMX2
+                &quot;pxor %%mm7, %%mm7                      \n\t&quot;
+                &quot;psadbw %%mm7, %%mm0                    \n\t&quot;
+#else
+                &quot;movq %%mm0, %%mm1                      \n\t&quot;
+                &quot;psrlw $8, %%mm0                        \n\t&quot;
+                &quot;paddb %%mm1, %%mm0                     \n\t&quot;
+                &quot;movq %%mm0, %%mm1                      \n\t&quot;
+                &quot;psrlq $16, %%mm0                       \n\t&quot;
+                &quot;paddb %%mm1, %%mm0                     \n\t&quot;
+                &quot;movq %%mm0, %%mm1                      \n\t&quot;
+                &quot;psrlq $32, %%mm0                       \n\t&quot;
+                &quot;paddb %%mm1, %%mm0                     \n\t&quot;
+#endif
+                &quot;movq %4, %%mm7                         \n\t&quot; // QP,..., QP
+                &quot;paddusb %%mm7, %%mm7                   \n\t&quot; // 2QP ... 2QP
+                &quot;psubusb %%mm7, %%mm4                   \n\t&quot; // Diff &lt;= 2QP -&gt; 0
+                &quot;packssdw %%mm4, %%mm4                  \n\t&quot;
+                &quot;movd %%mm0, %0                         \n\t&quot;
+                &quot;movd %%mm4, %1                         \n\t&quot;
+
+                : &quot;=r&quot; (numEq), &quot;=r&quot; (dcOk)
+                : &quot;r&quot; (src), &quot;r&quot; ((long)stride), &quot;m&quot; (c-&gt;pQPb)
+                : &quot;%&quot;REG_a
+                );
+
+        numEq= (-numEq) &amp;0xFF;
+        if(numEq &gt; c-&gt;ppMode.flatnessThreshold){
+            if(dcOk) return 0;
+            else     return 1;
+        }else{
+            return 2;
+        }
+}
+#endif //HAVE_MMX
+
+/**
+ * Do a vertical low pass filter on the 8x16 block (only write to the 8x8 block in the middle)
+ * using the 9-Tap Filter (1,1,2,2,4,2,2,1,1)/16
+ */
+#ifndef HAVE_ALTIVEC
+static inline void RENAME(doVertLowPass)(uint8_t *src, int stride, PPContext *c)
+{
+#if defined (HAVE_MMX2) || defined (HAVE_3DNOW)
+        src+= stride*3;
+        asm volatile(        //&quot;movv %0 %1 %2\n\t&quot;
+                &quot;movq %2, %%mm0                         \n\t&quot;  // QP,..., QP
+                &quot;pxor %%mm4, %%mm4                      \n\t&quot;
+
+                &quot;movq (%0), %%mm6                       \n\t&quot;
+                &quot;movq (%0, %1), %%mm5                   \n\t&quot;
+                &quot;movq %%mm5, %%mm1                      \n\t&quot;
+                &quot;movq %%mm6, %%mm2                      \n\t&quot;
+                &quot;psubusb %%mm6, %%mm5                   \n\t&quot;
+                &quot;psubusb %%mm1, %%mm2                   \n\t&quot;
+                &quot;por %%mm5, %%mm2                       \n\t&quot; // ABS Diff of lines
+                &quot;psubusb %%mm0, %%mm2                   \n\t&quot; // diff &lt;= QP -&gt; 0
+                &quot;pcmpeqb %%mm4, %%mm2                   \n\t&quot; // diff &lt;= QP -&gt; FF
+
+                &quot;pand %%mm2, %%mm6                      \n\t&quot;
+                &quot;pandn %%mm1, %%mm2                     \n\t&quot;
+                &quot;por %%mm2, %%mm6                       \n\t&quot;// First Line to Filter
+
+                &quot;movq (%0, %1, 8), %%mm5                \n\t&quot;
+                &quot;lea (%0, %1, 4), %%&quot;REG_a&quot;             \n\t&quot;
+                &quot;lea (%0, %1, 8), %%&quot;REG_c&quot;             \n\t&quot;
+                &quot;sub %1, %%&quot;REG_c&quot;                      \n\t&quot;
+                &quot;add %1, %0                             \n\t&quot; // %0 points to line 1 not 0
+                &quot;movq (%0, %1, 8), %%mm7                \n\t&quot;
+                &quot;movq %%mm5, %%mm1                      \n\t&quot;
+                &quot;movq %%mm7, %%mm2                      \n\t&quot;
+                &quot;psubusb %%mm7, %%mm5                   \n\t&quot;
+                &quot;psubusb %%mm1, %%mm2                   \n\t&quot;
+                &quot;por %%mm5, %%mm2                       \n\t&quot; // ABS Diff of lines
+                &quot;psubusb %%mm0, %%mm2                   \n\t&quot; // diff &lt;= QP -&gt; 0
+                &quot;pcmpeqb %%mm4, %%mm2                   \n\t&quot; // diff &lt;= QP -&gt; FF
+
+                &quot;pand %%mm2, %%mm7                      \n\t&quot;
+                &quot;pandn %%mm1, %%mm2                     \n\t&quot;
+                &quot;por %%mm2, %%mm7                       \n\t&quot; // First Line to Filter
+
+
+                //      1       2       3       4       5       6       7       8
+                //      %0      %0+%1   %0+2%1  eax     %0+4%1  eax+2%1 ecx     eax+4%1
+                // 6 4 2 2 1 1
+                // 6 4 4 2
+                // 6 8 2
+
+                &quot;movq (%0, %1), %%mm0                   \n\t&quot; //  1
+                &quot;movq %%mm0, %%mm1                      \n\t&quot; //  1
+                PAVGB(%%mm6, %%mm0)                           //1 1        /2
+                PAVGB(%%mm6, %%mm0)                           //3 1        /4
+
+                &quot;movq (%0, %1, 4), %%mm2                \n\t&quot; //     1
+                &quot;movq %%mm2, %%mm5                      \n\t&quot; //     1
+                PAVGB((%%REGa), %%mm2)                        //    11        /2
+                PAVGB((%0, %1, 2), %%mm2)                     //   211        /4
+                &quot;movq %%mm2, %%mm3                      \n\t&quot; //   211        /4
+                &quot;movq (%0), %%mm4                       \n\t&quot; // 1
+                PAVGB(%%mm4, %%mm3)                           // 4 211        /8
+                PAVGB(%%mm0, %%mm3)                           //642211        /16
+                &quot;movq %%mm3, (%0)                       \n\t&quot; // X
+                // mm1=2 mm2=3(211) mm4=1 mm5=5 mm6=0 mm7=9
+                &quot;movq %%mm1, %%mm0                      \n\t&quot; //  1
+                PAVGB(%%mm6, %%mm0)                           //1 1        /2
+                &quot;movq %%mm4, %%mm3                      \n\t&quot; // 1
+                PAVGB((%0,%1,2), %%mm3)                       // 1 1        /2
+                PAVGB((%%REGa,%1,2), %%mm5)                   //     11        /2
+                PAVGB((%%REGa), %%mm5)                        //    211 /4
+                PAVGB(%%mm5, %%mm3)                           // 2 2211 /8
+                PAVGB(%%mm0, %%mm3)                           //4242211 /16
+                &quot;movq %%mm3, (%0,%1)                    \n\t&quot; //  X
+                // mm1=2 mm2=3(211) mm4=1 mm5=4(211) mm6=0 mm7=9
+                PAVGB(%%mm4, %%mm6)                                   //11        /2
+                &quot;movq (%%&quot;REG_c&quot;), %%mm0                \n\t&quot; //       1
+                PAVGB((%%REGa, %1, 2), %%mm0)                 //      11/2
+                &quot;movq %%mm0, %%mm3                      \n\t&quot; //      11/2
+                PAVGB(%%mm1, %%mm0)                           //  2   11/4
+                PAVGB(%%mm6, %%mm0)                           //222   11/8
+                PAVGB(%%mm2, %%mm0)                           //22242211/16
+                &quot;movq (%0, %1, 2), %%mm2                \n\t&quot; //   1
+                &quot;movq %%mm0, (%0, %1, 2)                \n\t&quot; //   X
+                // mm1=2 mm2=3 mm3=6(11) mm4=1 mm5=4(211) mm6=0(11) mm7=9
+                &quot;movq (%%&quot;REG_a&quot;, %1, 4), %%mm0         \n\t&quot; //        1
+                PAVGB((%%REGc), %%mm0)                        //       11        /2
+                PAVGB(%%mm0, %%mm6)                           //11     11        /4
+                PAVGB(%%mm1, %%mm4)                           // 11                /2
+                PAVGB(%%mm2, %%mm1)                           //  11                /2
+                PAVGB(%%mm1, %%mm6)                           //1122   11        /8
+                PAVGB(%%mm5, %%mm6)                           //112242211        /16
+                &quot;movq (%%&quot;REG_a&quot;), %%mm5                \n\t&quot; //    1
+                &quot;movq %%mm6, (%%&quot;REG_a&quot;)                \n\t&quot; //    X
+                // mm0=7(11) mm1=2(11) mm2=3 mm3=6(11) mm4=1(11) mm5=4 mm7=9
+                &quot;movq (%%&quot;REG_a&quot;, %1, 4), %%mm6         \n\t&quot; //        1
+                PAVGB(%%mm7, %%mm6)                           //        11        /2
+                PAVGB(%%mm4, %%mm6)                           // 11     11        /4
+                PAVGB(%%mm3, %%mm6)                           // 11   2211        /8
+                PAVGB(%%mm5, %%mm2)                           //   11                /2
+                &quot;movq (%0, %1, 4), %%mm4                \n\t&quot; //     1
+                PAVGB(%%mm4, %%mm2)                           //   112                /4
+                PAVGB(%%mm2, %%mm6)                           // 112242211        /16
+                &quot;movq %%mm6, (%0, %1, 4)                \n\t&quot; //     X
+                // mm0=7(11) mm1=2(11) mm2=3(112) mm3=6(11) mm4=5 mm5=4 mm7=9
+                PAVGB(%%mm7, %%mm1)                           //  11     2        /4
+                PAVGB(%%mm4, %%mm5)                           //    11                /2
+                PAVGB(%%mm5, %%mm0)                           //    11 11        /4
+                &quot;movq (%%&quot;REG_a&quot;, %1, 2), %%mm6         \n\t&quot; //      1
+                PAVGB(%%mm6, %%mm1)                           //  11  4  2        /8
+                PAVGB(%%mm0, %%mm1)                           //  11224222        /16
+                &quot;movq %%mm1, (%%&quot;REG_a&quot;, %1, 2)         \n\t&quot; //      X
+                // mm2=3(112) mm3=6(11) mm4=5 mm5=4(11) mm6=6 mm7=9
+                PAVGB((%%REGc), %%mm2)                        //   112 4        /8
+                &quot;movq (%%&quot;REG_a&quot;, %1, 4), %%mm0         \n\t&quot; //        1
+                PAVGB(%%mm0, %%mm6)                           //      1 1        /2
+                PAVGB(%%mm7, %%mm6)                           //      1 12        /4
+                PAVGB(%%mm2, %%mm6)                           //   1122424        /4
+                &quot;movq %%mm6, (%%&quot;REG_c&quot;)                \n\t&quot; //       X
+                // mm0=8 mm3=6(11) mm4=5 mm5=4(11) mm7=9
+                PAVGB(%%mm7, %%mm5)                           //    11   2        /4
+                PAVGB(%%mm7, %%mm5)                           //    11   6        /8
+
+                PAVGB(%%mm3, %%mm0)                           //      112        /4
+                PAVGB(%%mm0, %%mm5)                           //    112246        /16
+                &quot;movq %%mm5, (%%&quot;REG_a&quot;, %1, 4)         \n\t&quot; //        X
+                &quot;sub %1, %0                             \n\t&quot;
+
+                :
+                : &quot;r&quot; (src), &quot;r&quot; ((long)stride), &quot;m&quot; (c-&gt;pQPb)
+                : &quot;%&quot;REG_a, &quot;%&quot;REG_c
+        );
+#else //defined (HAVE_MMX2) || defined (HAVE_3DNOW)
+        const int l1= stride;
+        const int l2= stride + l1;
+        const int l3= stride + l2;
+        const int l4= stride + l3;
+        const int l5= stride + l4;
+        const int l6= stride + l5;
+        const int l7= stride + l6;
+        const int l8= stride + l7;
+        const int l9= stride + l8;
+        int x;
+        src+= stride*3;
+        for(x=0; x&lt;BLOCK_SIZE; x++)
+        {
+                const int first= FFABS(src[0] - src[l1]) &lt; c-&gt;QP ? src[0] : src[l1];
+                const int last= FFABS(src[l8] - src[l9]) &lt; c-&gt;QP ? src[l9] : src[l8];
+
+                int sums[10];
+                sums[0] = 4*first + src[l1] + src[l2] + src[l3] + 4;
+                sums[1] = sums[0] - first  + src[l4];
+                sums[2] = sums[1] - first  + src[l5];
+                sums[3] = sums[2] - first  + src[l6];
+                sums[4] = sums[3] - first  + src[l7];
+                sums[5] = sums[4] - src[l1] + src[l8];
+                sums[6] = sums[5] - src[l2] + last;
+                sums[7] = sums[6] - src[l3] + last;
+                sums[8] = sums[7] - src[l4] + last;
+                sums[9] = sums[8] - src[l5] + last;
+
+                src[l1]= (sums[0] + sums[2] + 2*src[l1])&gt;&gt;4;
+                src[l2]= (sums[1] + sums[3] + 2*src[l2])&gt;&gt;4;
+                src[l3]= (sums[2] + sums[4] + 2*src[l3])&gt;&gt;4;
+                src[l4]= (sums[3] + sums[5] + 2*src[l4])&gt;&gt;4;
+                src[l5]= (sums[4] + sums[6] + 2*src[l5])&gt;&gt;4;
+                src[l6]= (sums[5] + sums[7] + 2*src[l6])&gt;&gt;4;
+                src[l7]= (sums[6] + sums[8] + 2*src[l7])&gt;&gt;4;
+                src[l8]= (sums[7] + sums[9] + 2*src[l8])&gt;&gt;4;
+
+                src++;
+        }
+#endif //defined (HAVE_MMX2) || defined (HAVE_3DNOW)
+}
+#endif //HAVE_ALTIVEC
+
+#if 0
+/**
+ * Experimental implementation of the filter (Algorithm 1) described in a paper from Ramkishor &amp; Karandikar
+ * values are correctly clipped (MMX2)
+ * values are wraparound (C)
+ * conclusion: its fast, but introduces ugly horizontal patterns if there is a continious gradient
+        0 8 16 24
+        x = 8
+        x/2 = 4
+        x/8 = 1
+        1 12 12 23
+ */
+static inline void RENAME(vertRK1Filter)(uint8_t *src, int stride, int QP)
+{
+#if defined (HAVE_MMX2) || defined (HAVE_3DNOW)
+        src+= stride*3;
+// FIXME rounding
+        asm volatile(
+                &quot;pxor %%mm7, %%mm7                      \n\t&quot; // 0
+                &quot;movq &quot;MANGLE(b80)&quot;, %%mm6              \n\t&quot; // MIN_SIGNED_BYTE
+                &quot;leal (%0, %1), %%&quot;REG_a&quot;               \n\t&quot;
+                &quot;leal (%%&quot;REG_a&quot;, %1, 4), %%&quot;REG_c&quot;     \n\t&quot;
+//      0       1       2       3       4       5       6       7       8       9
+//      %0      eax     eax+%1  eax+2%1 %0+4%1  ecx     ecx+%1  ecx+2%1 %0+8%1  ecx+4%1
+                &quot;movq &quot;MANGLE(pQPb)&quot;, %%mm0             \n\t&quot; // QP,..., QP
+                &quot;movq %%mm0, %%mm1                      \n\t&quot; // QP,..., QP
+                &quot;paddusb &quot;MANGLE(b02)&quot;, %%mm0           \n\t&quot;
+                &quot;psrlw $2, %%mm0                        \n\t&quot;
+                &quot;pand &quot;MANGLE(b3F)&quot;, %%mm0              \n\t&quot; // QP/4,..., QP/4
+                &quot;paddusb %%mm1, %%mm0                   \n\t&quot; // QP*1.25 ...
+                &quot;movq (%0, %1, 4), %%mm2                \n\t&quot; // line 4
+                &quot;movq (%%&quot;REG_c&quot;), %%mm3                \n\t&quot; // line 5
+                &quot;movq %%mm2, %%mm4                      \n\t&quot; // line 4
+                &quot;pcmpeqb %%mm5, %%mm5                   \n\t&quot; // -1
+                &quot;pxor %%mm2, %%mm5                      \n\t&quot; // -line 4 - 1
+                PAVGB(%%mm3, %%mm5)
+                &quot;paddb %%mm6, %%mm5                     \n\t&quot; // (l5-l4)/2
+                &quot;psubusb %%mm3, %%mm4                   \n\t&quot;
+                &quot;psubusb %%mm2, %%mm3                   \n\t&quot;
+                &quot;por %%mm3, %%mm4                       \n\t&quot; // |l4 - l5|
+                &quot;psubusb %%mm0, %%mm4                   \n\t&quot;
+                &quot;pcmpeqb %%mm7, %%mm4                   \n\t&quot;
+                &quot;pand %%mm4, %%mm5                      \n\t&quot; // d/2
+
+//                &quot;paddb %%mm6, %%mm2                     \n\t&quot; // line 4 + 0x80
+                &quot;paddb %%mm5, %%mm2                     \n\t&quot;
+//                &quot;psubb %%mm6, %%mm2                     \n\t&quot;
+                &quot;movq %%mm2, (%0,%1, 4)                 \n\t&quot;
+
+                &quot;movq (%%&quot;REG_c&quot;), %%mm2                \n\t&quot;
+//                &quot;paddb %%mm6, %%mm2                     \n\t&quot; // line 5 + 0x80
+                &quot;psubb %%mm5, %%mm2                     \n\t&quot;
+//                &quot;psubb %%mm6, %%mm2                     \n\t&quot;
+                &quot;movq %%mm2, (%%&quot;REG_c&quot;)                \n\t&quot;
+
+                &quot;paddb %%mm6, %%mm5                     \n\t&quot;
+                &quot;psrlw $2, %%mm5                        \n\t&quot;
+                &quot;pand &quot;MANGLE(b3F)&quot;, %%mm5              \n\t&quot;
+                &quot;psubb &quot;MANGLE(b20)&quot;, %%mm5             \n\t&quot; // (l5-l4)/8
+
+                &quot;movq (%%&quot;REG_a&quot;, %1, 2), %%mm2         \n\t&quot;
+                &quot;paddb %%mm6, %%mm2                     \n\t&quot; // line 3 + 0x80
+                &quot;paddsb %%mm5, %%mm2                    \n\t&quot;
+                &quot;psubb %%mm6, %%mm2                     \n\t&quot;
+                &quot;movq %%mm2, (%%&quot;REG_a&quot;, %1, 2)         \n\t&quot;
+
+                &quot;movq (%%&quot;REG_c&quot;, %1), %%mm2            \n\t&quot;
+                &quot;paddb %%mm6, %%mm2                     \n\t&quot; // line 6 + 0x80
+                &quot;psubsb %%mm5, %%mm2                    \n\t&quot;
+                &quot;psubb %%mm6, %%mm2                     \n\t&quot;
+                &quot;movq %%mm2, (%%&quot;REG_c&quot;, %1)            \n\t&quot;
+
+                :
+                : &quot;r&quot; (src), &quot;r&quot; ((long)stride)
+                : &quot;%&quot;REG_a, &quot;%&quot;REG_c
+        );
+#else //defined (HAVE_MMX2) || defined (HAVE_3DNOW)
+         const int l1= stride;
+        const int l2= stride + l1;
+        const int l3= stride + l2;
+        const int l4= stride + l3;
+        const int l5= stride + l4;
+        const int l6= stride + l5;
+//        const int l7= stride + l6;
+//        const int l8= stride + l7;
+//        const int l9= stride + l8;
+        int x;
+        const int QP15= QP + (QP&gt;&gt;2);
+        src+= stride*3;
+        for(x=0; x&lt;BLOCK_SIZE; x++)
+        {
+                const int v = (src[x+l5] - src[x+l4]);
+                if(FFABS(v) &lt; QP15)
+                {
+                        src[x+l3] +=v&gt;&gt;3;
+                        src[x+l4] +=v&gt;&gt;1;
+                        src[x+l5] -=v&gt;&gt;1;
+                        src[x+l6] -=v&gt;&gt;3;
+
+                }
+        }
+
+#endif //defined (HAVE_MMX2) || defined (HAVE_3DNOW)
+}
+#endif //0
+
+/**
+ * Experimental Filter 1
+ * will not damage linear gradients
+ * Flat blocks should look like they where passed through the (1,1,2,2,4,2,2,1,1) 9-Tap filter
+ * can only smooth blocks at the expected locations (it cant smooth them if they did move)
+ * MMX2 version does correct clipping C version doesnt
+ */
+static inline void RENAME(vertX1Filter)(uint8_t *src, int stride, PPContext *co)
+{
+#if defined (HAVE_MMX2) || defined (HAVE_3DNOW)
+        src+= stride*3;
+
+        asm volatile(
+                &quot;pxor %%mm7, %%mm7                      \n\t&quot; // 0
+                &quot;lea (%0, %1), %%&quot;REG_a&quot;                \n\t&quot;
+                &quot;lea (%%&quot;REG_a&quot;, %1, 4), %%&quot;REG_c&quot;      \n\t&quot;
+//      0       1       2       3       4       5       6       7       8       9
+//      %0      eax     eax+%1  eax+2%1 %0+4%1  ecx     ecx+%1  ecx+2%1 %0+8%1  ecx+4%1
+                &quot;movq (%%&quot;REG_a&quot;, %1, 2), %%mm0         \n\t&quot; // line 3
+                &quot;movq (%0, %1, 4), %%mm1                \n\t&quot; // line 4
+                &quot;movq %%mm1, %%mm2                      \n\t&quot; // line 4
+                &quot;psubusb %%mm0, %%mm1                   \n\t&quot;
+                &quot;psubusb %%mm2, %%mm0                   \n\t&quot;
+                &quot;por %%mm1, %%mm0                       \n\t&quot; // |l2 - l3|
+                &quot;movq (%%&quot;REG_c&quot;), %%mm3                \n\t&quot; // line 5
+                &quot;movq (%%&quot;REG_c&quot;, %1), %%mm4            \n\t&quot; // line 6
+                &quot;movq %%mm3, %%mm5                      \n\t&quot; // line 5
+                &quot;psubusb %%mm4, %%mm3                   \n\t&quot;
+                &quot;psubusb %%mm5, %%mm4                   \n\t&quot;
+                &quot;por %%mm4, %%mm3                       \n\t&quot; // |l5 - l6|
+                PAVGB(%%mm3, %%mm0)                           // (|l2 - l3| + |l5 - l6|)/2
+                &quot;movq %%mm2, %%mm1                      \n\t&quot; // line 4
+                &quot;psubusb %%mm5, %%mm2                   \n\t&quot;
+                &quot;movq %%mm2, %%mm4                      \n\t&quot;
+                &quot;pcmpeqb %%mm7, %%mm2                   \n\t&quot; // (l4 - l5) &lt;= 0 ? -1 : 0
+                &quot;psubusb %%mm1, %%mm5                   \n\t&quot;
+                &quot;por %%mm5, %%mm4                       \n\t&quot; // |l4 - l5|
+                &quot;psubusb %%mm0, %%mm4                   \n\t&quot; //d = MAX(0, |l4-l5| - (|l2-l3| + |l5-l6|)/2)
+                &quot;movq %%mm4, %%mm3                      \n\t&quot; // d
+                &quot;movq %2, %%mm0                         \n\t&quot;
+                &quot;paddusb %%mm0, %%mm0                   \n\t&quot;
+                &quot;psubusb %%mm0, %%mm4                   \n\t&quot;
+                &quot;pcmpeqb %%mm7, %%mm4                   \n\t&quot; // d &lt;= QP ? -1 : 0
+                &quot;psubusb &quot;MANGLE(b01)&quot;, %%mm3           \n\t&quot;
+                &quot;pand %%mm4, %%mm3                      \n\t&quot; // d &lt;= QP ? d : 0
+
+                PAVGB(%%mm7, %%mm3)                           // d/2
+                &quot;movq %%mm3, %%mm1                      \n\t&quot; // d/2
+                PAVGB(%%mm7, %%mm3)                           // d/4
+                PAVGB(%%mm1, %%mm3)                           // 3*d/8
+
+                &quot;movq (%0, %1, 4), %%mm0                \n\t&quot; // line 4
+                &quot;pxor %%mm2, %%mm0                      \n\t&quot; //(l4 - l5) &lt;= 0 ? -l4-1 : l4
+                &quot;psubusb %%mm3, %%mm0                   \n\t&quot;
+                &quot;pxor %%mm2, %%mm0                      \n\t&quot;
+                &quot;movq %%mm0, (%0, %1, 4)                \n\t&quot; // line 4
+
+                &quot;movq (%%&quot;REG_c&quot;), %%mm0                \n\t&quot; // line 5
+                &quot;pxor %%mm2, %%mm0                      \n\t&quot; //(l4 - l5) &lt;= 0 ? -l5-1 : l5
+                &quot;paddusb %%mm3, %%mm0                   \n\t&quot;
+                &quot;pxor %%mm2, %%mm0                      \n\t&quot;
+                &quot;movq %%mm0, (%%&quot;REG_c&quot;)                \n\t&quot; // line 5
+
+                PAVGB(%%mm7, %%mm1)                           // d/4
+
+                &quot;movq (%%&quot;REG_a&quot;, %1, 2), %%mm0         \n\t&quot; // line 3
+                &quot;pxor %%mm2, %%mm0                      \n\t&quot; //(l4 - l5) &lt;= 0 ? -l4-1 : l4
+                &quot;psubusb %%mm1, %%mm0                   \n\t&quot;
+                &quot;pxor %%mm2, %%mm0                      \n\t&quot;
+                &quot;movq %%mm0, (%%&quot;REG_a&quot;, %1, 2)         \n\t&quot; // line 3
+
+                &quot;movq (%%&quot;REG_c&quot;, %1), %%mm0            \n\t&quot; // line 6
+                &quot;pxor %%mm2, %%mm0                      \n\t&quot; //(l4 - l5) &lt;= 0 ? -l5-1 : l5
+                &quot;paddusb %%mm1, %%mm0                   \n\t&quot;
+                &quot;pxor %%mm2, %%mm0                      \n\t&quot;
+                &quot;movq %%mm0, (%%&quot;REG_c&quot;, %1)            \n\t&quot; // line 6
+
+                PAVGB(%%mm7, %%mm1)                           // d/8
+
+                &quot;movq (%%&quot;REG_a&quot;, %1), %%mm0            \n\t&quot; // line 2
+                &quot;pxor %%mm2, %%mm0                      \n\t&quot; //(l4 - l5) &lt;= 0 ? -l2-1 : l2
+                &quot;psubusb %%mm1, %%mm0                   \n\t&quot;
+                &quot;pxor %%mm2, %%mm0                      \n\t&quot;
+                &quot;movq %%mm0, (%%&quot;REG_a&quot;, %1)            \n\t&quot; // line 2
+
+                &quot;movq (%%&quot;REG_c&quot;, %1, 2), %%mm0         \n\t&quot; // line 7
+                &quot;pxor %%mm2, %%mm0                      \n\t&quot; //(l4 - l5) &lt;= 0 ? -l7-1 : l7
+                &quot;paddusb %%mm1, %%mm0                   \n\t&quot;
+                &quot;pxor %%mm2, %%mm0                      \n\t&quot;
+                &quot;movq %%mm0, (%%&quot;REG_c&quot;, %1, 2)         \n\t&quot; // line 7
+
+                :
+                : &quot;r&quot; (src), &quot;r&quot; ((long)stride), &quot;m&quot; (co-&gt;pQPb)
+                : &quot;%&quot;REG_a, &quot;%&quot;REG_c
+        );
+#else //defined (HAVE_MMX2) || defined (HAVE_3DNOW)
+
+        const int l1= stride;
+        const int l2= stride + l1;
+        const int l3= stride + l2;
+        const int l4= stride + l3;
+        const int l5= stride + l4;
+        const int l6= stride + l5;
+        const int l7= stride + l6;
+//        const int l8= stride + l7;
+//        const int l9= stride + l8;
+        int x;
+
+        src+= stride*3;
+        for(x=0; x&lt;BLOCK_SIZE; x++)
+        {
+                int a= src[l3] - src[l4];
+                int b= src[l4] - src[l5];
+                int c= src[l5] - src[l6];
+
+                int d= FFABS(b) - ((FFABS(a) + FFABS(c))&gt;&gt;1);
+                d= FFMAX(d, 0);
+
+                if(d &lt; co-&gt;QP*2)
+                {
+                        int v = d * FFSIGN(-b);
+
+                        src[l2] +=v&gt;&gt;3;
+                        src[l3] +=v&gt;&gt;2;
+                        src[l4] +=(3*v)&gt;&gt;3;
+                        src[l5] -=(3*v)&gt;&gt;3;
+                        src[l6] -=v&gt;&gt;2;
+                        src[l7] -=v&gt;&gt;3;
+
+                }
+                src++;
+        }
+#endif //defined (HAVE_MMX2) || defined (HAVE_3DNOW)
+}
+
+#ifndef HAVE_ALTIVEC
+static inline void RENAME(doVertDefFilter)(uint8_t src[], int stride, PPContext *c)
+{
+#if defined (HAVE_MMX2) || defined (HAVE_3DNOW)
+/*
+        uint8_t tmp[16];
+        const int l1= stride;
+        const int l2= stride + l1;
+        const int l3= stride + l2;
+        const int l4= (int)tmp - (int)src - stride*3;
+        const int l5= (int)tmp - (int)src - stride*3 + 8;
+        const int l6= stride*3 + l3;
+        const int l7= stride + l6;
+        const int l8= stride + l7;
+
+        memcpy(tmp, src+stride*7, 8);
+        memcpy(tmp+8, src+stride*8, 8);
+*/
+        src+= stride*4;
+        asm volatile(
+
+#if 0 //sligtly more accurate and slightly slower
+                &quot;pxor %%mm7, %%mm7                      \n\t&quot; // 0
+                &quot;lea (%0, %1), %%&quot;REG_a&quot;                \n\t&quot;
+                &quot;lea (%%&quot;REG_a&quot;, %1, 4), %%&quot;REG_c&quot;      \n\t&quot;
+//      0       1       2       3       4       5       6       7
+//      %0      %0+%1   %0+2%1  eax+2%1 %0+4%1  eax+4%1 ecx+%1  ecx+2%1
+//      %0      eax     eax+%1  eax+2%1 %0+4%1  ecx     ecx+%1  ecx+2%1
+
+
+                &quot;movq (%0, %1, 2), %%mm0                \n\t&quot; // l2
+                &quot;movq (%0), %%mm1                       \n\t&quot; // l0
+                &quot;movq %%mm0, %%mm2                      \n\t&quot; // l2
+                PAVGB(%%mm7, %%mm0)                           // ~l2/2
+                PAVGB(%%mm1, %%mm0)                           // ~(l2 + 2l0)/4
+                PAVGB(%%mm2, %%mm0)                           // ~(5l2 + 2l0)/8
+
+                &quot;movq (%%&quot;REG_a&quot;), %%mm1                \n\t&quot; // l1
+                &quot;movq (%%&quot;REG_a&quot;, %1, 2), %%mm3         \n\t&quot; // l3
+                &quot;movq %%mm1, %%mm4                      \n\t&quot; // l1
+                PAVGB(%%mm7, %%mm1)                           // ~l1/2
+                PAVGB(%%mm3, %%mm1)                           // ~(l1 + 2l3)/4
+                PAVGB(%%mm4, %%mm1)                           // ~(5l1 + 2l3)/8
+
+                &quot;movq %%mm0, %%mm4                      \n\t&quot; // ~(5l2 + 2l0)/8
+                &quot;psubusb %%mm1, %%mm0                   \n\t&quot;
+                &quot;psubusb %%mm4, %%mm1                   \n\t&quot;
+                &quot;por %%mm0, %%mm1                       \n\t&quot; // ~|2l0 - 5l1 + 5l2 - 2l3|/8
+// mm1= |lenergy|, mm2= l2, mm3= l3, mm7=0
+
+                &quot;movq (%0, %1, 4), %%mm0                \n\t&quot; // l4
+                &quot;movq %%mm0, %%mm4                      \n\t&quot; // l4
+                PAVGB(%%mm7, %%mm0)                           // ~l4/2
+                PAVGB(%%mm2, %%mm0)                           // ~(l4 + 2l2)/4
+                PAVGB(%%mm4, %%mm0)                           // ~(5l4 + 2l2)/8
+
+                &quot;movq (%%&quot;REG_c&quot;), %%mm2                \n\t&quot; // l5
+                &quot;movq %%mm3, %%mm5                      \n\t&quot; // l3
+                PAVGB(%%mm7, %%mm3)                           // ~l3/2
+                PAVGB(%%mm2, %%mm3)                           // ~(l3 + 2l5)/4
+                PAVGB(%%mm5, %%mm3)                           // ~(5l3 + 2l5)/8
+
+                &quot;movq %%mm0, %%mm6                      \n\t&quot; // ~(5l4 + 2l2)/8
+                &quot;psubusb %%mm3, %%mm0                   \n\t&quot;
+                &quot;psubusb %%mm6, %%mm3                   \n\t&quot;
+                &quot;por %%mm0, %%mm3                       \n\t&quot; // ~|2l2 - 5l3 + 5l4 - 2l5|/8
+                &quot;pcmpeqb %%mm7, %%mm0                   \n\t&quot; // SIGN(2l2 - 5l3 + 5l4 - 2l5)
+// mm0= SIGN(menergy), mm1= |lenergy|, mm2= l5, mm3= |menergy|, mm4=l4, mm5= l3, mm7=0
+
+                &quot;movq (%%&quot;REG_c&quot;, %1), %%mm6            \n\t&quot; // l6
+                &quot;movq %%mm6, %%mm5                      \n\t&quot; // l6
+                PAVGB(%%mm7, %%mm6)                           // ~l6/2
+                PAVGB(%%mm4, %%mm6)                           // ~(l6 + 2l4)/4
+                PAVGB(%%mm5, %%mm6)                           // ~(5l6 + 2l4)/8
+
+                &quot;movq (%%&quot;REG_c&quot;, %1, 2), %%mm5         \n\t&quot; // l7
+                &quot;movq %%mm2, %%mm4                      \n\t&quot; // l5
+                PAVGB(%%mm7, %%mm2)                           // ~l5/2
+                PAVGB(%%mm5, %%mm2)                           // ~(l5 + 2l7)/4
+                PAVGB(%%mm4, %%mm2)                           // ~(5l5 + 2l7)/8
+
+                &quot;movq %%mm6, %%mm4                      \n\t&quot; // ~(5l6 + 2l4)/8
+                &quot;psubusb %%mm2, %%mm6                   \n\t&quot;
+                &quot;psubusb %%mm4, %%mm2                   \n\t&quot;
+                &quot;por %%mm6, %%mm2                       \n\t&quot; // ~|2l4 - 5l5 + 5l6 - 2l7|/8
+// mm0= SIGN(menergy), mm1= |lenergy|/8, mm2= |renergy|/8, mm3= |menergy|/8, mm7=0
+
+
+                PMINUB(%%mm2, %%mm1, %%mm4)                   // MIN(|lenergy|,|renergy|)/8
+                &quot;movq %2, %%mm4                         \n\t&quot; // QP //FIXME QP+1 ?
+                &quot;paddusb &quot;MANGLE(b01)&quot;, %%mm4           \n\t&quot;
+                &quot;pcmpgtb %%mm3, %%mm4                   \n\t&quot; // |menergy|/8 &lt; QP
+                &quot;psubusb %%mm1, %%mm3                   \n\t&quot; // d=|menergy|/8-MIN(|lenergy|,|renergy|)/8
+                &quot;pand %%mm4, %%mm3                      \n\t&quot;
+
+                &quot;movq %%mm3, %%mm1                      \n\t&quot;
+//                &quot;psubusb &quot;MANGLE(b01)&quot;, %%mm3           \n\t&quot;
+                PAVGB(%%mm7, %%mm3)
+                PAVGB(%%mm7, %%mm3)
+                &quot;paddusb %%mm1, %%mm3                   \n\t&quot;
+//                &quot;paddusb &quot;MANGLE(b01)&quot;, %%mm3           \n\t&quot;
+
+                &quot;movq (%%&quot;REG_a&quot;, %1, 2), %%mm6         \n\t&quot; //l3
+                &quot;movq (%0, %1, 4), %%mm5                \n\t&quot; //l4
+                &quot;movq (%0, %1, 4), %%mm4                \n\t&quot; //l4
+                &quot;psubusb %%mm6, %%mm5                   \n\t&quot;
+                &quot;psubusb %%mm4, %%mm6                   \n\t&quot;
+                &quot;por %%mm6, %%mm5                       \n\t&quot; // |l3-l4|
+                &quot;pcmpeqb %%mm7, %%mm6                   \n\t&quot; // SIGN(l3-l4)
+                &quot;pxor %%mm6, %%mm0                      \n\t&quot;
+                &quot;pand %%mm0, %%mm3                      \n\t&quot;
+                PMINUB(%%mm5, %%mm3, %%mm0)
+
+                &quot;psubusb &quot;MANGLE(b01)&quot;, %%mm3           \n\t&quot;
+                PAVGB(%%mm7, %%mm3)
+
+                &quot;movq (%%&quot;REG_a&quot;, %1, 2), %%mm0         \n\t&quot;
+                &quot;movq (%0, %1, 4), %%mm2                \n\t&quot;
+                &quot;pxor %%mm6, %%mm0                      \n\t&quot;
+                &quot;pxor %%mm6, %%mm2                      \n\t&quot;
+                &quot;psubb %%mm3, %%mm0                     \n\t&quot;
+                &quot;paddb %%mm3, %%mm2                     \n\t&quot;
+                &quot;pxor %%mm6, %%mm0                      \n\t&quot;
+                &quot;pxor %%mm6, %%mm2                      \n\t&quot;
+                &quot;movq %%mm0, (%%&quot;REG_a&quot;, %1, 2)         \n\t&quot;
+                &quot;movq %%mm2, (%0, %1, 4)                \n\t&quot;
+#endif //0
+
+                &quot;lea (%0, %1), %%&quot;REG_a&quot;                \n\t&quot;
+                &quot;pcmpeqb %%mm6, %%mm6                   \n\t&quot; // -1
+//      0       1       2       3       4       5       6       7
+//      %0      %0+%1   %0+2%1  eax+2%1 %0+4%1  eax+4%1 ecx+%1  ecx+2%1
+//      %0      eax     eax+%1  eax+2%1 %0+4%1  ecx     ecx+%1  ecx+2%1
+
+
+                &quot;movq (%%&quot;REG_a&quot;, %1, 2), %%mm1         \n\t&quot; // l3
+                &quot;movq (%0, %1, 4), %%mm0                \n\t&quot; // l4
+                &quot;pxor %%mm6, %%mm1                      \n\t&quot; // -l3-1
+                PAVGB(%%mm1, %%mm0)                           // -q+128 = (l4-l3+256)/2
+// mm1=-l3-1, mm0=128-q
+
+                &quot;movq (%%&quot;REG_a&quot;, %1, 4), %%mm2         \n\t&quot; // l5
+                &quot;movq (%%&quot;REG_a&quot;, %1), %%mm3            \n\t&quot; // l2
+                &quot;pxor %%mm6, %%mm2                      \n\t&quot; // -l5-1
+                &quot;movq %%mm2, %%mm5                      \n\t&quot; // -l5-1
+                &quot;movq &quot;MANGLE(b80)&quot;, %%mm4              \n\t&quot; // 128
+                &quot;lea (%%&quot;REG_a&quot;, %1, 4), %%&quot;REG_c&quot;      \n\t&quot;
+                PAVGB(%%mm3, %%mm2)                           // (l2-l5+256)/2
+                PAVGB(%%mm0, %%mm4)                           // ~(l4-l3)/4 + 128
+                PAVGB(%%mm2, %%mm4)                           // ~(l2-l5)/4 +(l4-l3)/8 + 128
+                PAVGB(%%mm0, %%mm4)                           // ~(l2-l5)/8 +5(l4-l3)/16 + 128
+// mm1=-l3-1, mm0=128-q, mm3=l2, mm4=menergy/16 + 128, mm5= -l5-1
+
+                &quot;movq (%%&quot;REG_a&quot;), %%mm2                \n\t&quot; // l1
+                &quot;pxor %%mm6, %%mm2                      \n\t&quot; // -l1-1
+                PAVGB(%%mm3, %%mm2)                           // (l2-l1+256)/2
+                PAVGB((%0), %%mm1)                            // (l0-l3+256)/2
+                &quot;movq &quot;MANGLE(b80)&quot;, %%mm3              \n\t&quot; // 128
+                PAVGB(%%mm2, %%mm3)                           // ~(l2-l1)/4 + 128
+                PAVGB(%%mm1, %%mm3)                           // ~(l0-l3)/4 +(l2-l1)/8 + 128
+                PAVGB(%%mm2, %%mm3)                           // ~(l0-l3)/8 +5(l2-l1)/16 + 128
+// mm0=128-q, mm3=lenergy/16 + 128, mm4= menergy/16 + 128, mm5= -l5-1
+
+                PAVGB((%%REGc, %1), %%mm5)                    // (l6-l5+256)/2
+                &quot;movq (%%&quot;REG_c&quot;, %1, 2), %%mm1         \n\t&quot; // l7
+                &quot;pxor %%mm6, %%mm1                      \n\t&quot; // -l7-1
+                PAVGB((%0, %1, 4), %%mm1)                     // (l4-l7+256)/2
+                &quot;movq &quot;MANGLE(b80)&quot;, %%mm2              \n\t&quot; // 128
+                PAVGB(%%mm5, %%mm2)                           // ~(l6-l5)/4 + 128
+                PAVGB(%%mm1, %%mm2)                           // ~(l4-l7)/4 +(l6-l5)/8 + 128
+                PAVGB(%%mm5, %%mm2)                           // ~(l4-l7)/8 +5(l6-l5)/16 + 128
+// mm0=128-q, mm2=renergy/16 + 128, mm3=lenergy/16 + 128, mm4= menergy/16 + 128
+
+                &quot;movq &quot;MANGLE(b00)&quot;, %%mm1              \n\t&quot; // 0
+                &quot;movq &quot;MANGLE(b00)&quot;, %%mm5              \n\t&quot; // 0
+                &quot;psubb %%mm2, %%mm1                     \n\t&quot; // 128 - renergy/16
+                &quot;psubb %%mm3, %%mm5                     \n\t&quot; // 128 - lenergy/16
+                PMAXUB(%%mm1, %%mm2)                          // 128 + |renergy/16|
+                 PMAXUB(%%mm5, %%mm3)                         // 128 + |lenergy/16|
+                PMINUB(%%mm2, %%mm3, %%mm1)                   // 128 + MIN(|lenergy|,|renergy|)/16
+
+// mm0=128-q, mm3=128 + MIN(|lenergy|,|renergy|)/16, mm4= menergy/16 + 128
+
+                &quot;movq &quot;MANGLE(b00)&quot;, %%mm7              \n\t&quot; // 0
+                &quot;movq %2, %%mm2                         \n\t&quot; // QP
+                PAVGB(%%mm6, %%mm2)                           // 128 + QP/2
+                &quot;psubb %%mm6, %%mm2                     \n\t&quot;
+
+                &quot;movq %%mm4, %%mm1                      \n\t&quot;
+                &quot;pcmpgtb %%mm7, %%mm1                   \n\t&quot; // SIGN(menergy)
+                &quot;pxor %%mm1, %%mm4                      \n\t&quot;
+                &quot;psubb %%mm1, %%mm4                     \n\t&quot; // 128 + |menergy|/16
+                &quot;pcmpgtb %%mm4, %%mm2                   \n\t&quot; // |menergy|/16 &lt; QP/2
+                &quot;psubusb %%mm3, %%mm4                   \n\t&quot; //d=|menergy|/16 - MIN(|lenergy|,|renergy|)/16
+// mm0=128-q, mm1= SIGN(menergy), mm2= |menergy|/16 &lt; QP/2, mm4= d/16
+
+                &quot;movq %%mm4, %%mm3                      \n\t&quot; // d
+                &quot;psubusb &quot;MANGLE(b01)&quot;, %%mm4           \n\t&quot;
+                PAVGB(%%mm7, %%mm4)                           // d/32
+                PAVGB(%%mm7, %%mm4)                           // (d + 32)/64
+                &quot;paddb %%mm3, %%mm4                     \n\t&quot; // 5d/64
+                &quot;pand %%mm2, %%mm4                      \n\t&quot;
+
+                &quot;movq &quot;MANGLE(b80)&quot;, %%mm5              \n\t&quot; // 128
+                &quot;psubb %%mm0, %%mm5                     \n\t&quot; // q
+                &quot;paddsb %%mm6, %%mm5                    \n\t&quot; // fix bad rounding
+                &quot;pcmpgtb %%mm5, %%mm7                   \n\t&quot; // SIGN(q)
+                &quot;pxor %%mm7, %%mm5                      \n\t&quot;
+
+                PMINUB(%%mm5, %%mm4, %%mm3)                   // MIN(|q|, 5d/64)
+                &quot;pxor %%mm1, %%mm7                      \n\t&quot; // SIGN(d*q)
+
+                &quot;pand %%mm7, %%mm4                      \n\t&quot;
+                &quot;movq (%%&quot;REG_a&quot;, %1, 2), %%mm0         \n\t&quot;
+                &quot;movq (%0, %1, 4), %%mm2                \n\t&quot;
+                &quot;pxor %%mm1, %%mm0                      \n\t&quot;
+                &quot;pxor %%mm1, %%mm2                      \n\t&quot;
+                &quot;paddb %%mm4, %%mm0                     \n\t&quot;
+                &quot;psubb %%mm4, %%mm2                     \n\t&quot;
+                &quot;pxor %%mm1, %%mm0                      \n\t&quot;
+                &quot;pxor %%mm1, %%mm2                      \n\t&quot;
+                &quot;movq %%mm0, (%%&quot;REG_a&quot;, %1, 2)         \n\t&quot;
+                &quot;movq %%mm2, (%0, %1, 4)                \n\t&quot;
+
+                :
+                : &quot;r&quot; (src), &quot;r&quot; ((long)stride), &quot;m&quot; (c-&gt;pQPb)
+                : &quot;%&quot;REG_a, &quot;%&quot;REG_c
+        );
+
+/*
+        {
+        int x;
+        src-= stride;
+        for(x=0; x&lt;BLOCK_SIZE; x++)
+        {
+                const int middleEnergy= 5*(src[l5] - src[l4]) + 2*(src[l3] - src[l6]);
+                if(FFABS(middleEnergy)&lt; 8*QP)
+                {
+                        const int q=(src[l4] - src[l5])/2;
+                        const int leftEnergy=  5*(src[l3] - src[l2]) + 2*(src[l1] - src[l4]);
+                        const int rightEnergy= 5*(src[l7] - src[l6]) + 2*(src[l5] - src[l8]);
+
+                        int d= FFABS(middleEnergy) - FFMIN( FFABS(leftEnergy), FFABS(rightEnergy) );
+                        d= FFMAX(d, 0);
+
+                        d= (5*d + 32) &gt;&gt; 6;
+                        d*= FFSIGN(-middleEnergy);
+
+                        if(q&gt;0)
+                        {
+                                d= d&lt;0 ? 0 : d;
+                                d= d&gt;q ? q : d;
+                        }
+                        else
+                        {
+                                d= d&gt;0 ? 0 : d;
+                                d= d&lt;q ? q : d;
+                        }
+
+                        src[l4]-= d;
+                        src[l5]+= d;
+                }
+                src++;
+        }
+src-=8;
+        for(x=0; x&lt;8; x++)
+        {
+                int y;
+                for(y=4; y&lt;6; y++)
+                {
+                        int d= src[x+y*stride] - tmp[x+(y-4)*8];
+                        int ad= FFABS(d);
+                        static int max=0;
+                        static int sum=0;
+                        static int num=0;
+                        static int bias=0;
+
+                        if(max&lt;ad) max=ad;
+                        sum+= ad&gt;3 ? 1 : 0;
+                        if(ad&gt;3)
+                        {
+                                src[0] = src[7] = src[stride*7] = src[(stride+1)*7]=255;
+                        }
+                        if(y==4) bias+=d;
+                        num++;
+                        if(num%1000000 == 0)
+                        {
+                                av_log(c, AV_LOG_INFO, &quot; %d %d %d %d\n&quot;, num, sum, max, bias);
+                        }
+                }
+        }
+}
+*/
+#elif defined (HAVE_MMX)
+        src+= stride*4;
+        asm volatile(
+                &quot;pxor %%mm7, %%mm7                      \n\t&quot;
+                &quot;lea -40(%%&quot;REG_SP&quot;), %%&quot;REG_c&quot;         \n\t&quot; // make space for 4 8-byte vars
+                &quot;and &quot;ALIGN_MASK&quot;, %%&quot;REG_c&quot;            \n\t&quot; // align
+//      0       1       2       3       4       5       6       7
+//      %0      %0+%1   %0+2%1  eax+2%1 %0+4%1  eax+4%1 edx+%1  edx+2%1
+//      %0      eax     eax+%1  eax+2%1 %0+4%1  edx     edx+%1  edx+2%1
+
+                &quot;movq (%0), %%mm0                       \n\t&quot;
+                &quot;movq %%mm0, %%mm1                      \n\t&quot;
+                &quot;punpcklbw %%mm7, %%mm0                 \n\t&quot; // low part of line 0
+                &quot;punpckhbw %%mm7, %%mm1                 \n\t&quot; // high part of line 0
+
+                &quot;movq (%0, %1), %%mm2                   \n\t&quot;
+                &quot;lea (%0, %1, 2), %%&quot;REG_a&quot;             \n\t&quot;
+                &quot;movq %%mm2, %%mm3                      \n\t&quot;
+                &quot;punpcklbw %%mm7, %%mm2                 \n\t&quot; // low part of line 1
+                &quot;punpckhbw %%mm7, %%mm3                 \n\t&quot; // high part of line 1
+
+                &quot;movq (%%&quot;REG_a&quot;), %%mm4                \n\t&quot;
+                &quot;movq %%mm4, %%mm5                      \n\t&quot;
+                &quot;punpcklbw %%mm7, %%mm4                 \n\t&quot; // low part of line 2
+                &quot;punpckhbw %%mm7, %%mm5                 \n\t&quot; // high part of line 2
+
+                &quot;paddw %%mm0, %%mm0                     \n\t&quot; // 2L0
+                &quot;paddw %%mm1, %%mm1                     \n\t&quot; // 2H0
+                &quot;psubw %%mm4, %%mm2                     \n\t&quot; // L1 - L2
+                &quot;psubw %%mm5, %%mm3                     \n\t&quot; // H1 - H2
+                &quot;psubw %%mm2, %%mm0                     \n\t&quot; // 2L0 - L1 + L2
+                &quot;psubw %%mm3, %%mm1                     \n\t&quot; // 2H0 - H1 + H2
+
+                &quot;psllw $2, %%mm2                        \n\t&quot; // 4L1 - 4L2
+                &quot;psllw $2, %%mm3                        \n\t&quot; // 4H1 - 4H2
+                &quot;psubw %%mm2, %%mm0                     \n\t&quot; // 2L0 - 5L1 + 5L2
+                &quot;psubw %%mm3, %%mm1                     \n\t&quot; // 2H0 - 5H1 + 5H2
+
+                &quot;movq (%%&quot;REG_a&quot;, %1), %%mm2            \n\t&quot;
+                &quot;movq %%mm2, %%mm3                      \n\t&quot;
+                &quot;punpcklbw %%mm7, %%mm2                 \n\t&quot; // L3
+                &quot;punpckhbw %%mm7, %%mm3                 \n\t&quot; // H3
+
+                &quot;psubw %%mm2, %%mm0                     \n\t&quot; // 2L0 - 5L1 + 5L2 - L3
+                &quot;psubw %%mm3, %%mm1                     \n\t&quot; // 2H0 - 5H1 + 5H2 - H3
+                &quot;psubw %%mm2, %%mm0                     \n\t&quot; // 2L0 - 5L1 + 5L2 - 2L3
+                &quot;psubw %%mm3, %%mm1                     \n\t&quot; // 2H0 - 5H1 + 5H2 - 2H3
+                &quot;movq %%mm0, (%%&quot;REG_c&quot;)                \n\t&quot; // 2L0 - 5L1 + 5L2 - 2L3
+                &quot;movq %%mm1, 8(%%&quot;REG_c&quot;)               \n\t&quot; // 2H0 - 5H1 + 5H2 - 2H3
+
+                &quot;movq (%%&quot;REG_a&quot;, %1, 2), %%mm0         \n\t&quot;
+                &quot;movq %%mm0, %%mm1                      \n\t&quot;
+                &quot;punpcklbw %%mm7, %%mm0                 \n\t&quot; // L4
+                &quot;punpckhbw %%mm7, %%mm1                 \n\t&quot; // H4
+
+                &quot;psubw %%mm0, %%mm2                     \n\t&quot; // L3 - L4
+                &quot;psubw %%mm1, %%mm3                     \n\t&quot; // H3 - H4
+                &quot;movq %%mm2, 16(%%&quot;REG_c&quot;)              \n\t&quot; // L3 - L4
+                &quot;movq %%mm3, 24(%%&quot;REG_c&quot;)              \n\t&quot; // H3 - H4
+                &quot;paddw %%mm4, %%mm4                     \n\t&quot; // 2L2
+                &quot;paddw %%mm5, %%mm5                     \n\t&quot; // 2H2
+                &quot;psubw %%mm2, %%mm4                     \n\t&quot; // 2L2 - L3 + L4
+                &quot;psubw %%mm3, %%mm5                     \n\t&quot; // 2H2 - H3 + H4
+
+                &quot;lea (%%&quot;REG_a&quot;, %1), %0                \n\t&quot;
+                &quot;psllw $2, %%mm2                        \n\t&quot; // 4L3 - 4L4
+                &quot;psllw $2, %%mm3                        \n\t&quot; // 4H3 - 4H4
+                &quot;psubw %%mm2, %%mm4                     \n\t&quot; // 2L2 - 5L3 + 5L4
+                &quot;psubw %%mm3, %%mm5                     \n\t&quot; // 2H2 - 5H3 + 5H4
+//50 opcodes so far
+                &quot;movq (%0, %1, 2), %%mm2                \n\t&quot;
+                &quot;movq %%mm2, %%mm3                      \n\t&quot;
+                &quot;punpcklbw %%mm7, %%mm2                 \n\t&quot; // L5
+                &quot;punpckhbw %%mm7, %%mm3                 \n\t&quot; // H5
+                &quot;psubw %%mm2, %%mm4                     \n\t&quot; // 2L2 - 5L3 + 5L4 - L5
+                &quot;psubw %%mm3, %%mm5                     \n\t&quot; // 2H2 - 5H3 + 5H4 - H5
+                &quot;psubw %%mm2, %%mm4                     \n\t&quot; // 2L2 - 5L3 + 5L4 - 2L5
+                &quot;psubw %%mm3, %%mm5                     \n\t&quot; // 2H2 - 5H3 + 5H4 - 2H5
+
+                &quot;movq (%%&quot;REG_a&quot;, %1, 4), %%mm6         \n\t&quot;
+                &quot;punpcklbw %%mm7, %%mm6                 \n\t&quot; // L6
+                &quot;psubw %%mm6, %%mm2                     \n\t&quot; // L5 - L6
+                &quot;movq (%%&quot;REG_a&quot;, %1, 4), %%mm6         \n\t&quot;
+                &quot;punpckhbw %%mm7, %%mm6                 \n\t&quot; // H6
+                &quot;psubw %%mm6, %%mm3                     \n\t&quot; // H5 - H6
+
+                &quot;paddw %%mm0, %%mm0                     \n\t&quot; // 2L4
+                &quot;paddw %%mm1, %%mm1                     \n\t&quot; // 2H4
+                &quot;psubw %%mm2, %%mm0                     \n\t&quot; // 2L4 - L5 + L6
+                &quot;psubw %%mm3, %%mm1                     \n\t&quot; // 2H4 - H5 + H6
+
+                &quot;psllw $2, %%mm2                        \n\t&quot; // 4L5 - 4L6
+                &quot;psllw $2, %%mm3                        \n\t&quot; // 4H5 - 4H6
+                &quot;psubw %%mm2, %%mm0                     \n\t&quot; // 2L4 - 5L5 + 5L6
+                &quot;psubw %%mm3, %%mm1                     \n\t&quot; // 2H4 - 5H5 + 5H6
+
+                &quot;movq (%0, %1, 4), %%mm2                \n\t&quot;
+                &quot;movq %%mm2, %%mm3                      \n\t&quot;
+                &quot;punpcklbw %%mm7, %%mm2                 \n\t&quot; // L7
+                &quot;punpckhbw %%mm7, %%mm3                 \n\t&quot; // H7
+
+                &quot;paddw %%mm2, %%mm2                     \n\t&quot; // 2L7
+                &quot;paddw %%mm3, %%mm3                     \n\t&quot; // 2H7
+                &quot;psubw %%mm2, %%mm0                     \n\t&quot; // 2L4 - 5L5 + 5L6 - 2L7
+                &quot;psubw %%mm3, %%mm1                     \n\t&quot; // 2H4 - 5H5 + 5H6 - 2H7
+
+                &quot;movq (%%&quot;REG_c&quot;), %%mm2                \n\t&quot; // 2L0 - 5L1 + 5L2 - 2L3
+                &quot;movq 8(%%&quot;REG_c&quot;), %%mm3               \n\t&quot; // 2H0 - 5H1 + 5H2 - 2H3
+
+#ifdef HAVE_MMX2
+                &quot;movq %%mm7, %%mm6                      \n\t&quot; // 0
+                &quot;psubw %%mm0, %%mm6                     \n\t&quot;
+                &quot;pmaxsw %%mm6, %%mm0                    \n\t&quot; // |2L4 - 5L5 + 5L6 - 2L7|
+                &quot;movq %%mm7, %%mm6                      \n\t&quot; // 0
+                &quot;psubw %%mm1, %%mm6                     \n\t&quot;
+                &quot;pmaxsw %%mm6, %%mm1                    \n\t&quot; // |2H4 - 5H5 + 5H6 - 2H7|
+                &quot;movq %%mm7, %%mm6                      \n\t&quot; // 0
+                &quot;psubw %%mm2, %%mm6                     \n\t&quot;
+                &quot;pmaxsw %%mm6, %%mm2                    \n\t&quot; // |2L0 - 5L1 + 5L2 - 2L3|
+                &quot;movq %%mm7, %%mm6                      \n\t&quot; // 0
+                &quot;psubw %%mm3, %%mm6                     \n\t&quot;
+                &quot;pmaxsw %%mm6, %%mm3                    \n\t&quot; // |2H0 - 5H1 + 5H2 - 2H3|
+#else
+                &quot;movq %%mm7, %%mm6                      \n\t&quot; // 0
+                &quot;pcmpgtw %%mm0, %%mm6                   \n\t&quot;
+                &quot;pxor %%mm6, %%mm0                      \n\t&quot;
+                &quot;psubw %%mm6, %%mm0                     \n\t&quot; // |2L4 - 5L5 + 5L6 - 2L7|
+                &quot;movq %%mm7, %%mm6                      \n\t&quot; // 0
+                &quot;pcmpgtw %%mm1, %%mm6                   \n\t&quot;
+                &quot;pxor %%mm6, %%mm1                      \n\t&quot;
+                &quot;psubw %%mm6, %%mm1                     \n\t&quot; // |2H4 - 5H5 + 5H6 - 2H7|
+                &quot;movq %%mm7, %%mm6                      \n\t&quot; // 0
+                &quot;pcmpgtw %%mm2, %%mm6                   \n\t&quot;
+                &quot;pxor %%mm6, %%mm2                      \n\t&quot;
+                &quot;psubw %%mm6, %%mm2                     \n\t&quot; // |2L0 - 5L1 + 5L2 - 2L3|
+                &quot;movq %%mm7, %%mm6                      \n\t&quot; // 0
+                &quot;pcmpgtw %%mm3, %%mm6                   \n\t&quot;
+                &quot;pxor %%mm6, %%mm3                      \n\t&quot;
+                &quot;psubw %%mm6, %%mm3                     \n\t&quot; // |2H0 - 5H1 + 5H2 - 2H3|
+#endif
+
+#ifdef HAVE_MMX2
+                &quot;pminsw %%mm2, %%mm0                    \n\t&quot;
+                &quot;pminsw %%mm3, %%mm1                    \n\t&quot;
+#else
+                &quot;movq %%mm0, %%mm6                      \n\t&quot;
+                &quot;psubusw %%mm2, %%mm6                   \n\t&quot;
+                &quot;psubw %%mm6, %%mm0                     \n\t&quot;
+                &quot;movq %%mm1, %%mm6                      \n\t&quot;
+                &quot;psubusw %%mm3, %%mm6                   \n\t&quot;
+                &quot;psubw %%mm6, %%mm1                     \n\t&quot;
+#endif
+
+                &quot;movd %2, %%mm2                         \n\t&quot; // QP
+                &quot;punpcklbw %%mm7, %%mm2                 \n\t&quot;
+
+                &quot;movq %%mm7, %%mm6                      \n\t&quot; // 0
+                &quot;pcmpgtw %%mm4, %%mm6                   \n\t&quot; // sign(2L2 - 5L3 + 5L4 - 2L5)
+                &quot;pxor %%mm6, %%mm4                      \n\t&quot;
+                &quot;psubw %%mm6, %%mm4                     \n\t&quot; // |2L2 - 5L3 + 5L4 - 2L5|
+                &quot;pcmpgtw %%mm5, %%mm7                   \n\t&quot; // sign(2H2 - 5H3 + 5H4 - 2H5)
+                &quot;pxor %%mm7, %%mm5                      \n\t&quot;
+                &quot;psubw %%mm7, %%mm5                     \n\t&quot; // |2H2 - 5H3 + 5H4 - 2H5|
+// 100 opcodes
+                &quot;psllw $3, %%mm2                        \n\t&quot; // 8QP
+                &quot;movq %%mm2, %%mm3                      \n\t&quot; // 8QP
+                &quot;pcmpgtw %%mm4, %%mm2                   \n\t&quot;
+                &quot;pcmpgtw %%mm5, %%mm3                   \n\t&quot;
+                &quot;pand %%mm2, %%mm4                      \n\t&quot;
+                &quot;pand %%mm3, %%mm5                      \n\t&quot;
+
+
+                &quot;psubusw %%mm0, %%mm4                   \n\t&quot; // hd
+                &quot;psubusw %%mm1, %%mm5                   \n\t&quot; // ld
+
+
+                &quot;movq &quot;MANGLE(w05)&quot;, %%mm2              \n\t&quot; // 5
+                &quot;pmullw %%mm2, %%mm4                    \n\t&quot;
+                &quot;pmullw %%mm2, %%mm5                    \n\t&quot;
+                &quot;movq &quot;MANGLE(w20)&quot;, %%mm2              \n\t&quot; // 32
+                &quot;paddw %%mm2, %%mm4                     \n\t&quot;
+                &quot;paddw %%mm2, %%mm5                     \n\t&quot;
+                &quot;psrlw $6, %%mm4                        \n\t&quot;
+                &quot;psrlw $6, %%mm5                        \n\t&quot;
+
+                &quot;movq 16(%%&quot;REG_c&quot;), %%mm0              \n\t&quot; // L3 - L4
+                &quot;movq 24(%%&quot;REG_c&quot;), %%mm1              \n\t&quot; // H3 - H4
+
+                &quot;pxor %%mm2, %%mm2                      \n\t&quot;
+                &quot;pxor %%mm3, %%mm3                      \n\t&quot;
+
+                &quot;pcmpgtw %%mm0, %%mm2                   \n\t&quot; // sign (L3-L4)
+                &quot;pcmpgtw %%mm1, %%mm3                   \n\t&quot; // sign (H3-H4)
+                &quot;pxor %%mm2, %%mm0                      \n\t&quot;
+                &quot;pxor %%mm3, %%mm1                      \n\t&quot;
+                &quot;psubw %%mm2, %%mm0                     \n\t&quot; // |L3-L4|
+                &quot;psubw %%mm3, %%mm1                     \n\t&quot; // |H3-H4|
+                &quot;psrlw $1, %%mm0                        \n\t&quot; // |L3 - L4|/2
+                &quot;psrlw $1, %%mm1                        \n\t&quot; // |H3 - H4|/2
+
+                &quot;pxor %%mm6, %%mm2                      \n\t&quot;
+                &quot;pxor %%mm7, %%mm3                      \n\t&quot;
+                &quot;pand %%mm2, %%mm4                      \n\t&quot;
+                &quot;pand %%mm3, %%mm5                      \n\t&quot;
+
+#ifdef HAVE_MMX2
+                &quot;pminsw %%mm0, %%mm4                    \n\t&quot;
+                &quot;pminsw %%mm1, %%mm5                    \n\t&quot;
+#else
+                &quot;movq %%mm4, %%mm2                      \n\t&quot;
+                &quot;psubusw %%mm0, %%mm2                   \n\t&quot;
+                &quot;psubw %%mm2, %%mm4                     \n\t&quot;
+                &quot;movq %%mm5, %%mm2                      \n\t&quot;
+                &quot;psubusw %%mm1, %%mm2                   \n\t&quot;
+                &quot;psubw %%mm2, %%mm5                     \n\t&quot;
+#endif
+                &quot;pxor %%mm6, %%mm4                      \n\t&quot;
+                &quot;pxor %%mm7, %%mm5                      \n\t&quot;
+                &quot;psubw %%mm6, %%mm4                     \n\t&quot;
+                &quot;psubw %%mm7, %%mm5                     \n\t&quot;
+                &quot;packsswb %%mm5, %%mm4                  \n\t&quot;
+                &quot;movq (%0), %%mm0                       \n\t&quot;
+                &quot;paddb   %%mm4, %%mm0                   \n\t&quot;
+                &quot;movq %%mm0, (%0)                       \n\t&quot;
+                &quot;movq (%0, %1), %%mm0                   \n\t&quot;
+                &quot;psubb %%mm4, %%mm0                     \n\t&quot;
+                &quot;movq %%mm0, (%0, %1)                   \n\t&quot;
+
+                : &quot;+r&quot; (src)
+                : &quot;r&quot; ((long)stride), &quot;m&quot; (c-&gt;pQPb)
+                : &quot;%&quot;REG_a, &quot;%&quot;REG_c
+        );
+#else //defined (HAVE_MMX2) || defined (HAVE_3DNOW)
+        const int l1= stride;
+        const int l2= stride + l1;
+        const int l3= stride + l2;
+        const int l4= stride + l3;
+        const int l5= stride + l4;
+        const int l6= stride + l5;
+        const int l7= stride + l6;
+        const int l8= stride + l7;
+//        const int l9= stride + l8;
+        int x;
+        src+= stride*3;
+        for(x=0; x&lt;BLOCK_SIZE; x++)
+        {
+                const int middleEnergy= 5*(src[l5] - src[l4]) + 2*(src[l3] - src[l6]);
+                if(FFABS(middleEnergy) &lt; 8*c-&gt;QP)
+                {
+                        const int q=(src[l4] - src[l5])/2;
+                        const int leftEnergy=  5*(src[l3] - src[l2]) + 2*(src[l1] - src[l4]);
+                        const int rightEnergy= 5*(src[l7] - src[l6]) + 2*(src[l5] - src[l8]);
+
+                        int d= FFABS(middleEnergy) - FFMIN( FFABS(leftEnergy), FFABS(rightEnergy) );
+                        d= FFMAX(d, 0);
+
+                        d= (5*d + 32) &gt;&gt; 6;
+                        d*= FFSIGN(-middleEnergy);
+
+                        if(q&gt;0)
+                        {
+                                d= d&lt;0 ? 0 : d;
+                                d= d&gt;q ? q : d;
+                        }
+                        else
+                        {
+                                d= d&gt;0 ? 0 : d;
+                                d= d&lt;q ? q : d;
+                        }
+
+                        src[l4]-= d;
+                        src[l5]+= d;
+                }
+                src++;
+        }
+#endif //defined (HAVE_MMX2) || defined (HAVE_3DNOW)
+}
+#endif //HAVE_ALTIVEC
+
+#ifndef HAVE_ALTIVEC
+static inline void RENAME(dering)(uint8_t src[], int stride, PPContext *c)
+{
+#if defined (HAVE_MMX2) || defined (HAVE_3DNOW)
+        asm volatile(
+                &quot;pxor %%mm6, %%mm6                      \n\t&quot;
+                &quot;pcmpeqb %%mm7, %%mm7                   \n\t&quot;
+                &quot;movq %2, %%mm0                         \n\t&quot;
+                &quot;punpcklbw %%mm6, %%mm0                 \n\t&quot;
+                &quot;psrlw $1, %%mm0                        \n\t&quot;
+                &quot;psubw %%mm7, %%mm0                     \n\t&quot;
+                &quot;packuswb %%mm0, %%mm0                  \n\t&quot;
+                &quot;movq %%mm0, %3                         \n\t&quot;
+
+                &quot;lea (%0, %1), %%&quot;REG_a&quot;                \n\t&quot;
+                &quot;lea (%%&quot;REG_a&quot;, %1, 4), %%&quot;REG_d&quot;      \n\t&quot;
+
+//        0        1        2        3        4        5        6        7        8        9
+//        %0        eax        eax+%1        eax+2%1        %0+4%1        edx        edx+%1        edx+2%1        %0+8%1        edx+4%1
+
+#undef FIND_MIN_MAX
+#ifdef HAVE_MMX2
+#define REAL_FIND_MIN_MAX(addr)\
+                &quot;movq &quot; #addr &quot;, %%mm0                  \n\t&quot;\
+                &quot;pminub %%mm0, %%mm7                    \n\t&quot;\
+                &quot;pmaxub %%mm0, %%mm6                    \n\t&quot;
+#else
+#define REAL_FIND_MIN_MAX(addr)\
+                &quot;movq &quot; #addr &quot;, %%mm0                  \n\t&quot;\
+                &quot;movq %%mm7, %%mm1                      \n\t&quot;\
+                &quot;psubusb %%mm0, %%mm6                   \n\t&quot;\
+                &quot;paddb %%mm0, %%mm6                     \n\t&quot;\
+                &quot;psubusb %%mm0, %%mm1                   \n\t&quot;\
+                &quot;psubb %%mm1, %%mm7                     \n\t&quot;
+#endif
+#define FIND_MIN_MAX(addr)  REAL_FIND_MIN_MAX(addr)
+
+FIND_MIN_MAX((%%REGa))
+FIND_MIN_MAX((%%REGa, %1))
+FIND_MIN_MAX((%%REGa, %1, 2))
+FIND_MIN_MAX((%0, %1, 4))
+FIND_MIN_MAX((%%REGd))
+FIND_MIN_MAX((%%REGd, %1))
+FIND_MIN_MAX((%%REGd, %1, 2))
+FIND_MIN_MAX((%0, %1, 8))
+
+                &quot;movq %%mm7, %%mm4                      \n\t&quot;
+                &quot;psrlq $8, %%mm7                        \n\t&quot;
+#ifdef HAVE_MMX2
+                &quot;pminub %%mm4, %%mm7                    \n\t&quot; // min of pixels
+                &quot;pshufw $0xF9, %%mm7, %%mm4             \n\t&quot;
+                &quot;pminub %%mm4, %%mm7                    \n\t&quot; // min of pixels
+                &quot;pshufw $0xFE, %%mm7, %%mm4             \n\t&quot;
+                &quot;pminub %%mm4, %%mm7                    \n\t&quot;
+#else
+                &quot;movq %%mm7, %%mm1                      \n\t&quot;
+                &quot;psubusb %%mm4, %%mm1                   \n\t&quot;
+                &quot;psubb %%mm1, %%mm7                     \n\t&quot;
+                &quot;movq %%mm7, %%mm4                      \n\t&quot;
+                &quot;psrlq $16, %%mm7                       \n\t&quot;
+                &quot;movq %%mm7, %%mm1                      \n\t&quot;
+                &quot;psubusb %%mm4, %%mm1                   \n\t&quot;
+                &quot;psubb %%mm1, %%mm7                     \n\t&quot;
+                &quot;movq %%mm7, %%mm4                      \n\t&quot;
+                &quot;psrlq $32, %%mm7                       \n\t&quot;
+                &quot;movq %%mm7, %%mm1                      \n\t&quot;
+                &quot;psubusb %%mm4, %%mm1                   \n\t&quot;
+                &quot;psubb %%mm1, %%mm7                     \n\t&quot;
+#endif
+
+
+                &quot;movq %%mm6, %%mm4                      \n\t&quot;
+                &quot;psrlq $8, %%mm6                        \n\t&quot;
+#ifdef HAVE_MMX2
+                &quot;pmaxub %%mm4, %%mm6                    \n\t&quot; // max of pixels
+                &quot;pshufw $0xF9, %%mm6, %%mm4             \n\t&quot;
+                &quot;pmaxub %%mm4, %%mm6                    \n\t&quot;
+                &quot;pshufw $0xFE, %%mm6, %%mm4             \n\t&quot;
+                &quot;pmaxub %%mm4, %%mm6                    \n\t&quot;
+#else
+                &quot;psubusb %%mm4, %%mm6                   \n\t&quot;
+                &quot;paddb %%mm4, %%mm6                     \n\t&quot;
+                &quot;movq %%mm6, %%mm4                      \n\t&quot;
+                &quot;psrlq $16, %%mm6                       \n\t&quot;
+                &quot;psubusb %%mm4, %%mm6                   \n\t&quot;
+                &quot;paddb %%mm4, %%mm6                     \n\t&quot;
+                &quot;movq %%mm6, %%mm4                      \n\t&quot;
+                &quot;psrlq $32, %%mm6                       \n\t&quot;
+                &quot;psubusb %%mm4, %%mm6                   \n\t&quot;
+                &quot;paddb %%mm4, %%mm6                     \n\t&quot;
+#endif
+                &quot;movq %%mm6, %%mm0                      \n\t&quot; // max
+                &quot;psubb %%mm7, %%mm6                     \n\t&quot; // max - min
+                &quot;movd %%mm6, %%ecx                      \n\t&quot;
+                &quot;cmpb &quot;MANGLE(deringThreshold)&quot;, %%cl   \n\t&quot;
+                &quot; jb 1f                                 \n\t&quot;
+                &quot;lea -24(%%&quot;REG_SP&quot;), %%&quot;REG_c&quot;         \n\t&quot;
+                &quot;and &quot;ALIGN_MASK&quot;, %%&quot;REG_c&quot;            \n\t&quot;
+                PAVGB(%%mm0, %%mm7)                           // a=(max + min)/2
+                &quot;punpcklbw %%mm7, %%mm7                 \n\t&quot;
+                &quot;punpcklbw %%mm7, %%mm7                 \n\t&quot;
+                &quot;punpcklbw %%mm7, %%mm7                 \n\t&quot;
+                &quot;movq %%mm7, (%%&quot;REG_c&quot;)                \n\t&quot;
+
+                &quot;movq (%0), %%mm0                       \n\t&quot; // L10
+                &quot;movq %%mm0, %%mm1                      \n\t&quot; // L10
+                &quot;movq %%mm0, %%mm2                      \n\t&quot; // L10
+                &quot;psllq $8, %%mm1                        \n\t&quot;
+                &quot;psrlq $8, %%mm2                        \n\t&quot;
+                &quot;movd -4(%0), %%mm3                     \n\t&quot;
+                &quot;movd 8(%0), %%mm4                      \n\t&quot;
+                &quot;psrlq $24, %%mm3                       \n\t&quot;
+                &quot;psllq $56, %%mm4                       \n\t&quot;
+                &quot;por %%mm3, %%mm1                       \n\t&quot; // L00
+                &quot;por %%mm4, %%mm2                       \n\t&quot; // L20
+                &quot;movq %%mm1, %%mm3                      \n\t&quot; // L00
+                PAVGB(%%mm2, %%mm1)                           // (L20 + L00)/2
+                PAVGB(%%mm0, %%mm1)                           // (L20 + L00 + 2L10)/4
+                &quot;psubusb %%mm7, %%mm0                   \n\t&quot;
+                &quot;psubusb %%mm7, %%mm2                   \n\t&quot;
+                &quot;psubusb %%mm7, %%mm3                   \n\t&quot;
+                &quot;pcmpeqb &quot;MANGLE(b00)&quot;, %%mm0           \n\t&quot; // L10 &gt; a ? 0 : -1
+                &quot;pcmpeqb &quot;MANGLE(b00)&quot;, %%mm2           \n\t&quot; // L20 &gt; a ? 0 : -1
+                &quot;pcmpeqb &quot;MANGLE(b00)&quot;, %%mm3           \n\t&quot; // L00 &gt; a ? 0 : -1
+                &quot;paddb %%mm2, %%mm0                     \n\t&quot;
+                &quot;paddb %%mm3, %%mm0                     \n\t&quot;
+
+                &quot;movq (%%&quot;REG_a&quot;), %%mm2                \n\t&quot; // L11
+                &quot;movq %%mm2, %%mm3                      \n\t&quot; // L11
+                &quot;movq %%mm2, %%mm4                      \n\t&quot; // L11
+                &quot;psllq $8, %%mm3                        \n\t&quot;
+                &quot;psrlq $8, %%mm4                        \n\t&quot;
+                &quot;movd -4(%%&quot;REG_a&quot;), %%mm5              \n\t&quot;
+                &quot;movd 8(%%&quot;REG_a&quot;), %%mm6               \n\t&quot;
+                &quot;psrlq $24, %%mm5                       \n\t&quot;
+                &quot;psllq $56, %%mm6                       \n\t&quot;
+                &quot;por %%mm5, %%mm3                       \n\t&quot; // L01
+                &quot;por %%mm6, %%mm4                       \n\t&quot; // L21
+                &quot;movq %%mm3, %%mm5                      \n\t&quot; // L01
+                PAVGB(%%mm4, %%mm3)                           // (L21 + L01)/2
+                PAVGB(%%mm2, %%mm3)                           // (L21 + L01 + 2L11)/4
+                &quot;psubusb %%mm7, %%mm2                   \n\t&quot;
+                &quot;psubusb %%mm7, %%mm4                   \n\t&quot;
+                &quot;psubusb %%mm7, %%mm5                   \n\t&quot;
+                &quot;pcmpeqb &quot;MANGLE(b00)&quot;, %%mm2           \n\t&quot; // L11 &gt; a ? 0 : -1
+                &quot;pcmpeqb &quot;MANGLE(b00)&quot;, %%mm4           \n\t&quot; // L21 &gt; a ? 0 : -1
+                &quot;pcmpeqb &quot;MANGLE(b00)&quot;, %%mm5           \n\t&quot; // L01 &gt; a ? 0 : -1
+                &quot;paddb %%mm4, %%mm2                     \n\t&quot;
+                &quot;paddb %%mm5, %%mm2                     \n\t&quot;
+// 0, 2, 3, 1
+#define REAL_DERING_CORE(dst,src,ppsx,psx,sx,pplx,plx,lx,t0,t1) \
+                &quot;movq &quot; #src &quot;, &quot; #sx &quot;                 \n\t&quot; /* src[0] */\
+                &quot;movq &quot; #sx &quot;, &quot; #lx &quot;                  \n\t&quot; /* src[0] */\
+                &quot;movq &quot; #sx &quot;, &quot; #t0 &quot;                  \n\t&quot; /* src[0] */\
+                &quot;psllq $8, &quot; #lx &quot;                      \n\t&quot;\
+                &quot;psrlq $8, &quot; #t0 &quot;                      \n\t&quot;\
+                &quot;movd -4&quot; #src &quot;, &quot; #t1 &quot;               \n\t&quot;\
+                &quot;psrlq $24, &quot; #t1 &quot;                     \n\t&quot;\
+                &quot;por &quot; #t1 &quot;, &quot; #lx &quot;                   \n\t&quot; /* src[-1] */\
+                &quot;movd 8&quot; #src &quot;, &quot; #t1 &quot;                \n\t&quot;\
+                &quot;psllq $56, &quot; #t1 &quot;                     \n\t&quot;\
+                &quot;por &quot; #t1 &quot;, &quot; #t0 &quot;                   \n\t&quot; /* src[+1] */\
+                &quot;movq &quot; #lx &quot;, &quot; #t1 &quot;                  \n\t&quot; /* src[-1] */\
+                PAVGB(t0, lx)                                 /* (src[-1] + src[+1])/2 */\
+                PAVGB(sx, lx)                                 /* (src[-1] + 2src[0] + src[+1])/4 */\
+                PAVGB(lx, pplx)                                     \
+                &quot;movq &quot; #lx &quot;, 8(%%&quot;REG_c&quot;)             \n\t&quot;\
+                &quot;movq (%%&quot;REG_c&quot;), &quot; #lx &quot;              \n\t&quot;\
+                &quot;psubusb &quot; #lx &quot;, &quot; #t1 &quot;               \n\t&quot;\
+                &quot;psubusb &quot; #lx &quot;, &quot; #t0 &quot;               \n\t&quot;\
+                &quot;psubusb &quot; #lx &quot;, &quot; #sx &quot;               \n\t&quot;\
+                &quot;movq &quot;MANGLE(b00)&quot;, &quot; #lx &quot;            \n\t&quot;\
+                &quot;pcmpeqb &quot; #lx &quot;, &quot; #t1 &quot;               \n\t&quot; /* src[-1] &gt; a ? 0 : -1*/\
+                &quot;pcmpeqb &quot; #lx &quot;, &quot; #t0 &quot;               \n\t&quot; /* src[+1] &gt; a ? 0 : -1*/\
+                &quot;pcmpeqb &quot; #lx &quot;, &quot; #sx &quot;               \n\t&quot; /* src[0]  &gt; a ? 0 : -1*/\
+                &quot;paddb &quot; #t1 &quot;, &quot; #t0 &quot;                 \n\t&quot;\
+                &quot;paddb &quot; #t0 &quot;, &quot; #sx &quot;                 \n\t&quot;\
+\
+                PAVGB(plx, pplx)                              /* filtered */\
+                &quot;movq &quot; #dst &quot;, &quot; #t0 &quot;                 \n\t&quot; /* dst */\
+                &quot;movq &quot; #t0 &quot;, &quot; #t1 &quot;                  \n\t&quot; /* dst */\
+                &quot;psubusb %3, &quot; #t0 &quot;                    \n\t&quot;\
+                &quot;paddusb %3, &quot; #t1 &quot;                    \n\t&quot;\
+                PMAXUB(t0, pplx)\
+                PMINUB(t1, pplx, t0)\
+                &quot;paddb &quot; #sx &quot;, &quot; #ppsx &quot;               \n\t&quot;\
+                &quot;paddb &quot; #psx &quot;, &quot; #ppsx &quot;              \n\t&quot;\
+                &quot;#paddb &quot;MANGLE(b02)&quot;, &quot; #ppsx &quot;        \n\t&quot;\
+                &quot;pand &quot;MANGLE(b08)&quot;, &quot; #ppsx &quot;          \n\t&quot;\
+                &quot;pcmpeqb &quot; #lx &quot;, &quot; #ppsx &quot;             \n\t&quot;\
+                &quot;pand &quot; #ppsx &quot;, &quot; #pplx &quot;              \n\t&quot;\
+                &quot;pandn &quot; #dst &quot;, &quot; #ppsx &quot;              \n\t&quot;\
+                &quot;por &quot; #pplx &quot;, &quot; #ppsx &quot;               \n\t&quot;\
+                &quot;movq &quot; #ppsx &quot;, &quot; #dst &quot;               \n\t&quot;\
+                &quot;movq 8(%%&quot;REG_c&quot;), &quot; #lx &quot;             \n\t&quot;
+
+#define DERING_CORE(dst,src,ppsx,psx,sx,pplx,plx,lx,t0,t1) \
+   REAL_DERING_CORE(dst,src,ppsx,psx,sx,pplx,plx,lx,t0,t1)
+/*
+0000000
+1111111
+
+1111110
+1111101
+1111100
+1111011
+1111010
+1111001
+
+1111000
+1110111
+
+*/
+//DERING_CORE(dst          ,src            ,ppsx ,psx  ,sx   ,pplx ,plx  ,lx   ,t0   ,t1)
+DERING_CORE((%%REGa)       ,(%%REGa, %1)   ,%%mm0,%%mm2,%%mm4,%%mm1,%%mm3,%%mm5,%%mm6,%%mm7)
+DERING_CORE((%%REGa, %1)   ,(%%REGa, %1, 2),%%mm2,%%mm4,%%mm0,%%mm3,%%mm5,%%mm1,%%mm6,%%mm7)
+DERING_CORE((%%REGa, %1, 2),(%0, %1, 4)    ,%%mm4,%%mm0,%%mm2,%%mm5,%%mm1,%%mm3,%%mm6,%%mm7)
+DERING_CORE((%0, %1, 4)    ,(%%REGd)       ,%%mm0,%%mm2,%%mm4,%%mm1,%%mm3,%%mm5,%%mm6,%%mm7)
+DERING_CORE((%%REGd)       ,(%%REGd, %1)   ,%%mm2,%%mm4,%%mm0,%%mm3,%%mm5,%%mm1,%%mm6,%%mm7)
+DERING_CORE((%%REGd, %1)   ,(%%REGd, %1, 2),%%mm4,%%mm0,%%mm2,%%mm5,%%mm1,%%mm3,%%mm6,%%mm7)
+DERING_CORE((%%REGd, %1, 2),(%0, %1, 8)    ,%%mm0,%%mm2,%%mm4,%%mm1,%%mm3,%%mm5,%%mm6,%%mm7)
+DERING_CORE((%0, %1, 8)    ,(%%REGd, %1, 4),%%mm2,%%mm4,%%mm0,%%mm3,%%mm5,%%mm1,%%mm6,%%mm7)
+
+                &quot;1:                        \n\t&quot;
+                : : &quot;r&quot; (src), &quot;r&quot; ((long)stride), &quot;m&quot; (c-&gt;pQPb), &quot;m&quot;(c-&gt;pQPb2)
+                : &quot;%&quot;REG_a, &quot;%&quot;REG_d, &quot;%&quot;REG_c
+        );
+#else //defined (HAVE_MMX2) || defined (HAVE_3DNOW)
+        int y;
+        int min=255;
+        int max=0;
+        int avg;
+        uint8_t *p;
+        int s[10];
+        const int QP2= c-&gt;QP/2 + 1;
+
+        for(y=1; y&lt;9; y++)
+        {
+                int x;
+                p= src + stride*y;
+                for(x=1; x&lt;9; x++)
+                {
+                        p++;
+                        if(*p &gt; max) max= *p;
+                        if(*p &lt; min) min= *p;
+                }
+        }
+        avg= (min + max + 1)&gt;&gt;1;
+
+        if(max - min &lt;deringThreshold) return;
+
+        for(y=0; y&lt;10; y++)
+        {
+                int t = 0;
+
+                if(src[stride*y + 0] &gt; avg) t+= 1;
+                if(src[stride*y + 1] &gt; avg) t+= 2;
+                if(src[stride*y + 2] &gt; avg) t+= 4;
+                if(src[stride*y + 3] &gt; avg) t+= 8;
+                if(src[stride*y + 4] &gt; avg) t+= 16;
+                if(src[stride*y + 5] &gt; avg) t+= 32;
+                if(src[stride*y + 6] &gt; avg) t+= 64;
+                if(src[stride*y + 7] &gt; avg) t+= 128;
+                if(src[stride*y + 8] &gt; avg) t+= 256;
+                if(src[stride*y + 9] &gt; avg) t+= 512;
+
+                t |= (~t)&lt;&lt;16;
+                t &amp;= (t&lt;&lt;1) &amp; (t&gt;&gt;1);
+                s[y] = t;
+        }
+
+        for(y=1; y&lt;9; y++)
+        {
+                int t = s[y-1] &amp; s[y] &amp; s[y+1];
+                t|= t&gt;&gt;16;
+                s[y-1]= t;
+        }
+
+        for(y=1; y&lt;9; y++)
+        {
+                int x;
+                int t = s[y-1];
+
+                p= src + stride*y;
+                for(x=1; x&lt;9; x++)
+                {
+                        p++;
+                        if(t &amp; (1&lt;&lt;x))
+                        {
+                                int f= (*(p-stride-1)) + 2*(*(p-stride)) + (*(p-stride+1))
+                                      +2*(*(p     -1)) + 4*(*p         ) + 2*(*(p     +1))
+                                      +(*(p+stride-1)) + 2*(*(p+stride)) + (*(p+stride+1));
+                                f= (f + 8)&gt;&gt;4;
+
+#ifdef DEBUG_DERING_THRESHOLD
+                                asm volatile(&quot;emms\n\t&quot;:);
+                                {
+                                static long long numPixels=0;
+                                if(x!=1 &amp;&amp; x!=8 &amp;&amp; y!=1 &amp;&amp; y!=8) numPixels++;
+//                                if((max-min)&lt;20 || (max-min)*QP&lt;200)
+//                                if((max-min)*QP &lt; 500)
+//                                if(max-min&lt;QP/2)
+                                if(max-min &lt; 20)
+                                {
+                                        static int numSkiped=0;
+                                        static int errorSum=0;
+                                        static int worstQP=0;
+                                        static int worstRange=0;
+                                        static int worstDiff=0;
+                                        int diff= (f - *p);
+                                        int absDiff= FFABS(diff);
+                                        int error= diff*diff;
+
+                                        if(x==1 || x==8 || y==1 || y==8) continue;
+
+                                        numSkiped++;
+                                        if(absDiff &gt; worstDiff)
+                                        {
+                                                worstDiff= absDiff;
+                                                worstQP= QP;
+                                                worstRange= max-min;
+                                        }
+                                        errorSum+= error;
+
+                                        if(1024LL*1024LL*1024LL % numSkiped == 0)
+                                        {
+                                                av_log(c, AV_LOG_INFO, &quot;sum:%1.3f, skip:%d, wQP:%d, &quot;
+                                                        &quot;wRange:%d, wDiff:%d, relSkip:%1.3f\n&quot;,
+                                                        (float)errorSum/numSkiped, numSkiped, worstQP, worstRange,
+                                                        worstDiff, (float)numSkiped/numPixels);
+                                        }
+                                }
+                                }
+#endif
+                                if     (*p + QP2 &lt; f) *p= *p + QP2;
+                                else if(*p - QP2 &gt; f) *p= *p - QP2;
+                                else *p=f;
+                        }
+                }
+        }
+#ifdef DEBUG_DERING_THRESHOLD
+        if(max-min &lt; 20)
+        {
+                for(y=1; y&lt;9; y++)
+                {
+                        int x;
+                        int t = 0;
+                        p= src + stride*y;
+                        for(x=1; x&lt;9; x++)
+                        {
+                                p++;
+                                *p = FFMIN(*p + 20, 255);
+                        }
+                }
+//                src[0] = src[7]=src[stride*7]=src[stride*7 + 7]=255;
+        }
+#endif
+#endif //defined (HAVE_MMX2) || defined (HAVE_3DNOW)
+}
+#endif //HAVE_ALTIVEC
+
+/**
+ * Deinterlaces the given block by linearly interpolating every second line.
+ * will be called for every 8x8 block and can read &amp; write from line 4-15
+ * lines 0-3 have been passed through the deblock / dering filters allready, but can be read too
+ * lines 4-12 will be read into the deblocking filter and should be deinterlaced
+ */
+static inline void RENAME(deInterlaceInterpolateLinear)(uint8_t src[], int stride)
+{
+#if defined (HAVE_MMX2) || defined (HAVE_3DNOW)
+        src+= 4*stride;
+        asm volatile(
+                &quot;lea (%0, %1), %%&quot;REG_a&quot;                \n\t&quot;
+                &quot;lea (%%&quot;REG_a&quot;, %1, 4), %%&quot;REG_c&quot;      \n\t&quot;
+//      0       1       2       3       4       5       6       7       8       9
+//      %0      eax     eax+%1  eax+2%1 %0+4%1  ecx     ecx+%1  ecx+2%1 %0+8%1  ecx+4%1
+
+                &quot;movq (%0), %%mm0                       \n\t&quot;
+                &quot;movq (%%&quot;REG_a&quot;, %1), %%mm1            \n\t&quot;
+                PAVGB(%%mm1, %%mm0)
+                &quot;movq %%mm0, (%%&quot;REG_a&quot;)                \n\t&quot;
+                &quot;movq (%0, %1, 4), %%mm0                \n\t&quot;
+                PAVGB(%%mm0, %%mm1)
+                &quot;movq %%mm1, (%%&quot;REG_a&quot;, %1, 2)         \n\t&quot;
+                &quot;movq (%%&quot;REG_c&quot;, %1), %%mm1            \n\t&quot;
+                PAVGB(%%mm1, %%mm0)
+                &quot;movq %%mm0, (%%&quot;REG_c&quot;)                \n\t&quot;
+                &quot;movq (%0, %1, 8), %%mm0                \n\t&quot;
+                PAVGB(%%mm0, %%mm1)
+                &quot;movq %%mm1, (%%&quot;REG_c&quot;, %1, 2)         \n\t&quot;
+
+                : : &quot;r&quot; (src), &quot;r&quot; ((long)stride)
+                : &quot;%&quot;REG_a, &quot;%&quot;REG_c
+        );
+#else
+        int a, b, x;
+        src+= 4*stride;
+
+        for(x=0; x&lt;2; x++){
+                a= *(uint32_t*)&amp;src[stride*0];
+                b= *(uint32_t*)&amp;src[stride*2];
+                *(uint32_t*)&amp;src[stride*1]= (a|b) - (((a^b)&amp;0xFEFEFEFEUL)&gt;&gt;1);
+                a= *(uint32_t*)&amp;src[stride*4];
+                *(uint32_t*)&amp;src[stride*3]= (a|b) - (((a^b)&amp;0xFEFEFEFEUL)&gt;&gt;1);
+                b= *(uint32_t*)&amp;src[stride*6];
+                *(uint32_t*)&amp;src[stride*5]= (a|b) - (((a^b)&amp;0xFEFEFEFEUL)&gt;&gt;1);
+                a= *(uint32_t*)&amp;src[stride*8];
+                *(uint32_t*)&amp;src[stride*7]= (a|b) - (((a^b)&amp;0xFEFEFEFEUL)&gt;&gt;1);
+                src += 4;
+        }
+#endif
+}
+
+/**
+ * Deinterlaces the given block by cubic interpolating every second line.
+ * will be called for every 8x8 block and can read &amp; write from line 4-15
+ * lines 0-3 have been passed through the deblock / dering filters allready, but can be read too
+ * lines 4-12 will be read into the deblocking filter and should be deinterlaced
+ * this filter will read lines 3-15 and write 7-13
+ */
+static inline void RENAME(deInterlaceInterpolateCubic)(uint8_t src[], int stride)
+{
+#if defined (HAVE_MMX2) || defined (HAVE_3DNOW)
+        src+= stride*3;
+        asm volatile(
+                &quot;lea (%0, %1), %%&quot;REG_a&quot;                \n\t&quot;
+                &quot;lea (%%&quot;REG_a&quot;, %1, 4), %%&quot;REG_d&quot;      \n\t&quot;
+                &quot;lea (%%&quot;REG_d&quot;, %1, 4), %%&quot;REG_c&quot;      \n\t&quot;
+                &quot;add %1, %%&quot;REG_c&quot;                      \n\t&quot;
+                &quot;pxor %%mm7, %%mm7                      \n\t&quot;
+//      0       1       2       3       4       5       6       7       8       9       10
+//      %0      eax     eax+%1  eax+2%1 %0+4%1  edx     edx+%1  edx+2%1 %0+8%1  edx+4%1 ecx
+
+#define REAL_DEINT_CUBIC(a,b,c,d,e)\
+                &quot;movq &quot; #a &quot;, %%mm0                     \n\t&quot;\
+                &quot;movq &quot; #b &quot;, %%mm1                     \n\t&quot;\
+                &quot;movq &quot; #d &quot;, %%mm2                     \n\t&quot;\
+                &quot;movq &quot; #e &quot;, %%mm3                     \n\t&quot;\
+                PAVGB(%%mm2, %%mm1)                             /* (b+d) /2 */\
+                PAVGB(%%mm3, %%mm0)                             /* a(a+e) /2 */\
+                &quot;movq %%mm0, %%mm2                      \n\t&quot;\
+                &quot;punpcklbw %%mm7, %%mm0                 \n\t&quot;\
+                &quot;punpckhbw %%mm7, %%mm2                 \n\t&quot;\
+                &quot;movq %%mm1, %%mm3                      \n\t&quot;\
+                &quot;punpcklbw %%mm7, %%mm1                 \n\t&quot;\
+                &quot;punpckhbw %%mm7, %%mm3                 \n\t&quot;\
+                &quot;psubw %%mm1, %%mm0                     \n\t&quot;   /* L(a+e - (b+d))/2 */\
+                &quot;psubw %%mm3, %%mm2                     \n\t&quot;   /* H(a+e - (b+d))/2 */\
+                &quot;psraw $3, %%mm0                        \n\t&quot;   /* L(a+e - (b+d))/16 */\
+                &quot;psraw $3, %%mm2                        \n\t&quot;   /* H(a+e - (b+d))/16 */\
+                &quot;psubw %%mm0, %%mm1                     \n\t&quot;   /* L(9b + 9d - a - e)/16 */\
+                &quot;psubw %%mm2, %%mm3                     \n\t&quot;   /* H(9b + 9d - a - e)/16 */\
+                &quot;packuswb %%mm3, %%mm1                  \n\t&quot;\
+                &quot;movq %%mm1, &quot; #c &quot;                     \n\t&quot;
+#define DEINT_CUBIC(a,b,c,d,e)  REAL_DEINT_CUBIC(a,b,c,d,e)
+
+DEINT_CUBIC((%0)        , (%%REGa, %1), (%%REGa, %1, 2), (%0, %1, 4) , (%%REGd, %1))
+DEINT_CUBIC((%%REGa, %1), (%0, %1, 4) , (%%REGd)       , (%%REGd, %1), (%0, %1, 8))
+DEINT_CUBIC((%0, %1, 4) , (%%REGd, %1), (%%REGd, %1, 2), (%0, %1, 8) , (%%REGc))
+DEINT_CUBIC((%%REGd, %1), (%0, %1, 8) , (%%REGd, %1, 4), (%%REGc)    , (%%REGc, %1, 2))
+
+                : : &quot;r&quot; (src), &quot;r&quot; ((long)stride)
+                : &quot;%&quot;REG_a, &quot;%&quot;REG_d, &quot;%&quot;REG_c
+        );
+#else //defined (HAVE_MMX2) || defined (HAVE_3DNOW)
+        int x;
+        src+= stride*3;
+        for(x=0; x&lt;8; x++)
+        {
+                src[stride*3] = CLIP((-src[0]        + 9*src[stride*2] + 9*src[stride*4] - src[stride*6])&gt;&gt;4);
+                src[stride*5] = CLIP((-src[stride*2] + 9*src[stride*4] + 9*src[stride*6] - src[stride*8])&gt;&gt;4);
+                src[stride*7] = CLIP((-src[stride*4] + 9*src[stride*6] + 9*src[stride*8] - src[stride*10])&gt;&gt;4);
+                src[stride*9] = CLIP((-src[stride*6] + 9*src[stride*8] + 9*src[stride*10] - src[stride*12])&gt;&gt;4);
+                src++;
+        }
+#endif //defined (HAVE_MMX2) || defined (HAVE_3DNOW)
+}
+
+/**
+ * Deinterlaces the given block by filtering every second line with a (-1 4 2 4 -1) filter.
+ * will be called for every 8x8 block and can read &amp; write from line 4-15
+ * lines 0-3 have been passed through the deblock / dering filters allready, but can be read too
+ * lines 4-12 will be read into the deblocking filter and should be deinterlaced
+ * this filter will read lines 4-13 and write 5-11
+ */
+static inline void RENAME(deInterlaceFF)(uint8_t src[], int stride, uint8_t *tmp)
+{
+#if defined (HAVE_MMX2) || defined (HAVE_3DNOW)
+        src+= stride*4;
+        asm volatile(
+                &quot;lea (%0, %1), %%&quot;REG_a&quot;                \n\t&quot;
+                &quot;lea (%%&quot;REG_a&quot;, %1, 4), %%&quot;REG_d&quot;      \n\t&quot;
+                &quot;pxor %%mm7, %%mm7                      \n\t&quot;
+                &quot;movq (%2), %%mm0                       \n\t&quot;
+//      0       1       2       3       4       5       6       7       8       9       10
+//      %0      eax     eax+%1  eax+2%1 %0+4%1  edx     edx+%1  edx+2%1 %0+8%1  edx+4%1 ecx
+
+#define REAL_DEINT_FF(a,b,c,d)\
+                &quot;movq &quot; #a &quot;, %%mm1                     \n\t&quot;\
+                &quot;movq &quot; #b &quot;, %%mm2                     \n\t&quot;\
+                &quot;movq &quot; #c &quot;, %%mm3                     \n\t&quot;\
+                &quot;movq &quot; #d &quot;, %%mm4                     \n\t&quot;\
+                PAVGB(%%mm3, %%mm1)                          \
+                PAVGB(%%mm4, %%mm0)                          \
+                &quot;movq %%mm0, %%mm3                      \n\t&quot;\
+                &quot;punpcklbw %%mm7, %%mm0                 \n\t&quot;\
+                &quot;punpckhbw %%mm7, %%mm3                 \n\t&quot;\
+                &quot;movq %%mm1, %%mm4                      \n\t&quot;\
+                &quot;punpcklbw %%mm7, %%mm1                 \n\t&quot;\
+                &quot;punpckhbw %%mm7, %%mm4                 \n\t&quot;\
+                &quot;psllw $2, %%mm1                        \n\t&quot;\
+                &quot;psllw $2, %%mm4                        \n\t&quot;\
+                &quot;psubw %%mm0, %%mm1                     \n\t&quot;\
+                &quot;psubw %%mm3, %%mm4                     \n\t&quot;\
+                &quot;movq %%mm2, %%mm5                      \n\t&quot;\
+                &quot;movq %%mm2, %%mm0                      \n\t&quot;\
+                &quot;punpcklbw %%mm7, %%mm2                 \n\t&quot;\
+                &quot;punpckhbw %%mm7, %%mm5                 \n\t&quot;\
+                &quot;paddw %%mm2, %%mm1                     \n\t&quot;\
+                &quot;paddw %%mm5, %%mm4                     \n\t&quot;\
+                &quot;psraw $2, %%mm1                        \n\t&quot;\
+                &quot;psraw $2, %%mm4                        \n\t&quot;\
+                &quot;packuswb %%mm4, %%mm1                  \n\t&quot;\
+                &quot;movq %%mm1, &quot; #b &quot;                     \n\t&quot;\
+
+#define DEINT_FF(a,b,c,d)  REAL_DEINT_FF(a,b,c,d)
+
+DEINT_FF((%0)        , (%%REGa)       , (%%REGa, %1), (%%REGa, %1, 2))
+DEINT_FF((%%REGa, %1), (%%REGa, %1, 2), (%0, %1, 4) , (%%REGd)       )
+DEINT_FF((%0, %1, 4) , (%%REGd)       , (%%REGd, %1), (%%REGd, %1, 2))
+DEINT_FF((%%REGd, %1), (%%REGd, %1, 2), (%0, %1, 8) , (%%REGd, %1, 4))
+
+                &quot;movq %%mm0, (%2)                       \n\t&quot;
+                : : &quot;r&quot; (src), &quot;r&quot; ((long)stride), &quot;r&quot;(tmp)
+                : &quot;%&quot;REG_a, &quot;%&quot;REG_d
+        );
+#else //defined (HAVE_MMX2) || defined (HAVE_3DNOW)
+        int x;
+        src+= stride*4;
+        for(x=0; x&lt;8; x++)
+        {
+                int t1= tmp[x];
+                int t2= src[stride*1];
+
+                src[stride*1]= CLIP((-t1 + 4*src[stride*0] + 2*t2 + 4*src[stride*2] - src[stride*3] + 4)&gt;&gt;3);
+                t1= src[stride*4];
+                src[stride*3]= CLIP((-t2 + 4*src[stride*2] + 2*t1 + 4*src[stride*4] - src[stride*5] + 4)&gt;&gt;3);
+                t2= src[stride*6];
+                src[stride*5]= CLIP((-t1 + 4*src[stride*4] + 2*t2 + 4*src[stride*6] - src[stride*7] + 4)&gt;&gt;3);
+                t1= src[stride*8];
+                src[stride*7]= CLIP((-t2 + 4*src[stride*6] + 2*t1 + 4*src[stride*8] - src[stride*9] + 4)&gt;&gt;3);
+                tmp[x]= t1;
+
+                src++;
+        }
+#endif //defined (HAVE_MMX2) || defined (HAVE_3DNOW)
+}
+
+/**
+ * Deinterlaces the given block by filtering every line with a (-1 2 6 2 -1) filter.
+ * will be called for every 8x8 block and can read &amp; write from line 4-15
+ * lines 0-3 have been passed through the deblock / dering filters allready, but can be read too
+ * lines 4-12 will be read into the deblocking filter and should be deinterlaced
+ * this filter will read lines 4-13 and write 4-11
+ */
+static inline void RENAME(deInterlaceL5)(uint8_t src[], int stride, uint8_t *tmp, uint8_t *tmp2)
+{
+#if defined (HAVE_MMX2) || defined (HAVE_3DNOW)
+        src+= stride*4;
+        asm volatile(
+                &quot;lea (%0, %1), %%&quot;REG_a&quot;                \n\t&quot;
+                &quot;lea (%%&quot;REG_a&quot;, %1, 4), %%&quot;REG_d&quot;      \n\t&quot;
+                &quot;pxor %%mm7, %%mm7                      \n\t&quot;
+                &quot;movq (%2), %%mm0                       \n\t&quot;
+                &quot;movq (%3), %%mm1                       \n\t&quot;
+//      0       1       2       3       4       5       6       7       8       9       10
+//      %0      eax     eax+%1  eax+2%1 %0+4%1  edx     edx+%1  edx+2%1 %0+8%1  edx+4%1 ecx
+
+#define REAL_DEINT_L5(t1,t2,a,b,c)\
+                &quot;movq &quot; #a &quot;, %%mm2                     \n\t&quot;\
+                &quot;movq &quot; #b &quot;, %%mm3                     \n\t&quot;\
+                &quot;movq &quot; #c &quot;, %%mm4                     \n\t&quot;\
+                PAVGB(t2, %%mm3)                             \
+                PAVGB(t1, %%mm4)                             \
+                &quot;movq %%mm2, %%mm5                      \n\t&quot;\
+                &quot;movq %%mm2, &quot; #t1 &quot;                    \n\t&quot;\
+                &quot;punpcklbw %%mm7, %%mm2                 \n\t&quot;\
+                &quot;punpckhbw %%mm7, %%mm5                 \n\t&quot;\
+                &quot;movq %%mm2, %%mm6                      \n\t&quot;\
+                &quot;paddw %%mm2, %%mm2                     \n\t&quot;\
+                &quot;paddw %%mm6, %%mm2                     \n\t&quot;\
+                &quot;movq %%mm5, %%mm6                      \n\t&quot;\
+                &quot;paddw %%mm5, %%mm5                     \n\t&quot;\
+                &quot;paddw %%mm6, %%mm5                     \n\t&quot;\
+                &quot;movq %%mm3, %%mm6                      \n\t&quot;\
+                &quot;punpcklbw %%mm7, %%mm3                 \n\t&quot;\
+                &quot;punpckhbw %%mm7, %%mm6                 \n\t&quot;\
+                &quot;paddw %%mm3, %%mm3                     \n\t&quot;\
+                &quot;paddw %%mm6, %%mm6                     \n\t&quot;\
+                &quot;paddw %%mm3, %%mm2                     \n\t&quot;\
+                &quot;paddw %%mm6, %%mm5                     \n\t&quot;\
+                &quot;movq %%mm4, %%mm6                      \n\t&quot;\
+                &quot;punpcklbw %%mm7, %%mm4                 \n\t&quot;\
+                &quot;punpckhbw %%mm7, %%mm6                 \n\t&quot;\
+                &quot;psubw %%mm4, %%mm2                     \n\t&quot;\
+                &quot;psubw %%mm6, %%mm5                     \n\t&quot;\
+                &quot;psraw $2, %%mm2                        \n\t&quot;\
+                &quot;psraw $2, %%mm5                        \n\t&quot;\
+                &quot;packuswb %%mm5, %%mm2                  \n\t&quot;\
+                &quot;movq %%mm2, &quot; #a &quot;                     \n\t&quot;\
+
+#define DEINT_L5(t1,t2,a,b,c)  REAL_DEINT_L5(t1,t2,a,b,c)
+
+DEINT_L5(%%mm0, %%mm1, (%0)           , (%%REGa)       , (%%REGa, %1)   )
+DEINT_L5(%%mm1, %%mm0, (%%REGa)       , (%%REGa, %1)   , (%%REGa, %1, 2))
+DEINT_L5(%%mm0, %%mm1, (%%REGa, %1)   , (%%REGa, %1, 2), (%0, %1, 4)   )
+DEINT_L5(%%mm1, %%mm0, (%%REGa, %1, 2), (%0, %1, 4)    , (%%REGd)       )
+DEINT_L5(%%mm0, %%mm1, (%0, %1, 4)    , (%%REGd)       , (%%REGd, %1)   )
+DEINT_L5(%%mm1, %%mm0, (%%REGd)       , (%%REGd, %1)   , (%%REGd, %1, 2))
+DEINT_L5(%%mm0, %%mm1, (%%REGd, %1)   , (%%REGd, %1, 2), (%0, %1, 8)   )
+DEINT_L5(%%mm1, %%mm0, (%%REGd, %1, 2), (%0, %1, 8)    , (%%REGd, %1, 4))
+
+                &quot;movq %%mm0, (%2)                       \n\t&quot;
+                &quot;movq %%mm1, (%3)                       \n\t&quot;
+                : : &quot;r&quot; (src), &quot;r&quot; ((long)stride), &quot;r&quot;(tmp), &quot;r&quot;(tmp2)
+                : &quot;%&quot;REG_a, &quot;%&quot;REG_d
+        );
+#else //defined (HAVE_MMX2) || defined (HAVE_3DNOW)
+        int x;
+        src+= stride*4;
+        for(x=0; x&lt;8; x++)
+        {
+                int t1= tmp[x];
+                int t2= tmp2[x];
+                int t3= src[0];
+
+                src[stride*0]= CLIP((-(t1 + src[stride*2]) + 2*(t2 + src[stride*1]) + 6*t3 + 4)&gt;&gt;3);
+                t1= src[stride*1];
+                src[stride*1]= CLIP((-(t2 + src[stride*3]) + 2*(t3 + src[stride*2]) + 6*t1 + 4)&gt;&gt;3);
+                t2= src[stride*2];
+                src[stride*2]= CLIP((-(t3 + src[stride*4]) + 2*(t1 + src[stride*3]) + 6*t2 + 4)&gt;&gt;3);
+                t3= src[stride*3];
+                src[stride*3]= CLIP((-(t1 + src[stride*5]) + 2*(t2 + src[stride*4]) + 6*t3 + 4)&gt;&gt;3);
+                t1= src[stride*4];
+                src[stride*4]= CLIP((-(t2 + src[stride*6]) + 2*(t3 + src[stride*5]) + 6*t1 + 4)&gt;&gt;3);
+                t2= src[stride*5];
+                src[stride*5]= CLIP((-(t3 + src[stride*7]) + 2*(t1 + src[stride*6]) + 6*t2 + 4)&gt;&gt;3);
+                t3= src[stride*6];
+                src[stride*6]= CLIP((-(t1 + src[stride*8]) + 2*(t2 + src[stride*7]) + 6*t3 + 4)&gt;&gt;3);
+                t1= src[stride*7];
+                src[stride*7]= CLIP((-(t2 + src[stride*9]) + 2*(t3 + src[stride*8]) + 6*t1 + 4)&gt;&gt;3);
+
+                tmp[x]= t3;
+                tmp2[x]= t1;
+
+                src++;
+        }
+#endif //defined (HAVE_MMX2) || defined (HAVE_3DNOW)
+}
+
+/**
+ * Deinterlaces the given block by filtering all lines with a (1 2 1) filter.
+ * will be called for every 8x8 block and can read &amp; write from line 4-15
+ * lines 0-3 have been passed through the deblock / dering filters allready, but can be read too
+ * lines 4-12 will be read into the deblocking filter and should be deinterlaced
+ * this filter will read lines 4-13 and write 4-11
+ */
+static inline void RENAME(deInterlaceBlendLinear)(uint8_t src[], int stride, uint8_t *tmp)
+{
+#if defined (HAVE_MMX2) || defined (HAVE_3DNOW)
+        src+= 4*stride;
+        asm volatile(
+                &quot;lea (%0, %1), %%&quot;REG_a&quot;                \n\t&quot;
+                &quot;lea (%%&quot;REG_a&quot;, %1, 4), %%&quot;REG_d&quot;      \n\t&quot;
+//      0       1       2       3       4       5       6       7       8       9
+//      %0      eax     eax+%1  eax+2%1 %0+4%1  edx     edx+%1  edx+2%1 %0+8%1  edx+4%1
+
+                &quot;movq (%2), %%mm0                       \n\t&quot; // L0
+                &quot;movq (%%&quot;REG_a&quot;), %%mm1                \n\t&quot; // L2
+                PAVGB(%%mm1, %%mm0)                           // L0+L2
+                &quot;movq (%0), %%mm2                       \n\t&quot; // L1
+                PAVGB(%%mm2, %%mm0)
+                &quot;movq %%mm0, (%0)                       \n\t&quot;
+                &quot;movq (%%&quot;REG_a&quot;, %1), %%mm0            \n\t&quot; // L3
+                PAVGB(%%mm0, %%mm2)                           // L1+L3
+                PAVGB(%%mm1, %%mm2)                           // 2L2 + L1 + L3
+                &quot;movq %%mm2, (%%&quot;REG_a&quot;)                \n\t&quot;
+                &quot;movq (%%&quot;REG_a&quot;, %1, 2), %%mm2         \n\t&quot; // L4
+                PAVGB(%%mm2, %%mm1)                           // L2+L4
+                PAVGB(%%mm0, %%mm1)                           // 2L3 + L2 + L4
+                &quot;movq %%mm1, (%%&quot;REG_a&quot;, %1)            \n\t&quot;
+                &quot;movq (%0, %1, 4), %%mm1                \n\t&quot; // L5
+                PAVGB(%%mm1, %%mm0)                           // L3+L5
+                PAVGB(%%mm2, %%mm0)                           // 2L4 + L3 + L5
+                &quot;movq %%mm0, (%%&quot;REG_a&quot;, %1, 2)         \n\t&quot;
+                &quot;movq (%%&quot;REG_d&quot;), %%mm0                \n\t&quot; // L6
+                PAVGB(%%mm0, %%mm2)                           // L4+L6
+                PAVGB(%%mm1, %%mm2)                           // 2L5 + L4 + L6
+                &quot;movq %%mm2, (%0, %1, 4)                \n\t&quot;
+                &quot;movq (%%&quot;REG_d&quot;, %1), %%mm2            \n\t&quot; // L7
+                PAVGB(%%mm2, %%mm1)                           // L5+L7
+                PAVGB(%%mm0, %%mm1)                           // 2L6 + L5 + L7
+                &quot;movq %%mm1, (%%&quot;REG_d&quot;)                \n\t&quot;
+                &quot;movq (%%&quot;REG_d&quot;, %1, 2), %%mm1         \n\t&quot; // L8
+                PAVGB(%%mm1, %%mm0)                           // L6+L8
+                PAVGB(%%mm2, %%mm0)                           // 2L7 + L6 + L8
+                &quot;movq %%mm0, (%%&quot;REG_d&quot;, %1)            \n\t&quot;
+                &quot;movq (%0, %1, 8), %%mm0                \n\t&quot; // L9
+                PAVGB(%%mm0, %%mm2)                           // L7+L9
+                PAVGB(%%mm1, %%mm2)                           // 2L8 + L7 + L9
+                &quot;movq %%mm2, (%%&quot;REG_d&quot;, %1, 2)         \n\t&quot;
+                &quot;movq %%mm1, (%2)                       \n\t&quot;
+
+                : : &quot;r&quot; (src), &quot;r&quot; ((long)stride), &quot;r&quot; (tmp)
+                : &quot;%&quot;REG_a, &quot;%&quot;REG_d
+        );
+#else //defined (HAVE_MMX2) || defined (HAVE_3DNOW)
+        int a, b, c, x;
+        src+= 4*stride;
+
+        for(x=0; x&lt;2; x++){
+                a= *(uint32_t*)&amp;tmp[stride*0];
+                b= *(uint32_t*)&amp;src[stride*0];
+                c= *(uint32_t*)&amp;src[stride*1];
+                a= (a&amp;c) + (((a^c)&amp;0xFEFEFEFEUL)&gt;&gt;1);
+                *(uint32_t*)&amp;src[stride*0]= (a|b) - (((a^b)&amp;0xFEFEFEFEUL)&gt;&gt;1);
+
+                a= *(uint32_t*)&amp;src[stride*2];
+                b= (a&amp;b) + (((a^b)&amp;0xFEFEFEFEUL)&gt;&gt;1);
+                *(uint32_t*)&amp;src[stride*1]= (c|b) - (((c^b)&amp;0xFEFEFEFEUL)&gt;&gt;1);
+
+                b= *(uint32_t*)&amp;src[stride*3];
+                c= (b&amp;c) + (((b^c)&amp;0xFEFEFEFEUL)&gt;&gt;1);
+                *(uint32_t*)&amp;src[stride*2]= (c|a) - (((c^a)&amp;0xFEFEFEFEUL)&gt;&gt;1);
+
+                c= *(uint32_t*)&amp;src[stride*4];
+                a= (a&amp;c) + (((a^c)&amp;0xFEFEFEFEUL)&gt;&gt;1);
+                *(uint32_t*)&amp;src[stride*3]= (a|b) - (((a^b)&amp;0xFEFEFEFEUL)&gt;&gt;1);
+
+                a= *(uint32_t*)&amp;src[stride*5];
+                b= (a&amp;b) + (((a^b)&amp;0xFEFEFEFEUL)&gt;&gt;1);
+                *(uint32_t*)&amp;src[stride*4]= (c|b) - (((c^b)&amp;0xFEFEFEFEUL)&gt;&gt;1);
+
+                b= *(uint32_t*)&amp;src[stride*6];
+                c= (b&amp;c) + (((b^c)&amp;0xFEFEFEFEUL)&gt;&gt;1);
+                *(uint32_t*)&amp;src[stride*5]= (c|a) - (((c^a)&amp;0xFEFEFEFEUL)&gt;&gt;1);
+
+                c= *(uint32_t*)&amp;src[stride*7];
+                a= (a&amp;c) + (((a^c)&amp;0xFEFEFEFEUL)&gt;&gt;1);
+                *(uint32_t*)&amp;src[stride*6]= (a|b) - (((a^b)&amp;0xFEFEFEFEUL)&gt;&gt;1);
+
+                a= *(uint32_t*)&amp;src[stride*8];
+                b= (a&amp;b) + (((a^b)&amp;0xFEFEFEFEUL)&gt;&gt;1);
+                *(uint32_t*)&amp;src[stride*7]= (c|b) - (((c^b)&amp;0xFEFEFEFEUL)&gt;&gt;1);
+
+                *(uint32_t*)&amp;tmp[stride*0]= c;
+                src += 4;
+                tmp += 4;
+        }
+#endif //defined (HAVE_MMX2) || defined (HAVE_3DNOW)
+}
+
+/**
+ * Deinterlaces the given block by applying a median filter to every second line.
+ * will be called for every 8x8 block and can read &amp; write from line 4-15,
+ * lines 0-3 have been passed through the deblock / dering filters allready, but can be read too
+ * lines 4-12 will be read into the deblocking filter and should be deinterlaced
+ */
+static inline void RENAME(deInterlaceMedian)(uint8_t src[], int stride)
+{
+#ifdef HAVE_MMX
+        src+= 4*stride;
+#ifdef HAVE_MMX2
+        asm volatile(
+                &quot;lea (%0, %1), %%&quot;REG_a&quot;                \n\t&quot;
+                &quot;lea (%%&quot;REG_a&quot;, %1, 4), %%&quot;REG_d&quot;      \n\t&quot;
+//      0       1       2       3       4       5       6       7       8       9
+//      %0      eax     eax+%1  eax+2%1 %0+4%1  edx     edx+%1  edx+2%1 %0+8%1  edx+4%1
+
+                &quot;movq (%0), %%mm0                       \n\t&quot; //
+                &quot;movq (%%&quot;REG_a&quot;, %1), %%mm2            \n\t&quot; //
+                &quot;movq (%%&quot;REG_a&quot;), %%mm1                \n\t&quot; //
+                &quot;movq %%mm0, %%mm3                      \n\t&quot;
+                &quot;pmaxub %%mm1, %%mm0                    \n\t&quot; //
+                &quot;pminub %%mm3, %%mm1                    \n\t&quot; //
+                &quot;pmaxub %%mm2, %%mm1                    \n\t&quot; //
+                &quot;pminub %%mm1, %%mm0                    \n\t&quot;
+                &quot;movq %%mm0, (%%&quot;REG_a&quot;)                \n\t&quot;
+
+                &quot;movq (%0, %1, 4), %%mm0                \n\t&quot; //
+                &quot;movq (%%&quot;REG_a&quot;, %1, 2), %%mm1         \n\t&quot; //
+                &quot;movq %%mm2, %%mm3                      \n\t&quot;
+                &quot;pmaxub %%mm1, %%mm2                    \n\t&quot; //
+                &quot;pminub %%mm3, %%mm1                    \n\t&quot; //
+                &quot;pmaxub %%mm0, %%mm1                    \n\t&quot; //
+                &quot;pminub %%mm1, %%mm2                    \n\t&quot;
+                &quot;movq %%mm2, (%%&quot;REG_a&quot;, %1, 2)         \n\t&quot;
+
+                &quot;movq (%%&quot;REG_d&quot;), %%mm2                \n\t&quot; //
+                &quot;movq (%%&quot;REG_d&quot;, %1), %%mm1            \n\t&quot; //
+                &quot;movq %%mm2, %%mm3                      \n\t&quot;
+                &quot;pmaxub %%mm0, %%mm2                    \n\t&quot; //
+                &quot;pminub %%mm3, %%mm0                    \n\t&quot; //
+                &quot;pmaxub %%mm1, %%mm0                    \n\t&quot; //
+                &quot;pminub %%mm0, %%mm2                    \n\t&quot;
+                &quot;movq %%mm2, (%%&quot;REG_d&quot;)                \n\t&quot;
+
+                &quot;movq (%%&quot;REG_d&quot;, %1, 2), %%mm2         \n\t&quot; //
+                &quot;movq (%0, %1, 8), %%mm0                \n\t&quot; //
+                &quot;movq %%mm2, %%mm3                      \n\t&quot;
+                &quot;pmaxub %%mm0, %%mm2                    \n\t&quot; //
+                &quot;pminub %%mm3, %%mm0                    \n\t&quot; //
+                &quot;pmaxub %%mm1, %%mm0                    \n\t&quot; //
+                &quot;pminub %%mm0, %%mm2                    \n\t&quot;
+                &quot;movq %%mm2, (%%&quot;REG_d&quot;, %1, 2)         \n\t&quot;
+
+
+                : : &quot;r&quot; (src), &quot;r&quot; ((long)stride)
+                : &quot;%&quot;REG_a, &quot;%&quot;REG_d
+        );
+
+#else // MMX without MMX2
+        asm volatile(
+                &quot;lea (%0, %1), %%&quot;REG_a&quot;                \n\t&quot;
+                &quot;lea (%%&quot;REG_a&quot;, %1, 4), %%&quot;REG_d&quot;      \n\t&quot;
+//      0       1       2       3       4       5       6       7       8       9
+//      %0      eax     eax+%1  eax+2%1 %0+4%1  edx     edx+%1  edx+2%1 %0+8%1  edx+4%1
+                &quot;pxor %%mm7, %%mm7                      \n\t&quot;
+
+#define REAL_MEDIAN(a,b,c)\
+                &quot;movq &quot; #a &quot;, %%mm0                     \n\t&quot;\
+                &quot;movq &quot; #b &quot;, %%mm2                     \n\t&quot;\
+                &quot;movq &quot; #c &quot;, %%mm1                     \n\t&quot;\
+                &quot;movq %%mm0, %%mm3                      \n\t&quot;\
+                &quot;movq %%mm1, %%mm4                      \n\t&quot;\
+                &quot;movq %%mm2, %%mm5                      \n\t&quot;\
+                &quot;psubusb %%mm1, %%mm3                   \n\t&quot;\
+                &quot;psubusb %%mm2, %%mm4                   \n\t&quot;\
+                &quot;psubusb %%mm0, %%mm5                   \n\t&quot;\
+                &quot;pcmpeqb %%mm7, %%mm3                   \n\t&quot;\
+                &quot;pcmpeqb %%mm7, %%mm4                   \n\t&quot;\
+                &quot;pcmpeqb %%mm7, %%mm5                   \n\t&quot;\
+                &quot;movq %%mm3, %%mm6                      \n\t&quot;\
+                &quot;pxor %%mm4, %%mm3                      \n\t&quot;\
+                &quot;pxor %%mm5, %%mm4                      \n\t&quot;\
+                &quot;pxor %%mm6, %%mm5                      \n\t&quot;\
+                &quot;por %%mm3, %%mm1                       \n\t&quot;\
+                &quot;por %%mm4, %%mm2                       \n\t&quot;\
+                &quot;por %%mm5, %%mm0                       \n\t&quot;\
+                &quot;pand %%mm2, %%mm0                      \n\t&quot;\
+                &quot;pand %%mm1, %%mm0                      \n\t&quot;\
+                &quot;movq %%mm0, &quot; #b &quot;                     \n\t&quot;
+#define MEDIAN(a,b,c)  REAL_MEDIAN(a,b,c)
+
+MEDIAN((%0)        , (%%REGa)       , (%%REGa, %1))
+MEDIAN((%%REGa, %1), (%%REGa, %1, 2), (%0, %1, 4))
+MEDIAN((%0, %1, 4) , (%%REGd)       , (%%REGd, %1))
+MEDIAN((%%REGd, %1), (%%REGd, %1, 2), (%0, %1, 8))
+
+                : : &quot;r&quot; (src), &quot;r&quot; ((long)stride)
+                : &quot;%&quot;REG_a, &quot;%&quot;REG_d
+        );
+#endif //HAVE_MMX2
+#else //HAVE_MMX
+        int x, y;
+        src+= 4*stride;
+        // FIXME - there should be a way to do a few columns in parallel like w/mmx
+        for(x=0; x&lt;8; x++)
+        {
+                uint8_t *colsrc = src;
+                for (y=0; y&lt;4; y++)
+                {
+                        int a, b, c, d, e, f;
+                        a = colsrc[0       ];
+                        b = colsrc[stride  ];
+                        c = colsrc[stride*2];
+                        d = (a-b)&gt;&gt;31;
+                        e = (b-c)&gt;&gt;31;
+                        f = (c-a)&gt;&gt;31;
+                        colsrc[stride  ] = (a|(d^f)) &amp; (b|(d^e)) &amp; (c|(e^f));
+                        colsrc += stride*2;
+                }
+                src++;
+        }
+#endif //HAVE_MMX
+}
+
+#ifdef HAVE_MMX
+/**
+ * transposes and shift the given 8x8 Block into dst1 and dst2
+ */
+static inline void RENAME(transpose1)(uint8_t *dst1, uint8_t *dst2, uint8_t *src, int srcStride)
+{
+        asm(
+                &quot;lea (%0, %1), %%&quot;REG_a&quot;                \n\t&quot;
+//      0       1       2       3       4       5       6       7       8       9
+//      %0      eax     eax+%1  eax+2%1 %0+4%1  edx     edx+%1  edx+2%1 %0+8%1  edx+4%1
+                &quot;movq (%0), %%mm0                       \n\t&quot; // 12345678
+                &quot;movq (%%&quot;REG_a&quot;), %%mm1                \n\t&quot; // abcdefgh
+                &quot;movq %%mm0, %%mm2                      \n\t&quot; // 12345678
+                &quot;punpcklbw %%mm1, %%mm0                 \n\t&quot; // 1a2b3c4d
+                &quot;punpckhbw %%mm1, %%mm2                 \n\t&quot; // 5e6f7g8h
+
+                &quot;movq (%%&quot;REG_a&quot;, %1), %%mm1            \n\t&quot;
+                &quot;movq (%%&quot;REG_a&quot;, %1, 2), %%mm3         \n\t&quot;
+                &quot;movq %%mm1, %%mm4                      \n\t&quot;
+                &quot;punpcklbw %%mm3, %%mm1                 \n\t&quot;
+                &quot;punpckhbw %%mm3, %%mm4                 \n\t&quot;
+
+                &quot;movq %%mm0, %%mm3                      \n\t&quot;
+                &quot;punpcklwd %%mm1, %%mm0                 \n\t&quot;
+                &quot;punpckhwd %%mm1, %%mm3                 \n\t&quot;
+                &quot;movq %%mm2, %%mm1                      \n\t&quot;
+                &quot;punpcklwd %%mm4, %%mm2                 \n\t&quot;
+                &quot;punpckhwd %%mm4, %%mm1                 \n\t&quot;
+
+                &quot;movd %%mm0, 128(%2)                    \n\t&quot;
+                &quot;psrlq $32, %%mm0                       \n\t&quot;
+                &quot;movd %%mm0, 144(%2)                    \n\t&quot;
+                &quot;movd %%mm3, 160(%2)                    \n\t&quot;
+                &quot;psrlq $32, %%mm3                       \n\t&quot;
+                &quot;movd %%mm3, 176(%2)                    \n\t&quot;
+                &quot;movd %%mm3, 48(%3)                     \n\t&quot;
+                &quot;movd %%mm2, 192(%2)                    \n\t&quot;
+                &quot;movd %%mm2, 64(%3)                     \n\t&quot;
+                &quot;psrlq $32, %%mm2                       \n\t&quot;
+                &quot;movd %%mm2, 80(%3)                     \n\t&quot;
+                &quot;movd %%mm1, 96(%3)                     \n\t&quot;
+                &quot;psrlq $32, %%mm1                       \n\t&quot;
+                &quot;movd %%mm1, 112(%3)                    \n\t&quot;
+
+                &quot;lea (%%&quot;REG_a&quot;, %1, 4), %%&quot;REG_a&quot;      \n\t&quot;
+
+                &quot;movq (%0, %1, 4), %%mm0                \n\t&quot; // 12345678
+                &quot;movq (%%&quot;REG_a&quot;), %%mm1                \n\t&quot; // abcdefgh
+                &quot;movq %%mm0, %%mm2                      \n\t&quot; // 12345678
+                &quot;punpcklbw %%mm1, %%mm0                 \n\t&quot; // 1a2b3c4d
+                &quot;punpckhbw %%mm1, %%mm2                 \n\t&quot; // 5e6f7g8h
+
+                &quot;movq (%%&quot;REG_a&quot;, %1), %%mm1            \n\t&quot;
+                &quot;movq (%%&quot;REG_a&quot;, %1, 2), %%mm3         \n\t&quot;
+                &quot;movq %%mm1, %%mm4                      \n\t&quot;
+                &quot;punpcklbw %%mm3, %%mm1                 \n\t&quot;
+                &quot;punpckhbw %%mm3, %%mm4                 \n\t&quot;
+
+                &quot;movq %%mm0, %%mm3                      \n\t&quot;
+                &quot;punpcklwd %%mm1, %%mm0                 \n\t&quot;
+                &quot;punpckhwd %%mm1, %%mm3                 \n\t&quot;
+                &quot;movq %%mm2, %%mm1                      \n\t&quot;
+                &quot;punpcklwd %%mm4, %%mm2                 \n\t&quot;
+                &quot;punpckhwd %%mm4, %%mm1                 \n\t&quot;
+
+                &quot;movd %%mm0, 132(%2)                    \n\t&quot;
+                &quot;psrlq $32, %%mm0                       \n\t&quot;
+                &quot;movd %%mm0, 148(%2)                    \n\t&quot;
+                &quot;movd %%mm3, 164(%2)                    \n\t&quot;
+                &quot;psrlq $32, %%mm3                       \n\t&quot;
+                &quot;movd %%mm3, 180(%2)                    \n\t&quot;
+                &quot;movd %%mm3, 52(%3)                     \n\t&quot;
+                &quot;movd %%mm2, 196(%2)                    \n\t&quot;
+                &quot;movd %%mm2, 68(%3)                     \n\t&quot;
+                &quot;psrlq $32, %%mm2                       \n\t&quot;
+                &quot;movd %%mm2, 84(%3)                     \n\t&quot;
+                &quot;movd %%mm1, 100(%3)                    \n\t&quot;
+                &quot;psrlq $32, %%mm1                       \n\t&quot;
+                &quot;movd %%mm1, 116(%3)                    \n\t&quot;
+
+
+        :: &quot;r&quot; (src), &quot;r&quot; ((long)srcStride), &quot;r&quot; (dst1), &quot;r&quot; (dst2)
+        : &quot;%&quot;REG_a
+        );
+}
+
+/**
+ * transposes the given 8x8 block
+ */
+static inline void RENAME(transpose2)(uint8_t *dst, int dstStride, uint8_t *src)
+{
+        asm(
+                &quot;lea (%0, %1), %%&quot;REG_a&quot;                \n\t&quot;
+                &quot;lea (%%&quot;REG_a&quot;,%1,4), %%&quot;REG_d&quot;        \n\t&quot;
+//      0       1       2       3       4       5       6       7       8       9
+//      %0      eax     eax+%1  eax+2%1 %0+4%1  edx     edx+%1  edx+2%1 %0+8%1  edx+4%1
+                &quot;movq (%2), %%mm0                       \n\t&quot; // 12345678
+                &quot;movq 16(%2), %%mm1                     \n\t&quot; // abcdefgh
+                &quot;movq %%mm0, %%mm2                      \n\t&quot; // 12345678
+                &quot;punpcklbw %%mm1, %%mm0                 \n\t&quot; // 1a2b3c4d
+                &quot;punpckhbw %%mm1, %%mm2                 \n\t&quot; // 5e6f7g8h
+
+                &quot;movq 32(%2), %%mm1                     \n\t&quot;
+                &quot;movq 48(%2), %%mm3                     \n\t&quot;
+                &quot;movq %%mm1, %%mm4                      \n\t&quot;
+                &quot;punpcklbw %%mm3, %%mm1                 \n\t&quot;
+                &quot;punpckhbw %%mm3, %%mm4                 \n\t&quot;
+
+                &quot;movq %%mm0, %%mm3                      \n\t&quot;
+                &quot;punpcklwd %%mm1, %%mm0                 \n\t&quot;
+                &quot;punpckhwd %%mm1, %%mm3                 \n\t&quot;
+                &quot;movq %%mm2, %%mm1                      \n\t&quot;
+                &quot;punpcklwd %%mm4, %%mm2                 \n\t&quot;
+                &quot;punpckhwd %%mm4, %%mm1                 \n\t&quot;
+
+                &quot;movd %%mm0, (%0)                       \n\t&quot;
+                &quot;psrlq $32, %%mm0                       \n\t&quot;
+                &quot;movd %%mm0, (%%&quot;REG_a&quot;)                \n\t&quot;
+                &quot;movd %%mm3, (%%&quot;REG_a&quot;, %1)            \n\t&quot;
+                &quot;psrlq $32, %%mm3                       \n\t&quot;
+                &quot;movd %%mm3, (%%&quot;REG_a&quot;, %1, 2)         \n\t&quot;
+                &quot;movd %%mm2, (%0, %1, 4)                \n\t&quot;
+                &quot;psrlq $32, %%mm2                       \n\t&quot;
+                &quot;movd %%mm2, (%%&quot;REG_d&quot;)                \n\t&quot;
+                &quot;movd %%mm1, (%%&quot;REG_d&quot;, %1)            \n\t&quot;
+                &quot;psrlq $32, %%mm1                       \n\t&quot;
+                &quot;movd %%mm1, (%%&quot;REG_d&quot;, %1, 2)         \n\t&quot;
+
+
+                &quot;movq 64(%2), %%mm0                     \n\t&quot; // 12345678
+                &quot;movq 80(%2), %%mm1                     \n\t&quot; // abcdefgh
+                &quot;movq %%mm0, %%mm2                      \n\t&quot; // 12345678
+                &quot;punpcklbw %%mm1, %%mm0                 \n\t&quot; // 1a2b3c4d
+                &quot;punpckhbw %%mm1, %%mm2                 \n\t&quot; // 5e6f7g8h
+
+                &quot;movq 96(%2), %%mm1                     \n\t&quot;
+                &quot;movq 112(%2), %%mm3                    \n\t&quot;
+                &quot;movq %%mm1, %%mm4                      \n\t&quot;
+                &quot;punpcklbw %%mm3, %%mm1                 \n\t&quot;
+                &quot;punpckhbw %%mm3, %%mm4                 \n\t&quot;
+
+                &quot;movq %%mm0, %%mm3                      \n\t&quot;
+                &quot;punpcklwd %%mm1, %%mm0                 \n\t&quot;
+                &quot;punpckhwd %%mm1, %%mm3                 \n\t&quot;
+                &quot;movq %%mm2, %%mm1                      \n\t&quot;
+                &quot;punpcklwd %%mm4, %%mm2                 \n\t&quot;
+                &quot;punpckhwd %%mm4, %%mm1                 \n\t&quot;
+
+                &quot;movd %%mm0, 4(%0)                      \n\t&quot;
+                &quot;psrlq $32, %%mm0                       \n\t&quot;
+                &quot;movd %%mm0, 4(%%&quot;REG_a&quot;)               \n\t&quot;
+                &quot;movd %%mm3, 4(%%&quot;REG_a&quot;, %1)           \n\t&quot;
+                &quot;psrlq $32, %%mm3                       \n\t&quot;
+                &quot;movd %%mm3, 4(%%&quot;REG_a&quot;, %1, 2)        \n\t&quot;
+                &quot;movd %%mm2, 4(%0, %1, 4)               \n\t&quot;
+                &quot;psrlq $32, %%mm2                       \n\t&quot;
+                &quot;movd %%mm2, 4(%%&quot;REG_d&quot;)               \n\t&quot;
+                &quot;movd %%mm1, 4(%%&quot;REG_d&quot;, %1)           \n\t&quot;
+                &quot;psrlq $32, %%mm1                       \n\t&quot;
+                &quot;movd %%mm1, 4(%%&quot;REG_d&quot;, %1, 2)        \n\t&quot;
+
+        :: &quot;r&quot; (dst), &quot;r&quot; ((long)dstStride), &quot;r&quot; (src)
+        : &quot;%&quot;REG_a, &quot;%&quot;REG_d
+        );
+}
+#endif //HAVE_MMX
+//static long test=0;
+
+#ifndef HAVE_ALTIVEC
+static inline void RENAME(tempNoiseReducer)(uint8_t *src, int stride,
+                                    uint8_t *tempBlured, uint32_t *tempBluredPast, int *maxNoise)
+{
+        // to save a register (FIXME do this outside of the loops)
+        tempBluredPast[127]= maxNoise[0];
+        tempBluredPast[128]= maxNoise[1];
+        tempBluredPast[129]= maxNoise[2];
+
+#define FAST_L2_DIFF
+//#define L1_DIFF //u should change the thresholds too if u try that one
+#if defined (HAVE_MMX2) || defined (HAVE_3DNOW)
+        asm volatile(
+                &quot;lea (%2, %2, 2), %%&quot;REG_a&quot;             \n\t&quot; // 3*stride
+                &quot;lea (%2, %2, 4), %%&quot;REG_d&quot;             \n\t&quot; // 5*stride
+                &quot;lea (%%&quot;REG_d&quot;, %2, 2), %%&quot;REG_c&quot;      \n\t&quot; // 7*stride
+//      0       1       2       3       4       5       6       7       8       9
+//      %x      %x+%2   %x+2%2  %x+eax  %x+4%2  %x+edx  %x+2eax %x+ecx  %x+8%2
+//FIXME reorder?
+#ifdef L1_DIFF //needs mmx2
+                &quot;movq (%0), %%mm0                       \n\t&quot; // L0
+                &quot;psadbw (%1), %%mm0                     \n\t&quot; // |L0-R0|
+                &quot;movq (%0, %2), %%mm1                   \n\t&quot; // L1
+                &quot;psadbw (%1, %2), %%mm1                 \n\t&quot; // |L1-R1|
+                &quot;movq (%0, %2, 2), %%mm2                \n\t&quot; // L2
+                &quot;psadbw (%1, %2, 2), %%mm2              \n\t&quot; // |L2-R2|
+                &quot;movq (%0, %%&quot;REG_a&quot;), %%mm3            \n\t&quot; // L3
+                &quot;psadbw (%1, %%&quot;REG_a&quot;), %%mm3          \n\t&quot; // |L3-R3|
+
+                &quot;movq (%0, %2, 4), %%mm4                \n\t&quot; // L4
+                &quot;paddw %%mm1, %%mm0                     \n\t&quot;
+                &quot;psadbw (%1, %2, 4), %%mm4              \n\t&quot; // |L4-R4|
+                &quot;movq (%0, %%&quot;REG_d&quot;), %%mm5            \n\t&quot; // L5
+                &quot;paddw %%mm2, %%mm0                     \n\t&quot;
+                &quot;psadbw (%1, %%&quot;REG_d&quot;), %%mm5          \n\t&quot; // |L5-R5|
+                &quot;movq (%0, %%&quot;REG_a&quot;, 2), %%mm6         \n\t&quot; // L6
+                &quot;paddw %%mm3, %%mm0                     \n\t&quot;
+                &quot;psadbw (%1, %%&quot;REG_a&quot;, 2), %%mm6       \n\t&quot; // |L6-R6|
+                &quot;movq (%0, %%&quot;REG_c&quot;), %%mm7            \n\t&quot; // L7
+                &quot;paddw %%mm4, %%mm0                     \n\t&quot;
+                &quot;psadbw (%1, %%&quot;REG_c&quot;), %%mm7          \n\t&quot; // |L7-R7|
+                &quot;paddw %%mm5, %%mm6                     \n\t&quot;
+                &quot;paddw %%mm7, %%mm6                     \n\t&quot;
+                &quot;paddw %%mm6, %%mm0                     \n\t&quot;
+#else //L1_DIFF
+#if defined (FAST_L2_DIFF)
+                &quot;pcmpeqb %%mm7, %%mm7                   \n\t&quot;
+                &quot;movq &quot;MANGLE(b80)&quot;, %%mm6              \n\t&quot;
+                &quot;pxor %%mm0, %%mm0                      \n\t&quot;
+#define REAL_L2_DIFF_CORE(a, b)\
+                &quot;movq &quot; #a &quot;, %%mm5                     \n\t&quot;\
+                &quot;movq &quot; #b &quot;, %%mm2                     \n\t&quot;\
+                &quot;pxor %%mm7, %%mm2                      \n\t&quot;\
+                PAVGB(%%mm2, %%mm5)\
+                &quot;paddb %%mm6, %%mm5                     \n\t&quot;\
+                &quot;movq %%mm5, %%mm2                      \n\t&quot;\
+                &quot;psllw $8, %%mm5                        \n\t&quot;\
+                &quot;pmaddwd %%mm5, %%mm5                   \n\t&quot;\
+                &quot;pmaddwd %%mm2, %%mm2                   \n\t&quot;\
+                &quot;paddd %%mm2, %%mm5                     \n\t&quot;\
+                &quot;psrld $14, %%mm5                       \n\t&quot;\
+                &quot;paddd %%mm5, %%mm0                     \n\t&quot;
+
+#else //defined (FAST_L2_DIFF)
+                &quot;pxor %%mm7, %%mm7                      \n\t&quot;
+                &quot;pxor %%mm0, %%mm0                      \n\t&quot;
+#define REAL_L2_DIFF_CORE(a, b)\
+                &quot;movq &quot; #a &quot;, %%mm5                     \n\t&quot;\
+                &quot;movq &quot; #b &quot;, %%mm2                     \n\t&quot;\
+                &quot;movq %%mm5, %%mm1                      \n\t&quot;\
+                &quot;movq %%mm2, %%mm3                      \n\t&quot;\
+                &quot;punpcklbw %%mm7, %%mm5                 \n\t&quot;\
+                &quot;punpckhbw %%mm7, %%mm1                 \n\t&quot;\
+                &quot;punpcklbw %%mm7, %%mm2                 \n\t&quot;\
+                &quot;punpckhbw %%mm7, %%mm3                 \n\t&quot;\
+                &quot;psubw %%mm2, %%mm5                     \n\t&quot;\
+                &quot;psubw %%mm3, %%mm1                     \n\t&quot;\
+                &quot;pmaddwd %%mm5, %%mm5                   \n\t&quot;\
+                &quot;pmaddwd %%mm1, %%mm1                   \n\t&quot;\
+                &quot;paddd %%mm1, %%mm5                     \n\t&quot;\
+                &quot;paddd %%mm5, %%mm0                     \n\t&quot;
+
+#endif //defined (FAST_L2_DIFF)
+
+#define L2_DIFF_CORE(a, b)  REAL_L2_DIFF_CORE(a, b)
+
+L2_DIFF_CORE((%0)          , (%1))
+L2_DIFF_CORE((%0, %2)      , (%1, %2))
+L2_DIFF_CORE((%0, %2, 2)   , (%1, %2, 2))
+L2_DIFF_CORE((%0, %%REGa)  , (%1, %%REGa))
+L2_DIFF_CORE((%0, %2, 4)   , (%1, %2, 4))
+L2_DIFF_CORE((%0, %%REGd)  , (%1, %%REGd))
+L2_DIFF_CORE((%0, %%REGa,2), (%1, %%REGa,2))
+L2_DIFF_CORE((%0, %%REGc)  , (%1, %%REGc))
+
+#endif //L1_DIFF
+
+                &quot;movq %%mm0, %%mm4                      \n\t&quot;
+                &quot;psrlq $32, %%mm0                       \n\t&quot;
+                &quot;paddd %%mm0, %%mm4                     \n\t&quot;
+                &quot;movd %%mm4, %%ecx                      \n\t&quot;
+                &quot;shll $2, %%ecx                         \n\t&quot;
+                &quot;mov %3, %%&quot;REG_d&quot;                      \n\t&quot;
+                &quot;addl -4(%%&quot;REG_d&quot;), %%ecx              \n\t&quot;
+                &quot;addl 4(%%&quot;REG_d&quot;), %%ecx               \n\t&quot;
+                &quot;addl -1024(%%&quot;REG_d&quot;), %%ecx           \n\t&quot;
+                &quot;addl $4, %%ecx                         \n\t&quot;
+                &quot;addl 1024(%%&quot;REG_d&quot;), %%ecx            \n\t&quot;
+                &quot;shrl $3, %%ecx                         \n\t&quot;
+                &quot;movl %%ecx, (%%&quot;REG_d&quot;)                \n\t&quot;
+
+//                &quot;mov %3, %%&quot;REG_c&quot;                      \n\t&quot;
+//                &quot;mov %%&quot;REG_c&quot;, test                    \n\t&quot;
+//                &quot;jmp 4f                                 \n\t&quot;
+                &quot;cmpl 512(%%&quot;REG_d&quot;), %%ecx             \n\t&quot;
+                &quot; jb 2f                                 \n\t&quot;
+                &quot;cmpl 516(%%&quot;REG_d&quot;), %%ecx             \n\t&quot;
+                &quot; jb 1f                                 \n\t&quot;
+
+                &quot;lea (%%&quot;REG_a&quot;, %2, 2), %%&quot;REG_d&quot;      \n\t&quot; // 5*stride
+                &quot;lea (%%&quot;REG_d&quot;, %2, 2), %%&quot;REG_c&quot;      \n\t&quot; // 7*stride
+                &quot;movq (%0), %%mm0                       \n\t&quot; // L0
+                &quot;movq (%0, %2), %%mm1                   \n\t&quot; // L1
+                &quot;movq (%0, %2, 2), %%mm2                \n\t&quot; // L2
+                &quot;movq (%0, %%&quot;REG_a&quot;), %%mm3            \n\t&quot; // L3
+                &quot;movq (%0, %2, 4), %%mm4                \n\t&quot; // L4
+                &quot;movq (%0, %%&quot;REG_d&quot;), %%mm5            \n\t&quot; // L5
+                &quot;movq (%0, %%&quot;REG_a&quot;, 2), %%mm6         \n\t&quot; // L6
+                &quot;movq (%0, %%&quot;REG_c&quot;), %%mm7            \n\t&quot; // L7
+                &quot;movq %%mm0, (%1)                       \n\t&quot; // L0
+                &quot;movq %%mm1, (%1, %2)                   \n\t&quot; // L1
+                &quot;movq %%mm2, (%1, %2, 2)                \n\t&quot; // L2
+                &quot;movq %%mm3, (%1, %%&quot;REG_a&quot;)            \n\t&quot; // L3
+                &quot;movq %%mm4, (%1, %2, 4)                \n\t&quot; // L4
+                &quot;movq %%mm5, (%1, %%&quot;REG_d&quot;)            \n\t&quot; // L5
+                &quot;movq %%mm6, (%1, %%&quot;REG_a&quot;, 2)         \n\t&quot; // L6
+                &quot;movq %%mm7, (%1, %%&quot;REG_c&quot;)            \n\t&quot; // L7
+                &quot;jmp 4f                                 \n\t&quot;
+
+                &quot;1:                                     \n\t&quot;
+                &quot;lea (%%&quot;REG_a&quot;, %2, 2), %%&quot;REG_d&quot;      \n\t&quot; // 5*stride
+                &quot;lea (%%&quot;REG_d&quot;, %2, 2), %%&quot;REG_c&quot;      \n\t&quot; // 7*stride
+                &quot;movq (%0), %%mm0                       \n\t&quot; // L0
+                PAVGB((%1), %%mm0)                            // L0
+                &quot;movq (%0, %2), %%mm1                   \n\t&quot; // L1
+                PAVGB((%1, %2), %%mm1)                        // L1
+                &quot;movq (%0, %2, 2), %%mm2                \n\t&quot; // L2
+                PAVGB((%1, %2, 2), %%mm2)                     // L2
+                &quot;movq (%0, %%&quot;REG_a&quot;), %%mm3            \n\t&quot; // L3
+                PAVGB((%1, %%REGa), %%mm3)                    // L3
+                &quot;movq (%0, %2, 4), %%mm4                \n\t&quot; // L4
+                PAVGB((%1, %2, 4), %%mm4)                     // L4
+                &quot;movq (%0, %%&quot;REG_d&quot;), %%mm5            \n\t&quot; // L5
+                PAVGB((%1, %%REGd), %%mm5)                    // L5
+                &quot;movq (%0, %%&quot;REG_a&quot;, 2), %%mm6         \n\t&quot; // L6
+                PAVGB((%1, %%REGa, 2), %%mm6)                 // L6
+                &quot;movq (%0, %%&quot;REG_c&quot;), %%mm7            \n\t&quot; // L7
+                PAVGB((%1, %%REGc), %%mm7)                    // L7
+                &quot;movq %%mm0, (%1)                       \n\t&quot; // R0
+                &quot;movq %%mm1, (%1, %2)                   \n\t&quot; // R1
+                &quot;movq %%mm2, (%1, %2, 2)                \n\t&quot; // R2
+                &quot;movq %%mm3, (%1, %%&quot;REG_a&quot;)            \n\t&quot; // R3
+                &quot;movq %%mm4, (%1, %2, 4)                \n\t&quot; // R4
+                &quot;movq %%mm5, (%1, %%&quot;REG_d&quot;)            \n\t&quot; // R5
+                &quot;movq %%mm6, (%1, %%&quot;REG_a&quot;, 2)         \n\t&quot; // R6
+                &quot;movq %%mm7, (%1, %%&quot;REG_c&quot;)            \n\t&quot; // R7
+                &quot;movq %%mm0, (%0)                       \n\t&quot; // L0
+                &quot;movq %%mm1, (%0, %2)                   \n\t&quot; // L1
+                &quot;movq %%mm2, (%0, %2, 2)                \n\t&quot; // L2
+                &quot;movq %%mm3, (%0, %%&quot;REG_a&quot;)            \n\t&quot; // L3
+                &quot;movq %%mm4, (%0, %2, 4)                \n\t&quot; // L4
+                &quot;movq %%mm5, (%0, %%&quot;REG_d&quot;)            \n\t&quot; // L5
+                &quot;movq %%mm6, (%0, %%&quot;REG_a&quot;, 2)         \n\t&quot; // L6
+                &quot;movq %%mm7, (%0, %%&quot;REG_c&quot;)            \n\t&quot; // L7
+                &quot;jmp 4f                                 \n\t&quot;
+
+                &quot;2:                                     \n\t&quot;
+                &quot;cmpl 508(%%&quot;REG_d&quot;), %%ecx             \n\t&quot;
+                &quot; jb 3f                                 \n\t&quot;
+
+                &quot;lea (%%&quot;REG_a&quot;, %2, 2), %%&quot;REG_d&quot;      \n\t&quot; // 5*stride
+                &quot;lea (%%&quot;REG_d&quot;, %2, 2), %%&quot;REG_c&quot;      \n\t&quot; // 7*stride
+                &quot;movq (%0), %%mm0                       \n\t&quot; // L0
+                &quot;movq (%0, %2), %%mm1                   \n\t&quot; // L1
+                &quot;movq (%0, %2, 2), %%mm2                \n\t&quot; // L2
+                &quot;movq (%0, %%&quot;REG_a&quot;), %%mm3            \n\t&quot; // L3
+                &quot;movq (%1), %%mm4                       \n\t&quot; // R0
+                &quot;movq (%1, %2), %%mm5                   \n\t&quot; // R1
+                &quot;movq (%1, %2, 2), %%mm6                \n\t&quot; // R2
+                &quot;movq (%1, %%&quot;REG_a&quot;), %%mm7            \n\t&quot; // R3
+                PAVGB(%%mm4, %%mm0)
+                PAVGB(%%mm5, %%mm1)
+                PAVGB(%%mm6, %%mm2)
+                PAVGB(%%mm7, %%mm3)
+                PAVGB(%%mm4, %%mm0)
+                PAVGB(%%mm5, %%mm1)
+                PAVGB(%%mm6, %%mm2)
+                PAVGB(%%mm7, %%mm3)
+                &quot;movq %%mm0, (%1)                       \n\t&quot; // R0
+                &quot;movq %%mm1, (%1, %2)                   \n\t&quot; // R1
+                &quot;movq %%mm2, (%1, %2, 2)                \n\t&quot; // R2
+                &quot;movq %%mm3, (%1, %%&quot;REG_a&quot;)            \n\t&quot; // R3
+                &quot;movq %%mm0, (%0)                       \n\t&quot; // L0
+                &quot;movq %%mm1, (%0, %2)                   \n\t&quot; // L1
+                &quot;movq %%mm2, (%0, %2, 2)                \n\t&quot; // L2
+                &quot;movq %%mm3, (%0, %%&quot;REG_a&quot;)            \n\t&quot; // L3
+
+                &quot;movq (%0, %2, 4), %%mm0                \n\t&quot; // L4
+                &quot;movq (%0, %%&quot;REG_d&quot;), %%mm1            \n\t&quot; // L5
+                &quot;movq (%0, %%&quot;REG_a&quot;, 2), %%mm2         \n\t&quot; // L6
+                &quot;movq (%0, %%&quot;REG_c&quot;), %%mm3            \n\t&quot; // L7
+                &quot;movq (%1, %2, 4), %%mm4                \n\t&quot; // R4
+                &quot;movq (%1, %%&quot;REG_d&quot;), %%mm5            \n\t&quot; // R5
+                &quot;movq (%1, %%&quot;REG_a&quot;, 2), %%mm6         \n\t&quot; // R6
+                &quot;movq (%1, %%&quot;REG_c&quot;), %%mm7            \n\t&quot; // R7
+                PAVGB(%%mm4, %%mm0)
+                PAVGB(%%mm5, %%mm1)
+                PAVGB(%%mm6, %%mm2)
+                PAVGB(%%mm7, %%mm3)
+                PAVGB(%%mm4, %%mm0)
+                PAVGB(%%mm5, %%mm1)
+                PAVGB(%%mm6, %%mm2)
+                PAVGB(%%mm7, %%mm3)
+                &quot;movq %%mm0, (%1, %2, 4)                \n\t&quot; // R4
+                &quot;movq %%mm1, (%1, %%&quot;REG_d&quot;)            \n\t&quot; // R5
+                &quot;movq %%mm2, (%1, %%&quot;REG_a&quot;, 2)         \n\t&quot; // R6
+                &quot;movq %%mm3, (%1, %%&quot;REG_c&quot;)            \n\t&quot; // R7
+                &quot;movq %%mm0, (%0, %2, 4)                \n\t&quot; // L4
+                &quot;movq %%mm1, (%0, %%&quot;REG_d&quot;)            \n\t&quot; // L5
+                &quot;movq %%mm2, (%0, %%&quot;REG_a&quot;, 2)         \n\t&quot; // L6
+                &quot;movq %%mm3, (%0, %%&quot;REG_c&quot;)            \n\t&quot; // L7
+                &quot;jmp 4f                                 \n\t&quot;
+
+                &quot;3:                                     \n\t&quot;
+                &quot;lea (%%&quot;REG_a&quot;, %2, 2), %%&quot;REG_d&quot;      \n\t&quot; // 5*stride
+                &quot;lea (%%&quot;REG_d&quot;, %2, 2), %%&quot;REG_c&quot;      \n\t&quot; // 7*stride
+                &quot;movq (%0), %%mm0                       \n\t&quot; // L0
+                &quot;movq (%0, %2), %%mm1                   \n\t&quot; // L1
+                &quot;movq (%0, %2, 2), %%mm2                \n\t&quot; // L2
+                &quot;movq (%0, %%&quot;REG_a&quot;), %%mm3            \n\t&quot; // L3
+                &quot;movq (%1), %%mm4                       \n\t&quot; // R0
+                &quot;movq (%1, %2), %%mm5                   \n\t&quot; // R1
+                &quot;movq (%1, %2, 2), %%mm6                \n\t&quot; // R2
+                &quot;movq (%1, %%&quot;REG_a&quot;), %%mm7            \n\t&quot; // R3
+                PAVGB(%%mm4, %%mm0)
+                PAVGB(%%mm5, %%mm1)
+                PAVGB(%%mm6, %%mm2)
+                PAVGB(%%mm7, %%mm3)
+                PAVGB(%%mm4, %%mm0)
+                PAVGB(%%mm5, %%mm1)
+                PAVGB(%%mm6, %%mm2)
+                PAVGB(%%mm7, %%mm3)
+                PAVGB(%%mm4, %%mm0)
+                PAVGB(%%mm5, %%mm1)
+                PAVGB(%%mm6, %%mm2)
+                PAVGB(%%mm7, %%mm3)
+                &quot;movq %%mm0, (%1)                       \n\t&quot; // R0
+                &quot;movq %%mm1, (%1, %2)                   \n\t&quot; // R1
+                &quot;movq %%mm2, (%1, %2, 2)                \n\t&quot; // R2
+                &quot;movq %%mm3, (%1, %%&quot;REG_a&quot;)            \n\t&quot; // R3
+                &quot;movq %%mm0, (%0)                       \n\t&quot; // L0
+                &quot;movq %%mm1, (%0, %2)                   \n\t&quot; // L1
+                &quot;movq %%mm2, (%0, %2, 2)                \n\t&quot; // L2
+                &quot;movq %%mm3, (%0, %%&quot;REG_a&quot;)            \n\t&quot; // L3
+
+                &quot;movq (%0, %2, 4), %%mm0                \n\t&quot; // L4
+                &quot;movq (%0, %%&quot;REG_d&quot;), %%mm1            \n\t&quot; // L5
+                &quot;movq (%0, %%&quot;REG_a&quot;, 2), %%mm2         \n\t&quot; // L6
+                &quot;movq (%0, %%&quot;REG_c&quot;), %%mm3            \n\t&quot; // L7
+                &quot;movq (%1, %2, 4), %%mm4                \n\t&quot; // R4
+                &quot;movq (%1, %%&quot;REG_d&quot;), %%mm5            \n\t&quot; // R5
+                &quot;movq (%1, %%&quot;REG_a&quot;, 2), %%mm6         \n\t&quot; // R6
+                &quot;movq (%1, %%&quot;REG_c&quot;), %%mm7            \n\t&quot; // R7
+                PAVGB(%%mm4, %%mm0)
+                PAVGB(%%mm5, %%mm1)
+                PAVGB(%%mm6, %%mm2)
+                PAVGB(%%mm7, %%mm3)
+                PAVGB(%%mm4, %%mm0)
+                PAVGB(%%mm5, %%mm1)
+                PAVGB(%%mm6, %%mm2)
+                PAVGB(%%mm7, %%mm3)
+                PAVGB(%%mm4, %%mm0)
+                PAVGB(%%mm5, %%mm1)
+                PAVGB(%%mm6, %%mm2)
+                PAVGB(%%mm7, %%mm3)
+                &quot;movq %%mm0, (%1, %2, 4)                \n\t&quot; // R4
+                &quot;movq %%mm1, (%1, %%&quot;REG_d&quot;)            \n\t&quot; // R5
+                &quot;movq %%mm2, (%1, %%&quot;REG_a&quot;, 2)         \n\t&quot; // R6
+                &quot;movq %%mm3, (%1, %%&quot;REG_c&quot;)            \n\t&quot; // R7
+                &quot;movq %%mm0, (%0, %2, 4)                \n\t&quot; // L4
+                &quot;movq %%mm1, (%0, %%&quot;REG_d&quot;)            \n\t&quot; // L5
+                &quot;movq %%mm2, (%0, %%&quot;REG_a&quot;, 2)         \n\t&quot; // L6
+                &quot;movq %%mm3, (%0, %%&quot;REG_c&quot;)            \n\t&quot; // L7
+
+                &quot;4:                                     \n\t&quot;
+
+                :: &quot;r&quot; (src), &quot;r&quot; (tempBlured), &quot;r&quot;((long)stride), &quot;m&quot; (tempBluredPast)
+                : &quot;%&quot;REG_a, &quot;%&quot;REG_d, &quot;%&quot;REG_c, &quot;memory&quot;
+                );
+#else //defined (HAVE_MMX2) || defined (HAVE_3DNOW)
+{
+        int y;
+        int d=0;
+//        int sysd=0;
+        int i;
+
+        for(y=0; y&lt;8; y++)
+        {
+                int x;
+                for(x=0; x&lt;8; x++)
+                {
+                        int ref= tempBlured[ x + y*stride ];
+                        int cur= src[ x + y*stride ];
+                        int d1=ref - cur;
+//                        if(x==0 || x==7) d1+= d1&gt;&gt;1;
+//                        if(y==0 || y==7) d1+= d1&gt;&gt;1;
+//                        d+= FFABS(d1);
+                        d+= d1*d1;
+//                        sysd+= d1;
+                }
+        }
+        i=d;
+        d=         (
+                4*d
+                +(*(tempBluredPast-256))
+                +(*(tempBluredPast-1))+ (*(tempBluredPast+1))
+                +(*(tempBluredPast+256))
+                +4)&gt;&gt;3;
+        *tempBluredPast=i;
+//        ((*tempBluredPast)*3 + d + 2)&gt;&gt;2;
+
+/*
+Switch between
+ 1  0  0  0  0  0  0  (0)
+64 32 16  8  4  2  1  (1)
+64 48 36 27 20 15 11 (33) (approx)
+64 56 49 43 37 33 29 (200) (approx)
+*/
+        if(d &gt; maxNoise[1])
+        {
+                if(d &lt; maxNoise[2])
+                {
+                        for(y=0; y&lt;8; y++)
+                        {
+                                int x;
+                                for(x=0; x&lt;8; x++)
+                                {
+                                        int ref= tempBlured[ x + y*stride ];
+                                        int cur= src[ x + y*stride ];
+                                        tempBlured[ x + y*stride ]=
+                                        src[ x + y*stride ]=
+                                                (ref + cur + 1)&gt;&gt;1;
+                                }
+                        }
+                }
+                else
+                {
+                        for(y=0; y&lt;8; y++)
+                        {
+                                int x;
+                                for(x=0; x&lt;8; x++)
+                                {
+                                        tempBlured[ x + y*stride ]= src[ x + y*stride ];
+                                }
+                        }
+                }
+        }
+        else
+        {
+                if(d &lt; maxNoise[0])
+                {
+                        for(y=0; y&lt;8; y++)
+                        {
+                                int x;
+                                for(x=0; x&lt;8; x++)
+                                {
+                                        int ref= tempBlured[ x + y*stride ];
+                                        int cur= src[ x + y*stride ];
+                                        tempBlured[ x + y*stride ]=
+                                        src[ x + y*stride ]=
+                                                (ref*7 + cur + 4)&gt;&gt;3;
+                                }
+                        }
+                }
+                else
+                {
+                        for(y=0; y&lt;8; y++)
+                        {
+                                int x;
+                                for(x=0; x&lt;8; x++)
+                                {
+                                        int ref= tempBlured[ x + y*stride ];
+                                        int cur= src[ x + y*stride ];
+                                        tempBlured[ x + y*stride ]=
+                                        src[ x + y*stride ]=
+                                                (ref*3 + cur + 2)&gt;&gt;2;
+                                }
+                        }
+                }
+        }
+}
+#endif //defined (HAVE_MMX2) || defined (HAVE_3DNOW)
+}
+#endif //HAVE_ALTIVEC
+
+#ifdef HAVE_MMX
+/**
+ * accurate deblock filter
+ */
+static av_always_inline void RENAME(do_a_deblock)(uint8_t *src, int step, int stride, PPContext *c){
+        int64_t dc_mask, eq_mask, both_masks;
+        int64_t sums[10*8*2];
+        src+= step*3; // src points to begin of the 8x8 Block
+//START_TIMER
+asm volatile(
+                &quot;movq %0, %%mm7                         \n\t&quot;
+                &quot;movq %1, %%mm6                         \n\t&quot;
+                : : &quot;m&quot; (c-&gt;mmxDcOffset[c-&gt;nonBQP]),  &quot;m&quot; (c-&gt;mmxDcThreshold[c-&gt;nonBQP])
+                );
+
+asm volatile(
+                &quot;lea (%2, %3), %%&quot;REG_a&quot;                \n\t&quot;
+//      0       1       2       3       4       5       6       7       8       9
+//      %1      eax     eax+%2  eax+2%2 %1+4%2  ecx     ecx+%2  ecx+2%2 %1+8%2  ecx+4%2
+
+                &quot;movq (%2), %%mm0                       \n\t&quot;
+                &quot;movq (%%&quot;REG_a&quot;), %%mm1                \n\t&quot;
+                &quot;movq %%mm1, %%mm3                      \n\t&quot;
+                &quot;movq %%mm1, %%mm4                      \n\t&quot;
+                &quot;psubb %%mm1, %%mm0                     \n\t&quot; // mm0 = differnece
+                &quot;paddb %%mm7, %%mm0                     \n\t&quot;
+                &quot;pcmpgtb %%mm6, %%mm0                   \n\t&quot;
+
+                &quot;movq (%%&quot;REG_a&quot;,%3), %%mm2             \n\t&quot;
+                PMAXUB(%%mm2, %%mm4)
+                PMINUB(%%mm2, %%mm3, %%mm5)
+                &quot;psubb %%mm2, %%mm1                     \n\t&quot;
+                &quot;paddb %%mm7, %%mm1                     \n\t&quot;
+                &quot;pcmpgtb %%mm6, %%mm1                   \n\t&quot;
+                &quot;paddb %%mm1, %%mm0                     \n\t&quot;
+
+                &quot;movq (%%&quot;REG_a&quot;, %3, 2), %%mm1         \n\t&quot;
+                PMAXUB(%%mm1, %%mm4)
+                PMINUB(%%mm1, %%mm3, %%mm5)
+                &quot;psubb %%mm1, %%mm2                     \n\t&quot;
+                &quot;paddb %%mm7, %%mm2                     \n\t&quot;
+                &quot;pcmpgtb %%mm6, %%mm2                   \n\t&quot;
+                &quot;paddb %%mm2, %%mm0                     \n\t&quot;
+
+                &quot;lea (%%&quot;REG_a&quot;, %3, 4), %%&quot;REG_a&quot;      \n\t&quot;
+
+                &quot;movq (%2, %3, 4), %%mm2                \n\t&quot;
+                PMAXUB(%%mm2, %%mm4)
+                PMINUB(%%mm2, %%mm3, %%mm5)
+                &quot;psubb %%mm2, %%mm1                     \n\t&quot;
+                &quot;paddb %%mm7, %%mm1                     \n\t&quot;
+                &quot;pcmpgtb %%mm6, %%mm1                   \n\t&quot;
+                &quot;paddb %%mm1, %%mm0                     \n\t&quot;
+
+                &quot;movq (%%&quot;REG_a&quot;), %%mm1                \n\t&quot;
+                PMAXUB(%%mm1, %%mm4)
+                PMINUB(%%mm1, %%mm3, %%mm5)
+                &quot;psubb %%mm1, %%mm2                     \n\t&quot;
+                &quot;paddb %%mm7, %%mm2                     \n\t&quot;
+                &quot;pcmpgtb %%mm6, %%mm2                   \n\t&quot;
+                &quot;paddb %%mm2, %%mm0                     \n\t&quot;
+
+                &quot;movq (%%&quot;REG_a&quot;, %3), %%mm2            \n\t&quot;
+                PMAXUB(%%mm2, %%mm4)
+                PMINUB(%%mm2, %%mm3, %%mm5)
+                &quot;psubb %%mm2, %%mm1                     \n\t&quot;
+                &quot;paddb %%mm7, %%mm1                     \n\t&quot;
+                &quot;pcmpgtb %%mm6, %%mm1                   \n\t&quot;
+                &quot;paddb %%mm1, %%mm0                     \n\t&quot;
+
+                &quot;movq (%%&quot;REG_a&quot;, %3, 2), %%mm1         \n\t&quot;
+                PMAXUB(%%mm1, %%mm4)
+                PMINUB(%%mm1, %%mm3, %%mm5)
+                &quot;psubb %%mm1, %%mm2                     \n\t&quot;
+                &quot;paddb %%mm7, %%mm2                     \n\t&quot;
+                &quot;pcmpgtb %%mm6, %%mm2                   \n\t&quot;
+                &quot;paddb %%mm2, %%mm0                     \n\t&quot;
+
+                &quot;movq (%2, %3, 8), %%mm2                \n\t&quot;
+                PMAXUB(%%mm2, %%mm4)
+                PMINUB(%%mm2, %%mm3, %%mm5)
+                &quot;psubb %%mm2, %%mm1                     \n\t&quot;
+                &quot;paddb %%mm7, %%mm1                     \n\t&quot;
+                &quot;pcmpgtb %%mm6, %%mm1                   \n\t&quot;
+                &quot;paddb %%mm1, %%mm0                     \n\t&quot;
+
+                &quot;movq (%%&quot;REG_a&quot;, %3, 4), %%mm1         \n\t&quot;
+                &quot;psubb %%mm1, %%mm2                     \n\t&quot;
+                &quot;paddb %%mm7, %%mm2                     \n\t&quot;
+                &quot;pcmpgtb %%mm6, %%mm2                   \n\t&quot;
+                &quot;paddb %%mm2, %%mm0                     \n\t&quot;
+                &quot;psubusb %%mm3, %%mm4                   \n\t&quot;
+
+                &quot;pxor %%mm6, %%mm6                      \n\t&quot;
+                &quot;movq %4, %%mm7                         \n\t&quot; // QP,..., QP
+                &quot;paddusb %%mm7, %%mm7                   \n\t&quot; // 2QP ... 2QP
+                &quot;psubusb %%mm4, %%mm7                   \n\t&quot; // Diff &gt;=2QP -&gt; 0
+                &quot;pcmpeqb %%mm6, %%mm7                   \n\t&quot; // Diff &lt; 2QP -&gt; 0
+                &quot;pcmpeqb %%mm6, %%mm7                   \n\t&quot; // Diff &lt; 2QP -&gt; 0
+                &quot;movq %%mm7, %1                         \n\t&quot;
+
+                &quot;movq %5, %%mm7                         \n\t&quot;
+                &quot;punpcklbw %%mm7, %%mm7                 \n\t&quot;
+                &quot;punpcklbw %%mm7, %%mm7                 \n\t&quot;
+                &quot;punpcklbw %%mm7, %%mm7                 \n\t&quot;
+                &quot;psubb %%mm0, %%mm6                     \n\t&quot;
+                &quot;pcmpgtb %%mm7, %%mm6                   \n\t&quot;
+                &quot;movq %%mm6, %0                         \n\t&quot;
+
+                : &quot;=m&quot; (eq_mask), &quot;=m&quot; (dc_mask)
+                : &quot;r&quot; (src), &quot;r&quot; ((long)step), &quot;m&quot; (c-&gt;pQPb), &quot;m&quot;(c-&gt;ppMode.flatnessThreshold)
+                : &quot;%&quot;REG_a
+                );
+
+        both_masks = dc_mask &amp; eq_mask;
+
+        if(both_masks){
+                long offset= -8*step;
+                int64_t *temp_sums= sums;
+
+                asm volatile(
+                &quot;movq %2, %%mm0                         \n\t&quot;  // QP,..., QP
+                &quot;pxor %%mm4, %%mm4                      \n\t&quot;
+
+                &quot;movq (%0), %%mm6                       \n\t&quot;
+                &quot;movq (%0, %1), %%mm5                   \n\t&quot;
+                &quot;movq %%mm5, %%mm1                      \n\t&quot;
+                &quot;movq %%mm6, %%mm2                      \n\t&quot;
+                &quot;psubusb %%mm6, %%mm5                   \n\t&quot;
+                &quot;psubusb %%mm1, %%mm2                   \n\t&quot;
+                &quot;por %%mm5, %%mm2                       \n\t&quot; // ABS Diff of lines
+                &quot;psubusb %%mm2, %%mm0                   \n\t&quot; // diff &gt;= QP -&gt; 0
+                &quot;pcmpeqb %%mm4, %%mm0                   \n\t&quot; // diff &gt;= QP -&gt; FF
+
+                &quot;pxor %%mm6, %%mm1                      \n\t&quot;
+                &quot;pand %%mm0, %%mm1                      \n\t&quot;
+                &quot;pxor %%mm1, %%mm6                      \n\t&quot;
+                // 0:QP  6:First
+
+                &quot;movq (%0, %1, 8), %%mm5                \n\t&quot;
+                &quot;add %1, %0                             \n\t&quot; // %0 points to line 1 not 0
+                &quot;movq (%0, %1, 8), %%mm7                \n\t&quot;
+                &quot;movq %%mm5, %%mm1                      \n\t&quot;
+                &quot;movq %%mm7, %%mm2                      \n\t&quot;
+                &quot;psubusb %%mm7, %%mm5                   \n\t&quot;
+                &quot;psubusb %%mm1, %%mm2                   \n\t&quot;
+                &quot;por %%mm5, %%mm2                       \n\t&quot; // ABS Diff of lines
+                &quot;movq %2, %%mm0                         \n\t&quot;  // QP,..., QP
+                &quot;psubusb %%mm2, %%mm0                   \n\t&quot; // diff &gt;= QP -&gt; 0
+                &quot;pcmpeqb %%mm4, %%mm0                   \n\t&quot; // diff &gt;= QP -&gt; FF
+
+                &quot;pxor %%mm7, %%mm1                      \n\t&quot;
+                &quot;pand %%mm0, %%mm1                      \n\t&quot;
+                &quot;pxor %%mm1, %%mm7                      \n\t&quot;
+
+                &quot;movq %%mm6, %%mm5                      \n\t&quot;
+                &quot;punpckhbw %%mm4, %%mm6                 \n\t&quot;
+                &quot;punpcklbw %%mm4, %%mm5                 \n\t&quot;
+                // 4:0 5/6:First 7:Last
+
+                &quot;movq %%mm5, %%mm0                      \n\t&quot;
+                &quot;movq %%mm6, %%mm1                      \n\t&quot;
+                &quot;psllw $2, %%mm0                        \n\t&quot;
+                &quot;psllw $2, %%mm1                        \n\t&quot;
+                &quot;paddw &quot;MANGLE(w04)&quot;, %%mm0             \n\t&quot;
+                &quot;paddw &quot;MANGLE(w04)&quot;, %%mm1             \n\t&quot;
+
+#define NEXT\
+                &quot;movq (%0), %%mm2                       \n\t&quot;\
+                &quot;movq (%0), %%mm3                       \n\t&quot;\
+                &quot;add %1, %0                             \n\t&quot;\
+                &quot;punpcklbw %%mm4, %%mm2                 \n\t&quot;\
+                &quot;punpckhbw %%mm4, %%mm3                 \n\t&quot;\
+                &quot;paddw %%mm2, %%mm0                     \n\t&quot;\
+                &quot;paddw %%mm3, %%mm1                     \n\t&quot;
+
+#define PREV\
+                &quot;movq (%0), %%mm2                       \n\t&quot;\
+                &quot;movq (%0), %%mm3                       \n\t&quot;\
+                &quot;add %1, %0                             \n\t&quot;\
+                &quot;punpcklbw %%mm4, %%mm2                 \n\t&quot;\
+                &quot;punpckhbw %%mm4, %%mm3                 \n\t&quot;\
+                &quot;psubw %%mm2, %%mm0                     \n\t&quot;\
+                &quot;psubw %%mm3, %%mm1                     \n\t&quot;
+
+
+                NEXT //0
+                NEXT //1
+                NEXT //2
+                &quot;movq %%mm0, (%3)                       \n\t&quot;
+                &quot;movq %%mm1, 8(%3)                      \n\t&quot;
+
+                NEXT //3
+                &quot;psubw %%mm5, %%mm0                     \n\t&quot;
+                &quot;psubw %%mm6, %%mm1                     \n\t&quot;
+                &quot;movq %%mm0, 16(%3)                     \n\t&quot;
+                &quot;movq %%mm1, 24(%3)                     \n\t&quot;
+
+                NEXT //4
+                &quot;psubw %%mm5, %%mm0                     \n\t&quot;
+                &quot;psubw %%mm6, %%mm1                     \n\t&quot;
+                &quot;movq %%mm0, 32(%3)                     \n\t&quot;
+                &quot;movq %%mm1, 40(%3)                     \n\t&quot;
+
+                NEXT //5
+                &quot;psubw %%mm5, %%mm0                     \n\t&quot;
+                &quot;psubw %%mm6, %%mm1                     \n\t&quot;
+                &quot;movq %%mm0, 48(%3)                     \n\t&quot;
+                &quot;movq %%mm1, 56(%3)                     \n\t&quot;
+
+                NEXT //6
+                &quot;psubw %%mm5, %%mm0                     \n\t&quot;
+                &quot;psubw %%mm6, %%mm1                     \n\t&quot;
+                &quot;movq %%mm0, 64(%3)                     \n\t&quot;
+                &quot;movq %%mm1, 72(%3)                     \n\t&quot;
+
+                &quot;movq %%mm7, %%mm6                      \n\t&quot;
+                &quot;punpckhbw %%mm4, %%mm7                 \n\t&quot;
+                &quot;punpcklbw %%mm4, %%mm6                 \n\t&quot;
+
+                NEXT //7
+                &quot;mov %4, %0                             \n\t&quot;
+                &quot;add %1, %0                             \n\t&quot;
+                PREV //0
+                &quot;movq %%mm0, 80(%3)                     \n\t&quot;
+                &quot;movq %%mm1, 88(%3)                     \n\t&quot;
+
+                PREV //1
+                &quot;paddw %%mm6, %%mm0                     \n\t&quot;
+                &quot;paddw %%mm7, %%mm1                     \n\t&quot;
+                &quot;movq %%mm0, 96(%3)                     \n\t&quot;
+                &quot;movq %%mm1, 104(%3)                    \n\t&quot;
+
+                PREV //2
+                &quot;paddw %%mm6, %%mm0                     \n\t&quot;
+                &quot;paddw %%mm7, %%mm1                     \n\t&quot;
+                &quot;movq %%mm0, 112(%3)                    \n\t&quot;
+                &quot;movq %%mm1, 120(%3)                    \n\t&quot;
+
+                PREV //3
+                &quot;paddw %%mm6, %%mm0                     \n\t&quot;
+                &quot;paddw %%mm7, %%mm1                     \n\t&quot;
+                &quot;movq %%mm0, 128(%3)                    \n\t&quot;
+                &quot;movq %%mm1, 136(%3)                    \n\t&quot;
+
+                PREV //4
+                &quot;paddw %%mm6, %%mm0                     \n\t&quot;
+                &quot;paddw %%mm7, %%mm1                     \n\t&quot;
+                &quot;movq %%mm0, 144(%3)                    \n\t&quot;
+                &quot;movq %%mm1, 152(%3)                    \n\t&quot;
+
+                &quot;mov %4, %0                             \n\t&quot; //FIXME
+
+                : &quot;+&amp;r&quot;(src)
+                : &quot;r&quot; ((long)step), &quot;m&quot; (c-&gt;pQPb), &quot;r&quot;(sums), &quot;g&quot;(src)
+                );
+
+                src+= step; // src points to begin of the 8x8 Block
+
+                asm volatile(
+                &quot;movq %4, %%mm6                         \n\t&quot;
+                &quot;pcmpeqb %%mm5, %%mm5                   \n\t&quot;
+                &quot;pxor %%mm6, %%mm5                      \n\t&quot;
+                &quot;pxor %%mm7, %%mm7                      \n\t&quot;
+
+                &quot;1:                                     \n\t&quot;
+                &quot;movq (%1), %%mm0                       \n\t&quot;
+                &quot;movq 8(%1), %%mm1                      \n\t&quot;
+                &quot;paddw 32(%1), %%mm0                    \n\t&quot;
+                &quot;paddw 40(%1), %%mm1                    \n\t&quot;
+                &quot;movq (%0, %3), %%mm2                   \n\t&quot;
+                &quot;movq %%mm2, %%mm3                      \n\t&quot;
+                &quot;movq %%mm2, %%mm4                      \n\t&quot;
+                &quot;punpcklbw %%mm7, %%mm2                 \n\t&quot;
+                &quot;punpckhbw %%mm7, %%mm3                 \n\t&quot;
+                &quot;paddw %%mm2, %%mm0                     \n\t&quot;
+                &quot;paddw %%mm3, %%mm1                     \n\t&quot;
+                &quot;paddw %%mm2, %%mm0                     \n\t&quot;
+                &quot;paddw %%mm3, %%mm1                     \n\t&quot;
+                &quot;psrlw $4, %%mm0                        \n\t&quot;
+                &quot;psrlw $4, %%mm1                        \n\t&quot;
+                &quot;packuswb %%mm1, %%mm0                  \n\t&quot;
+                &quot;pand %%mm6, %%mm0                      \n\t&quot;
+                &quot;pand %%mm5, %%mm4                      \n\t&quot;
+                &quot;por %%mm4, %%mm0                       \n\t&quot;
+                &quot;movq %%mm0, (%0, %3)                   \n\t&quot;
+                &quot;add $16, %1                            \n\t&quot;
+                &quot;add %2, %0                             \n\t&quot;
+                &quot; js 1b                                 \n\t&quot;
+
+                : &quot;+r&quot;(offset), &quot;+r&quot;(temp_sums)
+                : &quot;r&quot; ((long)step), &quot;r&quot;(src - offset), &quot;m&quot;(both_masks)
+                );
+        }else
+                src+= step; // src points to begin of the 8x8 Block
+
+        if(eq_mask != -1LL){
+                uint8_t *temp_src= src;
+                asm volatile(
+                &quot;pxor %%mm7, %%mm7                      \n\t&quot;
+                &quot;lea -40(%%&quot;REG_SP&quot;), %%&quot;REG_c&quot;         \n\t&quot; // make space for 4 8-byte vars
+                &quot;and &quot;ALIGN_MASK&quot;, %%&quot;REG_c&quot;            \n\t&quot; // align
+//      0       1       2       3       4       5       6       7       8       9
+//      %0      eax     eax+%1  eax+2%1 %0+4%1  ecx     ecx+%1  ecx+2%1 %1+8%1  ecx+4%1
+
+                &quot;movq (%0), %%mm0                       \n\t&quot;
+                &quot;movq %%mm0, %%mm1                      \n\t&quot;
+                &quot;punpcklbw %%mm7, %%mm0                 \n\t&quot; // low part of line 0
+                &quot;punpckhbw %%mm7, %%mm1                 \n\t&quot; // high part of line 0
+
+                &quot;movq (%0, %1), %%mm2                   \n\t&quot;
+                &quot;lea (%0, %1, 2), %%&quot;REG_a&quot;             \n\t&quot;
+                &quot;movq %%mm2, %%mm3                      \n\t&quot;
+                &quot;punpcklbw %%mm7, %%mm2                 \n\t&quot; // low part of line 1
+                &quot;punpckhbw %%mm7, %%mm3                 \n\t&quot; // high part of line 1
+
+                &quot;movq (%%&quot;REG_a&quot;), %%mm4                \n\t&quot;
+                &quot;movq %%mm4, %%mm5                      \n\t&quot;
+                &quot;punpcklbw %%mm7, %%mm4                 \n\t&quot; // low part of line 2
+                &quot;punpckhbw %%mm7, %%mm5                 \n\t&quot; // high part of line 2
+
+                &quot;paddw %%mm0, %%mm0                     \n\t&quot; // 2L0
+                &quot;paddw %%mm1, %%mm1                     \n\t&quot; // 2H0
+                &quot;psubw %%mm4, %%mm2                     \n\t&quot; // L1 - L2
+                &quot;psubw %%mm5, %%mm3                     \n\t&quot; // H1 - H2
+                &quot;psubw %%mm2, %%mm0                     \n\t&quot; // 2L0 - L1 + L2
+                &quot;psubw %%mm3, %%mm1                     \n\t&quot; // 2H0 - H1 + H2
+
+                &quot;psllw $2, %%mm2                        \n\t&quot; // 4L1 - 4L2
+                &quot;psllw $2, %%mm3                        \n\t&quot; // 4H1 - 4H2
+                &quot;psubw %%mm2, %%mm0                     \n\t&quot; // 2L0 - 5L1 + 5L2
+                &quot;psubw %%mm3, %%mm1                     \n\t&quot; // 2H0 - 5H1 + 5H2
+
+                &quot;movq (%%&quot;REG_a&quot;, %1), %%mm2            \n\t&quot;
+                &quot;movq %%mm2, %%mm3                      \n\t&quot;
+                &quot;punpcklbw %%mm7, %%mm2                 \n\t&quot; // L3
+                &quot;punpckhbw %%mm7, %%mm3                 \n\t&quot; // H3
+
+                &quot;psubw %%mm2, %%mm0                     \n\t&quot; // 2L0 - 5L1 + 5L2 - L3
+                &quot;psubw %%mm3, %%mm1                     \n\t&quot; // 2H0 - 5H1 + 5H2 - H3
+                &quot;psubw %%mm2, %%mm0                     \n\t&quot; // 2L0 - 5L1 + 5L2 - 2L3
+                &quot;psubw %%mm3, %%mm1                     \n\t&quot; // 2H0 - 5H1 + 5H2 - 2H3
+                &quot;movq %%mm0, (%%&quot;REG_c&quot;)                \n\t&quot; // 2L0 - 5L1 + 5L2 - 2L3
+                &quot;movq %%mm1, 8(%%&quot;REG_c&quot;)               \n\t&quot; // 2H0 - 5H1 + 5H2 - 2H3
+
+                &quot;movq (%%&quot;REG_a&quot;, %1, 2), %%mm0         \n\t&quot;
+                &quot;movq %%mm0, %%mm1                      \n\t&quot;
+                &quot;punpcklbw %%mm7, %%mm0                 \n\t&quot; // L4
+                &quot;punpckhbw %%mm7, %%mm1                 \n\t&quot; // H4
+
+                &quot;psubw %%mm0, %%mm2                     \n\t&quot; // L3 - L4
+                &quot;psubw %%mm1, %%mm3                     \n\t&quot; // H3 - H4
+                &quot;movq %%mm2, 16(%%&quot;REG_c&quot;)              \n\t&quot; // L3 - L4
+                &quot;movq %%mm3, 24(%%&quot;REG_c&quot;)              \n\t&quot; // H3 - H4
+                &quot;paddw %%mm4, %%mm4                     \n\t&quot; // 2L2
+                &quot;paddw %%mm5, %%mm5                     \n\t&quot; // 2H2
+                &quot;psubw %%mm2, %%mm4                     \n\t&quot; // 2L2 - L3 + L4
+                &quot;psubw %%mm3, %%mm5                     \n\t&quot; // 2H2 - H3 + H4
+
+                &quot;lea (%%&quot;REG_a&quot;, %1), %0                \n\t&quot;
+                &quot;psllw $2, %%mm2                        \n\t&quot; // 4L3 - 4L4
+                &quot;psllw $2, %%mm3                        \n\t&quot; // 4H3 - 4H4
+                &quot;psubw %%mm2, %%mm4                     \n\t&quot; // 2L2 - 5L3 + 5L4
+                &quot;psubw %%mm3, %%mm5                     \n\t&quot; // 2H2 - 5H3 + 5H4
+//50 opcodes so far
+                &quot;movq (%0, %1, 2), %%mm2                \n\t&quot;
+                &quot;movq %%mm2, %%mm3                      \n\t&quot;
+                &quot;punpcklbw %%mm7, %%mm2                 \n\t&quot; // L5
+                &quot;punpckhbw %%mm7, %%mm3                 \n\t&quot; // H5
+                &quot;psubw %%mm2, %%mm4                     \n\t&quot; // 2L2 - 5L3 + 5L4 - L5
+                &quot;psubw %%mm3, %%mm5                     \n\t&quot; // 2H2 - 5H3 + 5H4 - H5
+                &quot;psubw %%mm2, %%mm4                     \n\t&quot; // 2L2 - 5L3 + 5L4 - 2L5
+                &quot;psubw %%mm3, %%mm5                     \n\t&quot; // 2H2 - 5H3 + 5H4 - 2H5
+
+                &quot;movq (%%&quot;REG_a&quot;, %1, 4), %%mm6         \n\t&quot;
+                &quot;punpcklbw %%mm7, %%mm6                 \n\t&quot; // L6
+                &quot;psubw %%mm6, %%mm2                     \n\t&quot; // L5 - L6
+                &quot;movq (%%&quot;REG_a&quot;, %1, 4), %%mm6         \n\t&quot;
+                &quot;punpckhbw %%mm7, %%mm6                 \n\t&quot; // H6
+                &quot;psubw %%mm6, %%mm3                     \n\t&quot; // H5 - H6
+
+                &quot;paddw %%mm0, %%mm0                     \n\t&quot; // 2L4
+                &quot;paddw %%mm1, %%mm1                     \n\t&quot; // 2H4
+                &quot;psubw %%mm2, %%mm0                     \n\t&quot; // 2L4 - L5 + L6
+                &quot;psubw %%mm3, %%mm1                     \n\t&quot; // 2H4 - H5 + H6
+
+                &quot;psllw $2, %%mm2                        \n\t&quot; // 4L5 - 4L6
+                &quot;psllw $2, %%mm3                        \n\t&quot; // 4H5 - 4H6
+                &quot;psubw %%mm2, %%mm0                     \n\t&quot; // 2L4 - 5L5 + 5L6
+                &quot;psubw %%mm3, %%mm1                     \n\t&quot; // 2H4 - 5H5 + 5H6
+
+                &quot;movq (%0, %1, 4), %%mm2                \n\t&quot;
+                &quot;movq %%mm2, %%mm3                      \n\t&quot;
+                &quot;punpcklbw %%mm7, %%mm2                 \n\t&quot; // L7
+                &quot;punpckhbw %%mm7, %%mm3                 \n\t&quot; // H7
+
+                &quot;paddw %%mm2, %%mm2                     \n\t&quot; // 2L7
+                &quot;paddw %%mm3, %%mm3                     \n\t&quot; // 2H7
+                &quot;psubw %%mm2, %%mm0                     \n\t&quot; // 2L4 - 5L5 + 5L6 - 2L7
+                &quot;psubw %%mm3, %%mm1                     \n\t&quot; // 2H4 - 5H5 + 5H6 - 2H7
+
+                &quot;movq (%%&quot;REG_c&quot;), %%mm2                \n\t&quot; // 2L0 - 5L1 + 5L2 - 2L3
+                &quot;movq 8(%%&quot;REG_c&quot;), %%mm3               \n\t&quot; // 2H0 - 5H1 + 5H2 - 2H3
+
+#ifdef HAVE_MMX2
+                &quot;movq %%mm7, %%mm6                      \n\t&quot; // 0
+                &quot;psubw %%mm0, %%mm6                     \n\t&quot;
+                &quot;pmaxsw %%mm6, %%mm0                    \n\t&quot; // |2L4 - 5L5 + 5L6 - 2L7|
+                &quot;movq %%mm7, %%mm6                      \n\t&quot; // 0
+                &quot;psubw %%mm1, %%mm6                     \n\t&quot;
+                &quot;pmaxsw %%mm6, %%mm1                    \n\t&quot; // |2H4 - 5H5 + 5H6 - 2H7|
+                &quot;movq %%mm7, %%mm6                      \n\t&quot; // 0
+                &quot;psubw %%mm2, %%mm6                     \n\t&quot;
+                &quot;pmaxsw %%mm6, %%mm2                    \n\t&quot; // |2L0 - 5L1 + 5L2 - 2L3|
+                &quot;movq %%mm7, %%mm6                      \n\t&quot; // 0
+                &quot;psubw %%mm3, %%mm6                     \n\t&quot;
+                &quot;pmaxsw %%mm6, %%mm3                    \n\t&quot; // |2H0 - 5H1 + 5H2 - 2H3|
+#else
+                &quot;movq %%mm7, %%mm6                      \n\t&quot; // 0
+                &quot;pcmpgtw %%mm0, %%mm6                   \n\t&quot;
+                &quot;pxor %%mm6, %%mm0                      \n\t&quot;
+                &quot;psubw %%mm6, %%mm0                     \n\t&quot; // |2L4 - 5L5 + 5L6 - 2L7|
+                &quot;movq %%mm7, %%mm6                      \n\t&quot; // 0
+                &quot;pcmpgtw %%mm1, %%mm6                   \n\t&quot;
+                &quot;pxor %%mm6, %%mm1                      \n\t&quot;
+                &quot;psubw %%mm6, %%mm1                     \n\t&quot; // |2H4 - 5H5 + 5H6 - 2H7|
+                &quot;movq %%mm7, %%mm6                      \n\t&quot; // 0
+                &quot;pcmpgtw %%mm2, %%mm6                   \n\t&quot;
+                &quot;pxor %%mm6, %%mm2                      \n\t&quot;
+                &quot;psubw %%mm6, %%mm2                     \n\t&quot; // |2L0 - 5L1 + 5L2 - 2L3|
+                &quot;movq %%mm7, %%mm6                      \n\t&quot; // 0
+                &quot;pcmpgtw %%mm3, %%mm6                   \n\t&quot;
+                &quot;pxor %%mm6, %%mm3                      \n\t&quot;
+                &quot;psubw %%mm6, %%mm3                     \n\t&quot; // |2H0 - 5H1 + 5H2 - 2H3|
+#endif
+
+#ifdef HAVE_MMX2
+                &quot;pminsw %%mm2, %%mm0                    \n\t&quot;
+                &quot;pminsw %%mm3, %%mm1                    \n\t&quot;
+#else
+                &quot;movq %%mm0, %%mm6                      \n\t&quot;
+                &quot;psubusw %%mm2, %%mm6                   \n\t&quot;
+                &quot;psubw %%mm6, %%mm0                     \n\t&quot;
+                &quot;movq %%mm1, %%mm6                      \n\t&quot;
+                &quot;psubusw %%mm3, %%mm6                   \n\t&quot;
+                &quot;psubw %%mm6, %%mm1                     \n\t&quot;
+#endif
+
+                &quot;movd %2, %%mm2                         \n\t&quot; // QP
+                &quot;punpcklbw %%mm7, %%mm2                 \n\t&quot;
+
+                &quot;movq %%mm7, %%mm6                      \n\t&quot; // 0
+                &quot;pcmpgtw %%mm4, %%mm6                   \n\t&quot; // sign(2L2 - 5L3 + 5L4 - 2L5)
+                &quot;pxor %%mm6, %%mm4                      \n\t&quot;
+                &quot;psubw %%mm6, %%mm4                     \n\t&quot; // |2L2 - 5L3 + 5L4 - 2L5|
+                &quot;pcmpgtw %%mm5, %%mm7                   \n\t&quot; // sign(2H2 - 5H3 + 5H4 - 2H5)
+                &quot;pxor %%mm7, %%mm5                      \n\t&quot;
+                &quot;psubw %%mm7, %%mm5                     \n\t&quot; // |2H2 - 5H3 + 5H4 - 2H5|
+// 100 opcodes
+                &quot;psllw $3, %%mm2                        \n\t&quot; // 8QP
+                &quot;movq %%mm2, %%mm3                      \n\t&quot; // 8QP
+                &quot;pcmpgtw %%mm4, %%mm2                   \n\t&quot;
+                &quot;pcmpgtw %%mm5, %%mm3                   \n\t&quot;
+                &quot;pand %%mm2, %%mm4                      \n\t&quot;
+                &quot;pand %%mm3, %%mm5                      \n\t&quot;
+
+
+                &quot;psubusw %%mm0, %%mm4                   \n\t&quot; // hd
+                &quot;psubusw %%mm1, %%mm5                   \n\t&quot; // ld
+
+
+                &quot;movq &quot;MANGLE(w05)&quot;, %%mm2              \n\t&quot; // 5
+                &quot;pmullw %%mm2, %%mm4                    \n\t&quot;
+                &quot;pmullw %%mm2, %%mm5                    \n\t&quot;
+                &quot;movq &quot;MANGLE(w20)&quot;, %%mm2              \n\t&quot; // 32
+                &quot;paddw %%mm2, %%mm4                     \n\t&quot;
+                &quot;paddw %%mm2, %%mm5                     \n\t&quot;
+                &quot;psrlw $6, %%mm4                        \n\t&quot;
+                &quot;psrlw $6, %%mm5                        \n\t&quot;
+
+                &quot;movq 16(%%&quot;REG_c&quot;), %%mm0              \n\t&quot; // L3 - L4
+                &quot;movq 24(%%&quot;REG_c&quot;), %%mm1              \n\t&quot; // H3 - H4
+
+                &quot;pxor %%mm2, %%mm2                      \n\t&quot;
+                &quot;pxor %%mm3, %%mm3                      \n\t&quot;
+
+                &quot;pcmpgtw %%mm0, %%mm2                   \n\t&quot; // sign (L3-L4)
+                &quot;pcmpgtw %%mm1, %%mm3                   \n\t&quot; // sign (H3-H4)
+                &quot;pxor %%mm2, %%mm0                      \n\t&quot;
+                &quot;pxor %%mm3, %%mm1                      \n\t&quot;
+                &quot;psubw %%mm2, %%mm0                     \n\t&quot; // |L3-L4|
+                &quot;psubw %%mm3, %%mm1                     \n\t&quot; // |H3-H4|
+                &quot;psrlw $1, %%mm0                        \n\t&quot; // |L3 - L4|/2
+                &quot;psrlw $1, %%mm1                        \n\t&quot; // |H3 - H4|/2
+
+                &quot;pxor %%mm6, %%mm2                      \n\t&quot;
+                &quot;pxor %%mm7, %%mm3                      \n\t&quot;
+                &quot;pand %%mm2, %%mm4                      \n\t&quot;
+                &quot;pand %%mm3, %%mm5                      \n\t&quot;
+
+#ifdef HAVE_MMX2
+                &quot;pminsw %%mm0, %%mm4                    \n\t&quot;
+                &quot;pminsw %%mm1, %%mm5                    \n\t&quot;
+#else
+                &quot;movq %%mm4, %%mm2                      \n\t&quot;
+                &quot;psubusw %%mm0, %%mm2                   \n\t&quot;
+                &quot;psubw %%mm2, %%mm4                     \n\t&quot;
+                &quot;movq %%mm5, %%mm2                      \n\t&quot;
+                &quot;psubusw %%mm1, %%mm2                   \n\t&quot;
+                &quot;psubw %%mm2, %%mm5                     \n\t&quot;
+#endif
+                &quot;pxor %%mm6, %%mm4                      \n\t&quot;
+                &quot;pxor %%mm7, %%mm5                      \n\t&quot;
+                &quot;psubw %%mm6, %%mm4                     \n\t&quot;
+                &quot;psubw %%mm7, %%mm5                     \n\t&quot;
+                &quot;packsswb %%mm5, %%mm4                  \n\t&quot;
+                &quot;movq %3, %%mm1                         \n\t&quot;
+                &quot;pandn %%mm4, %%mm1                     \n\t&quot;
+                &quot;movq (%0), %%mm0                       \n\t&quot;
+                &quot;paddb   %%mm1, %%mm0                   \n\t&quot;
+                &quot;movq %%mm0, (%0)                       \n\t&quot;
+                &quot;movq (%0, %1), %%mm0                   \n\t&quot;
+                &quot;psubb %%mm1, %%mm0                     \n\t&quot;
+                &quot;movq %%mm0, (%0, %1)                   \n\t&quot;
+
+                : &quot;+r&quot; (temp_src)
+                : &quot;r&quot; ((long)step), &quot;m&quot; (c-&gt;pQPb), &quot;m&quot;(eq_mask)
+                : &quot;%&quot;REG_a, &quot;%&quot;REG_c
+                );
+        }
+/*if(step==16){
+    STOP_TIMER(&quot;step16&quot;)
+}else{
+    STOP_TIMER(&quot;stepX&quot;)
+}*/
+}
+#endif //HAVE_MMX
+
+static void RENAME(postProcess)(uint8_t src[], int srcStride, uint8_t dst[], int dstStride, int width, int height,
+        QP_STORE_T QPs[], int QPStride, int isColor, PPContext *c);
+
+/**
+ * Copies a block from src to dst and fixes the blacklevel
+ * levelFix == 0 -&gt; dont touch the brighness &amp; contrast
+ */
+#undef SCALED_CPY
+
+static inline void RENAME(blockCopy)(uint8_t dst[], int dstStride, uint8_t src[], int srcStride,
+        int levelFix, int64_t *packedOffsetAndScale)
+{
+#ifndef HAVE_MMX
+        int i;
+#endif
+        if(levelFix)
+        {
+#ifdef HAVE_MMX
+                asm volatile(
+                        &quot;movq (%%&quot;REG_a&quot;), %%mm2        \n\t&quot; // packedYOffset
+                        &quot;movq 8(%%&quot;REG_a&quot;), %%mm3       \n\t&quot; // packedYScale
+                        &quot;lea (%2,%4), %%&quot;REG_a&quot;         \n\t&quot;
+                        &quot;lea (%3,%5), %%&quot;REG_d&quot;         \n\t&quot;
+                        &quot;pxor %%mm4, %%mm4              \n\t&quot;
+#ifdef HAVE_MMX2
+#define REAL_SCALED_CPY(src1, src2, dst1, dst2)                                                \
+                        &quot;movq &quot; #src1 &quot;, %%mm0          \n\t&quot;\
+                        &quot;movq &quot; #src1 &quot;, %%mm5          \n\t&quot;\
+                        &quot;movq &quot; #src2 &quot;, %%mm1          \n\t&quot;\
+                        &quot;movq &quot; #src2 &quot;, %%mm6          \n\t&quot;\
+                        &quot;punpcklbw %%mm0, %%mm0         \n\t&quot;\
+                        &quot;punpckhbw %%mm5, %%mm5         \n\t&quot;\
+                        &quot;punpcklbw %%mm1, %%mm1         \n\t&quot;\
+                        &quot;punpckhbw %%mm6, %%mm6         \n\t&quot;\
+                        &quot;pmulhuw %%mm3, %%mm0           \n\t&quot;\
+                        &quot;pmulhuw %%mm3, %%mm5           \n\t&quot;\
+                        &quot;pmulhuw %%mm3, %%mm1           \n\t&quot;\
+                        &quot;pmulhuw %%mm3, %%mm6           \n\t&quot;\
+                        &quot;psubw %%mm2, %%mm0             \n\t&quot;\
+                        &quot;psubw %%mm2, %%mm5             \n\t&quot;\
+                        &quot;psubw %%mm2, %%mm1             \n\t&quot;\
+                        &quot;psubw %%mm2, %%mm6             \n\t&quot;\
+                        &quot;packuswb %%mm5, %%mm0          \n\t&quot;\
+                        &quot;packuswb %%mm6, %%mm1          \n\t&quot;\
+                        &quot;movq %%mm0, &quot; #dst1 &quot;          \n\t&quot;\
+                        &quot;movq %%mm1, &quot; #dst2 &quot;          \n\t&quot;\
+
+#else //HAVE_MMX2
+#define REAL_SCALED_CPY(src1, src2, dst1, dst2)                                        \
+                        &quot;movq &quot; #src1 &quot;, %%mm0          \n\t&quot;\
+                        &quot;movq &quot; #src1 &quot;, %%mm5          \n\t&quot;\
+                        &quot;punpcklbw %%mm4, %%mm0         \n\t&quot;\
+                        &quot;punpckhbw %%mm4, %%mm5         \n\t&quot;\
+                        &quot;psubw %%mm2, %%mm0             \n\t&quot;\
+                        &quot;psubw %%mm2, %%mm5             \n\t&quot;\
+                        &quot;movq &quot; #src2 &quot;, %%mm1          \n\t&quot;\
+                        &quot;psllw $6, %%mm0                \n\t&quot;\
+                        &quot;psllw $6, %%mm5                \n\t&quot;\
+                        &quot;pmulhw %%mm3, %%mm0            \n\t&quot;\
+                        &quot;movq &quot; #src2 &quot;, %%mm6          \n\t&quot;\
+                        &quot;pmulhw %%mm3, %%mm5            \n\t&quot;\
+                        &quot;punpcklbw %%mm4, %%mm1         \n\t&quot;\
+                        &quot;punpckhbw %%mm4, %%mm6         \n\t&quot;\
+                        &quot;psubw %%mm2, %%mm1             \n\t&quot;\
+                        &quot;psubw %%mm2, %%mm6             \n\t&quot;\
+                        &quot;psllw $6, %%mm1                \n\t&quot;\
+                        &quot;psllw $6, %%mm6                \n\t&quot;\
+                        &quot;pmulhw %%mm3, %%mm1            \n\t&quot;\
+                        &quot;pmulhw %%mm3, %%mm6            \n\t&quot;\
+                        &quot;packuswb %%mm5, %%mm0          \n\t&quot;\
+                        &quot;packuswb %%mm6, %%mm1          \n\t&quot;\
+                        &quot;movq %%mm0, &quot; #dst1 &quot;          \n\t&quot;\
+                        &quot;movq %%mm1, &quot; #dst2 &quot;          \n\t&quot;\
+
+#endif //HAVE_MMX2
+#define SCALED_CPY(src1, src2, dst1, dst2)\
+   REAL_SCALED_CPY(src1, src2, dst1, dst2)
+
+SCALED_CPY((%2)       , (%2, %4)      , (%3)       , (%3, %5))
+SCALED_CPY((%2, %4, 2), (%%REGa, %4, 2), (%3, %5, 2), (%%REGd, %5, 2))
+SCALED_CPY((%2, %4, 4), (%%REGa, %4, 4), (%3, %5, 4), (%%REGd, %5, 4))
+                        &quot;lea (%%&quot;REG_a&quot;,%4,4), %%&quot;REG_a&quot;        \n\t&quot;
+                        &quot;lea (%%&quot;REG_d&quot;,%5,4), %%&quot;REG_d&quot;        \n\t&quot;
+SCALED_CPY((%%REGa, %4), (%%REGa, %4, 2), (%%REGd, %5), (%%REGd, %5, 2))
+
+
+                        : &quot;=&amp;a&quot; (packedOffsetAndScale)
+                        : &quot;0&quot; (packedOffsetAndScale),
+                        &quot;r&quot;(src),
+                        &quot;r&quot;(dst),
+                        &quot;r&quot; ((long)srcStride),
+                        &quot;r&quot; ((long)dstStride)
+                        : &quot;%&quot;REG_d
+                                        );
+#else //HAVE_MMX
+        for(i=0; i&lt;8; i++)
+                memcpy( &amp;(dst[dstStride*i]),
+                        &amp;(src[srcStride*i]), BLOCK_SIZE);
+#endif //HAVE_MMX
+        }
+        else
+        {
+#ifdef HAVE_MMX
+        asm volatile(
+                &quot;lea (%0,%2), %%&quot;REG_a&quot;                 \n\t&quot;
+                &quot;lea (%1,%3), %%&quot;REG_d&quot;                 \n\t&quot;
+
+#define REAL_SIMPLE_CPY(src1, src2, dst1, dst2)                              \
+                &quot;movq &quot; #src1 &quot;, %%mm0          \n\t&quot;\
+                &quot;movq &quot; #src2 &quot;, %%mm1          \n\t&quot;\
+                &quot;movq %%mm0, &quot; #dst1 &quot;          \n\t&quot;\
+                &quot;movq %%mm1, &quot; #dst2 &quot;          \n\t&quot;\
+
+#define SIMPLE_CPY(src1, src2, dst1, dst2)\
+   REAL_SIMPLE_CPY(src1, src2, dst1, dst2)
+
+SIMPLE_CPY((%0)       , (%0, %2)       , (%1)       , (%1, %3))
+SIMPLE_CPY((%0, %2, 2), (%%REGa, %2, 2), (%1, %3, 2), (%%REGd, %3, 2))
+SIMPLE_CPY((%0, %2, 4), (%%REGa, %2, 4), (%1, %3, 4), (%%REGd, %3, 4))
+                &quot;lea (%%&quot;REG_a&quot;,%2,4), %%&quot;REG_a&quot;        \n\t&quot;
+                &quot;lea (%%&quot;REG_d&quot;,%3,4), %%&quot;REG_d&quot;        \n\t&quot;
+SIMPLE_CPY((%%REGa, %2), (%%REGa, %2, 2), (%%REGd, %3), (%%REGd, %3, 2))
+
+                : : &quot;r&quot; (src),
+                &quot;r&quot; (dst),
+                &quot;r&quot; ((long)srcStride),
+                &quot;r&quot; ((long)dstStride)
+                : &quot;%&quot;REG_a, &quot;%&quot;REG_d
+        );
+#else //HAVE_MMX
+        for(i=0; i&lt;8; i++)
+                memcpy( &amp;(dst[dstStride*i]),
+                        &amp;(src[srcStride*i]), BLOCK_SIZE);
+#endif //HAVE_MMX
+        }
+}
+
+/**
+ * Duplicates the given 8 src pixels ? times upward
+ */
+static inline void RENAME(duplicate)(uint8_t src[], int stride)
+{
+#ifdef HAVE_MMX
+        asm volatile(
+                &quot;movq (%0), %%mm0               \n\t&quot;
+                &quot;add %1, %0                     \n\t&quot;
+                &quot;movq %%mm0, (%0)               \n\t&quot;
+                &quot;movq %%mm0, (%0, %1)           \n\t&quot;
+                &quot;movq %%mm0, (%0, %1, 2)        \n\t&quot;
+                : &quot;+r&quot; (src)
+                : &quot;r&quot; ((long)-stride)
+        );
+#else
+        int i;
+        uint8_t *p=src;
+        for(i=0; i&lt;3; i++)
+        {
+                p-= stride;
+                memcpy(p, src, 8);
+        }
+#endif
+}
+
+/**
+ * Filters array of bytes (Y or U or V values)
+ */
+static void RENAME(postProcess)(uint8_t src[], int srcStride, uint8_t dst[], int dstStride, int width, int height,
+        QP_STORE_T QPs[], int QPStride, int isColor, PPContext *c2)
+{
+        PPContext __attribute__((aligned(8))) c= *c2; //copy to stack for faster access
+        int x,y;
+#ifdef COMPILE_TIME_MODE
+        const int mode= COMPILE_TIME_MODE;
+#else
+        const int mode= isColor ? c.ppMode.chromMode : c.ppMode.lumMode;
+#endif
+        int black=0, white=255; // blackest black and whitest white in the picture
+        int QPCorrecture= 256*256;
+
+        int copyAhead;
+#ifdef HAVE_MMX
+        int i;
+#endif
+
+        const int qpHShift= isColor ? 4-c.hChromaSubSample : 4;
+        const int qpVShift= isColor ? 4-c.vChromaSubSample : 4;
+
+        //FIXME remove
+        uint64_t * const yHistogram= c.yHistogram;
+        uint8_t * const tempSrc= srcStride &gt; 0 ? c.tempSrc : c.tempSrc - 23*srcStride;
+        uint8_t * const tempDst= dstStride &gt; 0 ? c.tempDst : c.tempDst - 23*dstStride;
+        //const int mbWidth= isColor ? (width+7)&gt;&gt;3 : (width+15)&gt;&gt;4;
+
+#ifdef HAVE_MMX
+        for(i=0; i&lt;57; i++){
+                int offset= ((i*c.ppMode.baseDcDiff)&gt;&gt;8) + 1;
+                int threshold= offset*2 + 1;
+                c.mmxDcOffset[i]= 0x7F - offset;
+                c.mmxDcThreshold[i]= 0x7F - threshold;
+                c.mmxDcOffset[i]*= 0x0101010101010101LL;
+                c.mmxDcThreshold[i]*= 0x0101010101010101LL;
+        }
+#endif
+
+        if(mode &amp; CUBIC_IPOL_DEINT_FILTER) copyAhead=16;
+        else if(   (mode &amp; LINEAR_BLEND_DEINT_FILTER)
+                || (mode &amp; FFMPEG_DEINT_FILTER)
+                || (mode &amp; LOWPASS5_DEINT_FILTER)) copyAhead=14;
+        else if(   (mode &amp; V_DEBLOCK)
+                || (mode &amp; LINEAR_IPOL_DEINT_FILTER)
+                || (mode &amp; MEDIAN_DEINT_FILTER)
+                || (mode &amp; V_A_DEBLOCK)) copyAhead=13;
+        else if(mode &amp; V_X1_FILTER) copyAhead=11;
+//        else if(mode &amp; V_RK1_FILTER) copyAhead=10;
+        else if(mode &amp; DERING) copyAhead=9;
+        else copyAhead=8;
+
+        copyAhead-= 8;
+
+        if(!isColor)
+        {
+                uint64_t sum= 0;
+                int i;
+                uint64_t maxClipped;
+                uint64_t clipped;
+                double scale;
+
+                c.frameNum++;
+                // first frame is fscked so we ignore it
+                if(c.frameNum == 1) yHistogram[0]= width*height/64*15/256;
+
+                for(i=0; i&lt;256; i++)
+                {
+                        sum+= yHistogram[i];
+                }
+
+                /* we allways get a completly black picture first */
+                maxClipped= (uint64_t)(sum * c.ppMode.maxClippedThreshold);
+
+                clipped= sum;
+                for(black=255; black&gt;0; black--)
+                {
+                        if(clipped &lt; maxClipped) break;
+                        clipped-= yHistogram[black];
+                }
+
+                clipped= sum;
+                for(white=0; white&lt;256; white++)
+                {
+                        if(clipped &lt; maxClipped) break;
+                        clipped-= yHistogram[white];
+                }
+
+                scale= (double)(c.ppMode.maxAllowedY - c.ppMode.minAllowedY) / (double)(white-black);
+
+#ifdef HAVE_MMX2
+                c.packedYScale= (uint16_t)(scale*256.0 + 0.5);
+                c.packedYOffset= (((black*c.packedYScale)&gt;&gt;8) - c.ppMode.minAllowedY) &amp; 0xFFFF;
+#else
+                c.packedYScale= (uint16_t)(scale*1024.0 + 0.5);
+                c.packedYOffset= (black - c.ppMode.minAllowedY) &amp; 0xFFFF;
+#endif
+
+                c.packedYOffset|= c.packedYOffset&lt;&lt;32;
+                c.packedYOffset|= c.packedYOffset&lt;&lt;16;
+
+                c.packedYScale|= c.packedYScale&lt;&lt;32;
+                c.packedYScale|= c.packedYScale&lt;&lt;16;
+
+                if(mode &amp; LEVEL_FIX)        QPCorrecture= (int)(scale*256*256 + 0.5);
+                else                        QPCorrecture= 256*256;
+        }
+        else
+        {
+                c.packedYScale= 0x0100010001000100LL;
+                c.packedYOffset= 0;
+                QPCorrecture= 256*256;
+        }
+
+        /* copy &amp; deinterlace first row of blocks */
+        y=-BLOCK_SIZE;
+        {
+                uint8_t *srcBlock= &amp;(src[y*srcStride]);
+                uint8_t *dstBlock= tempDst + dstStride;
+
+                // From this point on it is guranteed that we can read and write 16 lines downward
+                // finish 1 block before the next otherwise we might have a problem
+                // with the L1 Cache of the P4 ... or only a few blocks at a time or soemthing
+                for(x=0; x&lt;width; x+=BLOCK_SIZE)
+                {
+
+#ifdef HAVE_MMX2
+/*
+                        prefetchnta(srcBlock + (((x&gt;&gt;2)&amp;6) + 5)*srcStride + 32);
+                        prefetchnta(srcBlock + (((x&gt;&gt;2)&amp;6) + 6)*srcStride + 32);
+                        prefetcht0(dstBlock + (((x&gt;&gt;2)&amp;6) + 5)*dstStride + 32);
+                        prefetcht0(dstBlock + (((x&gt;&gt;2)&amp;6) + 6)*dstStride + 32);
+*/
+
+                        asm(
+                                &quot;mov %4, %%&quot;REG_a&quot;              \n\t&quot;
+                                &quot;shr $2, %%&quot;REG_a&quot;              \n\t&quot;
+                                &quot;and $6, %%&quot;REG_a&quot;              \n\t&quot;
+                                &quot;add %5, %%&quot;REG_a&quot;              \n\t&quot;
+                                &quot;mov %%&quot;REG_a&quot;, %%&quot;REG_d&quot;       \n\t&quot;
+                                &quot;imul %1, %%&quot;REG_a&quot;             \n\t&quot;
+                                &quot;imul %3, %%&quot;REG_d&quot;             \n\t&quot;
+                                &quot;prefetchnta 32(%%&quot;REG_a&quot;, %0)  \n\t&quot;
+                                &quot;prefetcht0 32(%%&quot;REG_d&quot;, %2)   \n\t&quot;
+                                &quot;add %1, %%&quot;REG_a&quot;              \n\t&quot;
+                                &quot;add %3, %%&quot;REG_d&quot;              \n\t&quot;
+                                &quot;prefetchnta 32(%%&quot;REG_a&quot;, %0)  \n\t&quot;
+                                &quot;prefetcht0 32(%%&quot;REG_d&quot;, %2)   \n\t&quot;
+                        :: &quot;r&quot; (srcBlock), &quot;r&quot; ((long)srcStride), &quot;r&quot; (dstBlock), &quot;r&quot; ((long)dstStride),
+                        &quot;g&quot; ((long)x), &quot;g&quot; ((long)copyAhead)
+                        : &quot;%&quot;REG_a, &quot;%&quot;REG_d
+                        );
+
+#elif defined(HAVE_3DNOW)
+//FIXME check if this is faster on an 3dnow chip or if its faster without the prefetch or ...
+/*                        prefetch(srcBlock + (((x&gt;&gt;3)&amp;3) + 5)*srcStride + 32);
+                        prefetch(srcBlock + (((x&gt;&gt;3)&amp;3) + 9)*srcStride + 32);
+                        prefetchw(dstBlock + (((x&gt;&gt;3)&amp;3) + 5)*dstStride + 32);
+                        prefetchw(dstBlock + (((x&gt;&gt;3)&amp;3) + 9)*dstStride + 32);
+*/
+#endif
+
+                        RENAME(blockCopy)(dstBlock + dstStride*8, dstStride,
+                                srcBlock + srcStride*8, srcStride, mode &amp; LEVEL_FIX, &amp;c.packedYOffset);
+
+                        RENAME(duplicate)(dstBlock + dstStride*8, dstStride);
+
+                        if(mode &amp; LINEAR_IPOL_DEINT_FILTER)
+                                RENAME(deInterlaceInterpolateLinear)(dstBlock, dstStride);
+                        else if(mode &amp; LINEAR_BLEND_DEINT_FILTER)
+                                RENAME(deInterlaceBlendLinear)(dstBlock, dstStride, c.deintTemp + x);
+                        else if(mode &amp; MEDIAN_DEINT_FILTER)
+                                RENAME(deInterlaceMedian)(dstBlock, dstStride);
+                        else if(mode &amp; CUBIC_IPOL_DEINT_FILTER)
+                                RENAME(deInterlaceInterpolateCubic)(dstBlock, dstStride);
+                        else if(mode &amp; FFMPEG_DEINT_FILTER)
+                                RENAME(deInterlaceFF)(dstBlock, dstStride, c.deintTemp + x);
+                        else if(mode &amp; LOWPASS5_DEINT_FILTER)
+                                RENAME(deInterlaceL5)(dstBlock, dstStride, c.deintTemp + x, c.deintTemp + width + x);
+/*                        else if(mode &amp; CUBIC_BLEND_DEINT_FILTER)
+                                RENAME(deInterlaceBlendCubic)(dstBlock, dstStride);
+*/
+                        dstBlock+=8;
+                        srcBlock+=8;
+                }
+                if(width==FFABS(dstStride))
+                        linecpy(dst, tempDst + 9*dstStride, copyAhead, dstStride);
+                else
+                {
+                        int i;
+                        for(i=0; i&lt;copyAhead; i++)
+                        {
+                                memcpy(dst + i*dstStride, tempDst + (9+i)*dstStride, width);
+                        }
+                }
+        }
+
+        for(y=0; y&lt;height; y+=BLOCK_SIZE)
+        {
+                //1% speedup if these are here instead of the inner loop
+                uint8_t *srcBlock= &amp;(src[y*srcStride]);
+                uint8_t *dstBlock= &amp;(dst[y*dstStride]);
+#ifdef HAVE_MMX
+                uint8_t *tempBlock1= c.tempBlocks;
+                uint8_t *tempBlock2= c.tempBlocks + 8;
+#endif
+                int8_t *QPptr= &amp;QPs[(y&gt;&gt;qpVShift)*QPStride];
+                int8_t *nonBQPptr= &amp;c.nonBQPTable[(y&gt;&gt;qpVShift)*FFABS(QPStride)];
+                int QP=0;
+                /* can we mess with a 8x16 block from srcBlock/dstBlock downwards and 1 line upwards
+                   if not than use a temporary buffer */
+                if(y+15 &gt;= height)
+                {
+                        int i;
+                        /* copy from line (copyAhead) to (copyAhead+7) of src, these will be copied with
+                           blockcopy to dst later */
+                        linecpy(tempSrc + srcStride*copyAhead, srcBlock + srcStride*copyAhead,
+                                FFMAX(height-y-copyAhead, 0), srcStride);
+
+                        /* duplicate last line of src to fill the void upto line (copyAhead+7) */
+                        for(i=FFMAX(height-y, 8); i&lt;copyAhead+8; i++)
+                                memcpy(tempSrc + srcStride*i, src + srcStride*(height-1), FFABS(srcStride));
+
+                        /* copy up to (copyAhead+1) lines of dst (line -1 to (copyAhead-1))*/
+                        linecpy(tempDst, dstBlock - dstStride, FFMIN(height-y+1, copyAhead+1), dstStride);
+
+                        /* duplicate last line of dst to fill the void upto line (copyAhead) */
+                        for(i=height-y+1; i&lt;=copyAhead; i++)
+                                memcpy(tempDst + dstStride*i, dst + dstStride*(height-1), FFABS(dstStride));
+
+                        dstBlock= tempDst + dstStride;
+                        srcBlock= tempSrc;
+                }
+
+                // From this point on it is guranteed that we can read and write 16 lines downward
+                // finish 1 block before the next otherwise we might have a problem
+                // with the L1 Cache of the P4 ... or only a few blocks at a time or soemthing
+                for(x=0; x&lt;width; x+=BLOCK_SIZE)
+                {
+                        const int stride= dstStride;
+#ifdef HAVE_MMX
+                        uint8_t *tmpXchg;
+#endif
+                        if(isColor)
+                        {
+                                QP= QPptr[x&gt;&gt;qpHShift];
+                                c.nonBQP= nonBQPptr[x&gt;&gt;qpHShift];
+                        }
+                        else
+                        {
+                                QP= QPptr[x&gt;&gt;4];
+                                QP= (QP* QPCorrecture + 256*128)&gt;&gt;16;
+                                c.nonBQP= nonBQPptr[x&gt;&gt;4];
+                                c.nonBQP= (c.nonBQP* QPCorrecture + 256*128)&gt;&gt;16;
+                                yHistogram[ srcBlock[srcStride*12 + 4] ]++;
+                        }
+                        c.QP= QP;
+#ifdef HAVE_MMX
+                        asm volatile(
+                                &quot;movd %1, %%mm7         \n\t&quot;
+                                &quot;packuswb %%mm7, %%mm7  \n\t&quot; // 0, 0, 0, QP, 0, 0, 0, QP
+                                &quot;packuswb %%mm7, %%mm7  \n\t&quot; // 0,QP, 0, QP, 0,QP, 0, QP
+                                &quot;packuswb %%mm7, %%mm7  \n\t&quot; // QP,..., QP
+                                &quot;movq %%mm7, %0         \n\t&quot;
+                                : &quot;=m&quot; (c.pQPb)
+                                : &quot;r&quot; (QP)
+                        );
+#endif
+
+
+#ifdef HAVE_MMX2
+/*
+                        prefetchnta(srcBlock + (((x&gt;&gt;2)&amp;6) + 5)*srcStride + 32);
+                        prefetchnta(srcBlock + (((x&gt;&gt;2)&amp;6) + 6)*srcStride + 32);
+                        prefetcht0(dstBlock + (((x&gt;&gt;2)&amp;6) + 5)*dstStride + 32);
+                        prefetcht0(dstBlock + (((x&gt;&gt;2)&amp;6) + 6)*dstStride + 32);
+*/
+
+                        asm(
+                                &quot;mov %4, %%&quot;REG_a&quot;              \n\t&quot;
+                                &quot;shr $2, %%&quot;REG_a&quot;              \n\t&quot;
+                                &quot;and $6, %%&quot;REG_a&quot;              \n\t&quot;
+                                &quot;add %5, %%&quot;REG_a&quot;              \n\t&quot;
+                                &quot;mov %%&quot;REG_a&quot;, %%&quot;REG_d&quot;       \n\t&quot;
+                                &quot;imul %1, %%&quot;REG_a&quot;             \n\t&quot;
+                                &quot;imul %3, %%&quot;REG_d&quot;             \n\t&quot;
+                                &quot;prefetchnta 32(%%&quot;REG_a&quot;, %0)  \n\t&quot;
+                                &quot;prefetcht0 32(%%&quot;REG_d&quot;, %2)   \n\t&quot;
+                                &quot;add %1, %%&quot;REG_a&quot;              \n\t&quot;
+                                &quot;add %3, %%&quot;REG_d&quot;              \n\t&quot;
+                                &quot;prefetchnta 32(%%&quot;REG_a&quot;, %0)  \n\t&quot;
+                                &quot;prefetcht0 32(%%&quot;REG_d&quot;, %2)   \n\t&quot;
+                        :: &quot;r&quot; (srcBlock), &quot;r&quot; ((long)srcStride), &quot;r&quot; (dstBlock), &quot;r&quot; ((long)dstStride),
+                         &quot;g&quot; ((long)x), &quot;g&quot; ((long)copyAhead)
+                        : &quot;%&quot;REG_a, &quot;%&quot;REG_d
+                        );
+
+#elif defined(HAVE_3DNOW)
+//FIXME check if this is faster on an 3dnow chip or if its faster without the prefetch or ...
+/*                        prefetch(srcBlock + (((x&gt;&gt;3)&amp;3) + 5)*srcStride + 32);
+                        prefetch(srcBlock + (((x&gt;&gt;3)&amp;3) + 9)*srcStride + 32);
+                        prefetchw(dstBlock + (((x&gt;&gt;3)&amp;3) + 5)*dstStride + 32);
+                        prefetchw(dstBlock + (((x&gt;&gt;3)&amp;3) + 9)*dstStride + 32);
+*/
+#endif
+
+                        RENAME(blockCopy)(dstBlock + dstStride*copyAhead, dstStride,
+                                srcBlock + srcStride*copyAhead, srcStride, mode &amp; LEVEL_FIX, &amp;c.packedYOffset);
+
+                        if(mode &amp; LINEAR_IPOL_DEINT_FILTER)
+                                RENAME(deInterlaceInterpolateLinear)(dstBlock, dstStride);
+                        else if(mode &amp; LINEAR_BLEND_DEINT_FILTER)
+                                RENAME(deInterlaceBlendLinear)(dstBlock, dstStride, c.deintTemp + x);
+                        else if(mode &amp; MEDIAN_DEINT_FILTER)
+                                RENAME(deInterlaceMedian)(dstBlock, dstStride);
+                        else if(mode &amp; CUBIC_IPOL_DEINT_FILTER)
+                                RENAME(deInterlaceInterpolateCubic)(dstBlock, dstStride);
+                        else if(mode &amp; FFMPEG_DEINT_FILTER)
+                                RENAME(deInterlaceFF)(dstBlock, dstStride, c.deintTemp + x);
+                        else if(mode &amp; LOWPASS5_DEINT_FILTER)
+                                RENAME(deInterlaceL5)(dstBlock, dstStride, c.deintTemp + x, c.deintTemp + width + x);
+/*                        else if(mode &amp; CUBIC_BLEND_DEINT_FILTER)
+                                RENAME(deInterlaceBlendCubic)(dstBlock, dstStride);
+*/
+
+                        /* only deblock if we have 2 blocks */
+                        if(y + 8 &lt; height)
+                        {
+                                if(mode &amp; V_X1_FILTER)
+                                        RENAME(vertX1Filter)(dstBlock, stride, &amp;c);
+                                else if(mode &amp; V_DEBLOCK)
+                                {
+                                        const int t= RENAME(vertClassify)(dstBlock, stride, &amp;c);
+
+                                        if(t==1)
+                                                RENAME(doVertLowPass)(dstBlock, stride, &amp;c);
+                                        else if(t==2)
+                                                RENAME(doVertDefFilter)(dstBlock, stride, &amp;c);
+                                }else if(mode &amp; V_A_DEBLOCK){
+                                        RENAME(do_a_deblock)(dstBlock, stride, 1, &amp;c);
+                                }
+                        }
+
+#ifdef HAVE_MMX
+                        RENAME(transpose1)(tempBlock1, tempBlock2, dstBlock, dstStride);
+#endif
+                        /* check if we have a previous block to deblock it with dstBlock */
+                        if(x - 8 &gt;= 0)
+                        {
+#ifdef HAVE_MMX
+                                if(mode &amp; H_X1_FILTER)
+                                        RENAME(vertX1Filter)(tempBlock1, 16, &amp;c);
+                                else if(mode &amp; H_DEBLOCK)
+                                {
+//START_TIMER
+                                        const int t= RENAME(vertClassify)(tempBlock1, 16, &amp;c);
+//STOP_TIMER(&quot;dc &amp; minmax&quot;)
+                                        if(t==1)
+                                                RENAME(doVertLowPass)(tempBlock1, 16, &amp;c);
+                                        else if(t==2)
+                                                RENAME(doVertDefFilter)(tempBlock1, 16, &amp;c);
+                                }else if(mode &amp; H_A_DEBLOCK){
+                                        RENAME(do_a_deblock)(tempBlock1, 16, 1, &amp;c);
+                                }
+
+                                RENAME(transpose2)(dstBlock-4, dstStride, tempBlock1 + 4*16);
+
+#else
+                                if(mode &amp; H_X1_FILTER)
+                                        horizX1Filter(dstBlock-4, stride, QP);
+                                else if(mode &amp; H_DEBLOCK)
+                                {
+#ifdef HAVE_ALTIVEC
+                                        unsigned char __attribute__ ((aligned(16))) tempBlock[272];
+                                        transpose_16x8_char_toPackedAlign_altivec(tempBlock, dstBlock - (4 + 1), stride);
+
+                                        const int t=vertClassify_altivec(tempBlock-48, 16, &amp;c);
+                                        if(t==1) {
+                                                doVertLowPass_altivec(tempBlock-48, 16, &amp;c);
+                                                transpose_8x16_char_fromPackedAlign_altivec(dstBlock - (4 + 1), tempBlock, stride);
+                                        }
+                                        else if(t==2) {
+                                                doVertDefFilter_altivec(tempBlock-48, 16, &amp;c);
+                                                transpose_8x16_char_fromPackedAlign_altivec(dstBlock - (4 + 1), tempBlock, stride);
+                                        }
+#else
+                                        const int t= RENAME(horizClassify)(dstBlock-4, stride, &amp;c);
+
+                                        if(t==1)
+                                                RENAME(doHorizLowPass)(dstBlock-4, stride, &amp;c);
+                                        else if(t==2)
+                                                RENAME(doHorizDefFilter)(dstBlock-4, stride, &amp;c);
+#endif
+                                }else if(mode &amp; H_A_DEBLOCK){
+                                        RENAME(do_a_deblock)(dstBlock-8, 1, stride, &amp;c);
+                                }
+#endif //HAVE_MMX
+                                if(mode &amp; DERING)
+                                {
+                                //FIXME filter first line
+                                        if(y&gt;0) RENAME(dering)(dstBlock - stride - 8, stride, &amp;c);
+                                }
+
+                                if(mode &amp; TEMP_NOISE_FILTER)
+                                {
+                                        RENAME(tempNoiseReducer)(dstBlock-8, stride,
+                                                c.tempBlured[isColor] + y*dstStride + x,
+                                                c.tempBluredPast[isColor] + (y&gt;&gt;3)*256 + (x&gt;&gt;3),
+                                                c.ppMode.maxTmpNoise);
+                                }
+                        }
+
+                        dstBlock+=8;
+                        srcBlock+=8;
+
+#ifdef HAVE_MMX
+                        tmpXchg= tempBlock1;
+                        tempBlock1= tempBlock2;
+                        tempBlock2 = tmpXchg;
+#endif
+                }
+
+                if(mode &amp; DERING)
+                {
+                                if(y &gt; 0) RENAME(dering)(dstBlock - dstStride - 8, dstStride, &amp;c);
+                }
+
+                if((mode &amp; TEMP_NOISE_FILTER))
+                {
+                        RENAME(tempNoiseReducer)(dstBlock-8, dstStride,
+                                c.tempBlured[isColor] + y*dstStride + x,
+                                c.tempBluredPast[isColor] + (y&gt;&gt;3)*256 + (x&gt;&gt;3),
+                                c.ppMode.maxTmpNoise);
+                }
+
+                /* did we use a tmp buffer for the last lines*/
+                if(y+15 &gt;= height)
+                {
+                        uint8_t *dstBlock= &amp;(dst[y*dstStride]);
+                        if(width==FFABS(dstStride))
+                                linecpy(dstBlock, tempDst + dstStride, height-y, dstStride);
+                        else
+                        {
+                                int i;
+                                for(i=0; i&lt;height-y; i++)
+                                {
+                                        memcpy(dstBlock + i*dstStride, tempDst + (i+1)*dstStride, width);
+                                }
+                        }
+                }
+/*
+                for(x=0; x&lt;width; x+=32)
+                {
+                        volatile int i;
+                        i+=        + dstBlock[x + 7*dstStride] + dstBlock[x + 8*dstStride]
+                                + dstBlock[x + 9*dstStride] + dstBlock[x +10*dstStride]
+                                + dstBlock[x +11*dstStride] + dstBlock[x +12*dstStride];
+//                                + dstBlock[x +13*dstStride]
+//                                + dstBlock[x +14*dstStride] + dstBlock[x +15*dstStride];
+                }*/
+        }
+#ifdef HAVE_3DNOW
+        asm volatile(&quot;femms&quot;);
+#elif defined (HAVE_MMX)
+        asm volatile(&quot;emms&quot;);
+#endif
+
+#ifdef DEBUG_BRIGHTNESS
+        if(!isColor)
+        {
+                int max=1;
+                int i;
+                for(i=0; i&lt;256; i++)
+                        if(yHistogram[i] &gt; max) max=yHistogram[i];
+
+                for(i=1; i&lt;256; i++)
+                {
+                        int x;
+                        int start=yHistogram[i-1]/(max/256+1);
+                        int end=yHistogram[i]/(max/256+1);
+                        int inc= end &gt; start ? 1 : -1;
+                        for(x=start; x!=end+inc; x+=inc)
+                                dst[ i*dstStride + x]+=128;
+                }
+
+                for(i=0; i&lt;100; i+=2)
+                {
+                        dst[ (white)*dstStride + i]+=128;
+                        dst[ (black)*dstStride + i]+=128;
+                }
+
+        }
+#endif
+
+        *c2= c; //copy local context back
+
+}

Added: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_libswscale/CMakeLists.txt
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_libswscale/CMakeLists.txt	2007-05-27 18:44:33 UTC (rev 3157)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_libswscale/CMakeLists.txt	2007-05-28 13:03:46 UTC (rev 3158)
@@ -0,0 +1,14 @@
+################################
+#
+################################
+include(AdmLib)
+SET(ADM_LIB ADM_libswscale)
+#
+SET(${ADM_LIB}_SRCS 
+swscale.c yuv2rgb.c rgb2rgb.c yuv2rgb_altivec.c ADM_mp.cpp
+)
+ADD_LIBRARY(${ADM_LIB} STATIC ${${ADM_LIB}_SRCS})
+ADD_ADM_LIB(${ADM_LIB} ADM_libraries)
+
+
+################################

Added: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_libtwolame/CMakeLists.txt
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_libtwolame/CMakeLists.txt	2007-05-27 18:44:33 UTC (rev 3157)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_libtwolame/CMakeLists.txt	2007-05-28 13:03:46 UTC (rev 3158)
@@ -0,0 +1,21 @@
+
+################################
+#
+################################
+include(AdmLib)
+SET(ADM_LIB ADM_libtwolame)
+#
+SET(${ADM_LIB}_SRCS 
+ath.c        bitbuffer.c  crc.c  encode.c      energy.c  get_set.c  psycho_0.c  psycho_2.c  psycho_4.c   subband.c  twolame.c
+availbits.c  dab.c   fft.c     mem.c      psycho_1.c  psycho_3.c  psycho_n1.c     util.c
+
+)
+ADD_LIBRARY(${ADM_LIB} STATIC ${${ADM_LIB}_SRCS})
+ADD_ADM_LIB(${ADM_LIB} ADM_libraries)
+
+include_directories(${LIBXML2_INCLUDE_DIR})
+
+################################
+ADD_definitions(-DNDEBUG -DINLINE=inline)
+include_directories(.)
+

Added: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_libwrapper/CMakeLists.txt
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_libwrapper/CMakeLists.txt	2007-05-27 18:44:33 UTC (rev 3157)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_libwrapper/CMakeLists.txt	2007-05-28 13:03:46 UTC (rev 3158)
@@ -0,0 +1,13 @@
+################################
+#
+################################
+include(AdmLib)
+SET(ADM_LIB ADM_libwrapper)
+#
+SET(${ADM_LIB}_SRCS 
+libwrapper_amrnb.cpp  libwrapper.cpp  libwrapper_dca.cpp  libwrapper_global.cpp
+)
+ADD_LIBRARY(${ADM_LIB} STATIC ${${ADM_LIB}_SRCS})
+ADD_ADM_LIB(${ADM_LIB} ADM_libraries)
+
+################################

Added: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lvemux/CMakeLists.txt
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lvemux/CMakeLists.txt	2007-05-27 18:44:33 UTC (rev 3157)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lvemux/CMakeLists.txt	2007-05-28 13:03:46 UTC (rev 3158)
@@ -0,0 +1,16 @@
+################################
+#
+################################
+include(AdmLib)
+SET(ADM_LIB ADM_lvemux)
+#
+SET(${ADM_LIB}_SRCS 
+ADM_muxer.cpp
+mux_out.c
+)
+ADD_LIBRARY(${ADM_LIB} STATIC ${${ADM_LIB}_SRCS})
+ADD_ADM_LIB(${ADM_LIB} ADM_libraries)
+
+
+################################
+

Added: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/CMakeLists.txt
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/CMakeLists.txt	2007-05-27 18:44:33 UTC (rev 3157)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/CMakeLists.txt	2007-05-28 13:03:46 UTC (rev 3158)
@@ -0,0 +1,17 @@
+################################
+#
+################################
+include(AdmLib)
+SET(ADM_LIB ADM_mplex)
+#
+SET(${ADM_LIB}_SRCS 
+ac3strm_in.cpp      ADM_mplexout.cpp   audiostrm_out.cpp  dtsstrm_in.cpp  lpcmstrm_in.cpp   multiplexor.cpp   stream_params.cpp  videostrm_in.cpp   zalphastrm_out.cpp
+ADM_mplexin.cpp     ADM_mthread.cpp    bits.cpp           inputstrm.cpp   padstrm.cpp       systems.cpp        videostrm_out.cpp
+ADM_mplexmuxer.cpp  ADM_transfert.cpp  buffer.cpp         interact.cpp    mpastrm_in.cpp    stillsstream.cpp  vector.cpp         zalphastrm_in.cpp
+mpegconsts.c
+)
+ADD_LIBRARY(${ADM_LIB} STATIC ${${ADM_LIB}_SRCS})
+ADD_ADM_LIB(${ADM_LIB} ADM_libraries)
+################################
+include_directories(../ADM_libmpeg2enc  ../../ADM_userInterfaces/)
+

Added: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs/CMakeLists.txt
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs/CMakeLists.txt	2007-05-27 18:44:33 UTC (rev 3157)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_smjs/CMakeLists.txt	2007-05-28 13:03:46 UTC (rev 3158)
@@ -0,0 +1,15 @@
+################################
+#
+################################
+include(AdmLib)
+SET(ADM_LIB ADM_smjs)
+#
+SET(${ADM_LIB}_SRCS 
+jsapi.c    jsatom.c  jscntxt.c   jsdbgapi.c  jsemit.c  jsfun.c   jsinterp.c  jslong.c  jsobj.c     jsprf.c     jsscope.c   jsutil.c    prmjtime.c
+jsarena.c  jsbool.c  jscpucfg.c  jsdhash.c   jsexn.c   jsgc.c    jslock.c    jsmath.c  jsopcode.c  jsregexp.c  jsscript.c  jsxdrapi.c
+jsarray.c  jsdate.c    jsdtoa.c    jsfile.c  jshash.c  jslog2.c    jsnum.c   jsparse.c   jsscan.c    jsstr.c     jsxml.c
+)
+ADD_LIBRARY(${ADM_LIB} STATIC ${${ADM_LIB}_SRCS})
+ADD_ADM_LIB(${ADM_LIB} ADM_libraries)
+################################
+add_definitions( -DXP_UNIX -DSVR4 -DSYSV -D_BSD_SOURCE -DPOSIX_SOURCE -DHAVE_VA_COPY -DVA_COPY=va_copy)

Added: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_utilities/CMakeLists.txt
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_utilities/CMakeLists.txt	2007-05-27 18:44:33 UTC (rev 3157)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_utilities/CMakeLists.txt	2007-05-28 13:03:46 UTC (rev 3158)
@@ -0,0 +1,16 @@
+################################
+#
+################################
+include(AdmLib)
+SET(ADM_LIB ADM_utilities)
+#
+SET(${ADM_LIB}_SRCS 
+ADM_bitstream.cpp  ADM_image.cpp         ADM_imageUtils.cpp  ADM_print.cpp    aviframe.cpp    aviio.cpp   fourcc.cpp  subchunk.cpp
+ADM_fileio.cpp     ADM_imageResizer.cpp  ADM_pp.cpp          avidemutils.cpp  aviindexer.cpp  broken.cpp  prefs.cpp
+)
+ADD_LIBRARY(${ADM_LIB} STATIC ${${ADM_LIB}_SRCS})
+ADD_ADM_LIB(${ADM_LIB} ADM_libraries)
+
+include_directories(${LIBXML2_INCLUDE_DIR})
+
+################################

Added: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_xvidratectl/CMakeLists.txt
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_xvidratectl/CMakeLists.txt	2007-05-27 18:44:33 UTC (rev 3157)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_xvidratectl/CMakeLists.txt	2007-05-28 13:03:46 UTC (rev 3158)
@@ -0,0 +1,14 @@
+################################
+#
+################################
+include(AdmLib)
+SET(ADM_LIB ADM_xvidratectl)
+#
+SET(${ADM_LIB}_SRCS 
+ADM_oldxvid.cpp  ADM_xvidratectl.cpp  ADM_xvidratectlVBV.cpp
+)
+ADD_LIBRARY(${ADM_LIB} STATIC ${${ADM_LIB}_SRCS})
+ADD_ADM_LIB(${ADM_LIB} ADM_libraries)
+
+
+################################

Added: branches/avidemux_2.4_branch/avidemux/ADM_outputs/CMakeLists.txt
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_outputs/CMakeLists.txt	2007-05-27 18:44:33 UTC (rev 3157)
+++ branches/avidemux_2.4_branch/avidemux/ADM_outputs/CMakeLists.txt	2007-05-28 13:03:46 UTC (rev 3158)
@@ -0,0 +1,22 @@
+SET(ADM_outputs_SRCS 
+oplug_avi/op_avisavedual.cpp
+oplug_avi/op_savesmart.cpp
+oplug_avi/avilist.cpp
+oplug_avi/op_avisavecopy_pack.cpp
+oplug_avi/op_avisavecopy.cpp
+oplug_avi/op_aviwrite.cpp
+oplug_avi/op_avisavecopy_unpack.cpp
+oplug_avi/op_saveprocess.cpp
+oplug_avi/op_avisave.cpp
+oplug_mp4/oplug_mp4.cpp
+oplug_ogm/op_ogpage.cpp
+oplug_ogm/op_ogsaveprocess.cpp
+oplug_ogm/op_ogsave.cpp
+oplug_ogm/op_ogaudio.cpp
+oplug_ogm/op_ogsavecopy.cpp
+oplug_mpegFF/oplug_vcdff.cpp
+oplug_mpeg/op_mpegpass.cpp
+)
+ADD_LIBRARY(ADM_outputs STATIC ${ADM_outputs_SRCS})
+include_directories(./ ../ADM_inputs )
+

Added: branches/avidemux_2.4_branch/avidemux/ADM_outputs/oplug_avi/CMakeLists.txt
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_outputs/oplug_avi/CMakeLists.txt	2007-05-27 18:44:33 UTC (rev 3157)
+++ branches/avidemux_2.4_branch/avidemux/ADM_outputs/oplug_avi/CMakeLists.txt	2007-05-28 13:03:46 UTC (rev 3158)
@@ -0,0 +1,6 @@
+
+SET(ADM_oplug_avi_SRCS 
+avilist.cpp         op_avisavecopy_pack.cpp    op_avisave.cpp      op_aviwrite.cpp     op_savesmart.cpp
+op_avisavecopy.cpp  op_avisavecopy_unpack.cpp  op_avisavedual.cpp  op_saveprocess.cpp
+)
+ADD_LIBRARY(ADM_oplug_avi STATIC ${ADM_oplug_avi_SRCS})

Added: branches/avidemux_2.4_branch/avidemux/ADM_outputs/oplug_mp4/CMakeLists.txt
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_outputs/oplug_mp4/CMakeLists.txt	2007-05-27 18:44:33 UTC (rev 3157)
+++ branches/avidemux_2.4_branch/avidemux/ADM_outputs/oplug_mp4/CMakeLists.txt	2007-05-28 13:03:46 UTC (rev 3158)
@@ -0,0 +1,3 @@
+
+SET(ADM_oplug_mp4_SRCS oplug_mp4.cpp)
+ADD_LIBRARY(ADM_oplug_mp4 STATIC ${ADM_oplug_mp4_SRCS})

Added: branches/avidemux_2.4_branch/avidemux/ADM_outputs/oplug_mpeg/CMakeLists.txt
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_outputs/oplug_mpeg/CMakeLists.txt	2007-05-27 18:44:33 UTC (rev 3157)
+++ branches/avidemux_2.4_branch/avidemux/ADM_outputs/oplug_mpeg/CMakeLists.txt	2007-05-28 13:03:46 UTC (rev 3158)
@@ -0,0 +1,5 @@
+
+SET(ADM_oplug_mpeg_SRCS 
+op_mpegpass.cpp
+)
+ADD_LIBRARY(ADM_oplug_mpeg STATIC ${ADM_oplug_mpeg_SRCS})

Added: branches/avidemux_2.4_branch/avidemux/ADM_outputs/oplug_mpegFF/CMakeLists.txt
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_outputs/oplug_mpegFF/CMakeLists.txt	2007-05-27 18:44:33 UTC (rev 3157)
+++ branches/avidemux_2.4_branch/avidemux/ADM_outputs/oplug_mpegFF/CMakeLists.txt	2007-05-28 13:03:46 UTC (rev 3158)
@@ -0,0 +1,5 @@
+
+SET(ADM_oplug_mpegFF_SRCS 
+oplug_vcdff.cpp
+)
+ADD_LIBRARY(ADM_oplug_mpegFF STATIC ${ADM_oplug_mpegFF_SRCS})

Added: branches/avidemux_2.4_branch/avidemux/ADM_outputs/oplug_ogm/CMakeLists.txt
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_outputs/oplug_ogm/CMakeLists.txt	2007-05-27 18:44:33 UTC (rev 3157)
+++ branches/avidemux_2.4_branch/avidemux/ADM_outputs/oplug_ogm/CMakeLists.txt	2007-05-28 13:03:46 UTC (rev 3158)
@@ -0,0 +1,5 @@
+
+SET(ADM_oplug_ogm_SRCS 
+op_ogaudio.cpp  op_ogpage.cpp  op_ogsavecopy.cpp  op_ogsave.cpp  op_ogsaveprocess.cpp
+)
+ADD_LIBRARY(ADM_oplug_ogm STATIC ${ADM_oplug_ogm_SRCS})

Added: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/CMakeLists.txt
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/CMakeLists.txt	2007-05-27 18:44:33 UTC (rev 3157)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/CMakeLists.txt	2007-05-28 13:03:46 UTC (rev 3158)
@@ -0,0 +1,20 @@
+################################
+#
+################################
+include(AdmLib)
+SET(ADM_LIB ADM_dialogGtk)
+#
+SET(${ADM_LIB}_SRCS
+DIA_about.cpp     DIA_calculator.cpp   DIA_crop.cpp       DIA_flyDialog.cpp  DIA_mpdelogo.cpp  DIA_preview.cpp     DIA_srt.cpp      DIA_xvid4.cpp
+DIA_acodec.cpp    DIA_chromaShift.cpp  DIA_encoding.cpp   DIA_hue.cpp        DIA_ocr.cpp       DIA_properties.cpp  DIA_vcodec.cpp   DIA_xvid.cpp
+DIA_animated.cpp  DIA_cnr2.cpp         DIA_eq2.cpp        DIA_idx_pg.cpp     DIA_partial.cpp   DIA_quota.cpp       DIA_vobsub.cpp
+DIA_asharp.cpp    DIA_coloryuv.cpp     DIA_equalizer.cpp  DIA_jobs.cpp       DIA_pause.cpp     DIA_recent.cpp      DIA_working.cpp
+DIA_busy.cpp      DIA_contrast.cpp     DIA_exLame.cpp     DIA_jobs_save.cpp  DIA_pipe.cpp      DIA_resize.cpp      DIA_x264.cpp
+)
+ADD_LIBRARY(${ADM_LIB} STATIC ${${ADM_LIB}_SRCS})
+ADD_ADM_LIB(${ADM_LIB} ADM_libraries)
+
+
+################################
+ADD_definitions(${GTK_CFLAGS} -DADM_SUBVERSION=0 )
+include_directories(.. ../../../ADM_osSupport ../../../ADM_inputs)

Added: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialogFactory/CMakeLists.txt
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialogFactory/CMakeLists.txt	2007-05-27 18:44:33 UTC (rev 3157)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialogFactory/CMakeLists.txt	2007-05-28 13:03:46 UTC (rev 3158)
@@ -0,0 +1,18 @@
+################################
+#
+################################
+include(AdmLib)
+SET(ADM_LIB ADM_dialogFactoryGtk)
+#
+SET(${ADM_LIB}_SRCS
+DIA_color.cpp          DIA_filesel.cpp  FAC_bitrate.cpp  FAC_float.cpp  FAC_hex.cpp      FAC_menu.cpp   FAC_readOnlyText.cpp
+DIA_dialogFactory.cpp  FAC_bar.cpp      FAC_button.cpp   FAC_frame.cpp  FAC_integer.cpp  FAC_notch.cpp  FAC_toggle.cpp
+)
+ADD_LIBRARY(${ADM_LIB} STATIC ${${ADM_LIB}_SRCS})
+ADD_ADM_LIB(${ADM_LIB} ADM_libraries)
+
+
+################################
+ADD_definitions(${GTK_CFLAGS})
+include_directories(.. ../..)
+#../../../ADM_osSupport)

Added: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_filters/CMakeLists.txt
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_filters/CMakeLists.txt	2007-05-27 18:44:33 UTC (rev 3157)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_filters/CMakeLists.txt	2007-05-28 13:03:46 UTC (rev 3158)
@@ -0,0 +1,18 @@
+################################
+#
+################################
+include(AdmLib)
+SET(ADM_LIB ADM_filtersGtk)
+#
+SET(${ADM_LIB}_SRCS
+gui_filter.cpp  gui_filterlist.cpp  gui_filtermanager.cpp  gui_filtermanager_dialog.cpp  gui_filtersub.cpp
+
+)
+ADD_LIBRARY(${ADM_LIB} STATIC ${${ADM_LIB}_SRCS})
+ADD_ADM_LIB(${ADM_LIB} ADM_libraries)
+
+
+################################
+ADD_definitions(${GTK_CFLAGS} -DADM_SUBVERSION=0 )
+include_directories(.. ../..)
+#/../ADM_osSupport ../../../ADM_inputs)

Added: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_gui2/CMakeLists.txt
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_gui2/CMakeLists.txt	2007-05-27 18:44:33 UTC (rev 3157)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_gui2/CMakeLists.txt	2007-05-28 13:03:46 UTC (rev 3158)
@@ -0,0 +1,17 @@
+################################
+#
+################################
+include(AdmLib)
+SET(ADM_LIB ADM_gui2Gtk)
+#
+SET(${ADM_LIB}_SRCS
+GUI_bindings.cpp  GUI_gtkRender.cpp  GUI_keymap.cpp  GUI_main2.cpp
+)
+ADD_LIBRARY(${ADM_LIB} STATIC ${${ADM_LIB}_SRCS})
+ADD_ADM_LIB(${ADM_LIB} ADM_libraries)
+
+
+################################
+ADD_definitions(${GTK_CFLAGS} -DADM_SUBVERSION=0 )
+include_directories(.. ../..)
+#/../ADM_osSupport ../../../ADM_inputs)

Added: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_ocr/CMakeLists.txt
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_ocr/CMakeLists.txt	2007-05-27 18:44:33 UTC (rev 3157)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_ocr/CMakeLists.txt	2007-05-28 13:03:46 UTC (rev 3158)
@@ -0,0 +1,17 @@
+################################
+#
+################################
+include(AdmLib)
+SET(ADM_LIB ADM_ocrGtk)
+#
+SET(${ADM_LIB}_SRCS
+adm_ocr.cpp
+)
+ADD_LIBRARY(${ADM_LIB} STATIC ${${ADM_LIB}_SRCS})
+ADD_ADM_LIB(${ADM_LIB} ADM_libraries)
+
+
+################################
+ADD_definitions(${GTK_CFLAGS} -DADM_SUBVERSION=0 )
+include_directories(.. ../../../ADM_ocr)
+include_directories(../../../ADM_inputs)

Added: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_ocr/adm_ocr.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_ocr/adm_ocr.cpp	2007-05-27 18:44:33 UTC (rev 3157)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_ocr/adm_ocr.cpp	2007-05-28 13:03:46 UTC (rev 3158)
@@ -0,0 +1,807 @@
+/***************************************************************************
+                         
+        Very simple OCR engine
+
+        We do it in 3 passes
+        
+                Ask the vobsub decoder for a bitmap
+                Try to split the bitmap in lines
+                For each lines try to split in glyph (i.e. horizontal line)
+                Detour the glyph
+                If the detoured glyph has a width much less inferiror to its width
+                it probably means we have a italic or kerning.
+                In that case use the detouring to isolate the glyphs
+
+
+         A bit of warning. 
+                        The UI code is ugly.
+                        Bottom is the last actual line so to get height you have to to last-first +1 !
+
+    begin                : Jan 2005
+    copyright            : (C) 2002 by mean
+    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include &quot;config.h&quot;
+#include &lt;stdio.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;string.h&gt;
+#include &quot;gtk/gtk.h&quot;
+#include &lt;ADM_assert.h&gt;
+
+
+#include &quot;fourcc.h&quot;
+#include &quot;avio.hxx&quot;
+#include &quot;config.h&quot;
+#include &quot;avi_vars.h&quot;
+
+//#include &quot;unistd.h&quot;
+
+#include &quot;ADM_toolkit/toolkit.hxx&quot;
+#include &quot;../ADM_GTK/ADM_toolkit_gtk/toolkit_gtk.h&quot;
+#include &quot;../ADM_GTK/ADM_toolkit_gtk/toolkit_gtk_include.h&quot;
+#include &quot;ADM_editor/ADM_edit.hxx&quot;
+#include &quot;ADM_video/ADM_genvideo.hxx&quot;
+#include &quot;ADM_filter/video_filters.h&quot;
+
+#include &quot;ADM_toolkit/toolkit.hxx&quot;
+#include &quot;ADM_editor/ADM_edit.hxx&quot;
+#include &quot;ADM_video/ADM_genvideo.hxx&quot;
+#include &quot;ADM_filter/video_filters.h&quot;
+
+
+#include &quot;ADM_toolkit/filesel.h&quot;
+
+#include &quot;ADM_colorspace/colorspace.h&quot;
+
+#include &quot;ADM_video/ADM_vobsubinfo.h&quot;
+
+#include &quot;ADM_video/ADM_vidVobSub.h&quot;
+#include &quot;ADM_leftturn.h&quot;
+#include &quot;DIA_enter.h&quot;
+/******************************/
+#define GTK_PURGE {while (gtk_events_pending())                gtk_main_iteration(); }    
+#define TESTSUB &quot;/home/fx/usbstick/subs/vts_01_0.idx&quot;
+#define CONNECT(x,y,z) 	gtk_signal_connect(GTK_OBJECT(WID(x)), #y,GTK_SIGNAL_FUNC(z),   NULL);
+#define SUB_THRESH minThreshold
+
+typedef enum 
+{
+        ReplyOk=1,
+        ReplyClose=0,
+        ReplyCalibrate=2,
+        ReplySkip=3,
+        ReplySkipAll=4
+}ReplyType;
+
+static uint8_t mergeBitmap(uint8_t *bitin, uint8_t *bitout, uint8_t *maskin,uint32_t w, uint32_t h);
+static ReplyType ocrBitmap(uint8_t *data,uint32_t w,uint32_t h);
+static ReplyType handleGlyph(uint32_t start, uint32_t end,uint32_t w,uint32_t h,uint32_t base);
+static uint8_t lineEmpty(uint8_t *base, uint32_t stride, uint32_t width, uint32_t line);
+static uint8_t columnEmpty(uint8_t *base, uint32_t stride, uint32_t height);
+static ReplyType glyphToText(admGlyph *glyph);
+static uint8_t saveGlyph(void);
+static uint8_t loadGlyph(char *name);
+static void displaySmall( admGlyph *glyph );
+static int cb_accept(GtkObject * object, gpointer user_data);
+static ReplyType setup(void);
+static  vobSubParam subparam={NULL,0,0};
+static uint32_t minAlpha=7;
+static uint32_t minThreshold=0x80;
+
+
+/*++++++++++++++++++++++++++++++++++++++++*/
+extern  GtkWidget	*DIA_ocr(void);
+extern  uint8_t DIA_vobsub(vobSubParam *param);
+static gboolean gui_draw( void );
+static gboolean gui_draw_small( void );
+static char decodedString[1024];
+/*-------------------------*/
+static GtkWidget *dialog;
+static GtkWidget *mainDisplay;
+static GtkWidget *smallDisplay;
+static vobSubBitmap *bitmap;
+
+static uint8_t *workArea;
+static admGlyph head(250,4);
+static uint32_t lang_index=0;
+
+
+static uint32_t redraw_x,redraw_y;
+
+static uint32_t nbGlyphs;
+
+
+typedef enum
+{
+    actionLoadVob=10,
+    actionSaveSub,
+    actionGo,
+    actionLoadGlyph,
+    actionSaveGlyph,
+    actionSkip,
+    actionSkipAll,
+    actionAccept,
+    actionIgnore,
+    actionCalibrate
+}ocrAction;
+/* +++++++++++++++++++++++++++++++++++++++++++++++++++++++
+        Main
+   +++++++++++++++++++++++++++++++++++++++++++++++++++++++ */
+uint8_t ADM_ocr_engine( void)
+{
+// 
+    uint32_t nbSub=0;
+    FILE *out=NULL;
+    head.next=NULL;
+    ADMVideoVobSub *vobsub=NULL;
+    uint32_t startTime,endTime;
+    uint32_t w,h,oldw=0,oldh=0;
+    uint32_t oldbitmapw=0;
+    uint32_t oldbitmaph=0;
+    uint32_t first,last;
+    uint32_t seqNum;
+    char     text[1024];
+    lang_index=0;
+    nbGlyphs=0;
+    ReplyType reply;
+    
+// Create UI &amp;&amp; prepare callback
+    
+    dialog=DIA_ocr();
+    gtk_register_dialog(dialog);
+#define ASSOCIATE(x,y)   gtk_dialog_add_action_widget (GTK_DIALOG (dialog), WID(x),y)
+    ASSOCIATE(buttonStart,actionGo);
+    ASSOCIATE(buttonOk,   actionAccept);
+    ASSOCIATE(buttonSkip,     actionSkip);
+    ASSOCIATE(buttonSkipAll,     actionSkipAll);
+    ASSOCIATE(buttonIgnore,   actionIgnore);
+    ASSOCIATE(buttonCalibrate,   actionCalibrate);
+    
+    ASSOCIATE(buttonGlyphLoad,   actionLoadGlyph);
+    ASSOCIATE(buttonGlyphSave,   actionSaveGlyph);
+    
+    ASSOCIATE(buttonVobsub,   actionLoadVob);
+    ASSOCIATE(buttonSrt,   actionSaveSub);
+   
+    gtk_widget_show(dialog);
+//  disable
+    
+    mainDisplay=WID(drawingareaBitmap);
+    smallDisplay=WID(drawingareaSmall);
+    
+    CONNECT(drawingareaBitmap,expose_event,gui_draw);
+    CONNECT(drawingareaSmall,expose_event,gui_draw_small);
+
+    CONNECT(entry,activate,cb_accept);
+_again:    
+    reply=setup();
+    if(reply==ReplyClose) goto endIt;
+    
+    printf(&quot;Go go go\n&quot;);
+    
+    // Everything ready go go go 
+         
+    redraw_x=redraw_y=0;
+    GTK_PURGE;
+//  Time to go
+    // Inactivate frame1=glyph    frame2=in/out  buttonStart
+    gtk_widget_set_sensitive(WID(buttonStart),0);
+    gtk_widget_set_sensitive(WID(frameGlyph),0);
+    gtk_widget_set_sensitive(WID(frameLoad),0);
+    gtk_widget_set_sensitive(WID(frameBitmap),1);
+
+    gtk_widget_set_sensitive(WID(buttonStart),0);
+   
+  
+   char *fileout;
+   fileout=(char *)gtk_label_get_text(GTK_LABEL(WID(labelSrt)));
+   if(!fileout)
+    {
+      GUI_Error_HIG(_(&quot;Incorrect output file&quot;), NULL);
+        goto _again;
+    }
+    out=fopen(fileout,&quot;wb&quot;);
+    if(!out)
+    {
+      GUI_Error_HIG(_(&quot;Output file error&quot;), _(&quot;Could not open \&quot;%s\&quot; for writing.&quot;), fileout);
+        goto _again;
+    }
+     
+    vobsub=new ADMVideoVobSub(subparam.subname,subparam.index);
+    nbSub=vobsub-&gt;getNbImage();
+   
+    if(!nbSub)
+    {
+      GUI_Error_HIG(_(&quot;Problem loading sub&quot;), NULL);
+        delete vobsub;
+        vobsub=NULL;
+        goto _again;
+     }
+    seqNum=1;   // Sub number in srt file
+    oldw=oldh=0;
+
+    //******************    
+    // Load all bitmaps
+    //******************
+    for(uint32_t i=0;i&lt;nbSub;i++)
+    {
+            first=last=0;
+            bitmap=vobsub-&gt;getBitmap(i,&amp;startTime, &amp;endTime,&amp;first,&amp;last);
+            ADM_assert(last&gt;=first);
+            
+            // something ?
+            if(!bitmap) continue;
+            if(first==last) continue;
+
+            // If the bitmap size changed or does not exist yet...
+            if(!workArea || oldbitmapw!=bitmap-&gt;_width || oldbitmaph!=bitmap-&gt;_height)
+            {
+              if(workArea) 
+              {
+                delete [] workArea;
+                workArea=NULL; 
+              }
+              // Workarea is actually bigger than what we use
+              workArea=new uint8_t[bitmap-&gt;_width*(bitmap-&gt;_height)];
+              memset(workArea,0,bitmap-&gt;_width*(bitmap-&gt;_height));
+            }
+            oldbitmaph=bitmap-&gt;_height;
+            oldbitmapw=bitmap-&gt;_width;
+           // 
+           w=bitmap-&gt;_width;
+           h=last-first+1;
+           redraw_x=w;
+           redraw_y=h;
+           //**
+           
+           // Build
+againPlease:
+           mergeBitmap(bitmap-&gt;_bitmap+first*w, workArea, bitmap-&gt;_alphaMask+first*w,  w,   h);
+           if(oldw!=w || oldh !=h)
+           {                
+                GTK_PURGE;  // Force redaw
+           }
+           // Merge
+             GTK_PURGE;
+             gui_draw();
+             GTK_PURGE; 
+             // OCR
+              reply=ocrBitmap(workArea,w,h);
+              if(reply==ReplyClose) goto endIt;
+              if(reply==ReplyCalibrate)
+                {
+                        //
+                        //printf(&quot;TADA!!!!\n&quot;);
+                        int val;
+#if 0
+                         val=minAlpha;
+                        if(DIA_GetIntegerValue(&amp;val, 3, 7, &quot;Minimum alpha value&quot;, &quot;Enter new minimum alpha&quot;))
+                        {
+                                minAlpha=val;
+
+                        }
+#endif
+                        val=minThreshold;
+                        if(DIA_GetIntegerValue(&amp;val, 0x30, 0x80, &quot;Minimum pixel value&quot;, &quot;Enter new minimum pixel&quot;))
+                        {
+                                minThreshold=val;
+
+                        }
+                        goto againPlease;
+                }
+             
+             //
+             gtk_label_set_text(GTK_LABEL(WID(labelText)),decodedString);
+             fprintf(out,&quot;%d\n&quot;,seqNum++);
+             uint16_t hh,mm,ss,ms;
+             ms2time(startTime, &amp;hh, &amp;mm, &amp;ss, &amp;ms);
+             fprintf(out,&quot;%02d:%02d:%02d,%03d --&gt; &quot;,hh,mm,ss,ms);
+             ms2time(endTime, &amp;hh, &amp;mm, &amp;ss, &amp;ms);
+             fprintf(out,&quot;%02d:%02d:%02d,%03d\n&quot;,hh,mm,ss,ms);
+             fprintf(out,&quot;%s\n\n&quot;,decodedString);
+             //             
+             oldw=w;
+             oldh=h;
+             // Update infos
+             sprintf(text,&quot;%03d/%03d&quot;,i+1,nbSub);
+             gtk_label_set_text(GTK_LABEL(WID(labelNbLines)),text);
+             sprintf(text,&quot;%03d&quot;,nbGlyphs);
+             gtk_label_set_text(GTK_LABEL(WID(labelNbGlyphs)),text);
+    }
+
+endIt:
+    // Final round
+    gtk_widget_set_sensitive(WID(frameGlyph),1);
+    gtk_widget_set_sensitive(WID(frameLoad),0);
+    gtk_widget_set_sensitive(WID(buttonStart),0);  
+    gtk_widget_set_sensitive(WID(frameBitmap),0);
+   // gtk_widget_set_sensitive(WID(Current_Glyph),0); 
+    
+    if(nbGlyphs &amp;&amp; actionSaveGlyph==gtk_dialog_run(GTK_DIALOG(dialog)))
+        saveGlyph();
+    if(vobsub)
+        delete vobsub;
+    vobsub=NULL;
+    if(out) 
+        fclose(out);
+    out=NULL;
+    gtk_unregister_dialog(dialog);
+    gtk_widget_destroy(dialog);
+    if(head.next)
+        destroyGlyphTree(&amp;head);
+    head.next=NULL;
+    return 1;
+
+}
+
+//*****************************************************************************************
+//  Separate the bitmap into glyph and handle each glyph on itw own
+//
+//*****************************************************************************************
+
+ReplyType ocrBitmap(uint8_t *data,uint32_t w,uint32_t h)
+{
+uint8_t found;
+uint32_t colstart=0,colend=0,oldcol;
+uint32_t line=0,nbLine=1;
+uint32_t base=0,bottom,top;    
+ReplyType reply;
+    // Search First non nul colum
+    decodedString[0]=0;
+    // Search how much lines there is in the file
+    //
+    top=bottom=0;
+    while(top&lt;h)
+    {
+        // Search non empty line as top
+        while(top&lt;h &amp;&amp; lineEmpty(workArea,w,w,top)) top++;
+        // Nothing found
+        if(top&gt;=h-1) break;
+
+        // 
+       
+
+        bottom=top+1;
+        // Search empty line if any, bottom is the 1st line full of zero
+        while(bottom&lt;h &amp;&amp; (!lineEmpty(workArea,w,w,bottom) || bottom-top&lt;7))
+        {
+            bottom++;
+        }
+        if(line) strcat(decodedString,&quot;\n&quot;); 
+        //printf(&quot;\n Top:%lu bottom:%lu\n&quot;,top,bottom);
+       
+        // Scan a full line
+        colstart=0;
+        oldcol=0;
+       
+        // Split a line into glyphs
+        while(colstart&lt;w)
+        {
+            GTK_PURGE;
+            oldcol=colstart;
+            while( columnEmpty(workArea+colstart+top*w, w, bottom-top) &amp;&amp; colstart&lt;w) colstart++;
+            if(colstart&gt;=w) break;
+            // if too far apart, it means probably a blank space
+            if(colstart-oldcol&gt;6)
+            {
+                strcat(decodedString,&quot; &quot;);
+            }
+       
+            // We have found a non null column
+            // Seek the end now
+            colend=colstart+1;
+            while( !columnEmpty(workArea+colend+top*w, w, bottom-top) &amp;&amp; colend&lt;w) colend++;
+         
+         
+            // printf(&quot;Found glyph: %lu %lu\n&quot;,colstart,colend);  
+            reply=handleGlyph(colstart,colend,w,bottom,top);
+            switch(reply)
+                {
+                        case ReplySkip:break;
+                        case ReplyOk:break;
+                        case ReplyClose:
+                        case ReplyCalibrate: return reply;break;
+            
+                        case ReplySkipAll: return ReplyOk;break;
+                        default: ADM_assert(0);
+                }
+            
+            
+            colstart=colend;
+      }
+      line++;      
+      top=bottom;
+      
+    }
+   
+    return ReplyOk;
+}
+//*****************************************************************************************
+/*
+    We now have a good candidate for the glyph.
+    We will do the following processing :
+        - Clip the glyph to have it in its bounding box
+        - extract its container. If the container is smaller than the glyph, it means
+                that we have in fact several glyphs that overlaps slightly. In
+                that case we use another method to extract the glyph.
+                We split it using leftturn method and do it again.
+*/
+ReplyType handleGlyph(uint32_t start, uint32_t end,uint32_t w,uint32_t h,uint32_t base)
+{
+uint8_t found=0;
+static int inc=1;
+ReplyType reply;
+          
+    
+    // Ok now we have the cropped glyp
+    
+    admGlyph *glyph,*cand;
+    uint32_t minx,maxx,miny,maxy;
+    int     *raw=NULL;
+            glyph=new admGlyph(end-start,h-base);
+            glyph-&gt;create(workArea+start+base*w,w);
+            glyph=clippedGlyph(glyph);
+            if(!glyph-&gt;width) // Empty glyph
+            {
+                delete glyph;
+                return ReplyOk;
+            }
+            // now we have our full glyph, try harder to split it
+_nextglyph:
+            raw=new int[glyph-&gt;height];            
+            if(adm_estimate_glyphSize(glyph,&amp;minx, &amp;maxx,&amp;miny,&amp;maxy,raw))
+            {
+            //printf(&quot;Glyph width :%lu min:%lu max:%lu estimate width:%lu\n&quot;,glyph-&gt;width,minx,maxx,maxx-minx+1);
+            if((maxx-minx+2)&lt;glyph-&gt;width &amp;&amp; (maxx-minx&gt;2) &amp;&amp; (maxy-miny&gt;2))
+            {
+                // Suspicously too small
+                // We have to split the glyph
+                // recursively to extract each glyph
+                uint32_t width=maxx-minx+1;
+                uint32_t defStride=width+1;
+                
+                if(defStride&gt;glyph-&gt;width) defStride=glyph-&gt;width;
+                
+                admGlyph *lefty=new admGlyph(defStride,glyph-&gt;height);
+                for(int32_t i=miny;i&lt;=maxy;i++)
+                {
+                    if(raw[i]!=-1) memcpy(&amp;(lefty-&gt;data[0+i*defStride]),&amp;(glyph-&gt;data[minx+i*glyph-&gt;width]),raw[i]+1-minx);
+                    else
+                            memcpy(&amp;(lefty-&gt;data[0+i*defStride]),&amp;(glyph-&gt;data[minx+i*glyph-&gt;width]),defStride);
+                }
+                lefty=clippedGlyph(lefty);
+              
+                {
+                    // Remove that from the original
+                    for(uint32_t i=0;i&lt;glyph-&gt;height;i++)
+                    {
+                        //printf(&quot;%d:%d(%d)\n&quot;,i,raw[i],glyph-&gt;width);
+                        if(raw[i]!=-1) memset(&amp;(glyph-&gt;data[i*glyph-&gt;width]),0,raw[i]+1);
+                        else           memset(&amp;(glyph-&gt;data[i*glyph-&gt;width]),0,defStride); 
+                    }
+                    // Clip
+                    glyph=clippedGlyph(glyph);
+                
+                    if(lefty-&gt;width)
+                    {
+                        reply=glyphToText(lefty);
+                        if(reply!=ReplyOk)
+                        {
+                            printf(&quot;Glyph2text failed(1)\n&quot;);
+                            return reply;
+                        }
+                    }
+                    else
+                        delete lefty;
+                    if(glyph-&gt;width)
+                    {
+                        if(raw) delete [] raw;
+                        goto _nextglyph;                    
+                    } 
+                 }           
+            }
+            }//If
+            if(raw) delete [] raw;
+            if(glyph-&gt;width)
+            {
+                reply=glyphToText(glyph);
+                if(reply!=ReplyOk)                 
+                {
+                    printf(&quot;Glyph2text failed(2)\n&quot;);
+                    return reply;
+                }
+            }
+            else 
+            {
+                delete glyph;
+            }
+            
+    return ReplyOk;
+
+}
+/**
+        Search throught the existing glyphs , if not present create it
+        and append the text to decodedString
+*/
+ReplyType glyphToText(admGlyph *glyph)
+{
+ admGlyph *cand;
+            //printf(&quot;2t: %d x %d\n&quot;,glyph-&gt;width,glyph-&gt;height);
+            if(glyph-&gt;width&lt;2 &amp;&amp; glyph-&gt;height&lt;2)
+            {
+                delete glyph;
+                return ReplyOk;
+            }
+            cand=searchGlyph(&amp;head,glyph);
+            if(!cand) // New glyph
+            {
+                char *string;
+                // Draw it
+                displaySmall(glyph); 
+                gtk_label_set_text(GTK_LABEL(WID(labelText)),decodedString);
+                gtk_editable_delete_text(GTK_EDITABLE(WID(entry)), 0,-1);
+                
+                //gtk_widget_set_sensitive(WID(buttonAccept),1);
+                //gtk_widget_set_sensitive(WID(buttonSkip),1);
+                //gtk_widget_set_sensitive(WID(entryEntry),1);
+                
+                gtk_widget_grab_focus (WID(entry));
+                gtk_widget_grab_default (WID(buttonOk));
+                
+                //printf(&quot;i\n&quot;);
+                switch(gtk_dialog_run(GTK_DIALOG(dialog)))
+                {
+                case actionIgnore:
+                        glyph-&gt;code=NULL;
+                        insertInGlyphTree(&amp;head,glyph);
+                        nbGlyphs++;
+                        break;
+                case actionCalibrate: return ReplyCalibrate;
+                case actionAccept:
+                    string =gtk_editable_get_chars(GTK_EDITABLE (WID(entry)), 0, -1);
+                    if(string&amp;&amp; strlen(string))
+                    {
+                        glyph-&gt;code=ADM_strdup(string);
+                        insertInGlyphTree(&amp;head,glyph);
+                        //printf(&quot;New glyph:%s\n&quot;,glyph-&gt;code);
+                        strcat(decodedString,glyph-&gt;code);
+                        nbGlyphs++;
+                       
+                    }
+                    else delete glyph;
+                    break;
+                case actionSkip: //SKIP
+                    return ReplySkip;
+                    break;
+                case actionSkipAll:
+                    return ReplySkipAll;
+                    break;
+                case GTK_RESPONSE_CLOSE:
+                  if(GUI_Question(_(&quot;Sure ?&quot;))) return ReplyClose;
+                    break; // Abort
+                    
+                }
+                gtk_editable_delete_text(GTK_EDITABLE(WID(entry)), 0,-1);
+                //gtk_widget_set_sensitive(WID(buttonAccept),0);
+                //gtk_widget_set_sensitive(WID(buttonSkip),0);
+                //gtk_widget_set_sensitive(WID(entryEntry),0);
+            }
+            else
+            {
+                //printf(&quot;Glyph known :%s \n&quot;,cand-&gt;code);
+                if(cand-&gt;code)
+                    strcat(decodedString,cand-&gt;code);
+                delete glyph;
+            }
+           return ReplyOk;  
+
+}
+/**************************************************************************************
+    returns 1 if the line is empty
+    0 if not
+*/
+
+//*****************************************************************************************
+uint8_t mergeBitmap(uint8_t *bitin, uint8_t *bitout, uint8_t *maskin,uint32_t w, uint32_t h)
+{
+// Merge with alpha channel
+           uint8_t *in,*mask,*out;
+           uint32_t alp,nw;
+           in=bitin;
+           out=bitout;
+           mask=maskin;
+           for(uint32_t y=0;y&lt;h;y++)
+           {
+            for(uint32_t x=0;x&lt;w;x++)
+            {
+                   
+                    nw=in[x];
+                    alp=mask[x];
+
+                    if(alp&gt;minAlpha&amp;&amp; nw &gt;SUB_THRESH)  nw=0xff;
+                         else       nw=0;
+                        
+                    out[x]=nw;
+            }
+            out+=w;
+            in+=w;
+            mask+=w;
+           }    
+    return 1;
+}
+//*****************************************************************************************
+gboolean gui_draw( void )
+{
+static int lastx=0,lasty=0;
+    if(lastx!=redraw_x || lasty!=redraw_y)
+        gtk_widget_set_usize(mainDisplay, redraw_x, redraw_y);
+    lastx=redraw_x;
+    lasty=redraw_y;
+    
+    gdk_draw_gray_image(mainDisplay-&gt;window, mainDisplay-&gt;style-&gt;fg_gc[GTK_STATE_NORMAL],
+                        0,                          // X
+                        0,                          // y
+                        redraw_x,                          //width
+                        redraw_y,                          //h*2, // heigth
+                        GDK_RGB_DITHER_NONE,
+                        workArea, // buffer
+                        redraw_x );
+    return true;
+}
+//*****************************************************************************************
+ static int sx=0,sy=0,sw=0,sh=0;
+ uint8_t *sdata=NULL;
+void displaySmall( admGlyph *glyph)
+{
+    if(sw!=glyph-&gt;width || sh!=glyph-&gt;height)
+    {
+        if(sdata) delete [] sdata;
+        sdata=NULL;
+        sw=glyph-&gt;width;
+        sh=glyph-&gt;height;
+        sdata=new uint8_t[(sw*2+2)*(sh*2+2)];
+        gtk_widget_set_usize(smallDisplay, sw*2+2, sh*2+2);
+    }
+    uint32_t stride=sw*2+2;
+    uint8_t *in=glyph-&gt;data;
+    uint8_t *out=sdata;
+    
+    memset(out,0,stride);
+    out+=stride;
+    for(uint32_t y=0;y&lt;sh;y++)
+    {
+      *(out++)=0;
+      for(uint32_t x=0;x&lt;sw;x++)
+      {
+        out[1]=out[0]=out[stride]=out[stride+1]=*in;
+        out+=2; 
+        in++;
+        
+      } 
+      *(out++)=0;
+      out+=stride;      
+    }
+    memset(out,0,stride);
+    //memcpy(sdata,glyph-&gt;data,sw*sh);
+    gui_draw_small();
+} 
+
+gboolean gui_draw_small(void)
+{ 
+ if(sw &amp;&amp; sh &amp;&amp; sdata)
+    gdk_draw_gray_image(smallDisplay-&gt;window, smallDisplay-&gt;style-&gt;fg_gc[GTK_STATE_NORMAL],
+                        0,                          // X
+                        0,                          // y
+                        sw*2+2,                          //width
+                        sh*2+2,                          //h*2, // heigth
+                        GDK_RGB_DITHER_NONE,
+                        sdata, // buffer
+                        sw*2+2 );
+    return true;
+}
+
+/******************************************************************************************
+ Setup (input/output files etc..)
+*****************************************************************************************/
+ReplyType setup(void)
+{
+int sel;
+char text[1024];
+    while(1)
+    {
+    //gtk_widget_set_sensitive(WID(buttonAccept),0);
+    //gtk_widget_set_sensitive(WID(buttonSkip),0);
+    //gtk_widget_set_sensitive(WID(entryEntry),0);
+    GTK_PURGE;   
+    // Main loop : Only accept glyph load/save
+    // Sub &amp; srt select &amp; start ocr
+    gtk_widget_set_sensitive(WID(frameGlyph),1);
+    gtk_widget_set_sensitive(WID(frameLoad),1);
+    gtk_widget_set_sensitive(WID(buttonStart),1);
+    
+    gtk_widget_set_sensitive(WID(frameBitmap),0);
+    //gtk_widget_set_sensitive(WID(Current_Glyph),0); 
+     switch(sel=gtk_dialog_run(GTK_DIALOG(dialog)))
+     {
+        case actionLoadVob:
+                {
+                   
+                        subparam.index=lang_index;
+                        subparam.subname=NULL;
+                        if(DIA_vobsub(&amp;subparam))
+                        {
+                            lang_index=subparam.index;
+                            gtk_label_set_text(GTK_LABEL(WID(labelVobsub)),subparam.subname);
+                        }
+                        
+                    
+                }
+                break;
+        case actionSaveSub:
+                {
+                    char *srt=NULL;
+                    GUI_FileSelWrite(_(&quot;Select SRT to save&quot;), &amp;srt);
+                    if(srt)
+                    {
+                        gtk_label_set_text(GTK_LABEL(WID(labelSrt)),srt);
+                    }
+                }
+                break;
+        
+        case actionLoadGlyph:
+            {
+                 char *gly=NULL;
+                    
+                    GUI_FileSelRead(_(&quot;Select Glyoh to save&quot;), &amp;gly);
+                    if(gly)
+                    {
+                            loadGlyph(gly);
+                            sprintf(text,&quot;%03d&quot;,nbGlyphs);
+                            gtk_label_set_text(GTK_LABEL(WID(labelNbGlyphs)),text);
+                    }
+            }
+                break;
+        
+        case actionSaveGlyph:
+            
+                    if(!nbGlyphs)
+                    {
+                      GUI_Error_HIG(_(&quot;No glyphs to save&quot;), NULL);
+                        break;
+                    }                  
+                    saveGlyph();                                      
+                    break;
+        
+        case GTK_RESPONSE_CLOSE: 
+            printf(&quot;Close req\n&quot;);
+            return ReplyClose;
+        default:
+            printf(&quot;Other input:%d\n&quot;,sel);
+     }
+    // Everything selected, check
+    if(sel==actionGo) return ReplyOk;
+    }
+}
+/**
+*/
+int cb_accept(GtkObject * object, gpointer user_data)
+{
+        //printf(&quot;Hopla\n&quot;);
+        gtk_signal_emit_by_name(GTK_OBJECT(WID(buttonOk)),&quot;clicked&quot;,(gpointer)1);
+        return 0;
+
+}
+
+/**
+ */
+#include &quot;ADM_ocrLoadSave.h&quot;
+//;

Added: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_toolkit_gtk/CMakeLists.txt
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_toolkit_gtk/CMakeLists.txt	2007-05-27 18:44:33 UTC (rev 3157)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_toolkit_gtk/CMakeLists.txt	2007-05-28 13:03:46 UTC (rev 3158)
@@ -0,0 +1,17 @@
+################################
+#
+################################
+include(AdmLib)
+SET(ADM_LIB ADM_toolkitGtk)
+#
+SET(${ADM_LIB}_SRCS
+ADM_gladeSupport.cpp  ADM_tray_gtk.cpp  choice.cpp  TLK_filesel.cpp  toolkit.cpp  toolkit_dialog.cpp 
+                                        eggtrayicon.c eggtray_win32.c gtkmarkscale.c
+)
+ADD_LIBRARY(${ADM_LIB} STATIC ${${ADM_LIB}_SRCS})
+ADD_ADM_LIB(${ADM_LIB} ADM_libraries)
+
+
+################################
+ADD_definitions(${GTK_CFLAGS})
+include_directories(.. ../../../ADM_osSupport)

Added: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/CMakeLists.txt
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/CMakeLists.txt	2007-05-27 18:44:33 UTC (rev 3157)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/CMakeLists.txt	2007-05-28 13:03:46 UTC (rev 3158)
@@ -0,0 +1,7 @@
+subdirs(PREORDER ADM_dialog)
+subdirs(PREORDER ADM_dialogFactory)
+subdirs(PREORDER ADM_filters)
+subdirs(PREORDER ADM_gui2)
+subdirs(PREORDER ADM_toolkit_gtk)
+subdirs(PREORDER ADM_ocr)
+include_directories(../ADM_commonUI)

Added: branches/avidemux_2.4_branch/cmake/AdmLib.cmake
===================================================================
--- branches/avidemux_2.4_branch/cmake/AdmLib.cmake	2007-05-27 18:44:33 UTC (rev 3157)
+++ branches/avidemux_2.4_branch/cmake/AdmLib.cmake	2007-05-28 13:03:46 UTC (rev 3158)
@@ -0,0 +1,12 @@
+MACRO (ADD_ADM_LIB _libName _father)
+GET_TARGET_PROPERTY(Foo ${_libName} LOCATION)
+STRING(REGEX REPLACE &quot;${_father}.${_libName}&quot; &quot;${_father}&quot; NewFoo &quot;${Foo}&quot; )
+#SET_TARGET_PROPERTIES(${_libName} PROPERTIES 
+        #PREFIX &quot;../lib&quot;
+        #)
+
+#MESSAGE (&quot;LOCATION:&quot;${Foo}&quot;-&gt;&quot;${NewFoo})
+#GET_TARGET_PROPERTY(Foo ${_libName} LOCATION)
+#MESSAGE (&quot;AFTER LOCATION:&quot;${Foo}&quot;-&gt;&quot;${NewFoo})
+ENDMACRO (ADD_ADM_LIB _libName)
+

Added: branches/avidemux_2.4_branch/cmake/FindGTK.cmake
===================================================================
--- branches/avidemux_2.4_branch/cmake/FindGTK.cmake	2007-05-27 18:44:33 UTC (rev 3157)
+++ branches/avidemux_2.4_branch/cmake/FindGTK.cmake	2007-05-28 13:03:46 UTC (rev 3158)
@@ -0,0 +1,186 @@
+# - try to find GTK (and glib) and GTKGLArea
+#  GTK_INCLUDE_DIR   - Directories to include to use GTK
+#  GTK_LIBRARIES     - Files to link against to use GTK
+#  GTK_FOUND         - GTK was found
+#  GTK_GL_FOUND      - GTK's GL features were found
+
+# don't even bother under WIN32
+IF(UNIX)
+
+  FIND_PATH( GTK_gtk_INCLUDE_PATH gtk/gtk.h
+    /usr/include
+    /usr/local/include
+    /usr/openwin/share/include
+    /usr/openwin/include
+    /usr/X11R6/include
+    /usr/include/X11
+    /usr/X11R6/include/gtk12
+    /usr/include/gtk-1.2
+    /usr/local/include/gtk-1.2
+    /opt/gnome/include
+  )
+
+  # Some Linux distributions (e.g. Red Hat) have glibconfig.h
+  # and glib.h in different directories, so we need to look
+  # for both.
+  #  - Atanas Georgiev &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">atanas at cs.columbia.edu</A>&gt;
+
+  FIND_PATH( GTK_glibconfig_INCLUDE_PATH glibconfig.h
+    /usr/include
+    /usr/local/include
+    /usr/openwin/share/include
+    /usr/local/include/glib12
+    /usr/lib/glib/include
+    /usr/local/lib/glib/include
+    /opt/gnome/include
+    /opt/gnome/lib/glib/include
+  )
+
+  FIND_PATH( GTK_glib_INCLUDE_PATH glib.h
+    /usr/include
+    /usr/local/include
+    /usr/openwin/share/include
+    /usr/include/gtk-1.2
+    /usr/local/include/glib12
+    /usr/lib/glib/include
+    /usr/include/glib-1.2
+    /usr/local/include/glib-1.2
+    /opt/gnome/include
+    /opt/gnome/include/glib-1.2
+  )
+
+  FIND_PATH( GTK_gtkgl_INCLUDE_PATH gtkgl/gtkglarea.h
+    /usr/include
+    /usr/local/include
+    /usr/openwin/share/include
+    /opt/gnome/include
+  )
+
+  FIND_LIBRARY( GTK_gtkgl_LIBRARY gtkgl
+    /usr/lib
+    /usr/local/lib
+    /usr/openwin/lib
+    /usr/X11R6/lib
+    /opt/gnome/lib
+  )
+
+  #
+  # The 12 suffix is thanks to the FreeBSD ports collection
+  #
+
+  FIND_LIBRARY( GTK_gtk_LIBRARY
+    NAMES  gtk gtk12
+    PATHS /usr/lib
+          /usr/local/lib
+          /usr/openwin/lib
+          /usr/X11R6/lib
+          /opt/gnome/lib
+  )
+
+  FIND_LIBRARY( GTK_gdk_LIBRARY
+    NAMES  gdk gdk12
+    PATHS  /usr/lib
+           /usr/local/lib
+           /usr/openwin/lib
+           /usr/X11R6/lib
+           /opt/gnome/lib
+  )
+
+  FIND_LIBRARY( GTK_gmodule_LIBRARY
+    NAMES  gmodule gmodule12
+    PATHS  /usr/lib
+           /usr/local/lib
+           /usr/openwin/lib
+           /usr/X11R6/lib
+           /opt/gnome/lib
+  )
+
+  FIND_LIBRARY( GTK_glib_LIBRARY
+    NAMES  glib glib12
+    PATHS  /usr/lib
+           /usr/local/lib
+           /usr/openwin/lib
+           /usr/X11R6/lib
+           /opt/gnome/lib
+  )
+
+  FIND_LIBRARY( GTK_Xi_LIBRARY 
+    NAMES Xi 
+    PATHS /usr/lib 
+    /usr/local/lib 
+    /usr/openwin/lib 
+    /usr/X11R6/lib 
+    /opt/gnome/lib 
+    ) 
+
+  FIND_LIBRARY( GTK_gthread_LIBRARY
+    NAMES  gthread gthread12
+    PATHS  /usr/lib
+           /usr/local/lib
+           /usr/openwin/lib
+           /usr/X11R6/lib
+           /opt/gnome/lib
+  )
+
+  IF(GTK_gtk_INCLUDE_PATH)
+  IF(GTK_glibconfig_INCLUDE_PATH)
+  IF(GTK_glib_INCLUDE_PATH)
+  IF(GTK_gtk_LIBRARY)
+  IF(GTK_glib_LIBRARY)
+
+    # Assume that if gtk and glib were found, the other
+    # supporting libraries have also been found.
+
+    SET( GTK_FOUND &quot;YES&quot; )
+    SET( GTK_INCLUDE_DIR  ${GTK_gtk_INCLUDE_PATH}
+                           ${GTK_glibconfig_INCLUDE_PATH}
+                           ${GTK_glib_INCLUDE_PATH} )
+    SET( GTK_LIBRARIES  ${GTK_gtk_LIBRARY}
+                        ${GTK_gdk_LIBRARY}
+                        ${GTK_glib_LIBRARY} )
+
+    IF(GTK_gmodule_LIBRARY)
+      SET(GTK_LIBRARIES ${GTK_LIBRARIES} ${GTK_gmodule_LIBRARY})
+    ENDIF(GTK_gmodule_LIBRARY)
+    IF(GTK_gthread_LIBRARY)
+      SET(GTK_LIBRARIES ${GTK_LIBRARIES} ${GTK_gthread_LIBRARY})
+    ENDIF(GTK_gthread_LIBRARY)
+    IF(GTK_Xi_LIBRARY)
+      SET(GTK_LIBRARIES ${GTK_LIBRARIES} ${GTK_Xi_LIBRARY})
+    ENDIF(GTK_Xi_LIBRARY)
+
+  IF(GTK_gtkgl_INCLUDE_PATH)
+  IF(GTK_gtkgl_LIBRARY)
+    SET( GTK_GL_FOUND &quot;YES&quot; )
+    SET( GTK_INCLUDE_DIR  ${GTK_INCLUDE_DIR}
+                           ${GTK_gtkgl_INCLUDE_PATH} )
+    SET( GTK_LIBRARIES  ${GTK_gtkgl_LIBRARY} ${GTK_LIBRARIES} )
+    MARK_AS_ADVANCED(
+      GTK_gtkgl_LIBRARY
+      GTK_gtkgl_INCLUDE_PATH
+      )
+  ENDIF(GTK_gtkgl_LIBRARY)
+  ENDIF(GTK_gtkgl_INCLUDE_PATH)
+
+  ENDIF(GTK_glib_LIBRARY)
+  ENDIF(GTK_gtk_LIBRARY)
+  ENDIF(GTK_glib_INCLUDE_PATH) 
+  ENDIF(GTK_glibconfig_INCLUDE_PATH)
+  ENDIF(GTK_gtk_INCLUDE_PATH)
+
+  MARK_AS_ADVANCED(
+    GTK_gdk_LIBRARY
+    GTK_glib_INCLUDE_PATH
+    GTK_glib_LIBRARY
+    GTK_glibconfig_INCLUDE_PATH
+    GTK_gmodule_LIBRARY
+    GTK_gthread_LIBRARY
+    GTK_Xi_LIBRARY
+    GTK_gtk_INCLUDE_PATH
+    GTK_gtk_LIBRARY
+    GTK_gtkgl_INCLUDE_PATH
+    GTK_gtkgl_LIBRARY
+  )
+
+ENDIF(UNIX)
+

Added: branches/avidemux_2.4_branch/cmake/FindLibXml2.cmake
===================================================================
--- branches/avidemux_2.4_branch/cmake/FindLibXml2.cmake	2007-05-27 18:44:33 UTC (rev 3157)
+++ branches/avidemux_2.4_branch/cmake/FindLibXml2.cmake	2007-05-28 13:03:46 UTC (rev 3158)
@@ -0,0 +1,59 @@
+# - Try to find LibXml2
+# Once done this will define
+#
+#  LIBXML2_FOUND - system has LibXml2
+#  LIBXML2_INCLUDE_DIR - the LibXml2 include directory
+#  LIBXML2_LIBRARIES - the libraries needed to use LibXml2
+#  LIBXML2_DEFINITIONS - Compiler switches required for using LibXml2
+#
+# Copyright (c) 2006, Alexander Neundorf &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">neundorf at kde.org</A>&gt;
+# This code is available under the BSD license, see licenses/BSD for details.
+
+# Copyright (c) 2006, Alexander Neundorf, &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">neundorf at kde.org</A>&gt;
+#
+# Redistribution and use is allowed according to the terms of the BSD license.
+# For details see the accompanying COPYING-CMAKE-SCRIPTS file.
+
+
+IF (LIBXML2_INCLUDE_DIR AND LIBXML2_LIBRARIES)
+   # in cache already
+   SET(LibXml2_FIND_QUIETLY TRUE)
+ENDIF (LIBXML2_INCLUDE_DIR AND LIBXML2_LIBRARIES)
+
+IF (NOT WIN32)
+   # use pkg-config to get the directories and then use these values
+   # in the FIND_PATH() and FIND_LIBRARY() calls
+   INCLUDE(UsePkgConfig)
+   PKGCONFIG(libxml-2.0 _LibXml2IncDir _LibXml2LinkDir _LibXml2LinkFlags _LibXml2Cflags)
+   SET(LIBXML2_DEFINITIONS ${_LibXml2Cflags})
+ENDIF (NOT WIN32)
+
+FIND_PATH(LIBXML2_INCLUDE_DIR libxml/xpath.h
+   PATHS
+   ${_LibXml2IncDir}
+   PATH_SUFFIXES libxml2
+   )
+
+FIND_LIBRARY(LIBXML2_LIBRARIES NAMES xml2 libxml2
+   PATHS
+   ${_LibXml2LinkDir}
+   )
+
+IF (LIBXML2_INCLUDE_DIR AND LIBXML2_LIBRARIES)
+   SET(LIBXML2_FOUND TRUE)
+ELSE (LIBXML2_INCLUDE_DIR AND LIBXML2_LIBRARIES)
+   SET(LIBXML2_FOUND FALSE)
+ENDIF (LIBXML2_INCLUDE_DIR AND LIBXML2_LIBRARIES)
+
+IF (LIBXML2_FOUND)
+   IF (NOT LibXml2_FIND_QUIETLY)
+      MESSAGE(STATUS &quot;Found LibXml2: ${LIBXML2_LIBRARIES}&quot;)
+   ENDIF (NOT LibXml2_FIND_QUIETLY)
+ELSE (LIBXML2_FOUND)
+   IF (LibXml2_FIND_REQUIRED)
+      MESSAGE(SEND_ERROR &quot;Could NOT find LibXml2&quot;)
+   ENDIF (LibXml2_FIND_REQUIRED)
+ENDIF (LIBXML2_FOUND)
+
+MARK_AS_ADVANCED(LIBXML2_INCLUDE_DIR LIBXML2_LIBRARIES)
+

Added: branches/avidemux_2.4_branch/cmake/FindQT4.cmake
===================================================================
--- branches/avidemux_2.4_branch/cmake/FindQT4.cmake	2007-05-27 18:44:33 UTC (rev 3157)
+++ branches/avidemux_2.4_branch/cmake/FindQT4.cmake	2007-05-28 13:03:46 UTC (rev 3158)
@@ -0,0 +1,1201 @@
+# - Find QT 4
+# This module can be used to find Qt4.
+# The most important issue is that the Qt4 qmake is available via the system path.
+# This qmake is then used to detect basically everything else.
+# This module defines a number of key variables and macros. First is 
+# QT_USE_FILE which is the path to a CMake file that can be included to compile
+# Qt 4 applications and libraries.  By default, the QtCore and QtGui 
+# libraries are loaded. This behavior can be changed by setting one or more 
+# of the following variables to true:
+#                    QT_DONT_USE_QTCORE
+#                    QT_DONT_USE_QTGUI
+#                    QT_USE_QT3SUPPORT
+#                    QT_USE_QTASSISTANT
+#                    QT_USE_QTDESIGNER
+#                    QT_USE_QTMOTIF
+#                    QT_USE_QTMAIN
+#                    QT_USE_QTNETWORK
+#                    QT_USE_QTNSPLUGIN
+#                    QT_USE_QTOPENGL
+#                    QT_USE_QTSQL
+#                    QT_USE_QTXML
+#                    QT_USE_QTSVG
+#                    QT_USE_QTTEST
+#                    QT_USE_QTUITOOLS
+#                    QT_USE_QTDBUS
+#
+# All the libraries required are stored in a variable called QT_LIBRARIES.  
+# Add this variable to your TARGET_LINK_LIBRARIES.
+#  
+#  macro QT4_WRAP_CPP(outfiles inputfile ... )
+#  macro QT4_WRAP_UI(outfiles inputfile ... )
+#  macro QT4_ADD_RESOURCE(outfiles inputfile ... )
+#  macro QT4_AUTOMOC(inputfile ... )
+#  macro QT4_GENERATE_MOC(inputfile outputfile )
+#
+#  macro QT4_ADD_DBUS_INTERFACE(outfiles interface basename)
+#        create a the interface header and implementation files with the 
+#        given basename from the given interface xml file and add it to 
+#        the list of sources
+#
+#  macro QT4_ADD_DBUS_INTERFACES(outfiles inputfile ... )
+#        create the interface header and implementation files 
+#        for all listed interface xml files
+#        the name will be automatically determined from the name of the xml file
+#
+#  macro QT4_ADD_DBUS_INTERFACE_NO_NAMESPACE(outfiles interface basename)
+#        create a the interface without namespace header and implementation files with the
+#        given basename from the given interface xml file and add it to
+#        the list of sources
+#
+#  macro QT4_ADD_DBUS_INTERFACES_NO_NAMESPACE(outfiles inputfile ... )
+#        create the interface header without namespace and implementation files
+#        for all listed interface xml files
+#        the name will be automatically determined from the name of the xml file
+#
+#  macro QT4_ADD_DBUS_ADAPTOR(outfiles xmlfile parentheader parentclassname [basename] )
+#        create a dbus adaptor (header and implementation file) from the xml file
+#        describing the interface, and add it to the list of sources. The adaptor
+#        forwards the calls to a parent class, defined in parentheader and named
+#        parentclassname. The name of the generated files will be
+#        &lt;basename&gt;adaptor.{cpp,h} where basename is the basename of the xml file.
+#
+#  macro QT4_GENERATE_DBUS_INTERFACE( header [interfacename] )
+#        generate the xml interface file from the given header.
+#        If the optional argument interfacename is omitted, the name of the 
+#        interface file is constructed from the basename of the header with
+#        the suffix .xml appended.
+#
+#  QT_FOUND         If false, don't try to use Qt.
+#  QT4_FOUND        If false, don't try to use Qt 4.
+#
+#  QT_QTCORE_FOUND        True if QtCore was found.
+#  QT_QTGUI_FOUND         True if QtGui was found.
+#  QT_QT3SUPPORT_FOUND    True if Qt3Support was found.
+#  QT_QTASSISTANT_FOUND   True if QtAssistant was found.
+#  QT_QTDBUS_FOUND        True if QtDBus was found.
+#  QT_QTDESIGNER_FOUND    True if QtDesigner was found.
+#  QT_QTDESIGNERCOMPONENTS True if QtDesignerComponents was found.
+#  QT_QTMOTIF_FOUND       True if QtMotif was found.
+#  QT_QTNETWORK_FOUND     True if QtNetwork was found.
+#  QT_QTNSPLUGIN_FOUND    True if QtNsPlugin was found.
+#  QT_QTOPENGL_FOUND      True if QtOpenGL was found.
+#  QT_QTSQL_FOUND         True if QtSql was found.
+#  QT_QTXML_FOUND         True if QtXml was found.
+#  QT_QTSVG_FOUND         True if QtSvg was found.
+#  QT_QTSCRIPT_FOUND      True if QtScript was found.
+#  QT_QTTEST_FOUND        True if QtTest was found.
+#  QT_QTUITOOLS_FOUND     True if QtUiTools was found.
+#                      
+#  QT_DEFINITIONS   Definitions to use when compiling code that uses Qt.
+#                  
+#  QT_INCLUDES      List of paths to all include directories of 
+#                   Qt4 QT_INCLUDE_DIR and QT_QTCORE_INCLUDE_DIR are
+#                   always in this variable even if NOTFOUND,
+#                   all other INCLUDE_DIRS are
+#                   only added if they are found.
+#   
+#  QT_INCLUDE_DIR              Path to &quot;include&quot; of Qt4
+#  QT_QT_INCLUDE_DIR           Path to &quot;include/Qt&quot; 
+#  QT_QT3SUPPORT_INCLUDE_DIR   Path to &quot;include/Qt3Support&quot; 
+#  QT_QTASSISTANT_INCLUDE_DIR  Path to &quot;include/QtAssistant&quot; 
+#  QT_QTCORE_INCLUDE_DIR       Path to &quot;include/QtCore&quot;         
+#  QT_QTDESIGNER_INCLUDE_DIR   Path to &quot;include/QtDesigner&quot; 
+#  QT_QTDESIGNERCOMPONENTS_INCLUDE_DIR   Path to &quot;include/QtDesigner&quot;
+#  QT_QTDBUS_INCLUDE_DIR       Path to &quot;include/QtDBus&quot; 
+#  QT_QTGUI_INCLUDE_DIR        Path to &quot;include/QtGui&quot; 
+#  QT_QTMOTIF_INCLUDE_DIR      Path to &quot;include/QtMotif&quot; 
+#  QT_QTNETWORK_INCLUDE_DIR    Path to &quot;include/QtNetwork&quot; 
+#  QT_QTNSPLUGIN_INCLUDE_DIR   Path to &quot;include/QtNsPlugin&quot; 
+#  QT_QTOPENGL_INCLUDE_DIR     Path to &quot;include/QtOpenGL&quot; 
+#  QT_QTSQL_INCLUDE_DIR        Path to &quot;include/QtSql&quot; 
+#  QT_QTXML_INCLUDE_DIR        Path to &quot;include/QtXml&quot; 
+#  QT_QTSVG_INCLUDE_DIR        Path to &quot;include/QtSvg&quot;
+#  QT_QTSCRIPT_INCLUDE_DIR     Path to &quot;include/QtScript&quot;
+#  QT_QTTEST_INCLUDE_DIR       Path to &quot;include/QtTest&quot;
+#                            
+#  QT_LIBRARY_DIR              Path to &quot;lib&quot; of Qt4
+# 
+#  QT_PLUGINS_DIR              Path to &quot;plugins&quot; for Qt4
+#                            
+# For every library of Qt, a QT_QTFOO_LIBRARY variable is defined, with the full path to the library.
+#
+# So there are the following variables:
+# The Qt3Support library:     QT_QT3SUPPORT_LIBRARY
+#
+# The QtAssistant library:    QT_QTASSISTANT_LIBRARY
+#
+# The QtCore library:         QT_QTCORE_LIBRARY
+#
+# The QtDBus library:         QT_QTDBUS_LIBRARY
+#
+# The QtDesigner library:     QT_QTDESIGNER_LIBRARY
+#
+# The QtDesignerComponents library:     QT_QTDESIGNERCOMPONENTS_LIBRARY
+#
+# The QtGui library:          QT_QTGUI_LIBRARY
+#
+# The QtMotif library:        QT_QTMOTIF_LIBRARY
+#
+# The QtNetwork library:      QT_QTNETWORK_LIBRARY
+#
+# The QtNsPLugin library:     QT_QTNSPLUGIN_LIBRARY
+#
+# The QtOpenGL library:       QT_QTOPENGL_LIBRARY
+#
+# The QtSql library:          QT_QTSQL_LIBRARY
+#
+# The QtXml library:          QT_QTXML_LIBRARY
+#
+# The QtSvg library:          QT_QTSVG_LIBRARY
+#
+# The QtScript library:       QT_QTSCRIPT_LIBRARY
+#
+# The QtTest library:         QT_QTTEST_LIBRARY
+#
+# The qtmain library for Windows QT_QTMAIN_LIBRARY
+#
+# The QtUiTools library:      QT_QTUITOOLS_LIBRARY
+#  
+# also defined, but NOT for general use are
+#  QT_MOC_EXECUTABLE          Where to find the moc tool.
+#  QT_UIC_EXECUTABLE          Where to find the uic tool.
+#  QT_UIC3_EXECUTABLE         Where to find the uic3 tool.
+#  QT_RCC_EXECUTABLE          Where to find the rcc tool
+#  QT_DBUSCPP2XML_EXECUTABLE  Where to find the qdbuscpp2xml tool.
+#  QT_DBUSXML2CPP_EXECUTABLE  Where to find the qdbusxml2cpp tool.
+#  
+#  QT_DOC_DIR                 Path to &quot;doc&quot; of Qt4
+#  QT_MKSPECS_DIR             Path to &quot;mkspecs&quot; of Qt4
+#
+#
+# These are around for backwards compatibility 
+# they will be set
+#  QT_WRAP_CPP  Set true if QT_MOC_EXECUTABLE is found
+#  QT_WRAP_UI   Set true if QT_UIC_EXECUTABLE is found
+#  
+# These variables do _NOT_ have any effect anymore (compared to FindQt.cmake)
+#  QT_MT_REQUIRED         Qt4 is now always multithreaded
+#  
+# These variables are set to &quot;&quot; Because Qt structure changed 
+# (They make no sense in Qt4)
+#  QT_QT_LIBRARY        Qt-Library is now split
+
+# Copyright (c) 2002 Kitware, Inc., Insight Consortium.  All rights reserved.
+# See Copyright.txt or <A HREF="http://www.cmake.org/HTML/Copyright.html">http://www.cmake.org/HTML/Copyright.html</A> for details.
+
+
+INCLUDE(CheckSymbolExists)
+INCLUDE(MacroAddFileDependencies)
+
+SET(QT_USE_FILE ${CMAKE_ROOT}/Modules/UseQt4.cmake)
+
+SET( QT_DEFINITIONS &quot;&quot;)
+
+IF (WIN32)
+  SET(QT_DEFINITIONS -DQT_DLL)
+ENDIF(WIN32)
+
+SET(QT4_INSTALLED_VERSION_TOO_OLD FALSE)
+
+#  macro for asking qmake to process pro files
+MACRO(QT_QUERY_QMAKE outvar invar)
+  FILE(WRITE ${CMAKE_CURRENT_BINARY_DIR}${CMAKE_FILES_DIRECTORY}/CMakeTmpQmake/tmp.pro
+    &quot;message(CMAKE_MESSAGE&lt;$$${invar}&gt;)&quot;)
+
+  EXECUTE_PROCESS(COMMAND ${QT_QMAKE_EXECUTABLE}
+    WORKING_DIRECTORY  
+    ${CMAKE_CURRENT_BINARY_DIR}${CMAKE_FILES_DIRECTORY}/CMakeTmpQmake
+    OUTPUT_VARIABLE _qmake_query_output
+    ERROR_VARIABLE _qmake_query_output )
+
+  FILE(REMOVE_RECURSE 
+    &quot;${CMAKE_CURRENT_BINARY_DIR}${CMAKE_FILES_DIRECTORY}/CMakeTmpQmake&quot;)
+
+  STRING(REGEX REPLACE &quot;.*CMAKE_MESSAGE&lt;([^&gt;]*).*&quot; &quot;\\1&quot; ${outvar} &quot;${_qmake_query_output}&quot;)
+ENDMACRO(QT_QUERY_QMAKE)
+
+# check for qmake
+FIND_PROGRAM(QT_QMAKE_EXECUTABLE NAMES qmake qmake4 qmake-qt4 PATHS
+  &quot;[HKEY_CURRENT_USER\\Software\\Trolltech\\Qt3Versions\\4.0.0;InstallDir]/bin&quot;
+  &quot;[HKEY_CURRENT_USER\\Software\\Trolltech\\Versions\\4.0.0;InstallDir]/bin&quot;
+  $ENV{QTDIR}/bin
+)
+
+IF (QT_QMAKE_EXECUTABLE)
+
+  SET(QT4_QMAKE_FOUND FALSE)
+  
+  EXEC_PROGRAM(${QT_QMAKE_EXECUTABLE} ARGS &quot;-query QT_VERSION&quot; OUTPUT_VARIABLE QTVERSION)
+
+  # check for qt3 qmake and then try and find qmake4 or qmake-qt4 in the path
+  IF(&quot;${QTVERSION}&quot; MATCHES &quot;Unknown&quot;)
+    SET(QT_QMAKE_EXECUTABLE NOTFOUND CACHE FILEPATH &quot;&quot; FORCE)
+    FIND_PROGRAM(QT_QMAKE_EXECUTABLE NAMES qmake4 qmake-qt4 PATHS
+      &quot;[HKEY_CURRENT_USER\\Software\\Trolltech\\Qt3Versions\\4.0.0;InstallDir]/bin&quot;
+      &quot;[HKEY_CURRENT_USER\\Software\\Trolltech\\Versions\\4.0.0;InstallDir]/bin&quot;
+      $ENV{QTDIR}/bin
+      )
+    IF(QT_QMAKE_EXECUTABLE)
+      EXEC_PROGRAM(${QT_QMAKE_EXECUTABLE} 
+        ARGS &quot;-query QT_VERSION&quot; OUTPUT_VARIABLE QTVERSION)
+    ENDIF(QT_QMAKE_EXECUTABLE)
+  ENDIF(&quot;${QTVERSION}&quot; MATCHES &quot;Unknown&quot;)
+
+  # check that we found the Qt4 qmake, Qt3 qmake output won't match here
+  STRING(REGEX MATCH &quot;^[0-9]+\\.[0-9]+\\.[0-9]+&quot; qt_version_tmp &quot;${QTVERSION}&quot;)
+  IF (qt_version_tmp)
+
+    # we need at least version 4.0.0
+    IF (NOT QT_MIN_VERSION)
+      SET(QT_MIN_VERSION &quot;4.0.0&quot;)
+    ENDIF (NOT QT_MIN_VERSION)
+
+    #now parse the parts of the user given version string into variables
+    STRING(REGEX MATCH &quot;^[0-9]+\\.[0-9]+\\.[0-9]+&quot; req_qt_major_vers &quot;${QT_MIN_VERSION}&quot;)
+    IF (NOT req_qt_major_vers)
+      MESSAGE( FATAL_ERROR &quot;Invalid Qt version string given: \&quot;${QT_MIN_VERSION}\&quot;, expected e.g. \&quot;4.0.1\&quot;&quot;)
+    ENDIF (NOT req_qt_major_vers)
+
+    # now parse the parts of the user given version string into variables
+    STRING(REGEX REPLACE &quot;^([0-9]+)\\.[0-9]+\\.[0-9]+&quot; &quot;\\1&quot; req_qt_major_vers &quot;${QT_MIN_VERSION}&quot;)
+    STRING(REGEX REPLACE &quot;^[0-9]+\\.([0-9])+\\.[0-9]+&quot; &quot;\\1&quot; req_qt_minor_vers &quot;${QT_MIN_VERSION}&quot;)
+    STRING(REGEX REPLACE &quot;^[0-9]+\\.[0-9]+\\.([0-9]+)&quot; &quot;\\1&quot; req_qt_patch_vers &quot;${QT_MIN_VERSION}&quot;)
+
+    IF (NOT req_qt_major_vers EQUAL 4)
+      MESSAGE( FATAL_ERROR &quot;Invalid Qt version string given: \&quot;${QT_MIN_VERSION}\&quot;, major version 4 is required, e.g. \&quot;4.0.1\&quot;&quot;)
+    ENDIF (NOT req_qt_major_vers EQUAL 4)
+
+    # and now the version string given by qmake
+    STRING(REGEX REPLACE &quot;^([0-9]+)\\.[0-9]+\\.[0-9]+.*&quot; &quot;\\1&quot; found_qt_major_vers &quot;${QTVERSION}&quot;)
+    STRING(REGEX REPLACE &quot;^[0-9]+\\.([0-9])+\\.[0-9]+.*&quot; &quot;\\1&quot; found_qt_minor_vers &quot;${QTVERSION}&quot;)
+    STRING(REGEX REPLACE &quot;^[0-9]+\\.[0-9]+\\.([0-9]+).*&quot; &quot;\\1&quot; found_qt_patch_vers &quot;${QTVERSION}&quot;)
+
+    # compute an overall version number which can be compared at once
+    MATH(EXPR req_vers &quot;${req_qt_major_vers}*10000 + ${req_qt_minor_vers}*100 + ${req_qt_patch_vers}&quot;)
+    MATH(EXPR found_vers &quot;${found_qt_major_vers}*10000 + ${found_qt_minor_vers}*100 + ${found_qt_patch_vers}&quot;)
+
+    IF (found_vers LESS req_vers)
+      SET(QT4_QMAKE_FOUND FALSE)
+      SET(QT4_INSTALLED_VERSION_TOO_OLD TRUE)
+    ELSE (found_vers LESS req_vers)
+      SET(QT4_QMAKE_FOUND TRUE)
+    ENDIF (found_vers LESS req_vers)
+  ENDIF (qt_version_tmp)
+
+ENDIF (QT_QMAKE_EXECUTABLE)
+
+IF (QT4_QMAKE_FOUND)
+
+  # ask qmake for the library dir
+  # Set QT_LIBRARY_DIR
+  IF (NOT QT_LIBRARY_DIR)
+    EXEC_PROGRAM( ${QT_QMAKE_EXECUTABLE}
+      ARGS &quot;-query QT_INSTALL_LIBS&quot;
+      OUTPUT_VARIABLE QT_LIBRARY_DIR_TMP )
+    IF(EXISTS &quot;${QT_LIBRARY_DIR_TMP}&quot;)
+      SET(QT_LIBRARY_DIR ${QT_LIBRARY_DIR_TMP} CACHE PATH &quot;Qt library dir&quot;)
+    ELSE(EXISTS &quot;${QT_LIBRARY_DIR_TMP}&quot;)
+      MESSAGE(&quot;Warning: QT_QMAKE_EXECUTABLE reported QT_INSTALL_LIBS as ${QT_LIBRARY_DIR_TMP}&quot;)
+      MESSAGE(&quot;Warning: ${QT_LIBRARY_DIR_TMP} does NOT exist, Qt must NOT be installed correctly.&quot;)
+    ENDIF(EXISTS &quot;${QT_LIBRARY_DIR_TMP}&quot;)
+  ENDIF(NOT QT_LIBRARY_DIR)
+  
+  IF (APPLE)
+    IF (EXISTS ${QT_LIBRARY_DIR}/QtCore.framework)
+      SET(QT_USE_FRAMEWORKS ON
+        CACHE BOOL &quot;Set to ON if Qt build uses frameworks.&quot;)
+    ELSE (EXISTS ${QT_LIBRARY_DIR}/QtCore.framework)
+      SET(QT_USE_FRAMEWORKS OFF
+        CACHE BOOL &quot;Set to ON if Qt build uses frameworks.&quot;)
+    ENDIF (EXISTS ${QT_LIBRARY_DIR}/QtCore.framework)
+    
+    MARK_AS_ADVANCED(QT_USE_FRAMEWORKS)
+  ENDIF (APPLE)
+  
+  # ask qmake for the binary dir
+  IF (NOT QT_BINARY_DIR)
+     EXEC_PROGRAM(${QT_QMAKE_EXECUTABLE}
+        ARGS &quot;-query QT_INSTALL_BINS&quot;
+        OUTPUT_VARIABLE qt_bins )
+     SET(QT_BINARY_DIR ${qt_bins} CACHE INTERNAL &quot;&quot;)
+  ENDIF (NOT QT_BINARY_DIR)
+
+  # ask qmake for the include dir
+  IF (NOT QT_HEADERS_DIR)
+      EXEC_PROGRAM( ${QT_QMAKE_EXECUTABLE}
+        ARGS &quot;-query QT_INSTALL_HEADERS&quot; 
+        OUTPUT_VARIABLE qt_headers )
+      SET(QT_HEADERS_DIR ${qt_headers} CACHE INTERNAL &quot;&quot;)
+  ENDIF(NOT QT_HEADERS_DIR)
+
+
+  # ask qmake for the documentation directory
+  IF (NOT QT_DOC_DIR)
+    EXEC_PROGRAM( ${QT_QMAKE_EXECUTABLE}
+      ARGS &quot;-query QT_INSTALL_DOCS&quot;
+      OUTPUT_VARIABLE qt_doc_dir )
+    SET(QT_DOC_DIR ${qt_doc_dir} CACHE PATH &quot;The location of the Qt docs&quot;)
+  ENDIF (NOT QT_DOC_DIR)
+
+  # ask qmake for the mkspecs directory
+  IF (NOT QT_MKSPECS_DIR)
+    EXEC_PROGRAM( ${QT_QMAKE_EXECUTABLE}
+      ARGS &quot;-query QMAKE_MKSPECS&quot;
+      OUTPUT_VARIABLE qt_mkspecs_dir )
+    SET(QT_MKSPECS_DIR ${qt_mkspecs_dir} CACHE PATH &quot;The location of the Qt mkspecs&quot;)
+  ENDIF (NOT QT_MKSPECS_DIR)
+
+  # ask qmake for the plugins directory
+  IF (NOT QT_PLUGINS_DIR)
+    EXEC_PROGRAM( ${QT_QMAKE_EXECUTABLE}
+      ARGS &quot;-query QT_INSTALL_PLUGINS&quot;
+      OUTPUT_VARIABLE qt_plugins_dir )
+    SET(QT_PLUGINS_DIR ${qt_plugins_dir} CACHE PATH &quot;The location of the Qt plugins&quot;)
+  ENDIF (NOT QT_PLUGINS_DIR)
+  ########################################
+  #
+  #       Setting the INCLUDE-Variables
+  #
+  ########################################
+
+  FIND_PATH(QT_QTCORE_INCLUDE_DIR QtGlobal
+    ${QT_HEADERS_DIR}/QtCore
+    ${QT_LIBRARY_DIR}/QtCore.framework/Headers
+    NO_DEFAULT_PATH
+    )
+
+  # Set QT_INCLUDE_DIR by removine &quot;/QtCore&quot; in the string ${QT_QTCORE_INCLUDE_DIR}
+  IF( QT_QTCORE_INCLUDE_DIR AND NOT QT_INCLUDE_DIR)
+    IF (QT_USE_FRAMEWORKS)
+      SET(QT_INCLUDE_DIR ${QT_HEADERS_DIR})
+    ELSE (QT_USE_FRAMEWORKS)
+      STRING( REGEX REPLACE &quot;/QtCore$&quot; &quot;&quot; qt4_include_dir ${QT_QTCORE_INCLUDE_DIR})
+      SET( QT_INCLUDE_DIR ${qt4_include_dir} CACHE PATH &quot;&quot;)
+    ENDIF (QT_USE_FRAMEWORKS)
+  ENDIF( QT_QTCORE_INCLUDE_DIR AND NOT QT_INCLUDE_DIR)
+
+  IF( NOT QT_INCLUDE_DIR)
+    IF( NOT Qt4_FIND_QUIETLY AND Qt4_FIND_REQUIRED)
+      MESSAGE( FATAL_ERROR &quot;Could NOT find QtGlobal header&quot;)
+    ENDIF( NOT Qt4_FIND_QUIETLY AND Qt4_FIND_REQUIRED)
+  ENDIF( NOT QT_INCLUDE_DIR)
+
+  #############################################
+  #
+  # Find out what window system we're using
+  #
+  #############################################
+  # Save required includes variable
+  SET(CMAKE_REQUIRED_INCLUDES_SAVE ${CMAKE_REQUIRED_INCLUDES})
+  # Add QT_INCLUDE_DIR to CMAKE_REQUIRED_INCLUDES
+  SET(CMAKE_REQUIRED_INCLUDES &quot;${CMAKE_REQUIRED_INCLUDES};${QT_INCLUDE_DIR}&quot;)
+  # Check for Window system symbols (note: only one should end up being set)
+  CHECK_SYMBOL_EXISTS(Q_WS_X11 &quot;QtCore/qglobal.h&quot; Q_WS_X11)
+  CHECK_SYMBOL_EXISTS(Q_WS_MAC &quot;QtCore/qglobal.h&quot; Q_WS_MAC)
+  CHECK_SYMBOL_EXISTS(Q_WS_WIN &quot;QtCore/qglobal.h&quot; Q_WS_WIN)
+
+  IF (QT_QTCOPY_REQUIRED)
+     CHECK_SYMBOL_EXISTS(QT_IS_QTCOPY &quot;QtCore/qglobal.h&quot; QT_KDE_QT_COPY)
+     IF (NOT QT_IS_QTCOPY)
+        MESSAGE(FATAL_ERROR &quot;qt-copy is required, but hasn't been found&quot;)
+     ENDIF (NOT QT_IS_QTCOPY)
+  ENDIF (QT_QTCOPY_REQUIRED)
+
+  # Restore CMAKE_REQUIRED_INCLUDES variable
+  SET(CMAKE_REQUIRED_INCLUDES ${CMAKE_REQUIRED_INCLUDES_SAVE})
+  #
+  #############################################
+
+  IF (QT_USE_FRAMEWORKS)
+    SET(QT_DEFINITIONS ${QT_DEFINITIONS} -F${QT_LIBRARY_DIR} -L${QT_LIBRARY_DIR} )
+  ENDIF (QT_USE_FRAMEWORKS)
+
+  # Set QT_QT3SUPPORT_INCLUDE_DIR
+  FIND_PATH(QT_QT3SUPPORT_INCLUDE_DIR Qt3Support
+    PATHS
+    ${QT_INCLUDE_DIR}/Qt3Support
+    ${QT_LIBRARY_DIR}/Qt3Support.framework/Headers
+    NO_DEFAULT_PATH
+    )
+
+  # Set QT_QT_INCLUDE_DIR
+  FIND_PATH(QT_QT_INCLUDE_DIR qglobal.h
+    PATHS
+    ${QT_INCLUDE_DIR}/Qt
+    ${QT_LIBRARY_DIR}/QtCore.framework/Headers
+    NO_DEFAULT_PATH
+    )
+
+  # Set QT_QTGUI_INCLUDE_DIR
+  FIND_PATH(QT_QTGUI_INCLUDE_DIR QtGui
+    PATHS
+    ${QT_INCLUDE_DIR}/QtGui
+    ${QT_LIBRARY_DIR}/QtGui.framework/Headers
+    NO_DEFAULT_PATH
+    )
+
+  # Set QT_QTSVG_INCLUDE_DIR
+  FIND_PATH(QT_QTSVG_INCLUDE_DIR QtSvg
+    PATHS
+    ${QT_INCLUDE_DIR}/QtSvg
+    ${QT_LIBRARY_DIR}/QtSvg.framework/Headers
+    NO_DEFAULT_PATH
+    )
+
+  # Set QT_QTSVG_INCLUDE_DIR
+  FIND_PATH(QT_QTSCRIPT_INCLUDE_DIR QtScript
+    PATHS
+    ${QT_INCLUDE_DIR}/QtScript
+    ${QT_LIBRARY_DIR}/QtScript.framework/Headers
+    NO_DEFAULT_PATH
+    )
+
+  # Set QT_QTTEST_INCLUDE_DIR
+  FIND_PATH(QT_QTTEST_INCLUDE_DIR QtTest
+    PATHS
+    ${QT_INCLUDE_DIR}/QtTest
+    ${QT_LIBRARY_DIR}/QtTest.framework/Headers
+    NO_DEFAULT_PATH
+    )
+
+  # Set QT_QTUITOOLS_INCLUDE_DIR
+  FIND_PATH(QT_QTUITOOLS_INCLUDE_DIR QtUiTools
+    PATHS
+    ${QT_INCLUDE_DIR}/QtUiTools
+    ${QT_LIBRARY_DIR}/QtUiTools.framework/Headers
+    NO_DEFAULT_PATH
+    )
+
+
+
+  # Set QT_QTMOTIF_INCLUDE_DIR
+  IF(Q_WS_X11)
+    FIND_PATH(QT_QTMOTIF_INCLUDE_DIR QtMotif PATHS ${QT_INCLUDE_DIR}/QtMotif NO_DEFAULT_PATH )
+  ENDIF(Q_WS_X11)
+
+  # Set QT_QTNETWORK_INCLUDE_DIR
+  FIND_PATH(QT_QTNETWORK_INCLUDE_DIR QtNetwork
+    PATHS
+    ${QT_INCLUDE_DIR}/QtNetwork
+    ${QT_LIBRARY_DIR}/QtNetwork.framework/Headers
+    NO_DEFAULT_PATH
+    )
+
+  # Set QT_QTNSPLUGIN_INCLUDE_DIR
+  FIND_PATH(QT_QTNSPLUGIN_INCLUDE_DIR QtNsPlugin
+    PATHS
+    ${QT_INCLUDE_DIR}/QtNsPlugin
+    ${QT_LIBRARY_DIR}/QtNsPlugin.framework/Headers
+    NO_DEFAULT_PATH
+    )
+
+  # Set QT_QTOPENGL_INCLUDE_DIR
+  FIND_PATH(QT_QTOPENGL_INCLUDE_DIR QtOpenGL
+    PATHS
+    ${QT_INCLUDE_DIR}/QtOpenGL
+    ${QT_LIBRARY_DIR}/QtOpenGL.framework/Headers
+    NO_DEFAULT_PATH
+    )
+
+  # Set QT_QTSQL_INCLUDE_DIR
+  FIND_PATH(QT_QTSQL_INCLUDE_DIR QtSql
+    PATHS
+    ${QT_INCLUDE_DIR}/QtSql
+    ${QT_LIBRARY_DIR}/QtSql.framework/Headers
+    NO_DEFAULT_PATH
+    )
+
+  # Set QT_QTXML_INCLUDE_DIR
+  FIND_PATH(QT_QTXML_INCLUDE_DIR QtXml
+    PATHS
+    ${QT_INCLUDE_DIR}/QtXml
+    ${QT_LIBRARY_DIR}/QtXml.framework/Headers
+    NO_DEFAULT_PATH
+    )
+
+  # Set QT_QTASSISTANT_INCLUDE_DIR
+  FIND_PATH(QT_QTASSISTANT_INCLUDE_DIR QtAssistant
+    PATHS
+    ${QT_INCLUDE_DIR}/QtAssistant
+    ${QT_HEADERS_DIR}/QtAssistant
+    NO_DEFAULT_PATH
+    )
+
+  # Set QT_QTDESIGNER_INCLUDE_DIR
+  FIND_PATH(QT_QTDESIGNER_INCLUDE_DIR QDesignerComponents
+    PATHS
+    ${QT_INCLUDE_DIR}/QtDesigner
+    ${QT_HEADERS_DIR}/QtDesigner
+    NO_DEFAULT_PATH
+    )
+
+  # Set QT_QTDESIGNERCOMPONENTS_INCLUDE_DIR
+  FIND_PATH(QT_QTDESIGNERCOMPONENTS_INCLUDE_DIR QDesignerComponents
+    PATHS
+    ${QT_INCLUDE_DIR}/QtDesigner
+    ${QT_HEADERS_DIR}/QtDesigner
+    NO_DEFAULT_PATH
+    )
+
+
+  # Set QT_QTDBUS_INCLUDE_DIR
+  FIND_PATH(QT_QTDBUS_INCLUDE_DIR QtDBus
+    PATHS
+    ${QT_INCLUDE_DIR}/QtDBus
+    ${QT_HEADERS_DIR}/QtDBus
+    NO_DEFAULT_PATH
+    )
+
+  # Make variables changeble to the advanced user
+  MARK_AS_ADVANCED( QT_LIBRARY_DIR QT_INCLUDE_DIR QT_QT_INCLUDE_DIR QT_DOC_DIR QT_MKSPECS_DIR QT_PLUGINS_DIR)
+
+  # Set QT_INCLUDES
+  SET( QT_INCLUDES ${QT_INCLUDE_DIR} ${QT_QT_INCLUDE_DIR} ${QT_MKSPECS_DIR}/default )
+
+
+  ########################################
+  #
+  #       Setting the LIBRARY-Variables
+  #
+  ########################################
+
+  IF (QT_USE_FRAMEWORKS)
+    # If FIND_LIBRARY found libraries in Apple frameworks, we would NOT have
+    # to jump through these hoops.
+    IF(EXISTS ${QT_LIBRARY_DIR}/QtCore.framework)
+      SET(QT_QTCORE_FOUND TRUE)
+      SET(QT_QTCORE_LIBRARY &quot;-F${QT_LIBRARY_DIR} -framework QtCore&quot; CACHE STRING &quot;The QtCore library.&quot;)
+    ELSE(EXISTS ${QT_LIBRARY_DIR}/QtCore.framework)
+      SET(QT_QTCORE_FOUND FALSE)
+    ENDIF(EXISTS ${QT_LIBRARY_DIR}/QtCore.framework)
+
+    IF(EXISTS ${QT_LIBRARY_DIR}/QtGui.framework)
+      SET(QT_QTGUI_FOUND TRUE)
+      SET(QT_QTGUI_LIBRARY &quot;-F${QT_LIBRARY_DIR} -framework QtGui&quot; CACHE STRING &quot;The QtGui library.&quot;)
+    ELSE(EXISTS ${QT_LIBRARY_DIR}/QtGui.framework)
+      SET(QT_QTGUI_FOUND FALSE)
+    ENDIF(EXISTS ${QT_LIBRARY_DIR}/QtGui.framework)
+
+    IF(EXISTS ${QT_LIBRARY_DIR}/Qt3Support.framework)
+      SET(QT_QT3SUPPORT_FOUND TRUE)
+      SET(QT_QT3SUPPORT_LIBRARY &quot;-F${QT_LIBRARY_DIR} -framework Qt3Support&quot; CACHE STRING &quot;The Qt3Support library.&quot;)
+    ELSE(EXISTS ${QT_LIBRARY_DIR}/Qt3Support.framework)
+      SET(QT_QT3SUPPORT_FOUND FALSE)
+    ENDIF(EXISTS ${QT_LIBRARY_DIR}/Qt3Support.framework)
+
+    IF(EXISTS ${QT_LIBRARY_DIR}/QtNetwork.framework)
+      SET(QT_QTNETWORK_FOUND TRUE)
+      SET(QT_QTNETWORK_LIBRARY &quot;-F${QT_LIBRARY_DIR} -framework QtNetwork&quot; CACHE STRING &quot;The QtNetwork library.&quot;)
+    ELSE(EXISTS ${QT_LIBRARY_DIR}/QtNetwork.framework)
+      SET(QT_QTNETWORK_FOUND FALSE)
+    ENDIF(EXISTS ${QT_LIBRARY_DIR}/QtNetwork.framework)
+
+    IF(EXISTS ${QT_LIBRARY_DIR}/QtOpenGL.framework)
+      SET(QT_QTOPENGL_FOUND TRUE)
+      SET(QT_QTOPENGL_LIBRARY &quot;-F${QT_LIBRARY_DIR} -framework QtOpenGL&quot; CACHE STRING &quot;The QtOpenGL library.&quot;)
+    ELSE(EXISTS ${QT_LIBRARY_DIR}/QtOpenGL.framework)
+      SET(QT_QTOPENGL_FOUND FALSE)
+    ENDIF(EXISTS ${QT_LIBRARY_DIR}/QtOpenGL.framework)
+
+    IF(EXISTS ${QT_LIBRARY_DIR}/QtSql.framework)
+      SET(QT_QTSQL_FOUND TRUE)
+      SET(QT_QTSQL_LIBRARY &quot;-F${QT_LIBRARY_DIR} -framework QtSql&quot; CACHE STRING &quot;The QtSql library.&quot;)
+    ELSE(EXISTS ${QT_LIBRARY_DIR}/QtSql.framework)
+      SET(QT_QTSQL_FOUND FALSE)
+    ENDIF(EXISTS ${QT_LIBRARY_DIR}/QtSql.framework)
+
+    IF(EXISTS ${QT_LIBRARY_DIR}/QtXml.framework)
+      SET(QT_QTXML_FOUND TRUE)
+      SET(QT_QTXML_LIBRARY &quot;-F${QT_LIBRARY_DIR} -framework QtXml&quot; CACHE STRING &quot;The QtXml library.&quot;)
+    ELSE(EXISTS ${QT_LIBRARY_DIR}/QtXml.framework)
+      SET(QT_QTXML_FOUND FALSE)
+    ENDIF(EXISTS ${QT_LIBRARY_DIR}/QtXml.framework)
+
+    IF(EXISTS ${QT_LIBRARY_DIR}/QtSvg.framework)
+      SET(QT_QTSVG_FOUND TRUE)
+      SET(QT_QTSVG_LIBRARY &quot;-F${QT_LIBRARY_DIR} -framework QtSvg&quot; CACHE STRING &quot;The QtSvg library.&quot;)
+    ELSE(EXISTS ${QT_LIBRARY_DIR}/QtSvg.framework)
+      SET(QT_QTSVG_FOUND FALSE)
+    ENDIF(EXISTS ${QT_LIBRARY_DIR}/QtSvg.framework)
+
+    IF(EXISTS ${QT_LIBRARY_DIR}/QtDBus.framework)
+      SET(QT_QTDBUS_FOUND TRUE)
+      SET(QT_QTDBUS_LIBRARY &quot;-F${QT_LIBRARY_DIR} -framework QtDBus&quot; CACHE STRING &quot;The QtDBus library.&quot;)
+    ELSE(EXISTS ${QT_LIBRARY_DIR}/QtDBus.framework)
+      SET(QT_QTDBUS_FOUND FALSE)
+    ENDIF(EXISTS ${QT_LIBRARY_DIR}/QtDBus.framework)
+
+    IF(EXISTS ${QT_LIBRARY_DIR}/QtTest.framework)
+      SET(QT_QTTEST_FOUND TRUE)
+      SET(QT_QTTEST_LIBRARY &quot;-F${QT_LIBRARY_DIR} -framework QtTest&quot; CACHE STRING &quot;The QtTest library.&quot;)
+    ELSE(EXISTS ${QT_LIBRARY_DIR}/QtTest.framework)
+      SET(QT_QTTEST_FOUND FALSE)
+    ENDIF(EXISTS ${QT_LIBRARY_DIR}/QtTest.framework)
+
+    # WTF?  why don't we have frameworks?  :P
+    # Set QT_QTUITOOLS_LIBRARY
+    FIND_LIBRARY(QT_QTUITOOLS_LIBRARY NAMES QtUiTools QtUiTools4 PATHS ${QT_LIBRARY_DIR} )
+    # Set QT_QTSCRIPT_LIBRARY
+    FIND_LIBRARY(QT_QTSCRIPT_LIBRARY NAMES QtScript QtScript4    PATHS ${QT_LIBRARY_DIR} )
+
+  ELSE (QT_USE_FRAMEWORKS)
+    
+    # Set QT_QTCORE_LIBRARY by searching for a lib with &quot;QtCore.&quot;  as part of the filename
+    FIND_LIBRARY(QT_QTCORE_LIBRARY NAMES QtCore QtCore4          PATHS ${QT_LIBRARY_DIR} NO_DEFAULT_PATH )
+
+    # Set QT_QT3SUPPORT_LIBRARY
+    FIND_LIBRARY(QT_QT3SUPPORT_LIBRARY NAMES Qt3Support Qt3Support4 PATHS ${QT_LIBRARY_DIR} NO_DEFAULT_PATH)
+
+    # Set QT_QTGUI_LIBRARY
+    FIND_LIBRARY(QT_QTGUI_LIBRARY NAMES QtGui QtGui4             PATHS ${QT_LIBRARY_DIR} NO_DEFAULT_PATH)
+
+    # Set QT_QTMOTIF_LIBRARY
+    IF(Q_WS_X11)
+      FIND_LIBRARY(QT_QTMOTIF_LIBRARY NAMES QtMotif              PATHS ${QT_LIBRARY_DIR} NO_DEFAULT_PATH)
+    ENDIF(Q_WS_X11)
+
+    # Set QT_QTNETWORK_LIBRARY
+    FIND_LIBRARY(QT_QTNETWORK_LIBRARY NAMES QtNetwork QtNetwork4 PATHS ${QT_LIBRARY_DIR} NO_DEFAULT_PATH)
+
+    # Set QT_QTNSPLUGIN_LIBRARY
+    FIND_LIBRARY(QT_QTNSPLUGIN_LIBRARY NAMES QtNsPlugin          PATHS ${QT_LIBRARY_DIR} NO_DEFAULT_PATH)
+
+    # Set QT_QTOPENGL_LIBRARY
+    FIND_LIBRARY(QT_QTOPENGL_LIBRARY NAMES QtOpenGL QtOpenGL4    PATHS ${QT_LIBRARY_DIR} NO_DEFAULT_PATH)
+
+    # Set QT_QTSQL_LIBRARY
+    FIND_LIBRARY(QT_QTSQL_LIBRARY NAMES QtSql QtSql4             PATHS ${QT_LIBRARY_DIR} NO_DEFAULT_PATH)
+
+    # Set QT_QTXML_LIBRARY
+    FIND_LIBRARY(QT_QTXML_LIBRARY NAMES QtXml QtXml4             PATHS ${QT_LIBRARY_DIR} NO_DEFAULT_PATH)
+
+    # Set QT_QTSVG_LIBRARY
+    FIND_LIBRARY(QT_QTSVG_LIBRARY NAMES QtSvg QtSvg4             PATHS ${QT_LIBRARY_DIR} NO_DEFAULT_PATH)
+
+    # Set QT_QTSCRIPT_LIBRARY
+    FIND_LIBRARY(QT_QTSCRIPT_LIBRARY NAMES QtScript QtScript4    PATHS ${QT_LIBRARY_DIR} NO_DEFAULT_PATH)
+
+    # Set QT_QTUITOOLS_LIBRARY
+    FIND_LIBRARY(QT_QTUITOOLS_LIBRARY NAMES QtUiTools QtUiTools4 PATHS ${QT_LIBRARY_DIR} NO_DEFAULT_PATH)
+
+    # Set QT_QTTEST_LIBRARY
+    FIND_LIBRARY(QT_QTTEST_LIBRARY NAMES QtTest QtTest4          PATHS ${QT_LIBRARY_DIR} NO_DEFAULT_PATH)
+
+    FIND_LIBRARY(QT_QTDBUS_LIBRARY NAMES QtDBus QtDBus4          PATHS ${QT_LIBRARY_DIR} NO_DEFAULT_PATH)
+
+    IF(MSVC)
+      FIND_LIBRARY(QT_QTCORE_LIBRARY_DEBUG      NAMES QtCored4            PATHS ${QT_LIBRARY_DIR} NO_DEFAULT_PATH)
+      FIND_LIBRARY(QT_QT3SUPPORT_LIBRARY_DEBUG  NAMES Qt3Supportd4        PATHS ${QT_LIBRARY_DIR} NO_DEFAULT_PATH)
+      FIND_LIBRARY(QT_QTGUI_LIBRARY_DEBUG       NAMES QtGuid4             PATHS ${QT_LIBRARY_DIR} NO_DEFAULT_PATH)
+      FIND_LIBRARY(QT_QTNETWORK_LIBRARY_DEBUG   NAMES QtNetworkd4         PATHS ${QT_LIBRARY_DIR} NO_DEFAULT_PATH)
+      FIND_LIBRARY(QT_QTOPENGL_LIBRARY_DEBUG    NAMES QtOpenGLd4          PATHS ${QT_LIBRARY_DIR} NO_DEFAULT_PATH)
+      FIND_LIBRARY(QT_QTSQL_LIBRARY_DEBUG       NAMES QtSqld4             PATHS ${QT_LIBRARY_DIR} NO_DEFAULT_PATH)
+      FIND_LIBRARY(QT_QTXML_LIBRARY_DEBUG       NAMES QtXmld4             PATHS ${QT_LIBRARY_DIR} NO_DEFAULT_PATH)
+      FIND_LIBRARY(QT_QTSVG_LIBRARY_DEBUG       NAMES QtSvgd4             PATHS ${QT_LIBRARY_DIR} NO_DEFAULT_PATH)
+      FIND_LIBRARY(QT_QTSCRIPT_LIBRARY_DEBUG    NAMES QtScriptd4          PATHS ${QT_LIBRARY_DIR} NO_DEFAULT_PATH)
+      FIND_LIBRARY(QT_QTUITOOLS_LIBRARY_DEBUG   NAMES QtUiToolsd QtUiToolsd4 PATHS ${QT_LIBRARY_DIR} NO_DEFAULT_PATH)
+      FIND_LIBRARY(QT_QTTEST_LIBRARY_DEBUG      NAMES QtTestd4            PATHS ${QT_LIBRARY_DIR} NO_DEFAULT_PATH)
+      FIND_LIBRARY(QT_QTDBUS_LIBRARY_DEBUG      NAMES QtDBusd4            PATHS ${QT_LIBRARY_DIR} NO_DEFAULT_PATH)
+      FIND_LIBRARY(QT_QTASSISTANT_LIBRARY_DEBUG NAMES QtAssistantClientd4 PATHS ${QT_LIBRARY_DIR} NO_DEFAULT_PATH)
+      FIND_LIBRARY(QT_QTDESIGNER_LIBRARY_DEBUG           NAMES QtDesigner4            PATHS ${QT_LIBRARY_DIR} NO_DEFAULT_PATH)
+      FIND_LIBRARY(QT_QTDESIGNERCOMPONENTS_LIBRARY_DEBUG NAMES QtDesignerComponentsd4 PATHS ${QT_LIBRARY_DIR} NO_DEFAULT_PATH)
+      FIND_LIBRARY(QT_QTMAIN_LIBRARY_DEBUG      NAMES qtmaind             PATHS ${QT_LIBRARY_DIR} NO_DEFAULT_PATH)
+    ENDIF(MSVC)
+
+  ENDIF (QT_USE_FRAMEWORKS)
+
+  IF( NOT QT_QTCORE_LIBRARY )
+    IF( NOT Qt4_FIND_QUIETLY AND Qt4_FIND_REQUIRED)
+      MESSAGE( FATAL_ERROR &quot;Could NOT find QtCore. Check CMakeFiles/CMakeError.log for more details.&quot;)
+    ENDIF( NOT Qt4_FIND_QUIETLY AND Qt4_FIND_REQUIRED)
+  ENDIF( NOT QT_QTCORE_LIBRARY )
+
+  # Set QT_QTASSISTANT_LIBRARY
+  FIND_LIBRARY(QT_QTASSISTANT_LIBRARY NAMES QtAssistantClient QtAssistantClient4 QtAssistant QtAssistant4 PATHS ${QT_LIBRARY_DIR} NO_DEFAULT_PATH)
+
+  # Set QT_QTDESIGNER_LIBRARY
+  FIND_LIBRARY(QT_QTDESIGNER_LIBRARY NAMES QtDesigner QtDesigner4 PATHS ${QT_LIBRARY_DIR}        NO_DEFAULT_PATH)
+
+  # Set QT_QTDESIGNERCOMPONENTS_LIBRARY
+  FIND_LIBRARY(QT_QTDESIGNERCOMPONENTS_LIBRARY NAMES QtDesignerComponents QtDesignerComponents4 PATHS ${QT_LIBRARY_DIR}        NO_DEFAULT_PATH)
+
+  # Set QT_QTMAIN_LIBRARY
+  IF(WIN32)
+    FIND_LIBRARY(QT_QTMAIN_LIBRARY NAMES qtmain PATHS ${QT_LIBRARY_DIR} NO_DEFAULT_PATH)
+  ENDIF(WIN32)
+
+  ############################################
+  #
+  # Check the existence of the libraries.
+  #
+  ############################################
+
+  MACRO (_QT4_ADJUST_LIB_VARS basename)
+    IF (QT_${basename}_LIBRARY OR QT_${basename}_LIBRARY_DEBUG)
+
+      IF(MSVC)
+
+        # Both set
+        IF (QT_${basename}_LIBRARY AND QT_${basename}_LIBRARY_DEBUG)
+          SET(QT_${basename}_LIBRARY optimized ${QT_${basename}_LIBRARY} debug ${QT_${basename}_LIBRARY_DEBUG})
+        ENDIF (QT_${basename}_LIBRARY AND QT_${basename}_LIBRARY_DEBUG)
+
+        # Only debug was found
+        IF (NOT QT_${basename}_LIBRARY AND QT_${basename}_LIBRARY_DEBUG)
+          SET(QT_${basename}_LIBRARY ${QT_${basename}_LIBRARY_DEBUG})
+        ENDIF (NOT QT_${basename}_LIBRARY AND QT_${basename}_LIBRARY_DEBUG)
+
+        # Hmm, is this used anywhere ? Yes, in UseQt4.cmake. We are currently incompatible :-(
+        SET(QT_${basename}_LIBRARIES optimized ${QT_${basename}_LIBRARY} debug ${QT_${basename}_LIBRARY_DEBUG})
+
+      ENDIF(MSVC)
+
+      SET(QT_${basename}_LIBRARY ${QT_${basename}_LIBRARY} CACHE FILEPATH &quot;The Qt ${basename} library&quot;)
+
+      IF (QT_${basename}_LIBRARY)
+        SET(QT_${basename}_FOUND 1)
+      ENDIF (QT_${basename}_LIBRARY)
+      
+    ENDIF (QT_${basename}_LIBRARY OR QT_${basename}_LIBRARY_DEBUG)
+    
+    IF (QT_${basename}_INCLUDE_DIR)
+      #add the include directory to QT_INCLUDES
+      SET(QT_INCLUDES ${QT_INCLUDES} &quot;${QT_${basename}_INCLUDE_DIR}&quot;)
+    ENDIF (QT_${basename}_INCLUDE_DIR)
+
+    # Make variables changeble to the advanced user
+    MARK_AS_ADVANCED(QT_${basename}_LIBRARY QT_${basename}_INCLUDE_DIR)
+  ENDMACRO (_QT4_ADJUST_LIB_VARS)
+
+
+  # Set QT_xyz_LIBRARY variable and add 
+  # library include path to QT_INCLUDES
+  _QT4_ADJUST_LIB_VARS(QTCORE)
+  _QT4_ADJUST_LIB_VARS(QTGUI)
+  _QT4_ADJUST_LIB_VARS(QT3SUPPORT)
+  _QT4_ADJUST_LIB_VARS(QTASSISTANT)
+  _QT4_ADJUST_LIB_VARS(QTDESIGNER)
+  _QT4_ADJUST_LIB_VARS(QTDESIGNERCOMPONENTS)
+  _QT4_ADJUST_LIB_VARS(QTNETWORK)
+  _QT4_ADJUST_LIB_VARS(QTNSPLUGIN)
+  _QT4_ADJUST_LIB_VARS(QTOPENGL)
+  _QT4_ADJUST_LIB_VARS(QTSQL)
+  _QT4_ADJUST_LIB_VARS(QTXML)
+  _QT4_ADJUST_LIB_VARS(QTSVG)
+  _QT4_ADJUST_LIB_VARS(QTSCRIPT)
+  _QT4_ADJUST_LIB_VARS(QTUITOOLS)
+  _QT4_ADJUST_LIB_VARS(QTTEST)
+  _QT4_ADJUST_LIB_VARS(QTDBUS)
+  
+  
+  # platform dependent libraries
+  IF(Q_WS_X11)
+    _QT4_ADJUST_LIB_VARS(QTMOTIF)
+  ENDIF(Q_WS_X11)
+  IF(WIN32)
+    _QT4_ADJUST_LIB_VARS(QTMAIN)
+  ENDIF(WIN32)
+
+  IF(QT_QTSCRIPT_LIBRARY AND QT_QTUITOOLS_LIBRARY)
+    SET(QT_QTUITOOLS_LIBRARY ${QT_QTUITOOLS_LIBRARY} ${QT_QTSCRIPT_LIBRARY} )
+  ENDIF(QT_QTSCRIPT_LIBRARY AND QT_QTUITOOLS_LIBRARY)
+
+  #######################################
+  #
+  #       Check the executables of Qt 
+  #          ( moc, uic, rcc )
+  #
+  #######################################
+
+
+  # find moc and uic using qmake
+  QT_QUERY_QMAKE(QT_MOC_EXECUTABLE_INTERNAL &quot;QMAKE_MOC&quot;)
+  QT_QUERY_QMAKE(QT_UIC_EXECUTABLE_INTERNAL &quot;QMAKE_UIC&quot;)
+
+  FILE(TO_CMAKE_PATH 
+    &quot;${QT_MOC_EXECUTABLE_INTERNAL}&quot; QT_MOC_EXECUTABLE_INTERNAL)
+  FILE(TO_CMAKE_PATH 
+    &quot;${QT_UIC_EXECUTABLE_INTERNAL}&quot; QT_UIC_EXECUTABLE_INTERNAL)
+
+  SET(QT_MOC_EXECUTABLE 
+    ${QT_MOC_EXECUTABLE_INTERNAL} CACHE FILEPATH &quot;The moc executable&quot;)
+  SET(QT_UIC_EXECUTABLE 
+    ${QT_UIC_EXECUTABLE_INTERNAL} CACHE FILEPATH &quot;The uic executable&quot;)
+
+  FIND_PROGRAM(QT_UIC3_EXECUTABLE
+    NAMES uic3
+    PATHS ${QT_BINARY_DIR}
+    NO_DEFAULT_PATH
+    )
+
+  FIND_PROGRAM(QT_RCC_EXECUTABLE 
+    NAMES rcc
+    PATHS ${QT_BINARY_DIR}
+    NO_DEFAULT_PATH
+    )
+
+  FIND_PROGRAM(QT_DBUSCPP2XML_EXECUTABLE 
+    NAMES qdbuscpp2xml
+    PATHS ${QT_BINARY_DIR}
+    NO_DEFAULT_PATH
+    )
+
+  FIND_PROGRAM(QT_DBUSXML2CPP_EXECUTABLE 
+    NAMES qdbusxml2cpp
+    PATHS ${QT_BINARY_DIR}
+    NO_DEFAULT_PATH
+    )
+
+  IF (QT_MOC_EXECUTABLE)
+     SET(QT_WRAP_CPP &quot;YES&quot;)
+  ENDIF (QT_MOC_EXECUTABLE)
+
+  IF (QT_UIC_EXECUTABLE)
+     SET(QT_WRAP_UI &quot;YES&quot;)
+  ENDIF (QT_UIC_EXECUTABLE)
+
+
+
+  MARK_AS_ADVANCED( QT_UIC_EXECUTABLE QT_UIC3_EXECUTABLE QT_MOC_EXECUTABLE QT_RCC_EXECUTABLE QT_DBUSXML2CPP_EXECUTABLE QT_DBUSCPP2XML_EXECUTABLE)
+
+  ######################################
+  #
+  #       Macros for building Qt files
+  #
+  ######################################
+
+  MACRO (QT4_GET_MOC_INC_DIRS _moc_INC_DIRS)
+     SET(${_moc_INC_DIRS})
+     GET_DIRECTORY_PROPERTY(_inc_DIRS INCLUDE_DIRECTORIES)
+
+     FOREACH(_current ${_inc_DIRS})
+        SET(${_moc_INC_DIRS} ${${_moc_INC_DIRS}} &quot;-I&quot; ${_current})
+     ENDFOREACH(_current ${_inc_DIRS})
+  ENDMACRO(QT4_GET_MOC_INC_DIRS)
+
+
+  MACRO (QT4_GENERATE_MOC infile outfile )
+  # get include dirs
+     QT4_GET_MOC_INC_DIRS(moc_includes)
+
+     GET_FILENAME_COMPONENT(abs_infile ${infile} ABSOLUTE)
+
+     ADD_CUSTOM_COMMAND(OUTPUT ${outfile}
+        COMMAND ${QT_MOC_EXECUTABLE}
+        ARGS ${moc_includes} -o ${outfile} ${abs_infile}
+        DEPENDS ${abs_infile})
+
+     SET_SOURCE_FILES_PROPERTIES(${outfile} PROPERTIES SKIP_AUTOMOC TRUE)  # dont run automoc on this file
+
+     MACRO_ADD_FILE_DEPENDENCIES(${abs_infile} ${outfile})
+  ENDMACRO (QT4_GENERATE_MOC)
+
+
+  # QT4_WRAP_CPP(outfiles inputfile ... )
+  # TODO  perhaps add support for -D, -U and other minor options
+
+  MACRO (QT4_WRAP_CPP outfiles )
+    # get include dirs
+    QT4_GET_MOC_INC_DIRS(moc_includes)
+
+    FOREACH (it ${ARGN})
+      GET_FILENAME_COMPONENT(it ${it} ABSOLUTE)
+      GET_FILENAME_COMPONENT(outfile ${it} NAME_WE)
+
+      SET(outfile ${CMAKE_CURRENT_BINARY_DIR}/moc_${outfile}.cxx)
+      ADD_CUSTOM_COMMAND(OUTPUT ${outfile}
+        COMMAND ${QT_MOC_EXECUTABLE}
+        ARGS ${moc_includes} -o ${outfile} ${it}
+        DEPENDS ${it})
+      SET(${outfiles} ${${outfiles}} ${outfile})
+    ENDFOREACH(it)
+
+  ENDMACRO (QT4_WRAP_CPP)
+
+
+  # QT4_WRAP_UI(outfiles inputfile ... )
+
+  MACRO (QT4_WRAP_UI outfiles )
+
+    FOREACH (it ${ARGN})
+      GET_FILENAME_COMPONENT(outfile ${it} NAME_WE)
+      GET_FILENAME_COMPONENT(infile ${it} ABSOLUTE)
+      SET(outfile ${CMAKE_CURRENT_BINARY_DIR}/ui_${outfile}.h)
+      ADD_CUSTOM_COMMAND(OUTPUT ${outfile}
+        COMMAND ${QT_UIC_EXECUTABLE}
+        ARGS -o ${outfile} ${infile}
+        MAIN_DEPENDENCY ${infile})
+      SET(${outfiles} ${${outfiles}} ${outfile})
+    ENDFOREACH (it)
+
+  ENDMACRO (QT4_WRAP_UI)
+
+
+  # QT4_ADD_RESOURCE(outfiles inputfile ... )
+  # TODO  perhaps consider adding support for compression and root options to rcc
+
+  MACRO (QT4_ADD_RESOURCES outfiles )
+
+    FOREACH (it ${ARGN})
+      GET_FILENAME_COMPONENT(outfilename ${it} NAME_WE)
+      GET_FILENAME_COMPONENT(infile ${it} ABSOLUTE)
+      GET_FILENAME_COMPONENT(rc_path ${infile} PATH)
+      SET(outfile ${CMAKE_CURRENT_BINARY_DIR}/qrc_${outfilename}.cxx)
+      #  parse file for dependencies
+      FILE(READ &quot;${infile}&quot; _RC_FILE_CONTENTS)
+      STRING(REGEX MATCHALL &quot;&lt;file[^&lt;]+&quot; _RC_FILES &quot;${_RC_FILE_CONTENTS}&quot;)
+      
+      SET(_RC_DEPENDS)
+      FOREACH(_RC_FILE ${_RC_FILES})
+        STRING(REGEX REPLACE &quot;^&lt;file[^&gt;]*&gt;&quot; &quot;&quot; _RC_FILE &quot;${_RC_FILE}&quot;)
+        SET(_RC_DEPENDS ${_RC_DEPENDS} &quot;${rc_path}/${_RC_FILE}&quot;)
+      ENDFOREACH(_RC_FILE)
+      ADD_CUSTOM_COMMAND(OUTPUT ${outfile}
+        COMMAND ${QT_RCC_EXECUTABLE}
+        ARGS -name ${outfilename} -o ${outfile} ${infile}
+        MAIN_DEPENDENCY ${infile}
+        DEPENDS ${_RC_DEPENDS})
+      SET(${outfiles} ${${outfiles}} ${outfile})
+    ENDFOREACH (it)
+
+  ENDMACRO (QT4_ADD_RESOURCES)
+
+  MACRO(QT4_ADD_DBUS_INTERFACE _sources _interface _basename)
+    GET_FILENAME_COMPONENT(_infile ${_interface} ABSOLUTE)
+    SET(_header ${CMAKE_CURRENT_BINARY_DIR}/${_basename}.h)
+    SET(_impl   ${CMAKE_CURRENT_BINARY_DIR}/${_basename}.cpp)
+    SET(_moc    ${CMAKE_CURRENT_BINARY_DIR}/${_basename}.moc)
+
+    GET_SOURCE_FILE_PROPERTY(_nonamespace ${_infile} NO_NAMESPACE)
+    IF ( _nonamespace )
+        SET(_params -N -m -p)
+    ELSE ( _nonamespace )
+        SET(_params -m -p)
+    ENDIF ( _nonamespace )
+
+     ADD_CUSTOM_COMMAND(OUTPUT ${_impl} ${_header}
+        COMMAND ${QT_DBUSXML2CPP_EXECUTABLE} ${_params} ${_basename} ${_infile}
+        DEPENDS ${_infile})
+
+    SET_SOURCE_FILES_PROPERTIES(${_impl} PROPERTIES SKIP_AUTOMOC TRUE)
+    
+    QT4_GENERATE_MOC(${_header} ${_moc})
+  
+    SET(${_sources} ${${_sources}} ${_impl} ${_header} ${_moc})
+    MACRO_ADD_FILE_DEPENDENCIES(${_impl} ${_moc})
+  
+  ENDMACRO(QT4_ADD_DBUS_INTERFACE)
+ 
+  MACRO(QT4_ADD_DBUS_INTERFACE_NO_NAMESPACE _sources _interface _basename)
+    SET_SOURCE_FILES_PROPERTIES(${_interface} PROPERTIES NO_NAMESPACE TRUE)
+    QT4_ADD_DBUS_INTERFACE(${_sources} ${_interface} ${_basename})
+  ENDMACRO(QT4_ADD_DBUS_INTERFACE_NO_NAMESPACE)
+
+  # Internal (avoid to duplicate code between QT4_ADD_DBUS_INTERFACES_NO_NAMESPACE and QT4_ADD_DBUS_INTERFACES 
+  MACRO(_QT4_ADD_DBUS_INTERFACES _sources _filename)
+        GET_FILENAME_COMPONENT(_infile ${_filename} ABSOLUTE)
+        # get the part before the &quot;.xml&quot; suffix
+        STRING(REGEX REPLACE &quot;(.*[/\\.])?([^\\.]+)\\.xml&quot; &quot;\\2&quot; _basename ${_current_FILE})
+        STRING(TOLOWER ${_basename} _basename)
+        QT4_ADD_DBUS_INTERFACE(${_sources} ${_infile} ${_basename}interface)     
+  ENDMACRO(_QT4_ADD_DBUS_INTERFACES)
+
+  MACRO(QT4_ADD_DBUS_INTERFACES _sources)
+     FOREACH (_current_FILE ${ARGN})
+        _QT4_ADD_DBUS_INTERFACES(${_sources} ${_current_FILE})
+     ENDFOREACH (_current_FILE)
+  ENDMACRO(QT4_ADD_DBUS_INTERFACES)
+
+  MACRO(QT4_ADD_DBUS_INTERFACES_NO_NAMESPACE _sources)
+    FOREACH (_current_FILE ${ARGN})
+	SET_SOURCE_FILES_PROPERTIES(${_current_FILE} PROPERTIES NO_NAMESPACE TRUE)
+        _QT4_ADD_DBUS_INTERFACES(${_sources} ${_current_FILE})
+    ENDFOREACH (_current_FILE)
+  ENDMACRO(QT4_ADD_DBUS_INTERFACES_NO_NAMESPACE)
+  
+  MACRO(QT4_GENERATE_DBUS_INTERFACE _header) # _customName )
+    SET(_customName &quot;${ARGV1}&quot;)
+    GET_FILENAME_COMPONENT(_in_file ${_header} ABSOLUTE)
+    GET_FILENAME_COMPONENT(_basename ${_header} NAME_WE)
+    
+    IF (_customName)
+      SET(_target ${CMAKE_CURRENT_BINARY_DIR}/${_customName})
+    ELSE (_customName)
+      SET(_target ${CMAKE_CURRENT_BINARY_DIR}/${_basename}.xml)
+    ENDIF (_customName)
+  
+    ADD_CUSTOM_COMMAND(OUTPUT ${_target}
+        COMMAND ${QT_DBUSCPP2XML_EXECUTABLE} ${_in_file} &gt; ${_target}
+        DEPENDS ${_in_file}
+    )
+  ENDMACRO(QT4_GENERATE_DBUS_INTERFACE)
+  
+  
+  MACRO(QT4_ADD_DBUS_ADAPTOR _sources _xml_file _include _parentClass) # _optionalBasename )
+    GET_FILENAME_COMPONENT(_infile ${_xml_file} ABSOLUTE)
+    
+    SET(_optionalBasename &quot;${ARGV4}&quot;)
+    IF (_optionalBasename)
+       SET(_basename ${_optionalBasename} )
+    ELSE (_optionalBasename)
+       STRING(REGEX REPLACE &quot;(.*[/\\.])?([^\\.]+)\\.xml&quot; &quot;\\2adaptor&quot; _basename ${_infile})
+       STRING(TOLOWER ${_basename} _basename)
+    ENDIF (_optionalBasename)
+
+    SET(_optionalClassName &quot;${ARGV5}&quot;)
+    SET(_header ${CMAKE_CURRENT_BINARY_DIR}/${_basename}.h)
+    SET(_impl   ${CMAKE_CURRENT_BINARY_DIR}/${_basename}.cpp)
+    SET(_moc    ${CMAKE_CURRENT_BINARY_DIR}/${_basename}.moc)
+
+    IF(_optionalClassName)
+       ADD_CUSTOM_COMMAND(OUTPUT ${_impl} ${_header}
+          COMMAND ${QT_DBUSXML2CPP_EXECUTABLE} -m -a ${_basename} -c ${_optionalClassName} -i ${_include} -l ${_parentClass} ${_infile}
+          DEPENDS ${_infile}
+        )
+    ELSE(_optionalClassName)
+       ADD_CUSTOM_COMMAND(OUTPUT ${_impl} ${_header}
+          COMMAND ${QT_DBUSXML2CPP_EXECUTABLE} -m -a ${_basename} -i ${_include} -l ${_parentClass} ${_infile}
+          DEPENDS ${_infile}
+        )
+    ENDIF(_optionalClassName)
+
+    QT4_GENERATE_MOC(${_header} ${_moc})
+    SET_SOURCE_FILES_PROPERTIES(${_impl} PROPERTIES SKIP_AUTOMOC TRUE)
+    MACRO_ADD_FILE_DEPENDENCIES(${_impl} ${_moc})
+
+    SET(${_sources} ${${_sources}} ${_impl} ${_header} ${_moc})
+  ENDMACRO(QT4_ADD_DBUS_ADAPTOR)
+
+   MACRO(QT4_AUTOMOC)
+      QT4_GET_MOC_INC_DIRS(_moc_INCS)
+
+      SET(_matching_FILES )
+      FOREACH (_current_FILE ${ARGN})
+
+         GET_FILENAME_COMPONENT(_abs_FILE ${_current_FILE} ABSOLUTE)
+         # if &quot;SKIP_AUTOMOC&quot; is set to true, we will not handle this file here.
+         # here. this is required to make bouic work correctly:
+         # we need to add generated .cpp files to the sources (to compile them),
+         # but we cannot let automoc handle them, as the .cpp files don't exist yet when
+         # cmake is run for the very first time on them -&gt; however the .cpp files might
+         # exist at a later run. at that time we need to skip them, so that we don't add two
+         # different rules for the same moc file
+         GET_SOURCE_FILE_PROPERTY(_skip ${_abs_FILE} SKIP_AUTOMOC)
+
+         IF ( NOT _skip AND EXISTS ${_abs_FILE} )
+
+            FILE(READ ${_abs_FILE} _contents)
+
+            GET_FILENAME_COMPONENT(_abs_PATH ${_abs_FILE} PATH)
+
+            STRING(REGEX MATCHALL &quot;#include +[^ ]+\\.moc[\&quot;&gt;]&quot; _match &quot;${_contents}&quot;)
+            IF(_match)
+               FOREACH (_current_MOC_INC ${_match})
+                  STRING(REGEX MATCH &quot;[^ &lt;\&quot;]+\\.moc&quot; _current_MOC &quot;${_current_MOC_INC}&quot;)
+
+                  GET_filename_component(_basename ${_current_MOC} NAME_WE)
+   #               SET(_header ${CMAKE_CURRENT_SOURCE_DIR}/${_basename}.h)
+                  SET(_header ${_abs_PATH}/${_basename}.h)
+                  SET(_moc    ${CMAKE_CURRENT_BINARY_DIR}/${_current_MOC})
+                  ADD_CUSTOM_COMMAND(OUTPUT ${_moc}
+                     COMMAND ${QT_MOC_EXECUTABLE}
+                     ARGS ${_moc_INCS} ${_header} -o ${_moc}
+                     DEPENDS ${_header}
+                  )
+
+                  MACRO_ADD_FILE_DEPENDENCIES(${_abs_FILE} ${_moc})
+               ENDFOREACH (_current_MOC_INC)
+            ENDIF(_match)
+         ENDIF ( NOT _skip AND EXISTS ${_abs_FILE} )
+      ENDFOREACH (_current_FILE)
+   ENDMACRO(QT4_AUTOMOC)
+
+
+
+  ######################################
+  #
+  #       decide if Qt got found
+  #
+  ######################################
+
+  # if the includes,libraries,moc,uic and rcc are found then we have it
+  IF( QT_LIBRARY_DIR AND QT_INCLUDE_DIR AND QT_MOC_EXECUTABLE AND QT_UIC_EXECUTABLE AND QT_RCC_EXECUTABLE)
+    SET( QT4_FOUND &quot;YES&quot; )
+    IF( NOT Qt4_FIND_QUIETLY)
+      IF (WIN32)
+        MESSAGE(STATUS &quot;Found Qt-Version ${QTVERSION} with qmake at ${QT_QMAKE_EXECUTABLE}&quot;)
+      ELSE (WIN32)
+        MESSAGE(STATUS &quot;Found Qt-Version ${QTVERSION}&quot;)
+      ENDIF (WIN32)
+    ENDIF( NOT Qt4_FIND_QUIETLY)
+  ELSE( QT_LIBRARY_DIR AND QT_INCLUDE_DIR AND QT_MOC_EXECUTABLE AND QT_UIC_EXECUTABLE AND QT_RCC_EXECUTABLE)
+    SET( QT4_FOUND &quot;NO&quot;)
+    SET(QT_QMAKE_EXECUTABLE &quot;${QT_QMAKE_EXECUTABLE}-NOTFOUND&quot; CACHE FILEPATH &quot;Invalid qmake found&quot; FORCE)
+    IF( Qt4_FIND_REQUIRED)
+      IF ( NOT QT_LIBRARY_DIR )
+	MESSAGE(STATUS &quot;Qt libraries NOT found!&quot;)
+      ENDIF(NOT QT_LIBRARY_DIR )
+      IF ( NOT QT_INCLUDE_DIR )
+	MESSAGE(STATUS &quot;Qt includes NOT found!&quot;)
+      ENDIF( NOT QT_INCLUDE_DIR )
+      IF ( NOT QT_MOC_EXECUTABLE )
+        MESSAGE(STATUS &quot;Qt's moc NOT found!&quot;)
+      ENDIF( NOT QT_MOC_EXECUTABLE )
+      IF ( NOT QT_UIC_EXECUTABLE )
+        MESSAGE(STATUS &quot;Qt's uic NOT found!&quot;)
+      ENDIF( NOT QT_UIC_EXECUTABLE )
+      IF ( NOT QT_RCC_EXECUTABLE )
+        MESSAGE(STATUS &quot;Qt's rcc NOT found!&quot;)
+      ENDIF( NOT QT_RCC_EXECUTABLE )
+      MESSAGE( FATAL_ERROR &quot;Qt libraries, includes, moc, uic or/and rcc NOT found!&quot;)
+    ENDIF( Qt4_FIND_REQUIRED)
+  ENDIF( QT_LIBRARY_DIR AND QT_INCLUDE_DIR AND QT_MOC_EXECUTABLE AND QT_UIC_EXECUTABLE AND  QT_RCC_EXECUTABLE)
+  SET(QT_FOUND ${QT4_FOUND})
+
+
+  #######################################
+  #
+  #       System dependent settings  
+  #
+  #######################################
+  # for unix add X11 stuff
+  IF(UNIX)
+    # on OS X X11 may not be required
+    IF (Q_WS_X11)
+      FIND_PACKAGE(X11 REQUIRED)
+    ENDIF (Q_WS_X11)
+    FIND_PACKAGE(Threads)
+    SET(QT_QTCORE_LIBRARY ${QT_QTCORE_LIBRARY} ${CMAKE_THREAD_LIBS_INIT})
+  ENDIF(UNIX)
+
+
+  #######################################
+  #
+  #       compatibility settings 
+  #
+  #######################################
+  # Backwards compatibility for CMake1.4 and 1.2
+  SET (QT_MOC_EXE ${QT_MOC_EXECUTABLE} )
+  SET (QT_UIC_EXE ${QT_UIC_EXECUTABLE} )
+
+  SET( QT_QT_LIBRARY &quot;&quot;)
+
+ELSE(QT4_QMAKE_FOUND)
+   
+   SET(QT_QMAKE_EXECUTABLE &quot;${QT_QMAKE_EXECUTABLE}-NOTFOUND&quot; CACHE FILEPATH &quot;Invalid qmake found&quot; FORCE)
+   IF(Qt4_FIND_REQUIRED)
+      IF(QT4_INSTALLED_VERSION_TOO_OLD)
+         MESSAGE(FATAL_ERROR &quot;The installed Qt version ${QTVERSION} is too old, at least version ${QT_MIN_VERSION} is required&quot;)
+      ELSE(QT4_INSTALLED_VERSION_TOO_OLD)
+         MESSAGE( FATAL_ERROR &quot;Qt qmake not found!&quot;)
+      ENDIF(QT4_INSTALLED_VERSION_TOO_OLD)
+   ELSE(Qt4_FIND_REQUIRED)
+      IF(QT4_INSTALLED_VERSION_TOO_OLD AND NOT Qt4_FIND_QUIETLY)
+         MESSAGE(STATUS &quot;The installed Qt version ${QTVERSION} is too old, at least version ${QT_MIN_VERSION} is required&quot;)
+      ENDIF(QT4_INSTALLED_VERSION_TOO_OLD AND NOT Qt4_FIND_QUIETLY)
+   ENDIF(Qt4_FIND_REQUIRED)
+ 
+ENDIF (QT4_QMAKE_FOUND)
+
+

Added: branches/avidemux_2.4_branch/cmake/FindX11.cmake
===================================================================
--- branches/avidemux_2.4_branch/cmake/FindX11.cmake	2007-05-27 18:44:33 UTC (rev 3157)
+++ branches/avidemux_2.4_branch/cmake/FindX11.cmake	2007-05-28 13:03:46 UTC (rev 3158)
@@ -0,0 +1,154 @@
+# - Find X11 installation
+# Try to find X11 on UNIX systems. The following values are defined
+#  X11_FOUND        - True if X11 is available
+#  X11_INCLUDE_DIR  - include directories to use X11
+#  X11_LIBRARIES    - link against these to use X11
+
+IF (UNIX)
+  SET(X11_FOUND 0)
+  # X11 is never a framework and some header files may be
+  # found in tcl on the mac
+  SET(CMAKE_FIND_FRAMEWORK_SAVE ${CMAKE_FIND_FRAMEWORK})
+  SET(CMAKE_FIND_FRAMEWORK NEVER)
+  SET(X11_INC_SEARCH_PATH
+    /usr/X11R6/include 
+    /usr/local/include 
+    /usr/include/X11
+    /usr/openwin/include 
+    /usr/openwin/share/include 
+    /opt/graphics/OpenGL/include
+    /usr/include
+  )
+
+  SET(X11_LIB_SEARCH_PATH
+    /usr/X11R6/lib
+    /usr/local/lib 
+    /usr/openwin/lib 
+    /usr/lib 
+  )
+
+  FIND_PATH(X11_X11_INCLUDE_PATH X11/X.h ${X11_INC_SEARCH_PATH})
+  FIND_PATH(X11_Xlib_INCLUDE_PATH X11/Xlib.h ${X11_INC_SEARCH_PATH})
+  FIND_PATH(X11_Xutil_INCLUDE_PATH X11/Xutil.h ${X11_INC_SEARCH_PATH})
+  FIND_LIBRARY(X11_X11_LIB X11 ${X11_LIB_SEARCH_PATH})
+  FIND_LIBRARY(X11_Xext_LIB Xext ${X11_LIB_SEARCH_PATH})
+
+  IF(X11_X11_INCLUDE_PATH)
+    SET(X11_INCLUDE_DIR ${X11_INCLUDE_DIR} ${X11_X11_INCLUDE_PATH})
+  ENDIF(X11_X11_INCLUDE_PATH)
+
+  IF(X11_Xlib_INCLUDE_PATH)
+    SET(X11_INCLUDE_DIR ${X11_INCLUDE_DIR} ${X11_Xlib_INCLUDE_PATH})
+  ENDIF(X11_Xlib_INCLUDE_PATH)
+
+  IF(X11_Xutil_INCLUDE_PATH)
+    SET(X11_INCLUDE_DIR ${X11_INCLUDE_DIR} ${X11_Xutil_INCLUDE_PATH})
+  ENDIF(X11_Xutil_INCLUDE_PATH)
+
+  IF(X11_X11_LIB)
+    SET(X11_LIBRARIES ${X11_LIBRARIES} ${X11_X11_LIB})
+  ENDIF(X11_X11_LIB)
+
+  IF(X11_Xext_LIB)
+    SET(X11_LIBRARIES ${X11_LIBRARIES} ${X11_Xext_LIB})
+  ENDIF(X11_Xext_LIB)
+
+  # Deprecated variable for backwards compatibility with CMake 1.4
+  IF(X11_X11_INCLUDE_PATH)
+    IF(X11_LIBRARIES)
+      SET(X11_FOUND 1)
+    ENDIF(X11_LIBRARIES)
+  ENDIF(X11_X11_INCLUDE_PATH)
+
+  SET(X11_LIBRARY_DIR &quot;&quot;)
+  IF(X11_X11_LIB)
+    GET_FILENAME_COMPONENT(X11_LIBRARY_DIR ${X11_X11_LIB} PATH)
+  ENDIF(X11_X11_LIB)
+
+  IF(X11_FOUND)
+    INCLUDE(CheckFunctionExists)
+    INCLUDE(CheckLibraryExists)
+
+    # Translated from an autoconf-generated configure script.
+    # See libs.m4 in autoconf's m4 directory.
+    IF($ENV{ISC} MATCHES &quot;^yes$&quot;)
+      SET(X11_X_EXTRA_LIBS -lnsl_s -linet)
+    ELSE($ENV{ISC} MATCHES &quot;^yes$&quot;)
+      SET(X11_X_EXTRA_LIBS &quot;&quot;)
+
+      # See if XOpenDisplay in X11 works by itself.
+      CHECK_LIBRARY_EXISTS(&quot;${X11_LIBRARIES}&quot; &quot;XOpenDisplay&quot; &quot;${X11_LIBRARY_DIR}&quot; X11_LIB_X11_SOLO)
+      IF(NOT X11_LIB_X11_SOLO)
+        # Find library needed for dnet_ntoa.
+        CHECK_LIBRARY_EXISTS(&quot;dnet&quot; &quot;dnet_ntoa&quot; &quot;&quot; X11_LIB_DNET_HAS_DNET_NTOA) 
+        IF (X11_LIB_DNET_HAS_DNET_NTOA)
+          SET (X11_X_EXTRA_LIBS ${X11_X_EXTRA_LIBS} -ldnet)
+        ELSE (X11_LIB_DNET_HAS_DNET_NTOA)
+          CHECK_LIBRARY_EXISTS(&quot;dnet_stub&quot; &quot;dnet_ntoa&quot; &quot;&quot; X11_LIB_DNET_STUB_HAS_DNET_NTOA) 
+          IF (X11_LIB_DNET_STUB_HAS_DNET_NTOA)
+            SET (X11_X_EXTRA_LIBS ${X11_X_EXTRA_LIBS} -ldnet_stub)
+          ENDIF (X11_LIB_DNET_STUB_HAS_DNET_NTOA)
+        ENDIF (X11_LIB_DNET_HAS_DNET_NTOA)
+      ENDIF(NOT X11_LIB_X11_SOLO)
+
+      # Find library needed for gethostbyname.
+      CHECK_FUNCTION_EXISTS(&quot;gethostbyname&quot; CMAKE_HAVE_GETHOSTBYNAME)
+      IF(NOT CMAKE_HAVE_GETHOSTBYNAME)
+        CHECK_LIBRARY_EXISTS(&quot;nsl&quot; &quot;gethostbyname&quot; &quot;&quot; CMAKE_LIB_NSL_HAS_GETHOSTBYNAME) 
+        IF (CMAKE_LIB_NSL_HAS_GETHOSTBYNAME)
+          SET (X11_X_EXTRA_LIBS ${X11_X_EXTRA_LIBS} -lnsl)
+        ELSE (CMAKE_LIB_NSL_HAS_GETHOSTBYNAME)
+          CHECK_LIBRARY_EXISTS(&quot;bsd&quot; &quot;gethostbyname&quot; &quot;&quot; CMAKE_LIB_BSD_HAS_GETHOSTBYNAME) 
+          IF (CMAKE_LIB_BSD_HAS_GETHOSTBYNAME)
+            SET (X11_X_EXTRA_LIBS ${X11_X_EXTRA_LIBS} -lbsd)
+          ENDIF (CMAKE_LIB_BSD_HAS_GETHOSTBYNAME)
+        ENDIF (CMAKE_LIB_NSL_HAS_GETHOSTBYNAME)
+      ENDIF(NOT CMAKE_HAVE_GETHOSTBYNAME)
+
+      # Find library needed for connect.
+      CHECK_FUNCTION_EXISTS(&quot;connect&quot; CMAKE_HAVE_CONNECT)
+      IF(NOT CMAKE_HAVE_CONNECT)
+        CHECK_LIBRARY_EXISTS(&quot;socket&quot; &quot;connect&quot; &quot;&quot; CMAKE_LIB_SOCKET_HAS_CONNECT) 
+        IF (CMAKE_LIB_SOCKET_HAS_CONNECT)
+          SET (X11_X_EXTRA_LIBS -lsocket ${X11_X_EXTRA_LIBS})
+        ENDIF (CMAKE_LIB_SOCKET_HAS_CONNECT)
+      ENDIF(NOT CMAKE_HAVE_CONNECT)
+
+      # Find library needed for remove.
+      CHECK_FUNCTION_EXISTS(&quot;remove&quot; CMAKE_HAVE_REMOVE)
+      IF(NOT CMAKE_HAVE_REMOVE)
+        CHECK_LIBRARY_EXISTS(&quot;posix&quot; &quot;remove&quot; &quot;&quot; CMAKE_LIB_POSIX_HAS_REMOVE) 
+        IF (CMAKE_LIB_POSIX_HAS_REMOVE)
+          SET (X11_X_EXTRA_LIBS ${X11_X_EXTRA_LIBS} -lposix)
+        ENDIF (CMAKE_LIB_POSIX_HAS_REMOVE)
+      ENDIF(NOT CMAKE_HAVE_REMOVE)
+
+      # Find library needed for shmat.
+      CHECK_FUNCTION_EXISTS(&quot;shmat&quot; CMAKE_HAVE_SHMAT)
+      IF(NOT CMAKE_HAVE_SHMAT)
+        CHECK_LIBRARY_EXISTS(&quot;ipc&quot; &quot;shmat&quot; &quot;&quot; CMAKE_LIB_IPS_HAS_SHMAT) 
+        IF (CMAKE_LIB_IPS_HAS_SHMAT)
+          SET (X11_X_EXTRA_LIBS ${X11_X_EXTRA_LIBS} -lipc)
+        ENDIF (CMAKE_LIB_IPS_HAS_SHMAT)
+      ENDIF(NOT CMAKE_HAVE_SHMAT)
+    ENDIF($ENV{ISC} MATCHES &quot;^yes$&quot;)
+
+    CHECK_LIBRARY_EXISTS(&quot;ICE&quot; &quot;IceConnectionNumber&quot; &quot;${X11_LIBRARY_DIR}&quot;
+                         CMAKE_LIB_ICE_HAS_ICECONNECTIONNUMBER)
+    IF(CMAKE_LIB_ICE_HAS_ICECONNECTIONNUMBER)
+      SET (X11_X_PRE_LIBS -lSM -lICE)
+    ENDIF(CMAKE_LIB_ICE_HAS_ICECONNECTIONNUMBER)
+    # Build the final list of libraries.
+    SET (X11_LIBRARIES ${X11_X_PRE_LIBS} ${X11_LIBRARIES} ${X11_X_EXTRA_LIBS})
+  ENDIF(X11_FOUND)
+
+  MARK_AS_ADVANCED(
+    X11_X11_INCLUDE_PATH
+    X11_X11_LIB
+    X11_Xext_LIB
+    X11_Xlib_INCLUDE_PATH
+    X11_Xutil_INCLUDE_PATH
+    X11_LIBRARIES
+    )
+  SET(CMAKE_FIND_FRAMEWORK ${CMAKE_FIND_FRAMEWORK_SAVE})
+ENDIF (UNIX)

Added: branches/avidemux_2.4_branch/cmake/MacroEnsureOutOfSourceBuild.cmake
===================================================================
--- branches/avidemux_2.4_branch/cmake/MacroEnsureOutOfSourceBuild.cmake	2007-05-27 18:44:33 UTC (rev 3157)
+++ branches/avidemux_2.4_branch/cmake/MacroEnsureOutOfSourceBuild.cmake	2007-05-28 13:03:46 UTC (rev 3158)
@@ -0,0 +1,16 @@
+# - MACRO_ENSURE_OUT_OF_SOURCE_BUILD(&lt;errorMessage&gt;)
+# MACRO_ENSURE_OUT_OF_SOURCE_BUILD(&lt;errorMessage&gt;)
+
+# Copyright (c) 2006, Alexander Neundorf, &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">neundorf at kde.org</A>&gt;
+#
+# Redistribution and use is allowed according to the terms of the BSD license.
+# For details see the accompanying COPYING-CMAKE-SCRIPTS file.
+
+MACRO (MACRO_ENSURE_OUT_OF_SOURCE_BUILD _errorMessage)
+
+   STRING(COMPARE EQUAL &quot;${CMAKE_SOURCE_DIR}&quot; &quot;${CMAKE_BINARY_DIR}&quot; insource)
+      IF(insource)
+            MESSAGE(FATAL_ERROR &quot;${_errorMessage}&quot;)
+       ENDIF(insource)
+
+ENDMACRO (MACRO_ENSURE_OUT_OF_SOURCE_BUILD)

Added: branches/avidemux_2.4_branch/cmake/Po.cmake
===================================================================
--- branches/avidemux_2.4_branch/cmake/Po.cmake	2007-05-27 18:44:33 UTC (rev 3157)
+++ branches/avidemux_2.4_branch/cmake/Po.cmake	2007-05-28 13:03:46 UTC (rev 3158)
@@ -0,0 +1,100 @@
+# a small macro to create mo files out of po's
+# Taken from sim-im.org
+
+MACRO(FIND_MSGFMT)
+    IF(NOT MSGFMT_EXECUTABLE)
+        IF(NOT MSGFMT_NOT_FOUND)
+            IF(WIN32)
+              SET(MSGFMT_NAME &quot;msg2qm&quot;)
+            ELSE(WIN32)
+              SET(MSGFMT_NAME &quot;msgfmt&quot;)
+            ENDIF(WIN32)
+            FIND_PROGRAM(MSGFMT_EXECUTABLE ${MSGFMT_NAME})
+
+            IF (NOT MSGFMT_EXECUTABLE)
+                SET(MSGFMT_NAME &quot;msgfmt&quot;)
+                FIND_PROGRAM(MSGFMT_EXECUTABLE ${MSGFMT_NAME})
+            ENDIF(NOT MSGFMT_EXECUTABLE)
+
+            IF (NOT MSGFMT_EXECUTABLE)
+              MESSAGE(FATAL_ERROR &quot;${MSGFMT_NAME} not found - po files can't be processed&quot;)
+              SET(MSGFMT_NOT_FOUND &quot;1&quot;)     # to avoid double checking in one cmake run
+            ENDIF (NOT MSGFMT_EXECUTABLE)
+
+            MARK_AS_ADVANCED(MSGFMT_EXECUTABLE)
+        ENDIF(NOT MSGFMT_NOT_FOUND)
+    ENDIF(NOT MSGFMT_EXECUTABLE)
+ENDMACRO(FIND_MSGFMT)
+
+MACRO(COMPILE_PO_FILES po_subdir _sources)
+    FIND_MSGFMT()
+
+    IF(MSGFMT_EXECUTABLE)
+        FILE(GLOB po_files ${po_subdir}/*.po)
+
+        FOREACH(po_input ${po_files})
+
+            GET_FILENAME_COMPONENT(_in       ${po_input} ABSOLUTE)
+            GET_FILENAME_COMPONENT(_basename ${po_input} NAME_WE)
+
+            IF(WIN32)
+                FILE(MAKE_DIRECTORY ${CMAKE_BINARY_DIR}/${CMAKE_BUILD_TYPE}/po)
+                GET_FILENAME_COMPONENT(_out ${CMAKE_BINARY_DIR}/${CMAKE_BUILD_TYPE}/po/${_basename}.qm ABSOLUTE)
+                FILE(TO_NATIVE_PATH ${_in}  _in_native)
+                FILE(TO_NATIVE_PATH ${_out} _out_native)
+                GET_FILENAME_COMPONENT(_tmp ${MSGFMT_EXECUTABLE} NAME_WE)
+
+                IF(&quot;${_tmp}&quot; STREQUAL &quot;msg2qm&quot;)
+                    ADD_CUSTOM_COMMAND(
+                        OUTPUT ${_out}
+                        COMMAND ${CMAKE_COMMAND}
+                            -E echo
+                            &quot;Generating&quot; ${_out_native} &quot;from&quot; ${_in_native}
+                        COMMAND ${MSGFMT_EXECUTABLE}
+                            ${_in_native}
+                            ${_out_native}
+                        DEPENDS ${_in}
+                    )
+                ELSE(&quot;${_tmp}&quot; STREQUAL &quot;msg2qm&quot;)
+                    ADD_CUSTOM_COMMAND(
+                        OUTPUT ${_out}
+                        COMMAND ${CMAKE_COMMAND}
+                            -E echo
+                            &quot;Generating&quot; ${_out_native} &quot;from&quot; ${_in_native}
+                        COMMAND ${MSGFMT_EXECUTABLE}
+                            --qt
+                            ${_in_native}
+                            -o
+                            ${_out_native}
+                        DEPENDS ${_in}
+                    )
+                ENDIF(&quot;${_tmp}&quot; STREQUAL &quot;msg2qm&quot;)
+            ELSE(WIN32)
+                FILE(MAKE_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}/po)
+                GET_FILENAME_COMPONENT(_out ${CMAKE_CURRENT_BINARY_DIR}/po/${_basename}.mo ABSOLUTE)
+
+                ADD_CUSTOM_COMMAND(
+                    OUTPUT ${_out}
+                    COMMAND ${CMAKE_COMMAND}
+                        -E echo
+                        &quot;Generating&quot; ${_out} &quot;from&quot; ${_in}
+                    COMMAND ${MSGFMT_EXECUTABLE}
+                        ${_in}
+                        -o ${_out}
+                    DEPENDS ${_in}
+                )
+            ENDIF(WIN32)
+            SET(mo_files ${mo_files} ${_out})
+
+            IF(NOT WIN32)
+               INSTALL(FILES ${_out} DESTINATION ${SIM_I18N_DIR}/${_basename}/LC_MESSAGES RENAME sim.mo)
+            ENDIF(NOT WIN32)
+        ENDFOREACH(po_input ${po_files})
+
+        IF(WIN32)
+           INSTALL(FILES ${mo_files} DESTINATION ${SIM_I18N_DIR})
+        ENDIF(WIN32)
+        SET(${_sources} ${${_sources}} ${mo_files})
+    ENDIF(MSGFMT_EXECUTABLE)
+ENDMACRO(COMPILE_PO_FILES po_subdir)
+

Added: branches/avidemux_2.4_branch/cmake/UsePkgConfig.cmake
===================================================================
--- branches/avidemux_2.4_branch/cmake/UsePkgConfig.cmake	2007-05-27 18:44:33 UTC (rev 3157)
+++ branches/avidemux_2.4_branch/cmake/UsePkgConfig.cmake	2007-05-28 13:03:46 UTC (rev 3158)
@@ -0,0 +1,46 @@
+# - pkg-config module for CMake
+#
+# Defines the following macros:
+#
+# PKGCONFIG(package includedir libdir linkflags cflags)
+#
+# Calling PKGCONFIG will fill the desired information into the 4 given arguments,
+# e.g. PKGCONFIG(libart-2.0 LIBART_INCLUDE_DIR LIBART_LINK_DIR LIBART_LINK_FLAGS LIBART_CFLAGS)
+# if pkg-config was NOT found or the specified software package doesn't exist, the
+# variable will be empty when the function returns, otherwise they will contain the respective information
+#
+
+
+
+FIND_PROGRAM(PKGCONFIG_EXECUTABLE NAMES pkg-config PATHS /usr/local/bin )
+
+MACRO(PKGCONFIG _package _include_DIR _link_DIR _link_FLAGS _cflags)
+# reset the variables at the beginning
+  SET(${_include_DIR})
+  SET(${_link_DIR})
+  SET(${_link_FLAGS})
+  SET(${_cflags})
+
+  # if pkg-config has been found
+  IF(PKGCONFIG_EXECUTABLE)
+
+    EXEC_PROGRAM(${PKGCONFIG_EXECUTABLE} ARGS ${_package} --exists RETURN_VALUE _return_VALUE OUTPUT_VARIABLE _pkgconfigDevNull )
+
+    # and if the package of interest also exists for pkg-config, then get the information
+    IF(NOT _return_VALUE)
+
+      EXEC_PROGRAM(${PKGCONFIG_EXECUTABLE} ARGS ${_package} --variable=includedir OUTPUT_VARIABLE ${_include_DIR} )
+
+      EXEC_PROGRAM(${PKGCONFIG_EXECUTABLE} ARGS ${_package} --variable=libdir OUTPUT_VARIABLE ${_link_DIR} )
+
+      EXEC_PROGRAM(${PKGCONFIG_EXECUTABLE} ARGS ${_package} --libs OUTPUT_VARIABLE ${_link_FLAGS} )
+
+      EXEC_PROGRAM(${PKGCONFIG_EXECUTABLE} ARGS ${_package} --cflags OUTPUT_VARIABLE ${_cflags} )
+
+    ENDIF(NOT _return_VALUE)
+
+  ENDIF(PKGCONFIG_EXECUTABLE)
+
+ENDMACRO(PKGCONFIG _include_DIR _link_DIR _link_FLAGS _cflags)
+
+MARK_AS_ADVANCED(PKGCONFIG_EXECUTABLE)

Added: branches/avidemux_2.4_branch/cmake/UseQt4.cmake
===================================================================
--- branches/avidemux_2.4_branch/cmake/UseQt4.cmake	2007-05-27 18:44:33 UTC (rev 3157)
+++ branches/avidemux_2.4_branch/cmake/UseQt4.cmake	2007-05-28 13:03:46 UTC (rev 3158)
@@ -0,0 +1,91 @@
+# - Use Module for QT4
+# Sets up C and C++ to use Qt 4.  It is assumed that FindQt.cmake
+# has already been loaded.  See FindQt.cmake for information on
+# how to load Qt 4 into your CMake project.
+
+
+ADD_DEFINITIONS(${QT_DEFINITIONS})
+
+INCLUDE_DIRECTORIES(${QT_INCLUDE_DIR})
+
+SET(QT_LIBRARIES &quot;&quot;)
+
+IF (QT_USE_QTMAIN)
+  IF (WIN32)
+    SET(QT_LIBRARIES ${QT_LIBRARIES} ${QT_QTMAIN_LIBRARY})
+  ENDIF (WIN32)
+ENDIF (QT_USE_QTMAIN)
+
+# Macro for setting up compile flags for Qt modules
+MACRO(QT_MODULE_SETUP module)
+  IF (QT_QT${module}_FOUND)
+    ADD_DEFINITIONS(-DQT_${module}_LIB)
+    INCLUDE_DIRECTORIES(${QT_QT${module}_INCLUDE_DIR})
+    SET(QT_LIBRARIES ${QT_LIBRARIES} ${QT_QT${module}_LIBRARY})
+    SET(QT_LIBRARIES ${QT_LIBRARIES} ${QT_${module}_LIB_DEPENDENCIES})
+  ELSE (QT_QT${module}_FOUND)
+    MESSAGE(&quot;Qt ${module} library not found.&quot;)
+  ENDIF (QT_QT${module}_FOUND)
+ENDMACRO(QT_MODULE_SETUP)
+
+
+# Qt modules  (in order of dependence)
+
+IF (QT_USE_QT3SUPPORT)
+  QT_MODULE_SETUP(3SUPPORT)
+    ADD_DEFINITIONS(-DQT3_SUPPORT)
+ENDIF (QT_USE_QT3SUPPORT)
+
+IF (QT_USE_QTOPENGL)
+  QT_MODULE_SETUP(OPENGL)
+ENDIF (QT_USE_QTOPENGL)
+
+IF (QT_USE_QTASSISTANT)
+  QT_MODULE_SETUP(ASSISTANT)
+ENDIF (QT_USE_QTASSISTANT)
+
+IF (QT_USE_QTDESIGNER)
+  QT_MODULE_SETUP(DESIGNER)
+ENDIF (QT_USE_QTDESIGNER)
+
+IF (QT_USE_QTMOTIF)
+  QT_MODULE_SETUP(MOTIF)
+ENDIF (QT_USE_QTMOTIF)
+
+IF (QT_USE_QTNSPLUGIN)
+  QT_MODULE_SETUP(NSPLUGIN)
+ENDIF (QT_USE_QTNSPLUGIN)
+
+IF (QT_USE_QTSVG)
+  QT_MODULE_SETUP(SVG)
+ENDIF (QT_USE_QTSVG)
+
+IF (QT_USE_QTUITOOLS)
+  QT_MODULE_SETUP(UITOOLS)
+ENDIF (QT_USE_QTUITOOLS)
+
+IF (NOT QT_DONT_USE_QTGUI)
+  QT_MODULE_SETUP(GUI)
+ENDIF (NOT QT_DONT_USE_QTGUI)
+
+IF (QT_USE_QTTEST)
+  QT_MODULE_SETUP(TEST)
+ENDIF (QT_USE_QTTEST)
+
+IF (QT_USE_QTXML)
+  QT_MODULE_SETUP(XML)
+ENDIF (QT_USE_QTXML)
+
+IF (QT_USE_QTSQL)
+  QT_MODULE_SETUP(SQL)
+ENDIF (QT_USE_QTSQL)
+
+IF (QT_USE_QTNETWORK)
+  QT_MODULE_SETUP(NETWORK)
+ENDIF (QT_USE_QTNETWORK)
+
+IF (NOT QT_DONT_USE_QTCORE)
+  QT_MODULE_SETUP(CORE)
+ENDIF (NOT QT_DONT_USE_QTCORE)
+
+


Property changes on: branches/avidemux_2.4_branch/cmake/UseQt4.cmake
___________________________________________________________________
Name: svn:executable
   + *

Added: branches/avidemux_2.4_branch/cmake/lavcodec.cmake
===================================================================
--- branches/avidemux_2.4_branch/cmake/lavcodec.cmake	2007-05-27 18:44:33 UTC (rev 3157)
+++ branches/avidemux_2.4_branch/cmake/lavcodec.cmake	2007-05-28 13:03:46 UTC (rev 3158)
@@ -0,0 +1,56 @@
+MACRO(SET_LAVCODEC_FLAGS)
+##
+SET(CONFIG_WMV3_DECODER 1)
+SET(CONFIG_VC1_DECODER 1)
+SET(CONFIG_RISKY 1)
+SET(CONFIG_ENCODERS 1)
+SET(CONFIG_DECODERS 1)
+SET(CONFIG_QDM2_DECODER 1)
+SET(CONFIG_MPEGAUDIO_HP 1)
+##
+SET(CONFIG_SNOW_ENCODER 1)
+SET(CONFIG_AC3_ENCODER 1)
+SET(CONFIG_MP2_ENCODER 1)
+SET(CONFIG_MPEG1VIDEO_ENCODER 1)
+SET(CONFIG_MPEG2VIDEO_ENCODER 1)
+SET(CONFIG_H263_ENCODER 1)
+SET(CONFIG_H263P_ENCODER 1)
+SET(CONFIG_MPEG4_ENCODER 1)
+SET(CONFIG_MSMPEG4V3_ENCODER 1)
+SET(CONFIG_MJPEG_ENCODER 1)
+SET(CONFIG_HUFFYUV_ENCODER 1)
+SET(CONFIG_FFVHUFF_ENCODER 1)
+SET(CONFIG_FFV1_ENCODER 1)
+##
+SET(CONFIG_SNOW_DECODER 1)
+SET(CONFIG_TSCC_DECODER 1)
+SET(CONFIG_ZLIB 1)
+SET(CONFIG_MPEG1VIDEO_DECODER 1)
+SET(CONFIG_MPEG2VIDEO_DECODER 1)
+SET(CONFIG_H263_DECODER 1)
+SET(CONFIG_H263P_DECODER 1)
+SET(CONFIG_H264_DECODER 1)
+SET(CONFIG_MPEG4_DECODER 1)
+SET(CONFIG_MSMPEG4V3_DECODER 1)
+SET(CONFIG_MSMPEG4V2_DECODER 1)
+SET(CONFIG_MJPEG_DECODER 1)
+SET(CONFIG_HUFFYUV_DECODER 1)
+SET(CONFIG_FFVHUFF_DECODER 1)
+SET(CONFIG_FFV1_DECODER 1)
+SET(CONFIG_CYUV_DECODER 1)
+SET(CONFIG_SVQ3_DECODER 1)
+SET(CONFIG_WMAV2_DECODER 1)
+SET(CONFIG_DVVIDEO_DECODER 1)
+SET(CONFIG_DVVIDEO_ENCODER 1)
+SET(CONFIG_WMV2_DECODER 1)
+SET(CONFIG_WMV1_DECODER 1)
+SET(CONFIG_MUXERS 1)
+SET(CONFIG_TG2_MUXER 1)
+SET(CONFIG_TGP_MUXER 1)
+SET(CONFIG_PSP_MUXER 1)
+SET(CONFIG_MP4_MUXER 1)
+SET(CONFIG_MOV_MUXER 1)
+SET(HAVE_THREADS 1)
+ENDMACRO(SET_LAVCODEC_FLAGS)
+##
+#

Added: branches/avidemux_2.4_branch/config.h.cmake
===================================================================
--- branches/avidemux_2.4_branch/config.h.cmake	2007-05-27 18:44:33 UTC (rev 3157)
+++ branches/avidemux_2.4_branch/config.h.cmake	2007-05-28 13:03:46 UTC (rev 3158)
@@ -0,0 +1,517 @@
+/* config.h.in.  Generated from configure.in by autoheader.  */
+
+/* MPEG2DEC */
+#cmakedefine ACCEL_DETECT
+
+/* Big endian CPU - SPARC or PowerPC */
+#cmakedefine ADM_BIG_ENDIAN
+
+/* BSD OS specific ifdef */
+#cmakedefine ADM_BSD_FAMILY
+
+/* be verbose */
+#cmakedefine ADM_DEBUG
+
+#cmakedefine HAVE_AUDIO
+
+/* Sparc workstations */
+#cmakedefine ADM_SPARC
+
+/* &quot;Build for windows 32bits&quot; */
+#cmakedefine ADM_WIN32
+
+/* &quot;ALSA is 1.0&quot; */
+#cmakedefine ALSA_1_0_SUPPORT
+
+/* &quot;use ALSA as possible audio device&quot; */
+#cmakedefine ALSA_SUPPORT
+
+/* AMR_NB */
+#cmakedefine AMR_NB
+
+/* &quot;X86_64 AMD64 assembly&quot; */
+#cmakedefine ARCH_64_BITS
+
+/* Enable PowerPC optim */
+#cmakedefine ARCH_POWERPC
+
+/* AltiVec for libmpeg2 */
+#cmakedefine ARCH_PPC
+
+/* post proc */
+#cmakedefine ARCH_X86
+
+/* &quot;X86_32 assembly&quot; */
+#cmakedefine ARCH_X86_32
+
+/* &quot;X86_64 AMD64 assembly&quot; */
+#cmakedefine ARCH_X86_64
+
+/* CONFIG_AC3_ENCODER */
+#cmakedefine CONFIG_AC3_ENCODER
+
+/* AMR_NB */
+#cmakedefine CONFIG_AMR_NB
+
+/* CONFIG_FFV1_ENCODER */
+#cmakedefine CONFIG_CYUV_DECODER
+
+/* Inform FFmpeg we are using Darwin Mac OS X */
+#cmakedefine CONFIG_DARWIN
+
+/* FFMPEG */
+#cmakedefine CONFIG_DECODERS
+
+/* CONFIG_FFV1_ENCODER */
+#cmakedefine CONFIG_DVVIDEO_DECODER
+
+/* DV encoder */
+#cmakedefine CONFIG_DVVIDEO_ENCODER
+
+/* FFMPEG */
+#cmakedefine CONFIG_ENCODERS
+
+/* CONFIG_FFV1_ENCODER */
+#cmakedefine CONFIG_FFV1_DECODER
+
+/* CONFIG_FFV1_ENCODER */
+#cmakedefine CONFIG_FFV1_ENCODER
+
+/* CONFIG_FFVHUFF_ENCODER */
+#cmakedefine CONFIG_FFVHUFF_DECODER
+
+/* CONFIG_FFVHUFF_ENCODER */
+#cmakedefine CONFIG_FFVHUFF_ENCODER
+
+/* CONFIG_H263P_ENCODER */
+#cmakedefine CONFIG_H263P_DECODER
+
+/* CONFIG_H263P_ENCODER */
+#cmakedefine CONFIG_H263P_ENCODER
+
+/* CONFIG_H263_ENCODER */
+#cmakedefine CONFIG_H263_DECODER
+
+/* CONFIG_H263_ENCODER */
+#cmakedefine CONFIG_H263_ENCODER
+
+/* CONFIG_H263P_ENCODER */
+#cmakedefine CONFIG_H264_DECODER
+
+/* CONFIG_HUFFYUV_ENCODER */
+#cmakedefine CONFIG_HUFFYUV_DECODER
+
+/* CONFIG_HUFFYUV_ENCODER */
+#cmakedefine CONFIG_HUFFYUV_ENCODER
+
+/* CONFIG_MJPEG_ENCODER */
+#cmakedefine CONFIG_MJPEG_DECODER
+
+/* CONFIG_MJPEG_ENCODER */
+#cmakedefine CONFIG_MJPEG_ENCODER
+
+/* CONFIG_MUXERS */
+#cmakedefine CONFIG_MOV_MUXER
+
+/* CONFIG_MP2_ENCODER */
+#cmakedefine CONFIG_MP2_ENCODER
+
+/* CONFIG_MUXERS */
+#cmakedefine CONFIG_MP4_MUXER
+
+/* CONFIG_MPEG1VIDEO_ENCODER */
+#cmakedefine CONFIG_MPEG1VIDEO_DECODER
+
+/* CONFIG_MPEG1VIDEO_ENCODER */
+#cmakedefine CONFIG_MPEG1VIDEO_ENCODER
+
+/* CONFIG_MPEG2VIDEO_ENCODER */
+#cmakedefine CONFIG_MPEG2VIDEO_DECODER
+
+/* CONFIG_MPEG2VIDEO_ENCODER */
+#cmakedefine CONFIG_MPEG2VIDEO_ENCODER
+
+/* CONFIG_MPEG4_ENCODER */
+#cmakedefine CONFIG_MPEG4_DECODER
+
+/* CONFIG_MPEG4_ENCODER */
+#cmakedefine CONFIG_MPEG4_ENCODER
+
+/* FFMPEG */
+#cmakedefine CONFIG_MPEGAUDIO_HP
+
+/* CONFIG_MSMPEG4V3_ENCODER */
+#cmakedefine CONFIG_MSMPEG4V2_DECODER
+
+/* CONFIG_MSMPEG4V3_ENCODER */
+#cmakedefine CONFIG_MSMPEG4V3_DECODER
+
+/* CONFIG_MSMPEG4V3_ENCODER */
+#cmakedefine CONFIG_MSMPEG4V3_ENCODER
+
+/* CONFIG_MUXERS */
+#cmakedefine CONFIG_MUXERS
+
+/* CONFIG_MUXERS */
+#cmakedefine CONFIG_PSP_MUXER
+
+/* FFMPEG */
+#cmakedefine CONFIG_QDM2_DECODER
+
+/* FFMPEG */
+#cmakedefine CONFIG_RISKY
+
+/* CONFIG_SNOW_DECODER */
+#cmakedefine CONFIG_SNOW_DECODER
+
+/* CONFIG_SNOW_ENCODER */
+#cmakedefine CONFIG_SNOW_ENCODER
+
+/* CONFIG_FFV1_ENCODER */
+#cmakedefine CONFIG_SVQ3_DECODER
+
+/* CONFIG_MUXERS */
+#cmakedefine CONFIG_TG2_MUXER
+
+/* CONFIG_MUXERS */
+#cmakedefine CONFIG_TGP_MUXER
+
+/* CONFIG_MPEG1VIDEO_ENCODER */
+#cmakedefine CONFIG_TSCC_DECODER
+
+/* FFMPEG */
+#cmakedefine CONFIG_VC1_DECODER
+
+/* CONFIG_FFV1_ENCODER */
+#cmakedefine CONFIG_WMAV2_DECODER
+
+/* CONFIG_FFV1_ENCODER */
+#cmakedefine CONFIG_WMV1_DECODER
+
+/* CONFIG_FFV1_ENCODER */
+#cmakedefine CONFIG_WMV2_DECODER
+
+/* FFMPEG */
+#cmakedefine CONFIG_WMV3_DECODER
+
+/* CONFIG_MPEG1VIDEO_ENCODER */
+#cmakedefine CONFIG_ZLIB
+
+/* &quot;Name mangling&quot; */
+#cmakedefine CYG_MANGLING
+
+/* roundup function */
+#cmakedefine EMULATE_FAST_INT
+
+/* Define to 1 if translation of program messages to the user's native
+   language is requested. */
+#cmakedefine ENABLE_NLS
+
+/* Mad */
+#cmakedefine FPM_DEFAULT
+
+/* Mad */
+#cmakedefine FPM_INTEL
+
+/* Mad */
+#cmakedefine FPM_PPC
+
+/* Mad */
+#cmakedefine FPM_SPARC
+
+/* Using GCC 2.9x.x */
+#cmakedefine GCC_2_95_X
+
+/* gettext package name */
+#cmakedefine GETTEXT_PACKAGE
+
+/* Define to 1 if you have the &lt;alsa/asoundlib.h&gt; header file. */
+#cmakedefine HAVE_ALSA_ASOUNDLIB_H
+
+/* AltiVec for mpeg2enc */
+#cmakedefine HAVE_ALTIVEC
+
+/* Enable AltiVec by default */
+#cmakedefine HAVE_ALTIVEC_H
+
+/* Define to 1 if you have the &lt;artsc.h&gt; header file. */
+#cmakedefine HAVE_ARTSC_H
+
+/* Enable AltiVec by default */
+#cmakedefine HAVE_BUILTIN_VECTOR
+
+/* Define to 1 if you have the MacOS X function CFLocaleCopyCurrent in the
+   CoreFoundation framework. */
+#cmakedefine HAVE_CFLOCALECOPYCURRENT
+
+/* Define to 1 if you have the MacOS X function CFPreferencesCopyAppValue in
+   the CoreFoundation framework. */
+#cmakedefine HAVE_CFPREFERENCESCOPYAPPVALUE
+
+/* Define if the GNU dcgettext() function is already present or preinstalled.
+   */
+#cmakedefine HAVE_DCGETTEXT
+
+/* Define to 1 if you have the &lt;dlfcn.h&gt; header file. */
+#cmakedefine HAVE_DLFCN_H
+
+/* Define to 1 if you have the &lt;dts.h&gt; header file. */
+#cmakedefine HAVE_DTS_H
+
+/* Define to 1 if you have the &lt;dts_internal.h&gt; header file. */
+#cmakedefine HAVE_DTS_INTERNAL_H
+
+/* Define to 1 if you have the &lt;faac.h&gt; header file. */
+#cmakedefine HAVE_FAAC_H
+
+/* Define to 1 if you have the &lt;faad.h&gt; header file. */
+#cmakedefine HAVE_FAAD_H
+
+/* &quot;FontConfig detected&quot; */
+#cmakedefine HAVE_FONTCONFIG
+
+/* Define if the GNU gettext() function is already present or preinstalled. */
+#cmakedefine HAVE_GETTEXT
+
+/* Define to 1 if you have the `gettimeofday' function. */
+#cmakedefine HAVE_GETTIMEOFDAY
+
+/* Define if you have the iconv() function. */
+#cmakedefine HAVE_ICONV
+
+/* Define to 1 if you have the &lt;inttypes.h&gt; header file. */
+#cmakedefine HAVE_INTTYPES_H
+
+/* Define to 1 if you have the &lt;lame/lame.h&gt; header file. */
+#cmakedefine HAVE_LAME_LAME_H
+
+/* Define to 1 if you have the `aften' library (-laften). */
+#cmakedefine HAVE_LIBAFTEN
+
+/* Define to 1 if you have the `amrnb' library (-lamrnb). */
+#cmakedefine HAVE_LIBAMRNB
+
+/* Define to 1 if you have the `asound' library (-lasound). */
+#cmakedefine HAVE_LIBASOUND
+
+/* Define to 1 if you have the `dts' library (-ldts). */
+#cmakedefine HAVE_LIBDTS
+
+/* Define to 1 if you have the `esd' library (-lesd). */
+#cmakedefine HAVE_LIBESD
+
+/* Define to 1 if you have the `faac' library (-lfaac). */
+#cmakedefine HAVE_LIBFAAC
+
+/* Define to 1 if you have the `faad' library (-lfaad). */
+#cmakedefine HAVE_LIBFAAD
+
+/* Define to 1 if you have the `fontconfig' library (-lfontconfig). */
+#cmakedefine HAVE_LIBFONTCONFIG
+
+/* Define to 1 if you have the `mp3lame' library (-lmp3lame). */
+#cmakedefine HAVE_LIBMP3LAME
+
+/* Define to 1 if you have the `png' library (-lpng). */
+#cmakedefine HAVE_LIBPNG
+
+/* Define to 1 if you have the `vorbis' library (-lvorbis). */
+#cmakedefine HAVE_LIBVORBIS
+
+/* Define to 1 if you have the `vorbisenc' library (-lvorbisenc). */
+#cmakedefine HAVE_LIBVORBISENC
+
+/* Define to 1 if you have the `x264' library (-lx264). */
+#cmakedefine HAVE_LIBX264
+
+/* Define to 1 if you have the &lt;libxml/parser.h&gt; header file. */
+#cmakedefine HAVE_LIBXML_PARSER_H
+
+/* Define to 1 if you have the `Xv' library (-lXv). */
+#cmakedefine HAVE_LIBXV
+
+/* Define to 1 if you have the `xvidcore' library (-lxvidcore). */
+#cmakedefine HAVE_LIBXVIDCORE
+
+/* roundup function */
+#cmakedefine HAVE_LRINTF
+
+/* Use malloc.h */
+#cmakedefine HAVE_MALLOC_H
+
+/* Define to 1 if you have the &lt;malloc/malloc.h&gt; header file. */
+#cmakedefine HAVE_MALLOC_MALLOC_H
+
+/* Define to 1 if you have the &lt;memory.h&gt; header file. */
+#cmakedefine HAVE_MEMORY_H
+
+/* post proc */
+#cmakedefine HAVE_MMX
+
+/* Define to 1 if you have the &lt;stdint.h&gt; header file. */
+#cmakedefine HAVE_STDINT_H
+
+/* Define to 1 if you have the &lt;stdlib.h&gt; header file. */
+#cmakedefine HAVE_STDLIB_H
+
+/* Define to 1 if you have the &lt;strings.h&gt; header file. */
+#cmakedefine HAVE_STRINGS_H
+
+/* Define to 1 if you have the &lt;string.h&gt; header file. */
+#cmakedefine HAVE_STRING_H
+
+/* Define to 1 if you have the &lt;sys/shm.h&gt; header file. */
+#cmakedefine HAVE_SYS_SHM_H
+
+/* Define to 1 if you have the &lt;sys/stat.h&gt; header file. */
+#cmakedefine HAVE_SYS_STAT_H
+
+/* Define to 1 if you have the &lt;sys/types.h&gt; header file. */
+#cmakedefine HAVE_SYS_TYPES_H
+
+/* HAVE_THREADS */
+#cmakedefine HAVE_THREADS
+
+/* Define to 1 if you have the &lt;unistd.h&gt; header file. */
+#cmakedefine HAVE_UNISTD_H
+
+/* Define to 1 if you have the &lt;X11/extensions/XShm.h&gt; header file. */
+#cmakedefine HAVE_X11_EXTENSIONS_XSHM_H
+
+/* Define to 1 if you have the &lt;X11/extensions/Xvlib.h&gt; header file. */
+#cmakedefine HAVE_X11_EXTENSIONS_XVLIB_H
+
+/* stricter prototyping */
+#cmakedefine ICONV_NEED_CONST
+
+/* &quot;SSE on Cywin&quot; */
+#cmakedefine MEMALIGN_HACK
+
+/* use classing FAAD support */
+#cmakedefine OLD_FAAD_PROTO
+
+/* OSS detected */
+#cmakedefine OSS_SUPPORT
+
+/* Name of package */
+#cmakedefine PACKAGE
+
+/* Define to the address where bug reports for this package should be sent. */
+#cmakedefine PACKAGE_BUGREPORT
+
+/* Define to the full name of this package. */
+#cmakedefine PACKAGE_NAME
+
+/* Define to the full name and version of this package. */
+#cmakedefine PACKAGE_STRING
+
+/* Define to the one symbol short name of this package. */
+#cmakedefine PACKAGE_TARNAME
+
+/* Define to the version of this package. */
+#cmakedefine PACKAGE_VERSION
+
+/* &quot;Let FFmpeg decide which is faster&quot; */
+#cmakedefine RUNTIME_CPUDETECT
+
+/* Define to 1 if you have the ANSI C header files. */
+#cmakedefine STDC_HEADERS
+
+/* use liba52 */
+#cmakedefine USE_AC3
+
+/* use Aften AC3 encoder */
+#cmakedefine USE_AFTEN
+
+/* Use Aften 0.05 or earlier */
+#cmakedefine USE_AFTEN_05
+
+/* Use Aften 0.06 */
+#cmakedefine USE_AFTEN_06
+
+/* AltiVec for mpeg2enc */
+#cmakedefine USE_ALTIVEC
+
+/* Tell avidemux to use libamrnb */
+#cmakedefine USE_AMR_NB
+
+/* &quot;aRts detected&quot; */
+#cmakedefine USE_ARTS
+
+/* ESD detected */
+#cmakedefine USE_ESD
+
+/* &quot;Use faac audio enccoder&quot; */
+#cmakedefine USE_FAAC
+
+/* FAAD2 detected */
+#cmakedefine USE_FAAD
+
+/* FFmpeg */
+#cmakedefine USE_FFMPEG
+
+/* &quot;FontConfig detected&quot; */
+#cmakedefine USE_FONTCONFIG
+
+/* &quot;FreeType2 detected&quot; */
+#cmakedefine USE_FREETYPE
+
+/* &quot;use late binding of selected libraries&quot; */
+#cmakedefine USE_LATE_BINDING
+
+/* &quot;libdca detected&quot; */
+#cmakedefine USE_LIBDCA
+
+/* Libxml2 is available */
+#cmakedefine USE_LIBXML2
+
+/* MJPEG */
+#cmakedefine USE_MJPEG
+
+/* use libmad */
+#cmakedefine USE_MP3
+
+/* libpng is available */
+#cmakedefine USE_PNG
+
+/* SDL detected */
+#cmakedefine USE_SDL
+
+/* Vorbis detected */
+#cmakedefine USE_VORBIS
+
+/* use x264 encoder */
+#cmakedefine USE_X264
+
+/* XVideo detected */
+#cmakedefine USE_XV
+
+/* use Xvid 1.x API */
+#cmakedefine USE_XVID_4
+
+/* use Xvid 0.9 API */
+#cmakedefine USE_XX_XVID
+
+/* Version number of package */
+#cmakedefine VERSION
+
+/* Big endian CPU - SPARC or PowerPC */
+#cmakedefine WORDS_BIGENDIAN
+
+/* Define to 1 if the X Window System is missing or not being used. */
+#cmakedefine X_DISPLAY_MISSING
+
+/* &quot;&quot; */
+#cmakedefine fseeko
+
+/* &quot;&quot; */
+#cmakedefine ftello
+
+/* &quot;rindex does not exist on Cygwin&quot; */
+#cmakedefine index
+
+/* roundup function */
+#cmakedefine restrict
+
+/* &quot;rindex does not exist on Cygwin&quot; */
+#cmakedefine rindex


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000452.html">[Avidemux-svn-commit] r3157 - in branches/avidemux_2.4_branch: . avidemux avidemux/ADM_audio avidemux/ADM_audiocodec avidemux/ADM_audiodevice avidemux/ADM_audiofilter avidemux/ADM_codecs avidemux/ADM_colorspace avidemux/ADM_editor avidemux/ADM_encoder avidemux/ADM_filter avidemux/ADM_inputs avidemux/ADM_inputs/ADM_asf avidemux/ADM_inputs/ADM_avsproxy avidemux/ADM_inputs/ADM_h263 avidemux/ADM_inputs/ADM_inpics avidemux/ADM_inputs/ADM_matroska avidemux/ADM_inputs/ADM_mp4 avidemux/ADM_inputs/ADM_mpegdemuxer avidemux/ADM_inputs/ADM_nuv avidemux/ADM_inputs/ADM_ogm avidemux/ADM_inputs/ADM_openDML avidemux/ADM_libraries avidemux/ADM_ocr avidemux/ADM_osSupport avidemux/ADM_requant avidemux/ADM_script avidemux/ADM_toolkit avidemux/ADM_userInterfaces avidemux/ADM_userInterfaces/ADM_NONE avidemux/ADM_userInterfaces/ADM_NONE/ADM_dialog avidemux/ADM_userInterfaces/ADM_NONE/ADM_dialogFactory avidemux/ADM_userInterfaces/ADM_NONE/ADM_filters avidemux/ADM_userInterfaces/ADM_NONE/ADM_gui2 avidemux/ADM_use! rInterfaces/ADM_commonUI avidemux/ADM_video avidemux/ADM_videoFilter po
</A></li>
	<LI>Next message: <A HREF="000454.html">[Avidemux-svn-commit] r3159 - in branches/avidemux_2.4_branch: .	avidemux avidemux/ADM_editor avidemux/ADM_inputs	avidemux/ADM_inputs/ADM_asf avidemux/ADM_inputs/ADM_nuv	avidemux/ADM_libraries	avidemux/ADM_libraries/ADM_lavcodec/i386 avidemux/ADM_ocr	avidemux/ADM_userInterfaces	avidemux/ADM_userInterfaces/ADM_NONE/ADM_dialog	avidemux/ADM_userInterfaces/ADM_NONE/ADM_dialogFactory	avidemux/ADM_userInterfaces/ADM_NONE/ADM_filters	avidemux/ADM_userInterfaces/ADM_NONE/ADM_gui2	avidemux/ADM_userInterfaces/ADM_commonUI avidemux/ADM_video	avidemux/ADM_videoFilter
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#453">[ date ]</a>
              <a href="thread.html#453">[ thread ]</a>
              <a href="subject.html#453">[ subject ]</a>
              <a href="author.html#453">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">More information about the Avidemux-svn-commit
mailing list</a><br>
</body></html>
