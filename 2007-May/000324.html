<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Avidemux-svn-commit] r3013 - in	branches/avidemux_2.4_branch/avidemux/ADM_inputs: . ADM_mp4
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/avidemux-svn-commit/2007-May/index.html" >
   <LINK REL="made" HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r3013%20-%20in%0A%09branches/avidemux_2.4_branch/avidemux/ADM_inputs%3A%20.%20ADM_mp4&In-Reply-To=%3C200705031442.l43EgW1m009469%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000323.html">
   <LINK REL="Next"  HREF="000325.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Avidemux-svn-commit] r3013 - in	branches/avidemux_2.4_branch/avidemux/ADM_inputs: . ADM_mp4</H1>
    <B>mean at BerliOS</B> 
    <A HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r3013%20-%20in%0A%09branches/avidemux_2.4_branch/avidemux/ADM_inputs%3A%20.%20ADM_mp4&In-Reply-To=%3C200705031442.l43EgW1m009469%40sheep.berlios.de%3E"
       TITLE="[Avidemux-svn-commit] r3013 - in	branches/avidemux_2.4_branch/avidemux/ADM_inputs: . ADM_mp4">mean at mail.berlios.de
       </A><BR>
    <I>Thu May  3 16:42:32 CEST 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="000323.html">[Avidemux-svn-commit] r3012 -	branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialogFactory
</A></li>
        <LI>Next message: <A HREF="000325.html">[Avidemux-svn-commit] r3016 -	branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#324">[ date ]</a>
              <a href="thread.html#324">[ thread ]</a>
              <a href="subject.html#324">[ subject ]</a>
              <a href="author.html#324">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: mean
Date: 2007-05-03 16:42:31 +0200 (Thu, 03 May 2007)
New Revision: 3013

Added:
   branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mp4/
   branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mp4/ADM_atom.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mp4/ADM_atom.h
   branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mp4/ADM_infoextractor.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mp4/ADM_mp4.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mp4/ADM_mp4.h
   branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mp4/ADM_mp4audio.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mp4/Makefile.am
Log:
new mp4 parser

Added: branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mp4/ADM_atom.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mp4/ADM_atom.cpp	2007-05-03 14:40:06 UTC (rev 3012)
+++ branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mp4/ADM_atom.cpp	2007-05-03 14:42:31 UTC (rev 3013)
@@ -0,0 +1,192 @@
+/***************************************************************************
+                          ADM_Atom  -  description
+                             -------------------
+
+	Helper class to deal with atom
+
+    begin                : Mon Jul 21 2003
+    copyright            : (C) 2001 by mean
+    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include &quot;config.h&quot;
+
+#include &lt;stdio.h&gt;
+#include &lt;stdlib.h&gt;
+
+#include &lt;string.h&gt;
+
+#include &quot;math.h&quot;
+#include &lt;ADM_assert.h&gt;
+#include &quot;default.h&quot;
+#include &quot;ADM_editor/ADM_Video.h&quot;
+
+
+#include &quot;fourcc.h&quot;
+#include &quot;ADM_3gp/ADM_atom.h&quot;
+//#define _3G_LOGO
+#define aprintf printf
+//#define ATOM_DEBUG
+adm_atom::adm_atom(adm_atom *atom)
+{
+	_fd=atom-&gt;_fd;
+	_atomStart=ftell(_fd);
+	_atomSize=read32();
+	_atomFCC=read32();
+	// Gross hack for some (buggy ?) movie
+	if(!_atomSize)
+	{
+		printf(&quot;3GP:Workaround: detected wrong sized atom!\nTrying to continue\n&quot;);
+		_atomStart+=4;
+		_atomSize-=4;
+		fseek(_fd,_atomStart,SEEK_SET);
+		_atomSize=read32();
+		_atomFCC=read32();
+	}
+#ifdef ATOM_DEBUG
+	dumpAtom();
+#endif
+
+}
+adm_atom::adm_atom(FILE *fd )
+{
+uint32_t orgpos;
+	_fd=fd;
+        orgpos=ftello(fd);
+	fseek(_fd,0,SEEK_END);
+	_atomFCC=fourCC::get((uint8_t *)&quot;MOVI&quot;);
+	_atomSize=ftell(_fd);//-orgpos;
+
+	fseek(_fd,orgpos,SEEK_SET);
+	_atomStart=0;
+#ifdef ATOM_DEBUG
+	dumpAtom();
+#endif
+#ifdef _3G_LOGO
+        printf(&quot;Starting at %x  atom &quot;,_atomStart);
+        fourCC::printBE(_atomFCC);
+        printf(&quot;\n&quot;);
+#endif
+
+}
+uint8_t adm_atom::skipBytes( uint32_t nb )
+{
+uint32_t pos;
+	fseek(_fd,nb,SEEK_CUR);
+	pos=ftell(_fd);
+	if(pos&gt;_atomStart+_atomSize+1) ADM_assert(0);	
+	return 1;
+}
+
+uint8_t adm_atom::read( void )
+{
+	uint8_t a1;
+
+		a1=fgetc(_fd);
+	return a1;
+
+}
+
+uint16_t adm_atom::read16( void )
+{
+	uint8_t a1,a2;
+
+		a1=fgetc(_fd);
+		a2=fgetc(_fd);
+	return (a1&lt;&lt;8)+(a2);
+
+}
+
+
+uint32_t adm_atom::read32( void )
+{
+	uint8_t a1,a2,a3,a4;
+
+		a1=fgetc(_fd);
+		a2=fgetc(_fd);
+		a3=fgetc(_fd);
+		a4=fgetc(_fd);
+	return (a1&lt;&lt;24)+(a2&lt;&lt;16)+(a3&lt;&lt;8)+(a4);
+
+}
+
+uint32_t adm_atom::getFCC( void )
+{
+	return _atomFCC;
+}
+uint32_t adm_atom::getSize( void )
+{
+	return _atomSize-8;
+}
+uint32_t adm_atom::getRemainingSize( void )
+{
+        int64_t pos=ftello(_fd);
+        
+        return _atomStart+_atomSize-pos;
+}
+
+uint8_t adm_atom::readPayload( uint8_t *whereto, uint32_t rd)
+{
+	uint32_t pos;
+
+	pos=ftell(_fd);
+	if(pos+rd&gt;_atomSize+_atomStart)
+	{
+		printf(&quot;\n Going out of atom's bound!! (%ld  / %ld )\n&quot;,pos+rd,_atomSize+_atomStart);
+		dumpAtom();
+		exit(0);
+	}
+	uint32_t i;
+	i=fread(whereto,rd,1,_fd);
+	if(i!=1)
+	{
+		printf(&quot;\n oops asked %lu got %lu \n&quot;,rd,i);
+	return 0;
+	}
+	return 1;
+
+}
+uint8_t adm_atom::dumpAtom( void )
+{
+
+	aprintf(&quot;Atom :&quot;);
+	fourCC::print(_atomFCC);
+	aprintf(&quot; starting at pos %lu, size %lu\n&quot;,_atomStart,_atomSize);
+	return 1;
+
+}
+
+uint8_t adm_atom::skipAtom( void )
+{
+	fseek(_fd,_atomStart+_atomSize,SEEK_SET);
+#ifdef _3G_LOGO
+        printf(&quot;Branching to %x ending atom &quot;,_atomStart+_atomSize);
+        fourCC::printBE(_atomFCC);
+        printf(&quot;\n&quot;);
+#endif
+	return 1;
+
+
+}
+uint8_t adm_atom::isDone( void )
+{
+	uint32_t pos=ftell(_fd);
+
+	if(pos&gt;=(_atomStart+_atomSize)) return 1;
+	return 0;
+
+}
+
+
+
+
+//EOF
+

Added: branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mp4/ADM_atom.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mp4/ADM_atom.h	2007-05-03 14:40:06 UTC (rev 3012)
+++ branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mp4/ADM_atom.h	2007-05-03 14:42:31 UTC (rev 3013)
@@ -0,0 +1,49 @@
+/***************************************************************************
+                          ADM_Aton  -  description
+                             -------------------
+
+	Helper class to deal with atom
+
+    begin                : Mon Jul 21 2003
+    copyright            : (C) 2001 by mean
+    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#ifndef _ADM_ATOM
+#define _ADM_ATOM
+class adm_atom
+{
+private:
+		FILE 		*_fd;
+		uint32_t	_atomStart,_atomSize;
+		uint32_t	_atomFCC;
+		uint8_t		dumpAtom( void );
+public:
+				adm_atom(FILE *fd);
+				adm_atom(FILE *fd,uint8_t full);
+				adm_atom(adm_atom *atom);
+		uint8_t	        skipAtom( void );
+                uint32_t        getStartPos(void) {return _atomStart;}
+		uint32_t	getFCC( void );
+		uint32_t	getSize( void );
+                uint32_t        getRemainingSize( void );
+		uint8_t		readPayload( uint8_t *whereto, uint32_t rd );
+		uint8_t		isDone(void );
+		uint8_t		skipBytes(uint32_t nb );
+
+		uint32_t	read32( void );
+		uint16_t	read16( void );
+		uint8_t	read( void );
+
+
+};
+
+#endif

Added: branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mp4/ADM_infoextractor.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mp4/ADM_infoextractor.cpp	2007-05-03 14:40:06 UTC (rev 3012)
+++ branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mp4/ADM_infoextractor.cpp	2007-05-03 14:42:31 UTC (rev 3013)
@@ -0,0 +1,433 @@
+/***************************************************************************
+                          ADM_infoextractor
+                             -------------------
+           - extract additionnal info from header (mp4/h263)                  
+**************************************************************************/
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include &quot;config.h&quot;
+
+#include &lt;stdio.h&gt;
+#include &lt;stdlib.h&gt;
+
+#include &lt;string.h&gt;
+
+#include &quot;math.h&quot;
+
+#include &lt;ADM_assert.h&gt;
+#include &quot;default.h&quot;
+#include &quot;ADM_editor/ADM_Video.h&quot;
+
+
+#include &quot;fourcc.h&quot;
+#include &quot;ADM_3gp/ADM_3gp.h&quot;
+#include &quot;ADM_toolkit/toolkit.hxx&quot;
+
+#include &quot;ADM_osSupport/ADM_debugID.h&quot;
+#define MODULE_NAME MODULE_3GP
+#include &quot;ADM_osSupport/ADM_debug.h&quot;
+
+extern &quot;C&quot;
+{
+#include &quot;common.h&quot;
+#include &quot;bswap.h&quot;
+#define INT_MAX (0x7FFFFFFF)
+#include &quot;ADM_lavcodec/bitstream.h&quot;
+#include &quot;ADM_lavcodec/golomb.h&quot;
+}
+static void refineH264FrameType(uint8_t *head,uint8_t *tail,uint32_t *flags);
+/*
+    Extract width &amp; height from vol header passed as arg
+
+
+*/
+uint8_t extractMpeg4Info(uint8_t *data,uint32_t dataSize,uint32_t *w,uint32_t *h,uint32_t *time_inc)
+{
+    // Search startcode
+    uint8_t b;
+    uint32_t idx=0;
+    uint32_t mw,mh;
+    uint32_t timeVal;
+    
+    //mixDump(data,dataSize);
+    //printf(&quot;\n&quot;);
+    while(1)
+    {
+        uint32_t startcode=0xffffffff;
+        while(dataSize&gt;2)
+        {
+            startcode=(startcode&lt;&lt;8)+data[idx];
+            idx++;
+            dataSize--;
+            if((startcode&amp;0xffffff)==1) break;
+        }
+        if(dataSize&gt;2)
+        {
+            //printf(&quot;Startcodec:%x\n&quot;,data[idx]);
+            if((data[idx]&amp;0xF0)==0x20) //VOL start
+            {
+                dataSize--;
+                idx++;
+#if 0
+                printf(&quot;VOL Header:\n&quot;);
+
+                if(dataSize&lt;16)
+                {
+                  mixDump(data+idx,dataSize);printf(&quot;\n&quot;);
+                }
+                else
+                {
+                  mixDump(data+idx,16);printf(&quot;\n&quot;);
+                }
+#endif
+                // Here we go !
+                GetBitContext s;
+                init_get_bits( &amp;s,data+idx, dataSize*8);
+                //
+                skip_bits1(&amp;s); // Random access
+                skip_bits(&amp;s,8); // Obj type indication
+                if(get_bits(&amp;s,1)) // VO od 
+                {
+                      skip_bits(&amp;s,4); // Ver
+                      skip_bits(&amp;s,3);  // Priority
+                }
+                if(get_bits(&amp;s,4)==15) // custom A/R
+                {
+                      skip_bits(&amp;s,8);
+                      skip_bits(&amp;s,8);
+                }
+                if(get_bits(&amp;s,1)) // Vol control param
+                {
+                      skip_bits(&amp;s,2);   //Chroma
+                      skip_bits(&amp;s,1);   // Low delay
+                      if(get_bits(&amp;s,1)) // VBV Info
+                      {
+                        skip_bits(&amp;s,16);
+                        skip_bits(&amp;s,16);
+                        skip_bits(&amp;s,16);
+                        skip_bits(&amp;s,15);
+                        skip_bits(&amp;s,16);
+                      }
+                  }
+                 skip_bits(&amp;s,2); //  Shape
+                 skip_bits(&amp;s,1); //  Marker
+                 timeVal=get_bits(&amp;s,16); // Time increment
+                 *time_inc = av_log2(timeVal - 1) + 1;
+                 if (*time_inc &lt; 1)
+                    *time_inc = 1;
+                 skip_bits(&amp;s,1); //  Marker
+                 if(get_bits(&amp;s,1)) // Fixed vop rate, compute how much bits needed
+                 {
+                     get_bits(&amp;s, *time_inc);
+                 }
+                  skip_bits(&amp;s,1); //  Marker
+                  mw=get_bits(&amp;s,13);
+                  skip_bits(&amp;s,1); //  Marker
+                  mh=get_bits(&amp;s,13);
+                // /Here we go
+                //printf(&quot;%d x %d \n&quot;,mw,mh);
+                *h=mh;
+                *w=mw;
+                return 1;;
+                // Free get bits ?
+                // WTF ?
+            }
+            continue;
+        }
+        else
+        {
+            printf(&quot;No more startcode\n&quot;);
+            // Free get bits ?
+            return 0;
+            
+        }
+    }
+    
+    return 0;
+}
+/**
+    \fn extractVopInfo
+    \brief extract info from vop : Vop type, module time base, time inc
+    
+    Warning this function expects data to start AFTER startcode, contrarily to other functions here!
+*/
+
+uint8_t extractVopInfo(uint8_t *data, uint32_t len,uint32_t timeincbits,uint32_t *vopType,uint32_t *modulo, uint32_t *time_inc,uint32_t *vopcoded)
+{
+   GetBitContext s;
+   int vop;
+   uint32_t vp,tinc;
+           init_get_bits( &amp;s,data, len*8);
+           vop=get_bits(&amp;s,2);
+           switch(vop)
+           {
+             case 0: vp=AVI_KEY_FRAME;break;
+             case 1: vp=0;break;
+             case 2: vp=AVI_B_FRAME;break;
+             case 3: vp=0;break;  // D FRAME ????
+             default:
+                printf(&quot;Unknown vop type :%d\n&quot;,vop);
+                return 0;
+           }
+           /* Read modulo */
+           int imodulo=0;
+           while (get_bits1(&amp;s) != 0)
+                  imodulo++;
+           if(!get_bits1(&amp;s))
+           {
+              printf(&quot;Wrong marker1\n&quot;);
+              return 0; 
+           }
+           
+           /* Read time */
+           tinc=get_bits(&amp;s,timeincbits);
+           /* Marker */
+            if(!get_bits1(&amp;s))
+           {
+              printf(&quot;Wrong marker2\n&quot;);
+              return 0; 
+           }
+           /* Vop coded */
+           *modulo=imodulo;
+           *vopcoded=get_bits1(&amp;s);
+           *vopType=vp;
+           *time_inc=tinc;
+           return 1;
+}
+
+/*
+        Extract H263 width &amp; height from header
+
+*/
+uint8_t extractH263Info(uint8_t *data,uint32_t dataSize,uint32_t *w,uint32_t *h)
+{
+uint32_t val;
+                GetBitContext s;
+                init_get_bits( &amp;s,data, dataSize*8);
+                
+                 mixDump(data,10);
+                 val=get_bits(&amp;s,16);
+                 if(val)
+                 {
+                    printf(&quot;incorrect H263 header sync\n&quot;);
+                    return 0;
+                 }
+                 val=get_bits(&amp;s,6);
+                 if(val!=0x20)
+                 {
+                    printf(&quot;incorrect H263 header sync (2)\n&quot;);
+                    return 0;
+                 }
+                 //
+                 skip_bits(&amp;s,8); // timestamps in 30 fps tick
+                 skip_bits(&amp;s,1); // Marker
+                 skip_bits(&amp;s,1); // Id
+                 skip_bits(&amp;s,1); // Split
+                 skip_bits(&amp;s,1); // Document Camera indicator
+                 skip_bits(&amp;s,1); // Full Picture Freeze Release
+                 val=get_bits(&amp;s,3);
+                 switch(val)
+                 {
+                   
+                    case 1: *w=128;*h=96;return 1;break;
+                    case 2: *w=176;*h=144;return 1;break;
+                    case 6:
+                    case 7:
+                            printf(&quot;H263+:Todo\n&quot;);
+                    default:
+                        printf(&quot;Invalid format\n&quot;);return 0;break;
+                 }
+                 return 0;
+}
+/**
+    \fn extractSPSInfo
+    \brief Extract info from H264 SPS
+    See 7.3.2.1 of 14496-10
+*/
+uint8_t extractSPSInfo(uint8_t *data, uint32_t len,uint32_t *wwidth,uint32_t *hheight)
+{
+   GetBitContext s;
+   
+   uint32_t profile,constraint,level,pic_order_cnt_type,w,h;
+   
+           init_get_bits( &amp;s,data, len*8);
+            
+           profile=get_bits(&amp;s,8);
+           constraint=get_bits(&amp;s,8)&gt;&gt;5;
+           level=get_bits(&amp;s,8);
+           
+           if(profile&gt;100) // ?? Borrowed from H264.C/FFMPEG
+           {
+              printf(&quot;Warning : High profile\n&quot;);
+              if(get_ue_golomb(&amp;s) == 3) //chroma_format_idc
+                get_bits1(&amp;s);  //residual_color_transform_flag
+            get_ue_golomb(&amp;s);  //bit_depth_luma_minus8
+            get_ue_golomb(&amp;s);  //bit_depth_chroma_minus8
+            get_bits1(&amp;s);
+           }    // /??
+           
+           get_ue_golomb(&amp;s); // Seq parameter set id
+           get_ue_golomb(&amp;s); // log2_max_frame_num_minus4
+           if(!(pic_order_cnt_type=get_ue_golomb(&amp;s))) // pic_order_cnt_type
+           {
+              get_ue_golomb(&amp;s); //log2_max_pic_order_cnt_lsb_minus4
+           }else
+           {
+             if(pic_order_cnt_type==1)
+             {
+                 get_bits1(&amp;s);   //delta_pic_order_always_zero_flag
+                 get_se_golomb(&amp;s);   //offset_for_non_ref_pic
+                 get_se_golomb(&amp;s);  // offset_for_top_to_bottom_field
+                 int i=get_ue_golomb(&amp;s);  //num_ref_frames_in_pic_order_cnt_cycle
+
+                 for(int j=0;j&lt;i;j++)
+                 {
+                      get_se_golomb(&amp;s);
+                 }
+             }else 
+             {
+               printf(&quot;Error in SPS\n&quot;);
+               return 0;
+             }
+           }
+           get_ue_golomb(&amp;s);     //num_ref_frames
+           get_bits1(&amp;s);         // gaps_in_frame_num_value_allowed_flag
+           w=get_ue_golomb(&amp;s);   //pic_width_in_mbs_minus1
+           h=get_ue_golomb(&amp;s);   //pic_height_in_mbs_minus1
+           printf(&quot;%d\n&quot;,w); 
+           printf(&quot;%d\n&quot;, h); 
+            *wwidth=(w+1)*16;
+            *hheight=(h+1)*16*2; /* Fixme : frame_mbs_only_flag in slice header!! */
+
+           
+           return 1;
+}
+/**
+      \fn extractH264FrameType
+      \brief return frametype in flags (KEY_FRAME or 0). To be used only with  mkv/mp4 nal type (i.e. no startcode)
+      
+*/
+uint8_t extractH264FrameType(uint32_t nalSize,uint8_t *buffer,uint32_t len,uint32_t *flags)
+{
+  uint8_t *head=buffer, *tail=buffer+len;
+  uint8_t stream;
+#define NAL_NON_IDR       1
+#define NAL_IDR           5
+  
+  uint32_t val,hnt;  
+  
+// FIXME :  no startcode only !
+  
+  while(head+4&lt;tail)
+  {
+    
+              uint32_t length=(head[0]&lt;&lt;24) + (head[1]&lt;&lt;16) +(head[2]&lt;&lt;8)+(head[3]);
+              if(length&gt;len||length&lt;6)
+              {
+                printf(&quot;Warning , incomplete nal (%u/%u),(%0x/%0x)\n&quot;,length,len,length,len);
+                *flags=0;
+                return 0;
+              }
+              head+=4; // Skip nal lenth
+              length-=4;
+              stream=*(head++)&amp;0x1F;
+                switch(stream)
+                {
+                  case NAL_IDR: 
+                                  *flags=AVI_KEY_FRAME;
+                                  
+                                  return 1;
+                                  break; 
+                  case NAL_NON_IDR: 
+                                  refineH264FrameType(head,tail,flags);
+                                  return 1;
+                                  break;
+                  default:
+                          printf(&quot;??0x%x\n&quot;,stream);
+                          head+=length-5;
+                          continue;
+                }
+  }
+  printf(&quot;No stream\n&quot;);
+  return 0;
+}
+
+/**
+      \fn extractH264FrameType_startCode
+      \brief return frametype in flags (KEY_FRAME or 0). To be used only with  avi / mpeg TS nal type (i.e. with startcode)
+      
+*/
+uint8_t extractH264FrameType_startCode(uint32_t nalSize,uint8_t *buffer,uint32_t len,uint32_t *flags)
+{
+  uint8_t *head=buffer, *tail=buffer+len;
+  uint8_t stream;
+#define NAL_NON_IDR       1
+#define NAL_IDR           5
+#define NAL_SEI           6
+
+  uint32_t val,hnt;  
+  
+// FIXME :  no startcode only !
+  
+  while(head+4&lt;tail)
+  {
+          // Search startcode
+      
+                hnt=(head[0]&lt;&lt;24) + (head[1]&lt;&lt;16) +(head[2]&lt;&lt;8)+(head[3]);
+                head+=4;
+                while((hnt!=1) &amp;&amp; head&lt;tail)
+                {
+
+                        hnt&lt;&lt;=8;
+                        val=*head++;
+                        hnt+=val;
+                }
+                if(head&gt;=tail) break;
+                stream=*(head++) &amp;0x1f;
+                switch(stream)
+                {
+                  case NAL_IDR: 
+                                  *flags=AVI_KEY_FRAME;
+                                 // printf(&quot;IDR\n&quot;);
+                                  return 1;
+                                  break; 
+                  case NAL_NON_IDR: 
+                                  refineH264FrameType(head,tail,flags);
+                                  return 1;
+                                  break;
+                  default:
+                          printf(&quot;??0x%x\n&quot;,stream);
+                          continue;
+                }
+  }
+  printf(&quot;No stream\n&quot;);
+  return 0;
+}
+/**
+    \fn refineH264FrameType
+    \brief Try to detect B slice, warning the stream is not escaped!
+*/
+void refineH264FrameType(uint8_t *head,uint8_t *tail,uint32_t *flags)
+{
+GetBitContext s;
+uint32_t sliceType;
+            *flags=0;
+            init_get_bits(&amp;s,head, (tail-head)*8);
+            get_ue_golomb(&amp;s);
+            sliceType= get_ue_golomb(&amp;s);
+            if(sliceType &gt; 9) 
+            {
+              printf(&quot;Weird Slice %d\n&quot;,sliceType);
+              return ;
+            }
+            if(sliceType &gt; 4)
+                sliceType -= 5;
+            if(sliceType==3) *flags=AVI_B_FRAME;  
+}
+//EOF

Added: branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mp4/ADM_mp4.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mp4/ADM_mp4.cpp	2007-05-03 14:40:06 UTC (rev 3012)
+++ branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mp4/ADM_mp4.cpp	2007-05-03 14:42:31 UTC (rev 3013)
@@ -0,0 +1,1656 @@
+/***************************************************************************
+                          ADM_3gpp.cpp  -  description
+                             -------------------
+	
+		Read quicktime/mpeg4 file format found in 3gpp file.
+		They are limited to SQCIF/QCIF video size and can
+		only contains
+			video : h263 or mpeg4 
+			audio : AMR or AAC
+
+
+		For the mpeg4, the VOL headers are stored in esds atom
+		and not in the first image
+		Idem for MJPG and SVQ3
+
+		The usual tree structure of a 3gp file is
+
+		- ftyp
+		- mdat
+		- moov
+			xxx
+			trak
+				tkhd (duration / ...)
+			mdia
+				hdlr (type)
+				minf
+					stsd header for audio/video
+					stbl index to datas
+
+	We ignore other chunk as they are not vital for our aim
+	and just keep moov/mdia/minf/stsd/stbl stuff
+
+Generic
+*********
+<A HREF="http://developer.apple.com/documentation/QuickTime/QTFF/QTFFChap2/chapter_3_section_5.html#//apple_ref/doc/uid/DontLinkBookID_69-CH204-BBCJEIIA">http://developer.apple.com/documentation/QuickTime/QTFF/QTFFChap2/chapter_3_section_5.html#//apple_ref/doc/uid/DontLinkBookID_69-CH204-BBCJEIIA</A>
+
+version 2 media descriptor :
+****************************** <A HREF="http://developer.apple.com/documentation/QuickTime/Conceptual/QT7Win_Update_Guide/Chapter03/chapter_3_section_1.html#//apple_ref/doc/uid/TP40002476-CH314-BBCDGGBB">http://developer.apple.com/documentation/QuickTime/Conceptual/QT7Win_Update_Guide/Chapter03/chapter_3_section_1.html#//apple_ref/doc/uid/TP40002476-CH314-BBCDGGBB</A>
+
+
+
+    begin                : Tue Jul  2003
+    copyright            : (C) 2003/2006 by mean
+    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include &quot;config.h&quot;
+
+#include &lt;stdio.h&gt;
+#include &lt;stdlib.h&gt;
+
+#include &lt;string.h&gt;
+
+#include &quot;math.h&quot;
+
+#include &lt;ADM_assert.h&gt;
+#include &quot;default.h&quot;
+#include &quot;ADM_editor/ADM_Video.h&quot;
+
+
+#include &quot;fourcc.h&quot;
+#include &quot;ADM_3gp/ADM_3gp.h&quot;
+#include &quot;ADM_toolkit/toolkit.hxx&quot;
+#include &quot;ADM_codecs/ADM_codec.h&quot;
+
+#include &quot;ADM_video/ADM_videoInfoExtractor.h&quot;
+
+#include &quot;ADM_osSupport/ADM_debugID.h&quot;
+#define MODULE_NAME MODULE_3GP
+#include &quot;ADM_osSupport/ADM_debug.h&quot;
+
+//#define _3GP_VERBOSE
+#define MAX_CHUNK_SIZE (3*1024)
+// 14496-1 / 8.2.1
+typedef enum MP4_Tag
+{
+	Tag_InitialObjDesc	=0x02,
+	Tag_ES_Desc		=0x03,
+	Tag_DecConfigDesc 	=0x04,
+	Tag_DecSpecificInfo 	=0x05
+};
+uint32_t ADM_UsecFromFps1000(uint32_t fps1000);
+//****************************************************
+_3gpTrack::_3gpTrack(void)
+{
+    extraDataSize=0;
+    extraData=NULL;
+    index=NULL;
+    nbIndex=0;
+    id=0;
+    memset(&amp;_rdWav,0,sizeof(_rdWav));
+
+}
+_3gpTrack::~_3gpTrack()
+{
+    if(extraData) delete [] extraData;
+    if(index)   delete [] index;
+ 
+    index=NULL;
+    extraData=NULL;
+    
+}
+//****************************************************
+uint8_t _3GPHeader::setFlag(uint32_t frame,uint32_t flags){
+    UNUSED_ARG(frame);
+    UNUSED_ARG(flags);
+    
+    VDEO.index[frame].intra=flags;
+    return 0;
+}
+
+uint32_t _3GPHeader::getFlags(uint32_t frame,uint32_t *flags){
+	if(frame&gt;= (uint32_t)_videostream.dwLength) return 0;
+#warning FIXME : UGLY
+	if(fourCC::check(_videostream.fccHandler,(uint8_t *)&quot;MJPG&quot;)
+        || isDVCompatible(_videostream.fccHandler)) // Fixme should be done on the fly
+	{
+		*flags=AVI_KEY_FRAME;
+	}
+	else
+        *flags=VDEO.index[frame].intra;
+
+	return 1;
+}
+
+
+uint8_t  _3GPHeader::getFrameNoAlloc(uint32_t framenum,ADMCompressedImage *img)
+{
+    uint32_t offset=VDEO.index[framenum].offset; //+_mdatOffset;
+
+
+    fseeko(_fd,offset,SEEK_SET);
+    fread(img-&gt;data, VDEO.index[framenum].size, 1, _fd);
+    img-&gt;dataLength=VDEO.index[framenum].size;
+    return 1;
+}
+_3GPHeader::~_3GPHeader()
+{
+    close();
+
+}
+uint8_t    _3GPHeader::close( void )
+{
+	if(_fd)
+ 		{
+               	fclose(_fd);
+             	}
+              _fd=NULL;
+#define DEL(x) if(x) delete [] x;x=NULL;
+	DEL(Sz);
+	DEL(Co);
+	DEL(Sc);
+	DEL(Sn);
+	DEL(Sync);
+	DEL(SttsN);
+	DEL(SttsC);
+        DEL(Ctts);
+ 	return 1;
+}
+//
+//	Set default save value
+//
+
+_3GPHeader::_3GPHeader(void)
+{
+	_fd=NULL;
+	 Sz=NULL;
+	 Co=NULL;
+	 Sc=NULL;
+	 Sn=NULL;
+	 Sync=NULL;
+	 SttsN=NULL;
+	 SttsC=NULL;
+         Ctts=NULL;
+         nbCtts=0;
+        nbAudioTrack=0;
+        _currentAudioTrack=0;
+        _reordered=0;
+        _videoScale=1;
+}
+uint8_t	_3GPHeader::getAudioStream(AVDMGenericAudioStream **audio)
+{  
+    if(nbAudioTrack) 
+    {
+        *audio=_audioTracks[_currentAudioTrack];
+    }  else 
+        *audio=NULL;
+    return 1;
+};
+WAVHeader 	*_3GPHeader::getAudioInfo(void )
+{ 	
+	if(!nbAudioTrack)
+		return NULL; 
+       
+        return _audioTracks[_currentAudioTrack]-&gt;getInfo();
+} ;
+uint32_t _3GPHeader::getNbStream(void)
+{ 
+    return 1+nbAudioTrack;
+};
+uint8_t   _3GPHeader::getExtraHeaderData(uint32_t *len, uint8_t **data)
+{
+uint32_t old;
+        *len=0;*data=NULL;
+        if(_tracks[0].extraDataSize)
+        {
+            *len= VDEO.extraDataSize;
+            *data=VDEO.extraData;
+        }
+        return 1;
+}
+//______________________________________
+//
+// Open and recursively read the atoms
+// until we got the information we want
+// i.e. :
+//	index for audio and video track
+//	esds for mpeg4
+//	size / codec used 
+//
+// We don't care about sync atom and all
+// other stuff which are pretty useless on
+// 3gp file anyway.
+//______________________________________
+uint8_t    _3GPHeader::open(char *name)
+{
+	printf(&quot;** opening 3gpp files **&quot;);	
+	_fd=fopen(name,&quot;rb&quot;);
+	if(!_fd)
+	{
+		printf(&quot;\n cannot open %s \n&quot;,name);
+		return 0;
+	}
+#define CLR(x)              memset(&amp; x,0,sizeof(  x));
+
+              CLR( _videostream);
+              CLR(  _mainaviheader);
+	      _isvideopresent=1;
+	      _isaudiopresent=0;
+    	      _videostream.dwScale=1000;
+              _videostream.dwRate=10000;
+              _mainaviheader.dwMicroSecPerFrame=100000;;     // 10 fps hard coded
+              _videostream.fccType=fourCC::get((uint8_t *)&quot;vids&quot;);
+              _video_bih.biBitCount=24;
+              _videostream.dwLength= _mainaviheader.dwTotalFrames=1;
+              _videostream.dwInitialFrames= 0;
+              _videostream.dwStart= 0;
+              _video_bih.biWidth=_mainaviheader.dwWidth=16 ;
+              _video_bih.biHeight=_mainaviheader.dwHeight=16;
+              _videostream.fccHandler=fourCC::get((uint8_t *)&quot;XXXX&quot;);
+	      _video_bih.biCompression=_videostream.fccHandler;
+
+	printf(&quot;\n&quot;);
+	adm_atom *atom=new adm_atom(_fd);
+        // Check it is not mdat start(ADM_memcpy_0)     
+        uint8_t check[4];
+        fseeko(_fd,4,SEEK_SET);
+        fread(check,4,1,_fd);
+        fseeko(_fd,0,SEEK_SET);
+        if(check[0]=='m' &amp;&amp; check[1]=='d' &amp;&amp;check[2]=='a' &amp;&amp; check[3]=='t')
+        {
+                        uint32_t of;
+                                        printf(&quot;Data first, header later...\n&quot;);
+                                        of=atom-&gt;read32();
+                                        if(of==1)
+                                        {
+                                          atom-&gt;read32();
+                                          atom-&gt;read32();
+                                          of=atom-&gt;read32();
+                                        }
+                                        fseeko(_fd,of,SEEK_SET);        
+                                        printf(&quot;Header starts at %x\n&quot;,of);
+                                        delete atom;
+                                        atom=new adm_atom(_fd);
+        }
+	parseAtomTree(atom);
+	delete atom;
+	printf(&quot;Found video codec type :&quot;);fourCC::print(_videostream.fccHandler);printf(&quot;\n&quot;);
+        if(!VDEO.index) 
+        {
+                printf(&quot;No index!\n&quot;);
+                return 0;
+        }
+
+        // If it is mpeg4 and we have extra data
+        // Decode vol header to get the real width/height
+        // The mpeg4/3GP/Mov header is often misleading
+        if(fourCC::check(_videostream.fccHandler,(uint8_t *)&quot;DIVX&quot;))
+        {
+            if(VDEO.extraDataSize)
+            {
+                uint32_t w,h,ti;
+                if(extractMpeg4Info(VDEO.extraData,VDEO.extraDataSize,&amp;w,&amp;h,&amp;ti))
+                {
+                    printf(&quot;MP4 Corrected size : %lu x %lu\n&quot;,w,h);
+                    _video_bih.biWidth=_mainaviheader.dwWidth=w ;
+                    _video_bih.biHeight=_mainaviheader.dwHeight=h;                               
+                }
+            }else { printf(&quot;No extradata to probe\n&quot;);}
+        
+        }
+        else
+        {
+
+        /*
+            Same story for H263 : Analyze 1st frame to get the real width/height
+        */
+            if(fourCC::check(_videostream.fccHandler,(uint8_t *)&quot;H263&quot;))
+            {
+                uint32_t w,h,sz;
+                uint8_t *bfer=NULL;
+                sz=VDEO.index[0].size;
+                if(sz)
+                {
+                        bfer=new uint8_t[sz];
+                        ADMCompressedImage img;
+                        img.data=bfer;
+                        if(getFrameNoAlloc(0,&amp;img))
+                        {
+                        if(extractH263Info(bfer,sz,&amp;w,&amp;h))
+                        {
+                            printf(&quot;H263 Corrected size : %lu x %lu\n&quot;,w,h);
+                            _video_bih.biWidth=_mainaviheader.dwWidth=w ;
+                            _video_bih.biHeight=_mainaviheader.dwHeight=h;                               
+                        }
+                        else
+                        {
+                                  printf(&quot;H263 COULD NOT EXTRACT SIZE, using : %lu x %lu\n&quot;,
+                                      _video_bih.biWidth,  _video_bih.biHeight);
+                        }
+                        }
+                        delete [] bfer;
+                }
+            }
+
+        
+        }
+        
+        /*
+                Now build audio tracks
+        */
+        for(int audio=0;audio&lt;nbAudioTrack;audio++)
+        {
+            _audioTracks[audio]=new _3gpAudio(_fd,&amp;(_tracks[1+audio]));   
+            
+        }
+        fseek(_fd,0,SEEK_SET);
+
+        /* Do we have a ctts atom ? if so it contains B frame and we can guesstimate them */
+        if(Ctts)
+        {
+            uint32_t scope=nbCtts;
+            if(scope&gt;_videostream.dwLength) scope=_videostream.dwLength;
+            
+            // Search floor value
+            uint32_t  flor=0xFFFFFFFF;
+            uint32_t  cel=0;
+            for(uint32_t i=0;i&lt;scope;i++)
+            {
+              if(Ctts[i]&gt;4294967290) 
+              {
+                if(i)
+                  Ctts[i]=Ctts[0];
+                else
+                  Ctts[i]=Ctts[1];
+              }
+              if(Ctts[i] &gt;cel) cel=Ctts[i];
+              if(Ctts[i]&lt;flor) flor=Ctts[i];
+            }
+            printf(&quot;[3GP] Ctts min %u max %u\n&quot;,flor,cel);
+            for(uint32_t i=0;i&lt;scope;i++)
+            {
+              int floops=Ctts[i]-flor;
+               float f=floops;
+               aprintf(&quot;Frame %u ctts %u scale:%u\n&quot;,i,floops,_videoScale);
+                uint32_t delta;
+                f*=_videostream.dwRate;
+                f/=1000. ;; // in frame
+                f/=_videoScale;
+                floops=1+(uint32_t)floor(f+0.49);
+                aprintf(&quot;&gt;Frame :%u delta=%d\n&quot;,i,floops);
+              if(floops&lt;0)
+              {
+                printf(&quot;[3GPP] CTTS negative for frame %u : %d\n&quot;,i,floops); 
+                floops=0;
+              }
+              _tracks[0].index[i].deltaPtsDts=floops;
+                
+            }
+            
+            
+        }
+        _tracks[0].index[0].intra=AVI_KEY_FRAME;
+        // Update usec per frame
+        _mainaviheader.dwMicroSecPerFrame=ADM_UsecFromFps1000( _videostream.dwRate);;;   
+        printf(&quot;3gp/mov file successfully read..\n&quot;);
+        return 1;
+}
+uint8_t _3GPHeader::parseAtomTree(adm_atom *atom)
+{
+	static uint32_t current=0;
+	static uint32_t nbSz,nbCo,nbSc,nbSync,SzIndentical;
+	//static uint32_t duration;
+	static uint32_t _lastW, _lastH;
+	static uint32_t nest=0;
+	static uint32_t nbStts;
+	static uint32_t myScale=1000;
+	uint32_t type;
+	uint32_t n=0,j,wh,i,l=0;
+	uint32_t tag=0xff;
+        double duration=0;
+	// Skippable : Edit edts dinf
+	//		udta : user data
+	
+	while(!atom-&gt;isDone())
+	{
+		adm_atom tom(	atom);
+#ifdef _3GP_VERBOSE
+					for(uint32_t o=0;o&lt;nest;o++) printf(&quot;\t&quot;);
+					printf(&quot;parsing atom &quot;);
+					fourCC::printBE(tom.getFCC());
+					printf(&quot; (size %lu) at 0x%x\n&quot;,tom.getSize(),tom.getStartPos());	
+#endif
+		nest++;
+		switch((tom.getFCC()))
+		{
+			default:
+//#ifdef _3GP_VERBOSE
+#if 1
+					for(uint32_t o=0;o&lt;nest;o++) printf(&quot;\t&quot;);
+					printf(&quot;skipping atom &quot;);
+					fourCC::printBE(tom.getFCC());
+					printf(&quot; (size %lu) at 0x%x\n&quot;,tom.getSize(),tom.getStartPos());   
+#endif
+					tom.skipAtom();
+					break;
+			case MKFCCR('m','d','a','t') : //'mdat':
+                                        {
+                                        tom.skipAtom();
+                                
+                                        }
+					break;
+
+	 	// these are container atoms,
+	     	// we go on , they includes other atom
+
+                        case MKFCCR('w','a','v','e'): //'wave':
+			case MKFCCR('s','t','b','l'): //'stbl':
+			case MKFCCR('m','d','i','a') : //'mdia':
+			case MKFCCR('m','i','n','f'): //'minf':
+			case MKFCCR('m','o','o','v'): //'moov':
+			case MKFCCR('c','m','o','v'): //'cmov':
+			case MKFCCR('M','O','V','I') : //'MOVI':
+				parseAtomTree(&amp;tom);
+				break;
+
+			case MKFCCR('s','m','h','d'): // Track audio header
+					fourCC::printBE(tom.read32());
+					tom.skipAtom();
+					break;
+			case MKFCCR('d','c','o','m') : //dcom':
+					fourCC::printBE(tom.read32());
+					tom.skipAtom();
+					break;
+			case MKFCCR('m','v','h','d') : //'mvhd':
+				{
+				uint32_t scale=0;
+					tom.skipBytes(12);
+					scale=tom.read32();
+					duration=tom.read32();
+					if(scale!=1000)
+					{
+						myScale=scale;
+						printf(&quot;Warning : scale is not in ms %lu !\n&quot;,myScale);
+						if(scale)
+						{
+								duration=1000*duration;
+								duration/=scale;
+						}
+						scale=1000;
+					}
+					
+					printf(&quot;Duration : %lu ms\n&quot;,duration);
+					if(!duration) duration=1000;
+					
+				}
+				tom.skipAtom();
+				break;
+
+			case MKFCCR('r','a','w',' '): //'raw ':
+					tom.skipBytes(8);
+					
+					printf(&quot;Raw audio detected\n&quot;);
+					printf(&quot;Version : %u\n&quot;,tom.read16());
+					printf(&quot;Revision :%u\n&quot;,tom.read16());
+					printf(&quot;Vendor :%lu\n&quot;,tom.read32());
+                                        ADIO.channels=tom.read16();
+                                        ADIO.bitspersample=tom.read16();
+                                        ADIO.encoding=tom.read16();
+
+                                        printf(&quot;Channels :%lu\n&quot;,ADIO.channels);
+                                        printf(&quot;S size :%lu\n&quot;,ADIO.bitspersample);
+                                        printf(&quot;Compression :%u\n&quot;,ADIO.encoding);
+					printf(&quot;Packet Size :%u\n&quot;,tom.read16());
+					i=tom.read32();
+					if(i&amp;0xffff)
+					{
+                                          GUI_Error_HIG(_(&quot;Expect troubles&quot;), NULL);
+					}
+                                        if(!ADIO.channels) ADIO.channels=1;
+                                        if(ADIO.bitspersample&lt;8) ADIO.bitspersample=8;
+                                        ADIO.encoding=WAV_8BITS_UNSIGNED;
+                                        ADIO.byterate=(i&gt;&gt;16);
+                                        ADIO.frequency=ADIO.byterate/((ADIO.bitspersample&gt;&gt;3)*(ADIO.channels));
+					printf(&quot;Bitrate :%lu (%x)\n&quot;,i,i);
+                                        printf(&quot;Byterate :%lu\n&quot;,ADIO.byterate);
+                                        printf(&quot;Frequency :%lu\n&quot;,ADIO.frequency);
+// hardcoded for now
+
+					tom.skipAtom();
+					break;
+			case MKFCCR('u','l','a','w'): //'ulaw ':
+					tom.skipBytes(8);
+	                               printf(&quot;Version : %u\n&quot;,tom.read16());
+					printf(&quot;Revision :%u\n&quot;,tom.read16());
+					printf(&quot;Vendor :%lu\n&quot;,tom.read32());
+                                        ADIO.channels=tom.read16();
+                                        ADIO.bitspersample=tom.read16();
+                                        tom.read16();
+                                        ADIO.encoding=WAV_ULAW;
+                                        ADIO.byterate=ADIO.frequency=tom.read32();	
+                                        printf(&quot;Byterate  :%lu\n&quot;,ADIO.byterate);
+                                        printf(&quot;Frequency :%lu\n&quot;,ADIO.frequency);
+                                        printf(&quot;Bps       :%lu\n&quot;,ADIO.bitspersample);
+					tom.skipAtom();
+					break;		
+                        case MKFCCR('t','w','o','s'): //'twos ':
+                                        tom.skipBytes(8);
+                                       printf(&quot;Version : %u\n&quot;,tom.read16());
+                                        printf(&quot;Revision :%u\n&quot;,tom.read16());
+                                        printf(&quot;Vendor :%lu\n&quot;,tom.read32());
+                                        ADIO.channels=tom.read16();
+                                        ADIO.bitspersample=tom.read16();
+                                        tom.read16();
+                                        ADIO.encoding=WAV_LPCM;
+                                        ADIO.frequency=tom.read32();      
+                                        ADIO.byterate=ADIO.frequency*ADIO.bitspersample*ADIO.channels/8;
+                                        printf(&quot;Byterate  :%lu\n&quot;,ADIO.byterate);
+                                        printf(&quot;Frequency :%lu\n&quot;,ADIO.frequency);
+                                        printf(&quot;Bps       :%lu\n&quot;,ADIO.bitspersample);
+                                        tom.skipAtom();
+                                        break;          
+
+                        case MKFCCR('.','m','p','3'): //.mp3
+                                        tom.skipBytes(16);
+                                        ADIO.encoding=WAV_MP3;
+                                        ADIO.channels=tom.read16();
+                                        printf(&quot;mp3 audio\n&quot;);
+                                        printf(&quot;Channels :%d\n&quot;,ADIO.channels);
+                                        printf(&quot;Bps      :%d\n&quot;,tom.read16()); // Bps
+                                        printf(&quot;CodecId  :%x\n&quot;,tom.read16()); // Bps
+                                        printf(&quot;Packetsiz:%x\n&quot;,tom.read16()); // Bps
+                                        ADIO.frequency=tom.read16();  //Bps
+                                        printf(&quot;Fq        :%d\n&quot;,ADIO.frequency); // Bps
+                                        tom.skipAtom();
+                                        break;
+                        case MKFCCR('s','o','w','t'): //sowt
+                                        {
+                                        tom.skipBytes(8);
+                                        printf(&quot;Version : %u\n&quot;,tom.read16());
+                                        printf(&quot;Revision :%u\n&quot;,tom.read16());
+                                        printf(&quot;Vendor :%lu\n&quot;,tom.read32());
+                                        ADIO.channels=tom.read16();
+                                        ADIO.bitspersample=tom.read16();
+                                        tom.read16();
+                                        ADIO.encoding=WAV_PCM;
+                                        ADIO.byterate=ADIO.frequency=tom.read32();
+                                        ADIO.byterate*=ADIO.bitspersample/8;
+                                        ADIO.byterate*=ADIO.channels;
+                                        
+                                        printf(&quot;Byterate  :%lu\n&quot;,ADIO.byterate);
+                                        printf(&quot;Frequency :%lu\n&quot;,ADIO.frequency);
+                                        printf(&quot;Bps       :%lu\n&quot;,ADIO.bitspersample);
+                                        tom.skipAtom();
+                                        break;          
+
+
+                                        }
+                    case MKFCCR('u','r','l',' '): // url
+                                      {
+                                        int s;
+                                        tom.read32();
+                                        tom.read32();
+                                        s=tom.read32();
+                                        char str[s+1];
+                                        tom.readPayload((uint8_t *)str,s);
+                                        str[s]=0;
+                                        printf(&quot;Url : %s\n&quot;,str);
+                                        tom.skipAtom();
+                                        break;
+                                      }                   
+                    case MKFCCR('Q','D','M','2'): // QDM2
+                                        {
+                                        tom.skipBytes(8);
+                                        printf(&quot;QDM2 audio\n&quot;);
+                                        printf(&quot;Version : %u\n&quot;,tom.read16());
+                                        printf(&quot;Revision :%u\n&quot;,tom.read16());
+                                        printf(&quot;Vendor :%lu\n&quot;,tom.read32());
+                                        ADIO.channels=tom.read16();
+                                        ADIO.bitspersample=tom.read16();
+                                        tom.read16();
+                                        ADIO.encoding=WAV_QDM2;
+                                        ADIO.byterate=ADIO.frequency=tom.read32();
+                                        ADIO.byterate*=ADIO.bitspersample/8;
+                                        ADIO.byterate*=ADIO.channels;
+                                        
+                                        printf(&quot;Byterate  :%lu\n&quot;,ADIO.byterate);
+                                        printf(&quot;Frequency :%lu\n&quot;,ADIO.frequency);
+                                        printf(&quot;Bps       :%lu\n&quot;,ADIO.bitspersample);
+                                        tom.skipBytes(26);
+
+                                        _tracks[nbAudioTrack+1].extraDataSize=tom.getRemainingSize();
+                                        _tracks[nbAudioTrack+1].extraData=new uint8_t [_tracks[nbAudioTrack+1].extraDataSize];
+                                        tom.readPayload(_tracks[nbAudioTrack+1].extraData,_tracks[nbAudioTrack+1].extraDataSize);
+                                        mixDump(_tracks[nbAudioTrack+1].extraData,_tracks[nbAudioTrack+1].extraDataSize);
+                                        break;          
+
+
+                                        }
+			case MKFCCR('m','p','4','a'): //'mp4a':
+					
+                                        if(tom.getRemainingSize()&gt;15) // skip the real mp4a atom, we only do the one in stds
+                                        {
+					// Put safe default here, in case there 
+ 					// is no decodable information later on
+                                        ADIO.encoding=WAV_AAC;					
+                                        ADIO.frequency=44100;
+                                        ADIO.channels=2;
+                                        ADIO.bitspersample=16;
+                                        ADIO.byterate=128000/8;
+					// According to 3gp doc we should have 28 bytes
+					// at least
+
+					{
+                                                uint32_t u32;
+                                 
+                                                tom.skipBytes(8);  // Skip header
+                                                printf(&quot;Version  :%d\n&quot;,u32=tom.read16()); // Qual1
+                                                printf(&quot;Revision :%d\n&quot;,tom.read16());  // revision / level
+                                                printf(&quot;Vendor   :%d\n&quot;,tom.read32());  // Vendor
+                                                ADIO.channels=tom.read16();
+                                                printf(&quot;Channels :%d\n&quot;,ADIO.channels); // Channels
+                                                
+                                                printf(&quot;Bps      :%d\n&quot;,tom.read16()); // Bps
+                                                printf(&quot;CodecId  :%x\n&quot;,tom.read16()); // Bps
+                                                printf(&quot;Packetsiz:%x\n&quot;,tom.read16()); // Bps
+                                                if(u32&lt;2)
+                                                {
+                                                        ADIO.frequency=tom.read16();
+                                                        if(ADIO.frequency&lt;8000) ADIO.frequency=48000;
+                                                        printf(&quot;Fq       :%d\n&quot;,ADIO.frequency); // Bps
+                                                        tom.skipBytes(2); // Fixed point
+                                                }
+                                                
+                                                //
+                                                switch(u32)
+                                                {
+                                                        case 0:break;
+                                                        case 1:
+                                                                printf(&quot;Sample per packet   :%d\n&quot;,tom.read32());  // Vendor
+                                                                printf(&quot;Bytes  per packet   :%d\n&quot;,tom.read32());  // Vendor
+                                                                printf(&quot;Bytes per frame     :%d\n&quot;,tom.read32());  // Vendor
+                                                                printf(&quot;Bytes per sample    :%d\n&quot;,tom.read32());  // Vendor
+                                                                break;
+                                                        case 2:
+                                                                ADIO.frequency=44100;
+                                                                tom.skipBytes(16);
+                                                                ADIO.channels=tom.read32();
+                                                                printf(&quot;Channels            :%d\n&quot;,ADIO.channels); // Channels
+                                                                printf(&quot;Tak(7F000)           :%x\n&quot;,tom.read32()); // Channels
+                                                                printf(&quot;Bites  per channel  :%d\n&quot;,tom.read32());  // Vendor
+                                                                printf(&quot;Format specific     :%x\n&quot;,tom.read32());  // Vendor
+                                                                printf(&quot;Byte per audio packe:%x\n&quot;,tom.read32());  // Vendor
+                                                                printf(&quot;LPCM                :%x\n&quot;,tom.read32());  // Vendor
+                                                                break;
+                                                }
+                                                // look other atom following
+                                                parseAtomTree(&amp;tom);
+                                                tom.skipAtom();
+                                        }
+                                        } else tom.skipAtom();
+					break;
+			case MKFCCR('s','a','m','r'): //'mp4a':
+					tom.skipBytes(8);
+					
+                                        ADIO.encoding=WAV_AMRNB;
+					
+					#warning !!!!!!!!!!!!!!!
+					#warning decode WAV_AMRNB audio header!
+					#warning !!!!!!!!!!!!!!!
+                                        ADIO.frequency=8000;
+                                        ADIO.channels=1;
+                                        ADIO.bitspersample=16;
+                                        ADIO.byterate=12000/8;
+					
+					tom.skipAtom();
+					break;
+                        case MKFCCR('c','t','t','s'): // Composition time to sample             
+                                {
+                                    uint32_t n,i,j,k,v;
+                                printf(&quot;ctts:%lu\n&quot;,tom.read32()); // version &amp; flags
+                                n=tom.read32();
+                                
+                                    Ctts=new uint32_t[n*4]; // keep a safe margin
+                                
+                                    for(i=0;i&lt;n;i++)
+                                    {
+                                        j=tom.read32();
+                                        v=tom.read32();
+#if 0
+                                        if(j&gt;10)
+                                        {
+                                          //  printf(&quot;Too much element %u\n&quot;,j);
+                                            nbCtts=0;
+                                            break;
+                                        }
+#endif
+                                        if(i&lt;20)
+                                        {
+                                            printf(&quot;Ctts: nb: %u (%x) val:%u (%x)\n&quot;,j,j,v,v);   
+                                        }
+                                        for(k=0;k&lt;j;k++)
+                                        {
+                                            Ctts[nbCtts++]=v;
+                                        }
+                                    }
+                                    if(!nbCtts)
+                                    {
+                                        delete [] Ctts;
+                                        Ctts=NULL;
+                                        printf(&quot;Destroying Ctts, seems invalid\n&quot;);
+                                    }
+                                    printf(&quot;Found %u elements\n&quot;,nbCtts);
+                                
+                                
+                                tom.skipAtom(); 
+                                }
+                                break;  
+			case MKFCCR('s','t','t','s'): // time sample table stts
+				
+				printf(&quot;stts:%lu\n&quot;,tom.read32()); // version &amp; flags
+				nbStts=tom.read32();
+				printf(&quot;Time stts atom found (%lu)\n&quot;,nbStts);
+				printf(&quot;Using myscale %lu\n&quot;,myScale);
+				SttsN=new uint32_t[nbStts];
+				SttsC=new uint32_t[nbStts];
+				double dur;
+				for(i=0;i&lt;nbStts;i++)
+				{
+					
+					SttsN[i]=tom.read32();
+					SttsC[i]=tom.read32();
+					aprintf(&quot;stts: count:%u size:%u (unscaled)\n&quot;,SttsN[i],SttsC[i]);	
+					//dur*=1000.*1000.;; // us
+					//dur/=myScale;
+				}
+				tom.skipAtom();
+				break;	
+				
+			case MKFCCR('s','t','s','s'): //'stss':
+				printf(&quot;Sync atom found\n&quot;);
+				tom.read32();
+				nbSync=tom.read32();
+				if(nbSync)
+				{
+					Sync=new uint32_t[nbSync];
+					for(i=0;i&lt;nbSync;i++)
+					{
+						Sync[i]=tom.read32();
+					}
+				}
+				tom.skipAtom();
+				break;
+			case MKFCCR('t','r','a','k'): //'trak':
+                                printf(&quot;**************************************************\n&quot;);
+				printf(&quot;Track found\n&quot;);
+				current=0;
+				nbSz=0;
+				nbCo=0;
+				nbSc=0;
+				nbSync=0;
+				nbStts=0;
+                                SzIndentical=0;
+				//myScale=1000;
+				parseAtomTree(&amp;tom);
+				switch(current)
+				{
+				uint32_t nbo;
+				case 1:
+					{
+                                        // If we already built video track, ignore
+					if(_tracks[0].nbIndex) break;
+                                        _videoScale=myScale;
+					buildIndex(&amp;_tracks[0],myScale,
+							nbSz,Sz,SzIndentical,nbCo,Co,nbSc,Sc,nbStts,SttsN,SttsC,
+							Sn,&amp;nbo,0);
+					// Take the last entry in the video index as global time
+					// time in us
+                                        nbo=_tracks[0].nbIndex;
+					_videostream.dwLength= _mainaviheader.dwTotalFrames=nbo;
+					double last=VDEO.index[nbo-1].time;
+					// avoid rounding error
+					
+                                        last+=VDEO.index[1].time; // ~ 1 Frame duration
+                                        printf(&quot;Time code of last img  : %lf \n&quot;,last);
+					if(last&lt;0.1)
+                                        {
+                                                last=25000;
+                                                printf(&quot;WARNING Erroneous fps !!!\n&quot;);
+                                        }
+					last=1000.*1000.*1000./last;
+					last*=nbo;
+					printf(&quot;3GP:Tk %lu Nb sz:%lu nbFrame:%lu duration:%f us\n&quot;,
+							current,nbSz,nbo,last);
+              				_videostream.dwRate=(uint32_t)floor(last);
+					if(nbSync)
+                                            sync(VDEO.index,nbSz,nbSync,Sync);
+					else
+                                         { // All frame keyframe ?
+                                            printf(&quot;3gp:All frame keyframes ??\n&quot;);
+                                            for(uint32_t i=0;i&lt;nbo;i++)
+                                            {
+                                                VDEO.index[i].intra=AVI_KEY_FRAME;
+                                            }
+                                         }
+                                        }
+					break;
+				case 2:
+					// audio
+                                        
+                                        // Ugly hack !
+                                        // In case of uncompressed audio (LPCM &amp; friends)
+                                        // The size is in sample, not byte
+                                        if(SzIndentical ==1 &amp;&amp; (ADIO.encoding==WAV_LPCM || ADIO.encoding==WAV_PCM ))
+                                        {
+                                          printf(&quot;Overriding size %lu -&gt; %lu\n&quot;, SzIndentical,SzIndentical*2*ADIO.channels);
+                                          SzIndentical=SzIndentical*2*ADIO.channels;
+                                        }
+                                           
+                                  
+                                  
+                                        // 
+                                        buildIndex(&amp;_tracks[1+nbAudioTrack],myScale,
+							nbSz,Sz,SzIndentical,nbCo,Co,nbSc,Sc,nbStts,SttsN,SttsC,
+							Sn,&amp;nbo,1);
+                                        nbo=_tracks[1+nbAudioTrack].nbIndex;
+                                        // Check for extra
+
+
+                                        if(nbo)
+                                            _tracks[1+nbAudioTrack].nbIndex=nbo;
+                                        else
+                                            _tracks[1+nbAudioTrack].nbIndex=nbSz;
+                                        nbAudioTrack++;
+					break;
+                                default : printf(&quot;In atom track, the track type is unknown (%d)\n&quot;,current);
+				}
+                                DEL(Sz);
+                                DEL(Co);
+                                DEL(Sc);
+                                DEL(Sn);
+                                DEL(Sync);
+                                DEL(SttsC);
+                                DEL(SttsN);
+                                printf(&quot;**************************************************\n&quot;);
+				break;
+		// misc atom that needs special care
+			case MKFCCR('m','d','h','d'): //mdhd
+				//
+				{
+				uint32_t tmpscale,version;
+				
+				printf(&quot;Decoding mdhd\n&quot;);
+                                version=tom.read();
+				tom.skipBytes(3); // flags + version
+				tom.skipBytes(4); // creation time
+				tom.skipBytes(4); // mod time
+                                if(version==1) tom.skipBytes(8);
+				tmpscale=tom.read32(); //
+				printf(&quot;Myscale in mdhd:%lu\n&quot;,tmpscale);
+				if(!tmpscale) tmpscale=600; // default
+				duration=tom.read32();
+				printf(&quot;duration in mdhd:%f (unscaled)\n&quot;,duration);
+				duration=(duration*1000.)/tmpscale;
+				printf(&quot;duration in mdhd:%f (scaled ms)\n&quot;,duration);
+				tom.skipAtom();
+				myScale=tmpscale;
+				}
+				break;
+			case MKFCCR('h','d','l','r'): //'hdlr':
+				tom.read32();
+				tom.read32();
+				type=tom.read32();
+				switch(type)
+                                {	
+                                case MKFCCR('v','i','d','e')://'vide':
+                                        current=1;
+                                        printf(&quot;hdlr video found \n &quot;);
+                                        break;
+                                case MKFCCR('s','o','u','n'): //'soun':
+                                        current=2;
+                                        _audioDuration=(uint32_t)duration;
+                                        printf(&quot;hdlr audio found (duration %f ms)\n &quot;,duration);
+                                        break;
+                                case MKFCCR('u','r','l',' ')://'url ':
+                                    {
+                                        int s;
+                                        tom.read32();
+                                        tom.read32();
+                                        tom.read32();
+                                        s=tom.read();
+                                        char str[s+1];
+                                        tom.readPayload((uint8_t *)str,s);
+                                        str[s]=0;
+                                        printf(&quot;Url : &lt;%s&gt;\n&quot;,str);
+                                        
+                                      }                   
+                                      break;
+                                default:
+                                        printf(&quot;hdlr found but ignored \n&quot;);
+                                        fourCC::print(type);
+                                        printf(&quot;\n&quot;);
+                                }
+				tom.skipAtom();
+                                duration=0;
+				break;
+			case MKFCCR('s','t','s','d') : //'stsd':
+				tom.read32();
+				n=tom.read32();
+				for(i=0;i&lt;n;i++)
+					parseAtomTree(&amp;tom);
+
+				break;
+			case MKFCCR('t','k','h','d'): //'tkhd':
+				tom.skipBytes(12);
+				printf(&quot;Track Id: %lu\n&quot;,tom.read32());
+				tom.skipBytes(4);
+				printf(&quot;Duration: %lu (ms)\n&quot;,(tom.read32()*1000)/myScale);
+				tom.skipBytes(8);
+				tom.skipBytes(4); // layers
+				tom.skipBytes(40); // layers
+
+				_lastW=tom.read32()&gt;&gt;16;
+				_lastH=tom.read32()&gt;&gt;16;
+				tom.skipAtom();
+				printf(&quot;tkhd : %ld %ld\n&quot;,_lastW,_lastH);
+				break;
+                        case MKFCCR('d','v','c',' ') : //'dvc ':
+                        case MKFCCR('d','v','p','p') : //'dvpp':
+/*
+                                tom.skipBytes(24);
+                                wh=tom.read32();
+                                tom.skipBytes(40);
+*/
+
+                                _video_bih.biWidth=_mainaviheader.dwWidth=_lastW ;
+                                _video_bih.biHeight=_mainaviheader.dwHeight=_lastH ;
+
+                                printf(&quot;DV : %ld x %ld \n&quot;,_video_bih.biWidth,_video_bih.biHeight);
+                                _videostream.fccHandler=fourCC::get((uint8_t *)&quot;DVDS&quot;);
+                                _video_bih.biCompression=_videostream.fccHandler;
+                                tom.skipAtom();
+                                break;
+			case MKFCCR('s','2','6','3') : //'s263':
+                        case MKFCCR('h','2','6','3') : //'s263':
+				tom.skipBytes(24);
+				wh=tom.read32();
+				tom.skipBytes(40);
+
+
+              			_video_bih.biWidth=_mainaviheader.dwWidth=wh&gt;&gt;16 ;
+              			_video_bih.biHeight=_mainaviheader.dwHeight=wh &amp; 0xffff;
+				printf(&quot;H263 : %ld x %ld \n&quot;,_video_bih.biWidth,_video_bih.biHeight);
+              			_videostream.fccHandler=fourCC::get((uint8_t *)&quot;H263&quot;);
+                        	_video_bih.biCompression=_videostream.fccHandler;
+				// d263 atom here	 -&gt; ignored
+				tom.skipAtom();
+				break;
+			case MKFCCR('S','V','Q','3'): //'SVQ3':
+					// For SVQ3, the codec needs it to begin by SVQ3
+					// We go back by 4 bytes to get the 4CC
+						printf(&quot;SVQ3 atom found\n&quot;);
+						VDEO.extraDataSize=tom.getSize()+4;
+                                                VDEO.extraData=new uint8_t[ VDEO.extraDataSize ];
+                                                if(!tom.readPayload(VDEO.extraData+4,VDEO.extraDataSize-4 ))
+						{
+                                                  GUI_Error_HIG(_(&quot;Problem reading SVQ3 headers&quot;), NULL);
+						}
+                                                VDEO.extraData[0]='S';
+                                                VDEO.extraData[1]='V';
+                                                VDEO.extraData[2]='Q';
+                                                VDEO.extraData[3]='3';
+						_video_bih.biWidth=_mainaviheader.dwWidth=_lastW ;
+              					_video_bih.biHeight=_mainaviheader.dwHeight=_lastH;
+
+						printf(&quot;SVQ3 Header size : %lu&quot;,_videoExtraLen);
+						_videostream.fccHandler=fourCC::get((uint8_t *)&quot;SVQ3&quot;);
+				 		_video_bih.biCompression=_videostream.fccHandler;
+						//mixDump(_videoExtraData,30);
+						tom.skipAtom();
+				break;
+                        case MKFCCR('M','J','P','G'): //'jpeg':
+			case MKFCCR('j','p','e','g'): //'jpeg':
+                        case MKFCCR('A','V','D','J'): //'jpeg':
+                                VDEO.extraDataSize=tom.getSize();
+                                VDEO.extraData=new uint8_t [VDEO.extraDataSize];
+                                tom.readPayload(VDEO.extraData,VDEO.extraDataSize);
+				_video_bih.biWidth=_mainaviheader.dwWidth=_lastW ;
+              			_video_bih.biHeight=_mainaviheader.dwHeight=_lastH;
+
+                                printf(&quot;Jpeg Header size %lu \n&quot;,VDEO.extraDataSize);
+				_videostream.fccHandler=fourCC::get((uint8_t *)&quot;MJPG&quot;);
+				 _video_bih.biCompression=_videostream.fccHandler;
+				tom.skipAtom();
+				break;
+
+                          case MKFCCR('d','v','c','p'): //'dv':
+                                  
+                                  _video_bih.biWidth=_mainaviheader.dwWidth=_lastW ;
+                                  _video_bih.biHeight=_mainaviheader.dwHeight=_lastH;
+                                  _videostream.fccHandler=fourCC::get((uint8_t *)&quot;DVDS&quot;);
+                                  _video_bih.biCompression=_videostream.fccHandler;
+                                  tom.skipAtom();
+                                  break;
+                        case MKFCCR('a','v','c','C'): //'avcC':
+                                {
+                                        // configuration data for h264
+                                        //tom.skipBytes(8);
+                                        int len,offset;
+                                    VDEO.extraDataSize=tom.getRemainingSize();
+                                    VDEO.extraData=new uint8_t [VDEO.extraDataSize];
+                                    tom.readPayload(VDEO.extraData,VDEO.extraDataSize);
+                                        printf(&quot;avcC size:%d\n&quot;,VDEO.extraDataSize);
+                                    // Dump some info
+                                        #define MKD8(x) VDEO.extraData[x]
+                                        #define MKD16(x) ((MKD8(x)&lt;&lt;8)+MKD8(x+1))
+                                        #define MKD32(x) ((MKD16(x)&lt;&lt;16)+MKD16(x+2))
+
+                                     printf(&quot;avcC Revision             :%x\n&quot;, MKD8(0));
+                                     printf(&quot;avcC AVCProfileIndication :%x\n&quot;, MKD8(1));
+                                     printf(&quot;avcC profile_compatibility:%x\n&quot;, MKD8(2));
+                                     printf(&quot;avcC AVCLevelIndication   :%x\n&quot;, MKD8(3));
+
+                                     printf(&quot;avcC lengthSizeMinusOne   :%x\n&quot;, MKD8(4));
+                                     printf(&quot;avcC NumSeq               :%x\n&quot;, MKD8(5));
+                                     len=MKD16(6);
+                                     printf(&quot;avcC sequenceParSetLen    :%x &quot;,len );
+                                     offset=8;
+                                     mixDump(VDEO.extraData+offset,len);
+
+                                     offset=8+len;
+                                     printf(&quot;\navcC numOfPictureParSets  :%x\n&quot;, MKD8(offset++));
+                                     len=MKD16(offset++);
+                                     printf(&quot;avcC Pic len              :%x\n&quot;,len);
+                                     mixDump(VDEO.extraData+offset,len);
+                                     printf(&quot;\n&quot;);
+                                     tom.skipAtom();
+                                     break;
+                                }
+                        case MKFCCR('a','v','c','1'): //'avc1':
+                                {
+                                        uint32_t u32;
+                                 _videostream.fccHandler=fourCC::get((uint8_t *)&quot;H264&quot;);
+                                 _video_bih.biCompression=_videostream.fccHandler;
+                                tom.skipBytes(8);  // Skip header
+                                printf(&quot;Revision :%x\n&quot;,tom.read32());  // revision / level
+                                printf(&quot;Vendor   :&quot;);
+                                fourCC::print(tom.read32());  // vendor
+                                printf(&quot;\n&quot;);
+                                printf(&quot;Qual :%x\n&quot;,tom.read32()); // Qual1
+                                printf(&quot;Qual :%x\n&quot;,tom.read32()); // Qual1
+
+                                _video_bih.biWidth=_mainaviheader.dwWidth=tom.read16() ;
+                                _video_bih.biHeight=_mainaviheader.dwHeight=tom.read16(); 
+                                
+                                printf(&quot;w    :%d\n&quot;,_mainaviheader.dwWidth); // w/h
+                                printf(&quot;h    :%d\n&quot;,_mainaviheader.dwHeight); // w/h
+                                printf(&quot;hzR  :%x dpi\n&quot;,tom.read32()); // w2
+                                printf(&quot;vzR  :%x dpi\n&quot;,tom.read32()); // h2
+                                printf(&quot;DataS:%x\n&quot;,tom.read32()); // h2
+                                printf(&quot;Fr/Sa::%x\n&quot;,tom.read16()); // Frame per sample
+                                u32=tom.read();
+                                if(u32&gt;31) u32=31;
+                                printf(&quot;Codec string :%d &lt;&quot;,u32);
+                                for(int i=0;i&lt;u32;i++) printf(&quot;%c&quot;,tom.read());
+                                printf(&quot;&gt;\n&quot;);
+                                tom.skipBytes(32-1-u32); // skip leftover from name
+                                printf(&quot;Col  :%x\n&quot;,tom.read16()); // Qual1
+                                printf(&quot;Col  :%x\n&quot;,tom.read16()); // Qual1
+                                
+                                // look other atom following
+                                parseAtomTree(&amp;tom);
+                                tom.skipAtom();
+                                }
+                                break;
+
+			case MKFCCR('e','s','d','s'): //'esds':
+					// in case of mpeg4 we only take
+					// the mpeg4 vol header
+					printf(&quot;Esds atom found\n&quot;);
+
+					tom.skipBytes(4);
+					tag=0xff;
+					while(tag!=Tag_DecSpecificInfo &amp;&amp; !tom.isDone())
+					{
+						tag=tom.read();
+						l=readPackedLen(&amp;tom);
+						printf(&quot;\t Tag : %u Len : %u\n&quot;,tag,l);
+						switch(tag)
+						{
+							case Tag_ES_Desc:
+                                                                printf(&quot;\t ES_Desc\n&quot;);
+								tom.skipBytes(3);
+								break;
+							case Tag_DecConfigDesc:
+                                                        {
+                                                                uint8_t objectTypeIndication=tom.read();
+                                                                printf(&quot;\tDecConfigDesc : Tag %u\n&quot;,objectTypeIndication);
+                                                                if(current==2 &amp;&amp; ADIO.encoding==WAV_AAC)
+                                                                {
+                                                                  switch(objectTypeIndication)
+                                                                  {
+                                                                      case 0x69:ADIO.encoding=WAV_MP3;break;
+                                                                      case 0x6b:ADIO.encoding=WAV_MP3;break;
+                                                                      case 0x6d:ADIO.encoding=WAV_MP3;break;
+                                                                      case 226:ADIO.encoding=WAV_AC3;break;
+                                                                      break;
+                                                              
+                                                                  }
+                                                                }
+								tom.skipBytes(1+3+4+4);	
+								break;
+                                                        }
+							case Tag_DecSpecificInfo:
+                                                                printf(&quot;\t DecSpecicInfo\n&quot;);
+                                                                switch(current)
+                                                                {
+                                                                    case 1: // Video
+                                                                        if(!VDEO.extraDataSize)
+                                                                        {
+                                                                                VDEO.extraDataSize=l;
+                                                                                VDEO.extraData=new uint8_t[l];
+                                                                                fread(VDEO.extraData,VDEO.extraDataSize,1,_fd);
+                                                                        }
+								        break;
+                                                                    case 2:
+                                                                        printf(&quot;Esds for audio\n&quot;);
+                                                                        _tracks[1+nbAudioTrack].extraDataSize=l;
+                                                                        _tracks[1+nbAudioTrack].extraData=new uint8_t[l];
+                                                                        fread(_tracks[1+nbAudioTrack].extraData,
+                                                                            _tracks[1+nbAudioTrack].extraDataSize,1,_fd);
+                                                                        break;
+                                                                    default: printf(&quot;Unknown track type for esds %d\n&quot;,current);
+                                                                }
+							}
+					}
+					
+				tom.skipAtom();
+				break;
+			case MKFCCR('m','p','4','v'): //'mp4v':
+				tom.skipBytes(24);		
+                                current=1; // It is video, sure ;)
+				wh=tom.read32();
+				printf(&quot;MP4 : %ld x %ld \n&quot;,_video_bih.biWidth,_video_bih.biHeight);
+				
+              			_video_bih.biWidth=_mainaviheader.dwWidth=wh&gt;&gt;16 ;
+              			_video_bih.biHeight=_mainaviheader.dwHeight=wh &amp; 0xffff;
+              			_videostream.fccHandler=fourCC::get((uint8_t *)&quot;DIVX&quot;);
+				_video_bih.biCompression=_videostream.fccHandler;
+				tom.skipBytes(50);
+				parseAtomTree(&amp;tom);
+				tom.skipAtom();
+				break;
+			case MKFCCR('s','t','s','z'): //'stsz':
+				tom.read32();
+				n=tom.read32();
+              			nbSz=tom.read32();
+                                SzIndentical=0;
+				printf(&quot;%lu frames /%lu nbsz..\n&quot;,n,nbSz);
+				if(n)
+					{
+                                              printf(&quot;\t\t%lu frames of the same size %lu , n=%lu\n&quot;,
+                                                  nbSz,SzIndentical,n);
+                                              SzIndentical=n;
+                                              Sz=NULL;
+					}
+				else
+				{
+					Sz=new uint32_t[nbSz];
+					for(j=0;j&lt;nbSz;j++)
+					{
+							Sz[j]=tom.read32();
+
+					}
+				}
+				tom.skipAtom();
+				break;
+                        case MKFCCR('c','o','6','4'): //'co64':
+                                printf(&quot;Incomplete support for 64 bits quicktime!!\n&quot;);
+                                tom.read32();
+                                nbCo=tom.read32();
+                                Co=new uint32_t[nbCo];
+                                for(j=0;j&lt; nbCo;j++)
+                                {
+                                        tom.read32(); // ignore MSB
+                                        Co[j]=tom.read32();
+                                        aprintf(&quot;Chunk offset : %lu / %lu  : %lu\n&quot;,
+                                                j,nbCo,Co[j]);
+                                }
+
+                                tom.skipAtom();
+                                break;
+
+			case MKFCCR('s','t','c','o'): //'stco':
+
+				tom.read32();
+				nbCo=tom.read32();
+                                printf(&quot;\t\tnbCo:%u\n&quot;,nbCo);
+				Co=new uint32_t[nbCo];
+				for(j=0;j&lt; nbCo;j++)
+				{
+					Co[j]=tom.read32();
+					aprintf(&quot;Chunk offset : %lu / %lu  : %lu\n&quot;,
+						j,nbCo,Co[j]);
+				}
+
+				tom.skipAtom();
+				break;
+			case MKFCCR('s','t','s','c'): //'stsc':
+
+				tom.read32();
+				nbSc=tom.read32();
+				Sc=new uint32_t[nbSc];
+				Sn=new uint32_t[nbSc];
+				for(j=0;j&lt;nbSc;j++)
+				{
+
+					Sc[j]=tom.read32();
+					Sn[j]=tom.read32();
+					tom.read32();
+					aprintf(&quot;\t sc  %d : sc start:%lu sc count: %lu\n&quot;,j,Sc[j],Sn[j]);
+				}
+				tom.skipAtom();
+				break;
+				
+		}
+		nest--;
+	}
+	
+	return 1;
+}
+/*
+	Brute force index position rebuilding
+		from Chunk / Sample / sample per chunk
+
+		The method is a big hairy
+
+		We got a stsc table that says on many sample per chunk we have
+
+			1 3
+			4 7
+			8 9
+
+			It means
+				1 3
+				2 3
+				3 4
+				4 7
+				5 7
+				6 7
+				8 9
+				9 9  etc..
+	We got the first chunk  that have the new sample/chunk  until it changes
+
+	Sc[nbSc] hold the fist chunk that has   Sn[j] chunk in it
+
+	Stsz holds the size of each sample
+	If they are all the same size, nbSz=is the # of frames and Sz=NULL  SzIndentical is the size frame
+        IF they are not all the same size, nbSz is the # of sizes (normally same as # of samples) SzIndentical=0 and Sz contains the size
+
+
+<A HREF="http://developer.apple.com/documentation/QuickTime/QTFF/QTFFChap2/chapter_3_section_5.html#//apple_ref/doc/uid/DontLinkBookID_69-CH204-BBCJEIIA">http://developer.apple.com/documentation/QuickTime/QTFF/QTFFChap2/chapter_3_section_5.html#//apple_ref/doc/uid/DontLinkBookID_69-CH204-BBCJEIIA</A>
+
+*/
+uint8_t	_3GPHeader::buildIndex(
+                            _3gpTrack *track,   
+                            uint32_t myScale,
+				uint32_t nbSz,	uint32_t *Sz,uint32_t SzIndentical,
+				uint32_t nbCo ,		uint32_t *Co,
+				uint32_t nbSc,		uint32_t *Sc,
+				uint32_t nbStts,	uint32_t *SttsN,uint32_t *SttsC,
+				uint32_t *Sn, 			uint32_t *outNbChunk,uint32_t isAudio)
+
+{
+
+uint32_t i,j,cur;
+
+	*outNbChunk=0;
+	aprintf(&quot;+_+_+_+_+_+\n&quot;);
+	aprintf(&quot;co : %lu sz: %lu sc: %lu co[0]%lu \n&quot;,nbCo,nbSz,nbSc,Co[0]);
+	aprintf(&quot;+_+_+_+_+_+\n&quot;);
+
+	ADM_assert(Sc);
+	ADM_assert(Sn);
+	ADM_assert(Co);
+	if(!SzIndentical)
+        {
+          ADM_assert(Sz);
+        }
+	// first set size
+	if(SzIndentical &amp;&amp; isAudio)// in that case they are all the same size, i.e.audio
+	{
+          
+          
+          uint32_t totalBytes=SzIndentical*nbSz;
+          printf(&quot;All the same size : %u (total size %u bytes)\n&quot;,SzIndentical,totalBytes);
+              //
+              // Each chunk contains N samples=N bytes
+              int samplePerChunk[nbCo];
+              memset(samplePerChunk,0,nbCo*sizeof(int));
+              for( i=0;i&lt;nbSc;i++)
+              {
+                  for(int j=Sc[i]-1;j&lt;nbCo;j++)
+                  {
+                        aprintf(&quot;For chunk %lu , %lu samples\n&quot;,j,Sn[i]);
+                        samplePerChunk[j]=Sn[i];
+                  }
+              }
+              int total=0;
+              for( i=0;i&lt;nbCo;i++)
+              {
+                  aprintf(&quot;%u -&gt; %u samples %u bytes\n&quot;,i,samplePerChunk[i],samplePerChunk[i]*SzIndentical);
+                  total+=samplePerChunk[i];
+              }
+              printf(&quot;Total size in byte : %u\n&quot;,total*SzIndentical);
+              track-&gt;index=new _3gpIndex[nbCo];
+              memset(track-&gt;index,0,nbCo*sizeof(_3gpIndex));
+              track-&gt;nbIndex=nbCo;;
+              int max=0;
+              totalBytes=0;
+              for(i=0;i&lt;nbCo;i++)
+              {
+                  uint32_t sz;
+
+                  track-&gt;index[i].offset=Co[i];
+                  sz=samplePerChunk[i]*SzIndentical;
+                  track-&gt;index[i].size=sz;
+                  track-&gt;index[i].time=0; // No seek
+                  if(sz&gt;MAX_CHUNK_SIZE)
+                  {
+                      max+=sz/MAX_CHUNK_SIZE;
+                  }
+                  
+                  totalBytes+=track-&gt;index[i].size;
+              }
+              // Now time to update the time...
+              // Normally they have all the same duration
+              if(nbStts!=1) printf(&quot;WARNING: Same size, different duration\n&quot;);
+
+              float sampleDuration,totalDuration=0;
+              
+                sampleDuration=SttsC[0];
+                sampleDuration*=1000.*1000.;
+                sampleDuration/=myScale;    // Duration of one sample
+                for(i=0;i&lt;nbCo;i++)
+                {
+                        track-&gt;index[i].time=(uint64_t)floor(totalDuration);
+                        totalDuration+=sampleDuration*samplePerChunk[i];
+                        aprintf(&quot;Audio chunk : %lu time :%lu\n&quot;,i,track-&gt;index[i].time);
+                }
+                if(max &amp;&amp; isAudio) // We have some big chunks we need to split them
+                {
+                      // rebuild a new index
+                      printf(&quot;We have %u chunks that are too big, adjusting..\n&quot;,max);
+                      uint32_t newNbCo=track-&gt;nbIndex+max*2; // *2 is enough, should be.
+                      uint32_t w=0;
+                      uint32_t one_go;
+
+                        one_go=MAX_CHUNK_SIZE/SzIndentical;
+                        one_go=one_go*SzIndentical;
+
+                     _3gpIndex *newindex=new _3gpIndex[newNbCo];
+
+                    int64_t time_increment=(int64_t)((one_go/SzIndentical)*sampleDuration);  // Nb sample*duration of one sample
+                    for(i=0;i&lt;track-&gt;nbIndex;i++)
+                    {
+                      uint32_t sz;
+                          sz=track-&gt;index[i].size;
+                          if(sz&lt;MAX_CHUNK_SIZE)
+                          {
+                              memcpy(&amp;(newindex[w]),&amp;(track-&gt;index[i]),sizeof(_3gpIndex));
+                              w++;
+                              continue;
+                          }
+                          // We have to split it...
+                          int part=0;
+                          while(sz&gt;one_go)
+                          {
+                                newindex[w].offset=track-&gt;index[i].offset+part*one_go;
+                                newindex[w].size=one_go;
+                                newindex[w].time=track-&gt;index[i].time+part*time_increment; 
+                                ADM_assert(w&lt;newNbCo);
+                                w++;
+                                part++;
+                                sz-=one_go;
+                          }
+                          // The last one...
+                                newindex[w].offset=track-&gt;index[i].offset+part*one_go;
+                                newindex[w].size=sz;
+                                newindex[w].time=track-&gt;index[i].time+part*time_increment+((time_increment*sz)/one_go); 
+                                w++;
+                    }
+                    delete [] track-&gt;index;
+                    track-&gt;index=newindex;
+                    track-&gt;nbIndex=w;
+                }
+          return 1;
+      }
+          // Else we build an index per sample
+          //
+	
+		
+	// We have different packet size
+	// Probably video
+        track-&gt;index=new _3gpIndex[nbSz];
+        memset(track-&gt;index,0,nbSz*sizeof(_3gpIndex));
+
+        if(SzIndentical) // Video, all same size (DV ?)
+        {
+            aprintf(&quot;\t size for all %lu frames : %lu\n&quot;,nbSz,SzIndentical);
+            for(i=0;i&lt;nbSz;i++)
+            {
+                    track-&gt;index[i].size=SzIndentical;
+                    
+            }
+          }
+          else // Different size
+          {
+            for(i=0;i&lt;nbSz;i++)
+            {
+                    track-&gt;index[i].size=Sz[i];
+                    aprintf(&quot;\t size : %d : %lu\n&quot;,i,Sz[i]);
+            }
+          }
+	// if no sample to chunk we map directly
+	// first build the # of sample per chunk table
+        uint32_t totalchunk=0,max=0;
+
+        // Search the maximum
+        for(i=0;i&lt;nbSc-1;i++)
+        {
+                totalchunk+=(Sc[i+1]-Sc[i])*Sn[i];
+        }
+        totalchunk+=(nbCo-Sc[nbSc-1]+1)*Sn[nbSc-1];
+
+        printf(&quot;#of chunk %d max per chunk %d Max # of sample %d\n&quot;,nbCo,max,totalchunk);
+
+        uint32_t chunkCount[totalchunk+1];
+	for(i=0;i&lt;nbSc;i++)
+	{
+		for(j=Sc[i]-1;j&lt;nbCo;j++)
+		{
+			chunkCount[j]=Sn[i];
+                        ADM_assert(j&lt;=totalchunk);
+		}
+		aprintf(&quot;(%d) sc: %lu sn:%lu\n&quot;,i,Sc[i],Sn[i]);
+	}
+/*			for(j=0;j&lt;nbSc;j++)
+			{
+				aprintf(&quot;\n count number : %d - %lu\n&quot;,j,Sn[j]);
+			}*/
+	// now we have for each chunk the number of sample in it
+	cur=0;
+	for(j=0;j&lt;nbCo;j++)
+	{
+		int tail=0;
+		aprintf(&quot;--starting at %lu , %lu to go\n&quot;,Co[j],chunkCount[j]);
+		for(uint32_t k=0;k&lt;chunkCount[j];k++)
+		{
+                        track-&gt;index[cur].offset=Co[j]+tail;
+                        tail+=track-&gt;index[cur].size;
+                        aprintf(&quot; sample : %d offset : %lu\n&quot;,cur,track-&gt;index[cur].offset);
+			aprintf(&quot;Tail : %lu\n&quot;,tail);
+			cur++;
+		}
+
+
+	}
+        
+        
+        track-&gt;nbIndex=cur;;
+	
+	
+	// Now deal with duration
+	// the unit is us FIXME, probably said in header
+	// we put each sample duration in the time entry
+	// then sum them up to get the absolute time position
+
+        uint32_t nbChunk=track-&gt;nbIndex;
+	if(nbStts)		//uint32_t nbStts,	uint32_t *SttsN,uint32_t SttsC,
+	{
+		uint32_t start=0;
+		if(nbStts&gt;1)
+		{
+			for(uint32_t i=0;i&lt;nbStts;i++)
+			{
+				for(uint32_t j=0;j&lt;SttsN[i];j++)
+				{
+                                        track-&gt;index[start].time=(uint64_t)SttsC[i];
+					start++;
+					ADM_assert(start&lt;=nbChunk);
+				}	
+			}
+		}
+		else
+		{
+			// All same duration
+			for(uint32_t i=0;i&lt;nbChunk;i++)
+                                track-&gt;index[i].time=(uint64_t)SttsC[0]; // this is not an error!
+		
+		}
+		// now collapse
+		uint64_t total=0;
+		float    ftot;
+		uint32_t thisone;
+		
+		for(uint32_t i=0;i&lt;nbChunk;i++)
+		{
+                        thisone=track-&gt;index[i].time;
+			ftot=total;
+			ftot*=1000.*1000.;
+			ftot/=myScale;
+                        track-&gt;index[i].time=(uint64_t)floor(ftot);
+			total+=thisone;
+                        aprintf(&quot;Audio chunk : %lu time :%lu\n&quot;,i,track-&gt;index[i].time);
+		}
+		// Time is now built, it is in us
+	
+	
+	}
+	else // there is not ssts
+	{
+          GUI_Error_HIG(_(&quot;No stts table&quot;), NULL);
+		ADM_assert(0);	
+	}
+	return 1;
+}
+//
+//	That tag are coded like this
+//	Each 8 bits is in fact a 7 Bits part while b7=1
+// 	So we concanate them while possible
+uint32_t _3GPHeader::readPackedLen(adm_atom *tom )
+{
+	uint32_t len=0;
+	uint8_t	 b=0;
+
+	do
+	{
+	b=tom-&gt;read();
+	len=len&lt;&lt;7;
+	len+=b&amp;0x7f;
+	}while(b&amp;0x80);
+	return len;
+}
+//
+//	Update a index with the sync track that gives the intra frame position
+//
+uint8_t 	_3GPHeader::sync(_3gpIndex *idx,uint32_t index_size, uint32_t sync_size,uint32_t *sync)
+{
+	ADM_assert(index_size&gt;=sync_size);
+	for(uint32_t i=0;i&lt;sync_size;i++)
+	{
+		idx[sync[i]-1].intra=AVI_KEY_FRAME;
+	}
+	return 1;
+
+}
+uint32_t              _3GPHeader::ptsDtsDelta(uint32_t frame)
+{
+   if(frame &gt;= _videostream.dwLength) return 0;
+   return VDEO.index[frame].deltaPtsDts;
+}
+uint8_t _3GPHeader::getFrameSize (uint32_t frame, uint32_t * size){
+  if(frame &gt;= _videostream.dwLength) return 0;
+  *size = VDEO.index[frame].size;
+  return 1;
+}
+  uint8_t   _3GPHeader::changeAudioStream(uint32_t newstream)
+{
+        if(newstream&gt;nbAudioTrack) return 0;
+        _currentAudioTrack=newstream;
+        return 1;
+}
+uint32_t     _3GPHeader::getCurrentAudioStreamNumber(void) 
+{ 
+    return _currentAudioTrack;
+}
+ uint8_t   _3GPHeader::getAudioStreamsInfo(uint32_t *nbStreams, audioInfo **infos)
+{
+        *nbStreams=nbAudioTrack;
+        if(nbAudioTrack)
+        {
+            *infos=new audioInfo[nbAudioTrack];
+            for(int i=0;i&lt;nbAudioTrack;i++)
+            {
+                WAV2AudioInfo(&amp;(_tracks[i+1]._rdWav),&amp;((*infos)[i]));
+            }
+                
+             //   (*infos)[i]=_tracks[i+1]._rdWav.encoding;
+        }
+        return 1;
+}
+uint8_t                 _3GPHeader::isReordered( void )
+{ 
+        return _reordered;
+}
+/***************************************/
+uint8_t _3GPHeader::reorder( void )
+{
+
+        if( _reordered) return 1;
+        printf(&quot;Reordering...\n&quot;);
+#define INDEX_TMPL        _3gpIndex
+#define INDEX_ARRAY_TMPL  (VDEO.index)
+#define FRAMETYPE_TMPL    intra
+  
+#include &quot;ADM_video/ADM_reorderTemplate.cpp&quot;
+
+#undef INDEX_TMPL       
+#undef INDEX_ARRAY_TMPL 
+#undef FRAMETYPE_TMPL   
+        VDEO.nbIndex= _mainaviheader.dwTotalFrames;
+        // last frame cannot be B frame
+        index[last].intra&amp;=~AVI_B_FRAME;
+          _reordered=ret;
+        return ret;
+
+}

Added: branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mp4/ADM_mp4.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mp4/ADM_mp4.h	2007-05-03 14:40:06 UTC (rev 3012)
+++ branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mp4/ADM_mp4.h	2007-05-03 14:42:31 UTC (rev 3013)
@@ -0,0 +1,159 @@
+/***************************************************************************
+                          ADM_pics.h  -  description
+                             -------------------
+    begin                : Mon Jun 3 2002
+    copyright            : (C) 2002 by mean
+    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+ 
+
+
+#ifndef __3GPHEADER__
+#define __3GPHEADER__
+#include &quot;avifmt.h&quot;
+#include &quot;avifmt2.h&quot;
+
+#include &quot;ADM_editor/ADM_Video.h&quot;
+#include &quot;ADM_audio/aviaudio.hxx&quot;
+#include &quot;ADM_3gp/ADM_atom.h&quot;
+
+typedef struct _3gpIndex
+{
+	uint64_t offset;
+	uint64_t size;
+	uint32_t intra;
+	uint64_t time;
+        uint32_t deltaPtsDts;
+
+}_3gpIndex;
+class _3gpTrack
+{
+public:
+    _3gpIndex   *index;
+    uint32_t    id;
+    uint32_t    nbIndex;
+    uint32_t    extraDataSize;
+    uint8_t     *extraData;
+    WAVHeader   _rdWav;
+                _3gpTrack(void);
+                ~_3gpTrack();
+};
+
+//
+//	Audio track
+//
+class _3gpAudio : public AVDMGenericAudioStream
+{
+protected:
+
+           	uint32_t 					_nb_chunks;
+		uint64_t					_abs_position;
+		uint32_t					_rel_position;
+
+              	uint32_t 					_current_index;
+	    	_3gpIndex 					*_index;
+		FILE						*_fd;
+		uint32_t					_extraLen;
+		uint8_t						*_extraData;
+		uint32_t                                         _audioDuration;
+		
+		
+public:
+					_3gpAudio(FILE *fd,_3gpTrack *trak);
+// _3gpIndex *idx,
+// 						uint32_t nbchunk, FILE * fd,WAVHeader *incoming,
+// 						uint32_t extraLen,uint8_t *extraData,uint32_t duration);
+	virtual				~_3gpAudio();
+        virtual uint32_t 		read(uint32_t len,uint8_t *buffer);
+        virtual uint8_t  		goTo(uint32_t newoffset);
+		   uint8_t			getNbChunk(uint32_t *ch);
+	virtual uint8_t 		getPacket(uint8_t *dest, uint32_t *len, uint32_t *samples);
+	virtual uint8_t 		goToTime(uint32_t mstime);
+	virtual uint8_t			extraData(uint32_t *l,uint8_t **d);
+
+};
+
+#define _3GP_MAX_TRACKS 8
+#define VDEO _tracks[0]
+#define ADIO _tracks[nbAudioTrack+1]._rdWav
+class _3GPHeader         :public vidHeader
+{
+protected:
+          uint8_t                       _reordered;		
+	  FILE 				*_fd;
+          _3gpTrack                     _tracks[_3GP_MAX_TRACKS];
+	  uint32_t                      _audioDuration;
+          uint32_t                      _currentAudioTrack;
+	uint8_t 			parseAtomTree(adm_atom *atom);
+	  _3gpAudio			*_audioTracks[_3GP_MAX_TRACKS-1];
+	uint8_t 			sync(_3gpIndex *idx,uint32_t index_size, uint32_t sync_size,uint32_t *sync);
+         uint32_t  nbAudioTrack;
+	 uint32_t *Sz,*Co,*Sc;
+	 uint32_t *Sn,*Sync;
+	 uint32_t *SttsN,*SttsC,*Ctts,nbCtts;
+         uint32_t _videoScale;
+
+	uint8_t		buildIndex(	_3gpTrack *track,
+					uint32_t scale,
+					uint32_t nbSz,		uint32_t *Sz, uint32_t szIndentical,
+					uint32_t nbChunk ,	uint32_t *Chunk,
+					uint32_t nbSc,		uint32_t *Sc,
+					uint32_t nbStts,uint32_t *SttsN,uint32_t *SttsC,
+					uint32_t *Sn,			uint32_t *outNbChunk,
+                                            uint32_t isAudio
+					);
+	uint32_t 		readPackedLen(adm_atom *tom );
+	
+public:
+        uint8_t               hasPtsDts(void) {return 1;} // Return 1 if the container gives PTS &amp; DTS info
+        uint32_t              ptsDtsDelta(uint32_t framenum);
+virtual   void 				Dump(void) {};
+virtual   uint32_t 			getNbStream(void) ;
+virtual   uint8_t 			needDecompress(void) { return 1;};
+
+			_3GPHeader( void ) ;
+                        virtual	~_3GPHeader(  ) ;
+// AVI io
+virtual 	uint8_t			open(char *name);
+virtual 	uint8_t			close(void) ;
+  //__________________________
+  //				 Info
+  //__________________________
+virtual   uint8_t                       getExtraHeaderData(uint32_t *len, uint8_t **data);
+  //__________________________
+  //				 Audio
+  //__________________________
+
+virtual 	WAVHeader 	*getAudioInfo(void ); 
+virtual 	uint8_t		getAudioStream(AVDMGenericAudioStream **audio);
+
+// Frames
+  //__________________________
+  //				 video
+  //__________________________
+
+virtual 	uint8_t  setFlag(uint32_t frame,uint32_t flags);
+virtual 	uint32_t getFlags(uint32_t frame,uint32_t *flags);
+virtual 	uint8_t  getFrameNoAlloc(uint32_t framenum,ADMCompressedImage *img);
+ virtual     uint8_t getFrameSize (uint32_t frame, uint32_t * size);
+// Multi track
+uint8_t        changeAudioStream(uint32_t newstream);
+uint32_t     getCurrentAudioStreamNumber(void);
+uint8_t     getAudioStreamsInfo(uint32_t *nbStreams, audioInfo **infos);
+uint8_t      isReordered( void );
+uint8_t      reorder( void );
+
+};
+
+#endif
+
+

Added: branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mp4/ADM_mp4audio.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mp4/ADM_mp4audio.cpp	2007-05-03 14:40:06 UTC (rev 3012)
+++ branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mp4/ADM_mp4audio.cpp	2007-05-03 14:42:31 UTC (rev 3013)
@@ -0,0 +1,207 @@
+/***************************************************************************
+                          ADM_3gpAudio.cpp  -  description
+                             -------------------
+
+	Provide access to the audio track embedded in 3gp file
+	It can be either AMR NB/WB/ AAC
+	The most common being AMR NB
+
+ ***************************************************************************
+
+    begin                : Tue Jul 23 2003
+    copyright            : (C) 2002/2005 by mean
+    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include &quot;config.h&quot;
+
+
+#include &lt;stdio.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;string.h&gt;
+#include &quot;math.h&quot;
+#include &lt;ADM_assert.h&gt;
+
+#include &quot;default.h&quot;
+#include &quot;ADM_editor/ADM_Video.h&quot;
+#include &quot;fourcc.h&quot;
+#include &quot;ADM_3gp/ADM_3gp.h&quot;
+//_______________________________________________________
+//
+//
+//_______________________________________________________
+
+// _3gpAudio::_3gpAudio(_3gpIndex *idx, uint32_t nbchunk, FILE * fd,WAVHeader *incoming,uint32_t extraLen,uint8_t *extraData,uint32_t duration)
+_3gpAudio::_3gpAudio(FILE *fd,_3gpTrack *track)
+{
+	_nb_chunks=track-&gt;nbIndex;
+	_fd=fd;
+	_current_index=0;
+	_abs_position=0;
+	_rel_position=0;
+	_pos=0;
+	_index=track-&gt;index;
+
+	_extraLen=track-&gt;extraDataSize;
+	_extraData=track-&gt;extraData;
+	
+	_wavheader=new WAVHeader;
+        memcpy(_wavheader,&amp;(track-&gt;_rdWav),sizeof(WAVHeader));
+	
+
+	_destroyable=1;	
+	strcpy(_name,&quot;3gp audio&quot;);	
+	// compute length
+	_length=0;
+	for(uint32_t i=0;i&lt;_nb_chunks;i++)
+		{
+			_length+=track-&gt;index[i].size;
+		}
+	printf(&quot;\n 3gp audio : %lu bytes (%lu chunks)\n&quot;,_length,_nb_chunks);
+
+	printf(&quot;Byterate     :%d\n&quot;,_wavheader-&gt;byterate);
+	printf(&quot;Frequency :%d\n&quot;,_wavheader-&gt;frequency);
+	printf(&quot;Encoding   :%d\n&quot;,_wavheader-&gt;encoding);
+	printf(&quot;Channels   :%d\n&quot;,_wavheader-&gt;channels);
+	printf(&quot;Extra data :%lu\n&quot;,_extraLen);
+        if(_nb_chunks)
+            _audioDuration=_index[_nb_chunks-1].time;
+       // _wavheader-&gt;frequency=48000;
+    	goToTime(0);
+}
+ uint8_t	_3gpAudio::goToTime(uint32_t mstime)
+{
+uint64_t target=mstime;
+		target*=1000; // us
+		if(target&gt;_index[_nb_chunks-1].time)
+		{
+			printf(&quot;3GP: going out of time asked %lu : avail %lu\n&quot;,mstime,_index[_nb_chunks-1].time/1000);
+			_current_index=_nb_chunks-1;
+			return 1;
+		}
+		for(uint32_t i=0;i&lt;_nb_chunks;i++)
+		{
+			if(_index[i].time &gt;= target)
+			{
+				_current_index=i;
+				printf(&quot;3gp Go to time succeeded chunk :%lu time ask:%lu time get:%lu\n&quot;,i,mstime,
+						_index[i].time/1000);
+				return 1;
+			}
+		
+		}
+		printf(&quot;3GP: gototime Failed\n&quot;);
+		return 0;
+}
+//_______________________________________________________
+//
+//
+//_______________________________________________________
+uint8_t _3gpAudio::goTo(uint32_t newoffset)
+{
+   ADM_assert(0);
+    return 1;
+}
+//______________________________________
+uint8_t _3gpAudio::getPacket(uint8_t *dest, uint32_t *len, uint32_t *samples)
+{
+
+uint32_t r=0;
+double delta;
+	if(_current_index&gt;=_nb_chunks)  return 0;
+	
+	  fseeko(_fd,_index[_current_index].offset,SEEK_SET);
+	  r=fread(dest,1,_index[_current_index].size,_fd);
+	  if(_current_index==_nb_chunks-1)
+	  {
+	  	
+                // Assume the last sample is the same size as the previous one
+	  	//*samples=1024;
+                delta=_index[_nb_chunks-1].time;
+                delta=delta/1000;
+                if(_audioDuration&gt;delta)
+                {
+                        delta=_audioDuration-delta;
+                        // delta is the duration of the current chunk in us
+                        delta*=_wavheader-&gt;frequency;
+                        delta/=1000.; // mss -&gt; second
+                        *samples=(uint32_t)floor(delta);
+                }else *samples=1024;
+                printf(&quot;3gp: Last sample %d current chunk %d nb chunk %d\n&quot;,
+                                *samples,_current_index,_nb_chunks);
+                
+	  }
+	  else
+	  {
+	  	
+		delta=_index[_current_index+1].time-_index[_current_index].time;
+		
+		// delta is the duration of the current chunk in us
+		delta*=_wavheader-&gt;frequency;
+		delta/=1000.*1000.; // us -&gt; second
+		*samples=(uint32_t)floor(delta);
+	  
+	  }
+	  _current_index++;
+	  *len=r;
+	  
+	  
+	  return 1;
+}
+//_______________________________________________________
+//
+//
+//_______________________________________________________
+
+uint8_t	_3gpAudio::extraData(uint32_t *l,uint8_t **d)
+{
+	if(_extraLen &amp;&amp; _extraData)
+	{
+		*l=_extraLen;
+		*d=_extraData;
+		return 1;
+	
+	}
+	*l=0;
+	*d=NULL;
+	return 0;
+}
+
+//_______________________________________________________
+//
+//
+//_______________________________________________________
+uint32_t _3gpAudio::read(uint32_t len,uint8_t *buffer)
+{
+    uint32_t size,samples;
+    if(!getPacket(buffer,&amp;size,&amp;samples)) return 0;
+    return size;
+    
+
+}
+//_______________________________________________________
+//
+//
+//_______________________________________________________
+
+
+_3gpAudio::~_3gpAudio()
+{
+	// nothing special to do...
+	delete _wavheader;
+	_wavheader=NULL;
+}
+//_______________________________________________________
+uint8_t _3gpAudio::getNbChunk(uint32_t *ch)
+{
+	*ch=_nb_chunks;
+	return 1;
+}

Added: branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mp4/Makefile.am
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mp4/Makefile.am	2007-05-03 14:40:06 UTC (rev 3012)
+++ branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mp4/Makefile.am	2007-05-03 14:42:31 UTC (rev 3013)
@@ -0,0 +1,11 @@
+noinst_LIBRARIES = libADM_3gp.a
+
+INCLUDES = $(all_includes)  -I../../ADM_libraries -I../../ADM_libraries/ADM_utilities   -I../../ADM_libraries/ADM_lavutil
+
+libADM_3gph263_a_METASOURCES = AUTO
+
+libADM_3gp_a_SOURCES = ADM_3gp.cpp ADM_3gpAudio.cpp ADM_atom.cpp ADM_3gp.h ADM_atom.h ADM_infoextractor.cpp
+
+EXTRA_DIST= ADM_3gp.cpp  ADM_3gp.h  ADM_3gpAudio.cpp  ADM_atom.cpp  ADM_atom.h  ADM_infoextractor.cpp
+
+


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000323.html">[Avidemux-svn-commit] r3012 -	branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialogFactory
</A></li>
	<LI>Next message: <A HREF="000325.html">[Avidemux-svn-commit] r3016 -	branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#324">[ date ]</a>
              <a href="thread.html#324">[ thread ]</a>
              <a href="subject.html#324">[ subject ]</a>
              <a href="author.html#324">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">More information about the Avidemux-svn-commit
mailing list</a><br>
</body></html>
