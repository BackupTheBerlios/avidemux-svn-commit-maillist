From gruntster at mail.berlios.de  Sat Aug  1 00:24:47 2009
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Sat, 1 Aug 2009 00:24:47 +0200
Subject: [Avidemux-svn-commit] r5184 - in
	branches/avidemux_2.5_branch_gruntster/avidemux/ADM_UIs:
	ADM_GTK/src ADM_QT4/src
Message-ID: <200907312224.n6VMOlYR019837@sheep.berlios.de>

Author: gruntster
Date: 2009-08-01 00:24:31 +0200 (Sat, 01 Aug 2009)
New Revision: 5184

Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_UIs/ADM_GTK/src/FAC_menu.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_UIs/ADM_QT4/src/T_menu.cpp
Log:
[dlgFactory] make updateMe method of menu control work

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_UIs/ADM_GTK/src/FAC_menu.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_UIs/ADM_GTK/src/FAC_menu.cpp	2009-07-30 21:41:40 UTC (rev 5183)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_UIs/ADM_GTK/src/FAC_menu.cpp	2009-07-31 22:24:31 UTC (rev 5184)
@@ -1,294 +1,305 @@
-/***************************************************************************
-  FAC_toggle.cpp
-  Handle dialog factory element : Menu
-  (C) 2006 Mean Fixounet at free.fr 
-***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-#include "ADM_toolkitGtk.h"
-#include "DIA_factory.h"
-namespace ADM_GtkFactory
-{
-static void cb_menu(void *w,void *p);
-static void cb_menus(void *w,void *p);
-
-
-class diaElemMenuDynamic : public diaElemMenuDynamicBase
-{
-protected:
-	
-
-public:
-  diaElemMenuDynamic(uint32_t *intValue,const char *itle, uint32_t nb, 
-               diaMenuEntryDynamic **menu,const char *tip=NULL);
-  
-  virtual   ~diaElemMenuDynamic() ;
-  void      setMe(void *dialog, void *opaque,uint32_t line);
-  void      getMe(void);
-  virtual uint8_t   link(diaMenuEntryDynamic *entry,uint32_t onoff,diaElem *w);
-  virtual void      updateMe(void);
-  virtual void      enable(uint32_t onoff) ;
-  virtual void      finalize(void);
-  int getRequiredLayout(void);
-};
-//**********************
-class diaElemMenu : public diaElemMenuBase
-{
-protected:
-	
-
-	diaElemMenuDynamic  *dyna;
-	diaMenuEntryDynamic  **menus;	
-public:
-  diaElemMenu(uint32_t *intValue,const char *itle, uint32_t nb, 
-               const diaMenuEntry *menu,const char *tip=NULL);
-  
-  virtual ~diaElemMenu() ;
-  void setMe(void *dialog, void *opaque,uint32_t line);
-  void getMe(void);
-  virtual uint8_t   link(diaMenuEntry *entry,uint32_t onoff,diaElem *w);
-  virtual void      updateMe(void);
-  void      enable(uint32_t onoff) ;
-  void      finalize(void);
-  int getRequiredLayout(void);
-};
-//**********************
-diaElemMenu::diaElemMenu(uint32_t *intValue,const char *itle, uint32_t nb, 
-               const diaMenuEntry *menu,const char *tip)
-  : diaElemMenuBase()
-{
-  param=(void *)intValue;
-  paramTitle=itle;
-  this->tip=tip;
-  this->menu=menu;
-  this->nbMenu=nb;
-  nbLink=0;
-  
-  menus=new diaMenuEntryDynamic * [nb];
-  for(int i=0;i<nb;i++)
-  {
-    menus[i]=new  diaMenuEntryDynamic(menu[i].val,menu[i].text,menu[i].desc);
-  }
-  dyna=new diaElemMenuDynamic(intValue,itle,nb,menus,tip);
-}
-
-diaElemMenu::~diaElemMenu()
-{
-  for(int i=0;i<nbMenu;i++)
-      delete menus[i];
-  delete [] menus;
-  delete dyna;
-  
-}
-void diaElemMenu::setMe(void *dialog, void *opaque,uint32_t line)
-{
-  dyna->setMe(dialog,opaque,line);
-}
-
-void diaElemMenu::getMe(void)
-{
- dyna->getMe();
-}
-void   diaElemMenu::updateMe(void)
-{
-  dyna->updateMe();
-}
-uint8_t   diaElemMenu::link(diaMenuEntry *entry,uint32_t onoff,diaElem *w)
-{
-    for(int i=0;i<nbMenu;i++)
-    {
-        if(entry->val==menus[i]->val)
-            return dyna->link(menus[i],onoff,w);
-    }
-    ADM_assert(0);
-}
-void   diaElemMenu::enable(uint32_t onoff)
-{
-  dyna->enable(onoff);
-}
-void   diaElemMenu::finalize(void)
-{
-  dyna->finalize();
-}
-
-int diaElemMenu::getRequiredLayout(void) { return 0; }
-
-//*******************************
-diaElemMenuDynamic::diaElemMenuDynamic(uint32_t *intValue,const char *itle, uint32_t nb, 
-                diaMenuEntryDynamic **menu,const char *tip)
-  : diaElemMenuDynamicBase()
-{
-  param=(void *)intValue;
-  paramTitle=itle;
-  this->tip=tip;
-  this->menu=menu;
-  this->nbMenu=nb;
-  nbLink=0;
-}
-
-diaElemMenuDynamic::~diaElemMenuDynamic()
-{
-  
-}
-void diaElemMenuDynamic::setMe(void *dialog, void *opaque,uint32_t line)
-{
-  GtkWidget *widget;
-  GtkWidget *label;
-  GtkWidget *item;
-  GtkWidget *combo;
-  
-  
-  label = gtk_label_new_with_mnemonic (paramTitle);
-  gtk_misc_set_alignment (GTK_MISC (label), 0.0, 0.5);
-  gtk_widget_show(label);
-  
-  gtk_table_attach (GTK_TABLE (opaque), label, 0, 1, line, line+1,
-                    (GtkAttachOptions) (GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-  
-  combo = gtk_combo_box_new_text ();
-  gtk_widget_show (combo);
-  gtk_table_attach (GTK_TABLE (opaque), combo, 1, 2, line, line+1,
-                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-  
-  gtk_label_set_mnemonic_widget (GTK_LABEL(label), combo);
-  
-  for(int i=0;i<nbMenu;i++)
-  {
-    gtk_combo_box_append_text (GTK_COMBO_BOX (combo),menu[i]->text);
-  }
-  
-  for(int i=0;i<nbMenu;i++)
-  {
-    if(menu[i]->val==*(uint32_t *)param) 
-    {
-      gtk_combo_box_set_active(GTK_COMBO_BOX(combo),i);
-    }
-  }
-  myWidget=(void *)combo;
-  gtk_signal_connect(GTK_OBJECT(combo), "changed",
-                      GTK_SIGNAL_FUNC(cb_menu),
-                      (void *) this);
-  
-}
-
-void diaElemMenuDynamic::getMe(void)
-{
-  GtkWidget *widget=(GtkWidget *)myWidget;
-  uint32_t *val=(uint32_t *)param;
-  uint32_t rank;
-  if(!nbMenu) return;
-  ADM_assert(widget);
-  
-  
-  rank=gtk_combo_box_get_active(GTK_COMBO_BOX(widget));
-  ADM_assert(rank<this->nbMenu);
-  *(uint32_t *)param=this->menu[rank]->val;
-}
-
-uint8_t   diaElemMenuDynamic::link(diaMenuEntryDynamic *entry,uint32_t onoff,diaElem *w)
-{
-    ADM_assert(nbLink<MENU_MAX_lINK);
-    links[nbLink].value=entry->val;
-    links[nbLink].onoff=onoff;
-    links[nbLink].widget=w;
-    nbLink++;
-    return 1;
-}
-
-void   diaElemMenuDynamic::updateMe(void)
-{
-  GtkWidget *widget=(GtkWidget *)myWidget;
-  uint32_t val;
-  uint32_t rank;
-  if(!nbMenu) return;
-  ADM_assert(widget);
-  
-  
-  rank=gtk_combo_box_get_active(GTK_COMBO_BOX(widget));
-  ADM_assert(rank<this->nbMenu);
-  val=this->menu[rank]->val;
-  /* Now search through the linked list to see if something happens ...*/
-  
-   /* 1 disable everything */
-  for(int i=0;i<nbLink;i++)
-  {
-    dialElemLink *l=&(links[i]);
-    if(l->value==val)
-    {
-      if(!l->onoff)  l->widget->enable(0);
-    }else
-    {
-       if(l->onoff)  l->widget->enable(0);
-    }
-    
-  }
-  /* Then enable */
-  for(int i=0;i<nbLink;i++)
-  {
-    dialElemLink *l=&(links[i]);
-    if(l->value==val)
-    {
-      if(l->onoff)  l->widget->enable(1);
-    }else
-    {
-       if(!l->onoff)  l->widget->enable(1);
-    }
-    
-  }
-}
-void   diaElemMenuDynamic::finalize(void)
-{
-  updateMe(); 
-}
-void   diaElemMenuDynamic::enable(uint32_t onoff)
-{
-  gtk_widget_set_sensitive(GTK_WIDGET(myWidget),onoff);  
-}
-
-int diaElemMenuDynamic::getRequiredLayout(void) { return 0; }
-
-//** C callback **
-void cb_menu(void *w,void *p)
-{
-  diaElemMenuDynamic *me=(diaElemMenuDynamic *)p;
-  me->updateMe();
-}
-void cb_menus(void *w,void *p)
-{
-  diaElemMenu *me=(diaElemMenu *)p;
-  me->updateMe();
-}
-//********************
-}; // End of namespace
-
-diaElem  *gtkCreateMenu(uint32_t *intValue,const char *itle, uint32_t nb,         const diaMenuEntry *menu,const char *tip)
-{
-	return new  ADM_GtkFactory::diaElemMenu(intValue,itle,nb,menu,tip);
-}
-void gtkDestroyMenu(diaElem *e)
-{
-	ADM_GtkFactory::diaElemMenu *a=(ADM_GtkFactory::diaElemMenu *)e;
-	delete a;
-}
-diaElem  *gtkCreateMenuDynamic(uint32_t *intValue,const char *itle, uint32_t nb, 
-        diaMenuEntryDynamic **menu,const char *tipp)
-{
-	return new  ADM_GtkFactory::diaElemMenuDynamic(intValue,itle,nb,menu,tipp);
-}
-void gtkDestroyMenuDynamic(diaElem *e)
-{
-	ADM_GtkFactory::diaElemMenuDynamic *a=(ADM_GtkFactory::diaElemMenuDynamic *)e;
-	delete a;
-}
-
-//EOF
+/***************************************************************************
+  FAC_toggle.cpp
+  Handle dialog factory element : Menu
+  (C) 2006 Mean Fixounet at free.fr 
+***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include "ADM_toolkitGtk.h"
+#include "DIA_factory.h"
+namespace ADM_GtkFactory
+{
+static void cb_menu(void *w,void *p);
+static void cb_menus(void *w,void *p);
+
+
+class diaElemMenuDynamic : public diaElemMenuDynamicBase
+{
+protected:
+	
+
+public:
+  diaElemMenuDynamic(uint32_t *intValue,const char *itle, uint32_t nb, 
+               diaMenuEntryDynamic **menu,const char *tip=NULL);
+  
+  virtual   ~diaElemMenuDynamic() ;
+  void      setMe(void *dialog, void *opaque,uint32_t line);
+  void      getMe(void);
+  virtual uint8_t   link(diaMenuEntryDynamic *entry,uint32_t onoff,diaElem *w);
+  virtual void      updateMe(void);
+  virtual void      enable(uint32_t onoff) ;
+  virtual void      finalize(void);
+  int getRequiredLayout(void);
+};
+//**********************
+class diaElemMenu : public diaElemMenuBase
+{
+protected:
+	
+
+	diaElemMenuDynamic  *dyna;
+	diaMenuEntryDynamic  **menus;	
+public:
+  diaElemMenu(uint32_t *intValue,const char *itle, uint32_t nb, 
+               const diaMenuEntry *menu,const char *tip=NULL);
+  
+  virtual ~diaElemMenu() ;
+  void setMe(void *dialog, void *opaque,uint32_t line);
+  void getMe(void);
+  virtual uint8_t   link(diaMenuEntry *entry,uint32_t onoff,diaElem *w);
+  virtual void      updateMe(void);
+  void      enable(uint32_t onoff) ;
+  void      finalize(void);
+  int getRequiredLayout(void);
+};
+//**********************
+diaElemMenu::diaElemMenu(uint32_t *intValue,const char *itle, uint32_t nb, 
+               const diaMenuEntry *menu,const char *tip)
+  : diaElemMenuBase()
+{
+  param=(void *)intValue;
+  paramTitle=itle;
+  this->tip=tip;
+  this->menu=menu;
+  this->nbMenu=nb;
+  nbLink=0;
+  
+  menus=new diaMenuEntryDynamic * [nb];
+  for(int i=0;i<nb;i++)
+  {
+    menus[i]=new  diaMenuEntryDynamic(menu[i].val,menu[i].text,menu[i].desc);
+  }
+  dyna=new diaElemMenuDynamic(intValue,itle,nb,menus,tip);
+}
+
+diaElemMenu::~diaElemMenu()
+{
+  for(int i=0;i<nbMenu;i++)
+      delete menus[i];
+  delete [] menus;
+  delete dyna;
+  
+}
+void diaElemMenu::setMe(void *dialog, void *opaque,uint32_t line)
+{
+  dyna->setMe(dialog,opaque,line);
+}
+
+void diaElemMenu::getMe(void)
+{
+ dyna->getMe();
+}
+void   diaElemMenu::updateMe(void)
+{
+  dyna->updateMe();
+}
+uint8_t   diaElemMenu::link(diaMenuEntry *entry,uint32_t onoff,diaElem *w)
+{
+    for(int i=0;i<nbMenu;i++)
+    {
+        if(entry->val==menus[i]->val)
+            return dyna->link(menus[i],onoff,w);
+    }
+    ADM_assert(0);
+}
+void   diaElemMenu::enable(uint32_t onoff)
+{
+  dyna->enable(onoff);
+}
+void   diaElemMenu::finalize(void)
+{
+  dyna->finalize();
+}
+
+int diaElemMenu::getRequiredLayout(void) { return 0; }
+
+//*******************************
+diaElemMenuDynamic::diaElemMenuDynamic(uint32_t *intValue,const char *itle, uint32_t nb, 
+                diaMenuEntryDynamic **menu,const char *tip)
+  : diaElemMenuDynamicBase()
+{
+  param=(void *)intValue;
+  paramTitle=itle;
+  this->tip=tip;
+  this->menu=menu;
+  this->nbMenu=nb;
+  nbLink=0;
+}
+
+diaElemMenuDynamic::~diaElemMenuDynamic()
+{
+  
+}
+void diaElemMenuDynamic::setMe(void *dialog, void *opaque,uint32_t line)
+{
+  GtkWidget *widget;
+  GtkWidget *label;
+  GtkWidget *item;
+  GtkWidget *combo;
+  
+  
+  label = gtk_label_new_with_mnemonic (paramTitle);
+  gtk_misc_set_alignment (GTK_MISC (label), 0.0, 0.5);
+  gtk_widget_show(label);
+  
+  gtk_table_attach (GTK_TABLE (opaque), label, 0, 1, line, line+1,
+                    (GtkAttachOptions) (GTK_FILL),
+                    (GtkAttachOptions) (0), 0, 0);
+  
+  combo = gtk_combo_box_new_text ();
+  gtk_widget_show (combo);
+  gtk_table_attach (GTK_TABLE (opaque), combo, 1, 2, line, line+1,
+                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
+                    (GtkAttachOptions) (0), 0, 0);
+  
+  gtk_label_set_mnemonic_widget (GTK_LABEL(label), combo);
+  
+  for(int i=0;i<nbMenu;i++)
+  {
+    gtk_combo_box_append_text (GTK_COMBO_BOX (combo),menu[i]->text);
+  }
+  
+  for(int i=0;i<nbMenu;i++)
+  {
+    if(menu[i]->val==*(uint32_t *)param) 
+    {
+      gtk_combo_box_set_active(GTK_COMBO_BOX(combo),i);
+    }
+  }
+  myWidget=(void *)combo;
+  gtk_signal_connect(GTK_OBJECT(combo), "changed",
+                      GTK_SIGNAL_FUNC(cb_menu),
+                      (void *) this);
+  
+}
+
+void diaElemMenuDynamic::getMe(void)
+{
+  GtkWidget *widget=(GtkWidget *)myWidget;
+  int rank = gtk_combo_box_get_active(GTK_COMBO_BOX(widget));
+  
+  if (!nbMenu)
+	  return;
+
+  ADM_assert(rank < this->nbMenu);
+  *(uint32_t *)param = this->menu[rank]->val;
+}
+
+uint8_t   diaElemMenuDynamic::link(diaMenuEntryDynamic *entry,uint32_t onoff,diaElem *w)
+{
+    ADM_assert(nbLink<MENU_MAX_lINK);
+    links[nbLink].value=entry->val;
+    links[nbLink].onoff=onoff;
+    links[nbLink].widget=w;
+    nbLink++;
+    return 1;
+}
+
+void diaElemMenuDynamic::updateMe(void)
+{
+	GtkWidget *widget = (GtkWidget*)myWidget;
+
+	for (int i = 0; i < this->nbMenu; i++)
+	{
+		if (this->menu[i]->val == *(uint32_t*)param)
+		{
+			gtk_combo_box_set_active(GTK_COMBO_BOX(widget), i);
+			finalize();
+			break;
+		}
+	}
+}
+
+void   diaElemMenuDynamic::finalize(void)
+{
+  GtkWidget *widget=(GtkWidget *)myWidget;
+  uint32_t val;
+  uint32_t rank;
+  if(!nbMenu) return;
+  ADM_assert(widget);
+  
+  
+  rank=gtk_combo_box_get_active(GTK_COMBO_BOX(widget));
+  ADM_assert(rank<this->nbMenu);
+  val=this->menu[rank]->val;
+  /* Now search through the linked list to see if something happens ...*/
+  
+   /* 1 disable everything */
+  for(int i=0;i<nbLink;i++)
+  {
+    dialElemLink *l=&(links[i]);
+    if(l->value==val)
+    {
+      if(!l->onoff)  l->widget->enable(0);
+    }else
+    {
+       if(l->onoff)  l->widget->enable(0);
+    }
+    
+  }
+  /* Then enable */
+  for(int i=0;i<nbLink;i++)
+  {
+    dialElemLink *l=&(links[i]);
+    if(l->value==val)
+    {
+      if(l->onoff)  l->widget->enable(1);
+    }else
+    {
+       if(!l->onoff)  l->widget->enable(1);
+    }
+    
+  }
+}
+void   diaElemMenuDynamic::enable(uint32_t onoff)
+{
+  gtk_widget_set_sensitive(GTK_WIDGET(myWidget),onoff);  
+}
+
+int diaElemMenuDynamic::getRequiredLayout(void) { return 0; }
+
+//** C callback **
+void cb_menu(void *w,void *p)
+{
+	diaElemMenuDynamic *me=(diaElemMenuDynamic *)p;
+
+	me->finalize();
+}
+
+void cb_menus(void *w,void *p)
+{
+  diaElemMenu *me=(diaElemMenu *)p;
+  me->updateMe();
+}
+//********************
+}; // End of namespace
+
+diaElem  *gtkCreateMenu(uint32_t *intValue,const char *itle, uint32_t nb,         const diaMenuEntry *menu,const char *tip)
+{
+	return new  ADM_GtkFactory::diaElemMenu(intValue,itle,nb,menu,tip);
+}
+void gtkDestroyMenu(diaElem *e)
+{
+	ADM_GtkFactory::diaElemMenu *a=(ADM_GtkFactory::diaElemMenu *)e;
+	delete a;
+}
+diaElem  *gtkCreateMenuDynamic(uint32_t *intValue,const char *itle, uint32_t nb, 
+        diaMenuEntryDynamic **menu,const char *tipp)
+{
+	return new  ADM_GtkFactory::diaElemMenuDynamic(intValue,itle,nb,menu,tipp);
+}
+void gtkDestroyMenuDynamic(diaElem *e)
+{
+	ADM_GtkFactory::diaElemMenuDynamic *a=(ADM_GtkFactory::diaElemMenuDynamic *)e;
+	delete a;
+}
+
+//EOF

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_UIs/ADM_QT4/src/T_menu.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_UIs/ADM_QT4/src/T_menu.cpp	2009-07-30 21:41:40 UTC (rev 5183)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_UIs/ADM_QT4/src/T_menu.cpp	2009-07-31 22:24:31 UTC (rev 5184)
@@ -1,273 +1,285 @@
-/***************************************************************************
-  FAC_toggle.cpp
-  Handle dialog factory element : Toggle
-  (C) 2006 Mean Fixounet at free.fr 
-***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-#include "T_menu.h"
-#include "ADM_default.h"
-#include "ADM_dialogFactoryQt4.h"
-
-#include <QtGui/QGridLayout>
-#include <QtGui/QLabel>
-
-extern const char *shortkey(const char *);
-
-namespace ADM_qt4Factory
-{
-class diaElemMenu : public diaElemMenuBase
-{
-protected:
-	diaElemMenuDynamic  *dyna;
-	diaMenuEntryDynamic  **menus;	
-
-public:
-  diaElemMenu(uint32_t *intValue,const char *itle, uint32_t nb, 
-               const diaMenuEntry *menu,const char *tip=NULL);
-  
-  virtual ~diaElemMenu() ;
-  void setMe(void *dialog, void *opaque,uint32_t line);
-  void getMe(void);
-  virtual uint8_t   link(diaMenuEntry *entry,uint32_t onoff,diaElem *w);
-  virtual void      updateMe(void);
-  void      enable(uint32_t onoff) ;
-  void      finalize(void);;
-  int getRequiredLayout(void);
-};
-
-/**/
-
-ADM_QComboBox::ADM_QComboBox(QWidget *parent, diaElemMenuDynamic *menu) : QComboBox(parent)
-{
-	_menu=menu;
-}
-
-void ADM_QComboBox::changed(int i)
-{
-	_menu->updateMe();
-}
-
-void ADM_QComboBox::connectMe(void)
-{
-	QObject::connect(this, SIGNAL(currentIndexChanged(int)), this, SLOT(changed(int )));
-}
-
-diaElemMenu::diaElemMenu(uint32_t *intValue,const char *itle, uint32_t nb, 
-               const diaMenuEntry *menu,const char *tip)
-  : diaElemMenuBase()
-{
-  param=(void *)intValue;
-  paramTitle=itle;
-  this->tip=tip;
-  this->menu=menu;
-  this->nbMenu=nb;
-  nbLink=0;
-  
-  menus=new diaMenuEntryDynamic * [nb];
-  for(int i=0;i<nb;i++)
-  {
-    menus[i]=new  diaMenuEntryDynamic(menu[i].val,menu[i].text,menu[i].desc);
-  }
-  dyna=new diaElemMenuDynamic(intValue,itle,nb,menus,tip);
-}
-
-diaElemMenu::~diaElemMenu()
-{
-  for(int i=0;i<nbMenu;i++)
-      delete menus[i];
-  delete [] menus;
-  delete dyna;
-  
-}
-void diaElemMenu::setMe(void *dialog, void *opaque,uint32_t line)
-{
-  dyna->setMe(dialog,opaque,line);
-}
-
-void diaElemMenu::getMe(void)
-{
- dyna->getMe();
-}
-void   diaElemMenu::updateMe(void)
-{
-  dyna->updateMe();
-}
-uint8_t   diaElemMenu::link(diaMenuEntry *entry,uint32_t onoff,diaElem *w)
-{
-    for(int i=0;i<nbMenu;i++)
-    {
-        if(entry->val==menus[i]->val)
-            return dyna->link(menus[i],onoff,w);
-    }
-    ADM_assert(0);
-}
-void   diaElemMenu::enable(uint32_t onoff)
-{
-  
-    dyna->enable(onoff);
-}
-void   diaElemMenu::finalize(void)
-{
-  dyna->finalize();
-}
-
-int diaElemMenu::getRequiredLayout(void) { return FAC_QT_GRIDLAYOUT; }
-
-//*********************************
-//* DYNAMIC                       *
-//*********************************
-
-diaElemMenuDynamic::diaElemMenuDynamic(uint32_t *intValue,const char *itle, uint32_t nb, 
-                diaMenuEntryDynamic **menu,const char *tip)
-  : diaElemMenuDynamicBase()
-{
-  param=(void *)intValue;
-  paramTitle=shortkey(itle);
-  this->tip=tip;
-  this->menu=menu;
-  this->nbMenu=nb;
-  nbLink=0;
-}
-
-diaElemMenuDynamic::~diaElemMenuDynamic()
-{
-  if(paramTitle)
-    delete paramTitle;
-}
-void diaElemMenuDynamic::setMe(void *dialog, void *opaque,uint32_t line)
-{
-  ADM_QComboBox *combo=new ADM_QComboBox((QWidget*)dialog, this);
-
-  QGridLayout *layout=(QGridLayout*) opaque;
-     myWidget=(void *)combo; 
-
-	 QLabel *text=new QLabel( QString::fromUtf8(this->paramTitle));
-	 text->setSizePolicy(QSizePolicy::Fixed, QSizePolicy::Fixed);
-
-	 QSpacerItem *spacer = new QSpacerItem(20, 20, QSizePolicy::Expanding, QSizePolicy::Minimum);
-  
-  // Fill in combobox
-  int mem=0;
-  diaMenuEntryDynamic **entries=menu;
-  for(int i=0;i<nbMenu;i++)
-  {
-    combo->addItem(QString::fromUtf8(entries[i]->text));
-    if( *(uint32_t *)param==entries[i]->val) mem=i;
-  }
-   combo->setCurrentIndex(mem);
-   text->setBuddy(combo);
-   layout->addWidget(text,line,0);
-   layout->addWidget(combo,line,1);
-   layout->addItem(spacer,line,2);
-   
-   combo->connectMe();
-}
-
-void diaElemMenuDynamic::getMe(void)
-{
-  ADM_QComboBox *combo=(ADM_QComboBox *)myWidget;
-  int r;
-  r=combo->currentIndex();
-  if(!nbMenu) return;
-  ADM_assert(r<nbMenu);
-  *(uint32_t *)param=menu[r]->val;
-      
-}
-void diaElemMenuDynamic::finalize(void)
-{ 
-   ADM_QComboBox *combo=(ADM_QComboBox *)myWidget;
-  uint32_t val;
-  uint32_t rank;
-  if(!nbMenu) return;
-  ADM_assert(combo);
-  
-  
-  rank=combo->currentIndex();
-  ADM_assert(rank<this->nbMenu);
-  val=this->menu[rank]->val;
-  /* Now search through the linked list to see if something happens ...*/
- 
-   /* 1 disable everything */
-  for(int i=0;i<nbLink;i++)
-  {
-    dialElemLink *l=&(links[i]);
-    if(l->value==val)
-    {
-      if(!l->onoff)  l->widget->enable(FALSE);
-    }else
-    {
-       if(l->onoff)  l->widget->enable(FALSE);
-    }
-    
-  }
-  /* Then enable */
-  for(int i=0;i<nbLink;i++)
-  {
-    dialElemLink *l=&(links[i]);
-    if(l->value==val)
-    {
-      if(l->onoff)  l->widget->enable(TRUE);
-    }else
-    {
-       if(!l->onoff)  l->widget->enable(TRUE);
-    }
-    
-  }
-}
-void diaElemMenuDynamic::enable(uint32_t onoff)
-{ 
-   ADM_QComboBox *combo=(ADM_QComboBox *)myWidget;
-  ADM_assert(combo);
-  if(onoff)
-    combo->setEnabled(true);
-  else
-    combo->setDisabled(true);
-}
-
-uint8_t   diaElemMenuDynamic::link(diaMenuEntryDynamic *entry,uint32_t onoff,diaElem *w)
-{
-    ADM_assert(nbLink<MENU_MAX_lINK);
-    links[nbLink].value=entry->val;
-    links[nbLink].onoff=onoff;
-    links[nbLink].widget=w;
-    nbLink++;
-    return 1;
-}
-void   diaElemMenuDynamic::updateMe(void)
-{
-  finalize();
-}
-
-int diaElemMenuDynamic::getRequiredLayout(void) { return FAC_QT_GRIDLAYOUT; }
-}; // End of namespace
-
-diaElem  *qt4CreateMenu(uint32_t *intValue,const char *itle, uint32_t nb,         const diaMenuEntry *menu,const char *tip)
-{
-	return new  ADM_qt4Factory::diaElemMenu(intValue,itle,nb,menu,tip);
-}
-void qt4DestroyMenu(diaElem *e)
-{
-	ADM_qt4Factory::diaElemMenu *a=(ADM_qt4Factory::diaElemMenu *)e;
-	delete a;
-}
-diaElem  *qt4CreateMenuDynamic(uint32_t *intValue,const char *itle, uint32_t nb, 
-        diaMenuEntryDynamic **menu,const char *tipp)
-{
-	return new  ADM_qt4Factory::diaElemMenuDynamic(intValue,itle,nb,menu,tipp);
-}
-void qt4DestroyMenuDynamic(diaElem *e)
-{
-	ADM_qt4Factory::diaElemMenuDynamic *a=(ADM_qt4Factory::diaElemMenuDynamic *)e;
-	delete a;
-}
-
-//EOF
+/***************************************************************************
+  FAC_toggle.cpp
+  Handle dialog factory element : Toggle
+  (C) 2006 Mean Fixounet at free.fr 
+***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include "T_menu.h"
+#include "ADM_default.h"
+#include "ADM_dialogFactoryQt4.h"
+
+#include <QtGui/QGridLayout>
+#include <QtGui/QLabel>
+
+extern const char *shortkey(const char *);
+
+namespace ADM_qt4Factory
+{
+class diaElemMenu : public diaElemMenuBase
+{
+protected:
+	diaElemMenuDynamic  *dyna;
+	diaMenuEntryDynamic  **menus;	
+
+public:
+  diaElemMenu(uint32_t *intValue,const char *itle, uint32_t nb, 
+               const diaMenuEntry *menu,const char *tip=NULL);
+  
+  virtual ~diaElemMenu() ;
+  void setMe(void *dialog, void *opaque,uint32_t line);
+  void getMe(void);
+  virtual uint8_t   link(diaMenuEntry *entry,uint32_t onoff,diaElem *w);
+  virtual void      updateMe(void);
+  void      enable(uint32_t onoff) ;
+  void      finalize(void);;
+  int getRequiredLayout(void);
+};
+
+/**/
+
+ADM_QComboBox::ADM_QComboBox(QWidget *parent, diaElemMenuDynamic *menu) : QComboBox(parent)
+{
+	_menu=menu;
+}
+
+void ADM_QComboBox::changed(int i)
+{
+	_menu->finalize();
+}
+
+void ADM_QComboBox::connectMe(void)
+{
+	QObject::connect(this, SIGNAL(currentIndexChanged(int)), this, SLOT(changed(int )));
+}
+
+diaElemMenu::diaElemMenu(uint32_t *intValue,const char *itle, uint32_t nb, 
+               const diaMenuEntry *menu,const char *tip)
+  : diaElemMenuBase()
+{
+  param=(void *)intValue;
+  paramTitle=itle;
+  this->tip=tip;
+  this->menu=menu;
+  this->nbMenu=nb;
+  nbLink=0;
+  
+  menus=new diaMenuEntryDynamic * [nb];
+  for(int i=0;i<nb;i++)
+  {
+    menus[i]=new  diaMenuEntryDynamic(menu[i].val,menu[i].text,menu[i].desc);
+  }
+  dyna=new diaElemMenuDynamic(intValue,itle,nb,menus,tip);
+}
+
+diaElemMenu::~diaElemMenu()
+{
+  for(int i=0;i<nbMenu;i++)
+      delete menus[i];
+  delete [] menus;
+  delete dyna;
+  
+}
+void diaElemMenu::setMe(void *dialog, void *opaque,uint32_t line)
+{
+  dyna->setMe(dialog,opaque,line);
+}
+
+void diaElemMenu::getMe(void)
+{
+ dyna->getMe();
+}
+void   diaElemMenu::updateMe(void)
+{
+  dyna->updateMe();
+}
+uint8_t   diaElemMenu::link(diaMenuEntry *entry,uint32_t onoff,diaElem *w)
+{
+    for(int i=0;i<nbMenu;i++)
+    {
+        if(entry->val==menus[i]->val)
+            return dyna->link(menus[i],onoff,w);
+    }
+    ADM_assert(0);
+}
+void   diaElemMenu::enable(uint32_t onoff)
+{
+  
+    dyna->enable(onoff);
+}
+void   diaElemMenu::finalize(void)
+{
+  dyna->finalize();
+}
+
+int diaElemMenu::getRequiredLayout(void) { return FAC_QT_GRIDLAYOUT; }
+
+//*********************************
+//* DYNAMIC                       *
+//*********************************
+
+diaElemMenuDynamic::diaElemMenuDynamic(uint32_t *intValue,const char *itle, uint32_t nb, 
+                diaMenuEntryDynamic **menu,const char *tip)
+  : diaElemMenuDynamicBase()
+{
+  param=(void *)intValue;
+  paramTitle=shortkey(itle);
+  this->tip=tip;
+  this->menu=menu;
+  this->nbMenu=nb;
+  nbLink=0;
+}
+
+diaElemMenuDynamic::~diaElemMenuDynamic()
+{
+  if(paramTitle)
+    delete paramTitle;
+}
+void diaElemMenuDynamic::setMe(void *dialog, void *opaque,uint32_t line)
+{
+  ADM_QComboBox *combo=new ADM_QComboBox((QWidget*)dialog, this);
+
+  QGridLayout *layout=(QGridLayout*) opaque;
+     myWidget=(void *)combo; 
+
+	 QLabel *text=new QLabel( QString::fromUtf8(this->paramTitle));
+	 text->setSizePolicy(QSizePolicy::Fixed, QSizePolicy::Fixed);
+
+	 QSpacerItem *spacer = new QSpacerItem(20, 20, QSizePolicy::Expanding, QSizePolicy::Minimum);
+  
+  // Fill in combobox
+  int mem=0;
+  diaMenuEntryDynamic **entries=menu;
+  for(int i=0;i<nbMenu;i++)
+  {
+    combo->addItem(QString::fromUtf8(entries[i]->text));
+    if( *(uint32_t *)param==entries[i]->val) mem=i;
+  }
+   combo->setCurrentIndex(mem);
+   text->setBuddy(combo);
+   layout->addWidget(text,line,0);
+   layout->addWidget(combo,line,1);
+   layout->addItem(spacer,line,2);
+   
+   combo->connectMe();
+}
+
+void diaElemMenuDynamic::getMe(void)
+{
+  ADM_QComboBox *combo = (ADM_QComboBox *)myWidget;
+  int r = combo->currentIndex();
+
+  if (!nbMenu)
+	  return;
+
+  ADM_assert(r < nbMenu);
+  *(uint32_t *)param = menu[r]->val;
+      
+}
+void diaElemMenuDynamic::finalize(void)
+{ 
+   ADM_QComboBox *combo=(ADM_QComboBox *)myWidget;
+  uint32_t val;
+  uint32_t rank;
+  if(!nbMenu) return;
+  ADM_assert(combo);
+  
+  
+  rank=combo->currentIndex();
+  ADM_assert(rank<this->nbMenu);
+  val=this->menu[rank]->val;
+  /* Now search through the linked list to see if something happens ...*/
+ 
+   /* 1 disable everything */
+  for(int i=0;i<nbLink;i++)
+  {
+    dialElemLink *l=&(links[i]);
+    if(l->value==val)
+    {
+      if(!l->onoff)  l->widget->enable(FALSE);
+    }else
+    {
+       if(l->onoff)  l->widget->enable(FALSE);
+    }
+    
+  }
+  /* Then enable */
+  for(int i=0;i<nbLink;i++)
+  {
+    dialElemLink *l=&(links[i]);
+    if(l->value==val)
+    {
+      if(l->onoff)  l->widget->enable(TRUE);
+    }else
+    {
+       if(!l->onoff)  l->widget->enable(TRUE);
+    }
+    
+  }
+}
+void diaElemMenuDynamic::enable(uint32_t onoff)
+{ 
+   ADM_QComboBox *combo=(ADM_QComboBox *)myWidget;
+  ADM_assert(combo);
+  if(onoff)
+    combo->setEnabled(true);
+  else
+    combo->setDisabled(true);
+}
+
+uint8_t   diaElemMenuDynamic::link(diaMenuEntryDynamic *entry,uint32_t onoff,diaElem *w)
+{
+    ADM_assert(nbLink<MENU_MAX_lINK);
+    links[nbLink].value=entry->val;
+    links[nbLink].onoff=onoff;
+    links[nbLink].widget=w;
+    nbLink++;
+    return 1;
+}
+void   diaElemMenuDynamic::updateMe(void)
+{
+	ADM_QComboBox *combo = (ADM_QComboBox*)myWidget;
+
+	for (int i = 0; i < this->nbMenu; i++)
+	{
+		if (this->menu[i]->val == *(uint32_t*)param)
+		{
+			combo->setCurrentIndex(i);
+			finalize();
+			break;
+		}
+	}
+}
+
+int diaElemMenuDynamic::getRequiredLayout(void) { return FAC_QT_GRIDLAYOUT; }
+}; // End of namespace
+
+diaElem  *qt4CreateMenu(uint32_t *intValue,const char *itle, uint32_t nb,         const diaMenuEntry *menu,const char *tip)
+{
+	return new  ADM_qt4Factory::diaElemMenu(intValue,itle,nb,menu,tip);
+}
+void qt4DestroyMenu(diaElem *e)
+{
+	ADM_qt4Factory::diaElemMenu *a=(ADM_qt4Factory::diaElemMenu *)e;
+	delete a;
+}
+diaElem  *qt4CreateMenuDynamic(uint32_t *intValue,const char *itle, uint32_t nb, 
+        diaMenuEntryDynamic **menu,const char *tipp)
+{
+	return new  ADM_qt4Factory::diaElemMenuDynamic(intValue,itle,nb,menu,tipp);
+}
+void qt4DestroyMenuDynamic(diaElem *e)
+{
+	ADM_qt4Factory::diaElemMenuDynamic *a=(ADM_qt4Factory::diaElemMenuDynamic *)e;
+	delete a;
+}
+
+//EOF



From mean at mail.berlios.de  Sat Aug  1 09:55:26 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sat, 1 Aug 2009 09:55:26 +0200
Subject: [Avidemux-svn-commit] r5185 - in
	branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass:
	. ADM_libAss ADM_libass
Message-ID: <200908010755.n717tQxn016415@sheep.berlios.de>

Author: mean
Date: 2009-08-01 09:55:22 +0200 (Sat, 01 Aug 2009)
New Revision: 5185

Added:
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/CMakeLists.txt
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass.c
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass.h
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_bitmap.c
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_bitmap.h
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_cache.c
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_cache.h
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_cache_template.h
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_drawing.c
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_drawing.h
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_font.c
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_font.h
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_fontconfig.c
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_fontconfig.h
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_library.c
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_library.h
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_render.c
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_types.h
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_utils.c
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_utils.h
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/config.h
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/libass.sym
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/readme
Removed:
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/CMakeLists.txt
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/ass.c
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/ass.h
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/ass_bitmap.c
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/ass_bitmap.h
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/ass_cache.c
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/ass_cache.h
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/ass_font.c
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/ass_font.h
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/ass_fontconfig.c
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/ass_fontconfig.h
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/ass_library.c
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/ass_library.h
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/ass_render.c
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/ass_types.h
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/ass_utils.c
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/ass_utils.h
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/help_mp.h
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/mputils.c
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/mputils.h
Modified:
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_vidASS.cpp
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_vidASS.h
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/CMakeLists.txt
Log:
[ass] Update

Added: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/CMakeLists.txt	2009-07-31 22:24:31 UTC (rev 5184)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/CMakeLists.txt	2009-08-01 07:55:22 UTC (rev 5185)
@@ -0,0 +1,32 @@
+# Does not seem to work without fontconfig....
+
+INCLUDE(admCheckFontConfig)
+INCLUDE(admCheckFreeType)
+checkFontConfig()
+checkFreeType()
+IF(USE_FREETYPE)
+
+        SET(ADM_LIB ADM_libass)
+
+        SET(${ADM_LIB}_SRCS 
+        ass_bitmap.c  ass.c  ass_cache.c  ass_drawing.c  ass_font.c    ass_library.c  ass_render.c  ass_utils.c
+        )
+    IF (FONTCONFIG_FOUND)
+        ADD_DEFINITIONS(${FONTCONFIG_CFLAGS} "-DHAVE_FONTCONFIG=1" "-DCONFIG_FONTCONFIG=1")
+        SET(${ADM_LIB}_SRCS  ${${ADM_LIB}_SRCS} ass_fontconfig.c)
+    ENDIF (FONTCONFIG_FOUND)
+        ADD_LIBRARY(${ADM_LIB} STATIC ${${ADM_LIB}_SRCS})
+        ADD_DEFINITIONS(${FREETYPE2_CFLAGS} "-I${LIBICONV_INCLUDE_DIR}")
+
+     
+
+
+        ADD_DEFINITIONS("-DCONFIG_LIBPNG=1")
+        ADD_DEFINITIONS("-DCONFIG_FREETYPE=1")
+
+        IF (UNIX)
+	        ADD_TARGET_CFLAGS(${ADM_LIB} -fPIC)
+        ENDIF (UNIX)
+
+ENDIF(USE_FREETYPE)
+

Added: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass.c
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass.c	2009-07-31 22:24:31 UTC (rev 5184)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass.c	2009-08-01 07:55:22 UTC (rev 5185)
@@ -0,0 +1,1237 @@
+/*
+ * Copyright (C) 2006 Evgeniy Stepanov <eugeni.stepanov at gmail.com>
+ *
+ * This file is part of libass.
+ *
+ * libass is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * libass is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with libass; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include "config.h"
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <assert.h>
+#include <errno.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <unistd.h>
+#include <inttypes.h>
+
+#ifdef CONFIG_ICONV
+#include <iconv.h>
+#endif
+
+#include "ass.h"
+#include "ass_utils.h"
+#include "ass_library.h"
+
+typedef enum { PST_UNKNOWN =
+        0, PST_INFO, PST_STYLES, PST_EVENTS, PST_FONTS } parser_state_t;
+
+struct parser_priv {
+    parser_state_t state;
+    char *fontname;
+    char *fontdata;
+    int fontdata_size;
+    int fontdata_used;
+};
+
+#define ASS_STYLES_ALLOC 20
+#define ASS_EVENTS_ALLOC 200
+
+void ass_free_track(ass_track_t *track)
+{
+    int i;
+
+    if (track->parser_priv) {
+        if (track->parser_priv->fontname)
+            free(track->parser_priv->fontname);
+        if (track->parser_priv->fontdata)
+            free(track->parser_priv->fontdata);
+        free(track->parser_priv);
+    }
+    if (track->style_format)
+        free(track->style_format);
+    if (track->event_format)
+        free(track->event_format);
+    if (track->styles) {
+        for (i = 0; i < track->n_styles; ++i)
+            ass_free_style(track, i);
+        free(track->styles);
+    }
+    if (track->events) {
+        for (i = 0; i < track->n_events; ++i)
+            ass_free_event(track, i);
+        free(track->events);
+    }
+    free(track->name);
+    free(track);
+}
+
+/// \brief Allocate a new style struct
+/// \param track track
+/// \return style id
+int ass_alloc_style(ass_track_t *track)
+{
+    int sid;
+
+    assert(track->n_styles <= track->max_styles);
+
+    if (track->n_styles == track->max_styles) {
+        track->max_styles += ASS_STYLES_ALLOC;
+        track->styles =
+            (ass_style_t *) realloc(track->styles,
+                                    sizeof(ass_style_t) *
+                                    track->max_styles);
+    }
+
+    sid = track->n_styles++;
+    memset(track->styles + sid, 0, sizeof(ass_style_t));
+    return sid;
+}
+
+/// \brief Allocate a new event struct
+/// \param track track
+/// \return event id
+int ass_alloc_event(ass_track_t *track)
+{
+    int eid;
+
+    assert(track->n_events <= track->max_events);
+
+    if (track->n_events == track->max_events) {
+        track->max_events += ASS_EVENTS_ALLOC;
+        track->events =
+            (ass_event_t *) realloc(track->events,
+                                    sizeof(ass_event_t) *
+                                    track->max_events);
+    }
+
+    eid = track->n_events++;
+    memset(track->events + eid, 0, sizeof(ass_event_t));
+    return eid;
+}
+
+void ass_free_event(ass_track_t *track, int eid)
+{
+    ass_event_t *event = track->events + eid;
+    if (event->Name)
+        free(event->Name);
+    if (event->Effect)
+        free(event->Effect);
+    if (event->Text)
+        free(event->Text);
+    if (event->render_priv)
+        free(event->render_priv);
+}
+
+void ass_free_style(ass_track_t *track, int sid)
+{
+    ass_style_t *style = track->styles + sid;
+    if (style->Name)
+        free(style->Name);
+    if (style->FontName)
+        free(style->FontName);
+}
+
+// ==============================================================================================
+
+static void skip_spaces(char **str)
+{
+    char *p = *str;
+    while ((*p == ' ') || (*p == '\t'))
+        ++p;
+    *str = p;
+}
+
+static void rskip_spaces(char **str, char *limit)
+{
+    char *p = *str;
+    while ((p >= limit) && ((*p == ' ') || (*p == '\t')))
+        --p;
+    *str = p;
+}
+
+/**
+ * \brief find style by name
+ * \param track track
+ * \param name style name
+ * \return index in track->styles
+ * Returnes 0 if no styles found => expects at least 1 style.
+ * Parsing code always adds "Default" style in the end.
+ */
+static int lookup_style(ass_track_t *track, char *name)
+{
+    int i;
+    if (*name == '*')
+        ++name;                 // FIXME: what does '*' really mean ?
+    for (i = track->n_styles - 1; i >= 0; --i) {
+        // FIXME: mb strcasecmp ?
+        if (strcmp(track->styles[i].Name, name) == 0)
+            return i;
+    }
+    i = track->default_style;
+    ass_msg(track->library, MSGL_WARN,
+            "[%p]: Warning: no style named '%s' found, using '%s'",
+            track, name, track->styles[i].Name);
+    return i;                   // use the first style
+}
+
+static uint32_t string2color(ass_library_t *library, char *p)
+{
+    uint32_t tmp;
+    (void) strtocolor(library, &p, &tmp);
+    return tmp;
+}
+
+static long long string2timecode(ass_library_t *library, char *p)
+{
+    unsigned h, m, s, ms;
+    long long tm;
+    int res = sscanf(p, "%1d:%2d:%2d.%2d", &h, &m, &s, &ms);
+    if (res < 4) {
+        ass_msg(library, MSGL_WARN, "Bad timestamp");
+        return 0;
+    }
+    tm = ((h * 60 + m) * 60 + s) * 1000 + ms * 10;
+    return tm;
+}
+
+/**
+ * \brief converts numpad-style align to align.
+ */
+static int numpad2align(int val)
+{
+    int res, v;
+    v = (val - 1) / 3;          // 0, 1 or 2 for vertical alignment
+    if (v != 0)
+        v = 3 - v;
+    res = ((val - 1) % 3) + 1;  // horizontal alignment
+    res += v * 4;
+    return res;
+}
+
+#define NEXT(str,token) \
+	token = next_token(&str); \
+	if (!token) break;
+
+#define ANYVAL(name,func) \
+	} else if (strcasecmp(tname, #name) == 0) { \
+		target->name = func(token); \
+		ass_msg(track->library, MSGL_DBG2, "%s = %s", #name, token);
+
+#define STRVAL(name) \
+	} else if (strcasecmp(tname, #name) == 0) { \
+		if (target->name != NULL) free(target->name); \
+		target->name = strdup(token); \
+		ass_msg(track->library, MSGL_DBG2, "%s = %s", #name, token);
+
+#define COLORVAL(name) \
+	} else if (strcasecmp(tname, #name) == 0) { \
+		target->name = string2color(track->library, token); \
+		ass_msg(track->library, MSGL_DBG2, "%s = %s", #name, token);
+
+#define INTVAL(name) ANYVAL(name,atoi)
+#define FPVAL(name) ANYVAL(name,atof)
+#define TIMEVAL(name) \
+	} else if (strcasecmp(tname, #name) == 0) { \
+		target->name = string2timecode(track->library, token); \
+		ass_msg(track->library, MSGL_DBG2, "%s = %s", #name, token);
+
+#define STYLEVAL(name) \
+	} else if (strcasecmp(tname, #name) == 0) { \
+		target->name = lookup_style(track, token); \
+		ass_msg(track->library, MSGL_DBG2, "%s = %s", #name, token);
+
+#define ALIAS(alias,name) \
+	if (strcasecmp(tname, #alias) == 0) {tname = #name;}
+
+static char *next_token(char **str)
+{
+    char *p = *str;
+    char *start;
+    skip_spaces(&p);
+    if (*p == '\0') {
+        *str = p;
+        return 0;
+    }
+    start = p;                  // start of the token
+    for (; (*p != '\0') && (*p != ','); ++p) {
+    }
+    if (*p == '\0') {
+        *str = p;               // eos found, str will point to '\0' at exit
+    } else {
+        *p = '\0';
+        *str = p + 1;           // ',' found, str will point to the next char (beginning of the next token)
+    }
+    --p;                        // end of current token
+    rskip_spaces(&p, start);
+    if (p < start)
+        p = start;              // empty token
+    else
+        ++p;                    // the first space character, or '\0'
+    *p = '\0';
+    return start;
+}
+
+/**
+ * \brief Parse the tail of Dialogue line
+ * \param track track
+ * \param event parsed data goes here
+ * \param str string to parse, zero-terminated
+ * \param n_ignored number of format options to skip at the beginning
+*/
+static int process_event_tail(ass_track_t *track, ass_event_t *event,
+                              char *str, int n_ignored)
+{
+    char *token;
+    char *tname;
+    char *p = str;
+    int i;
+    ass_event_t *target = event;
+
+    char *format = strdup(track->event_format);
+    char *q = format;           // format scanning pointer
+
+    if (track->n_styles == 0) {
+        // add "Default" style to the end
+        // will be used if track does not contain a default style (or even does not contain styles at all)
+        int sid = ass_alloc_style(track);
+        track->styles[sid].Name = strdup("Default");
+        track->styles[sid].FontName = strdup("Arial");
+    }
+
+    for (i = 0; i < n_ignored; ++i) {
+        NEXT(q, tname);
+    }
+
+    while (1) {
+        NEXT(q, tname);
+        if (strcasecmp(tname, "Text") == 0) {
+            char *last;
+            event->Text = strdup(p);
+            if (*event->Text != 0) {
+                last = event->Text + strlen(event->Text) - 1;
+                if (last >= event->Text && *last == '\r')
+                    *last = 0;
+            }
+            ass_msg(track->library, MSGL_DBG2, "Text = %s", event->Text);
+            event->Duration -= event->Start;
+            free(format);
+            return 0;           // "Text" is always the last
+        }
+        NEXT(p, token);
+
+        ALIAS(End, Duration)    // temporarily store end timecode in event->Duration
+        if (0) {            // cool ;)
+            INTVAL(Layer)
+            STYLEVAL(Style)
+            STRVAL(Name)
+            STRVAL(Effect)
+            INTVAL(MarginL)
+            INTVAL(MarginR)
+            INTVAL(MarginV)
+            TIMEVAL(Start)
+            TIMEVAL(Duration)
+        }
+    }
+    free(format);
+    return 1;
+}
+
+/**
+ * \brief Parse command line style overrides (--ass-force-style option)
+ * \param track track to apply overrides to
+ * The format for overrides is [StyleName.]Field=Value
+ */
+void ass_process_force_style(ass_track_t *track)
+{
+    char **fs, *eq, *dt, *style, *tname, *token;
+    ass_style_t *target;
+    int sid;
+    char **list = track->library->style_overrides;
+
+    if (!list)
+        return;
+
+    for (fs = list; *fs; ++fs) {
+        eq = strrchr(*fs, '=');
+        if (!eq)
+            continue;
+        *eq = '\0';
+        token = eq + 1;
+
+        if (!strcasecmp(*fs, "PlayResX"))
+            track->PlayResX = atoi(token);
+        else if (!strcasecmp(*fs, "PlayResY"))
+            track->PlayResY = atoi(token);
+        else if (!strcasecmp(*fs, "Timer"))
+            track->Timer = atof(token);
+        else if (!strcasecmp(*fs, "WrapStyle"))
+            track->WrapStyle = atoi(token);
+        else if (!strcasecmp(*fs, "ScaledBorderAndShadow"))
+            track->ScaledBorderAndShadow = parse_bool(token);
+
+        dt = strrchr(*fs, '.');
+        if (dt) {
+            *dt = '\0';
+            style = *fs;
+            tname = dt + 1;
+        } else {
+            style = NULL;
+            tname = *fs;
+        }
+        for (sid = 0; sid < track->n_styles; ++sid) {
+            if (style == NULL
+                || strcasecmp(track->styles[sid].Name, style) == 0) {
+                target = track->styles + sid;
+                if (0) {
+                    STRVAL(FontName)
+                    COLORVAL(PrimaryColour)
+                    COLORVAL(SecondaryColour)
+                    COLORVAL(OutlineColour)
+                    COLORVAL(BackColour)
+                    FPVAL(FontSize)
+                    INTVAL(Bold)
+                    INTVAL(Italic)
+                    INTVAL(Underline)
+                    INTVAL(StrikeOut)
+                    FPVAL(Spacing)
+                    INTVAL(Angle)
+                    INTVAL(BorderStyle)
+                    INTVAL(Alignment)
+                    INTVAL(MarginL)
+                    INTVAL(MarginR)
+                    INTVAL(MarginV)
+                    INTVAL(Encoding)
+                    FPVAL(ScaleX)
+                    FPVAL(ScaleY)
+                    FPVAL(Outline)
+                    FPVAL(Shadow)
+                }
+            }
+        }
+        *eq = '=';
+        if (dt)
+            *dt = '.';
+    }
+}
+
+/**
+ * \brief Parse the Style line
+ * \param track track
+ * \param str string to parse, zero-terminated
+ * Allocates a new style struct.
+*/
+static int process_style(ass_track_t *track, char *str)
+{
+
+    char *token;
+    char *tname;
+    char *p = str;
+    char *format;
+    char *q;                    // format scanning pointer
+    int sid;
+    ass_style_t *style;
+    ass_style_t *target;
+
+    if (!track->style_format) {
+        // no style format header
+        // probably an ancient script version
+        if (track->track_type == TRACK_TYPE_SSA)
+            track->style_format =
+                strdup
+                ("Name, Fontname, Fontsize, PrimaryColour, SecondaryColour,"
+                 "TertiaryColour, BackColour, Bold, Italic, BorderStyle, Outline,"
+                 "Shadow, Alignment, MarginL, MarginR, MarginV, AlphaLevel, Encoding");
+        else
+            track->style_format =
+                strdup
+                ("Name, Fontname, Fontsize, PrimaryColour, SecondaryColour,"
+                 "OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut,"
+                 "ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow,"
+                 "Alignment, MarginL, MarginR, MarginV, Encoding");
+    }
+
+    q = format = strdup(track->style_format);
+
+    ass_msg(track->library, MSGL_V, "[%p] Style: %s", track, str);
+
+    sid = ass_alloc_style(track);
+
+    style = track->styles + sid;
+    target = style;
+// fill style with some default values
+    style->ScaleX = 100.;
+    style->ScaleY = 100.;
+
+    while (1) {
+        NEXT(q, tname);
+        NEXT(p, token);
+
+//              ALIAS(TertiaryColour,OutlineColour) // ignore TertiaryColour; it appears only in SSA, and is overridden by BackColour
+
+        if (0) {                // cool ;)
+            STRVAL(Name)
+            if ((strcmp(target->Name, "Default") == 0)
+                || (strcmp(target->Name, "*Default") == 0))
+            track->default_style = sid;
+            STRVAL(FontName)
+            COLORVAL(PrimaryColour)
+            COLORVAL(SecondaryColour)
+            COLORVAL(OutlineColour) // TertiaryColor
+            COLORVAL(BackColour)
+            // SSA uses BackColour for both outline and shadow
+            // this will destroy SSA's TertiaryColour, but i'm not going to use it anyway
+            if (track->track_type == TRACK_TYPE_SSA)
+                target->OutlineColour = target->BackColour;
+            FPVAL(FontSize)
+            INTVAL(Bold)
+            INTVAL(Italic)
+            INTVAL(Underline)
+            INTVAL(StrikeOut)
+            FPVAL(Spacing)
+            INTVAL(Angle)
+            INTVAL(BorderStyle)
+            INTVAL(Alignment)
+            if (track->track_type == TRACK_TYPE_ASS)
+                target->Alignment = numpad2align(target->Alignment);
+            INTVAL(MarginL)
+            INTVAL(MarginR)
+            INTVAL(MarginV)
+            INTVAL(Encoding)
+            FPVAL(ScaleX)
+            FPVAL(ScaleY)
+            FPVAL(Outline)
+            FPVAL(Shadow)
+        }
+    }
+    style->ScaleX /= 100.;
+    style->ScaleY /= 100.;
+    style->Bold = !!style->Bold;
+    style->Italic = !!style->Italic;
+    style->Underline = !!style->Underline;
+    if (!style->Name)
+        style->Name = strdup("Default");
+    if (!style->FontName)
+        style->FontName = strdup("Arial");
+    // skip '@' at the start of the font name
+    if (*style->FontName == '@') {
+        p = style->FontName;
+        style->FontName = strdup(p + 1);
+        free(p);
+    }
+    free(format);
+    return 0;
+
+}
+
+static int process_styles_line(ass_track_t *track, char *str)
+{
+    if (!strncmp(str, "Format:", 7)) {
+        char *p = str + 7;
+        skip_spaces(&p);
+        track->style_format = strdup(p);
+        ass_msg(track->library, MSGL_DBG2, "Style format: %s",
+               track->style_format);
+    } else if (!strncmp(str, "Style:", 6)) {
+        char *p = str + 6;
+        skip_spaces(&p);
+        process_style(track, p);
+    }
+    return 0;
+}
+
+static int process_info_line(ass_track_t *track, char *str)
+{
+    if (!strncmp(str, "PlayResX:", 9)) {
+        track->PlayResX = atoi(str + 9);
+    } else if (!strncmp(str, "PlayResY:", 9)) {
+        track->PlayResY = atoi(str + 9);
+    } else if (!strncmp(str, "Timer:", 6)) {
+        track->Timer = atof(str + 6);
+    } else if (!strncmp(str, "WrapStyle:", 10)) {
+        track->WrapStyle = atoi(str + 10);
+    } else if (!strncmp(str, "ScaledBorderAndShadow:", 22)) {
+        track->ScaledBorderAndShadow = parse_bool(str + 22);
+    }
+    return 0;
+}
+
+static void event_format_fallback(ass_track_t *track)
+{
+    track->parser_priv->state = PST_EVENTS;
+    if (track->track_type == TRACK_TYPE_SSA)
+        track->event_format = strdup("Format: Marked, Start, End, Style, "
+            "Name, MarginL, MarginR, MarginV, Effect, Text");
+    else
+        track->event_format = strdup("Format: Layer, Start, End, Style, "
+            "Actor, MarginL, MarginR, MarginV, Effect, Text");
+    ass_msg(track->library, MSGL_V,
+            "No event format found, using fallback");
+}
+
+static int process_events_line(ass_track_t *track, char *str)
+{
+    if (!strncmp(str, "Format:", 7)) {
+        char *p = str + 7;
+        skip_spaces(&p);
+        track->event_format = strdup(p);
+        ass_msg(track->library, MSGL_DBG2, "Event format: %s", track->event_format);
+    } else if (!strncmp(str, "Dialogue:", 9)) {
+        // This should never be reached for embedded subtitles.
+        // They have slightly different format and are parsed in ass_process_chunk,
+        // called directly from demuxer
+        int eid;
+        ass_event_t *event;
+
+        str += 9;
+        skip_spaces(&str);
+
+        eid = ass_alloc_event(track);
+        event = track->events + eid;
+
+        // We can't parse events with event_format
+        if (!track->event_format)
+            event_format_fallback(track);
+
+        process_event_tail(track, event, str, 0);
+    } else {
+        ass_msg(track->library, MSGL_V, "Not understood: '%s'", str);
+    }
+    return 0;
+}
+
+// Copied from mkvtoolnix
+static unsigned char *decode_chars(unsigned char c1, unsigned char c2,
+                                   unsigned char c3, unsigned char c4,
+                                   unsigned char *dst, int cnt)
+{
+    uint32_t value;
+    unsigned char bytes[3];
+    int i;
+
+    value =
+        ((c1 - 33) << 18) + ((c2 - 33) << 12) + ((c3 - 33) << 6) + (c4 -
+                                                                    33);
+    bytes[2] = value & 0xff;
+    bytes[1] = (value & 0xff00) >> 8;
+    bytes[0] = (value & 0xff0000) >> 16;
+
+    for (i = 0; i < cnt; ++i)
+        *dst++ = bytes[i];
+    return dst;
+}
+
+static int decode_font(ass_track_t *track)
+{
+    unsigned char *p;
+    unsigned char *q;
+    int i;
+    int size;                   // original size
+    int dsize;                  // decoded size
+    unsigned char *buf = 0;
+
+    ass_msg(track->library, MSGL_V, "Font: %d bytes encoded data",
+            track->parser_priv->fontdata_used);
+    size = track->parser_priv->fontdata_used;
+    if (size % 4 == 1) {
+        ass_msg(track->library, MSGL_ERR, "Bad encoded data size");
+        goto error_decode_font;
+    }
+    buf = malloc(size / 4 * 3 + 2);
+    q = buf;
+    for (i = 0, p = (unsigned char *) track->parser_priv->fontdata;
+         i < size / 4; i++, p += 4) {
+        q = decode_chars(p[0], p[1], p[2], p[3], q, 3);
+    }
+    if (size % 4 == 2) {
+        q = decode_chars(p[0], p[1], 0, 0, q, 1);
+    } else if (size % 4 == 3) {
+        q = decode_chars(p[0], p[1], p[2], 0, q, 2);
+    }
+    dsize = q - buf;
+    assert(dsize <= size / 4 * 3 + 2);
+
+    if (track->library->extract_fonts) {
+        ass_add_font(track->library, track->parser_priv->fontname,
+                     (char *) buf, dsize);
+        buf = 0;
+    }
+
+  error_decode_font:
+    if (buf)
+        free(buf);
+    free(track->parser_priv->fontname);
+    free(track->parser_priv->fontdata);
+    track->parser_priv->fontname = 0;
+    track->parser_priv->fontdata = 0;
+    track->parser_priv->fontdata_size = 0;
+    track->parser_priv->fontdata_used = 0;
+    return 0;
+}
+
+static int process_fonts_line(ass_track_t *track, char *str)
+{
+    int len;
+
+    if (!strncmp(str, "fontname:", 9)) {
+        char *p = str + 9;
+        skip_spaces(&p);
+        if (track->parser_priv->fontname) {
+            decode_font(track);
+        }
+        track->parser_priv->fontname = strdup(p);
+        ass_msg(track->library, MSGL_V, "Fontname: %s",
+               track->parser_priv->fontname);
+        return 0;
+    }
+
+    if (!track->parser_priv->fontname) {
+        ass_msg(track->library, MSGL_V, "Not understood: '%s'", str);
+        return 0;
+    }
+
+    len = strlen(str);
+    if (len > 80) {
+        ass_msg(track->library, MSGL_WARN, "Font line too long: %d, %s",
+                len, str);
+        return 0;
+    }
+    if (track->parser_priv->fontdata_used + len >
+        track->parser_priv->fontdata_size) {
+        track->parser_priv->fontdata_size += 100 * 1024;
+        track->parser_priv->fontdata =
+            realloc(track->parser_priv->fontdata,
+                    track->parser_priv->fontdata_size);
+    }
+    memcpy(track->parser_priv->fontdata + track->parser_priv->fontdata_used,
+           str, len);
+    track->parser_priv->fontdata_used += len;
+
+    return 0;
+}
+
+/**
+ * \brief Parse a header line
+ * \param track track
+ * \param str string to parse, zero-terminated
+*/
+static int process_line(ass_track_t *track, char *str)
+{
+    if (!strncasecmp(str, "[Script Info]", 13)) {
+        track->parser_priv->state = PST_INFO;
+    } else if (!strncasecmp(str, "[V4 Styles]", 11)) {
+        track->parser_priv->state = PST_STYLES;
+        track->track_type = TRACK_TYPE_SSA;
+    } else if (!strncasecmp(str, "[V4+ Styles]", 12)) {
+        track->parser_priv->state = PST_STYLES;
+        track->track_type = TRACK_TYPE_ASS;
+    } else if (!strncasecmp(str, "[Events]", 8)) {
+        track->parser_priv->state = PST_EVENTS;
+    } else if (!strncasecmp(str, "[Fonts]", 7)) {
+        track->parser_priv->state = PST_FONTS;
+    } else {
+        switch (track->parser_priv->state) {
+        case PST_INFO:
+            process_info_line(track, str);
+            break;
+        case PST_STYLES:
+            process_styles_line(track, str);
+            break;
+        case PST_EVENTS:
+            process_events_line(track, str);
+            break;
+        case PST_FONTS:
+            process_fonts_line(track, str);
+            break;
+        default:
+            break;
+        }
+    }
+
+    // there is no explicit end-of-font marker in ssa/ass
+    if ((track->parser_priv->state != PST_FONTS)
+        && (track->parser_priv->fontname))
+        decode_font(track);
+
+    return 0;
+}
+
+static int process_text(ass_track_t *track, char *str)
+{
+    char *p = str;
+    while (1) {
+        char *q;
+        while (1) {
+            if ((*p == '\r') || (*p == '\n'))
+                ++p;
+            else if (p[0] == '\xef' && p[1] == '\xbb' && p[2] == '\xbf')
+                p += 3;         // U+FFFE (BOM)
+            else
+                break;
+        }
+        for (q = p; ((*q != '\0') && (*q != '\r') && (*q != '\n')); ++q) {
+        };
+        if (q == p)
+            break;
+        if (*q != '\0')
+            *(q++) = '\0';
+        process_line(track, p);
+        if (*q == '\0')
+            break;
+        p = q;
+    }
+    return 0;
+}
+
+/**
+ * \brief Process a chunk of subtitle stream data.
+ * \param track track
+ * \param data string to parse
+ * \param size length of data
+*/
+void ass_process_data(ass_track_t *track, char *data, int size)
+{
+    char *str = malloc(size + 1);
+
+    memcpy(str, data, size);
+    str[size] = '\0';
+
+    ass_msg(track->library, MSGL_V, "Event: %s", str);
+    process_text(track, str);
+    free(str);
+}
+
+/**
+ * \brief Process CodecPrivate section of subtitle stream
+ * \param track track
+ * \param data string to parse
+ * \param size length of data
+ CodecPrivate section contains [Stream Info] and [V4+ Styles] ([V4 Styles] for SSA) sections
+*/
+void ass_process_codec_private(ass_track_t *track, char *data, int size)
+{
+    ass_process_data(track, data, size);
+
+    // probably an mkv produced by ancient mkvtoolnix
+    // such files don't have [Events] and Format: headers
+    if (!track->event_format)
+        event_format_fallback(track);
+
+    ass_process_force_style(track);
+}
+
+static int check_duplicate_event(ass_track_t *track, int ReadOrder)
+{
+    int i;
+    for (i = 0; i < track->n_events - 1; ++i)   // ignoring last event, it is the one we are comparing with
+        if (track->events[i].ReadOrder == ReadOrder)
+            return 1;
+    return 0;
+}
+
+/**
+ * \brief Process a chunk of subtitle stream data. In Matroska, this contains exactly 1 event (or a commentary).
+ * \param track track
+ * \param data string to parse
+ * \param size length of data
+ * \param timecode starting time of the event (milliseconds)
+ * \param duration duration of the event (milliseconds)
+*/
+void ass_process_chunk(ass_track_t *track, char *data, int size,
+                       long long timecode, long long duration)
+{
+    char *str;
+    int eid;
+    char *p;
+    char *token;
+    ass_event_t *event;
+
+    if (!track->event_format) {
+        ass_msg(track->library, MSGL_WARN, "Event format header missing");
+        return;
+    }
+
+    str = malloc(size + 1);
+    memcpy(str, data, size);
+    str[size] = '\0';
+    ass_msg(track->library, MSGL_V, "Event at %" PRId64 ", +%" PRId64 ": %s",
+           (int64_t) timecode, (int64_t) duration, str);
+
+    eid = ass_alloc_event(track);
+    event = track->events + eid;
+
+    p = str;
+
+    do {
+        NEXT(p, token);
+        event->ReadOrder = atoi(token);
+        if (check_duplicate_event(track, event->ReadOrder))
+            break;
+
+        NEXT(p, token);
+        event->Layer = atoi(token);
+
+        process_event_tail(track, event, p, 3);
+
+        event->Start = timecode;
+        event->Duration = duration;
+
+        free(str);
+        return;
+//              dump_events(tid);
+    } while (0);
+    // some error
+    ass_free_event(track, eid);
+    track->n_events--;
+    free(str);
+}
+
+#ifdef CONFIG_ICONV
+/** \brief recode buffer to utf-8
+ * constraint: codepage != 0
+ * \param data pointer to text buffer
+ * \param size buffer size
+ * \return a pointer to recoded buffer, caller is responsible for freeing it
+**/
+static char *sub_recode(ass_library_t *library, char *data, size_t size,
+                        char *codepage)
+{
+    iconv_t icdsc;
+    char *tocp = "UTF-8";
+    char *outbuf;
+    assert(codepage);
+
+    {
+        const char *cp_tmp = codepage;
+#ifdef CONFIG_ENCA
+        char enca_lang[3], enca_fallback[100];
+        if (sscanf(codepage, "enca:%2s:%99s", enca_lang, enca_fallback) == 2
+            || sscanf(codepage, "ENCA:%2s:%99s", enca_lang,
+                      enca_fallback) == 2) {
+            cp_tmp =
+                ass_guess_buffer_cp(library, (unsigned char *) data, size,
+                                    enca_lang, enca_fallback);
+        }
+#endif
+        if ((icdsc = iconv_open(tocp, cp_tmp)) != (iconv_t) (-1)) {
+            ass_msg(library, MSGL_V, "Opened iconv descriptor");
+        } else
+            ass_msg(library, MSGL_ERR, "Error opening iconv descriptor");
+    }
+
+    {
+        size_t osize = size;
+        size_t ileft = size;
+        size_t oleft = size - 1;
+        char *ip;
+        char *op;
+        size_t rc;
+        int clear = 0;
+
+        outbuf = malloc(osize);
+        ip = data;
+        op = outbuf;
+
+        while (1) {
+            if (ileft)
+                rc = iconv(icdsc, &ip, &ileft, &op, &oleft);
+            else {              // clear the conversion state and leave
+                clear = 1;
+                rc = iconv(icdsc, NULL, NULL, &op, &oleft);
+            }
+            if (rc == (size_t) (-1)) {
+                if (errno == E2BIG) {
+                    size_t offset = op - outbuf;
+                    outbuf = (char *) realloc(outbuf, osize + size);
+                    op = outbuf + offset;
+                    osize += size;
+                    oleft += size;
+                } else {
+                    ass_msg(library, MSGL_WARN, "Error recoding file");
+                    return NULL;
+                }
+            } else if (clear)
+                break;
+        }
+        outbuf[osize - oleft - 1] = 0;
+    }
+
+    if (icdsc != (iconv_t) (-1)) {
+        (void) iconv_close(icdsc);
+        icdsc = (iconv_t) (-1);
+        ass_msg(library, MSGL_V, "Closed iconv descriptor");
+    }
+
+    return outbuf;
+}
+#endif                          // ICONV
+
+/**
+ * \brief read file contents into newly allocated buffer
+ * \param fname file name
+ * \param bufsize out: file size
+ * \return pointer to file contents. Caller is responsible for its deallocation.
+ */
+static char *read_file(ass_library_t *library, char *fname, size_t *bufsize)
+{
+    int res;
+    long sz;
+    long bytes_read;
+    char *buf;
+
+    FILE *fp = fopen(fname, "rb");
+    if (!fp) {
+        ass_msg(library, MSGL_WARN,
+                "ass_read_file(%s): fopen failed", fname);
+        return 0;
+    }
+    res = fseek(fp, 0, SEEK_END);
+    if (res == -1) {
+        ass_msg(library, MSGL_WARN,
+                "ass_read_file(%s): fseek failed", fname);
+        fclose(fp);
+        return 0;
+    }
+
+    sz = ftell(fp);
+    rewind(fp);
+
+    if (sz > 10 * 1024 * 1024) {
+        ass_msg(library, MSGL_INFO,
+               "ass_read_file(%s): Refusing to load subtitles "
+               "larger than 10MiB", fname);
+        fclose(fp);
+        return 0;
+    }
+
+    ass_msg(library, MSGL_V, "File size: %ld", sz);
+
+    buf = malloc(sz + 1);
+    assert(buf);
+    bytes_read = 0;
+    do {
+        res = fread(buf + bytes_read, 1, sz - bytes_read, fp);
+        if (res <= 0) {
+            ass_msg(library, MSGL_INFO, "Read failed, %d: %s", errno,
+                    strerror(errno));
+            fclose(fp);
+            free(buf);
+            return 0;
+        }
+        bytes_read += res;
+    } while (sz - bytes_read > 0);
+    buf[sz] = '\0';
+    fclose(fp);
+
+    if (bufsize)
+        *bufsize = sz;
+    return buf;
+}
+
+/*
+ * \param buf pointer to subtitle text in utf-8
+ */
+static ass_track_t *parse_memory(ass_library_t *library, char *buf)
+{
+    ass_track_t *track;
+    int i;
+
+    track = ass_new_track(library);
+
+    // process header
+    process_text(track, buf);
+
+    // external SSA/ASS subs does not have ReadOrder field
+    for (i = 0; i < track->n_events; ++i)
+        track->events[i].ReadOrder = i;
+
+    // there is no explicit end-of-font marker in ssa/ass
+    if (track->parser_priv->fontname)
+        decode_font(track);
+
+    if (track->track_type == TRACK_TYPE_UNKNOWN) {
+        ass_free_track(track);
+        return 0;
+    }
+
+    ass_process_force_style(track);
+
+    return track;
+}
+
+/**
+ * \brief Read subtitles from memory.
+ * \param library libass library object
+ * \param buf pointer to subtitles text
+ * \param bufsize size of buffer
+ * \param codepage recode buffer contents from given codepage
+ * \return newly allocated track
+*/
+ass_track_t *ass_read_memory(ass_library_t *library, char *buf,
+                             size_t bufsize, char *codepage)
+{
+    ass_track_t *track;
+    int need_free = 0;
+
+    if (!buf)
+        return 0;
+
+#ifdef CONFIG_ICONV
+    if (codepage)
+        buf = sub_recode(library, buf, bufsize, codepage);
+    if (!buf)
+        return 0;
+    else
+        need_free = 1;
+#endif
+    track = parse_memory(library, buf);
+    if (need_free)
+        free(buf);
+    if (!track)
+        return 0;
+
+    ass_msg(library, MSGL_INFO, "Added subtitle file: "
+            "<memory> (%d styles, %d events)",
+            track->n_styles, track->n_events);
+    return track;
+}
+
+static char *read_file_recode(ass_library_t *library, char *fname,
+                              char *codepage, size_t *size)
+{
+    char *buf;
+    size_t bufsize;
+
+    buf = read_file(library, fname, &bufsize);
+    if (!buf)
+        return 0;
+#ifdef CONFIG_ICONV
+    if (codepage) {
+        char *tmpbuf = sub_recode(library, buf, bufsize, codepage);
+        free(buf);
+        buf = tmpbuf;
+    }
+    if (!buf)
+        return 0;
+#endif
+    *size = bufsize;
+    return buf;
+}
+
+/**
+ * \brief Read subtitles from file.
+ * \param library libass library object
+ * \param fname file name
+ * \param codepage recode buffer contents from given codepage
+ * \return newly allocated track
+*/
+ass_track_t *ass_read_file(ass_library_t *library, char *fname,
+                           char *codepage)
+{
+    char *buf;
+    ass_track_t *track;
+    size_t bufsize;
+
+    buf = read_file_recode(library, fname, codepage, &bufsize);
+    if (!buf)
+        return 0;
+    track = parse_memory(library, buf);
+    free(buf);
+    if (!track)
+        return 0;
+
+    track->name = strdup(fname);
+
+    ass_msg(library, MSGL_INFO,
+            "Added subtitle file: '%s' (%d styles, %d events)",
+            fname, track->n_styles, track->n_events);
+
+    return track;
+}
+
+/**
+ * \brief read styles from file into already initialized track
+ */
+int ass_read_styles(ass_track_t *track, char *fname, char *codepage)
+{
+    char *buf;
+    parser_state_t old_state;
+    size_t sz;
+
+    buf = read_file(track->library, fname, &sz);
+    if (!buf)
+        return 1;
+#ifdef CONFIG_ICONV
+    if (codepage) {
+        char *tmpbuf;
+        tmpbuf = sub_recode(track->library, buf, sz, codepage);
+        free(buf);
+        buf = tmpbuf;
+    }
+    if (!buf)
+        return 0;
+#endif
+
+    old_state = track->parser_priv->state;
+    track->parser_priv->state = PST_STYLES;
+    process_text(track, buf);
+    track->parser_priv->state = old_state;
+
+    return 0;
+}
+
+long long ass_step_sub(ass_track_t *track, long long now, int movement)
+{
+    int i;
+
+    if (movement == 0)
+        return 0;
+    if (track->n_events == 0)
+        return 0;
+
+    if (movement < 0)
+        for (i = 0;
+             (i < track->n_events)
+             &&
+             ((long long) (track->events[i].Start +
+                           track->events[i].Duration) <= now); ++i) {
+    } else
+        for (i = track->n_events - 1;
+             (i >= 0) && ((long long) (track->events[i].Start) > now);
+             --i) {
+        }
+
+    // -1 and n_events are ok
+    assert(i >= -1);
+    assert(i <= track->n_events);
+    i += movement;
+    if (i < 0)
+        i = 0;
+    if (i >= track->n_events)
+        i = track->n_events - 1;
+    return ((long long) track->events[i].Start) - now;
+}
+
+ass_track_t *ass_new_track(ass_library_t *library)
+{
+    ass_track_t *track = calloc(1, sizeof(ass_track_t));
+    track->library = library;
+    track->ScaledBorderAndShadow = 1;
+    track->parser_priv = calloc(1, sizeof(parser_priv_t));
+    return track;
+}

Added: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass.h	2009-07-31 22:24:31 UTC (rev 5184)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass.h	2009-08-01 07:55:22 UTC (rev 5185)
@@ -0,0 +1,371 @@
+/*
+ * Copyright (C) 2006 Evgeniy Stepanov <eugeni.stepanov at gmail.com>
+ *
+ * This file is part of libass.
+ *
+ * libass is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * libass is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with libass; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#ifndef LIBASS_ASS_H
+#define LIBASS_ASS_H
+
+#include <stdio.h>
+#include <stdarg.h>
+#include "ass_types.h"
+
+#define LIBASS_VERSION 0x00907000
+
+/*
+ * A linked list of images produced by an ass renderer.
+ *
+ * These images have to be rendered in-order for the correct screen
+ * composition.  The libass renderer clips these bitmaps to the frame size.
+ * w/h can be zero, in this case the bitmap should not be rendered at all.
+ * The last bitmap row is not guaranteed to be padded up to stride size,
+ * e.g. in the worst case a bitmap has the size stride * (h - 1) + w.
+ */
+typedef struct ass_image {
+    int w, h;                   // Bitmap width/height
+    int stride;                 // Bitmap stride
+    unsigned char *bitmap;      // 1bpp stride*h alpha buffer
+                                // Note: the last row may not be padded to
+                                // bitmap stride!
+    uint32_t color;             // Bitmap color and alpha, RGBA
+    int dst_x, dst_y;           // Bitmap placement inside the video frame
+
+    struct ass_image *next;   // Next image, or NULL
+} ass_image_t;
+
+/*
+ * Hintint type. (see ass_set_hinting below)
+ *
+ * FreeType's native hinter is still buggy sometimes and it is recommended
+ * to use the light autohinter, ASS_HINTING_LIGHT, instead.  For best
+ * compatibility with problematic fonts, disable hinting.
+ */
+typedef enum {
+    ASS_HINTING_NONE = 0,
+    ASS_HINTING_LIGHT,
+    ASS_HINTING_NORMAL,
+    ASS_HINTING_NATIVE
+} ass_hinting_t;
+
+/**
+ * \brief Initialize the library.
+ * \return library handle or NULL if failed
+ */
+ass_library_t *ass_library_init(void);
+
+/**
+ * \brief Finalize the library
+ * \param priv library handle
+ */
+void ass_library_done(ass_library_t *);
+
+/**
+ * \brief Set private font directory.
+ * It is used for saving embedded fonts and also in font lookup.
+ *
+ * \param priv library handle
+ * \param fonts_dir private directory for font extraction
+ */
+void ass_set_fonts_dir(ass_library_t *priv, const char *fonts_dir);
+
+/**
+ * \brief Whether fonts should be extracted from track data.
+ * \param priv library handle
+ * \param extract whether to extract fonts
+ */
+void ass_set_extract_fonts(ass_library_t *priv, int extract);
+
+/**
+ * \brief Register style overrides with a library instance.
+ * The overrides should have the form [Style.]Param=Value, e.g.
+ *   SomeStyle.Font=Arial
+ *   ScaledBorderAndShadow=yes
+ *
+ * \param priv library handle
+ * \param list NULL-terminated list of strings
+ */
+void ass_set_style_overrides(ass_library_t *priv, char **list);
+
+/**
+ * \brief Explicitly process style overrides for a track.
+ * \param track track handle
+ */
+void ass_process_force_style(ass_track_t *track);
+
+/**
+ * \brief Register a callback for debug/info messages.
+ * If a callback is registered, it is called for every message emitted by
+ * libass.  The callback receives a format string and a list of arguments,
+ * to be used for the printf family of functions. Additionally, a log level
+ * from 0 (FATAL errors) to 7 (verbose DEBUG) is passed.  Usually, level 5
+ * should be used by applications.
+ * If no callback is set, all messages level < 5 are printed to stderr,
+ * prefixed with [ass].
+ *
+ * \param priv library handle
+ * \param msg_cb pointer to callback function
+ * \param data additional data, will be passed to callback
+ */
+void ass_set_message_cb(ass_library_t *priv, void (*msg_cb)
+                        (int level, const char *fmt, va_list args, void *data),
+                        void *data);
+
+/**
+ * \brief Initialize the renderer.
+ * \param priv library handle
+ * \return renderer handle or NULL if failed
+ */
+ass_renderer_t *ass_renderer_init(ass_library_t *);
+
+/**
+ * \brief Finalize the renderer.
+ * \param priv renderer handle
+ */
+void ass_renderer_done(ass_renderer_t *priv);
+
+/**
+ * \brief Set the frame size in pixels, including margins.
+ * \param priv renderer handle
+ * \param w width
+ * \param h height
+ */
+void ass_set_frame_size(ass_renderer_t *priv, int w, int h);
+
+/**
+ * \brief Set frame margins.  These values may be negative if pan-and-scan
+ * is used.
+ * \param priv renderer handle
+ * \param t top margin
+ * \param b bottom margin
+ * \param l left margin
+ * \param r right margin
+ */
+void ass_set_margins(ass_renderer_t *priv, int t, int b, int l, int r);
+
+/**
+ * \brief Whether margins should be used for placing regular events.
+ * \param priv renderer handle
+ * \param use whether to use the margins
+ */
+void ass_set_use_margins(ass_renderer_t *priv, int use);
+
+/**
+ * \brief Set aspect ratio parameters.
+ * \param priv renderer handle
+ * \param ar physical aspect ratio
+ * \param par pixel ratio, e.g. width / height of the video
+ */
+void ass_set_aspect_ratio(ass_renderer_t *priv, double ar, double par);
+
+/**
+ * \brief Set a fixed font scaling factor.
+ * \param priv renderer handle
+ * \param font_scale scaling factor, default is 1.0
+ */
+void ass_set_font_scale(ass_renderer_t *priv, double font_scale);
+
+/**
+ * \brief Set font hinting method.
+ * \param priv renderer handle
+ * \param ht hinting method
+ */
+void ass_set_hinting(ass_renderer_t *priv, ass_hinting_t ht);
+
+/**
+ * \brief Set line spacing. Will not be scaled with frame size.
+ * \param priv renderer handle
+ * \param line_spacing line spacing in pixels
+ */
+void ass_set_line_spacing(ass_renderer_t *priv, double line_spacing);
+
+/**
+ * \brief Set font lookup defaults.
+ * \param fc whether to use fontconfig
+ * \param config path to fontconfig configuration file, or NULL.  Only relevant
+ * if fontconfig is used.
+ * \param update whether fontconfig cache should be built/updated now.  Only
+ * relevant if fontconfig is used.
+ */
+void ass_set_fonts(ass_renderer_t *priv, const char *default_font,
+                   const char *default_family, int fc, const char *config,
+                   int update);
+
+/**
+ * \brief Update/build font cache.  This needs to be called if it was
+ * disabled when ass_set_fonts was set.
+ *
+ * \param priv renderer handle
+ * \return success
+ */
+int ass_fonts_update(ass_renderer_t *priv);
+
+/**
+ * \brief Set hard cache limits.  Do not set, or set to zero, for reasonable
+ * defaults.
+ *
+ * \param priv renderer handle
+ * \param glyph_max maximum number of cached glyphs
+ * \param bitmap_max_size maximum bitmap cache size (in MB)
+ */
+void ass_set_cache_limits(ass_renderer_t *priv, int glyph_max,
+                          int bitmap_max_size);
+
+/**
+ * \brief Render a frame, producing a list of ass_image_t.
+ * \param priv renderer handle
+ * \param track subtitle track
+ * \param now video timestamp in milliseconds
+ * \param detect_change will be set to 1 if a change occured compared
+ * to the last invocation
+ */
+ass_image_t *ass_render_frame(ass_renderer_t *priv, ass_track_t *track,
+                              long long now, int *detect_change);
+
+
+/*
+ * The following functions operate on track objects and do not need
+ * an ass_renderer
+ */
+
+/**
+ * \brief Allocate a new empty track object.
+ * \param library handle
+ * \return pointer to empty track
+ */
+ass_track_t *ass_new_track(ass_library_t *);
+
+/**
+ * \brief Deallocate track and all its child objects (styles and events).
+ * \param track track to deallocate
+ */
+void ass_free_track(ass_track_t *track);
+
+/**
+ * \brief Allocate new style.
+ * \param track track
+ * \return newly allocated style id
+ */
+int ass_alloc_style(ass_track_t *track);
+
+/**
+ * \brief Allocate new event.
+ * \param track track
+ * \return newly allocated event id
+ */
+int ass_alloc_event(ass_track_t *track);
+
+/**
+ * \brief Delete a style.
+ * \param track track
+ * \param sid style id
+ * Deallocates style data. Does not modify track->n_styles.
+ */
+void ass_free_style(ass_track_t *track, int sid);
+
+/**
+ * \brief Delete an event.
+ * \param track track
+ * \param eid event id
+ * Deallocates event data. Does not modify track->n_events.
+ */
+void ass_free_event(ass_track_t *track, int eid);
+
+/**
+ * \brief Parse a chunk of subtitle stream data.
+ * \param track track
+ * \param data string to parse
+ * \param size length of data
+ */
+void ass_process_data(ass_track_t *track, char *data, int size);
+
+/**
+ * \brief Parse Codec Private section of subtitle stream.
+ * \param track target track
+ * \param data string to parse
+ * \param size length of data
+ */
+void ass_process_codec_private(ass_track_t *track, char *data, int size);
+
+/**
+ * \brief Parse a chunk of subtitle stream data. In Matroska,
+ * this contains exactly 1 event (or a commentary).
+ * \param track track
+ * \param data string to parse
+ * \param size length of data
+ * \param timecode starting time of the event (milliseconds)
+ * \param duration duration of the event (milliseconds)
+ */
+void ass_process_chunk(ass_track_t *track, char *data, int size,
+                       long long timecode, long long duration);
+
+/**
+ * \brief Read subtitles from file.
+ * \param library library handle
+ * \param fname file name
+ * \param codepage encoding (iconv format)
+ * \return newly allocated track
+*/
+ass_track_t *ass_read_file(ass_library_t *library, char *fname,
+                           char *codepage);
+
+/**
+ * \brief Read subtitles from memory.
+ * \param library library handle
+ * \param buf pointer to subtitles text
+ * \param bufsize size of buffer
+ * \param codepage encoding (iconv format)
+ * \return newly allocated track
+*/
+ass_track_t *ass_read_memory(ass_library_t *library, char *buf,
+                             size_t bufsize, char *codepage);
+/**
+ * \brief Read styles from file into already initialized track.
+ * \param fname file name
+ * \param codepage encoding (iconv format)
+ * \return 0 on success
+ */
+int ass_read_styles(ass_track_t *track, char *fname, char *codepage);
+
+/**
+ * \brief Add a memory font.
+ * \param library library handle
+ * \param name attachment name
+ * \param data binary font data
+ * \param data_size data size
+*/
+void ass_add_font(ass_library_t *library, char *name, char *data,
+                  int data_size);
+
+/**
+ * \brief Remove all fonts stored in an ass_library object.
+ * \param library library handle
+ */
+void ass_clear_fonts(ass_library_t *library);
+
+/**
+ * \brief Calculates timeshift from now to the start of some other subtitle
+ * event, depending on movement parameter.
+ * \param track subtitle track
+ * \param now current time in milliseconds
+ * \param movement how many events to skip from the one currently displayed
+ * +2 means "the one after the next", -1 means "previous"
+ * \return timeshift in milliseconds
+ */
+long long ass_step_sub(ass_track_t *track, long long now, int movement);
+
+#endif /* LIBASS_ASS_H */

Added: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_bitmap.c
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_bitmap.c	2009-07-31 22:24:31 UTC (rev 5184)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_bitmap.c	2009-08-01 07:55:22 UTC (rev 5185)
@@ -0,0 +1,540 @@
+/*
+ * Copyright (C) 2006 Evgeniy Stepanov <eugeni.stepanov at gmail.com>
+ *
+ * This file is part of libass.
+ *
+ * libass is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * libass is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with libass; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <stdlib.h>
+#include <string.h>
+#include <math.h>
+#include <assert.h>
+#include <ft2build.h>
+#include FT_GLYPH_H
+
+#include "ass_utils.h"
+#include "ass_bitmap.h"
+
+struct ass_synth_priv {
+    int tmp_w, tmp_h;
+    unsigned short *tmp;
+
+    int g_r;
+    int g_w;
+
+    unsigned *g;
+    unsigned *gt2;
+
+    double radius;
+};
+
+static const unsigned int maxcolor = 255;
+static const unsigned base = 256;
+
+static int generate_tables(ass_synth_priv_t *priv, double radius)
+{
+    double A = log(1.0 / base) / (radius * radius * 2);
+    int mx, i;
+    double volume_diff, volume_factor = 0;
+    unsigned volume;
+
+    if (priv->radius == radius)
+        return 0;
+    else
+        priv->radius = radius;
+
+    priv->g_r = ceil(radius);
+    priv->g_w = 2 * priv->g_r + 1;
+
+    if (priv->g_r) {
+        priv->g = realloc(priv->g, priv->g_w * sizeof(unsigned));
+        priv->gt2 = realloc(priv->gt2, 256 * priv->g_w * sizeof(unsigned));
+        if (priv->g == NULL || priv->gt2 == NULL) {
+            return -1;
+        }
+    }
+
+    if (priv->g_r) {
+        // gaussian curve with volume = 256
+        for (volume_diff = 10000000; volume_diff > 0.0000001;
+             volume_diff *= 0.5) {
+            volume_factor += volume_diff;
+            volume = 0;
+            for (i = 0; i < priv->g_w; ++i) {
+                priv->g[i] =
+                    (unsigned) (exp(A * (i - priv->g_r) * (i - priv->g_r)) *
+                                volume_factor + .5);
+                volume += priv->g[i];
+            }
+            if (volume > 256)
+                volume_factor -= volume_diff;
+        }
+        volume = 0;
+        for (i = 0; i < priv->g_w; ++i) {
+            priv->g[i] =
+                (unsigned) (exp(A * (i - priv->g_r) * (i - priv->g_r)) *
+                            volume_factor + .5);
+            volume += priv->g[i];
+        }
+
+        // gauss table:
+        for (mx = 0; mx < priv->g_w; mx++) {
+            for (i = 0; i < 256; i++) {
+                priv->gt2[mx + i * priv->g_w] = i * priv->g[mx];
+            }
+        }
+    }
+
+    return 0;
+}
+
+static void resize_tmp(ass_synth_priv_t *priv, int w, int h)
+{
+    if (priv->tmp_w >= w && priv->tmp_h >= h)
+        return;
+    if (priv->tmp_w == 0)
+        priv->tmp_w = 64;
+    if (priv->tmp_h == 0)
+        priv->tmp_h = 64;
+    while (priv->tmp_w < w)
+        priv->tmp_w *= 2;
+    while (priv->tmp_h < h)
+        priv->tmp_h *= 2;
+    if (priv->tmp)
+        free(priv->tmp);
+    priv->tmp = malloc((priv->tmp_w + 1) * priv->tmp_h * sizeof(short));
+}
+
+ass_synth_priv_t *ass_synth_init(double radius)
+{
+    ass_synth_priv_t *priv = calloc(1, sizeof(ass_synth_priv_t));
+    generate_tables(priv, radius);
+    return priv;
+}
+
+void ass_synth_done(ass_synth_priv_t *priv)
+{
+    if (priv->tmp)
+        free(priv->tmp);
+    if (priv->g)
+        free(priv->g);
+    if (priv->gt2)
+        free(priv->gt2);
+    free(priv);
+}
+
+static bitmap_t *alloc_bitmap(int w, int h)
+{
+    bitmap_t *bm;
+    bm = calloc(1, sizeof(bitmap_t));
+    bm->buffer = malloc(w * h);
+    bm->w = w;
+    bm->h = h;
+    bm->left = bm->top = 0;
+    return bm;
+}
+
+void ass_free_bitmap(bitmap_t *bm)
+{
+    if (bm) {
+        if (bm->buffer)
+            free(bm->buffer);
+        free(bm);
+    }
+}
+
+static bitmap_t *copy_bitmap(const bitmap_t *src)
+{
+    bitmap_t *dst = alloc_bitmap(src->w, src->h);
+    dst->left = src->left;
+    dst->top = src->top;
+    memcpy(dst->buffer, src->buffer, src->w * src->h);
+    return dst;
+}
+
+static int check_glyph_area(ass_library_t *library, FT_Glyph glyph)
+{
+    FT_BBox bbox;
+    long long dx, dy;
+    FT_Glyph_Get_CBox(glyph, FT_GLYPH_BBOX_TRUNCATE, &bbox);
+    dx = bbox.xMax - bbox.xMin;
+    dy = bbox.yMax - bbox.yMin;
+    if (dx * dy > 8000000) {
+        ass_msg(library, MSGL_WARN, "Glyph bounding box too large: %dx%dpx",
+               (int) dx, (int) dy);
+        return 1;
+    } else
+        return 0;
+}
+
+static bitmap_t *glyph_to_bitmap_internal(ass_library_t *library,
+                                          FT_Glyph glyph, int bord)
+{
+    FT_BitmapGlyph bg;
+    FT_Bitmap *bit;
+    bitmap_t *bm;
+    int w, h;
+    unsigned char *src;
+    unsigned char *dst;
+    int i;
+    int error;
+
+    if (check_glyph_area(library, glyph))
+        return 0;
+    error = FT_Glyph_To_Bitmap(&glyph, FT_RENDER_MODE_NORMAL, 0, 0);
+    if (error) {
+        ass_msg(library, MSGL_WARN, "FT_Glyph_To_Bitmap error %d",
+               error);
+        return 0;
+    }
+
+    bg = (FT_BitmapGlyph) glyph;
+    bit = &(bg->bitmap);
+    if (bit->pixel_mode != FT_PIXEL_MODE_GRAY) {
+        ass_msg(library, MSGL_WARN, "Unsupported pixel mode: %d",
+               (int) (bit->pixel_mode));
+        FT_Done_Glyph(glyph);
+        return 0;
+    }
+
+    w = bit->width;
+    h = bit->rows;
+    bm = alloc_bitmap(w + 2 * bord, h + 2 * bord);
+    memset(bm->buffer, 0, bm->w * bm->h);
+    bm->left = bg->left - bord;
+    bm->top = -bg->top - bord;
+
+    src = bit->buffer;
+    dst = bm->buffer + bord + bm->w * bord;
+    for (i = 0; i < h; ++i) {
+        memcpy(dst, src, w);
+        src += bit->pitch;
+        dst += bm->w;
+    }
+
+    FT_Done_Glyph(glyph);
+    return bm;
+}
+
+/**
+ * \brief fix outline bitmap and generate shadow bitmap
+ * Two things are done here:
+ * 1. Glyph bitmap is subtracted from outline bitmap. This way looks much better in some cases.
+ * 2. Shadow bitmap is created as a sum of glyph and outline bitmaps.
+ */
+static bitmap_t *fix_outline_and_shadow(bitmap_t *bm_g, bitmap_t *bm_o)
+{
+    int x, y;
+    const int l = bm_o->left > bm_g->left ? bm_o->left : bm_g->left;
+    const int t = bm_o->top > bm_g->top ? bm_o->top : bm_g->top;
+    const int r =
+        bm_o->left + bm_o->w <
+        bm_g->left + bm_g->w ? bm_o->left + bm_o->w : bm_g->left + bm_g->w;
+    const int b =
+        bm_o->top + bm_o->h <
+        bm_g->top + bm_g->h ? bm_o->top + bm_o->h : bm_g->top + bm_g->h;
+
+    bitmap_t *bm_s = copy_bitmap(bm_o);
+
+    unsigned char *g =
+        bm_g->buffer + (t - bm_g->top) * bm_g->w + (l - bm_g->left);
+    unsigned char *o =
+        bm_o->buffer + (t - bm_o->top) * bm_o->w + (l - bm_o->left);
+    unsigned char *s =
+        bm_s->buffer + (t - bm_s->top) * bm_s->w + (l - bm_s->left);
+
+    for (y = 0; y < b - t; ++y) {
+        for (x = 0; x < r - l; ++x) {
+            unsigned char c_g, c_o;
+            c_g = g[x];
+            c_o = o[x];
+            o[x] = (c_o > (3 * c_g) / 5) ? c_o - (3 * c_g) / 5 : 0;
+            s[x] = (c_o < 0xFF - c_g) ? c_o + c_g : 0xFF;
+        }
+        g += bm_g->w;
+        o += bm_o->w;
+        s += bm_s->w;
+    }
+
+    assert(bm_s);
+    return bm_s;
+}
+
+/**
+ * \brief Shift a bitmap by the fraction of a pixel in x and y direction
+ * expressed in 26.6 fixed point
+ */
+static void shift_bitmap(unsigned char *buf, int w, int h, int shift_x,
+                         int shift_y)
+{
+    int x, y, b;
+
+    // Shift in x direction
+    if (shift_x > 0) {
+        for (y = 0; y < h; y++) {
+            for (x = w - 1; x > 0; x--) {
+                b = (buf[x + y * w - 1] * shift_x) >> 6;
+                buf[x + y * w - 1] -= b;
+                buf[x + y * w] += b;
+            }
+        }
+    } else if (shift_x < 0) {
+        shift_x = -shift_x;
+        for (y = 0; y < h; y++) {
+            for (x = 0; x < w - 1; x++) {
+                b = (buf[x + y * w + 1] * shift_x) >> 6;
+                buf[x + y * w + 1] -= b;
+                buf[x + y * w] += b;
+            }
+        }
+    }
+
+    // Shift in y direction
+    if (shift_y > 0) {
+        for (x = 0; x < w; x++) {
+            for (y = h - 1; y > 0; y--) {
+                b = (buf[x + (y - 1) * w] * shift_y) >> 6;
+                buf[x + (y - 1) * w] -= b;
+                buf[x + y * w] += b;
+            }
+        }
+    } else if (shift_y < 0) {
+        shift_y = -shift_y;
+        for (x = 0; x < w; x++) {
+            for (y = 0; y < h - 1; y++) {
+                b = (buf[x + (y + 1) * w] * shift_y) >> 6;
+                buf[x + (y + 1) * w] -= b;
+                buf[x + y * w] += b;
+            }
+        }
+    }
+}
+
+/*
+ * Gaussian blur.  An fast pure C implementation from MPlayer.
+ */
+static void ass_gauss_blur(unsigned char *buffer, unsigned short *tmp2,
+                           int width, int height, int stride, int *m2,
+                           int r, int mwidth)
+{
+
+    int x, y;
+
+    unsigned char *s = buffer;
+    unsigned short *t = tmp2 + 1;
+    for (y = 0; y < height; y++) {
+        memset(t - 1, 0, (width + 1) * sizeof(short));
+
+        for (x = 0; x < r; x++) {
+            const int src = s[x];
+            if (src) {
+                register unsigned short *dstp = t + x - r;
+                int mx;
+                unsigned *m3 = (unsigned *) (m2 + src * mwidth);
+                for (mx = r - x; mx < mwidth; mx++) {
+                    dstp[mx] += m3[mx];
+                }
+            }
+        }
+
+        for (; x < width - r; x++) {
+            const int src = s[x];
+            if (src) {
+                register unsigned short *dstp = t + x - r;
+                int mx;
+                unsigned *m3 = (unsigned *) (m2 + src * mwidth);
+                for (mx = 0; mx < mwidth; mx++) {
+                    dstp[mx] += m3[mx];
+                }
+            }
+        }
+
+        for (; x < width; x++) {
+            const int src = s[x];
+            if (src) {
+                register unsigned short *dstp = t + x - r;
+                int mx;
+                const int x2 = r + width - x;
+                unsigned *m3 = (unsigned *) (m2 + src * mwidth);
+                for (mx = 0; mx < x2; mx++) {
+                    dstp[mx] += m3[mx];
+                }
+            }
+        }
+
+        s += stride;
+        t += width + 1;
+    }
+
+    t = tmp2;
+    for (x = 0; x < width; x++) {
+        for (y = 0; y < r; y++) {
+            unsigned short *srcp = t + y * (width + 1) + 1;
+            int src = *srcp;
+            if (src) {
+                register unsigned short *dstp = srcp - 1 + width + 1;
+                const int src2 = (src + 128) >> 8;
+                unsigned *m3 = (unsigned *) (m2 + src2 * mwidth);
+
+                int mx;
+                *srcp = 128;
+                for (mx = r - 1; mx < mwidth; mx++) {
+                    *dstp += m3[mx];
+                    dstp += width + 1;
+                }
+            }
+        }
+        for (; y < height - r; y++) {
+            unsigned short *srcp = t + y * (width + 1) + 1;
+            int src = *srcp;
+            if (src) {
+                register unsigned short *dstp = srcp - 1 - r * (width + 1);
+                const int src2 = (src + 128) >> 8;
+                unsigned *m3 = (unsigned *) (m2 + src2 * mwidth);
+
+                int mx;
+                *srcp = 128;
+                for (mx = 0; mx < mwidth; mx++) {
+                    *dstp += m3[mx];
+                    dstp += width + 1;
+                }
+            }
+        }
+        for (; y < height; y++) {
+            unsigned short *srcp = t + y * (width + 1) + 1;
+            int src = *srcp;
+            if (src) {
+                const int y2 = r + height - y;
+                register unsigned short *dstp = srcp - 1 - r * (width + 1);
+                const int src2 = (src + 128) >> 8;
+                unsigned *m3 = (unsigned *) (m2 + src2 * mwidth);
+
+                int mx;
+                *srcp = 128;
+                for (mx = 0; mx < y2; mx++) {
+                    *dstp += m3[mx];
+                    dstp += width + 1;
+                }
+            }
+        }
+        t++;
+    }
+
+    t = tmp2;
+    s = buffer;
+    for (y = 0; y < height; y++) {
+        for (x = 0; x < width; x++) {
+            s[x] = t[x] >> 8;
+        }
+        s += stride;
+        t += width + 1;
+    }
+}
+
+/**
+ * \brief Blur with [[1,2,1]. [2,4,2], [1,2,1]] kernel
+ * This blur is the same as the one employed by vsfilter.
+ */
+static void be_blur(unsigned char *buf, int w, int h)
+{
+    unsigned int x, y;
+    unsigned int old_sum, new_sum;
+
+    for (y = 0; y < h; y++) {
+        old_sum = 2 * buf[y * w];
+        for (x = 0; x < w - 1; x++) {
+            new_sum = buf[y * w + x] + buf[y * w + x + 1];
+            buf[y * w + x] = (old_sum + new_sum) >> 2;
+            old_sum = new_sum;
+        }
+    }
+
+    for (x = 0; x < w; x++) {
+        old_sum = 2 * buf[x];
+        for (y = 0; y < h - 1; y++) {
+            new_sum = buf[y * w + x] + buf[(y + 1) * w + x];
+            buf[y * w + x] = (old_sum + new_sum) >> 2;
+            old_sum = new_sum;
+        }
+    }
+}
+
+int glyph_to_bitmap(ass_library_t *library, ass_synth_priv_t *priv_blur,
+                    FT_Glyph glyph, FT_Glyph outline_glyph,
+                    bitmap_t **bm_g, bitmap_t **bm_o, bitmap_t **bm_s,
+                    int be, double blur_radius, FT_Vector shadow_offset)
+{
+    blur_radius *= 2;
+    int bbord = be > 0 ? sqrt(2 * be) : 0;
+    int gbord = blur_radius > 0.0 ? blur_radius + 1 : 0;
+    int bord = FFMAX(bbord, gbord);
+    if (bord == 0 && (shadow_offset.x || shadow_offset.y))
+        bord = 1;
+
+    assert(bm_g && bm_o && bm_s);
+
+    *bm_g = *bm_o = *bm_s = 0;
+
+    if (glyph)
+        *bm_g = glyph_to_bitmap_internal(library, glyph, bord);
+    if (!*bm_g)
+        return 1;
+
+    if (outline_glyph) {
+        *bm_o = glyph_to_bitmap_internal(library, outline_glyph, bord);
+        if (!*bm_o) {
+            return 1;
+        }
+    }
+
+    // Apply box blur (multiple passes, if requested)
+    while (be--) {
+        if (*bm_o)
+            be_blur((*bm_o)->buffer, (*bm_o)->w, (*bm_o)->h);
+        else
+            be_blur((*bm_g)->buffer, (*bm_g)->w, (*bm_g)->h);
+    }
+
+    // Apply gaussian blur
+    if (blur_radius > 0.0) {
+        if (*bm_o)
+            resize_tmp(priv_blur, (*bm_o)->w, (*bm_o)->h);
+        else
+            resize_tmp(priv_blur, (*bm_g)->w, (*bm_g)->h);
+        generate_tables(priv_blur, blur_radius);
+        if (*bm_o)
+            ass_gauss_blur((*bm_o)->buffer, priv_blur->tmp,
+                           (*bm_o)->w, (*bm_o)->h, (*bm_o)->w,
+                           (int *) priv_blur->gt2, priv_blur->g_r,
+                           priv_blur->g_w);
+        else
+            ass_gauss_blur((*bm_g)->buffer, priv_blur->tmp,
+                           (*bm_g)->w, (*bm_g)->h, (*bm_g)->w,
+                           (int *) priv_blur->gt2, priv_blur->g_r,
+                           priv_blur->g_w);
+    }
+
+    if (*bm_o)
+        *bm_s = fix_outline_and_shadow(*bm_g, *bm_o);
+    else
+        *bm_s = copy_bitmap(*bm_g);
+
+    shift_bitmap((*bm_s)->buffer, (*bm_s)->w,(*bm_s)->h,
+                 shadow_offset.x, shadow_offset.y);
+
+    assert(bm_s);
+    return 0;
+}

Added: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_bitmap.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_bitmap.h	2009-07-31 22:24:31 UTC (rev 5184)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_bitmap.h	2009-08-01 07:55:22 UTC (rev 5185)
@@ -0,0 +1,56 @@
+/*
+ * Copyright (C) 2006 Evgeniy Stepanov <eugeni.stepanov at gmail.com>
+ *
+ * This file is part of libass.
+ *
+ * libass is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * libass is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with libass; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#ifndef LIBASS_BITMAP_H
+#define LIBASS_BITMAP_H
+
+#include <ft2build.h>
+#include FT_GLYPH_H
+
+#include "ass.h"
+
+typedef struct ass_synth_priv ass_synth_priv_t;
+
+ass_synth_priv_t *ass_synth_init(double);
+void ass_synth_done(ass_synth_priv_t *priv);
+
+typedef struct {
+    int left, top;
+    int w, h;                   // width, height
+    unsigned char *buffer;      // w x h buffer
+} bitmap_t;
+
+/**
+ * \brief perform glyph rendering
+ * \param glyph original glyph
+ * \param outline_glyph "border" glyph, produced from original by FreeType's glyph stroker
+ * \param bm_g out: pointer to the bitmap of original glyph is returned here
+ * \param bm_o out: pointer to the bitmap of outline (border) glyph is returned here
+ * \param bm_g out: pointer to the bitmap of glyph shadow is returned here
+ * \param be 1 = produces blurred bitmaps, 0 = normal bitmaps
+ */
+int glyph_to_bitmap(ass_library_t *library, ass_synth_priv_t *priv_blur,
+                    FT_Glyph glyph, FT_Glyph outline_glyph,
+                    bitmap_t **bm_g, bitmap_t **bm_o, bitmap_t **bm_s,
+                    int be, double blur_radius, FT_Vector shadow_offset);
+
+void ass_free_bitmap(bitmap_t *bm);
+
+#endif                          /* LIBASS_BITMAP_H */

Added: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_cache.c
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_cache.c	2009-07-31 22:24:31 UTC (rev 5184)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_cache.c	2009-08-01 07:55:22 UTC (rev 5185)
@@ -0,0 +1,380 @@
+/*
+ * Copyright (C) 2006 Evgeniy Stepanov <eugeni.stepanov at gmail.com>
+ *
+ * This file is part of libass.
+ *
+ * libass is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * libass is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with libass; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include "config.h"
+
+#include <inttypes.h>
+#include <ft2build.h>
+#include FT_FREETYPE_H
+#include FT_GLYPH_H
+
+#include <assert.h>
+
+#include "ass_utils.h"
+#include "ass.h"
+#include "ass_fontconfig.h"
+#include "ass_font.h"
+#include "ass_bitmap.h"
+#include "ass_cache.h"
+
+static unsigned hashmap_hash(void *buf, size_t len)
+{
+    return fnv_32a_buf(buf, len, FNV1_32A_INIT);
+}
+
+static int hashmap_key_compare(void *a, void *b, size_t size)
+{
+    return memcmp(a, b, size) == 0;
+}
+
+static void hashmap_item_dtor(void *key, size_t key_size, void *value,
+                              size_t value_size)
+{
+    free(key);
+    free(value);
+}
+
+hashmap_t *hashmap_init(ass_library_t *library, size_t key_size,
+                        size_t value_size, int nbuckets,
+                        hashmap_item_dtor_t item_dtor,
+                        hashmap_key_compare_t key_compare,
+                        hashmap_hash_t hash)
+{
+    hashmap_t *map = calloc(1, sizeof(hashmap_t));
+    map->library = library;
+    map->nbuckets = nbuckets;
+    map->key_size = key_size;
+    map->value_size = value_size;
+    map->root = calloc(nbuckets, sizeof(hashmap_item_p));
+    map->item_dtor = item_dtor ? item_dtor : hashmap_item_dtor;
+    map->key_compare = key_compare ? key_compare : hashmap_key_compare;
+    map->hash = hash ? hash : hashmap_hash;
+    return map;
+}
+
+void hashmap_done(hashmap_t *map)
+{
+    int i;
+    // print stats
+    if (map->count > 0 || map->hit_count + map->miss_count > 0)
+        ass_msg(map->library, MSGL_V,
+               "cache statistics: \n  total accesses: %d\n  hits: %d\n  "
+               "misses: %d\n  object count: %d",
+               map->hit_count + map->miss_count, map->hit_count,
+               map->miss_count, map->count);
+
+    for (i = 0; i < map->nbuckets; ++i) {
+        hashmap_item_t *item = map->root[i];
+        while (item) {
+            hashmap_item_t *next = item->next;
+            map->item_dtor(item->key, map->key_size, item->value,
+                           map->value_size);
+            free(item);
+            item = next;
+        }
+    }
+    free(map->root);
+    free(map);
+}
+
+// does nothing if key already exists
+void *hashmap_insert(hashmap_t *map, void *key, void *value)
+{
+    unsigned hash = map->hash(key, map->key_size);
+    hashmap_item_t **next = map->root + (hash % map->nbuckets);
+    while (*next) {
+        if (map->key_compare(key, (*next)->key, map->key_size))
+            return (*next)->value;
+        next = &((*next)->next);
+        assert(next);
+    }
+    (*next) = malloc(sizeof(hashmap_item_t));
+    (*next)->key = malloc(map->key_size);
+    (*next)->value = malloc(map->value_size);
+    memcpy((*next)->key, key, map->key_size);
+    memcpy((*next)->value, value, map->value_size);
+    (*next)->next = 0;
+
+    map->count++;
+    return (*next)->value;
+}
+
+void *hashmap_find(hashmap_t *map, void *key)
+{
+    unsigned hash = map->hash(key, map->key_size);
+    hashmap_item_t *item = map->root[hash % map->nbuckets];
+    while (item) {
+        if (map->key_compare(key, item->key, map->key_size)) {
+            map->hit_count++;
+            return item->value;
+        }
+        item = item->next;
+    }
+    map->miss_count++;
+    return 0;
+}
+
+//---------------------------------
+// font cache
+
+static unsigned font_desc_hash(void *buf, size_t len)
+{
+    ass_font_desc_t *desc = buf;
+    unsigned hval;
+    hval = fnv_32a_str(desc->family, FNV1_32A_INIT);
+    hval = fnv_32a_buf(&desc->bold, sizeof(desc->bold), hval);
+    hval = fnv_32a_buf(&desc->italic, sizeof(desc->italic), hval);
+    return hval;
+}
+
+static int font_compare(void *key1, void *key2, size_t key_size)
+{
+    ass_font_desc_t *a = key1;
+    ass_font_desc_t *b = key2;
+    if (strcmp(a->family, b->family) != 0)
+        return 0;
+    if (a->bold != b->bold)
+        return 0;
+    if (a->italic != b->italic)
+        return 0;
+    if (a->treat_family_as_pattern != b->treat_family_as_pattern)
+        return 0;
+    return 1;
+}
+
+static void font_hash_dtor(void *key, size_t key_size, void *value,
+                           size_t value_size)
+{
+    ass_font_free(value);
+    free(key);
+}
+
+ass_font_t *ass_font_cache_find(hashmap_t *font_cache,
+                                ass_font_desc_t *desc)
+{
+    return hashmap_find(font_cache, desc);
+}
+
+/**
+ * \brief Add a face struct to cache.
+ * \param font font struct
+*/
+void *ass_font_cache_add(hashmap_t *font_cache, ass_font_t *font)
+{
+    return hashmap_insert(font_cache, &(font->desc), font);
+}
+
+hashmap_t *ass_font_cache_init(ass_library_t *library)
+{
+    hashmap_t *font_cache;
+    font_cache = hashmap_init(library, sizeof(ass_font_desc_t),
+                              sizeof(ass_font_t),
+                              1000,
+                              font_hash_dtor, font_compare, font_desc_hash);
+    return font_cache;
+}
+
+void ass_font_cache_done(hashmap_t *font_cache)
+{
+    hashmap_done(font_cache);
+}
+
+
+// Create hash/compare functions for bitmap and glyph
+#define CREATE_HASH_FUNCTIONS
+#include "ass_cache_template.h"
+#define CREATE_COMPARISON_FUNCTIONS
+#include "ass_cache_template.h"
+
+//---------------------------------
+// bitmap cache
+
+static void bitmap_hash_dtor(void *key, size_t key_size, void *value,
+                             size_t value_size)
+{
+    bitmap_hash_val_t *v = value;
+    if (v->bm)
+        ass_free_bitmap(v->bm);
+    if (v->bm_o)
+        ass_free_bitmap(v->bm_o);
+    if (v->bm_s)
+        ass_free_bitmap(v->bm_s);
+    free(key);
+    free(value);
+}
+
+void *cache_add_bitmap(hashmap_t *bitmap_cache, bitmap_hash_key_t *key,
+                       bitmap_hash_val_t *val)
+{
+    // Note: this is only an approximation
+    if (val->bm_o)
+        bitmap_cache->cache_size += val->bm_o->w * val->bm_o->h * 3;
+    else
+        bitmap_cache->cache_size += val->bm->w * val->bm->h * 3;
+
+    return hashmap_insert(bitmap_cache, key, val);
+}
+
+/**
+ * \brief Get a bitmap from bitmap cache.
+ * \param key hash key
+ * \return requested hash val or 0 if not found
+*/
+bitmap_hash_val_t *cache_find_bitmap(hashmap_t *bitmap_cache,
+                                     bitmap_hash_key_t *key)
+{
+    return hashmap_find(bitmap_cache, key);
+}
+
+hashmap_t *ass_bitmap_cache_init(ass_library_t *library)
+{
+    hashmap_t *bitmap_cache;
+    bitmap_cache = hashmap_init(library,
+                                sizeof(bitmap_hash_key_t),
+                                sizeof(bitmap_hash_val_t),
+                                0xFFFF + 13,
+                                bitmap_hash_dtor, bitmap_compare,
+                                bitmap_hash);
+    return bitmap_cache;
+}
+
+void ass_bitmap_cache_done(hashmap_t *bitmap_cache)
+{
+    hashmap_done(bitmap_cache);
+}
+
+hashmap_t *ass_bitmap_cache_reset(hashmap_t *bitmap_cache)
+{
+    ass_library_t *lib = bitmap_cache->library;
+
+    ass_bitmap_cache_done(bitmap_cache);
+    return ass_bitmap_cache_init(lib);
+}
+
+//---------------------------------
+// glyph cache
+
+static void glyph_hash_dtor(void *key, size_t key_size, void *value,
+                            size_t value_size)
+{
+    glyph_hash_val_t *v = value;
+    if (v->glyph)
+        FT_Done_Glyph(v->glyph);
+    if (v->outline_glyph)
+        FT_Done_Glyph(v->outline_glyph);
+    free(key);
+    free(value);
+}
+
+void *cache_add_glyph(hashmap_t *glyph_cache, glyph_hash_key_t *key,
+                      glyph_hash_val_t *val)
+{
+    return hashmap_insert(glyph_cache, key, val);
+}
+
+/**
+ * \brief Get a glyph from glyph cache.
+ * \param key hash key
+ * \return requested hash val or 0 if not found
+*/
+glyph_hash_val_t *cache_find_glyph(hashmap_t *glyph_cache,
+                                   glyph_hash_key_t *key)
+{
+    return hashmap_find(glyph_cache, key);
+}
+
+hashmap_t *ass_glyph_cache_init(ass_library_t *library)
+{
+    hashmap_t *glyph_cache;
+    glyph_cache = hashmap_init(library, sizeof(glyph_hash_key_t),
+                               sizeof(glyph_hash_val_t),
+                               0xFFFF + 13,
+                               glyph_hash_dtor, glyph_compare, glyph_hash);
+    return glyph_cache;
+}
+
+void ass_glyph_cache_done(hashmap_t *glyph_cache)
+{
+    hashmap_done(glyph_cache);
+}
+
+hashmap_t *ass_glyph_cache_reset(hashmap_t *glyph_cache)
+{
+    ass_library_t *lib = glyph_cache->library;
+
+    ass_glyph_cache_done(glyph_cache);
+    return ass_glyph_cache_init(lib);
+}
+
+
+//---------------------------------
+// composite cache
+
+static void composite_hash_dtor(void *key, size_t key_size, void *value,
+                                size_t value_size)
+{
+    composite_hash_val_t *v = value;
+    free(v->a);
+    free(v->b);
+    free(key);
+    free(value);
+}
+
+void *cache_add_composite(hashmap_t *composite_cache,
+                          composite_hash_key_t *key,
+                          composite_hash_val_t *val)
+{
+    return hashmap_insert(composite_cache, key, val);
+}
+
+/**
+ * \brief Get a composite bitmap from composite cache.
+ * \param key hash key
+ * \return requested hash val or 0 if not found
+*/
+composite_hash_val_t *cache_find_composite(hashmap_t *composite_cache,
+                                           composite_hash_key_t *key)
+{
+    return hashmap_find(composite_cache, key);
+}
+
+hashmap_t *ass_composite_cache_init(ass_library_t *library)
+{
+    hashmap_t *composite_cache;
+    composite_cache = hashmap_init(library, sizeof(composite_hash_key_t),
+                                   sizeof(composite_hash_val_t),
+                                   0xFFFF + 13,
+                                   composite_hash_dtor, composite_compare,
+                                   composite_hash);
+    return composite_cache;
+}
+
+void ass_composite_cache_done(hashmap_t *composite_cache)
+{
+    hashmap_done(composite_cache);
+}
+
+hashmap_t *ass_composite_cache_reset(hashmap_t *composite_cache)
+{
+    ass_library_t *lib = composite_cache->library;
+
+    ass_composite_cache_done(composite_cache);
+    return ass_composite_cache_init(lib);
+}

Added: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_cache.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_cache.h	2009-07-31 22:24:31 UTC (rev 5184)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_cache.h	2009-08-01 07:55:22 UTC (rev 5185)
@@ -0,0 +1,119 @@
+/*
+ * Copyright (C) 2006 Evgeniy Stepanov <eugeni.stepanov at gmail.com>
+ *
+ * This file is part of libass.
+ *
+ * libass is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * libass is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with libass; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#ifndef LIBASS_CACHE_H
+#define LIBASS_CACHE_H
+
+#include "ass.h"
+#include "ass_font.h"
+#include "ass_bitmap.h"
+
+typedef void (*hashmap_item_dtor_t) (void *key, size_t key_size,
+                                     void *value, size_t value_size);
+typedef int (*hashmap_key_compare_t) (void *key1, void *key2,
+                                      size_t key_size);
+typedef unsigned (*hashmap_hash_t) (void *key, size_t key_size);
+
+typedef struct hashmap_item {
+    void *key;
+    void *value;
+    struct hashmap_item *next;
+} hashmap_item_t;
+typedef hashmap_item_t *hashmap_item_p;
+
+typedef struct {
+    int nbuckets;
+    size_t key_size, value_size;
+    hashmap_item_p *root;
+    hashmap_item_dtor_t item_dtor;      // a destructor for hashmap key/value pairs
+    hashmap_key_compare_t key_compare;
+    hashmap_hash_t hash;
+    size_t cache_size;
+    // stats
+    int hit_count;
+    int miss_count;
+    int count;
+    ass_library_t *library;
+} hashmap_t;
+
+hashmap_t *hashmap_init(ass_library_t *library, size_t key_size,
+                        size_t value_size, int nbuckets,
+                        hashmap_item_dtor_t item_dtor,
+                        hashmap_key_compare_t key_compare,
+                        hashmap_hash_t hash);
+void hashmap_done(hashmap_t *map);
+void *hashmap_insert(hashmap_t *map, void *key, void *value);
+void *hashmap_find(hashmap_t *map, void *key);
+
+hashmap_t *ass_font_cache_init(ass_library_t *library);
+ass_font_t *ass_font_cache_find(hashmap_t *, ass_font_desc_t *desc);
+void *ass_font_cache_add(hashmap_t *, ass_font_t *font);
+void ass_font_cache_done(hashmap_t *);
+
+// Create definitions for bitmap_hash_key and glyph_hash_key
+#define CREATE_STRUCT_DEFINITIONS
+#include "ass_cache_template.h"
+
+typedef struct {
+    bitmap_t *bm;               // the actual bitmaps
+    bitmap_t *bm_o;
+    bitmap_t *bm_s;
+} bitmap_hash_val_t;
+
+hashmap_t *ass_bitmap_cache_init(ass_library_t *library);
+void *cache_add_bitmap(hashmap_t *, bitmap_hash_key_t *key,
+                       bitmap_hash_val_t *val);
+bitmap_hash_val_t *cache_find_bitmap(hashmap_t *bitmap_cache,
+                                     bitmap_hash_key_t *key);
+hashmap_t *ass_bitmap_cache_reset(hashmap_t *bitmap_cache);
+void ass_bitmap_cache_done(hashmap_t *bitmap_cache);
+
+
+typedef struct {
+    unsigned char *a;
+    unsigned char *b;
+} composite_hash_val_t;
+
+hashmap_t *ass_composite_cache_init(ass_library_t *library);
+void *cache_add_composite(hashmap_t *, composite_hash_key_t *key,
+                          composite_hash_val_t *val);
+composite_hash_val_t *cache_find_composite(hashmap_t *composite_cache,
+                                           composite_hash_key_t *key);
+hashmap_t *ass_composite_cache_reset(hashmap_t *composite_cache);
+void ass_composite_cache_done(hashmap_t *composite_cache);
+
+
+typedef struct {
+    FT_Glyph glyph;
+    FT_Glyph outline_glyph;
+    FT_BBox bbox_scaled;        // bbox after scaling, but before rotation
+    FT_Vector advance;          // 26.6, advance distance to the next bitmap in line
+    int asc, desc;              // ascender/descender of a drawing
+} glyph_hash_val_t;
+
+hashmap_t *ass_glyph_cache_init(ass_library_t *library);
+void *cache_add_glyph(hashmap_t *, glyph_hash_key_t *key,
+                      glyph_hash_val_t *val);
+glyph_hash_val_t *cache_find_glyph(hashmap_t *glyph_cache,
+                                   glyph_hash_key_t *key);
+hashmap_t *ass_glyph_cache_reset(hashmap_t *glyph_cache);
+void ass_glyph_cache_done(hashmap_t *glyph_cache);
+
+#endif                          /* LIBASS_CACHE_H */

Added: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_cache_template.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_cache_template.h	2009-07-31 22:24:31 UTC (rev 5184)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_cache_template.h	2009-08-01 07:55:22 UTC (rev 5185)
@@ -0,0 +1,117 @@
+#ifdef CREATE_STRUCT_DEFINITIONS
+#undef CREATE_STRUCT_DEFINITIONS
+#define START(funcname, structname) \
+    typedef struct structname {
+#define GENERIC(type, member) \
+        type member;
+#define FTVECTOR(member) \
+        FT_Vector member;
+#define BITMAPHASHKEY(member) \
+        bitmap_hash_key_t member;
+#define END(typedefnamename) \
+    } typedefnamename;
+
+#elif defined(CREATE_COMPARISON_FUNCTIONS)
+#undef CREATE_COMPARISON_FUNCTIONS
+#define START(funcname, structname) \
+    static int funcname##_compare(void *key1, void *key2, size_t key_size) \
+    { \
+        struct structname *a = key1; \
+        struct structname *b = key2; \
+        return // conditions follow
+#define GENERIC(type, member) \
+            a->member == b->member &&
+#define FTVECTOR(member) \
+            a->member.x == b->member.x && a->member.y == b->member.y &&
+#define BITMAPHASHKEY(member) \
+            bitmap_compare(&a->member, &b->member, sizeof(a->member)) &&
+#define END(typedefname) \
+            1; \
+    }
+
+#elif defined(CREATE_HASH_FUNCTIONS)
+#undef CREATE_HASH_FUNCTIONS
+#define START(funcname, structname) \
+    static unsigned funcname##_hash(void *buf, size_t len) \
+    { \
+        struct structname *p = buf; \
+        unsigned hval = FNV1_32A_INIT;
+#define GENERIC(type, member) \
+        hval = fnv_32a_buf(&p->member, sizeof(p->member), hval);
+#define FTVECTOR(member) GENERIC(, member.x); GENERIC(, member.y);
+#define BITMAPHASHKEY(member) { \
+        unsigned temp = bitmap_hash(&p->member, sizeof(p->member)); \
+        hval = fnv_32a_buf(&temp, sizeof(temp), hval); \
+        }
+#define END(typedefname) \
+        return hval; \
+    }
+
+#else
+#error missing defines
+#endif
+
+
+
+// describes a bitmap; bitmaps with equivalents structs are considered identical
+START(bitmap, bipmap_hash_key)
+    GENERIC(char, bitmap) // bool : true = bitmap, false = outline
+    GENERIC(ass_font_t *, font)
+    GENERIC(double, size) // font size
+    GENERIC(uint32_t, ch) // character code
+    FTVECTOR(outline) // border width, 16.16 fixed point value
+    GENERIC(int, bold)
+    GENERIC(int, italic)
+    GENERIC(char, be) // blur edges
+    GENERIC(double, blur) // gaussian blur
+    GENERIC(unsigned, scale_x) // 16.16
+    GENERIC(unsigned, scale_y) // 16.16
+    GENERIC(int, frx) // signed 16.16
+    GENERIC(int, fry) // signed 16.16
+    GENERIC(int, frz) // signed 16.16
+    GENERIC(int, fax) // signed 16.16
+    GENERIC(int, fay) // signed 16.16
+    // shift vector that was added to glyph before applying rotation
+    // = 0, if frx = fry = frx = 0
+    // = (glyph base point) - (rotation origin), otherwise
+    GENERIC(int, shift_x)
+    GENERIC(int, shift_y)
+    FTVECTOR(advance) // subpixel shift vector
+    FTVECTOR(shadow_offset) // shadow subpixel shift
+    GENERIC(unsigned, drawing_hash) // hashcode of a drawing
+END(bitmap_hash_key_t)
+
+// describes an outline glyph
+START(glyph, glyph_hash_key)
+    GENERIC(ass_font_t *, font)
+    GENERIC(double, size) // font size
+    GENERIC(uint32_t, ch) // character code
+    GENERIC(int, bold)
+    GENERIC(int, italic)
+    GENERIC(unsigned, scale_x) // 16.16
+    GENERIC(unsigned, scale_y) // 16.16
+    FTVECTOR(outline) // border width, 16.16
+    GENERIC(unsigned, drawing_hash) // hashcode of a drawing
+    GENERIC(unsigned, flags)    // glyph decoration flags
+END(glyph_hash_key_t)
+
+// Cache for composited bitmaps
+START(composite, composite_hash_key)
+    GENERIC(int, aw)
+    GENERIC(int, ah)
+    GENERIC(int, bw)
+    GENERIC(int, bh)
+    GENERIC(int, ax)
+    GENERIC(int, ay)
+    GENERIC(int, bx)
+    GENERIC(int, by)
+    BITMAPHASHKEY(a)
+    BITMAPHASHKEY(b)
+END(composite_hash_key_t)
+
+
+#undef START
+#undef GENERIC
+#undef FTVECTOR
+#undef BITMAPHASHKEY
+#undef END

Added: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_drawing.c
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_drawing.c	2009-07-31 22:24:31 UTC (rev 5184)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_drawing.c	2009-08-01 07:55:22 UTC (rev 5185)
@@ -0,0 +1,484 @@
+/*
+ * Copyright (C) 2009 Grigori Goronzy <greg at geekmind.org>
+ *
+ * This file is part of libass.
+ *
+ * Permission to use, copy, modify, and distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#include <ft2build.h>
+#include FT_GLYPH_H
+#include FT_OUTLINE_H
+#include FT_BBOX_H
+#include <math.h>
+
+#include "ass_utils.h"
+#include "ass_font.h"
+#include "ass_drawing.h"
+
+#define CURVE_ACCURACY 64.0
+#define GLYPH_INITIAL_POINTS 100
+#define GLYPH_INITIAL_CONTOURS 5
+
+/*
+ * \brief Get and prepare a FreeType glyph
+ */
+static void drawing_make_glyph(ass_drawing_t *drawing, void *fontconfig_priv,
+                               ass_font_t *font, ass_hinting_t hint)
+{
+    FT_OutlineGlyph glyph;
+
+    // This is hacky...
+    glyph = (FT_OutlineGlyph) ass_font_get_glyph(fontconfig_priv, font,
+                                                 (uint32_t) ' ', hint, 0);
+
+    FT_Outline_Done(drawing->ftlibrary, &glyph->outline);
+    FT_Outline_New(drawing->ftlibrary, GLYPH_INITIAL_POINTS,
+                   GLYPH_INITIAL_CONTOURS, &glyph->outline);
+
+    glyph->outline.n_contours = 0;
+    glyph->outline.n_points = 0;
+    glyph->root.advance.x = glyph->root.advance.y = 0;
+    drawing->glyph = glyph;
+}
+
+/*
+ * \brief Add a single point to a contour.
+ */
+static inline void drawing_add_point(ass_drawing_t *drawing,
+                                     FT_Vector *point)
+{
+    FT_Outline *ol = &drawing->glyph->outline;
+
+    if (ol->n_points >= drawing->max_points) {
+        drawing->max_points *= 2;
+        ol->points = realloc(ol->points, sizeof(FT_Vector) *
+                             drawing->max_points);
+        ol->tags = realloc(ol->tags, drawing->max_points);
+    }
+
+    ol->points[ol->n_points].x = point->x;
+    ol->points[ol->n_points].y = point->y;
+    ol->tags[ol->n_points] = 1;
+    ol->n_points++;
+}
+
+/*
+ * \brief Close a contour and check glyph size overflow.
+ */
+static inline void drawing_close_shape(ass_drawing_t *drawing)
+{
+    FT_Outline *ol = &drawing->glyph->outline;
+
+    if (ol->n_contours >= drawing->max_contours) {
+        drawing->max_contours *= 2;
+        ol->contours = realloc(ol->contours, sizeof(short) *
+                               drawing->max_contours);
+    }
+
+    ol->contours[ol->n_contours] = ol->n_points - 1;
+    ol->n_contours++;
+}
+
+/*
+ * \brief Prepare drawing for parsing.  This just sets a few parameters.
+ */
+static void drawing_prepare(ass_drawing_t *drawing)
+{
+    // Scaling parameters
+    drawing->point_scale_x = drawing->scale_x *
+                             64.0 / (1 << (drawing->scale - 1));
+    drawing->point_scale_y = drawing->scale_y *
+                             64.0 / (1 << (drawing->scale - 1));
+}
+
+/*
+ * \brief Finish a drawing.  This only sets the horizontal advance according
+ * to the glyph's bbox at the moment.
+ */
+static void drawing_finish(ass_drawing_t *drawing, int raw_mode)
+{
+    int i, offset;
+    FT_BBox bbox;
+    FT_Outline *ol = &drawing->glyph->outline;
+
+    // Close the last contour
+    drawing_close_shape(drawing);
+
+#if 0
+    // Dump points
+    for (i = 0; i < ol->n_points; i++) {
+        printf("point (%d, %d)\n", (int) ol->points[i].x,
+               (int) ol->points[i].y);
+    }
+
+    // Dump contours
+    for (i = 0; i < ol->n_contours; i++)
+        printf("contour %d\n", ol->contours[i]);
+#endif
+
+    ass_msg(drawing->library, MSGL_V,
+            "Parsed drawing with %d points and %d contours", ol->n_points,
+            ol->n_contours);
+
+    if (raw_mode)
+        return;
+
+    FT_Outline_Get_CBox(&drawing->glyph->outline, &bbox);
+    drawing->glyph->root.advance.x = d6_to_d16(bbox.xMax - bbox.xMin);
+
+    drawing->desc = double_to_d6(-drawing->pbo * drawing->scale_y);
+    drawing->asc = bbox.yMax - bbox.yMin + drawing->desc;
+
+    // Place it onto the baseline
+    offset = (bbox.yMax - bbox.yMin) + double_to_d6(-drawing->pbo *
+                                                    drawing->scale_y);
+    for (i = 0; i < ol->n_points; i++)
+        ol->points[i].y += offset;
+}
+
+/*
+ * \brief Check whether a number of items on the list is available
+ */
+static int token_check_values(ass_drawing_token_t *token, int i, int type)
+{
+    int j;
+    for (j = 0; j < i; j++) {
+        if (!token || token->type != type) return 0;
+        token = token->next;
+    }
+
+    return 1;
+}
+
+/*
+ * \brief Tokenize a drawing string into a list of ass_drawing_token_t
+ * This also expands points for closing b-splines
+ */
+static ass_drawing_token_t *drawing_tokenize(char *str)
+{
+    char *p = str;
+    int i, val, type = -1, is_set = 0;
+    FT_Vector point = {0, 0};
+
+    ass_drawing_token_t *root = NULL, *tail = NULL, *spline_start = NULL;
+
+    while (*p) {
+        if (*p == 'c' && spline_start) {
+            // Close b-splines: add the first three points of the b-spline
+            // back to the end
+            if (token_check_values(spline_start->next, 2, TOKEN_B_SPLINE)) {
+                for (i = 0; i < 3; i++) {
+                    tail->next = calloc(1, sizeof(ass_drawing_token_t));
+                    tail->next->prev = tail;
+                    tail = tail->next;
+                    tail->type = TOKEN_B_SPLINE;
+                    tail->point = spline_start->point;
+                    spline_start = spline_start->next;
+                }
+                spline_start = NULL;
+            }
+        } else if (!is_set && mystrtoi(&p, &val)) {
+            point.x = val;
+            is_set = 1;
+            p--;
+        } else if (is_set == 1 && mystrtoi(&p, &val)) {
+            point.y = val;
+            is_set = 2;
+            p--;
+        } else if (*p == 'm')
+            type = TOKEN_MOVE;
+        else if (*p == 'n')
+            type = TOKEN_MOVE_NC;
+        else if (*p == 'l')
+            type = TOKEN_LINE;
+        else if (*p == 'b')
+            type = TOKEN_CUBIC_BEZIER;
+        else if (*p == 'q')
+            type = TOKEN_CONIC_BEZIER;
+        else if (*p == 's')
+            type = TOKEN_B_SPLINE;
+        // We're simply ignoring TOKEN_EXTEND_B_SPLINE here.
+        // This is not harmful at all, since it can be ommitted with
+        // similar result (the spline is extended anyway).
+
+        if (type != -1 && is_set == 2) {
+            if (root) {
+                tail->next = calloc(1, sizeof(ass_drawing_token_t));
+                tail->next->prev = tail;
+                tail = tail->next;
+            } else
+                root = tail = calloc(1, sizeof(ass_drawing_token_t));
+            tail->type = type;
+            tail->point = point;
+            is_set = 0;
+            if (type == TOKEN_B_SPLINE && !spline_start)
+                spline_start = tail->prev;
+        }
+        p++;
+    }
+
+#if 0
+    // Check tokens
+    ass_drawing_token_t *t = root;
+    while(t) {
+        printf("token %d point (%d, %d)\n", t->type, t->point.x, t->point.y);
+        t = t->next;
+    }
+#endif
+
+    return root;
+}
+
+/*
+ * \brief Free a list of tokens
+ */
+static void drawing_free_tokens(ass_drawing_token_t *token)
+{
+    while (token) {
+        ass_drawing_token_t *at = token;
+        token = token->next;
+        free(at);
+    }
+}
+
+/*
+ * \brief Translate and scale a point coordinate according to baseline
+ * offset and scale.
+ */
+static inline void translate_point(ass_drawing_t *drawing, FT_Vector *point)
+{
+    point->x = drawing->point_scale_x * point->x;
+    point->y = drawing->point_scale_y * -point->y;
+}
+
+/*
+ * \brief Evaluate a curve into lines
+ * This curve evaluator is also used in VSFilter (RTS.cpp); it's a simple
+ * implementation of the De Casteljau algorithm.
+ */
+static void drawing_evaluate_curve(ass_drawing_t *drawing,
+                                   ass_drawing_token_t *token, char spline,
+                                   int started)
+{
+    double cx3, cx2, cx1, cx0, cy3, cy2, cy1, cy0;
+    double t, h, max_accel, max_accel1, max_accel2;
+    FT_Vector cur = {0, 0};
+
+    cur = token->point;
+    translate_point(drawing, &cur);
+    int x0 = cur.x;
+    int y0 = cur.y;
+    token = token->next;
+    cur = token->point;
+    translate_point(drawing, &cur);
+    int x1 = cur.x;
+    int y1 = cur.y;
+    token = token->next;
+    cur = token->point;
+    translate_point(drawing, &cur);
+    int x2 = cur.x;
+    int y2 = cur.y;
+    token = token->next;
+    cur = token->point;
+    translate_point(drawing, &cur);
+    int x3 = cur.x;
+    int y3 = cur.y;
+
+    if (spline) {
+        // 1   [-1 +3 -3 +1]
+        // - * [+3 -6 +3  0]
+        // 6   [-3  0 +3  0]
+        //	   [+1 +4 +1  0]
+
+        double div6 = 1.0/6.0;
+
+        cx3 = div6*(-  x0+3*x1-3*x2+x3);
+        cx2 = div6*( 3*x0-6*x1+3*x2);
+        cx1 = div6*(-3*x0	   +3*x2);
+        cx0 = div6*(   x0+4*x1+1*x2);
+
+        cy3 = div6*(-  y0+3*y1-3*y2+y3);
+        cy2 = div6*( 3*y0-6*y1+3*y2);
+        cy1 = div6*(-3*y0     +3*y2);
+        cy0 = div6*(   y0+4*y1+1*y2);
+    } else {
+        // [-1 +3 -3 +1]
+        // [+3 -6 +3  0]
+        // [-3 +3  0  0]
+        // [+1  0  0  0]
+
+        cx3 = -  x0+3*x1-3*x2+x3;
+        cx2 =  3*x0-6*x1+3*x2;
+        cx1 = -3*x0+3*x1;
+        cx0 =    x0;
+
+        cy3 = -  y0+3*y1-3*y2+y3;
+        cy2 =  3*y0-6*y1+3*y2;
+        cy1 = -3*y0+3*y1;
+        cy0 =    y0;
+    }
+
+    max_accel1 = fabs(2 * cy2) + fabs(6 * cy3);
+    max_accel2 = fabs(2 * cx2) + fabs(6 * cx3);
+
+    max_accel = FFMAX(max_accel1, max_accel2);
+    h = 1.0;
+
+    if (max_accel > CURVE_ACCURACY)
+        h = sqrt(CURVE_ACCURACY / max_accel);
+
+    if (!started) {
+        cur.x = cx0;
+        cur.y = cy0;
+        drawing_add_point(drawing, &cur);
+    }
+
+    for (t = 0; t < 1.0; t += h) {
+        cur.x = cx0 + t * (cx1 + t * (cx2 + t * cx3));
+        cur.y = cy0 + t * (cy1 + t * (cy2 + t * cy3));
+        drawing_add_point(drawing, &cur);
+    }
+
+    cur.x = cx0 + cx1 + cx2 + cx3;
+    cur.y = cy0 + cy1 + cy2 + cy3;
+    drawing_add_point(drawing, &cur);
+}
+
+/*
+ * \brief Create and initialize a new drawing and return it
+ */
+ass_drawing_t *ass_drawing_new(void *fontconfig_priv, ass_font_t *font,
+                               ass_hinting_t hint, FT_Library lib)
+{
+    ass_drawing_t* drawing;
+
+    drawing = calloc(1, sizeof(*drawing));
+    drawing->text = calloc(1, DRAWING_INITIAL_SIZE);
+    drawing->size = DRAWING_INITIAL_SIZE;
+
+    drawing->ftlibrary = lib;
+    drawing->library = font->library;
+    drawing_make_glyph(drawing, fontconfig_priv, font, hint);
+
+    drawing->scale_x = 1.;
+    drawing->scale_y = 1.;
+    drawing->max_contours = GLYPH_INITIAL_CONTOURS;
+    drawing->max_points = GLYPH_INITIAL_POINTS;
+
+    return drawing;
+}
+
+/*
+ * \brief Free a drawing
+ */
+void ass_drawing_free(ass_drawing_t* drawing)
+{
+    FT_Done_Glyph((FT_Glyph) drawing->glyph);
+    free(drawing->text);
+    free(drawing);
+}
+
+/*
+ * \brief Add one ASCII character to the drawing text buffer
+ */
+void ass_drawing_add_char(ass_drawing_t* drawing, char symbol)
+{
+    drawing->text[drawing->i++] = symbol;
+    drawing->text[drawing->i] = 0;
+
+    if (drawing->i + 1 >= drawing->size) {
+        drawing->size *= 2;
+        drawing->text = realloc(drawing->text, drawing->size);
+    }
+}
+
+/*
+ * \brief Create a hashcode for the drawing
+ * XXX: To avoid collisions a better hash algorithm might be useful.
+ */
+void ass_drawing_hash(ass_drawing_t* drawing)
+{
+    drawing->hash = fnv_32a_str(drawing->text, FNV1_32A_INIT);
+}
+
+/*
+ * \brief Convert token list to outline.  Calls the line and curve evaluators.
+ */
+FT_OutlineGlyph *ass_drawing_parse(ass_drawing_t *drawing, int raw_mode)
+{
+    int started = 0;
+    ass_drawing_token_t *token;
+    FT_Vector pen = {0, 0};
+
+    drawing->tokens = drawing_tokenize(drawing->text);
+    drawing_prepare(drawing);
+
+    token = drawing->tokens;
+    while (token) {
+        // Draw something according to current command
+        switch (token->type) {
+        case TOKEN_MOVE_NC:
+            pen = token->point;
+            translate_point(drawing, &pen);
+            token = token->next;
+            break;
+        case TOKEN_MOVE:
+            pen = token->point;
+            translate_point(drawing, &pen);
+            if (started) {
+                drawing_close_shape(drawing);
+                started = 0;
+            }
+            token = token->next;
+            break;
+        case TOKEN_LINE: {
+            FT_Vector to;
+            to = token->point;
+            translate_point(drawing, &to);
+            if (!started) drawing_add_point(drawing, &pen);
+            drawing_add_point(drawing, &to);
+            started = 1;
+            token = token->next;
+            break;
+        }
+        case TOKEN_CUBIC_BEZIER:
+            if (token_check_values(token, 3, TOKEN_CUBIC_BEZIER) &&
+                token->prev) {
+                drawing_evaluate_curve(drawing, token->prev, 0, started);
+                token = token->next;
+                token = token->next;
+                token = token->next;
+                started = 1;
+            } else
+                token = token->next;
+            break;
+        case TOKEN_B_SPLINE:
+            if (token_check_values(token, 3, TOKEN_B_SPLINE) &&
+                token->prev) {
+                drawing_evaluate_curve(drawing, token->prev, 1, started);
+                token = token->next;
+                started = 1;
+            } else
+                token = token->next;
+            break;
+        default:
+            token = token->next;
+            break;
+        }
+    }
+
+    drawing_finish(drawing, raw_mode);
+    drawing_free_tokens(drawing->tokens);
+    return &drawing->glyph;
+}

Added: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_drawing.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_drawing.h	2009-07-31 22:24:31 UTC (rev 5184)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_drawing.h	2009-08-01 07:55:22 UTC (rev 5185)
@@ -0,0 +1,77 @@
+/*
+ * Copyright (C) 2009 Grigori Goronzy <greg at geekmind.org>
+ *
+ * This file is part of libass.
+ *
+ * Permission to use, copy, modify, and distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef LIBASS_DRAWING_H
+#define LIBASS_DRAWING_H
+
+#include <ft2build.h>
+#include FT_GLYPH_H
+
+#include "ass.h"
+
+#define DRAWING_INITIAL_SIZE 256
+
+typedef enum {
+    TOKEN_MOVE,
+    TOKEN_MOVE_NC,
+    TOKEN_LINE,
+    TOKEN_CUBIC_BEZIER,
+    TOKEN_CONIC_BEZIER,
+    TOKEN_B_SPLINE,
+    TOKEN_EXTEND_SPLINE,
+    TOKEN_CLOSE
+} ass_token_type_t;
+
+typedef struct ass_drawing_token {
+    ass_token_type_t type;
+    FT_Vector point;
+    struct ass_drawing_token *next;
+    struct ass_drawing_token *prev;
+} ass_drawing_token_t;
+
+typedef struct {
+    char *text; // drawing string
+    int i;      // text index
+    int scale;  // scale (1-64) for subpixel accuracy
+    double pbo; // drawing will be shifted in y direction by this amount
+    double scale_x;     // FontScaleX
+    double scale_y;     // FontScaleY
+    int asc;            // ascender
+    int desc;           // descender
+    FT_OutlineGlyph glyph;  // the "fake" glyph created for later rendering
+    int hash;           // hash value (for caching)
+
+    // private
+    FT_Library ftlibrary;   // FT library instance, needed for font ops
+    ass_library_t *library;
+    int size;           // current buffer size
+    ass_drawing_token_t *tokens;    // tokenized drawing
+    int max_points;     // current maximum size
+    int max_contours;
+    double point_scale_x;
+    double point_scale_y;
+} ass_drawing_t;
+
+ass_drawing_t *ass_drawing_new(void *fontconfig_priv, ass_font_t *font,
+                               ass_hinting_t hint, FT_Library lib);
+void ass_drawing_free(ass_drawing_t* drawing);
+void ass_drawing_add_char(ass_drawing_t* drawing, char symbol);
+void ass_drawing_hash(ass_drawing_t* drawing);
+FT_OutlineGlyph *ass_drawing_parse(ass_drawing_t *drawing, int raw_mode);
+
+#endif /* LIBASS_DRAWING_H */

Added: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_font.c
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_font.c	2009-07-31 22:24:31 UTC (rev 5184)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_font.c	2009-08-01 07:55:22 UTC (rev 5185)
@@ -0,0 +1,495 @@
+/*
+ * Copyright (C) 2006 Evgeniy Stepanov <eugeni.stepanov at gmail.com>
+ *
+ * This file is part of libass.
+ *
+ * libass is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * libass is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with libass; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include "config.h"
+
+#include <inttypes.h>
+#include <ft2build.h>
+#include FT_FREETYPE_H
+#include FT_SYNTHESIS_H
+#include FT_GLYPH_H
+#include FT_TRUETYPE_TABLES_H
+
+#include "ass.h"
+#include "ass_library.h"
+#include "ass_font.h"
+#include "ass_bitmap.h"
+#include "ass_cache.h"
+#include "ass_fontconfig.h"
+#include "ass_utils.h"
+
+/**
+ * Select Microfost Unicode CharMap, if the font has one.
+ * Otherwise, let FreeType decide.
+ */
+static void charmap_magic(ass_library_t *library, FT_Face face)
+{
+    int i;
+    for (i = 0; i < face->num_charmaps; ++i) {
+        FT_CharMap cmap = face->charmaps[i];
+        unsigned pid = cmap->platform_id;
+        unsigned eid = cmap->encoding_id;
+        if (pid == 3 /*microsoft */
+            && (eid == 1 /*unicode bmp */
+                || eid == 10 /*full unicode */ )) {
+            FT_Set_Charmap(face, cmap);
+            return;
+        }
+    }
+
+    if (!face->charmap) {
+        if (face->num_charmaps == 0) {
+            ass_msg(library, MSGL_WARN, "Font face with no charmaps");
+            return;
+        }
+        ass_msg(library, MSGL_WARN,
+                "No charmap autodetected, trying the first one");
+        FT_Set_Charmap(face, face->charmaps[0]);
+        return;
+    }
+}
+
+static void update_transform(ass_font_t *font)
+{
+    int i;
+    FT_Matrix m;
+    m.xx = double_to_d16(font->scale_x);
+    m.yy = double_to_d16(font->scale_y);
+    m.xy = m.yx = 0;
+    for (i = 0; i < font->n_faces; ++i)
+        FT_Set_Transform(font->faces[i], &m, &font->v);
+}
+
+/**
+ * \brief find a memory font by name
+ */
+static int find_font(ass_library_t *library, char *name)
+{
+    int i;
+    for (i = 0; i < library->num_fontdata; ++i)
+        if (strcasecmp(name, library->fontdata[i].name) == 0)
+            return i;
+    return -1;
+}
+
+static void face_set_size(FT_Face face, double size);
+
+static void buggy_font_workaround(FT_Face face)
+{
+    // Some fonts have zero Ascender/Descender fields in 'hhea' table.
+    // In this case, get the information from 'os2' table or, as
+    // a last resort, from face.bbox.
+    if (face->ascender + face->descender == 0 || face->height == 0) {
+        TT_OS2 *os2 = FT_Get_Sfnt_Table(face, ft_sfnt_os2);
+        if (os2) {
+            face->ascender = os2->sTypoAscender;
+            face->descender = os2->sTypoDescender;
+            face->height = face->ascender - face->descender;
+        } else {
+            face->ascender = face->bbox.yMax;
+            face->descender = face->bbox.yMin;
+            face->height = face->ascender - face->descender;
+        }
+    }
+}
+
+/**
+ * \brief Select a face with the given charcode and add it to ass_font_t
+ * \return index of the new face in font->faces, -1 if failed
+ */
+static int add_face(void *fc_priv, ass_font_t *font, uint32_t ch)
+{
+    char *path;
+    int index;
+    FT_Face face;
+    int error;
+    int mem_idx;
+
+    if (font->n_faces == ASS_FONT_MAX_FACES)
+        return -1;
+
+    path =
+        fontconfig_select(font->library, fc_priv, font->desc.family,
+                          font->desc.treat_family_as_pattern,
+                          font->desc.bold, font->desc.italic, &index, ch);
+    if (!path)
+        return -1;
+
+    mem_idx = find_font(font->library, path);
+    if (mem_idx >= 0) {
+        error =
+            FT_New_Memory_Face(font->ftlibrary,
+                               (unsigned char *) font->library->
+                               fontdata[mem_idx].data,
+                               font->library->fontdata[mem_idx].size, 0,
+                               &face);
+        if (error) {
+            ass_msg(font->library, MSGL_WARN,
+                    "Error opening memory font: '%s'", path);
+            free(path);
+            return -1;
+        }
+    } else {
+        error = FT_New_Face(font->ftlibrary, path, index, &face);
+        if (error) {
+            ass_msg(font->library, MSGL_WARN,
+                    "Error opening font: '%s', %d", path, index);
+            free(path);
+            return -1;
+        }
+    }
+    charmap_magic(font->library, face);
+    buggy_font_workaround(face);
+
+    font->faces[font->n_faces++] = face;
+    update_transform(font);
+    face_set_size(face, font->size);
+    free(path);
+    return font->n_faces - 1;
+}
+
+/**
+ * \brief Create a new ass_font_t according to "desc" argument
+ */
+ass_font_t *ass_font_new(void *font_cache, ass_library_t *library,
+                         FT_Library ftlibrary, void *fc_priv,
+                         ass_font_desc_t *desc)
+{
+    int error;
+    ass_font_t *fontp;
+    ass_font_t font;
+
+    fontp = ass_font_cache_find((hashmap_t *) font_cache, desc);
+    if (fontp)
+        return fontp;
+
+    font.library = library;
+    font.ftlibrary = ftlibrary;
+    font.n_faces = 0;
+    font.desc.family = strdup(desc->family);
+    font.desc.treat_family_as_pattern = desc->treat_family_as_pattern;
+    font.desc.bold = desc->bold;
+    font.desc.italic = desc->italic;
+
+    font.scale_x = font.scale_y = 1.;
+    font.v.x = font.v.y = 0;
+    font.size = 0.;
+
+    error = add_face(fc_priv, &font, 0);
+    if (error == -1) {
+        free(font.desc.family);
+        return 0;
+    } else
+        return ass_font_cache_add((hashmap_t *) font_cache, &font);
+}
+
+/**
+ * \brief Set font transformation matrix and shift vector
+ **/
+void ass_font_set_transform(ass_font_t *font, double scale_x,
+                            double scale_y, FT_Vector *v)
+{
+    font->scale_x = scale_x;
+    font->scale_y = scale_y;
+    if (v) {
+        font->v.x = v->x;
+        font->v.y = v->y;
+    }
+    update_transform(font);
+}
+
+static void face_set_size(FT_Face face, double size)
+{
+#if (FREETYPE_MAJOR > 2) || ((FREETYPE_MAJOR == 2) && (FREETYPE_MINOR > 1))
+    TT_HoriHeader *hori = FT_Get_Sfnt_Table(face, ft_sfnt_hhea);
+    TT_OS2 *os2 = FT_Get_Sfnt_Table(face, ft_sfnt_os2);
+    double mscale = 1.;
+    FT_Size_RequestRec rq;
+    FT_Size_Metrics *m = &face->size->metrics;
+    // VSFilter uses metrics from TrueType OS/2 table
+    // The idea was borrowed from asa (http://asa.diac24.net)
+    if (hori && os2) {
+        int hori_height = hori->Ascender - hori->Descender;
+        int os2_height = os2->usWinAscent + os2->usWinDescent;
+        if (hori_height && os2_height)
+            mscale = (double) hori_height / os2_height;
+    }
+    memset(&rq, 0, sizeof(rq));
+    rq.type = FT_SIZE_REQUEST_TYPE_REAL_DIM;
+    rq.width = 0;
+    rq.height = double_to_d6(size * mscale);
+    rq.horiResolution = rq.vertResolution = 0;
+    FT_Request_Size(face, &rq);
+    m->ascender /= mscale;
+    m->descender /= mscale;
+    m->height /= mscale;
+#else
+    FT_Set_Char_Size(face, 0, double_to_d6(size), 0, 0);
+#endif
+}
+
+/**
+ * \brief Set font size
+ **/
+void ass_font_set_size(ass_font_t *font, double size)
+{
+    int i;
+    if (font->size != size) {
+        font->size = size;
+        for (i = 0; i < font->n_faces; ++i)
+            face_set_size(font->faces[i], size);
+    }
+}
+
+/**
+ * \brief Get maximal font ascender and descender.
+ * \param ch character code
+ * The values are extracted from the font face that provides glyphs for the given character
+ **/
+void ass_font_get_asc_desc(ass_font_t *font, uint32_t ch, int *asc,
+                           int *desc)
+{
+    int i;
+    for (i = 0; i < font->n_faces; ++i) {
+        FT_Face face = font->faces[i];
+        TT_OS2 *os2 = FT_Get_Sfnt_Table(face, ft_sfnt_os2);
+        if (FT_Get_Char_Index(face, ch)) {
+            int y_scale = face->size->metrics.y_scale;
+            if (os2) {
+                *asc = FT_MulFix(os2->usWinAscent, y_scale);
+                *desc = FT_MulFix(os2->usWinDescent, y_scale);
+            } else {
+                *asc = FT_MulFix(face->ascender, y_scale);
+                *desc = FT_MulFix(-face->descender, y_scale);
+            }
+            return;
+        }
+    }
+
+    *asc = *desc = 0;
+}
+
+/*
+ * Strike a glyph with a horizontal line; it's possible to underline it
+ * and/or strike through it.  For the line's position and size, truetype
+ * tables are consulted.  Obviously this relies on the data in the tables
+ * being accurate.
+ *
+ */
+static int ass_strike_outline_glyph(FT_Face face, ass_font_t *font,
+                                    FT_Glyph glyph, int under, int through)
+{
+    TT_OS2 *os2 = FT_Get_Sfnt_Table(face, ft_sfnt_os2);
+    TT_Postscript *ps = FT_Get_Sfnt_Table(face, ft_sfnt_post);
+    FT_Outline *ol = &((FT_OutlineGlyph) glyph)->outline;
+    int bear, advance, y_scale, i;
+
+    // Grow outline
+    i = (under ? 4 : 0) + (through ? 4 : 0);
+    ol->points = realloc(ol->points, sizeof(FT_Vector) *
+                         (ol->n_points + i));
+    ol->tags = realloc(ol->tags, ol->n_points + i);
+    i = !!under + !!through;
+    ol->contours = realloc(ol->contours, sizeof(short) *
+                           (ol->n_contours + i));
+
+    // If the bearing is negative, the glyph starts left of the current
+    // pen position
+    bear = FFMIN(face->glyph->metrics.horiBearingX, 0);
+    // We're adding half a pixel to avoid small gaps
+    advance = d16_to_d6(glyph->advance.x) + 32;
+    y_scale = face->size->metrics.y_scale;
+
+    // Add points to the outline
+    if (under && ps) {
+        int pos, size;
+        pos = FT_MulFix(ps->underlinePosition, y_scale * font->scale_y);
+        size = FT_MulFix(ps->underlineThickness,
+                         y_scale * font->scale_y / 2);
+
+        if (pos > 0 || size <= 0)
+            return 0;
+
+        FT_Vector points[4] = {
+            {.x = bear,      .y = pos + size},
+            {.x = advance,   .y = pos + size},
+            {.x = advance,   .y = pos - size},
+            {.x = bear,      .y = pos - size},
+        };
+
+        for (i = 0; i < 4; i++) {
+            ol->points[ol->n_points] = points[i];
+            ol->tags[ol->n_points++] = 1;
+        }
+        ol->contours[ol->n_contours++] = ol->n_points - 1;
+    }
+
+    if (through && os2) {
+        int pos, size;
+        pos = FT_MulFix(os2->yStrikeoutPosition, y_scale * font->scale_y);
+        size = FT_MulFix(os2->yStrikeoutSize, y_scale * font->scale_y / 2);
+
+        if (pos < 0 || size <= 0)
+            return 0;
+
+        FT_Vector points[4] = {
+            {.x = bear,      .y = pos + size},
+            {.x = advance,   .y = pos + size},
+            {.x = advance,   .y = pos - size},
+            {.x = bear,      .y = pos - size},
+        };
+
+        for (i = 0; i < 4; i++) {
+            ol->points[ol->n_points] = points[i];
+            ol->tags[ol->n_points++] = 1;
+        }
+
+        ol->contours[ol->n_contours++] = ol->n_points - 1;
+    }
+
+    return 1;
+}
+
+/**
+ * \brief Get a glyph
+ * \param ch character code
+ **/
+FT_Glyph ass_font_get_glyph(void *fontconfig_priv, ass_font_t *font,
+                            uint32_t ch, ass_hinting_t hinting, int deco)
+{
+    int error;
+    int index = 0;
+    int i;
+    FT_Glyph glyph;
+    FT_Face face = 0;
+    int flags = 0;
+
+    if (ch < 0x20)
+        return 0;
+    if (font->n_faces == 0)
+        return 0;
+
+    for (i = 0; i < font->n_faces; ++i) {
+        face = font->faces[i];
+        index = FT_Get_Char_Index(face, ch);
+        if (index)
+            break;
+    }
+
+#ifdef CONFIG_FONTCONFIG
+    if (index == 0) {
+        int face_idx;
+        ass_msg(font->library, MSGL_INFO,
+                "Glyph 0x%X not found, selecting one more "
+                "font for (%s, %d, %d)", ch, font->desc.family,
+                font->desc.bold, font->desc.italic);
+        face_idx = add_face(fontconfig_priv, font, ch);
+        if (face_idx >= 0) {
+            face = font->faces[face_idx];
+            index = FT_Get_Char_Index(face, ch);
+            if (index == 0) {
+                ass_msg(font->library, MSGL_ERR,
+                        "Glyph 0x%X not found in font for (%s, %d, %d)",
+                        ch, font->desc.family, font->desc.bold,
+                        font->desc.italic);
+            }
+        }
+    }
+#endif
+
+    switch (hinting) {
+    case ASS_HINTING_NONE:
+        flags = FT_LOAD_NO_HINTING;
+        break;
+    case ASS_HINTING_LIGHT:
+        flags = FT_LOAD_FORCE_AUTOHINT | FT_LOAD_TARGET_LIGHT;
+        break;
+    case ASS_HINTING_NORMAL:
+        flags = FT_LOAD_FORCE_AUTOHINT;
+        break;
+    case ASS_HINTING_NATIVE:
+        flags = 0;
+        break;
+    }
+
+    error = FT_Load_Glyph(face, index, FT_LOAD_NO_BITMAP | flags);
+    if (error) {
+        ass_msg(font->library, MSGL_WARN, "Error loading glyph, index %d",
+                index);
+        return 0;
+    }
+#if (FREETYPE_MAJOR > 2) || \
+    ((FREETYPE_MAJOR == 2) && (FREETYPE_MINOR >= 2)) || \
+    ((FREETYPE_MAJOR == 2) && (FREETYPE_MINOR == 1) && (FREETYPE_PATCH >= 10))
+// FreeType >= 2.1.10 required
+    if (!(face->style_flags & FT_STYLE_FLAG_ITALIC) &&
+        (font->desc.italic > 55)) {
+        FT_GlyphSlot_Oblique(face->glyph);
+    }
+#endif
+    error = FT_Get_Glyph(face->glyph, &glyph);
+    if (error) {
+        ass_msg(font->library, MSGL_WARN, "Error loading glyph, index %d",
+                index);
+        return 0;
+    }
+
+    ass_strike_outline_glyph(face, font, glyph, deco & DECO_UNDERLINE,
+                             deco & DECO_STRIKETHROUGH);
+
+    return glyph;
+}
+
+/**
+ * \brief Get kerning for the pair of glyphs.
+ **/
+FT_Vector ass_font_get_kerning(ass_font_t *font, uint32_t c1, uint32_t c2)
+{
+    FT_Vector v = { 0, 0 };
+    int i;
+
+    for (i = 0; i < font->n_faces; ++i) {
+        FT_Face face = font->faces[i];
+        int i1 = FT_Get_Char_Index(face, c1);
+        int i2 = FT_Get_Char_Index(face, c2);
+        if (i1 && i2) {
+            if (FT_HAS_KERNING(face))
+                FT_Get_Kerning(face, i1, i2, FT_KERNING_DEFAULT, &v);
+            return v;
+        }
+        if (i1 || i2)           // these glyphs are from different font faces, no kerning information
+            return v;
+    }
+    return v;
+}
+
+/**
+ * \brief Deallocate ass_font_t
+ **/
+void ass_font_free(ass_font_t *font)
+{
+    int i;
+    for (i = 0; i < font->n_faces; ++i)
+        if (font->faces[i])
+            FT_Done_Face(font->faces[i]);
+    if (font->desc.family)
+        free(font->desc.family);
+    free(font);
+}

Added: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_font.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_font.h	2009-07-31 22:24:31 UTC (rev 5184)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_font.h	2009-08-01 07:55:22 UTC (rev 5185)
@@ -0,0 +1,66 @@
+/*
+ * Copyright (C) 2006 Evgeniy Stepanov <eugeni.stepanov at gmail.com>
+ *
+ * This file is part of libass.
+ *
+ * libass is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * libass is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with libass; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#ifndef LIBASS_FONT_H
+#define LIBASS_FONT_H
+
+#include <stdint.h>
+#include <ft2build.h>
+#include FT_GLYPH_H
+#include "ass.h"
+#include "ass_types.h"
+
+#define ASS_FONT_MAX_FACES 10
+#define DECO_UNDERLINE 1
+#define DECO_STRIKETHROUGH 2
+
+typedef struct {
+    char *family;
+    unsigned bold;
+    unsigned italic;
+    int treat_family_as_pattern;
+} ass_font_desc_t;
+
+typedef struct {
+    ass_font_desc_t desc;
+    ass_library_t *library;
+    FT_Library ftlibrary;
+    FT_Face faces[ASS_FONT_MAX_FACES];
+    int n_faces;
+    double scale_x, scale_y;    // current transform
+    FT_Vector v;                // current shift
+    double size;
+} ass_font_t;
+
+// FIXME: passing the hashmap via a void pointer is very ugly.
+ass_font_t *ass_font_new(void *font_cache, ass_library_t *library,
+                         FT_Library ftlibrary, void *fc_priv,
+                         ass_font_desc_t *desc);
+void ass_font_set_transform(ass_font_t *font, double scale_x,
+                            double scale_y, FT_Vector *v);
+void ass_font_set_size(ass_font_t *font, double size);
+void ass_font_get_asc_desc(ass_font_t *font, uint32_t ch, int *asc,
+                           int *desc);
+FT_Glyph ass_font_get_glyph(void *fontconfig_priv, ass_font_t *font,
+                            uint32_t ch, ass_hinting_t hinting, int flags);
+FT_Vector ass_font_get_kerning(ass_font_t *font, uint32_t c1, uint32_t c2);
+void ass_font_free(ass_font_t *font);
+
+#endif                          /* LIBASS_FONT_H */

Added: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_fontconfig.c
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_fontconfig.c	2009-07-31 22:24:31 UTC (rev 5184)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_fontconfig.c	2009-08-01 07:55:22 UTC (rev 5185)
@@ -0,0 +1,575 @@
+/*
+ * Copyright (C) 2006 Evgeniy Stepanov <eugeni.stepanov at gmail.com>
+ *
+ * This file is part of libass.
+ *
+ * libass is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * libass is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with libass; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include "config.h"
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <assert.h>
+#include <string.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <inttypes.h>
+#include <ft2build.h>
+#include FT_FREETYPE_H
+
+#include "ass_utils.h"
+#include "ass.h"
+#include "ass_library.h"
+#include "ass_fontconfig.h"
+
+#ifdef CONFIG_FONTCONFIG
+#include <fontconfig/fontconfig.h>
+#include <fontconfig/fcfreetype.h>
+#endif
+
+struct fc_instance {
+#ifdef CONFIG_FONTCONFIG
+    FcConfig *config;
+#endif
+    char *family_default;
+    char *path_default;
+    int index_default;
+};
+
+#ifdef CONFIG_FONTCONFIG
+
+// 4yo fontconfig does not have these.
+// They are only needed for debug output, anyway.
+#ifndef FC_FULLNAME
+#define FC_FULLNAME "fullname"
+#endif
+#ifndef FC_EMBOLDEN
+#define FC_EMBOLDEN "embolden"
+#endif
+
+/**
+ * \brief Low-level font selection.
+ * \param priv private data
+ * \param family font family
+ * \param treat_family_as_pattern treat family as fontconfig pattern
+ * \param bold font weight value
+ * \param italic font slant value
+ * \param index out: font index inside a file
+ * \param code: the character that should be present in the font, can be 0
+ * \return font file path
+*/
+static char *_select_font(ass_library_t *library, fc_instance_t *priv,
+                          const char *family, int treat_family_as_pattern,
+                          unsigned bold, unsigned italic, int *index,
+                          uint32_t code)
+{
+    FcBool rc;
+    FcResult result;
+    FcPattern *pat = NULL, *rpat = NULL;
+    int r_index, r_slant, r_weight;
+    FcChar8 *r_family, *r_style, *r_file, *r_fullname;
+    FcBool r_outline, r_embolden;
+    FcCharSet *r_charset;
+    FcFontSet *fset = NULL;
+    int curf;
+    char *retval = NULL;
+    int family_cnt = 0;
+
+    *index = 0;
+
+    if (treat_family_as_pattern)
+        pat = FcNameParse((const FcChar8 *) family);
+    else
+        pat = FcPatternCreate();
+
+    if (!pat)
+        goto error;
+
+    if (!treat_family_as_pattern) {
+        FcPatternAddString(pat, FC_FAMILY, (const FcChar8 *) family);
+
+        // In SSA/ASS fonts are sometimes referenced by their "full name",
+        // which is usually a concatenation of family name and font
+        // style (ex. Ottawa Bold). Full name is available from
+        // FontConfig pattern element FC_FULLNAME, but it is never
+        // used for font matching.
+        // Therefore, I'm removing words from the end of the name one
+        // by one, and adding shortened names to the pattern. It seems
+        // that the first value (full name in this case) has
+        // precedence in matching.
+        // An alternative approach could be to reimplement FcFontSort
+        // using FC_FULLNAME instead of FC_FAMILY.
+        family_cnt = 1;
+        {
+            char *s = strdup(family);
+            char *p = s + strlen(s);
+            while (--p > s)
+                if (*p == ' ' || *p == '-') {
+                    *p = '\0';
+                    FcPatternAddString(pat, FC_FAMILY, (const FcChar8 *) s);
+                    ++family_cnt;
+                }
+            free(s);
+        }
+    }
+    FcPatternAddBool(pat, FC_OUTLINE, FcTrue);
+    FcPatternAddInteger(pat, FC_SLANT, italic);
+    FcPatternAddInteger(pat, FC_WEIGHT, bold);
+
+    FcDefaultSubstitute(pat);
+
+    rc = FcConfigSubstitute(priv->config, pat, FcMatchPattern);
+    if (!rc)
+        goto error;
+
+    fset = FcFontSort(priv->config, pat, FcTrue, NULL, &result);
+    if (!fset)
+        goto error;
+
+    for (curf = 0; curf < fset->nfont; ++curf) {
+        FcPattern *curp = fset->fonts[curf];
+
+        result = FcPatternGetBool(curp, FC_OUTLINE, 0, &r_outline);
+        if (result != FcResultMatch)
+            continue;
+        if (r_outline != FcTrue)
+            continue;
+        if (!code)
+            break;
+        result = FcPatternGetCharSet(curp, FC_CHARSET, 0, &r_charset);
+        if (result != FcResultMatch)
+            continue;
+        if (FcCharSetHasChar(r_charset, code))
+            break;
+    }
+
+    if (curf >= fset->nfont)
+        goto error;
+
+#if (FC_VERSION >= 20297)
+    if (!treat_family_as_pattern) {
+        // Remove all extra family names from original pattern.
+        // After this, FcFontRenderPrepare will select the most relevant family
+        // name in case there are more than one of them.
+        for (; family_cnt > 1; --family_cnt)
+            FcPatternRemove(pat, FC_FAMILY, family_cnt - 1);
+    }
+#endif
+
+    rpat = FcFontRenderPrepare(priv->config, pat, fset->fonts[curf]);
+    if (!rpat)
+        goto error;
+
+    result = FcPatternGetInteger(rpat, FC_INDEX, 0, &r_index);
+    if (result != FcResultMatch)
+        goto error;
+    *index = r_index;
+
+    result = FcPatternGetString(rpat, FC_FILE, 0, &r_file);
+    if (result != FcResultMatch)
+        goto error;
+    retval = strdup((const char *) r_file);
+
+    result = FcPatternGetString(rpat, FC_FAMILY, 0, &r_family);
+    if (result != FcResultMatch)
+        r_family = NULL;
+
+    result = FcPatternGetString(rpat, FC_FULLNAME, 0, &r_fullname);
+    if (result != FcResultMatch)
+        r_fullname = NULL;
+
+    if (!treat_family_as_pattern &&
+        !(r_family && strcasecmp((const char *) r_family, family) == 0) &&
+        !(r_fullname && strcasecmp((const char *) r_fullname, family) == 0))
+        ass_msg(library, MSGL_WARN,
+               "fontconfig: Selected font is not the requested one: "
+               "'%s' != '%s'",
+               (const char *) (r_fullname ? r_fullname : r_family), family);
+
+    result = FcPatternGetString(rpat, FC_STYLE, 0, &r_style);
+    if (result != FcResultMatch)
+        r_style = NULL;
+
+    result = FcPatternGetInteger(rpat, FC_SLANT, 0, &r_slant);
+    if (result != FcResultMatch)
+        r_slant = 0;
+
+    result = FcPatternGetInteger(rpat, FC_WEIGHT, 0, &r_weight);
+    if (result != FcResultMatch)
+        r_weight = 0;
+
+    result = FcPatternGetBool(rpat, FC_EMBOLDEN, 0, &r_embolden);
+    if (result != FcResultMatch)
+        r_embolden = 0;
+
+    ass_msg(library, MSGL_V,
+           "Font info: family '%s', style '%s', fullname '%s',"
+           " slant %d, weight %d%s", (const char *) r_family,
+           (const char *) r_style, (const char *) r_fullname, r_slant,
+           r_weight, r_embolden ? ", embolden" : "");
+
+  error:
+    if (pat)
+        FcPatternDestroy(pat);
+    if (rpat)
+        FcPatternDestroy(rpat);
+    if (fset)
+        FcFontSetDestroy(fset);
+    return retval;
+}
+
+/**
+ * \brief Find a font. Use default family or path if necessary.
+ * \param priv_ private data
+ * \param family font family
+ * \param treat_family_as_pattern treat family as fontconfig pattern
+ * \param bold font weight value
+ * \param italic font slant value
+ * \param index out: font index inside a file
+ * \param code: the character that should be present in the font, can be 0
+ * \return font file path
+*/
+char *fontconfig_select(ass_library_t *library, fc_instance_t *priv,
+                        const char *family, int treat_family_as_pattern,
+                        unsigned bold, unsigned italic, int *index,
+                        uint32_t code)
+{
+    char *res = 0;
+    if (!priv->config) {
+        *index = priv->index_default;
+        return priv->path_default;
+    }
+    if (family && *family)
+        res =
+            _select_font(library, priv, family, treat_family_as_pattern,
+                         bold, italic, index, code);
+    if (!res && priv->family_default) {
+        res =
+            _select_font(library, priv, priv->family_default, 0, bold,
+                         italic, index, code);
+        if (res)
+            ass_msg(library, MSGL_WARN, "fontconfig_select: Using default "
+                    "font family: (%s, %d, %d) -> %s, %d",
+                    family, bold, italic, res, *index);
+    }
+    if (!res && priv->path_default) {
+        res = priv->path_default;
+        *index = priv->index_default;
+        ass_msg(library, MSGL_WARN, "fontconfig_select: Using default font: "
+                "(%s, %d, %d) -> %s, %d", family, bold, italic,
+                res, *index);
+    }
+    if (!res) {
+        res = _select_font(library, priv, "Arial", 0, bold, italic,
+                           index, code);
+        if (res)
+            ass_msg(library, MSGL_WARN, "fontconfig_select: Using 'Arial' "
+                    "font family: (%s, %d, %d) -> %s, %d", family, bold,
+                    italic, res, *index);
+    }
+    if (res)
+        ass_msg(library, MSGL_V,
+                "fontconfig_select: (%s, %d, %d) -> %s, %d", family, bold,
+                italic, res, *index);
+    return res;
+}
+
+#if (FC_VERSION < 20402)
+static char *validate_fname(char *name)
+{
+    char *fname;
+    char *p;
+    char *q;
+    unsigned code;
+    int sz = strlen(name);
+
+    q = fname = malloc(sz + 1);
+    p = name;
+    while (*p) {
+        code = ass_utf8_get_char(&p);
+        if (code == 0)
+            break;
+        if ((code > 0x7F) ||
+            (code == '\\') ||
+            (code == '/') ||
+            (code == ':') ||
+            (code == '*') ||
+            (code == '?') ||
+            (code == '<') ||
+            (code == '>') || (code == '|') || (code == 0)) {
+            *q++ = '_';
+        } else {
+            *q++ = code;
+        }
+        if (p - name > sz)
+            break;
+    }
+    *q = 0;
+    return fname;
+}
+#endif
+
+/**
+ * \brief Process memory font.
+ * \param priv private data
+ * \param library library object
+ * \param ftlibrary freetype library object
+ * \param idx index of the processed font in library->fontdata
+ * With FontConfig >= 2.4.2, builds a font pattern in memory via FT_New_Memory_Face/FcFreeTypeQueryFace.
+ * With older FontConfig versions, save the font to ~/.mplayer/fonts.
+*/
+static void process_fontdata(fc_instance_t *priv, ass_library_t *library,
+                             FT_Library ftlibrary, int idx)
+{
+    int rc;
+    const char *name = library->fontdata[idx].name;
+    const char *data = library->fontdata[idx].data;
+    int data_size = library->fontdata[idx].size;
+
+#if (FC_VERSION < 20402)
+    struct stat st;
+    char *fname;
+    const char *fonts_dir = library->fonts_dir;
+    char buf[1000];
+    FILE *fp = NULL;
+
+    if (!fonts_dir)
+        return;
+    rc = stat(fonts_dir, &st);
+    if (rc) {
+        int res;
+#ifndef __MINGW32__
+        res = mkdir(fonts_dir, 0700);
+#else
+        res = mkdir(fonts_dir);
+#endif
+        if (res) {
+            ass_msg(library, MSGL_WARN, "Failed to create directory '%s'",
+                    fonts_dir);
+        }
+    } else if (!S_ISDIR(st.st_mode)) {
+        ass_msg(library, MSGL_WARN, "Not a directory: '%s'", fonts_dir);
+    }
+
+    fname = validate_fname((char *) name);
+
+    snprintf(buf, 1000, "%s/%s", fonts_dir, fname);
+    free(fname);
+
+    fp = fopen(buf, "wb");
+    if (!fp)
+        return;
+
+    fwrite(data, data_size, 1, fp);
+    fclose(fp);
+
+#else                           // (FC_VERSION >= 20402)
+    FT_Face face;
+    FcPattern *pattern;
+    FcFontSet *fset;
+    FcBool res;
+    int face_index, num_faces = 1;
+
+    for (face_index = 0; face_index < num_faces; ++face_index) {
+        rc = FT_New_Memory_Face(ftlibrary, (unsigned char *) data,
+                                data_size, face_index, &face);
+        if (rc) {
+            ass_msg(library, MSGL_WARN, "Error opening memory font: %s",
+                   name);
+            return;
+        }
+        num_faces = face->num_faces;
+
+        pattern =
+            FcFreeTypeQueryFace(face, (unsigned char *) name, 0,
+                                FcConfigGetBlanks(priv->config));
+        if (!pattern) {
+            ass_msg(library, MSGL_WARN, "%s failed", "FcFreeTypeQueryFace");
+            FT_Done_Face(face);
+            return;
+        }
+
+        fset = FcConfigGetFonts(priv->config, FcSetSystem);     // somehow it failes when asked for FcSetApplication
+        if (!fset) {
+            ass_msg(library, MSGL_WARN, "%s failed", "FcConfigGetFonts");
+            FT_Done_Face(face);
+            return;
+        }
+
+        res = FcFontSetAdd(fset, pattern);
+        if (!res) {
+            ass_msg(library, MSGL_WARN, "%s failed", "FcFontSetAdd");
+            FT_Done_Face(face);
+            return;
+        }
+
+        FT_Done_Face(face);
+    }
+#endif
+}
+
+/**
+ * \brief Init fontconfig.
+ * \param library libass library object
+ * \param ftlibrary freetype library object
+ * \param family default font family
+ * \param path default font path
+ * \param fc whether fontconfig should be used
+ * \param config path to a fontconfig configuration file, or NULL
+ * \param update whether the fontconfig cache should be built/updated
+ * \return pointer to fontconfig private data
+*/
+fc_instance_t *fontconfig_init(ass_library_t *library,
+                               FT_Library ftlibrary, const char *family,
+                               const char *path, int fc, const char *config,
+                               int update)
+{
+    int rc;
+    fc_instance_t *priv = calloc(1, sizeof(fc_instance_t));
+    const char *dir = library->fonts_dir;
+    int i;
+
+    if (!fc) {
+        ass_msg(library, MSGL_WARN,
+               "Fontconfig disabled, only default font will be used.");
+        goto exit;
+    }
+
+    priv->config = FcConfigCreate();
+    rc = FcConfigParseAndLoad(priv->config, (unsigned char *) config, FcTrue);
+    if (!rc) {
+        ass_msg(library, MSGL_WARN, "No usable fontconfig configuration "
+                "file found, using fallback.");
+        FcConfigDestroy(priv->config);
+        priv->config = FcInitLoadConfig();
+        rc++;
+    }
+    if (rc && update) {
+        FcConfigBuildFonts(priv->config);
+    }
+
+    if (!rc || !priv->config) {
+        ass_msg(library, MSGL_FATAL,
+                "No valid fontconfig configuration found!");
+        FcConfigDestroy(priv->config);
+        goto exit;
+    }
+
+    for (i = 0; i < library->num_fontdata; ++i)
+        process_fontdata(priv, library, ftlibrary, i);
+
+    if (dir) {
+        if (FcDirCacheValid((const FcChar8 *) dir) == FcFalse) {
+            ass_msg(library, MSGL_INFO, "Updating font cache");
+            if (FcGetVersion() >= 20390 && FcGetVersion() < 20400)
+                ass_msg(library, MSGL_WARN, "Beta versions of fontconfig"
+                        "are not supported. Update before reporting any bugs");
+            // FontConfig >= 2.4.0 updates cache automatically in FcConfigAppFontAddDir()
+            if (FcGetVersion() < 20390) {
+                FcFontSet *fcs;
+                FcStrSet *fss;
+                fcs = FcFontSetCreate();
+                fss = FcStrSetCreate();
+                rc = FcStrSetAdd(fss, (const FcChar8 *) dir);
+                if (!rc) {
+                    ass_msg(library, MSGL_WARN, "%s failed", "FcStrSetAdd");
+                    goto ErrorFontCache;
+                }
+
+                rc = FcDirScan(fcs, fss, NULL,
+                               FcConfigGetBlanks(priv->config),
+                               (const FcChar8 *) dir, FcFalse);
+                if (!rc) {
+                    ass_msg(library, MSGL_WARN, "%s failed", "FcDirScan");
+                    goto ErrorFontCache;
+                }
+
+                rc = FcDirSave(fcs, fss, (const FcChar8 *) dir);
+                if (!rc) {
+                    ass_msg(library, MSGL_WARN, "%s failed", "FcDirSave");
+                    goto ErrorFontCache;
+                }
+              ErrorFontCache:
+                ;
+            }
+        }
+
+        rc = FcConfigAppFontAddDir(priv->config, (const FcChar8 *) dir);
+        if (!rc) {
+            ass_msg(library, MSGL_WARN, "%s failed", "FcConfigAppFontAddDir");
+        }
+    }
+
+    priv->family_default = family ? strdup(family) : NULL;
+exit:
+    priv->path_default = path ? strdup(path) : NULL;
+    priv->index_default = 0;
+
+    return priv;
+}
+
+int fontconfig_update(fc_instance_t *priv)
+{
+        return FcConfigBuildFonts(priv->config);
+}
+
+#else                           /* CONFIG_FONTCONFIG */
+
+char *fontconfig_select(ass_library_t *library, fc_instance_t *priv,
+                        const char *family, int treat_family_as_pattern,
+                        unsigned bold, unsigned italic, int *index,
+                        uint32_t code)
+{
+    *index = priv->index_default;
+    return priv->path_default;
+}
+
+fc_instance_t *fontconfig_init(ass_library_t *library,
+                               FT_Library ftlibrary, const char *family,
+                               const char *path, int fc, const char *config,
+                               int update)
+{
+    fc_instance_t *priv;
+
+    ass_msg(library, MSGL_WARN,
+        "Fontconfig disabled, only default font will be used.");
+
+    priv = calloc(1, sizeof(fc_instance_t));
+
+    priv->path_default = strdup(path);
+    priv->index_default = 0;
+    return priv;
+}
+
+int fontconfig_update(fc_instance_t *priv)
+{
+    // Do nothing
+    return 1;
+}
+
+#endif
+
+void fontconfig_done(fc_instance_t *priv)
+{
+    if (priv && priv->config)
+        FcConfigDestroy(priv->config);
+    if (priv && priv->path_default)
+        free(priv->path_default);
+    if (priv && priv->family_default)
+        free(priv->family_default);
+    if (priv)
+        free(priv);
+}

Added: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_fontconfig.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_fontconfig.h	2009-07-31 22:24:31 UTC (rev 5184)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_fontconfig.h	2009-08-01 07:55:22 UTC (rev 5185)
@@ -0,0 +1,47 @@
+/*
+ * Copyright (C) 2006 Evgeniy Stepanov <eugeni.stepanov at gmail.com>
+ *
+ * This file is part of libass.
+ *
+ * libass is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * libass is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with libass; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#ifndef LIBASS_FONTCONFIG_H
+#define LIBASS_FONTCONFIG_H
+
+#include <stdint.h>
+#include "ass_types.h"
+#include "ass.h"
+#include <ft2build.h>
+#include FT_FREETYPE_H
+
+#ifdef CONFIG_FONTCONFIG
+#include <fontconfig/fontconfig.h>
+#endif
+
+typedef struct fc_instance fc_instance_t;
+
+fc_instance_t *fontconfig_init(ass_library_t *library,
+                               FT_Library ftlibrary, const char *family,
+                               const char *path, int fc, const char *config,
+                               int update);
+char *fontconfig_select(ass_library_t *library, fc_instance_t *priv,
+                        const char *family, int treat_family_as_pattern,
+                        unsigned bold, unsigned italic, int *index,
+                        uint32_t code);
+void fontconfig_done(fc_instance_t *priv);
+int fontconfig_update(fc_instance_t *priv);
+
+#endif                          /* LIBASS_FONTCONFIG_H */

Added: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_library.c
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_library.c	2009-07-31 22:24:31 UTC (rev 5184)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_library.c	2009-08-01 07:55:22 UTC (rev 5185)
@@ -0,0 +1,147 @@
+/*
+ * Copyright (C) 2006 Evgeniy Stepanov <eugeni.stepanov at gmail.com>
+ *
+ * This file is part of libass.
+ *
+ * libass is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * libass is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with libass; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include <inttypes.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <stdarg.h>
+
+#include "ass.h"
+#include "ass_library.h"
+#include "ass_utils.h"
+
+static void ass_msg_handler(int level, const char *fmt, va_list va, void *data)
+{
+    if (level > MSGL_INFO)
+        return;
+    fprintf(stderr, "[ass] ");
+    vfprintf(stderr, fmt, va);
+    fprintf(stderr, "\n");
+}
+
+ass_library_t *ass_library_init(void)
+{
+    ass_library_t* lib = calloc(1, sizeof(ass_library_t));
+    lib->msg_callback = ass_msg_handler;
+
+    return lib;
+}
+
+void ass_library_done(ass_library_t *priv)
+{
+    if (priv) {
+        ass_set_fonts_dir(priv, NULL);
+        ass_set_style_overrides(priv, NULL);
+        ass_clear_fonts(priv);
+        free(priv);
+    }
+}
+
+void ass_set_fonts_dir(ass_library_t *priv, const char *fonts_dir)
+{
+    if (priv->fonts_dir)
+        free(priv->fonts_dir);
+
+    priv->fonts_dir = fonts_dir ? strdup(fonts_dir) : 0;
+}
+
+void ass_set_extract_fonts(ass_library_t *priv, int extract)
+{
+    priv->extract_fonts = !!extract;
+}
+
+void ass_set_style_overrides(ass_library_t *priv, char **list)
+{
+    char **p;
+    char **q;
+    int cnt;
+
+    if (priv->style_overrides) {
+        for (p = priv->style_overrides; *p; ++p)
+            free(*p);
+        free(priv->style_overrides);
+    }
+
+    if (!list)
+        return;
+
+    for (p = list, cnt = 0; *p; ++p, ++cnt) {
+    }
+
+    priv->style_overrides = malloc((cnt + 1) * sizeof(char *));
+    for (p = list, q = priv->style_overrides; *p; ++p, ++q)
+        *q = strdup(*p);
+    priv->style_overrides[cnt] = NULL;
+}
+
+static void grow_array(void **array, int nelem, size_t elsize)
+{
+    if (!(nelem & 31))
+        *array = realloc(*array, (nelem + 32) * elsize);
+}
+
+void ass_add_font(ass_library_t *priv, char *name, char *data, int size)
+{
+    int idx = priv->num_fontdata;
+    if (!name || !data || !size)
+        return;
+    grow_array((void **) &priv->fontdata, priv->num_fontdata,
+               sizeof(*priv->fontdata));
+
+    priv->fontdata[idx].name = strdup(name);
+
+    priv->fontdata[idx].data = malloc(size);
+    memcpy(priv->fontdata[idx].data, data, size);
+
+    priv->fontdata[idx].size = size;
+
+    priv->num_fontdata++;
+}
+
+void ass_clear_fonts(ass_library_t *priv)
+{
+    int i;
+    for (i = 0; i < priv->num_fontdata; ++i) {
+        free(priv->fontdata[i].name);
+        free(priv->fontdata[i].data);
+    }
+    free(priv->fontdata);
+    priv->fontdata = NULL;
+    priv->num_fontdata = 0;
+}
+
+/*
+ * Register a message callback function with libass.  Without setting one,
+ * a default handler is used which prints everything with MSGL_INFO or
+ * higher to the standard output.
+ *
+ * \param msg_cb the callback function
+ * \param data additional data that will be passed to the callback
+ */
+void ass_set_message_cb(ass_library_t *priv,
+                        void (*msg_cb)(int, const char *, va_list, void *),
+                        void *data)
+{
+    if (msg_cb) {
+        priv->msg_callback = msg_cb;
+        priv->msg_callback_data = data;
+    }
+}

Added: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_library.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_library.h	2009-07-31 22:24:31 UTC (rev 5184)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_library.h	2009-08-01 07:55:22 UTC (rev 5185)
@@ -0,0 +1,43 @@
+/*
+ * Copyright (C) 2006 Evgeniy Stepanov <eugeni.stepanov at gmail.com>
+ *
+ * This file is part of libass.
+ *
+ * libass is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * libass is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with libass; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#ifndef LIBASS_LIBRARY_H
+#define LIBASS_LIBRARY_H
+
+#include <stdarg.h>
+
+typedef struct {
+    char *name;
+    char *data;
+    int size;
+} ass_fontdata_t;
+
+struct ass_library {
+    char *fonts_dir;
+    int extract_fonts;
+    char **style_overrides;
+
+    ass_fontdata_t *fontdata;
+    int num_fontdata;
+    void (*msg_callback)(int, const char *, va_list, void *);
+    void *msg_callback_data;
+};
+
+#endif                          /* LIBASS_LIBRARY_H */

Added: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_render.c
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_render.c	2009-07-31 22:24:31 UTC (rev 5184)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_render.c	2009-08-01 07:55:22 UTC (rev 5185)
@@ -0,0 +1,3615 @@
+/*
+ * Copyright (C) 2006 Evgeniy Stepanov <eugeni.stepanov at gmail.com>
+ *
+ * This file is part of libass.
+ *
+ * libass is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * libass is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with libass; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include "config.h"
+
+#include <assert.h>
+#include <math.h>
+#include <inttypes.h>
+#include <ft2build.h>
+#include FT_FREETYPE_H
+#include FT_STROKER_H
+#include FT_GLYPH_H
+#include FT_SYNTHESIS_H
+
+#include "ass.h"
+#include "ass_font.h"
+#include "ass_bitmap.h"
+#include "ass_cache.h"
+#include "ass_utils.h"
+#include "ass_fontconfig.h"
+#include "ass_library.h"
+#include "ass_drawing.h"
+
+#define MAX_GLYPHS_INITIAL 1024
+#define MAX_LINES_INITIAL 64
+#define BLUR_MAX_RADIUS 100.0
+#define MAX_BE 127
+#define SUBPIXEL_MASK 63
+#define SUBPIXEL_ACCURACY 7    // d6 mask for subpixel accuracy adjustment
+#define GLYPH_CACHE_MAX 1000
+#define BITMAP_CACHE_MAX_SIZE 50 * 1048576;
+
+typedef struct {
+    double xMin;
+    double xMax;
+    double yMin;
+    double yMax;
+} double_bbox_t;
+
+typedef struct {
+    double x;
+    double y;
+} double_vector_t;
+
+typedef struct free_list {
+    void *object;
+    struct free_list *next;
+} free_list_t;
+
+typedef struct {
+    int frame_width;
+    int frame_height;
+    double font_size_coeff;     // font size multiplier
+    double line_spacing;        // additional line spacing (in frame pixels)
+    int top_margin;             // height of top margin. Everything except toptitles is shifted down by top_margin.
+    int bottom_margin;          // height of bottom margin. (frame_height - top_margin - bottom_margin) is original video height.
+    int left_margin;
+    int right_margin;
+    int use_margins;            // 0 - place all subtitles inside original frame
+    // 1 - use margins for placing toptitles and subtitles
+    double aspect;              // frame aspect ratio, d_width / d_height.
+    double pixel_ratio;         // pixel ratio of the source image
+    ass_hinting_t hinting;
+
+    char *default_font;
+    char *default_family;
+} ass_settings_t;
+
+// a rendered event
+typedef struct {
+    ass_image_t *imgs;
+    int top, height;
+    int detect_collisions;
+    int shift_direction;
+    ass_event_t *event;
+} event_images_t;
+
+typedef enum { EF_NONE = 0, EF_KARAOKE, EF_KARAOKE_KF, EF_KARAOKE_KO
+} effect_t;
+
+// describes a glyph
+// glyph_info_t and text_info_t are used for text centering and word-wrapping operations
+typedef struct {
+    unsigned symbol;
+    FT_Glyph glyph;
+    FT_Glyph outline_glyph;
+    bitmap_t *bm;               // glyph bitmap
+    bitmap_t *bm_o;             // outline bitmap
+    bitmap_t *bm_s;             // shadow bitmap
+    FT_BBox bbox;
+    FT_Vector pos;
+    char linebreak;             // the first (leading) glyph of some line ?
+    uint32_t c[4];              // colors
+    FT_Vector advance;          // 26.6
+    effect_t effect_type;
+    int effect_timing;          // time duration of current karaoke word
+    // after process_karaoke_effects: distance in pixels from the glyph origin.
+    // part of the glyph to the left of it is displayed in a different color.
+    int effect_skip_timing;     // delay after the end of last karaoke word
+    int asc, desc;              // font max ascender and descender
+//      int height;
+    int be;                     // blur edges
+    double blur;                // gaussian blur
+    double shadow_x;
+    double shadow_y;
+    double frx, fry, frz;       // rotation
+    double fax, fay;            // text shearing
+
+    bitmap_hash_key_t hash_key;
+} glyph_info_t;
+
+typedef struct {
+    double asc, desc;
+} line_info_t;
+
+typedef struct {
+    glyph_info_t *glyphs;
+    int length;
+    line_info_t *lines;
+    int n_lines;
+    double height;
+    int max_glyphs;
+    int max_lines;
+} text_info_t;
+
+
+// Renderer state.
+// Values like current font face, color, screen position, clipping and so on are stored here.
+typedef struct {
+    ass_event_t *event;
+    ass_style_t *style;
+
+    ass_font_t *font;
+    char *font_path;
+    double font_size;
+    int flags;                  // decoration flags (underline/strike-through)
+
+    FT_Stroker stroker;
+    int alignment;              // alignment overrides go here; if zero, style value will be used
+    double frx, fry, frz;
+    double fax, fay;            // text shearing
+    enum { EVENT_NORMAL,        // "normal" top-, sub- or mid- title
+        EVENT_POSITIONED,       // happens after pos(,), margins are ignored
+        EVENT_HSCROLL,          // "Banner" transition effect, text_width is unlimited
+        EVENT_VSCROLL           // "Scroll up", "Scroll down" transition effects
+    } evt_type;
+    double pos_x, pos_y;        // position
+    double org_x, org_y;        // origin
+    char have_origin;           // origin is explicitly defined; if 0, get_base_point() is used
+    double scale_x, scale_y;
+    double hspacing;            // distance between letters, in pixels
+    double border_x;              // outline width
+    double border_y;
+    uint32_t c[4];              // colors(Primary, Secondary, so on) in RGBA
+    int clip_x0, clip_y0, clip_x1, clip_y1;
+    char clip_mode;             // 1 = iclip
+    char detect_collisions;
+    uint32_t fade;              // alpha from \fad
+    char be;                    // blur edges
+    double blur;                // gaussian blur
+    double shadow_x;
+    double shadow_y;
+    int drawing_mode;           // not implemented; when != 0 text is discarded, except for style override tags
+    ass_drawing_t *drawing;     // current drawing
+    ass_drawing_t *clip_drawing;// clip vector
+    int clip_drawing_mode;      // 0 = regular clip, 1 = inverse clip
+
+    effect_t effect_type;
+    int effect_timing;
+    int effect_skip_timing;
+
+    enum { SCROLL_LR,           // left-to-right
+        SCROLL_RL,
+        SCROLL_TB,              // top-to-bottom
+        SCROLL_BT
+    } scroll_direction;         // for EVENT_HSCROLL, EVENT_VSCROLL
+    int scroll_shift;
+
+    // face properties
+    char *family;
+    unsigned bold;
+    unsigned italic;
+    int treat_family_as_pattern;
+
+} render_context_t;
+
+typedef struct {
+    hashmap_t *font_cache;
+    hashmap_t *glyph_cache;
+    hashmap_t *bitmap_cache;
+    hashmap_t *composite_cache;
+    size_t glyph_max;
+    size_t bitmap_max_size;
+} cache_store_t;
+
+struct ass_renderer {
+    ass_library_t *library;
+    FT_Library ftlibrary;
+    fc_instance_t *fontconfig_priv;
+    ass_settings_t settings;
+    int render_id;
+    ass_synth_priv_t *synth_priv;
+
+    ass_image_t *images_root;   // rendering result is stored here
+    ass_image_t *prev_images_root;
+
+    event_images_t *eimg;       // temporary buffer for sorting rendered events
+    int eimg_size;              // allocated buffer size
+
+    // frame-global data
+    int width, height;          // screen dimensions
+    int orig_height;            // frame height ( = screen height - margins )
+    int orig_width;             // frame width ( = screen width - margins )
+    int orig_height_nocrop;     // frame height ( = screen height - margins + cropheight)
+    int orig_width_nocrop;      // frame width ( = screen width - margins + cropwidth)
+    ass_track_t *track;
+    long long time;             // frame's timestamp, ms
+    double font_scale;
+    double font_scale_x;        // x scale applied to all glyphs to preserve text aspect ratio
+    double border_scale;
+
+    render_context_t state;
+    text_info_t text_info;
+    cache_store_t cache;
+
+    free_list_t *free_head;
+    free_list_t *free_tail;
+};
+
+struct render_priv {
+    int top, height;
+    int render_id;
+};
+
+static void ass_lazy_track_init(ass_renderer_t *render_priv)
+{
+    ass_track_t *track = render_priv->track;
+
+    if (track->PlayResX && track->PlayResY)
+        return;
+    if (!track->PlayResX && !track->PlayResY) {
+        ass_msg(render_priv->library, MSGL_WARN,
+               "Neither PlayResX nor PlayResY defined. Assuming 384x288");
+        track->PlayResX = 384;
+        track->PlayResY = 288;
+    } else {
+        if (!track->PlayResY && track->PlayResX == 1280) {
+            track->PlayResY = 1024;
+            ass_msg(render_priv->library, MSGL_WARN,
+                   "PlayResY undefined, setting to %d", track->PlayResY);
+        } else if (!track->PlayResY) {
+            track->PlayResY = track->PlayResX * 3 / 4;
+            ass_msg(render_priv->library, MSGL_WARN,
+                   "PlayResY undefined, setting to %d", track->PlayResY);
+        } else if (!track->PlayResX && track->PlayResY == 1024) {
+            track->PlayResX = 1280;
+            ass_msg(render_priv->library, MSGL_WARN,
+                   "PlayResX undefined, setting to %d", track->PlayResX);
+        } else if (!track->PlayResX) {
+            track->PlayResX = track->PlayResY * 4 / 3;
+            ass_msg(render_priv->library, MSGL_WARN,
+                   "PlayResX undefined, setting to %d", track->PlayResX);
+        }
+    }
+}
+
+ass_renderer_t *ass_renderer_init(ass_library_t *library)
+{
+    int error;
+    FT_Library ft;
+    ass_renderer_t *priv = 0;
+    int vmajor, vminor, vpatch;
+
+    error = FT_Init_FreeType(&ft);
+    if (error) {
+        ass_msg(library, MSGL_FATAL, "%s failed", "FT_Init_FreeType");
+        goto ass_init_exit;
+    }
+
+    FT_Library_Version(ft, &vmajor, &vminor, &vpatch);
+    ass_msg(library, MSGL_V, "FreeType library version: %d.%d.%d",
+           vmajor, vminor, vpatch);
+    ass_msg(library, MSGL_V, "FreeType headers version: %d.%d.%d",
+           FREETYPE_MAJOR, FREETYPE_MINOR, FREETYPE_PATCH);
+
+    priv = calloc(1, sizeof(ass_renderer_t));
+    if (!priv) {
+        FT_Done_FreeType(ft);
+        goto ass_init_exit;
+    }
+
+    priv->synth_priv = ass_synth_init(BLUR_MAX_RADIUS);
+
+    priv->library = library;
+    priv->ftlibrary = ft;
+    // images_root and related stuff is zero-filled in calloc
+
+    priv->cache.font_cache = ass_font_cache_init(library);
+    priv->cache.bitmap_cache = ass_bitmap_cache_init(library);
+    priv->cache.composite_cache = ass_composite_cache_init(library);
+    priv->cache.glyph_cache = ass_glyph_cache_init(library);
+    priv->cache.glyph_max = GLYPH_CACHE_MAX;
+    priv->cache.bitmap_max_size = BITMAP_CACHE_MAX_SIZE;
+
+    priv->text_info.max_glyphs = MAX_GLYPHS_INITIAL;
+    priv->text_info.max_lines = MAX_LINES_INITIAL;
+    priv->text_info.glyphs =
+        calloc(MAX_GLYPHS_INITIAL, sizeof(glyph_info_t));
+    priv->text_info.lines = calloc(MAX_LINES_INITIAL, sizeof(line_info_t));
+
+  ass_init_exit:
+    if (priv)
+        ass_msg(library, MSGL_INFO, "Init");
+    else
+        ass_msg(library, MSGL_ERR, "Init failed");
+
+    return priv;
+}
+
+void ass_set_cache_limits(ass_renderer_t *render_priv, int glyph_max,
+                          int bitmap_max)
+{
+    render_priv->cache.glyph_max = glyph_max ? glyph_max : GLYPH_CACHE_MAX;
+    render_priv->cache.bitmap_max_size = bitmap_max ? 1048576 * bitmap_max :
+                                         BITMAP_CACHE_MAX_SIZE;
+}
+
+static void free_list_clear(ass_renderer_t *render_priv)
+{
+    if (render_priv->free_head) {
+        free_list_t *item = render_priv->free_head;
+        while(item) {
+            free_list_t *oi = item;
+            free(item->object);
+            item = item->next;
+            free(oi);
+        }
+        render_priv->free_head = NULL;
+    }
+}
+
+static void ass_free_images(ass_image_t *img);
+
+void ass_renderer_done(ass_renderer_t *render_priv)
+{
+    ass_font_cache_done(render_priv->cache.font_cache);
+    ass_bitmap_cache_done(render_priv->cache.bitmap_cache);
+    ass_composite_cache_done(render_priv->cache.composite_cache);
+    ass_glyph_cache_done(render_priv->cache.glyph_cache);
+
+    ass_free_images(render_priv->images_root);
+    ass_free_images(render_priv->prev_images_root);
+
+    if (render_priv->state.stroker) {
+        FT_Stroker_Done(render_priv->state.stroker);
+        render_priv->state.stroker = 0;
+    }
+    if (render_priv && render_priv->ftlibrary)
+        FT_Done_FreeType(render_priv->ftlibrary);
+    if (render_priv && render_priv->fontconfig_priv)
+        fontconfig_done(render_priv->fontconfig_priv);
+    if (render_priv && render_priv->synth_priv)
+        ass_synth_done(render_priv->synth_priv);
+    if (render_priv && render_priv->eimg)
+        free(render_priv->eimg);
+    free(render_priv->text_info.glyphs);
+    free(render_priv->text_info.lines);
+
+    free(render_priv->settings.default_font);
+    free(render_priv->settings.default_family);
+
+    free_list_clear(render_priv);
+    free(render_priv);
+}
+
+/**
+ * \brief Create a new ass_image_t
+ * Parameters are the same as ass_image_t fields.
+ */
+static ass_image_t *my_draw_bitmap(unsigned char *bitmap, int bitmap_w,
+                                   int bitmap_h, int stride, int dst_x,
+                                   int dst_y, uint32_t color)
+{
+    ass_image_t *img = calloc(1, sizeof(ass_image_t));
+
+    img->w = bitmap_w;
+    img->h = bitmap_h;
+    img->stride = stride;
+    img->bitmap = bitmap;
+    img->color = color;
+    img->dst_x = dst_x;
+    img->dst_y = dst_y;
+
+    return img;
+}
+
+static double x2scr_pos(ass_renderer_t *render_priv, double x);
+static double y2scr_pos(ass_renderer_t *render_priv, double y);
+
+typedef struct {
+    int x0;
+    int y0;
+    int x1;
+    int y1;
+} rect_t;
+
+/*
+ * \brief Convert bitmap glyphs into ass_image_t list with inverse clipping
+ *
+ * Inverse clipping with the following strategy:
+ * - find rectangle from (x0, y0) to (cx0, y1)
+ * - find rectangle from (cx0, y0) to (cx1, cy0)
+ * - find rectangle from (cx0, cy1) to (cx1, y1)
+ * - find rectangle from (cx1, y0) to (x1, y1)
+ * These rectangles can be invalid and in this case are discarded.
+ * Afterwards, they are clipped against the screen coordinates.
+ * In an additional pass, the rectangles need to be split up left/right for
+ * karaoke effects.  This can result in a lot of bitmaps (6 to be exact).
+ */
+static ass_image_t **render_glyph_i(ass_renderer_t *render_priv,
+                                    bitmap_t *bm, int dst_x, int dst_y,
+                                    uint32_t color, uint32_t color2, int brk,
+                                    ass_image_t **tail)
+{
+    int i, j, x0, y0, x1, y1, cx0, cy0, cx1, cy1, sx, sy, zx, zy;
+    rect_t r[4];
+    ass_image_t *img;
+
+    dst_x += bm->left;
+    dst_y += bm->top;
+
+    // we still need to clip against screen boundaries
+    zx = x2scr_pos(render_priv, 0);
+    zy = y2scr_pos(render_priv, 0);
+    sx = x2scr_pos(render_priv, render_priv->track->PlayResX);
+    sy = y2scr_pos(render_priv, render_priv->track->PlayResY);
+
+    x0 = 0;
+    y0 = 0;
+    x1 = bm->w;
+    y1 = bm->h;
+    cx0 = render_priv->state.clip_x0 - dst_x;
+    cy0 = render_priv->state.clip_y0 - dst_y;
+    cx1 = render_priv->state.clip_x1 - dst_x;
+    cy1 = render_priv->state.clip_y1 - dst_y;
+
+    // calculate rectangles and discard invalid ones while we're at it.
+    i = 0;
+    r[i].x0 = x0;
+    r[i].y0 = y0;
+    r[i].x1 = (cx0 > x1) ? x1 : cx0;
+    r[i].y1 = y1;
+    if (r[i].x1 > r[i].x0 && r[i].y1 > r[i].y0) i++;
+    r[i].x0 = (cx0 < 0) ? x0 : cx0;
+    r[i].y0 = y0;
+    r[i].x1 = (cx1 > x1) ? x1 : cx1;
+    r[i].y1 = (cy0 > y1) ? y1 : cy0;
+    if (r[i].x1 > r[i].x0 && r[i].y1 > r[i].y0) i++;
+    r[i].x0 = (cx0 < 0) ? x0 : cx0;
+    r[i].y0 = (cy1 < 0) ? y0 : cy1;
+    r[i].x1 = (cx1 > x1) ? x1 : cx1;
+    r[i].y1 = y1;
+    if (r[i].x1 > r[i].x0 && r[i].y1 > r[i].y0) i++;
+    r[i].x0 = (cx1 < 0) ? x0 : cx1;
+    r[i].y0 = y0;
+    r[i].x1 = x1;
+    r[i].y1 = y1;
+    if (r[i].x1 > r[i].x0 && r[i].y1 > r[i].y0) i++;
+
+    // clip each rectangle to screen coordinates
+    for (j = 0; j < i; j++) {
+        r[j].x0 = (r[j].x0 + dst_x < zx) ? zx - dst_x : r[j].x0;
+        r[j].y0 = (r[j].y0 + dst_y < zy) ? zy - dst_y : r[j].y0;
+        r[j].x1 = (r[j].x1 + dst_x > sx) ? sx - dst_x : r[j].x1;
+        r[j].y1 = (r[j].y1 + dst_y > sy) ? sy - dst_y : r[j].y1;
+    }
+
+    // draw the rectangles
+    for (j = 0; j < i; j++) {
+        int lbrk = brk;
+        // kick out rectangles that are invalid now
+        if (r[j].x1 <= r[j].x0 || r[j].y1 <= r[j].y0)
+            continue;
+        // split up into left and right for karaoke, if needed
+        if (lbrk > r[j].x0) {
+            if (lbrk > r[j].x1) lbrk = r[j].x1;
+            img = my_draw_bitmap(bm->buffer + r[j].y0 * bm->w + r[j].x0,
+                lbrk - r[j].x0, r[j].y1 - r[j].y0,
+                bm->w, dst_x + r[j].x0, dst_y + r[j].y0, color);
+            *tail = img;
+            tail = &img->next;
+        }
+        if (lbrk < r[j].x1) {
+            if (lbrk < r[j].x0) lbrk = r[j].x0;
+            img = my_draw_bitmap(bm->buffer + r[j].y0 * bm->w + lbrk,
+                r[j].x1 - lbrk, r[j].y1 - r[j].y0,
+                bm->w, dst_x + lbrk, dst_y + r[j].y0, color2);
+            *tail = img;
+            tail = &img->next;
+        }
+    }
+
+    return tail;
+}
+
+/**
+ * \brief convert bitmap glyph into ass_image_t struct(s)
+ * \param bit freetype bitmap glyph, FT_PIXEL_MODE_GRAY
+ * \param dst_x bitmap x coordinate in video frame
+ * \param dst_y bitmap y coordinate in video frame
+ * \param color first color, RGBA
+ * \param color2 second color, RGBA
+ * \param brk x coordinate relative to glyph origin, color is used to the left of brk, color2 - to the right
+ * \param tail pointer to the last image's next field, head of the generated list should be stored here
+ * \return pointer to the new list tail
+ * Performs clipping. Uses my_draw_bitmap for actual bitmap convertion.
+ */
+static ass_image_t **render_glyph(ass_renderer_t *render_priv,
+                                  bitmap_t *bm, int dst_x, int dst_y,
+                                  uint32_t color, uint32_t color2, int brk,
+                                  ass_image_t **tail)
+{
+    // Inverse clipping in use?
+    if (render_priv->state.clip_mode)
+        return render_glyph_i(render_priv, bm, dst_x, dst_y, color, color2,
+                              brk, tail);
+
+    // brk is relative to dst_x
+    // color = color left of brk
+    // color2 = color right of brk
+    int b_x0, b_y0, b_x1, b_y1; // visible part of the bitmap
+    int clip_x0, clip_y0, clip_x1, clip_y1;
+    int tmp;
+    ass_image_t *img;
+
+    dst_x += bm->left;
+    dst_y += bm->top;
+    brk -= bm->left;
+
+    // clipping
+    clip_x0 = FFMINMAX(render_priv->state.clip_x0, 0, render_priv->width);
+    clip_y0 = FFMINMAX(render_priv->state.clip_y0, 0, render_priv->height);
+    clip_x1 = FFMINMAX(render_priv->state.clip_x1, 0, render_priv->width);
+    clip_y1 = FFMINMAX(render_priv->state.clip_y1, 0, render_priv->height);
+    b_x0 = 0;
+    b_y0 = 0;
+    b_x1 = bm->w;
+    b_y1 = bm->h;
+
+    tmp = dst_x - clip_x0;
+    if (tmp < 0) {
+        ass_msg(render_priv->library, MSGL_DBG2, "clip left");
+        b_x0 = -tmp;
+    }
+    tmp = dst_y - clip_y0;
+    if (tmp < 0) {
+        ass_msg(render_priv->library, MSGL_DBG2, "clip top");
+        b_y0 = -tmp;
+    }
+    tmp = clip_x1 - dst_x - bm->w;
+    if (tmp < 0) {
+        ass_msg(render_priv->library, MSGL_DBG2, "clip right");
+        b_x1 = bm->w + tmp;
+    }
+    tmp = clip_y1 - dst_y - bm->h;
+    if (tmp < 0) {
+        ass_msg(render_priv->library, MSGL_DBG2, "clip bottom");
+        b_y1 = bm->h + tmp;
+    }
+
+    if ((b_y0 >= b_y1) || (b_x0 >= b_x1))
+        return tail;
+
+    if (brk > b_x0) {           // draw left part
+        if (brk > b_x1)
+            brk = b_x1;
+        img = my_draw_bitmap(bm->buffer + bm->w * b_y0 + b_x0,
+                             brk - b_x0, b_y1 - b_y0, bm->w,
+                             dst_x + b_x0, dst_y + b_y0, color);
+        *tail = img;
+        tail = &img->next;
+    }
+    if (brk < b_x1) {           // draw right part
+        if (brk < b_x0)
+            brk = b_x0;
+        img = my_draw_bitmap(bm->buffer + bm->w * b_y0 + brk,
+                             b_x1 - brk, b_y1 - b_y0, bm->w,
+                             dst_x + brk, dst_y + b_y0, color2);
+        *tail = img;
+        tail = &img->next;
+    }
+    return tail;
+}
+
+/**
+ * \brief Replace the bitmap buffer in ass_image_t with a copy
+ * \param img ass_image_t to operate on
+ * \return pointer to old bitmap buffer
+ */
+static unsigned char *clone_bitmap_buffer(ass_image_t *img)
+{
+    unsigned char *old_bitmap = img->bitmap;
+    int size = img->stride * (img->h - 1) + img->w;
+    img->bitmap = malloc(size);
+    memcpy(img->bitmap, old_bitmap, size);
+    return old_bitmap;
+}
+
+/**
+ * \brief Calculate overlapping area of two consecutive bitmaps and in case they
+ * overlap, composite them together
+ * Mainly useful for translucent glyphs and especially borders, to avoid the
+ * luminance adding up where they overlap (which looks ugly)
+ */
+static void
+render_overlap(ass_renderer_t *render_priv, ass_image_t **last_tail,
+               ass_image_t **tail, bitmap_hash_key_t *last_hash,
+               bitmap_hash_key_t *hash)
+{
+    int left, top, bottom, right;
+    int old_left, old_top, w, h, cur_left, cur_top;
+    int x, y, opos, cpos;
+    char m;
+    composite_hash_key_t hk;
+    composite_hash_val_t *hv;
+    composite_hash_val_t chv;
+    int ax = (*last_tail)->dst_x;
+    int ay = (*last_tail)->dst_y;
+    int aw = (*last_tail)->w;
+    int as = (*last_tail)->stride;
+    int ah = (*last_tail)->h;
+    int bx = (*tail)->dst_x;
+    int by = (*tail)->dst_y;
+    int bw = (*tail)->w;
+    int bs = (*tail)->stride;
+    int bh = (*tail)->h;
+    unsigned char *a;
+    unsigned char *b;
+
+    if ((*last_tail)->bitmap == (*tail)->bitmap)
+        return;
+
+    if ((*last_tail)->color != (*tail)->color)
+        return;
+
+    // Calculate overlap coordinates
+    left = (ax > bx) ? ax : bx;
+    top = (ay > by) ? ay : by;
+    right = ((ax + aw) < (bx + bw)) ? (ax + aw) : (bx + bw);
+    bottom = ((ay + ah) < (by + bh)) ? (ay + ah) : (by + bh);
+    if ((right <= left) || (bottom <= top))
+        return;
+    old_left = left - ax;
+    old_top = top - ay;
+    w = right - left;
+    h = bottom - top;
+    cur_left = left - bx;
+    cur_top = top - by;
+
+    // Query cache
+    memset(&hk, 0, sizeof(hk));
+    memcpy(&hk.a, last_hash, sizeof(*last_hash));
+    memcpy(&hk.b, hash, sizeof(*hash));
+    hk.aw = aw;
+    hk.ah = ah;
+    hk.bw = bw;
+    hk.bh = bh;
+    hk.ax = ax;
+    hk.ay = ay;
+    hk.bx = bx;
+    hk.by = by;
+    hv = cache_find_composite(render_priv->cache.composite_cache, &hk);
+    if (hv) {
+        (*last_tail)->bitmap = hv->a;
+        (*tail)->bitmap = hv->b;
+        return;
+    }
+    // Allocate new bitmaps and copy over data
+    a = clone_bitmap_buffer(*last_tail);
+    b = clone_bitmap_buffer(*tail);
+
+    // Composite overlapping area
+    for (y = 0; y < h; y++)
+        for (x = 0; x < w; x++) {
+            opos = (old_top + y) * (as) + (old_left + x);
+            cpos = (cur_top + y) * (bs) + (cur_left + x);
+            m = (a[opos] > b[cpos]) ? a[opos] : b[cpos];
+            (*last_tail)->bitmap[opos] = 0;
+            (*tail)->bitmap[cpos] = m;
+        }
+
+    // Insert bitmaps into the cache
+    chv.a = (*last_tail)->bitmap;
+    chv.b = (*tail)->bitmap;
+    cache_add_composite(render_priv->cache.composite_cache, &hk, &chv);
+}
+
+static void free_list_add(ass_renderer_t *render_priv, void *object)
+{
+    if (!render_priv->free_head) {
+        render_priv->free_head = calloc(1, sizeof(free_list_t));
+        render_priv->free_head->object = object;
+        render_priv->free_tail = render_priv->free_head;
+    } else {
+        free_list_t *l = calloc(1, sizeof(free_list_t));
+        l->object = object;
+        render_priv->free_tail->next = l;
+        render_priv->free_tail = render_priv->free_tail->next;
+    }
+}
+
+/**
+ * Iterate through a list of bitmaps and blend with clip vector, if
+ * applicable. The blended bitmaps are added to a free list which is freed
+ * at the start of a new frame.
+ */
+static void blend_vector_clip(ass_renderer_t *render_priv,
+                              ass_image_t *head)
+{
+    FT_Glyph glyph;
+    FT_BitmapGlyph clip_bm;
+    ass_image_t *cur;
+    ass_drawing_t *drawing = render_priv->state.clip_drawing;
+    int error;
+
+    if (!drawing)
+        return;
+
+    // Rasterize it
+    FT_Glyph_Copy((FT_Glyph) drawing->glyph, &glyph);
+    error = FT_Glyph_To_Bitmap(&glyph, FT_RENDER_MODE_NORMAL, 0, 1);
+    if (error) {
+        ass_msg(render_priv->library, MSGL_V,
+            "Clip vector rasterization failed: %d. Skipping.", error);
+        goto blend_vector_exit;
+    }
+    clip_bm = (FT_BitmapGlyph) glyph;
+    clip_bm->top = -clip_bm->top;
+
+    assert(clip_bm->bitmap.pitch >= 0);
+
+    // Iterate through bitmaps and blend/clip them
+    for (cur = head; cur; cur = cur->next) {
+        int left, top, right, bottom, apos, bpos, y, x, w, h;
+        int ax, ay, aw, ah, as;
+        int bx, by, bw, bh, bs;
+        int aleft, atop, bleft, btop;
+        unsigned char *abuffer, *bbuffer, *nbuffer;
+
+        abuffer = cur->bitmap;
+        bbuffer = clip_bm->bitmap.buffer;
+        ax = cur->dst_x;
+        ay = cur->dst_y;
+        aw = cur->w;
+        ah = cur->h;
+        as = cur->stride;
+        bx = clip_bm->left;
+        by = clip_bm->top;
+        bw = clip_bm->bitmap.width;
+        bh = clip_bm->bitmap.rows;
+        bs = clip_bm->bitmap.pitch;
+
+        // Calculate overlap coordinates
+        left = (ax > bx) ? ax : bx;
+        top = (ay > by) ? ay : by;
+        right = ((ax + aw) < (bx + bw)) ? (ax + aw) : (bx + bw);
+        bottom = ((ay + ah) < (by + bh)) ? (ay + ah) : (by + bh);
+        aleft = left - ax;
+        atop = top - ay;
+        w = right - left;
+        h = bottom - top;
+        bleft = left - bx;
+        btop = top - by;
+
+        if (render_priv->state.clip_drawing_mode) {
+            // Inverse clip
+            if (ax + aw < bx || ay + ah < by || ax > bx + bw ||
+                ay > by + bh) {
+                continue;
+            }
+
+            // Allocate new buffer and add to free list
+            nbuffer = malloc(as * ah);
+            free_list_add(render_priv, nbuffer);
+
+            // Blend together
+            memcpy(nbuffer, abuffer, as * ah);
+            for (y = 0; y < h; y++)
+                for (x = 0; x < w; x++) {
+                    apos = (atop + y) * as + aleft + x;
+                    bpos = (btop + y) * bs + bleft + x;
+                    nbuffer[apos] = FFMAX(0, abuffer[apos] - bbuffer[bpos]);
+                }
+        } else {
+            // Regular clip
+            if (ax + aw < bx || ay + ah < by || ax > bx + bw ||
+                ay > by + bh) {
+                cur->w = cur->h = 0;
+                continue;
+            }
+
+            // Allocate new buffer and add to free list
+            nbuffer = calloc(as, ah);
+            free_list_add(render_priv, nbuffer);
+
+            // Blend together
+            for (y = 0; y < h; y++)
+                for (x = 0; x < w; x++) {
+                    apos = (atop + y) * as + aleft + x;
+                    bpos = (btop + y) * bs + bleft + x;
+                    nbuffer[apos] = (abuffer[apos] * bbuffer[bpos] + 255) >> 8;
+                }
+        }
+        cur->bitmap = nbuffer;
+    }
+
+    // Free clip vector and its bitmap, we don't need it anymore
+    FT_Done_Glyph(glyph);
+blend_vector_exit:
+    ass_drawing_free(render_priv->state.clip_drawing);
+    render_priv->state.clip_drawing = 0;
+}
+
+/**
+ * \brief Convert text_info_t struct to ass_image_t list
+ * Splits glyphs in halves when needed (for \kf karaoke).
+ */
+static ass_image_t *render_text(ass_renderer_t *render_priv, int dst_x,
+                                int dst_y)
+{
+    int pen_x, pen_y;
+    int i;
+    bitmap_t *bm;
+    ass_image_t *head;
+    ass_image_t **tail = &head;
+    ass_image_t **last_tail = 0;
+    ass_image_t **here_tail = 0;
+    bitmap_hash_key_t *last_hash = 0;
+    text_info_t *text_info = &render_priv->text_info;
+
+    for (i = 0; i < text_info->length; ++i) {
+        glyph_info_t *info = text_info->glyphs + i;
+        if ((info->symbol == 0) || (info->symbol == '\n') || !info->bm_s
+            || (info->shadow_x == 0 && info->shadow_y == 0))
+            continue;
+
+        pen_x =
+            dst_x + (info->pos.x >> 6) +
+            (int) (info->shadow_x * render_priv->border_scale);
+        pen_y =
+            dst_y + (info->pos.y >> 6) +
+            (int) (info->shadow_y * render_priv->border_scale);
+        bm = info->bm_s;
+
+        here_tail = tail;
+        tail =
+            render_glyph(render_priv, bm, pen_x, pen_y, info->c[3], 0,
+                         1000000, tail);
+        if (last_tail && tail != here_tail && ((info->c[3] & 0xff) > 0))
+            render_overlap(render_priv, last_tail, here_tail, last_hash,
+                           &info->hash_key);
+        last_tail = here_tail;
+        last_hash = &info->hash_key;
+    }
+
+    last_tail = 0;
+    for (i = 0; i < text_info->length; ++i) {
+        glyph_info_t *info = text_info->glyphs + i;
+        if ((info->symbol == 0) || (info->symbol == '\n') || !info->bm_o)
+            continue;
+
+        pen_x = dst_x + (info->pos.x >> 6);
+        pen_y = dst_y + (info->pos.y >> 6);
+        bm = info->bm_o;
+
+        if ((info->effect_type == EF_KARAOKE_KO)
+            && (info->effect_timing <= (info->bbox.xMax >> 6))) {
+            // do nothing
+        } else {
+            here_tail = tail;
+            tail =
+                render_glyph(render_priv, bm, pen_x, pen_y, info->c[2],
+                             0, 1000000, tail);
+            if (last_tail && tail != here_tail && ((info->c[2] & 0xff) > 0))
+                render_overlap(render_priv, last_tail, here_tail,
+                               last_hash, &info->hash_key);
+            last_tail = here_tail;
+            last_hash = &info->hash_key;
+        }
+    }
+    for (i = 0; i < text_info->length; ++i) {
+        glyph_info_t *info = text_info->glyphs + i;
+        if ((info->symbol == 0) || (info->symbol == '\n') || !info->bm)
+            continue;
+
+        pen_x = dst_x + (info->pos.x >> 6);
+        pen_y = dst_y + (info->pos.y >> 6);
+        bm = info->bm;
+
+        if ((info->effect_type == EF_KARAOKE)
+            || (info->effect_type == EF_KARAOKE_KO)) {
+            if (info->effect_timing > (info->bbox.xMax >> 6))
+                tail =
+                    render_glyph(render_priv, bm, pen_x, pen_y,
+                                 info->c[0], 0, 1000000, tail);
+            else
+                tail =
+                    render_glyph(render_priv, bm, pen_x, pen_y,
+                                 info->c[1], 0, 1000000, tail);
+        } else if (info->effect_type == EF_KARAOKE_KF) {
+            tail =
+                render_glyph(render_priv, bm, pen_x, pen_y, info->c[0],
+                             info->c[1], info->effect_timing, tail);
+        } else
+            tail =
+                render_glyph(render_priv, bm, pen_x, pen_y, info->c[0],
+                             0, 1000000, tail);
+    }
+
+    *tail = 0;
+    blend_vector_clip(render_priv, head);
+
+    return head;
+}
+
+/**
+ * \brief Mapping between script and screen coordinates
+ */
+static double x2scr(ass_renderer_t *render_priv, double x)
+{
+    return x * render_priv->orig_width_nocrop /
+        render_priv->track->PlayResX +
+        FFMAX(render_priv->settings.left_margin, 0);
+}
+static double x2scr_pos(ass_renderer_t *render_priv, double x)
+{
+    return x * render_priv->orig_width / render_priv->track->PlayResX +
+        render_priv->settings.left_margin;
+}
+
+/**
+ * \brief Mapping between script and screen coordinates
+ */
+static double y2scr(ass_renderer_t *render_priv, double y)
+{
+    return y * render_priv->orig_height_nocrop /
+        render_priv->track->PlayResY +
+        FFMAX(render_priv->settings.top_margin, 0);
+}
+static double y2scr_pos(ass_renderer_t *render_priv, double y)
+{
+    return y * render_priv->orig_height / render_priv->track->PlayResY +
+        render_priv->settings.top_margin;
+}
+
+// the same for toptitles
+static double y2scr_top(ass_renderer_t *render_priv, double y)
+{
+    if (render_priv->settings.use_margins)
+        return y * render_priv->orig_height_nocrop /
+            render_priv->track->PlayResY;
+    else
+        return y * render_priv->orig_height_nocrop /
+            render_priv->track->PlayResY +
+            FFMAX(render_priv->settings.top_margin, 0);
+}
+
+// the same for subtitles
+static double y2scr_sub(ass_renderer_t *render_priv, double y)
+{
+    if (render_priv->settings.use_margins)
+        return y * render_priv->orig_height_nocrop /
+            render_priv->track->PlayResY +
+            FFMAX(render_priv->settings.top_margin,
+                  0) + FFMAX(render_priv->settings.bottom_margin, 0);
+    else
+        return y * render_priv->orig_height_nocrop /
+            render_priv->track->PlayResY +
+            FFMAX(render_priv->settings.top_margin, 0);
+}
+
+static void compute_string_bbox(text_info_t *info, double_bbox_t *bbox)
+{
+    int i;
+
+    if (info->length > 0) {
+        bbox->xMin = 32000;
+        bbox->xMax = -32000;
+        bbox->yMin = -1 * info->lines[0].asc + d6_to_double(info->glyphs[0].pos.y);
+        bbox->yMax = info->height - info->lines[0].asc +
+                     d6_to_double(info->glyphs[0].pos.y);
+
+        for (i = 0; i < info->length; ++i) {
+            double s = d6_to_double(info->glyphs[i].pos.x);
+            double e = s + d6_to_double(info->glyphs[i].advance.x);
+            bbox->xMin = FFMIN(bbox->xMin, s);
+            bbox->xMax = FFMAX(bbox->xMax, e);
+        }
+    } else
+        bbox->xMin = bbox->xMax = bbox->yMin = bbox->yMax = 0.;
+}
+
+
+/**
+ * \brief Check if starting part of (*p) matches sample. If true, shift p to the first symbol after the matching part.
+ */
+static inline int mystrcmp(char **p, const char *sample)
+{
+    int len = strlen(sample);
+    if (strncmp(*p, sample, len) == 0) {
+        (*p) += len;
+        return 1;
+    } else
+        return 0;
+}
+
+static void change_font_size(ass_renderer_t *render_priv, double sz)
+{
+    double size = sz * render_priv->font_scale;
+
+    if (size < 1)
+        size = 1;
+    else if (size > render_priv->height * 2)
+        size = render_priv->height * 2;
+
+    ass_font_set_size(render_priv->state.font, size);
+
+    render_priv->state.font_size = sz;
+}
+
+/**
+ * \brief Change current font, using setting from render_priv->state.
+ */
+static void update_font(ass_renderer_t *render_priv)
+{
+    unsigned val;
+    ass_font_desc_t desc;
+    desc.family = strdup(render_priv->state.family);
+    desc.treat_family_as_pattern =
+        render_priv->state.treat_family_as_pattern;
+
+    val = render_priv->state.bold;
+    // 0 = normal, 1 = bold, >1 = exact weight
+    if (val == 1 || val == -1)
+        val = 200;              // bold
+    else if (val <= 0)
+        val = 80;               // normal
+    desc.bold = val;
+
+    val = render_priv->state.italic;
+    if (val == 1 || val == -1)
+        val = 110;              // italic
+    else if (val <= 0)
+        val = 0;                // normal
+    desc.italic = val;
+
+    render_priv->state.font =
+        ass_font_new(render_priv->cache.font_cache, render_priv->library,
+                     render_priv->ftlibrary, render_priv->fontconfig_priv,
+                     &desc);
+    free(desc.family);
+
+    if (render_priv->state.font)
+        change_font_size(render_priv, render_priv->state.font_size);
+}
+
+/**
+ * \brief Change border width
+ * negative value resets border to style value
+ */
+static void change_border(ass_renderer_t *render_priv, double border_x,
+                          double border_y)
+{
+    int bord;
+    if (!render_priv->state.font)
+        return;
+
+    if (border_x < 0 && border_y < 0) {
+        if (render_priv->state.style->BorderStyle == 1)
+            border_x = border_y = render_priv->state.style->Outline;
+        else
+            border_x = border_y = 1.;
+    }
+
+    render_priv->state.border_x = border_x;
+    render_priv->state.border_y = border_y;
+
+    bord = 64 * border_x * render_priv->border_scale;
+    if (bord > 0 && border_x == border_y) {
+        if (!render_priv->state.stroker) {
+            int error;
+#if (FREETYPE_MAJOR > 2) || ((FREETYPE_MAJOR == 2) && (FREETYPE_MINOR > 1))
+            error =
+                FT_Stroker_New(render_priv->ftlibrary,
+                               &render_priv->state.stroker);
+#else                           // < 2.2
+            error =
+                FT_Stroker_New(render_priv->state.font->faces[0]->
+                               memory, &render_priv->state.stroker);
+#endif
+            if (error) {
+                ass_msg(render_priv->library, MSGL_V,
+                        "failed to get stroker");
+                render_priv->state.stroker = 0;
+            }
+        }
+        if (render_priv->state.stroker)
+            FT_Stroker_Set(render_priv->state.stroker, bord,
+                           FT_STROKER_LINECAP_ROUND,
+                           FT_STROKER_LINEJOIN_ROUND, 0);
+    } else {
+        FT_Stroker_Done(render_priv->state.stroker);
+        render_priv->state.stroker = 0;
+    }
+}
+
+#define _r(c)  ((c)>>24)
+#define _g(c)  (((c)>>16)&0xFF)
+#define _b(c)  (((c)>>8)&0xFF)
+#define _a(c)  ((c)&0xFF)
+
+/**
+ * \brief Calculate a weighted average of two colors
+ * calculates c1*(1-a) + c2*a, but separately for each component except alpha
+ */
+static void change_color(uint32_t *var, uint32_t new, double pwr)
+{
+    (*var) = ((uint32_t) (_r(*var) * (1 - pwr) + _r(new) * pwr) << 24) +
+        ((uint32_t) (_g(*var) * (1 - pwr) + _g(new) * pwr) << 16) +
+        ((uint32_t) (_b(*var) * (1 - pwr) + _b(new) * pwr) << 8) + _a(*var);
+}
+
+// like change_color, but for alpha component only
+static void change_alpha(uint32_t *var, uint32_t new, double pwr)
+{
+    *var =
+        (_r(*var) << 24) + (_g(*var) << 16) + (_b(*var) << 8) +
+        (_a(*var) * (1 - pwr) + _a(new) * pwr);
+}
+
+/**
+ * \brief Multiply two alpha values
+ * \param a first value
+ * \param b second value
+ * \return result of multiplication
+ * Parameters and result are limited by 0xFF.
+ */
+static uint32_t mult_alpha(uint32_t a, uint32_t b)
+{
+    return 0xFF - (0xFF - a) * (0xFF - b) / 0xFF;
+}
+
+/**
+ * \brief Calculate alpha value by piecewise linear function
+ * Used for \fad, \fade implementation.
+ */
+static unsigned
+interpolate_alpha(long long now,
+                  long long t1, long long t2, long long t3, long long t4,
+                  unsigned a1, unsigned a2, unsigned a3)
+{
+    unsigned a;
+    double cf;
+    if (now <= t1) {
+        a = a1;
+    } else if (now >= t4) {
+        a = a3;
+    } else if (now < t2) {      // and > t1
+        cf = ((double) (now - t1)) / (t2 - t1);
+        a = a1 * (1 - cf) + a2 * cf;
+    } else if (now > t3) {
+        cf = ((double) (now - t3)) / (t4 - t3);
+        a = a2 * (1 - cf) + a3 * cf;
+    } else {                    // t2 <= now <= t3
+        a = a2;
+    }
+
+    return a;
+}
+
+#define skip_to(x) while ((*p != (x)) && (*p != '}') && (*p != 0)) { ++p;}
+#define skip(x) if (*p == (x)) ++p; else { return p; }
+#define skipopt(x) if (*p == (x)) { ++p; }
+
+/**
+ * Parse a vector clip into an outline, using the proper scaling
+ * parameters.  Translate it to correct for screen borders, if needed.
+ */
+static char *parse_vector_clip(ass_renderer_t *render_priv, char *p)
+{
+    int scale = 1;
+    int res = 0;
+    ass_drawing_t *drawing;
+    render_priv->state.clip_drawing = ass_drawing_new(
+        render_priv->fontconfig_priv,
+        render_priv->state.font,
+        render_priv->settings.hinting,
+        render_priv->ftlibrary);
+    drawing = render_priv->state.clip_drawing;
+    skipopt('(');
+    res = mystrtoi(&p, &scale);
+    skipopt(',')
+    if (!res)
+        scale = 1;
+    drawing->scale = scale;
+    drawing->scale_x = render_priv->font_scale_x * render_priv->font_scale;
+    drawing->scale_y = render_priv->font_scale;
+    while (*p != ')' && *p != '}' && p != 0)
+        ass_drawing_add_char(drawing, *p++);
+    skipopt(')');
+    ass_drawing_parse(drawing, 1);
+    // We need to translate the clip according to screen borders
+    if (render_priv->settings.left_margin != 0 ||
+        render_priv->settings.top_margin != 0) {
+        FT_Vector trans = {
+            .x = int_to_d6(render_priv->settings.left_margin),
+            .y = -int_to_d6(render_priv->settings.top_margin),
+        };
+        FT_Outline_Translate(&drawing->glyph->outline, trans.x, trans.y);
+    }
+    ass_msg(render_priv->library, MSGL_DBG2,
+            "Parsed vector clip: scale %d, scales (%f, %f) string [%s]\n",
+            scale, drawing->scale_x, drawing->scale_y, drawing->text);
+
+    return p;
+}
+
+static void reset_render_context(ass_renderer_t *);
+
+/**
+ * \brief Parse style override tag.
+ * \param p string to parse
+ * \param pwr multiplier for some tag effects (comes from \t tags)
+ */
+static char *parse_tag(ass_renderer_t *render_priv, char *p, double pwr)
+{
+    skip_to('\\');
+    skip('\\');
+    if ((*p == '}') || (*p == 0))
+        return p;
+
+    // New tags introduced in vsfilter 2.39
+    if (mystrcmp(&p, "xbord")) {
+        double val;
+        if (mystrtod(&p, &val))
+            val = render_priv->state.border_x * (1 - pwr) + val * pwr;
+        else
+            val = -1.;
+        change_border(render_priv, val, render_priv->state.border_y);
+    } else if (mystrcmp(&p, "ybord")) {
+        double val;
+        if (mystrtod(&p, &val))
+            val = render_priv->state.border_y * (1 - pwr) + val * pwr;
+        else
+            val = -1.;
+        change_border(render_priv, render_priv->state.border_x, val);
+    } else if (mystrcmp(&p, "xshad")) {
+        double val;
+        if (mystrtod(&p, &val))
+            val = render_priv->state.shadow_x * (1 - pwr) + val * pwr;
+        else
+            val = 0.;
+        render_priv->state.shadow_x = val;
+    } else if (mystrcmp(&p, "yshad")) {
+        double val;
+        if (mystrtod(&p, &val))
+            val = render_priv->state.shadow_y * (1 - pwr) + val * pwr;
+        else
+            val = 0.;
+        render_priv->state.shadow_y = val;
+    } else if (mystrcmp(&p, "fax")) {
+        double val;
+        if (mystrtod(&p, &val))
+            render_priv->state.fax =
+                val * pwr + render_priv->state.fax * (1 - pwr);
+        else
+            render_priv->state.fax = 0.;
+    } else if (mystrcmp(&p, "fay")) {
+        double val;
+        if (mystrtod(&p, &val))
+            render_priv->state.fay =
+                val * pwr + render_priv->state.fay * (1 - pwr);
+        else
+            render_priv->state.fay = 0.;
+    } else if (mystrcmp(&p, "iclip")) {
+        int x0, y0, x1, y1;
+        int res = 1;
+        char *start = p;
+        skipopt('(');
+        res &= mystrtoi(&p, &x0);
+        skipopt(',');
+        res &= mystrtoi(&p, &y0);
+        skipopt(',');
+        res &= mystrtoi(&p, &x1);
+        skipopt(',');
+        res &= mystrtoi(&p, &y1);
+        skipopt(')');
+        if (res) {
+            render_priv->state.clip_x0 =
+                render_priv->state.clip_x0 * (1 - pwr) + x0 * pwr;
+            render_priv->state.clip_x1 =
+                render_priv->state.clip_x1 * (1 - pwr) + x1 * pwr;
+            render_priv->state.clip_y0 =
+                render_priv->state.clip_y0 * (1 - pwr) + y0 * pwr;
+            render_priv->state.clip_y1 =
+                render_priv->state.clip_y1 * (1 - pwr) + y1 * pwr;
+            render_priv->state.clip_mode = 1;
+        } else if (!render_priv->state.clip_drawing) {
+            p = parse_vector_clip(render_priv, start);
+            render_priv->state.clip_drawing_mode = 1;
+        } else
+            render_priv->state.clip_mode = 0;
+    } else if (mystrcmp(&p, "blur")) {
+        double val;
+        if (mystrtod(&p, &val)) {
+            val = render_priv->state.blur * (1 - pwr) + val * pwr;
+            val = (val < 0) ? 0 : val;
+            val = (val > BLUR_MAX_RADIUS) ? BLUR_MAX_RADIUS : val;
+            render_priv->state.blur = val;
+        } else
+            render_priv->state.blur = 0.0;
+        // ASS standard tags
+    } else if (mystrcmp(&p, "fsc")) {
+        char tp = *p++;
+        double val;
+        if (tp == 'x') {
+            if (mystrtod(&p, &val)) {
+                val /= 100;
+                render_priv->state.scale_x =
+                    render_priv->state.scale_x * (1 - pwr) + val * pwr;
+            } else
+                render_priv->state.scale_x =
+                    render_priv->state.style->ScaleX;
+        } else if (tp == 'y') {
+            if (mystrtod(&p, &val)) {
+                val /= 100;
+                render_priv->state.scale_y =
+                    render_priv->state.scale_y * (1 - pwr) + val * pwr;
+            } else
+                render_priv->state.scale_y =
+                    render_priv->state.style->ScaleY;
+        }
+    } else if (mystrcmp(&p, "fsp")) {
+        double val;
+        if (mystrtod(&p, &val))
+            render_priv->state.hspacing =
+                render_priv->state.hspacing * (1 - pwr) + val * pwr;
+        else
+            render_priv->state.hspacing = render_priv->state.style->Spacing;
+    } else if (mystrcmp(&p, "fs")) {
+        double val;
+        if (mystrtod(&p, &val))
+            val = render_priv->state.font_size * (1 - pwr) + val * pwr;
+        else
+            val = render_priv->state.style->FontSize;
+        if (render_priv->state.font)
+            change_font_size(render_priv, val);
+    } else if (mystrcmp(&p, "bord")) {
+        double val;
+        if (mystrtod(&p, &val)) {
+            if (render_priv->state.border_x == render_priv->state.border_y)
+                val = render_priv->state.border_x * (1 - pwr) + val * pwr;
+        } else
+            val = -1.;          // reset to default
+        change_border(render_priv, val, val);
+    } else if (mystrcmp(&p, "move")) {
+        double x1, x2, y1, y2;
+        long long t1, t2, delta_t, t;
+        double x, y;
+        double k;
+        skip('(');
+        mystrtod(&p, &x1);
+        skip(',');
+        mystrtod(&p, &y1);
+        skip(',');
+        mystrtod(&p, &x2);
+        skip(',');
+        mystrtod(&p, &y2);
+        if (*p == ',') {
+            skip(',');
+            mystrtoll(&p, &t1);
+            skip(',');
+            mystrtoll(&p, &t2);
+            ass_msg(render_priv->library, MSGL_DBG2,
+                   "movement6: (%f, %f) -> (%f, %f), (%" PRId64 " .. %"
+                   PRId64 ")\n", x1, y1, x2, y2, (int64_t) t1,
+                   (int64_t) t2);
+        } else {
+            t1 = 0;
+            t2 = render_priv->state.event->Duration;
+            ass_msg(render_priv->library, MSGL_DBG2,
+                   "movement: (%f, %f) -> (%f, %f)", x1, y1, x2, y2);
+        }
+        skip(')');
+        delta_t = t2 - t1;
+        t = render_priv->time - render_priv->state.event->Start;
+        if (t < t1)
+            k = 0.;
+        else if (t > t2)
+            k = 1.;
+        else
+            k = ((double) (t - t1)) / delta_t;
+        x = k * (x2 - x1) + x1;
+        y = k * (y2 - y1) + y1;
+        if (render_priv->state.evt_type != EVENT_POSITIONED) {
+            render_priv->state.pos_x = x;
+            render_priv->state.pos_y = y;
+            render_priv->state.detect_collisions = 0;
+            render_priv->state.evt_type = EVENT_POSITIONED;
+        }
+    } else if (mystrcmp(&p, "frx")) {
+        double val;
+        if (mystrtod(&p, &val)) {
+            val *= M_PI / 180;
+            render_priv->state.frx =
+                val * pwr + render_priv->state.frx * (1 - pwr);
+        } else
+            render_priv->state.frx = 0.;
+    } else if (mystrcmp(&p, "fry")) {
+        double val;
+        if (mystrtod(&p, &val)) {
+            val *= M_PI / 180;
+            render_priv->state.fry =
+                val * pwr + render_priv->state.fry * (1 - pwr);
+        } else
+            render_priv->state.fry = 0.;
+    } else if (mystrcmp(&p, "frz") || mystrcmp(&p, "fr")) {
+        double val;
+        if (mystrtod(&p, &val)) {
+            val *= M_PI / 180;
+            render_priv->state.frz =
+                val * pwr + render_priv->state.frz * (1 - pwr);
+        } else
+            render_priv->state.frz =
+                M_PI * render_priv->state.style->Angle / 180.;
+    } else if (mystrcmp(&p, "fn")) {
+        char *start = p;
+        char *family;
+        skip_to('\\');
+        if (p > start) {
+            family = malloc(p - start + 1);
+            strncpy(family, start, p - start);
+            family[p - start] = '\0';
+        } else
+            family = strdup(render_priv->state.style->FontName);
+        if (render_priv->state.family)
+            free(render_priv->state.family);
+        render_priv->state.family = family;
+        update_font(render_priv);
+    } else if (mystrcmp(&p, "alpha")) {
+        uint32_t val;
+        int i;
+        if (strtocolor(render_priv->library, &p, &val)) {
+            unsigned char a = val >> 24;
+            for (i = 0; i < 4; ++i)
+                change_alpha(&render_priv->state.c[i], a, pwr);
+        } else {
+            change_alpha(&render_priv->state.c[0],
+                         render_priv->state.style->PrimaryColour, pwr);
+            change_alpha(&render_priv->state.c[1],
+                         render_priv->state.style->SecondaryColour, pwr);
+            change_alpha(&render_priv->state.c[2],
+                         render_priv->state.style->OutlineColour, pwr);
+            change_alpha(&render_priv->state.c[3],
+                         render_priv->state.style->BackColour, pwr);
+        }
+        // FIXME: simplify
+    } else if (mystrcmp(&p, "an")) {
+        int val;
+        if (mystrtoi(&p, &val) && val) {
+            int v = (val - 1) / 3;      // 0, 1 or 2 for vertical alignment
+            ass_msg(render_priv->library, MSGL_DBG2, "an %d", val);
+            if (v != 0)
+                v = 3 - v;
+            val = ((val - 1) % 3) + 1;  // horizontal alignment
+            val += v * 4;
+            ass_msg(render_priv->library, MSGL_DBG2, "align %d", val);
+            render_priv->state.alignment = val;
+        } else
+            render_priv->state.alignment =
+                render_priv->state.style->Alignment;
+    } else if (mystrcmp(&p, "a")) {
+        int val;
+        if (mystrtoi(&p, &val) && val)
+            render_priv->state.alignment = val;
+        else
+            render_priv->state.alignment =
+                render_priv->state.style->Alignment;
+    } else if (mystrcmp(&p, "pos")) {
+        double v1, v2;
+        skip('(');
+        mystrtod(&p, &v1);
+        skip(',');
+        mystrtod(&p, &v2);
+        skip(')');
+        ass_msg(render_priv->library, MSGL_DBG2, "pos(%f, %f)", v1, v2);
+        if (render_priv->state.evt_type == EVENT_POSITIONED) {
+            ass_msg(render_priv->library, MSGL_V, "Subtitle has a new \\pos "
+                   "after \\move or \\pos, ignoring");
+        } else {
+            render_priv->state.evt_type = EVENT_POSITIONED;
+            render_priv->state.detect_collisions = 0;
+            render_priv->state.pos_x = v1;
+            render_priv->state.pos_y = v2;
+        }
+    } else if (mystrcmp(&p, "fad")) {
+        int a1, a2, a3;
+        long long t1, t2, t3, t4;
+        if (*p == 'e')
+            ++p;                // either \fad or \fade
+        skip('(');
+        mystrtoi(&p, &a1);
+        skip(',');
+        mystrtoi(&p, &a2);
+        if (*p == ')') {
+            // 2-argument version (\fad, according to specs)
+            // a1 and a2 are fade-in and fade-out durations
+            t1 = 0;
+            t4 = render_priv->state.event->Duration;
+            t2 = a1;
+            t3 = t4 - a2;
+            a1 = 0xFF;
+            a2 = 0;
+            a3 = 0xFF;
+        } else {
+            // 6-argument version (\fade)
+            // a1 and a2 (and a3) are opacity values
+            skip(',');
+            mystrtoi(&p, &a3);
+            skip(',');
+            mystrtoll(&p, &t1);
+            skip(',');
+            mystrtoll(&p, &t2);
+            skip(',');
+            mystrtoll(&p, &t3);
+            skip(',');
+            mystrtoll(&p, &t4);
+        }
+        skip(')');
+        render_priv->state.fade =
+            interpolate_alpha(render_priv->time -
+                              render_priv->state.event->Start, t1, t2,
+                              t3, t4, a1, a2, a3);
+    } else if (mystrcmp(&p, "org")) {
+        int v1, v2;
+        skip('(');
+        mystrtoi(&p, &v1);
+        skip(',');
+        mystrtoi(&p, &v2);
+        skip(')');
+        ass_msg(render_priv->library, MSGL_DBG2, "org(%d, %d)", v1, v2);
+        if (!render_priv->state.have_origin) {
+            render_priv->state.org_x = v1;
+            render_priv->state.org_y = v2;
+            render_priv->state.have_origin = 1;
+            render_priv->state.detect_collisions = 0;
+        }
+    } else if (mystrcmp(&p, "t")) {
+        double v[3];
+        int v1, v2;
+        double v3;
+        int cnt;
+        long long t1, t2, t, delta_t;
+        double k;
+        skip('(');
+        for (cnt = 0; cnt < 3; ++cnt) {
+            if (*p == '\\')
+                break;
+            v[cnt] = strtod(p, &p);
+            skip(',');
+        }
+        if (cnt == 3) {
+            v1 = v[0];
+            v2 = (v[1] < v1) ? render_priv->state.event->Duration : v[1];
+            v3 = v[2];
+        } else if (cnt == 2) {
+            v1 = v[0];
+            v2 = (v[1] < v1) ? render_priv->state.event->Duration : v[1];
+            v3 = 1.;
+        } else if (cnt == 1) {
+            v1 = 0;
+            v2 = render_priv->state.event->Duration;
+            v3 = v[0];
+        } else {                // cnt == 0
+            v1 = 0;
+            v2 = render_priv->state.event->Duration;
+            v3 = 1.;
+        }
+        render_priv->state.detect_collisions = 0;
+        t1 = v1;
+        t2 = v2;
+        delta_t = v2 - v1;
+        if (v3 < 0.)
+            v3 = 0.;
+        t = render_priv->time - render_priv->state.event->Start;        // FIXME: move to render_context
+        if (t <= t1)
+            k = 0.;
+        else if (t >= t2)
+            k = 1.;
+        else {
+            assert(delta_t != 0.);
+            k = pow(((double) (t - t1)) / delta_t, v3);
+        }
+        while (*p == '\\')
+            p = parse_tag(render_priv, p, k);   // maybe k*pwr ? no, specs forbid nested \t's
+        skip_to(')');           // in case there is some unknown tag or a comment
+        skip(')');
+    } else if (mystrcmp(&p, "clip")) {
+        char *start = p;
+        int x0, y0, x1, y1;
+        int res = 1;
+        skipopt('(');
+        res &= mystrtoi(&p, &x0);
+        skipopt(',');
+        res &= mystrtoi(&p, &y0);
+        skipopt(',');
+        res &= mystrtoi(&p, &x1);
+        skipopt(',');
+        res &= mystrtoi(&p, &y1);
+        skipopt(')');
+        if (res) {
+            render_priv->state.clip_x0 =
+                render_priv->state.clip_x0 * (1 - pwr) + x0 * pwr;
+            render_priv->state.clip_x1 =
+                render_priv->state.clip_x1 * (1 - pwr) + x1 * pwr;
+            render_priv->state.clip_y0 =
+                render_priv->state.clip_y0 * (1 - pwr) + y0 * pwr;
+            render_priv->state.clip_y1 =
+                render_priv->state.clip_y1 * (1 - pwr) + y1 * pwr;
+        // Might be a vector clip
+        } else if (!render_priv->state.clip_drawing) {
+            p = parse_vector_clip(render_priv, start);
+            render_priv->state.clip_drawing_mode = 0;
+        } else {
+            render_priv->state.clip_x0 = 0;
+            render_priv->state.clip_y0 = 0;
+            render_priv->state.clip_x1 = render_priv->track->PlayResX;
+            render_priv->state.clip_y1 = render_priv->track->PlayResY;
+        }
+    } else if (mystrcmp(&p, "c")) {
+        uint32_t val;
+        if (!strtocolor(render_priv->library, &p, &val))
+            val = render_priv->state.style->PrimaryColour;
+        ass_msg(render_priv->library, MSGL_DBG2, "color: %X", val);
+        change_color(&render_priv->state.c[0], val, pwr);
+    } else if ((*p >= '1') && (*p <= '4') && (++p)
+               && (mystrcmp(&p, "c") || mystrcmp(&p, "a"))) {
+        char n = *(p - 2);
+        int cidx = n - '1';
+        char cmd = *(p - 1);
+        uint32_t val;
+        assert((n >= '1') && (n <= '4'));
+        if (!strtocolor(render_priv->library, &p, &val))
+            switch (n) {
+            case '1':
+                val = render_priv->state.style->PrimaryColour;
+                break;
+            case '2':
+                val = render_priv->state.style->SecondaryColour;
+                break;
+            case '3':
+                val = render_priv->state.style->OutlineColour;
+                break;
+            case '4':
+                val = render_priv->state.style->BackColour;
+                break;
+            default:
+                val = 0;
+                break;          // impossible due to assert; avoid compilation warning
+            }
+        switch (cmd) {
+        case 'c':
+            change_color(render_priv->state.c + cidx, val, pwr);
+            break;
+        case 'a':
+            change_alpha(render_priv->state.c + cidx, val >> 24, pwr);
+            break;
+        default:
+            ass_msg(render_priv->library, MSGL_WARN, "Bad command: %c%c",
+                    n, cmd);
+            break;
+        }
+        ass_msg(render_priv->library, MSGL_DBG2, "single c/a at %f: %c%c = %X",
+               pwr, n, cmd, render_priv->state.c[cidx]);
+    } else if (mystrcmp(&p, "r")) {
+        reset_render_context(render_priv);
+    } else if (mystrcmp(&p, "be")) {
+        int val;
+        if (mystrtoi(&p, &val)) {
+            // Clamp to a safe upper limit, since high values need excessive CPU
+            val = (val < 0) ? 0 : val;
+            val = (val > MAX_BE) ? MAX_BE : val;
+            render_priv->state.be = val;
+        } else
+            render_priv->state.be = 0;
+    } else if (mystrcmp(&p, "b")) {
+        int b;
+        if (mystrtoi(&p, &b)) {
+            if (pwr >= .5)
+                render_priv->state.bold = b;
+        } else
+            render_priv->state.bold = render_priv->state.style->Bold;
+        update_font(render_priv);
+    } else if (mystrcmp(&p, "i")) {
+        int i;
+        if (mystrtoi(&p, &i)) {
+            if (pwr >= .5)
+                render_priv->state.italic = i;
+        } else
+            render_priv->state.italic = render_priv->state.style->Italic;
+        update_font(render_priv);
+    } else if (mystrcmp(&p, "kf") || mystrcmp(&p, "K")) {
+        int val = 0;
+        mystrtoi(&p, &val);
+        render_priv->state.effect_type = EF_KARAOKE_KF;
+        if (render_priv->state.effect_timing)
+            render_priv->state.effect_skip_timing +=
+                render_priv->state.effect_timing;
+        render_priv->state.effect_timing = val * 10;
+    } else if (mystrcmp(&p, "ko")) {
+        int val = 0;
+        mystrtoi(&p, &val);
+        render_priv->state.effect_type = EF_KARAOKE_KO;
+        if (render_priv->state.effect_timing)
+            render_priv->state.effect_skip_timing +=
+                render_priv->state.effect_timing;
+        render_priv->state.effect_timing = val * 10;
+    } else if (mystrcmp(&p, "k")) {
+        int val = 0;
+        mystrtoi(&p, &val);
+        render_priv->state.effect_type = EF_KARAOKE;
+        if (render_priv->state.effect_timing)
+            render_priv->state.effect_skip_timing +=
+                render_priv->state.effect_timing;
+        render_priv->state.effect_timing = val * 10;
+    } else if (mystrcmp(&p, "shad")) {
+        double val;
+        if (mystrtod(&p, &val)) {
+            if (render_priv->state.shadow_x == render_priv->state.shadow_y)
+                val = render_priv->state.shadow_x * (1 - pwr) + val * pwr;
+        } else
+            val = 0.;
+        render_priv->state.shadow_x = render_priv->state.shadow_y = val;
+    } else if (mystrcmp(&p, "s")) {
+        int val;
+        if (mystrtoi(&p, &val) && val)
+            render_priv->state.flags |= DECO_STRIKETHROUGH;
+        else
+            render_priv->state.flags &= ~DECO_STRIKETHROUGH;
+    } else if (mystrcmp(&p, "u")) {
+        int val;
+        if (mystrtoi(&p, &val) && val)
+            render_priv->state.flags |= DECO_UNDERLINE;
+        else
+            render_priv->state.flags &= ~DECO_UNDERLINE;
+    } else if (mystrcmp(&p, "pbo")) {
+        double val = 0;
+        if (mystrtod(&p, &val))
+            render_priv->state.drawing->pbo = val;
+    } else if (mystrcmp(&p, "p")) {
+        int val;
+        if (!mystrtoi(&p, &val))
+            val = 0;
+        if (val)
+            render_priv->state.drawing->scale = val;
+        render_priv->state.drawing_mode = !!val;
+    }
+
+    return p;
+
+#undef skip
+#undef skipopt
+#undef skip_to
+}
+
+/**
+ * \brief Get next ucs4 char from string, parsing and executing style overrides
+ * \param str string pointer
+ * \return ucs4 code of the next char
+ * On return str points to the unparsed part of the string
+ */
+static unsigned get_next_char(ass_renderer_t *render_priv, char **str)
+{
+    char *p = *str;
+    unsigned chr;
+    if (*p == '{') {            // '\0' goes here
+        p++;
+        while (1) {
+            p = parse_tag(render_priv, p, 1.);
+            if (*p == '}') {    // end of tag
+                p++;
+                if (*p == '{') {
+                    p++;
+                    continue;
+                } else
+                    break;
+            } else if (*p != '\\')
+                ass_msg(render_priv->library, MSGL_V,
+                        "Unable to parse: '%s'", p);
+            if (*p == 0)
+                break;
+        }
+    }
+    if (*p == '\t') {
+        ++p;
+        *str = p;
+        return ' ';
+    }
+    if (*p == '\\') {
+        if ((*(p + 1) == 'N')
+            || ((*(p + 1) == 'n')
+                && (render_priv->track->WrapStyle == 2))) {
+            p += 2;
+            *str = p;
+            return '\n';
+        } else if ((*(p + 1) == 'n') || (*(p + 1) == 'h')) {
+            p += 2;
+            *str = p;
+            return ' ';
+        }
+    }
+    chr = ass_utf8_get_char((char **) &p);
+    *str = p;
+    return chr;
+}
+
+static void
+apply_transition_effects(ass_renderer_t *render_priv, ass_event_t *event)
+{
+    int v[4];
+    int cnt;
+    char *p = event->Effect;
+
+    if (!p || !*p)
+        return;
+
+    cnt = 0;
+    while (cnt < 4 && (p = strchr(p, ';'))) {
+        v[cnt++] = atoi(++p);
+    }
+
+    if (strncmp(event->Effect, "Banner;", 7) == 0) {
+        int delay;
+        if (cnt < 1) {
+            ass_msg(render_priv->library, MSGL_V,
+                    "Error parsing effect: '%s'", event->Effect);
+            return;
+        }
+        if (cnt >= 2 && v[1] == 0)      // right-to-left
+            render_priv->state.scroll_direction = SCROLL_RL;
+        else                    // left-to-right
+            render_priv->state.scroll_direction = SCROLL_LR;
+
+        delay = v[0];
+        if (delay == 0)
+            delay = 1;          // ?
+        render_priv->state.scroll_shift =
+            (render_priv->time - render_priv->state.event->Start) / delay;
+        render_priv->state.evt_type = EVENT_HSCROLL;
+        return;
+    }
+
+    if (strncmp(event->Effect, "Scroll up;", 10) == 0) {
+        render_priv->state.scroll_direction = SCROLL_BT;
+    } else if (strncmp(event->Effect, "Scroll down;", 12) == 0) {
+        render_priv->state.scroll_direction = SCROLL_TB;
+    } else {
+        ass_msg(render_priv->library, MSGL_V,
+                "Unknown transition effect: '%s'", event->Effect);
+        return;
+    }
+    // parse scroll up/down parameters
+    {
+        int delay;
+        int y0, y1;
+        if (cnt < 3) {
+            ass_msg(render_priv->library, MSGL_V,
+                    "Error parsing effect: '%s'", event->Effect);
+            return;
+        }
+        delay = v[2];
+        if (delay == 0)
+            delay = 1;          // ?
+        render_priv->state.scroll_shift =
+            (render_priv->time - render_priv->state.event->Start) / delay;
+        if (v[0] < v[1]) {
+            y0 = v[0];
+            y1 = v[1];
+        } else {
+            y0 = v[1];
+            y1 = v[0];
+        }
+        if (y1 == 0)
+            y1 = render_priv->track->PlayResY;  // y0=y1=0 means fullscreen scrolling
+        render_priv->state.clip_y0 = y0;
+        render_priv->state.clip_y1 = y1;
+        render_priv->state.evt_type = EVENT_VSCROLL;
+        render_priv->state.detect_collisions = 0;
+    }
+
+}
+
+/**
+ * \brief partially reset render_context to style values
+ * Works like {\r}: resets some style overrides
+ */
+static void reset_render_context(ass_renderer_t *render_priv)
+{
+    render_priv->state.c[0] = render_priv->state.style->PrimaryColour;
+    render_priv->state.c[1] = render_priv->state.style->SecondaryColour;
+    render_priv->state.c[2] = render_priv->state.style->OutlineColour;
+    render_priv->state.c[3] = render_priv->state.style->BackColour;
+    render_priv->state.flags =
+        (render_priv->state.style->Underline ? DECO_UNDERLINE : 0) |
+        (render_priv->state.style->StrikeOut ? DECO_STRIKETHROUGH : 0);
+    render_priv->state.font_size = render_priv->state.style->FontSize;
+
+    free(render_priv->state.family);
+    render_priv->state.family = NULL;
+    render_priv->state.family = strdup(render_priv->state.style->FontName);
+    render_priv->state.treat_family_as_pattern =
+        render_priv->state.style->treat_fontname_as_pattern;
+    render_priv->state.bold = render_priv->state.style->Bold;
+    render_priv->state.italic = render_priv->state.style->Italic;
+    update_font(render_priv);
+
+    change_border(render_priv, -1., -1.);
+    render_priv->state.scale_x = render_priv->state.style->ScaleX;
+    render_priv->state.scale_y = render_priv->state.style->ScaleY;
+    render_priv->state.hspacing = render_priv->state.style->Spacing;
+    render_priv->state.be = 0;
+    render_priv->state.blur = 0.0;
+    render_priv->state.shadow_x = render_priv->state.style->Shadow;
+    render_priv->state.shadow_y = render_priv->state.style->Shadow;
+    render_priv->state.frx = render_priv->state.fry = 0.;
+    render_priv->state.frz = M_PI * render_priv->state.style->Angle / 180.;
+    render_priv->state.fax = render_priv->state.fay = 0.;
+
+    // FIXME: does not reset unsupported attributes.
+}
+
+/**
+ * \brief Start new event. Reset render_priv->state.
+ */
+static void
+init_render_context(ass_renderer_t *render_priv, ass_event_t *event)
+{
+    render_priv->state.event = event;
+    render_priv->state.style = render_priv->track->styles + event->Style;
+
+    reset_render_context(render_priv);
+
+    render_priv->state.evt_type = EVENT_NORMAL;
+    render_priv->state.alignment = render_priv->state.style->Alignment;
+    render_priv->state.pos_x = 0;
+    render_priv->state.pos_y = 0;
+    render_priv->state.org_x = 0;
+    render_priv->state.org_y = 0;
+    render_priv->state.have_origin = 0;
+    render_priv->state.clip_x0 = 0;
+    render_priv->state.clip_y0 = 0;
+    render_priv->state.clip_x1 = render_priv->track->PlayResX;
+    render_priv->state.clip_y1 = render_priv->track->PlayResY;
+    render_priv->state.detect_collisions = 1;
+    render_priv->state.fade = 0;
+    render_priv->state.drawing_mode = 0;
+    render_priv->state.effect_type = EF_NONE;
+    render_priv->state.effect_timing = 0;
+    render_priv->state.effect_skip_timing = 0;
+    render_priv->state.drawing =
+        ass_drawing_new(render_priv->fontconfig_priv,
+                        render_priv->state.font,
+                        render_priv->settings.hinting,
+                        render_priv->ftlibrary);
+
+    apply_transition_effects(render_priv, event);
+}
+
+static void free_render_context(ass_renderer_t *render_priv)
+{
+    free(render_priv->state.family);
+    ass_drawing_free(render_priv->state.drawing);
+
+    render_priv->state.family = NULL;
+    render_priv->state.drawing = NULL;
+}
+
+// Calculate the cbox of a series of points
+static void
+get_contour_cbox(FT_BBox *box, FT_Vector *points, int start, int end)
+{
+    box->xMin = box->yMin = INT_MAX;
+    box->xMax = box->yMax = INT_MIN;
+    int i;
+
+    for (i = start; i < end; i++) {
+        box->xMin = (points[i].x < box->xMin) ? points[i].x : box->xMin;
+        box->xMax = (points[i].x > box->xMax) ? points[i].x : box->xMax;
+        box->yMin = (points[i].y < box->yMin) ? points[i].y : box->yMin;
+        box->yMax = (points[i].y > box->yMax) ? points[i].y : box->yMax;
+    }
+}
+
+/**
+ * \brief Fix-up stroker result for huge borders by removing the contours from
+ * the outline that are harmful.
+*/
+static void fix_freetype_stroker(FT_OutlineGlyph glyph, int border_x,
+                                 int border_y)
+{
+    int nc = glyph->outline.n_contours;
+    int begin, stop;
+    char modified = 0;
+    char *valid_cont;
+    int start = 0;
+    int end = -1;
+    FT_BBox *boxes = calloc(nc, sizeof(FT_BBox));
+    int i, j;
+
+    // Create a list of cboxes of the contours
+    for (i = 0; i < nc; i++) {
+        start = end + 1;
+        end = glyph->outline.contours[i];
+        get_contour_cbox(&boxes[i], glyph->outline.points, start, end);
+    }
+
+    // if a) contour's cbox is contained in another contours cbox
+    //    b) contour's height or width is smaller than the border*2
+    // the contour can be safely removed.
+    valid_cont = calloc(1, nc);
+    for (i = 0; i < nc; i++) {
+        valid_cont[i] = 1;
+        for (j = 0; j < nc; j++) {
+            if (i == j)
+                continue;
+            if (boxes[i].xMin >= boxes[j].xMin &&
+                boxes[i].xMax <= boxes[j].xMax &&
+                boxes[i].yMin >= boxes[j].yMin &&
+                boxes[i].yMax <= boxes[j].yMax) {
+                int width = boxes[i].xMax - boxes[i].xMin;
+                int height = boxes[i].yMax - boxes[i].yMin;
+                if (width < border_x * 2 || height < border_y * 2) {
+                    valid_cont[i] = 0;
+                    modified = 1;
+                    break;
+                }
+            }
+        }
+    }
+
+    // Zero-out contours that can be removed; much simpler than copying
+    if (modified) {
+        for (i = 0; i < nc; i++) {
+            if (valid_cont[i])
+                continue;
+            begin = (i == 0) ? 0 : glyph->outline.contours[i - 1] + 1;
+            stop = glyph->outline.contours[i];
+            for (j = begin; j <= stop; j++) {
+                glyph->outline.points[j].x = 0;
+                glyph->outline.points[j].y = 0;
+                glyph->outline.tags[j] = 0;
+            }
+        }
+    }
+
+    free(boxes);
+    free(valid_cont);
+}
+
+/*
+ * Stroke an outline glyph in x/y direction.  Applies various fixups to get
+ * around limitations of the FreeType stroker.
+ */
+static void stroke_outline_glyph(ass_renderer_t *render_priv,
+                                 FT_OutlineGlyph *glyph, int sx, int sy)
+{
+    if (sx <= 0 && sy <= 0)
+        return;
+
+    fix_freetype_stroker(*glyph, sx, sy);
+
+    // Borders are equal; use the regular stroker
+    if (sx == sy && render_priv->state.stroker) {
+        int error;
+        error = FT_Glyph_StrokeBorder((FT_Glyph *) glyph,
+                                      render_priv->state.stroker, 0, 1);
+        if (error)
+            ass_msg(render_priv->library, MSGL_WARN,
+                    "FT_Glyph_Stroke error: %d", error);
+
+    // "Stroke" with the outline emboldener in two passes.
+    // The outlines look uglier, but the emboldening never adds any points
+    } else {
+        int i;
+        FT_Outline *ol = &(*glyph)->outline;
+        FT_Outline nol;
+        FT_Outline_New(render_priv->ftlibrary, ol->n_points,
+                       ol->n_contours, &nol);
+        FT_Outline_Copy(ol, &nol);
+
+        FT_Outline_Embolden(ol, sx * 2);
+        FT_Outline_Translate(ol, -sx, -sx);
+        FT_Outline_Embolden(&nol, sy * 2);
+        FT_Outline_Translate(&nol, -sy, -sy);
+
+        for (i = 0; i < ol->n_points; i++)
+            ol->points[i].y = nol.points[i].y;
+
+        FT_Outline_Done(render_priv->ftlibrary, &nol);
+    }
+}
+
+/**
+ * \brief Get normal and outline (border) glyphs
+ * \param symbol ucs4 char
+ * \param info out: struct filled with extracted data
+ * Tries to get both glyphs from cache.
+ * If they can't be found, gets a glyph from font face, generates outline with FT_Stroker,
+ * and add them to cache.
+ * The glyphs are returned in info->glyph and info->outline_glyph
+ */
+static void
+get_outline_glyph(ass_renderer_t *render_priv, int symbol,
+                  glyph_info_t *info, ass_drawing_t *drawing)
+{
+    glyph_hash_val_t *val;
+    glyph_hash_key_t key;
+    memset(&key, 0, sizeof(key));
+
+    if (drawing->hash) {
+        key.scale_x = double_to_d16(render_priv->state.scale_x);
+        key.scale_y = double_to_d16(render_priv->state.scale_y);
+        key.outline.x = render_priv->state.border_x * 0xFFFF;
+        key.outline.y = render_priv->state.border_y * 0xFFFF;
+        key.drawing_hash = drawing->hash;
+    } else {
+        key.font = render_priv->state.font;
+        key.size = render_priv->state.font_size;
+        key.ch = symbol;
+        key.bold = render_priv->state.bold;
+        key.italic = render_priv->state.italic;
+        key.scale_x = double_to_d16(render_priv->state.scale_x);
+        key.scale_y = double_to_d16(render_priv->state.scale_y);
+        key.outline.x = render_priv->state.border_x * 0xFFFF;
+        key.outline.y = render_priv->state.border_y * 0xFFFF;
+        key.flags = render_priv->state.flags;
+    }
+    memset(info, 0, sizeof(glyph_info_t));
+
+    val = cache_find_glyph(render_priv->cache.glyph_cache, &key);
+    if (val) {
+        FT_Glyph_Copy(val->glyph, &info->glyph);
+        if (val->outline_glyph)
+            FT_Glyph_Copy(val->outline_glyph, &info->outline_glyph);
+        info->bbox = val->bbox_scaled;
+        info->advance.x = val->advance.x;
+        info->advance.y = val->advance.y;
+        if (drawing->hash) {
+            drawing->asc = val->asc;
+            drawing->desc = val->desc;
+        }
+    } else {
+        glyph_hash_val_t v;
+        if (drawing->hash) {
+            ass_drawing_parse(drawing, 0);
+            FT_Glyph_Copy((FT_Glyph) drawing->glyph, &info->glyph);
+        } else {
+            info->glyph =
+                ass_font_get_glyph(render_priv->fontconfig_priv,
+                                   render_priv->state.font, symbol,
+                                   render_priv->settings.hinting,
+                                   render_priv->state.flags);
+        }
+        if (!info->glyph)
+            return;
+        info->advance.x = d16_to_d6(info->glyph->advance.x);
+        info->advance.y = d16_to_d6(info->glyph->advance.y);
+        FT_Glyph_Get_CBox(info->glyph, FT_GLYPH_BBOX_SUBPIXELS, &info->bbox);
+
+        if (render_priv->state.border_x > 0 ||
+            render_priv->state.border_y > 0) {
+
+            FT_Glyph_Copy(info->glyph, &info->outline_glyph);
+            stroke_outline_glyph(render_priv,
+                                 (FT_OutlineGlyph *) &info->outline_glyph,
+                                 double_to_d6(render_priv->state.border_x *
+                                              render_priv->border_scale),
+                                 double_to_d6(render_priv->state.border_y *
+                                              render_priv->border_scale));
+        }
+
+        memset(&v, 0, sizeof(v));
+        FT_Glyph_Copy(info->glyph, &v.glyph);
+        if (info->outline_glyph)
+            FT_Glyph_Copy(info->outline_glyph, &v.outline_glyph);
+        v.advance = info->advance;
+        v.bbox_scaled = info->bbox;
+        if (drawing->hash) {
+            v.asc = drawing->asc;
+            v.desc = drawing->desc;
+        }
+        cache_add_glyph(render_priv->cache.glyph_cache, &key, &v);
+    }
+}
+
+static void transform_3d(FT_Vector shift, FT_Glyph *glyph,
+                         FT_Glyph *glyph2, double frx, double fry,
+                         double frz, double fax, double fay, double scale);
+
+/**
+ * \brief Get bitmaps for a glyph
+ * \param info glyph info
+ * Tries to get glyph bitmaps from bitmap cache.
+ * If they can't be found, they are generated by rotating and rendering the glyph.
+ * After that, bitmaps are added to the cache.
+ * They are returned in info->bm (glyph), info->bm_o (outline) and info->bm_s (shadow).
+ */
+static void
+get_bitmap_glyph(ass_renderer_t *render_priv, glyph_info_t *info)
+{
+    bitmap_hash_val_t *val;
+    bitmap_hash_key_t *key = &info->hash_key;
+
+    val = cache_find_bitmap(render_priv->cache.bitmap_cache, key);
+
+    if (val) {
+        info->bm = val->bm;
+        info->bm_o = val->bm_o;
+        info->bm_s = val->bm_s;
+    } else {
+        FT_Vector shift;
+        bitmap_hash_val_t hash_val;
+        int error;
+        info->bm = info->bm_o = info->bm_s = 0;
+        if (info->glyph && info->symbol != '\n' && info->symbol != 0) {
+            // calculating rotation shift vector (from rotation origin to the glyph basepoint)
+            shift.x = info->hash_key.shift_x;
+            shift.y = info->hash_key.shift_y;
+            // apply rotation
+            transform_3d(shift, &info->glyph, &info->outline_glyph,
+                         info->frx, info->fry, info->frz, info->fax,
+                         info->fay, render_priv->font_scale);
+
+            // subpixel shift
+            if (info->glyph)
+                FT_Outline_Translate(
+                    &((FT_OutlineGlyph) info->glyph)->outline,
+                    info->hash_key.advance.x,
+                    -info->hash_key.advance.y);
+            if (info->outline_glyph)
+                FT_Outline_Translate(
+                    &((FT_OutlineGlyph) info->outline_glyph)->outline,
+                    info->hash_key.advance.x,
+                    -info->hash_key.advance.y);
+
+            // render glyph
+            error = glyph_to_bitmap(render_priv->library,
+                                    render_priv->synth_priv,
+                                    info->glyph, info->outline_glyph,
+                                    &info->bm, &info->bm_o,
+                                    &info->bm_s, info->be,
+                                    info->blur * render_priv->border_scale,
+                                    info->hash_key.shadow_offset);
+            if (error)
+                info->symbol = 0;
+
+            // add bitmaps to cache
+            hash_val.bm_o = info->bm_o;
+            hash_val.bm = info->bm;
+            hash_val.bm_s = info->bm_s;
+            cache_add_bitmap(render_priv->cache.bitmap_cache,
+                             &(info->hash_key), &hash_val);
+        }
+    }
+    // deallocate glyphs
+    if (info->glyph)
+        FT_Done_Glyph(info->glyph);
+    if (info->outline_glyph)
+        FT_Done_Glyph(info->outline_glyph);
+}
+
+/**
+ * This function goes through text_info and calculates text parameters.
+ * The following text_info fields are filled:
+ *   height
+ *   lines[].height
+ *   lines[].asc
+ *   lines[].desc
+ */
+static void measure_text(ass_renderer_t *render_priv)
+{
+    text_info_t *text_info = &render_priv->text_info;
+    int cur_line = 0;
+    double max_asc = 0., max_desc = 0.;
+    glyph_info_t *last = NULL;
+    int i;
+    int empty_line = 1;
+    text_info->height = 0.;
+    for (i = 0; i < text_info->length + 1; ++i) {
+        if ((i == text_info->length) || text_info->glyphs[i].linebreak) {
+            if (empty_line && cur_line > 0 && last && i < text_info->length) {
+                max_asc = d6_to_double(last->asc) / 2.0;
+                max_desc = d6_to_double(last->desc) / 2.0;
+            }
+            text_info->lines[cur_line].asc = max_asc;
+            text_info->lines[cur_line].desc = max_desc;
+            text_info->height += max_asc + max_desc;
+            cur_line++;
+            max_asc = max_desc = 0.;
+            empty_line = 1;
+        } else
+            empty_line = 0;
+        if (i < text_info->length) {
+            glyph_info_t *cur = text_info->glyphs + i;
+            if (d6_to_double(cur->asc) > max_asc)
+                max_asc = d6_to_double(cur->asc);
+            if (d6_to_double(cur->desc) > max_desc)
+                max_desc = d6_to_double(cur->desc);
+            if (cur->symbol != '\n' && cur->symbol != 0)
+                last = cur;
+        }
+    }
+    text_info->height +=
+        (text_info->n_lines -
+         1) * render_priv->settings.line_spacing;
+}
+
+/**
+ * \brief rearrange text between lines
+ * \param max_text_width maximal text line width in pixels
+ * The algo is similar to the one in libvo/sub.c:
+ * 1. Place text, wrapping it when current line is full
+ * 2. Try moving words from the end of a line to the beginning of the next one while it reduces
+ * the difference in lengths between this two lines.
+ * The result may not be optimal, but usually is good enough.
+ */
+static void
+wrap_lines_smart(ass_renderer_t *render_priv, double max_text_width)
+{
+    int i;
+    glyph_info_t *cur, *s1, *e1, *s2, *s3, *w;
+    int last_space;
+    int break_type;
+    int exit;
+    double pen_shift_x;
+    double pen_shift_y;
+    int cur_line;
+    text_info_t *text_info = &render_priv->text_info;
+
+    last_space = -1;
+    text_info->n_lines = 1;
+    break_type = 0;
+    s1 = text_info->glyphs;     // current line start
+    for (i = 0; i < text_info->length; ++i) {
+        int break_at;
+        double s_offset, len;
+        cur = text_info->glyphs + i;
+        break_at = -1;
+        s_offset = d6_to_double(s1->bbox.xMin + s1->pos.x);
+        len = d6_to_double(cur->bbox.xMax + cur->pos.x) - s_offset;
+
+        if (cur->symbol == '\n') {
+            break_type = 2;
+            break_at = i;
+            ass_msg(render_priv->library, MSGL_DBG2,
+                    "forced line break at %d", break_at);
+        }
+
+        if ((len >= max_text_width)
+            && (render_priv->track->WrapStyle != 2)) {
+            break_type = 1;
+            break_at = last_space;
+            if (break_at == -1)
+                break_at = i - 1;
+            if (break_at == -1)
+                break_at = 0;
+            ass_msg(render_priv->library, MSGL_DBG2, "overfill at %d", i);
+            ass_msg(render_priv->library, MSGL_DBG2, "line break at %d",
+                    break_at);
+        }
+
+        if (break_at != -1) {
+            // need to use one more line
+            // marking break_at+1 as start of a new line
+            int lead = break_at + 1;    // the first symbol of the new line
+            if (text_info->n_lines >= text_info->max_lines) {
+                // Raise maximum number of lines
+                text_info->max_lines *= 2;
+                text_info->lines = realloc(text_info->lines,
+                                           sizeof(line_info_t) *
+                                           text_info->max_lines);
+            }
+            if (lead < text_info->length)
+                text_info->glyphs[lead].linebreak = break_type;
+            last_space = -1;
+            s1 = text_info->glyphs + lead;
+            s_offset = d6_to_double(s1->bbox.xMin + s1->pos.x);
+            text_info->n_lines++;
+        }
+
+        if (cur->symbol == ' ')
+            last_space = i;
+
+        // make sure the hard linebreak is not forgotten when
+        // there was a new soft linebreak just inserted
+        if (cur->symbol == '\n' && break_type == 1)
+            i--;
+    }
+#define DIFF(x,y) (((x) < (y)) ? (y - x) : (x - y))
+    exit = 0;
+    while (!exit) {
+        exit = 1;
+        w = s3 = text_info->glyphs;
+        s1 = s2 = 0;
+        for (i = 0; i <= text_info->length; ++i) {
+            cur = text_info->glyphs + i;
+            if ((i == text_info->length) || cur->linebreak) {
+                s1 = s2;
+                s2 = s3;
+                s3 = cur;
+                if (s1 && (s2->linebreak == 1)) {       // have at least 2 lines, and linebreak is 'soft'
+                    double l1, l2, l1_new, l2_new;
+
+                    w = s2;
+                    do {
+                        --w;
+                    } while ((w > s1) && (w->symbol == ' '));
+                    while ((w > s1) && (w->symbol != ' ')) {
+                        --w;
+                    }
+                    e1 = w;
+                    while ((e1 > s1) && (e1->symbol == ' ')) {
+                        --e1;
+                    }
+                    if (w->symbol == ' ')
+                        ++w;
+
+                    l1 = d6_to_double(((s2 - 1)->bbox.xMax + (s2 - 1)->pos.x) -
+                        (s1->bbox.xMin + s1->pos.x));
+                    l2 = d6_to_double(((s3 - 1)->bbox.xMax + (s3 - 1)->pos.x) -
+                        (s2->bbox.xMin + s2->pos.x));
+                    l1_new = d6_to_double(
+                        (e1->bbox.xMax + e1->pos.x) -
+                        (s1->bbox.xMin + s1->pos.x));
+                    l2_new = d6_to_double(
+                        ((s3 - 1)->bbox.xMax + (s3 - 1)->pos.x) -
+                        (w->bbox.xMin + w->pos.x));
+
+                    if (DIFF(l1_new, l2_new) < DIFF(l1, l2)) {
+                        w->linebreak = 1;
+                        s2->linebreak = 0;
+                        exit = 0;
+                    }
+                }
+            }
+            if (i == text_info->length)
+                break;
+        }
+
+    }
+    assert(text_info->n_lines >= 1);
+#undef DIFF
+
+    measure_text(render_priv);
+
+    pen_shift_x = 0.;
+    pen_shift_y = 0.;
+    cur_line = 1;
+    for (i = 0; i < text_info->length; ++i) {
+        cur = text_info->glyphs + i;
+        if (cur->linebreak) {
+            double height =
+                text_info->lines[cur_line - 1].desc +
+                text_info->lines[cur_line].asc;
+            cur_line++;
+            pen_shift_x = d6_to_double(-cur->pos.x);
+            pen_shift_y += height + render_priv->settings.line_spacing;
+            ass_msg(render_priv->library, MSGL_DBG2,
+                   "shifting from %d to %d by (%f, %f)", i,
+                   text_info->length - 1, pen_shift_x, pen_shift_y);
+        }
+        cur->pos.x += double_to_d6(pen_shift_x);
+        cur->pos.y += double_to_d6(pen_shift_y);
+    }
+}
+
+/**
+ * \brief determine karaoke effects
+ * Karaoke effects cannot be calculated during parse stage (get_next_char()),
+ * so they are done in a separate step.
+ * Parse stage: when karaoke style override is found, its parameters are stored in the next glyph's
+ * (the first glyph of the karaoke word)'s effect_type and effect_timing.
+ * This function:
+ * 1. sets effect_type for all glyphs in the word (_karaoke_ word)
+ * 2. sets effect_timing for all glyphs to x coordinate of the border line between the left and right karaoke parts
+ * (left part is filled with PrimaryColour, right one - with SecondaryColour).
+ */
+static void process_karaoke_effects(ass_renderer_t *render_priv)
+{
+    glyph_info_t *cur, *cur2;
+    glyph_info_t *s1, *e1;      // start and end of the current word
+    glyph_info_t *s2;           // start of the next word
+    int i;
+    int timing;                 // current timing
+    int tm_start, tm_end;       // timings at start and end of the current word
+    int tm_current;
+    double dt;
+    int x;
+    int x_start, x_end;
+
+    tm_current = render_priv->time - render_priv->state.event->Start;
+    timing = 0;
+    s1 = s2 = 0;
+    for (i = 0; i <= render_priv->text_info.length; ++i) {
+        cur = render_priv->text_info.glyphs + i;
+        if ((i == render_priv->text_info.length)
+            || (cur->effect_type != EF_NONE)) {
+            s1 = s2;
+            s2 = cur;
+            if (s1) {
+                e1 = s2 - 1;
+                tm_start = timing + s1->effect_skip_timing;
+                tm_end = tm_start + s1->effect_timing;
+                timing = tm_end;
+                x_start = 1000000;
+                x_end = -1000000;
+                for (cur2 = s1; cur2 <= e1; ++cur2) {
+                    x_start = FFMIN(x_start, d6_to_int(cur2->bbox.xMin + cur2->pos.x));
+                    x_end = FFMAX(x_end, d6_to_int(cur2->bbox.xMax + cur2->pos.x));
+                }
+
+                dt = (tm_current - tm_start);
+                if ((s1->effect_type == EF_KARAOKE)
+                    || (s1->effect_type == EF_KARAOKE_KO)) {
+                    if (dt > 0)
+                        x = x_end + 1;
+                    else
+                        x = x_start;
+                } else if (s1->effect_type == EF_KARAOKE_KF) {
+                    dt /= (tm_end - tm_start);
+                    x = x_start + (x_end - x_start) * dt;
+                } else {
+                    ass_msg(render_priv->library, MSGL_ERR,
+                            "Unknown effect type");
+                    continue;
+                }
+
+                for (cur2 = s1; cur2 <= e1; ++cur2) {
+                    cur2->effect_type = s1->effect_type;
+                    cur2->effect_timing = x - d6_to_int(cur2->pos.x);
+                }
+            }
+        }
+    }
+}
+
+/**
+ * \brief Calculate base point for positioning and rotation
+ * \param bbox text bbox
+ * \param alignment alignment
+ * \param bx, by out: base point coordinates
+ */
+static void get_base_point(double_bbox_t *bbox, int alignment, double *bx, double *by)
+{
+    const int halign = alignment & 3;
+    const int valign = alignment & 12;
+    if (bx)
+        switch (halign) {
+        case HALIGN_LEFT:
+            *bx = bbox->xMin;
+            break;
+        case HALIGN_CENTER:
+            *bx = (bbox->xMax + bbox->xMin) / 2.0;
+            break;
+        case HALIGN_RIGHT:
+            *bx = bbox->xMax;
+            break;
+        }
+    if (by)
+        switch (valign) {
+        case VALIGN_TOP:
+            *by = bbox->yMin;
+            break;
+        case VALIGN_CENTER:
+            *by = (bbox->yMax + bbox->yMin) / 2.0;
+            break;
+        case VALIGN_SUB:
+            *by = bbox->yMax;
+            break;
+        }
+}
+
+/**
+ * \brief Apply transformation to outline points of a glyph
+ * Applies rotations given by frx, fry and frz and projects the points back
+ * onto the screen plane.
+ */
+static void
+transform_3d_points(FT_Vector shift, FT_Glyph glyph, double frx,
+                    double fry, double frz, double fax, double fay,
+                    double scale)
+{
+    double sx = sin(frx);
+    double sy = sin(fry);
+    double sz = sin(frz);
+    double cx = cos(frx);
+    double cy = cos(fry);
+    double cz = cos(frz);
+    FT_Outline *outline = &((FT_OutlineGlyph) glyph)->outline;
+    FT_Vector *p = outline->points;
+    double x, y, z, xx, yy, zz;
+    int i, dist;
+
+    dist = 20000 * scale;
+    for (i = 0; i < outline->n_points; i++) {
+        x = (double) p[i].x + shift.x + (-fax * p[i].y);
+        y = (double) p[i].y + shift.y + (-fay * p[i].x);
+        z = 0.;
+
+        xx = x * cz + y * sz;
+        yy = -(x * sz - y * cz);
+        zz = z;
+
+        x = xx;
+        y = yy * cx + zz * sx;
+        z = yy * sx - zz * cx;
+
+        xx = x * cy + z * sy;
+        yy = y;
+        zz = x * sy - z * cy;
+
+        zz = FFMAX(zz, 1000 - dist);
+
+        x = (xx * dist) / (zz + dist);
+        y = (yy * dist) / (zz + dist);
+        p[i].x = x - shift.x + 0.5;
+        p[i].y = y - shift.y + 0.5;
+    }
+}
+
+/**
+ * \brief Apply 3d transformation to several objects
+ * \param shift FreeType vector
+ * \param glyph FreeType glyph
+ * \param glyph2 FreeType glyph
+ * \param frx x-axis rotation angle
+ * \param fry y-axis rotation angle
+ * \param frz z-axis rotation angle
+ * Rotates both glyphs by frx, fry and frz. Shift vector is added before rotation and subtracted after it.
+ */
+static void
+transform_3d(FT_Vector shift, FT_Glyph *glyph, FT_Glyph *glyph2,
+             double frx, double fry, double frz, double fax, double fay,
+             double scale)
+{
+    frx = -frx;
+    frz = -frz;
+    if (frx != 0. || fry != 0. || frz != 0. || fax != 0. || fay != 0.) {
+        if (glyph && *glyph)
+            transform_3d_points(shift, *glyph, frx, fry, frz,
+                                fax, fay, scale);
+
+        if (glyph2 && *glyph2)
+            transform_3d_points(shift, *glyph2, frx, fry, frz,
+                                fax, fay, scale);
+    }
+}
+
+
+/**
+ * \brief Main ass rendering function, glues everything together
+ * \param event event to render
+ * \param event_images struct containing resulting images, will also be initialized
+ * Process event, appending resulting ass_image_t's to images_root.
+ */
+static int
+ass_render_event(ass_renderer_t *render_priv, ass_event_t *event,
+                 event_images_t *event_images)
+{
+    char *p;
+    FT_UInt previous;
+    FT_UInt num_glyphs;
+    FT_Vector pen;
+    unsigned code;
+    double_bbox_t bbox;
+    int i, j;
+    int MarginL, MarginR, MarginV;
+    int last_break;
+    int alignment, halign, valign;
+    double device_x = 0;
+    double device_y = 0;
+    text_info_t *text_info = &render_priv->text_info;
+    ass_drawing_t *drawing;
+
+    if (event->Style >= render_priv->track->n_styles) {
+        ass_msg(render_priv->library, MSGL_WARN, "No style found");
+        return 1;
+    }
+    if (!event->Text) {
+        ass_msg(render_priv->library, MSGL_WARN, "Empty event");
+        return 1;
+    }
+
+    init_render_context(render_priv, event);
+
+    drawing = render_priv->state.drawing;
+    text_info->length = 0;
+    pen.x = 0;
+    pen.y = 0;
+    previous = 0;
+    num_glyphs = 0;
+    p = event->Text;
+    // Event parsing.
+    while (1) {
+        // get next char, executing style override
+        // this affects render_context
+        do {
+            code = get_next_char(render_priv, &p);
+            if (render_priv->state.drawing_mode && code)
+                ass_drawing_add_char(drawing, (char) code);
+        } while (code && render_priv->state.drawing_mode);      // skip everything in drawing mode
+
+        // Parse drawing
+        if (drawing->i) {
+            drawing->scale_x = render_priv->state.scale_x *
+                                     render_priv->font_scale_x *
+                                     render_priv->font_scale;
+            drawing->scale_y = render_priv->state.scale_y *
+                                     render_priv->font_scale;
+            ass_drawing_hash(drawing);
+            p--;
+            code = -1;
+        }
+
+        // face could have been changed in get_next_char
+        if (!render_priv->state.font) {
+            free_render_context(render_priv);
+            return 1;
+        }
+
+        if (code == 0)
+            break;
+
+        if (text_info->length >= text_info->max_glyphs) {
+            // Raise maximum number of glyphs
+            text_info->max_glyphs *= 2;
+            text_info->glyphs =
+                realloc(text_info->glyphs,
+                        sizeof(glyph_info_t) * text_info->max_glyphs);
+        }
+
+        // Add kerning to pen
+        if (previous && code && !drawing->hash) {
+            FT_Vector delta;
+            delta =
+                ass_font_get_kerning(render_priv->state.font, previous,
+                                     code);
+            pen.x += delta.x * render_priv->state.scale_x;
+            pen.y += delta.y * render_priv->state.scale_y;
+        }
+
+        ass_font_set_transform(render_priv->state.font,
+                               render_priv->state.scale_x *
+                               render_priv->font_scale_x,
+                               render_priv->state.scale_y, NULL);
+
+        get_outline_glyph(render_priv, code,
+                          text_info->glyphs + text_info->length, drawing);
+
+        text_info->glyphs[text_info->length].pos.x = pen.x;
+        text_info->glyphs[text_info->length].pos.y = pen.y;
+
+        pen.x += text_info->glyphs[text_info->length].advance.x;
+        pen.x += double_to_d6(render_priv->state.hspacing *
+                              render_priv->font_scale);
+        pen.y += text_info->glyphs[text_info->length].advance.y;
+        pen.y += render_priv->state.fay *
+                 text_info->glyphs[text_info->length].advance.x;
+
+        previous = code;
+
+        text_info->glyphs[text_info->length].symbol = code;
+        text_info->glyphs[text_info->length].linebreak = 0;
+        for (i = 0; i < 4; ++i) {
+            uint32_t clr = render_priv->state.c[i];
+            change_alpha(&clr,
+                         mult_alpha(_a(clr), render_priv->state.fade), 1.);
+            text_info->glyphs[text_info->length].c[i] = clr;
+        }
+        text_info->glyphs[text_info->length].effect_type =
+            render_priv->state.effect_type;
+        text_info->glyphs[text_info->length].effect_timing =
+            render_priv->state.effect_timing;
+        text_info->glyphs[text_info->length].effect_skip_timing =
+            render_priv->state.effect_skip_timing;
+        text_info->glyphs[text_info->length].be = render_priv->state.be;
+        text_info->glyphs[text_info->length].blur = render_priv->state.blur;
+        text_info->glyphs[text_info->length].shadow_x =
+            render_priv->state.shadow_x;
+        text_info->glyphs[text_info->length].shadow_y =
+            render_priv->state.shadow_y;
+        text_info->glyphs[text_info->length].frx = render_priv->state.frx;
+        text_info->glyphs[text_info->length].fry = render_priv->state.fry;
+        text_info->glyphs[text_info->length].frz = render_priv->state.frz;
+        text_info->glyphs[text_info->length].fax = render_priv->state.fax;
+        text_info->glyphs[text_info->length].fay = render_priv->state.fay;
+        if (drawing->hash) {
+            text_info->glyphs[text_info->length].asc = drawing->asc;
+            text_info->glyphs[text_info->length].desc = drawing->desc;
+        } else {
+            ass_font_get_asc_desc(render_priv->state.font, code,
+                                  &text_info->glyphs[text_info->length].asc,
+                                  &text_info->glyphs[text_info->length].desc);
+
+            text_info->glyphs[text_info->length].asc *=
+                render_priv->state.scale_y;
+            text_info->glyphs[text_info->length].desc *=
+                render_priv->state.scale_y;
+        }
+
+        // fill bitmap_hash_key
+        if (!drawing->hash) {
+            text_info->glyphs[text_info->length].hash_key.font =
+                render_priv->state.font;
+            text_info->glyphs[text_info->length].hash_key.size =
+                render_priv->state.font_size;
+            text_info->glyphs[text_info->length].hash_key.bold =
+                render_priv->state.bold;
+            text_info->glyphs[text_info->length].hash_key.italic =
+                render_priv->state.italic;
+        } else
+            text_info->glyphs[text_info->length].hash_key.drawing_hash =
+                drawing->hash;
+        text_info->glyphs[text_info->length].hash_key.ch = code;
+        text_info->glyphs[text_info->length].hash_key.outline.x =
+            render_priv->state.border_x * 0xFFFF;
+        text_info->glyphs[text_info->length].hash_key.outline.y =
+            render_priv->state.border_y * 0xFFFF;
+        text_info->glyphs[text_info->length].hash_key.scale_x =
+            render_priv->state.scale_x * 0xFFFF;
+        text_info->glyphs[text_info->length].hash_key.scale_y =
+            render_priv->state.scale_y * 0xFFFF;
+        text_info->glyphs[text_info->length].hash_key.frx =
+            render_priv->state.frx * 0xFFFF;
+        text_info->glyphs[text_info->length].hash_key.fry =
+            render_priv->state.fry * 0xFFFF;
+        text_info->glyphs[text_info->length].hash_key.frz =
+            render_priv->state.frz * 0xFFFF;
+        text_info->glyphs[text_info->length].hash_key.fax =
+            render_priv->state.fax * 0xFFFF;
+        text_info->glyphs[text_info->length].hash_key.fay =
+            render_priv->state.fay * 0xFFFF;
+        text_info->glyphs[text_info->length].hash_key.advance.x = pen.x;
+        text_info->glyphs[text_info->length].hash_key.advance.y = pen.y;
+        text_info->glyphs[text_info->length].hash_key.be =
+            render_priv->state.be;
+        text_info->glyphs[text_info->length].hash_key.blur =
+            render_priv->state.blur;
+        text_info->glyphs[text_info->length].hash_key.shadow_offset.x =
+            double_to_d6(
+                render_priv->state.shadow_x * render_priv->border_scale -
+                (int) (render_priv->state.shadow_x *
+                render_priv->border_scale));
+        text_info->glyphs[text_info->length].hash_key.shadow_offset.y =
+            double_to_d6(
+                render_priv->state.shadow_y * render_priv->border_scale -
+                (int) (render_priv->state.shadow_y *
+                render_priv->border_scale));
+
+        text_info->length++;
+
+        render_priv->state.effect_type = EF_NONE;
+        render_priv->state.effect_timing = 0;
+        render_priv->state.effect_skip_timing = 0;
+
+        if (drawing->hash) {
+            ass_drawing_free(drawing);
+            drawing = render_priv->state.drawing =
+                ass_drawing_new(render_priv->fontconfig_priv,
+                    render_priv->state.font,
+                    render_priv->settings.hinting,
+                    render_priv->ftlibrary);
+        }
+    }
+
+
+    if (text_info->length == 0) {
+        // no valid symbols in the event; this can be smth like {comment}
+        free_render_context(render_priv);
+        return 1;
+    }
+    // depends on glyph x coordinates being monotonous, so it should be done before line wrap
+    process_karaoke_effects(render_priv);
+
+    // alignments
+    alignment = render_priv->state.alignment;
+    halign = alignment & 3;
+    valign = alignment & 12;
+
+    MarginL =
+        (event->MarginL) ? event->MarginL : render_priv->state.style->
+        MarginL;
+    MarginR =
+        (event->MarginR) ? event->MarginR : render_priv->state.style->
+        MarginR;
+    MarginV =
+        (event->MarginV) ? event->MarginV : render_priv->state.style->
+        MarginV;
+
+    if (render_priv->state.evt_type != EVENT_HSCROLL) {
+        double max_text_width;
+
+        // calculate max length of a line
+        max_text_width =
+            x2scr(render_priv,
+                  render_priv->track->PlayResX - MarginR) -
+            x2scr(render_priv, MarginL);
+
+        // rearrange text in several lines
+        wrap_lines_smart(render_priv, max_text_width);
+
+        // align text
+        last_break = -1;
+        for (i = 1; i < text_info->length + 1; ++i) {   // (text_info->length + 1) is the end of the last line
+            if ((i == text_info->length)
+                || text_info->glyphs[i].linebreak) {
+                double width, shift = 0;
+                glyph_info_t *first_glyph =
+                    text_info->glyphs + last_break + 1;
+                glyph_info_t *last_glyph = text_info->glyphs + i - 1;
+
+                while ((last_glyph > first_glyph)
+                       && ((last_glyph->symbol == '\n')
+                           || (last_glyph->symbol == 0)))
+                    last_glyph--;
+
+                width = d6_to_double(
+                    last_glyph->pos.x + last_glyph->advance.x -
+                    first_glyph->pos.x);
+                if (halign == HALIGN_LEFT) {    // left aligned, no action
+                    shift = 0;
+                } else if (halign == HALIGN_RIGHT) {    // right aligned
+                    shift = max_text_width - width;
+                } else if (halign == HALIGN_CENTER) {   // centered
+                    shift = (max_text_width - width) / 2.0;
+                }
+                for (j = last_break + 1; j < i; ++j) {
+                    text_info->glyphs[j].pos.x += double_to_d6(shift);
+                }
+                last_break = i - 1;
+            }
+        }
+    } else {                    // render_priv->state.evt_type == EVENT_HSCROLL
+        measure_text(render_priv);
+    }
+
+    // determing text bounding box
+    compute_string_bbox(text_info, &bbox);
+
+    // determine device coordinates for text
+
+    // x coordinate for everything except positioned events
+    if (render_priv->state.evt_type == EVENT_NORMAL ||
+        render_priv->state.evt_type == EVENT_VSCROLL) {
+        device_x = x2scr(render_priv, MarginL);
+    } else if (render_priv->state.evt_type == EVENT_HSCROLL) {
+        if (render_priv->state.scroll_direction == SCROLL_RL)
+            device_x =
+                x2scr(render_priv,
+                      render_priv->track->PlayResX -
+                      render_priv->state.scroll_shift);
+        else if (render_priv->state.scroll_direction == SCROLL_LR)
+            device_x =
+                x2scr(render_priv,
+                      render_priv->state.scroll_shift) - (bbox.xMax -
+                                                          bbox.xMin);
+    }
+    // y coordinate for everything except positioned events
+    if (render_priv->state.evt_type == EVENT_NORMAL ||
+        render_priv->state.evt_type == EVENT_HSCROLL) {
+        if (valign == VALIGN_TOP) {     // toptitle
+            device_y =
+                y2scr_top(render_priv,
+                          MarginV) + text_info->lines[0].asc;
+        } else if (valign == VALIGN_CENTER) {   // midtitle
+            double scr_y =
+                y2scr(render_priv, render_priv->track->PlayResY / 2.0);
+            device_y = scr_y - (bbox.yMax + bbox.yMin) / 2.0;
+        } else {                // subtitle
+            double scr_y;
+            if (valign != VALIGN_SUB)
+                ass_msg(render_priv->library, MSGL_V,
+                       "Invalid valign, supposing 0 (subtitle)");
+            scr_y =
+                y2scr_sub(render_priv,
+                          render_priv->track->PlayResY - MarginV);
+            device_y = scr_y;
+            device_y -= text_info->height;
+            device_y += text_info->lines[0].asc;
+        }
+    } else if (render_priv->state.evt_type == EVENT_VSCROLL) {
+        if (render_priv->state.scroll_direction == SCROLL_TB)
+            device_y =
+                y2scr(render_priv,
+                      render_priv->state.clip_y0 +
+                      render_priv->state.scroll_shift) - (bbox.yMax -
+                                                          bbox.yMin);
+        else if (render_priv->state.scroll_direction == SCROLL_BT)
+            device_y =
+                y2scr(render_priv,
+                      render_priv->state.clip_y1 -
+                      render_priv->state.scroll_shift);
+    }
+    // positioned events are totally different
+    if (render_priv->state.evt_type == EVENT_POSITIONED) {
+        double base_x = 0;
+        double base_y = 0;
+        ass_msg(render_priv->library, MSGL_DBG2, "positioned event at %f, %f",
+               render_priv->state.pos_x, render_priv->state.pos_y);
+        get_base_point(&bbox, alignment, &base_x, &base_y);
+        device_x =
+            x2scr_pos(render_priv, render_priv->state.pos_x) - base_x;
+        device_y =
+            y2scr_pos(render_priv, render_priv->state.pos_y) - base_y;
+    }
+    // fix clip coordinates (they depend on alignment)
+    if (render_priv->state.evt_type == EVENT_NORMAL ||
+        render_priv->state.evt_type == EVENT_HSCROLL ||
+        render_priv->state.evt_type == EVENT_VSCROLL) {
+        render_priv->state.clip_x0 =
+            x2scr(render_priv, render_priv->state.clip_x0);
+        render_priv->state.clip_x1 =
+            x2scr(render_priv, render_priv->state.clip_x1);
+        if (valign == VALIGN_TOP) {
+            render_priv->state.clip_y0 =
+                y2scr_top(render_priv, render_priv->state.clip_y0);
+            render_priv->state.clip_y1 =
+                y2scr_top(render_priv, render_priv->state.clip_y1);
+        } else if (valign == VALIGN_CENTER) {
+            render_priv->state.clip_y0 =
+                y2scr(render_priv, render_priv->state.clip_y0);
+            render_priv->state.clip_y1 =
+                y2scr(render_priv, render_priv->state.clip_y1);
+        } else if (valign == VALIGN_SUB) {
+            render_priv->state.clip_y0 =
+                y2scr_sub(render_priv, render_priv->state.clip_y0);
+            render_priv->state.clip_y1 =
+                y2scr_sub(render_priv, render_priv->state.clip_y1);
+        }
+    } else if (render_priv->state.evt_type == EVENT_POSITIONED) {
+        render_priv->state.clip_x0 =
+            x2scr_pos(render_priv, render_priv->state.clip_x0);
+        render_priv->state.clip_x1 =
+            x2scr_pos(render_priv, render_priv->state.clip_x1);
+        render_priv->state.clip_y0 =
+            y2scr_pos(render_priv, render_priv->state.clip_y0);
+        render_priv->state.clip_y1 =
+            y2scr_pos(render_priv, render_priv->state.clip_y1);
+    }
+    // calculate rotation parameters
+    {
+        double_vector_t center;
+
+        if (render_priv->state.have_origin) {
+            center.x = x2scr(render_priv, render_priv->state.org_x);
+            center.y = y2scr(render_priv, render_priv->state.org_y);
+        } else {
+            double bx = 0., by = 0.;
+            get_base_point(&bbox, alignment, &bx, &by);
+            center.x = device_x + bx;
+            center.y = device_y + by;
+        }
+
+        for (i = 0; i < text_info->length; ++i) {
+            glyph_info_t *info = text_info->glyphs + i;
+
+            if (info->hash_key.frx || info->hash_key.fry
+                || info->hash_key.frz || info->hash_key.fax
+                || info->hash_key.fay) {
+                info->hash_key.shift_x = info->pos.x + double_to_d6(device_x - center.x);
+                info->hash_key.shift_y =
+                    -(info->pos.y + double_to_d6(device_y - center.y));
+            } else {
+                info->hash_key.shift_x = 0;
+                info->hash_key.shift_y = 0;
+            }
+        }
+    }
+
+    // convert glyphs to bitmaps
+    for (i = 0; i < text_info->length; ++i) {
+        glyph_info_t *g = text_info->glyphs + i;
+        g->hash_key.advance.x =
+            double_to_d6(device_x - (int) device_x +
+            d6_to_double(g->pos.x & SUBPIXEL_MASK)) & ~SUBPIXEL_ACCURACY;
+        g->hash_key.advance.y =
+            double_to_d6(device_y - (int) device_y +
+            d6_to_double(g->pos.y & SUBPIXEL_MASK)) & ~SUBPIXEL_ACCURACY;
+        get_bitmap_glyph(render_priv, text_info->glyphs + i);
+    }
+
+    memset(event_images, 0, sizeof(*event_images));
+    event_images->top = device_y - text_info->lines[0].asc;
+    event_images->height = text_info->height;
+    event_images->detect_collisions = render_priv->state.detect_collisions;
+    event_images->shift_direction = (valign == VALIGN_TOP) ? 1 : -1;
+    event_images->event = event;
+    event_images->imgs = render_text(render_priv, (int) device_x, (int) device_y);
+
+    free_render_context(render_priv);
+
+    return 0;
+}
+
+/**
+ * \brief deallocate image list
+ * \param img list pointer
+ */
+static void ass_free_images(ass_image_t *img)
+{
+    while (img) {
+        ass_image_t *next = img->next;
+        free(img);
+        img = next;
+    }
+}
+
+static void ass_reconfigure(ass_renderer_t *priv)
+{
+    priv->render_id++;
+    priv->cache.glyph_cache =
+        ass_glyph_cache_reset(priv->cache.glyph_cache);
+    priv->cache.bitmap_cache =
+        ass_bitmap_cache_reset(priv->cache.bitmap_cache);
+    priv->cache.composite_cache =
+        ass_composite_cache_reset(priv->cache.composite_cache);
+    ass_free_images(priv->prev_images_root);
+    priv->prev_images_root = 0;
+}
+
+void ass_set_frame_size(ass_renderer_t *priv, int w, int h)
+{
+    if (priv->settings.frame_width != w || priv->settings.frame_height != h) {
+        priv->settings.frame_width = w;
+        priv->settings.frame_height = h;
+        if (priv->settings.aspect == 0.) {
+            priv->settings.aspect = ((double) w) / h;
+            priv->settings.pixel_ratio = ((double) w) / h;
+        }
+        ass_reconfigure(priv);
+    }
+}
+
+void ass_set_margins(ass_renderer_t *priv, int t, int b, int l, int r)
+{
+    if (priv->settings.left_margin != l ||
+        priv->settings.right_margin != r ||
+        priv->settings.top_margin != t
+        || priv->settings.bottom_margin != b) {
+        priv->settings.left_margin = l;
+        priv->settings.right_margin = r;
+        priv->settings.top_margin = t;
+        priv->settings.bottom_margin = b;
+        ass_reconfigure(priv);
+    }
+}
+
+void ass_set_use_margins(ass_renderer_t *priv, int use)
+{
+    priv->settings.use_margins = use;
+}
+
+void ass_set_aspect_ratio(ass_renderer_t *priv, double ar, double par)
+{
+    if (priv->settings.aspect != ar || priv->settings.pixel_ratio != par) {
+        priv->settings.aspect = ar;
+        priv->settings.pixel_ratio = par;
+        ass_reconfigure(priv);
+    }
+}
+
+void ass_set_font_scale(ass_renderer_t *priv, double font_scale)
+{
+    if (priv->settings.font_size_coeff != font_scale) {
+        priv->settings.font_size_coeff = font_scale;
+        ass_reconfigure(priv);
+    }
+}
+
+void ass_set_hinting(ass_renderer_t *priv, ass_hinting_t ht)
+{
+    if (priv->settings.hinting != ht) {
+        priv->settings.hinting = ht;
+        ass_reconfigure(priv);
+    }
+}
+
+void ass_set_line_spacing(ass_renderer_t *priv, double line_spacing)
+{
+    priv->settings.line_spacing = line_spacing;
+}
+
+void ass_set_fonts(ass_renderer_t *priv, const char *default_font,
+                   const char *default_family, int fc, const char *config,
+                   int update)
+{
+    free(priv->settings.default_font);
+    free(priv->settings.default_family);
+    priv->settings.default_font = default_font ? strdup(default_font) : 0;
+    priv->settings.default_family =
+        default_family ? strdup(default_family) : 0;
+
+    if (priv->fontconfig_priv)
+        fontconfig_done(priv->fontconfig_priv);
+    priv->fontconfig_priv =
+        fontconfig_init(priv->library, priv->ftlibrary, default_family,
+                        default_font, fc, config, update);
+}
+
+int ass_fonts_update(ass_renderer_t *render_priv)
+{
+    return fontconfig_update(render_priv->fontconfig_priv);
+}
+
+/**
+ * \brief Start a new frame
+ */
+static int
+ass_start_frame(ass_renderer_t *render_priv, ass_track_t *track,
+                long long now)
+{
+    ass_settings_t *settings_priv = &render_priv->settings;
+    cache_store_t *cache = &render_priv->cache;
+
+    if (!render_priv->settings.frame_width
+        && !render_priv->settings.frame_height)
+        return 1;               // library not initialized
+
+    if (render_priv->library != track->library)
+        return 1;
+
+    free_list_clear(render_priv);
+
+    if (track->n_events == 0)
+        return 1;               // nothing to do
+
+    render_priv->width = settings_priv->frame_width;
+    render_priv->height = settings_priv->frame_height;
+    render_priv->orig_width =
+        settings_priv->frame_width - settings_priv->left_margin -
+        settings_priv->right_margin;
+    render_priv->orig_height =
+        settings_priv->frame_height - settings_priv->top_margin -
+        settings_priv->bottom_margin;
+    render_priv->orig_width_nocrop =
+        settings_priv->frame_width - FFMAX(settings_priv->left_margin,
+                                           0) -
+        FFMAX(settings_priv->right_margin, 0);
+    render_priv->orig_height_nocrop =
+        settings_priv->frame_height - FFMAX(settings_priv->top_margin,
+                                            0) -
+        FFMAX(settings_priv->bottom_margin, 0);
+    render_priv->track = track;
+    render_priv->time = now;
+
+    ass_lazy_track_init(render_priv);
+
+    render_priv->font_scale = settings_priv->font_size_coeff *
+        render_priv->orig_height / render_priv->track->PlayResY;
+    if (render_priv->track->ScaledBorderAndShadow)
+        render_priv->border_scale =
+            ((double) render_priv->orig_height) /
+            render_priv->track->PlayResY;
+    else
+        render_priv->border_scale = 1.;
+
+    // PAR correction
+    render_priv->font_scale_x = render_priv->settings.aspect /
+                                render_priv->settings.pixel_ratio;
+
+    render_priv->prev_images_root = render_priv->images_root;
+    render_priv->images_root = 0;
+
+    if (cache->bitmap_cache->cache_size > cache->bitmap_max_size) {
+        ass_msg(render_priv->library, MSGL_V,
+                "Hitting hard bitmap cache limit (was: %ld bytes), "
+                "resetting.", (long) cache->bitmap_cache->cache_size);
+        cache->bitmap_cache = ass_bitmap_cache_reset(cache->bitmap_cache);
+        cache->composite_cache = ass_composite_cache_reset(
+            cache->composite_cache);
+        ass_free_images(render_priv->prev_images_root);
+        render_priv->prev_images_root = 0;
+    }
+
+    if (cache->glyph_cache->count > cache->glyph_max) {
+        ass_msg(render_priv->library, MSGL_V,
+            "Hitting hard glyph cache limit (was: %ld glyphs), resetting.",
+            (long) cache->glyph_cache->count);
+        cache->glyph_cache = ass_glyph_cache_reset(cache->glyph_cache);
+    }
+
+    return 0;
+}
+
+static int cmp_event_layer(const void *p1, const void *p2)
+{
+    ass_event_t *e1 = ((event_images_t *) p1)->event;
+    ass_event_t *e2 = ((event_images_t *) p2)->event;
+    if (e1->Layer < e2->Layer)
+        return -1;
+    if (e1->Layer > e2->Layer)
+        return 1;
+    if (e1->ReadOrder < e2->ReadOrder)
+        return -1;
+    if (e1->ReadOrder > e2->ReadOrder)
+        return 1;
+    return 0;
+}
+
+#define MAX_EVENTS 100
+
+static render_priv_t *get_render_priv(ass_renderer_t *render_priv,
+                                      ass_event_t *event)
+{
+    if (!event->render_priv)
+        event->render_priv = calloc(1, sizeof(render_priv_t));
+    // FIXME: check render_id
+    if (render_priv->render_id != event->render_priv->render_id) {
+        memset(event->render_priv, 0, sizeof(render_priv_t));
+        event->render_priv->render_id = render_priv->render_id;
+    }
+    return event->render_priv;
+}
+
+typedef struct {
+    int a, b;                   // top and height
+} segment_t;
+
+static int overlap(segment_t *s1, segment_t *s2)
+{
+    if (s1->a >= s2->b || s2->a >= s1->b)
+        return 0;
+    return 1;
+}
+
+static int cmp_segment(const void *p1, const void *p2)
+{
+    return ((segment_t *) p1)->a - ((segment_t *) p2)->a;
+}
+
+static void
+shift_event(ass_renderer_t *render_priv, event_images_t *ei, int shift)
+{
+    ass_image_t *cur = ei->imgs;
+    while (cur) {
+        cur->dst_y += shift;
+        // clip top and bottom
+        if (cur->dst_y < 0) {
+            int clip = -cur->dst_y;
+            cur->h -= clip;
+            cur->bitmap += clip * cur->stride;
+            cur->dst_y = 0;
+        }
+        if (cur->dst_y + cur->h >= render_priv->height) {
+            int clip = cur->dst_y + cur->h - render_priv->height;
+            cur->h -= clip;
+        }
+        if (cur->h <= 0) {
+            cur->h = 0;
+            cur->dst_y = 0;
+        }
+        cur = cur->next;
+    }
+    ei->top += shift;
+}
+
+// dir: 1 - move down
+//      -1 - move up
+static int fit_segment(segment_t *s, segment_t *fixed, int *cnt, int dir)
+{
+    int i;
+    int shift = 0;
+
+    if (dir == 1)               // move down
+        for (i = 0; i < *cnt; ++i) {
+            if (s->b + shift <= fixed[i].a || s->a + shift >= fixed[i].b)
+                continue;
+            shift = fixed[i].b - s->a;
+    } else                      // dir == -1, move up
+        for (i = *cnt - 1; i >= 0; --i) {
+            if (s->b + shift <= fixed[i].a || s->a + shift >= fixed[i].b)
+                continue;
+            shift = fixed[i].a - s->b;
+        }
+
+    fixed[*cnt].a = s->a + shift;
+    fixed[*cnt].b = s->b + shift;
+    (*cnt)++;
+    qsort(fixed, *cnt, sizeof(segment_t), cmp_segment);
+
+    return shift;
+}
+
+static void
+fix_collisions(ass_renderer_t *render_priv, event_images_t *imgs, int cnt)
+{
+    segment_t used[MAX_EVENTS];
+    int cnt_used = 0;
+    int i, j;
+
+    // fill used[] with fixed events
+    for (i = 0; i < cnt; ++i) {
+        render_priv_t *priv;
+        if (!imgs[i].detect_collisions)
+            continue;
+        priv = get_render_priv(render_priv, imgs[i].event);
+        if (priv->height > 0) { // it's a fixed event
+            segment_t s;
+            s.a = priv->top;
+            s.b = priv->top + priv->height;
+            if (priv->height != imgs[i].height) {       // no, it's not
+                ass_msg(render_priv->library, MSGL_WARN,
+                        "Warning! Event height has changed");
+                priv->top = 0;
+                priv->height = 0;
+            }
+            for (j = 0; j < cnt_used; ++j)
+                if (overlap(&s, used + j)) {    // no, it's not
+                    priv->top = 0;
+                    priv->height = 0;
+                }
+            if (priv->height > 0) {     // still a fixed event
+                used[cnt_used].a = priv->top;
+                used[cnt_used].b = priv->top + priv->height;
+                cnt_used++;
+                shift_event(render_priv, imgs + i, priv->top - imgs[i].top);
+            }
+        }
+    }
+    qsort(used, cnt_used, sizeof(segment_t), cmp_segment);
+
+    // try to fit other events in free spaces
+    for (i = 0; i < cnt; ++i) {
+        render_priv_t *priv;
+        if (!imgs[i].detect_collisions)
+            continue;
+        priv = get_render_priv(render_priv, imgs[i].event);
+        if (priv->height == 0) {        // not a fixed event
+            int shift;
+            segment_t s;
+            s.a = imgs[i].top;
+            s.b = imgs[i].top + imgs[i].height;
+            shift =
+                fit_segment(&s, used, &cnt_used, imgs[i].shift_direction);
+            if (shift)
+                shift_event(render_priv, imgs + i, shift);
+            // make it fixed
+            priv->top = imgs[i].top;
+            priv->height = imgs[i].height;
+        }
+
+    }
+}
+
+/**
+ * \brief compare two images
+ * \param i1 first image
+ * \param i2 second image
+ * \return 0 if identical, 1 if different positions, 2 if different content
+ */
+static int ass_image_compare(ass_image_t *i1, ass_image_t *i2)
+{
+    if (i1->w != i2->w)
+        return 2;
+    if (i1->h != i2->h)
+        return 2;
+    if (i1->stride != i2->stride)
+        return 2;
+    if (i1->color != i2->color)
+        return 2;
+    if (i1->bitmap != i2->bitmap)
+        return 2;
+    if (i1->dst_x != i2->dst_x)
+        return 1;
+    if (i1->dst_y != i2->dst_y)
+        return 1;
+    return 0;
+}
+
+/**
+ * \brief compare current and previous image list
+ * \param priv library handle
+ * \return 0 if identical, 1 if different positions, 2 if different content
+ */
+static int ass_detect_change(ass_renderer_t *priv)
+{
+    ass_image_t *img, *img2;
+    int diff;
+
+    img = priv->prev_images_root;
+    img2 = priv->images_root;
+    diff = 0;
+    while (img && diff < 2) {
+        ass_image_t *next, *next2;
+        next = img->next;
+        if (img2) {
+            int d = ass_image_compare(img, img2);
+            if (d > diff)
+                diff = d;
+            next2 = img2->next;
+        } else {
+            // previous list is shorter
+            diff = 2;
+            break;
+        }
+        img = next;
+        img2 = next2;
+    }
+
+    // is the previous list longer?
+    if (img2)
+        diff = 2;
+
+    return diff;
+}
+
+/**
+ * \brief render a frame
+ * \param priv library handle
+ * \param track track
+ * \param now current video timestamp (ms)
+ * \param detect_change a value describing how the new images differ from the previous ones will be written here:
+ *        0 if identical, 1 if different positions, 2 if different content.
+ *        Can be NULL, in that case no detection is performed.
+ */
+ass_image_t *ass_render_frame(ass_renderer_t *priv, ass_track_t *track,
+                              long long now, int *detect_change)
+{
+    int i, cnt, rc;
+    event_images_t *last;
+    ass_image_t **tail;
+
+    // init frame
+    rc = ass_start_frame(priv, track, now);
+    if (rc != 0)
+        return 0;
+
+    // render events separately
+    cnt = 0;
+    for (i = 0; i < track->n_events; ++i) {
+        ass_event_t *event = track->events + i;
+        if ((event->Start <= now)
+            && (now < (event->Start + event->Duration))) {
+            if (cnt >= priv->eimg_size) {
+                priv->eimg_size += 100;
+                priv->eimg =
+                    realloc(priv->eimg,
+                            priv->eimg_size * sizeof(event_images_t));
+            }
+            rc = ass_render_event(priv, event, priv->eimg + cnt);
+            if (!rc)
+                ++cnt;
+        }
+    }
+
+    // sort by layer
+    qsort(priv->eimg, cnt, sizeof(event_images_t), cmp_event_layer);
+
+    // call fix_collisions for each group of events with the same layer
+    last = priv->eimg;
+    for (i = 1; i < cnt; ++i)
+        if (last->event->Layer != priv->eimg[i].event->Layer) {
+            fix_collisions(priv, last, priv->eimg + i - last);
+            last = priv->eimg + i;
+        }
+    if (cnt > 0)
+        fix_collisions(priv, last, priv->eimg + cnt - last);
+
+    // concat lists
+    tail = &priv->images_root;
+    for (i = 0; i < cnt; ++i) {
+        ass_image_t *cur = priv->eimg[i].imgs;
+        while (cur) {
+            *tail = cur;
+            tail = &cur->next;
+            cur = cur->next;
+        }
+    }
+
+    if (detect_change)
+        *detect_change = ass_detect_change(priv);
+
+    // free the previous image list
+    ass_free_images(priv->prev_images_root);
+    priv->prev_images_root = 0;
+
+    return priv->images_root;
+}

Added: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_types.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_types.h	2009-07-31 22:24:31 UTC (rev 5184)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_types.h	2009-08-01 07:55:22 UTC (rev 5185)
@@ -0,0 +1,125 @@
+/*
+ * Copyright (C) 2006 Evgeniy Stepanov <eugeni.stepanov at gmail.com>
+ *
+ * This file is part of libass.
+ *
+ * libass is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * libass is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with libass; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#ifndef LIBASS_TYPES_H
+#define LIBASS_TYPES_H
+
+#include <stdint.h>
+
+#define VALIGN_SUB 0
+#define VALIGN_CENTER 8
+#define VALIGN_TOP 4
+#define HALIGN_LEFT 1
+#define HALIGN_CENTER 2
+#define HALIGN_RIGHT 3
+
+/* Opaque objects internally used by libass.  Contents are private. */
+typedef struct ass_renderer ass_renderer_t;
+typedef struct render_priv render_priv_t;
+typedef struct parser_priv parser_priv_t;
+typedef struct ass_library ass_library_t;
+
+/* ASS Style: line */
+typedef struct ass_style {
+    char *Name;
+    char *FontName;
+    double FontSize;
+    uint32_t PrimaryColour;
+    uint32_t SecondaryColour;
+    uint32_t OutlineColour;
+    uint32_t BackColour;
+    int Bold;
+    int Italic;
+    int Underline;
+    int StrikeOut;
+    double ScaleX;
+    double ScaleY;
+    double Spacing;
+    int Angle;
+    int BorderStyle;
+    double Outline;
+    double Shadow;
+    int Alignment;
+    int MarginL;
+    int MarginR;
+    int MarginV;
+    int Encoding;
+    int treat_fontname_as_pattern;
+} ass_style_t;
+
+/*
+ * ass_event_t corresponds to a single Dialogue line;
+ * text is stored as-is, style overrides will be parsed later.
+ */
+typedef struct ass_event {
+    long long Start;            // ms
+    long long Duration;         // ms
+
+    int ReadOrder;
+    int Layer;
+    int Style;
+    char *Name;
+    int MarginL;
+    int MarginR;
+    int MarginV;
+    char *Effect;
+    char *Text;
+
+    render_priv_t *render_priv;
+} ass_event_t;
+
+/*
+ * ass track represent either an external script or a matroska subtitle stream
+ * (no real difference between them); it can be used in rendering after the
+ * headers are parsed (i.e. events format line read).
+ */
+typedef struct ass_track {
+    int n_styles;           // amount used
+    int max_styles;         // amount allocated
+    int n_events;
+    int max_events;
+    ass_style_t *styles;    // array of styles, max_styles length, n_styles used
+    ass_event_t *events;    // the same as styles
+
+    char *style_format;     // style format line (everything after "Format: ")
+    char *event_format;     // event format line
+
+    enum {
+        TRACK_TYPE_UNKNOWN = 0,
+        TRACK_TYPE_ASS,
+        TRACK_TYPE_SSA
+    } track_type;
+
+    // Script header fields
+    int PlayResX;
+    int PlayResY;
+    double Timer;
+    int WrapStyle;
+    char ScaledBorderAndShadow;
+
+
+    int default_style;      // index of default style
+    char *name;             // file name in case of external subs, 0 for streams
+
+    ass_library_t *library;
+    parser_priv_t *parser_priv;
+} ass_track_t;
+
+#endif /* LIBASS_TYPES_H */

Added: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_utils.c
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_utils.c	2009-07-31 22:24:31 UTC (rev 5184)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_utils.c	2009-08-01 07:55:22 UTC (rev 5185)
@@ -0,0 +1,206 @@
+/*
+ * Copyright (C) 2006 Evgeniy Stepanov <eugeni.stepanov at gmail.com>
+ *
+ * This file is part of libass.
+ *
+ * libass is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * libass is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with libass; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#include "config.h"
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <inttypes.h>
+#include <ft2build.h>
+#include FT_GLYPH_H
+
+#include "ass_library.h"
+#include "ass.h"
+#include "ass_utils.h"
+
+int mystrtoi(char **p, int *res)
+{
+    double temp_res;
+    char *start = *p;
+    temp_res = strtod(*p, p);
+    *res = (int) (temp_res + (temp_res > 0 ? 0.5 : -0.5));
+    if (*p != start)
+        return 1;
+    else
+        return 0;
+}
+
+int mystrtoll(char **p, long long *res)
+{
+    double temp_res;
+    char *start = *p;
+    temp_res = strtod(*p, p);
+    *res = (int) (temp_res + (temp_res > 0 ? 0.5 : -0.5));
+    if (*p != start)
+        return 1;
+    else
+        return 0;
+}
+
+int mystrtou32(char **p, int base, uint32_t *res)
+{
+    char *start = *p;
+    *res = strtoll(*p, p, base);
+    if (*p != start)
+        return 1;
+    else
+        return 0;
+}
+
+int mystrtod(char **p, double *res)
+{
+    char *start = *p;
+    *res = strtod(*p, p);
+    if (*p != start)
+        return 1;
+    else
+        return 0;
+}
+
+int strtocolor(ass_library_t *library, char **q, uint32_t *res)
+{
+    uint32_t color = 0;
+    int result;
+    char *p = *q;
+
+    if (*p == '&')
+        ++p;
+    else
+        ass_msg(library, MSGL_DBG2, "suspicious color format: \"%s\"\n", p);
+
+    if (*p == 'H' || *p == 'h') {
+        ++p;
+        result = mystrtou32(&p, 16, &color);
+    } else {
+        result = mystrtou32(&p, 0, &color);
+    }
+
+    {
+        unsigned char *tmp = (unsigned char *) (&color);
+        unsigned char b;
+        b = tmp[0];
+        tmp[0] = tmp[3];
+        tmp[3] = b;
+        b = tmp[1];
+        tmp[1] = tmp[2];
+        tmp[2] = b;
+    }
+    if (*p == '&')
+        ++p;
+    *q = p;
+
+    *res = color;
+    return result;
+}
+
+// Return a boolean value for a string
+char parse_bool(char *str)
+{
+    while (*str == ' ' || *str == '\t')
+        str++;
+    if (!strncasecmp(str, "yes", 3))
+        return 1;
+    else if (strtol(str, NULL, 10) > 0)
+        return 1;
+    return 0;
+}
+
+void ass_msg(ass_library_t *priv, int lvl, char *fmt, ...)
+{
+    va_list va;
+    va_start(va, fmt);
+    priv->msg_callback(lvl, fmt, va, priv->msg_callback_data);
+    va_end(va);
+}
+
+unsigned ass_utf8_get_char(char **str)
+{
+    uint8_t *strp = (uint8_t *) * str;
+    unsigned c = *strp++;
+    unsigned mask = 0x80;
+    int len = -1;
+    while (c & mask) {
+        mask >>= 1;
+        len++;
+    }
+    if (len <= 0 || len > 4)
+        goto no_utf8;
+    c &= mask - 1;
+    while ((*strp & 0xc0) == 0x80) {
+        if (len-- <= 0)
+            goto no_utf8;
+        c = (c << 6) | (*strp++ & 0x3f);
+    }
+    if (len)
+        goto no_utf8;
+    *str = (char *) strp;
+    return c;
+
+  no_utf8:
+    strp = (uint8_t *) * str;
+    c = *strp++;
+    *str = (char *) strp;
+    return c;
+}
+
+#ifdef CONFIG_ENCA
+void *ass_guess_buffer_cp(ass_library_t *library, unsigned char *buffer,
+                          int buflen, char *preferred_language,
+                          char *fallback)
+{
+    const char **languages;
+    size_t langcnt;
+    EncaAnalyser analyser;
+    EncaEncoding encoding;
+    char *detected_sub_cp = NULL;
+    int i;
+
+    languages = enca_get_languages(&langcnt);
+    ass_msg(library, MSGL_V, "ENCA supported languages");
+    for (i = 0; i < langcnt; i++) {
+        ass_msg(library, MSGL_V, "lang %s", languages[i]);
+    }
+
+    for (i = 0; i < langcnt; i++) {
+        const char *tmp;
+
+        if (strcasecmp(languages[i], preferred_language) != 0)
+            continue;
+        analyser = enca_analyser_alloc(languages[i]);
+        encoding = enca_analyse_const(analyser, buffer, buflen);
+        tmp = enca_charset_name(encoding.charset, ENCA_NAME_STYLE_ICONV);
+        if (tmp && encoding.charset != ENCA_CS_UNKNOWN) {
+            detected_sub_cp = strdup(tmp);
+            ass_msg(library, MSGL_INFO, "ENCA detected charset: %s", tmp);
+        }
+        enca_analyser_free(analyser);
+    }
+
+    free(languages);
+
+    if (!detected_sub_cp) {
+        detected_sub_cp = strdup(fallback);
+        ass_msg(library, MSGL_INFO,
+               "ENCA detection failed: fallback to %s", fallback);
+    }
+
+    return detected_sub_cp;
+}
+#endif

Added: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_utils.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_utils.h	2009-07-31 22:24:31 UTC (rev 5184)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/ass_utils.h	2009-08-01 07:55:22 UTC (rev 5185)
@@ -0,0 +1,129 @@
+/*
+ * Copyright (C) 2006 Evgeniy Stepanov <eugeni.stepanov at gmail.com>
+ *
+ * This file is part of libass.
+ *
+ * libass is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * libass is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with libass; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ */
+
+#ifndef LIBASS_UTILS_H
+#define LIBASS_UTILS_H
+
+#include <stdio.h>
+#include <stdarg.h>
+#include <stdint.h>
+#include <stdlib.h>
+#include <string.h>
+#include <assert.h>
+
+#ifdef CONFIG_ENCA
+#include <enca.h>
+#endif
+
+#include "ass.h"
+
+#define MSGL_FATAL 0
+#define MSGL_ERR 1
+#define MSGL_WARN 2
+#define MSGL_INFO 4
+#define MSGL_V 6
+#define MSGL_DBG2 7
+
+#define FFMAX(a,b) ((a) > (b) ? (a) : (b))
+#define FFMIN(a,b) ((a) > (b) ? (b) : (a))
+#define FFMINMAX(c,a,b) FFMIN(FFMAX(c, a), b)
+
+int mystrtoi(char **p, int *res);
+int mystrtoll(char **p, long long *res);
+int mystrtou32(char **p, int base, uint32_t *res);
+int mystrtod(char **p, double *res);
+int strtocolor(ass_library_t *library, char **q, uint32_t *res);
+char parse_bool(char *str);
+unsigned ass_utf8_get_char(char **str);
+void ass_msg(ass_library_t *priv, int lvl, char *fmt, ...);
+#ifdef CONFIG_ENCA
+void *ass_guess_buffer_cp(ass_library_t *library, unsigned char *buffer,
+                          int buflen, char *preferred_language,
+                          char *fallback);
+#endif
+
+static inline int d6_to_int(int x)
+{
+    return (x + 32) >> 6;
+}
+static inline int d16_to_int(int x)
+{
+    return (x + 32768) >> 16;
+}
+static inline int int_to_d6(int x)
+{
+    return x << 6;
+}
+static inline int int_to_d16(int x)
+{
+    return x << 16;
+}
+static inline int d16_to_d6(int x)
+{
+    return (x + 512) >> 10;
+}
+static inline int d6_to_d16(int x)
+{
+    return x << 10;
+}
+static inline double d6_to_double(int x)
+{
+    return x / 64.;
+}
+static inline int double_to_d6(double x)
+{
+    return (int) (x * 64);
+}
+static inline double d16_to_double(int x)
+{
+    return ((double) x) / 0x10000;
+}
+static inline int double_to_d16(double x)
+{
+    return (int) (x * 0x10000);
+}
+
+#define FNV1_32A_INIT (unsigned)0x811c9dc5
+
+static inline unsigned fnv_32a_buf(void *buf, size_t len, unsigned hval)
+{
+    unsigned char *bp = buf;
+    unsigned char *be = bp + len;
+    while (bp < be) {
+        hval ^= (unsigned) *bp++;
+        hval +=
+            (hval << 1) + (hval << 4) + (hval << 7) + (hval << 8) +
+            (hval << 24);
+    }
+    return hval;
+}
+static inline unsigned fnv_32a_str(char *str, unsigned hval)
+{
+    unsigned char *s = (unsigned char *) str;
+    while (*s) {
+        hval ^= (unsigned) *s++;
+        hval +=
+            (hval << 1) + (hval << 4) + (hval << 7) + (hval << 8) +
+            (hval << 24);
+    }
+    return hval;
+}
+
+#endif                          /* LIBASS_UTILS_H */

Added: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/config.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/config.h	2009-07-31 22:24:31 UTC (rev 5184)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/config.h	2009-08-01 07:55:22 UTC (rev 5185)
@@ -0,0 +1 @@
+#include "ADM_coreConfig.h"

Added: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/libass.sym
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/libass.sym	2009-07-31 22:24:31 UTC (rev 5184)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/libass.sym	2009-08-01 07:55:22 UTC (rev 5185)
@@ -0,0 +1,35 @@
+ass_library_init
+ass_library_done
+ass_set_fonts_dir
+ass_set_extract_fonts
+ass_set_style_overrides
+ass_renderer_init
+ass_renderer_done
+ass_set_frame_size
+ass_set_margins
+ass_set_use_margins
+ass_set_aspect_ratio
+ass_set_font_scale
+ass_set_hinting
+ass_set_line_spacing
+ass_set_fonts
+ass_render_frame
+ass_new_track
+ass_free_track
+ass_alloc_style
+ass_alloc_event
+ass_free_style
+ass_free_event
+ass_process_data
+ass_process_codec_private
+ass_process_chunk
+ass_read_file
+ass_read_memory
+ass_read_styles
+ass_add_font
+ass_clear_fonts
+ass_step_sub
+ass_process_force_style
+ass_set_message_cb
+ass_fonts_update
+ass_set_cache_limits

Added: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/readme
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/readme	2009-07-31 22:24:31 UTC (rev 5184)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libAss/readme	2009-08-01 07:55:22 UTC (rev 5185)
@@ -0,0 +1,2 @@
+checkout http://repo.or.cz/w/libass.git
+done august first 8h36 AM, paris time, last commit      Do not round karaoke timing coordinates  

Deleted: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/CMakeLists.txt	2009-07-31 22:24:31 UTC (rev 5184)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/CMakeLists.txt	2009-08-01 07:55:22 UTC (rev 5185)
@@ -1,19 +0,0 @@
-INCLUDE(admCheckFontConfig)
-checkFontConfig()
-
-SET(ADM_LIB ADM_libass)
-
-SET(${ADM_LIB}_SRCS 
-ass_bitmap.c  ass.c  ass_cache.c  ass_fontconfig.c  ass_library.c   ass_render.c  ass_utils.c  mputils.c
-ass_font.c)
-
-ADD_LIBRARY(${ADM_LIB} STATIC ${${ADM_LIB}_SRCS})
-ADD_DEFINITIONS(${FREETYPE2_CFLAGS} "-I${LIBICONV_INCLUDE_DIR}")
-
-IF (FONTCONFIG_FOUND)
-	ADD_DEFINITIONS(${FONTCONFIG_CFLAGS} "-DHAVE_FONTCONFIG=1")
-ENDIF (FONTCONFIG_FOUND)
-
-IF (UNIX)
-	ADD_TARGET_CFLAGS(${ADM_LIB} -fPIC)
-ENDIF (UNIX)
\ No newline at end of file

Deleted: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/ass.c
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/ass.c	2009-07-31 22:24:31 UTC (rev 5184)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/ass.c	2009-08-01 07:55:22 UTC (rev 5185)
@@ -1,1092 +0,0 @@
-// -*- c-basic-offset: 8; indent-tabs-mode: t -*-
-// vim:ts=8:sw=8:noet:ai:
-/*
-  Copyright (C) 2006 Evgeniy Stepanov <eugeni.stepanov at gmail.com>
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation; either version 2 of the License, or
-  (at your option) any later version.
-
-  This program is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with this program; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
-*/
-
-//#include "config.h"
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <assert.h>
-#include <errno.h>
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <unistd.h>
-#include <inttypes.h>
-
-#ifdef USE_ICONV
-#include <iconv.h>
-#endif
-
-#include "ass.h"
-#include "ass_utils.h"
-#include "ass_library.h"
-#include "mputils.h"
-
-typedef enum {PST_UNKNOWN = 0, PST_INFO, PST_STYLES, PST_EVENTS, PST_FONTS} parser_state_t;
-
-struct parser_priv_s {
-	parser_state_t state;
-	char* fontname;
-	char* fontdata;
-	int fontdata_size;
-	int fontdata_used;
-};
-
-#define ASS_STYLES_ALLOC 20
-#define ASS_EVENTS_ALLOC 200
-
-void ass_free_track(ass_track_t* track) {
-	int i;
-	
-	if (track->parser_priv) {
-		if (track->parser_priv->fontname)
-			free(track->parser_priv->fontname);
-		if (track->parser_priv->fontdata)
-			free(track->parser_priv->fontdata);
-		free(track->parser_priv);
-	}
-	if (track->style_format)
-		free(track->style_format);
-	if (track->event_format)
-		free(track->event_format);
-	if (track->styles) {
-		for (i = 0; i < track->n_styles; ++i)
-			ass_free_style(track, i);
-		free(track->styles);
-	}
-	if (track->events) {
-		for (i = 0; i < track->n_events; ++i)
-			ass_free_event(track, i);
-		free(track->events);
-	}
-}
-
-/// \brief Allocate a new style struct
-/// \param track track
-/// \return style id
-int ass_alloc_style(ass_track_t* track) {
-	int sid;
-	
-	assert(track->n_styles <= track->max_styles);
-
-	if (track->n_styles == track->max_styles) {
-		track->max_styles += ASS_STYLES_ALLOC;
-		track->styles = (ass_style_t*)realloc(track->styles, sizeof(ass_style_t)*track->max_styles);
-	}
-	
-	sid = track->n_styles++;
-	memset(track->styles + sid, 0, sizeof(ass_style_t));
-	return sid;
-}
-
-/// \brief Allocate a new event struct
-/// \param track track
-/// \return event id
-int ass_alloc_event(ass_track_t* track) {
-	int eid;
-	
-	assert(track->n_events <= track->max_events);
-
-	if (track->n_events == track->max_events) {
-		track->max_events += ASS_EVENTS_ALLOC;
-		track->events = (ass_event_t*)realloc(track->events, sizeof(ass_event_t)*track->max_events);
-	}
-	
-	eid = track->n_events++;
-	memset(track->events + eid, 0, sizeof(ass_event_t));
-	return eid;
-}
-
-void ass_free_event(ass_track_t* track, int eid) {
-	ass_event_t* event = track->events + eid;
-	if (event->Name)
-		free(event->Name);
-	if (event->Effect)
-		free(event->Effect);
-	if (event->Text)
-		free(event->Text);
-	if (event->render_priv)
-		free(event->render_priv);
-}
-
-void ass_free_style(ass_track_t* track, int sid) {
-	ass_style_t* style = track->styles + sid;
-	if (style->Name)
-		free(style->Name);
-	if (style->FontName)
-		free(style->FontName);
-}
-
-// ==============================================================================================
-
-static void skip_spaces(char** str) {
-	char* p = *str;
-	while ((*p==' ') || (*p=='\t'))
-		++p;
-	*str = p;
-}
-
-static void rskip_spaces(char** str, char* limit) {
-	char* p = *str;
-	while ((p >= limit) && ((*p==' ') || (*p=='\t')))
-		--p;
-	*str = p;
-}
-
-/**
- * \brief find style by name
- * \param track track
- * \param name style name
- * \return index in track->styles
- * Returnes 0 if no styles found => expects at least 1 style.
- * Parsing code always adds "Default" style in the end.
- */
-static int lookup_style(ass_track_t* track, char* name) {
-	int i;
-	if (*name == '*') ++name; // FIXME: what does '*' really mean ?
-	for (i=0; i<track->n_styles; ++i) {
-		// FIXME: mb strcasecmp ?
-		if (strcmp(track->styles[i].Name, name) == 0)
-			return i;
-	}
-	i = track->default_style;
-	mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_NoStyleNamedXFoundUsingY, track, name, track->styles[i].Name);
-	return i; // use the first style
-}
-
-static uint32_t string2color(char* p) {
-	uint32_t tmp;
-	(void)strtocolor(&p, &tmp);
-	return tmp;
-}
-
-static long long string2timecode(char* p) {
-	unsigned h, m, s, ms;
-	long long tm;
-	int res = sscanf(p, "%1d:%2d:%2d.%2d", &h, &m, &s, &ms);
-	if (res < 4) {
-		mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_BadTimestamp);
-		return 0;
-	}
-	tm = ((h * 60 + m) * 60 + s) * 1000 + ms * 10;
-	return tm;
-}
-
-/**
- * \brief converts numpad-style align to align.
- */
-static int numpad2align(int val) {
-	int res, v;
-	v = (val - 1) / 3; // 0, 1 or 2 for vertical alignment
-	if (v != 0) v = 3 - v;
-	res = ((val - 1) % 3) + 1; // horizontal alignment
-	res += v*4;
-	return res;
-}
-
-#define NEXT(str,token) \
-	token = next_token(&str); \
-	if (!token) break;
-
-#define ANYVAL(name,func) \
-	} else if (strcasecmp(tname, #name) == 0) { \
-		target->name = func(token); \
-		mp_msg(MSGT_ASS, MSGL_DBG2, "%s = %s\n", #name, token);
-
-#define STRVAL(name) \
-	} else if (strcasecmp(tname, #name) == 0) { \
-		if (target->name != NULL) free(target->name); \
-		target->name = strdup(token); \
-		mp_msg(MSGT_ASS, MSGL_DBG2, "%s = %s\n", #name, token);
-		
-#define COLORVAL(name) ANYVAL(name,string2color)
-#define INTVAL(name) ANYVAL(name,atoi)
-#define FPVAL(name) ANYVAL(name,atof)
-#define TIMEVAL(name) ANYVAL(name,string2timecode)
-#define STYLEVAL(name) \
-	} else if (strcasecmp(tname, #name) == 0) { \
-		target->name = lookup_style(track, token); \
-		mp_msg(MSGT_ASS, MSGL_DBG2, "%s = %s\n", #name, token);
-
-#define ALIAS(alias,name) \
-	if (strcasecmp(tname, #alias) == 0) {tname = #name;}
-
-static char* next_token(char** str) {
-	char* p = *str;
-	char* start;
-	skip_spaces(&p);
-	if (*p == '\0') {
-		*str = p;
-		return 0;
-	}
-	start = p; // start of the token
-	for (; (*p != '\0') && (*p != ','); ++p) {}
-	if (*p == '\0') {
-		*str = p; // eos found, str will point to '\0' at exit
-	} else {
-		*p = '\0';
-		*str = p + 1; // ',' found, str will point to the next char (beginning of the next token)
-	}
-	--p; // end of current token
-	rskip_spaces(&p, start);
-	if (p < start)
-		p = start; // empty token
-	else
-		++p; // the first space character, or '\0'
-	*p = '\0';
-	return start;
-}
-/**
- * \brief Parse the tail of Dialogue line
- * \param track track
- * \param event parsed data goes here
- * \param str string to parse, zero-terminated
- * \param n_ignored number of format options to skip at the beginning
-*/ 
-static int process_event_tail(ass_track_t* track, ass_event_t* event, char* str, int n_ignored)
-{
-	char* token;
-	char* tname;
-	char* p = str;
-	int i;
-	ass_event_t* target = event;
-
-	char* format = strdup(track->event_format);
-	char* q = format; // format scanning pointer
-
-	if (track->n_styles == 0) {
-		// add "Default" style to the end
-		// will be used if track does not contain a default style (or even does not contain styles at all)
-		int sid = ass_alloc_style(track);
-		track->styles[sid].Name = strdup("Default");
-		track->styles[sid].FontName = strdup("Arial");
-	}
-
-	for (i = 0; i < n_ignored; ++i) {
-		NEXT(q, tname);
-	}
-
-	while (1) {
-		NEXT(q, tname);
-		if (strcasecmp(tname, "Text") == 0) {
-			char* last;
-			event->Text = strdup(p);
-			if (*event->Text != 0) {
-				last = event->Text + strlen(event->Text) - 1;
-				if (last >= event->Text && *last == '\r')
-					*last = 0;
-			}
-			mp_msg(MSGT_ASS, MSGL_DBG2, "Text = %s\n", event->Text);
-			event->Duration -= event->Start;
-			free(format);
-			return 0; // "Text" is always the last
-		}
-		NEXT(p, token);
-
-		ALIAS(End,Duration) // temporarily store end timecode in event->Duration
-		if (0) { // cool ;)
-			INTVAL(Layer)
-			STYLEVAL(Style)
-			STRVAL(Name)
-			STRVAL(Effect)
-			INTVAL(MarginL)
-			INTVAL(MarginR)
-			INTVAL(MarginV)
-			TIMEVAL(Start)
-			TIMEVAL(Duration)
-		}
-	}
-	free(format);
-	return 1;
-}
-
-/**
- * \brief Parse command line style overrides (--ass-force-style option)
- * \param track track to apply overrides to
- * The format for overrides is [StyleName.]Field=Value
- */
-void process_force_style(ass_track_t* track) {
-	char **fs, *eq, *dt, *style, *tname, *token;
-	ass_style_t* target;
-	int sid;
-	char** list = track->library->style_overrides;
-	
-	if (!list) return;
-	
-	for (fs = list; *fs; ++fs) {
-		eq = strrchr(*fs, '=');
-		if (!eq)
-			continue;
-		*eq = '\0';
-		token = eq + 1;
-
-		dt = strrchr(*fs, '.');
-		if (dt) {
-			*dt = '\0';
-			style = *fs;
-			tname = dt + 1;
-		} else {
-			style = NULL;
-			tname = *fs;
-		}
-		for (sid = 0; sid < track->n_styles; ++sid) {
-			if (style == NULL || strcasecmp(track->styles[sid].Name, style) == 0) {
-				target = track->styles + sid;
-				if (0) {
-					STRVAL(FontName)
-					COLORVAL(PrimaryColour)
-					COLORVAL(SecondaryColour)
-					COLORVAL(OutlineColour)
-					COLORVAL(BackColour)
-					FPVAL(FontSize)
-					INTVAL(Bold)
-					INTVAL(Italic)
-					INTVAL(Underline)
-					INTVAL(StrikeOut)
-					FPVAL(Spacing)
-					INTVAL(Angle)
-					INTVAL(BorderStyle)
-					INTVAL(Alignment)
-					INTVAL(MarginL)
-					INTVAL(MarginR)
-					INTVAL(MarginV)
-					INTVAL(Encoding)
-					FPVAL(ScaleX)
-					FPVAL(ScaleY)
-					FPVAL(Outline)
-					FPVAL(Shadow)
-				}
-			}
-		}
-		*eq = '=';
-		if (dt) *dt = '.';
-	}
-}
-
-/**
- * \brief Parse the Style line
- * \param track track
- * \param str string to parse, zero-terminated
- * Allocates a new style struct.
-*/ 
-static int process_style(ass_track_t* track, char *str)
-{
-
-	char* token;
-	char* tname;
-	char* p = str;
-	char* format;
-	char* q; // format scanning pointer
-	int sid;
-	ass_style_t* style;
-	ass_style_t* target;
-
-	if (!track->style_format) {
-		// no style format header
-		// probably an ancient script version
-		if (track->track_type == TRACK_TYPE_SSA)
-			track->style_format = strdup("Name, Fontname, Fontsize, PrimaryColour, SecondaryColour,"
-					"TertiaryColour, BackColour, Bold, Italic, BorderStyle, Outline,"
-					"Shadow, Alignment, MarginL, MarginR, MarginV, AlphaLevel, Encoding");
-		else
-			track->style_format = strdup("Name, Fontname, Fontsize, PrimaryColour, SecondaryColour,"
-					"OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut,"
-					"ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow,"
-					"Alignment, MarginL, MarginR, MarginV, Encoding");
-	}
-
-	q = format = strdup(track->style_format);
-	
-	mp_msg(MSGT_ASS, MSGL_V, "[%p] Style: %s\n", track, str);
-	
-	sid = ass_alloc_style(track);
-
-	style = track->styles + sid;
-	target = style;
-// fill style with some default values
-	style->ScaleX = 100.;
-	style->ScaleY = 100.;
-	
-	while (1) {
-		NEXT(q, tname);
-		NEXT(p, token);
-		
-//		ALIAS(TertiaryColour,OutlineColour) // ignore TertiaryColour; it appears only in SSA, and is overridden by BackColour
-			
-		if (0) { // cool ;)
-			STRVAL(Name)
-				if ((strcmp(target->Name, "Default")==0) || (strcmp(target->Name, "*Default")==0))
-					track->default_style = sid;
-			STRVAL(FontName)
-			COLORVAL(PrimaryColour)
-			COLORVAL(SecondaryColour)
-			COLORVAL(OutlineColour) // TertiaryColor
-			COLORVAL(BackColour)
-				// SSA uses BackColour for both outline and shadow
-				// this will destroy SSA's TertiaryColour, but i'm not going to use it anyway
-				if (track->track_type == TRACK_TYPE_SSA)
-					target->OutlineColour = target->BackColour;
-			FPVAL(FontSize)
-			INTVAL(Bold)
-			INTVAL(Italic)
-			INTVAL(Underline)
-			INTVAL(StrikeOut)
-			FPVAL(Spacing)
-			INTVAL(Angle)
-			INTVAL(BorderStyle)
-			INTVAL(Alignment)
-				if (track->track_type == TRACK_TYPE_ASS)
-					target->Alignment = numpad2align(target->Alignment);
-			INTVAL(MarginL)
-			INTVAL(MarginR)
-			INTVAL(MarginV)
-			INTVAL(Encoding)
-			FPVAL(ScaleX)
-			FPVAL(ScaleY)
-			FPVAL(Outline)
-			FPVAL(Shadow)
-		}
-	}
-	style->ScaleX /= 100.;
-	style->ScaleY /= 100.;
-	style->Bold = !!style->Bold;
-	style->Italic = !!style->Italic;
-	style->Underline = !!style->Underline;
-	if (!style->Name)
-		style->Name = strdup("Default");
-	if (!style->FontName)
-		style->FontName = strdup("Arial");
-	free(format);
-	return 0;
-	
-}
-
-static int process_styles_line(ass_track_t* track, char *str)
-{
-	if (!strncmp(str,"Format:", 7)) {
-		char* p = str + 7;
-		skip_spaces(&p);
-		track->style_format = strdup(p);
-		mp_msg(MSGT_ASS, MSGL_DBG2, "Style format: %s\n", track->style_format);
-	} else if (!strncmp(str,"Style:", 6)) {
-		char* p = str + 6;
-		skip_spaces(&p);
-		process_style(track, p);
-	}
-	return 0;
-}
-
-static int process_info_line(ass_track_t* track, char *str)
-{
-	if (!strncmp(str, "PlayResX:", 9)) {
-		track->PlayResX = atoi(str + 9);
-	} else if (!strncmp(str,"PlayResY:", 9)) {
-		track->PlayResY = atoi(str + 9);
-	} else if (!strncmp(str,"Timer:", 6)) {
-		track->Timer = atof(str + 6);
-	} else if (!strncmp(str,"WrapStyle:", 10)) {
-		track->WrapStyle = atoi(str + 10);
-	}
-	return 0;
-}
-
-static int process_events_line(ass_track_t* track, char *str)
-{
-	if (!strncmp(str, "Format:", 7)) {
-		char* p = str + 7;
-		skip_spaces(&p);
-		track->event_format = strdup(p);
-		mp_msg(MSGT_ASS, MSGL_DBG2, "Event format: %s\n", track->event_format);
-	} else if (!strncmp(str, "Dialogue:", 9)) {
-		// This should never be reached for embedded subtitles.
-		// They have slightly different format and are parsed in ass_process_chunk,
-		// called directly from demuxer
-		int eid;
-		ass_event_t* event;
-		
-		str += 9;
-		skip_spaces(&str);
-
-		eid = ass_alloc_event(track);
-		event = track->events + eid;
-
-		process_event_tail(track, event, str, 0);
-	} else {
-		mp_msg(MSGT_ASS, MSGL_V, "Not understood: %s  \n", str);
-	}
-	return 0;
-}
-
-// Copied from mkvtoolnix
-static unsigned char* decode_chars(unsigned char c1, unsigned char c2,
-		unsigned char c3, unsigned char c4, unsigned char* dst, int cnt)
-{
-	uint32_t value;
-	unsigned char bytes[3];
-	int i;
-
-	value = ((c1 - 33) << 18) + ((c2 - 33) << 12) + ((c3 - 33) << 6) + (c4 - 33);
-	bytes[2] = value & 0xff;
-	bytes[1] = (value & 0xff00) >> 8;
-	bytes[0] = (value & 0xff0000) >> 16;
-
-	for (i = 0; i < cnt; ++i)
-		*dst++ = bytes[i];
-	return dst;
-}
-
-static int decode_font(ass_track_t* track)
-{
-	unsigned char* p;
-	unsigned char* q;
-	int i;
-	int size; // original size
-	int dsize; // decoded size
-	unsigned char* buf = 0;
-
-	mp_msg(MSGT_ASS, MSGL_V, "font: %d bytes encoded data \n", track->parser_priv->fontdata_used);
-	size = track->parser_priv->fontdata_used;
-	if (size % 4 == 1) {
-		mp_msg(MSGT_ASS, MSGL_ERR, MSGTR_LIBASS_BadEncodedDataSize);
-		goto error_decode_font;
-	}
-	buf = malloc(size / 4 * 3 + 2);
-	q = buf;
-	for (i = 0, p = (unsigned char*)track->parser_priv->fontdata; i < size / 4; i++, p+=4) {
-		q = decode_chars(p[0], p[1], p[2], p[3], q, 3);
-	}
-	if (size % 4 == 2) {
-		q = decode_chars(p[0], p[1], 0, 0, q, 1);
-	} else if (size % 4 == 3) {
-		q = decode_chars(p[0], p[1], p[2], 0, q, 2);
-	}
-	dsize = q - buf;
-	assert(dsize <= size / 4 * 3 + 2);
-	
-	if (track->library->extract_fonts) {
-		ass_add_font(track->library, track->parser_priv->fontname, (char*)buf, dsize);
-		buf = 0;
-	}
-
-error_decode_font:
-	if (buf) free(buf);
-	free(track->parser_priv->fontname);
-	free(track->parser_priv->fontdata);
-	track->parser_priv->fontname = 0;
-	track->parser_priv->fontdata = 0;
-	track->parser_priv->fontdata_size = 0;
-	track->parser_priv->fontdata_used = 0;
-	return 0;
-}
-
-static int process_fonts_line(ass_track_t* track, char *str)
-{
-	int len;
-
-	if (!strncmp(str, "fontname:", 9)) {
-		char* p = str + 9;
-		skip_spaces(&p);
-		if (track->parser_priv->fontname) {
-			decode_font(track);
-		}
-		track->parser_priv->fontname = strdup(p);
-		mp_msg(MSGT_ASS, MSGL_V, "fontname: %s\n", track->parser_priv->fontname);
-		return 0;
-	}
-	
-	if (!track->parser_priv->fontname) {
-		mp_msg(MSGT_ASS, MSGL_V, "Not understood: %s  \n", str);
-		return 0;
-	}
-
-	len = strlen(str);
-	if (len > 80) {
-		mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_FontLineTooLong, len, str);
-		return 0;
-	}
-	if (track->parser_priv->fontdata_used + len > track->parser_priv->fontdata_size) {
-		track->parser_priv->fontdata_size += 100 * 1024;
-		track->parser_priv->fontdata = realloc(track->parser_priv->fontdata, track->parser_priv->fontdata_size);
-	}
-	memcpy(track->parser_priv->fontdata + track->parser_priv->fontdata_used, str, len);
-	track->parser_priv->fontdata_used += len;
-	
-	return 0;
-}
-
-/**
- * \brief Parse a header line
- * \param track track
- * \param str string to parse, zero-terminated
-*/ 
-static int process_line(ass_track_t* track, char *str)
-{
-	if (strstr(str, "[Script Info]")) { // FIXME: strstr to skip possible BOM at the beginning of the script
-		track->parser_priv->state = PST_INFO;
-	} else if (!strncmp(str, "[V4 Styles]", 11)) {
-		track->parser_priv->state = PST_STYLES;
-		track->track_type = TRACK_TYPE_SSA;
-	} else if (!strncmp(str, "[V4+ Styles]", 12)) {
-		track->parser_priv->state = PST_STYLES;
-		track->track_type = TRACK_TYPE_ASS;
-	} else if (!strncmp(str, "[Events]", 8)) {
-		track->parser_priv->state = PST_EVENTS;
-	} else if (!strncmp(str, "[Fonts]", 7)) {
-		track->parser_priv->state = PST_FONTS;
-	} else {
-		switch (track->parser_priv->state) {
-		case PST_INFO:
-			process_info_line(track, str);
-			break;
-		case PST_STYLES:
-			process_styles_line(track, str);
-			break;
-		case PST_EVENTS:
-			process_events_line(track, str);
-			break;
-		case PST_FONTS:
-			process_fonts_line(track, str);
-			break;
-		default:
-			break;
-		}
-	}
-
-	// there is no explicit end-of-font marker in ssa/ass
-	if ((track->parser_priv->state != PST_FONTS) && (track->parser_priv->fontname))
-		decode_font(track);
-
-	return 0;
-}
-
-static int process_text(ass_track_t* track, char* str)
-{
-	char* p = str;
-	while(1) {
-		char* q;
-		for (;((*p=='\r')||(*p=='\n'));++p) {}
-		for (q=p; ((*q!='\0')&&(*q!='\r')&&(*q!='\n')); ++q) {};
-		if (q==p)
-			break;
-		if (*q != '\0')
-			*(q++) = '\0';
-		process_line(track, p);
-		if (*q == '\0')
-			break;
-		p = q;
-	}
-	return 0;
-}
-
-/**
- * \brief Process CodecPrivate section of subtitle stream
- * \param track track
- * \param data string to parse
- * \param size length of data
- CodecPrivate section contains [Stream Info] and [V4+ Styles] ([V4 Styles] for SSA) sections
-*/ 
-void ass_process_codec_private(ass_track_t* track, char *data, int size)
-{
-	char* str = malloc(size + 1);
-
-	memcpy(str, data, size);
-	str[size] = '\0';
-
-	process_text(track, str);
-	free(str);
-
-	if (!track->event_format) {
-		// probably an mkv produced by ancient mkvtoolnix
-		// such files don't have [Events] and Format: headers
-		track->parser_priv->state = PST_EVENTS;
-		if (track->track_type == TRACK_TYPE_SSA)
-			track->event_format = strdup("Format: Marked, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text");
-		else
-			track->event_format = strdup("Format: Layer, Start, End, Style, Actor, MarginL, MarginR, MarginV, Effect, Text");
-	}
-
-	process_force_style(track);
-}
-
-static int check_duplicate_event(ass_track_t* track, int ReadOrder)
-{
-	int i;
-	for (i = 0; i<track->n_events - 1; ++i) // ignoring last event, it is the one we are comparing with
-		if (track->events[i].ReadOrder == ReadOrder)
-			return 1;
-	return 0;
-}
-
-/**
- * \brief Process a chunk of subtitle stream data. In matroska, this containes exactly 1 event (or a commentary)
- * \param track track
- * \param data string to parse
- * \param size length of data
- * \param timecode starting time of the event (milliseconds)
- * \param duration duration of the event (milliseconds)
-*/ 
-void ass_process_chunk(ass_track_t* track, char *data, int size, long long timecode, long long duration)
-{
-	char* str;
-	int eid;
-	char* p;
-	char* token;
-	ass_event_t* event;
-
-	if (!track->event_format) {
-		mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_EventFormatHeaderMissing);
-		return;
-	}
-	
-	str = malloc(size + 1);
-	memcpy(str, data, size);
-	str[size] = '\0';
-	mp_msg(MSGT_ASS, MSGL_V, "event at %" PRId64 ", +%" PRId64 ": %s  \n", (int64_t)timecode, (int64_t)duration, str);
-
-	eid = ass_alloc_event(track);
-	event = track->events + eid;
-
-	p = str;
-	
-	do { 
-		NEXT(p, token);
-		event->ReadOrder = atoi(token);
-		if (check_duplicate_event(track, event->ReadOrder))
-			break;
-
-		NEXT(p, token);
-		event->Layer = atoi(token);
-
-		process_event_tail(track, event, p, 3);
-
-		event->Start = timecode;
-		event->Duration = duration;
-		
-		free(str);
-		return;
-//		dump_events(tid);
-	} while (0);
-	// some error
-	ass_free_event(track, eid);
-	track->n_events--;
-	free(str);
-}
-
-#ifdef USE_ICONV
-/** \brief recode buffer to utf-8
- * constraint: codepage != 0
- * \param data pointer to text buffer
- * \param size buffer size
- * \return a pointer to recoded buffer, caller is responsible for freeing it
-**/
-static char* sub_recode(char* data, size_t size, char* codepage)
-{
-	static iconv_t icdsc = (iconv_t)(-1);
-	char* tocp = "UTF-8";
-	char* outbuf;
-	assert(codepage);
-
-	{
-		char* cp_tmp = codepage ? strdup(codepage) : 0;
-#ifdef HAVE_ENCA
-		char enca_lang[3], enca_fallback[100];
-		if (sscanf(codepage, "enca:%2s:%99s", enca_lang, enca_fallback) == 2
-				|| sscanf(codepage, "ENCA:%2s:%99s", enca_lang, enca_fallback) == 2) {
-			cp_tmp = guess_buffer_cp((unsigned char*)data, size, enca_lang, enca_fallback);
-		}
-#endif
-		if ((icdsc = iconv_open (tocp, cp_tmp)) != (iconv_t)(-1)){
-			mp_msg(MSGT_ASS,MSGL_V,"LIBSUB: opened iconv descriptor.\n");
-		} else
-			mp_msg(MSGT_ASS,MSGL_ERR,MSGTR_LIBASS_ErrorOpeningIconvDescriptor);
-#ifdef HAVE_ENCA
-		if (cp_tmp) free(cp_tmp);
-#endif
-	}
-
-	{
-		size_t osize = size;
-		size_t ileft = size;
-		size_t oleft = size - 1;
-		char* ip;
-		char* op;
-		size_t rc;
-		
-		outbuf = malloc(size);
-		ip = data;
-		op = outbuf;
-		
-		while (ileft) {
-			rc = iconv(icdsc, &ip, &ileft, &op, &oleft);
-			if (rc == (size_t)(-1)) {
-				if (errno == E2BIG) {
-					int offset = op - outbuf;
-					outbuf = (char*)realloc(outbuf, osize + size);
-					op = outbuf + offset;
-					osize += size;
-					oleft += size;
-				} else {
-					mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_ErrorRecodingFile);
-					return NULL;
-				}
-			}
-		}
-		outbuf[osize - oleft - 1] = 0;
-	}
-
-	if (icdsc != (iconv_t)(-1)) {
-		(void)iconv_close(icdsc);
-		icdsc = (iconv_t)(-1);
-		mp_msg(MSGT_ASS,MSGL_V,"LIBSUB: closed iconv descriptor.\n");
-	}
-	
-	return outbuf;
-}
-#endif // ICONV
-
-/**
- * \brief read file contents into newly allocated buffer
- * \param fname file name
- * \param bufsize out: file size
- * \return pointer to file contents. Caller is responsible for its deallocation.
- */
-static char* read_file(char* fname, size_t *bufsize)
-{
-	int res;
-	long sz;
-	long bytes_read;
-	char* buf;
-
-	FILE* fp = fopen(fname, "rb");
-	if (!fp) {
-		mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_FopenFailed, fname);
-		return 0;
-	}
-	res = fseek(fp, 0, SEEK_END);
-	if (res == -1) {
-		mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_FseekFailed, fname);
-		fclose(fp);
-		return 0;
-	}
-	
-	sz = ftell(fp);
-	rewind(fp);
-
-	if (sz > 10*1024*1024) {
-		mp_msg(MSGT_ASS, MSGL_INFO, MSGTR_LIBASS_RefusingToLoadSubtitlesLargerThan10M, fname);
-		fclose(fp);
-		return 0;
-	}
-	
-	mp_msg(MSGT_ASS, MSGL_V, "file size: %ld\n", sz);
-	
-	buf = malloc(sz + 1);
-	assert(buf);
-	bytes_read = 0;
-	do {
-		res = fread(buf + bytes_read, 1, sz - bytes_read, fp);
-		if (res <= 0) {
-			mp_msg(MSGT_ASS, MSGL_INFO, MSGTR_LIBASS_ReadFailed, errno, strerror(errno));
-			fclose(fp);
-			free(buf);
-			return 0;
-		}
-		bytes_read += res;
-	} while (sz - bytes_read > 0);
-	buf[sz] = '\0';
-	fclose(fp);
-	
-	if (bufsize)
-		*bufsize = sz;
-	return buf;
-}
-
-/*
- * \param buf pointer to subtitle text in utf-8
- */
-static ass_track_t* parse_memory(ass_library_t* library, char* buf)
-{
-	ass_track_t* track;
-	int i;
-	
-	track = ass_new_track(library);
-	
-	// process header
-	process_text(track, buf);
-
-	// external SSA/ASS subs does not have ReadOrder field
-	for (i = 0; i < track->n_events; ++i)
-		track->events[i].ReadOrder = i;
-
-	// there is no explicit end-of-font marker in ssa/ass
-	if (track->parser_priv->fontname)
-		decode_font(track);
-
-	if (track->track_type == TRACK_TYPE_UNKNOWN) {
-		ass_free_track(track);
-		return 0;
-	}
-
-	process_force_style(track);
-
-	return track;
-}
-
-/**
- * \brief Read subtitles from memory.
- * \param library libass library object
- * \param buf pointer to subtitles text
- * \param bufsize size of buffer
- * \param codepage recode buffer contents from given codepage
- * \return newly allocated track
-*/ 
-ass_track_t* ass_read_memory(ass_library_t* library, char* buf, size_t bufsize, char* codepage)
-{
-	ass_track_t* track;
-	int need_free = 0;
-	
-	if (!buf)
-		return 0;
-	
-#ifdef USE_ICONV
-	if (codepage)
-		buf = sub_recode(buf, bufsize, codepage);
-	if (!buf)
-		return 0;
-	else
-		need_free = 1;
-#endif
-	track = parse_memory(library, buf);
-	if (need_free)
-		free(buf);
-	if (!track)
-		return 0;
-
-	mp_msg(MSGT_ASS, MSGL_INFO, MSGTR_LIBASS_AddedSubtitleFileMemory, track->n_styles, track->n_events);
-	return track;
-}
-
-char* read_file_recode(char* fname, char* codepage, int* size)
-{
-	char* buf;
-	size_t bufsize;
-	
-	buf = read_file(fname, &bufsize);
-	if (!buf)
-		return 0;
-#ifdef USE_ICONV
-	if (codepage) {
-		 char* tmpbuf = sub_recode(buf, bufsize, codepage);
-		 free(buf);
-		 buf = tmpbuf;
-	}
-	if (!buf)
-		return 0;
-#endif
-	*size = bufsize;
-	return buf;
-}
-
-/**
- * \brief Read subtitles from file.
- * \param library libass library object
- * \param fname file name
- * \param codepage recode buffer contents from given codepage
- * \return newly allocated track
-*/ 
-ass_track_t* ass_read_file(ass_library_t* library, char* fname, char* codepage)
-{
-	char* buf;
-	ass_track_t* track;
-	size_t bufsize;
-
-	buf = read_file_recode(fname, codepage, &bufsize);
-	if (!buf)
-		return 0;
-	track = parse_memory(library, buf);
-	free(buf);
-	if (!track)
-		return 0;
-	
-	track->name = strdup(fname);
-
-	mp_msg(MSGT_ASS, MSGL_INFO, MSGTR_LIBASS_AddedSubtitleFileFname, fname, track->n_styles, track->n_events);
-	
-//	dump_events(forced_tid);
-	return track;
-}
-
-/**
- * \brief read styles from file into already initialized track
- */
-int ass_read_styles(ass_track_t* track, char* fname, char* codepage)
-{
-	char* buf;
-	parser_state_t old_state;
-	size_t sz;
-
-	buf = read_file(fname, &sz);
-	if (!buf)
-		return 1;
-#ifdef USE_ICONV
-	if (codepage) {
-		char* tmpbuf;
-		tmpbuf = sub_recode(buf, sz, codepage);
-		free(buf);
-		buf = tmpbuf;
-	}
-	if (!buf)
-		return 0;
-#endif
-
-	old_state = track->parser_priv->state;
-	track->parser_priv->state = PST_STYLES;
-	process_text(track, buf);
-	track->parser_priv->state = old_state;
-
-	return 0;
-}
-
-long long ass_step_sub(ass_track_t* track, long long now, int movement) {
-	int i;
-
-	if (movement == 0) return 0;
-	if (track->n_events == 0) return 0;
-	
-	if (movement < 0)
-		for (i = 0; (i < track->n_events) && ((long long)(track->events[i].Start + track->events[i].Duration) <= now); ++i) {}
-	else
-		for (i = track->n_events - 1; (i >= 0) && ((long long)(track->events[i].Start) > now); --i) {}
-	
-	// -1 and n_events are ok
-	assert(i >= -1); assert(i <= track->n_events);
-	i += movement;
-	if (i < 0) i = 0;
-	if (i >= track->n_events) i = track->n_events - 1;
-	return ((long long)track->events[i].Start) - now;
-}
-
-ass_track_t* ass_new_track(ass_library_t* library) {
-	ass_track_t* track = calloc(1, sizeof(ass_track_t));
-	track->library = library;
-	track->parser_priv = calloc(1, sizeof(parser_priv_t));
-	return track;
-}
-

Deleted: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/ass.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/ass.h	2009-07-31 22:24:31 UTC (rev 5184)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/ass.h	2009-08-01 07:55:22 UTC (rev 5185)
@@ -1,209 +0,0 @@
-// -*- c-basic-offset: 8; indent-tabs-mode: t -*-
-// vim:ts=8:sw=8:noet:ai:
-/*
-  Copyright (C) 2006 Evgeniy Stepanov <eugeni.stepanov at gmail.com>
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation; either version 2 of the License, or
-  (at your option) any later version.
-
-  This program is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with this program; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
-*/
-
-#ifndef ASS_H
-#define ASS_H
-
-#include "ass_types.h"
-
-/// Libass renderer object. Contents are private.
-typedef struct ass_renderer_s ass_renderer_t;
-
-/// a linked list of images produced by ass renderer
-typedef struct ass_image_s {
-	int w, h; // bitmap width/height
-	int stride; // bitmap stride
-	unsigned char* bitmap; // 1bpp stride*h alpha buffer
-	uint32_t color; // RGBA
-	int dst_x, dst_y; // bitmap placement inside the video frame
-
-	struct ass_image_s* next; // linked list
-} ass_image_t;
-
-/// Hinting type
-typedef enum {ASS_HINTING_NONE = 0,
-	      ASS_HINTING_LIGHT,
-	      ASS_HINTING_NORMAL,
-	      ASS_HINTING_NATIVE
-} ass_hinting_t;
-
-/**
- * \brief initialize the library
- * \return library handle or NULL if failed
- */
-ass_library_t* ass_library_init(void);
-
-/**
- * \brief finalize the library
- * \param priv library handle
- */
-void ass_library_done(ass_library_t*);
-
-/**
- * \brief set private font directory
- * It is used for saving embedded fonts and also in font lookup.
- */
-void ass_set_fonts_dir(ass_library_t* priv, const char* fonts_dir);
-
-void ass_set_extract_fonts(ass_library_t* priv, int extract);
-
-void ass_set_style_overrides(ass_library_t* priv, char** list);
-
-/**
- * \brief initialize the renderer
- * \param priv library handle
- * \return renderer handle or NULL if failed
- */
-ass_renderer_t* ass_renderer_init(ass_library_t*);
-
-/**
- * \brief finalize the renderer
- * \param priv renderer handle
- */
-void ass_renderer_done(ass_renderer_t* priv);
-
-void ass_set_frame_size(ass_renderer_t* priv, int w, int h);
-void ass_set_margins(ass_renderer_t* priv, int t, int b, int l, int r);
-void ass_set_use_margins(ass_renderer_t* priv, int use);
-void ass_set_aspect_ratio(ass_renderer_t* priv, double ar);
-void ass_set_font_scale(ass_renderer_t* priv, double font_scale);
-void ass_set_hinting(ass_renderer_t* priv, ass_hinting_t ht);
-void ass_set_line_spacing(ass_renderer_t* priv, double line_spacing);
-
-/**
- * \brief set font lookup defaults
- */
-int  ass_set_fonts(ass_renderer_t* priv, const char* default_font, const char* default_family);
-
-/**
- * \brief render a frame, producing a list of ass_image_t
- * \param priv library
- * \param track subtitle track
- * \param now video timestamp in milliseconds
- */
-ass_image_t* ass_render_frame(ass_renderer_t *priv, ass_track_t* track, long long now, int* detect_change);
-
-
-// The following functions operate on track objects and do not need an ass_renderer //
-
-/**
- * \brief allocate a new empty track object
- * \return pointer to empty track
- */
-ass_track_t* ass_new_track(ass_library_t*);
-
-/**
- * \brief deallocate track and all its child objects (styles and events)
- * \param track track to deallocate
- */
-void ass_free_track(ass_track_t* track);
-
-/**
- * \brief allocate new style
- * \param track track
- * \return newly allocated style id
- */
-int ass_alloc_style(ass_track_t* track);
-
-/**
- * \brief allocate new event
- * \param track track
- * \return newly allocated event id
- */
-int ass_alloc_event(ass_track_t* track);
-
-/**
- * \brief delete a style
- * \param track track
- * \param sid style id
- * Deallocates style data. Does not modify track->n_styles.
- */
-void ass_free_style(ass_track_t* track, int sid);
-
-/**
- * \brief delete an event
- * \param track track
- * \param eid event id
- * Deallocates event data. Does not modify track->n_events.
- */
-void ass_free_event(ass_track_t* track, int eid);
-
-/**
- * \brief Process Codec Private section of subtitle stream
- * \param track target track
- * \param data string to parse
- * \param size length of data
- */
-void ass_process_codec_private(ass_track_t* track, char *data, int size);
-
-/**
- * \brief Process a chunk of subtitle stream data. In matroska, this containes exactly 1 event (or a commentary)
- * \param track track
- * \param data string to parse
- * \param size length of data
- * \param timecode starting time of the event (milliseconds)
- * \param duration duration of the event (milliseconds)
-*/
-void ass_process_chunk(ass_track_t* track, char *data, int size, long long timecode, long long duration);
-
-char* read_file_recode(char* fname, char* codepage, int* size);
-
-/**
- * \brief Read subtitles from file.
- * \param fname file name
- * \return newly allocated track
-*/
-ass_track_t* ass_read_file(ass_library_t* library, char* fname, char* codepage);
-
-/**
- * \brief Read subtitles from memory.
- * \param library libass library object
- * \param buf pointer to subtitles text
- * \param bufsize size of buffer
- * \param codepage recode buffer contents from given codepage
- * \return newly allocated track
-*/ 
-ass_track_t* ass_read_memory(ass_library_t* library, char* buf, size_t bufsize, char* codepage);
-/**
- * \brief read styles from file into already initialized track
- * \return 0 on success
- */
-int ass_read_styles(ass_track_t* track, char* fname, char* codepage);
-
-/**
- * \brief Add a memory font.
- * \param name attachment name
- * \param data binary font data
- * \param data_size data size
-*/
-void ass_add_font(ass_library_t* library, char* name, char* data, int data_size);
-
-/**
- * \brief Calculates timeshift from now to the start of some other subtitle event, depending on movement parameter
- * \param track subtitle track
- * \param now current time, ms
- * \param movement how many events to skip from the one currently displayed
- * +2 means "the one after the next", -1 means "previous"
- * \return timeshift, ms
- */
-long long ass_step_sub(ass_track_t* track, long long now, int movement);
-
-#endif
-

Deleted: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/ass_bitmap.c
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/ass_bitmap.c	2009-07-31 22:24:31 UTC (rev 5184)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/ass_bitmap.c	2009-08-01 07:55:22 UTC (rev 5185)
@@ -1,272 +0,0 @@
-// -*- c-basic-offset: 8; indent-tabs-mode: t -*-
-// vim:ts=8:sw=8:noet:ai:
-/*
-  Copyright (C) 2006 Evgeniy Stepanov <eugeni.stepanov at gmail.com>
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation; either version 2 of the License, or
-  (at your option) any later version.
-
-  This program is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with this program; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
-*/
-
-#include <stdlib.h>
-#include <string.h>
-#include <math.h>
-#include <assert.h>
-#include <ft2build.h>
-#include FT_GLYPH_H
-
-#include "mputils.h"
-#include "ass_bitmap.h"
-
-struct ass_synth_priv_s {
-	int tmp_w, tmp_h;
-	unsigned short* tmp;
-
-	int g_r;
-	int g_w;
-
-	unsigned *g;
-	unsigned *gt2;
-};
-
-static const unsigned int maxcolor = 255;
-static const unsigned base = 256;
-static const double blur_radius = 1.5;
-
-static int generate_tables(ass_synth_priv_t* priv, double radius)
-{
-	double A = log(1.0/base)/(radius*radius*2);
-	int mx, i;
-	double volume_diff, volume_factor = 0;
-	unsigned volume;
-
-	priv->g_r = ceil(radius);
-	priv->g_w = 2*priv->g_r+1;
-
-	if (priv->g_r) {
-		priv->g = malloc(priv->g_w * sizeof(unsigned));
-		priv->gt2 = malloc(256 * priv->g_w * sizeof(unsigned));
-		if (priv->g==NULL || priv->gt2==NULL) {
-			return -1;
-		}
-	}
-
-	if (priv->g_r) {
-		// gaussian curve with volume = 256
-		for (volume_diff=10000000; volume_diff>0.0000001; volume_diff*=0.5){
-			volume_factor+= volume_diff;
-			volume=0;
-			for (i = 0; i<priv->g_w; ++i) {
-				priv->g[i] = (unsigned)(exp(A * (i-priv->g_r)*(i-priv->g_r)) * volume_factor + .5);
-				volume+= priv->g[i];
-			}
-			if(volume>256) volume_factor-= volume_diff;
-		}
-		volume=0;
-		for (i = 0; i<priv->g_w; ++i) {
-			priv->g[i] = (unsigned)(exp(A * (i-priv->g_r)*(i-priv->g_r)) * volume_factor + .5);
-			volume+= priv->g[i];
-		}
-
-		// gauss table:
-		for(mx=0;mx<priv->g_w;mx++){
-			for(i=0;i<256;i++){
-				priv->gt2[mx+i*priv->g_w] = i*priv->g[mx];
-			}
-		}
-	}
-
-	return 0;
-}
-
-static void resize_tmp(ass_synth_priv_t* priv, int w, int h)
-{
-	if (priv->tmp_w >= w && priv->tmp_h >= h)
-		return;
-	if (priv->tmp_w == 0)
-		priv->tmp_w = 64;
-	if (priv->tmp_h == 0)
-		priv->tmp_h = 64;
-	while (priv->tmp_w < w) priv->tmp_w *= 2;
-	while (priv->tmp_h < h) priv->tmp_h *= 2;
-	if (priv->tmp)
-		free(priv->tmp);
-	priv->tmp = malloc((priv->tmp_w + 1) * priv->tmp_h * sizeof(short));
-}
-
-ass_synth_priv_t* ass_synth_init(void)
-{
-	ass_synth_priv_t* priv = calloc(1, sizeof(ass_synth_priv_t));
-	generate_tables(priv, blur_radius);
-	return priv;
-}
-
-void ass_synth_done(ass_synth_priv_t* priv)
-{
-	if (priv->tmp)
-		free(priv->tmp);
-	if (priv->g)
-		free(priv->g);
-	if (priv->gt2)
-		free(priv->gt2);
-	free(priv);
-}
-
-static bitmap_t* alloc_bitmap(int w, int h)
-{
-	bitmap_t* bm;
-	bm = calloc(1, sizeof(bitmap_t));
-	bm->buffer = malloc(w*h);
-	bm->w = w;
-	bm->h = h;
-	bm->left = bm->top = 0;
-	return bm;
-}
-
-void ass_free_bitmap(bitmap_t* bm)
-{
-	if (bm) {
-		if (bm->buffer) free(bm->buffer);
-		free(bm);
-	}
-}
-
-static bitmap_t* copy_bitmap(const bitmap_t* src)
-{
-	bitmap_t* dst = alloc_bitmap(src->w, src->h);
-	dst->left = src->left;
-	dst->top = src->top;
-	memcpy(dst->buffer, src->buffer, src->w * src->h);
-	return dst;
-}
-
-static bitmap_t* glyph_to_bitmap_internal(FT_Glyph glyph, int bord)
-{
-	FT_BitmapGlyph bg;
-	FT_Bitmap* bit;
-	bitmap_t* bm;
-	int w, h;
-	unsigned char* src;
-	unsigned char* dst;
-	int i;
-	int error;
-
-	error = FT_Glyph_To_Bitmap(&glyph, FT_RENDER_MODE_NORMAL, 0, 0);
-	if (error) {
-		mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_FT_Glyph_To_BitmapError, error);
-		return 0;
-	}
-
-	bg = (FT_BitmapGlyph)glyph;
-	bit = &(bg->bitmap);
-	if (bit->pixel_mode != FT_PIXEL_MODE_GRAY) {
-		mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_UnsupportedPixelMode, (int)(bit->pixel_mode));
-		FT_Done_Glyph(glyph);
-		return 0;
-	}
-
-	w = bit->width;
-	h = bit->rows;
-	bm = alloc_bitmap(w + 2*bord, h + 2*bord);
-	memset(bm->buffer, 0, bm->w * bm->h);
-	bm->left = bg->left - bord;
-	bm->top = - bg->top - bord;
-
-	src = bit->buffer;
-	dst = bm->buffer + bord + bm->w * bord;
-	for (i = 0; i < h; ++i) {
-		memcpy(dst, src, w);
-		src += bit->pitch;
-		dst += bm->w;
-	}
-
-	return bm;
-}
-
-/**
- * \brief fix outline bitmap and generate shadow bitmap
- * Two things are done here:
- * 1. Glyph bitmap is subtracted from outline bitmap. This way looks much better in some cases.
- * 2. Shadow bitmap is created as a sum of glyph and outline bitmaps.
- */
-static bitmap_t* fix_outline_and_shadow(bitmap_t* bm_g, bitmap_t* bm_o)
-{
-	int x, y;
-	const int l = bm_o->left > bm_g->left ? bm_o->left : bm_g->left;
-	const int t = bm_o->top > bm_g->top ? bm_o->top : bm_g->top;
-	const int r = bm_o->left + bm_o->w < bm_g->left + bm_g->w ? bm_o->left + bm_o->w : bm_g->left + bm_g->w;
-	const int b = bm_o->top + bm_o->h < bm_g->top + bm_g->h ? bm_o->top + bm_o->h : bm_g->top + bm_g->h;
-
-	bitmap_t* bm_s = copy_bitmap(bm_o);
-
-	unsigned char* g = bm_g->buffer + (t - bm_g->top) * bm_g->w + (l - bm_g->left);
-	unsigned char* o = bm_o->buffer + (t - bm_o->top) * bm_o->w + (l - bm_o->left);
-	unsigned char* s = bm_s->buffer + (t - bm_s->top) * bm_s->w + (l - bm_s->left);
-	
-	for (y = 0; y < b - t; ++y) {
-		for (x = 0; x < r - l; ++x) {
-			unsigned char c_g, c_o;
-			c_g = g[x];
-			c_o = o[x];
-			o[x] = (c_o > c_g) ? c_o : 0;
-			s[x] = (c_o < 0xFF - c_g) ? c_o + c_g : 0xFF;
-		}
-		g += bm_g->w;
-		o += bm_o->w;
-		s += bm_s->w;
-	}
-
-	assert(bm_s);
-	return bm_s;
-}
-
-int glyph_to_bitmap(ass_synth_priv_t* priv, FT_Glyph glyph, FT_Glyph outline_glyph,
-		bitmap_t** bm_g, bitmap_t** bm_o, bitmap_t** bm_s, int be)
-{
-	const int bord = be ? ceil(blur_radius) : 0;
-
-	assert(bm_g && bm_o && bm_s);
-
-	*bm_g = *bm_o = *bm_s = 0;
-
-	if (glyph)
-		*bm_g = glyph_to_bitmap_internal(glyph, bord);
-	if (!*bm_g)
-		return 1;
-
-	if (outline_glyph) {
-		*bm_o = glyph_to_bitmap_internal(outline_glyph, bord);
-		if (!*bm_o) {
-			ass_free_bitmap(*bm_g);
-			return 1;
-		}
-	}
-	if (*bm_o)
-		resize_tmp(priv, (*bm_o)->w, (*bm_o)->h);
-	resize_tmp(priv, (*bm_g)->w, (*bm_g)->h);
-	
-	if (be) {
-		blur((*bm_g)->buffer, priv->tmp, (*bm_g)->w, (*bm_g)->h, (*bm_g)->w, (int*)priv->gt2, priv->g_r, priv->g_w);
-		if (*bm_o)
-			blur((*bm_o)->buffer, priv->tmp, (*bm_o)->w, (*bm_o)->h, (*bm_o)->w, (int*)priv->gt2, priv->g_r, priv->g_w);
-	}
-
-	if (*bm_o)
-		*bm_s = fix_outline_and_shadow(*bm_g, *bm_o);
-	else
-		*bm_s = copy_bitmap(*bm_g);
-
-	assert(bm_s);
-	return 0;
-}
-

Deleted: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/ass_bitmap.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/ass_bitmap.h	2009-07-31 22:24:31 UTC (rev 5184)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/ass_bitmap.h	2009-08-01 07:55:22 UTC (rev 5185)
@@ -1,49 +0,0 @@
-// -*- c-basic-offset: 8; indent-tabs-mode: t -*-
-// vim:ts=8:sw=8:noet:ai:
-/*
-  Copyright (C) 2006 Evgeniy Stepanov <eugeni.stepanov at gmail.com>
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation; either version 2 of the License, or
-  (at your option) any later version.
-
-  This program is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with this program; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
-*/
-
-#ifndef ASS_BITMAP_H
-#define ASS_BITMAP_H
-
-typedef struct ass_synth_priv_s ass_synth_priv_t;
-
-ass_synth_priv_t* ass_synth_init(void);
-void ass_synth_done(ass_synth_priv_t* priv);
-
-typedef struct bitmap_s {
-	int left, top;
-	int w, h; // width, height
-	unsigned char* buffer; // w x h buffer
-} bitmap_t;
-
-/**
- * \brief perform glyph rendering
- * \param glyph original glyph
- * \param outline_glyph "border" glyph, produced from original by FreeType's glyph stroker
- * \param bm_g out: pointer to the bitmap of original glyph is returned here
- * \param bm_o out: pointer to the bitmap of outline (border) glyph is returned here
- * \param bm_g out: pointer to the bitmap of glyph shadow is returned here
- * \param be 1 = produces blurred bitmaps, 0 = normal bitmaps
- */
-int glyph_to_bitmap(ass_synth_priv_t* priv, FT_Glyph glyph, FT_Glyph outline_glyph, bitmap_t** bm_g, bitmap_t** bm_o, bitmap_t** bm_s, int be);
-
-void ass_free_bitmap(bitmap_t* bm);
-
-#endif
-

Deleted: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/ass_cache.c
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/ass_cache.c	2009-07-31 22:24:31 UTC (rev 5184)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/ass_cache.c	2009-08-01 07:55:22 UTC (rev 5185)
@@ -1,324 +0,0 @@
-// -*- c-basic-offset: 8; indent-tabs-mode: t -*-
-// vim:ts=8:sw=8:noet:ai:
-/*
-  Copyright (C) 2006 Evgeniy Stepanov <eugeni.stepanov at gmail.com>
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation; either version 2 of the License, or
-  (at your option) any later version.
-
-  This program is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with this program; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
-*/
-
-//#include "config.h"
-
-#include <inttypes.h>
-#include <ft2build.h>
-#include FT_FREETYPE_H
-#include FT_GLYPH_H
-
-#include <assert.h>
-
-#include "mputils.h"
-#include "ass.h"
-#include "ass_fontconfig.h"
-#include "ass_font.h"
-#include "ass_bitmap.h"
-#include "ass_cache.h"
-
-
-typedef struct hashmap_item_s {
-	void* key;
-	void* value;
-	struct hashmap_item_s* next;
-} hashmap_item_t;
-typedef hashmap_item_t* hashmap_item_p;
-
-struct hashmap_s {
-	int nbuckets;
-	size_t key_size, value_size;
-	hashmap_item_p* root;
-	hashmap_item_dtor_t item_dtor; // a destructor for hashmap key/value pairs
-	hashmap_key_compare_t key_compare;
-	hashmap_hash_t hash;
-	// stats
-	int hit_count;
-	int miss_count;
-	int count;
-};
-
-#define FNV1_32A_INIT (unsigned)0x811c9dc5
-
-static inline unsigned fnv_32a_buf(void* buf, size_t len, unsigned hval)
-{
-	unsigned char *bp = buf;
-	unsigned char *be = bp + len;
-	while (bp < be) {
-		hval ^= (unsigned)*bp++;
-		hval += (hval<<1) + (hval<<4) + (hval<<7) + (hval<<8) + (hval<<24);
-	}
-	return hval;
-}
-static inline unsigned fnv_32a_str(char* str, unsigned hval)
-{
-	unsigned char* s = (unsigned char*)str;
-	while (*s) {
-		hval ^= (unsigned)*s++;
-		hval += (hval<<1) + (hval<<4) + (hval<<7) + (hval<<8) + (hval<<24);
-	}
-	return hval;
-}
-
-static unsigned hashmap_hash(void* buf, size_t len)
-{
-	return fnv_32a_buf(buf, len, FNV1_32A_INIT);
-}
-
-static int hashmap_key_compare(void* a, void* b, size_t size)
-{
-	return (memcmp(a, b, size) == 0);
-}
-
-static void hashmap_item_dtor(void* key, size_t key_size, void* value, size_t value_size)
-{
-	free(key);
-	free(value);
-}
-
-hashmap_t* hashmap_init(size_t key_size, size_t value_size, int nbuckets,
-			hashmap_item_dtor_t item_dtor, hashmap_key_compare_t key_compare,
-			hashmap_hash_t hash)
-{
-	hashmap_t* map = calloc(1, sizeof(hashmap_t));
-	map->nbuckets = nbuckets;
-	map->key_size = key_size;
-	map->value_size = value_size;
-	map->root = calloc(nbuckets, sizeof(hashmap_item_p));
-	map->item_dtor = item_dtor ? item_dtor : hashmap_item_dtor;
-	map->key_compare = key_compare ? key_compare : hashmap_key_compare;
-	map->hash = hash ? hash : hashmap_hash;
-	return map;
-}
-
-void hashmap_done(hashmap_t* map)
-{
-	int i;
-	// print stats
-	if (map->count > 0 || map->hit_count + map->miss_count > 0)
-		mp_msg(MSGT_ASS, MSGL_V, "cache statistics: \n  total accesses: %d\n  hits: %d\n  misses: %d\n  object count: %d\n",
-		       map->hit_count + map->miss_count, map->hit_count, map->miss_count, map->count);
-	
-	for (i = 0; i < map->nbuckets; ++i) {
-		hashmap_item_t* item = map->root[i];
-		while (item) {
-			hashmap_item_t* next = item->next;
-			map->item_dtor(item->key, map->key_size, item->value, map->value_size);
-			free(item);
-			item = next;
-		}
-	}
-	free(map->root);
-	free(map);
-}
-
-// does nothing if key already exists
-void* hashmap_insert(hashmap_t* map, void* key, void* value)
-{
-	unsigned hash = map->hash(key, map->key_size);
-	hashmap_item_t** next = map->root + (hash % map->nbuckets);
-	while (*next) {
-		if (map->key_compare(key, (*next)->key, map->key_size))
-			return (*next)->value;
-		next = &((*next)->next);
-		assert(next);
-	}
-	(*next) = malloc(sizeof(hashmap_item_t));
-	(*next)->key = malloc(map->key_size);
-	(*next)->value = malloc(map->value_size);
-	memcpy((*next)->key, key, map->key_size);
-	memcpy((*next)->value, value, map->value_size);
-	(*next)->next = 0;
-
-	map->count ++;
-	return (*next)->value;
-}
-
-void* hashmap_find(hashmap_t* map, void* key)
-{
-	unsigned hash = map->hash(key, map->key_size);
-	hashmap_item_t* item = map->root[hash % map->nbuckets];
-	while (item) {
-		if (map->key_compare(key, item->key, map->key_size)) {
-			map->hit_count++;
-			return item->value;
-		}
-		item = item->next;
-	}
-	map->miss_count++;
-	return 0;
-}
-
-//---------------------------------
-// font cache
-
-hashmap_t* font_cache;
-
-static unsigned font_desc_hash(void* buf, size_t len)
-{
-	ass_font_desc_t* desc = buf;
-	unsigned hval;
-	hval = fnv_32a_str(desc->family, FNV1_32A_INIT);
-	hval = fnv_32a_buf(&desc->bold, sizeof(desc->bold), hval);
-	hval = fnv_32a_buf(&desc->italic, sizeof(desc->italic), hval);
-	return hval;
-}
-
-static int font_compare(void* key1, void* key2, size_t key_size) {
-	ass_font_desc_t* a = key1;
-	ass_font_desc_t* b = key2;
-	if (strcmp(a->family, b->family) != 0)
-		return 0;
-	if (a->bold != b->bold)
-		return 0;
-	if (a->italic != b->italic)
-		return 0;
-	return 1;
-}
-
-static void font_hash_dtor(void* key, size_t key_size, void* value, size_t value_size)
-{
-	ass_font_free(value);
-	free(key);
-}
-
-ass_font_t* ass_font_cache_find(ass_font_desc_t* desc)
-{
-	return hashmap_find(font_cache, desc);
-}
-
-/**
- * \brief Add a face struct to cache.
- * \param font font struct
-*/
-void* ass_font_cache_add(ass_font_t* font)
-{
-	return hashmap_insert(font_cache, &(font->desc), font);
-}
-
-void ass_font_cache_init(void)
-{
-	font_cache = hashmap_init(sizeof(ass_font_desc_t),
-				  sizeof(ass_font_t),
-				  1000,
-				  font_hash_dtor, font_compare, font_desc_hash);
-}
-
-void ass_font_cache_done(void)
-{
-	hashmap_done(font_cache);
-}
-
-//---------------------------------
-// bitmap cache
-
-hashmap_t* bitmap_cache;
-
-static void bitmap_hash_dtor(void* key, size_t key_size, void* value, size_t value_size)
-{
-	bitmap_hash_val_t* v = value;
-	if (v->bm) ass_free_bitmap(v->bm);
-	if (v->bm_o) ass_free_bitmap(v->bm_o);
-	if (v->bm_s) ass_free_bitmap(v->bm_s);
-	free(key);
-	free(value);
-}
-
-void* cache_add_bitmap(bitmap_hash_key_t* key, bitmap_hash_val_t* val)
-{
-	return hashmap_insert(bitmap_cache, key, val);
-}
-
-/**
- * \brief Get a bitmap from bitmap cache.
- * \param key hash key
- * \return requested hash val or 0 if not found
-*/ 
-bitmap_hash_val_t* cache_find_bitmap(bitmap_hash_key_t* key)
-{
-	return hashmap_find(bitmap_cache, key);
-}
-
-void ass_bitmap_cache_init(void)
-{
-	bitmap_cache = hashmap_init(sizeof(bitmap_hash_key_t),
-				   sizeof(bitmap_hash_val_t),
-				   0xFFFF + 13,
-				   bitmap_hash_dtor, NULL, NULL);
-}
-
-void ass_bitmap_cache_done(void)
-{
-	hashmap_done(bitmap_cache);
-}
-
-void ass_bitmap_cache_reset(void)
-{
-	ass_bitmap_cache_done();
-	ass_bitmap_cache_init();
-}
-
-//---------------------------------
-// glyph cache
-
-hashmap_t* glyph_cache;
-
-static void glyph_hash_dtor(void* key, size_t key_size, void* value, size_t value_size)
-{
-	glyph_hash_val_t* v = value;
-	if (v->glyph) FT_Done_Glyph(v->glyph);
-	if (v->outline_glyph) FT_Done_Glyph(v->outline_glyph);
-	free(key);
-	free(value);
-}
-
-void* cache_add_glyph(glyph_hash_key_t* key, glyph_hash_val_t* val)
-{
-	return hashmap_insert(glyph_cache, key, val);
-}
-
-/**
- * \brief Get a glyph from glyph cache.
- * \param key hash key
- * \return requested hash val or 0 if not found
-*/ 
-glyph_hash_val_t* cache_find_glyph(glyph_hash_key_t* key)
-{
-	return hashmap_find(glyph_cache, key);
-}
-
-void ass_glyph_cache_init(void)
-{
-	glyph_cache = hashmap_init(sizeof(glyph_hash_key_t),
-				   sizeof(glyph_hash_val_t),
-				   0xFFFF + 13,
-				   glyph_hash_dtor, NULL, NULL);
-}
-
-void ass_glyph_cache_done(void)
-{
-	hashmap_done(glyph_cache);
-}
-
-void ass_glyph_cache_reset(void)
-{
-	ass_glyph_cache_done();
-	ass_glyph_cache_init();
-}

Deleted: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/ass_cache.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/ass_cache.h	2009-07-31 22:24:31 UTC (rev 5184)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/ass_cache.h	2009-08-01 07:55:22 UTC (rev 5185)
@@ -1,98 +0,0 @@
-// -*- c-basic-offset: 8; indent-tabs-mode: t -*-
-// vim:ts=8:sw=8:noet:ai:
-/*
-  Copyright (C) 2006 Evgeniy Stepanov <eugeni.stepanov at gmail.com>
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation; either version 2 of the License, or
-  (at your option) any later version.
-
-  This program is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with this program; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
-*/
-
-#ifndef ASS_CACHE_H
-#define ASS_CACHE_H
-
-void ass_font_cache_init(void);
-ass_font_t* ass_font_cache_find(ass_font_desc_t* desc);
-void* ass_font_cache_add(ass_font_t* font);
-void ass_font_cache_done(void);
-
-
-// describes a bitmap; bitmaps with equivalents structs are considered identical
-typedef struct bitmap_hash_key_s {
-	char bitmap; // bool : true = bitmap, false = outline
-	ass_font_t* font;
-	double size; // font size
-	uint32_t ch; // character code
-	unsigned outline; // border width, 16.16 fixed point value
-	int bold, italic;
-	char be; // blur edges
-
-	unsigned scale_x, scale_y; // 16.16
-	int frx, fry, frz; // signed 16.16
-	int shift_x, shift_y; // shift vector that was added to glyph before applying rotation
-	                      // = 0, if frx = fry = frx = 0
-	                      // = (glyph base point) - (rotation origin), otherwise
-	
-	FT_Vector advance; // subpixel shift vector
-} bitmap_hash_key_t;
-
-typedef struct bitmap_hash_val_s {
-	bitmap_t* bm; // the actual bitmaps
-	bitmap_t* bm_o;
-	bitmap_t* bm_s;
-} bitmap_hash_val_t;
-
-void ass_bitmap_cache_init(void);
-void* cache_add_bitmap(bitmap_hash_key_t* key, bitmap_hash_val_t* val);
-bitmap_hash_val_t* cache_find_bitmap(bitmap_hash_key_t* key);
-void ass_bitmap_cache_reset(void);
-void ass_bitmap_cache_done(void);
-
-// describes an outline glyph
-typedef struct glyph_hash_key_s {
-	ass_font_t* font;
-	double size; // font size
-	uint32_t ch; // character code
-	int bold, italic;
-	unsigned scale_x, scale_y; // 16.16
-	FT_Vector advance; // subpixel shift vector
-	unsigned outline; // border width, 16.16
-} glyph_hash_key_t;
-
-typedef struct glyph_hash_val_s {
-	FT_Glyph glyph;
-	FT_Glyph outline_glyph;
-	FT_BBox bbox_scaled; // bbox after scaling, but before rotation
-	FT_Vector advance; // 26.6, advance distance to the next bitmap in line
-} glyph_hash_val_t;
-
-void ass_glyph_cache_init(void);
-void* cache_add_glyph(glyph_hash_key_t* key, glyph_hash_val_t* val);
-glyph_hash_val_t* cache_find_glyph(glyph_hash_key_t* key);
-void ass_glyph_cache_reset(void);
-void ass_glyph_cache_done(void);
-
-typedef struct hashmap_s hashmap_t; 
-typedef void (*hashmap_item_dtor_t)(void* key, size_t key_size, void* value, size_t value_size);
-typedef int (*hashmap_key_compare_t)(void* key1, void* key2, size_t key_size);
-typedef unsigned (*hashmap_hash_t)(void* key, size_t key_size);
-
-hashmap_t* hashmap_init(size_t key_size, size_t value_size, int nbuckets,
-			hashmap_item_dtor_t item_dtor, hashmap_key_compare_t key_compare,
-			hashmap_hash_t hash);
-void hashmap_done(hashmap_t* map);
-void* hashmap_insert(hashmap_t* map, void* key, void* value);
-void* hashmap_find(hashmap_t* map, void* key);
-
-#endif
-

Deleted: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/ass_font.c
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/ass_font.c	2009-07-31 22:24:31 UTC (rev 5184)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/ass_font.c	2009-08-01 07:55:22 UTC (rev 5185)
@@ -1,370 +0,0 @@
-// -*- c-basic-offset: 8; indent-tabs-mode: t -*-
-// vim:ts=8:sw=8:noet:ai:
-/*
-  Copyright (C) 2006 Evgeniy Stepanov <eugeni.stepanov at gmail.com>
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation; either version 2 of the License, or
-  (at your option) any later version.
-
-  This program is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with this program; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
-*/
-
-//#include "config.h"
-
-#include <inttypes.h>
-#include <ft2build.h>
-#include FT_FREETYPE_H
-#include FT_SYNTHESIS_H
-#include FT_GLYPH_H
-#include FT_TRUETYPE_TABLES_H
-
-#include "ass.h"
-#include "ass_library.h"
-#include "ass_font.h"
-#include "ass_bitmap.h"
-#include "ass_cache.h"
-#include "ass_fontconfig.h"
-#include "ass_utils.h"
-#include "mputils.h"
-
-/**
- * Select Microfost Unicode CharMap, if the font has one.
- * Otherwise, let FreeType decide.
- */
-static void charmap_magic(FT_Face face)
-{
-	int i;
-	for (i = 0; i < face->num_charmaps; ++i) {
-		FT_CharMap cmap = face->charmaps[i];
-		unsigned pid = cmap->platform_id;
-		unsigned eid = cmap->encoding_id;
-		if (pid == 3 /*microsoft*/ && (eid == 1 /*unicode bmp*/ || eid == 10 /*full unicode*/)) {
-			FT_Set_Charmap(face, cmap);
-			return;
-		}
-	}
-
-	if (!face->charmap) {
-		if (face->num_charmaps == 0) {
-			mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_NoCharmaps);
-			return;
-		}
-		mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_NoCharmapAutodetected);
-		FT_Set_Charmap(face, face->charmaps[0]);
-		return;
-	}
-}
-
-static void update_transform(ass_font_t* font)
-{
-	int i;
-	FT_Matrix m;
-	m.xx = double_to_d16(font->scale_x);
-	m.yy = double_to_d16(font->scale_y);
-	m.xy = m.yx = 0;
-	for (i = 0; i < font->n_faces; ++i)
-		FT_Set_Transform(font->faces[i], &m, &font->v);
-}
-
-/**
- * \brief find a memory font by name
- */
-static int find_font(ass_library_t* library, char* name)
-{
-	int i;
-	for (i = 0; i < library->num_fontdata; ++i)
-		if (strcasecmp(name, library->fontdata[i].name) == 0)
-			return i;
-	return -1;
-}
-
-static void face_set_size(FT_Face face, double size);
-
-static void buggy_font_workaround(FT_Face face)
-{
-	// Some fonts have zero Ascender/Descender fields in 'hhea' table.
-	// In this case, get the information from 'os2' table or, as
-	// a last resort, from face.bbox.
-	if (face->ascender + face->descender == 0 || face->height == 0) {
-		TT_OS2 *os2 = FT_Get_Sfnt_Table(face, ft_sfnt_os2);
-		if (os2) {
-			face->ascender = os2->sTypoAscender;
-			face->descender = os2->sTypoDescender;
-			face->height = face->ascender - face->descender;
-		} else {
-			face->ascender = face->bbox.yMax;
-			face->descender = face->bbox.yMin;
-			face->height = face->ascender - face->descender;
-		}
-	}
-}
-
-/**
- * \brief Select a face with the given charcode and add it to ass_font_t
- * \return index of the new face in font->faces, -1 if failed
- */
-static int add_face(void* fc_priv, ass_font_t* font, uint32_t ch)
-{
-	char* path;
-	int index;
-	FT_Face face;
-	int error;
-	int mem_idx;
-	
-	if (font->n_faces == ASS_FONT_MAX_FACES)
-		return -1;
-	
-	path = fontconfig_select(fc_priv, font->desc.family, font->desc.bold,
-					      font->desc.italic, &index, ch);
-
-	mem_idx = find_font(font->library, path);
-	if (mem_idx >= 0) {
-		error = FT_New_Memory_Face(font->ftlibrary, (unsigned char*)font->library->fontdata[mem_idx].data,
-					   font->library->fontdata[mem_idx].size, 0, &face);
-		if (error) {
-			mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_ErrorOpeningMemoryFont, path);
-			return -1;
-		}
-	} else {
-		error = FT_New_Face(font->ftlibrary, path, index, &face);
-		if (error) {
-			mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_ErrorOpeningFont, path, index);
-			return -1;
-		}
-	}
-	charmap_magic(face);
-	buggy_font_workaround(face);
-	
-	font->faces[font->n_faces++] = face;
-	update_transform(font);
-	face_set_size(face, font->size);
-	return font->n_faces - 1;
-}
-
-/**
- * \brief Create a new ass_font_t according to "desc" argument
- */
-ass_font_t* ass_font_new(ass_library_t* library, FT_Library ftlibrary, void* fc_priv, ass_font_desc_t* desc)
-{
-	int error;
-	ass_font_t* fontp;
-	ass_font_t font;
-
-	fontp = ass_font_cache_find(desc);
-	if (fontp)
-		return fontp;
-	
-	font.library = library;
-	font.ftlibrary = ftlibrary;
-	font.n_faces = 0;
-	font.desc.family = strdup(desc->family);
-	font.desc.bold = desc->bold;
-	font.desc.italic = desc->italic;
-
-	font.scale_x = font.scale_y = 1.;
-	font.v.x = font.v.y = 0;
-	font.size = 0.;
-
-	error = add_face(fc_priv, &font, 0);
-	if (error == -1) {
-		free(font.desc.family);
-		return 0;
-	} else
-		return ass_font_cache_add(&font);
-}
-
-/**
- * \brief Set font transformation matrix and shift vector
- **/
-void ass_font_set_transform(ass_font_t* font, double scale_x, double scale_y, FT_Vector* v)
-{
-	font->scale_x = scale_x;
-	font->scale_y = scale_y;
-	font->v.x = v->x;
-	font->v.y = v->y;
-	update_transform(font);
-}
-
-static void face_set_size(FT_Face face, double size)
-{
-#if (FREETYPE_MAJOR > 2) || ((FREETYPE_MAJOR == 2) && (FREETYPE_MINOR > 1))
-	TT_HoriHeader *hori = FT_Get_Sfnt_Table(face, ft_sfnt_hhea);
-	TT_OS2 *os2 = FT_Get_Sfnt_Table(face, ft_sfnt_os2);
-	double mscale = 1.;
-	FT_Size_RequestRec rq;
-	FT_Size_Metrics *m = &face->size->metrics;
-	// VSFilter uses metrics from TrueType OS/2 table
-	// The idea was borrowed from asa (http://asa.diac24.net)
-	if (hori && os2) {
-		int hori_height = hori->Ascender - hori->Descender;
-		int os2_height = os2->usWinAscent + os2->usWinDescent;
-		if (hori_height && os2_height)
-			mscale = (double)hori_height / os2_height;
-	}
-	memset(&rq, 0, sizeof(rq));
-	rq.type = FT_SIZE_REQUEST_TYPE_REAL_DIM;
-	rq.width = 0;
-	rq.height = double_to_d6(size * mscale);
-	rq.horiResolution = rq.vertResolution = 0;
-	FT_Request_Size(face, &rq);
-	m->ascender /= mscale;
-	m->descender /= mscale;
-	m->height /= mscale;
-#else
-	FT_Set_Char_Size(face, 0, double_to_d6(size), 0, 0);
-#endif
-}
-
-/**
- * \brief Set font size
- **/
-void ass_font_set_size(ass_font_t* font, double size)
-{
-	int i;
-	if (font->size != size) {
-		font->size = size;
-		for (i = 0; i < font->n_faces; ++i)
-			face_set_size(font->faces[i], size);
-	}
-}
-
-/**
- * \brief Get maximal font ascender and descender.
- * \param ch character code
- * The values are extracted from the font face that provides glyphs for the given character
- **/
-void ass_font_get_asc_desc(ass_font_t* font, uint32_t ch, int* asc, int* desc)
-{
-	int i;
-	for (i = 0; i < font->n_faces; ++i) {
-		FT_Face face = font->faces[i];
-		if (FT_Get_Char_Index(face, ch)) {
-			int v, v2;
-			v = face->size->metrics.ascender;
-			v2 = FT_MulFix(face->bbox.yMax, face->size->metrics.y_scale);
-			*asc = (v > v2 * 0.9) ? v : v2;
-				
-			v = - face->size->metrics.descender;
-			v2 = - FT_MulFix(face->bbox.yMin, face->size->metrics.y_scale);
-			*desc = (v > v2 * 0.9) ? v : v2;
-			return;
-		}
-	}
-	
-	*asc = *desc = 0;
-}
-
-/**
- * \brief Get a glyph
- * \param ch character code
- **/
-FT_Glyph ass_font_get_glyph(void* fontconfig_priv, ass_font_t* font, uint32_t ch, ass_hinting_t hinting)
-{
-	int error;
-	int index = 0;
-	int i;
-	FT_Glyph glyph;
-	FT_Face face = 0;
-	int flags = 0;
-
-	if (ch < 0x20)
-		return 0;
-	if (font->n_faces == 0)
-		return 0;
-
-	for (i = 0; i < font->n_faces; ++i) {
-		face = font->faces[i];
-		index = FT_Get_Char_Index(face, ch);
-		if (index)
-			break;
-	}
-
-#ifdef HAVE_FONTCONFIG
-	if (index == 0) {
-		int face_idx;
-		mp_msg(MSGT_ASS, MSGL_INFO, MSGTR_LIBASS_GlyphNotFoundReselectingFont,
-		       ch, font->desc.family, font->desc.bold, font->desc.italic);
-		face_idx = add_face(fontconfig_priv, font, ch);
-		face = font->faces[face_idx];
-		index = FT_Get_Char_Index(face, ch);
-		if (index == 0) {
-			mp_msg(MSGT_ASS, MSGL_ERR, MSGTR_LIBASS_GlyphNotFound,
-			       ch, font->desc.family, font->desc.bold, font->desc.italic);
-		}
-	}
-#endif
-
-	switch (hinting) {
-	case ASS_HINTING_NONE: flags = FT_LOAD_NO_HINTING; break;
-	case ASS_HINTING_LIGHT: flags = FT_LOAD_FORCE_AUTOHINT | FT_LOAD_TARGET_LIGHT; break;
-	case ASS_HINTING_NORMAL: flags = FT_LOAD_FORCE_AUTOHINT; break;
-	case ASS_HINTING_NATIVE: flags = 0; break;
-	}
-	
-	error = FT_Load_Glyph(face, index, FT_LOAD_NO_BITMAP | flags);
-	if (error) {
-		mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_ErrorLoadingGlyph);
-		return 0;
-	}
-	
-#if (FREETYPE_MAJOR > 2) || \
-    ((FREETYPE_MAJOR == 2) && (FREETYPE_MINOR >= 2)) || \
-    ((FREETYPE_MAJOR == 2) && (FREETYPE_MINOR == 1) && (FREETYPE_PATCH >= 10))
-// FreeType >= 2.1.10 required
-	if (!(face->style_flags & FT_STYLE_FLAG_ITALIC) && 
-			(font->desc.italic > 55)) {
-		FT_GlyphSlot_Oblique(face->glyph);
-	}
-#endif
-	error = FT_Get_Glyph(face->glyph, &glyph);
-	if (error) {
-		mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_ErrorLoadingGlyph);
-		return 0;
-	}
-	
-	return glyph;
-}
-
-/**
- * \brief Get kerning for the pair of glyphs.
- **/
-FT_Vector ass_font_get_kerning(ass_font_t* font, uint32_t c1, uint32_t c2)
-{
-	FT_Vector v = {0, 0};
-	int i;
-
-	for (i = 0; i < font->n_faces; ++i) {
-		FT_Face face = font->faces[i];
-		int i1 = FT_Get_Char_Index(face, c1);
-		int i2 = FT_Get_Char_Index(face, c2);
-		if (i1 && i2) {
-			if (FT_HAS_KERNING(face))
-				FT_Get_Kerning(face, i1, i2, FT_KERNING_DEFAULT, &v);
-			return v;
-		}
-		if (i1 || i2) // these glyphs are from different font faces, no kerning information
-			return v;
-	}
-	return v;
-}
-
-/**
- * \brief Deallocate ass_font_t
- **/
-void ass_font_free(ass_font_t* font)
-{
-	int i;
-	for (i = 0; i < font->n_faces; ++i)
-		if (font->faces[i]) FT_Done_Face(font->faces[i]);
-	if (font->desc.family) free(font->desc.family);
-	free(font);
-}

Deleted: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/ass_font.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/ass_font.h	2009-07-31 22:24:31 UTC (rev 5184)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/ass_font.h	2009-08-01 07:55:22 UTC (rev 5185)
@@ -1,51 +0,0 @@
-// -*- c-basic-offset: 8; indent-tabs-mode: t -*-
-// vim:ts=8:sw=8:noet:ai:
-/*
-  Copyright (C) 2006 Evgeniy Stepanov <eugeni.stepanov at gmail.com>
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation; either version 2 of the License, or
-  (at your option) any later version.
-
-  This program is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with this program; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
-*/
-
-#ifndef ASS_FONT_H
-#define ASS_FONT_H
-
-typedef struct ass_font_desc_s {
-	char* family;
-	unsigned bold;
-	unsigned italic;
-} ass_font_desc_t;
-
-#define ASS_FONT_MAX_FACES 10
-
-typedef struct ass_font_s {
-	ass_font_desc_t desc;
-	ass_library_t* library;
-	FT_Library ftlibrary;
-	FT_Face faces[ASS_FONT_MAX_FACES];
-	int n_faces;
-	double scale_x, scale_y; // current transform
-	FT_Vector v; // current shift
-	double size;
-} ass_font_t;
-
-ass_font_t* ass_font_new(ass_library_t* library, FT_Library ftlibrary, void* fc_priv, ass_font_desc_t* desc);
-void ass_font_set_transform(ass_font_t* font, double scale_x, double scale_y, FT_Vector* v);
-void ass_font_set_size(ass_font_t* font, double size);
-void ass_font_get_asc_desc(ass_font_t* font, uint32_t ch, int* asc, int* desc);
-FT_Glyph ass_font_get_glyph(void* fontconfig_priv, ass_font_t* font, uint32_t ch, ass_hinting_t hinting);
-FT_Vector ass_font_get_kerning(ass_font_t* font, uint32_t c1, uint32_t c2);
-void ass_font_free(ass_font_t* font);
-
-#endif

Deleted: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/ass_fontconfig.c
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/ass_fontconfig.c	2009-07-31 22:24:31 UTC (rev 5184)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/ass_fontconfig.c	2009-08-01 07:55:22 UTC (rev 5185)
@@ -1,413 +0,0 @@
-// -*- c-basic-offset: 8; indent-tabs-mode: t -*-
-// vim:ts=8:sw=8:noet:ai:
-/*
-  Copyright (C) 2006 Evgeniy Stepanov <eugeni.stepanov at gmail.com>
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation; either version 2 of the License, or
-  (at your option) any later version.
-
-  This program is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with this program; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
-*/
-
-//#include "config.h"
-
-#include <stdlib.h>
-#include <stdio.h>
-#include <assert.h>
-#include <string.h>
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <inttypes.h>
-#include <ft2build.h>
-#include FT_FREETYPE_H
-
-#include "mputils.h"
-#include "ass.h"
-#include "ass_library.h"
-#include "ass_fontconfig.h"
-
-#ifdef HAVE_FONTCONFIG
-#include <fontconfig/fontconfig.h>
-#include <fontconfig/fcfreetype.h>
-#endif
-
-struct fc_instance_s {
-#ifdef HAVE_FONTCONFIG
-	FcConfig* config;
-#endif
-	char* family_default;
-	char* path_default;
-	int index_default;
-};
-
-#ifdef HAVE_FONTCONFIG
-/**
- * \brief Low-level font selection.
- * \param priv private data
- * \param family font family
- * \param bold font weight value
- * \param italic font slant value
- * \param index out: font index inside a file
- * \param code: the character that should be present in the font, can be 0
- * \return font file path
-*/ 
-static char* _select_font(fc_instance_t* priv, const char* family, unsigned bold, unsigned italic, int* index,
-			  uint32_t code)
-{
-	FcBool rc;
-	FcResult result;
-	FcPattern *pat = 0, *rpat;
-	int val_i;
-	FcChar8* val_s;
-	FcBool val_b;
-	FcCharSet* val_cs;
-	FcFontSet* fset = 0;
-	int curf;
-	char* retval = 0;
-	
-	*index = 0;
-
-	pat = FcPatternCreate();
-	if (!pat)
-		goto error;
-	
-	FcPatternAddString(pat, FC_FAMILY, (const FcChar8*)family);
-	FcPatternAddBool(pat, FC_OUTLINE, FcTrue);
-	FcPatternAddInteger(pat, FC_SLANT, italic);
-	FcPatternAddInteger(pat, FC_WEIGHT, bold);
-
-	FcDefaultSubstitute(pat);
-	
-	rc = FcConfigSubstitute(priv->config, pat, FcMatchPattern);
-	if (!rc)
-		goto error;
-
-	fset = FcFontSort(priv->config, pat, FcTrue, NULL, &result);
-
-	for (curf = 0; curf < fset->nfont; ++curf) {
-		rpat = fset->fonts[curf];
-		
-		result = FcPatternGetBool(rpat, FC_OUTLINE, 0, &val_b);
-		if (result != FcResultMatch)
-			continue;
-		if (val_b != FcTrue)
-			continue;
-		if (!code)
-			break;
-		result = FcPatternGetCharSet(rpat, FC_CHARSET, 0, &val_cs);
-		if (result != FcResultMatch)
-			continue;
-		if (FcCharSetHasChar(val_cs, code))
-			break;
-	}
-
-	if (curf >= fset->nfont)
-		goto error;
-
-	rpat = fset->fonts[curf];
-	
-	result = FcPatternGetInteger(rpat, FC_INDEX, 0, &val_i);
-	if (result != FcResultMatch)
-		goto error;
-	*index = val_i;
-
-	result = FcPatternGetString(rpat, FC_FAMILY, 0, &val_s);
-	if (result != FcResultMatch)
-		goto error;
-
-	if (strcasecmp((const char*)val_s, family) != 0)
-		mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_SelectedFontFamilyIsNotTheRequestedOne,
-				(const char*)val_s, family);
-
-	result = FcPatternGetString(rpat, FC_FILE, 0, &val_s);
-	if (result != FcResultMatch)
-		goto error;
-	
-	retval = strdup((const char*)val_s);
- error:
-	if (pat) FcPatternDestroy(pat);
-	if (fset) FcFontSetDestroy(fset);
-	return retval;
-}
-
-/**
- * \brief Find a font. Use default family or path if necessary.
- * \param priv_ private data
- * \param family font family
- * \param bold font weight value
- * \param italic font slant value
- * \param index out: font index inside a file
- * \param code: the character that should be present in the font, can be 0
- * \return font file path
-*/ 
-char* fontconfig_select(fc_instance_t* priv, const char* family, unsigned bold, unsigned italic, int* index,
-			uint32_t code)
-{
-	char* res = 0;
-	if (family && *family)
-		res = _select_font(priv, family, bold, italic, index, code);
-	if (!res && priv->family_default) {
-		res = _select_font(priv, priv->family_default, bold, italic, index, code);
-		if (res)
-			mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_UsingDefaultFontFamily, 
-					family, bold, italic, res, *index);
-	}
-	if (!res && priv->path_default) {
-		res = priv->path_default;
-		*index = priv->index_default;
-		mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_UsingDefaultFont, 
-		       family, bold, italic, res, *index);
-	}
-	if (!res) {
-		res = _select_font(priv, "Arial", bold, italic, index, code);
-		if (res)
-			mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_UsingArialFontFamily, 
-					family, bold, italic, res, *index);
-	}
-	if (res)
-		mp_msg(MSGT_ASS, MSGL_V, "fontconfig_select: (%s, %d, %d) -> %s, %d\n", 
-				family, bold, italic, res, *index);
-	return res;
-}
-
-#if (FC_VERSION < 20402)
-static char* validate_fname(char* name)
-{
-	char* fname;
-	char* p;
-	char* q;
-	unsigned code;
-	int sz = strlen(name);
-
-	q = fname = malloc(sz + 1);
-	p = name;
-	while (*p) {
-		code = utf8_get_char(&p);
-		if (code == 0)
-			break;
-		if (	(code > 0x7F) ||
-			(code == '\\') ||
-			(code == '/') ||
-			(code == ':') ||
-			(code == '*') ||
-			(code == '?') ||
-			(code == '<') ||
-			(code == '>') ||
-			(code == '|') ||
-			(code == 0))
-		{
-			*q++ = '_';
-		} else {
-			*q++ = code;
-		}
-		if (p - name > sz)
-			break;
-	}
-	*q = 0;
-	return fname;
-}
-#endif
-
-/**
- * \brief Process memory font.
- * \param priv private data
- * \param library library object
- * \param ftlibrary freetype library object
- * \param idx index of the processed font in library->fontdata
- * With FontConfig >= 2.4.2, builds a font pattern in memory via FT_New_Memory_Face/FcFreeTypeQueryFace.
- * With older FontConfig versions, save the font to ~/.mplayer/fonts.
-*/ 
-static void process_fontdata(fc_instance_t* priv, ass_library_t* library, FT_Library ftlibrary, int idx)
-{
-	int rc;
-	const char* name = library->fontdata[idx].name;
-	const char* data = library->fontdata[idx].data;
-	int data_size = library->fontdata[idx].size;
-
-#if (FC_VERSION < 20402)
-	struct stat st;
-	char* fname;
-	const char* fonts_dir = library->fonts_dir;
-	char buf[1000];
-	FILE* fp = 0;
-
-	if (!fonts_dir)
-		return;
-	rc = stat(fonts_dir, &st);
-	if (rc) {
-		int res;
-#ifndef __MINGW32__
-		res = mkdir(fonts_dir, 0700);
-#else
-		res = mkdir(fonts_dir);
-#endif
-		if (res) {
-			mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_FailedToCreateDirectory, fonts_dir);
-		}
-	} else if (!S_ISDIR(st.st_mode)) {
-		mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_NotADirectory, fonts_dir);
-	}
-	
-	fname = validate_fname((char*)name);
-
-	snprintf(buf, 1000, "%s/%s", fonts_dir, fname);
-	free(fname);
-
-	fp = fopen(buf, "wb");
-	if (!fp) return;
-
-	fwrite(data, data_size, 1, fp);
-	fclose(fp);
-
-#else // (FC_VERSION >= 20402)
-	FT_Face face;
-	FcPattern* pattern;
-	FcFontSet* fset;
-	FcBool res;
-
-	rc = FT_New_Memory_Face(ftlibrary, (unsigned char*)data, data_size, 0, &face);
-	if (rc) {
-		mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_ErrorOpeningMemoryFont, name);
-		return;
-	}
-
-	pattern = FcFreeTypeQueryFace(face, (unsigned char*)name, 0, FcConfigGetBlanks(priv->config));
-	if (!pattern) {
-		mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_FunctionCallFailed, "FcFreeTypeQueryFace");
-		FT_Done_Face(face);
-		return;
-	}
-
-	fset = FcConfigGetFonts(priv->config, FcSetSystem); // somehow it failes when asked for FcSetApplication
-	if (!fset) {
-		mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_FunctionCallFailed, "FcConfigGetFonts");
-		FT_Done_Face(face);
-		return;
-	}
-
-	res = FcFontSetAdd(fset, pattern);
-	if (!res) {
-		mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_FunctionCallFailed, "FcFontSetAdd");
-		FT_Done_Face(face);
-		return;
-	}
-
-	FT_Done_Face(face);
-#endif
-}
-
-/**
- * \brief Init fontconfig.
- * \param library libass library object
- * \param ftlibrary freetype library object
- * \param family default font family
- * \param path default font path
- * \return pointer to fontconfig private data
-*/ 
-fc_instance_t* fontconfig_init(ass_library_t* library, FT_Library ftlibrary, const char* family, const char* path)
-{
-	int rc;
-	fc_instance_t* priv = calloc(1, sizeof(fc_instance_t));
-	const char* dir = library->fonts_dir;
-	int i;
-	
-	rc = FcInit();
-	assert(rc);
-
-	priv->config = FcConfigGetCurrent();
-	if (!priv->config) {
-		mp_msg(MSGT_ASS, MSGL_FATAL, MSGTR_LIBASS_FcInitLoadConfigAndFontsFailed);
-		return 0;
-	}
-
-	for (i = 0; i < library->num_fontdata; ++i)
-		process_fontdata(priv, library, ftlibrary, i);
-
-	if (FcDirCacheValid((const FcChar8 *)dir) == FcFalse)
-	{
-		mp_msg(MSGT_ASS, MSGL_INFO, MSGTR_LIBASS_UpdatingFontCache);
-		if (FcGetVersion() >= 20390 && FcGetVersion() < 20400)
-			mp_msg(MSGT_ASS, MSGL_WARN,
-			       MSGTR_LIBASS_BetaVersionsOfFontconfigAreNotSupported);
-		// FontConfig >= 2.4.0 updates cache automatically in FcConfigAppFontAddDir()
-		if (FcGetVersion() < 20390) {
-			FcFontSet* fcs;
-			FcStrSet* fss;
-			fcs = FcFontSetCreate();
-			fss = FcStrSetCreate();
-			rc = FcStrSetAdd(fss, (const FcChar8*)dir);
-			if (!rc) {
-				mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_FcStrSetAddFailed);
-				goto ErrorFontCache;
-			}
-
-			rc = FcDirScan(fcs, fss, NULL, FcConfigGetBlanks(priv->config), (const FcChar8 *)dir, FcFalse);
-			if (!rc) {
-				mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_FcDirScanFailed);
-				goto ErrorFontCache;
-			}
-
-			rc = FcDirSave(fcs, fss, (const FcChar8 *)dir);
-			if (!rc) {
-				mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_FcDirSave);
-				goto ErrorFontCache;
-			}
-		ErrorFontCache:
-			;
-		}
-	}
-
-	rc = FcConfigAppFontAddDir(priv->config, (const FcChar8*)dir);
-	if (!rc) {
-		mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_FcConfigAppFontAddDirFailed);
-	}
-
-	priv->family_default = family ? strdup(family) : 0;
-	priv->path_default = path ? strdup(path) : 0;
-	priv->index_default = 0;
-
-	return priv;
-}
-
-#else // HAVE_FONTCONFIG
-
-char* fontconfig_select(fc_instance_t* priv, const char* family, unsigned bold, unsigned italic, int* index,
-			uint32_t code)
-{
-	*index = priv->index_default;
-	return priv->path_default;
-}
-
-fc_instance_t* fontconfig_init(ass_library_t* library, FT_Library ftlibrary, const char* family, const char* path)
-{
-	fc_instance_t* priv;
-
-	mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_FontconfigDisabledDefaultFontWillBeUsed);
-	
-	priv = calloc(1, sizeof(fc_instance_t));
-	
-	priv->path_default = strdup(path);
-	priv->index_default = 0;
-	return priv;
-}
-
-#endif
-
-void fontconfig_done(fc_instance_t* priv)
-{
-	// don't call FcFini() here, library can still be used by some code
-	if (priv && priv->path_default) free(priv->path_default);
-	if (priv && priv->family_default) free(priv->family_default);
-	if (priv) free(priv);
-}
-
-

Deleted: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/ass_fontconfig.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/ass_fontconfig.h	2009-07-31 22:24:31 UTC (rev 5184)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/ass_fontconfig.h	2009-08-01 07:55:22 UTC (rev 5185)
@@ -1,35 +0,0 @@
-// -*- c-basic-offset: 8; indent-tabs-mode: t -*-
-// vim:ts=8:sw=8:noet:ai:
-/*
-  Copyright (C) 2006 Evgeniy Stepanov <eugeni.stepanov at gmail.com>
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation; either version 2 of the License, or
-  (at your option) any later version.
-
-  This program is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with this program; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
-*/
-
-#ifndef ASS_FONTCONFIG_H
-#define ASS_FONTCONFIG_H
-
-#ifdef HAVE_FONTCONFIG
-#include <fontconfig/fontconfig.h>
-#endif
-
-typedef struct fc_instance_s fc_instance_t;
-
-fc_instance_t* fontconfig_init(ass_library_t* library, FT_Library ftlibrary, const char* family, const char* path);
-char* fontconfig_select(fc_instance_t* priv, const char* family, unsigned bold, unsigned italic, int* index, uint32_t code);
-void fontconfig_done(fc_instance_t* priv);
-
-#endif
-

Deleted: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/ass_library.c
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/ass_library.c	2009-07-31 22:24:31 UTC (rev 5184)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/ass_library.c	2009-08-01 07:55:22 UTC (rev 5185)
@@ -1,93 +0,0 @@
-// -*- c-basic-offset: 8; indent-tabs-mode: t -*-
-// vim:ts=8:sw=8:noet:ai:
-/*
-  Copyright (C) 2006 Evgeniy Stepanov <eugeni.stepanov at gmail.com>
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation; either version 2 of the License, or
-  (at your option) any later version.
-
-  This program is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with this program; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
-*/
-
-#include <inttypes.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-
-#include "ass.h"
-#include "ass_library.h"
-
-
-ass_library_t* ass_library_init(void)
-{
-	return calloc(1, sizeof(ass_library_t));
-}
-
-void ass_library_done(ass_library_t* priv)
-{
-	if (priv) {
-		ass_set_fonts_dir(priv, NULL);
-		ass_set_style_overrides(priv, NULL);
-		free(priv);
-	}
-}
-
-void ass_set_fonts_dir(ass_library_t* priv, const char* fonts_dir)
-{
-	if (priv->fonts_dir)
-		free(priv->fonts_dir);
-
-	priv->fonts_dir = fonts_dir ? strdup(fonts_dir) : 0;
-}
-
-void ass_set_extract_fonts(ass_library_t* priv, int extract)
-{
-	priv->extract_fonts = !!extract;
-}
-
-void ass_set_style_overrides(ass_library_t* priv, char** list)
-{
-	char** p;
-	char** q;
-	int cnt;
-	
-	if (priv->style_overrides) {
-		for (p = priv->style_overrides; *p; ++p)
-			free(*p);
-		free(priv->style_overrides);
-	}
-	
-	if (!list) return;
-
-	for (p = list, cnt = 0; *p; ++p, ++cnt) {}
-
-	priv->style_overrides = malloc((cnt + 1) * sizeof(char*));
-	for (p = list, q = priv->style_overrides; *p; ++p, ++q)
-		*q = strdup(*p);
-	priv->style_overrides[cnt] = NULL;
-}
-
-static void grow_array(void **array, int nelem, size_t elsize)
-{
-	if (!(nelem & 31))
-		*array = realloc(*array, (nelem + 32) * elsize);
-}
-
-void ass_add_font(ass_library_t* priv, char* name, char* data, int size)
-{
-	grow_array((void**)&priv->fontdata, priv->num_fontdata, sizeof(*priv->fontdata));
-	priv->fontdata[priv->num_fontdata].name = name;
-	priv->fontdata[priv->num_fontdata].data = data;
-	priv->fontdata[priv->num_fontdata].size = size;
-	priv->num_fontdata ++;
-}
-

Deleted: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/ass_library.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/ass_library.h	2009-07-31 22:24:31 UTC (rev 5184)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/ass_library.h	2009-08-01 07:55:22 UTC (rev 5185)
@@ -1,40 +0,0 @@
-// -*- c-basic-offset: 8; indent-tabs-mode: t -*-
-// vim:ts=8:sw=8:noet:ai:
-/*
-  Copyright (C) 2006 Evgeniy Stepanov <eugeni.stepanov at gmail.com>
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation; either version 2 of the License, or
-  (at your option) any later version.
-
-  This program is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with this program; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
-*/
-
-#ifndef ASS_LIBRARY_H
-#define ASS_LIBRARY_H
-
-typedef struct ass_fontdata_s {
-	char* name;
-	char* data;
-	int size;
-} ass_fontdata_t;
-
-struct ass_library_s {
-	char* fonts_dir;
-	int extract_fonts;
-	char** style_overrides;
-
-	ass_fontdata_t* fontdata;
-	int num_fontdata;
-};
-
-#endif
-

Deleted: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/ass_render.c
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/ass_render.c	2009-07-31 22:24:31 UTC (rev 5184)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/ass_render.c	2009-08-01 07:55:22 UTC (rev 5185)
@@ -1,2399 +0,0 @@
-// -*- c-basic-offset: 8; indent-tabs-mode: t -*-
-// vim:ts=8:sw=8:noet:ai:
-/*
-  Copyright (C) 2006 Evgeniy Stepanov <eugeni.stepanov at gmail.com>
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation; either version 2 of the License, or
-  (at your option) any later version.
-
-  This program is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with this program; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
-*/
-
-//#include "config.h"
-
-#include <assert.h>
-#include <math.h>
-#include <inttypes.h>
-#include <ft2build.h>
-#include FT_FREETYPE_H
-#include FT_STROKER_H
-#include FT_GLYPH_H
-#include FT_SYNTHESIS_H
-
-#include "mputils.h"
-
-#include "ass.h"
-#include "ass_font.h"
-#include "ass_bitmap.h"
-#include "ass_cache.h"
-#include "ass_utils.h"
-#include "ass_fontconfig.h"
-#include "ass_library.h"
-
-#define MAX_GLYPHS 1000
-#define MAX_LINES 100
-
-static int last_render_id = 0;
-
-typedef struct ass_settings_s {
-	int frame_width;
-	int frame_height;
-	double font_size_coeff; // font size multiplier
-	double line_spacing; // additional line spacing (in frame pixels)
-	int top_margin; // height of top margin. Everything except toptitles is shifted down by top_margin.
-	int bottom_margin; // height of bottom margin. (frame_height - top_margin - bottom_margin) is original video height.
-	int left_margin;
-	int right_margin;
-	int use_margins; // 0 - place all subtitles inside original frame
-	                 // 1 - use margins for placing toptitles and subtitles
-	double aspect; // frame aspect ratio, d_width / d_height.
-	ass_hinting_t hinting;
-
-	char* default_font;
-	char* default_family;
-} ass_settings_t;
-
-// a rendered event
-typedef struct event_images_s {
-	ass_image_t* imgs;
-	int top, height;
-	int detect_collisions;
-	int shift_direction;
-	ass_event_t* event;
-} event_images_t;
-
-struct ass_renderer_s {
-	ass_library_t* library;
-	FT_Library ftlibrary;
-	fc_instance_t* fontconfig_priv;
-	ass_settings_t settings;
-	int render_id;
-	ass_synth_priv_t* synth_priv;
-
-	ass_image_t* images_root; // rendering result is stored here
-	ass_image_t* prev_images_root;
-
-	event_images_t* eimg; // temporary buffer for sorting rendered events
-	int eimg_size; // allocated buffer size
-};
-
-typedef enum {EF_NONE = 0, EF_KARAOKE, EF_KARAOKE_KF, EF_KARAOKE_KO} effect_t;
-
-// describes a glyph
-// glyph_info_t and text_info_t are used for text centering and word-wrapping operations
-typedef struct glyph_info_s {
-	unsigned symbol;
-	FT_Glyph glyph;
-	FT_Glyph outline_glyph;
-	bitmap_t* bm; // glyph bitmap
-	bitmap_t* bm_o; // outline bitmap
-	bitmap_t* bm_s; // shadow bitmap
-	FT_BBox bbox;
-	FT_Vector pos;
-	char linebreak; // the first (leading) glyph of some line ?
-	uint32_t c[4]; // colors
-	FT_Vector advance; // 26.6
-	effect_t effect_type;
-	int effect_timing; // time duration of current karaoke word
-	                   // after process_karaoke_effects: distance in pixels from the glyph origin.
-	                   // part of the glyph to the left of it is displayed in a different color.
-	int effect_skip_timing; // delay after the end of last karaoke word
-	int asc, desc; // font max ascender and descender
-//	int height;
-	int be; // blur edges
-	int shadow;
-	double frx, fry, frz; // rotation
-	
-	bitmap_hash_key_t hash_key;
-} glyph_info_t;
-
-typedef struct line_info_s {
-	int asc, desc;
-} line_info_t;
-
-typedef struct text_info_s {
-	glyph_info_t* glyphs;
-	int length;
-	line_info_t lines[MAX_LINES];
-	int n_lines;
-	int height;
-} text_info_t;
-
-
-// Renderer state.
-// Values like current font face, color, screen position, clipping and so on are stored here.
-typedef struct render_context_s {
-	ass_event_t* event;
-	ass_style_t* style;
-	
-	ass_font_t* font;
-	char* font_path;
-	double font_size;
-	
-	FT_Stroker stroker;
-	int alignment; // alignment overrides go here; if zero, style value will be used
-	double frx, fry, frz;
-	enum {	EVENT_NORMAL, // "normal" top-, sub- or mid- title
-		EVENT_POSITIONED, // happens after pos(,), margins are ignored
-		EVENT_HSCROLL, // "Banner" transition effect, text_width is unlimited
-		EVENT_VSCROLL // "Scroll up", "Scroll down" transition effects
-		} evt_type;
-	int pos_x, pos_y; // position
-	int org_x, org_y; // origin
-	char have_origin; // origin is explicitly defined; if 0, get_base_point() is used
-	double scale_x, scale_y;
-	double hspacing; // distance between letters, in pixels
-	double border; // outline width
-	uint32_t c[4]; // colors(Primary, Secondary, so on) in RGBA
-	int clip_x0, clip_y0, clip_x1, clip_y1;
-	char detect_collisions;
-	uint32_t fade; // alpha from \fad
-	char be; // blur edges
-	int shadow;
-
-	effect_t effect_type;
-	int effect_timing;
-	int effect_skip_timing;
-
-	enum { SCROLL_LR, // left-to-right
-	       SCROLL_RL,
-	       SCROLL_TB, // top-to-bottom
-	       SCROLL_BT
-	       } scroll_direction; // for EVENT_HSCROLL, EVENT_VSCROLL
-	int scroll_shift;
-
-	// face properties
-	char* family;
-	unsigned bold;
-	unsigned italic;
-	
-} render_context_t;
-
-// frame-global data
-typedef struct frame_context_s {
-	ass_renderer_t* ass_priv;
-	int width, height; // screen dimensions
-	int orig_height; // frame height ( = screen height - margins )
-	int orig_width; // frame width ( = screen width - margins )
-	ass_track_t* track;
-	long long time; // frame's timestamp, ms
-	double font_scale;
-	double font_scale_x; // x scale applied to all glyphs to preserve text aspect ratio
-	double border_scale;
-} frame_context_t;
-
-static ass_renderer_t* ass_renderer;
-static ass_settings_t* global_settings;
-static text_info_t text_info;
-static render_context_t render_context;
-static frame_context_t frame_context;
-
-struct render_priv_s {
-	int top, height;
-	int render_id;
-};
-
-static void ass_lazy_track_init(void)
-{
-	ass_track_t* track = frame_context.track;
-	if (track->PlayResX && track->PlayResY)
-		return;
-	if (!track->PlayResX && !track->PlayResY) {
-		mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_NeitherPlayResXNorPlayResYDefined);
-		track->PlayResX = 384;
-		track->PlayResY = 288;
-	} else {
-		double orig_aspect = (global_settings->aspect * frame_context.height * frame_context.orig_width) /
-			frame_context.orig_height / frame_context.width;
-		if (!track->PlayResY) {
-			track->PlayResY = track->PlayResX / orig_aspect + .5;
-			mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_PlayResYUndefinedSettingY, track->PlayResY);
-		} else if (!track->PlayResX) {
-			track->PlayResX = track->PlayResY * orig_aspect + .5;
-			mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_PlayResXUndefinedSettingX, track->PlayResX);
-		}
-	}
-}
-
-ass_renderer_t* ass_renderer_init(ass_library_t* library)
-{
-	int error;
-	FT_Library ft;
-	ass_renderer_t* priv = 0;
-	
-	memset(&render_context, 0, sizeof(render_context));
-	memset(&frame_context, 0, sizeof(frame_context));
-	memset(&text_info, 0, sizeof(text_info));
-
-	error = FT_Init_FreeType( &ft );
-	if ( error ) { 
-		mp_msg(MSGT_ASS, MSGL_FATAL, MSGTR_LIBASS_FT_Init_FreeTypeFailed);
-		goto ass_init_exit;
-	}
-
-	priv = calloc(1, sizeof(ass_renderer_t));
-	if (!priv) {
-		FT_Done_FreeType(ft);
-		goto ass_init_exit;
-	}
-
-	priv->synth_priv = ass_synth_init();
-
-	priv->library = library;
-	priv->ftlibrary = ft;
-	// images_root and related stuff is zero-filled in calloc
-	
-	ass_font_cache_init();
-	ass_bitmap_cache_init();
-	ass_glyph_cache_init();
-
-	text_info.glyphs = calloc(MAX_GLYPHS, sizeof(glyph_info_t));
-	
-ass_init_exit:
-	if (priv) mp_msg(MSGT_ASS, MSGL_INFO, MSGTR_LIBASS_Init);
-	else mp_msg(MSGT_ASS, MSGL_ERR, MSGTR_LIBASS_InitFailed);
-
-	return priv;
-}
-
-void ass_renderer_done(ass_renderer_t* priv)
-{
-	ass_font_cache_done();
-	ass_bitmap_cache_done();
-	ass_glyph_cache_done();
-	if (render_context.stroker) {
-		FT_Stroker_Done(render_context.stroker);
-		render_context.stroker = 0;
-	}
-	if (priv && priv->ftlibrary) FT_Done_FreeType(priv->ftlibrary);
-	if (priv && priv->fontconfig_priv) fontconfig_done(priv->fontconfig_priv);
-	if (priv && priv->synth_priv) ass_synth_done(priv->synth_priv);
-	if (priv && priv->eimg) free(priv->eimg);
-	if (priv) free(priv);
-	if (text_info.glyphs) free(text_info.glyphs);
-}
-
-/**
- * \brief Create a new ass_image_t
- * Parameters are the same as ass_image_t fields.
- */
-static ass_image_t* my_draw_bitmap(unsigned char* bitmap, int bitmap_w, int bitmap_h, int stride, int dst_x, int dst_y, uint32_t color)
-{
-	ass_image_t* img = calloc(1, sizeof(ass_image_t));
-	
-	img->w = bitmap_w;
-	img->h = bitmap_h;
-	img->stride = stride;
-	img->bitmap = bitmap;
-	img->color = color;
-	img->dst_x = dst_x;
-	img->dst_y = dst_y;
-
-	return img;
-}
-
-/**
- * \brief convert bitmap glyph into ass_image_t struct(s)
- * \param bit freetype bitmap glyph, FT_PIXEL_MODE_GRAY
- * \param dst_x bitmap x coordinate in video frame
- * \param dst_y bitmap y coordinate in video frame
- * \param color first color, RGBA
- * \param color2 second color, RGBA
- * \param brk x coordinate relative to glyph origin, color is used to the left of brk, color2 - to the right
- * \param tail pointer to the last image's next field, head of the generated list should be stored here
- * \return pointer to the new list tail
- * Performs clipping. Uses my_draw_bitmap for actual bitmap convertion.
- */
-static ass_image_t** render_glyph(bitmap_t* bm, int dst_x, int dst_y, uint32_t color, uint32_t color2, int brk, ass_image_t** tail)
-{
-	// brk is relative to dst_x
-	// color = color left of brk
-	// color2 = color right of brk
-	int b_x0, b_y0, b_x1, b_y1; // visible part of the bitmap
-	int clip_x0, clip_y0, clip_x1, clip_y1;
-	int tmp;
-	ass_image_t* img;
-
-	dst_x += bm->left;
-	dst_y += bm->top;
-	brk -= bm->left;
-	
-	// clipping
-	clip_x0 = render_context.clip_x0;
-	clip_y0 = render_context.clip_y0;
-	clip_x1 = render_context.clip_x1;
-	clip_y1 = render_context.clip_y1;
-	b_x0 = 0;
-	b_y0 = 0;
-	b_x1 = bm->w;
-	b_y1 = bm->h;
-	
-	tmp = dst_x - clip_x0;
-	if (tmp < 0) {
-		mp_msg(MSGT_ASS, MSGL_DBG2, "clip left\n");
-		b_x0 = - tmp;
-	}
-	tmp = dst_y - clip_y0;
-	if (tmp < 0) {
-		mp_msg(MSGT_ASS, MSGL_DBG2, "clip top\n");
-		b_y0 = - tmp;
-	}
-	tmp = clip_x1 - dst_x - bm->w;
-	if (tmp < 0) {
-		mp_msg(MSGT_ASS, MSGL_DBG2, "clip right\n");
-		b_x1 = bm->w + tmp;
-	}
-	tmp = clip_y1 - dst_y - bm->h;
-	if (tmp < 0) {
-		mp_msg(MSGT_ASS, MSGL_DBG2, "clip bottom\n");
-		b_y1 = bm->h + tmp;
-	}
-	
-	if ((b_y0 >= b_y1) || (b_x0 >= b_x1))
-		return tail;
-
-	if (brk > b_x0) { // draw left part
-		if (brk > b_x1) brk = b_x1;
-		img = my_draw_bitmap(bm->buffer + bm->w * b_y0 + b_x0, 
-			brk - b_x0, b_y1 - b_y0, bm->w,
-			dst_x + b_x0, dst_y + b_y0, color);
-		*tail = img;
-		tail = &img->next;
-	}
-	if (brk < b_x1) { // draw right part
-		if (brk < b_x0) brk = b_x0;
-		img = my_draw_bitmap(bm->buffer + bm->w * b_y0 + brk, 
-			b_x1 - brk, b_y1 - b_y0, bm->w,
-			dst_x + brk, dst_y + b_y0, color2);
-		*tail = img;
-		tail = &img->next;
-	}
-	return tail;
-}
-
-/**
- * \brief Convert text_info_t struct to ass_image_t list
- * Splits glyphs in halves when needed (for \kf karaoke).
- */
-static ass_image_t* render_text(text_info_t* text_info, int dst_x, int dst_y)
-{
-	int pen_x, pen_y;
-	int i;
-	bitmap_t* bm;
-	ass_image_t* head;
-	ass_image_t** tail = &head;
-
-	for (i = 0; i < text_info->length; ++i) {
-		glyph_info_t* info = text_info->glyphs + i;
-		if ((info->symbol == 0) || (info->symbol == '\n') || !info->bm_s || (info->shadow == 0))
-			continue;
-
-		pen_x = dst_x + info->pos.x + info->shadow;
-		pen_y = dst_y + info->pos.y + info->shadow;
-		bm = info->bm_s;
-
-		tail = render_glyph(bm, pen_x, pen_y, info->c[3], 0, 1000000, tail);
-	}
-
-	for (i = 0; i < text_info->length; ++i) {
-		glyph_info_t* info = text_info->glyphs + i;
-		if ((info->symbol == 0) || (info->symbol == '\n') || !info->bm_o)
-			continue;
-
-		pen_x = dst_x + info->pos.x;
-		pen_y = dst_y + info->pos.y;
-		bm = info->bm_o;
-		
-		if ((info->effect_type == EF_KARAOKE_KO) && (info->effect_timing <= info->bbox.xMax)) {
-			// do nothing
-		} else
-			tail = render_glyph(bm, pen_x, pen_y, info->c[2], 0, 1000000, tail);
-	}
-	for (i = 0; i < text_info->length; ++i) {
-		glyph_info_t* info = text_info->glyphs + i;
-		if ((info->symbol == 0) || (info->symbol == '\n') || !info->bm)
-			continue;
-
-		pen_x = dst_x + info->pos.x;
-		pen_y = dst_y + info->pos.y;
-		bm = info->bm;
-
-		if ((info->effect_type == EF_KARAOKE) || (info->effect_type == EF_KARAOKE_KO)) {
-			if (info->effect_timing > info->bbox.xMax)
-				tail = render_glyph(bm, pen_x, pen_y, info->c[0], 0, 1000000, tail);
-			else
-				tail = render_glyph(bm, pen_x, pen_y, info->c[1], 0, 1000000, tail);
-		} else if (info->effect_type == EF_KARAOKE_KF) {
-			tail = render_glyph(bm, pen_x, pen_y, info->c[0], info->c[1], info->effect_timing, tail);
-		} else
-			tail = render_glyph(bm, pen_x, pen_y, info->c[0], 0, 1000000, tail);
-	}
-
-	*tail = 0;
-	return head;
-}
-
-/**
- * \brief Mapping between script and screen coordinates
- */
-static int x2scr(int x) {
-	return x*frame_context.orig_width / frame_context.track->PlayResX + global_settings->left_margin;
-}
-/**
- * \brief Mapping between script and screen coordinates
- */
-static int y2scr(int y) {
-	return y * frame_context.orig_height / frame_context.track->PlayResY + global_settings->top_margin;
-}
-// the same for toptitles
-static int y2scr_top(int y) {
-	if (global_settings->use_margins)
-		return y * frame_context.orig_height / frame_context.track->PlayResY;
-	else
-		return y * frame_context.orig_height / frame_context.track->PlayResY + global_settings->top_margin;
-}
-// the same for subtitles
-static int y2scr_sub(int y) {
-	if (global_settings->use_margins)
-		return y * frame_context.orig_height / frame_context.track->PlayResY +
-		       global_settings->top_margin + global_settings->bottom_margin;
-	else
-		return y * frame_context.orig_height / frame_context.track->PlayResY + global_settings->top_margin;
-}
-
-static void compute_string_bbox( text_info_t* info, FT_BBox *abbox ) {
-	FT_BBox bbox;
-	int i;
-	
-	if (text_info.length > 0) {
-		bbox.xMin = 32000;
-		bbox.xMax = -32000;
-		bbox.yMin = - d6_to_int(text_info.lines[0].asc) + text_info.glyphs[0].pos.y;
-		bbox.yMax = d6_to_int(text_info.height - text_info.lines[0].asc) + text_info.glyphs[0].pos.y;
-
-		for (i = 0; i < text_info.length; ++i) {
-			int s = text_info.glyphs[i].pos.x;
-			int e = s + d6_to_int(text_info.glyphs[i].advance.x);
-			bbox.xMin = FFMIN(bbox.xMin, s);
-			bbox.xMax = FFMAX(bbox.xMax, e);
-		}
-	} else
-		bbox.xMin = bbox.xMax = bbox.yMin = bbox.yMax = 0;
-
-	/* return string bbox */
-	*abbox = bbox;
-}
-
-
-/**
- * \brief Check if starting part of (*p) matches sample. If true, shift p to the first symbol after the matching part.
- */
-static inline int mystrcmp(char** p, const char* sample) {
-	int len = strlen(sample);
-	if (strncmp(*p, sample, len) == 0) {
-		(*p) += len;
-		return 1;
-	} else
-		return 0;
-}
-
-static void change_font_size(double sz)
-{
-	double size = sz * frame_context.font_scale;
-
-	if (size < 1)
-		size = 1;
-	else if (size > frame_context.height * 2)
-		size = frame_context.height * 2;
-
-	ass_font_set_size(render_context.font, size);
-
-	render_context.font_size = sz;
-}
-
-/**
- * \brief Change current font, using setting from render_context.
- */
-static void update_font(void)
-{
-	unsigned val;
-	ass_renderer_t* priv = frame_context.ass_priv;
-	ass_font_desc_t desc;
-	desc.family = strdup(render_context.family);
-
-	val = render_context.bold;
-	// 0 = normal, 1 = bold, >1 = exact weight
-	if (val == 0) val = 80; // normal
-	else if (val == 1) val = 200; // bold
-	desc.bold = val;
-
-	val = render_context.italic;
-	if (val == 0) val = 0; // normal
-	else if (val == 1) val = 110; //italic
-	desc.italic = val;
-
-	render_context.font = ass_font_new(priv->library, priv->ftlibrary, priv->fontconfig_priv, &desc);
-	free(desc.family);
-	
-	if (render_context.font)
-		change_font_size(render_context.font_size);
-}
-
-/**
- * \brief Change border width
- * negative value resets border to style value
- */
-static void change_border(double border)
-{
-	int b;
-	if (!render_context.font) return;
-
-	if (border < 0) {
-		if (render_context.style->BorderStyle == 1) {
-			if (render_context.style->Outline == 0 && render_context.style->Shadow > 0)
-				border = 1.;
-			else
-				border = render_context.style->Outline;
-		} else
-			border = 1.;
-	}
-	render_context.border = border;
-
-	b = 64 * border * frame_context.border_scale;
-	if (b > 0) {
-		if (!render_context.stroker) {
-			int error;
-#if (FREETYPE_MAJOR > 2) || ((FREETYPE_MAJOR == 2) && (FREETYPE_MINOR > 1))
-			error = FT_Stroker_New( ass_renderer->ftlibrary, &render_context.stroker );
-#else // < 2.2
-			error = FT_Stroker_New( render_context.font->faces[0]->memory, &render_context.stroker );
-#endif
-			if (error) {
-				mp_msg(MSGT_ASS, MSGL_V, "failed to get stroker\n");
-				render_context.stroker = 0;
-			}
-		}
-		if (render_context.stroker)
-			FT_Stroker_Set( render_context.stroker, b,
-					FT_STROKER_LINECAP_ROUND,
-					FT_STROKER_LINEJOIN_ROUND,
-					0 );
-	} else {
-		FT_Stroker_Done(render_context.stroker);
-		render_context.stroker = 0;
-	}
-}
-
-#define _r(c)  ((c)>>24)
-#define _g(c)  (((c)>>16)&0xFF)
-#define _b(c)  (((c)>>8)&0xFF)
-#define _a(c)  ((c)&0xFF)
-
-/**
- * \brief Calculate a weighted average of two colors
- * calculates c1*(1-a) + c2*a, but separately for each component except alpha
- */
-static void change_color(uint32_t* var, uint32_t new, double pwr)
-{
-	(*var)= ((uint32_t)(_r(*var) * (1 - pwr) + _r(new) * pwr) << 24) +
-		((uint32_t)(_g(*var) * (1 - pwr) + _g(new) * pwr) << 16) +
-		((uint32_t)(_b(*var) * (1 - pwr) + _b(new) * pwr) << 8) +
-		_a(*var);
-}
-
-// like change_color, but for alpha component only
-static void change_alpha(uint32_t* var, uint32_t new, double pwr)
-{
-	*var = (_r(*var) << 24) + (_g(*var) << 16) + (_b(*var) << 8) + (_a(*var) * (1 - pwr) + _a(new) * pwr);
-}
-
-/**
- * \brief Multiply two alpha values
- * \param a first value
- * \param b second value
- * \return result of multiplication
- * Parameters and result are limited by 0xFF.
- */
-static uint32_t mult_alpha(uint32_t a, uint32_t b)
-{
-	return 0xFF - (0xFF - a) * (0xFF - b) / 0xFF;
-}
-
-/**
- * \brief Calculate alpha value by piecewise linear function
- * Used for \fad, \fade implementation.
- */
-static unsigned interpolate_alpha(long long now, 
-		long long t1, long long t2, long long t3, long long t4,
-		unsigned a1, unsigned a2, unsigned a3)
-{
-	unsigned a;
-	double cf;
-	if (now <= t1) {
-		a = a1;
-	} else if (now >= t4) {
-		a = a3;
-	} else if (now < t2) { // and > t1
-		cf = ((double)(now - t1)) / (t2 - t1);
-		a = a1 * (1 - cf) + a2 * cf;
-	} else if (now > t3) {
-		cf = ((double)(now - t3)) / (t4 - t3);
-		a = a2 * (1 - cf) + a3 * cf;
-	} else { // t2 <= now <= t3
-		a = a2;
-	}
-
-	return a;
-}
-
-static void reset_render_context(void);
-
-/**
- * \brief Parse style override tag.
- * \param p string to parse
- * \param pwr multiplier for some tag effects (comes from \t tags)
- */
-static char* parse_tag(char* p, double pwr) {
-#define skip_all(x) if (*p == (x)) ++p; else { \
-	while ((*p != (x)) && (*p != '}') && (*p != 0)) {++p;} }
-#define skip(x) if (*p == (x)) ++p; else { return p; }
-	
-	skip_all('\\');
-	if ((*p == '}') || (*p == 0))
-		return p;
-
-	if (mystrcmp(&p, "fsc")) {
-		char tp = *p++;
-		double val;
-		if (tp == 'x') {
-			if (mystrtod(&p, &val)) {
-				val /= 100;
-				render_context.scale_x = render_context.scale_x * ( 1 - pwr) + val * pwr;
-			} else
-				render_context.scale_x = render_context.style->ScaleX;
-		} else if (tp == 'y') {
-			if (mystrtod(&p, &val)) {
-				val /= 100;
-				render_context.scale_y = render_context.scale_y * ( 1 - pwr) + val * pwr;
-			} else
-				render_context.scale_y = render_context.style->ScaleY;
-		}
-	} else if (mystrcmp(&p, "fsp")) {
-		double val;
-		if (mystrtod(&p, &val))
-			render_context.hspacing = render_context.hspacing * ( 1 - pwr ) + val * pwr;
-		else
-			render_context.hspacing = render_context.style->Spacing;
-	} else if (mystrcmp(&p, "fs")) {
-		double val;
-		if (mystrtod(&p, &val))
-			val = render_context.font_size * ( 1 - pwr ) + val * pwr;
-		else
-			val = render_context.style->FontSize;
-		if (render_context.font)
-			change_font_size(val);
-	} else if (mystrcmp(&p, "bord")) {
-		double val;
-		if (mystrtod(&p, &val))
-			val = render_context.border * ( 1 - pwr ) + val * pwr;
-		else
-			val = -1.; // reset to default
-		change_border(val);
-	} else if (mystrcmp(&p, "move")) {
-		int x1, x2, y1, y2;
-		long long t1, t2, delta_t, t;
-		int x, y;
-		double k;
-		skip('(');
-		x1 = strtol(p, &p, 10);
-		skip(',');
-		y1 = strtol(p, &p, 10);
-		skip(',');
-		x2 = strtol(p, &p, 10);
-		skip(',');
-		y2 = strtol(p, &p, 10);
-		if (*p == ',') {
-			skip(',');
-			t1 = strtoll(p, &p, 10);
-			skip(',');
-			t2 = strtoll(p, &p, 10);
-			mp_msg(MSGT_ASS, MSGL_DBG2, "movement6: (%d, %d) -> (%d, %d), (%" PRId64 " .. %" PRId64 ")\n", 
-				x1, y1, x2, y2, (int64_t)t1, (int64_t)t2);
-		} else {
-			t1 = 0;
-			t2 = render_context.event->Duration;
-			mp_msg(MSGT_ASS, MSGL_DBG2, "movement: (%d, %d) -> (%d, %d)\n", x1, y1, x2, y2);
-		}
-		skip(')');
-		delta_t = t2 - t1;
-		t = frame_context.time - render_context.event->Start;
-		if (t < t1)
-			k = 0.;
-		else if (t > t2)
-			k = 1.;
-		else k = ((double)(t - t1)) / delta_t;
-		x = k * (x2 - x1) + x1;
-		y = k * (y2 - y1) + y1;
-		render_context.pos_x = x;
-		render_context.pos_y = y;
-		render_context.detect_collisions = 0;
-		render_context.evt_type = EVENT_POSITIONED;
-	} else if (mystrcmp(&p, "frx")) {
-		double val;
-		if (mystrtod(&p, &val)) {
-			val *= M_PI / 180;
-			render_context.frx = val * pwr + render_context.frx * (1-pwr);
-		} else
-			render_context.frx = 0.;
-	} else if (mystrcmp(&p, "fry")) {
-		double val;
-		if (mystrtod(&p, &val)) {
-			val *= M_PI / 180;
-			render_context.fry = val * pwr + render_context.fry * (1-pwr);
-		} else
-			render_context.fry = 0.;
-	} else if (mystrcmp(&p, "frz") || mystrcmp(&p, "fr")) {
-		double val;
-		if (mystrtod(&p, &val)) {
-			val *= M_PI / 180;
-			render_context.frz = val * pwr + render_context.frz * (1-pwr);
-		} else
-			render_context.frz = M_PI * render_context.style->Angle / 180.;
-	} else if (mystrcmp(&p, "fn")) {
-		char* start = p;
-		char* family;
-		skip_all('\\');
-		if (p > start) {
-			family = malloc(p - start + 1);
-			strncpy(family, start, p - start);
-			family[p - start] = '\0';
-		} else
-			family = strdup(render_context.style->FontName);
-		if (render_context.family)
-			free(render_context.family);
-		render_context.family = family;
-		update_font();
-	} else if (mystrcmp(&p, "alpha")) {
-		uint32_t val;
-		int i;
-		if (strtocolor(&p, &val)) {
-			unsigned char a = val >> 24;
-			for (i = 0; i < 4; ++i)
-				change_alpha(&render_context.c[i], a, pwr);
-		} else {
-			change_alpha(&render_context.c[0], render_context.style->PrimaryColour, pwr);
-			change_alpha(&render_context.c[1], render_context.style->SecondaryColour, pwr);
-			change_alpha(&render_context.c[2], render_context.style->OutlineColour, pwr);
-			change_alpha(&render_context.c[3], render_context.style->BackColour, pwr);
-		}
-		// FIXME: simplify
-	} else if (mystrcmp(&p, "an")) {
-		int val;
-		if (mystrtoi(&p, 10, &val) && val) {
-			int v = (val - 1) / 3; // 0, 1 or 2 for vertical alignment
-			mp_msg(MSGT_ASS, MSGL_DBG2, "an %d\n", val);
-			if (v != 0) v = 3 - v;
-			val = ((val - 1) % 3) + 1; // horizontal alignment
-			val += v*4;
-			mp_msg(MSGT_ASS, MSGL_DBG2, "align %d\n", val);
-			render_context.alignment = val;
-		} else
-			render_context.alignment = render_context.style->Alignment;
-	} else if (mystrcmp(&p, "a")) {
-		int val;
-		if (mystrtoi(&p, 10, &val) && val)
-			render_context.alignment = val;
-		else
-			render_context.alignment = render_context.style->Alignment;
-	} else if (mystrcmp(&p, "pos")) {
-		int v1, v2;
-		skip('(');
-		v1 = strtol(p, &p, 10);
-		skip(',');
-		v2 = strtol(p, &p, 10);
-		skip(')');
-		mp_msg(MSGT_ASS, MSGL_DBG2, "pos(%d, %d)\n", v1, v2);
-		render_context.evt_type = EVENT_POSITIONED;
-		render_context.detect_collisions = 0;
-		render_context.pos_x = v1;
-		render_context.pos_y = v2;
-	} else if (mystrcmp(&p, "fad")) {
-		int a1, a2, a3;
-		long long t1, t2, t3, t4;
-		if (*p == 'e') ++p; // either \fad or \fade
-		skip('(');
-		a1 = strtol(p, &p, 10);
-		skip(',');
-		a2 = strtol(p, &p, 10);
-		if (*p == ')') {
-			// 2-argument version (\fad, according to specs)
-			// a1 and a2 are fade-in and fade-out durations
-			t1 = 0;
-			t4 = render_context.event->Duration;
-			t2 = a1;
-			t3 = t4 - a2;
-			a1 = 0xFF;
-			a2 = 0;
-			a3 = 0xFF;
-		} else {
-			// 6-argument version (\fade)
-			// a1 and a2 (and a3) are opacity values
-			skip(',');
-			a3 = strtol(p, &p, 10);
-			skip(',');
-			t1 = strtoll(p, &p, 10);
-			skip(',');
-			t2 = strtoll(p, &p, 10);
-			skip(',');
-			t3 = strtoll(p, &p, 10);
-			skip(',');
-			t4 = strtoll(p, &p, 10);
-		}
-		skip(')');
-		render_context.fade = interpolate_alpha(frame_context.time - render_context.event->Start, t1, t2, t3, t4, a1, a2, a3);
-	} else if (mystrcmp(&p, "org")) {
-		int v1, v2;
-		skip('(');
-		v1 = strtol(p, &p, 10);
-		skip(',');
-		v2 = strtol(p, &p, 10);
-		skip(')');
-		mp_msg(MSGT_ASS, MSGL_DBG2, "org(%d, %d)\n", v1, v2);
-		//				render_context.evt_type = EVENT_POSITIONED;
-		render_context.org_x = v1;
-		render_context.org_y = v2;
-		render_context.have_origin = 1;
-	} else if (mystrcmp(&p, "t")) {
-		double v[3];
-		int v1, v2;
-		double v3;
-		int cnt;
-		long long t1, t2, t, delta_t;
-		double k;
-		skip('(');
-		for (cnt = 0; cnt < 3; ++cnt) {
-			if (*p == '\\')
-				break;
-			v[cnt] = strtod(p, &p);
-			skip(',');
-		}
-		if (cnt == 3) {
-			v1 = v[0]; v2 = v[1]; v3 = v[2];
-		} else if (cnt == 2) {
-			v1 = v[0]; v2 = v[1]; v3 = 1.;
-		} else if (cnt == 1) {
-			v1 = 0; v2 = render_context.event->Duration; v3 = v[0];
-		} else { // cnt == 0
-			v1 = 0; v2 = render_context.event->Duration; v3 = 1.;
-		}
-		render_context.detect_collisions = 0;
-		t1 = v1;
-		t2 = v2;
-		delta_t = v2 - v1;
-		if (v3 < 0.)
-			v3 = 0.;
-		t = frame_context.time - render_context.event->Start; // FIXME: move to render_context
-		if (t <= t1)
-			k = 0.;
-		else if (t >= t2)
-			k = 1.;
-		else {
-			assert(delta_t != 0.);
-			k = pow(((double)(t - t1)) / delta_t, v3);
-		}
-		while (*p == '\\')
-			p = parse_tag(p, k); // maybe k*pwr ? no, specs forbid nested \t's 
-		skip_all(')'); // FIXME: better skip(')'), but much more tags support required
-	} else if (mystrcmp(&p, "clip")) {
-		int x0, y0, x1, y1;
-		int res = 1;
-		skip('(');
-		res &= mystrtoi(&p, 10, &x0);
-		skip(',');
-		res &= mystrtoi(&p, 10, &y0);
-		skip(',');
-		res &= mystrtoi(&p, 10, &x1);
-		skip(',');
-		res &= mystrtoi(&p, 10, &y1);
-		skip(')');
-		if (res) {
-			render_context.clip_x0 = render_context.clip_x0 * (1-pwr) + x0 * pwr;
-			render_context.clip_x1 = render_context.clip_x1 * (1-pwr) + x1 * pwr;
-			render_context.clip_y0 = render_context.clip_y0 * (1-pwr) + y0 * pwr;
-			render_context.clip_y1 = render_context.clip_y1 * (1-pwr) + y1 * pwr;
-		} else {
-			render_context.clip_x0 = 0;
-			render_context.clip_y0 = 0;
-			render_context.clip_x1 = frame_context.track->PlayResX;
-			render_context.clip_y1 = frame_context.track->PlayResY;
-		}
-	} else if (mystrcmp(&p, "c")) {
-		uint32_t val;
-		if (!strtocolor(&p, &val))
-			val = render_context.style->PrimaryColour;
-		mp_msg(MSGT_ASS, MSGL_DBG2, "color: %X\n", val);
-		change_color(&render_context.c[0], val, pwr);
-	} else if ((*p >= '1') && (*p <= '4') && (++p) && (mystrcmp(&p, "c") || mystrcmp(&p, "a"))) {
-		char n = *(p-2);
-		int cidx = n - '1';
-		char cmd = *(p-1);
-		uint32_t val;
-		assert((n >= '1') && (n <= '4'));
-		if (!strtocolor(&p, &val))
-			switch(n) {
-				case '1': val = render_context.style->PrimaryColour; break;
-				case '2': val = render_context.style->SecondaryColour; break;
-				case '3': val = render_context.style->OutlineColour; break;
-				case '4': val = render_context.style->BackColour; break;
-				default : val = 0; break; // impossible due to assert; avoid compilation warning
-			}
-		switch (cmd) {
-			case 'c': change_color(render_context.c + cidx, val, pwr); break;
-			case 'a': change_alpha(render_context.c + cidx, val >> 24, pwr); break;
-			default: mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_BadCommand, n, cmd); break;
-		}
-		mp_msg(MSGT_ASS, MSGL_DBG2, "single c/a at %f: %c%c = %X   \n", pwr, n, cmd, render_context.c[cidx]);
-	} else if (mystrcmp(&p, "r")) {
-		reset_render_context();
-	} else if (mystrcmp(&p, "be")) {
-		int val;
-		if (mystrtoi(&p, 10, &val))
-			render_context.be = val ? 1 : 0;
-		else
-			render_context.be = 0;
-	} else if (mystrcmp(&p, "b")) {
-		int b;
-		if (mystrtoi(&p, 10, &b)) {
-			if (pwr >= .5)
-				render_context.bold = b;
-		} else
-			render_context.bold = render_context.style->Bold;
-		update_font();
-	} else if (mystrcmp(&p, "i")) {
-		int i;
-		if (mystrtoi(&p, 10, &i)) {
-			if (pwr >= .5)
-				render_context.italic = i;
-		} else
-			render_context.italic = render_context.style->Italic;
-		update_font();
-	} else if (mystrcmp(&p, "kf") || mystrcmp(&p, "K")) {
-		int val = strtol(p, &p, 10);
-		render_context.effect_type = EF_KARAOKE_KF;
-		if (render_context.effect_timing)
-			render_context.effect_skip_timing += render_context.effect_timing;
-		render_context.effect_timing = val * 10;
-	} else if (mystrcmp(&p, "ko")) {
-		int val = strtol(p, &p, 10);
-		render_context.effect_type = EF_KARAOKE_KO;
-		if (render_context.effect_timing)
-			render_context.effect_skip_timing += render_context.effect_timing;
-		render_context.effect_timing = val * 10;
-	} else if (mystrcmp(&p, "k")) {
-		int val = strtol(p, &p, 10);
-		render_context.effect_type = EF_KARAOKE;
-		if (render_context.effect_timing)
-			render_context.effect_skip_timing += render_context.effect_timing;
-		render_context.effect_timing = val * 10;
-	} else if (mystrcmp(&p, "shad")) {
-		int val;
-		if (mystrtoi(&p, 10, &val))
-			render_context.shadow = val;
-		else
-			render_context.shadow = render_context.style->Shadow;
-	}
-
-	return p;
-
-#undef skip
-#undef skip_all
-}
-
-/**
- * \brief Get next ucs4 char from string, parsing and executing style overrides
- * \param str string pointer
- * \return ucs4 code of the next char
- * On return str points to the unparsed part of the string
- */
-static unsigned get_next_char(char** str)
-{
-	char* p = *str;
-	unsigned chr;
-	if (*p == '{') { // '\0' goes here
-		p++;
-		while (1) {
-			p = parse_tag(p, 1.);
-			if (*p == '}') { // end of tag
-				p++;
-				if (*p == '{') {
-					p++;
-					continue;
-				} else
-					break;
-			} else if (*p != '\\')
-				mp_msg(MSGT_ASS, MSGL_V, "Unable to parse: \"%s\" \n", p);
-			if (*p == 0)
-				break;
-		}
-	}
-	if (*p == '\t') {
-		++p;
-		*str = p;
-		return ' ';
-	}
-	if (*p == '\\') {
-		if ((*(p+1) == 'N') || ((*(p+1) == 'n') && (frame_context.track->WrapStyle == 2))) {
-			p += 2;
-			*str = p;
-			return '\n';
-		} else if (*(p+1) == 'n') {
-			p += 2;
-			*str = p;
-			return ' ';
-		}
-	}
-	chr = utf8_get_char(&p);
-	*str = p;
-	return chr;
-}
-
-static void apply_transition_effects(ass_event_t* event)
-{
-	int v[4];
-	int cnt;
-	char* p = event->Effect;
-
-	if (!p || !*p) return;
-
-	cnt = 0;
-	while (cnt < 4 && (p = strchr(p, ';'))) {
-		v[cnt++] = atoi(++p);
-	}
-	
-	if (strncmp(event->Effect, "Banner;", 7) == 0) {
-		int delay;
-		if (cnt < 1) {
-			mp_msg(MSGT_ASS, MSGL_V, "Error parsing effect: %s \n", event->Effect);
-			return;
-		}
-		if (cnt >= 2 && v[1] == 0) // right-to-left
-			render_context.scroll_direction = SCROLL_RL;
-		else // left-to-right
-			render_context.scroll_direction = SCROLL_LR;
-
-		delay = v[0];
-		if (delay == 0) delay = 1; // ?
-		render_context.scroll_shift = (frame_context.time - render_context.event->Start) / delay;
-		render_context.evt_type = EVENT_HSCROLL;
-		return;
-	}
-
-	if (strncmp(event->Effect, "Scroll up;", 10) == 0) {
-		render_context.scroll_direction = SCROLL_BT;
-	} else if (strncmp(event->Effect, "Scroll down;", 12) == 0) {
-		render_context.scroll_direction = SCROLL_TB;
-	} else {
-		mp_msg(MSGT_ASS, MSGL_V, "Unknown transition effect: %s \n", event->Effect);
-		return;
-	}
-	// parse scroll up/down parameters
-	{
-		int delay;
-		int y0, y1;
-		if (cnt < 3) {
-			mp_msg(MSGT_ASS, MSGL_V, "Error parsing effect: %s \n", event->Effect);
-			return;
-		}
-		delay = v[2];
-		if (delay == 0) delay = 1; // ?
-		render_context.scroll_shift = (frame_context.time - render_context.event->Start) / delay;
-		if (v[0] < v[1]) {
-			y0 = v[0]; y1 = v[1];
-		} else {
-			y0 = v[1]; y1 = v[0];
-		}
-		if (y1 == 0)
-			y1 = frame_context.track->PlayResY; // y0=y1=0 means fullscreen scrolling
-		render_context.clip_y0 = y0;
-		render_context.clip_y1 = y1;
-		render_context.evt_type = EVENT_VSCROLL;
-		render_context.detect_collisions = 0;
-	}
-
-}
-
-/**
- * \brief partially reset render_context to style values
- * Works like {\r}: resets some style overrides
- */
-static void reset_render_context(void)
-{
-	render_context.c[0] = render_context.style->PrimaryColour;
-	render_context.c[1] = render_context.style->SecondaryColour;
-	render_context.c[2] = render_context.style->OutlineColour;
-	render_context.c[3] = render_context.style->BackColour;
-	render_context.font_size = render_context.style->FontSize;
-
-	if (render_context.family)
-		free(render_context.family);
-	render_context.family = strdup(render_context.style->FontName);
-	render_context.bold = render_context.style->Bold;
-	render_context.italic = render_context.style->Italic;
-	update_font();
-
-	change_border(-1.);
-	render_context.scale_x = render_context.style->ScaleX;
-	render_context.scale_y = render_context.style->ScaleY;
-	render_context.hspacing = render_context.style->Spacing;
-	render_context.be = 0;
-	render_context.shadow = render_context.style->Shadow;
-	render_context.frx = render_context.fry = 0.;
-	render_context.frz = M_PI * render_context.style->Angle / 180.;
-
-	// FIXME: does not reset unsupported attributes.
-}
-
-/**
- * \brief Start new event. Reset render_context.
- */
-static void init_render_context(ass_event_t* event)
-{
-	render_context.event = event;
-	render_context.style = frame_context.track->styles + event->Style;
-
-	reset_render_context();
-
-	render_context.evt_type = EVENT_NORMAL;
-	render_context.alignment = render_context.style->Alignment;
-	render_context.pos_x = 0;
-	render_context.pos_y = 0;
-	render_context.org_x = 0;
-	render_context.org_y = 0;
-	render_context.have_origin = 0;
-	render_context.clip_x0 = 0;
-	render_context.clip_y0 = 0;
-	render_context.clip_x1 = frame_context.track->PlayResX;
-	render_context.clip_y1 = frame_context.track->PlayResY;
-	render_context.detect_collisions = 1;
-	render_context.fade = 0;
-	render_context.effect_type = EF_NONE;
-	render_context.effect_timing = 0;
-	render_context.effect_skip_timing = 0;
-	
-	apply_transition_effects(event);
-}
-
-static void free_render_context(void)
-{
-}
-
-/**
- * \brief Get normal and outline (border) glyphs
- * \param symbol ucs4 char
- * \param info out: struct filled with extracted data
- * \param advance subpixel shift vector used for cache lookup
- * Tries to get both glyphs from cache.
- * If they can't be found, gets a glyph from font face, generates outline with FT_Stroker,
- * and add them to cache.
- * The glyphs are returned in info->glyph and info->outline_glyph
- */
-static void get_outline_glyph(int symbol, glyph_info_t* info, FT_Vector* advance)
-{
-	int error;
-	glyph_hash_val_t* val;
-	glyph_hash_key_t key;
-	key.font = render_context.font;
-	key.size = render_context.font_size;
-	key.ch = symbol;
-	key.scale_x = (render_context.scale_x * 0xFFFF);
-	key.scale_y = (render_context.scale_y * 0xFFFF);
-	key.advance = *advance;
-	key.bold = render_context.bold;
-	key.italic = render_context.italic;
-	key.outline = render_context.border * 0xFFFF;
-
-	info->glyph = info->outline_glyph = 0;
-
-	val = cache_find_glyph(&key);
-	if (val) {
-		FT_Glyph_Copy(val->glyph, &info->glyph);
-		if (val->outline_glyph)
-			FT_Glyph_Copy(val->outline_glyph, &info->outline_glyph);
-		info->bbox = val->bbox_scaled;
-		info->advance.x = val->advance.x;
-		info->advance.y = val->advance.y;
-	} else {
-		glyph_hash_val_t v;
-		info->glyph = ass_font_get_glyph(frame_context.ass_priv->fontconfig_priv, render_context.font, symbol, global_settings->hinting);
-		if (!info->glyph)
-			return;
-		info->advance.x = d16_to_d6(info->glyph->advance.x);
-		info->advance.y = d16_to_d6(info->glyph->advance.y);
-		FT_Glyph_Get_CBox( info->glyph, FT_GLYPH_BBOX_PIXELS, &info->bbox);
-
-		if (render_context.stroker) {
-			info->outline_glyph = info->glyph;
-			error = FT_Glyph_StrokeBorder( &(info->outline_glyph), render_context.stroker, 0 , 0 ); // don't destroy original
-			if (error) {
-				mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_FT_Glyph_Stroke_Error, error);
-			}
-		}
-
-		memset(&v, 0, sizeof(v));
-		FT_Glyph_Copy(info->glyph, &v.glyph);
-		if (info->outline_glyph)
-			FT_Glyph_Copy(info->outline_glyph, &v.outline_glyph);
-		v.advance = info->advance;
-		v.bbox_scaled = info->bbox;
-		cache_add_glyph(&key, &v);
-	}
-}
-
-static void transform_3d(FT_Vector shift, FT_Glyph* glyph, FT_Glyph* glyph2, double frx, double fry, double frz);
-
-/**
- * \brief Get bitmaps for a glyph
- * \param info glyph info
- * Tries to get glyph bitmaps from bitmap cache.
- * If they can't be found, they are generated by rotating and rendering the glyph.
- * After that, bitmaps are added to the cache.
- * They are returned in info->bm (glyph), info->bm_o (outline) and info->bm_s (shadow).
- */
-static void get_bitmap_glyph(glyph_info_t* info)
-{
-	bitmap_hash_val_t* val;
-	bitmap_hash_key_t* key = &info->hash_key;
-	
-	val = cache_find_bitmap(key);
-/* 	val = 0; */
-	
-	if (val) {
-		info->bm = val->bm;
-		info->bm_o = val->bm_o;
-		info->bm_s = val->bm_s;
-	} else {
-		FT_Vector shift;
-		bitmap_hash_val_t hash_val;
-		int error;
-		info->bm = info->bm_o = info->bm_s = 0;
-		if (info->glyph && info->symbol != '\n' && info->symbol != 0) {
-			// calculating rotation shift vector (from rotation origin to the glyph basepoint)
-			shift.x = int_to_d6(info->hash_key.shift_x);
-			shift.y = int_to_d6(info->hash_key.shift_y);
-			// apply rotation
-			transform_3d(shift, &info->glyph, &info->outline_glyph, info->frx, info->fry, info->frz);
-
-			// render glyph
-			error = glyph_to_bitmap(ass_renderer->synth_priv,
-					info->glyph, info->outline_glyph,
-					&info->bm, &info->bm_o,
-					&info->bm_s, info->be);
-			if (error)
-				info->symbol = 0;
-
-			// add bitmaps to cache
-			hash_val.bm_o = info->bm_o;
-			hash_val.bm = info->bm;
-			hash_val.bm_s = info->bm_s;
-			cache_add_bitmap(&(info->hash_key), &hash_val);
-		}
-	}
-	// deallocate glyphs
-	if (info->glyph)
-		FT_Done_Glyph(info->glyph);
-	if (info->outline_glyph)
-		FT_Done_Glyph(info->outline_glyph);
-}
-
-/**
- * This function goes through text_info and calculates text parameters.
- * The following text_info fields are filled:
- *   height
- *   lines[].height
- *   lines[].asc
- *   lines[].desc
- */
-static void measure_text(void)
-{
-	int cur_line = 0, max_asc = 0, max_desc = 0;
-	int i;
-	text_info.height = 0;
-	for (i = 0; i < text_info.length + 1; ++i) {
-		if ((i == text_info.length) || text_info.glyphs[i].linebreak) {
-			text_info.lines[cur_line].asc = max_asc;
-			text_info.lines[cur_line].desc = max_desc;
-			text_info.height += max_asc + max_desc;
-			cur_line ++;
-			max_asc = max_desc = 0;
-		}
-		if (i < text_info.length) {
-			glyph_info_t* cur = text_info.glyphs + i;
-			if (cur->asc > max_asc)
-				max_asc = cur->asc;
-			if (cur->desc > max_desc)
-				max_desc = cur->desc;
-		}
-	}
-	text_info.height += (text_info.n_lines - 1) * double_to_d6(global_settings->line_spacing);
-}
-
-/**
- * \brief rearrange text between lines
- * \param max_text_width maximal text line width in pixels
- * The algo is similar to the one in libvo/sub.c:
- * 1. Place text, wrapping it when current line is full
- * 2. Try moving words from the end of a line to the beginning of the next one while it reduces
- * the difference in lengths between this two lines.
- * The result may not be optimal, but usually is good enough.
- */
-static void wrap_lines_smart(int max_text_width)
-{
-	int i, j;
-	glyph_info_t *cur, *s1, *e1, *s2, *s3, *w;
-	int last_space;
-	int break_type;
-	int exit;
-	int pen_shift_x;
-	int pen_shift_y;
-	int cur_line;
-
-	last_space = -1;
-	text_info.n_lines = 1;
-	break_type = 0;
-	s1 = text_info.glyphs; // current line start
-	for (i = 0; i < text_info.length; ++i) {
-		int break_at, s_offset, len;
-		cur = text_info.glyphs + i;
-		break_at = -1;
-		s_offset = s1->bbox.xMin + s1->pos.x;
-		len = (cur->bbox.xMax + cur->pos.x) - s_offset;
-
-		if (cur->symbol == '\n') {
-			break_type = 2;
-			break_at = i;
-			mp_msg(MSGT_ASS, MSGL_DBG2, "forced line break at %d\n", break_at);
-		}
-		
-		if (len >= max_text_width) {
-			break_type = 1;
-			break_at = last_space;
-			if (break_at == -1)
-				break_at = i - 1;
-			if (break_at == -1)
-				break_at = 0;
-			mp_msg(MSGT_ASS, MSGL_DBG2, "overfill at %d\n", i);
-			mp_msg(MSGT_ASS, MSGL_DBG2, "line break at %d\n", break_at);
-		}
-
-		if (break_at != -1) {
-			// need to use one more line
-			// marking break_at+1 as start of a new line
-			int lead = break_at + 1; // the first symbol of the new line
-			if (text_info.n_lines >= MAX_LINES) {
-				// to many lines ! 
-				// no more linebreaks
-				for (j = lead; j < text_info.length; ++j)
-					text_info.glyphs[j].linebreak = 0;
-				break;
-			}
-			if (lead < text_info.length)
-				text_info.glyphs[lead].linebreak = break_type;
-			last_space = -1;
-			s1 = text_info.glyphs + lead;
-			s_offset = s1->bbox.xMin + s1->pos.x;
-			text_info.n_lines ++;
-		}
-		
-		if (cur->symbol == ' ')
-			last_space = i;
-
-		// make sure the hard linebreak is not forgotten when
-		// there was a new soft linebreak just inserted
-		if (cur->symbol == '\n' && break_type == 1)
-			i--;
-	}
-#define DIFF(x,y) (((x) < (y)) ? (y - x) : (x - y))
-	exit = 0;
-	while (!exit) {
-		exit = 1;
-		w = s3 = text_info.glyphs;
-		s1 = s2 = 0;
-		for (i = 0; i <= text_info.length; ++i) {
-			cur = text_info.glyphs + i;
-			if ((i == text_info.length) || cur->linebreak) {
-				s1 = s2;
-				s2 = s3;
-				s3 = cur;
-				if (s1 && (s2->linebreak == 1)) { // have at least 2 lines, and linebreak is 'soft'
-					int l1, l2, l1_new, l2_new;
-
-					w = s2;
-					do { --w; } while ((w > s1) && (w->symbol == ' '));
-					while ((w > s1) && (w->symbol != ' ')) { --w; }
-					e1 = w;
-					while ((e1 > s1) && (e1->symbol == ' ')) { --e1; }
-					if (w->symbol == ' ') ++w;
-
-					l1 = ((s2-1)->bbox.xMax + (s2-1)->pos.x) - (s1->bbox.xMin + s1->pos.x);
-					l2 = ((s3-1)->bbox.xMax + (s3-1)->pos.x) - (s2->bbox.xMin + s2->pos.x);
-					l1_new = (e1->bbox.xMax + e1->pos.x) - (s1->bbox.xMin + s1->pos.x);
-					l2_new = ((s3-1)->bbox.xMax + (s3-1)->pos.x) - (w->bbox.xMin + w->pos.x);
-
-					if (DIFF(l1_new, l2_new) < DIFF(l1, l2)) {
-						w->linebreak = 1;
-						s2->linebreak = 0;
-						exit = 0;
-					}
-				}
-			}
-			if (i == text_info.length)
-				break;
-		}
-		
-	}
-	assert(text_info.n_lines >= 1);
-#undef DIFF
-	
-	measure_text();
-
-	pen_shift_x = 0;
-	pen_shift_y = 0;
-	cur_line = 1;
-	for (i = 0; i < text_info.length; ++i) {
-		cur = text_info.glyphs + i;
-		if (cur->linebreak) {
-			int height = text_info.lines[cur_line - 1].desc + text_info.lines[cur_line].asc;
-			cur_line ++;
-			pen_shift_x = - cur->pos.x;
-			pen_shift_y += d6_to_int(height + double_to_d6(global_settings->line_spacing));
-			mp_msg(MSGT_ASS, MSGL_DBG2, "shifting from %d to %d by (%d, %d)\n", i, text_info.length - 1, pen_shift_x, pen_shift_y);
-		}
-		cur->pos.x += pen_shift_x;
-		cur->pos.y += pen_shift_y;
-	}
-}
-
-/**
- * \brief determine karaoke effects
- * Karaoke effects cannot be calculated during parse stage (get_next_char()),
- * so they are done in a separate step.
- * Parse stage: when karaoke style override is found, its parameters are stored in the next glyph's 
- * (the first glyph of the karaoke word)'s effect_type and effect_timing.
- * This function:
- * 1. sets effect_type for all glyphs in the word (_karaoke_ word)
- * 2. sets effect_timing for all glyphs to x coordinate of the border line between the left and right karaoke parts
- * (left part is filled with PrimaryColour, right one - with SecondaryColour).
- */
-static void process_karaoke_effects(void)
-{
-	glyph_info_t *cur, *cur2;
-	glyph_info_t *s1, *e1; // start and end of the current word
-	glyph_info_t *s2; // start of the next word
-	int i;
-	int timing; // current timing
-	int tm_start, tm_end; // timings at start and end of the current word
-	int tm_current;
-	double dt;
-	int x;
-	int x_start, x_end;
-
-	tm_current = frame_context.time - render_context.event->Start;
-	timing = 0;
-	s1 = s2 = 0;
-	for (i = 0; i <= text_info.length; ++i) {
-		cur = text_info.glyphs + i;
-		if ((i == text_info.length) || (cur->effect_type != EF_NONE)) {
-			s1 = s2;
-			s2 = cur;
-			if (s1) {
-				e1 = s2 - 1;
-				tm_start = timing + s1->effect_skip_timing;
-				tm_end = tm_start + s1->effect_timing;
-				timing = tm_end;
-				x_start = 1000000;
-				x_end = -1000000;
-				for (cur2 = s1; cur2 <= e1; ++cur2) {
-					x_start = FFMIN(x_start, cur2->bbox.xMin + cur2->pos.x);
-					x_end = FFMAX(x_end, cur2->bbox.xMax + cur2->pos.x);
-				}
-
-				dt = (tm_current - tm_start);
-				if ((s1->effect_type == EF_KARAOKE) || (s1->effect_type == EF_KARAOKE_KO)) {
-					if (dt > 0)
-						x = x_end + 1;
-					else
-						x = x_start;
-				} else if (s1->effect_type == EF_KARAOKE_KF) {
-					dt /= (tm_end - tm_start);
-					x = x_start + (x_end - x_start) * dt;
-				} else {
-					mp_msg(MSGT_ASS, MSGL_ERR, MSGTR_LIBASS_UnknownEffectType_InternalError);
-					continue;
-				}
-
-				for (cur2 = s1; cur2 <= e1; ++cur2) {
-					cur2->effect_type = s1->effect_type;
-					cur2->effect_timing = x - cur2->pos.x;
-				}
-			}
-		}
-	}
-}
-
-/**
- * \brief Calculate base point for positioning and rotation
- * \param bbox text bbox
- * \param alignment alignment
- * \param bx, by out: base point coordinates
- */
-static void get_base_point(FT_BBox bbox, int alignment, int* bx, int* by)
-{
-	const int halign = alignment & 3;
-	const int valign = alignment & 12;
-	if (bx)
-		switch(halign) {
-		case HALIGN_LEFT:
-			*bx = bbox.xMin;
-			break;
-		case HALIGN_CENTER:
-			*bx = (bbox.xMax + bbox.xMin) / 2;
-			break;
-		case HALIGN_RIGHT:
-			*bx = bbox.xMax;
-			break;
-		}
-	if (by)
-		switch(valign) {
-		case VALIGN_TOP:
-			*by = bbox.yMin;
-			break;
-		case VALIGN_CENTER:
-			*by = (bbox.yMax + bbox.yMin) / 2;
-			break;
-		case VALIGN_SUB:
-			*by = bbox.yMax;
-			break;
-		}
-}
-
-/**
- * \brief Multiply 4-vector by 4-matrix
- * \param a 4-vector
- * \param m 4-matrix]
- * \param b out: 4-vector
- * Calculates a * m and stores result in b
- */
-static inline void transform_point_3d(double *a, double *m, double *b)
-{
-	b[0] = a[0] * m[0] + a[1] * m[4] + a[2] * m[8] +  a[3] * m[12];
-	b[1] = a[0] * m[1] + a[1] * m[5] + a[2] * m[9] +  a[3] * m[13];
-	b[2] = a[0] * m[2] + a[1] * m[6] + a[2] * m[10] + a[3] * m[14];
-	b[3] = a[0] * m[3] + a[1] * m[7] + a[2] * m[11] + a[3] * m[15];
-}
-
-/**
- * \brief Apply 3d transformation to a vector
- * \param v FreeType vector (2d)
- * \param m 4-matrix
- * Transforms v by m, projects the result back to the screen plane
- * Result is returned in v.
- */
-static inline void transform_vector_3d(FT_Vector* v, double *m) {
-	const double camera = 2500 * frame_context.border_scale; // camera distance
-	double a[4], b[4];
-	a[0] = d6_to_double(v->x);
-	a[1] = d6_to_double(v->y);
-	a[2] = 0.;
-	a[3] = 1.;
-	transform_point_3d(a, m, b);
-	/* Apply perspective projection with the following matrix:
-	   2500     0     0     0
-	      0  2500     0     0
-	      0     0     0     0
-	      0     0     8     2500
-	   where 2500 is camera distance, 8 - z-axis scale.
-	   Camera is always located in (org_x, org_y, -2500). This means
-	   that different subtitle events can be displayed at the same time
-	   using different cameras. */
-	b[0] *= camera;
-	b[1] *= camera;
-	b[3] = 8 * b[2] + camera;
-	if (b[3] < 0.001 && b[3] > -0.001)
-		b[3] = b[3] < 0. ? -0.001 : 0.001;
-	v->x = double_to_d6(b[0] / b[3]);
-	v->y = double_to_d6(b[1] / b[3]);
-}
-
-/**
- * \brief Apply 3d transformation to a glyph
- * \param glyph FreeType glyph
- * \param m 4-matrix
- * Transforms glyph by m, projects the result back to the screen plane
- * Result is returned in glyph.
- */
-static inline void transform_glyph_3d(FT_Glyph glyph, double *m, FT_Vector shift) {
-	int i;
-	FT_Outline* outline = &((FT_OutlineGlyph)glyph)->outline;
-	FT_Vector* p = outline->points;
-
-	for (i=0; i<outline->n_points; i++) {
-		p[i].x += shift.x;
-		p[i].y += shift.y;
-		transform_vector_3d(p + i, m);
-		p[i].x -= shift.x;
-		p[i].y -= shift.y;
-	}
-
-	//transform_vector_3d(&glyph->advance, m);
-}
-
-/**
- * \brief Apply 3d transformation to several objects
- * \param shift FreeType vector
- * \param glyph FreeType glyph
- * \param glyph2 FreeType glyph
- * \param frx x-axis rotation angle
- * \param fry y-axis rotation angle
- * \param frz z-axis rotation angle
- * Rotates both glyphs by frx, fry and frz. Shift vector is added before rotation and subtracted after it.
- */
-static void transform_3d(FT_Vector shift, FT_Glyph* glyph, FT_Glyph* glyph2, double frx, double fry, double frz)
-{
-	fry = - fry; // FreeType's y axis goes in the opposite direction
-	if (frx != 0. || fry != 0. || frz != 0.) {
-		double m[16];
-		double sx = sin(frx);
-		double sy = sin(fry);
- 		double sz = sin(frz);
-		double cx = cos(frx);
-		double cy = cos(fry);
-		double cz = cos(frz);
-		m[0] = cy * cz;            m[1] = cy*sz;              m[2]  = -sy;    m[3] = 0.0;
-		m[4] = -cx*sz + sx*sy*cz;  m[5] = cx*cz + sx*sy*sz;   m[6]  = sx*cy;  m[7] = 0.0;
-		m[8] = sx*sz + cx*sy*cz;   m[9] = -sx*cz + cx*sy*sz;  m[10] = cx*cy;  m[11] = 0.0;
-		m[12] = 0.0;               m[13] = 0.0;               m[14] = 0.0;    m[15] = 1.0;
-
-		if (glyph && *glyph)
-			transform_glyph_3d(*glyph, m, shift);
-
-		if (glyph2 && *glyph2)
-			transform_glyph_3d(*glyph2, m, shift);
-	}
-}
-
-/**
- * \brief Main ass rendering function, glues everything together
- * \param event event to render
- * Process event, appending resulting ass_image_t's to images_root.
- */
-static int ass_render_event(ass_event_t* event, event_images_t* event_images)
-{
-	char* p;
-	FT_UInt previous; 
-	FT_UInt num_glyphs;
-	FT_Vector pen;
-	unsigned code;
-	FT_BBox bbox;
-	int i, j;
-	FT_Vector shift;
-	int MarginL, MarginR, MarginV;
-	int last_break;
-	int alignment, halign, valign;
-	int device_x = 0, device_y = 0;
-
-	if (event->Style >= frame_context.track->n_styles) {
-		mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_NoStyleFound);
-		return 1;
-	}
-	if (!event->Text) {
-		mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_EmptyEvent);
-		return 1;
-	}
-
-	init_render_context(event);
-
-	text_info.length = 0;
-	pen.x = 0;
-	pen.y = 0;
-	previous = 0;
-	num_glyphs = 0;
-	p = event->Text;
-	// Event parsing.
-	while (1) {
-		// get next char, executing style override
-		// this affects render_context
-		code = get_next_char(&p);
-		
-		// face could have been changed in get_next_char
-		if (!render_context.font) {
-			free_render_context();
-			return 1;
-		}
-
-		if (code == 0)
-			break;
-
-		if (text_info.length >= MAX_GLYPHS) {
-			mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_MAX_GLYPHS_Reached, 
-					(int)(event - frame_context.track->events), event->Start, event->Duration, event->Text);
-			break;
-		}
-
-		if ( previous && code ) {
-			FT_Vector delta;
-			delta = ass_font_get_kerning(render_context.font, previous, code);
-			pen.x += delta.x * render_context.scale_x;
-			pen.y += delta.y * render_context.scale_y;
-		}
-
-		shift.x = pen.x & 63;
-		shift.y = pen.y & 63;
-
-		ass_font_set_transform(render_context.font,
-				       render_context.scale_x * frame_context.font_scale_x,
-				       render_context.scale_y,
-				       &shift );
-
-		get_outline_glyph(code, text_info.glyphs + text_info.length, &shift);
-		
-		text_info.glyphs[text_info.length].pos.x = pen.x >> 6;
-		text_info.glyphs[text_info.length].pos.y = pen.y >> 6;
-		
-		pen.x += text_info.glyphs[text_info.length].advance.x;
-		pen.x += double_to_d6(render_context.hspacing);
-		pen.y += text_info.glyphs[text_info.length].advance.y;
-		
-		previous = code;
-
-		text_info.glyphs[text_info.length].symbol = code;
-		text_info.glyphs[text_info.length].linebreak = 0;
-		for (i = 0; i < 4; ++i) {
-			uint32_t clr = render_context.c[i];
-			change_alpha(&clr, mult_alpha(_a(clr), render_context.fade), 1.);
-			text_info.glyphs[text_info.length].c[i] = clr;
-		}
-		text_info.glyphs[text_info.length].effect_type = render_context.effect_type;
-		text_info.glyphs[text_info.length].effect_timing = render_context.effect_timing;
-		text_info.glyphs[text_info.length].effect_skip_timing = render_context.effect_skip_timing;
-		text_info.glyphs[text_info.length].be = render_context.be;
-		text_info.glyphs[text_info.length].shadow = render_context.shadow;
-		text_info.glyphs[text_info.length].frx = render_context.frx;
-		text_info.glyphs[text_info.length].fry = render_context.fry;
-		text_info.glyphs[text_info.length].frz = render_context.frz;
-		ass_font_get_asc_desc(render_context.font, code,
-				      &text_info.glyphs[text_info.length].asc,
-				      &text_info.glyphs[text_info.length].desc);
-		text_info.glyphs[text_info.length].asc *= render_context.scale_y;
-		text_info.glyphs[text_info.length].desc *= render_context.scale_y;
-
-		// fill bitmap_hash_key
-		text_info.glyphs[text_info.length].hash_key.font = render_context.font;
-		text_info.glyphs[text_info.length].hash_key.size = render_context.font_size;
-		text_info.glyphs[text_info.length].hash_key.outline = render_context.border * 0xFFFF;
-		text_info.glyphs[text_info.length].hash_key.scale_x = render_context.scale_x * 0xFFFF;
-		text_info.glyphs[text_info.length].hash_key.scale_y = render_context.scale_y * 0xFFFF;
-		text_info.glyphs[text_info.length].hash_key.frx = render_context.frx * 0xFFFF;
-		text_info.glyphs[text_info.length].hash_key.fry = render_context.fry * 0xFFFF;
-		text_info.glyphs[text_info.length].hash_key.frz = render_context.frz * 0xFFFF;
-		text_info.glyphs[text_info.length].hash_key.bold = render_context.bold;
-		text_info.glyphs[text_info.length].hash_key.italic = render_context.italic;
-		text_info.glyphs[text_info.length].hash_key.ch = code;
-		text_info.glyphs[text_info.length].hash_key.advance = shift;
-		text_info.glyphs[text_info.length].hash_key.be = render_context.be;
-
-		text_info.length++;
-
-		render_context.effect_type = EF_NONE;
-		render_context.effect_timing = 0;
-		render_context.effect_skip_timing = 0;
-	}
-	
-	if (text_info.length == 0) {
-		// no valid symbols in the event; this can be smth like {comment}
-		free_render_context();
-		return 1;
-	}
-	
-	// depends on glyph x coordinates being monotonous, so it should be done before line wrap
-	process_karaoke_effects();
-	
-	// alignments
-	alignment = render_context.alignment;
-	halign = alignment & 3;
-	valign = alignment & 12;
-
-	MarginL = (event->MarginL) ? event->MarginL : render_context.style->MarginL; 
-	MarginR = (event->MarginR) ? event->MarginR : render_context.style->MarginR; 
-	MarginV = (event->MarginV) ? event->MarginV : render_context.style->MarginV;
-
-	if (render_context.evt_type != EVENT_HSCROLL) {
-		int max_text_width;
-
-		// calculate max length of a line
-		max_text_width = x2scr(frame_context.track->PlayResX - MarginR) - x2scr(MarginL);
-
-		// rearrange text in several lines
-		wrap_lines_smart(max_text_width);
-
-		// align text
-		last_break = -1;
-		for (i = 1; i < text_info.length + 1; ++i) { // (text_info.length + 1) is the end of the last line
-			if ((i == text_info.length) || text_info.glyphs[i].linebreak) {
-				int width, shift = 0;
-				glyph_info_t* first_glyph = text_info.glyphs + last_break + 1;
-				glyph_info_t* last_glyph = text_info.glyphs + i - 1;
-
-				while ((last_glyph > first_glyph) && ((last_glyph->symbol == '\n') || (last_glyph->symbol == 0)))
-					last_glyph --;
-
-				width = last_glyph->pos.x + d6_to_int(last_glyph->advance.x) - first_glyph->pos.x;
-				if (halign == HALIGN_LEFT) { // left aligned, no action
-					shift = 0;
-				} else if (halign == HALIGN_RIGHT) { // right aligned
-					shift = max_text_width - width;
-				} else if (halign == HALIGN_CENTER) { // centered
-					shift = (max_text_width - width) / 2;
-				}
-				for (j = last_break + 1; j < i; ++j) {
-					text_info.glyphs[j].pos.x += shift;
-				}
-				last_break = i - 1;
-			}
-		}
-	} else { // render_context.evt_type == EVENT_HSCROLL
-		measure_text();
-	}
-	
-	// determing text bounding box
-	compute_string_bbox(&text_info, &bbox);
-	
-	// determine device coordinates for text
-	
-	// x coordinate for everything except positioned events
-	if (render_context.evt_type == EVENT_NORMAL ||
-	    render_context.evt_type == EVENT_VSCROLL) {
-		device_x = x2scr(MarginL);
-	} else if (render_context.evt_type == EVENT_HSCROLL) {
-		if (render_context.scroll_direction == SCROLL_RL)
-			device_x = x2scr(frame_context.track->PlayResX - render_context.scroll_shift);
-		else if (render_context.scroll_direction == SCROLL_LR)
-			device_x = x2scr(render_context.scroll_shift) - (bbox.xMax - bbox.xMin);
-	}
-
-	// y coordinate for everything except positioned events
-	if (render_context.evt_type == EVENT_NORMAL ||
-	    render_context.evt_type == EVENT_HSCROLL) {
-		if (valign == VALIGN_TOP) { // toptitle
-			device_y = y2scr_top(MarginV) + d6_to_int(text_info.lines[0].asc);
-		} else if (valign == VALIGN_CENTER) { // midtitle
-			int scr_y = y2scr(frame_context.track->PlayResY / 2);
-			device_y = scr_y - (bbox.yMax - bbox.yMin) / 2;
-		} else { // subtitle
-			int scr_y;
-			if (valign != VALIGN_SUB)
-				mp_msg(MSGT_ASS, MSGL_V, "Invalid valign, supposing 0 (subtitle)\n");
-			scr_y = y2scr_sub(frame_context.track->PlayResY - MarginV);
-			device_y = scr_y;
-			device_y -= d6_to_int(text_info.height);
-			device_y += d6_to_int(text_info.lines[0].asc);
-		}
-	} else if (render_context.evt_type == EVENT_VSCROLL) {
-		if (render_context.scroll_direction == SCROLL_TB)
-			device_y = y2scr(render_context.clip_y0 + render_context.scroll_shift) - (bbox.yMax - bbox.yMin);
-		else if (render_context.scroll_direction == SCROLL_BT)
-			device_y = y2scr(render_context.clip_y1 - render_context.scroll_shift);
-	}
-
-	// positioned events are totally different
-	if (render_context.evt_type == EVENT_POSITIONED) {
-		int base_x = 0;
-		int base_y = 0;
-		mp_msg(MSGT_ASS, MSGL_DBG2, "positioned event at %d, %d\n", render_context.pos_x, render_context.pos_y);
-		get_base_point(bbox, alignment, &base_x, &base_y);
-		device_x = x2scr(render_context.pos_x) - base_x;
-		device_y = y2scr(render_context.pos_y) - base_y;
-	}
-	
-	// fix clip coordinates (they depend on alignment)
-	render_context.clip_x0 = x2scr(render_context.clip_x0);
-	render_context.clip_x1 = x2scr(render_context.clip_x1);
-	if (render_context.evt_type == EVENT_NORMAL ||
-	    render_context.evt_type == EVENT_HSCROLL ||
-	    render_context.evt_type == EVENT_VSCROLL) {
-		if (valign == VALIGN_TOP) {
-			render_context.clip_y0 = y2scr_top(render_context.clip_y0);
-			render_context.clip_y1 = y2scr_top(render_context.clip_y1);
-		} else if (valign == VALIGN_CENTER) {
-			render_context.clip_y0 = y2scr(render_context.clip_y0);
-			render_context.clip_y1 = y2scr(render_context.clip_y1);
-		} else if (valign == VALIGN_SUB) {
-			render_context.clip_y0 = y2scr_sub(render_context.clip_y0);
-			render_context.clip_y1 = y2scr_sub(render_context.clip_y1);
-		}
-	} else if (render_context.evt_type == EVENT_POSITIONED) {
-		render_context.clip_y0 = y2scr(render_context.clip_y0);
-		render_context.clip_y1 = y2scr(render_context.clip_y1);
-	}
-
-	// calculate rotation parameters
-	{
-		FT_Vector center;
-		
-		if (render_context.have_origin) {
-			center.x = x2scr(render_context.org_x);
-			center.y = y2scr(render_context.org_y);
-		} else {
-			int bx, by;
-			get_base_point(bbox, alignment, &bx, &by);
-			center.x = device_x + bx;
-			center.y = device_y + by;
-		}
-
-		for (i = 0; i < text_info.length; ++i) {
-			glyph_info_t* info = text_info.glyphs + i;
-
-			if (info->hash_key.frx || info->hash_key.fry || info->hash_key.frz) {
-				info->hash_key.shift_x = info->pos.x + device_x - center.x;
-				info->hash_key.shift_y = - (info->pos.y + device_y - center.y);
-			} else {
-				info->hash_key.shift_x = 0;
-				info->hash_key.shift_y = 0;
-			}
-		}
-	}
-
-	// convert glyphs to bitmaps
-	for (i = 0; i < text_info.length; ++i)
-		get_bitmap_glyph(text_info.glyphs + i);
-
-	event_images->top = device_y - d6_to_int(text_info.lines[0].asc);
-	event_images->height = d6_to_int(text_info.height);
-	event_images->detect_collisions = render_context.detect_collisions;
-	event_images->shift_direction = (valign == VALIGN_TOP) ? 1 : -1;
-	event_images->event = event;
-	event_images->imgs = render_text(&text_info, device_x, device_y);
-
-	free_render_context();
-	
-	return 0;
-}
-
-/**
- * \brief deallocate image list
- * \param img list pointer
- */
-void ass_free_images(ass_image_t* img)
-{
-	while (img) {
-		ass_image_t* next = img->next;
-		free(img);
-		img = next;
-	}
-}
-
-static void ass_reconfigure(ass_renderer_t* priv)
-{
-	priv->render_id = ++last_render_id;
-	ass_glyph_cache_reset();
-	ass_bitmap_cache_reset();
-	ass_free_images(priv->prev_images_root);
-	priv->prev_images_root = 0;
-}
-
-void ass_set_frame_size(ass_renderer_t* priv, int w, int h)
-{
-	if (priv->settings.frame_width != w || priv->settings.frame_height != h) {
-		priv->settings.frame_width = w;
-		priv->settings.frame_height = h;
-		if (priv->settings.aspect == 0.)
-			priv->settings.aspect = ((double)w) / h;
-		ass_reconfigure(priv);
-	}
-}
-
-void ass_set_margins(ass_renderer_t* priv, int t, int b, int l, int r)
-{
-	if (priv->settings.left_margin != l ||
-	    priv->settings.right_margin != r ||
-	    priv->settings.top_margin != t ||
-	    priv->settings.bottom_margin != b) {
-		priv->settings.left_margin = l;
-		priv->settings.right_margin = r;
-		priv->settings.top_margin = t;
-		priv->settings.bottom_margin = b;
-		ass_reconfigure(priv);
-	}
-}
-
-void ass_set_use_margins(ass_renderer_t* priv, int use)
-{
-	priv->settings.use_margins = use;
-}
-
-void ass_set_aspect_ratio(ass_renderer_t* priv, double ar)
-{
-	if (priv->settings.aspect != ar) {
-		priv->settings.aspect = ar;
-		ass_reconfigure(priv);
-	}
-}
-
-void ass_set_font_scale(ass_renderer_t* priv, double font_scale)
-{
-	if (priv->settings.font_size_coeff != font_scale) {
-		priv->settings.font_size_coeff = font_scale;
-		ass_reconfigure(priv);
-	}
-}
-
-void ass_set_hinting(ass_renderer_t* priv, ass_hinting_t ht)
-{
-	if (priv->settings.hinting != ht) {
-		priv->settings.hinting = ht;
-		ass_reconfigure(priv);
-	}
-}
-
-void ass_set_line_spacing(ass_renderer_t* priv, double line_spacing)
-{
-	priv->settings.line_spacing = line_spacing;
-}
-
-int ass_set_fonts(ass_renderer_t* priv, const char* default_font, const char* default_family)
-{
-	if (priv->settings.default_font)
-		free(priv->settings.default_font);
-	if (priv->settings.default_family)
-		free(priv->settings.default_family);
-
-	priv->settings.default_font = default_font ? strdup(default_font) : 0;
-	priv->settings.default_family = default_family ? strdup(default_family) : 0;
-
-	if (priv->fontconfig_priv)
-		fontconfig_done(priv->fontconfig_priv);
-	priv->fontconfig_priv = fontconfig_init(priv->library, priv->ftlibrary, default_family, default_font);
-
-	return !!priv->fontconfig_priv;
-}
-
-/**
- * \brief Start a new frame
- */
-static int ass_start_frame(ass_renderer_t *priv, ass_track_t* track, long long now)
-{
-	ass_renderer = priv;
-	global_settings = &priv->settings;
-
-	if (!priv->settings.frame_width && !priv->settings.frame_height)
-		return 1; // library not initialized
-	
-	frame_context.ass_priv = priv;
-	frame_context.width = global_settings->frame_width;
-	frame_context.height = global_settings->frame_height;
-	frame_context.orig_width = global_settings->frame_width - global_settings->left_margin - global_settings->right_margin;
-	frame_context.orig_height = global_settings->frame_height - global_settings->top_margin - global_settings->bottom_margin;
-	frame_context.track = track;
-	frame_context.time = now;
-
-	ass_lazy_track_init();
-	
-	frame_context.font_scale = global_settings->font_size_coeff *
-	                           frame_context.orig_height / frame_context.track->PlayResY;
-	frame_context.border_scale = ((double)frame_context.orig_height) / frame_context.track->PlayResY;
-
-	if (frame_context.orig_width * track->PlayResY == frame_context.orig_height * track->PlayResX)
-		frame_context.font_scale_x = 1.;
-	else
-		frame_context.font_scale_x = ((double)(frame_context.orig_width * track->PlayResY)) / (frame_context.orig_height * track->PlayResX);
-
-	priv->prev_images_root = priv->images_root;
-	priv->images_root = 0;
-
-	return 0;
-}
-
-static int cmp_event_layer(const void* p1, const void* p2)
-{
-	ass_event_t* e1 = ((event_images_t*)p1)->event;
-	ass_event_t* e2 = ((event_images_t*)p2)->event;
-	if (e1->Layer < e2->Layer)
-		return -1;
-	if (e1->Layer > e2->Layer)
-		return 1;
-	if (e1->ReadOrder < e2->ReadOrder)
-		return -1;
-	if (e1->ReadOrder > e2->ReadOrder)
-		return 1;
-	return 0;
-}
-
-#define MAX_EVENTS 100
-
-static render_priv_t* get_render_priv(ass_event_t* event)
-{
-	if (!event->render_priv)
-		event->render_priv = calloc(1, sizeof(render_priv_t));
-	// FIXME: check render_id
-	if (ass_renderer->render_id != event->render_priv->render_id) {
-		memset(event->render_priv, 0, sizeof(render_priv_t));
-		event->render_priv->render_id = ass_renderer->render_id;
-	}
-	return event->render_priv;
-}
-
-typedef struct segment_s {
-	int a, b; // top and height
-} segment_t;
-
-static int overlap(segment_t* s1, segment_t* s2)
-{
-	if (s1->a >= s2->b || s2->a >= s1->b)
-		return 0;
-	return 1;
-}
-
-static int cmp_segment(const void* p1, const void* p2)
-{
-	return ((segment_t*)p1)->a - ((segment_t*)p2)->a;
-}
-
-static void shift_event(event_images_t* ei, int shift)
-{
-	ass_image_t* cur = ei->imgs;
-	while (cur) {
-		cur->dst_y += shift;
-		// clip top and bottom
-		if (cur->dst_y < 0) {
-			int clip = - cur->dst_y;
-			cur->h -= clip;
-			cur->bitmap += clip * cur->stride;
-			cur->dst_y = 0;
-		}
-		if (cur->dst_y + cur->h >= frame_context.height) {
-			int clip = cur->dst_y + cur->h - frame_context.height;
-			cur->h -= clip;
-		}
-		if (cur->h <= 0) {
-			cur->h = 0;
-			cur->dst_y = 0;
-		}
-		cur = cur->next;
-	}
-	ei->top += shift;
-}
-
-// dir: 1 - move down
-//      -1 - move up
-static int fit_segment(segment_t* s, segment_t* fixed, int* cnt, int dir)
-{
-	int i;
-	int shift = 0;
-
-	if (dir == 1) // move down
-		for (i = 0; i < *cnt; ++i) {
-			if (s->b + shift <= fixed[i].a || s->a + shift >= fixed[i].b)
-				continue;
-			shift = fixed[i].b - s->a;
-		}
-	else // dir == -1, move up
-		for (i = *cnt-1; i >= 0; --i) {
-			if (s->b + shift <= fixed[i].a || s->a + shift >= fixed[i].b)
-				continue;
-			shift = fixed[i].a - s->b;
-		}
-
-	fixed[*cnt].a = s->a + shift;
-	fixed[*cnt].b = s->b + shift;
-	(*cnt)++;
-	qsort(fixed, *cnt, sizeof(segment_t), cmp_segment);
-	
-	return shift;
-}
-
-static void fix_collisions(event_images_t* imgs, int cnt)
-{
-	segment_t used[MAX_EVENTS];
-	int cnt_used = 0;
-	int i, j;
-
-	// fill used[] with fixed events
-	for (i = 0; i < cnt; ++i) {
-		render_priv_t* priv;
-		if (!imgs[i].detect_collisions) continue;
-		priv = get_render_priv(imgs[i].event);
-		if (priv->height > 0) { // it's a fixed event
-			segment_t s;
-			s.a = priv->top;
-			s.b = priv->top + priv->height;
-			if (priv->height != imgs[i].height) { // no, it's not
-				mp_msg(MSGT_ASS, MSGL_WARN, MSGTR_LIBASS_EventHeightHasChanged);
-				priv->top = 0;
-				priv->height = 0;
-			}
-			for (j = 0; j < cnt_used; ++j)
-				if (overlap(&s, used + j)) { // no, it's not
-					priv->top = 0;
-					priv->height = 0;
-				}
-			if (priv->height > 0) { // still a fixed event
-				used[cnt_used].a = priv->top;
-				used[cnt_used].b = priv->top + priv->height;
-				cnt_used ++;
-				shift_event(imgs + i, priv->top - imgs[i].top);
-			}
-		}
-	}
-	qsort(used, cnt_used, sizeof(segment_t), cmp_segment);
-
-	// try to fit other events in free spaces
-	for (i = 0; i < cnt; ++i) {
-		render_priv_t* priv;
-		if (!imgs[i].detect_collisions) continue;
-		priv = get_render_priv(imgs[i].event);
-		if (priv->height == 0) { // not a fixed event
-			int shift;
-			segment_t s;
-			s.a = imgs[i].top;
-			s.b = imgs[i].top + imgs[i].height;
-			shift = fit_segment(&s, used, &cnt_used, imgs[i].shift_direction);
-			if (shift) shift_event(imgs + i, shift);
-			// make it fixed
-			priv->top = imgs[i].top;
-			priv->height = imgs[i].height;
-		}
-		
-	}
-}
-
-/**
- * \brief compare two images
- * \param i1 first image
- * \param i2 second image
- * \return 0 if identical, 1 if different positions, 2 if different content
- */
-int ass_image_compare(ass_image_t *i1, ass_image_t *i2)
-{
-	if (i1->w != i2->w) return 2;
-	if (i1->h != i2->h) return 2;
-	if (i1->stride != i2->stride) return 2;
-	if (i1->color != i2->color) return 2;
-	if (i1->bitmap != i2->bitmap)
-		return 2;
-	if (i1->dst_x != i2->dst_x) return 1;
-	if (i1->dst_y != i2->dst_y) return 1;
-	return 0;
-}
-
-/**
- * \brief compare current and previous image list
- * \param priv library handle
- * \return 0 if identical, 1 if different positions, 2 if different content
- */
-int ass_detect_change(ass_renderer_t *priv)
-{
-	ass_image_t* img, *img2;
-	int diff;
-
-	img = priv->prev_images_root;
-	img2 = priv->images_root;
-	diff = 0;
-	while (img && diff < 2) {
-		ass_image_t* next, *next2;
-		next = img->next;
-		if (img2) {
-			int d = ass_image_compare(img, img2);
-			if (d > diff) diff = d;
-			next2 = img2->next;
-		} else {
-			// previous list is shorter
-			diff = 2;
-			break;
-		}
-		img = next;
-		img2 = next2;
-	}
-
-	// is the previous list longer?
-	if (img2)
-		diff = 2;
-
-	return diff;
-}
-
-/**
- * \brief render a frame
- * \param priv library handle
- * \param track track
- * \param now current video timestamp (ms)
- * \param detect_change a value describing how the new images differ from the previous ones will be written here:
- *        0 if identical, 1 if different positions, 2 if different content.
- *        Can be NULL, in that case no detection is performed.
- */
-ass_image_t* ass_render_frame(ass_renderer_t *priv, ass_track_t* track, long long now, int* detect_change)
-{
-	int i, cnt, rc;
-	event_images_t* last;
-	ass_image_t** tail;
-	
-	// init frame
-	rc = ass_start_frame(priv, track, now);
-	if (rc != 0)
-		return 0;
-
-	// render events separately
-	cnt = 0;
-	for (i = 0; i < track->n_events; ++i) {
-		ass_event_t* event = track->events + i;
-		if ( (event->Start <= now) && (now < (event->Start + event->Duration)) ) {
-			if (cnt >= priv->eimg_size) {
-				priv->eimg_size += 100;
-				priv->eimg = realloc(priv->eimg, priv->eimg_size * sizeof(event_images_t));
-			}
-			rc = ass_render_event(event, priv->eimg + cnt);
-			if (!rc) ++cnt;
-		}
-	}
-
-	// sort by layer
-	qsort(priv->eimg, cnt, sizeof(event_images_t), cmp_event_layer);
-
-	// call fix_collisions for each group of events with the same layer
-	last = priv->eimg;
-	for (i = 1; i < cnt; ++i)
-		if (last->event->Layer != priv->eimg[i].event->Layer) {
-			fix_collisions(last, priv->eimg + i - last);
-			last = priv->eimg + i;
-		}
-	if (cnt > 0)
-		fix_collisions(last, priv->eimg + cnt - last);
-
-	// concat lists
-	tail = &ass_renderer->images_root;
-	for (i = 0; i < cnt; ++i) {
-		ass_image_t* cur = priv->eimg[i].imgs;
-		while (cur) {
-			*tail = cur;
-			tail = &cur->next;
-			cur = cur->next;
-		}
-	}
-
-	if (detect_change)
-		*detect_change = ass_detect_change(priv);
-	
-	// free the previous image list
-	ass_free_images(priv->prev_images_root);
-	priv->prev_images_root = 0;
-
-	return ass_renderer->images_root;
-}
-

Deleted: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/ass_types.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/ass_types.h	2009-07-31 22:24:31 UTC (rev 5184)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/ass_types.h	2009-08-01 07:55:22 UTC (rev 5185)
@@ -1,114 +0,0 @@
-// -*- c-basic-offset: 8; indent-tabs-mode: t -*-
-// vim:ts=8:sw=8:noet:ai:
-/*
-  Copyright (C) 2006 Evgeniy Stepanov <eugeni.stepanov at gmail.com>
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation; either version 2 of the License, or
-  (at your option) any later version.
-
-  This program is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with this program; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
-*/
-
-#ifndef ASS_TYPES_H
-#define ASS_TYPES_H
-
-#define VALIGN_SUB 0
-#define VALIGN_CENTER 8
-#define VALIGN_TOP 4
-#define HALIGN_LEFT 1
-#define HALIGN_CENTER 2
-#define HALIGN_RIGHT 3
-
-/// ass Style: line
-typedef struct ass_style_s {
-	char* Name;
-	char* FontName;
-	double FontSize;
-	uint32_t PrimaryColour;
-	uint32_t SecondaryColour;
-	uint32_t OutlineColour;
-	uint32_t BackColour;
-	int Bold;
-	int Italic;
-	int Underline;
-	int StrikeOut;
-	double ScaleX;
-	double ScaleY;
-	double Spacing;
-	int Angle;
-	int BorderStyle;
-	double Outline;
-	double Shadow;
-	int Alignment;
-	int MarginL;
-	int MarginR;
-	int MarginV;
-//        int AlphaLevel;
-	int Encoding;
-} ass_style_t;
-
-typedef struct render_priv_s render_priv_t;
-
-/// ass_event_t corresponds to a single Dialogue line
-/// Text is stored as-is, style overrides will be parsed later
-typedef struct ass_event_s {
-	long long Start; // ms
-	long long Duration; // ms
-
-	int ReadOrder;
-	int Layer;
-	int Style;
-	char* Name;
-	int MarginL;
-	int MarginR;
-	int MarginV;
-	char* Effect;
-	char* Text;
-
-	render_priv_t* render_priv;
-} ass_event_t;
-
-typedef struct parser_priv_s parser_priv_t;
-
-typedef struct ass_library_s ass_library_t;
-
-/// ass track represent either an external script or a matroska subtitle stream (no real difference between them)
-/// it can be used in rendering after the headers are parsed (i.e. events format line read)
-typedef struct ass_track_s {
-	int n_styles; // amount used
-	int max_styles; // amount allocated
-	int n_events;
-	int max_events;
-	ass_style_t* styles; // array of styles, max_styles length, n_styles used
-	ass_event_t* events; // the same as styles
-
-	char* style_format; // style format line (everything after "Format: ")
-	char* event_format; // event format line
-
-	enum {TRACK_TYPE_UNKNOWN = 0, TRACK_TYPE_ASS, TRACK_TYPE_SSA} track_type;
-	
-	// script header fields
-	int PlayResX;
-	int PlayResY;
-	double Timer;
-	int WrapStyle;
-
-	
-	int default_style; // index of default style
-	char* name; // file name in case of external subs, 0 for streams
-
-	ass_library_t* library;
-	parser_priv_t* parser_priv;
-} ass_track_t;
-
-#endif
-

Deleted: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/ass_utils.c
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/ass_utils.c	2009-07-31 22:24:31 UTC (rev 5184)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/ass_utils.c	2009-08-01 07:55:22 UTC (rev 5185)
@@ -1,81 +0,0 @@
-// -*- c-basic-offset: 8; indent-tabs-mode: t -*-
-// vim:ts=8:sw=8:noet:ai:
-/*
-  Copyright (C) 2006 Evgeniy Stepanov <eugeni.stepanov at gmail.com>
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation; either version 2 of the License, or
-  (at your option) any later version.
-
-  This program is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with this program; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
-*/
-
-//#include "config.h"
-
-#include <stdlib.h>
-#include <inttypes.h>
-
-#include "mputils.h"
-#include "ass_utils.h"
-
-int mystrtoi(char** p, int base, int* res)
-{
-	char* start = *p;
-	*res = strtol(*p, p, base);
-	if (*p != start) return 1;
-	else return 0;
-}
-
-int mystrtou32(char** p, int base, uint32_t* res)
-{
-	char* start = *p;
-	*res = strtoll(*p, p, base);
-	if (*p != start) return 1;
-	else return 0;
-}
-
-int mystrtod(char** p, double* res)
-{
-	char* start = *p;
-	*res = strtod(*p, p);
-	if (*p != start) return 1;
-	else return 0;
-}
-
-int strtocolor(char** q, uint32_t* res)
-{
-	uint32_t color = 0;
-	int result;
-	char* p = *q;
-	
-	if (*p == '&') ++p; 
-	else mp_msg(MSGT_ASS, MSGL_DBG2, "suspicious color format: \"%s\"\n", p);
-	
-	if (*p == 'H' || *p == 'h') { 
-		++p;
-		result = mystrtou32(&p, 16, &color);
-	} else {
-		result = mystrtou32(&p, 0, &color);
-	}
-	
-	{
-		unsigned char* tmp = (unsigned char*)(&color);
-		unsigned char b;
-		b = tmp[0]; tmp[0] = tmp[3]; tmp[3] = b;
-		b = tmp[1]; tmp[1] = tmp[2]; tmp[2] = b;
-	}
-	if (*p == '&') ++p;
-	*q = p;
-
-	*res = color;
-	return result;
-}
-

Deleted: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/ass_utils.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/ass_utils.h	2009-07-31 22:24:31 UTC (rev 5184)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/ass_utils.h	2009-08-01 07:55:22 UTC (rev 5185)
@@ -1,61 +0,0 @@
-// -*- c-basic-offset: 8; indent-tabs-mode: t -*-
-// vim:ts=8:sw=8:noet:ai:
-/*
-  Copyright (C) 2006 Evgeniy Stepanov <eugeni.stepanov at gmail.com>
-
-  This program is free software; you can redistribute it and/or modify
-  it under the terms of the GNU General Public License as published by
-  the Free Software Foundation; either version 2 of the License, or
-  (at your option) any later version.
-
-  This program is distributed in the hope that it will be useful,
-  but WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  GNU General Public License for more details.
-
-  You should have received a copy of the GNU General Public License
-  along with this program; if not, write to the Free Software
-  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
-*/
-
-#ifndef ASS_UTILS_H
-#define ASS_UTILS_H
-
-int mystrtoi(char** p, int base, int* res);
-int mystrtou32(char** p, int base, uint32_t* res);
-int mystrtod(char** p, double* res);
-int strtocolor(char** q, uint32_t* res);
-
-static inline int d6_to_int(int x) {
-	return (x + 32) >> 6;
-}
-static inline int d16_to_int(int x) {
-	return (x + 32768) >> 16;
-}
-static inline int int_to_d6(int x) {
-	return x << 6;
-}
-static inline int int_to_d16(int x) {
-	return x << 16;
-}
-static inline int d16_to_d6(int x) {
-	return (x + 512) >> 10;
-}
-static inline int d6_to_d16(int x) {
-	return x << 10;
-}
-static inline double d6_to_double(int x) {
-	return x / 64.;
-}
-static inline int double_to_d6(double x) {
-	return (int)(x * 64);
-}
-static inline double d16_to_double(int x) {
-	return ((double)x) / 0x10000;
-}
-static inline int double_to_d16(double x) {
-	return (int)(x * 0x10000);
-}
-
-#endif
-

Deleted: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/help_mp.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/help_mp.h	2009-07-31 22:24:31 UTC (rev 5184)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/help_mp.h	2009-08-01 07:55:22 UTC (rev 5185)
@@ -1,55 +0,0 @@
-#ifndef __LIBASS_HELP_MP_H__
-#define __LIBASS_HELP_MP_H__
-#define MSGTR_LIBASS_FT_Glyph_To_BitmapError "[ass] FT_Glyph_To_Bitmap error %d \n"
-#define MSGTR_LIBASS_UnsupportedPixelMode "[ass] Unsupported pixel mode: %d\n"
-#define MSGTR_LIBASS_NoStyleNamedXFoundUsingY "[ass] [%p] Warning: no style named '%s' found, using '%s'\n"
-#define MSGTR_LIBASS_BadTimestamp "[ass] bad timestamp\n"
-#define MSGTR_LIBASS_BadEncodedDataSize "[ass] bad encoded data size\n"
-#define MSGTR_LIBASS_FontLineTooLong "[ass] Font line too long: %d, %s\n"
-#define MSGTR_LIBASS_EventFormatHeaderMissing "[ass] Event format header missing\n"
-#define MSGTR_LIBASS_ErrorOpeningIconvDescriptor "[ass] error opening iconv descriptor.\n"
-#define MSGTR_LIBASS_ErrorRecodingFile "[ass] error recoding file.\n"
-#define MSGTR_LIBASS_FopenFailed "[ass] ass_read_file(%s): fopen failed\n"
-#define MSGTR_LIBASS_FseekFailed "[ass] ass_read_file(%s): fseek failed\n"
-#define MSGTR_LIBASS_RefusingToLoadSubtitlesLargerThan10M "[ass] ass_read_file(%s): Refusing to load subtitles larger than 10M\n"
-#define MSGTR_LIBASS_ReadFailed "Read failed, %d: %s\n"
-#define MSGTR_LIBASS_AddedSubtitleFileMemory "[ass] Added subtitle file: <memory> (%d styles, %d events)\n"
-#define MSGTR_LIBASS_AddedSubtitleFileFname "[ass] Added subtitle file: %s (%d styles, %d events)\n"
-#define MSGTR_LIBASS_FailedToCreateDirectory "[ass] Failed to create directory %s\n"
-#define MSGTR_LIBASS_NotADirectory "[ass] Not a directory: %s\n"
-#define MSGTR_LIBASS_TooManyFonts "[ass] Too many fonts\n"
-#define MSGTR_LIBASS_ErrorOpeningFont "[ass] Error opening font: %s, %d\n"
-#define MSGTR_LIBASS_SelectedFontFamilyIsNotTheRequestedOne "[ass] fontconfig: Selected font family is not the requested one: '%s' != '%s'\n"
-#define MSGTR_LIBASS_UsingDefaultFontFamily "[ass] fontconfig_select: Using default font family: (%s, %d, %d) -> %s, %d\n"
-#define MSGTR_LIBASS_UsingDefaultFont "[ass] fontconfig_select: Using default font: (%s, %d, %d) -> %s, %d\n"
-#define MSGTR_LIBASS_UsingArialFontFamily "[ass] fontconfig_select: Using 'Arial' font family: (%s, %d, %d) -> %s, %d\n"
-#define MSGTR_LIBASS_FcInitLoadConfigAndFontsFailed "[ass] FcInitLoadConfigAndFonts failed.\n"
-#define MSGTR_LIBASS_UpdatingFontCache "[ass] Updating font cache.\n"
-#define MSGTR_LIBASS_BetaVersionsOfFontconfigAreNotSupported "[ass] Beta versions of fontconfig are not supported.\n[ass] Update before reporting any bugs.\n"
-#define MSGTR_LIBASS_FcStrSetAddFailed "[ass] FcStrSetAdd failed.\n"
-#define MSGTR_LIBASS_FcDirScanFailed "[ass] FcDirScan failed.\n"
-#define MSGTR_LIBASS_FcDirSave "[ass] FcDirSave failed.\n"
-#define MSGTR_LIBASS_FcConfigAppFontAddDirFailed "[ass] FcConfigAppFontAddDir failed\n"
-#define MSGTR_LIBASS_FontconfigDisabledDefaultFontWillBeUsed "[ass] Fontconfig disabled, only default font will be used.\n"
-#define MSGTR_LIBASS_FunctionCallFailed "[ass] %s failed\n"
-#define MSGTR_LIBASS_NeitherPlayResXNorPlayResYDefined "[ass] Neither PlayResX nor PlayResY defined. Assuming 384x288.\n"
-#define MSGTR_LIBASS_PlayResYUndefinedSettingY "[ass] PlayResY undefined, setting %d.\n"
-#define MSGTR_LIBASS_PlayResXUndefinedSettingX "[ass] PlayResX undefined, setting %d.\n"
-#define MSGTR_LIBASS_FT_Init_FreeTypeFailed "[ass] FT_Init_FreeType failed.\n"
-#define MSGTR_LIBASS_Init "[ass] Init\n"
-#define MSGTR_LIBASS_InitFailed "[ass] Init failed.\n"
-#define MSGTR_LIBASS_BadCommand "[ass] Bad command: %c%c\n"
-#define MSGTR_LIBASS_ErrorLoadingGlyph  "[ass] Error loading glyph.\n"
-#define MSGTR_LIBASS_FT_Glyph_Stroke_Error "[ass] FT_Glyph_Stroke error %d \n"
-#define MSGTR_LIBASS_UnknownEffectType_InternalError "[ass] Unknown effect type (internal error)\n"
-#define MSGTR_LIBASS_NoStyleFound "[ass] No style found!\n"
-#define MSGTR_LIBASS_EmptyEvent "[ass] Empty event!\n"
-#define MSGTR_LIBASS_MAX_GLYPHS_Reached "[ass] MAX_GLYPHS reached: event %d, start = %llu, duration = %llu\n Text = %s\n"
-#define MSGTR_LIBASS_EventHeightHasChanged "[ass] Warning! Event height has changed!  \n"
-#define MSGTR_LIBASS_GlyphNotFoundReselectingFont "[ass] Glyph 0x%X not found, reselecting font for (%s, %d, %d)\n"
-#define MSGTR_LIBASS_GlyphNotFound "[ass] Glyph 0x%X not found in font for (%s, %d, %d)\n"
-#define MSGTR_LIBASS_ErrorOpeningMemoryFont "[ass] Error opening memory font: %s\n"
-#define MSGTR_LIBASS_NoCharmaps "[ass] font face with no charmaps\n"
-#define MSGTR_LIBASS_NoCharmapAutodetected "[ass] no charmap autodetected, trying the first one\n"
-#endif
-

Deleted: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/mputils.c
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/mputils.c	2009-07-31 22:24:31 UTC (rev 5184)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/mputils.c	2009-08-01 07:55:22 UTC (rev 5185)
@@ -1,218 +0,0 @@
-//#include "config.h"
-
-#include "mputils.h"
-
-#include <stdio.h>
-#include <stdarg.h>
-#include <stdint.h>
-#include <stdlib.h>
-#include <string.h>
-#include <assert.h>
-
-#ifdef HAVE_ENCA
-#include <enca.h>
-#endif
-
-void my_mp_msg(int lvl, char *lvl_str, char *fmt, ...) {
-	va_list va;
-	if(lvl > MSGL_V) return;
-	printf("[ass] **%s**: ", lvl_str);
-	va_start(va, fmt);
-	vprintf(fmt, va);
-	va_end(va);
-}
-
-unsigned utf8_get_char(char **str) {
-  uint8_t *strp = (uint8_t *)*str;
-  unsigned c = *strp++;
-  unsigned mask = 0x80;
-  int len = -1;
-  while (c & mask) {
-    mask >>= 1;
-    len++;
-  }
-  if (len <= 0 || len > 4)
-    goto no_utf8;
-  c &= mask - 1;
-  while ((*strp & 0xc0) == 0x80) {
-    if (len-- <= 0)
-      goto no_utf8;
-    c = (c << 6) | (*strp++ & 0x3f);
-  }
-  if (len)
-    goto no_utf8;
-  *str = (char *)strp;
-  return c;
-
-no_utf8:
-  strp = (uint8_t *)*str;
-  c = *strp++;
-  *str = (char *)strp;
-  return c;
-}
-
-// gaussian blur
-void blur(
-	unsigned char *buffer,
-	unsigned short *tmp2,
-	int width,
-	int height,
-	int stride,
-	int *m2,
-	int r,
-	int mwidth) {
-
-    int x, y;
-
-    unsigned char  *s = buffer;
-    unsigned short *t = tmp2+1;
-    for(y=0; y<height; y++){
-	memset(t-1, 0, (width+1)*sizeof(short));
-
-	for(x=0; x<r; x++){
-	    const int src= s[x];
-	    if(src){
-		register unsigned short *dstp= t + x-r;
-		int mx;
-		unsigned *m3= m2 + src*mwidth;
-		for(mx=r-x; mx<mwidth; mx++){
-		    dstp[mx]+= m3[mx];
-		}
-	    }
-	}
-
-	for(; x<width-r; x++){
-	    const int src= s[x];
-	    if(src){
-		register unsigned short *dstp= t + x-r;
-		int mx;
-		unsigned *m3= m2 + src*mwidth;
-		for(mx=0; mx<mwidth; mx++){
-		    dstp[mx]+= m3[mx];
-		}
-	    }
-	}
-
-	for(; x<width; x++){
-	    const int src= s[x];
-	    if(src){
-		register unsigned short *dstp= t + x-r;
-		int mx;
-		const int x2= r+width -x;
-		unsigned *m3= m2 + src*mwidth;
-		for(mx=0; mx<x2; mx++){
-		    dstp[mx]+= m3[mx];
-		}
-	    }
-	}
-
-	s+= stride;
-	t+= width + 1;
-    }
-
-    t = tmp2;
-    for(x=0; x<width; x++){
-	for(y=0; y<r; y++){
-	    unsigned short *srcp= t + y*(width+1) + 1;
-	    int src= *srcp;
-	    if(src){
-		register unsigned short *dstp= srcp - 1 + width+1;
-		const int src2= (src + 128)>>8;
-		unsigned *m3= m2 + src2*mwidth;
-
-		int mx;
-		*srcp= 128;
-		for(mx=r-1; mx<mwidth; mx++){
-		    *dstp += m3[mx];
-		    dstp+= width+1;
-		}
-	    }
-	}
-	for(; y<height-r; y++){
-	    unsigned short *srcp= t + y*(width+1) + 1;
-	    int src= *srcp;
-	    if(src){
-		register unsigned short *dstp= srcp - 1 - r*(width+1);
-		const int src2= (src + 128)>>8;
-		unsigned *m3= m2 + src2*mwidth;
-
-		int mx;
-		*srcp= 128;
-		for(mx=0; mx<mwidth; mx++){
-		    *dstp += m3[mx];
-		    dstp+= width+1;
-		}
-	    }
-	}
-	for(; y<height; y++){
-	    unsigned short *srcp= t + y*(width+1) + 1;
-	    int src= *srcp;
-	    if(src){
-		const int y2=r+height-y;
-		register unsigned short *dstp= srcp - 1 - r*(width+1);
-		const int src2= (src + 128)>>8;
-		unsigned *m3= m2 + src2*mwidth;
-
-		int mx;
-		*srcp= 128;
-		for(mx=0; mx<y2; mx++){
-		    *dstp += m3[mx];
-		    dstp+= width+1;
-		}
-	    }
-	}
-	t++;
-    }
-
-    t = tmp2;
-    s = buffer;
-    for(y=0; y<height; y++){
-	for(x=0; x<width; x++){
-	    s[x]= t[x]>>8;
-	}
-	s+= stride;
-	t+= width + 1;
-    }
-}
-
-#ifdef HAVE_ENCA
-void* guess_buffer_cp(unsigned char* buffer, int buflen, char *preferred_language, char *fallback)
-{
-    const char **languages;
-    size_t langcnt;
-    EncaAnalyser analyser;
-    EncaEncoding encoding;
-    char *detected_sub_cp = NULL;
-    int i;
-
-    languages = enca_get_languages(&langcnt);
-    mp_msg(MSGT_ASS, MSGL_V, "ENCA supported languages: ");
-    for (i = 0; i < langcnt; i++) {
-	mp_msg(MSGT_ASS, MSGL_V, "%s ", languages[i]);
-    }
-    mp_msg(MSGT_ASS, MSGL_V, "\n");
-    
-    for (i = 0; i < langcnt; i++) {
-	const char *tmp;
-	
-	if (strcasecmp(languages[i], preferred_language) != 0) continue;
-	analyser = enca_analyser_alloc(languages[i]);
-	encoding = enca_analyse_const(analyser, buffer, buflen);
-	tmp = enca_charset_name(encoding.charset, ENCA_NAME_STYLE_ICONV);
-	if (tmp && encoding.charset != ENCA_CS_UNKNOWN) {
-	    detected_sub_cp = strdup(tmp);
-	    mp_msg(MSGT_ASS, MSGL_INFO, "ENCA detected charset: %s\n", tmp);
-	}
-	enca_analyser_free(analyser);
-    }
-    
-    free(languages);
-
-    if (!detected_sub_cp) {
-	detected_sub_cp = strdup(fallback);
-	mp_msg(MSGT_ASS, MSGL_INFO, "ENCA detection failed: fallback to %s\n", fallback);
-    }
-
-    return detected_sub_cp;
-}
-#endif

Deleted: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/mputils.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/mputils.h	2009-07-31 22:24:31 UTC (rev 5184)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/mputils.h	2009-08-01 07:55:22 UTC (rev 5185)
@@ -1,35 +0,0 @@
-#ifndef __MPUTILS_H__
-#define __MPUTILS_H__
-
-#include "help_mp.h"
-
-unsigned utf8_get_char(char **str);
-
-void my_mp_msg(int lvl, char *lvl_str, char *fmt, ...);
-
-#ifdef __VISUALC__
-static void mp_msg(int mod, int level, const char *fmt, ...) {
-	// MSVC doesn't like the # used all around for mp_msg, so it breaks va_arg
-}
-#else
-#define mp_msg(mod, level, args...) my_mp_msg(level, #level, args)
-#endif
-
-#define MSGT_ASS 43
-
-#define MSGL_FATAL 0
-#define MSGL_ERR 1
-#define MSGL_WARN 2
-#define MSGL_INFO 4
-#define MSGL_V 6
-#define MSGL_DBG2 7
-
-void blur(unsigned char *buffer, unsigned short *tmp2, int width, int height,
-          int stride, int *m2, int r, int mwidth);
-
-void* guess_buffer_cp(unsigned char* buffer, int buflen, char *preferred_language, char *fallback);
-
-#define FFMAX(a,b) ((a) > (b) ? (a) : (b))
-#define FFMIN(a,b) ((a) > (b) ? (b) : (a))
-
-#endif

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_vidASS.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_vidASS.cpp	2009-07-31 22:24:31 UTC (rev 5184)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_vidASS.cpp	2009-08-01 07:55:22 UTC (rev 5185)
@@ -174,7 +174,10 @@
         ass_set_margins(_ass_rend, _params->top_margin, _params->bottom_margin, 0, 0);
         ass_set_use_margins(_ass_rend, use_margins);
         ass_set_font_scale(_ass_rend, _params->font_scale);
-        ass_set_fonts(_ass_rend, NULL, "Sans");
+        ass_set_fonts(_ass_rend, NULL, "Sans",
+                false, // No fontconfig
+                NULL,
+                false);
         //~ ass_set_aspect_ratio(_ass_rend, ((double)_info.width) / ((double)_info.height));
 #if ASS_HAS_GLOBAL
         if(_ass_track) 

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_vidASS.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_vidASS.h	2009-07-31 22:24:31 UTC (rev 5184)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_vidASS.h	2009-08-01 07:55:22 UTC (rev 5185)
@@ -14,7 +14,7 @@
 
 extern "C"
 {
-#include "ADM_libass/ass.h"
+#include "ADM_libAss/ass.h"
 }
 #include "ADM_vidAss_Params.h" 
 class ADMVideoSubASS : public AVDMGenericVideoStream 

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/CMakeLists.txt	2009-07-31 22:24:31 UTC (rev 5184)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/CMakeLists.txt	2009-08-01 07:55:22 UTC (rev 5185)
@@ -2,7 +2,7 @@
 checkFreeType()
 
 IF (USE_FREETYPE)
-	ADD_SUBDIRECTORY(ADM_libass)
+	ADD_SUBDIRECTORY(ADM_libAss)
 
 	INCLUDE(vf_plugin)
 	SET(ADM_vf_ssa_SRCS ADM_vidASS.cpp)



From mean at mail.berlios.de  Sat Aug  1 09:55:28 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sat, 1 Aug 2009 09:55:28 +0200
Subject: [Avidemux-svn-commit] r5186 -
	branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass
Message-ID: <200908010755.n717tS4k016427@sheep.berlios.de>

Author: mean
Date: 2009-08-01 09:55:28 +0200 (Sat, 01 Aug 2009)
New Revision: 5186

Modified:
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_vidASS.cpp
Log:
[Ass] Simplify fonts to avoid crash + enable freeing stuff as the globals have been remove from libass

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_vidASS.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_vidASS.cpp	2009-08-01 07:55:22 UTC (rev 5185)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_vidASS.cpp	2009-08-01 07:55:28 UTC (rev 5186)
@@ -18,8 +18,8 @@
 #include "ADM_colorspace.h"
 #include "DIA_factory.h"
 
+#define ASS_HAS_GLOBAL 1 // no more globals, we can cleanup
 
-
 #ifndef DIR_SEP
 # ifdef WIN32
 #   define DIR_SEP '\\'
@@ -156,8 +156,8 @@
         memcpy(&_info,_in->getInfo(),sizeof(_info));
         _info.height += _params->top_margin + _params->bottom_margin;
 
-        ass_set_fonts_dir(_ass_lib, (const char*)_params->fonts_dir);
-        ass_set_extract_fonts(_ass_lib, _params->extract_embedded_fonts);
+        ass_set_fonts_dir(_ass_lib, ""); //(const char*)_params->fonts_dir);
+        ass_set_extract_fonts(_ass_lib, 0); // _params->extract_embedded_fonts);
         ass_set_style_overrides(_ass_lib, NULL);
 #if ASS_HAS_GLOBAL
          if(_ass_rend) 
@@ -175,9 +175,9 @@
         ass_set_use_margins(_ass_rend, use_margins);
         ass_set_font_scale(_ass_rend, _params->font_scale);
         ass_set_fonts(_ass_rend, NULL, "Sans",
-                false, // No fontconfig
+                1, // No fontconfig
                 NULL,
-                false);
+                1);
         //~ ass_set_aspect_ratio(_ass_rend, ((double)_info.width) / ((double)_info.height));
 #if ASS_HAS_GLOBAL
         if(_ass_track) 
@@ -206,19 +206,19 @@
         DELETE(_params);
       }
 #if ASS_HAS_GLOBAL
+        if(_ass_track) 
+        {
+              ass_free_track(_ass_track);
+              _ass_track = NULL;
+        }
         if(_ass_rend) 
         {
               ass_renderer_done(_ass_rend);
               _ass_rend = NULL;
          }
 
-        if(_ass_track) 
+             if(_ass_lib) 
         {
-              ass_free_track(_ass_track);
-              _ass_track = NULL;
-        }
-        if(_ass_lib) 
-        {
               ass_library_done(_ass_lib);
               _ass_lib = NULL;
         }



From mean at mail.berlios.de  Sat Aug  1 09:55:29 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sat, 1 Aug 2009 09:55:29 +0200
Subject: [Avidemux-svn-commit] r5187 - branches/avidemux_2.5_branch_gruntster
Message-ID: <200908010755.n717tTXg016437@sheep.berlios.de>

Author: mean
Date: 2009-08-01 09:55:29 +0200 (Sat, 01 Aug 2009)
New Revision: 5187

Modified:
   branches/avidemux_2.5_branch_gruntster/.gitignore
Log:
[misc] Update gitignore

Modified: branches/avidemux_2.5_branch_gruntster/.gitignore
===================================================================
--- branches/avidemux_2.5_branch_gruntster/.gitignore	2009-08-01 07:55:28 UTC (rev 5186)
+++ branches/avidemux_2.5_branch_gruntster/.gitignore	2009-08-01 07:55:29 UTC (rev 5187)
@@ -4,3 +4,7 @@
 [tT]ags
 Doxyfile
 *.kdev*
+avidemux/ADM_libraries/ffmpeg/
+build*/
+*.sw*
+



From gruntster at mail.berlios.de  Sat Aug  1 12:24:40 2009
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Sat, 1 Aug 2009 12:24:40 +0200
Subject: [Avidemux-svn-commit] r5188 -
	branches/avidemux_2.5_branch_gruntster/avidemux/ADM_UIs/ADM_GTK/src
Message-ID: <200908011024.n71AOe4F029246@sheep.berlios.de>

Author: gruntster
Date: 2009-08-01 12:24:30 +0200 (Sat, 01 Aug 2009)
New Revision: 5188

Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_UIs/ADM_GTK/src/FAC_bitrate.cpp
Log:
[dlgFactory] make updateMe method of GTK bitrate control work

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_UIs/ADM_GTK/src/FAC_bitrate.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_UIs/ADM_GTK/src/FAC_bitrate.cpp	2009-08-01 07:55:29 UTC (rev 5187)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_UIs/ADM_GTK/src/FAC_bitrate.cpp	2009-08-01 10:24:30 UTC (rev 5188)
@@ -17,6 +17,13 @@
 #include "DIA_factory.h"
 namespace ADM_GtkFactory
 {
+struct diaElemBitrateData
+{
+	GtkWidget *label1, *label2, *combo, *spin;
+	COMPRES_PARAMS *param;
+	unsigned int maxQ, minQ;
+};
+
 class diaElemBitrate : public diaElemBitrateBase
 {
 protected:
@@ -32,7 +39,7 @@
   int getRequiredLayout(void);
 };
 
-static void cb_mod(void *w,void *p);
+static void cb_mod(GtkWidget *widget, gpointer *data);
 /**
  * 	\fn 	readPullDown
  * \brief 	Convert the raw read of the combox into the actual compression mode
@@ -107,9 +114,10 @@
 }
 diaElemBitrate::~diaElemBitrate()
 {
-  GtkWidget *w=(GtkWidget *)myWidget;
-  delete [] w;
-  myWidget=NULL;
+	diaElemBitrateData *data = (diaElemBitrateData*)myWidget;
+
+	delete data;
+	myWidget = NULL;
 }
 /**
  * \fn setMe
@@ -184,148 +192,140 @@
     PUT_ARRAY(1,1,spin);
   /*  add button */
    gtk_label_set_mnemonic_widget (GTK_LABEL(label1), combo);
-   gtk_label_set_mnemonic_widget (GTK_LABEL(label2), spin); 
-   
-  gtk_signal_connect(GTK_OBJECT(combo), "changed",
-                      GTK_SIGNAL_FUNC(cb_mod),
-                      (void *) this);
-  
-  GtkWidget **w;
-  w=new GtkWidget*[4];
-  w[0]=label1;
-  w[1]=label2;
-  w[2]=combo;
-  w[3]=spin;
-  myWidget=(void *)w;
-  
-  updatePulldown(&copy, GTK_COMBO_BOX(combo));
+   gtk_label_set_mnemonic_widget (GTK_LABEL(label2), spin);
+
+   diaElemBitrateData *data = new diaElemBitrateData;
+
+   data->param = &copy;
+   data->label1 = label1;
+   data->label2 = label2;
+   data->combo = combo;
+   data->spin = spin;
+   data->maxQ = maxQ;
+   data->minQ = minQ;
+
+   myWidget = (void*)data;
+
+   gtk_signal_connect(GTK_OBJECT(data->combo), "changed",
+	   G_CALLBACK(cb_mod), (void *)data);
+
+   updatePulldown(&copy, GTK_COMBO_BOX(combo));
 }
 
-
 void diaElemBitrate::getMe(void)
 {
-  
-  
   // Read current value
-  GtkWidget **w=(GtkWidget **)myWidget;
-  GtkComboBox *combo=(GtkComboBox *)w[2];
-  GtkSpinButton *spin=(GtkSpinButton*)w[3];
-  GtkLabel *label=(GtkLabel*)w[1];
+  diaElemBitrateData *data = (diaElemBitrateData*)myWidget;
+  int rank = gtk_combo_box_get_active(GTK_COMBO_BOX(data->combo));
+  data->param->mode = readPulldown(data->param,rank);
 
-  int rank=gtk_combo_box_get_active(GTK_COMBO_BOX(combo));
-  COMPRESSION_MODE mode=readPulldown(&copy,rank);
-    
-  
 #undef P
 #undef M
 #undef S
 #define P(x) 
 #define M(x,y)
-#define S(x)   x=(uint32_t)gtk_spin_button_get_value  (GTK_SPIN_BUTTON(spin))
-  switch(mode)
+#define S(x)   x=(uint32_t)gtk_spin_button_get_value  (GTK_SPIN_BUTTON(data->spin))
+  switch(data->param->mode)
   {
     case COMPRESS_CBR: //CBR
           P(_Bitrate (kb/s):);
           M(0,20000);
-          S(copy.bitrate);
-          copy.mode=COMPRESS_CBR;
+          S(data->param->bitrate);
           break;
     case COMPRESS_AQ:// CQ
           P(_Quantizer:);
           M(2,31);
-          S(copy.qz);
-          copy.mode=COMPRESS_AQ;
+          S(data->param->qz);
           break;
-
     case COMPRESS_CQ:// CQ
           P(_Quantizer:);
           M(2,31);
-          S(copy.qz);
-          copy.mode=COMPRESS_CQ;
+          S(data->param->qz);
           break;
     case  COMPRESS_2PASS: // 2pass Filesize
           P(_Video size (MB):);
           M(1,8000);
-          S(copy.finalsize);
-          copy.mode=COMPRESS_2PASS;
+          S(data->param->finalsize);
           break;
     case COMPRESS_2PASS_BITRATE : // 2pass Avg
           P(_Average bitrate (kb/s):);
           M(0,20000);
-          S(copy.avg_bitrate);
-          copy.mode=COMPRESS_2PASS_BITRATE;
+          S(data->param->avg_bitrate);
           break;
     case COMPRESS_SAME : // Same Qz as input
           P(-);
           M(0,0);
-          copy.mode=COMPRESS_SAME;
           break;
-    default:ADM_assert(0);
+    default:
+		ADM_assert(0);
   }
-  memcpy(param,&copy,sizeof(copy));
+
+  memcpy(param, data->param, sizeof(COMPRES_PARAMS));
 }
 
 int diaElemBitrate::getRequiredLayout(void) { return 0; }
 
-void diaElemBitrate::updateMe(void)
+void updateCombo(diaElemBitrateData *data)
 {
-  memcpy(&copy, param, sizeof(copy));
-
-  // Read current value
-  GtkWidget **w=(GtkWidget **)myWidget;
-  GtkComboBox *combo=(GtkComboBox *)w[2];
-  GtkSpinButton *spin=(GtkSpinButton*)w[3];
-  GtkLabel *label=(GtkLabel*)w[1];
-  int index = 0, set = 0;
-
 #undef M
 #undef S
-#define M(x,y) gtk_spin_button_set_range  (GTK_SPIN_BUTTON(spin),x,y)
-#define S(x)   gtk_spin_button_set_value  (GTK_SPIN_BUTTON(spin),x)
+#define M(x,y) gtk_spin_button_set_range  (GTK_SPIN_BUTTON(data->spin),x,y)
+#define S(x)   gtk_spin_button_set_value  (GTK_SPIN_BUTTON(data->spin),x)
 
-  updatePulldown(&copy, GTK_COMBO_BOX(combo));
+  updatePulldown(data->param, GTK_COMBO_BOX(data->combo));
 
-  switch (copy.mode)
+  switch (data->param->mode)
   {
     case COMPRESS_CBR:
-          gtk_label_set_text_with_mnemonic(GTK_LABEL(label),QT_TR_NOOP("_Bitrate (kb/s):"));
+          gtk_label_set_text_with_mnemonic(GTK_LABEL(data->label2),QT_TR_NOOP("_Bitrate (kb/s):"));
           M(0,20000);
-          S(copy.bitrate);
+          S(data->param->bitrate);
           break; 
     case COMPRESS_CQ:
-          gtk_label_set_text_with_mnemonic(GTK_LABEL(label),QT_TR_NOOP("_Quantizer:"));
-          M(minQ,maxQ);
-          S(copy.qz);
+          gtk_label_set_text_with_mnemonic(GTK_LABEL(data->label2),QT_TR_NOOP("_Quantizer:"));
+          M(data->minQ,data->maxQ);
+          S(data->param->qz);
           break;
     case COMPRESS_AQ:
-          gtk_label_set_text_with_mnemonic(GTK_LABEL(label),QT_TR_NOOP("A_vg Quantizer:"));
+          gtk_label_set_text_with_mnemonic(GTK_LABEL(data->label2),QT_TR_NOOP("A_vg Quantizer:"));
           M(2,64);
-          S(copy.qz);
+          S(data->param->qz);
           break;
     case COMPRESS_2PASS:
-          gtk_label_set_text_with_mnemonic(GTK_LABEL(label),QT_TR_NOOP("_Video size (MB):"));
+          gtk_label_set_text_with_mnemonic(GTK_LABEL(data->label2),QT_TR_NOOP("_Video size (MB):"));
           M(1,8000);
-          S(copy.finalsize);
+          S(data->param->finalsize);
           break;
     case COMPRESS_2PASS_BITRATE:
-          gtk_label_set_text_with_mnemonic(GTK_LABEL(label),QT_TR_NOOP("_Average bitrate (kb/s):"));
+          gtk_label_set_text_with_mnemonic(GTK_LABEL(data->label2),QT_TR_NOOP("_Average bitrate (kb/s):"));
           M(0,20000);
-          S(copy.avg_bitrate);
+          S(data->param->avg_bitrate);
           break;
     case COMPRESS_SAME : // Same Qz as input
-          gtk_label_set_text_with_mnemonic(GTK_LABEL(label),QT_TR_NOOP("-"));
+          gtk_label_set_text_with_mnemonic(GTK_LABEL(data->label2),QT_TR_NOOP("-"));
           M(0,0);
           break;
-    default:ADM_assert(0);
+    default:
+		ADM_assert(0);
   }
 }
 
-void cb_mod(void *w,void *p)
+void diaElemBitrate::updateMe(void)
 {
-  diaElemBitrate *me=(diaElemBitrate *)p;
-  me->updateMe();
+	diaElemBitrateData *data = (diaElemBitrateData*)myWidget;
+
+	memcpy(data->param, param, sizeof(COMPRES_PARAMS));
+	updateCombo(data);
 }
 
+void cb_mod(GtkWidget *widget, gpointer *d)
+{
+	diaElemBitrateData *data = (diaElemBitrateData*)d;
+
+	data->param->mode = readPulldown(data->param, gtk_combo_box_get_active(GTK_COMBO_BOX(data->combo)));
+	updateCombo(data);
+}
+
 } // End of namespace
 //****************************Hoook*****************
 



From gruntster at mail.berlios.de  Sat Aug  1 12:30:09 2009
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Sat, 1 Aug 2009 12:30:09 +0200
Subject: [Avidemux-svn-commit] r5189 -
	branches/avidemux_2.5_branch_gruntster/avidemux/ADM_UIs/ADM_GTK/src
Message-ID: <200908011030.n71AU9LS029797@sheep.berlios.de>

Author: gruntster
Date: 2009-08-01 12:30:04 +0200 (Sat, 01 Aug 2009)
New Revision: 5189

Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_UIs/ADM_GTK/src/FAC_configMenu.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_UIs/ADM_GTK/src/FAC_menu.cpp
Log:
[dlgFactory] trigger custom profile on GTK config menu (control should now be complete for both toolkits)

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_UIs/ADM_GTK/src/FAC_configMenu.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_UIs/ADM_GTK/src/FAC_configMenu.cpp	2009-08-01 10:24:30 UTC (rev 5188)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_UIs/ADM_GTK/src/FAC_configMenu.cpp	2009-08-01 10:30:04 UTC (rev 5189)
@@ -30,10 +30,11 @@
 
 namespace ADM_GtkFactory
 {
-	class diaElemConfigMenuData
+	struct diaElemConfigMenuData
 	{
-	public:
 		bool disableSignals;
+
+		GtkDialog *dialog;
 		GtkComboBox *combo;
 		GtkButton *deleteButton;
 
@@ -210,25 +211,40 @@
 		const char* selectedConfig = gtk_combo_box_get_active_text(menuData->combo);
 		bool origDisableSignals = menuData->disableSignals;
 
+		menuData->disableSignals = true;
+
 		if (selectedConfig)
 		{
 			map<string, int>::iterator it = menuData->configs->find(string((selectedConfig)));
 
 			gtk_widget_set_sensitive(GTK_WIDGET(menuData->deleteButton), it->second == CONFIG_MENU_USER);
 
+			for (int i = 0; i < menuData->controlCount; i++)
+				menuData->controls[i]->getMe();
+
 			if (menuData->changedFunc)
 			{
-				if (!menuData->changedFunc(selectedConfig, (ConfigMenuType)it->second))
+				if (menuData->changedFunc(selectedConfig, (ConfigMenuType)it->second))
+				{
+					for (int i = 0; i < menuData->controlCount; i++)
+						menuData->controls[i]->updateMe();
+				}
+				else
 					gtk_combo_box_set_active(menuData->combo, 0);
-
-				for (int i = 0; i < menuData->controlCount; i++)
-					menuData->controls[i]->updateMe();
 			}
 		}
 
 		menuData->disableSignals = origDisableSignals;
 	}
 
+	void genericControlChanged(GtkWidget *widget, gpointer *data)
+	{
+		diaElemConfigMenuData *menuData = (diaElemConfigMenuData*)data;
+
+		if (!menuData->disableSignals)
+			gtk_combo_box_set_active(menuData->combo, 1);
+	}
+
 	class diaElemConfigMenu : public diaElem
 	{
 	protected:
@@ -301,6 +317,7 @@
 
 		diaElemConfigMenuData *data = new diaElemConfigMenuData();
 
+		data->dialog = (GtkDialog*)dialog;
 		data->combo = combo;
 		data->deleteButton = button2;
 		data->controls = controls;
@@ -339,8 +356,37 @@
 		selectConfiguration(menuData, this->configName, *this->configType);
 	}
 
+	void traverseChildren(GtkContainer *container, diaElemConfigMenuData *menuData)
+	{
+		GList *list = gtk_container_get_children(container);
+
+		for (GList *listItem = g_list_first(list); listItem != NULL; listItem = g_list_next(listItem))
+		{
+			const char* typeName = g_type_name(GTK_OBJECT_TYPE(listItem->data));
+
+			if (GTK_IS_CONTAINER(listItem->data))
+				traverseChildren(GTK_CONTAINER(listItem->data), menuData);
+
+			if (strcmp(typeName, "GtkComboBox") == 0 && GTK_COMBO_BOX(listItem->data) != menuData->combo)
+				g_signal_connect(GTK_OBJECT(listItem->data), "changed", G_CALLBACK(genericControlChanged), menuData);
+			else if (strcmp(typeName, "GtkSpinButton") == 0)
+				g_signal_connect(GTK_OBJECT(listItem->data), "value-changed", G_CALLBACK(genericControlChanged), menuData);
+			else if (strcmp(typeName, "GtkCheckButton") == 0)
+				g_signal_connect(GTK_OBJECT(listItem->data), "toggled", G_CALLBACK(genericControlChanged), menuData);
+			else if (strcmp(typeName, "GtkRadioButton") == 0)
+				g_signal_connect(GTK_OBJECT(listItem->data), "toggled", G_CALLBACK(genericControlChanged), menuData);
+			else if (strcmp(typeName, "GtkEntry") == 0)
+				g_signal_connect(GTK_OBJECT(listItem->data), "changed", G_CALLBACK(genericControlChanged), menuData);
+		}
+
+		g_list_free(list);
+	}
+
 	void diaElemConfigMenu::finalize(void)
 	{
+		diaElemConfigMenuData *menuData = (diaElemConfigMenuData*)myWidget;
+		traverseChildren(GTK_CONTAINER(menuData->dialog), menuData);
+
 		this->updateMe();
 	}
 }

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_UIs/ADM_GTK/src/FAC_menu.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_UIs/ADM_GTK/src/FAC_menu.cpp	2009-08-01 10:24:30 UTC (rev 5188)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_UIs/ADM_GTK/src/FAC_menu.cpp	2009-08-01 10:30:04 UTC (rev 5189)
@@ -18,9 +18,7 @@
 namespace ADM_GtkFactory
 {
 static void cb_menu(void *w,void *p);
-static void cb_menus(void *w,void *p);
 
-
 class diaElemMenuDynamic : public diaElemMenuDynamicBase
 {
 protected:
@@ -274,11 +272,6 @@
 	me->finalize();
 }
 
-void cb_menus(void *w,void *p)
-{
-  diaElemMenu *me=(diaElemMenu *)p;
-  me->updateMe();
-}
 //********************
 }; // End of namespace
 



From mean at mail.berlios.de  Sat Aug  1 13:02:46 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sat, 1 Aug 2009 13:02:46 +0200
Subject: [Avidemux-svn-commit] r5190 -
	branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass
Message-ID: <200908011102.n71B2kMX030156@sheep.berlios.de>

Author: mean
Date: 2009-08-01 13:02:38 +0200 (Sat, 01 Aug 2009)
New Revision: 5190

Removed:
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Ass/ADM_libass/
Log:
[plugins] remove old ADM_libass, replaced by ADM_libAss



From mean at mail.berlios.de  Sat Aug  1 13:11:59 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sat, 1 Aug 2009 13:11:59 +0200
Subject: [Avidemux-svn-commit] r5191 -
	branches/avidemux_2.5_branch_gruntster/cmake
Message-ID: <200908011111.n71BBxcI007480@sheep.berlios.de>

Author: mean
Date: 2009-08-01 13:11:58 +0200 (Sat, 01 Aug 2009)
New Revision: 5191

Modified:
   branches/avidemux_2.5_branch_gruntster/cmake/Ts.cmake
Log:
[Ts/i18n] Fix dependancies so that it does not break parallel build (xml and lrelease file could be built // while the latter depends on the former)

Modified: branches/avidemux_2.5_branch_gruntster/cmake/Ts.cmake
===================================================================
--- branches/avidemux_2.5_branch_gruntster/cmake/Ts.cmake	2009-08-01 11:02:38 UTC (rev 5190)
+++ branches/avidemux_2.5_branch_gruntster/cmake/Ts.cmake	2009-08-01 11:11:58 UTC (rev 5191)
@@ -59,7 +59,7 @@
                 COMMAND ${LRELEASE_EXECUTABLE}
                     ${_outXml}
                     -qm ${_out}
-                DEPENDS ${_in}
+                DEPENDS ${_in} ${_outXml}
             )
                 
             SET(qm_files ${qm_files} ${_outXml} ${_out})



From mean at mail.berlios.de  Sat Aug  1 17:51:27 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sat, 1 Aug 2009 17:51:27 +0200
Subject: [Avidemux-svn-commit] r5192 - in
	branches/avidemux_2.5_branch_gruntster/avidemux: ADM_icons
	ADM_icons/xpm ADM_userInterfaces/ADM_GTK/ADM_toolkit_gtk
Message-ID: <200908011551.n71FpRAT009490@sheep.berlios.de>

Author: mean
Date: 2009-08-01 17:51:26 +0200 (Sat, 01 Aug 2009)
New Revision: 5192

Added:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_icons/filter1.png
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_icons/filter2.png
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_icons/filter3.png
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_icons/filter4.png
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_icons/filter5.png
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_icons/filter6.png
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_icons/filter7.png
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_icons/xpm/filter1.inc
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_icons/xpm/filter2.inc
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_icons/xpm/filter3.inc
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_icons/xpm/filter4.inc
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_icons/xpm/filter5.inc
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_icons/xpm/filter6.inc
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_icons/xpm/filter7.inc
Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_icons/xpm/Makefile
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_GTK/ADM_toolkit_gtk/ADM_icons.cpp
Log:
[Gtk/icons] Put back the video filter icons, build them properly

Added: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_icons/filter1.png
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_icons/filter1.png	2009-08-01 11:11:58 UTC (rev 5191)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_icons/filter1.png	2009-08-01 15:51:26 UTC (rev 5192)
@@ -0,0 +1,4 @@
+?PNG
+
+
+U?,V???\?????3??J????????'????????dwf^???
\ No newline at end of file

Added: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_icons/filter2.png
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_icons/filter2.png	2009-08-01 11:11:58 UTC (rev 5191)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_icons/filter2.png	2009-08-01 15:51:26 UTC (rev 5192)
@@ -0,0 +1,3 @@
+?PNG
+
+
\ No newline at end of file

Added: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_icons/filter3.png
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_icons/filter3.png	2009-08-01 11:11:58 UTC (rev 5191)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_icons/filter3.png	2009-08-01 15:51:26 UTC (rev 5192)
@@ -0,0 +1,6 @@
+?PNG
+
+
+?T*4\??K???w?;??v?*\??2?B??t?]i4+u?/~&????d??z?^?DD\??r?,?Tj)????k:(???~?d2?D"?`<?8????s?^?m?
+?[LdY?m??????-?ZM????e???o!??
+???n8??n??t(?JN:??????vlY??r9?m[???D"?^,;>;??6?O??:?%???4?????V?;p<#???'`???????u?p???*<z?
\ No newline at end of file

Added: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_icons/filter4.png
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_icons/filter4.png	2009-08-01 11:11:58 UTC (rev 5191)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_icons/filter4.png	2009-08-01 15:51:26 UTC (rev 5192)
@@ -0,0 +1,12 @@
+?PNG
+
+
+*????P????nQ??~?
+p?uO??? ????????<??6??<?????2????e\F?:?@????v+???U???H??(c
+d??[-?W?b?AA???????9/?+~???Z~?????>?????KN.Ew[$?H?r??Dkk?kk{??("?c??O??G/?^????f???3?N?#?????S???Z?_9??{?$
+???Q?o?d?c?bW)l?B???~??8?????W??'~?x?8??d!b*^???a6???;??B??+'/??
+ B?5]?Y?,????Qrk?z!??,DD(??(z?????? r??im???????d?S?????@?J1??m??????????Fw???A,K+?????/S(
+?q?0
+l9?z?Fo????c????g8????K.?@???-~??_?X??:0??<???)<???]???m???!?R??*0T????o?||??w???|??C???0??4?k??&9?~?c?E,'"N??????Io??tw???????m`???Z=p??e?D??????L???C?2v?????Ln?U?RX?E????????6+fu?vm?q?'?R|??:c?w?'???z?v???X[?E?????@kM?k?[A;????}????P??j&???*?'UJ?I3:~???;d??Uas-?R?|?lQJ?K?????]?ud??^??a7?z????f?????I???1?q??8?-?6?3???}??r????%????f>?y???? t???Z???Ul??8
+?,/]?????`??????6?k?j??I~????$:??S??t??y{ik?????a?o???[?J?O?[???|????u`
+8?
\ No newline at end of file

Added: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_icons/filter5.png
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_icons/filter5.png	2009-08-01 11:11:58 UTC (rev 5191)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_icons/filter5.png	2009-08-01 15:51:26 UTC (rev 5192)
@@ -0,0 +1,6 @@
+?PNG
+
+
+fc?l?izM?z/??&^
+??R*"?J???????s?M????}???}?y?s?FLL???3_?????z??6?m	
+????;l6?'?gff???
\ No newline at end of file

Added: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_icons/filter6.png
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_icons/filter6.png	2009-08-01 11:11:58 UTC (rev 5191)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_icons/filter6.png	2009-08-01 15:51:26 UTC (rev 5192)
@@ -0,0 +1,9 @@
+?PNG
+
+
+<u*?????!m%???@l%????K?,?%??-??L???5??}vFg?q???c??f~????????(@
+a?O)??
+ ??mc?H?????`???g??V??
+zvW?'?????x
+???
+9{?>?U?????E????d
\ No newline at end of file

Added: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_icons/filter7.png
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_icons/filter7.png	2009-08-01 11:11:58 UTC (rev 5191)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_icons/filter7.png	2009-08-01 15:51:26 UTC (rev 5192)
@@ -0,0 +1,4 @@
+?PNG
+
+
+o?P
\ No newline at end of file

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_icons/xpm/Makefile
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_icons/xpm/Makefile	2009-08-01 11:11:58 UTC (rev 5191)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_icons/xpm/Makefile	2009-08-01 15:51:26 UTC (rev 5192)
@@ -8,6 +8,13 @@
 stock_filters_aging.inc \
 systray.inc \
 systray2.inc \
+filter1.inc \
+filter2.inc \
+filter3.inc \
+filter4.inc \
+filter5.inc \
+filter6.inc \
+filter7.inc \
 film1.inc \
 film3.inc \
 film5.inc \

Added: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_icons/xpm/filter1.inc
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_icons/xpm/filter1.inc	2009-08-01 11:11:58 UTC (rev 5191)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_icons/xpm/filter1.inc	2009-08-01 15:51:26 UTC (rev 5192)
@@ -0,0 +1,96 @@
+/* GdkPixbuf RGBA C-Source image dump */
+
+#ifdef __SUNPRO_C
+#pragma align 4 (filter1)
+#endif
+#ifdef __GNUC__
+static const guint8 filter1[] __attribute__ ((__aligned__ (4))) = 
+#else
+static const guint8 filter1[] = 
+#endif
+{ ""
+  /* Pixbuf magic (0x47646b50) */
+  "GdkP"
+  /* length: header (24) + pixel_data (2304) */
+  "\0\0\11\30"
+  /* pixdata_type (0x1010002) */
+  "\1\1\0\2"
+  /* rowstride (96) */
+  "\0\0\0`"
+  /* width (24) */
+  "\0\0\0\30"
+  /* height (24) */
+  "\0\0\0\30"
+  /* pixel_data: */
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\1\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\1\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\1"
+  "\0\0\0\377\0\0\0\12\0\0\0\5\0\0\0\1\0\0\0\0\0\0\0\1\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\1\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\1\0\0\0\377\0\0\0\12\0\0\0\5\0\0\0\0\0\0\0\2\0\0\0\377"
+  "\0\0\0\34\0\0\0\17\0\0\0\2\0\0\0\0\0\0\0\1\0\0\0\1\0\0\0\1\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\1\0\0\0\1\0\0\0\1\0\0\0"
+  "\0\0\0\0\2\0\0\0\377\0\0\0\34\0\0\0\17\0\0\0\0\0\0\0\3\0\0\0\377\0\0"
+  "\0%\0\0\0\24\0\0\0\24\0\0\0\210\0\0\0\377\0\0\0\16\0\0\0\6\0\0\0\1\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\1\0\0\0\377\0\0\0\214\0\0\0\33\0"
+  "\0\0\6\0\0\0\5\0\0\0\377\0\0\0%\0\0\0\24\0\0\0\0\0\0\0\3\0\0\0\377\0"
+  "\0\0/\0\0\0\177\0\0\0\371\0\0\0\377\0\0\0\377\0\0\0(\0\0\0\23\0\0\0\5"
+  "\0\0\0\3\0\0\0\3\0\0\0\3\0\0\0\3\0\0\0\5\0\0\0\377\0\0\0\377\0\0\0\372"
+  "\0\0\0\200\0\0\0\31\0\0\0\377\0\0\0'\0\0\0\25\0\0\0\0\0\0\0\3\0\0\0\377"
+  "\0\0\0\372\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377"
+  "\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377"
+  "\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\372\0\0\0\377\0\0\0-\0\0\0\25\0"
+  "\0\0\0\0\0\0\3\0\0\0\377\0\0\0R\0\0\0\240\0\0\0\370\0\0\0\377\0\0\0\377"
+  "\0\0\0G\0\0\0""3\0\0\0(\0\0\0&\0\0\0&\0\0\0&\0\0\0&\0\0\0(\0\0\0\377"
+  "\0\0\0\377\0\0\0\371\0\0\0\250\0\0\0[\0\0\0\377\0\0\0""2\0\0\0\26\0\0"
+  "\0\0\0\0\0\3\0\0\0\377\0\0\0.\0\0\0,\0\0\0B\0\0\0\256\0\0\0\377\0\0\0"
+  ">\0\0\0'\0\0\0\27\0\0\0\25\0\0\0\25\0\0\0\25\0\0\0\27\0\0\0\27\0\0\0"
+  "\377\0\0\0\257\0\0\0W\0\0\0;\0\0\0.\0\0\0\377\0\0\0.\0\0\0\26\0\0\0\0"
+  "\0\0\0\4\0\0\0\377\0\0\0(\0\0\0\33\0\0\0\23\0\0\0\35\0\0\0*\0\0\0(\0"
+  "\0\0\23\0\0\0\5\0\0\0\3\0\0\0\3\0\0\0\3\0\0\0\3\0\0\0\5\0\0\0\23\0\0"
+  "\0(\0\0\0*\0\0\0\35\0\0\0\23\0\0\0\377\0\0\0)\0\0\0\25\0\0\0\0\0\0\0"
+  "\3\0\0\0\377\0\0\0&\0\0\0\25\0\0\0\6\0\0\0\7\0\0\0\15\0\0\0\16\0\0\0"
+  "\6\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\1\0\0\0\6\0\0\0\16\0"
+  "\0\0\15\0\0\0\7\0\0\0\6\0\0\0\377\0\0\0&\0\0\0\25\0\0\0\0\0\0\0\3\0\0"
+  "\0\377\0\0\0%\0\0\0\24\0\0\0\3\0\0\0\1\0\0\0\1\0\0\0\2\0\0\0\1\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\1\0\0\0\2\0\0\0\1\0"
+  "\0\0\0\0\0\0\3\0\0\0\377\0\0\0%\0\0\0\24\0\0\0\0\0\0\0\2\0\0\0\17\0\0"
+  "\0\34\0\0\0\17\0\0\0\2\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\2\0\0\0\17\0\0\0\34\0\0\0\17\0\0\0\0\0\0\0\1\0\0\0\5\0\0\0\12\0"
+  "\0\0\5\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\1\0"
+  "\0\0\5\0\0\0\12\0\0\0\5\0\0\0\0\0\0\0\0\0\0\0\1\0\0\0\1\0\0\0\1\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\1\0\0\0"
+  "\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"};
+
+

Added: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_icons/xpm/filter2.inc
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_icons/xpm/filter2.inc	2009-08-01 11:11:58 UTC (rev 5191)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_icons/xpm/filter2.inc	2009-08-01 15:51:26 UTC (rev 5192)
@@ -0,0 +1,102 @@
+/* GdkPixbuf RGBA C-Source image dump */
+
+#ifdef __SUNPRO_C
+#pragma align 4 (filter2)
+#endif
+#ifdef __GNUC__
+static const guint8 filter2[] __attribute__ ((__aligned__ (4))) = 
+#else
+static const guint8 filter2[] = 
+#endif
+{ ""
+  /* Pixbuf magic (0x47646b50) */
+  "GdkP"
+  /* length: header (24) + pixel_data (2304) */
+  "\0\0\11\30"
+  /* pixdata_type (0x1010002) */
+  "\1\1\0\2"
+  /* rowstride (96) */
+  "\0\0\0`"
+  /* width (24) */
+  "\0\0\0\30"
+  /* height (24) */
+  "\0\0\0\30"
+  /* pixel_data: */
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\377\0"
+  "\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377"
+  "\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377"
+  "\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377"
+  "\0\0\0\377\0\0\0\377\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377"
+  "\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377"
+  "\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377"
+  "\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377"
+  "\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377"
+  "\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377"
+  "\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\377\0\0\0\377"
+  "\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377"
+  "\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377"
+  "\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377"
+  "\0\0\0\377\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377"
+  "\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377"
+  "\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377"
+  "\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377"
+  "\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377"
+  "\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377"
+  "\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\377\0\0\0\377\0\0\0\377"
+  "\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377"
+  "\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377"
+  "\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\377\0"
+  "\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377"
+  "\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377"
+  "\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377"
+  "\0\0\0\377\0\0\0\377\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377"
+  "\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377"
+  "\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377"
+  "\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377"
+  "\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377"
+  "\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377"
+  "\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\377\0\0\0\377"
+  "\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377"
+  "\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377"
+  "\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377"
+  "\0\0\0\377\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377"
+  "\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377"
+  "\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377"
+  "\0\0\0\377\0\0\0\377\0\0\0\377"};
+
+

Added: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_icons/xpm/filter3.inc
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_icons/xpm/filter3.inc	2009-08-01 11:11:58 UTC (rev 5191)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_icons/xpm/filter3.inc	2009-08-01 15:51:26 UTC (rev 5192)
@@ -0,0 +1,99 @@
+/* GdkPixbuf RGBA C-Source image dump */
+
+#ifdef __SUNPRO_C
+#pragma align 4 (filter3)
+#endif
+#ifdef __GNUC__
+static const guint8 filter3[] __attribute__ ((__aligned__ (4))) = 
+#else
+static const guint8 filter3[] = 
+#endif
+{ ""
+  /* Pixbuf magic (0x47646b50) */
+  "GdkP"
+  /* length: header (24) + pixel_data (2304) */
+  "\0\0\11\30"
+  /* pixdata_type (0x1010002) */
+  "\1\1\0\2"
+  /* rowstride (96) */
+  "\0\0\0`"
+  /* width (24) */
+  "\0\0\0\30"
+  /* height (24) */
+  "\0\0\0\30"
+  /* pixel_data: */
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0*\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0*\0\0\0\377\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "*\0\0\0\377\261\261\261\377\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0*\0\0\0\377\261"
+  "\261\261\377\0\0\0\377\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0*\0\0\0\377\261\261\261\377"
+  "\0\0\0\377\0\0\0\377\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0*\0\0\0\377\261\261\261\377\0\0\0\377"
+  "\0\0\0\377\0\0\0*\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0*\0\0\0\377\261\261\261\377\0\0\0\377\0\0\0\377"
+  "\0\0\0*\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0*\0\0\0\377\261\261\261\377\0\0\0\377\0\0\0\377\0\0\0*\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0*\0\0\0\377\261\261\261\377\0\0\0\377\0\0\0\377\0\0\0*\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0*\0\0"
+  "\0\377\261\261\261\377\0\0\0\377\0\0\0\377\0\0\0*\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0*\0\0\0\377\261"
+  "\261\261\377\0\0\0\377\0\0\0\377\0\0\0*\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0O\0\0\0\377\261\261\261\377"
+  "\0\0\0\377\0\0\0\377\0\0\0*\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\377\0\0\0""6\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0O\216\216\216\343\333\333\333\377\301\301\301"
+  "\377\0\0\0\377\0\0\0\377\0\0\0*\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0""6\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\211\211\211Avvv\277\277\277\277\357\377\377\377"
+  "\377\345\345\345\377\252\252\252\377QQQ\377\0\0\0*\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0a\0\0\0\377\0\0\0"
+  "\377\0\0\0\377\0\0\0\377\0\0\0^\0\0\0\0\221\221\221Fnnn\324\326\326\326"
+  "\377\377\377\377\377\377\377\377\377\334\334\334\377\215\215\215\364"
+  "@@@\207\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0""6\0\0\0\377\0\0\0\354\0\0\0\377\0\0"
+  "\0\377KKK\350\306\306\306\377\377\377\377\377\377\377\377\377\326\326"
+  "\326\377\273\273\273\377;;;\304\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0^\0\0\0\376\0\0\0\375<<<\377\345\345\345\377\377\377\377"
+  "\377\326\326\326\377\256\256\256\377```\342\222\222\222\\\0\0\0\5\0\0"
+  "\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0XKKK\377\207\207"
+  "\207\377\326\326\326\377\267\267\267\377222\346999x\0\0\0$\0\0\0\26\0"
+  "\0\0\11\0\0\0\2\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\24\0\0\0jGG"
+  "G\377KKK\377666\363\0\0\0\226\0\0\0L\0\0\0@\0\0\0""6\0\0\0$\0\0\0\23"
+  "\0\0\0\15\0\0\0\13\0\0\0\10\0\0\0\3\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\5\0\0\0\16\0\0\0\32\0\0"
+  "\0-\0\0\0E\0\0\0V\0\0\0j\0\0\0e\0\0\0K\0\0\0<\0\0\0,\0\0\0!\0\0\0\35"
+  "\0\0\0\30\0\0\0\16\0\0\0\10\0\0\0\5\0\0\0\4\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\1\0\0\0\6\0\0\0\24\0\0\0+\0\0\0"
+  "=\0\0\0;\0\0\0""4\0\0\0<\0\0\0""8\0\0\0*\0\0\0%\0\0\0#\0\0\0\35\0\0\0"
+  "\26\0\0\0\17\0\0\0\11\0\0\0\7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\1\0\0\0\5\0\0\0\16\0\0\0\26\0\0\0\26\0"
+  "\0\0\22\0\0\0\23\0\0\0\26\0\0\0\36\0\0\0\40\0\0\0\27\0\0\0\24\0\0\0\21"
+  "\0\0\0\16\0\0\0\11\0\0\0\7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\2\0\0\0\4\0\0\0\5\0\0\0"
+  "\6\0\0\0\11\0\0\0\15\0\0\0\21\0\0\0\23\0\0\0\26\0\0\0\26\0\0\0\20\0\0"
+  "\0\17\0\0\0\14\0\0\0\11"};
+
+

Added: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_icons/xpm/filter4.inc
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_icons/xpm/filter4.inc	2009-08-01 11:11:58 UTC (rev 5191)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_icons/xpm/filter4.inc	2009-08-01 15:51:26 UTC (rev 5192)
@@ -0,0 +1,112 @@
+/* GdkPixbuf RGBA C-Source image dump */
+
+#ifdef __SUNPRO_C
+#pragma align 4 (filter4)
+#endif
+#ifdef __GNUC__
+static const guint8 filter4[] __attribute__ ((__aligned__ (4))) = 
+#else
+static const guint8 filter4[] = 
+#endif
+{ ""
+  /* Pixbuf magic (0x47646b50) */
+  "GdkP"
+  /* length: header (24) + pixel_data (2304) */
+  "\0\0\11\30"
+  /* pixdata_type (0x1010002) */
+  "\1\1\0\2"
+  /* rowstride (96) */
+  "\0\0\0`"
+  /* width (24) */
+  "\0\0\0\30"
+  /* height (24) */
+  "\0\0\0\30"
+  /* pixel_data: */
+  "\0\0\0\0\0\0\0\0\0\0\0\1\0\0\0\3\0\0\0\10\0\0\0\16\0\0\0\23\0\0\0\25"
+  "\0\0\0\23\0\0\0\16\0\0\0\10\0\0\0\3\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\1\0\0\0\6\0\0\0\21e\2\2H\226\6\6\261\246\14\14\354\251\25\25"
+  "\377\240\33\33\354\215\34\34\261W\26\26H\0\0\0\21\0\0\0\6\0\0\0\1\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\1\0\0\0\6\0\0\0\26u\3\3z\253\11\11\377\336\222\222\377"
+  "\356\306\306\377\362\322\322\377\355\307\307\377\327\226\226\377\233"
+  "\35\35\377Q\20\20z\0\0\0\26\0\0\0\6\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\3\0\0\0\22O\4\4"
+  "W\245\14\14\377\336\225\225\377\356\276\276\377\356\276\276\377\356\276"
+  "\276\377\356\276\276\377\353\274\274\377\325\224\224\377\205\30\30\377"
+  "\"\3\3W\0\0\0\22\0\0\0\4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\10\0\0\0$\201\7\7\277\253\30\30\377"
+  "\344\243\243\377\350\246\246\377\350\245\245\377\351\245\245\377\350"
+  "\245\245\377\347\243\243\377\337\237\237\377\216\30\30\377L\11\11\300"
+  "\0\0\0$\0\0\0\11\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\16\0\0\0""8\217\6\6\362\257\32\32\377\326"
+  "jj\377\340\206\206\377\341\205\205\377\342\203\203\377\341\205\205\377"
+  "\340\204\204\377\321cc\377\224\27\27\377`\14\14\362\0\0\0>\0\0\0\34\0"
+  "\0\0\25\0\0\0\25\0\0\0\23\0\0\0\16\0\0\0\10\0\0\0\3\0\0\0\1\0\0\0\0\0"
+  "\0\0\0\0\0\0\23\0\0\0F\217\3\3\377\257\30\30\377\304++\377\321JJ\377"
+  "\326YY\377\330^^\377\326ZZ\377\320GG\377\272\34\34\377\220\23\23\377"
+  "c\14\14\377+:\1{n\220\5\267\177\245\14\354\204\250\25\377~\237\32\354"
+  "p\214\33\261FV\25H\0\0\0\21\0\0\0\6\0\0\0\1\0\0\0\0\0\0\0\25\0\0\0L{"
+  "\2\2\365\246\23\23\377\277((\377\310..\377\312..\377\313..\377\312.."
+  "\377\305%%\377\256\25\25\377\204\15\15\377\\=\6\372\202\252\11\377\313"
+  "\335\222\377\343\355\306\377\351\361\322\377\343\354\307\377\306\326"
+  "\225\377{\232\35\377 at P\20z\0\0\0\26\0\0\0\6\0\0\0\1\0\0\0\23\0\0\0FQ"
+  "\0\0\326\224\13\13\377\263\40\40\377\303**\377\310--\377\310--\377\306"
+  "))\377\271\34\34\377\231\21\21\377j%\14\377~\243\14\377\313\335\224\377"
+  "\341\355\276\377\341\355\276\377\341\355\276\377\341\355\276\377\336"
+  "\352\273\377\304\324\223\377i\204\27\377\31!\2W\0\0\0\22\0\0\0\4\0\0"
+  "\0\16\0\0\0""8\24\0\0\224}\3\3\377\226\21\21\377\245\33\33\377\251\40"
+  "\40\377\251\37\37\377\244\31\31\377\225\23\23\377v\22\22\377db\10\377"
+  "\204\251\26\377\323\343\242\377\327\347\246\377\326\347\244\377\327\350"
+  "\245\377\326\347\244\377\326\346\243\377\316\336\237\377p\215\30\377"
+  ":K\10\300\0\0\0$\0\0\0\11\0\0\0\10\0\0\0%\0\0\0_$\0\0\304d\17\27\377"
+  "L2O\377>Hr\377>S\177\377ENr\377N9P\377J\26\33\377a}\4\374\205\251\30"
+  "\377\272\324i\377\311\337\206\377\312\340\205\377\311\341\202\377\312"
+  "\340\205\377\311\337\204\377\265\320c\377u\224\27\377La\14\362\0\0\0"
+  "8\0\0\0\17\0\0\0\4\0\0\0\30\0\0\0F\27#:\2616M}\377\247\262\310\377\321"
+  "\327\342\377\333\337\350\377\321\327\342\377\247\261\304\377 at Rw\377H"
+  "^\37\377|\236\25\377\231\276)\377\255\317H\377\266\325X\377\271\327^"
+  "\377\267\325Z\377\255\317F\377\223\272\35\377t\223\24\377Sj\15\377\0"
+  "\0\0G\0\0\0\24\0\0\0\4\0\0\0\30\24\36""1e6Ly\377\251\263\310\377\313"
+  "\322\340\377\313\322\340\377\313\322\340\377\313\322\340\377\310\317"
+  "\335\377\245\257\302\3776Ee\377Xq\24\377\215\257%\377\236\303-\377\243"
+  "\311.\377\243\311.\377\243\311.\377\236\305&\377\213\262\25\377p\220"
+  "\17\377K`\11\365\0\0\0L\0\0\0\26\0\0\0\10\0\0\0%(9]\301 at U\201\377\264"
+  "\276\321\377\270\302\325\377\267\300\324\377\270\301\325\377\267\300"
+  "\324\377\266\277\323\377\261\272\314\3778Jm\3770\77,\377y\230\33\377"
+  "\226\272(\377\237\306+\377\240\307,\377\236\304)\377\223\272\35\377\200"
+  "\244\23\377f\202\21\3772@\5\326\0\0\0G\0\0\0\24\0\0\0\16\0\0\0""8,\77"
+  "g\362CX\204\377\210\227\267\377\237\254\306\377\237\254\306\377\235\252"
+  "\306\377\237\254\306\377\236\253\305\377\201\221\262\377:Lq\377'3E\377"
+  "]w\16\377\201\243\33\377\220\264\"\377\222\267\"\377\214\261\34\377\200"
+  "\243\26\377q\216\27\377Zq\22\377\15\20\1\225\0\0\0""8\0\0\0\17\0\0\0"
+  "\23\0\0\0F*>g\377AW\204\377Uk\230\377o\202\252\377{\215\262\377\200\221"
+  "\265\377|\216\263\377l\200\251\377I`\216\3778Jp\377'4P\377E[\2\377h\205"
+  "\14\377u\225\25\377x\230\27\377p\217\24\377f\202\21\377Yq\20\377\31\40"
+  "\3\300\0\0\0\\\0\0\0$\0\0\0\11\0\0\0\25\0\0\0L#4X\365;Q|\377Rg\223\377"
+  "Yo\234\377Yp\236\377Yp\236\377Yp\236\377Rj\231\377AX\206\3773Fl\377\40"
+  "-F\371\10\13\0\3072B\1\352Rj\6\373Zt\11\377Ne\10\373.;\4\350\12\16\0"
+  "\257\0\0\0k\0\0\0""5\0\0\0\22\0\0\0\4\0\0\0\23\0\0\0F\26!9\3260Dm\377"
+  "H^\211\377Tj\227\377Xn\233\377Xn\233\377Tk\231\377I`\216\377;Q|\3771"
+  "Ab\377\24\34.\337\0\0\0\211\0\0\0\211\0\0\0\227\0\0\0\236\0\0\0\226\0"
+  "\0\0\177\0\0\0\\\0\0\0""5\0\0\0\26\0\0\0\6\0\0\0\1\0\0\0\16\0\0\0""8"
+  "\5\10\16\224&7[\3777Kt\377F[\206\377La\215\377La\215\377F[\207\377=R"
+  "|\3778Jm\377-:V\377\4\6\13\234\0\0\0T\0\0\0D\0\0\0G\0\0\0L\0\0\0F\0\0"
+  "\0""8\0\0\0$\0\0\0\22\0\0\0\6\0\0\0\1\0\0\0\0\0\0\0\10\0\0\0$\0\0\0["
+  "\13\20\34\300&8]\3772Fm\377:Ms\377;Nt\3776Hm\3771Ab\377+9V\377\13\17"
+  "\30\300\0\0\0^\0\0\0+\0\0\0\27\0\0\0\24\0\0\0\25\0\0\0\23\0\0\0\16\0"
+  "\0\0\10\0\0\0\3\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\3\0\0\0\22\0\0\0""5\0\0"
+  "\0j\5\7\14\257\26\40""5\350#2P\373'6V\377\"/K\373\23\33,\350\3\5\12\257"
+  "\0\0\0k\0\0\0""5\0\0\0\22\0\0\0\5\0\0\0\2\0\0\0\3\0\0\0\2\0\0\0\1\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\1\0\0\0\6\0\0\0\26\0\0\0""5"
+  "\0\0\0\\\0\0\0\177\0\0\0\226\0\0\0\236\0\0\0\226\0\0\0\177\0\0\0\\\0"
+  "\0\0""5\0\0\0\26\0\0\0\6\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\1\0\0\0\6\0\0\0\22"
+  "\0\0\0$\0\0\0""8\0\0\0F\0\0\0L\0\0\0F\0\0\0""8\0\0\0$\0\0\0\22\0\0\0"
+  "\6\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\1\0\0\0\3\0\0\0\10\0\0\0"
+  "\16\0\0\0\23\0\0\0\25\0\0\0\23\0\0\0\16\0\0\0\10\0\0\0\3\0\0\0\1\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0"};
+
+

Added: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_icons/xpm/filter5.inc
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_icons/xpm/filter5.inc	2009-08-01 11:11:58 UTC (rev 5191)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_icons/xpm/filter5.inc	2009-08-01 15:51:26 UTC (rev 5192)
@@ -0,0 +1,108 @@
+/* GdkPixbuf RGBA C-Source image dump */
+
+#ifdef __SUNPRO_C
+#pragma align 4 (filter5)
+#endif
+#ifdef __GNUC__
+static const guint8 filter5[] __attribute__ ((__aligned__ (4))) = 
+#else
+static const guint8 filter5[] = 
+#endif
+{ ""
+  /* Pixbuf magic (0x47646b50) */
+  "GdkP"
+  /* length: header (24) + pixel_data (2304) */
+  "\0\0\11\30"
+  /* pixdata_type (0x1010002) */
+  "\1\1\0\2"
+  /* rowstride (96) */
+  "\0\0\0`"
+  /* width (24) */
+  "\0\0\0\30"
+  /* height (24) */
+  "\0\0\0\30"
+  /* pixel_data: */
+  "\0\0\0\0\0\0\0\0\33\33\33\5\232\232\232\26$$$\5\35\35\35\3\0\0\0\0\0"
+  "\0\0\0PPP\3\0\0\0\0\0\0\0\0NNN\4\22\22\22\1nnn\10\14\14\14\1\0\0\0\0"
+  "\0\0\0\0\0\0\0W!!!\377```\377www\377mmm\377```\377PPP\377\0\0\0\0((("
+  "\2\0\0\0\0\0\0\0\0|||\3]]]\2\0\0\0\0\230\230\230\2\0\0\0\0\0\0\0\0""2"
+  "22\1///\2\0\0\0\0\0\0\0\0@@@\3\0\0\0\0\2\2\2]\0\0\0\377```\377\225\225"
+  "\225\377sss\377YYY\377\77\77\77\377;;;\377\0\0\0\0\265\265\265\3\0\0"
+  "\0\0!!!\1\0\0\0\0\0\0\0\0\257\257\257\1SSS\1\0\0\0\0///\1\0\0\0\0\0\0"
+  "\0\0\12\12\12\1\326\326\326\15\356\356\356\22\0\0\0W\0\0\0\377```\377"
+  "\227\227\227\377yyy\377___\377FFF\377,,,\377EEE\377\22\22\22\1\253\253"
+  "\253\3\0\0\0\0\0\0\0\0ppp\1\0\0\0\0\0\0\0\0\245\245\245\2\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\220\220\220\10\0\0\0\0NNN\10\17\17\17f\0\0\0\377```\377"
+  "\233\233\233\377\177\177\177\377fff\377LLL\377333\377\31\31\31\377;;"
+  ";\377eee\6\0\0\0\0\0\0\0\0\227\227\227\4>>>\1""888\2BBB\2\0\0\0\0\0\0"
+  "\0\0\77\77\77\1\0\0\0\0\0\0\0\0...\6\0\0\0w\0\0\0\377```\377\237\237"
+  "\237\377\206\206\206\377lll\377SSS\377999\377\37\37\37\377\77\77\77\377"
+  "mmm\377\0\0\0\0\0\0\0\0\40\40\40\2\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0vvv\6+++\5\"\"\"I\0\0\0\377mmm\377\222\222\222"
+  "\377\203\203\203\377sss\377YYY\377\77\77\77\377&&&\377+++\377PPP\377"
+  "\0\0\0\377<<<\6\26\26\26\2\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\33\33\33\1\0\0\0\0\1\1\1\\\0\0\0\377uuu\377lll\377\216"
+  "\216\216\377\215\215\215\377___\377FFF\377,,,\377\23\23\23\377```\377"
+  "\0\0\0\377\0\0\0w\0\0\0\0\37\37\37\3\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0HHH\4\243\243\243\12\0\0\0\0\0\0\0\0\0\0\0\377sss\365\256\256"
+  "\256\371\266\266\266\372qqq\377zzz\377LLL\377333\377\31\31\31\377```"
+  "\377\0\0\0\377\0\0\0wHHH\3\31\31\31\4\\\\\\\12\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\270\270\270\21\230\230\230\15""111\5\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\377VVV\370\31\31\31\355\20\20\20\307\260\260\260\354\217\217\217\377"
+  "EEE\377\37\37\37\377```\377\0\0\0\377\0\0\0w\0\0\0\0~~~\2///\6\0\0\0"
+  "\0$$$\5\6\6\6\1\0\0\0\0bbb\14\0\0\0\0\254\254\254\33&&&\12\0\0\0\0\0"
+  "\0\0\0\0\0\0\377fff\374MMM\375)))\350\0\0\0\216\311\311\311\332BBB\377"
+  "___\377\0\0\0\377\0\0\0wGGG\1\0\0\0\0\0\0\0\0&&&\10\0\0\0\0\0\0\0\0""9"
+  "99\14\0\0\0\0ttt\24\0\0\0\0\0\0\0\0\36\36\36\12\302\302\302o\0\0\0\0"
+  "rrrW\0\0\0\377kkk\374YYY\371<<<\273\271\271\271\352ooo\377\0\0\0\377"
+  "\0\0\0w\0\0\0\0\0\0\0\0\204\204\204\2\0\0\0\0\0\0\0\0XXX\27\377\377\377"
+  "@\0\0\0\0\0\0\0\0\0\0\0\0uuu%EEE\27yyy1\0\0\0\0\311\311\311{\362\362"
+  "\362\260\231\231\231\333\22\22\22\377}}}\351iii\354yyy\272000\377\0\0"
+  "\0\221ooo\1ggg\1\0\0\0\0\0\0\0\0\224\224\224\2\256\256\256D\0\0\0\0t"
+  "tt&\0\0\0\0\251\251\251C\0\0\0\0\0\0\0\0\0\0\0\0\377\377\3770\261\261"
+  "\261W\377\377\377\352\336\336\336\263\275\275\275\274\233\233\233\340"
+  "\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0xGGG\1\0\0\0\0kkk\1ddd\2\0\0\0\0"
+  "\0\0\0\0\0\0\0\0///\33TTT2\306\306\306\177\0\0\0\0\0\0\0\0\226\226\226"
+  "l\377\377\3770\377\377\377W\377\377\377\246\377\377\377w\317\317\317"
+  "\255\270\270\270\255\377\377\377\311\247\247\247\312\1\1\1""6\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0bbb\1\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0OOOI\0\0\0\0\235\235\235y\347\347\347\205\377\377\377"
+  "\246\252\252\252\221\377\377\377W\377\377\377\246\221\221\221\227\377"
+  "\377\377\255\251\251\251\240\0\0\0\0\203\203\203\25AAA\1\0\0\0\0\0\0"
+  "\0\0www\1\201\201\201\1ddd\1\0\0\0\0\0\0\0\0vvvu\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\345\345\345\224\377\377\377\221\246\246\246\301iii_\377\377\377"
+  "W\377\377\377\246\245\245\245\223\257\257\257\232\377\377\377\246\241"
+  "\241\241\203\0\0\0\0\0\0\0\0\25\25\25\2\0\0\0\0\0\0\0\0""777\1\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\377\377\377W\377\377\377\203"
+  "\322\322\322\314\252\252\252\221\0\0\0""0\275\275\275\270\377\377\377"
+  "\221\377\377\377w\0\0\0""0\377\377\377\203\377\377\377\246\252\252\252"
+  "\221\207\207\207f\0\0\0\0TTT!\0\0\0\0\206\206\206\12\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\364\364\3642\377\377\377\203\377\377\377\203\377\377"
+  "\377\221\326\326\326\226aaan\0\0\0""0\0\0\0\0\333\333\333\305\377\377"
+  "\377\221\0\0\0\0\0\0\0""1\377\377\377\203\333\333\333\275\313\313\313"
+  "\272\215\215\215\277\0\0\0\0\0\0\0\0\270\270\270d\0\0\0\0\344\344\344"
+  "\40\0\0\0\0\0\0\0\0\0\0\0\0bbbbTTTT\242\242\242\215rrrW\0\0\0""6\5\5"
+  "\5A\235\235\235_\336\336\336\261\364\364\364\230\0\0\0\0\0\0\0""0!!!"
+  "!\377\377\377w\377\377\377\246\216\216\216\200\214\214\214\302\377\377"
+  "\377B\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\10\10\10\1\0\0\0\0""333\3\0\0\0"
+  "0\0\0\0""0\0\0\0""0\0\0\0\0\0\0\0\0\241\241\241X\377\377\377W\353\353"
+  "\353\267\0\0\0\0\0\0\0""0\272\272\272\272\241\241\241\241\352\352\352"
+  "_\350\350\350\275\254\254\254\341llll\377\377\3770\270\270\270c\15\15"
+  "\15\15ZZZK\0\0\0\0\12\12\12\2\0\0\0\0\0\0\0\0\14\14\14L\0\0\0\0\0\0\0"
+  "\0\377\377\3770\377\377\377W\377\377\377\246\377\377\377\255\250\250"
+  "\250\2502222\0\0\0""0\35\35\35\35\215\215\215\215\377\377\3770\377\377"
+  "\377\242gggb\0\0\0""04444\377\377\377f\377\377\3770;;;9EEE9\0\0\0\0\0"
+  "\0\0\0\2\2\2\1\24\24\24\24\255\255\255L\304\304\304\264\377\377\3770"
+  "\341\341\341\270\325\325\325\300\0\0\0\0\317\317\317\377\7\7\7D\217\217"
+  "\217\217\40\40\40\40>>>>\212\212\212\212\345\345\345\261\377\377\377"
+  "W\0\0\0""0\0\0\0\0\0\0\0\0\350\350\350q\377\377\377f\10\10\10\10\0\0"
+  "\0\0\0\0\0\0\14\14\14\7\233\233\233y\377\377\3770\377\377\377w\377\377"
+  "\377\246\346\346\346\345\356\356\356\356\0\0\0""0\0\0\0""0\0\0\0\0``"
+  "``\0\0\0\0\0\0\0\0\377\377\3770\261\261\261\247\0\0\0\0\0\0\0""0PPPP"
+  "@@@@\0\0\0\0\377\377\3770\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\243\243\243"
+  "\243\377\377\377W\377\377\377w\377\377\3770qqqq\0\0\0\0\0\0\0\0\205\205"
+  "\205\205\0\0\0\0\4\4\4\4\220\220\220\220\0\0\0\0\15\15\15\15\377\377"
+  "\3770\234\234\234b\0\0\0\0\0\0\0\0\0\0\0\0^^^^''''\0\0\0\0\27\27\27\27"
+  "%%%%\227\227\227\223"};
+
+

Added: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_icons/xpm/filter6.inc
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_icons/xpm/filter6.inc	2009-08-01 11:11:58 UTC (rev 5191)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_icons/xpm/filter6.inc	2009-08-01 15:51:26 UTC (rev 5192)
@@ -0,0 +1,112 @@
+/* GdkPixbuf RGBA C-Source image dump */
+
+#ifdef __SUNPRO_C
+#pragma align 4 (filter6)
+#endif
+#ifdef __GNUC__
+static const guint8 filter6[] __attribute__ ((__aligned__ (4))) = 
+#else
+static const guint8 filter6[] = 
+#endif
+{ ""
+  /* Pixbuf magic (0x47646b50) */
+  "GdkP"
+  /* length: header (24) + pixel_data (2304) */
+  "\0\0\11\30"
+  /* pixdata_type (0x1010002) */
+  "\1\1\0\2"
+  /* rowstride (96) */
+  "\0\0\0`"
+  /* width (24) */
+  "\0\0\0\30"
+  /* height (24) */
+  "\0\0\0\30"
+  /* pixel_data: */
+  "\0\0\0\377\0\0\0\377\377\377\377i\0\0\0i\377\377\377i\0\0\0i\377\377"
+  "\377i\0\0\0i\377\377\377i\0\0\0i\377\377\377i\0\0\0i\377\377\377i\0\0"
+  "\0i\377\377\377i\0\0\0i\377\377\377i\0\0\0i\377\377\377i\0\0\0i\377\377"
+  "\377i\0\0\0\377\0\0\0\377\0\0\0\0\0\0\0\377\0\0\0\377\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\377\0\0\0\377\0\0\0\0\377\377\377i\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0+\0"
+  "\0\0\235\0\0\0\346\0\0\0\377\0\0\0\346\0\0\0\240\0\0\0""1\0\0\0\2\0\0"
+  "\0\0\0\0\0\0\377\377\377i\0\0\0\0\0\0\0i\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0X\0\0\0\377"
+  "\310\271\206\377\360\337\242\377\362\341\244\377\360\337\242\377\275"
+  "\254o\377\0\0\0\377\0\0\0e\0\0\0\6\0\0\0\1\0\0\0i\0\0\0\0\377\377\377"
+  "i\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0+\0\0\0\377\350\330\237\377\362\341\244\377\357\331\212\377"
+  "\356\326\200\377\356\326\200\377\357\331\212\377\341\315\203\377\0\0"
+  "\0\377\0\0\0E\0\0\0\6\377\377\377i\0\0\0\0\0\0\0i\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\235\314\277"
+  "\220\377\361\337\234\377\356\326\200\377\356\326\200\377\356\326\200"
+  "\377\356\326\200\377\356\326\200\377\357\331\212\377\275\254o\377\0\0"
+  "\0\264\0\0\0\26\0\0\0k\0\0\0\0\377\377\377i\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\346\360\337\242"
+  "\377\356\326\200\377\356\326\200\377\356\326\200\377\356\326\200\377"
+  "\356\326\200\377\356\326\200\377\356\326\200\377\352\322}\377\0\0\0\354"
+  "\0\0\0+\363\363\363n\0\0\0\0\0\0\0i\0\0\0\0\0\0\0\377\0\0\0\377\0\0\0"
+  "\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0"
+  "\0\377\356\326\200\377\356\326\200\377\356\326\200\377\356\326\200\377"
+  "\356\326\200\377\356\326\200\377\356\326\200\377\356\326\200\377\0\0"
+  "\0\377\0\0\0""9\0\0\0o\0\0\0\0\377\377\377i\0\0\0\0\0\0\0\377\352\203"
+  "l\377\344_A\377\344_A\377\344_A\377\344_A\377\344_A\377\344_A\377\344"
+  "_A\377\0\0\0\377\356\326\200\377\356\326\200\377\356\326\200\377\356"
+  "\326\200\377\356\326\200\377\356\326\200\377\356\326\200\377\352\322"
+  "}\377\0\0\0\355\0\0\0>\357\357\357p\0\0\0\0\0\0\0i\0\0\0\0\0\0\0\377"
+  "\346lQ\377\337B\36\377\337B\36\377\337B\36\377\337B\36\377\337B\36\377"
+  "\337B\36\377\337B\36\377\0\0\0\377\356\326\200\377\356\326\200\377\0"
+  "\0\0\377\356\326\200\377\356\326\200\377\356\326\200\377\356\326\200"
+  "\377\270\245c\377\0\0\0\271\0\0\0""9\0\0\0o\0\0\0\0\377\377\377i\0\0"
+  "\0\0\0\0\0\377\346lQ\377\337B\36\377\337B\36\377\337B\36\377\337B\36"
+  "\377\337B\36\377\337B\36\377\337B\36\377\0\0\0\377\337\311x\377ymA\377"
+  "\212\241\272\377ymA\377\356\326\200\377\356\326\200\377\337\311x\377"
+  "\0\0\0\377\0\0\0g\0\0\0+\363\363\363n\0\0\0\0\0\0\0i\0\0\0\0\0\0\0\377"
+  "\346lQ\377\337B\36\377\337B\36\377\337B\36\377\337B\36\377\337B\36\377"
+  "\337B\36\377\337B\36\377\0\0\0\377\0\0\0\377\0\0\0\377\212\241\272\377"
+  "\0\0\0\377\352\322}\377\270\245c\377\0\0\0\377\0\0\0\210\0\0\0=\0\0\0"
+  "\26\0\0\0k\0\0\0\0\377\377\377i\0\0\0\0\0\0\0\377\346lQ\377\337B\36\377"
+  "\337B\36\377\337B\36\377\337B\36\377\337B\36\377\337B\36\377\337B\36"
+  "\377\0\0\0\377\0\0\0\263\212\241\272\377u\220\256\377u\220\256\377\0"
+  "\0\0\366\0\0\0\271\0\0\0g\0\0\0=\0\0\0\37\0\0\0\6\377\377\377i\0\0\0"
+  "\0\0\0\0i\0\0\0\0\0\0\0\377\346lQ\377\337B\36\377\337B\36\377\337B\36"
+  "\377\337B\36\377\337B\36\377\337B\36\377\337B\36\377\0\0\0\377\0\0\0"
+  "\377\212\241\272\377u\220\256\377u\220\256\377\0\0\0\377\0\0\0F\0\0\0"
+  "-\0\0\0\26\0\0\0\7\0\0\0\1\0\0\0i\0\0\0\0\377\377\377i\0\0\0\0\0\0\0"
+  "\377\346lQ\377\337B\36\377\337B\36\377\337B\36\377\337B\36\377\337B\36"
+  "\377\337B\36\377\337B\36\377\0\0\0\377\212\241\272\377u\220\256\377u"
+  "\220\256\377u\220\256\377u\220\256\377\0\0\0\237\0\0\0\26\0\0\0\4\0\0"
+  "\0\0\0\0\0\0\377\377\377i\0\0\0\0\0\0\0i\0\0\0\0\0\0\0\377\346lQ\377"
+  "\337B\36\377\337B\36\377\337B\36\377\337B\36\377\337B\36\377\337B\36"
+  "\377\337B\36\377\0\0\0\377\212\241\272\377u\220\256\377u\220\256\377"
+  "u\220\256\377u\220\256\377\0\0\0\377\0\0\0&\0\0\0\6\0\0\0\0\0\0\0\0\0"
+  "\0\0i\0\0\0\0\377\377\377i\0\0\0\0\0\0\0\377\344_A\377\337B\36\377\337"
+  "B\36\377\337B\36\377\337B\36\377\337B\36\377\337B\36\377q!\17\377\212"
+  "\241\272\377u\220\256\377u\220\256\377u\220\256\377u\220\256\377u\220"
+  "\256\377u\220\256\377\0\0\0\234\0\0\0\20\0\0\0\1\0\0\0\0\377\377\377"
+  "i\0\0\0\0\0\0\0i\0\0\0\0\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0"
+  "\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\212\241\272\377u\220\256"
+  "\377u\220\256\377u\220\256\377u\220\256\377u\220\256\377u\220\256\377"
+  "\0\0\0\377\0\0\0&\0\0\0\6\0\0\0\0\0\0\0i\0\0\0\0\377\377\377i\0\0\0\0"
+  "\0\0\0\12\0\0\0""5\0\0\0@\0\0\0@\0\0\0@\0\0\0@\0\0\0@\0\0\0\236\223\250"
+  "\277\377u\220\256\377u\220\256\377u\220\256\377u\220\256\377u\220\256"
+  "\377u\220\256\377u\220\256\377u\220\256\377\0\0\0\234\0\0\0\20\0\0\0"
+  "\1\377\377\377i\0\0\0\0\0\0\0i\0\0\0\0\0\0\0\2\0\0\0\12\0\0\0\14\0\0"
+  "\0\15\0\0\0\15\0\0\0\15\0\0\0\15\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0"
+  "\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0"
+  "\0\377\0\0\0&\0\0\0\6\0\0\0i\0\0\0\0\377\377\377i\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\11\0\0\0""1\0\0\0"
+  "\77\0\0\0@\0\0\0@\0\0\0@\0\0\0@\0\0\0@\0\0\0@\0\0\0@\0\0\0\77\0\0\0""1"
+  "\0\0\0\11\377\377\377i\0\0\0\0\0\0\0\377\0\0\0\377\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\2\0\0\0\12\0\0\0\14\0\0"
+  "\0\15\0\0\0\15\0\0\0\15\0\0\0\15\0\0\0\15\0\0\0\15\0\0\0\15\0\0\0\15"
+  "\0\0\0\13\0\0\0\377\0\0\0\377\0\0\0\0\0\0\0\377\0\0\0\377\377\377\377"
+  "i\0\0\0i\377\377\377i\0\0\0i\377\377\377i\0\0\0i\377\377\377i\0\0\0i"
+  "\377\377\377i\0\0\0i\377\377\377i\0\0\0i\377\377\377i\0\0\0i\377\377"
+  "\377i\0\0\0i\377\377\377i\0\0\0i\377\377\377i\0\0\0\377\0\0\0\377\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"};
+
+

Added: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_icons/xpm/filter7.inc
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_icons/xpm/filter7.inc	2009-08-01 11:11:58 UTC (rev 5191)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_icons/xpm/filter7.inc	2009-08-01 15:51:26 UTC (rev 5192)
@@ -0,0 +1,125 @@
+/* GdkPixbuf RGBA C-Source image dump */
+
+#ifdef __SUNPRO_C
+#pragma align 4 (filter7)
+#endif
+#ifdef __GNUC__
+static const guint8 filter7[] __attribute__ ((__aligned__ (4))) = 
+#else
+static const guint8 filter7[] = 
+#endif
+{ ""
+  /* Pixbuf magic (0x47646b50) */
+  "GdkP"
+  /* length: header (24) + pixel_data (2304) */
+  "\0\0\11\30"
+  /* pixdata_type (0x1010002) */
+  "\1\1\0\2"
+  /* rowstride (96) */
+  "\0\0\0`"
+  /* width (24) */
+  "\0\0\0\30"
+  /* height (24) */
+  "\0\0\0\30"
+  /* pixel_data: */
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\377\0\0\0\377\254\254\254\377\254\254\254\377\254"
+  "\254\254\377\254\254\254\377\254\254\254\377\254\254\254\377\254\254"
+  "\254\377\254\254\254\377\254\254\254\377\254\254\254\377\254\254\254"
+  "\377\254\254\254\377\254\254\254\377\254\254\254\377\0\0\0\377\0\0\0"
+  "\377\0\0\0\6\0\0\0\2\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\1\0\0\0\377\377\377"
+  "\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377"
+  "\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377"
+  "\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377"
+  "\377\377\377\377\377\377\377\340\340\340\377\0\0\0\377\0\0\0\21\0\0\0"
+  "\6\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\1\254\254\254\377\377\377\377\377\360"
+  "\360\360\377\360\360\360\377\360\360\360\377\360\360\360\377\360\360"
+  "\360\377\360\360\360\377\360\360\360\377\362\362\362\377\360\360\360"
+  "\377\360\360\360\377\362\362\362\377\362\362\362\377\363\363\363\377"
+  "\363\363\363\377\352\352\352\377\254\254\254\377\0\0\0\26\0\0\0\11\0"
+  "\0\0\1\0\0\0\0\0\0\0\0\0\0\0\1\254\254\254\377\377\377\377\377\360\360"
+  "\360\377\360\360\360\377\360\360\360\377\360\360\360\377\360\360\360"
+  "\377\361\361\361\377\361\361\361\377\362\362\362\377\361\361\361\377"
+  "\361\361\361\377\362\362\362\377\363\363\363\377\363\363\363\377\364"
+  "\364\364\377\352\352\352\377\254\254\254\377\0\0\0\27\0\0\0\11\0\0\0"
+  "\1\0\0\0\0\0\0\0\0\0\0\0\1\254\254\254\377\377\377\377\377\360\360\360"
+  "\377\360\360\360\377\360\360\360\377\360\360\360\377\361\361\361\377"
+  "\362\362\362\377\362\362\362\377\363\363\363\377\362\362\362\377\362"
+  "\362\362\377\363\363\363\377\363\363\363\377\364\364\364\377\365\365"
+  "\365\377\352\352\352\377\254\254\254\377\0\0\0\27\0\0\0\11\0\0\0\1\0"
+  "\0\0\0\0\0\0\0\0\0\0\1\254\254\254\377\377\377\377\377\360\360\360\377"
+  "\360\360\360\377\360\360\360\377\361\361\361\377\362\362\362\377\362"
+  "\362\362\377\362\362\362\377\363\363\363\377\362\362\362\377\362\362"
+  "\362\377\363\363\363\377\364\364\364\377\365\365\365\377\365\365\365"
+  "\377\353\353\353\377\254\254\254\377\0\0\0\27\0\0\0\11\0\0\0\1\0\0\0"
+  "\0\0\0\0\0\0\0\0\1\254\254\254\377\377\377\377\377\360\360\360\377\360"
+  "\360\360\377\361\361\361\377\362\362\362\377\362\362\362\377\363\363"
+  "\363\377\363\363\363\377\364\364\364\377\363\363\363\377\363\363\363"
+  "\377\364\364\364\377\365\365\365\377\365\365\365\377\366\366\366\377"
+  "\353\353\353\377\254\254\254\377\0\0\0\27\0\0\0\11\0\0\0\1\0\0\0\0\0"
+  "\0\0\0\0\0\0\1\254\254\254\377\377\377\377\377\360\360\360\377\361\361"
+  "\361\377\362\362\362\377\362\362\362\377\363\363\363\377\363\363\363"
+  "\377\363\363\363\377\365\365\365\377\363\363\363\377\363\363\363\377"
+  "\365\365\365\377\365\365\365\377\366\366\366\377\366\366\366\377\354"
+  "\354\354\377\254\254\254\377\0\0\0\27\0\0\0\11\0\0\0\1\0\0\0\0\0\0\0"
+  "\0\0\0\0\1\254\254\254\377\377\377\377\377\361\361\361\377\362\362\362"
+  "\377\362\362\362\377\363\363\363\377\363\363\363\377\364\364\364\377"
+  "\364\364\364\377\365\365\365\377\364\364\364\377\364\364\364\377\365"
+  "\365\365\377\366\366\366\377\366\366\366\377\367\367\367\377\354\354"
+  "\354\377\254\254\254\377\0\0\0\27\0\0\0\11\0\0\0\1\0\0\0\0\0\0\0\0\0"
+  "\0\0\1\254\254\254\377\377\377\377\377\362\362\362\377\362\362\362\377"
+  "\363\363\363\377\363\363\363\377\364\364\364\377\365\365\365\377\365"
+  "\365\365\377\366\366\366\377\365\365\365\377\365\365\365\377\366\366"
+  "\366\377\366\366\366\377\367\367\367\377\367\367\367\377\355\355\355"
+  "\377\254\254\254\377\0\0\0\27\0\0\0\11\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0"
+  "\1\254\254\254\377\377\377\377\377\362\362\362\377\363\363\363\377\363"
+  "\363\363\377\364\364\364\377\365\365\365\377\365\365\365\377\365\365"
+  "\365\377\366\366\366\377\365\365\365\377\365\365\365\377\366\366\366"
+  "\377\367\367\367\377\367\367\367\377\370\370\370\377\356\356\356\377"
+  "\254\254\254\377\0\0\0\27\0\0\0\11\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\1\254"
+  "\254\254\377\377\377\377\377\363\363\363\377\363\363\363\377\364\364"
+  "\364\377\365\365\365\377\365\365\365\377\366\366\366\377\366\366\366"
+  "\377\367\367\367\377\366\366\366\377\366\366\366\377\367\367\367\377"
+  "\367\367\367\377\370\370\370\377\371\371\371\377\356\356\356\377\254"
+  "\254\254\377\0\0\0\27\0\0\0\11\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\1\0\0\0"
+  "\377\363\363\363\377\351\351\351\377\352\352\352\377\352\352\352\377"
+  "\352\352\352\377\353\353\353\377\353\353\353\377\353\353\353\377\354"
+  "\354\354\377\353\353\353\377\353\353\353\377\354\354\354\377\355\355"
+  "\355\377\356\356\356\377\356\356\356\377\326\326\326\377\0\0\0\377\0"
+  "\0\0\27\0\0\0\11\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\1\0\0\0\377\0\0\0\377"
+  "\254\254\254\377\254\254\254\377\254\254\254\377\254\254\254\377\254"
+  "\254\254\377\254\254\254\377\254\254\254\377\254\254\254\377\254\254"
+  "\254\377\254\254\254\377\254\254\254\377\254\254\254\377\254\254\254"
+  "\377\254\254\254\377\0\0\0\377\0\0\0\377\0\0\0\26\0\0\0\11\0\0\0\1\0"
+  "\0\0\0\0\0\0\0\0\0\0\1\0\0\0\6\0\0\0\21\0\0\0\26\0\0\0\27\0\0\0\27\0"
+  "\0\0\27\0\0\0\27\0\0\0\27\0\0\0\27\0\0\0\27\0\0\0\27\0\0\0\27\0\0\0\27"
+  "\0\0\0\27\0\0\0\27\0\0\0\27\0\0\0\27\0\0\0\26\0\0\0\21\0\0\0\6\0\0\0"
+  "\1\0\0\0\0\0\0\0\0\0\0\0\1\0\0\0\3\0\0\0\7\0\0\0\10\0\0\0\11\0\0\0\11"
+  "\0\0\0\12\0\0\0\12\0\0\0\11\0\0\0\11\0\0\0\12\0\0\0\12\0\0\0\12\0\0\0"
+  "\11\0\0\0\11\0\0\0\11\0\0\0\12\0\0\0\12\0\0\0\11\0\0\0\7\0\0\0\2\0\0"
+  "\0\0\0\0\0\0\0\0\0\0""1Nl\377\0\0\0\5\0\0\0\3\0\0\0\2\0\0\0Z\0\0\0\377"
+  "\0\0\0\377\0\0\0^\0\0\0\5\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0^\0\0\0"
+  "\5\0\0\0\\\0\0\0\377\0\0\0\377\0\0\0^\0\0\0\5\0\0\0\2\0\0\0\0\0\0\0\0"
+  "\0\0\0\0\0\0\0\1""1Nl\377,Fa\377\0\0\0\12\0\0\0\4\0\0\0\377\0\0\0\12"
+  "\0\0\0\16\0\0\0\377\0\0\0\13\0\0\0\377\0\0\0\17\0\0\0\21\0\0\0\377\0"
+  "\0\0\13\0\0\0\377\0\0\0\13\0\0\0\16\0\0\0\377\0\0\0\12\0\0\0\4\0\0\0"
+  "\0\0\0\0\0\0\0\0\0\0\0\0\1""1Nl\3771Nl\377\33-\77\377\0\0\0\13\0\0\0"
+  "\377\0\0\0\377\0\0\0\377\0\0\0\377\0\0\0\21\0\0\0\377\0\0\0\377\0\0\0"
+  "\377\0\0\0\202\0\0\0\17\0\0\0\377\0\0\0\16\0\0\0\14\0\0\0\12\0\0\0\12"
+  "\0\0\0\5\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\1""1Nl\377\37""2F\377\0\0\0\30"
+  "\0\0\0\20\0\0\0\377\0\0\0\23\0\0\0\23\0\0\0\377\0\0\0\23\0\0\0\377\0"
+  "\0\0\24\0\0\0\24\0\0\0\377\0\0\0\20\0\0\0\377\0\0\0\17\0\0\0\11\0\0\0"
+  "\377\0\0\0\10\0\0\0\4\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\1#8N\377\0\0\0\23"
+  "\0\0\0\23\0\0\0\13\0\0\0\377\0\0\0\20\0\0\0\16\0\0\0\377\0\0\0\21\0\0"
+  "\0\377\0\0\0\377\0\0\0\377\0\0\0d\0\0\0\17\0\0\0a\0\0\0\377\0\0\0\377"
+  "\0\0\0`\0\0\0\12\0\0\0\5\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\1\0\0\0\6\0\0"
+  "\0\14\0\0\0\12\0\0\0\4\0\0\0\6\0\0\0\13\0\0\0\7\0\0\0\7\0\0\0\13\0\0"
+  "\0\14\0\0\0\17\0\0\0\21\0\0\0\17\0\0\0\13\0\0\0\10\0\0\0\13\0\0\0\15"
+  "\0\0\0\15\0\0\0\12\0\0\0\4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\2\0"
+  "\0\0\4\0\0\0\3\0\0\0\1\0\0\0\2\0\0\0\4\0\0\0\2\0\0\0\2\0\0\0\4\0\0\0"
+  "\4\0\0\0\6\0\0\0\7\0\0\0\6\0\0\0\4\0\0\0\2\0\0\0\4\0\0\0\6\0\0\0\6\0"
+  "\0\0\4\0\0\0\1\0\0\0\0\0\0\0\0"};
+
+

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_GTK/ADM_toolkit_gtk/ADM_icons.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_GTK/ADM_toolkit_gtk/ADM_icons.cpp	2009-08-01 11:11:58 UTC (rev 5191)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_GTK/ADM_toolkit_gtk/ADM_icons.cpp	2009-08-01 15:51:26 UTC (rev 5192)
@@ -33,6 +33,15 @@
 #include "xpm/film5.inc"
 #include "xpm/film7.inc"
 #include "xpm/film9.inc"
+
+#include "xpm/filter1.inc"
+#include "xpm/filter2.inc"
+#include "xpm/filter3.inc"
+#include "xpm/filter4.inc"
+#include "xpm/filter5.inc"
+#include "xpm/filter6.inc"
+#include "xpm/filter7.inc"
+
 #include "xpm/first_frame.inc"
 #include "xpm/gnome_calculator.inc"
 #include "xpm/gnome_calculator_small.inc"
@@ -91,15 +100,15 @@
         {A_ICON_PNG,"gnome-calculator_small.xpm",(void *) gnome_calculator_small},
         {A_ICON_PNG,"preview.png",(void *) preview},
         {A_ICON_PNG,"output.png",(void *) output},
-#if 0
-        {A_ICON_PNG,"1.png",(void *) x1},
-        {A_ICON_PNG,"2.png",(void *) x2},
-        {A_ICON_PNG,"3.png",(void *) x3},
-        {A_ICON_PNG,"4.png",(void *) x4},
-        {A_ICON_PNG,"5.png",(void *) x5},
-        {A_ICON_PNG,"6.png",(void *) x6},
-        {A_ICON_PNG,"7.png",(void *) x7},
-#endif
+
+        {A_ICON_PNG,"1.png",(void *) filter1},
+        {A_ICON_PNG,"2.png",(void *) filter2},
+        {A_ICON_PNG,"3.png",(void *) filter3},
+        {A_ICON_PNG,"4.png",(void *) filter4},
+        {A_ICON_PNG,"5.png",(void *) filter5},
+        {A_ICON_PNG,"6.png",(void *) filter6},
+        {A_ICON_PNG,"7.png",(void *) filter7},
+
         {A_ICON_PNG,"avidemux_icon.xpm",        (void *) avidemux_icon},
         {A_ICON_PNG,"avidemux_icon_small.png",  (void *) avidemux_icon_small},
         {A_ICON_PNG,"systray.png",              (void *) systray},



From mean at mail.berlios.de  Sat Aug  1 18:01:46 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sat, 1 Aug 2009 18:01:46 +0200
Subject: [Avidemux-svn-commit] r5193 -
	branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_commonUI
Message-ID: <200908011601.n71G1kAV010821@sheep.berlios.de>

Author: mean
Date: 2009-08-01 18:01:46 +0200 (Sat, 01 Aug 2009)
New Revision: 5193

Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_builtin.cpp
Log:
[UI] Remove all plugin-ified field from the build-in dialog

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_builtin.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_builtin.cpp	2009-08-01 15:51:26 UTC (rev 5192)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_builtin.cpp	2009-08-01 16:01:46 UTC (rev 5193)
@@ -41,8 +41,8 @@
 
 uint8_t DIA_builtin(void)
 {
-  uint32_t altivec=0,mad=0,a52dec=0,xvid4=0,X264=0,freetype=0,esd=0,arts=0,vorbis=0,win32=0;
-  uint32_t faac=0,faad=0,libdca=0,aften=0,libamrnb=0,lame=0,sdl=0,oss=0,xvideo=0,x86=0,x86_64=0,alsa=0;
+  uint32_t altivec=0,freetype=0,win32=0;
+  uint32_t sdl=0,xvideo=0,x86=0,x86_64=0;
   uint32_t adm_powerpc=0,adm_gettext=0,adm_fontconfig=0;
 #ifdef USE_FONTCONFIG
   adm_fontconfig=1;
@@ -50,62 +50,15 @@
 #ifdef ADM_CPU_ALTIVEC
         altivec=1;
 #endif
-#ifdef USE_MP3
-        mad=1;
-#endif
-#ifdef USE_AC3
-        a52dec=1;
-#endif
-#ifdef USE_XVID_4
-        xvid4=1;
-#endif
-#ifdef USE_X264
-        X264=1;
-#endif
 #ifdef USE_FREETYPE
         freetype=1;
 #endif
-#ifdef USE_ESD
-        esd=1;
-#endif
-#ifdef USE_ARTS
-        arts=1;
-#endif
-#ifdef USE_VORBIS
-        vorbis=1;
-#endif
 #ifdef __WIN32
         win32=1;
 #endif
-#ifdef USE_FAAC
-        faac=1;
-#endif
-#ifdef USE_FAAD
-        faad=1;
-#endif
-#ifdef USE_LIBDCA
-	if (dca->isAvailable())
-        libdca=1;
-#endif
-#ifdef USE_AFTEN
-        aften=1;
-#endif
-#if 0 //def USE_AMR_NB
-	if (amrnb->isAvailable())
-		libamrnb=1;
-#endif
-#ifdef HAVE_LIBMP3LAME
-	lame=1;
-#endif
 #ifdef USE_SDL
 	sdl=1;
 #endif
-#ifdef OSS_SUPPORT
-	oss=1;
-#endif
-#ifdef ALSA_SUPPORT
-	alsa=1;
-#endif
 
 #ifdef USE_XV
 	xvideo=1;
@@ -123,23 +76,13 @@
 	adm_gettext=1;
 #endif
     
-	diaElemFrame videoFrame(QT_TR_NOOP("Video Codecs"));
-	diaElemNotch tXvid4(xvid4, QT_TR_NOOP("Xvid"));
-	diaElemNotch tX264(X264, QT_TR_NOOP("x264"));
 
-	videoFrame.swallow(&tXvid4);
-	videoFrame.swallow(&tX264);
 
 
 
-
-	diaElemNotch tArts(arts, QT_TR_NOOP("aRts"));
-	diaElemNotch tEsd(esd, QT_TR_NOOP("ESD"));
         diaElemNotch tFontConfig(adm_fontconfig, QT_TR_NOOP("Fontconfig"));
 	diaElemNotch tFreetype(freetype, QT_TR_NOOP("FreeType 2"));
 	diaElemNotch tGettext(adm_gettext, QT_TR_NOOP("Gettext"));
-        diaElemNotch tAlsa(alsa, QT_TR_NOOP("ALSA"));
-	diaElemNotch tOss(oss, QT_TR_NOOP("OSS"));
 	diaElemNotch tSdl(sdl, QT_TR_NOOP("SDL"));
 	diaElemNotch tXvideo(xvideo, QT_TR_NOOP("XVideo"));
 
@@ -149,17 +92,16 @@
 	diaElemNotch tX86_64(x86_64, QT_TR_NOOP("x86-64"));
 
 
-	diaElem *codecElems[] = {&videoFrame};
-	diaElem *libsElems[] = {&tArts, &tEsd, &tFontConfig, &tFreetype, &tGettext, &tAlsa, &tOss, &tSdl, &tXvideo};
+
+	diaElem *libsElems[] = {&tFontConfig, &tFreetype, &tGettext, &tSdl, &tXvideo};
 	diaElem *CPUElems[] = {&tAltivec, &tPowerPc, &tX86, &tX86_64};
 
-	diaElemTabs tabCodec(QT_TR_NOOP("Codecs"), 1, codecElems);
-	diaElemTabs tabLibs(QT_TR_NOOP("Libraries"), 9, libsElems);
+	diaElemTabs tabLibs(QT_TR_NOOP("Libraries"), 5, libsElems);
 	diaElemTabs tabCPU(QT_TR_NOOP("CPU"), 4, CPUElems);
 
-	diaElemTabs *tabs[] = {&tabCodec, &tabLibs, &tabCPU};
+	diaElemTabs *tabs[] = { &tabLibs, &tabCPU};
 
-    diaFactoryRunTabs(QT_TR_NOOP("Built-in Support"), 3, tabs);
+    diaFactoryRunTabs(QT_TR_NOOP("Built-in Support"), 2, tabs);
 
     return 1;
 }



From mean at mail.berlios.de  Sat Aug  1 20:09:32 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sat, 1 Aug 2009 20:09:32 +0200
Subject: [Avidemux-svn-commit] r5194 - in branches/avidemux_2.6_branch_mean:
	avidemux/gtk avidemux/qt4 avidemux_core avidemux_plugins
Message-ID: <200908011809.n71I9WV4005827@sheep.berlios.de>

Author: mean
Date: 2009-08-01 20:09:31 +0200 (Sat, 01 Aug 2009)
New Revision: 5194

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/gtk/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/avidemux/gtk/gtkPackageDebian.cmake
   branches/avidemux_2.6_branch_mean/avidemux/qt4/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/avidemux/qt4/qt4PackageDebian.cmake
   branches/avidemux_2.6_branch_mean/avidemux_core/corePackageDebian.cmake
   branches/avidemux_2.6_branch_mean/avidemux_plugins/pluginsPackageDebian.cmake
Log:
[build] Rename avidemux2* to avidemux3* so that it can coexist with 2.5

Modified: branches/avidemux_2.6_branch_mean/avidemux/gtk/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/gtk/CMakeLists.txt	2009-08-01 16:01:46 UTC (rev 5193)
+++ branches/avidemux_2.6_branch_mean/avidemux/gtk/CMakeLists.txt	2009-08-01 18:09:31 UTC (rev 5194)
@@ -23,8 +23,8 @@
 ###########################################
 # Executable
 ###########################################
-ADD_EXECUTABLE(avidemux2_gtk ${ADM_EXE_SRCS})
-ADD_TARGET_CFLAGS(avidemux2_gtk "-I${CMAKE_BINARY_DIR}/config/gtk")
+ADD_EXECUTABLE(avidemux3_gtk ${ADM_EXE_SRCS})
+ADD_TARGET_CFLAGS(avidemux3_gtk "-I${CMAKE_BINARY_DIR}/config/gtk")
 ########################################
 # Add subdirectories 
 ########################################
@@ -40,60 +40,60 @@
 ###########################################
 
 IF (ADM_DEBUG AND FIND_LEAKS)
-	TARGET_LINK_LIBRARIES(avidemux2_gtk ADM_nvwa)
+	TARGET_LINK_LIBRARIES(avidemux3_gtk ADM_nvwa)
 ENDIF (ADM_DEBUG AND FIND_LEAKS)
 
 FOREACH (_libName ${commonLibs1})
-        TARGET_LINK_LIBRARIES(avidemux2_gtk ${_libName})
+        TARGET_LINK_LIBRARIES(avidemux3_gtk ${_libName})
 ENDFOREACH (_libName ${commonLibs})
 
-TARGET_LINK_LIBRARIES(avidemux2_gtk ADM_filtersGtk)
+TARGET_LINK_LIBRARIES(avidemux3_gtk ADM_filtersGtk)
 
 FOREACH (_libName ${commonLibs2})
-        TARGET_LINK_LIBRARIES(avidemux2_gtk ${_libName})
+        TARGET_LINK_LIBRARIES(avidemux3_gtk ${_libName})
 ENDFOREACH (_libName ${commonLibs})
 FOREACH (_libName ${coreLibs})
-        TARGET_LINK_LIBRARIES(avidemux2_gtk ${_libName})
+        TARGET_LINK_LIBRARIES(avidemux3_gtk ${_libName})
 ENDFOREACH (_libName ${commonLibs})
 
 #############################################
 # Add gtk specific libs
 #############################################
-TARGET_LINK_LIBRARIES(avidemux2_gtk ADM_UIGtk)
-TARGET_LINK_LIBRARIES(avidemux2_gtk ADM_dialogGtk)
-#TARGET_LINK_LIBRARIES(avidemux2_gtk ADM_filtersGtk)
-TARGET_LINK_LIBRARIES(avidemux2_gtk ADM_gui2Gtk)
-#TARGET_LINK_LIBRARIES(avidemux2_gtk ADM_ocrGtk)
-TARGET_LINK_LIBRARIES(avidemux2_gtk ADM_toolkitGtk)
-TARGET_LINK_LIBRARIES(avidemux2_gtk ADM_UI_GTK)
+TARGET_LINK_LIBRARIES(avidemux3_gtk ADM_UIGtk)
+TARGET_LINK_LIBRARIES(avidemux3_gtk ADM_dialogGtk)
+#TARGET_LINK_LIBRARIES(avidemux3_gtk ADM_filtersGtk)
+TARGET_LINK_LIBRARIES(avidemux3_gtk ADM_gui2Gtk)
+#TARGET_LINK_LIBRARIES(avidemux3_gtk ADM_ocrGtk)
+TARGET_LINK_LIBRARIES(avidemux3_gtk ADM_toolkitGtk)
+TARGET_LINK_LIBRARIES(avidemux3_gtk ADM_UI_GTK)
 ###########################################
 # External libs
 ###########################################
 # gettext
 IF (GETTEXT_FOUND)
-	TARGET_LINK_LIBRARIES(avidemux2_gtk ${GETTEXT_LIBRARY_DIR})
+	TARGET_LINK_LIBRARIES(avidemux3_gtk ${GETTEXT_LIBRARY_DIR})
 ENDIF (GETTEXT_FOUND)
 # PNG
 IF (USE_PNG)
-        TARGET_LINK_LIBRARIES(avidemux2_gtk ${PNG_LIBRARIES})
+        TARGET_LINK_LIBRARIES(avidemux3_gtk ${PNG_LIBRARIES})
 	
 ENDIF (USE_PNG)
 
 
 # XVideo
 IF (USE_XV)
-        TARGET_LINK_LIBRARIES(avidemux2_gtk ${XVIDEO_LIBRARY_DIR})
+        TARGET_LINK_LIBRARIES(avidemux3_gtk ${XVIDEO_LIBRARY_DIR})
 ENDIF (USE_XV)
 
 # SDL
 IF (USE_SDL)
-        TARGET_LINK_LIBRARIES(avidemux2_gtk ${SDL_LIBRARY})
+        TARGET_LINK_LIBRARIES(avidemux3_gtk ${SDL_LIBRARY})
 ENDIF (USE_SDL)
 
 ###########################################
 # UI Specific
 ###########################################
-ADD_TARGET_LDFLAGS(avidemux2_gtk ${GTK_LDFLAGS} ${GTHREAD_LDFLAGS})
+ADD_TARGET_LDFLAGS(avidemux3_gtk ${GTK_LDFLAGS} ${GTHREAD_LDFLAGS})
 
 
 ###########################################
@@ -103,21 +103,21 @@
 	target_link_libraries(ADM_osSupport)
 
 	IF (MINGW)
-		target_link_libraries(avidemux2_gtk -mno-cygwin)
+		target_link_libraries(avidemux3_gtk -mno-cygwin)
 	ENDIF (MINGW)
 
-	target_link_libraries(avidemux2_gtk winmm)
-        ADD_TARGET_LDFLAGS(avidemux2_gtk "-mwindows")
+	target_link_libraries(avidemux3_gtk winmm)
+        ADD_TARGET_LDFLAGS(avidemux3_gtk "-mwindows")
 
 ENDIF (WIN32)
 #
 # libxml2
 #
-TARGET_LINK_LIBRARIES(avidemux2_gtk ${LIBXML2_LIBRARIES})
+TARGET_LINK_LIBRARIES(avidemux3_gtk ${LIBXML2_LIBRARIES})
 ###########################################
 # Install
 ###########################################
-ADM_LINK_THREAD(avidemux2_gtk)
-ADM_INSTALL_BIN(avidemux2_gtk)
+ADM_LINK_THREAD(avidemux3_gtk)
+ADM_INSTALL_BIN(avidemux3_gtk)
 INSTALL(FILES ${CMAKE_BINARY_DIR}/config/gtk/config.h DESTINATION "${AVIDEMUX_INCLUDE_DIR}/avidemux/2.6/gtk") 
 include(./gtkPackageDebian.cmake)

Modified: branches/avidemux_2.6_branch_mean/avidemux/gtk/gtkPackageDebian.cmake
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/gtk/gtkPackageDebian.cmake	2009-08-01 16:01:46 UTC (rev 5193)
+++ branches/avidemux_2.6_branch_mean/avidemux/gtk/gtkPackageDebian.cmake	2009-08-01 18:09:31 UTC (rev 5194)
@@ -2,7 +2,7 @@
 # DEBIAN
 ##############################
 SET(CPACK_SET_DESTDIR "ON")
-SET(CPACK_DEBIAN_PACKAGE_NAME "avidemux2-gtk")
+SET(CPACK_DEBIAN_PACKAGE_NAME "avidemux3-gtk")
 SET (CPACK_GENERATOR "DEB")
 # ARCH
 IF (X86_64_SUPPORTED)
@@ -16,7 +16,7 @@
 
 # Build our deps list
 # Build deps SET(DEPS "debhelper (>> 4), libfreetype6-dev, libxml2-dev,  libxv-dev, dpatch , cmake, desktop-file-utils")
-SET(DEPS "libc6 (>=2.4),libglib2.0-0 (>=2.14.0),libstdc++6 (>=4.2.1),libx11-6,  libxml2 (>=2.6.27), libxv1, zlib1g (>=1:1.1.4), avidemux2-core (>=2.6.0)")
+SET(DEPS "libc6 (>=2.4),libglib2.0-0 (>=2.14.0),libstdc++6 (>=4.2.1),libx11-6,  libxml2 (>=2.6.27), libxv1, zlib1g (>=1:1.1.4), avidemux3-core (>=2.6.0)")
 # Add optional DEPS here
 SET(CPACK_DEBIAN_PACKAGE_DEPENDS "${DEPS}")
 #
@@ -28,7 +28,7 @@
 SET(CPACK_PACKAGE_VERSION_PATCH "0")
 SET(CPACK_PACKAGE_VERSION_PATCH "0-${ADM_SUBVERSION}")
 #
-SET(CPACK_PACKAGE_NAME "avidemux2-gtk")
+SET(CPACK_PACKAGE_NAME "avidemux3-gtk")
 #
 
 include(CPack)

Modified: branches/avidemux_2.6_branch_mean/avidemux/qt4/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/qt4/CMakeLists.txt	2009-08-01 16:01:46 UTC (rev 5193)
+++ branches/avidemux_2.6_branch_mean/avidemux/qt4/CMakeLists.txt	2009-08-01 18:09:31 UTC (rev 5194)
@@ -30,7 +30,7 @@
 ###########################################
 # Executable
 ###########################################
-ADD_EXECUTABLE(avidemux2_qt4 ${ADM_EXE_SRCS})
+ADD_EXECUTABLE(avidemux3_qt4 ${ADM_EXE_SRCS})
 ########################################
 # Add subdirectories 
 ########################################
@@ -47,34 +47,34 @@
 ###########################################
 
 IF (ADM_DEBUG AND FIND_LEAKS)
-	TARGET_LINK_LIBRARIES(avidemux2_qt4 ADM_nvwa)
+	TARGET_LINK_LIBRARIES(avidemux3_qt4 ADM_nvwa)
 ENDIF (ADM_DEBUG AND FIND_LEAKS)
 
 FOREACH (_libName ${commonLibs1})
-        TARGET_LINK_LIBRARIES(avidemux2_qt4 ${_libName})
+        TARGET_LINK_LIBRARIES(avidemux3_qt4 ${_libName})
 ENDFOREACH (_libName ${commonLibs})
 
 
 FOREACH (_libName ${commonLibs2})
-        TARGET_LINK_LIBRARIES(avidemux2_qt4 ${_libName})
+        TARGET_LINK_LIBRARIES(avidemux3_qt4 ${_libName})
 ENDFOREACH (_libName ${commonLibs})
-TARGET_LINK_LIBRARIES(avidemux2_qt4 ADM_filter6)
+TARGET_LINK_LIBRARIES(avidemux3_qt4 ADM_filter6)
 #############################################
 # Add qt specific libs
 #############################################
-TARGET_LINK_LIBRARIES(avidemux2_qt4 ADM_UIQT4)
-TARGET_LINK_LIBRARIES(avidemux2_qt4 ADM_dialogQt4)
-TARGET_LINK_LIBRARIES(avidemux2_qt4 ADM_guiQt4)
-TARGET_LINK_LIBRARIES(avidemux2_qt4 ADM_filtersQt4)
-TARGET_LINK_LIBRARIES(avidemux2_qt4 ADM_UIQT4)
-TARGET_LINK_LIBRARIES(avidemux2_qt4 ADM_guiQt4)
-TARGET_LINK_LIBRARIES(avidemux2_qt4 ADM_UI_QT4)
+TARGET_LINK_LIBRARIES(avidemux3_qt4 ADM_UIQT4)
+TARGET_LINK_LIBRARIES(avidemux3_qt4 ADM_dialogQt4)
+TARGET_LINK_LIBRARIES(avidemux3_qt4 ADM_guiQt4)
+TARGET_LINK_LIBRARIES(avidemux3_qt4 ADM_filtersQt4)
+TARGET_LINK_LIBRARIES(avidemux3_qt4 ADM_UIQT4)
+TARGET_LINK_LIBRARIES(avidemux3_qt4 ADM_guiQt4)
+TARGET_LINK_LIBRARIES(avidemux3_qt4 ADM_UI_QT4)
 ###########################################
 # Construct Core libraries
 ###########################################
 
 FOREACH (_libName ${coreLibs})
-        TARGET_LINK_LIBRARIES(avidemux2_qt4 ${_libName})
+        TARGET_LINK_LIBRARIES(avidemux3_qt4 ${_libName})
 ENDFOREACH (_libName ${commonLibs})
         
 
@@ -83,32 +83,32 @@
 ###########################################
 # gettext
 IF (GETTEXT_FOUND)
-	TARGET_LINK_LIBRARIES(avidemux2_qt4 ${GETTEXT_LIBRARY_DIR})
+	TARGET_LINK_LIBRARIES(avidemux3_qt4 ${GETTEXT_LIBRARY_DIR})
 ENDIF (GETTEXT_FOUND)
 
 
 # PNG
 IF (USE_PNG)
-        TARGET_LINK_LIBRARIES(avidemux2_qt4 ${PNG_LIBRARIES})
+        TARGET_LINK_LIBRARIES(avidemux3_qt4 ${PNG_LIBRARIES})
 	
 ENDIF (USE_PNG)
 
 
 # XVideo
 IF (USE_XV)
-        TARGET_LINK_LIBRARIES(avidemux2_qt4 ${XVIDEO_LIBRARY_DIR})
+        TARGET_LINK_LIBRARIES(avidemux3_qt4 ${XVIDEO_LIBRARY_DIR})
 ENDIF (USE_XV)
 
 # SDL
 IF (USE_SDL)
-        TARGET_LINK_LIBRARIES(avidemux2_qt4 ${SDL_LIBRARY})
+        TARGET_LINK_LIBRARIES(avidemux3_qt4 ${SDL_LIBRARY})
 ENDIF (USE_SDL)
 
 ###########################################
 # UI Specific
 ###########################################
-ADD_TARGET_LDFLAGS(avidemux2_qt4  ${GTHREAD_LDFLAGS})
-TARGET_LINK_LIBRARIES(avidemux2_qt4 ${QT_QTGUI_LIBRARY} ${QT_QTCORE_LIBRARY})
+ADD_TARGET_LDFLAGS(avidemux3_qt4  ${GTHREAD_LDFLAGS})
+TARGET_LINK_LIBRARIES(avidemux3_qt4 ${QT_QTGUI_LIBRARY} ${QT_QTCORE_LIBRARY})
 
 ###########################################
 # OS Specific
@@ -117,22 +117,22 @@
 	target_link_libraries(ADM_osSupport)
 
 	IF (MINGW)
-		target_link_libraries(avidemux2_qt4 -mno-cygwin)
+		target_link_libraries(avidemux3_qt4 -mno-cygwin)
 	ENDIF (MINGW)
 
-	target_link_libraries(avidemux2_qt4 winmm)
-        ADD_TARGET_LDFLAGS(avidemux2_qt4 "-mwindows")
+	target_link_libraries(avidemux3_qt4 winmm)
+        ADD_TARGET_LDFLAGS(avidemux3_qt4 "-mwindows")
 
 ENDIF (WIN32)
 #
 # xml
 #
-TARGET_LINK_LIBRARIES(avidemux2_qt4 ${LIBXML2_LIBRARIES})
+TARGET_LINK_LIBRARIES(avidemux3_qt4 ${LIBXML2_LIBRARIES})
 
 ###########################################
 # Install
 ###########################################
-ADM_LINK_THREAD(avidemux2_qt4)
-ADM_INSTALL_BIN(avidemux2_qt4)
+ADM_LINK_THREAD(avidemux3_qt4)
+ADM_INSTALL_BIN(avidemux3_qt4)
 INSTALL(FILES ${CMAKE_BINARY_DIR}/config/qt4/config.h DESTINATION "${AVIDEMUX_INCLUDE_DIR}/avidemux/2.6/qt4") 
 include(./qt4PackageDebian.cmake)

Modified: branches/avidemux_2.6_branch_mean/avidemux/qt4/qt4PackageDebian.cmake
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/qt4/qt4PackageDebian.cmake	2009-08-01 16:01:46 UTC (rev 5193)
+++ branches/avidemux_2.6_branch_mean/avidemux/qt4/qt4PackageDebian.cmake	2009-08-01 18:09:31 UTC (rev 5194)
@@ -2,7 +2,7 @@
 # DEBIAN
 ##############################
 SET(CPACK_SET_DESTDIR "ON")
-SET(CPACK_DEBIAN_PACKAGE_NAME "avidemux2-qt4")
+SET(CPACK_DEBIAN_PACKAGE_NAME "avidemux3-qt4")
 SET (CPACK_GENERATOR "DEB")
 # ARCH
 IF (X86_64_SUPPORTED)
@@ -16,7 +16,7 @@
 
 # Build our deps list
 # Build deps SET(DEPS "debhelper (>> 4), libfreetype6-dev, libxml2-dev,  libxv-dev, dpatch , cmake, desktop-file-utils")
-SET(DEPS "libc6 (>=2.4),libglib2.0-0 (>=2.14.0),libstdc++6 (>=4.2.1),libx11-6,  libxml2 (>=2.6.27), libxv1, zlib1g (>=1:1.1.4), avidemux2-core (>=2.6.0)")
+SET(DEPS "libc6 (>=2.4),libglib2.0-0 (>=2.14.0),libstdc++6 (>=4.2.1),libx11-6,  libxml2 (>=2.6.27), libxv1, zlib1g (>=1:1.1.4), avidemux3-core (>=2.6.0)")
 # Add optional DEPS here
 SET(CPACK_DEBIAN_PACKAGE_DEPENDS "${DEPS}")
 #
@@ -28,7 +28,7 @@
 SET(CPACK_PACKAGE_VERSION_PATCH "0")
 SET(CPACK_PACKAGE_VERSION_PATCH "0-${ADM_SUBVERSION}")
 #
-SET(CPACK_PACKAGE_NAME "avidemux2-qt4")
+SET(CPACK_PACKAGE_NAME "avidemux3-qt4")
 #
 
 include(CPack)

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/corePackageDebian.cmake
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/corePackageDebian.cmake	2009-08-01 16:01:46 UTC (rev 5193)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/corePackageDebian.cmake	2009-08-01 18:09:31 UTC (rev 5194)
@@ -2,7 +2,7 @@
 # DEBIAN
 ##############################
 SET(CPACK_SET_DESTDIR "ON")
-SET(CPACK_DEBIAN_PACKAGE_NAME "avidemux2-core")
+SET(CPACK_DEBIAN_PACKAGE_NAME "avidemux3-core")
 SET (CPACK_GENERATOR "DEB")
 # ARCH
 IF (X86_64_SUPPORTED)
@@ -29,7 +29,7 @@
 
 SET(CPACK_PACKAGE_VERSION_PATCH "0-r${ADM_SUBVERSION}")
 #
-SET(CPACK_PACKAGE_NAME "avidemux2-core")
+SET(CPACK_PACKAGE_NAME "avidemux3-core")
 #
 
 include(CPack)

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/pluginsPackageDebian.cmake
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/pluginsPackageDebian.cmake	2009-08-01 16:01:46 UTC (rev 5193)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/pluginsPackageDebian.cmake	2009-08-01 18:09:31 UTC (rev 5194)
@@ -2,7 +2,7 @@
 # DEBIAN
 ##############################
 SET(CPACK_SET_DESTDIR "ON")
-SET(CPACK_DEBIAN_PACKAGE_NAME "avidemux2-plugins")
+SET(CPACK_DEBIAN_PACKAGE_NAME "avidemux3-plugins")
 SET (CPACK_GENERATOR "DEB")
 # ARCH
 IF (X86_64_SUPPORTED)
@@ -16,7 +16,7 @@
 
 # Build our deps list
 # Build deps SET(DEPS "debhelper (>> 4), libfreetype6-dev, libxml2-dev,  libxv-dev, dpatch , cmake, desktop-file-utils")
-SET(DEPS "libc6 (>=2.4),libglib2.0-0 (>=2.14.0),libstdc++6 (>=4.2.1),libx11-6,  libxml2 (>=2.6.27), libxv1, zlib1g (>=1:1.1.4), avidemux2-core (>=2.6.0)")
+SET(DEPS "libc6 (>=2.4),libglib2.0-0 (>=2.14.0),libstdc++6 (>=4.2.1),libx11-6,  libxml2 (>=2.6.27), libxv1, zlib1g (>=1:1.1.4), avidemux3-core (>=2.6.0)")
 # Add optional DEPS here
 SET(CPACK_DEBIAN_PACKAGE_DEPENDS "${DEPS}")
 #
@@ -28,7 +28,7 @@
 SET(CPACK_PACKAGE_VERSION_PATCH "0")
 SET(CPACK_PACKAGE_VERSION_PATCH "0-${ADM_SUBVERSION}")
 #
-SET(CPACK_PACKAGE_NAME "avidemux2-plugins")
+SET(CPACK_PACKAGE_NAME "avidemux3-plugins")
 #
 
 include(CPack)



From mean at mail.berlios.de  Sat Aug  1 20:09:36 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sat, 1 Aug 2009 20:09:36 +0200
Subject: [Avidemux-svn-commit] r5195 -
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDecoders/ADM_ad_lav
Message-ID: <200908011809.n71I9a7W005842@sheep.berlios.de>

Author: mean
Date: 2009-08-01 20:09:35 +0200 (Sat, 01 Aug 2009)
New Revision: 5195

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDecoders/ADM_ad_lav/ADM_ad_lav.cpp
Log:
[AudioDecoder] Make DTS decoding available through lav, like in 2.5

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDecoders/ADM_ad_lav/ADM_ad_lav.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDecoders/ADM_ad_lav/ADM_ad_lav.cpp	2009-08-01 18:09:31 UTC (rev 5194)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDecoders/ADM_ad_lav/ADM_ad_lav.cpp	2009-08-01 18:09:35 UTC (rev 5195)
@@ -41,11 +41,11 @@
 
 // Supported formats + declare our plugin
 //*******************************************************
-static uint32_t Formats[]={ WAV_WMA,WAV_QDM2,WAV_AMV_ADPCM,WAV_NELLYMOSER};
+static uint32_t Formats[]={ WAV_WMA,WAV_QDM2,WAV_AMV_ADPCM,WAV_NELLYMOSER,WAV_DTS};
 DECLARE_AUDIO_DECODER(ADM_AudiocodecWMA,						// Class
-			0,0,1, 												// Major, minor,patch
-			Formats, 											// Supported formats
-			"Lavcodec decoder plugin for avidemux (c) Mean\n"); 	// Desc
+			0,0,1, 							       // Major, minor,patch
+			Formats, 							// Supported formats
+			"Lavcodec decoder plugin for avidemux (c) Mean/Gruntster\n"); 	// Desc
 //********************************************************
 
 #define _context ((AVCodecContext *)_contextVoid)
@@ -100,7 +100,10 @@
         _context->codec_id = CODEC_ID_NELLYMOSER;
         _blockalign=1;
         break;
-
+      case WAV_DTS:
+        _context->codec_id = CODEC_ID_DTS;
+        _blockalign = 1;
+        break;
       default:
              ADM_assert(0);
     }



From mean at mail.berlios.de  Sat Aug  1 20:09:40 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sat, 1 Aug 2009 20:09:40 +0200
Subject: [Avidemux-svn-commit] r5196 - in branches/avidemux_2.6_branch_mean:
	avidemux/common/ADM_audiocodec avidemux_core/ADM_coreAudio/include
	avidemux_core/ADM_ffmpeg/ffmpeg_config
	avidemux_core/ADM_ffmpeg/libavcodec
	avidemux_plugins/ADM_audioDecoders/ADM_ad_ac3
	avidemux_plugins/ADM_audioDecoders/ADM_ad_dca
	avidemux_plugins/ADM_audioDecoders/ADM_ad_faad
	avidemux_plugins/ADM_audioDecoders/ADM_ad_ima_adpcm
	avidemux_plugins/ADM_audioDecoders/ADM_ad_lav
	avidemux_plugins/ADM_audioDecoders/ADM_ad_mad
	avidemux_plugins/ADM_audioDecoders/ADM_ad_ms_adpcm
	avidemux_plugins/ADM_audioDecoders/ADM_ad_opencore_amrnb
	avidemux_plugins/ADM_audioDecoders/ADM_ad_opencore_amrwb
	avidemux_plugins/ADM_audioDecoders/ADM_ad_ulaw
	avidemux_plugins/ADM_audioDecoders/ADM_ad_vorbis
Message-ID: <200908011809.n71I9ee6005854@sheep.berlios.de>

Author: mean
Date: 2009-08-01 20:09:38 +0200 (Sat, 01 Aug 2009)
New Revision: 5196

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audiocodec/ADM_ad_plugin.h
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audiocodec/ADM_pluginLoad.cpp
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreAudio/include/ADM_audioCodecEnum.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/ffmpeg_config/config.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/ffmpeg_config/ffconf.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDecoders/ADM_ad_ac3/ADM_ad_a52.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDecoders/ADM_ad_dca/ADM_dca.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDecoders/ADM_ad_faad/ADM_ad_faad.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDecoders/ADM_ad_ima_adpcm/ADM_ad_ima_adpcm.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDecoders/ADM_ad_lav/ADM_ad_lav.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDecoders/ADM_ad_mad/ADM_ad_mad.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDecoders/ADM_ad_ms_adpcm/ADM_ad_ms_adpcm.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDecoders/ADM_ad_opencore_amrnb/ADM_ad_opencore_amrnb.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDecoders/ADM_ad_opencore_amrwb/ADM_ad_opencore_amrwb.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDecoders/ADM_ad_ulaw/ADM_ad_ulaw.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDecoders/ADM_ad_vorbis/ADM_ad_vorbis.cpp
Log:
[audio] set priority to audio decoder (fixes #8), plus add ac3, eac3 and dts to ffmpeg configuration

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audiocodec/ADM_ad_plugin.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audiocodec/ADM_ad_plugin.h	2009-08-01 18:09:35 UTC (rev 5195)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audiocodec/ADM_ad_plugin.h	2009-08-01 18:09:38 UTC (rev 5196)
@@ -9,18 +9,31 @@
 #include "ADM_audiocodec.h"
 
 
-#define AD_API_VERSION 1
+#define AD_API_VERSION 2
 /* These are the 6 functions exported by each plugin ...*/
 typedef ADM_Audiocodec  *(ADM_ad_CreateFunction)(uint32_t fourcc, 
 								WAVHeader *info,uint32_t extraLength,uint8_t *extraData);
 typedef void             (ADM_ad_DeleteFunction)(ADM_Audiocodec *codec);
-typedef bool             (ADM_ad_SupportedFormat)(uint32_t audioFourcc);
+typedef int             (ADM_ad_SupportedFormat)(uint32_t audioFourcc);
 typedef uint32_t         (ADM_ad_GetApiVersion)(void);
 typedef bool            (ADM_ad_GetDecoderVersion)(uint32_t *major, uint32_t *minor, uint32_t *patch);
 typedef const char       *(ADM_ADM_ad_GetInfo)(void);
 
 /* handly macro to declare plugins*/
+/**
+    \struct ad_supportedFormat
+*/
+typedef struct
+{
+    uint32_t fourcc;
+    uint32_t priority;  // The lower the value, the less desirable the codec is, 0 means unsupported
+                        // Valid value ranges from 1 (low quality codec) to 254 (must have codec)
+}ad_supportedFormat;
 
+#define AD_LOW_QUAL     50
+#define AD_MEDIUM_QUAL  100
+#define AD_HIGH_QUAL    150
+
 #define DECLARE_AUDIO_DECODER(Class,Major,Minor,Patch,Formats,Desc) \
 	extern "C" { \
 	ADM_Audiocodec *create(uint32_t fourcc,	WAVHeader *info,uint32_t extraLength,uint8_t *extraData)\
@@ -32,12 +45,12 @@
 		Class *a=(Class *)codec;\
 		delete a;\
 	}\
-	bool supportedFormat(uint32_t audioFourcc) \
+	int supportedFormat(uint32_t audioFourcc) \
 	{ \
-		for(int i=0;i<sizeof(Formats)/sizeof(uint32_t);i++)\
-			if(Formats[i]==audioFourcc) \
-				return true; \
-		return false; \
+		for(int i=0;i<sizeof(Formats)/sizeof(ad_supportedFormat);i++)\
+			if(Formats[i].fourcc==audioFourcc) \
+				return Formats[i].priority; \
+		return 0; \
 	} \
 	uint32_t getApiVersion(void)\
 	{\

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audiocodec/ADM_pluginLoad.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audiocodec/ADM_pluginLoad.cpp	2009-08-01 18:09:35 UTC (rev 5195)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audiocodec/ADM_pluginLoad.cpp	2009-08-01 18:09:38 UTC (rev 5196)
@@ -159,18 +159,28 @@
  */
 ADM_Audiocodec *ADM_ad_searchCodec(uint32_t fourcc,	WAVHeader *info,uint32_t extraLength,uint8_t *extraData)
 {
+    int best=0;
+    int index=-1;
 	for(int i=0;i<ADM_audioPlugins.size();i++)
 	{
 		ADM_ad_plugin *a=ADM_audioPlugins[i];
 		ADM_assert(a);
 		ADM_assert(a->supportedFormat);
-		aprintf("[ADM_ad_plugin]Format 0x%x : probing %s\n",fourcc,a->name);
-		if(a->supportedFormat(fourcc)==true)
-		{
-			ADM_assert(a->create);
-			return a->create(fourcc, info,extraLength,extraData);
-		}
+		
+        int score=a->supportedFormat(fourcc);
+        aprintf("[ADM_ad_plugin]Format 0x%x : probing %s score %d\n",fourcc,a->name,score);
+        if(score>best)
+        {
+            index=i;
+            best=score;
+        }
 	}
+    if(index!=-1 && best >0)
+    {
+        ADM_ad_plugin *a=ADM_audioPlugins[index];
+        ADM_assert(a->create);
+        return a->create(fourcc, info,extraLength,extraData);
+    }
 	return NULL;
 }
 

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreAudio/include/ADM_audioCodecEnum.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreAudio/include/ADM_audioCodecEnum.h	2009-08-01 18:09:35 UTC (rev 5195)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreAudio/include/ADM_audioCodecEnum.h	2009-08-01 18:09:38 UTC (rev 5196)
@@ -12,6 +12,7 @@
 #define WAV_LPCM 	3
 #define WAV_AC3 	0x2000
 #define WAV_DTS 	0x2001
+#define WAV_EAC3 	0x2002 // dummy
 #define WAV_OGG 0x676f
 #define WAV_8BITS 	53 // dummy id
 #define WAV_MP4 	54 // dummy id

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/ffmpeg_config/config.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/ffmpeg_config/config.h	2009-08-01 18:09:35 UTC (rev 5195)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/ffmpeg_config/config.h	2009-08-01 18:09:38 UTC (rev 5196)
@@ -13,6 +13,11 @@
 #define CONFIG_MPEG1_VDPAU_DECODER 0
 #define CONFIG_VC1_VDPAU_DECODER 0
 #define CONFIG_WMV3_VDPAU_DECODER 0
+#define CONFIG_DCA_DECODER 1
+#define CONFIG_MP3_DECODER 1
+#define CONFIG_MP2_DECODER 1
+#define CONFIG_AC3_DECODER 1
+#define CONFIG_EAC3_DECODER 1
 #define CONFIG_NELLYMOSER_DECODER 1
 #define CONFIG_ADPCM_IMA_AMV_DECODER 1
 #define CONFIG_CINEPAK_DECODER 1
@@ -74,7 +79,6 @@
 #define CONFIG_MP1_DECODER 0
 #define CONFIG_MLP_DECODER 0
 #define CONFIG_ALAC_DECODER 0
-#define CONFIG_EAC3_DECODER 0
 #define CONFIG_AAC_DECODER 0
 #define CONFIG_PGMYUV_DECODER 0
 #define CONFIG_PPM_DECODER 0
@@ -99,7 +103,6 @@
 #define CONFIG_SUNRAST_DECODER 0
 #define CONFIG_VB_DECODER 0
 #define CONFIG_XSUB_DECODER 0
-#define CONFIG_AC3_DECODER 0
 #define CONFIG_APE_DECODER 0
 #define CONFIG_MPC8_DECODER 0
 #define CONFIG_PCM_S16LE_PLANAR_DECODER 0
@@ -155,14 +158,12 @@
 #define CONFIG_ALAC_DECODER 0
 #define CONFIG_ATRAC3_DECODER 0
 #define CONFIG_COOK_DECODER 0
-#define CONFIG_DCA_DECODER 0
 #define CONFIG_DSICINAUDIO_DECODER 0
 #define CONFIG_IMC_DECODER 0
 #define CONFIG_LIBA52_DECODER 0
 #define CONFIG_LIBFAAD_DECODER 0
 #define CONFIG_MACE3_DECODER 0
 #define CONFIG_MACE6_DECODER 0
-#define CONFIG_MP3_DECODER 0
 #define CONFIG_MP3ADU_DECODER 0
 #define CONFIG_MP3ON4_DECODER 0
 #define CONFIG_MPC7_DECODER 0
@@ -202,7 +203,6 @@
 #define CONFIG_LIBAMR_WB_DECODER 0
 #define CONFIG_LIBGSM_DECODER 0
 #define CONFIG_LIBGSM_MS_DECODER 0
-#define CONFIG_MP2_DECODER 0
 #define CONFIG_SONIC_DECODER 0
 #define CONFIG_VORBIS_DECODER 0
 #define CONFIG_WMAV1_DECODER 0

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/ffmpeg_config/ffconf.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/ffmpeg_config/ffconf.c	2009-08-01 18:09:35 UTC (rev 5195)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/ffmpeg_config/ffconf.c	2009-08-01 18:09:38 UTC (rev 5196)
@@ -35,6 +35,11 @@
 
 #define DECLARE_DECODER(a,b); printf("#define CONFIG_"#a"_DECODER 1\n");
   
+    DECLARE_DECODER(DCA, dca);
+    DECLARE_DECODER(MP3, mp3);
+    DECLARE_DECODER(MP2, mp2);
+    DECLARE_DECODER(AC3, aasc);
+    DECLARE_DECODER(EAC3, eatgq);
     DECLARE_DECODER(NELLYMOSER,nellymoser);
     DECLARE_DECODER(ADPCM_IMA_AMV, amv);
     DECLARE_DECODER(CINEPAK, cinepak);
@@ -100,7 +105,6 @@
     DECLARE_DECODER(MP1, eatgq);
     DECLARE_DECODER(MLP, eatgq);
     DECLARE_DECODER(ALAC, eatgq);
-    DECLARE_DECODER(EAC3, eatgq);
     DECLARE_DECODER(AAC, eatgq);
     DECLARE_DECODER(PGMYUV, eatgq);
     DECLARE_DECODER(PPM, eatgq);
@@ -128,7 +132,6 @@
     DECLARE_DECODER(SUNRAST, aasc);
     DECLARE_DECODER(VB, aasc);
     DECLARE_DECODER(XSUB, aasc);
-    DECLARE_DECODER(AC3, aasc);
     DECLARE_DECODER(APE, aasc);
     DECLARE_DECODER(MPC8, aasc);
     DECLARE_DECODER(PCM_S16LE_PLANAR, aasc);
@@ -186,14 +189,12 @@
     DECLARE_DECODER(ALAC, alac);
     DECLARE_DECODER(ATRAC3, atrac3);
     DECLARE_DECODER(COOK, cook);
-    DECLARE_DECODER(DCA, dca);
     DECLARE_DECODER(DSICINAUDIO, dsicinaudio);
     DECLARE_DECODER(IMC, imc);
     DECLARE_DECODER(LIBA52, liba52);
     DECLARE_DECODER(LIBFAAD, libfaad);
     DECLARE_DECODER(MACE3, mace3);
     DECLARE_DECODER(MACE6, mace6);
-    DECLARE_DECODER(MP3, mp3);
     DECLARE_DECODER(MP3ADU, mp3adu);
     DECLARE_DECODER(MP3ON4, mp3on4);
     DECLARE_DECODER(MPC7, mpc7);
@@ -234,7 +235,6 @@
     DECLARE_DECODER (LIBAMR_WB, libamr_wb);
     DECLARE_DECODER (LIBGSM, libgsm);
     DECLARE_DECODER (LIBGSM_MS, libgsm_ms);
-    DECLARE_DECODER (MP2, mp2);
     DECLARE_DECODER (SONIC, sonic);
     DECLARE_DECODER (VORBIS, vorbis);
     DECLARE_DECODER(WMAV1, wmav1);

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/CMakeLists.txt	2009-08-01 18:09:35 UTC (rev 5195)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/CMakeLists.txt	2009-08-01 18:09:38 UTC (rev 5196)
@@ -22,7 +22,11 @@
 	vc1dsp.c  vp56.c  vp6.c  vp5.c  indeo2.c  smacker.c  opt.c  fraps.c  dnxhddec.c
 	mpeg12data.c  mpegaudiodata.c  msmpeg4data.c  vc1data.c  vp56data.c  mjpegbdec.c
 	h263_parser.c  h264_parser.c  mpeg4video_parser.c  mpegvideo_enc.c  mpeg12enc.c
-	mpegaudioenc.c  ac3enc.c  ac3.c  ac3tab.c  mjpegenc.c  mjpegdec.c  wma.c  
+	mpegaudioenc.c  
+        mjpegenc.c  mjpegdec.c  wma.c  
+        dca.c
+        ac3enc.c  ac3.c  ac3tab.c   ac3_parser.c
+        eac3dec.c ac3dec.c ac3dec_data.c
 	dvbsub_parser.c  dvbsubdec.c  dvbsub.c  xiph.c  sp5xdec.c  
         nellymoserdec.c nellymoser.c
 	ADM_lavcodec.cpp  pthread.c  huffman.c  wmv2dec.c  wmv2.c  h264pred.c  intrax8.c

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDecoders/ADM_ad_ac3/ADM_ad_a52.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDecoders/ADM_ad_ac3/ADM_ad_a52.cpp	2009-08-01 18:09:35 UTC (rev 5195)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDecoders/ADM_ad_ac3/ADM_ad_a52.cpp	2009-08-01 18:09:38 UTC (rev 5196)
@@ -43,7 +43,7 @@
    };
 // Supported formats + declare our plugin
 //*******************************************************
-   static  uint32_t Formats[]={WAV_AC3};
+   static  ad_supportedFormat Formats[]={{WAV_AC3,AD_MEDIUM_QUAL}};
    DECLARE_AUDIO_DECODER(ADM_AudiocodecAC3,						// Class
 		   	0,0,1, 												// Major, minor,patch
 		   	Formats, 											// Supported formats

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDecoders/ADM_ad_dca/ADM_dca.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDecoders/ADM_ad_dca/ADM_dca.cpp	2009-08-01 18:09:35 UTC (rev 5195)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDecoders/ADM_ad_dca/ADM_dca.cpp	2009-08-01 18:09:38 UTC (rev 5196)
@@ -87,7 +87,7 @@
 #define DTS_HANDLE ((LIBDCA_STATE *)dts_handle)
 // Supported formats + declare our plugin
 //*******************************************************
-static uint32_t Formats[]={WAV_DTS};
+ static  ad_supportedFormat Formats[]={{WAV_DTS,AD_LOW_QUAL}};
 DECLARE_AUDIO_DECODER(ADM_AudiocodecDCA,						// Class
 			0,0,1, 												// Major, minor,patch 
 			Formats, 											// Supported formats

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDecoders/ADM_ad_faad/ADM_ad_faad.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDecoders/ADM_ad_faad/ADM_ad_faad.cpp	2009-08-01 18:09:35 UTC (rev 5195)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDecoders/ADM_ad_faad/ADM_ad_faad.cpp	2009-08-01 18:09:38 UTC (rev 5196)
@@ -42,7 +42,11 @@
 };
 // Supported formats + declare our plugin
 //*******************************************************
-static uint32_t Formats[]={WAV_AAC,WAV_MP4};
+
+static  ad_supportedFormat Formats[]={
+        {WAV_AAC,AD_MEDIUM_QUAL},
+        {WAV_MP4,AD_MEDIUM_QUAL}
+};
 DECLARE_AUDIO_DECODER(ADM_faad,						// Class
 			0,0,1, 												// Major, minor,patch
 			Formats, 											// Supported formats

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDecoders/ADM_ad_ima_adpcm/ADM_ad_ima_adpcm.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDecoders/ADM_ad_ima_adpcm/ADM_ad_ima_adpcm.cpp	2009-08-01 18:09:35 UTC (rev 5195)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDecoders/ADM_ad_ima_adpcm/ADM_ad_ima_adpcm.cpp	2009-08-01 18:09:38 UTC (rev 5196)
@@ -62,7 +62,11 @@
 };
 // Supported formats + declare our plugin
 //*******************************************************
-static uint32_t Formats[]={WAV_IMAADPCM};
+
+static  ad_supportedFormat Formats[]={
+        {WAV_IMAADPCM,AD_MEDIUM_QUAL},
+  
+};
 DECLARE_AUDIO_DECODER(ADM_AudiocodecImaAdpcm,						// Class
 			0,0,1, 												// Major, minor,patch
 			Formats, 											// Supported formats

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDecoders/ADM_ad_lav/ADM_ad_lav.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDecoders/ADM_ad_lav/ADM_ad_lav.cpp	2009-08-01 18:09:35 UTC (rev 5195)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDecoders/ADM_ad_lav/ADM_ad_lav.cpp	2009-08-01 18:09:38 UTC (rev 5196)
@@ -41,7 +41,20 @@
 
 // Supported formats + declare our plugin
 //*******************************************************
-static uint32_t Formats[]={ WAV_WMA,WAV_QDM2,WAV_AMV_ADPCM,WAV_NELLYMOSER,WAV_DTS};
+
+static  ad_supportedFormat Formats[]={
+        {WAV_WMA,AD_MEDIUM_QUAL},
+        {WAV_QDM2,AD_MEDIUM_QUAL},
+        {WAV_AMV_ADPCM,AD_MEDIUM_QUAL},
+        {WAV_NELLYMOSER,AD_MEDIUM_QUAL},
+        {WAV_DTS,AD_MEDIUM_QUAL},
+        {WAV_MP3,AD_MEDIUM_QUAL},
+        {WAV_MP2,AD_MEDIUM_QUAL},
+        {WAV_AC3,AD_LOW_QUAL},   // liba52 preferred ???
+        {WAV_EAC3,AD_MEDIUM_QUAL}
+  
+};
+
 DECLARE_AUDIO_DECODER(ADM_AudiocodecWMA,						// Class
 			0,0,1, 							       // Major, minor,patch
 			Formats, 							// Supported formats
@@ -104,6 +117,22 @@
         _context->codec_id = CODEC_ID_DTS;
         _blockalign = 1;
         break;
+      case WAV_MP3:
+        _context->codec_id = CODEC_ID_MP3;
+        _blockalign = 1;
+        break;
+      case WAV_MP2:
+        _context->codec_id = CODEC_ID_MP2;
+        _blockalign = 1;
+        break;
+      case WAV_AC3:
+        _context->codec_id = CODEC_ID_AC3;
+        _blockalign = 1;
+        break;
+      case WAV_EAC3:
+        _context->codec_id = CODEC_ID_EAC3;
+        _blockalign = 1;
+        break;
       default:
              ADM_assert(0);
     }

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDecoders/ADM_ad_mad/ADM_ad_mad.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDecoders/ADM_ad_mad/ADM_ad_mad.cpp	2009-08-01 18:09:35 UTC (rev 5195)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDecoders/ADM_ad_mad/ADM_ad_mad.cpp	2009-08-01 18:09:38 UTC (rev 5196)
@@ -44,7 +44,13 @@
 };
 // Supported formats + declare our plugin
 //*******************************************************
-static uint32_t Formats[]={WAV_MP3,WAV_MP2};
+static  ad_supportedFormat Formats[]={
+        {WAV_MP3,AD_HIGH_QUAL},
+        {WAV_MP2,AD_HIGH_QUAL},
+  
+};
+
+
 DECLARE_AUDIO_DECODER(ADM_AudiocodecMP3,						// Class
 			0,0,1, 												// Major, minor,patch 
 			Formats, 											// Supported formats

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDecoders/ADM_ad_ms_adpcm/ADM_ad_ms_adpcm.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDecoders/ADM_ad_ms_adpcm/ADM_ad_ms_adpcm.cpp	2009-08-01 18:09:35 UTC (rev 5195)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDecoders/ADM_ad_ms_adpcm/ADM_ad_ms_adpcm.cpp	2009-08-01 18:09:38 UTC (rev 5196)
@@ -56,7 +56,14 @@
 };
 // Supported formats + declare our plugin
 //*******************************************************
-static uint32_t Formats[]={WAV_MSADPCM};
+
+static  ad_supportedFormat Formats[]={
+        {WAV_MSADPCM,AD_MEDIUM_QUAL},
+      
+  
+};
+
+
 DECLARE_AUDIO_DECODER(ADM_AudiocodecMsAdpcm,						// Class
 			0,0,1, 												// Major, minor,patch
 			Formats, 											// Supported formats

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDecoders/ADM_ad_opencore_amrnb/ADM_ad_opencore_amrnb.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDecoders/ADM_ad_opencore_amrnb/ADM_ad_opencore_amrnb.cpp	2009-08-01 18:09:35 UTC (rev 5195)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDecoders/ADM_ad_opencore_amrnb/ADM_ad_opencore_amrnb.cpp	2009-08-01 18:09:38 UTC (rev 5196)
@@ -40,7 +40,9 @@
 	uint8_t isDecompressable(void) { return 1; }
 };
 
-static uint32_t Formats[] = { WAV_AMRNB };
+static  ad_supportedFormat Formats[]={
+        {WAV_AMRNB,AD_MEDIUM_QUAL},
+};
 
 DECLARE_AUDIO_DECODER(ADM_AudiocodecOpencoreAmrNb,	// Class
 1,0,0, 												// Major, minor,patch 

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDecoders/ADM_ad_opencore_amrwb/ADM_ad_opencore_amrwb.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDecoders/ADM_ad_opencore_amrwb/ADM_ad_opencore_amrwb.cpp	2009-08-01 18:09:35 UTC (rev 5195)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDecoders/ADM_ad_opencore_amrwb/ADM_ad_opencore_amrwb.cpp	2009-08-01 18:09:38 UTC (rev 5196)
@@ -41,8 +41,9 @@
 	uint8_t isDecompressable(void) { return 1; }
 };
 
-static uint32_t Formats[] = { WAV_AMRWB };
-
+static  ad_supportedFormat Formats[]={
+        {WAV_AMRWB,AD_MEDIUM_QUAL},
+};
 DECLARE_AUDIO_DECODER(ADM_AudiocodecOpencoreAmrWb,	// Class
 1,0,0, 												// Major, minor,patch 
 Formats, 											// Supported formats

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDecoders/ADM_ad_ulaw/ADM_ad_ulaw.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDecoders/ADM_ad_ulaw/ADM_ad_ulaw.cpp	2009-08-01 18:09:35 UTC (rev 5195)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDecoders/ADM_ad_ulaw/ADM_ad_ulaw.cpp	2009-08-01 18:09:38 UTC (rev 5196)
@@ -36,7 +36,10 @@
 };
 // Supported formats + declare our plugin
 //*******************************************************
-static uint32_t Formats[]={WAV_ULAW};
+static  ad_supportedFormat Formats[]={
+        {WAV_ULAW,AD_MEDIUM_QUAL},
+};
+
 DECLARE_AUDIO_DECODER(ADM_AudiocodecUlaw,						// Class
 			0,0,1, 												// Major, minor,patch
 			Formats, 											// Supported formats

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDecoders/ADM_ad_vorbis/ADM_ad_vorbis.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDecoders/ADM_ad_vorbis/ADM_ad_vorbis.cpp	2009-08-01 18:09:35 UTC (rev 5195)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDecoders/ADM_ad_vorbis/ADM_ad_vorbis.cpp	2009-08-01 18:09:38 UTC (rev 5196)
@@ -50,7 +50,9 @@
 
 // Supported formats + declare our plugin
 //*******************************************************
-static uint32_t Formats[]={WAV_OGG};
+static  ad_supportedFormat Formats[]={
+        {WAV_OGG,AD_MEDIUM_QUAL},
+};
 DECLARE_AUDIO_DECODER(ADM_vorbis,						// Class
 			0,0,1, 												// Major, minor,patch
 			Formats, 											// Supported formats



From gruntster at mail.berlios.de  Mon Aug  3 17:58:45 2009
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Mon, 3 Aug 2009 17:58:45 +0200
Subject: [Avidemux-svn-commit] r5197 - branches/avidemux_2.5_branch_gruntster
Message-ID: <200908031558.n73FwjA9018428@sheep.berlios.de>

Author: gruntster
Date: 2009-08-03 17:58:40 +0200 (Mon, 03 Aug 2009)
New Revision: 5197

Modified:
   branches/avidemux_2.5_branch_gruntster/CMakeLists.txt
Log:
[cmake] restore SVN switch

Modified: branches/avidemux_2.5_branch_gruntster/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/CMakeLists.txt	2009-08-01 18:09:38 UTC (rev 5196)
+++ branches/avidemux_2.5_branch_gruntster/CMakeLists.txt	2009-08-03 15:58:40 UTC (rev 5197)
@@ -100,17 +100,17 @@
 OPTION(SVN "" ON)
 SET(ADM_SUBVERSION 0)
 
-#IF ( CMAKE_BUILD_TYPE STREQUAL "Debug" )
+IF (SVN)
 	MESSAGE(STATUS "Checking for SCM Revision")
 	MESSAGE(STATUS "*************************")
 
 	SET(Subversion_FIND_REQUIRED OFF)
-        include (admGetRevision)
-        admGetRevision( ${PROJECT_SOURCE_DIR} ADM_SUBVERSION)
-        MESSAGE(STATUS "  revision: ${ADM_SUBVERSION}")
-	
+	include(admGetRevision)
+	admGetRevision(${PROJECT_SOURCE_DIR} ADM_SUBVERSION)
+	MESSAGE(STATUS "  revision: ${ADM_SUBVERSION}")
+
 	MESSAGE("")
-#ENDIF ( CMAKE_BUILD_TYPE STREQUAL "Debug" )
+ENDIF (SVN)
 
 ########################################
 # Check for libraries



From gruntster at mail.berlios.de  Mon Aug  3 18:19:54 2009
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Mon, 3 Aug 2009 18:19:54 +0200
Subject: [Avidemux-svn-commit] r5198 -
	branches/avidemux_2.5_branch_gruntster/avidemux
Message-ID: <200908031619.n73GJseu024062@sheep.berlios.de>

Author: gruntster
Date: 2009-08-03 18:19:45 +0200 (Mon, 03 Aug 2009)
New Revision: 5198

Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/gtk_gui.cpp
Log:
[gui] fix Go To Frame window (fixes #11)

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/gtk_gui.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/gtk_gui.cpp	2009-08-03 15:58:40 UTC (rev 5197)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/gtk_gui.cpp	2009-08-03 16:19:45 UTC (rev 5198)
@@ -665,12 +665,14 @@
       GUI_GoToFrame (nf);
       break;
     case ACT_Goto:
-      uint32_t fn;
-      fn=curframe;
-      if (DIA_GetIntegerValue ((int *)&fn,0,avifileinfo->nb_frames,QT_TR_NOOP("Go to Frame"),QT_TR_NOOP("_Go to frame:")))
+	int fn;
+
+	fn = curframe;
+
+	if (DIA_GetIntegerValue(&fn, 0, avifileinfo->nb_frames, QT_TR_NOOP("Go to Frame"), QT_TR_NOOP("_Go to frame:")))
 	{
 		if (fn < avifileinfo->nb_frames)
-			GUI_GoToFrame (curframe);
+			GUI_GoToFrame(fn);
 		else
 			GUI_Error_HIG (QT_TR_NOOP("Out of bounds"), NULL);
 	}



From gruntster at mail.berlios.de  Mon Aug  3 18:24:18 2009
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Mon, 3 Aug 2009 18:24:18 +0200
Subject: [Avidemux-svn-commit] r5199 - in
	branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder:
	ADM_vidEnc_avcodec ADM_vidEnc_x264 ADM_vidEnc_x264/gtk
	ADM_vidEnc_x264/qt4 ADM_vidEnc_x264/xml ADM_vidEnc_xvid
	ADM_vidEnc_xvid/gtk ADM_vidEnc_xvid/qt4 common
Message-ID: <200908031624.n73GOIGO025111@sheep.berlios.de>

Author: gruntster
Date: 2009-08-03 18:24:09 +0200 (Mon, 03 Aug 2009)
New Revision: 5199

Modified:
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_avcodec/CMakeLists.txt
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/CMakeLists.txt
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/encoder.cpp
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/gtk/CMakeLists.txt
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/qt4/CMakeLists.txt
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/qt4/x264ConfigDialog.cpp
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/xml/CMakeLists.txt
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_xvid/CMakeLists.txt
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_xvid/encoder.cpp
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_xvid/gtk/CMakeLists.txt
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_xvid/qt4/CMakeLists.txt
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_xvid/qt4/xvidConfigDialog.cpp
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_xvid/qt4/xvidConfigDialog.h
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/common/PluginOptions.cpp
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/common/PluginXmlOptions.cpp
Log:
[vidEnc] allow separate schema and xml directories for plugin options

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_avcodec/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_avcodec/CMakeLists.txt	2009-08-03 16:19:45 UTC (rev 5198)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_avcodec/CMakeLists.txt	2009-08-03 16:24:09 UTC (rev 5199)
@@ -8,14 +8,16 @@
 	set(FFMPEG_INSTALL_DIR ${AVIDEMUX_INSTALL_PREFIX}/lib)
 endif (WIN32)
 
-SET(PLUGIN_SUBDIR "avcodec")
 SET(ADM_vidEnc_avcodec_SRCS  interface.c  encoder.cpp  huffyuvEncoder.cpp
 							 ffvhuffEncoder.cpp  ffv1Encoder.cpp  dvEncoder.cpp  mpeg1Encoder.cpp
 							 mpeg1EncoderOptions.cpp)
 
+set(PLUGIN_SCHEMA_DIR "avcodec")
+set(MPEG1_PLUGIN_CONFIG_DIR "avcodec/mpeg1")
+
 INCLUDE_DIRECTORIES(${CMAKE_CURRENT_BINARY_DIR} ${LIBXML2_INCLUDE_DIR})
-ADD_DEFINITIONS(${LIBXML2_DEFINITIONS})
-ADD_DEFINITIONS(-DPLUGIN_SUBDIR="${PLUGIN_SUBDIR}")
+ADD_DEFINITIONS(${LIBXML2_DEFINITIONS} -DPLUGIN_SCHEMA_DIR="${PLUGIN_SCHEMA_DIR}")
+set_property(SOURCE mpeg1EncoderOptions.cpp PROPERTY COMPILE_FLAGS -DPLUGIN_CONFIG_DIR=\\\"${MPEG1_PLUGIN_CONFIG_DIR}\\\")
 
 getFfmpegLibNames(${AVIDEMUX_SOURCE_DIR}/avidemux/ADM_libraries/ffmpeg)
 
@@ -27,4 +29,4 @@
 
 INIT_VIDEO_ENCODER_PLUGIN(ADM_vidEnc_avcodec)
 INSTALL_VIDEO_ENCODER(ADM_vidEnc_avcodec)
-INSTALL(FILES Mpeg1Param.xsd DESTINATION "${VIDENC_INSTALL_DIR}${PLUGIN_SUBDIR}")
\ No newline at end of file
+INSTALL(FILES Mpeg1Param.xsd DESTINATION "${VIDENC_INSTALL_DIR}${PLUGIN_SCHEMA_DIR}")
\ No newline at end of file

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/CMakeLists.txt	2009-08-03 16:19:45 UTC (rev 5198)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/CMakeLists.txt	2009-08-03 16:24:09 UTC (rev 5199)
@@ -8,13 +8,14 @@
 	checkLibxml2()
 
 	IF (LIBXML2_FOUND)
-		SET(PLUGIN_SUBDIR "x264")
 		SET(QT_PLUGIN_NAME "ADM_vidEnc_x264_Qt")
 		SET(GTK_PLUGIN_NAME "ADM_vidEnc_x264_Gtk")
 		
+		SET(PLUGIN_SCHEMA_DIR "x264")
+		SET(PLUGIN_CONFIG_DIR "x264")
+		
 		INCLUDE_DIRECTORIES(${CMAKE_CURRENT_BINARY_DIR} ${X264_INCLUDE_DIR} ${LIBXML2_INCLUDE_DIR} ../common)
-		ADD_DEFINITIONS(${LIBXML2_DEFINITIONS})
-		ADD_DEFINITIONS(-DPLUGIN_SUBDIR="${PLUGIN_SUBDIR}")
+		ADD_DEFINITIONS(${LIBXML2_DEFINITIONS} -DPLUGIN_SCHEMA_DIR="${PLUGIN_SCHEMA_DIR}" -DPLUGIN_CONFIG_DIR="${PLUGIN_CONFIG_DIR}")
 		
 		SET(ADM_vidEnc_x264_SRCS interface.c configGuiLoader.cpp encoder.cpp guiHelper.cpp zoneOptions.cpp x264Options.cpp)
 
@@ -28,6 +29,6 @@
 
 		INIT_VIDEO_ENCODER_PLUGIN(ADM_vidEnc_x264)
 		INSTALL_VIDEO_ENCODER(ADM_vidEnc_x264)
-		INSTALL(FILES x264Param.xsd DESTINATION "${VIDENC_INSTALL_DIR}${PLUGIN_SUBDIR}")
+		INSTALL(FILES x264Param.xsd DESTINATION "${VIDENC_INSTALL_DIR}${PLUGIN_SCHEMA_DIR}")
 	ENDIF (LIBXML2_FOUND)
 ENDIF (X264_FOUND)
\ No newline at end of file

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/encoder.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/encoder.cpp	2009-08-03 16:19:45 UTC (rev 5198)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/encoder.cpp	2009-08-03 16:24:09 UTC (rev 5199)
@@ -106,10 +106,10 @@
 		else
 			configGuiLibName = QT_PLUGIN_NAME;
 
-		char* configGuiPath = new char[strlen(pluginPath) + 1 + strlen(PLUGIN_SUBDIR) + 1 + strlen(PLUGIN_PREFIX) + strlen(configGuiLibName) + strlen(PLUGIN_SUFFIX) + 1];
+		char* configGuiPath = new char[strlen(pluginPath) + 1 + strlen(PLUGIN_CONFIG_DIR) + 1 + strlen(PLUGIN_PREFIX) + strlen(configGuiLibName) + strlen(PLUGIN_SUFFIX) + 1];
 
 		strcpy(configGuiPath, pluginPath);
-		strcat(configGuiPath, PLUGIN_SUBDIR);
+		strcat(configGuiPath, PLUGIN_CONFIG_DIR);
 		strcat(configGuiPath, "/");
 		strcat(configGuiPath, PLUGIN_PREFIX);
 		strcat(configGuiPath, configGuiLibName);

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/gtk/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/gtk/CMakeLists.txt	2009-08-03 16:19:45 UTC (rev 5198)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/gtk/CMakeLists.txt	2009-08-03 16:24:09 UTC (rev 5199)
@@ -23,5 +23,5 @@
 	ENDIF(GETTEXT_FOUND)
 
 	INIT_VIDEO_ENCODER_PLUGIN(${GTK_PLUGIN_NAME})
-	INSTALL(TARGETS ${GTK_PLUGIN_NAME} DESTINATION "${VIDENC_INSTALL_DIR}${PLUGIN_SUBDIR}")
+	INSTALL(TARGETS ${GTK_PLUGIN_NAME} DESTINATION "${VIDENC_INSTALL_DIR}${PLUGIN_SCHEMA_DIR}")
 ENDIF (GTK_FOUND AND GTHREAD_FOUND)
\ No newline at end of file

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/qt4/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/qt4/CMakeLists.txt	2009-08-03 16:19:45 UTC (rev 5198)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/qt4/CMakeLists.txt	2009-08-03 16:24:09 UTC (rev 5199)
@@ -16,5 +16,5 @@
 	TARGET_LINK_LIBRARIES(${QT_PLUGIN_NAME} ADM_vidEnc_x264 ADM_core ADM_coreUI ${QT_QTGUI_LIBRARY} ${QT_QTCORE_LIBRARY})
 
 	INIT_VIDEO_ENCODER_PLUGIN(${QT_PLUGIN_NAME})
-	INSTALL(TARGETS ${QT_PLUGIN_NAME} DESTINATION "${VIDENC_INSTALL_DIR}${PLUGIN_SUBDIR}")
+	INSTALL(TARGETS ${QT_PLUGIN_NAME} DESTINATION "${VIDENC_INSTALL_DIR}${PLUGIN_SCHEMA_DIR}")
 ENDIF (QT4_FOUND)
\ No newline at end of file

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/qt4/x264ConfigDialog.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/qt4/x264ConfigDialog.cpp	2009-08-03 16:19:45 UTC (rev 5198)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/qt4/x264ConfigDialog.cpp	2009-08-03 16:24:09 UTC (rev 5199)
@@ -557,7 +557,7 @@
 	PluginConfigType configurationType;
 
 	disableGenericSlots = true;
-	options->getPresetConfiguration(&configurationName, &configurationType);		
+	options->getPresetConfiguration(&configurationName, &configurationType);
 
 	bool foundConfig = selectConfiguration(&QString(configurationName), configurationType);
 

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/xml/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/xml/CMakeLists.txt	2009-08-03 16:19:45 UTC (rev 5198)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/xml/CMakeLists.txt	2009-08-03 16:24:09 UTC (rev 5199)
@@ -1 +1 @@
-INSTALL(DIRECTORY . DESTINATION "${VIDENC_INSTALL_DIR}${PLUGIN_SUBDIR}" FILES_MATCHING PATTERN "*.xml" PATTERN ".svn" EXCLUDE)
\ No newline at end of file
+INSTALL(DIRECTORY . DESTINATION "${VIDENC_INSTALL_DIR}${PLUGIN_CONFIG_DIR}" FILES_MATCHING PATTERN "*.xml" PATTERN ".svn" EXCLUDE)
\ No newline at end of file

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_xvid/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_xvid/CMakeLists.txt	2009-08-03 16:19:45 UTC (rev 5198)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_xvid/CMakeLists.txt	2009-08-03 16:24:09 UTC (rev 5199)
@@ -9,11 +9,12 @@
 	IF (LIBXML2_FOUND)
 		SET(QT_PLUGIN_NAME "ADM_vidEnc_Xvid_Qt")
 		SET(GTK_PLUGIN_NAME "ADM_vidEnc_Xvid_Gtk")
-		SET(PLUGIN_SUBDIR "xvid")
+		
+		SET(PLUGIN_SCHEMA_DIR "xvid")
+		SET(PLUGIN_CONFIG_DIR "xvid")
 
 		INCLUDE_DIRECTORIES(${CMAKE_CURRENT_BINARY_DIR} ${XVID_INCLUDE_DIR} ${LIBXML2_INCLUDE_DIR} ../common)
-		ADD_DEFINITIONS(${LIBXML2_DEFINITIONS})
-		ADD_DEFINITIONS(-DPLUGIN_SUBDIR="${PLUGIN_SUBDIR}")
+		ADD_DEFINITIONS(${LIBXML2_DEFINITIONS} -DPLUGIN_SCHEMA_DIR="${PLUGIN_SCHEMA_DIR}" -DPLUGIN_CONFIG_DIR="${PLUGIN_CONFIG_DIR}")
 
 		SET(ADM_vidEnc_xvid_SRCS interface.c  encoder.cpp  xvidOptions.cpp  configGuiLoader.cpp)
 
@@ -26,6 +27,6 @@
 
 		INIT_VIDEO_ENCODER_PLUGIN(ADM_vidEnc_xvid)
 		INSTALL_VIDEO_ENCODER(ADM_vidEnc_xvid)
-		INSTALL(FILES XvidParam.xsd DESTINATION "${VIDENC_INSTALL_DIR}${PLUGIN_SUBDIR}")
+		INSTALL(FILES XvidParam.xsd DESTINATION "${VIDENC_INSTALL_DIR}${PLUGIN_SCHEMA_DIR}")
 	ENDIF (LIBXML2_FOUND)
 ENDIF (XVID_FOUND)
\ No newline at end of file

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_xvid/encoder.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_xvid/encoder.cpp	2009-08-03 16:19:45 UTC (rev 5198)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_xvid/encoder.cpp	2009-08-03 16:24:09 UTC (rev 5199)
@@ -134,10 +134,10 @@
 		else
 			configGuiLibName = QT_PLUGIN_NAME;
 
-		char* configGuiPath = new char[strlen(pluginPath) + 1 + strlen(PLUGIN_SUBDIR) + 1 + strlen(PLUGIN_PREFIX) + strlen(configGuiLibName) + strlen(PLUGIN_SUFFIX) + 1];
+		char* configGuiPath = new char[strlen(pluginPath) + 1 + strlen(PLUGIN_CONFIG_DIR) + 1 + strlen(PLUGIN_PREFIX) + strlen(configGuiLibName) + strlen(PLUGIN_SUFFIX) + 1];
 
 		strcpy(configGuiPath, pluginPath);
-		strcat(configGuiPath, PLUGIN_SUBDIR);
+		strcat(configGuiPath, PLUGIN_CONFIG_DIR);
 		strcat(configGuiPath, "/");
 		strcat(configGuiPath, PLUGIN_PREFIX);
 		strcat(configGuiPath, configGuiLibName);

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_xvid/gtk/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_xvid/gtk/CMakeLists.txt	2009-08-03 16:19:45 UTC (rev 5198)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_xvid/gtk/CMakeLists.txt	2009-08-03 16:24:09 UTC (rev 5199)
@@ -23,5 +23,5 @@
 	ENDIF(GETTEXT_FOUND)
 
 	INIT_VIDEO_ENCODER_PLUGIN(${GTK_PLUGIN_NAME})
-	INSTALL(TARGETS ${GTK_PLUGIN_NAME} DESTINATION "${VIDENC_INSTALL_DIR}${PLUGIN_SUBDIR}")
+	INSTALL(TARGETS ${GTK_PLUGIN_NAME} DESTINATION "${VIDENC_INSTALL_DIR}${PLUGIN_SCHEMA_DIR}")
 ENDIF (GTK_FOUND AND GTHREAD_FOUND)
\ No newline at end of file

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_xvid/qt4/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_xvid/qt4/CMakeLists.txt	2009-08-03 16:19:45 UTC (rev 5198)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_xvid/qt4/CMakeLists.txt	2009-08-03 16:24:09 UTC (rev 5199)
@@ -16,5 +16,5 @@
 	TARGET_LINK_LIBRARIES(${QT_PLUGIN_NAME} ADM_vidEnc_xvid ADM_coreUI ${QT_QTGUI_LIBRARY} ${QT_QTCORE_LIBRARY})
 
 	INIT_VIDEO_ENCODER_PLUGIN(${QT_PLUGIN_NAME})
-	INSTALL(TARGETS ${QT_PLUGIN_NAME} DESTINATION "${VIDENC_INSTALL_DIR}${PLUGIN_SUBDIR}")
+	INSTALL(TARGETS ${QT_PLUGIN_NAME} DESTINATION "${VIDENC_INSTALL_DIR}${PLUGIN_SCHEMA_DIR}")
 ENDIF (QT4_FOUND)
\ No newline at end of file

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_xvid/qt4/xvidConfigDialog.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_xvid/qt4/xvidConfigDialog.cpp	2009-08-03 16:19:45 UTC (rev 5198)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_xvid/qt4/xvidConfigDialog.cpp	2009-08-03 16:24:09 UTC (rev 5199)
@@ -96,15 +96,20 @@
 	bool origDisableGenericSlots = disableGenericSlots;
 	QMap<QString, int> configs;
 	QStringList filter("*.xml");
-	QStringList list = QDir(getUserConfigDirectory()).entryList(filter, QDir::Files | QDir::Readable);
+	char* configDir = XvidOptions::getUserConfigDirectory();
+	QStringList list = QDir(configDir).entryList(filter, QDir::Files | QDir::Readable);
 
+	delete [] configDir;
 	disableGenericSlots = true;
 
 	for (int item = 0; item < list.size(); item++)
 		configs.insert(QFileInfo(list[item]).completeBaseName(), PLUGIN_CONFIG_USER);
 
-	list = QDir(getSystemConfigDirectory()).entryList(filter, QDir::Files | QDir::Readable);
+	configDir = XvidOptions::getSystemConfigDirectory();
+	list = QDir(configDir).entryList(filter, QDir::Files | QDir::Readable);
 
+	delete [] configDir;
+
 	for (int item = 0; item < list.size(); item++)
 		configs.insert(QFileInfo(list[item]).completeBaseName(), PLUGIN_CONFIG_SYSTEM);
 
@@ -235,9 +240,12 @@
 
 void XvidConfigDialog::deleteButton_pressed(void)
 {
-	QString configFileName = QFileInfo(getUserConfigDirectory(), ui.configurationComboBox->currentText() + ".xml").filePath();
+	char *configDir = XvidOptions::getUserConfigDirectory();
+	QString configFileName = QFileInfo(QString(configDir), ui.configurationComboBox->currentText() + ".xml").filePath();
 	QFile configFile(configFileName);
 
+	delete [] configDir;
+
 	if (GUI_Question(QT_TR_NOOP("Are you sure you wish to delete the selected configuration?")) && configFile.exists())
 	{
 		disableGenericSlots = true;
@@ -723,26 +731,6 @@
 	options->setVbvPeakBitrate(ui.vbvPeakBitrateSpinBox->value());
 }
 
-QString XvidConfigDialog::getUserConfigDirectory(void)
-{
-	char *userConfigDirectory = ADM_getHomeRelativePath("xvid");
-	QString qstring = QString(userConfigDirectory);
-
-	delete [] userConfigDirectory;
-
-	return qstring;
-}
-
-QString XvidConfigDialog::getSystemConfigDirectory(void)
-{
-	char* pluginPath = ADM_getPluginPath();
-	QString qstring = QString(pluginPath).append("/").append(PLUGIN_SUBDIR);
-
-	delete [] pluginPath;
-
-	return qstring;
-}
-
 extern "C" int showXvidConfigDialog(vidEncConfigParameters *configParameters, vidEncVideoProperties *properties, vidEncOptions *encodeOptions, XvidOptions *options)
 {
 	XvidConfigDialog dialog(configParameters, properties, encodeOptions, options);

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_xvid/qt4/xvidConfigDialog.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_xvid/qt4/xvidConfigDialog.h	2009-08-03 16:19:45 UTC (rev 5198)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_xvid/qt4/xvidConfigDialog.h	2009-08-03 16:24:09 UTC (rev 5199)
@@ -29,8 +29,6 @@
 	bool selectConfiguration(QString *selectFile, PluginConfigType configurationType);
 	bool loadPresetSettings(vidEncOptions *encodeOptions, XvidOptions *options);
 	void loadSettings(vidEncOptions *encodeOptions, XvidOptions *options);
-	QString getUserConfigDirectory(void);
-	QString getSystemConfigDirectory(void);
 
 public:
 	XvidConfigDialog(vidEncConfigParameters *configParameters, vidEncVideoProperties *properties, vidEncOptions *encodeOptions, XvidOptions *options);

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/common/PluginOptions.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/common/PluginOptions.cpp	2009-08-03 16:19:45 UTC (rev 5198)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/common/PluginOptions.cpp	2009-08-03 16:24:09 UTC (rev 5199)
@@ -376,17 +376,17 @@
 
 char* PluginOptions::getUserConfigDirectory(void)
 {
-	return ADM_getHomeRelativePath(PLUGIN_SUBDIR);
+	return ADM_getHomeRelativePath(PLUGIN_CONFIG_DIR);
 }
 
 char* PluginOptions::getSystemConfigDirectory(void)
 {
 	char* pluginPath = ADM_getPluginPath();
-	char* systemConfigPath = new char[strlen(pluginPath) + strlen(PLUGIN_SUBDIR) + 2];
+	char* systemConfigPath = new char[strlen(pluginPath) + strlen(PLUGIN_CONFIG_DIR) + 2];
 
 	strcpy(systemConfigPath, pluginPath);
 	strcat(systemConfigPath, "/");
-	strcat(systemConfigPath, PLUGIN_SUBDIR);
+	strcat(systemConfigPath, PLUGIN_CONFIG_DIR);
 
 	delete [] pluginPath;
 

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/common/PluginXmlOptions.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/common/PluginXmlOptions.cpp	2009-08-03 16:19:45 UTC (rev 5198)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/common/PluginXmlOptions.cpp	2009-08-03 16:24:09 UTC (rev 5199)
@@ -111,11 +111,11 @@
 bool PluginXmlOptions::validateXml(xmlDocPtr doc, const char *schemaFile)
 {
 	char *pluginDir = ADM_getPluginPath();
-	char schemaPath[strlen(pluginDir) + strlen(PLUGIN_SUBDIR) + 1 + strlen(schemaFile) + 1];
+	char schemaPath[strlen(pluginDir) + strlen(PLUGIN_SCHEMA_DIR) + 1 + strlen(schemaFile) + 1];
 	bool success = false;
 
 	strcpy(schemaPath, pluginDir);
-	strcat(schemaPath, PLUGIN_SUBDIR);
+	strcat(schemaPath, PLUGIN_SCHEMA_DIR);
 	strcat(schemaPath, "/");
 	strcat(schemaPath, schemaFile);
 	delete [] pluginDir;



From gruntster at mail.berlios.de  Mon Aug  3 18:34:06 2009
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Mon, 3 Aug 2009 18:34:06 +0200
Subject: [Avidemux-svn-commit] r5200 - in
	branches/avidemux_2.5_branch_gruntster: avidemux/ADM_encoder
	avidemux/ADM_outputs/oplug_mpegFF
	plugins/ADM_videoEncoder/ADM_vidEnc_avcodec
Message-ID: <200908031634.n73GY6R7030347@sheep.berlios.de>

Author: gruntster
Date: 2009-08-03 18:33:52 +0200 (Mon, 03 Aug 2009)
New Revision: 5200

Added:
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_avcodec/mpegMatrix.h
Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_encoder/adm_encConfig.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_outputs/oplug_mpegFF/oplug_vcdff.cpp
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_avcodec/encoder.cpp
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_avcodec/encoder.h
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_avcodec/mpeg1Encoder.cpp
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_avcodec/mpeg1Encoder.h
Log:
[mpeg1] replicate encoding logic for mpeg-1 plugin (only CQ currently done)

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_encoder/adm_encConfig.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_encoder/adm_encConfig.cpp	2009-08-03 16:24:09 UTC (rev 5199)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_encoder/adm_encConfig.cpp	2009-08-03 16:33:52 UTC (rev 5200)
@@ -87,7 +87,8 @@
 }
 CodecFamilty videoCodecGetFamily(void)
 {
-	if (currentCodecType == CodecXVCD || currentCodecType == CodecXSVCD || currentCodecType == CodecXDVD)
+	if (currentCodecType == CodecXVCD || currentCodecType == CodecXSVCD || currentCodecType == CodecXDVD ||
+		(currentCodecType == CodecExternal && strcmp(videoCodecPluginGetGuid(), "85FC9CAC-CE6C-4aa6-9D5F-352D6349BA3E") == 0))
 		return CodecFamilyXVCD;
 	if (currentCodecType == CodecVCD || currentCodecType == CodecSVCD || currentCodecType == CodecDVD || currentCodecType == CodecRequant)
 		return CodecFamilyMpeg;

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_outputs/oplug_mpegFF/oplug_vcdff.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_outputs/oplug_mpegFF/oplug_vcdff.cpp	2009-08-03 16:24:09 UTC (rev 5199)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_outputs/oplug_mpegFF/oplug_vcdff.cpp	2009-08-03 16:33:52 UTC (rev 5200)
@@ -133,7 +133,9 @@
                 // Check
                 WAVHeader *hdr=audio->getInfo();	
                 audio_encoding=hdr->encoding;
-                if (videoCodecGetType() == CodecXVCD || videoCodecGetType() == CodecVCD)
+
+                if (videoCodecGetType() == CodecXVCD || videoCodecGetType() == CodecVCD ||
+					(videoCodecGetType() == CodecExternal && strcmp(videoCodecPluginGetGuid(), "85FC9CAC-CE6C-4aa6-9D5F-352D6349BA3E") == 0))	// MPEG-1 plugin
                 {
                         if(hdr->frequency!=44100 ||  hdr->encoding != WAV_MP2)
                         {
@@ -215,7 +217,9 @@
           case CodecRequant:
             encoding->setCodec(QT_TR_NOOP("MPEG Requantizer"));
             break;
-          
+          case CodecExternal:
+            encoding->setCodec(encoder->getDisplayName());
+            break;
           default:
             ADM_assert(0);
 	}
@@ -498,4 +502,4 @@
   return audio;
 }
 #endif	
-// EOF
+// EOF
\ No newline at end of file

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_avcodec/encoder.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_avcodec/encoder.cpp	2009-08-03 16:24:09 UTC (rev 5199)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_avcodec/encoder.cpp	2009-08-03 16:33:52 UTC (rev 5200)
@@ -261,6 +261,12 @@
 	if (!_context)
 		return ADM_VIDENC_ERR_FAILED;
 
+	memset(&_frame, 0, sizeof(_frame));
+	_frame.pts = AV_NOPTS_VALUE;
+
+	properties->supportedCspsCount = 1;
+	properties->supportedCsps = &_supportedCsps[0];
+
 	initContext(properties);
 
 	AVCodec *codec = getAvCodec();
@@ -275,12 +281,6 @@
 		return ADM_VIDENC_ERR_FAILED;
 	}
 
-	memset(&_frame, 0, sizeof(_frame));
-	_frame.pts = AV_NOPTS_VALUE;
-
-	properties->supportedCspsCount = 1;
-	properties->supportedCsps = &_supportedCsps[0];
-
 	return ADM_VIDENC_ERR_SUCCESS;
 }
 
@@ -315,6 +315,8 @@
 	passParameters->extraData = _context->extradata;
 	passParameters->extraDataSize = _context->extradata_size;
 
+	//this->printContext();
+
 	return ADM_VIDENC_ERR_SUCCESS;
 }
 
@@ -388,3 +390,182 @@
 
 	return ADM_VIDENC_ERR_SUCCESS;
 }
+
+void AvcodecEncoder::printContext(void)
+{
+	printf("bit_rate: %d\n", _context->bit_rate);
+	printf("bit_rate_tolerance: %d\n", _context->bit_rate_tolerance);
+	printf("flags: %d\n", _context->flags);
+	printf("sub_id: %d\n", _context->sub_id);
+	printf("me_method: %d\n", _context->me_method);
+	printf("extradata_size: %d\n", _context->extradata_size);
+	printf("time_base %d, %d\n", _context->time_base.num, _context->time_base.den);
+	printf("width: %d\n", _context->width);
+	printf("height: %d\n", _context->height);
+	printf("gop_size: %d\n", _context->gop_size);
+	printf("pix_fmt: %d\n", _context->pix_fmt);
+	printf("rate_emu: %d\n", _context->rate_emu);
+	printf("frame_size: %d\n", _context->frame_size);
+	printf("frame_number: %d\n", _context->frame_number);
+	printf("delay: %d\n", _context->delay);
+	printf("qcompress: %f\n", _context->qcompress);
+	printf("qblur: %f\n", _context->qblur);
+	printf("qmin: %d\n", _context->qmin);
+	printf("qmax: %d\n", _context->qmax);
+	printf("max_qdiff: %d\n", _context->max_qdiff);
+	printf("max_b_frames: %d\n", _context->max_b_frames);
+	printf("b_quant_factor: %f\n", _context->b_quant_factor);
+	printf("rc_strategy: %d\n", _context->rc_strategy);
+	printf("b_frame_strategy: %d\n", _context->b_frame_strategy);
+	printf("hurry_up: %d\n", _context->hurry_up);
+	printf("rtp_payload_size: %d\n", _context->rtp_payload_size);
+	printf("mv_bits: %d\n", _context->mv_bits);
+	printf("header_bits: %d\n", _context->header_bits);
+	printf("i_tex_bits: %d\n", _context->i_tex_bits);
+	printf("p_tex_bits: %d\n", _context->p_tex_bits);
+	printf("i_count: %d\n", _context->i_count);
+	printf("p_count: %d\n", _context->p_count);
+	printf("skip_count: %d\n", _context->skip_count);
+	printf("misc_bits: %d\n", _context->misc_bits);
+	printf("frame_bits: %d\n", _context->frame_bits);
+	printf("codec_name: %s\n", _context->codec_name);
+	printf("codec_type: %d\n", _context->codec_type);
+	printf("codec_id: %d\n", _context->codec_id);
+	printf("codec_tag: %d\n", _context->codec_tag);
+	printf("workaround_bugs: %d\n", _context->workaround_bugs);
+	printf("luma_elim_threshold: %d\n", _context->luma_elim_threshold);
+	printf("chroma_elim_threshold: %d\n", _context->chroma_elim_threshold);
+	printf("strict_std_compliance: %d\n", _context->strict_std_compliance);
+	printf("b_quant_offset: %f\n", _context->b_quant_offset);
+	printf("error_recognition: %d\n", _context->error_recognition);
+	printf("has_b_frames: %d\n", _context->has_b_frames);
+	printf("block_align: %d\n", _context->block_align);
+	printf("parse_only: %d\n", _context->parse_only);
+	printf("mpeg_quant: %d\n", _context->mpeg_quant);
+	printf("rc_qsquish: %f\n", _context->rc_qsquish);
+	printf("rc_qmod_amp: %f\n", _context->rc_qmod_amp);
+	printf("rc_qmod_freq: %d\n", _context->rc_qmod_freq);
+	printf("rc_override_count: %d\n", _context->rc_override_count);
+	printf("rc_eq: %s\n", _context->rc_eq);
+	printf("rc_max_rate: %d\n", _context->rc_max_rate);
+	printf("rc_min_rate: %d\n", _context->rc_min_rate);
+	printf("rc_max_rate_header: %d\n", _context->rc_max_rate_header);
+	printf("rc_buffer_size: %d\n", _context->rc_buffer_size);
+	printf("rc_buffer_size_header: %d\n", _context->rc_buffer_size_header);
+	printf("rc_buffer_aggressivity: %f\n", _context->rc_buffer_aggressivity);
+	printf("i_quant_factor: %f\n", _context->i_quant_factor);
+	printf("i_quant_offset: %f\n", _context->i_quant_offset);
+	printf("rc_initial_cplx: %f\n", _context->rc_initial_cplx);
+	printf("dct_algo: %d\n", _context->dct_algo);
+	printf("lumi_masking: %f\n", _context->lumi_masking);
+	printf("temporal_cplx_masking: %f\n", _context->temporal_cplx_masking);
+	printf("spatial_cplx_masking: %f\n", _context->spatial_cplx_masking);
+	printf("p_masking: %f\n", _context->p_masking);
+	printf("dark_masking: %f\n", _context->dark_masking);
+	printf("idct_algo: %d\n", _context->idct_algo);
+	printf("slice_count: %d\n", _context->slice_count);
+	printf("*slice_offset: %d\n", _context->slice_offset);
+	printf("error_concealment: %d\n", _context->error_concealment);
+	printf("dsp_mask: %d\n", _context->dsp_mask);
+	printf("bits_per_coded_sample: %d\n", _context->bits_per_coded_sample);
+	printf("prediction_method: %d\n", _context->prediction_method);
+	printf("sample_aspect_ratio: %d, %d\n", _context->sample_aspect_ratio.num, _context->sample_aspect_ratio.den);
+	printf("debug: %d\n", _context->debug);
+	printf("debug_mv: %d\n", _context->debug_mv);
+	printf("mb_qmin: %d\n", _context->mb_qmin);
+	printf("mb_qmax: %d\n", _context->mb_qmax);
+	printf("me_cmp: %d\n", _context->me_cmp);
+	printf("me_sub_cmp: %d\n", _context->me_sub_cmp);
+	printf("mb_cmp: %d\n", _context->mb_cmp);
+	printf("ildct_cmp: %d\n", _context->ildct_cmp);
+	printf("dia_size: %d\n", _context->dia_size);
+	printf("last_predictor_count: %d\n", _context->last_predictor_count);
+	printf("pre_me: %d\n", _context->pre_me);
+	printf("me_pre_cmp: %d\n", _context->me_pre_cmp);
+	printf("pre_dia_size: %d\n", _context->pre_dia_size);
+	printf("me_subpel_quality: %d\n", _context->me_subpel_quality);
+	printf("dtg_active_format: %d\n", _context->dtg_active_format);
+	printf("me_range: %d\n", _context->me_range);
+	printf("intra_quant_bias: %d\n", _context->intra_quant_bias);
+	printf("inter_quant_bias: %d\n", _context->inter_quant_bias);
+	printf("color_table_id: %d\n", _context->color_table_id);
+	printf("internal_buffer_count: %d\n", _context->internal_buffer_count);
+	printf("global_quality: %d\n", _context->global_quality);
+	printf("coder_type: %d\n", _context->coder_type);
+	printf("context_model: %d\n", _context->context_model);
+	printf("slice_flags: %d\n", _context->slice_flags);
+	printf("xvmc_acceleration: %d\n", _context->xvmc_acceleration);
+	printf("mb_decision: %d\n", _context->mb_decision);
+	printf("stream_codec_tag: %d\n", _context->stream_codec_tag);
+	printf("scenechange_threshold: %d\n", _context->scenechange_threshold);
+	printf("lmin: %d\n", _context->lmin);
+	printf("lmax: %d\n", _context->lmax);
+	printf("noise_reduction: %d\n", _context->noise_reduction);
+	printf("rc_initial_buffer_occupancy: %d\n", _context->rc_initial_buffer_occupancy);
+	printf("inter_threshold: %d\n", _context->inter_threshold);
+	printf("flags2: %d\n", _context->flags2);
+	printf("error_rate: %d\n", _context->error_rate);
+	printf("antialias_algo: %d\n", _context->antialias_algo);
+	printf("quantizer_noise_shaping: %d\n", _context->quantizer_noise_shaping);
+	printf("thread_count: %d\n", _context->thread_count);
+	printf("me_threshold: %d\n", _context->me_threshold);
+	printf("mb_threshold: %d\n", _context->mb_threshold);
+	printf("intra_dc_precision: %d\n", _context->intra_dc_precision);
+	printf("nsse_weight: %d\n", _context->nsse_weight);
+	printf("skip_top: %d\n", _context->skip_top);
+	printf("skip_bottom: %d\n", _context->skip_bottom);
+	printf("profile: %d\n", _context->profile);
+	printf("level: %d\n", _context->level);
+	printf("lowres: %d\n", _context->lowres);
+	printf("coded_width: %d\n", _context->coded_width);
+	printf("coded_height: %d\n", _context->coded_height);
+	printf("frame_skip_threshold: %d\n", _context->frame_skip_threshold);
+	printf("frame_skip_factor: %d\n", _context->frame_skip_factor);
+	printf("frame_skip_exp: %d\n", _context->frame_skip_exp);
+	printf("frame_skip_cmp: %d\n", _context->frame_skip_cmp);
+	printf("border_masking: %f\n", _context->border_masking);
+	printf("mb_lmin: %d\n", _context->mb_lmin);
+	printf("mb_lmax: %d\n", _context->mb_lmax);
+	printf("me_penalty_compensation: %d\n", _context->me_penalty_compensation);
+	printf("skip_loop_filter: %d\n", _context->skip_loop_filter);
+	printf("skip_idct: %d\n", _context->skip_idct);
+	printf("skip_frame: %d\n", _context->skip_frame);
+	printf("bidir_refine: %d\n", _context->bidir_refine);
+	printf("brd_scale: %d\n", _context->brd_scale);
+	printf("crf: %f\n", _context->crf);
+	printf("cqp: %d\n", _context->cqp);
+	printf("keyint_min: %d\n", _context->keyint_min);
+	printf("refs: %d\n", _context->refs);
+	printf("chromaoffset: %d\n", _context->chromaoffset);
+	printf("bframebias: %d\n", _context->bframebias);
+	printf("trellis: %d\n", _context->trellis);
+	printf("complexityblur: %f\n", _context->complexityblur);
+	printf("deblockalpha: %d\n", _context->deblockalpha);
+	printf("deblockbeta: %d\n", _context->deblockbeta);
+	printf("partitions: %d\n", _context->partitions);
+	printf("directpred: %d\n", _context->directpred);
+	printf("cutoff: %d\n", _context->cutoff);
+	printf("scenechange_factor: %d\n", _context->scenechange_factor);
+	printf("mv0_threshold: %d\n", _context->mv0_threshold);
+	printf("b_sensitivity: %d\n", _context->b_sensitivity);
+	printf("compression_level: %d\n", _context->compression_level);
+	printf("use_lpc: %d\n", _context->use_lpc);
+	printf("lpc_coeff_precision: %d\n", _context->lpc_coeff_precision);
+	printf("min_prediction_order: %d\n", _context->min_prediction_order);
+	printf("max_prediction_order: %d\n", _context->max_prediction_order);
+	printf("prediction_order_method: %d\n", _context->prediction_order_method);
+	printf("min_partition_order: %d\n", _context->min_partition_order);
+	printf("max_partition_order: %d\n", _context->max_partition_order);
+	printf("timecode_frame_start: %"LLU"\n", _context->timecode_frame_start);
+	printf("drc_scale: %f\n", _context->drc_scale);
+	printf("reordered_opaque: %"LLU"\n", _context->reordered_opaque);
+	printf("bits_per_raw_sample: %d\n", _context->bits_per_raw_sample);
+	printf("rc_max_available_vbv_use: %f\n", _context->rc_max_available_vbv_use);
+	printf("rc_min_vbv_overflow_use: %f\n", _context->rc_min_vbv_overflow_use);
+	printf("ticks_per_frame: %d\n", _context->ticks_per_frame);
+	printf("color_primaries: %d\n", _context->color_primaries);
+	printf("color_trc: %d\n", _context->color_trc);
+	printf("colorspace: %d\n", _context->colorspace);
+	printf("color_range: %d\n", _context->color_range);
+	printf("chroma_sample_location: %d\n", _context->chroma_sample_location);
+}

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_avcodec/encoder.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_avcodec/encoder.h	2009-08-03 16:24:09 UTC (rev 5199)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_avcodec/encoder.h	2009-08-03 16:33:52 UTC (rev 5200)
@@ -30,6 +30,9 @@
 
 class AvcodecEncoder
 {
+	private:
+		void printContext(void);
+
 	protected:
 		enum CodecID _codecId;
 		int _supportedCsps[1];

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_avcodec/mpeg1Encoder.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_avcodec/mpeg1Encoder.cpp	2009-08-03 16:24:09 UTC (rev 5199)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_avcodec/mpeg1Encoder.cpp	2009-08-03 16:33:52 UTC (rev 5200)
@@ -16,6 +16,7 @@
 #include <libxml/tree.h>
 #include "ADM_inttype.h"
 #include "mpeg1Encoder.h"
+#include "mpegMatrix.h"
 
 extern int _uiType;
 static bool changedConfig(const char* fileName, ConfigMenuType configType);
@@ -54,6 +55,49 @@
 		_context->sample_aspect_ratio.num = 4;
 		_context->sample_aspect_ratio.den = 3;
 	}
+
+	switch (_options.getMatrix())
+	{
+		case MATRIX_TMPGENC:
+			printf("using custom matrix: Tmpg\n");
+			_context->intra_matrix = tmpgenc_intra;
+			_context->inter_matrix = tmpgenc_inter;
+			break;
+		case MATRIX_ANIME:
+			printf("using custom matrix: anim\n");
+			_context->intra_matrix = anime_intra;
+			_context->inter_matrix = anime_inter;
+
+			break;
+		case MATRIX_KVCD:
+			printf("using custom matrix: kvcd\n");
+			_context->intra_matrix = kvcd_intra;
+			_context->inter_matrix = kvcd_inter;
+			break;
+	}
+
+	switch (_options.getInterlaced())
+	{
+		case INTERLACED_TFF:
+			_frame.top_field_first = true;
+		case INTERLACED_BFF:
+			_frame.interlaced_frame = true;
+			break;
+	}
+
+	_context->max_b_frames = 2;
+	_context->luma_elim_threshold = -2;
+	_context->chroma_elim_threshold = -5;
+	_context->me_range = 255;
+	_context->mb_decision = FF_MB_DECISION_RD;
+	_context->scenechange_threshold = 0xfffffff;
+	_context->rc_max_rate_header = _options.getMaxBitrate() * 1000;
+	_context->rc_buffer_size_header = _options.getBufferSize() * 8 * 1024;
+	_context->rc_max_rate = _context->rc_max_rate_header;
+	_context->rc_buffer_size = _context->rc_buffer_size_header;
+
+	if (_encodeOptions.encodeMode == ADM_VIDENC_MODE_CQP)
+		_context->flags |= CODEC_FLAG_QSCALE;
 }
 
 const char* Mpeg1Encoder::getEncoderType(void)
@@ -288,19 +332,12 @@
 		return ADM_VIDENC_ERR_FAILED;
 }
 
-int Mpeg1Encoder::beginPass(vidEncPassParameters *passParameters)
-{
-	return AvcodecEncoder::beginPass(passParameters);
-}
-
 int Mpeg1Encoder::encodeFrame(vidEncEncodeParameters *encodeParams)
 {
-	int ret = AvcodecEncoder::encodeFrame(encodeParams);
-
 	if (_encodeOptions.encodeMode == ADM_VIDENC_MODE_CQP)
-		encodeParams->quantiser = _encodeOptions.encodeModeParameter;
+		_frame.quality = (int)floor(FF_QP2LAMBDA * _encodeOptions.encodeModeParameter + 0.5);
 
-	return ret;
+	return AvcodecEncoder::encodeFrame(encodeParams);
 }
 
 void Mpeg1Encoder::updateEncodeProperties(vidEncOptions *encodeOptions, vidEncVideoProperties *properties)

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_avcodec/mpeg1Encoder.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_avcodec/mpeg1Encoder.h	2009-08-03 16:24:09 UTC (rev 5199)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_avcodec/mpeg1Encoder.h	2009-08-03 16:33:52 UTC (rev 5200)
@@ -56,7 +56,6 @@
 		void saveSettings(vidEncOptions *encodeOptions, Mpeg1EncoderOptions *options);
 		int getOptions(vidEncOptions *encodeOptions, char *pluginOptions, int bufferSize);
 		int setOptions(vidEncOptions *encodeOptions, char *pluginOptions);
-		int beginPass(vidEncPassParameters *passParameters);
 		int encodeFrame(vidEncEncodeParameters *encodeParams);
 };
 #endif	// __cplusplus

Added: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_avcodec/mpegMatrix.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_avcodec/mpegMatrix.h	2009-08-03 16:24:09 UTC (rev 5199)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_avcodec/mpegMatrix.h	2009-08-03 16:33:52 UTC (rev 5200)
@@ -0,0 +1,82 @@
+/***************************************************************************
+                        mpegMatrix.h  -  description
+                        ----------------------------
+
+	Defined mpeg1/2 custom matrices
+
+    begin                : Tue Sep 1 2003
+    copyright            : (C) 2002 by mean
+    email                : fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+static uint16_t tmpgenc_intra[64] = {
+  8, 16, 19, 22, 26, 27, 29, 34,
+  16, 16, 22, 24, 27, 29, 34, 37,
+  19, 22, 26, 27, 29, 34, 34, 38,
+  22, 22, 26, 27, 29, 34, 37, 40,
+  22, 26, 27, 29, 32, 35, 40, 48,
+  26, 27, 29, 32, 35, 40, 48, 58,
+  26, 27, 29, 34, 38, 46, 56, 69,
+  27, 29, 35, 38, 46, 56, 69, 83
+};
+static uint16_t tmpgenc_inter[64] = {
+  16, 17, 18, 19, 20, 21, 22, 23,	//0
+  17, 18, 19, 20, 21, 22, 23, 24,
+  18, 19, 20, 21, 22, 23, 24, 25,
+  19, 20, 21, 22, 23, 24, 26, 27,
+  20, 21, 22, 23, 25, 26, 27, 28,	//4
+  21, 22, 23, 24, 26, 27, 28, 30,
+  22, 23, 24, 26, 27, 28, 30, 31,
+  23, 24, 25, 27, 28, 30, 31, 33
+};
+static uint16_t anime_intra[64] = {
+  8, 32, 32, 32, 32, 32, 32, 32,	//0
+  32, 32, 32, 32, 32, 32, 32, 32,
+  32, 32, 32, 32, 32, 32, 32, 32,
+  32, 32, 32, 32, 32, 32, 32, 32,
+  32, 32, 32, 32, 32, 32, 32, 32,	//4
+  32, 32, 32, 32, 32, 32, 32, 32,
+  32, 32, 32, 32, 32, 32, 32, 32,
+  32, 32, 32, 32, 32, 32, 32, 32
+};
+static uint16_t anime_inter[64] = {
+  16, 16, 16, 16, 16, 16, 16, 16,	//0
+  16, 16, 16, 16, 16, 16, 16, 16,
+  16, 16, 16, 16, 16, 16, 16, 16,
+  16, 16, 16, 16, 16, 16, 16, 16,
+  16, 16, 16, 16, 16, 16, 16, 16,	//4
+  16, 16, 16, 16, 16, 16, 16, 16,
+  16, 16, 16, 16, 16, 16, 16, 16,
+  16, 16, 16, 16, 16, 16, 16, 16,
+};
+//----------------------------------------------
+static uint16_t kvcd_intra[64] = {
+  8, 9, 12, 22, 26, 27, 29, 34,	//0
+  9, 10, 14, 26, 27, 29, 37, 37,
+  12, 14, 18, 27, 29, 34, 37, 38,
+  22, 26, 27, 31, 36, 37, 38, 40,
+
+  26, 27, 29, 36, 39, 38, 40, 48,	//4
+  27, 29, 34, 37, 38, 40, 48, 58,
+  29, 34, 37, 38, 40, 48, 58, 69,
+  34, 37, 38, 40, 48, 58, 69, 79
+};
+static uint16_t kvcd_inter[64] = {
+  16, 18, 20, 22, 24, 26, 28, 30,	//0
+  18, 20, 22, 24, 26, 28, 30, 32,	//0
+  20, 22, 24, 26, 28, 30, 32, 34,	//0
+  22, 24, 26, 28, 30, 32, 34, 36,	//0
+
+  24, 26, 28, 30, 32, 34, 36, 38,	//0
+  26, 28, 30, 32, 34, 36, 38, 40,	//0
+  28, 30, 32, 34, 36, 38, 40, 42,	//0
+  30, 32, 34, 36, 38, 40, 42, 44	//0
+};



From mean at mail.berlios.de  Mon Aug  3 19:10:35 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Mon, 3 Aug 2009 19:10:35 +0200
Subject: [Avidemux-svn-commit] r5201 - in branches/avidemux_2.6_branch_mean:
	. avidemux avidemux/gtk avidemux/qt4 avidemux_core
	avidemux_core/ADM_coreAudioParser/src
	avidemux_core/ADM_ffmpeg/libavcodec cmake foreignBuilds
Message-ID: <200908031710.n73HAZuT002194@sheep.berlios.de>

Author: mean
Date: 2009-08-03 19:10:30 +0200 (Mon, 03 Aug 2009)
New Revision: 5201

Added:
   branches/avidemux_2.6_branch_mean/bootStrapCrossMingw.sh
   branches/avidemux_2.6_branch_mean/cmake/admCrossCompile.cmake
   branches/avidemux_2.6_branch_mean/cmake/admCrossQt4.cmake
   branches/avidemux_2.6_branch_mean/cmake/admMainChecks.cmake
   branches/avidemux_2.6_branch_mean/foreignBuilds/
   branches/avidemux_2.6_branch_mean/foreignBuilds/cross_mingw_core
   branches/avidemux_2.6_branch_mean/foreignBuilds/cross_mingw_plugins
   branches/avidemux_2.6_branch_mean/foreignBuilds/cross_mingw_qt4
Modified:
   branches/avidemux_2.6_branch_mean/avidemux/commonCmakeApplication.cmake
   branches/avidemux_2.6_branch_mean/avidemux/gtk/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/avidemux/qt4/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreAudioParser/src/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/avidemux_core/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/cmake/admCheckLibxml2.cmake
   branches/avidemux_2.6_branch_mean/cmake/admCheckMiscLibs.cmake
   branches/avidemux_2.6_branch_mean/cmake/admCheckQt4.cmake
   branches/avidemux_2.6_branch_mean/cmake/admCheckRequiredLibs.cmake
   branches/avidemux_2.6_branch_mean/cmake/admConfigHelper.cmake
Log:
Squashed commit of the following:

commit e2bf06645c5da2ec29a37ef5517eb725776462fd
Author: fx <fx at quad.(none)>
Date:   Sun Aug 2 18:00:25 2009 +0200

    [build] cleaner configuration of cross script

commit 5237cb74032a14a2377346c3d34570d4073e5209
Author: fx <fx at quad.(none)>
Date:   Sun Aug 2 17:54:17 2009 +0200

    [build] Working cross mingw bootstrap

commit f3946455e4e1eccb8a69e14178d8420d6b4f8119
Author: fx <fx at quad.(none)>
Date:   Sun Aug 2 17:37:49 2009 +0200

    [build] Add a bootStrapCrossMingw.sh file that cross compile to win32. Update the cross setup scripts

commit b9470abdaba8de27fb099f5162caa008a1859d3f
Author: fx <fx at quad.(none)>
Date:   Sun Aug 2 17:37:19 2009 +0200

    [build] Use host Qt4 tools but link with target qt4 (cross compil)

commit 8b5751b52279d7905657d729799c22fa90b3cb59
Author: fx <fx at quad.(none)>
Date:   Sun Aug 2 17:37:10 2009 +0200

    [build] Use host Qt4 tools but link with target qt4 (cross compil)

commit f17ff1353cd5d9b3927c0681134347a761090b0a
Author: fx <fx at quad.(none)>
Date:   Sun Aug 2 16:55:57 2009 +0200

    [build] Cross mingw script for plugins

commit 4f36240185fad12f8ce0722f477c3fddcbbece51
Author: fx <fx at quad.(none)>
Date:   Sun Aug 2 16:54:41 2009 +0200

    [build] Use cmake 2.4 policy everywhere

commit 8ef812d2b73c524912bfe353753138303f4e6eff
Author: fx <fx at quad.(none)>
Date:   Sun Aug 2 16:54:26 2009 +0200

    [ffmpeg] Remove duplicate ac3_parser

commit 2ff59c5c7628b7706e9e5037b4743840b0dcce07
Author: fx <fx at quad.(none)>
Date:   Sun Aug 2 16:13:06 2009 +0200

    [build] Fix policy else GUI_glade have -D path wrongly escaped

commit 9ad59509a9919ad6c1cd675ad33feb26a9b3d69d
Author: fx <fx at quad.(none)>
Date:   Sun Aug 2 16:03:52 2009 +0200

    [build] fix build (need OFFSET64)

commit f7f76f5ea367dc358ae7948faad1f03676895372
Author: fx <fx at quad.(none)>
Date:   Sun Aug 2 15:59:16 2009 +0200

    [build] Factorize cmake checks

commit 1234f11760daff1d367dc4837fcdd8f8f0fa134c
Author: fx <fx at quad.(none)>
Date:   Sun Aug 2 15:49:04 2009 +0200

    [build] Factorize cmake stuff between components

commit 39942de655df9bed2f6ef8520a0e704ad6a406ae
Author: fx <fx at quad.(none)>
Date:   Sun Aug 2 15:48:29 2009 +0200

    [build] rename them to cross- when we cross compile

commit 9535d3eede6f6d575006ba62713a04d911d25f00
Author: fx <fx at quad.(none)>
Date:   Sun Aug 2 15:47:40 2009 +0200

    [build] Add X-Compile file

commit 27097e3a76236ca8d31319c56c26e071bcae91bf
Author: fx <fx at quad.(none)>
Date:   Sun Aug 2 15:11:10 2009 +0200

    [build] Mingw cross compile, ok for core, not ok for qt4

commit 625b3a786935398e07940f35ec5c67fc15189d4b
Author: fx <fx at quad.(none)>
Date:   Sun Aug 2 14:14:36 2009 +0200

    [build] Cross compile win32 from linux tweaks

Modified: branches/avidemux_2.6_branch_mean/avidemux/commonCmakeApplication.cmake
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/commonCmakeApplication.cmake	2009-08-03 16:33:52 UTC (rev 5200)
+++ branches/avidemux_2.6_branch_mean/avidemux/commonCmakeApplication.cmake	2009-08-03 17:10:30 UTC (rev 5201)
@@ -1,90 +1,26 @@
 #
 #
-#
-SET(VERSION 2.6.0)
-CMAKE_MINIMUM_REQUIRED(VERSION 2.4.7 FATAL_ERROR)
-
+cmake_minimum_required(VERSION 2.6)
 if (COMMAND cmake_policy)
 	cmake_policy(VERSION 2.4)
 	cmake_policy(SET CMP0003 NEW)
+	cmake_policy(SET CMP0011 OLD)
 endif (COMMAND cmake_policy)
 ########################################
 # Definitions and Includes
 ########################################
-ADD_DEFINITIONS(-D_FILE_OFFSET_BITS=64 -D_LARGE_FILES)
-ADD_DEFINITIONS(-DHAVE_CONFIG_H)
-########################################
-# Where is the config.h dir
-########################################
-#
-# Access to our cmake lib
-#
 if(NOT PLUGINS)
         SET(AVIDEMUX_TOP_SOURCE_DIR ${CMAKE_SOURCE_DIR}/../..)
 endif(NOT PLUGINS)
 SET(CMAKE_MODULE_PATH "${AVIDEMUX_TOP_SOURCE_DIR}/cmake" "${CMAKE_MODULE_PATH}")
-MESSAGE(STATUS "Avidemux cmake scripts are in ${CMAKE_MODULE_PATH}")
-#
-#
-#
-
-IF (ADM_DEBUG)
-	ADD_DEFINITIONS(-DADM_DEBUG)
-ENDIF (ADM_DEBUG)
-###########################################
-#  Basic cmake helper script
-###########################################
-include(admConfigHelper)
-
 ########################################
-# Avidemux system specific tweaks
+# Shared cmake part
 ########################################
-INCLUDE(admDetermineSystem)
-
-IF (CYGWIN)
-	SET(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -mwin32")
-	SET(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -mwin32")
-ENDIF (CYGWIN)
-
-IF (ADM_CPU_ALTIVEC)
-	SET(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} ${ADM_ALTIVEC_FLAGS}")
-	SET(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} ${ADM_ALTIVEC_FLAGS}")
-ENDIF (ADM_CPU_ALTIVEC)
-
-IF (UNIX AND NOT APPLE)
-	# jog shuttle is only available on Linux due to its interface
-	SET(USE_JOG 1)
-ENDIF (UNIX AND NOT APPLE)
-
-IF (WIN32)
-	SET(CMAKE_SHARED_LINKER_FLAGS "${CMAKE_SHARED_LINKER_FLAGS} -Wl,-enable-auto-image-base -Wl,-enable-auto-import")
-	SET(CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} -Wl,-enable-auto-import")
-
-	IF (CMAKE_BUILD_TYPE STREQUAL "Release")
-		SET(CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} -Wl,-s")
-		SET(CMAKE_SHARED_LINKER_FLAGS "${CMAKE_SHARED_LINKER_FLAGS} -Wl,-s")
-	ENDIF (CMAKE_BUILD_TYPE STREQUAL "Release")
-ENDIF (WIN32)
-
-
-include(FindThreads)
-INCLUDE(admCheckRequiredLibs)
-include(admCheckMiscLibs)
-include( admGetRevision)
+ADD_DEFINITIONS(-D_FILE_OFFSET_BITS=64 -D_LARGE_FILES)
+include(admMainChecks)
 ########################################
-# Subversion
-########################################
-MESSAGE("")
-MESSAGE(STATUS "Checking for SCM")
-MESSAGE(STATUS "****************")
-admGetRevision( ${AVIDEMUX_TOP_SOURCE_DIR} ADM_SUBVERSION)
-MESSAGE("")
-########################################
 # Add include dirs
 ########################################
-SET(AVIDEMUX_INSTALL_DIR "${CMAKE_INSTALL_PREFIX}")
-MARK_AS_ADVANCED(AVIDEMUX_INSTALL_DIR)
-include(admInstallDir)
 include(admCoreIncludes)
 LINK_DIRECTORIES("${AVIDEMUX_LIB_DIR}")
 #

Modified: branches/avidemux_2.6_branch_mean/avidemux/gtk/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/gtk/CMakeLists.txt	2009-08-03 16:33:52 UTC (rev 5200)
+++ branches/avidemux_2.6_branch_mean/avidemux/gtk/CMakeLists.txt	2009-08-03 17:10:30 UTC (rev 5201)
@@ -2,7 +2,15 @@
 MESSAGE("Configure for avidemux Gtk Started")
 MESSAGE("#########################################")
 MESSAGE("")
-PROJECT(Avidemux_gtk)
+SET(VERSION 2.6.0)
+CMAKE_MINIMUM_REQUIRED(VERSION 2.4.7 FATAL_ERROR)
+if (COMMAND cmake_policy)
+	cmake_policy(VERSION 2.4)
+	cmake_policy(SET CMP0003 NEW)
+	cmake_policy(SET CMP0011 OLD)
+endif (COMMAND cmake_policy)
+SET( ADM_PROJECT Avidemux_gtk)
+
 include(../commonCmakeApplication.cmake)
 include(admCheckGtk)
 include(admCheckGlade)

Modified: branches/avidemux_2.6_branch_mean/avidemux/qt4/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/qt4/CMakeLists.txt	2009-08-03 16:33:52 UTC (rev 5200)
+++ branches/avidemux_2.6_branch_mean/avidemux/qt4/CMakeLists.txt	2009-08-03 17:10:30 UTC (rev 5201)
@@ -2,7 +2,15 @@
 MESSAGE("Configure for avidemux Qt4 Started")
 MESSAGE("#########################################")
 MESSAGE("")
-PROJECT(Avidemux_qt4)
+SET(VERSION 2.6.0)
+CMAKE_MINIMUM_REQUIRED(VERSION 2.4.7 FATAL_ERROR)
+if (COMMAND cmake_policy)
+	cmake_policy(VERSION 2.4)
+	cmake_policy(SET CMP0003 NEW)
+	cmake_policy(SET CMP0011 OLD)
+endif (COMMAND cmake_policy)
+SET( ADM_PROJECT Avidemux_qt4)
+# Use old behaviour
 include(../commonCmakeApplication.cmake)
 INCLUDE(admCheckQt4)
 checkQt4()
@@ -10,11 +18,6 @@
         MESSAGE(FATAL_ERROR "Qt4 NOT FOUND")
 ENDIF (NOT QT4_FOUND)
 
-#include(admCheckGtk)
-#include(admCheckGlade)
-#
-#checkGtk()
-#checkGlade()
 ##########################################
 # Config
 ##########################################

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreAudioParser/src/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreAudioParser/src/CMakeLists.txt	2009-08-03 16:33:52 UTC (rev 5200)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreAudioParser/src/CMakeLists.txt	2009-08-03 17:10:30 UTC (rev 5201)
@@ -9,8 +9,6 @@
 ADD_DEFINITIONS( "-DADM_LEGACY_PROGGY")
 ADD_DEFINITIONS( "-DHAVE_LRINT -DHAVE_LRINTF ")
 ADD_DEFINITIONS( "-DCPU_CLIPS_POSITIVE=0 -DCPU_CLIPS_NEGATIVE=0")
-ADD_DEFINITIONS( "-DPACKAGE=`"SRC`"")
-ADD_DEFINITIONS( "-DVERSION=`"0.1.4`"")
 #*************************************************
 ADD_LIBRARY(ADM_audioParser6 SHARED ${ADMaudioParser_SRCS})
 TARGET_LINK_LIBRARIES(ADM_audioParser6 ADM_core6 ADM_coreUI6)

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/CMakeLists.txt	2009-08-03 16:33:52 UTC (rev 5200)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/CMakeLists.txt	2009-08-03 17:10:30 UTC (rev 5201)
@@ -30,7 +30,7 @@
 	dvbsub_parser.c  dvbsubdec.c  dvbsub.c  xiph.c  sp5xdec.c  
         nellymoserdec.c nellymoser.c
 	ADM_lavcodec.cpp  pthread.c  huffman.c  wmv2dec.c  wmv2.c  h264pred.c  intrax8.c
-	intrax8dsp.c  dnxhddata.c  faanidct.c  ac3_parser.c  aac_ac3_parser.c
+	intrax8dsp.c  dnxhddata.c  faanidct.c    aac_ac3_parser.c
         celp_math.c options.c aandcttab.c audioconvert.c mpeg4audio.c svq1dec.c celp_filters.c
 	aac_parser.c  mpegaudiodecheader.c)
 

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/CMakeLists.txt	2009-08-03 16:33:52 UTC (rev 5200)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/CMakeLists.txt	2009-08-03 17:10:30 UTC (rev 5201)
@@ -2,150 +2,27 @@
 MESSAGE("Configure for avidemux core libs Started")
 MESSAGE("#########################################")
 MESSAGE("")
-
-CMAKE_MINIMUM_REQUIRED(VERSION 2.4.7 FATAL_ERROR)
-
+cmake_minimum_required(VERSION 2.6)
 if (COMMAND cmake_policy)
 	cmake_policy(VERSION 2.4)
 	cmake_policy(SET CMP0003 NEW)
+	cmake_policy(SET CMP0011 OLD)
 endif (COMMAND cmake_policy)
 
-
-IF (NOT CMAKE_CXX_COMPILER_WORKS MATCHES "^${CMAKE_CXX_COMPILER_WORKS}$")
-	SET(FRESH_BUILD 1)
-ENDIF (NOT CMAKE_CXX_COMPILER_WORKS MATCHES "^${CMAKE_CXX_COMPILER_WORKS}$")
-
 # need for shared cmake script between avidemux & plugins
 SET(AVIDEMUX_SOURCE_DIR ${CMAKE_SOURCE_DIR})
 SET(AVIDEMUX_TOP_SOURCE_DIR ${CMAKE_SOURCE_DIR}/..)
 SET(AVIDEMUX_CORE_BUILD_DIR ${CMAKE_BINARY_DIR})
-#
+
 SET(CMAKE_MODULE_PATH "${AVIDEMUX_TOP_SOURCE_DIR}/cmake" "${CMAKE_MODULE_PATH}")
-#
-MESSAGE(STATUS "Top Source dir is ${AVIDEMUX_TOP_SOURCE_DIR}")
-MESSAGE("")
 
-PROJECT(Avidemux_core)
-
-IF (${Avidemux_SOURCE_DIR} MATCHES ${Avidemux_BINARY_DIR})
-	MESSAGE("Please do an out-of-tree build:")
-	MESSAGE("rm CMakeCache.txt; mkdir build; cd build; cmake ..; make")
-	MESSAGE(FATAL_ERROR "in-tree-build detected")
-ENDIF (${Avidemux_SOURCE_DIR} MATCHES ${Avidemux_BINARY_DIR})
-
-INCLUDE(admConfigHelper)
-include( admGetRevision)
-
-IF (FRESH_BUILD)
-	MESSAGE("")
-ENDIF (FRESH_BUILD)
-
+include(admMainChecks)
 ########################################
-# Global options
-########################################
-OPTION(VERBOSE "" OFF)
-
-IF (NOT CMAKE_BUILD_TYPE)
-	SET(CMAKE_BUILD_TYPE "Release")
-ENDIF (NOT CMAKE_BUILD_TYPE)
-
-########################################
-# Avidemux system specific tweaks
-########################################
-INCLUDE(admDetermineSystem)
-
-IF (CYGWIN)
-	SET(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -mwin32")
-	SET(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -mwin32")
-ENDIF (CYGWIN)
-
-IF (ADM_CPU_ALTIVEC)
-	SET(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} ${ADM_ALTIVEC_FLAGS}")
-	SET(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} ${ADM_ALTIVEC_FLAGS}")
-ENDIF (ADM_CPU_ALTIVEC)
-
-IF (UNIX AND NOT APPLE)
-	# jog shuttle is only available on Linux due to its interface
-	SET(USE_JOG 1)
-ENDIF (UNIX AND NOT APPLE)
-
-IF (WIN32)
-	SET(BIN_DIR .)
-	SET(CMAKE_SHARED_LINKER_FLAGS "${CMAKE_SHARED_LINKER_FLAGS} -Wl,-enable-auto-image-base -Wl,-enable-auto-import")
-	SET(CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} -Wl,-enable-auto-import")
-
-	IF (CMAKE_BUILD_TYPE STREQUAL "Release")
-		SET(CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} -Wl,-s")
-		SET(CMAKE_SHARED_LINKER_FLAGS "${CMAKE_SHARED_LINKER_FLAGS} -Wl,-s")
-	ENDIF (CMAKE_BUILD_TYPE STREQUAL "Release")
-ELSE (WIN32)
-	SET(BIN_DIR bin)
-ENDIF (WIN32)
-
-########################################
-# Standard Avidemux defines
-########################################
-SET(VERSION 2.6.0)
-
-# Define internal flags for GTK+ and Qt4 builds.  These are turned off
-# if a showstopper is found.  CLI is automatically assumed as possible
-# since it uses the minimum set of required libraries and CMake will 
-# fail if these aren't met.
-
-SET(AVIDEMUX_INSTALL_DIR "${CMAKE_INSTALL_PREFIX}")
-MARK_AS_ADVANCED(AVIDEMUX_INSTALL_DIR)
-include(admInstallDir)
-
-IF (CMAKE_BUILD_TYPE STREQUAL "Debug")
-	SET(ADM_DEBUG 1)
-ENDIF (CMAKE_BUILD_TYPE STREQUAL "Debug")
-########################################
-# Subversion
-########################################
-
-MESSAGE("")
-MESSAGE(STATUS "Checking for SCM")
-MESSAGE(STATUS "****************")
-admGetRevision( ${AVIDEMUX_TOP_SOURCE_DIR} ADM_SUBVERSION)
-MESSAGE("")
-
-
-########################################
-# Check for libraries
-########################################
-SET(MSG_DISABLE_OPTION "Disabled per request")
-
-INCLUDE(admCheckRequiredLibs)
-INCLUDE(admCheckMiscLibs)
-INCLUDE(admCheckVDPAU)
-INCLUDE(FindThreads)
-
-########################################
-# Check functions and includes
-########################################
-IF (NOT SYSTEM_HEADERS_CHECKED)
-	MESSAGE(STATUS "Checking system headers")
-	MESSAGE(STATUS "***********************")
-
-	INCLUDE(CheckIncludeFiles)
-	INCLUDE(CheckFunctionExists)
-
-	CHECK_FUNCTION_EXISTS(gettimeofday HAVE_GETTIMEOFDAY)
-
-	CHECK_INCLUDE_FILES(byteswap.h   HAVE_BYTESWAP_H)	# libavutil
-	CHECK_INCLUDE_FILES(inttypes.h   HAVE_INTTYPES_H)	# internal use, mpeg2enc, mplex
-	CHECK_INCLUDE_FILES(stdint.h     HAVE_STDINT_H)		# internal use, mpeg2enc, mplex
-	CHECK_INCLUDE_FILES(sys/types.h  HAVE_SYS_TYPES_H)	# mad, mpeg2enc
-	CHECK_INCLUDE_FILES(malloc.h     HAVE_MALLOC_H)		# libavcodec, libavutil, libpostproc, libswscale, mplex
-	SET(SYSTEM_HEADERS_CHECKED 1 CACHE BOOL "")
-	MARK_AS_ADVANCED(SYSTEM_HEADERS_CHECKED)
-
-	MESSAGE("")
-ENDIF (NOT SYSTEM_HEADERS_CHECKED)
-########################################
 # VDPAU
 ########################################
+IF(NOT CROSS)
 checkVDPAU()
+ENDIF(NOT CROSS)
 ########################################
 # Debug Summary
 ########################################
@@ -154,6 +31,7 @@
 	MESSAGE("")
 ENDIF (VERBOSE)
 
+
 ########################################
 # Generate config.h
 ########################################

Added: branches/avidemux_2.6_branch_mean/bootStrapCrossMingw.sh
===================================================================
--- branches/avidemux_2.6_branch_mean/bootStrapCrossMingw.sh	2009-08-03 16:33:52 UTC (rev 5200)
+++ branches/avidemux_2.6_branch_mean/bootStrapCrossMingw.sh	2009-08-03 17:10:30 UTC (rev 5201)
@@ -0,0 +1,45 @@
+#!/bin/bash
+# ** Put your config here **
+export PREFIX=i586-mingw32msvc
+export SDLDIR=/mingw
+export MINGW=/mingw
+export QT_HOME=/mingw/Qt/4.5.2
+# ** Put your config here **
+
+fail()
+{
+        echo "** Failed at $1**"
+        exit 1
+}
+
+Process()
+{
+        export BUILDDIR=$1
+        export SCRIPT=$2
+        echo "Building $BUILDDIR from $SOURCEDIR"
+        rm -Rf ./$BUILDDIR
+        mkdir $BUILDDIR || fail mkdir
+        cd $BUILDDIR 
+        sh $TOP/foreignBuilds/$SCRIPT || fail cmake
+        make -j 2 > /tmp/log$BUILDDIR || fail make
+        make install || fail make_install
+}
+
+echo "**BootStrapping avidemux **"
+export TOP=$PWD
+echo "Top dir : $TOP"
+echo "** CORE **"
+cd $TOP
+Process buildMingwCore cross_mingw_core
+echo "** QT4 **"
+cd $TOP
+Process buildMingwQt4 cross_mingw_qt4 
+#echo "** GTK **"
+#cd $TOP
+#Process buildGtk ../avidemux/gtk
+echo "** Plugins **"
+cd $TOP
+Process buildMingwPlugins cross_mingw_plugins 
+echo "** All done **"
+cd $TOP
+echo "** ALL DONE **"

Modified: branches/avidemux_2.6_branch_mean/cmake/admCheckLibxml2.cmake
===================================================================
--- branches/avidemux_2.6_branch_mean/cmake/admCheckLibxml2.cmake	2009-08-03 16:33:52 UTC (rev 5200)
+++ branches/avidemux_2.6_branch_mean/cmake/admCheckLibxml2.cmake	2009-08-03 17:10:30 UTC (rev 5201)
@@ -5,11 +5,23 @@
 
 		SET(LibXml2_FIND_QUIETLY TRUE)
 
-		FIND_PACKAGE(LibXml2)
+                if(CROSS)
+                        MESSAGE(STATUS "Xml2: Cross compilation override")
+                        SET(WIN32 0)
+                endif(CROSS) 
+
+                FIND_PACKAGE(LibXml2)
+
+                if(CROSS)
+                        MESSAGE(STATUS "Cross : Xml2: ${LIBXML2_FOUND} lib:${LIBXML2_LIBRARIES} inc:${LIBXML2_INCLUDE_DIR} ")
+                        SET(LIBXML2_LIBRARIES "-lxml2 -L${CROSS}/lib")
+                        SET(WIN32 1)
+                endif(CROSS) 
+
 		PRINT_LIBRARY_INFO("Libxml2" LIBXML2_FOUND "${LIBXML2_INCLUDE_DIR} ${LIBXML2_DEFINITIONS}" "${LIBXML2_LIBRARIES}")
 
 		SET(LIBXML2_CHECKED 1)
 
 		MESSAGE("")
 	ENDIF (NOT LIBXML2_CHECKED)
-ENDMACRO(checkLibxml2)
\ No newline at end of file
+ENDMACRO(checkLibxml2)

Modified: branches/avidemux_2.6_branch_mean/cmake/admCheckMiscLibs.cmake
===================================================================
--- branches/avidemux_2.6_branch_mean/cmake/admCheckMiscLibs.cmake	2009-08-03 16:33:52 UTC (rev 5200)
+++ branches/avidemux_2.6_branch_mean/cmake/admCheckMiscLibs.cmake	2009-08-03 17:10:30 UTC (rev 5201)
@@ -2,8 +2,9 @@
 # gettext
 ########################################
 INCLUDE(admCheckGettext)
-
+if(NOT CROSS)
 checkGettext()
+endif(NOT CROSS)
 
 SET(ADM_LOCALE "${CMAKE_INSTALL_PREFIX}/share/locale")
 

Modified: branches/avidemux_2.6_branch_mean/cmake/admCheckQt4.cmake
===================================================================
--- branches/avidemux_2.6_branch_mean/cmake/admCheckQt4.cmake	2009-08-03 16:33:52 UTC (rev 5200)
+++ branches/avidemux_2.6_branch_mean/cmake/admCheckQt4.cmake	2009-08-03 17:10:30 UTC (rev 5201)
@@ -4,7 +4,25 @@
 
 		MESSAGE(STATUS "Checking for Qt 4")
 		MESSAGE(STATUS "*****************")
+                IF(CROSS)
+                        MESSAGE(STATUS "Cross compiling override for QT4")
+                        SET(QT_INCLUDES "-I${QT_HOME}/include")
+                        SET(QT_INCLUDE_DIR "${QT_HOME}/include")
+                        SET(QT_BINARY_DIR ${QT_HOME}/bin)
+                        SET(QT_LIBRARY_DIR ${QT_HOME}/lib)
+                        SET(QT4_FOUND 1)
+                        SET(QT_RCC_EXECUTABLE rcc)
+                        SET(QT_MOC_EXECUTABLE moc-qt4)
+                        SET(QT_UIC_EXECUTABLE uic-qt4)
+                        SET(QT_QTCORE_LIBRARY ${QT_HOME}/lib/libQtCore4.a)
+                        SET(QT_QTGUI_LIBRARY ${QT_HOME}/lib/libQtGui4.a)
+                        MESSAGE(STATUS "[QT4Include] ${QT_INCLUDES}")
+                        MESSAGE(STATUS "[QT4IncludeDir] ${QT_INCLUDE_DIR}")
+                        include(admCrossQt4)
+                        
+                               
 
+                ELSE(CROSS)
 		IF (QT4)
 			FIND_PACKAGE(Qt4)	
 			STRING(REGEX REPLACE "[\\]" "/" QT_INCLUDES "${QT_INCLUDES}")	# backslashes aren't taken care of properly on Windows
@@ -17,9 +35,10 @@
 		ELSE (QT4)
 			MESSAGE("${MSG_DISABLE_OPTION}")
 		ENDIF (QT4)
+                ENDIF(CROSS)
 
 		SET(QT4_CHECKED 1)
 
 		MESSAGE("")
 	ENDIF (NOT QT4_CHECKED)
-ENDMACRO(checkQt4)
\ No newline at end of file
+ENDMACRO(checkQt4)

Modified: branches/avidemux_2.6_branch_mean/cmake/admCheckRequiredLibs.cmake
===================================================================
--- branches/avidemux_2.6_branch_mean/cmake/admCheckRequiredLibs.cmake	2009-08-03 16:33:52 UTC (rev 5200)
+++ branches/avidemux_2.6_branch_mean/cmake/admCheckRequiredLibs.cmake	2009-08-03 17:10:30 UTC (rev 5201)
@@ -38,6 +38,12 @@
 MESSAGE(STATUS "*******************")
 
 FIND_PACKAGE(PNG)
+if(CROSS)
+                        MESSAGE(STATUS "Cross compile override")
+                          SET(ZLIB_LIBRARY "-lz -L${CROSS}/lib")
+                          SET(PNG_LIBRARIES " ${ZLIB_LIBRARY} -lpng12 -L${CROSS}/lib")
+endif(CROSS)
+
 PRINT_LIBRARY_INFO("libpng" PNG_FOUND "${PNG_INCLUDE_DIR} ${PNG_DEFINITIONS}" "${PNG_LIBRARIES}" FATAL_ERROR)
 
 FOREACH(_flag ${PNG_INCLUDE_DIR})
@@ -55,6 +61,11 @@
 MESSAGE(STATUS "*********************")
 
 FIND_PACKAGE(Threads)
+if(CROSS)
+                          MESSAGE(STATUS "Cross compile override")
+                          SET(PTHREAD_LIBRARIES "-lpthreadGC2")
+endif(CROSS)
+
 PRINT_LIBRARY_INFO("pthreads" PTHREAD_FOUND "${PTHREAD_INCLUDE_DIR}" "${PTHREAD_LIBRARIES}" FATAL_ERROR)
 
-MESSAGE("")
\ No newline at end of file
+MESSAGE("")

Modified: branches/avidemux_2.6_branch_mean/cmake/admConfigHelper.cmake
===================================================================
--- branches/avidemux_2.6_branch_mean/cmake/admConfigHelper.cmake	2009-08-03 16:33:52 UTC (rev 5200)
+++ branches/avidemux_2.6_branch_mean/cmake/admConfigHelper.cmake	2009-08-03 17:10:30 UTC (rev 5201)
@@ -188,3 +188,6 @@
 
 	TARGET_LINK_LIBRARIES(${_target} ${_flags})
 ENDMACRO (ADD_TARGET_LDFLAGS)
+
+#
+

Added: branches/avidemux_2.6_branch_mean/cmake/admCrossCompile.cmake
===================================================================
--- branches/avidemux_2.6_branch_mean/cmake/admCrossCompile.cmake	2009-08-03 16:33:52 UTC (rev 5200)
+++ branches/avidemux_2.6_branch_mean/cmake/admCrossCompile.cmake	2009-08-03 17:10:30 UTC (rev 5201)
@@ -0,0 +1,23 @@
+
+if(CROSS)
+        MESSAGE(STATUS " ** Win32 Cross compiling activated, overriding cmake internals **")
+        # the name of the target operating system
+        SET(CMAKE_SYSTEM_NAME Windows)
+        
+        # which compilers to use for C and C++
+        SET(CMAKE_C_COMPILER i586-mingw32msvc-gcc)
+        SET(CMAKE_CXX_COMPILER i586-mingw32msvc-g++)
+        SET(CMAKE_LINKER i586-mingw32msvc-ld)
+        SET(CMAKE_AR i586-mingw32msvc-ar)
+        
+        # here is the target environment located
+        SET(CMAKE_FIND_ROOT_PATH  /usr/i586-mingw32msvc ${CROSS} )
+        
+        # adjust the default behaviour of the FIND_XXX() commands:
+        # search headers and libraries in the target environment, search 
+        # programs in the host environment
+        set(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER)
+        set(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY)
+        set(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY)
+endif(CROSS)
+

Added: branches/avidemux_2.6_branch_mean/cmake/admCrossQt4.cmake
===================================================================
--- branches/avidemux_2.6_branch_mean/cmake/admCrossQt4.cmake	2009-08-03 16:33:52 UTC (rev 5200)
+++ branches/avidemux_2.6_branch_mean/cmake/admCrossQt4.cmake	2009-08-03 17:10:30 UTC (rev 5201)
@@ -0,0 +1,171 @@
+
+  MACRO (QT4_EXTRACT_OPTIONS _qt4_files _qt4_options)
+    SET(${_qt4_files})
+    SET(${_qt4_options})
+    SET(_QT4_DOING_OPTIONS FALSE)
+    FOREACH(_currentArg ${ARGN})
+      IF ("${_currentArg}" STREQUAL "OPTIONS")
+        SET(_QT4_DOING_OPTIONS TRUE)
+      ELSE ("${_currentArg}" STREQUAL "OPTIONS")
+        IF(_QT4_DOING_OPTIONS) 
+          LIST(APPEND ${_qt4_options} "${_currentArg}")
+        ELSE(_QT4_DOING_OPTIONS)
+          LIST(APPEND ${_qt4_files} "${_currentArg}")
+        ENDIF(_QT4_DOING_OPTIONS)
+      ENDIF ("${_currentArg}" STREQUAL "OPTIONS")
+    ENDFOREACH(_currentArg) 
+  ENDMACRO (QT4_EXTRACT_OPTIONS)
+  
+  # macro used to create the names of output files preserving relative dirs
+  MACRO (QT4_MAKE_OUTPUT_FILE infile prefix ext outfile )
+    STRING(LENGTH ${CMAKE_CURRENT_BINARY_DIR} _binlength)
+    STRING(LENGTH ${infile} _infileLength)
+    SET(_checkinfile ${CMAKE_CURRENT_SOURCE_DIR})
+    IF(_infileLength GREATER _binlength)
+      STRING(SUBSTRING "${infile}" 0 ${_binlength} _checkinfile)
+      IF(_checkinfile STREQUAL "${CMAKE_CURRENT_BINARY_DIR}")
+        FILE(RELATIVE_PATH rel ${CMAKE_CURRENT_BINARY_DIR} ${infile})
+      ELSE(_checkinfile STREQUAL "${CMAKE_CURRENT_BINARY_DIR}")
+        FILE(RELATIVE_PATH rel ${CMAKE_CURRENT_SOURCE_DIR} ${infile})
+      ENDIF(_checkinfile STREQUAL "${CMAKE_CURRENT_BINARY_DIR}")
+    ELSE(_infileLength GREATER _binlength)
+      FILE(RELATIVE_PATH rel ${CMAKE_CURRENT_SOURCE_DIR} ${infile})
+    ENDIF(_infileLength GREATER _binlength)
+    SET(_outfile "${CMAKE_CURRENT_BINARY_DIR}/${rel}")
+    STRING(REPLACE ".." "__" _outfile ${_outfile})
+    GET_FILENAME_COMPONENT(outpath ${_outfile} PATH)
+    GET_FILENAME_COMPONENT(_outfile ${_outfile} NAME_WE)
+    FILE(MAKE_DIRECTORY ${outpath})
+    SET(${outfile} ${outpath}/${prefix}${_outfile}.${ext})
+  ENDMACRO (QT4_MAKE_OUTPUT_FILE )
+
+  MACRO (QT4_GET_MOC_FLAGS _moc_flags)
+     SET(${_moc_flags})
+     GET_DIRECTORY_PROPERTY(_inc_DIRS INCLUDE_DIRECTORIES)
+
+     FOREACH(_current ${_inc_DIRS})
+        SET(${_moc_flags} ${${_moc_flags}} "-I${_current}")
+     ENDFOREACH(_current ${_inc_DIRS})
+     
+     GET_DIRECTORY_PROPERTY(_defines COMPILE_DEFINITIONS)
+     FOREACH(_current ${_defines})
+        SET(${_moc_flags} ${${_moc_flags}} "-D${_current}")
+     ENDFOREACH(_current ${_defines})
+
+     IF(Q_WS_WIN)
+       SET(${_moc_flags} ${${_moc_flags}} -DWIN32)
+     ENDIF(Q_WS_WIN)
+
+  ENDMACRO(QT4_GET_MOC_FLAGS)
+
+  # helper macro to set up a moc rule
+  MACRO (QT4_CREATE_MOC_COMMAND infile outfile moc_flags moc_options)
+    # For Windows, create a parameters file to work around command line length limit
+    IF (WIN32)
+      # Pass the parameters in a file.  Set the working directory to
+      # be that containing the parameters file and reference it by
+      # just the file name.  This is necessary because the moc tool on
+      # MinGW builds does not seem to handle spaces in the path to the
+      # file given with the @ syntax.
+      GET_FILENAME_COMPONENT(_moc_outfile_name "${outfile}" NAME)
+      GET_FILENAME_COMPONENT(_moc_outfile_dir "${outfile}" PATH)
+      IF(_moc_outfile_dir)
+        SET(_moc_working_dir WORKING_DIRECTORY ${_moc_outfile_dir})
+      ENDIF(_moc_outfile_dir)
+      SET (_moc_parameters_file ${outfile}_parameters)
+      SET (_moc_parameters ${moc_flags} ${moc_options} -o "${outfile}" "${infile}")
+      FILE (REMOVE ${_moc_parameters_file})
+      FOREACH(arg ${_moc_parameters})
+        FILE (APPEND ${_moc_parameters_file} "${arg}\n")
+      ENDFOREACH(arg)
+      ADD_CUSTOM_COMMAND(OUTPUT ${outfile}
+                         COMMAND ${QT_MOC_EXECUTABLE} @${_moc_outfile_name}_parameters
+                         DEPENDS ${infile}
+                         ${_moc_working_dir}
+                         VERBATIM)
+    ELSE (WIN32)     
+      ADD_CUSTOM_COMMAND(OUTPUT ${outfile}
+                         COMMAND ${QT_MOC_EXECUTABLE}
+                         ARGS ${moc_flags} ${moc_options} -o ${outfile} ${infile}
+                         DEPENDS ${infile})     
+    ENDIF (WIN32)
+  ENDMACRO (QT4_CREATE_MOC_COMMAND)
+
+  
+  MACRO (QT4_GENERATE_MOC infile outfile )
+     QT4_GET_MOC_FLAGS(moc_flags)
+     GET_FILENAME_COMPONENT(abs_infile ${infile} ABSOLUTE)
+     QT4_CREATE_MOC_COMMAND(${abs_infile} ${outfile} "${moc_flags}" "")
+     SET_SOURCE_FILES_PROPERTIES(${outfile} PROPERTIES SKIP_AUTOMOC TRUE)  # dont run automoc on this file
+  ENDMACRO (QT4_GENERATE_MOC)
+
+
+  # QT4_WRAP_CPP(outfiles inputfile ... )
+
+  MACRO (QT4_WRAP_CPP outfiles )
+    # get include dirs
+    QT4_GET_MOC_FLAGS(moc_flags)
+    QT4_EXTRACT_OPTIONS(moc_files moc_options ${ARGN})
+
+    FOREACH (it ${moc_files})
+      GET_FILENAME_COMPONENT(it ${it} ABSOLUTE)
+      QT4_MAKE_OUTPUT_FILE(${it} moc_ cxx outfile)
+      QT4_CREATE_MOC_COMMAND(${it} ${outfile} "${moc_flags}" "${moc_options}")
+      SET(${outfiles} ${${outfiles}} ${outfile})
+    ENDFOREACH(it)
+
+  ENDMACRO (QT4_WRAP_CPP)
+
+
+  # QT4_WRAP_UI(outfiles inputfile ... )
+
+  MACRO (QT4_WRAP_UI outfiles )
+    QT4_EXTRACT_OPTIONS(ui_files ui_options ${ARGN})
+
+    FOREACH (it ${ui_files})
+      GET_FILENAME_COMPONENT(outfile ${it} NAME_WE)
+      GET_FILENAME_COMPONENT(infile ${it} ABSOLUTE)
+      SET(outfile ${CMAKE_CURRENT_BINARY_DIR}/ui_${outfile}.h)
+      ADD_CUSTOM_COMMAND(OUTPUT ${outfile}
+        COMMAND ${QT_UIC_EXECUTABLE}
+        ARGS ${ui_options} -o ${outfile} ${infile}
+        MAIN_DEPENDENCY ${infile})
+      SET(${outfiles} ${${outfiles}} ${outfile})
+    ENDFOREACH (it)
+
+  ENDMACRO (QT4_WRAP_UI)
+
+
+  # QT4_ADD_RESOURCES(outfiles inputfile ... )
+
+  MACRO (QT4_ADD_RESOURCES outfiles )
+    QT4_EXTRACT_OPTIONS(rcc_files rcc_options ${ARGN})
+
+    FOREACH (it ${rcc_files})
+      GET_FILENAME_COMPONENT(outfilename ${it} NAME_WE)
+      GET_FILENAME_COMPONENT(infile ${it} ABSOLUTE)
+      GET_FILENAME_COMPONENT(rc_path ${infile} PATH)
+      SET(outfile ${CMAKE_CURRENT_BINARY_DIR}/qrc_${outfilename}.cxx)
+      #  parse file for dependencies 
+      #  all files are absolute paths or relative to the location of the qrc file
+      FILE(READ "${infile}" _RC_FILE_CONTENTS)
+      STRING(REGEX MATCHALL "<file[^<]+" _RC_FILES "${_RC_FILE_CONTENTS}")
+      SET(_RC_DEPENDS)
+      FOREACH(_RC_FILE ${_RC_FILES})
+        STRING(REGEX REPLACE "^<file[^>]*>" "" _RC_FILE "${_RC_FILE}")
+        STRING(REGEX MATCH "^/|([A-Za-z]:/)" _ABS_PATH_INDICATOR "${_RC_FILE}")
+        IF(NOT _ABS_PATH_INDICATOR)
+          SET(_RC_FILE "${rc_path}/${_RC_FILE}")
+        ENDIF(NOT _ABS_PATH_INDICATOR)
+        SET(_RC_DEPENDS ${_RC_DEPENDS} "${_RC_FILE}")
+      ENDFOREACH(_RC_FILE)
+      ADD_CUSTOM_COMMAND(OUTPUT ${outfile}
+        COMMAND ${QT_RCC_EXECUTABLE}
+        ARGS ${rcc_options} -name ${outfilename} -o ${outfile} ${infile}
+        MAIN_DEPENDENCY ${infile}
+        DEPENDS ${_RC_DEPENDS})
+      SET(${outfiles} ${${outfiles}} ${outfile})
+    ENDFOREACH (it)
+
+  ENDMACRO (QT4_ADD_RESOURCES)
+

Copied: branches/avidemux_2.6_branch_mean/cmake/admMainChecks.cmake (from rev 5196, branches/avidemux_2.6_branch_mean/avidemux_core/CMakeLists.txt)
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/CMakeLists.txt	2009-08-01 18:09:38 UTC (rev 5196)
+++ branches/avidemux_2.6_branch_mean/cmake/admMainChecks.cmake	2009-08-03 17:10:30 UTC (rev 5201)
@@ -0,0 +1,140 @@
+
+# Override...
+SET(CMAKE_C_FLAGS $ENV{CFLAGS})
+SET(CMAKE_CXX_FLAGS $ENV{CXXFLAGS})
+SET(CMAKE_LD_FLAGS $ENV{LDFLAGS})
+
+
+IF (NOT CMAKE_CXX_COMPILER_WORKS MATCHES "^${CMAKE_CXX_COMPILER_WORKS}$")
+	SET(FRESH_BUILD 1)
+ENDIF (NOT CMAKE_CXX_COMPILER_WORKS MATCHES "^${CMAKE_CXX_COMPILER_WORKS}$")
+#
+#
+include(admCrossCompile)
+MESSAGE(STATUS "[BUILD] EXTRA Cflags:${CMAKE_C_FLAGS}")
+MESSAGE(STATUS "[BUILD] EXTRA CXXflags:${CMAKE_CXX_FLAGS}")
+MESSAGE(STATUS "[BUILD] EXTRA LDflags:${CMAKE_LD_FLAGS}")
+MESSAGE(STATUS "[BUILD] Compiler ${CMAKE_CXX_COMPILER}")
+MESSAGE(STATUS "[BUILD] Linker   ${CMAKE_LINKER}")
+#
+MESSAGE(STATUS "Top Source dir is ${AVIDEMUX_TOP_SOURCE_DIR}")
+MESSAGE("")
+
+PROJECT(Avidemux_core)
+
+IF (${Avidemux_SOURCE_DIR} MATCHES ${Avidemux_BINARY_DIR})
+	MESSAGE("Please do an out-of-tree build:")
+	MESSAGE("rm CMakeCache.txt; mkdir build; cd build; cmake ..; make")
+	MESSAGE(FATAL_ERROR "in-tree-build detected")
+ENDIF (${Avidemux_SOURCE_DIR} MATCHES ${Avidemux_BINARY_DIR})
+
+INCLUDE(admConfigHelper)
+include( admGetRevision)
+
+
+IF (FRESH_BUILD)
+	MESSAGE("")
+ENDIF (FRESH_BUILD)
+
+########################################
+# Global options
+########################################
+OPTION(VERBOSE "" OFF)
+
+IF (NOT CMAKE_BUILD_TYPE)
+	SET(CMAKE_BUILD_TYPE "Release")
+ENDIF (NOT CMAKE_BUILD_TYPE)
+
+########################################
+# Avidemux system specific tweaks
+########################################
+INCLUDE(admDetermineSystem)
+
+IF (CYGWIN)
+	SET(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -mwin32")
+	SET(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -mwin32")
+ENDIF (CYGWIN)
+
+IF (ADM_CPU_ALTIVEC)
+	SET(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} ${ADM_ALTIVEC_FLAGS}")
+	SET(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} ${ADM_ALTIVEC_FLAGS}")
+ENDIF (ADM_CPU_ALTIVEC)
+
+IF (UNIX AND NOT APPLE)
+	# jog shuttle is only available on Linux due to its interface
+	SET(USE_JOG 1)
+ENDIF (UNIX AND NOT APPLE)
+
+IF (WIN32)
+	SET(BIN_DIR .)
+	SET(CMAKE_SHARED_LINKER_FLAGS "${CMAKE_SHARED_LINKER_FLAGS} -Wl,-enable-auto-image-base -Wl,-enable-auto-import")
+	SET(CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} -Wl,-enable-auto-import")
+
+	IF (CMAKE_BUILD_TYPE STREQUAL "Release")
+		SET(CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} -Wl,-s")
+		SET(CMAKE_SHARED_LINKER_FLAGS "${CMAKE_SHARED_LINKER_FLAGS} -Wl,-s")
+	ENDIF (CMAKE_BUILD_TYPE STREQUAL "Release")
+ELSE (WIN32)
+	SET(BIN_DIR bin)
+ENDIF (WIN32)
+
+########################################
+# Standard Avidemux defines
+########################################
+SET(VERSION 2.6.0)
+
+# Define internal flags for GTK+ and Qt4 builds.  These are turned off
+# if a showstopper is found.  CLI is automatically assumed as possible
+# since it uses the minimum set of required libraries and CMake will 
+# fail if these aren't met.
+
+SET(AVIDEMUX_INSTALL_DIR "${CMAKE_INSTALL_PREFIX}")
+MARK_AS_ADVANCED(AVIDEMUX_INSTALL_DIR)
+include(admInstallDir)
+
+IF (CMAKE_BUILD_TYPE STREQUAL "Debug")
+	SET(ADM_DEBUG 1)
+ENDIF (CMAKE_BUILD_TYPE STREQUAL "Debug")
+########################################
+# Subversion
+########################################
+
+MESSAGE("")
+MESSAGE(STATUS "Checking for SCM")
+MESSAGE(STATUS "****************")
+admGetRevision( ${AVIDEMUX_TOP_SOURCE_DIR} ADM_SUBVERSION)
+MESSAGE("")
+
+
+########################################
+# Check for libraries
+########################################
+SET(MSG_DISABLE_OPTION "Disabled per request")
+INCLUDE(admCheckRequiredLibs)
+INCLUDE(admCheckMiscLibs)
+INCLUDE(FindThreads)
+INCLUDE(admCheckVDPAU)
+
+########################################
+# Check functions and includes
+########################################
+IF (NOT SYSTEM_HEADERS_CHECKED)
+	MESSAGE(STATUS "Checking system headers")
+	MESSAGE(STATUS "***********************")
+
+	INCLUDE(CheckIncludeFiles)
+	INCLUDE(CheckFunctionExists)
+
+	CHECK_FUNCTION_EXISTS(gettimeofday HAVE_GETTIMEOFDAY)
+
+	CHECK_INCLUDE_FILES(byteswap.h   HAVE_BYTESWAP_H)	# libavutil
+	CHECK_INCLUDE_FILES(inttypes.h   HAVE_INTTYPES_H)	# internal use, mpeg2enc, mplex
+	CHECK_INCLUDE_FILES(stdint.h     HAVE_STDINT_H)		# internal use, mpeg2enc, mplex
+	CHECK_INCLUDE_FILES(sys/types.h  HAVE_SYS_TYPES_H)	# mad, mpeg2enc
+	CHECK_INCLUDE_FILES(malloc.h     HAVE_MALLOC_H)		# libavcodec, libavutil, libpostproc, libswscale, mplex
+	SET(SYSTEM_HEADERS_CHECKED 1 CACHE BOOL "")
+	MARK_AS_ADVANCED(SYSTEM_HEADERS_CHECKED)
+
+	MESSAGE("")
+ENDIF (NOT SYSTEM_HEADERS_CHECKED)
+

Added: branches/avidemux_2.6_branch_mean/foreignBuilds/cross_mingw_core
===================================================================
--- branches/avidemux_2.6_branch_mean/foreignBuilds/cross_mingw_core	2009-08-03 16:33:52 UTC (rev 5200)
+++ branches/avidemux_2.6_branch_mean/foreignBuilds/cross_mingw_core	2009-08-03 17:10:30 UTC (rev 5201)
@@ -0,0 +1,22 @@
+#!/bin/bash
+export PKG_CONFIG_PATH=$MINGW/lib/pkgconfig
+export PKG_CONFIG_LIBDIR=$MINGW/lib/pkgconfig
+export CXXFLAGS="-I$MINGW/include -I/usr/i586-mingw32msvc/include"
+export CFLAGS="-I$MINGW/include -I/usr/i586-mingw32msvc/include"
+export CPPFLAGS="-I$MINGW/include -I/usr/i586-mingw32msvc/include"
+export LDFLAGS="-L$MINGW/lib -L/usr/i586-mingw32msvc/lib"
+export PATH=$MINGW/bin:$PATH
+pkg-config --list-all
+#export DEBUG="-DVERBOSE=1   -DCMAKE_BUILD_TYPE=Debug -G \"CodeBlocks - Unix Makefiles\"   "
+echo "<<<<<<<<<<<<Cross compiling core>>>>>>>>>>>>>>>"
+cmake   -DCROSS=$MINGW \
+        -DCMAKE_INCLUDE_PATH=$MINGW/include -DCMAKE_LIBRARY_PATH=$MINGW/lib \
+        -DCMAKE_INSTALL_PREFIX=$MINGW/Release \
+        -DCMAKE_C_COMPILER:STRING=$PREFIX-gcc \
+        -DCMAKE_CXX_COMPILER:STRING=$PREFIX-g++ \
+        -DCMAKE_LINKER:STRING=$PREFIX-ld \
+        -DCMAKE_AR:STRING=$PREFIX-ar \
+        -DCMAKE_SYSTEM_NAME:STRING=Windows \
+        $DEBUG\
+        -DAVIDEMUX_TOP_SOURCE_DIR="/home/fx/workspace/gitted/"  \
+        $TOP/avidemux_core

Added: branches/avidemux_2.6_branch_mean/foreignBuilds/cross_mingw_plugins
===================================================================
--- branches/avidemux_2.6_branch_mean/foreignBuilds/cross_mingw_plugins	2009-08-03 16:33:52 UTC (rev 5200)
+++ branches/avidemux_2.6_branch_mean/foreignBuilds/cross_mingw_plugins	2009-08-03 17:10:30 UTC (rev 5201)
@@ -0,0 +1,23 @@
+#!/bin/bash
+export PKG_CONFIG_PATH=$MINGW/lib/pkgconfig
+export PKG_CONFIG_LIBDIR=$MINGW/lib/pkgconfig
+export CXXFLAGS="-I$MINGW/include -I/usr/i586-mingw32msvc/include"
+export CFLAGS="-I$MINGW/include -I/usr/i586-mingw32msvc/include"
+export CPPFLAGS="-I$MINGW/include -I/usr/i586-mingw32msvc/include"
+export LDFLAGS="-L$MINGW/lib -L/usr/i586-mingw32msvc/lib"
+export PATH=$MINGW/bin:$PATH
+pkg-config --list-all
+#export DEBUG="-DVERBOSE=1   -DCMAKE_BUILD_TYPE=Debug -G \"CodeBlocks - Unix Makefiles\"   "
+echo "<<<<<<<<<<<<Cross compiling plugins>>>>>>>>>>>>>>>"
+cmake   -DCROSS=$MINGW \
+        -DCMAKE_INCLUDE_PATH=$MINGW/include -DCMAKE_LIBRARY_PATH=$MINGW/lib \
+        -DCMAKE_INSTALL_PREFIX=$MINGW/Release \
+        -DCMAKE_C_COMPILER:STRING=$PREFIX-gcc \
+        -DCMAKE_CXX_COMPILER:STRING=$PREFIX-g++ \
+        -DCMAKE_LINKER:STRING=$PREFIX-ld \
+        -DCMAKE_AR:STRING=$PREFIX-ar \
+        -DCMAKE_SYSTEM_NAME:STRING=Windows \
+        -DQT_HOME:STRING=$QT_HOME \
+         $DEBUG -G "CodeBlocks - Unix Makefiles"  \
+        -DAVIDEMUX_SOURCE_DIR="/home/fx/workspace/gitted/"  \
+        $TOP/avidemux_plugins

Added: branches/avidemux_2.6_branch_mean/foreignBuilds/cross_mingw_qt4
===================================================================
--- branches/avidemux_2.6_branch_mean/foreignBuilds/cross_mingw_qt4	2009-08-03 16:33:52 UTC (rev 5200)
+++ branches/avidemux_2.6_branch_mean/foreignBuilds/cross_mingw_qt4	2009-08-03 17:10:30 UTC (rev 5201)
@@ -0,0 +1,25 @@
+#!/bin/bash
+#
+export PKG_CONFIG_PATH=$MINGW/lib/pkgconfig
+export PKG_CONFIG_LIBDIR=$MINGW/lib/pkgconfig
+export CXXFLAGS="-I$MINGW/include -I/usr/i586-mingw32msvc/include"
+export CFLAGS="-I$MINGW/include -I/usr/i586-mingw32msvc/include"
+export CPPFLAGS="-I$MINGW/include -I/usr/i586-mingw32msvc/include"
+export LDFLAGS="-L$MINGW/lib -L/usr/i586-mingw32msvc/lib"
+export PATH=$MINGW/bin:$PATH
+pkg-config --list-all
+#export DEBUG="-DVERBOSE=1   -DCMAKE_BUILD_TYPE=Debug -G \"CodeBlocks - Unix Makefiles\"   "
+echo "<<<<<<<<<<<<Cross compiling core>>>>>>>>>>>>>>>"
+cmake   -DCROSS=$MINGW \
+        -DCMAKE_INCLUDE_PATH=$MINGW/include -DCMAKE_LIBRARY_PATH=$MINGW/lib \
+        -DCMAKE_INSTALL_PREFIX=$MINGW/Release \
+        -DCMAKE_C_COMPILER:STRING=$PREFIX-gcc \
+        -DCMAKE_CXX_COMPILER:STRING=$PREFIX-g++ \
+        -DCMAKE_LINKER:STRING=$PREFIX-ld \
+        -DCMAKE_AR:STRING=$PREFIX-ar \
+        -DCMAKE_SYSTEM_NAME:STRING=Windows \
+        -DQT_HOME:STRING=$QT_HOME \
+        $DEBUG \
+         -G "CodeBlocks - Unix Makefiles"  \
+        -DAVIDEMUX_TOP_SOURCE_DIR="/home/fx/workspace/gitted/"  \
+        $TOP/avidemux/qt4



From mean at mail.berlios.de  Mon Aug  3 20:02:18 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Mon, 3 Aug 2009 20:02:18 +0200
Subject: [Avidemux-svn-commit] r5202 - in branches/avidemux_2.6_branch_mean:
	avidemux avidemux/gtk avidemux/qt4 avidemux_core
	avidemux_plugins cmake foreignBuilds
Message-ID: <200908031802.n73I2Icx001205@sheep.berlios.de>

Author: mean
Date: 2009-08-03 20:02:17 +0200 (Mon, 03 Aug 2009)
New Revision: 5202

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/commonCmakeApplication.cmake
   branches/avidemux_2.6_branch_mean/avidemux/gtk/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/avidemux/qt4/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/avidemux_core/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/avidemux_plugins/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/cmake/admMainChecks.cmake
   branches/avidemux_2.6_branch_mean/foreignBuilds/cross_mingw_core
   branches/avidemux_2.6_branch_mean/foreignBuilds/cross_mingw_plugins
   branches/avidemux_2.6_branch_mean/foreignBuilds/cross_mingw_qt4
Log:
[build] remove deps to cmake 2.6.3

Modified: branches/avidemux_2.6_branch_mean/avidemux/commonCmakeApplication.cmake
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/commonCmakeApplication.cmake	2009-08-03 17:10:30 UTC (rev 5201)
+++ branches/avidemux_2.6_branch_mean/avidemux/commonCmakeApplication.cmake	2009-08-03 18:02:17 UTC (rev 5202)
@@ -4,7 +4,7 @@
 if (COMMAND cmake_policy)
 	cmake_policy(VERSION 2.4)
 	cmake_policy(SET CMP0003 NEW)
-	cmake_policy(SET CMP0011 OLD)
+	#cmake_policy(SET CMP0011 OLD)
 endif (COMMAND cmake_policy)
 ########################################
 # Definitions and Includes

Modified: branches/avidemux_2.6_branch_mean/avidemux/gtk/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/gtk/CMakeLists.txt	2009-08-03 17:10:30 UTC (rev 5201)
+++ branches/avidemux_2.6_branch_mean/avidemux/gtk/CMakeLists.txt	2009-08-03 18:02:17 UTC (rev 5202)
@@ -7,7 +7,7 @@
 if (COMMAND cmake_policy)
 	cmake_policy(VERSION 2.4)
 	cmake_policy(SET CMP0003 NEW)
-	cmake_policy(SET CMP0011 OLD)
+	#cmake_policy(SET CMP0011 OLD)
 endif (COMMAND cmake_policy)
 SET( ADM_PROJECT Avidemux_gtk)
 

Modified: branches/avidemux_2.6_branch_mean/avidemux/qt4/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/qt4/CMakeLists.txt	2009-08-03 17:10:30 UTC (rev 5201)
+++ branches/avidemux_2.6_branch_mean/avidemux/qt4/CMakeLists.txt	2009-08-03 18:02:17 UTC (rev 5202)
@@ -7,7 +7,7 @@
 if (COMMAND cmake_policy)
 	cmake_policy(VERSION 2.4)
 	cmake_policy(SET CMP0003 NEW)
-	cmake_policy(SET CMP0011 OLD)
+	#cmake_policy(SET CMP0011 OLD)
 endif (COMMAND cmake_policy)
 SET( ADM_PROJECT Avidemux_qt4)
 # Use old behaviour

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/CMakeLists.txt	2009-08-03 17:10:30 UTC (rev 5201)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/CMakeLists.txt	2009-08-03 18:02:17 UTC (rev 5202)
@@ -6,7 +6,7 @@
 if (COMMAND cmake_policy)
 	cmake_policy(VERSION 2.4)
 	cmake_policy(SET CMP0003 NEW)
-	cmake_policy(SET CMP0011 OLD)
+	#cmake_policy(SET CMP0011 OLD)
 endif (COMMAND cmake_policy)
 
 # need for shared cmake script between avidemux & plugins
@@ -15,7 +15,7 @@
 SET(AVIDEMUX_CORE_BUILD_DIR ${CMAKE_BINARY_DIR})
 
 SET(CMAKE_MODULE_PATH "${AVIDEMUX_TOP_SOURCE_DIR}/cmake" "${CMAKE_MODULE_PATH}")
-
+SET(ADM_PROJECT admCore)
 include(admMainChecks)
 ########################################
 # VDPAU

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/CMakeLists.txt	2009-08-03 17:10:30 UTC (rev 5201)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/CMakeLists.txt	2009-08-03 18:02:17 UTC (rev 5202)
@@ -3,7 +3,7 @@
 MESSAGE("#####################################")
 MESSAGE("")
 
-PROJECT(AdmPlugins)
+SET(ADM_PROJECT AdmPlugins)
 SET(PLUGINS TRUE)
 CMAKE_MINIMUM_REQUIRED(VERSION 2.4.7 FATAL_ERROR)
 ########################################

Modified: branches/avidemux_2.6_branch_mean/cmake/admMainChecks.cmake
===================================================================
--- branches/avidemux_2.6_branch_mean/cmake/admMainChecks.cmake	2009-08-03 17:10:30 UTC (rev 5201)
+++ branches/avidemux_2.6_branch_mean/cmake/admMainChecks.cmake	2009-08-03 18:02:17 UTC (rev 5202)
@@ -20,7 +20,7 @@
 MESSAGE(STATUS "Top Source dir is ${AVIDEMUX_TOP_SOURCE_DIR}")
 MESSAGE("")
 
-PROJECT(Avidemux_core)
+PROJECT(${ADM_PROJECT})
 
 IF (${Avidemux_SOURCE_DIR} MATCHES ${Avidemux_BINARY_DIR})
 	MESSAGE("Please do an out-of-tree build:")

Modified: branches/avidemux_2.6_branch_mean/foreignBuilds/cross_mingw_core
===================================================================
--- branches/avidemux_2.6_branch_mean/foreignBuilds/cross_mingw_core	2009-08-03 17:10:30 UTC (rev 5201)
+++ branches/avidemux_2.6_branch_mean/foreignBuilds/cross_mingw_core	2009-08-03 18:02:17 UTC (rev 5202)
@@ -18,5 +18,5 @@
         -DCMAKE_AR:STRING=$PREFIX-ar \
         -DCMAKE_SYSTEM_NAME:STRING=Windows \
         $DEBUG\
-        -DAVIDEMUX_TOP_SOURCE_DIR="/home/fx/workspace/gitted/"  \
+        -DAVIDEMUX_TOP_SOURCE_DIR="$TOP"  \
         $TOP/avidemux_core

Modified: branches/avidemux_2.6_branch_mean/foreignBuilds/cross_mingw_plugins
===================================================================
--- branches/avidemux_2.6_branch_mean/foreignBuilds/cross_mingw_plugins	2009-08-03 17:10:30 UTC (rev 5201)
+++ branches/avidemux_2.6_branch_mean/foreignBuilds/cross_mingw_plugins	2009-08-03 18:02:17 UTC (rev 5202)
@@ -19,5 +19,5 @@
         -DCMAKE_SYSTEM_NAME:STRING=Windows \
         -DQT_HOME:STRING=$QT_HOME \
          $DEBUG -G "CodeBlocks - Unix Makefiles"  \
-        -DAVIDEMUX_SOURCE_DIR="/home/fx/workspace/gitted/"  \
+        -DAVIDEMUX_SOURCE_DIR="$TOP"  \
         $TOP/avidemux_plugins

Modified: branches/avidemux_2.6_branch_mean/foreignBuilds/cross_mingw_qt4
===================================================================
--- branches/avidemux_2.6_branch_mean/foreignBuilds/cross_mingw_qt4	2009-08-03 17:10:30 UTC (rev 5201)
+++ branches/avidemux_2.6_branch_mean/foreignBuilds/cross_mingw_qt4	2009-08-03 18:02:17 UTC (rev 5202)
@@ -21,5 +21,5 @@
         -DQT_HOME:STRING=$QT_HOME \
         $DEBUG \
          -G "CodeBlocks - Unix Makefiles"  \
-        -DAVIDEMUX_TOP_SOURCE_DIR="/home/fx/workspace/gitted/"  \
+        -DAVIDEMUX_TOP_SOURCE_DIR="$TOP"  \
         $TOP/avidemux/qt4



From gruntster at mail.berlios.de  Mon Aug  3 20:31:55 2009
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Mon, 3 Aug 2009 20:31:55 +0200
Subject: [Avidemux-svn-commit] r5203 -
	branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264
Message-ID: <200908031831.n73IVtVs009003@sheep.berlios.de>

Author: gruntster
Date: 2009-08-03 20:31:49 +0200 (Mon, 03 Aug 2009)
New Revision: 5203

Modified:
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/guiHelper.cpp
Log:
[x264] gcc 4.4 fix

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/guiHelper.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/guiHelper.cpp	2009-08-03 18:02:17 UTC (rev 5202)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/guiHelper.cpp	2009-08-03 18:31:49 UTC (rev 5203)
@@ -62,8 +62,8 @@
 
 int x264_cqm_parse_jmlist(const char *buf, const char *name, uint8_t *cqm, uint8_t *defaultMatrix, int length)
 {
-	char *p;
-	char *nextvar;
+	const char *p;
+	const char *nextvar;
 	int i;
 
 	p = strstr(buf, name);



From gruntster at mail.berlios.de  Mon Aug  3 20:39:16 2009
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Mon, 3 Aug 2009 20:39:16 +0200
Subject: [Avidemux-svn-commit] r5204 - in
	branches/avidemux_2.5_branch_gruntster/cmake: . patches
Message-ID: <200908031839.n73IdGr2011422@sheep.berlios.de>

Author: gruntster
Date: 2009-08-03 20:39:09 +0200 (Mon, 03 Aug 2009)
New Revision: 5204

Modified:
   branches/avidemux_2.5_branch_gruntster/cmake/admFFmpegBuild.cmake
   branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_h263dec.c.patch
   branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_h264.c.patch
Log:
[ffmpeg] update FFmpeg to r19575 & libswscale to r29474

Modified: branches/avidemux_2.5_branch_gruntster/cmake/admFFmpegBuild.cmake
===================================================================
--- branches/avidemux_2.5_branch_gruntster/cmake/admFFmpegBuild.cmake	2009-08-03 18:31:49 UTC (rev 5203)
+++ branches/avidemux_2.5_branch_gruntster/cmake/admFFmpegBuild.cmake	2009-08-03 18:39:09 UTC (rev 5204)
@@ -1,7 +1,7 @@
 include(admFFmpegUtil)
 
-set(FFMPEG_VERSION 19285)	# http://git.ffmpeg.org/?p=ffmpeg;a=snapshot;h=a6262ab9bba80693bedf73a7252415af4e0ef463;sf=tgz
-set(SWSCALE_VERSION 29406)	# http://git.ffmpeg.org/?p=libswscale;a=snapshot;h=e52bf9389e0e77a63c3ee8d3f2ea67b8309207e3;sf=tgz
+set(FFMPEG_VERSION 19575)	# http://git.ffmpeg.org/?p=ffmpeg;a=snapshot;h=d3fb9f5983437e7379acc552d8d82a4704eb6167;sf=tgz
+set(SWSCALE_VERSION 29474)	# http://git.ffmpeg.org/?p=libswscale;a=snapshot;h=b1af9a271e6f587dbcd2b19dbceb4d2ec8eace7e;sf=tgz
 
 set(LIBRARY_SOURCE_DIR "${CMAKE_SOURCE_DIR}/avidemux/ADM_libraries")
 set(FFMPEG_SOURCE_DIR "${LIBRARY_SOURCE_DIR}/ffmpeg")

Modified: branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_h263dec.c.patch
===================================================================
--- branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_h263dec.c.patch	2009-08-03 18:31:49 UTC (rev 5203)
+++ branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_h263dec.c.patch	2009-08-03 18:39:09 UTC (rev 5204)
@@ -1,5 +1,5 @@
-*** libavcodec/h263dec.c.old	Mon May 25 14:32:17 2009
---- libavcodec/h263dec.c	Mon May 25 14:32:17 2009
+*** libavcodec/h263dec.c.old	Sun Aug  2 10:23:00 2009
+--- libavcodec/h263dec.c	Sun Aug  2 10:22:59 2009
 ***************
 *** 123,128 ****
 --- 123,145 ----
@@ -27,8 +27,8 @@
   av_cold int ff_h263_decode_end(AVCodecContext *avctx)
   {
 ***************
-*** 423,428 ****
---- 440,451 ----
+*** 418,423 ****
+--- 435,446 ----
       } else {
           ret = h263_decode_picture_header(s);
       }
@@ -42,8 +42,8 @@
       if(ret==FRAME_SKIPPED) return get_consumed_bytes(s, buf_size);
   
 ***************
-*** 713,718 ****
---- 736,749 ----
+*** 704,709 ****
+--- 727,740 ----
   
   assert(s->current_picture.pict_type == s->current_picture_ptr->pict_type);
   assert(s->current_picture.pict_type == s->pict_type);

Modified: branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_h264.c.patch
===================================================================
--- branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_h264.c.patch	2009-08-03 18:31:49 UTC (rev 5203)
+++ branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_h264.c.patch	2009-08-03 18:39:09 UTC (rev 5204)
@@ -1,8 +1,8 @@
-*** libavcodec/h264.c.old	Sat Jun 27 18:45:10 2009
---- libavcodec/h264.c	Sat Jun 27 18:45:09 2009
+*** libavcodec/h264.c.old	Sun Aug  2 10:23:00 2009
+--- libavcodec/h264.c	Sun Aug  2 10:23:00 2009
 ***************
-*** 8151,8156 ****
---- 8151,8167 ----
+*** 8155,8160 ****
+--- 8155,8171 ----
       return 0;
   }
   



From gruntster at mail.berlios.de  Mon Aug  3 21:45:23 2009
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Mon, 3 Aug 2009 21:45:23 +0200
Subject: [Avidemux-svn-commit] r5205 -
	branches/avidemux_2.5_branch_gruntster/avidemux/ADM_codecs
Message-ID: <200908031945.n73JjN9j022681@sheep.berlios.de>

Author: gruntster
Date: 2009-08-03 21:44:57 +0200 (Mon, 03 Aug 2009)
New Revision: 5205

Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_codecs/ADM_codecs.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_codecs/ADM_ffmp43.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_codecs/ADM_ffmp43.h
Log:
[fraps] add support for fraps video decoder

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_codecs/ADM_codecs.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_codecs/ADM_codecs.cpp	2009-08-03 18:39:09 UTC (rev 5204)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_codecs/ADM_codecs.cpp	2009-08-03 19:44:57 UTC (rev 5205)
@@ -316,6 +316,10 @@
 
       return (decoders *) (new decoderFFH264 (w, h, extraLen, extraData,1));
     }
+  if (fourCC::check(fcc, (uint8_t *)"FPS1"))
+  {
+	  return (decoders *)(new decoderFraps(w, h));
+  }
 #endif
 
 /*

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_codecs/ADM_ffmp43.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_codecs/ADM_ffmp43.cpp	2009-08-03 18:39:09 UTC (rev 5204)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_codecs/ADM_ffmp43.cpp	2009-08-03 19:44:57 UTC (rev 5205)
@@ -717,6 +717,10 @@
   WRAP_Open (CODEC_ID_MJPEGB);
   //_context->codec_id=CODEC_ID_AMV;
 }
+decoderFraps::decoderFraps(uint32_t w, uint32_t h) : decoderFF (w, h)
+{
+  WRAP_Open (CODEC_ID_FRAPS);
+}
 decoderFFDVBSub::decoderFFDVBSub (uint32_t w, uint32_t h, uint32_t l, uint8_t * d):decoderFF (w,	   h)
 {
   _context->sub_id=1;

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_codecs/ADM_ffmp43.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_codecs/ADM_ffmp43.h	2009-08-03 18:39:09 UTC (rev 5204)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_codecs/ADM_ffmp43.h	2009-08-03 19:44:57 UTC (rev 5205)
@@ -365,4 +365,9 @@
   decoderFFMjpegB (uint32_t w, uint32_t h, uint32_t l, uint8_t * d);
 };
 
+class decoderFraps : public decoderFF
+{
+public:
+	decoderFraps(uint32_t w, uint32_t h);
+};
 #endif



From mean at mail.berlios.de  Tue Aug  4 20:30:28 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Tue, 4 Aug 2009 20:30:28 +0200
Subject: [Avidemux-svn-commit] r5206 -
	branches/avidemux_2.6_branch_mean/avidemux/common
Message-ID: <200908041830.n74IUSx3022001@sheep.berlios.de>

Author: mean
Date: 2009-08-04 20:30:28 +0200 (Tue, 04 Aug 2009)
New Revision: 5206

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/gui_audio.cpp
Log:
[UI] Add string convert from WAV_EAC3 to E-AC3 to display

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/gui_audio.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/gui_audio.cpp	2009-08-03 19:44:57 UTC (rev 5205)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/gui_audio.cpp	2009-08-04 18:30:28 UTC (rev 5206)
@@ -19,6 +19,7 @@
               case WAV_WMA:  return QT_TR_NOOP("WMA");
               case WAV_LPCM: return QT_TR_NOOP("LPCM");
               case WAV_AC3:  return QT_TR_NOOP("AC3");
+              case WAV_EAC3:  return QT_TR_NOOP("E-AC3");
               case WAV_OGG: return QT_TR_NOOP("Ogg Vorbis");
               case WAV_MP4: return QT_TR_NOOP("MP4");
               case WAV_AAC: return QT_TR_NOOP("AAC");
@@ -30,4 +31,4 @@
               case WAV_8BITS_UNSIGNED:return QT_TR_NOOP("8-bit PCM");
       }
       return QT_TR_NOOP("Unknown codec");
-}
\ No newline at end of file
+}



From mean at mail.berlios.de  Tue Aug  4 20:30:30 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Tue, 4 Aug 2009 20:30:30 +0200
Subject: [Avidemux-svn-commit] r5207 -
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/MpegTS
Message-ID: <200908041830.n74IUUQ8022012@sheep.berlios.de>

Author: mean
Date: 2009-08-04 20:30:29 +0200 (Tue, 04 Aug 2009)
New Revision: 5207

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/MpegTS/ADM_tsAudioProbe.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/MpegTS/ADM_tsPatPmt.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/MpegTS/ADM_tsPatPmt.h
Log:
[TS/Demuxer] Add partial support for EAC3 in TS Streams

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/MpegTS/ADM_tsAudioProbe.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/MpegTS/ADM_tsAudioProbe.cpp	2009-08-04 18:30:28 UTC (rev 5206)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/MpegTS/ADM_tsAudioProbe.cpp	2009-08-04 18:30:29 UTC (rev 5207)
@@ -51,7 +51,8 @@
         
         
         // dont even try if it is not audio
-        if(trackInfo->trackType!=ADM_TS_MPEG_AUDIO &&trackInfo->trackType!=ADM_TS_AC3) return false;
+        if(trackInfo->trackType!=ADM_TS_MPEG_AUDIO &&trackInfo->trackType!=ADM_TS_AC3
+                && trackInfo->trackType!=ADM_TS_EAC3) return false;
 
         // Go back where we were
         p->changePid(trackInfo->esId); 
@@ -89,6 +90,25 @@
                                 trackInfo->wav.byterate=(br);
                                 break;
                             }
+            case ADM_TS_EAC3: 
+                            {
+                                trackInfo->wav.encoding=WAV_EAC3;
+#if 0
+                                if(!ADM_AC3GetInfo(audioBuffer, rd, &fq, &br, &chan,&off))
+                                {
+                                        printf("[PsProbeAudio] Failed to get info on track :%x\n",trackInfo->esId);
+                                        goto er;
+                                }
+                                trackInfo->wav.frequency=fq;
+                                trackInfo->wav.channels=chan;
+                                trackInfo->wav.byterate=(br);
+#else
+                                trackInfo->wav.frequency=48000;
+                                trackInfo->wav.channels=2;
+                                trackInfo->wav.byterate=128000>>3;
+#endif
+                                break;
+                            }
                             
             default:
                         printf("[tsAudioProbe] Unsupported audio format pid %d 0x%x\n",trackInfo->esId,trackInfo->esId);

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/MpegTS/ADM_tsPatPmt.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/MpegTS/ADM_tsPatPmt.cpp	2009-08-04 18:30:28 UTC (rev 5206)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/MpegTS/ADM_tsPatPmt.cpp	2009-08-04 18:30:29 UTC (rev 5207)
@@ -151,7 +151,7 @@
         for(int i=0;i<list.size();i++)
         {
             ADM_TS_TRACK_TYPE type=list[i].trackType;
-            if(type==ADM_TS_MPEG_AUDIO || type==ADM_TS_AC3 || type==ADM_TS_AAC)
+            if(type==ADM_TS_MPEG_AUDIO || type==ADM_TS_AC3 || type==ADM_TS_AAC || type==ADM_TS_EAC3)
             {
                 TSpacketInfo pkt;
                 t->setPos(0);
@@ -220,10 +220,30 @@
 
             size&=0xfff;
             pid&=0x1fff;
+            uint8_t *base=r+5;
             r+=size+5;
             packLen-=5+size;
             printf("[PMT]          Type=0x%x pid=%x size=%d\n",type,pid,size);
             const char *str;
+            
+            if(type==6) // Private data
+            {
+                
+                uint8_t *head=base;
+                uint8_t *tail=r;
+                while(head<tail)
+                {
+                    uint8_t tag=head[0];
+                    uint8_t tag_len=head[1];
+                    printf("[PMT]  Tag 0x%x , len %d, ",tag,tag_len);
+                    for(int i=0;i<tag_len;i++) printf(" %02x",head[2+i]);
+                    printf("\n");
+                    head+=2+tag_len;
+                    if(tag==0x7A) type=0x84;
+                    if(tag==0x6A) type=0x81;
+                }
+
+            }
             ADM_TS_TRACK_TYPE trackType=EsType(type,&str);;
             if(trackType!=ADM_TS_UNKNOWN) 
             {
@@ -233,8 +253,11 @@
                     printf("[PMT]  Adding pid 0x%x (%d) , type %s\n",pid,pid,str);
                     list->push_back(trk2);
             }
+            
            
         }
+        
+        printf("[PMT] Left :%d bytes\n",packLen);
         if(trk.trackType!=ADM_TS_UNKNOWN) list->push_back(trk);
         return true;
        }
@@ -255,6 +278,7 @@
              //   case 0x10:        *streamType=ADM_STREAM_MPEG4;return "MP4 Video";
                 case 0x1B:  *str= "H264 Video";return ADM_TS_H264;break;
                 case 0x81:  *str= "AC3 (Not sure)";return ADM_TS_AC3;break;
+                case 0x84:  *str= "E-AC3 (Not sure)";return ADM_TS_EAC3;break;
                 default : break;
     }
     return ADM_TS_UNKNOWN;
@@ -312,7 +336,7 @@
                         case 0x56: printf("Teletext");break;
                         case 0x59: printf("DVB subtitles");break;
                         case 0x7b: printf("DTS Descriptor");break;
-                        case 0x7a:
+                        case 0x7a: printf("EAC3 Descriptor");break;
                         case 0x6a: printf("AC3 Descriptor");break;
                         default : printf("unknown");break;
                     }

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/MpegTS/ADM_tsPatPmt.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/MpegTS/ADM_tsPatPmt.h	2009-08-04 18:30:28 UTC (rev 5206)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/MpegTS/ADM_tsPatPmt.h	2009-08-04 18:30:29 UTC (rev 5207)
@@ -29,7 +29,8 @@
     ADM_TS_H264,
     ADM_TS_MPEG_AUDIO=10,
     ADM_TS_AC3,
-    ADM_TS_AAC
+    ADM_TS_AAC,
+    ADM_TS_EAC3,
 }ADM_TS_TRACK_TYPE;
 /**
     \typedef ADM_TS_TRACK



From mean at mail.berlios.de  Tue Aug  4 20:31:22 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Tue, 4 Aug 2009 20:31:22 +0200
Subject: [Avidemux-svn-commit] r5209 - branches/avidemux_2.6_branch_mean
Message-ID: <200908041831.n74IVMxw022121@sheep.berlios.de>

Author: mean
Date: 2009-08-04 20:31:22 +0200 (Tue, 04 Aug 2009)
New Revision: 5209

Modified:
   branches/avidemux_2.6_branch_mean/README
Log:
[Dummy] Dummy commit to see if autofetch works, refs #16

Modified: branches/avidemux_2.6_branch_mean/README
===================================================================
--- branches/avidemux_2.6_branch_mean/README	2009-08-04 18:30:32 UTC (rev 5208)
+++ branches/avidemux_2.6_branch_mean/README	2009-08-04 18:31:22 UTC (rev 5209)
@@ -1 +1,2 @@
+#:x
 



From gruntster at mail.berlios.de  Wed Aug  5 10:19:30 2009
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Wed, 5 Aug 2009 10:19:30 +0200
Subject: [Avidemux-svn-commit] r5210 -
	branches/avidemux_2.5_branch_gruntster/avidemux/ADM_codecs
Message-ID: <200908050819.n758JUcW021776@sheep.berlios.de>

Author: gruntster
Date: 2009-08-05 10:19:26 +0200 (Wed, 05 Aug 2009)
New Revision: 5210

Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_codecs/ADM_ffmp43.cpp
Log:
[vidDec] improve null frame check (fixes #15)

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_codecs/ADM_ffmp43.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_codecs/ADM_ffmp43.cpp	2009-08-04 18:31:22 UTC (rev 5209)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_codecs/ADM_ffmp43.cpp	2009-08-05 08:19:26 UTC (rev 5210)
@@ -328,7 +328,7 @@
       printf ("\n[lavc] null frame\n");
       {
 	// search the last image
-	if (_context->coded_frame && _context->coded_frame->data)
+	if (_context->coded_frame && _context->coded_frame->data && _context->coded_frame->linesize[0])
 	  {
 	    clonePic (_context->coded_frame, out);
 	  }



From mean at mail.berlios.de  Wed Aug  5 20:07:55 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Wed, 5 Aug 2009 20:07:55 +0200
Subject: [Avidemux-svn-commit] r5211 -
	branches/avidemux_2.6_branch_mean/avidemux/common
Message-ID: <200908051807.n75I7tQA029890@sheep.berlios.de>

Author: mean
Date: 2009-08-05 20:07:54 +0200 (Wed, 05 Aug 2009)
New Revision: 5211

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/gui_save.cpp
Log:
[ui/audio] Partially fix audio/save, refs # 18

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/gui_save.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/gui_save.cpp	2009-08-05 08:19:26 UTC (rev 5210)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/gui_save.cpp	2009-08-05 18:07:54 UTC (rev 5211)
@@ -108,8 +108,12 @@
 
 int A_audioSave(char *name)
 {
-	if (!currentaudiostream)	// yes it is checked 2 times so what ?
-	return 0;
+    ADM_audioStream *stream;
+    if(false==video_body->getAudioStream( &stream)) 
+    {
+        printf("[A_audioSave] No stream\n");
+        return 0;
+    }
 	if (audioProcessMode())
 	{
 		// if we get here, either not compressed
@@ -265,9 +269,13 @@
 
 #define ONE_STRIKE (64*1024)
   uint8_t *buffer=NULL;
+  ADM_audioStream *stream;
+  if(false==video_body->getAudioStream( &stream)) 
+    {
+        printf("[A_audioSave] No stream\n");
+        return ;
+    }
 
-  if (!currentaudiostream)
-    return;
 
   out = fopen (name, "wb");
   if (!out) return;
@@ -287,13 +295,13 @@
    duration=timeEnd-timeStart;
    if(duration<0) 
     {
-            currentaudiostream->goToTime (timeEnd);
+            stream->goToTime (timeEnd);
             duration=-duration;
     }else
     {
-            currentaudiostream->goToTime (timeStart);
+            stream->goToTime (timeStart);
     }
-   duration*=currentaudiostream->getInfo()->frequency;
+   duration*=stream->getInfo()->frequency;
    duration/=1000000; // in seconds to have samples
    tgt_sample=(uint64_t)floor(duration);
    printf("[saveAudio] Start time :%"LLU" ms\n",timeStart/1000);
@@ -307,7 +315,7 @@
    buffer=new uint8_t[ONE_STRIKE*2];
    while (1)
     {
-    	if(!currentaudiostream->getPacket(buffer+hold,&len,ONE_STRIKE,&sample,&dts)) break;
+    	if(!stream->getPacket(buffer+hold,&len,ONE_STRIKE,&sample,&dts)) break;
         hold+=len;
         written+=len;
         cur_sample+=sample;



From mean at mail.berlios.de  Wed Aug  5 20:07:57 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Wed, 5 Aug 2009 20:07:57 +0200
Subject: [Avidemux-svn-commit] r5212 - in
	branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreAudioParser:
	include src
Message-ID: <200908051807.n75I7vWN029901@sheep.berlios.de>

Author: mean
Date: 2009-08-05 20:07:56 +0200 (Wed, 05 Aug 2009)
New Revision: 5212

Added:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreAudioParser/include/ADM_eac3info.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreAudioParser/src/ADM_eac3info.cpp
Modified:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreAudioParser/src/CMakeLists.txt
Log:
[audio/parser] Basic eac3 parser, refs #16

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreAudioParser/include/ADM_eac3info.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreAudioParser/include/ADM_eac3info.h	2009-08-05 18:07:54 UTC (rev 5211)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreAudioParser/include/ADM_eac3info.h	2009-08-05 18:07:56 UTC (rev 5212)
@@ -0,0 +1,14 @@
+/**
+
+        \file ADM_eac3info
+        \brief extract info from EAC3/A52B/DD+ streams
+        Author: mean <fixounet at free.fr>, (C) 2009
+        Code very derived from ffmpeg (tables etc...)
+
+*/
+
+#ifndef ADM_EAC3INFO_H
+#define ADM_EAC3INFO_H
+bool     ADM_a52b_syncinfo (uint8_t * buf, int * flags, int * sample_rate, int * bit_rate);
+bool     ADM_EAC3GetInfo(uint8_t *buf, uint32_t len, uint32_t *fq, uint32_t *byterate, uint32_t *chan,uint32_t *syncoff);
+#endif //ADM_EAC3INFO_H
\ No newline at end of file

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreAudioParser/src/ADM_eac3info.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreAudioParser/src/ADM_eac3info.cpp	2009-08-05 18:07:54 UTC (rev 5211)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreAudioParser/src/ADM_eac3info.cpp	2009-08-05 18:07:56 UTC (rev 5212)
@@ -0,0 +1,143 @@
+/**
+
+        \file ADM_eac3info
+        \brief extract info from EAC3/A52B/DD+ streams
+        Author: mean <fixounet at free.fr>, (C) 2009
+        Code very derived from ffmpeg (tables etc...)
+
+*/
+
+#include "ADM_default.h"
+
+#include "ADM_eac3info.h"
+/**
+ * Possible frame sizes.
+ * from ATSC A/52 Table 5.18 Frame Size Code Table.
+ * Borrowed from ffmpeg
+ */
+const uint16_t ff_ac3_frame_size_tab[38][3] = {
+    { 64,   69,   96   },
+    { 64,   70,   96   },
+    { 80,   87,   120  },
+    { 80,   88,   120  },
+    { 96,   104,  144  },
+    { 96,   105,  144  },
+    { 112,  121,  168  },
+    { 112,  122,  168  },
+    { 128,  139,  192  },
+    { 128,  140,  192  },
+    { 160,  174,  240  },
+    { 160,  175,  240  },
+    { 192,  208,  288  },
+    { 192,  209,  288  },
+    { 224,  243,  336  },
+    { 224,  244,  336  },
+    { 256,  278,  384  },
+    { 256,  279,  384  },
+    { 320,  348,  480  },
+    { 320,  349,  480  },
+    { 384,  417,  576  },
+    { 384,  418,  576  },
+    { 448,  487,  672  },
+    { 448,  488,  672  },
+    { 512,  557,  768  },
+    { 512,  558,  768  },
+    { 640,  696,  960  },
+    { 640,  697,  960  },
+    { 768,  835,  1152 },
+    { 768,  836,  1152 },
+    { 896,  975,  1344 },
+    { 896,  976,  1344 },
+    { 1024, 1114, 1536 },
+    { 1024, 1115, 1536 },
+    { 1152, 1253, 1728 },
+    { 1152, 1254, 1728 },
+    { 1280, 1393, 1920 },
+    { 1280, 1394, 1920 },
+};
+// Borrowed from ffmpeg
+const uint16_t ff_ac3_bitrate_tab[19] = {
+    32, 40, 48, 56, 64, 80, 96, 112, 128,
+    160, 192, 224, 256, 320, 384, 448, 512, 576, 640
+};
+
+/**
+    \fn ADM_a52b_syncinfo
+*/
+bool ADM_a52b_syncinfo (uint8_t * buf, int * flags, int * sample_rate, int * bit_rate)
+{
+    int frmsizecod;
+    int bitrate;
+    int half;
+    int acmod;
+
+    if ((buf[0] != 0x0b) || (buf[1] != 0x77))	/* syncword */
+        return false;
+
+// 0B77   16 01
+// CRC16  16 23
+// fscod  2  4
+// frmsiz 6  4
+
+    int fscod=buf[0]>>6;
+    int frmsize=buf[0]&0x3F;
+    if(frmsize>=38) return 0;
+
+    if(fscod==3) return 0;
+    switch(fscod)
+    {
+        case 0: *sample_rate=48000;break;
+        case 1: *sample_rate=44100;break;
+        case 2: *sample_rate=32000;break;
+        default : return 0;
+    }
+    *bit_rate=ff_ac3_frame_size_tab[frmsize][fscod]*1000;
+    return 1;
+    
+}
+/**
+    \fn ADM_EAC3GetInfo
+*/
+bool  ADM_EAC3GetInfo(uint8_t *buf, uint32_t len, uint32_t *fq, uint32_t *byterate, uint32_t *chan,uint32_t *syncoff)
+{
+uint32_t l;
+int ibr,ifq,flags;
+uint32_t of=0;
+
+	*syncoff=of=0;
+     	printf("\n Syncing on %d \n",len);
+	// Search for startcode
+	// 0x0b 0x77
+	while(1)
+	{
+		 if(len<7)
+		 {
+		 	printf("Not enough info to find a52 syncword\n");
+		 	return 0;
+		 }
+		 if( *buf!=0x0b || *(buf+1)!=0x77)
+		 {
+		 	len--;
+			buf++;
+			of++;
+			continue;
+		 }
+		 // Try to get syncinfo
+	        l=ADM_a52b_syncinfo (buf,&flags, &ifq, &ibr);
+		if(!l)
+		{
+			len--;
+			buf++;
+			of++;
+			printf("Sync failed..continuing\n");
+			continue;
+		}
+		printf("Sync found at offset %"LU"\n",of);
+		*syncoff=of;
+		*fq=(uint32_t)ifq;
+		*byterate=(uint32_t)ibr>>3;
+
+		return 1;
+	}
+	return 0;
+}

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreAudioParser/src/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreAudioParser/src/CMakeLists.txt	2009-08-05 18:07:54 UTC (rev 5211)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreAudioParser/src/CMakeLists.txt	2009-08-05 18:07:56 UTC (rev 5212)
@@ -4,6 +4,7 @@
 ADM_mp3info.cpp  
 ADM_a52info.cpp 
 ADM_dcainfo.cpp  
+ADM_eac3info.cpp
 )	
 #*************************************************
 ADD_DEFINITIONS( "-DADM_LEGACY_PROGGY")



From mean at mail.berlios.de  Wed Aug  5 20:07:58 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Wed, 5 Aug 2009 20:07:58 +0200
Subject: [Avidemux-svn-commit] r5213 -
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/MpegTS
Message-ID: <200908051807.n75I7wK7029911@sheep.berlios.de>

Author: mean
Date: 2009-08-05 20:07:58 +0200 (Wed, 05 Aug 2009)
New Revision: 5213

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/MpegTS/ADM_tsAudioProbe.cpp
Log:
[TS] Use eac3 parser get info, refs #16

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/MpegTS/ADM_tsAudioProbe.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/MpegTS/ADM_tsAudioProbe.cpp	2009-08-05 18:07:56 UTC (rev 5212)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/MpegTS/ADM_tsAudioProbe.cpp	2009-08-05 18:07:58 UTC (rev 5213)
@@ -21,6 +21,7 @@
 #include "ADM_tsAudioProbe.h"
 //
 #include "ADM_a52info.h"
+#include "ADM_eac3info.h"
 #include "ADM_mp3info.h"
 #include "ADM_dcainfo.h"
 // Number of video packet seen to be enough to sample the audio tracks
@@ -93,8 +94,8 @@
             case ADM_TS_EAC3: 
                             {
                                 trackInfo->wav.encoding=WAV_EAC3;
-#if 0
-                                if(!ADM_AC3GetInfo(audioBuffer, rd, &fq, &br, &chan,&off))
+#if 1
+                                if(!ADM_EAC3GetInfo(audioBuffer, rd, &fq, &br, &chan,&off))
                                 {
                                         printf("[PsProbeAudio] Failed to get info on track :%x\n",trackInfo->esId);
                                         goto er;



From mean at mail.berlios.de  Wed Aug  5 20:07:59 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Wed, 5 Aug 2009 20:07:59 +0200
Subject: [Avidemux-svn-commit] r5214 - in
	branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreAudioParser:
	include src
Message-ID: <200908051807.n75I7x2h029922@sheep.berlios.de>

Author: mean
Date: 2009-08-05 20:07:59 +0200 (Wed, 05 Aug 2009)
New Revision: 5214

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreAudioParser/include/ADM_eac3info.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreAudioParser/src/ADM_eac3info.cpp
Log:
[eac3] Use libavcodec function to extract data from eac3 header

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreAudioParser/include/ADM_eac3info.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreAudioParser/include/ADM_eac3info.h	2009-08-05 18:07:58 UTC (rev 5213)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreAudioParser/include/ADM_eac3info.h	2009-08-05 18:07:59 UTC (rev 5214)
@@ -9,6 +9,17 @@
 
 #ifndef ADM_EAC3INFO_H
 #define ADM_EAC3INFO_H
-bool     ADM_a52b_syncinfo (uint8_t * buf, int * flags, int * sample_rate, int * bit_rate);
-bool     ADM_EAC3GetInfo(uint8_t *buf, uint32_t len, uint32_t *fq, uint32_t *byterate, uint32_t *chan,uint32_t *syncoff);
+/**
+    \struct ADM_EAC3_INFO
+*/
+typedef struct
+{
+    uint32_t frequency;
+    uint32_t byterate;
+    uint32_t channels;
+    uint32_t frameSizeInBytes;
+    uint32_t samples;
+}ADM_EAC3_INFO;
+
+bool     ADM_EAC3GetInfo(uint8_t *buf, uint32_t len, uint32_t *syncoff,ADM_EAC3_INFO *info);
 #endif //ADM_EAC3INFO_H
\ No newline at end of file

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreAudioParser/src/ADM_eac3info.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreAudioParser/src/ADM_eac3info.cpp	2009-08-05 18:07:58 UTC (rev 5213)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreAudioParser/src/ADM_eac3info.cpp	2009-08-05 18:07:59 UTC (rev 5214)
@@ -10,95 +10,19 @@
 #include "ADM_default.h"
 
 #include "ADM_eac3info.h"
-/**
- * Possible frame sizes.
- * from ATSC A/52 Table 5.18 Frame Size Code Table.
- * Borrowed from ffmpeg
- */
-const uint16_t ff_ac3_frame_size_tab[38][3] = {
-    { 64,   69,   96   },
-    { 64,   70,   96   },
-    { 80,   87,   120  },
-    { 80,   88,   120  },
-    { 96,   104,  144  },
-    { 96,   105,  144  },
-    { 112,  121,  168  },
-    { 112,  122,  168  },
-    { 128,  139,  192  },
-    { 128,  140,  192  },
-    { 160,  174,  240  },
-    { 160,  175,  240  },
-    { 192,  208,  288  },
-    { 192,  209,  288  },
-    { 224,  243,  336  },
-    { 224,  244,  336  },
-    { 256,  278,  384  },
-    { 256,  279,  384  },
-    { 320,  348,  480  },
-    { 320,  349,  480  },
-    { 384,  417,  576  },
-    { 384,  418,  576  },
-    { 448,  487,  672  },
-    { 448,  488,  672  },
-    { 512,  557,  768  },
-    { 512,  558,  768  },
-    { 640,  696,  960  },
-    { 640,  697,  960  },
-    { 768,  835,  1152 },
-    { 768,  836,  1152 },
-    { 896,  975,  1344 },
-    { 896,  976,  1344 },
-    { 1024, 1114, 1536 },
-    { 1024, 1115, 1536 },
-    { 1152, 1253, 1728 },
-    { 1152, 1254, 1728 },
-    { 1280, 1393, 1920 },
-    { 1280, 1394, 1920 },
-};
-// Borrowed from ffmpeg
-const uint16_t ff_ac3_bitrate_tab[19] = {
-    32, 40, 48, 56, 64, 80, 96, 112, 128,
-    160, 192, 224, 256, 320, 384, 448, 512, 576, 640
-};
-
-/**
-    \fn ADM_a52b_syncinfo
-*/
-bool ADM_a52b_syncinfo (uint8_t * buf, int * flags, int * sample_rate, int * bit_rate)
+extern "C"
 {
-    int frmsizecod;
-    int bitrate;
-    int half;
-    int acmod;
+#define ADM_NO_CONFIG_H
+#define sign_extend
+#include "libavcodec/internal.h"
+#include "libavcodec/ac3_parser.h"
 
-    if ((buf[0] != 0x0b) || (buf[1] != 0x77))	/* syncword */
-        return false;
+};
 
-// 0B77   16 01
-// CRC16  16 23
-// fscod  2  4
-// frmsiz 6  4
-
-    int fscod=buf[0]>>6;
-    int frmsize=buf[0]&0x3F;
-    if(frmsize>=38) return 0;
-
-    if(fscod==3) return 0;
-    switch(fscod)
-    {
-        case 0: *sample_rate=48000;break;
-        case 1: *sample_rate=44100;break;
-        case 2: *sample_rate=32000;break;
-        default : return 0;
-    }
-    *bit_rate=ff_ac3_frame_size_tab[frmsize][fscod]*1000;
-    return 1;
-    
-}
 /**
     \fn ADM_EAC3GetInfo
 */
-bool  ADM_EAC3GetInfo(uint8_t *buf, uint32_t len, uint32_t *fq, uint32_t *byterate, uint32_t *chan,uint32_t *syncoff)
+bool     ADM_EAC3GetInfo(uint8_t *buf, uint32_t len, uint32_t *syncoff,ADM_EAC3_INFO *info)
 {
 uint32_t l;
 int ibr,ifq,flags;
@@ -122,22 +46,26 @@
 			of++;
 			continue;
 		 }
-		 // Try to get syncinfo
-	        l=ADM_a52b_syncinfo (buf,&flags, &ifq, &ibr);
-		if(!l)
-		{
-			len--;
-			buf++;
-			of++;
-			printf("Sync failed..continuing\n");
-			continue;
+            AC3HeaderInfo hdr;
+            GetBitContext gb;
+            init_get_bits(&gb,buf,len*8);
+            if(ff_ac3_parse_header(&gb, &hdr))
+            {
+                len--;
+                buf++;
+                of++;
+                printf("Sync failed..continuing\n");
+                continue;
+            }
+            printf("Sync found at offset %"LU"\n",of);
+            *syncoff=of;
+            info->frequency=(uint32_t)hdr.sample_rate;
+            info->byterate=(uint32_t)hdr.bit_rate>>3;
+            info->channels=hdr.channels;
+            info->frameSizeInBytes=hdr.frame_size;
+            info->samples=265*6; // ??
+            return 1;
 		}
-		printf("Sync found at offset %"LU"\n",of);
-		*syncoff=of;
-		*fq=(uint32_t)ifq;
-		*byterate=(uint32_t)ibr>>3;
-
 		return 1;
-	}
-	return 0;
+	
 }



From mean at mail.berlios.de  Wed Aug  5 20:08:01 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Wed, 5 Aug 2009 20:08:01 +0200
Subject: [Avidemux-svn-commit] r5215 -
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/MpegTS
Message-ID: <200908051808.n75I81kD029934@sheep.berlios.de>

Author: mean
Date: 2009-08-05 20:08:01 +0200 (Wed, 05 Aug 2009)
New Revision: 5215

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/MpegTS/ADM_tsAudioProbe.cpp
Log:
[Demuxer/TS] Use new eac3 parser

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/MpegTS/ADM_tsAudioProbe.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/MpegTS/ADM_tsAudioProbe.cpp	2009-08-05 18:07:59 UTC (rev 5214)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/MpegTS/ADM_tsAudioProbe.cpp	2009-08-05 18:08:01 UTC (rev 5215)
@@ -94,20 +94,15 @@
             case ADM_TS_EAC3: 
                             {
                                 trackInfo->wav.encoding=WAV_EAC3;
-#if 1
-                                if(!ADM_EAC3GetInfo(audioBuffer, rd, &fq, &br, &chan,&off))
+                                ADM_EAC3_INFO info;
+                                if(!ADM_EAC3GetInfo(audioBuffer, rd, &off,&info))
                                 {
                                         printf("[PsProbeAudio] Failed to get info on track :%x\n",trackInfo->esId);
                                         goto er;
                                 }
-                                trackInfo->wav.frequency=fq;
-                                trackInfo->wav.channels=chan;
-                                trackInfo->wav.byterate=(br);
-#else
-                                trackInfo->wav.frequency=48000;
-                                trackInfo->wav.channels=2;
-                                trackInfo->wav.byterate=128000>>3;
-#endif
+                                trackInfo->wav.frequency=info.frequency;
+                                trackInfo->wav.channels=info.channels;
+                                trackInfo->wav.byterate=info.byterate;
                                 break;
                             }
                             



From mean at mail.berlios.de  Thu Aug  6 20:25:20 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Thu, 6 Aug 2009 20:25:20 +0200
Subject: [Avidemux-svn-commit] r5216 - in
	branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg:
	libavcodec patches
Message-ID: <200908061825.n76IPKB0014697@sheep.berlios.de>

Author: mean
Date: 2009-08-06 20:25:20 +0200 (Thu, 06 Aug 2009)
New Revision: 5216

Added:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/libavcodec_eac3_patch.patch
Modified:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/ac3dec.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/ac3dec.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/ac3dec_data.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/ac3dec_data.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/eac3dec.c
Log:
[core/ffmpeg] Add eac3 patch, ok for stereo, refs #16

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/CMakeLists.txt	2009-08-05 18:08:01 UTC (rev 5215)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/CMakeLists.txt	2009-08-06 18:25:20 UTC (rev 5216)
@@ -20,8 +20,8 @@
         flacdata.c
         vp6dsp.c
         tscc.c  resample2.c    qdm2.c  bitstream_filter.c  eval.c  vc1.c
-	vc1dsp.c  vp56.c  vp6.c  vp5.c  indeo2.c  smacker.c  opt.c  fraps.c  dnxhddec.c
-	mpeg12data.c  mpegaudiodata.c  msmpeg4data.c  vc1data.c  vp56data.c  mjpegbdec.c
+	vp56.c  vp6.c  vp5.c  indeo2.c  smacker.c  opt.c  fraps.c  dnxhddec.c
+	mpeg12data.c  mpegaudiodata.c  msmpeg4data.c   vp56data.c  mjpegbdec.c
 	h263_parser.c  h264_parser.c  mpeg4video_parser.c  mpegvideo_enc.c  mpeg12enc.c
 	mpegaudioenc.c  
         mjpegenc.c  mjpegdec.c  wma.c  

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/ac3dec.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/ac3dec.c	2009-08-05 18:08:01 UTC (rev 5215)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/ac3dec.c	2009-08-06 18:25:20 UTC (rev 5216)
@@ -826,15 +826,95 @@
 
     /* spectral extension strategy */
     if (s->eac3 && (!blk || get_bits1(gbc))) {
-        if (get_bits1(gbc)) {
-            av_log_missing_feature(s->avctx, "Spectral extension", 1);
-            return -1;
+        s->spx_in_use = get_bits1(gbc);
+        if (s->spx_in_use) {
+            int begf, endf;
+            int spx_end_subband;
+
+            /* determine which channels use spx */
+            if (s->channel_mode == AC3_CHMODE_MONO) {
+                s->channel_in_spx[1] = 1;
+            } else {
+                for (ch = 1; ch <= fbw_channels; ch++)
+                    s->channel_in_spx[ch] = get_bits1(gbc);
+            }
+
+            s->spx_copy_start_freq = get_bits(gbc, 2) * 12 + 25;
+            begf = get_bits(gbc, 3);
+            endf = get_bits(gbc, 3);
+            s->spx_start_subband = begf < 6 ? begf+2 : 2*begf-3;
+            spx_end_subband      = endf < 4 ? endf+5 : 2*endf+3;
+            if (s->spx_start_subband >= spx_end_subband) {
+                av_log(s->avctx, AV_LOG_ERROR, "invalid spectral extension range (%d >= %d)\n",
+                       s->spx_start_subband, spx_end_subband);
+                return -1;
+            }
+            s->spx_start_freq    = s->spx_start_subband * 12 + 25;
+            s->spx_end_freq      = spx_end_subband      * 12 + 25;
+            if (s->spx_copy_start_freq >= s->spx_start_freq) {
+                av_log(s->avctx, AV_LOG_ERROR, "invalid spectral extension copy start bin (%d >= %d)\n",
+                       s->spx_copy_start_freq, s->spx_start_freq);
+                return -1;
+            }
+            decode_band_structure(gbc, blk, s->eac3, 0,
+                                  s->spx_start_subband, spx_end_subband,
+                                  ff_eac3_default_spx_band_struct,
+                                  s->spx_band_struct, &s->num_spx_bands,
+                                  s->spx_band_sizes);
+        } else {
+            for (ch = 1; ch <= fbw_channels; ch++) {
+                s->channel_in_spx[ch] = 0;
+                s->first_spx_coords[ch] = 1;
+            }
         }
-        /* TODO: parse spectral extension strategy info */
     }
 
-    /* TODO: spectral extension coordinates */
+    /* spectral extension coordinates */
+    if (s->spx_in_use) {
+        for (ch = 1; ch <= fbw_channels; ch++) {
+            if (s->channel_in_spx[ch]) {
+                if (s->first_spx_coords[ch] || get_bits1(gbc)) {
+                    int bin;
+                    float spx_blend;
+                    int master_spx_coord;
+                    s->first_spx_coords[ch] = 0;
+                    spx_blend = get_bits(gbc, 5) / 32.0f;
+                    master_spx_coord = get_bits(gbc, 2) * 3;
+                    bin = s->spx_start_freq;
+                    for (bnd = 0; bnd < s->num_spx_bands; bnd++) {
+                        int bandsize;
+                        int spx_coord_exp, spx_coord_mant;
+                        float nratio, sblend, nblend, spx_coord;
 
+                        /* calculate blending factors */
+                        bandsize = s->spx_band_sizes[bnd];
+                        nratio = ((float)((bin + (bandsize >> 1))) / s->spx_end_freq) - spx_blend;
+                        nratio = av_clipf(nratio, 0.0f, 1.0f);
+                        nblend = sqrt(       nratio);
+                        sblend = sqrt(1.0f - nratio);
+                        nblend *= 1.73205077648f; // scale noise to give unity variance
+                        bin += bandsize;
+
+                        /* decode spx coordinates */
+                        spx_coord_exp  = get_bits(gbc, 4);
+                        spx_coord_mant = get_bits(gbc, 2);
+                        if (spx_coord_exp == 15)
+                            spx_coord = spx_coord_mant / 4.0f;
+                        else
+                            spx_coord = (spx_coord_mant + 4) / 8.0f;
+                        spx_coord /= (float)(1 << (spx_coord_exp + master_spx_coord));
+
+                        /* multiply noise and signal blending factors by spx coordinate */
+                        s->spx_noise_blend [ch][bnd] = nblend * spx_coord * 32.0f;
+                        s->spx_signal_blend[ch][bnd] = sblend * spx_coord * 32.0f;
+                    }
+                }
+            } else {
+                s->first_spx_coords[ch] = 1;
+            }
+        }
+    }
+
     /* coupling strategy */
     if (s->eac3 ? s->cpl_strategy_exists[blk] : get_bits1(gbc)) {
         memset(bit_alloc_stages, 3, AC3_MAX_CHANNELS);
@@ -870,9 +950,9 @@
                 s->phase_flags_in_use = get_bits1(gbc);
 
             /* coupling frequency range */
-            /* TODO: modify coupling end freq if spectral extension is used */
             cpl_start_subband = get_bits(gbc, 4);
-            cpl_end_subband   = get_bits(gbc, 4) + 3;
+            cpl_end_subband = s->spx_in_use ? s->spx_start_subband - 1 :
+                                              get_bits(gbc, 4) + 3;
             if (cpl_start_subband >= cpl_end_subband) {
                 av_log(s->avctx, AV_LOG_ERROR, "invalid coupling range (%d >= %d)\n",
                        cpl_start_subband, cpl_end_subband);
@@ -945,8 +1025,11 @@
     if (channel_mode == AC3_CHMODE_STEREO) {
         if ((s->eac3 && !blk) || get_bits1(gbc)) {
             s->num_rematrixing_bands = 4;
-            if(cpl_in_use && s->start_freq[CPL_CH] <= 61)
+            if (cpl_in_use && s->start_freq[CPL_CH] <= 61) {
                 s->num_rematrixing_bands -= 1 + (s->start_freq[CPL_CH] == 37);
+            } else if (s->spx_in_use && s->spx_start_freq <= 61) {
+                s->num_rematrixing_bands -= 1;
+            }
             for(bnd=0; bnd<s->num_rematrixing_bands; bnd++)
                 s->rematrixing_flags[bnd] = get_bits1(gbc);
         } else if (!blk) {
@@ -971,6 +1054,8 @@
             int prev = s->end_freq[ch];
             if (s->channel_in_cpl[ch])
                 s->end_freq[ch] = s->start_freq[CPL_CH];
+            else if (s->channel_in_spx[ch])
+                s->end_freq[ch] = s->spx_start_freq;
             else {
                 int bandwidth_code = get_bits(gbc, 6);
                 if (bandwidth_code > 60) {
@@ -1167,8 +1252,6 @@
 
     /* TODO: generate enhanced coupling coordinates and uncouple */
 
-    /* TODO: apply spectral extension */
-
     /* recover coefficients if rematrixing is in use */
     if(s->channel_mode == AC3_CHMODE_STEREO)
         do_rematrixing(s);
@@ -1184,6 +1267,10 @@
         s->dsp.int32_to_float_fmul_scalar(s->transform_coeffs[ch], s->fixed_coeffs[ch], gain, 256);
     }
 
+    /* apply spectral extension to high frequency bins */
+    if (s->spx_in_use)
+        ff_eac3_apply_spectral_extension(s);
+
     /* downmix and MDCT. order depends on whether block switching is used for
        any channel in this block. this is because coefficients for the long
        and short transforms cannot be mixed. */
@@ -1225,8 +1312,8 @@
 static int ac3_decode_frame(AVCodecContext * avctx, void *data, int *data_size,
                             AVPacket *avpkt)
 {
-    const uint8_t *buf = avpkt->data;
-    int buf_size = avpkt->size;
+    const uint8_t *buf=avpkt->data;
+    int buf_size=avpkt->size;
     AC3DecodeContext *s = avctx->priv_data;
     int16_t *out_samples = (int16_t *)data;
     int blk, ch, err;

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/ac3dec.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/ac3dec.h	2009-08-05 18:08:01 UTC (rev 5215)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/ac3dec.h	2009-08-06 18:25:20 UTC (rev 5216)
@@ -42,6 +42,7 @@
 #define AC3_MAX_COEFS   256
 #define AC3_BLOCK_SIZE  256
 #define MAX_BLOCKS        6
+#define SPX_MAX_BANDS    17
 
 typedef struct {
     AVCodecContext *avctx;                  ///< parent context
@@ -88,6 +89,23 @@
     int cpl_coords[AC3_MAX_CHANNELS][18];   ///< coupling coordinates                   (cplco)
 ///@}
 
+///@defgroup spx spectral extension
+///@{
+    int spx_in_use;                             ///< spectral extension in use              (spxinu)
+    uint8_t channel_in_spx[AC3_MAX_CHANNELS];   ///< channel in spectral extension          (chinspx)
+    int8_t spx_atten_code[AC3_MAX_CHANNELS];    ///< spx attenuation code                   (spxattencod)
+    int spx_start_subband;                      ///< spx beginning frequency band           (spxbegf)
+    int spx_start_freq;                         ///< spx start frequency bin
+    int spx_end_freq;                           ///< spx end frequency bin
+    int spx_copy_start_freq;                    ///< spx starting frequency for copying     (copystartmant)
+    int num_spx_bands;                          ///< number of spx bands                    (nspxbnds)
+    uint8_t spx_band_struct[SPX_MAX_BANDS];     ///< spectral extension band structure      (spxbndstrc)
+    uint8_t spx_band_sizes[SPX_MAX_BANDS];      ///< number of bins in each band            (spxbndsztab)
+    uint8_t first_spx_coords[AC3_MAX_CHANNELS]; ///< first spx coordinates states           (firstspxcos)
+    float spx_noise_blend[AC3_MAX_CHANNELS][SPX_MAX_BANDS]; ///< spx noise blending factor  (nblendfact)
+    float spx_signal_blend[AC3_MAX_CHANNELS][SPX_MAX_BANDS];///< spx signal blending factor (sblendfact)
+///@}
+
 ///@defgroup aht adaptive hybrid transform
     int channel_uses_aht[AC3_MAX_CHANNELS];                         ///< channel AHT in use (chahtinu)
     int pre_mantissa[AC3_MAX_CHANNELS][AC3_MAX_COEFS][MAX_BLOCKS];  ///< pre-IDCT mantissas
@@ -179,4 +197,11 @@
  */
 void ff_eac3_decode_transform_coeffs_aht_ch(AC3DecodeContext *s, int ch);
 
+/**
+ * Apply spectral extension to each channel by copying lower frequency
+ * coefficients to higher frequency bins and applying side information to
+ * approximate the original high frequency signal.
+ */
+void ff_eac3_apply_spectral_extension(AC3DecodeContext *s);
+
 #endif /* AVCODEC_AC3DEC_H */

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/ac3dec_data.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/ac3dec_data.c	2009-08-05 18:08:01 UTC (rev 5215)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/ac3dec_data.c	2009-08-06 18:25:20 UTC (rev 5216)
@@ -64,3 +64,48 @@
  */
 const uint8_t ff_eac3_default_cpl_band_struct[18] =
 { 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1 };
+
+/**
+ * Table E2.15 Default Spectral Extension Banding Structure
+ */
+const uint8_t ff_eac3_default_spx_band_struct[17] =
+{ 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1 };
+
+/**
+ * Table E.25: Spectral Extension Attenuation Table
+ * ff_eac3_spx_atten_tab[code][bin]=pow(2.0,(bin+1)*(code+1)/-15.0);
+ */
+const float ff_eac3_spx_atten_tab[32][3] = {
+    { 0.954841603910416503f, 0.911722488558216804f, 0.870550563296124125f },
+    { 0.911722488558216804f, 0.831237896142787758f, 0.757858283255198995f },
+    { 0.870550563296124125f, 0.757858283255198995f, 0.659753955386447100f },
+    { 0.831237896142787758f, 0.690956439983888004f, 0.574349177498517438f },
+    { 0.793700525984099792f, 0.629960524947436595f, 0.500000000000000000f },
+    { 0.757858283255198995f, 0.574349177498517438f, 0.435275281648062062f },
+    { 0.723634618720189082f, 0.523647061410313364f, 0.378929141627599553f },
+    { 0.690956439983888004f, 0.477420801955208307f, 0.329876977693223550f },
+    { 0.659753955386447100f, 0.435275281648062062f, 0.287174588749258719f },
+    { 0.629960524947436595f, 0.396850262992049896f, 0.250000000000000000f },
+    { 0.601512518041058319f, 0.361817309360094541f, 0.217637640824031003f },
+    { 0.574349177498517438f, 0.329876977693223550f, 0.189464570813799776f },
+    { 0.548412489847312945f, 0.300756259020529160f, 0.164938488846611775f },
+    { 0.523647061410313364f, 0.274206244923656473f, 0.143587294374629387f },
+    { 0.500000000000000000f, 0.250000000000000000f, 0.125000000000000000f },
+    { 0.477420801955208307f, 0.227930622139554201f, 0.108818820412015502f },
+    { 0.455861244279108402f, 0.207809474035696939f, 0.094732285406899888f },
+    { 0.435275281648062062f, 0.189464570813799776f, 0.082469244423305887f },
+    { 0.415618948071393879f, 0.172739109995972029f, 0.071793647187314694f },
+    { 0.396850262992049896f, 0.157490131236859149f, 0.062500000000000000f },
+    { 0.378929141627599553f, 0.143587294374629387f, 0.054409410206007751f },
+    { 0.361817309360094541f, 0.130911765352578369f, 0.047366142703449930f },
+    { 0.345478219991944002f, 0.119355200488802049f, 0.041234622211652958f },
+    { 0.329876977693223550f, 0.108818820412015502f, 0.035896823593657347f },
+    { 0.314980262473718298f, 0.099212565748012460f, 0.031250000000000000f },
+    { 0.300756259020529160f, 0.090454327340023621f, 0.027204705103003875f },
+    { 0.287174588749258719f, 0.082469244423305887f, 0.023683071351724965f },
+    { 0.274206244923656473f, 0.075189064755132290f, 0.020617311105826479f },
+    { 0.261823530705156682f, 0.068551561230914118f, 0.017948411796828673f },
+    { 0.250000000000000000f, 0.062500000000000000f, 0.015625000000000000f },
+    { 0.238710400977604098f, 0.056982655534888536f, 0.013602352551501938f },
+    { 0.227930622139554201f, 0.051952368508924235f, 0.011841535675862483f }
+};

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/ac3dec_data.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/ac3dec_data.h	2009-08-05 18:08:01 UTC (rev 5215)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/ac3dec_data.h	2009-08-06 18:25:20 UTC (rev 5216)
@@ -29,5 +29,7 @@
 
 extern const uint8_t ff_eac3_hebap_tab[64];
 extern const uint8_t ff_eac3_default_cpl_band_struct[18];
+extern const uint8_t ff_eac3_default_spx_band_struct[17];
+extern const float   ff_eac3_spx_atten_tab[32][3];
 
 #endif /* AVCODEC_AC3DEC_DATA_H */

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/eac3dec.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/eac3dec.c	2009-08-05 18:08:01 UTC (rev 5215)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/eac3dec.c	2009-08-06 18:25:20 UTC (rev 5216)
@@ -23,10 +23,6 @@
 /*
  * There are several features of E-AC-3 that this decoder does not yet support.
  *
- * Spectral Extension
- *     There is a patch to get this working for the two samples we have that
- *     use it, but it needs some minor changes in order to be accepted.
- *
  * Enhanced Coupling
  *     No known samples exist.  If any ever surface, this feature should not be
  *     too difficult to implement.
@@ -67,6 +63,95 @@
 
 #define EAC3_SR_CODE_REDUCED  3
 
+void ff_eac3_apply_spectral_extension(AC3DecodeContext *s)
+{
+    int bin, bnd, ch, i;
+    uint8_t wrapflag[SPX_MAX_BANDS]={0,}, num_copy_sections, copy_sizes[SPX_MAX_BANDS];
+    float rms_energy[SPX_MAX_BANDS];
+
+    /* Set copy index mapping table. Set wrap flags to apply a notch filter at
+       wrap points later on. */
+    wrapflag[0] = 1;
+    bin = s->spx_copy_start_freq;
+    num_copy_sections = 0;
+    for (bnd = 0; bnd < s->num_spx_bands; bnd++) {
+        int copysize;
+        int bandsize = s->spx_band_sizes[bnd];
+        if ((bin + bandsize) > s->spx_start_freq) {
+            copy_sizes[num_copy_sections++] = bin - s->spx_copy_start_freq;
+            bin = s->spx_copy_start_freq;
+            wrapflag[bnd] = 1;
+        }
+        for (i = 0; i < bandsize; i += copysize) {
+            if (bin == s->spx_start_freq) {
+                copy_sizes[num_copy_sections++] = bin - s->spx_copy_start_freq;
+                bin = s->spx_copy_start_freq;
+            }
+            copysize = FFMIN(bandsize - i, s->spx_start_freq - bin);
+            bin += copysize;
+        }
+    }
+    copy_sizes[num_copy_sections++] = bin - s->spx_copy_start_freq;
+
+    for (ch = 1; ch <= s->fbw_channels; ch++) {
+        if (!s->channel_in_spx[ch])
+            continue;
+
+        /* Copy coeffs from normal bands to extension bands */
+        bin = s->spx_start_freq;
+        for (i = 0; i < num_copy_sections; i++) {
+            memcpy(&s->transform_coeffs[ch][bin],
+                   &s->transform_coeffs[ch][s->spx_copy_start_freq],
+                   copy_sizes[i]*sizeof(float));
+            bin += copy_sizes[i];
+        }
+
+        /* Calculate RMS energy for each SPX band. */
+        bin = s->spx_start_freq;
+        for (bnd = 0; bnd < s->num_spx_bands; bnd++) {
+            int bandsize = s->spx_band_sizes[bnd];
+            float accum = 0.0f;
+            for (i = 0; i < bandsize; i++) {
+                float coeff = s->transform_coeffs[ch][bin++];
+                accum += coeff * coeff;
+            }
+            rms_energy[bnd] = sqrt(accum / (float)bandsize);
+        }
+
+        /* Apply a notch filter at transitions between normal and extension
+           bands and at all wrap points. */
+        if (s->spx_atten_code[ch] >= 0) {
+            const float *atten_tab = ff_eac3_spx_atten_tab[s->spx_atten_code[ch]];
+            bin = s->spx_start_freq - 2;
+            for (bnd = 0; bnd < s->num_spx_bands; bnd++) {
+                if (wrapflag[bnd]) {
+                    float *coeffs = &s->transform_coeffs[ch][bin];
+                    coeffs[0] *= atten_tab[0];
+                    coeffs[1] *= atten_tab[1];
+                    coeffs[2] *= atten_tab[2];
+                    coeffs[3] *= atten_tab[1];
+                    coeffs[4] *= atten_tab[0];
+                }
+                bin += s->spx_band_sizes[bnd];
+            }
+        }
+
+        /* Apply noise-blended coefficient scaling based on previously
+           calculated RMS energy, blending factors, and SPX coordinates for
+           each band. */
+        bin = s->spx_start_freq;
+        for (bnd = 0; bnd < s->num_spx_bands; bnd++) {
+            float nscale = s->spx_noise_blend[ch][bnd] * rms_energy[bnd];
+            float sscale = s->spx_signal_blend[ch][bnd];
+            for (i = 0; i < s->spx_band_sizes[bnd]; i++) {
+                float noise  = nscale * (((int)av_lfg_get(&s->dith_state))/(float)(1<<31));
+                s->transform_coeffs[ch][bin]   *= sscale;
+                s->transform_coeffs[ch][bin++] += noise;
+            }
+        }
+    }
+}
+
 /** lrint(M_SQRT2*cos(2*M_PI/12)*(1<<23)) */
 #define COEFF_0 10273905LL
 
@@ -492,13 +577,11 @@
     }
 
     /* spectral extension attenuation data */
-    if (parse_spx_atten_data) {
-        av_log_missing_feature(s->avctx, "Spectral extension attenuation", 1);
-        for (ch = 1; ch <= s->fbw_channels; ch++) {
-            if (get_bits1(gbc)) { // channel has spx attenuation
-                skip_bits(gbc, 5); // skip spx attenuation code
-            }
-        }
+    for (ch = 1; ch <= s->fbw_channels; ch++) {
+        if (parse_spx_atten_data && get_bits1(gbc))
+            s->spx_atten_code[ch] = get_bits(gbc, 5);
+        else
+            s->spx_atten_code[ch] = -1;
     }
 
     /* block start information */
@@ -514,6 +597,7 @@
 
     /* syntax state initialization */
     for (ch = 1; ch <= s->fbw_channels; ch++) {
+        s->first_spx_coords[ch] = 1;
         s->first_cpl_coords[ch] = 1;
     }
     s->first_cpl_leak = 1;

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/libavcodec_eac3_patch.patch
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/libavcodec_eac3_patch.patch	2009-08-05 18:08:01 UTC (rev 5215)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/patches/libavcodec_eac3_patch.patch	2009-08-06 18:25:20 UTC (rev 5216)
@@ -0,0 +1,435 @@
+diff --git a/avidemux_core/ADM_ffmpeg/libavcodec/CMakeLists.txt b/avidemux_core/ADM_ffmpeg/libavcodec/CMakeLists.txt
+index d584ef4..086861b 100644
+--- libavcodec/CMakeLists.txt
++++ libavcodec/CMakeLists.txt
+@@ -20,8 +20,8 @@ SET(${ADM_LIB}_SRCS
+         flacdata.c
+         vp6dsp.c
+         tscc.c  resample2.c    qdm2.c  bitstream_filter.c  eval.c  vc1.c
+-	vc1dsp.c  vp56.c  vp6.c  vp5.c  indeo2.c  smacker.c  opt.c  fraps.c  dnxhddec.c
+-	mpeg12data.c  mpegaudiodata.c  msmpeg4data.c  vc1data.c  vp56data.c  mjpegbdec.c
++	vp56.c  vp6.c  vp5.c  indeo2.c  smacker.c  opt.c  fraps.c  dnxhddec.c
++	mpeg12data.c  mpegaudiodata.c  msmpeg4data.c   vp56data.c  mjpegbdec.c
+ 	h263_parser.c  h264_parser.c  mpeg4video_parser.c  mpegvideo_enc.c  mpeg12enc.c
+ 	mpegaudioenc.c  
+         mjpegenc.c  mjpegdec.c  wma.c  
+diff --git a/avidemux_core/ADM_ffmpeg/libavcodec/ac3dec.c b/avidemux_core/ADM_ffmpeg/libavcodec/ac3dec.c
+index baff415..d6de1e0 100644
+--- libavcodec/ac3dec.c
++++ libavcodec/ac3dec.c
+@@ -826,14 +826,94 @@ static int decode_audio_block(AC3DecodeContext *s, int blk)
+ 
+     /* spectral extension strategy */
+     if (s->eac3 && (!blk || get_bits1(gbc))) {
+-        if (get_bits1(gbc)) {
+-            av_log_missing_feature(s->avctx, "Spectral extension", 1);
+-            return -1;
++        s->spx_in_use = get_bits1(gbc);
++        if (s->spx_in_use) {
++            int begf, endf;
++            int spx_end_subband;
++
++            /* determine which channels use spx */
++            if (s->channel_mode == AC3_CHMODE_MONO) {
++                s->channel_in_spx[1] = 1;
++            } else {
++                for (ch = 1; ch <= fbw_channels; ch++)
++                    s->channel_in_spx[ch] = get_bits1(gbc);
++            }
++
++            s->spx_copy_start_freq = get_bits(gbc, 2) * 12 + 25;
++            begf = get_bits(gbc, 3);
++            endf = get_bits(gbc, 3);
++            s->spx_start_subband = begf < 6 ? begf+2 : 2*begf-3;
++            spx_end_subband      = endf < 4 ? endf+5 : 2*endf+3;
++            if (s->spx_start_subband >= spx_end_subband) {
++                av_log(s->avctx, AV_LOG_ERROR, "invalid spectral extension range (%d >= %d)\n",
++                       s->spx_start_subband, spx_end_subband);
++                return -1;
++            }
++            s->spx_start_freq    = s->spx_start_subband * 12 + 25;
++            s->spx_end_freq      = spx_end_subband      * 12 + 25;
++            if (s->spx_copy_start_freq >= s->spx_start_freq) {
++                av_log(s->avctx, AV_LOG_ERROR, "invalid spectral extension copy start bin (%d >= %d)\n",
++                       s->spx_copy_start_freq, s->spx_start_freq);
++                return -1;
++            }
++            decode_band_structure(gbc, blk, s->eac3, 0,
++                                  s->spx_start_subband, spx_end_subband,
++                                  ff_eac3_default_spx_band_struct,
++                                  s->spx_band_struct, &s->num_spx_bands,
++                                  s->spx_band_sizes);
++        } else {
++            for (ch = 1; ch <= fbw_channels; ch++) {
++                s->channel_in_spx[ch] = 0;
++                s->first_spx_coords[ch] = 1;
++            }
+         }
+-        /* TODO: parse spectral extension strategy info */
+     }
+ 
+-    /* TODO: spectral extension coordinates */
++    /* spectral extension coordinates */
++    if (s->spx_in_use) {
++        for (ch = 1; ch <= fbw_channels; ch++) {
++            if (s->channel_in_spx[ch]) {
++                if (s->first_spx_coords[ch] || get_bits1(gbc)) {
++                    int bin;
++                    float spx_blend;
++                    int master_spx_coord;
++                    s->first_spx_coords[ch] = 0;
++                    spx_blend = get_bits(gbc, 5) / 32.0f;
++                    master_spx_coord = get_bits(gbc, 2) * 3;
++                    bin = s->spx_start_freq;
++                    for (bnd = 0; bnd < s->num_spx_bands; bnd++) {
++                        int bandsize;
++                        int spx_coord_exp, spx_coord_mant;
++                        float nratio, sblend, nblend, spx_coord;
++
++                        /* calculate blending factors */
++                        bandsize = s->spx_band_sizes[bnd];
++                        nratio = ((float)((bin + (bandsize >> 1))) / s->spx_end_freq) - spx_blend;
++                        nratio = av_clipf(nratio, 0.0f, 1.0f);
++                        nblend = sqrt(       nratio);
++                        sblend = sqrt(1.0f - nratio);
++                        nblend *= 1.73205077648f; // scale noise to give unity variance
++                        bin += bandsize;
++
++                        /* decode spx coordinates */
++                        spx_coord_exp  = get_bits(gbc, 4);
++                        spx_coord_mant = get_bits(gbc, 2);
++                        if (spx_coord_exp == 15)
++                            spx_coord = spx_coord_mant / 4.0f;
++                        else
++                            spx_coord = (spx_coord_mant + 4) / 8.0f;
++                        spx_coord /= (float)(1 << (spx_coord_exp + master_spx_coord));
++
++                        /* multiply noise and signal blending factors by spx coordinate */
++                        s->spx_noise_blend [ch][bnd] = nblend * spx_coord * 32.0f;
++                        s->spx_signal_blend[ch][bnd] = sblend * spx_coord * 32.0f;
++                    }
++                }
++            } else {
++                s->first_spx_coords[ch] = 1;
++            }
++        }
++    }
+ 
+     /* coupling strategy */
+     if (s->eac3 ? s->cpl_strategy_exists[blk] : get_bits1(gbc)) {
+@@ -870,9 +950,9 @@ static int decode_audio_block(AC3DecodeContext *s, int blk)
+                 s->phase_flags_in_use = get_bits1(gbc);
+ 
+             /* coupling frequency range */
+-            /* TODO: modify coupling end freq if spectral extension is used */
+             cpl_start_subband = get_bits(gbc, 4);
+-            cpl_end_subband   = get_bits(gbc, 4) + 3;
++            cpl_end_subband = s->spx_in_use ? s->spx_start_subband - 1 :
++                                              get_bits(gbc, 4) + 3;
+             if (cpl_start_subband >= cpl_end_subband) {
+                 av_log(s->avctx, AV_LOG_ERROR, "invalid coupling range (%d >= %d)\n",
+                        cpl_start_subband, cpl_end_subband);
+@@ -945,8 +1025,11 @@ static int decode_audio_block(AC3DecodeContext *s, int blk)
+     if (channel_mode == AC3_CHMODE_STEREO) {
+         if ((s->eac3 && !blk) || get_bits1(gbc)) {
+             s->num_rematrixing_bands = 4;
+-            if(cpl_in_use && s->start_freq[CPL_CH] <= 61)
++            if (cpl_in_use && s->start_freq[CPL_CH] <= 61) {
+                 s->num_rematrixing_bands -= 1 + (s->start_freq[CPL_CH] == 37);
++            } else if (s->spx_in_use && s->spx_start_freq <= 61) {
++                s->num_rematrixing_bands -= 1;
++            }
+             for(bnd=0; bnd<s->num_rematrixing_bands; bnd++)
+                 s->rematrixing_flags[bnd] = get_bits1(gbc);
+         } else if (!blk) {
+@@ -971,6 +1054,8 @@ static int decode_audio_block(AC3DecodeContext *s, int blk)
+             int prev = s->end_freq[ch];
+             if (s->channel_in_cpl[ch])
+                 s->end_freq[ch] = s->start_freq[CPL_CH];
++            else if (s->channel_in_spx[ch])
++                s->end_freq[ch] = s->spx_start_freq;
+             else {
+                 int bandwidth_code = get_bits(gbc, 6);
+                 if (bandwidth_code > 60) {
+@@ -1167,8 +1252,6 @@ static int decode_audio_block(AC3DecodeContext *s, int blk)
+ 
+     /* TODO: generate enhanced coupling coordinates and uncouple */
+ 
+-    /* TODO: apply spectral extension */
+-
+     /* recover coefficients if rematrixing is in use */
+     if(s->channel_mode == AC3_CHMODE_STEREO)
+         do_rematrixing(s);
+@@ -1184,6 +1267,10 @@ static int decode_audio_block(AC3DecodeContext *s, int blk)
+         s->dsp.int32_to_float_fmul_scalar(s->transform_coeffs[ch], s->fixed_coeffs[ch], gain, 256);
+     }
+ 
++    /* apply spectral extension to high frequency bins */
++    if (s->spx_in_use)
++        ff_eac3_apply_spectral_extension(s);
++
+     /* downmix and MDCT. order depends on whether block switching is used for
+        any channel in this block. this is because coefficients for the long
+        and short transforms cannot be mixed. */
+@@ -1225,8 +1312,8 @@ static int decode_audio_block(AC3DecodeContext *s, int blk)
+ static int ac3_decode_frame(AVCodecContext * avctx, void *data, int *data_size,
+                             AVPacket *avpkt)
+ {
+-    const uint8_t *buf = avpkt->data;
+-    int buf_size = avpkt->size;
++    const uint8_t *buf=avpkt->data;
++    int buf_size=avpkt->size;
+     AC3DecodeContext *s = avctx->priv_data;
+     int16_t *out_samples = (int16_t *)data;
+     int blk, ch, err;
+diff --git a/avidemux_core/ADM_ffmpeg/libavcodec/ac3dec.h b/avidemux_core/ADM_ffmpeg/libavcodec/ac3dec.h
+index 38c2deb..79ed731 100644
+--- libavcodec/ac3dec.h
++++ libavcodec/ac3dec.h
+@@ -42,6 +42,7 @@
+ #define AC3_MAX_COEFS   256
+ #define AC3_BLOCK_SIZE  256
+ #define MAX_BLOCKS        6
++#define SPX_MAX_BANDS    17
+ 
+ typedef struct {
+     AVCodecContext *avctx;                  ///< parent context
+@@ -88,6 +89,23 @@ typedef struct {
+     int cpl_coords[AC3_MAX_CHANNELS][18];   ///< coupling coordinates                   (cplco)
+ ///@}
+ 
++///@defgroup spx spectral extension
++///@{
++    int spx_in_use;                             ///< spectral extension in use              (spxinu)
++    uint8_t channel_in_spx[AC3_MAX_CHANNELS];   ///< channel in spectral extension          (chinspx)
++    int8_t spx_atten_code[AC3_MAX_CHANNELS];    ///< spx attenuation code                   (spxattencod)
++    int spx_start_subband;                      ///< spx beginning frequency band           (spxbegf)
++    int spx_start_freq;                         ///< spx start frequency bin
++    int spx_end_freq;                           ///< spx end frequency bin
++    int spx_copy_start_freq;                    ///< spx starting frequency for copying     (copystartmant)
++    int num_spx_bands;                          ///< number of spx bands                    (nspxbnds)
++    uint8_t spx_band_struct[SPX_MAX_BANDS];     ///< spectral extension band structure      (spxbndstrc)
++    uint8_t spx_band_sizes[SPX_MAX_BANDS];      ///< number of bins in each band            (spxbndsztab)
++    uint8_t first_spx_coords[AC3_MAX_CHANNELS]; ///< first spx coordinates states           (firstspxcos)
++    float spx_noise_blend[AC3_MAX_CHANNELS][SPX_MAX_BANDS]; ///< spx noise blending factor  (nblendfact)
++    float spx_signal_blend[AC3_MAX_CHANNELS][SPX_MAX_BANDS];///< spx signal blending factor (sblendfact)
++///@}
++
+ ///@defgroup aht adaptive hybrid transform
+     int channel_uses_aht[AC3_MAX_CHANNELS];                         ///< channel AHT in use (chahtinu)
+     int pre_mantissa[AC3_MAX_CHANNELS][AC3_MAX_COEFS][MAX_BLOCKS];  ///< pre-IDCT mantissas
+@@ -179,4 +197,11 @@ int ff_eac3_parse_header(AC3DecodeContext *s);
+  */
+ void ff_eac3_decode_transform_coeffs_aht_ch(AC3DecodeContext *s, int ch);
+ 
++/**
++ * Apply spectral extension to each channel by copying lower frequency
++ * coefficients to higher frequency bins and applying side information to
++ * approximate the original high frequency signal.
++ */
++void ff_eac3_apply_spectral_extension(AC3DecodeContext *s);
++
+ #endif /* AVCODEC_AC3DEC_H */
+diff --git a/avidemux_core/ADM_ffmpeg/libavcodec/ac3dec_data.c b/avidemux_core/ADM_ffmpeg/libavcodec/ac3dec_data.c
+index 907a3ae..57bed8d 100644
+--- libavcodec/ac3dec_data.c
++++ libavcodec/ac3dec_data.c
+@@ -64,3 +64,48 @@ const uint8_t ff_eac3_hebap_tab[64] = {
+  */
+ const uint8_t ff_eac3_default_cpl_band_struct[18] =
+ { 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1 };
++
++/**
++ * Table E2.15 Default Spectral Extension Banding Structure
++ */
++const uint8_t ff_eac3_default_spx_band_struct[17] =
++{ 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1 };
++
++/**
++ * Table E.25: Spectral Extension Attenuation Table
++ * ff_eac3_spx_atten_tab[code][bin]=pow(2.0,(bin+1)*(code+1)/-15.0);
++ */
++const float ff_eac3_spx_atten_tab[32][3] = {
++    { 0.954841603910416503f, 0.911722488558216804f, 0.870550563296124125f },
++    { 0.911722488558216804f, 0.831237896142787758f, 0.757858283255198995f },
++    { 0.870550563296124125f, 0.757858283255198995f, 0.659753955386447100f },
++    { 0.831237896142787758f, 0.690956439983888004f, 0.574349177498517438f },
++    { 0.793700525984099792f, 0.629960524947436595f, 0.500000000000000000f },
++    { 0.757858283255198995f, 0.574349177498517438f, 0.435275281648062062f },
++    { 0.723634618720189082f, 0.523647061410313364f, 0.378929141627599553f },
++    { 0.690956439983888004f, 0.477420801955208307f, 0.329876977693223550f },
++    { 0.659753955386447100f, 0.435275281648062062f, 0.287174588749258719f },
++    { 0.629960524947436595f, 0.396850262992049896f, 0.250000000000000000f },
++    { 0.601512518041058319f, 0.361817309360094541f, 0.217637640824031003f },
++    { 0.574349177498517438f, 0.329876977693223550f, 0.189464570813799776f },
++    { 0.548412489847312945f, 0.300756259020529160f, 0.164938488846611775f },
++    { 0.523647061410313364f, 0.274206244923656473f, 0.143587294374629387f },
++    { 0.500000000000000000f, 0.250000000000000000f, 0.125000000000000000f },
++    { 0.477420801955208307f, 0.227930622139554201f, 0.108818820412015502f },
++    { 0.455861244279108402f, 0.207809474035696939f, 0.094732285406899888f },
++    { 0.435275281648062062f, 0.189464570813799776f, 0.082469244423305887f },
++    { 0.415618948071393879f, 0.172739109995972029f, 0.071793647187314694f },
++    { 0.396850262992049896f, 0.157490131236859149f, 0.062500000000000000f },
++    { 0.378929141627599553f, 0.143587294374629387f, 0.054409410206007751f },
++    { 0.361817309360094541f, 0.130911765352578369f, 0.047366142703449930f },
++    { 0.345478219991944002f, 0.119355200488802049f, 0.041234622211652958f },
++    { 0.329876977693223550f, 0.108818820412015502f, 0.035896823593657347f },
++    { 0.314980262473718298f, 0.099212565748012460f, 0.031250000000000000f },
++    { 0.300756259020529160f, 0.090454327340023621f, 0.027204705103003875f },
++    { 0.287174588749258719f, 0.082469244423305887f, 0.023683071351724965f },
++    { 0.274206244923656473f, 0.075189064755132290f, 0.020617311105826479f },
++    { 0.261823530705156682f, 0.068551561230914118f, 0.017948411796828673f },
++    { 0.250000000000000000f, 0.062500000000000000f, 0.015625000000000000f },
++    { 0.238710400977604098f, 0.056982655534888536f, 0.013602352551501938f },
++    { 0.227930622139554201f, 0.051952368508924235f, 0.011841535675862483f }
++};
+diff --git a/avidemux_core/ADM_ffmpeg/libavcodec/ac3dec_data.h b/avidemux_core/ADM_ffmpeg/libavcodec/ac3dec_data.h
+index 8d9db05..877ea0b 100644
+--- libavcodec/ac3dec_data.h
++++ libavcodec/ac3dec_data.h
+@@ -29,5 +29,7 @@ extern const uint8_t ff_ac3_rematrix_band_tab[5];
+ 
+ extern const uint8_t ff_eac3_hebap_tab[64];
+ extern const uint8_t ff_eac3_default_cpl_band_struct[18];
++extern const uint8_t ff_eac3_default_spx_band_struct[17];
++extern const float   ff_eac3_spx_atten_tab[32][3];
+ 
+ #endif /* AVCODEC_AC3DEC_DATA_H */
+diff --git a/avidemux_core/ADM_ffmpeg/libavcodec/eac3dec.c b/avidemux_core/ADM_ffmpeg/libavcodec/eac3dec.c
+index 3784ccf..79f3c3b 100644
+--- libavcodec/eac3dec.c
++++ libavcodec/eac3dec.c
+@@ -23,10 +23,6 @@
+ /*
+  * There are several features of E-AC-3 that this decoder does not yet support.
+  *
+- * Spectral Extension
+- *     There is a patch to get this working for the two samples we have that
+- *     use it, but it needs some minor changes in order to be accepted.
+- *
+  * Enhanced Coupling
+  *     No known samples exist.  If any ever surface, this feature should not be
+  *     too difficult to implement.
+@@ -67,6 +63,95 @@ typedef enum {
+ 
+ #define EAC3_SR_CODE_REDUCED  3
+ 
++void ff_eac3_apply_spectral_extension(AC3DecodeContext *s)
++{
++    int bin, bnd, ch, i;
++    uint8_t wrapflag[SPX_MAX_BANDS]={0,}, num_copy_sections, copy_sizes[SPX_MAX_BANDS];
++    float rms_energy[SPX_MAX_BANDS];
++
++    /* Set copy index mapping table. Set wrap flags to apply a notch filter at
++       wrap points later on. */
++    wrapflag[0] = 1;
++    bin = s->spx_copy_start_freq;
++    num_copy_sections = 0;
++    for (bnd = 0; bnd < s->num_spx_bands; bnd++) {
++        int copysize;
++        int bandsize = s->spx_band_sizes[bnd];
++        if ((bin + bandsize) > s->spx_start_freq) {
++            copy_sizes[num_copy_sections++] = bin - s->spx_copy_start_freq;
++            bin = s->spx_copy_start_freq;
++            wrapflag[bnd] = 1;
++        }
++        for (i = 0; i < bandsize; i += copysize) {
++            if (bin == s->spx_start_freq) {
++                copy_sizes[num_copy_sections++] = bin - s->spx_copy_start_freq;
++                bin = s->spx_copy_start_freq;
++            }
++            copysize = FFMIN(bandsize - i, s->spx_start_freq - bin);
++            bin += copysize;
++        }
++    }
++    copy_sizes[num_copy_sections++] = bin - s->spx_copy_start_freq;
++
++    for (ch = 1; ch <= s->fbw_channels; ch++) {
++        if (!s->channel_in_spx[ch])
++            continue;
++
++        /* Copy coeffs from normal bands to extension bands */
++        bin = s->spx_start_freq;
++        for (i = 0; i < num_copy_sections; i++) {
++            memcpy(&s->transform_coeffs[ch][bin],
++                   &s->transform_coeffs[ch][s->spx_copy_start_freq],
++                   copy_sizes[i]*sizeof(float));
++            bin += copy_sizes[i];
++        }
++
++        /* Calculate RMS energy for each SPX band. */
++        bin = s->spx_start_freq;
++        for (bnd = 0; bnd < s->num_spx_bands; bnd++) {
++            int bandsize = s->spx_band_sizes[bnd];
++            float accum = 0.0f;
++            for (i = 0; i < bandsize; i++) {
++                float coeff = s->transform_coeffs[ch][bin++];
++                accum += coeff * coeff;
++            }
++            rms_energy[bnd] = sqrt(accum / (float)bandsize);
++        }
++
++        /* Apply a notch filter at transitions between normal and extension
++           bands and at all wrap points. */
++        if (s->spx_atten_code[ch] >= 0) {
++            const float *atten_tab = ff_eac3_spx_atten_tab[s->spx_atten_code[ch]];
++            bin = s->spx_start_freq - 2;
++            for (bnd = 0; bnd < s->num_spx_bands; bnd++) {
++                if (wrapflag[bnd]) {
++                    float *coeffs = &s->transform_coeffs[ch][bin];
++                    coeffs[0] *= atten_tab[0];
++                    coeffs[1] *= atten_tab[1];
++                    coeffs[2] *= atten_tab[2];
++                    coeffs[3] *= atten_tab[1];
++                    coeffs[4] *= atten_tab[0];
++                }
++                bin += s->spx_band_sizes[bnd];
++            }
++        }
++
++        /* Apply noise-blended coefficient scaling based on previously
++           calculated RMS energy, blending factors, and SPX coordinates for
++           each band. */
++        bin = s->spx_start_freq;
++        for (bnd = 0; bnd < s->num_spx_bands; bnd++) {
++            float nscale = s->spx_noise_blend[ch][bnd] * rms_energy[bnd];
++            float sscale = s->spx_signal_blend[ch][bnd];
++            for (i = 0; i < s->spx_band_sizes[bnd]; i++) {
++                float noise  = nscale * (((int)av_lfg_get(&s->dith_state))/(float)(1<<31));
++                s->transform_coeffs[ch][bin]   *= sscale;
++                s->transform_coeffs[ch][bin++] += noise;
++            }
++        }
++    }
++}
++
+ /** lrint(M_SQRT2*cos(2*M_PI/12)*(1<<23)) */
+ #define COEFF_0 10273905LL
+ 
+@@ -492,13 +577,11 @@ int ff_eac3_parse_header(AC3DecodeContext *s)
+     }
+ 
+     /* spectral extension attenuation data */
+-    if (parse_spx_atten_data) {
+-        av_log_missing_feature(s->avctx, "Spectral extension attenuation", 1);
+-        for (ch = 1; ch <= s->fbw_channels; ch++) {
+-            if (get_bits1(gbc)) { // channel has spx attenuation
+-                skip_bits(gbc, 5); // skip spx attenuation code
+-            }
+-        }
++    for (ch = 1; ch <= s->fbw_channels; ch++) {
++        if (parse_spx_atten_data && get_bits1(gbc))
++            s->spx_atten_code[ch] = get_bits(gbc, 5);
++        else
++            s->spx_atten_code[ch] = -1;
+     }
+ 
+     /* block start information */
+@@ -514,6 +597,7 @@ int ff_eac3_parse_header(AC3DecodeContext *s)
+ 
+     /* syntax state initialization */
+     for (ch = 1; ch <= s->fbw_channels; ch++) {
++        s->first_spx_coords[ch] = 1;
+         s->first_cpl_coords[ch] = 1;
+     }
+     s->first_cpl_leak = 1;



From mean at mail.berlios.de  Thu Aug  6 20:25:23 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Thu, 6 Aug 2009 20:25:23 +0200
Subject: [Avidemux-svn-commit] r5217 - in
	branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreAudio:
	include src
Message-ID: <200908061825.n76IPNao014709@sheep.berlios.de>

Author: mean
Date: 2009-08-06 20:25:23 +0200 (Thu, 06 Aug 2009)
New Revision: 5217

Added:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreAudio/include/ADM_audioStreamEac3.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreAudio/src/ADM_audioStreamEac3.cpp
Modified:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreAudio/src/ADM_audioStream.cpp
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreAudio/src/CMakeLists.txt
Log:
[Codec] EAC3 stream handler

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreAudio/include/ADM_audioStreamEac3.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreAudio/include/ADM_audioStreamEac3.h	2009-08-06 18:25:20 UTC (rev 5216)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreAudio/include/ADM_audioStreamEac3.h	2009-08-06 18:25:23 UTC (rev 5217)
@@ -0,0 +1,45 @@
+/***************************************************************************
+                          ADM_audioStreamAC3.h  -  description
+                             -------------------
+    copyright            : (C) 2008 by mean
+    email                : fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#ifndef ADM_audioStreamEAC3_H
+#define ADM_audioStreamEAC3_H
+
+#include "ADM_audioStreamBuffered.h"
+
+
+/**
+        \fn ADM_audioStreamEAC3
+        \brief Class to handle EAC3/A52B streams
+
+*/
+class ADM_audioStreamEAC3 : public ADM_audioStreamBuffered
+{
+        protected:
+        public:
+/// Default constructor
+                       ADM_audioStreamEAC3(WAVHeader *header,ADM_audioAccess *access);  
+/// Destructor
+virtual                 ~ADM_audioStreamEAC3();
+///  Get a packet
+virtual uint8_t         getPacket(uint8_t *buffer,uint32_t *size, uint32_t sizeMax,
+                                uint32_t *nbSample,uint64_t *dts);
+/// Go to a given time, in microseconds
+virtual bool            goToTime(uint64_t nbUs);
+/// Returns or compute duration. If the access cannot provide it, it will be computed here
+        uint64_t        getDurationInUs(void) {return durationInUs;}
+};
+#endif
+// EOF
+

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreAudio/src/ADM_audioStream.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreAudio/src/ADM_audioStream.cpp	2009-08-06 18:25:20 UTC (rev 5216)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreAudio/src/ADM_audioStream.cpp	2009-08-06 18:25:23 UTC (rev 5217)
@@ -7,6 +7,7 @@
 #include "ADM_audioStream.h"
 #include "ADM_audioStreamMP3.h"
 #include "ADM_audioStreamAC3.h"
+#include "ADM_audioStreamEac3.h"
 
 /**
     \fn ADM_audioStream
@@ -134,6 +135,8 @@
 uint32_t size;
     switch(wavheader->encoding)
     {
+        case WAV_EAC3:
+            return new ADM_audioStreamEAC3(wavheader,access);    
         case WAV_AC3:
             return new ADM_audioStreamAC3(wavheader,access);
         case WAV_MP3:

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreAudio/src/ADM_audioStreamEac3.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreAudio/src/ADM_audioStreamEac3.cpp	2009-08-06 18:25:20 UTC (rev 5216)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreAudio/src/ADM_audioStreamEac3.cpp	2009-08-06 18:25:23 UTC (rev 5217)
@@ -0,0 +1,105 @@
+/**
+    \file ADM_audioStreamAC3
+    \brief AC3 Handling class
+
+*/
+#include "ADM_default.h"
+#include "ADM_audioStreamEac3.h"
+#include "ADM_eac3info.h"
+
+/**
+    \fn ADM_audioStreamAC3
+    \brief constructor
+*/
+ADM_audioStreamEAC3::ADM_audioStreamEAC3(WAVHeader *header,ADM_audioAccess *access) : ADM_audioStreamBuffered(header,access)
+{
+    if(access->canGetDuration()==false)
+    {
+        // We can compute the duration from the length
+        float size=access->getLength();
+              size/=header->byterate; // Result is in second
+              size*=1000;
+              size*=1000; // s->us
+              durationInUs=(uint64_t)size;
+    }
+}
+
+/**
+    \fn ADM_audioStream
+    \brief destructor
+*/
+ADM_audioStreamEAC3::~ADM_audioStreamEAC3()
+{
+   
+}
+/**
+    \fn goToTime
+    \brief goToTime
+*/
+bool         ADM_audioStreamEAC3::goToTime(uint64_t nbUs)
+{
+    if(access->canSeekTime()==true)
+    {
+        if( access->goToTime(nbUs)==true)
+        {
+           setDts(nbUs);
+           limit=start=0;
+           refill();
+           return 1;
+        }
+        return 1;
+    }
+    // If CBR we can use the default way
+    return ADM_audioStream::goToTime(nbUs);
+    
+}
+/**
+        \fn getPacket
+*/
+uint8_t ADM_audioStreamEAC3::getPacket(uint8_t *obuffer,
+                                       uint32_t *osize, 
+                                       uint32_t sizeMax,
+                                       uint32_t *nbSample,
+                                       uint64_t *dts)
+{
+#define ADM_LOOK_AHEAD 6 // Need 6 bytes...
+uint8_t data[ADM_LOOK_AHEAD];
+uint32_t offset;
+int size;
+int flags,sample_rate,bit_rate;
+ADM_EAC3_INFO info;
+    while(1)
+    {
+        // Do we have sync ?
+        if(needBytes(ADM_LOOK_AHEAD)==false) return 0;
+        // Peek
+        peek(ADM_LOOK_AHEAD,data);
+        // Search start seq
+        if(buffer[start]!=0x0b || buffer[start+1]!=0x77)
+        {
+            read8();
+            continue;
+        }
+        if(!ADM_EAC3GetInfo(buffer+start, limit-start, &offset,&info))
+        {
+            printf("[EAC3 Stream] Syncing...\n");
+            read8();
+            continue;
+        }
+        // 
+        size= info.frameSizeInBytes;
+        ADM_assert(size<=sizeMax);
+        if(needBytes(size)==false)
+        {
+            return false;
+        }
+        *osize=size;
+        read(size,obuffer);
+        *nbSample=256*6;
+        *dts=lastDts;
+        advanceDtsBySample(*nbSample);
+        return 1;
+    }
+}
+
+// EOF

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreAudio/src/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreAudio/src/CMakeLists.txt	2009-08-06 18:25:20 UTC (rev 5216)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreAudio/src/CMakeLists.txt	2009-08-06 18:25:23 UTC (rev 5217)
@@ -5,6 +5,7 @@
 ADM_audioStreamBuffered.cpp
 ADM_audioStreamMP3.cpp
 ADM_audioStreamAC3.cpp
+ADM_audioStreamEac3.cpp
 )	
 #*************************************************
 #*************************************************



From mean at mail.berlios.de  Thu Aug  6 20:25:25 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Thu, 6 Aug 2009 20:25:25 +0200
Subject: [Avidemux-svn-commit] r5219 -
	branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreAudioParser/src
Message-ID: <200908061825.n76IPPEU014733@sheep.berlios.de>

Author: mean
Date: 2009-08-06 20:25:25 +0200 (Thu, 06 Aug 2009)
New Revision: 5219

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreAudioParser/src/ADM_eac3info.cpp
Log:
[audioParser] EAC3 : Silence

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreAudioParser/src/ADM_eac3info.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreAudioParser/src/ADM_eac3info.cpp	2009-08-06 18:25:24 UTC (rev 5218)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreAudioParser/src/ADM_eac3info.cpp	2009-08-06 18:25:25 UTC (rev 5219)
@@ -29,7 +29,7 @@
 uint32_t of=0;
 
 	*syncoff=of=0;
-     	printf("\n Syncing on %d \n",len);
+ //    	printf("\n Syncing on %d \n",len);
 	// Search for startcode
 	// 0x0b 0x77
 	while(1)
@@ -57,7 +57,7 @@
                 printf("Sync failed..continuing\n");
                 continue;
             }
-            printf("Sync found at offset %"LU"\n",of);
+//            printf("Sync found at offset %"LU"\n",of);
             *syncoff=of;
             info->frequency=(uint32_t)hdr.sample_rate;
             info->byterate=(uint32_t)hdr.bit_rate>>3;



From mean at mail.berlios.de  Thu Aug  6 20:25:24 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Thu, 6 Aug 2009 20:25:24 +0200
Subject: [Avidemux-svn-commit] r5218 -
	branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreAudioParser/src
Message-ID: <200908061825.n76IPOxC014721@sheep.berlios.de>

Author: mean
Date: 2009-08-06 20:25:24 +0200 (Thu, 06 Aug 2009)
New Revision: 5218

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreAudioParser/src/CMakeLists.txt
Log:
[AudioParser] Eac3 fix linking on win32

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreAudioParser/src/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreAudioParser/src/CMakeLists.txt	2009-08-06 18:25:23 UTC (rev 5217)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreAudioParser/src/CMakeLists.txt	2009-08-06 18:25:24 UTC (rev 5218)
@@ -12,6 +12,6 @@
 ADD_DEFINITIONS( "-DCPU_CLIPS_POSITIVE=0 -DCPU_CLIPS_NEGATIVE=0")
 #*************************************************
 ADD_LIBRARY(ADM_audioParser6 SHARED ${ADMaudioParser_SRCS})
-TARGET_LINK_LIBRARIES(ADM_audioParser6 ADM_core6 ADM_coreUI6)
+TARGET_LINK_LIBRARIES(ADM_audioParser6 ADM_core6 ADM_coreUI6  ADM_libavcodec6 ADM_libavformat6 ADM_libavutil6)
 
 ADM_INSTALL_LIB(ADM_audioParser6)



From mean at mail.berlios.de  Thu Aug  6 20:25:27 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Thu, 6 Aug 2009 20:25:27 +0200
Subject: [Avidemux-svn-commit] r5220 -
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDecoders/ADM_ad_lav
Message-ID: <200908061825.n76IPRKQ014746@sheep.berlios.de>

Author: mean
Date: 2009-08-06 20:25:27 +0200 (Thu, 06 Aug 2009)
New Revision: 5220

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDecoders/ADM_ad_lav/ADM_ad_lav.cpp
Log:
[audioDecoder] Lav: pretty up the printf

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDecoders/ADM_ad_lav/ADM_ad_lav.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDecoders/ADM_ad_lav/ADM_ad_lav.cpp	2009-08-06 18:25:25 UTC (rev 5219)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDecoders/ADM_ad_lav/ADM_ad_lav.cpp	2009-08-06 18:25:27 UTC (rev 5220)
@@ -145,7 +145,7 @@
    if(!codec) {ADM_assert(0);}
     if (avcodec_open(_context, codec) < 0)
     {
-        printf("\n Lavc audio decoder init failed !\n");
+        printf("[audioCodec] Lavc audio decoder init failed !\n");
         ADM_assert(0);
     }
     if(!_blockalign)
@@ -153,11 +153,11 @@
       if(_context->block_align) _blockalign=_context->block_align;
       else
       {
-        printf("FFWMA : no blockalign taking 378\n");
+        printf("[ADM_ad_lav] : no blockalign taking 378\n");
         _blockalign=378;
       }
     }
-    printf("FFwma init successful (blockalign %d)\n",info->blockalign);
+    printf("[ADM_ad_lav] init successful (blockalign %d)\n",info->blockalign);
 }
  ADM_AudiocodecWMA::~ADM_AudiocodecWMA()
  {
@@ -197,13 +197,13 @@
 
           if(out<0)
           {
-            printf( " *** WMA decoding error (%u)***\n",_blockalign);
+            printf( "[ADM_ad_lav] *** WMA decoding error (%u)***\n",_blockalign);
             _head+=1; // Try skipping some bytes
             continue;
           }
           if(pout>=SCRATCH_PAD_SIZE)
           {
-            printf("Produced : %u, buffer %u,in%u\n",pout,SCRATCH_PAD_SIZE,_tail-_head);
+            printf("[ADM_ad_lav]Produced : %u, buffer %u,in%u\n",pout,SCRATCH_PAD_SIZE,_tail-_head);
             ADM_assert(0);
           }
           if(_context->codec_id == CODEC_ID_NELLYMOSER)



From mean at mail.berlios.de  Fri Aug  7 09:08:52 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Fri, 7 Aug 2009 09:08:52 +0200
Subject: [Avidemux-svn-commit] r5221 - in
	branches/avidemux_2.6_branch_mean/avidemux/common: . ADM_editor
Message-ID: <200908070708.n7778qZj004534@sheep.berlios.de>

Author: mean
Date: 2009-08-07 09:08:49 +0200 (Fri, 07 Aug 2009)
New Revision: 5221

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/gtk_gui.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/gui_action.names
Log:
[UI/audio] Menu to select audio track, fixes #18

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.cpp	2009-08-06 18:25:27 UTC (rev 5220)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.cpp	2009-08-07 07:08:49 UTC (rev 5221)
@@ -758,10 +758,11 @@
   return 1;
 
 }
-//******************************
-// Select audio track
-//
-//******************************
+/**
+    \fn getAudioStreamsInfo
+    \brief Returns a copy of all audio trackes at frame frame
+    call delete [] infos when you dont need them anymore
+*/
 uint8_t ADM_Composer::getAudioStreamsInfo(uint32_t frame,uint32_t *nbStreams, audioInfo **infos)
 {
 uint32_t seg,rel,reference;
@@ -784,11 +785,12 @@
         for(int i=0;i<*nbStreams;i++)
         {
             WAVHeader *wav=&(_videos[reference].audioTracks[i]->wavheader);
-            (*infos)->bitrate=(wav->byterate*8)/1000;
-            (*infos)->channels=wav->channels;
-            (*infos)->encoding=wav->encoding;
-            (*infos)->frequency=wav->frequency;
-            (*infos)->av_sync=0;
+            audioInfo *t=(*infos)+i;
+            t->bitrate=(wav->byterate*8)/1000;
+            t->channels=wav->channels;
+            t->encoding=wav->encoding;
+            t->frequency=wav->frequency;
+            t->av_sync=0;
          }
         return 1;
     return 0;

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/gtk_gui.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/gtk_gui.cpp	2009-08-06 18:25:27 UTC (rev 5220)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/gtk_gui.cpp	2009-08-07 07:08:49 UTC (rev 5221)
@@ -1001,114 +1001,46 @@
       \brief Allow to select audio track
 */
 void A_audioTrack( void )
-{
-#if 0
-        uint32_t nb;
+{        
         audioInfo *infos=NULL;
+        uint32_t nbAudioTracks,currentAudioTrack;
+        uint32_t newTrack;
 
-        uint32_t old,nw;
-        uint8_t r=0;
-        uint32_t oldtrack,newtrack;
-        char *newtrackname=ADM_strdup(currentAudioName);
-
-        if(!video_body->getAudioStreamsInfo(0,&nb, &infos))
-        {
-          GUI_Error_HIG(QT_TR_NOOP("Could not get tracks info"), NULL);
-                return ;
-        }
-        newtrack=oldtrack=(uint32_t)video_body->getCurrentAudioStreamNumber(0);
-        nw=old=currentAudioSource;
-
-        /* Build dialog factory widget */
-        diaMenuEntry sourcesStream[]={
-            {AudioAvi,QT_TR_NOOP("Video"),QT_TR_NOOP("Take audio from video file")},
-            {AudioNone,QT_TR_NOOP("None"),QT_TR_NOOP("No audio")},
-            {AudioAC3,QT_TR_NOOP("External AC3"),QT_TR_NOOP("Take audio from external AC3 file")},
-            {AudioMP3,QT_TR_NOOP("External MP3"),QT_TR_NOOP("Take audio from external MP3 file")},
-            {AudioWav,QT_TR_NOOP("External WAV"),QT_TR_NOOP("Take audio from external WAV file")}
-        };
-
-
-        diaElemMenu   sourceMenu(&nw,QT_TR_NOOP("_Audio source:"),5,sourcesStream,NULL);
-
-
-
-        diaElemFile  sourceName(0,&newtrackname,QT_TR_NOOP("_External file:"), NULL, QT_TR_NOOP("Select file"));
-
+        if(!video_body->getAudioStreamsInfo(0,&nbAudioTracks,&infos)) return;
+        currentAudioTrack=video_body->getCurrentAudioStreamNumber(0);
+        newTrack=currentAudioTrack;
         // Now build the list of embedded track
 #define MAX_AUDIO_TRACK 10
 #define MAX_AUDIO_TRACK_NAME 100
         diaMenuEntryDynamic *sourceavitracks[MAX_AUDIO_TRACK];
         char string[MAX_AUDIO_TRACK_NAME];
-        for(int i=0;i<nb;i++)
+        for(int i=0;i<nbAudioTracks;i++)
         {
-          sprintf(string,"Audio track %d (%s/%d channels/%d kbit per s/%d ms shift)",i,getStrFromAudioCodec(infos[i].encoding),
-                        infos[i].channels,infos[i].bitrate,infos[i].av_sync);
+          sprintf(string,"Audio track %d (%s, %d channels, %d kbit/s)",i,
+                        getStrFromAudioCodec(infos[i].encoding),
+                        infos[i].channels,infos[i].bitrate);
            sourceavitracks[i]=new diaMenuEntryDynamic(i,string,NULL);
         }
          if(infos) delete [] infos;
 
-         diaElemMenuDynamic   sourceFromVideo(&newtrack,QT_TR_NOOP("_Track from video:"),nb,sourceavitracks);
-         diaElem *allWidgets[]={&sourceMenu,&sourceFromVideo,&sourceName};
+         diaElemMenuDynamic   sourceFromVideo(&newTrack,QT_TR_NOOP("_Track from video:"),nbAudioTracks,sourceavitracks);
+         diaElem *allWidgets[]={&sourceFromVideo};
 
-         /* Link..*/
-         sourceMenu.link(&(sourcesStream[0]),1,&sourceFromVideo);
-         sourceMenu.link(&(sourcesStream[2]),1,&sourceName);
-         sourceMenu.link(&(sourcesStream[3]),1,&sourceName);
-         sourceMenu.link(&(sourcesStream[4]),1,&sourceName);
-
-
-         if( diaFactoryRun(QT_TR_NOOP("Main Audio Track"),3,allWidgets))
+         if( diaFactoryRun(QT_TR_NOOP("Main Audio Track"),1,allWidgets))
          {
-           if(nw!=AudioNone && nw!=AudioAvi)
-           {
-              if( !ADM_fileExist(newtrackname))
-              {
-                GUI_Info_HIG(ADM_LOG_INFO,QT_TR_NOOP("Cannot load"),QT_TR_NOOP("The selected audio file does not exist."));
-                goto roger_and_out;
-              }
-           }
-            switch( nw)
+            if(newTrack!=currentAudioTrack)
             {
-                    case AudioMP3:
-                            if( ADM_fileExist(newtrackname))
-                              A_loadMP3(newtrackname);
-                            break;
-                    case AudioAC3:
-                            if( ADM_fileExist(newtrackname))
-                              A_loadAC3(newtrackname);
-                            break;
-                    case AudioWav:
-                            if( ADM_fileExist(newtrackname))
-                              A_loadWave(newtrackname);
-                            break;
-                    case AudioNone:
-//                              A_changeAudioStream((AVDMGenericAudioStream *) NULL, AudioNone,NULL);
-                            break;
-                    case AudioAvi:
-                            //printf("New :%d old:%d\n",newtrack,oldtrack);
-                            if(oldtrack!=newtrack)
-                            {
-                                    video_body->changeAudioStream(0,newtrack);
-                                    //
-                                    if(aviaudiostream==currentaudiostream)
-                                            currentaudiostream=NULL;
-                                    delete aviaudiostream;
-                                    aviaudiostream=NULL;
-                                    video_body->getAudioStream(&aviaudiostream);
-                            }
-                            A_changeAudioStream (aviaudiostream, AudioAvi,NULL);
-                            break;
-                    default:
-                            ADM_assert(0);
+                    video_body->changeAudioStream(0,newTrack);
+                    video_body->getAudioStream(&aviaudiostream);
+            }
         }
-         }
+      
 roger_and_out:
          /* Clean up */
-         for(int i=0;i<nb;i++)
+         for(int i=0;i<nbAudioTracks;i++)
             delete sourceavitracks[i];
         return;
-#endif
+
 }
 /**
         \fn A_externalAudioTrack

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/gui_action.names
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/gui_action.names	2009-08-06 18:25:27 UTC (rev 5220)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/gui_action.names	2009-08-07 07:08:49 UTC (rev 5221)
@@ -15,7 +15,6 @@
 ACT(SaveImg)
 ACT(SaveJPG)
 ACT(SaveBunchJPG)
-ACT(SaveDVDPS)
 ACT(SaveAvi)
 ACT(SaveWave)
 ACT(SaveRaw)



From mean at mail.berlios.de  Fri Aug  7 09:08:57 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Fri, 7 Aug 2009 09:08:57 +0200
Subject: [Avidemux-svn-commit] r5222 - in
	branches/avidemux_2.6_branch_mean/avidemux/common: ADM_codecs
	ADM_editor
Message-ID: <200908070708.n7778vOC004565@sheep.berlios.de>

Author: mean
Date: 2009-08-07 09:08:54 +0200 (Fri, 07 Aug 2009)
New Revision: 5222

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_ffmp43.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRender.cpp
Log:
[UI/audio] Menu to select audio track, fixes #18

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_ffmp43.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_ffmp43.cpp	2009-08-07 07:08:49 UTC (rev 5221)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_ffmp43.cpp	2009-08-07 07:08:54 UTC (rev 5222)
@@ -362,18 +362,23 @@
   if (in->dataLength == 0 && !_allowNull)	// Null frame, silently skipped
     {
       
-      printf ("[lavc] null frame\n");
-      {
+      printf ("[Codec] null frame\n");
         // search the last image
-        if (_context->coded_frame && _context->coded_frame->data)
+        if (_context->coded_frame && 
+            _context->coded_frame->data &&
+            _context->coded_frame->data[0]
+            )
           {
-            
+            printf("[Codec] Cloning older pic\n");
             clonePic (_context->coded_frame, out);
             out->Pts=ADM_COMPRESSED_NO_PTS;
           }
         else
-          out->_noPicture = 1;
-          }
+            {
+                out->_noPicture = 1;
+                out->Pts=ADM_COMPRESSED_NO_PTS;
+                printf("[Codec] No Picture\n");
+            }
           return 1;
     }
    // Put a safe value....

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRender.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRender.cpp	2009-08-07 07:08:49 UTC (rev 5221)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRender.cpp	2009-08-07 07:08:54 UTC (rev 5222)
@@ -429,7 +429,8 @@
         if(tmpImage->_noPicture && refOnly)
         {
             printf("[decompressImage] NoPicture\n");
-            return false;
+            // Fill in with black
+            return true;
         }
         aprintf("[::Decompress] in:%"LU" out:%"LU" flags:%x\n",in->demuxerPts,out->Pts,out->flags);
 	// If not quant and it is already YV12, we can stop here



From mean at mail.berlios.de  Fri Aug  7 09:09:00 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Fri, 7 Aug 2009 09:09:00 +0200
Subject: [Avidemux-svn-commit] r5223 -
	branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libpostproc
Message-ID: <200908070709.n777907d004575@sheep.berlios.de>

Author: mean
Date: 2009-08-07 09:08:59 +0200 (Fri, 07 Aug 2009)
New Revision: 5223

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libpostproc/postprocess.c
Log:
[postproc] Kill a log too verbose

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libpostproc/postprocess.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libpostproc/postprocess.c	2009-08-07 07:08:54 UTC (rev 5222)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libpostproc/postprocess.c	2009-08-07 07:08:59 UTC (rev 5223)
@@ -1066,8 +1066,8 @@
         }
     }
 
-    av_log(c, AV_LOG_DEBUG, "using npp filters 0x%X/0x%X\n",
-           mode->lumMode, mode->chromMode);
+    // MEANX : SILENCE av_log(c, AV_LOG_DEBUG, "using npp filters 0x%X/0x%X\n",
+           // mode->lumMode, mode->chromMode);
 
     postProcess(src[0], srcStride[0], dst[0], dstStride[0],
                 width, height, QP_store, QPStride, 0, mode, c);



From mean at mail.berlios.de  Fri Aug  7 09:09:02 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Fri, 7 Aug 2009 09:09:02 +0200
Subject: [Avidemux-svn-commit] r5224 -
	branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor
Message-ID: <200908070709.n77792nn004585@sheep.berlios.de>

Author: mean
Date: 2009-08-07 09:09:02 +0200 (Fri, 07 Aug 2009)
New Revision: 5224

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRender.cpp
Log:
[Editor] By default frame 0 is black in case the first frame is a skipped one

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRender.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRender.cpp	2009-08-07 07:08:59 UTC (rev 5223)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRender.cpp	2009-08-07 07:09:02 UTC (rev 5224)
@@ -164,6 +164,10 @@
          }
          // Now uncompress it...
          result=cache->getFreeImage();
+         if(frame==0) // out first frame, make sure it starts black to avoid the all green effect
+         {
+            result->blacken();
+         }
          if(!result)
          {
                 printf("[DecodePictureUpToIntra] Cache full for frame %"LU"\n",vid->lastSentFrame);



From mean at mail.berlios.de  Fri Aug  7 10:02:54 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Fri, 7 Aug 2009 10:02:54 +0200
Subject: [Avidemux-svn-commit] r5225 -
	branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_mp4
Message-ID: <200908070802.n7782sPf010925@sheep.berlios.de>

Author: mean
Date: 2009-08-07 10:02:54 +0200 (Fri, 07 Aug 2009)
New Revision: 5225

Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_mp4/ADM_mp4Analyzer.cpp
Log:
[Demuxer/mp4] dont divide by 0 when STSD is full of zeroes for audio track

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_mp4/ADM_mp4Analyzer.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_mp4/ADM_mp4Analyzer.cpp	2009-08-07 07:09:02 UTC (rev 5224)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_mp4/ADM_mp4Analyzer.cpp	2009-08-07 08:02:54 UTC (rev 5225)
@@ -759,6 +759,7 @@
                                 left-=4;
                                 if(atomVersion)
                                 {
+                                         #define ADM_NOT_NULL(x)          if(!info.x) info.x=1;
                                     info.samplePerPacket=son.read32();
                                     info.bytePerPacket=son.read32();
                                     info.bytePerFrame=son.read32();
@@ -766,6 +767,10 @@
                                     printf("[STSD] Bytes per packet  %u\n",info.bytePerPacket);
                                     printf("[STSD] Bytes per frame   %u\n",info.bytePerFrame);
                                     printf("[STSD] Bytes per sample   %u\n",son.read32());
+                                     ADM_NOT_NULL(samplePerPacket);  
+                                    ADM_NOT_NULL(bytePerPacket);
+                                    ADM_NOT_NULL(bytePerFrame);
+
                                     left-=16;
                                 }else
                                 {



From mean at mail.berlios.de  Fri Aug  7 10:04:26 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Fri, 7 Aug 2009 10:04:26 +0200
Subject: [Avidemux-svn-commit] r5226 -
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Mp4
Message-ID: <200908070804.n7784Q7o011386@sheep.berlios.de>

Author: mean
Date: 2009-08-07 10:04:26 +0200 (Fri, 07 Aug 2009)
New Revision: 5226

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Mp4/ADM_mp4Analyzer.cpp
Log:
[Mov] dont crash if stsd is full of zeroes, refs #20

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Mp4/ADM_mp4Analyzer.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Mp4/ADM_mp4Analyzer.cpp	2009-08-07 08:02:54 UTC (rev 5225)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Mp4/ADM_mp4Analyzer.cpp	2009-08-07 08:04:26 UTC (rev 5226)
@@ -758,13 +758,19 @@
                                 left-=4;
                                 if(atomVersion)
                                 {
+                                    
                                     info.samplePerPacket=son.read32();
                                     info.bytePerPacket=son.read32();
                                     info.bytePerFrame=son.read32();
+                                        #define ADM_NOT_NULL(x)          if(!info.x) info.x=1;
                                     printf("[STSD] Sample per packet %u\n",info.samplePerPacket);
                                     printf("[STSD] Bytes per packet  %u\n",info.bytePerPacket);
                                     printf("[STSD] Bytes per frame   %u\n",info.bytePerFrame);
                                     printf("[STSD] Bytes per sample   %u\n",son.read32());
+                                    ADM_NOT_NULL(samplePerPacket);  
+                                    ADM_NOT_NULL(bytePerPacket);
+                                    ADM_NOT_NULL(bytePerFrame);
+                                    
                                     left-=16;
                                 }else
                                 {
@@ -1129,3 +1135,4 @@
 
 // EOF
 
+



From mean at mail.berlios.de  Sun Aug  9 19:38:08 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sun, 9 Aug 2009 19:38:08 +0200
Subject: [Avidemux-svn-commit] r5227 - in
	branches/avidemux_2.6_branch_mean/avidemux/gtk: . ADM_UIs/src
Message-ID: <200908091738.n79Hc80u022342@sheep.berlios.de>

Author: mean
Date: 2009-08-09 19:38:07 +0200 (Sun, 09 Aug 2009)
New Revision: 5227

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/gtk/ADM_UIs/src/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/avidemux/gtk/CMakeLists.txt
Log:
[UI/Gtk] Rename also UIGtk to UIGtk6 to avoid clash with 2.5

Modified: branches/avidemux_2.6_branch_mean/avidemux/gtk/ADM_UIs/src/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/gtk/ADM_UIs/src/CMakeLists.txt	2009-08-07 08:04:26 UTC (rev 5226)
+++ branches/avidemux_2.6_branch_mean/avidemux/gtk/ADM_UIs/src/CMakeLists.txt	2009-08-09 17:38:07 UTC (rev 5227)
@@ -1,4 +1,4 @@
-SET(ADM_LIB ADM_UIGtk)
+SET(ADM_LIB ADM_UIGtk6)
 
 SET(${ADM_LIB}_SRCS
 	DIA_color.cpp

Modified: branches/avidemux_2.6_branch_mean/avidemux/gtk/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/gtk/CMakeLists.txt	2009-08-07 08:04:26 UTC (rev 5226)
+++ branches/avidemux_2.6_branch_mean/avidemux/gtk/CMakeLists.txt	2009-08-09 17:38:07 UTC (rev 5227)
@@ -67,7 +67,7 @@
 #############################################
 # Add gtk specific libs
 #############################################
-TARGET_LINK_LIBRARIES(avidemux3_gtk ADM_UIGtk)
+TARGET_LINK_LIBRARIES(avidemux3_gtk ADM_UIGtk6)
 TARGET_LINK_LIBRARIES(avidemux3_gtk ADM_dialogGtk)
 #TARGET_LINK_LIBRARIES(avidemux3_gtk ADM_filtersGtk)
 TARGET_LINK_LIBRARIES(avidemux3_gtk ADM_gui2Gtk)



From mean at mail.berlios.de  Sun Aug  9 19:38:13 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sun, 9 Aug 2009 19:38:13 +0200
Subject: [Avidemux-svn-commit] r5229 -
	branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs
Message-ID: <200908091738.n79HcDdf022377@sheep.berlios.de>

Author: mean
Date: 2009-08-09 19:38:12 +0200 (Sun, 09 Aug 2009)
New Revision: 5229

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_ffmp43.cpp
Log:
[main/codec] Dont use 2 lines for each lavcodec log

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_ffmp43.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_ffmp43.cpp	2009-08-09 17:38:09 UTC (rev 5228)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_ffmp43.cpp	2009-08-09 17:38:12 UTC (rev 5229)
@@ -814,7 +814,7 @@
     char buf[256];
   
     vsnprintf(buf, sizeof(buf), fmt, list);
-    printf("[lavc] %s\n",buf);
+    printf("[lavc] %s",buf);
 }
 
 void ADM_lavDestroy(void)



From mean at mail.berlios.de  Sun Aug  9 19:38:15 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sun, 9 Aug 2009 19:38:15 +0200
Subject: [Avidemux-svn-commit] r5230 -
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDecoders/ADM_ad_lav
Message-ID: <200908091738.n79HcFhs022401@sheep.berlios.de>

Author: mean
Date: 2009-08-09 19:38:15 +0200 (Sun, 09 Aug 2009)
New Revision: 5230

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDecoders/ADM_ad_lav/ADM_ad_lav.cpp
Log:
[codec] Lavcodec used for audio, remap correctly channels so that 5.0 and 5.1 are downmixed correctly to stereo, fixes #21

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDecoders/ADM_ad_lav/ADM_ad_lav.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDecoders/ADM_ad_lav/ADM_ad_lav.cpp	2009-08-09 17:38:12 UTC (rev 5229)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDecoders/ADM_ad_lav/ADM_ad_lav.cpp	2009-08-09 17:38:15 UTC (rev 5230)
@@ -26,6 +26,7 @@
 		uint8_t _buffer[ ADMWA_BUF];
 		uint32_t _tail,_head;
 		uint32_t _blockalign;
+        uint32_t channels;
 
 	public:
 		ADM_AudiocodecWMA(uint32_t fourcc, WAVHeader *info, uint32_t l, uint8_t *d);
@@ -88,8 +89,10 @@
  ADM_AudiocodecWMA::ADM_AudiocodecWMA(uint32_t fourcc,WAVHeader *info,uint32_t l,uint8_t *d)
        :  ADM_Audiocodec(fourcc)
  {
+    printf(" [ADM_AD_LAV] Using decoder for type 0x%x\n",info->encoding);
+    printf(" [ADM_AD_LAV] #of channels %d\n",info->channels);
     _tail=_head=0;
-
+    channels=info->channels;
     _contextVoid=(void *)avcodec_alloc_context();
     ADM_assert(_contextVoid);
     // Fills in some values...
@@ -136,9 +139,14 @@
       default:
              ADM_assert(0);
     }
+
+
+
+
+
     _context->extradata=(uint8_t *)d;
     _context->extradata_size=(int)l;
-    //printf(" Using %"LU" bytes of extra header data\n",l);
+    printf("[ADM_AD_LAV] Using %d bytes of extra header data\n", _context->extradata_size);
     mixDump((uint8_t *)_context->extradata,_context->extradata_size);
 
    AVCodec *codec=avcodec_find_decoder(_context->codec_id);
@@ -158,6 +166,7 @@
       }
     }
     printf("[ADM_ad_lav] init successful (blockalign %d)\n",info->blockalign);
+  
 }
  ADM_AudiocodecWMA::~ADM_AudiocodecWMA()
  {
@@ -206,6 +215,9 @@
             printf("[ADM_ad_lav]Produced : %u, buffer %u,in%u\n",pout,SCRATCH_PAD_SIZE,_tail-_head);
             ADM_assert(0);
           }
+
+//            printf("Channel layout :%llx\n",_context->channel_layout);
+
           if(_context->codec_id == CODEC_ID_NELLYMOSER)
           { // Hack, it returns inconsistent size
             out=nbChunk*_blockalign;
@@ -218,6 +230,18 @@
           {
             *outptr++=((float)run16[i])/32767.;
           }
+          if(channels>=5 )
+            {
+            CHANNEL_TYPE *p_ch_type = channelMapping;
+        #define DOIT(x,y) if(_context->channel_layout & CH_##x) *(p_ch_type++)=ADM_CH_##y;
+                DOIT(LOW_FREQUENCY,LFE);
+                DOIT(FRONT_LEFT,FRONT_LEFT);
+                DOIT(FRONT_CENTER,FRONT_CENTER);
+                DOIT(FRONT_RIGHT,FRONT_RIGHT);
+                DOIT(SIDE_LEFT,REAR_LEFT);
+                DOIT(SIDE_RIGHT,REAR_RIGHT);
+
+            }
         }
         return 1;
 }



From mean at mail.berlios.de  Sun Aug  9 19:38:11 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sun, 9 Aug 2009 19:38:11 +0200
Subject: [Avidemux-svn-commit] r5228 -
	branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audioFilter/src
Message-ID: <200908091738.n79HcBUh022359@sheep.berlios.de>

Author: mean
Date: 2009-08-09 19:38:09 +0200 (Sun, 09 Aug 2009)
New Revision: 5228

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audioFilter/src/audiofilter_mixer.cpp
Log:
[mixer] re-enable dolby etc..

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audioFilter/src/audiofilter_mixer.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audioFilter/src/audiofilter_mixer.cpp	2009-08-09 17:38:07 UTC (rev 5227)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audioFilter/src/audiofilter_mixer.cpp	2009-08-09 17:38:09 UTC (rev 5228)
@@ -450,7 +450,7 @@
 static int MDolbyProLogic(float *in,float *out,uint32_t nbSample,uint32_t chan,CHANNEL_TYPE *chanMap)
 {
 	memset(out, 0, sizeof(float) * nbSample * 2);
-#if 0
+
 	for (int i = 0; i < nbSample; i++) {
 		for (int c = 0; c < chan; c++) {
 			switch (chanMap[c]) {
@@ -487,14 +487,14 @@
 		}
 		out += 2;
 	}
-#endif
+
 	return nbSample*2;
 }
 
 static int MDolbyProLogic2(float *in,float *out,uint32_t nbSample,uint32_t chan,CHANNEL_TYPE *chanMap)
 {
 	memset(out, 0, sizeof(float) * nbSample * 2);
-#if 0
+
 	for (int i = 0; i < nbSample; i++) {
 		for (int c = 0; c < chan; c++) {
 			switch (chanMap[c]) {
@@ -537,7 +537,7 @@
 		}
 		out += 2;
 	}
-#endif
+
 	return nbSample*2;
 }
 



From gruntster at mail.berlios.de  Mon Aug 10 23:25:31 2009
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Mon, 10 Aug 2009 23:25:31 +0200
Subject: [Avidemux-svn-commit] r5231 -
	branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_avcodec
Message-ID: <200908102125.n7ALPVCH012164@sheep.berlios.de>

Author: gruntster
Date: 2009-08-10 23:25:25 +0200 (Mon, 10 Aug 2009)
New Revision: 5231

Modified:
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_avcodec/encoder.cpp
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_avcodec/encoder.h
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_avcodec/mpeg1Encoder.cpp
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_avcodec/mpeg1Encoder.h
Log:
[mpeg1] two pass logic for mpeg-1 plugin (incomplete)

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_avcodec/encoder.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_avcodec/encoder.cpp	2009-08-09 17:38:15 UTC (rev 5230)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_avcodec/encoder.cpp	2009-08-10 21:25:25 UTC (rev 5231)
@@ -155,16 +155,19 @@
 	_passCount = 1;
 	_currentPass = 0;
 	_openPass = false;
+	_context = NULL;
 
 	_supportedCsps[0] = targetColourSpace;
 }
 
-void AvcodecEncoder::initContext(vidEncVideoProperties *properties)
+int AvcodecEncoder::initContext(const char* logFileName)
 {
-	_context->width = properties->width;
-	_context->height = properties->height;
-	_context->time_base = (AVRational){properties->fpsDen, properties->fpsNum};
+	_context->width = _width;
+	_context->height = _height;
+	_context->time_base = (AVRational){_fpsDen, _fpsNum};
 	_context->pix_fmt = getAvCodecColourSpace(_supportedCsps[0]);
+
+	return ADM_VIDENC_ERR_SUCCESS;
 }
 
 AVCodec *AvcodecEncoder::getAvCodec(void)
@@ -256,31 +259,18 @@
 
 	_opened = true;
 	_currentPass = 0;
-	_context = avcodec_alloc_context();
 
-	if (!_context)
-		return ADM_VIDENC_ERR_FAILED;
-
-	memset(&_frame, 0, sizeof(_frame));
-	_frame.pts = AV_NOPTS_VALUE;
-
 	properties->supportedCspsCount = 1;
 	properties->supportedCsps = &_supportedCsps[0];
 
-	initContext(properties);
+	_width = properties->width;
+	_height = properties->height;
 
-	AVCodec *codec = getAvCodec();
+	_fpsNum = properties->fpsNum;
+	_fpsDen = properties->fpsDen;
 
-	if (!codec)
-		return ADM_VIDENC_ERR_FAILED;
+	_frameCount = properties->frameCount;
 
-	if (avcodec_open(_context, codec) < 0)
-	{
-		close();
-
-		return ADM_VIDENC_ERR_FAILED;
-	}
-
 	return ADM_VIDENC_ERR_SUCCESS;
 }
 
@@ -301,22 +291,44 @@
 		return ADM_VIDENC_ERR_PASS_SKIP;
 	}
 
-	if (!_buffer)
+	_openPass = true;
+	_currentPass++;
+	_context = avcodec_alloc_context();
+
+	if (!_context)
+		return ADM_VIDENC_ERR_FAILED;
+
+	memset(&_frame, 0, sizeof(_frame));
+	_frame.pts = AV_NOPTS_VALUE;
+
+	int ret = initContext(passParameters->logFileName);
+
+	if (ret != ADM_VIDENC_ERR_SUCCESS)
+		return ret;
+
+	AVCodec *codec = getAvCodec();
+
+	if (!codec)
+		return ADM_VIDENC_ERR_FAILED;
+
+	if (avcodec_open(_context, codec) < 0)
 	{
-		AVPicture encodedPicture;
+		//this->printContext();
+		finishPass();
 
-		_bufferSize = avpicture_fill(&encodedPicture, NULL, _context->pix_fmt, _context->width, _context->height);
-		_buffer = new uint8_t[_bufferSize];
+		return ADM_VIDENC_ERR_FAILED;
 	}
 
-	_openPass = true;
-	_currentPass++;
+	//this->printContext();
 
+	AVPicture encodedPicture;
+
+	_bufferSize = avpicture_fill(&encodedPicture, NULL, _context->pix_fmt, _context->width, _context->height);
+	_buffer = new uint8_t[_bufferSize];
+
 	passParameters->extraData = _context->extradata;
 	passParameters->extraDataSize = _context->extradata_size;
 
-	//this->printContext();
-
 	return ADM_VIDENC_ERR_SUCCESS;
 }
 
@@ -365,17 +377,6 @@
 	if (_openPass)
 		_openPass = false;
 
-	return ADM_VIDENC_ERR_SUCCESS;
-}
-
-int AvcodecEncoder::close(void)
-{
-	if (_openPass)
-		finishPass();
-
-	_opened = false;
-	_currentPass = 0;
-
 	if (_context)
 	{
 		avcodec_close(_context);
@@ -391,6 +392,17 @@
 	return ADM_VIDENC_ERR_SUCCESS;
 }
 
+int AvcodecEncoder::close(void)
+{
+	if (_openPass)
+		finishPass();
+
+	_opened = false;
+	_currentPass = 0;
+
+	return ADM_VIDENC_ERR_SUCCESS;
+}
+
 void AvcodecEncoder::printContext(void)
 {
 	printf("bit_rate: %d\n", _context->bit_rate);

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_avcodec/encoder.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_avcodec/encoder.h	2009-08-09 17:38:15 UTC (rev 5230)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_avcodec/encoder.h	2009-08-10 21:25:25 UTC (rev 5231)
@@ -30,13 +30,14 @@
 
 class AvcodecEncoder
 {
-	private:
-		void printContext(void);
-
 	protected:
 		enum CodecID _codecId;
 		int _supportedCsps[1];
 
+		unsigned int _width, _height;
+		unsigned int _fpsNum, _fpsDen;
+		unsigned int _frameCount;
+
 		int _currentPass, _passCount;
 		bool _opened, _openPass;
 
@@ -47,11 +48,12 @@
 		uint8_t *_buffer;
 
 		virtual void init(enum CodecID id, int targetColourSpace);
-		virtual void initContext(vidEncVideoProperties *properties);
+		virtual int initContext(const char* logFileName);
 		AVCodec *getAvCodec(void);
 		enum PixelFormat getAvCodecColourSpace(int colourSpace);
 		virtual int getFrameType(void);
 		virtual void updateEncodeParameters(vidEncEncodeParameters *encodeParams, uint8_t *buffer, int bufferSize);
+		void printContext(void);
 
 	public:
 		virtual ~AvcodecEncoder(void);

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_avcodec/mpeg1Encoder.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_avcodec/mpeg1Encoder.cpp	2009-08-09 17:38:15 UTC (rev 5230)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_avcodec/mpeg1Encoder.cpp	2009-08-10 21:25:25 UTC (rev 5231)
@@ -23,6 +23,10 @@
 static char *serializeConfig(void);
 static Mpeg1Encoder *encoder = NULL;
 
+#ifdef __WIN32
+extern void convertPathToAnsi(const char *path, char **ansiPath);
+#endif
+
 Mpeg1Encoder::Mpeg1Encoder(void)
 {
 	encoder = this;
@@ -37,11 +41,14 @@
 	_bitrateParam.qz = DEFAULT_ENCODE_MODE_PARAMETER;
 	_bitrateParam.avg_bitrate = 1000;
 	_bitrateParam.finalsize = 700;
+
+	_statFile = NULL;
 }
 
-void Mpeg1Encoder::initContext(vidEncVideoProperties *properties)
+int Mpeg1Encoder::initContext(const char* logFileName)
 {
-	AvcodecEncoder::initContext(properties);
+	AvcodecEncoder::initContext(logFileName);
+	int ret = ADM_VIDENC_ERR_SUCCESS;
 
 	_context->gop_size = _options.getGopSize();
 
@@ -93,11 +100,79 @@
 	_context->scenechange_threshold = 0xfffffff;
 	_context->rc_max_rate_header = _options.getMaxBitrate() * 1000;
 	_context->rc_buffer_size_header = _options.getBufferSize() * 8 * 1024;
-	_context->rc_max_rate = _context->rc_max_rate_header;
-	_context->rc_buffer_size = _context->rc_buffer_size_header;
+	_context->dark_masking = 0.01;
+	_context->rc_qsquish = 1.0;
 
-	if (_encodeOptions.encodeMode == ADM_VIDENC_MODE_CQP)
+	if (_currentPass == 1)
+	{
+		_context->bit_rate = 0;
+		_context->bit_rate_tolerance = 1024 * 8 * 1000;
 		_context->flags |= CODEC_FLAG_QSCALE;
+
+		if (_passCount > 1)
+			_context->flags |= CODEC_FLAG_PASS1;
+	}
+	else 
+	{
+		if (_encodeOptions.encodeMode == ADM_VIDENC_MODE_2PASS_SIZE)
+			_context->bit_rate = calculateBitrate(_fpsNum, _fpsDen, _frameCount, _encodeOptions.encodeModeParameter);
+		else
+			_context->bit_rate = _encodeOptions.encodeModeParameter * 1000;
+
+		if (_context->bit_rate > _options.getMaxBitrate() * 1000)
+			_context->bit_rate = _options.getMaxBitrate() * 1000;
+
+		_context->bit_rate_tolerance = 8000000;
+		_context->flags |= CODEC_FLAG_PASS2;
+	}
+
+	if (_encodeOptions.encodeMode == ADM_VIDENC_MODE_2PASS_SIZE || _encodeOptions.encodeMode == ADM_VIDENC_MODE_2PASS_ABR)
+	{
+		char *log = NULL;
+
+#ifdef __WIN32
+		convertPathToAnsi(logFileName, &log);
+#else
+		log = new char[strlen(logFileName) + 1];
+		strcpy(log, logFileName);
+#endif
+
+		if (_currentPass == 1)
+		{
+			_statFile = fopen(log, "wb");
+
+			if (!_statFile)
+				ret = ADM_VIDENC_ERR_FAILED;
+		}
+		else
+		{
+			FILE *statFile = fopen(log, "rb");
+
+			if (statFile)
+			{
+				fseek(statFile, 0, SEEK_END);
+
+				long statSize = ftello(statFile);
+
+				fseek(statFile, 0, SEEK_SET);
+				_context->stats_in = new char[statSize + 1];
+				_context->stats_in[statSize] = 0;
+
+				fread(_context->stats_in, statSize, 1, statFile);
+				fclose(statFile);
+			}
+			else
+				ret = ADM_VIDENC_ERR_FAILED;
+		}
+	}
+
+	if (_encodeOptions.encodeMode == ADM_VIDENC_MODE_CQP || _currentPass == 2)
+	{
+		_context->rc_max_rate = _context->rc_max_rate_header;
+		_context->rc_buffer_size = _context->rc_buffer_size_header;
+	}
+
+	return ret;
 }
 
 const char* Mpeg1Encoder::getEncoderType(void)
@@ -167,6 +242,7 @@
 	if (diaFactoryRunTabs("avcodec MPEG-1 Configuration", 1, elmHeader, 1, tabs))
 	{
 		saveSettings(&_encodeOptions, &_options);
+		updateEncodeProperties(&_encodeOptions);
 
 		return 1;
 	}
@@ -186,7 +262,7 @@
 		delete [] configurationName;
 	}
 
-	if (configType != CONFIG_MENU_CUSTOM)
+	if (encodeOptions)
 	{
 		_minBitrate = options->getMinBitrate();
 		_maxBitrate = options->getMaxBitrate();
@@ -197,7 +273,7 @@
 		_userMatrix = options->getMatrix();
 		_gopSize = options->getGopSize();
 
-		updateEncodeProperties(encodeOptions, NULL);
+		updateEncodeProperties(encodeOptions);
 	}
 }
 
@@ -218,7 +294,7 @@
 
 			break;
 		case COMPRESS_2PASS_BITRATE:
-			encodeOptions->encodeMode = COMPRESS_2PASS_BITRATE;
+			encodeOptions->encodeMode = ADM_VIDENC_MODE_2PASS_ABR;
 			encodeOptions->encodeModeParameter = _bitrateParam.avg_bitrate;
 
 			break;
@@ -323,7 +399,7 @@
 	if (encodeOptions && success)
 	{
 		memcpy(&_encodeOptions, encodeOptions, sizeof(vidEncOptions));
-		updateEncodeProperties(encodeOptions, NULL);
+		updateEncodeProperties(encodeOptions);
 	}
 
 	if (success)
@@ -332,16 +408,53 @@
 		return ADM_VIDENC_ERR_FAILED;
 }
 
-int Mpeg1Encoder::encodeFrame(vidEncEncodeParameters *encodeParams)
+int Mpeg1Encoder::beginPass(vidEncPassParameters *passParameters)
 {
+	int qz = 0;
+	int ret = AvcodecEncoder::beginPass(passParameters);
+
 	if (_encodeOptions.encodeMode == ADM_VIDENC_MODE_CQP)
-		_frame.quality = (int)floor(FF_QP2LAMBDA * _encodeOptions.encodeModeParameter + 0.5);
+		qz = _encodeOptions.encodeModeParameter;
+	else if (_currentPass == 1)
+		qz = 2;
 
-	return AvcodecEncoder::encodeFrame(encodeParams);
+	if (qz)
+		_frame.quality = (int)floor(FF_QP2LAMBDA * qz + 0.5);
+
+	return ret;
 }
 
-void Mpeg1Encoder::updateEncodeProperties(vidEncOptions *encodeOptions, vidEncVideoProperties *properties)
+int Mpeg1Encoder::finishPass(void)
 {
+	int ret = AvcodecEncoder::finishPass();
+
+	if (_statFile)
+	{
+		fclose(_statFile);
+		_statFile = NULL;
+	}
+
+	if (_context && _context->stats_in)
+	{
+		delete [] _context->stats_in;
+		_context->stats_in = NULL;
+	}
+
+	return ret;
+}
+
+int Mpeg1Encoder::encodeFrame(vidEncEncodeParameters *encodeParams)
+{
+	int ret = AvcodecEncoder::encodeFrame(encodeParams);
+
+	if (_context->stats_out)
+		fprintf (_statFile, "%s", _context->stats_out);
+
+	return ret;
+}
+
+void Mpeg1Encoder::updateEncodeProperties(vidEncOptions *encodeOptions)
+{
 	switch (encodeOptions->encodeMode)
 	{
 		case ADM_VIDENC_MODE_CQP:
@@ -357,11 +470,6 @@
 			_bitrateParam.mode = COMPRESS_2PASS;
 			_bitrateParam.finalsize = encodeOptions->encodeModeParameter;
 
-			//if (properties)
-				//bitrateParam->bitrate = calculateBitrate(properties->fpsNum, properties->fpsDen, properties->frameCount, _encodeOptions.encodeModeParameter) / 1000;					
-			//else
-				//bitrateParam->bitrate = 1500;
-
 			break;
 		case ADM_VIDENC_MODE_2PASS_ABR:
 			_passCount = 2;

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_avcodec/mpeg1Encoder.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_avcodec/mpeg1Encoder.h	2009-08-09 17:38:15 UTC (rev 5230)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_avcodec/mpeg1Encoder.h	2009-08-10 21:25:25 UTC (rev 5231)
@@ -40,12 +40,14 @@
 		Mpeg1EncoderOptions _options;
 		vidEncOptions _encodeOptions;
 
-		void updateEncodeProperties(vidEncOptions *encodeOptions, vidEncVideoProperties *properties);
+		FILE *_statFile;
+
+		void updateEncodeProperties(vidEncOptions *encodeOptions);
 		unsigned int calculateBitrate(unsigned int fpsNum, unsigned int fpsDen, unsigned int frameCount, unsigned int sizeInMb);
 
 	public:
 		Mpeg1Encoder(void);
-		void initContext(vidEncVideoProperties *properties);
+		int initContext(const char* logFileName);
 		const char* getEncoderType(void);
 		const char* getEncoderDescription(void);
 		const char* getFourCC(void);
@@ -56,7 +58,9 @@
 		void saveSettings(vidEncOptions *encodeOptions, Mpeg1EncoderOptions *options);
 		int getOptions(vidEncOptions *encodeOptions, char *pluginOptions, int bufferSize);
 		int setOptions(vidEncOptions *encodeOptions, char *pluginOptions);
+		int beginPass(vidEncPassParameters *passParameters);
 		int encodeFrame(vidEncEncodeParameters *encodeParams);
+		int finishPass(void);
 };
 #endif	// __cplusplus
 #endif	// Mpeg1Encoder_h



From gruntster at mail.berlios.de  Wed Aug 12 10:58:15 2009
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Wed, 12 Aug 2009 10:58:15 +0200
Subject: [Avidemux-svn-commit] r5232 -
	branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/ASharp/qt4
Message-ID: <200908120858.n7C8wFpL024579@sheep.berlios.de>

Author: gruntster
Date: 2009-08-12 10:58:07 +0200 (Wed, 12 Aug 2009)
New Revision: 5232

Modified:
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/ASharp/qt4/asharp.ui
Log:
[asharp] allow disabling of "Block Adaptive" mode (patch by torrentss)

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/ASharp/qt4/asharp.ui
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/ASharp/qt4/asharp.ui	2009-08-10 21:25:25 UTC (rev 5231)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/ASharp/qt4/asharp.ui	2009-08-12 08:58:07 UTC (rev 5232)
@@ -138,7 +138,11 @@
     <widget class="QDoubleSpinBox" name="doubleSpinBoxStrength" />
    </item>
    <item row="2" column="2" >
-    <widget class="QDoubleSpinBox" name="doubleSpinBoxBlock" />
+    <widget class="QDoubleSpinBox" name="doubleSpinBoxBlock">
+     <property name="minimum">
+      <double>-1.000000000000000</double>
+     </property>
+    </widget>
    </item>
   </layout>
  </widget>



From gruntster at mail.berlios.de  Wed Aug 12 11:03:06 2009
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Wed, 12 Aug 2009 11:03:06 +0200
Subject: [Avidemux-svn-commit] r5233 - in
	branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/ASharp:
	gtk qt4
Message-ID: <200908120903.n7C936Pc024966@sheep.berlios.de>

Author: gruntster
Date: 2009-08-12 11:03:01 +0200 (Wed, 12 Aug 2009)
New Revision: 5233

Modified:
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/ASharp/gtk/DIA_asharp.cpp
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/ASharp/qt4/asharp.ui
Log:
[asharp] label block filtering checkbox (patch by torrentss)

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/ASharp/gtk/DIA_asharp.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/ASharp/gtk/DIA_asharp.cpp	2009-08-12 08:58:07 UTC (rev 5232)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/ASharp/gtk/DIA_asharp.cpp	2009-08-12 09:03:01 UTC (rev 5233)
@@ -211,7 +211,7 @@
   gtk_label_set_justify (GTK_LABEL (label3), GTK_JUSTIFY_LEFT);
   gtk_misc_set_alignment (GTK_MISC (label3), 0, 0.5);
 
-  label4 = gtk_label_new (QT_TR_NOOP("Unknown flag :"));
+  label4 = gtk_label_new (QT_TR_NOOP("High Quality Block Filtering :"));
   gtk_widget_show (label4);
   gtk_table_attach (GTK_TABLE (table1), label4, 0, 1, 3, 4,
                     (GtkAttachOptions) (GTK_FILL),

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/ASharp/qt4/asharp.ui
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/ASharp/qt4/asharp.ui	2009-08-12 08:58:07 UTC (rev 5232)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/ASharp/qt4/asharp.ui	2009-08-12 09:03:01 UTC (rev 5233)
@@ -127,7 +127,7 @@
    <item row="3" column="0" colspan="3" >
     <widget class="QCheckBox" name="checkBox" >
      <property name="text" >
-      <string>Unknown flag</string>
+      <string>High Quality Block Filtering</string>
      </property>
     </widget>
    </item>



From gruntster at mail.berlios.de  Wed Aug 12 11:06:33 2009
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Wed, 12 Aug 2009 11:06:33 +0200
Subject: [Avidemux-svn-commit] r5234 -
	branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/lavDeinterlace
Message-ID: <200908120906.n7C96Xtx025637@sheep.berlios.de>

Author: gruntster
Date: 2009-08-12 11:06:28 +0200 (Wed, 12 Aug 2009)
New Revision: 5234

Modified:
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/lavDeinterlace/ADM_lavpp_deint.cpp
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/lavDeinterlace/ADM_lavpp_deintparam.h
Log:
[lavDeinterlace] add lowpass5 support (patch by torrentss; fixes #22)

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/lavDeinterlace/ADM_lavpp_deint.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/lavDeinterlace/ADM_lavpp_deint.cpp	2009-08-12 09:03:01 UTC (rev 5233)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/lavDeinterlace/ADM_lavpp_deint.cpp	2009-08-12 09:06:28 UTC (rev 5234)
@@ -103,16 +103,17 @@
   _in=in;
   
   
-   diaMenuEntry menuField[6]={{PP_BM_NONE,        QT_TR_NOOP("None"),NULL},
+   diaMenuEntry menuField[7]={{PP_BM_NONE,        QT_TR_NOOP("None"),NULL},
                              {PP_BM_LINEAR_BLEND, QT_TR_NOOP("Linear blend"),NULL},
                              {PP_BM_LINEAR_INTER, QT_TR_NOOP("Linear interpolate"),NULL},
                              {PP_BM_CUBIC_INTER, QT_TR_NOOP("Cubic interpolate"),NULL},
                              {PP_BM_MEDIAN_INTER, QT_TR_NOOP("Median interpolate"),NULL},
                              {PP_BM_FFMPEG_DEINT, QT_TR_NOOP("FFmpeg deint"),NULL},
+                             {PP_BM_LOWPASS5_DEINT, QT_TR_NOOP("Lowpass5 deint"),NULL},
                           };
   
     
-    diaElemMenu     menu1(PX(deintType),QT_TR_NOOP("_Deinterlacing:"), 6,menuField);
+    diaElemMenu     menu1(PX(deintType),QT_TR_NOOP("_Deinterlacing:"), 7,menuField);
     diaElemToggle   autolevel(PX(autolevel),QT_TR_NOOP("_Autolevel"));
     
     diaElem *elems[2]={&menu1,&autolevel};
@@ -202,7 +203,8 @@
           case PP_BM_LINEAR_INTER: ADD(li);break;
           case PP_BM_CUBIC_INTER: ADD(ci);break;
           case PP_BM_MEDIAN_INTER: ADD(md);break;
-          case PP_BM_FFMPEG_DEINT: ADD(fd);break;                             
+          case PP_BM_FFMPEG_DEINT: ADD(fd);break;
+          case PP_BM_LOWPASS5_DEINT: ADD(l5);break;
         }        
 
 

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/lavDeinterlace/ADM_lavpp_deintparam.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/lavDeinterlace/ADM_lavpp_deintparam.h	2009-08-12 09:03:01 UTC (rev 5233)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/lavDeinterlace/ADM_lavpp_deintparam.h	2009-08-12 09:06:28 UTC (rev 5234)
@@ -16,7 +16,8 @@
   PP_BM_LINEAR_INTER   =0x0002, 
   PP_BM_CUBIC_INTER    =0x0003, 
   PP_BM_MEDIAN_INTER   =0x0004, 
-  PP_BM_FFMPEG_DEINT   =0x0005,  
+  PP_BM_FFMPEG_DEINT   =0x0005, 
+  PP_BM_LOWPASS5_DEINT   =0x0006, 
 };
 
 typedef struct 



From mean at mail.berlios.de  Wed Aug 12 19:38:53 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Wed, 12 Aug 2009 19:38:53 +0200
Subject: [Avidemux-svn-commit] r5235 -
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioEncoders/lavcodec
Message-ID: <200908121738.n7CHcrad012727@sheep.berlios.de>

Author: mean
Date: 2009-08-12 19:38:52 +0200 (Wed, 12 Aug 2009)
New Revision: 5235

Added:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioEncoders/lavcodec/ADM_lav_aac.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioEncoders/lavcodec/ADM_lav_ac3.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioEncoders/lavcodec/ADM_lav_mp2.h
Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioEncoders/lavcodec/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioEncoders/lavcodec/audioencoder_lavcodec.cpp
Log:
[AudioEncoder] Try to make lav based codec more generic

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioEncoders/lavcodec/ADM_lav_aac.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioEncoders/lavcodec/ADM_lav_aac.h	2009-08-12 09:06:28 UTC (rev 5234)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioEncoders/lavcodec/ADM_lav_aac.h	2009-08-12 17:38:52 UTC (rev 5235)
@@ -0,0 +1,10 @@
+#define Join(x,y) x##_##y
+#define AUDMEncoder_Lavcodec AUDMEncoder_Lavcodec_AAC
+#define makeName(x) Join(x,AAC)
+#define ADM_LAV_VERSION     1,0,0
+#define ADM_LAV_NAME        "LavAAC" 
+#define ADM_LAV_MENU        "AAC (lav)" 
+#define ADM_LAV_DESC        "AAC LavCodec encoder plugin Mean 2008/2009"
+#define ADM_LAV_MAX_CHANNEL 6
+#define ADM_LAV_SAMPLE_PER_P 1024
+

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioEncoders/lavcodec/ADM_lav_ac3.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioEncoders/lavcodec/ADM_lav_ac3.h	2009-08-12 09:06:28 UTC (rev 5234)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioEncoders/lavcodec/ADM_lav_ac3.h	2009-08-12 17:38:52 UTC (rev 5235)
@@ -0,0 +1,10 @@
+#define Join(x,y) x##_##y
+#define AUDMEncoder_Lavcodec AUDMEncoder_Lavcodec_AC3
+#define makeName(x) Join(x,AC3)
+#define ADM_LAV_VERSION     1,0,0
+#define ADM_LAV_NAME        "LavAC3" 
+#define ADM_LAV_MENU        "AC3 (lav)" 
+#define ADM_LAV_DESC        "AC3 LavCodec encoder plugin Mean 2008/2009"
+#define ADM_LAV_MAX_CHANNEL 6
+#define ADM_LAV_SAMPLE_PER_P 1536
+

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioEncoders/lavcodec/ADM_lav_mp2.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioEncoders/lavcodec/ADM_lav_mp2.h	2009-08-12 09:06:28 UTC (rev 5234)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioEncoders/lavcodec/ADM_lav_mp2.h	2009-08-12 17:38:52 UTC (rev 5235)
@@ -0,0 +1,11 @@
+#define Join(x,y) x##_##y
+#define AUDMEncoder_Lavcodec AUDMEncoder_Lavcodec_MP2
+#define makeName(x) Join(x,MP2)
+#define ADM_LAV_VERSION     1,0,0
+#define ADM_LAV_NAME        "LavMP2" 
+#define ADM_LAV_MENU        "MP2 (lav)" 
+#define ADM_LAV_DESC        "MP2 LavCodec encoder plugin Mean 2008/2009"
+#define ADM_LAV_MAX_CHANNEL 6
+#define ADM_LAV_SAMPLE_PER_P 1152
+
+

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioEncoders/lavcodec/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioEncoders/lavcodec/CMakeLists.txt	2009-08-12 09:06:28 UTC (rev 5234)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioEncoders/lavcodec/CMakeLists.txt	2009-08-12 17:38:52 UTC (rev 5235)
@@ -1,21 +1,32 @@
 	INCLUDE(ae_plugin)
-        INCLUDE_DIRECTORIES("${CMAKE_SOURCE_DIR}/../avidemux/")
-        INCLUDE_DIRECTORIES("${CMAKE_SOURCE_DIR}/../avidemux/ADM_libraries/ADM_ffmpeg/")
 
+        include_directories(.)
+#====
 	SET(ADM_ae_lav_mp2_SRCS audioencoder_lavcodec.cpp)
 
 	ADD_LIBRARY(ADM_ae_lav_mp2 SHARED ${ADM_ae_lav_mp2_SRCS})
-	ADD_TARGET_CFLAGS(ADM_ae_lav_mp2 "-DADM_LAV_MP2")
+	ADD_TARGET_CFLAGS(ADM_ae_lav_mp2 "-DADM_AE_SET='\"ADM_lav_mp2.h\"'")
 	TARGET_LINK_LIBRARIES(ADM_ae_lav_mp2  ADM_libavcodec6)
 
 	INIT_AUDIO_ENCODER(ADM_ae_lav_mp2)
 	INSTALL_AUDIOENCODER(ADM_ae_lav_mp2)
-
+#====
 	SET(ADM_ae_lav_ac3_SRCS audioencoder_lavcodec.cpp)
 
 	ADD_LIBRARY(ADM_ae_lav_ac3 SHARED ${ADM_ae_lav_ac3_SRCS})
-	ADD_TARGET_CFLAGS(ADM_ae_lav_ac3 "-DADM_LAV_AC3")
+	ADD_TARGET_CFLAGS(ADM_ae_lav_ac3 "-DADM_AE_SET='\"ADM_lav_ac3.h\"'")
 	TARGET_LINK_LIBRARIES(ADM_ae_lav_ac3  ADM_libavcodec6)
 
 	INIT_AUDIO_ENCODER(ADM_ae_lav_ac3)
 	INSTALL_AUDIOENCODER(ADM_ae_lav_ac3)
+#====
+	SET(ADM_ae_lav_aac_SRCS audioencoder_lavcodec.cpp)
+
+	ADD_LIBRARY(ADM_ae_lav_aac SHARED ${ADM_ae_lav_aac_SRCS})
+	ADD_TARGET_CFLAGS(ADM_ae_lav_aac "-DADM_AE_SET='\"ADM_lav_aac.h\"'")
+	TARGET_LINK_LIBRARIES(ADM_ae_lav_aac  ADM_libavcodec6)
+
+	INIT_AUDIO_ENCODER(ADM_ae_lav_aac)
+	INSTALL_AUDIOENCODER(ADM_ae_lav_aac)
+#====
+

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioEncoders/lavcodec/audioencoder_lavcodec.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioEncoders/lavcodec/audioencoder_lavcodec.cpp	2009-08-12 09:06:28 UTC (rev 5234)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioEncoders/lavcodec/audioencoder_lavcodec.cpp	2009-08-12 17:38:52 UTC (rev 5235)
@@ -27,21 +27,8 @@
 
 #include "ADM_lavcodec.h"
 
+#include ADM_AE_SET
 
-
-#define Join(x,y) x##_##y
-#if defined(ADM_LAV_MP2) && !defined(ADM_LAV_AC3)
-  #define makeName(x) Join(x,MP2)
-  #define AUDMEncoder_Lavcodec AUDMEncoder_Lavcodec_MP2
-#else
- #if !defined(ADM_LAV_MP2) && defined(ADM_LAV_AC3)
-  #define makeName(x) Join(x,AC3)
-  #define AUDMEncoder_Lavcodec AUDMEncoder_Lavcodec_AC3
- #else
-   #error
- #endif
-#endif
-
 #include "audioencoder_lavcodec.h"
 
 typedef struct 
@@ -58,21 +45,11 @@
   create,			// Defined by macro automatically
   destroy,			// Defined by macro automatically
   configure,		//** put your own function here**
-#ifdef ADM_LAV_MP2      
-  "LavMP2",            
-  "MP2 (lav)",      
-  "MP2 LavCodec encoder plugin Mean 2008",             
-  2,                    // Max channels
-  1,0,0,                // Version
-#else
-  
-
- "LavAC3",            
-  "AC3 (lav)",      
-  "AC3 LavEncoder encoder plugin Mean 2008",             
-  6,                    // Max channels
-  1,0,0,                // Version
-#endif
+  ADM_LAV_NAME,
+  ADM_LAV_MENU,
+  ADM_LAV_DESC,
+  ADM_LAV_MAX_CHANNEL,
+  ADM_LAV_VERSION,
   makeName(WAV),
 
   100,                  // Priority
@@ -130,20 +107,14 @@
   _context=( void *)avcodec_alloc_context();
   
 
-#ifdef ADM_LAV_MP2      
-  if( _incoming->getInfo()->channels>2)
+  if( _incoming->getInfo()->channels>ADM_LAV_MAX_CHANNEL)
   {
     printf("[Lavcodec]Too many channels\n");
     return 0; 
   }
-#endif
   wavheader.byterate=(lavConfig.bitrate*1000)>>3;         
       
-#ifdef ADM_LAV_MP2 
-    _chunk = 1152*wavheader.channels;
-#else
-    _chunk = 1536*wavheader.channels; // AC3
-#endif
+    _chunk = ADM_LAV_SAMPLE_PER_P*wavheader.channels; // AC3
   printf("[Lavcodec]Incoming : fq : %"LU", channel : %"LU" bitrate: %"LU" \n",
          wavheader.frequency,wavheader.channels,lavConfig.bitrate);
   



From mean at mail.berlios.de  Wed Aug 12 19:38:56 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Wed, 12 Aug 2009 19:38:56 +0200
Subject: [Avidemux-svn-commit] r5236 - in
	branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg:
	ffmpeg_config libavcodec
Message-ID: <200908121738.n7CHcuZp012753@sheep.berlios.de>

Author: mean
Date: 2009-08-12 19:38:55 +0200 (Wed, 12 Aug 2009)
New Revision: 5236

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/ffmpeg_config/config.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/ffmpeg_config/ffconf.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/CMakeLists.txt
Log:
[ffmpeg] Enable aac encoder

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/ffmpeg_config/config.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/ffmpeg_config/config.h	2009-08-12 17:38:52 UTC (rev 5235)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/ffmpeg_config/config.h	2009-08-12 17:38:55 UTC (rev 5236)
@@ -13,6 +13,8 @@
 #define CONFIG_MPEG1_VDPAU_DECODER 0
 #define CONFIG_VC1_VDPAU_DECODER 0
 #define CONFIG_WMV3_VDPAU_DECODER 0
+#define CONFIG_AAC_DECODER 1
+#define CONFIG_MPEG4AAC_DECODER 1
 #define CONFIG_DCA_DECODER 1
 #define CONFIG_MP3_DECODER 1
 #define CONFIG_MP2_DECODER 1
@@ -85,7 +87,6 @@
 #define CONFIG_MP1_DECODER 0
 #define CONFIG_MLP_DECODER 0
 #define CONFIG_ALAC_DECODER 0
-#define CONFIG_AAC_DECODER 0
 #define CONFIG_PGMYUV_DECODER 0
 #define CONFIG_PPM_DECODER 0
 #define CONFIG_EATGV_DECODER 0
@@ -160,7 +161,6 @@
 #define CONFIG_WNV1_DECODER 0
 #define CONFIG_XAN_WC3_DECODER 0
 #define CONFIG_XL_DECODER 0
-#define CONFIG_MPEG4AAC_DECODER 0
 #define CONFIG_ALAC_DECODER 0
 #define CONFIG_ATRAC3_DECODER 0
 #define CONFIG_COOK_DECODER 0
@@ -250,10 +250,10 @@
 #define CONFIG_ADPCM_YAMAHA_DECODER 0
 #define CONFIG_DVDSUB_DECODER 0
 #define CONFIG_LIBVORBIS_DECODER 0
+#define CONFIG_AAC_PARSER 1
 #define CONFIG_H263_PARSER 1
 #define CONFIG_H264_PARSER 1
 #define CONFIG_MPEG4VIDEO_PARSER 1
-#define CONFIG_AAC_PARSER 0
 #define CONFIG_AC3_PARSER 0
 #define CONFIG_CAVSVIDEO_PARSER 0
 #define CONFIG_DCA_PARSER 0
@@ -268,6 +268,7 @@
 #define CONFIG_VP3_PARSER 0
 #define CONFIG_DNXHD_PARSER 0
 #define CONFIG_DIRAC_PARSER 0
+#define CONFIG_AAC_ENCODER 1
 #define CONFIG_MJPEG_ENCODER 1
 #define CONFIG_MSMPEG4V3_ENCODER 1
 #define CONFIG_H263P_ENCODER 1
@@ -285,7 +286,6 @@
 #define CONFIG_HUFFYUV_ENCODER 1
 #define CONFIG_DVBSUB_ENCODER 1
 #define CONFIG_SNOW_ENCODER 1
-#define CONFIG_AAC_ENCODER 0
 #define CONFIG_XSUB_ENCODER 0
 #define CONFIG_V210_ENCODER 0
 #define CONFIG_LIBOPENCORE_AMRNB_ENCODER 0

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/ffmpeg_config/ffconf.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/ffmpeg_config/ffconf.c	2009-08-12 17:38:52 UTC (rev 5235)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/ffmpeg_config/ffconf.c	2009-08-12 17:38:55 UTC (rev 5236)
@@ -35,6 +35,8 @@
 
 #define DECLARE_DECODER(a,b); printf("#define CONFIG_"#a"_DECODER 1\n");
   
+    DECLARE_DECODER(AAC, eatgq);
+    DECLARE_DECODER(MPEG4AAC, mpeg4aac);
     DECLARE_DECODER(DCA, dca);
     DECLARE_DECODER(MP3, mp3);
     DECLARE_DECODER(MP2, mp2);
@@ -113,7 +115,6 @@
     DECLARE_DECODER(MP1, eatgq);
     DECLARE_DECODER(MLP, eatgq);
     DECLARE_DECODER(ALAC, eatgq);
-    DECLARE_DECODER(AAC, eatgq);
     DECLARE_DECODER(PGMYUV, eatgq);
     DECLARE_DECODER(PPM, eatgq);
 
@@ -193,7 +194,6 @@
     DECLARE_DECODER(WNV1, wnv1);
     DECLARE_DECODER(XAN_WC3, xan_wc3);
     DECLARE_DECODER(XL, xl);
-    DECLARE_DECODER(MPEG4AAC, mpeg4aac);
     DECLARE_DECODER(ALAC, alac);
     DECLARE_DECODER(ATRAC3, atrac3);
     DECLARE_DECODER(COOK, cook);
@@ -286,13 +286,13 @@
 	DECLARE_DECODER (LIBVORBIS, libvorbis);
 
 #define DECLARE_PARSER(a,b); printf("#define CONFIG_"#a"_PARSER 1\n"); 
+    DECLARE_PARSER (AAC, aac);
     DECLARE_PARSER (H263, h263);
     DECLARE_PARSER (H264, h264);
     DECLARE_PARSER (MPEG4VIDEO, mpeg4video);
 
 #undef DECLARE_PARSER
 #define DECLARE_PARSER(a,b); printf("#define CONFIG_"#a"_PARSER 0\n"); 
-    DECLARE_PARSER (AAC, aac);
     DECLARE_PARSER (AC3, ac3);
     DECLARE_PARSER (CAVSVIDEO, cavsvideo);
     DECLARE_PARSER (DCA, dca);
@@ -310,6 +310,7 @@
 
 #define DECLARE_ENCODER(a,b); printf("#define CONFIG_"#a"_ENCODER 1\n");
 
+    DECLARE_ENCODER (AAC, mjpeg);
     DECLARE_ENCODER (MJPEG, mjpeg);
     DECLARE_ENCODER (MSMPEG4V3, msmpeg4v3);
     DECLARE_ENCODER(H263P, h263p);
@@ -330,7 +331,6 @@
 
 #undef DECLARE_ENCODER
 #define DECLARE_ENCODER(a,b); printf("#define CONFIG_"#a"_ENCODER 0\n"); 
-    DECLARE_ENCODER (AAC, mjpeg);
     DECLARE_ENCODER(XSUB, amv);
     DECLARE_ENCODER(V210, amv);
     DECLARE_ENCODER(LIBOPENCORE_AMRNB, amv);

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/CMakeLists.txt	2009-08-12 17:38:52 UTC (rev 5235)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/CMakeLists.txt	2009-08-12 17:38:55 UTC (rev 5236)
@@ -28,7 +28,7 @@
         dca.c
         ac3enc.c  ac3.c  ac3tab.c   ac3_parser.c
         eac3dec.c ac3dec.c ac3dec_data.c eac3dec_data.c
-        #aacenc.c aaccoder.c
+        aacenc.c aaccoder.c
 	dvbsub_parser.c  dvbsubdec.c  dvbsub.c  xiph.c  sp5xdec.c  
         nellymoserdec.c nellymoser.c
 	ADM_lavcodec.cpp  pthread.c  huffman.c  wmv2dec.c  wmv2.c  h264pred.c  intrax8.c
@@ -63,7 +63,7 @@
 ENDIF (ADM_CPU_ALTIVEC)
 
 ADD_LIBRARY(${ADM_LIB} SHARED ${${ADM_LIB}_SRCS})
-
+ADD_DEFINITIONS(-std=c99)
 IF (ADM_DEBUG AND ADM_CPU_X86_32)
 	ADD_SOURCE_CFLAGS(cabac.c -O2)
 	ADD_SOURCE_CFLAGS(h264.c -O2)



From mean at mail.berlios.de  Wed Aug 12 19:38:59 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Wed, 12 Aug 2009 19:38:59 +0200
Subject: [Avidemux-svn-commit] r5237 - in branches/avidemux_2.6_branch_mean:
	avidemux_core/ADM_ffmpeg/libavcodec
	avidemux_plugins/ADM_audioDecoders/ADM_ad_lav
Message-ID: <200908121738.n7CHcxhW012776@sheep.berlios.de>

Author: mean
Date: 2009-08-12 19:38:58 +0200 (Wed, 12 Aug 2009)
New Revision: 5237

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDecoders/ADM_ad_lav/ADM_ad_lav.cpp
Log:
[audioEncoder] Fix lavcodec so that the aac encoder works

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/CMakeLists.txt	2009-08-12 17:38:55 UTC (rev 5236)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavcodec/CMakeLists.txt	2009-08-12 17:38:58 UTC (rev 5237)
@@ -28,7 +28,7 @@
         dca.c
         ac3enc.c  ac3.c  ac3tab.c   ac3_parser.c
         eac3dec.c ac3dec.c ac3dec_data.c eac3dec_data.c
-        aacenc.c aaccoder.c
+        aacenc.c aaccoder.c aac.c aactab.c psymodel.c aacpsy.c iirfilter.c
 	dvbsub_parser.c  dvbsubdec.c  dvbsub.c  xiph.c  sp5xdec.c  
         nellymoserdec.c nellymoser.c
 	ADM_lavcodec.cpp  pthread.c  huffman.c  wmv2dec.c  wmv2.c  h264pred.c  intrax8.c

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDecoders/ADM_ad_lav/ADM_ad_lav.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDecoders/ADM_ad_lav/ADM_ad_lav.cpp	2009-08-12 17:38:55 UTC (rev 5236)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDecoders/ADM_ad_lav/ADM_ad_lav.cpp	2009-08-12 17:38:58 UTC (rev 5237)
@@ -52,6 +52,7 @@
         {WAV_MP3,AD_MEDIUM_QUAL},
         {WAV_MP2,AD_MEDIUM_QUAL},
         {WAV_AC3,AD_LOW_QUAL},   // liba52 preferred ???
+        {WAV_AAC,AD_LOW_QUAL},   // liba52 preferred ???
         {WAV_EAC3,AD_MEDIUM_QUAL}
   
 };
@@ -136,6 +137,10 @@
         _context->codec_id = CODEC_ID_EAC3;
         _blockalign = 1;
         break;
+      case WAV_AAC:
+        _context->codec_id = CODEC_ID_AAC;
+        _blockalign = 1;
+        break;
       default:
              ADM_assert(0);
     }



From mean at mail.berlios.de  Wed Aug 12 19:39:02 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Wed, 12 Aug 2009 19:39:02 +0200
Subject: [Avidemux-svn-commit] r5238 - in
	branches/avidemux_2.6_branch_mean/avidemux/common/ADM_icons:
	. scalable
Message-ID: <200908121739.n7CHd2gZ012799@sheep.berlios.de>

Author: mean
Date: 2009-08-12 19:39:01 +0200 (Wed, 12 Aug 2009)
New Revision: 5238

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_icons/play.png
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_icons/scalable/play.svg
Log:
[UI/Icons] New play icon from JM

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_icons/play.png
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_icons/play.png	2009-08-12 17:38:58 UTC (rev 5237)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_icons/play.png	2009-08-12 17:39:01 UTC (rev 5238)
@@ -1,11 +1,9 @@
 ?PNG
 
-
+
 &
-&Q??3
-?b?@@???)?? I2 ???d??i\?>	?????[X]]???????R?
-?|78??/????e*??A
-??? X?O?i??WQ?W+??[
-??v=z!?[??/????c>?/	
-S???cE^E???_o?A??,?rl|||?9L? ??IA??P??d$3!????0???
-??%? ?,0p0??I??
\ No newline at end of file
+&Q??3
+????????? ??[Q???+?\??????>|i?W???`_WW???o}????JOC+?J>??74?OB???????^~v???}????~??*7?w[??????|?t?Rw???=??XB???VDu??????V??_C<?l?5"u????b????i????????_??~000p?y?0?<A?????k?'??.????M??'???JT?{?s???????????-?x????uo????????T*?5??\?y?G?!*A????i76ye???P?j?25??????????NX????7??vW???=??????S?Z,???S???B??qSS??Y?	4???@#k???3?
+??f6GG??>?s?p???[u???Uu??????Q??V}??8???dyF|S?G??	Rg?M?????????`????&?;?Q
+`?\c?pk%??f??*???[?9??????w?j???_??m???_?N_
+?V?9?`???o???W???????-?]o}
\ No newline at end of file

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_icons/scalable/play.svg
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_icons/scalable/play.svg	2009-08-12 17:38:58 UTC (rev 5237)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_icons/scalable/play.svg	2009-08-12 17:39:01 UTC (rev 5238)
@@ -23,6 +23,17 @@
    inkscape:export-ydpi="66.040642">
   <defs
      id="defs7856">
+    <linearGradient
+       id="linearGradient3643">
+      <stop
+         id="stop3645"
+         offset="0"
+         style="stop-color:#000000;stop-opacity:0.3137255;" />
+      <stop
+         id="stop3647"
+         offset="1"
+         style="stop-color:#ffffff;stop-opacity:0.4" />
+    </linearGradient>
     <inkscape:perspective
        sodipodi:type="inkscape:persp3d"
        inkscape:vp_x="0 : 24 : 1"
@@ -99,7 +110,8 @@
        x1="-177.27766"
        y1="9.2039175"
        x2="-172.82857"
-       y2="25.808161" />
+       y2="25.808161"
+       gradientTransform="translate(-10,0)" />
     <linearGradient
        inkscape:collect="always"
        xlink:href="#linearGradient7305"
@@ -108,18 +120,60 @@
        x1="-0.11694507"
        y1="10.14653"
        x2="48.025963"
-       y2="37.941853" />
+       y2="37.941853"
+       gradientTransform="translate(-10,0)" />
     <radialGradient
        inkscape:collect="always"
        xlink:href="#linearGradient7344"
        id="radialGradient3815"
        gradientUnits="userSpaceOnUse"
        gradientTransform="matrix(2.7391664,0,0,2.2478596,-74.857354,-10.683483)"
-       cx="36.126339"
-       cy="18.020473"
-       fx="36.126339"
-       fy="18.020473"
+       cx="38.6572"
+       cy="17.891972"
+       fx="38.6572"
+       fy="17.891972"
        r="13.55237" />
+    <linearGradient
+       inkscape:collect="always"
+       xlink:href="#linearGradient7577"
+       id="linearGradient3567"
+       gradientUnits="userSpaceOnUse"
+       gradientTransform="matrix(1.0273966,0,0,1.1964739,66.605475,-2.9942796)"
+       x1="-77.711723"
+       y1="13.246527"
+       x2="-74.288277"
+       y2="26.023027" />
+    <radialGradient
+       inkscape:collect="always"
+       xlink:href="#linearGradient7344"
+       id="radialGradient3569"
+       gradientUnits="userSpaceOnUse"
+       gradientTransform="matrix(2.2856093,0,0,2.7559984,-57.328914,-53.069064)"
+       cx="28.541149"
+       cy="31.678772"
+       fx="28.541149"
+       fy="31.678772"
+       r="12.000001" />
+    <linearGradient
+       inkscape:collect="always"
+       xlink:href="#linearGradient7577"
+       id="linearGradient3661"
+       x1="9.2604694"
+       y1="14.060266"
+       x2="14.21783"
+       y2="27.082993"
+       gradientUnits="userSpaceOnUse" />
+    <radialGradient
+       inkscape:collect="always"
+       xlink:href="#linearGradient7344"
+       id="radialGradient3665"
+       gradientUnits="userSpaceOnUse"
+       gradientTransform="matrix(2.2856093,0,0,2.7559983,-57.328912,-53.069063)"
+       cx="31.043377"
+       cy="31.145161"
+       fx="31.043377"
+       fy="31.145161"
+       r="12.000001" />
   </defs>
   <sodipodi:namedview
      id="base"
@@ -131,9 +185,9 @@
      objecttolerance="10"
      inkscape:pageopacity="0"
      inkscape:pageshadow="2"
-     inkscape:zoom="17.30989"
-     inkscape:cx="14.532593"
-     inkscape:cy="24.981269"
+     inkscape:zoom="14.06"
+     inkscape:cx="34.346795"
+     inkscape:cy="20.297014"
      inkscape:document-units="px"
      inkscape:current-layer="layer1"
      width="48px"
@@ -142,7 +196,7 @@
      inkscape:window-width="1411"
      inkscape:window-height="846"
      inkscape:window-x="0"
-     inkscape:window-y="0"
+     inkscape:window-y="25"
      showgrid="false"
      inkscape:grid-points="true"
      showborder="true"
@@ -217,6 +271,14 @@
        opacity="0.2"
        empopacity="0.4"
        empspacing="2" />
+    <sodipodi:guide
+       orientation="0,1"
+       position="15.771331,38.417344"
+       id="guide2790" />
+    <sodipodi:guide
+       orientation="0,1"
+       position="14.501354,9.6206396"
+       id="guide2792" />
   </sodipodi:namedview>
   <metadata
      id="metadata7859">
@@ -265,6 +327,15 @@
      inkscape:label="Layer 1"
      inkscape:groupmode="layer"
      id="layer1">
+    <rect
+       style="opacity:0.4;fill:url(#linearGradient3661);fill-opacity:1;fill-rule:evenodd;stroke:none;stroke-width:1;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0.69999992;stroke-opacity:1"
+       id="rect3649"
+       width="12.39101"
+       height="30.575102"
+       x="6.4105816"
+       y="8.7403173"
+       rx="1.71"
+       ry="1.459" />
     <path
        sodipodi:type="inkscape:offset"
        inkscape:radius="1.5026019"
@@ -272,16 +343,16 @@
        style="opacity:0.4;fill:url(#linearGradient7865);fill-opacity:1;fill-rule:evenodd;stroke:none;stroke-width:0.99999982;stroke-linecap:square;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dashoffset:0.69999992;stroke-opacity:1"
        id="path7671"
        d="M -186.59375,9 C -187.38473,9.0508993 -188.00018,9.7073844 -188,10.5 L -188,37.5 C -187.99205,38.031998 -187.70339,38.520136 -187.24104,38.783419 C -186.77869,39.046702 -186.21158,39.045877 -185.75,38.78125 L -162.75,25.28125 C -162.30425,25.008049 -162.03253,24.522812 -162.03253,24 C -162.03253,23.477188 -162.30425,22.991951 -162.75,22.71875 L -185.75,9.21875 C -186.00346,9.0640763 -186.29707,8.9879569 -186.59375,9 z"
-       transform="translate(200,0)" />
+       transform="translate(210,0)" />
     <path
        sodipodi:nodetypes="cccc"
        id="path7812"
-       d="M 13.499996,37.500001 L 13.499996,10.500456 L 36.499996,24.012458 L 13.499996,37.500001 z"
+       d="M 23.499996,37.500001 L 23.499996,10.500456 L 46.499996,24.012458 L 23.499996,37.500001 z"
        style="fill:url(#radialGradient3815);fill-opacity:1;fill-rule:evenodd;stroke:#4e9a06;stroke-width:0.99999981999999998;stroke-linecap:square;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dashoffset:0.69999992000000000;stroke-opacity:1" />
     <path
        sodipodi:nodetypes="cccc"
        id="path7828"
-       d="M 14.499996,35.750028 L 14.499996,12.250428 L 34.499996,24.010872 L 14.499996,35.750028 z"
+       d="M 24.499996,35.750028 L 24.499996,12.250428 L 44.499996,24.010872 L 24.499996,35.750028 z"
        style="fill:none;fill-opacity:1;fill-rule:evenodd;stroke:#ffffff;stroke-width:0.99999982;stroke-linecap:square;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dashoffset:0.69999992;stroke-opacity:1" />
     <path
        sodipodi:type="inkscape:offset"
@@ -290,6 +361,24 @@
        style="opacity:0.15;fill:url(#linearGradient3810);fill-opacity:1;fill-rule:evenodd;stroke:none;stroke-width:0.99999982;stroke-linecap:square;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dashoffset:0.69999992;stroke-opacity:1"
        id="path7354"
        d="M 14,11.375 C 14,19.791551 14,28.208449 14,36.625 C 21.167154,32.421341 28.332238,28.204015 35.5,24 C 28.332835,19.790152 21.16775,15.585191 14,11.375 z"
-       transform="matrix(1,0,0,-1,-3.5655781e-6,48)" />
+       transform="matrix(1,0,0,-1,9.9999964,48)" />
+    <rect
+       style="fill:url(#radialGradient3665);fill-opacity:1;fill-rule:evenodd;stroke:#4e9a06;stroke-width:1;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0.69999992;stroke-opacity:1"
+       id="rect3573"
+       width="9.3982105"
+       height="27.805355"
+       x="7.9069819"
+       y="10.125191"
+       rx="1.0102171"
+       ry="0.55919814" />
+    <rect
+       style="fill:none;fill-opacity:1;fill-rule:evenodd;stroke:#ffffff;stroke-width:1;stroke-linecap:round;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0.69999992;stroke-opacity:1"
+       id="rect3575"
+       width="7.2693739"
+       height="25.663738"
+       x="8.9580898"
+       y="11.182421"
+       rx="0"
+       ry="0" />
   </g>
 </svg>



From mean at mail.berlios.de  Wed Aug 12 19:51:06 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Wed, 12 Aug 2009 19:51:06 +0200
Subject: [Avidemux-svn-commit] r5239 - in
	branches/avidemux_2.5_branch_gruntster/avidemux/ADM_icons: .
	scalable xpm
Message-ID: <200908121751.n7CHp6ck014311@sheep.berlios.de>

Author: mean
Date: 2009-08-12 19:51:06 +0200 (Wed, 12 Aug 2009)
New Revision: 5239

Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_icons/play.png
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_icons/scalable/play.svg
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_icons/xpm/play.inc
Log:
[UI/Gtk] New play icon from JM

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_icons/play.png
===================================================================
(Binary files differ)

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_icons/scalable/play.svg
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_icons/scalable/play.svg	2009-08-12 17:39:01 UTC (rev 5238)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_icons/scalable/play.svg	2009-08-12 17:51:06 UTC (rev 5239)
@@ -23,6 +23,17 @@
    inkscape:export-ydpi="66.040642">
   <defs
      id="defs7856">
+    <linearGradient
+       id="linearGradient3643">
+      <stop
+         id="stop3645"
+         offset="0"
+         style="stop-color:#000000;stop-opacity:0.3137255;" />
+      <stop
+         id="stop3647"
+         offset="1"
+         style="stop-color:#ffffff;stop-opacity:0.4" />
+    </linearGradient>
     <inkscape:perspective
        sodipodi:type="inkscape:persp3d"
        inkscape:vp_x="0 : 24 : 1"
@@ -99,7 +110,8 @@
        x1="-177.27766"
        y1="9.2039175"
        x2="-172.82857"
-       y2="25.808161" />
+       y2="25.808161"
+       gradientTransform="translate(-10,0)" />
     <linearGradient
        inkscape:collect="always"
        xlink:href="#linearGradient7305"
@@ -108,18 +120,60 @@
        x1="-0.11694507"
        y1="10.14653"
        x2="48.025963"
-       y2="37.941853" />
+       y2="37.941853"
+       gradientTransform="translate(-10,0)" />
     <radialGradient
        inkscape:collect="always"
        xlink:href="#linearGradient7344"
        id="radialGradient3815"
        gradientUnits="userSpaceOnUse"
        gradientTransform="matrix(2.7391664,0,0,2.2478596,-74.857354,-10.683483)"
-       cx="36.126339"
-       cy="18.020473"
-       fx="36.126339"
-       fy="18.020473"
+       cx="38.6572"
+       cy="17.891972"
+       fx="38.6572"
+       fy="17.891972"
        r="13.55237" />
+    <linearGradient
+       inkscape:collect="always"
+       xlink:href="#linearGradient7577"
+       id="linearGradient3567"
+       gradientUnits="userSpaceOnUse"
+       gradientTransform="matrix(1.0273966,0,0,1.1964739,66.605475,-2.9942796)"
+       x1="-77.711723"
+       y1="13.246527"
+       x2="-74.288277"
+       y2="26.023027" />
+    <radialGradient
+       inkscape:collect="always"
+       xlink:href="#linearGradient7344"
+       id="radialGradient3569"
+       gradientUnits="userSpaceOnUse"
+       gradientTransform="matrix(2.2856093,0,0,2.7559984,-57.328914,-53.069064)"
+       cx="28.541149"
+       cy="31.678772"
+       fx="28.541149"
+       fy="31.678772"
+       r="12.000001" />
+    <linearGradient
+       inkscape:collect="always"
+       xlink:href="#linearGradient7577"
+       id="linearGradient3661"
+       x1="9.2604694"
+       y1="14.060266"
+       x2="14.21783"
+       y2="27.082993"
+       gradientUnits="userSpaceOnUse" />
+    <radialGradient
+       inkscape:collect="always"
+       xlink:href="#linearGradient7344"
+       id="radialGradient3665"
+       gradientUnits="userSpaceOnUse"
+       gradientTransform="matrix(2.2856093,0,0,2.7559983,-57.328912,-53.069063)"
+       cx="31.043377"
+       cy="31.145161"
+       fx="31.043377"
+       fy="31.145161"
+       r="12.000001" />
   </defs>
   <sodipodi:namedview
      id="base"
@@ -131,9 +185,9 @@
      objecttolerance="10"
      inkscape:pageopacity="0"
      inkscape:pageshadow="2"
-     inkscape:zoom="17.30989"
-     inkscape:cx="14.532593"
-     inkscape:cy="24.981269"
+     inkscape:zoom="14.06"
+     inkscape:cx="34.346795"
+     inkscape:cy="20.297014"
      inkscape:document-units="px"
      inkscape:current-layer="layer1"
      width="48px"
@@ -142,7 +196,7 @@
      inkscape:window-width="1411"
      inkscape:window-height="846"
      inkscape:window-x="0"
-     inkscape:window-y="0"
+     inkscape:window-y="25"
      showgrid="false"
      inkscape:grid-points="true"
      showborder="true"
@@ -217,6 +271,14 @@
        opacity="0.2"
        empopacity="0.4"
        empspacing="2" />
+    <sodipodi:guide
+       orientation="0,1"
+       position="15.771331,38.417344"
+       id="guide2790" />
+    <sodipodi:guide
+       orientation="0,1"
+       position="14.501354,9.6206396"
+       id="guide2792" />
   </sodipodi:namedview>
   <metadata
      id="metadata7859">
@@ -265,6 +327,15 @@
      inkscape:label="Layer 1"
      inkscape:groupmode="layer"
      id="layer1">
+    <rect
+       style="opacity:0.4;fill:url(#linearGradient3661);fill-opacity:1;fill-rule:evenodd;stroke:none;stroke-width:1;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0.69999992;stroke-opacity:1"
+       id="rect3649"
+       width="12.39101"
+       height="30.575102"
+       x="6.4105816"
+       y="8.7403173"
+       rx="1.71"
+       ry="1.459" />
     <path
        sodipodi:type="inkscape:offset"
        inkscape:radius="1.5026019"
@@ -272,16 +343,16 @@
        style="opacity:0.4;fill:url(#linearGradient7865);fill-opacity:1;fill-rule:evenodd;stroke:none;stroke-width:0.99999982;stroke-linecap:square;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dashoffset:0.69999992;stroke-opacity:1"
        id="path7671"
        d="M -186.59375,9 C -187.38473,9.0508993 -188.00018,9.7073844 -188,10.5 L -188,37.5 C -187.99205,38.031998 -187.70339,38.520136 -187.24104,38.783419 C -186.77869,39.046702 -186.21158,39.045877 -185.75,38.78125 L -162.75,25.28125 C -162.30425,25.008049 -162.03253,24.522812 -162.03253,24 C -162.03253,23.477188 -162.30425,22.991951 -162.75,22.71875 L -185.75,9.21875 C -186.00346,9.0640763 -186.29707,8.9879569 -186.59375,9 z"
-       transform="translate(200,0)" />
+       transform="translate(210,0)" />
     <path
        sodipodi:nodetypes="cccc"
        id="path7812"
-       d="M 13.499996,37.500001 L 13.499996,10.500456 L 36.499996,24.012458 L 13.499996,37.500001 z"
+       d="M 23.499996,37.500001 L 23.499996,10.500456 L 46.499996,24.012458 L 23.499996,37.500001 z"
        style="fill:url(#radialGradient3815);fill-opacity:1;fill-rule:evenodd;stroke:#4e9a06;stroke-width:0.99999981999999998;stroke-linecap:square;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dashoffset:0.69999992000000000;stroke-opacity:1" />
     <path
        sodipodi:nodetypes="cccc"
        id="path7828"
-       d="M 14.499996,35.750028 L 14.499996,12.250428 L 34.499996,24.010872 L 14.499996,35.750028 z"
+       d="M 24.499996,35.750028 L 24.499996,12.250428 L 44.499996,24.010872 L 24.499996,35.750028 z"
        style="fill:none;fill-opacity:1;fill-rule:evenodd;stroke:#ffffff;stroke-width:0.99999982;stroke-linecap:square;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dashoffset:0.69999992;stroke-opacity:1" />
     <path
        sodipodi:type="inkscape:offset"
@@ -290,6 +361,24 @@
        style="opacity:0.15;fill:url(#linearGradient3810);fill-opacity:1;fill-rule:evenodd;stroke:none;stroke-width:0.99999982;stroke-linecap:square;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dashoffset:0.69999992;stroke-opacity:1"
        id="path7354"
        d="M 14,11.375 C 14,19.791551 14,28.208449 14,36.625 C 21.167154,32.421341 28.332238,28.204015 35.5,24 C 28.332835,19.790152 21.16775,15.585191 14,11.375 z"
-       transform="matrix(1,0,0,-1,-3.5655781e-6,48)" />
+       transform="matrix(1,0,0,-1,9.9999964,48)" />
+    <rect
+       style="fill:url(#radialGradient3665);fill-opacity:1;fill-rule:evenodd;stroke:#4e9a06;stroke-width:1;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0.69999992;stroke-opacity:1"
+       id="rect3573"
+       width="9.3982105"
+       height="27.805355"
+       x="7.9069819"
+       y="10.125191"
+       rx="1.0102171"
+       ry="0.55919814" />
+    <rect
+       style="fill:none;fill-opacity:1;fill-rule:evenodd;stroke:#ffffff;stroke-width:1;stroke-linecap:round;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:none;stroke-dashoffset:0.69999992;stroke-opacity:1"
+       id="rect3575"
+       width="7.2693739"
+       height="25.663738"
+       x="8.9580898"
+       y="11.182421"
+       rx="0"
+       ry="0" />
   </g>
 </svg>

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_icons/xpm/play.inc
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_icons/xpm/play.inc	2009-08-12 17:39:01 UTC (rev 5238)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_icons/xpm/play.inc	2009-08-12 17:51:06 UTC (rev 5239)
@@ -11,102 +11,151 @@
 { ""
   /* Pixbuf magic (0x47646b50) */
   "GdkP"
-  /* length: header (24) + pixel_data (1672) */
-  "\0\0\6\240"
+  /* length: header (24) + pixel_data (2640) */
+  "\0\0\12h"
   /* pixdata_type (0x1010002) */
   "\1\1\0\2"
-  /* rowstride (76) */
-  "\0\0\0L"
-  /* width (19) */
-  "\0\0\0\23"
+  /* rowstride (120) */
+  "\0\0\0x"
+  /* width (30) */
+  "\0\0\0\36"
   /* height (22) */
   "\0\0\0\26"
   /* pixel_data: */
-  """2b\4""2+V\3""8\0\0\0\13\377\377\377\0\377\377\377\0\377\377\377\0\377"
-  "\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377"
-  "\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377"
-  "\377\377\0\377\377\377\0\377\377\377\0;u\5_\\\242\30\367N\223\16\234"
-  "\30-\5!\0\0\0\6\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377"
+  "\0\0\0\24""6k\4QA\200\5tA\200\5tA\200\5tA\200\5tA\200\5t4f\4L\0\0\0\22"
+  "\377\377\377\0\377\377\377\0\15\32\1\14,V\5""0\12\12\12\12\377\377\377"
   "\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377"
   "\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377"
-  "\0<u\6`\302\342\245\372\326\354\300\375m\254/\351G\201\20q###\30$$$\3"
-  "\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377"
   "\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377"
-  "\0\377\377\377\0\377\377\377\0\77v\14d\303\341\246\372\314\357\254\377"
-  "\351\370\333\377\274\335\235\370]\241\34\326Dm\36O>>>\24\0\0\0\0\377"
-  "\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377"
-  "\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0Dy"
-  "\22h\304\341\247\372\301\353\227\377\267\350\210\377\325\361\270\377"
-  "\354\367\341\377\230\307m\363X\231\33\264UiC9```\15\377\377\377\0\377"
-  "\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377"
-  "\377\377\0\377\377\377\0\377\377\377\0J|\32l\306\342\253\372\303\354"
-  "\234\377\272\351\215\377\276\352\224\377\305\354\240\377\345\366\324"
-  "\377\341\362\322\376v\261=\356]\224)\216uws*www\6\377\377\377\0\377\377"
+  "\0""7l\4S\224\306e\364\314\350\261\377\315\350\261\377\315\351\262\377"
+  "\315\351\262\377\315\351\262\377\212\277W\3632c\5D\377\377\377\0\377"
+  "\377\377\0#4\22#Q\234\12\366O\220\22\227-:!#000\6\377\377\377\0\377\377"
   "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
-  "\377\0P\202\"o\307\343\255\372\310\355\243\377\277\352\224\377\303\353"
-  "\233\377\307\355\242\377\313\356\250\377\323\361\267\377\356\371\342"
-  "\377\310\343\257\372e\247'\342n\225Il\225\225\225!\200\200\200\2\377"
-  "\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0X\207"
-  "+t\312\344\261\373\315\356\254\377\303\353\233\377\307\355\243\377\313"
-  "\356\251\377\317\357\257\377\321\360\263\377\317\357\257\377\334\363"
-  "\304\377\357\371\347\377\247\316\200\365d\243(\310\223\250\177T\265\265"
-  "\265\26\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0`\216"
-  "5w\313\344\263\373\322\361\265\377\311\355\245\377\314\356\252\377\320"
-  "\360\261\377\323\360\266\377\326\362\272\377\327\362\274\377\323\361"
-  "\266\377\323\361\265\377\350\367\331\377\352\365\337\376\203\272P\361"
-  "u\253B\250\304\311\277\77\323\323\323\14\377\377\377\0\377\377\377\0"
-  "j\226@{\315\344\265\373\327\362\275\377\317\360\257\377\320\360\261\377"
-  "\323\360\267\377\327\362\276\377\332\362\302\377\334\364\306\377\333"
-  "\363\303\377\327\362\275\377\326\361\274\377\333\363\302\377\361\372"
-  "\347\377\325\352\302\374o\2544\352\230\277t\210\352\352\3521\343\343"
-  "\343\4s\236J\177\316\346\270\373\332\363\303\377\324\361\270\377\326"
-  "\361\272\377\331\362\277\377\334\364\305\377\337\364\312\377\341\365"
-  "\316\377\343\366\320\377\337\365\312\377\334\363\304\377\333\363\302"
-  "\377\330\362\277\377\341\365\316\377\363\372\354\377\266\327\225\370"
-  "o\2553\330\306\337\257^}\247V\203\317\346\270\373\336\364\311\377\331"
-  "\363\300\377\333\363\303\377\335\364\307\377\341\365\315\377\344\366"
-  "\322\377\346\367\326\377\347\367\330\377\346\367\326\377\342\365\317"
-  "\377\337\364\312\377\335\364\307\377\345\366\323\377\364\373\356\377"
-  "\273\332\234\372n\2551\337\275\331\242c\207\260a\207\320\346\272\373"
-  "\342\365\317\377\335\364\310\377\340\365\314\377\343\365\320\377\345"
-  "\366\325\377\351\367\333\377\354\371\337\377\354\371\340\377\354\371"
-  "\340\377\351\370\333\377\347\367\331\377\365\374\356\377\333\354\313"
-  "\375t\260:\356\243\312~\223\377\377\3774\377\377\377\4\223\273n\213\317"
-  "\346\272\373\343\365\321\377\341\365\315\377\344\366\323\377\347\367"
-  "\330\377\352\370\335\377\355\371\343\377\361\372\347\377\361\372\351"
-  "\377\362\373\351\377\367\374\362\377\360\367\352\377\213\275Z\365\210"
-  "\273W\266\361\367\353J\377\377\377\15\377\377\377\0\377\377\377\0\237"
-  "\305z\216\320\346\273\374\344\366\322\377\343\365\321\377\347\367\327"
-  "\377\352\370\335\377\357\371\344\377\362\372\352\377\365\374\360\377"
-  "\372\375\367\377\372\374\367\377\265\325\227\370v\261=\324\322\345\300"
-  "g\373\373\373\34\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377"
-  "\0\247\314\203\221\320\346\273\374\345\366\323\377\343\366\321\377\350"
-  "\367\332\377\355\371\340\377\361\372\347\377\367\374\361\377\374\376"
-  "\373\377\331\351\311\374t\257;\352\260\322\220\206\375\375\375.\377\377"
-  "\377\2\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
-  "\377\0\247\314\203\221\320\346\272\374\344\366\322\377\343\366\321\377"
-  "\350\367\331\377\355\371\342\377\370\375\364\377\354\365\345\377\202"
-  "\270P\362\223\302h\251\372\374\367A\377\377\377\12\377\377\377\0\377"
-  "\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377"
-  "\377\377\0\247\314\203\221\317\346\272\374\343\366\320\377\341\365\316"
-  "\377\357\372\345\377\365\373\361\377\245\314\200\367|\265G\310\336\354"
-  "\321^\377\377\377\27\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
   "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
-  "\377\0\247\314\203\221\317\346\270\374\347\367\330\377\364\373\356\377"
-  "\310\341\260\372q\2566\343\276\332\244z\375\375\375)\377\377\377\1\377"
-  "\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377"
-  "\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\247"
-  "\314\203\221\315\345\266\374\340\360\321\376x\263A\360\235\307u\232\377"
-  "\377\377;\377\377\377\7\377\377\377\0\377\377\377\0\377\377\377\0\377"
-  "\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377"
+  "\377\0\377\377\377\0\377\377\377\0;u\5_\302\341\244\372\275\352\221\377"
+  "\257\345z\377\257\345{\377\260\346|\377\306\355\240\377\263\331\217\370"
+  "<n\14U\377\377\377\0\377\377\377\0""1@\"'\225\304h\360\325\353\277\374"
+  "l\253/\346L\201\32oEEE\33UUU\2\377\377\377\0\377\377\377\0\377\377\377"
+  "\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377"
+  "\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0;u\5_\303\342"
+  "\246\372\270\350\211\377\251\343p\377\252\343r\377\252\343s\377\302\353"
+  "\232\377\265\332\221\370Ds\26Z\377\377\377\0\377\377\377\0 at N3,\227\305"
+  "k\360\340\365\313\377\353\367\335\377\273\333\233\367_\241\37\322Vy5"
+  "Q```\25\0\0\0\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377"
+  "\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377"
+  "\0\377\377\377\0;u\5_\305\342\250\372\274\351\221\377\257\345z\377\260"
+  "\345|\377\260\345|\377\306\354\241\377\266\332\224\370Mz\"^\377\377\377"
+  "\0\377\377\377\0P\\D0\230\306m\361\324\361\270\377\271\350\211\377\325"
+  "\362\271\377\354\367\341\377\230\306m\361^\234\"\263s\202e=\200\200\200"
+  "\16\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377"
+  "\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\77v\14d\306"
+  "\343\252\372\301\353\230\377\265\347\204\377\266\347\205\377\266\347"
+  "\206\377\313\356\250\377\270\333\227\370W\202.c\377\377\377\0\377\377"
+  "\377\0alU4\231\306n\361\327\362\274\377\276\352\223\377\300\353\226\377"
+  "\305\354\236\377\345\367\323\377\343\362\323\376z\264C\355i\2359\220"
+  "\231\233\230.\237\237\237\6\377\377\377\0\377\377\377\0\377\377\377\0"
+  "\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0Ez\24h\307\343"
+  "\255\372\305\354\240\377\272\351\215\377\274\351\217\377\274\351\220"
+  "\377\317\357\257\377\272\333\231\371b\213;h\377\377\377\0\377\377\377"
+  "\0r}h7\233\307q\361\332\363\301\377\303\353\234\377\306\355\237\377\307"
+  "\355\242\377\310\355\244\377\321\360\263\377\356\371\343\377\312\344"
+  "\262\372i\251-\341\205\250ep\272\272\272$\252\252\252\1\377\377\377\0"
+  "\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0L~\35m\311\344"
+  "\257\372\312\356\247\377\300\352\226\377\301\353\231\377\302\353\232"
+  "\377\323\361\266\377\273\334\234\371o\226Jl\377\377\377\0\377\377\377"
+  "\0\204\216z;\235\310u\362\335\364\307\377\311\355\245\377\313\356\251"
+  "\377\315\357\253\377\316\357\256\377\317\357\257\377\317\357\257\377"
+  "\336\364\310\377\357\371\347\377\250\317\203\366k\2510\312\263\305\242"
+  "Y\331\331\331\30\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377"
+  "\0U\205'r\312\344\261\372\316\360\257\377\306\354\240\377\307\355\242"
+  "\377\310\355\244\377\330\362\275\377\275\334\237\371|\242Yr\377\377\377"
+  "\0\377\377\377\0\226\237\215\77\241\312z\363\342\365\317\377\316\357"
+  "\257\377\321\357\263\377\322\360\265\377\324\361\267\377\324\361\270"
+  "\377\325\361\271\377\325\361\270\377\324\361\267\377\346\367\325\377"
+  "\351\365\335\377\207\274T\361\203\267R\254\350\354\343E\367\367\367\14"
+  "\377\377\377\0\377\377\377\0_\2153w\313\345\263\372\323\360\266\377\313"
+  "\356\251\377\315\357\254\377\316\357\255\377\334\364\304\377\277\335"
+  "\241\371\212\256hv\377\377\377\0\377\377\377\0\250\261\240D\242\313|"
+  "\364\346\367\326\377\324\361\267\377\326\361\274\377\330\362\277\377"
+  "\331\362\301\377\332\363\302\377\332\363\302\377\332\363\301\377\330"
+  "\362\277\377\325\361\270\377\325\361\272\377\355\371\341\377\326\352"
+  "\301\375r\2608\354\251\316\206\215\377\377\3773\377\377\377\4j\226@|"
+  "\315\345\265\373\327\362\275\377\321\360\263\377\323\360\266\377\324"
+  "\361\267\377\337\365\313\377\300\335\244\371\231\274x{\377\377\377\0"
+  "\377\377\377\0\273\304\263H\243\313~\363\352\370\334\377\333\363\303"
+  "\377\334\363\305\377\337\364\311\377\340\364\312\377\340\364\314\377"
+  "\340\365\314\377\337\365\312\377\336\364\310\377\332\363\302\377\325"
+  "\361\272\377\321\360\263\377\332\363\302\377\360\371\346\377\267\331"
+  "\226\371p\2575\331\304\335\254`u\240L\200\316\345\267\373\333\364\304"
+  "\377\326\362\274\377\331\362\277\377\332\363\301\377\344\366\322\377"
+  "\302\336\247\372\251\312\211\200\377\377\377\0\377\377\377\0\316\326"
+  "\306L\243\314}\363\355\371\341\377\341\365\317\377\341\365\317\377\344"
+  "\366\323\377\346\366\325\377\346\366\326\377\346\366\325\377\345\367"
+  "\323\377\342\366\320\377\340\365\314\377\333\364\304\377\325\361\272"
+  "\377\335\364\306\377\360\371\350\377\267\331\227\371q\2576\331\302\334"
+  "\252]\202\253[\204\317\346\271\373\337\364\313\377\334\363\305\377\336"
+  "\364\311\377\337\365\313\377\350\367\331\377\303\340\251\372\263\323"
+  "\224\203\377\377\377\0\377\377\377\0\341\350\331P\244\314~\364\356\371"
+  "\344\377\347\367\330\377\351\370\332\377\351\370\333\377\353\370\337"
+  "\377\355\370\340\377\354\370\336\377\351\367\334\377\347\367\327\377"
+  "\343\366\322\377\343\366\322\377\361\372\351\377\327\352\304\375s\261"
+  "9\354\251\316\206\214\375\375\3750\377\377\377\3\217\267i\211\320\346"
+  "\273\373\343\366\321\377\341\365\315\377\344\366\322\377\345\366\325"
+  "\377\354\371\337\377\304\340\254\372\263\323\224\203\377\377\377\0\377"
+  "\377\377\0\355\364\346R\244\314~\364\360\372\346\377\352\370\335\377"
+  "\355\371\343\377\357\371\346\377\361\372\351\377\362\372\352\377\361"
+  "\372\350\377\356\371\343\377\354\370\337\377\363\372\352\377\355\367"
+  "\346\376\211\275W\363\215\277^\256\365\371\361E\377\377\377\13\377\377"
+  "\377\0\377\377\377\0\236\304y\216\322\347\275\373\347\367\326\377\346"
+  "\367\325\377\351\370\333\377\353\370\336\377\360\372\347\377\306\340"
+  "\255\372\263\323\224\203\377\377\377\0\377\377\377\0\355\364\346R\244"
+  "\314~\364\361\372\350\377\354\371\340\377\361\372\350\377\364\373\355"
+  "\377\367\374\362\377\370\375\364\377\366\374\360\377\366\374\361\377"
+  "\366\373\363\377\257\322\213\366y\263A\315\331\351\312`\377\377\377\30"
+  "\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\247\314\203"
+  "\221\322\347\276\373\351\370\333\377\352\370\334\377\357\371\344\377"
+  "\361\372\350\377\364\373\355\377\307\340\260\372\263\323\224\203\377"
+  "\377\377\0\377\377\377\0\355\364\346R\243\313}\364\361\372\347\377\355"
+  "\371\341\377\362\373\352\377\366\374\361\377\373\375\370\377\375\376"
+  "\375\377\373\375\372\377\322\345\276\373s\260:\344\272\327\236|\375\375"
+  "\375)\377\377\377\1\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\247\314\203\221\323\350\277\373\354\371\337\377"
+  "\355\371\342\377\363\373\354\377\367\374\362\377\370\375\364\377\310"
+  "\341\261\372\263\323\224\203\377\377\377\0\377\377\377\0\355\364\346"
+  "R\243\313|\364\360\372\347\377\353\370\336\377\361\372\347\377\366\374"
+  "\357\377\374\376\372\377\352\363\341\376\200\267L\360\232\306q\236\377"
+  "\377\377:\377\377\377\7\377\377\377\0\377\377\377\0\377\377\377\0\377"
   "\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\247\314\203\221"
-  "a\246\40\371\202\271N\274\353\363\343S\377\377\377\22\377\377\377\0\377"
+  "\323\350\277\373\354\371\340\377\357\371\345\377\366\374\360\377\374"
+  "\376\373\377\373\376\370\377\311\341\262\372\263\323\224\203\377\377"
+  "\377\0\377\377\377\0\355\364\346R\243\313|\364\356\371\343\377\350\367"
+  "\331\377\364\373\356\377\365\372\361\377\240\311y\365\204\271Q\276\352"
+  "\363\341S\377\377\377\22\377\377\377\0\377\377\377\0\377\377\377\0\377"
   "\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377"
+  "\377\377\0\247\314\203\221\323\350\277\373\354\371\337\377\356\371\344"
+  "\377\365\373\357\377\372\375\367\377\372\375\366\377\311\341\262\372"
+  "\263\323\224\203\377\377\377\0\377\377\377\0\355\364\346R\243\314}\364"
+  "\363\373\353\377\365\373\360\377\301\335\246\371u\260<\333\311\340\264"
+  "n\374\374\374\"\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377"
+  "\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377"
+  "\0\377\377\377\0\377\377\377\0\247\314\203\221\323\347\276\373\355\371"
+  "\341\377\356\372\344\377\363\373\354\377\365\374\360\377\367\374\362"
+  "\377\310\340\261\372\263\323\224\203\377\377\377\0\377\377\377\0\355"
+  "\364\346R\240\313x\365\333\353\312\375u\262=\354\251\316\206\215\377"
+  "\377\3773\377\377\377\4\377\377\377\0\377\377\377\0\377\377\377\0\377"
   "\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377"
-  "\377\377\0\377\377\377\0\377\377\377\0\270\327\234U\310\337\261h\374"
-  "\374\374#\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377"
-  "\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377"
-  "\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377"
-  "\377\377\0\377\377\377\0"};
+  "\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\263\324\225\211"
+  "\242\314{\367\337\356\320\377\340\357\322\377\341\357\324\377\342\357"
+  "\325\377\342\357\325\377\230\305n\367\300\333\247z\377\377\377\0\377"
+  "\377\377\0\355\365\346OT\236\16\370\214\276]\257\365\371\361G\377\377"
+  "\377\14\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\77\265\324\227\207\224\302i\240\224\302i\240\224\302i\240\224\302"
+  "i\240\224\302i\240\273\330\237\202\377\377\377;\377\377\377\0\377\377"
+  "\377\0\361\367\354\32\322\345\277N\373\373\373\32\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377"
+  "\377\0\377\377\377\0\377\377\377\0\377\377\377\0\377\377\377\0"};
 
 



From mean at mail.berlios.de  Wed Aug 12 19:51:08 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Wed, 12 Aug 2009 19:51:08 +0200
Subject: [Avidemux-svn-commit] r5240 -
	branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_GTK/ADM_filters
Message-ID: <200908121751.n7CHp8j5014325@sheep.berlios.de>

Author: mean
Date: 2009-08-12 19:51:08 +0200 (Wed, 12 Aug 2009)
New Revision: 5240

Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_GTK/ADM_filters/gui_filtermanager.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_GTK/ADM_filters/gui_filtermanager_dialog.cpp
Log:
[UI/Gtk] Better looking filter dialog by JM

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_GTK/ADM_filters/gui_filtermanager.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_GTK/ADM_filters/gui_filtermanager.cpp	2009-08-12 17:51:06 UTC (rev 5239)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_GTK/ADM_filters/gui_filtermanager.cpp	2009-08-12 17:51:08 UTC (rev 5240)
@@ -62,24 +62,30 @@
 static gulong row_inserted_id;
 static gulong row_deleted_id;
 
-static void on_treeview0_row_deleted(GtkTreeModel *treemodel, GtkTreePath *arg1, gpointer user_data);
-static void on_treeview0_row_inserted(GtkTreeModel *treemodel, GtkTreePath *arg1, GtkTreeIter *arg2, gpointer user_data);
-static void on_treeview1_size_allocate(GtkWidget *widget, GtkAllocation *allocation, GtkCellRenderer *cell);
+static void on_treeActive_row_deleted(GtkTreeModel *treemodel, GtkTreePath *arg1, gpointer user_data);
+static void on_treeActive_row_inserted(GtkTreeModel *treemodel, GtkTreePath *arg1, GtkTreeIter *arg2, gpointer user_data);
+static void on_tree_size_allocate(GtkWidget *widget, GtkAllocation *allocation, GtkCellRenderer *cell);
 static void on_action (gui_act action);
 static void on_action_double_click (GtkButton * button, gpointer user_data);
 static void on_action_double_click_1 (GtkButton * button, gpointer user_data);
+static void on_action_change_category (GtkWidget *tree, gpointer user_data);
 static void updateFilterList (void);
 static VF_FILTERS getFilterFromSelection (void);
-static void wrapToolButton(GtkWidget * wid, gpointer user_data);
+static void button_clicked(GtkWidget * wid, gpointer user_data);
 //___________________________________________
 #define NB_TREE 9
+const   gint tree_width = 300;
 static  uint32_t max = 0;
-static  GtkWidget *trees[NB_TREE];
+static  GtkListStore *storeCategories;
+static  GtkWidget *treeCategories;
+static  GtkWidget *treeAvailable;
+static  GtkWidget *treeActive;
 static  GtkListStore *stores[NB_TREE];
 static  GtkTreeViewColumn *columns[NB_TREE];
 static  GtkCellRenderer *renderers[NB_TREE];
 static  int startFilter[NB_TREE];
 //___________________________________________
+static GtkWidget *createTree (const gchar *ref);
 static GtkWidget *createFilterDialog (void);
 extern GtkWidget *create_dialog1 (void);
 static GtkWidget *dialog = 0;
@@ -106,10 +112,10 @@
         GdkWMDecoration decorations=(GdkWMDecoration)0;
         gtk_widget_realize(dialog);
         gdk_window_set_decorations(dialog->window, (GdkWMDecoration)(GDK_DECOR_ALL | GDK_DECOR_MINIMIZE));
-        GdkScreen* screen = gdk_screen_get_default();
+        /*GdkScreen* screen = gdk_screen_get_default();
         gint width = gdk_screen_get_width(screen);
         if(width>=1024)
-            gtk_window_set_default_size(GTK_WINDOW(dialog), 900, 600);
+            gtk_window_set_default_size(GTK_WINDOW(dialog), 900, 600);*/
         updateFilterList ();
         gtk_register_dialog (dialog);
         //gtk_widget_show (dialog);
@@ -131,25 +137,6 @@
     
 }
 
-// gtk_dialog_add_action_widget seems buggy for toolbar button
-// workaround it...
-void
-wrapToolButton(GtkWidget * wid, gpointer user_data)
-{
-        gui_act action;
-#ifdef ADM_CPU_64BIT
-#define TPE long long int
-	long long int dummy;
-#else
-        int dummy;
-#define TPE int
-#endif
-
-        dummy=(TPE)user_data;
-
-        action=(gui_act) dummy;
-        on_action(action);
-}
 //
 // One of the button of the main dialog was pressed
 // Retrieve also the associated filter and handle
@@ -163,7 +150,7 @@
     action_parameter = 0;
     if (nb_active_filter > 1)
         if (getSelectionNumber(nb_active_filter - 1,
-                                WID(treeview0),
+                                WID(treeviewActive),
                                 stores[0],
                                 &action_parameter))
             action_parameter++;
@@ -188,31 +175,31 @@
         videofilters[nb_active_filter].conf = coup;
         nb_active_filter++;
         updateFilterList ();
-        setSelectionNumber(nb_active_filter-1, WID(treeview0), stores[0], nb_active_filter-2);
+        setSelectionNumber(nb_active_filter-1, WID(treeviewActive), stores[0], nb_active_filter-2);
         break;
 
     case A_VCD:
         setVCD ();
         updateFilterList ();
-        setSelectionNumber(nb_active_filter-1, WID(treeview0), stores[0], nb_active_filter-2);
+        setSelectionNumber(nb_active_filter-1, WID(treeviewActive), stores[0], nb_active_filter-2);
         break;
 
     case A_SVCD:
         setSVCD ();
         updateFilterList ();
-        setSelectionNumber(nb_active_filter-1, WID(treeview0), stores[0], nb_active_filter-2);
+        setSelectionNumber(nb_active_filter-1, WID(treeviewActive), stores[0], nb_active_filter-2);
         break;
 
     case A_DVD:
         setDVD ();
         updateFilterList ();
-        setSelectionNumber(nb_active_filter-1, WID(treeview0), stores[0], nb_active_filter-2);
+        setSelectionNumber(nb_active_filter-1, WID(treeviewActive), stores[0], nb_active_filter-2);
         break;
 
     case A_HALFD1:
         setHalfD1 ();
         updateFilterList ();
-        setSelectionNumber(nb_active_filter-1, WID(treeview0), stores[0], nb_active_filter-2);
+        setSelectionNumber(nb_active_filter-1, WID(treeviewActive), stores[0], nb_active_filter-2);
         break;
 
     default:
@@ -227,7 +214,7 @@
         videofilters[action_parameter].conf = couple;
         getFirstVideoFilter ();
         updateFilterList ();
-        setSelectionNumber(nb_active_filter-1, WID(treeview0), stores[0], action_parameter-1);
+        setSelectionNumber(nb_active_filter-1, WID(treeviewActive), stores[0], action_parameter-1);
         break;
 
     case A_PARTIAL:
@@ -255,7 +242,7 @@
 			videofilters[action_parameter].tag = VF_PARTIAL_FILTER;
 			getFirstVideoFilter ();
 			updateFilterList ();
-			setSelectionNumber(nb_active_filter-1, WID(treeview0), stores[0], action_parameter-1);
+			setSelectionNumber(nb_active_filter-1, WID(treeviewActive), stores[0], action_parameter-1);
         }
         else delete replace;
         break;
@@ -272,7 +259,7 @@
         // select action_parameter -1
         updateFilterList ();
         setSelectionNumber (nb_active_filter - 1,
-			      WID(treeview0),
+			      WID(treeviewActive),
 			      stores[0], action_parameter - 2);
         break;
 
@@ -288,7 +275,7 @@
             getFirstVideoFilter ();
             updateFilterList ();
             setSelectionNumber (nb_active_filter - 1,
-			      WID(treeview0),
+			      WID(treeviewActive),
 			      stores[0], action_parameter);
         }
         break;
@@ -317,8 +304,8 @@
 		videofilters[nb_active_filter - 1].filter = NULL;
 		nb_active_filter--;
         updateFilterList ();
-        if(!setSelectionNumber(nb_active_filter-1, WID(treeview0), stores[0], action_parameter-1))
-            setSelectionNumber(nb_active_filter-1, WID(treeview0), stores[0], action_parameter-2);
+        if(!setSelectionNumber(nb_active_filter-1, WID(treeviewActive), stores[0], action_parameter-1))
+            setSelectionNumber(nb_active_filter-1, WID(treeviewActive), stores[0], action_parameter-2);
 		break;
 
     case A_DONE:
@@ -340,7 +327,7 @@
         GUI_FileSelRead (QT_TR_NOOP("Load set of filters"), filterLoad);
 #endif
         updateFilterList ();
-        setSelectionNumber(nb_active_filter-1, WID(treeview0), stores[0], 0);
+        setSelectionNumber(nb_active_filter-1, WID(treeviewActive), stores[0], 0);
         break;
     case A_CLOSE:
         //gtk_widget_destroy(dialog);
@@ -372,20 +359,42 @@
 */
 VF_FILTERS getFilterFromSelection (void)
 {
-    uint32_t sel = 0;
+    uint32_t sel = 0, category = 0;
 	uint8_t ret = 0;
     VF_FILTERS tag = VF_INVALID;
     // 1- identify the current tab/treeview we are in
-    int page = gtk_notebook_get_current_page(GTK_NOTEBOOK(lookup_widget(dialog,"notebook1")));
+    ret = getSelectionNumber (VF_MAX+1, treeCategories, storeCategories, &category);
     // then get the selection
-    page++;
-    if ((ret = getSelectionNumber (max, trees[page], stores[page], &sel)))
-	{
-        tag = filterCategories[page-1][sel]->tag;
-	}
+    category++;
+    if (ret == 1)
+    {
+        if ((ret = getSelectionNumber (max, treeAvailable, stores[category], &sel)))
+        {
+            tag = filterCategories[category-1][sel]->tag;
+        }
+    }
     return tag;
 }
+
 /**
+ * 	\fn createTree
+ *  \brief Set up a TreeView for the Available and Active Filters list
+ */
+GtkWidget *createTree (const gchar *ref)
+{
+	GtkWidget *tree = lookup_widget (dialog, ref); 
+	GtkCellRenderer *renderer = gtk_cell_renderer_text_new ();
+	GtkTreeViewColumn *column = gtk_tree_view_column_new_with_attributes ("", renderer, "markup", (GdkModifierType) 0, NULL);
+	gtk_widget_set_size_request (tree, tree_width, -1);
+	g_object_set (renderer, "ypad", 6, NULL);
+	g_object_set (renderer, "wrap-width", tree_width-8, NULL);
+	g_object_set (renderer, "wrap-mode", PANGO_WRAP_WORD_CHAR, NULL);
+	gtk_tree_view_append_column (GTK_TREE_VIEW(tree), column);
+	g_signal_connect (G_OBJECT(tree), "size-allocate", G_CALLBACK(on_tree_size_allocate), renderer);
+	return tree;
+}
+
+/**
  * 	\fn createFilterDialog
  *  \brief Create the dialog including list of all filters available on the left.
  * 
@@ -393,114 +402,133 @@
 GtkWidget *
 createFilterDialog (void)
 {
-    dialog = create_dialog1();
+	dialog = create_dialog1();
+	GtkTreeIter iter;
 
-    //connect toolbar
-#define CALLME_TOOLBAR(x,y) gtk_signal_connect(GTK_OBJECT(WID(x)),"clicked",  GTK_SIGNAL_FUNC(wrapToolButton), (void *) y);
-#define CALLME(x,y) gtk_dialog_add_action_widget (GTK_DIALOG (dialog), WID(x), y)
+	//Connect buttons from the Available and Active Filters list
+	#define CONNECT(button, action) g_signal_connect (G_OBJECT(WID(button)), "clicked", G_CALLBACK(button_clicked), (void*)action);
 
+	CONNECT (buttonAdd, A_ADD)
+	CONNECT (buttonRemove, A_REMOVE)
+	CONNECT (buttonProperties, A_CONFIGURE)
+	CONNECT (buttonUp, A_UP)
+	CONNECT (buttonDown, A_DOWN)
+	CONNECT (buttonPreview, A_PREVIEW)
+	CONNECT (buttonPartial, A_PARTIAL)
+	CONNECT (buttonVCDRes, A_VCD)
+	CONNECT (buttonSVCDRes, A_SVCD)
+	CONNECT (buttonHalfD1Res, A_HALFD1)
+	CONNECT (buttonDVDRes, A_DVD)
+	CONNECT (buttonOpen, A_LOAD)
+	CONNECT (buttonSave, A_SAVE)
 
-        // Each of these triggers the following message:
-        // Gtk-CRITICAL **: gtk_box_pack_end: assertion `child->parent == NULL' failed
-        CALLME (buttonRemove,		A_REMOVE);
-        CALLME (buttonProperties,	A_CONFIGURE);
-        CALLME (buttonUp, 		A_UP);
-        CALLME (buttonDown, 		A_DOWN);
-        CALLME (buttonPreview, 		A_PREVIEW);
-        CALLME (buttonPartial, 		A_PARTIAL);
-        CALLME (buttonAdd, 		A_ADD);
-        
-        CALLME_TOOLBAR (toolbuttonHalfD1, 	A_HALFD1);
-        CALLME_TOOLBAR (toolbuttonScript, 	A_SCRIPT);
-        CALLME_TOOLBAR (toolbuttonVCD, 		A_VCD);
-        CALLME_TOOLBAR (toolbuttonSVCD, 	A_SVCD);
-        CALLME_TOOLBAR (toolbuttonDVD, 		A_DVD);
-        CALLME_TOOLBAR (toolbuttonSave, 	A_SAVE);
-        CALLME_TOOLBAR (toolbuttonScript, 	A_SAVE);
-        CALLME_TOOLBAR (toolbuttonOpen, 	A_LOAD);
-        
+	//Create TreeView with the filter categories
+	enum
+	{
+		ICON_COLUMN,
+		CATEGORY_COLUMN,
+		N_COLUMNS
+	};
 
-    //create treeviews
-    // Treeview zero is reserved and does not contain
-    //
-    trees[0]=lookup_widget(dialog,"treeview0");
-    stores[0]=gtk_list_store_new (3, G_TYPE_STRING, G_TYPE_INT, G_TYPE_POINTER);
-    #define LOOK(x) {trees[x]=lookup_widget(dialog,"treeview"#x);\
-                    stores[x]=gtk_list_store_new (1, G_TYPE_STRING);}
-    LOOK(1);
-    LOOK(2);
-    LOOK(3);
-    LOOK(4);
-    LOOK(5);
-    LOOK(6);
-    LOOK(7);
-    LOOK(8);
+	storeCategories = gtk_list_store_new (N_COLUMNS, GDK_TYPE_PIXBUF, G_TYPE_STRING);
+	GdkPixbuf *pb;
 
-    //load stores with filter names, get start filter for each page
-    char *str=NULL;
-    GtkTreeIter iter;
-    
-    // Dispatch each category to the matching tree
-    for(int current_tree=0;current_tree< VF_MAX;current_tree++)
-    {
-    	 std::vector <FilterDescriptor *> vec=filterCategories[current_tree];
-    	for (uint32_t i = 0; i < vec.size(); i++)
-    	{		
-		 str = g_strconcat(
-				 "<span weight=\"bold\">", vec[i]->name, "</span>\n",
-                 "<span size=\"smaller\">", vec[i]->description, "</span>", NULL);
-				
-            gtk_list_store_append (stores[current_tree+1], &iter);
-            gtk_list_store_set (stores[current_tree+1], &iter, 0, str ,-1);
-            g_free(str);
-            max++;
-    	}
-    }
+	#define ADD_CATEGORY(icon, category) \
+		gtk_list_store_append (storeCategories, &iter); \
+		pb = create_pixbuf (#icon); \
+		gtk_list_store_set (storeCategories, &iter, ICON_COLUMN, pb, CATEGORY_COLUMN, QT_TR_NOOP(#category), -1);
 
-    //setup treeviews
-    for(int i=0;i<VF_MAX+1;i++)
-    {
-        renderers[i] = gtk_cell_renderer_text_new();
-   		columns[i] = gtk_tree_view_column_new_with_attributes (
-                            "",
-                            renderers[i],
-                            "markup", (GdkModifierType) 0,
-                            NULL);
-		gtk_cell_renderer_text_set_fixed_height_from_font
-			(GTK_CELL_RENDERER_TEXT(renderers[i]), 3);
-        g_object_set(renderers[i], "wrap-width", 0, NULL);
-        gtk_tree_view_append_column(GTK_TREE_VIEW (trees[i]), columns[i]);
-        gtk_tree_view_set_model(GTK_TREE_VIEW(trees[i]),GTK_TREE_MODEL (stores[i]));
+	ADD_CATEGORY (1.png, Transform)
+	ADD_CATEGORY (2.png, Interlacing)
+	ADD_CATEGORY (4.png, Colors)
+	ADD_CATEGORY (5.png, Noise)
+	ADD_CATEGORY (3.png, Sharpness)
+	ADD_CATEGORY (7.png, Subtitles)
+	ADD_CATEGORY (6.png, Miscellaneous)
+	ADD_CATEGORY (film1.xpm, External)
 
-		// Add double click, 0 is active filter tree
-        if(i)
-        	g_signal_connect (G_OBJECT(trees[i]),
-                      "row-activated",
-                      G_CALLBACK(on_action_double_click),
-                      (void *) dialog);
-  		else
-  		{
-            gtk_tree_view_set_reorderable(GTK_TREE_VIEW(trees[i]), true);
-  			g_signal_connect(G_OBJECT(WID(treeview0)),
-  						"row-activated",
-        				G_CALLBACK(on_action_double_click_1),
-        				(void *)NULL);
-   			row_inserted_id=g_signal_connect(G_OBJECT(stores[i]),
-  						"row-inserted",
-        				G_CALLBACK(on_treeview0_row_inserted),
-        				(void *)NULL);
-   			row_deleted_id=g_signal_connect(G_OBJECT(stores[i]),
-  						"row-deleted",
-        				G_CALLBACK(on_treeview0_row_deleted),
-        				(void *)NULL);
-  		}
-        g_signal_connect(G_OBJECT(trees[i]),
-                      "size-allocate",
-                      G_CALLBACK(on_treeview1_size_allocate),
-                      renderers[i]);
-    }
+	treeCategories = lookup_widget (dialog, "mainTree");
+	gtk_tree_view_set_model (GTK_TREE_VIEW(treeCategories), GTK_TREE_MODEL(storeCategories));
+	gtk_tree_view_set_headers_visible (GTK_TREE_VIEW(treeCategories), FALSE);
+
+	GtkCellRenderer *renderer;
+	renderer = gtk_cell_renderer_pixbuf_new();
+
+	GtkTreeViewColumn *column;
+	column = gtk_tree_view_column_new ();
+	gtk_tree_view_append_column (GTK_TREE_VIEW(treeCategories), column);
+	gtk_tree_view_column_pack_start (column, renderer, TRUE);
+	gtk_tree_view_column_add_attribute (column, renderer, "pixbuf", ICON_COLUMN);
+
+	column = gtk_tree_view_column_new ();
+	gtk_tree_view_append_column (GTK_TREE_VIEW(treeCategories), column);
+
+	renderer = gtk_cell_renderer_text_new ();
+	gtk_tree_view_column_pack_start (column, renderer, TRUE);
+	gtk_tree_view_column_add_attribute (column, renderer, "text", CATEGORY_COLUMN);
+	g_object_set (renderer, "ypad", 6, NULL);
+
+	//Create ListStores with filters, store zero is the Active Filters list
+	stores[0]=gtk_list_store_new (3, G_TYPE_STRING, G_TYPE_INT, G_TYPE_POINTER);
+
+	#define CREATE_STORE(x) stores[x] = gtk_list_store_new (1, G_TYPE_STRING);
+
+	CREATE_STORE (1)
+	CREATE_STORE (2)
+	CREATE_STORE (3)
+	CREATE_STORE (4)
+	CREATE_STORE (5)
+	CREATE_STORE (6)
+	CREATE_STORE (7)
+	CREATE_STORE (8)
+
+	//load stores with filter names, get start filter for each page
+	char *str=NULL;
+
+	// Dispatch each category to the matching tree
+	for(int current_tree=0;current_tree< VF_MAX;current_tree++)
+	{
+		std::vector <FilterDescriptor *> vec=filterCategories[current_tree];
+		for (uint32_t i = 0; i < vec.size(); i++)
+		{
+			str = g_strconcat(
+				"<span weight=\"bold\">", vec[i]->name, "</span>\n",
+				"<span size=\"smaller\">", vec[i]->description, "</span>", NULL);
+
+			gtk_list_store_append (stores[current_tree+1], &iter);
+			gtk_list_store_set (stores[current_tree+1], &iter, 0, str ,-1);
+			g_free(str);
+			max++;
+		}
+	}
+
+	//Create TreeViews with available and active filters
+	treeAvailable = createTree ("treeviewAvailable");
+	g_signal_connect (G_OBJECT(treeAvailable), "row-activated", G_CALLBACK(on_action_double_click), (void *) dialog);
+	g_signal_connect (G_OBJECT(treeCategories), "cursor-changed", G_CALLBACK(on_action_change_category), NULL);
+
+	treeActive = createTree ("treeviewActive");
+	gtk_tree_view_set_model (GTK_TREE_VIEW(treeActive), GTK_TREE_MODEL(stores[0]));
+	gtk_tree_view_set_reorderable (GTK_TREE_VIEW(treeActive), true);
+	g_signal_connect (G_OBJECT(treeActive), 
+		"row-activated", G_CALLBACK(on_action_double_click_1), 
+		(void *)NULL);
+	row_inserted_id = g_signal_connect (G_OBJECT(stores[0]), 
+		"row-inserted", 
+		G_CALLBACK(on_treeActive_row_inserted), 
+		(void *)NULL);
+	row_deleted_id = g_signal_connect (G_OBJECT(stores[0]), 
+		"row-deleted", 
+		G_CALLBACK(on_treeActive_row_deleted), 
+		(void *)NULL);
+
+	//Select the first category in treeCategories and show its filters in treeAvailable
+	gtk_widget_grab_focus (treeCategories);
+	GtkTreePath *gp = gtk_tree_path_new_first ();
+	gtk_tree_view_set_cursor (GTK_TREE_VIEW(treeCategories), gp, NULL, TRUE);
     return dialog;
 }
+
 /**
  * 	\fn updateFilterList
  *  \brief Update the list of activated filters
@@ -573,21 +601,30 @@
 }
 
 void
+on_action_change_category (GtkWidget * tree, gpointer user_data)
+{
+	GtkAdjustment *adj = gtk_scrolled_window_get_vadjustment (GTK_SCROLLED_WINDOW(WID(scrolledwindowAvailable)));
+	gtk_adjustment_set_value (adj, 0);
+
+	uint32_t number = 0;
+	if (getSelectionNumber (VF_MAX+1, tree, storeCategories, &number))
+		gtk_tree_view_set_model (GTK_TREE_VIEW(treeAvailable), GTK_TREE_MODEL(stores[number+1]));
+}
+
+void
 on_action_double_click_1 (GtkButton * button, gpointer user_data)
 {
     on_action(A_DOUBLECLICK);
 }
 
 void
-on_treeview1_size_allocate(GtkWidget *widget, GtkAllocation *allocation, GtkCellRenderer *cell)
+on_tree_size_allocate(GtkWidget *widget, GtkAllocation *allocation, GtkCellRenderer *cell)
 {
-    g_object_set(cell,
-              "wrap-width", allocation->width-8,
-              NULL);
+	g_object_set (cell, "wrap-width", allocation->width-8, NULL);
 }
 
 void
-on_treeview0_row_deleted(GtkTreeModel *treemodel, GtkTreePath *arg1, gpointer user_data)
+on_treeActive_row_deleted(GtkTreeModel *treemodel, GtkTreePath *arg1, gpointer user_data)
 {
     GtkTreeIter iter;
     VF_FILTERS				tag;
@@ -614,10 +651,24 @@
     //on_action(A_REORDERED);
 }
 void
-on_treeview0_row_inserted(GtkTreeModel *treemodel, GtkTreePath *arg1, GtkTreeIter *arg2, gpointer user_data)
+on_treeActive_row_inserted(GtkTreeModel *treemodel, GtkTreePath *arg1, GtkTreeIter *arg2, gpointer user_data)
 {
 
 
 }
 
+static void button_clicked(GtkWidget * wid, gpointer user_data)
+{
+	gui_act action;
+#ifdef ADM_CPU_64BIT
+#define TPE long long int
+	long long int dummy;
+#else
+	int dummy;
+#define TPE int
+#endif
+	dummy=(TPE)user_data;
+	action=(gui_act) dummy;
 
+	on_action(action);
+}

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_GTK/ADM_filters/gui_filtermanager_dialog.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_GTK/ADM_filters/gui_filtermanager_dialog.cpp	2009-08-12 17:51:06 UTC (rev 5239)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_GTK/ADM_filters/gui_filtermanager_dialog.cpp	2009-08-12 17:51:08 UTC (rev 5240)
@@ -17,100 +17,57 @@
 #define GLADE_HOOKUP_OBJECT_NO_REF(component,widget,name) \
   g_object_set_data (G_OBJECT (component), name, widget)
 
-#define GLADE_HOOKUP_OBJECT(component,widget,name) \
-  g_object_set_data_full (G_OBJECT (component), name, \
-    gtk_widget_ref (widget), (GDestroyNotify) gtk_widget_unref)
-
-#define GLADE_HOOKUP_OBJECT_NO_REF(component,widget,name) \
-  g_object_set_data (G_OBJECT (component), name, widget)
-
 GtkWidget*
 create_dialog1 (void)
 {
   GtkWidget *dialog1;
   GtkWidget *dialog_vbox1;
-  GtkWidget *vbox3b;
-  GtkWidget *toolbar1;
-  GtkIconSize tmp_toolbar_icon_size;
-  GtkWidget *toolbuttonOpen;
-  GtkWidget *toolbuttonSave;
+  GtkWidget *vbox1;
+  GtkWidget *vbox2;
   GtkWidget *tmp_image;
-  GtkWidget *toolbuttonScript;
-  GtkWidget *toolbuttonDVD;
-  GtkWidget *toolbuttonHalfD1;
-  GtkWidget *toolbuttonSVCD;
-  GtkWidget *toolbuttonVCD;
-  GtkWidget *hbox11;
-  GtkWidget *frame1;
+  GtkWidget *hbox1;
   GtkWidget *alignment1;
-  GtkWidget *vbox2;
-  GtkWidget *notebook1;
-  GtkWidget *scrolledwindow1;
-  GtkWidget *treeview1;
-  GtkWidget *hbox5;
-  GtkWidget *image1;
-  GtkWidget *label11;
-  GtkWidget *scrolledwindow2;
-  GtkWidget *treeview2;
-  GtkWidget *hbox6;
-  GtkWidget *image2;
-  GtkWidget *label17;
-  GtkWidget *scrolledwindow3;
-  GtkWidget *treeview3;
-  GtkWidget *hbox7;
-  GtkWidget *image3;
-  GtkWidget *label18;
-  GtkWidget *scrolledwindow4;
-  GtkWidget *treeview4;
-  GtkWidget *hbox8;
-  GtkWidget *image4;
-  GtkWidget *label19;
-  GtkWidget *scrolledwindow5;
-  GtkWidget *treeview5;
-  GtkWidget *hbox9;
-  GtkWidget *image5;
-  GtkWidget *label20;
-  GtkWidget *scrolledwindow6;
-  GtkWidget *treeview6;
-  GtkWidget *hbox10;
-  GtkWidget *image6;
-  GtkWidget *label21;
-  GtkWidget *scrolledwindow7;
-  GtkWidget *treeview7;
-  GtkWidget *hbox4;
-  GtkWidget *image7;
-  GtkWidget *label22;
-  GtkWidget *treeview8;
-  GtkWidget *label28;
-  GtkWidget *hbox13;
+  GtkWidget *table1;
+  GtkWidget *vbox3;
+  GtkWidget *table2;
+  GtkWidget *scrolledwindowAvailable;
+  GtkWidget *treeviewAvailable;
+  GtkWidget *buttonVCDRes;
+  GtkWidget *buttonSVCDRes;
+  GtkWidget *buttonHalfD1Res;
+  GtkWidget *hbox2;
+  GtkWidget *label1;
+  GtkWidget *buttonDVDRes;
+  GtkWidget *frame1;
+  GtkWidget *mainTree;
+  GtkWidget *hboxActionAvailable;
   GtkWidget *buttonAdd;
-  GtkWidget *image11;
-  GtkWidget *label23;
-  GtkWidget *frame2;
+  GtkWidget *image1;
+  GtkWidget *labelAvailable;
   GtkWidget *alignment2;
-  GtkWidget *hbox1;
-  GtkWidget *vbox3;
-  GtkWidget *scrolledwindow9;
-  GtkWidget *treeview0;
-  GtkWidget *hbox14;
+  GtkWidget *vbox4;
+  GtkWidget *scrolledwindowActive;
+  GtkWidget *treeviewActive;
+  GtkWidget *hboxActionActive;
   GtkWidget *buttonRemove;
-  GtkWidget *image15;
+  GtkWidget *image2;
   GtkWidget *buttonDown;
-  GtkWidget *image14;
+  GtkWidget *image3;
   GtkWidget *buttonUp;
-  GtkWidget *image13;
+  GtkWidget *image4;
+  GtkWidget *buttonOpen;
+  GtkWidget *buttonSave;
   GtkWidget *buttonPartial;
   GtkWidget *buttonProperties;
-  GtkWidget *alignment4;
-  GtkWidget *hbox16;
-  GtkWidget *label25;
+  GtkWidget *alignment3;
+  GtkWidget *hbox3;
   GtkWidget *label2;
+  GtkWidget *labelActive;
   GtkWidget *dialog_action_area1;
   GtkWidget *buttonPreview;
-  GtkWidget *alignment5;
-  GtkWidget *hbox17;
-  GtkWidget *image17;
-  GtkWidget *label26;
+  GtkWidget *alignment4;
+  GtkWidget *image5;
+  GtkWidget *label3;
   GtkWidget *buttonClose;
   GtkAccelGroup *accel_group;
   GtkTooltips *tooltips;
@@ -129,404 +86,208 @@
   gtk_box_set_spacing (GTK_BOX(dialog_vbox1), 12);
   gtk_widget_show (dialog_vbox1);
 
-  vbox3b = gtk_vbox_new (FALSE, 12);
-  gtk_widget_show (vbox3b);
-  gtk_box_pack_start (GTK_BOX (dialog_vbox1), vbox3b, TRUE, TRUE, 0);
-  gtk_container_set_border_width (GTK_CONTAINER (vbox3b), 6);
+  hbox1 = gtk_hbox_new (FALSE, 12);
+  gtk_container_set_border_width (GTK_CONTAINER (hbox1), 6);
+  gtk_widget_show (hbox1);
+  gtk_box_pack_start (GTK_BOX (dialog_vbox1), hbox1, TRUE, TRUE, 0);
 
-  toolbar1 = gtk_toolbar_new ();
-  gtk_widget_show (toolbar1);
-  gtk_box_pack_start (GTK_BOX (vbox3b), toolbar1, FALSE, FALSE, 0);
-  gtk_toolbar_set_style (GTK_TOOLBAR (toolbar1), GTK_TOOLBAR_BOTH);
-  tmp_toolbar_icon_size = gtk_toolbar_get_icon_size (GTK_TOOLBAR (toolbar1));
+  vbox1 = gtk_vbox_new (FALSE, 0);
+  gtk_widget_show (vbox1);
+  gtk_box_pack_start (GTK_BOX (hbox1), vbox1, TRUE, TRUE, 0);
 
-  toolbuttonOpen = (GtkWidget*) gtk_tool_button_new_from_stock ("gtk-open");
-  gtk_widget_show (toolbuttonOpen);
-  gtk_container_add (GTK_CONTAINER (toolbar1), toolbuttonOpen);
-  gtk_tool_item_set_tooltip (GTK_TOOL_ITEM (toolbuttonOpen), tooltips, QT_TR_NOOP("Open filter list [Ctrl-O]"), NULL);
-  gtk_widget_add_accelerator (toolbuttonOpen, "clicked", accel_group,
-                              GDK_O, (GdkModifierType) GDK_CONTROL_MASK,
-                              GTK_ACCEL_VISIBLE);
-  gtk_tool_item_set_is_important (GTK_TOOL_ITEM (toolbuttonOpen), TRUE);
+  vbox2 = gtk_vbox_new (FALSE, 0);
+  gtk_widget_show (vbox2);
+  gtk_box_pack_start (GTK_BOX (hbox1), vbox2, TRUE, TRUE, 0);
 
-  toolbuttonSave = (GtkWidget*) gtk_tool_button_new_from_stock ("gtk-save");
-  gtk_widget_show (toolbuttonSave);
-  gtk_container_add (GTK_CONTAINER (toolbar1), toolbuttonSave);
-  gtk_tool_item_set_tooltip (GTK_TOOL_ITEM (toolbuttonSave), tooltips, QT_TR_NOOP("Save filter list [Ctrl-S]"), NULL);
-  gtk_widget_add_accelerator (toolbuttonSave, "clicked", accel_group,
-                              GDK_S, (GdkModifierType) GDK_CONTROL_MASK,
-                              GTK_ACCEL_VISIBLE);
-  gtk_tool_item_set_is_important (GTK_TOOL_ITEM (toolbuttonSave), TRUE);
+  labelAvailable = gtk_label_new (QT_TR_NOOP("<b>Available Filters</b>"));
+  gtk_label_set_use_markup (GTK_LABEL (labelAvailable), TRUE);
+  gtk_misc_set_alignment (GTK_MISC (labelAvailable), 0, 0);
+  gtk_box_pack_start (GTK_BOX (vbox1), labelAvailable, FALSE, FALSE, 0);
+  gtk_widget_show (labelAvailable);
 
-  tmp_image = gtk_image_new_from_stock ("gtk-save-as", tmp_toolbar_icon_size);
-  gtk_widget_show (tmp_image);
-  toolbuttonScript = (GtkWidget*) gtk_tool_button_new (tmp_image, QT_TR_NOOP("Save Script"));
-  gtk_widget_show (toolbuttonScript);
-  gtk_container_add (GTK_CONTAINER (toolbar1), toolbuttonScript);
-  gtk_tool_item_set_tooltip (GTK_TOOL_ITEM (toolbuttonScript), tooltips, QT_TR_NOOP("Save as script [Ctrl-J]"), NULL);
-  gtk_widget_add_accelerator (toolbuttonScript, "clicked", accel_group,
-                              GDK_J, (GdkModifierType) GDK_CONTROL_MASK,
-                              GTK_ACCEL_VISIBLE);
-  gtk_tool_item_set_is_important (GTK_TOOL_ITEM (toolbuttonScript), TRUE);
+  alignment1 = gtk_alignment_new (0, 0, 1, 1);
+  gtk_alignment_set_padding (GTK_ALIGNMENT (alignment1), 6, 0, 18, 0);
+  gtk_box_pack_start (GTK_BOX (vbox1), alignment1, TRUE, TRUE, 0);
+  gtk_widget_show (alignment1);
 
-  tmp_image = gtk_image_new_from_stock ("gtk-cdrom", tmp_toolbar_icon_size);
-  gtk_widget_show (tmp_image);
-  toolbuttonDVD = (GtkWidget*) gtk_tool_button_new (tmp_image, QT_TR_NOOP("DVD Res"));
-  gtk_widget_show (toolbuttonDVD);
-  gtk_container_add (GTK_CONTAINER (toolbar1), toolbuttonDVD);
-  gtk_tool_item_set_tooltip (GTK_TOOL_ITEM (toolbuttonDVD), tooltips, QT_TR_NOOP("DVD resolution [Ctrl-1]"), NULL);
-  gtk_widget_add_accelerator (toolbuttonDVD, "clicked", accel_group,
-                              GDK_1, (GdkModifierType) GDK_CONTROL_MASK,
-                              GTK_ACCEL_VISIBLE);
-  gtk_tool_item_set_is_important (GTK_TOOL_ITEM (toolbuttonDVD), TRUE);
+  table1 = gtk_table_new (2, 2, FALSE);
+  gtk_table_set_row_spacings (GTK_TABLE (table1), 6);
+  gtk_table_set_col_spacings (GTK_TABLE (table1), 6);
+  gtk_container_add (GTK_CONTAINER (alignment1), table1);
+  gtk_widget_show (table1);
 
-  tmp_image = gtk_image_new_from_stock ("gtk-cdrom", tmp_toolbar_icon_size);
-  gtk_widget_show (tmp_image);
-  toolbuttonHalfD1 = (GtkWidget*) gtk_tool_button_new (tmp_image, QT_TR_NOOP("Half D1 Res"));
-  gtk_widget_show (toolbuttonHalfD1);
-  gtk_container_add (GTK_CONTAINER (toolbar1), toolbuttonHalfD1);
-  gtk_tool_item_set_tooltip (GTK_TOOL_ITEM (toolbuttonHalfD1), tooltips, QT_TR_NOOP("Half D1 resolution [Ctrl-2]"), NULL);
-  gtk_widget_add_accelerator (toolbuttonHalfD1, "clicked", accel_group,
-                              GDK_2, (GdkModifierType) GDK_CONTROL_MASK,
-                              GTK_ACCEL_VISIBLE);
-  gtk_tool_item_set_is_important (GTK_TOOL_ITEM (toolbuttonHalfD1), TRUE);
+  vbox3 = gtk_vbox_new (FALSE, 6);
+  gtk_table_attach (GTK_TABLE(table1), vbox3, 0, 1, 0, 1, GTK_SHRINK, GTK_FILL, 0, 0);
+  gtk_widget_show (vbox3);
 
-  tmp_image = gtk_image_new_from_stock ("gtk-cdrom", tmp_toolbar_icon_size);
-  gtk_widget_show (tmp_image);
-  toolbuttonSVCD = (GtkWidget*) gtk_tool_button_new (tmp_image, QT_TR_NOOP("SVCD Res"));
-  gtk_widget_show (toolbuttonSVCD);
-  gtk_container_add (GTK_CONTAINER (toolbar1), toolbuttonSVCD);
-  gtk_tool_item_set_tooltip (GTK_TOOL_ITEM (toolbuttonSVCD), tooltips, QT_TR_NOOP("SVCD resolution [Ctrl-3]"), NULL);
-  gtk_widget_add_accelerator (toolbuttonSVCD, "clicked", accel_group,
-                              GDK_3, (GdkModifierType) GDK_CONTROL_MASK,
-                              GTK_ACCEL_VISIBLE);
-  gtk_tool_item_set_is_important (GTK_TOOL_ITEM (toolbuttonSVCD), TRUE);
-
-  tmp_image = gtk_image_new_from_stock ("gtk-cdrom", tmp_toolbar_icon_size);
-  gtk_widget_show (tmp_image);
-  toolbuttonVCD = (GtkWidget*) gtk_tool_button_new (tmp_image, QT_TR_NOOP("VCD Res"));
-  gtk_widget_show (toolbuttonVCD);
-  gtk_container_add (GTK_CONTAINER (toolbar1), toolbuttonVCD);
-  gtk_tool_item_set_tooltip (GTK_TOOL_ITEM (toolbuttonVCD), tooltips, QT_TR_NOOP("VCD resolution [Ctrl-4]"), NULL);
-  gtk_widget_add_accelerator (toolbuttonVCD, "clicked", accel_group,
-                              GDK_4, (GdkModifierType) GDK_CONTROL_MASK,
-                              GTK_ACCEL_VISIBLE);
-  gtk_tool_item_set_is_important (GTK_TOOL_ITEM (toolbuttonVCD), TRUE);
-
-  hbox11 = gtk_hbox_new (FALSE, 12);
-  gtk_widget_show (hbox11);
-  gtk_box_pack_start (GTK_BOX (vbox3b), hbox11, TRUE, TRUE, 0);
-
   frame1 = gtk_frame_new (NULL);
+  gtk_frame_set_shadow_type (GTK_FRAME(frame1), GTK_SHADOW_IN);
   gtk_widget_show (frame1);
-  gtk_box_pack_start (GTK_BOX (hbox11), frame1, TRUE, TRUE, 0);
-  gtk_frame_set_shadow_type (GTK_FRAME (frame1), GTK_SHADOW_NONE);
+  gtk_box_pack_start (GTK_BOX (vbox3), frame1, TRUE, TRUE, 0);
 
-  alignment1 = gtk_alignment_new (0.5, 0.5, 1, 1);
-  gtk_widget_show (alignment1);
-  gtk_container_add (GTK_CONTAINER (frame1), alignment1);
-  gtk_alignment_set_padding (GTK_ALIGNMENT (alignment1), 6, 0, 18, 0);
+  mainTree =  gtk_tree_view_new ();
+  gtk_tree_view_set_headers_visible (GTK_TREE_VIEW(mainTree), FALSE);
+  gtk_tree_view_set_enable_search (GTK_TREE_VIEW (mainTree), FALSE);
+  gtk_widget_show (mainTree);
+  gtk_container_add (GTK_CONTAINER (frame1), mainTree);
+  
+  table2 = gtk_table_new (2, 2, TRUE);
+  gtk_table_set_row_spacings (GTK_TABLE(table2), 6);
+  gtk_table_set_col_spacings (GTK_TABLE(table2), 6);
+  gtk_widget_show (table2);
+  gtk_box_pack_start (GTK_BOX (vbox3), table2, FALSE, FALSE, 0);
 
-  vbox2 = gtk_vbox_new (FALSE, 6);
-  gtk_widget_show (vbox2);
-  gtk_container_add (GTK_CONTAINER (alignment1), vbox2);
+  buttonVCDRes = gtk_button_new_with_mnemonic (QT_TR_NOOP("_VCD"));
+  gtk_tooltips_set_tip (tooltips, buttonVCDRes, QT_TR_NOOP("VCD resolution"), NULL);
+  gtk_widget_show (buttonVCDRes);
+  gtk_table_attach_defaults (GTK_TABLE(table2), buttonVCDRes, 0, 1, 0, 1);
 
-  notebook1 = gtk_notebook_new ();
-  gtk_widget_show (notebook1);
-  gtk_box_pack_start (GTK_BOX (vbox2), notebook1, TRUE, TRUE, 0);
-  gtk_notebook_set_show_border (GTK_NOTEBOOK (notebook1), FALSE);
-  gtk_notebook_set_tab_pos (GTK_NOTEBOOK (notebook1), GTK_POS_LEFT);
+  buttonSVCDRes = gtk_button_new_with_mnemonic (QT_TR_NOOP("_SVCD"));
+  gtk_tooltips_set_tip (tooltips, buttonSVCDRes, QT_TR_NOOP("SVCD resolution"), NULL);
+  gtk_widget_show (buttonSVCDRes);
+  gtk_table_attach_defaults (GTK_TABLE(table2), buttonSVCDRes, 1, 2, 0, 1);
 
-  scrolledwindow1 = gtk_scrolled_window_new (NULL, NULL);
-  gtk_widget_show (scrolledwindow1);
-  gtk_container_add (GTK_CONTAINER (notebook1), scrolledwindow1);
-  gtk_scrolled_window_set_policy (GTK_SCROLLED_WINDOW (scrolledwindow1), GTK_POLICY_NEVER, GTK_POLICY_AUTOMATIC);
+  buttonHalfD1Res = gtk_button_new ();
+  gtk_tooltips_set_tip (tooltips, buttonHalfD1Res, QT_TR_NOOP("Half D1 resolution"), NULL);
+  gtk_widget_show (buttonHalfD1Res);
+  hbox2 = gtk_hbox_new (FALSE, 2);
+  gtk_widget_show (hbox2);
+  gtk_container_add (GTK_CONTAINER (buttonHalfD1Res), hbox2);
+  label1 = gtk_label_new_with_mnemonic (QT_TR_NOOP("<sup>1</sup>/<sub>2</sub> D_1"));
+  gtk_label_set_use_markup (GTK_LABEL(label1), TRUE);
+  gtk_widget_show (label1);
+  gtk_box_pack_start (GTK_BOX (hbox2), label1, FALSE, FALSE, 0);
+  gtk_table_attach_defaults (GTK_TABLE(table2), buttonHalfD1Res, 0, 1, 1, 2);
 
-  treeview1 = gtk_tree_view_new ();
-  gtk_widget_show (treeview1);
-  gtk_container_add (GTK_CONTAINER (scrolledwindow1), treeview1);
-  gtk_widget_set_size_request (treeview1, 288, 336);
-  gtk_tree_view_set_headers_visible (GTK_TREE_VIEW (treeview1), FALSE);
-  gtk_tree_view_set_rules_hint (GTK_TREE_VIEW (treeview1), TRUE);
-  gtk_tree_view_set_enable_search (GTK_TREE_VIEW (treeview1), FALSE);
+  buttonDVDRes = gtk_button_new_with_mnemonic (QT_TR_NOOP("_DVD"));
+  gtk_tooltips_set_tip (tooltips, buttonDVDRes, QT_TR_NOOP("DVD resolution"), NULL);
+  gtk_widget_show (buttonDVDRes);
+  gtk_table_attach_defaults (GTK_TABLE(table2), buttonDVDRes, 1, 2, 1, 2);
 
-  hbox5 = gtk_hbox_new (FALSE, 0);
-  gtk_widget_show (hbox5);
-  gtk_notebook_set_tab_label (GTK_NOTEBOOK (notebook1), gtk_notebook_get_nth_page (GTK_NOTEBOOK (notebook1), 0), hbox5);
+  scrolledwindowAvailable = gtk_scrolled_window_new (NULL, NULL);
+  gtk_table_attach_defaults (GTK_TABLE(table1), scrolledwindowAvailable, 1, 2, 0, 1);
+  gtk_scrolled_window_set_policy (GTK_SCROLLED_WINDOW (scrolledwindowAvailable), GTK_POLICY_NEVER, GTK_POLICY_AUTOMATIC);
+  gtk_scrolled_window_set_shadow_type (GTK_SCROLLED_WINDOW (scrolledwindowAvailable), GTK_SHADOW_IN);
+  gtk_widget_show (scrolledwindowAvailable);
 
-  image1 = create_pixmap (dialog1, "1.png");
-  gtk_widget_show (image1);
-  gtk_box_pack_start (GTK_BOX (hbox5), image1, FALSE, FALSE, 0);
+  treeviewAvailable = gtk_tree_view_new ();
+  gtk_widget_show (treeviewAvailable);
+  gtk_container_add (GTK_CONTAINER (scrolledwindowAvailable), treeviewAvailable);
+  gtk_tree_view_set_headers_visible (GTK_TREE_VIEW (treeviewAvailable), FALSE);
+  gtk_tree_view_set_rules_hint (GTK_TREE_VIEW (treeviewAvailable), TRUE);
+  gtk_tree_view_set_enable_search (GTK_TREE_VIEW (treeviewAvailable), FALSE);
 
-  label11 = gtk_label_new_with_mnemonic (QT_TR_NOOP("Transform"));
-  gtk_widget_show (label11);
-  gtk_box_pack_start (GTK_BOX (hbox5), label11, FALSE, FALSE, 4);
-  gtk_label_set_use_markup (GTK_LABEL (label11), TRUE);
+  hboxActionAvailable = gtk_hbox_new (FALSE, 6);
+  gtk_widget_show (hboxActionAvailable);
+  gtk_table_attach (GTK_TABLE(table1), hboxActionAvailable, 1, 2, 1, 2, GTK_FILL, GTK_FILL, 0, 0);
 
-  scrolledwindow2 = gtk_scrolled_window_new (NULL, NULL);
-  gtk_widget_show (scrolledwindow2);
-  gtk_container_add (GTK_CONTAINER (notebook1), scrolledwindow2);
-  gtk_scrolled_window_set_policy (GTK_SCROLLED_WINDOW (scrolledwindow2), GTK_POLICY_AUTOMATIC, GTK_POLICY_AUTOMATIC);
-
-  treeview2 = gtk_tree_view_new ();
-  gtk_widget_show (treeview2);
-  gtk_container_add (GTK_CONTAINER (scrolledwindow2), treeview2);
-  gtk_tree_view_set_headers_visible (GTK_TREE_VIEW (treeview2), FALSE);
-  gtk_tree_view_set_rules_hint (GTK_TREE_VIEW (treeview2), TRUE);
-  gtk_tree_view_set_enable_search (GTK_TREE_VIEW (treeview2), FALSE);
-
-  hbox6 = gtk_hbox_new (FALSE, 0);
-  gtk_widget_show (hbox6);
-  gtk_notebook_set_tab_label (GTK_NOTEBOOK (notebook1), gtk_notebook_get_nth_page (GTK_NOTEBOOK (notebook1), 1), hbox6);
-
-  image2 = create_pixmap (dialog1, "2.png");
-  gtk_widget_show (image2);
-  gtk_box_pack_start (GTK_BOX (hbox6), image2, FALSE, FALSE, 0);
-
-  label17 = gtk_label_new_with_mnemonic (QT_TR_NOOP("Interlacing"));
-  gtk_widget_show (label17);
-  gtk_box_pack_start (GTK_BOX (hbox6), label17, FALSE, FALSE, 4);
-
-  scrolledwindow3 = gtk_scrolled_window_new (NULL, NULL);
-  gtk_widget_show (scrolledwindow3);
-  gtk_container_add (GTK_CONTAINER (notebook1), scrolledwindow3);
-  gtk_scrolled_window_set_policy (GTK_SCROLLED_WINDOW (scrolledwindow3), GTK_POLICY_AUTOMATIC, GTK_POLICY_AUTOMATIC);
-
-  treeview3 = gtk_tree_view_new ();
-  gtk_widget_show (treeview3);
-  gtk_container_add (GTK_CONTAINER (scrolledwindow3), treeview3);
-  gtk_tree_view_set_headers_visible (GTK_TREE_VIEW (treeview3), FALSE);
-  gtk_tree_view_set_rules_hint (GTK_TREE_VIEW (treeview3), TRUE);
-  gtk_tree_view_set_enable_search (GTK_TREE_VIEW (treeview3), FALSE);
-
-  hbox7 = gtk_hbox_new (FALSE, 0);
-  gtk_widget_show (hbox7);
-  gtk_notebook_set_tab_label (GTK_NOTEBOOK (notebook1), gtk_notebook_get_nth_page (GTK_NOTEBOOK (notebook1), 2), hbox7);
-
-  image3 = create_pixmap (dialog1, "4.png");
-  gtk_widget_show (image3);
-  gtk_box_pack_start (GTK_BOX (hbox7), image3, FALSE, FALSE, 0);
-
-  label18 = gtk_label_new_with_mnemonic (QT_TR_NOOP("Colors"));
-  gtk_widget_show (label18);
-  gtk_box_pack_start (GTK_BOX (hbox7), label18, FALSE, FALSE, 4);
-
-  scrolledwindow4 = gtk_scrolled_window_new (NULL, NULL);
-  gtk_widget_show (scrolledwindow4);
-  gtk_container_add (GTK_CONTAINER (notebook1), scrolledwindow4);
-  gtk_scrolled_window_set_policy (GTK_SCROLLED_WINDOW (scrolledwindow4), GTK_POLICY_AUTOMATIC, GTK_POLICY_AUTOMATIC);
-
-  treeview4 = gtk_tree_view_new ();
-  gtk_widget_show (treeview4);
-  gtk_container_add (GTK_CONTAINER (scrolledwindow4), treeview4);
-  gtk_tree_view_set_headers_visible (GTK_TREE_VIEW (treeview4), FALSE);
-  gtk_tree_view_set_rules_hint (GTK_TREE_VIEW (treeview4), TRUE);
-  gtk_tree_view_set_enable_search (GTK_TREE_VIEW (treeview4), FALSE);
-
-  hbox8 = gtk_hbox_new (FALSE, 0);
-  gtk_widget_show (hbox8);
-  gtk_notebook_set_tab_label (GTK_NOTEBOOK (notebook1), gtk_notebook_get_nth_page (GTK_NOTEBOOK (notebook1), 3), hbox8);
-
-  image4 = create_pixmap (dialog1, "5.png");
-  gtk_widget_show (image4);
-  gtk_box_pack_start (GTK_BOX (hbox8), image4, FALSE, FALSE, 0);
-
-  label19 = gtk_label_new_with_mnemonic (QT_TR_NOOP("Noise"));
-  gtk_widget_show (label19);
-  gtk_box_pack_start (GTK_BOX (hbox8), label19, FALSE, FALSE, 4);
-
-  scrolledwindow5 = gtk_scrolled_window_new (NULL, NULL);
-  gtk_widget_show (scrolledwindow5);
-  gtk_container_add (GTK_CONTAINER (notebook1), scrolledwindow5);
-  gtk_scrolled_window_set_policy (GTK_SCROLLED_WINDOW (scrolledwindow5), GTK_POLICY_AUTOMATIC, GTK_POLICY_AUTOMATIC);
-
-  treeview5 = gtk_tree_view_new ();
-  gtk_widget_show (treeview5);
-  gtk_container_add (GTK_CONTAINER (scrolledwindow5), treeview5);
-  gtk_tree_view_set_headers_visible (GTK_TREE_VIEW (treeview5), FALSE);
-  gtk_tree_view_set_rules_hint (GTK_TREE_VIEW (treeview5), TRUE);
-  gtk_tree_view_set_enable_search (GTK_TREE_VIEW (treeview5), FALSE);
-
-  hbox9 = gtk_hbox_new (FALSE, 0);
-  gtk_widget_show (hbox9);
-  gtk_notebook_set_tab_label (GTK_NOTEBOOK (notebook1), gtk_notebook_get_nth_page (GTK_NOTEBOOK (notebook1), 4), hbox9);
-
-  image5 = create_pixmap (dialog1, "3.png");
-  gtk_widget_show (image5);
-  gtk_box_pack_start (GTK_BOX (hbox9), image5, FALSE, FALSE, 0);
-
-  label20 = gtk_label_new_with_mnemonic (QT_TR_NOOP("Sharpness"));
-  gtk_widget_show (label20);
-  gtk_box_pack_start (GTK_BOX (hbox9), label20, FALSE, FALSE, 4);
-
-  scrolledwindow6 = gtk_scrolled_window_new (NULL, NULL);
-  gtk_widget_show (scrolledwindow6);
-  gtk_container_add (GTK_CONTAINER (notebook1), scrolledwindow6);
-  gtk_scrolled_window_set_policy (GTK_SCROLLED_WINDOW (scrolledwindow6), GTK_POLICY_AUTOMATIC, GTK_POLICY_AUTOMATIC);
-
-  treeview6 = gtk_tree_view_new ();
-  gtk_widget_show (treeview6);
-  gtk_container_add (GTK_CONTAINER (scrolledwindow6), treeview6);
-  gtk_tree_view_set_headers_visible (GTK_TREE_VIEW (treeview6), FALSE);
-  gtk_tree_view_set_rules_hint (GTK_TREE_VIEW (treeview6), TRUE);
-  gtk_tree_view_set_enable_search (GTK_TREE_VIEW (treeview6), FALSE);
-
-  hbox10 = gtk_hbox_new (FALSE, 0);
-  gtk_widget_show (hbox10);
-  gtk_notebook_set_tab_label (GTK_NOTEBOOK (notebook1), gtk_notebook_get_nth_page (GTK_NOTEBOOK (notebook1), 5), hbox10);
-
-  image6 = create_pixmap (dialog1, "7.png");
-  gtk_widget_show (image6);
-  gtk_box_pack_start (GTK_BOX (hbox10), image6, FALSE, FALSE, 0);
-
-  label21 = gtk_label_new_with_mnemonic (QT_TR_NOOP("Subtitles"));
-  gtk_widget_show (label21);
-  gtk_box_pack_start (GTK_BOX (hbox10), label21, FALSE, FALSE, 4);
-
-  scrolledwindow7 = gtk_scrolled_window_new (NULL, NULL);
-  gtk_widget_show (scrolledwindow7);
-  gtk_container_add (GTK_CONTAINER (notebook1), scrolledwindow7);
-  gtk_scrolled_window_set_policy (GTK_SCROLLED_WINDOW (scrolledwindow7), GTK_POLICY_AUTOMATIC, GTK_POLICY_AUTOMATIC);
-
-  treeview7 = gtk_tree_view_new ();
-  gtk_widget_show (treeview7);
-  gtk_container_add (GTK_CONTAINER (scrolledwindow7), treeview7);
-  gtk_tree_view_set_headers_visible (GTK_TREE_VIEW (treeview7), FALSE);
-  gtk_tree_view_set_rules_hint (GTK_TREE_VIEW (treeview7), TRUE);
-  gtk_tree_view_set_enable_search (GTK_TREE_VIEW (treeview7), FALSE);
-
-  hbox4 = gtk_hbox_new (FALSE, 0);
-  gtk_widget_show (hbox4);
-  gtk_notebook_set_tab_label (GTK_NOTEBOOK (notebook1), gtk_notebook_get_nth_page (GTK_NOTEBOOK (notebook1), 6), hbox4);
-
-  image7 = create_pixmap (dialog1, "6.png");
-  gtk_widget_show (image7);
-  gtk_box_pack_start (GTK_BOX (hbox4), image7, FALSE, FALSE, 0);
-
-  label22 = gtk_label_new_with_mnemonic (QT_TR_NOOP("Misc"));
-  gtk_widget_show (label22);
-  gtk_box_pack_start (GTK_BOX (hbox4), label22, FALSE, FALSE, 4);
-
-  treeview8 = gtk_tree_view_new ();
-  gtk_widget_show (treeview8);
-  gtk_container_add (GTK_CONTAINER (notebook1), treeview8);
-  gtk_tree_view_set_headers_visible (GTK_TREE_VIEW (treeview8), FALSE);
-  gtk_tree_view_set_rules_hint (GTK_TREE_VIEW (treeview8), TRUE);
-  gtk_tree_view_set_enable_search (GTK_TREE_VIEW (treeview8), FALSE);
-
-  label28 = gtk_label_new (QT_TR_NOOP("External"));
-  gtk_widget_show (label28);
-  gtk_notebook_set_tab_label (GTK_NOTEBOOK (notebook1), gtk_notebook_get_nth_page (GTK_NOTEBOOK (notebook1), 7), label28);
-
-  hbox13 = gtk_hbox_new (FALSE, 6);
-  gtk_widget_show (hbox13);
-  gtk_box_pack_start (GTK_BOX (vbox2), hbox13, FALSE, FALSE, 0);
-
   buttonAdd = gtk_button_new ();
   gtk_widget_show (buttonAdd);
-  gtk_box_pack_end (GTK_BOX (hbox13), buttonAdd, FALSE, FALSE, 0);
+  gtk_box_pack_end (GTK_BOX (hboxActionAvailable), buttonAdd, FALSE, FALSE, 0);
   gtk_tooltips_set_tip (tooltips, buttonAdd, QT_TR_NOOP("Add selected filter to the Active Filters list"), NULL);
 
-  image11 = gtk_image_new_from_stock ("gtk-add", GTK_ICON_SIZE_BUTTON);
-  gtk_widget_show (image11);
-  gtk_container_add (GTK_CONTAINER (buttonAdd), image11);
+  image1 = gtk_image_new_from_stock ("gtk-add", GTK_ICON_SIZE_BUTTON);
+  gtk_widget_show (image1);
+  gtk_container_add (GTK_CONTAINER (buttonAdd), image1);
 
-  label23 = gtk_label_new (QT_TR_NOOP("<b>Available Filters</b>"));
-  gtk_widget_show (label23);
-  gtk_frame_set_label_widget (GTK_FRAME (frame1), label23);
-  gtk_label_set_use_markup (GTK_LABEL (label23), TRUE);
-  gtk_misc_set_alignment (GTK_MISC (label23), 1, 1);
+  labelActive = gtk_label_new (QT_TR_NOOP("<b>Active Filters</b>"));
+  gtk_label_set_use_markup (GTK_LABEL (labelActive), TRUE);
+  gtk_misc_set_alignment (GTK_MISC (labelActive), 0, 0);
+  gtk_box_pack_start (GTK_BOX (vbox2), labelActive, FALSE, FALSE, 0);
+  gtk_widget_show (labelActive);
 
-  frame2 = gtk_frame_new (NULL);
-  gtk_widget_show (frame2);
-  gtk_box_pack_start (GTK_BOX (hbox11), frame2, TRUE, TRUE, 0);
-  gtk_frame_set_shadow_type (GTK_FRAME (frame2), GTK_SHADOW_NONE);
-
-  alignment2 = gtk_alignment_new (0.5, 0.5, 1, 1);
-  gtk_widget_show (alignment2);
-  gtk_container_add (GTK_CONTAINER (frame2), alignment2);
+  alignment2 = gtk_alignment_new (0, 0, 1, 1);
   gtk_alignment_set_padding (GTK_ALIGNMENT (alignment2), 6, 0, 18, 0);
+  gtk_box_pack_start (GTK_BOX (vbox2), alignment2, TRUE, TRUE, 0);
+  gtk_widget_show (alignment2);
 
-  hbox1 = gtk_hbox_new (FALSE, 0);
-  gtk_widget_show (hbox1);
-  gtk_container_add (GTK_CONTAINER (alignment2), hbox1);
+  vbox4 = gtk_vbox_new (FALSE, 6);
+  gtk_widget_show (vbox4);
+  gtk_container_add (GTK_CONTAINER (alignment2), vbox4);
 
-  vbox3 = gtk_vbox_new (FALSE, 6);
-  gtk_widget_show (vbox3);
-  gtk_box_pack_start (GTK_BOX (hbox1), vbox3, TRUE, TRUE, 0);
+  scrolledwindowActive = gtk_scrolled_window_new (NULL, NULL);
+  gtk_box_pack_start (GTK_BOX (vbox4), scrolledwindowActive, TRUE, TRUE, 0);
+  gtk_scrolled_window_set_policy (GTK_SCROLLED_WINDOW (scrolledwindowActive), GTK_POLICY_NEVER, GTK_POLICY_AUTOMATIC);
+  gtk_scrolled_window_set_shadow_type (GTK_SCROLLED_WINDOW (scrolledwindowActive), GTK_SHADOW_IN);
+  gtk_widget_show (scrolledwindowActive);
 
-  scrolledwindow9 = gtk_scrolled_window_new (NULL, NULL);
-  gtk_widget_show (scrolledwindow9);
-  gtk_box_pack_start (GTK_BOX (vbox3), scrolledwindow9, TRUE, TRUE, 0);
-  gtk_scrolled_window_set_policy (GTK_SCROLLED_WINDOW (scrolledwindow9), GTK_POLICY_NEVER, GTK_POLICY_AUTOMATIC);
-  gtk_scrolled_window_set_shadow_type (GTK_SCROLLED_WINDOW (scrolledwindow9), GTK_SHADOW_OUT);
+  treeviewActive = gtk_tree_view_new ();
+  gtk_widget_show (treeviewActive);
+  gtk_container_add (GTK_CONTAINER (scrolledwindowActive), treeviewActive);
+  gtk_tree_view_set_headers_visible (GTK_TREE_VIEW (treeviewActive), FALSE);
+  gtk_tree_view_set_rules_hint (GTK_TREE_VIEW (treeviewActive), TRUE);
+  gtk_tree_view_set_enable_search (GTK_TREE_VIEW (treeviewActive), FALSE);
 
-  treeview0 = gtk_tree_view_new ();
-  gtk_widget_show (treeview0);
-  gtk_container_add (GTK_CONTAINER (scrolledwindow9), treeview0);
-  gtk_widget_set_size_request (treeview0, 288, 336);
-  gtk_tree_view_set_headers_visible (GTK_TREE_VIEW (treeview0), FALSE);
-  gtk_tree_view_set_rules_hint (GTK_TREE_VIEW (treeview0), TRUE);
-  gtk_tree_view_set_enable_search (GTK_TREE_VIEW (treeview0), FALSE);
+  hboxActionActive = gtk_hbox_new (FALSE, 6);
+  gtk_widget_show (hboxActionActive);
+  gtk_box_pack_start (GTK_BOX (vbox4), hboxActionActive, FALSE, FALSE, 0);
 
-  hbox14 = gtk_hbox_new (FALSE, 6);
-  gtk_widget_show (hbox14);
-  gtk_box_pack_start (GTK_BOX (vbox3), hbox14, FALSE, FALSE, 0);
-
   buttonRemove = gtk_button_new ();
   gtk_widget_show (buttonRemove);
-  gtk_box_pack_end (GTK_BOX (hbox14), buttonRemove, FALSE, FALSE, 0);
+  gtk_box_pack_end (GTK_BOX (hboxActionActive), buttonRemove, FALSE, FALSE, 0);
   gtk_tooltips_set_tip (tooltips, buttonRemove, QT_TR_NOOP("Remove filter"), NULL);
 
-  image15 = gtk_image_new_from_stock ("gtk-remove", GTK_ICON_SIZE_BUTTON);
-  gtk_widget_show (image15);
-  gtk_container_add (GTK_CONTAINER (buttonRemove), image15);
+  image2 = gtk_image_new_from_stock ("gtk-remove", GTK_ICON_SIZE_BUTTON);
+  gtk_widget_show (image2);
+  gtk_container_add (GTK_CONTAINER (buttonRemove), image2);
 
   buttonDown = gtk_button_new ();
   gtk_widget_show (buttonDown);
-  gtk_box_pack_end (GTK_BOX (hbox14), buttonDown, FALSE, FALSE, 0);
+  gtk_box_pack_end (GTK_BOX (hboxActionActive), buttonDown, FALSE, FALSE, 0);
   gtk_tooltips_set_tip (tooltips, buttonDown, QT_TR_NOOP("Move filter down"), NULL);
 
-  image14 = gtk_image_new_from_icon_name ("gtk-go-down", GTK_ICON_SIZE_BUTTON);
-  gtk_widget_show (image14);
-  gtk_container_add (GTK_CONTAINER (buttonDown), image14);
+  image3 = gtk_image_new_from_icon_name ("gtk-go-down", GTK_ICON_SIZE_BUTTON);
+  gtk_widget_show (image3);
+  gtk_container_add (GTK_CONTAINER (buttonDown), image3);
 
   buttonUp = gtk_button_new ();
   gtk_widget_show (buttonUp);
-  gtk_box_pack_end (GTK_BOX (hbox14), buttonUp, FALSE, FALSE, 0);
+  gtk_box_pack_end (GTK_BOX (hboxActionActive), buttonUp, FALSE, FALSE, 0);
   gtk_tooltips_set_tip (tooltips, buttonUp, QT_TR_NOOP("Move filter up"), NULL);
 
-  image13 = gtk_image_new_from_icon_name ("gtk-go-up", GTK_ICON_SIZE_BUTTON);
-  gtk_widget_show (image13);
-  gtk_container_add (GTK_CONTAINER (buttonUp), image13);
+  image4 = gtk_image_new_from_icon_name ("gtk-go-up", GTK_ICON_SIZE_BUTTON);
+  gtk_widget_show (image4);
+  gtk_container_add (GTK_CONTAINER (buttonUp), image4);
 
+  buttonOpen = gtk_button_new ();
+  gtk_widget_show (buttonOpen);
+  gtk_box_pack_end (GTK_BOX (hboxActionActive), buttonOpen, FALSE, FALSE, 0);
+  gtk_tooltips_set_tip (tooltips, buttonOpen, QT_TR_NOOP("Open filter list"), NULL);
+
+  tmp_image = gtk_image_new_from_icon_name ("gtk-open", GTK_ICON_SIZE_BUTTON);
+  gtk_widget_show (tmp_image);
+  gtk_container_add (GTK_CONTAINER (buttonOpen), tmp_image);
+
+  buttonSave = gtk_button_new ();
+  gtk_widget_show (buttonSave);
+  gtk_box_pack_end (GTK_BOX (hboxActionActive), buttonSave, FALSE, FALSE, 0);
+  gtk_tooltips_set_tip (tooltips, buttonSave, QT_TR_NOOP("Save filter list"), NULL);
+
+  tmp_image= gtk_image_new_from_icon_name ("gtk-save", GTK_ICON_SIZE_BUTTON);
+  gtk_widget_show (tmp_image);
+  gtk_container_add (GTK_CONTAINER (buttonSave), tmp_image);
+
   buttonPartial = gtk_button_new_with_mnemonic (QT_TR_NOOP("P_artial"));
   gtk_widget_show (buttonPartial);
-  gtk_box_pack_end (GTK_BOX (hbox14), buttonPartial, FALSE, FALSE, 0);
+  gtk_box_pack_end (GTK_BOX (hboxActionActive), buttonPartial, FALSE, FALSE, 0);
   gtk_tooltips_set_tip (tooltips, buttonPartial, QT_TR_NOOP("Apply the current filter only to a part of the file"), NULL);
 
   buttonProperties = gtk_button_new ();
   gtk_widget_show (buttonProperties);
-  gtk_box_pack_end (GTK_BOX (hbox14), buttonProperties, FALSE, FALSE, 0);
+  gtk_box_pack_end (GTK_BOX (hboxActionActive), buttonProperties, FALSE, FALSE, 0);
   gtk_tooltips_set_tip (tooltips, buttonProperties, QT_TR_NOOP("Configure filter"), NULL);
 
-  alignment4 = gtk_alignment_new (0.5, 0.5, 0, 0);
-  gtk_widget_show (alignment4);
-  gtk_container_add (GTK_CONTAINER (buttonProperties), alignment4);
+  alignment3 = gtk_alignment_new (0.5, 0.5, 0, 0);
+  gtk_widget_show (alignment3);
+  gtk_container_add (GTK_CONTAINER (buttonProperties), alignment3);
 
-  hbox16 = gtk_hbox_new (FALSE, 2);
-  gtk_widget_show (hbox16);
-  gtk_container_add (GTK_CONTAINER (alignment4), hbox16);
+  hbox3 = gtk_hbox_new (FALSE, 2);
+  gtk_widget_show (hbox3);
+  gtk_container_add (GTK_CONTAINER (alignment3), hbox3);
 
-  label25 = gtk_label_new_with_mnemonic (QT_TR_NOOP("C_onfigure"));
-  gtk_widget_show (label25);
-  gtk_box_pack_start (GTK_BOX (hbox16), label25, FALSE, FALSE, 0);
-
-  label2 = gtk_label_new (QT_TR_NOOP("<b >Active Filters</b>"));
+  label2 = gtk_label_new_with_mnemonic (QT_TR_NOOP("C_onfigure"));
   gtk_widget_show (label2);
-  gtk_frame_set_label_widget (GTK_FRAME (frame2), label2);
-  gtk_label_set_use_markup (GTK_LABEL (label2), TRUE);
-  gtk_misc_set_alignment (GTK_MISC (label2), 1, 1);
+  gtk_box_pack_start (GTK_BOX (hbox3), label2, FALSE, FALSE, 0);
 
   dialog_action_area1 = GTK_DIALOG (dialog1)->action_area;
   gtk_widget_show (dialog_action_area1);
@@ -537,21 +298,21 @@
   gtk_dialog_add_action_widget (GTK_DIALOG (dialog1), buttonPreview, GTK_RESPONSE_APPLY);
   GTK_WIDGET_SET_FLAGS (buttonPreview, GTK_CAN_DEFAULT);
 
-  alignment5 = gtk_alignment_new (0.5, 0.5, 0, 0);
-  gtk_widget_show (alignment5);
-  gtk_container_add (GTK_CONTAINER (buttonPreview), alignment5);
+  alignment4 = gtk_alignment_new (0.5, 0.5, 0, 0);
+  gtk_widget_show (alignment4);
+  gtk_container_add (GTK_CONTAINER (buttonPreview), alignment4);
 
-  hbox17 = gtk_hbox_new (FALSE, 2);
-  gtk_widget_show (hbox17);
-  gtk_container_add (GTK_CONTAINER (alignment5), hbox17);
+  hbox2 = gtk_hbox_new (FALSE, 2);
+  gtk_widget_show (hbox2);
+  gtk_container_add (GTK_CONTAINER (alignment4), hbox2);
 
-  image17 = create_pixmap (dialog1, "preview-button.png");
-  gtk_widget_show (image17);
-  gtk_box_pack_start (GTK_BOX (hbox17), image17, FALSE, FALSE, 0);
+  image5 = create_pixmap (dialog1, "preview-button.png");
+  gtk_widget_show (image5);
+  gtk_box_pack_start (GTK_BOX (hbox2), image5, FALSE, FALSE, 0);
 
-  label26 = gtk_label_new_with_mnemonic (QT_TR_NOOP("_Preview"));
-  gtk_widget_show (label26);
-  gtk_box_pack_start (GTK_BOX (hbox17), label26, FALSE, FALSE, 0);
+  label3 = gtk_label_new_with_mnemonic (QT_TR_NOOP("_Preview"));
+  gtk_widget_show (label3);
+  gtk_box_pack_start (GTK_BOX (hbox2), label3, FALSE, FALSE, 0);
 
   buttonClose = gtk_button_new_from_stock ("gtk-close");
   gtk_widget_show (buttonClose);
@@ -561,86 +322,51 @@
   /* Store pointers to all widgets, for use by lookup_widget(). */
   GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog1, "dialog1");
   GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog_vbox1, "dialog_vbox1");
-  GLADE_HOOKUP_OBJECT (dialog1, vbox3b, "vbox3b");
-  GLADE_HOOKUP_OBJECT (dialog1, toolbar1, "toolbar1");
-  GLADE_HOOKUP_OBJECT (dialog1, toolbuttonOpen, "toolbuttonOpen");
-  GLADE_HOOKUP_OBJECT (dialog1, toolbuttonSave, "toolbuttonSave");
-  GLADE_HOOKUP_OBJECT (dialog1, toolbuttonScript, "toolbuttonScript");
-  GLADE_HOOKUP_OBJECT (dialog1, toolbuttonDVD, "toolbuttonDVD");
-  GLADE_HOOKUP_OBJECT (dialog1, toolbuttonHalfD1, "toolbuttonHalfD1");
-  GLADE_HOOKUP_OBJECT (dialog1, toolbuttonSVCD, "toolbuttonSVCD");
-  GLADE_HOOKUP_OBJECT (dialog1, toolbuttonVCD, "toolbuttonVCD");
-  GLADE_HOOKUP_OBJECT (dialog1, hbox11, "hbox11");
-  GLADE_HOOKUP_OBJECT (dialog1, frame1, "frame1");
-  GLADE_HOOKUP_OBJECT (dialog1, alignment1, "alignment1");
+  GLADE_HOOKUP_OBJECT_NO_REF (dialog1, vbox1, "vbox1");
   GLADE_HOOKUP_OBJECT (dialog1, vbox2, "vbox2");
-  GLADE_HOOKUP_OBJECT (dialog1, notebook1, "notebook1");
-  GLADE_HOOKUP_OBJECT (dialog1, scrolledwindow1, "scrolledwindow1");
-  GLADE_HOOKUP_OBJECT (dialog1, treeview1, "treeview1");
-  GLADE_HOOKUP_OBJECT (dialog1, hbox5, "hbox5");
-  GLADE_HOOKUP_OBJECT (dialog1, image1, "image1");
-  GLADE_HOOKUP_OBJECT (dialog1, label11, "label11");
-  GLADE_HOOKUP_OBJECT (dialog1, scrolledwindow2, "scrolledwindow2");
-  GLADE_HOOKUP_OBJECT (dialog1, treeview2, "treeview2");
-  GLADE_HOOKUP_OBJECT (dialog1, hbox6, "hbox6");
-  GLADE_HOOKUP_OBJECT (dialog1, image2, "image2");
-  GLADE_HOOKUP_OBJECT (dialog1, label17, "label17");
-  GLADE_HOOKUP_OBJECT (dialog1, scrolledwindow3, "scrolledwindow3");
-  GLADE_HOOKUP_OBJECT (dialog1, treeview3, "treeview3");
-  GLADE_HOOKUP_OBJECT (dialog1, hbox7, "hbox7");
-  GLADE_HOOKUP_OBJECT (dialog1, image3, "image3");
-  GLADE_HOOKUP_OBJECT (dialog1, label18, "label18");
-  GLADE_HOOKUP_OBJECT (dialog1, scrolledwindow4, "scrolledwindow4");
-  GLADE_HOOKUP_OBJECT (dialog1, treeview4, "treeview4");
-  GLADE_HOOKUP_OBJECT (dialog1, hbox8, "hbox8");
-  GLADE_HOOKUP_OBJECT (dialog1, image4, "image4");
-  GLADE_HOOKUP_OBJECT (dialog1, label19, "label19");
-  GLADE_HOOKUP_OBJECT (dialog1, scrolledwindow5, "scrolledwindow5");
-  GLADE_HOOKUP_OBJECT (dialog1, treeview5, "treeview5");
-  GLADE_HOOKUP_OBJECT (dialog1, hbox9, "hbox9");
-  GLADE_HOOKUP_OBJECT (dialog1, image5, "image5");
-  GLADE_HOOKUP_OBJECT (dialog1, label20, "label20");
-  GLADE_HOOKUP_OBJECT (dialog1, scrolledwindow6, "scrolledwindow6");
-  GLADE_HOOKUP_OBJECT (dialog1, treeview6, "treeview6");
-  GLADE_HOOKUP_OBJECT (dialog1, hbox10, "hbox10");
-  GLADE_HOOKUP_OBJECT (dialog1, image6, "image6");
-  GLADE_HOOKUP_OBJECT (dialog1, label21, "label21");
-  GLADE_HOOKUP_OBJECT (dialog1, scrolledwindow7, "scrolledwindow7");
-  GLADE_HOOKUP_OBJECT (dialog1, treeview7, "treeview7");
-  GLADE_HOOKUP_OBJECT (dialog1, hbox4, "hbox4");
-  GLADE_HOOKUP_OBJECT (dialog1, image7, "image7");
-  GLADE_HOOKUP_OBJECT (dialog1, label22, "label22");
-  GLADE_HOOKUP_OBJECT (dialog1, treeview8, "treeview8");
-  GLADE_HOOKUP_OBJECT (dialog1, label28, "label28");
-  GLADE_HOOKUP_OBJECT (dialog1, hbox13, "hbox13");
-  GLADE_HOOKUP_OBJECT (dialog1, buttonAdd, "buttonAdd");
-  GLADE_HOOKUP_OBJECT (dialog1, image11, "image11");
-  GLADE_HOOKUP_OBJECT (dialog1, label23, "label23");
-  GLADE_HOOKUP_OBJECT (dialog1, frame2, "frame2");
-  GLADE_HOOKUP_OBJECT (dialog1, alignment2, "alignment2");
   GLADE_HOOKUP_OBJECT (dialog1, hbox1, "hbox1");
+  GLADE_HOOKUP_OBJECT (dialog1, alignment1, "alignment1");
+  GLADE_HOOKUP_OBJECT (dialog1, table1, "table1");
   GLADE_HOOKUP_OBJECT (dialog1, vbox3, "vbox3");
-  GLADE_HOOKUP_OBJECT (dialog1, scrolledwindow9, "scrolledwindow9");
-  GLADE_HOOKUP_OBJECT (dialog1, treeview0, "treeview0");
-  GLADE_HOOKUP_OBJECT (dialog1, hbox14, "hbox14");
+  GLADE_HOOKUP_OBJECT (dialog1, table2, "table2");
+  GLADE_HOOKUP_OBJECT (dialog1, scrolledwindowAvailable, "scrolledwindowAvailable");
+  GLADE_HOOKUP_OBJECT (dialog1, treeviewAvailable, "treeviewAvailable");
+  GLADE_HOOKUP_OBJECT (dialog1, buttonVCDRes, "buttonVCDRes");
+  GLADE_HOOKUP_OBJECT (dialog1, buttonSVCDRes, "buttonSVCDRes");
+  GLADE_HOOKUP_OBJECT (dialog1, buttonHalfD1Res, "buttonHalfD1Res");
+  GLADE_HOOKUP_OBJECT (dialog1, hbox2, "hbox2");
+  GLADE_HOOKUP_OBJECT (dialog1, label1, "label1");
+  GLADE_HOOKUP_OBJECT (dialog1, buttonDVDRes, "buttonDVDRes");
+  GLADE_HOOKUP_OBJECT (dialog1, frame1, "frame1");
+  GLADE_HOOKUP_OBJECT (dialog1, mainTree, "mainTree");
+  GLADE_HOOKUP_OBJECT (dialog1, hboxActionAvailable, "hboxActionAvailable");
+  GLADE_HOOKUP_OBJECT (dialog1, buttonAdd, "buttonAdd");
+  GLADE_HOOKUP_OBJECT (dialog1, image1, "image1");
+  GLADE_HOOKUP_OBJECT (dialog1, labelAvailable, "labelAvailable");
+  GLADE_HOOKUP_OBJECT (dialog1, alignment2, "alignment2");
+  GLADE_HOOKUP_OBJECT (dialog1, vbox4, "vbox4");
+  GLADE_HOOKUP_OBJECT (dialog1, scrolledwindowActive, "scrolledwindowActive");
+  GLADE_HOOKUP_OBJECT (dialog1, treeviewActive, "treeviewActive");
+  GLADE_HOOKUP_OBJECT (dialog1, hboxActionActive, "hboxActionActive");
   GLADE_HOOKUP_OBJECT (dialog1, buttonRemove, "buttonRemove");
-  GLADE_HOOKUP_OBJECT (dialog1, image15, "image15");
+  GLADE_HOOKUP_OBJECT (dialog1, image2, "image2");
   GLADE_HOOKUP_OBJECT (dialog1, buttonDown, "buttonDown");
-  GLADE_HOOKUP_OBJECT (dialog1, image14, "image14");
+  GLADE_HOOKUP_OBJECT (dialog1, image3, "image3");
   GLADE_HOOKUP_OBJECT (dialog1, buttonUp, "buttonUp");
-  GLADE_HOOKUP_OBJECT (dialog1, image13, "image13");
+  GLADE_HOOKUP_OBJECT (dialog1, image4, "image4");
+  GLADE_HOOKUP_OBJECT (dialog1, buttonOpen, "buttonOpen");
+  GLADE_HOOKUP_OBJECT (dialog1, buttonSave, "buttonSave");
   GLADE_HOOKUP_OBJECT (dialog1, buttonPartial, "buttonPartial");
   GLADE_HOOKUP_OBJECT (dialog1, buttonProperties, "buttonProperties");
-  GLADE_HOOKUP_OBJECT (dialog1, alignment4, "alignment4");
-  GLADE_HOOKUP_OBJECT (dialog1, hbox16, "hbox16");
-  GLADE_HOOKUP_OBJECT (dialog1, label25, "label25");
+  GLADE_HOOKUP_OBJECT (dialog1, alignment3, "alignment3");
+  GLADE_HOOKUP_OBJECT (dialog1, hbox3, "hbox3");
   GLADE_HOOKUP_OBJECT (dialog1, label2, "label2");
+  GLADE_HOOKUP_OBJECT (dialog1, labelActive, "labelActive");
   GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog_action_area1, "dialog_action_area1");
   GLADE_HOOKUP_OBJECT (dialog1, buttonPreview, "buttonPreview");
-  GLADE_HOOKUP_OBJECT (dialog1, alignment5, "alignment5");
-  GLADE_HOOKUP_OBJECT (dialog1, hbox17, "hbox17");
-  GLADE_HOOKUP_OBJECT (dialog1, image17, "image17");
-  GLADE_HOOKUP_OBJECT (dialog1, label26, "label26");
+  GLADE_HOOKUP_OBJECT (dialog1, alignment4, "alignment4");
+  GLADE_HOOKUP_OBJECT (dialog1, image5, "image5");
+  GLADE_HOOKUP_OBJECT (dialog1, label3, "label3");
   GLADE_HOOKUP_OBJECT (dialog1, buttonClose, "buttonClose");
   GLADE_HOOKUP_OBJECT_NO_REF (dialog1, tooltips, "tooltips");
 



From mean at mail.berlios.de  Wed Aug 12 20:12:51 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Wed, 12 Aug 2009 20:12:51 +0200
Subject: [Avidemux-svn-commit] r5241 - in
	branches/avidemux_2.5_branch_gruntster:
	avidemux/ADM_audiocodec plugins/ADM_audioDecoders/ADM_ad_ac3
	plugins/ADM_audioDecoders/ADM_ad_faad
	plugins/ADM_audioDecoders/ADM_ad_mad
	plugins/ADM_audioDecoders/ADM_ad_opencore_amrnb
	plugins/ADM_audioDecoders/ADM_ad_opencore_amrwb
	plugins/ADM_audioDecoders/ADM_ad_vorbis
Message-ID: <200908121812.n7CICppJ017988@sheep.berlios.de>

Author: mean
Date: 2009-08-12 20:12:50 +0200 (Wed, 12 Aug 2009)
New Revision: 5241

Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiocodec/ADM_ad_plugin.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiocodec/ADM_pluginLoad.cpp
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDecoders/ADM_ad_ac3/ADM_ad_a52.cpp
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDecoders/ADM_ad_faad/ADM_ad_faad.cpp
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDecoders/ADM_ad_mad/ADM_ad_mad.cpp
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDecoders/ADM_ad_opencore_amrnb/ADM_ad_opencore_amrnb.cpp
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDecoders/ADM_ad_opencore_amrwb/ADM_ad_opencore_amrwb.cpp
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDecoders/ADM_ad_vorbis/ADM_ad_vorbis.cpp
Log:
[audioDecoder] Backport audio codec priority from 2.6

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiocodec/ADM_ad_plugin.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiocodec/ADM_ad_plugin.h	2009-08-12 17:51:08 UTC (rev 5240)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiocodec/ADM_ad_plugin.h	2009-08-12 18:12:50 UTC (rev 5241)
@@ -7,20 +7,33 @@
 #include "ADM_default.h"
 #include "ADM_coreAudio.h"
 #include "ADM_audiocodec.h"
-#include "../ADM_audio/aviaudio.hxx"
 
-#define AD_API_VERSION 1
+
+#define AD_API_VERSION 2
 /* These are the 6 functions exported by each plugin ...*/
 typedef ADM_Audiocodec  *(ADM_ad_CreateFunction)(uint32_t fourcc, 
 								WAVHeader *info,uint32_t extraLength,uint8_t *extraData);
 typedef void             (ADM_ad_DeleteFunction)(ADM_Audiocodec *codec);
-typedef bool             (ADM_ad_SupportedFormat)(uint32_t audioFourcc);
+typedef int             (ADM_ad_SupportedFormat)(uint32_t audioFourcc);
 typedef uint32_t         (ADM_ad_GetApiVersion)(void);
 typedef bool            (ADM_ad_GetDecoderVersion)(uint32_t *major, uint32_t *minor, uint32_t *patch);
 typedef const char       *(ADM_ADM_ad_GetInfo)(void);
 
 /* handly macro to declare plugins*/
+/**
+    \struct ad_supportedFormat
+*/
+typedef struct
+{
+    uint32_t fourcc;
+    uint32_t priority;  // The lower the value, the less desirable the codec is, 0 means unsupported
+                        // Valid value ranges from 1 (low quality codec) to 254 (must have codec)
+}ad_supportedFormat;
 
+#define AD_LOW_QUAL     50
+#define AD_MEDIUM_QUAL  100
+#define AD_HIGH_QUAL    150
+
 #define DECLARE_AUDIO_DECODER(Class,Major,Minor,Patch,Formats,Desc) \
 	extern "C" { \
 	ADM_Audiocodec *create(uint32_t fourcc,	WAVHeader *info,uint32_t extraLength,uint8_t *extraData)\
@@ -32,12 +45,12 @@
 		Class *a=(Class *)codec;\
 		delete a;\
 	}\
-	bool supportedFormat(uint32_t audioFourcc) \
+	int supportedFormat(uint32_t audioFourcc) \
 	{ \
-		for(int i=0;i<sizeof(Formats)/sizeof(uint32_t);i++)\
-			if(Formats[i]==audioFourcc) \
-				return true; \
-		return false; \
+		for(int i=0;i<sizeof(Formats)/sizeof(ad_supportedFormat);i++)\
+			if(Formats[i].fourcc==audioFourcc) \
+				return Formats[i].priority; \
+		return 0; \
 	} \
 	uint32_t getApiVersion(void)\
 	{\

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiocodec/ADM_pluginLoad.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiocodec/ADM_pluginLoad.cpp	2009-08-12 17:51:08 UTC (rev 5240)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_audiocodec/ADM_pluginLoad.cpp	2009-08-12 18:12:50 UTC (rev 5241)
@@ -167,18 +167,28 @@
  */
 ADM_Audiocodec *ADM_ad_searchCodec(uint32_t fourcc,	WAVHeader *info,uint32_t extraLength,uint8_t *extraData)
 {
+        int best=0;
+        int index=-1;
+
 	for(int i=0;i<ADM_audioPlugins.size();i++)
 	{
 		ADM_ad_plugin *a=ADM_audioPlugins[i];
 		ADM_assert(a);
 		ADM_assert(a->supportedFormat);
-		aprintf("Format 0x%x : probing %s\n",fourcc,a->name);
-		if(a->supportedFormat(fourcc)==true)
-		{
-			ADM_assert(a->create);
-			return a->create(fourcc, info,extraLength,extraData);
-		}
+               int score=a->supportedFormat(fourcc);
+                aprintf("[ADM_ad_plugin]Format 0x%x : probing %s score %d\n",fourcc,a->name,score);
+                if(score>best)
+                {
+                index=i;
+                best=score;
+                }
 	}
+        if(index!=-1 && best >0)
+        {
+                ADM_ad_plugin *a=ADM_audioPlugins[index];
+                ADM_assert(a->create);
+                return a->create(fourcc, info,extraLength,extraData);
+        }
 	return NULL;
 }
 

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDecoders/ADM_ad_ac3/ADM_ad_a52.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDecoders/ADM_ad_ac3/ADM_ad_a52.cpp	2009-08-12 17:51:08 UTC (rev 5240)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDecoders/ADM_ad_ac3/ADM_ad_a52.cpp	2009-08-12 18:12:50 UTC (rev 5241)
@@ -16,7 +16,7 @@
  ***************************************************************************/
 #include "ADM_default.h"
 #include "ADM_ad_plugin.h"
-
+#include "ADM_audioCodecEnum.h"
 extern "C" {
 #include "ADM_liba52/a52.h"
 #include "ADM_liba52/mm_accel.h"
@@ -43,7 +43,7 @@
    };
 // Supported formats + declare our plugin
 //*******************************************************
-   static  uint32_t Formats[]={WAV_AC3};
+   static  ad_supportedFormat Formats[]={WAV_AC3,AD_HIGH_QUAL};
    DECLARE_AUDIO_DECODER(ADM_AudiocodecAC3,						// Class
 		   	0,0,1, 												// Major, minor,patch 
 		   	Formats, 											// Supported formats

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDecoders/ADM_ad_faad/ADM_ad_faad.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDecoders/ADM_ad_faad/ADM_ad_faad.cpp	2009-08-12 17:51:08 UTC (rev 5240)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDecoders/ADM_ad_faad/ADM_ad_faad.cpp	2009-08-12 18:12:50 UTC (rev 5241)
@@ -19,6 +19,7 @@
 
 #include "ADM_default.h"
 #include "ADM_ad_plugin.h"
+#include "ADM_audioCodecEnum.h"
 
 #define FAAD_BUFFER 2048
 
@@ -42,7 +43,7 @@
 };
 // Supported formats + declare our plugin
 //*******************************************************
-static uint32_t Formats[]={WAV_AAC,WAV_MP4};
+static ad_supportedFormat Formats[]={WAV_AAC,WAV_MP4,AD_HIGH_QUAL};
 DECLARE_AUDIO_DECODER(ADM_faad,						// Class
 			0,0,1, 												// Major, minor,patch 
 			Formats, 											// Supported formats

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDecoders/ADM_ad_mad/ADM_ad_mad.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDecoders/ADM_ad_mad/ADM_ad_mad.cpp	2009-08-12 17:51:08 UTC (rev 5240)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDecoders/ADM_ad_mad/ADM_ad_mad.cpp	2009-08-12 18:12:50 UTC (rev 5241)
@@ -16,6 +16,7 @@
  ***************************************************************************/
 #include "ADM_default.h"
 #include "ADM_ad_plugin.h"
+#include "ADM_audioCodecEnum.h"
 #include "ADM_libMad/mad.h"
 
 #define Stream ((mad_stream *)_stream)
@@ -44,7 +45,13 @@
 };
 // Supported formats + declare our plugin
 //*******************************************************
-static uint32_t Formats[]={WAV_MP3,WAV_MP2};
+static  ad_supportedFormat Formats[]={
+        {WAV_MP3,AD_HIGH_QUAL},
+        {WAV_MP2,AD_HIGH_QUAL},
+  
+};
+
+
 DECLARE_AUDIO_DECODER(ADM_AudiocodecMP3,						// Class
 			0,0,1, 												// Major, minor,patch 
 			Formats, 											// Supported formats

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDecoders/ADM_ad_opencore_amrnb/ADM_ad_opencore_amrnb.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDecoders/ADM_ad_opencore_amrnb/ADM_ad_opencore_amrnb.cpp	2009-08-12 17:51:08 UTC (rev 5240)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDecoders/ADM_ad_opencore_amrnb/ADM_ad_opencore_amrnb.cpp	2009-08-12 18:12:50 UTC (rev 5241)
@@ -16,6 +16,7 @@
  ***************************************************************************/
 #include "ADM_default.h"
 #include "ADM_ad_plugin.h"
+#include "ADM_audioCodecEnum.h"
 
 extern "C" {
 #include <opencore-amrnb/interf_dec.h>
@@ -40,7 +41,9 @@
 	uint8_t isDecompressable(void) { return 1; }
 };
 
-static uint32_t Formats[] = { WAV_AMRNB };
+static  ad_supportedFormat Formats[]={
+        {WAV_AMRNB,AD_MEDIUM_QUAL},
+};
 
 DECLARE_AUDIO_DECODER(ADM_AudiocodecOpencoreAmrNb,	// Class
 1,0,0, 												// Major, minor,patch 

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDecoders/ADM_ad_opencore_amrwb/ADM_ad_opencore_amrwb.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDecoders/ADM_ad_opencore_amrwb/ADM_ad_opencore_amrwb.cpp	2009-08-12 17:51:08 UTC (rev 5240)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDecoders/ADM_ad_opencore_amrwb/ADM_ad_opencore_amrwb.cpp	2009-08-12 18:12:50 UTC (rev 5241)
@@ -16,6 +16,7 @@
  ***************************************************************************/
 #include "ADM_default.h"
 #include "ADM_ad_plugin.h"
+#include "ADM_audioCodecEnum.h"
 
 extern "C" {
 #include <opencore-amrwb/dec_if.h>
@@ -41,8 +42,9 @@
 	uint8_t isDecompressable(void) { return 1; }
 };
 
-static uint32_t Formats[] = { WAV_AMRWB };
-
+static  ad_supportedFormat Formats[]={
+        {WAV_AMRWB,AD_MEDIUM_QUAL},
+};
 DECLARE_AUDIO_DECODER(ADM_AudiocodecOpencoreAmrWb,	// Class
 1,0,0, 												// Major, minor,patch 
 Formats, 											// Supported formats

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDecoders/ADM_ad_vorbis/ADM_ad_vorbis.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDecoders/ADM_ad_vorbis/ADM_ad_vorbis.cpp	2009-08-12 17:51:08 UTC (rev 5240)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDecoders/ADM_ad_vorbis/ADM_ad_vorbis.cpp	2009-08-12 18:12:50 UTC (rev 5241)
@@ -30,6 +30,7 @@
 #include "ADM_default.h"
 #include "ADM_ad_plugin.h"
 #include "ADM_ad_vorbis.h"
+#include "ADM_audioCodecEnum.h"
 
 #define STRUCT ((oggVorbis *)_contextVoid)
 
@@ -50,7 +51,9 @@
 
 // Supported formats + declare our plugin
 //*******************************************************
-static uint32_t Formats[]={WAV_OGG};
+static  ad_supportedFormat Formats[]={
+        {WAV_OGG,AD_MEDIUM_QUAL},
+};
 DECLARE_AUDIO_DECODER(ADM_vorbis,						// Class
 			0,0,1, 												// Major, minor,patch 
 			Formats, 											// Supported formats



From mean at mail.berlios.de  Fri Aug 14 19:29:19 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Fri, 14 Aug 2009 19:29:19 +0200
Subject: [Avidemux-svn-commit] r5242 - in
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers:
	. Asf
Message-ID: <200908141729.n7EHTJHm032641@sheep.berlios.de>

Author: mean
Date: 2009-08-14 19:29:18 +0200 (Fri, 14 Aug 2009)
New Revision: 5242

Added:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asf.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asf.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asfChunk.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asfIo.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asfPacket.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asfPacket.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asf_audio.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/CMakeLists.txt
Log:
[Demuxer] Raw import of asf demuxer from 2.5

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asf.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asf.cpp	2009-08-12 18:12:50 UTC (rev 5241)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asf.cpp	2009-08-14 17:29:18 UTC (rev 5242)
@@ -0,0 +1,777 @@
+/***************************************************************************
+    copyright            : (C) 2006 by mean
+    email                : fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include "config.h"
+
+#include <math.h>
+
+#include "ADM_default.h"
+#include "ADM_editor/ADM_Video.h"
+#include "ADM_assert.h"
+
+#include "fourcc.h"
+#include "DIA_coreToolkit.h"
+//#include "DIA_working.h"
+#include "ADM_asf.h"
+#include "ADM_asfPacket.h"
+
+#include "ADM_osSupport/ADM_debugID.h"
+#define MODULE_NAME MODULE_ASF
+#include "ADM_osSupport/ADM_debug.h"
+
+static const uint8_t asf_audio[16]={0x40,0x9e,0x69,0xf8,0x4d,0x5b,0xcf,0x11,0xa8,0xfd,0x00,0x80,0x5f,0x5c,0x44,0x2b};
+static const uint8_t asf_video[16]={0xc0,0xef,0x19,0xbc,0x4d,0x5b,0xcf,0x11,0xa8,0xfd,0x00,0x80,0x5f,0x5c,0x44,0x2b};
+
+
+WAVHeader *asfHeader::getAudioInfo(void )
+{
+  if(!_curAudio) return NULL;
+  return _curAudio->getInfo();
+}
+/*
+    __________________________________________________________
+*/
+
+uint8_t asfHeader::getAudioStream(AVDMGenericAudioStream **audio)
+{
+ 
+  *audio=_curAudio;
+  return 1; 
+}
+/*
+    __________________________________________________________
+*/
+
+void asfHeader::Dump(void)
+{
+ 
+  printf("*********** ASF INFO***********\n");
+}
+/*
+    __________________________________________________________
+*/
+
+uint8_t asfHeader::close(void)
+{
+	if (_fd) 
+		fclose(_fd);
+
+	_fd=NULL;
+
+  if(_videoExtraData)
+  {
+    delete [] _videoExtraData;
+    _videoExtraData=NULL; 
+  }
+  if(myName)
+  {
+    delete myName;
+    myName=NULL; 
+  }
+  if(_extraData)
+  {
+    delete [] _extraData;
+    _extraData=NULL; 
+  }
+  if(_index)
+  {
+    delete [] _index; 
+  }
+  _index=NULL;
+  if(_packet)
+    delete _packet;
+  _packet=NULL;
+  
+  for(int i=0;i<_nbAudioTrack;i++)
+  {
+    asfAudioTrak *trk=&(_allAudioTracks[i]);
+    if(trk->extraData) delete [] trk->extraData;
+    trk->extraData=NULL;
+  }
+}
+uint8_t       asfHeader::getExtraHeaderData(uint32_t *len, uint8_t **data)
+{
+  *len=_extraDataLen;
+  *data=_extraData;
+  return 1; 
+}
+/*
+    __________________________________________________________
+*/
+
+ asfHeader::asfHeader( void ) : vidHeader()
+{
+  _fd=NULL;
+  _videoIndex=-1;
+  myName=NULL;
+  _extraDataLen=0;
+  _extraData=NULL;
+  _packetSize=0;
+  _videoStreamId=0;
+  nbImage=0;
+  _index=NULL;
+  _packet=NULL;
+  _curAudio=NULL;
+  _nbPackets=0;
+  printf("%u\n",sizeof(_allAudioTracks));
+  memset(&(_allAudioTracks[0]),0,sizeof(_allAudioTracks));
+
+  _nbAudioTrack=0;
+  _currentAudioStream=0;
+}
+/*
+    __________________________________________________________
+*/
+
+ asfHeader::~asfHeader(  )
+{
+  close();
+}
+/*
+    __________________________________________________________
+*/
+
+uint8_t asfHeader::open(const char *name)
+{
+  _fd=fopen(name,"rb");
+  if(!_fd)
+  {
+    GUI_Error_HIG("File Error.","Cannot open file\n");
+    return 0; 
+  }
+  myName=ADM_strdup(name);
+  if(!getHeaders())
+  {
+    return 0; 
+  }
+  buildIndex();
+  fseeko(_fd,_dataStartOffset,SEEK_SET);
+  _packet=new asfPacket(_fd,_nbPackets,_packetSize,&readQueue,_dataStartOffset);
+  curSeq=1;
+  if(_nbAudioTrack)
+  {
+    _curAudio=new asfAudio(this,_currentAudioStream);
+  }
+  return 1;
+}
+/*
+    __________________________________________________________
+*/
+
+ 
+/*
+    __________________________________________________________
+*/
+
+  uint8_t  asfHeader::setFlag(uint32_t frame,uint32_t flags)
+{
+  ADM_assert(frame<nbImage);
+  _index[frame].flags=flags;
+  return 1; 
+}
+/*
+    __________________________________________________________
+*/
+
+uint32_t asfHeader::getFlags(uint32_t frame,uint32_t *flags)
+{
+  if(frame>=nbImage) return 0;
+  if(!frame) *flags=AVI_KEY_FRAME;
+  else 
+      *flags=_index[frame].flags;
+  return 1; 
+}
+/*
+    __________________________________________________________
+*/
+
+uint8_t  asfHeader::getFrameNoAlloc(uint32_t framenum,ADMCompressedImage *img)
+{
+  img->dataLength=0;
+  img->flags=AVI_KEY_FRAME;
+  if(framenum>=nbImage)
+  {
+    printf("[ASF] Going out of bound %u %u\n",framenum, nbImage);
+    return 0;
+  }
+  if(!_index[framenum].frameLen)
+  {
+    return 1; // Empty frame 
+  }
+  // In case curSeq is stored as one byte..
+  curSeq&=0xff;
+  //
+  uint32_t len=0;
+  aprintf("Framenum %u len: %u curSeq %u frameSeq=%u packetnb=%u \n",
+         framenum,_index[framenum].frameLen,curSeq,
+         _index[framenum].segNb,_index[framenum].packetNb);
+  // Seeking ?
+  if(_index[framenum].segNb!=curSeq)
+  {
+    printf("Seeking.. curseq:%u wanted seq:%u\n",curSeq,_index[framenum].segNb);
+    if(!_packet->goToPacket(_index[framenum].packetNb))
+    {
+      printf("[ASF] Cannot seek to frame %u\n",framenum);
+      return 0; 
+    }
+    _packet->purge();
+    curSeq=_index[framenum].segNb;
+    printf("Seeking starting at seq=%u\n",curSeq);
+  }
+  
+  
+  len=0;
+  uint32_t delta;
+  while(1)
+  {
+   
+    
+    
+    while(!readQueue.isEmpty())
+    {
+      asfBit *bit;
+      ADM_assert(readQueue.pop((void**)&bit));
+      aprintf(">found packet of size %d seq %d, while curseq =%d wanted seg=%u current offset=%u\n",bit->len,bit->sequence,curSeq,_index[framenum].segNb,len);
+      // Here it is tricky
+      // if len==0 we are reading the first part of our frame
+      // The packet may starts with segments from the previous frame
+      // discard them
+      // Delta is just a security as it should be slightly >10
+      delta=256+bit->sequence-_index[framenum].segNb;
+      delta &=0xff;
+      if(!len) // Starting a new frame
+      {
+          if(_index[framenum].segNb != bit->sequence )
+          {
+            aprintf("Dropping seq=%u too old for %u delta %d\n",
+                  bit->sequence,_index[framenum].segNb,delta);
+            delete[] bit->data;
+            delete bit;
+            if(delta<230)
+            {
+              printf("Very suspicious\n");
+              printf("Very suspicious\n");
+              printf("Very suspicious\n");
+              printf("Very suspicious\n");
+              printf("Very suspicious\n");
+            }
+            continue; 
+          }
+          // We have found our first chunk
+          curSeq=bit->sequence;
+          memcpy(img->data,bit->data,bit->len);
+          len=bit->len;
+          delete[] bit->data;
+          delete bit;
+          continue;
+      }
+      // Continuing a frame
+      // If the seq number is different it is the beginning of a new frame
+      if(bit->sequence!=curSeq )
+      {
+        aprintf("New sequence %u->%u while loading %u frame\n",curSeq,bit->sequence,framenum);
+        img->dataLength=len;
+        readQueue.pushBack(bit); // don't delete it, we will use it later...
+        curSeq=bit->sequence;
+        goto gotcha;
+      }
+      // still same sequence ...add
+      memcpy(img->data+len,bit->data,bit->len);
+      len+=bit->len;
+	  delete[] bit->data;
+      delete bit;
+    }
+    if(!_packet->nextPacket(_videoStreamId))
+    {
+      printf("[ASF] Packet Error\n");
+      return 0; 
+    }
+    _packet->skipPacket();
+  }
+gotcha:
+  
+  img->dataLength=len;
+  if(len!=_index[framenum].frameLen)
+  {
+    printf("[ASF] Frame=%u :-> Mismatch found len : %u expected %u\n",framenum,len, _index[framenum].frameLen);
+  }
+  aprintf(">>Len %d seq %d\n",len,curSeq);
+  return 1; 
+}
+/*
+    __________________________________________________________
+*/
+
+/*******************************************
+  Read Headers to collect information 
+********************************************/
+uint8_t asfHeader::getHeaders(void)
+{
+  uint32_t i=0,nbSubChunk,hi,lo;
+  const chunky *id;
+  uint8_t gid[16];
+  uint32_t mn=0,mx=0;
+  asfChunk chunk(_fd);
+  // The first header is header chunk
+  chunk.nextChunk();
+  id=chunk.chunkId();
+  if(id->id!=ADM_CHUNK_HEADER_CHUNK)
+  {
+    printf("[ASF] expected header chunk\n"); 
+    return 0;
+  }
+  printf("[ASF] getting headers\n");
+  chunk.dump();
+  nbSubChunk=chunk.read32();
+  printf("NB subchunk :%u\n",nbSubChunk);
+  chunk.read8();
+  chunk.read8();
+  for(i=0;i<nbSubChunk;i++)
+  {
+    asfChunk *s=new asfChunk(_fd);
+    uint32_t skip;
+    s->nextChunk();
+    printf("***************\n");  
+    id=s->chunkId();
+    s->dump();
+    switch(id->id)
+    {
+#if 0      
+      case ADM_CHUNK_HEADER_EXTENSION_CHUNK:
+      {
+        s->skip(16); // Clock type extension ????
+        printf("?? %d\n",s->read16());
+        printf("?? %d\n",s->read32());
+          
+        uint32_t streamNameCount;
+        uint32_t payloadCount;
+          
+          asfChunk *u=new asfChunk(_fd);
+          for(int zzz=0;zzz<8;zzz++)
+          {
+              u->nextChunk();
+              u->dump();
+              id=u->chunkId();
+              if(id->id==ADM_CHUNK_EXTENDED_STREAM_PROP)
+              {
+                  s->skip(8); // start time 
+                  s->skip(8); // end time
+                  printf("Bitrate         %u :\n",u->read32());
+                  printf("Buffer Size     %u :\n",u->read32());
+                  printf("BFill           %u :\n",u->read32());
+                  printf("Alt Bitrate     %u :\n",u->read32());
+                  printf("Alt Bsize       %u :\n",u->read32());
+                  printf("Alt Bfullness   %u :\n",u->read32());
+                  printf("Max object Size %u :\n",u->read32());
+                  printf("Flags           0x%x :\n",u->read32());
+                  printf("Stream no       %u :\n",u->read16());
+                  printf("Stream lang     %u :\n",u->read16());
+                  printf("Stream time/fra %lu :\n",u->read64());
+                  streamNameCount=u->read16();
+                  payloadCount=u->read16();
+                  printf("Stream Nm Count %u :\n",streamNameCount);
+                  printf("Payload count   %u :\n",payloadCount);
+                  for(int stream=0;stream<streamNameCount;stream++)
+                  {
+                    u->read16();
+                    skip=u->read16();
+                    u->skip(skip);
+                  }
+                  uint32_t size;
+                  for(int payload=0;payload<payloadCount;payload++)
+                  {
+                    for(int pp=0;pp<16;pp++) printf("0x%02x,",u->read8());
+                    printf("\n");
+                    skip=u->read16();
+                    size=u->read32();
+                    u->skip(size);
+                    printf("Extra Data : %d, skipd %d\n",size,skip);
+                  }
+                  printf("We are at %x\n",ftello(_fd));
+                }
+                u->skipChunk();
+          }
+          delete u;
+      }
+      break;
+#endif      
+      case ADM_CHUNK_FILE_HEADER_CHUNK:
+        {
+            // Client GID
+            printf("Client        :");
+            for(int z=0;z<16;z++) printf(":%02x",s->read8());
+            printf("\n");
+            printf("File size     : %08lx\n",s->read64());
+            printf("Creation time : %08lx\n",s->read64());
+            printf("Number of pack: %08lx\n",s->read64());
+            printf("Timestamp 1   : %08lx\n",s->read64());
+            _duration=s->read64();
+            printf("Timestamp 2   : %08lx\n",_duration);
+            printf("Timestamp 3   : %04x\n",s->read32());
+            printf("Preload       : %04x\n",s->read32());
+            printf("Flags         : %04x\n",s->read32());
+            mx=s->read32();
+            mn=s->read32();
+            if(mx!=mn)
+            {
+              printf("Variable packet size!!\n");
+              delete s;
+              return 0; 
+            }
+            _packetSize=mx;
+            printf("Min size      : %04x\n",mx);
+            printf("Max size      : %04x\n",mn);
+            printf("Uncompres.size: %04x\n",s->read32());
+          }
+          break;
+      case ADM_CHUNK_STREAM_HEADER_CHUNK:
+      {
+         // Client GID
+        uint32_t audiovideo=0; // video=1, audio=2, 0=unknown
+        uint32_t sid;
+        s->read(gid,16);
+        printf("Type            :");
+        for(int z=0;z<16;z++) printf("0x%02x,",gid[z]);
+        if(!memcmp(gid,asf_video,16))
+        {
+          printf("(video)");
+          audiovideo=1;
+        } else
+        {
+          if(!memcmp(gid,asf_audio,16))
+          {
+            printf("(audio)"); 
+            audiovideo=2;
+          } else printf("(? ? ? ?)"); 
+        }
+        printf("\nConceal       :");
+        for(int z=0;z<16;z++) printf(":%02x",s->read8());
+        printf("\n");
+        printf("Reserved    : %08x\n",s->read64());
+        printf("Total Size  : %04x\n",s->read32());
+        printf("Size        : %04x\n",s->read32());
+        sid=s->read16();
+        printf("Stream nb   : %04x\n",sid);
+        printf("Reserved    : %04x\n",s->read32());
+        switch(audiovideo)
+        {
+          case 1: // Video
+          {
+                    _videoStreamId=sid;
+                    if(!loadVideo(s))
+                    {
+                      delete s;
+                      return 0; 
+                    }
+                    break;
+          }
+              break;
+          case 2: // audio
+          {
+            asfAudioTrak *trk=&(_allAudioTracks[_nbAudioTrack]);
+            ADM_assert(_nbAudioTrack<ASF_MAX_AUDIO_TRACK);
+            trk->streamIndex=sid;
+            s->read((uint8_t *)&(trk->wavHeader),sizeof(WAVHeader));
+
+		#ifdef ADM_BIG_ENDIAN
+			Endian_WavHeader(&(trk->wavHeader));
+		#endif
+
+            trk->extraDataLen=s->read16();
+            printf("Extension :%u bytes\n",trk->extraDataLen);
+            if(trk->extraDataLen)
+            {
+              trk->extraData=new uint8_t[trk->extraDataLen];
+              s->read(trk->extraData,trk->extraDataLen);
+            }
+              printf("#block in group   :%d\n",s->read8());
+              printf("#byte in group    :%d\n",s->read16());
+              printf("Align1            :%d\n",s->read16());
+              printf("Align2            :%d\n",s->read16());
+              _nbAudioTrack++;
+            
+          }
+          break;
+          default:break; 
+          
+        }
+      }
+      break;
+       default:
+         break;
+    }
+    s->skipChunk();
+    delete s;
+  }
+  printf("End of headers\n");
+  return 1;
+}
+uint8_t    asfHeader::changeAudioStream(uint32_t newstream)
+{
+  ADM_assert(_currentAudioStream<_nbAudioTrack);
+  _currentAudioStream=newstream;
+  return 1;
+}
+uint32_t    asfHeader::getCurrentAudioStreamNumber(void)
+{
+  return _currentAudioStream;
+}
+uint8_t     asfHeader::getAudioStreamsInfo(uint32_t *nbStreams, audioInfo **infos)
+{
+    *nbStreams=_nbAudioTrack;
+    if(_nbAudioTrack)
+    {
+      *infos=new audioInfo[_nbAudioTrack];
+      for(int i=0;i<_nbAudioTrack;i++)
+      {
+        WAV2AudioInfo(&(_allAudioTracks[i].wavHeader),&((*infos)[i]));
+      }
+    }
+    return 1;
+}
+uint8_t asfHeader::loadVideo(asfChunk *s)
+{
+  uint32_t w,h,x;
+            w=s->read32();
+            h=s->read32();
+            s->read8();
+            x=s->read16();
+            _isvideopresent=1;
+
+            memset(&_mainaviheader,0,sizeof(_mainaviheader));
+            _mainaviheader.dwWidth=w;
+            _mainaviheader.dwHeight=h;
+            _video_bih.biWidth=w;
+            _video_bih.biHeight=h;
+            printf("Pic Width  %04d\n",w);
+            printf("Pic Height %04d\n",h);
+            printf(" BMP size  %04d (%04d)\n",x,sizeof(ADM_BITMAPINFOHEADER));
+            s->read((uint8_t *)&_video_bih,sizeof(ADM_BITMAPINFOHEADER));
+
+		#ifdef ADM_BIG_ENDIAN
+			Endian_BitMapInfo(&_video_bih);
+		#endif
+
+            _videostream.dwScale=1000;
+            _videostream.dwRate=30000;
+
+            _videostream.fccHandler=_video_bih.biCompression;
+            printf("Codec : <%s> (%04x)\n",
+                    fourCC::tostring(_video_bih.biCompression),_video_bih.biCompression);
+            if(fourCC::check(_video_bih.biCompression,(uint8_t *)"DVR "))
+            {
+              // It is MS DVR, fail so that the mpeg2 indexer can take it from here
+              _videostream.fccHandler=_video_bih.biCompression=fourCC::get((uint8_t *)"MPEG");
+              printf("This is MSDVR, not ASF\n");
+              return 0; 
+            }
+            printBih(&_video_bih);
+            if(x>sizeof(ADM_BITMAPINFOHEADER))
+            {
+              _extraDataLen=x-sizeof(ADM_BITMAPINFOHEADER);
+              _extraData=new uint8_t[_extraDataLen];
+              s->read(_extraData,_extraDataLen);
+            }
+            return 1;
+}
+/*
+    Scan the file to build an index
+    
+    Header Chunk
+            Chunk
+            Chunk
+            Chunk
+            
+    Data chunk
+            Chunk
+            Chunk
+            
+    We skip the 1st one, and just read the header of the 2nd one
+    
+*/
+uint8_t asfHeader::buildIndex(void)
+{
+  uint32_t fSize;
+  const chunky *id;
+  uint32_t chunkFound;
+  uint32_t r=5;
+  uint32_t len;
+  
+  fseeko(_fd,0,SEEK_END);
+  fSize=ftello(_fd);
+  fseeko(_fd,0,SEEK_SET);
+  
+  asfChunk h(_fd);
+  printf("[ASF] ********** Building index **********\n");
+  printf("[ASF] Searching data\n");
+  while(r--)
+  {
+    h.nextChunk();    // Skip headers
+    id=h.chunkId();
+    h.dump();
+    if(id->id==ADM_CHUNK_DATA_CHUNK) break;
+    h.skipChunk();
+  }
+  if(id->id!=ADM_CHUNK_DATA_CHUNK) return 0;
+  // Remove leftover from DATA_chunk
+ // Unknown	GUID	16
+//       Number of packets	UINT64	8
+//       Unknown	UINT8	1
+//       Unknown	UINT8	1
+//   
+  h.read32();
+  h.read32();
+  h.read32();
+  h.read32();
+  _nbPackets=(uint32_t) h.read64();
+  h.read16();
+  
+  len=h.chunkLen-16-8-2-24;
+  
+  printf("[ASF] nbPacket  : %u\n",_nbPackets);
+  printf("[ASF] len to go : %u\n",len);
+  printf("[ASF] scanning data\n");
+  _dataStartOffset=ftello(_fd);
+  
+  // Here we go
+  //DIA_working *working=new DIA_working("indexing asf");
+  asfPacket *aPacket=new asfPacket(_fd,_nbPackets,_packetSize,
+                                   &readQueue,_dataStartOffset);
+  uint32_t packet=1;
+#define MAXIMAGE (_nbPackets)
+  uint32_t sequence=1;
+  uint32_t ceilImage=MAXIMAGE;
+
+  nbImage=0;
+  asfIndex *tmpIndex=new asfIndex[ceilImage];
+  memset(tmpIndex,0,sizeof(asfIndex)*ceilImage);
+  len=0;
+  tmpIndex[0].segNb=1;
+  while(packet<_nbPackets)
+  {
+    while(!readQueue.isEmpty())
+    {
+      asfBit *bit=NULL;
+      ADM_assert(readQueue.pop((void**)&bit));
+      if(nbImage>=ceilImage-1)
+      {  // Expand if our first guess was too small
+           uint32_t newceil=ceilImage*2;
+           asfIndex *tmptmpIndex=new asfIndex[newceil];
+           memset(tmptmpIndex,0,sizeof(asfIndex)*newceil);
+           memcpy(tmptmpIndex,tmpIndex,sizeof(asfIndex)*ceilImage);
+           delete [] tmpIndex;
+           tmpIndex=tmptmpIndex;
+           ceilImage=newceil;
+      }
+      if(bit->stream==_videoStreamId)
+      {
+          aprintf(">found packet of size %d seq %d, while curseq =%d\n",bit->len,bit->sequence,curSeq);
+          if(bit->sequence!=sequence)
+          {
+            tmpIndex[nbImage].frameLen=len;
+            aprintf("New sequence\n");
+            if( ((sequence+1)&0xff)!=(bit->sequence&0xff))
+            {
+                printf("!!!!!!!!!!!! non continuous sequence %u %u\n",sequence,bit->sequence); 
+    #if 1         
+                // Let's insert a couple of null frame
+                int32_t delta,start,end;
+                
+                start=256+bit->sequence-sequence-1;
+                start&=0xff;
+                printf("!!!!!!!!!!!! Delta %d\n",start);
+                
+                for(int filler=0;filler<start;filler++)
+                {
+                  tmpIndex[++nbImage].frameLen=0;
+                }
+    #endif            
+            }
+            nbImage++;
+            ADM_assert(nbImage<ceilImage);
+            tmpIndex[nbImage].frameLen=0;
+            tmpIndex[nbImage].segNb=bit->sequence;
+            tmpIndex[nbImage].packetNb=bit->packet;
+            tmpIndex[nbImage].flags=bit->flags;
+
+            for(int z=0;z<_nbAudioTrack;z++)
+            {
+              tmpIndex[nbImage].audioSeen[z]=_allAudioTracks[z].length;
+            }
+            readQueue.pushBack(bit);
+    
+            sequence=bit->sequence;
+            len=0;
+            continue;
+          }
+          len+=bit->len;
+      } // End of video stream Id
+      else  // Audio ?
+      {
+        int found=0;
+        for(int i=0;i<_nbAudioTrack && !found;i++)
+        {
+          if(bit->stream == _allAudioTracks[i].streamIndex)
+          {
+            
+            _allAudioTracks[i].length+=bit->len;
+            found=1;
+          }
+        }
+        if(!found) 
+        {
+          printf("Unmapped stream %u\n",bit->stream); 
+        }
+      }
+     delete[] bit->data;
+     delete bit;
+    }
+    //working->update(packet,_nbPackets);
+
+    packet++;
+    aPacket->nextPacket(0xff); // All packets
+    aPacket->skipPacket();
+  }
+  delete aPacket;
+  //delete working;
+  /* Compact index */
+  _index=new asfIndex[nbImage];
+  memcpy(_index,tmpIndex,sizeof(asfIndex)*nbImage);
+  delete [] tmpIndex;
+  
+  fseeko(_fd,_dataStartOffset,SEEK_SET);
+  printf("[ASF] %u images found\n",nbImage);
+  printf("[ASF] ******** End of buildindex *******\n");
+  _videostream.dwLength=_mainaviheader.dwTotalFrames=nbImage;
+  if(!nbImage) return 0;
+  
+  // Update fps
+  // In fact it is an average fps
+  // FIXME
+  float f=nbImage;
+  uint32_t ps;
+  
+  f*=1000.*1000.*10000.;
+  f=f/_duration;
+  ps=(uint32_t)f;
+  // Round up to the closed 0.5 = 500
+  ps=(ps+490)/500;
+  ps*=500;
+  
+  _videostream.dwScale=1000;
+  _videostream.dwRate=ps;
+
+  return 1;
+  
+}
+//EOF

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asf.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asf.h	2009-08-12 18:12:50 UTC (rev 5241)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asf.h	2009-08-14 17:29:18 UTC (rev 5242)
@@ -0,0 +1,201 @@
+/***************************************************************************
+                          ADM_pics.h  -  description
+                             -------------------
+    begin                : Mon Jun 3 2002
+    copyright            : (C) 2002 by mean
+    email                : fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+ 
+
+
+#ifndef ADM_ASF_H
+#define ADM_ASF_H
+
+#include "ADM_editor/ADM_Video.h"
+#include "ADM_audio/aviaudio.hxx"
+
+#include "ADM_osSupport/ADM_queue.h"
+#include "ADM_asfPacket.h"
+
+#define ASF_MAX_AUDIO_TRACK 8
+
+typedef struct 
+{
+  uint32_t packetNb;
+  uint32_t frameLen;
+  uint32_t segNb;
+  uint32_t flags;
+  uint32_t audioSeen[ASF_MAX_AUDIO_TRACK];
+}asfIndex;
+
+typedef enum 
+{
+  ADM_CHUNK_HEADER_CHUNK ,
+  ADM_CHUNK_FILE_HEADER_CHUNK,
+  ADM_CHUNK_NO_AUDIO_CONCEAL,
+  ADM_CHUNK_STREAM_HEADER_CHUNK,
+  ADM_CHUNK_STREAM_GROUP_ID,
+  ADM_CHUNK_DATA_CHUNK,
+  ADM_CHUNK_HEADER_EXTENSION_CHUNK,
+  ADM_CHUNK_CLOCK_TYPE_EX,
+  ADM_CHUNK_LANGUAGE_LIST_EX,
+  ADM_CHUNK_EXTENDED_STREAM_PROP,
+  ADM_CHUNK_UNKNOWN_CHUNK
+}ADM_KNOWN_CHUNK;
+typedef struct 
+{
+  const char *name;
+  uint32_t len;
+  uint8_t val[16];
+  ADM_KNOWN_CHUNK id; 
+}chunky;
+class asfChunk
+{
+  protected:
+    FILE        *_fd;
+    
+    
+  public:
+  uint32_t  _chunkStart;
+            asfChunk(FILE *f);
+            ~asfChunk();
+  uint8_t   dump(void);
+  uint8_t   guId[16];
+  uint64_t  chunkLen;
+  
+  uint8_t   readChunkPayload(uint8_t *data, uint32_t *dataLen);
+  uint8_t   nextChunk(int shortChunk=0);
+  uint8_t   skipChunk(void);
+  uint64_t  read64(void);
+  uint32_t  read32(void);
+  uint32_t  read16(void);
+  uint8_t   read8(void);
+  uint8_t   read(uint8_t *where, uint32_t how);
+  const chunky    *chunkId(void);
+  uint8_t   skip(uint32_t skip);
+};
+
+typedef struct 
+{
+  uint32_t     streamIndex;
+  uint32_t     extraDataLen;
+  uint8_t      *extraData;
+  uint32_t     nbPackets;
+  uint32_t     length;
+  WAVHeader    wavHeader;
+  
+}asfAudioTrak;
+
+class asfAudio : public AVDMGenericAudioStream
+{
+  protected:
+    uint32_t                _myRank;
+    uint32_t                _extraDataLen;
+    uint8_t                 *_extraData;
+    char                    *myName;
+    uint32_t                _streamId;
+    uint32_t                _dataStart;
+    asfPacket               *_packet;
+    FILE                    *_fd;
+    ADM_queue               readQueue;
+    uint32_t                _packetSize;
+    class asfHeader         *_father;
+    asfAudioTrak            *_track;
+  public:
+                                asfAudio(asfHeader *father,uint32_t rank);
+    virtual                     ~asfAudio();
+    virtual uint32_t            read(uint32_t len,uint8_t *buffer);
+    virtual uint8_t             goTo(uint32_t newoffset);
+    virtual uint8_t             getPacket(uint8_t *dest, uint32_t *len, uint32_t *samples);
+    virtual uint8_t             goToTime(uint32_t mstime);
+    virtual uint8_t             extraData(uint32_t *l,uint8_t **d);
+};
+
+
+
+class asfHeader         :public vidHeader
+{
+  protected:
+    uint8_t                 getHeaders( void);
+    uint8_t                 buildIndex(void);
+    uint8_t                 loadVideo(asfChunk *s);
+    
+    ADM_queue               readQueue;
+    uint32_t                curSeq;
+    asfPacket               *_packet;
+    uint32_t                _currentAudioStream;
+    uint64_t                _duration;  // Duration 100 ns
+  protected:
+                                
+    FILE                    *_fd;
+
+    int32_t                 _videoIndex;
+    uint32_t                _extraDataLen;
+    uint8_t                 *_extraData;
+    
+    
+    uint32_t                _videoStreamId;
+    
+  public: // Shared with audio track
+    char                    *myName;
+    
+    uint32_t                nbImage;
+    asfIndex                *_index;
+    uint32_t                _packetSize;
+    uint32_t                _dataStartOffset;
+    uint32_t                _nbAudioTrack;
+    asfAudio                *_curAudio;
+    asfAudioTrak             _allAudioTracks[ASF_MAX_AUDIO_TRACK];
+    uint32_t                 _nbPackets;
+    
+    // / Shared
+  public:
+
+
+    virtual   void          Dump(void);
+    virtual   uint8_t       getExtraHeaderData(uint32_t *len, uint8_t **data);
+             asfHeader( void );
+    virtual  ~asfHeader(  ) ;
+// AVI io
+    virtual uint8_t  open(const char *name);
+    virtual uint8_t  close(void) ;
+  //__________________________
+  //  Info
+  //__________________________
+
+  //__________________________
+  //  Audio
+  //__________________________
+
+    virtual   WAVHeader *getAudioInfo(void ) ;
+    virtual uint8_t getAudioStream(AVDMGenericAudioStream **audio);
+
+
+// Frames
+  //__________________________
+  //  video
+  //__________________________
+
+    virtual uint8_t  setFlag(uint32_t frame,uint32_t flags);
+    virtual uint32_t getFlags(uint32_t frame,uint32_t *flags);
+    virtual uint8_t  getFrameNoAlloc(uint32_t framenum,ADMCompressedImage *img)	;
+    //
+    //  Multiple audio channels
+    //
+    uint8_t           changeAudioStream(uint32_t newstream);
+    uint32_t          getCurrentAudioStreamNumber(void) ;
+    uint8_t           getAudioStreamsInfo(uint32_t *nbStreams, audioInfo **infos);
+
+};
+#endif
+
+

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asfChunk.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asfChunk.cpp	2009-08-12 18:12:50 UTC (rev 5241)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asfChunk.cpp	2009-08-14 17:29:18 UTC (rev 5242)
@@ -0,0 +1,207 @@
+/***************************************************************************
+    copyright            : (C) 2006 by mean
+    email                : fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include "config.h"
+
+#include <stdio.h>
+#include <stdlib.h>
+
+#include <string.h>
+
+#include <math.h>
+
+#include "ADM_default.h"
+#include "ADM_editor/ADM_Video.h"
+#include "ADM_assert.h"
+
+#include "fourcc.h"
+
+
+#include "ADM_asf.h"
+
+// http://www.thozie.de/dnn/AVIMaster.aspx?PageContentID=4
+
+static const chunky mychunks[]=
+{
+  {"Header Chunk",0,    {0x30,0x26,0xb2,0x75,0x8e,0x66,0xcf,0x11,0xa6,0xd9,0x00,0xaa,0x00,0x62,0xce,0x6c},ADM_CHUNK_HEADER_CHUNK},
+  {"File Header",0,  {0xa1,0xdc,0xab,0x8c,0x47,0xa9,0xcf,0x11,0x8e,0xe4,0x00,0xc0,0x0c,0x20,0x53,0x65},ADM_CHUNK_FILE_HEADER_CHUNK},
+  {"No audio conceal",0,
+  {0x40,0x52,0xd1,0x86,0x1d,0x31,0xd0,0x11,0xa3,0xa4,0x00,0xa0,0xc9,0x03,0x48,0xf6},ADM_CHUNK_NO_AUDIO_CONCEAL},
+  {"Stream Header",0,   {0x91,0x07,0xdc,0xb7,0xb7,0xa9,0xcf,0x11,0x8e,0xe6,0x00,0xc0,0x0c,0x20,0x53,0x65},ADM_CHUNK_STREAM_HEADER_CHUNK},
+  {"Stream Group Id",0, {0xce,0x75,0xf8,0x7b,0x8d,0x46,0xd1,0x11,0x8d,0x82,0x00,0x60,0x97,0xc9,0xa2,0xb2},ADM_CHUNK_STREAM_GROUP_ID},
+  {"Data Chunk",0,      {0x36,0x26,0xb2,0x75,0x8e,0x66,0xcf,0x11,0xa6,0xd9,0x00,0xaa,0x00,0x62,0xce,0x6c},ADM_CHUNK_DATA_CHUNK},
+  {"Header Extension",0,
+    {0Xb5,0x03,0xbf,0x5f,0x2e,0xa9,0xcf,0x11,0x8e,0xe3,0x00,0xc0,0x0c,0x20,0x53,0x65},
+              ADM_CHUNK_HEADER_EXTENSION_CHUNK},
+  {"Clock Type  Ext",0,
+  {0x11,0xd2,0xd3,0xab,0xba,0xa9,0xcf,0x11,0x8e,0xe6,0x00,0xc0,0x0c,0x20,0x53,0x65},ADM_CHUNK_CLOCK_TYPE_EX},
+  {"Language List Ext",0,
+  {0xa9,0x46,0x43,0x7c,0xe0,0xef,0xfc,0x4b,0xb2,0x29,0x39,0x3e,0xde,0x41,0x5c,0x85},ADM_CHUNK_LANGUAGE_LIST_EX},
+  {"Compatibility List Ex",0,
+  {0x5d,0x8b,0xf1,0x26,0x84,0x45,0xec,0x47,0x9f,0x5f,0x0e,0x65,0x1f,0x04,0x52,0xc9},ADM_CHUNK_UNKNOWN_CHUNK},
+  {"Padding",0,
+  {0x74,0xd4,0x06,0x18,0xdf,0xca,0x09,0x45,0xa4,0xba,0x9a,0xab,0xcb,0x96,0xaa,0xe8},ADM_CHUNK_UNKNOWN_CHUNK},
+  {"Padding2",0,
+  {0x94,0x1c,0x23,0x44,0x98,0x94,0xd1,0x49,0xa1,0x41,0x1d,0x13,0x4e,0x45,0x70,0x54},ADM_CHUNK_UNKNOWN_CHUNK},
+
+  {"Extended Stream Property",0,
+  {0xcb,0xa5,0xe6,0x14,0x72,0xc6,0x32,0x43,0x83,0x99,0xa9,0x69,0x52,0x06,0x5b,0x5a},ADM_CHUNK_EXTENDED_STREAM_PROP},
+  {"MetaData Object",0,
+  {0xea,0xcb,0xf8,0xc5,0xaf,0x5b,0x77,0x48,0x84,0x67,0xaa,0x8c,0x44,0xfa,0x4c,0xca},ADM_CHUNK_UNKNOWN_CHUNK},
+  
+  {"zz",0,{0x30,0x26,0xb2,0x75,0x8e,0x66,0xcf,0x11,0xa6,0xd9,0x00,0xaa,0x00,0x62,0xce,0x6c},ADM_CHUNK_HEADER_CHUNK}
+  
+};
+static const chunky nochunk=
+{"Unknown",0,{0x10,0x20,0x30,0x40,0xde,0xad,0xde,0xad,0xbe,0xef,0xbe,0xef,0x00,0x62,0xce,0x6c},ADM_CHUNK_UNKNOWN_CHUNK};
+
+
+ asfChunk::asfChunk(FILE *f)
+{
+  _fd=f;
+  _chunkStart=ftello(f);;
+  printf("Chunk created at %x\n",_chunkStart);
+  ADM_assert(_fd);
+  chunkLen=0;
+}
+ asfChunk::~asfChunk()
+{
+}
+uint8_t   asfChunk::readChunkPayload(uint8_t *data, uint32_t *dataLen)
+{
+  uint32_t remaining;
+  
+  remaining=ftello(_fd);
+  remaining-=_chunkStart;
+  remaining=chunkLen-remaining;
+  fread(data,remaining,1,_fd);
+  *dataLen=remaining;
+  return 1;
+}
+uint8_t   asfChunk::skip(uint32_t skip)
+{
+  fseeko(_fd,skip,SEEK_CUR);
+  return 1; 
+}
+uint8_t   asfChunk::nextChunk(int shortChunk)
+{
+  uint32_t low,high;
+  
+  if(_chunkStart)
+  {
+    
+    fseeko(_fd,_chunkStart+ chunkLen,SEEK_SET);
+  }
+  
+  _chunkStart=ftello(_fd);
+  fread(guId,16,1,_fd);
+  if(shortChunk)
+  {
+    low=read16()+16;
+    high=0;
+  } 
+  else
+  {
+    low=read32();
+    high=read32();
+  }
+  chunkLen=high;
+  chunkLen<<=32;
+  chunkLen+=low;
+  
+  printf("Next chunk from %x +%u to %x\n",_chunkStart,chunkLen,chunkLen+_chunkStart);
+  
+  return 1;
+  
+}
+uint8_t   asfChunk::skipChunk(void)
+{
+  uint32_t go;
+  go=_chunkStart+ chunkLen;
+  printf("Pos %x\n",ftello(_fd));
+  fseeko(_fd,go,SEEK_SET);
+  printf("Skipping to %x\n",go);
+  
+  return 1; 
+}
+uint64_t  asfChunk::read64(void)
+{
+  uint64_t lo,hi;
+  lo=read32();
+  hi=read32();
+  return lo+(hi<<32); 
+  
+}
+uint32_t   asfChunk::read32(void)
+{
+  uint8_t c[4];
+  
+  fread(c,4,1,_fd);
+  
+  return c[0]+(c[1]<<8)+(c[2]<<16)+(c[3]<<24);
+  
+}
+uint32_t   asfChunk::read16(void)
+{
+  uint8_t c[2];
+  
+  fread(c,2,1,_fd);
+  
+  return c[0]+(c[1]<<8);
+  
+}
+
+uint8_t   asfChunk::read8(void)
+{
+  uint8_t c[1];
+  
+  fread(c,1,1,_fd);
+  
+  return c[0];
+  
+}
+uint8_t   asfChunk::read(uint8_t *where, uint32_t how)
+{
+ 
+  if(1!=fread(where,how,1,_fd))
+  {
+    printf("[AsfChunk] Read error\n");
+    return 0; 
+  }
+  return 1;
+
+  
+}
+uint8_t   asfChunk::dump(void)
+{
+  const chunky *id;
+  id=chunkId();
+  printf("Chunk type  : <<<<%s>>>>\n",id->name);
+  printf("Chunk Start : %x\n",_chunkStart);
+  printf("Chunk Len   : %lu\n",(uint32_t)chunkLen);
+  for(int i=0;i<16;i++) printf("%02x ",guId[i]);
+  printf("\n");
+  return 1;
+  
+}
+const chunky *asfChunk::chunkId(void)
+{
+  int mx=sizeof(mychunks)/sizeof(chunky);
+  for(int i=0;i<sizeof(mychunks)/sizeof(chunky);i++)
+  {
+    if(!memcmp(mychunks[i].val,guId,16)) return &mychunks[i];
+  }
+  return &nochunk;
+  
+}
+

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asfIo.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asfIo.h	2009-08-12 18:12:50 UTC (rev 5241)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asfIo.h	2009-08-14 17:29:18 UTC (rev 5242)
@@ -0,0 +1,35 @@
+  uint64_t  asfPacket::read64(void)
+      {
+        uint64_t lo,hi;
+        lo=read32();
+        hi=read32();
+        _offset+=8;
+        ADM_assert(_offset<=pakSize);
+        return lo+(hi<<32); 
+        
+      }
+      uint32_t   asfPacket::read32(void)
+      {
+        uint8_t c[4];
+        fread(c,4,1,_fd);
+        _offset+=4;
+        ADM_assert(_offset<=pakSize);
+        return c[0]+(c[1]<<8)+(c[2]<<16)+(c[3]<<24);
+      }
+      uint32_t   asfPacket::read16(void)
+      {
+        uint8_t c[2];
+        fread(c,2,1,_fd);
+        _offset+=2;
+        ADM_assert(_offset<=pakSize);
+        return c[0]+(c[1]<<8);
+      }
+      
+      uint8_t   asfPacket::read8(void)
+      {
+        uint8_t c[1];
+        fread(c,1,1,_fd);
+        _offset++;
+        ADM_assert(_offset<=pakSize);
+        return c[0];
+      }

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asfPacket.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asfPacket.cpp	2009-08-12 18:12:50 UTC (rev 5241)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asfPacket.cpp	2009-08-14 17:29:18 UTC (rev 5242)
@@ -0,0 +1,407 @@
+/***************************************************************************
+    copyright            : (C) 2006 by mean
+    email                : fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include "config.h"
+
+#include <stdio.h>
+#include <stdlib.h>
+
+#include <string.h>
+
+#include <math.h>
+
+#include "ADM_default.h"
+#include "ADM_editor/ADM_Video.h"
+#include "ADM_assert.h"
+
+#include "fourcc.h"
+
+
+#include "ADM_asfPacket.h"
+
+#include "ADM_osSupport/ADM_debugID.h"
+#define MODULE_NAME MODULE_ASF
+#include "ADM_osSupport/ADM_debug.h"
+
+ 
+asfPacket::asfPacket(FILE *f,uint32_t nb,uint32_t pSize,ADM_queue *q,uint32_t startDataOffset)
+ {
+   _fd=f;
+   pakSize=pSize;
+   ADM_assert(pakSize);
+   packetStart=ftello(f);;
+   aprintf("Packet created at %x\n",packetStart);
+   ADM_assert(_fd);
+   queue=q;
+   ADM_assert(q);
+   currentPacket=0;
+   _nbPackets=nb;
+   _startDataOffset=startDataOffset;
+ }
+ asfPacket::~asfPacket()
+ {
+	 purge();
+ }
+ uint8_t   asfPacket::readChunkPayload(uint8_t *data, uint32_t *dataLen)
+ {
+   uint32_t remaining;
+   *dataLen=0;
+   ADM_assert(0);
+   purge();
+   return 1;
+  
+ }
+ 
+ uint8_t asfPacket::goToPacket(uint32_t packet)
+ {
+   uint32_t offset=_startDataOffset+packet*pakSize;
+   fseeko(_fd,offset,SEEK_SET);
+   currentPacket=packet;
+   return 1;
+ }
+ /*
+      Read ASF packet & segments 
+ 
+    Flags are bitwise OR of:
+   
+ 0x40 Explicit packet size specified word16  0X60 Means word32
+ 0x20 Explicit packet size specified byte
+   
+ 0x10 16-bit padding size specified  0x18 means word32
+ 0x08 8-bit padding size specified
+   
+ 0x04 sequence coded in word16
+ 0x02 sequence coded in byte
+ 0x01 More than one segment
+ 
+ 
+ Docs from http://avifile.sourceforge.net/asf-1.0.htm
+  completed by mplayer code
+  
+ 
+ */
+uint8_t   asfPacket::nextPacket(uint8_t streamWanted)
+{
+   uint32_t atime,aduration,nbSeg,segType=0x80;
+   uint32_t sequenceLen,len,streamId;
+   int32_t   packetLen=0;
+   uint32_t  paddingLen;
+   uint8_t   flags;
+    
+   packetStart=ftello(_fd);
+#ifdef ADM_DEBUG
+   uint32_t round=packetStart-_startDataOffset;
+   if(round % pakSize)
+   {
+     printf("[ASF PACKET] we are starting a new packet at 0x%x\n",packetStart); 
+     printf("[ASF PACKET]but data starts at  0x%x\n",_startDataOffset);
+     printf("[ASF PACKET]and offset is not a multiple of length = %d\n",pakSize);
+     ADM_assert(0);
+     
+   }
+#endif
+   _offset=0;
+   if(read8()!=0x82) 
+   {
+     printf("[ASF PACKET]At pos %x \n",ftello(_fd));
+     printf("[ASF PACKET]not a 82 packet\n");
+     printf("[ASF PACKET]not a 82 packet\n");
+     printf("[ASF PACKET]not a 82 packet\n");
+     return 0;
+   }
+   
+   aprintf("============== New packet ===============\n");
+   read16();          // Always 0 ????
+   flags=read8();
+   segmentId=read8();
+   packetLen=0;
+   paddingLen=0;
+   
+
+   // Read packetLen
+   packetLen=readVCL(flags>>5);
+   // Sequence len
+   sequenceLen=readVCL(flags>>1);
+   // Read padding size (padding):
+   paddingLen=readVCL(flags>>3);
+   
+   aprintf("paddingLen :         %d\n",paddingLen);
+   
+// Explicit (absolute) packet size	    
+   if(((flags>>5)&3))
+   {
+     printf("## Explicit packet size %d\n",packetLen);
+     if(packetLen>pakSize) printf("**************Len > packet size!! (%d /%d)\n",packetLen,pakSize);
+   } 
+   if(!packetLen)
+   {
+     // Padding (relative) size
+     packetLen=pakSize-_offset;
+     packetLen=packetLen-paddingLen;
+   }
+
+   
+  
+   atime=read32(); // Send time
+   aduration=read16(); // Duration
+   
+   if(flags &1) // Multiseg
+   {
+     uint8_t r=read8();
+     nbSeg=r&0x3f;
+     segType=r>>6;
+   }
+   else
+   {
+     nbSeg=1; 
+   }
+#ifdef ASF_VERBOSE   
+   printf("-----------------------\n");
+   printf("Flags     :           0X%x",flags);
+   
+   if(flags & 0x40) printf(" Packet Len Specified  ");
+   if(flags & 0x10) printf(" Padding 16bits ");
+   if(flags & 0x8) printf(" Padding 8bits ");
+   if(flags & 0x1) printf(" Multiseg ");
+   printf("\n");
+   printf("SegmentId :           %d\n",segmentId);
+   printf("sequenceLen :         %d\n",sequenceLen);
+   
+   
+   printf("packetLen :           %d\n",packetLen);
+   printf("Send      :           %d\n",atime);
+   printf("Duration  :           %d\n",aduration);
+   printf("# of seg  :           %d %x\n",nbSeg,segType);
+#endif
+   // Now read Segments....
+   //
+   uint32_t sequence, offset,replica,r;
+   int32_t remaining;
+   uint32_t payloadLen;
+   uint32_t keyframe;
+   for(int seg=0;seg<nbSeg;seg++)
+   {
+     r=read8(); // Read stream Id
+     if(r&0x80) keyframe=AVI_KEY_FRAME;
+     else       keyframe=0;
+     streamId=r&0x7f;
+     aprintf(">>>>>Stream Id : %x<<<<<\n",streamId);
+     if(r&0x80) 
+     {
+       aprintf("KeyFrame\n");
+     }
+     sequence=readVCL(segmentId>>4);
+     offset=readVCL(segmentId>>2);
+     replica=readVCL(segmentId);
+     aprintf("replica                %d\n",replica);
+     // Skip replica data_len
+     skip(replica);
+     
+     payloadLen=0;
+     if(flags &1)  // multi seg
+     {
+       payloadLen=readVCL(segType);
+       if(payloadLen)
+        aprintf("##len                    %d\n",payloadLen);
+       
+     }
+     remaining=pakSize-_offset;
+     remaining=remaining-paddingLen;
+     aprintf("Remaining %d asked %d\n",remaining,payloadLen);
+     if(remaining<=0) 
+     {
+       printf("** Err: No data left (%d)\n",remaining); 
+     }
+     if(!payloadLen)
+     {
+       payloadLen=remaining;
+     }
+     if(remaining<payloadLen)
+     {
+       printf("** WARNING too big %d %d\n", remaining,packetLen);
+       payloadLen=remaining;
+     }
+#ifdef ASF_VERBOSE     
+     printf("This segment %d bytes, %d /%d\n",packetLen,seg,nbSeg);
+     printf("Offset                 %d\n",offset);
+     printf("sequence               %d\n",sequence);
+     printf("Grouping               %d\n",replica==1);
+     printf("payloadLen             %d\n",payloadLen);
+#endif
+     // Frag
+     if(replica==1) // Grouping
+     {
+       // Each tiny packet starts with 
+       // 1 byte = packet Len
+       // Data and we read them until "payloadLen" is comsumed
+       while(payloadLen>0)
+       {
+         uint8_t l=read8();
+         payloadLen--;
+         if(l>payloadLen)
+         {
+           
+           printf("oops exceeding %d/%d\n",l,payloadLen);
+           if(streamId==streamWanted || streamWanted==0xff)
+           {
+             pushPacket(keyframe,currentPacket,offset,sequence,payloadLen,streamId);
+             
+           }else
+           {
+            skip(payloadLen);
+           }
+           break;
+         }
+         skip(l);
+         payloadLen-=l;
+       }
+       
+     }else
+     { // else we read "payloadLen" bytes and put them at offset "offset"
+       if(streamId==streamWanted|| streamWanted==0xff)
+       {
+         pushPacket(keyframe,currentPacket,offset,sequence,payloadLen,streamId);    
+       }else
+        skip(payloadLen);
+       aprintf("Reading %d bytes\n",payloadLen);
+     }
+     
+   }
+   // Do some sanity check
+   if(_offset+paddingLen!=pakSize)
+   {
+     printf("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! %d %d\n",_offset,paddingLen);
+   }
+   currentPacket++;
+   return 1;
+  
+ }
+ /*
+    Push a packet down the queue
+    The packet could be a complete one or a fragement
+    To know that, either look at the offset field which will be != for fragements
+    Or look if the sequence number is increasing
+ 
+ */
+
+ uint8_t asfPacket::pushPacket(uint32_t keyframe,uint32_t packetnb,uint32_t offset,uint32_t sequence,uint32_t payloadLen,uint32_t stream)
+ {
+   asfBit *bit=new asfBit;
+   aprintf("Pushing packet stream=%d len=%d seq=%d\n",stream,payloadLen,sequence);
+   bit->sequence=sequence;
+   bit->offset=offset;
+   bit->len=payloadLen;
+   bit->data=new uint8_t[payloadLen];
+   bit->stream=stream;
+   bit->packet=packetnb;
+   bit->flags=keyframe;
+
+   if(!read(bit->data,bit->len))
+   {
+		delete[] bit->data;
+		delete bit;
+		return 0; 
+   }
+
+   queue->push((void *)bit);
+   return 1;
+ }
+ 
+ uint32_t asfPacket::readVCL(uint32_t bitwise)
+ {
+   uint32_t r;
+   switch(bitwise&3)
+   {
+     case 3: r=read32();break;  // dword
+     case 2: r=read16();break;  // word
+     case 1: r=read8();break;   // byte
+     default: r=0;
+   }
+   return r;
+ }
+
+ uint8_t   asfPacket::skipPacket(void)
+ {
+   uint32_t go;
+   go=packetStart+ pakSize;
+   aprintf("Pos %x\n",ftello(_fd));
+   fseeko(_fd,go,SEEK_SET);
+   aprintf("Skipping to %x\n",go);
+  
+   return 1; 
+ }
+ uint8_t   asfPacket::read(uint8_t *where, uint32_t how)
+ {
+ 
+   if(1!=fread(where,how,1,_fd))
+   {
+     printf("[AsfPacket] Read error\n");
+     return 0; 
+   }
+   _offset+=how;
+   ADM_assert(_offset<=pakSize);
+
+   return 1;
+
+  
+ }
+ uint8_t   asfPacket::skip( uint32_t how)
+ {
+   fseeko(_fd,how,SEEK_CUR);
+   _offset+=how;
+   ADM_assert(_offset<=pakSize);
+
+   return 1;
+ }
+ //****************************
+ uint8_t   asfPacket::dump(void)
+ {
+  
+   return 1;
+  
+ }
+ //****************************
+ uint8_t asfPacket::purge(void)
+ {
+    // Flush queue
+   while(!queue->isEmpty())
+   {
+     asfBit *bit;
+     ADM_assert(queue->pop((void**)&bit));
+     delete[] bit->data;
+     delete bit;
+   }
+   return 1; 
+ }
+ //****************************
+ uint8_t   asfPacket::packTo(uint8_t *buffer,uint32_t *len)
+ {
+   *len=0;
+   while(!queue->isEmpty())
+   {
+     asfBit *bit;
+     ADM_assert(queue->pop((void**)&bit));
+     memcpy(buffer,bit->data,bit->len);
+     *len+=bit->len;
+     delete[] bit->data;
+     delete bit;
+   }
+   return 1;
+ }
+ 
+ 
+#ifndef ASF_INLINE
+#include "ADM_asfIo.h"
+#endif
+
+ //EOF

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asfPacket.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asfPacket.h	2009-08-12 18:12:50 UTC (rev 5241)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asfPacket.h	2009-08-14 17:29:18 UTC (rev 5242)
@@ -0,0 +1,77 @@
+
+/***************************************************************************
+    copyright            : (C) 2006 by mean
+    email                : fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+
+#ifndef ASF_PACKET_H
+#define ASF_PACKET_H
+
+#include "ADM_osSupport/ADM_queue.h"
+
+typedef struct 
+{
+  uint32_t sequence;
+  uint32_t offset;
+  uint32_t len;
+  uint32_t stream;
+  uint32_t packet;
+  uint32_t flags;
+  uint8_t  *data;
+}asfBit;
+
+class asfPacket
+{
+  protected:
+    uint32_t        readVCL(uint32_t bitwise);
+    uint8_t         pushPacket(uint32_t flags,uint32_t packetnb,
+                                uint32_t offset,uint32_t sequence,uint32_t payloadLen,uint32_t stream);
+    uint8_t         skip( uint32_t how);
+    FILE            *_fd;
+    uint32_t        packetStart;
+    uint8_t         segmentId;
+    uint32_t        pakSize;
+    ADM_queue       *queue;
+    uint32_t        _offset;
+    uint32_t        currentPacket;
+    uint32_t        _startDataOffset;
+    uint32_t        _nbPackets;
+  public:
+    
+    asfPacket(FILE *f,uint32_t nbElem,uint32_t pSize,ADM_queue *q,uint32_t startDataOffset);
+    ~asfPacket();
+    uint8_t   dump(void);
+    
+    uint8_t   goToPacket(uint32_t packet);
+  
+    uint8_t   readChunkPayload(uint8_t *data, uint32_t *dataLen);
+    uint8_t   nextPacket(uint8_t streamWanted);
+    uint8_t   skipPacket(void);
+    
+    uint32_t  getPos(void);
+    uint32_t  getPayloadLen(void);
+#ifdef ASF_INLINE
+    #include "ADM_asfIo.h"
+#else    
+    uint64_t  read64(void);
+    uint32_t  read32(void);
+    uint32_t  read16(void);
+    uint8_t   read8(void);
+#endif    
+    uint8_t   read(uint8_t *where, uint32_t how);
+    uint8_t   purge(void);
+    uint8_t   packTo(uint8_t *buffer,uint32_t *len);
+};
+
+#endif
+

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asf_audio.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asf_audio.cpp	2009-08-12 18:12:50 UTC (rev 5241)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asf_audio.cpp	2009-08-14 17:29:18 UTC (rev 5242)
@@ -0,0 +1,192 @@
+/***************************************************************************
+    copyright            : (C) 2006 by mean
+    email                : fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include "config.h"
+
+#include <stdio.h>
+#include <stdlib.h>
+
+#include <string.h>
+
+#include <math.h>
+
+#include "ADM_default.h"
+#include "ADM_editor/ADM_Video.h"
+#include "ADM_assert.h"
+
+#include "fourcc.h"
+
+
+#include "ADM_asf.h"
+
+
+/*
+    __________________________________________________________
+*/
+
+asfAudio::~asfAudio()
+{
+	printf("[asfAudio] Destroying track\n");
+
+	fclose(_fd);
+	_fd = NULL;
+
+	delete _wavheader;
+	delete _packet;
+
+	_wavheader = NULL;
+	_packet = NULL;
+}
+/*
+    __________________________________________________________
+*/
+                               
+asfAudio::asfAudio(asfHeader *father,uint32_t myRank)
+{
+  printf("[asfAudio] Creating track\n");
+    _myRank=myRank;
+    _father=father;
+    _track=&(_father->_allAudioTracks[myRank]);
+    
+    _wavheader=new WAVHeader;
+    memcpy(_wavheader,&(_track->wavHeader),sizeof(WAVHeader));
+    _extraDataLen=_track->extraDataLen;
+    _extraData= _track->extraData;
+    _length=_track->length;
+    _streamId=_track->streamIndex;
+    _dataStart=_father->_dataStartOffset;
+    _fd=fopen(_father->myName,"rb");
+    ADM_assert(_fd);
+    fseeko(_fd,_dataStart,SEEK_SET);
+    _packetSize=_father->_packetSize;
+    _packet=new asfPacket(_fd,_father->_nbPackets,_packetSize,
+                          &readQueue,_dataStart);
+    _destroyable=1;
+    printf("[asfAudio] Length %u\n",_length);
+  
+}
+/*
+    __________________________________________________________
+*/
+
+uint32_t            asfAudio::read(uint32_t len,uint8_t *buffer)
+{
+  uint32_t lan,samples;
+  if(!getPacket(      buffer,    &lan, &samples)) return 0;
+  return lan;
+}
+/*
+    __________________________________________________________
+*/
+
+uint8_t   asfAudio::goTo(uint32_t newoffset)
+{
+  // Look into the index until we find the audio
+  // just after the wanted value
+  for(int i=0;i<_father->nbImage;i++)
+  {
+    if(!_father->_index[i].audioSeen[_myRank]) continue;
+    if(_father->_index[i].audioSeen[_myRank]>=newoffset)
+    {
+      // Flush queue
+      _packet->purge();
+      // Seek
+      if(!_packet->goToPacket(_father->_index[i].packetNb))
+      {
+        printf("[asfAudio] Cannot seek to frame %u\n",i);
+        return 0; 
+      }
+      printf("[asfAudio]For audio %u, seeking to packet %u\n",newoffset,_father->_index[i].packetNb);
+      _packet->nextPacket(_streamId);
+      _packet->skipPacket();
+      return 1;
+    }
+  }
+  printf("[asfAudio] Seek failed for offset=%u\n",newoffset);
+  return 1; 
+}
+/*
+    __________________________________________________________
+*/
+
+uint8_t   asfAudio::goToTime(uint32_t newoffset)
+{
+  // Compute the linear version
+  float f;
+  uint32_t val;
+  
+  f=newoffset;
+  f*=_wavheader->byterate;
+  
+  val=(uint32_t)((f+459.)/1000.);
+  goTo(val);
+  return 1; 
+}
+/*
+    __________________________________________________________
+*/
+
+uint8_t   asfAudio::extraData(uint32_t *l,uint8_t **d)
+{
+  if(_extraData)
+  {
+    *l=_extraDataLen;
+    *d=_extraData;  
+  }
+  else
+  {
+    *l=0;
+    *d=NULL; 
+  }
+  return 1;
+}
+/*
+    __________________________________________________________
+*/
+
+uint8_t  asfAudio::getPacket(uint8_t *dest, uint32_t *len, uint32_t *samples)
+{
+  *len=0;
+  uint32_t delta;
+  uint8_t r;
+  while(1)
+  {
+   
+    while(!readQueue.isEmpty())
+    {
+      asfBit *bit;
+      ADM_assert(readQueue.pop((void**)&bit));
+      printf("Audio found packet of size %d seq %d\n",bit->len,bit->sequence);
+      
+      // still same sequence ...add
+      memcpy(dest,bit->data,bit->len);
+      *len=bit->len;
+#warning FIXME      
+      *samples=384; // ?
+	  delete[] bit->data;
+      delete bit;
+      return 1;
+    }
+    r=_packet->nextPacket(_streamId);
+    _packet->skipPacket();
+    if(!r)
+    {
+      printf("[ASF] Audio Packet Error\n");
+      return 0; 
+    }
+    _packet->skipPacket();
+  }
+  
+  return 0; 
+}
+//EOF

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/CMakeLists.txt	2009-08-12 18:12:50 UTC (rev 5241)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/CMakeLists.txt	2009-08-14 17:29:18 UTC (rev 5242)
@@ -0,0 +1,4 @@
+SET(ADM_asf_SRCS 
+	ADM_asf_audio.cpp  ADM_asfChunk.cpp  ADM_asf.cpp  ADM_asfPacket.cpp)
+
+ADD_ADM_LIB_ALL_TARGETS(ADM_asf ${ADM_asf_SRCS})
\ No newline at end of file



From mean at mail.berlios.de  Fri Aug 14 19:29:22 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Fri, 14 Aug 2009 19:29:22 +0200
Subject: [Avidemux-svn-commit] r5243 -
	branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreDemuxerMpeg/src
Message-ID: <200908141729.n7EHTMAj032668@sheep.berlios.de>

Author: mean
Date: 2009-08-14 19:29:20 +0200 (Fri, 14 Aug 2009)
New Revision: 5243

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreDemuxerMpeg/src/dmx_io.cpp
Log:
[core/demuxerMpeg] Fix build on karmic

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreDemuxerMpeg/src/dmx_io.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreDemuxerMpeg/src/dmx_io.cpp	2009-08-14 17:29:18 UTC (rev 5242)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreDemuxerMpeg/src/dmx_io.cpp	2009-08-14 17:29:20 UTC (rev 5243)
@@ -67,7 +67,7 @@
 */
 uint8_t fileParser::open( const char *filename,FP_TYPE *multi )
 {
-        char *dot = NULL;                   // pointer to the last dot in filename
+        const char *dot = NULL;                   // pointer to the last dot in filename
         uint8_t decimals = 0;               // number of decimals
         char *left = NULL, *number = NULL, *right = NULL; // parts of filename (after splitting)
 



From mean at mail.berlios.de  Fri Aug 14 19:29:30 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Fri, 14 Aug 2009 19:29:30 +0200
Subject: [Avidemux-svn-commit] r5244 - in branches/avidemux_2.6_branch_mean:
	avidemux/common/ADM_osSupport avidemux_core/ADM_core/include
	avidemux_core/ADM_core/src
Message-ID: <200908141729.n7EHTUa2000029@sheep.berlios.de>

Author: mean
Date: 2009-08-14 19:29:29 +0200 (Fri, 14 Aug 2009)
New Revision: 5244

Added:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_core/include/ADM_queue.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_core/src/ADM_queue.cpp
Removed:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_osSupport/ADM_queue.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_osSupport/ADM_queue.h
Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_osSupport/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_core/src/CMakeLists.txt
Log:
[core] Move queue to core

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_osSupport/ADM_queue.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_osSupport/ADM_queue.cpp	2009-08-14 17:29:20 UTC (rev 5243)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_osSupport/ADM_queue.cpp	2009-08-14 17:29:29 UTC (rev 5244)
@@ -1,77 +0,0 @@
-/***************************************************************************
-              
-    copyright            : (C) 2006 by mean
-    email                : fixounet at free.fr
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#include "ADM_default.h"
-#include "ADM_queue.h"
-
-ADM_queue::ADM_queue()
-{
-  head=NULL;
-  tail=NULL;
-}
-ADM_queue::~ADM_queue()
-{
-  if(head)
-  {
-    printf(">>>>>>>>Warning queue is not empty\n<<<<<<<"); 
-  }
-}
-uint8_t ADM_queue::isEmpty(void)
-{
-  if(head) return 0;
-  ADM_assert(!tail);
-  return 1; 
-}
-uint8_t ADM_queue::push(void *data)
-{
-  queueElem *elem=new queueElem;
-  
-  elem->next=NULL;
-  elem->data=data;
-  if(!head)
-  {
-    head=tail=elem; 
-    return 1;
-  }
-  ADM_assert(tail);
-  tail->next=elem;
-  tail=elem;
-  return 1;
-}
-uint8_t ADM_queue::pushBack(void *data)
-{
-  queueElem *elem=new queueElem;
-
-  elem->next=head;
-  elem->data=data;
-  if(!head) tail=elem;
-  head=elem;
-  return 1;
-}
-uint8_t ADM_queue::pop(void **data)
-{
-  ADM_assert(head);
-  *data=NULL;
-  if(isEmpty()) return 0;
-  *data=head->data;
-  queueElem *tmp=head;
-  head=head->next;
-  if(!head)
-  {
-    head=tail=NULL; 
-  }
-  delete tmp;
-  return 1;
-}
-//EOF 

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_osSupport/ADM_queue.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_osSupport/ADM_queue.h	2009-08-14 17:29:20 UTC (rev 5243)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_osSupport/ADM_queue.h	2009-08-14 17:29:29 UTC (rev 5244)
@@ -1,41 +0,0 @@
-/***************************************************************************
-              
-    copyright            : (C) 2006 by mean
-    email                : fixounet at free.fr
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#ifndef ADM_QUEUE_H
-#define ADM_QUEUE_H
-
-typedef struct queueElem
-{
-  queueElem   *next;
-  void        *data;
-}queueElem;
-
-class ADM_queue
-{
-  protected:
-    queueElem *head;
-    queueElem *tail;
-  public:
-            ADM_queue();
-            ~ADM_queue();
-    uint8_t isEmpty(void);
-    uint8_t push(void *data);
-    uint8_t pushBack(void *data);
-    uint8_t pop(void **data);
-  
-};
-
-
-
-#endif

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_osSupport/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_osSupport/CMakeLists.txt	2009-08-14 17:29:20 UTC (rev 5243)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_osSupport/CMakeLists.txt	2009-08-14 17:29:29 UTC (rev 5244)
@@ -1,7 +1,6 @@
 SET(ADM_osSupport_SRCS 
 ADM_crashHook.cpp 
 ADM_misc.cpp 
-ADM_queue.cpp 
 )
 
 ADD_LIBRARY(ADM_osSupport6 STATIC ${ADM_osSupport_SRCS})

Copied: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_core/include/ADM_queue.h (from rev 5243, branches/avidemux_2.6_branch_mean/avidemux/common/ADM_osSupport/ADM_queue.h)
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_osSupport/ADM_queue.h	2009-08-14 17:29:20 UTC (rev 5243)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_core/include/ADM_queue.h	2009-08-14 17:29:29 UTC (rev 5244)
@@ -0,0 +1,41 @@
+/***************************************************************************
+              
+    copyright            : (C) 2006 by mean
+    email                : fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#ifndef ADM_QUEUE_H
+#define ADM_QUEUE_H
+
+typedef struct queueElem
+{
+  queueElem   *next;
+  void        *data;
+}queueElem;
+
+class ADM_queue
+{
+  protected:
+    queueElem *head;
+    queueElem *tail;
+  public:
+            ADM_queue();
+            ~ADM_queue();
+    uint8_t isEmpty(void);
+    uint8_t push(void *data);
+    uint8_t pushBack(void *data);
+    uint8_t pop(void **data);
+  
+};
+
+
+
+#endif

Copied: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_core/src/ADM_queue.cpp (from rev 5243, branches/avidemux_2.6_branch_mean/avidemux/common/ADM_osSupport/ADM_queue.cpp)
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_osSupport/ADM_queue.cpp	2009-08-14 17:29:20 UTC (rev 5243)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_core/src/ADM_queue.cpp	2009-08-14 17:29:29 UTC (rev 5244)
@@ -0,0 +1,77 @@
+/***************************************************************************
+              
+    copyright            : (C) 2006 by mean
+    email                : fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include "ADM_default.h"
+#include "ADM_queue.h"
+
+ADM_queue::ADM_queue()
+{
+  head=NULL;
+  tail=NULL;
+}
+ADM_queue::~ADM_queue()
+{
+  if(head)
+  {
+    printf(">>>>>>>>Warning queue is not empty\n<<<<<<<"); 
+  }
+}
+uint8_t ADM_queue::isEmpty(void)
+{
+  if(head) return 0;
+  ADM_assert(!tail);
+  return 1; 
+}
+uint8_t ADM_queue::push(void *data)
+{
+  queueElem *elem=new queueElem;
+  
+  elem->next=NULL;
+  elem->data=data;
+  if(!head)
+  {
+    head=tail=elem; 
+    return 1;
+  }
+  ADM_assert(tail);
+  tail->next=elem;
+  tail=elem;
+  return 1;
+}
+uint8_t ADM_queue::pushBack(void *data)
+{
+  queueElem *elem=new queueElem;
+
+  elem->next=head;
+  elem->data=data;
+  if(!head) tail=elem;
+  head=elem;
+  return 1;
+}
+uint8_t ADM_queue::pop(void **data)
+{
+  ADM_assert(head);
+  *data=NULL;
+  if(isEmpty()) return 0;
+  *data=head->data;
+  queueElem *tmp=head;
+  head=head->next;
+  if(!head)
+  {
+    head=tail=NULL; 
+  }
+  delete tmp;
+  return 1;
+}
+//EOF 

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_core/src/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_core/src/CMakeLists.txt	2009-08-14 17:29:20 UTC (rev 5243)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_core/src/CMakeLists.txt	2009-08-14 17:29:29 UTC (rev 5244)
@@ -2,6 +2,7 @@
 	ADM_cpuCap.cpp  ADM_memcpy.cpp  ADM_memsupport.cpp  ADM_threads.cpp  ADM_win32.cpp
 	ADM_memory.cpp  ADM_misc.cpp  TLK_clock.cpp  ADM_crashdump.cpp  ADM_fileio.cpp ADM_dynamicLoading.cpp
         ADM_debug.cpp 
+        ADM_queue.cpp
 )
 
 ADD_LIBRARY(ADM_core6 SHARED ${ADM_core_SRCS})



From mean at mail.berlios.de  Fri Aug 14 19:29:32 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Fri, 14 Aug 2009 19:29:32 +0200
Subject: [Avidemux-svn-commit] r5245 - in
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers:
	. Asf
Message-ID: <200908141729.n7EHTWZY000116@sheep.berlios.de>

Author: mean
Date: 2009-08-14 19:29:31 +0200 (Fri, 14 Aug 2009)
New Revision: 5245

Added:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asfAudio.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asfPlugin.cpp
Removed:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asf_audio.cpp
Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asf.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asf.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asfChunk.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asfPacket.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asfPacket.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/CMakeLists.txt
Log:
[Demuxer] Skeleton for asf/wmv demuxer (not complete)

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asf.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asf.cpp	2009-08-14 17:29:29 UTC (rev 5244)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asf.cpp	2009-08-14 17:29:31 UTC (rev 5245)
@@ -1,5 +1,7 @@
-/***************************************************************************
-    copyright            : (C) 2006 by mean
+/** *************************************************************************
+    \file ADM_asf.cpp
+    \brief ASF/WMV demuxer
+    copyright            : (C) 2006/2009 by mean
     email                : fixounet at free.fr
  ***************************************************************************/
 
@@ -11,56 +13,90 @@
  *   (at your option) any later version.                                   *
  *                                                                         *
  ***************************************************************************/
-#include "config.h"
 
-#include <math.h>
-
 #include "ADM_default.h"
-#include "ADM_editor/ADM_Video.h"
+#include "ADM_Video.h"
 #include "ADM_assert.h"
 
 #include "fourcc.h"
 #include "DIA_coreToolkit.h"
-//#include "DIA_working.h"
 #include "ADM_asf.h"
 #include "ADM_asfPacket.h"
 
-#include "ADM_osSupport/ADM_debugID.h"
-#define MODULE_NAME MODULE_ASF
-#include "ADM_osSupport/ADM_debug.h"
+#if 1
+#define aprintf printf
+#else
+#define aprintf(...) {}
+#endif
 
 static const uint8_t asf_audio[16]={0x40,0x9e,0x69,0xf8,0x4d,0x5b,0xcf,0x11,0xa8,0xfd,0x00,0x80,0x5f,0x5c,0x44,0x2b};
 static const uint8_t asf_video[16]={0xc0,0xef,0x19,0xbc,0x4d,0x5b,0xcf,0x11,0xa8,0xfd,0x00,0x80,0x5f,0x5c,0x44,0x2b};
 
-
-WAVHeader *asfHeader::getAudioInfo(void )
+/**
+    \fn getAudioInfo
+*/
+WAVHeader *asfHeader::getAudioInfo(uint32_t i )
 {
-  if(!_curAudio) return NULL;
-  return _curAudio->getInfo();
+  if(!_nbAudioTrack) return NULL;
+  
+  ADM_assert(i<_nbAudioTrack);
+  if(!_audioAccess) return NULL;
+  return &(_allAudioTracks[i].wavHeader);
 }
-/*
-    __________________________________________________________
+/**
+    \fn getAudioStream
 */
-
-uint8_t asfHeader::getAudioStream(AVDMGenericAudioStream **audio)
+uint8_t    asfHeader::getAudioStream(uint32_t i,ADM_audioStream  **audio)
 {
- 
-  *audio=_curAudio;
-  return 1; 
+ *audio=NULL;
+  if(!_nbAudioTrack) return true;
+  ADM_assert(i<_nbAudioTrack); 
+  *audio=_audioStreams[i];
+ return 1; 
 }
-/*
-    __________________________________________________________
+/**
+    \fn getNbAudioStreams
 */
+uint8_t                 asfHeader::getNbAudioStreams(void)
+{
+    return _nbAudioTrack;
+}
 
+/**
+    \fn Dump
+*/
+
 void asfHeader::Dump(void)
 {
  
   printf("*********** ASF INFO***********\n");
 }
-/*
-    __________________________________________________________
+/**
+    \fn getTime
 */
+uint64_t                   asfHeader::getTime(uint32_t frameNum)
+{
+    return 0;
+}
 
+uint64_t                   asfHeader::getVideoDuration(void)
+{
+    return 0;
+}
+bool                       asfHeader::getPtsDts(uint32_t frame,uint64_t *pts,uint64_t *dts)
+{
+    *pts=ADM_NO_PTS;
+    *dts=ADM_NO_PTS;
+    return true;
+}
+bool                       asfHeader::setPtsDts(uint32_t frame,uint64_t pts,uint64_t dts)
+{
+    return true;
+}
+/**
+    \fn close
+*/
+
 uint8_t asfHeader::close(void)
 {
 	if (_fd) 
@@ -97,48 +133,43 @@
     asfAudioTrak *trk=&(_allAudioTracks[i]);
     if(trk->extraData) delete [] trk->extraData;
     trk->extraData=NULL;
+    delete    _audioAccess[i];
+    _audioAccess[i]=NULL;
+    delete _audioStreams[i];
+    _audioStreams[i]=NULL;    
   }
 }
-uint8_t       asfHeader::getExtraHeaderData(uint32_t *len, uint8_t **data)
-{
-  *len=_extraDataLen;
-  *data=_extraData;
-  return 1; 
-}
-/*
-    __________________________________________________________
+/**
+    \fn asfHeader
 */
 
+
  asfHeader::asfHeader( void ) : vidHeader()
 {
   _fd=NULL;
   _videoIndex=-1;
   myName=NULL;
-  _extraDataLen=0;
-  _extraData=NULL;
   _packetSize=0;
   _videoStreamId=0;
   nbImage=0;
   _index=NULL;
   _packet=NULL;
-  _curAudio=NULL;
   _nbPackets=0;
-  printf("%u\n",sizeof(_allAudioTracks));
+//  printf("%u\n",sizeof(_allAudioTracks));
   memset(&(_allAudioTracks[0]),0,sizeof(_allAudioTracks));
+  _nbAudioTrack=0;
 
-  _nbAudioTrack=0;
-  _currentAudioStream=0;
 }
-/*
-    __________________________________________________________
+/**
+    \fn ~ asfHeader
 */
 
  asfHeader::~asfHeader(  )
 {
   close();
 }
-/*
-    __________________________________________________________
+/**
+    \fn open
 */
 
 uint8_t asfHeader::open(const char *name)
@@ -158,29 +189,25 @@
   fseeko(_fd,_dataStartOffset,SEEK_SET);
   _packet=new asfPacket(_fd,_nbPackets,_packetSize,&readQueue,_dataStartOffset);
   curSeq=1;
-  if(_nbAudioTrack)
+  for(int i=0;i<_nbAudioTrack;i++)
   {
-    _curAudio=new asfAudio(this,_currentAudioStream);
+        _audioAccess[i]=new asfAudioAccess(this,i);
+        _audioStreams[i]=ADM_audioCreateStream(&(_allAudioTracks[i].wavHeader), _audioAccess[i]);
   }
   return 1;
 }
-/*
-    __________________________________________________________
+/**
+    \fn setFlag
 */
 
- 
-/*
-    __________________________________________________________
-*/
-
   uint8_t  asfHeader::setFlag(uint32_t frame,uint32_t flags)
 {
   ADM_assert(frame<nbImage);
   _index[frame].flags=flags;
   return 1; 
 }
-/*
-    __________________________________________________________
+/**
+    \fn getFlags
 */
 
 uint32_t asfHeader::getFlags(uint32_t frame,uint32_t *flags)
@@ -191,12 +218,21 @@
       *flags=_index[frame].flags;
   return 1; 
 }
-/*
-    __________________________________________________________
-*/
-
-uint8_t  asfHeader::getFrameNoAlloc(uint32_t framenum,ADMCompressedImage *img)
+/**
+    \fn getFrameSize
+*/ 
+uint8_t     asfHeader::getFrameSize(uint32_t frame,uint32_t *size)
 {
+    *size=0;
+    if(frame>=nbImage) return 0;
+    *size=_index[frame].frameLen;
+    return true;
+}
+/**
+    \fn getFrame
+*/    
+uint8_t  asfHeader::getFrame(uint32_t framenum,ADMCompressedImage *img)
+{
   img->dataLength=0;
   img->flags=AVI_KEY_FRAME;
   if(framenum>=nbImage)
@@ -457,12 +493,12 @@
         printf("\nConceal       :");
         for(int z=0;z<16;z++) printf(":%02x",s->read8());
         printf("\n");
-        printf("Reserved    : %08x\n",s->read64());
-        printf("Total Size  : %04x\n",s->read32());
-        printf("Size        : %04x\n",s->read32());
+        printf("Reserved    : %08"LLX"\n",s->read64());
+        printf("Total Size  : %04"LX"\n",s->read32());
+        printf("Size        : %04"LX"\n",s->read32());
         sid=s->read16();
-        printf("Stream nb   : %04x\n",sid);
-        printf("Reserved    : %04x\n",s->read32());
+        printf("Stream nb   : %04d\n",sid);
+        printf("Reserved    : %04"LX"\n",s->read32());
         switch(audiovideo)
         {
           case 1: // Video
@@ -516,29 +552,10 @@
   printf("End of headers\n");
   return 1;
 }
-uint8_t    asfHeader::changeAudioStream(uint32_t newstream)
-{
-  ADM_assert(_currentAudioStream<_nbAudioTrack);
-  _currentAudioStream=newstream;
-  return 1;
-}
-uint32_t    asfHeader::getCurrentAudioStreamNumber(void)
-{
-  return _currentAudioStream;
-}
-uint8_t     asfHeader::getAudioStreamsInfo(uint32_t *nbStreams, audioInfo **infos)
-{
-    *nbStreams=_nbAudioTrack;
-    if(_nbAudioTrack)
-    {
-      *infos=new audioInfo[_nbAudioTrack];
-      for(int i=0;i<_nbAudioTrack;i++)
-      {
-        WAV2AudioInfo(&(_allAudioTracks[i].wavHeader),&((*infos)[i]));
-      }
-    }
-    return 1;
-}
+/**
+    \fn loadVideo
+*/
+
 uint8_t asfHeader::loadVideo(asfChunk *s)
 {
   uint32_t w,h,x;
@@ -555,7 +572,7 @@
             _video_bih.biHeight=h;
             printf("Pic Width  %04d\n",w);
             printf("Pic Height %04d\n",h);
-            printf(" BMP size  %04d (%04d)\n",x,sizeof(ADM_BITMAPINFOHEADER));
+            printf(" BMP size  %04d (%04d)\n",x,(int)sizeof(ADM_BITMAPINFOHEADER));
             s->read((uint8_t *)&_video_bih,sizeof(ADM_BITMAPINFOHEADER));
 
 		#ifdef ADM_BIG_ENDIAN

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asf.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asf.h	2009-08-14 17:29:29 UTC (rev 5244)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asf.h	2009-08-14 17:29:31 UTC (rev 5245)
@@ -2,7 +2,7 @@
                           ADM_pics.h  -  description
                              -------------------
     begin                : Mon Jun 3 2002
-    copyright            : (C) 2002 by mean
+    copyright            : (C) 2002/2009 by mean
     email                : fixounet at free.fr
  ***************************************************************************/
 
@@ -15,15 +15,11 @@
  *                                                                         *
  ***************************************************************************/
  
-
-
 #ifndef ADM_ASF_H
 #define ADM_ASF_H
 
-#include "ADM_editor/ADM_Video.h"
-#include "ADM_audio/aviaudio.hxx"
-
-#include "ADM_osSupport/ADM_queue.h"
+#include "ADM_Video.h"
+#include "ADM_queue.h"
 #include "ADM_asfPacket.h"
 
 #define ASF_MAX_AUDIO_TRACK 8
@@ -51,6 +47,7 @@
   ADM_CHUNK_EXTENDED_STREAM_PROP,
   ADM_CHUNK_UNKNOWN_CHUNK
 }ADM_KNOWN_CHUNK;
+
 typedef struct 
 {
   const char *name;
@@ -58,6 +55,7 @@
   uint8_t val[16];
   ADM_KNOWN_CHUNK id; 
 }chunky;
+
 class asfChunk
 {
   protected:
@@ -92,15 +90,16 @@
   uint32_t     nbPackets;
   uint32_t     length;
   WAVHeader    wavHeader;
-  
 }asfAudioTrak;
 
-class asfAudio : public AVDMGenericAudioStream
+/**
+    \class asfAudioAccess
+    \brief Audio access class for asf/wmv
+*/
+class asfAudioAccess : public ADM_audioAccess
 {
   protected:
     uint32_t                _myRank;
-    uint32_t                _extraDataLen;
-    uint8_t                 *_extraData;
     char                    *myName;
     uint32_t                _streamId;
     uint32_t                _dataStart;
@@ -111,17 +110,31 @@
     class asfHeader         *_father;
     asfAudioTrak            *_track;
   public:
-                                asfAudio(asfHeader *father,uint32_t rank);
-    virtual                     ~asfAudio();
-    virtual uint32_t            read(uint32_t len,uint8_t *buffer);
-    virtual uint8_t             goTo(uint32_t newoffset);
-    virtual uint8_t             getPacket(uint8_t *dest, uint32_t *len, uint32_t *samples);
-    virtual uint8_t             goToTime(uint32_t mstime);
-    virtual uint8_t             extraData(uint32_t *l,uint8_t **d);
+                                asfAudioAccess(asfHeader *father,uint32_t rank);
+    virtual                     ~asfAudioAccess();
+
+    virtual bool      canSeekTime(void) {return true;};
+    virtual bool      canSeekOffset(void) {return true;};
+    virtual bool      canGetDuration(void) {return true;};
+    
+    virtual uint32_t  getLength(void) {return _track->length;}
+    virtual bool      goToTime(uint64_t timeUs) ;
+    virtual bool      isCBR(void) {return true;};
+    
+    
+    virtual uint64_t  getPos(void);
+    virtual bool      setPos(uint64_t pos);
+    virtual uint64_t  getDurationInUs(void) ;
+
+    virtual bool   getPacket(uint8_t *buffer, uint32_t *size, uint32_t maxSize,uint64_t *dts);
+    
 };
 
+/**
+    \class asfHeader
+    \brief Asf Demuxer
+*/  
 
-
 class asfHeader         :public vidHeader
 {
   protected:
@@ -132,7 +145,7 @@
     ADM_queue               readQueue;
     uint32_t                curSeq;
     asfPacket               *_packet;
-    uint32_t                _currentAudioStream;
+    //uint32_t                _currentAudioStream;
     uint64_t                _duration;  // Duration 100 ns
   protected:
                                 
@@ -144,6 +157,9 @@
     
     
     uint32_t                _videoStreamId;
+
+    uint8_t                 close(void);
+
     
   public: // Shared with audio track
     char                    *myName;
@@ -153,47 +169,43 @@
     uint32_t                _packetSize;
     uint32_t                _dataStartOffset;
     uint32_t                _nbAudioTrack;
-    asfAudio                *_curAudio;
+    asfAudioAccess          *_audioAccess[ASF_MAX_AUDIO_TRACK];
     asfAudioTrak             _allAudioTracks[ASF_MAX_AUDIO_TRACK];
+    ADM_audioStream         *_audioStreams[ASF_MAX_AUDIO_TRACK];
     uint32_t                 _nbPackets;
     
     // / Shared
   public:
+                                        asfHeader(void);
+   virtual                              ~asfHeader();
+                uint8_t                 open(const char *name);
+      //__________________________
+      //				 Audio
+      //__________________________
 
+    virtual 	WAVHeader              *getAudioInfo(uint32_t i )  ;
+    virtual 	uint8_t                 getAudioStream(uint32_t i,ADM_audioStream  **audio);
+    virtual     uint8_t                 getNbAudioStreams(void);
+    // Frames
+      //__________________________
+      //				 video
+      //__________________________
 
-    virtual   void          Dump(void);
-    virtual   uint8_t       getExtraHeaderData(uint32_t *len, uint8_t **data);
-             asfHeader( void );
-    virtual  ~asfHeader(  ) ;
-// AVI io
-    virtual uint8_t  open(const char *name);
-    virtual uint8_t  close(void) ;
-  //__________________________
-  //  Info
-  //__________________________
+    virtual 	uint8_t                 setFlag(uint32_t frame,uint32_t flags);
+    virtual 	uint32_t                getFlags(uint32_t frame,uint32_t *flags);			
+    virtual 	uint8_t                 getFrameSize(uint32_t frame,uint32_t *size);
+    virtual 	uint8_t                 getFrame(uint32_t framenum,ADMCompressedImage *img);
 
-  //__________________________
-  //  Audio
-  //__________________________
+    virtual   void                       Dump(void);
+    virtual   uint64_t                   getTime(uint32_t frameNum);
+    virtual   uint64_t                   getVideoDuration(void);
 
-    virtual   WAVHeader *getAudioInfo(void ) ;
-    virtual uint8_t getAudioStream(AVDMGenericAudioStream **audio);
-
-
-// Frames
-  //__________________________
-  //  video
-  //__________________________
-
-    virtual uint8_t  setFlag(uint32_t frame,uint32_t flags);
-    virtual uint32_t getFlags(uint32_t frame,uint32_t *flags);
-    virtual uint8_t  getFrameNoAlloc(uint32_t framenum,ADMCompressedImage *img)	;
+    // Return true if the container provides pts informations
+    virtual   bool                       providePts(void) {return false;};
     //
-    //  Multiple audio channels
-    //
-    uint8_t           changeAudioStream(uint32_t newstream);
-    uint32_t          getCurrentAudioStreamNumber(void) ;
-    uint8_t           getAudioStreamsInfo(uint32_t *nbStreams, audioInfo **infos);
+    virtual   bool                       getPtsDts(uint32_t frame,uint64_t *pts,uint64_t *dts);
+    virtual   bool                       setPtsDts(uint32_t frame,uint64_t pts,uint64_t dts);
+ 
 
 };
 #endif

Copied: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asfAudio.cpp (from rev 5244, branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asf_audio.cpp)
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asf_audio.cpp	2009-08-14 17:29:29 UTC (rev 5244)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asfAudio.cpp	2009-08-14 17:29:31 UTC (rev 5245)
@@ -0,0 +1,163 @@
+/***************************************************************************
+    copyright            : (C) 2006 by mean
+    email                : fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+
+#include "ADM_default.h"
+#include "ADM_Video.h"
+
+#include "fourcc.h"
+#include "ADM_asf.h"
+/**
+    \fn getDurationInUs
+*/
+uint64_t  asfAudioAccess::getDurationInUs(void)
+{
+    return 0;
+}
+/**
+    \fn asfAudioAccess
+*/
+
+asfAudioAccess::~asfAudioAccess()
+{
+	printf("[asfAudio] Destroying track\n");
+
+	fclose(_fd);
+	_fd = NULL;
+
+
+	delete _packet;
+
+
+	_packet = NULL;
+}
+
+/**
+    \fn asfAudioAccess
+*/
+                               
+asfAudioAccess::asfAudioAccess(asfHeader *father,uint32_t myRank)
+{
+  printf("[asfAudio] Creating track\n");
+    _myRank=myRank;
+    _father=father;
+    _track=&(_father->_allAudioTracks[myRank]);
+    extraDataLen=_track->extraDataLen;
+    extraData= _track->extraData;
+    _streamId=_track->streamIndex;
+    _dataStart=_father->_dataStartOffset;
+    _fd=fopen(_father->myName,"rb");
+    ADM_assert(_fd);
+    fseeko(_fd,_dataStart,SEEK_SET);
+    _packetSize=_father->_packetSize;
+    _packet=new asfPacket(_fd,_father->_nbPackets,_packetSize,
+                          &readQueue,_dataStart);
+    
+    printf("[asfAudio] Length %u\n",getLength());
+  
+}
+
+uint64_t  asfAudioAccess::getPos(void)
+{
+    return 0;
+}
+
+/**
+    \fn setPos
+*/
+
+bool   asfAudioAccess::setPos(uint64_t newoffset)
+{
+  // Look into the index until we find the audio
+  // just after the wanted value
+  for(int i=0;i<_father->nbImage;i++)
+  {
+    if(!_father->_index[i].audioSeen[_myRank]) continue;
+    if(_father->_index[i].audioSeen[_myRank]>=newoffset)
+    {
+      // Flush queue
+      _packet->purge();
+      // Seek
+      if(!_packet->goToPacket(_father->_index[i].packetNb))
+      {
+        printf("[asfAudio] Cannot seek to frame %u\n",i);
+        return 0; 
+      }
+      printf("[asfAudio]For audio %"LLU", seeking to packet %"LU"\n",newoffset,_father->_index[i].packetNb);
+      _packet->nextPacket(_streamId);
+      _packet->skipPacket();
+      return 1;
+    }
+  }
+  printf("[asfAudio] Seek failed for offset=%"LLU"\n",newoffset);
+  return 1; 
+}
+
+/**
+    \fn goToTime
+*/
+
+bool   asfAudioAccess::goToTime(uint64_t dts_us)
+{
+  // Compute the linear version
+  float f;
+  uint32_t val;
+  
+  f=dts_us;
+  f/=1000;
+  f*=_track->wavHeader.byterate;
+  
+  val=(uint32_t)((f+459.)/1000.);
+  return setPos(val);
+}
+
+/**
+    \fn getPacket
+
+*/
+bool  asfAudioAccess::getPacket(uint8_t *dest, uint32_t *len, uint32_t maxSize,uint64_t *dts)
+{
+  *len=0;
+  uint32_t delta;
+  uint8_t r;
+  while(1)
+  {
+   
+    while(!readQueue.isEmpty())
+    {
+      asfBit *bit;
+      ADM_assert(readQueue.pop((void**)&bit));
+      printf("Audio found packet of size %d seq %d\n",bit->len,bit->sequence);
+      
+      // still same sequence ...add
+      memcpy(dest,bit->data,bit->len);
+      *len=bit->len;
+      *dts=ADM_NO_PTS;
+	  delete[] bit->data;
+      delete bit;
+      return 1;
+    }
+    r=_packet->nextPacket(_streamId);
+    _packet->skipPacket();
+    if(!r)
+    {
+      printf("[ASF] Audio Packet Error\n");
+      return 0; 
+    }
+    _packet->skipPacket();
+  }
+  
+  return 0; 
+}
+//EOF

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asfChunk.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asfChunk.cpp	2009-08-14 17:29:29 UTC (rev 5244)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asfChunk.cpp	2009-08-14 17:29:31 UTC (rev 5245)
@@ -11,17 +11,9 @@
  *   (at your option) any later version.                                   *
  *                                                                         *
  ***************************************************************************/
-#include "config.h"
 
-#include <stdio.h>
-#include <stdlib.h>
-
-#include <string.h>
-
-#include <math.h>
-
 #include "ADM_default.h"
-#include "ADM_editor/ADM_Video.h"
+#include "ADM_Video.h"
 #include "ADM_assert.h"
 
 #include "fourcc.h"
@@ -119,7 +111,7 @@
   chunkLen<<=32;
   chunkLen+=low;
   
-  printf("Next chunk from %x +%u to %x\n",_chunkStart,chunkLen,chunkLen+_chunkStart);
+  printf("Next chunk from %"LLX" +%"LX" to %"LLX"\n",_chunkStart,chunkLen,chunkLen+_chunkStart);
   
   return 1;
   
@@ -128,9 +120,9 @@
 {
   uint32_t go;
   go=_chunkStart+ chunkLen;
-  printf("Pos %x\n",ftello(_fd));
+  printf("Pos 0x%"LLX"\n",ftello(_fd));
   fseeko(_fd,go,SEEK_SET);
-  printf("Skipping to %x\n",go);
+  printf("Skipping to 0x%"LX"\n",go);
   
   return 1; 
 }
@@ -187,8 +179,8 @@
   const chunky *id;
   id=chunkId();
   printf("Chunk type  : <<<<%s>>>>\n",id->name);
-  printf("Chunk Start : %x\n",_chunkStart);
-  printf("Chunk Len   : %lu\n",(uint32_t)chunkLen);
+  printf("Chunk Start : %"LX"\n",_chunkStart);
+  printf("Chunk Len   : %"LU"\n",(uint32_t)chunkLen);
   for(int i=0;i<16;i++) printf("%02x ",guId[i]);
   printf("\n");
   return 1;

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asfPacket.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asfPacket.cpp	2009-08-14 17:29:29 UTC (rev 5244)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asfPacket.cpp	2009-08-14 17:29:31 UTC (rev 5245)
@@ -1,5 +1,6 @@
-/***************************************************************************
-    copyright            : (C) 2006 by mean
+/** *************************************************************************
+    \file ADM_asfPacket.cpp
+    copyright            : (C) 2006/2009 by mean
     email                : fixounet at free.fr
  ***************************************************************************/
 
@@ -11,27 +12,23 @@
  *   (at your option) any later version.                                   *
  *                                                                         *
  ***************************************************************************/
-#include "config.h"
 
-#include <stdio.h>
-#include <stdlib.h>
 
-#include <string.h>
 
+#include "ADM_default.h"
 #include <math.h>
+#include "ADM_Video.h"
 
-#include "ADM_default.h"
-#include "ADM_editor/ADM_Video.h"
-#include "ADM_assert.h"
-
 #include "fourcc.h"
 
 
 #include "ADM_asfPacket.h"
 
-#include "ADM_osSupport/ADM_debugID.h"
-#define MODULE_NAME MODULE_ASF
-#include "ADM_osSupport/ADM_debug.h"
+#if 1
+#define aprintf printf
+#else
+#define aprintf(...) {}
+#endif
 
  
 asfPacket::asfPacket(FILE *f,uint32_t nb,uint32_t pSize,ADM_queue *q,uint32_t startDataOffset)
@@ -113,7 +110,7 @@
    _offset=0;
    if(read8()!=0x82) 
    {
-     printf("[ASF PACKET]At pos %x \n",ftello(_fd));
+     printf("[ASF PACKET]At pos 0x%"LLX" \n",(uint64_t)ftello(_fd));
      printf("[ASF PACKET]not a 82 packet\n");
      printf("[ASF PACKET]not a 82 packet\n");
      printf("[ASF PACKET]not a 82 packet\n");
@@ -334,7 +331,7 @@
  {
    uint32_t go;
    go=packetStart+ pakSize;
-   aprintf("Pos %x\n",ftello(_fd));
+   aprintf("Pos 0x%"LLX"\n",(uint64_t)ftello(_fd));
    fseeko(_fd,go,SEEK_SET);
    aprintf("Skipping to %x\n",go);
   

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asfPacket.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asfPacket.h	2009-08-14 17:29:29 UTC (rev 5244)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asfPacket.h	2009-08-14 17:29:31 UTC (rev 5245)
@@ -17,7 +17,7 @@
 #ifndef ASF_PACKET_H
 #define ASF_PACKET_H
 
-#include "ADM_osSupport/ADM_queue.h"
+#include "ADM_queue.h"
 
 typedef struct 
 {

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asfPlugin.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asfPlugin.cpp	2009-08-14 17:29:29 UTC (rev 5244)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asfPlugin.cpp	2009-08-14 17:29:31 UTC (rev 5245)
@@ -0,0 +1,41 @@
+/***************************************************************************
+    copyright            : (C) 2007 by mean
+    email                : fixounet at free.fr
+    
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include "ADM_default.h"
+#include "ADM_asf.h"
+#include "ADM_demuxerInternal.h"
+#include "fourcc.h"
+
+ADM_DEMUXER_BEGIN( asfHeader,
+                    1,0,0,
+                    "asf",
+                    "asf/wmv demuxer plugin (c) Mean 2007/2009"
+                );
+
+/**
+    \fn Probe
+*/
+
+extern "C"  uint32_t         probe(uint32_t magic, const char *fileName)
+{
+        const uint8_t signature[4]={ 0x30,0x26,0xb2,0x75}; //0x75,0xb2,0x26,0x30}; 
+
+    if (fourCC::check (magic, signature))
+    {
+	  printf (" [asfHeader] FLV file detected...\n");
+	  return 100;
+    }
+    printf (" [asfHeader] Cannot open that\n");
+    return 0;
+}

Deleted: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asf_audio.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asf_audio.cpp	2009-08-14 17:29:29 UTC (rev 5244)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asf_audio.cpp	2009-08-14 17:29:31 UTC (rev 5245)
@@ -1,192 +0,0 @@
-/***************************************************************************
-    copyright            : (C) 2006 by mean
-    email                : fixounet at free.fr
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#include "config.h"
-
-#include <stdio.h>
-#include <stdlib.h>
-
-#include <string.h>
-
-#include <math.h>
-
-#include "ADM_default.h"
-#include "ADM_editor/ADM_Video.h"
-#include "ADM_assert.h"
-
-#include "fourcc.h"
-
-
-#include "ADM_asf.h"
-
-
-/*
-    __________________________________________________________
-*/
-
-asfAudio::~asfAudio()
-{
-	printf("[asfAudio] Destroying track\n");
-
-	fclose(_fd);
-	_fd = NULL;
-
-	delete _wavheader;
-	delete _packet;
-
-	_wavheader = NULL;
-	_packet = NULL;
-}
-/*
-    __________________________________________________________
-*/
-                               
-asfAudio::asfAudio(asfHeader *father,uint32_t myRank)
-{
-  printf("[asfAudio] Creating track\n");
-    _myRank=myRank;
-    _father=father;
-    _track=&(_father->_allAudioTracks[myRank]);
-    
-    _wavheader=new WAVHeader;
-    memcpy(_wavheader,&(_track->wavHeader),sizeof(WAVHeader));
-    _extraDataLen=_track->extraDataLen;
-    _extraData= _track->extraData;
-    _length=_track->length;
-    _streamId=_track->streamIndex;
-    _dataStart=_father->_dataStartOffset;
-    _fd=fopen(_father->myName,"rb");
-    ADM_assert(_fd);
-    fseeko(_fd,_dataStart,SEEK_SET);
-    _packetSize=_father->_packetSize;
-    _packet=new asfPacket(_fd,_father->_nbPackets,_packetSize,
-                          &readQueue,_dataStart);
-    _destroyable=1;
-    printf("[asfAudio] Length %u\n",_length);
-  
-}
-/*
-    __________________________________________________________
-*/
-
-uint32_t            asfAudio::read(uint32_t len,uint8_t *buffer)
-{
-  uint32_t lan,samples;
-  if(!getPacket(      buffer,    &lan, &samples)) return 0;
-  return lan;
-}
-/*
-    __________________________________________________________
-*/
-
-uint8_t   asfAudio::goTo(uint32_t newoffset)
-{
-  // Look into the index until we find the audio
-  // just after the wanted value
-  for(int i=0;i<_father->nbImage;i++)
-  {
-    if(!_father->_index[i].audioSeen[_myRank]) continue;
-    if(_father->_index[i].audioSeen[_myRank]>=newoffset)
-    {
-      // Flush queue
-      _packet->purge();
-      // Seek
-      if(!_packet->goToPacket(_father->_index[i].packetNb))
-      {
-        printf("[asfAudio] Cannot seek to frame %u\n",i);
-        return 0; 
-      }
-      printf("[asfAudio]For audio %u, seeking to packet %u\n",newoffset,_father->_index[i].packetNb);
-      _packet->nextPacket(_streamId);
-      _packet->skipPacket();
-      return 1;
-    }
-  }
-  printf("[asfAudio] Seek failed for offset=%u\n",newoffset);
-  return 1; 
-}
-/*
-    __________________________________________________________
-*/
-
-uint8_t   asfAudio::goToTime(uint32_t newoffset)
-{
-  // Compute the linear version
-  float f;
-  uint32_t val;
-  
-  f=newoffset;
-  f*=_wavheader->byterate;
-  
-  val=(uint32_t)((f+459.)/1000.);
-  goTo(val);
-  return 1; 
-}
-/*
-    __________________________________________________________
-*/
-
-uint8_t   asfAudio::extraData(uint32_t *l,uint8_t **d)
-{
-  if(_extraData)
-  {
-    *l=_extraDataLen;
-    *d=_extraData;  
-  }
-  else
-  {
-    *l=0;
-    *d=NULL; 
-  }
-  return 1;
-}
-/*
-    __________________________________________________________
-*/
-
-uint8_t  asfAudio::getPacket(uint8_t *dest, uint32_t *len, uint32_t *samples)
-{
-  *len=0;
-  uint32_t delta;
-  uint8_t r;
-  while(1)
-  {
-   
-    while(!readQueue.isEmpty())
-    {
-      asfBit *bit;
-      ADM_assert(readQueue.pop((void**)&bit));
-      printf("Audio found packet of size %d seq %d\n",bit->len,bit->sequence);
-      
-      // still same sequence ...add
-      memcpy(dest,bit->data,bit->len);
-      *len=bit->len;
-#warning FIXME      
-      *samples=384; // ?
-	  delete[] bit->data;
-      delete bit;
-      return 1;
-    }
-    r=_packet->nextPacket(_streamId);
-    _packet->skipPacket();
-    if(!r)
-    {
-      printf("[ASF] Audio Packet Error\n");
-      return 0; 
-    }
-    _packet->skipPacket();
-  }
-  
-  return 0; 
-}
-//EOF

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/CMakeLists.txt	2009-08-14 17:29:29 UTC (rev 5244)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/CMakeLists.txt	2009-08-14 17:29:31 UTC (rev 5245)
@@ -1,4 +1,17 @@
+include(dm_plugin)
 SET(ADM_asf_SRCS 
-	ADM_asf_audio.cpp  ADM_asfChunk.cpp  ADM_asf.cpp  ADM_asfPacket.cpp)
+	ADM_asfAudio.cpp
+        ADM_asfChunk.cpp  
+        ADM_asf.cpp  
+        ADM_asfPacket.cpp
+        ADM_asfPlugin.cpp
+)
 
-ADD_ADM_LIB_ALL_TARGETS(ADM_asf ${ADM_asf_SRCS})
\ No newline at end of file
+ADD_LIBRARY(ADM_dm_asf SHARED ${ADM_asf_SRCS})
+
+#TARGET_LINK_LIBRARIES(ADM_dm_asf ADM_libavutil6)
+
+INCLUDE_DIRECTORIES("${AVIDEMUX_SOURCE_DIR}/avidemux/ADM_libraries/ADM_ffmpeg")
+
+INIT_DEMUXER(ADM_dm_asf)
+INSTALL_DEMUXER(ADM_dm_asf)

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/CMakeLists.txt	2009-08-14 17:29:29 UTC (rev 5244)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/CMakeLists.txt	2009-08-14 17:29:31 UTC (rev 5245)
@@ -5,4 +5,5 @@
 ADD_SUBDIRECTORY(OpenDml)
 ADD_SUBDIRECTORY(MpegPS)
 ADD_SUBDIRECTORY(MpegTS)
+ADD_SUBDIRECTORY(Asf)
 #



From gruntster at mail.berlios.de  Sun Aug 16 11:27:32 2009
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Sun, 16 Aug 2009 11:27:32 +0200
Subject: [Avidemux-svn-commit] r5246 -
	branches/avidemux_2.5_branch_gruntster/avidemux/ADM_libraries
Message-ID: <200908160927.n7G9RWq3028643@sheep.berlios.de>

Author: gruntster
Date: 2009-08-16 11:26:59 +0200 (Sun, 16 Aug 2009)
New Revision: 5246

Added:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_libraries/ffmpeg_r19575.tar.gz
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_libraries/libswscale_r29474.tar.gz
Removed:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_libraries/ffmpeg_r18940.tar.gz
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_libraries/libswscale_r29319.tar.gz
Log:
[ffmpeg] update ffmpeg tarballs

Deleted: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_libraries/ffmpeg_r18940.tar.gz
===================================================================
(Binary files differ)

Copied: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_libraries/ffmpeg_r19575.tar.gz (from rev 5245, branches/avidemux_2.5_branch_gruntster/avidemux/ADM_libraries/ffmpeg_r18940.tar.gz)
===================================================================
(Binary files differ)

Deleted: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_libraries/libswscale_r29319.tar.gz
===================================================================
(Binary files differ)

Copied: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_libraries/libswscale_r29474.tar.gz (from rev 5245, branches/avidemux_2.5_branch_gruntster/avidemux/ADM_libraries/libswscale_r29319.tar.gz)
===================================================================
(Binary files differ)



From mean at mail.berlios.de  Sun Aug 16 11:37:35 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sun, 16 Aug 2009 11:37:35 +0200
Subject: [Avidemux-svn-commit] r5247 - branches/avidemux_2.5_branch_gruntster
Message-ID: <200908160937.n7G9bZ5g030073@sheep.berlios.de>

Author: mean
Date: 2009-08-16 11:37:34 +0200 (Sun, 16 Aug 2009)
New Revision: 5247

Modified:
   branches/avidemux_2.5_branch_gruntster/CMakeLists.txt
Log:
[version] Bump 2.5.1

Modified: branches/avidemux_2.5_branch_gruntster/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/CMakeLists.txt	2009-08-16 09:26:59 UTC (rev 5246)
+++ branches/avidemux_2.5_branch_gruntster/CMakeLists.txt	2009-08-16 09:37:34 UTC (rev 5247)
@@ -79,7 +79,7 @@
 ########################################
 # Standard Avidemux defines
 ########################################
-SET(VERSION 2.5.0)
+SET(VERSION 2.5.1)
 
 # Define internal flags for GTK+ and Qt4 builds.  These are turned off
 # if a showstopper is found.  CLI is automatically assumed as possible



From mean at mail.berlios.de  Sun Aug 16 11:54:08 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sun, 16 Aug 2009 11:54:08 +0200
Subject: [Avidemux-svn-commit] r5248 - tags
Message-ID: <200908160954.n7G9s8hh031877@sheep.berlios.de>

Author: mean
Date: 2009-08-16 11:54:08 +0200 (Sun, 16 Aug 2009)
New Revision: 5248

Added:
   tags/avidemux_2.5.1/
Log:


Copied: tags/avidemux_2.5.1 (from rev 5247, branches/avidemux_2.5_branch_gruntster)



From gruntster at mail.berlios.de  Sun Aug 16 12:03:55 2009
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Sun, 16 Aug 2009 12:03:55 +0200
Subject: [Avidemux-svn-commit] r5249 -
	tags/avidemux_2.5.1/plugins/ADM_videoEncoder/ADM_vidEnc_avcodec
Message-ID: <200908161003.n7GA3t8G000182@sheep.berlios.de>

Author: gruntster
Date: 2009-08-16 12:03:48 +0200 (Sun, 16 Aug 2009)
New Revision: 5249

Modified:
   tags/avidemux_2.5.1/plugins/ADM_videoEncoder/ADM_vidEnc_avcodec/CMakeLists.txt
   tags/avidemux_2.5.1/plugins/ADM_videoEncoder/ADM_vidEnc_avcodec/encoder.cpp
Log:
[2.5.1] disable MPEG-1 video encoder plugin

Modified: tags/avidemux_2.5.1/plugins/ADM_videoEncoder/ADM_vidEnc_avcodec/CMakeLists.txt
===================================================================
--- tags/avidemux_2.5.1/plugins/ADM_videoEncoder/ADM_vidEnc_avcodec/CMakeLists.txt	2009-08-16 09:54:08 UTC (rev 5248)
+++ tags/avidemux_2.5.1/plugins/ADM_videoEncoder/ADM_vidEnc_avcodec/CMakeLists.txt	2009-08-16 10:03:48 UTC (rev 5249)
@@ -9,8 +9,8 @@
 endif (WIN32)
 
 SET(ADM_vidEnc_avcodec_SRCS  interface.c  encoder.cpp  huffyuvEncoder.cpp
-							 ffvhuffEncoder.cpp  ffv1Encoder.cpp  dvEncoder.cpp  mpeg1Encoder.cpp
-							 mpeg1EncoderOptions.cpp)
+							 ffvhuffEncoder.cpp  ffv1Encoder.cpp  dvEncoder.cpp)
+							 #mpeg1Encoder.cpp  mpeg1EncoderOptions.cpp)
 
 set(PLUGIN_SCHEMA_DIR "avcodec")
 set(MPEG1_PLUGIN_CONFIG_DIR "avcodec/mpeg1")

Modified: tags/avidemux_2.5.1/plugins/ADM_videoEncoder/ADM_vidEnc_avcodec/encoder.cpp
===================================================================
--- tags/avidemux_2.5.1/plugins/ADM_videoEncoder/ADM_vidEnc_avcodec/encoder.cpp	2009-08-16 09:54:08 UTC (rev 5248)
+++ tags/avidemux_2.5.1/plugins/ADM_videoEncoder/ADM_vidEnc_avcodec/encoder.cpp	2009-08-16 10:03:48 UTC (rev 5249)
@@ -29,10 +29,10 @@
 static FFV1Encoder ffv1;
 static FFVHuffEncoder ffvhuff;
 static HuffyuvEncoder huffyuv;
-static Mpeg1Encoder mpeg1Encoder;
+//static Mpeg1Encoder mpeg1Encoder;
 
-static int encoderIds[] = { 0, 1, 2, 3, 4 };
-static AvcodecEncoder* encoders[] = { &dv, &ffv1, &ffvhuff, &huffyuv, &mpeg1Encoder};
+static int encoderIds[] = { 0, 1, 2, 3 }; //, 4 };
+static AvcodecEncoder* encoders[] = { &dv, &ffv1, &ffvhuff, &huffyuv }; //, &mpeg1Encoder};
 
 extern "C"
 {



From mean at mail.berlios.de  Sun Aug 16 21:21:39 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sun, 16 Aug 2009 21:21:39 +0200
Subject: [Avidemux-svn-commit] r5250 -
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf
Message-ID: <200908161921.n7GJLdBj022012@sheep.berlios.de>

Author: mean
Date: 2009-08-16 21:21:38 +0200 (Sun, 16 Aug 2009)
New Revision: 5250

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asf.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asf.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asfChunk.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asfPacket.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asfPacket.h
Log:
[Demuxer/asf] Better demuxing

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asf.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asf.cpp	2009-08-16 10:03:48 UTC (rev 5249)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asf.cpp	2009-08-16 19:21:38 UTC (rev 5250)
@@ -23,7 +23,7 @@
 #include "ADM_asf.h"
 #include "ADM_asfPacket.h"
 
-#if 1
+#if 0
 #define aprintf printf
 #else
 #define aprintf(...) {}
@@ -71,28 +71,7 @@
  
   printf("*********** ASF INFO***********\n");
 }
-/**
-    \fn getTime
-*/
-uint64_t                   asfHeader::getTime(uint32_t frameNum)
-{
-    return 0;
-}
 
-uint64_t                   asfHeader::getVideoDuration(void)
-{
-    return 0;
-}
-bool                       asfHeader::getPtsDts(uint32_t frame,uint64_t *pts,uint64_t *dts)
-{
-    *pts=ADM_NO_PTS;
-    *dts=ADM_NO_PTS;
-    return true;
-}
-bool                       asfHeader::setPtsDts(uint32_t frame,uint64_t pts,uint64_t dts)
-{
-    return true;
-}
 /**
     \fn close
 */
@@ -114,16 +93,12 @@
     delete myName;
     myName=NULL; 
   }
-  if(_extraData)
+  if(_videoExtraData)
   {
-    delete [] _extraData;
-    _extraData=NULL; 
+    delete [] _videoExtraData;
+    _videoExtraData=NULL; 
   }
-  if(_index)
-  {
-    delete [] _index; 
-  }
-  _index=NULL;
+
   if(_packet)
     delete _packet;
   _packet=NULL;
@@ -152,11 +127,12 @@
   _packetSize=0;
   _videoStreamId=0;
   nbImage=0;
-  _index=NULL;
+  
   _packet=NULL;
   _nbPackets=0;
-//  printf("%u\n",sizeof(_allAudioTracks));
   memset(&(_allAudioTracks[0]),0,sizeof(_allAudioTracks));
+  memset(&(_audioAccess[0]),0,sizeof(_audioAccess));
+  memset(&(_audioStreams[0]),0,sizeof(_audioStreams));
   _nbAudioTrack=0;
 
 }
@@ -229,6 +205,44 @@
     return true;
 }
 /**
+    \fn getTime
+*/
+uint64_t                   asfHeader::getTime(uint32_t frameNum)
+{
+     if(frameNum>=nbImage) return 0;
+     return _index[frameNum].dts; // ??PTS??
+}
+/**
+    \fn getTime
+*/
+
+uint64_t                   asfHeader::getVideoDuration(void)
+{
+    return _index[nbImage-1].dts;
+}
+/**
+    \fn getTime
+*/
+
+bool                       asfHeader::getPtsDts(uint32_t frame,uint64_t *pts,uint64_t *dts)
+{
+    if(frame>=nbImage) return false;
+    *pts=_index[frame].pts;
+    *dts=_index[frame].dts;
+    return true;
+}
+/**
+    \fn getTime
+*/
+
+bool                       asfHeader::setPtsDts(uint32_t frame,uint64_t pts,uint64_t dts)
+{
+     if(frame>=nbImage) return false;
+    _index[frame].pts=pts;
+    _index[frame].dts=dts;;
+    return true;
+}
+/**
     \fn getFrame
 */    
 uint8_t  asfHeader::getFrame(uint32_t framenum,ADMCompressedImage *img)
@@ -337,6 +351,8 @@
 gotcha:
   
   img->dataLength=len;
+  img->demuxerDts=_index[framenum].dts;
+  img->demuxerPts=_index[framenum].pts;
   if(len!=_index[framenum].frameLen)
   {
     printf("[ASF] Frame=%u :-> Mismatch found len : %u expected %u\n",framenum,len, _index[framenum].frameLen);
@@ -348,8 +364,9 @@
     __________________________________________________________
 */
 
-/*******************************************
-  Read Headers to collect information 
+/** *****************************************
+    \fn getHeaders
+    \brief Read Headers to collect information 
 ********************************************/
 uint8_t asfHeader::getHeaders(void)
 {
@@ -518,7 +535,7 @@
             ADM_assert(_nbAudioTrack<ASF_MAX_AUDIO_TRACK);
             trk->streamIndex=sid;
             s->read((uint8_t *)&(trk->wavHeader),sizeof(WAVHeader));
-
+            printf("[Asf] Encoding for audio 0x%x\n",trk->wavHeader.encoding);
 		#ifdef ADM_BIG_ENDIAN
 			Endian_WavHeader(&(trk->wavHeader));
 		#endif
@@ -595,14 +612,15 @@
             printBih(&_video_bih);
             if(x>sizeof(ADM_BITMAPINFOHEADER))
             {
-              _extraDataLen=x-sizeof(ADM_BITMAPINFOHEADER);
-              _extraData=new uint8_t[_extraDataLen];
-              s->read(_extraData,_extraDataLen);
+              _videoExtraLen=x-sizeof(ADM_BITMAPINFOHEADER);
+              _videoExtraData=new uint8_t[_videoExtraLen];
+              s->read(_videoExtraData,_videoExtraLen);
             }
             return 1;
 }
-/*
-    Scan the file to build an index
+/**
+    \fn      buildIndex
+    \brief   Scan the file to build an index
     
     Header Chunk
             Chunk
@@ -670,37 +688,31 @@
   uint32_t ceilImage=MAXIMAGE;
 
   nbImage=0;
-  asfIndex *tmpIndex=new asfIndex[ceilImage];
-  memset(tmpIndex,0,sizeof(asfIndex)*ceilImage);
+  
   len=0;
-  tmpIndex[0].segNb=1;
+  asfIndex indexEntry;
+  memset(&indexEntry,0,sizeof(indexEntry));
   while(packet<_nbPackets)
   {
     while(!readQueue.isEmpty())
     {
       asfBit *bit=NULL;
+      
       ADM_assert(readQueue.pop((void**)&bit));
-      if(nbImage>=ceilImage-1)
-      {  // Expand if our first guess was too small
-           uint32_t newceil=ceilImage*2;
-           asfIndex *tmptmpIndex=new asfIndex[newceil];
-           memset(tmptmpIndex,0,sizeof(asfIndex)*newceil);
-           memcpy(tmptmpIndex,tmpIndex,sizeof(asfIndex)*ceilImage);
-           delete [] tmpIndex;
-           tmpIndex=tmptmpIndex;
-           ceilImage=newceil;
-      }
+      uint64_t dts=bit->dts;
       if(bit->stream==_videoStreamId)
       {
           aprintf(">found packet of size %d seq %d, while curseq =%d\n",bit->len,bit->sequence,curSeq);
           if(bit->sequence!=sequence)
           {
-            tmpIndex[nbImage].frameLen=len;
+            
+            indexEntry.frameLen=len;
+            _index.push_back(indexEntry);
             aprintf("New sequence\n");
             if( ((sequence+1)&0xff)!=(bit->sequence&0xff))
             {
                 printf("!!!!!!!!!!!! non continuous sequence %u %u\n",sequence,bit->sequence); 
-    #if 1         
+    #if 0         
                 // Let's insert a couple of null frame
                 int32_t delta,start,end;
                 
@@ -714,16 +726,18 @@
                 }
     #endif            
             }
-            nbImage++;
-            ADM_assert(nbImage<ceilImage);
-            tmpIndex[nbImage].frameLen=0;
-            tmpIndex[nbImage].segNb=bit->sequence;
-            tmpIndex[nbImage].packetNb=bit->packet;
-            tmpIndex[nbImage].flags=bit->flags;
+            
+            
+            indexEntry.frameLen=0;
+            indexEntry.segNb=bit->sequence;
+            indexEntry.packetNb=bit->packet;
+            indexEntry.flags=bit->flags;
+            indexEntry.dts=dts;
+            indexEntry.pts=ADM_NO_PTS;
 
             for(int z=0;z<_nbAudioTrack;z++)
             {
-              tmpIndex[nbImage].audioSeen[z]=_allAudioTracks[z].length;
+              indexEntry.audioSeen[z]=_allAudioTracks[z].length;
             }
             readQueue.pushBack(bit);
     
@@ -762,31 +776,28 @@
   delete aPacket;
   //delete working;
   /* Compact index */
-  _index=new asfIndex[nbImage];
-  memcpy(_index,tmpIndex,sizeof(asfIndex)*nbImage);
-  delete [] tmpIndex;
   
   fseeko(_fd,_dataStartOffset,SEEK_SET);
   printf("[ASF] %u images found\n",nbImage);
   printf("[ASF] ******** End of buildindex *******\n");
+
+  nbImage=_index.size();;
+
   _videostream.dwLength=_mainaviheader.dwTotalFrames=nbImage;
   if(!nbImage) return 0;
   
   // Update fps
   // In fact it is an average fps
-  // FIXME
-  float f=nbImage;
-  uint32_t ps;
+  //
+  float f=_index[nbImage-1].dts;
+   f/=nbImage; // average duration of 1 image in us
+    if(f<10) f=10;
+   f=1000000.*1000./f;
+  uint32_t avgFps=(uint32_t) f;
+    printf("[Asf] Average fps=%d\n",avgFps);
   
-  f*=1000.*1000.*10000.;
-  f=f/_duration;
-  ps=(uint32_t)f;
-  // Round up to the closed 0.5 = 500
-  ps=(ps+490)/500;
-  ps*=500;
-  
   _videostream.dwScale=1000;
-  _videostream.dwRate=ps;
+  _videostream.dwRate=(uint32_t)avgFps;;
 
   return 1;
   

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asf.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asf.h	2009-08-16 10:03:48 UTC (rev 5249)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asf.h	2009-08-16 19:21:38 UTC (rev 5250)
@@ -17,22 +17,30 @@
  
 #ifndef ADM_ASF_H
 #define ADM_ASF_H
-
+#include <vector>
+using std::vector;
 #include "ADM_Video.h"
 #include "ADM_queue.h"
 #include "ADM_asfPacket.h"
 
 #define ASF_MAX_AUDIO_TRACK 8
 
+
+
 typedef struct 
 {
   uint32_t packetNb;
   uint32_t frameLen;
   uint32_t segNb;
   uint32_t flags;
+  uint64_t dts;
+  uint64_t pts;
   uint32_t audioSeen[ASF_MAX_AUDIO_TRACK];
+  uint64_t audioDts[ASF_MAX_AUDIO_TRACK];
 }asfIndex;
 
+typedef  vector <asfIndex> AsfVectorIndex;
+
 typedef enum 
 {
   ADM_CHUNK_HEADER_CHUNK ,
@@ -151,11 +159,7 @@
                                 
     FILE                    *_fd;
 
-    int32_t                 _videoIndex;
-    uint32_t                _extraDataLen;
-    uint8_t                 *_extraData;
-    
-    
+    int32_t                 _videoIndex;    
     uint32_t                _videoStreamId;
 
     uint8_t                 close(void);
@@ -165,7 +169,7 @@
     char                    *myName;
     
     uint32_t                nbImage;
-    asfIndex                *_index;
+    AsfVectorIndex          _index;
     uint32_t                _packetSize;
     uint32_t                _dataStartOffset;
     uint32_t                _nbAudioTrack;
@@ -174,6 +178,7 @@
     ADM_audioStream         *_audioStreams[ASF_MAX_AUDIO_TRACK];
     uint32_t                 _nbPackets;
     
+    
     // / Shared
   public:
                                         asfHeader(void);

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asfChunk.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asfChunk.cpp	2009-08-16 10:03:48 UTC (rev 5249)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asfChunk.cpp	2009-08-16 19:21:38 UTC (rev 5250)
@@ -111,7 +111,7 @@
   chunkLen<<=32;
   chunkLen+=low;
   
-  printf("Next chunk from %"LLX" +%"LX" to %"LLX"\n",_chunkStart,chunkLen,chunkLen+_chunkStart);
+  printf("Next chunk from %"LX" +%"LX" to %"LX"\n",_chunkStart,chunkLen,chunkLen+_chunkStart);
   
   return 1;
   

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asfPacket.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asfPacket.cpp	2009-08-16 10:03:48 UTC (rev 5249)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asfPacket.cpp	2009-08-16 19:21:38 UTC (rev 5250)
@@ -2,6 +2,9 @@
     \file ADM_asfPacket.cpp
     copyright            : (C) 2006/2009 by mean
     email                : fixounet at free.fr
+
+see http://avifile.sourceforge.net/asf-1.0.htm
+
  ***************************************************************************/
 
 /***************************************************************************
@@ -24,7 +27,7 @@
 
 #include "ADM_asfPacket.h"
 
-#if 1
+#if 0
 #define aprintf printf
 #else
 #define aprintf(...) {}
@@ -96,7 +99,7 @@
    uint8_t   flags;
     
    packetStart=ftello(_fd);
-#ifdef ADM_DEBUG
+#ifdef ASF_VERBOSE
    uint32_t round=packetStart-_startDataOffset;
    if(round % pakSize)
    {
@@ -149,8 +152,8 @@
 
    
   
-   atime=read32(); // Send time
-   aduration=read16(); // Duration
+   atime=read32(); // Send time (ms)
+   aduration=read16(); // Duration (ms)
    
    if(flags &1) // Multiseg
    {
@@ -192,7 +195,7 @@
      if(r&0x80) keyframe=AVI_KEY_FRAME;
      else       keyframe=0;
      streamId=r&0x7f;
-     aprintf(">>>>>Stream Id : %x<<<<<\n",streamId);
+     //printf(">>>>>Stream Id : %x, duration %d ms, send time:%d ms <<<<<\n",streamId,aduration,atime);
      if(r&0x80) 
      {
        aprintf("KeyFrame\n");
@@ -229,11 +232,14 @@
        payloadLen=remaining;
      }
 #ifdef ASF_VERBOSE     
+//    if(streamId==1)
+    {
      printf("This segment %d bytes, %d /%d\n",packetLen,seg,nbSeg);
      printf("Offset                 %d\n",offset);
      printf("sequence               %d\n",sequence);
      printf("Grouping               %d\n",replica==1);
      printf("payloadLen             %d\n",payloadLen);
+    }
 #endif
      // Frag
      if(replica==1) // Grouping
@@ -251,7 +257,7 @@
            printf("oops exceeding %d/%d\n",l,payloadLen);
            if(streamId==streamWanted || streamWanted==0xff)
            {
-             pushPacket(keyframe,currentPacket,offset,sequence,payloadLen,streamId);
+             pushPacket(keyframe,currentPacket,offset,sequence,payloadLen,streamId,atime*1000);
              
            }else
            {
@@ -267,7 +273,7 @@
      { // else we read "payloadLen" bytes and put them at offset "offset"
        if(streamId==streamWanted|| streamWanted==0xff)
        {
-         pushPacket(keyframe,currentPacket,offset,sequence,payloadLen,streamId);    
+         pushPacket(keyframe,currentPacket,offset,sequence,payloadLen,streamId,atime*1000);    
        }else
         skip(payloadLen);
        aprintf("Reading %d bytes\n",payloadLen);
@@ -291,10 +297,10 @@
  
  */
 
- uint8_t asfPacket::pushPacket(uint32_t keyframe,uint32_t packetnb,uint32_t offset,uint32_t sequence,uint32_t payloadLen,uint32_t stream)
+ uint8_t asfPacket::pushPacket(uint32_t keyframe,uint32_t packetnb,uint32_t offset,uint32_t sequence,uint32_t payloadLen,uint32_t stream,uint64_t dts)
  {
    asfBit *bit=new asfBit;
-   aprintf("Pushing packet stream=%d len=%d seq=%d\n",stream,payloadLen,sequence);
+   printf("Pushing packet stream=%d len=%d seq=%d dts=%d ms\n",stream,payloadLen,sequence,dts/1000);
    bit->sequence=sequence;
    bit->offset=offset;
    bit->len=payloadLen;
@@ -302,6 +308,7 @@
    bit->stream=stream;
    bit->packet=packetnb;
    bit->flags=keyframe;
+   bit->dts=dts;
 
    if(!read(bit->data,bit->len))
    {

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asfPacket.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asfPacket.h	2009-08-16 10:03:48 UTC (rev 5249)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asfPacket.h	2009-08-16 19:21:38 UTC (rev 5250)
@@ -27,7 +27,9 @@
   uint32_t stream;
   uint32_t packet;
   uint32_t flags;
+  uint64_t dts; // in us
   uint8_t  *data;
+  
 }asfBit;
 
 class asfPacket
@@ -35,7 +37,8 @@
   protected:
     uint32_t        readVCL(uint32_t bitwise);
     uint8_t         pushPacket(uint32_t flags,uint32_t packetnb,
-                                uint32_t offset,uint32_t sequence,uint32_t payloadLen,uint32_t stream);
+                                uint32_t offset,uint32_t sequence,uint32_t payloadLen,uint32_t stream,
+                                uint64_t dtsus);
     uint8_t         skip( uint32_t how);
     FILE            *_fd;
     uint32_t        packetStart;



From mean at mail.berlios.de  Sun Aug 16 21:21:41 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sun, 16 Aug 2009 21:21:41 +0200
Subject: [Avidemux-svn-commit] r5251 - in
	branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreAudio:
	include src
Message-ID: <200908161921.n7GJLfhs022022@sheep.berlios.de>

Author: mean
Date: 2009-08-16 21:21:40 +0200 (Sun, 16 Aug 2009)
New Revision: 5251

Added:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreAudio/include/ADM_audioStreamConstantChunk.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreAudio/src/ADM_audioStreamConstantChunk.cpp
Modified:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreAudio/include/ADM_audioStreamBuffered.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreAudio/src/ADM_audioStream.cpp
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreAudio/src/CMakeLists.txt
Log:
[coreAudio] Added constant chunk size audioStream

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreAudio/include/ADM_audioStreamBuffered.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreAudio/include/ADM_audioStreamBuffered.h	2009-08-16 19:21:38 UTC (rev 5250)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreAudio/include/ADM_audioStreamBuffered.h	2009-08-16 19:21:40 UTC (rev 5251)
@@ -45,6 +45,7 @@
 virtual                bool      goToTime(uint64_t nbUs);
                        bool      needBytes(uint32_t nbBytes);
                        bool      skipBytes(uint32_t nbBytes);
+                       bool      empty(void) {limit=start=0;}
 };
 #endif
 // EOF

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreAudio/include/ADM_audioStreamConstantChunk.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreAudio/include/ADM_audioStreamConstantChunk.h	2009-08-16 19:21:38 UTC (rev 5250)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreAudio/include/ADM_audioStreamConstantChunk.h	2009-08-16 19:21:40 UTC (rev 5251)
@@ -0,0 +1,45 @@
+/***************************************************************************
+                          ADM_audioStream.h  -  description
+                             -------------------
+    copyright            : (C) 2008 by mean
+    email                : fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#ifndef ADM_audioStreamConstantChunk_H
+#define ADM_audioStreamConstantChunk_H
+
+#include "ADM_audioStreamBuffered.h"
+#include <vector>
+using namespace std;
+
+
+/**
+        \fn ADM_audioStreamConstantChunk
+        \brief Class to handle MP3/MP3 streams
+
+*/
+class ADM_audioStreamConstantChunk : public ADM_audioStreamBuffered
+{
+        protected:
+                        uint32_t  chunkSize;
+                        uint32_t samplesPerChunk;
+        public:
+/// Default constructor
+                       ADM_audioStreamConstantChunk(WAVHeader *header,ADM_audioAccess *access);  
+/// Destructor
+virtual                 ~ADM_audioStreamConstantChunk();
+///  Get a packet
+virtual uint8_t         getPacket(uint8_t *buffer,uint32_t *size, uint32_t sizeMax,
+                                uint32_t *nbSample,uint64_t *dts);
+};
+#endif
+// EOF
+

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreAudio/src/ADM_audioStream.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreAudio/src/ADM_audioStream.cpp	2009-08-16 19:21:38 UTC (rev 5250)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreAudio/src/ADM_audioStream.cpp	2009-08-16 19:21:40 UTC (rev 5251)
@@ -8,6 +8,7 @@
 #include "ADM_audioStreamMP3.h"
 #include "ADM_audioStreamAC3.h"
 #include "ADM_audioStreamEac3.h"
+#include "ADM_audioStreamConstantChunk.h"
 
 /**
     \fn ADM_audioStream
@@ -141,9 +142,14 @@
             return new ADM_audioStreamAC3(wavheader,access);
         case WAV_MP3:
             return new ADM_audioStreamMP3(wavheader,access);
+#if 0
+        case WAV_WMA:
+            return new ADM_audioStreamConstantChunk(wavheader,access);
+#endif
         default:
             return new ADM_audioStream(wavheader,access);
     }
 
 }
 // EOF
+

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreAudio/src/ADM_audioStreamConstantChunk.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreAudio/src/ADM_audioStreamConstantChunk.cpp	2009-08-16 19:21:38 UTC (rev 5250)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreAudio/src/ADM_audioStreamConstantChunk.cpp	2009-08-16 19:21:40 UTC (rev 5251)
@@ -0,0 +1,82 @@
+/**
+    \file ADM_audioStreamConstantChunk
+    \brief Base class
+
+(C) Mean 2008
+GPL-v2
+*/
+#include "ADM_default.h"
+#include "ADM_audioStreamConstantChunk.h"
+#include "DIA_working.h"
+/**
+    \fn ADM_audioStreamConstantChunk
+    \brief constructor
+*/
+ADM_audioStreamConstantChunk::ADM_audioStreamConstantChunk(WAVHeader *header,ADM_audioAccess *access) : ADM_audioStreamBuffered(header,access)
+{
+    //
+    chunkSize=header->blockalign;
+    if(!chunkSize)
+    {
+        printf("[ADM_audioStreamConstantChunk] Blockalign is null expect problems\n");
+        chunkSize=8192; // dummy value
+    }
+    printf("[ADM_audioStreamConstantChunk] Chunk size %"LU"\n",chunkSize);
+    printf("[ADM_audioStreamConstantChunk] Byterate   %"LU"\n",header->byterate);
+    // Compute sample per chunk from wavHeader...
+    float f;
+    f=chunkSize;
+    f/=header->byterate; // F is in seconds
+    f*=header->frequency; // in sample
+    samplesPerChunk=(uint32_t)f;
+    printf("[ADM_audioStreamConstantChunk] About %"LU" samples per chunk\n",samplesPerChunk);
+
+    // If hinted..., compute the duration ourselves
+    if(access->isCBR()==true && access->canSeekOffset()==true)
+    {
+        // We can compute the duration from the length
+        float size=access->getLength();
+              size/=header->byterate; // Result is in second
+              size*=1000;
+              size*=1000; // s->us
+              durationInUs=(uint64_t)size;
+              return;
+    }
+// Time based
+    durationInUs=access->getDurationInUs();
+    
+
+}
+
+/**
+    \fn ADM_audioStream
+    \brief destructor
+*/
+ADM_audioStreamConstantChunk::~ADM_audioStreamConstantChunk()
+{
+  
+}
+
+/**
+        \fn getPacket
+*/
+uint8_t ADM_audioStreamConstantChunk::getPacket(uint8_t *buffer,uint32_t *size, uint32_t sizeMax,uint32_t *nbSample,uint64_t *dts)
+{
+
+        // Do we have enough ? Refill if needed ?
+        if(needBytes(chunkSize)==false) return 0;
+        if(sizeMax<chunkSize)
+        {
+            printf("[ADM_audioStreamConstantChunk] Buffer too small %"LU", need %"LU"\n",sizeMax,chunkSize);
+            return 0;
+        }
+        *size=chunkSize;
+        read(chunkSize,buffer);
+        start+=chunkSize;
+        *nbSample=samplesPerChunk;
+        *dts=lastDts;
+        advanceDtsBySample(samplesPerChunk);
+        return 1;
+            
+}
+

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreAudio/src/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreAudio/src/CMakeLists.txt	2009-08-16 19:21:38 UTC (rev 5250)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreAudio/src/CMakeLists.txt	2009-08-16 19:21:40 UTC (rev 5251)
@@ -6,6 +6,7 @@
 ADM_audioStreamMP3.cpp
 ADM_audioStreamAC3.cpp
 ADM_audioStreamEac3.cpp
+ADM_audioStreamConstantChunk.cpp
 )	
 #*************************************************
 #*************************************************



From mean at mail.berlios.de  Sun Aug 16 21:21:42 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sun, 16 Aug 2009 21:21:42 +0200
Subject: [Avidemux-svn-commit] r5252 -
	branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreAudioFilter/include
Message-ID: <200908161921.n7GJLgxL022032@sheep.berlios.de>

Author: mean
Date: 2009-08-16 21:21:42 +0200 (Sun, 16 Aug 2009)
New Revision: 5252

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreAudioFilter/include/ADM_audioFilter.h
Log:
[audioCore] Increase audio filter buffer (WTF)

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreAudioFilter/include/ADM_audioFilter.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreAudioFilter/include/ADM_audioFilter.h	2009-08-16 19:21:40 UTC (rev 5251)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreAudioFilter/include/ADM_audioFilter.h	2009-08-16 19:21:42 UTC (rev 5252)
@@ -18,7 +18,7 @@
 #ifndef __Audio_ENG_Process__
 #define __Audio_ENG_Process__
 
-#define AUD_PROCESS_BUFFER_SIZE 48000*2*4 // should be enougth 4 seconds of stereo
+#define AUD_PROCESS_BUFFER_SIZE 48000*4*4 // should be enougth 4 seconds of stereo
 #include "ADM_coreAudio.h"
 /**
   This enumerate is used to give a more accurate error when no audio is output from



From mean at mail.berlios.de  Mon Aug 17 19:50:46 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Mon, 17 Aug 2009 19:50:46 +0200
Subject: [Avidemux-svn-commit] r5253 -
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf
Message-ID: <200908171750.n7HHokmS027113@sheep.berlios.de>

Author: mean
Date: 2009-08-17 19:50:46 +0200 (Mon, 17 Aug 2009)
New Revision: 5253

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asf.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asf.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asfAudio.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asfPacket.cpp
Log:
[asf/demuxer] Fix first image decoding, silence prints

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asf.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asf.cpp	2009-08-16 19:21:42 UTC (rev 5252)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asf.cpp	2009-08-17 17:50:46 UTC (rev 5253)
@@ -692,6 +692,7 @@
   len=0;
   asfIndex indexEntry;
   memset(&indexEntry,0,sizeof(indexEntry));
+  bool first=true;
   while(packet<_nbPackets)
   {
     while(!readQueue.isEmpty())
@@ -703,11 +704,14 @@
       if(bit->stream==_videoStreamId)
       {
           aprintf(">found packet of size %d seq %d, while curseq =%d\n",bit->len,bit->sequence,curSeq);
-          if(bit->sequence!=sequence)
+          if(bit->sequence!=sequence || first==true)
           {
-            
-            indexEntry.frameLen=len;
-            _index.push_back(indexEntry);
+            if(first==false)
+            {
+                indexEntry.frameLen=len;
+                _index.push_back(indexEntry);
+            }
+            first=false;
             aprintf("New sequence\n");
             if( ((sequence+1)&0xff)!=(bit->sequence&0xff))
             {
@@ -738,6 +742,7 @@
             for(int z=0;z<_nbAudioTrack;z++)
             {
               indexEntry.audioSeen[z]=_allAudioTracks[z].length;
+              indexEntry.audioDts[z]=_allAudioTracks[z].lastDts;
             }
             readQueue.pushBack(bit);
     
@@ -756,6 +761,8 @@
           {
             
             _allAudioTracks[i].length+=bit->len;
+            _allAudioTracks[i].lastDts=bit->dts;
+            
             found=1;
           }
         }

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asf.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asf.h	2009-08-16 19:21:42 UTC (rev 5252)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asf.h	2009-08-17 17:50:46 UTC (rev 5253)
@@ -97,6 +97,7 @@
   uint8_t      *extraData;
   uint32_t     nbPackets;
   uint32_t     length;
+  uint64_t     lastDts;
   WAVHeader    wavHeader;
 }asfAudioTrak;
 

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asfAudio.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asfAudio.cpp	2009-08-16 19:21:42 UTC (rev 5252)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asfAudio.cpp	2009-08-17 17:50:46 UTC (rev 5253)
@@ -110,16 +110,21 @@
 
 bool   asfAudioAccess::goToTime(uint64_t dts_us)
 {
-  // Compute the linear version
-  float f;
-  uint32_t val;
-  
-  f=dts_us;
-  f/=1000;
-  f*=_track->wavHeader.byterate;
-  
-  val=(uint32_t)((f+459.)/1000.);
-  return setPos(val);
+    AsfVectorIndex     *idx=&(_father->_index);
+    // Search
+    int size=idx->size();
+    if(dts_us<=(*idx)[0].audioDts[_myRank])
+    {
+          return setPos( 0);
+    }
+    for(int i=0;i<size-1;i++)
+    {
+        if(dts_us>=(*idx)[i].audioDts[_myRank] && dts_us<(*idx)[i+1].audioDts[_myRank])
+        {
+            return setPos( (*idx)[i].packetNb);
+        }
+    }
+    return false;
 }
 
 /**
@@ -138,12 +143,12 @@
     {
       asfBit *bit;
       ADM_assert(readQueue.pop((void**)&bit));
-      printf("Audio found packet of size %d seq %d\n",bit->len,bit->sequence);
+      //printf("[Asf] Audio found packet of size %d seq %d\n",bit->len,bit->sequence);
       
       // still same sequence ...add
       memcpy(dest,bit->data,bit->len);
       *len=bit->len;
-      *dts=ADM_NO_PTS;
+      *dts=bit->dts;
 	  delete[] bit->data;
       delete bit;
       return 1;

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asfPacket.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asfPacket.cpp	2009-08-16 19:21:42 UTC (rev 5252)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asfPacket.cpp	2009-08-17 17:50:46 UTC (rev 5253)
@@ -205,7 +205,29 @@
      replica=readVCL(segmentId);
      aprintf("replica                %d\n",replica);
      // Skip replica data_len
-     skip(replica);
+     if(replica>=8) // Grab timestamp
+     {
+        uint32_t time1=read32();
+        
+        //printf("Time 1 : %"LU"\n",time1);
+         if(replica >= 8+38+4)
+         {
+            uint64_t time2;
+            uint32_t a,b;
+            skip(10);
+            a=read32();
+            b=read32();
+            time2=a+(b<<32);
+            skip(8); 
+            skip(12);
+            skip(4);
+            skip(replica - 8 - 38 - 4);
+            printf("Time 2 : %"LLU"\n",time2);
+            }else
+            skip(replica-4);
+     }
+      else 
+        skip(replica);
      
      payloadLen=0;
      if(flags &1)  // multi seg
@@ -300,7 +322,7 @@
  uint8_t asfPacket::pushPacket(uint32_t keyframe,uint32_t packetnb,uint32_t offset,uint32_t sequence,uint32_t payloadLen,uint32_t stream,uint64_t dts)
  {
    asfBit *bit=new asfBit;
-   printf("Pushing packet stream=%d len=%d seq=%d dts=%d ms\n",stream,payloadLen,sequence,dts/1000);
+   //printf("Pushing packet stream=%d len=%d seq=%d dts=%d ms\n",stream,payloadLen,sequence,dts/1000);
    bit->sequence=sequence;
    bit->offset=offset;
    bit->len=payloadLen;



From mean at mail.berlios.de  Mon Aug 17 19:50:50 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Mon, 17 Aug 2009 19:50:50 +0200
Subject: [Avidemux-svn-commit] r5254 -
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf
Message-ID: <200908171750.n7HHoouw027130@sheep.berlios.de>

Author: mean
Date: 2009-08-17 19:50:48 +0200 (Mon, 17 Aug 2009)
New Revision: 5254

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asfPacket.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asfPacket.h
Log:
[Asf] change readVCL to follow what ffmpeg does (since there is no doc...)

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asfPacket.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asfPacket.cpp	2009-08-17 17:50:46 UTC (rev 5253)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asfPacket.cpp	2009-08-17 17:50:48 UTC (rev 5254)
@@ -129,18 +129,18 @@
    
 
    // Read packetLen
-   packetLen=readVCL(flags>>5);
+   packetLen=readVCL(flags>>5,pakSize);
    // Sequence len
-   sequenceLen=readVCL(flags>>1);
+   sequenceLen=readVCL(flags>>1,0);
    // Read padding size (padding):
-   paddingLen=readVCL(flags>>3);
+   paddingLen=readVCL(flags>>3,0);
    
    aprintf("paddingLen :         %d\n",paddingLen);
    
 // Explicit (absolute) packet size	    
    if(((flags>>5)&3))
    {
-     printf("## Explicit packet size %d\n",packetLen);
+     //printf("## Explicit packet size %d\n",packetLen);
      if(packetLen>pakSize) printf("**************Len > packet size!! (%d /%d)\n",packetLen,pakSize);
    } 
    if(!packetLen)
@@ -200,9 +200,9 @@
      {
        aprintf("KeyFrame\n");
      }
-     sequence=readVCL(segmentId>>4);
-     offset=readVCL(segmentId>>2);
-     replica=readVCL(segmentId);
+     sequence=readVCL(segmentId>>4,0);
+     offset=readVCL(segmentId>>2,0);
+     replica=readVCL(segmentId,0);
      aprintf("replica                %d\n",replica);
      // Skip replica data_len
      if(replica>=8) // Grab timestamp
@@ -232,7 +232,7 @@
      payloadLen=0;
      if(flags &1)  // multi seg
      {
-       payloadLen=readVCL(segType);
+       payloadLen=readVCL(segType,0);
        if(payloadLen)
         aprintf("##len                    %d\n",payloadLen);
        
@@ -343,7 +343,7 @@
    return 1;
  }
  
- uint32_t asfPacket::readVCL(uint32_t bitwise)
+ uint32_t asfPacket::readVCL(uint32_t bitwise,uint32_t def)
  {
    uint32_t r;
    switch(bitwise&3)
@@ -351,7 +351,7 @@
      case 3: r=read32();break;  // dword
      case 2: r=read16();break;  // word
      case 1: r=read8();break;   // byte
-     default: r=0;
+     default: r=def;
    }
    return r;
  }

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asfPacket.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asfPacket.h	2009-08-17 17:50:46 UTC (rev 5253)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asfPacket.h	2009-08-17 17:50:48 UTC (rev 5254)
@@ -35,7 +35,7 @@
 class asfPacket
 {
   protected:
-    uint32_t        readVCL(uint32_t bitwise);
+    uint32_t        readVCL(uint32_t bitwise,uint32_t defaultValue);
     uint8_t         pushPacket(uint32_t flags,uint32_t packetnb,
                                 uint32_t offset,uint32_t sequence,uint32_t payloadLen,uint32_t stream,
                                 uint64_t dtsus);



From mean at mail.berlios.de  Tue Aug 18 20:10:52 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Tue, 18 Aug 2009 20:10:52 +0200
Subject: [Avidemux-svn-commit] r5255 - in
	branches/avidemux_2.5_branch_gruntster/avidemux: ADM_codecs
	ADM_inputs/ADM_flv
Message-ID: <200908181810.n7IIAqwl006238@sheep.berlios.de>

Author: mean
Date: 2009-08-18 20:10:51 +0200 (Tue, 18 Aug 2009)
New Revision: 5255

Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_codecs/ADM_codecs.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_codecs/ADM_ffmp43.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_codecs/ADM_ffmp43.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_flv/ADM_flv.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_flv/ADM_flv.h
Log:
[Flv] Backport metadata handling from 2.6, fixes #26

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_codecs/ADM_codecs.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_codecs/ADM_codecs.cpp	2009-08-17 17:50:48 UTC (rev 5254)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_codecs/ADM_codecs.cpp	2009-08-18 18:10:51 UTC (rev 5255)
@@ -375,7 +375,11 @@
       return (decoders *) (new decoderFFAMV (w, h,extraLen,extraData));
     }
 
-
+ if (fourCC::check (fcc, (uint8_t *) "VP6A"))
+    {
+      printf ("\n using YUY2 codec\n");
+      return (decoders *) (new decoderFFVP6A (w, h,extraLen,extraData));
+    }
   if (isVP6Compatible(fcc))
     {
       printf ("\n using VP6F codec\n");

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_codecs/ADM_ffmp43.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_codecs/ADM_ffmp43.cpp	2009-08-17 17:50:48 UTC (rev 5254)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_codecs/ADM_ffmp43.cpp	2009-08-18 18:10:51 UTC (rev 5255)
@@ -411,6 +411,7 @@
 
     case PIX_FMT_YUV420P:
     case PIX_FMT_YUVJ420P:
+    case PIX_FMT_YUVA420P:
       // Default is YV12 or I420
       // In that case depending on swap u/v
       // we do it or not
@@ -702,6 +703,12 @@
 {
   WRAP_Open (CODEC_ID_VP6F);
 }
+//*************
+decoderFFVP6A::decoderFFVP6A (uint32_t w, uint32_t h, uint32_t l, uint8_t * d):decoderFF (w,	   h)
+{
+  WRAP_Open (CODEC_ID_VP6A);
+}
+
 //************
 decoderFFFLV1::decoderFFFLV1 (uint32_t w, uint32_t h, uint32_t l, uint8_t * d):decoderFF (w,	   h)
 {

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_codecs/ADM_ffmp43.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_codecs/ADM_ffmp43.h	2009-08-17 17:50:48 UTC (rev 5254)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_codecs/ADM_ffmp43.h	2009-08-18 18:10:51 UTC (rev 5255)
@@ -340,6 +340,12 @@
 public:
   decoderFFVP6F (uint32_t w, uint32_t h, uint32_t l, uint8_t * d);
 };
+class decoderFFVP6A:public decoderFF
+{
+protected:
+public:
+  decoderFFVP6A (uint32_t w, uint32_t h, uint32_t l, uint8_t * d);
+};
 class decoderFFFLV1:public decoderFF
 {
 protected:

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_flv/ADM_flv.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_flv/ADM_flv.cpp	2009-08-17 17:50:48 UTC (rev 5254)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_flv/ADM_flv.cpp	2009-08-18 18:10:51 UTC (rev 5255)
@@ -80,8 +80,100 @@
     fread(r,4,1,_fd);
     return (r[0]<<24)+(r[1]<<16)+(r[2]<<8)+r[3]; 
 }
+/**
+    \fn     readFlvString
+    \brief  read pascal like string
+*/
+char *flvHeader::readFlvString(void)
+{
+static char stringz[255];
+    int size=read16();
+    read(size,(uint8_t *)stringz);
+    stringz[size]=0;
+    return stringz;
+}
 
+extern "C" {
+double av_int2dbl(int64_t v);
+}
+
 /**
+    \fn setProperties
+    \brief get a couple key/value and use it if needed...
+*/
+void flvHeader::setProperties(const char *name,float value)
+{
+    if(!strcmp(name,"framerate"))
+    {
+        _videostream.dwRate=(uint32_t)(value*1000);
+        return;
+    }
+    if(!strcmp(name,"width"))
+    {
+        metaWidth=(uint32_t)value;
+    }
+    if(!strcmp(name,"height"))
+    {
+        metaHeight=(uint32_t)value;
+    }
+
+}
+/**
+    \fn parseMetaData
+    \brief
+*/
+uint8_t flvHeader::parseMetaData(uint32_t remaining)
+{
+    uint32_t endPos=ftello(_fd)+remaining;
+    {
+        // Check the first one is onMetaData...
+        uint8_t type=read8();
+
+        if(type!=AMF_DATA_TYPE_STRING) // String!
+            goto endit;
+        char *z=readFlvString();
+        printf("[FlashString] %s\n",z);
+        if(z && strncmp(z,"onMetaData",10)) goto endit;
+        // Normally the next one is mixed array
+        Skip(4);
+        Skip(1);
+        while(ftello(_fd)<endPos-4)
+        {
+
+            char *s=readFlvString();
+            printf("[FlvType] :%d String : %s",type,s);
+            type=read8();
+            switch(type)
+            {
+                case AMF_DATA_TYPE_DATE: Skip(8+2);break;
+                case AMF_DATA_TYPE_NUMBER:
+                                        {
+                                            float val;
+                                            uint64_t hi,lo;
+                                            hi=read32();lo=read32();
+                                            hi=(hi<<32)+lo;
+                                            val=(float)av_int2dbl(hi);
+                                            printf("->%f\n",val);
+                                            setProperties(s,val);
+                                        }
+                                        ;break;
+                case AMF_DATA_TYPE_STRING: {int r=read16();Skip(r);}break;
+                case AMF_DATA_TYPE_BOOL: read8();break;
+                case AMF_DATA_TYPE_OBJECT: goto endit; // unsupported for the moment
+                default : printf("\n");ADM_assert(0);
+            }
+            printf("\n");
+
+        }
+
+        // Process them...
+    }
+endit:
+    fseeko(_fd,endPos,SEEK_SET);
+    return 1;
+}
+
+/**
       \fn open
       \brief open the flv file, gather infos and build index(es).
 */
@@ -182,6 +274,11 @@
             insertAudio(pos+of,remaining,pts);
           }
           break;
+      case FLV_TAG_TYPE_META:
+                parseMetaData(remaining);
+                remaining=0;
+                break;
+
       case FLV_TAG_TYPE_VIDEO:
           {
             int of=1+4+3+3+1+4;
@@ -191,7 +288,7 @@
             
             int codec=(flags)&0xf;
             
-            if(codec==FLV_CODECID_VP6)
+            if(codec==FLV_CODECID_VP6 || codec==FLV_CODECID_VP6A)
             {
               read8(); // 1 byte of extraData
               remaining--;
@@ -257,10 +354,19 @@
     {
       case FLV_CODECID_H263:            _videostream.fccHandler=_video_bih.biCompression=fourCC::get((uint8_t *)"FLV1");break;
       case FLV_CODECID_VP6:             _videostream.fccHandler=_video_bih.biCompression=fourCC::get((uint8_t *)"VP6F");break;
+      case FLV_CODECID_VP6A:
+                        _videostream.fccHandler=_video_bih.biCompression=fourCC::get((uint8_t *)"VP6A");break;
+
     //???   case FLV_CODECID_SCREEN:          _videostream.fccHandler=_video_bih.biCompression=fourCC::get((uint8_t *)"VP6F");break;
       default :                         _videostream.fccHandler=_video_bih.biCompression=fourCC::get((uint8_t *)"XXX");break;
       
     }
+    if(codec==FLV_CODECID_VP6A && metaWidth && metaHeight )
+    {
+         _video_bih.biHeight=_mainaviheader.dwHeight=metaHeight ;
+         _video_bih.biWidth=_mainaviheader.dwWidth=metaWidth;
+    }
+
     if(codec==FLV_CODECID_VP6)
     {
         read8();

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_flv/ADM_flv.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_flv/ADM_flv.h	2009-08-17 17:50:48 UTC (rev 5254)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_flv/ADM_flv.h	2009-08-18 18:10:51 UTC (rev 5255)
@@ -88,6 +88,7 @@
     uint8_t                 getAudioStreamsInfo(uint32_t *nbStreams, audioInfo **infos);
     flvAudio                *_audioStream;
     /* */
+    uint32_t                metaWidth,metaHeight,metaFps1000;
     
     uint8_t     read(uint32_t len, uint8_t *where);
     uint8_t     read8(void);
@@ -102,6 +103,11 @@
     
     
     uint8_t     getFrameSize (uint32_t frame, uint32_t * size);
+    uint8_t     parseMetaData(uint32_t remaining);
+    void        setProperties(const char *name,float value);
+    char        *readFlvString(void);
+ 
+
   public:
 
 



From mean at mail.berlios.de  Wed Aug 19 19:38:05 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Wed, 19 Aug 2009 19:38:05 +0200
Subject: [Avidemux-svn-commit] r5256 - in
	branches/avidemux_2.5_branch_gruntster: cmake
	plugins/ADM_audioDecoders/ADM_ad_vorbis
Message-ID: <200908191738.n7JHc54n023626@sheep.berlios.de>

Author: mean
Date: 2009-08-19 19:38:04 +0200 (Wed, 19 Aug 2009)
New Revision: 5256

Added:
   branches/avidemux_2.5_branch_gruntster/cmake/admCheckVorbisDec.cmake
Modified:
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDecoders/ADM_ad_vorbis/CMakeLists.txt
Log:
[Audio/vorbis] Check also for vorbis decoder and build the decoder plugin

Added: branches/avidemux_2.5_branch_gruntster/cmake/admCheckVorbisDec.cmake
===================================================================
--- branches/avidemux_2.5_branch_gruntster/cmake/admCheckVorbisDec.cmake	2009-08-18 18:10:51 UTC (rev 5255)
+++ branches/avidemux_2.5_branch_gruntster/cmake/admCheckVorbisDec.cmake	2009-08-19 17:38:04 UTC (rev 5256)
@@ -0,0 +1,35 @@
+########################################
+# LIBVORBIS
+########################################
+MACRO(checkvorbis)
+	IF (NOT LIBVORBIS_CHECKED)
+		OPTION(LIBVORBIS "" ON)
+
+		MESSAGE(STATUS "Checking for LIBVORBIS")
+		MESSAGE(STATUS "*******************")
+
+		IF (LIBVORBIS)
+			IF (UNIX)
+				SET(LIBVORBIS_REQUIRED_FLAGS "-lm")
+			ENDIF (UNIX)
+
+
+			FIND_HEADER_AND_LIB(LIBVORBIS vorbis/codec.h vorbis vorbis_synthesis_init ${LIBVORBIS_REQUIRED_FLAGS})
+
+			IF (LIBVORBIS_FOUND)
+				SET(LIBVORBIS_FOUND 1)
+				SET(USE_LIBVORBIS 1)
+				SET(LIBVORBIS_INCLUDE_DIR "${LIBVORBIS_INCLUDE_DIR}")
+				SET(LIBVORBIS_LIBRARY_DIR "${LIBVORBIS_LIBRARY_DIR}")
+			ENDIF (LIBVORBIS_FOUND)
+
+			PRINT_LIBRARY_INFO("LIBVORBIS" LIBVORBIS_FOUND "${LIBVORBIS_INCLUDE_DIR}" "${LIBVORBIS_LIBRARY_DIR}")
+		ELSE (LIBVORBIS)
+			MESSAGE("${MSG_DISABLE_OPTION}")
+		ENDIF (LIBVORBIS)
+
+		SET(LIBVORBIS_CHECKED 1)
+
+		MESSAGE("")
+	ENDIF (NOT LIBVORBIS_CHECKED)
+ENDMACRO(checkvorbis)

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDecoders/ADM_ad_vorbis/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDecoders/ADM_ad_vorbis/CMakeLists.txt	2009-08-18 18:10:51 UTC (rev 5255)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_audioDecoders/ADM_ad_vorbis/CMakeLists.txt	2009-08-19 17:38:04 UTC (rev 5256)
@@ -1,15 +1,17 @@
-IF (USE_VORBIS)
-	INCLUDE(ad_plugin)
+INCLUDE(ad_plugin)
+INCLUDE(admCheckVorbisDec)
+checkvorbis()
+IF (USE_LIBVORBIS)
 
 	SET(ADM_ad_vorbis_SRCS ADM_ad_vorbis.cpp)
 
 	ADD_LIBRARY(ADM_ad_vorbis SHARED ${ADM_ad_vorbis_SRCS})
 
-	TARGET_LINK_LIBRARIES(ADM_ad_vorbis ${VORBIS_LIBRARY_DIR})
-	TARGET_LINK_LIBRARIES(ADM_ad_vorbis ${VORBISENC_LIBRARY_DIR})
+	TARGET_LINK_LIBRARIES(ADM_ad_vorbis ${LIBVORBIS_LIBRARY_DIR})
+	TARGET_LINK_LIBRARIES(ADM_ad_vorbis ${LIBVORBISENC_LIBRARY_DIR})
 
-	ADD_TARGET_CFLAGS(ADM_ad_vorbis "-I${VORBIS_INCLUDE_DIR}")
+	ADD_TARGET_CFLAGS(ADM_ad_vorbis "-I${LIBVORBIS_INCLUDE_DIR}")
 
 	INIT_AUDIO_PLUGIN(ADM_ad_vorbis)
 	INSTALL_AUDIODECODER(ADM_ad_vorbis)
-ENDIF (USE_VORBIS)
+ENDIF (USE_LIBVORBIS)



From mean at mail.berlios.de  Fri Aug 21 17:32:53 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Fri, 21 Aug 2009 17:32:53 +0200
Subject: [Avidemux-svn-commit] r5257 -
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Flv
Message-ID: <200908211532.n7LFWr89027604@sheep.berlios.de>

Author: mean
Date: 2009-08-21 17:32:53 +0200 (Fri, 21 Aug 2009)
New Revision: 5257

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Flv/ADM_flv.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Flv/ADM_flv.h
Log:
[Flv/demux] Support VP6A + fetch w & h from metadata, refs #26

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Flv/ADM_flv.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Flv/ADM_flv.cpp	2009-08-19 17:38:04 UTC (rev 5256)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Flv/ADM_flv.cpp	2009-08-21 15:32:53 UTC (rev 5257)
@@ -108,6 +108,15 @@
         _videostream.dwRate=(uint32_t)(value*1000);
         return;
     }
+    if(!strcmp(name,"width"))
+    {
+        metaWidth=(uint32_t)value;
+    }
+    if(!strcmp(name,"height"))
+    {
+        metaHeight=(uint32_t)value;
+    }
+
 }
 /**
     \fn parseMetaData
@@ -295,7 +304,7 @@
 
             int codec=(flags)&0xf;
 
-            if(codec==FLV_CODECID_VP6)
+            if(codec==FLV_CODECID_VP6 || codec==FLV_CODECID_VP6A)
             {
               read8(); // 1 byte of extraData
               remaining--;
@@ -389,13 +398,21 @@
     switch(codec)
     {
       case FLV_CODECID_H263:            _videostream.fccHandler=_video_bih.biCompression=fourCC::get((uint8_t *)"FLV1");break;
-      case FLV_CODECID_VP6:             _videostream.fccHandler=_video_bih.biCompression=fourCC::get((uint8_t *)"VP6F");break;
+      case FLV_CODECID_VP6:
+                        _videostream.fccHandler=_video_bih.biCompression=fourCC::get((uint8_t *)"VP6F");break;
+      case FLV_CODECID_VP6A:
+                        _videostream.fccHandler=_video_bih.biCompression=fourCC::get((uint8_t *)"VP6A");break;
     //???   case FLV_CODECID_SCREEN:          _videostream.fccHandler=_video_bih.biCompression=fourCC::get((uint8_t *)"VP6F");break;
       default :                         _videostream.fccHandler=_video_bih.biCompression=fourCC::get((uint8_t *)"XXX");break;
 
     }
-    if(codec==FLV_CODECID_VP6)
+    if(codec==FLV_CODECID_VP6A && metaWidth && metaHeight )
     {
+         _video_bih.biHeight=_mainaviheader.dwHeight=metaHeight ;
+         _video_bih.biWidth=_mainaviheader.dwWidth=metaWidth;
+    }
+    if(codec==FLV_CODECID_VP6 )
+    {
         read8();
         read8();
         *remaining-=2;
@@ -585,6 +602,9 @@
     _audioStream=NULL;
     access=NULL;
     memset(&wavHeader,0,sizeof(wavHeader));
+    metaWidth=0;
+    metaHeight=0;
+    metaFps1000=0;
 
 }
 /**

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Flv/ADM_flv.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Flv/ADM_flv.h	2009-08-19 17:38:04 UTC (rev 5256)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Flv/ADM_flv.h	2009-08-21 15:32:53 UTC (rev 5257)
@@ -60,7 +60,10 @@
                 flvTrak          *_track;
                 uint32_t         currentBlock;
                 bool             goToBlock(uint32_t block);
+
+
                 
+                
 public:
                                   ADM_flvAccess(const char *name,flvTrak *trak); 
                 virtual           ~ADM_flvAccess();
@@ -99,7 +102,8 @@
     ADM_audioStream         *_audioStream;
     ADM_flvAccess           *access;
     /* */
-    
+    uint32_t            metaWidth,metaHeight,metaFps1000;
+
     uint8_t     read(uint32_t len, uint8_t *where);
     uint8_t     read8(void);
     uint32_t    read16(void);



From mean at mail.berlios.de  Fri Aug 21 17:32:55 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Fri, 21 Aug 2009 17:32:55 +0200
Subject: [Avidemux-svn-commit] r5258 -
	branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs
Message-ID: <200908211532.n7LFWt2x027615@sheep.berlios.de>

Author: mean
Date: 2009-08-21 17:32:55 +0200 (Fri, 21 Aug 2009)
New Revision: 5258

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_codecs.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_ffmp43.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_ffmp43.h
Log:
[codec] Support for VP6A + yuv420A colorspac

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_codecs.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_codecs.cpp	2009-08-21 15:32:53 UTC (rev 5257)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_codecs.cpp	2009-08-21 15:32:55 UTC (rev 5258)
@@ -265,7 +265,11 @@
       return (decoders *) (new decoderFFAMV (w, h,extraLen,extraData));
     }
 
-
+ if (fourCC::check (fcc, (uint8_t *) "VP6A"))
+    {
+      printf ("\n using YUY2 codec\n");
+      return (decoders *) (new decoderFFVP6A (w, h,extraLen,extraData));
+    }
   if (isVP6Compatible(fcc))
     {
       printf ("\n using VP6F codec\n");

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_ffmp43.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_ffmp43.cpp	2009-08-21 15:32:53 UTC (rev 5257)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_ffmp43.cpp	2009-08-21 15:32:55 UTC (rev 5258)
@@ -461,6 +461,7 @@
       break;
     case PIX_FMT_YUV420P:
     case PIX_FMT_YUVJ420P:
+    case PIX_FMT_YUVA420P:
       // Default is YV12 or I420
       // In that case depending on swap u/v
       // we do it or not
@@ -727,6 +728,12 @@
 {
   WRAP_Open (CODEC_ID_VP6F);
 }
+//*************
+decoderFFVP6A::decoderFFVP6A (uint32_t w, uint32_t h, uint32_t l, uint8_t * d):decoderFF (w,	   h)
+{
+  WRAP_Open (CODEC_ID_VP6A);
+}
+
 //************
 decoderFFFLV1::decoderFFFLV1 (uint32_t w, uint32_t h, uint32_t l, uint8_t * d):decoderFF (w,	   h)
 {

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_ffmp43.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_ffmp43.h	2009-08-21 15:32:53 UTC (rev 5257)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_codecs/ADM_ffmp43.h	2009-08-21 15:32:55 UTC (rev 5258)
@@ -322,6 +322,12 @@
 public:
   decoderFFVP6F (uint32_t w, uint32_t h, uint32_t l, uint8_t * d);
 };
+class decoderFFVP6A:public decoderFF
+{
+protected:
+public:
+  decoderFFVP6A (uint32_t w, uint32_t h, uint32_t l, uint8_t * d);
+};
 class decoderFFFLV1:public decoderFF
 {
 protected:



From mean at mail.berlios.de  Fri Aug 21 17:32:58 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Fri, 21 Aug 2009 17:32:58 +0200
Subject: [Avidemux-svn-commit] r5259 -
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf
Message-ID: <200908211532.n7LFWwjJ027630@sheep.berlios.de>

Author: mean
Date: 2009-08-21 17:32:56 +0200 (Fri, 21 Aug 2009)
New Revision: 5259

Added:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asfHeaders.cpp
Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asf.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asf.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asfAudio.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asfPacket.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/CMakeLists.txt
Log:
[Asf/Demuxer] Incomplete asf demuxer

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asf.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asf.cpp	2009-08-21 15:32:55 UTC (rev 5258)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asf.cpp	2009-08-21 15:32:56 UTC (rev 5259)
@@ -29,9 +29,6 @@
 #define aprintf(...) {}
 #endif
 
-static const uint8_t asf_audio[16]={0x40,0x9e,0x69,0xf8,0x4d,0x5b,0xcf,0x11,0xa8,0xfd,0x00,0x80,0x5f,0x5c,0x44,0x2b};
-static const uint8_t asf_video[16]={0xc0,0xef,0x19,0xbc,0x4d,0x5b,0xcf,0x11,0xa8,0xfd,0x00,0x80,0x5f,0x5c,0x44,0x2b};
-
 /**
     \fn getAudioInfo
 */
@@ -309,11 +306,7 @@
             delete bit;
             if(delta<230)
             {
-              printf("Very suspicious\n");
-              printf("Very suspicious\n");
-              printf("Very suspicious\n");
-              printf("Very suspicious\n");
-              printf("Very suspicious\n");
+              printf("[ASF] Very suspicious delta :%"LU"\n",delta);
             }
             continue; 
           }
@@ -364,449 +357,4 @@
     __________________________________________________________
 */
 
-/** *****************************************
-    \fn getHeaders
-    \brief Read Headers to collect information 
-********************************************/
-uint8_t asfHeader::getHeaders(void)
-{
-  uint32_t i=0,nbSubChunk,hi,lo;
-  const chunky *id;
-  uint8_t gid[16];
-  uint32_t mn=0,mx=0;
-  asfChunk chunk(_fd);
-  // The first header is header chunk
-  chunk.nextChunk();
-  id=chunk.chunkId();
-  if(id->id!=ADM_CHUNK_HEADER_CHUNK)
-  {
-    printf("[ASF] expected header chunk\n"); 
-    return 0;
-  }
-  printf("[ASF] getting headers\n");
-  chunk.dump();
-  nbSubChunk=chunk.read32();
-  printf("NB subchunk :%u\n",nbSubChunk);
-  chunk.read8();
-  chunk.read8();
-  for(i=0;i<nbSubChunk;i++)
-  {
-    asfChunk *s=new asfChunk(_fd);
-    uint32_t skip;
-    s->nextChunk();
-    printf("***************\n");  
-    id=s->chunkId();
-    s->dump();
-    switch(id->id)
-    {
-#if 0      
-      case ADM_CHUNK_HEADER_EXTENSION_CHUNK:
-      {
-        s->skip(16); // Clock type extension ????
-        printf("?? %d\n",s->read16());
-        printf("?? %d\n",s->read32());
-          
-        uint32_t streamNameCount;
-        uint32_t payloadCount;
-          
-          asfChunk *u=new asfChunk(_fd);
-          for(int zzz=0;zzz<8;zzz++)
-          {
-              u->nextChunk();
-              u->dump();
-              id=u->chunkId();
-              if(id->id==ADM_CHUNK_EXTENDED_STREAM_PROP)
-              {
-                  s->skip(8); // start time 
-                  s->skip(8); // end time
-                  printf("Bitrate         %u :\n",u->read32());
-                  printf("Buffer Size     %u :\n",u->read32());
-                  printf("BFill           %u :\n",u->read32());
-                  printf("Alt Bitrate     %u :\n",u->read32());
-                  printf("Alt Bsize       %u :\n",u->read32());
-                  printf("Alt Bfullness   %u :\n",u->read32());
-                  printf("Max object Size %u :\n",u->read32());
-                  printf("Flags           0x%x :\n",u->read32());
-                  printf("Stream no       %u :\n",u->read16());
-                  printf("Stream lang     %u :\n",u->read16());
-                  printf("Stream time/fra %lu :\n",u->read64());
-                  streamNameCount=u->read16();
-                  payloadCount=u->read16();
-                  printf("Stream Nm Count %u :\n",streamNameCount);
-                  printf("Payload count   %u :\n",payloadCount);
-                  for(int stream=0;stream<streamNameCount;stream++)
-                  {
-                    u->read16();
-                    skip=u->read16();
-                    u->skip(skip);
-                  }
-                  uint32_t size;
-                  for(int payload=0;payload<payloadCount;payload++)
-                  {
-                    for(int pp=0;pp<16;pp++) printf("0x%02x,",u->read8());
-                    printf("\n");
-                    skip=u->read16();
-                    size=u->read32();
-                    u->skip(size);
-                    printf("Extra Data : %d, skipd %d\n",size,skip);
-                  }
-                  printf("We are at %x\n",ftello(_fd));
-                }
-                u->skipChunk();
-          }
-          delete u;
-      }
-      break;
-#endif      
-      case ADM_CHUNK_FILE_HEADER_CHUNK:
-        {
-            // Client GID
-            printf("Client        :");
-            for(int z=0;z<16;z++) printf(":%02x",s->read8());
-            printf("\n");
-            printf("File size     : %08lx\n",s->read64());
-            printf("Creation time : %08lx\n",s->read64());
-            printf("Number of pack: %08lx\n",s->read64());
-            printf("Timestamp 1   : %08lx\n",s->read64());
-            _duration=s->read64();
-            printf("Timestamp 2   : %08lx\n",_duration);
-            printf("Timestamp 3   : %04x\n",s->read32());
-            printf("Preload       : %04x\n",s->read32());
-            printf("Flags         : %04x\n",s->read32());
-            mx=s->read32();
-            mn=s->read32();
-            if(mx!=mn)
-            {
-              printf("Variable packet size!!\n");
-              delete s;
-              return 0; 
-            }
-            _packetSize=mx;
-            printf("Min size      : %04x\n",mx);
-            printf("Max size      : %04x\n",mn);
-            printf("Uncompres.size: %04x\n",s->read32());
-          }
-          break;
-      case ADM_CHUNK_STREAM_HEADER_CHUNK:
-      {
-         // Client GID
-        uint32_t audiovideo=0; // video=1, audio=2, 0=unknown
-        uint32_t sid;
-        s->read(gid,16);
-        printf("Type            :");
-        for(int z=0;z<16;z++) printf("0x%02x,",gid[z]);
-        if(!memcmp(gid,asf_video,16))
-        {
-          printf("(video)");
-          audiovideo=1;
-        } else
-        {
-          if(!memcmp(gid,asf_audio,16))
-          {
-            printf("(audio)"); 
-            audiovideo=2;
-          } else printf("(? ? ? ?)"); 
-        }
-        printf("\nConceal       :");
-        for(int z=0;z<16;z++) printf(":%02x",s->read8());
-        printf("\n");
-        printf("Reserved    : %08"LLX"\n",s->read64());
-        printf("Total Size  : %04"LX"\n",s->read32());
-        printf("Size        : %04"LX"\n",s->read32());
-        sid=s->read16();
-        printf("Stream nb   : %04d\n",sid);
-        printf("Reserved    : %04"LX"\n",s->read32());
-        switch(audiovideo)
-        {
-          case 1: // Video
-          {
-                    _videoStreamId=sid;
-                    if(!loadVideo(s))
-                    {
-                      delete s;
-                      return 0; 
-                    }
-                    break;
-          }
-              break;
-          case 2: // audio
-          {
-            asfAudioTrak *trk=&(_allAudioTracks[_nbAudioTrack]);
-            ADM_assert(_nbAudioTrack<ASF_MAX_AUDIO_TRACK);
-            trk->streamIndex=sid;
-            s->read((uint8_t *)&(trk->wavHeader),sizeof(WAVHeader));
-            printf("[Asf] Encoding for audio 0x%x\n",trk->wavHeader.encoding);
-		#ifdef ADM_BIG_ENDIAN
-			Endian_WavHeader(&(trk->wavHeader));
-		#endif
-
-            trk->extraDataLen=s->read16();
-            printf("Extension :%u bytes\n",trk->extraDataLen);
-            if(trk->extraDataLen)
-            {
-              trk->extraData=new uint8_t[trk->extraDataLen];
-              s->read(trk->extraData,trk->extraDataLen);
-            }
-              printf("#block in group   :%d\n",s->read8());
-              printf("#byte in group    :%d\n",s->read16());
-              printf("Align1            :%d\n",s->read16());
-              printf("Align2            :%d\n",s->read16());
-              _nbAudioTrack++;
-            
-          }
-          break;
-          default:break; 
-          
-        }
-      }
-      break;
-       default:
-         break;
-    }
-    s->skipChunk();
-    delete s;
-  }
-  printf("End of headers\n");
-  return 1;
-}
-/**
-    \fn loadVideo
-*/
-
-uint8_t asfHeader::loadVideo(asfChunk *s)
-{
-  uint32_t w,h,x;
-            w=s->read32();
-            h=s->read32();
-            s->read8();
-            x=s->read16();
-            _isvideopresent=1;
-
-            memset(&_mainaviheader,0,sizeof(_mainaviheader));
-            _mainaviheader.dwWidth=w;
-            _mainaviheader.dwHeight=h;
-            _video_bih.biWidth=w;
-            _video_bih.biHeight=h;
-            printf("Pic Width  %04d\n",w);
-            printf("Pic Height %04d\n",h);
-            printf(" BMP size  %04d (%04d)\n",x,(int)sizeof(ADM_BITMAPINFOHEADER));
-            s->read((uint8_t *)&_video_bih,sizeof(ADM_BITMAPINFOHEADER));
-
-		#ifdef ADM_BIG_ENDIAN
-			Endian_BitMapInfo(&_video_bih);
-		#endif
-
-            _videostream.dwScale=1000;
-            _videostream.dwRate=30000;
-
-            _videostream.fccHandler=_video_bih.biCompression;
-            printf("Codec : <%s> (%04x)\n",
-                    fourCC::tostring(_video_bih.biCompression),_video_bih.biCompression);
-            if(fourCC::check(_video_bih.biCompression,(uint8_t *)"DVR "))
-            {
-              // It is MS DVR, fail so that the mpeg2 indexer can take it from here
-              _videostream.fccHandler=_video_bih.biCompression=fourCC::get((uint8_t *)"MPEG");
-              printf("This is MSDVR, not ASF\n");
-              return 0; 
-            }
-            printBih(&_video_bih);
-            if(x>sizeof(ADM_BITMAPINFOHEADER))
-            {
-              _videoExtraLen=x-sizeof(ADM_BITMAPINFOHEADER);
-              _videoExtraData=new uint8_t[_videoExtraLen];
-              s->read(_videoExtraData,_videoExtraLen);
-            }
-            return 1;
-}
-/**
-    \fn      buildIndex
-    \brief   Scan the file to build an index
-    
-    Header Chunk
-            Chunk
-            Chunk
-            Chunk
-            
-    Data chunk
-            Chunk
-            Chunk
-            
-    We skip the 1st one, and just read the header of the 2nd one
-    
-*/
-uint8_t asfHeader::buildIndex(void)
-{
-  uint32_t fSize;
-  const chunky *id;
-  uint32_t chunkFound;
-  uint32_t r=5;
-  uint32_t len;
-  
-  fseeko(_fd,0,SEEK_END);
-  fSize=ftello(_fd);
-  fseeko(_fd,0,SEEK_SET);
-  
-  asfChunk h(_fd);
-  printf("[ASF] ********** Building index **********\n");
-  printf("[ASF] Searching data\n");
-  while(r--)
-  {
-    h.nextChunk();    // Skip headers
-    id=h.chunkId();
-    h.dump();
-    if(id->id==ADM_CHUNK_DATA_CHUNK) break;
-    h.skipChunk();
-  }
-  if(id->id!=ADM_CHUNK_DATA_CHUNK) return 0;
-  // Remove leftover from DATA_chunk
- // Unknown	GUID	16
-//       Number of packets	UINT64	8
-//       Unknown	UINT8	1
-//       Unknown	UINT8	1
-//   
-  h.read32();
-  h.read32();
-  h.read32();
-  h.read32();
-  _nbPackets=(uint32_t) h.read64();
-  h.read16();
-  
-  len=h.chunkLen-16-8-2-24;
-  
-  printf("[ASF] nbPacket  : %u\n",_nbPackets);
-  printf("[ASF] len to go : %u\n",len);
-  printf("[ASF] scanning data\n");
-  _dataStartOffset=ftello(_fd);
-  
-  // Here we go
-  //DIA_working *working=new DIA_working("indexing asf");
-  asfPacket *aPacket=new asfPacket(_fd,_nbPackets,_packetSize,
-                                   &readQueue,_dataStartOffset);
-  uint32_t packet=1;
-#define MAXIMAGE (_nbPackets)
-  uint32_t sequence=1;
-  uint32_t ceilImage=MAXIMAGE;
-
-  nbImage=0;
-  
-  len=0;
-  asfIndex indexEntry;
-  memset(&indexEntry,0,sizeof(indexEntry));
-  bool first=true;
-  while(packet<_nbPackets)
-  {
-    while(!readQueue.isEmpty())
-    {
-      asfBit *bit=NULL;
-      
-      ADM_assert(readQueue.pop((void**)&bit));
-      uint64_t dts=bit->dts;
-      if(bit->stream==_videoStreamId)
-      {
-          aprintf(">found packet of size %d seq %d, while curseq =%d\n",bit->len,bit->sequence,curSeq);
-          if(bit->sequence!=sequence || first==true)
-          {
-            if(first==false)
-            {
-                indexEntry.frameLen=len;
-                _index.push_back(indexEntry);
-            }
-            first=false;
-            aprintf("New sequence\n");
-            if( ((sequence+1)&0xff)!=(bit->sequence&0xff))
-            {
-                printf("!!!!!!!!!!!! non continuous sequence %u %u\n",sequence,bit->sequence); 
-    #if 0         
-                // Let's insert a couple of null frame
-                int32_t delta,start,end;
-                
-                start=256+bit->sequence-sequence-1;
-                start&=0xff;
-                printf("!!!!!!!!!!!! Delta %d\n",start);
-                
-                for(int filler=0;filler<start;filler++)
-                {
-                  tmpIndex[++nbImage].frameLen=0;
-                }
-    #endif            
-            }
-            
-            
-            indexEntry.frameLen=0;
-            indexEntry.segNb=bit->sequence;
-            indexEntry.packetNb=bit->packet;
-            indexEntry.flags=bit->flags;
-            indexEntry.dts=dts;
-            indexEntry.pts=ADM_NO_PTS;
-
-            for(int z=0;z<_nbAudioTrack;z++)
-            {
-              indexEntry.audioSeen[z]=_allAudioTracks[z].length;
-              indexEntry.audioDts[z]=_allAudioTracks[z].lastDts;
-            }
-            readQueue.pushBack(bit);
-    
-            sequence=bit->sequence;
-            len=0;
-            continue;
-          }
-          len+=bit->len;
-      } // End of video stream Id
-      else  // Audio ?
-      {
-        int found=0;
-        for(int i=0;i<_nbAudioTrack && !found;i++)
-        {
-          if(bit->stream == _allAudioTracks[i].streamIndex)
-          {
-            
-            _allAudioTracks[i].length+=bit->len;
-            _allAudioTracks[i].lastDts=bit->dts;
-            
-            found=1;
-          }
-        }
-        if(!found) 
-        {
-          printf("Unmapped stream %u\n",bit->stream); 
-        }
-      }
-     delete[] bit->data;
-     delete bit;
-    }
-    //working->update(packet,_nbPackets);
-
-    packet++;
-    aPacket->nextPacket(0xff); // All packets
-    aPacket->skipPacket();
-  }
-  delete aPacket;
-  //delete working;
-  /* Compact index */
-  
-  fseeko(_fd,_dataStartOffset,SEEK_SET);
-  printf("[ASF] %u images found\n",nbImage);
-  printf("[ASF] ******** End of buildindex *******\n");
-
-  nbImage=_index.size();;
-
-  _videostream.dwLength=_mainaviheader.dwTotalFrames=nbImage;
-  if(!nbImage) return 0;
-  
-  // Update fps
-  // In fact it is an average fps
-  //
-  float f=_index[nbImage-1].dts;
-   f/=nbImage; // average duration of 1 image in us
-    if(f<10) f=10;
-   f=1000000.*1000./f;
-  uint32_t avgFps=(uint32_t) f;
-    printf("[Asf] Average fps=%d\n",avgFps);
-  
-  _videostream.dwScale=1000;
-  _videostream.dwRate=(uint32_t)avgFps;;
-
-  return 1;
-  
-}
 //EOF

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asf.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asf.h	2009-08-21 15:32:55 UTC (rev 5258)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asf.h	2009-08-21 15:32:56 UTC (rev 5259)
@@ -150,6 +150,7 @@
     uint8_t                 getHeaders( void);
     uint8_t                 buildIndex(void);
     uint8_t                 loadVideo(asfChunk *s);
+    bool                    loadAudio(asfChunk *s,uint32_t sid);
     
     ADM_queue               readQueue;
     uint32_t                curSeq;

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asfAudio.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asfAudio.cpp	2009-08-21 15:32:55 UTC (rev 5258)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asfAudio.cpp	2009-08-21 15:32:56 UTC (rev 5259)
@@ -65,7 +65,6 @@
                           &readQueue,_dataStart);
     
     printf("[asfAudio] Length %u\n",getLength());
-  
 }
 
 uint64_t  asfAudioAccess::getPos(void)
@@ -121,7 +120,7 @@
     {
         if(dts_us>=(*idx)[i].audioDts[_myRank] && dts_us<(*idx)[i+1].audioDts[_myRank])
         {
-            return setPos( (*idx)[i].packetNb);
+            return _packet->goToPacket( (*idx)[i].packetNb);
         }
     }
     return false;
@@ -148,8 +147,8 @@
       // still same sequence ...add
       memcpy(dest,bit->data,bit->len);
       *len=bit->len;
-      *dts=bit->dts;
-	  delete[] bit->data;
+      *dts=ADM_NO_PTS;
+      delete[] bit->data;
       delete bit;
       return 1;
     }
@@ -160,7 +159,8 @@
       printf("[ASF] Audio Packet Error\n");
       return 0; 
     }
-    _packet->skipPacket();
+    
+   // _packet->skipPacket();
   }
   
   return 0; 

Copied: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asfHeaders.cpp (from rev 5258, branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asf.cpp)
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asf.cpp	2009-08-21 15:32:55 UTC (rev 5258)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asfHeaders.cpp	2009-08-21 15:32:56 UTC (rev 5259)
@@ -0,0 +1,489 @@
+/** *************************************************************************
+    \file ADM_asf.cpp
+    \brief ASF/WMV demuxer
+    copyright            : (C) 2006/2009 by mean
+    email                : fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include "ADM_default.h"
+#include "ADM_Video.h"
+#include "ADM_assert.h"
+
+#include "fourcc.h"
+#include "DIA_coreToolkit.h"
+#include "ADM_asf.h"
+#include "ADM_asfPacket.h"
+
+#if 0
+#define aprintf printf
+#else
+#define aprintf(...) {}
+#endif
+
+static const uint8_t asf_audio[16]={0x40,0x9e,0x69,0xf8,0x4d,0x5b,0xcf,0x11,0xa8,0xfd,0x00,0x80,0x5f,0x5c,0x44,0x2b};
+static const uint8_t asf_video[16]={0xc0,0xef,0x19,0xbc,0x4d,0x5b,0xcf,0x11,0xa8,0xfd,0x00,0x80,0x5f,0x5c,0x44,0x2b};
+
+/** *****************************************
+    \fn getHeaders
+    \brief Read Headers to collect information 
+********************************************/
+uint8_t asfHeader::getHeaders(void)
+{
+  uint32_t i=0,nbSubChunk,hi,lo;
+  const chunky *id;
+  uint8_t gid[16];
+  uint32_t mn=0,mx=0;
+  asfChunk chunk(_fd);
+  // The first header is header chunk
+  chunk.nextChunk();
+  id=chunk.chunkId();
+  if(id->id!=ADM_CHUNK_HEADER_CHUNK)
+  {
+    printf("[ASF] expected header chunk\n"); 
+    return 0;
+  }
+  printf("[ASF] getting headers\n");
+  chunk.dump();
+  nbSubChunk=chunk.read32();
+  printf("NB subchunk :%u\n",nbSubChunk);
+  chunk.read8();
+  chunk.read8();
+  for(i=0;i<nbSubChunk;i++)
+  {
+    asfChunk *s=new asfChunk(_fd);
+    uint32_t skip;
+    s->nextChunk();
+    printf("***************\n");  
+    id=s->chunkId();
+    s->dump();
+    switch(id->id)
+    {
+#if 0      
+      case ADM_CHUNK_HEADER_EXTENSION_CHUNK:
+      {
+        s->skip(16); // Clock type extension ????
+        printf("?? %d\n",s->read16());
+        printf("?? %d\n",s->read32());
+          
+        uint32_t streamNameCount;
+        uint32_t payloadCount;
+          
+          asfChunk *u=new asfChunk(_fd);
+          for(int zzz=0;zzz<8;zzz++)
+          {
+              u->nextChunk();
+              u->dump();
+              id=u->chunkId();
+              if(id->id==ADM_CHUNK_EXTENDED_STREAM_PROP)
+              {
+                  s->skip(8); // start time 
+                  s->skip(8); // end time
+                  printf("Bitrate         %u :\n",u->read32());
+                  printf("Buffer Size     %u :\n",u->read32());
+                  printf("BFill           %u :\n",u->read32());
+                  printf("Alt Bitrate     %u :\n",u->read32());
+                  printf("Alt Bsize       %u :\n",u->read32());
+                  printf("Alt Bfullness   %u :\n",u->read32());
+                  printf("Max object Size %u :\n",u->read32());
+                  printf("Flags           0x%x :\n",u->read32());
+                  printf("Stream no       %u :\n",u->read16());
+                  printf("Stream lang     %u :\n",u->read16());
+                  printf("Stream time/fra %lu :\n",u->read64());
+                  streamNameCount=u->read16();
+                  payloadCount=u->read16();
+                  printf("Stream Nm Count %u :\n",streamNameCount);
+                  printf("Payload count   %u :\n",payloadCount);
+                  for(int stream=0;stream<streamNameCount;stream++)
+                  {
+                    u->read16();
+                    skip=u->read16();
+                    u->skip(skip);
+                  }
+                  uint32_t size;
+                  for(int payload=0;payload<payloadCount;payload++)
+                  {
+                    for(int pp=0;pp<16;pp++) printf("0x%02x,",u->read8());
+                    printf("\n");
+                    skip=u->read16();
+                    size=u->read32();
+                    u->skip(size);
+                    printf("Extra Data : %d, skipd %d\n",size,skip);
+                  }
+                  printf("We are at %x\n",ftello(_fd));
+                }
+                u->skipChunk();
+          }
+          delete u;
+      }
+      break;
+#endif      
+      case ADM_CHUNK_FILE_HEADER_CHUNK:
+        {
+            // Client GID
+            printf("Client        :");
+            for(int z=0;z<16;z++) printf(":%02x",s->read8());
+            printf("\n");
+            printf("File size     : %08lx\n",s->read64());
+            printf("Creation time : %08lx\n",s->read64());
+            printf("Number of pack: %08lx\n",s->read64());
+            printf("Timestamp 1   : %08lx\n",s->read64());
+            _duration=s->read64();
+            printf("Timestamp 2   : %08lx\n",_duration);
+            printf("Timestamp 3   : %04x\n",s->read32());
+            printf("Preload       : %04x\n",s->read32());
+            printf("Flags         : %04x\n",s->read32());
+            mx=s->read32();
+            mn=s->read32();
+            if(mx!=mn)
+            {
+              printf("Variable packet size!!\n");
+              delete s;
+              return 0; 
+            }
+            _packetSize=mx;
+            printf("Min size      : %04x\n",mx);
+            printf("Max size      : %04x\n",mn);
+            printf("Uncompres.size: %04x\n",s->read32());
+          }
+          break;
+      case ADM_CHUNK_STREAM_HEADER_CHUNK:
+      {
+         // Client GID
+        uint32_t audiovideo=0; // video=1, audio=2, 0=unknown
+        uint32_t sid;
+        s->read(gid,16);
+        printf("Type            :");
+        for(int z=0;z<16;z++) printf("0x%02x,",gid[z]);
+        if(!memcmp(gid,asf_video,16))
+        {
+          printf("(video)");
+          audiovideo=1;
+        } else
+        {
+          if(!memcmp(gid,asf_audio,16))
+          {
+            printf("(audio)"); 
+            audiovideo=2;
+          } else printf("(? ? ? ?)"); 
+        }
+        printf("\nConceal       :");
+        for(int z=0;z<16;z++) printf(":%02x",s->read8());
+        printf("\n");
+        printf("Reserved    : %08"LLX"\n",s->read64());
+        printf("Total Size  : %04"LX"\n",s->read32());
+        printf("Size        : %04"LX"\n",s->read32());
+        sid=s->read16();
+        printf("Stream nb   : %04d\n",sid);
+        printf("Reserved    : %04"LX"\n",s->read32());
+        switch(audiovideo)
+        {
+          case 1: // Video
+          {
+                    _videoStreamId=sid;
+                    if(!loadVideo(s))
+                    {
+                      delete s;
+                      return 0; 
+                    }
+                    break;
+          }
+              break;
+          case 2: // audio
+          {
+            loadAudio(s,sid);
+          
+            
+          }
+          break;
+          default:break; 
+          
+        }
+      }
+      break;
+       default:
+         break;
+    }
+    s->skipChunk();
+    delete s;
+  }
+  printf("End of headers\n");
+  return 1;
+}
+/**
+    \fn loadAudio
+*/
+
+bool asfHeader::loadAudio(asfChunk *s,uint32_t sid)
+{
+  asfAudioTrak *trk=&(_allAudioTracks[_nbAudioTrack]);
+    ADM_assert(_nbAudioTrack<ASF_MAX_AUDIO_TRACK);
+    trk->streamIndex=sid;
+    s->read((uint8_t *)&(trk->wavHeader),sizeof(WAVHeader));
+    printf("[Asf] Encoding for audio 0x%x\n",trk->wavHeader.encoding);
+#ifdef ADM_BIG_ENDIAN
+    Endian_WavHeader(&(trk->wavHeader));
+#endif
+
+    trk->extraDataLen=s->read16();
+    printf("Extension :%u bytes\n",trk->extraDataLen);
+    if(trk->extraDataLen)
+    {
+      trk->extraData=new uint8_t[trk->extraDataLen];
+      s->read(trk->extraData,trk->extraDataLen);
+    }
+      printf("#block in group   :%d\n",s->read8());
+      printf("#byte in group    :%d\n",s->read16());
+      printf("Align1            :%d\n",s->read16());
+      printf("Align2            :%d\n",s->read16());
+      _nbAudioTrack++;
+    return true;
+}
+/**
+    \fn loadVideo
+*/
+
+uint8_t asfHeader::loadVideo(asfChunk *s)
+{
+  uint32_t w,h,x;
+            w=s->read32();
+            h=s->read32();
+            s->read8();
+            x=s->read16();
+            _isvideopresent=1;
+
+            memset(&_mainaviheader,0,sizeof(_mainaviheader));
+            _mainaviheader.dwWidth=w;
+            _mainaviheader.dwHeight=h;
+            _video_bih.biWidth=w;
+            _video_bih.biHeight=h;
+            printf("Pic Width  %04d\n",w);
+            printf("Pic Height %04d\n",h);
+            printf(" BMP size  %04d (%04d)\n",x,(int)sizeof(ADM_BITMAPINFOHEADER));
+            s->read((uint8_t *)&_video_bih,sizeof(ADM_BITMAPINFOHEADER));
+
+		#ifdef ADM_BIG_ENDIAN
+			Endian_BitMapInfo(&_video_bih);
+		#endif
+
+            _videostream.dwScale=1000;
+            _videostream.dwRate=30000;
+
+            _videostream.fccHandler=_video_bih.biCompression;
+            printf("Codec : <%s> (%04x)\n",
+                    fourCC::tostring(_video_bih.biCompression),_video_bih.biCompression);
+            if(fourCC::check(_video_bih.biCompression,(uint8_t *)"DVR "))
+            {
+              // It is MS DVR, fail so that the mpeg2 indexer can take it from here
+              _videostream.fccHandler=_video_bih.biCompression=fourCC::get((uint8_t *)"MPEG");
+              printf("This is MSDVR, not ASF\n");
+              return 0; 
+            }
+            printBih(&_video_bih);
+            if(x>sizeof(ADM_BITMAPINFOHEADER))
+            {
+              _videoExtraLen=x-sizeof(ADM_BITMAPINFOHEADER);
+              _videoExtraData=new uint8_t[_videoExtraLen];
+              s->read(_videoExtraData,_videoExtraLen);
+            }
+            return 1;
+}
+/**
+    \fn      buildIndex
+    \brief   Scan the file to build an index
+    
+    Header Chunk
+            Chunk
+            Chunk
+            Chunk
+            
+    Data chunk
+            Chunk
+            Chunk
+            
+    We skip the 1st one, and just read the header of the 2nd one
+    
+*/
+uint8_t asfHeader::buildIndex(void)
+{
+  uint32_t fSize;
+  const chunky *id;
+  uint32_t chunkFound;
+  uint32_t r=5;
+  uint32_t len;
+  
+  fseeko(_fd,0,SEEK_END);
+  fSize=ftello(_fd);
+  fseeko(_fd,0,SEEK_SET);
+  
+  asfChunk h(_fd);
+  printf("[ASF] ********** Building index **********\n");
+  printf("[ASF] Searching data\n");
+  while(r--)
+  {
+    h.nextChunk();    // Skip headers
+    id=h.chunkId();
+    h.dump();
+    if(id->id==ADM_CHUNK_DATA_CHUNK) break;
+    h.skipChunk();
+  }
+  if(id->id!=ADM_CHUNK_DATA_CHUNK) return 0;
+  // Remove leftover from DATA_chunk
+ // Unknown	GUID	16
+//       Number of packets	UINT64	8
+//       Unknown	UINT8	1
+//       Unknown	UINT8	1
+//   
+  h.read32();
+  h.read32();
+  h.read32();
+  h.read32();
+  _nbPackets=(uint32_t) h.read64();
+  h.read16();
+  
+  len=h.chunkLen-16-8-2-24;
+  
+  printf("[ASF] nbPacket  : %u\n",_nbPackets);
+  printf("[ASF] len to go : %u\n",len);
+  printf("[ASF] scanning data\n");
+  _dataStartOffset=ftello(_fd);
+  
+  // Here we go
+  //DIA_working *working=new DIA_working("indexing asf");
+  asfPacket *aPacket=new asfPacket(_fd,_nbPackets,_packetSize,
+                                   &readQueue,_dataStartOffset);
+  uint32_t packet=1;
+#define MAXIMAGE (_nbPackets)
+  uint32_t sequence=1;
+  uint32_t ceilImage=MAXIMAGE;
+
+  nbImage=0;
+  
+  len=0;
+  asfIndex indexEntry;
+  memset(&indexEntry,0,sizeof(indexEntry));
+  bool first=true;
+  while(packet<_nbPackets)
+  {
+    while(!readQueue.isEmpty())
+    {
+      asfBit *bit=NULL;
+      
+      ADM_assert(readQueue.pop((void**)&bit));
+      uint64_t dts=bit->dts;
+      if(bit->stream==_videoStreamId)
+      {
+          aprintf(">found packet of size %d seq %d, while curseq =%d\n",bit->len,bit->sequence,curSeq);
+          if(bit->sequence!=sequence || first==true)
+          {
+            if(first==false)
+            {
+                indexEntry.frameLen=len;
+                _index.push_back(indexEntry);
+            }
+            first=false;
+            aprintf("New sequence\n");
+            if( ((sequence+1)&0xff)!=(bit->sequence&0xff))
+            {
+                printf("!!!!!!!!!!!! non continuous sequence %u %u\n",sequence,bit->sequence); 
+    #if 0         
+                // Let's insert a couple of null frame
+                int32_t delta,start,end;
+                
+                start=256+bit->sequence-sequence-1;
+                start&=0xff;
+                printf("!!!!!!!!!!!! Delta %d\n",start);
+                
+                for(int filler=0;filler<start;filler++)
+                {
+                  tmpIndex[++nbImage].frameLen=0;
+                }
+    #endif            
+            }
+            
+            
+            indexEntry.frameLen=0;
+            indexEntry.segNb=bit->sequence;
+            indexEntry.packetNb=bit->packet;
+            indexEntry.flags=bit->flags;
+            indexEntry.dts=dts;
+            indexEntry.pts=ADM_NO_PTS;
+
+            for(int z=0;z<_nbAudioTrack;z++)
+            {
+              indexEntry.audioSeen[z]=_allAudioTracks[z].length;
+              indexEntry.audioDts[z]=_allAudioTracks[z].lastDts;
+            }
+            readQueue.pushBack(bit);
+    
+            sequence=bit->sequence;
+            len=0;
+            continue;
+          }
+          len+=bit->len;
+      } // End of video stream Id
+      else  // Audio ?
+      {
+        int found=0;
+        for(int i=0;i<_nbAudioTrack && !found;i++)
+        {
+          if(bit->stream == _allAudioTracks[i].streamIndex)
+          {
+            
+            _allAudioTracks[i].length+=bit->len;
+            _allAudioTracks[i].lastDts=bit->dts;
+            
+            found=1;
+          }
+        }
+        if(!found) 
+        {
+          printf("Unmapped stream %u\n",bit->stream); 
+        }
+      }
+     delete[] bit->data;
+     delete bit;
+    }
+    //working->update(packet,_nbPackets);
+
+    packet++;
+    aPacket->nextPacket(0xff); // All packets
+    aPacket->skipPacket();
+  }
+  delete aPacket;
+  //delete working;
+  /* Compact index */
+  
+  fseeko(_fd,_dataStartOffset,SEEK_SET);
+  printf("[ASF] %u images found\n",nbImage);
+  printf("[ASF] ******** End of buildindex *******\n");
+
+  nbImage=_index.size();;
+
+  _videostream.dwLength=_mainaviheader.dwTotalFrames=nbImage;
+  if(!nbImage) return 0;
+  
+  // Update fps
+  // In fact it is an average fps
+  //
+  float f=_index[nbImage-1].dts;
+   f/=nbImage; // average duration of 1 image in us
+    if(f<10) f=10;
+   f=1000000.*1000./f;
+  uint32_t avgFps=(uint32_t) f;
+    printf("[Asf] Average fps=%d\n",avgFps);
+  
+  _videostream.dwScale=1000;
+  _videostream.dwRate=(uint32_t)avgFps;;
+
+  return 1;
+  
+}
\ No newline at end of file

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asfPacket.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asfPacket.cpp	2009-08-21 15:32:55 UTC (rev 5258)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/ADM_asfPacket.cpp	2009-08-21 15:32:56 UTC (rev 5259)
@@ -67,6 +67,7 @@
    uint32_t offset=_startDataOffset+packet*pakSize;
    fseeko(_fd,offset,SEEK_SET);
    currentPacket=packet;
+   purge();
    return 1;
  }
  /*

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/CMakeLists.txt	2009-08-21 15:32:55 UTC (rev 5258)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Asf/CMakeLists.txt	2009-08-21 15:32:56 UTC (rev 5259)
@@ -5,6 +5,7 @@
         ADM_asf.cpp  
         ADM_asfPacket.cpp
         ADM_asfPlugin.cpp
+        ADM_asfHeaders.cpp
 )
 
 ADD_LIBRARY(ADM_dm_asf SHARED ${ADM_asf_SRCS})



From mean at mail.berlios.de  Fri Aug 21 17:33:05 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Fri, 21 Aug 2009 17:33:05 +0200
Subject: [Avidemux-svn-commit] r5260 -
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Flv
Message-ID: <200908211533.n7LFX5K5027648@sheep.berlios.de>

Author: mean
Date: 2009-08-21 17:33:04 +0200 (Fri, 21 Aug 2009)
New Revision: 5260

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Flv/ADM_flv.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Flv/ADM_flv.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Flv/ADM_flvAudio.cpp
Log:
[flv/demuxer] Partial support for h264 & AAC in flv

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Flv/ADM_flv.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Flv/ADM_flv.cpp	2009-08-21 15:32:56 UTC (rev 5259)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Flv/ADM_flv.cpp	2009-08-21 15:33:04 UTC (rev 5260)
@@ -153,7 +153,7 @@
                                             hi=read32();lo=read32();
                                             hi=(hi<<32)+lo;
                                             val=(float)av_int2dbl(hi);
-                                            printf("->%f\n",val);
+                                            printf("->%f",val);
                                             setProperties(s,val);
                                         }
                                         ;break;
@@ -188,16 +188,51 @@
     }
     return delta;
 }
-
 /**
+    \fn extraHeader
+    \brief if returns true means we must skip the remainder
+*/
+bool flvHeader::extraHeader(flvTrak *trk,uint32_t *remain,bool have_cts,uint64_t *cts)
+{
+    int type=read8();
+    int r=*remain;
+    r--;
+    if(have_cts)
+    {
+        *cts=read24();
+        //printf("Type :%d\n",type);
+        r-=3;
+    }
+    if(!type)
+    {  // Grab extra data
+        if(trk->extraData) 
+        {
+            Skip(*remain);
+            r=0;
+        }
+        else    
+        {
+            printf("[FLV] found some extradata %"LU"\n",*remain);
+            trk->extraData=new uint8_t[*remain];
+            trk->extraDataLen=*remain;
+            read(*remain,trk->extraData);
+            r=0;            
+        }
+        *remain=r;
+        return true;
+    }
+    *remain=r;
+    return false;
+}
+/**
       \fn open
       \brief open the flv file, gather infos and build index(es).
 */
 
 uint8_t flvHeader::open(const char *name)
 {
-  uint32_t prevLen, type, size, pts,pos=0;
-
+  uint32_t prevLen, type, size, dts,pos=0;
+  bool firstVideo=true;
   _isvideopresent=0;
   _isaudiopresent=0;
   audioTrack=NULL;
@@ -260,14 +295,15 @@
   // Loop
   while(pos<fileSize-14)
   {
+    uint64_t cts;
     pos=ftello(_fd);
     prevLen=read32();
     type=read8();
     size=read24();
-    pts=read24();
+    dts=read24();
     read32(); // ???
     uint32_t remaining=size;
-    //printf("[FLV] At %08x found type %x size %u pts%u\n",pos,type,size,pts);
+    //printf("[FLV] At %08x found type %x size %u pts%u\n",pos,type,size,dts);
     switch(type)
     {
       case FLV_TAG_TYPE_AUDIO:
@@ -288,7 +324,12 @@
             {
                setAudioHeader(format,fq,bps,channel);
             }
-            insertAudio(pos+of,remaining,pts);
+            if(format==10)
+            {
+                if(extraHeader(audioTrack,&remaining,false,&cts)) continue;
+            }
+            if(remaining)
+                insertAudio(pos+of,remaining,dts);
           }
           break;
       case FLV_TAG_TYPE_META:
@@ -298,6 +339,7 @@
       case FLV_TAG_TYPE_VIDEO:
           {
             int of=1+4+3+3+1+4;
+            
             uint8_t flags=read8();
             remaining--;
             int frameType=flags>>4;
@@ -310,14 +352,19 @@
               remaining--;
               of++;
             }
-            int first=0;
-            if(!videoTrack->_nbIndex) first=1;
-            insertVideo(pos+of,remaining,frameType,pts);
-            if(first) // first frame..
+            
+            if(firstVideo==true) // first frame..
             {
                 if(!setVideoHeader(codec,&remaining)) return 0;
+                firstVideo=false;
             }
+            if(codec==FLV_CODECID_H264)
+            {
+                if(true==extraHeader(videoTrack,&remaining,true,&cts)) continue;
 
+            }
+            if(remaining)
+                insertVideo(pos+of,remaining,frameType,dts);
           }
            break;
       default: printf("[FLV]At 0x%x, unhandled type %u\n",pos,type);
@@ -393,40 +440,33 @@
 uint8_t flvHeader::setVideoHeader(uint8_t codec,uint32_t *remaining)
 {
     printf("[FLV] Video Codec:%u\n",codec);
-     _video_bih.biWidth=_mainaviheader.dwWidth=320;
+     
+    _video_bih.biWidth=_mainaviheader.dwWidth=320;
     _video_bih.biHeight=_mainaviheader.dwHeight=240;
+#define MKFLV(x,t) case FLV_CODECID_##x :  _videostream.fccHandler=_video_bih.biCompression=\
+                            fourCC::get((uint8_t *)#t);break;
     switch(codec)
     {
-      case FLV_CODECID_H263:            _videostream.fccHandler=_video_bih.biCompression=fourCC::get((uint8_t *)"FLV1");break;
-      case FLV_CODECID_VP6:
-                        _videostream.fccHandler=_video_bih.biCompression=fourCC::get((uint8_t *)"VP6F");break;
-      case FLV_CODECID_VP6A:
-                        _videostream.fccHandler=_video_bih.biCompression=fourCC::get((uint8_t *)"VP6A");break;
-    //???   case FLV_CODECID_SCREEN:          _videostream.fccHandler=_video_bih.biCompression=fourCC::get((uint8_t *)"VP6F");break;
-      default :                         _videostream.fccHandler=_video_bih.biCompression=fourCC::get((uint8_t *)"XXX");break;
-
+        MKFLV(H264,H264);
+        MKFLV(H263,FLV1);
+        MKFLV(VP6,VP6F);
+        MKFLV(VP6A,VP6A);
+        default : _videostream.fccHandler=_video_bih.biCompression=fourCC::get((uint8_t *)"XXX");break;
     }
-    if(codec==FLV_CODECID_VP6A && metaWidth && metaHeight )
-    {
-         _video_bih.biHeight=_mainaviheader.dwHeight=metaHeight ;
-         _video_bih.biWidth=_mainaviheader.dwWidth=metaWidth;
-    }
-    if(codec==FLV_CODECID_VP6 )
-    {
-        read8();
-        read8();
-        *remaining-=2;
-
-         _video_bih.biHeight=_mainaviheader.dwHeight=read8()*16;
-         _video_bih.biWidth=_mainaviheader.dwWidth=read8()*16;
-        *remaining-=2;
-    }
+    if( metaWidth && metaHeight )
+        if( codec==FLV_CODECID_VP6A  || codec==FLV_CODECID_H264 || codec==FLV_CODECID_VP6) 
+        {
+                _video_bih.biHeight=_mainaviheader.dwHeight=metaHeight ;
+                _video_bih.biWidth=_mainaviheader.dwWidth=metaWidth;
+        }
     if(codec==FLV_CODECID_H263)
     {
+  
+      uint32_t pos=ftello(_fd);
       uint32_t len=*remaining,width,height;
       uint8_t buffer[len];
       read(len,buffer);
-      *remaining=0;
+      fseeko(_fd,pos,SEEK_SET);
        /* Decode header, from h263dec.c / lavcodec*/
       if(extractH263FLVInfo(buffer,len,&width,&height))
       {
@@ -461,6 +501,7 @@
     case 3: wavHeader.encoding=WAV_PCM;break;
     case 0: wavHeader.encoding=WAV_LPCM;break;
     case 1: wavHeader.encoding=WAV_MSADPCM;break;
+    case 10:wavHeader.encoding=WAV_AAC;break;
     default:
           printf("[FLV]Unsupported audio codec:%u\n",format);
   }
@@ -485,13 +526,13 @@
       \fn insertVideo
       \brief add a frame to the index, grow the index if needed
 */
-uint8_t flvHeader::insertVideo(uint32_t pos,uint32_t size,uint32_t frameType,uint32_t pts)
+uint8_t flvHeader::insertVideo(uint32_t pos,uint32_t size,uint32_t frameType,uint32_t dts)
 {
     videoTrack->grow();
     flvIndex *x=&(videoTrack->_index[videoTrack->_nbIndex]);
     x->size=size;
     x->pos=pos;
-    x->timeCodeUs=pts*1000LL;
+    x->timeCodeUs=dts*1000LL;
     if(frameType==1)
     {
         x->flags=AVI_KEY_FRAME;
@@ -575,11 +616,21 @@
 uint8_t flvHeader::close(void)
 {
   if(_filename) ADM_dealloc(_filename);
-  if(videoTrack) delete videoTrack;
-  if(audioTrack) delete audioTrack;
+  if(videoTrack) 
+  {
+        if(videoTrack->extraData) delete [] videoTrack->extraData;
+        delete videoTrack;
+  }
+  if(audioTrack) 
+  {
+     if(audioTrack->extraData) delete [] audioTrack->extraData;
+    delete audioTrack;
+  }
   if(_fd) fclose(_fd);
   if(_audioStream) delete _audioStream;
   if(access) delete access;
+  
+  
   _fd=NULL;
   _filename=NULL;
   videoTrack=NULL;
@@ -683,9 +734,15 @@
 */
 uint8_t  flvHeader::getExtraHeaderData(uint32_t *len, uint8_t **data)
 {
-                *len=0; //_tracks[0].extraDataLen;
-                *data=NULL; //_tracks[0].extraData;
+        if(videoTrack)
+        {
+                *len=videoTrack->extraDataLen;
+                *data=videoTrack->extraData;
                 return 1;
+        }
+        *len=0;
+        *data=NULL;
+        return 1;
 }
 
 /**

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Flv/ADM_flv.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Flv/ADM_flv.h	2009-08-21 15:32:56 UTC (rev 5259)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Flv/ADM_flv.h	2009-08-21 15:33:04 UTC (rev 5260)
@@ -81,7 +81,7 @@
                 virtual bool      goToTime(uint64_t timeUs);
                 virtual bool      getPacket(uint8_t *buffer, uint32_t *size, uint32_t maxSize,uint64_t *dts);
 
-
+                bool              getExtraData(uint32_t *l, uint8_t **d);
 };
 
 
@@ -114,8 +114,8 @@
     uint8_t     insertAudio(uint32_t pos,uint32_t size,uint32_t pts);
     uint8_t     setAudioHeader(uint32_t format,uint32_t fq,uint32_t bps,uint32_t channels);
     uint8_t     setVideoHeader(uint8_t codec,uint32_t *remaining);
+    bool        extraHeader(flvTrak *trk,uint32_t *remain,bool haveCts,uint64_t *cts);
     
-    
     uint8_t     getFrameSize (uint32_t frame, uint32_t * size);
     char        *readFlvString(void);
     uint8_t     parseMetaData(uint32_t remaining);

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Flv/ADM_flvAudio.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Flv/ADM_flvAudio.cpp	2009-08-21 15:32:56 UTC (rev 5259)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Flv/ADM_flvAudio.cpp	2009-08-21 15:33:04 UTC (rev 5260)
@@ -20,9 +20,16 @@
 
 #include "ADM_flv.h"
 
+/**
+    \fn getExtraData
+*/
+bool      ADM_flvAccess::getExtraData(uint32_t *l, uint8_t **d)
+{
+    *l=_track->extraDataLen;
+    *d=_track->extraData;
+    return true;
+}   
 
-
-
 /**
     \fn ADM_audioAccess
     \brief Constructor



From mean at mail.berlios.de  Fri Aug 21 17:33:06 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Fri, 21 Aug 2009 17:33:06 +0200
Subject: [Avidemux-svn-commit] r5261 -
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Flv
Message-ID: <200908211533.n7LFX6Ux027658@sheep.berlios.de>

Author: mean
Date: 2009-08-21 17:33:06 +0200 (Fri, 21 Aug 2009)
New Revision: 5261

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Flv/ADM_flv.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Flv/ADM_flvAudio.cpp
Log:
[flv/demuxer] Play h264/aac (lucy spinder sample)

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Flv/ADM_flv.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Flv/ADM_flv.cpp	2009-08-21 15:33:04 UTC (rev 5260)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Flv/ADM_flv.cpp	2009-08-21 15:33:06 UTC (rev 5261)
@@ -329,7 +329,7 @@
                 if(extraHeader(audioTrack,&remaining,false,&cts)) continue;
             }
             if(remaining)
-                insertAudio(pos+of,remaining,dts);
+                insertAudio(ftello(_fd),remaining,dts);
           }
           break;
       case FLV_TAG_TYPE_META:
@@ -364,7 +364,7 @@
 
             }
             if(remaining)
-                insertVideo(pos+of,remaining,frameType,dts);
+                insertVideo(ftello(_fd),remaining,frameType,dts);
           }
            break;
       default: printf("[FLV]At 0x%x, unhandled type %u\n",pos,type);

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Flv/ADM_flvAudio.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Flv/ADM_flvAudio.cpp	2009-08-21 15:33:04 UTC (rev 5260)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Flv/ADM_flvAudio.cpp	2009-08-21 15:33:06 UTC (rev 5261)
@@ -25,8 +25,15 @@
 */
 bool      ADM_flvAccess::getExtraData(uint32_t *l, uint8_t **d)
 {
+#if 0
+        uint8_t dd[2]={0x12,0x10};
+        *l=2;
+        *d=dd;
+        return true;
+#else
     *l=_track->extraDataLen;
     *d=_track->extraData;
+#endif
     return true;
 }   
 



From mean at mail.berlios.de  Fri Aug 21 19:12:26 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Fri, 21 Aug 2009 19:12:26 +0200
Subject: [Avidemux-svn-commit] r5262 -
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Flv
Message-ID: <200908211712.n7LHCQ30015400@sheep.berlios.de>

Author: mean
Date: 2009-08-21 19:12:24 +0200 (Fri, 21 Aug 2009)
New Revision: 5262

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Flv/ADM_flv.cpp
Log:
[flv/demuxer] Fix array metadata

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Flv/ADM_flv.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Flv/ADM_flv.cpp	2009-08-21 15:33:06 UTC (rev 5261)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Flv/ADM_flv.cpp	2009-08-21 17:12:24 UTC (rev 5262)
@@ -145,6 +145,14 @@
             type=read8();
             switch(type)
             {
+                case AMF_DATA_TYPE_ARRAY:
+                                    {
+                                            uint32_t len=read32();
+                                            printf("[FLV] Array :");
+                                            for(int i=0;i<len;i++) printf("%02x ",read8());
+                                            printf("\n");
+                                            break;
+                                    }
                 case AMF_DATA_TYPE_DATE: Skip(8+2);break;
                 case AMF_DATA_TYPE_NUMBER:
                                         {



From mean at mail.berlios.de  Sat Aug 22 08:59:08 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sat, 22 Aug 2009 08:59:08 +0200
Subject: [Avidemux-svn-commit] r5263 -
	branches/avidemux_2.5_branch_gruntster/avidemux/ADM_codecs
Message-ID: <200908220659.n7M6x8bq017780@sheep.berlios.de>

Author: mean
Date: 2009-08-22 08:59:07 +0200 (Sat, 22 Aug 2009)
New Revision: 5263

Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_codecs/ADM_codecs.cpp
Log:
[Codec] WMVA==VC1 video codec

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_codecs/ADM_codecs.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_codecs/ADM_codecs.cpp	2009-08-21 17:12:24 UTC (rev 5262)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_codecs/ADM_codecs.cpp	2009-08-22 06:59:07 UTC (rev 5263)
@@ -295,7 +295,8 @@
       return (decoders *) (new decoderFFWMV3 (w, h, extraLen, extraData));
     }
 
-    if (fourCC::check (fcc, (uint8_t *) "WVC1"))
+    if (fourCC::check (fcc, (uint8_t *) "WVC1") ||
+                fourCC::check (fcc, (uint8_t *) "WMVA")  )
     {
 
       return (decoders *) (new decoderFFVC1 (w, h, extraLen, extraData));



From gruntster at mail.berlios.de  Sun Aug 23 18:00:39 2009
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Sun, 23 Aug 2009 18:00:39 +0200
Subject: [Avidemux-svn-commit] r5264 -
	branches/avidemux_2.5_branch_gruntster/avidemux
Message-ID: <200908231600.n7NG0dBG016029@sheep.berlios.de>

Author: gruntster
Date: 2009-08-23 18:00:34 +0200 (Sun, 23 Aug 2009)
New Revision: 5264

Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/gtk_gui.cpp
Log:
[gui] prevent opening video filter window when in copy mode (fixes #27)

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/gtk_gui.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/gtk_gui.cpp	2009-08-22 06:59:07 UTC (rev 5263)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/gtk_gui.cpp	2009-08-23 16:00:34 UTC (rev 5264)
@@ -810,24 +810,35 @@
       video_body->setDecodeParam ( curframe);
 
       break;
-    case ACT_VideoParameter:
-      // first remove current viewer
-      if (getPreviewMode()!=ADM_PREVIEW_NONE)
-        {
-	         admPreview::stop();
-        }
-      GUI_handleVFilter();
-      if( getLastVideoFilter()->getInfo()->width % 8 ){
-        GUI_Error_HIG(QT_TR_NOOP("Width is not a multiple of 8"),
-                      QT_TR_NOOP("This will make trouble for AVI files."));
-      }
-      if (getPreviewMode()!=ADM_PREVIEW_NONE)
-      {
-         admPreview::start();
-         admPreview::update (curframe);
-      }
-      break;
+	case ACT_VideoParameter:
+		if (videoProcessMode())
+		{
+			// first remove current viewer
+			if (getPreviewMode() != ADM_PREVIEW_NONE)
+			{
+				admPreview::stop();
+			}
 
+			GUI_handleVFilter();
+
+			if (getLastVideoFilter()->getInfo()->width % 8)
+			{
+				GUI_Error_HIG(QT_TR_NOOP("Width is not a multiple of 8"),
+					QT_TR_NOOP("This will make trouble for AVI files."));
+			}
+
+			if (getPreviewMode() != ADM_PREVIEW_NONE)
+			{
+				admPreview::start();
+				admPreview::update (curframe);
+			}
+		}
+		else
+		{
+			GUI_Error_HIG(QT_TR_NOOP("Video filters cannot be applied in Copy mode"), QT_TR_NOOP("To apply filters the video must be transcoded."));
+		}
+
+		break;
     case ACT_RebuildKF:
       if (GUI_Question (QT_TR_NOOP("Rebuild all Keyframes?")))
 	{



From gruntster at mail.berlios.de  Sun Aug 23 18:14:15 2009
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Sun, 23 Aug 2009 18:14:15 +0200
Subject: [Avidemux-svn-commit] r5265 -
	branches/avidemux_2.5_branch_gruntster/avidemux
Message-ID: <200908231614.n7NGEFaT018572@sheep.berlios.de>

Author: gruntster
Date: 2009-08-23 18:14:10 +0200 (Sun, 23 Aug 2009)
New Revision: 5265

Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/gtk_gui.cpp
Log:
[gui] prevent opening audio filter window when in copy mode

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/gtk_gui.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/gtk_gui.cpp	2009-08-23 16:00:34 UTC (rev 5264)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/gtk_gui.cpp	2009-08-23 16:14:10 UTC (rev 5265)
@@ -267,9 +267,17 @@
       audioCodecConfigure();
       return;
 
-    case ACT_AudioFilters:
-      audioFilter_configureFilters ();
-      return;
+	case ACT_AudioFilters:
+		if (audioProcessMode())
+		{
+			audioFilter_configureFilters();
+		}
+		else
+		{
+			GUI_Error_HIG(QT_TR_NOOP("Audio filters cannot be applied in Copy mode"), QT_TR_NOOP("To apply filters the audio must be transcoded."));
+		}
+
+		return;
     case ACT_Pref:
         if(playing) return;
     	if(DIA_Preferences())



From gruntster at mail.berlios.de  Sun Aug 23 18:50:22 2009
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Sun, 23 Aug 2009 18:50:22 +0200
Subject: [Avidemux-svn-commit] r5266 -
	branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_gui
Message-ID: <200908231650.n7NGoMYW008303@sheep.berlios.de>

Author: gruntster
Date: 2009-08-23 18:50:15 +0200 (Sun, 23 Aug 2009)
New Revision: 5266

Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_gui/Q_gui2.cpp
Log:
[qt] disable video encoder when muxer set to avi pack/unpack

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_gui/Q_gui2.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_gui/Q_gui2.cpp	2009-08-23 16:14:10 UTC (rev 5265)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_gui/Q_gui2.cpp	2009-08-23 16:50:15 UTC (rev 5266)
@@ -67,6 +67,8 @@
 static int currentFps = 0;
 static int frameCount = 0;
 static int currentFrame = 0;
+ADM_OUT_FORMAT UI_GetCurrentFormat(void);
+void UI_setVideoCodec(int i);
 
 #ifdef HAVE_AUDIO
 extern uint8_t AVDM_setVolume(int volume);
@@ -125,6 +127,20 @@
 		ui.pushButtonAudioFilter->setEnabled(b);
 		HandleAction(ACT_AudioCodecChanged);
 	}
+	else if (sender() == ui.comboBoxFormat)
+	{
+		ADM_OUT_FORMAT fmt = UI_GetCurrentFormat();
+
+		if (fmt == ADM_AVI_UNP || fmt == ADM_AVI_PAK)
+		{
+			ui.comboBoxVideo->setEnabled(false);
+			UI_setVideoCodec(0);
+		}
+		else
+		{
+			ui.comboBoxVideo->setEnabled(true);
+		}
+	}
 }
 
 void MainWindow::sliderValueChanged(int u) 
@@ -249,6 +265,7 @@
 	//ACT_VideoCodecChanged
 	connect( ui.comboBoxVideo,SIGNAL(currentIndexChanged(int)),this,SLOT(comboChanged(int)));
 	connect( ui.comboBoxAudio,SIGNAL(currentIndexChanged(int)),this,SLOT(comboChanged(int)));
+	connect(ui.comboBoxFormat, SIGNAL(currentIndexChanged(int)), this, SLOT(comboChanged(int)));
 
 	// Slider
 	slider=ui.horizontalSlider;



From gruntster at mail.berlios.de  Sun Aug 23 19:35:49 2009
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Sun, 23 Aug 2009 19:35:49 +0200
Subject: [Avidemux-svn-commit] r5267 - in
	branches/avidemux_2.5_branch_gruntster/avidemux: ADM_core/src
	ADM_userInterfaces/ADM_QT4/ADM_gui
Message-ID: <200908231735.n7NHZneA013520@sheep.berlios.de>

Author: gruntster
Date: 2009-08-23 19:35:43 +0200 (Sun, 23 Aug 2009)
New Revision: 5267

Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_core/src/ADM_crashdump.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_gui/Q_gui2.cpp
Log:
[qt] save crash file when Avidemux unexpectedly quits (regression introduced in 2.5.0)

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_core/src/ADM_crashdump.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_core/src/ADM_crashdump.cpp	2009-08-23 16:50:15 UTC (rev 5266)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_core/src/ADM_crashdump.cpp	2009-08-23 17:35:43 UTC (rev 5267)
@@ -42,7 +42,6 @@
         myFatalFunction=fatal;
 }
 
-static void saveCrashProject(void);
 extern char *ADM_getBaseDir(void);
 extern void A_parseECMAScript(const char *name);
 

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_gui/Q_gui2.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_gui/Q_gui2.cpp	2009-08-23 16:50:15 UTC (rev 5266)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_gui/Q_gui2.cpp	2009-08-23 17:35:43 UTC (rev 5267)
@@ -30,7 +30,7 @@
 #include "prefs.h"
 #include "avi_vars.h"
 #include "gtkgui.h"
-
+#include "DIA_coreToolkit.h"
 #include "ADM_userInterfaces/ADM_render/GUI_renderInternal.h"
 
 extern int global_argc;
@@ -55,6 +55,7 @@
 extern char *actual_workbench_file;
 extern void FileSel_ReadWrite(SELFILE_CB *cb, int rw, const char *name, const char *actual_workbench_file);
 extern bool A_parseECMAScript(const char *name);
+extern void saveCrashProject(void);
 
 int SliderIsShifted=0;
 static void setupMenus(void);
@@ -735,6 +736,11 @@
 	}
 }
 
+static void FatalFunctionQt(const char *title, const char *info)
+{
+	GUI_Info_HIG(ADM_LOG_IMPORTANT, title, info);
+}
+
 /**
     \fn UI_RunApp(void)
     \brief Main entry point for the GUI application
@@ -762,6 +768,7 @@
 	UI_QT4VideoWidget(mw->ui.frame_video);  // Add the widget that will handle video display
 	UI_updateRecentMenu();
 	setupMenus();
+	ADM_setCrashHook(&saveCrashProject, &FatalFunctionQt);
 	checkCrashFile();
 
 	if (global_argc >= 2)



From gruntster at mail.berlios.de  Sun Aug 23 20:58:17 2009
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Sun, 23 Aug 2009 20:58:17 +0200
Subject: [Avidemux-svn-commit] r5268 -
	branches/avidemux_2.5_branch_gruntster/platforms/windows/installer
Message-ID: <200908231858.n7NIwHbV021442@sheep.berlios.de>

Author: gruntster
Date: 2009-08-23 20:58:13 +0200 (Sun, 23 Aug 2009)
New Revision: 5268

Modified:
   branches/avidemux_2.5_branch_gruntster/platforms/windows/installer/avidemux.nsi
Log:
[win32] bump installer version

Modified: branches/avidemux_2.5_branch_gruntster/platforms/windows/installer/avidemux.nsi
===================================================================
--- branches/avidemux_2.5_branch_gruntster/platforms/windows/installer/avidemux.nsi	2009-08-23 17:35:43 UTC (rev 5267)
+++ branches/avidemux_2.5_branch_gruntster/platforms/windows/installer/avidemux.nsi	2009-08-23 18:58:13 UTC (rev 5268)
@@ -18,7 +18,7 @@
 !define INTERNALNAME "Avidemux 2.5"
 !define REGKEY "SOFTWARE\${INTERNALNAME}"
 !define UNINST_REGKEY "SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\${INTERNALNAME}"
-!define VERSION 2.5.0.${REVISION}
+!define VERSION 2.5.1.${REVISION}
 !define COMPANY "Free Software Foundation"
 !define URL "http://www.avidemux.org"
 
@@ -37,13 +37,13 @@
 
 !ifdef INST_BOTH
 OutFile ${EXEDIR}\avidemux_2.5_r${REVISION}_full_win32.exe
-Name "Avidemux 2.5.0 Full beta r${REVISION}"
+Name "Avidemux 2.5.1 Full beta r${REVISION}"
 !else ifdef INST_QT
 OutFile ${EXEDIR}\avidemux_2.5_r${REVISION}_win32.exe
-Name "Avidemux 2.5.0 beta r${REVISION}"
+Name "Avidemux 2.5.1 beta r${REVISION}"
 !else ifdef INST_GTK
 OutFile ${EXEDIR}\avidemux_2.5_r${REVISION}_gtk_win32.exe
-Name "Avidemux 2.5.0 GTK+ beta r${REVISION}"
+Name "Avidemux 2.5.1 GTK+ beta r${REVISION}"
 !endif
 
 ##########################
@@ -135,7 +135,7 @@
 XPStyle on
 ShowInstDetails nevershow
 ShowUninstDetails nevershow
-VIProductVersion 2.5.0.${REVISION}
+VIProductVersion 2.5.1.${REVISION}
 VIAddVersionKey ProductName Avidemux
 VIAddVersionKey ProductVersion "${VERSION} (beta)"
 VIAddVersionKey FileVersion ""



From gruntster at mail.berlios.de  Thu Aug 27 20:46:15 2009
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Thu, 27 Aug 2009 20:46:15 +0200
Subject: [Avidemux-svn-commit] r5269 -
	branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_xvid/gtk
Message-ID: <200908271846.n7RIkFw5009255@sheep.berlios.de>

Author: gruntster
Date: 2009-08-27 20:46:09 +0200 (Thu, 27 Aug 2009)
New Revision: 5269

Modified:
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_xvid/gtk/xvidConfigDialog.cpp
Log:
[xvid] allow max i-frame interval = 0 on GTK config window

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_xvid/gtk/xvidConfigDialog.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_xvid/gtk/xvidConfigDialog.cpp	2009-08-23 18:58:13 UTC (rev 5268)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_xvid/gtk/xvidConfigDialog.cpp	2009-08-27 18:46:09 UTC (rev 5269)
@@ -1024,7 +1024,7 @@
   gtk_widget_show (labelIFrameIntervalMax);
   gtk_box_pack_start (GTK_BOX (hbox9), labelIFrameIntervalMax, FALSE, FALSE, 0);
 
-  spinbuttonIMaxPeriod_adj = gtk_adjustment_new (250, 1, 500, 1, 10, 0);
+  spinbuttonIMaxPeriod_adj = gtk_adjustment_new (250, 0, 300, 1, 10, 0);
   spinbuttonIMaxPeriod = gtk_spin_button_new (GTK_ADJUSTMENT (spinbuttonIMaxPeriod_adj), 1, 0);
   gtk_widget_show (spinbuttonIMaxPeriod);
   gtk_box_pack_start (GTK_BOX (hbox9), spinbuttonIMaxPeriod, FALSE, FALSE, 0);



From gruntster at mail.berlios.de  Thu Aug 27 21:12:43 2009
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Thu, 27 Aug 2009 21:12:43 +0200
Subject: [Avidemux-svn-commit] r5270 -
	branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_xvid
Message-ID: <200908271912.n7RJCh7g013769@sheep.berlios.de>

Author: gruntster
Date: 2009-08-27 21:12:20 +0200 (Thu, 27 Aug 2009)
New Revision: 5270

Modified:
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_xvid/xvidOptions.cpp
Log:
[xvid] adopt vfw defaults instead of xvidcore (fixes #29)

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_xvid/xvidOptions.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_xvid/xvidOptions.cpp	2009-08-27 18:46:09 UTC (rev 5269)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_xvid/xvidOptions.cpp	2009-08-27 19:12:20 UTC (rev 5270)
@@ -23,8 +23,6 @@
 
 #include <libxml/parser.h>
 #include <libxml/xmlschemas.h>
-#include <sstream>
-#include <string>
 
 #include "config.h"
 #include "ADM_default.h"
@@ -56,15 +54,36 @@
 
 	xvid_enc_frame.vop_flags = XVID_VOP_HALFPEL | XVID_VOP_HQACPRED;
 
+	// General
 	setPar(1, 1);
 	setParAsInput(false);
+
+	// Quantiser
 	setCqmPreset(CQM_H263);
-	setMotionEstimation(ME_LOW);
+	setMinQuantiser(1, 1, 1);
+	setMaxQuantiser(31, 31, 31);
+	setTrellis(true);
+
+	// Motion
+	setMotionEstimation(ME_HIGH);
+	setChromaMotionEstimation(true);
 	setRateDistortion(RD_DCT_ME);
-	setMinQuantiser(2, 2, 2);
-	setMaxQuantiser(31, 31, 31);
+
+	// Frame
+	setMaxKeyInterval(300);
+	setMaxBframes(2);
 	setBframeQuantiserRatio(150);
 	setBframeQuantiserOffset(100);
+
+	// 1-Pass
+	setReactionDelayFactor(16);
+	setAveragingQuantiserPeriod(100);
+	setSmoother(100);
+
+	// 2-Pass
+	setKeyFrameBoost(10);
+	setMaxKeyFrameReduceBitrate(20);
+	setKeyFrameBitrateThreshold(1);
 	setOverflowControlStrength(5);
 	setMaxOverflowImprovement(5);
 	setMaxOverflowDegradation(5);



From gruntster at mail.berlios.de  Thu Aug 27 21:37:30 2009
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Thu, 27 Aug 2009 21:37:30 +0200
Subject: [Avidemux-svn-commit] r5271 - in
	branches/avidemux_2.5_branch_gruntster/platforms/windows:
	build_scripts/avidemux installer
Message-ID: <200908271937.n7RJbUfs018237@sheep.berlios.de>

Author: gruntster
Date: 2009-08-27 21:37:25 +0200 (Thu, 27 Aug 2009)
New Revision: 5271

Modified:
   branches/avidemux_2.5_branch_gruntster/platforms/windows/build_scripts/avidemux/Package Notes.xml
   branches/avidemux_2.5_branch_gruntster/platforms/windows/installer/avidemux.nsi
Log:
[win32] add libvorbis decoder to Windows installer

Modified: branches/avidemux_2.5_branch_gruntster/platforms/windows/build_scripts/avidemux/Package Notes.xml
===================================================================
--- branches/avidemux_2.5_branch_gruntster/platforms/windows/build_scripts/avidemux/Package Notes.xml	2009-08-27 19:12:20 UTC (rev 5270)
+++ branches/avidemux_2.5_branch_gruntster/platforms/windows/build_scripts/avidemux/Package Notes.xml	2009-08-27 19:37:25 UTC (rev 5271)
@@ -1,5 +1,34 @@
 <?xml version="1.0"?>
 <log>
+  <buildentry revision="5268" date="2009-08-23">
+    <comment>Updated x264 r1222.</comment>
+  </buildentry>
+  <buildentry revision="5249 [2.5.1 Final]" date="2009-08-16">
+    <comment>Updated Fontconfig to version 2.7.1-2.</comment>
+  </buildentry>
+  <buildentry revision="5234" date="2009-08-12">
+    <comment>Updated Cairo to version 1.8.8-1.</comment>
+    <comment>Updated Fontconfig to version 2.7.1-1.</comment>
+    <comment>Updated Freetype to version 2.3.9-1.</comment>
+    <comment>Updated GLib to version 2.20.4-1.</comment>
+    <comment>Updated GTK+ to version 2.16.5-1.</comment>
+    <comment>Updated libpng to version 1.2.38-1.</comment>
+    <comment>Updated Pango to version 1.24.5-1.</comment>
+    <comment>Updated x264 to r1206.</comment>
+  </buildentry>
+  <buildentry revision="5204" date="2009-08-03">
+  </buildentry>
+  <buildentry revision="5181" date="2009-07-30">
+    <comment>Updated x264 to r1195.</comment>
+  </buildentry>
+  <buildentry revision="5152" date="2009-07-25">
+    <comment>Updated Avisynth Proxy GUI to version 2.09d.</comment>
+    <comment>Updated x264 to r1185.</comment>
+  </buildentry>
+  <buildentry revision="5104" date="2009-07-17">
+    <comment>Added opencore-amr 0.1.1.</comment>
+    <comment>Updated x264 to r1183.</comment>
+  </buildentry>
   <buildentry revision="5087" date="2009-07-13">
   </buildentry>
   <buildentry revision="5065" date="2009-07-12">

Modified: branches/avidemux_2.5_branch_gruntster/platforms/windows/installer/avidemux.nsi
===================================================================
--- branches/avidemux_2.5_branch_gruntster/platforms/windows/installer/avidemux.nsi	2009-08-27 19:12:20 UTC (rev 5270)
+++ branches/avidemux_2.5_branch_gruntster/platforms/windows/installer/avidemux.nsi	2009-08-27 19:37:25 UTC (rev 5271)
@@ -382,6 +382,12 @@
 			SetOutPath $INSTDIR\plugins\audioDecoder
 			${File} plugins\audioDecoder\libADM_ad_a52.dll
 		${MementoSectionEnd}
+		${MementoSection} "libvorbis (Vorbis)" SecAudDecVorbis
+			SectionIn 1 2
+			SetOverwrite on
+			SetOutPath $INSTDIR\plugins\audioDecoder
+			${File} plugins\audioDecoder\libADM_ad_vorbis.dll
+		${MementoSectionEnd}
 		${MementoSection} "MAD (MPEG)" SecAudDecMad
 			SectionIn 1 2
 			SetOverwrite on



From gruntster at mail.berlios.de  Thu Aug 27 22:19:49 2009
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Thu, 27 Aug 2009 22:19:49 +0200
Subject: [Avidemux-svn-commit] r5272 - in
	branches/avidemux_2.5_branch_gruntster/cmake: . patches
Message-ID: <200908272019.n7RKJnc1024509@sheep.berlios.de>

Author: gruntster
Date: 2009-08-27 22:19:42 +0200 (Thu, 27 Aug 2009)
New Revision: 5272

Modified:
   branches/avidemux_2.5_branch_gruntster/cmake/admFFmpegPatch.cmake
   branches/avidemux_2.5_branch_gruntster/cmake/patches/createPatches.sh
Log:
[win32] fix patching to work with latest MSYS tools

Modified: branches/avidemux_2.5_branch_gruntster/cmake/admFFmpegPatch.cmake
===================================================================
--- branches/avidemux_2.5_branch_gruntster/cmake/admFFmpegPatch.cmake	2009-08-27 19:37:25 UTC (rev 5271)
+++ branches/avidemux_2.5_branch_gruntster/cmake/admFFmpegPatch.cmake	2009-08-27 20:19:42 UTC (rev 5272)
@@ -1,28 +1,29 @@
 macro(find_patch)
 	find_package(Patch)
 
-	if (WIN32)
-		find_package(Unix2Dos)
+	#if (WIN32)
+		#find_package(Unix2Dos)
 
-		if (NOT VERBOSE)
-			set(unix2dosOutput OUTPUT_VARIABLE UNIX2DOS_OUTPUT)
-		endif (NOT VERBOSE)
-	endif (WIN32)
+		#if (NOT VERBOSE)
+			#set(unix2dosOutput OUTPUT_VARIABLE UNIX2DOS_OUTPUT)
+		#endif (NOT VERBOSE)
+	#endif (WIN32)
 endmacro(find_patch)
 
 macro(patch_file baseDir patchFile)
-	if (WIN32)
-		set(tempPatchDir ${CMAKE_BINARY_DIR}/temp)
-		file(MAKE_DIRECTORY "${tempPatchDir}")
-		get_filename_component(fileName "${patchFile}" NAME)
+	#if (WIN32)
+		#set(tempPatchDir ${CMAKE_BINARY_DIR}/temp)
+		#file(MAKE_DIRECTORY "${tempPatchDir}")
+		#get_filename_component(fileName "${patchFile}" NAME)
 
-		execute_process(COMMAND ${UNIX2DOS_EXECUTABLE} -n ${patchFile} ${tempPatchDir}/${fileName}
-						${unix2dosOutput})
+		#execute_process(COMMAND ${UNIX2DOS_EXECUTABLE} -n ${patchFile} ${tempPatchDir}/${fileName}
+						#${unix2dosOutput})
 
-		set(_patchFile "${tempPatchDir}/${fileName}")
-	else (WIN32)
+		#set(_patchFile "${tempPatchDir}/${fileName}")
+	#else (WIN32)
 		set(_patchFile "${patchFile}")
-	endif (WIN32)
+	#endif (WIN32)
+
 	execute_process(COMMAND ${PATCH_EXECUTABLE} -p0 -i "${_patchFile}"
 					WORKING_DIRECTORY "${baseDir}")
 endmacro(patch_file)

Modified: branches/avidemux_2.5_branch_gruntster/cmake/patches/createPatches.sh
===================================================================
--- branches/avidemux_2.5_branch_gruntster/cmake/patches/createPatches.sh	2009-08-27 19:37:25 UTC (rev 5271)
+++ branches/avidemux_2.5_branch_gruntster/cmake/patches/createPatches.sh	2009-08-27 20:19:42 UTC (rev 5272)
@@ -8,6 +8,7 @@
 	cp $1/$2 $1/$2.new
 	svn revert $1/$2
 	unix2dos $1/$2
+	unix2dos $1/$2.new
 	mv $1/$2 $1/$2.old
 	mv $1/$2.new $1/$2
 	diff -c $1/$2.old $1/$2 > $curDir/$1_$2.patch
@@ -33,4 +34,3 @@
 updatePatch libavutil avutil.h
 updatePatch libavutil internal.h
 updatePatch libavutil mem.c
-updatePatch libswscale swscale_internal.h
\ No newline at end of file



From gruntster at mail.berlios.de  Thu Aug 27 22:29:40 2009
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Thu, 27 Aug 2009 22:29:40 +0200
Subject: [Avidemux-svn-commit] r5273 - in
	branches/avidemux_2.5_branch_gruntster/cmake: . patches
Message-ID: <200908272029.n7RKTeeE025723@sheep.berlios.de>

Author: gruntster
Date: 2009-08-27 22:29:31 +0200 (Thu, 27 Aug 2009)
New Revision: 5273

Modified:
   branches/avidemux_2.5_branch_gruntster/cmake/admFFmpegBuild.cmake
   branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_avcodec.h.patch
   branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_ffv1.c.patch
   branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_mpeg12enc.c.patch
Log:
[ffmpeg] update FFmpeg to r19733 & libswscale r29569

Modified: branches/avidemux_2.5_branch_gruntster/cmake/admFFmpegBuild.cmake
===================================================================
--- branches/avidemux_2.5_branch_gruntster/cmake/admFFmpegBuild.cmake	2009-08-27 20:19:42 UTC (rev 5272)
+++ branches/avidemux_2.5_branch_gruntster/cmake/admFFmpegBuild.cmake	2009-08-27 20:29:31 UTC (rev 5273)
@@ -1,7 +1,7 @@
 include(admFFmpegUtil)
 
-set(FFMPEG_VERSION 19575)	# http://git.ffmpeg.org/?p=ffmpeg;a=snapshot;h=d3fb9f5983437e7379acc552d8d82a4704eb6167;sf=tgz
-set(SWSCALE_VERSION 29474)	# http://git.ffmpeg.org/?p=libswscale;a=snapshot;h=b1af9a271e6f587dbcd2b19dbceb4d2ec8eace7e;sf=tgz
+set(FFMPEG_VERSION 19733)	# http://git.ffmpeg.org/?p=ffmpeg;a=snapshot;h=98a20315c84e530ada85050aa19c82080e35a635;sf=tgz
+set(SWSCALE_VERSION 29569)	# http://git.ffmpeg.org/?p=libswscale;a=snapshot;h=30c6a4d2f849809c0d1f9ca6d548f786990b1d38;sf=tgz
 
 set(LIBRARY_SOURCE_DIR "${CMAKE_SOURCE_DIR}/avidemux/ADM_libraries")
 set(FFMPEG_SOURCE_DIR "${LIBRARY_SOURCE_DIR}/ffmpeg")

Modified: branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_avcodec.h.patch
===================================================================
--- branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_avcodec.h.patch	2009-08-27 20:19:42 UTC (rev 5272)
+++ branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_avcodec.h.patch	2009-08-27 20:29:31 UTC (rev 5273)
@@ -1,8 +1,8 @@
-*** libavcodec/avcodec.h.old	Sat Jun 27 18:45:05 2009
---- libavcodec/avcodec.h	Sat Jun 27 18:45:04 2009
+*** libavcodec/avcodec.h.old	Thu Aug 27 21:15:55 2009
+--- libavcodec/avcodec.h	Thu Aug 27 21:15:55 2009
 ***************
-*** 568,573 ****
---- 568,575 ----
+*** 571,576 ****
+--- 571,578 ----
   #define CODEC_FLAG2_CHUNKS        0x00008000 ///< Input bitstream might be truncated at a packet boundaries instead of only at frame boundaries.
   #define CODEC_FLAG2_NON_LINEAR_QUANT 0x00010000 ///< Use MPEG-2 nonlinear quantizer.
   #define CODEC_FLAG2_BIT_RESERVOIR 0x00020000 ///< Use a bit reservoir when encoding if possible
@@ -12,8 +12,8 @@
   /* Unsupported options :
    *              Syntax Arithmetic coding (SAC)
 ***************
-*** 1422,1427 ****
---- 1424,1430 ----
+*** 1425,1430 ****
+--- 1427,1433 ----
        * - decoding: unused
        */
       int rc_max_rate;
@@ -22,8 +22,8 @@
       /**
        * minimum bitrate
 ***************
-*** 1436,1441 ****
---- 1439,1446 ----
+*** 1439,1444 ****
+--- 1442,1449 ----
        * - decoding: unused
        */
       int rc_buffer_size;

Modified: branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_ffv1.c.patch
===================================================================
--- branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_ffv1.c.patch	2009-08-27 20:19:42 UTC (rev 5272)
+++ branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_ffv1.c.patch	2009-08-27 20:29:31 UTC (rev 5273)
@@ -1,8 +1,8 @@
-*** libavcodec/ffv1.c.old	Mon May 25 14:32:17 2009
---- libavcodec/ffv1.c	Mon May 25 14:32:17 2009
+*** libavcodec/ffv1.c.old	Thu Aug 27 21:15:58 2009
+--- libavcodec/ffv1.c	Thu Aug 27 21:15:58 2009
 ***************
-*** 1072,1077 ****
---- 1072,1079 ----
+*** 1071,1076 ****
+--- 1071,1078 ----
           clear_state(f);
       }else{
           p->key_frame= 0;

Modified: branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_mpeg12enc.c.patch
===================================================================
--- branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_mpeg12enc.c.patch	2009-08-27 20:19:42 UTC (rev 5272)
+++ branches/avidemux_2.5_branch_gruntster/cmake/patches/libavcodec_mpeg12enc.c.patch	2009-08-27 20:29:31 UTC (rev 5273)
@@ -1,5 +1,5 @@
-*** libavcodec/mpeg12enc.c.old	Sat Jan 24 22:57:41 2009
---- libavcodec/mpeg12enc.c	Sat Jan 24 22:57:40 2009
+*** libavcodec/mpeg12enc.c.old	Thu Aug 27 21:16:08 2009
+--- libavcodec/mpeg12enc.c	Thu Aug 27 21:16:09 2009
 ***************
 *** 127,136 ****
 --- 127,145 ----
@@ -40,7 +40,7 @@
   
 !             put_bits(&s->pb, 4, s->aspect_ratio_info);
 !             put_bits(&s->pb, 4, s->frame_rate_index);
-! 
+  
 !             if(s->avctx->rc_max_rate){
 !                 v = (s->avctx->rc_max_rate + 399) / 400;
                   if (v > 0x3ffff && s->codec_id == CODEC_ID_MPEG1VIDEO)
@@ -75,17 +75,17 @@
 +                 put_bits(&s->pb, 4, 12); // MPEG1
 +             }
 + // /MEANX
-+ 
-+ // //MEANX PULLDOWN            put_bits(&s->pb, 4, s->frame_rate_index);
-+ if((s->flags2 & CODEC_FLAG2_32_PULLDOWN) && (s->codec_id == CODEC_ID_MPEG2VIDEO))
-+             {           
-+                 put_bits(&s->pb, 4,4);
-+             }
-+             else
-+             {                                  
-+                 put_bits(&s->pb, 4, s->frame_rate_index);
-+             } //MEANX pulldown
   
+! // //MEANX PULLDOWN            put_bits(&s->pb, 4, s->frame_rate_index);
+! if((s->flags2 & CODEC_FLAG2_32_PULLDOWN) && (s->codec_id == CODEC_ID_MPEG2VIDEO))
+!             {           
+!                 put_bits(&s->pb, 4,4);
+!             }
+!             else
+!             {                                  
+!                 put_bits(&s->pb, 4, s->frame_rate_index);
+!             } //MEANX pulldown
+  
 !             if(s->avctx->rc_max_rate_header){ //MEANX we use header
 !                 v = (s->avctx->rc_max_rate_header + 399) / 400;
                   if (v > 0x3ffff && s->codec_id == CODEC_ID_MPEG1VIDEO)



From mean at mail.berlios.de  Fri Aug 28 11:31:45 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Fri, 28 Aug 2009 11:31:45 +0200
Subject: [Avidemux-svn-commit] r5274 -
	branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_flv
Message-ID: <200908280931.n7S9VjxP006455@sheep.berlios.de>

Author: mean
Date: 2009-08-28 11:31:44 +0200 (Fri, 28 Aug 2009)
New Revision: 5274

Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_flv/ADM_flv.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_flv/ADM_flv.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_flv/ADM_flvAudio.cpp
Log:
[Flv] Backport some code from 2.6 to allow new codecs in flv, refs #26

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_flv/ADM_flv.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_flv/ADM_flv.cpp	2009-08-27 20:29:31 UTC (rev 5273)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_flv/ADM_flv.cpp	2009-08-28 09:31:44 UTC (rev 5274)
@@ -145,6 +145,14 @@
             type=read8();
             switch(type)
             {
+                case AMF_DATA_TYPE_ARRAY:
+                                    {
+                                            uint32_t len=read32();
+                                            printf("[FLV] Array :");
+                                            for(int i=0;i<len;i++) printf("%02x ",read8());
+                                            printf("\n");
+                                            break;
+                                    }
                 case AMF_DATA_TYPE_DATE: Skip(8+2);break;
                 case AMF_DATA_TYPE_NUMBER:
                                         {
@@ -172,6 +180,43 @@
     fseeko(_fd,endPos,SEEK_SET);
     return 1;
 }
+/**
+    \fn extraHeader
+    \brief if returns true means we must skip the remainder
+*/
+bool flvHeader::extraHeader(flvTrak *trk,uint32_t *remain,bool have_cts,int32_t *cts)
+{
+    int type=read8();
+    int r=*remain;
+    r--;
+    if(have_cts)
+    {
+        uint32_t c=read24();
+         *cts=(c+0xff800000)^0xff800000;
+        //printf("Type :%d\n",type);
+        r-=3;
+    }
+    if(!type)
+    {  // Grab extra data
+        if(trk->extraData) 
+        {
+            Skip(r);
+            r=0;
+        }
+        else    
+        {
+            printf("[FLV] found some extradata %lu\n",r);
+            trk->extraData=new uint8_t[r];
+            trk->extraDataLen=r;
+            read(r,trk->extraData);
+            r=0;            
+        }
+        *remain=r;
+        return true;
+    }
+    *remain=r;
+    return false;
+}
 
 /**
       \fn open
@@ -181,7 +226,8 @@
 uint8_t flvHeader::open(const char *name)
 {
   uint32_t prevLen, type, size, pts,pos=0;
-  
+  bool firstVideo=true;
+  int32_t cts; 
   _isvideopresent=0;
   _isaudiopresent=0;
   audioTrack=NULL;
@@ -271,7 +317,12 @@
             {
                setAudioHeader(format,fq,bps,channel);
             }
-            insertAudio(pos+of,remaining,pts);
+            if(format==10)
+            {
+                if(extraHeader(audioTrack,&remaining,false,&cts)) continue;
+            }
+            if(remaining)
+                insertAudio(pos+of,remaining,pts);
           }
           break;
       case FLV_TAG_TYPE_META:
@@ -294,13 +345,18 @@
               remaining--;
               of++;
             }
-            int first=0;
-            if(!videoTrack->_nbIndex) first=1;
-            insertVideo(pos+of,remaining,frameType,pts);
-            if(first) // first frame..
+            if(firstVideo==true) // first frame..
             {
                 if(!setVideoHeader(codec,&remaining)) return 0;
+                firstVideo=false;
             }
+            if(codec==FLV_CODECID_H264)
+            {
+                if(true==extraHeader(videoTrack,&remaining,true,&cts)) continue;
+
+            }
+            if(remaining)
+                insertVideo(ftello(_fd),remaining,frameType,pts);
             
           }
            break;
@@ -350,39 +406,34 @@
     printf("[FLV] Video Codec:%u\n",codec);
      _video_bih.biWidth=_mainaviheader.dwWidth=320;
     _video_bih.biHeight=_mainaviheader.dwHeight=240;
+#define MKFLV(x,t) case FLV_CODECID_##x :  _videostream.fccHandler=_video_bih.biCompression=\
+                            fourCC::get((uint8_t *)#t);break;
+
     switch(codec)
     {
-      case FLV_CODECID_H263:            _videostream.fccHandler=_video_bih.biCompression=fourCC::get((uint8_t *)"FLV1");break;
-      case FLV_CODECID_VP6:             _videostream.fccHandler=_video_bih.biCompression=fourCC::get((uint8_t *)"VP6F");break;
-      case FLV_CODECID_VP6A:
-                        _videostream.fccHandler=_video_bih.biCompression=fourCC::get((uint8_t *)"VP6A");break;
+        MKFLV(H264,H264);
+        MKFLV(H263,FLV1);
+        MKFLV(VP6,VP6F);
+        MKFLV(VP6A,VP6A);
 
-    //???   case FLV_CODECID_SCREEN:          _videostream.fccHandler=_video_bih.biCompression=fourCC::get((uint8_t *)"VP6F");break;
       default :                         _videostream.fccHandler=_video_bih.biCompression=fourCC::get((uint8_t *)"XXX");break;
       
     }
-    if(codec==FLV_CODECID_VP6A && metaWidth && metaHeight )
-    {
-         _video_bih.biHeight=_mainaviheader.dwHeight=metaHeight ;
-         _video_bih.biWidth=_mainaviheader.dwWidth=metaWidth;
-    }
+     if( metaWidth && metaHeight )
+        if( codec==FLV_CODECID_VP6A  || codec==FLV_CODECID_H264 || codec==FLV_CODECID_VP6) 
+        {
+                _video_bih.biHeight=_mainaviheader.dwHeight=metaHeight ;
+                _video_bih.biWidth=_mainaviheader.dwWidth=metaWidth;
+        }
 
-    if(codec==FLV_CODECID_VP6)
-    {
-        read8();
-        read8();
-        *remaining-=2;
-         
-         _video_bih.biHeight=_mainaviheader.dwHeight=read8()*16;
-         _video_bih.biWidth=_mainaviheader.dwWidth=read8()*16;
-        *remaining-=2; 
-    }
     if(codec==FLV_CODECID_H263)
     {
       uint32_t len=*remaining,width,height;
+      uint32_t pos=ftello(_fd);
+
       uint8_t buffer[len];
       read(len,buffer);
-      *remaining=0;
+      fseeko(_fd,pos,SEEK_SET);
        /* Decode header, from h263dec.c / lavcodec*/
       if(extractH263FLVInfo(buffer,len,&width,&height))
       {
@@ -417,6 +468,7 @@
     case 3: wavHeader.encoding=WAV_PCM;break; 
     case 0: wavHeader.encoding=WAV_LPCM;break;
     case 1: wavHeader.encoding=WAV_MSADPCM;break;
+    case 10:wavHeader.encoding=WAV_AAC;break;
     default:
           printf("[FLV]Unsupported audio codec:%u\n",format);    
   }
@@ -514,8 +566,17 @@
 uint8_t flvHeader::close(void)
 {
   if(_filename) ADM_dealloc(_filename);
-  if(videoTrack) delete videoTrack;
-  if(audioTrack) delete audioTrack;
+  if(videoTrack) 
+  {
+        if(videoTrack->extraData) delete [] videoTrack->extraData;
+        delete videoTrack;
+  }
+  if(audioTrack) 
+  {
+     if(audioTrack->extraData) delete [] audioTrack->extraData;
+    delete audioTrack;
+  }
+
   if(_fd) fclose(_fd);
   if(_audioStream) delete _audioStream;
   

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_flv/ADM_flv.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_flv/ADM_flv.h	2009-08-27 20:29:31 UTC (rev 5273)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_flv/ADM_flv.h	2009-08-28 09:31:44 UTC (rev 5274)
@@ -100,6 +100,7 @@
     uint8_t     insertAudio(uint32_t pos,uint32_t size,uint32_t pts);
     uint8_t     setAudioHeader(uint32_t format,uint32_t fq,uint32_t bps,uint32_t channels);
     uint8_t     setVideoHeader(uint8_t codec,uint32_t *remaining);
+    bool        extraHeader(flvTrak *trk,uint32_t *remain,bool have_cts,int32_t *cts);
     
     
     uint8_t     getFrameSize (uint32_t frame, uint32_t * size);

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_flv/ADM_flvAudio.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_flv/ADM_flvAudio.cpp	2009-08-27 20:29:31 UTC (rev 5273)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_flv/ADM_flvAudio.cpp	2009-08-28 09:31:44 UTC (rev 5274)
@@ -61,8 +61,9 @@
 */
 uint8_t             flvAudio::extraData(uint32_t *l,uint8_t **d)
 {
-  *l=0;
-  *d=NULL;
+    *l=_track->extraDataLen;
+    *d=_track->extraData;
+    return 1;
 }
 /**
     \fn getPacket



From mean at mail.berlios.de  Fri Aug 28 11:31:46 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Fri, 28 Aug 2009 11:31:46 +0200
Subject: [Avidemux-svn-commit] r5275 -
	branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_flv
Message-ID: <200908280931.n7S9VkXG006465@sheep.berlios.de>

Author: mean
Date: 2009-08-28 11:31:46 +0200 (Fri, 28 Aug 2009)
New Revision: 5275

Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_flv/ADM_flv.cpp
Log:
[Flv] Fix extraheader + offset in audio, fix #26

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_flv/ADM_flv.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_flv/ADM_flv.cpp	2009-08-28 09:31:44 UTC (rev 5274)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_flv/ADM_flv.cpp	2009-08-28 09:31:46 UTC (rev 5275)
@@ -322,7 +322,7 @@
                 if(extraHeader(audioTrack,&remaining,false,&cts)) continue;
             }
             if(remaining)
-                insertAudio(pos+of,remaining,pts);
+                insertAudio(ftello(_fd),remaining,pts);
           }
           break;
       case FLV_TAG_TYPE_META:
@@ -662,9 +662,15 @@
 
 uint8_t  flvHeader::getExtraHeaderData(uint32_t *len, uint8_t **data)
 {
-                *len=0; //_tracks[0].extraDataLen;
-                *data=NULL; //_tracks[0].extraData;
-                return 1;            
+        if(videoTrack)
+        {
+                *len=videoTrack->extraDataLen;
+                *data=videoTrack->extraData;
+                return 1;
+        }
+        *len=0;
+        *data=NULL;
+        return 1;
 }
 /*
     __________________________________________________________



From gruntster at mail.berlios.de  Fri Aug 28 23:07:09 2009
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Fri, 28 Aug 2009 23:07:09 +0200
Subject: [Avidemux-svn-commit] r5276 - in
	branches/avidemux_2.5_branch_gruntster/avidemux:
	ADM_coreImage/include ADM_filter
	ADM_userInterfaces/ADM_GTK/ADM_filters
	ADM_userInterfaces/ADM_QT4/ADM_filters
Message-ID: <200908282107.n7SL79xQ022622@sheep.berlios.de>

Author: gruntster
Date: 2009-08-28 23:07:03 +0200 (Fri, 28 Aug 2009)
New Revision: 5276

Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreImage/include/ADM_videoFilter_internal.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_filter/filter.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_filter/filter_declaration.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_GTK/ADM_filters/gui_filtermanager.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_filters/Q_mainfilter.cpp
Log:
[filter] reinstate partial filter support (fixes #28)

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreImage/include/ADM_videoFilter_internal.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreImage/include/ADM_videoFilter_internal.h	2009-08-28 09:31:46 UTC (rev 5275)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreImage/include/ADM_videoFilter_internal.h	2009-08-28 21:07:03 UTC (rev 5276)
@@ -21,14 +21,15 @@
 
 typedef enum
 {
-	VF_TRANSFORM=0,
-	VF_INTERLACING=1,
-	VF_COLORS=2,
-	VF_NOISE=3,
-	VF_SHARPNESS=4,
-	VF_SUBTITLE=5,
-	VF_MISC=6,
-	VF_MAX=7
+	VF_TRANSFORM,
+	VF_INTERLACING,
+	VF_COLORS,
+	VF_NOISE,
+	VF_SHARPNESS,
+	VF_SUBTITLE,
+	VF_MISC,
+	VF_INTERNAL,
+	VF_MAX
 }VF_CATEGORY;
 #define VF_INVALID 		  0
 

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_filter/filter.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_filter/filter.cpp	2009-08-28 09:31:46 UTC (rev 5275)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_filter/filter.cpp	2009-08-28 21:07:03 UTC (rev 5276)
@@ -121,63 +121,69 @@
  */
 VF_FILTERS filterGetTagFromName(const char *inname)
 {
-const char *name;
-int max=allfilters.size();
-	VF_FILTERS filter=VF_INVALID;
-	for(uint32_t i=0;i<max;i++)
+	const char *name;
+	int max = allfilters.size();
+	VF_FILTERS filter = VF_INVALID;
+
+	for (uint32_t i = 0; i < max; i++)
 	{
-		name=allfilters[ i]->filterName;
-		if(1) // allfilters[i]->tag==VF_PARTIAL_FILTER)
+		name = allfilters[i]->filterName;
+
+		if (name && strlen(name) && !strcasecmp(name, inname))
 		{
-			if(name)
-			{
-				if(strlen(name))
-				{
-					if(!strcasecmp(name,inname))
-						return allfilters[ i]->tag;
-				}
-			}
+			filter = allfilters[i]->tag;
+			break;
 		}
 	}
+
 	return filter;
 }
+
 /**
  * 	\fn tryLoadingFilterPlugin
  *  \brief try to load the plugin given as argument..
  */
 
 #define Fail(x) {printf("%s:"#x"\n",file);goto er;}
+
 static bool tryLoadingFilterPlugin(const char *file)
 {
-	ADM_vf_pluginLoader *dll=new ADM_vf_pluginLoader(file);
+	ADM_vf_pluginLoader *dll = new ADM_vf_pluginLoader(file);
+	FilterDescriptor *desc = NULL;
+	FilterDescriptor *myDesc = NULL;
 
-	FilterDescriptor *desc=NULL;
-	FilterDescriptor *myDesc=NULL;
-	if(!dll->getDesc) Fail(nogetdesc);
+	if (!dll->getDesc)
+		Fail(nogetdesc);
 
-	desc=dll->getDesc();
-	if(!desc) Fail(GetDescriptor);
-	// Check the API version
-	if(desc->apiVersion!=ADM_FILTER_API_VERSION) Fail(WrongAPI);
-	if(!(desc->uiFlags & UI_GetCurrentUI())) Fail(WrongUI);
+	desc = dll->getDesc();
+
+	if (!desc)
+		Fail(GetDescriptor);
+
+	if (desc->apiVersion != ADM_FILTER_API_VERSION)
+		Fail(WrongAPI);
+
+	if (!(desc->uiFlags & UI_GetCurrentUI()))
+		Fail(WrongUI);
+
 	// Duplicate it, just in case...
-	myDesc=new FilterDescriptor();
-	memcpy(myDesc,desc,sizeof(*myDesc));
-	// push it !
-	myDesc->tag=tagCount++;
-	ADM_assert(myDesc->category<VF_MAX);
+	myDesc = new FilterDescriptor();
 
-    allfilters.push_back (myDesc);
-    filterCategories[myDesc->category].push_back(myDesc);
-    pluginLoaderQueue.push_back(dll); // Needed for cleanup. FIXME TODO Delete it.
-    printf("[Filters] Registered filter %s as  %s\n",file,desc->name);
-    return true;
-	// Tag it
-	// Fail!
+	memcpy(myDesc, desc, sizeof(*myDesc));
+	myDesc->tag = tagCount++;
+	ADM_assert(myDesc->category < VF_MAX);
+
+	allfilters.push_back(myDesc);
+	filterCategories[myDesc->category].push_back(myDesc);
+	pluginLoaderQueue.push_back(dll); // Needed for cleanup. FIXME TODO Delete it.
+	printf("[Filters] Registered filter %s as %s\n", file, desc->name);
+
+	return true;
+
 er:
 	delete dll;
+
 	return false;
-
 }
 /**
  * 	\fn ADM_vf_loadPlugins
@@ -198,16 +204,16 @@
 	char *files[MAX_EXTERNAL_FILTER];
 	uint32_t nbFile;
 
-	memset(files,0,sizeof(char *)*MAX_EXTERNAL_FILTER);
-	printf("[ADM_vf_plugin] Scanning directory %s\n",path);
+	memset(files, 0, sizeof(char *)*MAX_EXTERNAL_FILTER);
+	printf("[ADM_vf_plugin] Scanning directory %s\n", path);
 
-	if(!buildDirectoryContent(&nbFile, path, files, MAX_EXTERNAL_FILTER, SHARED_LIB_EXT))
+	if (!buildDirectoryContent(&nbFile, path, files, MAX_EXTERNAL_FILTER, SHARED_LIB_EXT))
 	{
 		printf("[ADM_vf_plugin] Cannot parse plugin\n");
 		return 0;
 	}
 
-	for(int i=0;i<nbFile;i++)
+	for (int i = 0; i < nbFile; i++)
 	{
 		tryLoadingFilterPlugin(files[i]);
 		ADM_dealloc(files[i]);
@@ -226,8 +232,14 @@
 		AVDMGenericVideoStream *(*create_from_script) (AVDMGenericVideoStream *in, int n,Arg *args),
 		const char *descText)
 {
+	int tag;
 
-	FilterDescriptor *desc=new FilterDescriptor(tagCount++,filtername,name,
+	if (strcmp(name, "partial") == 0)
+		tag = VF_PARTIAL_FILTER;
+	else
+		tag = tagCount++;
+
+	FilterDescriptor *desc=new FilterDescriptor(tag,filtername,name,
 												descText,
 												category,
 												create,
@@ -360,25 +372,25 @@
 //
 //	Create a filter from : its tag, its config and an input stream
 //
-
 AVDMGenericVideoStream *filterCreateFromTag(VF_FILTERS tag,CONFcouple *couple, AVDMGenericVideoStream *in)
 {
-	 AVDMGenericVideoStream *filter;
+	ADM_assert(tag != VF_INVALID);
 
-			ADM_assert(tag!=VF_INVALID);
+	AVDMGenericVideoStream *filter = VF_INVALID;
 
-                        {
-                          for(unsigned int i=0;i<allfilters.size();i++)
-                                  {
-                                          if(tag==allfilters[i]->tag)
-                                                  {
-                                                          filter=allfilters[i]->create( in, couple);
-                                                          return filter;
-                                                  }
-                                  }
-                        }
-			ADM_assert(0);
-			return NULL;
+	for (unsigned int i = 0; i < allfilters.size(); i++)
+	{
+		if (tag == allfilters[i]->tag)
+		{
+			filter = allfilters[i]->create(in, couple);
+
+			break;
+		}
+	}
+
+	ADM_assert(filter != VF_INVALID);
+
+	return filter;
 }
 
 /*

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_filter/filter_declaration.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_filter/filter_declaration.cpp	2009-08-28 09:31:46 UTC (rev 5275)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_filter/filter_declaration.cpp	2009-08-28 21:07:03 UTC (rev 5276)
@@ -54,7 +54,7 @@
 	REGISTERX("swissarmyknife",QT_TR_NOOP("Swiss Army Knife"),QT_TR_NOOP("Apply operation like P'=P*A, P-A, P+A, etc. using a convolution, rolling average, image from file, or constant"),VF_SWISSARMYKNIFE,1,swissarmyknife_create,swissarmyknife_script);
 #endif
 // Misc filter, internal only
-	REGISTERX(VF_MISC,"partial",QT_TR_NOOP("Partial"),"",VF_PARTIAL,0,partial_create,partial_script);
+	REGISTERX(VF_INTERNAL,"partial",QT_TR_NOOP("Partial"),"",VF_PARTIAL,0,partial_create,partial_script);
 	REGISTERX(VF_MISC,"framenum",QT_TR_NOOP("Add Framenumber"),QT_TR_NOOP("Print frame number directly in image"),VF_FRAMENUM,1,number_create,number_script);
  printf("\n");
 }

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_GTK/ADM_filters/gui_filtermanager.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_GTK/ADM_filters/gui_filtermanager.cpp	2009-08-28 09:31:46 UTC (rev 5275)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_GTK/ADM_filters/gui_filtermanager.cpp	2009-08-28 21:07:03 UTC (rev 5276)
@@ -543,52 +543,57 @@
     gtk_list_store_clear (stores[0]);
     for (uint32_t i = 1; i < nb_active_filter; i++)
     {
-        gtk_list_store_append (stores[0], &iter);
-        fil=videofilters[i].tag;
-         const char * name = filterGetNameFromTag(fil);
-         const char * conf = videofilters[i].filter->printConf ();
-         int namelen = strlen (name);
-         while (*conf == ' ')
-             ++conf;
-         if (strncasecmp (name, conf, namelen) == 0)
-         {
-             conf += namelen;
-             while (*conf == ' ' || *conf == ':')
-                 ++conf;
-         }
-         const char * smallstart = "";
-         const char * smallend = "";
-         const char * namesmallstart = "";
-         const char * namesmallend = "";
-         int conflen = strlen (conf);
-         if (conflen > 120)
-         {
-             smallstart = "<small>";
-             smallend = "</small>";
-             if (conflen > 180)
-             {
-                 namesmallstart = smallstart;
-                 namesmallend = smallend;
-             }
-         }
+		fil = videofilters[i].tag;
 
-        str = g_strconcat("<span  weight=\"bold\">",
-                            namesmallstart,
-                            name,
-                            namesmallend,
-                            "</span>\n",
-                             "<span size=\"smaller\">",
-                             smallstart,
-                             conf,
-                             smallend,
-                             "</span>",  NULL);
+		if (fil != VF_INTERNAL)
+		{
+			gtk_list_store_append (stores[0], &iter);
 
-        gtk_list_store_set (stores[0], &iter,
-                            0, str,
-                            1, videofilters[i].tag,
-                            2, videofilters[i].conf,
-                            -1);
-        g_free(str);
+			const char * name = filterGetNameFromTag(fil);
+			const char * conf = videofilters[i].filter->printConf ();
+			int namelen = strlen (name);
+			while (*conf == ' ')
+				++conf;
+			if (strncasecmp (name, conf, namelen) == 0)
+			{
+				conf += namelen;
+				while (*conf == ' ' || *conf == ':')
+					++conf;
+			}
+			const char * smallstart = "";
+			const char * smallend = "";
+			const char * namesmallstart = "";
+			const char * namesmallend = "";
+			int conflen = strlen (conf);
+			if (conflen > 120)
+			{
+				smallstart = "<small>";
+				smallend = "</small>";
+				if (conflen > 180)
+				{
+					namesmallstart = smallstart;
+					namesmallend = smallend;
+				}
+			}
+
+			str = g_strconcat("<span  weight=\"bold\">",
+				namesmallstart,
+				name,
+				namesmallend,
+				"</span>\n",
+				"<span size=\"smaller\">",
+				smallstart,
+				conf,
+				smallend,
+				"</span>",  NULL);
+
+			gtk_list_store_set (stores[0], &iter,
+				0, str,
+				1, videofilters[i].tag,
+				2, videofilters[i].conf,
+				-1);
+			g_free(str);
+		}
     }
     g_signal_handler_unblock(stores[0], row_inserted_id);
     g_signal_handler_unblock(stores[0], row_deleted_id);

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_filters/Q_mainfilter.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_filters/Q_mainfilter.cpp	2009-08-28 09:31:46 UTC (rev 5275)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_filters/Q_mainfilter.cpp	2009-08-28 21:07:03 UTC (rev 5276)
@@ -598,23 +598,26 @@
 
 	for (uint32_t i = 1; i < nb_active_filter; i++)
 	{
-		const char *name = filterGetNameFromTag(videofilters[i].tag);
-		const char *conf = videofilters[i].filter->printConf ();
-		int namelen = strlen (name);
+		if (videofilters[i].tag != VF_INTERNAL)
+		{
+			const char *name = filterGetNameFromTag(videofilters[i].tag);
+			const char *conf = videofilters[i].filter->printConf ();
+			int namelen = strlen (name);
 
-		while (*conf == ' ')
-			++conf;
+			while (*conf == ' ')
+				++conf;
 
-		if (strncasecmp (name, conf, namelen) == 0)
-		{
-			conf += namelen;
-			while (*conf == ' ' || *conf == ':')
-				++conf;
+			if (strncasecmp (name, conf, namelen) == 0)
+			{
+				conf += namelen;
+				while (*conf == ' ' || *conf == ':')
+					++conf;
+			}
+
+			QString str = QString("<b>") + QString::fromUtf8(name) + QString("</b><br>\n<small>") + QString::fromUtf8(conf) + QString("</small>");
+			QListWidgetItem *item=new QListWidgetItem(str,activeList,ACTIVE_FILTER_BASE+i);
+			activeList->addItem(item);
 		}
-
-		QString str = QString("<b>") + QString::fromUtf8(name) + QString("</b><br>\n<small>") + QString::fromUtf8(conf) + QString("</small>");
-		QListWidgetItem *item=new QListWidgetItem(str,activeList,ACTIVE_FILTER_BASE+i);
-		activeList->addItem(item);
 	}
 }
   /**



From gruntster at mail.berlios.de  Fri Aug 28 23:13:42 2009
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Fri, 28 Aug 2009 23:13:42 +0200
Subject: [Avidemux-svn-commit] r5277 -
	branches/avidemux_2.5_branch_gruntster/avidemux
Message-ID: <200908282113.n7SLDgOr023020@sheep.berlios.de>

Author: gruntster
Date: 2009-08-28 23:13:32 +0200 (Fri, 28 Aug 2009)
New Revision: 5277

Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/gui_autodrive.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/main.cpp
Log:
[misc] remove dead code

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/gui_autodrive.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/gui_autodrive.cpp	2009-08-28 21:07:03 UTC (rev 5276)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/gui_autodrive.cpp	2009-08-28 21:13:32 UTC (rev 5277)
@@ -148,11 +148,7 @@
                     {
                     case ACT_AUTO_PSP:
                           {
-#ifdef USE_XVID_4
-                            if(!videoCodecSelectByName("XVID4")) 
-#else
                             if(!videoCodecSelectByName("FFMpeg4"))            
-#endif
                             {
                               GUI_Error_HIG(QT_TR_NOOP("Codec Error"),QT_TR_NOOP( "Cannot select mpeg4 sp codec."));
                                 return 0;

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/main.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/main.cpp	2009-08-28 21:07:03 UTC (rev 5276)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/main.cpp	2009-08-28 21:13:32 UTC (rev 5277)
@@ -33,10 +33,6 @@
 #include "prefs.h"
 #include "ADM_audiodevice/audio_out.h"
 
-#ifdef USE_XVID_4
-extern void xvid4_init(void);
-#endif
-
 extern void  ADM_lavInit();
 
 extern "C" {
@@ -202,10 +198,6 @@
     UI_Init(argc,argv);
     AUDMEncoder_initDither();
 
-#ifdef USE_XVID_4
-    xvid4_init();
-#endif
-
     // Hook our UI...
     InitFactory();
     InitCoreToolkit();



From gruntster at mail.berlios.de  Sat Aug 29 01:44:04 2009
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Sat, 29 Aug 2009 01:44:04 +0200
Subject: [Avidemux-svn-commit] r5278 -
	branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog
Message-ID: <200908282344.n7SNi4KO019696@sheep.berlios.de>

Author: gruntster
Date: 2009-08-29 01:43:56 +0200 (Sat, 29 Aug 2009)
New Revision: 5278

Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/Q_working.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/Q_working.h
Log:
[qt] add responder for cancel button on progress dialog (fixes #24)

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/Q_working.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/Q_working.cpp	2009-08-28 21:13:32 UTC (rev 5277)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/Q_working.cpp	2009-08-28 23:43:56 UTC (rev 5278)
@@ -14,23 +14,30 @@
 #include <math.h>
 
 #include "Q_working.h"
-#include "ADM_default.h"
 #include "ADM_video/ADM_vidMisc.h"
-#include "DIA_working.h"
 #include "ADM_toolkitQt.h"
 
 extern void UI_purge(void);
 
-workWindow::workWindow(QWidget *parent) : QDialog(parent)
- {
-     ui.setupUi(this);
- }
+workWindow::workWindow(QWidget *parent, DIA_working *working) : QDialog(parent)
+{
+	ui.setupUi(this);
+
+	connect(ui.buttonBox, SIGNAL(rejected()), this, SLOT(closeDialog(void)));
+	_working = working;
+}
+
+void workWindow::closeDialog(void)
+{
+	_working->closeDialog();
+}
+
 //*******************************************
 
 DIA_working::DIA_working( void )
 {
   workWindow *wind;
-  wind=new workWindow(qtLastRegisteredDialog());
+  wind=new workWindow(qtLastRegisteredDialog(), this);
   qtRegisterDialog(wind);
   _priv=(void *)wind;
   postCtor();
@@ -38,7 +45,7 @@
 DIA_working::DIA_working( const char *title )
 {
   workWindow *wind;
-  wind=new workWindow(qtLastRegisteredDialog());
+  wind=new workWindow(qtLastRegisteredDialog(), this);
   qtRegisterDialog(wind);
   _priv=(void *)wind;
   wind->setWindowTitle(QString::fromUtf8(title));
@@ -110,8 +117,7 @@
 
 uint8_t DIA_working::isAlive (void )
 {
-	if(!_priv) return 0;
-	return 1;
+	return _priv != NULL;
 }
 
 DIA_working::~DIA_working()
@@ -121,10 +127,15 @@
 
 void DIA_working::closeDialog( void )
 {
-  workWindow *wind=(workWindow *)_priv; ADM_assert(wind);
-  qtUnregisterDialog(wind);
-    delete wind;
-    wind=NULL;
+	if (_priv)
+	{
+		QDialog* dialog = (QDialog*)_priv;
+
+		_priv = NULL;
+		dialog->accept();
+		qtUnregisterDialog(dialog);
+		delete dialog;
+	}
 }
 
 //********************************************

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/Q_working.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/Q_working.h	2009-08-28 21:13:32 UTC (rev 5277)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/Q_working.h	2009-08-28 23:43:56 UTC (rev 5278)
@@ -2,13 +2,21 @@
 #define Q_working_h
 
 #include "ui_working.h"
+#include "ADM_default.h"
+#include "DIA_working.h"
 
 class workWindow : public QDialog
 {
 	Q_OBJECT
 
+private:
+	DIA_working *_working;
+
 public:
-	workWindow(QWidget *parent);
+	workWindow(QWidget *parent, DIA_working *working);
 	Ui_workingDialog ui;
+
+private slots:
+	void closeDialog(void);
 };
 #endif	// Q_working_h



From gruntster at mail.berlios.de  Sat Aug 29 22:43:29 2009
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Sat, 29 Aug 2009 22:43:29 +0200
Subject: [Avidemux-svn-commit] r5279 -
	branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/FluxSmooth
Message-ID: <200908292043.n7TKhTx9020261@sheep.berlios.de>

Author: gruntster
Date: 2009-08-29 22:43:24 +0200 (Sat, 29 Aug 2009)
New Revision: 5279

Modified:
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/FluxSmooth/ADM_vidFlux.cpp
Log:
[flux] correctly initialise fluxsmooth filter (regression introduced in 2.5.0; fixes #23)

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/FluxSmooth/ADM_vidFlux.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/FluxSmooth/ADM_vidFlux.cpp	2009-08-28 23:43:56 UTC (rev 5278)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/FluxSmooth/ADM_vidFlux.cpp	2009-08-29 20:43:24 UTC (rev 5279)
@@ -25,24 +25,23 @@
 #include "ADM_vidFlux.h"
 
 static int16_t FUNNY_MANGLE_ARRAY(scaletab, 16);
-static uint64_t FUNNY_MANGLE_ARRAY(scaletab_MMX, 65535);
+static uint64_t FUNNY_MANGLE_ARRAY(scaletab_MMX, 65536);
 
-void initScaleTab( void )
+static void initScaleTab(void)
 {
-//uint32_t i;
+	scaletab[1] = 32767;
 
-		scaletab[1] = 32767;
-		for(int i = 2; i < 16; ++i)
-				scaletab[i] = (int)(32768.0 / i + 0.5);
-		for(uint32_t  i = 0; i < 65536; ++i)
-		{
-			scaletab_MMX[i] = ( (uint64_t)scaletab[ i        & 15]       ) |
-							  (((uint64_t)scaletab[(i >>  4) & 15]) << 16) |
-							  (((uint64_t)scaletab[(i >>  8) & 15]) << 32) |
-							  (((uint64_t)scaletab[(i >> 12) & 15]) << 48);
-		}
+	for(int i = 2; i < 16; ++i)
+		scaletab[i] = (int)(32768.0 / i + 0.5);
+
+	for(uint32_t  i = 0; i < 65536; ++i)
+	{
+		scaletab_MMX[i] = ((uint64_t)scaletab[i & 15]) |
+			(((uint64_t)scaletab[(i >>  4) & 15]) << 16) |
+			(((uint64_t)scaletab[(i >>  8) & 15]) << 32) |
+			(((uint64_t)scaletab[(i >> 12) & 15]) << 48);
+	}
 }
- 
 
 static FILTER_PARAM fluxParam={2,{"temporal_threshold","spatial_threshold"}};
 
@@ -78,9 +77,15 @@
 static uint32_t size;
 
 ADMVideoFlux::ADMVideoFlux(AVDMGenericVideoStream *in,CONFcouple *couples)
-			
 {
-  
+	static bool _initialised = false;
+
+	if (!_initialised)
+	{
+		initScaleTab();
+		_initialised = true;
+	}
+
 	_in=in;
 	memcpy(&_info,in->getInfo(),sizeof(_info));
 	if(couples)



From gruntster at mail.berlios.de  Sat Aug 29 23:33:13 2009
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Sat, 29 Aug 2009 23:33:13 +0200
Subject: [Avidemux-svn-commit] r5280 -
	branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_NONE/ADM_dialog
Message-ID: <200908292133.n7TLXD5h025591@sheep.berlios.de>

Author: gruntster
Date: 2009-08-29 23:33:06 +0200 (Sat, 29 Aug 2009)
New Revision: 5280

Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_NONE/ADM_dialog/DIA_working.cpp
Log:
[cli] signal that progress dialog is always alive for CLI since it isn't displayed and can't be aborted

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_NONE/ADM_dialog/DIA_working.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_NONE/ADM_dialog/DIA_working.cpp	2009-08-29 20:43:24 UTC (rev 5279)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_NONE/ADM_dialog/DIA_working.cpp	2009-08-29 21:33:06 UTC (rev 5280)
@@ -17,17 +17,8 @@
  *   (at your option) any later version.                                   *
  *                                                                         *
  ***************************************************************************/
-
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <unistd.h>
-#include <string.h>
-#include <stdio.h>
 #include <math.h>
 
-
-
-#include "config.h"
 #include "ADM_default.h"
 
 #include "ADM_osSupport/ADM_debugID.h"
@@ -55,7 +46,6 @@
 {
 	#define  GUI_UPDATE_RATE 1000
 
-                if(!_priv) return 1;
                 if(!percent) return 0;
                 if(percent==lastper)
                 {
@@ -105,7 +95,6 @@
 {
 		double d,n;
 		uint32_t percent;
-		if(!_priv) return 1;
 
 		aprintf("DIA_working::update(uint32_t %lu,uint32_t %lu) called\n", cur, total);
 		if(!total) return 0;
@@ -123,7 +112,6 @@
 
 uint8_t DIA_working::isAlive (void )
 {
-	if(!_priv) return 0;
 	return 1;
 }
 



From gruntster at mail.berlios.de  Sat Aug 29 23:37:26 2009
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Sat, 29 Aug 2009 23:37:26 +0200
Subject: [Avidemux-svn-commit] r5281 -
	branches/avidemux_2.5_branch_gruntster/avidemux/ADM_toolkit
Message-ID: <200908292137.n7TLbQCZ026114@sheep.berlios.de>

Author: gruntster
Date: 2009-08-29 23:37:21 +0200 (Sat, 29 Aug 2009)
New Revision: 5281

Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_toolkit/automation.cpp
Log:
[cli] modify behaviour of save-jpg parameter to recognise selection (fixes #14)

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_toolkit/automation.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_toolkit/automation.cpp	2009-08-29 21:33:06 UTC (rev 5280)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_toolkit/automation.cpp	2009-08-29 21:37:21 UTC (rev 5281)
@@ -48,7 +48,7 @@
 extern void filterListAll(void );
 
 extern uint8_t loadVideoCodecConf( const char *name);
-extern int A_saveJpg (char *name);
+extern int A_saveBunchJpg(const char *name);
 extern void filterLoadXml(const char *n);
 extern int A_appendAvi (const char *name);
 extern void A_saveAudio(char *name);
@@ -154,7 +154,7 @@
         {"svcd-res",		0,"set SVCD resolution",		(one_arg_type)setSVCD}              ,
         {"dvd-res",		0,"set DVD resolution",			(one_arg_type)setDVD}  ,
         {"halfd1-res",		0,"set 1/2 DVD resolution",		(one_arg_type)setHalfD1} ,  
-        {"save-jpg",		1,"save a jpeg",			(one_arg_type)A_saveJpg}        ,
+        {"save-jpg",		1,"save JPEG images",			(one_arg_type)A_saveBunchJpg},
         {"begin",		1,"set start frame",			setBegin},
         {"end",			1,"set end frame",			setEnd},
         {"save-unpacked-vop",	1,"save avi, unpacking vop",(one_arg_type)A_SaveUnpackedVop},



From mean at mail.berlios.de  Mon Aug 31 17:56:19 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Mon, 31 Aug 2009 17:56:19 +0200
Subject: [Avidemux-svn-commit] r5282 - in
	branches/avidemux_2.5_branch_gruntster: . avidemux cmake
Message-ID: <200908311556.n7VFuJOK000675@sheep.berlios.de>

Author: mean
Date: 2009-08-31 17:56:18 +0200 (Mon, 31 Aug 2009)
New Revision: 5282

Modified:
   branches/avidemux_2.5_branch_gruntster/CMakeLists.txt
   branches/avidemux_2.5_branch_gruntster/avidemux/CMakeLists.txt
   branches/avidemux_2.5_branch_gruntster/cmake/ad_plugin.cmake
   branches/avidemux_2.5_branch_gruntster/cmake/admPluginVideoEncoder.cmake
   branches/avidemux_2.5_branch_gruntster/cmake/ae_plugin.cmake
   branches/avidemux_2.5_branch_gruntster/cmake/av_plugin.cmake
Log:
[Build] Patch from D. Kapusta that fixes a couple of loose ends + enable plugin build with the need to install main by symlinking the libs into the lib dir

Modified: branches/avidemux_2.5_branch_gruntster/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/CMakeLists.txt	2009-08-29 21:37:21 UTC (rev 5281)
+++ branches/avidemux_2.5_branch_gruntster/CMakeLists.txt	2009-08-31 15:56:18 UTC (rev 5282)
@@ -184,6 +184,7 @@
 ADD_SUBDIRECTORY(avidemux)
 ADD_SUBDIRECTORY(po)
 ADD_SUBDIRECTORY(scripts)
+# MEANX : DOES NOT WORK ADD_SUBDIRECTORY(plugins EXCLUDE_FROM_ALL)
 
 ########################################
 # Config Summary

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/CMakeLists.txt	2009-08-29 21:37:21 UTC (rev 5281)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/CMakeLists.txt	2009-08-31 15:56:18 UTC (rev 5282)
@@ -501,3 +501,14 @@
 ELSE (APPLE)
 	INSTALL(TARGETS ${ADM_EXES} RUNTIME DESTINATION ${BIN_DIR} LIBRARY DESTINATION lib)
 ENDIF (APPLE)
+
+IF (UNIX AND NOT APPLE)
+   ADD_CUSTOM_COMMAND(TARGET ffmpeg
+                      POST_BUILD
+                      COMMAND mkdir -p ${CMAKE_BINARY_DIR}/lib${LIB_SUFFIX}
+                      COMMAND find ${CMAKE_BINARY_DIR}/avidemux -name '*.so*' | xargs ln -sft ${CMAKE_BINARY_DIR}/lib${LIB_SUFFIX}
+                      WORKING_DIRECTORY ${CMAKE_BINARY_DIR}
+                      COMMENT "Creating temporary lib directory for proper plugins linking")
+ENDIF (UNIX AND NOT APPLE)
+
+

Modified: branches/avidemux_2.5_branch_gruntster/cmake/ad_plugin.cmake
===================================================================
--- branches/avidemux_2.5_branch_gruntster/cmake/ad_plugin.cmake	2009-08-29 21:37:21 UTC (rev 5281)
+++ branches/avidemux_2.5_branch_gruntster/cmake/ad_plugin.cmake	2009-08-31 15:56:18 UTC (rev 5282)
@@ -6,9 +6,9 @@
 
 MACRO(INIT_AUDIO_PLUGIN _lib)
 	INCLUDE_DIRECTORIES("${CMAKE_BINARY_DIR}/config")
-	INCLUDE_DIRECTORIES("${CMAKE_SOURCE_DIR}/../avidemux/ADM_core/include")
-	INCLUDE_DIRECTORIES("${CMAKE_SOURCE_DIR}/../avidemux/ADM_coreAudio/include")
-	INCLUDE_DIRECTORIES("${CMAKE_SOURCE_DIR}/../avidemux/ADM_audiocodec")
+	INCLUDE_DIRECTORIES("${AVIDEMUX_SOURCE_DIR}/avidemux/ADM_core/include")
+	INCLUDE_DIRECTORIES("${AVIDEMUX_SOURCE_DIR}/avidemux/ADM_coreAudio/include")
+	INCLUDE_DIRECTORIES("${AVIDEMUX_SOURCE_DIR}/avidemux/ADM_audiocodec")
 ENDMACRO(INIT_AUDIO_PLUGIN)
 
 MACRO(INSTALL_AUDIODECODER _lib)

Modified: branches/avidemux_2.5_branch_gruntster/cmake/admPluginVideoEncoder.cmake
===================================================================
--- branches/avidemux_2.5_branch_gruntster/cmake/admPluginVideoEncoder.cmake	2009-08-29 21:37:21 UTC (rev 5281)
+++ branches/avidemux_2.5_branch_gruntster/cmake/admPluginVideoEncoder.cmake	2009-08-31 15:56:18 UTC (rev 5282)
@@ -6,9 +6,9 @@
 
 MACRO(INIT_VIDEO_ENCODER_PLUGIN _lib)
 	INCLUDE_DIRECTORIES("${CMAKE_BINARY_DIR}/config")
-	INCLUDE_DIRECTORIES("${CMAKE_SOURCE_DIR}/../avidemux/ADM_core/include")
-	INCLUDE_DIRECTORIES("${CMAKE_SOURCE_DIR}/../avidemux/ADM_coreUI/include")
-	INCLUDE_DIRECTORIES("${CMAKE_SOURCE_DIR}/../avidemux/ADM_plugin")
+	INCLUDE_DIRECTORIES("${AVIDEMUX_SOURCE_DIR}/avidemux/ADM_core/include")
+	INCLUDE_DIRECTORIES("${AVIDEMUX_SOURCE_DIR}/avidemux/ADM_coreUI/include")
+	INCLUDE_DIRECTORIES("${AVIDEMUX_SOURCE_DIR}/avidemux/ADM_plugin")
 ENDMACRO(INIT_VIDEO_ENCODER_PLUGIN)
 
 MACRO(INSTALL_VIDEO_ENCODER _lib)

Modified: branches/avidemux_2.5_branch_gruntster/cmake/ae_plugin.cmake
===================================================================
--- branches/avidemux_2.5_branch_gruntster/cmake/ae_plugin.cmake	2009-08-29 21:37:21 UTC (rev 5281)
+++ branches/avidemux_2.5_branch_gruntster/cmake/ae_plugin.cmake	2009-08-31 15:56:18 UTC (rev 5282)
@@ -5,10 +5,10 @@
 ENDIF (WIN32)
 
 MACRO(INIT_AUDIO_ENCODER _lib)
-	INCLUDE_DIRECTORIES("${CMAKE_SOURCE_DIR}/../avidemux/ADM_core/include")
-	INCLUDE_DIRECTORIES("${CMAKE_SOURCE_DIR}/../avidemux/ADM_coreAudio/include")
-	INCLUDE_DIRECTORIES("${CMAKE_SOURCE_DIR}/../avidemux/ADM_coreUI/include")
-	INCLUDE_DIRECTORIES("${CMAKE_SOURCE_DIR}/../avidemux/ADM_audiofilter")
+	INCLUDE_DIRECTORIES("${AVIDEMUX_SOURCE_DIR}/avidemux/ADM_core/include")
+	INCLUDE_DIRECTORIES("${AVIDEMUX_SOURCE_DIR}/avidemux/ADM_coreAudio/include")
+	INCLUDE_DIRECTORIES("${AVIDEMUX_SOURCE_DIR}/avidemux/ADM_coreUI/include")
+	INCLUDE_DIRECTORIES("${AVIDEMUX_SOURCE_DIR}/avidemux/ADM_audiofilter")
         ADD_DEFINITIONS("-DADM_MINIMAL_UI_INTERFACE")
 ENDMACRO(INIT_AUDIO_ENCODER)
 

Modified: branches/avidemux_2.5_branch_gruntster/cmake/av_plugin.cmake
===================================================================
--- branches/avidemux_2.5_branch_gruntster/cmake/av_plugin.cmake	2009-08-29 21:37:21 UTC (rev 5281)
+++ branches/avidemux_2.5_branch_gruntster/cmake/av_plugin.cmake	2009-08-31 15:56:18 UTC (rev 5282)
@@ -5,9 +5,9 @@
 ENDIF (WIN32)
 
 MACRO(INIT_AUDIO_DEVICE _lib)
-	INCLUDE_DIRECTORIES("${CMAKE_SOURCE_DIR}/../avidemux/ADM_core/include")
-	INCLUDE_DIRECTORIES("${CMAKE_SOURCE_DIR}/../avidemux/ADM_coreAudio/include")
-	INCLUDE_DIRECTORIES("${CMAKE_SOURCE_DIR}/../avidemux/ADM_audiodevice/")
+	INCLUDE_DIRECTORIES("${AVIDEMUX_SOURCE_DIR}/avidemux/ADM_core/include")
+	INCLUDE_DIRECTORIES("${AVIDEMUX_SOURCE_DIR}/avidemux/ADM_coreAudio/include")
+	INCLUDE_DIRECTORIES("${AVIDEMUX_SOURCE_DIR}/avidemux/ADM_audiodevice/")
 ENDMACRO(INIT_AUDIO_DEVICE)
 
 MACRO(INSTALL_AUDIODEVICE _lib)



From mean at mail.berlios.de  Mon Aug 31 17:56:23 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Mon, 31 Aug 2009 17:56:23 +0200
Subject: [Avidemux-svn-commit] r5283 - in
	branches/avidemux_2.5_branch_gruntster: avidemux
	avidemux/ADM_UIs/ADM_CLI/src avidemux/ADM_UIs/ADM_GTK/src
	avidemux/ADM_UIs/ADM_QT4/src avidemux/ADM_core/src
	avidemux/ADM_coreAudio/src avidemux/ADM_coreImage/src
	avidemux/ADM_coreUI/src avidemux/ADM_libraries/ADM_smjs
	avidemux/ADM_userInterfaces/ADM_render cmake plugins
	plugins/ADM_videoEncoder/ADM_vidEnc_avcodec
Message-ID: <200908311556.n7VFuNwK000685@sheep.berlios.de>

Author: mean
Date: 2009-08-31 17:56:21 +0200 (Mon, 31 Aug 2009)
New Revision: 5283

Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_UIs/ADM_CLI/src/CMakeLists.txt
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_UIs/ADM_GTK/src/CMakeLists.txt
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_UIs/ADM_QT4/src/CMakeLists.txt
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_core/src/CMakeLists.txt
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/src/CMakeLists.txt
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreImage/src/CMakeLists.txt
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreUI/src/CMakeLists.txt
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_libraries/ADM_smjs/CMakeLists.txt
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_render/CMakeLists.txt
   branches/avidemux_2.5_branch_gruntster/avidemux/CMakeLists.txt
   branches/avidemux_2.5_branch_gruntster/cmake/ad_plugin.cmake
   branches/avidemux_2.5_branch_gruntster/cmake/admFFmpegBuild.cmake
   branches/avidemux_2.5_branch_gruntster/cmake/admPluginVideoEncoder.cmake
   branches/avidemux_2.5_branch_gruntster/cmake/ae_plugin.cmake
   branches/avidemux_2.5_branch_gruntster/cmake/av_plugin.cmake
   branches/avidemux_2.5_branch_gruntster/cmake/vf_plugin.cmake
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_avcodec/CMakeLists.txt
   branches/avidemux_2.5_branch_gruntster/plugins/CMakeLists.txt
Log:
[Plugins] Build patch from D. Kapusta, cleanup the lib/lib32/lib64 mess

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_UIs/ADM_CLI/src/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_UIs/ADM_CLI/src/CMakeLists.txt	2009-08-31 15:56:18 UTC (rev 5282)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_UIs/ADM_CLI/src/CMakeLists.txt	2009-08-31 15:56:21 UTC (rev 5283)
@@ -9,4 +9,4 @@
 INCLUDE_DIRECTORIES(${CMAKE_CURRENT_SOURCE_DIR}/../include)
 ADD_LIBRARY(${ADM_LIB}  SHARED ${${ADM_LIB}_SRCS})
 ADD_SOURCE_CFLAGS(DIA_flyDialogCli.cpp " -DADM_UI_TYPE_BUILD=1")
-INSTALL(TARGETS ${ADM_LIB} RUNTIME DESTINATION ${BIN_DIR}  LIBRARY DESTINATION lib  ARCHIVE DESTINATION lib)
+INSTALL(TARGETS ${ADM_LIB} RUNTIME DESTINATION ${BIN_DIR}  LIBRARY DESTINATION lib${LIB_SUFFIX}  ARCHIVE DESTINATION lib${LIB_SUFFIX})

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_UIs/ADM_GTK/src/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_UIs/ADM_GTK/src/CMakeLists.txt	2009-08-31 15:56:18 UTC (rev 5282)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_UIs/ADM_GTK/src/CMakeLists.txt	2009-08-31 15:56:21 UTC (rev 5283)
@@ -30,4 +30,4 @@
 TARGET_LINK_LIBRARIES(${ADM_LIB} ${GTK_LDFLAGS} ADM_core ADM_coreUI ADM_render_gtk)
 ADD_TARGET_CFLAGS(${ADM_LIB} ${GTK_CFLAGS})
 ADD_SOURCE_CFLAGS(DIA_flyDialogGtk.cpp " -DADM_UI_TYPE_BUILD=2")
-INSTALL(TARGETS ${ADM_LIB} RUNTIME DESTINATION ${BIN_DIR}  LIBRARY DESTINATION lib  ARCHIVE DESTINATION lib)
\ No newline at end of file
+INSTALL(TARGETS ${ADM_LIB} RUNTIME DESTINATION ${BIN_DIR}  LIBRARY DESTINATION lib${LIB_SUFFIX}  ARCHIVE DESTINATION lib${LIB_SUFFIX})

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_UIs/ADM_QT4/src/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_UIs/ADM_QT4/src/CMakeLists.txt	2009-08-31 15:56:18 UTC (rev 5282)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_UIs/ADM_QT4/src/CMakeLists.txt	2009-08-31 15:56:21 UTC (rev 5283)
@@ -21,4 +21,4 @@
 ADD_SOURCE_CFLAGS(T_flyDialogQt4.cpp " -DADM_UI_TYPE_BUILD=4")
 ADD_SOURCE_CFLAGS(T_QCanvas.cpp " -DADM_UI_TYPE_BUILD=4")
 TARGET_LINK_LIBRARIES(${ADM_LIB} ADM_core ADM_coreUI ${QT_QTGUI_LIBRARY} ${QT_QTCORE_LIBRARY} ADM_render_qt4)
-INSTALL(TARGETS ${ADM_LIB} RUNTIME DESTINATION ${BIN_DIR}  LIBRARY DESTINATION lib  ARCHIVE DESTINATION lib)
+INSTALL(TARGETS ${ADM_LIB} RUNTIME DESTINATION ${BIN_DIR}  LIBRARY DESTINATION lib${LIB_SUFFIX}  ARCHIVE DESTINATION lib${LIB_SUFFIX})

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_core/src/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_core/src/CMakeLists.txt	2009-08-31 15:56:18 UTC (rev 5282)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_core/src/CMakeLists.txt	2009-08-31 15:56:21 UTC (rev 5283)
@@ -20,4 +20,4 @@
 REMOVE_DEFINITIONS(-DHAVE_CONFIG_H)
 include_directories("${FFMPEG_BINARY_DIR}")
 
-INSTALL(TARGETS ADM_core RUNTIME DESTINATION ${BIN_DIR}  LIBRARY DESTINATION lib  ARCHIVE DESTINATION lib)
+INSTALL(TARGETS ADM_core RUNTIME DESTINATION ${BIN_DIR}  LIBRARY DESTINATION lib${LIB_SUFFIX}  ARCHIVE DESTINATION lib${LIB_SUFFIX})

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/src/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/src/CMakeLists.txt	2009-08-31 15:56:18 UTC (rev 5282)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreAudio/src/CMakeLists.txt	2009-08-31 15:56:21 UTC (rev 5283)
@@ -17,4 +17,4 @@
 INCLUDE_DIRECTORIES(${CMAKE_SOURCE_DIR}/avidemux/ADM_coreAudio/include)
 TARGET_LINK_LIBRARIES(ADM_coreAudio ADM_core)
 
-INSTALL(TARGETS ADM_coreAudio RUNTIME DESTINATION ${BIN_DIR}  LIBRARY DESTINATION lib  ARCHIVE DESTINATION lib)
+INSTALL(TARGETS ADM_coreAudio RUNTIME DESTINATION ${BIN_DIR}  LIBRARY DESTINATION lib${LIB_SUFFIX}  ARCHIVE DESTINATION lib${LIB_SUFFIX})

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreImage/src/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreImage/src/CMakeLists.txt	2009-08-31 15:56:18 UTC (rev 5282)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreImage/src/CMakeLists.txt	2009-08-31 15:56:21 UTC (rev 5283)
@@ -27,4 +27,4 @@
 
 TARGET_LINK_LIBRARIES(ADM_coreImage ADM_core ADM_coreUI ADM_libswscale ADM_libpostproc)
 add_dependencies(ADM_coreImage ffmpeg)
-INSTALL(TARGETS ADM_coreImage RUNTIME DESTINATION ${BIN_DIR}  LIBRARY DESTINATION lib  ARCHIVE DESTINATION lib)
+INSTALL(TARGETS ADM_coreImage RUNTIME DESTINATION ${BIN_DIR}  LIBRARY DESTINATION lib${LIB_SUFFIX}  ARCHIVE DESTINATION lib${LIB_SUFFIX})

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreUI/src/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreUI/src/CMakeLists.txt	2009-08-31 15:56:18 UTC (rev 5282)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_coreUI/src/CMakeLists.txt	2009-08-31 15:56:21 UTC (rev 5283)
@@ -7,4 +7,4 @@
 ADD_LIBRARY(ADM_coreUI SHARED ${ADM_coreUI_SRCS})
 TARGET_LINK_LIBRARIES(ADM_coreUI ADM_core)
 
-INSTALL(TARGETS ADM_coreUI RUNTIME DESTINATION ${BIN_DIR}  LIBRARY DESTINATION lib  ARCHIVE DESTINATION lib)
+INSTALL(TARGETS ADM_coreUI RUNTIME DESTINATION ${BIN_DIR}  LIBRARY DESTINATION lib${LIB_SUFFIX}  ARCHIVE DESTINATION lib${LIB_SUFFIX})

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_libraries/ADM_smjs/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_libraries/ADM_smjs/CMakeLists.txt	2009-08-31 15:56:18 UTC (rev 5282)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_libraries/ADM_smjs/CMakeLists.txt	2009-08-31 15:56:21 UTC (rev 5283)
@@ -16,4 +16,4 @@
 ADD_TARGET_CFLAGS(${ADM_LIB} "-DNDEBUG -DTRIMMED -DEXPORT_JS_API -DJS_USE_SAFE_ARENA -D_IEEE_LIBM")
 TARGET_LINK_LIBRARIES(${ADM_LIB} m)
 
-INSTALL(TARGETS ${ADM_LIB} RUNTIME DESTINATION ${BIN_DIR}  LIBRARY DESTINATION lib  ARCHIVE DESTINATION lib)
\ No newline at end of file
+INSTALL(TARGETS ${ADM_LIB} RUNTIME DESTINATION ${BIN_DIR}  LIBRARY DESTINATION lib${LIB_SUFFIX}  ARCHIVE DESTINATION lib${LIB_SUFFIX})

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_render/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_render/CMakeLists.txt	2009-08-31 15:56:18 UTC (rev 5282)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_render/CMakeLists.txt	2009-08-31 15:56:21 UTC (rev 5283)
@@ -31,7 +31,7 @@
 		TARGET_LINK_LIBRARIES(${ADM_LIB}_gtk ${XVIDEO_LIBRARY_DIR} X11 Xext)
 	ENDIF (USE_XV)
 
-	INSTALL(TARGETS ${ADM_LIB}_gtk RUNTIME DESTINATION ${BIN_DIR}  LIBRARY DESTINATION lib  ARCHIVE DESTINATION lib)
+	INSTALL(TARGETS ${ADM_LIB}_gtk RUNTIME DESTINATION ${BIN_DIR}  LIBRARY DESTINATION lib${LIB_SUFFIX}  ARCHIVE DESTINATION lib${LIB_SUFFIX})
 ENDIF (ADM_UI_GTK)
 
 IF (ADM_UI_QT4)
@@ -43,11 +43,11 @@
 		TARGET_LINK_LIBRARIES(${ADM_LIB}_qt4 ${XVIDEO_LIBRARY_DIR} X11 Xext)
 	ENDIF (USE_XV)
 
-	INSTALL(TARGETS ${ADM_LIB}_qt4 RUNTIME DESTINATION ${BIN_DIR}  LIBRARY DESTINATION lib  ARCHIVE DESTINATION lib)
+	INSTALL(TARGETS ${ADM_LIB}_qt4 RUNTIME DESTINATION ${BIN_DIR}  LIBRARY DESTINATION lib${LIB_SUFFIX}  ARCHIVE DESTINATION lib${LIB_SUFFIX})
 ENDIF (ADM_UI_QT4)
 
 IF (GETTEXT_FOUND)
 	TARGET_LINK_LIBRARIES(${ADM_LIB}_cli ${GETTEXT_LIBRARY_DIR})
 ENDIF (GETTEXT_FOUND)
 
-INSTALL(TARGETS ${ADM_LIB}_cli RUNTIME DESTINATION ${BIN_DIR}  LIBRARY DESTINATION lib  ARCHIVE DESTINATION lib)
\ No newline at end of file
+INSTALL(TARGETS ${ADM_LIB}_cli RUNTIME DESTINATION ${BIN_DIR}  LIBRARY DESTINATION lib${LIB_SUFFIX}  ARCHIVE DESTINATION lib${LIB_SUFFIX})

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/CMakeLists.txt	2009-08-31 15:56:18 UTC (rev 5282)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/CMakeLists.txt	2009-08-31 15:56:21 UTC (rev 5283)
@@ -499,7 +499,7 @@
 		SET (MAC_BUNDLE_DIR "/Applications")
 	ENDIF (MAC_BUNDLE_DIR)
 ELSE (APPLE)
-	INSTALL(TARGETS ${ADM_EXES} RUNTIME DESTINATION ${BIN_DIR} LIBRARY DESTINATION lib)
+	INSTALL(TARGETS ${ADM_EXES} RUNTIME DESTINATION ${BIN_DIR} LIBRARY DESTINATION lib${LIB_SUFFIX})
 ENDIF (APPLE)
 
 IF (UNIX AND NOT APPLE)

Modified: branches/avidemux_2.5_branch_gruntster/cmake/ad_plugin.cmake
===================================================================
--- branches/avidemux_2.5_branch_gruntster/cmake/ad_plugin.cmake	2009-08-31 15:56:18 UTC (rev 5282)
+++ branches/avidemux_2.5_branch_gruntster/cmake/ad_plugin.cmake	2009-08-31 15:56:21 UTC (rev 5283)
@@ -1,7 +1,7 @@
 IF (WIN32)
 	SET(AUDDEC_INSTALL_DIR "${CMAKE_INSTALL_PREFIX}/plugins/audioDecoder/")
 ELSE (WIN32)
-	SET(AUDDEC_INSTALL_DIR "${CMAKE_INSTALL_PREFIX}/lib/ADM_plugins/audioDecoder/")
+	SET(AUDDEC_INSTALL_DIR "${CMAKE_INSTALL_PREFIX}/lib${LIB_SUFFIX}/ADM_plugins/audioDecoder/")
 ENDIF (WIN32)
 
 MACRO(INIT_AUDIO_PLUGIN _lib)

Modified: branches/avidemux_2.5_branch_gruntster/cmake/admFFmpegBuild.cmake
===================================================================
--- branches/avidemux_2.5_branch_gruntster/cmake/admFFmpegBuild.cmake	2009-08-31 15:56:18 UTC (rev 5282)
+++ branches/avidemux_2.5_branch_gruntster/cmake/admFFmpegBuild.cmake	2009-08-31 15:56:21 UTC (rev 5283)
@@ -132,7 +132,7 @@
 if (WIN32)
 	set(FFMPEG_INSTALL_DIR ${BIN_DIR})
 else (WIN32)
-	set(FFMPEG_INSTALL_DIR lib)
+	set(FFMPEG_INSTALL_DIR lib${LIB_SUFFIX})
 endif (WIN32)
 
 add_library(ADM_libswscale UNKNOWN IMPORTED)

Modified: branches/avidemux_2.5_branch_gruntster/cmake/admPluginVideoEncoder.cmake
===================================================================
--- branches/avidemux_2.5_branch_gruntster/cmake/admPluginVideoEncoder.cmake	2009-08-31 15:56:18 UTC (rev 5282)
+++ branches/avidemux_2.5_branch_gruntster/cmake/admPluginVideoEncoder.cmake	2009-08-31 15:56:21 UTC (rev 5283)
@@ -1,7 +1,7 @@
 IF (WIN32)
 	SET(VIDENC_INSTALL_DIR "${CMAKE_INSTALL_PREFIX}/plugins/videoEncoder/")
 ELSE (WIN32)
-	SET(VIDENC_INSTALL_DIR "${CMAKE_INSTALL_PREFIX}/lib/ADM_plugins/videoEncoder/")
+	SET(VIDENC_INSTALL_DIR "${CMAKE_INSTALL_PREFIX}/lib${LIB_SUFFIX}/ADM_plugins/videoEncoder/")
 ENDIF (WIN32)
 
 MACRO(INIT_VIDEO_ENCODER_PLUGIN _lib)

Modified: branches/avidemux_2.5_branch_gruntster/cmake/ae_plugin.cmake
===================================================================
--- branches/avidemux_2.5_branch_gruntster/cmake/ae_plugin.cmake	2009-08-31 15:56:18 UTC (rev 5282)
+++ branches/avidemux_2.5_branch_gruntster/cmake/ae_plugin.cmake	2009-08-31 15:56:21 UTC (rev 5283)
@@ -1,7 +1,7 @@
 IF (WIN32)
 	SET(AUDENC_INSTALL_DIR "${CMAKE_INSTALL_PREFIX}/plugins/audioEncoders/")
 ELSE (WIN32)
-	SET(AUDENC_INSTALL_DIR "${CMAKE_INSTALL_PREFIX}/lib/ADM_plugins/audioEncoders/")
+	SET(AUDENC_INSTALL_DIR "${CMAKE_INSTALL_PREFIX}/lib${LIB_SUFFIX}/ADM_plugins/audioEncoders/")
 ENDIF (WIN32)
 
 MACRO(INIT_AUDIO_ENCODER _lib)

Modified: branches/avidemux_2.5_branch_gruntster/cmake/av_plugin.cmake
===================================================================
--- branches/avidemux_2.5_branch_gruntster/cmake/av_plugin.cmake	2009-08-31 15:56:18 UTC (rev 5282)
+++ branches/avidemux_2.5_branch_gruntster/cmake/av_plugin.cmake	2009-08-31 15:56:21 UTC (rev 5283)
@@ -1,7 +1,7 @@
 IF (WIN32)
 	SET(AUDDEV_INSTALL_DIR "${CMAKE_INSTALL_PREFIX}/plugins/audioDevices/")
 ELSE (WIN32)
-	SET(AUDDEV_INSTALL_DIR "${CMAKE_INSTALL_PREFIX}/lib/ADM_plugins/audioDevices/")
+	SET(AUDDEV_INSTALL_DIR "${CMAKE_INSTALL_PREFIX}/lib${LIB_SUFFIX}/ADM_plugins/audioDevices/")
 ENDIF (WIN32)
 
 MACRO(INIT_AUDIO_DEVICE _lib)

Modified: branches/avidemux_2.5_branch_gruntster/cmake/vf_plugin.cmake
===================================================================
--- branches/avidemux_2.5_branch_gruntster/cmake/vf_plugin.cmake	2009-08-31 15:56:18 UTC (rev 5282)
+++ branches/avidemux_2.5_branch_gruntster/cmake/vf_plugin.cmake	2009-08-31 15:56:21 UTC (rev 5283)
@@ -1,7 +1,7 @@
 IF (WIN32)
 	SET(VIDFLT_INSTALL_DIR "${CMAKE_INSTALL_PREFIX}/plugins/videoFilter/")
 ELSE (WIN32)
-	SET(VIDFLT_INSTALL_DIR "${CMAKE_INSTALL_PREFIX}/lib/ADM_plugins/videoFilter/")
+	SET(VIDFLT_INSTALL_DIR "${CMAKE_INSTALL_PREFIX}/lib${LIB_SUFFIX}/ADM_plugins/videoFilter/")
 ENDIF (WIN32)
 
 MACRO(INIT_VIDEOFILTER_PLUGIN _lib)

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_avcodec/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_avcodec/CMakeLists.txt	2009-08-31 15:56:18 UTC (rev 5282)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_avcodec/CMakeLists.txt	2009-08-31 15:56:21 UTC (rev 5283)
@@ -5,7 +5,7 @@
 if (WIN32)
 	set(FFMPEG_INSTALL_DIR ${AVIDEMUX_INSTALL_PREFIX})
 else (WIN32)
-	set(FFMPEG_INSTALL_DIR ${AVIDEMUX_INSTALL_PREFIX}/lib)
+	set(FFMPEG_INSTALL_DIR ${AVIDEMUX_INSTALL_PREFIX}/lib${LIB_SUFFIX})
 endif (WIN32)
 
 SET(ADM_vidEnc_avcodec_SRCS  interface.c  encoder.cpp  huffyuvEncoder.cpp
@@ -29,4 +29,4 @@
 
 INIT_VIDEO_ENCODER_PLUGIN(ADM_vidEnc_avcodec)
 INSTALL_VIDEO_ENCODER(ADM_vidEnc_avcodec)
-INSTALL(FILES Mpeg1Param.xsd DESTINATION "${VIDENC_INSTALL_DIR}${PLUGIN_SCHEMA_DIR}")
\ No newline at end of file
+INSTALL(FILES Mpeg1Param.xsd DESTINATION "${VIDENC_INSTALL_DIR}${PLUGIN_SCHEMA_DIR}")

Modified: branches/avidemux_2.5_branch_gruntster/plugins/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/CMakeLists.txt	2009-08-31 15:56:18 UTC (rev 5282)
+++ branches/avidemux_2.5_branch_gruntster/plugins/CMakeLists.txt	2009-08-31 15:56:21 UTC (rev 5283)
@@ -43,7 +43,7 @@
 	SET(AVIDEMUX_INSTALL_PREFIX "${AVIDEMUX_INSTALL_PREFIX}" CACHE STRING "")
 ENDIF (NOT AVIDEMUX_INSTALL_PREFIX)
 
-LINK_DIRECTORIES(${AVIDEMUX_INSTALL_PREFIX}/lib)
+LINK_DIRECTORIES(${AVIDEMUX_INSTALL_PREFIX}/lib${LIB_SUFFIX})
 
 ########################################
 # Where is coreConfig ?
@@ -98,7 +98,7 @@
 	ENDIF (CMAKE_BUILD_TYPE STREQUAL "Release")
 ELSE (WIN32)
 	SET(BIN_DIR bin)
-	set(FFMPEG_LIB_DIR ${AVIDEMUX_INSTALL_PREFIX}/lib)
+	set(FFMPEG_LIB_DIR ${AVIDEMUX_INSTALL_PREFIX}/lib${LIB_SUFFIX})
 ENDIF (WIN32)
 
 ########################################



