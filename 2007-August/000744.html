<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Avidemux-svn-commit] r3469 -	branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/avidemux-svn-commit/2007-August/index.html" >
   <LINK REL="made" HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r3469%20-%0A%09branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex&In-Reply-To=%3C200708030005.l7305BQi015671%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000743.html">
   <LINK REL="Next"  HREF="000745.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Avidemux-svn-commit] r3469 -	branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex</H1>
    <B>gruntster at mail.berlios.de</B> 
    <A HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r3469%20-%0A%09branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex&In-Reply-To=%3C200708030005.l7305BQi015671%40sheep.berlios.de%3E"
       TITLE="[Avidemux-svn-commit] r3469 -	branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex">gruntster at mail.berlios.de
       </A><BR>
    <I>Fri Aug  3 02:05:11 CEST 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="000743.html">[Avidemux-svn-commit] r3468 - branches/avidemux_2.4_branch/avidemux
</A></li>
        <LI>Next message: <A HREF="000745.html">[Avidemux-svn-commit] r3470 -	branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_ocr
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#744">[ date ]</a>
              <a href="thread.html#744">[ thread ]</a>
              <a href="subject.html#744">[ subject ]</a>
              <a href="author.html#744">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: gruntster
Date: 2007-08-03 02:04:40 +0200 (Fri, 03 Aug 2007)
New Revision: 3469

Added:
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/aunitbuffer.hpp
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/cpu_accel.c
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/cpu_accel.h
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/decodebufmodel.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/decodebufmodel.hpp
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/format_codes.h
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/mjpeg_logging.c
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/mjpeg_logging.h
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/mjpeg_types.h
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/mpegconsts.h
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/yuv4mpeg.c
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/yuv4mpeg.h
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/yuv4mpeg_intern.h
Removed:
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/buffer.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/buffer.hpp
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/main_example.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/streamType.h
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/vector.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/vector.hpp
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/zalphastrm.hpp
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/zalphastrm_in.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/zalphastrm_out.cpp
Modified:
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/ADM_inout.h
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/ADM_mplexmuxer.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/ADM_mplexout.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/CMakeLists.txt
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/ac3strm_in.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/audiostrm.hpp
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/audiostrm_out.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/aunit.hpp
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/bits.hpp
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/dtsstrm_in.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/inputstrm.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/inputstrm.hpp
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/interact.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/interact.hpp
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/lpcmstrm_in.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/mpastrm_in.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/mpegconsts.c
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/multiplexor.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/multiplexor.hpp
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/padstrm.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/stillsstream.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/stillsstream.hpp
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/stream_params.hpp
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/systems.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/videostrm.hpp
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/videostrm_in.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/videostrm_out.cpp
Log:
[mplex] update mplex library to 1.8.0 to fix mem leaks

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/ADM_inout.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/ADM_inout.h	2007-08-02 19:57:16 UTC (rev 3468)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/ADM_inout.h	2007-08-03 00:04:40 UTC (rev 3469)
@@ -39,7 +39,7 @@
 class IFileBitStream : public IBitStream
 {
 public:
-        IFileBitStream( PacketQueue *inQueue, mplexStreamDescriptor *streamDesc, unsigned int buf_size = BUFFER_SIZE);
+        IFileBitStream( PacketQueue *inQueue, unsigned int buf_size = BUFFER_SIZE);
         ~IFileBitStream();
 
 private:

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/ADM_mplexmuxer.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/ADM_mplexmuxer.cpp	2007-08-02 19:57:16 UTC (rev 3468)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/ADM_mplexmuxer.cpp	2007-08-03 00:04:40 UTC (rev 3469)
@@ -160,38 +160,19 @@
         printf(&quot;Init ok\n&quot;);
         return 1;
 }
-static uint8_t wavToStreamType(WAVHeader *hdr,mplexStreamDescriptor *desc)
-{
-    ADM_assert(hdr);
-    desc-&gt;frequency=hdr-&gt;frequency;
-    desc-&gt;channel=hdr-&gt;channels;
-    switch(hdr-&gt;encoding)
-    {
-        case WAV_LPCM:  desc-&gt;kind= LPCM_AUDIO;break;
-        case WAV_AC3:   desc-&gt;kind=  AC3_AUDIO;;break;
-        case WAV_MP2: case WAV_MP3:   desc-&gt;kind=  MPEG_AUDIO;;break;
-        case WAV_DTS:    desc-&gt;kind=  DTS_AUDIO;;break;
-        default: return 0;
-    }
-  return 1;
-}
+
 extern const char *getStrFromAudioCodec( uint32_t codec);
 int slaveThread( WAVHeader *audioheader )
 {
         MultiplexJob job;
-        mplexStreamDescriptor audioDesc;
-        mplexStreamDescriptor videoDesc;
 
         printf(&quot;[Muxer Slave Thread] Creating job &amp; muxer\n&quot;);
-
         
         printf(&quot;output file created\n&quot;);
-        wavToStreamType(audioheader,&amp;audioDesc);
-        audioin=new IFileBitStream(channelaudio,&amp;audioDesc);
+        audioin=new IFileBitStream(channelaudio);
         
         printf(&quot;audio done (%s), creating video bitstream\n&quot;,getStrFromAudioCodec(audioheader-&gt;encoding));
-        videoDesc.kind=MPEG_VIDEO;
-        videoin=new IFileBitStream(channelvideo,&amp;videoDesc);
+        videoin=new IFileBitStream(channelvideo);
         
         printf(&quot;Both stream ready\n&quot;);
          
@@ -200,14 +181,11 @@
         
         job.mux_format=mux_format;
         job.SetupInputStreams( inputs );
-        
 
-        
         Multiplexor mux(job, *outputStream);
                
         printf(&quot;[Muxer Slave Thread] Muxing\n&quot;);
         mux.Multiplex();
-		mux.Close();
 
         slaveRunning=0;
         printf(&quot;[Muxer Slave Thread] Exiting\n&quot;);

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/ADM_mplexout.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/ADM_mplexout.cpp	2007-08-02 19:57:16 UTC (rev 3468)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/ADM_mplexout.cpp	2007-08-03 00:04:40 UTC (rev 3469)
@@ -58,9 +58,7 @@
 
 }
 
-IFileBitStream::IFileBitStream(PacketQueue *q,mplexStreamDescriptor *desc,
-                                unsigned int buf_size) :
-    IBitStream(desc)
+IFileBitStream::IFileBitStream(PacketQueue *q, unsigned int buf_size) : IBitStream()
 {
         queue=q;        
         SetBufSize(buf_size);

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/CMakeLists.txt
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/CMakeLists.txt	2007-08-02 19:57:16 UTC (rev 3468)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/CMakeLists.txt	2007-08-03 00:04:40 UTC (rev 3469)
@@ -1,17 +1,17 @@
-################################
-#
-################################
-include(AdmLib)
-SET(ADM_LIB ADM_mplex)
-#
-SET(${ADM_LIB}_SRCS 
-ac3strm_in.cpp      ADM_mplexout.cpp   audiostrm_out.cpp  dtsstrm_in.cpp  lpcmstrm_in.cpp   multiplexor.cpp   stream_params.cpp  videostrm_in.cpp   zalphastrm_out.cpp
-ADM_mplexin.cpp     ADM_mthread.cpp    bits.cpp           inputstrm.cpp   padstrm.cpp       systems.cpp        videostrm_out.cpp
-ADM_mplexmuxer.cpp  ADM_transfert.cpp  buffer.cpp         interact.cpp    mpastrm_in.cpp    stillsstream.cpp  vector.cpp         zalphastrm_in.cpp
-mpegconsts.c
-)
-ADD_LIBRARY(${ADM_LIB} STATIC ${${ADM_LIB}_SRCS})
-ADD_ADM_LIB(${ADM_LIB} ADM_libraries)
-################################
-include_directories(../ADM_libmpeg2enc  ../../ADM_userInterfaces/)
-
+################################
+#
+################################
+include(AdmLib)
+SET(ADM_LIB ADM_mplex)
+#
+SET(${ADM_LIB}_SRCS 
+ac3strm_in.cpp      ADM_mplexout.cpp   audiostrm_out.cpp  dtsstrm_in.cpp  lpcmstrm_in.cpp   multiplexor.cpp   stream_params.cpp  videostrm_in.cpp
+ADM_mplexin.cpp     ADM_mthread.cpp    bits.cpp           inputstrm.cpp   padstrm.cpp       systems.cpp       videostrm_out.cpp
+ADM_mplexmuxer.cpp  ADM_transfert.cpp  interact.cpp       mpastrm_in.cpp  stillsstream.cpp  mpegconsts.c      mjpeg_logging.c    decodebufmodel.cpp
+yuv4mpeg.c          cpu_accel.c
+)
+ADD_LIBRARY(${ADM_LIB} STATIC ${${ADM_LIB}_SRCS})
+ADD_ADM_LIB(${ADM_LIB} ADM_libraries)
+################################
+include_directories(&quot;${CMAKE_CURRENT_SOURCE_DIR}&quot;)
+add_definitions(-DHAVE_MEMALIGN)
\ No newline at end of file

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/ac3strm_in.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/ac3strm_in.cpp	2007-08-02 19:57:16 UTC (rev 3468)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/ac3strm_in.cpp	2007-08-03 00:04:40 UTC (rev 3469)
@@ -66,6 +66,7 @@
 AC3Stream::AC3Stream(IBitStream &amp;ibs, Multiplexor &amp;into) : 
 	AudioStream( ibs, into )
 {
+num_frames = 0;
 }
 
 bool AC3Stream::Probe(IBitStream &amp;bs )
@@ -220,7 +221,6 @@
                 bs.StreamName()
                 );
 
-	InitAUbuffer();
 	AU_start = bs.bitcount();
     if (bs.GetBits(16)==AC3_SYNCWORD)
     {
@@ -236,10 +236,10 @@
             
         header_skip = 5;        // Initially skipped past  5 bytes of header 
 
-		num_frames++;
+	num_frames++;
         access_unit.start = AU_start;
-		access_unit.length = framesize;
-        mjpeg_info( &quot;AC3 frame size = %d\n&quot;, framesize );
+	access_unit.length = framesize;
+        mjpeg_info( &quot;AC3 frame size = %d&quot;, framesize );
         bit_rate = ac3_bitrate_index[framesize_code&gt;&gt;1];
 		samples_per_second = ac3_frequency[frequency];
 
@@ -250,7 +250,7 @@
 		access_unit.DTS = access_unit.PTS;
 		access_unit.dorder = decoding_order;
 		++decoding_order;
-		aunits.append( access_unit );
+		aunits.Append( access_unit );
 
     } else
     {
@@ -292,7 +292,7 @@
         {
             mjpeg_warn( &quot;Discarding incomplete final frame AC3 stream %d!&quot;,
                        stream_num);
-            aunits.droplast();
+            aunits.DropLast();
             --decoding_order;
             break;
         }
@@ -324,7 +324,7 @@
 		access_unit.DTS = access_unit.PTS;
 		access_unit.dorder = decoding_order;
 		decoding_order++;
-		aunits.append( access_unit );
+		aunits.Append( access_unit );
 		num_frames++;
 		
 		num_syncword++;

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/audiostrm.hpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/audiostrm.hpp	2007-08-02 19:57:16 UTC (rev 3468)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/audiostrm.hpp	2007-08-03 00:04:40 UTC (rev 3469)
@@ -42,12 +42,10 @@
     unsigned int num_syncword;
 
 protected:
-    virtual bool AUBufferNeedsRefill();
 	virtual void FillAUbuffer(unsigned int frames_to_buffer) = 0;
-	void InitAUbuffer();
     
 	/* State variables for scanning source bit-stream */
-    AAunit access_unit;
+    AUnit access_unit;
     unsigned int header_skip;
 }; 	
 

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/audiostrm_out.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/audiostrm_out.cpp	2007-08-02 19:57:16 UTC (rev 3468)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/audiostrm_out.cpp	2007-08-03 00:04:40 UTC (rev 3469)
@@ -25,7 +25,6 @@
 #include &lt;assert.h&gt;
 
 #include &quot;mjpeg_types.h&quot;
-#include &quot;fastintfns.h&quot;
 #include &quot;audiostrm.hpp&quot;
 #include &quot;multiplexor.hpp&quot;
 
@@ -37,15 +36,8 @@
     FRAME_CHUNK = 24;
 }
 
-void AudioStream::InitAUbuffer()
-{
-	unsigned int i;
-	for( i = 0; i &lt; aunits.BUF_SIZE; ++i )
-		aunits.init( new AAunit );
-}
 
 
-
 /*********************************
  * Signals when audio stream has completed mux run-out specified
  * in associated mux stream. 
@@ -57,15 +49,6 @@
 			( muxinto.running_out &amp;&amp; RequiredPTS() &gt;= muxinto.runout_PTS));
 }
 
-bool AudioStream::AUBufferNeedsRefill()
-{
-    return 
-        !eoscan
-        &amp;&amp; ( aunits.current()+FRAME_CHUNK &gt; last_buffered_AU
-             || 
-             bs.BufferedBytes() &lt; muxinto.sector_size
-            );
-}
 
 /******************************************************************
 	Output_Audio

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/aunit.hpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/aunit.hpp	2007-08-02 19:57:16 UTC (rev 3468)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/aunit.hpp	2007-08-03 00:04:40 UTC (rev 3469)
@@ -7,17 +7,23 @@
 typedef int64_t clockticks;		// This value *must* be signed
                                 // because we frequently compute *offsets*
 
-class Aunit
+class AUnit
 {
 public:
-	Aunit() : length(0), PTS(0), DTS(0) {}
+	AUnit() : length(0), PTS(0), DTS(0) {}
+	//
+	// How many payload bytes muxing AU will require.  Eventually will be more
+	// complex for input streams where AU are no contiguous
+	//
+	inline unsigned int PayloadSize() const { return length; }
 	void markempty() { length = 0; }
 	bitcount_t start;
 	unsigned int length;
     clockticks PTS;
     int        dorder;
-	// Used only for video AU's but otherwise
-	// you have to go crazy on templates.
+	//
+	// Remainder Used only for video AU's... 
+	//
     clockticks DTS;
     int		   porder;
     unsigned int type;
@@ -26,10 +32,5 @@
 
 };
 
-typedef Aunit *AunitPtr;
 
-typedef Aunit VAunit;
-
-typedef Aunit AAunit;
-
 #endif // __AUNIT_H__

Added: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/aunitbuffer.hpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/aunitbuffer.hpp	2007-08-02 19:57:16 UTC (rev 3468)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/aunitbuffer.hpp	2007-08-03 00:04:40 UTC (rev 3469)
@@ -0,0 +1,65 @@
+#ifndef __AUNITBUFFER_H__
+#define __AUNITBUFFER_H__
+
+#include &lt;deque&gt;
+#include &quot;mjpeg_logging.h&quot;
+#include &quot;aunit.hpp&quot;
+
+class AUStream
+{
+public:
+	AUStream()  {}
+	~AUStream() 
+	{
+		for( std::deque&lt;AUnit *&gt;::iterator i = buf.begin(); i &lt; buf.end(); ++i )
+			delete *i;
+	}
+	
+	void Append( AUnit &amp;rec )
+	{
+		if( buf.size() &gt;= BUF_SIZE_SANITY )
+			mjpeg_error_exit1( &quot;INTERNAL ERROR: AU buffer overflow&quot; );
+		buf.push_back( new AUnit(rec) );
+	}
+
+	inline AUnit *Next( ) 
+	{ 
+		if( buf.size()==0 )
+		{
+			return 0;
+		}
+	    else
+		{
+			AUnit *res = buf.front();
+			buf.pop_front();
+			return res;
+		}
+	}
+
+	inline void DropLast()
+		{
+			if( buf.empty() )
+				mjpeg_error_exit1( &quot;INTERNAL ERROR: droplast empty AU buffer&quot; );
+			buf.pop_back();
+			
+		}
+
+	inline AUnit *Lookahead( unsigned int n)
+	{
+		return buf.size() &lt;= n ? 0 : buf[n];
+    }
+
+	inline unsigned int MaxAULookahead() const { return buf.size(); }
+
+private:
+	static const unsigned int BUF_SIZE_SANITY = 1000;
+
+
+	
+	std::deque&lt;AUnit *&gt; buf;
+};
+
+
+
+
+#endif // __AUSTREAM_H__

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/bits.hpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/bits.hpp	2007-08-02 19:57:16 UTC (rev 3468)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/bits.hpp	2007-08-03 00:04:40 UTC (rev 3469)
@@ -6,7 +6,7 @@
 
 typedef uint64_t bitcount_t;
 
-#include &quot;streamType.h&quot;
+
 class BitStreamBuffering
 {
 public:
@@ -120,12 +120,10 @@
 class IBitStream : public IBitStreamUndo 
 {
 public:
-        mplexStreamDescriptor      streamDesc;
- 	IBitStream(mplexStreamDescriptor *desc) :
+ 	IBitStream() :
 		IBitStreamUndo(),
 		streamname( &quot;unnamed&quot; )
 		{
-                    streamDesc=*desc;
 		}
 	virtual ~IBitStream() { Release(); }
 
@@ -154,7 +152,6 @@
 	void Flush( bitcount_t byte_position );
 
 	inline const char *StreamName() { return streamname; }
-
 protected:
 	bool ReadIntoBuffer( unsigned int to_read = BUFFER_SIZE );
 	virtual size_t ReadStreamBytes( uint8_t *buf, size_t number ) = 0;

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/buffer.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/buffer.cpp	2007-08-02 19:57:16 UTC (rev 3468)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/buffer.cpp	2007-08-03 00:04:40 UTC (rev 3469)
@@ -1,124 +0,0 @@
-#ifdef HAVE_CONFIG_H
-#include &quot;config.h&quot;
-#endif
-
-#include &quot;buffer.hpp&quot;
-#include &lt;stdlib.h&gt;
-
-/******************************************************************
- *	Remove entries from FIFO buffer list, if their DTS is less than
- *	actual SCR. These packet data have been already decoded and have
- *	been removed from the system target decoder's elementary stream
- *	buffer.
- *****************************************************************/
-
-void BufferModel::Cleaned(clockticks SCR)
-{
-    BufferQueue *pointer;
-
-    while ((first != NULL) &amp;&amp; first-&gt;DTS &lt; SCR)
-    {
-	  pointer = first;
-	  first = first-&gt;next;
-	  delete pointer;	
-    }
-}
-
-/******************************************************************
- * Return the SCR when there will next be some change in the
- * buffer.
- * If the buffer is empty return a zero timestamp.
- *****************************************************************/
-
-clockticks BufferModel::NextChange()
-{
-	if( first == NULL )
-		return static_cast&lt;clockticks&gt;(0);
-	else
-		return first-&gt;DTS;
-}
-
-
-/******************************************************************
- *
- *	Remove all entries from FIFO buffer list, if their DTS is less
- *	than actual SCR. These packet data have been already decoded and
- *	have been removed from the system target decoder's elementary
- *	stream buffer.
- *****************************************************************/
-
-void BufferModel::Flushed ()
-{
-    BufferQueue *pointer;
-
-    while (first != NULL)
-    {
-	  pointer = first;
-	  first = first-&gt;next;
-	  delete pointer;	
-    }
-}
-
-/******************************************************************
-	BufferModel::Space
-
-	returns free space in the buffer
-******************************************************************/
-
-unsigned int BufferModel::Space ()
-{
-    unsigned int used_bytes;
-    BufferQueue *pointer;
-
-    pointer=first;
-    used_bytes=0;
-
-    while (pointer != NULL)
-    {
-		used_bytes += pointer-&gt;size;
-		pointer = pointer-&gt;next;
-    }
-
-    return (max_size - used_bytes);
-
-}
-
-/******************************************************************
-	Queue_Buffer
-
-	adds entry into the buffer FIFO queue
-******************************************************************/
-
-void BufferModel::Queued (unsigned int bytes,
-					clockticks TS)
-{
-    BufferQueue *pointer;
-
-    pointer=first;
-    if (pointer==NULL)
-    {
-		first = new BufferQueue;
-		first-&gt;size = bytes;
-		first-&gt;next=NULL;
-		first-&gt;DTS = TS;
-    } 
-	else
-    {
-		while ((pointer-&gt;next)!=NULL)
-		{
-			pointer = pointer-&gt;next;
-		}
-
-		pointer-&gt;next = new BufferQueue;
-		pointer-&gt;next-&gt;size = bytes;
-		pointer-&gt;next-&gt;next = NULL;
-		pointer-&gt;next-&gt;DTS = TS;
-    }
-}
-
-
-void BufferModel::Init ( unsigned int size)
-{
-    max_size = size;
-    first = 0;
-}

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/buffer.hpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/buffer.hpp	2007-08-02 19:57:16 UTC (rev 3468)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/buffer.hpp	2007-08-03 00:04:40 UTC (rev 3469)
@@ -1,65 +0,0 @@
-
-/*
- *  buffer.hpp:  Classes for decoder buffer models for mux despatch
- *
- *  Copyright (C) 2001 Andrew Stevens &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">andrew.stevens at philips.com</A>&gt;
- *
- *
- *  This program is free software; you can redistribute it and/or
- *  modify it under the terms of version 2 of the GNU General Public License
- *  as published by the Free Software Foundation.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
- */
-
-
-#ifndef __BUFFER_H__
-#define __BUFFER_H__
-
-#include &quot;aunit.hpp&quot;
-
-class BufferQueue
-{
-public:
-	unsigned int size	;	/* als verkettete Liste implementiert	*/
-    clockticks DTS	;
-    BufferQueue *next	;
-};
-    
-
-class BufferModel
-{
-public:
-  BufferModel() : max_size(0),first(0) {}
-  void Init( unsigned int size);
-  
-  void Cleaned(  clockticks timenow);
-  clockticks NextChange();
-  void Flushed( );
-  unsigned int Space();
-  void Queued( unsigned int bytes, clockticks removaltime);
-  inline unsigned int Size() { return max_size; }
-private:
-  unsigned int max_size;
-  BufferQueue *first;
-};
-
-
-
-#endif // __BUFFER_H__
-
-
-/* 
- * Local variables:
- *  c-file-style: &quot;gnu&quot;
- *  tab-width: 4
- *  indent-tabs-mode: nil
- * End:
- */

Added: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/cpu_accel.c
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/cpu_accel.c	2007-08-02 19:57:16 UTC (rev 3468)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/cpu_accel.c	2007-08-03 00:04:40 UTC (rev 3469)
@@ -0,0 +1,447 @@
+/*
+* cpu_accel.c
+* Copyright (C) 1999-2000 Aaron Holtzman &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">aholtzma at ess.engr.uvic.ca</A>&gt;
+*
+* This file is part of mpeg2dec, a free MPEG-2 video stream decoder.
+*
+* mpeg2dec is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* mpeg2dec is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
+
+#include &lt;config.h&gt;
+#include &lt;stdio.h&gt;
+#include &lt;signal.h&gt;
+#include &lt;setjmp.h&gt;
+#include &lt;stdlib.h&gt;
+#ifdef	HAVE_MALLOC_H
+#include &lt;malloc.h&gt;
+#endif
+#include &lt;unistd.h&gt;
+#include &lt;string.h&gt;
+#include &lt;errno.h&gt;
+#include &quot;cpu_accel.h&quot;
+#include &quot;mjpeg_logging.h&quot;
+
+#ifdef HAVE_ALTIVEC
+extern int altivec_copy_v0();
+#endif
+
+/*
+ * Don't add &quot;mblocks_sub44_mests&quot; to the list below because it does not
+ * have a C-reference code counterpart (mblocks_sub44_mests only exists as
+ * a SIMD routine).
+*/
+
+	const char *disable_simd_flags[] = {
+		&quot;sad_00&quot;,
+		&quot;sad_01&quot;,
+		&quot;sad_10&quot;,
+		&quot;sad_11&quot;,
+		&quot;sad_sub22&quot;,
+		&quot;sad_sub44&quot;,
+		&quot;bsad&quot;,
+		&quot;variance&quot;,
+		&quot;sumsq&quot;,
+		&quot;sumsq_sub22&quot;,
+		&quot;bsumsq_sub22&quot;,
+		&quot;bsumsq&quot;,
+		&quot;build_sub22_mests&quot;,
+		&quot;build_sub44_mests&quot;,
+		&quot;subsample_image&quot;,
+		&quot;find_best_one_pel&quot;,
+		&quot;quant_nonintra&quot;,
+		&quot;quant_weight_intra&quot;,
+		&quot;quant_weight_nonintra&quot;,
+		&quot;iquant_intra&quot;,
+		&quot;iquant_nonintra&quot;,
+		NULL
+		};
+
+static char *parse_next(char **, const char *);
+
+#ifdef HAVE_X86CPU 
+
+/* Some miscelaneous stuff to allow checking whether SSE instructions cause
+   illegal instruction errors.
+*/
+
+static sigjmp_buf sigill_recover;
+
+static RETSIGTYPE sigillhandler(int sig )
+{
+	siglongjmp( sigill_recover, 1 );
+}
+
+typedef RETSIGTYPE (*__sig_t)(int);
+
+static int testsseill()
+{
+	int illegal;
+#if defined(__CYGWIN__)
+	/* SSE causes a crash on CYGWIN, apparently.
+	   Perhaps the wrong signal is being caught or something along
+	   those line ;-) or maybe SSE itself won't work...
+	*/
+	illegal = 1;
+#else
+	__sig_t old_handler = signal( SIGILL, sigillhandler);
+	if( sigsetjmp( sigill_recover, 1 ) == 0 )
+	{
+		asm ( &quot;movups %xmm0, %xmm0&quot; );
+		illegal = 0;
+	}
+	else
+		illegal = 1;
+	signal( SIGILL, old_handler );
+#endif
+	return illegal;
+}
+
+static int x86_accel (void)
+{
+    long eax, ebx, ecx, edx;
+    int32_t AMD;
+    int32_t caps;
+
+	/* Slightly weirdified cpuid that preserves the ebx and edi required
+	   by gcc for PIC offset table and frame pointer */
+
+#ifdef __LP64__
+#  define REG_b &quot;rbx&quot;
+#  define REG_S &quot;rsi&quot;
+#else
+#  define REG_b &quot;ebx&quot;
+#  define REG_S &quot;esi&quot;
+#endif
+	   
+#define cpuid(op,eax,ebx,ecx,edx)	\
+    asm ( &quot;push %%&quot;REG_b&quot;\n&quot; \
+	      &quot;cpuid\n&quot; \
+	      &quot;mov   %%&quot;REG_b&quot;, %%&quot;REG_S&quot;\n&quot; \
+	      &quot;pop   %%&quot;REG_b&quot;\n&quot;  \
+	 : &quot;=a&quot; (eax),			\
+	   &quot;=S&quot; (ebx),			\
+	   &quot;=c&quot; (ecx),			\
+	   &quot;=d&quot; (edx)			\
+	 : &quot;a&quot; (op)			\
+	 : &quot;cc&quot;, &quot;edi&quot;)
+
+    asm (&quot;pushf\n\t&quot;
+	 &quot;pop %0\n\t&quot;
+	 &quot;mov %0,%1\n\t&quot;
+	 &quot;xor $0x200000,%0\n\t&quot;
+	 &quot;push %0\n\t&quot;
+	 &quot;popf\n\t&quot;
+	 &quot;pushf\n\t&quot;
+	 &quot;pop %0&quot;
+         : &quot;=a&quot; (eax),
+	       &quot;=c&quot; (ecx)
+	 :
+	 : &quot;cc&quot;);
+
+
+    if (eax == ecx)		// no cpuid
+	return 0;
+
+    cpuid (0x00000000, eax, ebx, ecx, edx);
+    if (!eax)			// vendor string only
+	return 0;
+
+    AMD = (ebx == 0x68747541) &amp;&amp; (ecx == 0x444d4163) &amp;&amp; (edx == 0x69746e65);
+
+    cpuid (0x00000001, eax, ebx, ecx, edx);
+    if (! (edx &amp; 0x00800000))	// no MMX
+	return 0;
+
+    caps = ACCEL_X86_MMX;
+    /* If SSE capable CPU has same MMX extensions as AMD
+	   and then some. However, to use SSE O.S. must have signalled
+	   it use of FXSAVE/FXRSTOR through CR4.OSFXSR and hence FXSR (bit 24)
+	   here
+	*/
+    if ((edx &amp; 0x02000000))	
+		caps = ACCEL_X86_MMX | ACCEL_X86_MMXEXT;
+	if( (edx &amp; 0x03000000) == 0x03000000 )
+	{
+		/* Check whether O.S. has SSE support... has to be done with
+		   exception 'cos those Intel morons put the relevant bit
+		   in a reg that is only accesible in ring 0... doh! 
+		*/
+		if( !testsseill() )
+			caps |= ACCEL_X86_SSE;
+	}
+
+    cpuid (0x80000000, eax, ebx, ecx, edx);
+    if (eax &lt; 0x80000001)	// no extended capabilities
+		return caps;
+
+    cpuid (0x80000001, eax, ebx, ecx, edx);
+
+    if (edx &amp; 0x80000000)
+	caps |= ACCEL_X86_3DNOW;
+
+    if (AMD &amp;&amp; (edx &amp; 0x00400000))	// AMD MMX extensions
+	{
+		caps |= ACCEL_X86_MMXEXT;
+	}
+
+    return caps;
+}
+#endif
+
+
+#ifdef HAVE_ALTIVEC
+/* AltiVec optimized library for MJPEG tools MPEG-1/2 Video Encoder
+ * Copyright (C) 2002  James Klicman &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">james at klicman.org</A>&gt;
+ *
+ * The altivec_detect() function has been moved here to workaround a bug in a
+ * released version of GCC (3.3.3). When -maltivec and -mabi=altivec are
+ * specified, the bug causes VRSAVE instructions at the beginning and end of
+ * functions which do not use AltiVec. GCC 3.3.3 also lacks support for
+ * '#pragma altivec_vrsave off' which would have been the preferred workaround.
+ *
+ * This AltiVec detection code relies on the operating system to provide an
+ * illegal instruction signal if AltiVec is not present. It is known to work
+ * on Mac OS X and Linux.
+ */
+
+static sigjmp_buf jmpbuf;
+
+static void sig_ill(int sig)
+{
+    siglongjmp(jmpbuf, 1);
+}
+
+int detect_altivec()
+{
+    volatile int detected = 0; /* volatile (modified after sigsetjmp) */
+    struct sigaction act, oact;
+
+    act.sa_handler = sig_ill;
+    sigemptyset(&amp;act.sa_mask);
+    act.sa_flags = 0;
+
+    if (sigaction(SIGILL, &amp;act, &amp;oact)) {
+	perror(&quot;sigaction&quot;);
+	return 0;
+    }
+
+    if (sigsetjmp(jmpbuf, 1))
+	goto noAltiVec;
+
+    /* try to read an AltiVec register */ 
+    altivec_copy_v0();
+
+    detected = 1;
+
+noAltiVec:
+    if (sigaction(SIGILL, &amp;oact, (struct sigaction *)0))
+	perror(&quot;sigaction&quot;);
+
+    return detected;
+}
+#endif
+
+
+int32_t cpu_accel (void)
+{
+#ifdef HAVE_X86CPU 
+    static int got_accel = 0;
+    static int accel;
+
+    if (!got_accel) {
+		got_accel = 1;
+		accel = x86_accel ();
+    }
+
+    return accel;
+#elif defined(HAVE_ALTIVEC)
+    return detect_altivec();
+#else
+    return 0;
+#endif
+}
+
+/*****************************
+ *
+ * Allocate memory aligned to suit SIMD 
+ *
+ ****************************/
+
+#define powerof2(x)     ((((x)-1)&amp;(x))==0)
+
+#if	!defined(HAVE_POSIX_MEMALIGN)
+
+int
+posix_memalign(void **ptr, size_t alignment, size_t size)
+{
+	void *mem;
+
+	if	(alignment % sizeof (void *) != 0 || !powerof2(alignment) != 0)
+		return(EINVAL);
+	mem = malloc((size + alignment - 1) &amp; ~(alignment - 1));
+	if	(mem != NULL)
+	{
+		*ptr = mem;
+		return(0);
+	}
+	return(ENOMEM);
+}
+#endif
+
+#if	!defined(HAVE_MEMALIGN)
+void *
+memalign(size_t alignment, size_t size)
+{
+
+	if 	(alignment % sizeof (void *) || !powerof2(alignment))
+	{
+		errno = EINVAL;
+		return(NULL);
+	}
+	return(malloc((size + alignment - 1) &amp; ~(alignment - 1)));
+}
+#endif
+
+/***********************
+ * Implement fmax() for systems which do not have it.  Not a strictly
+ * conforming implementation - we don't bother checking for NaN which if
+ * mpeg2enc gets means big trouble I suspect ;)
+************************/
+
+#if	!defined(HAVE_FMAX)
+double
+fmax(double x, double y)
+{
+	if	(x &gt; y)
+		return(x);
+	return(y);
+}
+#endif
+
+void *bufalloc( size_t size )
+{
+	static size_t simd_alignment = 16;
+	static int bufalloc_init = 0;
+	int  pgsize;
+	void *buf = NULL;
+
+	if( !bufalloc_init )
+	{
+#ifdef HAVE_X86CPU 
+		if( (cpu_accel() &amp;  (ACCEL_X86_SSE|ACCEL_X86_3DNOW)) != 0 )
+		{
+			simd_alignment = 64;
+			bufalloc_init = 1;
+		}
+#endif		
+	}
+		
+#ifdef ADM_WIN32	// GRUNTSTER
+	pgsize = 4096;
+#else
+	pgsize = sysconf(_SC_PAGESIZE);
+#endif
+
+/*
+ * If posix_memalign fails it could be a broken glibc that caused the error,
+ * so try again with a page aligned memalign request
+*/
+	if (posix_memalign( &amp;buf, simd_alignment, size))
+		buf = memalign(pgsize, size);
+	if (buf &amp;&amp; ((size_t)buf &amp; (simd_alignment - 1)))
+	{
+		free(buf);
+		buf = memalign(pgsize, size);
+	}
+	if (buf == NULL)
+		mjpeg_error_exit1(&quot;malloc of %d bytes failed&quot;, (int)size);
+	if ((size_t)buf &amp; (simd_alignment - 1))
+		mjpeg_error_exit1(&quot;could not allocate %d bytes aligned on a %d byte boundary&quot;, (int)size, (int)simd_alignment);
+	return buf;
+}
+
+int
+disable_simd(char *name)
+	{
+	int	foundit;
+	char	*cp, *simd_env, *dup_backup;
+	const char **dft;
+
+	if	((cp = getenv(&quot;MJPEGTOOLS_SIMD_DISABLE&quot;)) == NULL)
+		return(0);
+
+/*
+ * Special case for &quot;all&quot; so that all 22 or whatever names don't have to be
+ * explicitly specified.  If &quot;all&quot; is seen as the only name in the environment
+ * variable then always return 1.
+*/
+	if	(strcasecmp(cp, &quot;all&quot;) == 0)
+		return(1);
+
+/*
+ * First check that the routine being tested for disabled status exists in
+ * the list of known functions.
+*/
+	foundit = 0;
+	for	(dft = disable_simd_flags; *dft; dft++)
+		{
+		if	(strcasecmp(name, *dft) == 0)
+			{
+			foundit = 1;
+			break;
+			}
+		}
+	if	(foundit == 0)
+		return(0);
+
+/*
+ * Next compare the function name passed as input to the comma separated
+ * names in the environment variable.  If a match is found then return 1
+*/
+	dup_backup = simd_env = strdup(cp);
+	while	((cp = parse_next(&amp;simd_env, &quot;,&quot;)))
+		{
+		foundit = 0;
+		if	(strcasecmp(cp, name) == 0)
+			{
+			foundit = 1;
+			break;
+			}
+		}
+	free(dup_backup);
+	return(foundit);
+	}
+
+static char *parse_next(char **sptr, const char *delim)
+{
+	char *start, *ret;
+	start = ret = *sptr;
+	if ((ret == NULL) || ret == '\0') {
+	   return (NULL);
+	}
+
+	while (*ret != '\0' &amp;&amp;
+		   strchr(delim, *ret) == NULL) {
+		ret++;
+	}
+	if (*ret == '\0') {
+		*sptr = NULL;
+	} else {
+	    *ret = '\0';
+	    ret++;
+	    *sptr = ret;
+	}
+	return (start);
+}

Added: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/cpu_accel.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/cpu_accel.h	2007-08-02 19:57:16 UTC (rev 3468)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/cpu_accel.h	2007-08-03 00:04:40 UTC (rev 3469)
@@ -0,0 +1,58 @@
+/*
+ * cpu_accel.h
+ * Copyright (C) 1999-2000 Aaron Holtzman &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">aholtzma at ess.engr.uvic.ca</A>&gt;
+ *
+ * This file was part of mpeg2dec, a free MPEG-2 video stream decoder.
+ *
+ * mpeg2dec is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * mpeg2dec is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef _CPU_ACCEL_HH
+#define _CPU_ACCEL_HH
+
+#include &lt;stdlib.h&gt;
+#include &quot;mjpeg_types.h&quot;
+
+
+// x86 accelerations
+#define ACCEL_X86_MMX	0x80000000
+#define ACCEL_X86_3DNOW	0x40000000
+#define ACCEL_X86_MMXEXT 0x20000000
+#define ACCEL_X86_SSE   0x10000000
+
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+
+	int32_t cpu_accel (void);
+	void *bufalloc( size_t size );
+#if	!defined(HAVE_POSIX_MEMALIGN)
+	int posix_memalign(void **, size_t, size_t);
+#endif
+#if	!defined(HAVE_MEMALIGN)
+	void *memalign(size_t, size_t);
+#endif
+#if	!defined(HAVE_FMAX)
+	double fmax(double, double);
+#endif
+
+extern const char *disable_simd_flags[];
+extern int disable_simd(char *);
+
+#ifdef __cplusplus
+}
+#endif
+
+
+#endif

Added: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/decodebufmodel.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/decodebufmodel.cpp	2007-08-02 19:57:16 UTC (rev 3468)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/decodebufmodel.cpp	2007-08-03 00:04:40 UTC (rev 3469)
@@ -0,0 +1,83 @@
+#ifdef HAVE_CONFIG_H
+#include &quot;config.h&quot;
+#endif
+
+#include &quot;decodebufmodel.hpp&quot;
+#include &lt;stdlib.h&gt;
+
+using std::deque;
+
+/******************************************************************
+ *	Remove entries from FIFO buffer list, if their DTS is less than
+ *	actual SCR. These packet data have been already decoded and have
+ *	been removed from the system target decoder's elementary stream
+ *	buffer.
+ *****************************************************************/
+
+void DecodeBufModel::Cleaned(clockticks SCR)
+{
+    while ( bufstate.size() != 0 &amp;&amp; bufstate.front().DTS &lt; SCR)
+    {
+		bufstate.pop_front();
+    }
+}
+
+/******************************************************************
+ * Return the SCR when there will next be some change in the
+ * buffer.
+ * If the buffer is empty return a zero timestamp.
+ *****************************************************************/
+
+clockticks DecodeBufModel::NextChange()
+{
+	if( bufstate.size() == 0 )
+		return static_cast&lt;clockticks&gt;(0);
+	else
+		return bufstate.front().DTS;
+}
+
+
+/******************************************************************
+ *
+ *	Remove all entries from FIFO buffer list.
+ *
+ *****************************************************************/
+
+void DecodeBufModel::Flushed ()
+{
+	bufstate.clear();
+}
+
+/******************************************************************
+	DecodeBufModel::Space
+
+	returns free space in the buffer
+******************************************************************/
+
+unsigned int DecodeBufModel::Space ()
+{
+	unsigned int used_bytes = 0;
+	for( std::deque&lt;DecodeBufEntry&gt;::iterator i = bufstate.begin(); 
+		 i &lt; bufstate.end();
+		 ++i )
+	{
+		used_bytes += i-&gt;size;
+    }
+
+    return (buffer_size - used_bytes);
+
+}
+
+/******************************************************************
+	Queue_Buffer
+
+	adds entry into the buffer FIFO queue
+******************************************************************/
+
+void DecodeBufModel::Queued (unsigned int bytes, clockticks TS)
+{
+	DecodeBufEntry entry;
+	entry.size = bytes;
+	entry.DTS = TS;
+	bufstate.push_back( entry );
+}

Added: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/decodebufmodel.hpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/decodebufmodel.hpp	2007-08-02 19:57:16 UTC (rev 3468)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/decodebufmodel.hpp	2007-08-03 00:04:40 UTC (rev 3469)
@@ -0,0 +1,68 @@
+
+/*
+ *  buffer.hpp:  Classes for decoder buffer models for mux despatch
+ *
+ *  Copyright (C) 2001 Andrew Stevens &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">andrew.stevens at philips.com</A>&gt;
+ *
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of version 2 of the GNU General Public License
+ *  as published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+
+#ifndef __DECODEBUFMODEL_H__
+#define __DECODEBUFMODEL_H__
+
+#include &quot;aunit.hpp&quot;
+#include &lt;deque&gt;
+
+
+struct DecodeBufEntry
+{
+	unsigned int size	;	/* als verkettete Liste implementiert	*/
+    clockticks DTS	;
+};
+    
+
+class DecodeBufModel
+{
+public:
+  DecodeBufModel() : buffer_size(0) {}
+  void Init ( unsigned int size)
+  {
+    buffer_size = size;
+  }
+  
+  void Cleaned(  clockticks timenow);
+  clockticks NextChange();
+  void Flushed( );
+  unsigned int Space();
+  void Queued( unsigned int bytes, clockticks removaltime);
+  inline unsigned int Size() { return buffer_size; }
+private:
+  unsigned int buffer_size;
+  std::deque&lt;DecodeBufEntry&gt; bufstate ;
+};
+
+
+
+#endif // __DECODEBUFMODEL_H__
+
+
+/* 
+ * Local variables:
+ *  c-file-style: &quot;gnu&quot;
+ *  tab-width: 4
+ *  indent-tabs-mode: nil
+ * End:
+ */

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/dtsstrm_in.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/dtsstrm_in.cpp	2007-08-02 19:57:16 UTC (rev 3468)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/dtsstrm_in.cpp	2007-08-03 00:04:40 UTC (rev 3469)
@@ -51,6 +51,7 @@
 DTSStream::DTSStream(IBitStream &amp;ibs, Multiplexor &amp;into) : 
 	AudioStream( ibs, into )
 {
+	num_frames = 0;
 }
 
 bool DTSStream::Probe(IBitStream &amp;bs )
@@ -136,7 +137,6 @@
                 bs.StreamName()
                 );
 
-	InitAUbuffer();
 	AU_start = bs.bitcount();
     if (bs.GetBits(32)==DTS_SYNCWORD)
     {
@@ -156,7 +156,7 @@
 		num_frames++;
         access_unit.start = AU_start;
 		access_unit.length = framesize;
-        mjpeg_info( &quot;dts frame size = %d\n&quot;, framesize );
+        mjpeg_info( &quot;dts frame size = %d&quot;, framesize );
 		samples_per_second = dts_frequency[frequency];
 
 		/* Presentation time-stamping  */
@@ -166,7 +166,7 @@
 		access_unit.DTS = access_unit.PTS;
 		access_unit.dorder = decoding_order;
 		++decoding_order;
-		aunits.append( access_unit );
+		aunits.Append( access_unit );
 
     } else
     {
@@ -204,7 +204,7 @@
         {
             mjpeg_warn( &quot;Discarding incomplete final frame dts stream %d!&quot;,
                        stream_num);
-            aunits.droplast();
+            aunits.DropLast();
             decoding_order--;
             break;
         }
@@ -238,7 +238,7 @@
 		access_unit.DTS = access_unit.PTS;
 		access_unit.dorder = decoding_order;
 		decoding_order++;
-		aunits.append( access_unit );
+		aunits.Append( access_unit );
 		num_frames++;
 
 		num_syncword++;

Added: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/format_codes.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/format_codes.h	2007-08-02 19:57:16 UTC (rev 3468)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/format_codes.h	2007-08-03 00:04:40 UTC (rev 3469)
@@ -0,0 +1,39 @@
+/*
+    $Id: format_codes.h,v 1.9 2002/12/17 21:54:24 wackston2 Exp $
+
+    Copyright (C) 2001 Andrew Stevens &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">andrew.stevens at planet-interkom.de</A>&gt;
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
+
+#ifndef __FORMAT_CODES_H__
+#define __FORMAT_CODES_H__
+
+#define MPEG_FORMAT_MPEG1   0
+#define MPEG_FORMAT_VCD     1
+#define MPEG_FORMAT_VCD_NSR 2
+#define MPEG_FORMAT_MPEG2   3
+#define MPEG_FORMAT_SVCD     4
+#define MPEG_FORMAT_SVCD_NSR 5
+#define MPEG_FORMAT_VCD_STILL 6
+#define MPEG_FORMAT_SVCD_STILL 7
+#define MPEG_FORMAT_DVD_NAV 8
+#define MPEG_FORMAT_DVD      9
+
+#define MPEG_FORMAT_FIRST 0
+#define MPEG_FORMAT_LAST MPEG_FORMAT_DVD
+
+#define MPEG_STILLS_FORMAT(x) (x==MPEG_FORMAT_VCD_STILL||x==MPEG_FORMAT_SVCD_STILL)
+#endif /* __FORMAT_CODES_H__ */

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/inputstrm.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/inputstrm.cpp	2007-08-02 19:57:16 UTC (rev 3468)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/inputstrm.cpp	2007-08-03 00:04:40 UTC (rev 3469)
@@ -22,11 +22,9 @@
 
 
 #include &lt;config.h&gt;
-#include &lt;limits.h&gt;
 #include &lt;assert.h&gt;
 
 #include &quot;mjpeg_types.h&quot;
-#include &quot;fastintfns.h&quot;
 #include &quot;inputstrm.hpp&quot;
 #include &quot;multiplexor.hpp&quot;
 
@@ -34,14 +32,12 @@
 {
 }
 
-
 void MuxStream::Init( const int strm_id, 
-					  const unsigned int _buf_scale,
-					  const unsigned int buf_size,
-					  const unsigned int _zero_stuffing,
-					  bool bufs_in_first, 
-					  bool always_bufs
-	) 
+			const unsigned int _buf_scale,
+			const unsigned int buf_size,
+			const unsigned int _zero_stuffing,
+			bool bufs_in_first, 
+			bool always_bufs) 
 {
 	stream_id = strm_id;
 	nsec = 0;
@@ -57,7 +53,6 @@
 }
 
 
-
 unsigned int 
 MuxStream::BufferSizeCode()
 {
@@ -71,11 +66,10 @@
 }
 
 
-
 ElementaryStream::ElementaryStream( IBitStream &amp;ibs,
-                                    Multiplexor &amp;into, 
-									stream_kind _kind) : 
+                                    Multiplexor &amp;into, stream_kind _kind) : 
     InputStream( ibs ),
+    au(0),
 	muxinto( into ),
 	kind(_kind),
     buffer_min(INT_MAX),
@@ -83,11 +77,43 @@
 {
 }
 
+/***********************************
+ *
+ * Scan ahead to buffer enough info on the coming Access Units to
+ * permit look-ahead of look_ahead/processing AUs forward from the
+ * current AU *and* the muxing of at least one sector.
+ *
+ **********************************/
 
+void 
+ElementaryStream::AUBufferLookaheadFill( unsigned int look_ahead)
+{
+    while( !eoscan &amp;&amp;
+           ( look_ahead+1 &gt; aunits.MaxAULookahead() 
+             || bs.BufferedBytes() &lt; muxinto.sector_size ) )
+    {
+        FillAUbuffer(FRAME_CHUNK);
+    }
+}
+
+/******************************************
+ *
+ * Move on to the next Access unit in the Elementary stream
+ *
+ *****************************************/
+
 bool 
 ElementaryStream::NextAU()
 {
-	Aunit *p_au = next();
+    // Free up no longer needed AU record
+    if( au != 0 )
+        delete au;
+
+    // Ensure we have enough in the AU buffer!
+    AUBufferLookaheadFill(1);
+
+    // Get the details of the next AU to be muxed....
+	AUnit *p_au = aunits.Next();
 	if( p_au != NULL )
 	{
 		au = p_au;
@@ -102,10 +128,11 @@
 }
 
 
-Aunit *
-ElementaryStream::Lookahead( )
+AUnit *
+ElementaryStream::Lookahead( unsigned int n)
 {
-    return aunits.lookahead();
+    AUBufferLookaheadFill(n);
+    return aunits.Lookahead( n );
 }
 
 unsigned int 
@@ -134,20 +161,21 @@
  ******************************************************************/
 
 
-
 unsigned int 
 ElementaryStream::ReadPacketPayload(uint8_t *dst, unsigned int to_read)
 {
+    //
+    // Allow for the possibility that stream sub-headers might be needed
+    // E.g. AC3, LPCM, DTS....
+    unsigned int header_size = StreamHeaderSize();
     bitcount_t read_start = bs.GetBytePos();
-    unsigned int actually_read = bs.GetBytes( dst, to_read );
+    unsigned int actually_read = bs.GetBytes( dst+header_size, to_read-header_size );
     bs.Flush( read_start );
     Muxed( actually_read );
+    ReadStreamHeader(dst, header_size);
 	return actually_read;
 }
 
-
-
-
 void ElementaryStream::Muxed (unsigned int bytes_muxed)
 {
 	clockticks   decode_time;
@@ -170,12 +198,13 @@
 	decode_time = RequiredDTS();
 	while (au_unsent &lt; bytes_muxed)
 	{	  
-
+        AUMuxed(true);          // Update stream specific tracking 
+                                // of AUs muxed...
 		bufmodel.Queued(au_unsent, decode_time);
 		bytes_muxed -= au_unsent;
-		if( !NextAU() )
+        new_au_next_sec = NextAU();
+        if( !new_au_next_sec )
 			return;
-		new_au_next_sec = true;
 		decode_time = RequiredDTS();
 	};
 
@@ -187,17 +216,16 @@
 	
 	if (au_unsent &gt; bytes_muxed)
 	{
-
+        AUMuxed(false);
 		bufmodel.Queued( bytes_muxed, decode_time);
 		au_unsent -= bytes_muxed;
 		new_au_next_sec = false;
 	} 
 	else //  if (au_unsent == bytes_muxed)
 	{
+        AUMuxed(false);
 		bufmodel.Queued(bytes_muxed, decode_time);
-		if( ! NextAU() )
-			return;
-		new_au_next_sec = true;
+		new_au_next_sec = NextAU();
 	}	   
 
 }
@@ -208,7 +236,6 @@
 			bufmodel.Space() &gt; max_packet_data);
 }
 
-
 void ElementaryStream::UpdateBufferMinMax()
 {
     buffer_min =  buffer_min &lt; bufmodel.Space() ? 
@@ -218,7 +245,6 @@
 }
 
 
-
 void ElementaryStream::AllDemuxed()
 {
 	bufmodel.Flushed();
@@ -240,41 +266,12 @@
 	timestamp_delay = sync_offset;
 }
 
-Aunit *ElementaryStream::next()
-{
-    Aunit *res;
-    while( AUBufferNeedsRefill() )
-	{
-        FillAUbuffer(FRAME_CHUNK);
-	}
-    res = aunits.next();
-	return res;
-}
-
-
-
-//
-// TODO: The buffer refilling is a mess.  We not only refull here but
-// TODO: also refill in next().  However, neither is *guaranteed* to put
-// TODO: enough data in the buffer.  What we need to ensure is that we have
-// TODO: read enough input stream into the buffer to guarantee a sectors
-// TODO: worth of payload.  A reasonable approximation would be simply to
-// TODO: try to read-ahead 2* the sector size. However, this will break for
-// TODO: streams which have big inclusions.  One example might be direct AVI
-// TODO: reading of mixed streams or reading of program streams.
-//
-
-
 void ElementaryStream::BufferAndOutputSector( )
 {
-    while( AUBufferNeedsRefill() )
-	{
-        FillAUbuffer(FRAME_CHUNK);
-	}
+    AUBufferLookaheadFill(1);   // TODO is this really needed here?
     OutputSector();
 }
 
-
 
 /* 
  * Local variables:

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/inputstrm.hpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/inputstrm.hpp	2007-08-02 19:57:16 UTC (rev 3468)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/inputstrm.hpp	2007-08-03 00:04:40 UTC (rev 3469)
@@ -33,9 +33,8 @@
 
 #include &quot;mplexconsts.hpp&quot;
 #include &quot;bits.hpp&quot;
-#include &quot;aunit.hpp&quot;
-#include &quot;vector.hpp&quot;
-#include &quot;buffer.hpp&quot;
+#include &quot;aunitbuffer.hpp&quot;
+#include &quot;decodebufmodel.hpp&quot;
 
 using std::vector;
 
@@ -72,10 +71,6 @@
 
 };
 
-//
-// Abstract forward reference...
-//
-
 class Multiplexor;
 
 
@@ -126,7 +121,7 @@
 	int        stream_id;
 	unsigned int    buffer_scale;
 	unsigned int 	buffer_size;
-	BufferModel bufmodel;
+	DecodeBufModel  bufmodel;
 	unsigned int 	max_packet_data;
 	unsigned int	min_packet_data;
 	unsigned int    zero_stuffing;
@@ -171,7 +166,7 @@
 	virtual void Close() = 0;
 
 	bool NextAU();
-	Aunit *Lookahead();
+	AUnit *Lookahead( unsigned int n = 0);
 	unsigned int BytesToMuxAUEnd(unsigned int sector_transport_size);
 	bool MuxCompleted();
 	virtual bool MuxPossible(clockticks currentSCR );
@@ -183,22 +178,30 @@
     inline unsigned int BufferMax() { return buffer_max; }
     inline clockticks BaseDTS() { return au-&gt;DTS; };
     inline clockticks BasePTS() { return au-&gt;PTS; };
-    inline clockticks RequiredDTS() { return au-&gt;DTS + timestamp_delay; };
-    inline clockticks RequiredPTS() { return au-&gt;PTS + timestamp_delay; };
+
     inline int        DecodeOrder() { return au-&gt;dorder; }
+
+    inline clockticks RequiredDTS( const AUnit *unit )  
+        { return unit-&gt;DTS + timestamp_delay; };
+    inline clockticks RequiredPTS( const AUnit *unit ) 
+        { return unit-&gt;PTS + timestamp_delay; };
+    inline clockticks RequiredDTS()  
+        { return RequiredDTS(au); };
+    inline clockticks RequiredPTS() 
+        { return  RequiredPTS(au); };
     inline clockticks NextRequiredDTS()
         { 
-            Aunit *next = Lookahead();
+            AUnit *next = Lookahead();
             if( next != 0 )
-                return next-&gt;DTS + timestamp_delay; 
+                return RequiredDTS(next); 
             else
                 return 0;
         };
     inline clockticks NextRequiredPTS()
         { 
-            Aunit *next = Lookahead();
+            AUnit *next = Lookahead();
             if( next != 0 )
-                return next-&gt;PTS + timestamp_delay; 
+                return RequiredPTS(next); 
             else
                 return 0;
         };
@@ -213,21 +216,53 @@
 	virtual unsigned int NominalBitRate() = 0;
 	virtual bool RunOutComplete() = 0;
 
+
+    /******************************************************************
+     *  Reads the stream data from actual input stream, updates decode
+     *  buffer model and current access unit information from the
+     *  look-ahead scanning buffer to account for bytes_muxed bytes being
+     *  muxed out.  
+     * TODO: No longer needs to be virtual
+     *
+     ******************************************************************/
 	virtual unsigned int ReadPacketPayload(uint8_t *dst, unsigned int to_read);
 
+    /********************************************************************
+     * Update stream-specific mux state information to reflect muxing of
+     * current AU.  first_in_sector is set true if AU is first muxed into
+     * the current sector.
+     *
+     *******************************************************************/
+
+    virtual void AUMuxed( bool first_in_sector ) {}
+
+    /**************************************************************
+     * The size of the stream-specific  sub-header (if any)
+     *************************************************************/
+    virtual unsigned int StreamHeaderSize() { return 0; }
+    
+    /*****************************************************************
+     * Reads/generates the stream-specific sub-header for AUs muxed
+     * since last call AUMuxed( true );
+     ****************************************************************/
+
+    virtual void ReadStreamHeader( uint8_t *dst, unsigned int len ) {}
+
     bitcount_t bytes_read;
-protected:
+private:
+    void AUBufferLookaheadFill( unsigned int look_ahead);
+
+//protected:
+public:
 	virtual void FillAUbuffer(unsigned int frames_to_buffer) = 0;
-	virtual void InitAUbuffer() = 0;
-    virtual bool AUBufferNeedsRefill() = 0;
     virtual void OutputSector() = 0;
 	AUStream aunits;
 	void Muxed( unsigned int bytes_muxed );
-	Aunit *au;
+	AUnit *au;
 	clockticks timestamp_delay;
 
 	unsigned int au_unsent;
-	Aunit *next();
+	AUnit *OLDnext();
 	Multiplexor &muxinto;
 	stream_kind kind;
     unsigned int buffer_min;

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/interact.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/interact.cpp	2007-08-02 19:57:16 UTC (rev 3468)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/interact.cpp	2007-08-03 00:04:40 UTC (rev 3469)
@@ -23,13 +23,7 @@
 #include &lt;config.h&gt;
 #include &lt;stdlib.h&gt;
 #include &lt;ctype.h&gt;
-#if 0
-#ifdef _WIN32
-#include &lt;win32defs.h&gt;
-#else
 #include &lt;unistd.h&gt;
-#endif
-#endif
 #include &lt;sys/stat.h&gt;
 #include &lt;mjpeg_logging.h&gt;
 #include &lt;format_codes.h&gt;
@@ -43,7 +37,6 @@
 #include &quot;mplexconsts.hpp&quot;
 #include &quot;aunit.hpp&quot;
 
-#define mjpeg_info mjpeg_warn
 
 static const char *KindNames[] =
 {
@@ -120,22 +113,8 @@
             res.push_back( *i );
 }
 
-static const char *kindToString(StreamKind kind)
-{
-#define KID(x)  x##_AUDIO:return #x;
-    switch(kind)
-    {
-        case KID(MPEG)
-       case  KID(AC3)
-        case KID(LPCM)
-        case KID(DTS)
-        default: 
-            printf(&quot;Kind %d\n&quot;,kind);
-            assert(0);
-    }
-  return &quot;Oops&quot;;
-}
 
+
 void MultiplexJob::SetupInputStreams( std::vector&lt; IBitStream *&gt; &amp;inputs )
 {
     IBitStream *bs;
@@ -143,36 +122,23 @@
     unsigned int i;
     bool bad_file = false;
     
-  for( i = 0; i &lt; inputs.size(); ++i )
+	for( i = 0; i &lt; inputs.size(); ++i )
     {
         bs = inputs[i];
         // Remember the streams initial state...
         bs-&gt;PrepareUndo( undo );
-        switch(bs-&gt;streamDesc.kind)
+        if( LPCMStream::Probe( *bs ) )
         {
-            case MPEG_AUDIO:
-            case AC3_AUDIO:
-            case LPCM_AUDIO:
-            case DTS_AUDIO:
-                mjpeg_info (&quot;File %s looks like an %s Audio stream (fq %u, channel %u).\n&quot;, bs-&gt;StreamName() , kindToString(bs-&gt;streamDesc.kind),bs-&gt;streamDesc.frequency,bs-&gt;streamDesc.channel);
-                bs-&gt;UndoChanges( undo );
-                streams.push_back( new JobStream( bs, bs-&gt;streamDesc.kind) );
-                ++audio_tracks;
-                if(bs-&gt;streamDesc.kind==LPCM_AUDIO) 
-                    lpcm_param.push_back(LpcmParams::Checked(  bs-&gt;streamDesc.frequency,                                         
-                                                   bs-&gt;streamDesc.channel,16));//++lpcm_tracks;
-                continue;
-            case MPEG_VIDEO:
-                mjpeg_info (&quot;File %s looks like an Video stream.&quot;, bs-&gt;StreamName() );
-                bs-&gt;UndoChanges( undo );
-                streams.push_back( new JobStream( bs,MPEG_VIDEO) );
-                ++video_tracks;
-                continue;
-            default: assert(0);
-            
+            mjpeg_info (&quot;File %s looks like an LPCM Audio stream.&quot;,
+                        bs-&gt;StreamName());
+            bs-&gt;UndoChanges( undo );
+            streams.push_back( new JobStream( bs,  LPCM_AUDIO) );
+            ++audio_tracks;
+            ++lpcm_tracks;
+            continue;
         }
-    }
-#if 0
+
+        bs-&gt;UndoChanges( undo );
         if( MPAStream::Probe( *bs ) )
         {
             mjpeg_info (&quot;File %s looks like an MPEG Audio stream.&quot;, 
@@ -205,9 +171,7 @@
             continue;
         }
 
-        bs-&gt;UndoChanges( undo);
-       
-
+        bs-&gt;UndoChanges( undo );
         if( VideoStream::Probe( *bs ) )
         {
             mjpeg_info (&quot;File %s looks like an MPEG Video stream.&quot;,
@@ -231,25 +195,10 @@
             continue;
         }
 #endif
-        //if( LPCMStream::Probe( *bs ) )
-        if(1)
-        {
-            mjpeg_info (&quot;File %s looks like an LPCM Audio stream.&quot;,
-                        bs-&gt;StreamName());
-            bs-&gt;UndoChanges( undo );
-            streams.push_back( new JobStream( bs,  LPCM_AUDIO) );
-            ++audio_tracks;
-            ++lpcm_tracks;
-            continue;
-        }
-        bs-&gt;UndoChanges( undo );
-#if 0 // MEAN: Force LPCM when not recognized
         bad_file = true;
-        delete bs;
         mjpeg_error (&quot;File %s unrecogniseable!&quot;, bs-&gt;StreamName());
-#endif
-#endif
-
+        delete bs;
+    }
     
     if( bad_file )
     {
@@ -268,7 +217,7 @@
 	}
 	for( i = lpcm_param.size(); i &lt; lpcm_tracks; ++i )
 	{
-		//  lpcm_param.push_back(LpcmParams::Default(mux_format));
+		lpcm_param.push_back(LpcmParams::Default(mux_format));
 	}
 
 	//

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/interact.hpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/interact.hpp	2007-08-02 19:57:16 UTC (rev 3468)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/interact.hpp	2007-08-03 00:04:40 UTC (rev 3469)
@@ -83,7 +83,18 @@
  *
  **********************************************************************/
 
-#include &quot;streamType.h&quot;
+enum StreamKind
+  {
+    MPEG_AUDIO,
+    AC3_AUDIO,
+    LPCM_AUDIO,
+    DTS_AUDIO,
+    MPEG_VIDEO
+#ifdef ZALPHA
+    ,
+    Z_ALPHA
+#endif
+  };
 
 class JobStream
 {
@@ -128,7 +139,7 @@
     Program ID
 *************************************************************************/
  
-#define MPLEX_VER    &quot;2.2.3&quot;
+#define MPLEX_VER    &quot;2.2.4&quot;
 #define MPLEX_DATE   &quot;$Date$&quot;
 
 #endif // __INTERACT_H__

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/lpcmstrm_in.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/lpcmstrm_in.cpp	2007-08-02 19:57:16 UTC (rev 3468)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/lpcmstrm_in.cpp	2007-08-03 00:04:40 UTC (rev 3469)
@@ -45,6 +45,7 @@
 	AudioStream( ibs, into ),
     parms(parms)
 {
+	num_frames = 0;
 }
 
 
@@ -89,7 +90,6 @@
                 bs.StreamName()
                 );
 
-	InitAUbuffer();
     
 	AU_start = bs.bitcount();
 
@@ -114,7 +114,7 @@
     access_unit.DTS = access_unit.PTS;
     access_unit.dorder = decoding_order;
     decoding_order++;
-    aunits.append( access_unit );
+    aunits.Append( access_unit );
     
 	OutputHdrInfo();
 }
@@ -144,7 +144,7 @@
         {
             mjpeg_warn(&quot;Discarding incomplete final frame LPCM  stream %d&quot;,
                        stream_num);
-            aunits.droplast();
+            aunits.DropLast();
             --decoding_order;
             break;
         }
@@ -160,7 +160,7 @@
 		access_unit.DTS = access_unit.PTS;
 		access_unit.dorder = decoding_order;
 		decoding_order++;
-		aunits.append( access_unit );
+		aunits.Append( access_unit );
 		num_frames++;
 		
 		num_syncword++;
@@ -294,8 +294,8 @@
     // the smallest value is 1!
     dst[0] = LPCM_SUB_STR_0 + stream_num;
     dst[1] = frames;
-    dst[2] = (starting_frame_offset+1)&gt;&gt;8;
-    dst[3] = (starting_frame_offset+1)&amp;0xff;
+    dst[2] = (starting_frame_offset+4)&gt;&gt;8;
+    dst[3] = (starting_frame_offset+4)&amp;0xff;
     unsigned int bps_code;
     switch( bits_per_sample )
     {

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/main_example.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/main_example.cpp	2007-08-02 19:57:16 UTC (rev 3468)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/main_example.cpp	2007-08-03 00:04:40 UTC (rev 3469)
@@ -1,621 +0,0 @@
-
-/*************************************************************************
-* @mainpage
-*  mplex - General-purpose MPEG-1/2 multiplexer.
-* (C) 2000, 2001 Andrew Stevens &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">andrew.stevens at philips.com</A>&gt;
-* 
-* Doxygen documentation and MPEG Z/Alpha multiplexing part by
-* Gernot Ziegler &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">gz at lysator.liu.se</A>&gt;
-*  Constructed using mplex - MPEG-1/SYSTEMS multiplexer as starting point
-*  Copyright (C) 1994 1995 Christoph Moar
-*  Siemens ZFE ST SN 11 / T SN 6
-*
-*  This program is free software; you can redistribute it and/or modify
-*  it under the terms of the GNU General Public License as published by
-*  the Free Software Foundation; either version 2 of the License, or
-*  (at your option) any later version.					 *
-*
-*  This program is distributed in the hope that it will be useful,
-*  but WITHOUT ANY WARRANTY; without even the implied warranty of
-*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-*  GNU General Public License for more details.	
-*
-*  You should have received a copy of the GNU General Public License
-*  along with this program; if not, write to the Free Software	
-*  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
-*************************************************************************/
-
-#include &lt;config.h&gt;
-#include &lt;stdio.h&gt;
-#ifdef HAVE_GETOPT_H
-#include &lt;getopt.h&gt;
-#endif
-#include &lt;string&gt;
-#include &lt;memory&gt;
-#include &lt;sys/stat.h&gt;
-#ifndef _WIN32
-#include &lt;sys/param.h&gt;
-#endif
-#include &lt;ctype.h&gt;
-#include &lt;math.h&gt;
-#include &quot;cpu_accel.h&quot;
-#include &quot;mjpeg_types.h&quot;
-#include &quot;mjpeg_logging.h&quot;
-#include &quot;mpegconsts.h&quot;
-
-#include &quot;interact.hpp&quot;
-#include &quot;bits.hpp&quot;
-#include &quot;outputstrm.hpp&quot;
-#include &quot;multiplexor.hpp&quot;
-
-
-using std::auto_ptr;
-
-
-/*************************************************************************
- Command line wrapper.  Basically, all the command line and file (actually
- pipe and FIFO is what would be more normal) I/O specific sub-classes
-
- Plus the top-level entry point.  That's all!!
-
-*************************************************************************/
-
-
-#if	!defined(HAVE_LROUND)
-extern &quot;C&quot; {
-long
-lround(double x)
-{
-	long l = ceil(x);
-	return(l);
-}
-};
-#endif
-
-
-
-class FileOutputStream : public OutputStream
-{
-public:
-    FileOutputStream( const char *filename_pat );
-    virtual int  Open( );
-    virtual void Close();
-    virtual off_t SegmentSize( );
-    virtual void NextSegment();
-    virtual void Write(uint8_t *data, unsigned int len);
-
-private:
-    FILE *strm;
-    char filename_pat[MAXPATHLEN];
-    char cur_filename[MAXPATHLEN];
-
-};
-
-
-
-FileOutputStream::FileOutputStream( const char *name_pat ) 
-{
-	strncpy( filename_pat, name_pat, MAXPATHLEN );
-	snprintf( cur_filename, MAXPATHLEN, filename_pat, segment_num );
-}
-      
-int FileOutputStream::Open()
-{
-	strm = fopen( cur_filename, &quot;wb&quot; );
-	if( strm == NULL )
-	{
-		mjpeg_error_exit1( &quot;Could not open for writing: %s&quot;, cur_filename );
-	}
-
-	return 0;
-}
-
-void FileOutputStream::Close()
-{ 
-    fclose(strm);
-}
-
-
-off_t
-FileOutputStream::SegmentSize()
-{
-	struct stat stb;
-    fstat(fileno(strm), &amp;stb);
-	off_t written = stb.st_size;
-    return written;
-}
-
-void 
-FileOutputStream::NextSegment( )
-{
-    auto_ptr&lt;char&gt; prev_filename_buf( new char[strlen(cur_filename)+1] );
-    char *prev_filename = prev_filename_buf.get();
-	fclose(strm);
-	++segment_num;
-    strcpy( prev_filename, cur_filename );
-	snprintf( cur_filename, MAXPATHLEN, filename_pat, segment_num );
-	if( strcmp( prev_filename, cur_filename ) == 0 )
-	{
-		mjpeg_error_exit1( 
-			&quot;Need to split output but there appears to be no %%d in the filename pattern %s&quot;, filename_pat );
-	}
-	strm = fopen( cur_filename, &quot;wb&quot; );
-	if( strm == NULL )
-	{
-		mjpeg_error_exit1( &quot;Could not open for writing: %s&quot;, cur_filename );
-	}
-}
-
-void
-FileOutputStream::Write( uint8_t *buf, unsigned int len )
-{
-    if( fwrite( buf, 1, len, strm ) != len )
-    {
-        mjpeg_error_exit1( &quot;Failed write: %s&quot;, cur_filename );
-    }
-}
-
-
-
-/********************************
- *
- * IFileBitStream - Input bit stream class for bit streams sourced
- * from standard file I/O (this of course *includes* network sockets,
- * fifo's, et al).
- *
- * OLAF: To hook into your PES reader/reconstructor you need to define
- * a class like this one, where 'ReadStreamBytes' calls you code to
- * generate the required number of bytes of ES data and transfer it 
- * to the specified buffer.  The logical way to do this would be to
- * inherit IBitStream as a base class of the top-level classes for the ES
- * reconstructors.
- *
- ********************************/
-
-class IFileBitStream : public IBitStream
-{
-public:
- 	IFileBitStream( const char *bs_filename, 
-					unsigned int buf_size = BUFFER_SIZE);
-	~IFileBitStream();
-
-private:
-	FILE *fileh;
-	char *filename;
-	virtual size_t ReadStreamBytes( uint8_t *buf, size_t number ) 
-		{
-			return fread(buf,sizeof(uint8_t), number, fileh ); 
-		}
-	virtual bool EndOfStream() { return feof(fileh) != 0; }
-	
-};
-
-
-
-IFileBitStream::IFileBitStream( const char *bs_filename,
-                                unsigned int buf_size) :
-    IBitStream()
-{
-	if ((fileh = fopen(bs_filename, &quot;rb&quot;)) == NULL)
-	{
-		mjpeg_error_exit1( &quot;Unable to open file %s for reading.&quot;, bs_filename);
-	}
-	filename = strcpy( new char[strlen(bs_filename)+1], bs_filename );
-    streamname = filename;
-
-    SetBufSize(buf_size);
-	eobs = false;
-    byteidx = 0;
-	if (!ReadIntoBuffer())
-	{
-		if (buffered==0)
-		{
-			mjpeg_error_exit1( &quot;Unable to read from %s.&quot;, bs_filename);
-		}
-	}
-}
-
-
-/**
-   Destructor: close the device containing the bit stream after a read
-   process
-*/
-IFileBitStream::~IFileBitStream()
-{
-	if (fileh)
-	{
-		fclose(fileh);
-		delete filename;
-	}
-	fileh = 0;
-    Release();
-}
-
-
-/*******************************
- *
- * Command line job class - sets up a Multiplex Job based on command
- * line and File I/O...
- *
- ******************************/
-
-class CmdLineMultiplexJob : public MultiplexJob
-{
-public:
-	CmdLineMultiplexJob( unsigned int argc, char *argv[]);
-
-private:
-	void InputStreamsFromCmdLine (unsigned int argc, char* argv[] );
-	void Usage(char *program_name);
-	bool ParseVideoOpt( const char *optarg );
-	bool ParseLpcmOpt( const char *optarg );
-	bool ParseWorkaroundOpt( const char *optarg );
-	bool ParseTimeOffset( const char *optarg );
-	
-
-	static const char short_options[];
-
-#if defined(HAVE_GETOPT_LONG)
-	static struct option long_options[];
-#endif
-
-};
-
-const char CmdLineMultiplexJob::short_options[] =
-    &quot;o:b:r:O:v:f:l:s:S:p:W:L:VMh&quot;;
-#if defined(HAVE_GETOPT_LONG)
-struct option CmdLineMultiplexJob::long_options[] = 
-{
-	{ &quot;verbose&quot;,           1, 0, 'v' },
-	{ &quot;format&quot;,            1, 0, 'f' },
-	{ &quot;mux-bitrate&quot;,       1, 0, 'r' },
-	{ &quot;video-buffer&quot;,      1, 0, 'b' },
-	{ &quot;lpcm-params&quot;,       1, 0, 'L' },
-	{ &quot;output&quot;,            1, 0, 'o' },
-	{ &quot;sync-offset&quot;,    	1, 0, 'O' },
-	{ &quot;vbr&quot;,      	        1, 0, 'V' },
-	{ &quot;system-headers&quot;,    1, 0, 'h' },
-	{ &quot;split-segment&quot;,     0, 0, 'M' },
-	{ &quot;max-segment-size&quot;,  1, 0, 'S' },
-	{ &quot;mux-limit&quot;,   	    1, 0, 'l' },
-	{ &quot;packets-per-pack&quot;,  1, 0, 'p' },
-	{ &quot;sector-size&quot;,       1, 0, 's' },
-	{ &quot;workarounds&quot;, 1, 0, 'W' },
-	{ &quot;help&quot;,              0, 0, '?' },
-	{ 0,                   0, 0, 0   }
-};
-#endif
-
-
-CmdLineMultiplexJob::CmdLineMultiplexJob(unsigned int argc, char *argv[]) :
-	MultiplexJob()
-{
-    int n;
-    outfile_pattern = NULL;
-
-#if defined(HAVE_GETOPT_LONG)
-	while( (n=getopt_long(argc,argv,short_options,long_options, NULL)) != -1 )
-#else
-    while( (n=getopt(argc,argv,short_options)) != -1 )
-#endif
-	{
-		switch(n)
-		{
-        case 0 :
-            break;
-		case 'o' :
-			outfile_pattern = optarg;
-			break;
-		case 'v' :
-			verbose = atoi(optarg);
-			if( verbose &lt; 0 || verbose &gt; 2 )
-				Usage(argv[0]);
-			break;
-
-		case 'V' :
-			VBR = true;
-			break;
-	  
-		case 'h' :
-			always_system_headers = true;
-			break;
-
-		case 'b' :
-            if( ! ParseVideoOpt( optarg ) )
-            {
-                mjpeg_error( &quot;Illegal video decoder buffer size(s): %s&quot;, 
-                             optarg );
-                Usage(argv[0]);
-            }
-            break;
-        case 'L':
-            if( ! ParseLpcmOpt( optarg ) )
-            {
-                mjpeg_error( &quot;Illegal LPCM option(s): %s&quot;, optarg );
-                Usage(argv[0]);
-            }
-            break;
-
-		case 'r':
-			data_rate = atoi(optarg);
-			if( data_rate &lt; 0 )
-				Usage(argv[0]);
-			/* Convert from kbit/sec (user spec) to 50B/sec units... */
-			data_rate = (( data_rate * 1000 / 8 + 49) / 50 ) * 50;
-			break;
-
-		case 'O':
-			if( ! ParseTimeOffset(optarg) )
-			{
-				mjpeg_error( &quot;Time offset units if specified must: ms|s|mpt&quot; );
-				Usage(argv[0]);
-			}
-			break;
-          
-		case 'l' : 
- 			max_PTS = atoi(optarg);
-			if( max_PTS &lt; 1  )
-				Usage(argv[0]);
-			break;
-		
-		case 'p' : 
-			packets_per_pack = atoi(optarg);
-			if( packets_per_pack &lt; 1 || packets_per_pack &gt; 100  )
-				Usage(argv[0]);
-			break;
-		
-	  
-		case 'f' :
-			mux_format = atoi(optarg);
-			if( mux_format &lt; MPEG_FORMAT_MPEG1 || mux_format &gt; MPEG_FORMAT_LAST
-                )
-				Usage(argv[0]);
-			break;
-		case 's' :
-			sector_size = atoi(optarg);
-			if( sector_size &lt; 256 || sector_size &gt; 16384 )
-				Usage(argv[0]);
-			break;
-		case 'S' :
-			max_segment_size = atoi(optarg);
-			if( max_segment_size &lt; 0  )
-				Usage(argv[0]);
-			break;
-		case 'M' :
-			multifile_segment = true;
-			break;
-        case 'W' :
-            if( ! ParseWorkaroundOpt( optarg ) )
-            {
-                Usage(argv[0]);
-            }
-            break;
-		case '?' :
-		default :
-			Usage(argv[0]);
-			break;
-		}
-	}
-	if (argc - optind &lt; 1 || outfile_pattern == NULL)
-    {	
-		Usage(argv[0]);
-    }
-	(void)mjpeg_default_handler_verbosity(verbose);
-	mjpeg_info( &quot;mplex version %s (%s %s)&quot;,VERSION,MPLEX_VER,MPLEX_DATE );
-
-    InputStreamsFromCmdLine( argc-(optind-1), argv+optind-1);
-}
-
-/*************************************************************************
- Usage banner for the command line wrapper.
-*************************************************************************/
-
-    
-void CmdLineMultiplexJob::Usage(char *str)
-{
-    fprintf( stderr,
-	&quot;mjpegtools mplex-2 version &quot; VERSION &quot; (&quot; MPLEX_VER &quot;)\n&quot;
-	&quot;Usage: %s [params] -o &lt;output filename pattern&gt; &lt;input file&gt;... \n&quot;
-	&quot;         %%d in the output file name is by segment count\n&quot;
-	&quot;  where possible params are:\n&quot;
-	&quot;--verbose|-v num\n&quot;
-    &quot;  Level of verbosity. 0 = quiet, 1 = normal 2 = verbose/debug\n&quot;
-	&quot;--format|-f fmt\n&quot;
-    &quot;  Set defaults for particular MPEG profiles\n&quot;
-	&quot;  [0 = Generic MPEG1, 1 = VCD, 2 = user-rate VCD, 3 = Generic MPEG2,\n&quot;
-    &quot;   4 = SVCD, 5 = user-rate SVCD\n&quot;
-	&quot;   6 = VCD Stills, 7 = SVCD Stills, 8 = DVD with NAV sectors, 9 = DVD]\n&quot;
-    &quot;--mux-bitrate|-r num\n&quot;
-    &quot;  Specify data rate of output stream in kbit/sec\n&quot;
-	&quot;    (default 0=Compute from source streams)\n&quot;
-	&quot;--video-buffer|-b num [, num...] \n&quot;
-    &quot;  Specifies decoder buffers size in kB.  [ 20...2000]\n&quot;
-    &quot;--lpcm-params | -L samppersec:chan:bits [, samppersec:chan:bits]\n&quot;
-	&quot;--mux-limit|-l num\n&quot;
-    &quot;  Multiplex only num seconds of material (default 0=multiplex all)\n&quot;
-	&quot;--sync-offset|-O num ms|s|mpt\n&quot;
-    &quot;  Specify offset of timestamps (video-audio) in mSec\n&quot;
-	&quot;--sector-size|-s num\n&quot;
-    &quot;  Specify sector size in bytes for generic formats [256..16384]\n&quot;
-    &quot;--vbr|-V\n&quot;
-    &quot;  Multiplex variable bit-rate video\n&quot;
-	&quot;--packets-per-pack|-p num\n&quot;
-    &quot;  Number of packets per pack generic formats [1..100]\n&quot;
-	&quot;--system-headers|-h\n&quot;
-    &quot;  Create System header in every pack in generic formats\n&quot;
-	&quot;--max-segment-size|-S size\n&quot;
-    &quot;  Maximum size of output file(s) in Mbyte (default: 0) (no limit)\n&quot;
-	&quot;--split-segment|-M\n&quot;
-    &quot;  Simply split a sequence across files rather than building run-out/run-in\n&quot;
-    &quot;--workaround|-W workaround [, workaround ]\n&quot;
-	&quot;--help|-?\n&quot;
-    &quot;  Print this lot out!\n&quot;, str);
-	exit (1);
-}
-
-
-bool CmdLineMultiplexJob::ParseLpcmOpt( const char *optarg )
-{
-    char *endptr, *startptr;
-    unsigned int samples_sec;
-    unsigned int channels;
-    unsigned int bits_sample;
-    endptr = const_cast&lt;char *&gt;(optarg);
-    do 
-    {
-        startptr = endptr;
-        samples_sec = static_cast&lt;unsigned int&gt;(strtol(startptr, &amp;endptr, 10));
-        if( startptr == endptr || *endptr != ':' )
-            return false;
-
-
-        startptr = endptr+1;
-        channels = static_cast&lt;unsigned int&gt;(strtol(startptr, &amp;endptr, 10));
-        if(startptr == endptr || *endptr != ':' )
-            return false;
-
-        startptr = endptr+1;
-        bits_sample = static_cast&lt;unsigned int&gt;(strtol(startptr, &amp;endptr, 10));
-        if( startptr == endptr )
-            return false;
-
-        LpcmParams *params = LpcmParams::Checked( samples_sec,
-                                                  channels,
-                                                  bits_sample );
-        if( params == 0 )
-            return false;
-        lpcm_param.push_back(params);
-        if( *endptr == ',' )
-            ++endptr;
-    } while( *endptr != '\0' );
-    return true;
-}
-
-
-bool CmdLineMultiplexJob::ParseWorkaroundOpt( const char *optarg )
-{
-    char *endptr, *startptr;
-    endptr = const_cast&lt;char *&gt;(optarg);
-    struct { const char *longname; char shortname; bool *flag; } flag_table[] =
-        {
-            { 0, '\0', 0 }
-        };
-    for(;;)
-    {
-        // Find start of next flag...
-        while( isspace(*endptr) || *endptr == ',' )
-            ++endptr;
-        if( *endptr == '\0' )
-            break;
-        startptr = endptr;
-        // Find end of current flag...
-        while( *endptr != ' ' &amp;&amp; *endptr != ',' &amp;&amp; *endptr != '\0' )
-            ++endptr;
-            
-        size_t len = endptr - startptr;
-
-        int flag = 0;
-        while( flag_table[flag].longname != 0 )
-        {
-            if( (len == 1 &amp;&amp; *startptr == flag_table[flag].shortname ) ||
-                strncmp( startptr, flag_table[flag].longname, len ) == 0 )
-            {
-                *flag_table[flag].flag = true;
-                break;
-            }
-            ++flag;
-        }
-
-        if( flag_table[flag].longname == 0 )
-        {
-            std::string message( &quot;Illegal work-around option: not one of &quot; );
-            flag = 0;
-            char sep[] = &quot;,&quot;;
-            do
-            {
-                message += flag_table[flag].longname;
-                message += sep;
-                message += flag_table[flag].shortname;
-                ++flag;
-                if( flag_table[flag].longname != 0 )
-                    message += sep;
-            }
-            while( flag_table[flag].longname != 0 );
-            mjpeg_error( message.c_str() );
-            return false;
-        }
-
-    } 
-    return true;
-}
-
-bool CmdLineMultiplexJob::ParseVideoOpt( const char *optarg )
-{
-    char *endptr, *startptr;
-    unsigned int buffer_size;
-    endptr = const_cast&lt;char *&gt;(optarg);
-    do 
-    {
-        startptr = endptr;
-        buffer_size = static_cast&lt;unsigned int&gt;(strtol(startptr, &amp;endptr, 10));
-        if( startptr == endptr )
-            return false;
-
-        VideoParams *params = VideoParams::Checked( buffer_size );
-        if( params == 0 )
-            return false;
-        video_param.push_back(params);
-        if( *endptr == ',' )
-            ++endptr;
-    } 
-    while( *endptr != '\0' );
-    return true;
-}
-
-bool CmdLineMultiplexJob::ParseTimeOffset(const char *optarg)
-{
-    double f;
-    double persecond=1000.0;
-    char *e;
-
-    f=strtod(optarg,&amp;e);
-    if( e ) {
-        while(isspace(*e)) e++;
-        if(!strcmp(e,&quot;ms&quot;)) persecond=1000.0;
-        else if(!strcmp(e,&quot;s&quot;)) persecond=1.0;
-        else if(!strcmp(e,&quot;mpt&quot;)) persecond=90000.0;
-		else
-			return false;
-    }
-    video_offset = lround(f*CLOCKS/(persecond));
-	if( video_offset &lt; 0 )
-	{
-		audio_offset = - video_offset;
-		video_offset = 0;
-	}
-	return true;
-}
-
-void CmdLineMultiplexJob::InputStreamsFromCmdLine(unsigned int argc, char* argv[] )
-{
-	vector&lt;IBitStream *&gt; inputs;
-    unsigned int i;
-	for( i = 1; i &lt; argc; ++i )
-    {
-		inputs.push_back( new IFileBitStream( argv[i] ) );
-	}
-	SetupInputStreams( inputs );
-}
-
-
-int main (int argc, char* argv[])
-{
-	CmdLineMultiplexJob job(argc,argv);
-	FileOutputStream output( job.outfile_pattern );
-	Multiplexor mux(job, output);
-	mux.Multiplex();
-
-    return (0);	
-}
-
-			

Added: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/mjpeg_logging.c
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/mjpeg_logging.c	2007-08-02 19:57:16 UTC (rev 3468)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/mjpeg_logging.c	2007-08-03 00:04:40 UTC (rev 3469)
@@ -0,0 +1,227 @@
+/*
+    $Id: mjpeg_logging.c,v 1.14 2005/05/18 17:21:47 sms00 Exp $
+
+    Copyright (C) 2000 Herbert Valerio Riedel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">hvr at gnu.org</A>&gt;
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
+
+
+#ifdef HAVE_CONFIG_H
+# include &lt;config.h&gt;
+#endif
+
+#include &lt;stdlib.h&gt;
+#include &lt;stdarg.h&gt;
+#include &lt;stdio.h&gt;
+#include &lt;assert.h&gt;
+#include &lt;string.h&gt;
+
+#include &quot;mjpeg_logging.h&quot;
+
+#define MAX_DEFAULT_ID_SIZE 16
+#define DEFAULT_DEFAULT_ID &quot;???&quot;
+
+#ifdef HAVE___PROGNAME
+extern const char *__progname;
+#endif
+
+static log_level_t mjpeg_log_verbosity = LOG_NONE;
+static char default_handler_id[MAX_DEFAULT_ID_SIZE];
+static char default_handler_id_is_set = 0;
+
+static int default_mjpeg_log_filter( log_level_t level )
+{
+  int verb_from_env;
+  if( mjpeg_log_verbosity == 0 )
+    {
+      char *mjpeg_verb_env = getenv(&quot;MJPEG_VERBOSITY&quot;);
+      if( mjpeg_verb_env != NULL )
+        {
+          verb_from_env = LOG_WARN-atoi(mjpeg_verb_env);
+          if( verb_from_env &gt;= LOG_DEBUG &amp;&amp; verb_from_env &lt;= LOG_ERROR )
+            mjpeg_log_verbosity = (log_level_t)verb_from_env;
+        }
+    }
+  return (level &lt; LOG_WARN &amp;&amp; level &lt; mjpeg_log_verbosity);
+}
+
+static mjpeg_log_filter_t _filter = default_mjpeg_log_filter;
+
+static void
+default_mjpeg_log_handler(log_level_t level, const char message[])
+{
+  const char *ids;
+
+  if( (*_filter)( level ) )
+    return;
+  if (default_handler_id_is_set) {
+    ids = default_handler_id;
+  } else {
+#ifdef HAVE___PROGNAME
+    ids = __progname;
+#else
+    ids = DEFAULT_DEFAULT_ID;
+#endif
+  }
+  switch(level) {
+  case LOG_ERROR:
+    fprintf(stderr, &quot;**ERROR: [%s] %s\n&quot;, ids, message);
+    break;
+  case LOG_DEBUG:
+    fprintf(stderr, &quot;--DEBUG: [%s] %s\n&quot;, ids, message);
+    break;
+  case LOG_WARN:
+    fprintf(stderr, &quot;++ WARN: [%s] %s\n&quot;, ids, message);
+    break;
+  case LOG_INFO:
+    fprintf(stderr, &quot;   INFO: [%s] %s\n&quot;, ids, message);
+    break;
+  default:
+    assert(0);
+  }
+}
+
+static mjpeg_log_handler_t _handler = default_mjpeg_log_handler;
+
+
+mjpeg_log_handler_t
+mjpeg_log_set_handler(mjpeg_log_handler_t new_handler)
+{
+  mjpeg_log_handler_t old_handler = _handler;
+
+  _handler = new_handler;
+
+  return old_handler;
+}
+
+/***************
+ *
+ * Set default log handlers degree of verboseity.
+ * 0 = quiet, 1 = info, 2 = debug
+ *
+ *************/
+
+int
+mjpeg_default_handler_verbosity(int verbosity)
+{
+  int prev_verb = mjpeg_log_verbosity;
+  mjpeg_log_verbosity = (log_level_t)(LOG_WARN - verbosity);
+  return prev_verb;
+}
+
+/*
+ * Set identifier string used by default handler
+ *
+ */
+int
+mjpeg_default_handler_identifier(const char *new_id)
+{
+  const char *s;
+  if (new_id == NULL) {
+    default_handler_id_is_set = 0;
+    return 0;
+  }
+  /* find basename of new_id (remove any directory prefix) */
+  if ((s = strrchr(new_id, '/')) == NULL)
+    s = new_id;
+  else
+    s = s + 1;
+  strncpy(default_handler_id, s, MAX_DEFAULT_ID_SIZE);
+  default_handler_id[MAX_DEFAULT_ID_SIZE-1] = '\0';
+  default_handler_id_is_set = 1;
+  return 0;
+}
+
+
+static void
+mjpeg_logv(log_level_t level, const char format[], va_list args)
+{
+  char buf[1024] = { 0, };
+
+  /* TODO: Original had a re-entrancy error trap to assist bug
+     finding.  To make this work with multi-threaded applications a
+     lock is needed hence delete.
+  */
+
+  
+  vsnprintf(buf, sizeof(buf)-1, format, args);
+
+  _handler(level, buf);
+}
+
+void
+mjpeg_log(log_level_t level, const char format[], ...)
+{
+  va_list args;
+  va_start (args, format);
+  mjpeg_logv(level, format, args);
+  va_end (args);
+}
+
+void
+mjpeg_debug(const char format[], ...)
+{
+  va_list args;
+  va_start (args, format);
+  mjpeg_logv(LOG_DEBUG, format, args);
+  va_end (args);
+}
+
+void
+mjpeg_info(const char format[], ...)
+{
+  va_list args;
+  va_start (args, format);
+  mjpeg_logv(LOG_INFO, format, args);
+  va_end (args);
+}
+
+void
+mjpeg_warn(const char format[], ...)
+{
+  va_list args;
+  va_start (args, format);
+  mjpeg_logv(LOG_WARN, format, args);
+  va_end (args);
+}
+
+void
+mjpeg_error(const char format[], ...)
+{
+  va_list args;
+  va_start (args, format);
+  mjpeg_logv(LOG_ERROR, format, args);
+  va_end (args);
+}
+
+void
+mjpeg_error_exit1(const char format[], ...)
+{
+  va_list args;
+  va_start( args, format );
+  mjpeg_logv( LOG_ERROR, format, args);
+  va_end(args);           
+  exit(EXIT_FAILURE);
+}
+
+
+/* 
+ * Local variables:
+ *  c-file-style: &quot;gnu&quot;
+ *  tab-width: 8
+ *  indent-tabs-mode: nil
+ * End:
+ */

Added: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/mjpeg_logging.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/mjpeg_logging.h	2007-08-02 19:57:16 UTC (rev 3468)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/mjpeg_logging.h	2007-08-03 00:04:40 UTC (rev 3469)
@@ -0,0 +1,80 @@
+/*
+    $Id: mjpeg_logging.h,v 1.8 2004/09/01 02:55:30 sms00 Exp $
+
+    Copyright (C) 2000 Herbert Valerio Riedel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">hvr at gnu.org</A>&gt;
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
+
+#ifndef __MJPEG_LOGGING_H__
+#define __MJPEG_LOGGING_H__
+
+#include &lt;mjpeg_types.h&gt;
+
+typedef enum {
+  LOG_NONE = 0,
+  LOG_DEBUG,
+  LOG_INFO,
+  LOG_WARN,
+  LOG_ERROR
+} log_level_t;
+
+#ifdef __cplusplus
+extern &quot;C&quot; {
+#endif
+void
+mjpeg_log(log_level_t level, const char format[], ...) GNUC_PRINTF(2, 3);
+
+typedef int(*mjpeg_log_filter_t)(log_level_t level);
+    
+typedef void(*mjpeg_log_handler_t)(log_level_t level, const char message[]);
+
+mjpeg_log_handler_t
+mjpeg_log_set_handler(mjpeg_log_handler_t new_handler);
+
+int
+mjpeg_default_handler_identifier(const char *new_id);
+
+int
+mjpeg_default_handler_verbosity(int verbosity);
+
+void
+mjpeg_debug(const char format[], ...) GNUC_PRINTF(1,2);
+
+void
+mjpeg_info(const char format[], ...) GNUC_PRINTF(1,2);
+
+void
+mjpeg_warn(const char format[], ...) GNUC_PRINTF(1,2);
+
+void
+mjpeg_error(const char format[], ...) GNUC_PRINTF(1,2);
+
+void
+mjpeg_error_exit1(const char format[], ...) GNUC_PRINTF(1,2);
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* __MJPEG_LOGGING_H__ */
+
+
+/* 
+ * Local variables:
+ *  c-file-style: &quot;gnu&quot;
+ *  tab-width: 8
+ *  indent-tabs-mode: nil
+ * End:
+ */

Added: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/mjpeg_types.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/mjpeg_types.h	2007-08-02 19:57:16 UTC (rev 3468)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/mjpeg_types.h	2007-08-03 00:04:40 UTC (rev 3469)
@@ -0,0 +1,59 @@
+/*
+    $Id: mjpeg_types.h,v 1.14 2005/05/18 17:21:47 sms00 Exp $
+
+    Copyright (C) 2000 Herbert Valerio Riedel &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">hvr at gnu.org</A>&gt;
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
+
+#ifndef __MJPEG_TYPES_H__
+#define __MJPEG_TYPES_H__
+
+#include &lt;sys/types.h&gt; /* FreeBSD, others - ssize_t */
+
+/*
+ * modern CYGWIN releases have stdint/inttypes so there's no need
+ * to check for it or provide typedefs/defines
+*/
+
+#if defined(HAVE_STDINT_H)
+# include &lt;stdint.h&gt;
+#elif defined(HAVE_INTTYPES_H)
+# include &lt;inttypes.h&gt;
+#else
+typedef unsigned char uint8_t;
+typedef unsigned short uint16_t;
+typedef unsigned int uint32_t;
+typedef unsigned long long uint64_t;
+typedef long long int int64_t;
+#endif /* HAVE_STDINT_H */
+
+#if __GNUC__ &gt; 2 || (__GNUC__ == 2 &amp;&amp; __GNUC_MINOR__ &gt; 4)
+#define GNUC_PRINTF( format_idx, arg_idx )    \
+  __attribute__((format (printf, format_idx, arg_idx)))
+#else   /* !__GNUC__ */
+#define GNUC_PRINTF( format_idx, arg_idx )
+#endif  /* !__GNUC__ */
+
+#endif /* __MJPEG_TYPES_H__ */
+
+
+/* 
+ * Local variables:
+ *  c-file-style: &quot;gnu&quot;
+ *  tab-width: 8
+ *  indent-tabs-mode: nil
+ * End:
+ */

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/mpastrm_in.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/mpastrm_in.cpp	2007-08-02 19:57:16 UTC (rev 3468)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/mpastrm_in.cpp	2007-08-03 00:04:40 UTC (rev 3469)
@@ -27,7 +27,6 @@
 #include &quot;interact.hpp&quot;
 #include &quot;multiplexor.hpp&quot;
 
-#define mjpeg_info mjpeg_warn
 
 static const char *mpa_audio_version[4] =
 {
@@ -125,8 +124,6 @@
                 bs.StreamName()
                 );
 
-	InitAUbuffer();
-	
 	/* A.Stevens 2000 - update to be compatible up to  MPEG2.5
 	 */
     AU_start = bs.bitcount();
@@ -151,8 +148,8 @@
 			mpa_slots[layer] *1000 /
 			mpa_freq_table[version_id][frequency];
 
-		size_frames[0] = framesize;
-		size_frames[1] = framesize+( layer == 0 ? 4 : 1);
+		size_frames[0] = framesize * ( layer == 0 ? 4 : 1);
+		size_frames[1] = (framesize+1) * ( layer == 0 ? 4 : 1);
 		num_frames[padding_bit]++;
         access_unit.start  = AU_start;
 		access_unit.length = size_frames[padding_bit];
@@ -166,7 +163,7 @@
 		access_unit.DTS = access_unit.PTS;
 		access_unit.dorder = decoding_order;
 		++decoding_order;
-		aunits.append( access_unit );
+		aunits.Append( access_unit );
 
     } else
     {
@@ -186,9 +183,9 @@
 
 unsigned int MPAStream::SizeFrame( int rate_code, int padding )
 {
-	return mpa_bitrates_kbps[version_id][layer][rate_code]  * 
+	return ( mpa_bitrates_kbps[version_id][layer][rate_code]  * 
 		mpa_slots [layer] *1000 /
-		mpa_freq_table[version_id][frequency] + padding;
+		mpa_freq_table[version_id][frequency] + padding ) * ( layer == 0 ? 4 : 1);
 }
 
 void MPAStream::FillAUbuffer(unsigned int frames_to_buffer )
@@ -216,7 +213,7 @@
             mjpeg_warn(&quot;Discarding incomplete final frame MPEG audio stream %02x!&quot;,
                        stream_id
                        );
-            aunits.droplast();
+            aunits.DropLast();
             --decoding_order;
             break;
         }
@@ -248,7 +245,7 @@
 		access_unit.DTS = access_unit.PTS;
 		access_unit.dorder = decoding_order;
 		decoding_order++;
-		aunits.append( access_unit );
+		aunits.Append( access_unit );
 		num_frames[padding_bit]++;
 
 		bs.GetBits( 9);

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/mpegconsts.c
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/mpegconsts.c	2007-08-02 19:57:16 UTC (rev 3468)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/mpegconsts.c	2007-08-03 00:04:40 UTC (rev 3469)
@@ -41,21 +41,21 @@
 
 
 #define MPEG_NUM_RATES (sizeof(mpeg_framerates)/sizeof(mpeg_framerates[0]))
-static const mpeg_framerate_code_t MX_mpeg_num_framerates = MPEG_NUM_RATES;
+static const mpeg_framerate_code_t mpeg_num_framerates = MPEG_NUM_RATES;
 
-static const char *
-framerate_definitions[MPEG_NUM_RATES] =
-{
-   &quot;illegal&quot;, 
-  &quot;24000.0/1001.0 (NTSC 3:2 pulldown converted FILM)&quot;,
-  &quot;24.0 (NATIVE FILM)&quot;,
-  &quot;25.0 (PAL/SECAM VIDEO / converted FILM)&quot;,
-  &quot;30000.0/1001.0 (NTSC VIDEO)&quot;,
-  &quot;30.0&quot;,
-  &quot;50.0 (PAL FIELD RATE)&quot;,
-  &quot;60000.0/1001.0 (NTSC FIELD RATE)&quot;,
-  &quot;60.0&quot;
-};
+//static const char *
+//framerate_definitions[MPEG_NUM_RATES] =
+//{
+//   &quot;illegal&quot;, 
+//  &quot;24000.0/1001.0 (NTSC 3:2 pulldown converted FILM)&quot;,
+//  &quot;24.0 (NATIVE FILM)&quot;,
+//  &quot;25.0 (PAL/SECAM VIDEO / converted FILM)&quot;,
+//  &quot;30000.0/1001.0 (NTSC VIDEO)&quot;,
+//  &quot;30.0&quot;,
+//  &quot;50.0 (PAL FIELD RATE)&quot;,
+//  &quot;60000.0/1001.0 (NTSC FIELD RATE)&quot;,
+//  &quot;60.0&quot;
+//};
 
 
 static const char *mpeg1_aspect_ratio_definitions[] =
@@ -121,13 +121,13 @@
 	mpeg2_aspect_ratio_definitions
 };
 
-static const y4m_ratio_t *mpeg_aspect_ratios[2] = 
-{
-	mpeg1_aspect_ratios,
-	mpeg2_aspect_ratios
-};
+//static const y4m_ratio_t *mpeg_aspect_ratios[2] = 
+//{
+//	mpeg1_aspect_ratios,
+//	mpeg2_aspect_ratios
+//};
 
-static const mpeg_aspect_code_t MX_mpeg_num_aspect_ratios[2] = 
+static const mpeg_aspect_code_t mpeg_num_aspect_ratios[2] = 
 {
   sizeof(mpeg1_aspect_ratios)/sizeof(mpeg1_aspect_ratios[0]),
   sizeof(mpeg2_aspect_ratios)/sizeof(mpeg2_aspect_ratios[0])
@@ -139,9 +139,9 @@
  */
 
 int
-mpeg_valid_framerate_code( mpeg_framerate_code_t code )
+MX_mpeg_valid_framerate_code( mpeg_framerate_code_t code )
 {
-    return ((code &gt; 0) &amp;&amp; (code &lt; MX_mpeg_num_framerates)) ? 1 : 0;
+    return ((code &gt; 0) &amp;&amp; (code &lt; mpeg_num_framerates)) ? 1 : 0;
 }
 
 
@@ -149,40 +149,61 @@
  * Convert MPEG frame-rate code to corresponding frame-rate
  */
 
-// y4m_ratio_t
-// mpeg_framerate( mpeg_framerate_code_t code )
-// {
-//     if ((code &gt; 0) &amp;&amp; (code &lt; mpeg_num_framerates))
-// 		return mpeg_framerates[code];
-//     else
-// 		return y4m_fps_UNKNOWN;
-// }
+y4m_ratio_t
+MX_mpeg_framerate( mpeg_framerate_code_t code )
+{
+    if ((code &gt; 0) &amp;&amp; (code &lt; mpeg_num_framerates))
+		return mpeg_framerates[code];
+    else
+		return y4m_fps_UNKNOWN;
+}
 
-/*
- * Look-up MPEG frame rate code for a (exact) frame rate.
- */
+///*
+// * Look-up MPEG frame rate code for a (exact) frame rate.
+// */
+//
+//
+//mpeg_framerate_code_t 
+//mpeg_framerate_code( y4m_ratio_t framerate )
+//{
+//	mpeg_framerate_code_t i;
+//  
+//	y4m_ratio_reduce(&amp;framerate);
+//    /* start at '1', because 0 is unknown/illegal */
+//	for (i = 1; i &lt; mpeg_num_framerates; ++i) {
+//		if (Y4M_RATIO_EQL(framerate, mpeg_framerates[i]))
+//			return i;
+//	}
+//	return 0;
+//}
+//
+//
+///* small enough to distinguish 1/1000 from 1/1001 */
+//#define MPEG_FPS_TOLERANCE 0.0001
+//
+//
+//y4m_ratio_t
+//mpeg_conform_framerate( double fps )
+//{
+//	mpeg_framerate_code_t i;
+//	y4m_ratio_t result;
+//
+//	/* try to match it to a standard frame rate */
+//    /* (start at '1', because 0 is unknown/illegal) */
+//	for (i = 1; i &lt; mpeg_num_framerates; i++) 
+//	{
+//		double deviation = 1.0 - (Y4M_RATIO_DBL(mpeg_framerates[i]) / fps);
+//		if ( (deviation &gt; -MPEG_FPS_TOLERANCE) &amp;&amp;
+//			 (deviation &lt; +MPEG_FPS_TOLERANCE) )
+//			return mpeg_framerates[i];
+//	}
+//	/* no luck?  just turn it into a ratio (6 decimal place accuracy) */
+//	result.n = (int)((fps * 1000000.0) + 0.5);
+//	result.d = 1000000;
+//	y4m_ratio_reduce(&amp;result);
+//	return result;
+//}
 
-
-// mpeg_framerate_code_t 
-// mpeg_framerate_code( y4m_ratio_t framerate )
-// {
-// 	mpeg_framerate_code_t i;
-//   
-// 	y4m_ratio_reduce(&amp;framerate);
-//     /* start at '1', because 0 is unknown/illegal */
-// 	for (i = 1; i &lt; mpeg_num_framerates; ++i) {
-// 		if (Y4M_RATIO_EQL(framerate, mpeg_framerates[i]))
-// 			return i;
-// 	}
-// 	return 0;
-// }
-
-
-/* small enough to distinguish 1/1000 from 1/1001 */
-#define MPEG_FPS_TOLERANCE 0.0001
-
-
-
   
 
 /*
@@ -190,270 +211,270 @@
  */
 
 int
-mpeg_valid_aspect_code( int version, mpeg_framerate_code_t c )
+MX_mpeg_valid_aspect_code( int version, mpeg_framerate_code_t c )
 {
 	if ((version == 1) || (version == 2))
-        return ((c &gt; 0) &amp;&amp; (c &lt; MX_mpeg_num_aspect_ratios[version-1])) ? 1 : 0;
+        return ((c &gt; 0) &amp;&amp; (c &lt; mpeg_num_aspect_ratios[version-1])) ? 1 : 0;
     else
         return 0;
 }
 
 
-/*
- * Convert MPEG aspect-ratio code to corresponding aspect-ratio
- */
+///*
+// * Convert MPEG aspect-ratio code to corresponding aspect-ratio
+// */
+//
+//y4m_ratio_t 
+//mpeg_aspect_ratio( int mpeg_version,  mpeg_aspect_code_t code )
+//{
+//	y4m_ratio_t ratio;
+//    if ((mpeg_version &gt;= 1) &amp;&amp; (mpeg_version &lt;= 2) &amp;&amp;
+//        (code &gt; 0) &amp;&amp; (code &lt; mpeg_num_aspect_ratios[mpeg_version-1]))
+//	{
+//		ratio = mpeg_aspect_ratios[mpeg_version-1][code];
+//		y4m_ratio_reduce(&amp;ratio);
+//		return ratio;
+//	}
+//    else
+//		return y4m_sar_UNKNOWN;
+//}
+//
+//
+//
+///*
+// * Look-up corresponding MPEG aspect ratio code given an exact aspect ratio.
+// *
+// * WARNING: The semantics of aspect ratio coding *changed* between
+// * MPEG1 and MPEG2.  In MPEG1 it is the *pixel* aspect ratio. In
+// * MPEG2 it is the (far more sensible) aspect ratio of the eventual
+// * display.
+// *
+// */
+//
+//mpeg_aspect_code_t 
+//mpeg_frame_aspect_code( int mpeg_version, y4m_ratio_t aspect_ratio )
+//{
+//	mpeg_aspect_code_t i;
+//	y4m_ratio_t red_ratio = aspect_ratio;
+//	y4m_ratio_reduce( &amp;red_ratio );
+//	if( mpeg_version &lt; 1 || mpeg_version &gt; 2 )
+//		return 0;
+//    /* (start at '1', because 0 is unknown/illegal) */
+//	for( i = 1; i &lt; mpeg_num_aspect_ratios[mpeg_version-1]; ++i )
+//	{
+//		y4m_ratio_t red_entry =  mpeg_aspect_ratios[mpeg_version-1][i];
+//		y4m_ratio_reduce( &amp;red_entry );
+//		if(  Y4M_RATIO_EQL( red_entry, red_ratio) )
+//			return i;
+//	}
+//
+//	return 0;
+//			
+//}
+//
+//
+//
+///*
+// * Guess the correct MPEG aspect ratio code,
+// *  given the true sample aspect ratio and frame size of a video stream
+// *  (and the MPEG version, 1 or 2).
+// *
+// * Returns 0 if it has no good guess.
+// *
+// */
+//
+//
+///* this is big enough to accommodate the difference between 720 and 704 */
+//#define GUESS_ASPECT_TOLERANCE 0.03
+//
+//mpeg_aspect_code_t 
+//mpeg_guess_mpeg_aspect_code(int mpeg_version, y4m_ratio_t sampleaspect,
+//							int frame_width, int frame_height)
+//{
+//	if (Y4M_RATIO_EQL(sampleaspect, y4m_sar_UNKNOWN))
+//    {
+//		return 0;
+//    }
+//	switch (mpeg_version) {
+//	case 1:
+//		if (Y4M_RATIO_EQL(sampleaspect, y4m_sar_SQUARE))
+//		{
+//			return 1;
+//		} 
+//		else if (Y4M_RATIO_EQL(sampleaspect, y4m_sar_NTSC_CCIR601))
+//		{
+//			return 12;
+//		} 
+//		else if (Y4M_RATIO_EQL(sampleaspect, y4m_sar_NTSC_16_9))
+//		{
+//			return 6;
+//		} 
+//		else if (Y4M_RATIO_EQL(sampleaspect, y4m_sar_PAL_CCIR601))
+//		{
+//			return 8;
+//		} 
+//		else if (Y4M_RATIO_EQL(sampleaspect, y4m_sar_PAL_16_9))
+//		{
+//			return 3;
+//		} 
+//		return 0;
+//		break;
+//	case 2:
+//		if (Y4M_RATIO_EQL(sampleaspect, y4m_sar_SQUARE))
+//		{
+//			return 1;  /* '1' means square *pixels* in MPEG-2; go figure. */
+//		}
+//		else
+//		{
+//			int i;
+//			double true_far;  /* true frame aspect ratio */
+//			true_far = 
+//				(double)(sampleaspect.n * frame_width) /
+//				(double)(sampleaspect.d * frame_height);
+//			/* start at '2'... */
+//			for (i = 2; i &lt; (int)(mpeg_num_aspect_ratios[mpeg_version-1]); i++) 
+//			{
+//				double ratio = 
+//					true_far / Y4M_RATIO_DBL(mpeg_aspect_ratios[mpeg_version-1][i]);
+//				if ( (ratio &gt; (1.0 - GUESS_ASPECT_TOLERANCE)) &amp;&amp;
+//					 (ratio &lt; (1.0 + GUESS_ASPECT_TOLERANCE)) )
+//					return i;
+//			}
+//			return 0;
+//		}
+//		break;
+//	default:
+//		return 0;
+//		break;
+//	}
+//}
+//
+//
+//
+//
+///*
+// * Guess the true sample aspect ratio of a video stream,
+// *  given the MPEG aspect ratio code and the actual frame size
+// *  (and the MPEG version, 1 or 2).
+// *
+// * Returns y4m_sar_UNKNOWN if it has no good guess.
+// *
+// */
+//y4m_ratio_t 
+//mpeg_guess_sample_aspect_ratio(int mpeg_version,
+//							   mpeg_aspect_code_t code,
+//							   int frame_width, int frame_height)
+//{
+//	switch (mpeg_version) 
+//	{
+//	case 1:
+//		/* MPEG-1 codes turn into SAR's, just not quite the right ones.
+//		   For the common/known values, we provide the ratio used in practice,
+//		   otherwise say we don't know.*/
+//		switch (code)
+//		{
+//		case 1:  return y4m_sar_SQUARE;        break;
+//		case 3:  return y4m_sar_PAL_16_9;      break;
+//		case 6:  return y4m_sar_NTSC_16_9;     break;
+//		case 8:  return y4m_sar_PAL_CCIR601;   break;
+//		case 12: return y4m_sar_NTSC_CCIR601;  break;
+//		default:
+//			return y4m_sar_UNKNOWN;       break;
+//		}
+//		break;
+//	case 2:
+//		/* MPEG-2 codes turn into Display Aspect Ratios, though not exactly the
+//		   DAR's used in practice.  For common/standard frame sizes, we provide
+//		   the original SAR; otherwise, we say we don't know. */
+//		if (code == 1) 
+//		{
+//			return y4m_sar_SQUARE; /* '1' means square *pixels* in MPEG-2 */
+//		}
+//		else if ((code &gt;= 2) &amp;&amp; (code &lt;= 4))
+//		{
+//            return y4m_guess_sar(frame_width, frame_height,
+//                                 mpeg2_aspect_ratios[code]);
+//		} 
+//		else
+//		{
+//			return y4m_sar_UNKNOWN;
+//		}
+//		break;
+//	default:
+//		return y4m_sar_UNKNOWN;
+//		break;
+//	}
+//}
+//
+//
+//
+//
+//
+///*
+// * Look-up MPEG explanatory definition string for frame rate code
+// *
+// */
+//
+//
+//const char *
+//mpeg_framerate_code_definition(   mpeg_framerate_code_t code  )
+//{
+//	if( code == 0 || code &gt;=  mpeg_num_framerates )
+//		return &quot;UNDEFINED: illegal/reserved frame-rate ratio code&quot;;
+//
+//	return framerate_definitions[code];
+//}
 
-// y4m_ratio_t 
-// mpeg_aspect_ratio( int mpeg_version,  mpeg_aspect_code_t code )
-// {
-// 	y4m_ratio_t ratio;
-//     if ((mpeg_version &gt;= 1) &amp;&amp; (mpeg_version &lt;= 2) &amp;&amp;
-//         (code &gt; 0) &amp;&amp; (code &lt; mpeg_num_aspect_ratios[mpeg_version-1]))
-// 	{
-// 		ratio = mpeg_aspect_ratios[mpeg_version-1][code];
-// 		y4m_ratio_reduce(&amp;ratio);
-// 		return ratio;
-// 	}
-//     else
-// 		return y4m_sar_UNKNOWN;
-// }
-// 
-// 
-
 /*
- * Look-up corresponding MPEG aspect ratio code given an exact aspect ratio.
+ * Look-up MPEG explanatory definition string aspect ratio code for an
+ * aspect ratio code
  *
- * WARNING: The semantics of aspect ratio coding *changed* between
- * MPEG1 and MPEG2.  In MPEG1 it is the *pixel* aspect ratio. In
- * MPEG2 it is the (far more sensible) aspect ratio of the eventual
- * display.
- *
  */
-// 
-// mpeg_aspect_code_t 
-// mpeg_frame_aspect_code( int mpeg_version, y4m_ratio_t aspect_ratio )
-// {
-// 	mpeg_aspect_code_t i;
-// 	y4m_ratio_t red_ratio = aspect_ratio;
-// 	y4m_ratio_reduce( &amp;red_ratio );
-// 	if( mpeg_version &lt; 1 || mpeg_version &gt; 2 )
-// 		return 0;
-//     /* (start at '1', because 0 is unknown/illegal) */
-// 	for( i = 1; i &lt; mpeg_num_aspect_ratios[mpeg_version-1]; ++i )
-// 	{
-// 		y4m_ratio_t red_entry =  mpeg_aspect_ratios[mpeg_version-1][i];
-// 		y4m_ratio_reduce( &amp;red_entry );
-// 		if(  Y4M_RATIO_EQL( red_entry, red_ratio) )
-// 			return i;
-// 	}
-// 
-// 	return 0;
-// 			
-// }
 
+const char *
+MX_mpeg_aspect_code_definition( int mpeg_version,  mpeg_aspect_code_t code  )
+{
+	if( mpeg_version &lt; 1 || mpeg_version &gt; 2 )
+		return &quot;UNDEFINED: illegal MPEG version&quot;;
+	
+	if( code &lt; 1 || code &gt;=  mpeg_num_aspect_ratios[mpeg_version-1] )
+		return &quot;UNDEFINED: illegal aspect ratio code&quot;;
 
+	return aspect_ratio_definitions[mpeg_version-1][code];
+}
 
-/*
- * Guess the correct MPEG aspect ratio code,
- *  given the true sample aspect ratio and frame size of a video stream
- *  (and the MPEG version, 1 or 2).
- *
- * Returns 0 if it has no good guess.
- *
- */
 
+///*
+// * Look-up explanatory definition of interlace field order code
+// *
+// */
+//
+//const char *
+//mpeg_interlace_code_definition( int yuv4m_interlace_code )
+//{
+//	const char *def;
+//	switch( yuv4m_interlace_code )
+//	{
+//	case Y4M_UNKNOWN :
+//		def = &quot;unknown&quot;;
+//		break;
+//	case Y4M_ILACE_NONE :
+//		def = &quot;none/progressive&quot;;
+//		break;
+//	case Y4M_ILACE_TOP_FIRST :
+//		def = &quot;top-field-first&quot;;
+//		break;
+//	case Y4M_ILACE_BOTTOM_FIRST :
+//		def = &quot;bottom-field-first&quot;;
+//		break;
+//	default :
+//		def = &quot;UNDEFINED: illegal video interlacing type-code!&quot;;
+//		break;
+//	}
+//	return def;
+//}
 
-/* this is big enough to accommodate the difference between 720 and 704 */
-#define GUESS_ASPECT_TOLERANCE 0.03
-
-// mpeg_aspect_code_t 
-// mpeg_guess_mpeg_aspect_code(int mpeg_version, y4m_ratio_t sampleaspect,
-// 							int frame_width, int frame_height)
-// {
-// 	if (Y4M_RATIO_EQL(sampleaspect, y4m_sar_UNKNOWN))
-//     {
-// 		return 0;
-//     }
-// 	switch (mpeg_version) {
-// 	case 1:
-// 		if (Y4M_RATIO_EQL(sampleaspect, y4m_sar_SQUARE))
-// 		{
-// 			return 1;
-// 		} 
-// 		else if (Y4M_RATIO_EQL(sampleaspect, y4m_sar_NTSC_CCIR601))
-// 		{
-// 			return 12;
-// 		} 
-// 		else if (Y4M_RATIO_EQL(sampleaspect, y4m_sar_NTSC_16_9))
-// 		{
-// 			return 6;
-// 		} 
-// 		else if (Y4M_RATIO_EQL(sampleaspect, y4m_sar_PAL_CCIR601))
-// 		{
-// 			return 8;
-// 		} 
-// 		else if (Y4M_RATIO_EQL(sampleaspect, y4m_sar_PAL_16_9))
-// 		{
-// 			return 3;
-// 		} 
-// 		return 0;
-// 		break;
-// 	case 2:
-// 		if (Y4M_RATIO_EQL(sampleaspect, y4m_sar_SQUARE))
-// 		{
-// 			return 1;  /* '1' means square *pixels* in MPEG-2; go figure. */
-// 		}
-// 		else
-// 		{
-// 			int i;
-// 			double true_far;  /* true frame aspect ratio */
-// 			true_far = 
-// 				(double)(sampleaspect.n * frame_width) /
-// 				(double)(sampleaspect.d * frame_height);
-// 			/* start at '2'... */
-// 			for (i = 2; i &lt; (int)(mpeg_num_aspect_ratios[mpeg_version-1]); i++) 
-// 			{
-// 				double ratio = 
-// 					true_far / Y4M_RATIO_DBL(mpeg_aspect_ratios[mpeg_version-1][i]);
-// 				if ( (ratio &gt; (1.0 - GUESS_ASPECT_TOLERANCE)) &amp;&amp;
-// 					 (ratio &lt; (1.0 + GUESS_ASPECT_TOLERANCE)) )
-// 					return i;
-// 			}
-// 			return 0;
-// 		}
-// 		break;
-// 	default:
-// 		return 0;
-// 		break;
-// 	}
-// }
-// 
-// 
-// 
-// 
-// /*
-//  * Guess the true sample aspect ratio of a video stream,
-//  *  given the MPEG aspect ratio code and the actual frame size
-//  *  (and the MPEG version, 1 or 2).
-//  *
-//  * Returns y4m_sar_UNKNOWN if it has no good guess.
-//  *
-//  */
-// y4m_ratio_t 
-// mpeg_guess_sample_aspect_ratio(int mpeg_version,
-// 							   mpeg_aspect_code_t code,
-// 							   int frame_width, int frame_height)
-// {
-// 	switch (mpeg_version) 
-// 	{
-// 	case 1:
-// 		/* MPEG-1 codes turn into SAR's, just not quite the right ones.
-// 		   For the common/known values, we provide the ratio used in practice,
-// 		   otherwise say we don't know.*/
-// 		switch (code)
-// 		{
-// 		case 1:  return y4m_sar_SQUARE;        break;
-// 		case 3:  return y4m_sar_PAL_16_9;      break;
-// 		case 6:  return y4m_sar_NTSC_16_9;     break;
-// 		case 8:  return y4m_sar_PAL_CCIR601;   break;
-// 		case 12: return y4m_sar_NTSC_CCIR601;  break;
-// 		default:
-// 			return y4m_sar_UNKNOWN;       break;
-// 		}
-// 		break;
-// 	case 2:
-// 		/* MPEG-2 codes turn into Display Aspect Ratios, though not exactly the
-// 		   DAR's used in practice.  For common/standard frame sizes, we provide
-// 		   the original SAR; otherwise, we say we don't know. */
-// 		if (code == 1) 
-// 		{
-// 			return y4m_sar_SQUARE; /* '1' means square *pixels* in MPEG-2 */
-// 		}
-// 		else if ((code &gt;= 2) &amp;&amp; (code &lt;= 4))
-// 		{
-//             return y4m_guess_sar(frame_width, frame_height,
-//                                  mpeg2_aspect_ratios[code]);
-// 		} 
-// 		else
-// 		{
-// 			return y4m_sar_UNKNOWN;
-// 		}
-// 		break;
-// 	default:
-// 		return y4m_sar_UNKNOWN;
-// 		break;
-// 	}
-// }
-// 
-// 
-// 
-// 
-// 
-// /*
-//  * Look-up MPEG explanatory definition string for frame rate code
-//  *
-//  */
-// 
-// 
-// const char *
-// mpeg_framerate_code_definition(   mpeg_framerate_code_t code  )
-// {
-// 	if( code == 0 || code &gt;=  mpeg_num_framerates )
-// 		return &quot;UNDEFINED: illegal/reserved frame-rate ratio code&quot;;
-// 
-// 	return framerate_definitions[code];
-// }
-// 
-// /*
-//  * Look-up MPEG explanatory definition string aspect ratio code for an
-//  * aspect ratio code
-//  *
-//  */
-// 
-// const char *
-// mpeg_aspect_code_definition( int mpeg_version,  mpeg_aspect_code_t code  )
-// {
-// 	if( mpeg_version &lt; 1 || mpeg_version &gt; 2 )
-// 		return &quot;UNDEFINED: illegal MPEG version&quot;;
-// 	
-// 	if( code &lt; 1 || code &gt;=  mpeg_num_aspect_ratios[mpeg_version-1] )
-// 		return &quot;UNDEFINED: illegal aspect ratio code&quot;;
-// 
-// 	return aspect_ratio_definitions[mpeg_version-1][code];
-// }
-// 
-// 
-// /*
-//  * Look-up explanatory definition of interlace field order code
-//  *
-//  */
-// 
-// const char *
-// mpeg_interlace_code_definition( int yuv4m_interlace_code )
-// {
-// 	const char *def;
-// 	switch( yuv4m_interlace_code )
-// 	{
-// 	case Y4M_UNKNOWN :
-// 		def = &quot;unknown&quot;;
-// 		break;
-// 	case Y4M_ILACE_NONE :
-// 		def = &quot;none/progressive&quot;;
-// 		break;
-// 	case Y4M_ILACE_TOP_FIRST :
-// 		def = &quot;top-field-first&quot;;
-// 		break;
-// 	case Y4M_ILACE_BOTTOM_FIRST :
-// 		def = &quot;bottom-field-first&quot;;
-// 		break;
-// 	default :
-// 		def = &quot;UNDEFINED: illegal video interlacing type-code!&quot;;
-// 		break;
-// 	}
-// 	return def;
-// }
-// 
-// 
+
 /* 
  * Local variables:
  *  c-file-style: &quot;stroustrup&quot;

Added: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/mpegconsts.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/mpegconsts.h	2007-08-02 19:57:16 UTC (rev 3468)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/mpegconsts.h	2007-08-03 00:04:40 UTC (rev 3469)
@@ -0,0 +1,165 @@
+
+/*
+ *  mpegconsts.c:  Video format constants for MPEG and utilities for display
+ *                 and conversion to format used for yuv4mpeg
+ *
+ *  Copyright (C) 2001 Andrew Stevens &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">andrew.stevens at philips.com</A>&gt;
+ *
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of version 2 of the GNU General Public License
+ *  as published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+#ifndef __MPEGCONSTS_H__
+#define __MPEGCONSTS_H__
+
+#include &lt;yuv4mpeg.h&gt;
+
+typedef unsigned int mpeg_framerate_code_t;
+typedef unsigned int mpeg_aspect_code_t;
+
+#ifdef __cplusplus
+#define START_CPP_WRAP extern &quot;C&quot; {
+#define END_CPP_WRAP };
+#else
+#define START_CPP_WRAP
+#define END_CPP_WRAP
+#endif
+
+START_CPP_WRAP
+
+
+/*
+ * Convert MPEG frame-rate code to corresponding frame-rate
+ *  y4m_fps_UNKNOWN = { 0, 0 } = Undefined/resrerved code.
+ */
+
+y4m_ratio_t
+MX_mpeg_framerate( mpeg_framerate_code_t code );
+
+
+/*
+ * Is code a valid MPEG frame-rate code?
+ * Return 1 if true; 0 otherwise.
+ */
+
+int
+MX_mpeg_valid_framerate_code( mpeg_framerate_code_t code );
+
+
+///*
+// * Look-up MPEG frame rate code for a (exact) frame rate.
+// *  0 = No MPEG code defined for frame-rate
+// */
+//
+//mpeg_framerate_code_t 
+//mpeg_framerate_code( y4m_ratio_t framerate );
+//
+//
+///*
+// * Convert floating-point framerate to an exact ratio.
+// *  Uses a standard MPEG rate, if it finds one within MPEG_FPS_TOLERANCE
+// *  (see mpegconsts.c), otherwise uses &quot;fps:1000000&quot; as the ratio.
+// */
+//
+//y4m_ratio_t
+//mpeg_conform_framerate( double fps );
+//
+//
+///*
+// * Convert MPEG aspect ratio code to corresponding aspect ratio
+// *
+// * WARNING: The semantics of aspect ratio coding *changed* between
+// * MPEG1 and MPEG2.  In MPEG1 it is the *pixel* aspect ratio. In
+// * MPEG2 it is the (far more sensible) aspect ratio of the eventual
+// * display.
+// *
+// */
+//
+//y4m_ratio_t
+//mpeg_aspect_ratio( int mpeg_version,  mpeg_aspect_code_t code );
+
+
+/*
+ * Is code a valid MPEG(1,2) aspect-ratio code?
+ * Return 1 if true; 0 otherwise.
+ */
+
+int
+MX_mpeg_valid_aspect_code( int mpeg_version, mpeg_aspect_code_t code );
+
+
+///*
+// * Look-up MPEG aspect ratio code for an aspect ratio - tolerance
+// * is Y4M_ASPECT_MULT used by YUV4MPEG (see yuv4mpeg_intern.h)
+// *
+// * WARNING: The semantics of aspect ratio coding *changed* between
+// * MPEG1 and MPEG2.  In MPEG1 it is the *pixel* aspect ratio. In
+// * MPEG2 it is the (far more sensible) aspect ratio of the eventual
+// * display.
+// *
+// */
+//
+//mpeg_aspect_code_t 
+//mpeg_frame_aspect_code( int mpeg_version, y4m_ratio_t aspect_ratio );
+
+/*
+ * Look-up MPEG explanatory definition string aspect ratio code for an
+ * aspect ratio code
+ *
+ */
+
+const char *
+MX_mpeg_aspect_code_definition( int mpeg_version,  mpeg_aspect_code_t code  );
+
+///*
+// * Look-up MPEG explanatory definition string aspect ratio code for an
+// * frame rate code
+// *
+// */
+//
+//const char *
+//mpeg_framerate_code_definition( mpeg_framerate_code_t code  );
+//
+//const char *
+//mpeg_interlace_code_definition( int yuv4m_interlace_code );
+//
+//
+///*
+// * Guess the correct MPEG aspect ratio code,
+// *  given the true sample aspect ratio and frame size of a video stream
+// *  (and the MPEG version, 1 or 2).
+// *
+// * Returns 0 if it has no good answer.
+// *
+// */
+//mpeg_aspect_code_t 
+//mpeg_guess_mpeg_aspect_code(int mpeg_version, y4m_ratio_t sampleaspect,
+//			    int frame_width, int frame_height);
+//
+///*
+// * Guess the true sample aspect ratio of a video stream,
+// *  given the MPEG aspect ratio code and the actual frame size
+// *  (and the MPEG version, 1 or 2).
+// *
+// * Returns y4m_sar_UNKNOWN if it has no good answer.
+// *
+// */
+//y4m_ratio_t 
+//mpeg_guess_sample_aspect_ratio(int mpeg_version,
+//			       mpeg_aspect_code_t code,
+//			       int frame_width, int frame_height);
+
+END_CPP_WRAP
+
+#endif /* __MPEGCONSTS_H__ */

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/multiplexor.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/multiplexor.cpp	2007-08-02 19:57:16 UTC (rev 3468)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/multiplexor.cpp	2007-08-03 00:04:40 UTC (rev 3469)
@@ -18,7 +18,7 @@
  *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
  */
 
-
+#define STREAM_LOGGING
 #include &lt;config.h&gt;
 #include &lt;math.h&gt;
 #include &lt;stdlib.h&gt;
@@ -36,9 +36,6 @@
 #endif
 #include &quot;multiplexor.hpp&quot;
 
-#define MAX_UNDERRUN 10
-//#define mjpeg_info mjpeg_warn
-//#define STREAM_LOGGING 1
 
 /****************
  *
@@ -50,9 +47,6 @@
 
 Multiplexor::Multiplexor(MultiplexJob &amp;job, OutputStream &amp;output)
 {
-
-        
-
     underrun_ignore = 0;
     underruns = 0;
 	start_of_new_pack = false;
@@ -63,15 +57,7 @@
 
 }
 
-void Multiplexor::Close(void)
-{
-	std::vector&lt;ElementaryStream *&gt;::iterator str;
 
-	for( str = estreams.begin(); str &lt; estreams.end(); ++str )
-		delete (*str);
-}
-
-
 /******************************************************************
  *
  * Initialisation of stream syntax paramters based on selected user
@@ -105,10 +91,9 @@
 	{
 	case MPEG_FORMAT_VCD :
 		data_rate = 75*2352;  			 /* 75 raw CD sectors/sec */ 
-	  	vbr = false;
- 
 	case MPEG_FORMAT_VCD_NSR : /* VCD format, non-standard rate */
 		mjpeg_info( &quot;Selecting VCD output profile&quot;);
+		video_buffers_iframe_only = false;
 		mpeg = 1;
 	 	packets_per_pack = 1;
 	  	sys_header_in_pack1 = 0;
@@ -127,6 +112,11 @@
 		sector_align_iframeAUs = false;
         timestamp_iframe_only = false;
 		seg_starts_with_video = true;
+        if( job.video_tracks == 0 )
+        {
+            mjpeg_info( &quot;Audio-only VCD track - variable-bit-rate (VCD2.0)&quot;);
+            vbr = true;
+        }
 		break;
 		
 	case  MPEG_FORMAT_MPEG2 : 
@@ -143,9 +133,10 @@
 		buffers_in_audio = 1;
 		always_buffers_in_audio = 1;
 		vcd_zero_stuffing = 0;
-        dtspts_for_all_vau = 0;
-        timestamp_iframe_only = false;
-        video_buffers_iframe_only = false;
+		vbr = true;
+        	dtspts_for_all_vau = 0;
+        	timestamp_iframe_only = false;
+        	video_buffers_iframe_only = false;
 		break;
 
 	case MPEG_FORMAT_SVCD :
@@ -281,7 +272,6 @@
         video_buffers_iframe_only = false;
 		break;
 	}
-	
 }
 
 /**************************************
@@ -387,10 +377,6 @@
 	std::vector&lt;VideoParams *&gt;::iterator vidparm = job.video_param.begin();
 	std::vector&lt;LpcmParams *&gt;::iterator lpcmparm = job.lpcm_param.begin();
 
-    if( job.video_tracks &lt; 1 &amp;&amp; job.mux_format == MPEG_FORMAT_VCD )
-    {
-        mjpeg_warn( &quot;Multiplexing audio-only for a standard VCD is very inefficient&quot;);
-    }
 
     std::vector&lt;JobStream *&gt;::iterator i;
     for( i = job.streams.begin() ; i &lt; job.streams.end() ; ++i )
@@ -760,7 +746,7 @@
 			mjpeg_log( level,
 					   &quot;Video %02x: buf=%7d frame=%06d sector=%08d&quot;,
 					   (*str)-&gt;stream_id,
-					   (*str)-&gt;bufmodel.Space(),
+					   (*str)-&gt;BufferSize()-(*str)-&gt;bufmodel.Space(),
 					   (*str)-&gt;DecodeOrder(),
 					   (*str)-&gt;nsec
 				);
@@ -769,7 +755,7 @@
 			mjpeg_log( level,
 					   &quot;Audio %02x: buf=%7d frame=%06d sector=%08d&quot;,
 					   (*str)-&gt;stream_id,
-					   (*str)-&gt;bufmodel.Space(),
+					   (*str)-&gt;BufferSize()-(*str)-&gt;bufmodel.Space(),
 					   (*str)-&gt;DecodeOrder(),
 					   (*str)-&gt;nsec
 				);
@@ -839,6 +825,9 @@
 		{
 				mjpeg_error_exit1(&quot;VCD man only have max. 1 audio and 1 video stream&quot;);
 		}
+
+        if( vstreams.size() &gt; 0 )
+        {
 		/* First packet carries video-info-only sys_header */
 		psstrm-&gt;CreateSysHeader (&amp;sys_header, mux_rate, 
 								 false, true, 
@@ -846,15 +835,20 @@
 		sys_header_ptr = &amp;sys_header;
 		pack_header_ptr = &amp;pack_header;
 	  	OutputPadding( false);		
+        }
 
-		/* Second packet carries audio-info-only sys_header */
-		psstrm-&gt;CreateSysHeader (&amp;sys_header, mux_rate,  
-                                 false, true, 
-								 true, true, amux );
-		sys_header_ptr = &amp;sys_header;
-		pack_header_ptr = &amp;pack_header;
-	  	OutputPadding( true );
-		break;
+        if( astreams.size() &gt; 0 )
+        {
+
+            /* Second packet carries audio-info-only sys_header */
+            psstrm-&gt;CreateSysHeader (&amp;sys_header, mux_rate,  
+                                     false, true, 
+                                     true, true, amux );
+            sys_header_ptr = &amp;sys_header;
+            pack_header_ptr = &amp;pack_header;
+            OutputPadding( true );
+        }
+        break;
 		
 	case MPEG_FORMAT_SVCD :
 	case MPEG_FORMAT_SVCD_NSR :
@@ -1134,25 +1128,25 @@
                 mjpeg_info( &quot;Starting new output file...&quot;);
                 psstrm-&gt;NextSegment();
 			}
-			else if( master != 0 &amp;&amp; master-&gt;EndSeq() )
+			else if( master != 0 &amp;&amp; master-&gt;SeqEndRunOut() )
 			{
-				if(  split_at_seq_end &amp;&amp; master-&gt;Lookahead( ) != 0 )
+                const AUnit *nextIframe = master-&gt;NextIFrame();
+				if(  split_at_seq_end &amp;&amp; nextIframe != 0)
 				{
-					if( ! master-&gt;SeqHdrNext() || 
-						master-&gt;NextAUType() != IFRAME)
-					{
-						mjpeg_error_exit1( &quot;Sequence split detected %d but no following sequence found...&quot;, master-&gt;NextAUType());
-					}
-						
-					runout_PTS = master-&gt;NextRequiredPTS();
-                    mjpeg_info( &quot;Running out...&quot;);
-                    mjpeg_debug(&quot;Run out PTS limit to %lld SCR=%lld&quot;, 
-                                runout_PTS/300, 
-                                current_SCR/300 );
+					runout_PTS = master-&gt;RequiredPTS(nextIframe);
+                    mjpeg_info( &quot;Sequence end marker! Running out...&quot;);
+                    mjpeg_info(&quot;Run out PTS limit to AU %d %lld SCR=%lld&quot;, 
+                               nextIframe-&gt;dorder,
+                               runout_PTS/300, 
+                               current_SCR/300 );
                     MuxStatus( LOG_INFO );
 					running_out = true;
 					seg_state = runout_segment;
 				}
+                else
+                {
+                    mjpeg_warn( &quot;Sequence end without following I-frame!&quot; );
+                }
 			}
 			break;
 			
@@ -1176,11 +1170,14 @@
 		for( str = estreams.begin(); str &lt; estreams.end(); ++str )
 		{
 #ifdef STREAM_LOGGING
-            mjpeg_warn(&quot;STREAM %02x: SCR=%lld mux=%d reqDTS=%lld&quot;, 
+            mjpeg_debug(&quot;%02x: SCR=%lld (%.3f) mux=%d %d reqDTS=%lld &quot;, 
                         (*str)-&gt;stream_id,
-                        current_SCR /300,
+                        current_SCR,
+                        static_cast&lt;double&gt;(current_SCR) /(90.0*300.0),
                         (*str)-&gt;MuxPossible(current_SCR),
+                        (*str)-&gt;BufferSize()-(*str)-&gt;bufmodel.Space(),
                         (*str)-&gt;RequiredDTS()/300
+                        
 				);
 #endif
 			if( (*str)-&gt;MuxPossible(current_SCR) &amp;&amp; 
@@ -1202,22 +1199,19 @@
 		{
 			despatch-&gt;BufferAndOutputSector();
 			video_first = false;
-#if 0                        
+			if( current_SCR &gt;=  earliest &amp;&amp; underrun_ignore == 0)
+			{
 				mjpeg_warn( &quot;Stream %02x: data will arrive too late sent(SCR)=%lld required(DTS)=%lld&quot;, 
 							despatch-&gt;stream_id, 
 							current_SCR/300, 
 							earliest/300 );
-#endif                                                        
 				MuxStatus( LOG_WARN );
-                        if( current_SCR &gt;=  earliest &amp;&amp; underrun_ignore == 0)
-                        {
-                                                        
 				// Give the stream a chance to recover
 				underrun_ignore = 300;
 				++underruns;
-				if( underruns &gt; MAX_UNDERRUN  )
+				if( underruns &gt; 10  )
 				{
-					//mjpeg_error_exit1(&quot;Too many frame drops -exiting&quot; );
+					mjpeg_error_exit1(&quot;Too many frame drops -exiting&quot; );
 				}
 			}
             if( despatch-&gt;nsec &gt; 50 &amp;&amp;
@@ -1245,8 +1239,11 @@
                 {
                     clockticks change_time = (*str)-&gt;bufmodel.NextChange();
                     if( next_change == 0 || change_time &lt; next_change )
+                    {
                         next_change = change_time;
+                    }
                 }
+
                 unsigned int bumps = 5;
                 while( bumps &gt; 0 
                        &amp;&amp; next_change &gt; current_SCR + ticks_per_sector)
@@ -1254,6 +1251,7 @@
                     NextPosAndSCR();
                     --bumps;
                 }
+                            
             }
             else
             {
@@ -1312,11 +1310,11 @@
 
     if( underruns&gt; 0 )
 	{
-		mjpeg_warn( &quot;MUX STATUS: Frame data under-runs detected!&quot; );
+		mjpeg_error_exit1( &quot;MUX STATUS: Frame data under-runs detected!&quot; );
 	}
 	else
 	{
-		mjpeg_warn( &quot;MUX STATUS: no under-runs detected.&quot;);
+		mjpeg_info( &quot;MUX STATUS: no under-runs detected.&quot;);
 	}
 }
 

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/multiplexor.hpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/multiplexor.hpp	2007-08-02 19:57:16 UTC (rev 3468)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/multiplexor.hpp	2007-08-03 00:04:40 UTC (rev 3469)
@@ -13,11 +13,14 @@
 class Multiplexor
 {
 public:
-	Multiplexor(MultiplexJob &amp;job, OutputStream &amp;output);	
-	void Close(void);
+	Multiplexor(MultiplexJob &amp;job, OutputStream &amp;output);
 	void Multiplex ();
-	void ByteposTimecode( bitcount_t bytepos, clockticks &amp;ts );	
+
+
+	void ByteposTimecode( bitcount_t bytepos, clockticks &amp;ts );
+	
 	inline Sys_header_struc *SystemHeader() { return &amp;sys_header; }
+
 	unsigned int PacketPayload(	MuxStream &amp;strm,
 								bool buffers, bool PTSstamp, bool DTSstamp );
 	unsigned int WritePacket( unsigned int     max_packet_data_size,

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/padstrm.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/padstrm.cpp	2007-08-02 19:57:16 UTC (rev 3468)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/padstrm.cpp	2007-08-03 00:04:40 UTC (rev 3469)
@@ -35,7 +35,7 @@
 
 unsigned int PaddingStream::ReadPacketPayload(uint8_t *dst, unsigned int to_read)
 {
-	memset( dst, 0, to_read );
+	memset( dst, STUFFING_BYTE, to_read );
 	return to_read;
 }
 

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/stillsstream.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/stillsstream.cpp	2007-08-02 19:57:16 UTC (rev 3468)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/stillsstream.cpp	2007-08-03 00:04:40 UTC (rev 3469)
@@ -37,7 +37,6 @@
 	int buffer_size = -1;
 
 	SetBufSize( 4*1024*1024 );
-	InitAUbuffer();
 	ScanFirstSeqHeader();
 
 	mjpeg_debug( &quot;Stills: Video buffer suggestion ignored!&quot; );
@@ -110,7 +109,7 @@
  *
  */
 
-void StillsStream::NextDTSPTS( clockticks &amp;DTS, clockticks &amp;PTS )
+void StillsStream::NextDTSPTS( )
 {
     StillsParams *sparms = static_cast&lt;StillsParams*&gt;(parms);
 
@@ -119,11 +118,11 @@
 	clockticks time_for_xfer;
 	muxinto.ByteposTimecode( BufferSize(), time_for_xfer );
 		
-	DTS = current_PTS + time_for_xfer;	// This frame decoded just after
+	access_unit.DTS = current_PTS + time_for_xfer;	// This frame decoded just after
 	                                    // Predecessor completed.
-	PTS = current_PTS + time_for_xfer + interval;
-	current_PTS = PTS;
-	current_DTS = DTS;
+	access_unit.PTS = current_PTS + time_for_xfer + interval;
+	current_PTS = access_unit.PTS;
+	current_DTS = access_unit.DTS;
     fields_presented += 2;
 }
 

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/stillsstream.hpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/stillsstream.hpp	2007-08-02 19:57:16 UTC (rev 3468)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/stillsstream.hpp	2007-08-03 00:04:40 UTC (rev 3469)
@@ -40,7 +40,7 @@
 		{}
 	void Init( );
 private:
-	virtual void NextDTSPTS( clockticks &amp;DTS, clockticks &amp;PTS );
+	virtual void NextDTSPTS( );
 	clockticks current_PTS;
 	clockticks current_DTS;
 };

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/streamType.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/streamType.h	2007-08-02 19:57:16 UTC (rev 3468)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/streamType.h	2007-08-03 00:04:40 UTC (rev 3469)
@@ -1,22 +0,0 @@
-#ifndef STREAM_TYPE_H
-#define STREAM_TYPE_H
-enum StreamKind
-  {
-      MPEG_AUDIO=1,
-      AC3_AUDIO,
-      LPCM_AUDIO,
-      DTS_AUDIO,
-      MPEG_VIDEO
-#ifdef ZALPHA
-        ,
-      Z_ALPHA
-#endif
-  };
-
-typedef struct mplexStreamDescriptor
-{
-  int channel;
-  int frequency;
-  StreamKind kind;
-}mplexStreamDescriptor;
-#endif

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/stream_params.hpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/stream_params.hpp	2007-08-02 19:57:16 UTC (rev 3468)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/stream_params.hpp	2007-08-03 00:04:40 UTC (rev 3469)
@@ -1,5 +1,5 @@
 /*
- * params.hpp:  User specifiable parameter classes for various types of stream
+ * streamparams.hpp:  User specifiable parameter classes for various types of stream
  *
  * The class constructors etc are defined so that it is impossible to build
  * objects with illegal combinations of constructors.

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/systems.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/systems.cpp	2007-08-02 19:57:16 UTC (rev 3468)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/systems.cpp	2007-08-03 00:04:40 UTC (rev 3469)
@@ -25,17 +25,11 @@
 #include &lt;stdio.h&gt;
 #include &lt;stdlib.h&gt;
 #include &lt;string.h&gt;
-#if 0
-#ifdef _WIN32
-#include &lt;win32defs.h&gt;
-#else
+
 #include &lt;sys/param.h&gt;
-#endif
-#endif
 #include &quot;systems.hpp&quot;
 #include &quot;mplexconsts.hpp&quot;
 
-
 PS_Stream:: PS_Stream( unsigned _mpeg,
                        unsigned int _sector_size,
                        OutputStream &amp;_output_strm, 
@@ -59,13 +53,7 @@
 PS_Stream::SegmentLimReached()
 {
 	off_t written = output_strm.SegmentSize();
-	if(!max_segment_size) return false;
-	if(written &gt; max_segment_size)
-	{
-        printf(&quot;Mplex: current:%d max:%d, switching seg\n&quot;,written,max_segment_size);
-        return true;	
-	}
-	return false;
+	return max_segment_size != 0 &amp;&amp; written &gt; max_segment_size;
 }
 
 

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/vector.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/vector.cpp	2007-08-02 19:57:16 UTC (rev 3468)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/vector.cpp	2007-08-03 00:04:40 UTC (rev 3469)
@@ -1,24 +0,0 @@
-#include &lt;config.h&gt;
-#include &lt;stdlib.h&gt;
-#include &lt;stdio.h&gt;
-#include &lt;string.h&gt;
-#include &quot;mjpeg_types.h&quot;
-#include &quot;vector.hpp&quot;
-
-
-const unsigned int AUStream::BUF_SIZE = 128;
-
-AUStream::AUStream() : 
-	cur_rd( 0 ), cur_wr(0), totalctr(0), size(0), 
-	buf(AUStream::BUF_SIZE)
-{
-}
-
-
-void AUStream::init( Aunit *rec )
-{
-	buf[cur_wr] = rec;
-	++cur_wr;
-	cur_wr = cur_wr &gt;= AUStream::BUF_SIZE ? 0 : cur_wr;
-	cur_rd = cur_wr;
-}

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/vector.hpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/vector.hpp	2007-08-02 19:57:16 UTC (rev 3468)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/vector.hpp	2007-08-03 00:04:40 UTC (rev 3469)
@@ -1,78 +0,0 @@
-#ifndef __AUSTREAM_H__
-#define __AUSTREAM_H__
-
-#include &lt;vector&gt;
-#include &quot;mjpeg_logging.h&quot;
-#include &quot;aunit.hpp&quot;
-
-class AUStream
-{
-public:
-	// TODO The buffer should be delete-ed on destruction...
-	AUStream();
-	void init( Aunit *rec );
-
-	void append( Aunit &amp;rec )
-	{
-		if( size == BUF_SIZE )
-			mjpeg_error_exit1( &quot;INTERNAL ERROR: AU buffer overflow&quot; );
-		*buf[cur_wr] = rec;
-		++size;
-		++cur_wr;
-		cur_wr = cur_wr &gt;= BUF_SIZE ? 0 : cur_wr;
-	}
-
-	inline Aunit *next( ) 
-	{ 
-		if( size==0 )
-		{
-			return 0;
-		}
-	    else
-		{
-			Aunit *ret;
-			ret = buf[cur_rd];
-			++cur_rd;
-			++totalctr;
-			--size;
-			cur_rd = cur_rd &gt;= BUF_SIZE ? 0 : cur_rd;
-			return ret;
-		}
-	}
-
-	inline void droplast()
-		{
-			if( size == 0 )
-				mjpeg_error_exit1( &quot;INTERNAL ERROR: droplast empty AU buffer&quot; );
-			--size;
-			if( cur_wr == 0 )
-				cur_wr = BUF_SIZE ;
-			--cur_wr;
-		}
-
-	inline Aunit *lookahead( )
-	{
-		return size == 0 ? 0 : buf[cur_rd];
-    }
-
-	inline Aunit *last()
-		{
-			int i = cur_wr &lt; 1 ? BUF_SIZE-1 : cur_wr-1;
-			return buf[i];
-		}
-
-	static const unsigned int BUF_SIZE;
-
-	inline unsigned int current() { return totalctr; }
-private:
-	unsigned int cur_rd;
-	unsigned int cur_wr;
-	unsigned int totalctr;
-	unsigned int size;
-	std::vector&lt;AunitPtr&gt; buf;
-};
-
-
-
-
-#endif // __AUSTREAM_H__

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/videostrm.hpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/videostrm.hpp	2007-08-02 19:57:16 UTC (rev 3468)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/videostrm.hpp	2007-08-03 00:04:40 UTC (rev 3469)
@@ -32,34 +32,28 @@
 	VideoStream(IBitStream &amp;ibs, VideoParams *parms, 
                 Multiplexor &amp;into);
 	void Init( const int stream_num );
+
     static bool Probe(IBitStream &amp;bs );
 
 	void Close();
 
-	inline int AUType()
-		{
-			return au-&gt;type;
-		}
+    inline int DecoderOrder() { return au-&gt;dorder; }
+	inline int AUType()	{ return au-&gt;type; }
 
-	inline bool EndSeq()
-		{
-			return au-&gt;end_seq;
-		}
+    bool SeqEndRunOut();
 
+    const AUnit *NextIFrame();
+
+
 	inline int NextAUType()
 		{
-			VAunit *p_au = Lookahead();
-			if( p_au != NULL )
+			AUnit *p_au = Lookahead();
+			if( p_au != 0 )
 				return p_au-&gt;type;
 			else
 				return NOFRAME;
 		}
 
-	inline bool SeqHdrNext()
-		{
-			VAunit *p_au = Lookahead();
-			return  p_au != NULL &amp;&amp; p_au-&gt;seq_header;
-		}
 
 	virtual unsigned int NominalBitRate() 
 		{ 
@@ -69,26 +63,30 @@
     virtual void OutputGOPControlSector();
 	bool RunOutComplete();
 	virtual bool MuxPossible(clockticks currentSCR);
+    virtual void AUMuxed( bool first_in_sector ) ;
+
     void SetMaxStdBufferDelay( unsigned int demux_rate );
 	void OutputSector();
 
+
 protected:
+    static const unsigned int MAX_GOP_LENGTH = 128;
 	void OutputSeqhdrInfo();
-    virtual bool AUBufferNeedsRefill();
 	virtual void FillAUbuffer(unsigned int frames_to_buffer);
-	virtual void InitAUbuffer();
-	virtual void NextDTSPTS( clockticks &amp;DTS, clockticks &amp;PTS );
+	virtual void NextDTSPTS(  );
 	void ScanFirstSeqHeader();
     uint8_t NewAUTimestamps( int AUtype );
     bool NewAUBuffers( int AUtype );
 
+    unsigned int ExcludeNextIFramePayload();
+
 public:	
     unsigned int num_sequence 	;
     unsigned int num_seq_end	;
     unsigned int num_pictures 	;
     unsigned int num_groups 	;
     unsigned int num_frames[4] 	;
-    unsigned int avg_frames[4]  ;
+         int64_t avg_frames[4]  ;
     
     unsigned int horizontal_size;
     unsigned int vertical_size 	;
@@ -106,8 +104,9 @@
 
 protected:
 
+
 	/* State variables for scanning source bit-stream */
-    VAunit access_unit;
+    AUnit access_unit;
 	int fields_presented;
     int group_start_pic;
 	int group_start_field;
@@ -117,6 +116,8 @@
 	int pulldown_32;
 	int repeat_first_field;
 	int prev_temp_ref;
+    int ref_present;
+    int prev_ref_present;
     double frame_rate;
 	double max_bits_persec;
 	int AU_pict_data;

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/videostrm_in.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/videostrm_in.cpp	2007-08-02 19:57:16 UTC (rev 3468)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/videostrm_in.cpp	2007-08-03 00:04:40 UTC (rev 3469)
@@ -27,8 +27,8 @@
 #include &quot;interact.hpp&quot;
 #include &quot;multiplexor.hpp&quot;
 
-#define mjpeg_info mjpeg_warn
 
+
 static void marker_bit (IBitStream &amp;bs, unsigned int what)
 {
     if (what != bs.Get1Bit())
@@ -59,9 +59,9 @@
 		exit (1);
     }
 
-	if (mpeg_valid_framerate_code(picture_rate))
+	if (MX_mpeg_valid_framerate_code(picture_rate))
     {
-		frame_rate = Y4M_RATIO_DBL(mpeg_framerate(picture_rate));
+		frame_rate = Y4M_RATIO_DBL(MX_mpeg_framerate(picture_rate));
 	}
     else
     {
@@ -86,7 +86,6 @@
                 VIDEO_STR_0+stream_num,
                 bs.StreamName()
                 );
-	InitAUbuffer();
 
 	SetBufSize( 4*1024*1024 );
 	ScanFirstSeqHeader();
@@ -97,6 +96,9 @@
 	AU_pict_data = 0;
 	AU_start = 0;
     
+    fields_presented = 0;
+    group_start_pic = 0;
+    group_start_field = 0;
     OutputSeqhdrInfo();
 }
 
@@ -128,23 +130,7 @@
 
 }
 
-//
-// Return whether AU buffer needs refilling.  There are two cases:
-// 1. We have less than our look-ahead &quot;FRAME_CHUNK&quot; buffer AU's
-// buffered 2. AU's are very small and we could have less than 1
-// sector's worth of data buffered.
-//
 
-bool VideoStream::AUBufferNeedsRefill()
-{
-    return 
-        !eoscan
-        &amp;&amp; ( aunits.current()+FRAME_CHUNK &gt; last_buffered_AU
-             ||
-             bs.BufferedBytes() &lt; muxinto.sector_size 
-            );
-}
-
 //
 // Refill the AU unit buffer setting  AU PTS DTS from the scanned
 // header information...
@@ -186,19 +172,24 @@
 			switch (syncword) 
 			{
 			case SEQUENCE_HEADER :
+                mjpeg_debug( &quot;Seq hdr @ %lld&quot;, bs.bitcount() / 8-4 );
 			case GROUP_START :
+                mjpeg_debug( &quot;Group hdr @ %lld&quot;, bs.bitcount() / 8-4 );
 			case PICTURE_START :
 				access_unit.start = AU_start;
 				access_unit.length = static_cast&lt;int&gt;(stream_length - AU_start)&gt;&gt;3;
 				access_unit.end_seq = 0;
 				avg_frames[access_unit.type-1]+=access_unit.length;
-				aunits.append( access_unit );					
-                decoding_order++;
-				mjpeg_debug( &quot;Found start AU %d @ %lld: DTS=%ud&quot;, 
+				mjpeg_debug( &quot;AU %d %d %d @ %lld: DTS=%ud&quot;, 
                              decoding_order,
+                             access_unit.type,
+                             access_unit.length,
                              bs.bitcount() / 8-4,
 							 static_cast&lt;unsigned int&gt;(access_unit.DTS/300) );
 
+
+				aunits.Append( access_unit );					
+                decoding_order++;
 				AU_hdr = syncword;
 				AU_start = stream_length;
 				AU_pict_data = 0;
@@ -206,7 +197,7 @@
 			case SEQUENCE_END:
 				access_unit.length = ((stream_length - AU_start)&gt;&gt;3)+4;
 				access_unit.end_seq = 1;
-				aunits.append( access_unit );
+				aunits.Append( access_unit );
 				mjpeg_info( &quot;Scanned to end AU %d&quot;, access_unit.dorder );
 				avg_frames[access_unit.type-1]+=access_unit.length;
 
@@ -226,7 +217,7 @@
 					if( !bs.eos() &amp;&amp; muxinto.split_at_seq_end )
 						mjpeg_warn(&quot;No seq. header starting new sequence after seq. end!&quot;);
 				}
-					
+                decoding_order++;
 				num_seq_end++;
 				break;
 			}
@@ -248,6 +239,7 @@
 		case PICTURE_START:
 			/* We have reached AU's picture data... */
 			AU_pict_data = 1;
+            mjpeg_debug( &quot;Picture start @ %lld&quot;, bs.bitcount() / 8-4 );
 			
             prev_temp_ref = temporal_reference;
 			temporal_reference = bs.GetBits( 10);
@@ -294,10 +286,11 @@
 				group_start_field = fields_presented;
 			}
 
-			NextDTSPTS( access_unit.DTS, access_unit.PTS );
+			NextDTSPTS( );
 
 			access_unit.dorder = decoding_order;
 			access_unit.porder = temporal_reference + group_start_pic;
+
 			access_unit.seq_header = ( AU_hdr == SEQUENCE_HEADER);
 
 			if ((access_unit.type&gt;0) &amp;&amp; (access_unit.type&lt;5))
@@ -348,11 +341,11 @@
     mjpeg_info (&quot;No. Pictures    : %8u&quot;,num_pictures);
     mjpeg_info (&quot;No. Groups      : %8u&quot;,num_groups);
     mjpeg_info (&quot;No. I Frames    : %8u avg. size%6u bytes&quot;,
-			  num_frames[0],avg_frames[0]);
+			  num_frames[0], (uint32_t)avg_frames[0]);
     mjpeg_info (&quot;No. P Frames    : %8u avg. size%6u bytes&quot;,
-			  num_frames[1],avg_frames[1]);
+			  num_frames[1], (uint32_t)avg_frames[1]);
     mjpeg_info (&quot;No. B Frames    : %8u avg. size%6u bytes&quot;,
-			  num_frames[2],avg_frames[2]);
+			  num_frames[2], (uint32_t)avg_frames[2]);
     mjpeg_info(&quot;Average bit-rate : %8u bits/sec&quot;,comp_bit_rate*400);
     mjpeg_info(&quot;Peak bit-rate    : %8u  bits/sec&quot;,peak_bit_rate*400);
 	
@@ -373,8 +366,8 @@
 
     mjpeg_info (&quot;Frame width     : %u&quot;,horizontal_size);
     mjpeg_info (&quot;Frame height    : %u&quot;,vertical_size);
-	if (mpeg_valid_aspect_code(muxinto.mpeg, aspect_ratio))
-		str =  mpeg_aspect_code_definition(muxinto.mpeg,aspect_ratio);
+	if (MX_mpeg_valid_aspect_code(muxinto.mpeg, aspect_ratio))
+		str =  MX_mpeg_aspect_code_definition(muxinto.mpeg,aspect_ratio);
 	else
 		str = &quot;forbidden&quot;;
     mjpeg_info (&quot;Aspect ratio    : %s&quot;, str );
@@ -382,9 +375,9 @@
 
     if (picture_rate == 0)
 		mjpeg_info( &quot;Picture rate    : forbidden&quot;);
-    else if (mpeg_valid_framerate_code(picture_rate))
+    else if (MX_mpeg_valid_framerate_code(picture_rate))
 		mjpeg_info( &quot;Picture rate    : %2.3f frames/sec&quot;,
-					Y4M_RATIO_DBL(mpeg_framerate(picture_rate)) );
+					Y4M_RATIO_DBL(MX_mpeg_framerate(picture_rate)) );
     else
 		mjpeg_info( &quot;Picture rate    : %x reserved&quot;,picture_rate);
 
@@ -410,51 +403,86 @@
 // etc!).
 //
 
-void VideoStream::NextDTSPTS( clockticks &amp;DTS, clockticks &amp;PTS )
+int gopfields_32pd( int temporal_ref, bool repeat_first_field )
 {
+    int frames2field;
+    int frames3field;
+    //
+    // Assume first presented frame of GOP has temporal ref 0
+    if( repeat_first_field )
+    {
+        frames2field = (temporal_ref+1) / 2;
+        frames3field = temporal_ref / 2;
+    }
+    else
+    {
+        frames2field = (temporal_ref) / 2;
+        frames3field = (temporal_ref+1) / 2;
+    }
+
+    return frames2field*2 + frames3field*3;
+
+}
+
+/****************************************************
+ *
+ * Work out DTS PTS stamps for the current AU.
+ * Note: Current strategy assumes decoders model 'ideal'
+ * timing with instantaneous decoding.
+ * This makes sense it is what is assumed for B-frames anyway
+ * (no seperate DTS).
+ *
+ ******************************************************/
+
+void VideoStream::NextDTSPTS()
+{
+    const int decode_delay = 0;
+    int startup_skew = 2;
+    int decode_fields, present_fields;
     if( pict_struct != PIC_FRAME )
     {
-		DTS = static_cast&lt;clockticks&gt;
-			(fields_presented * (double)(CLOCKS/2) / frame_rate);
-        int dts_fields = temporal_reference*2 + group_start_field+1;
+		decode_fields = fields_presented;
+        present_fields = temporal_reference*2 + group_start_field+decode_delay/2;
         if( temporal_reference == prev_temp_ref )
-            dts_fields += 1;
-        PTS =
-            static_cast&lt;clockticks&gt;(dts_fields* (double)(CLOCKS/2) / frame_rate);
-		access_unit.porder = temporal_reference + group_start_pic;
+            present_fields += 1;
         fields_presented += 1;
     }	
     else if( pulldown_32 )
 	{
-		int frames2field;
-		int frames3field;
-		DTS = static_cast&lt;clockticks&gt;
-			(fields_presented * (double)(CLOCKS/2) / frame_rate);
-		if( repeat_first_field )
-		{
-			frames2field = (temporal_reference+1) / 2;
-			frames3field = temporal_reference / 2;
-			fields_presented += 3;
-		}
-		else
-		{
-			frames2field = (temporal_reference) / 2;
-			frames3field = (temporal_reference+1) / 2;
-			fields_presented += 2;
-		}
-		PTS = static_cast&lt;clockticks&gt;
-			((frames2field*2 + frames3field*3 + group_start_field+1) * (double)(CLOCKS/2) / frame_rate);
-		access_unit.porder = temporal_reference + group_start_pic;
+        present_fields = group_start_field  + startup_skew + decode_delay +
+            gopfields_32pd( temporal_reference, repeat_first_field );
+        
+        if( decoding_order == 0 )
+        {
+            // Special case... first IFRAME is not decoded during presentation
+            // of previous ref frame but immediately at start
+            decode_fields = 0;
+            prev_ref_present = present_fields ;
+        }
+        else if( access_unit.type == IFRAME || access_unit.type == PFRAME )
+        {
+            decode_fields = prev_ref_present-decode_delay;
+            prev_ref_present = present_fields;
+        }
+        else
+        {
+            decode_fields = present_fields - decode_delay;
+        }
+        fields_presented += repeat_first_field ? 3 : 2;
 	}
     else
 	{
-		DTS = static_cast&lt;clockticks&gt; 
-			(decoding_order * (double)CLOCKS / frame_rate);
-		PTS = static_cast&lt;clockticks&gt;
-			((temporal_reference + group_start_pic+1) * (double)CLOCKS / frame_rate);
+        decode_fields = decoding_order*2;
+        present_fields = (temporal_reference + group_start_pic)*2
+            + startup_skew + decode_delay;
 		fields_presented += 2;
 	}
 
+    access_unit.DTS = static_cast&lt;clockticks&gt;
+        (decode_fields * (double)(CLOCKS/2) / frame_rate);
+    
+    access_unit.PTS = static_cast&lt;clockticks&gt;
+        (present_fields * (double)(CLOCKS/2) / frame_rate);
 }
 
 

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/videostrm_out.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/videostrm_out.cpp	2007-08-02 19:57:16 UTC (rev 3468)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/videostrm_out.cpp	2007-08-03 00:04:40 UTC (rev 3469)
@@ -25,11 +25,9 @@
 #include &lt;assert.h&gt;
 
 #include &quot;mjpeg_types.h&quot;
-#include &quot;fastintfns.h&quot;
 #include &quot;videostrm.hpp&quot;
 #include &quot;multiplexor.hpp&quot;
 
-
 VideoStream::VideoStream(IBitStream &amp;ibs, VideoParams *parms, 
                          Multiplexor &amp;into ) :
 	ElementaryStream( ibs, into, ElementaryStream::video ),
@@ -64,14 +62,6 @@
     return bs.GetBits( 32)  == 0x1b3;
 }
 
-void VideoStream::InitAUbuffer()
-{
-	unsigned int i;
-	for( i = 0; i &lt; aunits.BUF_SIZE; ++i )
-		aunits.init( new VAunit );
-}
-
-
 /*********************************
  * Signals when video stream has completed mux run-out specified
  * in associated mux stream.   Run-out is always to complete GOP's.
@@ -94,14 +84,20 @@
  * where long delays mess up random access.
  *******************************/
 
-
 bool VideoStream::MuxPossible( clockticks currentSCR )
 {
-
 	return ( ElementaryStream::MuxPossible(currentSCR) &amp;&amp; 
              RequiredDTS() &lt; currentSCR + max_STD_buffer_delay );
 }
 
+
+void VideoStream::AUMuxed( bool first_in_sector )
+{
+    //DEBUG
+    //mjpeg_info( &quot;VidMuxed: %d %lld &quot;, au-&gt;dorder, RequiredDTS()/300 );
+}
+
+
 /*********************************
  * Work out the timestamps to be set in the header of sectors starting
  * new AU's.
@@ -131,6 +127,81 @@
         !(muxinto.video_buffers_iframe_only &amp;&amp; AUtype != IFRAME);
 }
 
+/********************************
+ *
+ * Check if the next sector could potentially include parts of AUs
+ * following a sequence end marker... in this case a run-out may be needed
+ *
+ *******************************/
+
+bool VideoStream::SeqEndRunOut()
+{
+    unsigned int payload = au_unsent;
+    unsigned int ahead = 0;
+    AUnit *next_au = au;
+    for(;;)
+    {
+        if( next_au-&gt;end_seq || payload &gt;= muxinto.sector_size)
+            break;  
+        ++ahead;
+        next_au = Lookahead(ahead);
+        if( next_au == 0 )
+            break;
+        payload += next_au-&gt;PayloadSize();
+    }
+    
+    // We don't need to start run-out if the next sector cannot contain
+    // next sequence or there is no next sequence (no AU after the one with
+    // the sequence end marker
+    return next_au != 0 &amp;&amp; next_au-&gt;end_seq 
+        &amp;&amp; payload &lt; muxinto.sector_size
+        &amp;&amp; Lookahead(ahead+1) != 0;
+
+}
+
+/********************************
+ *
+ * Check if the next sector could potentially include a seq_end marker
+ *
+ *******************************/
+
+const AUnit *VideoStream::NextIFrame()
+{
+    unsigned int ahead = 0;
+    AUnit *au_ahead = Lookahead(ahead);
+    while( au_ahead != 0 &amp;&amp; au_ahead-&gt;type != IFRAME 
+           &amp;&amp; ahead &lt; MAX_GOP_LENGTH )
+    {
+        ++ahead;
+        au_ahead = Lookahead(ahead);
+    }
+    return au_ahead;
+}
+
+/********************************
+ *
+ * Calculate how much payload can be muxed next sector without
+ * including the next IFRAME.
+ *
+ *******************************/
+
+unsigned int VideoStream::ExcludeNextIFramePayload()
+{
+    unsigned int payload = au_unsent;
+    unsigned int ahead = 0;
+    AUnit *au_ahead;
+    for(;;)
+    {
+        au_ahead = Lookahead(ahead);
+        if( au_ahead == 0 || payload &gt;= muxinto.sector_size || au_ahead-&gt;type == IFRAME )
+            break;
+        payload += au_ahead-&gt;PayloadSize();
+        ++ahead;
+    }
+    assert( eoscan || au_ahead != 0 );
+    return payload;
+}
+
 /******************************************************************
 	Output_Video
 	generiert Pack/Sys_Header/Packet Informationen aus dem
@@ -143,7 +214,6 @@
 void VideoStream::OutputSector ( )
 
 {
-
 	unsigned int max_packet_payload; 	 
 	unsigned int actual_payload;
 	unsigned int old_au_then_new_payload;
@@ -152,21 +222,25 @@
 
 	max_packet_payload = 0;	/* 0 = Fill sector */
   	/* 	
- 	   We're now in the last AU of a segment.  So we don't want to go
- 	   beyond it's end when filling sectors. Hence we limit packet
- 	   payload size to (remaining) AU length.  The same applies when
- 	   we wish to ensure sequence headers starting ACCESS-POINT AU's
- 	   in (S)VCD's etc are sector-aligned.  
+       I-frame aligning.  For the last AU of segment or for formats
+       with ACCESS-POINT sectors where I-frame (and preceding headers)
+       are sector aligned.
 
-       N.b.runout_PTS is the PTS of the first I picture following the
-       run-out is recorded.
+       We need to look ahead to see how much we may put into the current packet
+       without without touching the next I-frame (which is supposed to be
+       placed at the start of its own sector).
+
+       N.b.runout_PTS is the PTS of the after which the next I frame
+       marks the start of the next sequence.
 	*/
-	int nextAU = NextAUType();
-	if( ( muxinto.running_out &amp;&amp; nextAU == IFRAME &amp;&amp; NextRequiredPTS() &gt;= muxinto.runout_PTS) 
-        || (muxinto.sector_align_iframeAUs &amp;&amp; nextAU == IFRAME  )
-		) 
+    
+    /* TODO finish this: Need to look-ahead sufficiently far to
+       guarantee finding an I-FRAME even if its predecessors are very
+       small.  
+    */
+	if( muxinto.sector_align_iframeAUs || muxinto.running_out )
 	{
-		max_packet_payload = au_unsent;
+		max_packet_payload = ExcludeNextIFramePayload();
 	}
 
 	/* Figure out the threshold payload size below which we can fit more
@@ -177,8 +251,8 @@
 	   of the last packet...  */
 
 	old_au_then_new_payload = muxinto.PacketPayload( *this,
-													 buffers_in_header, 
-													 true, true);
+					buffers_in_header, 
+					true, true);
 
 	/* CASE: Packet starts with new access unit			*/
 	if (new_au_next_sec  )
@@ -205,10 +279,10 @@
         DTS = RequiredDTS();
 		actual_payload =
 			muxinto.WritePacket ( max_packet_payload,
-								  *this,
-								  NewAUBuffers(autype), 
-                                  PTS, DTS,
-								  NewAUTimestamps(autype) );
+						*this,
+						NewAUBuffers(autype), 
+                                  		PTS, DTS,
+						NewAUTimestamps(autype) );
 
 	}
 
@@ -220,9 +294,9 @@
 	{
 		actual_payload = 
 			muxinto.WritePacket( au_unsent,
-								  *this,
-								  false, 0, 0,
-								  TIMESTAMPBITS_NO );
+							*this,
+							false, 0, 0,
+							TIMESTAMPBITS_NO );
 	}
 
 	/* CASE: Packet begins with old access unit, a new one	*/
@@ -242,19 +316,17 @@
 
 			actual_payload = 
 				muxinto.WritePacket ( max_packet_payload,
-									  *this,
-									  NewAUBuffers(autype), 
-                                      PTS, DTS,
-									  NewAUTimestamps(autype) );
+						*this,
+						NewAUBuffers(autype), 
+                                      		PTS, DTS,
+						NewAUTimestamps(autype) );
 		} 
 		else
 		{
-			actual_payload = muxinto.WritePacket ( au_unsent,
-										 *this,
-										 false, 0, 0,
-										 TIMESTAMPBITS_NO);
+			actual_payload = muxinto.WritePacket ( au_unsent, 
+							*this, false, 0, 0,
+							TIMESTAMPBITS_NO);
 		}
-
 	}
 	++nsec;
 	buffers_in_header = always_buffers_in_header;

Added: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/yuv4mpeg.c
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/yuv4mpeg.c	2007-08-02 19:57:16 UTC (rev 3468)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/yuv4mpeg.c	2007-08-03 00:04:40 UTC (rev 3469)
@@ -0,0 +1,1339 @@
+/*
+ *  yuv4mpeg.c:  Functions for reading and writing &quot;new&quot; YUV4MPEG streams
+ *
+ *  Copyright (C) 2001 Matthew J. Marjanovic &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">maddog at mir.com</A>&gt;
+ *
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU General Public License
+ *  as published by the Free Software Foundation; either version 2
+ *  of the License, or (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ *
+ */
+
+#include &lt;config.h&gt;
+
+#include &lt;unistd.h&gt;
+#include &lt;stdio.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;string.h&gt;
+#define INTERNAL_Y4M_LIBCODE_STUFF_QPX
+#include &quot;yuv4mpeg.h&quot;
+#include &quot;yuv4mpeg_intern.h&quot;
+#include &quot;mjpeg_logging.h&quot;
+
+
+static int _y4mparam_allow_unknown_tags = 1;  /* default is forgiveness */
+static int _y4mparam_feature_level = 0;       /* default is ol YUV4MPEG2 */
+
+static void *(*_y4m_alloc)(size_t bytes) = malloc;
+static void (*_y4m_free)(void *ptr) = free;
+
+
+
+int y4m_allow_unknown_tags(int yn)
+{
+  int old = _y4mparam_allow_unknown_tags;
+  if (yn &gt;= 0)
+    _y4mparam_allow_unknown_tags = (yn) ? 1 : 0;
+  return old;
+}
+
+
+int y4m_accept_extensions(int level)
+{
+  int old = _y4mparam_feature_level;
+  if (level &gt;= 0)
+    _y4mparam_feature_level = level;
+  return old;
+}
+
+
+
+/*************************************************************************
+ *
+ * Convenience functions for fd read/write
+ *
+ *   - guaranteed to transfer entire payload (or fail)
+ *   - returns:
+ *               0 on complete success
+ *               +(# of remaining bytes) on eof (for y4m_read)
+ *               -(# of rem. bytes) on error (and ERRNO should be set)
+ *     
+ *************************************************************************/
+
+
+ssize_t y4m_read(int fd, void *buf, size_t len)
+{
+   ssize_t n;
+   uint8_t *ptr = (uint8_t *)buf;
+
+   while (len &gt; 0) {
+     n = read(fd, ptr, len);
+     if (n &lt;= 0) {
+       /* return amount left to read */
+       if (n == 0)
+	 return len;  /* n == 0 --&gt; eof */
+       else
+	 return -len; /* n &lt; 0 --&gt; error */
+     }
+     ptr += n;
+     len -= n;
+   }
+   return 0;
+}
+
+
+ssize_t y4m_write(int fd, const void *buf, size_t len)
+{
+   ssize_t n;
+   const uint8_t *ptr = (const uint8_t *)buf;
+
+   while (len &gt; 0) {
+     n = write(fd, ptr, len);
+     if (n &lt;= 0) return -len;  /* return amount left to write */
+     ptr += n;
+     len -= n;
+   }
+   return 0;
+}
+
+
+
+
+/*************************************************************************
+ *
+ * &quot;Extra tags&quot; handling
+ *
+ *************************************************************************/
+
+
+static char *y4m_new_xtag(void)
+{
+  return _y4m_alloc(Y4M_MAX_XTAG_SIZE * sizeof(char));
+}
+
+
+void y4m_init_xtag_list(y4m_xtag_list_t *xtags)
+{
+  int i;
+  xtags-&gt;count = 0;
+  for (i = 0; i &lt; Y4M_MAX_XTAGS; i++) {
+    xtags-&gt;tags[i] = NULL;
+  }
+}
+
+
+void y4m_fini_xtag_list(y4m_xtag_list_t *xtags)
+{
+  int i;
+  for (i = 0; i &lt; Y4M_MAX_XTAGS; i++) {
+    if (xtags-&gt;tags[i] != NULL) {
+      _y4m_free(xtags-&gt;tags[i]);
+      xtags-&gt;tags[i] = NULL;
+    }
+  }
+  xtags-&gt;count = 0;
+}
+
+
+void y4m_copy_xtag_list(y4m_xtag_list_t *dest, const y4m_xtag_list_t *src)
+{
+  int i;
+  for (i = 0; i &lt; src-&gt;count; i++) {
+    if (dest-&gt;tags[i] == NULL) 
+      dest-&gt;tags[i] = y4m_new_xtag();
+    strncpy(dest-&gt;tags[i], src-&gt;tags[i], Y4M_MAX_XTAG_SIZE);
+  }
+  dest-&gt;count = src-&gt;count;
+}
+
+
+
+static int y4m_snprint_xtags(char *s, int maxn, const y4m_xtag_list_t *xtags)
+{
+  int i, room;
+  
+  for (i = 0, room = maxn - 1; i &lt; xtags-&gt;count; i++) {
+    int n = snprintf(s, room + 1, &quot; %s&quot;, xtags-&gt;tags[i]);
+    if ((n &lt; 0) || (n &gt; room)) return Y4M_ERR_HEADER;
+    s += n;
+    room -= n;
+  }
+  s[0] = '\n';  /* finish off header with newline */
+  s[1] = '\0';  /* ...and end-of-string           */
+  return Y4M_OK;
+}
+
+
+int y4m_xtag_count(const y4m_xtag_list_t *xtags)
+{
+  return xtags-&gt;count;
+}
+
+
+const char *y4m_xtag_get(const y4m_xtag_list_t *xtags, int n)
+{
+  if (n &gt;= xtags-&gt;count)
+    return NULL;
+  else
+    return xtags-&gt;tags[n];
+}
+
+
+int y4m_xtag_add(y4m_xtag_list_t *xtags, const char *tag)
+{
+  if (xtags-&gt;count &gt;= Y4M_MAX_XTAGS) return Y4M_ERR_XXTAGS;
+  if (xtags-&gt;tags[xtags-&gt;count] == NULL) 
+    xtags-&gt;tags[xtags-&gt;count] = y4m_new_xtag();
+  strncpy(xtags-&gt;tags[xtags-&gt;count], tag, Y4M_MAX_XTAG_SIZE);
+  (xtags-&gt;count)++;
+  return Y4M_OK;
+}
+
+
+int y4m_xtag_remove(y4m_xtag_list_t *xtags, int n)
+{
+  int i;
+  char *q;
+
+  if ((n &lt; 0) || (n &gt;= xtags-&gt;count)) return Y4M_ERR_RANGE;
+  q = xtags-&gt;tags[n];
+  for (i = n; i &lt; (xtags-&gt;count - 1); i++)
+    xtags-&gt;tags[i] = xtags-&gt;tags[i+1];
+  xtags-&gt;tags[i] = q;
+  (xtags-&gt;count)--;
+  return Y4M_OK;
+}
+
+
+int y4m_xtag_clearlist(y4m_xtag_list_t *xtags)
+{
+  xtags-&gt;count = 0;
+  return Y4M_OK;
+}
+
+
+int y4m_xtag_addlist(y4m_xtag_list_t *dest, const y4m_xtag_list_t *src)
+{
+  int i, j;
+
+  if ((dest-&gt;count + src-&gt;count) &gt; Y4M_MAX_XTAGS) return Y4M_ERR_XXTAGS;
+  for (i = dest-&gt;count, j = 0;
+       j &lt; src-&gt;count;
+       i++, j++) {
+    if (dest-&gt;tags[i] == NULL) 
+      dest-&gt;tags[i] = y4m_new_xtag();
+    strncpy(dest-&gt;tags[i], src-&gt;tags[i], Y4M_MAX_XTAG_SIZE);
+  }
+  dest-&gt;count += src-&gt;count;
+  return Y4M_OK;
+}  
+
+
+/*************************************************************************
+ *
+ * Creators/destructors for y4m_*_info_t structures
+ *
+ *************************************************************************/
+
+
+void y4m_init_stream_info(y4m_stream_info_t *info)
+{
+  if (info == NULL) return;
+  /* init substructures */
+  y4m_init_xtag_list(&amp;(info-&gt;x_tags));
+  /* set defaults */
+  y4m_clear_stream_info(info);
+}
+
+
+void y4m_clear_stream_info(y4m_stream_info_t *info)
+{
+  if (info == NULL) return;
+  /* clear/initialize info */
+  info-&gt;width = Y4M_UNKNOWN;
+  info-&gt;height = Y4M_UNKNOWN;
+  info-&gt;interlace = Y4M_UNKNOWN;
+  info-&gt;framerate = y4m_fps_UNKNOWN;
+  info-&gt;sampleaspect = y4m_sar_UNKNOWN;
+  if (_y4mparam_feature_level &lt; 1) {
+    info-&gt;chroma = Y4M_CHROMA_420JPEG;
+  } else {
+    info-&gt;chroma = Y4M_UNKNOWN;
+  }
+  y4m_xtag_clearlist(&amp;(info-&gt;x_tags));
+}
+
+
+void y4m_copy_stream_info(y4m_stream_info_t *dest,
+			  const y4m_stream_info_t *src)
+{
+  if ((dest == NULL) || (src == NULL)) return;
+  /* copy info */
+  dest-&gt;width = src-&gt;width;
+  dest-&gt;height = src-&gt;height;
+  dest-&gt;interlace = src-&gt;interlace;
+  dest-&gt;framerate = src-&gt;framerate;
+  dest-&gt;sampleaspect = src-&gt;sampleaspect;
+  dest-&gt;chroma = src-&gt;chroma;
+  y4m_copy_xtag_list(&amp;(dest-&gt;x_tags), &amp;(src-&gt;x_tags));
+}
+
+
+void y4m_fini_stream_info(y4m_stream_info_t *info)
+{
+  if (info == NULL) return;
+  y4m_fini_xtag_list(&amp;(info-&gt;x_tags));
+}
+
+
+void y4m_si_set_width(y4m_stream_info_t *si, int width)
+{
+  si-&gt;width = width;
+}
+
+int y4m_si_get_width(const y4m_stream_info_t *si)
+{ return si-&gt;width; }
+
+void y4m_si_set_height(y4m_stream_info_t *si, int height)
+{
+  si-&gt;height = height; 
+}
+
+int y4m_si_get_height(const y4m_stream_info_t *si)
+{ return si-&gt;height; }
+
+void y4m_si_set_interlace(y4m_stream_info_t *si, int interlace)
+{ si-&gt;interlace = interlace; }
+
+int y4m_si_get_interlace(const y4m_stream_info_t *si)
+{ return si-&gt;interlace; }
+
+void y4m_si_set_framerate(y4m_stream_info_t *si, y4m_ratio_t framerate)
+{ si-&gt;framerate = framerate; }
+
+y4m_ratio_t y4m_si_get_framerate(const y4m_stream_info_t *si)
+{ return si-&gt;framerate; }
+
+void y4m_si_set_sampleaspect(y4m_stream_info_t *si, y4m_ratio_t sar)
+{ si-&gt;sampleaspect = sar; }
+
+y4m_ratio_t y4m_si_get_sampleaspect(const y4m_stream_info_t *si)
+{ return si-&gt;sampleaspect; }
+
+void y4m_si_set_chroma(y4m_stream_info_t *si, int chroma_mode)
+{ si-&gt;chroma = chroma_mode; }
+
+int y4m_si_get_chroma(const y4m_stream_info_t *si)
+{ return si-&gt;chroma; }
+
+
+int y4m_si_get_plane_count(const y4m_stream_info_t *si)
+{
+  switch (si-&gt;chroma) {
+  case Y4M_CHROMA_420JPEG:
+  case Y4M_CHROMA_420MPEG2:
+  case Y4M_CHROMA_420PALDV:
+  case Y4M_CHROMA_444:
+  case Y4M_CHROMA_422:
+  case Y4M_CHROMA_411:
+    return 3;
+  case Y4M_CHROMA_MONO:
+    return 1;
+  case Y4M_CHROMA_444ALPHA:
+    return 4;
+  default:
+    return Y4M_UNKNOWN;
+  }
+}
+
+int y4m_si_get_plane_width(const y4m_stream_info_t *si, int plane)
+{
+  switch (plane) {
+  case 0:
+    return (si-&gt;width);
+  case 1:
+  case 2:
+    switch (si-&gt;chroma) {
+    case Y4M_CHROMA_420JPEG: 
+    case Y4M_CHROMA_420MPEG2:
+    case Y4M_CHROMA_420PALDV:
+      return (si-&gt;width) / 2;
+    case Y4M_CHROMA_444:
+    case Y4M_CHROMA_444ALPHA:
+      return (si-&gt;width);
+    case Y4M_CHROMA_422:
+      return (si-&gt;width) / 2;
+    case Y4M_CHROMA_411:
+      return (si-&gt;width) / 4;
+    default:
+      return Y4M_UNKNOWN;
+    }
+  case 3:
+    switch (si-&gt;chroma) {
+    case Y4M_CHROMA_444ALPHA:
+      return (si-&gt;width);
+    default:
+      return Y4M_UNKNOWN;
+    }
+  default:
+    return Y4M_UNKNOWN;
+  }
+}
+
+int y4m_si_get_plane_height(const y4m_stream_info_t *si, int plane)
+{
+  switch (plane) {
+  case 0:
+    return (si-&gt;height);
+  case 1:
+  case 2:
+    switch (si-&gt;chroma) {
+    case Y4M_CHROMA_420JPEG: 
+    case Y4M_CHROMA_420MPEG2:
+    case Y4M_CHROMA_420PALDV:
+      return (si-&gt;height) / 2;
+    case Y4M_CHROMA_444:
+    case Y4M_CHROMA_444ALPHA:
+    case Y4M_CHROMA_422:
+    case Y4M_CHROMA_411:
+      return (si-&gt;height);
+    default:
+      return Y4M_UNKNOWN;
+    }
+  case 3:
+    switch (si-&gt;chroma) {
+    case Y4M_CHROMA_444ALPHA:
+      return (si-&gt;height);
+    default:
+      return Y4M_UNKNOWN;
+    }
+  default:
+    return Y4M_UNKNOWN;
+  }
+}
+
+int y4m_si_get_plane_length(const y4m_stream_info_t *si, int plane)
+{
+  int w = y4m_si_get_plane_width(si, plane);
+  int h = y4m_si_get_plane_height(si, plane);
+  if ((w != Y4M_UNKNOWN) &amp;&amp; (h != Y4M_UNKNOWN))
+    return (w * h);
+  else
+    return Y4M_UNKNOWN;
+}
+
+int y4m_si_get_framelength(const y4m_stream_info_t *si)
+{
+  int total = 0;
+  int planes = y4m_si_get_plane_count(si);
+  int p;
+  for (p = 0; p &lt; planes; p++) {
+    int plen = y4m_si_get_plane_length(si, p);
+    if (plen == Y4M_UNKNOWN) return Y4M_UNKNOWN;
+    total += plen;
+  }
+  return total;
+}
+
+
+y4m_xtag_list_t *y4m_si_xtags(y4m_stream_info_t *si)
+{ return &amp;(si-&gt;x_tags); }
+
+
+
+void y4m_init_frame_info(y4m_frame_info_t *info)
+{
+  if (info == NULL) return;
+  /* init substructures */
+  y4m_init_xtag_list(&amp;(info-&gt;x_tags));
+  /* set defaults */
+  y4m_clear_frame_info(info);
+}
+
+
+void y4m_clear_frame_info(y4m_frame_info_t *info)
+{
+  if (info == NULL) return;
+  /* clear/initialize info */
+  info-&gt;spatial = Y4M_UNKNOWN;
+  info-&gt;temporal = Y4M_UNKNOWN;
+  info-&gt;presentation = Y4M_UNKNOWN;
+  y4m_xtag_clearlist(&amp;(info-&gt;x_tags));
+}
+
+
+void y4m_copy_frame_info(y4m_frame_info_t *dest, const y4m_frame_info_t *src)
+{
+  if ((dest == NULL) || (src == NULL)) return;
+  /* copy info */
+  dest-&gt;spatial = src-&gt;spatial;
+  dest-&gt;temporal = src-&gt;temporal;
+  dest-&gt;presentation = src-&gt;presentation;
+  y4m_copy_xtag_list(&amp;(dest-&gt;x_tags), &amp;(src-&gt;x_tags));
+}
+
+void y4m_fini_frame_info(y4m_frame_info_t *info)
+{
+  if (info == NULL) return;
+  y4m_fini_xtag_list(&amp;(info-&gt;x_tags));
+}
+
+
+void y4m_fi_set_presentation(y4m_frame_info_t *fi, int pres)
+{ fi-&gt;presentation = pres; }
+
+int y4m_fi_get_presentation(const y4m_frame_info_t *fi)
+{ return fi-&gt;presentation; }
+
+void y4m_fi_set_temporal(y4m_frame_info_t *fi, int sampling)
+{ fi-&gt;temporal = sampling; }
+
+int y4m_fi_get_temporal(const y4m_frame_info_t *fi)
+{ return fi-&gt;temporal; }
+
+void y4m_fi_set_spatial(y4m_frame_info_t *fi, int sampling)
+{ fi-&gt;spatial = sampling; }
+
+int y4m_fi_get_spatial(const y4m_frame_info_t *fi)
+{ return fi-&gt;spatial; }
+
+
+
+y4m_xtag_list_t *y4m_fi_xtags(y4m_frame_info_t *fi)
+{ return &amp;(fi-&gt;x_tags); }
+
+
+/*************************************************************************
+ *
+ * Tag parsing 
+ *
+ *************************************************************************/
+
+
+/* Parse (the first) old, unofficial X-tag chroma specification,
+   and then remove that tag from the X-tag list. */
+static int
+handle_old_chroma_xtag(y4m_stream_info_t *si)
+{
+  y4m_xtag_list_t *xtags = y4m_si_xtags(si);
+  const char *tag = NULL;
+  int n, chroma;
+
+  for (n = y4m_xtag_count(xtags) - 1; n &gt;= 0; n--) {
+    tag = y4m_xtag_get(xtags, n);
+    if (!strncmp(&quot;XYSCSS=&quot;, tag, 7)) break;
+  }
+  if ((tag == NULL) || (n &lt; 0)) return Y4M_UNKNOWN;
+  mjpeg_warn(&quot;Deprecated X-tag for chroma found in a stream header...&quot;);
+  mjpeg_warn(&quot;...pester someone to upgrade the source's program!&quot;);
+  /* parse the tag */
+  tag += 7;
+  if (!strcmp(&quot;411&quot;, tag))           chroma = Y4M_CHROMA_411;
+  else if (!strcmp(tag, &quot;420&quot;))      chroma = Y4M_CHROMA_420JPEG;
+  else if (!strcmp(tag, &quot;420MPEG2&quot;)) chroma = Y4M_CHROMA_420MPEG2;
+  else if (!strcmp(tag, &quot;420PALDV&quot;)) chroma = Y4M_CHROMA_420PALDV;
+  else if (!strcmp(tag, &quot;420JPEG&quot;))  chroma = Y4M_CHROMA_420JPEG;
+  else if (!strcmp(tag, &quot;444&quot;))      chroma = Y4M_CHROMA_444;
+  else chroma = Y4M_UNKNOWN;
+  /* Remove the 'X' tag so that no one has to worry about it any more. */
+  y4m_xtag_remove(xtags, n);
+  /* Hmm... what if there are more XYSCSS tags?  Broken is as broken does;
+     thank goodness this is temporary code. */
+  return chroma;
+}
+
+
+
+
+int y4m_parse_stream_tags(char *s, y4m_stream_info_t *i)
+{
+  char *token, *value;
+  char tag;
+  int err;
+
+  /* parse fields */
+  for (token = strtok(s, Y4M_DELIM); 
+       token != NULL; 
+       token = strtok(NULL, Y4M_DELIM)) {
+    if (token[0] == '\0') continue;   /* skip empty strings */
+    tag = token[0];
+    value = token + 1;
+    switch (tag) {
+    case 'W':  /* width */
+      i-&gt;width = atoi(value);
+      if (i-&gt;width &lt;= 0) return Y4M_ERR_RANGE;
+      break;
+    case 'H':  /* height */
+      i-&gt;height = atoi(value); 
+      if (i-&gt;height &lt;= 0) return Y4M_ERR_RANGE;
+      break;
+    case 'F':  /* frame rate (fps) */
+      if ((err = y4m_parse_ratio(&amp;(i-&gt;framerate), value)) != Y4M_OK)
+	return err;
+      if (i-&gt;framerate.n &lt; 0) return Y4M_ERR_RANGE;
+      break;
+    case 'I':  /* interlacing */
+      switch (value[0]) {
+      case 'p':  i-&gt;interlace = Y4M_ILACE_NONE; break;
+      case 't':  i-&gt;interlace = Y4M_ILACE_TOP_FIRST; break;
+      case 'b':  i-&gt;interlace = Y4M_ILACE_BOTTOM_FIRST; break;
+      case 'm':  i-&gt;interlace = Y4M_ILACE_MIXED; break;
+      case '?':
+      default:
+	i-&gt;interlace = Y4M_UNKNOWN; break;
+      }
+      break;
+    case 'A':  /* sample (pixel) aspect ratio */
+      if ((err = y4m_parse_ratio(&amp;(i-&gt;sampleaspect), value)) != Y4M_OK)
+	return err;
+      if (i-&gt;sampleaspect.n &lt; 0) return Y4M_ERR_RANGE;
+      break;
+    case 'C':
+      i-&gt;chroma = y4m_chroma_parse_keyword(value);
+      if (i-&gt;chroma == Y4M_UNKNOWN)
+	return Y4M_ERR_HEADER;
+      break;
+    case 'X':  /* 'X' meta-tag */
+      if ((err = y4m_xtag_add(&amp;(i-&gt;x_tags), token)) != Y4M_OK) return err;
+      break;
+    default:
+      /* possible error on unknown options */
+      if (_y4mparam_allow_unknown_tags) {
+	/* unknown tags ok:  store in xtag list and warn... */
+	if ((err = y4m_xtag_add(&amp;(i-&gt;x_tags), token)) != Y4M_OK) return err;
+	mjpeg_warn(&quot;Unknown stream tag encountered:  '%s'&quot;, token);
+      } else {
+	/* unknown tags are *not* ok */
+	return Y4M_ERR_BADTAG;
+      }
+      break;
+    }
+  }
+
+  /* If feature_level &gt; 0, then handle and/or remove any old-style XYSCSS
+     chroma tags.  The new-style 'C' tag takes precedence, however. */
+  if (_y4mparam_feature_level &gt; 0) {
+    int xt_chroma = handle_old_chroma_xtag(i);
+
+    if (i-&gt;chroma == Y4M_UNKNOWN)
+      i-&gt;chroma = xt_chroma;
+    else if ((xt_chroma != Y4M_UNKNOWN) &amp;&amp;
+             (xt_chroma != i-&gt;chroma))
+      mjpeg_warn(&quot;Old chroma X-tag (ignored) does not match new chroma tag.&quot;);
+  }
+
+  /* Without 'C' tag or any other chroma spec, default to 420jpeg */
+  if (i-&gt;chroma == Y4M_UNKNOWN) 
+    i-&gt;chroma = Y4M_CHROMA_420JPEG;
+
+  /* Error checking... */
+  /*      - Width and Height are required. */
+  if ((i-&gt;width == Y4M_UNKNOWN) || (i-&gt;height == Y4M_UNKNOWN))
+    return Y4M_ERR_HEADER;
+  /*      - Non-420 chroma and mixed interlace require level &gt;= 1 */
+  if (_y4mparam_feature_level &lt; 1) {
+    if ((i-&gt;chroma != Y4M_CHROMA_420JPEG) &amp;&amp;
+	(i-&gt;chroma != Y4M_CHROMA_420MPEG2) &amp;&amp;
+	(i-&gt;chroma != Y4M_CHROMA_420PALDV))
+      return Y4M_ERR_FEATURE;
+    if (i-&gt;interlace == Y4M_ILACE_MIXED)
+      return Y4M_ERR_FEATURE;
+  }
+
+  /* ta da!  done. */
+  return Y4M_OK;
+}
+
+
+
+static int y4m_parse_frame_tags(char *s, const y4m_stream_info_t *si,
+				y4m_frame_info_t *fi)
+{
+  char *token, *value;
+  char tag;
+  int err;
+
+  /* parse fields */
+  for (token = strtok(s, Y4M_DELIM); 
+       token != NULL; 
+       token = strtok(NULL, Y4M_DELIM)) {
+    if (token[0] == '\0') continue;   /* skip empty strings */
+    tag = token[0];
+    value = token + 1;
+    switch (tag) {
+    case 'I':
+      /* frame 'I' tag requires feature level &gt;= 1 */
+      if (_y4mparam_feature_level &lt; 1) return Y4M_ERR_FEATURE;
+      if (si-&gt;interlace != Y4M_ILACE_MIXED) return Y4M_ERR_BADTAG;
+      switch (value[0]) {
+      case 't':  fi-&gt;presentation = Y4M_PRESENT_TOP_FIRST;        break;
+      case 'T':  fi-&gt;presentation = Y4M_PRESENT_TOP_FIRST_RPT;    break;
+      case 'b':  fi-&gt;presentation = Y4M_PRESENT_BOTTOM_FIRST;     break;
+      case 'B':  fi-&gt;presentation = Y4M_PRESENT_BOTTOM_FIRST_RPT; break;
+      case '1':  fi-&gt;presentation = Y4M_PRESENT_PROG_SINGLE;      break;
+      case '2':  fi-&gt;presentation = Y4M_PRESENT_PROG_DOUBLE;      break;
+      case '3':  fi-&gt;presentation = Y4M_PRESENT_PROG_TRIPLE;      break;
+      default: 
+	return Y4M_ERR_BADTAG;
+      }
+      switch (value[1]) {
+      case 'p':  fi-&gt;temporal = Y4M_SAMPLING_PROGRESSIVE; break;
+      case 'i':  fi-&gt;temporal = Y4M_SAMPLING_INTERLACED;  break;
+      default: 
+	return Y4M_ERR_BADTAG;
+      }
+      switch (value[2]) {
+      case 'p':  fi-&gt;spatial = Y4M_SAMPLING_PROGRESSIVE; break;
+      case 'i':  fi-&gt;spatial = Y4M_SAMPLING_INTERLACED;  break;
+      case '?':  fi-&gt;spatial = Y4M_UNKNOWN;              break;
+      default: 
+	return Y4M_ERR_BADTAG;
+      }
+      break;
+    case 'X':  /* 'X' meta-tag */
+      if ((err = y4m_xtag_add(&amp;(fi-&gt;x_tags), token)) != Y4M_OK) return err;
+      break;
+    default:
+      /* possible error on unknown options */
+      if (_y4mparam_allow_unknown_tags) {
+	/* unknown tags ok:  store in xtag list and warn... */
+	if ((err = y4m_xtag_add(&amp;(fi-&gt;x_tags), token)) != Y4M_OK) return err;
+	mjpeg_warn(&quot;Unknown frame tag encountered:  '%s'&quot;, token);
+      } else {
+	/* unknown tags are *not* ok */
+	return Y4M_ERR_BADTAG;
+      }
+      break;
+    }
+  }
+  /* error-checking and/or non-mixed defaults */
+  switch (si-&gt;interlace) {
+  case Y4M_ILACE_MIXED:
+    /* T and P are required if stream &quot;Im&quot; */
+    if ((fi-&gt;presentation == Y4M_UNKNOWN) || (fi-&gt;temporal == Y4M_UNKNOWN))
+      return Y4M_ERR_HEADER;
+    /* and S is required if stream is also 4:2:0 */
+    if ( ((si-&gt;chroma == Y4M_CHROMA_420JPEG) ||
+          (si-&gt;chroma == Y4M_CHROMA_420MPEG2) ||
+          (si-&gt;chroma == Y4M_CHROMA_420PALDV)) &amp;&amp;
+         (fi-&gt;spatial == Y4M_UNKNOWN) )
+      return Y4M_ERR_HEADER;
+    break;
+  case Y4M_ILACE_NONE:
+    /* stream &quot;Ip&quot; --&gt; equivalent to frame &quot;I1pp&quot; */
+    fi-&gt;spatial = Y4M_SAMPLING_PROGRESSIVE;
+    fi-&gt;temporal = Y4M_SAMPLING_PROGRESSIVE;
+    fi-&gt;presentation = Y4M_PRESENT_PROG_SINGLE;
+    break;
+  case Y4M_ILACE_TOP_FIRST:
+    /* stream &quot;It&quot; --&gt; equivalent to frame &quot;Itii&quot; */
+    fi-&gt;spatial = Y4M_SAMPLING_INTERLACED;
+    fi-&gt;temporal = Y4M_SAMPLING_INTERLACED;
+    fi-&gt;presentation = Y4M_PRESENT_TOP_FIRST;
+    break;
+  case Y4M_ILACE_BOTTOM_FIRST:
+    /* stream &quot;Ib&quot; --&gt; equivalent to frame &quot;Ibii&quot; */
+    fi-&gt;spatial = Y4M_SAMPLING_INTERLACED;
+    fi-&gt;temporal = Y4M_SAMPLING_INTERLACED;
+    fi-&gt;presentation = Y4M_PRESENT_BOTTOM_FIRST;
+    break;
+  default:
+    /* stream unknown:  then, whatever */
+    break;
+  }
+  /* ta da!  done. */
+  return Y4M_OK;
+}
+
+
+
+
+
+/*************************************************************************
+ *
+ * Read/Write stream header
+ *
+ *************************************************************************/
+
+
+int y4m_read_stream_header(int fd, y4m_stream_info_t *i)
+{
+   char line[Y4M_LINE_MAX];
+   char *p;
+   int n;
+   int err;
+
+  /* start with a clean slate */
+  y4m_clear_stream_info(i);
+   /* read the header line */
+   for (n = 0, p = line; n &lt; Y4M_LINE_MAX; n++, p++) {
+     if (read(fd, p, 1) &lt; 1) 
+       return Y4M_ERR_SYSTEM;
+     if (*p == '\n') {
+       *p = '\0';           /* Replace linefeed by end of string */
+       break;
+     }
+   }
+   if (n &gt;= Y4M_LINE_MAX)
+      return Y4M_ERR_HEADER;
+   /* look for keyword in header */
+   if (strncmp(line, Y4M_MAGIC, strlen(Y4M_MAGIC)))
+    return Y4M_ERR_MAGIC;
+   if ((err = y4m_parse_stream_tags(line + strlen(Y4M_MAGIC), i)) != Y4M_OK)
+     return err;
+
+   return Y4M_OK;
+}
+
+
+
+int y4m_write_stream_header(int fd, const y4m_stream_info_t *i)
+{
+  char s[Y4M_LINE_MAX+1];
+  int n;
+  int err;
+  y4m_ratio_t rate = i-&gt;framerate;
+  y4m_ratio_t aspect = i-&gt;sampleaspect;
+  const char *chroma_keyword = y4m_chroma_keyword(i-&gt;chroma);
+
+  if ((i-&gt;chroma == Y4M_UNKNOWN) || (chroma_keyword == NULL))
+    return Y4M_ERR_HEADER;
+  if (_y4mparam_feature_level &lt; 1) {
+    if ((i-&gt;chroma != Y4M_CHROMA_420JPEG) &amp;&amp;
+	(i-&gt;chroma != Y4M_CHROMA_420MPEG2) &amp;&amp;
+	(i-&gt;chroma != Y4M_CHROMA_420PALDV))
+      return Y4M_ERR_FEATURE;
+    if (i-&gt;interlace == Y4M_ILACE_MIXED)
+      return Y4M_ERR_FEATURE;
+  }
+  y4m_ratio_reduce(&amp;rate);
+  y4m_ratio_reduce(&amp;aspect);
+  n = snprintf(s, sizeof(s), &quot;%s W%d H%d F%d:%d I%s A%d:%d C%s&quot;,
+	       Y4M_MAGIC,
+	       i-&gt;width,
+	       i-&gt;height,
+	       rate.n, rate.d,
+	       (i-&gt;interlace == Y4M_ILACE_NONE) ? &quot;p&quot; :
+	       (i-&gt;interlace == Y4M_ILACE_TOP_FIRST) ? &quot;t&quot; :
+	       (i-&gt;interlace == Y4M_ILACE_BOTTOM_FIRST) ? &quot;b&quot; :
+	       (i-&gt;interlace == Y4M_ILACE_MIXED) ? &quot;m&quot; : &quot;?&quot;,
+	       aspect.n, aspect.d,
+	       chroma_keyword
+	       );
+  if ((n &lt; 0) || (n &gt; Y4M_LINE_MAX)) return Y4M_ERR_HEADER;
+  if ((err = y4m_snprint_xtags(s + n, sizeof(s) - n - 1, &amp;(i-&gt;x_tags))) 
+      != Y4M_OK) 
+    return err;
+  /* non-zero on error */
+  return (y4m_write(fd, s, strlen(s)) ? Y4M_ERR_SYSTEM : Y4M_OK);
+}
+
+
+
+
+
+/*************************************************************************
+ *
+ * Read/Write frame header
+ *
+ *************************************************************************/
+
+int y4m_read_frame_header(int fd,
+			  const y4m_stream_info_t *si,
+			  y4m_frame_info_t *fi)
+{
+  char line[Y4M_LINE_MAX];
+  char *p;
+  int n;
+  ssize_t remain;
+  
+  /* start with a clean slate */
+  y4m_clear_frame_info(fi);
+  /* This is more clever than read_stream_header...
+     Try to read &quot;FRAME\n&quot; all at once, and don't try to parse
+     if nothing else is there...
+  */
+  remain = y4m_read(fd, line, sizeof(Y4M_FRAME_MAGIC)-1+1); /* -'\0', +'\n' */
+  if (remain &lt; 0) return Y4M_ERR_SYSTEM;
+  if (remain &gt; 0) {
+    /* A clean EOF should end exactly at a frame-boundary */
+    if (remain == sizeof(Y4M_FRAME_MAGIC))
+      return Y4M_ERR_EOF;
+    else
+      return Y4M_ERR_BADEOF;
+  }
+  if (strncmp(line, Y4M_FRAME_MAGIC, sizeof(Y4M_FRAME_MAGIC)-1))
+    return Y4M_ERR_MAGIC;
+  if (line[sizeof(Y4M_FRAME_MAGIC)-1] == '\n')
+    return Y4M_OK; /* done -- no tags:  that was the end-of-line. */
+
+  if (line[sizeof(Y4M_FRAME_MAGIC)-1] != Y4M_DELIM[0]) {
+    return Y4M_ERR_MAGIC; /* wasn't a space -- what was it? */
+  }
+
+  /* proceed to get the tags... (overwrite the magic) */
+  for (n = 0, p = line; n &lt; Y4M_LINE_MAX; n++, p++) {
+    if (y4m_read(fd, p, 1))
+      return Y4M_ERR_SYSTEM;
+    if (*p == '\n') {
+      *p = '\0';           /* Replace linefeed by end of string */
+      break;
+    }
+  }
+  if (n &gt;= Y4M_LINE_MAX) return Y4M_ERR_HEADER;
+  /* non-zero on error */
+  return y4m_parse_frame_tags(line, si, fi);
+}
+
+
+int y4m_write_frame_header(int fd,
+			   const y4m_stream_info_t *si,
+			   const y4m_frame_info_t *fi)
+{
+  char s[Y4M_LINE_MAX+1];
+  int n, err;
+
+  if (si-&gt;interlace == Y4M_ILACE_MIXED) {
+    if (_y4mparam_feature_level &lt; 1) return Y4M_ERR_FEATURE;
+    n = snprintf(s, sizeof(s), &quot;%s I%c%c%c&quot;, Y4M_FRAME_MAGIC,
+		 (fi-&gt;presentation == Y4M_PRESENT_TOP_FIRST)        ? 't' :
+		 (fi-&gt;presentation == Y4M_PRESENT_TOP_FIRST_RPT)    ? 'T' :
+		 (fi-&gt;presentation == Y4M_PRESENT_BOTTOM_FIRST)     ? 'b' :
+		 (fi-&gt;presentation == Y4M_PRESENT_BOTTOM_FIRST_RPT) ? 'B' :
+		 (fi-&gt;presentation == Y4M_PRESENT_PROG_SINGLE) ? '1' :
+		 (fi-&gt;presentation == Y4M_PRESENT_PROG_DOUBLE) ? '2' :
+		 (fi-&gt;presentation == Y4M_PRESENT_PROG_TRIPLE) ? '3' :
+		 '?',
+		 (fi-&gt;temporal == Y4M_SAMPLING_PROGRESSIVE) ? 'p' :
+		 (fi-&gt;temporal == Y4M_SAMPLING_INTERLACED)  ? 'i' :
+		 '?',
+		 (fi-&gt;spatial == Y4M_SAMPLING_PROGRESSIVE) ? 'p' :
+		 (fi-&gt;spatial == Y4M_SAMPLING_INTERLACED)  ? 'i' :
+		 '?'
+		 );
+  } else {
+    n = snprintf(s, sizeof(s), &quot;%s&quot;, Y4M_FRAME_MAGIC);
+  }
+  
+  if ((n &lt; 0) || (n &gt; Y4M_LINE_MAX)) return Y4M_ERR_HEADER;
+  if ((err = y4m_snprint_xtags(s + n, sizeof(s) - n - 1, &amp;(fi-&gt;x_tags))) 
+      != Y4M_OK) 
+    return err;
+  /* non-zero on error */
+  return (y4m_write(fd, s, strlen(s)) ? Y4M_ERR_SYSTEM : Y4M_OK);
+}
+
+
+
+/*************************************************************************
+ *
+ * Read/Write entire frame
+ *
+ *************************************************************************/
+
+int y4m_read_frame_data(int fd, const y4m_stream_info_t *si, 
+                        y4m_frame_info_t *fi, uint8_t * const *frame)
+{
+  int planes = y4m_si_get_plane_count(si);
+  int p;
+  
+  /* Read each plane */
+  for (p = 0; p &lt; planes; p++) {
+    int w = y4m_si_get_plane_width(si, p);
+    int h = y4m_si_get_plane_height(si, p);
+    if (y4m_read(fd, frame[p], w*h)) return Y4M_ERR_SYSTEM;
+  }
+  return Y4M_OK;
+}
+
+
+
+int y4m_read_frame(int fd, const y4m_stream_info_t *si, 
+		   y4m_frame_info_t *fi, uint8_t * const *frame)
+{
+  int err;
+  
+  /* Read frame header */
+  if ((err = y4m_read_frame_header(fd, si, fi)) != Y4M_OK) return err;
+  /* Read date */
+  return y4m_read_frame_data(fd, si, fi, frame);
+}
+
+
+
+
+int y4m_write_frame(int fd, const y4m_stream_info_t *si, 
+		    const y4m_frame_info_t *fi, uint8_t * const *frame)
+{
+  int planes = y4m_si_get_plane_count(si);
+  int err, p;
+
+  /* Write frame header */
+  if ((err = y4m_write_frame_header(fd, si, fi)) != Y4M_OK) return err;
+  /* Write each plane */
+  for (p = 0; p &lt; planes; p++) {
+    int w = y4m_si_get_plane_width(si, p);
+    int h = y4m_si_get_plane_height(si, p);
+    if (y4m_write(fd, frame[p], w*h)) return Y4M_ERR_SYSTEM;
+  }
+  return Y4M_OK;
+}
+
+
+
+/*************************************************************************
+ *
+ * Read/Write entire frame, (de)interleaved (to)from two separate fields
+ *
+ *************************************************************************/
+
+
+int y4m_read_fields_data(int fd, const y4m_stream_info_t *si,
+                         y4m_frame_info_t *fi,
+                         uint8_t * const *upper_field, 
+                         uint8_t * const *lower_field)
+{
+  int p;
+  int planes = y4m_si_get_plane_count(si);
+  const int maxrbuf=32*1024;
+  uint8_t *rbuf=_y4m_alloc(maxrbuf);
+  int rbufpos=0,rbuflen=0;
+  
+  /* Read each plane */
+  for (p = 0; p &lt; planes; p++) {
+    uint8_t *dsttop = upper_field[p];
+    uint8_t *dstbot = lower_field[p];
+    int height = y4m_si_get_plane_height(si, p);
+    int width = y4m_si_get_plane_width(si, p);
+    int y;
+    /* alternately read one line into each field */
+    for (y = 0; y &lt; height; y += 2) {
+      if( width*2 &gt;= maxrbuf ) {
+        if (y4m_read(fd, dsttop, width)) goto y4merr;
+        if (y4m_read(fd, dstbot, width)) goto y4merr;
+      } else {
+        if( rbufpos==rbuflen ) {
+          rbuflen=(height-y)*width;
+          if( rbuflen&gt;maxrbuf )
+            rbuflen=maxrbuf-maxrbuf%(2*width);
+          if( y4m_read(fd,rbuf,rbuflen) )
+            goto y4merr;
+          rbufpos=0;
+        }
+            
+        memcpy(dsttop,rbuf+rbufpos,width); rbufpos+=width;
+        memcpy(dstbot,rbuf+rbufpos,width); rbufpos+=width;
+      }
+      dsttop+=width;
+      dstbot+=width;
+    }
+  }
+  _y4m_free(rbuf);
+  return Y4M_OK;
+
+ y4merr:
+  _y4m_free(rbuf);
+  return Y4M_ERR_SYSTEM;
+}
+
+
+int y4m_read_fields(int fd, const y4m_stream_info_t *si, y4m_frame_info_t *fi,
+                    uint8_t * const *upper_field, 
+                    uint8_t * const *lower_field)
+{
+  int err;
+  /* Read frame header */
+  if ((err = y4m_read_frame_header(fd, si, fi)) != Y4M_OK) return err;
+  /* Read data */
+  return y4m_read_fields_data(fd, si, fi, upper_field, lower_field);
+}
+
+
+
+int y4m_write_fields(int fd, const y4m_stream_info_t *si,
+		     const y4m_frame_info_t *fi,
+		     uint8_t * const *upper_field, 
+		     uint8_t * const *lower_field)
+{
+  int p, err;
+  int planes = y4m_si_get_plane_count(si);
+  int numwbuf=0;
+  const int maxwbuf=32*1024;
+  uint8_t *wbuf;
+  
+  /* Write frame header */
+  if ((err = y4m_write_frame_header(fd, si, fi)) != Y4M_OK) return err;
+  /* Write each plane */
+  wbuf=_y4m_alloc(maxwbuf);
+  for (p = 0; p &lt; planes; p++) {
+    uint8_t *srctop = upper_field[p];
+    uint8_t *srcbot = lower_field[p];
+    int height = y4m_si_get_plane_height(si, p);
+    int width = y4m_si_get_plane_width(si, p);
+    int y;
+    /* alternately write one line from each field */
+    for (y = 0; y &lt; height; y += 2) {
+      if( width*2 &gt;= maxwbuf ) {
+        if (y4m_write(fd, srctop, width)) goto y4merr;
+        if (y4m_write(fd, srcbot, width)) goto y4merr;
+      } else {
+        if (numwbuf + 2 * width &gt; maxwbuf) {
+          if(y4m_write(fd, wbuf, numwbuf)) goto y4merr;
+          numwbuf=0;
+        }
+
+        memcpy(wbuf+numwbuf,srctop,width); numwbuf += width;
+        memcpy(wbuf+numwbuf,srcbot,width); numwbuf += width;
+      }
+      srctop  += width;
+      srcbot  += width;
+    }
+  }
+  if( numwbuf )
+    if( y4m_write(fd, wbuf, numwbuf) )
+      goto y4merr;
+  _y4m_free(wbuf);
+  return Y4M_OK;
+
+ y4merr:
+  _y4m_free(wbuf);
+  return Y4M_ERR_SYSTEM;
+}
+
+
+/*************************************************************************
+ *
+ * Handy logging of stream info
+ *
+ *************************************************************************/
+
+void y4m_log_stream_info(log_level_t level, const char *prefix,
+			 const y4m_stream_info_t *i)
+{
+  char s[256];
+
+  snprintf(s, sizeof(s), &quot;  frame size:  &quot;);
+  if (i-&gt;width == Y4M_UNKNOWN)
+    snprintf(s+strlen(s), sizeof(s)-strlen(s), &quot;(?)x&quot;);
+  else
+    snprintf(s+strlen(s), sizeof(s)-strlen(s), &quot;%dx&quot;, i-&gt;width);
+  if (i-&gt;height == Y4M_UNKNOWN)
+    snprintf(s+strlen(s), sizeof(s)-strlen(s), &quot;(?) pixels &quot;);
+  else
+    snprintf(s+strlen(s), sizeof(s)-strlen(s), &quot;%d pixels &quot;, i-&gt;height);
+  {
+    int framelength = y4m_si_get_framelength(i);
+    if (framelength == Y4M_UNKNOWN)
+      snprintf(s+strlen(s), sizeof(s)-strlen(s), &quot;(? bytes)&quot;);
+    else
+      snprintf(s+strlen(s), sizeof(s)-strlen(s), &quot;(%d bytes)&quot;, framelength);
+    mjpeg_log(level, &quot;%s%s&quot;, prefix, s);
+  }
+  {
+    const char *desc = y4m_chroma_description(i-&gt;chroma);
+    if (desc == NULL) desc = &quot;unknown!&quot;;
+    mjpeg_log(level, &quot;%s      chroma:  %s&quot;, prefix, desc);
+  }
+  if ((i-&gt;framerate.n == 0) &amp;&amp; (i-&gt;framerate.d == 0))
+    mjpeg_log(level, &quot;%s  frame rate:  ??? fps&quot;, prefix);
+  else
+    mjpeg_log(level, &quot;%s  frame rate:  %d/%d fps (~%f)&quot;, prefix,
+	      i-&gt;framerate.n, i-&gt;framerate.d, 
+	      (double) i-&gt;framerate.n / (double) i-&gt;framerate.d);
+  mjpeg_log(level, &quot;%s   interlace:  %s&quot;, prefix,
+	  (i-&gt;interlace == Y4M_ILACE_NONE) ? &quot;none/progressive&quot; :
+	  (i-&gt;interlace == Y4M_ILACE_TOP_FIRST) ? &quot;top-field-first&quot; :
+	  (i-&gt;interlace == Y4M_ILACE_BOTTOM_FIRST) ? &quot;bottom-field-first&quot; :
+	  (i-&gt;interlace == Y4M_ILACE_MIXED) ? &quot;mixed-mode&quot; :
+	  &quot;anyone's guess&quot;);
+  if ((i-&gt;sampleaspect.n == 0) &amp;&amp; (i-&gt;sampleaspect.d == 0))
+    mjpeg_log(level, &quot;%ssample aspect ratio:  ?:?&quot;, prefix);
+  else
+    mjpeg_log(level, &quot;%ssample aspect ratio:  %d:%d&quot;, prefix,
+	      i-&gt;sampleaspect.n, i-&gt;sampleaspect.d);
+}
+
+
+/*************************************************************************
+ *
+ * Convert error code to string
+ *
+ *************************************************************************/
+
+const char *y4m_strerr(int err)
+{
+  switch (err) {
+  case Y4M_OK:          return &quot;no error&quot;;
+  case Y4M_ERR_RANGE:   return &quot;parameter out of range&quot;;
+  case Y4M_ERR_SYSTEM:  return &quot;system error (failed read/write)&quot;;
+  case Y4M_ERR_HEADER:  return &quot;bad stream or frame header&quot;;
+  case Y4M_ERR_BADTAG:  return &quot;unknown header tag&quot;;
+  case Y4M_ERR_MAGIC:   return &quot;bad header magic&quot;;
+  case Y4M_ERR_XXTAGS:  return &quot;too many xtags&quot;;
+  case Y4M_ERR_EOF:     return &quot;end-of-file&quot;;
+  case Y4M_ERR_BADEOF:  return &quot;stream ended unexpectedly (EOF)&quot;;
+  case Y4M_ERR_FEATURE: return &quot;stream requires unsupported features&quot;;
+  default: 
+    return &quot;unknown error code&quot;;
+  }
+}
+
+
+/*************************************************************************
+ *
+ * Chroma subsampling stuff
+ *
+ *************************************************************************/
+
+y4m_ratio_t y4m_chroma_ss_x_ratio(int chroma_mode)
+{
+  y4m_ratio_t r;
+  switch (chroma_mode) {
+  case Y4M_CHROMA_444ALPHA:
+  case Y4M_CHROMA_444:
+  case Y4M_CHROMA_MONO:
+    r.n = 1; r.d = 1; break;
+  case Y4M_CHROMA_420JPEG:
+  case Y4M_CHROMA_420MPEG2:
+  case Y4M_CHROMA_420PALDV:
+  case Y4M_CHROMA_422:
+    r.n = 1; r.d = 2; break;
+  case Y4M_CHROMA_411:
+    r.n = 1; r.d = 4; break;
+  default:
+    r.n = 0; r.d = 0;
+  }
+  return r;
+}
+
+y4m_ratio_t y4m_chroma_ss_y_ratio(int chroma_mode)
+{
+  y4m_ratio_t r;
+  switch (chroma_mode) {
+  case Y4M_CHROMA_444ALPHA:
+  case Y4M_CHROMA_444:
+  case Y4M_CHROMA_MONO:
+  case Y4M_CHROMA_422:
+  case Y4M_CHROMA_411:
+    r.n = 1; r.d = 1; break;
+  case Y4M_CHROMA_420JPEG:
+  case Y4M_CHROMA_420MPEG2:
+  case Y4M_CHROMA_420PALDV:
+    r.n = 1; r.d = 2; break;
+  default:
+    r.n = 0; r.d = 0;
+  }
+  return r;
+}
+
+
+#if 0  /* unfinished work here */
+y4m_ratio_t y4m_chroma_ss_x_offset(int chroma_mode, int field, int plane)
+{
+  y4m_ratio_t r;
+  switch (chroma_mode) {
+  case Y4M_CHROMA_444ALPHA:
+  case Y4M_CHROMA_444:
+  case Y4M_CHROMA_MONO:
+  case Y4M_CHROMA_422:
+  case Y4M_CHROMA_411:
+    r.n = 0; r.d = 1; break;
+  case Y4M_CHROMA_420JPEG:
+  case Y4M_CHROMA_420MPEG2:
+  case Y4M_CHROMA_420PALDV:
+    r.n = 1; r.d = 2; break;
+  default:
+    r.n = 0; r.d = 0;
+  }
+  return r;
+}
+
+y4m_ratio_t y4m_chroma_ss_y_offset(int chroma_mode, int field, int plane);
+{
+  y4m_ratio_t r;
+  switch (chroma_mode) {
+  case Y4M_CHROMA_444ALPHA:
+  case Y4M_CHROMA_444:
+  case Y4M_CHROMA_MONO:
+  case Y4M_CHROMA_422:
+  case Y4M_CHROMA_411:
+    r.n = 0; r.d = 1; break;
+  case Y4M_CHROMA_420JPEG:
+  case Y4M_CHROMA_420MPEG2:
+  case Y4M_CHROMA_420PALDV:
+    r.n = 1; r.d = 2; break;
+  default:
+    r.n = 0; r.d = 0;
+  }
+  return r;
+}
+#endif
+
+
+
+int y4m_chroma_parse_keyword(const char *s)
+{
+  if (!strcasecmp(&quot;420jpeg&quot;, s))
+    return Y4M_CHROMA_420JPEG;
+  else if (!strcasecmp(&quot;420mpeg2&quot;, s))
+    return Y4M_CHROMA_420MPEG2;
+  else if (!strcasecmp(&quot;420paldv&quot;, s))
+    return Y4M_CHROMA_420PALDV;
+  else if (!strcasecmp(&quot;444&quot;, s))
+    return Y4M_CHROMA_444;
+  else if (!strcasecmp(&quot;422&quot;, s))
+    return Y4M_CHROMA_422;
+  else if (!strcasecmp(&quot;411&quot;, s))
+    return Y4M_CHROMA_411;
+  else if (!strcasecmp(&quot;mono&quot;, s))
+    return Y4M_CHROMA_MONO;
+  else if (!strcasecmp(&quot;444alpha&quot;, s))
+    return Y4M_CHROMA_444ALPHA;
+  else
+    return Y4M_UNKNOWN;
+}
+
+
+const char *y4m_chroma_keyword(int chroma_mode)
+{
+  switch (chroma_mode) {
+  case Y4M_CHROMA_420JPEG:  return &quot;420jpeg&quot;;
+  case Y4M_CHROMA_420MPEG2: return &quot;420mpeg2&quot;;
+  case Y4M_CHROMA_420PALDV: return &quot;420paldv&quot;;
+  case Y4M_CHROMA_444:      return &quot;444&quot;;
+  case Y4M_CHROMA_422:      return &quot;422&quot;;
+  case Y4M_CHROMA_411:      return &quot;411&quot;;
+  case Y4M_CHROMA_MONO:     return &quot;mono&quot;;
+  case Y4M_CHROMA_444ALPHA: return &quot;444alpha&quot;;
+  default:
+    return NULL;
+  }
+}  
+
+
+const char *y4m_chroma_description(int chroma_mode)
+{           
+  switch (chroma_mode) {
+  case Y4M_CHROMA_420JPEG:  return &quot;4:2:0 JPEG/MPEG-1 (interstitial)&quot;;
+  case Y4M_CHROMA_420MPEG2: return &quot;4:2:0 MPEG-2 (horiz. cositing)&quot;;
+  case Y4M_CHROMA_420PALDV: return &quot;4:2:0 PAL-DV (altern. siting)&quot;;
+  case Y4M_CHROMA_444:      return &quot;4:4:4 (no subsampling)&quot;;
+  case Y4M_CHROMA_422:      return &quot;4:2:2 (horiz. cositing)&quot;;
+  case Y4M_CHROMA_411:      return &quot;4:1:1 (horiz. cositing)&quot;;
+  case Y4M_CHROMA_MONO:     return &quot;luma plane only&quot;;
+  case Y4M_CHROMA_444ALPHA: return &quot;4:4:4 with alpha channel&quot;;
+  default:
+    return NULL;
+  }
+}

Added: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/yuv4mpeg.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/yuv4mpeg.h	2007-08-02 19:57:16 UTC (rev 3468)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/yuv4mpeg.h	2007-08-03 00:04:40 UTC (rev 3469)
@@ -0,0 +1,666 @@
+/*
+ *  yuv4mpeg.h:  Functions for reading and writing &quot;new&quot; YUV4MPEG2 streams.
+ *
+ *               Stream format is described at the end of this file.
+ *
+ *
+ *  Copyright (C) 2004 Matthew J. Marjanovic &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">maddog at mir.com</A>&gt;
+ *
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU General Public License
+ *  as published by the Free Software Foundation; either version 2
+ *  of the License, or (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+#ifndef __YUV4MPEG_H__
+#define __YUV4MPEG_H__
+
+#include &lt;stdlib.h&gt;
+#include &lt;mjpeg_types.h&gt;
+#ifndef _WIN32
+#include &lt;unistd.h&gt;
+#endif
+#include &lt;mjpeg_logging.h&gt;
+
+
+/************************************************************************
+ *  error codes returned by y4m_* functions
+ ************************************************************************/
+#define Y4M_OK          0
+#define Y4M_ERR_RANGE   1  /* argument or tag value out of range */
+#define Y4M_ERR_SYSTEM  2  /* failed system call, check errno */
+#define Y4M_ERR_HEADER  3  /* illegal/malformed header */
+#define Y4M_ERR_BADTAG  4  /* illegal tag character */
+#define Y4M_ERR_MAGIC   5  /* bad header magic */
+#define Y4M_ERR_EOF     6  /* end-of-file (clean) */
+#define Y4M_ERR_XXTAGS  7  /* too many xtags */
+#define Y4M_ERR_BADEOF  8  /* unexpected end-of-file */
+#define Y4M_ERR_FEATURE 9  /* stream requires features beyond allowed level */
+
+
+/* generic 'unknown' value for integer parameters (e.g. interlace, height) */
+#define Y4M_UNKNOWN -1
+
+/************************************************************************
+ * values for the &quot;interlace&quot; parameter [y4m_*_interlace()]
+ ************************************************************************/
+#define Y4M_ILACE_NONE          0   /* non-interlaced, progressive frame */
+#define Y4M_ILACE_TOP_FIRST     1   /* interlaced, top-field first       */
+#define Y4M_ILACE_BOTTOM_FIRST  2   /* interlaced, bottom-field first    */
+#define Y4M_ILACE_MIXED         3   /* mixed, &quot;refer to frame header&quot;    */
+
+/************************************************************************
+ * values for the &quot;chroma&quot; parameter [y4m_*_chroma()]
+ ************************************************************************/
+#define Y4M_CHROMA_420JPEG     0  /* 4:2:0, H/V centered, for JPEG/MPEG-1 */
+#define Y4M_CHROMA_420MPEG2    1  /* 4:2:0, H cosited, for MPEG-2         */
+#define Y4M_CHROMA_420PALDV    2  /* 4:2:0, alternating Cb/Cr, for PAL-DV */
+#define Y4M_CHROMA_444         3  /* 4:4:4, no subsampling, phew.         */
+#define Y4M_CHROMA_422         4  /* 4:2:2, H cosited                     */
+#define Y4M_CHROMA_411         5  /* 4:1:1, H cosited                     */
+#define Y4M_CHROMA_MONO        6  /* luma plane only                      */
+#define Y4M_CHROMA_444ALPHA    7  /* 4:4:4 with an alpha channel          */
+
+/************************************************************************
+ * values for sampling parameters [y4m_*_spatial(), y4m_*_temporal()]
+ ************************************************************************/
+#define Y4M_SAMPLING_PROGRESSIVE 0
+#define Y4M_SAMPLING_INTERLACED  1
+
+/************************************************************************
+ * values for &quot;presentation&quot; parameter [y4m_*_presentation()]
+ ************************************************************************/
+#define Y4M_PRESENT_TOP_FIRST         0  /* top-field-first                 */
+#define Y4M_PRESENT_TOP_FIRST_RPT     1  /* top-first, repeat top           */
+#define Y4M_PRESENT_BOTTOM_FIRST      2  /* bottom-field-first              */
+#define Y4M_PRESENT_BOTTOM_FIRST_RPT  3  /* bottom-first, repeat bottom     */
+#define Y4M_PRESENT_PROG_SINGLE       4  /* single progressive frame        */
+#define Y4M_PRESENT_PROG_DOUBLE       5  /* progressive frame, repeat once  */
+#define Y4M_PRESENT_PROG_TRIPLE       6  /* progressive frame, repeat twice */
+
+#define Y4M_MAX_NUM_PLANES 4
+
+/************************************************************************
+ *  'ratio' datatype, for rational numbers
+ *                                     (see 'ratio' functions down below)
+ ************************************************************************/
+typedef struct _y4m_ratio {
+  int n;  /* numerator   */
+  int d;  /* denominator */
+} y4m_ratio_t;
+
+
+/************************************************************************
+ *  useful standard framerates (as ratios)
+ ************************************************************************/
+extern const y4m_ratio_t y4m_fps_UNKNOWN;
+extern const y4m_ratio_t y4m_fps_NTSC_FILM;  /* 24000/1001 film (in NTSC)  */
+extern const y4m_ratio_t y4m_fps_FILM;       /* 24fps film                 */
+extern const y4m_ratio_t y4m_fps_PAL;        /* 25fps PAL                  */
+extern const y4m_ratio_t y4m_fps_NTSC;       /* 30000/1001 NTSC            */
+extern const y4m_ratio_t y4m_fps_30;         /* 30fps                      */
+extern const y4m_ratio_t y4m_fps_PAL_FIELD;  /* 50fps PAL field rate       */
+extern const y4m_ratio_t y4m_fps_NTSC_FIELD; /* 60000/1001 NTSC field rate */
+extern const y4m_ratio_t y4m_fps_60;         /* 60fps                      */
+
+/************************************************************************
+ *  useful standard sample (pixel) aspect ratios (W:H)
+ ************************************************************************/
+extern const y4m_ratio_t y4m_sar_UNKNOWN; 
+extern const y4m_ratio_t y4m_sar_SQUARE;        /* square pixels */
+extern const y4m_ratio_t y4m_sar_NTSC_CCIR601;  /* 525-line (NTSC) Rec.601 */
+extern const y4m_ratio_t y4m_sar_NTSC_16_9;     /* 16:9 NTSC/Rec.601       */
+extern const y4m_ratio_t y4m_sar_NTSC_SVCD_4_3; /* NTSC SVCD 4:3           */
+extern const y4m_ratio_t y4m_sar_NTSC_SVCD_16_9;/* NTSC SVCD 16:9          */
+extern const y4m_ratio_t y4m_sar_PAL_CCIR601;   /* 625-line (PAL) Rec.601  */
+extern const y4m_ratio_t y4m_sar_PAL_16_9;      /* 16:9 PAL/Rec.601        */
+extern const y4m_ratio_t y4m_sar_PAL_SVCD_4_3;  /* PAL SVCD 4:3            */
+extern const y4m_ratio_t y4m_sar_PAL_SVCD_16_9; /* PAL SVCD 16:9           */
+extern const y4m_ratio_t y4m_sar_SQR_ANA16_9;   /* anamorphic 16:9 sampled */
+                                            /* from 4:3 with square pixels */
+
+/************************************************************************
+ *  useful standard display aspect ratios (W:H)
+ ************************************************************************/
+extern const y4m_ratio_t y4m_dar_UNKNOWN; 
+extern const y4m_ratio_t y4m_dar_4_3;     /* standard TV   */
+extern const y4m_ratio_t y4m_dar_16_9;    /* widescreen TV */
+extern const y4m_ratio_t y4m_dar_221_100; /* word-to-your-mother TV */
+
+
+#define Y4M_MAX_XTAGS 32        /* maximum number of xtags in list       */
+#define Y4M_MAX_XTAG_SIZE 32    /* max length of an xtag (including 'X') */
+
+typedef struct _y4m_xtag_list y4m_xtag_list_t;
+typedef struct _y4m_stream_info y4m_stream_info_t;
+typedef struct _y4m_frame_info y4m_frame_info_t;
+
+
+#ifdef __cplusplus
+#define BEGIN_CDECLS extern &quot;C&quot; {
+#define END_CDECLS   }
+#else
+#define BEGIN_CDECLS 
+#define END_CDECLS   
+#endif
+
+BEGIN_CDECLS
+
+/************************************************************************
+ *  'ratio' functions
+ ************************************************************************/
+
+/* 'normalize' a ratio (remove common factors) */
+void y4m_ratio_reduce(y4m_ratio_t *r);
+
+/* parse &quot;nnn:ddd&quot; into a ratio (returns Y4M_OK or Y4M_ERR_RANGE) */
+int y4m_parse_ratio(y4m_ratio_t *r, const char *s);
+
+/* quick test of two ratios for equality (i.e. identical components) */
+#define Y4M_RATIO_EQL(a,b) ( ((a).n == (b).n) &amp;&amp; ((a).d == (b).d) )
+
+/* quick conversion of a ratio to a double (no divide-by-zero check!) */
+#define Y4M_RATIO_DBL(r) ((double)(r).n / (double)(r).d)
+
+/*************************************************************************
+ *
+ * Guess the true SAR (sample aspect ratio) from a list of commonly 
+ * encountered values, given the &quot;suggested&quot; display aspect ratio (DAR),
+ * and the true frame width and height.
+ *
+ * Returns y4m_sar_UNKNOWN if no match is found.
+ *
+ *************************************************************************/
+y4m_ratio_t y4m_guess_sar(int width, int height, y4m_ratio_t dar);
+
+
+/*************************************************************************
+ *
+ * Chroma Subsampling Mode information
+ *
+ *  x_ratio, y_ratio  -  subsampling of chroma planes
+ *  x_offset, y_offset - offset of chroma sample grid,
+ *                        relative to luma (0,0) sample
+ *
+ *************************************************************************/
+
+y4m_ratio_t y4m_chroma_ss_x_ratio(int chroma_mode);
+y4m_ratio_t y4m_chroma_ss_y_ratio(int chroma_mode);
+#if 0
+y4m_ratio_t y4m_chroma_ss_x_offset(int chroma_mode, int field, int plane);
+y4m_ratio_t y4m_chroma_ss_y_offset(int chroma_mode, int field, int plane);
+#endif
+
+/* Given a string containing a (case-insensitive) chroma-tag keyword,
+   return appropriate chroma mode (or Y4M_UNKNOWN) */
+int y4m_chroma_parse_keyword(const char *s);
+
+/* Given a Y4M_CHROMA_* mode, return appropriate chroma-tag keyword,
+   or NULL if there is none. */
+const char *y4m_chroma_keyword(int chroma_mode);
+
+/* Given a Y4M_CHROMA_* mode, return appropriate chroma mode description,
+   or NULL if there is none. */
+const char *y4m_chroma_description(int chroma_mode);
+
+
+
+/************************************************************************
+ *  'xtag' functions
+ *
+ * o Before using an xtag_list (but after the structure/memory has been
+ *    allocated), you must initialize it via y4m_init_xtag_list().
+ * o After using an xtag_list (but before the structure is released),
+ *    call y4m_fini_xtag_list() to free internal memory.
+ *
+ ************************************************************************/
+
+/* initialize an xtag_list structure */
+void y4m_init_xtag_list(y4m_xtag_list_t *xtags);
+
+/* finalize an xtag_list structure */
+void y4m_fini_xtag_list(y4m_xtag_list_t *xtags);
+
+/* make one xtag_list into a copy of another */
+void y4m_copy_xtag_list(y4m_xtag_list_t *dest, const y4m_xtag_list_t *src);
+
+/* return number of tags in an xtag_list */
+int y4m_xtag_count(const y4m_xtag_list_t *xtags);
+
+/* access n'th tag in an xtag_list */
+const char *y4m_xtag_get(const y4m_xtag_list_t *xtags, int n);
+
+/* append a new tag to an xtag_list
+    returns:          Y4M_OK - success
+              Y4M_ERR_XXTAGS - list is already full */
+int y4m_xtag_add(y4m_xtag_list_t *xtags, const char *tag);
+
+/* remove a tag from an xtag_list 
+    returns:         Y4M_OK - success
+              Y4M_ERR_RANGE - n is out of range */
+int y4m_xtag_remove(y4m_xtag_list_t *xtags, int n);
+
+/* remove all tags from an xtag_list 
+    returns:   Y4M_OK - success       */
+int y4m_xtag_clearlist(y4m_xtag_list_t *xtags);
+
+/* append copies of tags from src list to dest list
+    returns:          Y4M_OK - success
+              Y4M_ERR_XXTAGS - operation would overfill dest list */
+int y4m_xtag_addlist(y4m_xtag_list_t *dest, const y4m_xtag_list_t *src);
+
+
+
+/************************************************************************
+ *  '*_info' functions
+ *
+ * o Before using a *_info structure (but after the structure/memory has
+ *    been allocated), you must initialize it via y4m_init_*_info().
+ * o After using a *_info structure (but before the structure is released),
+ *    call y4m_fini_*_info() to free internal memory.
+ * o Use the 'set' and 'get' accessors to modify or access the fields in
+ *    the structures; don't touch the structure directly.  (Ok, so there
+ *    is no really convenient C syntax to prevent you from doing this,
+ *    but we are all responsible programmers here, so just don't do it!)
+ *
+ ************************************************************************/
+
+/* initialize a stream_info structure */
+void y4m_init_stream_info(y4m_stream_info_t *i);
+
+/* finalize a stream_info structure */
+void y4m_fini_stream_info(y4m_stream_info_t *i);
+
+/* reset stream_info back to default/unknown values */
+void y4m_clear_stream_info(y4m_stream_info_t *info);
+
+/* make one stream_info into a copy of another */
+void y4m_copy_stream_info(y4m_stream_info_t *dest,
+			  const y4m_stream_info_t *src);
+
+/* access or set stream_info fields */
+/*      level 0                   */
+int y4m_si_get_width(const y4m_stream_info_t *si);
+int y4m_si_get_height(const y4m_stream_info_t *si);
+int y4m_si_get_interlace(const y4m_stream_info_t *si);
+y4m_ratio_t y4m_si_get_framerate(const y4m_stream_info_t *si);
+y4m_ratio_t y4m_si_get_sampleaspect(const y4m_stream_info_t *si);
+void y4m_si_set_width(y4m_stream_info_t *si, int width);
+void y4m_si_set_height(y4m_stream_info_t *si, int height);
+void y4m_si_set_interlace(y4m_stream_info_t *si, int interlace);
+void y4m_si_set_framerate(y4m_stream_info_t *si, y4m_ratio_t framerate);
+void y4m_si_set_sampleaspect(y4m_stream_info_t *si, y4m_ratio_t sar);
+/*      level 1                   */
+void y4m_si_set_chroma(y4m_stream_info_t *si, int chroma_mode);
+int y4m_si_get_chroma(const y4m_stream_info_t *si);
+
+/* derived quantities (no setter) */
+/*      level 0                   */
+int y4m_si_get_framelength(const y4m_stream_info_t *si);
+/*      level 1                   */
+int y4m_si_get_plane_count(const y4m_stream_info_t *si);
+int y4m_si_get_plane_width(const y4m_stream_info_t *si, int plane);
+int y4m_si_get_plane_height(const y4m_stream_info_t *si, int plane);
+int y4m_si_get_plane_length(const y4m_stream_info_t *si, int plane);
+
+
+/* access stream_info xtag_list */
+y4m_xtag_list_t *y4m_si_xtags(y4m_stream_info_t *si);
+
+
+/* initialize a frame_info structure */
+void y4m_init_frame_info(y4m_frame_info_t *i);
+
+/* finalize a frame_info structure */
+void y4m_fini_frame_info(y4m_frame_info_t *i);
+
+/* reset frame_info back to default/unknown values */
+void y4m_clear_frame_info(y4m_frame_info_t *info);
+
+/* make one frame_info into a copy of another */
+void y4m_copy_frame_info(y4m_frame_info_t *dest,
+			 const y4m_frame_info_t *src);
+
+
+/* access or set frame_info fields (level 1) */
+int y4m_fi_get_presentation(const y4m_frame_info_t *fi);
+int y4m_fi_get_temporal(const y4m_frame_info_t *fi);
+int y4m_fi_get_spatial(const y4m_frame_info_t *fi);
+
+void y4m_fi_set_presentation(y4m_frame_info_t *fi, int pres);
+void y4m_fi_set_temporal(y4m_frame_info_t *fi, int sampling);
+void y4m_fi_set_spatial(y4m_frame_info_t *fi, int sampling);
+
+
+/* access frame_info xtag_list */
+y4m_xtag_list_t *y4m_fi_xtags(y4m_frame_info_t *fi);
+
+
+
+/************************************************************************
+ *  blocking read and write functions
+ *
+ *  o guaranteed to transfer entire payload (or fail)
+ *  o return values:
+ *                         0 (zero)   complete success
+ *          -(# of remaining bytes)   error (and errno left set)
+ *          +(# of remaining bytes)   EOF (for y4m_read only)
+ *
+ ************************************************************************/
+
+/* read len bytes from fd into buf */
+ssize_t y4m_read(int fd, void *buf, size_t len);
+
+/* write len bytes from fd into buf */
+ssize_t y4m_write(int fd, const void *buf, size_t len);
+
+
+
+/************************************************************************
+ *  stream header processing functions
+ *  
+ *  o return values:
+ *                   Y4M_OK - success
+ *                Y4M_ERR_* - error (see y4m_strerr() for descriptions)
+ *
+ ************************************************************************/
+
+/* parse a string of stream header tags */
+int y4m_parse_stream_tags(char *s, y4m_stream_info_t *i);
+
+/* read a stream header from file descriptor fd
+   (the current contents of stream_info are erased first) */
+int y4m_read_stream_header(int fd, y4m_stream_info_t *i);
+
+/* write a stream header to file descriptor fd */
+int y4m_write_stream_header(int fd, const y4m_stream_info_t *i);
+
+
+
+/************************************************************************
+ *  frame processing functions
+ *  
+ *  o return values:
+ *                   Y4M_OK - success
+ *                Y4M_ERR_* - error (see y4m_strerr() for descriptions)
+ *
+ ************************************************************************/
+
+/* write a frame header to file descriptor fd */
+int y4m_write_frame_header(int fd,
+			   const y4m_stream_info_t *si,
+			   const y4m_frame_info_t *fi);
+
+/* write a complete frame (header + data)
+   o planes[] points to 1-4 buffers, one each for image plane */
+int y4m_write_frame(int fd, const y4m_stream_info_t *si, 
+		    const y4m_frame_info_t *fi, uint8_t * const *planes);
+
+
+/* write a complete frame (header + data), but interleave fields
+    from two separate buffers
+   o upper_field[] same as planes[] above, but for upper field only
+   o lower_field[] same as planes[] above, but for lower field only
+*/
+int y4m_write_fields(int fd, const y4m_stream_info_t *si, 
+		     const y4m_frame_info_t *fi,
+		     uint8_t * const *upper_field, 
+		     uint8_t * const *lower_field);
+
+
+/* read a frame header from file descriptor fd 
+   (the current contents of frame_info are erased first) */
+int y4m_read_frame_header(int fd,
+			  const y4m_stream_info_t *si,
+			  y4m_frame_info_t *fi);
+
+/* read frame data [to be called after y4m_read_frame_header()]
+   o planes[] points to 1-4 buffers, one each for image plane */
+int y4m_read_frame_data(int fd, const y4m_stream_info_t *si, 
+                        y4m_frame_info_t *fi, uint8_t * const *planes);
+
+/* read frame data, but de-interleave fields into two separate buffers
+    [to be called after y4m_read_frame_header()]
+   o upper_field[] same as planes[] above, but for upper field only
+   o lower_field[] same as planes[] above, but for lower field only
+*/
+int y4m_read_fields_data(int fd, const y4m_stream_info_t *si, 
+                         y4m_frame_info_t *fi,
+                         uint8_t * const *upper_field, 
+                         uint8_t * const *lower_field);
+
+/* read a complete frame (header + data)
+   o planes[] points to 1-4 buffers, one each for image plane */
+int y4m_read_frame(int fd, const y4m_stream_info_t *si, 
+		   y4m_frame_info_t *fi, uint8_t * const *planes);
+
+/* read a complete frame (header + data), but de-interleave fields
+    into two separate buffers
+   o upper_field[] same as planes[] above, but for upper field only
+   o lower_field[] same as planes[] above, but for lower field only
+*/
+int y4m_read_fields(int fd, const y4m_stream_info_t *si, 
+		    y4m_frame_info_t *fi,
+		    uint8_t * const *upper_field, 
+		    uint8_t * const *lower_field);
+
+
+/************************************************************************
+ *  miscellaneous functions
+ ************************************************************************/
+
+/* convenient dump of stream header info via mjpeg_log facility
+ *  - each logged/printed line is prefixed by 'prefix'
+ */
+void y4m_log_stream_info(log_level_t level, const char *prefix,
+			 const y4m_stream_info_t *i);
+
+/* convert a Y4M_ERR_* error code into mildly explanatory string */
+const char *y4m_strerr(int err);
+
+/* set 'allow_unknown_tag' flag for library...
+    o yn = 0 :  unknown header tags will produce a parsing error
+    o yn = 1 :  unknown header tags/values will produce a warning, but
+                 are otherwise passed along via the xtags list
+    o yn = -1:  don't change, just return current setting
+
+   return value:  previous setting of flag
+*/
+int y4m_allow_unknown_tags(int yn);
+
+
+/* set level of &quot;accepted extensions&quot; for the library...
+    o level = 0:  default - conform to original YUV4MPEG2 spec; yield errors
+                   when reading or writing a stream which exceeds it.
+    o level = 1:  allow reading/writing streams which contain non-420jpeg
+                   chroma and/or mixed-mode interlacing
+    o level = -1: don't change, just return current setting
+
+   return value:  previous setting of level
+ */
+int y4m_accept_extensions(int level);
+
+
+END_CDECLS
+
+
+/************************************************************************
+ ************************************************************************
+
+  Description of the (new!, forever?) YUV4MPEG2 stream format:
+
+  STREAM consists of
+    o one '\n' terminated STREAM-HEADER
+    o unlimited number of FRAMEs
+
+  FRAME consists of
+    o one '\n' terminated FRAME-HEADER
+    o &quot;length&quot; octets of planar YCrCb 4:2:0 image data
+        (if frame is interlaced, then the two fields are interleaved)
+
+
+  STREAM-HEADER consists of
+     o string &quot;YUV4MPEG2&quot;
+     o unlimited number TAGGED-FIELDs, each preceded by ' ' separator
+     o '\n' line terminator
+
+  FRAME-HEADER consists of
+     o string &quot;FRAME&quot;
+     o unlimited number of TAGGED-FIELDs, each preceded by ' ' separator
+     o '\n' line terminator
+
+
+  TAGGED-FIELD consists of
+     o single ascii character tag
+     o VALUE (which does not contain whitespace)
+
+  VALUE consists of
+     o integer (base 10 ascii representation)
+  or o RATIO
+  or o single ascii character
+  or o non-whitespace ascii string
+
+  RATIO consists of
+     o numerator (integer)
+     o ':' (a colon)
+     o denominator (integer)
+
+
+  The currently supported tags for the STREAM-HEADER:
+     W - [integer] frame width, pixels, should be &gt; 0
+     H - [integer] frame height, pixels, should be &gt; 0
+     C - [string]  chroma-subsampling/data format
+           420jpeg   (default)
+           420mpeg2
+           420paldv
+           411
+           422
+           444       - non-subsampled Y'CbCr
+	   444alpha  - Y'CbCr with alpha channel (with Y' black/white point)
+           mono      - Y' plane only
+     I - [char] interlacing:  p - progressive (none)
+                              t - top-field-first
+                              b - bottom-field-first
+                              m - mixed -- see 'I' tag in frame header
+                              ? - unknown
+     F - [ratio] frame-rate, 0:0 == unknown
+     A - [ratio] sample (pixel) aspect ratio, 0:0 == unknown
+     X - [character string] 'metadata' (unparsed, but passed around)
+
+  The currently supported tags for the FRAME-HEADER:
+     Ixyz - framing/sampling (required if-and-only-if stream is &quot;Im&quot;)
+          x:  t - top-field-first
+              T - top-field-first and repeat
+	      b - bottom-field-first
+              B - bottom-field-first and repeat
+              1 - single progressive frame
+              2 - double progressive frame (repeat)
+              3 - triple progressive frame (repeat twice)
+
+          y:  p - progressive:  fields sampled at same time
+              i - interlaced:   fields sampled at different times
+
+          z:  p - progressive:  subsampling over whole frame
+              i - interlaced:   each field subsampled independently
+              ? - unknown (allowed only for non-4:2:0 subsampling)           
+       
+     X - character string 'metadata' (unparsed, but passed around)
+
+ ************************************************************************
+ ************************************************************************/
+
+
+/*
+
+   THAT'S ALL FOLKS!
+
+   Thank you for reading the source code.  We hope you have thoroughly
+   enjoyed the experience.
+
+*/
+
+
+
+
+
+#ifdef INTERNAL_Y4M_LIBCODE_STUFF_QPX
+#define Y4MPRIVATIZE(identifier) identifier
+#else
+#define Y4MPRIVATIZE(identifier) PRIVATE##identifier
+#endif
+
+/* 
+ * Actual structure definitions of structures which you shouldn't touch.
+ *
+ */
+
+/************************************************************************
+ *  'xtag_list' --- list of unparsed and/or meta/X header tags
+ *
+ *     Do not touch this structure directly!
+ *
+ *     Use the y4m_xtag_*() functions (see below).
+ *     You must initialize/finalize this structure before/after use.
+ ************************************************************************/
+struct _y4m_xtag_list {
+  int Y4MPRIVATIZE(count);
+  char *Y4MPRIVATIZE(tags)[Y4M_MAX_XTAGS];
+};
+
+
+/************************************************************************
+ *  'stream_info' --- stream header information
+ *
+ *     Do not touch this structure directly!
+ *
+ *     Use the y4m_si_*() functions (see below).
+ *     You must initialize/finalize this structure before/after use.
+ ************************************************************************/
+struct _y4m_stream_info {
+  /* values from header/setters */
+  int Y4MPRIVATIZE(width);
+  int Y4MPRIVATIZE(height);
+  int Y4MPRIVATIZE(interlace);            /* see Y4M_ILACE_* definitions  */
+  y4m_ratio_t Y4MPRIVATIZE(framerate);    /* see Y4M_FPS_* definitions    */
+  y4m_ratio_t Y4MPRIVATIZE(sampleaspect); /* see Y4M_SAR_* definitions    */
+  int Y4MPRIVATIZE(chroma);               /* see Y4M_CHROMA_* definitions */
+
+  /* mystical X tags */
+  y4m_xtag_list_t Y4MPRIVATIZE(x_tags);
+};
+
+
+/************************************************************************
+ *  'frame_info' --- frame header information
+ *
+ *     Do not touch this structure directly!
+ *
+ *     Use the y4m_fi_*() functions (see below).
+ *     You must initialize/finalize this structure before/after use.
+ ************************************************************************/
+
+struct _y4m_frame_info {
+  int Y4MPRIVATIZE(spatial);      /* see Y4M_SAMPLING_* definitions */
+  int Y4MPRIVATIZE(temporal);     /* see Y4M_SAMPLING_* definitions */
+  int Y4MPRIVATIZE(presentation); /* see Y4M_PRESENT_* definitions  */
+  /* mystical X tags */
+  y4m_xtag_list_t Y4MPRIVATIZE(x_tags);
+};
+
+
+#undef Y4MPRIVATIZE
+
+
+#endif /* __YUV4MPEG_H__ */
+
+

Added: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/yuv4mpeg_intern.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/yuv4mpeg_intern.h	2007-08-02 19:57:16 UTC (rev 3468)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/yuv4mpeg_intern.h	2007-08-03 00:04:40 UTC (rev 3469)
@@ -0,0 +1,85 @@
+/*
+ *  yuv4mpeg_intern.h:  Internal constants for &quot;new&quot; YUV4MPEG streams
+ *
+ *  Copyright (C) 2001 Andrew Stevens &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">andrew.stevens at philips.com</A>&gt;
+ *  Copyright (C) 2001 Matthew J. Marjanovic &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">maddog at mir.com</A>&gt;
+ *
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of version 2 of the GNU General Public License
+ *  as published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+#ifndef __YUV4MPEG_INTERN_H__
+#define __YUV4MPEG_INTERN_H__
+
+
+#define Y4M_MAGIC &quot;YUV4MPEG2&quot;
+#define Y4M_FRAME_MAGIC &quot;FRAME&quot;
+
+#define Y4M_DELIM &quot; &quot;  /* single-character(space) separating tagged fields */
+
+#define Y4M_LINE_MAX 256   /* max number of characters in a header line
+                               (including the '\n', but not the '\0') */
+
+
+/* standard framerate ratios */
+#define Y4M_FPS_UNKNOWN    { 0, 0 }
+#define Y4M_FPS_NTSC_FILM  { 24000, 1001 }
+#define Y4M_FPS_FILM       { 24, 1 }
+#define Y4M_FPS_PAL        { 25, 1 }
+#define Y4M_FPS_NTSC       { 30000, 1001 }
+#define Y4M_FPS_30         { 30, 1 }
+#define Y4M_FPS_PAL_FIELD  { 50, 1 }
+#define Y4M_FPS_NTSC_FIELD { 60000, 1001 }
+#define Y4M_FPS_60         { 60, 1 }
+
+/* standard sample/pixel aspect ratios */
+#define Y4M_SAR_UNKNOWN        {   0, 0  }
+#define Y4M_SAR_SQUARE         {   1, 1  }
+#define Y4M_SAR_SQR_ANA_16_9   {   4, 3  }
+#define Y4M_SAR_NTSC_CCIR601   {  10, 11 }
+#define Y4M_SAR_NTSC_16_9      {  40, 33 }
+#define Y4M_SAR_NTSC_SVCD_4_3  {  15, 11 }
+#define Y4M_SAR_NTSC_SVCD_16_9 {  20, 11 }
+#define Y4M_SAR_PAL_CCIR601    {  59, 54 }
+#define Y4M_SAR_PAL_16_9       { 118, 81 }
+#define Y4M_SAR_PAL_SVCD_4_3   {  59, 36 }
+#define Y4M_SAR_PAL_SVCD_16_9  {  59, 27 }
+
+#define Y4M_SAR_MPEG1_1  Y4M_SAR_SQUARE
+#define Y4M_SAR_MPEG1_2  { 10000, 6735 }
+#define Y4M_SAR_MPEG1_3  { 10000, 7031 } /* Anamorphic 16:9 PAL */
+#define Y4M_SAR_MPEG1_4  { 10000, 7615 }
+#define Y4M_SAR_MPEG1_5  { 10000, 8055 }
+#define Y4M_SAR_MPEG1_6  { 10000, 8437 } /* Anamorphic 16:9 NTSC */
+#define Y4M_SAR_MPEG1_7  { 10000, 8935 } 
+#define Y4M_SAR_MPEG1_8  { 10000, 9375 } /* PAL/SECAM 4:3 */
+#define Y4M_SAR_MPEG1_9  { 10000, 9815 }
+#define Y4M_SAR_MPEG1_10 { 10000, 10255 }
+#define Y4M_SAR_MPEG1_11 { 10000, 10695 }
+#define Y4M_SAR_MPEG1_12 { 10000, 11250 } /* NTSC 4:3 */
+#define Y4M_SAR_MPEG1_13 { 10000, 11575 }
+#define Y4M_SAR_MPEG1_14 { 10000, 12015 }
+
+#define Y4M_DAR_UNKNOWN  {   0, 0   }
+#define Y4M_DAR_4_3      {   4, 3   }
+#define Y4M_DAR_16_9     {  16, 9   }
+#define Y4M_DAR_221_100  { 221, 100 }
+
+#define Y4M_DAR_MPEG2_1 {   1, 1   }
+#define Y4M_DAR_MPEG2_2 {   4, 3   }
+#define Y4M_DAR_MPEG2_3 {  16, 9   }
+#define Y4M_DAR_MPEG2_4 { 221, 100 }
+
+#endif /* __YUV4MPEG_INTERN_H__ */
+

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/zalphastrm.hpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/zalphastrm.hpp	2007-08-02 19:57:16 UTC (rev 3468)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/zalphastrm.hpp	2007-08-03 00:04:40 UTC (rev 3469)
@@ -1,68 +0,0 @@
-
-/*
- *  zalphastrm.hpp:  Z/Alpha video elementary input stream
- *
- *  Copyright (C) 2002 Gernot Ziegler &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">gz at lysator.liu.se</A>&gt;
- *  Copyright (C) 2001 Andrew Stevens &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">andrew.stevens at philips.com</A>&gt;
- *
- *
- *  This program is free software; you can redistribute it and/or
- *  modify it under the terms of version 2 of the GNU General Public License
- *  as published by the Free Software Foundation.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
- */
-
-#ifndef __ZALPHASTRM_H__
-#define __ZALPHASTRM_H__
-
-#include &quot;videostrm.hpp&quot;
-
-class ZAlphaStream : public VideoStream
-{
-public:
-	//ZAlphaStream(IBitStream &amp;ibs, OutputStream &amp;into);
-	ZAlphaStream(IBitStream &amp;ibs, VideoParams *parms, 
-                Multiplexor &amp;into);
-	void Init( const int stream_num );
-    static bool Probe(IBitStream &amp;bs );
-
-	void Close();
-
-	virtual bool MuxPossible(clockticks currentSCR);
-    void SetMaxStdBufferDelay( unsigned int demux_rate );
-	void OutputSector();
-protected:
-	void OutputSeqhdrInfo();
-    void FillAUbuffer(unsigned int frames_to_buffer);
-    virtual bool AUBufferNeedsRefill();
-	virtual void NextDTSPTS( clockticks &amp;DTS, clockticks &amp;PTS);
-	virtual void ScanFirstSeqHeader();
-    bool RunOutComplete();
-
-private:
-    float z_min; 
-    float z_max;	
-    int z_format;
-    int alpha_depth, z_depth;
-}; 	
-
-
-
-#endif // __INPUTSTRM_H__
-
-
-/* 
- * Local variables:
- *  c-file-style: &quot;stroustrup&quot;
- *  tab-width: 4
- *  indent-tabs-mode: nil
- * End:
- */

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/zalphastrm_in.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/zalphastrm_in.cpp	2007-08-02 19:57:16 UTC (rev 3468)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/zalphastrm_in.cpp	2007-08-03 00:04:40 UTC (rev 3469)
@@ -1,492 +0,0 @@
-/*
- *  zalphastrm_in.cpp:  Members of Z/Alpha stream class related to raw stream
- *               scanning and buffering.
- *
- *  Copyright (C) 2001 Gernot Ziegler &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">gz at lysator.liu.se</A>&gt;
- *  Copyright (C) 2001 Andrew Stevens &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">andrew.stevens at philips.com</A>&gt;
- *
- *
- *  This program is free software; you can redistribute it and/or
- *  modify it under the terms of version 2 of the GNU General Public License
- *  as published by the Free Software Foundation.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
- */
-
-#include &lt;config.h&gt;
-#include &lt;math.h&gt;
-#include &lt;stdlib.h&gt;
-
-#include &quot;zalphastrm.hpp&quot;
-#include &quot;interact.hpp&quot;
-#include &quot;multiplexor.hpp&quot;
-
-
-
-static void marker_bit (IBitStream &amp;bs, unsigned int what)
-{
-    if (what != bs.Get1Bit())
-    {
-        mjpeg_error (&quot;Illegal MPEG stream at offset (bits) %lld: supposed marker bit not found.&quot;,bs.bitcount());
-        exit (1);
-    }
-}
-
-
-void ZAlphaStream::ScanFirstSeqHeader()
-{
-    if (bs.GetBits( 32)==ZA_SEQUENCE_HEADER)
-    {
-        mjpeg_debug(&quot;Reading Z/Alpha sequence header ... &quot;);
-		num_sequence++;
-        
-        int headerlen = bs.GetBits(16);
-        mjpeg_info(&quot;Header frame length is %d&quot;, headerlen);
-
-        int frame_num = bs.GetBits(8);
-        mjpeg_info(&quot;Header frame number is %d&quot;, frame_num);
-		horizontal_size	= bs.GetBits( 12);
-		vertical_size	= bs.GetBits( 12);
-
-#if 0 
-		aspect_ratio	= bs.GetBits(  4);
-		picture_rate 	= bs.GetBits(  4);
-		bit_rate		= bs.GetBits( 18);
-		marker_bit( bs, 1);
-		vbv_buffer_size	= bs.GetBits( 10);
-		CSPF		= bs.get1bit();
-#else
-        // hardcoded here, but should really be copied from the video stream... 
-		aspect_ratio	= 2;
-		picture_rate	= 3;
-		bit_rate		= 3000;
-        //bit_rate = 0x3ffff;
-		//marker_bit( bs, 1);
-		vbv_buffer_size	= 50;
-		CSPF		= 0;
-#endif
-        uint8_t conv[4];
-
-        conv[0] = bs.GetBits(8);
-        conv[1] = bs.GetBits(8);
-        conv[2] = bs.GetBits(8);
-        conv[3] = bs.GetBits(8);
-
-        memcpy(&amp;z_min, conv, 4);
-
-        conv[0] = bs.GetBits(8);
-        conv[1] = bs.GetBits(8);
-        conv[2] = bs.GetBits(8);
-        conv[3] = bs.GetBits(8);
-
-        memcpy(&amp;z_max, conv, 4);
-
-        z_format = bs.GetBits(8);
-        printf(&quot;Z format byte is set to 0x%x\n&quot;, z_format);
-        z_depth = bs.GetBits(8);
-        alpha_depth = bs.GetBits(8);
-    } 
-    else
-    {
-		mjpeg_error (&quot;Invalid MPEG ZAlpha stream header.&quot;);
-		exit (1);
-    }
-
-	if (mpeg_valid_framerate_code(picture_rate))
-    {
-		frame_rate = Y4M_RATIO_DBL(mpeg_framerate(picture_rate));
-	}
-    else
-    {
-		frame_rate = 25.0;
-	}
-
-}
-
-
-
-
-void ZAlphaStream::Init ( const int stream_num )
-{
-	mjpeg_debug( &quot;SETTING video buffer to %d&quot;, parms-&gt;DecodeBufferSize() );
-	MuxStream::Init( ZALPHA_STR_0+stream_num,
-					 1,  // Buffer scale
-					 parms-&gt;DecodeBufferSize()*1024,
-					 0,  // Zero stuffing
-					 muxinto.buffers_in_video,
-					 muxinto.always_buffers_in_video);
-    mjpeg_debug( &quot;Scanning for header info: Z/Alpha stream %02x (%s)&quot;,
-                ZALPHA_STR_0+stream_num,
-                bs.StreamName()
-                );
-	InitAUbuffer();
-
-	SetBufSize( 4*1024*1024 );
-	ScanFirstSeqHeader();
-
-	/* Skip to the end of the 1st AU (*2nd* Picture start!)
-	*/
-	AU_hdr = ZA_SEQUENCE_HEADER;
-	AU_pict_data = 1;
-	AU_start = 0LL;
-    
-    OutputSeqhdrInfo();
-}
-
-//
-// Set the Maximum STD buffer delay for this video stream.
-// By default we set 1 second but if we have specified a video
-// buffer that can hold more than 1.0 seconds demuxed data we
-// set the delay to the time to fill the buffer.
-//
-
-void ZAlphaStream::SetMaxStdBufferDelay( unsigned int dmux_rate )
-{
-    double max_delay = CLOCKS;
-    if( static_cast&lt;double&gt;(BufferSize()) / dmux_rate &gt; 1.0 )
-        max_delay *= static_cast&lt;double&gt;(BufferSize()) / dmux_rate;
-
-    //
-    // To enforce a maximum STD buffer residency the
-    // calculation is a bit tricky as when we decide to mux we may
-    // (but not always) have some of the *previous* picture left to
-    // mux in which case it is the timestamp of the next picture that counts.
-    // For simplicity we simply reduce the limit by 1.5 frame intervals
-    // and use the timestamp for the current picture.
-    //
-    if( frame_rate &gt; 10.0 )
-        max_STD_buffer_delay = static_cast&lt;clockticks&gt;(max_delay * (frame_rate-1.5)/frame_rate);
-    else
-        max_STD_buffer_delay = static_cast&lt;clockticks&gt;(10.0 * max_delay / frame_rate);
-
-    mjpeg_error_exit1(&quot;dmux_rate is %d max_delay %g&quot;, dmux_rate, max_delay);
-
-}
-
-//
-// Return whether AU buffer needs refilling.  There are two cases:
-// 1. We have less than our look-ahead &quot;FRAME_CHUNK&quot; buffer AU's
-// buffered 2. AU's are very small and we could have less than 1
-// sector's worth of data buffered.
-//
-
-bool ZAlphaStream::AUBufferNeedsRefill()
-{
-    int retval = 
-        !eoscan
-        &amp;&amp; ( aunits.current()+FRAME_CHUNK &gt; last_buffered_AU
-             ||
-             bs.BufferedBytes() &lt; muxinto.sector_size 
-            );
-
-    //mjpeg_info(&quot;Z/A needs %s refill.\n&quot;, retval ? &quot;a&quot;:&quot;no&quot;);
-    return retval;
-}
-
-//
-// Refill the AU unit buffer setting  AU PTS DTS from the scanned
-// header information...
-//
-
-void ZAlphaStream::FillAUbuffer(unsigned int frames_to_buffer)
-{
-    int frame_num;
-    unsigned int bits_persec;
-    int headerlen;
-
-    if( eoscan )
-        return;
-
-	last_buffered_AU += frames_to_buffer;
-	mjpeg_debug( &quot;Scanning %d Z/A video frames to frame %d&quot;, 
-				 frames_to_buffer, last_buffered_AU );
-
-    // We set a limit of 2M to seek before we give up.
-    // This is intentionally very high because some heavily
-    // padded still frames may have a loooong gap before
-    // a following sequence end marker.
-	while(!bs.eos() 
-          &amp;&amp; decoding_order &lt; last_buffered_AU 
-          &amp;&amp; !muxinto.AfterMaxPTS(access_unit.PTS)
-          &amp;&amp; bs.SeekSync( SYNCWORD_START, 24, 2*1024*1024)
-		)
-	{
-		syncword = (SYNCWORD_START&lt;&lt;8) + bs.GetBits( 8);
-        //mjpeg_info( &quot;Traversing ... syncword 0x%x &quot;, syncword); 
-		if( AU_pict_data )
-		{
-			
-			/* Handle the header *ending* an AU...
-			   If we have the AU picture data an AU and have now
-			   reached a header marking the end of an AU fill in the
-			   the AU length and append it to the list of AU's and
-			   start a new AU.  I.e. sequence and gop headers count as
-			   part of the AU of the corresponding picture
-			*/
-			stream_length = bs.bitcount()-32LL;
-			switch (syncword) 
-			{
-            // note: there are currently _no_ sequence distinctions in Z/Alpha ! 
-			case ZA_SEQUENCE_HEADER :
-				access_unit.start = AU_start;
-				access_unit.length = (int) (stream_length - AU_start)&gt;&gt;3;
-				access_unit.end_seq = 0;
-                access_unit.type = IFRAME;
-				avg_frames[access_unit.type-1]+=access_unit.length;
-                access_unit.dorder = decoding_order;
-                access_unit.seq_header = 1; //( AU_hdr == SEQUENCE_HEADER);
-
-                
-                bits_persec = 
-					(unsigned int) ( ((double)(stream_length - prev_offset)) *
-									 2*frame_rate / ((double)(2 /*+ fields_presented- group_start_field*/)));
-				
-                //mjpeg_info(&quot;New bits_persec is %d bits/second.&quot;, bits_persec);
-                
-				if( bits_persec &gt; max_bits_persec )
-				{
-					max_bits_persec = bits_persec;
-				}
-
-				prev_offset = stream_length;
-
-                headerlen = bs.GetBits(16);
-                frame_num = bs.GetBits(8);
-                //mjpeg_info(&quot;Header frame number is %d&quot;, frame_num);
-
-				mjpeg_debug( &quot;Found Z/Alpha AU %d (real: %d): DTS=%d&quot;, access_unit.dorder, frame_num,
-							 access_unit.DTS/300);
-                
-                if ( decoding_order &gt;= old_frames+1000 )
-                {
-                    mjpeg_debug(&quot;Got %d picture headers.&quot;, decoding_order);
-                    old_frames = decoding_order;
-                }
-
-                decoding_order++;
-                //mjpeg_info(&quot;Decoding order is now %d&quot;, decoding_order);
-
-                NextDTSPTS( access_unit.DTS, access_unit.PTS);
-				aunits.append( access_unit ); // INSERTING NEW AUNIT ! 
-
-                
-                if ((access_unit.type&gt;0) &amp;&amp; (access_unit.type&lt;5))
-                {
-                    num_frames[access_unit.type-1]++; // counts the frames in this Z/Alpha stream
-                }                
-                
-				AU_hdr = syncword;
-				AU_start = stream_length;
-				AU_pict_data = 1;
-
-                if (decoding_order &gt;= last_buffered_AU)
-                {
-                    mjpeg_debug(&quot;Reached end of buffer ...&quot;);
-                    break;
-                }
-
-				break;
-
-			case SEQUENCE_END: // still using the MPEG sequence end, so that we don't have to use another SYNCWORD
-				access_unit.start = AU_start;
-				access_unit.length = (int) ((stream_length - AU_start)&gt;&gt;3)+4;
-				access_unit.end_seq = 1;
-				avg_frames[access_unit.type-1]+=access_unit.length;
-                access_unit.dorder = decoding_order;
-                access_unit.seq_header = 1; //( AU_hdr == SEQUENCE_HEADER);
-
-                access_unit.type = IFRAME;
-				mjpeg_debug( &quot;Adding final AU %d (real: %d): DTS=%d&quot;, access_unit.dorder, frame_num,
-							 access_unit.DTS/300);
-                NextDTSPTS( access_unit.DTS, access_unit.PTS);
-				aunits.append( access_unit ); // INSERTING NEW AUNIT ! 
-
-
-				//access_unit.length = ((stream_length - AU_start)&gt;&gt;3)+4;
-				//access_unit.end_seq = 1;
-				//aunits.append( access_unit );
-				mjpeg_debug( &quot;Z/Alpha: Scanned to end AU %d at %d&quot;, access_unit.dorder, stream_length/8 );
-				avg_frames[access_unit.type-1]+=access_unit.length;
-
-				/* Do we have a sequence split in the video stream? */
-				if( !bs.eos() &amp;&amp; 
-					bs.GetBits( 32) ==SEQUENCE_HEADER )
-				{
-					stream_length = bs.bitcount()-32LL;
-					AU_start = stream_length;
-					syncword  = AU_hdr = SEQUENCE_HEADER;
-					AU_pict_data = 0;
-					if( !muxinto.split_at_seq_end )
-						mjpeg_warn(&quot;Sequence end marker found in video stream but single-segment splitting specified!&quot; );
-				}
-				else
-				{
-					if( !bs.eos() &amp;&amp; muxinto.split_at_seq_end )
-						mjpeg_warn(&quot;No seq. header starting new sequence after seq. end!&quot;);
-				}
-					
-				num_seq_end++;
-				break;
-			}
-		}
-	}
-	last_buffered_AU = decoding_order;
-	num_pictures = decoding_order;	
-	eoscan = bs.eos() || muxinto.AfterMaxPTS(access_unit.PTS);
-}
-
-void ZAlphaStream::Close()
-{
-    unsigned int comp_bit_rate	;
-    unsigned int peak_bit_rate  ;
-
-    stream_length = (unsigned int)(bs.bitcount() / 8);
-    for (int i=0; i&lt;4; i++)
-	{
-		avg_frames[i] /= num_frames[i] == 0 ? 1 : num_frames[i];
-	}
-
-    comp_bit_rate = (unsigned int)
-		(
-			(((double)stream_length) / ((double)fields_presented)) * 2.0
-			* ((double)frame_rate)  + 25.0
-			) / 50;
-	
-	/* Peak bit rate in 50B/sec units... */
-	peak_bit_rate = ((max_bits_persec / 8) / 50);
-	mjpeg_info (&quot;VIDEO_STATISTICS: %02x&quot;, stream_id); 
-    mjpeg_info (&quot;Video Stream length: %11llu bytes&quot;,stream_length);
-    mjpeg_info (&quot;Sequence headers: %8u&quot;,num_sequence);
-    mjpeg_info (&quot;Sequence ends   : %8u&quot;,num_seq_end);
-    mjpeg_info (&quot;No. Pictures    : %8u&quot;,num_pictures);
-    mjpeg_info (&quot;No. I Frames    : %8u avg. size%6u bytes&quot;,
-			  num_frames[0],avg_frames[0]);
-    mjpeg_info(&quot;Average bit-rate : %8u bits/sec&quot;,comp_bit_rate*400);
-    mjpeg_info(&quot;Peak bit-rate    : %8u  bits/sec&quot;,peak_bit_rate*400);
-
-	
-}
-	
-
-
-
-/*************************************************************************
-	OutputSeqHdrInfo
-     Display sequence header parameters
-*************************************************************************/
-
-void ZAlphaStream::OutputSeqhdrInfo ()
-{
-	const char *str;
-	mjpeg_info(&quot;Z/Alpha STREAM: %02x&quot;, stream_id);
-
-    mjpeg_info (&quot;Frame width     : %u\n&quot;,horizontal_size);
-    mjpeg_info (&quot;Frame height    : %u\n&quot;,vertical_size);
-
-    mjpeg_info (&quot;Z min    : %f\n&quot;, z_min);
-    mjpeg_info (&quot;Z max    : %f\n&quot;, z_max);
-
-    mjpeg_info (&quot;Z format 0x%x, depth    : %d&quot;, z_format, z_depth);
-    mjpeg_info (&quot;Alpha depth   : %d&quot;, alpha_depth);
-
-	if (mpeg_valid_aspect_code(muxinto.mpeg, aspect_ratio))
-		str =  mpeg_aspect_code_definition(muxinto.mpeg,aspect_ratio);
-	else
-		str = &quot;forbidden&quot;;
-    mjpeg_info (&quot;Aspect ratio    : %s&quot;, str );
-
-    if (picture_rate == 0)
-		mjpeg_info( &quot;Picture rate    : forbidden&quot;);
-    else if (mpeg_valid_framerate_code(picture_rate))
-		mjpeg_info( &quot;Picture rate    : %2.3f frames/sec&quot;,
-					Y4M_RATIO_DBL(mpeg_framerate(picture_rate)) );
-    else
-		mjpeg_info( &quot;Picture rate    : %x reserved&quot;,picture_rate);
-				
-    if (bit_rate == 0x3ffff)
-		{
-			bit_rate = 0;
-			mjpeg_info( &quot;Bit rate        : variable&quot;); 
-		}
-    else if (bit_rate == 0)
-		mjpeg_info( &quot;Bit rate       : forbidden&quot;);
-    else
-		mjpeg_info( &quot;Bit rate        : %u bits/sec&quot;,
-					bit_rate*400);
-
-
-    mjpeg_info(&quot;Vbv buffer size : %u bytes&quot;,vbv_buffer_size*2048);
-    mjpeg_info(&quot;CSPF            : %u&quot;,CSPF);
-}
-
-//
-// Compute DTS of current AU in the Z/alpha sequence being
-// scanned.  
-//
-
-void ZAlphaStream::NextDTSPTS( clockticks &amp;DTS, clockticks &amp;PTS)
-{
-#if 0  // ZAlpha can't currently handle interlaced or 3:2 pulldown
-    if( pict_struct != PIC_FRAME )
-    {
-		DTS = static_cast&lt;clockticks&gt;
-			(fields_presented * (double)(CLOCKS/2) / frame_rate);
-        int dts_fields = temporal_reference*2 + group_start_field+1;
-        if( temporal_reference == prev_temp_ref )
-            dts_fields += 1;
-        PTS =
-            static_cast&lt;clockticks&gt;(dts_fields* (double)(CLOCKS/2) / frame_rate);
-		access_unit.porder = temporal_reference /*+ group_start_pic*/;
-        fields_presented += 1;
-    }	
-    else if( pulldown_32 )
-	{
-		int frames2field;
-		int frames3field;
-		DTS = static_cast&lt;clockticks&gt;
-			(fields_presented * (double)(CLOCKS/2) / frame_rate);
-		if( repeat_first_field )
-		{
-			frames2field = (temporal_reference+1) / 2;
-			frames3field = temporal_reference / 2;
-			fields_presented += 3;
-		}
-		else
-		{
-			frames2field = (temporal_reference) / 2;
-			frames3field = (temporal_reference+1) / 2;
-			fields_presented += 2;
-		}
-		PTS = static_cast&lt;clockticks&gt;
-			((frames2field*2 + frames3field*3 + group_start_field+1) * (double)(CLOCKS/2) / frame_rate);
-		access_unit.porder = temporal_reference + group_start_pic;
-	}
-    else
-#endif
-	{
-		DTS = static_cast&lt;clockticks&gt; 
-			(decoding_order * (double)CLOCKS / frame_rate);
-        PTS=DTS;
-		fields_presented += 2;
-	}
-}
-
-
-
-
-
-/* 
- * Local variables:
- *  c-file-style: &quot;stroustrup&quot;
- *  tab-width: 4
- *  indent-tabs-mode: nil
- * End:
- */
-

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/zalphastrm_out.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/zalphastrm_out.cpp	2007-08-02 19:57:16 UTC (rev 3468)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_mplex/zalphastrm_out.cpp	2007-08-03 00:04:40 UTC (rev 3469)
@@ -1,343 +0,0 @@
-
-/*
- *  zalphastrm_out.cpp:  Members of input stream classes related to muxing out into
- *               the output stream.
- *
- *  Copyright (C) 2001 Gernot Ziegler &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">gz at lysator.liu.se</A>&gt;
- *  Copyright (C) 2001 Andrew Stevens &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">andrew.stevens at philips.com</A>&gt;
- *
- *
- *  This program is free software; you can redistribute it and/or
- *  modify it under the terms of version 2 of the GNU General Public License
- *  as published by the Free Software Foundation.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
- */
-
-
-#include &lt;config.h&gt;
-#include &lt;assert.h&gt;
-#include &quot;fastintfns.h&quot;
-#include &quot;zalphastrm.hpp&quot;
-#include &quot;multiplexor.hpp&quot;
-
-
-ZAlphaStream::ZAlphaStream(IBitStream &amp;ibs, VideoParams *parms, 
-                         Multiplexor &amp;into ) :
-	VideoStream( ibs, parms, into)
-//ZAlphaStream::ZAlphaStream(IBitStream &amp;ibs, OutputStream &amp;into )	:
-//	VideoStream( ibs, into)
-{
-	prev_offset=0;
-    decoding_order=0;
-	fields_presented=0;
-    temporal_reference=0;
-	pulldown_32 = 0;
-    temporal_reference = -1;   // Needed to recognise 2nd field of 1st
-                               // frame in a field pic sequence
-	last_buffered_AU=0;
-	max_bits_persec = 0;
-	AU_hdr = ZA_SEQUENCE_HEADER;  /* GOP or SEQ Header starting AU? */
-	for( int i =0; i&lt;4; ++i )
-		num_frames[i] = avg_frames[i] = 0;
-    FRAME_CHUNK = 6;
-		
-}
-
-bool ZAlphaStream::Probe(IBitStream &amp;bs )
-{
-    return bs.GetBits( 32)  == ZA_SEQUENCE_HEADER;
-}
-
-
-/*********************************
- * Signals if it is permissible/possible to Mux out a sector from the Stream.
- * The universal constraints that muxing should not be complete and that
- * that the reciever buffer should have sufficient it also insists that
- * the muxed data won't hang around in the receiver buffer for more than
- * one second.  This is mainly for the benefit of (S)VCD and DVD applications
- * where long delays mess up random access.
- *******************************/
-
-
-bool ZAlphaStream::MuxPossible( clockticks currentSCR )
-{
-    bool a = ElementaryStream::MuxPossible(currentSCR);
-    bool b = (RequiredDTS() &lt; (currentSCR + max_STD_buffer_delay));
-
-    //mjpeg_info(&quot;Z/A max_STD_buffer_delay %d&quot;, max_STD_buffer_delay); 
-
-    //mjpeg_info(&quot;Z/A Mux Possible %d, %d &quot;, a, b);
-    //mjpeg_info(&quot;RequiredDTS %ld&quot;,RequiredDTS());
-    //mjpeg_info(&quot;currentSCR %ld&quot;, currentSCR);
-    //mjpeg_info(&quot;max_STD_buffer_delay %ld&quot;, max_STD_buffer_delay);
-
-	return (  a &amp;&amp; b );
-}
-
-
-
-/******************************************************************
-	Output_Video
-	generates Pack/Sys_Header/Packet information from the
-	video stream and writes out the new sector
-******************************************************************/
-
-void ZAlphaStream::OutputSector ( )
-
-#if 1
-{
-
-	unsigned int max_packet_payload; 	 
-	unsigned int actual_payload;
-	unsigned int old_au_then_new_payload;
-	clockticks  DTS,PTS;
-    int autype;
-
-	max_packet_payload = 0;	/* 0 = Fill sector */
-  	/* 	
- 	   We're now in the last AU of a segment.  So we don't want to go
- 	   beyond it's end when filling sectors. Hence we limit packet
- 	   payload size to (remaining) AU length.  The same applies when
- 	   we wish to ensure sequence headers starting ACCESS-POINT AU's
- 	   in (S)VCD's etc are sector-aligned.  
-
-       N.b.runout_PTS is the PTS of the first I picture following the
-       run-out is recorded.
-	*/
-	int nextAU = NextAUType();
-	if( ( muxinto.running_out &amp;&amp; nextAU == IFRAME &amp;&amp; NextRequiredPTS() &gt;= muxinto.runout_PTS) 
-        || (muxinto.sector_align_iframeAUs &amp;&amp; nextAU == IFRAME  )
-		) 
-	{
-		max_packet_payload = au_unsent;
-	}
-
-	/* Figure out the threshold payload size below which we can fit more
-	   than one AU into a packet N.b. because fitting more than one in
-	   imposses an overhead of additional header fields so there is a
-	   dead spot where we *have* to stuff the packet rather than start
-	   fitting in an extra AU.  Slightly over-conservative in the case
-	   of the last packet...  */
-
-	old_au_then_new_payload = muxinto.PacketPayload( *this,
-													 buffers_in_header, 
-													 true, true);
-
-	/* CASE: Packet starts with new access unit			*/
-	if (new_au_next_sec  )
-	{
-        autype = AUType();
-        //
-        // Some types of output format (e.g. DVD) require special
-        // control sectors before the sector starting a new GOP
-        // N.b. this implies muxinto.sector_align_iframeAUs
-        //
-        if( gop_control_packet &amp;&amp; autype == IFRAME )
-        {
-            OutputGOPControlSector();
-        }
-
-        if(  dtspts_for_all_au  &amp;&amp; max_packet_payload == 0 )
-            max_packet_payload = au_unsent;
-
-        PTS = RequiredPTS();
-        DTS = RequiredDTS();
-		actual_payload =
-			muxinto.WritePacket ( max_packet_payload,
-								  *this,
-								  NewAUBuffers(autype), 
-                                  PTS, DTS,
-								  NewAUTimestamps(autype) );
-
-	}
-
-	/* CASE: Packet begins with old access unit, no new one	*/
-	/*	     can begin in the very same packet					*/
-
-	else if ( au_unsent &gt;= old_au_then_new_payload ||
-              (max_packet_payload != 0 &amp;&amp; au_unsent &gt;= max_packet_payload) )
-	{
-		actual_payload = 
-			muxinto.WritePacket( au_unsent,
-								  *this,
-								  false, 0, 0,
-								  TIMESTAMPBITS_NO );
-	}
-
-	/* CASE: Packet begins with old access unit, a new one	*/
-	/*	     could begin in the very same packet			*/
-	else /* if ( !new_au_next_sec  &amp;&amp; 
-			(au_unsent &lt; old_au_then_new_payload)) */
-	{
-		/* Is there a new access unit ? */
-		if( Lookahead() != 0 )
-		{
-            autype = NextAUType();
-			if(  dtspts_for_all_au  &amp;&amp; max_packet_payload == 0 )
-				max_packet_payload = au_unsent + Lookahead()-&gt;length;
-
-			PTS = NextRequiredPTS();
-			DTS = NextRequiredDTS();
-
-			actual_payload = 
-				muxinto.WritePacket ( max_packet_payload,
-									  *this,
-									  NewAUBuffers(autype), 
-                                      PTS, DTS,
-									  NewAUTimestamps(autype) );
-		} 
-		else
-		{
-			actual_payload = muxinto.WritePacket ( au_unsent,
-										 *this,
-										 false, 0, 0,
-										 TIMESTAMPBITS_NO);
-		}
-
-	}
-	++nsec;
-	buffers_in_header = always_buffers_in_header;
-}
-
-#else
-{
-
-	unsigned int max_packet_payload; 	 
-	unsigned int actual_payload;
-	unsigned int prev_au_tail;
-	VAunit *vau;
-	unsigned int old_au_then_new_payload;
-	clockticks  DTS,PTS;
-    int autype;
-
-	max_packet_payload = 0;	/* 0 = Fill sector */
-  	/* 	
- 	   We're now in the last AU of a segment. 
-		So we don't want to go beyond it's end when filling
-		sectors. Hence we limit packet payload size to (remaining) AU length.
-		The same applies when we wish to ensure sequence headers starting
-		ACCESS-POINT AU's in (S)VCD's etc are sector-aligned.
-	*/
-	int nextAU = NextAUType();
-	if( (muxinto.running_out &amp;&amp; nextAU == IFRAME &amp;&amp; 
-		 NextRequiredPTS() &gt; muxinto.runout_PTS) ||
-		(muxinto.sector_align_iframeAUs &amp;&amp; nextAU == IFRAME )
-		) 
-	{
-		max_packet_payload = au_unsent;
-	}
-
-	/* Figure out the threshold payload size below which we can fit more
-	   than one AU into a packet N.b. because fitting more than one in
-	   imposses an overhead of additional header fields so there is a
-	   dead spot where we *have* to stuff the packet rather than start
-	   fitting in an extra AU.  Slightly over-conservative in the case
-	   of the last packet...  */
-
-	old_au_then_new_payload = muxinto.PacketPayload( *this,
-													 buffers_in_header, 
-													 true, true);
-
-	/* CASE: Packet starts with new access unit			*/
-	if (new_au_next_sec  )
-	{
-        autype = AUType();
-        //
-        // Some types of output format (e.g. DVD) require special
-        // control sectors before the sector starting a new GOP
-        // N.b. this implies muxinto.sector_align_iframeAUs
-        //
-        if( gop_control_packet &amp;&amp; autype == IFRAME )
-        {
-            OutputGOPControlSector();
-        }
-
-        if(  dtspts_for_all_au  &amp;&amp; max_packet_payload == 0 )
-            max_packet_payload = au_unsent;
-
-        PTS = RequiredPTS();
-        DTS = RequiredDTS();
-		actual_payload =
-			muxinto.WritePacket ( max_packet_payload,
-								  *this,
-								  NewAUBuffers(autype), 
-                                  PTS, DTS,
-								  NewAUTimestamps(autype) );
-
-	}
-
-	/* CASE: Packet begins with old access unit, no new one	*/
-	/*	     can begin in the very same packet					*/
-
-	else if ( au_unsent &gt;= old_au_then_new_payload ||
-              (max_packet_payload != 0 &amp;&amp; au_unsent &gt;= max_packet_payload) )
-	{
-		actual_payload = 
-			muxinto.WritePacket( au_unsent,
-								  *this,
-								  false, 0, 0,
-								  TIMESTAMPBITS_NO );
-	}
-
-	/* CASE: Packet begins with old access unit, a new one	*/
-	/*	     could begin in the very same packet			*/
-	else /* if ( !new_au_next_sec  &amp;&amp; 
-			(au_unsent &lt; old_au_then_new_payload)) */
-	{
-		/* Is there a new access unit ? */
-		if( Lookahead() != 0 )
-		{
-            autype = NextAUType();
-			if(  dtspts_for_all_au  &amp;&amp; max_packet_payload == 0 )
-				max_packet_payload = au_unsent + Lookahead()-&gt;length;
-
-			PTS = NextRequiredPTS();
-			DTS = NextRequiredDTS();
-
-			actual_payload = 
-				muxinto.WritePacket ( max_packet_payload,
-									  *this,
-									  NewAUBuffers(autype), 
-                                      PTS, DTS,
-									  NewAUTimestamps(autype) );
-		} 
-		else
-		{
-			actual_payload = muxinto.WritePacket ( 0,
-										 *this,
-										 false, 0, 0,
-										 TIMESTAMPBITS_NO);
-		}
-
-	}
-	++nsec;
-	buffers_in_header = always_buffers_in_header;
-}
-#endif
-
-
-bool ZAlphaStream::RunOutComplete()
-{
- 
-	return (au_unsent == 0);
-// || 
-//			( muxinto.running_out &amp;&amp;
-//			  au-&gt;type == IFRAME &amp;&amp; RequiredPTS() &gt;= muxinto.runout_PTS));
-}
-
-
-/* 
- * Local variables:
- *  c-file-style: &quot;stroustrup&quot;
- *  tab-width: 4
- *  indent-tabs-mode: nil
- * End:
- */


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000743.html">[Avidemux-svn-commit] r3468 - branches/avidemux_2.4_branch/avidemux
</A></li>
	<LI>Next message: <A HREF="000745.html">[Avidemux-svn-commit] r3470 -	branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_ocr
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#744">[ date ]</a>
              <a href="thread.html#744">[ thread ]</a>
              <a href="subject.html#744">[ subject ]</a>
              <a href="author.html#744">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">More information about the Avidemux-svn-commit
mailing list</a><br>
</body></html>
