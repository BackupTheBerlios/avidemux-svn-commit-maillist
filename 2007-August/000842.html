<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Avidemux-svn-commit] r3568 - in branches/avidemux_2.4_branch: .	avidemux avidemux/ADM_libraries	avidemux/ADM_libraries/ADM_nvwa avidemux/ADM_osSupport
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/avidemux-svn-commit/2007-August/index.html" >
   <LINK REL="made" HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r3568%20-%20in%20branches/avidemux_2.4_branch%3A%20.%0A%09avidemux%20avidemux/ADM_libraries%0A%09avidemux/ADM_libraries/ADM_nvwa%20avidemux/ADM_osSupport&In-Reply-To=%3C200708291945.l7TJjRwX011965%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000841.html">
   <LINK REL="Next"  HREF="000843.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Avidemux-svn-commit] r3568 - in branches/avidemux_2.4_branch: .	avidemux avidemux/ADM_libraries	avidemux/ADM_libraries/ADM_nvwa avidemux/ADM_osSupport</H1>
    <B>gruntster at mail.berlios.de</B> 
    <A HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r3568%20-%20in%20branches/avidemux_2.4_branch%3A%20.%0A%09avidemux%20avidemux/ADM_libraries%0A%09avidemux/ADM_libraries/ADM_nvwa%20avidemux/ADM_osSupport&In-Reply-To=%3C200708291945.l7TJjRwX011965%40sheep.berlios.de%3E"
       TITLE="[Avidemux-svn-commit] r3568 - in branches/avidemux_2.4_branch: .	avidemux avidemux/ADM_libraries	avidemux/ADM_libraries/ADM_nvwa avidemux/ADM_osSupport">gruntster at mail.berlios.de
       </A><BR>
    <I>Wed Aug 29 21:45:27 CEST 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="000841.html">[Avidemux-svn-commit] r3567 - in	branches/avidemux_2.4_branch/avidemux:	ADM_libraries/ADM_utilities ADM_userInterfaces/ADM_commonUI	ADM_videoFilter
</A></li>
        <LI>Next message: <A HREF="000843.html">[Avidemux-svn-commit] r3569 - in	branches/avidemux_2.4_branch/avidemux: . ADM_libraries/ADM_nvwa
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#842">[ date ]</a>
              <a href="thread.html#842">[ thread ]</a>
              <a href="subject.html#842">[ subject ]</a>
              <a href="author.html#842">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: gruntster
Date: 2007-08-29 21:45:10 +0200 (Wed, 29 Aug 2007)
New Revision: 3568

Added:
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_nvwa/
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_nvwa/CMakeLists.txt
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_nvwa/debug_new.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_nvwa/debug_new.h
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_nvwa/fast_mutex.h
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_nvwa/static_assert.h
Modified:
   branches/avidemux_2.4_branch/ConfigureChecks.cmake
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/CMakeLists.txt
   branches/avidemux_2.4_branch/avidemux/ADM_osSupport/ADM_memsupport.cpp
   branches/avidemux_2.4_branch/avidemux/CMakeLists.txt
   branches/avidemux_2.4_branch/config.h.cmake
Log:
[Debug] Nvwa memory leak detector, enabled only in debug mode and with FIND_LEAKS defined

Modified: branches/avidemux_2.4_branch/ConfigureChecks.cmake
===================================================================
--- branches/avidemux_2.4_branch/ConfigureChecks.cmake	2007-08-29 17:49:57 UTC (rev 3567)
+++ branches/avidemux_2.4_branch/ConfigureChecks.cmake	2007-08-29 19:45:10 UTC (rev 3568)
@@ -445,6 +445,7 @@
 
 if(CMAKE_BUILD_TYPE STREQUAL &quot;Debug&quot;)
 MESSAGE(STATUS &quot;** DEBUG BUILD (${CMAKE_BUILD_TYPE})**&quot;)
+SET(ADM_DEBUG 1)
 add_definitions(-DADM_DEBUG)
 else (CMAKE_BUILD_TYPE STREQUAL &quot;Debug&quot;)
 MESSAGE(STATUS &quot;** RELEASE BUILD (${CMAKE_BUILD_TYPE})**&quot;)

Added: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_nvwa/CMakeLists.txt
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_nvwa/CMakeLists.txt	2007-08-29 17:49:57 UTC (rev 3567)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_nvwa/CMakeLists.txt	2007-08-29 19:45:10 UTC (rev 3568)
@@ -0,0 +1,14 @@
+################################
+#
+################################
+include(AdmLib)
+SET(ADM_LIB ADM_nvwa)
+#
+SET(${ADM_LIB}_SRCS 
+debug_new.cpp
+)
+ADD_LIBRARY(${ADM_LIB} STATIC ${${ADM_LIB}_SRCS})
+ADD_ADM_LIB(${ADM_LIB} ADM_libraries)
+ADD_DEFINITIONS(-D_DEBUG_NEW_ERROR_ACTION=NULL -D_DEBUG_NEW_ALIGNMENT=32)
+
+################################

Added: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_nvwa/debug_new.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_nvwa/debug_new.cpp	2007-08-29 17:49:57 UTC (rev 3567)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_nvwa/debug_new.cpp	2007-08-29 19:45:10 UTC (rev 3568)
@@ -0,0 +1,730 @@
+// -*- Mode: C++; tab-width: 4; c-basic-offset: 4; indent-tabs-mode: nil -*-
+// vim:tabstop=4:shiftwidth=4:expandtab:
+
+/*
+ * Copyright (C) 2004-2005 Wu Yongwei &lt;adah at users dot sourceforge dot net&gt;
+ *
+ * This software is provided 'as-is', without any express or implied
+ * warranty.  In no event will the authors be held liable for any
+ * damages arising from the use of this software.
+ *
+ * Permission is granted to anyone to use this software for any purpose,
+ * including commercial applications, and to alter it and redistribute
+ * it freely, subject to the following restrictions:
+ *
+ * 1. The origin of this software must not be misrepresented; you must
+ *    not claim that you wrote the original software. If you use this
+ *    software in a product, an acknowledgment in the product
+ *    documentation would be appreciated but is not required.
+ * 2. Altered source versions must be plainly marked as such, and must
+ *    not be misrepresented as being the original software.
+ * 3. This notice may not be removed or altered from any source
+ *    distribution.
+ *
+ * This file is part of Stones of Nvwa:
+ *      <A HREF="http://sourceforge.net/projects/nvwa">http://sourceforge.net/projects/nvwa</A>
+ *
+ */
+
+/**
+ * @file    debug_new.cpp
+ *
+ * Implementation of debug versions of new and delete to check leakage.
+ *
+ * @version 3.16, 2005/11/22
+ * @author  Wu Yongwei
+ *
+ */
+
+#include &lt;new&gt;
+#include &lt;assert.h&gt;
+#include &lt;limits.h&gt;
+#include &lt;stdio.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;string.h&gt;
+#ifdef __unix__
+#include &lt;alloca.h&gt;
+#endif
+#ifdef _WIN32
+#include &lt;malloc.h&gt;
+#endif
+#include &quot;fast_mutex.h&quot;
+#include &quot;static_assert.h&quot;
+
+// GRUNTSTER
+static void* _malloc(size_t size);
+static void _free(void *ptr);
+
+#if !_FAST_MUTEX_CHECK_INITIALIZATION &amp;&amp; !defined(_NOTHREADS)
+#error &quot;_FAST_MUTEX_CHECK_INITIALIZATION not set: check_leaks may not work&quot;
+#endif
+
+/**
+ * @def _DEBUG_NEW_ALIGNMENT
+ *
+ * The alignment requirement of allocated memory blocks.  It must be a
+ * power of two.
+ */
+#ifndef _DEBUG_NEW_ALIGNMENT
+#define _DEBUG_NEW_ALIGNMENT 16
+#endif
+
+/**
+ * @def _DEBUG_NEW_CALLER_ADDRESS
+ *
+ * The expression to return the caller address.  #print_position will
+ * later on use this address to print the position information of memory
+ * operation points.
+ */
+#ifndef _DEBUG_NEW_CALLER_ADDRESS
+#ifdef __GNUC__
+#define _DEBUG_NEW_CALLER_ADDRESS __builtin_return_address(0)
+#else
+#define _DEBUG_NEW_CALLER_ADDRESS NULL
+#endif
+#endif
+
+/**
+ * @def _DEBUG_NEW_ERROR_ACTION
+ *
+ * The action to take when an error occurs.  The default behaviour is to
+ * call \e abort, unless \c _DEBUG_NEW_ERROR_CRASH is defined, in which
+ * case a segmentation fault will be triggered instead (which can be
+ * useful on platforms like Windows that do not generate a core dump
+ * when \e abort is called).
+ */
+#ifndef _DEBUG_NEW_ERROR_ACTION
+#ifndef _DEBUG_NEW_ERROR_CRASH
+#define _DEBUG_NEW_ERROR_ACTION NULL //abort()
+#else
+#define _DEBUG_NEW_ERROR_ACTION do { *((char*)0) = 0; abort(); } while (0)
+#endif
+#endif
+
+/**
+ * @def _DEBUG_NEW_FILENAME_LEN
+ *
+ * The length of file name stored if greater than zero.  If it is zero,
+ * only a const char pointer will be stored.  Currently the default
+ * behaviour is to copy the file name, because I found that the exit
+ * leakage check cannot access the address of the file name sometimes
+ * (in my case, a core dump will occur when trying to access the file
+ * name in a shared library after a \c SIGINT).  If the default value is
+ * too small for you, try defining it to \c 52, which makes the size of
+ * new_ptr_list_t 64 (it is 32 by default) on 32-bit platforms.
+ */
+#ifndef _DEBUG_NEW_FILENAME_LEN
+#define _DEBUG_NEW_FILENAME_LEN 20
+#endif
+
+/**
+ * @def _DEBUG_NEW_HASHTABLESIZE
+ *
+ * The size of the hash bucket for the table to store pointers to
+ * allocated memory.  To ensure good performance, always make it a power
+ * of two.
+ */
+#ifndef _DEBUG_NEW_HASHTABLESIZE
+#define _DEBUG_NEW_HASHTABLESIZE 16384
+#endif
+
+/**
+ * @def _DEBUG_NEW_HASH
+ *
+ * The hash function for the pointers.  This one has good performance in
+ * test for me.
+ */
+#ifndef _DEBUG_NEW_HASH
+#define _DEBUG_NEW_HASH(p) (((size_t)(p) &gt;&gt; 8) % _DEBUG_NEW_HASHTABLESIZE)
+#endif
+
+/**
+ * @def _DEBUG_NEW_PROGNAME
+ *
+ * The program (executable) name to be set at compile time.  It is
+ * better to assign the full program path to #new_progname in \e main
+ * (at run time) than to use this (compile-time) macro, but this macro
+ * serves well as a quick hack.  Note also that double quotation marks
+ * need to be used around the program name, i.e., one should specify a
+ * command-line option like &lt;code&gt;-D_DEBUG_NEW_PROGNAME=\&quot;a.out\&quot;&lt;/code&gt;
+ * in \e bash, or &lt;code&gt;-D_DEBUG_NEW_PROGNAME=\&quot;a.exe\&quot;&lt;/code&gt; in the
+ * Windows command prompt.
+ */
+#ifndef _DEBUG_NEW_PROGNAME
+#define _DEBUG_NEW_PROGNAME NULL
+#endif
+
+/**
+ * @def _DEBUG_NEW_USE_ADDR2LINE
+ *
+ * Whether to use \e addr2line to convert a caller address to file/line
+ * information.  Defining it to a non-zero value will enable the
+ * conversion (automatically done if GCC is detected).  Defining it to
+ * zero will disable the conversion.
+ */
+#ifndef _DEBUG_NEW_USE_ADDR2LINE
+#ifdef __GNUC__
+#define _DEBUG_NEW_USE_ADDR2LINE 1
+#else
+#define _DEBUG_NEW_USE_ADDR2LINE 0
+#endif
+#endif
+
+#ifdef _MSC_VER
+#pragma warning(disable: 4073)  // #pragma init_seg(lib) used
+#pragma warning(disable: 4290)  // C++ exception specification ignored
+#pragma init_seg(lib)
+#endif
+
+#undef  _DEBUG_NEW_EMULATE_MALLOC
+#undef  _DEBUG_NEW_REDEFINE_NEW
+/**
+ * Macro to indicate whether redefinition of \c new is wanted.  Here it
+ * is defined to \c 0 to disable the redefinition of \c new.
+ */
+#define _DEBUG_NEW_REDEFINE_NEW 0
+#include &quot;debug_new.h&quot;
+
+/**
+ * Gets the aligned value of memory block size.
+ */
+#define align(s) \
+        (((s) + _DEBUG_NEW_ALIGNMENT - 1) &amp; ~(_DEBUG_NEW_ALIGNMENT - 1))
+
+/**
+ * Structure to store the position information where \c new occurs.
+ */
+struct new_ptr_list_t
+{
+    new_ptr_list_t*     next;
+    union
+    {
+#if _DEBUG_NEW_FILENAME_LEN == 0
+    const char*         file;
+#else
+    char                file[_DEBUG_NEW_FILENAME_LEN];
+#endif
+    void*               addr;
+    };
+    int                 line;
+    size_t              size;
+};
+
+/**
+ * The extra memory allocated by &lt;code&gt;operator new&lt;/code&gt;.
+ */
+const int aligned_list_item_size = align(sizeof(new_ptr_list_t));
+
+/**
+ * Array of pointer lists of a hash value.
+ */
+static new_ptr_list_t* new_ptr_list[_DEBUG_NEW_HASHTABLESIZE];
+
+/**
+ * Array of mutex guards to protect simultaneous access to the pointer
+ * lists of a hash value.
+ */
+static fast_mutex new_ptr_lock[_DEBUG_NEW_HASHTABLESIZE];
+
+/**
+ * The mutex guard to protect simultaneous output to #new_output_fp.
+ */
+static fast_mutex new_output_lock;
+
+/**
+ * Total memory allocated in bytes.
+ */
+static size_t total_mem_alloc = 0;
+
+/**
+ * Flag to control whether #check_leaks will be automatically called on
+ * program exit.
+ */
+bool new_autocheck_flag = true;
+
+/**
+ * Flag to control whether verbose messages are output.
+ */
+bool new_verbose_flag = false;
+
+/**
+ * Pointer to the output stream.  The default output is \e stderr, and
+ * one may change it to a user stream if needed (say, #new_verbose_flag
+ * is \c true and there are a lot of (de)allocations).
+ */
+FILE* new_output_fp = stderr;
+
+/**
+ * Pointer to the program name.  Its initial value is the macro
+ * #_DEBUG_NEW_PROGNAME.  You should try to assign the program path to
+ * it early in your application.  Assigning &lt;code&gt;argv[0]&lt;/code&gt; to it
+ * in \e main is one way.  If you use \e bash or \e ksh (or similar),
+ * the following statement is probably what you want:
+ * `&lt;code&gt;new_progname = getenv(&quot;_&quot;);&lt;/code&gt;'.
+ */
+const char* new_progname = _DEBUG_NEW_PROGNAME;
+
+#if _DEBUG_NEW_USE_ADDR2LINE
+/**
+ * Tries printing the position information from an instruction address.
+ * This is the version that uses \e addr2line.
+ *
+ * @param addr  the instruction address to convert and print
+ * @return      \c true if the address is converted successfully (and
+ *              the result is printed); \c false if no useful
+ *              information is got (and nothing is printed)
+ */
+static bool print_position_from_addr(const void* addr)
+{
+    static const void* last_addr = NULL;
+    static char last_info[256] = &quot;&quot;;
+    if (addr == last_addr)
+    {
+        if (last_info[0] == '\0')
+            return false;
+        fprintf(new_output_fp, &quot;%s&quot;, last_info);
+        return true;
+    }
+    if (new_progname)
+    {
+        const char addr2line_cmd[] = &quot;addr2line -e &quot;;
+#if   defined(__CYGWIN__) || defined(_WIN32)
+        const int  exeext_len = 4;
+#else
+        const int  exeext_len = 0;
+#endif
+#if  !defined(__CYGWIN__) &amp;&amp; defined(__unix__)
+        const char ignore_err[] = &quot; 2&gt;/dev/null&quot;;
+#elif defined(__CYGWIN__) || \
+        (defined(_WIN32) &amp;&amp; defined(WINVER) &amp;&amp; WINVER &gt;= 0x0500)
+        const char ignore_err[] = &quot; 2&gt;nul&quot;;
+#else
+        const char ignore_err[] = &quot;&quot;;
+#endif
+        char* cmd = (char*)alloca(strlen(new_progname)
+                                  + exeext_len
+                                  + sizeof addr2line_cmd - 1
+                                  + sizeof ignore_err - 1
+                                  + sizeof(void*) * 2
+                                  + 4 /* SP + &quot;0x&quot; + null */);
+        strcpy(cmd, addr2line_cmd);
+        strcpy(cmd + sizeof addr2line_cmd - 1, new_progname);
+        size_t len = strlen(cmd);
+#if   defined(__CYGWIN__) || defined(_WIN32)
+        if (len &lt;= 4
+                || (strcmp(cmd + len - 4, &quot;.exe&quot;) != 0 &amp;&amp;
+                    strcmp(cmd + len - 4, &quot;.EXE&quot;) != 0))
+        {
+            strcpy(cmd + len, &quot;.exe&quot;);
+            len += 4;
+        }
+#endif
+        sprintf(cmd + len, &quot; %p%s&quot;, addr, ignore_err);
+        FILE* fp = popen(cmd, &quot;r&quot;);
+        if (fp)
+        {
+            char buffer[sizeof last_info] = &quot;&quot;;
+            len = 0;
+            if (fgets(buffer, sizeof buffer, fp))
+            {
+                len = strlen(buffer);
+                if (buffer[len - 1] == '\n')
+                    buffer[--len] = '\0';
+            }
+            int res = pclose(fp);
+            // Display the file/line information only if the command
+            // is executed successfully and the output points to a
+            // valid position, but the result will be cached if only
+            // the command is executed successfully.
+            if (res == 0 &amp;&amp; len &gt; 0)
+            {
+                last_addr = addr;
+                if (buffer[len - 1] == '0' &amp;&amp; buffer[len - 2] == ':')
+                    last_info[0] = '\0';
+                else
+                {
+                    fprintf(new_output_fp, &quot;%s&quot;, buffer);
+                    strcpy(last_info, buffer);
+                    return true;
+                }
+            }
+        }
+    }
+    return false;
+}
+#else
+/**
+ * Tries printing the position information from an instruction address.
+ * This is the stub version that does nothing at all.
+ *
+ * @return      \c false always
+ */
+static bool print_position_from_addr(const void*)
+{
+    return false;
+}
+#endif // _DEBUG_NEW_USE_ADDR2LINE
+
+/**
+ * Prints the position information of a memory operation point.  When \c
+ * _DEBUG_NEW_USE_ADDR2LINE is defined to a non-zero value, this
+ * function will try to convert a given caller address to file/line
+ * information with \e addr2line.
+ *
+ * @param ptr   source file name if \e line is non-zero; caller address
+ *              otherwise
+ * @param line  source line number if non-zero; indication that \e ptr
+ *              is the caller address otherwise
+ */
+static void print_position(const void* ptr, int line)
+{
+    line &amp;= ~INT_MIN;       // Result from new[] if highest bit set: Ignore
+    if (line != 0)          // Is file/line information present?
+    {
+        fprintf(new_output_fp, &quot;%s:%d&quot;, (const char*)ptr, line);
+    }
+    else if (ptr != NULL)   // Is caller address present?
+    {
+        if (!print_position_from_addr(ptr)) // Fail to get source position?
+            fprintf(new_output_fp, &quot;%p&quot;, ptr);
+    }
+    else                    // No information is present
+    {
+        fprintf(new_output_fp, &quot;&lt;Unknown&gt;&quot;);
+    }
+}
+
+/**
+ * Searches for the raw pointer given a user pointer.  The term `raw
+ * pointer' here refers to the pointer to the pointer to originally
+ * &lt;em&gt;malloc&lt;/em&gt;'d memory.
+ *
+ * @param pointer       user pointer to search for
+ * @param hash_index    hash index of the user pointer
+ * @return              the raw pointer if searching is successful; or
+ *                      \c NULL otherwise
+ */
+static new_ptr_list_t** search_pointer(void* pointer, size_t hash_index)
+{
+    new_ptr_list_t** raw_ptr = &amp;new_ptr_list[hash_index];
+    while (*raw_ptr)
+    {
+        if ((char*)*raw_ptr + aligned_list_item_size == pointer)
+        {
+            return raw_ptr;
+        }
+        raw_ptr = &amp;(*raw_ptr)-&gt;next;
+    }
+    return NULL;
+}
+
+/**
+ * Frees memory and adjusts pointers relating to a raw pointer.  If the
+ * highest bit of \c line (set from a previous &lt;code&gt;new[]&lt;/code&gt; call)
+ * does not agree with \c array_mode, program will abort with an error
+ * message.
+ *
+ * @param raw_ptr       raw pointer to free
+ * @param addr          pointer to the caller
+ * @param array_mode    flag indicating whether it is invoked by a
+ *                      &lt;code&gt;delete[]&lt;/code&gt; call
+ */
+static void free_pointer(new_ptr_list_t** raw_ptr, void* addr, bool array_mode)
+{
+    new_ptr_list_t* ptr = *raw_ptr;
+    int array_mode_mismatch = array_mode ^ ((ptr-&gt;line &amp; INT_MIN) != 0);
+    if (array_mode_mismatch)
+    {
+        const char* msg;
+        if (array_mode)
+            msg = &quot;delete[] after new&quot;;
+        else
+            msg = &quot;delete after new[]&quot;;
+        fast_mutex_autolock lock(new_output_lock);
+        fprintf(new_output_fp,
+                &quot;%s: pointer %p (size %u)\n\tat &quot;,
+                msg,
+                (char*)ptr + aligned_list_item_size,
+                ptr-&gt;size);
+        print_position(addr, 0);
+        fprintf(new_output_fp, &quot;\n\toriginally allocated at &quot;);
+        if ((ptr-&gt;line &amp; ~INT_MIN) != 0)
+            print_position(ptr-&gt;file, ptr-&gt;line);
+        else
+            print_position(ptr-&gt;addr, ptr-&gt;line);
+        fprintf(new_output_fp, &quot;\n&quot;);
+        fflush(new_output_fp);
+        _DEBUG_NEW_ERROR_ACTION;
+    }
+    total_mem_alloc -= ptr-&gt;size;
+    if (new_verbose_flag)
+    {
+        fast_mutex_autolock lock(new_output_lock);
+        fprintf(new_output_fp,
+                &quot;delete: freeing  %p (size %u, %u bytes still allocated)\n&quot;,
+                (char*)ptr + aligned_list_item_size,
+                ptr-&gt;size, total_mem_alloc);
+    }
+    *raw_ptr = ptr-&gt;next;
+    _free(ptr);
+    return;
+}
+
+/**
+ * Checks for memory leaks.
+ *
+ * @return  zero if no leakage is found; the number of leaks otherwise
+ */
+int check_leaks()
+{
+    int leak_cnt = 0;
+    for (int i = 0; i &lt; _DEBUG_NEW_HASHTABLESIZE; ++i)
+    {
+        fast_mutex_autolock lock(new_ptr_lock[i]);
+        new_ptr_list_t* ptr = new_ptr_list[i];
+        if (ptr == NULL)
+            continue;
+        while (ptr)
+        {
+            fast_mutex_autolock lock(new_output_lock);
+            fprintf(new_output_fp,
+                    &quot;Leaked object at %p (size %u, &quot;,
+                    (char*)ptr + aligned_list_item_size,
+                    ptr-&gt;size);
+            if ((ptr-&gt;line &amp; ~INT_MIN) != 0)
+                print_position(ptr-&gt;file, ptr-&gt;line);
+            else
+                print_position(ptr-&gt;addr, ptr-&gt;line);
+            fprintf(new_output_fp, &quot;)\n&quot;);
+            ptr = ptr-&gt;next;
+            ++leak_cnt;
+        }
+    }
+    return leak_cnt;
+}
+
+void* operator new(size_t size, const char* file, int line)
+{
+    assert((line &amp; INT_MIN) == 0);
+    STATIC_ASSERT((_DEBUG_NEW_ALIGNMENT &amp; (_DEBUG_NEW_ALIGNMENT - 1)) == 0,
+                  Alignment_must_be_power_of_two);
+    size_t s = size + aligned_list_item_size;
+    new_ptr_list_t* ptr = (new_ptr_list_t*)_malloc(s);
+    if (ptr == NULL)
+    {
+        fast_mutex_autolock lock(new_output_lock);
+        fprintf(new_output_fp,
+                &quot;new:  out of memory when allocating %u bytes\n&quot;,
+                size);
+        fflush(new_output_fp);
+        _DEBUG_NEW_ERROR_ACTION;
+    }
+    void* pointer = (char*)ptr + aligned_list_item_size;
+    size_t hash_index = _DEBUG_NEW_HASH(pointer);
+#if _DEBUG_NEW_FILENAME_LEN == 0
+    ptr-&gt;file = file;
+#else
+    if (line)
+        strncpy(ptr-&gt;file, file, _DEBUG_NEW_FILENAME_LEN - 1)
+                [_DEBUG_NEW_FILENAME_LEN - 1] = '\0';
+    else
+        ptr-&gt;addr = (void*)file;
+#endif
+    ptr-&gt;line = line;
+    ptr-&gt;size = size;
+    {
+        fast_mutex_autolock lock(new_ptr_lock[hash_index]);
+        ptr-&gt;next = new_ptr_list[hash_index];
+        new_ptr_list[hash_index] = ptr;
+    }
+    if (new_verbose_flag)
+    {
+        fast_mutex_autolock lock(new_output_lock);
+        fprintf(new_output_fp,
+                &quot;new:  allocated  %p (size %u, &quot;,
+                pointer, size);
+        if (line != 0)
+            print_position(ptr-&gt;file, ptr-&gt;line);
+        else
+            print_position(ptr-&gt;addr, ptr-&gt;line);
+        fprintf(new_output_fp, &quot;)\n&quot;);
+    }
+    total_mem_alloc += size;
+    return pointer;
+}
+
+void* operator new[](size_t size, const char* file, int line)
+{
+    void* pointer = operator new(size, file, line);
+    new_ptr_list_t* ptr =
+            (new_ptr_list_t*)((char*)pointer - aligned_list_item_size);
+    assert((ptr-&gt;line &amp; INT_MIN) == 0);
+    ptr-&gt;line |= INT_MIN;   // Result from new[] if highest bit set: Set
+    return pointer;
+}
+
+void* operator new(size_t size) throw(std::bad_alloc)
+{
+    return operator new(size, (char*)_DEBUG_NEW_CALLER_ADDRESS, 0);
+}
+
+void* operator new[](size_t size) throw(std::bad_alloc)
+{
+    return operator new[](size, (char*)_DEBUG_NEW_CALLER_ADDRESS, 0);
+}
+
+#if !defined(__BORLANDC__) || __BORLANDC__ &gt; 0x551
+void* operator new(size_t size, const std::nothrow_t&amp;) throw()
+{
+    return operator new(size, (char*)_DEBUG_NEW_CALLER_ADDRESS, 0);
+}
+
+void* operator new[](size_t size, const std::nothrow_t&amp;) throw()
+{
+    return operator new[](size, (char*)_DEBUG_NEW_CALLER_ADDRESS, 0);
+}
+#endif
+
+void operator delete(void* pointer) throw()
+{
+    if (pointer == NULL)
+        return;
+    size_t hash_index = _DEBUG_NEW_HASH(pointer);
+    fast_mutex_autolock lock(new_ptr_lock[hash_index]);
+    new_ptr_list_t** raw_ptr = search_pointer(pointer, hash_index);
+    if (raw_ptr == NULL)
+    {
+        fast_mutex_autolock lock(new_output_lock);
+        fprintf(new_output_fp, &quot;delete: invalid pointer %p at &quot;, pointer);
+        print_position(_DEBUG_NEW_CALLER_ADDRESS, 0);
+        fprintf(new_output_fp, &quot;\n&quot;);
+        fflush(new_output_fp);
+        _DEBUG_NEW_ERROR_ACTION;
+    }
+    free_pointer(raw_ptr, _DEBUG_NEW_CALLER_ADDRESS, false);
+}
+
+void operator delete[](void* pointer) throw()
+{
+    if (pointer == NULL)
+        return;
+    size_t hash_index = _DEBUG_NEW_HASH(pointer);
+    fast_mutex_autolock lock(new_ptr_lock[hash_index]);
+    new_ptr_list_t** raw_ptr = search_pointer(pointer, hash_index);
+    if (raw_ptr == NULL)
+    {
+        fast_mutex_autolock lock(new_output_lock);
+        fprintf(new_output_fp, &quot;delete[]: invalid pointer %p at &quot;, pointer);
+        print_position(_DEBUG_NEW_CALLER_ADDRESS, 0);
+        fprintf(new_output_fp, &quot;\n&quot;);
+        fflush(new_output_fp);
+        _DEBUG_NEW_ERROR_ACTION;
+    }
+    free_pointer(raw_ptr, _DEBUG_NEW_CALLER_ADDRESS, true);
+}
+
+#if HAS_PLACEMENT_DELETE
+void operator delete(void* pointer, const char* file, int line) throw()
+{
+    if (new_verbose_flag)
+    {
+        fast_mutex_autolock lock(new_output_lock);
+        fprintf(new_output_fp,
+                &quot;info: exception thrown on initializing object at %p (&quot;,
+                pointer);
+        print_position(file, line);
+        fprintf(new_output_fp, &quot;)\n&quot;);
+    }
+    operator delete(pointer);
+}
+
+void operator delete[](void* pointer, const char* file, int line) throw()
+{
+    if (new_verbose_flag)
+    {
+        fast_mutex_autolock lock(new_output_lock);
+        fprintf(new_output_fp,
+                &quot;info: exception thrown on initializing objects at %p (&quot;,
+                pointer);
+        print_position(file, line);
+        fprintf(new_output_fp, &quot;)\n&quot;);
+    }
+    operator delete[](pointer);
+}
+
+void operator delete(void* pointer, const std::nothrow_t&amp;) throw()
+{
+    operator delete(pointer, (char*)_DEBUG_NEW_CALLER_ADDRESS, 0);
+}
+
+void operator delete[](void* pointer, const std::nothrow_t&amp;) throw()
+{
+    operator delete[](pointer, (char*)_DEBUG_NEW_CALLER_ADDRESS, 0);
+}
+#endif // HAS_PLACEMENT_DELETE
+
+int __debug_new_counter::_count = 0;
+
+/**
+ * Constructor to increment the count.
+ */
+__debug_new_counter::__debug_new_counter()
+{
+    ++_count;
+}
+
+/**
+ * Destructor to decrement the count.  When the count is zero,
+ * #check_leaks will be called.
+ */
+__debug_new_counter::~__debug_new_counter()
+{
+    if (--_count == 0 &amp;&amp; new_autocheck_flag)
+        if (check_leaks())
+        {
+            new_verbose_flag = true;
+#if defined(__GNUC__) &amp;&amp; __GNUC__ &gt;= 3
+            if (!getenv(&quot;GLIBCPP_FORCE_NEW&quot;) &amp;&amp; !getenv(&quot;GLIBCXX_FORCE_NEW&quot;))
+                fprintf(new_output_fp,
+&quot;*** WARNING:  GCC 3 or later is detected, please make sure the\n&quot;
+&quot;    environment variable GLIBCPP_FORCE_NEW (GCC 3.2 and 3.3) or\n&quot;
+&quot;    GLIBCXX_FORCE_NEW (GCC 3.4 and later) is defined.  Check the\n&quot;
+&quot;    README file for details.\n&quot;);
+#endif
+        }
+}
+
+// GRUNTSTER
+size_t getSizeFromPointer(void* ptr)
+{
+	size_t hash_index = _DEBUG_NEW_HASH(ptr);
+    fast_mutex_autolock lock(new_ptr_lock[hash_index]);
+    new_ptr_list_t** raw_pointer = search_pointer(ptr, hash_index);
+	new_ptr_list_t* pointer = *raw_pointer;
+
+	return pointer-&gt;size;
+}
+
+static void* _malloc(size_t size)
+{
+	char *ptr, *ptr2, *aligned_ptr;
+
+	ptr = (char *)malloc(size + 16 + sizeof(int));
+	if (ptr == NULL) return(NULL);
+
+	ptr2 = ptr + sizeof(int);
+	aligned_ptr = ptr2 + (16 - ((size_t)ptr2 &amp; 15));
+
+	ptr2 = aligned_ptr - sizeof(int);
+	*((int *)ptr2)=(int)(aligned_ptr - ptr);
+
+	return(aligned_ptr);
+}
+
+static void _free(void *ptr)
+{
+	int *ptr2 = (int *)ptr - 1;
+	char *c = (char *)ptr;
+
+	free(c - *ptr2);
+}

Added: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_nvwa/debug_new.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_nvwa/debug_new.h	2007-08-29 17:49:57 UTC (rev 3567)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_nvwa/debug_new.h	2007-08-29 19:45:10 UTC (rev 3568)
@@ -0,0 +1,143 @@
+// -*- Mode: C++; tab-width: 4; c-basic-offset: 4; indent-tabs-mode: nil -*-
+// vim:tabstop=4:shiftwidth=4:expandtab:
+
+/*
+ * Copyright (C) 2004-2005 Wu Yongwei &lt;adah at users dot sourceforge dot net&gt;
+ *
+ * This software is provided 'as-is', without any express or implied
+ * warranty.  In no event will the authors be held liable for any
+ * damages arising from the use of this software.
+ *
+ * Permission is granted to anyone to use this software for any purpose,
+ * including commercial applications, and to alter it and redistribute
+ * it freely, subject to the following restrictions:
+ *
+ * 1. The origin of this software must not be misrepresented; you must
+ *    not claim that you wrote the original software. If you use this
+ *    software in a product, an acknowledgment in the product
+ *    documentation would be appreciated but is not required.
+ * 2. Altered source versions must be plainly marked as such, and must
+ *    not be misrepresented as being the original software.
+ * 3. This notice may not be removed or altered from any source
+ *    distribution.
+ *
+ * This file is part of Stones of Nvwa:
+ *      <A HREF="http://sourceforge.net/projects/nvwa">http://sourceforge.net/projects/nvwa</A>
+ *
+ */
+
+/**
+ * @file    debug_new.h
+ *
+ * Header file for checking leaks caused by unmatched new/delete.
+ *
+ * @version 3.4, 2005/09/13
+ * @author  Wu Yongwei
+ *
+ */
+
+#ifndef _DEBUG_NEW_H
+#define _DEBUG_NEW_H
+
+#include &lt;new&gt;
+#include &lt;stdio.h&gt;
+
+/**
+ * @def HAS_PLACEMENT_DELETE
+ *
+ * Macro to indicate whether placement delete operators are supported on
+ * a certain compiler.  Some compilers, like Borland C++ Compiler 5.5.1
+ * and Digital Mars Compiler 8.42, do not support them, and the user
+ * must define this macro to \c 0 to make the program compile.  Also
+ * note that in that case memory leakage will occur if an exception is
+ * thrown in the initialization (constructor) of a dynamically created
+ * object.
+ */
+#ifndef HAS_PLACEMENT_DELETE
+#define HAS_PLACEMENT_DELETE 1
+#endif
+
+/**
+ * @def _DEBUG_NEW_REDEFINE_NEW
+ *
+ * Macro to indicate whether redefinition of \c new is wanted.  If one
+ * wants to define one's own &lt;code&gt;operator new&lt;/code&gt;, to call
+ * &lt;code&gt;operator new&lt;/code&gt; directly, or to call placement \c new, it
+ * should be defined to \c 0 to alter the default behaviour.  Unless, of
+ * course, one is willing to take the trouble to write something like:
+ * @code
+ * # ifdef new
+ * #   define _NEW_REDEFINED
+ * #   undef new
+ * # endif
+ *
+ * // Code that uses new is here
+ *
+ * # ifdef _NEW_REDEFINED
+ * #   ifdef DEBUG_NEW
+ * #     define new DEBUG_NEW
+ * #   endif
+ * #   undef _NEW_REDEFINED
+ * # endif
+ * @endcode
+ */
+#ifndef _DEBUG_NEW_REDEFINE_NEW
+#define _DEBUG_NEW_REDEFINE_NEW 1
+#endif
+
+/* Prototypes */
+int check_leaks();
+void* operator new(size_t size, const char* file, int line);
+void* operator new[](size_t size, const char* file, int line);
+#if HAS_PLACEMENT_DELETE
+void operator delete(void* pointer, const char* file, int line) throw();
+void operator delete[](void* pointer, const char* file, int line) throw();
+#endif
+#if defined(_MSC_VER) &amp;&amp; _MSC_VER &lt; 1300
+// MSVC 6 requires the following declarations; or the non-placement
+// new[]/delete[] will not compile.
+void* operator new[](size_t) throw(std::bad_alloc);
+void operator delete[](void*) throw();
+#endif
+
+/* Control variables */
+extern bool new_autocheck_flag; // default to true: call check_leaks() on exit
+extern bool new_verbose_flag;   // default to false: no verbose information
+extern FILE* new_output_fp;     // default to stderr: output to console
+extern const char* new_progname;// default to NULL; should be assigned argv[0]
+
+/**
+ * @def DEBUG_NEW
+ *
+ * The macro to catch file/line information on allocation.  If
+ * #_DEBUG_NEW_REDEFINE_NEW is not defined, one can use this macro
+ * directly; otherwise \c new will be defined to it, and one must use
+ * \c new instead.
+ */
+#define DEBUG_NEW new(__FILE__, __LINE__)
+
+# if _DEBUG_NEW_REDEFINE_NEW
+#   define new DEBUG_NEW
+# endif
+# ifdef _DEBUG_NEW_EMULATE_MALLOC
+#   include &lt;stdlib.h&gt;
+#   ifdef new
+#     define malloc(s) ((void*)(new char[s]))
+#   else
+#     define malloc(s) ((void*)(DEBUG_NEW char[s]))
+#   endif
+#   define free(p) delete[] (char*)(p)
+# endif
+
+/** Counter class for on-exit leakage check. */
+class __debug_new_counter
+{
+    static int _count;
+public:
+    __debug_new_counter();
+    ~__debug_new_counter();
+};
+/** Counting object for each file including debug_new.h. */
+static __debug_new_counter __debug_new_count;
+
+#endif // _DEBUG_NEW_H

Added: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_nvwa/fast_mutex.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_nvwa/fast_mutex.h	2007-08-29 17:49:57 UTC (rev 3567)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_nvwa/fast_mutex.h	2007-08-29 19:45:10 UTC (rev 3568)
@@ -0,0 +1,311 @@
+// -*- Mode: C++; tab-width: 4; c-basic-offset: 4; indent-tabs-mode: nil -*-
+// vim:tabstop=4:shiftwidth=4:expandtab:
+
+/*
+ * Copyright (C) 2004-2005 Wu Yongwei &lt;adah at users dot sourceforge dot net&gt;
+ *
+ * This software is provided 'as-is', without any express or implied
+ * warranty.  In no event will the authors be held liable for any
+ * damages arising from the use of this software.
+ *
+ * Permission is granted to anyone to use this software for any purpose,
+ * including commercial applications, and to alter it and redistribute
+ * it freely, subject to the following restrictions:
+ *
+ * 1. The origin of this software must not be misrepresented; you must
+ *    not claim that you wrote the original software. If you use this
+ *    software in a product, an acknowledgment in the product
+ *    documentation would be appreciated but is not required.
+ * 2. Altered source versions must be plainly marked as such, and must
+ *    not be misrepresented as being the original software.
+ * 3. This notice may not be removed or altered from any source
+ *    distribution.
+ *
+ * This file is part of Stones of Nvwa:
+ *      <A HREF="http://sourceforge.net/projects/nvwa">http://sourceforge.net/projects/nvwa</A>
+ *
+ */
+
+/**
+ * @file    fast_mutex.h
+ *
+ * A fast mutex implementation for POSIX and Win32.
+ *
+ * @version 1.18, 2005/05/06
+ * @author  Wu Yongwei
+ *
+ */
+
+#ifndef _FAST_MUTEX_H
+#define _FAST_MUTEX_H
+
+# if !defined(_NOTHREADS)
+#   if !defined(_WIN32THREADS) &amp;&amp; \
+            (defined(_WIN32) &amp;&amp; defined(_MT))
+//      Automatically use _WIN32THREADS when specifying -MT/-MD in MSVC,
+//      or -mthreads in MinGW GCC.
+#       define _WIN32THREADS
+#   elif !defined(_PTHREADS) &amp;&amp; \
+            defined(_REENTRANT)
+//      Automatically use _PTHREADS when specifying -pthread in GCC.
+//      N.B. I do not detect on _PTHREAD_H since libstdc++-v3 under
+//      Linux will silently include &lt;pthread.h&gt; anyway.
+#       define _PTHREADS
+#   endif
+# endif
+
+# if !defined(_PTHREADS) &amp;&amp; !defined(_WIN32THREADS) &amp;&amp; !defined(_NOTHREADS)
+#   define _NOTHREADS
+# endif
+
+# if defined(_NOTHREADS)
+#   if defined(_PTHREADS) || defined(_WIN32THREADS)
+#       undef _NOTHREADS
+#       error &quot;Cannot define multi-threaded mode with -D_NOTHREADS&quot;
+#       if defined(__MINGW32__) &amp;&amp; defined(_WIN32THREADS) &amp;&amp; !defined(_MT)
+#           error &quot;Be sure to specify -mthreads with -D_WIN32THREADS&quot;
+#       endif
+#   endif
+# endif
+
+# ifndef _FAST_MUTEX_CHECK_INITIALIZATION
+/**
+ * Macro to control whether to check for initialization status for each
+ * lock/unlock operation.  Defining it to a non-zero value will enable
+ * the check, so that the construction/destruction of a static object
+ * using a static fast_mutex not yet constructed or already destroyed
+ * will work (with lock/unlock operations ignored).  Defining it to zero
+ * will disable to check.
+ */
+#   define _FAST_MUTEX_CHECK_INITIALIZATION 1
+# endif
+
+# if defined(_PTHREADS) &amp;&amp; defined(_WIN32THREADS)
+//  Some C++ libraries have _PTHREADS defined even on Win32 platforms.
+//  Thus this hack.
+#   undef _PTHREADS
+# endif
+
+# ifdef _DEBUG
+#   include &lt;stdio.h&gt;
+#   include &lt;stdlib.h&gt;
+/** Macro for fast_mutex assertions.  Real version (for debug mode). */
+#   define _FAST_MUTEX_ASSERT(_Expr, _Msg) \
+        if (!(_Expr)) { \
+            fprintf(stderr, &quot;fast_mutex::%s\n&quot;, _Msg); \
+            abort(); \
+        }
+# else
+/** Macro for fast_mutex assertions.  Fake version (for release mode). */
+#   define _FAST_MUTEX_ASSERT(_Expr, _Msg) \
+        ((void)0)
+# endif
+
+# ifdef _PTHREADS
+#   include &lt;pthread.h&gt;
+/**
+ * Macro alias to `volatile' semantics.  Here it is truly volatile since
+ * it is in a multi-threaded (POSIX threads) environment.
+ */
+#   define __VOLATILE volatile
+    /**
+     * Class for non-reentrant fast mutexes.  This is the implementation
+     * for POSIX threads.
+     */
+    class fast_mutex
+    {
+        pthread_mutex_t _M_mtx_impl;
+#       if _FAST_MUTEX_CHECK_INITIALIZATION
+        bool _M_initialized;
+#       endif
+#       ifdef _DEBUG
+        bool _M_locked;
+#       endif
+    public:
+        fast_mutex()
+#       ifdef _DEBUG
+            : _M_locked(false)
+#       endif
+        {
+            ::pthread_mutex_init(&amp;_M_mtx_impl, NULL);
+#       if _FAST_MUTEX_CHECK_INITIALIZATION
+            _M_initialized = true;
+#       endif
+        }
+        ~fast_mutex()
+        {
+            _FAST_MUTEX_ASSERT(!_M_locked, &quot;~fast_mutex(): still locked&quot;);
+#       if _FAST_MUTEX_CHECK_INITIALIZATION
+            _M_initialized = false;
+#       endif
+            ::pthread_mutex_destroy(&amp;_M_mtx_impl);
+        }
+        void lock()
+        {
+#       if _FAST_MUTEX_CHECK_INITIALIZATION
+            if (!_M_initialized)
+                return;
+#       endif
+            ::pthread_mutex_lock(&amp;_M_mtx_impl);
+#       ifdef _DEBUG
+            // The following assertion should _always_ be true for a
+            // real `fast' pthread_mutex.  However, this assertion can
+            // help sometimes, when people forget to use `-lpthread' and
+            // glibc provides an empty implementation.  Having this
+            // assertion is also more consistent.
+            _FAST_MUTEX_ASSERT(!_M_locked, &quot;lock(): already locked&quot;);
+            _M_locked = true;
+#       endif
+        }
+        void unlock()
+        {
+#       if _FAST_MUTEX_CHECK_INITIALIZATION
+            if (!_M_initialized)
+                return;
+#       endif
+#       ifdef _DEBUG
+            _FAST_MUTEX_ASSERT(_M_locked, &quot;unlock(): not locked&quot;);
+            _M_locked = false;
+#       endif
+            ::pthread_mutex_unlock(&amp;_M_mtx_impl);
+        }
+    private:
+        fast_mutex(const fast_mutex&amp;);
+        fast_mutex&amp; operator=(const fast_mutex&amp;);
+    };
+# endif // _PTHREADS
+
+# ifdef _WIN32THREADS
+#   include &lt;windows.h&gt;
+/**
+ * Macro alias to `volatile' semantics.  Here it is truly volatile since
+ * it is in a multi-threaded (Win32 threads) environment.
+ */
+#   define __VOLATILE volatile
+    /**
+     * Class for non-reentrant fast mutexes.  This is the implementation
+     * for Win32 threads.
+     */
+    class fast_mutex
+    {
+        CRITICAL_SECTION _M_mtx_impl;
+#       if _FAST_MUTEX_CHECK_INITIALIZATION
+        bool _M_initialized;
+#       endif
+#       ifdef _DEBUG
+        bool _M_locked;
+#       endif
+    public:
+        fast_mutex()
+#       ifdef _DEBUG
+            : _M_locked(false)
+#       endif
+        {
+            ::InitializeCriticalSection(&amp;_M_mtx_impl);
+#       if _FAST_MUTEX_CHECK_INITIALIZATION
+            _M_initialized = true;
+#       endif
+        }
+        ~fast_mutex()
+        {
+            _FAST_MUTEX_ASSERT(!_M_locked, &quot;~fast_mutex(): still locked&quot;);
+#       if _FAST_MUTEX_CHECK_INITIALIZATION
+            _M_initialized = false;
+#       endif
+            ::DeleteCriticalSection(&amp;_M_mtx_impl);
+        }
+        void lock()
+        {
+#       if _FAST_MUTEX_CHECK_INITIALIZATION
+            if (!_M_initialized)
+                return;
+#       endif
+            ::EnterCriticalSection(&amp;_M_mtx_impl);
+#       ifdef _DEBUG
+            _FAST_MUTEX_ASSERT(!_M_locked, &quot;lock(): already locked&quot;);
+            _M_locked = true;
+#       endif
+        }
+        void unlock()
+        {
+#       if _FAST_MUTEX_CHECK_INITIALIZATION
+            if (!_M_initialized)
+                return;
+#       endif
+#       ifdef _DEBUG
+            _FAST_MUTEX_ASSERT(_M_locked, &quot;unlock(): not locked&quot;);
+            _M_locked = false;
+#       endif
+            ::LeaveCriticalSection(&amp;_M_mtx_impl);
+        }
+    private:
+        fast_mutex(const fast_mutex&amp;);
+        fast_mutex&amp; operator=(const fast_mutex&amp;);
+    };
+# endif // _WIN32THREADS
+
+# ifdef _NOTHREADS
+/**
+ * Macro alias to `volatile' semantics.  Here it is not truly volatile
+ * since it is in a single-threaded environment.
+ */
+#   define __VOLATILE
+    /**
+     * Class for non-reentrant fast mutexes.  This is the null
+     * implementation for single-threaded environments.
+     */
+    class fast_mutex
+    {
+#       ifdef _DEBUG
+        bool _M_locked;
+#       endif
+    public:
+        fast_mutex()
+#       ifdef _DEBUG
+            : _M_locked(false)
+#       endif
+        {
+        }
+        ~fast_mutex()
+        {
+            _FAST_MUTEX_ASSERT(!_M_locked, &quot;~fast_mutex(): still locked&quot;);
+        }
+        void lock()
+        {
+#       ifdef _DEBUG
+            _FAST_MUTEX_ASSERT(!_M_locked, &quot;lock(): already locked&quot;);
+            _M_locked = true;
+#       endif
+        }
+        void unlock()
+        {
+#       ifdef _DEBUG
+            _FAST_MUTEX_ASSERT(_M_locked, &quot;unlock(): not locked&quot;);
+            _M_locked = false;
+#       endif
+        }
+    private:
+        fast_mutex(const fast_mutex&amp;);
+        fast_mutex&amp; operator=(const fast_mutex&amp;);
+    };
+# endif // _NOTHREADS
+
+/** An acquistion-on-initialization lock class based on fast_mutex. */
+class fast_mutex_autolock
+{
+    fast_mutex&amp; _M_mtx;
+public:
+    explicit fast_mutex_autolock(fast_mutex&amp; __mtx) : _M_mtx(__mtx)
+    {
+        _M_mtx.lock();
+    }
+    ~fast_mutex_autolock()
+    {
+        _M_mtx.unlock();
+    }
+private:
+    fast_mutex_autolock(const fast_mutex_autolock&amp;);
+    fast_mutex_autolock&amp; operator=(const fast_mutex_autolock&amp;);
+};
+
+#endif // _FAST_MUTEX_H

Added: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_nvwa/static_assert.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_nvwa/static_assert.h	2007-08-29 17:49:57 UTC (rev 3567)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_nvwa/static_assert.h	2007-08-29 19:45:10 UTC (rev 3568)
@@ -0,0 +1,50 @@
+// -*- Mode: C++; tab-width: 4; c-basic-offset: 4; indent-tabs-mode: nil -*-
+// vim:tabstop=4:shiftwidth=4:expandtab:
+
+/*
+ * Copyright (C) 2004-2005 Wu Yongwei &lt;adah at users dot sourceforge dot net&gt;
+ *
+ * This software is provided 'as-is', without any express or implied
+ * warranty.  In no event will the authors be held liable for any
+ * damages arising from the use of this software.
+ *
+ * Permission is granted to anyone to use this software for any purpose,
+ * including commercial applications, and to alter it and redistribute
+ * it freely, subject to the following restrictions:
+ *
+ * 1. The origin of this software must not be misrepresented; you must
+ *    not claim that you wrote the original software. If you use this
+ *    software in a product, an acknowledgment in the product
+ *    documentation would be appreciated but is not required.
+ * 2. Altered source versions must be plainly marked as such, and must
+ *    not be misrepresented as being the original software.
+ * 3. This notice may not be removed or altered from any source
+ *    distribution.
+ *
+ * This file is part of Stones of Nvwa:
+ *      <A HREF="http://sourceforge.net/projects/nvwa">http://sourceforge.net/projects/nvwa</A>
+ *
+ */
+
+/**
+ * @file    static_assert.h
+ *
+ * Template class to check validity duing compile time (adapted from Loki).
+ *
+ * @version 1.2, 2005/11/22
+ * @author  Wu Yongwei
+ *
+ */
+
+#ifndef STATIC_ASSERT
+
+template &lt;bool&gt; struct __nvwa_compile_time_error;
+template &lt;&gt;     struct __nvwa_compile_time_error&lt;true&gt; {};
+
+#define STATIC_ASSERT(_Expr, _Msg) \
+    { \
+        __nvwa_compile_time_error&lt;((_Expr) != 0)&gt; ERROR_##_Msg; \
+        (void)ERROR_##_Msg; \
+    }
+
+#endif // STATIC_ASSERT

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/CMakeLists.txt
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/CMakeLists.txt	2007-08-29 17:49:57 UTC (rev 3567)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/CMakeLists.txt	2007-08-29 19:45:10 UTC (rev 3568)
@@ -1,20 +1,24 @@
-subdirs (PREORDER ADM_lavcodec)
-subdirs (PREORDER ADM_lavformat)
-subdirs (PREORDER ADM_lavutil)
-subdirs (PREORDER ADM_liba52)
-subdirs (PREORDER ADM_libMad)
-subdirs (PREORDER ADM_libMpeg2Dec)
-subdirs (PREORDER ADM_libmpeg2enc)
-subdirs (PREORDER ADM_libswscale)
-subdirs (PREORDER ADM_libtwolame)
-subdirs (PREORDER ADM_libwrapper)
-subdirs (PREORDER ADM_lvemux)
-subdirs (PREORDER ADM_mplex)
-subdirs (PREORDER ADM_smjs)
-subdirs (PREORDER ADM_utilities)
-subdirs (PREORDER ADM_xvidratectl)
-subdirs (PREORDER ADM_libpostproc)
-
-if(USE_FREETYPE)
-subdirs (PREORDER ADM_libass)
-endif(USE_FREETYPE)
+subdirs (PREORDER ADM_lavcodec)
+subdirs (PREORDER ADM_lavformat)
+subdirs (PREORDER ADM_lavutil)
+subdirs (PREORDER ADM_liba52)
+subdirs (PREORDER ADM_libMad)
+subdirs (PREORDER ADM_libMpeg2Dec)
+subdirs (PREORDER ADM_libmpeg2enc)
+subdirs (PREORDER ADM_libswscale)
+subdirs (PREORDER ADM_libtwolame)
+subdirs (PREORDER ADM_libwrapper)
+subdirs (PREORDER ADM_lvemux)
+subdirs (PREORDER ADM_mplex)
+subdirs (PREORDER ADM_smjs)
+subdirs (PREORDER ADM_utilities)
+subdirs (PREORDER ADM_xvidratectl)
+subdirs (PREORDER ADM_libpostproc)
+
+if(USE_FREETYPE)
+subdirs (PREORDER ADM_libass)
+endif(USE_FREETYPE)
+
+if (ADM_DEBUG AND FIND_LEAKS)
+subdirs (PREORDER ADM_nvwa)
+endif (ADM_DEBUG AND FIND_LEAKS)

Modified: branches/avidemux_2.4_branch/avidemux/ADM_osSupport/ADM_memsupport.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_osSupport/ADM_memsupport.cpp	2007-08-29 17:49:57 UTC (rev 3567)
+++ branches/avidemux_2.4_branch/avidemux/ADM_osSupport/ADM_memsupport.cpp	2007-08-29 19:45:10 UTC (rev 3568)
@@ -29,19 +29,25 @@
 #include &lt;math.h&gt;
 
 #include &quot;default.h&quot;
+#include &quot;ADM_assert.h&quot;
 
-#include &lt;ADM_assert.h&gt;
-
 #include &quot;ADM_osSupport/ADM_threads.h&quot;
 
 #undef memalign
 #undef malloc
 #undef free
 
-
 static uint32_t ADM_consumed=0;
 static admMutex memAccess(&quot;MemAccess&quot;);
 static int doMemStat=0;
+
+#if defined(ADM_DEBUG) &amp;&amp; defined(FIND_LEAKS)
+#define _DEBUG_NEW_CALLER_ADDRESS __builtin_return_address(0)
+extern void* operator new(size_t size, const char* file, int line);
+extern void operator delete(void* pointer, const char* file, int line) throw();
+extern size_t getSizeFromPointer(void* ptr);
+#endif
+
 extern &quot;C&quot; {
 
 void *av_malloc(unsigned int size);
@@ -68,6 +74,8 @@
 	printf(&quot;\tMemory consumed :%lu (MB)\n&quot;,ADM_consumed&gt;&gt;20);
 
 }
+
+#if !defined(ADM_DEBUG) || !defined(FIND_LEAKS)
 /**
     \fn ADM_calloc(size_t nbElm,size_t elSize);
     \brief Replacement for system Calloc using our memory management
@@ -253,4 +261,113 @@
 	
 
 }
+#else
+
+void *ADM_alloc(size_t size)
+{
+	return operator new(size, (char*)_DEBUG_NEW_CALLER_ADDRESS, 0);
+}
+
+void *ADM_calloc(size_t nbElm,size_t elSize)
+{
+  void *out = operator new(nbElm*elSize, (char*)_DEBUG_NEW_CALLER_ADDRESS, 0);
+
+  memset(out,0,nbElm*elSize);
+  return out;
+}
+
+char *ADM_strdup(const char *in)
+{
+    if(!in) return NULL;
+
+	int size = strlen(in) + 1;
+	char *out = (char *)(operator new(size, (char*)_DEBUG_NEW_CALLER_ADDRESS, 0));
+
+	memcpy(out, in, size);
+
+	return out;
+}
+
+void ADM_dezalloc(void *ptr)
+{
+	operator delete(ptr, (char*)_DEBUG_NEW_CALLER_ADDRESS, 0);
+}
+
+void *ADM_realloc(void *ptr, size_t newsize)
+{
+	void *nalloc;
+    
+    if(!ptr)
+		return operator new(newsize, (char*)_DEBUG_NEW_CALLER_ADDRESS, 0);
+
+    if(!newsize) 
+    {    
+		operator delete(ptr, (char*)_DEBUG_NEW_CALLER_ADDRESS, 0);
+		return NULL;
+    }
+
+	uint32_t size = getSizeFromPointer(ptr);
+
+	if (size &gt;= newsize)
+		return ptr;
+
+	nalloc = operator new(newsize, (char*)_DEBUG_NEW_CALLER_ADDRESS, 0);
+	memcpy(nalloc,ptr,getSizeFromPointer(ptr));
+	operator delete(ptr, (char*)_DEBUG_NEW_CALLER_ADDRESS, 0);
+
+	return nalloc;
+}
+
+extern &quot;C&quot;
+{
+void *av_malloc(unsigned int size)
+{
+	return operator new(size, (char*)_DEBUG_NEW_CALLER_ADDRESS, 0);
+}
+void av_freep(void *arg)
+{
+    void **ptr= (void**)arg;
+    av_free(*ptr);
+    *ptr = NULL;
+}
+
+void *av_mallocz(unsigned int size)
+{
+    void *ptr;
+
+	ptr = operator new(size, (char*)_DEBUG_NEW_CALLER_ADDRESS, 0);
+
+    if (ptr)
+        memset(ptr, 0, size);
+    return ptr;
+}
+}
+
+char *av_strdup(const char *s)
+{
+    char *ptr;
+    int len;
+    len = strlen(s) + 1;
+	ptr = (char *)operator new(len, (char*)_DEBUG_NEW_CALLER_ADDRESS, 0);
+
+    if (ptr)
+        memcpy(ptr, s, len);
+
+    return ptr;
+}
+
+void *av_realloc(void *ptr, unsigned int newsize)
+{
+	if(!ptr)
+		return operator new(newsize, (char*)_DEBUG_NEW_CALLER_ADDRESS, 0);
+	else
+		return ADM_realloc(ptr,newsize);
+}
+
+void av_free(void *ptr)
+{
+	if(ptr)
+		operator delete(ptr, (char*)_DEBUG_NEW_CALLER_ADDRESS, 0);
+}
+#endif
 // EOF

Modified: branches/avidemux_2.4_branch/avidemux/CMakeLists.txt
===================================================================
--- branches/avidemux_2.4_branch/avidemux/CMakeLists.txt	2007-08-29 17:49:57 UTC (rev 3567)
+++ branches/avidemux_2.4_branch/avidemux/CMakeLists.txt	2007-08-29 19:45:10 UTC (rev 3568)
@@ -189,6 +189,10 @@
 SET(ADM_LIBRARIES ${ADM_LIBRARIES}  ADM_libass)
 ENDIF(USE_FREETYPE)
 
+if (ADM_DEBUG AND FIND_LEAKS)
+SET(ADM_LIBRARIES ${ADM_LIBRARIES} ADM_nvwa)
+ENDIF (ADM_DEBUG AND FIND_LEAKS)
+
 FOREACH(_current ${ADM_LIBRARIES})
 add_libs_all_targets(${_current})
 ENDFOREACH(_current ${ADM_SUBDIR})

Modified: branches/avidemux_2.4_branch/config.h.cmake
===================================================================
--- branches/avidemux_2.4_branch/config.h.cmake	2007-08-29 17:49:57 UTC (rev 3567)
+++ branches/avidemux_2.4_branch/config.h.cmake	2007-08-29 19:45:10 UTC (rev 3568)
@@ -300,3 +300,6 @@
 
 /* Big endian CPU - SPARC or PowerPC */
 #cmakedefine WORDS_BIGENDIAN
+
+/* use Nvwa memory leak detector */
+#cmakedefine FIND_LEAKS


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000841.html">[Avidemux-svn-commit] r3567 - in	branches/avidemux_2.4_branch/avidemux:	ADM_libraries/ADM_utilities ADM_userInterfaces/ADM_commonUI	ADM_videoFilter
</A></li>
	<LI>Next message: <A HREF="000843.html">[Avidemux-svn-commit] r3569 - in	branches/avidemux_2.4_branch/avidemux: . ADM_libraries/ADM_nvwa
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#842">[ date ]</a>
              <a href="thread.html#842">[ thread ]</a>
              <a href="subject.html#842">[ subject ]</a>
              <a href="author.html#842">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">More information about the Avidemux-svn-commit
mailing list</a><br>
</body></html>
