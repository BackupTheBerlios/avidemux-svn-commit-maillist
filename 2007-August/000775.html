<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Avidemux-svn-commit] r3501 - in	branches/avidemux_2.4_branch/avidemux:	ADM_userInterfaces/ADM_GTK/ADM_dialog	ADM_userInterfaces/ADM_NONE/ADM_dialog	ADM_userInterfaces/ADM_QT4/ADM_dialog	ADM_userInterfaces/ADM_commonUI ADM_video ADM_videoFilter
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/avidemux-svn-commit/2007-August/index.html" >
   <LINK REL="made" HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r3501%20-%20in%0A%09branches/avidemux_2.4_branch/avidemux%3A%0A%09ADM_userInterfaces/ADM_GTK/ADM_dialog%0A%09ADM_userInterfaces/ADM_NONE/ADM_dialog%0A%09ADM_userInterfaces/ADM_QT4/ADM_dialog%0A%09ADM_userInterfaces/ADM_commonUI%20ADM_video%20ADM_videoFilter&In-Reply-To=%3C200708131347.l7DDlTve017466%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000774.html">
   <LINK REL="Next"  HREF="000776.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Avidemux-svn-commit] r3501 - in	branches/avidemux_2.4_branch/avidemux:	ADM_userInterfaces/ADM_GTK/ADM_dialog	ADM_userInterfaces/ADM_NONE/ADM_dialog	ADM_userInterfaces/ADM_QT4/ADM_dialog	ADM_userInterfaces/ADM_commonUI ADM_video ADM_videoFilter</H1>
    <B>mean at BerliOS</B> 
    <A HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r3501%20-%20in%0A%09branches/avidemux_2.4_branch/avidemux%3A%0A%09ADM_userInterfaces/ADM_GTK/ADM_dialog%0A%09ADM_userInterfaces/ADM_NONE/ADM_dialog%0A%09ADM_userInterfaces/ADM_QT4/ADM_dialog%0A%09ADM_userInterfaces/ADM_commonUI%20ADM_video%20ADM_videoFilter&In-Reply-To=%3C200708131347.l7DDlTve017466%40sheep.berlios.de%3E"
       TITLE="[Avidemux-svn-commit] r3501 - in	branches/avidemux_2.4_branch/avidemux:	ADM_userInterfaces/ADM_GTK/ADM_dialog	ADM_userInterfaces/ADM_NONE/ADM_dialog	ADM_userInterfaces/ADM_QT4/ADM_dialog	ADM_userInterfaces/ADM_commonUI ADM_video ADM_videoFilter">mean at mail.berlios.de
       </A><BR>
    <I>Mon Aug 13 15:47:29 CEST 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="000774.html">[Avidemux-svn-commit] r3500 -	branches/avidemux_2.4_branch/avidemux/ADM_encoder
</A></li>
        <LI>Next message: <A HREF="000776.html">[Avidemux-svn-commit] r3502 - in	branches/avidemux_2.4_branch/avidemux: ADM_video ADM_videoFilter
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#775">[ date ]</a>
              <a href="thread.html#775">[ thread ]</a>
              <a href="subject.html#775">[ subject ]</a>
              <a href="author.html#775">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: mean
Date: 2007-08-13 15:47:25 +0200 (Mon, 13 Aug 2007)
New Revision: 3501

Added:
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidHue.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidHue.h
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidSRT.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidSRT.h
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidSRTRender.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidSRTload.cpp
Removed:
   branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidHue.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidHue.h
   branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidSRT.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidSRT.h
   branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidSRTRender.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidSRTload.cpp
Modified:
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_hue.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_srt.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_NONE/ADM_dialog/DIA_none.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/DIA_none.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/DIA_srt.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/Q_hue.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/Q_srt.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_flyHue.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_flySrtPos.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_srt.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_video/CMakeLists.txt
   branches/avidemux_2.4_branch/avidemux/ADM_video/Makefile.am
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/CMakeLists.txt
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/Makefile.am
Log:
[Filters] Move hue and srt to their proper place, now that they use dialogFactory/flyDialog

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_hue.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_hue.cpp	2007-08-13 10:07:01 UTC (rev 3500)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_hue.cpp	2007-08-13 13:47:25 UTC (rev 3501)
@@ -38,7 +38,7 @@
 
 #include &quot;ADM_image.h&quot;
 #include &quot;ADM_video/ADM_genvideo.hxx&quot;
-#include &quot;ADM_video/ADM_vidHue.h&quot;
+#include &quot;ADM_videoFilter/ADM_vidHue.h&quot;
 #include &quot;DIA_flyDialog.h&quot;
 #include &quot;DIA_flyHue.h&quot;
 

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_srt.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_srt.cpp	2007-08-13 10:07:01 UTC (rev 3500)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_srt.cpp	2007-08-13 13:47:25 UTC (rev 3501)
@@ -43,7 +43,7 @@
 
 //#include &quot;ADM_video/ADM_vidFont.h&quot;
 class ADMfont;
-#include &quot;ADM_video/ADM_vidSRT.h&quot;
+#include &quot;ADM_videoFilter/ADM_vidSRT.h&quot;
 
 #include &quot;ADM_toolkit_gtk/ADM_gladeSupport.h&quot;
 #include &quot;ADM_toolkit_gtk/toolkit_gtk.h&quot;

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_NONE/ADM_dialog/DIA_none.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_NONE/ADM_dialog/DIA_none.cpp	2007-08-13 10:07:01 UTC (rev 3500)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_NONE/ADM_dialog/DIA_none.cpp	2007-08-13 13:47:25 UTC (rev 3501)
@@ -43,7 +43,7 @@
 #include &quot;ADM_encoder/adm_encmjpeg_param.h&quot;
 #include &quot;ADM_video/ADM_vidPartial_param.h&quot;
 #include &quot;ADM_video/ADM_vidEqualizer.h&quot;
-#include &quot;ADM_video/ADM_vidHue.h&quot;
+#include &quot;ADM_videoFilter/ADM_vidHue.h&quot;
 #include &quot;ADM_video/ADM_vobsubinfo.h&quot;
 #include &quot;ADM_video/ADM_vidVobSub.h&quot;
 #include &quot;ADM_videoFilter/ADM_vidChromaShift_param.h&quot;
@@ -52,7 +52,7 @@
 #include &quot;ADM_video/ADM_vidContrast.h&quot;
 //#include &quot;ADM_video/ADM_vidFont.h&quot;
 class ADMfont;
-#include &quot;ADM_video/ADM_vidSRT.h&quot;
+#include &quot;ADM_videoFilter/ADM_vidSRT.h&quot;
 #include &quot;ADM_audiofilter/audioencoder_vorbis_param.h&quot;    
     
 #include &quot;ADM_audiofilter/audioeng_buildfilters.h&quot;

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/DIA_none.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/DIA_none.cpp	2007-08-13 10:07:01 UTC (rev 3500)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/DIA_none.cpp	2007-08-13 13:47:25 UTC (rev 3501)
@@ -43,7 +43,7 @@
 #include &quot;ADM_encoder/adm_encmjpeg_param.h&quot;
 #include &quot;ADM_video/ADM_vidPartial_param.h&quot;
 #include &quot;ADM_video/ADM_vidEqualizer.h&quot;
-#include &quot;ADM_video/ADM_vidHue.h&quot;
+#include &quot;ADM_videoFilter/ADM_vidHue.h&quot;
 #include &quot;ADM_video/ADM_vobsubinfo.h&quot;
 #include &quot;ADM_video/ADM_vidVobSub.h&quot;
 #include &quot;ADM_videoFilter/ADM_vidChromaShift_param.h&quot;
@@ -52,7 +52,7 @@
 #include &quot;ADM_video/ADM_vidContrast.h&quot;
 //#include &quot;ADM_video/ADM_vidFont.h&quot;
 class ADMfont;
-#include &quot;ADM_video/ADM_vidSRT.h&quot;
+#include &quot;ADM_videoFilter/ADM_vidSRT.h&quot;
 #include &quot;ADM_audiofilter/audioencoder_vorbis_param.h&quot;    
     
 #include &quot;ADM_audiofilter/audioeng_buildfilters.h&quot;

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/DIA_srt.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/DIA_srt.cpp	2007-08-13 10:07:01 UTC (rev 3500)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/DIA_srt.cpp	2007-08-13 13:47:25 UTC (rev 3501)
@@ -29,7 +29,7 @@
 #include &quot;ADM_encoder/ADM_vidEncode.hxx&quot;
 //#include &quot;ADM_video/ADM_vidFont.h&quot;
 class ADMfont;
-#include &quot;ADM_video/ADM_vidSRT.h&quot;
+#include &quot;ADM_videoFilter/ADM_vidSRT.h&quot;
 /**
       \fn DIA_x264
       \brief Dialog for x264 codec settings

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/Q_hue.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/Q_hue.cpp	2007-08-13 10:07:01 UTC (rev 3500)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/Q_hue.cpp	2007-08-13 13:47:25 UTC (rev 3501)
@@ -37,7 +37,7 @@
 #include &quot;ADM_assert.h&quot;
 #include &quot;DIA_flyDialog.h&quot;
 #include &quot;DIA_flyDialogQt4.h&quot;
-#include &quot;ADM_video/ADM_vidHue.h&quot;
+#include &quot;ADM_videoFilter/ADM_vidHue.h&quot;
 #include &quot;DIA_flyHue.h&quot;
 
 //

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/Q_srt.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/Q_srt.cpp	2007-08-13 10:07:01 UTC (rev 3500)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/Q_srt.cpp	2007-08-13 13:47:25 UTC (rev 3501)
@@ -36,7 +36,7 @@
 
 //#include &quot;ADM_video/ADM_vidFont.h&quot;
 class ADMfont;
-#include &quot;ADM_video/ADM_vidSRT.h&quot;
+#include &quot;ADM_videoFilter/ADM_vidSRT.h&quot;
 
 #include &quot;DIA_flySrtPos.h&quot;
 

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_flyHue.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_flyHue.cpp	2007-08-13 10:07:01 UTC (rev 3500)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_flyHue.cpp	2007-08-13 13:47:25 UTC (rev 3501)
@@ -31,7 +31,7 @@
 #include &quot;ADM_colorspace/ADM_rgb.h&quot;
 #include &quot;ADM_image.h&quot;
 #include &quot;ADM_video/ADM_genvideo.hxx&quot;
-#include &quot;ADM_video/ADM_vidHue.h&quot;
+#include &quot;ADM_videoFilter/ADM_vidHue.h&quot;
 #include &quot;DIA_flyDialog.h&quot;
 #include &quot;DIA_flyHue.h&quot;
 

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_flySrtPos.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_flySrtPos.cpp	2007-08-13 10:07:01 UTC (rev 3500)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_flySrtPos.cpp	2007-08-13 13:47:25 UTC (rev 3501)
@@ -26,7 +26,7 @@
 #include &quot;ADM_video/ADM_genvideo.hxx&quot;
 class ADMfont;
 //#include &quot;ADM_video/ADM_vidFont.h&quot;
-#include &quot;ADM_video/ADM_vidSRT.h&quot;
+#include &quot;ADM_videoFilter/ADM_vidSRT.h&quot;
 
 #include &quot;DIA_flyDialog.h&quot;
 #include &quot;DIA_flySrtPos.h&quot;

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_srt.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_srt.cpp	2007-08-13 10:07:01 UTC (rev 3500)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_srt.cpp	2007-08-13 13:47:25 UTC (rev 3501)
@@ -32,7 +32,7 @@
 #include &quot;ADM_encoder/ADM_vidEncode.hxx&quot;
 //#include &quot;ADM_video/ADM_vidFont.h&quot;
 class ADMfont;
-#include &quot;ADM_video/ADM_vidSRT.h&quot;
+#include &quot;ADM_videoFilter/ADM_vidSRT.h&quot;
 #include &quot;ADM_colorspace/colorspace.h&quot;
 /*****************************************************************/
 extern int DIA_colorSel(uint8_t *r, uint8_t *g, uint8_t *b);

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidHue.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidHue.cpp	2007-08-13 10:07:01 UTC (rev 3500)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidHue.cpp	2007-08-13 13:47:25 UTC (rev 3501)
@@ -1,180 +0,0 @@
-/***************************************************************************
-                          Hue/Saturation filter ported from mplayer 
- (c) Michael Niedermayer
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-#include &lt;stdio.h&gt;
-#include &lt;math.h&gt;
-
-#include &lt;stdlib.h&gt;
-#include &lt;string.h&gt;
-#include &lt;ADM_assert.h&gt;
-
-#include &quot;config.h&quot;
-#include &quot;fourcc.h&quot;
-#include &quot;avio.hxx&quot;
-#include &quot;config.h&quot;
-#include &quot;avi_vars.h&quot;
-#ifdef HAVE_ENCODER
-
-
-#include &quot;ADM_toolkit/toolkit.hxx&quot;
-#include &quot;ADM_editor/ADM_edit.hxx&quot;
-#include &quot;ADM_video/ADM_genvideo.hxx&quot;
-#include &quot;ADM_filter/video_filters.h&quot;
-#include &quot;ADM_userInterfaces/ADM_commonUI/DIA_enter.h&quot;
-#include &quot;ADM_video/ADM_cache.h&quot;
-
-#include &quot;admmangle.h&quot;
-#include &quot;ADM_vidHue.h&quot;
-static FILTER_PARAM HueParam={2,{&quot;hue&quot;,&quot;saturation&quot;}};
-
-extern uint8_t DIA_getHue(Hue_Param *param, AVDMGenericVideoStream *in);
-
-class  ADMVideoHue:public AVDMGenericVideoStream
-{
-
-  protected:
-    AVDMGenericVideoStream  *_in;           
-    virtual char            *printConf(void);
-            void            update(void);
-            Hue_Param       *_param;    
-            VideoCache      *vidCache; 
-            float           _hue;
-            float           _saturation;
-  public:
-                
-                        ADMVideoHue(  AVDMGenericVideoStream *in,CONFcouple *setup);
-    virtual             ~ADMVideoHue();
-    virtual uint8_t     configure(AVDMGenericVideoStream *in);
-    virtual uint8_t     getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
-                                          ADMImage *data,uint32_t *flags);
-
-             uint8_t     getCoupledConf( CONFcouple **couples);
-}     ;
-
-SCRIPT_CREATE(hue_script,ADMVideoHue,HueParam);
-BUILD_CREATE(hue_create,ADMVideoHue);
-
-void HueProcess_C(uint8_t *udst, uint8_t *vdst, uint8_t *usrc, uint8_t *vsrc, int dststride, int srcstride,
-		    int w, int h, float hue, float sat)
-{
-	int i;
-	const int s= (int)rint(sin(hue) * (1&lt;&lt;16) * sat);
-	const int c= (int)rint(cos(hue) * (1&lt;&lt;16) * sat);
-
-	while (h--) {
-		for (i = 0; i&lt;w; i++)
-		{
-			const int u= usrc[i] - 128;
-			const int v= vsrc[i] - 128;
-			int new_u= (c*u - s*v + (1&lt;&lt;15) + (128&lt;&lt;16))&gt;&gt;16;
-			int new_v= (s*u + c*v + (1&lt;&lt;15) + (128&lt;&lt;16))&gt;&gt;16;
-			if(new_u &amp; 768) new_u= (-new_u)&gt;&gt;31;
-			if(new_v &amp; 768) new_v= (-new_v)&gt;&gt;31;
-			udst[i]= new_u;
-			vdst[i]= new_v;
-		}
-		usrc += srcstride;
-		vsrc += srcstride;
-		udst += dststride;
-		vdst += dststride;
-	}
-}
-
-
-uint8_t ADMVideoHue::configure(AVDMGenericVideoStream *in)
-{
-uint8_t r=0;
-  _in=in;   
-  r=  DIA_getHue(_param, in);
-  if(r) update();
-  return r;  
-}
-char *ADMVideoHue::printConf( void )
-{
-  static char buf[50];
-        
-  sprintf((char *)buf,&quot; Hue :%2.2f %2.2f&quot;,_param-&gt;hue,_param-&gt;saturation);
-  return buf;
-}
-
-ADMVideoHue::ADMVideoHue(  AVDMGenericVideoStream *in,CONFcouple *couples)
-{
-  
-  _in=in;         
-  memcpy(&amp;_info,_in-&gt;getInfo(),sizeof(_info));    
-  _info.encoding=1; 
-  _param=new  Hue_Param;
-  if(couples)
-  {                 
-    GET(hue);    
-    GET(saturation); 
-  }
-  else
-  {
-    _param-&gt;hue =0.0;                
-    _param-&gt;saturation=1.0;
-  }      
-  vidCache=new VideoCache(1,_in);
-  update();
-}
-void ADMVideoHue::update(void)
-{
-    _hue=_param-&gt;hue*M_PI/180.;
-    _saturation=(100+_param-&gt;saturation)/100;
-}
-ADMVideoHue::~ADMVideoHue()
-{
-  delete _param;
-  delete vidCache;
-  
-}
-uint8_t ADMVideoHue::getCoupledConf( CONFcouple **couples)
-{
-  ADM_assert(_param);
-  *couples=new CONFcouple(2);
-
-
-                CSET(hue);
-                CSET(saturation);
-                return 1;
-}
-
-
-uint8_t ADMVideoHue::getFrameNumberNoAlloc(uint32_t frame,
-                                             uint32_t *len,
-                                             ADMImage *data,
-                                             uint32_t *flags)
-{
-  ADMImage *mysrc=NULL;
-  
-
-  if(frame&gt;=_info.nb_frames) return 0;
-  
-  mysrc=vidCache-&gt;getImage(frame);
-  if(!mysrc) return 0;
-  memcpy(YPLANE(data),YPLANE(mysrc),_info.width*_info.height);
-  HueProcess_C(VPLANE(data), UPLANE(data),
-        VPLANE(mysrc), UPLANE(mysrc),
-        _info.width&gt;&gt;1,_info.width&gt;&gt;1,
-        _info.width&gt;&gt;1,_info.height&gt;&gt;1, 
-        _hue, _saturation);
- 
-  vidCache-&gt;unlockAll();
-  
-  
-  return 1;
-}
-
-  
-#endif

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidHue.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidHue.h	2007-08-13 10:07:01 UTC (rev 3500)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidHue.h	2007-08-13 13:47:25 UTC (rev 3501)
@@ -1,11 +0,0 @@
-/*
-
-*/
-
-typedef struct Hue_Param
-{
-  float     hue ;           /* -180 to 180 */
-  float     saturation;     /* -180 to 180 */
-}Hue_Param;
- void HueProcess_C(uint8_t *udst, uint8_t *vdst, uint8_t *usrc, uint8_t *vsrc, int dststride, int srcstride,
-		    int w, int h, float hue, float sat);

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidSRT.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidSRT.cpp	2007-08-13 10:07:01 UTC (rev 3500)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidSRT.cpp	2007-08-13 13:47:25 UTC (rev 3501)
@@ -1,420 +0,0 @@
-/***************************************************************************
-                          ADM_vidSRT.cpp  -  description
-                             -------------------
-    begin                : Thu Dec 12 2002
-    copyright            : (C) 2002 by mean
-    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#include &quot;config.h&quot;
-
-#include &lt;stdio.h&gt;
-#include &lt;stdlib.h&gt;
-#include &lt;string.h&gt;
-#include &lt;math.h&gt;
-#include &lt;math.h&gt;
-#include &lt;iconv.h&gt;
-
-
-#ifdef USE_FREETYPE
-
-#include &quot;fourcc.h&quot;
-#include &quot;avio.hxx&quot;
-
-#include &quot;avi_vars.h&quot;
-
-#include &quot;ADM_toolkit/toolkit.hxx&quot;
-
-
-#include &quot;ADM_editor/ADM_edit.hxx&quot;
-#include &quot;ADM_video/ADM_genvideo.hxx&quot;
-
-#include &quot;ADM_video/ADM_vidFont.h&quot;
-#include &quot;ADM_video/ADM_vidSRT.h&quot;
-
-#include &lt;ADM_assert.h&gt;
-
-#include &quot;ADM_osSupport/ADM_debugID.h&quot;
-#define MODULE_NAME MODULE_FILTER
-#include &quot;ADM_osSupport/ADM_debug.h&quot;
-#include &quot;ADM_filter/video_filters.h&quot;
-
-#include &lt;prefs.h&gt;
-
-static FILTER_PARAM subParam={15,{&quot;_fontsize&quot;,&quot;_subname&quot;,&quot;_fontname&quot;,&quot;_charset&quot;,
-				&quot;_baseLine&quot;,&quot;_Y_percent&quot;,&quot;_U_percent&quot;,&quot;_V_percent&quot;,
-				&quot;_selfAdjustable&quot;,&quot;_delay&quot;,&quot;_useBackgroundColor&quot;,&quot;_bg_Y_percent&quot;,
-      				&quot;_bg_U_percent&quot;,&quot;_bg_V_percent&quot;,&quot;_blend&quot;}};
-
-SCRIPT_CREATE(subtitle_script,ADMVideoSubtitle,subParam);
-
-BUILD_CREATE(subtitle_create,ADMVideoSubtitle);
-
-//__________________________________________________________________
-
-//_______________________________________________________________
-
-//__________________________________________________________________
-
-char 								*ADMVideoSubtitle::printConf(void)
- {
-	  	static char buf[50];
- 	
- 				sprintf((char *)buf,&quot;Subtitle &quot;);
-        return buf;
-	}
-
-//--------------------------------------------------------	
-ADMVideoSubtitle::ADMVideoSubtitle(AVDMGenericVideoStream *in,CONFcouple *couples)
-{
-
-  uint32_t frame;
-//  char c;
-
-  _uncompressed=NULL;
-  _font=NULL;
-
-
-  _in=in;
-  memcpy(&amp;_info,_in-&gt;getInfo(),sizeof(_info));
-
-	frame=3*_in-&gt;getInfo()-&gt;width*_in-&gt;getInfo()-&gt;height;
-
-	_subs=NULL;
-	_fd=NULL;
- 	_line=0;
-	_oldframe=0;
-	_oldline=0;
-	_font = new ADMfont();	
-	if(couples)
-	{
-                int32_t b;
-			SUBCONF *_param;
-			_conf=NEW( SUBCONF);
-
-
-			_param=_conf; // keep macro happy
-
-			GET(_fontsize);
-			GET(_subname);
-			GET(_fontname);
-			GET(_charset);
-			GET(_baseLine);
-			GET(_Y_percent);
-			GET(_U_percent);
-			GET(_V_percent);
-			GET(_selfAdjustable);
-			GET(_delay);
-			GET(_useBackgroundColor);
-			GET(_bg_Y_percent);
-      			GET(_bg_U_percent);
-      			GET(_bg_V_percent);
-//                        GET(_blend);
-                        couples-&gt;getCouple(&quot;_blend&quot;,&amp;b);
-                        _param-&gt;_blend=(BlendMode)b;
-			if(_conf-&gt;_baseLine&gt;_info.height-_conf-&gt;_fontsize*SRT_MAX_LINE)
-                        {
-                                printf(&quot;Base exceeded : base :%lu height :%lu bottom:%lu\n&quot;,
-                                        _conf-&gt;_baseLine,_info.height,_info.height-_conf-&gt;_fontsize*SRT_MAX_LINE);
-                                _conf-&gt;_baseLine=_conf-&gt;_fontsize*SRT_MAX_LINE;
-                        }
-
-                    char *ft,*sub;
-                        ft=(char *)ADM_alloc(500);
-                        sub=(char *)ADM_alloc(500);
-                        strcpy(ft,(char *)_conf-&gt;_subname); 
-                        _conf-&gt;_subname=(ADM_filename *)ft;
-                        strcpy(sub,(char *)_conf-&gt;_fontname); 
-                        _conf-&gt;_fontname=(ADM_filename *)sub;
-
-                        sub=(char *)ADM_alloc(500);
-                        strcpy(sub,_conf-&gt;_charset);
-                        _conf-&gt;_charset=sub;
-                        loadSubtitle();
-                        loadFont();
-
-	}
-	else
-	{
-			_conf=NEW( SUBCONF);
-
-			_conf-&gt;_fontname=(ADM_filename *)ADM_alloc(500);
-			_conf-&gt;_subname=(ADM_filename *)ADM_alloc(500);
-			_conf-&gt;_charset=(char *)ADM_alloc(500);
-			_conf-&gt;_fontname[0]=0;
-			_conf-&gt;_subname[0]=0;
-			_conf-&gt;_charset[0]=0;
-			
-			
-			_conf-&gt;_baseLine=_info.height-24*SRT_MAX_LINE;
-			_conf-&gt;_Y_percent=255;
-			_conf-&gt;_U_percent=0;
-			_conf-&gt;_V_percent=0;
-                        _conf-&gt;_fontsize=24; 
-			_conf-&gt;_selfAdjustable=0;
-			_conf-&gt;_delay=0;
-			_conf-&gt;_useBackgroundColor=0;
-			
-			_conf-&gt;_bg_Y_percent=0;
-			_conf-&gt;_bg_U_percent=0;
-			_conf-&gt;_bg_V_percent=0;
-                        _conf-&gt;_blend=BLEND_SOLID;
-
-			prefs-&gt;get(FILTERS_SUBTITLE_FONTSIZE,&amp;(_conf-&gt;_fontsize));
-			prefs-&gt;get(FILTERS_SUBTITLE_YPERCENT,&amp;(_conf-&gt;_Y_percent));
-			prefs-&gt;get(FILTERS_SUBTITLE_UPERCENT,&amp;(_conf-&gt;_U_percent));
-			prefs-&gt;get(FILTERS_SUBTITLE_VPERCENT,&amp;(_conf-&gt;_V_percent));
-			prefs-&gt;get(FILTERS_SUBTITLE_SELFADJUSTABLE,&amp;(_conf-&gt;_selfAdjustable));			
-			prefs-&gt;get(FILTERS_SUBTITLE_USEBACKGROUNDCOLOR,&amp;(_conf-&gt;_useBackgroundColor));
-			
-			// _conf-&gt;_fontname, ... are used as memory for a dialog
-			// later. we can't used the length of the current string
-			{ char *tmp;
-			   prefs-&gt;get(FILTERS_SUBTITLE_FONTNAME,&amp;tmp);
-			   strcpy((char *)_conf-&gt;_fontname,tmp);
-			   ADM_dealloc(tmp);
-			   
-			   prefs-&gt;get(FILTERS_SUBTITLE_CHARSET,&amp;tmp);
-			   strcpy(_conf-&gt;_charset,tmp); 
-                           ADM_dealloc(tmp);
-			}
-			
-	}
-
-  
-  	_info.encoding=1;
-
-
-	_bitmap=0xffffffff;
-#define BITMAP_SIZE _info.width*_conf-&gt;_fontsize*SRT_MAX_LINE
-	_bitmapBuffer=new uint8_t[_info.width*_info.height];
-	_maskBuffer=new uint8_t[_info.width*_info.height];
-  _bgBitmapBuffer=new uint8_t[(_info.width*_info.height)&gt;&gt;1];
-	_bgMaskBuffer=new uint8_t[_info.width*_info.height];
-        _dirty=new uint8_t[_info.height];
-	ADM_assert(_bitmapBuffer);
-	ADM_assert(_maskBuffer);
-	ADM_assert(_bgBitmapBuffer);
-	ADM_assert(_bgMaskBuffer);
-        ADM_assert(_dirty);
-}
-uint8_t	ADMVideoSubtitle::loadSubtitle( void )
-{
-unsigned char c,d;
-			_fd=fopen((char *)_conf-&gt;_subname,&quot;rt&quot;);
-			if(!_fd)
-			{
-                          GUI_Error_HIG(_(&quot;Could not open subtitle file&quot;), NULL);
-				return 0;
-			}
-			// Try to detect utf16 files			
-			c=fgetc(_fd);
-			// Skip utf identifier if any
-			if( (c&amp;0xef)==0xef)
-			{
-                          int count=4;
-                                while(count-- &amp;&amp; c&amp;0x80) c=fgetc(_fd);
-			}
-			switch(c)
-			{
-			case '{' :
-						loadSubTitle();
-						break;
-			case '1' :
-						loadSRT();
-						break;
-			default:
-                          GUI_Error_HIG(_(&quot;Cannot identify subtitle format&quot;), NULL);
-			}
-
-  // Apply delay to subtitles
-  
-  aprintf(&quot;[debug] DELAY %d\n&quot;, _conf-&gt;_delay);
-  if(_conf-&gt;_delay)
-  {
-  	int32_t newStartTime;
-	int32_t newEndTime;
-	for(uint32_t i=0;i&lt;_line;i++) 
-	{
-		aprintf(&quot;[debug] BEFORE DELAY (%d) %d %d\n&quot;,i, _subs[i].startTime,_subs[i].endTime);
-		newStartTime=_subs[i].startTime;
-		newStartTime+=_conf-&gt;_delay;
-		_subs[i].startTime=(newStartTime);
-		newEndTime=_subs[i].endTime;
-		newEndTime+=_conf-&gt;_delay;
-		_subs[i].endTime=(newEndTime);
-		// put them at infinit display time
-		// should get rid of them
-		if(newEndTime&lt;0 || newStartTime&lt;0)
-		{
-			_subs[i].startTime=_subs[i].endTime=0;
-		}
-		aprintf(&quot;[debug] AFTER DELAY (%d) %d %d\n&quot;,i, _subs[i].startTime,_subs[i].endTime);
-  	}
-  }
-
-
-	fclose(_fd);
-	_fd=NULL;
-	_bitmap=0xffffffff;
-	if(_line)	// that way we will have the first sub
-		_oldline=_line-1;
-	return 1;
-}
-uint8_t	ADMVideoSubtitle::getCoupledConf( CONFcouple **couples)
-{
-SUBCONF *_param;
-
-			_param=_conf; // keep macro happy
-			ADM_assert(_param);
-			*couples=new CONFcouple(15);
-
-			CSET(_fontsize);
-			CSET(_subname);
-			CSET(_fontname);
-			CSET(_charset);
-			CSET(_baseLine);
-			CSET(_Y_percent);
-			CSET(_U_percent);
-			CSET(_V_percent);
-			CSET(_selfAdjustable);
-			CSET(_delay);
-			CSET(_useBackgroundColor);
-			CSET(_bg_Y_percent);
-			CSET(_bg_U_percent);
-			CSET(_bg_V_percent);
-                        (*couples)-&gt;setCouple(&quot;_blend&quot;,(uint32_t)_param-&gt;_blend);
-
-		return 1;
-
-}
-//__________________________________________________________________
-
-ADMVideoSubtitle::~ADMVideoSubtitle()
-{
-
-		if(_bitmapBuffer)
-			{
-				delete [] _bitmapBuffer;
-				_bitmapBuffer=0;
-			}
-		if(_maskBuffer)
-			{
-				delete [] _maskBuffer;
-				_maskBuffer=0;
-			}
-
- 		if(_bgBitmapBuffer) 
-			{
-				delete [] _bgBitmapBuffer;
-				_bgBitmapBuffer=0;
-			}
- 
-		if(_bgMaskBuffer) 
-			{
-				delete [] _bgMaskBuffer;
-				_bgMaskBuffer=0;
-			}
-                if(_dirty)
-                {
-                                delete [] _dirty;
-                                _dirty=0;
-                }
-
-		if(_fd)
-		{
-				fclose(_fd);
-				_fd=NULL;
-		}
-		if(_subs)
-		{
-				for(uint32_t i=0;i&lt;_line;i++)
-				{
-					if(_subs[i].nbLine)
-					{
-					for(uint32_t k=0;k&lt;_subs[i].nbLine;k++)
-					{					
-						if(_subs[i].string[k])
-						{
-							delete [] _subs[i].string[k];
-							_subs[i].string[k]=NULL;
-						}
-					}					
-					
-					delete _subs[i].string;
-					_subs[i].string=NULL;
-					delete _subs[i].lineSize;
-					_subs[i].lineSize=NULL;
-					}
-				}
-				delete [] _subs;
-				_subs=NULL;
-		}
-	if(_conf)
-	{
-			ADM_dealloc(_conf-&gt;_subname);
-			ADM_dealloc(_conf-&gt;_fontname);
-			ADM_dealloc(_conf-&gt;_charset);
-
-		 	DELETE(_conf);
-	}
-	if(_font)
-	{
-		delete _font;
-		_font=NULL;
-	}
-}
-
-uint8_t DIA_srt(AVDMGenericVideoStream *source, SUBCONF *param);
-    
-uint8_t ADMVideoSubtitle::configure(AVDMGenericVideoStream *instream)
-{
-  
-  UNUSED_ARG(instream);
-//char c;
-uint8_t ret=0;
-int charset=0;
-uint32_t l,f;
-
-                        
-          if(DIA_srt(	instream,_conf))
-          {
-            printf(&quot;\n Font : %s&quot;, _conf-&gt;_fontname);
-            printf(&quot;\n Sub  : %s&quot;, _conf-&gt;_subname);
-            printf(&quot;\n Font size : %ld&quot;,_conf-&gt;_fontsize);
-            printf(&quot;\n Charset : %d&quot;,charset);
-            printf(&quot;\n Y : %ld&quot;,_conf-&gt;_Y_percent);
-            printf(&quot;\n U : %ld&quot;,_conf-&gt;_U_percent);
-            printf(&quot;\n V : %ld&quot;,_conf-&gt;_V_percent);
-
-
-            loadSubtitle();
-            loadFont();
-                        
-            prefs-&gt;set(FILTERS_SUBTITLE_FONTNAME,
-                    (ADM_filename *)_conf-&gt;_fontname);
-            prefs-&gt;set(FILTERS_SUBTITLE_CHARSET,
-                    _conf-&gt;_charset);
-            prefs-&gt;set(FILTERS_SUBTITLE_FONTSIZE,_conf-&gt;_fontsize);
-            prefs-&gt;set(FILTERS_SUBTITLE_YPERCENT,_conf-&gt;_Y_percent);
-            prefs-&gt;set(FILTERS_SUBTITLE_UPERCENT,_conf-&gt;_U_percent);
-            prefs-&gt;set(FILTERS_SUBTITLE_VPERCENT,_conf-&gt;_V_percent);
-            prefs-&gt;set(FILTERS_SUBTITLE_SELFADJUSTABLE,
-                        _conf-&gt;_selfAdjustable);
-            prefs-&gt;set(FILTERS_SUBTITLE_USEBACKGROUNDCOLOR,
-                        _conf-&gt;_useBackgroundColor);
-            ret=1;
-        }
-        return ret;
-
-}
-#endif
-

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidSRT.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidSRT.h	2007-08-13 10:07:01 UTC (rev 3500)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidSRT.h	2007-08-13 13:47:25 UTC (rev 3501)
@@ -1,128 +0,0 @@
-/***************************************************************************
-                          ADM_vidSRT.h  -  description
-                             -------------------
-    begin                : Thu Dec 12 2002
-    copyright            : (C) 2002 by mean
-    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
-    
-    Lots of bugfixes / enhancement by Daniel Lima
-    
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#ifdef USE_FREETYPE
-
-#define SRT_MAX_LINE 3
-#define SRT_MAX_LINE_LENGTH 512
-
-#define ADM_GLYPH_T uint16_t 
-// UTF16 -&gt; Ascii
-
-#define ADM_ASC(x) x
-
-typedef struct subLine
-{
-  
-	uint32_t 		startTime;
-	uint32_t 		endTime;
-	uint32_t		nbLine;
-	uint32_t		*lineSize;
-	ADM_GLYPH_T		**string;
-	
-}subLine;
-
-typedef enum 
-{
-        BLEND_SOLID=1,
-        BLEND_DOTTED,
-        BLEND_DIMMER
-}BlendMode;
-
-typedef struct SUBCONF
-{
-		uint32_t _fontsize;
-		uint32_t _baseLine;
-
-  /** YUV font color components */
-		int32_t    _Y_percent;
-		int32_t    _U_percent;
-		int32_t    _V_percent;
-		ADM_filename	*_fontname;
-		ADM_filename	*_subname;
-		char 		*_charset;
-		uint32_t	_selfAdjustable;   /** Automatic line breaks */
-		int32_t		_delay;            
-		/** Wait x miliseconds before show subtitles. If negative, it will to show subtitles x */
-		/* miliseconds before. */
-
-
-		uint32_t	_useBackgroundColor;
-
-  /** YUV background color components */
-		int32_t   _bg_Y_percent;
-		int32_t   _bg_U_percent;
-		int32_t   _bg_V_percent;
-                BlendMode _blend;
-
-
-	}SUBCONF;
-
-  class  ADMVideoSubtitle:public AVDMGenericVideoStream
- {
-
- protected:
-
-	    	SUBCONF					*_conf;		
-       virtual char 					*printConf(void) ;
-        FILE						*_fd;
-        uint8_t						loadSubTitle( void );
-	uint8_t  					loadSRT( void )        ;
-        uint32_t					_line;
-        subLine						*_subs;
-        uint32_t					_oldframe;
-        uint32_t					_oldline;
-        uint32_t					_bitmap;
-        uint32_t					search(uint32_t time);
-        void 						displayString(subLine *string);
-	void 						displayString_autoadj(char *string);
-        void 						displayChar(uint32_t w,uint32_t h,char c);
-  	uint32_t					displayLine(ADM_GLYPH_T *string,uint32_t line, uint32_t len);
-  
-	uint8_t 					lowPass(uint8_t *src, uint8_t *dst, uint32_t w, uint32_t h);
-	uint8_t 					decimate(uint8_t *src, uint8_t *dst, uint32_t w, uint32_t h);
-
-
-        uint8_t						*_bitmapBuffer;
-	uint8_t						*_maskBuffer;
-	uint8_t						*_bgBitmapBuffer;
-	uint8_t						*_bgMaskBuffer;
-        uint8_t                                         *_dirty;
-	uint8_t						blend(uint8_t *target,uint32_t baseLine);
-	ADMfont						*_font;
-	uint8_t						loadSubtitle(void);
-	uint8_t						loadFont(void);
-	uint8_t 					subParse( subLine *in, char *string );
-        uint8_t                                         doChroma(void);
-        uint8_t                                         clearBuffers(void);
-        void                                            doAutoSplit(subLine *string);
-        uint8_t                                         isDirty(int line);
-
- public:
- 		
-  						ADMVideoSubtitle(  AVDMGenericVideoStream *in,CONFcouple *setup);
-  						~ADMVideoSubtitle();
-		      virtual uint8_t 		getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
-       								ADMImage *data,uint32_t *flags);
-
-			virtual uint8_t	getCoupledConf( CONFcouple **couples)		;
-			virtual uint8_t 	configure( AVDMGenericVideoStream *instream);
-							
- }     ;
-#endif

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidSRTRender.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidSRTRender.cpp	2007-08-13 10:07:01 UTC (rev 3500)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidSRTRender.cpp	2007-08-13 13:47:25 UTC (rev 3501)
@@ -1,798 +0,0 @@
-/***************************************************************************
-                          ADM_vidSRT.cpp  -  description
-                             -------------------
-    begin                : Thu Dec 12 2002
-    copyright            : (C) 2002 by mean
-    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#include &quot;config.h&quot;
-
-#include &lt;stdio.h&gt;
-#include &lt;stdlib.h&gt;
-#include &lt;string.h&gt;
-#include &lt;math.h&gt;
-#include &lt;math.h&gt;
-#include &lt;iconv.h&gt;
-
-
-#ifdef USE_FREETYPE
-
-#include &quot;fourcc.h&quot;
-#include &quot;avio.hxx&quot;
-
-#include &quot;avi_vars.h&quot;
-
-#include &quot;ADM_toolkit/toolkit.hxx&quot;
-
-#include &quot;ADM_editor/ADM_edit.hxx&quot;
-#include &quot;ADM_video/ADM_genvideo.hxx&quot;
-
-#include &quot;ADM_video/ADM_vidFont.h&quot;
-#include &quot;ADM_video/ADM_vidSRT.h&quot;
-#include &lt;ADM_assert.h&gt;
-
-#include &quot;ADM_osSupport/ADM_debugID.h&quot;
-#define MODULE_NAME MODULE_FILTER
-#include &quot;ADM_osSupport/ADM_debug.h&quot;
-
-
-#define SUB_OUT 0xf0000000
-
-#define ALPHA
-
-#define LUMA_LEVEL 10
-
-#define SAFE_STRCPY(dest,destLen,src,srcLen) \
-memcpy(dest,src,srcLen&lt;destLen?srcLen:destLen-1); \
-dest[srcLen&lt;destLen?srcLen:destLen-1]='\0'; \
-
-
-//                     1
-//		Get in range in 121 + coeff matrix
-//                     1
-//
-// If the value is too far away we ignore it
-// else we blend
-//__________________________________________________________________
-uint8_t ADMVideoSubtitle::getFrameNumberNoAlloc(uint32_t frame,
-						uint32_t *len,
-   						ADMImage *data,
-   						uint32_t *flags)
-{
-
-double f;
-uint32_t time,srch;
-uint32_t absFrame=frame+_info.orgFrame;
-
-	//		printf(&quot;\n Stabilize : %lu\n&quot;,frame);
-          _uncompressed=data;
-	if(frame&gt;=_info.nb_frames) 
-	{
-		printf(&quot;Filter : out of bound!\n&quot;);
-		return 0;
-	}
-	if(!_in-&gt;getFrameNumberNoAlloc(frame, len,data,flags)) return 0;
-
-	// if no subtitle return...
-	if(!_subs) return 1;
-
-	// compute time stamp
-	      f=absFrame*1000000./_info.fps1000;
-	      time=(uint32_t) floor(f);
-	      // Do we have it already ?
-
-	      if(time&lt;=_subs[_oldline].endTime &amp;&amp; time &gt;=_subs[_oldline].startTime)
-	      {
-	      		aprintf(&quot;Sub: cached %lu %lu %lu\n&quot;,time,_subs[_oldline].startTime,_subs[_oldline].endTime);
-			blend(YPLANE(data),_conf-&gt;_baseLine); // re-use it
-			return 1;	
-
-	      }
-	      srch=search(time);
-	      // we got the right one
-     
-	      if(srch!=SUB_OUT) // we got something...
-			{
-					_oldline=srch;
-					aprintf(&quot;Sub: Using line %d\n&quot;,srch);
-					//printf(&quot;\n %s \n&quot;,_subs[_oldline].string);
-					displayString(&amp;(_subs[_oldline]));
-					blend(YPLANE(data),_conf-&gt;_baseLine);
-			}
-
-		return 1;
-
-}
-//_________________________________________________________________
-uint32_t	ADMVideoSubtitle::search(uint32_t time)
-{
-	if(time&lt;_subs[0].startTime)
-		return SUB_OUT;
-
-	  for(uint32_t i=0;i&lt;_line;i++)
-	  {
-				if((time&lt;=_subs[i].endTime)  &amp;&amp;
-					(time&gt;=_subs[i].startTime)
-				)
-				return i;
-
-		}
-		return SUB_OUT;
-}
-//
-//	Display up to 3 lines of text centered on screen
-//  Each line is separated by a |
-// It is the basic version that tries to use only 2 lines
-// in most cases, 3 when needed
-//______________________________________
-void ADMVideoSubtitle::displayString(subLine *string)
-{
- 
-	uint32_t base=0;	
-	uint32_t nbLine=0;
-	uint32_t i=0;
-	uint32_t overflow=0;
-
-      aprintf(&quot;Sub: Rendering string %s\n&quot;,string);
-// bbase is the final position in line
-// in the image
-
-	clearBuffers();
-	nbLine=string-&gt;nbLine;
-	if(nbLine&gt;SRT_MAX_LINE )
-	{
-		nbLine=SRT_MAX_LINE;
-		printf(&quot;Too much lines\n&quot;);
-	}
-	switch(nbLine)
-	{
-		case 0:
-			base=2*_conf-&gt;_fontsize;; // 1 or 2 lines we dont use the upper line		
-			break;
-		case 1:
-			base=_conf-&gt;_fontsize;; // 1 or 2 lines we dont use the upper line		
-			break;
-		default:
-                        base=0;
-                        break;
-	}	
-		
-	aprintf(&quot;Sub: %d lines to render\n&quot;,nbLine);
-	// scan and display each line
-	for(i=0;i&lt;nbLine;i++)
-	{
-		
-			if(string-&gt;lineSize[i]!=displayLine(string-&gt;string[i],base,string-&gt;lineSize[i]))
-                                overflow=1;
-			base+=_conf-&gt;_fontsize;
-		
-	}
-        if(overflow &amp;&amp; _conf-&gt;_selfAdjustable) 
-        {
-                printf(&quot;Do autosplit\n&quot;);
-                doAutoSplit(string);
-        }
-    	doChroma();
-	// Compute the dirty state
-        // If a line is not set as dirty, it means it has no pixel in it
-        // In fact we do top/bottom and add a tiny bit to it
-        memset(_dirty,1,_info.height);
-
-        // First to top
-
-        int top=0,bottom=_info.height-1,limit;
-        while(top&lt;_info.height &amp;&amp; !isDirty(top)) top++;
-        if(top&gt;_conf-&gt;_fontsize&gt;&gt;1) top-=_conf-&gt;_fontsize&gt;&gt;1;
-        memset(&amp;(_dirty[0]),0,top); // Clear top
-        
-        // Then bottom
-        limit=(SRT_MAX_LINE+1)*_conf-&gt;_fontsize;
-        if(limit&gt;=_info.height) limit=_info.height-1;
-
-
-        bottom=limit;
-        while(bottom&gt;top &amp;&amp; !isDirty(bottom)) bottom--;
-        if(bottom+(_conf-&gt;_fontsize&gt;&gt;1)&lt;limit) bottom+=_conf-&gt;_fontsize&gt;&gt;1;
-        ADM_assert(bottom&lt;=limit);
-        memset(&amp;(_dirty[bottom]),0,limit-bottom+1);
-        //printf(&quot;Top:%d bottom :%d limit:%d\n&quot;,top,bottom,limit);
-	
-}
-uint8_t ADMVideoSubtitle::isDirty(int line)
-{
-        uint8_t *base=_maskBuffer+_info.width*line;
-        for(int x=0;x&lt;_info.width;x++)
-        {
-                if(base[x]) return 1;
-        }
-        return 0;
-}
-/*
-        We merge the whole lines into one then split it
-        to avoid truncated subs
-*/
-void ADMVideoSubtitle::doAutoSplit(subLine *string)
-{
-        uint32_t base=0;    
-        uint32_t nbLine=0;
-        uint32_t i=0;
-        int      total=0,start,end,pivot;
-
-        aprintf(&quot;Sub: Autospliting \n&quot;);
-        nbLine=string-&gt;nbLine;
-
-        // Merge all strings into one
-
-        for(int i=0;i&lt;nbLine;i++) 
-                total+=1+string-&gt;lineSize[i];
-
-        ADM_GLYPH_T allwords[total];
-        int         offset[total];
-        int         sentence[total];
-        int         nbWords=0;
-        //
-        start=0;
-        for(int i=0;i&lt;nbLine;i++) 
-        {
-                memcpy(&amp;(allwords[start]),string-&gt;string[i],string-&gt;lineSize[i]*sizeof(ADM_GLYPH_T));
-                start+=string-&gt;lineSize[i];
-                allwords[start]=' ';
-                start++;
-        }
-        // Remove the last ' '
-        start--;
-        end=start;
-        // Here we go, we have now one line made of all merged sub
-        // We will put as much as possible into one displayed line
-        // then switch to the next one
-        //
-        printf(&quot;The new stuff is :&lt;&quot;);
-        for(i=0;i&lt;end;i++)
-                printf(&quot;%c&quot;,allwords[i]);
-        printf(&quot;&gt;\n&quot;);
-        
-        // Split into words
-        pivot=0;
-        int car;
-        offset[0]=0;
-        nbWords=1;
-        while(pivot&lt;end)
-        {
-                car=ADM_ASC(allwords[pivot]);
-                if(car==' ' || car=='.' || car ==',')
-                        {
-                                offset[nbWords++]=pivot;
-                        }
-                pivot++;
-        }
-        printf(&quot;Found %d words\n&quot;,nbWords); 
-        // Now  split
-        int nbSentence=0,len;
-        pivot=0;
-        sentence[0]=0;
-        // Try to display as much as possible in one line
-        // We build sentence here
-        while(pivot&lt;nbWords)
-        {
-                for(i=pivot+1;i&lt;nbWords;i++)
-                {
-                        len=offset[i]-offset[pivot];
-                        if(len!=displayLine(&amp;(allwords[offset[pivot]]),0,len)) break;
-                }
-                sentence[nbSentence]=offset[pivot];
-                nbSentence++;
-                if(i&gt;1 &amp;&amp; i!=nbWords) i--;
-                pivot=i;
-        }
-        printf(&quot;0: %d,off:%d\n&quot;,sentence[0],offset[0]);
-        // Take the last word
-        sentence[nbSentence]=end;
-
-        if(nbSentence&gt;SRT_MAX_LINE) nbSentence=SRT_MAX_LINE;
-        // now display
-        printf(&quot;Nb sentence:%d\n&quot;,nbSentence);
-        for(int j=0;j&lt;nbSentence;j++)
-        {
-                printf(&quot;Sentence %d:&quot;,j);
-                for(int k=sentence[j];k&lt;sentence[j+1];k++)
-                        printf(&quot;%c&quot;,allwords[k]);
-                printf(&quot;\n&quot;);
-        }
-        // now display
-        
-        switch(nbSentence)
-        {
-                case 0:
-                        base=2*_conf-&gt;_fontsize;; // 1 or 2 lines we dont use the upper line            
-                        break;
-                case 1:
-                        base=_conf-&gt;_fontsize;; // 1 or 2 lines we dont use the upper line              
-                        break;
-                default:
-                        base=0;
-                        break;
-        }
-        // scan and display each line
-        clearBuffers();
-        printf(&quot;Display\n&quot;);
-        for(i=0;i&lt;nbSentence;i++)
-        {
-                        len=sentence[i+1]-sentence[i];
-                        displayLine(&amp;(allwords[sentence[i]]),base,len);
-                        //displayLine(allwords,base,10);
-                        base+=_conf-&gt;_fontsize;
-        }
-        printf(&quot;/Display\n&quot;);
-        
-}
-/*
-        Once we have the subtitle built, we do the u&amp; v planes
-        and some smoothing to avoid over sharpening on the chroma plane
-
-*/
-uint8_t ADMVideoSubtitle::doChroma(void)
-{
-// now blur bitmap into mask..
-        memset(_maskBuffer,0,SRT_MAX_LINE*_conf-&gt;_fontsize*_info.width);
-
-        uint32_t off;
-        uint8_t *src,*dst;
-
-        off=0;
-
-        src=_bitmapBuffer;
-        dst=_maskBuffer;
-
-
-        // We shrink it down for u &amp; v by 2x2
-        // mask buffer-&gt;bitmap buffer
-
-        uint8_t tmp[_info.width*_info.height];
-
-        decimate(src,tmp,_info.width,_info.height);
-        lowPass(src,dst,_info.width,_info.height);
-        lowPass(tmp,src,_info.width&gt;&gt;1,_info.height&gt;&gt;1);
-
-        if (_conf-&gt;_useBackgroundColor) 
-        {
-                decimate(_bgMaskBuffer,_bgBitmapBuffer,_info.width,_info.height);
-                //lowPass(tmp,_bgBitmapBuffer,_info.width&gt;&gt;1,_info.height&gt;&gt;1);
-        }
-  
-}
-/*
-        Clear the buffers in case we do a new sub or
-                redo one in case it overflows
-*/
-uint8_t ADMVideoSubtitle::clearBuffers(void)
-{
-        memset(_bitmapBuffer,0,_info.height*_info.width);
-        memset(_maskBuffer,0,_info.height*_info.width);
-        memset(_bgBitmapBuffer,0,(_info.height*_info.width)&gt;&gt;1);
-        memset(_bgMaskBuffer,0,_info.height*_info.width);
-        return 1;
-}
-// Display a full line centered on screen. It returns the
-// number of displayed chars.
-//____________________________________________________________
-
-// It also returns the suggested len for this line string (just when display fail)
-//
-uint32_t ADMVideoSubtitle::displayLine(ADM_GLYPH_T *string,uint32_t line, uint32_t len)
-{
-  // n first chars in string that can &quot;fit&quot; in this line
- 
-
-	//uint32_t pixstart;
-	uint8_t *target;
-	int car;
-
-
-	aprintf(&quot;Sub DisplayString  line %lu len %lu\n&quot;,line,len);
-
-	if(!len)
-	{
-		printf(&quot;\n null string\n&quot;);
-      		return 0;
-	}
-
-
-  
-	uint32_t w=0,next;
-	int ww;
-
-	// we dummy do it one time to get the actual width of the string
-	// and hence perfectly center it
-	target=_maskBuffer+_info.width*line;
-	for(uint32_t i=0;i&lt;len;i++)
-	{
-			if(ADM_ASC(*(string+i))==' ')
-			{
-					w+=_conf-&gt;_fontsize&gt;&gt;2;
-			}
-			else
-			{
-				ww=0;
-				car=string[i];
-				if(i) next=string[i-1];
-					else next=0;
-				// Change ' to &quot;
-				//if(ADM_ASC(car)==0x27)
-				//	car=0x22;
-	        		if(!_font-&gt;fontDraw((char *)(target+1+w),car,next , _info.width,_conf-&gt;_fontsize,&amp;ww))
-				{
-					printf(&quot;Font error\n&quot;);
-              return 0;
-				}
-				if((ww&lt;0)||(ww&gt;64))
-				{
-					printf(&quot;Warning w out of bound (%d)\n&quot;,ww);
-					ww=0;
-				}
-				if(w+ww&gt;_info.width)
-				{
-					printf(&quot;Line too long!\n&quot;);
-					len=i;
-					goto _abt;
-					break;
-				}
-				w=w+ww;
-			}
-      
-	}
-_abt:
-	//Now we can render it at its final position
-	if(w&lt;_info.width)
-	{
-		target=_bitmapBuffer+_info.width*line+((_info.width-w)&gt;&gt;1);
-	}
-	else
-	{
-		target=_bitmapBuffer+_info.width*line+1;
-	}
-
-  //printf(&quot;[debug] line %s\n&quot;,string);
-
-	ww=0;
-	w=0;
-	for(uint32_t i=0;i&lt;len;i++)
-	{
-			if(*(string+i)==' ')
-			{
-					w+=_conf-&gt;_fontsize&gt;&gt;2;
-
-			}
-			else
-			{
-				ww=0;
-				car=string[i];
-				if(i) next=string[i-1];
-					else next=0;
-	        		if(!_font-&gt;fontDraw((char *)(target+1+w),car,next , _info.width,_conf-&gt;_fontsize,&amp;ww))
-				{
-					printf(&quot;Font error\n&quot;);
-              return 0;
-				}
-				if((ww&lt;0)||(ww&gt;64))
-				{
-					printf(&quot;Warning w out of bound (%d)\n&quot;,ww);
-					ww=0;
-				}
-				w=w+ww;
-			}
-      
-	}
-
-  {
-    if (_conf-&gt;_useBackgroundColor) {
-      //Create background info
-      
-      int32_t delta=_info.width*line+((_info.width-w)&gt;&gt;1);
-      uint8_t *bitmapTarget=_bitmapBuffer+delta;
-      uint8_t *maskTarget=_maskBuffer+delta;
-      //uint8_t *bgBitmapTarget=_bgBitmapBuffer+delta;
-      uint8_t *bgMaskTarget=_bgMaskBuffer+delta;
-      
-      delta=3*_info.width;
-      bitmapTarget+=delta;
-      maskTarget+=delta;
-      //bgBitmapTarget+=delta;
-      bgMaskTarget+=delta;
-      
-      for (uint32_t i=0;i&lt;_conf-&gt;_fontsize;i++) {
-	//memset(bgTarget,1,w);
-	for (uint32_t j=0;j&lt;w;j++) {
-	  if (*(bitmapTarget+j)==0) {
-	    *(bgMaskTarget+j)=1;   //at this position, we will apply a different color
-	    //*(bgBitmapTarget+j)=1;
-	    *(maskTarget+j)=0;
-	    *(bitmapTarget+j)=0;
-	  }
-	}
-	bgMaskTarget+=_info.width;
-	//bgBitmapTarget+=_info.width;
-	maskTarget+=_info.width;
-	bitmapTarget+=_info.width;
-      }
-
-    }
-  }
-	
-
- 
-  return len;
-}
-//--------------------------------------------------------------------
-//
-//	Blend bitmap buffer into final screen
-//      We scan the SRT_MAX_LINE last line
-//--------------------------------------------------------------------
-uint8_t ADMVideoSubtitle::blend(uint8_t *target,uint32_t baseLine)
-{
-
-	uint8_t  *mask; //*oldtarget=target,*
-  uint8_t  *bgMask;
-	int8_t *chromatarget;
-	uint32_t hei,start;
-	uint32_t y;
-	uint32_t val;
-	int32_t ssigned;
-	double alpha,alpha2;
-#define SHADOW_UP 	8
-#define SHADOW_DOWN 	16
-
-	hei=(SRT_MAX_LINE+1)*_conf-&gt;_fontsize;
-	if(hei&gt;=_info.height-1) hei=_info.height-1;
-	hei*=_info.width;  // max height of our subtitle
-	
-
-	aprintf(&quot;Sub:Rendering : %d %d %d (yuv)\n&quot;,_conf-&gt;_Y_percent,_conf-&gt;_U_percent,_conf-&gt;_V_percent);
-	
-	// keep a little margin for renderin
-	// to render f y or g
-	if((baseLine) &gt; _conf-&gt;_fontsize)
-		baseLine-=_conf-&gt;_fontsize&gt;&gt;1;
-	
-		
-	//__________________________
-		
-		// Shadow ..
-		uint8_t *shadow=target;
-		uint32_t shadow_pos;
-		
-		shadow_pos=_conf-&gt;_fontsize/10;
-		start=_info.width*baseLine;  // base line in final image
-		// mask out left and right
-		mask=_maskBuffer; 
-				
- 		shadow+=start+(1+_info.width)*shadow_pos;
-  		for( y=hei;y&gt;0;y--)
-		{
-     		 if(*mask) 
-		 {
-				if(*mask&gt;LUMA_LEVEL)
-				{
-					val=*shadow;
-					val=(val*SHADOW_UP)/SHADOW_DOWN;
-					*shadow=(uint8_t )val;
-				}				
-     		 } 	  
-      
-		shadow++;
-		mask++;
-		}
-	
-	// /Shadow
-	//__________________________
-	start=_info.width*baseLine;  // base line in final image
-
-	chromatarget=(int8_t *)(target+(_info.width*_info.height));
-
-	// mask out left and right
-
-	mask=_maskBuffer;
-  	bgMask=_bgMaskBuffer;
- 	target+=start;
-        // clip 
-        if(hei+start&gt;_info.width*_info.height)
-        {
-                hei=_info.width*_info.height-start;
-        }
-// Luma
-        int bottom=baseLine+(SRT_MAX_LINE+1)*_conf-&gt;_fontsize;
-        if(bottom&gt;_info.height) bottom=_info.height;
-        for( y=baseLine;y&lt;bottom;y++)
-        {
-            if(!_dirty[y-baseLine])
-            {
-                target+=_info.width;
-                mask+=_info.width;
-                bgMask+=_info.width;
-                 continue;
-            }
-            for(int x=0;x&lt;_info.width;x++)
-            {
-                if(*mask) {
-                                if(*mask&gt;LUMA_LEVEL || _conf-&gt;_useBackgroundColor)
-                                {
-                                        val=*mask*_conf-&gt;_Y_percent+128;
-                                        val&gt;&gt;=8;
-                                        *target=(uint8_t )val;
-                                }
-                                else 
-                                        { *target=0; }
-                        } else 
-                        if(*bgMask)
-                        {
-                                if(_conf-&gt;_useBackgroundColor) 
-                                {
-                                        *target=(uint8_t )_conf-&gt;_bg_Y_percent;
-                                }
-                        }
-                        else
-                                {
-                                        switch(_conf-&gt;_blend)
-                                        {
-                                                case BLEND_SOLID: break;
-                                                case BLEND_DIMMER: *target=(*target*3)&gt;&gt;2;break;
-                                                case BLEND_DOTTED: 
-                                                {
-                                                        int odd;
-                                                                odd= y%_info.width;
-                                                                odd=odd&amp;1;
-                                                                odd+=(1&amp;(y/_info.width));
-                                                                odd&amp;=1;
-                                                                if(odd) *target=0; 
-                                                }
-                                        }
-                                }
-                        
-                target++;
-                mask++;
-                bgMask++;
-              }
-        }
-	
-
-// do u &amp; v
-	int8_t *ctarget;
-
-	baseLine&amp;=0xffffe;
-	start=(_info.width*baseLine)&gt;&gt;2;
-	hei&gt;&gt;=2;
-
-	mask=_bitmapBuffer;
-  	bgMask=_bgBitmapBuffer;
-	ctarget=chromatarget+start;
-	target=(uint8_t *)ctarget;
-
-	ssigned=_conf-&gt;_U_percent;
-	ssigned+=128;
-
-  uint8_t bg_val=(uint8_t) _conf-&gt;_bg_U_percent+128;
-
-//#define MAXVAL(x) {val=*mask*(x)+127;val&gt;&gt;=8;*ctarget=(uint8_t)(val&amp;0xff);}
-
-#define BLEND_LEVEL 	3
-#define BLEND_PERCENT 	20
-
-#define MAXVAL(x)  *target=(uint8_t )ssigned
-#define DOIT if(*mask) \
-		{ \
-			alpha=*mask; \
-			if(alpha&gt;BLEND_LEVEL) \
-				*target=(uint8_t)ssigned; \
-			else			\
-			{			\
-				alpha2=(100-BLEND_PERCENT)*(*target-128); \
-				alpha=BLEND_PERCENT*(ssigned-128); \
-				alpha=(alpha2+alpha)/100; \
-				*target=(uint8_t)(alpha+128) ;\
-			} \
-                } \
-             else if (_conf-&gt;_useBackgroundColor &amp;&amp; *bgMask) {*target=(uint8_t)bg_val;}
-	     
-#define RENDER	     \
-	\
-	for( y=hei;y&gt;0;y--) \
-	{ \
-		DOIT; \
-		ctarget++; \
-		target++; \
-		mask++; \
-	bgMask++; \
-	} \
-	
-	RENDER;
-
-	mask=_bitmapBuffer;
-  	bgMask=_bgBitmapBuffer;
-	ctarget=chromatarget+start+((_info.width*_info.height)&gt;&gt;2);;
-	target=(uint8_t *)ctarget;
-	ssigned=_conf-&gt;_V_percent;
-	ssigned+=128;
-
-  	bg_val=(uint8_t) _conf-&gt;_bg_V_percent+128;
-
-	RENDER;
-
-
-	return 1;
-}
-//
-//	Apply a low pass to alias it
-//					1
-// The softening is a 1 4 1  convolution filter
-//					1
-uint8_t ADMVideoSubtitle::lowPass(uint8_t *src, uint8_t *dst, uint32_t w, uint32_t h)
-{
-	uint8_t *prevline, *nextline,*curline,*target;
-	uint32_t val;
-
-	memcpy(dst,src,w*h);
-
-	src++;dst++;
-
-			for(uint32_t line=h-1;line&gt;0;line--)
-			{
-				curline=src+line*w;
-				nextline=curline+w;
-				prevline=curline-w;
-				target=dst+line*w;
-				for(uint32_t col=w-1;col&gt;1;col--)
-				{
-#define LEVEL 8*90
-					// 1 4 1
-					val= (*(curline)*4+*prevline+*nextline+*(curline-1)+*(curline+1));
-					if(val&gt; 0 )
-					if(val&lt;LEVEL)
-						val=1;  // just enough to trigger masking
-					else
-						val&gt;&gt;=3;
-					*target=val;
-					target++;
-					curline++;
-					prevline++;
-					nextline++;
-				}
-
-			}
-	return 1;
-}
-//
-//	Decimate 2x2 (luma-&gt;chroma)
-//					1
-//					1
-uint8_t ADMVideoSubtitle::decimate(uint8_t *src, uint8_t *dst, uint32_t w, uint32_t h)
-{
-	uint8_t	*curline, *nextline;
-	uint8_t *target=dst;
-
-			for(uint32_t line=0;line&lt;h&gt;&gt;1;line++)
-			{
-				curline=src+line*w*2;
-				nextline=curline+w;
-				target=dst+line*(w&gt;&gt;1);
-				for(uint32_t col=0;col&lt;w&gt;&gt;1;col++)
-				{
-					// 1 4 1
-					*target= (*(curline)+*(curline+1)+*nextline+*(nextline+1))&gt;&gt;2;
-					target++;
-					curline+=2;
-					nextline+=2;
-				}
-
-			}
-	return 1;
-}
-
-#endif

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidSRTload.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidSRTload.cpp	2007-08-13 10:07:01 UTC (rev 3500)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidSRTload.cpp	2007-08-13 13:47:25 UTC (rev 3501)
@@ -1,497 +0,0 @@
-/***************************************************************************
-                          ADM_vidload.cpp  -  description
-                             -------------------
-
-	Load the subtitles either in srt or sub format
-
-	The structure is
-		uint32_t 		startTime in ms from beginning
-		uint32_t 		endTime  in ms from beginning
-	
-	All text are stored as utf16 after loading
-
-
-    begin                : Thu Aug 09 2003
-    copyright            : (C) 2003 by mean
-    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#include &quot;config.h&quot;
-
-#include &lt;stdio.h&gt;
-#include &lt;stdlib.h&gt;
-#include &lt;string.h&gt;
-#include &lt;math.h&gt;
-#include &lt;math.h&gt;
-#include &lt;iconv.h&gt;
-#include &lt;errno.h&gt;
-
-
-#ifdef USE_FREETYPE
-//#define __STDC_ISO_10646__
-#include &quot;fourcc.h&quot;
-#include &quot;avio.hxx&quot;
-
-#include &quot;avi_vars.h&quot;
-
-#include &quot;ADM_toolkit/toolkit.hxx&quot;
-#include &quot;ADM_editor/ADM_edit.hxx&quot;
-#include &quot;ADM_video/ADM_genvideo.hxx&quot;
-
-#include &quot;ADM_video/ADM_vidFont.h&quot;
-#include &quot;ADM_video/ADM_vidSRT.h&quot;
-#include &lt;ADM_assert.h&gt;
-
-#include &quot;ADM_osSupport/ADM_debugID.h&quot;
-#define MODULE_NAME MODULE_FILTER
-#include &quot;ADM_osSupport/ADM_debug.h&quot;
-
-#define ADM_RAW 1024
-
-static iconv_t myConv=(iconv_t)-1;;
-static int ADM_SubAtoi(uint16_t *in);
-
-static uint8_t	ADM_utfInit( char *charset );
-static uint8_t ADM_utfConv(ADM_GLYPH_T *out, char *in,uint32_t nbIn, uint32_t *nbOut);
-static uint8_t ADM_utfEnd( void);
-
-
-
-
-uint8_t	ADMVideoSubtitle::loadFont (void)
-{
- 
-  if (!_font-&gt;initFreeType ((char *)_conf-&gt;_fontname))
-    {
-      printf (&quot;\n Free type init failed for font %s!&quot;, _conf-&gt;_fontname);
-    }
-  else
-    {
-      _font-&gt;fontSetSize (_conf-&gt;_fontsize);
-    }
-   
-  return 1;
-}
-
-//
-//      Load subtitles in .sub format i.e. {xx}{yy} |   |
-//
-// {3610}{3656}Pripraven&#65533;uv&#65533;a ich|v naom dome s primeranou ctou.
-//__________________________________________________________________
-uint8_t  ADMVideoSubtitle::loadSubTitle (void)
-{
-
-  char string[500];
-  uint32_t current_line = 0;
-  // first cound how many line
-  _line = 0;
-   // init iconv...  
-  if(! ADM_utfInit(_conf-&gt;_charset))
-  {
-  	printf(&quot;Problem initializing iconv, aborting\n&quot;);
-	return 0;
-  
-  }
-  while (fgets (string, 200, _fd))
-    {
-      _line++;
-    }
-  printf (&quot;\n subs : %ld lines\n&quot;, _line);
-  // rewind
-  fseek (_fd, 0, SEEK_SET);
-  //
-  _subs = new subLine[_line];
-  if (!_subs)
-    return 0;
-  memset (_subs, 0, sizeof (subLine) * _line);
-
-
- 
-//	
-  for (uint32_t i = 0; i &lt; _line; i++)
-    {
-      fgets (string, ADM_RAW, _fd);
-      //printf(&quot;\n in : %s &quot;,string);
-      if (string[0] != '{')
-	continue;
-      subParse ((subLine *) &amp; (_subs[current_line]), string);
-      current_line++;
-    }
-	
-  // the effective number of line we have
-  _line = current_line;
-  return 1;
-  
- ADM_utfEnd( );
-}
-
-//___________________________________________________________________
-//      In case of sub file, take one line and convert it to unicode
-//	we also extract the start/end and split it to N lines
-//	Does not work if input is UTF16. UTF8 is ok.
-//___________________________________________________________________
-uint8_t	ADMVideoSubtitle::subParse (subLine * in, char *string)
-{
-
-
-  static ADM_GLYPH_T 	final[ADM_RAW];	// convert to unicode
-  uint32_t   	startindex, endindex,textindex;
-  uint32_t 	j;
-  float 	f;
- 
-  uint32_t 	finallen=0;
-  uint32_t	alpha;
- 
-  j = 1;
-  
-  
-  ADM_utfConv(final,string,strlen(string),&amp;finallen);
-  
-  // ignore { }
-  while (ADM_ASC(final[j]) != '}' &amp;&amp; j &lt; finallen)
-    j++;
- 
-  startindex =1;
-  j += 2;			// skip }{
-  endindex =j;
-  while (ADM_ASC(final[j]) != '}' &amp;&amp; j &lt; finallen)
-    j++;
-  // The text starts here
-  textindex = j + 1;
-
-  if (j &gt;= finallen - 1)
-    {
-      printf (&quot;***ERR: Suspicious line !!!\n&quot;);
-      return 0;
-
-    }
-
-  // convert frame -&gt; time in ms
-  // skip utf marker if present
-  alpha= ADM_SubAtoi (&amp;final[1]);
-  f=(float)alpha;
-  aprintf(&quot;%s start:%d&quot;,string,alpha);
-  f = f * 1000000. / _info.fps1000;
-  in-&gt;startTime = (uint32_t) floor (f);
-
-  alpha = ADM_SubAtoi (&amp;final[endindex]);
-  f=(float)alpha;
-  aprintf(&quot; end:%d\n&quot;,alpha);
-  f = f * 1000000. / _info.fps1000;
-  
-  in-&gt;endTime = (uint32_t) floor (f);
-
-  uint32_t lllines=0;
-  finallen-=textindex;
-  if(finallen==0)
-  	{
-		printf(&quot;Empty line\n&quot;);
-		in-&gt;nbLine=0;
-		return 1;
-	}
-  // Count the number of | found
-  for(j=0;j&lt;finallen;j++)
-  {
-  	if(ADM_ASC(final[j+textindex])=='|') lllines++;
-  }
-
-  aprintf(&quot;%lu --&gt;%lu\n&quot;,in-&gt;startTime,in-&gt;endTime);
-  in-&gt;nbLine=lllines+1;
-  in-&gt;string=new ADM_GLYPH_T *[in-&gt;nbLine];
-  in-&gt;lineSize=new uint32_t[in-&gt;nbLine];
-  
-  for(uint32_t i=0;i&lt;in-&gt;nbLine;i++)
-  {
-  	in-&gt;string[i]=new ADM_GLYPH_T[finallen]; 	// yes, we overshot
-	in-&gt;lineSize[i]=0;
-  }
-  
-  uint32_t curline=0, curindex=0;
-  for(uint32_t i=0;i&lt;finallen;i++)
-  {
-  	if(ADM_ASC(final[i+textindex])=='|')
-	{
-		in-&gt;lineSize[curline]=curindex;
-		curindex=0;
-		curline++;		
-	}
-	else
-	{
-		in-&gt;string[curline][curindex++]=final[i+textindex];
-	}
-  
-  }  
-  if(curindex)
-  	in-&gt;lineSize[curline]=curindex;
-  return 1;
-}
-
-//
-//      Load subtitles in .srt format i.e. {xx}{yy} |   |
-//__________________________________________________________________
-uint8_t
-ADMVideoSubtitle::loadSRT (void)
-{
-
-
-  static ADM_GLYPH_T 	final[ADM_RAW];	// convert to unicode
-  ADM_GLYPH_T  		temp[SRT_MAX_LINE][ADM_RAW];
-  uint32_t		tempSize[SRT_MAX_LINE];
-  char			string[ADM_RAW];
-  
-  
-  uint32_t line;  
-  uint32_t len;
-  // Init iconv
-   uint32_t 	finallen=0;
-  subLine	*current;
-  
-  if(! ADM_utfInit(_conf-&gt;_charset))
-  {
-  	printf(&quot;Problem initializing iconv, aborting\n&quot;);
-	return 0;
-  
-  } 
-  
-  // first cound how many line
-  line = 0;
-  _line = 0;
-  while (fgets (string, 300, _fd))
-    line++;
-  printf (&quot;\n subs : %ld lines\n&quot;, line);
-  // rewind
-  fseek (_fd, 0, SEEK_SET);
-  //
-  _subs = new subLine[line];
-
-  if (!_subs)
-    return 0;
-  
-  memset (_subs, 0, sizeof (subLine) * line);
-  
-  // read and allocate
-  
-  uint32_t j;
-  int state = 0;
-  int stored=0;
-  
-  for (uint32_t i = 0; i &lt; line; i++)
-    {
-	current=&amp;_subs[_line];
-	fgets (string, ADM_RAW, _fd);
-	ADM_utfConv(final,string,strlen(string),&amp;finallen);
-	// Purge cr/lf	
-	switch (state)
-	{
-	case 0:		// waiting for number	 
-                  if(!_line &amp;&amp; (final[0]&amp;0xfefe)==0xfefe)
-                  {
-                      j=ADM_SubAtoi (final+1);
-                  }
-                  else
-		      j = ADM_SubAtoi (final);
-		if (j == _line + 1)
-		{
-			stored=0;
-			state = 1;
-		}
-		break;
-	case 1:		// waiting for time
-		{
-			uint32_t sh, sm, ss, ms;
-			uint32_t dh, dm, ds, md;
-
-			ADM_GLYPH_T *cur=&amp;final[0];
-				
-	  		sh=ADM_SubAtoi(cur);
-			cur+=3;
-			sm=ADM_SubAtoi(cur);
-			cur+=3;
-			ss=ADM_SubAtoi(cur);
-			cur+=3;
-			ms=ADM_SubAtoi(cur);
-			cur+=3;
-			
-			cur+=5;
-			
-			dh=ADM_SubAtoi(cur);
-			cur+=3;
-			dm=ADM_SubAtoi(cur);
-			cur+=3;
-			ds=ADM_SubAtoi(cur);
-			cur+=3;
-			md=ADM_SubAtoi(cur);
-			
-			_subs[_line].startTime = ms + 1000 * (ss + sm * 60 + sh * 3600);
-			_subs[_line].endTime = md + 1000 * (ds + dm * 60 + dh * 3600);
-			state = 2;
-			
-			aprintf(&quot;%d %d %d %d / %d %d %d %d&gt;%s&lt;\n&quot;,sh,sm,ss,ms,dh,dm,ds,md,string);
-			
-		}
-
-		break;
-	case 2:		
-	   // looking for text
-	   // We append each line to text with a | to separate the lines	 	  
-	  {
-	  	if (finallen &lt; 2)
-	    	{
-	   		// Finished
-	      		_line++;
-	      		state = 0;
-			current-&gt;nbLine=stored;
-			current-&gt;lineSize=new uint32_t[stored];
-			current-&gt;string=new ADM_GLYPH_T *[stored];
-			for(uint32_t i=0;i&lt;stored;i++)
-			{
-				current-&gt;lineSize[i]=tempSize[i];
-				current-&gt;string[i]=new ADM_GLYPH_T[tempSize[i]];
-				memcpy(current-&gt;string[i],temp[i],sizeof(ADM_GLYPH_T)*tempSize[i]);
-			}
-	      		break;
-	    	}
-	  	else
-	    	{
-			if(stored&gt;=SRT_MAX_LINE)
-			{
-				printf(&quot;sub:Too much lines, ignoring..\n&quot;);
-				continue;
-			}
-	      		// We add it
-			memcpy(temp[stored],final,finallen*sizeof(ADM_GLYPH_T));
-			tempSize[stored]=finallen;
-			stored++;
-	    	}
-	  }
-	  break;
-
-	}
-
-    }
-  ADM_utfEnd( );
-  aprintf(&quot;&gt;&gt; Sub: %d subs stored and loaded\n&quot;,_line); 	
-  return 1;
-  
-}
-// Sort of atoi for utf16
-// Very basic
-int ADM_SubAtoi(uint16_t *in)
-{
-	int result=0;
-	int d;
-	do
-	{
-		d=ADM_ASC(*in);		
-		in++;
-		if(d&gt;='0' &amp;&amp; d&lt;='9')
-		{
-			result*=10;
-			result+=d-'0';
-		}
-		else
-			return result;
-	}while(1);
-	
-
-}
-//	Init iconv, so that we can go utf16
-//
-uint8_t	ADM_utfInit( char *charset )
-{
-	myConv=iconv_open(&quot;UTF-16&quot;,charset); //&quot;WINDOWS-1251&quot;);
-	if((long int)myConv==-1)
-	{
-		printf(&quot;\n Error initializing iconv...\n&quot;);
-		return  0;
-	}
-	return 1;
-}
-//
-//	Convert the incoming string to utf16
-//	While doing it, remove the utf16 makers from input/output
-//	(fffe)
-//
-uint8_t ADM_utfConv(ADM_GLYPH_T *out, char *in,uint32_t nbIn, uint32_t *nbOut)
-{
-size_t sin,sout,sz;
-char *cout,*cin;
-uint32_t done=0;
-
-	memset(out,0,ADM_RAW*sizeof(ADM_GLYPH_T));
-	sin=strlen(in);
-	sout=ADM_RAW;
-	cin=in;
-	cout=(char *)(out);
-	
-	if((uint8_t)in[0]==0xff &amp;&amp; (uint8_t)in[1]==0xfe)
-	{
-		 cin+=2;
-		 sin-=2;
-	}
-	if(!sin) 
-	{
-		*nbOut=0;
-		return 1;
-	}
-#ifdef  ICONV_NEED_CONST 
-  	sz=iconv(myConv,(const char **)&amp;cin,&amp;sin,&amp;cout,&amp;sout);
-#else
-	sz=iconv(myConv,&amp;cin,&amp;sin,&amp;cout,&amp;sout);
-#endif	
-	if(sz==-1)
-	{
-  		printf(&quot;Iconv error:%s\n:%s:\n&quot;,strerror(errno),in);
-		//out[0]=' ';
-  	}
-	// Get the amound of utf16...
-	done=(ADM_RAW-sout)&gt;&gt;1;
-// For win32 we swap le and be
-#ifdef ADM_WIN32
-       ADM_GLYPH_T glyph;
-       for(uint32_t w=0;w&lt;done;w++)
-       {
-               glyph=out[w];
-               out[w]=((glyph&amp;0xff)&lt;&lt;8)+(glyph&gt;&gt;8);
-       }
-#endif
-	
-	if(done)
-	{
-		if(0xfeff==out[0])
-		{
-			//aprintf(&quot;Removing utf tag\n&quot;);
-			done--;
-			memmove(&amp;out[0],&amp;out[1],done*sizeof(ADM_GLYPH_T));
-			
-		}
-	}
-
-	while(done &amp;&amp;( ADM_ASC(out[done-1])==0x0a || ADM_ASC(out[done-1]==0x0d))) done--;
-	*nbOut=done;
-	return 1;
-	
-}
-// Close iconv
-//
-
-uint8_t ADM_utfEnd( void)
-{
-  // Purge iconv
-  if((long int)myConv!=-1)
-	{
-		iconv_close(myConv);
-		myConv=(iconv_t)-1;
-	}
-}
-
-
-#endif

Modified: branches/avidemux_2.4_branch/avidemux/ADM_video/CMakeLists.txt
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/CMakeLists.txt	2007-08-13 10:07:01 UTC (rev 3500)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/CMakeLists.txt	2007-08-13 13:47:25 UTC (rev 3501)
@@ -14,20 +14,16 @@
 ADM_vidVobsub.cpp
 ADM_vidAsharp.cpp       
 ADM_vidCrop.cpp       
-ADM_vidHue.cpp               
 ADM_vidVobSubRender.cpp
 ADM_interlaced.cpp       
 ADM_vidCached.cpp       
 ADM_vidDelta.cpp      
 ADM_vidMPdelogo.cpp      
-ADM_vidSRT.cpp        
 ADM_vobsubinfo.cpp
 ADM_vidEq2.cpp             
-ADM_vidSRTload.cpp
 ADM_vidClean.cpp        
 ADM_vidEqualizer.cpp  
 ADM_vidNull.cpp          
-ADM_vidSRTRender.cpp
 )
 ADD_LIBRARY(ADM_video STATIC ${ADM_video_SRCS})
 if(FT_FOUND)

Modified: branches/avidemux_2.4_branch/avidemux/ADM_video/Makefile.am
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/Makefile.am	2007-08-13 10:07:01 UTC (rev 3500)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/Makefile.am	2007-08-13 13:47:25 UTC (rev 3501)
@@ -10,7 +10,6 @@
  ADM_vidCached.cpp \
  ADM_vidPartial.cpp \
  ADM_vidFont.cpp \
- ADM_vidSRT.cpp \
  ADM_vidContrast.cpp \
  ADM_vidCrop.cpp \
  ADM_vidNull.cpp \
@@ -23,14 +22,11 @@
  ADM_interlaced.cpp \
 	ADM_interlaced.h \
  ADM_vidRaw.cpp \
-	ADM_vidSRTRender.cpp \
- ADM_vidSRTload.cpp \
  ADM_cache.cpp \
  ADM_vidEqualizer.cpp \
  ADM_vidVobsub.cpp \
  ADM_vobsubinfo.cpp \
  ADM_vidVobSubRender.cpp \
- ADM_vidHue.cpp \
  ADM_vidEq2.cpp \
  ADM_vidAsharp.cpp \
  ADM_vidCNR2.cpp \
@@ -57,10 +53,10 @@
 ADM_vidEqualizer.cpp  \
 ADM_mpdetc.cpp ADM_vidEqualizer.h   \
 ADM_mpdetc.h  \
-ADM_resizebis.cpp   ADM_vidSRT.cpp \
-ADM_resizebis.hxx    ADM_vidSRT.h \
-ADM_resizeter.cpp  ADM_vidField.h  ADM_vidSRTRender.cpp \
-ADM_vidFieldUnblend.cpp ADM_vidSRTload.cpp \
+ADM_resizebis.cpp   \
+ADM_resizebis.hxx    \
+ADM_resizeter.cpp  ADM_vidField.h  \
+ADM_vidFieldUnblend.cpp \
 ADM_vidASharp_param.h  ADM_vidFieldUtil.cpp  \
 ADM_vidFieldUtil.h  \
 ADM_vidAnimated.cpp  \
@@ -70,8 +66,8 @@
 ADM_vidFont.cpp \
 ADM_vidFont.h \
 ADM_vidCNR2.cpp  \
-ADM_vidCNR2_param.h  ADM_vidHue.cpp  ADM_vidTDeint_param.h \
-ADM_vidCached.cpp  ADM_vidHue.h  ADM_vidTdeint.cpp \
+ADM_vidCNR2_param.h  ADM_vidTDeint_param.h \
+ADM_vidCached.cpp  ADM_vidTdeint.cpp \
 ADM_vidCached.h  ADM_vidIVTC.cpp \
 ADM_vidIVTC.h \
 ADM_vidChromaShift.cpp \

Copied: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidHue.cpp (from rev 3497, branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidHue.cpp)

Copied: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidHue.h (from rev 3497, branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidHue.h)

Copied: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidSRT.cpp (from rev 3497, branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidSRT.cpp)
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidSRT.cpp	2007-08-13 08:19:48 UTC (rev 3497)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidSRT.cpp	2007-08-13 13:47:25 UTC (rev 3501)
@@ -0,0 +1,419 @@
+/***************************************************************************
+                          ADM_vidSRT.cpp  -  description
+                             -------------------
+    begin                : Thu Dec 12 2002
+    copyright            : (C) 2002 by mean
+    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include &quot;config.h&quot;
+
+#include &lt;stdio.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;string.h&gt;
+#include &lt;math.h&gt;
+#include &lt;math.h&gt;
+#include &lt;iconv.h&gt;
+
+
+#ifdef USE_FREETYPE
+
+#include &quot;default.h&quot;
+#include &quot;ADM_osSupport/ADM_misc.h&quot;
+
+#include &quot;ADM_toolkit/toolkit.hxx&quot;
+
+
+
+#include &quot;ADM_editor/ADM_edit.hxx&quot;
+#include &quot;ADM_video/ADM_genvideo.hxx&quot;
+
+#include &quot;ADM_video/ADM_vidFont.h&quot;
+#include &quot;ADM_videoFilter/ADM_vidSRT.h&quot;
+
+#include &lt;ADM_assert.h&gt;
+
+#include &quot;ADM_osSupport/ADM_debugID.h&quot;
+#define MODULE_NAME MODULE_FILTER
+#include &quot;ADM_osSupport/ADM_debug.h&quot;
+#include &quot;ADM_filter/video_filters.h&quot;
+
+#include &lt;prefs.h&gt;
+
+static FILTER_PARAM subParam={15,{&quot;_fontsize&quot;,&quot;_subname&quot;,&quot;_fontname&quot;,&quot;_charset&quot;,
+				&quot;_baseLine&quot;,&quot;_Y_percent&quot;,&quot;_U_percent&quot;,&quot;_V_percent&quot;,
+				&quot;_selfAdjustable&quot;,&quot;_delay&quot;,&quot;_useBackgroundColor&quot;,&quot;_bg_Y_percent&quot;,
+      				&quot;_bg_U_percent&quot;,&quot;_bg_V_percent&quot;,&quot;_blend&quot;}};
+
+SCRIPT_CREATE(subtitle_script,ADMVideoSubtitle,subParam);
+
+BUILD_CREATE(subtitle_create,ADMVideoSubtitle);
+
+//__________________________________________________________________
+
+//_______________________________________________________________
+
+//__________________________________________________________________
+
+char 								*ADMVideoSubtitle::printConf(void)
+ {
+	  	static char buf[50];
+ 	
+ 				sprintf((char *)buf,&quot;Subtitle &quot;);
+        return buf;
+	}
+
+//--------------------------------------------------------	
+ADMVideoSubtitle::ADMVideoSubtitle(AVDMGenericVideoStream *in,CONFcouple *couples)
+{
+
+  uint32_t frame;
+//  char c;
+
+  _uncompressed=NULL;
+  _font=NULL;
+
+
+  _in=in;
+  memcpy(&amp;_info,_in-&gt;getInfo(),sizeof(_info));
+
+	frame=3*_in-&gt;getInfo()-&gt;width*_in-&gt;getInfo()-&gt;height;
+
+	_subs=NULL;
+	_fd=NULL;
+ 	_line=0;
+	_oldframe=0;
+	_oldline=0;
+	_font = new ADMfont();	
+	if(couples)
+	{
+                int32_t b;
+			SUBCONF *_param;
+			_conf=NEW( SUBCONF);
+
+
+			_param=_conf; // keep macro happy
+
+			GET(_fontsize);
+			GET(_subname);
+			GET(_fontname);
+			GET(_charset);
+			GET(_baseLine);
+			GET(_Y_percent);
+			GET(_U_percent);
+			GET(_V_percent);
+			GET(_selfAdjustable);
+			GET(_delay);
+			GET(_useBackgroundColor);
+			GET(_bg_Y_percent);
+      			GET(_bg_U_percent);
+      			GET(_bg_V_percent);
+//                        GET(_blend);
+                        couples-&gt;getCouple(&quot;_blend&quot;,&amp;b);
+                        _param-&gt;_blend=(BlendMode)b;
+			if(_conf-&gt;_baseLine&gt;_info.height-_conf-&gt;_fontsize*SRT_MAX_LINE)
+                        {
+                                printf(&quot;Base exceeded : base :%lu height :%lu bottom:%lu\n&quot;,
+                                        _conf-&gt;_baseLine,_info.height,_info.height-_conf-&gt;_fontsize*SRT_MAX_LINE);
+                                _conf-&gt;_baseLine=_conf-&gt;_fontsize*SRT_MAX_LINE;
+                        }
+
+                    char *ft,*sub;
+                        ft=(char *)ADM_alloc(500);
+                        sub=(char *)ADM_alloc(500);
+                        strcpy(ft,(char *)_conf-&gt;_subname); 
+                        _conf-&gt;_subname=(ADM_filename *)ft;
+                        strcpy(sub,(char *)_conf-&gt;_fontname); 
+                        _conf-&gt;_fontname=(ADM_filename *)sub;
+
+                        sub=(char *)ADM_alloc(500);
+                        strcpy(sub,_conf-&gt;_charset);
+                        _conf-&gt;_charset=sub;
+                        loadSubtitle();
+                        loadFont();
+
+	}
+	else
+	{
+			_conf=NEW( SUBCONF);
+
+			_conf-&gt;_fontname=(ADM_filename *)ADM_alloc(500);
+			_conf-&gt;_subname=(ADM_filename *)ADM_alloc(500);
+			_conf-&gt;_charset=(char *)ADM_alloc(500);
+			_conf-&gt;_fontname[0]=0;
+			_conf-&gt;_subname[0]=0;
+			_conf-&gt;_charset[0]=0;
+			
+			
+			_conf-&gt;_baseLine=_info.height-24*SRT_MAX_LINE;
+			_conf-&gt;_Y_percent=255;
+			_conf-&gt;_U_percent=0;
+			_conf-&gt;_V_percent=0;
+                        _conf-&gt;_fontsize=24; 
+			_conf-&gt;_selfAdjustable=0;
+			_conf-&gt;_delay=0;
+			_conf-&gt;_useBackgroundColor=0;
+			
+			_conf-&gt;_bg_Y_percent=0;
+			_conf-&gt;_bg_U_percent=0;
+			_conf-&gt;_bg_V_percent=0;
+                        _conf-&gt;_blend=BLEND_SOLID;
+
+			prefs-&gt;get(FILTERS_SUBTITLE_FONTSIZE,&amp;(_conf-&gt;_fontsize));
+			prefs-&gt;get(FILTERS_SUBTITLE_YPERCENT,&amp;(_conf-&gt;_Y_percent));
+			prefs-&gt;get(FILTERS_SUBTITLE_UPERCENT,&amp;(_conf-&gt;_U_percent));
+			prefs-&gt;get(FILTERS_SUBTITLE_VPERCENT,&amp;(_conf-&gt;_V_percent));
+			prefs-&gt;get(FILTERS_SUBTITLE_SELFADJUSTABLE,&amp;(_conf-&gt;_selfAdjustable));			
+			prefs-&gt;get(FILTERS_SUBTITLE_USEBACKGROUNDCOLOR,&amp;(_conf-&gt;_useBackgroundColor));
+			
+			// _conf-&gt;_fontname, ... are used as memory for a dialog
+			// later. we can't used the length of the current string
+			{ char *tmp;
+			   prefs-&gt;get(FILTERS_SUBTITLE_FONTNAME,&amp;tmp);
+			   strcpy((char *)_conf-&gt;_fontname,tmp);
+			   ADM_dealloc(tmp);
+			   
+			   prefs-&gt;get(FILTERS_SUBTITLE_CHARSET,&amp;tmp);
+			   strcpy(_conf-&gt;_charset,tmp); 
+                           ADM_dealloc(tmp);
+			}
+			
+	}
+
+  
+  	_info.encoding=1;
+
+
+	_bitmap=0xffffffff;
+#define BITMAP_SIZE _info.width*_conf-&gt;_fontsize*SRT_MAX_LINE
+	_bitmapBuffer=new uint8_t[_info.width*_info.height];
+	_maskBuffer=new uint8_t[_info.width*_info.height];
+  _bgBitmapBuffer=new uint8_t[(_info.width*_info.height)&gt;&gt;1];
+	_bgMaskBuffer=new uint8_t[_info.width*_info.height];
+        _dirty=new uint8_t[_info.height];
+	ADM_assert(_bitmapBuffer);
+	ADM_assert(_maskBuffer);
+	ADM_assert(_bgBitmapBuffer);
+	ADM_assert(_bgMaskBuffer);
+        ADM_assert(_dirty);
+}
+uint8_t	ADMVideoSubtitle::loadSubtitle( void )
+{
+unsigned char c,d;
+			_fd=fopen((char *)_conf-&gt;_subname,&quot;rt&quot;);
+			if(!_fd)
+			{
+                          GUI_Error_HIG(_(&quot;Could not open subtitle file&quot;), NULL);
+				return 0;
+			}
+			// Try to detect utf16 files			
+			c=fgetc(_fd);
+			// Skip utf identifier if any
+			if( (c&amp;0xef)==0xef)
+			{
+                          int count=4;
+                                while(count-- &amp;&amp; c&amp;0x80) c=fgetc(_fd);
+			}
+			switch(c)
+			{
+			case '{' :
+						loadSubTitle();
+						break;
+			case '1' :
+						loadSRT();
+						break;
+			default:
+                          GUI_Error_HIG(_(&quot;Cannot identify subtitle format&quot;), NULL);
+			}
+
+  // Apply delay to subtitles
+  
+  aprintf(&quot;[debug] DELAY %d\n&quot;, _conf-&gt;_delay);
+  if(_conf-&gt;_delay)
+  {
+  	int32_t newStartTime;
+	int32_t newEndTime;
+	for(uint32_t i=0;i&lt;_line;i++) 
+	{
+		aprintf(&quot;[debug] BEFORE DELAY (%d) %d %d\n&quot;,i, _subs[i].startTime,_subs[i].endTime);
+		newStartTime=_subs[i].startTime;
+		newStartTime+=_conf-&gt;_delay;
+		_subs[i].startTime=(newStartTime);
+		newEndTime=_subs[i].endTime;
+		newEndTime+=_conf-&gt;_delay;
+		_subs[i].endTime=(newEndTime);
+		// put them at infinit display time
+		// should get rid of them
+		if(newEndTime&lt;0 || newStartTime&lt;0)
+		{
+			_subs[i].startTime=_subs[i].endTime=0;
+		}
+		aprintf(&quot;[debug] AFTER DELAY (%d) %d %d\n&quot;,i, _subs[i].startTime,_subs[i].endTime);
+  	}
+  }
+
+
+	fclose(_fd);
+	_fd=NULL;
+	_bitmap=0xffffffff;
+	if(_line)	// that way we will have the first sub
+		_oldline=_line-1;
+	return 1;
+}
+uint8_t	ADMVideoSubtitle::getCoupledConf( CONFcouple **couples)
+{
+SUBCONF *_param;
+
+			_param=_conf; // keep macro happy
+			ADM_assert(_param);
+			*couples=new CONFcouple(15);
+
+			CSET(_fontsize);
+			CSET(_subname);
+			CSET(_fontname);
+			CSET(_charset);
+			CSET(_baseLine);
+			CSET(_Y_percent);
+			CSET(_U_percent);
+			CSET(_V_percent);
+			CSET(_selfAdjustable);
+			CSET(_delay);
+			CSET(_useBackgroundColor);
+			CSET(_bg_Y_percent);
+			CSET(_bg_U_percent);
+			CSET(_bg_V_percent);
+                        (*couples)-&gt;setCouple(&quot;_blend&quot;,(uint32_t)_param-&gt;_blend);
+
+		return 1;
+
+}
+//__________________________________________________________________
+
+ADMVideoSubtitle::~ADMVideoSubtitle()
+{
+
+		if(_bitmapBuffer)
+			{
+				delete [] _bitmapBuffer;
+				_bitmapBuffer=0;
+			}
+		if(_maskBuffer)
+			{
+				delete [] _maskBuffer;
+				_maskBuffer=0;
+			}
+
+ 		if(_bgBitmapBuffer) 
+			{
+				delete [] _bgBitmapBuffer;
+				_bgBitmapBuffer=0;
+			}
+ 
+		if(_bgMaskBuffer) 
+			{
+				delete [] _bgMaskBuffer;
+				_bgMaskBuffer=0;
+			}
+                if(_dirty)
+                {
+                                delete [] _dirty;
+                                _dirty=0;
+                }
+
+		if(_fd)
+		{
+				fclose(_fd);
+				_fd=NULL;
+		}
+		if(_subs)
+		{
+				for(uint32_t i=0;i&lt;_line;i++)
+				{
+					if(_subs[i].nbLine)
+					{
+					for(uint32_t k=0;k&lt;_subs[i].nbLine;k++)
+					{					
+						if(_subs[i].string[k])
+						{
+							delete [] _subs[i].string[k];
+							_subs[i].string[k]=NULL;
+						}
+					}					
+					
+					delete _subs[i].string;
+					_subs[i].string=NULL;
+					delete _subs[i].lineSize;
+					_subs[i].lineSize=NULL;
+					}
+				}
+				delete [] _subs;
+				_subs=NULL;
+		}
+	if(_conf)
+	{
+			ADM_dealloc(_conf-&gt;_subname);
+			ADM_dealloc(_conf-&gt;_fontname);
+			ADM_dealloc(_conf-&gt;_charset);
+
+		 	DELETE(_conf);
+	}
+	if(_font)
+	{
+		delete _font;
+		_font=NULL;
+	}
+}
+
+uint8_t DIA_srt(AVDMGenericVideoStream *source, SUBCONF *param);
+    
+uint8_t ADMVideoSubtitle::configure(AVDMGenericVideoStream *instream)
+{
+  
+  UNUSED_ARG(instream);
+//char c;
+uint8_t ret=0;
+int charset=0;
+uint32_t l,f;
+
+                        
+          if(DIA_srt(	instream,_conf))
+          {
+            printf(&quot;\n Font : %s&quot;, _conf-&gt;_fontname);
+            printf(&quot;\n Sub  : %s&quot;, _conf-&gt;_subname);
+            printf(&quot;\n Font size : %ld&quot;,_conf-&gt;_fontsize);
+            printf(&quot;\n Charset : %d&quot;,charset);
+            printf(&quot;\n Y : %ld&quot;,_conf-&gt;_Y_percent);
+            printf(&quot;\n U : %ld&quot;,_conf-&gt;_U_percent);
+            printf(&quot;\n V : %ld&quot;,_conf-&gt;_V_percent);
+
+
+            loadSubtitle();
+            loadFont();
+                        
+            prefs-&gt;set(FILTERS_SUBTITLE_FONTNAME,
+                    (ADM_filename *)_conf-&gt;_fontname);
+            prefs-&gt;set(FILTERS_SUBTITLE_CHARSET,
+                    _conf-&gt;_charset);
+            prefs-&gt;set(FILTERS_SUBTITLE_FONTSIZE,_conf-&gt;_fontsize);
+            prefs-&gt;set(FILTERS_SUBTITLE_YPERCENT,_conf-&gt;_Y_percent);
+            prefs-&gt;set(FILTERS_SUBTITLE_UPERCENT,_conf-&gt;_U_percent);
+            prefs-&gt;set(FILTERS_SUBTITLE_VPERCENT,_conf-&gt;_V_percent);
+            prefs-&gt;set(FILTERS_SUBTITLE_SELFADJUSTABLE,
+                        _conf-&gt;_selfAdjustable);
+            prefs-&gt;set(FILTERS_SUBTITLE_USEBACKGROUNDCOLOR,
+                        _conf-&gt;_useBackgroundColor);
+            ret=1;
+        }
+        return ret;
+
+}
+#endif
+

Copied: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidSRT.h (from rev 3497, branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidSRT.h)

Copied: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidSRTRender.cpp (from rev 3497, branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidSRTRender.cpp)
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidSRTRender.cpp	2007-08-13 08:19:48 UTC (rev 3497)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidSRTRender.cpp	2007-08-13 13:47:25 UTC (rev 3501)
@@ -0,0 +1,797 @@
+/***************************************************************************
+                          ADM_vidSRT.cpp  -  description
+                             -------------------
+    begin                : Thu Dec 12 2002
+    copyright            : (C) 2002 by mean
+    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include &quot;config.h&quot;
+
+#include &lt;stdio.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;string.h&gt;
+#include &lt;math.h&gt;
+#include &lt;math.h&gt;
+#include &lt;iconv.h&gt;
+
+
+#ifdef USE_FREETYPE
+
+#include &quot;default.h&quot;
+#include &quot;ADM_osSupport/ADM_misc.h&quot;
+
+
+#include &quot;ADM_toolkit/toolkit.hxx&quot;
+
+#include &quot;ADM_editor/ADM_edit.hxx&quot;
+#include &quot;ADM_video/ADM_genvideo.hxx&quot;
+
+#include &quot;ADM_video/ADM_vidFont.h&quot;
+#include &quot;ADM_videoFilter/ADM_vidSRT.h&quot;
+#include &lt;ADM_assert.h&gt;
+
+#include &quot;ADM_osSupport/ADM_debugID.h&quot;
+#define MODULE_NAME MODULE_FILTER
+#include &quot;ADM_osSupport/ADM_debug.h&quot;
+
+
+#define SUB_OUT 0xf0000000
+
+#define ALPHA
+
+#define LUMA_LEVEL 10
+
+#define SAFE_STRCPY(dest,destLen,src,srcLen) \
+memcpy(dest,src,srcLen&lt;destLen?srcLen:destLen-1); \
+dest[srcLen&lt;destLen?srcLen:destLen-1]='\0'; \
+
+
+//                     1
+//		Get in range in 121 + coeff matrix
+//                     1
+//
+// If the value is too far away we ignore it
+// else we blend
+//__________________________________________________________________
+uint8_t ADMVideoSubtitle::getFrameNumberNoAlloc(uint32_t frame,
+						uint32_t *len,
+   						ADMImage *data,
+   						uint32_t *flags)
+{
+
+double f;
+uint32_t time,srch;
+uint32_t absFrame=frame+_info.orgFrame;
+
+	//		printf(&quot;\n Stabilize : %lu\n&quot;,frame);
+          _uncompressed=data;
+	if(frame&gt;=_info.nb_frames) 
+	{
+		printf(&quot;Filter : out of bound!\n&quot;);
+		return 0;
+	}
+	if(!_in-&gt;getFrameNumberNoAlloc(frame, len,data,flags)) return 0;
+
+	// if no subtitle return...
+	if(!_subs) return 1;
+
+	// compute time stamp
+	      f=absFrame*1000000./_info.fps1000;
+	      time=(uint32_t) floor(f);
+	      // Do we have it already ?
+
+	      if(time&lt;=_subs[_oldline].endTime &amp;&amp; time &gt;=_subs[_oldline].startTime)
+	      {
+	      		aprintf(&quot;Sub: cached %lu %lu %lu\n&quot;,time,_subs[_oldline].startTime,_subs[_oldline].endTime);
+			blend(YPLANE(data),_conf-&gt;_baseLine); // re-use it
+			return 1;	
+
+	      }
+	      srch=search(time);
+	      // we got the right one
+     
+	      if(srch!=SUB_OUT) // we got something...
+			{
+					_oldline=srch;
+					aprintf(&quot;Sub: Using line %d\n&quot;,srch);
+					//printf(&quot;\n %s \n&quot;,_subs[_oldline].string);
+					displayString(&amp;(_subs[_oldline]));
+					blend(YPLANE(data),_conf-&gt;_baseLine);
+			}
+
+		return 1;
+
+}
+//_________________________________________________________________
+uint32_t	ADMVideoSubtitle::search(uint32_t time)
+{
+	if(time&lt;_subs[0].startTime)
+		return SUB_OUT;
+
+	  for(uint32_t i=0;i&lt;_line;i++)
+	  {
+				if((time&lt;=_subs[i].endTime)  &amp;&amp;
+					(time&gt;=_subs[i].startTime)
+				)
+				return i;
+
+		}
+		return SUB_OUT;
+}
+//
+//	Display up to 3 lines of text centered on screen
+//  Each line is separated by a |
+// It is the basic version that tries to use only 2 lines
+// in most cases, 3 when needed
+//______________________________________
+void ADMVideoSubtitle::displayString(subLine *string)
+{
+ 
+	uint32_t base=0;	
+	uint32_t nbLine=0;
+	uint32_t i=0;
+	uint32_t overflow=0;
+
+      aprintf(&quot;Sub: Rendering string %s\n&quot;,string);
+// bbase is the final position in line
+// in the image
+
+	clearBuffers();
+	nbLine=string-&gt;nbLine;
+	if(nbLine&gt;SRT_MAX_LINE )
+	{
+		nbLine=SRT_MAX_LINE;
+		printf(&quot;Too much lines\n&quot;);
+	}
+	switch(nbLine)
+	{
+		case 0:
+			base=2*_conf-&gt;_fontsize;; // 1 or 2 lines we dont use the upper line		
+			break;
+		case 1:
+			base=_conf-&gt;_fontsize;; // 1 or 2 lines we dont use the upper line		
+			break;
+		default:
+                        base=0;
+                        break;
+	}	
+		
+	aprintf(&quot;Sub: %d lines to render\n&quot;,nbLine);
+	// scan and display each line
+	for(i=0;i&lt;nbLine;i++)
+	{
+		
+			if(string-&gt;lineSize[i]!=displayLine(string-&gt;string[i],base,string-&gt;lineSize[i]))
+                                overflow=1;
+			base+=_conf-&gt;_fontsize;
+		
+	}
+        if(overflow &amp;&amp; _conf-&gt;_selfAdjustable) 
+        {
+                printf(&quot;Do autosplit\n&quot;);
+                doAutoSplit(string);
+        }
+    	doChroma();
+	// Compute the dirty state
+        // If a line is not set as dirty, it means it has no pixel in it
+        // In fact we do top/bottom and add a tiny bit to it
+        memset(_dirty,1,_info.height);
+
+        // First to top
+
+        int top=0,bottom=_info.height-1,limit;
+        while(top&lt;_info.height &amp;&amp; !isDirty(top)) top++;
+        if(top&gt;_conf-&gt;_fontsize&gt;&gt;1) top-=_conf-&gt;_fontsize&gt;&gt;1;
+        memset(&amp;(_dirty[0]),0,top); // Clear top
+        
+        // Then bottom
+        limit=(SRT_MAX_LINE+1)*_conf-&gt;_fontsize;
+        if(limit&gt;=_info.height) limit=_info.height-1;
+
+
+        bottom=limit;
+        while(bottom&gt;top &amp;&amp; !isDirty(bottom)) bottom--;
+        if(bottom+(_conf-&gt;_fontsize&gt;&gt;1)&lt;limit) bottom+=_conf-&gt;_fontsize&gt;&gt;1;
+        ADM_assert(bottom&lt;=limit);
+        memset(&amp;(_dirty[bottom]),0,limit-bottom+1);
+        //printf(&quot;Top:%d bottom :%d limit:%d\n&quot;,top,bottom,limit);
+	
+}
+uint8_t ADMVideoSubtitle::isDirty(int line)
+{
+        uint8_t *base=_maskBuffer+_info.width*line;
+        for(int x=0;x&lt;_info.width;x++)
+        {
+                if(base[x]) return 1;
+        }
+        return 0;
+}
+/*
+        We merge the whole lines into one then split it
+        to avoid truncated subs
+*/
+void ADMVideoSubtitle::doAutoSplit(subLine *string)
+{
+        uint32_t base=0;    
+        uint32_t nbLine=0;
+        uint32_t i=0;
+        int      total=0,start,end,pivot;
+
+        aprintf(&quot;Sub: Autospliting \n&quot;);
+        nbLine=string-&gt;nbLine;
+
+        // Merge all strings into one
+
+        for(int i=0;i&lt;nbLine;i++) 
+                total+=1+string-&gt;lineSize[i];
+
+        ADM_GLYPH_T allwords[total];
+        int         offset[total];
+        int         sentence[total];
+        int         nbWords=0;
+        //
+        start=0;
+        for(int i=0;i&lt;nbLine;i++) 
+        {
+                memcpy(&amp;(allwords[start]),string-&gt;string[i],string-&gt;lineSize[i]*sizeof(ADM_GLYPH_T));
+                start+=string-&gt;lineSize[i];
+                allwords[start]=' ';
+                start++;
+        }
+        // Remove the last ' '
+        start--;
+        end=start;
+        // Here we go, we have now one line made of all merged sub
+        // We will put as much as possible into one displayed line
+        // then switch to the next one
+        //
+        printf(&quot;The new stuff is :&lt;&quot;);
+        for(i=0;i&lt;end;i++)
+                printf(&quot;%c&quot;,allwords[i]);
+        printf(&quot;&gt;\n&quot;);
+        
+        // Split into words
+        pivot=0;
+        int car;
+        offset[0]=0;
+        nbWords=1;
+        while(pivot&lt;end)
+        {
+                car=ADM_ASC(allwords[pivot]);
+                if(car==' ' || car=='.' || car ==',')
+                        {
+                                offset[nbWords++]=pivot;
+                        }
+                pivot++;
+        }
+        printf(&quot;Found %d words\n&quot;,nbWords); 
+        // Now  split
+        int nbSentence=0,len;
+        pivot=0;
+        sentence[0]=0;
+        // Try to display as much as possible in one line
+        // We build sentence here
+        while(pivot&lt;nbWords)
+        {
+                for(i=pivot+1;i&lt;nbWords;i++)
+                {
+                        len=offset[i]-offset[pivot];
+                        if(len!=displayLine(&amp;(allwords[offset[pivot]]),0,len)) break;
+                }
+                sentence[nbSentence]=offset[pivot];
+                nbSentence++;
+                if(i&gt;1 &amp;&amp; i!=nbWords) i--;
+                pivot=i;
+        }
+        printf(&quot;0: %d,off:%d\n&quot;,sentence[0],offset[0]);
+        // Take the last word
+        sentence[nbSentence]=end;
+
+        if(nbSentence&gt;SRT_MAX_LINE) nbSentence=SRT_MAX_LINE;
+        // now display
+        printf(&quot;Nb sentence:%d\n&quot;,nbSentence);
+        for(int j=0;j&lt;nbSentence;j++)
+        {
+                printf(&quot;Sentence %d:&quot;,j);
+                for(int k=sentence[j];k&lt;sentence[j+1];k++)
+                        printf(&quot;%c&quot;,allwords[k]);
+                printf(&quot;\n&quot;);
+        }
+        // now display
+        
+        switch(nbSentence)
+        {
+                case 0:
+                        base=2*_conf-&gt;_fontsize;; // 1 or 2 lines we dont use the upper line            
+                        break;
+                case 1:
+                        base=_conf-&gt;_fontsize;; // 1 or 2 lines we dont use the upper line              
+                        break;
+                default:
+                        base=0;
+                        break;
+        }
+        // scan and display each line
+        clearBuffers();
+        printf(&quot;Display\n&quot;);
+        for(i=0;i&lt;nbSentence;i++)
+        {
+                        len=sentence[i+1]-sentence[i];
+                        displayLine(&amp;(allwords[sentence[i]]),base,len);
+                        //displayLine(allwords,base,10);
+                        base+=_conf-&gt;_fontsize;
+        }
+        printf(&quot;/Display\n&quot;);
+        
+}
+/*
+        Once we have the subtitle built, we do the u&amp; v planes
+        and some smoothing to avoid over sharpening on the chroma plane
+
+*/
+uint8_t ADMVideoSubtitle::doChroma(void)
+{
+// now blur bitmap into mask..
+        memset(_maskBuffer,0,SRT_MAX_LINE*_conf-&gt;_fontsize*_info.width);
+
+        uint32_t off;
+        uint8_t *src,*dst;
+
+        off=0;
+
+        src=_bitmapBuffer;
+        dst=_maskBuffer;
+
+
+        // We shrink it down for u &amp; v by 2x2
+        // mask buffer-&gt;bitmap buffer
+
+        uint8_t tmp[_info.width*_info.height];
+
+        decimate(src,tmp,_info.width,_info.height);
+        lowPass(src,dst,_info.width,_info.height);
+        lowPass(tmp,src,_info.width&gt;&gt;1,_info.height&gt;&gt;1);
+
+        if (_conf-&gt;_useBackgroundColor) 
+        {
+                decimate(_bgMaskBuffer,_bgBitmapBuffer,_info.width,_info.height);
+                //lowPass(tmp,_bgBitmapBuffer,_info.width&gt;&gt;1,_info.height&gt;&gt;1);
+        }
+  
+}
+/*
+        Clear the buffers in case we do a new sub or
+                redo one in case it overflows
+*/
+uint8_t ADMVideoSubtitle::clearBuffers(void)
+{
+        memset(_bitmapBuffer,0,_info.height*_info.width);
+        memset(_maskBuffer,0,_info.height*_info.width);
+        memset(_bgBitmapBuffer,0,(_info.height*_info.width)&gt;&gt;1);
+        memset(_bgMaskBuffer,0,_info.height*_info.width);
+        return 1;
+}
+// Display a full line centered on screen. It returns the
+// number of displayed chars.
+//____________________________________________________________
+
+// It also returns the suggested len for this line string (just when display fail)
+//
+uint32_t ADMVideoSubtitle::displayLine(ADM_GLYPH_T *string,uint32_t line, uint32_t len)
+{
+  // n first chars in string that can &quot;fit&quot; in this line
+ 
+
+	//uint32_t pixstart;
+	uint8_t *target;
+	int car;
+
+
+	aprintf(&quot;Sub DisplayString  line %lu len %lu\n&quot;,line,len);
+
+	if(!len)
+	{
+		printf(&quot;\n null string\n&quot;);
+      		return 0;
+	}
+
+
+  
+	uint32_t w=0,next;
+	int ww;
+
+	// we dummy do it one time to get the actual width of the string
+	// and hence perfectly center it
+	target=_maskBuffer+_info.width*line;
+	for(uint32_t i=0;i&lt;len;i++)
+	{
+			if(ADM_ASC(*(string+i))==' ')
+			{
+					w+=_conf-&gt;_fontsize&gt;&gt;2;
+			}
+			else
+			{
+				ww=0;
+				car=string[i];
+				if(i) next=string[i-1];
+					else next=0;
+				// Change ' to &quot;
+				//if(ADM_ASC(car)==0x27)
+				//	car=0x22;
+	        		if(!_font-&gt;fontDraw((char *)(target+1+w),car,next , _info.width,_conf-&gt;_fontsize,&amp;ww))
+				{
+					printf(&quot;Font error\n&quot;);
+              return 0;
+				}
+				if((ww&lt;0)||(ww&gt;64))
+				{
+					printf(&quot;Warning w out of bound (%d)\n&quot;,ww);
+					ww=0;
+				}
+				if(w+ww&gt;_info.width)
+				{
+					printf(&quot;Line too long!\n&quot;);
+					len=i;
+					goto _abt;
+					break;
+				}
+				w=w+ww;
+			}
+      
+	}
+_abt:
+	//Now we can render it at its final position
+	if(w&lt;_info.width)
+	{
+		target=_bitmapBuffer+_info.width*line+((_info.width-w)&gt;&gt;1);
+	}
+	else
+	{
+		target=_bitmapBuffer+_info.width*line+1;
+	}
+
+  //printf(&quot;[debug] line %s\n&quot;,string);
+
+	ww=0;
+	w=0;
+	for(uint32_t i=0;i&lt;len;i++)
+	{
+			if(*(string+i)==' ')
+			{
+					w+=_conf-&gt;_fontsize&gt;&gt;2;
+
+			}
+			else
+			{
+				ww=0;
+				car=string[i];
+				if(i) next=string[i-1];
+					else next=0;
+	        		if(!_font-&gt;fontDraw((char *)(target+1+w),car,next , _info.width,_conf-&gt;_fontsize,&amp;ww))
+				{
+					printf(&quot;Font error\n&quot;);
+              return 0;
+				}
+				if((ww&lt;0)||(ww&gt;64))
+				{
+					printf(&quot;Warning w out of bound (%d)\n&quot;,ww);
+					ww=0;
+				}
+				w=w+ww;
+			}
+      
+	}
+
+  {
+    if (_conf-&gt;_useBackgroundColor) {
+      //Create background info
+      
+      int32_t delta=_info.width*line+((_info.width-w)&gt;&gt;1);
+      uint8_t *bitmapTarget=_bitmapBuffer+delta;
+      uint8_t *maskTarget=_maskBuffer+delta;
+      //uint8_t *bgBitmapTarget=_bgBitmapBuffer+delta;
+      uint8_t *bgMaskTarget=_bgMaskBuffer+delta;
+      
+      delta=3*_info.width;
+      bitmapTarget+=delta;
+      maskTarget+=delta;
+      //bgBitmapTarget+=delta;
+      bgMaskTarget+=delta;
+      
+      for (uint32_t i=0;i&lt;_conf-&gt;_fontsize;i++) {
+	//memset(bgTarget,1,w);
+	for (uint32_t j=0;j&lt;w;j++) {
+	  if (*(bitmapTarget+j)==0) {
+	    *(bgMaskTarget+j)=1;   //at this position, we will apply a different color
+	    //*(bgBitmapTarget+j)=1;
+	    *(maskTarget+j)=0;
+	    *(bitmapTarget+j)=0;
+	  }
+	}
+	bgMaskTarget+=_info.width;
+	//bgBitmapTarget+=_info.width;
+	maskTarget+=_info.width;
+	bitmapTarget+=_info.width;
+      }
+
+    }
+  }
+	
+
+ 
+  return len;
+}
+//--------------------------------------------------------------------
+//
+//	Blend bitmap buffer into final screen
+//      We scan the SRT_MAX_LINE last line
+//--------------------------------------------------------------------
+uint8_t ADMVideoSubtitle::blend(uint8_t *target,uint32_t baseLine)
+{
+
+	uint8_t  *mask; //*oldtarget=target,*
+  uint8_t  *bgMask;
+	int8_t *chromatarget;
+	uint32_t hei,start;
+	uint32_t y;
+	uint32_t val;
+	int32_t ssigned;
+	double alpha,alpha2;
+#define SHADOW_UP 	8
+#define SHADOW_DOWN 	16
+
+	hei=(SRT_MAX_LINE+1)*_conf-&gt;_fontsize;
+	if(hei&gt;=_info.height-1) hei=_info.height-1;
+	hei*=_info.width;  // max height of our subtitle
+	
+
+	aprintf(&quot;Sub:Rendering : %d %d %d (yuv)\n&quot;,_conf-&gt;_Y_percent,_conf-&gt;_U_percent,_conf-&gt;_V_percent);
+	
+	// keep a little margin for renderin
+	// to render f y or g
+	if((baseLine) &gt; _conf-&gt;_fontsize)
+		baseLine-=_conf-&gt;_fontsize&gt;&gt;1;
+	
+		
+	//__________________________
+		
+		// Shadow ..
+		uint8_t *shadow=target;
+		uint32_t shadow_pos;
+		
+		shadow_pos=_conf-&gt;_fontsize/10;
+		start=_info.width*baseLine;  // base line in final image
+		// mask out left and right
+		mask=_maskBuffer; 
+				
+ 		shadow+=start+(1+_info.width)*shadow_pos;
+  		for( y=hei;y&gt;0;y--)
+		{
+     		 if(*mask) 
+		 {
+				if(*mask&gt;LUMA_LEVEL)
+				{
+					val=*shadow;
+					val=(val*SHADOW_UP)/SHADOW_DOWN;
+					*shadow=(uint8_t )val;
+				}				
+     		 } 	  
+      
+		shadow++;
+		mask++;
+		}
+	
+	// /Shadow
+	//__________________________
+	start=_info.width*baseLine;  // base line in final image
+
+	chromatarget=(int8_t *)(target+(_info.width*_info.height));
+
+	// mask out left and right
+
+	mask=_maskBuffer;
+  	bgMask=_bgMaskBuffer;
+ 	target+=start;
+        // clip 
+        if(hei+start&gt;_info.width*_info.height)
+        {
+                hei=_info.width*_info.height-start;
+        }
+// Luma
+        int bottom=baseLine+(SRT_MAX_LINE+1)*_conf-&gt;_fontsize;
+        if(bottom&gt;_info.height) bottom=_info.height;
+        for( y=baseLine;y&lt;bottom;y++)
+        {
+            if(!_dirty[y-baseLine])
+            {
+                target+=_info.width;
+                mask+=_info.width;
+                bgMask+=_info.width;
+                 continue;
+            }
+            for(int x=0;x&lt;_info.width;x++)
+            {
+                if(*mask) {
+                                if(*mask&gt;LUMA_LEVEL || _conf-&gt;_useBackgroundColor)
+                                {
+                                        val=*mask*_conf-&gt;_Y_percent+128;
+                                        val&gt;&gt;=8;
+                                        *target=(uint8_t )val;
+                                }
+                                else 
+                                        { *target=0; }
+                        } else 
+                        if(*bgMask)
+                        {
+                                if(_conf-&gt;_useBackgroundColor) 
+                                {
+                                        *target=(uint8_t )_conf-&gt;_bg_Y_percent;
+                                }
+                        }
+                        else
+                                {
+                                        switch(_conf-&gt;_blend)
+                                        {
+                                                case BLEND_SOLID: break;
+                                                case BLEND_DIMMER: *target=(*target*3)&gt;&gt;2;break;
+                                                case BLEND_DOTTED: 
+                                                {
+                                                        int odd;
+                                                                odd= y%_info.width;
+                                                                odd=odd&amp;1;
+                                                                odd+=(1&amp;(y/_info.width));
+                                                                odd&amp;=1;
+                                                                if(odd) *target=0; 
+                                                }
+                                        }
+                                }
+                        
+                target++;
+                mask++;
+                bgMask++;
+              }
+        }
+	
+
+// do u &amp; v
+	int8_t *ctarget;
+
+	baseLine&amp;=0xffffe;
+	start=(_info.width*baseLine)&gt;&gt;2;
+	hei&gt;&gt;=2;
+
+	mask=_bitmapBuffer;
+  	bgMask=_bgBitmapBuffer;
+	ctarget=chromatarget+start;
+	target=(uint8_t *)ctarget;
+
+	ssigned=_conf-&gt;_U_percent;
+	ssigned+=128;
+
+  uint8_t bg_val=(uint8_t) _conf-&gt;_bg_U_percent+128;
+
+//#define MAXVAL(x) {val=*mask*(x)+127;val&gt;&gt;=8;*ctarget=(uint8_t)(val&amp;0xff);}
+
+#define BLEND_LEVEL 	3
+#define BLEND_PERCENT 	20
+
+#define MAXVAL(x)  *target=(uint8_t )ssigned
+#define DOIT if(*mask) \
+		{ \
+			alpha=*mask; \
+			if(alpha&gt;BLEND_LEVEL) \
+				*target=(uint8_t)ssigned; \
+			else			\
+			{			\
+				alpha2=(100-BLEND_PERCENT)*(*target-128); \
+				alpha=BLEND_PERCENT*(ssigned-128); \
+				alpha=(alpha2+alpha)/100; \
+				*target=(uint8_t)(alpha+128) ;\
+			} \
+                } \
+             else if (_conf-&gt;_useBackgroundColor &amp;&amp; *bgMask) {*target=(uint8_t)bg_val;}
+	     
+#define RENDER	     \
+	\
+	for( y=hei;y&gt;0;y--) \
+	{ \
+		DOIT; \
+		ctarget++; \
+		target++; \
+		mask++; \
+	bgMask++; \
+	} \
+	
+	RENDER;
+
+	mask=_bitmapBuffer;
+  	bgMask=_bgBitmapBuffer;
+	ctarget=chromatarget+start+((_info.width*_info.height)&gt;&gt;2);;
+	target=(uint8_t *)ctarget;
+	ssigned=_conf-&gt;_V_percent;
+	ssigned+=128;
+
+  	bg_val=(uint8_t) _conf-&gt;_bg_V_percent+128;
+
+	RENDER;
+
+
+	return 1;
+}
+//
+//	Apply a low pass to alias it
+//					1
+// The softening is a 1 4 1  convolution filter
+//					1
+uint8_t ADMVideoSubtitle::lowPass(uint8_t *src, uint8_t *dst, uint32_t w, uint32_t h)
+{
+	uint8_t *prevline, *nextline,*curline,*target;
+	uint32_t val;
+
+	memcpy(dst,src,w*h);
+
+	src++;dst++;
+
+			for(uint32_t line=h-1;line&gt;0;line--)
+			{
+				curline=src+line*w;
+				nextline=curline+w;
+				prevline=curline-w;
+				target=dst+line*w;
+				for(uint32_t col=w-1;col&gt;1;col--)
+				{
+#define LEVEL 8*90
+					// 1 4 1
+					val= (*(curline)*4+*prevline+*nextline+*(curline-1)+*(curline+1));
+					if(val&gt; 0 )
+					if(val&lt;LEVEL)
+						val=1;  // just enough to trigger masking
+					else
+						val&gt;&gt;=3;
+					*target=val;
+					target++;
+					curline++;
+					prevline++;
+					nextline++;
+				}
+
+			}
+	return 1;
+}
+//
+//	Decimate 2x2 (luma-&gt;chroma)
+//					1
+//					1
+uint8_t ADMVideoSubtitle::decimate(uint8_t *src, uint8_t *dst, uint32_t w, uint32_t h)
+{
+	uint8_t	*curline, *nextline;
+	uint8_t *target=dst;
+
+			for(uint32_t line=0;line&lt;h&gt;&gt;1;line++)
+			{
+				curline=src+line*w*2;
+				nextline=curline+w;
+				target=dst+line*(w&gt;&gt;1);
+				for(uint32_t col=0;col&lt;w&gt;&gt;1;col++)
+				{
+					// 1 4 1
+					*target= (*(curline)+*(curline+1)+*nextline+*(nextline+1))&gt;&gt;2;
+					target++;
+					curline+=2;
+					nextline+=2;
+				}
+
+			}
+	return 1;
+}
+
+#endif

Copied: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidSRTload.cpp (from rev 3497, branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidSRTload.cpp)
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidSRTload.cpp	2007-08-13 08:19:48 UTC (rev 3497)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidSRTload.cpp	2007-08-13 13:47:25 UTC (rev 3501)
@@ -0,0 +1,497 @@
+/***************************************************************************
+                          ADM_vidload.cpp  -  description
+                             -------------------
+
+	Load the subtitles either in srt or sub format
+
+	The structure is
+		uint32_t 		startTime in ms from beginning
+		uint32_t 		endTime  in ms from beginning
+	
+	All text are stored as utf16 after loading
+
+
+    begin                : Thu Aug 09 2003
+    copyright            : (C) 2003 by mean
+    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include &quot;config.h&quot;
+
+#include &lt;stdio.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;string.h&gt;
+#include &lt;math.h&gt;
+#include &lt;math.h&gt;
+#include &lt;iconv.h&gt;
+#include &lt;errno.h&gt;
+
+
+#ifdef USE_FREETYPE
+//#define __STDC_ISO_10646__
+#include &quot;default.h&quot;
+#include &quot;ADM_osSupport/ADM_misc.h&quot;
+
+#include &quot;ADM_toolkit/toolkit.hxx&quot;
+
+#include &quot;ADM_toolkit/toolkit.hxx&quot;
+#include &quot;ADM_editor/ADM_edit.hxx&quot;
+#include &quot;ADM_video/ADM_genvideo.hxx&quot;
+
+#include &quot;ADM_video/ADM_vidFont.h&quot;
+#include &quot;ADM_videoFilter/ADM_vidSRT.h&quot;
+#include &lt;ADM_assert.h&gt;
+
+#include &quot;ADM_osSupport/ADM_debugID.h&quot;
+#define MODULE_NAME MODULE_FILTER
+#include &quot;ADM_osSupport/ADM_debug.h&quot;
+
+#define ADM_RAW 1024
+
+static iconv_t myConv=(iconv_t)-1;;
+static int ADM_SubAtoi(uint16_t *in);
+
+static uint8_t	ADM_utfInit( char *charset );
+static uint8_t ADM_utfConv(ADM_GLYPH_T *out, char *in,uint32_t nbIn, uint32_t *nbOut);
+static uint8_t ADM_utfEnd( void);
+
+
+
+
+uint8_t	ADMVideoSubtitle::loadFont (void)
+{
+ 
+  if (!_font-&gt;initFreeType ((char *)_conf-&gt;_fontname))
+    {
+      printf (&quot;\n Free type init failed for font %s!&quot;, _conf-&gt;_fontname);
+    }
+  else
+    {
+      _font-&gt;fontSetSize (_conf-&gt;_fontsize);
+    }
+   
+  return 1;
+}
+
+//
+//      Load subtitles in .sub format i.e. {xx}{yy} |   |
+//
+// {3610}{3656}Pripraven&#65533;uv&#65533;a ich|v naom dome s primeranou ctou.
+//__________________________________________________________________
+uint8_t  ADMVideoSubtitle::loadSubTitle (void)
+{
+
+  char string[500];
+  uint32_t current_line = 0;
+  // first cound how many line
+  _line = 0;
+   // init iconv...  
+  if(! ADM_utfInit(_conf-&gt;_charset))
+  {
+  	printf(&quot;Problem initializing iconv, aborting\n&quot;);
+	return 0;
+  
+  }
+  while (fgets (string, 200, _fd))
+    {
+      _line++;
+    }
+  printf (&quot;\n subs : %ld lines\n&quot;, _line);
+  // rewind
+  fseek (_fd, 0, SEEK_SET);
+  //
+  _subs = new subLine[_line];
+  if (!_subs)
+    return 0;
+  memset (_subs, 0, sizeof (subLine) * _line);
+
+
+ 
+//	
+  for (uint32_t i = 0; i &lt; _line; i++)
+    {
+      fgets (string, ADM_RAW, _fd);
+      //printf(&quot;\n in : %s &quot;,string);
+      if (string[0] != '{')
+	continue;
+      subParse ((subLine *) &amp; (_subs[current_line]), string);
+      current_line++;
+    }
+	
+  // the effective number of line we have
+  _line = current_line;
+  return 1;
+  
+ ADM_utfEnd( );
+}
+
+//___________________________________________________________________
+//      In case of sub file, take one line and convert it to unicode
+//	we also extract the start/end and split it to N lines
+//	Does not work if input is UTF16. UTF8 is ok.
+//___________________________________________________________________
+uint8_t	ADMVideoSubtitle::subParse (subLine * in, char *string)
+{
+
+
+  static ADM_GLYPH_T 	final[ADM_RAW];	// convert to unicode
+  uint32_t   	startindex, endindex,textindex;
+  uint32_t 	j;
+  float 	f;
+ 
+  uint32_t 	finallen=0;
+  uint32_t	alpha;
+ 
+  j = 1;
+  
+  
+  ADM_utfConv(final,string,strlen(string),&amp;finallen);
+  
+  // ignore { }
+  while (ADM_ASC(final[j]) != '}' &amp;&amp; j &lt; finallen)
+    j++;
+ 
+  startindex =1;
+  j += 2;			// skip }{
+  endindex =j;
+  while (ADM_ASC(final[j]) != '}' &amp;&amp; j &lt; finallen)
+    j++;
+  // The text starts here
+  textindex = j + 1;
+
+  if (j &gt;= finallen - 1)
+    {
+      printf (&quot;***ERR: Suspicious line !!!\n&quot;);
+      return 0;
+
+    }
+
+  // convert frame -&gt; time in ms
+  // skip utf marker if present
+  alpha= ADM_SubAtoi (&amp;final[1]);
+  f=(float)alpha;
+  aprintf(&quot;%s start:%d&quot;,string,alpha);
+  f = f * 1000000. / _info.fps1000;
+  in-&gt;startTime = (uint32_t) floor (f);
+
+  alpha = ADM_SubAtoi (&amp;final[endindex]);
+  f=(float)alpha;
+  aprintf(&quot; end:%d\n&quot;,alpha);
+  f = f * 1000000. / _info.fps1000;
+  
+  in-&gt;endTime = (uint32_t) floor (f);
+
+  uint32_t lllines=0;
+  finallen-=textindex;
+  if(finallen==0)
+  	{
+		printf(&quot;Empty line\n&quot;);
+		in-&gt;nbLine=0;
+		return 1;
+	}
+  // Count the number of | found
+  for(j=0;j&lt;finallen;j++)
+  {
+  	if(ADM_ASC(final[j+textindex])=='|') lllines++;
+  }
+
+  aprintf(&quot;%lu --&gt;%lu\n&quot;,in-&gt;startTime,in-&gt;endTime);
+  in-&gt;nbLine=lllines+1;
+  in-&gt;string=new ADM_GLYPH_T *[in-&gt;nbLine];
+  in-&gt;lineSize=new uint32_t[in-&gt;nbLine];
+  
+  for(uint32_t i=0;i&lt;in-&gt;nbLine;i++)
+  {
+  	in-&gt;string[i]=new ADM_GLYPH_T[finallen]; 	// yes, we overshot
+	in-&gt;lineSize[i]=0;
+  }
+  
+  uint32_t curline=0, curindex=0;
+  for(uint32_t i=0;i&lt;finallen;i++)
+  {
+  	if(ADM_ASC(final[i+textindex])=='|')
+	{
+		in-&gt;lineSize[curline]=curindex;
+		curindex=0;
+		curline++;		
+	}
+	else
+	{
+		in-&gt;string[curline][curindex++]=final[i+textindex];
+	}
+  
+  }  
+  if(curindex)
+  	in-&gt;lineSize[curline]=curindex;
+  return 1;
+}
+
+//
+//      Load subtitles in .srt format i.e. {xx}{yy} |   |
+//__________________________________________________________________
+uint8_t
+ADMVideoSubtitle::loadSRT (void)
+{
+
+
+  static ADM_GLYPH_T 	final[ADM_RAW];	// convert to unicode
+  ADM_GLYPH_T  		temp[SRT_MAX_LINE][ADM_RAW];
+  uint32_t		tempSize[SRT_MAX_LINE];
+  char			string[ADM_RAW];
+  
+  
+  uint32_t line;  
+  uint32_t len;
+  // Init iconv
+   uint32_t 	finallen=0;
+  subLine	*current;
+  
+  if(! ADM_utfInit(_conf-&gt;_charset))
+  {
+  	printf(&quot;Problem initializing iconv, aborting\n&quot;);
+	return 0;
+  
+  } 
+  
+  // first cound how many line
+  line = 0;
+  _line = 0;
+  while (fgets (string, 300, _fd))
+    line++;
+  printf (&quot;\n subs : %ld lines\n&quot;, line);
+  // rewind
+  fseek (_fd, 0, SEEK_SET);
+  //
+  _subs = new subLine[line];
+
+  if (!_subs)
+    return 0;
+  
+  memset (_subs, 0, sizeof (subLine) * line);
+  
+  // read and allocate
+  
+  uint32_t j;
+  int state = 0;
+  int stored=0;
+  
+  for (uint32_t i = 0; i &lt; line; i++)
+    {
+	current=&amp;_subs[_line];
+	fgets (string, ADM_RAW, _fd);
+	ADM_utfConv(final,string,strlen(string),&amp;finallen);
+	// Purge cr/lf	
+	switch (state)
+	{
+	case 0:		// waiting for number	 
+                  if(!_line &amp;&amp; (final[0]&amp;0xfefe)==0xfefe)
+                  {
+                      j=ADM_SubAtoi (final+1);
+                  }
+                  else
+		      j = ADM_SubAtoi (final);
+		if (j == _line + 1)
+		{
+			stored=0;
+			state = 1;
+		}
+		break;
+	case 1:		// waiting for time
+		{
+			uint32_t sh, sm, ss, ms;
+			uint32_t dh, dm, ds, md;
+
+			ADM_GLYPH_T *cur=&amp;final[0];
+				
+	  		sh=ADM_SubAtoi(cur);
+			cur+=3;
+			sm=ADM_SubAtoi(cur);
+			cur+=3;
+			ss=ADM_SubAtoi(cur);
+			cur+=3;
+			ms=ADM_SubAtoi(cur);
+			cur+=3;
+			
+			cur+=5;
+			
+			dh=ADM_SubAtoi(cur);
+			cur+=3;
+			dm=ADM_SubAtoi(cur);
+			cur+=3;
+			ds=ADM_SubAtoi(cur);
+			cur+=3;
+			md=ADM_SubAtoi(cur);
+			
+			_subs[_line].startTime = ms + 1000 * (ss + sm * 60 + sh * 3600);
+			_subs[_line].endTime = md + 1000 * (ds + dm * 60 + dh * 3600);
+			state = 2;
+			
+			aprintf(&quot;%d %d %d %d / %d %d %d %d&gt;%s&lt;\n&quot;,sh,sm,ss,ms,dh,dm,ds,md,string);
+			
+		}
+
+		break;
+	case 2:		
+	   // looking for text
+	   // We append each line to text with a | to separate the lines	 	  
+	  {
+	  	if (finallen &lt; 2)
+	    	{
+	   		// Finished
+	      		_line++;
+	      		state = 0;
+			current-&gt;nbLine=stored;
+			current-&gt;lineSize=new uint32_t[stored];
+			current-&gt;string=new ADM_GLYPH_T *[stored];
+			for(uint32_t i=0;i&lt;stored;i++)
+			{
+				current-&gt;lineSize[i]=tempSize[i];
+				current-&gt;string[i]=new ADM_GLYPH_T[tempSize[i]];
+				memcpy(current-&gt;string[i],temp[i],sizeof(ADM_GLYPH_T)*tempSize[i]);
+			}
+	      		break;
+	    	}
+	  	else
+	    	{
+			if(stored&gt;=SRT_MAX_LINE)
+			{
+				printf(&quot;sub:Too much lines, ignoring..\n&quot;);
+				continue;
+			}
+	      		// We add it
+			memcpy(temp[stored],final,finallen*sizeof(ADM_GLYPH_T));
+			tempSize[stored]=finallen;
+			stored++;
+	    	}
+	  }
+	  break;
+
+	}
+
+    }
+  ADM_utfEnd( );
+  aprintf(&quot;&gt;&gt; Sub: %d subs stored and loaded\n&quot;,_line); 	
+  return 1;
+  
+}
+// Sort of atoi for utf16
+// Very basic
+int ADM_SubAtoi(uint16_t *in)
+{
+	int result=0;
+	int d;
+	do
+	{
+		d=ADM_ASC(*in);		
+		in++;
+		if(d&gt;='0' &amp;&amp; d&lt;='9')
+		{
+			result*=10;
+			result+=d-'0';
+		}
+		else
+			return result;
+	}while(1);
+	
+
+}
+//	Init iconv, so that we can go utf16
+//
+uint8_t	ADM_utfInit( char *charset )
+{
+	myConv=iconv_open(&quot;UTF-16&quot;,charset); //&quot;WINDOWS-1251&quot;);
+	if((long int)myConv==-1)
+	{
+		printf(&quot;\n Error initializing iconv...\n&quot;);
+		return  0;
+	}
+	return 1;
+}
+//
+//	Convert the incoming string to utf16
+//	While doing it, remove the utf16 makers from input/output
+//	(fffe)
+//
+uint8_t ADM_utfConv(ADM_GLYPH_T *out, char *in,uint32_t nbIn, uint32_t *nbOut)
+{
+size_t sin,sout,sz;
+char *cout,*cin;
+uint32_t done=0;
+
+	memset(out,0,ADM_RAW*sizeof(ADM_GLYPH_T));
+	sin=strlen(in);
+	sout=ADM_RAW;
+	cin=in;
+	cout=(char *)(out);
+	
+	if((uint8_t)in[0]==0xff &amp;&amp; (uint8_t)in[1]==0xfe)
+	{
+		 cin+=2;
+		 sin-=2;
+	}
+	if(!sin) 
+	{
+		*nbOut=0;
+		return 1;
+	}
+#ifdef  ICONV_NEED_CONST 
+  	sz=iconv(myConv,(const char **)&amp;cin,&amp;sin,&amp;cout,&amp;sout);
+#else
+	sz=iconv(myConv,&amp;cin,&amp;sin,&amp;cout,&amp;sout);
+#endif	
+	if(sz==-1)
+	{
+  		printf(&quot;Iconv error:%s\n:%s:\n&quot;,strerror(errno),in);
+		//out[0]=' ';
+  	}
+	// Get the amound of utf16...
+	done=(ADM_RAW-sout)&gt;&gt;1;
+// For win32 we swap le and be
+#ifdef ADM_WIN32
+       ADM_GLYPH_T glyph;
+       for(uint32_t w=0;w&lt;done;w++)
+       {
+               glyph=out[w];
+               out[w]=((glyph&amp;0xff)&lt;&lt;8)+(glyph&gt;&gt;8);
+       }
+#endif
+	
+	if(done)
+	{
+		if(0xfeff==out[0])
+		{
+			//aprintf(&quot;Removing utf tag\n&quot;);
+			done--;
+			memmove(&amp;out[0],&amp;out[1],done*sizeof(ADM_GLYPH_T));
+			
+		}
+	}
+
+	while(done &amp;&amp;( ADM_ASC(out[done-1])==0x0a || ADM_ASC(out[done-1]==0x0d))) done--;
+	*nbOut=done;
+	return 1;
+	
+}
+// Close iconv
+//
+
+uint8_t ADM_utfEnd( void)
+{
+  // Purge iconv
+  if((long int)myConv!=-1)
+	{
+		iconv_close(myConv);
+		myConv=(iconv_t)-1;
+	}
+}
+
+
+#endif

Modified: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/CMakeLists.txt
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/CMakeLists.txt	2007-08-13 10:07:01 UTC (rev 3500)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/CMakeLists.txt	2007-08-13 13:47:25 UTC (rev 3501)
@@ -25,5 +25,12 @@
 ADM_vidAnimated.cpp
 ADM_vidDvbSub.cpp
 ADM_vidLogo.cpp
+ADM_vidHue.cpp
+ADM_vidSRT.cpp
+ADM_vidSRTload.cpp
+ADM_vidSRTRender.cpp
 )
 ADD_LIBRARY(ADM_videoFilter STATIC ${ADM_videoFilter_SRCS})
+if(FT_FOUND)
+add_definitions(${FT_CFLAGS})
+endif(FT_FOUND)

Modified: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/Makefile.am
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/Makefile.am	2007-08-13 10:07:01 UTC (rev 3500)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/Makefile.am	2007-08-13 13:47:25 UTC (rev 3501)
@@ -63,7 +63,11 @@
  ADM_vidYadif_asm.c \
  ADM_vidAnimated.cpp \
  ADM_vidDvbSub.cpp \
- ADM_vidLogo.cpp
+ ADM_vidLogo.cpp \
+ ADM_vidHue.cpp \
+ ADM_vidSRT.cpp \
+ ADM_vidSRTload.cpp \
+ ADM_vidSRTRender.cpp
 			
 
 


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000774.html">[Avidemux-svn-commit] r3500 -	branches/avidemux_2.4_branch/avidemux/ADM_encoder
</A></li>
	<LI>Next message: <A HREF="000776.html">[Avidemux-svn-commit] r3502 - in	branches/avidemux_2.4_branch/avidemux: ADM_video ADM_videoFilter
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#775">[ date ]</a>
              <a href="thread.html#775">[ thread ]</a>
              <a href="subject.html#775">[ subject ]</a>
              <a href="author.html#775">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">More information about the Avidemux-svn-commit
mailing list</a><br>
</body></html>
