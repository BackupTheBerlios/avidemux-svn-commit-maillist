<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Avidemux-svn-commit] r3539 - in	branches/avidemux_2.4_branch/avidemux: ADM_ocr	ADM_userInterfaces/ADM_GTK/ADM_dialog	ADM_userInterfaces/ADM_GTK/ADM_ocr	ADM_userInterfaces/ADM_NONE/ADM_dialog	ADM_userInterfaces/ADM_QT4/ADM_dialog	ADM_userInterfaces/ADM_QT4/ADM_ocr	ADM_userInterfaces/ADM_commonUI ADM_video ADM_videoFilter
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/avidemux-svn-commit/2007-August/index.html" >
   <LINK REL="made" HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r3539%20-%20in%0A%09branches/avidemux_2.4_branch/avidemux%3A%20ADM_ocr%0A%09ADM_userInterfaces/ADM_GTK/ADM_dialog%0A%09ADM_userInterfaces/ADM_GTK/ADM_ocr%0A%09ADM_userInterfaces/ADM_NONE/ADM_dialog%0A%09ADM_userInterfaces/ADM_QT4/ADM_dialog%0A%09ADM_userInterfaces/ADM_QT4/ADM_ocr%0A%09ADM_userInterfaces/ADM_commonUI%20ADM_video%20ADM_videoFilter&In-Reply-To=%3C200708191601.l7JG1eGd019486%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000812.html">
   <LINK REL="Next"  HREF="000814.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Avidemux-svn-commit] r3539 - in	branches/avidemux_2.4_branch/avidemux: ADM_ocr	ADM_userInterfaces/ADM_GTK/ADM_dialog	ADM_userInterfaces/ADM_GTK/ADM_ocr	ADM_userInterfaces/ADM_NONE/ADM_dialog	ADM_userInterfaces/ADM_QT4/ADM_dialog	ADM_userInterfaces/ADM_QT4/ADM_ocr	ADM_userInterfaces/ADM_commonUI ADM_video ADM_videoFilter</H1>
    <B>mean at BerliOS</B> 
    <A HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r3539%20-%20in%0A%09branches/avidemux_2.4_branch/avidemux%3A%20ADM_ocr%0A%09ADM_userInterfaces/ADM_GTK/ADM_dialog%0A%09ADM_userInterfaces/ADM_GTK/ADM_ocr%0A%09ADM_userInterfaces/ADM_NONE/ADM_dialog%0A%09ADM_userInterfaces/ADM_QT4/ADM_dialog%0A%09ADM_userInterfaces/ADM_QT4/ADM_ocr%0A%09ADM_userInterfaces/ADM_commonUI%20ADM_video%20ADM_videoFilter&In-Reply-To=%3C200708191601.l7JG1eGd019486%40sheep.berlios.de%3E"
       TITLE="[Avidemux-svn-commit] r3539 - in	branches/avidemux_2.4_branch/avidemux: ADM_ocr	ADM_userInterfaces/ADM_GTK/ADM_dialog	ADM_userInterfaces/ADM_GTK/ADM_ocr	ADM_userInterfaces/ADM_NONE/ADM_dialog	ADM_userInterfaces/ADM_QT4/ADM_dialog	ADM_userInterfaces/ADM_QT4/ADM_ocr	ADM_userInterfaces/ADM_commonUI ADM_video ADM_videoFilter">mean at mail.berlios.de
       </A><BR>
    <I>Sun Aug 19 18:01:40 CEST 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="000812.html">[Avidemux-svn-commit] r3538 -	branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog
</A></li>
        <LI>Next message: <A HREF="000814.html">[Avidemux-svn-commit] r3540 -	branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_gui
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#813">[ date ]</a>
              <a href="thread.html#813">[ thread ]</a>
              <a href="subject.html#813">[ subject ]</a>
              <a href="author.html#813">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: mean
Date: 2007-08-19 18:01:39 +0200 (Sun, 19 Aug 2007)
New Revision: 3539

Added:
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_mpdetc.h
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidVobSub.h
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidVobSubBitmap.h
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidVobSubRender.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidVobsub.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vobsubinfo.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vobsubinfo.h
Removed:
   branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_mpdetc.h
   branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidMPresize.c
   branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidVobSub.h
   branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidVobSubBitmap.h
   branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidVobSubRender.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidVobsub.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vobsubinfo.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vobsubinfo.h
   branches/avidemux_2.4_branch/avidemux/ADM_video/swscale_internal.h
Modified:
   branches/avidemux_2.4_branch/avidemux/ADM_ocr/ADM_ocr.h
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_vobsub.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_ocr/adm_ocr.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_NONE/ADM_dialog/DIA_none.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/DIA_none.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/Q_vobsub.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_ocr/Q_ocr.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_ocr.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_video/CMakeLists.txt
   branches/avidemux_2.4_branch/avidemux/ADM_video/Makefile.am
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidDvbSub.h
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/CMakeLists.txt
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/Makefile.am
Log:
[Filters] Move more filters to proper place (all the ones that have dialog for both qt and gtk)

Modified: branches/avidemux_2.4_branch/avidemux/ADM_ocr/ADM_ocr.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_ocr/ADM_ocr.h	2007-08-19 13:46:48 UTC (rev 3538)
+++ branches/avidemux_2.4_branch/avidemux/ADM_ocr/ADM_ocr.h	2007-08-19 16:01:39 UTC (rev 3539)
@@ -16,8 +16,8 @@
  ***************************************************************************/
 #ifndef ADM_OCR_H
 #define ADM_OCR_H
-#include &quot;ADM_video/ADM_vobsubinfo.h&quot;
-#include &quot;ADM_video/ADM_vidVobSub.h&quot;
+#include &quot;ADM_videoFilter/ADM_vobsubinfo.h&quot;
+#include &quot;ADM_videoFilter/ADM_vidVobSub.h&quot;
 #include &quot;ADM_ocr/adm_glyph.h&quot;
 typedef enum
 {

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_vobsub.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_vobsub.cpp	2007-08-19 13:46:48 UTC (rev 3538)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_vobsub.cpp	2007-08-19 16:01:39 UTC (rev 3539)
@@ -43,8 +43,8 @@
 
 
 
-#include &quot;ADM_video/ADM_vobsubinfo.h&quot;
-#include &quot;ADM_video/ADM_vidVobSub.h&quot;
+#include &quot;ADM_videoFilter/ADM_vobsubinfo.h&quot;
+#include &quot;ADM_videoFilter/ADM_vidVobSub.h&quot;
 
 #define MAX_INDECES ADM_MAX_LANGUAGE
 

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_ocr/adm_ocr.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_ocr/adm_ocr.cpp	2007-08-19 13:46:48 UTC (rev 3538)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_ocr/adm_ocr.cpp	2007-08-19 16:01:39 UTC (rev 3539)
@@ -62,9 +62,9 @@
 
 #include &quot;ADM_colorspace/colorspace.h&quot;
 
-#include &quot;ADM_video/ADM_vobsubinfo.h&quot;
+#include &quot;ADM_videoFilter/ADM_vobsubinfo.h&quot;
 
-#include &quot;ADM_video/ADM_vidVobSub.h&quot;
+#include &quot;ADM_videoFilter/ADM_vidVobSub.h&quot;
 #include &quot;ADM_leftturn.h&quot;
 #include &quot;DIA_enter.h&quot;
 

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_NONE/ADM_dialog/DIA_none.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_NONE/ADM_dialog/DIA_none.cpp	2007-08-19 13:46:48 UTC (rev 3538)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_NONE/ADM_dialog/DIA_none.cpp	2007-08-19 16:01:39 UTC (rev 3539)
@@ -44,8 +44,8 @@
 #include &quot;ADM_video/ADM_vidPartial_param.h&quot;
 #include &quot;ADM_video/ADM_vidEqualizer.h&quot;
 #include &quot;ADM_videoFilter/ADM_vidHue.h&quot;
-#include &quot;ADM_video/ADM_vobsubinfo.h&quot;
-#include &quot;ADM_video/ADM_vidVobSub.h&quot;
+#include &quot;ADM_videoFilter/ADM_vobsubinfo.h&quot;
+#include &quot;ADM_videoFilter/ADM_vidVobSub.h&quot;
 #include &quot;ADM_videoFilter/ADM_vidChromaShift_param.h&quot;
 #include &quot;ADM_video/ADM_vidMPdelogo.h&quot;
 #include &quot;ADM_videoFilter/ADM_vidEq2.h&quot;

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/DIA_none.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/DIA_none.cpp	2007-08-19 13:46:48 UTC (rev 3538)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/DIA_none.cpp	2007-08-19 16:01:39 UTC (rev 3539)
@@ -44,8 +44,8 @@
 #include &quot;ADM_video/ADM_vidPartial_param.h&quot;
 #include &quot;ADM_video/ADM_vidEqualizer.h&quot;
 #include &quot;ADM_videoFilter/ADM_vidHue.h&quot;
-#include &quot;ADM_video/ADM_vobsubinfo.h&quot;
-#include &quot;ADM_video/ADM_vidVobSub.h&quot;
+#include &quot;ADM_videoFilter/ADM_vobsubinfo.h&quot;
+#include &quot;ADM_videoFilter/ADM_vidVobSub.h&quot;
 #include &quot;ADM_videoFilter/ADM_vidChromaShift_param.h&quot;
 #include &quot;ADM_video/ADM_vidMPdelogo.h&quot;
 #include &quot;ADM_videoFilter/ADM_vidContrast.h&quot;

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/Q_vobsub.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/Q_vobsub.cpp	2007-08-19 13:46:48 UTC (rev 3538)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/Q_vobsub.cpp	2007-08-19 16:01:39 UTC (rev 3539)
@@ -30,8 +30,8 @@
 #include &quot;ADM_video/ADM_genvideo.hxx&quot;
 #include &quot;ADM_colorspace/ADM_rgb.h&quot;
 
-#include &quot;ADM_video/ADM_vobsubinfo.h&quot;
-#include &quot;ADM_video/ADM_vidVobSub.h&quot;
+#include &quot;ADM_videoFilter/ADM_vobsubinfo.h&quot;
+#include &quot;ADM_videoFilter/ADM_vidVobSub.h&quot;
 
 #include &quot;ADM_assert.h&quot;
 

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_ocr/Q_ocr.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_ocr/Q_ocr.cpp	2007-08-19 13:46:48 UTC (rev 3538)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_ocr/Q_ocr.cpp	2007-08-19 16:01:39 UTC (rev 3539)
@@ -30,8 +30,8 @@
 #include &quot;ADM_video/ADM_genvideo.hxx&quot;
 #include &quot;ADM_colorspace/ADM_rgb.h&quot;
 
-#include &quot;ADM_video/ADM_vobsubinfo.h&quot;
-#include &quot;ADM_video/ADM_vidVobSub.h&quot;
+#include &quot;ADM_videoFilter/ADM_vobsubinfo.h&quot;
+#include &quot;ADM_videoFilter/ADM_vidVobSub.h&quot;
 
 #include &quot;ADM_assert.h&quot;
 #include &quot;ADM_ocr/ADM_ocr.h&quot;

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_ocr.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_ocr.cpp	2007-08-19 13:46:48 UTC (rev 3538)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_ocr.cpp	2007-08-19 16:01:39 UTC (rev 3539)
@@ -37,8 +37,8 @@
 #include &quot;ADM_video/ADM_genvideo.hxx&quot;
 #include &quot;ADM_filter/video_filters.h&quot;
 
-#include &quot;ADM_video/ADM_vobsubinfo.h&quot;
-#include &quot;ADM_video/ADM_vidVobSub.h&quot;
+#include &quot;ADM_videoFilter/ADM_vobsubinfo.h&quot;
+#include &quot;ADM_videoFilter/ADM_vidVobSub.h&quot;
 #include &quot;ADM_ocr/ADM_ocr.h&quot;
 #include &quot;ADM_osSupport/ADM_misc.h&quot;
 #include &quot;ADM_toolkit/toolkit.hxx&quot;

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_mpdetc.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_mpdetc.h	2007-08-19 13:46:48 UTC (rev 3538)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_mpdetc.h	2007-08-19 16:01:39 UTC (rev 3539)
@@ -1,71 +0,0 @@
-//
-//
-// C++ Interface: ADM_mpdetc
-//
-// Description: 
-//		Port of Mplayer Detc filter (inverse telecine)
-//		Original author &amp; copyright : Richard Felker
-//
-// Author: mean &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>&gt;, (C) 2003
-//
-// Copyright: See COPYING file that comes with this distribution
-//
-//
-typedef struct metrics {
-	/* difference: total, even lines, odd lines */
-	int d, e, o;
-	/* noise: temporal, spacial (current), spacial (past) */
-	int t, s, p;
-};
-
-typedef struct frameinfo {
-	/* peak, relative, mean */
-	 metrics p, r, m;
-};
-
-struct vf_priv_s {
-	struct frameinfo fi[2];
-	uint8_t  *dmpi;
-	int first;
-	int drop, lastdrop, dropnext;
-	int inframes, outframes;
-};
-
-enum {
-	F_DROP,
-	F_MERGE,
-	F_NEXT,
-	F_SHOW
-};
-
-
-
-class  AVDMVideoMPDetc:public AVDMGenericVideoStream
- {
-
- protected:
-
-	struct vf_priv_s	*_param;
-	ADMImage		*_lastFrame;
-        virtual char 		*printConf(void) ;
-	
-	
-		uint8_t 	do_put_image(ADMImage *data);
-		uint32_t	_inFrame;
-		uint32_t	_lastAsked;
-		uint32_t 	_copy;
-	
-
- public:
-  				AVDMVideoMPDetc(  AVDMGenericVideoStream *in,CONFcouple *setup);
-  				~AVDMVideoMPDetc();
-	virtual uint8_t 	getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
-          									ADMImage *data,uint32_t *flags);
-
-			virtual uint8_t 	configure( AVDMGenericVideoStream *instream) 
-								{return 0;};
-
-
- }     ;
-
- 

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidMPresize.c
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidMPresize.c	2007-08-19 13:46:48 UTC (rev 3538)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidMPresize.c	2007-08-19 16:01:39 UTC (rev 3539)
@@ -1,221 +0,0 @@
-/***************************************************************************
-                          ADM_vidResize.cpp  -  description
-                             -------------------
-   Resize a picture in YUV12
-
-   w,h 		size of final picture
-   dw,dh  size of black bordered picture
-
-
-    begin                : Thu Mar 21 2002
-    copyright            : (C) 2002 by mean
-    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-#include &lt;stdio.h&gt;
-#include &lt;stdlib.h&gt;
-#include &lt;string.h&gt;
-#include &lt;assert.h&gt;
-
-#include &quot;config.h&quot;
-
-#include &quot;fourcc.h&quot;
-#include &quot;avio.hxx&quot;
-#include &quot;avi_vars.h&quot;
-
-
-#include &quot;ADM_toolkit/toolkit.hxx&quot;
-#include &quot;ADM_editor/ADM_edit.hxx&quot;
-#include &quot;ADM_video/ADM_genvideo.hxx&quot;
-#include &quot;ADM_video/ADM_vidCommonFilter.h&quot;
-#include &quot;ADM_video/swscale.h&quot;
-
-
-
-
-
-class  AVDMVideoStreamMPResize:public AVDMGenericVideoStream
- {
-
- protected:
-
-
- public:
-
-  				AVDMVideoStreamMPResize(  AVDMGenericVideoStream *in,CONFcouple *setup);
-				AVDMVideoStreamMPResize(	AVDMGenericVideoStream *in,uint32_t x,uint32_t y);
-  				virtual 		~AVDMVideoStreamMPResize();
-          virtual 		uint8_t getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
-          																	uint8_t *data,uint32_t *flags);
-				uint8_t configure( AVDMGenericVideoStream *instream);
-	virtual 		char 	*printConf(void) ;
-
-          virtual uint8_t	getCoupledConf( CONFcouple **couples);
-
-
- }     ;
-
-//BUILD_CREATE(partial_create,ADMVideoPartial);
-
-char *AVDMVideoStreamMPResize::printConf( void )
-{
- 	static char buf[50];
-
- 	sprintf((char *)buf,&quot; Resize %lu x %lu --&gt; %lu x %lu&quot;,
- 				_in-&gt;getInfo()-&gt;width,
- 				_in-&gt;getInfo()-&gt;height,
- 				_info.width,
- 				_info.height);
-        return buf;
-}
-//_______________________________________________________________
-AVDMVideoStreamMPResize::AVDMVideoStreamMPResize(
-									AVDMGenericVideoStream *in,CONFcouple *couples)
-{
-
-  	_in=in;
-   	memcpy(&amp;_info,_in-&gt;getInfo(),sizeof(_info));
-	//_uncompressed=(uint8_t *)malloc(3*_info.width*_info.height);
-	_uncompressed=new uint8_t[3*_info.width*_info.height];
-
-		if(couples)
-		{
-			 _param=NEW(RESIZE_PARAMS);
-			GET(w);
-			GET(h);
-			GET(algo);
-			_info.width=_param-&gt;w;
-			_info.height=_param-&gt;h;
-
-		}
-			else
-			{
-				_param=NEW( RESIZE_PARAMS);
-				_param-&gt;w=_info.width;
-				_param-&gt;h = _info.height;
-			    _param-&gt;algo = 0;
-			}
-			//_intermediate_buffer=(uint8_t *)malloc(3*_info.width*_in-&gt;getInfo()-&gt;height);
-			_intermediate_buffer=new uint8_t [3*_info.width*_in-&gt;getInfo()-&gt;height];
-
-  _info.encoding=1;
-  _init=0;
-	Vpattern_luma=NULL;
-    Vpattern_chroma=NULL;
-	Hpattern_luma=NULL;
-    Hpattern_chroma=NULL;
-}
-/*AVDMGenericVideoStream *createResizeFromParam(AVDMGenericVideoStream *in,uint32_t x,uint32_t y)
-{
-
-	return new AVDMVideoStreamResize(in,x,y);
-}*/
-AVDMVideoStreamMPResize::AVDMVideoStreamMPResize(
-									AVDMGenericVideoStream *in,uint32_t x,uint32_t y)
-{
-
-  	_in=in;
-   	memcpy(&amp;_info,_in-&gt;getInfo(),sizeof(_info));
-	//_uncompressed=(uint8_t *)malloc(3*_info.width*_info.height);
-	_uncompressed=new uint8_t[3*_info.width*_info.height];
-	_param=NEW( RESIZE_PARAMS);
-	_param-&gt;w=x;
-	_param-&gt;h = y;
-	_info.width=_param-&gt;w;
-	_info.height=_param-&gt;h;
-	_param-&gt;algo = 0;
-			//_intermediate_buffer=(uint8_t *)malloc(3*_info.width*_in-&gt;getInfo()-&gt;height);
-			_intermediate_buffer=new uint8_t [3*_info.width*_in-&gt;getInfo()-&gt;height];
-
-  _info.encoding=1;
-  _init=0;
-	Vpattern_luma=NULL;
-    Vpattern_chroma=NULL;
-	Hpattern_luma=NULL;
-    Hpattern_chroma=NULL;
-}
-
-uint8_t	AVDMVideoStreamMPResize::getCoupledConf( CONFcouple **couples)
-{
-
-			ADM_assert(_param);
-			*couples=new CONFcouple(3);
-
-#define CSET(x)  (*couples)-&gt;setCouple((char *)#x,(_param-&gt;x))
-	CSET(w);
-	CSET(h);
-	CSET(algo);
-			return 1;
-
-}
-// ___ destructor_____________
-AVDMVideoStreamMPResize::~AVDMVideoStreamMPResize()
-{
- 	delete [] _uncompressed;
-	delete [] _intermediate_buffer;
-	DELETE(_param);
-	_uncompressed=_intermediate_buffer=NULL;
- 	endcompute();
-}
-
-//
-//	Basically ask a uncompressed frame from editor and ask
-//		GUI to decompress it .
-//
-
-uint8_t AVDMVideoStreamMPResize::getFrameNumberNoAlloc(uint32_t frame,
-																		uint32_t *len,
-   																	uint8_t *data,
-   																	uint32_t *flags)
-{
-static Image in,out;
-			if(frame&gt;= _info.nb_frames) return 0;
-			ADM_assert(_param);	
-	
-   			
-
-			// bypass filter
-			//return _in-&gt;getFrameNumberNoAlloc(frame, len,data,flags)	;
-			
-								
-			// read uncompressed frame
-       		if(!_in-&gt;getFrameNumberNoAlloc(frame, len,_uncompressed,flags)) return 0;
-       		
-       		// do the resize in 3 passes, Y, U then V
-       		in.width=_in-&gt;getInfo()-&gt;width;
-       		in.height=_in-&gt;getInfo()-&gt;height;
-       		in.data=_uncompressed;
-
-       		out.width=_info.width;
-       		out.height=_info.height;
-       		out.data=data;
-       		
-              if(!_init)
-              {
-               	_init=1;
-               	printf(&quot;\n Precomputing with algo :%lu\n&quot;,_param-&gt;algo);
-                	if(_param-&gt;algo&gt;2)
-                 		{
-                      	printf(&quot;\n Wrong algorithm selection&quot;);
-                        ADM_assert(0);
-                     }
-               	 precompute(&amp;out,&amp;in, _param-&gt;algo );
-              }
-       		zoom(&amp;out,&amp;in)         ;
-       				       			
-       		
-       		  *flags=0;
-       		  *len= _info.width*_info.height+(_info.width*_info.height&gt;&gt;1);       				
-      return 1;
-}
-
-

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidVobSub.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidVobSub.h	2007-08-19 13:46:48 UTC (rev 3538)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidVobSub.h	2007-08-19 16:01:39 UTC (rev 3539)
@@ -1,81 +0,0 @@
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-#ifndef _VOBSUB_V_
-#define _VOBSUB_V_
-#include &quot;ADM_inputs/ADM_mpegdemuxer/dmx_demuxerPS.h&quot;
-#define VS_MAXPACKET 128*1024
-
-#define NOSUB 0xffffffff
-
-#define MAX_DISPLAY_TIME 3000 // 3s
-
-//************************************
-typedef struct vobSubParam
-{
-        char            *subname;
-        uint32_t        index;
-        int32_t         subShift;
-}vobSubParam;
-//************************************
-#include &quot;ADM_video/ADM_vidVobSubBitmap.h&quot;
-//************************************
-class  ADMVideoVobSub:public AVDMGenericVideoStream
- {
-
- protected:
-        virtual char                    *printConf(void);
-        uint8_t                         guessPalette(void);
-        uint8_t                         readbyte(void);         /// Read a byte from buffer
-        uint16_t                        readword(void);         /// Read a 16 bits word from buffer
-        uint8_t                         forward(uint32_t v);    /// Read a 16 bits word from buffer
-        uint8_t                         decodeRLE(uint32_t off,uint32_t start,uint32_t end);
-        uint8_t                         setup(void);            /// Rebuild internal info
-        uint8_t                         cleanup(void);          /// Destroy all internal info
-        uint8_t                         paletteYUV( void );     /// Convert RGB Pallette to yuv
-        uint8_t                         Palettte2Display( void ); /// Convert the RLE to YUV bitmap
-        uint8_t                         handleSub( uint32_t idx );/// Decode a sub packet
-        uint32_t                        lookupSub(uint64_t time);/// Return sub index corresponding to time
-        
-        dmx_demuxerPS                   *_parser;        
-        uint8_t                         *_data;                 /// Data for packet
-        VobSubInfo                      *_vobSubInfo;           /// Info of the index file
-        vobSubParam                     *_param;
-        vobSubBitmap                    *_original;              /// True size (..) depacked vobsub
-        vobSubBitmap                    *_resampled;            /// Final one; to be blended in picture
-        vobSubBitmap                    *_chromaResampled;      /// Same as above but shinked by 2
-        uint32_t                        _x1,_y1,_x2,_y2;        /// sub boxing
-        uint32_t                        _subW,_subH;
-        uint8_t                         _displaying;            ///  Is display active
-        uint32_t                        _curOffset;
-        uint32_t                        _subSize;
-        uint32_t                        _dataSize;              /// Size of the data chunk
-        
-        uint8_t                         _colors[4];             /// Colors palette
-        uint8_t                         _alpha[4];              /// Colors alpha
-        int16_t                         _YUVPalette[16];        /// Luma only
-        uint32_t                        _currentSub;            ///
-        uint32_t                        _initialPts;
- public:
-    /* This 3 functions are used by OCR */
-                        ADMVideoVobSub(  char *fileidx,uint32_t idx);
-              vobSubBitmap *getBitmap(uint32_t nb,uint32_t *start, uint32_t *end,uint32_t *first,uint32_t *last);
-              uint32_t     getNbImage( void);
-    /* /ocr */ 
-    
-                        ADMVideoVobSub(  AVDMGenericVideoStream *in,CONFcouple *setup);
-                        ~ADMVideoVobSub();
-        virtual uint8_t getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
-                                                ADMImage *data,uint32_t *flags);
-        virtual uint8_t getCoupledConf( CONFcouple **couples)           ;
-        virtual uint8_t configure( AVDMGenericVideoStream *instream);
-                                                        
-};
-#endif

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidVobSubBitmap.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidVobSubBitmap.h	2007-08-19 13:46:48 UTC (rev 3538)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidVobSubBitmap.h	2007-08-19 16:01:39 UTC (rev 3539)
@@ -1,40 +0,0 @@
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-#ifndef _VOBSUB_BITMAP_H
-#define _VOBSUB_BITMAP_H
-//************************************
-class vobSubBitmap
-{
-  protected:
-        uint8_t                         *_dirty;                   /// Dirty lines (non transparent)
-  public:
-        uint8_t                         isDirty(uint32_t line);
-        uint8_t                         setDirty(uint32_t line);
-
-        uint32_t                        _width,_height;
-        uint32_t                        placeTop, placeHeight;     /// Position of the sub
-      
-        uint8_t                         *_bitmap;                  /// YUV image
-        uint8_t                         *_alphaMask;               /// alpha mask 
-        
- 
-                                        vobSubBitmap(uint32_t w, uint32_t h); 
-                                        ~vobSubBitmap();
-        void                            clear(void);
-        
-                                        /// Convert palette bitmap to yuv&amp;mask bitmap
-        uint8_t                         buildYUV( int16_t *palette ); 
-                                        /// Generate the final bitmap (resized)
-        uint8_t                         subResize(vobSubBitmap **tgt,uint32_t newx,uint32_t newy,
-                                                uint32_t oldtop, uint32_t oldheight);
-};
-
-#endif

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidVobSubRender.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidVobSubRender.cpp	2007-08-19 13:46:48 UTC (rev 3538)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidVobSubRender.cpp	2007-08-19 16:01:39 UTC (rev 3539)
@@ -1,677 +0,0 @@
-//
-// C++ Implementation: %{MODULE}
-//
-// Description:
-//
-//
-// Author: %{AUTHOR} &lt;%{EMAIL}&gt;, (C) %{YEAR}
-//
-// Copyright: See COPYING file that comes with this distribution
-//
-//
-//
-// C++ Implementation:Spudecoder (subs for DVd like stream)
-//
-// Description:
-//
-//
-// Author: Mean, <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
-//
-// Copyright: See COPYING file that comes with this distribution
-//
-// see <A HREF="http://sam.zoy.org/writings/dvd/subtitles/">http://sam.zoy.org/writings/dvd/subtitles/</A>
-
-/*
-        This part of the vobsub stuff 
-                - decodes the command spu block
-                - rle decode the bitmap itself
-                
-        
-       palettized is the palette based decoded sub
-       
-       Elsewhere
-       
-       bitmap &amp; alphamask are the bitmap &amp; alpha channel stuff
-       subW &amp; subH are width and height of them
-       
-       The RLE decoder is derivated from mplayer one
-*/
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-#include &lt;stdio.h&gt;
-#include &lt;stdlib.h&gt;
-#include &lt;string.h&gt;
-#include &lt;ADM_assert.h&gt;
-
-#include &quot;config.h&quot;
-#include &quot;fourcc.h&quot;
-#include &quot;avio.hxx&quot;
-#include &quot;config.h&quot;
-#include &quot;avi_vars.h&quot;
-
-
-
-#include &quot;ADM_toolkit/toolkit.hxx&quot;
-#include &quot;ADM_editor/ADM_edit.hxx&quot;
-#include &quot;ADM_video/ADM_genvideo.hxx&quot;
-#include &quot;ADM_filter/video_filters.h&quot;
-
-
-#include &quot;ADM_toolkit/filesel.h&quot;
-
-#include &quot;ADM_colorspace/colorspace.h&quot;
-
-#include &quot;ADM_vobsubinfo.h&quot;
-
-#include &quot;ADM_vidVobSub.h&quot;
-
-#if (defined( ARCH_X86)  || defined(ARCH_X86_64))
-extern &quot;C&quot; {
-#include &quot;ADM_lavcodec/avcodec.h&quot;
-}
-#endif
-
-#include &quot;../ADM_lavutil/avutil.h&quot;
-#include &quot;ADM_libswscale/swscale.h&quot;
-#include &quot;ADM_osSupport/ADM_cpuCap.h&quot;
-
-#include &quot;ADM_osSupport/ADM_debugID.h&quot;
-#define MODULE_NAME MODULE_FILTER
-#include &quot;ADM_osSupport/ADM_debug.h&quot;
-
-//*************************************************************
-uint8_t ADMVideoVobSub::forward(uint32_t v)
-{
-        aprintf(&quot;Current : %lu forwarding : %lu\n&quot;,_curOffset,v);
-         if(_curOffset+v&gt;=_subSize) return 0;
-         _curOffset+=v;
-         return 1;
-
-}
-//*************************************************************
-uint8_t ADMVideoVobSub::readbyte( void )
-{
-        ADM_assert(_curOffset&lt;_subSize);
-        return _data[_curOffset++];
-
-}
-//*************************************************************
-uint16_t ADMVideoVobSub::readword( void )
-{
-uint16_t w;
-        ADM_assert(_curOffset&lt;_subSize-1);
-        w= _data[_curOffset]&lt;&lt;8;
-        w+= _data[_curOffset+1];
-        _curOffset+=2;
-        return w;
-}
-//***********************************************************
-//      Convert RGB Palette to YUV Palette
-//      ALL 16 of them
-//
-uint8_t ADMVideoVobSub::paletteYUV( void )
-{
-uint8_t r,g,b,a;
-uint8_t y;
-int8_t u,v;
-uint32_t value;
-        for(int i=0;i&lt;16;i++)
-        {
-               value=_vobSubInfo-&gt;Palette[i];
-               r=(value&gt;&gt;16)&amp;0xff;
-               g=(value&gt;&gt;8)&amp;0xff; 
-               b=(value)&amp;0xff;
-               
-               COL_RgbToYuv(b,  g,  r, &amp;y, &amp;u,&amp;v);
-               
-                _YUVPalette[i]=y;
-                //_YUVPalette[i][1]=u;
-                //_YUVPalette[i][2]=v;
-        
-        }
-        return 1;
-
-}
-
-
-//***********************************************************
-// RLE code inspired from mplayer
-uint8_t ADMVideoVobSub::decodeRLE(uint32_t off,uint32_t start,uint32_t end)
-{
-
-        if(!_original) return 0;
-
-        uint32_t oldoffset=_curOffset;
-        uint32_t stride=_subW;
-        uint32_t x,y;
-        uint8_t *ptr=_original-&gt;_bitmap;
-        uint8_t *alpha=_original-&gt;_alphaMask;
-        uint32_t a,b;
-        int     nibbleparity=0;
-        int     nibble=0;
-        
-        int run,color;
-        
-#define SKIPNIBBLE        {nibbleparity=0;}
-#define NEXTNIBBLE(x) if(nibbleparity){ x=nibble&amp;0xf;nibbleparity=0;}else {nibble=readbyte();nibbleparity=1;x=nibble&gt;&gt;4;}
-       
-        _curOffset=off;
-        aprintf(&quot;Vobsub: Rle at offset :%d datasize:%d (stride:%d)\n&quot;,off,_dataSize,stride);
-        if(!ptr)
-        {
-                printf(&quot;Vobsub:No infos yet RLE data...\n&quot;);
-                 return 1;
-        }
-        x=0;
-        y=0;
-        while(
-               (_curOffset&lt;_dataSize)
-            &amp;&amp; (y&lt;(_subH&gt;&gt;1)) 
-            &amp;&amp; ((!end) || (_curOffset&lt;end))
-        )
-        {
-               NEXTNIBBLE(a);
-               if(a&lt;4)
-               {
-                 a&lt;&lt;=4;
-                 NEXTNIBBLE(b);
-                 a|=b;
-                 if(a&lt;0x10)
-                 {
-                        a&lt;&lt;=4;
-                        NEXTNIBBLE(b);
-                        a|=b;
-                        if(a&lt;0x40)
-                        {
-                                a&lt;&lt;=4;
-                                NEXTNIBBLE(b);
-                                a|=b;
-                                if(a&lt;0x100)
-                                {
-                                        a|=(stride-x)&lt;&lt;2;
-                                }
-                        }
-                 }
-              }
-              run=a&gt;&gt;2;
-              color=3-(a&amp;0x3);
-             // aprintf(&quot;Vobsub: Run:%d color:%d\n&quot;,run,color);
-              if((run&gt;stride-x) || !run)
-                run=stride-x;
-              
-              //memset(ptr,color,run);
-              memset(ptr,_colors[color],run);
-              memset(alpha,_alpha[color],run);
-              if(run!=stride) _original-&gt;setDirty(y*2+start);
-              x+=run;
-              ptr+=run;
-              alpha+=run;
-              //  aprintf(&quot;x:%d y:%d\n&quot;,x,y);
-              if(x&gt;=stride)
-              {
-                        
-                     y++;
-                     x=0;
-                     ptr=_original-&gt;_bitmap+(y*2+start)*stride;
-                     alpha=_original-&gt;_alphaMask+(y*2+start)*stride;
-                     SKIPNIBBLE;
-              }
-        }
-        aprintf(&quot;vobsub End :%d y:%d\n&quot;,_curOffset,y); 
-        _curOffset=oldoffset;
-} 
-//***********************************************        
-// Decode Sub automaton command
-//***********************************************
-uint8_t  ADMVideoVobSub::handleSub( uint32_t idx )
-{       
-uint16_t date,next,dum;
-uint8_t  command;
-        _subSize=0;
-uint32_t pts;
-uint64_t posA,posR;
- uint32_t odd,even;
-int doneA=0;
-int doneB=0;
-        _parser-&gt;getPos(&amp;posA,&amp;posR);
-        // Read data
-aprintf(&quot;**Cur:A:%llx R:%llx next:%llx\n&quot;,posA,posR,_vobSubInfo-&gt;lines[idx+1].fileOffset);        
-while(posA&lt;_vobSubInfo-&gt;lines[idx+1].fileOffset)
-{        
-        odd=even=0;
-        aprintf(&quot;**Cur: A:%llx R:%llx next:%llx\n&quot;,posA,posR,_vobSubInfo-&gt;lines[idx+1].fileOffset);
-        
-        _subSize=_parser-&gt;read16i();
-        if(!_subSize)
-        {
-            printf(&quot;Vobsub: error reading\n&quot;);
-            return 0;
-        }
-        
-        aprintf(&quot;Vobsub: data len =%d\n&quot;,_subSize);
-        
-        if(_subSize&gt;VS_MAXPACKET-1)
-         {
-            printf(&quot;Vobsub: error reading (packet too big)\n&quot;);
-            return 0;
-        }
-        if(!_parser-&gt;read(_data+2,_subSize-2)) 
-        {
-                printf(&quot;VS: read failed\n&quot;);
-                return 0;
-        }
-       
-        // We got the full packet
-        // now scan it
-        _curOffset=2;
-        if(_subSize&lt;4)
-        {
-          printf(&quot;[handleSub] Packet too short!\n&quot;);
-          return 1; 
-        }
-        _dataSize=readword();
-        aprintf(&quot;data block=%lu\n&quot;,_dataSize);
-        if(_dataSize&lt;=4)
-        {
-            printf(&quot;Vobsub: data block too small\n&quot;);
-            return 0;       
-        }
-        
-        if(!forward(_dataSize-4)) return 0;    // go to the command block
-        
-        
-        while(2)
-        {
-                if(_curOffset&gt;_subSize-5) break;
-                date=readword();
-                next=readword();
-                if(next==_curOffset-4) break;            // end of command
-                
-                while(_curOffset&lt;next)
-                {
-                      
-                      
-                        command=readbyte();
-                        aprintf(&quot;vobsub:Command : %d date:%d next:%d cur:%lu\n&quot;,command,date,next,_curOffset);
-                        int left=next-_curOffset;
-                        switch(command)
-                        {
-                                case 00: _displaying=1;
-                                        break;
-                                case 01: // start date
-                                        break;
-                                case 02: // stop date
-#if 0                                
-                                        pts=_parser-&gt;getPTS();
-                                        if(!_vobSubInfo-&gt;lines[idx].stopTime)
-                                        {
-                                                double comp;
-                                           
-                                                comp=pts-_initialPts;
-                                                comp=comp/90;     // 90khz
-                                                comp+=date*10;    // 1/100th of a second
-                                                 _vobSubInfo-&gt;lines[idx].stopTime=(uint32_t)comp;
-                                                aprintf(&quot;****Sub: idx : %lu starts at :%lu end at :%lu\n&quot;,
-                                                        idx,
-                                                        _vobSubInfo-&gt;lines[idx].startTime, 
-                                                        _vobSubInfo-&gt;lines[idx].stopTime);
-                                        
-                                        }
-#endif                                        
-                                        break;
-                                case 03: // Pallette 4 nibble= 16 bits
-                                         if(left&lt;2)
-                                         {
-                                            printf(&quot;Command 3: Palette: Not enough bytes left\n&quot;);
-                                            return 1; 
-                                         }
-                                         dum=readword();
-                                        _colors[0]=dum&gt;&gt;12;
-                                        _colors[1]=0xf &amp; (dum&gt;&gt;8);
-                                        _colors[2]=0xf &amp; (dum&gt;&gt;4);
-                                        _colors[3]=0xf &amp; (dum);
-                                        break;          
-                                case 0xff:
-                                        break;
-                                case 04: // alpha channel
-                                         //4 nibble= 16 bits
-                                        if(left&lt;2)
-                                         {
-                                            printf(&quot;Command 4: Alpha: Not enough bytes left\n&quot;);
-                                            return 1; 
-                                         }
-
-                                        dum=readword();
-                                        _alpha[0]=dum&gt;&gt;12;
-                                        _alpha[1]=0xf &amp; (dum&gt;&gt;8);
-                                        _alpha[2]=0xf &amp; (dum&gt;&gt;4);
-                                        _alpha[3]=0xf &amp; (dum);
-                                        break;
-                                case 05:
-                                        // Coordinates 12 bits per entry X1/X2/Y1/Y2
-                                        // 48 bits total / 6 bytes
-                                        {
-                                                uint16_t a,b,c;
-                                                uint32_t nx1,nx2,ny1,ny2;
-                                                if(left&lt;6)
-                                                {
-                                                    printf(&quot;Command 5: Coord: Not enough bytes left\n&quot;);
-                                                    return 1; 
-                                                }
-                                                if(doneA) return 1;
-                                                doneA++;
-                                                a=readword();
-                                                b=readword();
-                                                c=readword();
-                                                nx1=a&gt;&gt;4;
-                                                nx2=((a&amp;0xf)&lt;&lt;8)+(b&gt;&gt;8);
-                                                ny1=((b&amp;0xf)&lt;&lt;4)+(c&gt;&gt;12);
-                                                ny2=c&amp;0xfff;
-                                                
-                                                aprintf(&quot;vobsuv: x1:%d x2:%d y1:%d y2:%d\n&quot;,nx1,nx2,ny1,ny2);
-                                                
-                                                if(nx1==_x1 &amp;&amp; nx2==_x2 &amp;&amp; ny1==_y1 &amp;&amp; ny2==_y2 &amp;&amp; _original)
-                                                {       // Reuse old bitmap
-                                                        _original-&gt;clear();
-                                                }
-                                                else
-                                                {
-                                                  if(_original)
-                                                        delete _original;
-                                                  _original=NULL;
-                                                  _x1=nx1;
-                                                  _x2=nx2;
-                                                  _y1=ny1;
-                                                  _y2=ny2;
-                                                  _subW=_x2-_x1+1;
-                                                  _subH=_y2-_y1+1;                                                
-                                                  _original=new vobSubBitmap(_subW,_subH);
-                                                }
-                                                                        
-                                        }
-                                        break;
-                                case 06: // RLE offset 
-                                        // 2*16 bits : odd offset, even offset
-                                        {
-                                                if(doneB) return 1;
-                                                doneB++;
-                                                if(left&lt;4)
-                                                {
-                                                    printf(&quot;Command 6: RLE: Not enough bytes left\n&quot;);
-                                                    return 1; 
-                                                }
-                                        odd=readword();                                        
-                                        even=readword();
- 
-                                        }
-                                        break;   
-                                default:                                                     
-                                        printf(&quot;Unknown command:%d\n&quot;,command);
-                                        return 0;
-                                  
-                        } //End switch command     
-                }// end while
-        }
-        _parser-&gt;getPos(&amp;posA,&amp;posR);
-        /*****/
-        if(_original &amp;&amp; odd &amp;&amp; even) 
-        {
-                _original-&gt;clear();
-                decodeRLE(odd,0,even);
-                decodeRLE(even,1,0);
-                if(!_vobSubInfo-&gt;hasPalette)
-                {
-                        // guess palette   
-                        guessPalette();
-                }
-        }
-        /*****/
-  }   // Next picture  
-  return 1;
-}
-/*
-    Try to guess the palette...
-*/
-uint8_t ADMVideoVobSub::guessPalette(void)
-{
- int  stat[4];
- uint32_t sum,sumalpha,y,x;
- uint8_t *in,*inmax,*inalpha;
- int background,foreground,candidate1,candidate2;
- 
-    memset(stat,0,4*sizeof(int));
-   
-    in=_original-&gt;_bitmap ;
-    y=_original-&gt;_width*_original-&gt;_height;
-    inmax=in+y;
-    for(x=0;x&lt;y;x++)
-    {
-        stat[(*in)&amp;0x03]++;
-        in++; 
-           
-    }  
-    // normally just between 0 &amp; 3
-    sum=stat[0]+stat[1]+stat[2]+stat[3];
-   
-    #define PERC(x) stat[x]*=10000;stat[x]/=sum;//alpha[x]*=1000;alpha[x]/=sumalpha;
-    PERC(0);
-    PERC(1);
-    PERC(2);
-    PERC(3);
-    int nbColor=0;
-    for(int i=0;i&lt;4;i++) 
-    {
-        printf(&quot;Color : %d percent :%d \n&quot;,i,stat[i]);
-    }
-#define NB_COLOR nbColor=0;for(int i=0;i&lt;4;i++) if(stat[i]) nbColor++;
-#define SEARCH_MAX(OUT) max=0;for(int o=0;o&lt;4;o++) if(stat[o]&gt;max) {max=stat[o];OUT=o;}stat[OUT]=0;
-#define SET_COLOR(x,color) for(int k=0;k&lt;4;k++) _YUVPalette[x+4*k]=color;
-    // Search Max
-    int max=0;
-    memset(_YUVPalette,0,sizeof(_YUVPalette));
-    
-    // The most common color is background
-    SEARCH_MAX(background);
-    SET_COLOR(background,0);
-    printf(&quot;Background is %d\n&quot;,background);
- 
-    // Search for A/B /C
-    in=_original-&gt;_bitmap ;
-    while(in&lt;inmax)
-    {
-        if(*in!=background) break;
-        in++;   
-    };
-    candidate1=*in; 
-    while(in&lt;inmax)
-    {
-        if(*in!=candidate1) break;
-        in++;   
-    };
-    // if we have background / candidate / candidate2
-    //  we consider candidate to be blending and candidate2 to be solid
-    candidate2=*in;
-    if(candidate2!=background)
-    {
-        SET_COLOR(candidate1,0x40);
-        SET_COLOR(candidate2,0xFF); 
-    }else 
-    // We have background / candidate / background
-    // candidate is then considered solid color
-    {
-        SET_COLOR(candidate2,0xff);
-    }
-    return 1;
-    
-}
-
-vobSubBitmap::vobSubBitmap(uint32_t w, uint32_t h)
-{
-  uint32_t page;
-  
-  _width=w;
-  _height=h;
-  
-  page=w*h;
-   
-
-  _bitmap=new uint8_t [page];
-  _alphaMask=new uint8_t [page];
-  _dirty=new uint8_t[h];                                                
-  clear();
-}
-uint8_t vobSubBitmap::isDirty(uint32_t line)
-{
-        ADM_assert(line&lt;_height);
-        if(_dirty[line]) return 1;
-        return 0;
-
-}
-uint8_t vobSubBitmap::setDirty(uint32_t line)
-{
-        ADM_assert(line&lt;_height);
-        _dirty[line]=1;
-        return 1;
-}
-vobSubBitmap::~vobSubBitmap()
-{
-#define CLN(x) if(x) delete [] x;
-
-  CLN(_bitmap);
-  CLN(_alphaMask);  
-  CLN(_dirty);
-}
-void vobSubBitmap::clear(void)
-{
-#define CLR(x) memset(x,0,_width*_height);
-
-  CLR(_bitmap);
-  CLR(_alphaMask);
-  memset(_dirty,0,_height);
-}
-
-//***********************************************************
-// Convert the palette bitmap into yuv + alphamask bitmap
-//
-//***********************************************************
-uint8_t vobSubBitmap::buildYUV( int16_t *palette )
-{
-  
-  uint8_t *ptr;
-
-  ptr=_bitmap;      
-        
-  for(uint32_t y=0;y&lt;_width*_height;y++)
-  {
-    *ptr=palette[*ptr];
-    ptr++;  
-  }
-  return 1;
-}
-//***********************************************************
-//
-//      Resample the square beginning at position = oldtop with a height of oldheigh
-//        to a square of size new, newy
-//
-//***********************************************************
-uint8_t vobSubBitmap::subResize(vobSubBitmap **tgt,uint32_t newx,uint32_t newy,uint32_t oldtop, uint32_t oldheight)
-{
-  int flags=0;
-  SwsContext *ctx=NULL;
-  int er=0;
-  
-  aprintf(&quot;Sub Resize : top %lu height %lu -&gt; %lu %lu\n&quot;,oldtop, oldheight,newx, newy);
-  
-#if 0  
-//#ifdef USE_MMX
-                
-#define ADD(x,y) if( CpuCaps::has##x()) flags|=SWS_CPU_CAPS_##y;
-                ADD(MMX,MMX);           
-                ADD(3DNOW,3DNOW);
-                ADD(MMXEXT,MMX2);
-#endif  
-  flags+=SWS_BILINEAR;
-  // Need a new one ?
-  // Or reuse the old one ?
-  if(*tgt &amp;&amp; (*tgt)-&gt;_width==newx &amp;&amp; (*tgt)-&gt;_height==newy)
-  {
-    (*tgt)-&gt;clear(); // useless FIXME
-  }
-  else
-  {
-    if(*tgt) delete *tgt;
-    *tgt=NULL;
-    *tgt=new  vobSubBitmap(newx,newy);    
-  }
-  
-  // Need to resize ?
-  if(oldheight==newy &amp;&amp; _width==newx)
-  {
-    uint8_t *src,*dst;
-    aprintf(&quot;No need to resize\n&quot;);
-    src=_bitmap+oldtop*_width;
-    dst=(*tgt)-&gt;_bitmap;
-    memcpy(dst,src,newx*newy); 
-    
-    src=_alphaMask+oldtop*_width;
-    dst=(*tgt)-&gt;_alphaMask;
-    memcpy(dst,src,newx*newy); 
-    
-    return 1;    
-  }
-  
-  ctx=sws_getContext(
-  _width,oldheight,
-  PIX_FMT_GRAY8,
-  newx,newy,
-  PIX_FMT_GRAY8,
-  flags,
-  NULL, NULL,NULL);
-
-  ADM_assert(ctx);
-    
-  //************************
-  uint8_t *src[3];
-  uint8_t *dst[3];
-  int ssrc[3];
-  int ddst[3];
-  
-
-  //resize bitmap
-  
-  src[0]=_bitmap+oldtop*_width;
-  src[1]=NULL;
-  src[2]=NULL;
-
-  ssrc[0]=_width;
-  ssrc[1]=ssrc[2]=0;
-
-  
-  dst[0]=(*tgt)-&gt;_bitmap;
-  dst[1]=NULL;
-  dst[2]=NULL;
-  
-  ddst[0]=newx;
-  ddst[1]=ddst[2]=0;
-
-  er=sws_scale(ctx,src,ssrc,0,oldheight,dst,ddst);
-  aprintf(&quot;Er:%d\n&quot;,er);
-  
-  // And alpha
-  src[0]=_alphaMask+oldtop*_width;  
-  dst[0]=(*tgt)-&gt;_alphaMask;
-  er=sws_scale(ctx,src,ssrc,0,_height,dst,ddst);
-  aprintf(&quot;Er:%d\n&quot;,er);
-  // end
-  sws_freeContext(ctx); 
-  return 1;             
-}
-
-//EOF

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidVobsub.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidVobsub.cpp	2007-08-19 13:46:48 UTC (rev 3538)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidVobsub.cpp	2007-08-19 16:01:39 UTC (rev 3539)
@@ -1,672 +0,0 @@
-//
-// C++ Implementation:Spudecoder (subs for DVd like stream)
-//
-// Description:
-//
-//
-// Author: Mean, <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
-//
-// Copyright: See COPYING file that comes with this distribution
-//
-// see <A HREF="http://sam.zoy.org/writings/dvd/subtitles/">http://sam.zoy.org/writings/dvd/subtitles/</A>
-
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-#include &lt;stdio.h&gt;
-#include &lt;stdlib.h&gt;
-#include &lt;string.h&gt;
-#include &lt;math.h&gt;
-#include &lt;ADM_assert.h&gt;
-
-#include &quot;config.h&quot;
-#include &quot;fourcc.h&quot;
-#include &quot;avio.hxx&quot;
-#include &quot;config.h&quot;
-#include &quot;avi_vars.h&quot;
-
-
-
-#include &quot;ADM_toolkit/toolkit.hxx&quot;
-#include &quot;ADM_editor/ADM_edit.hxx&quot;
-#include &quot;ADM_video/ADM_genvideo.hxx&quot;
-#include &quot;ADM_filter/video_filters.h&quot;
-
-
-#include &quot;ADM_toolkit/filesel.h&quot;
-
-#include &quot;ADM_colorspace/colorspace.h&quot;
-
-#include &quot;ADM_vobsubinfo.h&quot;
-
-#define VOBSUB &quot;/capture/sub/phone.sub&quot;
-
-#include &quot;ADM_vidVobSub.h&quot;
-
-#include &quot;ADM_osSupport/ADM_debugID.h&quot;
-#define MODULE_NAME MODULE_FILTER
-#include &quot;ADM_osSupport/ADM_debug.h&quot;
-
-
-extern uint8_t DIA_vobsub(vobSubParam *param);
-
-static FILTER_PARAM vobsubParam={3,{&quot;subname&quot;,&quot;index&quot;,&quot;subShift&quot;}};
-//*************************************************************
-//
-
-//*************************************************************
-SCRIPT_CREATE(vobsub_script,ADMVideoVobSub,vobsubParam);
-BUILD_CREATE(vobsub_create,ADMVideoVobSub);
-//*************************************************************
-uint8_t ADMVideoVobSub::configure(AVDMGenericVideoStream *in)
-{
-
-       
-  if(DIA_vobsub(_param))
-       {
-                cleanup();
-                setup();
-                return 1;
-       }
-        
-        return 0;        
-}
- 
-//*************************************************************
-char *ADMVideoVobSub::printConf( void )
-{
-        static char buf[50];
-        
-        sprintf((char *)buf,&quot; VobSub&quot;);
-        return buf;
-}
-//*************************************************************
-ADMVideoVobSub::ADMVideoVobSub(  AVDMGenericVideoStream *in,CONFcouple *couples)
-{
-
-        _in=in;         
-        memcpy(&amp;_info,_in-&gt;getInfo(),sizeof(_info));    
-        _info.encoding=1;       
-        _parser=NULL;  
-        _resampled=NULL;
-        _chromaResampled=NULL;
-        _original=NULL;        
-        
-        _param=NEW(vobSubParam);
-        
-        if(couples)
-        {                 
-                GET(subname);
-                GET(index);                               
-                GET(subShift);  
-        }
-        else
-        {
-#ifdef KK_ADM_DEBUG
-                _param-&gt;subname=ADM_strdup(VOBSUB);
-#else                
-                _param-&gt;subname =NULL;
-#endif                
-                _param-&gt;index = 0;   
-                _param-&gt;subShift=0;             
-        }
-        
-        setup();
-}
-/*
-    Alternate constructor for use by OCR
-*/
-ADMVideoVobSub::ADMVideoVobSub(  char *fileidx,uint32_t idx)
-{
-
-        _in=NULL;         
-        memset(&amp;_info,0,sizeof(_info));    
-        _info.encoding=1;       
-        _parser=NULL;  
-        _resampled=NULL;
-        _chromaResampled=NULL;
-        _original=NULL;        
-        
-        _param=NEW(vobSubParam);
-        
-        
-        _param-&gt;subname=ADM_strdup(fileidx);
-        _param-&gt;index = idx;   
-        _param-&gt;subShift=0;                    
-        
-        setup();
-}
-/*
-    Returns bitmap &amp; info for the Nth subs
-*/
-
-vobSubBitmap *ADMVideoVobSub::getBitmap(uint32_t nb,uint32_t *start, uint32_t *end,uint32_t *first,uint32_t *last)
-{
-uint32_t top=0,bottom=0;
-    ADM_assert(_vobSubInfo);
-    ADM_assert(nb&lt;_vobSubInfo-&gt;nbLines);
-    
-    // Seek &amp; decode
-    //_parser-&gt;_asyncJump2(0,_vobSubInfo-&gt;lines[nb].fileOffset);
-    _parser-&gt;setPos(_vobSubInfo-&gt;lines[nb].fileOffset,0);
-    if(!handleSub(nb))
-        {
-                printf(&quot;Error reading getBimap\n&quot;);
-                *first=*last=0;
-                return _original; // might be null (?)
-        }
-    *first=*last=0;
-    if(_original)
-    {
-    uint32_t ox,oy;
-        _original-&gt;buildYUV(_YUVPalette);
-        ox=_original-&gt;_width;        
-        oy=_original-&gt;_height;
-        printf(&quot;Original :%lu x %lu (original  %d)\n&quot;,ox,oy,_vobSubInfo-&gt;height);
-        ADM_assert(oy&lt;=_vobSubInfo-&gt;height);
-        
-        // Search the 1st/last non null line
-//#define DONTCLIP
-#ifdef DONTCLIP     
-         *first=0;
-         *last=oy-1;   
-#else
-        if(oy&gt;_original-&gt;_height) oy=_original-&gt;_height-1;
-
-        while(top&lt;oy &amp;&amp; !_original-&gt;isDirty(top) ) top++;
-        
-        if(top==oy)
-        {
-                top=bottom=0;   // Empty bitmap ?
-                *first=top;
-                *last=bottom;
-                printf(&quot;Empry bitmap\n&quot;);
-                return NULL; 
-        }
-        bottom=oy-1;
-        while(bottom&gt;top &amp;&amp; !_original-&gt;isDirty(bottom)) bottom--;
-        
-        // If true it means we have 2 subs, one on top, one on bottom
-        //
-#if 0
-        if(bottom&gt;(oy&gt;&gt;1) &amp;&amp; top&lt;(oy&gt;&gt;1) &amp;&amp; (bottom-top&gt;(oy&gt;&gt;1)))
-        {
-          // in that case, take only the lower one
-          top=oy&gt;&gt;1;
-          while(top&lt;oy &amp;&amp; !_original-&gt;isDirty(top)) top++;                    
-        }
-        printf(&quot;&gt; clipped: %lu / %lu=%lu\n&quot;,top,bottom,bottom-top+1);
-#endif
-        *first=top;
-        *last=bottom;
-#endif
-    }
-    *start=_vobSubInfo-&gt;lines[nb].startTime;
-    *end=_vobSubInfo-&gt;lines[nb].stopTime;
-    return _original;
-}
-/*
-    Returns the nb of lines found in the sub
-*/
-uint32_t     ADMVideoVobSub::getNbImage( void)
-{
-    if(!_parser) return 0;
-    if(!_param) return 0;
-    if(!_vobSubInfo) return 0;
-    return _vobSubInfo-&gt;nbLines;
-
-}
-//************************************
-uint8_t ADMVideoVobSub::setup(void)
-{
-  char *dup;
-  int l;
-  
-   _vobSubInfo=NULL;
-   if(_param-&gt;subname &amp;&amp; strlen(_param-&gt;subname)&gt;5)
-        {
-                printf(&quot;Opening %s\n&quot;,_param-&gt;subname);
-                dup=ADM_strdup(_param-&gt;subname);
-                l=strlen(dup);
-                if(l&gt;5)
-                  if(dup[l-4]=='.')
-                {
-                  dup[l-3]='s';
-                  dup[l-2]='u';
-                  dup[l-1]='b';
-                          
-                }
-                if(vobSubRead(_param-&gt;subname,_param-&gt;index,&amp;_vobSubInfo))
-                {
-                        printf(&quot;Opening index \n&quot;);
-                       
-                        MPEG_TRACK track;
-                        memset(&amp;track,0,sizeof(track));
-                        track.pes=_param-&gt;index+0x20;
-                        track.pid=0;
-                       // _parser=new ADM_mpegDemuxerProgramStream(_param-&gt;index+0x20,0xe0);
-                        _parser=new dmx_demuxerPS(1,&amp;track,0);
-                        if(!_parser-&gt;open(dup))
-                        {
-                                printf(&quot;Mpeg Parser : opening %s failed\n&quot;,_param-&gt;subname);
-                                delete _parser;
-                                _parser=NULL;
-                
-                         }
-                         
-                }
-                ADM_dealloc(dup);
-        }
-        
-        
-        if(!_parser)
-        {
-                printf(&quot;opening of vobsub file failed\n&quot;);
-        }
-         else
-        {       // Recompute sub duration
-                uint32_t end;
-                vobSubLine *cur,*next;
-                // Assuming max displat time = MAX_DISPLAY_TIME
-                for(uint32_t i=0;i&lt;_vobSubInfo-&gt;nbLines-1;i++)
-                {
-                        if(i &amp;&amp; !_vobSubInfo-&gt;lines[i].startTime)
-                        {
-                                _vobSubInfo-&gt;lines[i].startTime=0xf0000000;
-                                _vobSubInfo-&gt;lines[i].stopTime=0xf0000001;
-                                
-                        }
-                        else
-                        {
-                                cur=&amp;_vobSubInfo-&gt;lines[i];
-                                next=&amp;_vobSubInfo-&gt;lines[i+1];
-                        
-                                end=cur-&gt;startTime+MAX_DISPLAY_TIME;
-                                if(end&gt;=next-&gt;startTime) end=next-&gt;startTime-1;
-                                cur-&gt;stopTime=end;                                
-                        }
-                }
-                _vobSubInfo-&gt;lines[_vobSubInfo-&gt;nbLines-1].stopTime=
-                        MAX_DISPLAY_TIME+_vobSubInfo-&gt;lines[_vobSubInfo-&gt;nbLines-1].startTime;
-                // Convert all the palette from RGB to YUV
-                paletteYUV();
-        }
-      
-        _x1=_y1=_x2=_y2=0;
-        _data=new uint8_t [VS_MAXPACKET];
-        _subSize=0;
-        _subW=_subH=0;
-        
-        memset(&amp;_original,0,sizeof(_original));
-        _currentSub=NOSUB;
-        _initialPts=0;
-                
-
-}
-//*************************************************************
-uint8_t ADMVideoVobSub::cleanup(void)
-{
-
-        if(_parser) delete _parser;
-        _parser=NULL;
-        
-        if(_original)
-          delete _original;
-        _original=NULL;        
-        
-        if(_resampled)
-          delete _resampled;
-        _resampled=NULL;
-        
-        if(_chromaResampled)
-          delete _chromaResampled;
-        _chromaResampled=NULL;
-        
-        
-        if(_data) delete [] _data;
-        _data=NULL;
-        
-        if(_vobSubInfo) destroySubInfo( _vobSubInfo);
-        _vobSubInfo=NULL;
-        
-
-}
-//*************************************************************
-ADMVideoVobSub::~ADMVideoVobSub()
-{
-        cleanup();
-         if(_param)
-        {
-                if(_param-&gt;subname)  ADM_dealloc(_param-&gt;subname);
-                DELETE(_param);
-        }
-        _param=NULL;
-}
-
-//*************************************************************
-uint8_t ADMVideoVobSub::getCoupledConf( CONFcouple **couples)
-{
-                        ADM_assert(_param);
-                        *couples=new CONFcouple(3);
-
-#define CSET(x)  (*couples)-&gt;setCouple((char *)#x,(_param-&gt;x))
-                        if(_param-&gt;subname)
-                                CSET(subname);
-                        else
-                          (*couples)-&gt;setCouple(&quot;subname&quot;,&quot;none&quot;) ;
-                        CSET(index);
-                        CSET(subShift);
-                        
-
-                        return 1;
-}
-//*************************************************************
-uint8_t ADMVideoVobSub::getFrameNumberNoAlloc(uint32_t frame,
-                                uint32_t *len,
-                                ADMImage *data,
-                                uint32_t *flags)
-{
-
-uint64_t time;
-uint32_t sub;
-
-        if(frame&gt;= _info.nb_frames) return 0;
-        // read uncompressed frame
-        if(!_in-&gt;getFrameNumberNoAlloc(frame, len,data,flags)) return 0;
-
-        if(!_parser)        
-        {
-                //
-                printf(&quot;No valid vobsub to process\n&quot;);
-                
-                return 1;
-        
-        }
-        
-        time=(frame+_info.orgFrame);
-        time=(time*1000*1000)/_info.fps1000;
-        
-        sub=lookupSub(time);  
-        // Should we re-use the current one ? 
-        if(sub==NOSUB)
-        {
-                aprintf(&quot;No matching sub for time %llu frame%lu\n&quot;,time,frame);
-                return 1;
-        }
-        // If it is a new sub, decode it...
-        if(sub!=_currentSub )
-        {                
-                // _parser-&gt;_asyncJump2(0,_vobSubInfo-&gt;lines[sub].fileOffset);
-                _parser-&gt;setPos(_vobSubInfo-&gt;lines[sub].fileOffset,0);
-                 //_initialPts=_parser-&gt;getPTS();
-                 handleSub(sub);
-                _currentSub=sub;
-                Palettte2Display(); // Create the bitmap
-                // Time to resize the bitmap
-                // First try : Do it bluntly
-                
-        }                
-        
-        // and if there is something to display, display it
-        //
-        vobSubBitmap *src;
-        //src=_original;
-        src=_resampled;
-        
-        if(src)          
-        {
-               
-          aprintf(&quot;We have %lu %lu to merge\n&quot;,src-&gt;_width,src-&gt;_height);
-                // Merge
-                
-                uint32_t stridein,strideout,len;
-                uint8_t *in,*out,*mask,*in2;
-                uint16_t old,nw,alp;
-                uint32_t xx,yy;
-                
-                stridein=src-&gt;_width;
-                strideout=_info.width;
-                
-                if(strideout&gt;stridein)
-                {
-                        len=stridein;
-                        xx=src-&gt;_width;
-                }
-                else
-                {
-                        xx=_info.width;
-                        len=strideout;
-                }
-                if(src-&gt;_height&gt;_info.height) yy=_info.height;
-                        else                 yy=src-&gt;_height;           
-                in=src-&gt;_bitmap;
-                mask=src-&gt;_alphaMask;
-               
-                out=data-&gt;data+_info.width*src-&gt;placeTop;
-                // auto center
-                uint32_t center=_info.width-src-&gt;_width;
-                out+=(center&gt;&gt;2)*2;
-                
-                for(uint32_t y=0;y&lt;yy;y++)
-                {
-                  for(uint32_t x=0;x&lt;xx;x++)
-                        {
-                               old=out[x];
-                               nw=in[x];
-                               alp=mask[x];
-
-                                if(alp) 
-                                {
-                                  if(alp&gt;7)  nw=old*(16-alp-1)+(alp+1)*nw;
-                                        else nw=old*(16-alp)+(alp)*nw;
-                                  out[x]=nw&gt;&gt;4;                                         
-                                }
-
-                               //out[x]=nw;
-                        }
-                        //memcpy(out,in,len);
-                        out+=strideout;
-                        in+=stridein;
-                        mask+=stridein;
-                }
-                
-                // Now do chroma u &amp; chroma V
-#define DOCHROMA                
-#if defined(DOCHROMA)                
-                uint32_t crosspage=(_info.width*_info.height)&gt;&gt;2;
-                
-                strideout=_info.width&gt;&gt;1;
-                stridein=_chromaResampled-&gt;_width;
-                
-                out=data-&gt;data+_info.width*_info.height;
-                out+=(src-&gt;placeTop&gt;&gt;1)*(_info.width&gt;&gt;1);
-                mask=_chromaResampled-&gt;_alphaMask;
-                // Center
-                out+=(center&gt;&gt;2)*1;
-                if(strideout&gt;stridein) xx=stridein;
-                else            xx=strideout;
-                
-                int16_t left=(_info.height&gt;&gt;1)-(_chromaResampled-&gt;_height+(_original-&gt;placeTop&gt;&gt;1));
-                
-                if(left&lt;_chromaResampled-&gt;_height) yy=left;
-                else yy=_chromaResampled-&gt;_height;
-                
-                for(uint32_t y=0;y&lt;yy;y++)
-                {
-                   for(uint32_t x=0;x&lt;xx;x++)
-                   {
-                        if(mask[x]&gt;10)         
-                        {
-                          int16_t val;
-                          val=out[x];
-                          val-=128;
-                         
-                          
-                          
-                          nw=val*(16-alp);
-                          
-                          val/=4;
-                          val=val+128;
-                                
-                          out[x]=val; 
-                          out[crosspage+x]=val;
-                        }                                                 
-                   }
-                   out+=strideout;
-                   mask+=stridein;
-                }
-#endif                
-        }
-        return 1;
-}
-//*************************************************************************
-//
-//      Convert the original bitmap to a rescaled &amp; repositionned one
-//      that will be blended into the current picutr
-//
-//*************************************************************************
-uint8_t ADMVideoVobSub::Palettte2Display( void )
-{
-        ADM_assert(_parser);
-        ADM_assert(_vobSubInfo);
-     
-        // Then Process the RLE Datas
-        // To get the _bitmap yuv data
-        ADM_assert(_original);
-        
-        // Set correct color
-        _original-&gt;buildYUV(_YUVPalette);
-        
-        // rebuild the scaled one
-        // Compute the target size
-        uint32_t fx,fy;
-        uint32_t ox,oy;
-        uint32_t sx,sy;
-        /*
-                Fx, fy : Final size of the image (i.e size of the current picture)
-                ox,oy  : Original size of the image where the sub is coming from
-                sx,sy  : Size of the  sub
-        
-                And we want the final size of the sub
-                        + coordinates but that we will do later
-        
-        */
-        
-        fx=_info.width;
-        fy=_info.height;
-        
-        ox=_vobSubInfo-&gt;width;
-        oy=_vobSubInfo-&gt;height;
-        
-        sx=_subW;
-        sy=_subH;
-        
-        // Search the 1st/last non null line
-        uint32_t top=0,bottom=0;
-
-        if(oy&gt;_original-&gt;_height) oy=_original-&gt;_height-1;
-
-        while(top&lt;oy &amp;&amp; !_original-&gt;isDirty(top)) top++;
-        
-        bottom=_original-&gt;_height-1;
-        if(top==bottom)
-        {
-                printf(&quot;Empty sub ?&quot;);
-                return 0;
-        }
-        
-        while(bottom &amp;&amp; !_original-&gt;isDirty(bottom)) bottom--;
-        
-        // If true it means we have 2 subs, one on top, one on bottom
-        //
-        if(bottom&gt;(oy&gt;&gt;1) &amp;&amp; top&lt;(oy&gt;&gt;1) &amp;&amp; (bottom-top&gt;(oy&gt;&gt;1)))
-        {
-          // in that case, take only the lower one
-          top=oy&gt;&gt;1;
-          while(top&lt;oy &amp;&amp; !_original-&gt;isDirty(top)) top++;                    
-        }
-        //
-        //  The useful part is between top &amp; bottom lines
-        //
-        
-        // Shrink factor
-        // The shrink factor is the one used to shrink from the original video
-        // to the resize video
-        
-        double scale,l;
-        scale=fx;
-        scale/=ox;
-        printf(&quot;top %lu : bottom :%lu Scale :%f ox:%lu oy:%lu fx:%lu \n&quot;,top,bottom,scale,ox,oy,fx);
-        
-        // We rescale the sub by the same factor
-        // Only the visible / useful part
-        l=scale;
-        l=l*sx;
-        sx=(uint32_t )floor(l);
-        
-       
-        l=scale;
-        l=l*(bottom-top);
-        sy=(uint32_t )floor(l);
-        
-
-        // And we resize that useful part of sub
-        // to our final bitmap (resampled)
-                
-        _original-&gt;subResize(&amp;_resampled,sx,sy,top, bottom-top);
-                
-        uint32_t tail;
-        
-        // Set the position of the sub so that it is ok
-        
-        tail=16+sy;
-        
-        if(tail&gt;fy) tail=0;
-        else
-        {
-            tail=fy-tail;           
-        }
-        
-        _resampled-&gt;placeTop=tail;
-        
-        _resampled-&gt;subResize(&amp;_chromaResampled,sx&gt;&gt;1,sy&gt;&gt;1,0,sy);
-        return 1;
-}
-
-//
-//      Return the index in the sub table of the sub matching the time
-//
-uint32_t ADMVideoVobSub::lookupSub(uint64_t time)
-{
-int64_t head,tail, cur;
-int32_t i;
-        cur=(int64_t)time;
-        i=0;
-        while(i&lt;_vobSubInfo-&gt;nbLines-1)
-        {
-                head=(int64_t)_vobSubInfo-&gt;lines[i].startTime;
-                tail=(int64_t) _vobSubInfo-&gt;lines[i].stopTime;
-                head+=_param-&gt;subShift;
-                tail+=_param-&gt;subShift;
-                if(head&lt;=cur &amp;&amp;tail&gt;cur)
-                {
-                  aprintf(&quot;Matching for time %llu : sub %lu starting at :%lu (shift %lu)\n&quot;,
-                                        time,i,_vobSubInfo-&gt;lines[i].startTime,_param-&gt;subShift);
-                        return i; 
-                }   
-                if(head&gt;cur) return NOSUB;                   
-                i++;       
-        }
-        return NOSUB;
-
-
-}
-//EOF
-

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vobsubinfo.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vobsubinfo.cpp	2007-08-19 13:46:48 UTC (rev 3538)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vobsubinfo.cpp	2007-08-19 16:01:39 UTC (rev 3539)
@@ -1,265 +0,0 @@
-//
-// C++ Implementation: vobsub parser
-//
-// Description:
-//
-//
-// Author: Mean, 2005 GPL
-//
-// Copyright: See COPYING file that comes with this distribution
-//
-//
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#include &quot;config.h&quot;
-#include &lt;stdio.h&gt;
-#include &lt;stdlib.h&gt;
-#include &lt;string.h&gt;
-#include &lt;ADM_assert.h&gt;
-#include &quot;ADM_utilities/default.h&quot;
-#include &quot;ADM_vobsubinfo.h&quot;
-
-static uint8_t fillLine(char *str,VobSubInfo *sub,uint32_t line);
-static uint32_t countLine(FILE *f,int index);
-uint8_t fillPalette(char *str,VobSubInfo *sub);
-
-uint8_t destroySubInfo(VobSubInfo *sub)
-{
-        if(!sub) return 1;      // ?
-        if(sub-&gt;lines) delete [] sub-&gt;lines;
-        delete sub;
-        return 1;
-
-
-}
-//****************** 
-// Extract Line info
-//******************
-uint8_t fillLine(char *str,VobSubInfo *sub,uint32_t line)
-{
-int hh,mm,ss,ms,o;
-uint64_t ti;
-uint32_t pos;
-
-        ADM_assert(line&lt;sub-&gt;nbLines);
-
-        o=sscanf(str,&quot;timestamp: %d:%d:%d:%d, filepos: %x\n&quot;,&amp;hh,&amp;mm,&amp;ss,&amp;ms,&amp;pos);
-        ADM_assert(o==5);
-        
-        ti=hh*3600+mm*60+ss;
-        ti=ti*1000+ms;
-        
-        sub-&gt;lines[line].startTime      =ti;
-        sub-&gt;lines[line].stopTime       =ti+1000;
-        sub-&gt;lines[line].fileOffset     =pos;
-        
-        return 1;
-}
-//******************
-// Extract palette
-//******************
-uint8_t fillPalette(char *str,VobSubInfo *sub)
-{
-int p[16],o;
-
-        o=sscanf(str,&quot;palette: %x, %x, %x, %x, %x, %x, %x, %x,&quot;
-                                &quot; %x, %x, %x, %x, %x, %x, %x, %x&quot;,
-                                &amp;p[0],&amp;p[1],&amp;p[2],&amp;p[3],&amp;p[4],&amp;p[5],&amp;p[6],&amp;p[7],
-                                &amp;p[8],&amp;p[9],&amp;p[10],&amp;p[11],&amp;p[12],&amp;p[13],&amp;p[14],&amp;p[15]);
-        ADM_assert(o==16);
-        for(int i=0;i&lt;16;i++)
-                sub-&gt;Palette[i]=p[i];
-                                       
-        return 1;
-}
-//******************
-//******************
-uint8_t vobSubRead(char *filename,int index,VobSubInfo **info)
-{
-FILE            *file=NULL;
-uint32_t        nb_lines;
-VobSubInfo      *sub=NULL;
-uint8_t         success=0;
-uint32_t        line=0,l;
-char            str[1024];
-char            *dup;
-int             language=0;
-
-        if(!filename)
-        {
-                printf(&quot;Null file ?\n&quot;);
-                return 0;
-        }
-        *info=NULL;
-        file=fopen(filename,&quot;rt&quot;);
-        if(!file) 
-        {
-                printf(&quot;Could not open %s file\n&quot;,filename);
-                return 0;
-        }
-        nb_lines=countLine(file,index);
-        if(!nb_lines)
-        {
-                printf(&quot;Empty file\n&quot;);
-                 goto subAbort;
-        }
-        // Try to read the file
-        sub=new VobSubInfo;
-        memset(sub,0,sizeof(VobSubInfo));
-        //
-        sub-&gt;nbLines=nb_lines;
-        sub-&gt;lines=new vobSubLine[nb_lines];
-        memset(sub-&gt;lines,0,sizeof(vobSubLine)*nb_lines);
-        printf(&quot;Rebuilding %d lines of subs\n&quot;,nb_lines);
-        
-        while(line&lt;nb_lines &amp;&amp; !feof(file))
-        {
-                fgets(str,1023,file); 
-                if(!strncmp(str,&quot;palette:&quot;,7))
-                {
-                                 fillPalette(str,sub);
-                                 sub-&gt;hasPalette=1;
-                }
-                else 
-                {
-                        if(!strncmp(str,&quot;timestamp: &quot;,10) &amp;&amp; language)        
-                        {
-                                fillLine(str,sub,line);
-                                line++;
-                        }
-                        else
-                        {
-                                if(!strncmp(str,&quot;id:&quot;,3))       // Catch language/index
-                                {
-                                  int  l;
-                                  char s[50];
-                                  s[0]=0;
-                                  l=999;
-                                  sscanf(str,&quot;id: %s index: %d&quot;,s,&amp;l);
-                                  printf(&quot;Found lang : %s index %d while searching %d\n&quot;,s,l,index);
-                                  if(l==index)
-                                  {
-                                	  language=1;
-                                	  printf(&quot;Match\n&quot;);
-                                  }
-                                  else language=0;                                                                              
-                                
-                                }
-                                else
-                                {
-                                        if(!strncmp(str,&quot;size:&quot;,5))       // Catch original screen dimension
-                                        {
-                                            sscanf(str,&quot;size:%&quot;SCNu32&quot;x%&quot;SCNu32&quot;&quot;,&amp;(sub-&gt;width),&amp;(sub-&gt;height));
-                                        }
-                                
-                                }
-                                
-                        }
-                }
-        }
-subSuccess:        
-        success=1;
-        if(!sub-&gt;hasPalette)
-        {
-            for(int j=0;j&lt;16;j++)
-                sub-&gt;Palette[j]=j;   
-        }
-subAbort:        
-        if(success)
-        {
-                *info=sub;
-        }
-        else
-        {
-                destroySubInfo( sub);        
-        }
-        fclose(file);
-        return success;
-
-}
-//******************
-// count #nb beginning by timestamp in file
-//******************
-uint32_t countLine(FILE *f,int index)
-{
-char str[1024],s[1024];
-uint32_t nb=0;
-uint32_t match=0;
-int lang;
-
-        fseek(f,0,SEEK_SET);
-        while(!feof(f))
-        {
-                fgets(str,1023,f);
-                if(!strncmp(str,&quot;id:&quot;,3))
-                {
-                  s[0]=0;
-                  lang=9999;
-                  sscanf(str,&quot;id: %s index: %d&quot;,s,&amp;lang);
-                  if(lang==index) match=1;
-                  else match=0;
-                }
-                else
-                  if(match)
-                        if(!strncmp(str,&quot;timestamp: &quot;,10)) nb++;
-        
-        }
-        fseek(f,0,SEEK_SET);
-        return nb;
-}
-//*****************************************
-vobSubLanguage *vobSubAllocateLanguage(void)
-{
-  vobSubLanguage *l;
-  l=new vobSubLanguage;
-  memset(l,0,sizeof(vobSubLanguage));
-  return l;  
-}
-//*****************************************
-uint8_t vobSubDestroyLanguage(vobSubLanguage *lingua)
-{
-  for(uint32_t i=0;i&lt;lingua-&gt;nbLanguage;i++)  
-    delete [] lingua-&gt;language[i].name;
-  delete lingua; 
-  return 1;
-}
-//*****************************************
-uint8_t vobSubGetLanguage(const char *filename,vobSubLanguage *lingua)
-{
-  char str[1024];
-  char s[16];
-  uint32_t nb=0,index;
-  FILE *fd=NULL;
-  
-  fd=fopen(filename,&quot;rb&quot;);
-  if(!fd) return 0;
-  
-  
-
-  
-  while(!feof(fd))
-  {
-    fgets(str,1023,fd);
-    if(!strncmp(str,&quot;id: &quot;,3))
-    {
-      sscanf(str,&quot;id: %s index: %d&quot;,s,&amp;index);
-      lingua-&gt;language[nb].name=new char[3];
-      lingua-&gt;language[nb].name[0]=str[4];
-      lingua-&gt;language[nb].name[1]=str[5];
-      lingua-&gt;language[nb].name[2]=0;
-      //
-      lingua-&gt;language[nb].index=index;
-      nb++;
-    }        
-  }
-  lingua-&gt;nbLanguage=nb;
-  return 1;
-}
-
-//EOF

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vobsubinfo.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vobsubinfo.h	2007-08-19 13:46:48 UTC (rev 3538)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vobsubinfo.h	2007-08-19 16:01:39 UTC (rev 3539)
@@ -1,60 +0,0 @@
-//
-// C++ Interface: Vobsubinfo struct &amp; prototyping
-//
-// Description: Read the idx part of an index file
-//
-//
-// Author: mean , <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>, GPL (C) 2005
-//
-// Copyright: See COPYING file that comes with this distribution
-//
-//
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#ifndef _VOBSUB_INFO_
-#define _VOBSUB_INFO_
-#define ADM_MAX_LANGUAGE 33
-typedef struct vobSubLine
-{
-        uint32_t        startTime;      /// Starting time in ms
-        uint32_t        stopTime;       /// Stop time
-        uint64_t        fileOffset;     /// Offset in the file where this sub starts
-
-}vobSubLine;
-typedef struct vobSubOneLang
-{
-        char     *name;
-        uint32_t index;
-}vobSubOneLang;
-typedef struct vobSubLanguage
-{
-        uint32_t        nbLanguage; 
-        vobSubOneLang   language[ADM_MAX_LANGUAGE];  
-}vobSubLanguage;
-
-typedef struct VobSubInfo
-{
-        uint32_t        hasPalette;
-        uint32_t        Palette[16];
-        uint32_t        nbLines;
-        uint32_t        width;
-        uint32_t        height;
-        vobSubLine      *lines;
-}VobSubInfo;
-
-/// Read the sub and return a new filled out vobsub info struct
-uint8_t vobSubRead(char *filename,int index,VobSubInfo **info);
-uint8_t destroySubInfo(VobSubInfo *sub);
-
-uint8_t         vobSubGetLanguage(const char *filename,vobSubLanguage *lingua);
-vobSubLanguage  *vobSubAllocateLanguage(void);
-uint8_t         vobSubDestroyLanguage(vobSubLanguage *lingua);
-
-#endif
-// EOF

Modified: branches/avidemux_2.4_branch/avidemux/ADM_video/CMakeLists.txt
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/CMakeLists.txt	2007-08-19 13:46:48 UTC (rev 3538)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/CMakeLists.txt	2007-08-19 16:01:39 UTC (rev 3539)
@@ -9,12 +9,9 @@
 ADM_vidRaw.cpp        
 ADM_genvideo.cpp         
 ADM_vidFont.cpp
-ADM_vidVobsub.cpp
-ADM_vidVobSubRender.cpp
 ADM_interlaced.cpp       
 ADM_vidCached.cpp       
 ADM_vidMPdelogo.cpp      
-ADM_vobsubinfo.cpp
 ADM_vidClean.cpp        
 ADM_vidEqualizer.cpp  
 ADM_vidNull.cpp          

Modified: branches/avidemux_2.4_branch/avidemux/ADM_video/Makefile.am
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/Makefile.am	2007-08-19 13:46:48 UTC (rev 3538)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/Makefile.am	2007-08-19 16:01:39 UTC (rev 3539)
@@ -11,20 +11,15 @@
  ADM_vidPartial.cpp \
  ADM_vidFont.cpp \
  ADM_vidNull.cpp \
-	ADM_vidClean.cpp \
+ ADM_vidClean.cpp \
  ADM_genvideo.cpp \
  ADM_vidFieldUtil.cpp \
  ADM_vidFieldUtil.h \
  ADM_confCouples.cpp \
- ADM_confCouple.h ADM_vidCommonFilter.h \
  ADM_interlaced.cpp \
-	ADM_interlaced.h \
  ADM_vidRaw.cpp \
  ADM_cache.cpp \
  ADM_vidEqualizer.cpp \
- ADM_vidVobsub.cpp \
- ADM_vobsubinfo.cpp \
- ADM_vidVobSubRender.cpp \
  ADM_vidCNR2.cpp \
  ADM_vidMPdelogo.cpp \
  ADM_vidColorYuv.cpp  
@@ -32,55 +27,8 @@
 				
 
 
-EXTRA_DIST =  ADM_cache.cpp  \
-ADM_cache.h  \
-ADM_confCouple.h ADM_vidNull.cpp \
-ADM_confCouples.cpp  \
-ADM_genvideo.cpp \
-ADM_genvideo.hxx ADM_vidPartial.cpp \
-ADM_vidPartial.h \
-ADM_vidPartial_param.h \
-ADM_guiResize.cpp   ADM_vidRaw.cpp \
-ADM_interlaced.cpp  \
-ADM_interlaced.h ADM_vidResize.cpp \
-ADM_vidResize25.cpp \
-ADM_vidEqualizer.cpp  \
-ADM_mpdetc.cpp ADM_vidEqualizer.h   \
-ADM_mpdetc.h  \
-ADM_resizebis.cpp   \
-ADM_resizebis.hxx    \
-ADM_resizeter.cpp  ADM_vidField.h  \
-ADM_vidFieldUnblend.cpp \
-ADM_vidFieldUtil.cpp  \
-ADM_vidFieldUtil.h  \
-ADM_vidAnimated.cpp  \
-ADM_vidAnimated.h  \
-ADM_vidAnimated_param.h   \
-ADM_vidFont.cpp \
-ADM_vidFont.h \
-ADM_vidCNR2.cpp  \
-ADM_vidCNR2_param.h  ADM_vidTDeint_param.h \
-ADM_vidCached.cpp  ADM_vidTdeint.cpp \
-ADM_vidCached.h  ADM_vidIVTC.cpp \
-ADM_vidIVTC.h \
-ADM_vidChromaShift.cpp \
-ADM_vidChromaShift.h  \
-ADM_vidClean.cpp  \
-ADM_vidClean.h \
-ADM_vidColorYuv.cpp  \
-ADM_vidColorYuv.h  ADM_vidVobSub.h \
-ADM_vidColorYuv_param.h  ADM_vidVobSubRender.cpp \
-ADM_vidCommonFilter.h  ADM_vidMPLResize.cpp  ADM_vidVobsub.cpp \
-ADM_vidMPdelogo.cpp \
-ADM_vidMPdelogo.h \
-ADM_vobsubinfo.cpp \
-ADM_vobsubinfo.h \
-swscale_internal.h \
-ADM_vidTdeint_util.txt mmx_macros.h
+EXTRA_DIST =  
 
 ####### kdevelop will overwrite this part!!! (end)############
 INCLUDES = $(all_includes) -I../ADM_libraries -I../ADM_libraries/ADM_utilities -I../ADM_libraries/ADM_lavutil \
 			 $(FREETYPE_CFLAGS) $(ALTIVEC_SWITCH) -I../ADM_userInterfaces/ADM_commonUI -I../ADM_inputs
-noinst_HEADERS = ADM_mpdetc.h \
-  ADM_cache.h \
-ADM_vidEqualizer.h ADM_vobsubinfo.h ADM_vidVobSub.h 

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_video/swscale_internal.h
===================================================================

Copied: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_mpdetc.h (from rev 3532, branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_mpdetc.h)

Modified: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidDvbSub.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidDvbSub.h	2007-08-19 13:46:48 UTC (rev 3538)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidDvbSub.h	2007-08-19 16:01:39 UTC (rev 3539)
@@ -20,7 +20,7 @@
 #include &quot;ADM_inputs/ADM_mpegdemuxer/dmx_demuxerTS.h&quot;
 
 #include &quot;ADM_codecs/ADM_ffmp43.h&quot;
-#include &quot;ADM_video/ADM_vidVobSubBitmap.h&quot;
+#include &quot;ADM_videoFilter/ADM_vidVobSubBitmap.h&quot;
 
 
 #define READ_BUFFER_SIZE (64*1024)

Copied: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidVobSub.h (from rev 3532, branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidVobSub.h)
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidVobSub.h	2007-08-18 17:18:57 UTC (rev 3532)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidVobSub.h	2007-08-19 16:01:39 UTC (rev 3539)
@@ -0,0 +1,81 @@
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#ifndef _VOBSUB_V_
+#define _VOBSUB_V_
+#include &quot;ADM_inputs/ADM_mpegdemuxer/dmx_demuxerPS.h&quot;
+#define VS_MAXPACKET 128*1024
+
+#define NOSUB 0xffffffff
+
+#define MAX_DISPLAY_TIME 3000 // 3s
+
+//************************************
+typedef struct vobSubParam
+{
+        char            *subname;
+        uint32_t        index;
+        int32_t         subShift;
+}vobSubParam;
+//************************************
+#include &quot;ADM_videoFilter/ADM_vidVobSubBitmap.h&quot;
+//************************************
+class  ADMVideoVobSub:public AVDMGenericVideoStream
+ {
+
+ protected:
+        virtual char                    *printConf(void);
+        uint8_t                         guessPalette(void);
+        uint8_t                         readbyte(void);         /// Read a byte from buffer
+        uint16_t                        readword(void);         /// Read a 16 bits word from buffer
+        uint8_t                         forward(uint32_t v);    /// Read a 16 bits word from buffer
+        uint8_t                         decodeRLE(uint32_t off,uint32_t start,uint32_t end);
+        uint8_t                         setup(void);            /// Rebuild internal info
+        uint8_t                         cleanup(void);          /// Destroy all internal info
+        uint8_t                         paletteYUV( void );     /// Convert RGB Pallette to yuv
+        uint8_t                         Palettte2Display( void ); /// Convert the RLE to YUV bitmap
+        uint8_t                         handleSub( uint32_t idx );/// Decode a sub packet
+        uint32_t                        lookupSub(uint64_t time);/// Return sub index corresponding to time
+        
+        dmx_demuxerPS                   *_parser;        
+        uint8_t                         *_data;                 /// Data for packet
+        VobSubInfo                      *_vobSubInfo;           /// Info of the index file
+        vobSubParam                     *_param;
+        vobSubBitmap                    *_original;              /// True size (..) depacked vobsub
+        vobSubBitmap                    *_resampled;            /// Final one; to be blended in picture
+        vobSubBitmap                    *_chromaResampled;      /// Same as above but shinked by 2
+        uint32_t                        _x1,_y1,_x2,_y2;        /// sub boxing
+        uint32_t                        _subW,_subH;
+        uint8_t                         _displaying;            ///  Is display active
+        uint32_t                        _curOffset;
+        uint32_t                        _subSize;
+        uint32_t                        _dataSize;              /// Size of the data chunk
+        
+        uint8_t                         _colors[4];             /// Colors palette
+        uint8_t                         _alpha[4];              /// Colors alpha
+        int16_t                         _YUVPalette[16];        /// Luma only
+        uint32_t                        _currentSub;            ///
+        uint32_t                        _initialPts;
+ public:
+    /* This 3 functions are used by OCR */
+                        ADMVideoVobSub(  char *fileidx,uint32_t idx);
+              vobSubBitmap *getBitmap(uint32_t nb,uint32_t *start, uint32_t *end,uint32_t *first,uint32_t *last);
+              uint32_t     getNbImage( void);
+    /* /ocr */ 
+    
+                        ADMVideoVobSub(  AVDMGenericVideoStream *in,CONFcouple *setup);
+                        ~ADMVideoVobSub();
+        virtual uint8_t getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
+                                                ADMImage *data,uint32_t *flags);
+        virtual uint8_t getCoupledConf( CONFcouple **couples)           ;
+        virtual uint8_t configure( AVDMGenericVideoStream *instream);
+                                                        
+};
+#endif

Copied: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidVobSubBitmap.h (from rev 3532, branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidVobSubBitmap.h)

Copied: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidVobSubRender.cpp (from rev 3532, branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidVobSubRender.cpp)

Copied: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidVobsub.cpp (from rev 3532, branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidVobsub.cpp)

Copied: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vobsubinfo.cpp (from rev 3532, branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vobsubinfo.cpp)

Copied: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vobsubinfo.h (from rev 3532, branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vobsubinfo.h)

Modified: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/CMakeLists.txt
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/CMakeLists.txt	2007-08-19 13:46:48 UTC (rev 3538)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/CMakeLists.txt	2007-08-19 16:01:39 UTC (rev 3539)
@@ -35,8 +35,13 @@
 ADM_vidDelta.cpp 
 ADM_vidUnblend.cpp 
 ADM_vidAsharp.cpp
+ADM_vidVobsub.cpp
+ADM_vidVobSubRender.cpp
+ADM_vobsubinfo.cpp
+
 )
 ADD_LIBRARY(ADM_videoFilter STATIC ${ADM_videoFilter_SRCS})
 if(FT_FOUND)
 add_definitions(${FT_CFLAGS})
 endif(FT_FOUND)
+include_directories(../ADM_inputs)

Modified: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/Makefile.am
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/Makefile.am	2007-08-19 13:46:48 UTC (rev 3538)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/Makefile.am	2007-08-19 16:01:39 UTC (rev 3539)
@@ -73,6 +73,9 @@
  ADM_vidContrast.cpp \
  ADM_vidDelta.cpp  \
  ADM_vidUnblend.cpp        \
+ ADM_vidVobsub.cpp \
+ ADM_vidVobSubRender.cpp \
+ ADM_vobsubinfo.cpp \
  ADM_vidCrop.cpp       
 			
 


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000812.html">[Avidemux-svn-commit] r3538 -	branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog
</A></li>
	<LI>Next message: <A HREF="000814.html">[Avidemux-svn-commit] r3540 -	branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_gui
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#813">[ date ]</a>
              <a href="thread.html#813">[ thread ]</a>
              <a href="subject.html#813">[ subject ]</a>
              <a href="author.html#813">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">More information about the Avidemux-svn-commit
mailing list</a><br>
</body></html>
