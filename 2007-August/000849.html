<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Avidemux-svn-commit] r3575 - in	branches/avidemux_2.4_branch/avidemux: ADM_filter ADM_video	ADM_videoFilter
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/avidemux-svn-commit/2007-August/index.html" >
   <LINK REL="made" HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r3575%20-%20in%0A%09branches/avidemux_2.4_branch/avidemux%3A%20ADM_filter%20ADM_video%0A%09ADM_videoFilter&In-Reply-To=%3C200708311618.l7VGIQFk023488%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000848.html">
   <LINK REL="Next"  HREF="000850.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Avidemux-svn-commit] r3575 - in	branches/avidemux_2.4_branch/avidemux: ADM_filter ADM_video	ADM_videoFilter</H1>
    <B>mean at BerliOS</B> 
    <A HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r3575%20-%20in%0A%09branches/avidemux_2.4_branch/avidemux%3A%20ADM_filter%20ADM_video%0A%09ADM_videoFilter&In-Reply-To=%3C200708311618.l7VGIQFk023488%40sheep.berlios.de%3E"
       TITLE="[Avidemux-svn-commit] r3575 - in	branches/avidemux_2.4_branch/avidemux: ADM_filter ADM_video	ADM_videoFilter">mean at mail.berlios.de
       </A><BR>
    <I>Fri Aug 31 18:18:26 CEST 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="000848.html">[Avidemux-svn-commit] r3574 - branches/avidemux_2.4_branch/po
</A></li>
        <LI>Next message: <A HREF="000850.html">[Avidemux-svn-commit] r3576 - in	branches/avidemux_2.4_branch/avidemux: . ADM_editor	ADM_outputs ADM_outputs/oplug_dummy
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#849">[ date ]</a>
              <a href="thread.html#849">[ thread ]</a>
              <a href="subject.html#849">[ subject ]</a>
              <a href="author.html#849">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: mean
Date: 2007-08-31 18:18:20 +0200 (Fri, 31 Aug 2007)
New Revision: 3575

Added:
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidComputeAverage.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidComputeAverage.h
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidParticle.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidParticle.h
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidSwissArmyKnife.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidSwissArmyKnife.h
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidThreshold.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidThreshold.h
Modified:
   branches/avidemux_2.4_branch/avidemux/ADM_filter/filter_declaration.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_filter/video_filters.h
   branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_genvideo.hxx
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/CMakeLists.txt
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/Makefile.am
Log:
[Filter] Chris MacGregor funky filters

Modified: branches/avidemux_2.4_branch/avidemux/ADM_filter/filter_declaration.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_filter/filter_declaration.cpp	2007-08-30 18:42:41 UTC (rev 3574)
+++ branches/avidemux_2.4_branch/avidemux/ADM_filter/filter_declaration.cpp	2007-08-31 16:18:20 UTC (rev 3575)
@@ -158,6 +158,7 @@
 
         //*********************
  registerFilter(&quot;-------- Deblender ---------&quot;,VF_INVALID,2,NULL,NULL);
+//	registerFilter(&quot;---- Video Analysis Tools ----&quot;,VF_INVALID,2,NULL,NULL);
 
         REGISTERX(&quot;blendremover&quot;,&quot;Blend remover&quot;,&quot;Remove blend between previous and next picture.&quot;,VF_BLENDREMOVAL,1,blendremove_create,blendremove_script);
         REGISTERX(&quot;hardivtcremove&quot;,&quot;Hard pulldown removal&quot;,&quot;Remove IVTC that has been analog captured or resized.&quot;,VF_HARDIVTC,1,hardivtc_create,hardivtc_script);
@@ -168,6 +169,10 @@
         REGISTERX(&quot;animatedmenu&quot;,&quot;Animated Menu&quot;,
             &quot;Create a video made of 6 mini windows, very useful to do DVD menus.&quot;,
             VF_ANIMATED,1,animated_create,animated_script);
+	REGISTERX(&quot;computeaverage&quot;,&quot;Compute Average&quot;,&quot;Compute average luma value for each pixel throughout all frames, and save to file&quot;,VF_COMPUTEAVERAGE,1,computeaverage_create,computeaverage_script);
+	REGISTERX(&quot;swissarmyknife&quot;,&quot;Swiss Army Knife&quot;,&quot;Apply operation like P'=P*A, P-A, P+A, etc. using a convolution, rolling average, image from file, or constant&quot;,VF_SWISSARMYKNIFE,1,swissarmyknife_create,swissarmyknife_script);
+	REGISTERX(&quot;threshold&quot;,&quot;Threshold&quot;,&quot;Force too-bright/too-dim pixels to 0 and the rest to 255 or vice-versa&quot;,VF_THRESHOLD,1,threshold_create,threshold_script);
+	REGISTERX(&quot;particlelist&quot;,&quot;Particle List&quot;,&quot;Identify 'particles' (groups of pixels)&quot;,VF_PARTICLELIST,1,particle_create,particle_script);
 
 // Does not work
 //        REGISTERX(&quot;unblend&quot;,&quot;Unblend by Bach&quot;,VF_UNBLEND,1,unblend_create,unblend_script);

Modified: branches/avidemux_2.4_branch/avidemux/ADM_filter/video_filters.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_filter/video_filters.h	2007-08-30 18:42:41 UTC (rev 3574)
+++ branches/avidemux_2.4_branch/avidemux/ADM_filter/video_filters.h	2007-08-31 16:18:20 UTC (rev 3575)
@@ -99,6 +99,10 @@
                 VF_YADIF,
                 VF_DVBSUB,
                 VF_LOGO,
+                VF_COMPUTEAVERAGE,
+                VF_SWISSARMYKNIFE,
+                VF_THRESHOLD,
+                VF_PARTICLELIST,
                 VF_DUMMY,
                 VF_COUNT,
                 MAX_FILTER = VF_COUNT - 1,

Modified: branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_genvideo.hxx
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_genvideo.hxx	2007-08-30 18:42:41 UTC (rev 3574)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_genvideo.hxx	2007-08-31 16:18:20 UTC (rev 3575)
@@ -167,6 +167,7 @@
 
 
 #define GET(x) ADM_assert(couples-&gt;getCouple((char *)#x,&amp;(_param-&gt;x)))
+#define GET2(x,t) (assert(couples-&gt;getCouple((char *)#x,&amp;(t))),(_param-&gt;x)=(t))
 #define CSET(x)  (*couples)-&gt;setCouple((char *)#x,(_param-&gt;x))
 
 #define MPLAYER_RESIZE_PREFFERED

Added: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidComputeAverage.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidComputeAverage.cpp	2007-08-30 18:42:41 UTC (rev 3574)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidComputeAverage.cpp	2007-08-31 16:18:20 UTC (rev 3575)
@@ -0,0 +1,531 @@
+/***************************************************************************
+                          ADM_vidComputeAverage.cpp  -  compute average of
+                                                     all frames (so it can
+                                                     later be subtracted to
+                                                     remove static
+                                                     background details)
+                              -------------------
+                          Chris MacGregor, 2005, 2007
+                         <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">chris-avidemux at bouncingdog.com</A>
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+ 
+ 
+#include &lt;stdio.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;string.h&gt;
+#include &lt;ADM_assert.h&gt;
+#include &lt;math.h&gt;
+
+#include &quot;config.h&quot;
+#include &quot;fourcc.h&quot;
+#include &quot;avio.hxx&quot;
+#include &quot;config.h&quot;
+#include &quot;avi_vars.h&quot;
+
+
+#include &quot;ADM_toolkit/toolkit.hxx&quot;
+#include &quot;ADM_editor/ADM_edit.hxx&quot;
+#include &quot;ADM_video/ADM_genvideo.hxx&quot;
+
+#include &quot;ADM_filter/video_filters.h&quot;
+
+#include &quot;ADM_userInterfaces/ADM_commonUI/DIA_factory.h&quot;
+
+#include &quot;ADM_vidComputeAverage.h&quot;
+
+static FILTER_PARAM computeAverageParam={5,{&quot;start_frame&quot;,
+                                            &quot;end_frame&quot;,
+                                            &quot;output_file&quot;,
+                                            &quot;bias&quot;,
+                                            &quot;display_mode&quot;}};
+
+// This is a hack to work around the fact that the ctor &amp; dtor get called
+// too often.  The right solution would be to arrange for the filter
+// objects to be constructed and destructed only when really necessary:
+// when a new instance of a filter is added to the list (by the user), it
+// is constructed, and when it is removed from the list (by the user), it
+// is destructed, and anything else is handled by a separate init() or
+// configure() method.  This would allow the objects to maintain a
+// persistent state in a more straightforward way.
+
+ADMVideoComputeAverage::PImap ADMVideoComputeAverage::pimap;
+
+
+SCRIPT_CREATE(computeaverage_script,ADMVideoComputeAverage,computeAverageParam);
+
+BUILD_CREATE(computeaverage_create,ADMVideoComputeAverage);
+
+ADMVideoComputeAverage::ADMVideoComputeAverage(AVDMGenericVideoStream *in,CONFcouple *couples)
+			
+{
+    _in=in;
+    memcpy(&amp;_info,in-&gt;getInfo(),sizeof(_info));
+    _info.encoding = 1;	
+    _uncompressed = new ADMImage (_in-&gt;getInfo()-&gt;width,_in-&gt;getInfo()-&gt;height);
+    ADM_assert(_uncompressed);
+    _param=NEW (COMPUTEAVERAGE_PARAM);
+    if (couples)
+    {
+        GET(start_frame);
+        GET(end_frame);
+        char * tmp;
+        GET2(output_file, tmp);
+        GET(bias);
+        GET(display_mode);
+    }
+    else
+    {
+        _param-&gt;start_frame = 1;
+        _param-&gt;end_frame = -1;
+        _param-&gt;output_file = ADM_strdup (&quot;&quot;);
+        _param-&gt;bias = 128;
+        _param-&gt;display_mode = DISPLAYMODE_FRAME_MINUS_AVERAGE;
+    }
+
+    // This is a hack to work around the fact that the ctor &amp; dtor get called
+    // too often.  The right solution would be to arrange for the filter
+    // objects to be constructed and destructed only when really necessary:
+    // when a new instance of a filter is added to the list (by the user), it
+    // is constructed, and when it is removed from the list (by the user), it
+    // is destructed, and anything else is handled by a separate init() or
+    // configure() method.  This would allow the objects to maintain a
+    // persistent state in a more straightforward way.
+
+    // This explicit check wouldn't be necessary if there was an easier way of
+    // ensuring that we got a 0 pointer when a new map entry was auto-consed
+    // up...
+
+    if (pimap.count (couples) == 0)
+    {
+        myInfo = new PersistentInfo;
+        myInfo-&gt;conf = couples;
+        pimap [couples] = myInfo;
+    }
+    else
+    {
+        myInfo = pimap [couples];
+        if (couples)
+        {
+            if (myInfo-&gt;oldConf == couples)
+            {
+                pimap.erase (myInfo-&gt;conf);
+                myInfo-&gt;conf = myInfo-&gt;oldConf;
+                myInfo-&gt;oldConf = 0;
+            }
+            else
+            {
+                ADM_assert (myInfo-&gt;conf == couples);
+
+                if (myInfo-&gt;oldConf)
+                {
+                    pimap.erase (myInfo-&gt;oldConf);
+                    myInfo-&gt;oldConf = 0;
+                }
+            }
+        }
+    }
+
+    myInfo-&gt;refCount++;
+
+    printf (&quot;ADMVideoComputeAverage ctor (%p, conf = %p), pi = %p, rc now %d\n&quot;,
+            this, couples, myInfo, myInfo-&gt;refCount);
+}
+
+uint8_t	ADMVideoComputeAverage::getCoupledConf (CONFcouple **couples)
+{
+
+    ADM_assert(_param);
+    *couples=new CONFcouple(computeAverageParam.nb);
+
+    // This is a hack to work around the fact that the ctor &amp; dtor get called
+    // too often.  The right solution would be to arrange for the filter
+    // objects to be constructed and destructed only when really necessary:
+    // when a new instance of a filter is added to the list (by the user), it
+    // is constructed, and when it is removed from the list (by the user), it
+    // is destructed, and anything else is handled by a separate init() or
+    // configure() method.  This would allow the objects to maintain a
+    // persistent state in a more straightforward way.
+
+    printf(&quot;ADMVideoComputeAverage::getCoupledConf(): this = %p, couples = %p, &quot;
+           &quot;oldConf = %p (was %p), pi = %p\n&quot;,
+           this, *couples, myInfo-&gt;conf, myInfo-&gt;oldConf, myInfo);
+
+    if (myInfo-&gt;oldConf)
+        pimap.erase (myInfo-&gt;oldConf);
+    myInfo-&gt;oldConf = myInfo-&gt;conf;
+    myInfo-&gt;conf = *couples;
+    pimap [myInfo-&gt;conf] = myInfo;
+    if (myInfo-&gt;oldConf == 0)
+        pimap.erase (0);
+
+#define CSET(x)  (*couples)-&gt;setCouple((char *)#x,(_param-&gt;x))
+    CSET(start_frame);
+    CSET(end_frame);
+    CSET(output_file);
+    CSET(bias);
+    CSET(display_mode);
+
+    return 1;
+
+}
+
+uint8_t ADMVideoComputeAverage::configure(AVDMGenericVideoStream *in)
+{
+    UNUSED_ARG(in);
+
+    diaElemInteger start_frame
+        (&amp;(_param-&gt;start_frame),
+         _(&quot;_Start Frame (first frame # to include in average):&quot;),
+         0, 0x7fffffff);
+    diaElemInteger end_frame
+        (&amp;(_param-&gt;end_frame),
+         _(&quot;_End Frame (last frame # to include), -1 = last:&quot;),
+         -1000000, 0x7fffffff);
+    diaElemFile output_file
+        (1, const_cast&lt;char **&gt;(&amp;(_param-&gt;output_file)), _(&quot;_Output File:&quot;));
+    diaElemSlider bias
+        (&amp;(_param-&gt;bias),
+         _(&quot;_Bias (only for display; use 0 for &quot;
+           &quot;average, 128 for frame minus average):&quot;), -256, +256);
+    diaMenuEntry tDisplayMode [] = {
+        { DISPLAYMODE_FRAME_MINUS_AVERAGE,
+          _(&quot;Current frame minus average so far&quot;), NULL },
+        { DISPLAYMODE_AVERAGE, _(&quot;Average so far&quot;), NULL },
+        { DISPLAYMODE_BLANK,
+          _(&quot;Display nothing (fast for batch processing)&quot;), NULL },
+    };
+    diaElemMenu display_mode
+        (&amp;(_param-&gt;display_mode),
+         _(&quot;Display _Mode:&quot;),
+         sizeof (tDisplayMode) / sizeof (diaMenuEntry), tDisplayMode);
+    diaElem * elems[] = { &amp;start_frame, &amp;end_frame, &amp;output_file,
+                          &amp;bias, &amp;display_mode };
+
+    uint8_t ret = diaFactoryRun(&quot;ComputeAverage&quot;, sizeof (elems) / sizeof (diaElem *), elems);
+    return ret;
+	
+}
+
+ADMVideoComputeAverage::~ADMVideoComputeAverage()
+{
+    // This is a hack to work around the fact that the ctor &amp; dtor get called
+    // too often.  The right solution would be to arrange for the filter
+    // objects to be constructed and destructed only when really necessary:
+    // when a new instance of a filter is added to the list (by the user), it
+    // is constructed, and when it is removed from the list (by the user), it
+    // is destructed, and anything else is handled by a separate init() or
+    // configure() method.  This would allow the objects to maintain a
+    // persistent state in a more straightforward way.
+
+    myInfo-&gt;refCount--;
+    printf (&quot;ADMVideoComputeAverage dtor (%p), conf = %p, pi = %p, rc now %d\n&quot;,
+            this, myInfo-&gt;conf, myInfo, myInfo-&gt;refCount);
+
+    if (myInfo-&gt;oldConf)
+    {
+        pimap.erase (myInfo-&gt;oldConf);
+        myInfo-&gt;oldConf = 0;
+    }
+
+    if (myInfo-&gt;refCount &lt; 1)
+    {
+        pimap.erase (myInfo-&gt;conf);
+        delete myInfo;
+    }
+
+    DELETE(_param);
+    delete  _uncompressed;	
+    _uncompressed=NULL;
+}
+
+char * ADMVideoComputeAverage::printConf (void) 
+{
+    const int CONF_LEN = 512;
+    static char conf[CONF_LEN];
+
+    const char * display = &quot;oops&quot;;
+    if (_param-&gt;display_mode == DISPLAYMODE_AVERAGE)
+        display = &quot;average so far&quot;;
+    else if (_param-&gt;display_mode == DISPLAYMODE_FRAME_MINUS_AVERAGE)
+        display = &quot;current frame minus average so far&quot;;
+    else if (_param-&gt;display_mode == DISPLAYMODE_BLANK)
+        display = &quot;nothing (fast)&quot;;
+
+    snprintf(conf, CONF_LEN, &quot;ComputeAverage: Average of frames %d - %d, &quot;
+             &quot;output to %s, display %s %+d&quot;,
+             _param-&gt;start_frame, _param-&gt;end_frame, _param-&gt;output_file,
+             display, _param-&gt;bias);
+    return conf;
+	
+}
+
+static inline
+uint8_t saturate_pixel (uint32_t pixel)
+{
+    if (pixel &amp; 0xffffff00)
+    {
+        if (int32_t (pixel) &lt; 0)
+            return 0;
+        else // if (pixel &gt; 255)
+            return 255;
+    }
+
+    return pixel;
+}
+
+uint8_t ADMVideoComputeAverage::getFrameNumberNoAlloc (uint32_t frame, uint32_t *len,
+                                                       ADMImage *data, uint32_t *flags)
+{
+    if (frame &gt;= _info.nb_frames)
+        return 0;
+
+    int debug = 0;
+
+    int curr_frame = frame + _info.orgFrame;
+    int num_frames = _info.nb_frames + _info.orgFrame;
+
+    int planesize = _info.width * _info.height;
+    uint32_t size = (planesize * 3) &gt;&gt; 1;
+    *len = size;
+			
+    if (!_in-&gt;getFrameNumberNoAlloc (frame, len, _uncompressed, flags))
+        return 0;
+    ADMImage * image = _uncompressed;
+
+    uint32_t start_frame = _param-&gt;start_frame - 1;
+    uint32_t end_frame = _param-&gt;end_frame;
+    if (int32_t (end_frame) &lt; 0)
+        end_frame = int32_t (num_frames) + int32_t (end_frame); // 0-based, thus -1 = last frame
+    else
+        --end_frame;
+
+    if (!myInfo-&gt;sums
+        || myInfo-&gt;width != _info.width || myInfo-&gt;height != _info.height
+        || myInfo-&gt;start_frame != start_frame
+        || myInfo-&gt;end_frame != end_frame)
+    {
+        printf (&quot;ADMVideoComputeAverage: resetting; was %p %ux%u, %u..%u\n&quot;,
+                myInfo-&gt;sums, myInfo-&gt;width, myInfo-&gt;height,
+                myInfo-&gt;start_frame, myInfo-&gt;end_frame);
+
+        if (!myInfo-&gt;sums
+            || myInfo-&gt;width != _info.width || myInfo-&gt;height != _info.height)
+        {
+            myInfo-&gt;width = _info.width;
+            myInfo-&gt;height = _info.height;
+            delete[] myInfo-&gt;sums;
+            myInfo-&gt;sums = new uint32_t [planesize];
+        }
+
+        uint32_t pixremaining = planesize + 1;
+        uint32_t * sums = myInfo-&gt;sums + planesize;
+        while (--pixremaining)
+        {
+            *--sums = 0;
+        }
+
+        myInfo-&gt;frame_count = 0;
+        myInfo-&gt;most_recent_frame = -1;
+        myInfo-&gt;start_frame = start_frame;
+        myInfo-&gt;end_frame = end_frame;
+
+        printf (&quot;ADMVideoComputeAverage: reset average; now %p %ux%u, &quot;
+                &quot;%u..%u\n&quot;,
+                myInfo-&gt;sums, myInfo-&gt;width, myInfo-&gt;height,
+                myInfo-&gt;start_frame, myInfo-&gt;end_frame);
+    }
+			
+    // HERE: for speed, we do luma (Y plane) only.  However, some
+    // users might want chroma, too... we should make that
+    // an option or something.
+
+    uint8_t * currp = YPLANE (image) + planesize;
+    uint8_t * destp = YPLANE (data) + planesize;
+    uint32_t * sums = myInfo-&gt;sums + planesize;
+    uint32_t pixremaining = planesize + 1;
+    int32_t bias = _param-&gt;bias;
+
+    if (curr_frame &gt;= start_frame &amp;&amp; curr_frame &lt;= end_frame
+        &amp;&amp; curr_frame != myInfo-&gt;most_recent_frame)
+    {
+        uint32_t frame_count = ++(myInfo-&gt;frame_count);
+        uint32_t half_frame_count = frame_count / 2;
+        if (debug &amp; 2)
+            printf (&quot;Including frame %u of %u, now have %u (%u - %u)\n&quot;,
+                    curr_frame + 1, num_frames, frame_count, start_frame, end_frame);
+
+        if (_param-&gt;display_mode == DISPLAYMODE_AVERAGE)
+        {
+            while (--pixremaining)
+            {
+                uint8_t curr = *--currp;
+                uint32_t sum = (*--sums += curr);
+
+                uint32_t avg = (sum + half_frame_count) / frame_count;
+                *--destp = saturate_pixel (avg + bias);
+            }
+        }
+        else if (_param-&gt;display_mode == DISPLAYMODE_FRAME_MINUS_AVERAGE)
+        {
+            while (--pixremaining)
+            {
+                uint8_t curr = *--currp;
+                uint32_t sum = (*--sums += curr);
+
+                uint32_t avg = (sum + half_frame_count) / frame_count;
+                *--destp = saturate_pixel (curr + bias - avg);
+            }
+        }
+        else // if (_param-&gt;display_mode == DISPLAYMODE_BLANK)
+        {
+            while (--pixremaining)
+            {
+                *--sums += *--currp;
+            }
+        }
+
+        myInfo-&gt;most_recent_frame = curr_frame;
+
+        // If we just did the last frame of the specified range, then we need
+        // to write the output file.
+
+        if (curr_frame == end_frame
+            &amp;&amp; frame_count == end_frame - start_frame + 1)
+            write_output_file();
+    }
+    else // frame out of specified range for collecting average
+    {
+        uint32_t frame_count = myInfo-&gt;frame_count;
+        uint32_t half_frame_count = frame_count / 2;
+        if (debug &amp; 2)
+            printf (&quot;Using %u frame(s) (%u - %u) worth of average on frame %u of %u\n&quot;,
+                    frame_count, start_frame, end_frame, curr_frame + 1, num_frames);
+
+        if (frame_count == 0)
+        {
+            // dividing by zero is not a good idea.  Just punt.
+            return 0;
+        }
+        else if (_param-&gt;display_mode == DISPLAYMODE_AVERAGE)
+        {
+            while (--pixremaining)
+            {
+                uint32_t sum = *--sums;
+                uint32_t avg = (sum + half_frame_count) / frame_count;
+                *--destp = saturate_pixel (avg + bias);
+            }
+        }
+        else if (_param-&gt;display_mode == DISPLAYMODE_FRAME_MINUS_AVERAGE)
+        {
+            while (--pixremaining)
+            {
+                uint8_t curr = *--currp;
+                uint32_t sum = *--sums;
+
+                uint32_t avg = (sum + half_frame_count) / frame_count;
+                *--destp = saturate_pixel (curr + bias - avg);
+            }
+        }
+        else if (curr_frame &gt; end_frame)
+        {
+            // nothing more to do
+            return 0;
+        }
+    }
+
+    if (_param-&gt;display_mode != DISPLAYMODE_BLANK)
+    {
+        // HERE: the following two lines do a luma-only-ize
+
+        memset (UPLANE (data), 128, planesize &gt;&gt; 2);
+        memset (VPLANE (data), 128, planesize &gt;&gt; 2);
+    }
+
+    data-&gt;copyInfo(image);
+    return 1;
+}
+
+void ADMVideoComputeAverage::write_output_file () const
+{
+    const char * output_file = _param-&gt;output_file;
+    if (!output_file || !*output_file)
+    {
+        printf (&quot;ADMVideoComputeAverage: Wanted to write output file, but &quot;
+                &quot;no file has been specified!!\n&quot;);
+        return;
+    }
+
+    FILE * fp = fopen (output_file, &quot;wb&quot;);
+    if (!fp)
+    {
+        perror (output_file);
+        return;
+    }
+
+    uint32_t width = myInfo-&gt;width;
+    uint32_t height = myInfo-&gt;height;
+
+    int pixelcount = width * height;
+    uint32_t * sums = myInfo-&gt;sums;
+    uint32_t pixremaining = pixelcount + 1;
+
+    FileHeader header;
+    memcpy (header.magic, &quot;DGCMimgF&quot;, sizeof (header.magic));
+    header.width = width;
+    header.height = height;
+
+    int nwritten = fwrite (&amp;header, sizeof (FileHeader), 1, fp);
+    if (nwritten != 1)
+    {
+        printf (&quot;Failed to write file header to %s\n&quot;, output_file);
+        fflush (stdout);
+        perror (output_file);
+        fclose (fp);
+        unlink (output_file);
+        return;
+    }
+
+    uint32_t frame_count = myInfo-&gt;frame_count;
+
+    printf (&quot;frame count = %u\n&quot;, frame_count);
+
+    float minavg = 1000;
+    float maxavg = -1000;
+    while (--pixremaining)
+    {
+        uint32_t sum = *sums++;
+        float avg = float (sum) / frame_count;
+
+        if (avg &lt; minavg)
+            minavg = avg;
+        if (avg &gt; maxavg)
+            maxavg = avg;
+
+        nwritten = fwrite (&amp;avg, sizeof (float), 1, fp);
+        if (nwritten != 1)
+        {
+            printf (&quot;Failed to write pixel %u to %s\n&quot;,
+                    pixelcount - pixremaining + 1, output_file);
+            fflush (stdout);
+            perror (output_file);
+            fclose (fp);
+            unlink (output_file);
+            return;
+        }
+    }
+
+    printf (&quot;Successfully wrote %ux%u = %u floating point pixel averages &quot;
+            &quot;(from %.6f to %.6f) of %u frames to %s\n&quot;,
+            width, height, pixelcount, minavg, maxavg, frame_count, output_file);
+
+    fclose (fp);
+}

Added: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidComputeAverage.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidComputeAverage.h	2007-08-30 18:42:41 UTC (rev 3574)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidComputeAverage.h	2007-08-31 16:18:20 UTC (rev 3575)
@@ -0,0 +1,125 @@
+/***************************************************************************
+                          ADM_vidComputeAverage.h  -  compute average of
+                                                     all frames (so it can
+                                                     later be subtracted to
+                                                     remove static
+                                                     background details)
+                              -------------------
+                          Chris MacGregor, 2005, 2007
+                         <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">chris-avidemux at bouncingdog.com</A>
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+ 
+#ifndef __COMPUTEAVERAGE__
+#define __COMPUTEAVERAGE__   
+
+#include &lt;map&gt;
+
+#include &quot;ADM_video/ADM_cache.h&quot;
+
+typedef struct COMPUTEAVERAGE_PARAM
+{
+    int32_t start_frame;
+    int32_t end_frame; // -1 means last frame, -2 = last - 1, ...
+    const char * output_file;
+    int32_t bias;
+    uint32_t display_mode;
+
+} COMPUTEAVERAGE_PARAM;
+
+class  ADMVideoComputeAverage : public AVDMGenericVideoStream
+{
+
+    enum DisplayMode
+    {
+        DISPLAYMODE_INVALID = 0,
+        DISPLAYMODE_FRAME_MINUS_AVERAGE,
+        DISPLAYMODE_AVERAGE,
+        DISPLAYMODE_BLANK,
+        DISPLAYMODE_COUNT
+    };
+
+ public:
+
+    struct FileHeader
+    {
+        char magic [8]; // &quot;DGCMimg&quot; + (is_float ? &quot;F&quot; : &quot;8&quot;)
+        uint32_t width;
+        uint32_t height;
+    };
+        
+
+ protected:
+
+     // This is a hack to work around the fact that the ctor &amp; dtor get called
+     // too often.  The right solution would be to arrange for the filter
+     // objects to be constructed and destructed only when really necessary:
+     // when a new instance of a filter is added to the list (by the user), it
+     // is constructed, and when it is removed from the list (by the user), it
+     // is destructed, and anything else is handled by a separate init() or
+     // configure() method.  This would allow the objects to maintain a
+     // persistent state in a more straightforward way.
+
+     class PersistentInfo
+     {
+     public:
+         CONFcouple *  conf;
+         CONFcouple *  oldConf;
+         uint32_t      refCount;
+
+         uint32_t *    sums;
+         uint32_t      frame_count;
+         uint32_t      width;
+         uint32_t      height;
+         uint32_t      start_frame;
+         uint32_t      end_frame;
+         uint32_t      most_recent_frame;
+
+         PersistentInfo ()
+             : conf (0),
+               oldConf (0),
+               refCount (0),
+
+               sums (0),
+               frame_count (0),
+               width (0),
+               height (0),
+               start_frame (0),
+               end_frame (0),
+               most_recent_frame (0)
+         {
+         }
+     };
+
+     typedef std::map &lt;CONFcouple *, PersistentInfo *&gt; PImap;
+     static PImap pimap;
+
+     PersistentInfo * myInfo;
+
+     COMPUTEAVERAGE_PARAM *  _param;
+
+     void write_output_file () const;
+
+ public:
+ 		
+     ADMVideoComputeAverage (AVDMGenericVideoStream *in, CONFcouple *setup);
+
+     ~ADMVideoComputeAverage();
+
+     virtual uint8_t getFrameNumberNoAlloc (uint32_t frame, uint32_t *len,
+                                            ADMImage *data, uint32_t *flags);
+
+     virtual uint8_t configure (AVDMGenericVideoStream *instream);
+     virtual char * printConf (void);
+     virtual uint8_t getCoupledConf (CONFcouple **couples);
+							
+ };
+#endif

Added: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidParticle.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidParticle.cpp	2007-08-30 18:42:41 UTC (rev 3574)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidParticle.cpp	2007-08-31 16:18:20 UTC (rev 3575)
@@ -0,0 +1,738 @@
+/***************************************************************************
+                          ADM_vidParticle.cpp  -  detect particles (groups
+                                                     of pixels)
+                              -------------------
+                          Chris MacGregor, 2005, 2007
+                         <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">chris-avidemux at bouncingdog.com</A>
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+ 
+ 
+#include &lt;stdio.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;string.h&gt;
+#include &lt;ADM_assert.h&gt;
+#include &lt;math.h&gt;
+
+#include &quot;config.h&quot;
+#include &quot;fourcc.h&quot;
+#include &quot;avio.hxx&quot;
+#include &quot;config.h&quot;
+#include &quot;avi_vars.h&quot;
+
+
+#include &quot;ADM_toolkit/toolkit.hxx&quot;
+#include &quot;ADM_editor/ADM_edit.hxx&quot;
+#include &quot;ADM_video/ADM_genvideo.hxx&quot;
+
+#include &quot;ADM_encoder/ADM_vidEncode.hxx&quot;
+#include &quot;ADM_encoder/adm_encoder.h&quot;
+
+#include &quot;ADM_filter/video_filters.h&quot;
+
+#include &quot;ADM_userInterfaces/ADM_commonUI/DIA_factory.h&quot;
+
+#include &quot;ADM_vidParticle.h&quot;
+
+FILE * ADMVideoParticle::outfp = 0;
+uint32_t ADMVideoParticle::last_frame_written = 0xffffffff;
+
+static FILTER_PARAM particleParam =
+{
+    10,
+    { &quot;min_area&quot;, &quot;max_area&quot;, &quot;left_crop&quot;, &quot;right_crop&quot;,          // 4
+      &quot;top_crop&quot;, &quot;bottom_crop&quot;, &quot;output_format&quot;, &quot;output_file&quot;,  // + 4 = 8
+      &quot;camera_number&quot;, &quot;debug&quot;                                    // + 2 = 10
+    }
+};
+
+SCRIPT_CREATE(particle_script,ADMVideoParticle,particleParam);
+
+BUILD_CREATE(particle_create,ADMVideoParticle);
+
+ADMVideoParticle::ADMVideoParticle (AVDMGenericVideoStream *in, CONFcouple *couples)
+{
+    printf (&quot;ADMVideoParticle ctor (%p)\n&quot;, this);
+    _in = in;
+    memcpy(&amp;_info, in-&gt;getInfo(), sizeof(_info));
+    _info.encoding = 1;
+    _uncompressed = new ADMImage(_in-&gt;getInfo()-&gt;width, _in-&gt;getInfo()-&gt;height);
+    ADM_assert(_uncompressed);
+    _param = NEW(PARTICLE_PARAM);
+
+    if (couples)
+    {
+        GET(min_area);
+        GET(max_area);
+        GET(left_crop);
+        GET(right_crop);
+        GET(top_crop);
+        GET(bottom_crop);
+        GET(output_format);
+
+        char * tmp;
+        GET2(output_file, tmp);
+        GET(camera_number);
+        GET(debug);
+    }
+    else
+    {
+        _param-&gt;min_area = 5;
+        _param-&gt;max_area = 50000;
+        _param-&gt;left_crop = 0;
+        _param-&gt;right_crop = 0;
+        _param-&gt;top_crop = 0;
+        _param-&gt;bottom_crop = 0;
+        _param-&gt;output_format = OUTPUTFMT_FORMAT_NEW;
+        _param-&gt;output_file = ADM_strdup (&quot;&quot;);
+        _param-&gt;camera_number = 1;
+        _param-&gt;debug = 0;
+    }
+}
+
+uint8_t	ADMVideoParticle::getCoupledConf (CONFcouple **couples)
+{
+
+    ADM_assert(_param);
+    *couples = new CONFcouple(particleParam.nb);
+
+#define CSET(x)  (*couples)-&gt;setCouple((char *)#x,(_param-&gt;x))
+    CSET(min_area);
+    CSET(max_area);
+    CSET(left_crop);
+    CSET(right_crop);
+    CSET(top_crop);
+    CSET(bottom_crop);
+    CSET(output_format);
+    CSET(output_file);
+    CSET(camera_number);
+    CSET(debug);
+
+    return 1;
+
+}
+
+uint8_t ADMVideoParticle::configure(AVDMGenericVideoStream *in)
+{
+    UNUSED_ARG(in);
+
+    diaElemUInteger min_area
+        (&amp;(_param-&gt;min_area),
+         _(&quot;Mi_nimum area for a particle to be detected:&quot;), 1, 0x7fffffff);
+    diaElemUInteger max_area
+        (&amp;(_param-&gt;max_area),
+         _(&quot;Ma_ximum area for a particle to be detected:&quot;), 1, 0x7fffffff);
+
+    diaElemUInteger left_crop
+        (&amp;(_param-&gt;left_crop),
+         _(&quot;_Left side crop (ignore particles in):&quot;), 0, 0x7fffffff);
+    diaElemUInteger right_crop
+        (&amp;(_param-&gt;right_crop),
+         _(&quot;_Right side crop (ignore particles in):&quot;), 0, 0x7fffffff);
+    diaElemUInteger top_crop
+        (&amp;(_param-&gt;top_crop),
+         _(&quot;_Top crop (ignore particles in):&quot;), 0, 0x7fffffff);
+    diaElemUInteger bottom_crop
+        (&amp;(_param-&gt;bottom_crop),
+         _(&quot;_Bottom crop (ignore particles in):&quot;), 0, 0x7fffffff);
+
+    diaMenuEntry tOutputFmt [] = {
+        { OUTPUTFMT_FORMAT_NEW,
+          _(&quot;New format, preferred, good for Tracker3D&quot;), NULL },
+        { OUTPUTFMT_FORMAT_OLD,
+          _(&quot;Old format that Tracker3D can't read directly&quot;), NULL },
+    };
+
+    diaElemMenu output_format
+        (&amp;(_param-&gt;output_format), _(&quot;_Output Format:&quot;),
+         sizeof (tOutputFmt) / sizeof (diaMenuEntry), tOutputFmt);
+
+    diaElemFile output_file
+        (1, const_cast&lt;char **&gt;(&amp;(_param-&gt;output_file)), _(&quot;_Output File:&quot;));
+
+    diaElemUInteger camera_number
+        (&amp;(_param-&gt;camera_number), _(&quot;_Camera number:&quot;), 1, 0x7fffffff);
+
+    diaElemUInteger debug(&amp;(_param-&gt;debug), _(&quot;_Debugging settings (bits):&quot;),
+                          0, 0x7fffffff);
+
+    diaElem * elems[] = { &amp;min_area, &amp;max_area, &amp;left_crop, &amp;right_crop,
+                          &amp;top_crop, &amp;bottom_crop, &amp;output_format,
+                          &amp;output_file, &amp;camera_number, &amp;debug };
+
+    uint8_t ret = diaFactoryRun(&quot;Particle&quot;, sizeof (elems) / sizeof (diaElem *), elems);
+    return ret;
+	
+}
+
+ADMVideoParticle::~ADMVideoParticle()
+{
+    printf (&quot;ADMVideoParticle dtor (%p)\n&quot;, this);
+    DELETE(_param);
+    delete _uncompressed;
+    _uncompressed = NULL;
+}
+
+char *ADMVideoParticle::printConf (void)
+{
+    const int CONF_LEN = 1024;
+    static char conf[CONF_LEN];
+
+    char * cptr = conf;
+
+    cptr += snprintf (conf, CONF_LEN, &quot;ParticleList: Area=%u..%u&quot;,
+                      _param-&gt;min_area, _param-&gt;max_area);
+
+    if (_param-&gt;left_crop || _param-&gt;right_crop || _param-&gt;top_crop
+        || _param-&gt;bottom_crop)
+    {
+        cptr += snprintf (cptr, CONF_LEN - (cptr - conf),
+                          &quot;, Crop (L/R/T/B): %u/%u/%u/%u&quot;,
+                          _param-&gt;left_crop, _param-&gt;right_crop,
+                          _param-&gt;top_crop, _param-&gt;bottom_crop);
+    }
+
+    if (_param-&gt;output_file &amp;&amp; _param-&gt;output_file[0])
+    {
+        cptr += snprintf (cptr, CONF_LEN - (cptr - conf), &quot;, %s Output to %s&quot;,
+                          _param-&gt;output_format == OUTPUTFMT_FORMAT_OLD
+                          ? &quot;Old&quot; : &quot;New&quot;, _param-&gt;output_file);
+    }
+
+    cptr += snprintf (cptr, CONF_LEN - (cptr - conf), &quot;, Camera # %u&quot;,
+                      _param-&gt;camera_number);
+
+    if (_param-&gt;debug)
+        cptr += snprintf (cptr, CONF_LEN - (cptr - conf),
+                          &quot;, debug=0x%x&quot;, _param-&gt;debug);
+
+    return conf;
+}
+
+uint8_t ADMVideoParticle::getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
+                                                ADMImage *data, uint32_t *flags)
+{
+    if (frame &gt;= _info.nb_frames)
+        return 0;
+
+    uint32_t real_frame = frame + _info.orgFrame;
+
+    uint32_t debug = _param-&gt;debug;
+
+    if (debug &amp; 1)
+        printf (&quot;in ADMVideoParticle::getFrameNumberNoAlloc(%d, ...)\n&quot;, frame);
+
+    uint32_t w = _info.width;
+    uint32_t h = _info.height;
+    uint32_t planesize = w * h;
+    uint32_t uvplanesize = planesize &gt;&gt; 2;
+    uint32_t size = planesize + (uvplanesize * 2);
+    *len = size;
+			
+    if (!_in-&gt;getFrameNumberNoAlloc (frame, len, _uncompressed, flags))
+        return 0;
+    ADMImage * image = _uncompressed;
+
+    memset (UPLANE (data), 128, uvplanesize);
+    memset (VPLANE (data), 128, uvplanesize);
+    memset (YPLANE (data), 0, planesize);
+
+    // HERE: we should erase anything outside the ROI (region of interest),
+    // unless we decide to handle that some other way and/or place...
+
+    uint8_t * imagePixels = YPLANE (image);
+    ImageTool imtool (imagePixels, w, h, data);
+    imtool.setDebug (debug);
+    imtool.setMinArea (_param-&gt;min_area);
+    imtool.setMaxArea (_param-&gt;max_area);
+    static uint32_t particleNum = 0;
+
+    OutputFmt outfmt = static_cast &lt;OutputFmt&gt; (_param-&gt;output_format);
+    uint32_t camera_number = _param-&gt;camera_number;
+
+    if (!outfp &amp;&amp; real_frame == 0
+        &amp;&amp; _param-&gt;output_file &amp;&amp; _param-&gt;output_file[0])
+    {
+        printf (&quot;Preparing to write particle list to %s\n&quot;,
+                _param-&gt;output_file);
+
+        outfp = fopen (_param-&gt;output_file, &quot;w&quot;);
+        if (!outfp)
+        {
+            perror (_param-&gt;output_file);
+        }
+        else if (real_frame == 0) // ick
+        {
+            if (outfmt == OUTPUTFMT_FORMAT_NEW)
+                fprintf (outfp, &quot;%% Frame  Camera  X  Y  Area  Particle\n&quot;);
+            else
+                fprintf (outfp, &quot;%% Particle  Area  X  Y  Frame\n&quot;);
+        }
+    }
+
+    for (uint32_t y = 0; y &lt; h; y++)
+    {
+        uint8_t * pixelrow = imagePixels + (y * w);
+        for (uint32_t x = 0; x &lt; w; x++)
+        {
+            if (imtool.goodPixel (pixelrow [x]))
+            {
+                if (imtool.autoOutline (x, y) == 0)
+                    continue;
+
+                uint32_t area = imtool.particleArea();
+                float centroid_x = imtool.particleCentroidX();
+                float centroid_y = imtool.particleCentroidY();
+                if (debug &amp; 0x01)
+                    printf (&quot;%d %d %.6f %.6f %d\n&quot;,
+                            ++particleNum, area, centroid_x, centroid_y,
+                            real_frame + 1);
+
+                if (!outfp || last_frame_written == real_frame)
+                    continue;
+
+                if (outfmt == OUTPUTFMT_FORMAT_NEW)
+                {
+                    fprintf (outfp, &quot;%d %d %.6f %.6f %d %d\n&quot;,
+                             real_frame + 1, camera_number, centroid_x, centroid_y,
+                             area, ++particleNum);
+                }
+                else
+                {
+                    fprintf (outfp, &quot;%d %d %.6f %.6f %d\n&quot;,
+                             ++particleNum, area, centroid_x, centroid_y,
+                             real_frame + 1);
+                }
+            }
+        }
+    }
+
+    last_frame_written = real_frame;
+
+    if (outfp &amp;&amp; real_frame &gt;= _info.nb_frames + _info.orgFrame - 1)
+    {
+        fclose (outfp);
+        outfp = 0;
+        printf (&quot;Finished writing particle list to %s\n&quot;,
+                _param-&gt;output_file);
+    }
+
+    data-&gt;copyInfo(image);
+    return 1;
+}	                           
+
+//////////////////////////////////////////////////////////////////////////////
+
+char ImageTool::directionLetters [] = &quot;ESWN#?&quot;;
+
+PixelOffset ImageTool::leftOffset [ImageTool::DIRECTION_COUNT] =
+{
+//     East         South        West         North
+    {  0, -1 },  {  1,  0 },  {  0,  1 },  { -1,  0 }
+};
+
+// Interesting - aheadOffset [n] == leftOffset [(n + 1) % DIRECTION_COUNT]...
+PixelOffset ImageTool::aheadOffset [ImageTool::DIRECTION_COUNT] =
+{
+//     East         South        West         North
+    {  1,  0 },  {  0,  1 },  { -1,  0 },  {  0, -1 }
+};
+
+// If we're using 4-connectedness (current implementation), then the following
+// would be treated as two independent particles; with 8-connectedness, this
+// would be a single particle with some &quot;holes&quot; in it.
+
+// . . . * * . . .
+// . . * * * . . .
+// . * * * . * . .
+// . * * * . * * .
+// * * * . * * * .
+// * * . * * * * .
+// . * . * * * . .
+// . . . * . . . .
+
+
+uint8_t ImageTool::autoOutline (uint32_t x, uint32_t y)
+{
+    pixelList.clear();
+
+    if (debug &amp; 0x02)
+        printf (&quot;autoOutline(%d,%d):&quot;, x, y);
+
+    ADM_assert (goodPixel (x, y));
+
+    uint32_t startingX = x;
+    uint32_t startingY = y;
+
+    TracingDirection direction = DIRECTION_COUNT; // deliberately invalid
+    TracingDirection newDirection = DIRECTION_EAST;
+
+    int8_t
+        Lx, Ly,  // left
+        Ax, Ay;  // ahead
+
+#if 0
+    uint32_t prevX;
+    uint32_t prevY;
+    TracingDirection startingDirection = direction;
+#endif
+
+    uint32_t pointCount = 0;
+    uint32_t pointMax = my_w * my_h; // more than that and something is wrong
+
+    do
+    {
+#if 0
+        prevX = x;
+        prevY = y;
+#endif
+
+        pixelList.push_back (PixelLoc (x, y));
+        if (debug &amp; 0x04)
+            printf (&quot; %c(%d,%d)%c&quot;, directionLetters [direction],
+                    x, y, directionLetters [newDirection]);
+
+        if (++pointCount &gt;= pointMax)
+        {
+            printf (&quot;\nUh oh!  Too many points!! (%d) (@(%d,%d), dir %c)\n&quot;,
+                    pointCount, x, y, directionLetters [direction]);
+            showStuff();
+            break;
+        }
+
+        if (newDirection != direction)
+        {
+            direction = newDirection;
+            Lx = leftOffset [direction].x;
+            Ly = leftOffset [direction].y;
+            Ax = aheadOffset [direction].x;
+            Ay = aheadOffset [direction].y;
+#define ARx (Ax + Rx)
+#define ARy (Ay + Ry)
+#define Rx  (-Lx)
+#define Ry  (-Ly)
+#define BRx (Bx + Rx)
+#define BRy (By + Ry)
+#define Bx  (-Ax)
+#define By  (-Ay)
+#define BLx (Bx + Lx)
+#define BLy (By + Ly)
+        }
+
+        if (goodPixel (x + Lx, y + Ly))
+        {
+            // Turn left
+            x += Lx;
+            y += Ly;
+            newDirection = TracingDirection ((direction + TURN_LEFT)
+                                             % DIRECTION_COUNT);
+        }
+        else if (goodPixel (x + Ax, y + Ay))
+        {
+            // Continue in same direction
+            x += Ax;
+            y += Ay;
+            // newDirection = direction;
+        }
+        else if (goodPixel (x + Rx, y + Ry))
+        {
+            // Turn right
+            x += Rx;
+            y += Ry;
+            newDirection = TracingDirection ((direction + TURN_RIGHT)
+                                             % DIRECTION_COUNT);
+        }
+#if 0
+// if we turn this on, we probably ought to be looking at the AL pixel as
+// well.  (And turn on the BR case, below?)
+
+        else if (goodPixel (x + ARx, y + ARy))
+        {
+            // Slide down one pixel and continue
+            do that!;
+        }
+#endif
+        else if (goodPixel (x + Bx, y + By))
+        {
+            // Turn around (reverse direction)
+            x += Bx;
+            y += By;
+            newDirection = TracingDirection ((direction + TURN_AROUND)
+                                             % DIRECTION_COUNT);
+        }
+#if 0
+        else if (goodPixel (x + BRx, y + BRy))
+        {
+            // Slide down one pixel and turn right
+            do that (the slide)!;
+            newDirection = TracingDirection ((direction + TURN_RIGHT)
+                                             % DIRECTION_COUNT);
+        }
+#endif
+        else
+        {
+            // Apparently there is nowhere to go.  This should happen only if
+            // we're looking at an isolated pixel (a one-pixel particle).
+
+            if (pixelList.size() &gt; 1)
+            {
+                printf (&quot;\nUh oh!  We're stuck, but it's not a lonely pixel!  &quot;
+                        &quot;(@(%d,%d), dir %c)\n&quot;,
+                        x, y, directionLetters [direction]);
+                showStuff();
+                ADM_assert (pixelList.size() &gt; 1);
+            }
+
+            break; // we'd fall out anyway, but this is faster &amp; more explicit
+        }
+
+    } while (x != startingX || y != startingY);
+
+    if (debug &amp; 0x02)
+        printf (&quot; done! %d points in all\n&quot;, pixelList.size());
+
+    // HERE: if we moved this to below the loop that does the centroid, etc.,
+    // then we could show that info and also the fill-in of the particle,
+    // based on reading the output image (if it exists).
+
+    if (debug &amp; 0x08)
+        showStuff();
+
+    // We now do 4 things in one pass: 1. count the pixels in the particle
+    // (thus computing the area, defined as the number of pixels in the
+    // particle); 2. clear those pixels in the input image so that we don't
+    // count the particle more than once; 3. compute the centroid (defined as
+    // the point whose x is the average of all the x's in the particle, and
+    // whose y is the average of all the y's in particle); 4. if there is an
+    // output image, draw the particle in the output, with the outline
+    // highlighted.
+
+    my_particleArea = 0;
+    my_particleCentroidX = 0;
+    my_particleCentroidY = 0;
+
+    uint32_t sumOfXs = 0;
+    uint32_t sumOfYs = 0;
+    uint32_t count = 0;
+
+    PixelList::iterator plit = pixelList.begin();
+    while (plit != pixelList.end())
+    {
+        uint32_t px = plit-&gt;x;
+        uint32_t py = plit-&gt;y;
+
+        ++plit;
+
+        if (my_outImage)
+        {
+            outPixel (px, py) = 255;
+#ifdef USE_COLOR_IN_OUTPUT
+            outUPixel (px, py) = 0;
+            outVPixel (px, py) = 0;
+#endif
+        }
+
+        // We do the above (set up output pixels) first so we ensure that the
+        // outline is highlighted even if the code below has already displayed
+        // some of the pixels in the outline (due to direct or indirect
+        // adjacency to other outline pixels).
+
+        if (getPixel (px, py) == 0)
+            continue;
+
+        // If we're still here, then this pixel is part of the particle but
+        // has not yet been counted or otherwise processed.  There may be
+        // other horizontally adjacent pixels, as well, which we will also
+        // process now, if they are present - this accomplishes &quot;filling&quot; the
+        // particle outline (except that any pixels that were actually not
+        // &quot;on&quot; in the particle will be ignored).
+
+        // First, we process the pixel itself, and any pixels to the right of
+        // it (if they are on).
+
+        uint32_t startX = px;
+
+        count++;
+        sumOfXs += px;
+        sumOfYs += py;
+        getPixel (px, py) = 0; // erase to prevent being counted again
+
+        while (goodPixel (++px, py))
+        {
+            count++;
+            sumOfXs += px;
+            sumOfYs += py;
+            getPixel (px, py) = 0; // erase to prevent being counted again
+            if (my_outImage)
+                outPixel (px, py) = 128;
+        }
+
+        // Now, we process any pixels to the left of the original one (if they
+        // are on).
+
+        px = startX;
+        while (goodPixel (--px, py))
+        {
+            count++;
+            sumOfXs += px;
+            sumOfYs += py;
+            getPixel (px, py) = 0; // erase to prevent being counted again
+            if (my_outImage)
+                outPixel (px, py) = 128;
+        }
+    }
+
+    my_particleArea = count;
+
+    if (my_particleArea &lt; my_minArea || my_particleArea &gt; my_maxArea)
+    {
+        if (my_outImage)
+        {
+            // We need to erase the particle we just drew. :-(
+
+            plit = pixelList.begin();
+            while (plit != pixelList.end())
+            {
+                uint32_t px = plit-&gt;x;
+                uint32_t py = plit-&gt;y;
+
+                ++plit;
+
+                // First, we erase the pixel itself, and any pixels to the right of
+                // it (if they are on).
+
+                uint32_t startX = px;
+
+                while (validPixel (px, py) &amp;&amp; outPixel (px, py))
+                    outPixel (px++, py) = 0;
+
+                // Now, we process any pixels to the left of the original one (if they
+                // are on).
+
+                px = startX;
+                while (validPixel (--px, py) &amp;&amp; outPixel (px, py))
+                    outPixel (px, py) = 0;
+            }
+        }
+
+        return 0;
+    }
+
+    my_particleCentroidX = float (sumOfXs) / count;
+    my_particleCentroidY = float (sumOfYs) / count;
+
+    if (my_outImage)
+    {
+        uint32_t px = static_cast &lt;uint32_t&gt; (nearbyintf (my_particleCentroidX));
+        uint32_t py = static_cast &lt;uint32_t&gt; (nearbyintf (my_particleCentroidY));
+        if (validPixel (px, py))
+            outPixel (px, py) = 255;
+        else
+            printf (&quot;################# Uh oh, about to stomp invalid centroid pixel (%d, %d)!!\n&quot;,
+                    px, py);
+#ifdef USE_COLOR_IN_OUTPUT
+        outUPixel (px, py) = 255;
+        outVPixel (px, py) = 255;
+#endif
+    }
+
+    return 1;
+}
+
+void ImageTool::showStuff () const
+{
+    uint32_t minx = 0xffffffff;
+    uint32_t miny = 0xffffffff;
+    uint32_t maxx = 0;
+    uint32_t maxy = 0;
+
+    PixelList::const_iterator plit = pixelList.begin();
+    while (plit != pixelList.end())
+    {
+        uint32_t px = plit-&gt;x;
+        uint32_t py = plit-&gt;y;
+
+        if (px &lt; minx)
+            minx = px;
+        if (px &gt; maxx)
+            maxx = px;
+        if (py &lt; miny)
+            miny = py;
+        if (py &gt; maxy)
+            maxy = py;
+
+        ++plit;
+    }
+
+    minx -= (minx &gt; 0);
+    miny -= (miny &gt; 0);
+    maxx += (maxx &lt; my_w - 1);
+    maxy += (maxy &lt; my_h - 1);
+
+    printf (&quot;(%d..%d, %d..%d):\n&quot;, minx, maxx, miny, maxy);
+
+    for (uint32_t py = miny; py &lt;= maxy; py++)
+    {
+        printf (&quot;    &quot;);
+        for (uint32_t px = minx; px &lt;= maxx; px++)
+        {
+            if (goodPixel (px, py))
+            {
+                printf (&quot;*&quot;);
+#if 0
+// This is now done in autoOutline() where it belongs (more so than here,
+// anyway).
+                outPixel (px, py) = 64;
+#endif
+            }
+            else
+                printf (&quot;.&quot;);
+        }
+        printf (&quot;\n&quot;);
+    }
+
+    printf (&quot;\nOutline (%d points):\n\n&quot;, pixelList.size());
+
+    std::string blankLine (maxx - minx + 1, '.');
+    std::vector &lt;std::string&gt; showOutline (maxy - miny + 1, blankLine);
+
+    plit = pixelList.begin();
+    while (plit != pixelList.end())
+    {
+        uint32_t px = plit-&gt;x;
+        uint32_t py = plit-&gt;y;
+
+        char &amp; ch = showOutline [py - miny][px - minx];
+        if (ch == '.')
+            ch = '1';
+        else if (ch == '9')
+            ch = '+';
+        else if (ch != '+')
+            ++ch;
+
+#if 0
+// This is now done in autoOutline() where it belongs (more so than here,
+// anyway).
+        getPixel (px, py) = 0;
+        outPixel (px, py) = 255;
+        outUPixel (px, py) = 0;
+        outVPixel (px, py) = 0;
+#endif
+
+        ++plit;
+    }
+
+    std::vector &lt;std::string&gt;::iterator oit = showOutline.begin();
+    while (oit != showOutline.end())
+        std::cout &lt;&lt; *oit++ &lt;&lt; &quot;\n&quot;;
+
+    std::cout &lt;&lt; &quot;\npixelList: &quot; &lt;&lt; pixelList &lt;&lt; &quot;\n\n&quot;;
+}

Added: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidParticle.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidParticle.h	2007-08-30 18:42:41 UTC (rev 3574)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidParticle.h	2007-08-31 16:18:20 UTC (rev 3575)
@@ -0,0 +1,313 @@
+/***************************************************************************
+                          ADM_vidParticle.h  -  detect particles (groups of pixels)
+                              -------------------
+                          Chris MacGregor, 2005, 2007
+                         <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">chris-avidemux at bouncingdog.com</A>
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+ 
+#ifndef __PARTICLE__
+#define __PARTICLE__   
+#include &quot;ADM_video/ADM_cache.h&quot;
+struct PARTICLE_PARAM
+{
+
+    uint32_t min_area;
+    uint32_t max_area;
+    uint32_t left_crop;
+    uint32_t right_crop;
+    uint32_t top_crop;
+    uint32_t bottom_crop;
+    uint32_t output_format;
+    const char * output_file;
+    uint32_t camera_number;
+    uint32_t debug;
+
+};
+
+class ADMVideoParticle : public AVDMGenericVideoStream
+{
+
+ protected:
+    	
+     PARTICLE_PARAM *  _param;
+
+     static FILE * outfp; // ugly, but hard to avoid
+     static uint32_t last_frame_written; // ditto
+
+ public:
+ 		
+     enum OutputFmt
+     {
+         OUTPUTFMT_INVALID = 0,
+
+         OUTPUTFMT_FORMAT_NEW,
+         OUTPUTFMT_FORMAT_OLD,
+
+         OUTPUTFMT_COUNT
+     };
+
+
+     ADMVideoParticle(  AVDMGenericVideoStream *in,CONFcouple *setup);
+
+     ~ADMVideoParticle();
+
+     virtual uint8_t 	getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
+                                              ADMImage *data,uint32_t *flags);
+
+     virtual uint8_t 	configure( AVDMGenericVideoStream *instream);
+     virtual char 		   *printConf(void);
+     virtual uint8_t 	getCoupledConf( CONFcouple **couples);
+							
+};
+
+//////////////////////////////////////////////////////////////////////////////
+
+#include &lt;list&gt;
+#include &lt;vector&gt;
+#include &lt;iostream&gt;
+#include &lt;iterator&gt;
+
+class PixelLoc
+{
+public:
+    uint16_t x;
+    uint16_t y;
+
+    PixelLoc ()
+        : x (0),
+          y (0)
+    {
+    }
+
+    PixelLoc (uint32_t a_x, uint32_t a_y)
+        : x (a_x),
+          y (a_y)
+    {
+    }
+
+    // Use this to sort by y's, then (for PixelLoc's with the same y) by x's.
+
+    class Compare
+    {
+    public:
+        int operator () (const PixelLoc &amp; p1, const PixelLoc &amp; p2) const
+        {
+            return ((p1.y == p2.y) ? (p1.x &lt; p2.x) : (p1.y &lt; p2.y));
+        }
+    };
+};
+
+// Now that we no longer need to sort the list or insert anything into it, a
+// vector should be faster.
+// typedef std::list &lt;PixelLoc&gt; PixelList;
+typedef std::vector &lt;PixelLoc&gt; PixelList;
+
+inline std::ostream &amp;
+operator &lt;&lt; (std::ostream &amp; s, const PixelLoc &amp; pl)
+{
+    return s &lt;&lt; &quot;(&quot; &lt;&lt; pl.x &lt;&lt; &quot;,&quot; &lt;&lt; pl.y &lt;&lt; &quot;)&quot;;
+}
+
+inline std::ostream &amp;
+operator &lt;&lt; (std::ostream &amp; s, const PixelList &amp; theList)
+{
+    s &lt;&lt; &quot;[ &quot;;
+    std::copy (theList.begin(), theList.end(),
+               std::ostream_iterator &lt;PixelLoc&gt; (s, &quot; &quot;));
+    s &lt;&lt; &quot;]&quot;;
+    return s;
+}
+
+struct PixelOffset
+{
+    int8_t x;
+    int8_t y;
+};
+
+class ImageTool
+{
+private:
+    uint8_t * my_pixels;
+    uint32_t my_w;
+    uint32_t my_h;
+    ADMImage * my_outImage;
+    uint32_t my_minArea;
+    uint32_t my_maxArea;
+    uint32_t my_particleArea;
+    float my_particleCentroidX;
+    float my_particleCentroidY;
+    uint32_t debug;
+    PixelList pixelList;
+
+    enum TracingDirection
+    {
+        // The order of the members here is important - several things depend
+        // on it!
+
+        DIRECTION_EAST,   // x + 1, y
+        DIRECTION_SOUTH,  // x    , y + 1
+        DIRECTION_WEST,   // x - 1, y
+        DIRECTION_NORTH,  // x    , y - 1
+        DIRECTION_COUNT
+    };
+
+    enum TurnDirection
+    {
+        // These values are designed to be added to TracingDirection values.
+        TURN_RIGHT = 1,
+        TURN_AROUND = 2, // reverse
+        TURN_LEFT = 3,
+    };
+
+    static char directionLetters [];
+    static PixelOffset leftOffset [DIRECTION_COUNT];
+    static PixelOffset aheadOffset [DIRECTION_COUNT];
+
+public:
+    ImageTool (uint8_t * pixels, uint32_t w, uint32_t h, ADMImage * outImage = 0)
+        : my_pixels (pixels),
+          my_w (w),
+          my_h (h),
+          my_outImage (outImage),
+          my_particleArea (0),
+          my_particleCentroidX (0),
+          my_particleCentroidY (0),
+          debug (0)
+    {
+    }
+
+    // Return true if the pixel is part of a particle.
+
+    bool goodPixel (uint8_t pixel) const
+    {
+        // HERE: If we wanted to incorporate thresholding into this step, or look
+        // for black particles on a white background, this function would be the
+        // place to make the change.
+
+        return (pixel != 0);
+    }
+
+    uint8_t &amp; getPixel (uint32_t x, uint32_t y) const
+    {
+        return my_pixels [(y * my_w) + x];
+    }
+
+    uint8_t &amp; getPixel (uint32_t index) const
+    {
+        return my_pixels [index];
+    }
+
+    // This one does bounds checking, and forces references &quot;off the edge&quot; to
+    // the nearest valid pixel - it's useful for convolutions.
+
+    uint8_t &amp; getPixelSafely (int32_t x, int32_t y) const
+    {
+        if (x &lt; 0)
+            x = 0;
+        else if (x &gt;= my_w)
+            x = my_w - 1;
+
+        if (y &lt; 0)
+            y = 0;
+        else if (y &gt;= my_h)
+            y = my_h - 1;
+
+        return my_pixels [(y * my_w) + x];
+    }
+
+    uint8_t &amp; getPixelSafely (uint32_t x, uint32_t y) const
+    {
+        return getPixelSafely (static_cast &lt;int32_t&gt; (x),
+                               static_cast &lt;int32_t&gt; (y));
+    }
+
+    uint8_t &amp; outPixel (uint32_t x, uint32_t y) const
+    {
+        return YPLANE (my_outImage) [(y * my_w) + x];
+    }
+
+    uint8_t &amp; outUPixel (uint32_t x, uint32_t y) const
+    {
+        return UPLANE (my_outImage) [((y &gt;&gt; 2) * my_w) + (x &gt;&gt; 1)];
+    }
+
+    uint8_t &amp; outVPixel (uint32_t x, uint32_t y) const
+    {
+        return VPLANE (my_outImage) [((y &gt;&gt; 2) * my_w) + (x &gt;&gt; 1)];
+    }
+
+    bool validPixel (uint32_t x, uint32_t y) const
+    {
+        return (x &lt; my_w &amp;&amp; y &lt; my_h);
+    }
+
+    bool goodPixel (uint32_t x, uint32_t y) const
+    {
+        // HERE: this might be a good place to implement ROI (region of
+        // interest) if we want that.
+
+        return (validPixel (x, y) &amp;&amp; goodPixel (getPixel (x, y)));
+    }
+
+    uint32_t width () const
+    {
+        return my_w;
+    }
+
+    uint32_t height () const
+    {
+        return my_h;
+    }
+
+    uint32_t particleArea () const
+    {
+        return my_particleArea;
+    }
+
+    float particleCentroidX () const
+    {
+        return my_particleCentroidX;
+    }
+
+    float particleCentroidY () const
+    {
+        return my_particleCentroidY;
+    }
+
+    uint8_t autoOutline (uint32_t x, uint32_t y);
+
+    void showStuff () const;
+
+    // implementation is in ADM_vidSwissArmyKnife.cpp - nothing else uses it
+    // (currently).
+
+    template &lt;class Oper, class Histo&gt;
+    void convolve (const std::vector &lt;float&gt; &amp; kernel,
+                   uint32_t kw, uint32_t kh, int32_t bias, const Oper &amp; op,
+                   const Histo &amp; histogram_in);
+
+    void setDebug (uint32_t newDebug)
+    {
+        debug = newDebug;
+    }
+
+    void setMinArea (uint32_t newMinArea)
+    {
+        my_minArea = newMinArea;
+    }
+
+    void setMaxArea (uint32_t newMaxArea)
+    {
+        my_maxArea = newMaxArea;
+    }
+};
+#endif

Added: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidSwissArmyKnife.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidSwissArmyKnife.cpp	2007-08-30 18:42:41 UTC (rev 3574)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidSwissArmyKnife.cpp	2007-08-31 16:18:20 UTC (rev 3575)
@@ -0,0 +1,2684 @@
+/***************************************************************************
+                          ADM_vidSwissArmyKnife.cpp  -  Perform one of many
+                                                        possible operations
+                             -------------------
+                          Chris MacGregor, 2005, 2007
+                         <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">chris-avidemux at bouncingdog.com</A>
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+ 
+ 
+#include &lt;ctype.h&gt;
+#include &lt;stdio.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;string.h&gt;
+#include &lt;errno.h&gt;
+#include &lt;ADM_assert.h&gt;
+#include &lt;math.h&gt;
+#include &lt;sys/types.h&gt;
+#include &lt;sys/stat.h&gt;
+
+#include &lt;iostream&gt;
+#include &lt;fstream&gt;
+#include &lt;iterator&gt;
+
+#include &quot;config.h&quot;
+#include &quot;fourcc.h&quot;
+#include &quot;avio.hxx&quot;
+#include &quot;config.h&quot;
+#include &quot;avi_vars.h&quot;
+
+#include &quot;ADM_toolkit/toolkit.hxx&quot;
+#include &quot;ADM_editor/ADM_edit.hxx&quot;
+#include &quot;ADM_video/ADM_genvideo.hxx&quot;
+
+#include &quot;ADM_encoder/ADM_vidEncode.hxx&quot;
+#include &quot;ADM_encoder/adm_encoder.h&quot;
+
+#include &quot;ADM_filter/video_filters.h&quot;
+
+#include &quot;ADM_userInterfaces/ADM_commonUI/DIA_factory.h&quot;
+
+#include &quot;ADM_vidSwissArmyKnife.h&quot;
+#include &quot;ADM_vidParticle.h&quot; // for ImageTool
+#include &quot;ADM_vidComputeAverage.h&quot; // for ADMVideoComputeAverage::FileHeader
+
+static const int MAX_PIXEL_LUMA = 255;
+
+static FILTER_PARAM swissArmyKnifeParam =
+{
+    15,
+    { &quot;tool&quot;, &quot;input_type&quot;, &quot;input_file&quot;, &quot;load_bias&quot;,              // 4
+      &quot;load_multiplier&quot;, &quot;input_constant&quot;, &quot;memory_constant_denom&quot;, // + 3 = 7
+      &quot;init_start_frame&quot;, &quot;init_end_frame&quot;, &quot;init_by_rolling&quot;,      // + 3 = 10
+      &quot;bias&quot;, &quot;scale_from_min&quot;, &quot;scale_from_max&quot;,                   // + 3 = 13
+      &quot;histogram_frame_interval&quot;, &quot;debug&quot;                           // + 2 = 15
+    }
+};
+
+ADMVideoSwissArmyKnife::ToolMap ADMVideoSwissArmyKnife::tool_map [] =
+{
+    { TOOL_A,         &quot;A&quot;,        &quot;%s&quot; },
+    { TOOL_P,         &quot;P&quot;,        &quot;P&quot; },
+    { TOOL_P_MINUS_A, &quot;P-A&quot;,      &quot;P-%s&quot; },
+    { TOOL_A_MINUS_P, &quot;A-P&quot;,      &quot;%s-P&quot; },
+    { TOOL_P_PLUS_A,  &quot;P+A&quot;,      &quot;P+%s&quot; },
+    { TOOL_P_TIMES_A, &quot;P*A&quot;,      &quot;P*%s&quot; },
+    { TOOL_P_DIVBY_A, &quot;P/A&quot;,      &quot;P/%s&quot; },
+    { TOOL_A_DIVBY_P, &quot;A/P&quot;,      &quot;%s/P&quot; },
+    { TOOL_MIN_P_A,   &quot;min(P,A)&quot;, &quot;min(P,%s)&quot; },
+    { TOOL_MAX_P_A,   &quot;max(P,A)&quot;, &quot;max(P,%s)&quot; },
+
+    { TOOL_INVALID, 0, 0 }
+};
+
+// This is a hack to work around the fact that the ctor &amp; dtor get called
+// too often.  The right solution would be to arrange for the filter
+// objects to be constructed and destructed only when really necessary:
+// when a new instance of a filter is added to the list (by the user), it
+// is constructed, and when it is removed from the list (by the user), it
+// is destructed, and anything else is handled by a separate init() or
+// configure() method.  This would allow the objects to maintain a
+// persistent state in a more straightforward way.
+
+ADMVideoSwissArmyKnife::PImap ADMVideoSwissArmyKnife::pimap;
+
+
+SCRIPT_CREATE(swissarmyknife_script,ADMVideoSwissArmyKnife,swissArmyKnifeParam);
+
+BUILD_CREATE(swissarmyknife_create,ADMVideoSwissArmyKnife);
+
+ADMVideoSwissArmyKnife::ADMVideoSwissArmyKnife(AVDMGenericVideoStream *in,CONFcouple *couples)
+			
+{
+    _in = in;
+    memcpy(&amp;_info, in-&gt;getInfo(), sizeof(_info));
+    _info.encoding = 1;
+    _uncompressed = new ADMImage(_in-&gt;getInfo()-&gt;width, _in-&gt;getInfo()-&gt;height);
+    ADM_assert(_uncompressed);
+    _param=NEW(SWISSARMYKNIFE_PARAM);
+
+    if (couples)
+    {
+        GET(tool);
+        GET(input_type);
+
+        char * tmp;
+        GET2(input_file, tmp);
+        GET(load_bias);
+        GET(load_multiplier);
+
+        GET(input_constant);
+
+        GET(memory_constant_denom);
+        GET(init_start_frame);
+        GET(init_end_frame);
+        GET(init_by_rolling);
+
+        GET(bias);
+        GET(scale_from_min);
+        GET(scale_from_max);
+        GET(histogram_frame_interval);
+        GET(debug);
+    }
+    else
+    {
+        _param-&gt;tool = TOOL_P_MINUS_A;
+        _param-&gt;input_type = INPUT_ROLLING_AVERAGE;
+
+        _param-&gt;input_file = ADM_strdup (&quot;&quot;);
+        _param-&gt;load_bias = 0.0;
+        _param-&gt;load_multiplier = 1.0;
+
+        _param-&gt;input_constant = 0;
+
+        _param-&gt;memory_constant_denom = 100;
+        _param-&gt;init_start_frame = 1;
+        _param-&gt;init_end_frame = 100;
+        _param-&gt;init_by_rolling = false;
+
+        _param-&gt;bias = 128;
+        _param-&gt;scale_from_min = 0;
+        _param-&gt;scale_from_max = 255;
+        _param-&gt;histogram_frame_interval = 0;
+        _param-&gt;debug = 0;
+    }
+
+    // This is a hack to work around the fact that the ctor &amp; dtor get called
+    // too often.  The right solution would be to arrange for the filter
+    // objects to be constructed and destructed only when really necessary:
+    // when a new instance of a filter is added to the list (by the user), it
+    // is constructed, and when it is removed from the list (by the user), it
+    // is destructed, and anything else is handled by a separate init() or
+    // configure() method.  This would allow the objects to maintain a
+    // persistent state in a more straightforward way.
+
+    // This explicit check wouldn't be necessary if there was an easier way of
+    // ensuring that we got a 0 pointer when a new map entry was auto-consed
+    // up...
+
+    if (pimap.count (couples) == 0)
+    {
+        myInfo = new PersistentInfo;
+        myInfo-&gt;conf = couples;
+        pimap [couples] = myInfo;
+    }
+    else
+    {
+        myInfo = pimap [couples];
+        if (couples)
+        {
+            if (myInfo-&gt;oldConf == couples)
+            {
+                pimap.erase (myInfo-&gt;conf);
+                myInfo-&gt;conf = myInfo-&gt;oldConf;
+                myInfo-&gt;oldConf = 0;
+            }
+            else
+            {
+                ADM_assert (myInfo-&gt;conf == couples);
+
+                if (myInfo-&gt;oldConf)
+                {
+                    pimap.erase (myInfo-&gt;oldConf);
+                    myInfo-&gt;oldConf = 0;
+                }
+            }
+        }
+    }
+
+    myInfo-&gt;refCount++;
+
+    printf (&quot;ADMVideoSwissArmyKnife ctor (%p, conf = %p), pi = %p, rc now %d\n&quot;,
+            this, couples, myInfo, myInfo-&gt;refCount);
+}
+
+uint8_t	ADMVideoSwissArmyKnife::getCoupledConf (CONFcouple **couples)
+{
+
+    ADM_assert(_param);
+    *couples = new CONFcouple(swissArmyKnifeParam.nb);
+
+    // This is a hack to work around the fact that the ctor &amp; dtor get called
+    // too often.  The right solution would be to arrange for the filter
+    // objects to be constructed and destructed only when really necessary:
+    // when a new instance of a filter is added to the list (by the user), it
+    // is constructed, and when it is removed from the list (by the user), it
+    // is destructed, and anything else is handled by a separate init() or
+    // configure() method.  This would allow the objects to maintain a
+    // persistent state in a more straightforward way.
+
+    printf(&quot;ADMVideoSwissArmyKnife::getCoupledConf(): this = %p, couples = %p, &quot;
+           &quot;oldConf = %p (was %p), pi = %p\n&quot;,
+           this, *couples, myInfo-&gt;conf, myInfo-&gt;oldConf, myInfo);
+
+    if (myInfo-&gt;oldConf)
+        pimap.erase (myInfo-&gt;oldConf);
+    myInfo-&gt;oldConf = myInfo-&gt;conf;
+    myInfo-&gt;conf = *couples;
+    pimap [myInfo-&gt;conf] = myInfo;
+    if (myInfo-&gt;oldConf == 0)
+        pimap.erase (0);
+
+#define CSET(x)  (*couples)-&gt;setCouple((char *)#x,(_param-&gt;x))
+    CSET(tool);
+    CSET(input_type);
+
+    CSET(input_file);
+    CSET(load_bias);
+    CSET(load_multiplier);
+
+    CSET(input_constant);
+
+    CSET(memory_constant_denom);
+    CSET(init_start_frame);
+    CSET(init_end_frame);
+    CSET(init_by_rolling);
+
+    CSET(bias);
+    CSET(scale_from_min);
+    CSET(scale_from_max);
+    CSET(histogram_frame_interval);
+    CSET(debug);
+
+    return 1;
+}
+
+uint8_t ADMVideoSwissArmyKnife::configure(AVDMGenericVideoStream *in)
+{
+    UNUSED_ARG(in);
+
+    diaMenuEntry tTool [] = {
+        { TOOL_A,          _(&quot;P' = A&quot;), NULL },
+        { TOOL_P,          _(&quot;P' = P&quot;), NULL },
+        { TOOL_P_MINUS_A,  _(&quot;P' = P - A&quot;), NULL },
+        { TOOL_A_MINUS_P,  _(&quot;P' = A - P&quot;), NULL },
+        { TOOL_P_PLUS_A,   _(&quot;P' = P + A&quot;), NULL },
+        { TOOL_P_TIMES_A,  _(&quot;P' = P * A&quot;), NULL },
+        { TOOL_P_DIVBY_A,  _(&quot;P' = P / A&quot;), NULL },
+        { TOOL_A_DIVBY_P,  _(&quot;P' = A / P&quot;), NULL },
+        { TOOL_MIN_P_A,    _(&quot;P' = min (P, A)&quot;), NULL },
+        { TOOL_MAX_P_A,    _(&quot;P' = max (P, A)&quot;), NULL }
+    };
+
+    diaMenuEntry tInputType [] = {
+        { INPUT_CUSTOM_CONVOLUTION,
+          _(&quot;A = convolve(P); Load convolution kernel from file&quot;), NULL },
+        { INPUT_FILE_IMAGE_FLOAT,
+          _(&quot;A = pixel from image file as float; Load image from file&quot;), NULL },
+        { INPUT_FILE_IMAGE_INTEGER,
+          _(&quot;A = pixel from image file as integer; Load image from file&quot;), NULL },
+        { INPUT_CONSTANT_VALUE,
+          _(&quot;A = floating point constant value&quot;), NULL },
+        { INPUT_ROLLING_AVERAGE,
+          _(&quot;A = rolling average of pixel: A = A*(1-alpha)+(P*alpha)&quot;), NULL },
+    };
+
+    diaElemMenu tool
+        (&amp;(_param-&gt;tool),
+         _(&quot;Select _Operation on each pixel P and input A:&quot;),
+         sizeof (tTool) / sizeof (diaMenuEntry), tTool);
+    diaElemMenu input_type
+        (&amp;(_param-&gt;input_type),
+         _(&quot;Input _Type:&quot;),
+         sizeof (tInputType) / sizeof (diaMenuEntry), tInputType);
+
+    diaElemFile input_file
+        (0, const_cast&lt;char **&gt;(&amp;(_param-&gt;input_file)),
+         _(&quot;Input _File (image or convolution kernel):&quot;));
+    diaElemFloat load_bias
+        (&amp;(_param-&gt;load_bias),
+         _(&quot;_Load Bias (added to each pixel\n&quot;
+           &quot;in file image when loaded):&quot;),
+         -99999, +99999); // arbitrary!
+    diaElemFloat load_multiplier
+        (&amp;(_param-&gt;load_multiplier),
+         _(&quot;Load _Multiplier (each pixel in\n&quot;
+           &quot;file image mult. by this when loaded):&quot;),
+         -99999, +99999); // arbitrary!
+
+    diaElemFloat input_constant
+        (&amp;(_param-&gt;input_constant),
+         _(&quot;Input _Constant:&quot;), -99999, +99999); // arbitrary!
+
+    diaElemUInteger memory_constant_denom
+        (&amp;(_param-&gt;memory_constant_denom),
+         _(&quot;Denominator of memory constant _alpha\n&quot;
+           &quot;(where A = (1-alpha)*A + alpha*curr_frame):&quot;),
+         0, 0x7fffffff);
+    diaElemUInteger init_start_frame
+        (&amp;(_param-&gt;init_start_frame),
+         _(&quot;Init _Start Frame (first frame # to use for head start):&quot;),
+         0, 0x7fffffff);
+    diaElemUInteger init_end_frame
+        (&amp;(_param-&gt;init_end_frame),
+         _(&quot;Init _End Frame (last frame # to use for head start):&quot;),
+         0, 0x7fffffff);
+    diaElemToggle init_by_rolling
+        (&amp;(_param-&gt;init_by_rolling),
+         _(&quot;Init By _Rolling (compute head start using a &quot;
+           &quot;rolling average rather than a straight average)&quot;));
+
+    diaElemSlider bias
+        (&amp;(_param-&gt;bias),
+         _(&quot;_Bias (will be added to result):&quot;), -256, +256);
+    diaElemSlider scale_from_min
+        (&amp;(_param-&gt;scale_from_min),
+         _(&quot;Mi_nimum value (will be scaled to 0):&quot;), -1024, +1024);
+    diaElemSlider scale_from_max
+        (&amp;(_param-&gt;scale_from_max),
+         _(&quot;Ma_ximum value (will be scaled to 255):&quot;), -1024, +1024);
+    diaElemUInteger histogram_frame_interval
+        (&amp;(_param-&gt;histogram_frame_interval),
+         _(&quot;_Histogram every N frames (0 to disable):&quot;), 0, 0x7fffffff);
+    diaElemUInteger debug
+        (&amp;(_param-&gt;debug), _(&quot;_Debugging settings (bits):&quot;), 0, 0x7fffffff);
+
+    diaElem * elems[] = { &amp;tool, &amp;input_type, &amp;input_file, &amp;load_bias,
+                          &amp;load_multiplier, &amp;input_constant,
+                          &amp;memory_constant_denom, &amp;init_start_frame,
+                          &amp;init_end_frame, &amp;init_by_rolling,
+                          &amp;bias, &amp;scale_from_min, &amp;scale_from_max,
+                          &amp;histogram_frame_interval, &amp;debug };
+
+    uint8_t ret = diaFactoryRun(&quot;SwissArmyKnife&quot;, sizeof (elems) / sizeof (diaElem *), elems);
+    if (ret) // 0 = cancel
+    {
+        myInfo-&gt;image_data_invalid = true;
+        myInfo-&gt;histogram_data_invalid = true;
+    }
+    return ret;
+	
+}
+
+ADMVideoSwissArmyKnife::~ADMVideoSwissArmyKnife()
+{
+    // This is a hack to work around the fact that the ctor &amp; dtor get called
+    // too often.  The right solution would be to arrange for the filter
+    // objects to be constructed and destructed only when really necessary:
+    // when a new instance of a filter is added to the list (by the user), it
+    // is constructed, and when it is removed from the list (by the user), it
+    // is destructed, and anything else is handled by a separate init() or
+    // configure() method.  This would allow the objects to maintain a
+    // persistent state in a more straightforward way.
+
+    myInfo-&gt;refCount--;
+    printf (&quot;ADMVideoSwissArmyKnife dtor (%p), conf = %p, pi = %p, rc now %d\n&quot;,
+            this, myInfo-&gt;conf, myInfo, myInfo-&gt;refCount);
+
+    if (myInfo-&gt;oldConf)
+    {
+        pimap.erase (myInfo-&gt;oldConf);
+        myInfo-&gt;oldConf = 0;
+    }
+
+    if (myInfo-&gt;refCount &lt; 1)
+    {
+        pimap.erase (myInfo-&gt;conf);
+        delete myInfo;
+    }
+
+    DELETE(_param);
+    delete _uncompressed;
+    _uncompressed = NULL;
+}
+
+char * ADMVideoSwissArmyKnife::printConf( void) 
+{
+    const int CONF_LEN = 1024;
+    static char conf[CONF_LEN];
+
+    ToolMap * tm;
+    for (tm = tool_map; tm-&gt;outputName; tm++)
+        if (tm-&gt;toolid == _param-&gt;tool)
+            break;
+
+    char inputstr [CONF_LEN];
+    char where [256];
+    where[0] = '\0';
+    char moreinfo [256];
+    moreinfo[0] = '\0';
+    const char * input_file = _param-&gt;input_file;
+    if (!input_file || !*input_file)
+        input_file = &quot;**** no file selected ****&quot;;
+    switch (_param-&gt;input_type)
+    {
+    case INPUT_CUSTOM_CONVOLUTION:
+        snprintf (inputstr, CONF_LEN, &quot;convolve(P,%s)&quot;, input_file);
+        break;
+    case INPUT_FILE_IMAGE_FLOAT:
+        snprintf (inputstr, CONF_LEN,
+                  (_param-&gt;load_bias == 0.0 &amp;&amp; _param-&gt;load_multiplier == 1.0)
+                  ? &quot;pixel_from(%s)&quot;
+                  : &quot;((pixel_from(%s)%+.6f)*%.6f)&quot;,
+                  input_file, _param-&gt;load_bias, _param-&gt;load_multiplier);
+        break;
+    case INPUT_FILE_IMAGE_INTEGER:
+        snprintf (inputstr, CONF_LEN,
+                  (_param-&gt;load_bias == 0.0 &amp;&amp; _param-&gt;load_multiplier == 1.0)
+                  ? &quot;integer(pixel_from(%s))&quot;
+                  : &quot;integer((pixel_from(%s)%+.6f)*%.6f)&quot;,
+                  input_file, _param-&gt;load_bias, _param-&gt;load_multiplier);
+        break;
+    case INPUT_CONSTANT_VALUE:
+        if (int (_param-&gt;input_constant) == _param-&gt;input_constant)
+            sprintf (inputstr, &quot;%d&quot;, int (_param-&gt;input_constant));
+        else
+            sprintf (inputstr, &quot;%.6f&quot;, _param-&gt;input_constant);
+        break;
+    case INPUT_ROLLING_AVERAGE:
+        sprintf (inputstr, &quot;A&quot;);
+        sprintf (where, &quot; (where each frame, A=(A*(1-alpha))+(P*alpha), &quot;
+                 &quot;alpha=1/%u=%.6f)&quot;, _param-&gt;memory_constant_denom,
+                 1.0 / _param-&gt;memory_constant_denom);
+        if (_param-&gt;init_start_frame)
+            sprintf (moreinfo, &quot;, initial A = %s avg of frames %u - %u&quot;,
+                     _param-&gt;init_by_rolling ? &quot;rolling&quot; : &quot;straight&quot;,
+                     _param-&gt;init_start_frame, _param-&gt;init_end_frame);
+        break;
+    default:
+        sprintf (inputstr, &quot;OOOPS!! (unexpected type %d)&quot;,
+                 _param-&gt;input_type);
+        break;
+    }
+
+    char * cptr = conf;
+
+    cptr += snprintf (conf, CONF_LEN, &quot;Swiss Army Knife: P' = &quot;);
+    cptr += snprintf (cptr, CONF_LEN - (cptr - conf), tm-&gt;format, inputstr);
+    if (_param-&gt;bias)
+        cptr += snprintf (cptr, CONF_LEN - (cptr - conf), &quot;%+d&quot;,
+                          _param-&gt;bias);
+    cptr += snprintf (cptr, CONF_LEN - (cptr - conf), &quot;%s&quot;, where);
+    if (_param-&gt;scale_from_min != 0 || _param-&gt;scale_from_max != 255)
+        cptr += snprintf (cptr, CONF_LEN - (cptr - conf),
+                          &quot;, scaled from %d..%d to 0..255&quot;,
+                          _param-&gt;scale_from_min, _param-&gt;scale_from_max);
+    cptr += snprintf (cptr, CONF_LEN - (cptr - conf), &quot;%s&quot;, moreinfo);
+    if (_param-&gt;histogram_frame_interval)
+        cptr += snprintf (cptr, CONF_LEN - (cptr - conf),
+                          &quot;, histogram every %u frames&quot;,
+                          _param-&gt;histogram_frame_interval);
+    if (_param-&gt;debug)
+        cptr += snprintf (cptr, CONF_LEN - (cptr - conf),
+                          &quot;, debug=0x%x&quot;, _param-&gt;debug);
+    fprintf (stderr, &quot;conf is (%d) \&quot;%s\&quot;\n&quot;, cptr - conf, conf);
+    return conf;
+}
+
+//==============================================================================
+
+// Note: The structure of the following code (with the template functions, and
+// the functor objects, etc.) is all about minimizing the code executed
+// per-pixel.  We need to select an input (convolution, etc.), and an
+// operation to apply that input to each pixel (P' = P - A, etc.), and
+// optionally scale the result, and optionally collect a histogram...but we
+// don't want any more if's or pointer (or reference dereferences) in the
+// per-pixel core of the loop than we absolutely must have, and we certainly
+// don't want any switches or function calls.  At the same time, we don't want
+// to duplicate the code that humans have to deal with - that's the whole
+// point of templates.  So, buckle your seat belts, because this is where C++
+// gets really fun!
+
+//==============================================================================
+
+class HistogramNull // do-nothing version
+{
+public:
+    static
+    void reset()
+    {
+    }
+    static
+    void record_input (uint8_t P)
+    {
+    }
+    static
+    void record_output (int32_t P)
+    {
+    }
+    static
+    void dump (uint32_t frame_count, uint32_t pixels_per_frame)
+    {
+    }
+    static
+    bool frame_check ()
+    {
+        return false;
+    }
+};
+
+//------------------------------------------------------------------------------
+
+class Histogram
+{
+public:
+    // Optionally, we could make this a template class with range_size a
+    // template parameter.  However, it would have to be used in more than one
+    // place, with different range sizes, for that to be worth doing.
+
+    static const int32_t input_range_size = 256; // 8 bit pixels
+    static const int32_t range_size = 1024; // This must be a power of 2!
+    static const int32_t midpoint = 128;
+    static const int32_t range_min = midpoint - (range_size / 2);
+    static const int32_t range_max = midpoint + (range_size / 2) - 1;
+    static const int32_t out_of_range_mask = ~(range_size - 1);
+
+    uint32_t * input_data;
+    uint32_t * output_data;
+    uint32_t pixels_per_frame;
+    uint32_t &amp; frame_count;
+    uint32_t frame_interval;
+
+    // The default copy ctor and assignment operators are just fine in this
+    // case!  Also, note that the ctor allocates the memory and sets the
+    // pointers to which it is passed references, but does not keep the
+    // references (since it won't need to change those pointers again) - it
+    // keeps local copies instead, to avoid later indirections.  It does store
+    // a reference to the frame_count for use in frame_check().
+
+    Histogram (uint32_t * &amp; input_data_ref, uint32_t * &amp; output_data_ref,
+               uint32_t frame_interval, uint32_t &amp; frame_count,
+               uint32_t pixels_per_frame)
+        : input_data (input_data_ref),
+          output_data (output_data_ref),
+          pixels_per_frame (pixels_per_frame),
+          frame_count (frame_count),
+          frame_interval (frame_interval)
+    {
+        if (!input_data)
+        {
+            input_data = input_data_ref = new uint32_t [input_range_size];
+            output_data = output_data_ref = new uint32_t [range_size];
+            // printf (&quot;histogram: allocated data at %p, %p\n&quot;,
+            //         input_data, output_data);
+            reset();
+        }
+        else
+            ;// printf (&quot;histogram: using data at %p, %p\n&quot;,
+             //         input_data, output_data);
+    }
+
+    // no dtor needed - deallocation is handled elsewhere
+
+    void reset () const
+    {
+        memset (input_data, 0, input_range_size * sizeof (input_data[0]));
+        memset (output_data, 0, range_size * sizeof (output_data[0]));
+        frame_count = 0;
+    }
+
+    void record_input (uint8_t P) const
+    {
+        input_data[P]++;
+    }
+
+    void record_output (int32_t P) const
+    {
+        P -= range_min; // scale into histogram data array index
+        if ((P &amp; out_of_range_mask) == 0)
+        {
+            output_data[P]++;
+            return;
+        }
+
+        if (P &lt; 0)
+            P = 0;
+        else if (P &gt;= range_size)
+            P = range_size - 1;
+
+        output_data[P]++;
+    }
+
+    void dump () const
+    {
+        int32_t index_min = 0;
+        int32_t index_max = range_size - 1;
+        while (index_min &lt; index_max)
+        {
+            if (output_data[index_min])
+                break;
+            ++index_min;
+        }
+        while (index_min &lt; index_max)
+        {
+            if (output_data[index_max])
+                break;
+            --index_max;
+        }
+        
+        printf (&quot;Swiss Army Knife Histogram for past %u frames:\n&quot;
+                &quot; =================== Input (0 - 255), &quot;
+                &quot;avg/frame over %d frames: ====================\n&quot;,
+                frame_count, frame_count);
+        do_dump (input_data, 0, 255, 0);
+        printf (&quot;=========== Result before saturation (%d - %d), &quot;
+                &quot;avg/frame over %d frames: ==========\n&quot;,
+                index_min + range_min, index_max + range_min, frame_count);
+        do_dump (output_data, index_min, index_max, range_min);
+    }
+
+    // returns true if it outputs data and resets the counter, else false.
+
+    bool frame_check () const
+    {
+        if (++frame_count &lt; frame_interval)
+        {
+            // printf (&quot;histogram: frame %d of %d\n&quot;,
+            //         frame_count, frame_interval);
+            return false;
+        }
+
+        dump();
+        reset();
+        return true;
+    }
+
+private:
+    void do_dump (uint32_t * data, int32_t index_min, int32_t index_max,
+                  int32_t bias) const
+    {
+        // We scan the data to find the maximum value, so we can scale the
+        // bars to provide useful visual data.
+
+        uint32_t max_pixels = 0;
+        for (int32_t index = index_min; index &lt;= index_max; index++)
+        {
+            if (data[index] &gt; max_pixels)
+                max_pixels = data[index];
+        }
+
+        // Effectively, for each pixel-value count, we divide by the frame
+        // count to get the average number of times that pixel value occurred
+        // per frame, and then we scale the bar so that only the max number of
+        // pixels gets 100% of the bar.
+
+        const int32_t bar_max = 11; // hardcoded as %11s in printf below
+#if 0
+        max_pixels /= frame_count;
+        int32_t divisor = frame_count * max_pixels / bar_max;
+#else
+        int32_t divisor = max_pixels / bar_max;
+#endif
+
+        const int32_t columns = 4;
+        // The &quot;+ columns&quot; below is to round up to the total number of rows we
+        // need including partial rows; it's really &quot;+ 1 + (columns - 1)&quot;,
+        // where the + 1 is to account for index_max being the top end of the
+        // range, not the top end + 1.
+        int32_t column_len = (index_max - index_min + columns) / columns;
+
+        int32_t column_end = index_min + column_len;
+
+        const char * bar = &quot;*********************************************&quot;;
+        const char * bar_end = bar + strlen (bar);
+
+        for (int32_t index = index_min; index &lt; column_end; index++)
+        {
+            int32_t index2 = index;
+            int32_t val = index + bias;
+            
+            for (int32_t column = 0;
+                 column &lt; columns;
+                 ++column, index2 += column_len, val += column_len)
+            {
+                if (index2 &gt; index_max)
+                    break;
+
+                int32_t dat = data[index2];
+                int32_t bar_size = dat / divisor;
+                if (bar_size == 0 &amp;&amp; dat != 0)
+                    bar_size = 1;
+#define HISTOGRAM_SHOW_VALUES 1
+#ifdef HISTOGRAM_SHOW_VALUES
+                printf (&quot; %5d: %6d %-11s&quot;, val, dat / frame_count, bar_end - bar_size);
+#else
+                printf (&quot; %5d: %-11s&quot;, val, bar_end - bar_size);
+#endif
+            }
+            printf (&quot;\n&quot;);
+        }
+    }
+};
+
+//==============================================================================
+
+template &lt;typename Oper, typename Histo&gt;
+void ImageTool::convolve (const std::vector &lt;float&gt; &amp; kernel,
+                          uint32_t kw, uint32_t kh, int32_t bias,
+                          const Oper &amp; op_in, const Histo &amp; histogram_in)
+{
+    // We make local copies of the functors so that the calls below to
+    // record_input() and record_output() (for the histogram) and operator()
+    // (for the op) are accessing stack data rather than incurring yet another
+    // indirection.  When it's per-pixel, every little bit helps!
+
+    Histo histogram = histogram_in;
+    Oper op = op_in;
+
+    uint32_t sathigh = 0;
+    uint32_t satlow = 0;
+
+    // The following code is copied with little significant change (mostly
+    // just porting &amp; performance tweaks, and adding some debugging output)
+    // from ImageJ's Convolver::convolveFloat() function.  Blame them for
+    // variable names like &quot;uc&quot;. ;-)
+
+    // We have (for the moment) skipped the normalizing step - we assume that
+    // the scale is 1.0.
+
+    // We also assume that kw and kh are both odd.
+
+    int32_t uc = kw / 2;
+    int32_t vc = kh / 2;
+
+    uint32_t xedge = my_w - uc;
+    uint32_t yedge = my_h - vc;
+
+    for (uint32_t y = 0; y &lt; my_h; y++)
+    {
+        bool y_is_edgy = (y &lt; vc || y &gt;= yedge);
+
+        for (uint32_t x = 0; x &lt; my_w; x++)
+        {
+            float sum = 0;
+            uint32_t i = 0;
+
+            // If some of this pixel's neighbors are &quot;off the edge&quot; of the
+            // input image, we'll use the &quot;safe&quot; getPixel().
+
+            if (y_is_edgy || x &lt; uc || x &gt;= xedge)
+            {
+                for (int32_t v = -vc; v &lt;= vc; v++)
+                    for (int32_t u = -uc; u &lt;= uc; u++)
+                        sum += getPixelSafely (x + u, y + v) * kernel [i++];
+            }
+            else
+            {
+                // HERE: we could optimize this a good bit by putting
+                // &amp;(getPixel(x - uc, y - vc)) into a pointer, then just
+                // incrementing the pointer (and adding a precomputed (my_w -
+                // uc * 2) to shift lines).  It violates the nice
+                // encapsulation provided by ImageTool, but if/when we add a
+                // SIMD version of this loop, that sure isn't going to use
+                // GetPixel()... ;-)
+
+                for (int32_t v = -vc; v &lt;= vc; v++)
+                {
+                    int32_t offset = x + ((y + v) * my_w);
+
+                    for (int32_t u = -uc; u &lt;= uc; u++)
+                        sum += getPixel (offset + u) * kernel [i++];
+                }
+            }
+
+            // as noted above, we're currently assuming the matrix was already
+            // normalized...
+            // sum *= scale;
+
+            int32_t P = getPixel (x, y);
+
+            histogram.record_input (P);
+
+            float A = sum;
+
+            int32_t result = op (P, A) + bias;
+
+            histogram.record_output (result);
+
+            if (result &amp; 0xffffff00)
+            {
+                if (result &lt; 0)
+                {
+                    result = 0;
+                    satlow++;
+                }
+                else // if (result &gt; 255)
+                {
+                    result = 255;
+                    sathigh++;
+                }
+            }
+
+            outPixel (x, y) = result;
+        }
+    }
+
+    if (debug &amp; 2)
+    {
+        if (satlow || sathigh)
+            printf (&quot;    Saturated %d low, %d high\n&quot;, satlow, sathigh);
+    }
+}
+
+//==============================================================================
+
+template &lt;typename Oper, typename Histo&gt;
+void ADMVideoSwissArmyKnife::computeRollingAverage (ADMImage * image,
+                                                    ADMImage * data,
+                                                    uint32_t planesize,
+                                                    int32_t bias,
+                                                    const Oper &amp; op_in,
+                                                    const Histo &amp; histogram_in)
+{
+    // We make local copies of the functors so that the calls below to
+    // record_input() and record_output() (for the histogram) and operator()
+    // (for the op) are accessing stack data rather than incurring yet another
+    // indirection.  When it's per-pixel, every little bit helps!
+
+    Histo histogram = histogram_in;
+    Oper op = op_in;
+
+    float alpha = 1.0 / _param-&gt;memory_constant_denom;
+    float oneminusalpha = 1 - alpha;
+
+    // HERE: for speed, we do luma (Y plane) only.  However, some
+    // users might want chroma, too... we should make that
+    // an option or something.
+
+    uint8_t * currp = YPLANE (image) + planesize;
+    uint8_t * destp = YPLANE (data) + planesize;
+    float * bgp = myInfo-&gt;bg + planesize;
+    uint32_t pixremaining = planesize + 1;
+
+    uint32_t sathigh = 0;
+    uint32_t satlow = 0;
+
+    while (--pixremaining)
+    {
+        int32_t P = *--currp;
+        histogram.record_input (P);
+
+        float A = *--bgp;
+        *bgp = (A * oneminusalpha) + (P * alpha);
+
+        int32_t result = op (P, A) + bias;
+
+        histogram.record_output (result);
+
+        if (result &amp; 0xffffff00)
+        {
+            if (result &lt; 0)
+            {
+                result = 0;
+                satlow++;
+            }
+            else // if (result &gt; 255)
+            {
+                result = 255;
+                sathigh++;
+            }
+        }
+
+        *--destp = result;
+    }
+
+    if (_param-&gt;debug &amp; 2)
+    {
+        if (satlow || sathigh)
+            printf (&quot;    Saturated %d low, %d high\n&quot;, satlow, sathigh);
+    }
+}
+
+//==============================================================================
+
+template &lt;typename InputImageType, typename Oper, typename Histo&gt;
+void ADMVideoSwissArmyKnife::applyImage (ADMImage * image, ADMImage * data,
+                                         uint32_t planesize, int32_t bias,
+                                         InputImageType * input_image,
+                                         const Oper &amp; op_in,
+                                         const Histo &amp; histogram_in)
+{
+    // We make local copies of the functors so that the calls below to
+    // record_input() and record_output() (for the histogram) and operator()
+    // (for the op) are accessing stack data rather than incurring yet another
+    // indirection.  When it's per-pixel, every little bit helps!
+
+    Histo histogram = histogram_in;
+    Oper op = op_in;
+
+    // HERE: for speed, we do luma (Y plane) only.  However, some
+    // users might want chroma, too... we should make that
+    // an option or something.
+
+    uint8_t * currp = YPLANE (image) + planesize;
+    uint8_t * destp = YPLANE (data) + planesize;
+    InputImageType * bgp = input_image + planesize;
+    uint32_t pixremaining = planesize + 1;
+
+    uint32_t sathigh = 0;
+    uint32_t satlow = 0;
+
+    while (--pixremaining)
+    {
+        int32_t P = *--currp;
+        histogram.record_input (P);
+
+        InputImageType A = *--bgp;
+        int32_t result = op (P, A) + bias;
+
+        histogram.record_output (result);
+
+        if (result &amp; 0xffffff00)
+        {
+            if (result &lt; 0)
+            {
+                result = 0;
+                satlow++;
+            }
+            else // if (result &gt; 255)
+            {
+                result = 255;
+                sathigh++;
+            }
+        }
+
+        *--destp = result;
+    }
+
+    if (_param-&gt;debug &amp; 2)
+    {
+        if (satlow || sathigh)
+            printf (&quot;    Saturated %d low, %d high\n&quot;, satlow, sathigh);
+    }
+}
+
+//==============================================================================
+
+template &lt;typename Oper, typename Histo&gt;
+void ADMVideoSwissArmyKnife::applyConstant (ADMImage * image, ADMImage * data,
+                                            uint32_t planesize, int32_t bias,
+                                            const Oper &amp; op_in,
+                                            const Histo &amp; histogram_in)
+{
+    // We make local copies of the functors so that the calls below to
+    // record_input() and record_output() (for the histogram) and operator()
+    // (for the op) are accessing stack data rather than incurring yet another
+    // indirection.  When it's per-pixel, every little bit helps!
+
+    Histo histogram = histogram_in;
+    Oper op = op_in;
+
+    // HERE: for speed, we do luma (Y plane) only.  However, some
+    // users might want chroma, too... we should make that
+    // an option or something.
+
+    uint8_t * currp = YPLANE (image) + planesize;
+    uint8_t * destp = YPLANE (data) + planesize;
+    float A = _param-&gt;input_constant;
+    uint32_t pixremaining = planesize + 1;
+
+    uint32_t sathigh = 0;
+    uint32_t satlow = 0;
+
+    while (--pixremaining)
+    {
+        int32_t P = *--currp;
+        histogram.record_input (P);
+
+        int32_t result = op (P, A) + bias;
+
+        histogram.record_output (result);
+
+        if (result &amp; 0xffffff00)
+        {
+            if (result &lt; 0)
+            {
+                result = 0;
+                satlow++;
+            }
+            else // if (result &gt; 255)
+            {
+                result = 255;
+                sathigh++;
+            }
+        }
+
+        *--destp = result;
+    }
+
+    if (_param-&gt;debug &amp; 2)
+    {
+        if (satlow || sathigh)
+            printf (&quot;    Saturated %d low, %d high\n&quot;, satlow, sathigh);
+    }
+}
+
+//==============================================================================
+
+class OpPequalsA
+{
+public:
+    int32_t operator () (int32_t P, float A) const
+    {
+        return static_cast &lt;int32_t&gt; (A + .5);
+    }
+
+    int32_t operator () (int32_t P, uint8_t A) const
+    {
+        return A;
+    }
+};
+
+class OpPequalsP
+{
+public:
+    int32_t operator () (int32_t P, float A) const
+    {
+        return P;
+    }
+
+    int32_t operator () (int32_t P, uint8_t A) const
+    {
+        return P;
+    }
+};
+
+class OpPequalsPminusA
+{
+public:
+    int32_t operator () (int32_t P, float A) const
+    {
+        return (P - static_cast &lt;int32_t&gt; (A + .5));
+    }
+
+    int32_t operator () (int32_t P, uint8_t A) const
+    {
+        return (P - A);
+    }
+};
+
+class OpPequalsAminusP
+{
+public:
+    int32_t operator () (int32_t P, float A) const
+    {
+        return (static_cast &lt;int32_t&gt; (A + .5) - P);
+    }
+
+    int32_t operator () (int32_t P, uint8_t A) const
+    {
+        return (A - P);
+    }
+};
+
+class OpPequalsPplusA
+{
+public:
+    int32_t operator () (int32_t P, float A) const
+    {
+        return (P + static_cast &lt;int32_t&gt; (A + .5));
+    }
+
+    int32_t operator () (int32_t P, uint8_t A) const
+    {
+        return (P + A);
+    }
+};
+
+class OpPequalsPtimesA
+{
+public:
+    int32_t operator () (int32_t P, float A) const
+    {
+        return static_cast &lt;int32_t&gt; ((P * A) + .5);
+    }
+
+    int32_t operator () (int32_t P, uint8_t A) const
+    {
+        return (P * A);
+    }
+};
+
+class OpPequalsPdivByA
+{
+public:
+    int32_t operator () (int32_t P, float A) const
+    {
+        return static_cast &lt;int32_t&gt; ((P / A) + .5);
+    }
+
+    int32_t operator () (int32_t P, uint8_t A) const
+    {
+        return (P / A);
+    }
+};
+
+class OpPequalsAdivByP
+{
+public:
+    int32_t operator () (int32_t P, float A) const
+    {
+        return static_cast &lt;int32_t&gt; ((A / P) + .5);
+    }
+
+    int32_t operator () (int32_t P, uint8_t A) const
+    {
+        return (A / P);
+    }
+};
+
+class OpPequalsMinPA
+{
+public:
+    int32_t operator () (int32_t P, float A) const
+    {
+        int32_t intA = static_cast &lt;int32_t&gt; (A + .5);
+        return ((intA &gt; P) ? P : intA);
+    }
+
+    int32_t operator () (int32_t P, uint8_t A) const
+    {
+        return ((A &gt; P) ? P : A);
+    }
+};
+
+class OpPequalsMaxPA
+{
+public:
+    int32_t operator () (int32_t P, float A) const
+    {
+        int32_t intA = static_cast &lt;int32_t&gt; (A + .5);
+        return ((intA &gt; P) ? intA : P);
+    }
+
+    int32_t operator () (int32_t P, uint8_t A) const
+    {
+        return ((A &gt; P) ? A : P);
+    }
+};
+
+//------------------------------------------------------------------------------
+
+class OpPequalsA_Scaled
+{
+    float scale_min;
+    float multiplier;
+public:
+    OpPequalsA_Scaled (int32_t scale_min, int32_t scale_max)
+        : scale_min (scale_min),
+          multiplier (MAX_PIXEL_LUMA / float (scale_max - scale_min))  { }
+
+    int32_t operator () (int32_t P, float A) const
+    {
+        return static_cast &lt;int32_t&gt; (((A - scale_min) * multiplier) + .5);
+    }
+};
+
+class OpPequalsP_Scaled
+{
+    float scale_min;
+    float multiplier;
+public:
+    OpPequalsP_Scaled (int32_t scale_min, int32_t scale_max)
+        : scale_min (scale_min),
+          multiplier (MAX_PIXEL_LUMA / float (scale_max - scale_min))  { }
+
+    int32_t operator () (int32_t P, float A) const
+    {
+        return static_cast &lt;int32_t&gt; (((P - scale_min) * multiplier) + .5);
+    }
+};
+
+class OpPequalsPminusA_Scaled
+{
+    float scale_min;
+    float multiplier;
+public:
+    OpPequalsPminusA_Scaled (int32_t scale_min, int32_t scale_max)
+        : scale_min (scale_min),
+          multiplier (MAX_PIXEL_LUMA / float (scale_max - scale_min))  { }
+
+    int32_t operator () (int32_t P, float A) const
+    {
+        return (static_cast &lt;int32_t&gt;
+                ((((P - A) - scale_min) * multiplier) + .5));
+    }
+};
+
+class OpPequalsAminusP_Scaled
+{
+    float scale_min;
+    float multiplier;
+public:
+    OpPequalsAminusP_Scaled (int32_t scale_min, int32_t scale_max)
+        : scale_min (scale_min),
+          multiplier (MAX_PIXEL_LUMA / float (scale_max - scale_min))  { }
+
+    int32_t operator () (int32_t P, float A) const
+    {
+        return (static_cast &lt;int32_t&gt;
+                ((((A - P) - scale_min) * multiplier) + .5));
+    }
+};
+
+class OpPequalsPplusA_Scaled
+{
+    float scale_min;
+    float multiplier;
+public:
+    OpPequalsPplusA_Scaled (int32_t scale_min, int32_t scale_max)
+        : scale_min (scale_min),
+          multiplier (MAX_PIXEL_LUMA / float (scale_max - scale_min))  { }
+
+    int32_t operator () (int32_t P, float A) const
+    {
+        return (static_cast &lt;int32_t&gt;
+                ((((P + A) - scale_min) * multiplier) + .5));
+    }
+};
+
+class OpPequalsPtimesA_Scaled
+{
+    float scale_min;
+    float multiplier;
+public:
+    OpPequalsPtimesA_Scaled (int32_t scale_min, int32_t scale_max)
+        : scale_min (scale_min),
+          multiplier (MAX_PIXEL_LUMA / float (scale_max - scale_min))  { }
+
+    int32_t operator () (int32_t P, float A) const
+    {
+        return (static_cast &lt;int32_t&gt;
+                ((((P * A) - scale_min) * multiplier) + .5));
+    }
+};
+
+class OpPequalsPdivByA_Scaled
+{
+    float scale_min;
+    float multiplier;
+public:
+    OpPequalsPdivByA_Scaled (int32_t scale_min, int32_t scale_max)
+        : scale_min (scale_min),
+          multiplier (MAX_PIXEL_LUMA / float (scale_max - scale_min))  { }
+
+    int32_t operator () (int32_t P, float A) const
+    {
+        return (static_cast &lt;int32_t&gt;
+                ((((P / A) - scale_min) * multiplier) + .5));
+    }
+};
+
+class OpPequalsAdivByP_Scaled
+{
+    float scale_min;
+    float multiplier;
+public:
+    OpPequalsAdivByP_Scaled (int32_t scale_min, int32_t scale_max)
+        : scale_min (scale_min),
+          multiplier (MAX_PIXEL_LUMA / float (scale_max - scale_min))  { }
+
+    int32_t operator () (int32_t P, float A) const
+    {
+        return (static_cast &lt;int32_t&gt;
+                ((((A / P) - scale_min) * multiplier) + .5));
+    }
+};
+
+class OpPequalsMinPA_Scaled
+{
+    float scale_min;
+    float multiplier;
+public:
+    OpPequalsMinPA_Scaled (int32_t scale_min, int32_t scale_max)
+        : scale_min (scale_min),
+          multiplier (MAX_PIXEL_LUMA / float (scale_max - scale_min))  { }
+
+    int32_t operator () (int32_t P, float A) const
+    {
+        return (static_cast &lt;int32_t&gt;
+                ((((A &gt; P ? P : A) - scale_min) * multiplier) + .5));
+    }
+};
+
+class OpPequalsMaxPA_Scaled
+{
+    float scale_min;
+    float multiplier;
+public:
+    OpPequalsMaxPA_Scaled (int32_t scale_min, int32_t scale_max)
+        : scale_min (scale_min),
+          multiplier (MAX_PIXEL_LUMA / float (scale_max - scale_min))  { }
+
+    int32_t operator () (int32_t P, float A) const
+    {
+        return (static_cast &lt;int32_t&gt;
+                ((((A &gt; P ? A : P) - scale_min) * multiplier) + .5));
+    }
+};
+
+//==============================================================================
+
+uint8_t ADMVideoSwissArmyKnife::getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
+          			ADMImage *data, uint32_t *flags)
+{
+    if (frame &gt;= _info.nb_frames)
+        return 0;
+
+    uint32_t debug = _param-&gt;debug;
+
+    if (debug &amp; 1)
+        printf (&quot;in ADMVideoSwissArmyKnife::getFrameNumberNoAlloc(%d, ...)\n&quot;,
+                frame);
+
+    bool doingConvolution = (_param-&gt;input_type == INPUT_CUSTOM_CONVOLUTION);
+    bool doingRollingAvg = (_param-&gt;input_type == INPUT_ROLLING_AVERAGE);
+    bool doingFileImage = (_param-&gt;input_type == INPUT_FILE_IMAGE_FLOAT
+                           || _param-&gt;input_type == INPUT_FILE_IMAGE_INTEGER);
+    bool doingFileImageFloat = (_param-&gt;input_type == INPUT_FILE_IMAGE_FLOAT);
+    bool doingApplyConstant = (_param-&gt;input_type == INPUT_CONSTANT_VALUE);
+
+    bool needRead = false;
+    bool needFile = doingConvolution || doingFileImage;
+
+    if (needFile)
+    {
+        if (myInfo-&gt;input_file_name != _param-&gt;input_file)
+        {
+            myInfo-&gt;input_file_name = _param-&gt;input_file;
+            myInfo-&gt;input_file_mtime = 0;
+            printf (&quot;SwissArmyKnife: new input file has been selected: %s\n&quot;,
+                    myInfo-&gt;input_file_name.c_str());
+            needRead = true;
+        }
+
+        // HERE: we should rearrange a bit to move the stat() call out to the
+        // ctor - we don't need to check it every frame!
+
+        struct stat st;
+        if (stat (myInfo-&gt;input_file_name.c_str(), &amp;st) == -1)
+        {
+            perror (myInfo-&gt;input_file_name.c_str());
+            return 0;
+        }
+
+        if (st.st_mtime != myInfo-&gt;input_file_mtime)
+        {
+            if (!needRead &amp;&amp; myInfo-&gt;input_file_mtime)
+                printf (&quot;SwissArmyKnife: input file %s has been changed - &quot;
+                        &quot;re-reading it\n&quot;, myInfo-&gt;input_file_name.c_str());
+            needRead = true;
+            myInfo-&gt;input_file_mtime = st.st_mtime;
+        }
+        else if (!needRead &amp;&amp; myInfo-&gt;image_data_invalid)
+            needRead = true;
+    }
+
+    FloatVector &amp; kernel = myInfo-&gt;kernel;
+    uint32_t &amp; kernel_w = myInfo-&gt;kernel_w;
+    uint32_t &amp; kernel_h = myInfo-&gt;kernel_h;
+
+    uint32_t w = _info.width;
+    uint32_t h = _info.height;
+    uint32_t planesize = w * h;
+    uint32_t size = (planesize * 3) &gt;&gt; 1;
+    *len = size;
+			
+    if (needRead)
+    {
+        myInfo-&gt;histogram_data_invalid = true;
+
+        if (doingConvolution)
+        {
+            kernel.clear();
+            kernel_w = 0;
+            kernel_h = 0;
+
+            using namespace std;
+
+            const char * filename = myInfo-&gt;input_file_name.c_str();
+            ifstream inputStream (filename);
+            if (!inputStream)
+            {
+                printf (&quot;SwissArmyKnife: can't open input file %s, but it &quot;
+                        &quot;apparently does exist...(%d)\n&quot;, filename, errno);
+                return 0;
+            }
+
+#ifndef ASSUME_SQUARE_MATRIX
+            // We read the dimensions as floats just in case they happen to be
+            // written that way (no reason to punt) - however, we do expect
+            // that anything to the right of the decimal is 0!
+
+            float dimtmp;
+            inputStream &gt;&gt; dimtmp;
+            kernel_w = uint32_t (dimtmp);
+            if (float (kernel_w) != dimtmp)
+                printf (&quot;SwissArmyKnife: %s: What exactly do you expect a &quot;
+                        &quot;width of %f to mean?  Truncating to %d...\n&quot;,
+                        filename, dimtmp, uint32_t (dimtmp));
+            inputStream &gt;&gt; dimtmp;
+            kernel_h = uint32_t (dimtmp);
+            if (float (kernel_h) != dimtmp)
+                printf (&quot;SwissArmyKnife: %s: What exactly do you expect a &quot;
+                        &quot;height of %f to mean?  Truncating to %d...\n&quot;,
+                        filename, dimtmp, uint32_t (dimtmp));
+            if (kernel_w &lt; 1 || (kernel_w &amp; 1) == 0
+                || kernel_h &lt; 1 || (kernel_h &amp; 1) == 0)
+            {
+                printf (&quot;SwissArmyKnife: %s: Can't handle a convolution &quot;
+                        &quot;kernel with dimensions %dx%d - both dimensions &quot;
+                        &quot;must be odd (and positive)\n&quot;,
+                        filename, int (kernel_w), int (kernel_h));
+                myInfo-&gt;input_file_mtime = 0;  // force re-read, avoid crash
+                return 0;
+            }
+#endif
+
+            copy (istream_iterator &lt;float&gt; (inputStream),
+                  istream_iterator &lt;float&gt; (),
+                  back_inserter (kernel));
+
+#ifdef ASSUME_SQUARE_MATRIX
+            kernel_dim = uint32_t (sqrtf (kernel.size()));
+            if (kernel_dim * kernel_dim != kernel.size())
+            {
+                if ((kernel_dim + 1) * (kernel_dim + 1) == kernel.size())
+                    ++kernel_dim;
+                else
+                {
+                    printf (&quot;SwissArmyKnife: Can't determine matrix &quot;
+                            &quot;dimensions to explain %d input values! &quot;
+                            &quot;(sqrt(%d) = %f)\n&quot;,
+                            kernel.size(), kernel.size(),
+                            sqrt (kernel.size()));
+                    kernel_dim = 0;
+                    return 0;
+                }
+            }
+#endif
+
+            printf (&quot;SwissArmyKnife: read %d convolution kernel values &quot;
+                    &quot;from %s (%dx%d):\n&quot;,
+                    kernel.size(), filename, kernel_w, kernel_h);
+            if (debug &amp; 8)
+            {
+                FloatVector::const_iterator kit = kernel.begin();
+                int count = 0;
+                while (kit != kernel.end())
+                {
+                    printf (&quot;%.6f%c&quot;, *kit++,
+                            (++count % kernel_w) ? ' ' : '\n');
+                }
+                if (count % kernel_w)
+                    printf (&quot;[incomplete?!]\n&quot;);
+            }
+        }
+        else // file image (not convolution)
+        {
+            ADM_assert (_param-&gt;input_type == INPUT_FILE_IMAGE_FLOAT
+                        || _param-&gt;input_type == INPUT_FILE_IMAGE_INTEGER);
+
+            const char * filename = myInfo-&gt;input_file_name.c_str();
+            FILE * fin = fopen (filename, &quot;rb&quot;);
+            if (!fin)
+            {
+                printf (&quot;SwissArmyKnife: can't open input file %s, but it &quot;
+                        &quot;apparently does exist...(%d)\n&quot;, filename, errno);
+                return 0;
+            }
+
+            ADMVideoComputeAverage::FileHeader header;
+            int nread = fread (&amp;header, sizeof (header), 1, fin);
+            if (nread != 1 || strncmp (header.magic, &quot;DGCMimgF&quot;, 8) != 0)
+            {
+                printf (&quot;SwissArmyKnife: %s does not appear to be a valid &quot;
+                        &quot;DG/CM floating-point raw image file (produced by the &quot;
+                        &quot;ComputeAverage filter)\n&quot;, filename);
+                fclose (fin);
+                return 0;
+            }
+
+            uint32_t width = header.width;
+            uint32_t height = header.height;
+            uint32_t pixelcount = width * height;
+
+            if (width &gt; 2000 || height &gt; 2000)
+            {
+                printf (&quot;SwissArmyKnife: invalid image dimensions &quot;
+                        &quot;(%dx%d) in %s\n&quot;,
+                        int (width), int (height), filename);
+                fclose (fin);
+                return 0;
+            }
+
+            myInfo-&gt;image_data_invalid = true;
+            delete [] myInfo-&gt;image_float;
+            delete [] myInfo-&gt;image_int;
+
+            myInfo-&gt;image_float = new float [pixelcount];
+
+            nread = fread (myInfo-&gt;image_float, sizeof (float), pixelcount, fin);
+            fclose (fin);
+            if (nread != pixelcount)
+            {
+                printf (&quot;SwissArmyKnife: failed to read image data &quot;
+                        &quot;(%ux%u = %u) from %s (got %u)\n&quot;,
+                        width, height, pixelcount, filename, nread);
+                delete [] myInfo-&gt;image_float;
+                myInfo-&gt;image_float = 0;
+                return 0;
+            }
+
+            printf (&quot;SwissArmyKnife: successfully loaded image data &quot;
+                    &quot;(%ux%u = %u) from %s\n&quot;,
+                    width, height, pixelcount, filename);
+
+            myInfo-&gt;image_int = new uint8_t [pixelcount];
+            float * floatpixp = myInfo-&gt;image_float + pixelcount;
+            uint8_t * intpixp = myInfo-&gt;image_int + pixelcount;
+
+            if (_param-&gt;load_bias == 0.0 &amp;&amp; _param-&gt;load_multiplier == 1.0)
+            {
+                printf (&quot;Converting %u pixels to integer values (and keeping &quot;
+                        &quot;the floats, too)\n&quot;, pixelcount);
+
+                ++pixelcount;
+                while (--pixelcount)
+                {
+                    *--intpixp = static_cast &lt;uint8_t&gt; (*--floatpixp + 0.5);
+                }
+            }
+            else
+            {
+                float load_bias = _param-&gt;load_bias;
+                float load_multiplier = _param-&gt;load_multiplier;
+
+                printf (&quot;applying P = (P + %.6f) * %.6f to %u pixels\n&quot;,
+                        load_bias, load_multiplier, pixelcount);
+
+                ++pixelcount;
+                while (--pixelcount)
+                {
+                    float floatpix
+                        = (*--floatpixp + load_bias) * load_multiplier;
+                    *floatpixp = floatpix;
+
+                    uint8_t intpix;
+                    if (floatpix &lt; 0)
+                        intpix = 0;
+                    else if (floatpix &gt; 255)
+                        intpix = 255;
+                    else
+                        intpix = static_cast &lt;uint8_t&gt; (floatpix + 0.5);
+
+                    *--intpixp = intpix;
+                }
+            }
+
+            myInfo-&gt;image_w = width;
+            myInfo-&gt;image_h = height;
+            myInfo-&gt;image_data_invalid = false;
+        }
+    }
+    else if (doingRollingAvg)
+    {
+        if (!myInfo-&gt;bg
+            || myInfo-&gt;bg_x != w || myInfo-&gt;bg_y != h
+            || myInfo-&gt;bg_mc != _param-&gt;memory_constant_denom
+            || myInfo-&gt;bg_isf != _param-&gt;init_start_frame
+            || myInfo-&gt;bg_ief != _param-&gt;init_end_frame
+            || myInfo-&gt;bg_ibr != _param-&gt;init_by_rolling)
+        {
+            if (!myInfo-&gt;bg || myInfo-&gt;bg_x != w || myInfo-&gt;bg_y != h)
+            {
+                myInfo-&gt;bg_x = w;
+                myInfo-&gt;bg_y = h;
+                delete [] myInfo-&gt;bg;
+                myInfo-&gt;bg = new float [planesize];
+            }
+
+            myInfo-&gt;histogram_data_invalid = true;
+
+            myInfo-&gt;bg_mc = _param-&gt;memory_constant_denom;
+            myInfo-&gt;bg_isf = _param-&gt;init_start_frame;
+            myInfo-&gt;bg_ief = _param-&gt;init_end_frame;
+            myInfo-&gt;bg_ibr = _param-&gt;init_by_rolling;
+
+            if (myInfo-&gt;bg_isf &amp;&amp; myInfo-&gt;bg_isf &lt;= myInfo-&gt;bg_ief)
+            {
+                uint32_t do_frames = myInfo-&gt;bg_ief - myInfo-&gt;bg_isf + 1;
+
+                uint32_t firstframe = myInfo-&gt;bg_isf - 1;
+                uint32_t lastframe = myInfo-&gt;bg_ief - 1;
+                if (lastframe &gt;= _info.nb_frames)
+                {
+                    lastframe = _info.nb_frames - 1;
+                    if (firstframe &gt; _info.nb_frames)
+                    {
+                        firstframe = lastframe - do_frames + 1;
+                        if (firstframe &gt; _info.nb_frames)
+                            firstframe = 0;
+                    }
+                    do_frames = lastframe - firstframe + 1;
+                }
+
+                // if (debug &amp; 2)
+                printf (&quot;Getting a \&quot;head start\&quot; on rolling average by computing %s &quot;
+                        &quot;%d frames of size %dx%d from %d to %d with alpha = %.5f (1/%d)\n&quot;,
+                        myInfo-&gt;bg_ibr ? &quot;rolling average over&quot; : &quot;straight average of&quot;,
+                        do_frames, myInfo-&gt;bg_x, myInfo-&gt;bg_y,
+                        firstframe + 1, lastframe + 1,
+                        1.0 / myInfo-&gt;bg_mc, myInfo-&gt;bg_mc);
+
+
+                ADMImage aimage (myInfo-&gt;bg_x, myInfo-&gt;bg_y);
+
+                // HERE: for speed, we do luma (Y plane) only.  However, some
+                // users might want chroma, too... we should make that an option
+                // or something.  (...in which case bg should be big enough for
+                // all three planes.)
+
+                if (myInfo-&gt;bg_ibr)
+                {
+                    // We want to &quot;prime&quot; the rolling average with the values from
+                    // the first frame (rather than zeroes, which doesn't seem to
+                    // work out well).  So we do the following block just once,
+                    // but in its own scope to not collide with the locals of the
+                    // loop that follows:
+                    {
+                        uint32_t flen;
+                        uint32_t fflags = *flags;
+                        if (!_in-&gt;getFrameNumberNoAlloc (firstframe, &amp;flen,
+                                                         &amp;aimage, &amp;fflags))
+                            return 0;
+
+                        uint8_t * currp = YPLANE (&amp;aimage) + planesize;
+                        float * bgp = myInfo-&gt;bg + planesize;
+                        uint32_t pixremaining = planesize + 1;
+                        while (--pixremaining)
+                        {
+                            *--bgp = *--currp;
+                        }
+
+                        ++firstframe; // don't include this one again
+                    }
+
+                    float alpha = 1.0 / _param-&gt;memory_constant_denom;
+                    float oneminusalpha = 1 - alpha;
+
+                    for (int fnum = firstframe; fnum &lt;= lastframe; fnum++)
+                    {
+                        uint32_t flen;
+                        uint32_t fflags = *flags;
+                        if (!_in-&gt;getFrameNumberNoAlloc (fnum, &amp;flen,
+                                                         &amp;aimage, &amp;fflags))
+                            return 0;
+
+                        uint8_t * currp = YPLANE (&amp;aimage) + planesize;
+                        float * bgp = myInfo-&gt;bg + planesize;
+                        uint32_t pixremaining = planesize + 1;
+                        while (--pixremaining)
+                        {
+                            --bgp;
+                            *bgp = (*bgp * oneminusalpha) + (*--currp * alpha);
+                        }
+                    }
+                }
+                else // head start uses straight average (not rolling average)
+                {
+                    uint32_t sums [planesize];
+                    memset (sums, 0, planesize * sizeof sums[0]);
+
+                    for (int fnum = firstframe; fnum &lt;= lastframe; fnum++)
+                    {
+                        uint32_t flen;
+                        uint32_t fflags = *flags;
+                        if (!_in-&gt;getFrameNumberNoAlloc (fnum, &amp;flen,
+                                                         &amp;aimage, &amp;fflags))
+                            return 0;
+
+                        uint8_t * currp = YPLANE (&amp;aimage) + planesize;
+                        uint32_t * sump = sums + planesize;
+                        uint32_t pixremaining = planesize + 1;
+                        while (--pixremaining)
+                        {
+                            *--sump += *--currp;
+                        }
+                    }
+
+                    float * bgp = myInfo-&gt;bg + planesize;
+                    uint32_t * sump = sums + planesize;
+                    uint32_t pixremaining = planesize + 1;
+                    // we use a floating point multiply of a reciprocal rather
+                    // than a floating point divide, because floating point
+                    // folklore says the multiply will be faster.
+                    float one_over_framecount = 1.0 / do_frames;
+                    while (--pixremaining)
+                    {
+                        *--bgp = *--sump * one_over_framecount;
+                    }
+                }
+
+                // if (debug &amp; 2)
+                printf (&quot;Done computing head start.\n&quot;);
+            }
+            else // if (debug &amp; 2)
+            {
+                printf (&quot;Starting with new 0 baseline background\n&quot;);
+                memset (myInfo-&gt;bg, 0, planesize * sizeof (myInfo-&gt;bg[0]));
+            }
+        }
+        else
+        {
+            if (debug &amp; 4)
+                printf (&quot;Using existing baseline background of size %dx%d with &quot;
+                        &quot;alpha = %.5f (1/%d)\n&quot;, myInfo-&gt;bg_x, myInfo-&gt;bg_y,
+                        1.0 / myInfo-&gt;bg_mc, myInfo-&gt;bg_mc);
+        }
+    }			
+
+    if (!_in-&gt;getFrameNumberNoAlloc (frame, len, _uncompressed, flags))
+        return 0;
+
+    ADMImage * image = _uncompressed;
+    uint8_t * imagePixels = YPLANE (image);
+
+    ImageTool imtool (imagePixels, w, h, data);
+    imtool.setDebug (debug);
+
+    Histogram * histogram = 0;
+    int32_t bias = _param-&gt;bias;
+    uint32_t tool = _param-&gt;tool;
+
+    // HERE: give some thought to the general issue of keeping myInfo &amp; _param
+    // in sync, and resetting the histogram (or whatever) when things change.
+
+    if (_param-&gt;histogram_frame_interval != 0)
+    {
+        histogram = new Histogram (myInfo-&gt;histogram_input_data,
+                                   myInfo-&gt;histogram_output_data,
+                                   _param-&gt;histogram_frame_interval,
+                                   myInfo-&gt;histogram_frame_count,
+                                   w * h);
+        tool += TOOL_ADD_HISTOGRAM;
+        if (myInfo-&gt;histogram_frame_interval !=
+            _param-&gt;histogram_frame_interval)
+        {
+            if (myInfo-&gt;histogram_frame_interval)
+                myInfo-&gt;histogram_data_invalid = true;
+            myInfo-&gt;histogram_frame_interval
+                = _param-&gt;histogram_frame_interval;
+        }
+
+        if (myInfo-&gt;histogram_data_invalid)
+        {
+            myInfo-&gt;histogram_data_invalid = false;
+            histogram-&gt;reset();
+        }
+    }
+
+    int32_t scale_min = _param-&gt;scale_from_min;
+    int32_t scale_max = _param-&gt;scale_from_max;
+    if (scale_min != 0 || scale_max != 255)
+    {
+        // printf (&quot;Scaling enabled (from %d..%d to 0..255)\n&quot;,
+        //         scale_min, scale_max);
+        tool += TOOL_ADD_SCALING;
+    }
+
+    if (doingConvolution)
+    {
+        switch (tool)
+        {
+        case TOOL_A:
+            imtool.convolve (kernel, kernel_w, kernel_h, bias, OpPequalsA(), HistogramNull());
+            break;
+        case TOOL_P: // HERE: we could optimize this if we wanted to
+            imtool.convolve (kernel, kernel_w, kernel_h, bias, OpPequalsP(), HistogramNull());
+            break;
+        case TOOL_P_MINUS_A:
+            imtool.convolve (kernel, kernel_w, kernel_h, bias, OpPequalsPminusA(), HistogramNull());
+            break;
+        case TOOL_A_MINUS_P:
+            imtool.convolve (kernel, kernel_w, kernel_h, bias, OpPequalsAminusP(), HistogramNull());
+            break;
+        case TOOL_P_PLUS_A:
+            imtool.convolve (kernel, kernel_w, kernel_h, bias, OpPequalsPplusA(), HistogramNull());
+            break;
+        case TOOL_P_TIMES_A:
+            imtool.convolve (kernel, kernel_w, kernel_h, bias, OpPequalsPtimesA(), HistogramNull());
+            break;
+        case TOOL_P_DIVBY_A:
+            imtool.convolve (kernel, kernel_w, kernel_h, bias, OpPequalsPdivByA(), HistogramNull());
+            break;
+        case TOOL_A_DIVBY_P:
+            imtool.convolve (kernel, kernel_w, kernel_h, bias, OpPequalsAdivByP(), HistogramNull());
+            break;
+        case TOOL_MIN_P_A:
+            imtool.convolve (kernel, kernel_w, kernel_h, bias, OpPequalsMinPA(), HistogramNull());
+            break;
+        case TOOL_MAX_P_A:
+            imtool.convolve (kernel, kernel_w, kernel_h, bias, OpPequalsMaxPA(), HistogramNull());
+            break;
+
+        case TOOL_A_WITH_HISTOGRAM:
+            imtool.convolve (kernel, kernel_w, kernel_h, bias, OpPequalsA(), *histogram);
+            break;
+        case TOOL_P_WITH_HISTOGRAM: // HERE: we could optimize this if we wanted to
+            imtool.convolve (kernel, kernel_w, kernel_h, bias, OpPequalsP(), *histogram);
+            break;
+        case TOOL_P_MINUS_A_WITH_HISTOGRAM:
+            imtool.convolve (kernel, kernel_w, kernel_h, bias, OpPequalsPminusA(), *histogram);
+            break;
+        case TOOL_A_MINUS_P_WITH_HISTOGRAM:
+            imtool.convolve (kernel, kernel_w, kernel_h, bias, OpPequalsAminusP(), *histogram);
+            break;
+        case TOOL_P_PLUS_A_WITH_HISTOGRAM:
+            imtool.convolve (kernel, kernel_w, kernel_h, bias, OpPequalsPplusA(), *histogram);
+            break;
+        case TOOL_P_TIMES_A_WITH_HISTOGRAM:
+            imtool.convolve (kernel, kernel_w, kernel_h, bias, OpPequalsPtimesA(), *histogram);
+            break;
+        case TOOL_P_DIVBY_A_WITH_HISTOGRAM:
+            imtool.convolve (kernel, kernel_w, kernel_h, bias, OpPequalsPdivByA(), *histogram);
+            break;
+        case TOOL_A_DIVBY_P_WITH_HISTOGRAM:
+            imtool.convolve (kernel, kernel_w, kernel_h, bias, OpPequalsAdivByP(), *histogram);
+            break;
+        case TOOL_MIN_P_A_WITH_HISTOGRAM:
+            imtool.convolve (kernel, kernel_w, kernel_h, bias, OpPequalsMinPA(), *histogram);
+            break;
+        case TOOL_MAX_P_A_WITH_HISTOGRAM:
+            imtool.convolve (kernel, kernel_w, kernel_h, bias, OpPequalsMaxPA(), *histogram);
+            break;
+
+        case TOOL_A_SCALED:
+            imtool.convolve (kernel, kernel_w, kernel_h, bias,
+                             OpPequalsA_Scaled (scale_min, scale_max), HistogramNull());
+            break;
+        case TOOL_P_SCALED: // HERE_SCALED: we could optimize this if we wanted to
+            imtool.convolve (kernel, kernel_w, kernel_h, bias,
+                             OpPequalsP_Scaled (scale_min, scale_max), HistogramNull());
+            break;
+        case TOOL_P_MINUS_A_SCALED:
+            imtool.convolve (kernel, kernel_w, kernel_h, bias,
+                             OpPequalsPminusA_Scaled (scale_min, scale_max), HistogramNull());
+            break;
+        case TOOL_A_MINUS_P_SCALED:
+            imtool.convolve (kernel, kernel_w, kernel_h, bias,
+                             OpPequalsAminusP_Scaled (scale_min, scale_max), HistogramNull());
+            break;
+        case TOOL_P_PLUS_A_SCALED:
+            imtool.convolve (kernel, kernel_w, kernel_h, bias,
+                             OpPequalsPplusA_Scaled (scale_min, scale_max), HistogramNull());
+            break;
+        case TOOL_P_TIMES_A_SCALED:
+            imtool.convolve (kernel, kernel_w, kernel_h, bias,
+                             OpPequalsPtimesA_Scaled (scale_min, scale_max), HistogramNull());
+            break;
+        case TOOL_P_DIVBY_A_SCALED:
+            imtool.convolve (kernel, kernel_w, kernel_h, bias,
+                             OpPequalsPdivByA_Scaled (scale_min, scale_max), HistogramNull());
+            break;
+        case TOOL_A_DIVBY_P_SCALED:
+            imtool.convolve (kernel, kernel_w, kernel_h, bias,
+                             OpPequalsAdivByP_Scaled (scale_min, scale_max), HistogramNull());
+            break;
+        case TOOL_MIN_P_A_SCALED:
+            imtool.convolve (kernel, kernel_w, kernel_h, bias,
+                             OpPequalsMinPA_Scaled (scale_min, scale_max), HistogramNull());
+            break;
+        case TOOL_MAX_P_A_SCALED:
+            imtool.convolve (kernel, kernel_w, kernel_h, bias,
+                             OpPequalsMaxPA_Scaled (scale_min, scale_max), HistogramNull());
+            break;
+
+        case TOOL_A_SCALED_WITH_HISTOGRAM:
+            imtool.convolve (kernel, kernel_w, kernel_h, bias,
+                             OpPequalsA_Scaled (scale_min, scale_max), *histogram);
+            break;
+        case TOOL_P_SCALED_WITH_HISTOGRAM: // HERE: we could optimize this if we wanted to
+            imtool.convolve (kernel, kernel_w, kernel_h, bias,
+                             OpPequalsP_Scaled (scale_min, scale_max), *histogram);
+            break;
+        case TOOL_P_MINUS_A_SCALED_WITH_HISTOGRAM:
+            imtool.convolve (kernel, kernel_w, kernel_h, bias,
+                             OpPequalsPminusA_Scaled (scale_min, scale_max), *histogram);
+            break;
+        case TOOL_A_MINUS_P_SCALED_WITH_HISTOGRAM:
+            imtool.convolve (kernel, kernel_w, kernel_h, bias,
+                             OpPequalsAminusP_Scaled (scale_min, scale_max), *histogram);
+            break;
+        case TOOL_P_PLUS_A_SCALED_WITH_HISTOGRAM:
+            imtool.convolve (kernel, kernel_w, kernel_h, bias,
+                             OpPequalsPplusA_Scaled (scale_min, scale_max), *histogram);
+            break;
+        case TOOL_P_TIMES_A_SCALED_WITH_HISTOGRAM:
+            imtool.convolve (kernel, kernel_w, kernel_h, bias,
+                             OpPequalsPtimesA_Scaled (scale_min, scale_max), *histogram);
+            break;
+        case TOOL_P_DIVBY_A_SCALED_WITH_HISTOGRAM:
+            imtool.convolve (kernel, kernel_w, kernel_h, bias,
+                             OpPequalsPdivByA_Scaled (scale_min, scale_max), *histogram);
+            break;
+        case TOOL_A_DIVBY_P_SCALED_WITH_HISTOGRAM:
+            imtool.convolve (kernel, kernel_w, kernel_h, bias,
+                             OpPequalsAdivByP_Scaled (scale_min, scale_max), *histogram);
+            break;
+        case TOOL_MIN_P_A_SCALED_WITH_HISTOGRAM:
+            imtool.convolve (kernel, kernel_w, kernel_h, bias,
+                             OpPequalsMinPA_Scaled (scale_min, scale_max), *histogram);
+            break;
+        case TOOL_MAX_P_A_SCALED_WITH_HISTOGRAM:
+            imtool.convolve (kernel, kernel_w, kernel_h, bias,
+                             OpPequalsMaxPA_Scaled (scale_min, scale_max), *histogram);
+            break;
+
+        default:
+            printf (&quot;SwissArmyKnife: unknown operation (tool) %d!\n&quot;,
+                    _param-&gt;tool);
+            return 0;
+        }
+    }
+    else if (doingRollingAvg)
+    {
+        switch (tool)
+        {
+        case TOOL_A:
+            computeRollingAverage (image, data, planesize, bias, OpPequalsA(), HistogramNull());
+            break;
+        case TOOL_P: // HERE: we could optimize this if we wanted to
+            computeRollingAverage (image, data, planesize, bias, OpPequalsP(), HistogramNull());
+            break;
+        case TOOL_P_MINUS_A:
+            computeRollingAverage (image, data, planesize, bias, OpPequalsPminusA(), HistogramNull());
+            break;
+        case TOOL_A_MINUS_P:
+            computeRollingAverage (image, data, planesize, bias, OpPequalsAminusP(), HistogramNull());
+            break;
+        case TOOL_P_PLUS_A:
+            computeRollingAverage (image, data, planesize, bias, OpPequalsPplusA(), HistogramNull());
+            break;
+        case TOOL_P_TIMES_A:
+            computeRollingAverage (image, data, planesize, bias, OpPequalsPtimesA(), HistogramNull());
+            break;
+        case TOOL_P_DIVBY_A:
+            computeRollingAverage (image, data, planesize, bias, OpPequalsPdivByA(), HistogramNull());
+            break;
+        case TOOL_A_DIVBY_P:
+            computeRollingAverage (image, data, planesize, bias, OpPequalsAdivByP(), HistogramNull());
+            break;
+        case TOOL_MIN_P_A:
+            computeRollingAverage (image, data, planesize, bias, OpPequalsMinPA(), HistogramNull());
+            break;
+        case TOOL_MAX_P_A:
+            computeRollingAverage (image, data, planesize, bias, OpPequalsMaxPA(), HistogramNull());
+            break;
+
+        case TOOL_A_WITH_HISTOGRAM:
+            computeRollingAverage (image, data, planesize, bias, OpPequalsA(), *histogram);
+            break;
+        case TOOL_P_WITH_HISTOGRAM: // HERE: we could optimize this if we wanted to
+            computeRollingAverage (image, data, planesize, bias, OpPequalsP(), *histogram);
+            break;
+        case TOOL_P_MINUS_A_WITH_HISTOGRAM:
+            computeRollingAverage (image, data, planesize, bias, OpPequalsPminusA(), *histogram);
+            break;
+        case TOOL_A_MINUS_P_WITH_HISTOGRAM:
+            computeRollingAverage (image, data, planesize, bias, OpPequalsAminusP(), *histogram);
+            break;
+        case TOOL_P_PLUS_A_WITH_HISTOGRAM:
+            computeRollingAverage (image, data, planesize, bias, OpPequalsPplusA(), *histogram);
+            break;
+        case TOOL_P_TIMES_A_WITH_HISTOGRAM:
+            computeRollingAverage (image, data, planesize, bias, OpPequalsPtimesA(), *histogram);
+            break;
+        case TOOL_P_DIVBY_A_WITH_HISTOGRAM:
+            computeRollingAverage (image, data, planesize, bias, OpPequalsPdivByA(), *histogram);
+            break;
+        case TOOL_A_DIVBY_P_WITH_HISTOGRAM:
+            computeRollingAverage (image, data, planesize, bias, OpPequalsAdivByP(), *histogram);
+            break;
+        case TOOL_MIN_P_A_WITH_HISTOGRAM:
+            computeRollingAverage (image, data, planesize, bias, OpPequalsMinPA(), *histogram);
+            break;
+        case TOOL_MAX_P_A_WITH_HISTOGRAM:
+            computeRollingAverage (image, data, planesize, bias, OpPequalsMaxPA(), *histogram);
+            break;
+
+        case TOOL_A_SCALED:
+            computeRollingAverage (image, data, planesize, bias,
+                                   OpPequalsA_Scaled (scale_min, scale_max),
+                                   HistogramNull());
+            break;
+        case TOOL_P_SCALED: // HERE_SCALED: we could optimize this if we wanted to
+            computeRollingAverage (image, data, planesize, bias,
+                                   OpPequalsP_Scaled (scale_min, scale_max),
+                                   HistogramNull());
+            break;
+        case TOOL_P_MINUS_A_SCALED:
+            computeRollingAverage (image, data, planesize, bias,
+                                   OpPequalsPminusA_Scaled (scale_min, scale_max),
+                                   HistogramNull());
+            break;
+        case TOOL_A_MINUS_P_SCALED:
+            computeRollingAverage (image, data, planesize, bias,
+                                   OpPequalsAminusP_Scaled (scale_min, scale_max),
+                                   HistogramNull());
+            break;
+        case TOOL_P_PLUS_A_SCALED:
+            computeRollingAverage (image, data, planesize, bias,
+                                   OpPequalsPplusA_Scaled (scale_min, scale_max),
+                                   HistogramNull());
+            break;
+        case TOOL_P_TIMES_A_SCALED:
+            computeRollingAverage (image, data, planesize, bias,
+                                   OpPequalsPtimesA_Scaled (scale_min, scale_max),
+                                   HistogramNull());
+            break;
+        case TOOL_P_DIVBY_A_SCALED:
+            computeRollingAverage (image, data, planesize, bias,
+                                   OpPequalsPdivByA_Scaled (scale_min, scale_max),
+                                   HistogramNull());
+            break;
+        case TOOL_A_DIVBY_P_SCALED:
+            computeRollingAverage (image, data, planesize, bias,
+                                   OpPequalsAdivByP_Scaled (scale_min, scale_max),
+                                   HistogramNull());
+            break;
+        case TOOL_MIN_P_A_SCALED:
+            computeRollingAverage (image, data, planesize, bias,
+                                   OpPequalsMinPA_Scaled (scale_min, scale_max),
+                                   HistogramNull());
+            break;
+        case TOOL_MAX_P_A_SCALED:
+            computeRollingAverage (image, data, planesize, bias,
+                                   OpPequalsMaxPA_Scaled (scale_min, scale_max),
+                                   HistogramNull());
+            break;
+
+        case TOOL_A_SCALED_WITH_HISTOGRAM:
+            computeRollingAverage (image, data, planesize, bias,
+                                   OpPequalsA_Scaled (scale_min, scale_max),
+                                   *histogram);
+            break;
+        case TOOL_P_SCALED_WITH_HISTOGRAM: // HERE: we could optimize this if we wanted to
+            computeRollingAverage (image, data, planesize, bias,
+                                   OpPequalsP_Scaled (scale_min, scale_max),
+                                   *histogram);
+            break;
+        case TOOL_P_MINUS_A_SCALED_WITH_HISTOGRAM:
+            computeRollingAverage (image, data, planesize, bias,
+                                   OpPequalsPminusA_Scaled (scale_min, scale_max),
+                                   *histogram);
+            break;
+        case TOOL_A_MINUS_P_SCALED_WITH_HISTOGRAM:
+            computeRollingAverage (image, data, planesize, bias,
+                                   OpPequalsAminusP_Scaled (scale_min, scale_max),
+                                   *histogram);
+            break;
+        case TOOL_P_PLUS_A_SCALED_WITH_HISTOGRAM:
+            computeRollingAverage (image, data, planesize, bias,
+                                   OpPequalsPplusA_Scaled (scale_min, scale_max),
+                                   *histogram);
+            break;
+        case TOOL_P_TIMES_A_SCALED_WITH_HISTOGRAM:
+            computeRollingAverage (image, data, planesize, bias,
+                                   OpPequalsPtimesA_Scaled (scale_min, scale_max),
+                                   *histogram);
+            break;
+        case TOOL_P_DIVBY_A_SCALED_WITH_HISTOGRAM:
+            computeRollingAverage (image, data, planesize, bias,
+                                   OpPequalsPdivByA_Scaled (scale_min, scale_max),
+                                   *histogram);
+            break;
+        case TOOL_A_DIVBY_P_SCALED_WITH_HISTOGRAM:
+            computeRollingAverage (image, data, planesize, bias,
+                                   OpPequalsAdivByP_Scaled (scale_min, scale_max),
+                                   *histogram);
+            break;
+        case TOOL_MIN_P_A_SCALED_WITH_HISTOGRAM:
+            computeRollingAverage (image, data, planesize, bias,
+                                   OpPequalsMinPA_Scaled (scale_min, scale_max),
+                                   *histogram);
+            break;
+        case TOOL_MAX_P_A_SCALED_WITH_HISTOGRAM:
+            computeRollingAverage (image, data, planesize, bias,
+                                   OpPequalsMaxPA_Scaled (scale_min, scale_max),
+                                   *histogram);
+            break;
+
+        default:
+            printf (&quot;SwissArmyKnife: unknown operation (tool) %d!\n&quot;,
+                    _param-&gt;tool);
+            return 0;
+        }
+    }
+    else if (doingFileImageFloat)
+    {
+        if (w != myInfo-&gt;image_w || h != myInfo-&gt;image_h)
+        {
+            const char * bar = &quot;*************************&quot;;
+            printf (&quot;\n%s%s%s\nAttempting to apply a %ux%u input image to &quot;
+                    &quot;%ux%u video - even if I could do that, it probably &quot;
+                    &quot;wouldn't be what you wanted...\n%s%s%s\n&quot;,
+                    bar, bar, bar, myInfo-&gt;image_w, myInfo-&gt;image_h,
+                    w, h, bar, bar, bar);
+            return 0;
+        }
+
+        float * flt_img = myInfo-&gt;image_float;
+
+        switch (tool)
+        {
+        case TOOL_A:
+            applyImage (image, data, planesize, bias, flt_img, OpPequalsA(), HistogramNull());
+            break;
+        case TOOL_P: // HERE: we could optimize this if we wanted to
+            applyImage (image, data, planesize, bias, flt_img, OpPequalsP(), HistogramNull());
+            break;
+        case TOOL_P_MINUS_A:
+            applyImage (image, data, planesize, bias, flt_img, OpPequalsPminusA(), HistogramNull());
+            break;
+        case TOOL_A_MINUS_P:
+            applyImage (image, data, planesize, bias, flt_img, OpPequalsAminusP(), HistogramNull());
+            break;
+        case TOOL_P_PLUS_A:
+            applyImage (image, data, planesize, bias, flt_img, OpPequalsPplusA(), HistogramNull());
+            break;
+        case TOOL_P_TIMES_A:
+            applyImage (image, data, planesize, bias, flt_img, OpPequalsPtimesA(), HistogramNull());
+            break;
+        case TOOL_P_DIVBY_A:
+            applyImage (image, data, planesize, bias, flt_img, OpPequalsPdivByA(), HistogramNull());
+            break;
+        case TOOL_A_DIVBY_P:
+            applyImage (image, data, planesize, bias, flt_img, OpPequalsAdivByP(), HistogramNull());
+            break;
+        case TOOL_MIN_P_A:
+            applyImage (image, data, planesize, bias, flt_img, OpPequalsMinPA(), HistogramNull());
+            break;
+        case TOOL_MAX_P_A:
+            applyImage (image, data, planesize, bias, flt_img, OpPequalsMaxPA(), HistogramNull());
+            break;
+
+        case TOOL_A_WITH_HISTOGRAM:
+            applyImage (image, data, planesize, bias, flt_img, OpPequalsA(), *histogram);
+            break;
+        case TOOL_P_WITH_HISTOGRAM: // HERE: we could optimize this if we wanted to
+            applyImage (image, data, planesize, bias, flt_img, OpPequalsP(), *histogram);
+            break;
+        case TOOL_P_MINUS_A_WITH_HISTOGRAM:
+            applyImage (image, data, planesize, bias, flt_img, OpPequalsPminusA(), *histogram);
+            break;
+        case TOOL_A_MINUS_P_WITH_HISTOGRAM:
+            applyImage (image, data, planesize, bias, flt_img, OpPequalsAminusP(), *histogram);
+            break;
+        case TOOL_P_PLUS_A_WITH_HISTOGRAM:
+            applyImage (image, data, planesize, bias, flt_img, OpPequalsPplusA(), *histogram);
+            break;
+        case TOOL_P_TIMES_A_WITH_HISTOGRAM:
+            applyImage (image, data, planesize, bias, flt_img, OpPequalsPtimesA(), *histogram);
+            break;
+        case TOOL_P_DIVBY_A_WITH_HISTOGRAM:
+            applyImage (image, data, planesize, bias, flt_img, OpPequalsPdivByA(), *histogram);
+            break;
+        case TOOL_A_DIVBY_P_WITH_HISTOGRAM:
+            applyImage (image, data, planesize, bias, flt_img, OpPequalsAdivByP(), *histogram);
+            break;
+        case TOOL_MIN_P_A_WITH_HISTOGRAM:
+            applyImage (image, data, planesize, bias, flt_img, OpPequalsMinPA(), *histogram);
+            break;
+        case TOOL_MAX_P_A_WITH_HISTOGRAM:
+            applyImage (image, data, planesize, bias, flt_img, OpPequalsMaxPA(), *histogram);
+            break;
+
+        case TOOL_A_SCALED:
+            applyImage (image, data, planesize, bias, flt_img,
+                           OpPequalsA_Scaled (scale_min, scale_max),
+                           HistogramNull());
+            break;
+        case TOOL_P_SCALED: // HERE_SCALED: we could optimize this if we wanted to
+            applyImage (image, data, planesize, bias, flt_img,
+                           OpPequalsP_Scaled (scale_min, scale_max),
+                           HistogramNull());
+            break;
+        case TOOL_P_MINUS_A_SCALED:
+            applyImage (image, data, planesize, bias, flt_img,
+                           OpPequalsPminusA_Scaled (scale_min, scale_max),
+                           HistogramNull());
+            break;
+        case TOOL_A_MINUS_P_SCALED:
+            applyImage (image, data, planesize, bias, flt_img,
+                           OpPequalsAminusP_Scaled (scale_min, scale_max),
+                           HistogramNull());
+            break;
+        case TOOL_P_PLUS_A_SCALED:
+            applyImage (image, data, planesize, bias, flt_img,
+                           OpPequalsPplusA_Scaled (scale_min, scale_max),
+                           HistogramNull());
+            break;
+        case TOOL_P_TIMES_A_SCALED:
+            applyImage (image, data, planesize, bias, flt_img,
+                           OpPequalsPtimesA_Scaled (scale_min, scale_max),
+                           HistogramNull());
+            break;
+        case TOOL_P_DIVBY_A_SCALED:
+            applyImage (image, data, planesize, bias, flt_img,
+                           OpPequalsPdivByA_Scaled (scale_min, scale_max),
+                           HistogramNull());
+            break;
+        case TOOL_A_DIVBY_P_SCALED:
+            applyImage (image, data, planesize, bias, flt_img,
+                           OpPequalsAdivByP_Scaled (scale_min, scale_max),
+                           HistogramNull());
+            break;
+        case TOOL_MIN_P_A_SCALED:
+            applyImage (image, data, planesize, bias, flt_img,
+                           OpPequalsMinPA_Scaled (scale_min, scale_max),
+                           HistogramNull());
+            break;
+        case TOOL_MAX_P_A_SCALED:
+            applyImage (image, data, planesize, bias, flt_img,
+                           OpPequalsMaxPA_Scaled (scale_min, scale_max),
+                           HistogramNull());
+            break;
+
+        case TOOL_A_SCALED_WITH_HISTOGRAM:
+            applyImage (image, data, planesize, bias, flt_img,
+                           OpPequalsA_Scaled (scale_min, scale_max),
+                           *histogram);
+            break;
+        case TOOL_P_SCALED_WITH_HISTOGRAM: // HERE: we could optimize this if we wanted to
+            applyImage (image, data, planesize, bias, flt_img,
+                           OpPequalsP_Scaled (scale_min, scale_max),
+                           *histogram);
+            break;
+        case TOOL_P_MINUS_A_SCALED_WITH_HISTOGRAM:
+            applyImage (image, data, planesize, bias, flt_img,
+                           OpPequalsPminusA_Scaled (scale_min, scale_max),
+                           *histogram);
+            break;
+        case TOOL_A_MINUS_P_SCALED_WITH_HISTOGRAM:
+            applyImage (image, data, planesize, bias, flt_img,
+                           OpPequalsAminusP_Scaled (scale_min, scale_max),
+                           *histogram);
+            break;
+        case TOOL_P_PLUS_A_SCALED_WITH_HISTOGRAM:
+            applyImage (image, data, planesize, bias, flt_img,
+                           OpPequalsPplusA_Scaled (scale_min, scale_max),
+                           *histogram);
+            break;
+        case TOOL_P_TIMES_A_SCALED_WITH_HISTOGRAM:
+            applyImage (image, data, planesize, bias, flt_img,
+                           OpPequalsPtimesA_Scaled (scale_min, scale_max),
+                           *histogram);
+            break;
+        case TOOL_P_DIVBY_A_SCALED_WITH_HISTOGRAM:
+            applyImage (image, data, planesize, bias, flt_img,
+                           OpPequalsPdivByA_Scaled (scale_min, scale_max),
+                           *histogram);
+            break;
+        case TOOL_A_DIVBY_P_SCALED_WITH_HISTOGRAM:
+            applyImage (image, data, planesize, bias, flt_img,
+                           OpPequalsAdivByP_Scaled (scale_min, scale_max),
+                           *histogram);
+            break;
+        case TOOL_MIN_P_A_SCALED_WITH_HISTOGRAM:
+            applyImage (image, data, planesize, bias, flt_img,
+                           OpPequalsMinPA_Scaled (scale_min, scale_max),
+                           *histogram);
+            break;
+        case TOOL_MAX_P_A_SCALED_WITH_HISTOGRAM:
+            applyImage (image, data, planesize, bias, flt_img,
+                           OpPequalsMaxPA_Scaled (scale_min, scale_max),
+                           *histogram);
+            break;
+
+        default:
+            printf (&quot;SwissArmyKnife: unknown operation (tool) %d!\n&quot;,
+                    _param-&gt;tool);
+            return 0;
+        }
+    }
+    else if (doingFileImage)
+    {
+        if (w != myInfo-&gt;image_w || h != myInfo-&gt;image_h)
+        {
+            const char * bar = &quot;*************************&quot;;
+            printf (&quot;\n%s%s%s\nAttempting to apply a %ux%u input image to &quot;
+                    &quot;%ux%u video - even if I could do that, it probably &quot;
+                    &quot;wouldn't be what you wanted...\n%s%s%s\n&quot;,
+                    bar, bar, bar, myInfo-&gt;image_w, myInfo-&gt;image_h,
+                    w, h, bar, bar, bar);
+            return 0;
+        }
+
+        uint8_t * int_img = myInfo-&gt;image_int;
+
+        switch (tool)
+        {
+        case TOOL_A:
+            applyImage (image, data, planesize, bias, int_img, OpPequalsA(), HistogramNull());
+            break;
+        case TOOL_P: // HERE: we could optimize this if we wanted to
+            applyImage (image, data, planesize, bias, int_img, OpPequalsP(), HistogramNull());
+            break;
+        case TOOL_P_MINUS_A:
+            applyImage (image, data, planesize, bias, int_img, OpPequalsPminusA(), HistogramNull());
+            break;
+        case TOOL_A_MINUS_P:
+            applyImage (image, data, planesize, bias, int_img, OpPequalsAminusP(), HistogramNull());
+            break;
+        case TOOL_P_PLUS_A:
+            applyImage (image, data, planesize, bias, int_img, OpPequalsPplusA(), HistogramNull());
+            break;
+        case TOOL_P_TIMES_A:
+            applyImage (image, data, planesize, bias, int_img, OpPequalsPtimesA(), HistogramNull());
+            break;
+        case TOOL_P_DIVBY_A:
+            applyImage (image, data, planesize, bias, int_img, OpPequalsPdivByA(), HistogramNull());
+            break;
+        case TOOL_A_DIVBY_P:
+            applyImage (image, data, planesize, bias, int_img, OpPequalsAdivByP(), HistogramNull());
+            break;
+        case TOOL_MIN_P_A:
+            applyImage (image, data, planesize, bias, int_img, OpPequalsMinPA(), HistogramNull());
+            break;
+        case TOOL_MAX_P_A:
+            applyImage (image, data, planesize, bias, int_img, OpPequalsMaxPA(), HistogramNull());
+            break;
+
+        case TOOL_A_WITH_HISTOGRAM:
+            applyImage (image, data, planesize, bias, int_img, OpPequalsA(), *histogram);
+            break;
+        case TOOL_P_WITH_HISTOGRAM: // HERE: we could optimize this if we wanted to
+            applyImage (image, data, planesize, bias, int_img, OpPequalsP(), *histogram);
+            break;
+        case TOOL_P_MINUS_A_WITH_HISTOGRAM:
+            applyImage (image, data, planesize, bias, int_img, OpPequalsPminusA(), *histogram);
+            break;
+        case TOOL_A_MINUS_P_WITH_HISTOGRAM:
+            applyImage (image, data, planesize, bias, int_img, OpPequalsAminusP(), *histogram);
+            break;
+        case TOOL_P_PLUS_A_WITH_HISTOGRAM:
+            applyImage (image, data, planesize, bias, int_img, OpPequalsPplusA(), *histogram);
+            break;
+        case TOOL_P_TIMES_A_WITH_HISTOGRAM:
+            applyImage (image, data, planesize, bias, int_img, OpPequalsPtimesA(), *histogram);
+            break;
+        case TOOL_P_DIVBY_A_WITH_HISTOGRAM:
+            applyImage (image, data, planesize, bias, int_img, OpPequalsPdivByA(), *histogram);
+            break;
+        case TOOL_A_DIVBY_P_WITH_HISTOGRAM:
+            applyImage (image, data, planesize, bias, int_img, OpPequalsAdivByP(), *histogram);
+            break;
+        case TOOL_MIN_P_A_WITH_HISTOGRAM:
+            applyImage (image, data, planesize, bias, int_img, OpPequalsMinPA(), *histogram);
+            break;
+        case TOOL_MAX_P_A_WITH_HISTOGRAM:
+            applyImage (image, data, planesize, bias, int_img, OpPequalsMaxPA(), *histogram);
+            break;
+
+        case TOOL_A_SCALED:
+            applyImage (image, data, planesize, bias, int_img,
+                        OpPequalsA_Scaled (scale_min, scale_max),
+                        HistogramNull());
+            break;
+        case TOOL_P_SCALED: // HERE_SCALED: we could optimize this if we wanted to
+            applyImage (image, data, planesize, bias, int_img,
+                        OpPequalsP_Scaled (scale_min, scale_max),
+                        HistogramNull());
+            break;
+        case TOOL_P_MINUS_A_SCALED:
+            applyImage (image, data, planesize, bias, int_img,
+                        OpPequalsPminusA_Scaled (scale_min, scale_max),
+                        HistogramNull());
+            break;
+        case TOOL_A_MINUS_P_SCALED:
+            applyImage (image, data, planesize, bias, int_img,
+                        OpPequalsAminusP_Scaled (scale_min, scale_max),
+                        HistogramNull());
+            break;
+        case TOOL_P_PLUS_A_SCALED:
+            applyImage (image, data, planesize, bias, int_img,
+                        OpPequalsPplusA_Scaled (scale_min, scale_max),
+                        HistogramNull());
+            break;
+        case TOOL_P_TIMES_A_SCALED:
+            applyImage (image, data, planesize, bias, int_img,
+                        OpPequalsPtimesA_Scaled (scale_min, scale_max),
+                        HistogramNull());
+            break;
+        case TOOL_P_DIVBY_A_SCALED:
+            applyImage (image, data, planesize, bias, int_img,
+                        OpPequalsPdivByA_Scaled (scale_min, scale_max),
+                        HistogramNull());
+            break;
+        case TOOL_A_DIVBY_P_SCALED:
+            applyImage (image, data, planesize, bias, int_img,
+                        OpPequalsAdivByP_Scaled (scale_min, scale_max),
+                        HistogramNull());
+            break;
+        case TOOL_MIN_P_A_SCALED:
+            applyImage (image, data, planesize, bias, int_img,
+                        OpPequalsMinPA_Scaled (scale_min, scale_max),
+                        HistogramNull());
+            break;
+        case TOOL_MAX_P_A_SCALED:
+            applyImage (image, data, planesize, bias, int_img,
+                        OpPequalsMaxPA_Scaled (scale_min, scale_max),
+                        HistogramNull());
+            break;
+
+        case TOOL_A_SCALED_WITH_HISTOGRAM:
+            applyImage (image, data, planesize, bias, int_img,
+                        OpPequalsA_Scaled (scale_min, scale_max),
+                        *histogram);
+            break;
+        case TOOL_P_SCALED_WITH_HISTOGRAM: // HERE: we could optimize this if we wanted to
+            applyImage (image, data, planesize, bias, int_img,
+                        OpPequalsP_Scaled (scale_min, scale_max),
+                        *histogram);
+            break;
+        case TOOL_P_MINUS_A_SCALED_WITH_HISTOGRAM:
+            applyImage (image, data, planesize, bias, int_img,
+                        OpPequalsPminusA_Scaled (scale_min, scale_max),
+                        *histogram);
+            break;
+        case TOOL_A_MINUS_P_SCALED_WITH_HISTOGRAM:
+            applyImage (image, data, planesize, bias, int_img,
+                        OpPequalsAminusP_Scaled (scale_min, scale_max),
+                        *histogram);
+            break;
+        case TOOL_P_PLUS_A_SCALED_WITH_HISTOGRAM:
+            applyImage (image, data, planesize, bias, int_img,
+                        OpPequalsPplusA_Scaled (scale_min, scale_max),
+                        *histogram);
+            break;
+        case TOOL_P_TIMES_A_SCALED_WITH_HISTOGRAM:
+            applyImage (image, data, planesize, bias, int_img,
+                        OpPequalsPtimesA_Scaled (scale_min, scale_max),
+                        *histogram);
+            break;
+        case TOOL_P_DIVBY_A_SCALED_WITH_HISTOGRAM:
+            applyImage (image, data, planesize, bias, int_img,
+                        OpPequalsPdivByA_Scaled (scale_min, scale_max),
+                        *histogram);
+            break;
+        case TOOL_A_DIVBY_P_SCALED_WITH_HISTOGRAM:
+            applyImage (image, data, planesize, bias, int_img,
+                        OpPequalsAdivByP_Scaled (scale_min, scale_max),
+                        *histogram);
+            break;
+        case TOOL_MIN_P_A_SCALED_WITH_HISTOGRAM:
+            applyImage (image, data, planesize, bias, int_img,
+                        OpPequalsMinPA_Scaled (scale_min, scale_max),
+                        *histogram);
+            break;
+        case TOOL_MAX_P_A_SCALED_WITH_HISTOGRAM:
+            applyImage (image, data, planesize, bias, int_img,
+                        OpPequalsMaxPA_Scaled (scale_min, scale_max),
+                        *histogram);
+            break;
+
+        default:
+            printf (&quot;SwissArmyKnife: unknown operation (tool) %d!\n&quot;,
+                    _param-&gt;tool);
+            return 0;
+        }
+    }
+    else if (doingApplyConstant)
+    {
+        switch (tool)
+        {
+        case TOOL_A:
+            applyConstant (image, data, planesize, bias, OpPequalsA(), HistogramNull());
+            break;
+        case TOOL_P: // HERE: we could optimize this if we wanted to
+            applyConstant (image, data, planesize, bias, OpPequalsP(), HistogramNull());
+            break;
+        case TOOL_P_MINUS_A:
+            applyConstant (image, data, planesize, bias, OpPequalsPminusA(), HistogramNull());
+            break;
+        case TOOL_A_MINUS_P:
+            applyConstant (image, data, planesize, bias, OpPequalsAminusP(), HistogramNull());
+            break;
+        case TOOL_P_PLUS_A:
+            applyConstant (image, data, planesize, bias, OpPequalsPplusA(), HistogramNull());
+            break;
+        case TOOL_P_TIMES_A:
+            applyConstant (image, data, planesize, bias, OpPequalsPtimesA(), HistogramNull());
+            break;
+        case TOOL_P_DIVBY_A:
+            applyConstant (image, data, planesize, bias, OpPequalsPdivByA(), HistogramNull());
+            break;
+        case TOOL_A_DIVBY_P:
+            applyConstant (image, data, planesize, bias, OpPequalsAdivByP(), HistogramNull());
+            break;
+        case TOOL_MIN_P_A:
+            applyConstant (image, data, planesize, bias, OpPequalsMinPA(), HistogramNull());
+            break;
+        case TOOL_MAX_P_A:
+            applyConstant (image, data, planesize, bias, OpPequalsMaxPA(), HistogramNull());
+            break;
+
+        case TOOL_A_WITH_HISTOGRAM:
+            applyConstant (image, data, planesize, bias, OpPequalsA(), *histogram);
+            break;
+        case TOOL_P_WITH_HISTOGRAM: // HERE: we could optimize this if we wanted to
+            applyConstant (image, data, planesize, bias, OpPequalsP(), *histogram);
+            break;
+        case TOOL_P_MINUS_A_WITH_HISTOGRAM:
+            applyConstant (image, data, planesize, bias, OpPequalsPminusA(), *histogram);
+            break;
+        case TOOL_A_MINUS_P_WITH_HISTOGRAM:
+            applyConstant (image, data, planesize, bias, OpPequalsAminusP(), *histogram);
+            break;
+        case TOOL_P_PLUS_A_WITH_HISTOGRAM:
+            applyConstant (image, data, planesize, bias, OpPequalsPplusA(), *histogram);
+            break;
+        case TOOL_P_TIMES_A_WITH_HISTOGRAM:
+            applyConstant (image, data, planesize, bias, OpPequalsPtimesA(), *histogram);
+            break;
+        case TOOL_P_DIVBY_A_WITH_HISTOGRAM:
+            applyConstant (image, data, planesize, bias, OpPequalsPdivByA(), *histogram);
+            break;
+        case TOOL_A_DIVBY_P_WITH_HISTOGRAM:
+            applyConstant (image, data, planesize, bias, OpPequalsAdivByP(), *histogram);
+            break;
+        case TOOL_MIN_P_A_WITH_HISTOGRAM:
+            applyConstant (image, data, planesize, bias, OpPequalsMinPA(), *histogram);
+            break;
+        case TOOL_MAX_P_A_WITH_HISTOGRAM:
+            applyConstant (image, data, planesize, bias, OpPequalsMaxPA(), *histogram);
+            break;
+
+        case TOOL_A_SCALED:
+            applyConstant (image, data, planesize, bias,
+                           OpPequalsA_Scaled (scale_min, scale_max),
+                           HistogramNull());
+            break;
+        case TOOL_P_SCALED: // HERE_SCALED: we could optimize this if we wanted to
+            applyConstant (image, data, planesize, bias,
+                           OpPequalsP_Scaled (scale_min, scale_max),
+                           HistogramNull());
+            break;
+        case TOOL_P_MINUS_A_SCALED:
+            applyConstant (image, data, planesize, bias,
+                           OpPequalsPminusA_Scaled (scale_min, scale_max),
+                           HistogramNull());
+            break;
+        case TOOL_A_MINUS_P_SCALED:
+            applyConstant (image, data, planesize, bias,
+                           OpPequalsAminusP_Scaled (scale_min, scale_max),
+                           HistogramNull());
+            break;
+        case TOOL_P_PLUS_A_SCALED:
+            applyConstant (image, data, planesize, bias,
+                           OpPequalsPplusA_Scaled (scale_min, scale_max),
+                           HistogramNull());
+            break;
+        case TOOL_P_TIMES_A_SCALED:
+            applyConstant (image, data, planesize, bias,
+                           OpPequalsPtimesA_Scaled (scale_min, scale_max),
+                           HistogramNull());
+            break;
+        case TOOL_P_DIVBY_A_SCALED:
+            applyConstant (image, data, planesize, bias,
+                           OpPequalsPdivByA_Scaled (scale_min, scale_max),
+                           HistogramNull());
+            break;
+        case TOOL_A_DIVBY_P_SCALED:
+            applyConstant (image, data, planesize, bias,
+                           OpPequalsAdivByP_Scaled (scale_min, scale_max),
+                           HistogramNull());
+            break;
+        case TOOL_MIN_P_A_SCALED:
+            applyConstant (image, data, planesize, bias,
+                           OpPequalsMinPA_Scaled (scale_min, scale_max),
+                           HistogramNull());
+            break;
+        case TOOL_MAX_P_A_SCALED:
+            applyConstant (image, data, planesize, bias,
+                           OpPequalsMaxPA_Scaled (scale_min, scale_max),
+                           HistogramNull());
+            break;
+
+        case TOOL_A_SCALED_WITH_HISTOGRAM:
+            applyConstant (image, data, planesize, bias,
+                           OpPequalsA_Scaled (scale_min, scale_max),
+                           *histogram);
+            break;
+        case TOOL_P_SCALED_WITH_HISTOGRAM: // HERE: we could optimize this if we wanted to
+            applyConstant (image, data, planesize, bias,
+                           OpPequalsP_Scaled (scale_min, scale_max),
+                           *histogram);
+            break;
+        case TOOL_P_MINUS_A_SCALED_WITH_HISTOGRAM:
+            applyConstant (image, data, planesize, bias,
+                           OpPequalsPminusA_Scaled (scale_min, scale_max),
+                           *histogram);
+            break;
+        case TOOL_A_MINUS_P_SCALED_WITH_HISTOGRAM:
+            applyConstant (image, data, planesize, bias,
+                           OpPequalsAminusP_Scaled (scale_min, scale_max),
+                           *histogram);
+            break;
+        case TOOL_P_PLUS_A_SCALED_WITH_HISTOGRAM:
+            applyConstant (image, data, planesize, bias,
+                           OpPequalsPplusA_Scaled (scale_min, scale_max),
+                           *histogram);
+            break;
+        case TOOL_P_TIMES_A_SCALED_WITH_HISTOGRAM:
+            applyConstant (image, data, planesize, bias,
+                           OpPequalsPtimesA_Scaled (scale_min, scale_max),
+                           *histogram);
+            break;
+        case TOOL_P_DIVBY_A_SCALED_WITH_HISTOGRAM:
+            applyConstant (image, data, planesize, bias,
+                           OpPequalsPdivByA_Scaled (scale_min, scale_max),
+                           *histogram);
+            break;
+        case TOOL_A_DIVBY_P_SCALED_WITH_HISTOGRAM:
+            applyConstant (image, data, planesize, bias,
+                           OpPequalsAdivByP_Scaled (scale_min, scale_max),
+                           *histogram);
+            break;
+        case TOOL_MIN_P_A_SCALED_WITH_HISTOGRAM:
+            applyConstant (image, data, planesize, bias,
+                           OpPequalsMinPA_Scaled (scale_min, scale_max),
+                           *histogram);
+            break;
+        case TOOL_MAX_P_A_SCALED_WITH_HISTOGRAM:
+            applyConstant (image, data, planesize, bias,
+                           OpPequalsMaxPA_Scaled (scale_min, scale_max),
+                           *histogram);
+            break;
+
+        default:
+            printf (&quot;SwissArmyKnife: unknown operation (tool) %d!\n&quot;,
+                    _param-&gt;tool);
+            return 0;
+        }
+    }
+    else
+    {
+        printf (&quot;ooops!  input selection botch in SwissArmyKnife!\n&quot;);
+        return 0;
+    }
+
+    if (histogram)
+    {
+        histogram-&gt;frame_check();
+        delete histogram;
+    }
+
+    // HERE: the following two lines do a luma-only-ize
+
+    memset (UPLANE (data), 128, planesize &gt;&gt; 2);
+    memset (VPLANE (data), 128, planesize &gt;&gt; 2);
+
+    data-&gt;copyInfo(image);
+    return 1;
+}	                           

Added: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidSwissArmyKnife.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidSwissArmyKnife.h	2007-08-30 18:42:41 UTC (rev 3574)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidSwissArmyKnife.h	2007-08-31 16:18:20 UTC (rev 3575)
@@ -0,0 +1,264 @@
+/***************************************************************************
+                          ADM_vidSwissArmyKnife.h  -  Perform one of many
+                                                      possible operations
+                             -------------------
+                          Chris MacGregor, 2005, 2007
+                         <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">chris-avidemux at bouncingdog.com</A>
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+ 
+#ifndef __SWISSARMYKNIFE__
+#define __SWISSARMYKNIFE__   
+
+#include &lt;map&gt;
+
+#include &quot;ADM_video/ADM_cache.h&quot;
+
+#include &lt;vector&gt;
+#include &lt;string&gt;
+
+#include &lt;sys/time.h&gt;
+
+struct SWISSARMYKNIFE_PARAM
+{
+    uint32_t tool; // ADMVideoSwissArmyKnife::Tool
+    uint32_t input_type; // ADMVideoSwissArmyKnife::Input
+
+    const char * input_file;
+    float load_bias;
+    float load_multiplier;
+
+    float input_constant;
+
+    uint32_t memory_constant_denom;
+    uint32_t init_start_frame;
+    uint32_t init_end_frame;
+    uint32_t init_by_rolling;
+
+    int32_t  bias;
+    int32_t  scale_from_min;
+    int32_t  scale_from_max;
+    uint32_t histogram_frame_interval;
+    uint32_t debug;
+
+};
+
+class ADMVideoSwissArmyKnife : public AVDMGenericVideoStream
+{
+protected:
+    	
+    // This is a hack to work around the fact that the ctor &amp; dtor get called
+    // too often.  The right solution would be to arrange for the filter
+    // objects to be constructed and destructed only when really necessary:
+    // when a new instance of a filter is added to the list (by the user), it
+    // is constructed, and when it is removed from the list (by the user), it
+    // is destructed, and anything else is handled by a separate init() or
+    // configure() method.  This would allow the objects to maintain a
+    // persistent state in a more straightforward way.
+
+    typedef std::vector &lt;float&gt; FloatVector;
+
+    class PersistentInfo
+    {
+    public:
+        CONFcouple *  conf;
+        CONFcouple *  oldConf;
+        uint32_t      refCount;
+
+        FloatVector   kernel;
+        uint32_t      kernel_w;
+        uint32_t      kernel_h;
+
+        uint32_t      image_w;
+        uint32_t      image_h;
+        uint8_t *     image_int;
+        float *       image_float;
+
+        std::string   input_file_name;
+        time_t        input_file_mtime;
+
+        float *       bg;
+        uint32_t      bg_mc;
+        uint32_t      bg_isf;
+        uint32_t      bg_ief;
+        uint32_t      bg_x;
+        uint32_t      bg_y;
+
+        uint32_t      histogram_frame_interval;
+        uint32_t *    histogram_input_data;
+        uint32_t *    histogram_output_data;
+        uint32_t      histogram_frame_count;
+
+        bool          bg_ibr;
+        bool          histogram_data_invalid;
+        bool          image_data_invalid;
+
+        PersistentInfo ()
+            : conf (0),
+              oldConf (0),
+              refCount (0),
+
+              kernel_w (0),
+              kernel_h (0),
+
+              image_w (0),
+              image_h (0),
+              image_int (0),
+              image_float (0),
+
+              input_file_mtime (0),
+
+              bg (0),
+              bg_mc (0),
+              bg_isf (0),
+              bg_ief (0),
+              bg_x (0),
+              bg_y (0),
+
+              histogram_frame_interval (0),
+              histogram_input_data (0),
+              histogram_output_data (0),
+              histogram_frame_count (0),
+
+              bg_ibr (false),
+              histogram_data_invalid (false),
+              image_data_invalid (false)
+        {
+        }
+
+        ~PersistentInfo ()
+        {
+            delete image_int;
+            delete image_float;
+            delete bg;
+            delete histogram_input_data;
+            delete histogram_output_data;
+        }
+    };
+
+    typedef std::map &lt;CONFcouple *, PersistentInfo *&gt; PImap;
+    static PImap pimap;
+
+    PersistentInfo * myInfo;
+
+    enum Input
+    {
+        INPUT_INVALID = 0,
+
+        INPUT_FILE_IMAGE_FLOAT,
+        INPUT_FILE_IMAGE_INTEGER,
+        INPUT_CUSTOM_CONVOLUTION,
+        INPUT_CONSTANT_VALUE,
+        INPUT_ROLLING_AVERAGE,
+
+        INPUT_COUNT
+    };
+
+    enum Tool
+    {
+        TOOL_INVALID = 0,
+
+        TOOL_A,          // P' = A
+        TOOL_P,          // P' = P
+        TOOL_P_MINUS_A,  // P' = P - A
+        TOOL_A_MINUS_P,  // P' = A - P
+        TOOL_P_PLUS_A,   // P' = P + A
+        TOOL_P_TIMES_A,  // P' = P * A
+        TOOL_P_DIVBY_A,  // P' = P / A
+        TOOL_A_DIVBY_P,  // P' = A / P
+        TOOL_MIN_P_A,    // P' = min (P, A)
+        TOOL_MAX_P_A,    // P' = max (P, A)
+
+        TOOL_A_WITH_HISTOGRAM,
+        TOOL_P_WITH_HISTOGRAM,
+        TOOL_P_MINUS_A_WITH_HISTOGRAM,
+        TOOL_A_MINUS_P_WITH_HISTOGRAM,
+        TOOL_P_PLUS_A_WITH_HISTOGRAM,
+        TOOL_P_TIMES_A_WITH_HISTOGRAM,
+        TOOL_P_DIVBY_A_WITH_HISTOGRAM,
+        TOOL_A_DIVBY_P_WITH_HISTOGRAM,
+        TOOL_MIN_P_A_WITH_HISTOGRAM,
+        TOOL_MAX_P_A_WITH_HISTOGRAM,
+
+        TOOL_A_SCALED,
+        TOOL_P_SCALED,
+        TOOL_P_MINUS_A_SCALED,
+        TOOL_A_MINUS_P_SCALED,
+        TOOL_P_PLUS_A_SCALED,
+        TOOL_P_TIMES_A_SCALED,
+        TOOL_P_DIVBY_A_SCALED,
+        TOOL_A_DIVBY_P_SCALED,
+        TOOL_MIN_P_A_SCALED,
+        TOOL_MAX_P_A_SCALED,
+
+        TOOL_A_SCALED_WITH_HISTOGRAM,
+        TOOL_P_SCALED_WITH_HISTOGRAM,
+        TOOL_P_MINUS_A_SCALED_WITH_HISTOGRAM,
+        TOOL_A_MINUS_P_SCALED_WITH_HISTOGRAM,
+        TOOL_P_PLUS_A_SCALED_WITH_HISTOGRAM,
+        TOOL_P_TIMES_A_SCALED_WITH_HISTOGRAM,
+        TOOL_P_DIVBY_A_SCALED_WITH_HISTOGRAM,
+        TOOL_A_DIVBY_P_SCALED_WITH_HISTOGRAM,
+        TOOL_MIN_P_A_SCALED_WITH_HISTOGRAM,
+        TOOL_MAX_P_A_SCALED_WITH_HISTOGRAM,
+
+        TOOL_TOTAL_COUNT,
+
+        TOOL_ADD_HISTOGRAM = TOOL_A_WITH_HISTOGRAM - TOOL_A,
+        TOOL_ADD_SCALING = TOOL_A_SCALED - TOOL_A,
+
+    };
+
+    struct ToolMap
+    {
+        Tool toolid;
+        const char * outputName; // displayed name
+        const char * format;     // printf format (%s is A)
+    };
+
+    static ToolMap tool_map [];
+
+    SWISSARMYKNIFE_PARAM *  _param;
+
+public:
+
+    ADMVideoSwissArmyKnife (AVDMGenericVideoStream *in,CONFcouple *setup);
+    ~ADMVideoSwissArmyKnife();
+
+    virtual uint8_t getFrameNumberNoAlloc (uint32_t frame, uint32_t *len,
+                                           ADMImage *data, uint32_t *flags);
+
+    virtual uint8_t configure (AVDMGenericVideoStream *instream);
+    virtual char * printConf(void);
+    virtual uint8_t getCoupledConf (CONFcouple **couples);
+
+private:
+
+    template &lt;typename Oper, typename Histo&gt;
+    void computeRollingAverage (ADMImage * image, ADMImage * data,
+                                uint32_t planesize, int32_t bias,
+                                const Oper &amp; op_in,
+                                const Histo &amp; histogram_in);
+
+    template &lt;typename InputImageType, typename Oper, typename Histo&gt;
+    void applyImage (ADMImage * image, ADMImage * data,
+                     uint32_t planesize, int32_t bias,
+                     InputImageType * input_image,
+                     const Oper &amp; op_in, const Histo &amp; histogram_in);
+
+    template &lt;typename Oper, typename Histo&gt;
+    void applyConstant (ADMImage * image, ADMImage * data,
+                        uint32_t planesize, int32_t bias,
+                        const Oper &amp; op_in,
+                        const Histo &amp; histogram_in);
+
+};
+#endif

Added: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidThreshold.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidThreshold.cpp	2007-08-30 18:42:41 UTC (rev 3574)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidThreshold.cpp	2007-08-31 16:18:20 UTC (rev 3575)
@@ -0,0 +1,226 @@
+/***************************************************************************
+                          ADM_vidThreshold.cpp  -  do thresholding
+                              -------------------
+                          Chris MacGregor, 2005, 2007
+                         <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">chris-avidemux at bouncingdog.com</A>
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+ 
+ 
+#include &lt;stdio.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;string.h&gt;
+#include &lt;ADM_assert.h&gt;
+#include &lt;math.h&gt;
+
+#include &quot;config.h&quot;
+#include &quot;fourcc.h&quot;
+#include &quot;avio.hxx&quot;
+#include &quot;config.h&quot;
+#include &quot;avi_vars.h&quot;
+
+
+#include &quot;ADM_toolkit/toolkit.hxx&quot;
+#include &quot;ADM_editor/ADM_edit.hxx&quot;
+#include &quot;ADM_video/ADM_genvideo.hxx&quot;
+
+#include &quot;ADM_filter/video_filters.h&quot;
+
+#include &quot;ADM_userInterfaces/ADM_commonUI/DIA_factory.h&quot;
+
+#include &quot;ADM_vidThreshold.h&quot;
+
+// #define THRESHOLD_HISTO 1
+
+static FILTER_PARAM thresholdParam={3,{&quot;min&quot;, &quot;max&quot;, &quot;debug&quot;}};
+
+SCRIPT_CREATE(threshold_script,ADMVideoThreshold,thresholdParam);
+
+BUILD_CREATE(threshold_create,ADMVideoThreshold);
+
+ADMVideoThreshold::ADMVideoThreshold(AVDMGenericVideoStream *in,CONFcouple *couples)
+			
+{
+    printf (&quot;ADMVideoThreshold ctor (%p)\n&quot;, this);
+    _in=in;
+    memcpy(&amp;_info,in-&gt;getInfo(),sizeof(_info));
+    _info.encoding=1;	
+    _uncompressed=new ADMImage(_in-&gt;getInfo()-&gt;width,_in-&gt;getInfo()-&gt;height);
+    ADM_assert(_uncompressed);    	  	
+    _param=NEW( THRESHOLD_PARAM );
+    if(couples)
+    {
+        GET(min);
+        GET(max);
+        GET(debug);
+    }
+    else
+    {
+        _param-&gt;min = 100;
+        _param-&gt;max = 200;
+        _param-&gt;debug = 0;
+    }
+}
+
+uint8_t	ADMVideoThreshold::getCoupledConf( CONFcouple **couples)
+{
+
+    ADM_assert(_param);
+    *couples=new CONFcouple(3);
+
+#define CSET(x)  (*couples)-&gt;setCouple((char *)#x,(_param-&gt;x))
+    CSET(min);
+    CSET(max);
+    CSET(debug);
+
+    return 1;
+
+}
+
+uint8_t ADMVideoThreshold::configure(AVDMGenericVideoStream *in)
+{
+    UNUSED_ARG(in);
+
+    diaElemUSlider minslide(&amp;(_param-&gt;min), _(&quot;Mi_nimum value to be non-zero in output:&quot;), 0, 255);
+    diaElemUSlider maxslide(&amp;(_param-&gt;max), _(&quot;Ma_ximum value to be non-zero in output:&quot;), 0, 255);
+    diaElemUInteger debug(&amp;(_param-&gt;debug), _(&quot;_Debugging settings (bits):&quot;),
+                          0, 0x7fffffff);
+    diaElem * elems[] = { &amp;minslide, &amp;maxslide, &amp;debug };
+
+    uint8_t ret = diaFactoryRun(&quot;Threshold&quot;, sizeof (elems) / sizeof (diaElem *), elems);
+    return ret;
+}
+
+ADMVideoThreshold::~ADMVideoThreshold()
+{
+    printf (&quot;ADMVideoThreshold dtor (%p)\n&quot;, this);
+    DELETE(_param);
+    delete  _uncompressed;	
+    _uncompressed=NULL;
+}
+
+char	*ADMVideoThreshold::printConf( void) 
+{
+    static char conf[100];
+
+    sprintf(conf,&quot;Threshold: Min = %3u  Max = %3u  Debug=0x%06x&quot;,
+            _param-&gt;min, _param-&gt;max, _param-&gt;debug);
+    return conf;
+	
+}
+uint8_t ADMVideoThreshold::getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
+          			ADMImage *data,uint32_t *flags)
+{
+    if (frame&gt;= _info.nb_frames)
+        return 0;
+
+    uint32_t debug = _param-&gt;debug;
+
+    if (debug &amp; 1)
+        printf (&quot;in ADMVideoThreshold::getFrameNumberNoAlloc(%d, ...)\n&quot;,
+                frame);
+
+    uint32_t planesize = _info.width * _info.height;
+    uint32_t size = (planesize*3)&gt;&gt;1;
+    *len = size;
+			
+    if (!_in-&gt;getFrameNumberNoAlloc (frame, len, _uncompressed, flags))
+        return 0;
+    ADMImage * image = _uncompressed;
+
+    // HERE: for speed, we do luma (Y plane) only.  However, some
+    // users might want chroma, too... we should make that
+    // an option or something.
+
+    uint8_t * currp = YPLANE (image) + planesize;
+    uint8_t * destp = YPLANE (data) + planesize;
+    uint32_t pixremaining = planesize + 1;
+
+#ifdef THRESHOLD_HISTO
+    uint32_t histo_before [256];
+    uint32_t histo_after [256];
+
+    memset (histo_before, 0, 256 * sizeof (uint32_t));
+    memset (histo_after, 0, 256 * sizeof (uint32_t));
+#endif
+
+    uint32_t min = _param-&gt;min;
+    uint32_t max = _param-&gt;max;
+
+    uint8_t in_range_value;
+    uint8_t out_of_range_value;
+    if (min &lt;= max)
+    {
+        in_range_value = 255;
+        out_of_range_value = 0;
+    }
+    else
+    {
+        in_range_value = 0;
+        out_of_range_value = 255;
+        uint32_t tmp = min;
+        min = max;
+        max = tmp;
+    }
+
+#ifdef DUMP_FRAME_DATA
+    FILE * fp = fopen (&quot;/tmp/framedump.new.out&quot;, &quot;a&quot;);
+    ADM_assert(fp);
+#endif
+
+    while (--pixremaining)
+    {
+        int32_t curr = *--currp;
+
+#ifdef THRESHOLD_HISTO
+        histo_before [curr]++;
+#endif
+
+#ifdef DUMP_FRAME_DATA
+        fprintf (fp, &quot;%x\n&quot;, curr);
+#endif
+
+        if (curr &lt; min || curr &gt; max)
+            *--destp = out_of_range_value;
+        else
+            *--destp = in_range_value;
+
+#ifdef THRESHOLD_HISTO
+        histo_after [*destp]++;
+#endif
+    }
+
+#ifdef DUMP_FRAME_DATA
+    fclose (fp);
+#endif
+
+#ifdef THRESHOLD_HISTO
+    if (debug &amp; 0x800)
+    {
+        printf (&quot;    Histogram:\n\tValue\tBefore\tAfter\tValue\tBefore\tAfter&quot;
+                &quot;\tValue\tBefore\tAfter\tValue\tBefore\tAfter\n&quot;);
+        for (int val = 0; val &lt;= 63; val++)
+            printf (&quot;\t%3d:\t%6d\t%6d\t%3d:\t%6d\t%6d\t%3d:\t%6d\t%6d\t%3d:\t%6d\t%6d\n&quot;,
+                    val, histo_before [val], histo_after [val],
+                    val + 64, histo_before [val + 64], histo_after [val + 64],
+                    val + 128, histo_before [val + 128], histo_after [val + 128],
+                    val + 192, histo_before [val + 192], histo_after [val + 192]);
+    }
+#endif
+
+    // HERE: the following two lines do a luma-only-ize
+
+    memset (UPLANE (data), 128, planesize &gt;&gt; 2);
+    memset (VPLANE (data), 128, planesize &gt;&gt; 2);
+
+    data-&gt;copyInfo(image);
+    return 1;
+}	                           

Added: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidThreshold.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidThreshold.h	2007-08-30 18:42:41 UTC (rev 3574)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidThreshold.h	2007-08-31 16:18:20 UTC (rev 3575)
@@ -0,0 +1,51 @@
+/***************************************************************************
+                          ADM_vidThreshold.h  -  do thresholding
+                              -------------------
+                          Chris MacGregor, 2005, 2007
+                         <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">chris-avidemux at bouncingdog.com</A>
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+ 
+#ifndef __THRESHOLD__
+#define __THRESHOLD__   
+#include &quot;ADM_video/ADM_cache.h&quot;
+typedef struct THRESHOLD_PARAM
+{
+
+    uint32_t min;
+    uint32_t max;
+    uint32_t debug;
+
+} THRESHOLD_PARAM;
+
+class  ADMVideoThreshold:public AVDMGenericVideoStream
+ {
+
+ protected:
+    	
+     THRESHOLD_PARAM *  _param;
+
+ public:
+ 		
+
+     ADMVideoThreshold(  AVDMGenericVideoStream *in,CONFcouple *setup);
+
+     ~ADMVideoThreshold();
+
+     virtual uint8_t 	getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
+                                              ADMImage *data,uint32_t *flags);
+
+     virtual uint8_t 	configure( AVDMGenericVideoStream *instream);
+     virtual char 		   *printConf(void);
+     virtual uint8_t 	getCoupledConf( CONFcouple **couples);
+							
+ };
+#endif

Modified: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/CMakeLists.txt
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/CMakeLists.txt	2007-08-30 18:42:41 UTC (rev 3574)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/CMakeLists.txt	2007-08-31 16:18:20 UTC (rev 3575)
@@ -38,6 +38,10 @@
 ADM_vidVobsub.cpp
 ADM_vidVobSubRender.cpp
 ADM_vobsubinfo.cpp
+ADM_vidComputeAverage.cpp
+ADM_vidSwissArmyKnife.cpp
+ADM_vidThreshold.cpp
+ADM_vidParticle.cpp
 
 )
 ADD_LIBRARY(ADM_videoFilter STATIC ${ADM_videoFilter_SRCS})

Modified: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/Makefile.am
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/Makefile.am	2007-08-30 18:42:41 UTC (rev 3574)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/Makefile.am	2007-08-31 16:18:20 UTC (rev 3575)
@@ -76,7 +76,11 @@
  ADM_vidVobsub.cpp \
  ADM_vidVobSubRender.cpp \
  ADM_vobsubinfo.cpp \
- ADM_vidCrop.cpp       
+ ADM_vidCrop.cpp \
+ ADM_vidComputeAverage.cpp \
+ ADM_vidSwissArmyKnife.cpp \
+ ADM_vidThreshold.cpp \
+ ADM_vidParticle.cpp       
 			
 
 


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000848.html">[Avidemux-svn-commit] r3574 - branches/avidemux_2.4_branch/po
</A></li>
	<LI>Next message: <A HREF="000850.html">[Avidemux-svn-commit] r3576 - in	branches/avidemux_2.4_branch/avidemux: . ADM_editor	ADM_outputs ADM_outputs/oplug_dummy
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#849">[ date ]</a>
              <a href="thread.html#849">[ thread ]</a>
              <a href="subject.html#849">[ subject ]</a>
              <a href="author.html#849">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">More information about the Avidemux-svn-commit
mailing list</a><br>
</body></html>
