From gruntster at mail.berlios.de  Sun Oct  3 18:54:52 2010
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Sun,  3 Oct 2010 18:54:52 +0200
Subject: [Avidemux-svn-commit] r6693 -
	branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264
Message-ID: <20101003165453.B35904810E3@sheep.berlios.de>

Author: gruntster
Date: 2010-10-03 18:54:51 +0200 (Sun, 03 Oct 2010)
New Revision: 6693

Modified:
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/encoder.cpp
Log:
[x264] use key frame flag rather than deriving from frame type

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/encoder.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/encoder.cpp	2010-10-03 08:19:09 UTC (rev 6692)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/encoder.cpp	2010-10-03 16:54:51 UTC (rev 6693)
@@ -334,21 +334,23 @@
 	_currentFrame++;
 	encodeParams->ptsFrame = picture_out.i_pts;	// In fact it is the picture number in out case
 
-	switch (picture_out.i_type)
+	if (picture_out.b_keyframe)
+		encodeParams->frameType = ADM_VIDENC_FRAMETYPE_IDR;
+	else
 	{
-		case X264_TYPE_IDR:
-			encodeParams->frameType = ADM_VIDENC_FRAMETYPE_IDR;
-			break;
-		case X264_TYPE_I:
-		case X264_TYPE_P:
-			encodeParams->frameType = ADM_VIDENC_FRAMETYPE_P;
-			break;
-		case X264_TYPE_B:
-		case X264_TYPE_BREF:
-			encodeParams->frameType = ADM_VIDENC_FRAMETYPE_B;
-			break;
-		default:
-			encodeParams->frameType = ADM_VIDENC_FRAMETYPE_NULL;
+		switch (picture_out.i_type)
+		{
+			case X264_TYPE_I:
+			case X264_TYPE_P:
+				encodeParams->frameType = ADM_VIDENC_FRAMETYPE_P;
+				break;
+			case X264_TYPE_B:
+			case X264_TYPE_BREF:
+				encodeParams->frameType = ADM_VIDENC_FRAMETYPE_B;
+				break;
+			default:
+				encodeParams->frameType = ADM_VIDENC_FRAMETYPE_NULL;
+		}
 	}
 
 	encodeParams->quantiser = picture_out.i_qpplus1 - 1;



From gruntster at mail.berlios.de  Sun Oct  3 19:04:18 2010
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Sun,  3 Oct 2010 19:04:18 +0200
Subject: [Avidemux-svn-commit] r6694 -
	branches/avidemux_2.5_branch_gruntster/avidemux/ADM_libraries
Message-ID: <20101003170418.BAC92480F75@sheep.berlios.de>

Author: gruntster
Date: 2010-10-03 19:04:18 +0200 (Sun, 03 Oct 2010)
New Revision: 6694

Added:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_libraries/ffmpeg_r25041.tar.gz
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_libraries/libswscale_r32049.tar.gz
Log:
[ffmpeg] update ffmpeg & libswscale tarballs

Copied: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_libraries/ffmpeg_r25041.tar.gz (from rev 6692, branches/avidemux_2.5_branch_gruntster/avidemux/ADM_libraries/ffmpeg_r20602.tar.gz)
===================================================================
(Binary files differ)

Copied: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_libraries/libswscale_r32049.tar.gz (from rev 6692, branches/avidemux_2.5_branch_gruntster/avidemux/ADM_libraries/libswscale_r29964.tar.gz)
===================================================================
(Binary files differ)



From mean at mail.berlios.de  Mon Oct  4 07:27:28 2010
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Mon,  4 Oct 2010 07:27:28 +0200
Subject: [Avidemux-svn-commit] r6696 -
	branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Srt
Message-ID: <20101004052728.34F00480ED9@sheep.berlios.de>

Author: mean
Date: 2010-10-04 07:27:28 +0200 (Mon, 04 Oct 2010)
New Revision: 6696

Modified:
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Srt/ADM_vidSRTload.cpp
Log:
[srt] Merge gentoo patch 249367

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Srt/ADM_vidSRTload.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Srt/ADM_vidSRTload.cpp	2010-10-04 05:16:39 UTC (rev 6695)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoFilters/Srt/ADM_vidSRTload.cpp	2010-10-04 05:27:28 UTC (rev 6696)
@@ -86,7 +86,7 @@
 	return 0;
 
   }
-  while (fgets (string, 200, _fd))
+  while (fgets (string, sizeof(string), _fd))
     {
       _line++;
     }
@@ -104,7 +104,7 @@
 //
   for (uint32_t i = 0; i < _line; i++)
     {
-      fgets (string, ADM_RAW, _fd);
+      fgets (string, sizeof(string), _fd);
       //printf("\n in : %s ",string);
       if (string[0] != '{')
 	continue;
@@ -250,7 +250,7 @@
   // first cound how many line
   line = 0;
   _line = 0;
-  while (fgets (string, 300, _fd))
+  while (fgets (string, sizeof(string), _fd))
     line++;
   printf ("\n subs : %ld lines\n", line);
   // rewind
@@ -272,7 +272,7 @@
   for (uint32_t i = 0; i < line; i++)
     {
 	current=&_subs[_line];
-	fgets (string, ADM_RAW, _fd);
+	fgets (string, sizeof(string), _fd);
 	ADM_utfConv(final,string,strlen(string),&finallen);
 	// Purge cr/lf
 	switch (state)



From mean at mail.berlios.de  Wed Oct  6 07:42:09 2010
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Wed,  6 Oct 2010 07:42:09 +0200
Subject: [Avidemux-svn-commit] r6697 -
	branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src
Message-ID: <20101006054209.1E5D9480E0A@sheep.berlios.de>

Author: mean
Date: 2010-10-06 07:42:08 +0200 (Wed, 06 Oct 2010)
New Revision: 6697

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_ffmp43.cpp
Log:
[corevideo] revert CR/LF to LF

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_ffmp43.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_ffmp43.cpp	2010-10-04 05:27:28 UTC (rev 6696)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_ffmp43.cpp	2010-10-06 05:42:08 UTC (rev 6697)
@@ -1,623 +1,623 @@
-/***************************************************************************
-    \file ADM_ffmp43
-    \brief Decoders using lavcodec
-    \author mean & all (c) 2002-2010
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-extern "C" {
-#include "ADM_lavcodec.h"
-}
-#include "ADM_default.h"
-
-#include "ADM_codec.h"
-#include "ADM_ffmp43.h"
-#include "DIA_coreToolkit.h"
-//#include "ADM_videoInfoExtractor.h"
-
-extern int ADM_cpu_num_processors(void);
-extern "C"
-{
-    static void ADM_releaseBuffer(struct AVCodecContext *avctx, AVFrame *pic);
-    static int  ADM_getBuffer(AVCodecContext *avctx, AVFrame *pic);
-}
-
-#define aprintf(...) {}
-
-#define WRAP_Open_Template(funcz,argz,display,codecid) \
-{\
-AVCodec *codec=funcz(argz);\
-if(!codec) {GUI_Error_HIG("Codec",QT_TR_NOOP("Internal error finding codec"display));ADM_assert(0);} \
-  codecId=codecid; \
-  _context->workaround_bugs=1*FF_BUG_AUTODETECT +0*FF_BUG_NO_PADDING; \
-  _context->error_concealment=3; \
-  if (avcodec_open(_context, codec) < 0)  \
-                      { \
-                                        printf("[lavc] Decoder init: "display" video decoder failed!\n"); \
-                                        GUI_Error_HIG("Codec","Internal error opening "display); \
-                                        ADM_assert(0); \
-                                } \
-                                else \
-                                { \
-                                        printf("[lavc] Decoder init: "display" video decoder initialized! (%s)\n",codec->long_name); \
-                                } \
-}
-
-#define WRAP_Open(x)            {WRAP_Open_Template(avcodec_find_decoder,x,#x,x);}
-#define WRAP_OpenByName(x,y)    {WRAP_Open_Template(avcodec_find_decoder_by_name,#x,#x,y);}
-
-
-//****************************
-extern uint8_t DIA_lavDecoder (uint32_t * swapUv, uint32_t * showU);
-extern "C"
-{
-  int av_is_voppacked (AVCodecContext * avctx, int *vop_packed, int *gmc,
-		       int *qpel);
-};
-/**
-    \fn clonePic
-    \brief Convert AvFrame to ADMImage
-*/
-uint8_t decoderFF::clonePic (AVFrame * src, ADMImage * out)
-{
-  uint32_t    u,v;
-  ADM_assert(out->isRef());
-  ADMImageRef *ref=out->castToRef();
-  ref->_planes[0] = (uint8_t *) src->data[0];
-  ref->_planeStride[0] = src->linesize[0];
-  if (_swapUV)
-    {
-      u = 1;
-      v = 2;
-    }
-  else
-    {
-      u = 2;
-      v = 1;
-    }
-  ref->_planes[1] = (uint8_t *) src->data[u];
-  ref->_planeStride[1] = src->linesize[u];
-
-  ref->_planes[2] = (uint8_t *) src->data[v];
-  ref->_planeStride[2] = src->linesize[v];
-
-  _lastQ = 0;			//_context->quality;
-  out->_Qp = (src->quality * 32) / FF_LAMBDA_MAX;
-  out->flags = frameType ();
-
-  // Quant ?
-  if (src->qstride && src->qscale_table && codecId != CODEC_ID_H264)
-    {
-      out->quant = (uint8_t *) src->qscale_table;
-      out->_qStride = src->qstride;
-      out->_qSize = (_w + 15) >> 4;
-      out->_qSize *= (_h + 15) >> 4;	// FixME?
-    }
-  else
-    {
-      out->_qSize = out->_qStride = 0;
-      out->quant = NULL;
-    }
-    //printf("[LAVC] Old pts :%"LLD" new pts :%"LLD"\n",out->Pts, (uint64_t)(src->reordered_opaque));
-    //printf("[LAVC] pts: %"LLU"\n",src->pts);
-    out->Pts= (uint64_t)(src->reordered_opaque);
- 
-    return 1;
-}
-/**
-        \fn decoderMultiThread
-        \brief Enabled multitheaded decoder if possible
-*/
-void decoderFF::decoderMultiThread (void)
-{
-  uint32_t threads = 0;
-
- // prefs->get(FEATURE_THREADING_LAVC, &threads);
-#warning Fixme
-    threads=1;
-  if (threads == 0)
-	  threads = ADM_cpu_num_processors();
-
-  if (threads == 1)
-	  threads = 0;
-
-  if (threads)
-  {
-      printf ("[lavc] Enabling MT decoder with %u threads\n", threads);
-
-      if (avcodec_thread_init (_context, threads) == -1)
-	      printf ("[lavc] Failed!!\n");
-	  else
-          _usingMT = 1;
-  }
-}
-uint8_t decoderFF::getPARWidth (void)
-{
-  if(!_context->sample_aspect_ratio.num) return 1;
-  return _context->sample_aspect_ratio.num;
-}
-uint8_t decoderFF::getPARHeight (void)
-{
-  if(!_context->sample_aspect_ratio.den) return 1;
-  return _context->sample_aspect_ratio.den;
-
-}
-
-//________________________________________________
-bool  decoderFF::setParam (void)
-{
-  DIA_lavDecoder (&_swapUV, &_showMv);
-  return true;			// no param for ffmpeg
-}
-
-//-------------------------------
-decoderFF::decoderFF (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp)
-            :decoders (w, h,fcc,extraDataLen,extraData,bpp)
-{
-  codecId = 0;
-//                              memset(&_context,0,sizeof(_context));
-  _allowNull = 0;
-  _gmc = 0;
-  _context = NULL;
-  _refCopy = 0;
-  _usingMT = 0;
-#if LIBAVCODEC_BUILD >= 4624
-  _context = avcodec_alloc_context ();
-#else
-  _context = new AVCodecContext;
-  memset (_context, 0, sizeof (AVCodecContext));
-#endif
-  ADM_assert (_context);
-  memset (&_frame, 0, sizeof (_frame));
-
-  _context->max_b_frames = 0;
-
-  _context->width = _w;
-  _context->height = _h;
-  _context->pix_fmt = PIX_FMT_YUV420P;	//PIX_FMT_RGBA32
-  //_context->debug=1;
-
-  _internalBuffer = new uint8_t[w * h * 3];
-
-  _swapUV = 0;
-  //_context->strict_std_compliance=-1;
-
-  _showMv = 0;
-#define FF_SHOW		(FF_DEBUG_VIS_MV_P_FOR+	FF_DEBUG_VIS_MV_B_FOR+FF_DEBUG_VIS_MV_B_BACK)
-//#define FF_SHOW               (FF_DEBUG_VIS_MV_P_FOR)
-  printf ("[lavc] Build: %d\n", LIBAVCODEC_BUILD);
-  _context->debug_mv |= FF_SHOW;
-  _context->debug |= FF_DEBUG_VIS_MB_TYPE + FF_DEBUG_VIS_QP;
-  
-}
-
-//_____________________________________________________
-
-decoderFF::~decoderFF ()
-{
-  if (_usingMT)
-    {
-      printf ("[lavc] Killing decoding threads\n");
-      avcodec_thread_free (_context);
-      _usingMT = 0;
-    }
-
-  avcodec_close (_context);
-  ADM_dealloc (_context);
-  delete[]_internalBuffer;
-  printf ("[lavc] Destroyed\n");
-}
-
-/**
-    \fn frameType
-    \return frametype of the last decoded frame
-*/
-uint32_t decoderFF::frameType (void)
-{
-  uint32_t
-    flag = 0;
-
-  AVFrame *
-    target;
-#define SET(x) {flag=x;aprintf("Frame is %s\n",#x);}
-
-
-  target = &_frame;
-  switch (target->pict_type)
-    {
-    case FF_B_TYPE:
-      SET (AVI_B_FRAME);
-      if (target->key_frame)
-	aprintf ("\n But keyframe is set\n");
-      break;
-
-    case FF_I_TYPE:
-      SET (AVI_KEY_FRAME);
-      if (!target->key_frame)
-	{
-	  if (codecId == CODEC_ID_H264)
-	    {
-	      SET (AVI_P_FRAME);
-	    }
-	  else
-	    printf ("\n But keyframe is not set\n");
-	}
-      break;
-    case FF_S_TYPE:
-      _gmc = 1;			// No break, just inform that gmc is there
-    case FF_P_TYPE:
-      SET (AVI_P_FRAME);
-      if (target->key_frame)
-	aprintf ("\n But keyframe is set\n");
-      break;
-    default:
-//                              printf("\n OOops XXX frame ?\n");
-      break;
-    }
-    flag&=~AVI_STRUCTURE_TYPE_MASK;
-    if(target->interlaced_frame)
-    {
-        flag|=AVI_FIELD_STRUCTURE;
-        if(target->top_field_first)
-            flag|=AVI_TOP_FIELD;
-        else
-            flag|=AVI_BOTTOM_FIELD;
-    }
-  return flag;
-}
-bool decoderFF::decodeHeaderOnly (void)
-{
-  if (codecId == CODEC_ID_H264)
-    _context->hurry_up = 4;
-  else
-    _context->hurry_up = 5;
-  printf ("\n[lavc] Hurry up\n");
-  return 1;
-}
-bool decoderFF::decodeFull (void)
-{
-  _context->hurry_up = 0;
-  printf ("\n[lavc] full decoding\n");
-  return 1;
-}
-
-/**
-    \fn flush
-    \brief empty internal buffer
-*/
-bool    decoderFF::flush(void)
-{
-    if(_context)
-        avcodec_flush_buffers(_context);
-    return true;
-}
-/**
-    \fn uncompress
-    \brief Actually decode an image
-*/
-bool   decoderFF::uncompress (ADMCompressedImage * in, ADMImage * out)
-{
-  int got_picture = 0;
-  uint8_t *oBuff[3];
-  int strideTab[3];
-  int strideTab2[3];
-  int ret = 0;
-  out->_noPicture = 0;
-  if (_showMv)
-    {
-      _context->debug_mv |= FF_SHOW;
-      _context->debug |= 0;	//FF_DEBUG_VIS_MB_TYPE;
-    }
-  else
-    {
-      _context->debug_mv &= ~FF_SHOW;
-      _context->debug &= ~(FF_DEBUG_VIS_MB_TYPE + FF_DEBUG_VIS_QP);
-    }
-
-   
-    
-  if (in->dataLength == 0 && !_allowNull)	// Null frame, silently skipped
-    {
-      
-      printf ("[Codec] null frame\n");
-        // search the last image
-        if (_context->coded_frame && 
-            _context->coded_frame->data &&
-            _context->coded_frame->data[0]
-            )
-          {
-            printf("[Codec] Cloning older pic\n");
-            clonePic (_context->coded_frame, out);
-            out->Pts=ADM_COMPRESSED_NO_PTS;
-          }
-        else
-            {
-                out->_noPicture = 1;
-                out->Pts=ADM_COMPRESSED_NO_PTS;
-                printf("[Codec] No Picture\n");
-            }
-          return 1;
-    }
-   // Put a safe value....
-   out->Pts=in->demuxerPts;
-    _context->reordered_opaque=in->demuxerPts;
-  //_frame.opaque=(void *)out->Pts;
-  //printf("Incoming Pts :%"LLD"\n",out->Pts);
-  AVPacket pkt;
-  av_init_packet(&pkt);
-  pkt.data=in->data;
-  pkt.size=in->dataLength;
-  if(in->flags&AVI_KEY_FRAME)
-    pkt.flags=AV_PKT_FLAG_KEY;
-  else
-    pkt.flags=0;
-  
-  ret = avcodec_decode_video2 (_context, &_frame, &got_picture, &pkt);
-  if(!bFramePossible())
-  {
-    // No delay, the value is sure, no need to hide it in opaque
-    _context->reordered_opaque=(int64_t)in->demuxerPts;
-  }
-  out->_qStride = 0;		//Default = no quant
-  if (0 > ret && !_context->hurry_up)
-    {
-      printf ("\n[lavc] error in lavcodec decoder!\n");
-      printf ("[lavc] Err: %d, size :%d\n", ret, in->dataLength);
-      return 0;
-    }
-  if (!got_picture && !_context->hurry_up)
-    {
-      // Some encoder code a vop header with the 
-      // vop flag set to 0
-      // it is meant to mean frame skipped but very dubious
-      if (in->dataLength <= 8 && codecId == CODEC_ID_MPEG4)
-	{
-	  printf ("[lavc] Probably pseudo black frame...\n");
-	  out->_Qp = 2;
-	  out->flags = 0;	// assume P ?
-
-	  clonePic (_context->coded_frame, out);
-	  return 1;
-	}
-      // allow null means we allow null frame in and so potentially
-      // have no frame out for a time
-      // in that case silently fill with black and returns it as KF
-      if (_allowNull)
-	{
-	  out->flags = AVI_KEY_FRAME;
-	  if (!_refCopy)
-	    {
-            out->blacken();
-	    }
-	  else
-	    {
-	      out->_noPicture = 1;
-	    }
-	  printf ("\n[lavc] ignoring got pict ==0\n");
-	  return 1;
-
-	}
-#if 0
-      printf ("[lavc] Err: %d, size: %d\n", ret, in->dataLength);
-      printf ("\n[lavc] error in FFMP43/mpeg4!: got picture\n");
-#endif
-      //GUI_Alert("Please retry with misc->Turbo off");
-      //return 1;
-      return 0;
-    }
-  if (_context->hurry_up)
-    {
-      out->flags = frameType ();
-      return 1;
-    }
-  // We have an image....
-  switch (_context->pix_fmt)
-    {
-    case PIX_FMT_YUV411P:
-      out->_colorspace = ADM_COLOR_YUV411;
-      break;
-    case PIX_FMT_YUYV422:
-      out->_colorspace = ADM_COLOR_YUV422;
-      break;
-    case PIX_FMT_YUV422P:
-    case PIX_FMT_YUVJ422P:
-      out->_colorspace = ADM_COLOR_YUV422P;
-      break;
-    case PIX_FMT_YUV444P:
-    case PIX_FMT_YUVJ444P:
-      out->_colorspace = ADM_COLOR_YUV444;
-      break;
-    case PIX_FMT_YUV420P:
-    case PIX_FMT_YUVJ420P:
-    case PIX_FMT_YUVA420P:
-      // Default is YV12 or I420
-      // In that case depending on swap u/v
-      // we do it or not
-      out->_colorspace = ADM_COLOR_YV12;
-      break;
-	case PIX_FMT_RGB24:
-	  out->_colorspace = ADM_COLOR_BGR24;
-	  break;
-    case PIX_FMT_BGRA:
-      out->_colorspace = ADM_COLOR_BGR32A;
-      break;
-    case PIX_FMT_RGBA: // ???PIX_FMT_RGBA32:
-      out->_colorspace = ADM_COLOR_RGB32A;
-      break;
-    case PIX_FMT_RGB555:
-      out->_colorspace = ADM_COLOR_RGB555;
-      break;
-    case PIX_FMT_VDPAU_MPEG1:
-    case PIX_FMT_VDPAU_MPEG2:
-    case PIX_FMT_VDPAU_WMV3:
-    case PIX_FMT_VDPAU_VC1:
-    case PIX_FMT_VDPAU_H264:
-        out->_colorspace=ADM_COLOR_VDPAU;
-        break;
-    default:
-      printf ("[lavc] Unhandled colorspace: %d\n", _context->pix_fmt);
-      return 0;
-    }
-    clonePic (&_frame, out);
-    //printf("[AvCodec] Pts : %llu Out Pts:%llu \n",_frame.pts,out->Pts);
-
-  return 1;
-}
-// *******************************************************************
-// *******************************************************************
-// *******************************************************************
-
-decoderFFDiv3::decoderFFDiv3 (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp):
-decoderFF (w, h,fcc,extraDataLen,extraData,bpp)
-{
-  _refCopy = 1;			// YUV420 only
-  WRAP_Open (CODEC_ID_MSMPEG4V3);
-}
-
-decoderFFMpeg4::decoderFFMpeg4 (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp):
-decoderFF (w, h,fcc,extraDataLen,extraData,bpp)
-{
-// force low delay as avidemux don't handle B-frames
-  ADM_info ("[lavc] Using %d bytes of extradata for MPEG4 decoder\n", (int)extraDataLen);
-  
-  _refCopy = 1;			// YUV420 only
-  _context->extradata = (uint8_t *) extraData;
-  _context->extradata_size = (int)extraDataLen  ;
-  _context->codec_tag=fcc;
-  _context->stream_codec_tag=fcc;
-  decoderMultiThread ();
-  //  _context->flags|=FF_DEBUG_VIS_MV;
-  WRAP_Open (CODEC_ID_MPEG4);
-}
-bool decoderFFMpeg4::uncompress (ADMCompressedImage * in, ADMImage * out)
-{
-    // For pseudo startcode
-    if(in->dataLength)
-    {
-        in->data[in->dataLength]=0;
-        in->data[in->dataLength+1]=0;
-    }
-    return decoderFF::uncompress(in,out);
-
-}
-//************************************
-decoderFFDV::decoderFFDV (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp):
-decoderFF (w, h,fcc,extraDataLen,extraData,bpp)
-{
-  _context->extradata = (uint8_t *) extraData;
-  _context->extradata_size = (int) extraDataLen;
-  WRAP_Open (CODEC_ID_DVVIDEO);
-
-}
-decoderFFMpeg12::decoderFFMpeg12 (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp):
-                decoderFF (w, h,fcc,extraDataLen,extraData,bpp)
-{
-  _refCopy = 1;			// YUV420 only
-  decoderMultiThread ();
-  WRAP_Open (CODEC_ID_MPEG2VIDEO);
-}
-
-decoderFFPng::decoderFFPng(uint32_t w, uint32_t h, uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData, uint32_t bpp) : decoderFF(w, h, fcc, extraDataLen, extraData, bpp)
-{
-	WRAP_Open (CODEC_ID_PNG);
-}
-
-decoderFF_ffhuff::decoderFF_ffhuff (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp)
-:decoderFF (w, h,fcc,extraDataLen,extraData,bpp)
-{
-  _context->extradata = (uint8_t *) extraData;
-  _context->extradata_size = (int) extraDataLen;
-  _context->bits_per_coded_sample=bpp;
-  ADM_info ("[lavc] FFhuff: We have %d bytes of extra data\n", (int)extraDataLen);
-  WRAP_Open (CODEC_ID_FFVHUFF);
-
-}
-decoderFFH264::decoderFFH264 (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp)
-        :decoderFF (w, h,fcc,extraDataLen,extraData,bpp)
-{
-
-  _refCopy = 1;			// YUV420 only
-  _context->extradata = (uint8_t *) extraData;
-  _context->extradata_size = (int) extraDataLen;
-  decoderMultiThread ();
-  ADM_info ("[lavc] Initializing H264 decoder with %d extradata\n", (int)extraDataLen);
-  WRAP_Open(CODEC_ID_H264);
-}
-//*********************
-extern "C" {int av_getAVCStreamInfo(AVCodecContext *avctx, uint32_t  *nalSize, uint32_t *isAvc);}
-/**
-    \fn uncompress
-*/
-bool   decoderFFH264::uncompress (ADMCompressedImage * in, ADMImage * out)
-{
-  if(!_context->hurry_up) return decoderFF::uncompress (in, out);
-    ADM_assert(0);
-#if 0  
-  uint32_t nalSize, isAvc;
-  av_getAVCStreamInfo(_context,&nalSize,&isAvc);
-  if(isAvc)
-  {
-      return extractH264FrameType(nalSize, in->data,in->dataLength,&(out->flags));
-  }else
-  {
-    return extractH264FrameType_startCode(nalSize, in->data,in->dataLength,&(out->flags));
-  }
-#endif
-}
-//*********************
-decoderFFhuff::decoderFFhuff (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp):
-decoderFF (w, h,fcc,extraDataLen,extraData,bpp)
-{
-  _context->extradata = (uint8_t *) extraData;
-  _context->extradata_size = (int) extraDataLen;
-  _context->bits_per_coded_sample = bpp;
-  WRAP_Open (CODEC_ID_HUFFYUV);
-}
-
-//***************
-extern uint8_t  lavformat_init(void);
-extern void     avcodec_init(void );
-extern  void    avcodec_register_all(void );
-extern "C"
-{
-  void adm_lavLogCallback(void  *instance, int level, const char* fmt, va_list list);
-}
-/**
-    \fn ADM_lavInit
-    \brief Init both lavcodec and lavformat
-*/
-void ADM_lavInit(void)
-{
-    avcodec_init();
-    avcodec_register_all();
-//BAZOOKA    lavformat_init();
-    av_log_set_callback(adm_lavLogCallback);
-#ifdef ADM_DEBUG
-  //  av_log_set_level(AV_LOG_DEBUG);
-#endif
-
-}
-void adm_lavLogCallback(void  *instance, int level, const char* fmt, va_list list)
-{
-   // if(level>1) return;
-    char buf[256];
-  
-    vsnprintf(buf, sizeof(buf), fmt, list);
-    if(level<=AV_LOG_INFO)
-        ADM_info("[lavc] %s",buf);
-}
-
-void ADM_lavDestroy(void)
-{
-	//av_free_static();
-}
-
-// EOF
+/***************************************************************************
+    \file ADM_ffmp43
+    \brief Decoders using lavcodec
+    \author mean & all (c) 2002-2010
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+extern "C" {
+#include "ADM_lavcodec.h"
+}
+#include "ADM_default.h"
+
+#include "ADM_codec.h"
+#include "ADM_ffmp43.h"
+#include "DIA_coreToolkit.h"
+//#include "ADM_videoInfoExtractor.h"
+
+extern int ADM_cpu_num_processors(void);
+extern "C"
+{
+    static void ADM_releaseBuffer(struct AVCodecContext *avctx, AVFrame *pic);
+    static int  ADM_getBuffer(AVCodecContext *avctx, AVFrame *pic);
+}
+
+#define aprintf(...) {}
+
+#define WRAP_Open_Template(funcz,argz,display,codecid) \
+{\
+AVCodec *codec=funcz(argz);\
+if(!codec) {GUI_Error_HIG("Codec",QT_TR_NOOP("Internal error finding codec"display));ADM_assert(0);} \
+  codecId=codecid; \
+  _context->workaround_bugs=1*FF_BUG_AUTODETECT +0*FF_BUG_NO_PADDING; \
+  _context->error_concealment=3; \
+  if (avcodec_open(_context, codec) < 0)  \
+                      { \
+                                        printf("[lavc] Decoder init: "display" video decoder failed!\n"); \
+                                        GUI_Error_HIG("Codec","Internal error opening "display); \
+                                        ADM_assert(0); \
+                                } \
+                                else \
+                                { \
+                                        printf("[lavc] Decoder init: "display" video decoder initialized! (%s)\n",codec->long_name); \
+                                } \
+}
+
+#define WRAP_Open(x)            {WRAP_Open_Template(avcodec_find_decoder,x,#x,x);}
+#define WRAP_OpenByName(x,y)    {WRAP_Open_Template(avcodec_find_decoder_by_name,#x,#x,y);}
+
+
+//****************************
+extern uint8_t DIA_lavDecoder (uint32_t * swapUv, uint32_t * showU);
+extern "C"
+{
+  int av_is_voppacked (AVCodecContext * avctx, int *vop_packed, int *gmc,
+		       int *qpel);
+};
+/**
+    \fn clonePic
+    \brief Convert AvFrame to ADMImage
+*/
+uint8_t decoderFF::clonePic (AVFrame * src, ADMImage * out)
+{
+  uint32_t    u,v;
+  ADM_assert(out->isRef());
+  ADMImageRef *ref=out->castToRef();
+  ref->_planes[0] = (uint8_t *) src->data[0];
+  ref->_planeStride[0] = src->linesize[0];
+  if (_swapUV)
+    {
+      u = 1;
+      v = 2;
+    }
+  else
+    {
+      u = 2;
+      v = 1;
+    }
+  ref->_planes[1] = (uint8_t *) src->data[u];
+  ref->_planeStride[1] = src->linesize[u];
+
+  ref->_planes[2] = (uint8_t *) src->data[v];
+  ref->_planeStride[2] = src->linesize[v];
+
+  _lastQ = 0;			//_context->quality;
+  out->_Qp = (src->quality * 32) / FF_LAMBDA_MAX;
+  out->flags = frameType ();
+
+  // Quant ?
+  if (src->qstride && src->qscale_table && codecId != CODEC_ID_H264)
+    {
+      out->quant = (uint8_t *) src->qscale_table;
+      out->_qStride = src->qstride;
+      out->_qSize = (_w + 15) >> 4;
+      out->_qSize *= (_h + 15) >> 4;	// FixME?
+    }
+  else
+    {
+      out->_qSize = out->_qStride = 0;
+      out->quant = NULL;
+    }
+    //printf("[LAVC] Old pts :%"LLD" new pts :%"LLD"\n",out->Pts, (uint64_t)(src->reordered_opaque));
+    //printf("[LAVC] pts: %"LLU"\n",src->pts);
+    out->Pts= (uint64_t)(src->reordered_opaque);
+ 
+    return 1;
+}
+/**
+        \fn decoderMultiThread
+        \brief Enabled multitheaded decoder if possible
+*/
+void decoderFF::decoderMultiThread (void)
+{
+  uint32_t threads = 0;
+
+ // prefs->get(FEATURE_THREADING_LAVC, &threads);
+#warning Fixme
+    threads=1;
+  if (threads == 0)
+	  threads = ADM_cpu_num_processors();
+
+  if (threads == 1)
+	  threads = 0;
+
+  if (threads)
+  {
+      printf ("[lavc] Enabling MT decoder with %u threads\n", threads);
+
+      if (avcodec_thread_init (_context, threads) == -1)
+	      printf ("[lavc] Failed!!\n");
+	  else
+          _usingMT = 1;
+  }
+}
+uint8_t decoderFF::getPARWidth (void)
+{
+  if(!_context->sample_aspect_ratio.num) return 1;
+  return _context->sample_aspect_ratio.num;
+}
+uint8_t decoderFF::getPARHeight (void)
+{
+  if(!_context->sample_aspect_ratio.den) return 1;
+  return _context->sample_aspect_ratio.den;
+
+}
+
+//________________________________________________
+bool  decoderFF::setParam (void)
+{
+  DIA_lavDecoder (&_swapUV, &_showMv);
+  return true;			// no param for ffmpeg
+}
+
+//-------------------------------
+decoderFF::decoderFF (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp)
+            :decoders (w, h,fcc,extraDataLen,extraData,bpp)
+{
+  codecId = 0;
+//                              memset(&_context,0,sizeof(_context));
+  _allowNull = 0;
+  _gmc = 0;
+  _context = NULL;
+  _refCopy = 0;
+  _usingMT = 0;
+#if LIBAVCODEC_BUILD >= 4624
+  _context = avcodec_alloc_context ();
+#else
+  _context = new AVCodecContext;
+  memset (_context, 0, sizeof (AVCodecContext));
+#endif
+  ADM_assert (_context);
+  memset (&_frame, 0, sizeof (_frame));
+
+  _context->max_b_frames = 0;
+
+  _context->width = _w;
+  _context->height = _h;
+  _context->pix_fmt = PIX_FMT_YUV420P;	//PIX_FMT_RGBA32
+  //_context->debug=1;
+
+  _internalBuffer = new uint8_t[w * h * 3];
+
+  _swapUV = 0;
+  //_context->strict_std_compliance=-1;
+
+  _showMv = 0;
+#define FF_SHOW		(FF_DEBUG_VIS_MV_P_FOR+	FF_DEBUG_VIS_MV_B_FOR+FF_DEBUG_VIS_MV_B_BACK)
+//#define FF_SHOW               (FF_DEBUG_VIS_MV_P_FOR)
+  printf ("[lavc] Build: %d\n", LIBAVCODEC_BUILD);
+  _context->debug_mv |= FF_SHOW;
+  _context->debug |= FF_DEBUG_VIS_MB_TYPE + FF_DEBUG_VIS_QP;
+  
+}
+
+//_____________________________________________________
+
+decoderFF::~decoderFF ()
+{
+  if (_usingMT)
+    {
+      printf ("[lavc] Killing decoding threads\n");
+      avcodec_thread_free (_context);
+      _usingMT = 0;
+    }
+
+  avcodec_close (_context);
+  ADM_dealloc (_context);
+  delete[]_internalBuffer;
+  printf ("[lavc] Destroyed\n");
+}
+
+/**
+    \fn frameType
+    \return frametype of the last decoded frame
+*/
+uint32_t decoderFF::frameType (void)
+{
+  uint32_t
+    flag = 0;
+
+  AVFrame *
+    target;
+#define SET(x) {flag=x;aprintf("Frame is %s\n",#x);}
+
+
+  target = &_frame;
+  switch (target->pict_type)
+    {
+    case FF_B_TYPE:
+      SET (AVI_B_FRAME);
+      if (target->key_frame)
+	aprintf ("\n But keyframe is set\n");
+      break;
+
+    case FF_I_TYPE:
+      SET (AVI_KEY_FRAME);
+      if (!target->key_frame)
+	{
+	  if (codecId == CODEC_ID_H264)
+	    {
+	      SET (AVI_P_FRAME);
+	    }
+	  else
+	    printf ("\n But keyframe is not set\n");
+	}
+      break;
+    case FF_S_TYPE:
+      _gmc = 1;			// No break, just inform that gmc is there
+    case FF_P_TYPE:
+      SET (AVI_P_FRAME);
+      if (target->key_frame)
+	aprintf ("\n But keyframe is set\n");
+      break;
+    default:
+//                              printf("\n OOops XXX frame ?\n");
+      break;
+    }
+    flag&=~AVI_STRUCTURE_TYPE_MASK;
+    if(target->interlaced_frame)
+    {
+        flag|=AVI_FIELD_STRUCTURE;
+        if(target->top_field_first)
+            flag|=AVI_TOP_FIELD;
+        else
+            flag|=AVI_BOTTOM_FIELD;
+    }
+  return flag;
+}
+bool decoderFF::decodeHeaderOnly (void)
+{
+  if (codecId == CODEC_ID_H264)
+    _context->hurry_up = 4;
+  else
+    _context->hurry_up = 5;
+  printf ("\n[lavc] Hurry up\n");
+  return 1;
+}
+bool decoderFF::decodeFull (void)
+{
+  _context->hurry_up = 0;
+  printf ("\n[lavc] full decoding\n");
+  return 1;
+}
+
+/**
+    \fn flush
+    \brief empty internal buffer
+*/
+bool    decoderFF::flush(void)
+{
+    if(_context)
+        avcodec_flush_buffers(_context);
+    return true;
+}
+/**
+    \fn uncompress
+    \brief Actually decode an image
+*/
+bool   decoderFF::uncompress (ADMCompressedImage * in, ADMImage * out)
+{
+  int got_picture = 0;
+  uint8_t *oBuff[3];
+  int strideTab[3];
+  int strideTab2[3];
+  int ret = 0;
+  out->_noPicture = 0;
+  if (_showMv)
+    {
+      _context->debug_mv |= FF_SHOW;
+      _context->debug |= 0;	//FF_DEBUG_VIS_MB_TYPE;
+    }
+  else
+    {
+      _context->debug_mv &= ~FF_SHOW;
+      _context->debug &= ~(FF_DEBUG_VIS_MB_TYPE + FF_DEBUG_VIS_QP);
+    }
+
+   
+    
+  if (in->dataLength == 0 && !_allowNull)	// Null frame, silently skipped
+    {
+      
+      printf ("[Codec] null frame\n");
+        // search the last image
+        if (_context->coded_frame && 
+            _context->coded_frame->data &&
+            _context->coded_frame->data[0]
+            )
+          {
+            printf("[Codec] Cloning older pic\n");
+            clonePic (_context->coded_frame, out);
+            out->Pts=ADM_COMPRESSED_NO_PTS;
+          }
+        else
+            {
+                out->_noPicture = 1;
+                out->Pts=ADM_COMPRESSED_NO_PTS;
+                printf("[Codec] No Picture\n");
+            }
+          return 1;
+    }
+   // Put a safe value....
+   out->Pts=in->demuxerPts;
+    _context->reordered_opaque=in->demuxerPts;
+  //_frame.opaque=(void *)out->Pts;
+  //printf("Incoming Pts :%"LLD"\n",out->Pts);
+  AVPacket pkt;
+  av_init_packet(&pkt);
+  pkt.data=in->data;
+  pkt.size=in->dataLength;
+  if(in->flags&AVI_KEY_FRAME)
+    pkt.flags=AV_PKT_FLAG_KEY;
+  else
+    pkt.flags=0;
+  
+  ret = avcodec_decode_video2 (_context, &_frame, &got_picture, &pkt);
+  if(!bFramePossible())
+  {
+    // No delay, the value is sure, no need to hide it in opaque
+    _context->reordered_opaque=(int64_t)in->demuxerPts;
+  }
+  out->_qStride = 0;		//Default = no quant
+  if (0 > ret && !_context->hurry_up)
+    {
+      printf ("\n[lavc] error in lavcodec decoder!\n");
+      printf ("[lavc] Err: %d, size :%d\n", ret, in->dataLength);
+      return 0;
+    }
+  if (!got_picture && !_context->hurry_up)
+    {
+      // Some encoder code a vop header with the 
+      // vop flag set to 0
+      // it is meant to mean frame skipped but very dubious
+      if (in->dataLength <= 8 && codecId == CODEC_ID_MPEG4)
+	{
+	  printf ("[lavc] Probably pseudo black frame...\n");
+	  out->_Qp = 2;
+	  out->flags = 0;	// assume P ?
+
+	  clonePic (_context->coded_frame, out);
+	  return 1;
+	}
+      // allow null means we allow null frame in and so potentially
+      // have no frame out for a time
+      // in that case silently fill with black and returns it as KF
+      if (_allowNull)
+	{
+	  out->flags = AVI_KEY_FRAME;
+	  if (!_refCopy)
+	    {
+            out->blacken();
+	    }
+	  else
+	    {
+	      out->_noPicture = 1;
+	    }
+	  printf ("\n[lavc] ignoring got pict ==0\n");
+	  return 1;
+
+	}
+#if 0
+      printf ("[lavc] Err: %d, size: %d\n", ret, in->dataLength);
+      printf ("\n[lavc] error in FFMP43/mpeg4!: got picture\n");
+#endif
+      //GUI_Alert("Please retry with misc->Turbo off");
+      //return 1;
+      return 0;
+    }
+  if (_context->hurry_up)
+    {
+      out->flags = frameType ();
+      return 1;
+    }
+  // We have an image....
+  switch (_context->pix_fmt)
+    {
+    case PIX_FMT_YUV411P:
+      out->_colorspace = ADM_COLOR_YUV411;
+      break;
+    case PIX_FMT_YUYV422:
+      out->_colorspace = ADM_COLOR_YUV422;
+      break;
+    case PIX_FMT_YUV422P:
+    case PIX_FMT_YUVJ422P:
+      out->_colorspace = ADM_COLOR_YUV422P;
+      break;
+    case PIX_FMT_YUV444P:
+    case PIX_FMT_YUVJ444P:
+      out->_colorspace = ADM_COLOR_YUV444;
+      break;
+    case PIX_FMT_YUV420P:
+    case PIX_FMT_YUVJ420P:
+    case PIX_FMT_YUVA420P:
+      // Default is YV12 or I420
+      // In that case depending on swap u/v
+      // we do it or not
+      out->_colorspace = ADM_COLOR_YV12;
+      break;
+	case PIX_FMT_RGB24:
+	  out->_colorspace = ADM_COLOR_BGR24;
+	  break;
+    case PIX_FMT_BGRA:
+      out->_colorspace = ADM_COLOR_BGR32A;
+      break;
+    case PIX_FMT_RGBA: // ???PIX_FMT_RGBA32:
+      out->_colorspace = ADM_COLOR_RGB32A;
+      break;
+    case PIX_FMT_RGB555:
+      out->_colorspace = ADM_COLOR_RGB555;
+      break;
+    case PIX_FMT_VDPAU_MPEG1:
+    case PIX_FMT_VDPAU_MPEG2:
+    case PIX_FMT_VDPAU_WMV3:
+    case PIX_FMT_VDPAU_VC1:
+    case PIX_FMT_VDPAU_H264:
+        out->_colorspace=ADM_COLOR_VDPAU;
+        break;
+    default:
+      printf ("[lavc] Unhandled colorspace: %d\n", _context->pix_fmt);
+      return 0;
+    }
+    clonePic (&_frame, out);
+    //printf("[AvCodec] Pts : %llu Out Pts:%llu \n",_frame.pts,out->Pts);
+
+  return 1;
+}
+// *******************************************************************
+// *******************************************************************
+// *******************************************************************
+
+decoderFFDiv3::decoderFFDiv3 (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp):
+decoderFF (w, h,fcc,extraDataLen,extraData,bpp)
+{
+  _refCopy = 1;			// YUV420 only
+  WRAP_Open (CODEC_ID_MSMPEG4V3);
+}
+
+decoderFFMpeg4::decoderFFMpeg4 (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp):
+decoderFF (w, h,fcc,extraDataLen,extraData,bpp)
+{
+// force low delay as avidemux don't handle B-frames
+  ADM_info ("[lavc] Using %d bytes of extradata for MPEG4 decoder\n", (int)extraDataLen);
+  
+  _refCopy = 1;			// YUV420 only
+  _context->extradata = (uint8_t *) extraData;
+  _context->extradata_size = (int)extraDataLen  ;
+  _context->codec_tag=fcc;
+  _context->stream_codec_tag=fcc;
+  decoderMultiThread ();
+  //  _context->flags|=FF_DEBUG_VIS_MV;
+  WRAP_Open (CODEC_ID_MPEG4);
+}
+bool decoderFFMpeg4::uncompress (ADMCompressedImage * in, ADMImage * out)
+{
+    // For pseudo startcode
+    if(in->dataLength)
+    {
+        in->data[in->dataLength]=0;
+        in->data[in->dataLength+1]=0;
+    }
+    return decoderFF::uncompress(in,out);
+
+}
+//************************************
+decoderFFDV::decoderFFDV (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp):
+decoderFF (w, h,fcc,extraDataLen,extraData,bpp)
+{
+  _context->extradata = (uint8_t *) extraData;
+  _context->extradata_size = (int) extraDataLen;
+  WRAP_Open (CODEC_ID_DVVIDEO);
+
+}
+decoderFFMpeg12::decoderFFMpeg12 (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp):
+                decoderFF (w, h,fcc,extraDataLen,extraData,bpp)
+{
+  _refCopy = 1;			// YUV420 only
+  decoderMultiThread ();
+  WRAP_Open (CODEC_ID_MPEG2VIDEO);
+}
+
+decoderFFPng::decoderFFPng(uint32_t w, uint32_t h, uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData, uint32_t bpp) : decoderFF(w, h, fcc, extraDataLen, extraData, bpp)
+{
+	WRAP_Open (CODEC_ID_PNG);
+}
+
+decoderFF_ffhuff::decoderFF_ffhuff (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp)
+:decoderFF (w, h,fcc,extraDataLen,extraData,bpp)
+{
+  _context->extradata = (uint8_t *) extraData;
+  _context->extradata_size = (int) extraDataLen;
+  _context->bits_per_coded_sample=bpp;
+  ADM_info ("[lavc] FFhuff: We have %d bytes of extra data\n", (int)extraDataLen);
+  WRAP_Open (CODEC_ID_FFVHUFF);
+
+}
+decoderFFH264::decoderFFH264 (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp)
+        :decoderFF (w, h,fcc,extraDataLen,extraData,bpp)
+{
+
+  _refCopy = 1;			// YUV420 only
+  _context->extradata = (uint8_t *) extraData;
+  _context->extradata_size = (int) extraDataLen;
+  decoderMultiThread ();
+  ADM_info ("[lavc] Initializing H264 decoder with %d extradata\n", (int)extraDataLen);
+  WRAP_Open(CODEC_ID_H264);
+}
+//*********************
+extern "C" {int av_getAVCStreamInfo(AVCodecContext *avctx, uint32_t  *nalSize, uint32_t *isAvc);}
+/**
+    \fn uncompress
+*/
+bool   decoderFFH264::uncompress (ADMCompressedImage * in, ADMImage * out)
+{
+  if(!_context->hurry_up) return decoderFF::uncompress (in, out);
+    ADM_assert(0);
+#if 0  
+  uint32_t nalSize, isAvc;
+  av_getAVCStreamInfo(_context,&nalSize,&isAvc);
+  if(isAvc)
+  {
+      return extractH264FrameType(nalSize, in->data,in->dataLength,&(out->flags));
+  }else
+  {
+    return extractH264FrameType_startCode(nalSize, in->data,in->dataLength,&(out->flags));
+  }
+#endif
+}
+//*********************
+decoderFFhuff::decoderFFhuff (uint32_t w, uint32_t h,uint32_t fcc, uint32_t extraDataLen, uint8_t *extraData,uint32_t bpp):
+decoderFF (w, h,fcc,extraDataLen,extraData,bpp)
+{
+  _context->extradata = (uint8_t *) extraData;
+  _context->extradata_size = (int) extraDataLen;
+  _context->bits_per_coded_sample = bpp;
+  WRAP_Open (CODEC_ID_HUFFYUV);
+}
+
+//***************
+extern uint8_t  lavformat_init(void);
+extern void     avcodec_init(void );
+extern  void    avcodec_register_all(void );
+extern "C"
+{
+  void adm_lavLogCallback(void  *instance, int level, const char* fmt, va_list list);
+}
+/**
+    \fn ADM_lavInit
+    \brief Init both lavcodec and lavformat
+*/
+void ADM_lavInit(void)
+{
+    avcodec_init();
+    avcodec_register_all();
+//BAZOOKA    lavformat_init();
+    av_log_set_callback(adm_lavLogCallback);
+#ifdef ADM_DEBUG
+  //  av_log_set_level(AV_LOG_DEBUG);
+#endif
+
+}
+void adm_lavLogCallback(void  *instance, int level, const char* fmt, va_list list)
+{
+   // if(level>1) return;
+    char buf[256];
+  
+    vsnprintf(buf, sizeof(buf), fmt, list);
+    if(level<=AV_LOG_INFO)
+        ADM_info("[lavc] %s",buf);
+}
+
+void ADM_lavDestroy(void)
+{
+	//av_free_static();
+}
+
+// EOF



From mean at mail.berlios.de  Wed Oct  6 07:42:10 2010
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Wed,  6 Oct 2010 07:42:10 +0200
Subject: [Avidemux-svn-commit] r6698 -
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/vdpauFilters
Message-ID: <20101006054210.89459480E0A@sheep.berlios.de>

Author: mean
Date: 2010-10-06 07:42:10 +0200 (Wed, 06 Oct 2010)
New Revision: 6698

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/vdpauFilters/ADM_vidVdpauFilterDeint.cpp
Log:
[vdpau videoFilter] Dont swap u & v, no needed with latest nvidia

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/vdpauFilters/ADM_vidVdpauFilterDeint.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/vdpauFilters/ADM_vidVdpauFilterDeint.cpp	2010-10-06 05:42:08 UTC (rev 6697)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/vdpauFilters/ADM_vidVdpauFilterDeint.cpp	2010-10-06 05:42:10 UTC (rev 6698)
@@ -382,10 +382,10 @@
     // Invert U&V
     uint32_t ts;
     uint8_t  *td;
-
+#if 0
     ts=destStride[2];destStride[2]=destStride[1];destStride[1]=ts;
-    td=destData[2];destData[2]=destData[1];destData[1]=td;
-
+    td=destData[1];destData[2]=destData[2];destData[1]=td;
+#endif
     scaler->convertPlanes(  sourceStride,destStride,     
                             sourceData,destData);
     return true;



From mean at mail.berlios.de  Wed Oct  6 07:42:11 2010
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Wed,  6 Oct 2010 07:42:11 +0200
Subject: [Avidemux-svn-commit] r6699 - in
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6:
	. fastConvolution
Message-ID: <20101006054211.D3875480E0A@sheep.berlios.de>

Author: mean
Date: 2010-10-06 07:42:11 +0200 (Wed, 06 Oct 2010)
New Revision: 6699

Added:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/fastConvolution/
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/fastConvolution/ADM_vidConvolution.hxx
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/fastConvolution/ADM_vidFastConvolution.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/fastConvolution/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/fastConvolution/Gauss.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/fastConvolution/Mean.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/fastConvolution/Median.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/fastConvolution/Sharpen.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/fastConvolution/convolution.conf
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/fastConvolution/convolution.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/fastConvolution/convolution_desc.cpp
Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/CMakeLists.txt
Log:
[VideoFilter] Fast convolution

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/CMakeLists.txt	2010-10-06 05:42:10 UTC (rev 6698)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/CMakeLists.txt	2010-10-06 05:42:11 UTC (rev 6699)
@@ -3,6 +3,7 @@
 ADD_SUBDIRECTORY(blackenBorder)
 ADD_SUBDIRECTORY(crop)
 ADD_SUBDIRECTORY(dummy)
+ADD_SUBDIRECTORY(fastConvolution)
 ADD_SUBDIRECTORY(kernelDeint)
 ADD_SUBDIRECTORY(lavDeint)
 ADD_SUBDIRECTORY(logo)

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/fastConvolution/ADM_vidConvolution.hxx
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/fastConvolution/ADM_vidConvolution.hxx	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/fastConvolution/ADM_vidConvolution.hxx	2010-10-06 05:42:11 UTC (rev 6699)
@@ -0,0 +1,129 @@
+/***************************************************************************
+                          ADM_vidConvolution.hxx  -  description
+                             -------------------
+    begin                : Wed Apr 10 2002
+    copyright            : (C) 2002 by mean
+    email                : fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#ifndef ADM_CONVOLUTION_H
+#define ADM_CONVOLUTION_H
+
+#include "ADM_default.h"
+#include "ADM_coreVideoFilterInternal.h"
+#include "DIA_coreToolkit.h"
+#include "convolution.h"
+
+/**
+    \class AVDMFastVideoConvolution
+*/
+ class  AVDMFastVideoConvolution:public ADM_coreVideoFilter
+ {
+
+ protected:
+
+	virtual uint8_t doLine(uint8_t *pred, uint8_t *cur, uint8_t *next, uint8_t *out, uint32_t w)
+                      { UNUSED_ARG(pred); UNUSED_ARG(cur); UNUSED_ARG(next); UNUSED_ARG(out); UNUSED_ARG(w);
+                                return 0;}
+        
+                      convolution	param;
+                      ADMImage      *image;
+                    bool                processPlane(ADMImage *s,ADMImage *d,ADM_PLANE plane);
+ public:
+                                        AVDMFastVideoConvolution(ADM_coreVideoFilter *previous,CONFcouple *conf);
+                                        ~AVDMFastVideoConvolution();
+                    virtual const char   *getConfiguration(void); 
+                    virtual bool         getNextFrame(uint32_t *fn,ADMImage *image);    /// Return the next image
+                    virtual bool         getCoupledConf(CONFcouple **couples) ;   /// Return the current filter configuration
+                    virtual bool         configure(void) ;           /// Start graphical user interface
+            
+
+}     ;
+/**
+
+*/
+ class    AVDMFastVideoMean: public AVDMFastVideoConvolution
+ {
+        protected:
+            virtual uint8_t doLine(uint8_t  *pred,
+                                  uint8_t *cur,
+                                  uint8_t *next,
+                                  uint8_t *out,
+                                  uint32_t w)   ;
+
+        public:
+
+                                    AVDMFastVideoMean(  ADM_coreVideoFilter *in,CONFcouple *setup) :
+                                    AVDMFastVideoConvolution(  in,setup) {};
+              virtual const char 	*getConfiguration(void);
+
+	}      ;
+
+/**
+
+*/
+   class    AVDMFastVideoGauss: public AVDMFastVideoConvolution
+ {
+    protected:
+              virtual uint8_t 		doLine(uint8_t  *pred,
+                                              uint8_t *cur,
+                                              uint8_t *next,
+                                              uint8_t *out,
+                                              uint32_t w)   ;
+  
+		public:
+
+                                    AVDMFastVideoGauss(  ADM_coreVideoFilter *in,CONFcouple *setup) :
+                                    AVDMFastVideoConvolution(  in,setup) {};
+             virtual const char 	*getConfiguration(void);
+	}      ;
+/**
+
+*/
+     class    AVDMFastVideoSharpen: public AVDMFastVideoConvolution
+ {
+        protected:
+            virtual uint8_t 		doLine(uint8_t  *pred,
+                                                uint8_t *cur,
+                                                uint8_t *next,
+                                                uint8_t *out,
+                                                uint32_t w)   ;
+
+          public:
+
+                                      AVDMFastVideoSharpen(  ADM_coreVideoFilter *in,CONFcouple *setup) :
+                                      AVDMFastVideoConvolution(  in,setup) {};
+             virtual const char 	*getConfiguration(void);	
+                      
+};
+/**
+
+*/
+  class    AVDMFastVideoMedian: public AVDMFastVideoConvolution
+ {
+        protected:
+          virtual uint8_t 	doLine(uint8_t  *pred,
+                                        uint8_t *cur,
+                                        uint8_t *next,
+                                        uint8_t *out,
+                                        uint32_t w)   ;
+
+        public:
+
+                                AVDMFastVideoMedian(  ADM_coreVideoFilter *in,CONFcouple *setup) :
+                                AVDMFastVideoConvolution(  in,setup) {};
+            virtual const char 	*getConfiguration(void);	
+ };
+
+//EOF
+
+#endif

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/fastConvolution/ADM_vidFastConvolution.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/fastConvolution/ADM_vidFastConvolution.cpp	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/fastConvolution/ADM_vidFastConvolution.cpp	2010-10-06 05:42:11 UTC (rev 6699)
@@ -0,0 +1,163 @@
+/***************************************************************************
+                          ADM_vidFastConvolution.cpp  -  description
+                             -------------------
+    begin                : Sat Nov 23 2002
+    copyright            : (C) 2002 by mean
+    email                : fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include "ADM_vidConvolution.hxx"
+#include "convolution_desc.cpp"
+#include "DIA_factory.h"
+/**
+    \fn getCoupledConf
+*/
+bool         AVDMFastVideoConvolution::getCoupledConf(CONFcouple **couples)
+{
+ return ADM_paramSave(couples, convolution_param,&param);
+}
+
+/**
+    \fn ctor
+*/
+AVDMFastVideoConvolution::AVDMFastVideoConvolution(
+			ADM_coreVideoFilter *in,CONFcouple *couples) : ADM_coreVideoFilter(in,couples)
+{
+    if(!couples || !ADM_paramLoad(couples,convolution_param,&param))
+    {
+        param.chroma=1;
+        param.luma=1;
+	}
+    image=new ADMImageDefault(info.width,info.height);
+    myName="Convolution";
+}
+/**
+    \fn dtor
+*/
+AVDMFastVideoConvolution::~AVDMFastVideoConvolution()
+{
+	if(image) delete image;
+    image=NULL;
+}
+/**
+    \fn copyPlane
+*/
+static void copyPlane(ADMImage *s, ADMImage *d, ADM_PLANE plane)
+{
+        uint8_t *src=s->GetReadPtr(plane);
+        uint8_t *dst=d->GetWritePtr(plane);
+        uint32_t sPitch=s->GetPitch(plane);
+        uint32_t dPitch=d->GetPitch(plane);
+        uint32_t w=s->_width;  
+        uint32_t h=s->_height;
+        if(plane!=PLANAR_Y) 
+        {
+            w>>=1;
+            h>>=1;
+        }
+        BitBlit(dst,dPitch,src,sPitch,w,h);
+}
+/**
+    \fn processPlane
+*/
+bool AVDMFastVideoConvolution::processPlane(ADMImage *s,ADMImage *d,ADM_PLANE plane)
+{
+        uint8_t *src=s->GetReadPtr(plane);
+        uint8_t *dst=d->GetWritePtr(plane);
+        uint32_t sPitch=s->GetPitch(plane);
+        uint32_t dPitch=d->GetPitch(plane);
+        uint32_t w=info.width;  
+        uint32_t h=info.height;
+        if(plane!=PLANAR_Y) 
+        {
+            w>>=1;
+            h>>=1;
+        }
+	// first and last line
+		memcpy(dst,src,w);
+        memcpy(dst+(h-1)*dPitch,src+(h-1)*sPitch,w);
+    // Other lines
+        uint8_t *o1,*x1,*x2,*x3;
+        o1=dst+dPitch;
+		x1=src;
+		x2=x1+sPitch;
+		x3=x2+sPitch;
+
+		// Luma
+		for(int32_t y=1;y<h-1;y++)
+		{
+			doLine(x1,x2,x3,o1,w);
+			x1=x2;
+			x2=x3;
+			x3+=sPitch; 
+			o1+=dPitch;                 
+		}
+}
+/**
+    \fn getNextFrame
+*/
+bool         AVDMFastVideoConvolution::getNextFrame(uint32_t *fn,ADMImage *data)
+{
+uint8_t *x1,*x2,*x3,*o1;
+uint32_t stride,page;
+
+	
+	ADM_assert(image);					
+	// read uncompressed frame
+	if(!previousFilter->getNextFrame(fn,image)) return 0;               
+         
+    // Luma...
+	if(!param.luma)
+	{
+        copyPlane(image,data,PLANAR_Y);
+	}
+	else
+	{
+        processPlane(image,data,PLANAR_Y);
+	}
+    // chroma u & v
+	if(!param.chroma)
+	{
+        copyPlane(image,data,PLANAR_U);
+        copyPlane(image,data,PLANAR_V);
+	}
+	else
+	{
+        processPlane(image,data,PLANAR_U);
+        processPlane(image,data,PLANAR_V);
+	}
+	data->copyInfo(image);
+    return 1;
+}
+/**
+    \fn configure
+*/
+bool AVDMFastVideoConvolution::configure(void)
+{
+  
+  //return DIA_getLumaChroma(&(_param->luma),&(_param->chroma)) ; 
+  diaElemToggle luma(&(param.luma),QT_TR_NOOP("_Process luma"),QT_TR_NOOP("Process luma plane"));
+  diaElemToggle chroma(&(param.chroma),QT_TR_NOOP("P_rocess chroma"));
+  
+  diaElem *elems[2]={&luma,&chroma};
+  
+  return diaFactoryRun(QT_TR_NOOP("Fast Convolution"),2,elems);
+}
+/**
+    \fn getConfiguration
+*/
+const char   *AVDMFastVideoConvolution::getConfiguration(void)
+{
+    return "oops, you should never see that";
+}
+
+// EOF

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/fastConvolution/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/fastConvolution/CMakeLists.txt	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/fastConvolution/CMakeLists.txt	2010-10-06 05:42:11 UTC (rev 6699)
@@ -0,0 +1,19 @@
+INCLUDE(vf_plugin)
+
+MACRO(CONV_FILTER FILTERNAME FILTERSRC)
+ADD_VIDEO_FILTER( ${FILTERNAME} ${FILTERSRC} ADM_vidFastConvolution.cpp )
+INIT_VIDEO_FILTER(${FILTERNAME})
+INSTALL_VIDEO_FILTER(${FILTERNAME})
+ENDMACRO(CONV_FILTER FILTERNAME FILTERSRC)
+
+CONV_FILTER(ADM_vf_mean    Mean.cpp )
+CONV_FILTER(ADM_vf_gauss   Gauss.cpp )
+CONV_FILTER(ADM_vf_median  Median.cpp )
+CONV_FILTER(ADM_vf_sharpen Sharpen.cpp )
+
+
+#SET(ADM_vf_fastconvolutionsharpen_SRCS ADM_vidFastConvolution.cpp Sharpen.cpp )
+#ADD_LIBRARY(ADM_vf_fastconvolutionsharpen SHARED ${ADM_vf_fastconvolutionsharpen_SRCS})
+#INIT_VIDEOFILTER_PLUGIN(ADM_vf_fastconvolutionsharpen)
+#INSTALL_VIDEOFILTER(ADM_vf_fastconvolutionsharpen)
+

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/fastConvolution/Gauss.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/fastConvolution/Gauss.cpp	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/fastConvolution/Gauss.cpp	2010-10-06 05:42:11 UTC (rev 6699)
@@ -0,0 +1,112 @@
+/***************************************************************************
+                          ADM_vidFastConvolution.cpp  -  description
+                             -------------------
+    begin                : Sat Nov 23 2002
+    copyright            : (C) 2002 by mean
+    email                : fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include "ADM_vidConvolution.hxx"
+#include "convolution_desc.cpp"
+
+DECLARE_VIDEO_FILTER(   AVDMFastVideoGauss,   // Class
+                        1,0,0,              // Version
+                        ADM_UI_ALL,         // UI
+                        VF_NOISE,            // Category
+                        "Gaussian",            // internal name (must be uniq!)
+                        "Gaussian convolution.",            // Display name
+                        "3x3 convolution filter :gaussian." // Description
+                    );
+
+/**
+    \fn getConfiguration
+*/
+//          6 10 6
+//         10 16 10 *1/80
+//		    6 10 6
+const char 							*AVDMFastVideoGauss::getConfiguration(void)
+{
+		static char str[]="Gauss(fast)";
+		return (char *)str;
+	
+}
+/**
+    \fn doLine
+*/
+
+ uint8_t AVDMFastVideoGauss::doLine(uint8_t  *pred,
+                                    uint8_t *cur,
+                                    uint8_t *next,
+                                    uint8_t *out,
+                                    uint32_t w)
+{
+	uint8_t a1,a2,a3;
+	uint8_t b1,b2,b3;
+	uint8_t c1,c2,c3;
+	int32_t o;
+//#define MASKED__	
+#define threshold 80
+	int v,r;
+	
+	a2=*pred++;a3=*pred++;
+	b2=*cur++;b3=*cur++;
+	c2=*next++;c3=*next++;
+	
+	*out++=b2;
+	w--;
+	
+	while(w>1)
+	{
+			a1=a2;
+			a2=a3;
+			a3=*pred++;
+			b1=b2;
+			b2=b3;
+			b3=*cur++;
+			c1=c2;
+			c2=c3;
+			c3=*next++;
+		
+		  //
+#ifdef MASKED__
+		v=b2;
+		r=16;
+		o=b2*16;
+		#define MORE(x,coef) if(abs(x-v)<=threshold) {o+=x*coef;r+=coef;}
+		MORE(a1,6);
+		MORE(a2,10);
+		MORE(a3,6);
+		
+		MORE(b1,10);
+		MORE(b3,10);
+		
+		MORE(c1,6);
+		MORE(c2,10);
+		MORE(c3,6);
+		
+		o=(o+r-1)/r;		
+		
+#else		  
+		  o=6*a1+10*a2+6*a3+10*b1+16*b2+10*b3+6*c1+10*c2+6*c3;		  
+		  o/=80;
+#endif		  
+		  
+		  *out++=o;
+		  w--;
+	}	
+	*out++=b3;
+		return 1;
+}
+
+
+
+

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/fastConvolution/Mean.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/fastConvolution/Mean.cpp	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/fastConvolution/Mean.cpp	2010-10-06 05:42:11 UTC (rev 6699)
@@ -0,0 +1,84 @@
+/***************************************************************************
+                          ADM_vidFastConvolution.cpp  -  description
+                             -------------------
+    begin                : Sat Nov 23 2002
+    copyright            : (C) 2002 by mean
+    email                : fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include "ADM_vidConvolution.hxx"
+#include "convolution_desc.cpp"
+
+
+DECLARE_VIDEO_FILTER(   AVDMFastVideoMean,   // Class
+                        1,0,0,              // Version
+                        ADM_UI_ALL,         // UI
+                        VF_NOISE,            // Category
+                        "Mean",            // internal name (must be uniq!)
+                        "Mean convolution.",            // Display name
+                        "3x3 convolution filter :mean." // Description
+                    );
+
+/**
+    \fn getConfiguration
+*/
+
+const char 	*AVDMFastVideoMean::getConfiguration(void)
+{
+		static char str[]="Mean(fast)";
+		return (char *)str;
+	
+}
+/**
+    \fn doLine
+*/
+
+uint8_t AVDMFastVideoMean::doLine(uint8_t  *pred,
+                            uint8_t *cur,
+                            uint8_t *next,
+                            uint8_t *out,
+                            uint32_t w)
+{
+	uint8_t a1,a2,a3;
+	uint8_t b1,b2,b3;
+	uint8_t c1,c2,c3;
+	int32_t o;
+	
+	a2=*pred++;a3=*pred++;
+	b2=*cur++;b3=*cur++;
+	c2=*next++;c3=*next++;
+	
+	*out++=b2;
+	w--;
+	
+	while(w>1)
+	{
+			a1=a2;
+			a2=a3;
+			a3=*pred++;
+			b1=b2;
+			b2=b3;
+			b3=*cur++;
+			c1=c2;
+			c2=c3;
+			c3=*next++;
+		
+		  //
+		  o=a1+a2+a3+b1+b2+b3+c1+c2+c3;
+		  o/=9;
+		  
+		  *out++=o;
+		  w--;
+	}	
+		*out++=b3;
+		return 1;
+}

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/fastConvolution/Median.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/fastConvolution/Median.cpp	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/fastConvolution/Median.cpp	2010-10-06 05:42:11 UTC (rev 6699)
@@ -0,0 +1,94 @@
+/***************************************************************************
+                          ADM_vidFastConvolution.cpp  -  description
+                             -------------------
+    begin                : Sat Nov 23 2002
+    copyright            : (C) 2002 by mean
+    email                : fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include "ADM_vidConvolution.hxx"
+#include "convolution_desc.cpp"
+
+
+
+DECLARE_VIDEO_FILTER(   AVDMFastVideoMedian,   // Class
+                        1,0,0,              // Version
+                        ADM_UI_ALL,         // UI
+                        VF_NOISE,            // Category
+                        "Median",            // internal name (must be uniq!)
+                        "Median convolution.",            // Display name
+                        "3x3 convolution filter :median." // Description
+                    );
+/**
+    \fn getConfiguration
+*/
+
+const char 							*AVDMFastVideoMedian::getConfiguration(void)
+{
+		static char str[]="Median(fast)";
+		return (char *)str;
+	
+}
+/**
+    \fn doLine
+*/
+ uint8_t AVDMFastVideoMedian::doLine(uint8_t  *pred,
+                                    uint8_t *cur,
+                                    uint8_t *next,
+                                    uint8_t *out,
+                                    uint32_t w)
+{
+	uint8_t a1,a2,a3;
+	uint8_t b1,b2,b3;
+	uint8_t c1,c2,c3; //,i;
+	//int32_t o;
+	uint8_t temp;
+	
+	static uint8_t tab[9];
+	a2=*pred++;a3=*pred++;
+	b2=*cur++;b3=*cur++;
+	c2=*next++;c3=*next++;
+	
+	*out++=b2;
+	w--;
+	
+	while(w>1)
+	{
+			tab[0]=a1=a2;
+			tab[1]=a2=a3;
+			tab[2]=a3=*pred++;
+			tab[3]=b1=b2;
+			tab[4]=b2=b3;
+			tab[5]=b3=*cur++;
+			tab[6]=c1=c2;
+			tab[7]=c2=c3;
+			tab[8]=c3=*next++;
+		
+#define PIX_SORT(a,b) { if ((a)>(b)) PIX_SWAP((a),(b)); }
+#define PIX_SWAP(a,b) { temp=(a);(a)=(b);(b)=temp; }
+
+   uint8_t *p=(uint8_t *)tab;
+								
+    PIX_SORT(p[1], p[2]) ; PIX_SORT(p[4], p[5]) ; PIX_SORT(p[7], p[8]) ;
+    PIX_SORT(p[0], p[1]) ; PIX_SORT(p[3], p[4]) ; PIX_SORT(p[6], p[7]) ;
+    PIX_SORT(p[1], p[2]) ; PIX_SORT(p[4], p[5]) ; PIX_SORT(p[7], p[8]) ;
+    PIX_SORT(p[0], p[3]) ; PIX_SORT(p[5], p[8]) ; PIX_SORT(p[4], p[7]) ;
+    PIX_SORT(p[3], p[6]) ; PIX_SORT(p[1], p[4]) ; PIX_SORT(p[2], p[5]) ;
+    PIX_SORT(p[4], p[7]) ; PIX_SORT(p[4], p[2]) ; PIX_SORT(p[6], p[4]) ;
+    PIX_SORT(p[4], p[2]) ; 
+		  
+		  *out++=tab[4];
+		  w--;
+	}	
+	*out++=b3;
+	return 1;
+}

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/fastConvolution/Sharpen.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/fastConvolution/Sharpen.cpp	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/fastConvolution/Sharpen.cpp	2010-10-06 05:42:11 UTC (rev 6699)
@@ -0,0 +1,97 @@
+/***************************************************************************
+                          ADM_vidFastConvolution.cpp  -  description
+                             -------------------
+    begin                : Sat Nov 23 2002
+    copyright            : (C) 2002 by mean
+    email                : fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include "ADM_vidConvolution.hxx"
+#include "convolution_desc.cpp"
+
+
+DECLARE_VIDEO_FILTER(   AVDMFastVideoSharpen,   // Class
+                        1,0,0,              // Version
+                        ADM_UI_ALL,         // UI
+                        VF_SHARPNESS,            // Category
+                        "Sharpen",            // internal name (must be uniq!)
+                        "Sharpen convolution.",            // Display name
+                        "3x3 convolution filter :sharpen." // Description
+                    );
+
+/**
+    \fn getConfiguration
+*/
+
+//         -1 -2 -1
+ 	//         -2 16 -2 *1/16
+  	//		    -1 -2 -1
+const char 							*AVDMFastVideoSharpen::getConfiguration(void)
+{
+		static char str[]="Sharpen(fast)";
+		return (char *)str;
+	
+}
+/**
+    \fn doLine
+*/
+
+ uint8_t AVDMFastVideoSharpen::doLine(uint8_t  *pred,
+                                    uint8_t *cur,
+                                    uint8_t *next,
+                                    uint8_t *out,
+                                    uint32_t w)
+{
+	uint8_t a1,a2,a3;
+	uint8_t b1,b2,b3;
+	uint8_t c1,c2,c3;
+	int32_t o;
+	
+	a2=*pred++;a3=*pred++;
+	b2=*cur++;b3=*cur++;
+	c2=*next++;c3=*next++;
+	
+	*out++=b2;
+	w--;
+	
+	while(w>1)
+	{
+			a1=a2;
+			a2=a3;
+			a3=*pred++;
+			b1=b2;
+			b2=b3;
+			b3=*cur++;
+			c1=c2;
+			c2=c3;
+			c3=*next++;
+		
+		  //
+		  //         -1 -2 -1
+ 	//         -2 16 -2 *1/16
+  	//		    -1 -2 -1
+		  //o=-a1+-2*a2+-a3+-2*b1+16*b2+-2*b3+-1*c1+-2*c2+-1*c3;
+		  //o/=16;
+		  o=4*b2-a2-c2-b1-b3;
+		  o>>=2;
+		  o+=3*a2;
+		  o=o/3;
+		  if(o<0) o=0;
+		  if(o>255) o=255;
+		  
+		  *out++=o;
+		  w--;
+	}	
+	*out++=b3;
+		return 1;
+}
+// EOF

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/fastConvolution/convolution.conf
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/fastConvolution/convolution.conf	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/fastConvolution/convolution.conf	2010-10-06 05:42:11 UTC (rev 6699)
@@ -0,0 +1,2 @@
+uint32_t:luma; 
+uint32_t:chroma; 

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/fastConvolution/convolution.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/fastConvolution/convolution.h	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/fastConvolution/convolution.h	2010-10-06 05:42:11 UTC (rev 6699)
@@ -0,0 +1,9 @@
+// Automatically generated, do not edit!
+#ifndef ADM_convolution_CONF_H
+#define ADM_convolution_CONF_H
+typedef struct {
+   uint32_t luma;
+   uint32_t chroma;
+}convolution;
+#endif //convolution
+//EOF

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/fastConvolution/convolution_desc.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/fastConvolution/convolution_desc.cpp	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/fastConvolution/convolution_desc.cpp	2010-10-06 05:42:11 UTC (rev 6699)
@@ -0,0 +1,6 @@
+// Automatically generated, do not edit!
+const ADM_paramList convolution_param[]={
+ {"luma",offsetof( convolution,luma),"uint32_t",ADM_param_uint32_t},
+ {"chroma",offsetof( convolution,chroma),"uint32_t",ADM_param_uint32_t},
+{NULL,0,NULL}
+};



From gruntster at mail.berlios.de  Sun Oct 10 15:45:42 2010
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Sun, 10 Oct 2010 15:45:42 +0200
Subject: [Avidemux-svn-commit] r6700 -
	branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264
Message-ID: <20101010134542.6A3E8481099@sheep.berlios.de>

Author: gruntster
Date: 2010-10-10 15:45:42 +0200 (Sun, 10 Oct 2010)
New Revision: 6700

Modified:
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/x264Options.cpp
Log:
[x264] correctly load hrd option

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/x264Options.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/x264Options.cpp	2010-10-06 05:42:11 UTC (rev 6699)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/x264Options.cpp	2010-10-10 13:45:42 UTC (rev 6700)
@@ -1710,13 +1710,11 @@
 			else if (strcmp((char*)xmlChild->name, "sliceCount") == 0)
 				setSliceCount(atoi(content));
 #if X264_BUILD > 88
-			else if (strcmp((char*)xmlChild->name, "hdr") == 0)
+			else if (strcmp((char*)xmlChild->name, "hrd") == 0)
 			{
-				unsigned int hdr = 0;
+				unsigned int hdr = X264_NAL_HRD_NONE;
 
-				if (strcmp(content, "none") == 0)
-					hdr = X264_NAL_HRD_NONE;
-				else if (strcmp(content, "vbr") == 0)
+				if (strcmp(content, "vbr") == 0)
 					hdr = X264_NAL_HRD_VBR;
 				else if (strcmp(content, "cbr") == 0)
 					hdr = X264_NAL_HRD_CBR;



From mean at mail.berlios.de  Wed Oct 13 08:27:39 2010
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Wed, 13 Oct 2010 08:27:39 +0200
Subject: [Avidemux-svn-commit] r6701 -
	branches/avidemux_2.6_branch_mean/avidemux/common/ADM_muxerGate/src
Message-ID: <20101013062739.7C73748114E@sheep.berlios.de>

Author: mean
Date: 2010-10-13 08:27:39 +0200 (Wed, 13 Oct 2010)
New Revision: 6701

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_muxerGate/src/ADM_videoCopyFromAnnexB.cpp
Log:
[annexB] Take only 5 bits from nalu

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_muxerGate/src/ADM_videoCopyFromAnnexB.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_muxerGate/src/ADM_videoCopyFromAnnexB.cpp	2010-10-10 13:45:42 UTC (rev 6700)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_muxerGate/src/ADM_videoCopyFromAnnexB.cpp	2010-10-13 06:27:39 UTC (rev 6701)
@@ -240,7 +240,7 @@
     {
         NALU_descriptor *d=desc+i;
         aprintf("%d/%d : Nalu :0x%x size=%d\n",i,nbNalu,d->nalu,d->size);
-        switch(d->nalu)
+        switch(d->nalu&0x1f)
         {
             case NAL_FILLER: break;
             case NAL_AU_DELIMITER: break; 



From mean at mail.berlios.de  Wed Oct 13 08:27:40 2010
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Wed, 13 Oct 2010 08:27:40 +0200
Subject: [Avidemux-svn-commit] r6702 -
	branches/avidemux_2.6_branch_mean/avidemux/common/ADM_muxerGate/src
Message-ID: <20101013062740.A7FE248114E@sheep.berlios.de>

Author: mean
Date: 2010-10-13 08:27:40 +0200 (Wed, 13 Oct 2010)
New Revision: 6702

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_muxerGate/src/ADM_videoCopyFromAnnexB.cpp
Log:
[annexb] Use short startcode for H264

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_muxerGate/src/ADM_videoCopyFromAnnexB.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_muxerGate/src/ADM_videoCopyFromAnnexB.cpp	2010-10-13 06:27:39 UTC (rev 6701)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_muxerGate/src/ADM_videoCopyFromAnnexB.cpp	2010-10-13 06:27:40 UTC (rev 6702)
@@ -20,12 +20,25 @@
 #include "ADM_editor/ADM_edit.hxx"
 #include "ADM_coreUtils.h"
 #include "ADM_h264_tag.h"
+
+
+
 extern ADM_Composer *video_body; // Fixme!
 
 extern bool ADM_findH264StartCode(uint8_t *start, uint8_t *end,uint8_t *outstartcode,uint32_t *offset);
+extern bool ADM_findMpegStartCode(uint8_t *start, uint8_t *end,uint8_t *outstartcode,uint32_t *offset);
 extern void mixDump(uint8_t *ptr, uint32_t len);
 
+#define SHORT_START_CODE
 
+#ifdef SHORT_START_CODE
+    #define SearchStartCode ADM_findMpegStartCode
+    #define START_CODE_LEN 4
+#else
+    #define SearchStartCode ADM_findH264StartCode
+    #define START_CODE_LEN 5
+#endif
+
 //#define ANNEX_B_DEBUG
 
 #if defined(ANNEX_B_DEBUG)
@@ -89,7 +102,7 @@
 uint32_t offset;
 uint8_t startCode,oldStartCode=0xff;
 int index=0;
-      while(true==ADM_findH264StartCode(head,end,&startCode,&offset))
+      while(true==SearchStartCode(head,end,&startCode,&offset))
       {
             if(true==first)
             {
@@ -100,7 +113,7 @@
             }
         ADM_assert(index<maxNalu);
         desc[index].start=head;
-        desc[index].size=offset-5;
+        desc[index].size=offset-START_CODE_LEN;
         desc[index].nalu=oldStartCode;
         index++;
         head+=offset;
@@ -262,8 +275,8 @@
     while(head<tail)
     {
         int32_t size=readBE32(head);
-            printf("[%02x] size=%d\n",head[5],size);
-        head+=size+4;
+            printf("[%02x] size=%d\n",head[START_CODE_LEN],size);
+        head+=size+START_CODE_LEN-1;
     }
 }
 /**



From mean at mail.berlios.de  Fri Oct 15 07:45:37 2010
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Fri, 15 Oct 2010 07:45:37 +0200
Subject: [Avidemux-svn-commit] r6703 - in
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6:
	. largeMedian
Message-ID: <20101015054537.49B1E480F32@sheep.berlios.de>

Author: mean
Date: 2010-10-15 07:45:37 +0200 (Fri, 15 Oct 2010)
New Revision: 6703

Added:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/largeMedian/
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/largeMedian/ADM_largeMedian.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/largeMedian/ADM_largeMedian.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/largeMedian/CMakeLists.txt
Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/CMakeLists.txt
Log:
[filter] LargeMedian

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/CMakeLists.txt	2010-10-13 06:27:40 UTC (rev 6702)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/CMakeLists.txt	2010-10-15 05:45:37 UTC (rev 6703)
@@ -5,6 +5,7 @@
 ADD_SUBDIRECTORY(dummy)
 ADD_SUBDIRECTORY(fastConvolution)
 ADD_SUBDIRECTORY(kernelDeint)
+ADD_SUBDIRECTORY(largeMedian)
 ADD_SUBDIRECTORY(lavDeint)
 ADD_SUBDIRECTORY(logo)
 ADD_SUBDIRECTORY(lumaOnly)

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/largeMedian/ADM_largeMedian.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/largeMedian/ADM_largeMedian.cpp	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/largeMedian/ADM_largeMedian.cpp	2010-10-15 05:45:37 UTC (rev 6703)
@@ -0,0 +1,288 @@
+/***************************************************************************
+                          ADM_vidLargeMedian.cpp  -  description
+                             -------------------
+    begin                : Wed Jan 1 2003
+    copyright            : (C) 2003 by mean
+    email                : fixounet at free.fr
+    
+    Using http://ndevilla.free.fr/median/median/node20.html
+    optimized median search
+    
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+
+#include "ADM_default.h"
+#include "ADM_coreVideoFilterInternal.h"
+#include "DIA_coreToolkit.h"
+#include "convolution.h"
+#include "convolution_desc.cpp"
+#include "DIA_factory.h"
+#include "ADM_largeMedian.h"
+// Add the hook to make it valid plugin
+DECLARE_VIDEO_FILTER(   largeMedian,   // Class
+                        1,0,0,              // Version
+                        ADM_UI_ALL,         // UI
+                        VF_NOISE,            // Category
+                        "largeMedian",            // internal name (must be uniq!)
+                        "Large Median (5x5).",            // Display name
+                        "Median filter on 5x5 matrix." // Description
+                    );
+
+
+/**
+    \fn ctor
+*/
+largeMedian::largeMedian(ADM_coreVideoFilter *previous,CONFcouple *couples)
+:  ADM_coreVideoFilter(previous,couples)
+{
+
+    if(!couples || !ADM_paramLoad(couples,convolution_param,&param))
+    {
+        param.chroma=1;
+        param.luma=1;
+	}
+    image=new ADMImageDefault(info.width,info.height);
+    myName="largeMedian";
+}
+
+/**
+    \fn dtor
+*/
+largeMedian::~largeMedian()
+{
+	if(image) delete image;
+    image=NULL;
+}
+/**
+    \fn configure
+*/
+bool largeMedian::configure(void)
+{
+  
+  diaElemToggle luma(&(param.luma),QT_TR_NOOP("_Process luma"),QT_TR_NOOP("Process luma plane"));
+  diaElemToggle chroma(&(param.chroma),QT_TR_NOOP("P_rocess chroma"));
+  
+  diaElem *elems[2]={&luma,&chroma};
+  
+  return diaFactoryRun(QT_TR_NOOP("Fast Convolution"),2,elems);
+}
+/**
+    \fn getConfiguration
+*/
+const char   *largeMedian::getConfiguration(void)
+{
+    return "";
+}
+/**
+    \fn getCoupledConf
+*/
+bool         largeMedian::getCoupledConf(CONFcouple **couples)
+{
+ return ADM_paramSave(couples, convolution_param,&param);
+}
+
+/**
+    \fn copyPlane
+*/
+static void copyPlane(ADMImage *s, ADMImage *d, ADM_PLANE plane)
+{
+        uint8_t *src=s->GetReadPtr(plane);
+        uint8_t *dst=d->GetWritePtr(plane);
+        uint32_t sPitch=s->GetPitch(plane);
+        uint32_t dPitch=d->GetPitch(plane);
+        uint32_t w=s->_width;  
+        uint32_t h=s->_height;
+        if(plane!=PLANAR_Y) 
+        {
+            w>>=1;
+            h>>=1;
+        }
+        BitBlit(dst,dPitch,src,sPitch,w,h);
+}
+/**
+    \fn processPlane
+*/
+bool largeMedian::processPlane(ADMImage *s,ADMImage *d,ADM_PLANE plane)
+{
+        uint8_t *src=s->GetReadPtr(plane);
+        uint8_t *dst=d->GetWritePtr(plane);
+        uint32_t sPitch=s->GetPitch(plane);
+        uint32_t dPitch=d->GetPitch(plane);
+        uint32_t w=info.width;  
+        uint32_t h=info.height;
+        if(plane!=PLANAR_Y) 
+        {
+            w>>=1;
+            h>>=1;
+        }
+	// 2xfirst and 2xlast line
+		memcpy(dst,src,w);
+        memcpy(dst+dPitch,src+sPitch,w);
+        memcpy(dst+(h-1)*dPitch,src+(h-1)*sPitch,w);
+        memcpy(dst+(h-2)*dPitch,src+(h-2)*sPitch,w);
+    // Other lines
+        uint8_t *o,*p1,*p2,*c,*n1,*n2;
+        o=dst+dPitch+dPitch;
+		p1=src;
+		p2=p1+sPitch;
+		c=p2+sPitch;
+        n1=c+sPitch;
+        n2=n1+sPitch;
+
+		// Luma
+		for(int32_t y=2;y<h-2;y++)
+		{
+			doLine(p1,p2,c,n1,n2,o,w);
+			p1=p2;
+            p2=c;
+            c=n1;
+            n1=n2;
+            n2+=sPitch;
+			o+=dPitch;
+		}
+        return true;
+}
+/**
+    \fn getNextFrame
+*/
+bool largeMedian::getNextFrame(uint32_t *fn,ADMImage *data)
+{
+//uint8_t *dst,*dstu,*dstv,*srcu,*srcv;
+uint8_t *x1,*x2,*x3,*x4,*x5,*o1;
+uint32_t stride,page;
+    ADM_assert(image);					
+    if(!previousFilter->getNextFrame(fn,image)) return 0;             
+	
+																
+ // Luma...
+	if(!param.luma)
+	{
+        copyPlane(image,data,PLANAR_Y);
+	}
+	else
+	{
+        processPlane(image,data,PLANAR_Y);
+	}
+    // chroma u & v
+	if(!param.chroma)
+	{
+        copyPlane(image,data,PLANAR_U);
+        copyPlane(image,data,PLANAR_V);
+	}
+	else
+	{
+        processPlane(image,data,PLANAR_U);
+        processPlane(image,data,PLANAR_V);
+	}
+	data->copyInfo(image);
+    return true;
+}
+         
+
+/**
+    \fn doLine
+*/
+uint8_t largeMedian::doLine(uint8_t  *pred2,uint8_t  *pred1,
+					uint8_t *cur,
+   					uint8_t *next1,uint8_t *next2,
+   					uint8_t *out,
+                       			uint32_t w)
+                                 
+{
+static uint8_t box[5][5];	
+static uint8_t box2[5][5];	
+
+uint32_t col;
+uint8_t temp;
+uint32_t inbox;
+	
+// prefill box
+	for(uint32_t x=0;x<4;x++)
+		{
+			box[0][x+1]=*(pred2+x);
+			box[1][x+1]=*(pred1+x);
+			box[2][x+1]=*(cur+x);
+			box[3][x+1]=*(next1+x);
+			box[4][x+1]=*(next2+x);			
+		}
+		col=0;
+		*out=*cur;
+		*(out+1)=*(cur+1);
+		*(out+w-1)=*(cur+w-1);		
+		*(out+w-2)=*(cur+w-2);
+		out+=2;
+		next1+=4;
+		next2+=4;
+		pred1+=4;
+		pred2+=4;
+		cur+=4;	
+	while(w>4)
+	{
+		// fill
+			box[0][col]=*pred2++;
+			box[1][col]=*pred1++;
+			box[2][col]=*cur++;
+			box[3][col]=*next1++;
+			box[4][col]=*next2++;
+			col++;
+			col%=5;
+			// copy & sort
+			memcpy(box2,box,5*5);
+			uint8_t *p=(uint8_t *)box2;	
+			inbox=0;	
+#define PIX_SORT(a,b) { if ((a)>(b)) PIX_SWAP((a),(b)); }
+#define PIX_SWAP(a,b) { temp=(a);(a)=(b);(b)=temp; }
+
+			
+    PIX_SORT(p[0], p[1]) ;   PIX_SORT(p[3], p[4]) ;   PIX_SORT(p[2], p[4]) ;
+    PIX_SORT(p[2], p[3]) ;   PIX_SORT(p[6], p[7]) ;   PIX_SORT(p[5], p[7]) ;
+    PIX_SORT(p[5], p[6]) ;   PIX_SORT(p[9], p[10]) ;  PIX_SORT(p[8], p[10]) ;
+    PIX_SORT(p[8], p[9]) ;   PIX_SORT(p[12], p[13]) ; PIX_SORT(p[11], p[13]) ;
+    PIX_SORT(p[11], p[12]) ; PIX_SORT(p[15], p[16]) ; PIX_SORT(p[14], p[16]) ;
+    PIX_SORT(p[14], p[15]) ; PIX_SORT(p[18], p[19]) ; PIX_SORT(p[17], p[19]) ;
+    PIX_SORT(p[17], p[18]) ; PIX_SORT(p[21], p[22]) ; PIX_SORT(p[20], p[22]) ;
+    PIX_SORT(p[20], p[21]) ; PIX_SORT(p[23], p[24]) ; PIX_SORT(p[2], p[5]) ;
+    PIX_SORT(p[3], p[6]) ;   PIX_SORT(p[0], p[6]) ;   PIX_SORT(p[0], p[3]) ;
+    PIX_SORT(p[4], p[7]) ;   PIX_SORT(p[1], p[7]) ;   PIX_SORT(p[1], p[4]) ;
+    PIX_SORT(p[11], p[14]) ; PIX_SORT(p[8], p[14]) ;  PIX_SORT(p[8], p[11]) ;
+    PIX_SORT(p[12], p[15]) ; PIX_SORT(p[9], p[15]) ;  PIX_SORT(p[9], p[12]) ;
+    PIX_SORT(p[13], p[16]) ; PIX_SORT(p[10], p[16]) ; PIX_SORT(p[10], p[13]) ;
+    PIX_SORT(p[20], p[23]) ; PIX_SORT(p[17], p[23]) ; PIX_SORT(p[17], p[20]) ;
+    PIX_SORT(p[21], p[24]) ; PIX_SORT(p[18], p[24]) ; PIX_SORT(p[18], p[21]) ;
+    PIX_SORT(p[19], p[22]) ; PIX_SORT(p[8], p[17]) ;  PIX_SORT(p[9], p[18]) ;
+    PIX_SORT(p[0], p[18]) ;  PIX_SORT(p[0], p[9]) ;   PIX_SORT(p[10], p[19]) ;
+    PIX_SORT(p[1], p[19]) ;  PIX_SORT(p[1], p[10]) ;  PIX_SORT(p[11], p[20]) ;
+    PIX_SORT(p[2], p[20]) ;  PIX_SORT(p[2], p[11]) ;  PIX_SORT(p[12], p[21]) ;
+    PIX_SORT(p[3], p[21]) ;  PIX_SORT(p[3], p[12]) ;  PIX_SORT(p[13], p[22]) ;
+    PIX_SORT(p[4], p[22]) ;  PIX_SORT(p[4], p[13]) ;  PIX_SORT(p[14], p[23]) ;
+    PIX_SORT(p[5], p[23]) ;  PIX_SORT(p[5], p[14]) ;  PIX_SORT(p[15], p[24]) ;
+    PIX_SORT(p[6], p[24]) ;  PIX_SORT(p[6], p[15]) ;  PIX_SORT(p[7], p[16]) ;
+    PIX_SORT(p[7], p[19]) ;  PIX_SORT(p[13], p[21]) ; PIX_SORT(p[15], p[23]) ;
+    PIX_SORT(p[7], p[13]) ;  PIX_SORT(p[7], p[15]) ;  PIX_SORT(p[1], p[9]) ;
+    PIX_SORT(p[3], p[11]) ;  PIX_SORT(p[5], p[17]) ;  PIX_SORT(p[11], p[17]) ;
+    PIX_SORT(p[9], p[17]) ;  PIX_SORT(p[4], p[10]) ;  PIX_SORT(p[6], p[12]) ;
+    PIX_SORT(p[7], p[14]) ;  PIX_SORT(p[4], p[6]) ;   PIX_SORT(p[4], p[7]) ;
+    PIX_SORT(p[12], p[14]) ; PIX_SORT(p[10], p[14]) ; PIX_SORT(p[6], p[7]) ;
+    PIX_SORT(p[10], p[12]) ; PIX_SORT(p[6], p[10]) ;  PIX_SORT(p[6], p[17]) ;
+    PIX_SORT(p[12], p[17]) ; PIX_SORT(p[7], p[17]) ;  PIX_SORT(p[7], p[10]) ;
+    PIX_SORT(p[12], p[18]) ; PIX_SORT(p[7], p[12]) ;  PIX_SORT(p[10], p[18]) ;
+    PIX_SORT(p[12], p[20]) ; PIX_SORT(p[10], p[20]) ; PIX_SORT(p[10], p[12]) ;
+			
+		  
+		  *out++=p[12];
+		  w--;
+	}	
+	
+	return 1;
+}
+// EOF
+

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/largeMedian/ADM_largeMedian.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/largeMedian/ADM_largeMedian.h	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/largeMedian/ADM_largeMedian.h	2010-10-15 05:45:37 UTC (rev 6703)
@@ -0,0 +1,45 @@
+/***************************************************************************
+                          ADM_vidLargeMedian.h  -  description
+                             -------------------
+    begin                : Wed Jan 1 2003
+    copyright            : (C) 2003 by mean
+    email                : fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#ifndef  LARGE_MEDIAN_H
+#define  LARGE_MEDIAN_H
+#include "convolution.h"
+
+/**
+    \class largeMedian
+*/
+class largeMedian : public  ADM_coreVideoFilter
+{
+protected:
+        convolution  param;
+virtual uint8_t 	 doLine(uint8_t  *pred2,uint8_t *pred1,	uint8_t *cur,uint8_t *next1,uint8_t *next2,
+   										uint8_t *out,uint32_t w)    ;
+                bool        processPlane(ADMImage *s,ADMImage *d,ADM_PLANE plane);
+                ADMImage    *image;
+public:
+                    largeMedian(ADM_coreVideoFilter *previous,CONFcouple *conf);
+                    ~largeMedian();
+
+        virtual const char   *getConfiguration(void);                   /// Return  current configuration as a human readable string
+        virtual bool         getNextFrame(uint32_t *fn,ADMImage *image);    /// Return the next image
+	 //  virtual FilterInfo  *getInfo(void);                             /// Return picture parameters after this filter
+        virtual bool         getCoupledConf(CONFcouple **couples) ;   /// Return the current filter configuration
+        virtual bool         configure(void) ;           /// Start graphical user interface
+};
+
+#endif
+// EOF
+

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/largeMedian/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/largeMedian/CMakeLists.txt	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/largeMedian/CMakeLists.txt	2010-10-15 05:45:37 UTC (rev 6703)
@@ -0,0 +1,9 @@
+INCLUDE(vf_plugin)
+
+
+SET(ADM_vf_largeMedian_SRCS ADM_largeMedian.cpp)
+
+ADD_VIDEO_FILTER(ADM_vf_largeMedian ${ADM_vf_largeMedian_SRCS})
+
+INIT_VIDEO_FILTER(ADM_vf_largeMedian)
+INSTALL_VIDEO_FILTER(ADM_vf_largeMedian)



From mean at mail.berlios.de  Fri Oct 15 07:45:39 2010
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Fri, 15 Oct 2010 07:45:39 +0200
Subject: [Avidemux-svn-commit] r6704 - in branches/avidemux_2.6_branch_mean:
	avidemux_core/ADM_coreImage/include avidemux_core/ADM_coreImage/src
	avidemux_plugins/ADM_videoFilters6/fastConvolution
	avidemux_plugins/ADM_videoFilters6/largeMedian
Message-ID: <20101015054539.64385480F32@sheep.berlios.de>

Author: mean
Date: 2010-10-15 07:45:39 +0200 (Fri, 15 Oct 2010)
New Revision: 6704

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImage/include/ADM_image.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImage/src/ADM_imageUtils.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/fastConvolution/ADM_vidFastConvolution.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/largeMedian/ADM_largeMedian.cpp
Log:
[Image] Move copyPlane to ADMImage

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImage/include/ADM_image.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImage/include/ADM_image.h	2010-10-15 05:45:37 UTC (rev 6703)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImage/include/ADM_image.h	2010-10-15 05:45:39 UTC (rev 6704)
@@ -126,8 +126,8 @@
         bool    saveAsBmp(const char *filename);
         bool    saveAsJpg(const char *filename);
         bool    printString(uint32_t x,uint32_t y, const char *strng);
-        
-static uint32_t lumaDiff(ADMImage *src1,ADMImage *src2,uint32_t noise);
+static  bool    copyPlane(ADMImage *s, ADMImage *d, ADM_PLANE plane);
+static  uint32_t lumaDiff(ADMImage *src1,ADMImage *src2,uint32_t noise);
 };
 
 /**

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImage/src/ADM_imageUtils.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImage/src/ADM_imageUtils.cpp	2010-10-15 05:45:37 UTC (rev 6703)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImage/src/ADM_imageUtils.cpp	2010-10-15 05:45:39 UTC (rev 6704)
@@ -395,4 +395,25 @@
 		    }
 		    return 1;
  }
+
+
+/**
+    \fn copyPlane
+*/
+bool ADMImage::copyPlane(ADMImage *s, ADMImage *d, ADM_PLANE plane)
+{
+        uint8_t *src=s->GetReadPtr(plane);
+        uint8_t *dst=d->GetWritePtr(plane);
+        uint32_t sPitch=s->GetPitch(plane);
+        uint32_t dPitch=d->GetPitch(plane);
+        uint32_t w=s->_width;  
+        uint32_t h=s->_height;
+        if(plane!=PLANAR_Y) 
+        {
+            w>>=1;
+            h>>=1;
+        }
+        BitBlit(dst,dPitch,src,sPitch,w,h);
+        return true;
+}
 //EOF

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/fastConvolution/ADM_vidFastConvolution.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/fastConvolution/ADM_vidFastConvolution.cpp	2010-10-15 05:45:37 UTC (rev 6703)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/fastConvolution/ADM_vidFastConvolution.cpp	2010-10-15 05:45:39 UTC (rev 6704)
@@ -49,24 +49,6 @@
     image=NULL;
 }
 /**
-    \fn copyPlane
-*/
-static void copyPlane(ADMImage *s, ADMImage *d, ADM_PLANE plane)
-{
-        uint8_t *src=s->GetReadPtr(plane);
-        uint8_t *dst=d->GetWritePtr(plane);
-        uint32_t sPitch=s->GetPitch(plane);
-        uint32_t dPitch=d->GetPitch(plane);
-        uint32_t w=s->_width;  
-        uint32_t h=s->_height;
-        if(plane!=PLANAR_Y) 
-        {
-            w>>=1;
-            h>>=1;
-        }
-        BitBlit(dst,dPitch,src,sPitch,w,h);
-}
-/**
     \fn processPlane
 */
 bool AVDMFastVideoConvolution::processPlane(ADMImage *s,ADMImage *d,ADM_PLANE plane)
@@ -118,7 +100,7 @@
     // Luma...
 	if(!param.luma)
 	{
-        copyPlane(image,data,PLANAR_Y);
+        ADMImage::copyPlane(image,data,PLANAR_Y);
 	}
 	else
 	{
@@ -127,8 +109,8 @@
     // chroma u & v
 	if(!param.chroma)
 	{
-        copyPlane(image,data,PLANAR_U);
-        copyPlane(image,data,PLANAR_V);
+        ADMImage::copyPlane(image,data,PLANAR_U);
+        ADMImage::copyPlane(image,data,PLANAR_V);
 	}
 	else
 	{

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/largeMedian/ADM_largeMedian.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/largeMedian/ADM_largeMedian.cpp	2010-10-15 05:45:37 UTC (rev 6703)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/largeMedian/ADM_largeMedian.cpp	2010-10-15 05:45:39 UTC (rev 6704)
@@ -91,24 +91,6 @@
 }
 
 /**
-    \fn copyPlane
-*/
-static void copyPlane(ADMImage *s, ADMImage *d, ADM_PLANE plane)
-{
-        uint8_t *src=s->GetReadPtr(plane);
-        uint8_t *dst=d->GetWritePtr(plane);
-        uint32_t sPitch=s->GetPitch(plane);
-        uint32_t dPitch=d->GetPitch(plane);
-        uint32_t w=s->_width;  
-        uint32_t h=s->_height;
-        if(plane!=PLANAR_Y) 
-        {
-            w>>=1;
-            h>>=1;
-        }
-        BitBlit(dst,dPitch,src,sPitch,w,h);
-}
-/**
     \fn processPlane
 */
 bool largeMedian::processPlane(ADMImage *s,ADMImage *d,ADM_PLANE plane)
@@ -166,7 +148,7 @@
  // Luma...
 	if(!param.luma)
 	{
-        copyPlane(image,data,PLANAR_Y);
+        ADMImage::copyPlane(image,data,PLANAR_Y);
 	}
 	else
 	{
@@ -175,8 +157,8 @@
     // chroma u & v
 	if(!param.chroma)
 	{
-        copyPlane(image,data,PLANAR_U);
-        copyPlane(image,data,PLANAR_V);
+        ADMImage::copyPlane(image,data,PLANAR_U);
+        ADMImage::copyPlane(image,data,PLANAR_V);
 	}
 	else
 	{



From mean at mail.berlios.de  Fri Oct 15 07:45:40 2010
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Fri, 15 Oct 2010 07:45:40 +0200
Subject: [Avidemux-svn-commit] r6705 -
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/largeMedian
Message-ID: <20101015054540.CB959480F32@sheep.berlios.de>

Author: mean
Date: 2010-10-15 07:45:40 +0200 (Fri, 15 Oct 2010)
New Revision: 6705

Added:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/largeMedian/convolution.conf
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/largeMedian/convolution.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/largeMedian/convolution_desc.cpp
Log:
[largeConvolution] add configuration files

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/largeMedian/convolution.conf
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/largeMedian/convolution.conf	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/largeMedian/convolution.conf	2010-10-15 05:45:40 UTC (rev 6705)
@@ -0,0 +1,2 @@
+uint32_t:luma; 
+uint32_t:chroma; 

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/largeMedian/convolution.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/largeMedian/convolution.h	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/largeMedian/convolution.h	2010-10-15 05:45:40 UTC (rev 6705)
@@ -0,0 +1,9 @@
+// Automatically generated, do not edit!
+#ifndef ADM_convolution_CONF_H
+#define ADM_convolution_CONF_H
+typedef struct {
+   uint32_t luma;
+   uint32_t chroma;
+}convolution;
+#endif //convolution
+//EOF

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/largeMedian/convolution_desc.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/largeMedian/convolution_desc.cpp	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/largeMedian/convolution_desc.cpp	2010-10-15 05:45:40 UTC (rev 6705)
@@ -0,0 +1,6 @@
+// Automatically generated, do not edit!
+const ADM_paramList convolution_param[]={
+ {"luma",offsetof( convolution,luma),"uint32_t",ADM_param_uint32_t},
+ {"chroma",offsetof( convolution,chroma),"uint32_t",ADM_param_uint32_t},
+{NULL,0,NULL}
+};



From mean at mail.berlios.de  Sun Oct 17 18:12:05 2010
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Sun, 17 Oct 2010 18:12:05 +0200
Subject: [Avidemux-svn-commit] r6706 -
	branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor
Message-ID: <20101017161205.9FBFF481067@sheep.berlios.de>

Author: mean
Date: 2010-10-17 18:12:05 +0200 (Sun, 17 Oct 2010)
New Revision: 6706

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADMedAVIAUD.cpp
Log:
[Composer/audio] Properly switch segment in audio copy mode

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADMedAVIAUD.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADMedAVIAUD.cpp	2010-10-15 05:45:40 UTC (rev 6705)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADMedAVIAUD.cpp	2010-10-17 16:12:05 UTC (rev 6706)
@@ -37,6 +37,7 @@
 #define MODULE_NAME MODULE_AUDIO_EDITOR
 #include "ADM_debug.h"
 
+#include "ADM_vidMisc.h"
 
 #define AUDIOSEG 	_segments[_audioseg]._reference
 #define SEG 		_segments[seg]._reference
@@ -68,7 +69,8 @@
             ADM_warning("Fail to seek audio to %"LLU"ms\n",seg->_refStartTimeUs/1000);
             return false;
           }
-        ADM_info("Switched ok to audio segment %"LU"\n",_audioSeg);
+        ADM_info("Switched ok to audio segment %"LU", with a ref time=%s\n",
+            _audioSeg,ADM_us2plain(seg->_refStartTimeUs));
         return true;
 
 }
@@ -242,18 +244,26 @@
 */
 uint8_t ADM_Composer::getPacket(uint8_t  *dest, uint32_t *len,uint32_t sizeMax, uint32_t *samples,uint64_t *odts)
 {
-        
+zgain:        
     _SEGMENT *seg=_segments.getSegment(_audioSeg);
     ADM_audioStreamTrack *trk=getTrack(seg->_reference);
     if(!trk) return 0;
    
     // Read a packet
-zgain:
+
     bool r=trk->stream->getPacket(dest,len,sizeMax,samples,odts);
-    if(r==false) return false;
-    //
+    if(r==false) 
+    {
+            ADM_warning("AudioGetPacket failed, audioSegment=%d\n",(int)_audioSeg);
+            // if it fails, we have to switch segment
+            if(false==switchToNextAudioSegment())
+            {
+                ADM_warning("..and this is the last segment\n");
+                return false;
+            }
+            goto zgain;
+    }
 
-
     // Rescale odts
     if(*odts!=ADM_NO_PTS)
     {
@@ -271,10 +281,9 @@
         {
             if(switchToNextAudioSegment()==false)
             {
-                
+                ADM_warning("Audio:Switching to next segment failed\n");
                 return false;
             }
-            seg=_segments.getSegment(_audioSeg);
             goto zgain;
         }
         *odts+=seg->_startTimeUs;
@@ -282,6 +291,7 @@
     {
         *odts=ADM_NO_PTS;
     }
+    //ADM_info("Time : %s\n",ADM_us2plain(*odts));
     //advanceDtsBySample(*samples);
     return true;
 }
@@ -300,6 +310,7 @@
         ADM_warning("Cannot convert %"LLU" to linear time\n",ustime/1000);
         return false;
       }
+    ADM_info("=> seg %d, rel time %02.2f secs\n",(int)seg,((float)segTime)/1000000.);
     _SEGMENT *s=_segments.getSegment(seg);
     ADM_audioStreamTrack *trk=getTrack(s->_reference);
     if(!trk)



From mean at mail.berlios.de  Sun Oct 17 18:12:07 2010
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Sun, 17 Oct 2010 18:12:07 +0200
Subject: [Avidemux-svn-commit] r6707 -
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Matroska
Message-ID: <20101017161207.548E8481067@sheep.berlios.de>

Author: mean
Date: 2010-10-17 18:12:07 +0200 (Sun, 17 Oct 2010)
New Revision: 6707

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Matroska/ADM_mkv.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Matroska/ADM_mkv.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Matroska/ADM_mkv_audio.cpp
Log:
[Mkv] Make sure PTS>=DTS when reconstucting them, especially at at the beginning

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Matroska/ADM_mkv.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Matroska/ADM_mkv.cpp	2010-10-17 16:12:05 UTC (rev 6706)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Matroska/ADM_mkv.cpp	2010-10-17 16:12:07 UTC (rev 6707)
@@ -123,6 +123,22 @@
             }
             vid->index[i].Dts=lastDts;
       }
+        // Check that we have PTS>=DTS also
+        uint64_t enforePtsGreaterThanDts=0;
+        for(int i=0;i<last;i++)
+        {
+                if(vid->index[i].Pts<vid->index[i].Dts)
+                {
+                    uint64_t delta=vid->index[i].Dts-vid->index[i].Pts;
+                    if(delta>enforePtsGreaterThanDts) enforePtsGreaterThanDts=delta;
+                }
+        }
+        if(enforePtsGreaterThanDts)
+        {
+                ADM_info("Have to delay by %"LU" ms so that PTS>DTS\n",enforePtsGreaterThanDts);
+                for(int i=0;i<_nbAudioTrack+1;i++)
+                delayTrack(i,&(_tracks[i]),enforePtsGreaterThanDts);
+        }
     }else
     {       // No bframe, DTS=PTS
       for(int i=0;i<last;i++)
@@ -166,12 +182,14 @@
     \brief delay audio and video by 2 * time increment if b frames present
                 else we may have PTS<DTS
 */
-bool mkvHeader::delayTrack(mkvTrak *track, uint64_t value)
+bool mkvHeader::delayTrack(int index,mkvTrak *track, uint64_t value)
 {
     int nb=track->index.size();
     for(int i=0;i<nb;i++)
     {
         if(track->index[i].Pts!=ADM_NO_PTS) track->index[i].Pts+=value;
+        if(index) // Must also delay DTS for audio as we use DTS not PTS
+            if(track->index[i].Dts!=ADM_NO_PTS) track->index[i].Dts+=value;
     }
     return true;
 }
@@ -250,15 +268,24 @@
 
     }
     ADM_info("First frame pts     %"LLD" us\n",track->index[0].Pts);
-    uint64_t adj;
-    if(maxDelta>track->index[0].Pts) // need to correct
+    uint64_t adj=0;
+    int limit=32;
+    if(limit>nb) limit=nb;
+    // Pts must be >= maxDelta for all frames, the first 32 will do
+    for(int i=0;i<limit;i++)
     {
-        
-        adj=maxDelta-track->index[0].Pts;
+        if(maxDelta>track->index[i].Pts) 
+        {
+            uint64_t newAdj=maxDelta-track->index[i].Pts;
+            if(newAdj>adj) adj=newAdj;
+        }
+    }
+    if(adj) // need to correct
+    {
         ADM_info("Delaying video by %"LLU" us\n",adj);
         ADM_info("[mkv] Delaying audio by %"LLU" us\n",adj);
         for(int i=0;i<_nbAudioTrack+1;i++)
-            delayTrack(&(_tracks[i]),adj);
+            delayTrack(i,&(_tracks[i]),adj);
     }
     *maxDeltaX=maxDelta;
     *minDeltaX=minDelta;

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Matroska/ADM_mkv.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Matroska/ADM_mkv.h	2010-10-17 16:12:05 UTC (rev 6706)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Matroska/ADM_mkv.h	2010-10-17 16:12:07 UTC (rev 6707)
@@ -159,7 +159,7 @@
 
     uint8_t                 rescaleTrack(mkvTrak *track,uint32_t durationMs);
 
-    bool                    delayTrack(mkvTrak *track, uint64_t value);
+    bool                    delayTrack(int index,mkvTrak *track, uint64_t value);
     
     bool                    ComputeDeltaAndCheckBFrames(uint32_t *minDeltaX, uint32_t *maxDeltaX, bool *bFramePresent);
 

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Matroska/ADM_mkv_audio.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Matroska/ADM_mkv_audio.cpp	2010-10-17 16:12:05 UTC (rev 6706)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_demuxers/Matroska/ADM_mkv_audio.cpp	2010-10-17 16:12:07 UTC (rev 6707)
@@ -19,6 +19,7 @@
 #include "ADM_a52info.h"
 #include "ADM_dcainfo.h"
 
+#include "ADM_vidMisc.h"
 #if 0
 #define vprintf printf
 #else
@@ -144,20 +145,24 @@
             {
                 clus=0;
             }else
-            for(int i=0;i<limit-1;i++)
             {
-              if(targetUs>=(*dex)[i].Dts && targetUs<(*dex)[i+1].Dts)
-              {
-                clus=i;
-                break;
-              }
+                for(int i=0;i<limit-1;i++)
+                {
+                  if(targetUs>=(*dex)[i].Dts && targetUs<(*dex)[i+1].Dts)
+                  {
+                    clus=i;
+                    break;
+                  }
+                }
             }
             if(clus==-1) clus=limit-1; // Hopefully in the last one
-
+            ADM_info("[MKVAUDIO] Asked for %s , go to block %d\n",ADM_us2plain(timeUs),clus);
+            ADM_info("[MKVAUDIO] This block starts at %s\n",ADM_us2plain((*dex)[clus].Dts));
             targetUs-=(*dex)[clus].Dts; // now the time is relative
+            ADM_info("[MKVAUDIO] Offset=%"LLU" us\n",targetUs);
             goToBlock(clus);
 
-            printf("[MKVAUDIO] Asked for %"LLU" us, go to block %d, which starts at %"LLU" ms\n",timeUs,clus,targetUs);
+            
             // Now seek more finely
             // will be off by one frame
 #if 0



From mean at mail.berlios.de  Tue Oct 19 08:26:37 2010
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Tue, 19 Oct 2010 08:26:37 +0200
Subject: [Avidemux-svn-commit] r6708 -
	branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_gui
Message-ID: <20101019062637.6FDD14802F1@sheep.berlios.de>

Author: mean
Date: 2010-10-19 08:26:36 +0200 (Tue, 19 Oct 2010)
New Revision: 6708

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_gui/T_preview.cpp
Log:
[Render] Try to make redraw works

Modified: branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_gui/T_preview.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_gui/T_preview.cpp	2010-10-17 16:12:07 UTC (rev 6707)
+++ branches/avidemux_2.6_branch_mean/avidemux/qt4/ADM_userInterfaces/ADM_gui/T_preview.cpp	2010-10-19 06:26:36 UTC (rev 6708)
@@ -67,7 +67,18 @@
     rgbDataBuffer=NULL;
     return true;
 }
-ADM_Qvideo::ADM_Qvideo(QWidget *z) : QWidget(z) {}
+ADM_Qvideo::ADM_Qvideo(QWidget *z) : QWidget(z) 
+{    
+setAttribute( Qt::WA_PaintOnScreen, true );
+// Put a transparent background
+//setAutoFillBackground(true);
+QPalette p =  palette();
+QColor color(Qt::black);
+color.setAlpha(0);
+p.setColor( QPalette::Window, color );
+setPalette( p );
+
+} //{setAutoFillBackground(false);}
 ADM_Qvideo::~ADM_Qvideo() {}
 
 void ADM_Qvideo::paintEvent(QPaintEvent *ev)
@@ -104,6 +115,10 @@
    hostFrame=host;
    videoWindow->resize(hostFrame->size());
    videoWindow->show();
+#if 0
+   host->setAutoFillBackground(false);
+   host->setEnabled(false);
+#endif   
    
 }
 //*************************



From mean at mail.berlios.de  Tue Oct 19 08:26:38 2010
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Tue, 19 Oct 2010 08:26:38 +0200
Subject: [Avidemux-svn-commit] r6709 -
	branches/avidemux_2.6_branch_mean/avidemux/common/ADM_render
Message-ID: <20101019062638.6FE8A4802F1@sheep.berlios.de>

Author: mean
Date: 2010-10-19 08:26:38 +0200 (Tue, 19 Oct 2010)
New Revision: 6709

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_render/GUI_xvRender.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_render/GUI_xvRender.h
Log:
[xvRender] Allow self refresh

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_render/GUI_xvRender.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_render/GUI_xvRender.cpp	2010-10-19 06:26:36 UTC (rev 6708)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_render/GUI_xvRender.cpp	2010-10-19 06:26:38 UTC (rev 6709)
@@ -44,6 +44,7 @@
 static uint8_t  GUI_XvDisplay(ADMImage *src, uint32_t w, uint32_t h,uint32_t destW,uint32_t destH);
 static uint8_t  GUI_XvRedraw( void );
 static uint8_t  getAtom(const char *string);
+static bool     xvDraw(uint32_t w,uint32_t h,uint32_t destW,uint32_t destH);
 //________________Wrapper around Xv_______________
 /**
     \fn XvRender
@@ -96,7 +97,7 @@
 {
     // since we dont know how to redraw without help, ask above
     ADM_info("XV:refresh\n");
-    renderCompleteRedrawRequest();
+    xvDraw(imageWidth,imageHeight,displayWidth,displayHeight);
     return true;
 }
 //________________Wrapper around Xv_______________
@@ -134,6 +135,26 @@
 
 }
 /**
+    \fn xvDraw
+*/
+bool xvDraw(uint32_t w,uint32_t h,uint32_t destW,uint32_t destH)
+{
+        if(!xvimage) return false;
+        XLockDisplay (xv_display);
+#if 1
+        XvShmPutImage(xv_display, xv_port, xv_win, xv_gc, xvimage, 0, 0, w, h,	// src
+			0, 0, destW, destH,	// dst
+			False);
+#else
+        XvPutImage(xv_display, xv_port, xv_win, xv_gc, xvimage, 0, 0, w, h,	// src
+			0, 0, w, h	// dst
+			);
+#endif
+          XUnlockDisplay (xv_display);
+          XSync(xv_display, False);
+        return true;
+}
+/**
     \fn GUI_XvList
 */
 uint8_t GUI_XvDisplay(ADMImage * src, uint32_t w, uint32_t h,uint32_t destW,uint32_t destH)
@@ -141,32 +162,14 @@
     
     if (xvimage)
       {
-
-	  // put image in shared segment
-
-	  // for YV12, 4 bits for Y 4 bits for u, 4 bits for v
-	  // total 1.5*
           XLockDisplay (xv_display);
           // Pack src into xvimage->data
             int plane=w*h;
           BitBlit((uint8_t *)xvimage->data, w,src->GetReadPtr(PLANAR_Y),src->GetPitch(PLANAR_Y),w,h);
           BitBlit((uint8_t *)xvimage->data+plane, w/2,src->GetReadPtr(PLANAR_U),src->GetPitch(PLANAR_U),w/2,h/2);
           BitBlit((uint8_t *)xvimage->data+(plane*5)/4, w/2,src->GetReadPtr(PLANAR_V),src->GetPitch(PLANAR_V),w/2,h/2);
-          
-        //printf("%u x %u => %u x %u\n",w,h,destW,destH);
-        // And display it !
-#if 1
-        XvShmPutImage(xv_display, xv_port, xv_win, xv_gc, xvimage, 0, 0, w, h,	// src
-			0, 0, destW, destH,	// dst
-			False);
-#else
-        XvPutImage(xv_display, xv_port, xv_win, xv_gc, xvimage, 0, 0, w, h,	// src
-			0, 0, w, h	// dst
-			);
-#endif
           XUnlockDisplay (xv_display);
-          XSync(xv_display, False);
-          
+          xvDraw(w,h,destW,destH);
       }
     return 1;
 }

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_render/GUI_xvRender.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_render/GUI_xvRender.h	2010-10-19 06:26:36 UTC (rev 6708)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_render/GUI_xvRender.h	2010-10-19 06:26:38 UTC (rev 6709)
@@ -32,7 +32,7 @@
               virtual   bool displayImage(ADMImage *pic);
               virtual   bool changeZoom(renderZoom newzoom);
               virtual   bool refresh(void);
-              virtual   bool usingUIRedraw(void) {return true;};
+              virtual   bool usingUIRedraw(void) {return false;}; // we can redraw by ourselves
 };
 #endif
 



From mean at mail.berlios.de  Tue Oct 19 08:26:39 2010
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Tue, 19 Oct 2010 08:26:39 +0200
Subject: [Avidemux-svn-commit] r6710 -
	branches/avidemux_2.6_branch_mean/avidemux/common/ADM_render
Message-ID: <20101019062639.822984802F1@sheep.berlios.de>

Author: mean
Date: 2010-10-19 08:26:39 +0200 (Tue, 19 Oct 2010)
New Revision: 6710

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_render/GUI_qtGlRender.cpp
Log:
[QtGl] Dont spawn GlWidget if GL support is incomplete, it would confuse other renderers later

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_render/GUI_qtGlRender.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_render/GUI_qtGlRender.cpp	2010-10-19 06:26:38 UTC (rev 6709)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_render/GUI_qtGlRender.cpp	2010-10-19 06:26:39 UTC (rev 6710)
@@ -272,11 +272,20 @@
 bool QtGlRender::init( GUI_WindowInfo *  window, uint32_t w, uint32_t h,renderZoom zoom)
 {
 	printf("[GL Render] Initialising renderer\n");
-    baseInit(w,h,zoom);
+    baseInit(w,h,zoom);
+    glWidget=NULL;
+	bool status= QGLFormat::hasOpenGL() && QGLShaderProgram::hasOpenGLShaderPrograms();
+    if(false==status)
+    {
+        ADM_warning("[GL Render] Init failed : No QFl support or no GLShareProgram\n");
+        ADM_warning("[GL Render] hasOpenGl : %d, hasOpenGLShaderProgram %d\n",(int)QGLFormat::hasOpenGL(),(int)QGLShaderProgram::hasOpenGLShaderPrograms());
+        return false;
+    }
+
 	glWidget = new QtGlAccelWidget((QWidget*)window->widget, w, h);
     glWidget->setDisplaySize(displayWidth,displayHeight);
 	glWidget->show();
-	return QGLFormat::hasOpenGL() && QGLShaderProgram::hasOpenGLShaderPrograms();
+    return true;
 }
 /**
     \fn displayImage



From mean at mail.berlios.de  Fri Oct 22 08:02:42 2010
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Fri, 22 Oct 2010 08:02:42 +0200
Subject: [Avidemux-svn-commit] r6711 -
	branches/avidemux_2.6_branch_mean/avidemux/common/ADM_muxerGate/src
Message-ID: <20101022060242.42C97480E57@sheep.berlios.de>

Author: mean
Date: 2010-10-22 08:02:42 +0200 (Fri, 22 Oct 2010)
New Revision: 6711

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_muxerGate/src/ADM_videoCopy.cpp
Log:
[muxer] Get real video duration in copy mode, not the duration from the complete source

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_muxerGate/src/ADM_videoCopy.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_muxerGate/src/ADM_videoCopy.cpp	2010-10-19 06:26:39 UTC (rev 6710)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_muxerGate/src/ADM_videoCopy.cpp	2010-10-22 06:02:42 UTC (rev 6711)
@@ -169,9 +169,10 @@
 */
 uint64_t        ADM_videoStreamCopy::getVideoDuration(void)
 {
-    return video_body->getVideoDuration();
+    //return video_body->getVideoDuration();
+    return endTimePts-startTimePts;
+}
 
-}
 /**
 
 */



From mean at mail.berlios.de  Fri Oct 22 08:02:43 2010
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Fri, 22 Oct 2010 08:02:43 +0200
Subject: [Avidemux-svn-commit] r6712 -
	branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/src
Message-ID: <20101022060243.A01DE480E57@sheep.berlios.de>

Author: mean
Date: 2010-10-22 08:02:43 +0200 (Fri, 22 Oct 2010)
New Revision: 6712

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/src/ADM_muxerUtils.cpp
Log:
[muxerBase] Add display of duration (video part)

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/src/ADM_muxerUtils.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/src/ADM_muxerUtils.cpp	2010-10-22 06:02:42 UTC (rev 6711)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreMuxer/src/ADM_muxerUtils.cpp	2010-10-22 06:02:43 UTC (rev 6712)
@@ -19,6 +19,7 @@
 #include "ADM_muxerInternal.h"
 #include "ADM_muxerUtils.h"
 #include "fourcc.h"
+#include "ADM_vidMisc.h"
 extern const char *getStrFromAudioCodec( uint32_t codec);
 /**
     \fn rescaleFps
@@ -78,7 +79,7 @@
         f*=1000000;
         videoIncrement=(uint64_t)f;  // Video increment in AVI-Tick
         videoDuration=vStream->getVideoDuration();
-
+        ADM_info("Muxer, creating UI, video duration is %s\n",ADM_us2plain(videoDuration));
         encoding=createEncoding(videoDuration);
         // Set video stream etc...
         encoding->setVideoCodec(fourCC::tostring(vStream->getFCC()));



From mean at mail.berlios.de  Sat Oct 23 14:59:09 2010
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Sat, 23 Oct 2010 14:59:09 +0200
Subject: [Avidemux-svn-commit] r6713 - tags
Message-ID: <20101023125910.0C9474801E6@sheep.berlios.de>

Author: mean
Date: 2010-10-23 14:59:09 +0200 (Sat, 23 Oct 2010)
New Revision: 6713

Added:
   tags/avidemux_2.5.4/
Log:
Tag 2.5.4




From mean at mail.berlios.de  Sat Oct 23 18:12:07 2010
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Sat, 23 Oct 2010 18:12:07 +0200
Subject: [Avidemux-svn-commit] r6714 - tags/avidemux_2.5.4
Message-ID: <20101023161208.06D0B4801E6@sheep.berlios.de>

Author: mean
Date: 2010-10-23 18:12:07 +0200 (Sat, 23 Oct 2010)
New Revision: 6714

Modified:
   tags/avidemux_2.5.4/CMakeLists.txt
Log:
[2.5.4] Set version

Modified: tags/avidemux_2.5.4/CMakeLists.txt
===================================================================
--- tags/avidemux_2.5.4/CMakeLists.txt	2010-10-23 12:59:09 UTC (rev 6713)
+++ tags/avidemux_2.5.4/CMakeLists.txt	2010-10-23 16:12:07 UTC (rev 6714)
@@ -97,7 +97,7 @@
 ########################################
 # Standard Avidemux defines
 ########################################
-SET(VERSION 2.5.3)
+SET(VERSION 2.5.4)
 
 # Define internal flags for GTK+ and Qt4 builds.  These are turned off
 # if a showstopper is found.  CLI is automatically assumed as possible
@@ -115,20 +115,20 @@
 ########################################
 # Subversion
 ########################################
-OPTION(SVN "" ON)
+#OPTION(SVN "" ON)
 SET(ADM_SUBVERSION 0)
 
-IF (SVN)
-	MESSAGE(STATUS "Checking for SCM Revision")
-	MESSAGE(STATUS "*************************")
+#IF (SVN)
+	#MESSAGE(STATUS "Checking for SCM Revision")
+	#MESSAGE(STATUS "*************************")
 
-	SET(Subversion_FIND_REQUIRED OFF)
-	include(admGetRevision)
-	admGetRevision(${PROJECT_SOURCE_DIR} ADM_SUBVERSION)
-	MESSAGE(STATUS "  revision: ${ADM_SUBVERSION}")
+	#SET(Subversion_FIND_REQUIRED OFF)
+	#include(admGetRevision)
+	#admGetRevision(${PROJECT_SOURCE_DIR} ADM_SUBVERSION)
+	#MESSAGE(STATUS "  revision: ${ADM_SUBVERSION}")
 
-	MESSAGE("")
-ENDIF (SVN)
+#	MESSAGE("")
+#ENDIF (SVN)
 
 ########################################
 # Check for libraries



From mean at mail.berlios.de  Tue Oct 26 20:07:59 2010
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Tue, 26 Oct 2010 20:07:59 +0200
Subject: [Avidemux-svn-commit] r6715 -
	branches/avidemux_2.5_branch_gruntster/cmake
Message-ID: <20101026180759.591FE480E47@sheep.berlios.de>

Author: mean
Date: 2010-10-26 20:07:58 +0200 (Tue, 26 Oct 2010)
New Revision: 6715

Modified:
   branches/avidemux_2.5_branch_gruntster/cmake/config.h.cmake
Log:
[audio] Fix audio handling, we always have audio, at worst it is dummy

Modified: branches/avidemux_2.5_branch_gruntster/cmake/config.h.cmake
===================================================================
--- branches/avidemux_2.5_branch_gruntster/cmake/config.h.cmake	2010-10-23 16:12:07 UTC (rev 6714)
+++ branches/avidemux_2.5_branch_gruntster/cmake/config.h.cmake	2010-10-26 18:07:58 UTC (rev 6715)
@@ -76,9 +76,7 @@
 /* use Nvwa memory leak detector */
 #cmakedefine FIND_LEAKS
 
-#if defined(OSS_SUPPORT) || defined (USE_ARTS) || defined(USE_SDL) || defined(__APPLE__) || defined(__WIN32) || defined(ALSA_SUPPORT)
 #define HAVE_AUDIO
-#endif
 
 #define HAVE_ENCODER
 



From mean at mail.berlios.de  Tue Oct 26 21:08:26 2010
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Tue, 26 Oct 2010 21:08:26 +0200
Subject: [Avidemux-svn-commit] r6716 -
	branches/avidemux_2.5_branch_gruntster/avidemux/ADM_UIs/ADM_GTK/src
Message-ID: <20101026190826.985B5480E64@sheep.berlios.de>

Author: mean
Date: 2010-10-26 21:08:26 +0200 (Tue, 26 Oct 2010)
New Revision: 6716

Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_UIs/ADM_GTK/src/FAC_menu.cpp
Log:
[Gtk] dont crash if default value is out of bound

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_UIs/ADM_GTK/src/FAC_menu.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_UIs/ADM_GTK/src/FAC_menu.cpp	2010-10-26 18:07:58 UTC (rev 6715)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_UIs/ADM_GTK/src/FAC_menu.cpp	2010-10-26 19:08:26 UTC (rev 6716)
@@ -183,7 +183,7 @@
 {
   GtkWidget *widget=(GtkWidget *)myWidget;
   int rank = gtk_combo_box_get_active(GTK_COMBO_BOX(widget));
-  
+  if(rank==-1) rank=0; 
   if (!nbMenu)
 	  return;
 
@@ -226,6 +226,7 @@
   
   
   rank=gtk_combo_box_get_active(GTK_COMBO_BOX(widget));
+  if(-1==rank) rank=0;
   ADM_assert(rank<this->nbMenu);
   val=this->menu[rank]->val;
   /* Now search through the linked list to see if something happens ...*/



From mean at mail.berlios.de  Thu Oct 28 07:54:49 2010
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Thu, 28 Oct 2010 07:54:49 +0200
Subject: [Avidemux-svn-commit] r6717 - in
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6:
	. colorYUV
Message-ID: <20101028055449.D5734480FA4@sheep.berlios.de>

Author: mean
Date: 2010-10-28 07:54:49 +0200 (Thu, 28 Oct 2010)
New Revision: 6717

Added:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/colorYUV/
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/colorYUV/ADM_vidColorYuv.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/colorYUV/ADM_vidColorYuv.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/colorYUV/ADM_vidColorYuv_param.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/colorYUV/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/colorYUV/avsColor.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/colorYUV/colorYuv.conf
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/colorYUV/colorYuv.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/colorYUV/colorYuv_desc.cpp
Log:
[VideoFilter] Import avsFilter

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/colorYUV/ADM_vidColorYuv.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/colorYUV/ADM_vidColorYuv.cpp	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/colorYUV/ADM_vidColorYuv.cpp	2010-10-28 05:54:49 UTC (rev 6717)
@@ -0,0 +1,134 @@
+
+/***************************************************************************
+    Port of ColorYuv from avisynth to avidemux by mean
+ ***************************************************************************/
+ // Avisynth v2.5.  Copyright 2002 Ben Rudiak-Gould et al.
+// http://www.avisynth.org
+
+// This program is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation; either version 2 of the License, or
+// (at your option) any later version.
+//
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA, or visit
+// http://www.gnu.org/copyleft/gpl.html .
+//
+// Linking Avisynth statically or dynamically with other modules is making a
+// combined work based on Avisynth.  Thus, the terms and conditions of the GNU
+// General Public License cover the whole combination.
+//
+// As a special exception, the copyright holders of Avisynth give you
+// permission to link Avisynth with independent modules that communicate with
+// Avisynth solely through the interfaces defined in avisynth.h, regardless of the license
+// terms of these independent modules, and to copy and distribute the
+// resulting combined work under terms of your choice, provided that
+// every copy of the combined work is accompanied by a complete copy of
+// the source code of Avisynth (the version of Avisynth used to produce the
+// combined work), being distributed under the terms of the GNU General
+// Public License plus this exception.  An independent module is a module
+// which is not derived from or based on Avisynth, such as 3rd-party filters,
+// import and export plugins, or graphical user interfaces.
+
+ /***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include <math.h>
+#include "ADM_default.h"
+#include "ADM_coreVideoFilterInternal.h"
+#include "DIA_coreToolkit.h"
+#include "ADM_vidColorYuv.h"
+#include "DIA_factory.h"
+#include "colorYuv_desc.cpp"
+
+
+// Add the hook to make it valid plugin
+DECLARE_VIDEO_FILTER(   vidColorYuv,   // Class
+                        1,0,0,              // Version
+                        ADM_UI_ALL,         // UI
+                        VF_COLORS,            // Category
+                        "colorYuv",            // internal name (must be uniq!)
+                        "Avisynth color filter.",            // Display name
+                        "Color management filter." // Description
+                    );
+
+/**
+    \fn configure
+*/
+bool         vidColorYuv::configure(void)
+{
+    MakeGammaLUT();
+    return true;
+}
+/**
+    \fn getConfiguration
+*/
+const char   *vidColorYuv::getConfiguration(void)
+{
+      const char *foobar="colorYuv";
+      return foobar;
+}
+/**
+    \fn ctor
+*/
+vidColorYuv::vidColorYuv( ADM_coreVideoFilter *in,CONFcouple *setup) : ADM_coreVideoFilter(in,setup)
+{	
+	 if(!setup || !ADM_paramLoad(setup,colorYuv_param,&param))
+    {
+        // Default value
+        #define MKP(x,y) param.x=y;
+            MKP(y_contrast,0);
+            MKP(y_bright,0);
+            MKP(y_gamma,0);
+            MKP(y_gain,0);
+
+            MKP(u_contrast,0);
+            MKP(u_bright,0);
+            MKP(u_gamma,0);
+            MKP(u_gain,0);
+
+            MKP(v_contrast,0);
+            MKP(v_bright,0);
+            MKP(v_gamma,0);
+            MKP(v_gain,0);
+            
+            MKP(matrix,0);
+            MKP(levels,0);
+            MKP(opt,0); 
+       
+            MKP(colorbars,0);
+            MKP(analyze,1);
+            MKP(autowhite,1); 
+            MKP(autogain,0); 
+    }  	 
+    MakeGammaLUT(); 	
+}
+/**
+    \fn getCoupledConf
+*/
+bool         vidColorYuv::getCoupledConf(CONFcouple **couples)
+{
+    return ADM_paramSave(couples, colorYuv_param,&param);
+}
+
+
+/**
+    \fn dtor
+*/
+vidColorYuv::~vidColorYuv()
+{
+}
+
+
+// EOF

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/colorYUV/ADM_vidColorYuv.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/colorYUV/ADM_vidColorYuv.h	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/colorYUV/ADM_vidColorYuv.h	2010-10-28 05:54:49 UTC (rev 6717)
@@ -0,0 +1,43 @@
+/***************************************************************************
+                          Port of avisynth ColorYuv Filter
+    copyright            : (C) 2006 by mean
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#ifndef ADM_VID_COLOR_YUV_H
+#define ADM_VID_COLOR_YUV_H
+
+#include "colorYuv.h"
+/**
+    \class vidColorYuv
+*/
+class vidColorYuv : public  ADM_coreVideoFilter
+{
+protected:
+        uint8_t       LUT_Y[256],LUT_U[256],LUT_V[256];
+        int           y_thresh1, y_thresh2, u_thresh1, u_thresh2, v_thresh1, v_thresh2;
+
+protected:
+        colorYuv    param;
+        void        MakeGammaLUT(void);
+public:
+        vidColorYuv(ADM_coreVideoFilter *previous,CONFcouple *conf);
+        ~vidColorYuv();
+
+        virtual const char   *getConfiguration(void);                   /// Return  current configuration as a human readable string
+        virtual bool         getNextFrame(uint32_t *fn,ADMImage *image);    /// Return the next image
+	 //  virtual FilterInfo  *getInfo(void);                             /// Return picture parameters after this filter
+        virtual bool         getCoupledConf(CONFcouple **couples) ;   /// Return the current filter configuration
+        virtual bool         configure(void) ;           /// Start graphical user interface
+};
+
+
+
+#endif

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/colorYUV/ADM_vidColorYuv_param.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/colorYUV/ADM_vidColorYuv_param.h	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/colorYUV/ADM_vidColorYuv_param.h	2010-10-28 05:54:49 UTC (rev 6717)
@@ -0,0 +1,36 @@
+/***************************************************************************
+                          Port of avisynth ColorYuv Filter
+    copyright            : (C) 2006 by mean
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#ifndef ADM_VID_COLOR_YUV_PARAM_H
+#define ADM_VID_COLOR_YUV_PARAM_H
+typedef struct COLOR_YUV_PARAM
+{
+    double y_contrast, y_bright, y_gamma, y_gain;
+    double u_contrast, u_bright, u_gamma, u_gain;
+    double v_contrast, v_bright, v_gamma, v_gain;
+    int32_t matrix, levels, opt;
+    uint32_t colorbars, analyze, autowhite, autogain;
+
+}COLOR_YUV_PARAM;
+
+/*
+matrix : 0 : none   1: rec.709
+Level :  0 : none   1:"TV->PC", 2:"PC->TV", 3:"PC->TV.Y" 
+Opt :    0 : none   1: Coring
+
+
+
+*/
+
+#endif

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/colorYUV/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/colorYUV/CMakeLists.txt	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/colorYUV/CMakeLists.txt	2010-10-28 05:54:49 UTC (rev 6717)
@@ -0,0 +1,8 @@
+INCLUDE(vf_plugin)
+
+SET(ADM_vf_colorYuv_SRCS ADM_vidColorYuv.cpp avsColor.cpp)
+
+ADD_VIDEO_FILTER(ADM_vf_colorYuv ${ADM_vf_colorYuv_SRCS})
+
+INIT_VIDEO_FILTER(ADM_vf_colorYuv)
+INSTALL_VIDEO_FILTER(ADM_vf_colorYuv)

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/colorYUV/avsColor.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/colorYUV/avsColor.cpp	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/colorYUV/avsColor.cpp	2010-10-28 05:54:49 UTC (rev 6717)
@@ -0,0 +1,732 @@
+// Avisynth v2.5.  Copyright 2002 Ben Rudiak-Gould et al.
+// http://www.avisynth.org
+
+// This program is free software; you can redistribute it and/or modify
+// it under the terms of the GNU General Public License as published by
+// the Free Software Foundation; either version 2 of the License, or
+// (at your option) any later version.
+//
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA, or visit
+// http://www.gnu.org/copyleft/gpl.html .
+//
+// Linking Avisynth statically or dynamically with other modules is making a
+// combined work based on Avisynth.  Thus, the terms and conditions of the GNU
+// General Public License cover the whole combination.
+//
+// As a special exception, the copyright holders of Avisynth give you
+// permission to link Avisynth with independent modules that communicate with
+// Avisynth solely through the interfaces defined in avisynth.h, regardless of the license
+// terms of these independent modules, and to copy and distribute the
+// resulting combined work under terms of your choice, provided that
+// every copy of the combined work is accompanied by a complete copy of
+// the source code of Avisynth (the version of Avisynth used to produce the
+// combined work), being distributed under the terms of the GNU General
+// Public License plus this exception.  An independent module is a module
+// which is not derived from or based on Avisynth, such as 3rd-party filters,
+// import and export plugins, or graphical user interfaces.
+
+#include <math.h>
+#include "ADM_default.h"
+#include "ADM_coreVideoFilterInternal.h"
+#include "DIA_coreToolkit.h"
+#include "ADM_vidColorYuv.h"
+
+#define BYTE uint8_t
+#ifndef x_max
+#define x_max(x,y) ((x)>(y) ?(x):(y))
+#endif
+#ifndef x_min
+#define x_min(x,y) ((x)<(y) ?(x):(y))
+#endif
+
+
+/**
+    \fn getNextFrame
+*/
+bool         vidColorYuv::getNextFrame(uint32_t *fn,ADMImage *image)
+{
+//x	PVideoFrame src;
+//x	unsigned long *srcp;
+    uint8_t *srcp;
+	int pitch, w, h;
+	int i,j,wby4;
+	int modulo;
+
+#ifdef _DEBUG
+	COUNT y0,u0,v0;
+	COUNT y,u,v;
+	COUNT r,g,b;
+	COUNT r0,g0,b0;
+	PIXELDATA	pixel0;
+	int   total,totalby2;
+#endif
+
+#if 0
+  if (colorbars) {
+    PVideoFrame dst= env->NewVideoFrame(vi);
+    int* pdst=(int*)dst->GetWritePtr(PLANAR_Y);
+    int Y=16+abs(219-((frame+219)%438));
+    Y|=(Y<<8)|(Y<<16)|(Y<<24);
+    for (int i = 0;i<224*224;i++)
+      pdst[i] = Y;
+    unsigned char* pdstb = dst->GetWritePtr(PLANAR_U);
+    for (unsigned int y=0;y<224;y++) {
+      for (unsigned int x=0;x<224;x++) {
+        pdstb[x] = 16+x;
+      }
+      pdstb += dst->GetPitch(PLANAR_U);
+    }
+
+    pdstb = dst->GetWritePtr(PLANAR_V);
+    for (y=0;y<224;y++) {
+      for (unsigned int x=0;x<224;x++) {
+        pdstb[x] = 16+y;
+      }
+      pdstb += dst->GetPitch(PLANAR_U);
+    }
+    return dst;
+  }
+#endif
+    if(false==previousFilter->getNextFrame(fn,image))
+    {
+        return false;
+    }
+    ADMImage *src=image;
+//x	src = child->GetFrame(frame, env);
+//x	env->MakeWritable(&src);
+
+//x	srcp = (unsigned long *) src->GetWritePtr();
+//x	pitch = src->GetPitch();
+    srcp=src->GetWritePtr(PLANAR_Y);
+    pitch=src->GetPitch(PLANAR_Y);
+
+	w = info.width;  //x src->GetRowSize();
+	h = info.height; //x src->GetHeight();
+	wby4 = w / 4;
+	modulo = pitch - w;
+//	dst = env->NewVideoFrame(vi);
+//	dstp = (unsigned long *) dst->GetWritePtr();
+//	dpitch = dst->GetPitch();
+//	dmodulo = dpitch - dst->GetRowSize();
+  if (param.analyze||param.autowhite||param.autogain) {
+    unsigned int accum_Y[256],accum_U[256],accum_V[256];
+    for (int i=0;i<256;i++) {
+      accum_Y[i]=0;
+      accum_U[i]=0;
+      accum_V[i]=0;
+    }
+    int uvdiv=1;  //UV divider (ratio between Y and UV pixels)
+    if (1) { //x vi.IsPlanar()) {
+      uvdiv=4;
+	    BYTE* srcp2 = (BYTE*) src->GetReadPtr(PLANAR_Y);
+      for (int y=0;y<h;y++) {
+        for (int x=0;x<w;x++) {
+          accum_Y[srcp2[x]]++;
+        }
+        srcp2+=pitch;
+      }
+      pitch = src->GetPitch(PLANAR_U);
+	    srcp2 = (BYTE*) src->GetReadPtr(PLANAR_U);
+      for (int y=0;y<h/2;y++) {
+        for (int x=0;x<w/2;x++) {
+          accum_U[srcp2[x]]++;
+        }
+        srcp2+=pitch;
+      }
+	    srcp2 = (BYTE*) src->GetReadPtr(PLANAR_V);
+      for (int y=0;y<h/2;y++) {
+        for (int x=0;x<w/2;x++) {
+          accum_V[srcp2[x]]++;
+        }
+        srcp2+=pitch;
+      }
+      pitch = src->GetPitch(PLANAR_Y);
+    } 
+#if 0 
+    else {  // YUY2
+      uvdiv=2;
+      for (int y=0;y<h;y++) {
+        for (int x=0;x<wby4;x++) {
+          unsigned long p=srcp[x];
+          accum_Y[p&0xff]++;
+          accum_Y[(p>>16)&0xff]++;
+          accum_U[(p>>8)&0xff]++;
+          accum_V[(p>>24)&0xff]++;
+        }
+        srcp+=pitch/4;
+      }
+      srcp=(unsigned long *)src->GetReadPtr();
+    }
+#endif
+    int pixels = info.width*info.height;
+    float avg_u=0, avg_v=0, avg_y=0;
+    int x_min_u=0, x_min_v=0, x_min_y=0;
+    int x_max_u=0, x_max_v=0, x_max_y=0;
+    bool hit_y=false,hit_u=false,hit_v=false;
+    int Ax_min_u=0, Ax_min_v=0, Ax_min_y=0;
+    int Ax_max_u=0, Ax_max_v=0, Ax_max_y=0;
+    bool Ahit_x_miny=false,Ahit_x_minu=false,Ahit_x_minv=false;
+    bool Ahit_x_maxy=false,Ahit_x_maxu=false,Ahit_x_maxv=false;
+    int At_y2=(pixels/256); // When 1/256th of all pixels have been reached, trigger "Loose x_min/x_max"
+    int At_uv2=(pixels/1024); 
+   
+    for (int i=0;i<256;i++) {
+      avg_y+=(float)accum_Y[i]*(float)i;
+      avg_u+=(float)accum_U[i]*(float)i;
+      avg_v+=(float)accum_V[i]*(float)i;
+      if (accum_Y[i]!=0) {x_max_y=i;hit_y=true;} else {if (!hit_y) x_min_y=i+1;} 
+      if (accum_U[i]!=0) {x_max_u=i;hit_u=true;} else {if (!hit_u) x_min_u=i+1;} 
+      if (accum_V[i]!=0) {x_max_v=i;hit_v=true;} else {if (!hit_v) x_min_v=i+1;} 
+
+      if (!Ahit_x_miny) {Ax_min_y+=accum_Y[i]; if (Ax_min_y>At_y2){Ahit_x_miny=true; Ax_min_y=i;} }
+      if (!Ahit_x_minu) {Ax_min_u+=accum_U[i]; if (Ax_min_u>At_uv2){Ahit_x_minu=true; Ax_min_u=i;} }
+      if (!Ahit_x_minv) {Ax_min_v+=accum_V[i]; if (Ax_min_v>At_uv2){Ahit_x_minv=true; Ax_min_v=i;} }
+
+      if (!Ahit_x_maxy) {Ax_max_y+=accum_Y[255-i]; if (Ax_max_y>At_y2){Ahit_x_maxy=true; Ax_max_y=255-i;} }
+      if (!Ahit_x_maxu) {Ax_max_u+=accum_U[255-i]; if (Ax_max_u>At_uv2){Ahit_x_maxu=true; Ax_max_u=255-i;} }
+      if (!Ahit_x_maxv) {Ax_max_v+=accum_V[255-i]; if (Ax_max_v>At_uv2){Ahit_x_maxv=true; Ax_max_v=255-i;} }
+    }
+
+    float Favg_y=avg_y/(float)pixels;
+    float Favg_u=(avg_u*(float)uvdiv)/(float)pixels;
+    float Favg_v=(avg_v*(float)uvdiv)/(float)pixels;
+    if (param.analyze) {
+#if 0
+      char text[400];
+      sprintf(text,
+      "        Frame: %-8u ( Luma Y / ChromaU / ChromaV )\n"
+      "      Average:      ( %7.2f / %7.2f / %7.2f )\n"
+      "      x_minimum:      (   %3d   /   %3d   /   %3d    )\n"
+      "      x_maximum:      (   %3d   /   %3d   /   %3d    )\n"
+      "Loose x_minimum:      (   %3d   /   %3d   /   %3d    )\n"
+      "Loose x_maximum:      (   %3d   /   %3d   /   %3d    )\n"
+      ,
+      frame,
+      Favg_y,Favg_u,Favg_v,
+      x_min_y,x_min_u,x_min_v,
+      x_max_y,x_max_u,x_max_v,
+      Ax_min_y,Ax_min_u,Ax_min_v,
+      Ax_max_y,Ax_max_u,Ax_max_v
+      );
+
+      ApplyMessage(&src, vi, text, vi.width/4, 0xa0a0a0,0,0 , env );
+      if (!(param.autowhite||param.autogain)) {
+        return true; //x src;
+      }
+#endif
+    }
+    if (param.autowhite) {
+      param.u_bright=127-(int)Favg_u;
+      param.v_bright=127-(int)Favg_v;
+    }
+    if (param.autogain) {
+      Ax_max_y=x_min(Ax_max_y,236);
+      Ax_min_y=x_max(Ax_min_y,16);  // Never scale above luma range!
+      if (Ax_min_y!=Ax_max_y) {
+        int y_range = Ax_max_y-Ax_min_y;
+        double scale = (220.0 / y_range);
+        param.y_gain = (int) (256.0 * scale)-256;
+        param.y_bright = -(int)(scale * (double)(Ax_min_y)-16);
+      }
+    }
+	  MakeGammaLUT();
+  }
+
+#ifdef _DEBUG
+	total = wby4 * h;
+	totalby2 = total / 2;
+
+	y.x_min  = u.x_min  = v.x_min  = 255;
+	y.x_max  = u.x_max  = v.x_max  = 0;
+	y.ave  = u.ave  = v.ave  = 0;
+	y.over  = u.over  = v.over  = 0;
+	y.under = u.under = v.under = 0;
+
+	y0.x_min = u0.x_min = v0.x_min = 255;
+	y0.x_max = u0.x_max = v0.x_max = 0;
+	y0.ave = u0.ave = v0.ave = 0;
+	y0.over  = u0.over  = v0.over  = 0;
+	y0.under = u0.under = v0.under = 0;
+
+	r.x_min   = g.x_min   = b.x_min   = 255;
+	r.x_max   = g.x_max   = b.x_max   = 0;
+	r.ave   = g.ave   = b.ave   = 0;
+	r.over  = g.over  = b.over  = 0;
+	r.under = g.under = b.under = 0;
+
+	r0.x_min   = g0.x_min   = b0.x_min   = 255;
+	r0.x_max   = g0.x_max   = b0.x_max   = 0;
+	r0.ave   = g0.ave   = b0.ave   = 0;
+	r0.over  = g0.over  = b0.over  = 0;
+	r0.under = g0.under = b0.under = 0;
+#endif
+#if 0 //x
+  if (vi.IsYUY2()) {
+	  for (j = 0; j < h; j++)
+	  {
+		  for (i=0; i<wby4; i++)
+		  {
+			  pixel.data = *srcp;
+
+#ifdef _DEBUG
+			pixel0.data = pixel.data;
+			CheckYUV(NULL, &pixel, &y0, &u0, &v0, 0);
+			
+			YUV2RGB(pixel.yuv.y0, pixel.yuv.u, pixel.yuv.v, &r0.d, &g0.d, &b0.d, matrix);
+			CheckRGB(&r0, &g0, &b0);
+			YUV2RGB(pixel.yuv.y1, pixel.yuv.u, pixel.yuv.v, &r0.d, &g0.d, &b0.d, matrix);
+			CheckRGB(&r0, &g0, &b0);
+#endif 
+
+			  pixel.yuv.y0 = LUT_Y[pixel.yuv.y0];
+			  pixel.yuv.u  = LUT_U[pixel.yuv.u ];
+			  pixel.yuv.y1 = LUT_Y[pixel.yuv.y1];
+			  pixel.yuv.v  = LUT_V[pixel.yuv.v ];
+			  *srcp++ = pixel.data;
+
+#ifdef _DEBUG
+			CheckYUV(&pixel0, &pixel, &y, &u, &v, 1);
+
+			YUV2RGB(pixel.yuv.y0, pixel.yuv.u, pixel.yuv.v, &r.d, &g.d, &b.d, matrix);
+			CheckRGB(&r, &g, &b);
+			YUV2RGB(pixel.yuv.y1, pixel.yuv.u, pixel.yuv.v, &r.d, &g.d, &b.d, matrix);
+			CheckRGB(&r, &g, &b);
+#endif
+		  }
+		  srcp = (unsigned long *)((unsigned char *)srcp + modulo) ;
+	  }
+  } else 
+if (vi.IsPlanar()) 
+#endif //x
+    {
+	  BYTE* srcp2 = (BYTE*) src->GetWritePtr(PLANAR_Y);
+    for (j = 0; j < h; j++) {
+		  for (i=0; i<w; i++) {
+        srcp2[i]=LUT_Y[srcp2[i]];
+      }
+	    srcp2 +=  pitch;
+    }
+	  srcp2 = (BYTE*) src->GetWritePtr(PLANAR_U);
+    h=src->GetHeight(PLANAR_U);
+    w=src->GetRowSize(PLANAR_U);
+    pitch=src->GetPitch(PLANAR_U);
+    for (j = 0; j < h; j++) {
+		  for (i=0; i<w; i++) {
+        srcp2[i]=LUT_U[srcp2[i]];
+      }
+	    srcp2 +=  pitch;
+    }
+	  srcp2 = (BYTE*) src->GetWritePtr(PLANAR_V);
+    for (j = 0; j < h; j++) {
+		  for (i=0; i<w; i++) {
+        srcp2[i]=LUT_V[srcp2[i]];
+      }
+	    srcp2 +=  pitch;
+    }
+  }
+
+#ifdef _DEBUG
+/*
+	y.ave  = ( y.ave+total)/total/2; u.ave  = ( u.ave+totalby2)/total;   v.ave  = ( v.ave+totalby2)/total;
+	y0.ave = (y0.ave+total)/total/2; u0.ave = (u0.ave+totalby2)/total;   v0.ave = (v0.ave+totalby2)/total;
+	r.ave  = ( r.ave+total)/total/2; g.ave  = ( g.ave+total   )/total/2; b.ave  = ( b.ave+total   )/total/2;
+	r0.ave = (r0.ave+total)/total/2; g0.ave = (g0.ave+total   )/total/2; b0.ave = (b0.ave+total   )/total/2;
+
+  char buf[256];
+  OutputDebugString("\n");
+	sprintf(buf,"frame=%05d  x_minimun   Src=[Y:%03d  U:%03d  V:%03d  R:%03d  G:%03d  B:%03d]" \
+				"  Dst=[Y:%03d  U:%03d  V:%03d  R:%03d  G:%03d  B:%03d]",
+				frame, y0.x_min,u0.x_min,v0.x_min, r0.x_min,g0.x_min,b0.x_min,
+				y.x_min,u.x_min,v.x_min, r.x_min,g.x_min,b.x_min);
+	OutputDebugString(buf);
+
+	sprintf(buf,"             x_maximum   Src=[Y:%03d  U:%03d  V:%03d  R:%03d  G:%03d  B:%03d]" \
+				"  Dst=[Y:%03d  U:%03d  V:%03d  R:%03d  G:%03d  B:%03d]",
+				y0.x_max,u0.x_max,v0.x_max, r0.x_max,g0.x_max,b0.x_max,
+				y.x_max,u.x_max,v.x_max, r.x_max,g.x_max,b.x_max);
+	OutputDebugString(buf);
+
+	sprintf(buf,"             average   Src=[Y:%03d  U:%03d  V:%03d  R:%03d  G:%03d  B:%03d]" \
+				"  Dst=[Y:%03d  U:%03d  V:%03d  R:%03d  G:%03d  B:%03d]",
+				y0.ave,u0.ave,v0.ave, r0.ave,g0.ave,b0.ave,
+				y.ave,u.ave,v.ave, r.ave,g.ave,b.ave);
+	OutputDebugString(buf);
+
+	sprintf(buf,"             underflow Src=[Y:%3d  U:%3d  V:%3d  R:%3d  G:%3d  B:%3d]" \
+				"  Dst=[Y:%3d  U:%3d  V:%3d  R:%3d  G:%3d  B:%3d]",
+				y0.under,u0.under,v0.under, r0.under,g0.under,b0.under,
+				y.under,u.under,v.under, r.under,g.under,b.under
+			);
+	OutputDebugString(buf);
+
+	sprintf(buf,"             overflow  Src=[Y:%3d  U:%3d  V:%3d  R:%3d  G:%3d  B:%3d]" \
+				"  Dst=[Y:%3d  U:%3d  V:%3d  R:%3d  G:%3d  B:%3d]",
+				y0.over,u0.over,v0.over, r0.over,g0.over,b0.over,
+				y.over,u.over,v.over, r.over,g.over,b.over
+			);
+	OutputDebugString(buf);
+*/
+#endif
+
+	return true;
+}
+/**
+    \fn MakeGammaLUT
+*/
+void vidColorYuv::MakeGammaLUT(void)
+{
+	static const int scale = 256, shift = 2^10,
+		coeff_y0 =  76309, coeff_y1 =  65536,
+		coeff_u0 = 132201, coeff_u1 = 116129,
+		coeff_v0 = 104597, coeff_v1 =  91881;
+	int i;
+	int val;
+	double g,b,c,gain;
+	double v;
+
+	y_thresh1 = u_thresh1 = v_thresh1 = -1;
+	y_thresh2 = u_thresh2 = v_thresh2 = 256;
+
+	gain = ((double)param.y_gain + scale) / scale;
+	c = ((double)param.y_contrast + scale) / scale;
+	b = ((double)param.y_bright + scale) / scale;
+	g = ((double)param.y_gamma + scale) / scale;
+	if (g < 0.01)    g = 0.01;
+	for (i = 0; i < 256; i++)
+    {
+		val = i * shift;
+		switch (param.levels) {
+			case 1:	// PC->TV
+				val = (int)((val - 16 * shift) * coeff_y0 / coeff_y1 + shift / 2);
+				break;
+			case 2:	// TV->PC
+			case 3:	// TV->PC.Y
+				val = (int)(val * coeff_y1 / coeff_y0 + 16 * shift + shift / 2);
+				break;
+			default:	//none
+				break;
+		}
+		val = val / shift;
+
+		v = ((double)val) / 256;
+		v = (v * gain) + ((v-0.5) * c + 0.5) - v + (b - 1);
+
+		if (param.y_gamma != 0 && v > 0)
+			v = pow( v, 1 / g);
+		v = v * 256;
+		
+		v += 0.5;
+		val = (int)floor(v);
+
+		if (val > 255)
+			val = 255;
+		else if (val < 0)
+			val = 0;
+
+		if (val > 235) {
+			if(y_thresh2 > 255)		y_thresh2 = i;
+			if(param.opt)		val = 235;
+		}
+		else if (val < 16) {
+			y_thresh1 = i;
+			if(param.opt)		val = 16;
+		}
+		LUT_Y[i] = (unsigned char)val;
+    }
+
+	gain = ((double)param.u_gain + scale);
+	c = ((double)param.u_contrast + scale);
+	b = ((double)param.u_bright);
+	for (i = 0; i < 256; i++)
+    {
+		val = i * shift;
+		switch (param.levels) {
+			case 1:	// PC->TV Scale
+				val = (int)((val - 128 * shift) * coeff_u0 / coeff_u1 + 128 * shift + shift / 2);
+				break;
+			case 2:	// TV->PC Scale
+				val = (int)((val - 128 * shift) * coeff_u1 / coeff_u0 + 128 * shift + shift / 2);
+				break;
+			default:	//none
+				break;
+		}
+		val = val / shift;
+
+		v = ((double)val);
+		v = (v * gain / scale) + ((v-128) * c / scale + 128) - v + b;
+
+		v += 0.5;
+		val = (int)floor(v);
+		
+		if (val > 255)
+			val = 255;
+		else if (val < 0)
+			val = 0;
+
+		if (val > 240) {
+			if(u_thresh2 > 255)		u_thresh2 = i;
+			if(param.opt)		val = 240;
+		}
+		else if (val < 16) {
+			u_thresh1 = i;
+			if(param.opt)		val = 16;
+		}
+		LUT_U[i] = (unsigned char)val;
+    }
+
+	gain = ((double)param.v_gain + scale);
+	c = ((double)param.v_contrast + scale);
+	b = ((double)param.v_bright);
+	for (i = 0; i < 256; i++)
+    {
+		val = i * shift;
+		switch (param.levels) {
+			case 1:	// PC->TV Scale
+				val = (int)((val - 128 * shift) * coeff_v0 / coeff_v1 + 128 * shift + shift / 2);
+				break;
+			case 2:	// TV->PC Scale
+				val = (int)((val - 128 * shift) * coeff_v1 / coeff_v0 + 128 * shift + shift / 2);
+				break;
+			default:	//none
+				break;
+		}
+		val = val / shift;
+
+		v = ((double)val);
+		v = (v * gain / scale) + ((v-128) * c / scale + 128) - v + b;
+
+		v += 0.5;
+		val = (int)floor(v);
+		
+		if (val > 255)
+			val = 255;
+		else if (val < 0)
+			val = 0;
+		
+		if (val > 240) {
+			if(v_thresh2 > 255)		v_thresh2 = i;
+			if(param.opt)		val = 240;
+		}
+		else if (val < 16) {
+			v_thresh1 = i;
+			if(param.opt)		val = 16;
+		}
+		LUT_V[i] = (unsigned char)val;
+    }
+
+#ifdef _DEBUG
+	DumpLUT();
+#endif
+
+}
+#if 0
+
+void	Color::YUV2RGB(int y, int u, int v, int *r, int *g, int *b, int matrix)
+{
+  if (matrix==0) {
+	  const int cy  = int((255.0/219.0)*65536+0.5);
+	  const int crv = int(1.596*65536+0.5);
+	  const int cgv = int(0.813*65536+0.5);
+	  const int cgu = int(0.391*65536+0.5);
+	  const int cbu = int(2.018*65536+0.5);
+	  int scaled_y = (y - 16) * cy;
+	  *b = ((scaled_y + (u-128) * cbu) + 2^15) >> 16;					// blue
+	  *g = ((scaled_y - (u-128) * cgu - (v-128) * cgv) + 2^15) >> 16;	// green
+	  *r = ((scaled_y + (v-128) * crv) + 2^15) >> 16;					// red
+  } else {
+	  // ITU-R Recommendation  BT.709
+	  const int cy  = 19077;
+	  const int crv = 3960 * 2;
+	  const int cgv = -4363 * 2;
+	  const int cgu = -1744 * 2;
+	  const int cbu = 17307 * 2;
+	  const int shift = 14;
+	  int scaled_y = (y - 16) * cy;
+	  *b = ((scaled_y + (u-128) * cbu) + 2^13) >> 14;					// blue
+	  *g = ((scaled_y - (u-128) * cgu - (v-128) * cgv) + 2^13) >> 14;	// green
+	  *r = ((scaled_y + (v-128) * crv) + 2^13) >> 14;					// red
+  }
+}
+
+
+void	Color::CheckRGB(COUNT *r, COUNT *b, COUNT *g)
+{
+	if(r->d < 0)		{ r->under++;	/*r->d = 0;*/	}
+	if(r->d > 255)		{ r->over++;	/*r->d = 255;*/	}
+	if(g->d < 0)		{ g->under++;	/*g->d = 0;*/	}
+	if(g->d > 255)		{ g->over++;	/*g->d = 255;*/	}
+	if(b->d < 0)		{ b->under++;	/*b->d = 0;*/	}
+	if(b->d > 255)		{ b->over++;	/*b->d = 255;*/	}
+	if(r->d < r->x_min)	{ r->x_min = r->d;	}
+	if(g->d < g->x_min)	{ g->x_min = g->d;	}
+	if(b->d < b->x_min)	{ b->x_min = b->d;	}
+	if(r->d > r->x_max)	{ r->x_max = r->d;	}
+	if(g->d > g->x_max)	{ g->x_max = g->d;	}
+	if(b->d > b->x_max)	{ b->x_max = b->d;	}
+	r->ave += r->d;
+	g->ave += g->d;
+	b->ave += b->d;
+}	
+
+void	Color::CheckYUV(PIXELDATA *pixel0, PIXELDATA *pixel, COUNT *y, COUNT *u, COUNT *v, int terget )
+{
+	if(!terget)	{
+		if(pixel->yuv.y0 < 16)			{ y->under++;	}
+		if(pixel->yuv.y0 > 235)			{ y->over++;	}
+		if(pixel->yuv.y1 < 16)			{ y->under++;	}
+		if(pixel->yuv.y1 > 235)			{ y->over++;	}
+	} else {
+		if(pixel0->yuv.y0 <= y_thresh1)	{ y->under++;	}
+		if(pixel0->yuv.y0 >= y_thresh2)	{ y->over++;	}
+		if(pixel0->yuv.y1 <= y_thresh1)	{ y->under++;	}
+		if(pixel0->yuv.y1 >= y_thresh2)	{ y->over++;	}
+	}
+	if(pixel->yuv.y0 < y->x_min)			{ y->x_min = pixel->yuv.y0;}
+	if(pixel->yuv.y0 > y->x_max)			{ y->x_max = pixel->yuv.y0;}
+	if(pixel->yuv.y1 < y->x_min)			{ y->x_min = pixel->yuv.y1;}
+	if(pixel->yuv.y1 > y->x_max)			{ y->x_max = pixel->yuv.y1;}
+	y->ave += pixel->yuv.y0;
+	y->ave += pixel->yuv.y1;
+
+	if(!terget)	{
+		if(pixel->yuv.u < 16)			{ u->under++;	}
+		if(pixel->yuv.u > 240)			{ u->over++;	}
+	} else {
+		if(pixel0->yuv.u <= u_thresh1)	{ u->under++;	}
+		if(pixel0->yuv.u >= u_thresh2)	{ u->over++;	}
+	}
+	if(pixel->yuv.u < u->x_min)			{ u->x_min = pixel->yuv.u;}
+	if(pixel->yuv.u > u->x_max)			{ u->x_max = pixel->yuv.u;}
+	u->ave += pixel->yuv.u;
+
+	if(!terget)	{
+		if(pixel->yuv.v < 16)			{ v->under++;	}
+		if(pixel->yuv.v > 240)			{ v->over++;	}
+	} else {
+		if(pixel0->yuv.v <= v_thresh1)	{ v->under++;	}
+		if(pixel0->yuv.v >= v_thresh2)	{ v->over++;	}
+	}
+	if(pixel->yuv.v < v->x_min)			{ v->x_min = pixel->yuv.v;}
+	if(pixel->yuv.v > v->x_max)			{ v->x_max = pixel->yuv.v;}
+	v->ave += pixel->yuv.v;
+}
+
+bool Color::CheckParms(const char *_levels, const char *_matrix, const char *_opt)
+{
+	int i;
+	static const char	*LevelsTbl[] = { "", "TV->PC", "PC->TV", "PC->TV.Y" },
+		*MatrixTbl[] = { "", "rec.709" },
+		*OptTbl[] = { "", "coring" };
+
+	levels = -1;
+	if (_levels) {
+		for (i=0; i<4 ; i++) {
+			if (!lstrcmpi(_levels, LevelsTbl[i])) 
+			{
+				levels = i;
+				break;
+			}
+		}
+	} else {		
+		levels = 0;
+	}
+
+	matrix = -1;
+	if (_matrix) {
+		for (i=0; i<2 ; i++) {
+			if (!lstrcmpi(_matrix, MatrixTbl[i])) 
+			{
+				matrix = i;
+				break;
+			}
+		}
+	} else {		
+		matrix = 0;
+	}
+
+	opt = -1;
+	if (_opt) {
+		for (i=0; i<2 ; i++) {
+			if (!lstrcmpi(_opt, OptTbl[i])) 
+			{
+				opt = i;
+				break;
+			}
+		}
+	} else {		
+		opt = 0;
+	}
+
+	if ( levels < 0 || matrix < 0 || opt < 0 )	return FALSE;
+	return TRUE;
+}
+
+
+void Color::DumpLUT(void)
+{
+/*
+  static const char *TitleTbl[] = {
+		"Color Adjust Look-up Table : Y, lux_minance\n",
+		"Color Adjust Look-up Table : U, Cb, Color Difference(blue)\n",
+		"Color Adjust Look-up Table : V, Cr, Color Difference(red)\n"
+	};
+	static const BYTE *LUT[] = { (BYTE *)&LUT_Y, (BYTE *)&LUT_U, (BYTE *)&LUT_V };
+	int	index,i,j;
+	char buf[512];
+
+	for(index=0; index<3; index++)
+	{
+		OutputDebugString( TitleTbl[index] );
+		for(i=0; i<16;i++)
+		{
+			sprintf(buf,"%03d(%02X) : ", i * 16, i * 16);
+			for(j=0;j<8;j++)
+			{
+				sprintf(&buf[j*4+10], "%03d ",LUT[index][i*16+j]);
+			}
+			sprintf(&buf[8*4+10], " - ");
+			for(j=8;j<16;j++)
+			{
+				sprintf(&buf[j*4+13], "%03d ",LUT[index][i*16+j]);
+			}
+			OutputDebugString(buf);
+		}
+		OutputDebugString("\n");
+	}
+*/
+}
+AVSValue __cdecl Color::Create(AVSValue args, void* user_data, IScriptEnvironment* env) {
+    try {	// HIDE DAMN SEH COMPILER BUG!!!
+		return new Color(args[0].AsClip(),
+						args[1].AsFloat(0.0),		// gain_y
+						args[2].AsFloat(0.0),		// off_y      bright
+						args[3].AsFloat(0.0),		// gamma_y
+						args[4].AsFloat(0.0),		// cont_y
+						args[5].AsFloat(0.0),		// gain_u
+						args[6].AsFloat(0.0),		// off_u      bright
+						args[7].AsFloat(0.0),		// gamma_u
+						args[8].AsFloat(0.0),		// cont_u
+						args[9].AsFloat(0.0),		// gain_v
+						args[10].AsFloat(0.0),		// off_v
+						args[11].AsFloat(0.0),		// gamma_v
+						args[12].AsFloat(0.0),		// cont_v
+						args[13].AsString(""),		// levels = "", "TV->PC", "PC->TV"
+						args[14].AsString(""),		// opt = "", "coring"
+						args[15].AsString(""),		// matrix = "", "rec.709"
+						args[16].AsBool(false),		// colorbars
+						args[17].AsBool(false),		// analyze
+						args[18].AsBool(false),		// autowhite
+						args[19].AsBool(false),		// autogain
+						env);
+	}
+	catch (...) { throw; }
+}
+#endif
+// EOF

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/colorYUV/colorYuv.conf
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/colorYUV/colorYuv.conf	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/colorYUV/colorYuv.conf	2010-10-28 05:54:49 UTC (rev 6717)
@@ -0,0 +1,19 @@
+float:y_contrast
+float:y_bright
+float:y_gamma
+float:y_gain
+float:u_contrast
+float:u_bright
+float:u_gamma
+float:u_gain;
+float:v_contrast
+float:v_bright
+float:v_gamma
+float:v_gain
+int32_t:matrix
+int32_t:levels
+int32_t:opt
+uint32_t:colorbars
+uint32_t:analyze
+uint32_t:autowhite
+uint32_t:autogain #matrix : 0 : none   1: rec.709 #Level :  0 : none   1:"TV->PC", 2:"PC->TV", 3:"PC->TV.Y" Opt :    0 : none   1: Coring

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/colorYUV/colorYuv.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/colorYUV/colorYuv.h	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/colorYUV/colorYuv.h	2010-10-28 05:54:49 UTC (rev 6717)
@@ -0,0 +1,26 @@
+// Automatically generated, do not edit!
+#ifndef ADM_colorYuv_CONF_H
+#define ADM_colorYuv_CONF_H
+typedef struct {
+   float y_contrast;
+   float y_bright;
+   float y_gamma;
+   float y_gain;
+   float u_contrast;
+   float u_bright;
+   float u_gamma;
+   float u_gain;
+   float v_contrast;
+   float v_bright;
+   float v_gamma;
+   float v_gain;
+   int32_t matrix;
+   int32_t levels;
+   int32_t opt;
+   uint32_t colorbars;
+   uint32_t analyze;
+   uint32_t autowhite;
+   uint32_t autogain ;
+}colorYuv;
+#endif //colorYuv
+//EOF

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/colorYUV/colorYuv_desc.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/colorYUV/colorYuv_desc.cpp	                        (rev 0)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/colorYUV/colorYuv_desc.cpp	2010-10-28 05:54:49 UTC (rev 6717)
@@ -0,0 +1,23 @@
+// Automatically generated, do not edit!
+const ADM_paramList colorYuv_param[]={
+ {"y_contrast",offsetof( colorYuv,y_contrast),"float",ADM_param_float},
+ {"y_bright",offsetof( colorYuv,y_bright),"float",ADM_param_float},
+ {"y_gamma",offsetof( colorYuv,y_gamma),"float",ADM_param_float},
+ {"y_gain",offsetof( colorYuv,y_gain),"float",ADM_param_float},
+ {"u_contrast",offsetof( colorYuv,u_contrast),"float",ADM_param_float},
+ {"u_bright",offsetof( colorYuv,u_bright),"float",ADM_param_float},
+ {"u_gamma",offsetof( colorYuv,u_gamma),"float",ADM_param_float},
+ {"u_gain",offsetof( colorYuv,u_gain),"float",ADM_param_float},
+ {"v_contrast",offsetof( colorYuv,v_contrast),"float",ADM_param_float},
+ {"v_bright",offsetof( colorYuv,v_bright),"float",ADM_param_float},
+ {"v_gamma",offsetof( colorYuv,v_gamma),"float",ADM_param_float},
+ {"v_gain",offsetof( colorYuv,v_gain),"float",ADM_param_float},
+ {"matrix",offsetof( colorYuv,matrix),"int32_t",ADM_param_int32_t},
+ {"levels",offsetof( colorYuv,levels),"int32_t",ADM_param_int32_t},
+ {"opt",offsetof( colorYuv,opt),"int32_t",ADM_param_int32_t},
+ {"colorbars",offsetof( colorYuv,colorbars),"uint32_t",ADM_param_uint32_t},
+ {"analyze",offsetof( colorYuv,analyze),"uint32_t",ADM_param_uint32_t},
+ {"autowhite",offsetof( colorYuv,autowhite),"uint32_t",ADM_param_uint32_t},
+ {"autogain ",offsetof( colorYuv,autogain ),"uint32_t",ADM_param_uint32_t},
+{NULL,0,NULL}
+};



From mean at mail.berlios.de  Thu Oct 28 07:54:51 2010
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Thu, 28 Oct 2010 07:54:51 +0200
Subject: [Avidemux-svn-commit] r6718 -
	branches/avidemux_2.6_branch_mean/avidemux/gtk/ADM_UIs/src
Message-ID: <20101028055451.58689480FA4@sheep.berlios.de>

Author: mean
Date: 2010-10-28 07:54:51 +0200 (Thu, 28 Oct 2010)
New Revision: 6718

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/gtk/ADM_UIs/src/FAC_menu.cpp
Log:
[Gtk] Dont crash if option is not available (merge from 2.5)

Modified: branches/avidemux_2.6_branch_mean/avidemux/gtk/ADM_UIs/src/FAC_menu.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/gtk/ADM_UIs/src/FAC_menu.cpp	2010-10-28 05:54:49 UTC (rev 6717)
+++ branches/avidemux_2.6_branch_mean/avidemux/gtk/ADM_UIs/src/FAC_menu.cpp	2010-10-28 05:54:51 UTC (rev 6718)
@@ -191,6 +191,7 @@
   
   
   rank=gtk_combo_box_get_active(GTK_COMBO_BOX(widget));
+  if(-1==rank) rank=0;
   ADM_assert(rank<this->nbMenu);
   *(uint32_t *)param=this->menu[rank]->val;
 }
@@ -215,6 +216,7 @@
   
   
   rank=gtk_combo_box_get_active(GTK_COMBO_BOX(widget));
+  if(-1==rank) rank=0;
   ADM_assert(rank<this->nbMenu);
   val=this->menu[rank]->val;
   /* Now search through the linked list to see if something happens ...*/



From mean at mail.berlios.de  Thu Oct 28 07:54:52 2010
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Thu, 28 Oct 2010 07:54:52 +0200
Subject: [Avidemux-svn-commit] r6719 - in
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6:
	. colorYUV
Message-ID: <20101028055452.7C668480FA4@sheep.berlios.de>

Author: mean
Date: 2010-10-28 07:54:52 +0200 (Thu, 28 Oct 2010)
New Revision: 6719

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/colorYUV/ADM_vidColorYuv.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/colorYUV/colorYuv.conf
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/colorYUV/colorYuv.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/colorYUV/colorYuv_desc.cpp
Log:
[VideoFilter] ColorYuv]

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/CMakeLists.txt	2010-10-28 05:54:51 UTC (rev 6718)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/CMakeLists.txt	2010-10-28 05:54:52 UTC (rev 6719)
@@ -1,6 +1,7 @@
 ADD_SUBDIRECTORY(addBorder)
 ADD_SUBDIRECTORY(ass)
 ADD_SUBDIRECTORY(blackenBorder)
+ADD_SUBDIRECTORY(colorYUV)
 ADD_SUBDIRECTORY(crop)
 ADD_SUBDIRECTORY(dummy)
 ADD_SUBDIRECTORY(fastConvolution)

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/colorYUV/ADM_vidColorYuv.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/colorYUV/ADM_vidColorYuv.cpp	2010-10-28 05:54:51 UTC (rev 6718)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/colorYUV/ADM_vidColorYuv.cpp	2010-10-28 05:54:52 UTC (rev 6719)
@@ -68,8 +68,61 @@
 */
 bool         vidColorYuv::configure(void)
 {
+    bool r=false;
+
+// --- Tab 1 ----
+#define PX(x) (&(param.x))
+     diaElemToggle     tAutoWhite(PX(autowhite),QT_TR_NOOP("AutoWhite"));
+     diaElemToggle     tAutoGain(PX(autogain),QT_TR_NOOP("AutoGain"));
+     diaElemToggle     tOpt(PX(opt),QT_TR_NOOP("Clip to Tv Range (16-235)"));
+     diaMenuEntry      levelMenus[]={{0,QT_TR_NOOP("None"),NULL},
+                                     {1,QT_TR_NOOP("PC->TV"),NULL},
+                                     {2,QT_TR_NOOP("TV->PC"),NULL}};
+// levels 	case 1:	// PC->TV Scale			case 2:	// TV->PC Scale  case 0:	//none
+        diaElemMenu mLevel(PX(levels),QT_TR_NOOP("Levels:"), sizeof(levelMenus)/sizeof(diaMenuEntry),levelMenus,"");    
+    diaElem *dia1[]={&tAutoWhite,&tAutoGain,&tOpt,&mLevel};
+//  diaElemFloat(ELEM_TYPE_FLOAT *intValue,const char *toggleTitle, ELEM_TYPE_FLOAT min, 
+//               ELEM_TYPE_FLOAT max,const char *tip=NULL, int decimals = 2);
+
+// --- Tab 2 ----
+
+    diaElemFloat        yGain(PX(y_gain),QT_TR_NOOP("Y gain"),0,100,NULL,3);
+    diaElemFloat        yBright(PX(y_bright),QT_TR_NOOP("Y Brightness"),0,100,NULL,3);
+    diaElemFloat        yGamma(PX(y_gamma),QT_TR_NOOP("Y Gamma"),0,100,NULL,3);
+    diaElemFloat        yContrast(PX(y_contrast),QT_TR_NOOP("Y Contrast"),0,100,NULL,3);
+ 
+    diaElem *dia2[]={&yGain,&yBright,&yGamma,&yContrast};
+// --- Tab 3 ----
+
+    diaElemFloat        uGain(PX(u_gain),QT_TR_NOOP("U gain"),0,100,NULL,3);
+    diaElemFloat        uBright(PX(u_bright),QT_TR_NOOP("U Brightness"),0,100,NULL,3);
+    diaElemFloat        uGamma(PX(u_gamma),QT_TR_NOOP("U Gamma"),0,100,NULL,3);
+    diaElemFloat        uContrast(PX(u_contrast),QT_TR_NOOP("U Contrast"),0,100,NULL,3);
+ 
+    diaElem *dia3[]={&uGain,&uBright,&uGamma,&uContrast};
+
+// --- Tab 4 ----
+
+    diaElemFloat        vGain(PX(u_gain),QT_TR_NOOP("V gain"),0,100,NULL,3);
+    diaElemFloat        vBright(PX(u_bright),QT_TR_NOOP("V Brightness"),0,100,NULL,3);
+    diaElemFloat        vGamma(PX(u_gamma),QT_TR_NOOP("V Gamma"),0,100,NULL,3);
+    diaElemFloat        vContrast(PX(u_contrast),QT_TR_NOOP("V Contrast"),0,100,NULL,3);
+ 
+    diaElem *dia4[]={&vGain,&vBright,&vGamma,&vContrast};
+//
+    diaElemTabs tab1(QT_TR_NOOP("Flags"),4,dia1);
+    diaElemTabs tab2(QT_TR_NOOP("Y"),4,dia2);
+    diaElemTabs tab3(QT_TR_NOOP("U"),4,dia3);
+    diaElemTabs tab4(QT_TR_NOOP("V"),4,dia4);
+    
+    diaElemTabs *tabs[]={&tab1,&tab2,&tab3,&tab4};
+    if( diaFactoryRunTabs(QT_TR_NOOP("colorYuv"),4,tabs))
+    {
+        r=true;
+    }
+
     MakeGammaLUT();
-    return true;
+    return r;
 }
 /**
     \fn getConfiguration

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/colorYUV/colorYuv.conf
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/colorYUV/colorYuv.conf	2010-10-28 05:54:51 UTC (rev 6718)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/colorYUV/colorYuv.conf	2010-10-28 05:54:52 UTC (rev 6719)
@@ -1,18 +1,18 @@
-float:y_contrast
+float:y_gain
 float:y_bright
 float:y_gamma
-float:y_gain
-float:u_contrast
+float:y_contrast
+float:u_gain
 float:u_bright
 float:u_gamma
-float:u_gain;
-float:v_contrast
+float:u_contrast
+float:v_gain
 float:v_bright
 float:v_gamma
-float:v_gain
-int32_t:matrix
-int32_t:levels
-int32_t:opt
+float:v_contrast
+uint32_t:matrix
+uint32_t:levels
+uint32_t:opt
 uint32_t:colorbars
 uint32_t:analyze
 uint32_t:autowhite

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/colorYUV/colorYuv.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/colorYUV/colorYuv.h	2010-10-28 05:54:51 UTC (rev 6718)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/colorYUV/colorYuv.h	2010-10-28 05:54:52 UTC (rev 6719)
@@ -2,21 +2,21 @@
 #ifndef ADM_colorYuv_CONF_H
 #define ADM_colorYuv_CONF_H
 typedef struct {
-   float y_contrast;
+   float y_gain;
    float y_bright;
    float y_gamma;
-   float y_gain;
-   float u_contrast;
+   float y_contrast;
+   float u_gain;
    float u_bright;
    float u_gamma;
-   float u_gain;
-   float v_contrast;
+   float u_contrast;
+   float v_gain;
    float v_bright;
    float v_gamma;
-   float v_gain;
-   int32_t matrix;
-   int32_t levels;
-   int32_t opt;
+   float v_contrast;
+   uint32_t matrix;
+   uint32_t levels;
+   uint32_t opt;
    uint32_t colorbars;
    uint32_t analyze;
    uint32_t autowhite;

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/colorYUV/colorYuv_desc.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/colorYUV/colorYuv_desc.cpp	2010-10-28 05:54:51 UTC (rev 6718)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/colorYUV/colorYuv_desc.cpp	2010-10-28 05:54:52 UTC (rev 6719)
@@ -1,20 +1,20 @@
 // Automatically generated, do not edit!
 const ADM_paramList colorYuv_param[]={
- {"y_contrast",offsetof( colorYuv,y_contrast),"float",ADM_param_float},
+ {"y_gain",offsetof( colorYuv,y_gain),"float",ADM_param_float},
  {"y_bright",offsetof( colorYuv,y_bright),"float",ADM_param_float},
  {"y_gamma",offsetof( colorYuv,y_gamma),"float",ADM_param_float},
- {"y_gain",offsetof( colorYuv,y_gain),"float",ADM_param_float},
- {"u_contrast",offsetof( colorYuv,u_contrast),"float",ADM_param_float},
+ {"y_contrast",offsetof( colorYuv,y_contrast),"float",ADM_param_float},
+ {"u_gain",offsetof( colorYuv,u_gain),"float",ADM_param_float},
  {"u_bright",offsetof( colorYuv,u_bright),"float",ADM_param_float},
  {"u_gamma",offsetof( colorYuv,u_gamma),"float",ADM_param_float},
- {"u_gain",offsetof( colorYuv,u_gain),"float",ADM_param_float},
- {"v_contrast",offsetof( colorYuv,v_contrast),"float",ADM_param_float},
+ {"u_contrast",offsetof( colorYuv,u_contrast),"float",ADM_param_float},
+ {"v_gain",offsetof( colorYuv,v_gain),"float",ADM_param_float},
  {"v_bright",offsetof( colorYuv,v_bright),"float",ADM_param_float},
  {"v_gamma",offsetof( colorYuv,v_gamma),"float",ADM_param_float},
- {"v_gain",offsetof( colorYuv,v_gain),"float",ADM_param_float},
- {"matrix",offsetof( colorYuv,matrix),"int32_t",ADM_param_int32_t},
- {"levels",offsetof( colorYuv,levels),"int32_t",ADM_param_int32_t},
- {"opt",offsetof( colorYuv,opt),"int32_t",ADM_param_int32_t},
+ {"v_contrast",offsetof( colorYuv,v_contrast),"float",ADM_param_float},
+ {"matrix",offsetof( colorYuv,matrix),"uint32_t",ADM_param_uint32_t},
+ {"levels",offsetof( colorYuv,levels),"uint32_t",ADM_param_uint32_t},
+ {"opt",offsetof( colorYuv,opt),"uint32_t",ADM_param_uint32_t},
  {"colorbars",offsetof( colorYuv,colorbars),"uint32_t",ADM_param_uint32_t},
  {"analyze",offsetof( colorYuv,analyze),"uint32_t",ADM_param_uint32_t},
  {"autowhite",offsetof( colorYuv,autowhite),"uint32_t",ADM_param_uint32_t},



From mean at mail.berlios.de  Thu Oct 28 07:54:53 2010
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Thu, 28 Oct 2010 07:54:53 +0200
Subject: [Avidemux-svn-commit] r6720 -
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters/Yadif
Message-ID: <20101028055453.D0F3F480FA4@sheep.berlios.de>

Author: mean
Date: 2010-10-28 07:54:53 +0200 (Thu, 28 Oct 2010)
New Revision: 6720

Removed:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters/Yadif/ADM_vidYadif.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters/Yadif/ADM_vidYadif_asm.c
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters/Yadif/CMakeLists.txt
Log:
[cleanup] VideoFilters : yadif has been ported

Deleted: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters/Yadif/ADM_vidYadif.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters/Yadif/ADM_vidYadif.cpp	2010-10-28 05:54:52 UTC (rev 6719)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters/Yadif/ADM_vidYadif.cpp	2010-10-28 05:54:53 UTC (rev 6720)
@@ -1,395 +0,0 @@
-/*
-	Yadif C-plugin for Avisynth 2.5 - Yet Another DeInterlacing Filter
-	Copyright (C)2007 Alexander G. Balakhnin aka Fizick  http://avisynth.org.ru
-    Port of YADIF filter from MPlayer
-	Copyright (C) 2006 Michael Niedermayer <michaelni at gmx.at>
-
-    This program is free software; you can redistribute it and/or modify
-	it under the terms of the GNU General Public License as published by
-	the Free Software Foundation.
-
-	This program is distributed in the hope that it will be useful,
-	but WITHOUT ANY WARRANTY; without even the implied warranty of
-	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-	GNU General Public License for more details.
-
-	You should have received a copy of the GNU General Public License
-	along with this program; if not, write to the Free Software
-	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
-
-    Avisynth_C plugin
-	Assembler optimized for GNU C compiler
-
-*/
-/*
-  Ported to avidemux by mean
-  Same license as original (?GPL)
-*/
-
-#include "ADM_default.h"
-#include "ADM_videoFilterDynamic.h"
-#include "DIA_factory.h"
-//************************************************
-#define MIN(a,b) ((a) > (b) ? (b) : (a))
-#define MAX(a,b) ((a) < (b) ? (b) : (a))
-#define ABS(a) ((a) > 0 ? (a) : (-(a)))
-
-#define MIN3(a,b,c) MIN(MIN(a,b),c)
-#define MAX3(a,b,c) MAX(MAX(a,b),c)
-
-//===========================================================================//
-#ifdef ADM_CPU_X86
-extern "C"
-{
-void filter_line_mmx2(int mode, uint8_t *dst, const uint8_t *prev, const uint8_t *cur, const uint8_t *next, int w, int refs, int parity);
-}
-#endif
-//
-typedef struct YADIF_PARAM
-{
-    uint32_t mode;
-    uint32_t order;
-}YADIF_PARAM;
-
-class  ADMVideoYadif:public AVDMGenericVideoStream
-{
-
- protected:
-  virtual char                 *printConf(void);
-  YADIF_PARAM                  *_param;
-   VideoCache                  *vidCache;
-  void                         updateInfo(void);
-
- public:
-                  ADMVideoYadif(AVDMGenericVideoStream *in, CONFcouple *setup);
-  virtual         ~ADMVideoYadif();
-  virtual uint8_t configure( AVDMGenericVideoStream *instream) ;
-  virtual uint8_t getFrameNumberNoAlloc(uint32_t frame, uint32_t *len, ADMImage *data,uint32_t *flags);
-  virtual uint8_t	getCoupledConf( CONFcouple **couples)				;
- }     ;
-
-static FILTER_PARAM yadifParam={2,{"mode","order"}};
-//************************************
-
-VF_DEFINE_FILTER(ADMVideoYadif,yadifParam,
-                YADIF,
-                QT_TR_NOOP("yadif"),
-                1,
-                VF_INTERLACING,
-                QT_TR_NOOP("Yet Another DeInterlacer. Ported from MPlayer."));
-
-//************************************
-//
-static void filter_plane(int mode, uint8_t *dst, int dst_stride, const uint8_t *prev0, const uint8_t *cur0, const uint8_t *next0, int refs, int w, int h, int parity, int tff, int mmx);
-
-
-//***************************************************
-//***************************************************
-char *ADMVideoYadif::printConf( void )
-{
-  ADM_FILTER_DECLARE_CONF(" Yadif : mode %u order %d",_param->mode, _param->order);
-  
-}
-
-ADMVideoYadif::ADMVideoYadif(AVDMGenericVideoStream *in, CONFcouple *couples)
-{
-  _in=in;		
-
-  memcpy(&_info,_in->getInfo(),sizeof(_info)); 
-  _info.encoding=1;
-
- // _uncompressed=new uint8_t [3*_in->getInfo()->width*_in->getInfo()->height];
- 
-
-  if(couples)
-  {
-   	 _param=new (YADIF_PARAM);
-	GET(mode);
-        GET(order);
-  }
-  else
-  {
-    _param = new ( YADIF_PARAM);
-    _param->mode=0;
-    _param->order=1;
-  }
-  _uncompressed=new ADMImage(_in->getInfo()->width,_in->getInfo()->height);
-  ADM_assert(_uncompressed);    	  	
-  vidCache = new VideoCache (10, in);
-  updateInfo();
-}
-
-void ADMVideoYadif::updateInfo(void)
-{
-   memcpy(&_info,_in->getInfo(),sizeof(_info)); 
-  if(_param->mode &1 ) // Bob
-  {
-    _info.nb_frames*=2;
-    _info.fps1000*=2;
-  }
-}
-
-uint8_t ADMVideoYadif::configure( AVDMGenericVideoStream *instream) 
-{
-  _in= instream;
-     diaMenuEntry tMode[]={
-                             {0,      QT_TR_NOOP("Temporal & spatial check"),NULL},
-                             {1,   QT_TR_NOOP("Bob, temporal & spatial check"),NULL},
-                             {2,      QT_TR_NOOP("Skip spatial temporal check"),NULL},
-                             {3,  QT_TR_NOOP("Bob, skip spatial temporal check"),NULL}
-          };
-     diaMenuEntry tOrder[]={
-                             {0,      QT_TR_NOOP("Bottom field first"),NULL},
-                             {1,   QT_TR_NOOP("Top field first"),NULL}
-          };
-  
-     diaElemMenu mMode(&(_param->mode),   QT_TR_NOOP("_Mode:"), 4,tMode);
-     diaElemMenu morder(&(_param->order),   QT_TR_NOOP("_Order:"), 2,tOrder);
-     
-     diaElem *elems[]={&mMode,&morder};
-     
-     if(diaFactoryRun(QT_TR_NOOP("yadif"),sizeof(elems)/sizeof(diaElem *),elems))
-     {
-        updateInfo();
-        return 1;
-     }
-     return 0;
-}
-
-uint8_t	ADMVideoYadif::getCoupledConf( CONFcouple **couples)
-{
-#define CSET(x)  (*couples)->setCouple((char *)#x,(_param->x))
-
-          ADM_assert(_param);
-          *couples=new CONFcouple(2);
-
-          CSET(mode);
-          CSET(order);
-          return 1;
-
-}
-
-
-ADMVideoYadif::~ADMVideoYadif()
-{
-        delete  _uncompressed;
-        _uncompressed=NULL;
-       
-        delete vidCache;
-        vidCache = NULL;
-        
-        delete _param;
-        _param=NULL;
-}
-
-uint8_t ADMVideoYadif::getFrameNumberNoAlloc(uint32_t frame,
-                                              uint32_t *len,
-                                              ADMImage *data,
-                                              uint32_t *flags)
-{
-        int mode;
-        int parity;
-        int tff;
-        int iplane;
-        int cpu;
-        int n;
-        ADMImage *src, *dst, * prev, *next;
-
-    
-        mode = _param->mode;
-
-        if (mode & 1) 
-                n = (frame>>1); // bob
-        else
-                n = frame;
-
-        src = vidCache->getImage(n);
-  // Request frame 'n' from the child (source) clip.
-
-        if (n>0)
-                prev =  vidCache->getImage( n-1); // get previous frame
-        else
-                prev= vidCache->getImage(0); // get very first frame
-
-        if (n< _in->getInfo()->nb_frames-1)
-                next = vidCache->getImage( n+1); // get next frame
-        else
-                next = vidCache->getImage( _in->getInfo()->nb_frames-1); // get last frame
-
-        dst = data;
-        
-        if(!prev || !src || !next)
-        {
-            printf("Failed to read frame for frame %u\n",frame);
-            vidCache->unlockAll();
-            return 0;
-        }
-        
-  // Construct a frame based on the information of the current frame
-  // contained in the "vi" struct.
-#if 0 //MEANX
-        if (_params->order == -1)
-//		tff = avs_is_tff(&p->vi) == 0 ? 0 : 1; // 0 or 1
-                tff = avs_get_parity(p->child, n) ? 1 : 0; // 0 or 1
-        else
-#endif
-                tff = _param->order;	
-        
-        parity = (mode & 1) ? (frame & 1) ^ (1^tff) : (tff ^ 1);  // 0 or 1
-
-      //MEANX  cpu = avs_get_cpu_flags(p->env);
-
-        for (iplane = 0; iplane<3; iplane++)
-        {
-                ADM_PLANE plane = (iplane==0) ? PLANAR_Y : (iplane==1) ? PLANAR_U : PLANAR_V;
-
-                const unsigned char* srcp = src->GetWritePtr(plane);
-          // Request a Read pointer from the current source frame
-
-                const unsigned char* prevp0 = prev->GetWritePtr( plane);
-                unsigned char* prevp = (unsigned char*) prevp0; // with same pitch
-          // Request a Read pointer from the prev source frame.
-
-                const unsigned char* nextp0 = next->GetWritePtr( plane);
-                unsigned char* nextp = (unsigned char*) nextp0; // with same pitch
-          // Request a Read pointer from the next source frame.
-
-                unsigned char* dstp = dst->GetWritePtr( plane);
-                // Request a Write pointer from the newly created destination image.
-          // You can request a writepointer to images that have just been
-
-                const int dst_pitch = dst->GetPitch( plane);
-          // Requests pitch (length of a line) of the destination image.
-          // For more information on pitch see: http://www.avisynth.org/index.php?page=WorkingWithImages
-                // (short version - pitch is always equal to or greater than width to allow for seriously fast assembly code)
-
-                const int width =dst->GetPitch( plane);
-          // Requests rowsize (number of used bytes in a line.
-          // See the link above for more information.
-
-                const int height = dst->GetHeight( plane);
-          // Requests the height of the destination image.
-
-                const int src_pitch = src->GetPitch(plane);
-                const int prev_pitch = prev->GetPitch(plane);
-                const int next_pitch = next->GetPitch(plane);
-
-                // in v.0.1-0.3  all source pitches are  assumed equal (for simplicity)
-                                // consider other (rare) case
-                if (prev_pitch != src_pitch)
-                {
-                    prevp = (unsigned char *)ADM_alloc(height*src_pitch);
-                    int h;
-                    for (h=0; h<0; h++)
-                      memcpy(prevp+h*src_pitch, prevp0+h*prev_pitch, width);
-                }
-                    
-                if (next_pitch != src_pitch)
-                {
-                    nextp = (unsigned char *)ADM_alloc(height*src_pitch);
-                    int h;
-                    for (h=0; h<0; h++)
-                      memcpy(nextp+h*src_pitch, nextp0+h*next_pitch, width);
-                }
-                    
-                filter_plane(mode, dstp, dst_pitch, prevp, srcp, nextp, src_pitch, width, height, parity, tff, 0);
-                if (prev_pitch != src_pitch)
-                        ADM_dealloc(prevp);
-                if (next_pitch != src_pitch)
-                        ADM_dealloc(nextp);
-        }
-       vidCache->unlockAll();
-      return 1;
-}
-//****************
-
-static void filter_line_c(int mode, uint8_t *dst, const uint8_t *prev, const uint8_t *cur, const uint8_t *next, int w, int refs, int parity){
-    int x;
-    const uint8_t *prev2= parity ? prev : cur ;
-    const uint8_t *next2= parity ? cur  : next;
-    for(x=0; x<w; x++){
-        int c= cur[-refs];
-        int d= (prev2[0] + next2[0])>>1;
-        int e= cur[+refs];
-        int temporal_diff0= ABS(prev2[0] - next2[0]);
-        int temporal_diff1=( ABS(prev[-refs] - c) + ABS(prev[+refs] - e) )>>1;
-        int temporal_diff2=( ABS(next[-refs] - c) + ABS(next[+refs] - e) )>>1;
-        int diff= MAX3(temporal_diff0>>1, temporal_diff1, temporal_diff2);
-        int spatial_pred= (c+e)>>1;
-        int spatial_score= ABS(cur[-refs-1] - cur[+refs-1]) + ABS(c-e)
-                         + ABS(cur[-refs+1] - cur[+refs+1]) - 1;
-
-#define CHECK(j)\
-    {   int score= ABS(cur[-refs-1+ j] - cur[+refs-1- j])\
-                 + ABS(cur[-refs  + j] - cur[+refs  - j])\
-                 + ABS(cur[-refs+1+ j] - cur[+refs+1- j]);\
-        if(score < spatial_score){\
-            spatial_score= score;\
-            spatial_pred= (cur[-refs  + j] + cur[+refs  - j])>>1;\
-
-        CHECK(-1) CHECK(-2) }} }}
-        CHECK( 1) CHECK( 2) }} }}
-
-        if(mode<2){
-            int b= (prev2[-2*refs] + next2[-2*refs])>>1;
-            int f= (prev2[+2*refs] + next2[+2*refs])>>1;
-#if 0
-            int a= cur[-3*refs];
-            int g= cur[+3*refs];
-            int max= MAX3(d-e, d-c, MIN3(MAX(b-c,f-e),MAX(b-c,b-a),MAX(f-g,f-e)) );
-            int min= MIN3(d-e, d-c, MAX3(MIN(b-c,f-e),MIN(b-c,b-a),MIN(f-g,f-e)) );
-#else
-            int max= MAX3(d-e, d-c, MIN(b-c, f-e));
-            int min= MIN3(d-e, d-c, MAX(b-c, f-e));
-#endif
-
-            diff= MAX3(diff, min, -max);
-        }
-
-        if(spatial_pred > d + diff)
-           spatial_pred = d + diff;
-        else if(spatial_pred < d - diff)
-           spatial_pred = d - diff;
-
-        dst[0] = spatial_pred;
-
-        dst++;
-        cur++;
-        prev++;
-        next++;
-        prev2++;
-        next2++;
-    }
-}
-
-void filter_plane(int mode, uint8_t *dst, int dst_stride, const uint8_t *prev0, const uint8_t *cur0, const uint8_t *next0, int refs, int w, int h, int parity, int tff, int mmx)
-{
-void (*filter_line)(int mode, uint8_t *dst, const uint8_t *prev, const uint8_t *cur, const uint8_t *next, int w, int refs, int parity);
-	int y;
-	filter_line = filter_line_c;
-#ifdef ADM_CPU_X86
-	if (CpuCaps::hasMMXEXT()) 
-		filter_line = filter_line_mmx2;
-#endif
-
-        memcpy(dst, cur0, w);
-        memcpy(dst + dst_stride, cur0 + refs, w);
-        for(y=2; y<h-1; y++){
-            if(((y ^ parity) & 1)){
-                const uint8_t *prev= prev0 + y*refs;
-                const uint8_t *cur = cur0 + y*refs;
-                const uint8_t *next= next0 + y*refs;
-                uint8_t *dst2= dst + y*dst_stride;
-                filter_line(mode, dst2, prev, cur, next, w, refs, (parity ^ tff));
-            }else{
-                memcpy(dst + y*dst_stride, cur0 + y*refs, w);
-            }
-        }
-        memcpy(dst + (h-1)*dst_stride, cur0 + (h-1)*refs, w);
-
-#ifdef ADM_CPU_X86
-	if (CpuCaps::hasMMXEXT()) 
-		asm volatile("emms");
-#endif
-}
-

Deleted: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters/Yadif/ADM_vidYadif_asm.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters/Yadif/ADM_vidYadif_asm.c	2010-10-28 05:54:52 UTC (rev 6719)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters/Yadif/ADM_vidYadif_asm.c	2010-10-28 05:54:53 UTC (rev 6720)
@@ -1,227 +0,0 @@
-
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <inttypes.h>
-#include <math.h>
-
-#include "ADM_default.h"
-
-#ifdef ADM_CPU_X86
-
-
-#define LOAD4(mem,dst) \
-            "movd      "mem", "#dst" \n\t"\
-            "punpcklbw %%mm7, "#dst" \n\t"
-
-#define PABS(tmp,dst) \
-            "pxor     "#tmp", "#tmp" \n\t"\
-            "psubw    "#dst", "#tmp" \n\t"\
-            "pmaxsw   "#tmp", "#dst" \n\t"
-
-#define CHECK(pj,mj) \
-            "movq "#pj"(%[cur],%[mrefs]), %%mm2 \n\t" /* cur[x-refs-1+j] */\
-            "movq "#mj"(%[cur],%[prefs]), %%mm3 \n\t" /* cur[x+refs-1-j] */\
-            "movq      %%mm2, %%mm4 \n\t"\
-            "movq      %%mm2, %%mm5 \n\t"\
-            "pxor      %%mm3, %%mm4 \n\t"\
-            "pavgb     %%mm3, %%mm5 \n\t"\
-            "pand     %[pb1], %%mm4 \n\t"\
-            "psubusb   %%mm4, %%mm5 \n\t"\
-            "psrlq     $8,    %%mm5 \n\t"\
-            "punpcklbw %%mm7, %%mm5 \n\t" /* (cur[x-refs+j] + cur[x+refs-j])>>1 */\
-            "movq      %%mm2, %%mm4 \n\t"\
-            "psubusb   %%mm3, %%mm2 \n\t"\
-            "psubusb   %%mm4, %%mm3 \n\t"\
-            "pmaxub    %%mm3, %%mm2 \n\t"\
-            "movq      %%mm2, %%mm3 \n\t"\
-            "movq      %%mm2, %%mm4 \n\t" /* ABS(cur[x-refs-1+j] - cur[x+refs-1-j]) */\
-            "psrlq      $8,   %%mm3 \n\t" /* ABS(cur[x-refs  +j] - cur[x+refs  -j]) */\
-            "psrlq     $16,   %%mm4 \n\t" /* ABS(cur[x-refs+1+j] - cur[x+refs+1-j]) */\
-            "punpcklbw %%mm7, %%mm2 \n\t"\
-            "punpcklbw %%mm7, %%mm3 \n\t"\
-            "punpcklbw %%mm7, %%mm4 \n\t"\
-            "paddw     %%mm3, %%mm2 \n\t"\
-            "paddw     %%mm4, %%mm2 \n\t" /* score */
-
-#define CHECK1 \
-            "movq      %%mm0, %%mm3 \n\t"\
-            "pcmpgtw   %%mm2, %%mm3 \n\t" /* if(score < spatial_score) */\
-            "pminsw    %%mm2, %%mm0 \n\t" /* spatial_score= score; */\
-            "movq      %%mm3, %%mm6 \n\t"\
-            "pand      %%mm3, %%mm5 \n\t"\
-            "pandn     %%mm1, %%mm3 \n\t"\
-            "por       %%mm5, %%mm3 \n\t"\
-            "movq      %%mm3, %%mm1 \n\t" /* spatial_pred= (cur[x-refs+j] + cur[x+refs-j])>>1; */
-
-#define CHECK2 /* pretend not to have checked dir=2 if dir=1 was bad.\
-                  hurts both quality and speed, but matches the C version. */\
-            "paddw    %[pw1], %%mm6 \n\t"\
-            "psllw     $14,   %%mm6 \n\t"\
-            "paddsw    %%mm6, %%mm2 \n\t"\
-            "movq      %%mm0, %%mm3 \n\t"\
-            "pcmpgtw   %%mm2, %%mm3 \n\t"\
-            "pminsw    %%mm2, %%mm0 \n\t"\
-            "pand      %%mm3, %%mm5 \n\t"\
-            "pandn     %%mm1, %%mm3 \n\t"\
-            "por       %%mm5, %%mm3 \n\t"\
-            "movq      %%mm3, %%mm1 \n\t"
-
-void filter_line_mmx2(int mode, uint8_t *dst, const uint8_t *prev, const uint8_t *cur, const uint8_t *next, int w, int refs, int parity){
-    static const uint64_t pw_1 = 0x0001000100010001ULL;
-    static const uint64_t pb_1 = 0x0101010101010101ULL;
-//    const int mode = p->mode;
-    uint64_t tmp0, tmp1, tmp2, tmp3;
-    int x;
-
-#define FILTER\
-    for(x=0; x<w; x+=4){\
-        asm volatile(\
-            "pxor      %%mm7, %%mm7 \n\t"\
-            LOAD4("(%[cur],%[mrefs])", %%mm0) /* c = cur[x-refs] */\
-            LOAD4("(%[cur],%[prefs])", %%mm1) /* e = cur[x+refs] */\
-            LOAD4("(%["prev2"])", %%mm2) /* prev2[x] */\
-            LOAD4("(%["next2"])", %%mm3) /* next2[x] */\
-            "movq      %%mm3, %%mm4 \n\t"\
-            "paddw     %%mm2, %%mm3 \n\t"\
-            "psraw     $1,    %%mm3 \n\t" /* d = (prev2[x] + next2[x])>>1 */\
-            "movq      %%mm0, %[tmp0] \n\t" /* c */\
-            "movq      %%mm3, %[tmp1] \n\t" /* d */\
-            "movq      %%mm1, %[tmp2] \n\t" /* e */\
-            "psubw     %%mm4, %%mm2 \n\t"\
-            PABS(      %%mm4, %%mm2) /* temporal_diff0 */\
-            LOAD4("(%[prev],%[mrefs])", %%mm3) /* prev[x-refs] */\
-            LOAD4("(%[prev],%[prefs])", %%mm4) /* prev[x+refs] */\
-            "psubw     %%mm0, %%mm3 \n\t"\
-            "psubw     %%mm1, %%mm4 \n\t"\
-            PABS(      %%mm5, %%mm3)\
-            PABS(      %%mm5, %%mm4)\
-            "paddw     %%mm4, %%mm3 \n\t" /* temporal_diff1 */\
-            "psrlw     $1,    %%mm2 \n\t"\
-            "psrlw     $1,    %%mm3 \n\t"\
-            "pmaxsw    %%mm3, %%mm2 \n\t"\
-            LOAD4("(%[next],%[mrefs])", %%mm3) /* next[x-refs] */\
-            LOAD4("(%[next],%[prefs])", %%mm4) /* next[x+refs] */\
-            "psubw     %%mm0, %%mm3 \n\t"\
-            "psubw     %%mm1, %%mm4 \n\t"\
-            PABS(      %%mm5, %%mm3)\
-            PABS(      %%mm5, %%mm4)\
-            "paddw     %%mm4, %%mm3 \n\t" /* temporal_diff2 */\
-            "psrlw     $1,    %%mm3 \n\t"\
-            "pmaxsw    %%mm3, %%mm2 \n\t"\
-            "movq      %%mm2, %[tmp3] \n\t" /* diff */\
-\
-            "paddw     %%mm0, %%mm1 \n\t"\
-            "paddw     %%mm0, %%mm0 \n\t"\
-            "psubw     %%mm1, %%mm0 \n\t"\
-            "psrlw     $1,    %%mm1 \n\t" /* spatial_pred */\
-            PABS(      %%mm2, %%mm0)      /* ABS(c-e) */\
-\
-            "movq -1(%[cur],%[mrefs]), %%mm2 \n\t" /* cur[x-refs-1] */\
-            "movq -1(%[cur],%[prefs]), %%mm3 \n\t" /* cur[x+refs-1] */\
-            "movq      %%mm2, %%mm4 \n\t"\
-            "psubusb   %%mm3, %%mm2 \n\t"\
-            "psubusb   %%mm4, %%mm3 \n\t"\
-            "pmaxub    %%mm3, %%mm2 \n\t"\
-            "pshufw $9,%%mm2, %%mm3 \n\t"\
-            "punpcklbw %%mm7, %%mm2 \n\t" /* ABS(cur[x-refs-1] - cur[x+refs-1]) */\
-            "punpcklbw %%mm7, %%mm3 \n\t" /* ABS(cur[x-refs+1] - cur[x+refs+1]) */\
-            "paddw     %%mm2, %%mm0 \n\t"\
-            "paddw     %%mm3, %%mm0 \n\t"\
-            "psubw    %[pw1], %%mm0 \n\t" /* spatial_score */\
-\
-            CHECK(-2,0)\
-            CHECK1\
-            CHECK(-3,1)\
-            CHECK2\
-            CHECK(0,-2)\
-            CHECK1\
-            CHECK(1,-3)\
-            CHECK2\
-\
-            /* if(p->mode<2) ... */\
-            "movq    %[tmp3], %%mm6 \n\t" /* diff */\
-            "cmp       $2, %[mode] \n\t"\
-            "jge       1f \n\t"\
-            LOAD4("(%["prev2"],%[mrefs],2)", %%mm2) /* prev2[x-2*refs] */\
-            LOAD4("(%["next2"],%[mrefs],2)", %%mm4) /* next2[x-2*refs] */\
-            LOAD4("(%["prev2"],%[prefs],2)", %%mm3) /* prev2[x+2*refs] */\
-            LOAD4("(%["next2"],%[prefs],2)", %%mm5) /* next2[x+2*refs] */\
-            "paddw     %%mm4, %%mm2 \n\t"\
-            "paddw     %%mm5, %%mm3 \n\t"\
-            "psrlw     $1,    %%mm2 \n\t" /* b */\
-            "psrlw     $1,    %%mm3 \n\t" /* f */\
-            "movq    %[tmp0], %%mm4 \n\t" /* c */\
-            "movq    %[tmp1], %%mm5 \n\t" /* d */\
-            "movq    %[tmp2], %%mm7 \n\t" /* e */\
-            "psubw     %%mm4, %%mm2 \n\t" /* b-c */\
-            "psubw     %%mm7, %%mm3 \n\t" /* f-e */\
-            "movq      %%mm5, %%mm0 \n\t"\
-            "psubw     %%mm4, %%mm5 \n\t" /* d-c */\
-            "psubw     %%mm7, %%mm0 \n\t" /* d-e */\
-            "movq      %%mm2, %%mm4 \n\t"\
-            "pminsw    %%mm3, %%mm2 \n\t"\
-            "pmaxsw    %%mm4, %%mm3 \n\t"\
-            "pmaxsw    %%mm5, %%mm2 \n\t"\
-            "pminsw    %%mm5, %%mm3 \n\t"\
-            "pmaxsw    %%mm0, %%mm2 \n\t" /* max */\
-            "pminsw    %%mm0, %%mm3 \n\t" /* min */\
-            "pxor      %%mm4, %%mm4 \n\t"\
-            "pmaxsw    %%mm3, %%mm6 \n\t"\
-            "psubw     %%mm2, %%mm4 \n\t" /* -max */\
-            "pmaxsw    %%mm4, %%mm6 \n\t" /* diff= MAX3(diff, min, -max); */\
-            "1: \n\t"\
-\
-            "movq    %[tmp1], %%mm2 \n\t" /* d */\
-            "movq      %%mm2, %%mm3 \n\t"\
-            "psubw     %%mm6, %%mm2 \n\t" /* d-diff */\
-            "paddw     %%mm6, %%mm3 \n\t" /* d+diff */\
-            "pmaxsw    %%mm2, %%mm1 \n\t"\
-            "pminsw    %%mm3, %%mm1 \n\t" /* d = clip(spatial_pred, d-diff, d+diff); */\
-            "packuswb  %%mm1, %%mm1 \n\t"\
-\
-            :[tmp0]"=m"(tmp0),\
-             [tmp1]"=m"(tmp1),\
-             [tmp2]"=m"(tmp2),\
-             [tmp3]"=m"(tmp3)\
-            :[prev] "r"(prev),\
-             [cur]  "r"(cur),\
-             [next] "r"(next),\
-             [prefs]"r"((long)refs),\
-             [mrefs]"r"((long)-refs),\
-             [pw1]  "m"(pw_1),\
-             [pb1]  "m"(pb_1),\
-             [mode] "g"(mode)\
-        );\
-        asm volatile("movd %%mm1, %0" :"=m"(*dst));\
-        dst += 4;\
-        prev+= 4;\
-        cur += 4;\
-        next+= 4;\
-    }
-
-    if(parity){
-#define prev2 "prev"
-#define next2 "cur"
-        FILTER
-#undef prev2
-#undef next2
-    }else{
-#define prev2 "cur"
-#define next2 "next"
-        FILTER
-#undef prev2
-#undef next2
-    }
-}
-#undef LOAD4
-#undef PABS
-#undef CHECK
-#undef CHECK1
-#undef CHECK2
-#undef FILTER
-#endif
-
-
-

Deleted: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters/Yadif/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters/Yadif/CMakeLists.txt	2010-10-28 05:54:52 UTC (rev 6719)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters/Yadif/CMakeLists.txt	2010-10-28 05:54:53 UTC (rev 6720)
@@ -1,9 +0,0 @@
-INCLUDE(vf_plugin)
-
-
-SET(ADM_vf_yadif_SRCS ADM_vidYadif_asm.c  ADM_vidYadif.cpp )
-
-ADD_LIBRARY(ADM_vf_yadif SHARED ${ADM_vf_yadif_SRCS})
-
-INIT_VIDEOFILTER_PLUGIN(ADM_vf_yadif)
-INSTALL_VIDEOFILTER(ADM_vf_yadif)



From mean at mail.berlios.de  Thu Oct 28 08:01:40 2010
From: mean at mail.berlios.de (mean at mail.berlios.de)
Date: Thu, 28 Oct 2010 08:01:40 +0200
Subject: [Avidemux-svn-commit] r6721 -
	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/colorYUV
Message-ID: <20101028060140.B8669480FA4@sheep.berlios.de>

Author: mean
Date: 2010-10-28 08:01:40 +0200 (Thu, 28 Oct 2010)
New Revision: 6721

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/colorYUV/ADM_vidColorYuv.cpp
Log:
[ColorYuv] Fix ranges for parameters

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/colorYUV/ADM_vidColorYuv.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/colorYUV/ADM_vidColorYuv.cpp	2010-10-28 05:54:53 UTC (rev 6720)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_videoFilters6/colorYUV/ADM_vidColorYuv.cpp	2010-10-28 06:01:40 UTC (rev 6721)
@@ -86,34 +86,34 @@
 
 // --- Tab 2 ----
 
-    diaElemFloat        yGain(PX(y_gain),QT_TR_NOOP("Y gain"),0,100,NULL,3);
-    diaElemFloat        yBright(PX(y_bright),QT_TR_NOOP("Y Brightness"),0,100,NULL,3);
-    diaElemFloat        yGamma(PX(y_gamma),QT_TR_NOOP("Y Gamma"),0,100,NULL,3);
-    diaElemFloat        yContrast(PX(y_contrast),QT_TR_NOOP("Y Contrast"),0,100,NULL,3);
+    diaElemFloat        yGain(PX(y_gain),QT_TR_NOOP("Y gain"),0,256*3,NULL,3);
+    diaElemFloat        yBright(PX(y_bright),QT_TR_NOOP("Y Brightness"),0,256*3,NULL,3);
+    diaElemFloat        yGamma(PX(y_gamma),QT_TR_NOOP("Y Gamma"),0,256*2,NULL,3);
+    diaElemFloat        yContrast(PX(y_contrast),QT_TR_NOOP("Y Contrast"),-256*3,256*3,NULL,3);
  
     diaElem *dia2[]={&yGain,&yBright,&yGamma,&yContrast};
 // --- Tab 3 ----
 
-    diaElemFloat        uGain(PX(u_gain),QT_TR_NOOP("U gain"),0,100,NULL,3);
-    diaElemFloat        uBright(PX(u_bright),QT_TR_NOOP("U Brightness"),0,100,NULL,3);
-    diaElemFloat        uGamma(PX(u_gamma),QT_TR_NOOP("U Gamma"),0,100,NULL,3);
-    diaElemFloat        uContrast(PX(u_contrast),QT_TR_NOOP("U Contrast"),0,100,NULL,3);
+    diaElemFloat        uGain(PX(u_gain),QT_TR_NOOP("U gain"),0,256*3,NULL,3);
+    diaElemFloat        uBright(PX(u_bright),QT_TR_NOOP("U Brightness"),0,256*3,NULL,3);
+    //diaElemFloat        uGamma(PX(u_gamma),QT_TR_NOOP("U Gamma"),0,100,NULL,3);
+    diaElemFloat        uContrast(PX(u_contrast),QT_TR_NOOP("U Contrast"),-256*3,256*3,NULL,3);
  
-    diaElem *dia3[]={&uGain,&uBright,&uGamma,&uContrast};
+    diaElem *dia3[]={&uGain,&uBright,&uContrast};
 
 // --- Tab 4 ----
 
-    diaElemFloat        vGain(PX(u_gain),QT_TR_NOOP("V gain"),0,100,NULL,3);
-    diaElemFloat        vBright(PX(u_bright),QT_TR_NOOP("V Brightness"),0,100,NULL,3);
-    diaElemFloat        vGamma(PX(u_gamma),QT_TR_NOOP("V Gamma"),0,100,NULL,3);
-    diaElemFloat        vContrast(PX(u_contrast),QT_TR_NOOP("V Contrast"),0,100,NULL,3);
+    diaElemFloat        vGain(PX(u_gain),QT_TR_NOOP("V gain"),0,256*3,NULL,3);
+    diaElemFloat        vBright(PX(u_bright),QT_TR_NOOP("V Brightness"),0,256*3,NULL,3);
+    //diaElemFloat        vGamma(PX(u_gamma),QT_TR_NOOP("V Gamma"),0,100,NULL,3);
+    diaElemFloat        vContrast(PX(u_contrast),QT_TR_NOOP("V Contrast"),-256*3,256*3,NULL,3);
  
-    diaElem *dia4[]={&vGain,&vBright,&vGamma,&vContrast};
+    diaElem *dia4[]={&vGain,&vBright,&vContrast};
 //
     diaElemTabs tab1(QT_TR_NOOP("Flags"),4,dia1);
     diaElemTabs tab2(QT_TR_NOOP("Y"),4,dia2);
-    diaElemTabs tab3(QT_TR_NOOP("U"),4,dia3);
-    diaElemTabs tab4(QT_TR_NOOP("V"),4,dia4);
+    diaElemTabs tab3(QT_TR_NOOP("U"),3,dia3);
+    diaElemTabs tab4(QT_TR_NOOP("V"),3,dia4);
     
     diaElemTabs *tabs[]={&tab1,&tab2,&tab3,&tab4};
     if( diaFactoryRunTabs(QT_TR_NOOP("colorYuv"),4,tabs))



