<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Avidemux-svn-commit] r5080 - in branches/avidemux_2.6_branch_mean:	avidemux/common/ADM_audiocodec avidemux_core/ADM_coreAudio/include	avidemux_plugins/ADM_audioDecoders	avidemux_plugins/ADM_audioDecoders/ADM_ad_ima_adpcm	avidemux_plugins/ADM_audioDecoders/ADM_ad_ms_adpcm	avidemux_plugins/ADM_audioDecoders/ADM_ad_ulaw
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/avidemux-svn-commit/2009-July/index.html" >
   <LINK REL="made" HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r5080%20-%20in%20branches/avidemux_2.6_branch_mean%3A%0A%09avidemux/common/ADM_audiocodec%20avidemux_core/ADM_coreAudio/include%0A%09avidemux_plugins/ADM_audioDecoders%0A%09avidemux_plugins/ADM_audioDecoders/ADM_ad_ima_adpcm%0A%09avidemux_plugins/ADM_audioDecoders/ADM_ad_ms_adpcm%0A%09avidemux_plugins/ADM_audioDecoders/ADM_ad_ulaw&In-Reply-To=%3C200907130856.n6D8urSf004951%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="002294.html">
   <LINK REL="Next"  HREF="002296.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Avidemux-svn-commit] r5080 - in branches/avidemux_2.6_branch_mean:	avidemux/common/ADM_audiocodec avidemux_core/ADM_coreAudio/include	avidemux_plugins/ADM_audioDecoders	avidemux_plugins/ADM_audioDecoders/ADM_ad_ima_adpcm	avidemux_plugins/ADM_audioDecoders/ADM_ad_ms_adpcm	avidemux_plugins/ADM_audioDecoders/ADM_ad_ulaw</H1>
    <B>mean at BerliOS</B> 
    <A HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r5080%20-%20in%20branches/avidemux_2.6_branch_mean%3A%0A%09avidemux/common/ADM_audiocodec%20avidemux_core/ADM_coreAudio/include%0A%09avidemux_plugins/ADM_audioDecoders%0A%09avidemux_plugins/ADM_audioDecoders/ADM_ad_ima_adpcm%0A%09avidemux_plugins/ADM_audioDecoders/ADM_ad_ms_adpcm%0A%09avidemux_plugins/ADM_audioDecoders/ADM_ad_ulaw&In-Reply-To=%3C200907130856.n6D8urSf004951%40sheep.berlios.de%3E"
       TITLE="[Avidemux-svn-commit] r5080 - in branches/avidemux_2.6_branch_mean:	avidemux/common/ADM_audiocodec avidemux_core/ADM_coreAudio/include	avidemux_plugins/ADM_audioDecoders	avidemux_plugins/ADM_audioDecoders/ADM_ad_ima_adpcm	avidemux_plugins/ADM_audioDecoders/ADM_ad_ms_adpcm	avidemux_plugins/ADM_audioDecoders/ADM_ad_ulaw">mean at mail.berlios.de
       </A><BR>
    <I>Mon Jul 13 10:56:53 CEST 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="002294.html">[Avidemux-svn-commit] r5079 -	branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audiocodec
</A></li>
        <LI>Next message: <A HREF="002296.html">[Avidemux-svn-commit] r5081 -	branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audiocodec
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2295">[ date ]</a>
              <a href="thread.html#2295">[ thread ]</a>
              <a href="subject.html#2295">[ subject ]</a>
              <a href="author.html#2295">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: mean
Date: 2009-07-13 10:56:52 +0200 (Mon, 13 Jul 2009)
New Revision: 5080

Added:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDecoders/ADM_ad_ima_adpcm/
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDecoders/ADM_ad_ima_adpcm/ADM_ad_ima_adpcm.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDecoders/ADM_ad_ima_adpcm/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDecoders/ADM_ad_ms_adpcm/
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDecoders/ADM_ad_ms_adpcm/ADM_ad_ms_adpcm.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDecoders/ADM_ad_ms_adpcm/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDecoders/ADM_ad_ulaw/
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDecoders/ADM_ad_ulaw/ADM_ad_ulaw.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDecoders/ADM_ad_ulaw/CMakeLists.txt
Removed:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audiocodec/ADM_codecimaadpcm.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audiocodec/ADM_codecmsadpcm.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audiocodec/ADM_codeculaw.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audiocodec/ADM_codecwma.cpp
Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audiocodec/ADM_audiocodec.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audiocodec/ADM_audiocodec.h
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audiocodec/ADM_pluginLoad.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audiocodec/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreAudio/include/ADM_audioCodecEnum.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreAudio/include/ADM_baseAudioStream.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDecoders/CMakeLists.txt
Log:
[AudioDecoder] Pluginify adpcm (ms+ima), ulaw (not working)

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audiocodec/ADM_audiocodec.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audiocodec/ADM_audiocodec.cpp	2009-07-13 08:56:50 UTC (rev 5079)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audiocodec/ADM_audiocodec.cpp	2009-07-13 08:56:52 UTC (rev 5080)
@@ -44,7 +44,7 @@
                                         printf(&quot;\n Audio codec:  NELLYMOSER\n&quot;);
                                         out= (ADM_Audiocodec *)new ADM_AudiocodecWMA(fourcc,info,extra,extraData);
                                         break;
-#endif
+
                                 case WAV_IMAADPCM:
                                         printf(&quot;\n Audio codec:  IMA MS ADPCM\n&quot;);
                                         out= (ADM_Audiocodec *)new ADM_AudiocodecImaAdpcm(fourcc,info);
@@ -53,6 +53,7 @@
                                         printf(&quot;\n Audio codec:   MS ADPCM\n&quot;);
                                         out= (ADM_Audiocodec *)new ADM_AudiocodecMsAdpcm(fourcc,info);
                                         break;
+#endif
 				case WAV_PCM:
     					printf(&quot;\n Audio codec:  WAV\n&quot;);
 #ifdef ADM_BIG_ENDIAN
@@ -87,11 +88,12 @@
 
 					break;
 #endif
+#if 0
 				case WAV_ULAW:
 						printf(&quot;\n ULAW codec\n&quot;);
 						out=(ADM_Audiocodec *) new ADM_AudiocodecUlaw(fourcc,info);
 						break;
-#if 0
+
             case WAV_AMV_ADPCM:
                 printf(&quot;\n Audio codec:  ffAMV\n&quot;);
                 out= (ADM_Audiocodec *) new ADM_AudiocodecWMA(fourcc,info,extra,extraData);

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audiocodec/ADM_audiocodec.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audiocodec/ADM_audiocodec.h	2009-07-13 08:56:50 UTC (rev 5079)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audiocodec/ADM_audiocodec.h	2009-07-13 08:56:52 UTC (rev 5080)
@@ -95,51 +95,7 @@
 		virtual	uint8_t run(uint8_t *inptr, uint32_t nbIn, float *outptr, uint32_t *nbOut);
 		virtual	uint8_t isCompressed(void) {return 1;}
 };
- class ADM_AudiocodecUlaw : public     ADM_Audiocodec
- {
- 	public:
-		ADM_AudiocodecUlaw(uint32_t fourcc, WAVHeader *info);
-		virtual	~ADM_AudiocodecUlaw() ;
-		virtual	uint8_t beginDecompress(void) {return 1;}
-		virtual	uint8_t endDecompress(void) {return 1;}
-		virtual	uint8_t run(uint8_t *inptr, uint32_t nbIn, float *outptr, uint32_t *nbOut);
-		virtual	uint8_t isCompressed(void) {return 1;}
-};
 
-#define IMA_BUFFER 4096*8
-class ADM_AudiocodecImaAdpcm : public     ADM_Audiocodec
-{
-	protected:
-		uint32_t _inStock,_me,_channels;
-		int ss_div,ss_mul; // ???
-		void *_contextVoid;
-		uint8_t _buffer[ IMA_BUFFER];
-		uint32_t _head,_tail;
 
-	public:
-		ADM_AudiocodecImaAdpcm(uint32_t fourcc, WAVHeader *info);
-		virtual	~ADM_AudiocodecImaAdpcm();
-		virtual	uint8_t beginDecompress(void) {_head=_tail=0;return 1;}
-		virtual	uint8_t endDecompress(void) {_head=_tail=0;return 1;}
-		virtual	uint8_t run(uint8_t *inptr, uint32_t nbIn, float *outptr, uint32_t *nbOut);
-		virtual	uint8_t isCompressed(void) {return 1;}
-};
-class ADM_AudiocodecMsAdpcm : public     ADM_Audiocodec
-{
-	protected:
-		uint32_t _inStock,_me,_channels;
-		int ss_div,ss_mul; // ???
-		void *_contextVoid;
-		uint8_t _buffer[ IMA_BUFFER];
-		uint32_t _head,_tail;
 
-	public:
-		ADM_AudiocodecMsAdpcm(uint32_t fourcc, WAVHeader *info);
-		virtual	~ADM_AudiocodecMsAdpcm();
-		virtual	uint8_t beginDecompress(void) {_head=_tail=0;return 1;}
-		virtual	uint8_t endDecompress(void) {_head=_tail=0;return 1;}
-		virtual	uint8_t run(uint8_t *inptr, uint32_t nbIn, float *outptr, uint32_t *nbOut);
-		virtual	uint8_t isCompressed(void) {return 1;}
-};
-
 #endif

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audiocodec/ADM_codecimaadpcm.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audiocodec/ADM_codecimaadpcm.cpp	2009-07-13 08:56:50 UTC (rev 5079)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audiocodec/ADM_codecimaadpcm.cpp	2009-07-13 08:56:52 UTC (rev 5080)
@@ -1,451 +0,0 @@
-/*
-    IMA ADPCM Decoder for MPlayer
-      by Mike Melanson
-
-    This file is in charge of decoding all of the various IMA ADPCM data
-    formats that various entities have created. Details about the data
-    formats can be found here:
-      <A HREF="http://www.pcisys.net/~melanson/codecs/">http://www.pcisys.net/~melanson/codecs/</A>
-
-    So far, this file handles these formats:
-      'ima4': IMA ADPCM found in QT files
-        0x11: IMA ADPCM found in MS AVI/ASF/WAV files
-        0x61: DK4 ADPCM found in certain AVI files on Sega Saturn CD-ROMs;
-              note that this is a 'rogue' format number in that it was
-              never officially registered with Microsoft
-    0x1100736d: IMA ADPCM coded like in MS AVI/ASF/WAV found in QT files
-*/
-
-
-#define ADM_NO_CONFIG_H
-#include &quot;ADM_default.h&quot;
-#include &quot;ADM_ffmpeg/libavutil/bswap.h&quot;
-
-#include &quot;ADM_assert.h&quot;
-#include &quot;ADM_coreAudio.h&quot;
-#include &quot;ADM_audiocodec.h&quot;
-
-
-
-#define MS_IMA_ADPCM_PREAMBLE_SIZE 4
-
-#define QT_IMA_ADPCM_PREAMBLE_SIZE 2
-#define QT_IMA_ADPCM_BLOCK_SIZE 0x22
-#define QT_IMA_ADPCM_SAMPLES_PER_BLOCK 64
-
-#define BE_16(x) (be2me_16(*(unsigned short *)(x)))
-#define BE_32(x) (be2me_32(*(unsigned int *)(x)))
-#define LE_16(x) (le2me_16(*(unsigned short *)(x)))
-#define LE_32(x) (le2me_32(*(unsigned int *)(x)))
-
-int ms_ima_adpcm_decode_block(unsigned short *output,
-  unsigned char *input, int channels, int block_size);
-#if 0
-int dk4_ima_adpcm_decode_block(unsigned short *output,
-  unsigned char *input, int channels, int block_size);
-int qt_ima_adpcm_decode_block(unsigned short *output,
-  unsigned char *input, int channels);
-#endif
-
-
-
-// pertinent tables for IMA ADPCM
-static int adpcm_step[89] =
-{
-  7, 8, 9, 10, 11, 12, 13, 14, 16, 17,
-  19, 21, 23, 25, 28, 31, 34, 37, 41, 45,
-  50, 55, 60, 66, 73, 80, 88, 97, 107, 118,
-  130, 143, 157, 173, 190, 209, 230, 253, 279, 307,
-  337, 371, 408, 449, 494, 544, 598, 658, 724, 796,
-  876, 963, 1060, 1166, 1282, 1411, 1552, 1707, 1878, 2066,
-  2272, 2499, 2749, 3024, 3327, 3660, 4026, 4428, 4871, 5358,
-  5894, 6484, 7132, 7845, 8630, 9493, 10442, 11487, 12635, 13899,
-  15289, 16818, 18500, 20350, 22385, 24623, 27086, 29794, 32767
-};
-
-static int adpcm_index[16] =
-{
-  -1, -1, -1, -1, 2, 4, 6, 8,
-  -1, -1, -1, -1, 2, 4, 6, 8
-};
-
-// useful macros
-// clamp a number between 0 and 88
-#define CLAMP_0_TO_88(x)  if (x &lt; 0) x = 0; else if (x &gt; 88) x = 88;
-// clamp a number within a signed 16-bit range
-#define CLAMP_S16(x)  if (x &lt; -32768) x = -32768; \
-  else if (x &gt; 32767) x = 32767;
-// clamp a number above 16
-#define CLAMP_ABOVE_16(x)  if (x &lt; 16) x = 16;
-// sign extend a 16-bit value
-#define SE_16BIT(x)  if (x &amp; 0x8000) x -= 0x10000;
-// sign extend a 4-bit value
-#define SE_4BIT(x)  if (x &amp; 0x8) x -= 0x10;
-
-// static ad_info_t info = 
-// {
-// 	&quot;IMA ADPCM audio decoder&quot;,
-// 	&quot;imaadpcm&quot;,
-// 	&quot;Nick Kurshev&quot;,
-// 	&quot;Mike Melanson&quot;,
-// 	&quot;&quot;
-// };
-
-ADM_AudiocodecImaAdpcm::ADM_AudiocodecImaAdpcm( uint32_t fourcc ,WAVHeader *info)
-        : ADM_Audiocodec(fourcc)
-{
-        _me=info-&gt;encoding;
-        _channels=info-&gt;channels;
-
-         if ((info-&gt;encoding == WAV_IMAADPCM) || (info-&gt;encoding == 0x61) 
-        //||      (info-&gt;encoding == (uint16_t)0x1100736d)
-        )
-  {
-     ss_div = info-&gt;blockalign -
-      (MS_IMA_ADPCM_PREAMBLE_SIZE * info-&gt;channels) * 2;
-     ss_mul = info-&gt;blockalign;
-  }
-  else
-  {
-    ss_div = QT_IMA_ADPCM_SAMPLES_PER_BLOCK;
-    ss_mul = QT_IMA_ADPCM_BLOCK_SIZE * info-&gt;channels;
-  }
-  //sh_audio-&gt;audio_in_minsize=sss_mul;
-  _tail=_head=0;
-  printf(&quot;Block size: %d\n&quot;,ss_mul);
-}
-ADM_AudiocodecImaAdpcm::~ADM_AudiocodecImaAdpcm()
-{
-
-}
-
-uint8_t ADM_AudiocodecImaAdpcm::run(uint8_t *inptr, uint32_t nbIn, float *outptr, uint32_t *nbOut)
-{
-int produced=0,one;
-uint8_t  *start;
-int16_t *run16;
-// Add to buffer
-  
-  ADM_assert((_tail+nbIn)&lt;IMA_BUFFER);
-  memcpy(&amp;(_buffer[_tail]),inptr,nbIn);
-  _tail+=nbIn;
-  *nbOut=0;
-
-  if((_tail-_head)&lt;ss_mul) 
-        return 0;
-
-
-  if ((_me== WAV_IMAADPCM))// || (sh_audio-&gt;format == 0x1100736d))
-  {
-        while((_tail-_head)&gt;=ss_mul)
-        {
-                start=(uint8_t *)&amp;(_buffer[_head]);
-                one=  ms_ima_adpcm_decode_block(
-                        (unsigned short *)scratchPad,start,_channels , ss_mul);
-                _head+=ss_mul;
-                produced+=one;
-                run16=(int16_t *)scratchPad;
-                for(int i=0;i&lt;one;i++)
-                {
-                  *outptr++=((float)run16[i])/32767.;
-                }
-        }
-        if(_tail&gt;IMA_BUFFER/2 &amp;&amp; _head)
-        {
-                memmove(_buffer,&amp;_buffer[_head],_tail-_head);
-                _tail-=_head;
-                _head=0;
-        }
-        *nbOut=produced;
-        return 1;
-  }
-#if 0
-  else if (_me == 0x61)
-  {
-    return 2 * dk4_ima_adpcm_decode_block(
-      (unsigned short*)outptr, ptr, _channels,  ss_mul);
-  }
-  else
-  {
-    return 2 * qt_ima_adpcm_decode_block(
-      (unsigned short*)outptr, ptr, _channels);
-  }
-#endif
-        return 0;
-}
-#if 0
-static int preinit(sh_audio_t *sh_audio)
-{
-  // not exactly sure what this field is for
-  sh_audio-&gt;audio_out_minsize = 8192;
-
-  // if format is &quot;ima4&quot;, assume the audio is coming from a QT file which
-  // indicates constant block size, whereas an AVI/ASF/WAV file will fill
-  // in this field with 0x11
-  if ((sh_audio-&gt;format == 0x11) || (sh_audio-&gt;format == 0x61) ||
-      (sh_audio-&gt;format == 0x1100736d))
-  {
-    sh_audio-&gt;ds-&gt;ss_div = (sh_audio-&gt;wf-&gt;nBlockAlign - 
-      (MS_IMA_ADPCM_PREAMBLE_SIZE * sh_audio-&gt;wf-&gt;nChannels)) * 2;
-    sh_audio-&gt;ds-&gt;ss_mul = sh_audio-&gt;wf-&gt;nBlockAlign;
-  }
-  else
-  {
-    sh_audio-&gt;ds-&gt;ss_div = QT_IMA_ADPCM_SAMPLES_PER_BLOCK;
-    sh_audio-&gt;ds-&gt;ss_mul = QT_IMA_ADPCM_BLOCK_SIZE * sh_audio-&gt;wf-&gt;nChannels;
-  }
-  sh_audio-&gt;audio_in_minsize=sh_audio-&gt;ds-&gt;ss_mul;
-  return 1;
-}
-#endif
-
-static void decode_nibbles(unsigned short *output,
-  int output_size, int channels,
-  int predictor_l, int index_l,
-  int predictor_r, int index_r)
-{
-  int step[2];
-  int predictor[2];
-  int index[2];
-  int diff;
-  int i;
-  int sign;
-  int delta;
-  int channel_number = 0;
-
-  step[0] = adpcm_step[index_l];
-  step[1] = adpcm_step[index_r];
-  predictor[0] = predictor_l;
-  predictor[1] = predictor_r;
-  index[0] = index_l;
-  index[1] = index_r;
-
-  for (i = 0; i &lt; output_size; i++)
-  {
-    delta = output[i];
-
-    index[channel_number] += adpcm_index[delta];
-    CLAMP_0_TO_88(index[channel_number]);
-
-    sign = delta &amp; 8;
-    delta = delta &amp; 7;
-
-    diff = step[channel_number] &gt;&gt; 3;
-    if (delta &amp; 4) diff += step[channel_number];
-    if (delta &amp; 2) diff += step[channel_number] &gt;&gt; 1;
-    if (delta &amp; 1) diff += step[channel_number] &gt;&gt; 2;
-
-    if (sign)
-      predictor[channel_number] -= diff;
-    else
-      predictor[channel_number] += diff;
-
-    CLAMP_S16(predictor[channel_number]);
-    output[i] = predictor[channel_number];
-    step[channel_number] = adpcm_step[index[channel_number]];
-
-    // toggle channel
-    channel_number ^= channels - 1;
-
-  }
-}
-
-#if 0
-int qt_ima_adpcm_decode_block(unsigned short *output,
-  unsigned char *input, int channels)
-{
-  int initial_predictor_l = 0;
-  int initial_predictor_r = 0;
-  int initial_index_l = 0;
-  int initial_index_r = 0;
-  int i;
-
-  initial_predictor_l = BE_16(&amp;input[0]);
-  initial_index_l = initial_predictor_l;
-
-  // mask, sign-extend, and clamp the predictor portion
-  initial_predictor_l &amp;= 0xFF80;
-  SE_16BIT(initial_predictor_l);
-  CLAMP_S16(initial_predictor_l);
-
-  // mask and clamp the index portion
-  initial_index_l &amp;= 0x7F;
-  CLAMP_0_TO_88(initial_index_l);
-
-  // handle stereo
-  if (channels &gt; 1)
-  {
-    initial_predictor_r = BE_16(&amp;input[QT_IMA_ADPCM_BLOCK_SIZE]);
-    initial_index_r = initial_predictor_r;
-
-    // mask, sign-extend, and clamp the predictor portion
-    initial_predictor_r &amp;= 0xFF80;
-    SE_16BIT(initial_predictor_r);
-    CLAMP_S16(initial_predictor_r);
-
-    // mask and clamp the index portion
-    initial_index_r &amp;= 0x7F;
-    CLAMP_0_TO_88(initial_index_r);
-  }
-
-  // break apart all of the nibbles in the block
-  if (channels == 1)
-    for (i = 0; i &lt; QT_IMA_ADPCM_SAMPLES_PER_BLOCK / 2; i++)
-    {
-      output[i * 2 + 0] = input[2 + i] &amp; 0x0F;
-      output[i * 2 + 1] = input[2 + i] &gt;&gt; 4;
-    }
-  else
-    for (i = 0; i &lt; QT_IMA_ADPCM_SAMPLES_PER_BLOCK / 2 * 2; i++)
-    {
-      output[i * 4 + 0] = input[2 + i] &amp; 0x0F;
-      output[i * 4 + 1] = input[2 + QT_IMA_ADPCM_BLOCK_SIZE + i] &amp; 0x0F;
-      output[i * 4 + 2] = input[2 + i] &gt;&gt; 4;
-      output[i * 4 + 3] = input[2 + QT_IMA_ADPCM_BLOCK_SIZE + i] &gt;&gt; 4;
-    }
-
-  decode_nibbles(output,
-    QT_IMA_ADPCM_SAMPLES_PER_BLOCK * channels, channels,
-    initial_predictor_l, initial_index_l,
-    initial_predictor_r, initial_index_r);
-
-  return QT_IMA_ADPCM_SAMPLES_PER_BLOCK * channels;
-}
-#endif
-
-int ms_ima_adpcm_decode_block(unsigned short *output,
-  unsigned char *input, int channels, int block_size)
-{
-  int predictor_l = 0;
-  int predictor_r = 0;
-  int index_l = 0;
-  int index_r = 0;
-  int i;
-  int channel_counter;
-  int channel_index;
-  int channel_index_l;
-  int channel_index_r;
-
-  predictor_l = LE_16(&amp;input[0]);
-  SE_16BIT(predictor_l);
-  index_l = input[2];
-  if (channels == 2)
-  {
-    predictor_r = LE_16(&amp;input[4]);
-    SE_16BIT(predictor_r);
-    index_r = input[6];
-  }
-
-  if (channels == 1)
-    for (i = 0;
-      i &lt; (block_size - MS_IMA_ADPCM_PREAMBLE_SIZE * channels); i++)
-    {
-      output[i * 2 + 0] = input[MS_IMA_ADPCM_PREAMBLE_SIZE + i] &amp; 0x0F;
-      output[i * 2 + 1] = input[MS_IMA_ADPCM_PREAMBLE_SIZE + i] &gt;&gt; 4;
-    }
-  else
-  {
-    // encoded as 8 nibbles (4 bytes) per channel; switch channel every
-    // 4th byte
-    channel_counter = 0;
-    channel_index_l = 0;
-    channel_index_r = 1;
-    channel_index = channel_index_l;
-    for (i = 0;
-      i &lt; (block_size - MS_IMA_ADPCM_PREAMBLE_SIZE * channels); i++)
-    {
-      output[channel_index + 0] =
-        input[MS_IMA_ADPCM_PREAMBLE_SIZE * 2 + i] &amp; 0x0F;
-      output[channel_index + 2] =
-        input[MS_IMA_ADPCM_PREAMBLE_SIZE * 2 + i] &gt;&gt; 4;
-      channel_index += 4;
-      channel_counter++;
-      if (channel_counter == 4)
-      {
-        channel_index_l = channel_index;
-        channel_index = channel_index_r;
-      }
-      else if (channel_counter == 8)
-      {
-        channel_index_r = channel_index;
-        channel_index = channel_index_l;
-        channel_counter = 0;
-      }
-    }
-  }
-  
-  decode_nibbles(output,
-    (block_size - MS_IMA_ADPCM_PREAMBLE_SIZE * channels) * 2,
-    channels,
-    predictor_l, index_l,
-    predictor_r, index_r);
-
-  return (block_size - MS_IMA_ADPCM_PREAMBLE_SIZE * channels) * 2;
-}
-#if 0
-int dk4_ima_adpcm_decode_block(unsigned short *output,
-  unsigned char *input, int channels, int block_size)
-{
-  int i;
-  int output_ptr;
-  int predictor_l = 0;
-  int predictor_r = 0;
-  int index_l = 0;
-  int index_r = 0;
-
-  // the first predictor value goes straight to the output
-  predictor_l = output[0] = LE_16(&amp;input[0]);
-  SE_16BIT(predictor_l);
-  index_l = input[2];
-  if (channels == 2)
-  {
-    predictor_r = output[1] = LE_16(&amp;input[4]);
-    SE_16BIT(predictor_r);
-    index_r = input[6];
-  }
-
-  output_ptr = channels;
-  for (i = MS_IMA_ADPCM_PREAMBLE_SIZE * channels; i &lt; block_size; i++)
-  {
-    output[output_ptr++] = input[i] &gt;&gt; 4;
-    output[output_ptr++] = input[i] &amp; 0x0F;
-  }
-
-  decode_nibbles(&amp;output[channels],
-    (block_size - MS_IMA_ADPCM_PREAMBLE_SIZE * channels) * 2 - channels,
-    channels,
-    predictor_l, index_l,
-    predictor_r, index_r);
-
-  return (block_size - MS_IMA_ADPCM_PREAMBLE_SIZE * channels) * 2 - channels;
-}
-#endif
-/********************************************************************************/
-/********************************************************************************/
-#if 0
-static int decode_audio(sh_audio_t *sh_audio,unsigned char *buf,int minlen,int maxlen)
-{
-  if (demux_read_data(sh_audio-&gt;ds, sh_audio-&gt;a_in_buffer,
-    sh_audio-&gt;ds-&gt;ss_mul) != 
-    sh_audio-&gt;ds-&gt;ss_mul) 
-    return -1;
-
-  if ((sh_audio-&gt;format == 0x11) || (sh_audio-&gt;format == 0x1100736d))
-  {
-    return 2 * ms_ima_adpcm_decode_block(
-      (unsigned short*)buf, sh_audio-&gt;a_in_buffer, sh_audio-&gt;wf-&gt;nChannels,
-      sh_audio-&gt;ds-&gt;ss_mul);
-  }
-  else if (sh_audio-&gt;format == 0x61)
-  {
-    return 2 * dk4_ima_adpcm_decode_block(
-      (unsigned short*)buf, sh_audio-&gt;a_in_buffer, sh_audio-&gt;wf-&gt;nChannels,
-      sh_audio-&gt;ds-&gt;ss_mul);
-  }
-  else
-  {
-    return 2 * qt_ima_adpcm_decode_block(
-      (unsigned short*)buf, sh_audio-&gt;a_in_buffer, sh_audio-&gt;wf-&gt;nChannels);
-  }
-}
-#endif

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audiocodec/ADM_codecmsadpcm.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audiocodec/ADM_codecmsadpcm.cpp	2009-07-13 08:56:50 UTC (rev 5079)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audiocodec/ADM_codecmsadpcm.cpp	2009-07-13 08:56:52 UTC (rev 5080)
@@ -1,223 +0,0 @@
-/*
-    MS ADPCM Decoder for MPlayer
-      by Mike Melanson
-
-    This file is responsible for decoding Microsoft ADPCM data.
-    Details about the data format can be found here:
-      <A HREF="http://www.pcisys.net/~melanson/codecs/">http://www.pcisys.net/~melanson/codecs/</A>
-      
-      &quot;Nick Kurshev&quot;,
-	&quot;Mike Melanson&quot;,
-
-      
-*/
-
-#include &quot;ADM_default.h&quot;
-#define ADM_NO_CONFIG_H
-#include &quot;ADM_coreAudio.h&quot;
-#include &quot;ADM_audiocodec.h&quot;
-
-static int ms_adapt_table[] =
-{
-  230, 230, 230, 230, 307, 409, 512, 614,
-  768, 614, 512, 409, 307, 230, 230, 230
-};
-
-static int ms_adapt_coeff1[] =
-{
-  256, 512, 0, 192, 240, 460, 392
-};
-
-static int ms_adapt_coeff2[] =
-{
-  0, -256, 0, 64, 0, -208, -232
-};
-
-#define MS_ADPCM_PREAMBLE_SIZE 6
-
-#define LE_16(x) ((x)[0]+(256*((x)[1])))
-//#define LE_16(x) (le2me_16((x)[1]+(256*((x)[0]))))
-//#define LE_16(x) (le2me_16(*(unsigned short *)(x)))
-//#define LE_32(x) (le2me_32(*(unsigned int *)(x)))
-
-// useful macros
-// clamp a number between 0 and 88
-#define CLAMP_0_TO_88(x)  if (x &lt; 0) x = 0; else if (x &gt; 88) x = 88;
-// clamp a number within a signed 16-bit range
-#define CLAMP_S16(x)  if (x &lt; -32768) x = -32768; \
-  else if (x &gt; 32767) x = 32767;
-// clamp a number above 16
-#define CLAMP_ABOVE_16(x)  if (x &lt; 16) x = 16;
-// sign extend a 16-bit value
-#define SE_16BIT(x)  if (x &amp; 0x8000) x -= 0x10000;
-// sign extend a 4-bit value
-#define SE_4BIT(x)  if (x &amp; 0x8) x -= 0x10;
-
-static int ms_adpcm_decode_block(unsigned short *output, unsigned char *input,
-  int channels, int block_size)
-{
-  int current_channel = 0;
-  int idelta[2];
-  int sample1[2];
-  int sample2[2];
-  int coeff1[2];
-  int coeff2[2];
-  int stream_ptr = 0;
-  int out_ptr = 0;
-  int upper_nibble = 1;
-  int nibble;
-  int snibble;  // signed nibble
-  int predictor;
-
-  // fetch the header information, in stereo if both channels are present
-  if (input[stream_ptr] &gt; 6)
-    printf( &quot;MS ADPCM: coefficient (%d) out of range (should be [0..6])\n&quot;,
-      input[stream_ptr]);
-  coeff1[0] = ms_adapt_coeff1[input[stream_ptr]];
-  coeff2[0] = ms_adapt_coeff2[input[stream_ptr]];
-  stream_ptr++;
-  if (channels == 2)
-  {
-    if (input[stream_ptr] &gt; 6)
-     printf( &quot;MS ADPCM: coefficient (%d) out of range (should be [0..6])\n&quot;,
-       input[stream_ptr]);
-    coeff1[1] = ms_adapt_coeff1[input[stream_ptr]];
-    coeff2[1] = ms_adapt_coeff2[input[stream_ptr]];
-    stream_ptr++;
-  }
-
-  idelta[0] = LE_16(&amp;input[stream_ptr]);
-  stream_ptr += 2;
-  SE_16BIT(idelta[0]);
-  if (channels == 2)
-  {
-    idelta[1] = LE_16(&amp;input[stream_ptr]);
-    stream_ptr += 2;
-    SE_16BIT(idelta[1]);
-  }
-
-  sample1[0] = LE_16(&amp;input[stream_ptr]);
-  stream_ptr += 2;
-  SE_16BIT(sample1[0]);
-  if (channels == 2)
-  {
-    sample1[1] = LE_16(&amp;input[stream_ptr]);
-    stream_ptr += 2;
-    SE_16BIT(sample1[1]);
-  }
-
-  sample2[0] = LE_16(&amp;input[stream_ptr]);
-  stream_ptr += 2;
-  SE_16BIT(sample2[0]);
-  if (channels == 2)
-  {
-    sample2[1] = LE_16(&amp;input[stream_ptr]);
-    stream_ptr += 2;
-    SE_16BIT(sample2[1]);
-  }
-
-  if (channels == 1)
-  {
-    output[out_ptr++] = sample2[0];
-    output[out_ptr++] = sample1[0];
-  } else {
-    output[out_ptr++] = sample2[0];
-    output[out_ptr++] = sample2[1];
-    output[out_ptr++] = sample1[0];
-    output[out_ptr++] = sample1[1];
-  }
-
-  while (stream_ptr &lt; block_size)
-  {
-    // get the next nibble
-    if (upper_nibble)
-      nibble = snibble = input[stream_ptr] &gt;&gt; 4;
-    else
-      nibble = snibble = input[stream_ptr++] &amp; 0x0F;
-    upper_nibble ^= 1;
-    SE_4BIT(snibble);
-
-    predictor = (
-      ((sample1[current_channel] * coeff1[current_channel]) +
-       (sample2[current_channel] * coeff2[current_channel])) / 256) +
-      (snibble * idelta[current_channel]);
-    CLAMP_S16(predictor);
-    sample2[current_channel] = sample1[current_channel];
-    sample1[current_channel] = predictor;
-    output[out_ptr++] = predictor;
-
-    // compute the next adaptive scale factor (a.k.a. the variable idelta)
-    idelta[current_channel] =
-      (ms_adapt_table[nibble] * idelta[current_channel]) / 256;
-    CLAMP_ABOVE_16(idelta[current_channel]);
-
-    // toggle the channel
-    current_channel ^= channels - 1;
-  }
-
-  return (block_size - (MS_ADPCM_PREAMBLE_SIZE * channels)) * 2;
-}
-
-ADM_AudiocodecMsAdpcm::ADM_AudiocodecMsAdpcm( uint32_t fourcc ,WAVHeader *info)
-        : ADM_Audiocodec(fourcc)
-{
-        _me=info-&gt;encoding;
-        _channels=info-&gt;channels;
-
-         if ((info-&gt;encoding == WAV_MSADPCM)      )
-        {
-              ss_div = info-&gt;blockalign -   (MS_ADPCM_PREAMBLE_SIZE * info-&gt;channels) * 2;
-              ss_mul = info-&gt;blockalign;
-        }
-  _tail=_head=0;
-  printf(&quot;Block size: %d\n&quot;,ss_mul);
-}
-ADM_AudiocodecMsAdpcm::~ADM_AudiocodecMsAdpcm()
-{
-
-}
-
-uint8_t ADM_AudiocodecMsAdpcm::run(uint8_t *inptr, uint32_t nbIn, float *outptr, uint32_t *nbOut)
-{
-int produced=0,one;
-uint8_t  *start;
-int16_t *run16;
-// Add to buffer
-  
-  ADM_assert((_tail+nbIn)&lt;IMA_BUFFER);
-  memcpy(&amp;(_buffer[_tail]),inptr,nbIn);
-  _tail+=nbIn;
-  *nbOut=0;
-
-  if((_tail-_head)&lt;ss_mul) 
-        return 0;
-// static int ms_adpcm_decode_block(unsigned short *output, unsigned char *input,
-//   int channels, int block_size)
-
-
-        while((_tail-_head)&gt;=ss_mul)
-        {
-                start=(uint8_t *)&amp;(_buffer[_head]);
-                one=  ms_adpcm_decode_block(
-                        (unsigned short *)scratchPad,start,_channels , ss_mul);
-                _head+=ss_mul;
-                produced+=one;
-                run16=(int16_t *)scratchPad;
-                for(int i=0;i&lt;one;i++)
-                {
-                  *outptr++=((float)run16[i])/32767.;
-                }
-                //printf(&quot;Out :%u one\n&quot;);
-        }
-        if(_tail&gt;IMA_BUFFER/2 &amp;&amp; _head)
-        {
-                memmove(_buffer,&amp;_buffer[_head],_tail-_head);
-                _tail-=_head;
-                _head=0;
-        }
-        *nbOut=produced;
-        return 1;
-  
-}
-
-// EOF

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audiocodec/ADM_codeculaw.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audiocodec/ADM_codeculaw.cpp	2009-07-13 08:56:50 UTC (rev 5079)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audiocodec/ADM_codeculaw.cpp	2009-07-13 08:56:52 UTC (rev 5080)
@@ -1,67 +0,0 @@
-//
-// C++ Implementation: ADM_codeculaw
-//
-// Description: 
-//
-//
-// Author: mean &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>&gt;, (C) 2004
-//
-// Copyright: See COPYING file that comes with this distribution
-//
-//
-
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-#include &quot;ADM_default.h&quot;
-#include &lt;math.h&gt;
-
-//#include &quot;avifmt.h&quot;
-//#include &quot;avifmt2.h&quot;
-//#include &quot;fourcc.h&quot;
-
-#include &quot;ADM_audiocodec/ADM_audiocodec.h&quot;
-
-
-static int expon [8]= {0,132,396,924,1980,4092,8316,16764};
-ADM_AudiocodecUlaw::ADM_AudiocodecUlaw( uint32_t fourcc,WAVHeader *info) : ADM_Audiocodec(fourcc)
-{
-		
-}
-ADM_AudiocodecUlaw::~ADM_AudiocodecUlaw()
-{
-
-}
-
-
-uint8_t ADM_AudiocodecUlaw::run(uint8_t *inptr, uint32_t nbIn, float *outptr, uint32_t *nbOut)
-{
-uint8_t byt1;
-int16_t out;
-
-int mant,mexp,sign;
-
-	*nbOut=nbIn;
-
-	for(uint32_t i=0;i&lt;nbIn;i++)
-	{
-		byt1=*inptr++;
-		byt1=~byt1;
-		sign=(byt1&amp;0x80);
-		mexp=(byt1&gt;&gt;4)&amp;0x7;
-		mant=byt1&amp;0xf;
-		out=expon[mexp]+(mant&lt;&lt;(mexp+3));
-		if(sign) out=-out;
-		*outptr++=(float)out / 32768;
-	}
-
-	return 1;
-}
-

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audiocodec/ADM_codecwma.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audiocodec/ADM_codecwma.cpp	2009-07-13 08:56:50 UTC (rev 5079)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audiocodec/ADM_codecwma.cpp	2009-07-13 08:56:52 UTC (rev 5080)
@@ -1,163 +0,0 @@
-/***************************************************************************
-                          ADM_codecwma.cpp  -  description
-                             -------------------
-        We do also AMR here
-
-    begin                : Tue Nov 12 2002
-    copyright            : (C) 2002 by mean
-    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#include &quot;ADM_default.h&quot;
-#include &lt;math.h&gt;
-#include &quot;ADM_lavcodec.h&quot;
-#include &quot;fourcc.h&quot;
-#include &quot;DIA_coreToolkit.h&quot;
-
-#include &quot;ADM_coreAudio.h&quot;
-#include &quot;ADM_audiocodec/ADM_audiocodec.h&quot;
-
-#define _context ((AVCodecContext *)_contextVoid)
-
-uint8_t scratchPad[SCRATCH_PAD_SIZE];
-
-   uint8_t ADM_AudiocodecWMA::beginDecompress( void )
-   {
-            _tail=_head=0;
-            return 1;
-   };
-   uint8_t ADM_AudiocodecWMA::endDecompress( void )
-   {
-          _tail=_head=0;
-          return 1;
-   };
-
- ADM_AudiocodecWMA::ADM_AudiocodecWMA(uint32_t fourcc,WAVHeader *info,uint32_t l,uint8_t *d)
-       :  ADM_Audiocodec(fourcc)
- {
-    _tail=_head=0;
-
-    _contextVoid=(void *)avcodec_alloc_context();
-    ADM_assert(_contextVoid);
-    // Fills in some values...
-    _context-&gt;sample_rate = info-&gt;frequency;
-    _context-&gt;channels = info-&gt;channels;
-    _blockalign=_context-&gt;block_align = info-&gt;blockalign;
-    _context-&gt;bit_rate = info-&gt;byterate*8;
-    switch(fourcc)
-    {
-      case WAV_WMA:
-        _context-&gt;codec_id = CODEC_ID_WMAV2;
-        break;
-      case WAV_QDM2:
-        _context-&gt;codec_id = CODEC_ID_QDM2;
-        break;
-      case WAV_AMV_ADPCM:
-        _context-&gt;codec_id = CODEC_ID_ADPCM_IMA_AMV;
-        _blockalign=1;
-        break;
-      case WAV_NELLYMOSER:
-        _context-&gt;codec_id = CODEC_ID_NELLYMOSER;
-        _blockalign=1;
-        break;
-
-      default:
-             ADM_assert(0);
-    }
-    _context-&gt;extradata=(uint8_t *)d;
-    _context-&gt;extradata_size=(int)l;
-    printf(&quot; Using %&quot;LU&quot; bytes of extra header data\n&quot;,l);
-    mixDump((uint8_t *)_context-&gt;extradata,_context-&gt;extradata_size);
-
-   AVCodec *codec=avcodec_find_decoder(_context-&gt;codec_id);
-   if(!codec) {GUI_Error_HIG(QT_TR_NOOP(&quot;Internal error&quot;), QT_TR_NOOP(&quot;Cannot open WMA2 codec.&quot;));ADM_assert(0);}
-    if (avcodec_open(_context, codec) &lt; 0)
-    {
-        printf(&quot;\n Lavc audio decoder init failed !\n&quot;);
-        ADM_assert(0);
-    }
-    if(!_blockalign)
-    {
-      if(_context-&gt;block_align) _blockalign=_context-&gt;block_align;
-      else
-      {
-        printf(&quot;FFWMA : no blockalign taking 378\n&quot;);
-        _blockalign=378;
-      }
-    }
-    printf(&quot;FFwma init successful (blockalign %d)\n&quot;,info-&gt;blockalign);
-}
- ADM_AudiocodecWMA::~ADM_AudiocodecWMA()
- {
-        avcodec_close(_context);
-        ADM_dealloc(_context);
-        _contextVoid=NULL;
-}
-/*-------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------*/
-
-uint8_t ADM_AudiocodecWMA::run(uint8_t *inptr, uint32_t nbIn, float *outptr, uint32_t *nbOut)
-{
-int out=0;
-int max=0,pout=0;
-int16_t *run16;
-int nbChunk;
-
-        *nbOut=0;
-        // Shrink
-        if(_head &amp;&amp; (_tail+nbIn)*3&gt;ADMWA_BUF*2)
-        {
-            memmove(_buffer,_buffer+_head,_tail-_head);
-            _tail-=_head;
-            _head=0;
-        }
-        //
-        ADM_assert(nbIn+_tail&lt;ADMWA_BUF);
-        memcpy(_buffer+_tail,inptr,nbIn);
-        _tail+=nbIn;
-        while(_tail-_head&gt;=_blockalign)
-        {
-          nbChunk=(_tail-_head)/_blockalign;
-          pout=SCRATCH_PAD_SIZE;
-          out=avcodec_decode_audio2(_context,(int16_t *)scratchPad,
-                                   &amp;pout,_buffer+_head,nbChunk*_blockalign);
-
-          if(out&lt;0)
-          {
-            printf( &quot; *** WMA decoding error (%u)***\n&quot;,_blockalign);
-            _head+=1; // Try skipping some bytes
-            continue;
-          }
-          if(pout&gt;=SCRATCH_PAD_SIZE)
-          {
-            printf(&quot;Produced : %u, buffer %u,in%u\n&quot;,pout,SCRATCH_PAD_SIZE,_tail-_head);
-            ADM_assert(0);
-          }
-          if(_context-&gt;codec_id == CODEC_ID_NELLYMOSER)
-          { // Hack, it returns inconsistent size
-            out=nbChunk*_blockalign;
-          }
-          _head+=out; // consumed bytes
-          pout&gt;&gt;=1;
-          *nbOut+=pout;
-          run16=(int16_t *)scratchPad;
-          for(int i=0;i&lt;pout;i++)
-          {
-            *outptr++=((float)run16[i])/32767.;
-          }
-        }
-
-
-
-        return 1;
-}
-
-//---

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audiocodec/ADM_pluginLoad.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audiocodec/ADM_pluginLoad.cpp	2009-07-13 08:56:50 UTC (rev 5079)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audiocodec/ADM_pluginLoad.cpp	2009-07-13 08:56:52 UTC (rev 5080)
@@ -164,7 +164,7 @@
 		ADM_ad_plugin *a=ADM_audioPlugins[i];
 		ADM_assert(a);
 		ADM_assert(a-&gt;supportedFormat);
-		aprintf(&quot;Format 0x%x : probing %s\n&quot;,fourcc,a-&gt;name);
+		aprintf(&quot;[ADM_ad_plugin]Format 0x%x : probing %s\n&quot;,fourcc,a-&gt;name);
 		if(a-&gt;supportedFormat(fourcc)==true)
 		{
 			ADM_assert(a-&gt;create);

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audiocodec/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audiocodec/CMakeLists.txt	2009-07-13 08:56:50 UTC (rev 5079)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audiocodec/CMakeLists.txt	2009-07-13 08:56:52 UTC (rev 5080)
@@ -1,8 +1,5 @@
 SET(ADM_audiocodec_SRCS
 ADM_8bits.cpp  
-ADM_codecimaadpcm.cpp  
-ADM_codecmsadpcm.cpp  
-ADM_codeculaw.cpp  
 ADM_lpcm.cpp
 ADM_audiocodec.cpp  
 ADM_codecwav.cpp  

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreAudio/include/ADM_audioCodecEnum.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreAudio/include/ADM_audioCodecEnum.h	2009-07-13 08:56:50 UTC (rev 5079)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreAudio/include/ADM_audioCodecEnum.h	2009-07-13 08:56:52 UTC (rev 5080)
@@ -4,26 +4,6 @@
 #ifndef ADM_audioCodecEnum_H
 #define ADM_audioCodecEnum_H
 
-#if 0
-typedef struct
-{
-	uint16_t	encoding;	
-	uint16_t	channels;					/* 1 = mono, 2 = stereo */
-	uint32_t	frequency;				/* One of 11025, 22050, or 44100 48000 Hz */
-	uint32_t	byterate;					/* Average bytes per second */
-	uint16_t	blockalign;				/* Bytes per sample block */
-	uint16_t	bitspersample;		/* One of 8, 12, 16, or 4 for ADPCM */
- // 16 bytes up to here, 14 left
- // Used for VBR mp3
-  uint16_t   		cbsize ;
-  uint16_t          wId ;
-  uint32_t         	fdwflags ;
-  uint16_t          nblocksize ;
-  uint16_t          nframesperblock  ;
-  uint16_t          ncodecdelay ;
-} WAVHeaderVBR;
-#endif
-
 #define WAV_MP3 	85
 #define WAV_MP2 	80
 #define WAV_WMA 	353

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreAudio/include/ADM_baseAudioStream.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreAudio/include/ADM_baseAudioStream.h	2009-07-13 08:56:50 UTC (rev 5079)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreAudio/include/ADM_baseAudioStream.h	2009-07-13 08:56:52 UTC (rev 5080)
@@ -44,27 +44,7 @@
 
 }ST_point;
 
-#define WAV_MP3 	85
-#define WAV_MP2 	80
-#define WAV_WMA 	353
-#define WAV_PCM 	1
-#define WAV_MSADPCM 	2
-#define WAV_LPCM 	3
-#define WAV_AC3 	0x2000
-#define WAV_DTS 	0x2001
-#define WAV_OGG 0x676f
-#define WAV_8BITS 	53 // dummy id
-#define WAV_MP4 	54 // dummy id
-#define WAV_AAC 	0xff // dummy id
-#define WAV_AAC_HE 	0xfe // dummy id
-#define WAV_8BITS_UNSIGNED 	55 // dummy id
-#define WAV_AMRNB 	56 // dummy id
-#define WAV_ULAW	57 // dummy id
-#define WAV_QDM2 	58
-#define WAV_IMAADPCM    17
-#define WAV_AMV_ADPCM    9900
-#define WAV_NELLYMOSER   9901
-#define WAV_UNKNOWN     9999
+#include &quot;ADM_audioCodecEnum.h&quot;
 
 
 #endif

Copied: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDecoders/ADM_ad_ima_adpcm/ADM_ad_ima_adpcm.cpp (from rev 5079, branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audiocodec/ADM_codecimaadpcm.cpp)
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audiocodec/ADM_codecimaadpcm.cpp	2009-07-13 08:56:50 UTC (rev 5079)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDecoders/ADM_ad_ima_adpcm/ADM_ad_ima_adpcm.cpp	2009-07-13 08:56:52 UTC (rev 5080)
@@ -0,0 +1,335 @@
+/**
+    \file ADM_ad_ima_adpcm.cpp
+    \brief Audio decoders built ulaw from mplayer or ffmpeg (??, can't remember)
+    \author mean (c) 2009
+
+*/
+/*
+    IMA ADPCM Decoder for MPlayer
+      by Mike Melanson
+
+    This file is in charge of decoding all of the various IMA ADPCM data
+    formats that various entities have created. Details about the data
+    formats can be found here:
+      <A HREF="http://www.pcisys.net/~melanson/codecs/">http://www.pcisys.net/~melanson/codecs/</A>
+
+    So far, this file handles these formats:
+      'ima4': IMA ADPCM found in QT files
+        0x11: IMA ADPCM found in MS AVI/ASF/WAV files
+        0x61: DK4 ADPCM found in certain AVI files on Sega Saturn CD-ROMs;
+              note that this is a 'rogue' format number in that it was
+              never officially registered with Microsoft
+    0x1100736d: IMA ADPCM coded like in MS AVI/ASF/WAV found in QT files
+*/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include &quot;ADM_default.h&quot;
+#include &lt;math.h&gt;
+#define ADM_NO_CONFIG_H
+#include &quot;ADM_ffmpeg/libavutil/bswap.h&quot;
+#include &quot;ADM_ad_plugin.h&quot;
+
+/**
+    \class ADM_AudiocodecImaAdpcm
+    \brief
+*/
+
+ 
+#define IMA_BUFFER 4096*8
+class ADM_AudiocodecImaAdpcm : public     ADM_Audiocodec
+{
+	protected:
+		uint32_t _inStock,_me,_channels;
+		int ss_div,ss_mul; // ???
+		void *_contextVoid;
+		uint8_t _buffer[ IMA_BUFFER];
+		uint32_t _head,_tail;
+
+	public:
+		ADM_AudiocodecImaAdpcm(uint32_t fourcc, WAVHeader *info, uint32_t l, uint8_t *d);
+		virtual	~ADM_AudiocodecImaAdpcm();
+		virtual	uint8_t beginDecompress(void) {_head=_tail=0;return 1;}
+		virtual	uint8_t endDecompress(void) {_head=_tail=0;return 1;}
+		virtual	uint8_t run(uint8_t *inptr, uint32_t nbIn, float *outptr, uint32_t *nbOut);
+		virtual	uint8_t isCompressed(void) {return 1;}
+};
+// Supported formats + declare our plugin
+//*******************************************************
+static uint32_t Formats[]={WAV_IMAADPCM};
+DECLARE_AUDIO_DECODER(ADM_AudiocodecImaAdpcm,						// Class
+			0,0,1, 												// Major, minor,patch
+			Formats, 											// Supported formats
+			&quot;IMA ADPCM decoder plugin for avidemux (c) Mean\n&quot;); 	// Desc
+//********************************************************
+
+
+#define MS_IMA_ADPCM_PREAMBLE_SIZE 4
+
+#define QT_IMA_ADPCM_PREAMBLE_SIZE 2
+#define QT_IMA_ADPCM_BLOCK_SIZE 0x22
+#define QT_IMA_ADPCM_SAMPLES_PER_BLOCK 64
+
+#define BE_16(x) (be2me_16(*(unsigned short *)(x)))
+#define BE_32(x) (be2me_32(*(unsigned int *)(x)))
+#define LE_16(x) (le2me_16(*(unsigned short *)(x)))
+#define LE_32(x) (le2me_32(*(unsigned int *)(x)))
+
+int ms_ima_adpcm_decode_block(unsigned short *output,
+  unsigned char *input, int channels, int block_size);
+
+// pertinent tables for IMA ADPCM
+static int adpcm_step[89] =
+{
+  7, 8, 9, 10, 11, 12, 13, 14, 16, 17,
+  19, 21, 23, 25, 28, 31, 34, 37, 41, 45,
+  50, 55, 60, 66, 73, 80, 88, 97, 107, 118,
+  130, 143, 157, 173, 190, 209, 230, 253, 279, 307,
+  337, 371, 408, 449, 494, 544, 598, 658, 724, 796,
+  876, 963, 1060, 1166, 1282, 1411, 1552, 1707, 1878, 2066,
+  2272, 2499, 2749, 3024, 3327, 3660, 4026, 4428, 4871, 5358,
+  5894, 6484, 7132, 7845, 8630, 9493, 10442, 11487, 12635, 13899,
+  15289, 16818, 18500, 20350, 22385, 24623, 27086, 29794, 32767
+};
+
+static int adpcm_index[16] =
+{
+  -1, -1, -1, -1, 2, 4, 6, 8,
+  -1, -1, -1, -1, 2, 4, 6, 8
+};
+
+// useful macros
+// clamp a number between 0 and 88
+#define CLAMP_0_TO_88(x)  if (x &lt; 0) x = 0; else if (x &gt; 88) x = 88;
+// clamp a number within a signed 16-bit range
+#define CLAMP_S16(x)  if (x &lt; -32768) x = -32768; \
+  else if (x &gt; 32767) x = 32767;
+// clamp a number above 16
+#define CLAMP_ABOVE_16(x)  if (x &lt; 16) x = 16;
+// sign extend a 16-bit value
+#define SE_16BIT(x)  if (x &amp; 0x8000) x -= 0x10000;
+// sign extend a 4-bit value
+#define SE_4BIT(x)  if (x &amp; 0x8) x -= 0x10;
+
+// static ad_info_t info = 
+// {
+// 	&quot;IMA ADPCM audio decoder&quot;,
+// 	&quot;imaadpcm&quot;,
+// 	&quot;Nick Kurshev&quot;,
+// 	&quot;Mike Melanson&quot;,
+// 	&quot;&quot;
+// };
+
+ADM_AudiocodecImaAdpcm::ADM_AudiocodecImaAdpcm( uint32_t fourcc, WAVHeader *info, uint32_t l, uint8_t *d)
+        : ADM_Audiocodec(fourcc)
+{
+        _me=info-&gt;encoding;
+        _channels=info-&gt;channels;
+
+         if ((info-&gt;encoding == WAV_IMAADPCM) || (info-&gt;encoding == 0x61) 
+        //||      (info-&gt;encoding == (uint16_t)0x1100736d)
+        )
+  {
+     ss_div = info-&gt;blockalign -
+      (MS_IMA_ADPCM_PREAMBLE_SIZE * info-&gt;channels) * 2;
+     ss_mul = info-&gt;blockalign;
+  }
+  else
+  {
+    ss_div = QT_IMA_ADPCM_SAMPLES_PER_BLOCK;
+    ss_mul = QT_IMA_ADPCM_BLOCK_SIZE * info-&gt;channels;
+  }
+  //sh_audio-&gt;audio_in_minsize=sss_mul;
+  _tail=_head=0;
+  printf(&quot;Block size: %d\n&quot;,ss_mul);
+}
+ADM_AudiocodecImaAdpcm::~ADM_AudiocodecImaAdpcm()
+{
+
+}
+
+uint8_t ADM_AudiocodecImaAdpcm::run(uint8_t *inptr, uint32_t nbIn, float *outptr, uint32_t *nbOut)
+{
+int produced=0,one;
+uint8_t  *start;
+int16_t *run16;
+// Add to buffer
+  
+  ADM_assert((_tail+nbIn)&lt;IMA_BUFFER);
+  memcpy(&amp;(_buffer[_tail]),inptr,nbIn);
+  _tail+=nbIn;
+  *nbOut=0;
+
+  if((_tail-_head)&lt;ss_mul) 
+        return 0;
+
+
+  if ((_me== WAV_IMAADPCM))// || (sh_audio-&gt;format == 0x1100736d))
+  {
+        while((_tail-_head)&gt;=ss_mul)
+        {
+                start=(uint8_t *)&amp;(_buffer[_head]);
+                one=  ms_ima_adpcm_decode_block(
+                        (unsigned short *)scratchPad,start,_channels , ss_mul);
+                _head+=ss_mul;
+                produced+=one;
+                run16=(int16_t *)scratchPad;
+                for(int i=0;i&lt;one;i++)
+                {
+                  *outptr++=((float)run16[i])/32767.;
+                }
+        }
+        if(_tail&gt;IMA_BUFFER/2 &amp;&amp; _head)
+        {
+                memmove(_buffer,&amp;_buffer[_head],_tail-_head);
+                _tail-=_head;
+                _head=0;
+        }
+        *nbOut=produced;
+        return 1;
+  }
+#if 0
+  else if (_me == 0x61)
+  {
+    return 2 * dk4_ima_adpcm_decode_block(
+      (unsigned short*)outptr, ptr, _channels,  ss_mul);
+  }
+  else
+  {
+    return 2 * qt_ima_adpcm_decode_block(
+      (unsigned short*)outptr, ptr, _channels);
+  }
+#endif
+        return 0;
+}
+
+
+static void decode_nibbles(unsigned short *output,
+  int output_size, int channels,
+  int predictor_l, int index_l,
+  int predictor_r, int index_r)
+{
+  int step[2];
+  int predictor[2];
+  int index[2];
+  int diff;
+  int i;
+  int sign;
+  int delta;
+  int channel_number = 0;
+
+  step[0] = adpcm_step[index_l];
+  step[1] = adpcm_step[index_r];
+  predictor[0] = predictor_l;
+  predictor[1] = predictor_r;
+  index[0] = index_l;
+  index[1] = index_r;
+
+  for (i = 0; i &lt; output_size; i++)
+  {
+    delta = output[i];
+
+    index[channel_number] += adpcm_index[delta];
+    CLAMP_0_TO_88(index[channel_number]);
+
+    sign = delta &amp; 8;
+    delta = delta &amp; 7;
+
+    diff = step[channel_number] &gt;&gt; 3;
+    if (delta &amp; 4) diff += step[channel_number];
+    if (delta &amp; 2) diff += step[channel_number] &gt;&gt; 1;
+    if (delta &amp; 1) diff += step[channel_number] &gt;&gt; 2;
+
+    if (sign)
+      predictor[channel_number] -= diff;
+    else
+      predictor[channel_number] += diff;
+
+    CLAMP_S16(predictor[channel_number]);
+    output[i] = predictor[channel_number];
+    step[channel_number] = adpcm_step[index[channel_number]];
+
+    // toggle channel
+    channel_number ^= channels - 1;
+
+  }
+}
+
+int ms_ima_adpcm_decode_block(unsigned short *output,
+  unsigned char *input, int channels, int block_size)
+{
+  int predictor_l = 0;
+  int predictor_r = 0;
+  int index_l = 0;
+  int index_r = 0;
+  int i;
+  int channel_counter;
+  int channel_index;
+  int channel_index_l;
+  int channel_index_r;
+
+  predictor_l = LE_16(&amp;input[0]);
+  SE_16BIT(predictor_l);
+  index_l = input[2];
+  if (channels == 2)
+  {
+    predictor_r = LE_16(&amp;input[4]);
+    SE_16BIT(predictor_r);
+    index_r = input[6];
+  }
+
+  if (channels == 1)
+    for (i = 0;
+      i &lt; (block_size - MS_IMA_ADPCM_PREAMBLE_SIZE * channels); i++)
+    {
+      output[i * 2 + 0] = input[MS_IMA_ADPCM_PREAMBLE_SIZE + i] &amp; 0x0F;
+      output[i * 2 + 1] = input[MS_IMA_ADPCM_PREAMBLE_SIZE + i] &gt;&gt; 4;
+    }
+  else
+  {
+    // encoded as 8 nibbles (4 bytes) per channel; switch channel every
+    // 4th byte
+    channel_counter = 0;
+    channel_index_l = 0;
+    channel_index_r = 1;
+    channel_index = channel_index_l;
+    for (i = 0;
+      i &lt; (block_size - MS_IMA_ADPCM_PREAMBLE_SIZE * channels); i++)
+    {
+      output[channel_index + 0] =
+        input[MS_IMA_ADPCM_PREAMBLE_SIZE * 2 + i] &amp; 0x0F;
+      output[channel_index + 2] =
+        input[MS_IMA_ADPCM_PREAMBLE_SIZE * 2 + i] &gt;&gt; 4;
+      channel_index += 4;
+      channel_counter++;
+      if (channel_counter == 4)
+      {
+        channel_index_l = channel_index;
+        channel_index = channel_index_r;
+      }
+      else if (channel_counter == 8)
+      {
+        channel_index_r = channel_index;
+        channel_index = channel_index_l;
+        channel_counter = 0;
+      }
+    }
+  }
+  
+  decode_nibbles(output,
+    (block_size - MS_IMA_ADPCM_PREAMBLE_SIZE * channels) * 2,
+    channels,
+    predictor_l, index_l,
+    predictor_r, index_r);
+
+  return (block_size - MS_IMA_ADPCM_PREAMBLE_SIZE * channels) * 2;
+}
+
+
+// EOF

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDecoders/ADM_ad_ima_adpcm/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDecoders/ADM_ad_ima_adpcm/CMakeLists.txt	2009-07-13 08:56:50 UTC (rev 5079)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDecoders/ADM_ad_ima_adpcm/CMakeLists.txt	2009-07-13 08:56:52 UTC (rev 5080)
@@ -0,0 +1,9 @@
+	INCLUDE(ad_plugin)
+	
+	SET(ADM_ad_ima_adpcm_SRCS ADM_ad_ima_adpcm.cpp)
+
+	ADD_LIBRARY(ADM_ad_ima_adpcm SHARED ${ADM_ad_ima_adpcm_SRCS})
+	TARGET_LINK_LIBRARIES(ADM_ad_ima_adpcm ADM_core )
+
+	INIT_AUDIO_PLUGIN(ADM_ad_ima_adpcm)
+	INSTALL_AUDIODECODER(ADM_ad_ima_adpcm)

Copied: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDecoders/ADM_ad_ms_adpcm/ADM_ad_ms_adpcm.cpp (from rev 5079, branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audiocodec/ADM_codecmsadpcm.cpp)
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audiocodec/ADM_codecmsadpcm.cpp	2009-07-13 08:56:50 UTC (rev 5079)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDecoders/ADM_ad_ms_adpcm/ADM_ad_ms_adpcm.cpp	2009-07-13 08:56:52 UTC (rev 5080)
@@ -0,0 +1,286 @@
+/**
+    \file ADM_ad_msadpcm.cpp
+    \brief Audio decoders built ulaw from mplayer or ffmpeg (??, can't remember)
+    \author mean (c) 2009
+
+*/
+//********************************************************
+/*
+    MS ADPCM Decoder for MPlayer
+      by Mike Melanson
+
+    This file is responsible for decoding Microsoft ADPCM data.
+    Details about the data format can be found here:
+      <A HREF="http://www.pcisys.net/~melanson/codecs/">http://www.pcisys.net/~melanson/codecs/</A>
+      
+      &quot;Nick Kurshev&quot;,
+	&quot;Mike Melanson&quot;,
+
+      
+*/
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include &quot;ADM_default.h&quot;
+#include &lt;math.h&gt;
+
+#include &quot;ADM_default.h&quot;
+#include &quot;ADM_ad_plugin.h&quot;
+#define IMA_BUFFER 4096*8
+/**
+    \class ADM_AudiocodecUlaw
+    \brief
+*/
+
+class ADM_AudiocodecMsAdpcm : public     ADM_Audiocodec
+{
+	protected:
+		uint32_t _inStock,_me,_channels;
+		int ss_div,ss_mul; // ???
+		void *_contextVoid;
+		uint8_t _buffer[ IMA_BUFFER];
+		uint32_t _head,_tail;
+
+	public:
+		ADM_AudiocodecMsAdpcm(uint32_t fourcc, WAVHeader *info, uint32_t l, uint8_t *d);
+		virtual	~ADM_AudiocodecMsAdpcm();
+		virtual	uint8_t beginDecompress(void) {_head=_tail=0;return 1;}
+		virtual	uint8_t endDecompress(void) {_head=_tail=0;return 1;}
+		virtual	uint8_t run(uint8_t *inptr, uint32_t nbIn, float *outptr, uint32_t *nbOut);
+		virtual	uint8_t isCompressed(void) {return 1;}
+};
+// Supported formats + declare our plugin
+//*******************************************************
+static uint32_t Formats[]={WAV_MSADPCM};
+DECLARE_AUDIO_DECODER(ADM_AudiocodecMsAdpcm,						// Class
+			0,0,1, 												// Major, minor,patch
+			Formats, 											// Supported formats
+			&quot;Ulaw decoder plugin for avidemux (c) Mean\n&quot;); 	// Desc
+
+
+#include &quot;ADM_default.h&quot;
+#define ADM_NO_CONFIG_H
+#include &quot;ADM_coreAudio.h&quot;
+#include &quot;ADM_audiocodec.h&quot;
+
+static int ms_adapt_table[] =
+{
+  230, 230, 230, 230, 307, 409, 512, 614,
+  768, 614, 512, 409, 307, 230, 230, 230
+};
+
+static int ms_adapt_coeff1[] =
+{
+  256, 512, 0, 192, 240, 460, 392
+};
+
+static int ms_adapt_coeff2[] =
+{
+  0, -256, 0, 64, 0, -208, -232
+};
+
+#define MS_ADPCM_PREAMBLE_SIZE 6
+
+#define LE_16(x) ((x)[0]+(256*((x)[1])))
+//#define LE_16(x) (le2me_16((x)[1]+(256*((x)[0]))))
+//#define LE_16(x) (le2me_16(*(unsigned short *)(x)))
+//#define LE_32(x) (le2me_32(*(unsigned int *)(x)))
+
+// useful macros
+// clamp a number between 0 and 88
+#define CLAMP_0_TO_88(x)  if (x &lt; 0) x = 0; else if (x &gt; 88) x = 88;
+// clamp a number within a signed 16-bit range
+#define CLAMP_S16(x)  if (x &lt; -32768) x = -32768; \
+  else if (x &gt; 32767) x = 32767;
+// clamp a number above 16
+#define CLAMP_ABOVE_16(x)  if (x &lt; 16) x = 16;
+// sign extend a 16-bit value
+#define SE_16BIT(x)  if (x &amp; 0x8000) x -= 0x10000;
+// sign extend a 4-bit value
+#define SE_4BIT(x)  if (x &amp; 0x8) x -= 0x10;
+
+static int ms_adpcm_decode_block(unsigned short *output, unsigned char *input,
+  int channels, int block_size)
+{
+  int current_channel = 0;
+  int idelta[2];
+  int sample1[2];
+  int sample2[2];
+  int coeff1[2];
+  int coeff2[2];
+  int stream_ptr = 0;
+  int out_ptr = 0;
+  int upper_nibble = 1;
+  int nibble;
+  int snibble;  // signed nibble
+  int predictor;
+
+  // fetch the header information, in stereo if both channels are present
+  if (input[stream_ptr] &gt; 6)
+    printf( &quot;MS ADPCM: coefficient (%d) out of range (should be [0..6])\n&quot;,
+      input[stream_ptr]);
+  coeff1[0] = ms_adapt_coeff1[input[stream_ptr]];
+  coeff2[0] = ms_adapt_coeff2[input[stream_ptr]];
+  stream_ptr++;
+  if (channels == 2)
+  {
+    if (input[stream_ptr] &gt; 6)
+     printf( &quot;MS ADPCM: coefficient (%d) out of range (should be [0..6])\n&quot;,
+       input[stream_ptr]);
+    coeff1[1] = ms_adapt_coeff1[input[stream_ptr]];
+    coeff2[1] = ms_adapt_coeff2[input[stream_ptr]];
+    stream_ptr++;
+  }
+
+  idelta[0] = LE_16(&amp;input[stream_ptr]);
+  stream_ptr += 2;
+  SE_16BIT(idelta[0]);
+  if (channels == 2)
+  {
+    idelta[1] = LE_16(&amp;input[stream_ptr]);
+    stream_ptr += 2;
+    SE_16BIT(idelta[1]);
+  }
+
+  sample1[0] = LE_16(&amp;input[stream_ptr]);
+  stream_ptr += 2;
+  SE_16BIT(sample1[0]);
+  if (channels == 2)
+  {
+    sample1[1] = LE_16(&amp;input[stream_ptr]);
+    stream_ptr += 2;
+    SE_16BIT(sample1[1]);
+  }
+
+  sample2[0] = LE_16(&amp;input[stream_ptr]);
+  stream_ptr += 2;
+  SE_16BIT(sample2[0]);
+  if (channels == 2)
+  {
+    sample2[1] = LE_16(&amp;input[stream_ptr]);
+    stream_ptr += 2;
+    SE_16BIT(sample2[1]);
+  }
+
+  if (channels == 1)
+  {
+    output[out_ptr++] = sample2[0];
+    output[out_ptr++] = sample1[0];
+  } else {
+    output[out_ptr++] = sample2[0];
+    output[out_ptr++] = sample2[1];
+    output[out_ptr++] = sample1[0];
+    output[out_ptr++] = sample1[1];
+  }
+
+  while (stream_ptr &lt; block_size)
+  {
+    // get the next nibble
+    if (upper_nibble)
+      nibble = snibble = input[stream_ptr] &gt;&gt; 4;
+    else
+      nibble = snibble = input[stream_ptr++] &amp; 0x0F;
+    upper_nibble ^= 1;
+    SE_4BIT(snibble);
+
+    predictor = (
+      ((sample1[current_channel] * coeff1[current_channel]) +
+       (sample2[current_channel] * coeff2[current_channel])) / 256) +
+      (snibble * idelta[current_channel]);
+    CLAMP_S16(predictor);
+    sample2[current_channel] = sample1[current_channel];
+    sample1[current_channel] = predictor;
+    output[out_ptr++] = predictor;
+
+    // compute the next adaptive scale factor (a.k.a. the variable idelta)
+    idelta[current_channel] =
+      (ms_adapt_table[nibble] * idelta[current_channel]) / 256;
+    CLAMP_ABOVE_16(idelta[current_channel]);
+
+    // toggle the channel
+    current_channel ^= channels - 1;
+  }
+
+  return (block_size - (MS_ADPCM_PREAMBLE_SIZE * channels)) * 2;
+}
+/**
+    \fn     ADM_AudiocodecMsAdpcm
+    \brief
+*/
+ADM_AudiocodecMsAdpcm::ADM_AudiocodecMsAdpcm( uint32_t fourcc, WAVHeader *info, uint32_t l, uint8_t *d)
+        : ADM_Audiocodec(fourcc)
+{
+        _me=info-&gt;encoding;
+        _channels=info-&gt;channels;
+
+         if ((info-&gt;encoding == WAV_MSADPCM)      )
+        {
+              ss_div = info-&gt;blockalign -   (MS_ADPCM_PREAMBLE_SIZE * info-&gt;channels) * 2;
+              ss_mul = info-&gt;blockalign;
+        }
+  _tail=_head=0;
+  printf(&quot;Block size: %d\n&quot;,ss_mul);
+}
+/**
+    \fn 
+    \brief
+*/
+
+ADM_AudiocodecMsAdpcm::~ADM_AudiocodecMsAdpcm()
+{
+
+}
+/**
+    \fn     run
+    \brief
+*/
+
+uint8_t ADM_AudiocodecMsAdpcm::run(uint8_t *inptr, uint32_t nbIn, float *outptr, uint32_t *nbOut)
+{
+int produced=0,one;
+uint8_t  *start;
+int16_t *run16;
+// Add to buffer
+  
+  ADM_assert((_tail+nbIn)&lt;IMA_BUFFER);
+  memcpy(&amp;(_buffer[_tail]),inptr,nbIn);
+  _tail+=nbIn;
+  *nbOut=0;
+
+  if((_tail-_head)&lt;ss_mul) 
+        return 0;
+// static int ms_adpcm_decode_block(unsigned short *output, unsigned char *input,
+//   int channels, int block_size)
+
+
+        while((_tail-_head)&gt;=ss_mul)
+        {
+                start=(uint8_t *)&amp;(_buffer[_head]);
+                one=  ms_adpcm_decode_block(
+                        (unsigned short *)scratchPad,start,_channels , ss_mul);
+                _head+=ss_mul;
+                produced+=one;
+                run16=(int16_t *)scratchPad;
+                for(int i=0;i&lt;one;i++)
+                {
+                  *outptr++=((float)run16[i])/32767.;
+                }
+                //printf(&quot;Out :%u one\n&quot;);
+        }
+        if(_tail&gt;IMA_BUFFER/2 &amp;&amp; _head)
+        {
+                memmove(_buffer,&amp;_buffer[_head],_tail-_head);
+                _tail-=_head;
+                _head=0;
+        }
+        *nbOut=produced;
+        return 1;
+  
+}
+
+// EOF

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDecoders/ADM_ad_ms_adpcm/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDecoders/ADM_ad_ms_adpcm/CMakeLists.txt	2009-07-13 08:56:50 UTC (rev 5079)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDecoders/ADM_ad_ms_adpcm/CMakeLists.txt	2009-07-13 08:56:52 UTC (rev 5080)
@@ -0,0 +1,9 @@
+	INCLUDE(ad_plugin)
+	
+	SET(ADM_ad_ms_adpcm_SRCS ADM_ad_ms_adpcm.cpp)
+
+	ADD_LIBRARY(ADM_ad_ms_adpcm SHARED ${ADM_ad_ms_adpcm_SRCS})
+	TARGET_LINK_LIBRARIES(ADM_ad_ms_adpcm ADM_core )
+
+	INIT_AUDIO_PLUGIN(ADM_ad_ms_adpcm)
+	INSTALL_AUDIODECODER(ADM_ad_ms_adpcm)

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDecoders/ADM_ad_ulaw/ADM_ad_ulaw.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDecoders/ADM_ad_ulaw/ADM_ad_ulaw.cpp	2009-07-13 08:56:50 UTC (rev 5079)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDecoders/ADM_ad_ulaw/ADM_ad_ulaw.cpp	2009-07-13 08:56:52 UTC (rev 5080)
@@ -0,0 +1,93 @@
+/**
+    \file ADM_ad_ulaw.cpp
+    \brief Audio decoders built ulaw from mplayer or ffmpeg (??, can't remember)
+    \author mean (c) 2009
+
+*/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include &quot;ADM_default.h&quot;
+#include &lt;math.h&gt;
+
+#include &quot;ADM_default.h&quot;
+#include &quot;ADM_ad_plugin.h&quot;
+
+/**
+    \class ADM_AudiocodecUlaw
+    \brief
+*/
+
+ class ADM_AudiocodecUlaw : public     ADM_Audiocodec
+ {
+ 	public:
+		ADM_AudiocodecUlaw(uint32_t fourcc, WAVHeader *info, uint32_t l, uint8_t *d);
+		virtual	~ADM_AudiocodecUlaw() ;
+		virtual	uint8_t beginDecompress(void) {return 1;}
+		virtual	uint8_t endDecompress(void) {return 1;}
+		virtual	uint8_t run(uint8_t *inptr, uint32_t nbIn, float *outptr, uint32_t *nbOut);
+		virtual	uint8_t isCompressed(void) {return 1;}
+};
+// Supported formats + declare our plugin
+//*******************************************************
+static uint32_t Formats[]={WAV_ULAW};
+DECLARE_AUDIO_DECODER(ADM_AudiocodecUlaw,						// Class
+			0,0,1, 												// Major, minor,patch
+			Formats, 											// Supported formats
+			&quot;Ulaw decoder plugin for avidemux (c) Mean\n&quot;); 	// Desc
+//********************************************************
+
+static int expon [8]= {0,132,396,924,1980,4092,8316,16764};
+/**
+    \fn ADM_AudiocodecUlaw
+    \brief
+*/
+ADM_AudiocodecUlaw::ADM_AudiocodecUlaw(uint32_t fourcc, WAVHeader *info, uint32_t l, uint8_t *d) : ADM_Audiocodec(fourcc)
+{
+		
+}
+/**
+    \fn ~ADM_AudiocodecUlaw
+    \brief
+*/
+
+ADM_AudiocodecUlaw::~ADM_AudiocodecUlaw()
+{
+
+}
+/**
+    \fn run
+    \brief
+*/
+
+
+uint8_t ADM_AudiocodecUlaw::run(uint8_t *inptr, uint32_t nbIn, float *outptr, uint32_t *nbOut)
+{
+uint8_t byt1;
+int16_t out;
+
+int mant,mexp,sign;
+
+	*nbOut=nbIn;
+
+	for(uint32_t i=0;i&lt;nbIn;i++)
+	{
+		byt1=*inptr++;
+		byt1=~byt1;
+		sign=(byt1&amp;0x80);
+		mexp=(byt1&gt;&gt;4)&amp;0x7;
+		mant=byt1&amp;0xf;
+		out=expon[mexp]+(mant&lt;&lt;(mexp+3));
+		if(sign) out=-out;
+		*outptr++=(float)out / 32768;
+	}
+
+	return 1;
+}
+// EOF

Added: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDecoders/ADM_ad_ulaw/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDecoders/ADM_ad_ulaw/CMakeLists.txt	2009-07-13 08:56:50 UTC (rev 5079)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDecoders/ADM_ad_ulaw/CMakeLists.txt	2009-07-13 08:56:52 UTC (rev 5080)
@@ -0,0 +1,9 @@
+	INCLUDE(ad_plugin)
+	
+	SET(ADM_ad_ulaw_SRCS ADM_ad_ulaw.cpp)
+
+	ADD_LIBRARY(ADM_ad_ulaw SHARED ${ADM_ad_ulaw_SRCS})
+	TARGET_LINK_LIBRARIES(ADM_ad_ulaw ADM_core )
+
+	INIT_AUDIO_PLUGIN(ADM_ad_ulaw)
+	INSTALL_AUDIODECODER(ADM_ad_ulaw)

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDecoders/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDecoders/CMakeLists.txt	2009-07-13 08:56:50 UTC (rev 5079)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_audioDecoders/CMakeLists.txt	2009-07-13 08:56:52 UTC (rev 5080)
@@ -5,3 +5,6 @@
 ADD_SUBDIRECTORY(ADM_ad_dca)
 ADD_SUBDIRECTORY(ADM_ad_amrnb)
 ADD_SUBDIRECTORY(ADM_ad_lav)
+ADD_SUBDIRECTORY(ADM_ad_ulaw)
+ADD_SUBDIRECTORY(ADM_ad_ms_adpcm)
+ADD_SUBDIRECTORY(ADM_ad_ima_adpcm)


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="002294.html">[Avidemux-svn-commit] r5079 -	branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audiocodec
</A></li>
	<LI>Next message: <A HREF="002296.html">[Avidemux-svn-commit] r5081 -	branches/avidemux_2.6_branch_mean/avidemux/common/ADM_audiocodec
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2295">[ date ]</a>
              <a href="thread.html#2295">[ thread ]</a>
              <a href="subject.html#2295">[ subject ]</a>
              <a href="author.html#2295">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">More information about the Avidemux-svn-commit
mailing list</a><br>
</body></html>
