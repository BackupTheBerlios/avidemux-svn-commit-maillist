<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Avidemux-svn-commit] r5132 - in	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers:	. oplug_dummy oplug_flv oplug_mpeg oplug_mpegFF
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/avidemux-svn-commit/2009-July/index.html" >
   <LINK REL="made" HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r5132%20-%20in%0A%09branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers%3A%0A%09.%20oplug_dummy%20oplug_flv%20oplug_mpeg%20oplug_mpegFF&In-Reply-To=%3C200907231818.n6NIIk7q009284%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="002346.html">
   <LINK REL="Next"  HREF="002348.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Avidemux-svn-commit] r5132 - in	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers:	. oplug_dummy oplug_flv oplug_mpeg oplug_mpegFF</H1>
    <B>mean at BerliOS</B> 
    <A HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r5132%20-%20in%0A%09branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers%3A%0A%09.%20oplug_dummy%20oplug_flv%20oplug_mpeg%20oplug_mpegFF&In-Reply-To=%3C200907231818.n6NIIk7q009284%40sheep.berlios.de%3E"
       TITLE="[Avidemux-svn-commit] r5132 - in	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers:	. oplug_dummy oplug_flv oplug_mpeg oplug_mpegFF">mean at mail.berlios.de
       </A><BR>
    <I>Thu Jul 23 20:18:46 CEST 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="002346.html">[Avidemux-svn-commit] r5131 -	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/oplug_ogm
</A></li>
        <LI>Next message: <A HREF="002348.html">[Avidemux-svn-commit] r5133 - in	branches/avidemux_2.6_branch_mean/avidemux_plugins:	ADM_muxers ADM_videoEncoder ADM_videoEncoder/ffFlv1
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2347">[ date ]</a>
              <a href="thread.html#2347">[ thread ]</a>
              <a href="subject.html#2347">[ subject ]</a>
              <a href="author.html#2347">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: mean
Date: 2009-07-23 20:18:46 +0200 (Thu, 23 Jul 2009)
New Revision: 5132

Removed:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/ADM_lavformat.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/ADM_lavformat.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/ADM_muxts.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/ADM_tscrc.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/oplug_dummy/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/oplug_dummy/oplug_dummy.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/oplug_flv/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/oplug_flv/oplug_flv.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/oplug_flv/oplug_flv.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/oplug_mpeg/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/oplug_mpeg/op_mpegpass.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/oplug_mpegFF/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/oplug_mpegFF/oplug_encodervcd.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/oplug_mpegFF/oplug_vcdff.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/oplug_mpegFF/oplug_vcdff.h
Log:
[muxer] Cleanup

Deleted: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/ADM_lavformat.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/ADM_lavformat.cpp	2009-07-23 18:18:44 UTC (rev 5131)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/ADM_lavformat.cpp	2009-07-23 18:18:46 UTC (rev 5132)
@@ -1,820 +0,0 @@
-//
-// C++ Implementation: ADM_lavformat
-//
-// Description:
-//
-//
-// Author: mean &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>&gt;, (C) 2004
-//
-// Copyright: See COPYING file that comes with this distribution
-//
-//
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-#include &quot;config.h&quot;
-
-#include &lt;stdio.h&gt;
-#include &lt;stdlib.h&gt;
-#include &lt;math.h&gt;
-#include &lt;string.h&gt;
-
-extern &quot;C&quot;
-{
-	#include &quot;ADM_libraries/ADM_ffmpeg/ADM_lavformat/avformat.h&quot;
-};
-
-#undef malloc
-#undef realloc
-#undef free
-
-#include &quot;ADM_default.h&quot;
-#include &quot;DIA_coreToolkit.h&quot;
-
-#include &quot;ADM_audiofilter/audioprocess.hxx&quot;
-#include &quot;ADM_audio/ADM_a52info.h&quot;
-
-#include &quot;ADM_codecs/ADM_codec.h&quot;
-#include &quot;ADM_editor/ADM_Video.h&quot;
-
-#include &quot;ADM_lavformat.h&quot;
-#include &quot;fourcc.h&quot;
-
-#include &quot;prefs.h&quot;
-#include &quot;ADM_osSupport/ADM_debugID.h&quot;
-#define MODULE_NAME MODULE_LAVFORMAT
-#include &quot;ADM_osSupport/ADM_debug.h&quot;
-
-#include &quot;ADM_cpuCap.h&quot;
-static    AVOutputFormat *fmt;
-static    AVFormatContext *oc;
-static    AVStream *audio_st, *video_st;
-static    double audio_pts, video_pts;
-
-static uint32_t one;
-uint64_t  _curDTS;
-
-static uint8_t ADM_4cc_to_lavcodec(const char *fcc, CodecID *outlavid);
-static uint8_t ADM_WaveTag_to_lavcodec(uint32_t tag, CodecID *outlavid);
-
-extern uint8_t isVP6Compatible (uint32_t fourcc);
-
-// convert in in us to out in 90Khz tick
-int64_t adm_90k( double in)
-{
-int64_t out;
-	// in=in/1000*1000 us-&gt;s
-	// in/=(1/90000) nb 90 khz tick
-	// in*=90*000/000*000
-	// in =  in*=90/000
-	//in=in*90./1000.;
-	out= (int64_t)in;
-	return out;
-}
-//___________________________________________________________________________
-lavMuxer::lavMuxer( void )
-{
-	fmt=NULL;
-	oc=NULL;
-	audio_st=NULL;
-	video_st=NULL;
-	_fps1000=0;
-	_audioByterate=0;
-	_lastAudioDts=0;
-	_frameNo=0;
-	_running=0;
-	_curDTS=0;
-        _audioFq=0;
-}
-//___________________________________________________________________________
-lavMuxer::~lavMuxer()
-{
-	close();
-}
-//___________________________________________________________________________
-uint8_t lavMuxer::open(const char *filename, uint32_t inbitrate,ADM_MUXER_TYPE type, aviInfo *info, WAVHeader *audioheader)
-{
-        return open(filename,inbitrate,type,info,0,NULL,audioheader,0,NULL);
-}
-
-
-uint8_t lavMuxer::open(const char *filename,uint32_t inbitrate, ADM_MUXER_TYPE type, aviInfo *info,
-              uint32_t videoExtraDataSize, uint8_t *videoExtraData, WAVHeader *audioheader,
-              uint32_t audioextraSize,uint8_t *audioextraData)
-{
- AVCodecContext *c;
- 	_type=type;
-	_fps1000=info-&gt;fps1000;
-	switch(_type)
-	{
-	case MUXER_TS:
-		fmt=guess_format(&quot;mpegts&quot;, NULL, NULL);
-		break;
-	case MUXER_DVD:
-		fmt = guess_format(&quot;dvd&quot;, NULL, NULL);
-		break;
-	case MUXER_VCD:
-		fmt = guess_format(&quot;vcd&quot;, NULL, NULL);
-		break;
-	case MUXER_SVCD:
-		fmt = guess_format(&quot;svcd&quot;, NULL, NULL);
-		break;
-	case MUXER_MP4:
-		fmt = guess_format(&quot;mp4&quot;, NULL, NULL);
-		break;
-	case MUXER_PSP:
-		fmt = guess_format(&quot;psp&quot;, NULL, NULL);
-		break;
-	case MUXER_FLV:
-		fmt = guess_format(&quot;flv&quot;, NULL, NULL);
-		break;
-	case MUXER_MATROSKA:
-		fmt = guess_format(&quot;matroska&quot;, NULL, NULL);
-		break;
-
-	default:
-		fmt=NULL;
-	}
-	if (!fmt)
-	{
-        	printf(&quot;Lav:Cannot guess format\n&quot;);
-                ADM_assert(0);
-		return 0;
-	}
-	oc = av_alloc_format_context();
-	if (!oc)
-	{
-       		printf(&quot;Lav:Cannot allocate context\n&quot;);
-		return 0;
-	}
-	oc-&gt;oformat = fmt;
-	snprintf(oc-&gt;filename,1000,&quot;<A HREF="file://%s">file://%s</A>&quot;,filename);
-	// Video
-	//________
-
-	video_st = av_new_stream(oc, 0);
-	if (!video_st)
-	{
-		printf(&quot;Lav: new stream failed\n&quot;);
-		return 0;
-	}
-
-	c = video_st-&gt;codec;
-	switch(_type)
-	{
-				case MUXER_FLV:
-					 c-&gt;codec=new AVCodec;
-					 memset(c-&gt;codec,0,sizeof(AVCodec));
-					 if(fourCC::check(info-&gt;fcc,(uint8_t *)&quot;FLV1&quot;))
-					 {
-						 c-&gt;codec_id=CODEC_ID_FLV1;
-					 	 c-&gt;codec-&gt;name=ADM_strdup(&quot;FLV1&quot;);
-					 }else
-					 {
-						 if(isVP6Compatible(info-&gt;fcc))
-						 			{
-							 		 c-&gt;codec_id=CODEC_ID_VP6F;
-					 				 c-&gt;codec-&gt;name=ADM_strdup(&quot;VP6F&quot;);
-						 			}
-						 else
-							 ADM_assert(0);
-
-					 }
-
-					 break;
-                case MUXER_MATROSKA:
-                        strcpy(oc-&gt;title,&quot;Avidemux&quot;);
-                        strcpy(oc-&gt;author,&quot;Avidemux&quot;);
-                        c-&gt;sample_aspect_ratio.num=1;
-                        c-&gt;sample_aspect_ratio.den=1;
-                        if(isMpeg4Compatible(info-&gt;fcc))
-                        {
-                                c-&gt;codec_id = CODEC_ID_MPEG4;
-                                c-&gt;has_b_frames=1; // in doubt...
-                        }else
-                        {
-                                if(isH264Compatible(info-&gt;fcc))
-                                {
-                                        c-&gt;has_b_frames=1; // in doubt...
-                                        c-&gt;codec_id = CODEC_ID_H264;
-                                        c-&gt;codec=new AVCodec;
-                                        memset(c-&gt;codec,0,sizeof(AVCodec));
-                                        c-&gt;codec-&gt;name=ADM_strdup(&quot;H264&quot;);
-                                }
-                                else
-                                {
-                                   if(!ADM_4cc_to_lavcodec((const char *)&amp;(info-&gt;fcc),&amp;(c-&gt;codec_id)))
-                                   {
-                                      printf(&quot;[lavFormat] Cannot map  this\n&quot;);
-                                      return 0;
-                                   }
-
-                                }
-                        }
-                        if(videoExtraDataSize)
-                        {
-                                c-&gt;extradata=videoExtraData;
-                                c-&gt;extradata_size= videoExtraDataSize;
-                        }
-                        break;
-                case MUXER_MP4:
-                case MUXER_PSP:
-                {
-                        // probably a memeleak here
-                        char *foo=ADM_strdup(filename);
-                        
-                        strcpy(oc-&gt;title,ADM_GetFileName(foo));
-                        strcpy(oc-&gt;author,&quot;Avidemux&quot;);
-                        c-&gt;sample_aspect_ratio.num=1;
-                        c-&gt;sample_aspect_ratio.den=1;
-                        if(isMpeg4Compatible(info-&gt;fcc))
-                        {
-                                c-&gt;codec_id = CODEC_ID_MPEG4;
-                                c-&gt;has_b_frames=1; // in doubt...
-                        }else
-                        {
-                                if(isH264Compatible(info-&gt;fcc))
-                                {
-                                        c-&gt;has_b_frames=1; // in doubt...
-                                        c-&gt;codec_id = CODEC_ID_H264;
-                                        c-&gt;codec=new AVCodec;
-                                        memset(c-&gt;codec,0,sizeof(AVCodec));
-                                        c-&gt;codec-&gt;name=ADM_strdup(&quot;H264&quot;);
-                                }
-                                else
-                                {
-                                        if(isDVCompatible(info-&gt;fcc))
-                                        {
-                                          c-&gt;codec_id = CODEC_ID_DVVIDEO;
-                                        }else
-                                        {
-                                          if(fourCC::check(info-&gt;fcc,(uint8_t *)&quot;H263&quot;))
-                                          {
-                                                    c-&gt;codec_id=CODEC_ID_H263;
-                                            }else{
-                                                    c-&gt;codec_id = CODEC_ID_MPEG4; // Default value
-                                                    printf(&quot;Ooops, cant mux that...\n&quot;);
-                                                    printf(&quot;Ooops, cant mux that...\n&quot;);
-                                                    printf(&quot;Ooops, cant mux that...\n&quot;);
-                                                }
-                                        }
-                                }
-                        }
-                        if(videoExtraDataSize)
-                        {
-                                c-&gt;extradata=videoExtraData;
-                                c-&gt;extradata_size= videoExtraDataSize;
-                        }
-                        if(MUXER_PSP==_type)
-                        {
-                            c-&gt;rc_buffer_size=0; //8*1024*224;
-                            c-&gt;rc_max_rate=0; //768*1000;
-                            c-&gt;rc_min_rate=0;
-                            c-&gt;bit_rate=768*1000;
-                        }
-                        else
-                        {
-                            c-&gt;rc_buffer_size=8*1024*224;
-                            c-&gt;rc_max_rate=9500*1000;
-                            c-&gt;rc_min_rate=0;
-                            if(!inbitrate)
-                                    c-&gt;bit_rate=9000*1000;
-                            else
-                                    c-&gt;bit_rate=inbitrate;
-                        }
-                }
-                        break;
-                case MUXER_TS:
-                        c-&gt;codec_id = CODEC_ID_MPEG2VIDEO;
-                        c-&gt;rc_buffer_size=8*1024*224;
-                        c-&gt;rc_max_rate=9500*1000;
-                        c-&gt;rc_min_rate=0;
-                        if(!inbitrate)
-                                c-&gt;bit_rate=9000*1000;
-                        else
-                                c-&gt;bit_rate=inbitrate;
-
-                        break;
-		case MUXER_DVD:
-			c-&gt;codec_id = CODEC_ID_MPEG2VIDEO;
-			c-&gt;rc_buffer_size=8*1024*224;
-			c-&gt;rc_max_rate=9500*1000;
-			c-&gt;rc_min_rate=0;
-			if(!inbitrate)
-				c-&gt;bit_rate=9000*1000;
-			else
-				c-&gt;bit_rate=inbitrate;
-
-			break;
-		case MUXER_VCD:
-			c-&gt;codec_id = CODEC_ID_MPEG1VIDEO;
-
-			c-&gt;rc_buffer_size=8*1024*40;
-			c-&gt;rc_max_rate=1152*1000;
-			c-&gt;rc_min_rate=1152*1000;
-
-			c-&gt;bit_rate=1152*1000;
-
-
-			break;
-		case MUXER_SVCD:
-			c-&gt;codec_id = CODEC_ID_MPEG2VIDEO;
-
-			c-&gt;rc_buffer_size=8*1024*112;
-			c-&gt;rc_max_rate=2500*1000;
-			c-&gt;rc_min_rate=0*1000;
-			if(!inbitrate)
-				c-&gt;bit_rate=2040*1000;
-			else
-				c-&gt;bit_rate=inbitrate;
-
-			break;
-		default:
-			ADM_assert(0);
-	}
-
-	c-&gt;codec_type = CODEC_TYPE_VIDEO;
-	c-&gt;flags=CODEC_FLAG_QSCALE;
-	c-&gt;width = info-&gt;width;
-	c-&gt;height = info-&gt;height;
-
-       AVRational fps25=(AVRational){1001,25025};
-       AVRational fps24=(AVRational){1001,24000};
-       AVRational fps30= (AVRational){1001,30000};
-       AVRational fpsfree= (AVRational){1000,_fps1000};
-
-
-    	switch(_fps1000)
-	{
-		case 25000:
-                {
-			 c-&gt;time_base= fps25;
-			 break;
-                }
-		case 23976:
-                        if(_type==MUXER_MP4 || _type==MUXER_PSP || _type==MUXER_FLV || _type==MUXER_MATROSKA)
-                        {
-                                 c-&gt;time_base= fps24; //(AVRational){1001,24000};
-                                break;
-                        }
-		case  29970:
-			 c-&gt;time_base=fps30;
-			break;
-		default:
-                      {
-                            if(_type==MUXER_MP4 || _type==MUXER_PSP || _type==MUXER_FLV || _type==MUXER_MATROSKA)
-                            {
-                                    c-&gt;time_base=fpsfree;// (AVRational){1000,_fps1000};
-                                    break;
-                            }
-                            else
-                            {
-                                GUI_Error_HIG(QT_TR_NOOP(&quot;Incompatible frame rate&quot;), NULL);
-                                return 0;
-                            }
-                            }
-                        break;
-	}
-
-
-	c-&gt;gop_size=15;
-	c-&gt;max_b_frames=2;
-	c-&gt;has_b_frames=1;
-
-
-	// Audio
-	//________
-        if(audioheader)
-        {
-          audio_st = av_new_stream(oc, 1);
-          if (!audio_st)
-          {
-                  printf(&quot;Lav: new stream failed\n&quot;);
-                  return 0;
-          }
-
-
-          c = audio_st-&gt;codec;
-          c-&gt;frame_size=1024; //For AAC mainly, sample per frame
-          printf(&quot;[LavFormat] Bitrate %u\n&quot;,(audioheader-&gt;byterate*8)/1000);
-          _audioFq=c-&gt;sample_rate = audioheader-&gt;frequency;
-#if 0
-           if(_type== MUXER_PSP &amp;&amp; audioheader-&gt;encoding==WAV_AAC)
-            {
-                    _audioFq=c-&gt;sample_rate = audioheader-&gt;frequency/2;                 //_audioFq*=2; // SBR
-             }
-#endif
-
-          switch(audioheader-&gt;encoding)
-          {
-                  case WAV_AC3: c-&gt;codec_id = CODEC_ID_AC3;c-&gt;frame_size=6*256;break;
-                  case WAV_MP2: c-&gt;codec_id = CODEC_ID_MP2;break;
-                  case WAV_MP3:
-  #warning FIXME : Probe deeper
-                              c-&gt;frame_size=1152;
-                              c-&gt;codec_id = CODEC_ID_MP3;
-                              break;
-                  case WAV_PCM:
-                                  // One chunk is 10 ms (1/100 of fq)
-                                  c-&gt;frame_size=4;
-                                  c-&gt;codec_id = CODEC_ID_PCM_S16LE;break;
-                  case WAV_AAC:
-                                  c-&gt;extradata=audioextraData;
-                                  c-&gt;extradata_size= audioextraSize;
-                                  c-&gt;codec_id = CODEC_ID_AAC;
-                                  break;
-                  default:
-                          if(_type==MUXER_MATROSKA)
-                          {
-                           if(ADM_WaveTag_to_lavcodec(audioheader-&gt;encoding, &amp;(c-&gt;codec_id)))
-                           {
-                             if(audioextraData)
-                             {
-                                  c-&gt;extradata=audioextraData;
-                                  c-&gt;extradata_size= audioextraSize;
-                             }
-                             // Put a dummy time increment
-                              c-&gt;time_base= fps25;
-                             break;
-                           }
-                          }
-
-                          printf(&quot;Cant mux that ! audio\n&quot;);
-                          c-&gt;codec_id = CODEC_ID_MP2;
-                          return 0;
-                          break;
-          }
-          c-&gt;codec_type = CODEC_TYPE_AUDIO;
-
-          c-&gt;bit_rate = audioheader-&gt;byterate*8;
-          c-&gt;rc_buffer_size=(c-&gt;bit_rate/(2*8)); // 500 ms worth
-
-          c-&gt;channels = audioheader-&gt;channels;
-          _audioByterate=audioheader-&gt;byterate;
-
-        }
-        // /audio
-
-
-//----------------------
-	switch(_type)
-	{
-				case MUXER_FLV:
-                case MUXER_PSP:
-                case MUXER_MP4:
-                case MUXER_MATROSKA:
-                        oc-&gt;mux_rate=10080*1000; // Needed ?
-                        break;
-
-                case MUXER_TS:
-                        oc-&gt;mux_rate=10080*1000;
-                        break;
-		case MUXER_DVD:
-			oc-&gt;packet_size=2048;
-			oc-&gt;mux_rate=10080*1000;
-			break;
-		case MUXER_VCD:
-			oc-&gt;packet_size=2324;
-			oc-&gt;mux_rate=2352 * 75 * 8;
-
-			break;
-		case MUXER_SVCD:
-
-			oc-&gt;packet_size=2324;
-			oc-&gt;mux_rate=2*2352 * 75 * 8; // ?
-
-			break;
-		default:
-			ADM_assert(0);
-	}
-	oc-&gt;preload=AV_TIME_BASE/10; // 100 ms preloading
-	oc-&gt;max_delay=200*1000; // 500 ms
-
-	if (av_set_parameters(oc, NULL) &lt; 0)
-	{
-		printf(&quot;Lav: set param failed \n&quot;);
-		return 0;
-	}
-	 if (url_fopen(&amp;(oc-&gt;pb), filename, URL_WRONLY) &lt; 0)
-	 {
-	 	printf(&quot;Lav: Failed to open file :%s\n&quot;,filename);
-		return 0;
-        }
-
-	ADM_assert(av_write_header(oc)&gt;=0);
-	dump_format(oc, 0, filename, 1);
-
-
-	printf(&quot;lavformat mpeg muxer initialized\n&quot;);
-
-	_running=1;
-
-	one=(1000*1000*1000)/_fps1000;
-	_curDTS=one;
-
-	return 1;
-}
-//___________________________________________________________________________
-uint8_t lavMuxer::writeAudioPacket(uint32_t len, uint8_t *buf,uint32_t sample)
-{
-
-        int ret;
-        AVPacket pkt;
-        double f;
-        int64_t timeInUs;
-        static uint64_t sz = 0;
-            //printf(&quot;Audio paclet : size %u, sample %u\n&quot;,len,sample);
-
-           if(!audio_st) return 0;
-           if(!len) return 1;
-            av_init_packet(&amp;pkt);
-            timeInUs=(int64_t)sample2time_us(sample);
-            aprintf(&quot;Sample: %u, time: %&quot;LLU&quot;, size: %&quot;LLU&quot;, this round: %u\n&quot;,sample, timeInUs, sz, len);
-            sz+=len;
-            /* Rescale to ?? */
-            if(_type==MUXER_FLV || _type==MUXER_MATROSKA) /* The FLV muxer expects packets dated in ms, there is something i did not get... WTF */
-            {
-            			f=timeInUs/1000; // ms
-            			f=floor(f+0.4);
-            }
-            else
-            {
-            	f=timeInUs;
-            	f/=1000000.; // In sec
-            	f*=_audioFq; // In samples
-            	f=floor(f+0.4);
-            }
-            pkt.dts=pkt.pts=f;
-            aprintf(&quot;Adm audio dts: %&quot;LLU&quot;\n&quot;,pkt.dts);
-            //printf(&quot;F:%f Q:%u D=%u\n&quot;,f,pkt.pts,timeInUs-_lastAudioDts);
-
-            pkt.flags |= PKT_FLAG_KEY;
-            pkt.data= buf;
-            pkt.size= len;
-            pkt.stream_index=1;
-            //pkt.duration=pkt.dts-_lastAudioDts; // Duration
-            aprintf(&quot;A: sample: %d, frame_pts: %&quot;LLU&quot;, fq: %d\n&quot;, sample, pkt.dts, audio_st-&gt;codec-&gt;sample_rate);
-
-            ret = av_write_frame(oc, &amp;pkt);
-            _lastAudioDts=timeInUs;
-            if(ret)
-            {
-                        printf(&quot;[LavFormat]Error writing audio packet\n&quot;);
-                        printf(&quot;[LavFormat]pts %llu dts %llu\n&quot;,pkt.pts,pkt.dts);
-                        return 0;
-            }
-            return 1;
-}
-//________________________________________________________________________
-uint64_t  lavMuxer::sample2time_us( uint32_t sample )
-{
-double f;
-
-                f=sample;
-                f*=1000.*1000.;
-                f/=_audioFq;              // Sample / Frequency = time in seconds *10E6 to get in in us
-
-                return (uint64_t)floor(f);
-
-}
-//___________________________________________________________________________
-uint8_t lavMuxer::needAudio( void )
-{
-
-        if(!audio_st) return 0;
-
-	double f;
-	uint64_t dts=_lastAudioDts;  // Last audio dts
-
-
-		aprintf(&quot;Need audio  ?: %llu / %llu : %llu\n &quot;,dts,_curDTS,_curDTS+one);
-		if((dts+5000&gt;=_curDTS) &amp;&amp; (dts&lt;=_curDTS+one)) return 1;
-		if(dts&lt;=_curDTS)
-		{
-			printf(&quot;LavMuxer:Audio DTS is too low %llu / %llu!\n&quot;,dts,_curDTS);
-			return 1;
-		}
-		return 0;
-}
-//___________________________________________________________________________
-uint8_t lavMuxer::writeVideoPacket(ADMBitstream *bitstream)
-{
-int ret;
-
-double p,d;
-  	AVPacket pkt;
-            av_init_packet(&amp;pkt);
-
-        p=bitstream-&gt;ptsFrame+1;      // Pts           // Time p/fps1000=out/den  out=p*den*1000/fps1000
-        p=(p*1000*1000*1000);
-        p=p/_fps1000;                  // in us
-
-        d=bitstream-&gt;dtsFrame;		// dts
-	d=(d*1000*1000*1000);
-	d=d/_fps1000;
-
-
-	_curDTS=(int64_t)floor(d);
-    aprintf(&quot;Adm video unscaled dts=:%u\n&quot;,(uint32_t)d);
-        // Rescale
-#define RESCALE(x) x=x*1000.;\
-                   x=x/_fps1000;
-
-        p=bitstream-&gt;ptsFrame+1;
-        RESCALE(p);
-// MP4/ TS
-        d=bitstream-&gt;dtsFrame;  // p &amp; d are now in seconds
-        RESCALE(d);
-        switch(_type)  // video_st-&gt;codec-&gt;time_base.den
-        {
-        case MUXER_FLV :
-        case MUXER_MATROSKA:
-                    {
-                        p=p*1000;
-                        d=d*1000; // in milliseconds
-                        break;
-                    }
-        
-        default:
-                    p=p*video_st-&gt;codec-&gt;time_base.den;
-                    d=d*video_st-&gt;codec-&gt;time_base.den;
-                    break;
-        }
-    	pkt.dts=(int64_t)floor(d);
-    	pkt.pts=(int64_t)floor(p);
-
-       // printf(&quot;Lavformat : Pts :%u dts:%u&quot;,displayframe,frameno);
-	aprintf(&quot;Lavformat : Pts :%llu dts:%llu&quot;,pkt.pts,pkt.dts);
-	pkt.stream_index=0;
-
-        pkt.data= bitstream-&gt;data;
-        pkt.size= bitstream-&gt;len;
-	// Look if it is a gop start or seq start
-        if(_type==MUXER_MP4 || _type==MUXER_PSP || _type==MUXER_FLV || _type==MUXER_MATROSKA)
-        {
-            if(bitstream-&gt;flags &amp; AVI_KEY_FRAME)
-                        pkt.flags |= PKT_FLAG_KEY;
-        }else
-            if(!bitstream-&gt;data[0] &amp;&amp;  !bitstream-&gt;data[1] &amp;&amp; bitstream-&gt;data[2]==1)
-	{
-            if(bitstream-&gt;data[3]==0xb3 || bitstream-&gt;data[3]==0xb8 ) // Seq start or gop start
-		pkt.flags |= PKT_FLAG_KEY;
-		//printf(&quot;Intra\n&quot;);
-	}
-    //printf(&quot;Adm video dts=:%u\n&quot;,pkt.dts);
-	ret =av_write_frame(oc, &amp;pkt);
-	if(ret)
-	{
-		printf(&quot;[LavFormat]Error writing video packet\n&quot;);
-		return 0;
-	}
-        aprintf(&quot;V: frame %lu pts%d\n&quot;,bitstream-&gt;dtsFrame,pkt.pts);
-
-	return 1;
-}
-//___________________________________________________________________________
-uint8_t lavMuxer::forceRestamp(void)
-{
-	return 1;
-}
-//___________________________________________________________________________
-uint8_t lavMuxer::close( void )
-{
-	if(_running)
-	{
-		_running=0;
-		// Flush
-		// Cause deadlock :
-		av_write_trailer(oc);
-		url_fclose((oc-&gt;pb));
-
-	}
-	if(audio_st)
-	{
-		 av_free(audio_st);
-	}
-	if(video_st)
-	{
-		 av_free(video_st);
-	}
-	video_st=NULL;
-	audio_st=NULL;
-	if(oc)
-		av_free(oc);
-	oc=NULL;
-	return 1;
-}
-//___________________________________________________________________________
-uint8_t lavMuxer::audioEmpty( void)
-{
-	return 0;
-}
-extern &quot;C&quot;
-{
-     extern  int        mpegps_init(void );
-     extern  int        movenc_init(void );
-     extern  int        flvenc_init(void );
-     extern  int        matroskaenc_init(void );
-};
-extern URLProtocol file_protocol ;
-uint8_t lavformat_init(void)
-{
-                movenc_init();
-                flvenc_init();
-                matroskaenc_init();
-                register_protocol(&amp;file_protocol);
-}
-extern &quot;C&quot;
-{
-/**
-    \fn ADM_useAlternateTagging
-    \brief returns 1 if using haali compatible tagging, 0 if normal. For mp3 in mp4ff.
-*/
-int ADM_useAlternateTagging(void)
-{
-  uint32_t v=1;
-  prefs-&gt;get(FEATURE_ALTERNATE_MP3_TAG,&amp;v);
-  return v;
-}
-}
-
-typedef struct
-{
-  const char *name;
-  int    id;
-}lavFCC_t;
-
-lavFCC_t lavFCC[]=
-{
-  {&quot;DIV3&quot;,CODEC_ID_MSMPEG4V3},
-  {&quot;FLV1&quot;,CODEC_ID_FLV1},
-  {&quot;MPEG&quot;,CODEC_ID_MPEG2VIDEO},
-  {&quot;DUMMY&quot;,0Xffff}
-};
-/**
-    \fn ADM_4cc_to_lavcodec
-    \brief Convert avi fourcc to lavcodec id (video)
-
-*/
-uint8_t ADM_4cc_to_lavcodec(const char *fcc, CodecID *outlavid)
-{
-    uint32_t nb=sizeof( lavFCC)/sizeof(lavFCC_t);
-    nb--;
-    for(int i=0;i&lt;nb;i++)
-    {
-      if(!strncmp(lavFCC[i].name,fcc,4))
-      {
-        *outlavid=(CodecID)lavFCC[i].id;
-        return 1;
-      }
-
-    }
-    return 0;
-
-}
-//*****************
-typedef struct
-{
-  uint32_t tag;
-  int    id;
-}lavWaveTag_t;
-
-lavWaveTag_t lavWaveTag[]=
-{
-  {WAV_AC3,CODEC_ID_AC3},
-  {WAV_OGG,CODEC_ID_VORBIS},
-  {WAV_AAC,CODEC_ID_AAC},
-  {0xdead,0Xffff} // DUMMY
-};
-/**
-    \fn ADM_WaveTag_to_lavcodec
-    \brief Convert ADM audio codec id to lavcodec id (video)
-
-*/
-uint8_t ADM_WaveTag_to_lavcodec(uint32_t tag, CodecID *outlavid)
-{
-    uint32_t nb=sizeof( lavWaveTag)/sizeof(lavWaveTag_t);
-    nb--;
-    for(int i=0;i&lt;nb;i++)
-    {
-      if(lavWaveTag[i].tag==tag)
-      {
-        *outlavid=(CodecID)lavWaveTag[i].id;
-        return 1;
-      }
-
-    }
-    return 0;
-
-}
-
-//___________________________________________________________________________
-//EOF
-
-

Deleted: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/ADM_lavformat.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/ADM_lavformat.h	2009-07-23 18:18:44 UTC (rev 5131)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/ADM_lavformat.h	2009-07-23 18:18:46 UTC (rev 5132)
@@ -1,168 +0,0 @@
-//
-// C++ Interface: ADM_lavformat
-//
-// Description: 
-//
-//	iface to libavformat	
-//
-//
-// Author: mean &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>&gt;, (C) 2004
-//
-// Copyright: See COPYING file that comes with this distribution
-//
-//
-#ifndef ADM_LAVFORMAT_H
-#define ADM_LAVFORMAT_H
-#include &quot;ADM_bitstream.h&quot;
-typedef enum
-{
-        MUXER_NONE=0,
-        MUXER_DVD,
-		MUXER_VCD,
-		MUXER_SVCD,
-        MUXER_TS,
-        MUXER_MP4,
-        MUXER_PSP,
-        MUXER_FLV,
-        MUXER_MATROSKA,
-        MUXER_DUMMY
-}ADM_MUXER_TYPE;
-
-/*
-class ADMMpegMuxer
-{
-protected:
-                uint32_t _frameNo;
-                uint32_t _fps1000;
-                uint32_t _audioByterate;
-                uint32_t _audioFq;
-                uint32_t _total; // deprecated, only for muxts
-                uint64_t _lastAudioDts;
-                uint32_t _running;
-                ADM_MUXER_TYPE _type;
-                uint8_t  _restamp;
-                ADM_MUXER_TYPE _muxerType;
-
-public:
-        virtual uint8_t open(const char *filename,uint32_t inbitrate, ADM_MUXER_TYPE type, 
-                                aviInfo *info, WAVHeader *audioheader)=0;
-        virtual uint8_t writeAudioPacket(uint32_t len, uint8_t *buf)=0;
-        virtual uint8_t writeVideoPacket(ADMBitstream *bitstream )=0;
-        virtual uint8_t forceRestamp(void)=0;
-        virtual uint8_t close( void )=0;
-        virtual uint8_t audioEmpty( void)=0;
-        virtual uint8_t needAudio(void)=0;
-        virtual uint8_t audioEof(void) {return 1;}
-
-                ADMMpegMuxer(void) {};
-                virtual ~ADMMpegMuxer(void) {};
-
-};
-class lavMuxer : public ADMMpegMuxer
-{
-private:
-                uint64_t  sample2time_us( uint32_t sample );
-		
-
-public:
-		lavMuxer(void );
-		~lavMuxer(  );
-	virtual uint8_t open(const char *filename,uint32_t inbitrate, ADM_MUXER_TYPE type, aviInfo *info, WAVHeader *audioheader);
-        virtual uint8_t open(const char *filename,uint32_t inbitrate, ADM_MUXER_TYPE type, aviInfo *info,uint32_t videoExtraDataSize,
-                        uint8_t *videoExtraData, WAVHeader *audioheader,uint32_t audioextraSize,uint8_t *audioextraData);
-        
-        virtual uint8_t writeAudioPacket(uint32_t len, uint8_t *buf,uint32_t sample);
-        virtual uint8_t writeAudioPacket(uint32_t len, uint8_t *buf) { ADM_assert(0);return 1;}
-        virtual uint8_t writeVideoPacket(ADMBitstream *bitstream );
-        virtual uint8_t forceRestamp(void);
-        virtual uint8_t close( void );
-        virtual uint8_t audioEmpty( void);
-        virtual uint8_t needAudio(void);
-
-	
-
-};
-
-class mplexMuxer : public ADMMpegMuxer
-{
-protected:
-               
-public:
-                mplexMuxer(void );
-                ~mplexMuxer(  );
-        virtual uint8_t open(const char *filename,uint32_t inbitrate, ADM_MUXER_TYPE type, aviInfo *info, WAVHeader *audioheader);
-        virtual uint8_t writeVideoPacket(ADMBitstream *bitstream );
-        virtual uint8_t writeAudioPacket(uint32_t len, uint8_t *buf);
-        virtual uint8_t forceRestamp(void);
-        virtual uint8_t close( void );
-        virtual uint8_t audioEmpty( void);
-        virtual uint8_t needAudio(void);
-        virtual uint8_t audioEof(void);
-        virtual uint8_t videoEof(void);
-
-};*/
-#define TS_PACKET_SIZE 188
-
-typedef struct
-{
-    uint64_t pts;
-    uint8_t  packet[TS_PACKET_SIZE];
-}entryPacket;
-
-typedef struct
-{
-    uint32_t pid;
-    uint32_t counter;
-    uint32_t tableId;
-    uint32_t sectionId;
-}channel;
-/*
-class tsMuxer : public ADMMpegMuxer
-{
-protected:
-        uint32_t    audioPacket;
-        entryPacket *packetPipe;
-        uint32_t    packetHead,packetTail;
-        FILE        *outFile;     
-        uint32_t    audioPid,videoPid;
-        uint32_t    _curPTS;
-        uint32_t    nbPacket;
-        uint32_t    packetSincePAT;
-        uint64_t    lastPCR;
-        uint8_t     *audioBuffer;
-        uint32_t    audioFill;
-        uint8_t     *pesBuffer;
-        
-        entryPacket *getPacket( void);   
-        uint8_t     writeSection( uint32_t pid,channel *chan, 
-                                uint8_t *data, uint32_t len) ;
-        uint8_t     writePmt( void); 
-        uint8_t     writePat( void);                       
-        uint8_t     writePacket(uint8_t *data, uint32_t len, uint64_t pcr,channel *chan,uint8_t start);
-        uint8_t     writePacketPad(uint8_t *data, uint32_t len, uint64_t pcr,channel *chan,uint8_t start);
-        uint64_t    audioTime( uint32_t time)   ;            // Time is us
-        uint64_t    videoTime( uint32_t frameno);   // Time in us                    
-        uint8_t     flushPackets(uint8_t r);
-        uint8_t     writeAudioPacket2(void);
-        uint8_t     pes2ts(channel *chan,uint64_t pcr,uint8_t tim );
-        uint8_t     writeVideoPacket2(uint32_t len, uint8_t *buf,uint32_t frameno,uint32_t displayframe );
-        channel     audioChannel,videoChannel,pmt,pat;
-        aviInfo     _info;
-        WAVHeader   _wavHeader;
-             
-public:
-                tsMuxer(void );
-                ~tsMuxer(  );
-        virtual uint8_t open(const char *filename,uint32_t inbitrate, ADM_MUXER_TYPE type, aviInfo *info, WAVHeader *audioheader);
-        virtual uint8_t writeVideoPacket(ADMBitstream *bitstream );
-        virtual uint8_t writeAudioPacket(uint32_t len, uint8_t *buf);
-        virtual uint8_t forceRestamp(void);
-        virtual uint8_t close( void );
-        virtual uint8_t audioEmpty( void);
-        virtual uint8_t needAudio(void);
-
-};
-*/
-#endif
-//EOF
-

Deleted: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/ADM_muxts.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/ADM_muxts.cpp	2009-07-23 18:18:44 UTC (rev 5131)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/ADM_muxts.cpp	2009-07-23 18:18:46 UTC (rev 5132)
@@ -1,708 +0,0 @@
-//
-// C++ Implementation: ADM_lavformat
-//
-// Description: 
-//
-//
-// Author: mean &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>&gt;, (C) 2004
-//
-// Copyright: See COPYING file that comes with this distribution
-//
-//
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-#include &quot;config.h&quot;
-
-#include &lt;stdio.h&gt;
-#include &lt;stdlib.h&gt;
-#include &lt;math.h&gt;
-#include &lt;string.h&gt;
-
-
-#include &quot;ADM_assert.h&quot;
-
-#include &quot;ADM_default.h&quot;
-
-
-#include &quot;ADM_audiofilter/audioprocess.hxx&quot;
-#include &quot;ADM_audio/ADM_a52info.h&quot;
-
-#include &quot;ADM_codecs/ADM_codec.h&quot;
-#include &quot;ADM_editor/ADM_Video.h&quot;
-
-#include &quot;ADM_lavformat.h&quot;
-
-
-#include &quot;ADM_osSupport/ADM_debugID.h&quot;
-#define MODULE_NAME MODULE_LAVFORMAT
-#include &quot;ADM_osSupport/ADM_debug.h&quot;
-#include &quot;ADM_tscrc.h&quot;
-
-
-#define TS_NB_PACKET   1000
-
-#define PAT_PID         0
-#define PMT_PID         0x42
-#define AUDIO_PID       0x45
-#define VIDEO_PID       0x44
-
-#define TS_HEADER_LEN 4
-
-#define TS_UNIT_START        0x40
-#define TS_UNIT_PAYLOAD_ONLY 0x10
-#define TS_UNIT_PAYLOAD_AF   0x30
-// 33 bits 
-#define TS_PCR_MASK             0x0000003FFFFFFFFFLL
-#define TS_NO_PCR               0xFF00000000000000LL
-#define TS_PAT_EVERY_PACKET     256
-#define TS_MUX_RATE             10000000        // 10 Mbs
-
-#define AUDIO_BUFFER            1024*10
-#define PES_BUFFER              1024            // Just to build packet into
-#define STUFFING_PATTERN        0
-#define MUX_EVERY_N_AUDIO_FRAMES 5
-static uint8_t writePts(uint8_t *data,uint64_t ipts,uint32_t flags);
-// /* ------------------------------------------------------------------------*/write
-tsMuxer::tsMuxer( void)
-{
-    packetPipe=new entryPacket[TS_NB_PACKET];
-    memset(packetPipe,0,sizeof(entryPacket)*TS_NB_PACKET);
-    packetHead=packetTail=0;
-    
-    audioChannel.pid=AUDIO_PID;
-    audioChannel.counter=0;
-    
-    videoChannel.pid=VIDEO_PID;
-    videoChannel.counter=0;
-    
-    pat.pid=PAT_PID;
-    pat.counter=0;
-    pat.tableId=0;
-    pat.sectionId=0;
-    
-    pmt.pid=PMT_PID;
-    pmt.counter=0;
-    pmt.tableId=2;
-    pmt.sectionId=1;
-    
-    _total=0;
-    _curPTS=0;
-    
-    packetSincePAT=0;
-    nbPacket=0;
-    lastPCR=0;
-    audioFill=0;
-    audioBuffer=new uint8_t[AUDIO_BUFFER];
-    pesBuffer=new uint8_t [PES_BUFFER];
-    audioPacket=0;
-}
-tsMuxer::~tsMuxer( )
-{
-   if(packetPipe)
-    delete [] packetPipe;
-   packetPipe=NULL;
-   if(audioBuffer)
-        delete [] audioBuffer;
-   audioBuffer=NULL;
-   if(pesBuffer)
-        delete [] pesBuffer;
-   pesBuffer=NULL;
-
-}
-//
-// Flush out of data packets
-// update pcr on the fly with non stupid value
-//
-uint8_t tsMuxer::flushPackets(uint8_t really)
-{
-double dpcr;    // delta PCR
-uint64_t pcr,packetpcr;
-entryPacket *entry;
-        
-        dpcr=TS_PACKET_SIZE*8;
-        dpcr/=TS_MUX_RATE;      
-        dpcr=dpcr*1000*1000;        // duration of a packet in us
-        pcr=(uint64_t )dpcr;
-        while(1)
-        {
-            if(packetHead==packetTail) break; // no more packet to handle
-            entry=&amp;(packetPipe[packetHead]);
-#if 0            
-            if(entry-&gt;pts!=TS_NO_PCR)
-            {
-                if(entry-&gt;pts&gt;=_curPTS) _curPTS=entry-&gt;pts;
-                    else
-                {
-                    // need to update
-                    uint32_t i=4;
-                    uint64_t fixed;
-                    uint8_t *pkt=entry-&gt;packet;
-                    
-                    fixed=_curPTS;
-                     //mask to avoid overflow
-                    fixed=(fixed*90)/1000;
-                    fixed=fixed&amp;0x1FFFFFFFFLL; // 33 Bits
-                    pkt[i++]=7;
-                    pkt[i++]=0x10; // AF flags       
-                    pkt[i++]=(fixed&gt;&gt;25)&amp;0xff; // FF
-                    pkt[i++]=(fixed&gt;&gt;17)&amp;0xff; // FF
-                    pkt[i++]=(fixed&gt;&gt;9)&amp;0xff; // FF
-                    pkt[i++]=(fixed&gt;&gt;1)&amp;0xff; // FF
-                    pkt[i++]=(fixed&lt;&lt;7)&amp;0x80; // &amp;0x80
-                    pkt[i++]=0x00;
-                }
-            }
-#endif            
-           // _curPTS+=pcr;
-            fwrite(entry-&gt;packet,TS_PACKET_SIZE,1,outFile);
-            packetHead++;
-            packetHead%=TS_NB_PACKET;
-        }
-        return 1;
-}
-/*
-sync_byte 8 bslbf 
-transport_error_indicator 1 bslbf       1: Error present
-payload_unit_start_indicator 1 bslbf    If 1 a unit start in this packet, there is an offset later
-transport_priority 1 bslbf              x
-PID 13 uimsbf 
-transport_scrambling_control 2 bslbf  00 not scrambled
-adaptation_field_control 2 bslbf      00 01:Payload only 10:adap only 11: payload + adap
-continuity_counter 4 uimsbf 
-if(adaptation_field_control=='10' || adaptation_field_control=='11
-'){ adaptation_field() }
-if(adaptation_field_control=='01' || adaptation_field_control=='11') 
-{ for (i=0;i&lt;N;i++){ data_byte 8 bslbf } } } bslbf Bit string, 
-
-pcr is pts in us
-*/
-uint8_t     tsMuxer::writePacket(uint8_t *data, uint32_t len, uint64_t pcr,channel *chan,uint8_t start)
-{
-
-uint32_t i=0,val=0,fill=0,fre;
-entryPacket *paket;
-uint8_t *pkt;
-
-    if(start)
-      if(((packetTail+TS_NB_PACKET-packetHead)%TS_NB_PACKET)&gt;TS_NB_PACKET/4)
-      {  
-            flushPackets(0);    
-      }
-     
-    //ADM_assert(len&lt;TS_PACKET_SIZE-3);
-    if(!packetSincePAT)
-    {
-        packetSincePAT++;
-        writePat();
-        writePmt();
-    }
-    else
-        packetSincePAT++;
-    packetSincePAT%=TS_PAT_EVERY_PACKET;
-    
-    //
-    paket=getPacket();
-    paket-&gt;pts=pcr;
-    pkt=paket-&gt;packet;
-
-    // Here we go
-
-        // Will we fill the packet
-        fre=TS_PACKET_SIZE-TS_HEADER_LEN;
-        if(start)       fre--;  // offset
-        if(pcr!=TS_NO_PCR) fre-=8;
-        if(len&lt;fre) // We won't fill the packet
-        {
-                fill=fre-len;
-        }
-
-    pkt[i++]=0x47;
-    if(start) val=TS_UNIT_START; // Start ?
-            else val=0;
-    pkt[i++]=val+((chan-&gt;pid)&gt;&gt;8);
-    pkt[i++]=(chan-&gt;pid)&amp;0xff;
-   
-    if(pcr!=TS_NO_PCR || fill)
-        val=TS_UNIT_PAYLOAD_AF;     // if me put a pcr, we need to say there is
-                                    // an adaption field
-    else
-        val=TS_UNIT_PAYLOAD_ONLY;
-    pkt[i++]=val+(chan-&gt;counter&amp;0xf);  // Payload only
-    chan-&gt;counter++;
-    if(pcr!=TS_NO_PCR || fill)
-    {
-        if(pcr!=TS_NO_PCR)
-        {
-        
-                pcr=(pcr*90)/1000;
-                pcr=pcr&amp;0x1FFFFFFFFLL; //mask to avoid overflow
-                pkt[i++]=7+fill;
-                pkt[i++]=0x10; // AF flags
-        
-                pkt[i++]=(pcr&gt;&gt;25)&amp;0xff; // FF
-                pkt[i++]=(pcr&gt;&gt;17)&amp;0xff; // FF
-                pkt[i++]=(pcr&gt;&gt;9)&amp;0xff; // FF
-                pkt[i++]=(pcr&gt;&gt;1)&amp;0xff; // FF
-                pkt[i++]=(pcr&lt;&lt;7)&amp;0x80; // &amp;0x80
-                pkt[i++]=0x00;
-                if(fill)
-                {
-                        memset(pkt+i,0xff,fill);        
-                        i+=fill;
-                }
-        }
-        else
-        {
-                pkt[i++]=fill-1;
-                switch(fill)
-                {
-                        case 1: break;
-                        case 2: pkt[i++]=0;
-                                break;
-                        default:
-                                pkt[i++]=0;
-                                memset(pkt+i,0xff,fill-2);   
-                                i+=fill-2;
-                                break;
-                }
-        }
-     }
-
-    
-    if(start) pkt[i++]=0; // pointer field
-    uint32_t left=TS_PACKET_SIZE-i;
-    ADM_assert(len&gt;=left);
-    memcpy(pkt+i,data,left);
-    return left;
-}
-
-uint32_t mpegTsCRC(uint8_t *data, uint32_t len)
-{
-    int i;
-    uint32_t crc = 0xffffffff;
-    
-    for (i=0; i&lt;len; i++)
-        crc = (crc &lt;&lt; 8) ^ crc_table[((crc &gt;&gt; 24) ^ *data++) &amp; 0xff];
-    
-    return crc;
-}
-/*****************************/
-entryPacket *tsMuxer::getPacket( void)
-{
- 
- entryPacket *r=&amp;packetPipe[packetTail++];
- packetTail%=TS_NB_PACKET;
- ADM_assert(packetTail!=packetHead);
- return r;   
-}
-
-uint8_t tsMuxer::open(const char *filename,uint32_t inbitrate, ADM_MUXER_TYPE type, aviInfo *info, WAVHeader *audioheader)
-{
-    ADM_assert(type==MUXER_TS);
-    outFile=fopen(filename,&quot;wb&quot;);
-    if(!outFile)
-    {
-        printf(&quot;TS:Cannot open for write\n&quot;);
-        return 0; 
-    }
-    memcpy(&amp;_info,info,sizeof(_info));
-    memcpy(&amp;_wavHeader,audioheader,sizeof(_wavHeader));
-    
-    return 1;
-}
-uint8_t tsMuxer::close( void)
-{
-    flushPackets(1);    
-    if(outFile) fclose(outFile);
-    outFile=NULL;
-    return 1;
-}
-uint8_t tsMuxer::forceRestamp(void)
-{
-    return 1;
-}
-uint8_t tsMuxer::audioEmpty( void)
-{
-    return 0;
-}
-uint8_t tsMuxer::needAudio(void)
-{
-	
-    double f;
-    uint64_t pts;
-    // all computation is in us
-    uint32_t one=(1000*1000*1000)/_info.fps1000;
-    
-            pts=audioTime(audioFill);
-            aprintf(&quot;Need audio  ?: %llu / %llu : %llu\n &quot;,pts,_curPTS,_curPTS+one);
-            if((pts&gt;=_curPTS) &amp;&amp; (pts&lt;=_curPTS+one)) return 1;
-            if(pts&lt;=_curPTS)
-            {
-                    printf(&quot;tsMuxer:Audio DTS is too low %llu / %llu!\n&quot;,pts,_curPTS);
-                    return 1;
-            }
-            return 0;
-}
-/*
-    Write the program Access Table
-    In our case it is pretty simple as we have one video and one audio
-    in one PMT
-    We assume it fits in one TS packet
-
-    8 :Table id
-    1 :Section syntax indicator (1 for PAT)
-    1: 0
-    2: 11
-    12: length
-    16: Transport ID
-    2 : 11
-    5: Version number
-    1: current next indicator
-    8 : : section number
-    8:last section number
-        8: Program number
-        3: 111
-        13: Nit pid
-    32 : CRC    
-*/
-uint8_t tsMuxer::writeSection( uint32_t pid,channel *chan, 
-                                uint8_t *data, uint32_t len)
-{
-    uint8_t packet[1024];
-    uint32_t i=0,sectionLen=0,crc;
-    
-    sectionLen=len+4+5; // Includes header &amp; crc
-    
-    packet[i++]=chan-&gt;tableId;
-    packet[i++]=0xb0+(sectionLen&gt;&gt;8);
-    packet[i++]=0x00+(sectionLen&amp;0xff);
-    packet[i++]=chan-&gt;sectionId&gt;&gt;8;     // For PMT: Program number
-    packet[i++]=chan-&gt;sectionId&amp;0xff;
-    packet[i++]=0xc1;   // Table is applicable
-    packet[i++]=0;      // section  number
-    packet[i++]=0;      // last section number
-    
-    memcpy(packet+i,data,len);
-    i+=len;
-    //ADM_assert(len&lt;TS_PACKET_SIZE-3);
-    // and CRC
-    crc= mpegTsCRC(packet,i);
-    packet[i++]=(crc&gt;&gt;24)&amp;0xff;
-    packet[i++]=(crc&gt;&gt;16)&amp;0xff;
-    packet[i++]=(crc&gt;&gt;8)&amp;0xff;
-    packet[i++]=(crc    )&amp;0xff;
-   
-  //  writePacket(packet,i,NO_PCR);
-    writePacket(packet, i, TS_NO_PCR,chan,1);
-    return 1;
-}
-uint8_t tsMuxer::writePat( void)
-{
-uint8_t data[1024];
-uint32_t i=0,sid=1;
-
-        sid=pmt.sectionId;
-        data[i++]=sid&gt;&gt;8;                
-        data[i++]=sid&amp;0xff;                        
-        data[i++]=0xe0+((pmt.pid)&gt;&gt;8);                
-        data[i++]=(pmt.pid)&amp;0xff;    
-        return writeSection(pat.pid,&amp;pat,data,4);                    
-                                
-}   
-uint8_t tsMuxer::writePmt( void)
-{
-uint8_t data[1024];
-uint32_t i=0,sid=1;
-
-        data[i++]=0xE0+(videoChannel.pid&gt;&gt;8);  // PCR pid locked on audio             
-        data[i++]=videoChannel.pid&amp;0xff;       //                 
-        data[i++]=0xf0;  // info length              
-        data[i++]=0;  // info length   
-        //-- Video --
-        data[i++]=0x02; // Mpeg2 video
-        data[i++]=0xE0+(videoChannel.pid&gt;&gt;8); // pid
-        data[i++]=(videoChannel.pid&amp;0xff); 
-        data[i++]=0xF0; // no descriptor
-        data[i++]=3;    // Stream descriptor
-        data[i++]=0x52;    
-        data[i++]=1;    
-        data[i++]=1;    
-        //-- Audio --
-        if(_wavHeader.encoding==WAV_AC3)
-            data[i++]=0x81; // ac3
-        else
-            data[i++]=0x03; // Mpeg2 audio
-        data[i++]=0xE0+(audioChannel.pid&gt;&gt;8); // pid
-        data[i++]=(audioChannel.pid&amp;0xff); 
-        data[i++]=0xF0; // no descriptor
-        data[i++]=3+6;    // Stream descriptor
-        data[i++]=0x52;    
-        data[i++]=1;    
-        data[i++]=2;    
-        data[i++]=0x0a; // Language    
-        data[i++]=4;    
-        data[i++]='e';    
-        data[i++]='n';    
-        data[i++]='g';    
-        data[i++]=0x02;     // Hearing impaired ?
-        
-        
-/*        data[2]=0xF0+((i-4)&gt;&gt;8);
-        data[3]=((i-4)&amp;0xff);
-*/        
-        return writeSection(pmt.pid,&amp;pmt,data,i);                          
-                                
-} 
-uint8_t tsMuxer::pes2ts(channel *chan,uint64_t pcr,uint8_t tim )
-{
-        uint32_t part=0,l;
-        uint32_t out=PES_BUFFER;
-        uint8_t *data=pesBuffer;
-        while(out)
-        {
-                if(!part &amp;&amp; tim)
-                {
-                        l=writePacket(data,out,pcr,chan,1);
-                }
-                else
-                        l=writePacket(data,out,TS_NO_PCR,chan,0);
-                out-=l;
-                data+=l;
-                part++;
-        }
-        return 1;
-}
-uint8_t tsMuxer::writeVideoPacket(ADMBitstream *bitstream )
-{
-#define MAX_PES 64000
-uint32_t l,len;
-uint8_t *buf;
-
-       //writeAudioPacket2();
-       _curPTS=videoTime(bitstream-&gt;dtsFrame); 
-       len=bitstream-&gt;len;
-       buf=bitstream-&gt;data;
-       while(len)
-       {
-                if(len&gt;MAX_PES)
-                        l=MAX_PES;
-                else
-                    l=len;
-                if(!writeVideoPacket2(l,buf, bitstream-&gt;dtsFrame, bitstream-&gt;ptsFrame ))
-                {
-                    return 0;    
-                }
-                len-=l;
-                buf+=l;
-        }
-        return 1;
-
-}                                  
-uint8_t tsMuxer::writeVideoPacket2(uint32_t len, uint8_t *buf,uint32_t frameno,uint32_t displayframe )
-{
-    
-    uint8_t  *data;
-    uint32_t pes_len;
-    uint64_t its;
-    double d;
-    uint32_t left,part=1;
-    
-//#define IGNORE_PTS
-        
-#ifdef IGNORE_PTS
-        displayframe=frameno+1;
-#endif    
-
-    // First packet    
-    while(len)
-    {
-            
-            // we build header &amp; pts separately
-            //
-            uint32_t i=0,left;
-            data=pesBuffer;
-            if(part)
-            {
-            
-                //data[i++]=0x00;
-                data[i++]=0x00;
-                data[i++]=0x01;
-                data[i++]=0xe0;   // video id
-                pes_len=len+3+10;  // PES header
-                data[i++]=pes_len&gt;&gt;8;
-                data[i++]=pes_len &amp; 0xff;
-                data[i++]=0x80; // mpeg2
-           
-                data[i++]=0x80+0x40; // PTS + dts
-                data[i++]=10;    // PTS LEN
-            
-                // pts
-                
-                its=videoTime(displayframe);
-                writePts(data+i,its,3);
-                data[i]|=0x10;
-                i+=5;
-                // dts
-                its=videoTime(frameno);
-                writePts(data+i,its,1);
-                i+=5;                
-
-                left=TS_PACKET_SIZE-i;
-                if(left&gt;len)
-                {
-                      left=len;
-
-                }
-                memcpy(data+i,buf,left);                      
-                left=writePacket(data, i+len, its,&amp;videoChannel,1);
-                left=left-i;
-            }
-            else
-            {
-                left=writePacket(buf, len, TS_NO_PCR,&amp;videoChannel,0);
-            }
-
-            buf+=left;
-            len-=left;                   
-            part=0;
-     }    
-    return 1;
-}
-/* Return time elapsed for video in us */
-uint64_t tsMuxer::videoTime( uint32_t frameno)
-{
-double d;
-uint64_t p;
-    d=frameno;		// dts
-    d=(d*1000*1000*1000);
-    d=d/_info.fps1000; // in usec
-    
-    p= (uint64_t)floor(d);
-   
-    return p;
-}    
-/* Return time elapsed for audio in us */
-uint64_t tsMuxer::audioTime( uint32_t fill)
-{
-double f;
-uint64_t d;
-    f=_total+fill;
-     f*=1000.*1000.;  // in us
-     f/=(_wavHeader.byterate);   
-     d= (uint64_t)floor(f);
-     
-     return d;
-}
-uint8_t tsMuxer::writeAudioPacket(uint32_t len, uint8_t *buf)
-{
-        memcpy(audioBuffer+audioFill,buf,len);
-        audioFill+=len;
-        audioPacket++;
-        ADM_assert(audioFill&lt;AUDIO_BUFFER);
-        if(audioPacket&gt;=MUX_EVERY_N_AUDIO_FRAMES)
-        {
-                writeAudioPacket2();
-                audioPacket%=MUX_EVERY_N_AUDIO_FRAMES;
-        }
-        return 1;        
-}
-uint8_t tsMuxer::writeAudioPacket2(void)
-{
-    uint32_t part=1;
-    uint8_t  *data; // should be enough for one frame...    
-    uint64_t ipts;   
-    uint32_t left,pes_len;
-    uint8_t  *buf=audioBuffer;
-    uint32_t len=audioFill,org=audioFill;    
-    uint64_t its;
-
-    if(!audioFill) return 1; // nothing to do
-
-
-     while(len)
-    {
-            
-            // we build header &amp; pts separately
-            //
-            uint32_t i=0,left;
-            data=pesBuffer;
-            if(part)
-            {
-            
-                //data[i++]=0x00;
-                data[i++]=0x00;
-                data[i++]=0x01;
-               // data[i++]=0xc0;   // video id
-                if(_wavHeader.encoding==WAV_AC3)
-                {
-                        data[i++]=0xbd;   // audio id
-                }
-                else
-                        data[i++]=0xc0;   // audio id
-
-                pes_len=len+3+5;  // PES header
-                data[i++]=pes_len&gt;&gt;8;
-                data[i++]=pes_len &amp; 0xff;
-                data[i++]=0x80; // mpeg2            
-                data[i++]=0x80; // PTS 
-                data[i++]=5;    // PTS LEN
-            
-                // pts
-                its=audioTime(0);
-                writePts(data+i,its,2);
-                i+=5;                             
-            
-                left=TS_PACKET_SIZE-i;
-                if(left&gt;len)
-                {
-                      left=len;
-
-                }
-                memcpy(data+i,buf,left);                      
-                left=writePacket(data, i+len, its,&amp;audioChannel,1);
-                left=left-i;
-            }
-            else
-            {
-                left=writePacket(buf, len, TS_NO_PCR,&amp;audioChannel,0);
-            }
-
-            buf+=left;
-            len-=left;                   
-            part=0;
-     }    
-   
-     audioFill=0;
-     _total+=org;
-     return 1;
-}
-/*
-    ipts is is us
-*/
-/*
-        flags : PTS only = 2 PTS+DTS=3 DTS=1
-
-*/
-uint8_t writePts(uint8_t *data,uint64_t ipts,uint32_t flags)
-{
-uint32_t i=0;
-uint64_t p;
-            ipts=ipts&amp;0xfffffffffLL; // clip to 36 bits 33 bits *8 before clipping
-            ipts=(ipts*90)/1000;
-            
-            data[i++]=(flags &lt;&lt; 4) | (((ipts &gt;&gt; 30) &amp; 0x07) &lt;&lt; 1) | 1;
-            p=(((ipts &gt;&gt; 15) &amp; 0x7fff) &lt;&lt; 1) | 1;
-            data[i++]=p&gt;&gt;8;
-            data[i++]=p&amp;0xff;
-            p=(((ipts) &amp; 0x7fff) &lt;&lt; 1) | 1;
-            data[i++]=p&gt;&gt;8;
-            data[i++]=p&amp;0xff;
-}
-// EOF

Deleted: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/ADM_tscrc.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/ADM_tscrc.h	2009-07-23 18:18:44 UTC (rev 5131)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/ADM_tscrc.h	2009-07-23 18:18:46 UTC (rev 5132)
@@ -1,45 +0,0 @@
-static const uint32_t crc_table[256] = {
-	0x00000000, 0x04c11db7, 0x09823b6e, 0x0d4326d9, 0x130476dc, 0x17c56b6b,
-	0x1a864db2, 0x1e475005, 0x2608edb8, 0x22c9f00f, 0x2f8ad6d6, 0x2b4bcb61,
-	0x350c9b64, 0x31cd86d3, 0x3c8ea00a, 0x384fbdbd, 0x4c11db70, 0x48d0c6c7,
-	0x4593e01e, 0x4152fda9, 0x5f15adac, 0x5bd4b01b, 0x569796c2, 0x52568b75,
-	0x6a1936c8, 0x6ed82b7f, 0x639b0da6, 0x675a1011, 0x791d4014, 0x7ddc5da3,
-	0x709f7b7a, 0x745e66cd, 0x9823b6e0, 0x9ce2ab57, 0x91a18d8e, 0x95609039,
-	0x8b27c03c, 0x8fe6dd8b, 0x82a5fb52, 0x8664e6e5, 0xbe2b5b58, 0xbaea46ef,
-	0xb7a96036, 0xb3687d81, 0xad2f2d84, 0xa9ee3033, 0xa4ad16ea, 0xa06c0b5d,
-	0xd4326d90, 0xd0f37027, 0xddb056fe, 0xd9714b49, 0xc7361b4c, 0xc3f706fb,
-	0xceb42022, 0xca753d95, 0xf23a8028, 0xf6fb9d9f, 0xfbb8bb46, 0xff79a6f1,
-	0xe13ef6f4, 0xe5ffeb43, 0xe8bccd9a, 0xec7dd02d, 0x34867077, 0x30476dc0,
-	0x3d044b19, 0x39c556ae, 0x278206ab, 0x23431b1c, 0x2e003dc5, 0x2ac12072,
-	0x128e9dcf, 0x164f8078, 0x1b0ca6a1, 0x1fcdbb16, 0x018aeb13, 0x054bf6a4,
-	0x0808d07d, 0x0cc9cdca, 0x7897ab07, 0x7c56b6b0, 0x71159069, 0x75d48dde,
-	0x6b93dddb, 0x6f52c06c, 0x6211e6b5, 0x66d0fb02, 0x5e9f46bf, 0x5a5e5b08,
-	0x571d7dd1, 0x53dc6066, 0x4d9b3063, 0x495a2dd4, 0x44190b0d, 0x40d816ba,
-	0xaca5c697, 0xa864db20, 0xa527fdf9, 0xa1e6e04e, 0xbfa1b04b, 0xbb60adfc,
-	0xb6238b25, 0xb2e29692, 0x8aad2b2f, 0x8e6c3698, 0x832f1041, 0x87ee0df6,
-	0x99a95df3, 0x9d684044, 0x902b669d, 0x94ea7b2a, 0xe0b41de7, 0xe4750050,
-	0xe9362689, 0xedf73b3e, 0xf3b06b3b, 0xf771768c, 0xfa325055, 0xfef34de2,
-	0xc6bcf05f, 0xc27dede8, 0xcf3ecb31, 0xcbffd686, 0xd5b88683, 0xd1799b34,
-	0xdc3abded, 0xd8fba05a, 0x690ce0ee, 0x6dcdfd59, 0x608edb80, 0x644fc637,
-	0x7a089632, 0x7ec98b85, 0x738aad5c, 0x774bb0eb, 0x4f040d56, 0x4bc510e1,
-	0x46863638, 0x42472b8f, 0x5c007b8a, 0x58c1663d, 0x558240e4, 0x51435d53,
-	0x251d3b9e, 0x21dc2629, 0x2c9f00f0, 0x285e1d47, 0x36194d42, 0x32d850f5,
-	0x3f9b762c, 0x3b5a6b9b, 0x0315d626, 0x07d4cb91, 0x0a97ed48, 0x0e56f0ff,
-	0x1011a0fa, 0x14d0bd4d, 0x19939b94, 0x1d528623, 0xf12f560e, 0xf5ee4bb9,
-	0xf8ad6d60, 0xfc6c70d7, 0xe22b20d2, 0xe6ea3d65, 0xeba91bbc, 0xef68060b,
-	0xd727bbb6, 0xd3e6a601, 0xdea580d8, 0xda649d6f, 0xc423cd6a, 0xc0e2d0dd,
-	0xcda1f604, 0xc960ebb3, 0xbd3e8d7e, 0xb9ff90c9, 0xb4bcb610, 0xb07daba7,
-	0xae3afba2, 0xaafbe615, 0xa7b8c0cc, 0xa379dd7b, 0x9b3660c6, 0x9ff77d71,
-	0x92b45ba8, 0x9675461f, 0x8832161a, 0x8cf30bad, 0x81b02d74, 0x857130c3,
-	0x5d8a9099, 0x594b8d2e, 0x5408abf7, 0x50c9b640, 0x4e8ee645, 0x4a4ffbf2,
-	0x470cdd2b, 0x43cdc09c, 0x7b827d21, 0x7f436096, 0x7200464f, 0x76c15bf8,
-	0x68860bfd, 0x6c47164a, 0x61043093, 0x65c52d24, 0x119b4be9, 0x155a565e,
-	0x18197087, 0x1cd86d30, 0x029f3d35, 0x065e2082, 0x0b1d065b, 0x0fdc1bec,
-	0x3793a651, 0x3352bbe6, 0x3e119d3f, 0x3ad08088, 0x2497d08d, 0x2056cd3a,
-	0x2d15ebe3, 0x29d4f654, 0xc5a92679, 0xc1683bce, 0xcc2b1d17, 0xc8ea00a0,
-	0xd6ad50a5, 0xd26c4d12, 0xdf2f6bcb, 0xdbee767c, 0xe3a1cbc1, 0xe760d676,
-	0xea23f0af, 0xeee2ed18, 0xf0a5bd1d, 0xf464a0aa, 0xf9278673, 0xfde69bc4,
-	0x89b8fd09, 0x8d79e0be, 0x803ac667, 0x84fbdbd0, 0x9abc8bd5, 0x9e7d9662,
-	0x933eb0bb, 0x97ffad0c, 0xafb010b1, 0xab710d06, 0xa6322bdf, 0xa2f33668,
-	0xbcb4666d, 0xb8757bda, 0xb5365d03, 0xb1f740b4
-};

Deleted: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/oplug_dummy/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/oplug_dummy/CMakeLists.txt	2009-07-23 18:18:44 UTC (rev 5131)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/oplug_dummy/CMakeLists.txt	2009-07-23 18:18:46 UTC (rev 5132)
@@ -1,3 +0,0 @@
-SET(ADM_oplug_dummy_SRCS oplug_dummy.cpp)
-
-ADD_ADM_LIB_ALL_TARGETS(oplug_dummy ${ADM_oplug_dummy_SRCS})
\ No newline at end of file

Deleted: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/oplug_dummy/oplug_dummy.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/oplug_dummy/oplug_dummy.cpp	2009-07-23 18:18:44 UTC (rev 5131)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/oplug_dummy/oplug_dummy.cpp	2009-07-23 18:18:46 UTC (rev 5132)
@@ -1,240 +0,0 @@
-/***************************************************************************
-                          oplug_dummy.cpp  -  Container that discards all inputs
-                          						Video only!
-                             -------------------
-    
-    copyright            : (C) 2007 by mean
-    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
-        
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-#include &lt;math.h&gt;
-
-#include &quot;config.h&quot;
-#include &quot;ADM_default.h&quot;
-#include &quot;ADM_threads.h&quot;
-
-extern &quot;C&quot; {
-#include &quot;ADM_lavcodec.h&quot;
-};
-
-#include &quot;ADM_editor/ADM_Video.h&quot;
-//#include &quot;ADM_colorspace/colorspace.h&quot;
-#include &quot;DIA_coreToolkit.h&quot;
-#include &quot;ADM_videoFilter.h&quot;
-#include &quot;ADM_videoFilter_internal.h&quot;
-
-#include &quot;ADM_encoder/ADM_vidEncode.hxx&quot;
-#include &quot;ADM_codecs/ADM_codec.h&quot;
-#include &quot;ADM_encoder/adm_encoder.h&quot;
-
-#include &quot;ADM_codecs/ADM_ffmpeg.h&quot;
-#include &quot;ADM_encoder/adm_encffmpeg.h&quot;
-#include &quot;../oplug_mpegFF/oplug_vcdff.h&quot;
-
-#include &quot;ADM_userInterfaces/ADM_commonUI/DIA_encoding.h&quot;
-#include &quot;audioprocess.hxx&quot;
-#include &quot;audioeng_buildfilters.h&quot;
-#include &quot;../ADM_lavformat.h&quot;
-#include &quot;fourcc.h&quot;
-#include &quot;ADM_encoder/adm_encConfig.h&quot;
-#include &quot;ADM_encoder/ADM_vidEncode.hxx&quot;
-#include &quot;ADM_libraries/ADM_mplex/ADM_mthread.h&quot;
-#include &quot;ADM_toolkit/ADM_audioQueue.h&quot;
-
-#include &quot;ADM_osSupport/ADM_debugID.h&quot;
-#define MODULE_NAME MODULE_MP4
-#include &quot;ADM_osSupport/ADM_debug.h&quot;
-
-
-extern void   	 				UI_purge(void );
-
-extern uint32_t					videoProcessMode (void);
-extern uint32_t 				frameStart,frameEnd;
-
-
-
-static 				uint8_t *_buffer=NULL,*_outbuffer=NULL;
-
-/*
- * 		\fn    Oplug_dummy
-		\brief Main function to save in dummy format. 
-		This containers drops all datas. Useful for testing or some weird filters
-
-*/
-uint8_t oplug_dummy(const char *name)
-{
-AVDMGenericVideoStream *_incoming=NULL;
-AVDMGenericAudioStream  *audio=NULL;
-
-uint8_t		audioBuffer[48000];
-uint8_t         *videoBuffer=NULL;
-
-uint32_t alen;//,flags;
-uint32_t size;
-
-uint8_t   ret=0;
-
-uint32_t  sample_got=0,sample;
-uint32_t  extraDataSize=0;
-uint8_t   *extraData=NULL;
-aviInfo      info;
-uint32_t   width,height;
-DIA_encoding *encoding_gui=NULL;
-Encoder         *_encode=NULL;
-uint32_t total=0;
-uint32_t videoExtraDataSize=0;
-uint8_t  *videoExtraData=NULL;
-uint8_t *dummy,err;
-int prefill=0;
-uint32_t displayFrame=0;
-ADMBitstream    bitstream(0);
-uint32_t        frameWrite=0;
-uint8_t r=0;
-uint32_t skipping=1;
-
-uint32_t    totalAudioSize=0;
-uint32_t sent=0;
-
-        // Setup video
-        
-        if(videoProcessMode())
-        {
-             _incoming = getLastVideoFilter (frameStart,frameEnd-frameStart);
-        }else
-        {
-             _incoming = getFirstVideoFilter (frameStart,frameEnd-frameStart);
-        }
-
-           videoBuffer=new uint8_t[_incoming-&gt;getInfo()-&gt;width*_incoming-&gt;getInfo()-&gt;height*3];
-                // Set global header encoding, needed for H264
-           _encode = getVideoEncoder (_incoming-&gt;getInfo()-&gt;width,  _incoming-&gt;getInfo()-&gt;height,1);
-           total= _incoming-&gt;getInfo()-&gt;nb_frames;
-
-           info.fcc=*(uint32_t *)_encode-&gt;getCodecName(); //FIXME
-           
-           encoding_gui=new DIA_encoding(_incoming-&gt;getInfo()-&gt;fps1000);
-           bitstream.bufferSize=_incoming-&gt;getInfo()-&gt;width*_incoming-&gt;getInfo()-&gt;height*3;
-           if (!_encode)
-                {
-                  GUI_Error_HIG (&quot;[FLV]&quot;,QT_TR_NOOP(&quot;Cannot initialize the video stream&quot;));
-                        goto  stopit;
-                }
-
-                // init compressor
-                encoding_gui-&gt;setContainer(QT_TR_NOOP(&quot;Dummy&quot;));
-                encoding_gui-&gt;setAudioCodec(QT_TR_NOOP(&quot;None&quot;));
-                if(!videoProcessMode())
-                        encoding_gui-&gt;setCodec(QT_TR_NOOP(&quot;Copy&quot;));
-                else
-                        encoding_gui-&gt;setCodec(_encode-&gt;getDisplayName());
-                
-                if (!_encode-&gt;configure (_incoming, 0))
-                {
-                      GUI_Error_HIG (QT_TR_NOOP(&quot;Filter init failed&quot;), NULL);
-                     goto  stopit;
-                };
-
-                encoding_gui-&gt;setPhasis (QT_TR_NOOP(&quot;Encoding&quot;));
-                
-                
-                info.width=_incoming-&gt;getInfo()-&gt;width;
-                info.height=_incoming-&gt;getInfo()-&gt;height;
-                info.nb_frames=_incoming-&gt;getInfo()-&gt;nb_frames;
-                info.fps1000=_incoming-&gt;getInfo()-&gt;fps1000;
-                
-                _encode-&gt;hasExtraHeaderData( &amp;videoExtraDataSize,&amp;dummy);
-                if(videoExtraDataSize)
-                {
-                        printf(&quot;[FLV]We have extradata for video in copy mode (%d)\n&quot;,videoExtraDataSize);
-                        videoExtraData=new uint8_t[videoExtraDataSize];
-                        memcpy(videoExtraData,dummy,videoExtraDataSize);
-                }
-        // _________________Setup video (cont) _______________
-        // ___________ Read 1st frame _________________
-             
-             ADM_assert(_encode);
-             bitstream.data=videoBuffer;
-             
-preFilling:
-             bitstream.cleanup(0);
-             if(!(err=_encode-&gt;encode ( prefill, &amp;bitstream)))// FIXME: We should never execute it more than once
-             {
-                        printf(&quot;[FLV]:First frame error\n&quot;);
-                        GUI_Error_HIG (QT_TR_NOOP(&quot;Error while encoding&quot;), NULL);
-                        goto  stopit;
-              }
-              sent++;
-              if(!bitstream.len)
-              {
-                prefill++;
-                goto preFilling;
-              }
-              if(!bitstream.flags &amp; AVI_KEY_FRAME)
-              {
-                GUI_Error_HIG (QT_TR_NOOP(&quot;KeyFrame error&quot;),QT_TR_NOOP( &quot;The beginning frame is not a key frame.\nPlease move the A marker.&quot;));
-                  goto  stopit; 
-              }
-         
-          if(!videoProcessMode())
-                encoding_gui-&gt;setCodec(QT_TR_NOOP(&quot;Copy&quot;));
-          else
-                encoding_gui-&gt;setCodec(_encode-&gt;getDisplayName());
-           //
-          UI_purge();
-          if(bitstream.len)
-          {
-            frameWrite++;
-          }
-           for(int frame=1;frame&lt;total;frame++)
-           {
-               
-               ADM_assert(_encode);
-               bitstream.cleanup(frameWrite);
-              
-               r=_encode-&gt;encode ( prefill+frame, &amp;bitstream);
-              
-               if(!r &amp;&amp; frame&lt;total-2)
-               {
-                        printf(&quot;[FLV]:Frame %u error\n&quot;,frame);
-                        GUI_Error_HIG (&quot;FLV&quot;,QT_TR_NOOP(&quot;Error while encoding&quot;));
-                        goto  stopit;
-                }
-                if(!bitstream.len &amp;&amp; skipping)
-                {
-                    printf(&quot;[FLV]Frame skipped (xvid ?)\n&quot;);
-                    continue;
-                }
-                sent++;
-                skipping=0;
-                frameWrite++;
-                encoding_gui-&gt;setFrame(frame,bitstream.len,bitstream.out_quantizer,total);
-               if(!encoding_gui-&gt;isAlive())
-                {
-                    
-                    goto stopit;
-                }
-               
-           }
-           ret=1;
-           
-stopit:
-    
-           if(encoding_gui) delete encoding_gui;
-           if(videoBuffer) delete [] videoBuffer;
-           if(_encode) delete _encode;	
-           if(videoExtraData) delete [] videoExtraData;
-           return ret;
-}
-
-	
-// EOF

Deleted: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/oplug_flv/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/oplug_flv/CMakeLists.txt	2009-07-23 18:18:44 UTC (rev 5131)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/oplug_flv/CMakeLists.txt	2009-07-23 18:18:46 UTC (rev 5132)
@@ -1,9 +0,0 @@
-
-SET(ADM_flv_SRCS oplug_flv.cpp)
- 
-ADD_LIBRARY(ADM_mx_flv SHARED ${ADM_flv_SRCS})
-
-INCLUDE_DIRECTORIES(&quot;${AVIDEMUX_SOURCE_DIR}/avidemux/ADM_libraries/ADM_ffmpeg&quot;)
-TARGET_LINK_LIBRARIES(ADM_mx_flv  ADM_libavutil6 ADM_libavcodec6 ADM_libavformat6)
-INIT_MUXER(ADM_mx_flv)
-INSTALL_MUXER(ADM_mx_flv)

Deleted: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/oplug_flv/oplug_flv.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/oplug_flv/oplug_flv.cpp	2009-07-23 18:18:44 UTC (rev 5131)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/oplug_flv/oplug_flv.cpp	2009-07-23 18:18:46 UTC (rev 5132)
@@ -1,370 +0,0 @@
-/***************************************************************************
-                          oplug_flv.cpp  -  I/f to lavformat flash encoder
-                             -------------------
-
-    copyright            : (C) 2007 by mean
-    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
-
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-#include &lt;math.h&gt;
-
-#include &quot;config.h&quot;
-#include &quot;ADM_default.h&quot;
-#include &quot;ADM_threads.h&quot;
-
-extern &quot;C&quot; {
-#include &quot;ADM_lavcodec.h&quot;
-};
-
-#include &quot;ADM_editor/ADM_Video.h&quot;
-//#include &quot;ADM_colorspace/colorspace.h&quot;
-#include &quot;DIA_coreToolkit.h&quot;
-#include &quot;ADM_videoFilter.h&quot;
-#include &quot;ADM_videoFilter_internal.h&quot;
-
-#include &quot;ADM_encoder/ADM_vidEncode.hxx&quot;
-#include &quot;ADM_codecs/ADM_codec.h&quot;
-#include &quot;ADM_encoder/adm_encoder.h&quot;
-
-#include &quot;ADM_codecs/ADM_ffmpeg.h&quot;
-#include &quot;ADM_encoder/adm_encffmpeg.h&quot;
-#include &quot;../oplug_mpegFF/oplug_vcdff.h&quot;
-
-#include &quot;ADM_userInterfaces/ADM_commonUI/DIA_encoding.h&quot;
-#include &quot;audioprocess.hxx&quot;
-#include &quot;audioeng_buildfilters.h&quot;
-#include &quot;../ADM_lavformat.h&quot;
-#include &quot;fourcc.h&quot;
-#include &quot;ADM_encoder/adm_encConfig.h&quot;
-#include &quot;ADM_encoder/ADM_vidEncode.hxx&quot;
-#include &quot;ADM_libraries/ADM_mplex/ADM_mthread.h&quot;
-#include &quot;ADM_toolkit/ADM_audioQueue.h&quot;
-
-#include &quot;ADM_osSupport/ADM_debugID.h&quot;
-#define MODULE_NAME MODULE_MP4
-#include &quot;ADM_osSupport/ADM_debug.h&quot;
-
-
-extern const char 				*getStrFromAudioCodec( uint32_t codec);
-extern AVDMGenericAudioStream 	*mpt_getAudioStream(void);
-extern void   	 				UI_purge(void );
-
-extern uint32_t					videoProcessMode (void);
-extern uint32_t 				frameStart,frameEnd;
-extern uint32_t 				audioProcessMode(void);
-extern AVDMGenericAudioStream 	*currentaudiostream;;
-
-static 				uint8_t *_buffer=NULL,*_outbuffer=NULL;
-extern uint8_t isVP6Compatible (uint32_t fourcc);
-
-/*
- * 		\fn    Oplug_flv
-		\brief Main function to save in flv format.
-		It is very close to oplug_mp4 but somehow simplified as the following assumptions are made :
-				* No b frame
-				* No 2 pass encoding
-
-*/
-uint8_t oplug_flv(const char *name)
-{
-AVDMGenericVideoStream *_incoming=NULL;
-AVDMGenericAudioStream  *audio=NULL;
-
-uint8_t		audioBuffer[48000];
-uint8_t         *videoBuffer=NULL;
-
-uint32_t alen;//,flags;
-uint32_t size;
-
-uint8_t   ret=0;
-
-uint32_t  sample_got=0,sample;
-uint32_t  extraDataSize=0;
-uint8_t   *extraData=NULL;
-lavMuxer  *muxer=NULL;
-aviInfo      info;
-uint32_t   width,height;
-DIA_encoding *encoding_gui=NULL;
-Encoder         *_encode=NULL;
-uint32_t total=0;
-uint32_t videoExtraDataSize=0;
-uint8_t  *videoExtraData=NULL;
-uint8_t *dummy,err;
-WAVHeader *audioinfo=NULL;
-int prefill=0;
-uint32_t displayFrame=0;
-ADMBitstream    bitstream(0);
-uint32_t        frameWrite=0;
-uint8_t r=0;
-uint32_t skipping=1;
-pthread_t     audioThread;
-audioQueueMT context;
-PacketQueue   *pq=NULL;//(&quot;MP4 audioQ&quot;,50,2*1024*1024);
-uint32_t    totalAudioSize=0;
-uint32_t sent=0;
-
-        // Setup video
-
-        if(videoProcessMode())
-        {
-             _incoming = getLastVideoFilter (frameStart,frameEnd-frameStart);
-        }else
-        {
-             _incoming = getFirstVideoFilter (frameStart,frameEnd-frameStart);
-        }
-
-           videoBuffer=new uint8_t[_incoming-&gt;getInfo()-&gt;width*_incoming-&gt;getInfo()-&gt;height*3];
-                // Set global header encoding, needed for H264
-           _encode = getVideoEncoder (_incoming-&gt;getInfo()-&gt;width,  _incoming-&gt;getInfo()-&gt;height,1);
-           total= _incoming-&gt;getInfo()-&gt;nb_frames;
-
-           info.fcc=*(uint32_t *)_encode-&gt;getCodecName(); //FIXME
-           //
-           int supported=0;
-           if(isVP6Compatible(info.fcc)) supported=1;
-           if(fourCC::check(info.fcc,(const uint8_t *)&quot;FLV1&quot;)) supported=1;
-           if(!supported)
-           {
-        	   GUI_Error_HIG(QT_TR_NOOP(&quot;Unsupported video&quot;),QT_TR_NOOP(&quot;Only FLV1 and VP6 video are supported&quot;));
-        	   goto stopit;
-           }
-           /* Check audio, we support only mp3 right now
-            * 44100, 22050, 11025 only!
-            *  */
-           if(currentaudiostream)
-           {
-        	   uint32_t audioCodec=0;
-        	   uint32_t fq=currentaudiostream-&gt;getInfo()-&gt;frequency;
-
-        	   	if(audioProcessMode())
-        	   	{
-        	   		audioCodec=audioFilter_getOuputCodec();
-        	   		fq=audioFilter_getOuputFrequency(fq);
-
-        	   	}else
-        	   	{	// copy
-        	   		audioCodec=currentaudiostream-&gt;getInfo()-&gt;encoding;
-        	   	}
-        	   	if(audioCodec!=WAV_MP3 )
-        	   		{
-        	   			GUI_Error_HIG(QT_TR_NOOP(&quot;Unsupported audio&quot;),QT_TR_NOOP(&quot;Audio must be mp3 for flv output.&quot;));
-        	   			goto stopit;
-        	   		}
-        	   	if(fq!=44100 &amp;&amp; fq!=22050 &amp;&amp; fq!=11025)
-        	   	{
-    	   			GUI_Error_HIG(QT_TR_NOOP(&quot;Unsupported audio&quot;),QT_TR_NOOP(&quot;Frequency must be 44100, 22050 or 11025 Hz.&quot;));
-    	   			goto stopit;
-
-        	   	}
-           }
-
-
-           encoding_gui=new DIA_encoding(_incoming-&gt;getInfo()-&gt;fps1000);
-           bitstream.bufferSize=_incoming-&gt;getInfo()-&gt;width*_incoming-&gt;getInfo()-&gt;height*3;
-           if (!_encode)
-                {
-                  GUI_Error_HIG (&quot;[FLV]&quot;,QT_TR_NOOP(&quot;Cannot initialize the video stream&quot;));
-                        goto  stopit;
-                }
-
-                // init compressor
-                encoding_gui-&gt;setContainer(QT_TR_NOOP(&quot;FLV&quot;));
-                encoding_gui-&gt;setAudioCodec(QT_TR_NOOP(&quot;None&quot;));
-                if(!videoProcessMode())
-                        encoding_gui-&gt;setCodec(QT_TR_NOOP(&quot;Copy&quot;));
-                else
-                        encoding_gui-&gt;setCodec(_encode-&gt;getDisplayName());
-
-                if (!_encode-&gt;configure (_incoming, 0))
-                {
-                      GUI_Error_HIG (QT_TR_NOOP(&quot;Filter init failed&quot;), NULL);
-                     goto  stopit;
-                };
-
-                encoding_gui-&gt;setPhasis (QT_TR_NOOP(&quot;Encoding&quot;));
-
-
-                info.width=_incoming-&gt;getInfo()-&gt;width;
-                info.height=_incoming-&gt;getInfo()-&gt;height;
-                info.nb_frames=_incoming-&gt;getInfo()-&gt;nb_frames;
-                info.fps1000=_incoming-&gt;getInfo()-&gt;fps1000;
-
-                _encode-&gt;hasExtraHeaderData( &amp;videoExtraDataSize,&amp;dummy);
-                if(videoExtraDataSize)
-                {
-                        printf(&quot;[FLV]We have extradata for video in copy mode (%d)\n&quot;,videoExtraDataSize);
-                        videoExtraData=new uint8_t[videoExtraDataSize];
-                        memcpy(videoExtraData,dummy,videoExtraDataSize);
-                }
-        // _________________Setup video (cont) _______________
-        // ___________ Read 1st frame _________________
-
-             ADM_assert(_encode);
-             bitstream.data=videoBuffer;
-
-preFilling:
-             bitstream.cleanup(0);
-             if(!(err=_encode-&gt;encode ( prefill, &amp;bitstream)))// FIXME: We should never execute it more than once
-             {
-                        printf(&quot;[FLV]:First frame error\n&quot;);
-                        GUI_Error_HIG (QT_TR_NOOP(&quot;Error while encoding&quot;), NULL);
-                        goto  stopit;
-              }
-              sent++;
-              if(!bitstream.len)
-              {
-                prefill++;
-                goto preFilling;
-              }
-              if(!bitstream.flags &amp; AVI_KEY_FRAME)
-              {
-                GUI_Error_HIG (QT_TR_NOOP(&quot;KeyFrame error&quot;),QT_TR_NOOP( &quot;The beginning frame is not a key frame.\nPlease move the A marker.&quot;));
-                  goto  stopit;
-              }
-
-// ____________Setup audio__________________
-          if(currentaudiostream)
-          {
-                audio=mpt_getAudioStream();
-                if(!audio)
-                {
-                        GUI_Error_HIG (&quot;[FLV]&quot;,QT_TR_NOOP(&quot;Cannot initialize the audio stream&quot;));
-                        goto  stopit;
-                }
-          }
-          if(audio)
-          {
-                audioinfo=audio-&gt;getInfo();
-                audio-&gt;extraData(&amp;extraDataSize,&amp;extraData);
-                if(audioProcessMode())
-                        encoding_gui-&gt;setAudioCodec(getStrFromAudioCodec(audio-&gt;getInfo()-&gt;encoding));
-                else
-                         encoding_gui-&gt;setAudioCodec(QT_TR_NOOP(&quot;Copy&quot;));
-
-           }else
-           {
-                encoding_gui-&gt;setAudioCodec(QT_TR_NOOP(&quot;None&quot;));
-           }
-// ____________Setup Muxer _____________________
-           muxer= new lavMuxer;
-
-           if(!muxer-&gt;open(
-                name,
-                2000000, // Muxrate
-                MUXER_FLV,
-                &amp;info,videoExtraDataSize,videoExtraData,
-                audioinfo,extraDataSize,extraData))
-                         goto stopit;
-//_____________ Loop _____________________
-
-          encoding_gui-&gt;setContainer(QT_TR_NOOP(&quot;FLV&quot;));
-
-          if(!videoProcessMode())
-                encoding_gui-&gt;setCodec(QT_TR_NOOP(&quot;Copy&quot;));
-          else
-                encoding_gui-&gt;setCodec(_encode-&gt;getDisplayName());
-           //
-          UI_purge();
-          if(bitstream.len)
-          {
-            muxer-&gt;writeVideoPacket( &amp;bitstream);
-            frameWrite++;
-          }
-//_____________ Start Audio thread _____________________
-          if(audio)
-          {
-            pq=new PacketQueue(&quot;[FLV] audioQ&quot;,5000,2*1024*1024);
-            memset(&amp;context,0,sizeof(context));
-            context.audioEncoder=audio;
-            context.audioTargetSample=0xFFFF0000; ; //FIXME
-            context.packetQueue=pq;
-            // start audio thread
-            ADM_assert(!pthread_create(&amp;audioThread,NULL,(THRINP)defaultAudioQueueSlave,&amp;context));
-            ADM_usleep(4000);
-          }
-//_____________GO !___________________
-           for(int frame=1;frame&lt;total;frame++)
-           {
-               while(muxer-&gt;needAudio())
-               {
-                    if(pq-&gt;Pop(audioBuffer,&amp;alen,&amp;sample))
-                    {
-                     if(alen)
-                     {
-                        muxer-&gt;writeAudioPacket(alen,audioBuffer,sample_got);
-                        totalAudioSize+=alen;
-                        encoding_gui-&gt;setAudioSize(totalAudioSize);
-                        sample_got+=sample;
-                     }
-                    }else break;
-               }
-               ADM_assert(_encode);
-               bitstream.cleanup(frameWrite);
-
-               r=_encode-&gt;encode ( prefill+frame, &amp;bitstream);
-
-               if(!r &amp;&amp; frame&lt;total-2)
-               {
-                        printf(&quot;[FLV]:Frame %u error\n&quot;,frame);
-                        GUI_Error_HIG (&quot;FLV&quot;,QT_TR_NOOP(&quot;Error while encoding&quot;));
-                        goto  stopit;
-                }
-                if(!bitstream.len &amp;&amp; skipping)
-                {
-                    printf(&quot;[FLV]Frame skipped (xvid ?)\n&quot;);
-                    continue;
-                }
-                sent++;
-                skipping=0;
-            //    printf(&quot;Prefill %u FrameWrite :%u Frame %u PtsFrame :%u\n&quot;,prefill,frameWrite,frame,bitstream.ptsFrame);
-                frameWrite++;
-                muxer-&gt;writeVideoPacket( &amp;bitstream);
-                encoding_gui-&gt;setFrame(frame,bitstream.len,bitstream.out_quantizer,total);
-               if(!encoding_gui-&gt;isAlive())
-                {
-
-                    goto stopit;
-                }
-
-           }
-           ret=1;
-
-stopit:
-
-    // Flush slave Q
-    if(audio&amp;&amp; pq)
-    {
-        context.audioAbort=1;
-        pq-&gt;Abort();
-        // Wait for audio slave to be over
-        while(!context.audioDone)
-        {
-          printf(&quot;[FLV]Waiting Audio thread\n&quot;);
-          ADM_usleep(500000);
-        }
-        delete pq;
-    }
-    //
-           if(muxer) muxer-&gt;close();
-           if(encoding_gui) delete encoding_gui;
-           if(videoBuffer) delete [] videoBuffer;
-           if(muxer) delete muxer;
-           if(_encode) delete _encode;
-           if(videoExtraData) delete [] videoExtraData;
-           // Cleanup
-           deleteAudioFilter (audio);
-           return ret;
-}
-
-
-// EOF

Deleted: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/oplug_flv/oplug_flv.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/oplug_flv/oplug_flv.h	2009-07-23 18:18:44 UTC (rev 5131)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/oplug_flv/oplug_flv.h	2009-07-23 18:18:46 UTC (rev 5132)
@@ -1,21 +0,0 @@
-/***************************************************************************
-                          oplug_vcdff.h  -  description
-                             -------------------
-    begin                : Sun Nov 10 2002
-    copyright            : (C) 2002 by mean
-    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#ifdef USE_FFMPEG
-#include &quot;ADM_editor/ADM_outputfmt.h&quot;
-uint8_t oplug_flv(const char *name);
-
-#endif

Deleted: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/oplug_mpeg/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/oplug_mpeg/CMakeLists.txt	2009-07-23 18:18:44 UTC (rev 5131)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/oplug_mpeg/CMakeLists.txt	2009-07-23 18:18:46 UTC (rev 5132)
@@ -1,4 +0,0 @@
-SET(ADM_oplug_mpeg_SRCS 
-	op_mpegpass.cpp)
-	
-ADD_ADM_LIB_ALL_TARGETS(oplug_mpeg ${ADM_oplug_mpeg_SRCS})
\ No newline at end of file

Deleted: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/oplug_mpeg/op_mpegpass.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/oplug_mpeg/op_mpegpass.cpp	2009-07-23 18:18:44 UTC (rev 5131)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/oplug_mpeg/op_mpegpass.cpp	2009-07-23 18:18:46 UTC (rev 5132)
@@ -1,425 +0,0 @@
-//
-// C++ Implementation: op_mpegpass
-//
-// Description: 
-//   This save mpeg video to mpegPS in video copy mode
-//	Audio can be in copy mode or not.
-//
-// Author: mean &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>&gt;, (C) 2004
-//
-// Copyright: See COPYING file that comes with this distribution
-//
-//
-
-
-#include &quot;config.h&quot;
-#include &lt;math.h&gt;
-#include &quot;ADM_default.h&quot;
-#include &quot;ADM_threads.h&quot;
-
-#include &quot;avi_vars.h&quot;
-#include &quot;audioprocess.hxx&quot;
-
-#include &quot;ADM_userInterfaces/ADM_commonUI/DIA_encoding.h&quot;
-
-#include &quot;audioeng_buildfilters.h&quot;
-#include &quot;prefs.h&quot;
-#include &quot;DIA_coreToolkit.h&quot;
-#include &quot;ADM_editor/ADM_outputfmt.h&quot;
-#include &quot;../ADM_lavformat.h&quot;
-
-#include &quot;ADM_libraries/ADM_lvemux/ADM_muxer.h&quot;
-
-// To have access to low level infos 
-#include &quot;ADM_lavcodec.h&quot;
-#include &quot;ADM_codecs/ADM_ffmp43.h&quot;
-#include &quot;ADM_inputs/ADM_mpegdemuxer/dmx_mpegstartcode.h&quot;
-
-#include &quot;ADM_encoder/ADM_vidEncode.hxx&quot;
-#include &quot;ADM_videoFilter.h&quot;
-#include &quot;ADM_videoFilter_internal.h&quot;
-#include &quot;ADM_encoder/adm_encoder.h&quot;
-#include &quot;ADM_encoder/adm_encCopy.h&quot;
-
-#include &quot;ADM_libraries/ADM_mplex/ADM_mthread.h&quot;
-#include &quot;ADM_toolkit/ADM_audioQueue.h&quot;
-
-static uint8_t lookupSeqEnd(ADMBitstream *bitstream,uint32_t *position);
-uint8_t ADM_findMpegStartCode(uint8_t *start, uint8_t *end,uint8_t *outstartcode,  uint32_t *offset);
-static int copyVideoSlave( muxerMT *context );
-/**
-	Save a cut and audio edited to mpeg-PS
-	Usefull for editing PVR captured files for example
-
-*/
-
-uint8_t isMpeg12Compatible(uint32_t fourcc);
-extern const char *getStrFromAudioCodec( uint32_t codec); 
-uint8_t mpeg_passthrough(const char *name,ADM_OUT_FORMAT format )
-{
-  uint32_t len, flags;
-  AVDMGenericAudioStream *audio=NULL;
-  uint32_t audiolen;
-  
-  DIA_encoding *work;
-  ADM_MUXER_TYPE mux;
-  
-  double total_wanted=0;
-  uint32_t total_got=0;
-  uint8_t ret=0;
- 
-  ADMMpegMuxer *muxer=NULL;
-  ADMBitstream bitstream(0);
-  
-  	printf(&quot;Saving as mpg PS to file %s\n&quot;,name);
-  
-  	// First we check it is mpeg
-	if(!isMpeg12Compatible(avifileinfo-&gt;fcc))
-  	{
-          GUI_Error_HIG(QT_TR_NOOP(&quot;This is not MPEG compatible&quot;), QT_TR_NOOP(&quot;You can't use the Copy codec.&quot;));
-		return 0 ;
-  	}
-  	if(!currentaudiostream)
-  	{
-          GUI_Error_HIG(QT_TR_NOOP(&quot;There is no audio track&quot;), NULL);
-		return 0;
-  	}
-  
-	ADM_assert (video_body-&gt;getFlags (frameStart, &amp;flags));
-        if(!(flags&amp;AVI_KEY_FRAME))
-        {
-          GUI_Error_HIG(QT_TR_NOOP(&quot;The first frame is not intra frame&quot;), QT_TR_NOOP(&quot;Use the &lt;&lt; and the &gt;&gt; buttons to move using Intra frames.&quot;));
-                return 0;
-        }
-	
-  	audio=mpt_getAudioStream();
-	
-	// Have to check the type
-	// If it is mpeg2 we use DVD-PS
-	// If it is mpeg1 we use VCD-PS
-	// Later check if it is SVCD
-	if(!audio)
-	{
-          GUI_Error_HIG(QT_TR_NOOP(&quot;Audio track is not suitable&quot;), NULL);
-		return 0;
-	}
-	// Check
-	WAVHeader *hdr=audio-&gt;getInfo();
-
-	switch(format)
-        {
-        case ADM_PS:	
-                    // Mpeg2 
-                        aviInfo info;
-                        video_body-&gt;getVideoInfo(&amp;info);
-                        if(hdr-&gt;frequency==44100 &amp;&amp; info.width==480&amp;&amp; hdr-&gt;encoding == WAV_MP2 ) // SVCD ?
-                        {
-                                mux=MUXER_SVCD;
-                                printf(&quot;PassThrough: Using SVCD PS\n&quot;);
-                        }
-                        else
-                        {
-                            uint32_t valid=0;
-                                if(!prefs-&gt;get(FEATURE_MPEG_NO_LIMIT,&amp;valid)) valid=0;
-                                 // mpeg2, we do only DVD right now
-                                if(hdr-&gt;frequency==48000) valid=1;
-                                if((hdr-&gt;encoding != WAV_MP2 &amp;&amp; hdr-&gt;encoding!=WAV_AC3 &amp;&amp; hdr-&gt;encoding!=WAV_LPCM
-                                &amp;&amp; hdr-&gt;encoding!=WAV_DTS))
-                                {
-                                  valid=0;  
-                                }
-                    
-                                if(!valid)
-                                {
-                                        deleteAudioFilter(audio);
-                                       GUI_Error_HIG((&quot;Incompatible audio&quot;),QT_TR_NOOP( &quot;For DVD, audio must be 48 kHz MP2(stereo), AC3, DTS or LPCM (stereo).&quot;));
-                                       return 0;
-                                }
-                         
-                               mux=MUXER_DVD;
-                               printf(&quot;PassThrough: Using DVD PS\n&quot;);
-                        }
-
-  	        muxer=new mplexMuxer();
-                break;
-        case ADM_TS:     
-             printf(&quot;Using TS output format\n&quot;);   
-             muxer=new tsMuxer(); //lavMuxer();
-             mux=MUXER_TS;
-             break;
-        default:
-                ADM_assert(0);
-                break;
-        }
-        
-        if(!muxer)
-         {
-                 printf(&quot;No muxer ?\n&quot;);
-                 return 0;
-        }
-	if(!muxer-&gt;open(name,0,mux,avifileinfo,audio-&gt;getInfo()))
-	{
-		delete muxer;
-		muxer=NULL;
-		printf(&quot;Muxer init failed\n&quot;);
-		return 0;
-		
-	}
-        
-	// In copy mode it is better to recompute the gop timestamp
-	muxer-&gt;forceRestamp();
-  ///____________________________
-  work=new DIA_encoding(avifileinfo-&gt;fps1000);
-  work-&gt;setCodec(QT_TR_NOOP(&quot;Copy&quot;));
-  work-&gt;setAudioCodec(QT_TR_NOOP(&quot;---&quot;));
-  work-&gt;setPhasis(QT_TR_NOOP(&quot;Saving&quot;));
-  if(!audioProcessMode())
-     work-&gt;setAudioCodec(QT_TR_NOOP(&quot;Copy&quot;));
-  else
-     work-&gt;setAudioCodec(getStrFromAudioCodec(audio-&gt;getInfo()-&gt;encoding));
-  switch(mux)
-  {
-    case MUXER_TS: work-&gt;setContainer(QT_TR_NOOP(&quot;MPEG TS&quot;));break;
-    case MUXER_VCD: work-&gt;setContainer(QT_TR_NOOP(&quot;MPEG VCD&quot;));break;
-    case MUXER_SVCD: work-&gt;setContainer(QT_TR_NOOP(&quot;MPEG SVCD&quot;));break;
-    case MUXER_DVD: work-&gt;setContainer(QT_TR_NOOP(&quot;MPEG DVD&quot;));break;
-    default:
-        ADM_assert(0);
-  }
-  
-  uint32_t cur=0;
-  uint32_t target_sample=0;
-  double target_time;
-  aviInfo info;
-        video_body-&gt;getVideoInfo(&amp;info);
-        target_time=frameEnd-frameStart+1;
-        target_time*=1000;
-        target_time/=info.fps1000; // target_time in second
-        target_time*=audio-&gt;getInfo()-&gt;frequency;
-        target_sample=(uint32_t)floor(target_time);
-
-  uint8_t *buffer = new uint8_t[avifileinfo-&gt;width * avifileinfo-&gt;height * 3];
-  uint8_t *audiobuffer = new uint8_t[4*48000*2]; // 2 sec worth of lpcm
-  uint32_t position;
-  EncoderCopy *copy=NULL;
-        bitstream.data=buffer;
-        bitstream.bufferSize=avifileinfo-&gt;width * avifileinfo-&gt;height * 3;
-        
-     /***************************
-      Special case : Multithreaded
-     ***************************/
-        if(mux==MUXER_VCD || mux==MUXER_SVCD || mux==MUXER_DVD)
-        {
-          pthread_t audioThread,videoThread,muxerThread;
-          copy=new EncoderCopy(NULL);
-          muxerMT context;
-          
-          copy-&gt;configure(NULL, 0);
-          // 
-          memset(&amp;context,0,sizeof(context));
-          context.videoEncoder=copy;
-          context.audioEncoder=audio;
-          context.muxer=( mplexMuxer *)muxer;
-          context.nbVideoFrame=copy-&gt;getNbFrame();
-          context.audioTargetSample=target_sample;
-          context.audioBuffer=audiobuffer;
-          context.bitstream=&bitstream;
-          context.opaque=(void *)work;
-
-           // start audio thread
-          ADM_assert(!pthread_create(&amp;audioThread,NULL,(THRINP)defaultAudioSlave,&amp;context)); 
-          ADM_assert(!pthread_create(&amp;videoThread,NULL,(THRINP)copyVideoSlave,&amp;context)); 
-          while(1)
-          {
-            accessMutex.lock();
-            if(context.audioDone==2 || context.videoDone==2 || !work-&gt;isAlive()) //ERROR
-            {
-              context.audioAbort=1;
-              context.videoAbort=1;
-              printf(&quot;[Copy] aborting\n&quot;);
-            }
-            if(context.audioDone &amp;&amp; context.videoDone)
-            {
-              printf(&quot;[Copy]Both audio &amp; video done\n&quot;);
-              if(context.audioDone==1 &amp;&amp; context.videoDone==1) ret=1;
-              else ret=0;
-              accessMutex.unlock();
-              goto _abt;
-            }
-             // Update UI
-            work-&gt;setAudioSize(context.feedAudio);
-            context.feedVideo=0;
-            accessMutex.unlock();
-            ADM_usleep(1000*1000);
-             
-          }    
-    
-    
-        }
-        /**************************************************************************************/
-        /* If we get here, it means output is MPEG_TS */ 
-        /* We must use the audio packet Queue */
-        /**************************************************************************************/
-        ADM_assert(mux==MUXER_TS);
-        {
-            PacketQueue *pq;
-            uint32_t mx,sample;
-            pthread_t     audioThread;
-            copy=new EncoderCopy(NULL);
-            audioQueueMT context;
-            uint8_t r;
-            
-            copy-&gt;configure(NULL, 0);
-            pq=new PacketQueue(&quot;TS audioQ&quot;,5000,2*1024*1024);
-            memset(&amp;context,0,sizeof(context));
-            context.audioEncoder=audio;
-            context.audioTargetSample=target_sample;
-            context.packetQueue=pq;
-              // start audio thread
-            ADM_assert(!pthread_create(&amp;audioThread,NULL,(THRINP)defaultAudioQueueSlave,&amp;context));
-            // Go!
-             
-            ADM_usleep(4000);
-            mx=copy-&gt;getNbFrame();
-            printf(&quot;Writing %u frames\n&quot;,mx);
-            for(int frame=0;frame&lt;mx;frame++)
-            {
-              while(muxer-&gt;needAudio())
-              {
-                if(pq-&gt;Pop(audiobuffer,&amp;audiolen,&amp;sample))
-                {
-                  if(audiolen)
-                  {
-                    muxer-&gt;writeAudioPacket(audiolen,audiobuffer);
-                    //work-&gt;feedAudioFrame(audiolen);
-                  }
-                }else break;
-              }
-              ADM_assert(copy);
-              bitstream.cleanup(frame);
-              r=copy-&gt;encode ( frame, &amp;bitstream);
-              if(!r)
-              {
-                printf(&quot;TS:Frame %u error\n&quot;,frame);
-                GUI_Error_HIG (QT_TR_NOOP(&quot;Error while encoding&quot;), NULL);
-                goto  stopit;
-              }
-              muxer-&gt;writeVideoPacket( &amp;bitstream);
-
-              work-&gt;setFrame(frame,bitstream.len,bitstream.out_quantizer,mx);
-//              work-&gt;feedFrame(bitstream.len);
-              if(!work-&gt;isAlive())
-              {
-                goto stopit;
-              }
-            }
-        
-    ret=1;
-stopit:
-    context.audioAbort=1;
-    pq-&gt;Abort();
-    // Wait for audio slave to be over
-    while(!context.audioDone)
-    {
-      printf(&quot;Waiting Audio thread\n&quot;);
-      ADM_usleep(500000); 
-    }
-    delete pq;
-  } // End ts case 
-  /************************************** TS End *********************************/
-_abt:
-  delete work;
-  muxer-&gt;close();
-  delete muxer;
-  delete [] buffer;
-  delete [] audiobuffer;
-  deleteAudioFilter(audio);
-  if(copy) delete copy;
-  return ret;
-
-}
-
-
-
-
-//************************************************
-uint8_t lookupSeqEnd(ADMBitstream *bitstream,uint32_t *position)
-{
-    uint8_t *ptr=bitstream-&gt;data,*end,code;
-    uint32_t len=bitstream-&gt;len,offset;
-    
-    end=ptr+len;
-    while(ADM_findMpegStartCode(ptr, end,&amp;code,&amp;offset))
-    {
-        if(code==SEQ_END_CODE)
-        {
-            *position=ptr-bitstream-&gt;data+offset-4;
-            return 1;
-        }
-        ptr+=offset;
-    }
-    return 0;
-}
-//*******************************
-int copyVideoSlave( muxerMT *context )
-{
-DIA_encoding *work=(DIA_encoding *)context-&gt;opaque;
-ADMBitstream *bitstream=context-&gt;bitstream;
-
-  printf(&quot;[CopyVideoThread] Starting\n&quot;);
-  uint32_t position;
-  for(uint32_t i=0;i&lt;context-&gt;nbVideoFrame;i++)
-  {
-
-    bitstream-&gt;cleanup(i);
-    if(context-&gt;videoAbort)
-    {
-      context-&gt;videoDone=1;
-      context-&gt;muxer-&gt;audioEof();
-      return 1;
-    }
-    if(!context-&gt;videoEncoder-&gt;encode( i,bitstream))
-    {
-      accessMutex.lock();
-      context-&gt;videoDone=2;
-      context-&gt;muxer-&gt;audioEof();
-      accessMutex.unlock();
-      printf(&quot;[CopyVideoThread] Exiting on error\n&quot;);
-      return 1;
-    }
-    if(!bitstream-&gt;len)
-      continue;
-    
-    if(lookupSeqEnd(bitstream,&amp;position))
-    {
-        ADMBitstream bs2(bitstream-&gt;bufferSize); // Mostly correct
-                if(position) 
-                {
-                  bs2.data=context-&gt;bitstream-&gt;data;
-                  bs2.len=position;
-                  context-&gt;muxer-&gt;writeVideoPacket(&amp;bs2);
-                }
-                bs2.data=bitstream-&gt;data+position+4;
-                bs2.len=bitstream-&gt;len-position-4;
-                if(bs2.len) context-&gt;muxer-&gt;writeVideoPacket(&amp;bs2);
-    } 
-    else 
-      context-&gt;muxer-&gt;writeVideoPacket(bitstream); 
-  
-
-    accessMutex.lock();
-    context-&gt;currentVideoFrame=i;
-    context-&gt;feedVideo+=bitstream-&gt;len;
-    work-&gt;setFrame(i,bitstream-&gt;len,bitstream-&gt;out_quantizer,frameEnd-frameStart);
-    accessMutex.unlock();
-  }        
-  accessMutex.lock();
-  context-&gt;videoDone=1;
-  context-&gt;muxer-&gt;audioEof();
-  accessMutex.unlock();
-
-  printf(&quot;[CopyVideoThread] Exiting\n&quot;);
-  return 1;
-}
-
-//EOF

Deleted: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/oplug_mpegFF/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/oplug_mpegFF/CMakeLists.txt	2009-07-23 18:18:44 UTC (rev 5131)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/oplug_mpegFF/CMakeLists.txt	2009-07-23 18:18:46 UTC (rev 5132)
@@ -1,4 +0,0 @@
-SET(ADM_oplug_mpegFF_SRCS 
-	oplug_vcdff.cpp)
-
-ADD_ADM_LIB_ALL_TARGETS(oplug_mpegFF ${ADM_oplug_mpegFF_SRCS})

Deleted: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/oplug_mpegFF/oplug_encodervcd.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/oplug_mpegFF/oplug_encodervcd.h	2009-07-23 18:18:44 UTC (rev 5131)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/oplug_mpegFF/oplug_encodervcd.h	2009-07-23 18:18:46 UTC (rev 5132)
@@ -1,29 +0,0 @@
-/***************************************************************************
-                          oplug_encodervcd.h  -  description
-                             -------------------
-    begin                : Sun Nov 10 2002
-    copyright            : (C) 2002 by mean
-    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
- class encoderVCD
- {
-	private :
-						uint32_t _w,_h,_br;
-						FILE *file;
-						
-	public:
-					encoderVCD( void );
-											  
-	 
-	 
-};
\ No newline at end of file

Deleted: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/oplug_mpegFF/oplug_vcdff.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/oplug_mpegFF/oplug_vcdff.cpp	2009-07-23 18:18:44 UTC (rev 5131)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/oplug_mpegFF/oplug_vcdff.cpp	2009-07-23 18:18:46 UTC (rev 5132)
@@ -1,555 +0,0 @@
-/***************************************************************************
-                          oplug_vcdff.cpp  -  description
-                             -------------------
-    begin                : Sun Nov 10 2002
-    copyright            : (C) 2002 by mean
-    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
-    
-    Ouput using FFmpeg mpeg1 encoder
-    Much faster than mjpegtools, albeit quality seems inferior
-    
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-#include &quot;config.h&quot;
-
-#ifdef USE_FFMPEG
-#include &lt;math.h&gt;
-
-#include &quot;ADM_default.h&quot;
-#include &quot;ADM_threads.h&quot;
-
-extern &quot;C&quot; {
-#include &quot;ADM_lavcodec.h&quot;
-}
-
-#include &quot;avi_vars.h&quot;
-#include &quot;prototype.h&quot;
-
-//#include &quot;ADM_colorspace/colorspace.h&quot;
-#include &quot;DIA_coreToolkit.h&quot;
-#include &quot;ADM_videoFilter.h&quot;
-#include &quot;ADM_videoFilter_internal.h&quot;
-
-#include &quot;ADM_encoder/ADM_vidEncode.hxx&quot;
-#include &quot;ADM_encoder/adm_encoder.h&quot;
-
-#include &quot;ADM_codecs/ADM_ffmpeg.h&quot;
-#include &quot;ADM_encoder/adm_encffmpeg.h&quot;
-#include &quot;ADM_encoder/adm_encmpeg2enc.h&quot;
-#include &quot;ADM_encoder/adm_encRequant.h&quot;
-#include &quot;../oplug_mpegFF/oplug_vcdff.h&quot;
-
-#include &quot;ADM_userInterfaces/ADM_commonUI/DIA_encoding.h&quot;
-#include &quot;audioprocess.hxx&quot;
-#include &quot;ADM_audiofilter/audioeng_buildfilters.h&quot;
-#include &quot;../ADM_lavformat.h&quot;
-
-#include &quot;ADM_encoder/adm_encConfig.h&quot;
-#include &quot;ADM_encoder/ADM_vidEncode.hxx&quot;
-
-#include &quot;ADM_libraries/ADM_mplex/ADM_mthread.h&quot;
-
-static uint8_t *_buffer = NULL, *_outbuffer = NULL;
-static void end(void);
-extern const char *getStrFromAudioCodec(uint32_t codec);
-
-extern COMPRES_PARAMS ffmpeg1Codec,ffmpeg2DVDCodec,ffmpeg2SVCDCodec,RequantCodec;	
-extern FFcodecSetting ffmpeg1Extra,ffmpeg2DVDExtra,ffmpeg2SVCDExtra;
-extern COMPRES_PARAMS SVCDCodec, DVDCodec,VCDCodec;
-
-extern uint8_t    isMpeg12Compatible (uint32_t fourcc);
-
-extern SelectCodecType videoCodecGetType(void);
-
-static char *twoPass = NULL;
-static char *twoFake = NULL;
-
-uint8_t oplug_mpegff(const char *name, ADM_OUT_FORMAT type)
-{
-AVDMGenericVideoStream *_incoming;
-Encoder  *encoder=NULL;
-ADMMpegMuxer	*muxer=NULL;
-FILE 		*file=NULL;
-uint8_t		audioBuffer[48000];
-uint32_t	audioLen=0;
-uint32_t _w,_h,_fps1000,_page,total;	
-AVDMGenericAudioStream	*audio=NULL;
-uint32_t len,flags;
-uint32_t size;
-ADM_MUXER_TYPE mux;
-uint32_t  audio_encoding=0;
-uint32_t  real_framenum=0;
-uint8_t   ret=0;
-uint32_t  sample_target=0;
-uint32_t  total_sample=0;
-ADMBitstream bitstream(0);
-uint32_t audioSum=0;
-DIA_encoding  *encoding;
-int reuse = 0;
-
-        twoPass=new char[strlen(name)+6];
-        twoFake=new char[strlen(name)+6];
-  
-        strcpy(twoPass,name);
-        strcat(twoPass,&quot;.stat&quot;);
-        strcpy(twoFake,name);
-        strcat(twoFake,&quot;.fake&quot;);
- 
-        _incoming = getLastVideoFilter (frameStart,frameEnd-frameStart);
-        _w=_incoming-&gt;getInfo()-&gt;width;
-        _h=_incoming-&gt;getInfo()-&gt;height;
-        _fps1000=_incoming-&gt;getInfo()-&gt;fps1000;
-        _page=_w*_h;
-        _page+=_page&gt;&gt;1;
-
-        total=_incoming-&gt;getInfo()-&gt;nb_frames;
-        if(!total) return 0;	
-        
-        switch(type)
-        {
-            default:
-                    ADM_assert(0);
-            case ADM_ES:
-                        // Else open file (if possible)                       
-                        mux=MUXER_NONE;
-                        break;
-            case ADM_TS:
-                    if(!currentaudiostream)
-                    {
-                      GUI_Error_HIG(QT_TR_NOOP(&quot;There is no audio track&quot;), NULL);
-					  goto finishvcdff;
-                    }
-                    audio=mpt_getAudioStream();
-                    mux=MUXER_TS;
-                    break;
-            case ADM_PS:
-            
-            {
-                if(!currentaudiostream)
-                {
-                  GUI_Error_HIG(QT_TR_NOOP(&quot;There is no audio track&quot;), NULL);
-				  goto finishvcdff;
-                }
-                audio=mpt_getAudioStream();
-                // Have to check the type
-                // If it is mpeg2 we use DVD-PS
-                // If it is mpeg1 we use VCD-PS
-                // Later check if it is SVCD
-                if(!audio)
-                {
-                  GUI_Error_HIG(QT_TR_NOOP(&quot;Audio track is not suitable&quot;), NULL);
-				  goto finishvcdff;
-                }
-                // Check
-                WAVHeader *hdr=audio-&gt;getInfo();	
-                audio_encoding=hdr-&gt;encoding;
-                if (videoCodecGetType() == CodecXVCD || videoCodecGetType() == CodecVCD)
-                {
-                        if(hdr-&gt;frequency!=44100 ||  hdr-&gt;encoding != WAV_MP2)
-                        {
-                            GUI_Error_HIG((&quot;Incompatible audio&quot;),QT_TR_NOOP( &quot;For VCD, audio must be 44.1 kHz MP2.&quot;));
-							goto finishvcdff;
-                        }
-                        mux=MUXER_VCD;
-                        printf(&quot;X*CD: Using VCD PS\n&quot;);
-                }else
-                {    
-                        aviInfo info;
-                        video_body-&gt;getVideoInfo(&amp;info);
-                        if(hdr-&gt;frequency==44100 &amp;&amp; _w==480&amp;&amp;hdr-&gt;encoding == WAV_MP2 ) // SVCD ?
-                        {
-                            mux=MUXER_SVCD;
-                            printf(&quot;X*VCD: Using SVCD PS\n&quot;);
-                        }
-                        else
-                        {
-                            // mpeg2, we do only DVD right now
-                            if(hdr-&gt;frequency!=48000 || 
-                                (hdr-&gt;encoding != WAV_MP2 &amp;&amp; hdr-&gt;encoding!=WAV_AC3 &amp;&amp; hdr-&gt;encoding!=WAV_LPCM))
-                            {
-                                GUI_Error_HIG(QT_TR_NOOP(&quot;Incompatible audio&quot;), QT_TR_NOOP(&quot;For DVD, audio must be 48 kHz MP2, AC3 or LPCM.&quot;));
-								goto finishvcdff;
-                            }
-                            mux=MUXER_DVD;
-                            printf(&quot;X*VCD: Using DVD PS\n&quot;);
-                        }
-                }
-            }
-         }        
-        // Create muxer
-       
-       
-        switch (videoCodecGetType())
-        {
-                
-                case CodecXVCD:
-                        encoder=new EncoderFFMPEGMpeg1(FF_MPEG1,&amp;ffmpeg1Codec);
-                        printf(&quot;\n Using ffmpeg mpeg1 encoder\n&quot;);
-                        break;
-                case CodecXSVCD:
-                        encoder=new EncoderFFMPEGMpeg1(FF_MPEG2,&amp;ffmpeg2SVCDCodec);
-                        printf(&quot;\n Using ffmpeg mpeg2 encoder\n&quot;);
-                        break;
-                case CodecXDVD:
-                        encoder=new EncoderFFMPEGMpeg1(FF_MPEG2,&amp;ffmpeg2DVDCodec);
-                        printf(&quot;\n Using ffmpeg mpeg2 encoder (DVD)\n&quot;);
-                        break;
-                case CodecDVD:
-                  encoder=new EncoderMpeg2enc(MPEG2ENC_DVD,&amp;DVDCodec);
-                  printf(&quot;\n Using mpeg2enc encoder (DVD)\n&quot;);
-                  break;
-                case CodecRequant:
-                  if(!isMpeg12Compatible(avifileinfo-&gt;fcc))
-                  {
-                    GUI_Error_HIG(&quot;Incompatible Input&quot;,&quot;The input file must be mpeg2 to be able to use requant!&quot;);
-                    return 0; // Fixme, do some cleanup 
-                  }
-                  encoder=new EncoderRequant(&amp;RequantCodec);
-                  printf(&quot;\n Using mpeg2 requant\n&quot;);
-                  break;
-                break;
-                case CodecSVCD:
-                  encoder=new EncoderMpeg2enc(MPEG2ENC_SVCD,&amp;SVCDCodec);
-                  printf(&quot;\n Using mpeg2enc encoder (SVCD)\n&quot;);
-                  break;
-                case CodecVCD:
-                  encoder=new EncoderMpeg2enc(MPEG2ENC_VCD,&amp;VCDCodec);
-                  printf(&quot;\n Using mpeg2enc encoder (VCD)\n&quot;);
-                  break;
-                default:
-                ADM_assert(0);
-      }
-
-      encoder-&gt;setLogFile(twoPass,total);
-
-	  if (encoder-&gt;isDualPass())
-	  {
-		  printf(&quot;Verifying log file\n&quot;);
-
-		  if (encoder-&gt;verifyLog(twoPass, total) &amp;&amp; GUI_Question(QT_TR_NOOP(&quot;Reuse the existing log file?&quot;)))
-			  reuse = 1;
-	  }
-
-      if(!encoder-&gt;configure(_incoming, reuse))
-              goto finishvcdff;
-
-      _buffer=new uint8_t[_page]; // Might overflow if _page only
-      _outbuffer=new uint8_t[_page];
-
-      ADM_assert(  _buffer);
-      ADM_assert(  _outbuffer);
-
-      encoding =new DIA_encoding(_fps1000);
-      switch (videoCodecGetType())
-      {
-          case CodecVCD:
-            encoding-&gt;setCodec(QT_TR_NOOP(&quot;libmpeg2enc VCD&quot;));
-            break;
-          case CodecSVCD:
-            encoding-&gt;setCodec(QT_TR_NOOP(&quot;libmpeg2enc SVCD&quot;));
-            break;
-          case CodecDVD:
-            encoding-&gt;setCodec(QT_TR_NOOP(&quot;libmpeg2enc DVD&quot;));
-            break;
-          case CodecXVCD:
-            encoding-&gt;setCodec(QT_TR_NOOP(&quot;FFmpeg MPEG-1 VBR&quot;));
-            break;
-          case CodecXSVCD:
-            encoding-&gt;setCodec(QT_TR_NOOP(&quot;FFmpeg MPEG-2 SVCD VBR&quot;));
-            break;
-          case CodecXDVD:
-            encoding-&gt;setCodec(QT_TR_NOOP(&quot;FFmpeg MPEG-2 DVD VBR&quot;));
-            break;
-          case CodecRequant:
-            encoding-&gt;setCodec(QT_TR_NOOP(&quot;MPEG Requantizer&quot;));
-            break;
-          
-          default:
-            ADM_assert(0);
-	}
-        switch(mux)
-          {
-            case MUXER_NONE:encoding-&gt;setContainer(QT_TR_NOOP(&quot;MPEG ES&quot;));break;
-            case MUXER_TS:  encoding-&gt;setContainer(QT_TR_NOOP(&quot;MPEG TS&quot;));break;
-            case MUXER_VCD: encoding-&gt;setContainer(QT_TR_NOOP(&quot;MPEG VCD&quot;));break;
-            case MUXER_SVCD:encoding-&gt;setContainer(QT_TR_NOOP(&quot;MPEG SVCD&quot;));break;
-            case MUXER_DVD: encoding-&gt;setContainer(QT_TR_NOOP(&quot;MPEG DVD&quot;));break;
-            default:
-                ADM_assert(0);
-          }
-
-
-
-        // pass 1
-        if(encoder-&gt;isDualPass()) //Cannot be requant
-        {
-                        if(!reuse)
-                        {
-                                encoding-&gt;setPhasis (QT_TR_NOOP(&quot;Pass 1/2&quot;));
-                                encoder-&gt;startPass1();
-                                bitstream.data=_buffer;
-                                bitstream.bufferSize=_page;
-                                for(uint32_t i=0;i&lt;total;i++)
-                                {
-                                        bitstream.cleanup(i);
-                                        if(!encoder-&gt;encode( i, &amp;bitstream))//&amp;len,(uint8_t *) _buffer,&amp;flags))
-                                        {
-                                          GUI_Error_HIG(QT_TR_NOOP(&quot;Error in pass 1&quot;), NULL);
-                                        }
-                                        encoding-&gt;setFrame(i,bitstream.len,bitstream.out_quantizer,total);
-                                        if(!encoding-&gt;isAlive())
-                                              goto finishvcdff;
-                                }
-                        }
-                        encoder-&gt;startPass2();
-                        encoding-&gt;reset();
-                }
-                
-              switch(type)
-              {
-                case ADM_PS:
-                  muxer=new mplexMuxer;
-                  break;
-                case ADM_TS:
-                  muxer=new tsMuxer;
-                  break;
-                case ADM_ES:
-                  break;
-                default:
-                  ADM_assert(0);
-      
-      
-              }
-              if(muxer)
-              {
-                if(!muxer-&gt;open(name,0,mux,avifileinfo,audio-&gt;getInfo()))
-                {
-                  printf(&quot;Muxer init failed\n&quot;);
-				  goto finishvcdff;
-                }
-                double sample_time;
-
-                sample_time=total;
-                sample_time*=1000;
-                sample_time/=_fps1000; // target_time in second
-                sample_time*=audio-&gt;getInfo()-&gt;frequency;
-                sample_target=(uint32_t)floor(sample_time);
-              }
-              else
-              {
-                file=fopen(name,&quot;wb&quot;);
-                if(!file)
-                {
-                  GUI_Error_HIG(QT_TR_NOOP(&quot;File error&quot;), QT_TR_NOOP(&quot;Cannot open \&quot;%s\&quot; for writing.&quot;), name);
-				  goto finishvcdff;
-                }
-              }
-          if(encoder-&gt;isDualPass())
-                  encoding-&gt;setPhasis (QT_TR_NOOP(&quot;Pass 2/2&quot;));
-          else
-                  encoding-&gt;setPhasis (QT_TR_NOOP(&quot;Encoding&quot;));
-
-         // Set info for audio if any
-         if(muxer)
-         {
-            if(!audioProcessMode())
-                  encoding-&gt;setAudioCodec(QT_TR_NOOP(&quot;Copy&quot;));
-            else
-                  encoding-&gt;setAudioCodec(getStrFromAudioCodec(audio-&gt;getInfo()-&gt;encoding));
-         }
-         //**********************************************************
-         //  In that case we do multithreadedwriting (yes!)
-         //**********************************************************
-
-         if(mux==MUXER_DVD || mux==MUXER_SVCD || mux==MUXER_VCD)
-         {
-           pthread_t audioThread,videoThread,muxerThread;
-           muxerMT context;
-           //
-           bitstream.data=_outbuffer;
-           bitstream.bufferSize=_page;
-           // 
-           memset(&amp;context,0,sizeof(context));
-           context.videoEncoder=encoder;
-           context.audioEncoder=audio;
-           context.muxer=(mplexMuxer *)muxer;
-           context.nbVideoFrame=total;
-           context.audioTargetSample=sample_target;
-           context.audioBuffer=audioBuffer;
-           context.bitstream=&bitstream;
-           context.opaque=(void *)encoding;
-
-           // start audio thread
-           ADM_assert(!pthread_create(&amp;audioThread,NULL,(THRINP)defaultAudioSlave,&amp;context)); 
-           ADM_assert(!pthread_create(&amp;videoThread,NULL,(THRINP)defaultVideoSlave,&amp;context)); 
-           while(1)
-           {
-             accessMutex.lock();
-             if(!encoding-&gt;isAlive())
-             {
-               context.audioAbort=1;
-               context.videoAbort=1;
-               printf(&quot;[mpegFF]Waiting for slaves\n&quot;);
-               accessMutex.unlock();
-               while(1)
-               {
-                 accessMutex.lock();
-                 if(context.audioDone &amp;&amp; context.videoDone)
-                 {
-                   printf(&quot;[mpegFF]Both audio &amp; video done\n&quot;);
-                   if(context.audioDone==1 &amp;&amp; context.videoDone==1) ret=1;
-                   accessMutex.unlock();
-                   goto finishvcdff;
-                 }
-                 accessMutex.unlock();
-                 ADM_usleep(50000);
- 
-               }
-               
-             }
-             if(context.audioDone==2 || context.videoDone==2 ) //ERROR
-             {
-               context.audioAbort=1;
-               context.videoAbort=1;
-             }
-             if(context.audioDone &amp;&amp; context.videoDone)
-             {
-               printf(&quot;[mpegFF]Both audio &amp; video done\n&quot;);
-               if(context.audioDone==1 &amp;&amp; context.videoDone==1) ret=1;
-               accessMutex.unlock();
-               goto finishvcdff;
-             }
-             accessMutex.unlock();
-             ADM_usleep(1000*1000);
-             
-           }
-           
-         }
-         //**********************************************************
-         //  NOT MULTITHREADED
-         //**********************************************************
-
-      bitstream.data=_outbuffer;
-      bitstream.bufferSize=_page;
-      for(uint32_t i=0;i&lt;total;i++)
-      {
-       	// get frame
-                bitstream.cleanup(i);
-                if(!encoder-&gt;encode( i,&amp;bitstream))// &amp;len,(uint8_t *) _outbuffer,&amp;flags))
-                {
-                  GUI_Error_HIG(QT_TR_NOOP(&quot;Error in pass 2&quot;), NULL);
-                        goto finishvcdff;
-                }
-                if(!bitstream.len) continue;
-                
-                if(file)
-                {
-                    fwrite(_outbuffer,bitstream.len,1,file);
-                }
-                else
-                {
-                        uint32_t samples; 
-                        
-                        //printf(&quot;%lu %lu\n&quot;,i,dts);
-                        
-                        muxer-&gt;writeVideoPacket(&amp;bitstream);
-                        real_framenum++;
-                        // _muxer-&gt;writeVideoPacket(len,_buffer_out,
-                        //i-MPEG_PREFILL,_codec-&gt;getCodedPictureNumber());
-                        if(total_sample&lt;sample_target)
-                        {
-                            while(muxer-&gt;needAudio() &amp;&amp; total_sample&lt;sample_target) 
-                            {				
-                                if(!audio-&gt;getPacket(audioBuffer, &amp;audioLen, &amp;samples))	
-                                { 
-                                        break; 
-                                }
-                                if(audioLen) 
-                                {
-                                        muxer-&gt;writeAudioPacket(audioLen,audioBuffer); 
-                                        total_sample+=samples;
-                                        audioSum+=audioLen;
-                                }
-                            }
-                        }
-                
-                }
-                encoding-&gt;setFrame(i,bitstream.len,bitstream.out_quantizer,total);
-                encoding-&gt;setAudioSize(audioSum);
-                if(!encoding-&gt;isAlive ())
-                                  goto finishvcdff;
-        }
-        ret=1;
-finishvcdff:
-        printf(&quot;[MPEGFF] Finishing..\n&quot;);
-        delete encoding;
-        end();
-
-        if(file)
-        {
-                fclose(file);
-                file=NULL;
-        }
-        else if(muxer)
-        {
-                muxer-&gt;close();
-                delete muxer;
-                muxer=NULL;
-        }
-
-        delete encoder;
-
-		if (audio)
-			deleteAudioFilter(audio);
-
-        return ret;
-}
-	
-void end (void)
-{
-        
-        delete [] _buffer;
-        delete [] _outbuffer;
-
-        _buffer		=NULL;
-        _outbuffer=NULL;
-        
-        if(twoPass) delete [] twoPass;
-        if(twoFake) delete [] twoFake;
-        
-        twoPass=twoFake=NULL;
-        
-}
-AVDMGenericAudioStream *mpt_getAudioStream (void)
-{
-  AVDMGenericAudioStream *audio = NULL;
-  if (audioProcessMode ())	// else Raw copy mode
-  {
-    if (currentaudiostream-&gt;isCompressed ())
-    {
-      if (!currentaudiostream-&gt;isDecompressable ())
-      {
-        return NULL;
-      }
-    }
-    audio =  buildAudioFilter (currentaudiostream,  video_body-&gt;getTime (frameStart));
-  }
-  else				// copymode
-  {
-      // else prepare the incoming raw stream
-      // audio copy mode here
-    audio = buildAudioFilter (currentaudiostream,video_body-&gt;getTime (frameStart));
-  }
-  return audio;
-}
-#endif	
-// EOF

Deleted: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/oplug_mpegFF/oplug_vcdff.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/oplug_mpegFF/oplug_vcdff.h	2009-07-23 18:18:44 UTC (rev 5131)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/oplug_mpegFF/oplug_vcdff.h	2009-07-23 18:18:46 UTC (rev 5132)
@@ -1,21 +0,0 @@
-/***************************************************************************
-                          oplug_vcdff.h  -  description
-                             -------------------
-    begin                : Sun Nov 10 2002
-    copyright            : (C) 2002 by mean
-    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#ifdef USE_FFMPEG
-#include &quot;ADM_editor/ADM_outputfmt.h&quot;
-uint8_t oplug_mpegff(const char *name,ADM_OUT_FORMAT type);
-
-#endif


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="002346.html">[Avidemux-svn-commit] r5131 -	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/oplug_ogm
</A></li>
	<LI>Next message: <A HREF="002348.html">[Avidemux-svn-commit] r5133 - in	branches/avidemux_2.6_branch_mean/avidemux_plugins:	ADM_muxers ADM_videoEncoder ADM_videoEncoder/ffFlv1
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2347">[ date ]</a>
              <a href="thread.html#2347">[ thread ]</a>
              <a href="subject.html#2347">[ subject ]</a>
              <a href="author.html#2347">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">More information about the Avidemux-svn-commit
mailing list</a><br>
</body></html>
