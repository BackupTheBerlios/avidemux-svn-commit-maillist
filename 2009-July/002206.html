<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Avidemux-svn-commit] r4991 - in	branches/avidemux_2.5_branch_gruntster/avidemux: . ADM_codecs	ADM_encoder ADM_libraries/ADM_utilities	ADM_userInterfaces/ADM_GTK/ADM_dialog	ADM_userInterfaces/ADM_NONE/ADM_dialog
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/avidemux-svn-commit/2009-July/index.html" >
   <LINK REL="made" HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r4991%20-%20in%0A%09branches/avidemux_2.5_branch_gruntster/avidemux%3A%20.%20ADM_codecs%0A%09ADM_encoder%20ADM_libraries/ADM_utilities%0A%09ADM_userInterfaces/ADM_GTK/ADM_dialog%0A%09ADM_userInterfaces/ADM_NONE/ADM_dialog&In-Reply-To=%3C200907031011.n63ABoME016846%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="002205.html">
   <LINK REL="Next"  HREF="002207.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Avidemux-svn-commit] r4991 - in	branches/avidemux_2.5_branch_gruntster/avidemux: . ADM_codecs	ADM_encoder ADM_libraries/ADM_utilities	ADM_userInterfaces/ADM_GTK/ADM_dialog	ADM_userInterfaces/ADM_NONE/ADM_dialog</H1>
    <B>gruntster at mail.berlios.de</B> 
    <A HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r4991%20-%20in%0A%09branches/avidemux_2.5_branch_gruntster/avidemux%3A%20.%20ADM_codecs%0A%09ADM_encoder%20ADM_libraries/ADM_utilities%0A%09ADM_userInterfaces/ADM_GTK/ADM_dialog%0A%09ADM_userInterfaces/ADM_NONE/ADM_dialog&In-Reply-To=%3C200907031011.n63ABoME016846%40sheep.berlios.de%3E"
       TITLE="[Avidemux-svn-commit] r4991 - in	branches/avidemux_2.5_branch_gruntster/avidemux: . ADM_codecs	ADM_encoder ADM_libraries/ADM_utilities	ADM_userInterfaces/ADM_GTK/ADM_dialog	ADM_userInterfaces/ADM_NONE/ADM_dialog">gruntster at mail.berlios.de
       </A><BR>
    <I>Fri Jul  3 12:11:50 CEST 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="002205.html">[Avidemux-svn-commit] r4990 - in	branches/avidemux_2.5_branch_gruntster/avidemux: ADM_codecs	ADM_encoder
</A></li>
        <LI>Next message: <A HREF="002207.html">[Avidemux-svn-commit] r4992 - in	branches/avidemux_2.5_branch_gruntster/platforms/windows:	build_scripts/avidemux installer
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2206">[ date ]</a>
              <a href="thread.html#2206">[ thread ]</a>
              <a href="subject.html#2206">[ subject ]</a>
              <a href="author.html#2206">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: gruntster
Date: 2009-07-03 12:11:38 +0200 (Fri, 03 Jul 2009)
New Revision: 4991

Removed:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_encoder/adm_encXvid4.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_encoder/adm_encXvid4.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_encoder/adm_encxvid.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_encoder/adm_encxvid.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_encoder/xvid_vbr.c
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_encoder/xvid_vbr.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_exLame.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_pipe.cpp
Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_codecs/ADM_codecs.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_encoder/ADM_encCodecDesc.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_encoder/ADM_vidEncode.hxx
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_encoder/CMakeLists.txt
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_encoder/adm_encConfig.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_encoder/adm_encConfig.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_encoder/adm_encoder.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_libraries/ADM_utilities/prefs.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/CMakeLists.txt
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_NONE/ADM_dialog/DIA_none.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/prefs.h
   branches/avidemux_2.5_branch_gruntster/avidemux/prefs.in
Log:
[vidEnc] remove more remnants of old encoders

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_codecs/ADM_codecs.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_codecs/ADM_codecs.cpp	2009-07-03 08:55:54 UTC (rev 4990)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_codecs/ADM_codecs.cpp	2009-07-03 10:11:38 UTC (rev 4991)
@@ -33,10 +33,6 @@
 
 //#include &quot;ADM_colorspace/colorspace.h&quot;
 
-#ifdef USE_XX_XVID
-#include &quot;xvid.h&quot;
-#endif
-
 #include &quot;ADM_codecs/ADM_codec.h&quot;
 #include &quot;ADM_codecs/ADM_mjpeg.h&quot;
 #include &quot;ADM_codecs/ADM_codecNull.h&quot;

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_encoder/ADM_encCodecDesc.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_encoder/ADM_encCodecDesc.h	2009-07-03 08:55:54 UTC (rev 4990)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_encoder/ADM_encCodecDesc.h	2009-07-03 10:11:38 UTC (rev 4991)
@@ -155,22 +155,7 @@
   sizeof (ffmpeg4Extra),
   getFFCompressParams
 };
-COMPRES_PARAMS ffmpegDV = {
-  CodecDV,
-  QT_TR_NOOP(&quot;DV (lavc)&quot;),
-  &quot;DV&quot;,
-  &quot;DV&quot;,
-  COMPRESS_CQ,
-  4,
-  1500,
-  700,
-  1000, // AVG
-  ADM_ENC_CAP_CBR + ADM_ENC_CAP_CQ,
-  ADM_EXTRA_PARAM,
-  &amp;ffmpeg4Extra,
-  sizeof (ffmpeg4Extra),
-  NULL
-};
+
 COMPRES_PARAMS ffmpegFLV1 = {
   CodecFLV1,
   QT_TR_NOOP(&quot;FLV1 (lavc)&quot;),
@@ -489,139 +474,6 @@
   DIA_SVCDParam
 };
 
-/*
-//*************************** Xvid 0.9*****************
-*/
-#ifdef USE_XX_XVID
-#error !!! XVID 0.9 support not codec
-#error !!! XVID 0.9 support not codec
-#error !!! XVID 0.9 support not codec
-#error !!! XVID 0.9 support not codec
-
-
-#endif
-
-//*************************** Xvid 4*****************
-
-#ifdef USE_XVID_4
-xvid4EncParam xvid4Extra = {
-  6,				//int guiLevel;              
-
-  1,				//int min_key_interval;
-  250,				// Max key interval
-  2,				//int bframes;
-
-  0,				//int mpegQuantizer; 
-  0,				//int interlaced;
-  1,				//int inter4mv;
-  0,				//int trellis;       
-  0,				//int cartoon;
-  0,				//int greyscale;             
-  0,				// qpel
-  0,				// GMC
-  1,				// BVHQ
-  1,				// hqac
-  0,				// Chroma optim
-  {2, 2, 2}
-  ,				//qmin
-  {31, 31, 31}
-  ,				//qmax
-
-  0,				//par as input
-  1,				//par width
-  1,				//par height
-
-  // This if for 2 pass   
-  0,				//int keyframe_boost;
-  0,				//int curve_compression_high;
-  0,				//int curve_compression_low;
-  5,				//int overflow_control_strength;
-  5,				//int max_overflow_improvement;
-  5,				//int max_overflow_degradation;
-  0,				//int kfreduction;
-  0,				//int kfthreshold;
-
-  0,				//24,//int container_frame_overhead;
-  150,				//int bquant_ratio;
-  100,				//int bquant_offset;    
-  1,				//vhqmode                
-  1,				// chroma me
-  0,				// turbo
-  0,				// Packed bitstream - Not Xvid Default
-  1,				// closed_gop
-  0,				// bframe_threshold
-  0,                            // Use inter
-  0                             // Use intra
-};
-xvid4EncParam xvid4ExtraIPOD = {
-  6,				//int guiLevel;              
-
-  1,				//int min_key_interval;
-  250,				// Max key interval
-  0,				//int bframes;
-
-  0,				//int mpegQuantizer; 
-  0,				//int interlaced;
-  1,				//int inter4mv;
-  0,				//int trellis;       
-  0,				//int cartoon;
-  0,				//int greyscale;             
-  0,				// qpel
-  0,				// GMC
-  1,				// BVHQ
-  1,				// hqac
-  0,				// Chroma optim
-  {2, 2, 2}
-  ,				//qmin
-  {31, 31, 31}
-  ,				//qmax
-
-  0,				//par as input
-  1,				//par width
-  1,				//par height
-
-  // This if for 2 pass   
-  0,				//int keyframe_boost;
-  0,				//int curve_compression_high;
-  0,				//int curve_compression_low;
-  5,				//int overflow_control_strength;
-  5,				//int max_overflow_improvement;
-  5,				//int max_overflow_degradation;
-  0,				//int kfreduction;
-  0,				//int kfthreshold;
-
-  0,				//24,//int container_frame_overhead;
-  150,				//int bquant_ratio;
-  100,				//int bquant_offset;    
-  1,				//vhqmode                
-  1,				// chroma me
-  0,				// turbo
-  0,				// Packed bitstream - Not Xvid Default
-  1,				// closed_gop
-  0,				// bframe_threshold
-  0,                            // Use inter
-  0                             // Use intra
-};
-
-extern uint8_t DIA_xvid4 (COMPRES_PARAMS * incoming);
-COMPRES_PARAMS Xvid4Codec = {
-  CodecXvid4,
-  QT_TR_NOOP(&quot;MPEG-4 ASP (Xvid4)&quot;),
-  &quot;XVID4&quot;,
-  &quot;XVID 4 mpeg4&quot;,
-  COMPRESS_CQ,
-  4,
-  1500,
-  700,
-  1000, // AVG
-  ADM_ENC_CAP_CBR + ADM_ENC_CAP_CQ + ADM_ENC_CAP_2PASS +ADM_ENC_CAP_2PASS_BR+ADM_ENC_CAP_SAME,
-  ADM_EXTRA_PARAM,
-  &amp;xvid4Extra,
-  sizeof (xvid4Extra),
-  DIA_xvid4
-};
-#endif
-
 COMPRES_PARAMS DUMMYONE =
   { CodecDummy, QT_TR_NOOP(&quot;dummy&quot;), &quot;dummy&quot;, &quot;dummy&quot;, COMPRESS_CQ, 4, 1500, 700,1000, 0, 0,
 NULL, 0 };
@@ -631,9 +483,6 @@
 
 COMPRES_PARAMS *internalVideoCodec[] = {
   &amp;CopyCodec,
-#ifdef USE_XVID_4
-  &amp;Xvid4Codec,
-#endif
   &amp;ffmpegMpeg4,
   &amp;ffmpeg1Codec,
   &amp;ffmpeg2DVDCodec,

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_encoder/ADM_vidEncode.hxx
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_encoder/ADM_vidEncode.hxx	2009-07-03 08:55:54 UTC (rev 4990)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_encoder/ADM_vidEncode.hxx	2009-07-03 10:11:38 UTC (rev 4991)
@@ -21,25 +21,18 @@
 {
   CodecCopy,
   CodecDivx,
-  CodecXvid,
   CodecFF,
   CodecMjpeg,
   CodecH263,
   CodecH263P,
-  CodecFFV1,
-  CodecSnow,
-  CodecHuff,
   CodecVCD,
   CodecSVCD,
   CodecDVD,
   CodecXVCD,
   CodecXSVCD,
   CodecXDVD,
-  CodecXvid4,
-  CodecFFhuff,
   CodecYV12,
   CodecRequant,
-  CodecDV,
   CodecFLV1,
   CodecExternal,
   CodecDummy

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_encoder/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_encoder/CMakeLists.txt	2009-07-03 08:55:54 UTC (rev 4990)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_encoder/CMakeLists.txt	2009-07-03 10:11:38 UTC (rev 4991)
@@ -1,11 +1,6 @@
 SET(ADM_encoder_SRCS 
-	adm_encConfig.cpp  adm_encffmpeg1.cpp  adm_encmjpeg.cpp     adm_encoder.cpp   adm_encxvid.cpp
-	adm_encCopy.cpp    adm_encdivx.cpp    adm_encffmpeg.cpp   adm_encmpeg2enc.cpp  adm_encRequant.cpp  adm_encXvid4.cpp  adm_encyv12.cpp
+	adm_encConfig.cpp  adm_encffmpeg1.cpp  adm_encmjpeg.cpp     adm_encoder.cpp
+	adm_encCopy.cpp    adm_encdivx.cpp    adm_encffmpeg.cpp   adm_encmpeg2enc.cpp  adm_encRequant.cpp  adm_encyv12.cpp
 	ADM_pluginLoad.cpp ADM_externalEncoder.cpp)
 
 ADD_ADM_LIB_ALL_TARGETS(ADM_encoder ${ADM_encoder_SRCS})
-
-IF (USE_XVID_4)
-	ADD_SOURCE_CFLAGS(adm_encxvid.cpp -I${XVID_INCLUDE_DIR})
-	ADD_SOURCE_CFLAGS(adm_encXvid4.cpp -I${XVID_INCLUDE_DIR})
-ENDIF (USE_XVID_4)
\ No newline at end of file

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_encoder/adm_encConfig.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_encoder/adm_encConfig.cpp	2009-07-03 08:55:54 UTC (rev 4990)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_encoder/adm_encConfig.cpp	2009-07-03 10:11:38 UTC (rev 4991)
@@ -47,18 +47,6 @@
 #include &quot;adm_encConfig.h&quot;
 #include &quot;adm_encoder.h&quot;
 
-#ifdef USE_XVID_4
-#include &quot;ADM_codecs/ADM_xvid4.h&quot;
-#include &quot;ADM_codecs/ADM_xvid4param.h&quot;
-#include &quot;adm_encXvid4.h&quot;
-#endif
-
-#ifdef USE_XX_XVID
-#include &quot;ADM_codecs/ADM_xvid.h&quot;
-#include &quot;adm_encxvid.h&quot;
-#include &quot;xvid.h&quot;
-#endif
-
 #include &quot;ADM_codecs/ADM_ffmpeg.h&quot;
 #include &quot;adm_encffmpeg.h&quot;
 
@@ -607,11 +595,6 @@
 
 		e = new EncoderFFMPEG (FF_H263, desc);
 		break;
-#ifdef USE_XVID_4
-	case CodecXvid4:
-		e = new EncoderXvid4 (desc);
-		break;
-#endif
 	case CodecExternal:
 		e = new externalEncoder(&amp;AllVideoCodec[currentCodecIndex], globalHeaderFlag);
 		break;
@@ -785,15 +768,4 @@
 	}
 }
 
-#ifdef USE_XVID_4
-/**
-    \fn     setIpod_Xvid4Preset(void)
-    \brief  set XVID4 codec conf to the Ipod preset
-*/
-void setIpod_Xvid4Preset(void)
-{
-	memcpy(&amp;xvid4Extra,&amp;xvid4ExtraIPOD,sizeof(xvid4ExtraIPOD)); 
-}
-#endif
-
 // EOF

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_encoder/adm_encConfig.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_encoder/adm_encConfig.h	2009-07-03 08:55:54 UTC (rev 4990)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_encoder/adm_encConfig.h	2009-07-03 10:11:38 UTC (rev 4991)
@@ -20,5 +20,4 @@
 const char *videoCodecGetMode(void);
 uint8_t videoCodecSetFinalSize(uint32_t size);
 
-void setIpod_Xvid4Preset(void);
 #endif	// adm_encConfig_h

Deleted: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_encoder/adm_encXvid4.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_encoder/adm_encXvid4.cpp	2009-07-03 08:55:54 UTC (rev 4990)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_encoder/adm_encXvid4.cpp	2009-07-03 10:11:38 UTC (rev 4991)
@@ -1,294 +0,0 @@
-/***************************************************************************
-                          adm_encxvid.cpp  -  description
-                             -------------------
-			     Encoder for Xvid 1.0x (dev-api4)
-    begin                : Sun Jul 14 2002
-    copyright            : (C) 2002/2003 by mean
-    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#include &quot;config.h&quot;
-
-#define __STDC_LIMIT_MACROS
-
-#ifdef USE_XVID_4
-#include &quot;xvid.h&quot;
-
-#include &quot;fourcc.h&quot;
-#include &quot;avi_vars.h&quot;
-
-#include &quot;ADM_default.h&quot;
-
-#include &quot;ADM_encoder/ADM_vidEncode.hxx&quot;
-
-#include &quot;ADM_videoFilter.h&quot;
-#include &quot;ADM_codecs/ADM_xvid4.h&quot;
-#include &quot;ADM_encoder/adm_encoder.h&quot;
-#include &quot;ADM_encoder/adm_encXvid4.h&quot;
-
-
-#define aprintf printf
-
-
-
-/*_________________________________________________*/
-EncoderXvid4::EncoderXvid4 (COMPRES_PARAMS * codecconfig)
-{
-
-  _codec = NULL;
-  strcpy (_logname, &quot;&quot;);
-  _frametogo = 0;
-  _pass1Done = 0;
-
-  memcpy (&amp;_param, codecconfig, sizeof (_param));
-  ADM_assert (codecconfig-&gt;extraSettingsLen == sizeof (encparam));
-  memcpy (&amp;encparam, codecconfig-&gt;extraSettings, sizeof (encparam));
-
-
-};
-EncoderXvid4::~EncoderXvid4 ()
-{
-
-  stop ();
-
-};
-//--------------------------------
-uint8_t
-EncoderXvid4::configure (AVDMGenericVideoStream * instream, int useExistingLogFile)
-{
-  ADM_assert (instream);
-  ADV_Info *info;
-
-  //uint32_t flag1,flag2,flag3;
-  if(encparam.par_as_input)
-  {
-    encparam.par_width=instream-&gt;getPARWidth();
-    encparam.par_height=instream-&gt;getPARHeight();
-  }else
-  {
-      printf(&quot;[xvid] Using %u x %u aspect ratio\n&quot;,encparam.par_width,encparam.par_height);
-  }
-  
-  //
-  info = instream-&gt;getInfo ();
-  _w = info-&gt;width;
-  _h = info-&gt;height;
-//  _vbuffer = new uint8_t[_w * _h * 2];
-  _vbuffer = new ADMImage (_w, _h);
-  ADM_assert (_vbuffer);
-  _in = instream;
-  _fps1000 = info-&gt;fps1000;
-  switch (_param.mode)
-    {
-    case COMPRESS_SAME:
-      printf (&quot;[xvid] Follow quant mode\n&quot;);
-      _state = enc_Same;
-      _codec = new xvid4EncoderVBRExternal (_w, _h);
-      if (!_codec-&gt;init (2, info-&gt;fps1000, &amp;encparam))
-	{
-	  printf (&quot;[xvid] Error init Follow mode\n&quot;);
-	  return 0;
-	}
-      break;
-    case COMPRESS_CQ:
-      printf (&quot;[xvid] CQ mode: %ld\n&quot;, _param.qz);
-      _state = enc_CQ;
-      _codec = new xvid4EncoderCQ (_w, _h);
-
-      if (!_codec-&gt;init (_param.qz, info-&gt;fps1000, &amp;encparam))
-	{
-	  printf (&quot;[xvid] Error init CQ mode\n&quot;);
-	  return 0;
-	}
-      break;
-    case COMPRESS_CBR:
-      printf (&quot;[xvid] CBR mode: %lu\n&quot;, _param.bitrate);
-      _state = enc_CBR;
-
-      _codec = new xvid4EncoderCBR (_w, _h);
-      if (!_codec-&gt;init (_param.bitrate, info-&gt;fps1000, &amp;encparam))
-	{
-	  printf (&quot;[xvid] Error init CBR mode\n&quot;);
-	  return 0;
-	}
-      break;
-    case COMPRESS_2PASS:
-    case COMPRESS_2PASS_BITRATE:
-      if(_param.mode==COMPRESS_2PASS)
-          printf (&quot;[xvid] Dual size: %lu (%s)\n&quot;, _param.finalsize, _logname);
-      else
-          printf (&quot;[xvid] Dual avg br: %u kb/s (%s)\n&quot;, _param.avg_bitrate, _logname);
-      _state = enc_Pass1;
-      _codec = new xvid4EncoderPass1 (_w, _h);
-      strcpy (encparam.logName, _logname);
-      printf (&quot;[xvid] Using %s as stat file\n&quot;, encparam.logName);
-
-      break;
-    default:
-      ADM_assert (0);
-    }
-  printf (&quot;[xvid] Encoder ready, w: %lu h: %lu mode: %d\n&quot;, _w, _h, _state);
-  return 1;
-
-}
-
-
-
-uint8_t EncoderXvid4::startPass1 (void)
-{
-  ADV_Info *
-    info;
-  ADM_assert (_state == enc_Pass1);
-  info = _in-&gt;getInfo ();
-  if (!_codec-&gt;init (_param.bitrate, info-&gt;fps1000, &amp;encparam))
-    {
-      printf (&quot;[xvid] Error init pass 1 mode\n&quot;);
-      return 0;
-    }
-  return 1;
-}
-
-int EncoderXvid4::getRequirements (void) { return ADM_ENC_REQ_NULL_FLUSH; }
-
-uint8_t EncoderXvid4::isDualPass (void)
-{
-  if ((_state == enc_Pass1) || (_state == enc_Pass2))
-    {
-      return 1;
-    }
-  return 0;
-
-}
-
-uint8_t EncoderXvid4::setLogFile (const char *lofile, uint32_t nbframe)
-{
-  strcpy (_logname, lofile);
-  _frametogo = nbframe;
-  _totalframe = nbframe;
-  return 1;
-
-}
-
-//______________________________
-uint8_t
-  EncoderXvid4::encode (uint32_t frame, ADMBitstream *out)
-{
-  uint32_t l, f;
-
-  ADM_assert (_codec);
-  ADM_assert (_in);
-
-  if (frame != UINT32_MAX)
-  {
-	  if (!_in-&gt;getFrameNumberNoAlloc (frame, &amp;l, _vbuffer, &amp;f))
-	  {
-		  printf (&quot;[xvid] Error: Cannot read incoming frame!\n&quot;);
-		  return 0;
-	  }
-  }
-
-  switch (_state)
-    {
-    case enc_Same:
-	{
-		if (frame != UINT32_MAX)
-		{
-			out-&gt;flags = 0;
-
-			if (frame &lt; (encparam.bframes + 1))
-			{
-				out-&gt;flags = AVI_KEY_FRAME;
-				printf (&quot;[xvid] Forcing keyframe for B frame\n&quot;);
-			}
-
-			int q = _vbuffer-&gt;_Qp;
-
-			if (q &lt; 2 || q &gt; 31)
-			{
-				printf (&quot;[xvid] Out of bound incoming q: %d\n&quot;, q);
-
-				if (q &lt; 2)
-					q = 2;
-				if (q &gt; 31)
-					q = 31;
-			}
-
-			out-&gt;in_quantizer = q;
-		}
-	}
-    case enc_CBR:
-    case enc_CQ:
-    case enc_Pass1:
-    case enc_Pass2:
-		return _codec-&gt;encode (frame == UINT32_MAX ? NULL : _vbuffer, out);
-      break;
-
-    default:
-      ADM_assert (0);
-    }
-
-  return 0;
-}
-
-//_______________________________
-uint8_t EncoderXvid4::stop (void)
-{
-  if (_codec)
-    delete
-      _codec;
-  _codec = NULL;
-
-
-  return 1;
-
-}
-extern uint32_t ADM_computeBitrate(uint32_t fps1000, uint32_t nbFrame, uint32_t sizeInMB);
-uint8_t EncoderXvid4::startPass2 (void)
-{
-  uint32_t     finalSize;
-  uint32_t         br;
-
-  ADM_assert (_state == enc_Pass1);
-  printf (&quot;[xvid] Starting pass 2 (%d x %d)\n&quot;, _w, _h);
-
-  if(_param.mode==COMPRESS_2PASS)
-  {
-    
-    br=ADM_computeBitrate( _fps1000,_totalframe,_param.finalsize);
-    printf(&quot;[xvid] Final Size: %u MB, avg bitrate %u kb/s\n&quot;,_param.finalsize,br/1000);
-  }else if(_param.mode==COMPRESS_2PASS_BITRATE)
-  {
-    br=_param.avg_bitrate*1000;
-    printf(&quot;[xvid] 2 pass avg bitrate %u kb/s\n&quot;,br/1000);
-  }else ADM_assert(0);
-
-  _state = enc_Pass2;
-  // Delete codec and start new one
-  if (_codec)
-    {
-      delete
-	_codec;
-      _codec = NULL;
-    }
-
-  _codec = new xvid4EncoderPass2 (_w, _h);
-  strcpy (encparam.logName, _logname);
-  printf (&quot;[xvid] Using %s as stat file, average bitrate %d kbps\n&quot;, _logname,	  br / 1000);
-  if (!_codec-&gt;init (br, _fps1000, &amp;encparam))
-    {
-      printf (&quot;[xvid] Error initializing pass1 mode\n&quot;);
-      return 0;
-    }
-  _frametogo = 0;
-  return 1;
-}
-
-#endif

Deleted: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_encoder/adm_encXvid4.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_encoder/adm_encXvid4.h	2009-07-03 08:55:54 UTC (rev 4990)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_encoder/adm_encXvid4.h	2009-07-03 10:11:38 UTC (rev 4991)
@@ -1,69 +0,0 @@
-/***************************************************************************
-                          adm_encxvi4d.h  -  description
-                             -------------------
-			     structure for xvid api-4 encoder
-    begin                : Sun Jul 14 2002
-    copyright            : (C) 2002/2003 by mean
-    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#ifndef __ADM_encoder_xvid4__
-#define __ADM_encoder_xvid4__
-#include &quot;ADM_codecs/ADM_xvid4param.h&quot;
-typedef struct XVID4config
-{
-  COMPRES_PARAMS generic;
-  xvid4EncParam specific;
-} XVID4config;
-
-
-class EncoderXvid4:public Encoder
-{
-
-protected:
-
-  xvid4Encoder * _codec;
-  xvid4EncParam encparam;
-
-
-  uint32_t _totalframe;
-  uint8_t _pass1Done;
-  uint32_t _fps1000;
-
-public:
-    EncoderXvid4 (COMPRES_PARAMS * codecconfig);
-   ~EncoderXvid4 ();		// can be called twice if needed ..
-  virtual int getRequirements (void);
-  virtual uint8_t isDualPass (void);
-  virtual uint8_t configure (AVDMGenericVideoStream * instream, int useExistingLogFile);
- 
-  virtual uint8_t encode (uint32_t frame, ADMBitstream *out);
-  virtual uint8_t setLogFile (const char *p, uint32_t fr);
-  virtual uint8_t stop (void);
-  virtual uint8_t startPass2 (void);
-  virtual uint8_t startPass1 (void);
-  virtual const char *getCodecName (void)
-  {
-    return &quot;XVID&quot;;
-  }
-  virtual const char *getFCCHandler (void)
-  {
-    return &quot;xvid&quot;;
-  }
-  virtual const char *getDisplayName (void)
-  {
-    return QT_TR_NOOP(&quot;Xvid4&quot;);
-  }
-
-};
-
-
-#endif

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_encoder/adm_encoder.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_encoder/adm_encoder.cpp	2009-07-03 08:55:54 UTC (rev 4990)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_encoder/adm_encoder.cpp	2009-07-03 10:11:38 UTC (rev 4991)
@@ -41,19 +41,6 @@
 
 #endif
 
-#ifdef USE_XX_XVID
-#include &quot;ADM_codecs/ADM_xvid.h&quot;
-#include &quot;ADM_encoder/adm_encxvid.h&quot;
-
-#endif
-#ifdef USE_XVID_4
-#include &quot;ADM_codecs/ADM_xvid4.h&quot;
-#include &quot;ADM_codecs/ADM_xvid4param.h&quot;
-#include &quot;ADM_encoder/adm_encXvid4.h&quot;
-
-#endif
-
-
 #ifdef USE_FFMPEG
 #include &quot;ADM_codecs/ADM_ffmpeg.h&quot;
 #include &quot;ADM_encoder/adm_encffmpeg.h&quot;
@@ -100,16 +87,6 @@
   printf (&quot;MJPEG encoder registered\n&quot;);
 #endif
 
-#ifdef USE_XX_XVID
-    nb_encoder++;
-    printf (&quot;Xvid encoder registered\n&quot;);
-#endif
-
-#ifdef USE_XVID_4
-    nb_encoder++;
-    printf (&quot;Xvid-4 encoder registered\n&quot;);
-#endif
-
 #ifdef USE_FFMPEG
   nb_encoder++;
   printf (&quot;FFmpeg encoder registered\n&quot;);

Deleted: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_encoder/adm_encxvid.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_encoder/adm_encxvid.cpp	2009-07-03 08:55:54 UTC (rev 4990)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_encoder/adm_encxvid.cpp	2009-07-03 10:11:38 UTC (rev 4991)
@@ -1,429 +0,0 @@
-/***************************************************************************
-                          adm_encxvid.cpp  -  description
-                             -------------------
-    begin                : Sun Jul 14 2002
-    copyright            : (C) 2002 by mean
-    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-#include &lt;stdio.h&gt;
-#include &lt;stdlib.h&gt;
-#include &lt;math.h&gt;
-#include &lt;unistd.h&gt;
-
-#include &lt;time.h&gt;
-#include &lt;sys/time.h&gt;
-#include &quot;config.h&quot;
-#ifdef USE_XX_XVID
-#include &quot;xvid.h&quot;
-
-#include &quot;fourcc.h&quot;
-#include &quot;avi_vars.h&quot;
-#include &quot;ADM_toolkit/toolkit.hxx&quot;
-
-#include &quot;ADM_encoder/ADM_vidEncode.hxx&quot;
-
-#include &quot;ADM_video/ADM_genvideo.hxx&quot;
-#include &quot;ADM_codecs/ADM_xvid.h&quot;
-#include &quot;ADM_encoder/adm_encoder.h&quot;
-#include &quot;ADM_encoder/adm_encxvid.h&quot;
-#include &quot;ADM_assert.h&quot;
-extern &quot;C&quot;
-{
-#include &quot;ADM_encoder/xvid_vbr.h&quot;
-};
-#include &quot;ADM_gui/GUI_xvidparam.h&quot;
-
-static vbr_control_t vbrstate;
-#define aprintf printf
-//static char *XvidInternal2pass_statfile=(const char *)&quot;/tmp/xvid_int2pass.txt&quot;;
-
-#define USE_XVID_2PASS 1
-
-/*_________________________________________________*/
-EncoderXvid::EncoderXvid (XVIDconfig * codecconfig)
-{
-
-  _codec = NULL;
-  fd = NULL;
-  //entries = NULL;       
-  strcpy (_logname, &quot;&quot;);
-  _frametogo = 0;
-  _pass1Done = 0;
-  memset (&amp;encparam, 0, sizeof (encparam));
-  memset (&amp;vbrstate, 0, sizeof (vbrstate));
-  // codecconfig is of type XvidCodecConfig
-  memcpy (&amp;_param, &amp;(codecconfig-&gt;generic), sizeof (_param));
-  memcpy (&amp;encparam, &amp;(codecconfig-&gt;specific), sizeof (encparam));
-//  _logFile=codecconfig-&gt;specific.logName;//XvidInternal2pass_statfile;
-
-};
-//--------------------------------
-uint8_t EncoderXvid::configure (AVDMGenericVideoStream * instream, int useExistingLogFile)
-{
-  ADM_assert (instream);
-  ADV_Info *
-    info;
-
-  //uint32_t flag1,flag2,flag3;
-
-  info = instream-&gt;getInfo ();
-  _w = info-&gt;width;
-  _h = info-&gt;height;
-  printf (&quot;Configuting xvif encoder (%dx%d)\n&quot;, _w, _h);
-  _vbuffer = new ADMImage (_w, _h);
-  ADM_assert (_vbuffer);
-  _in = instream;
-
-
-
-  switch (_param.mode)
-    {
-    case COMPRESS_CQ:
-      printf (&quot;\n Xvid cq mode: %ld&quot;, _param.qz);
-      _state = enc_CQ;
-      _codec = new xvidEncoderCQ (_w, _h);
-      encparam.lumi = 0;
-      _codec-&gt;initExtented (_param.qz, &amp;encparam);
-      break;
-    case COMPRESS_CBR:
-      printf (&quot;\n Xvid cbr mode: %lu&quot;, _param.bitrate);
-      _state = enc_CBR;
-      encparam.lumi = 0;
-      _codec = new xvidEncoderCBR (_w, _h);
-      _codec-&gt;initExtented (_param.bitrate, &amp;encparam);	//qz,bitrate,finalsize;
-      break;
-    case COMPRESS_2PASS:
-
-      // initialize Xvid internal 2 pass mode
-
-      if (0 &gt; vbrSetDefaults (&amp;vbrstate))
-	return 0;
-      vbrstate.fps = info-&gt;fps1000 / 1000.;
-      // our stuff
-
-
-      printf (&quot;\n Xvid dual size: %lu&quot;, _param.finalsize);
-      _state = enc_Pass1;
-      _codec = new xvidEncoderCQ (_w, _h);
-      _codec-&gt;initExtented (2, &amp;encparam);
-
-      break;
-    default:
-      ADM_assert (0);
-
-    }
-  _in = instream;
-  printf (&quot;\n Xvid Encoder , w: %lu h:%lu mode:%d&quot;, _w, _h, _state);
-  return 1;
-
-}
-
-
-
-uint8_t EncoderXvid::startPass1 (void)
-{
-  ADM_assert (_state == enc_Pass1);
-  _frametogo = 0;
-  printf (&quot;\n Starting pass 1\n&quot;);
-  printf (&quot; Creating logfile :%s\n&quot;, _logname);
-  _pass1Done = 1;
-
-  vbrstate.mode = VBR_MODE_2PASS_1;
-  vbrstate.desired_size = _param.finalsize * 1024 * 1024;
-  vbrstate.debug = 0;
-  vbrstate.filename = _logname;	//XvidInternal2pass_statfile;
-
-
-  setAdvancedOptions ();
-
-  if (0 &gt; vbrInit (&amp;vbrstate))
-    return 0;
-  fd = fopen (_logname, &quot;wt&quot;);
-  if (!fd)
-    {
-      printf (&quot;\n cannot create logfile !\n&quot;);
-      return 0;
-    }
-  return 1;
-}
-
-
-
-uint8_t EncoderXvid::isDualPass (void)
-{
-  if ((_state == enc_Pass1) || (_state == enc_Pass2))
-    {
-      return 1;
-    }
-  return 0;
-
-}
-
-uint8_t EncoderXvid::setLogFile (const char *lofile, uint32_t nbframe)
-{
-  strcpy (_logname, lofile);
-  _frametogo = nbframe;
-  _totalframe = nbframe;
-  return 1;
-
-}
-
-//______________________________
-uint8_t
-  EncoderXvid::encode (uint32_t frame, uint32_t * len, uint8_t * out,
-		       uint32_t * flags)
-{
-  uint32_t l, f;
-  //ENC_RESULT enc;
-
-  ADM_assert (_codec);
-  ADM_assert (_in);
-
-  if (!_in-&gt;getFrameNumberNoAlloc (frame, &amp;l, _vbuffer, &amp;f))
-    {
-      printf (&quot;\n Error : Cannot read incoming frame !&quot;);
-      return 0;
-    }
-
-  switch (_state)
-    {
-    case enc_CBR:
-    case enc_CQ:
-      return _codec-&gt;encode (_vbuffer, out, len, flags);
-      break;
-    case enc_Pass1:
-
-
-      ADM_assert (fd);
-      if (!_codec-&gt;encode (_vbuffer, out, len, flags))
-	{
-	  printf (&quot;\n codec error on 1st pass !&quot;);
-	  return 0;
-	}
-      myENC_RESULT enc;
-      // Grab result
-      _codec-&gt;getResult ((void *) &amp;enc);
-
-      fprintf (fd,
-	       &quot;Frame %ld: intra %d, quant %d, texture %d, motion %d, total %d\n&quot;,
-	       frame, enc.is_key_frame, enc.quantizer, enc.texture_bits,
-	       enc.motion_bits, enc.total_bits);
-
-      updateStats (*len);
-      _frametogo++;
-      return 1;
-      break;
-    case enc_Pass2:
-
-      uint16_t nq;
-      uint8_t nf;
-
-      nq = vbrGetQuant (&amp;vbrstate);
-      nf = vbrGetIntra (&amp;vbrstate);
-      //aprintf(&quot;Key : %d\n&quot;,nf);
-
-      // Encode it !
-      *flags = (nq &lt;&lt; 8) + nf;	// ugly but help to keep interface
-      if (!_codec-&gt;encode (_vbuffer, out, len, flags))
-	return 0;
-      updateStats (*len);
-      old_bits = enc.total_bits;
-      return 1;
-      break;
-      break;
-    default:
-      ADM_assert (0);
-    }
-  return 0;
-}
-
-//_______________________________
-uint8_t EncoderXvid::stop (void)
-{
-  if (_codec)
-    delete
-      _codec;
-  _codec = NULL;
-  if (_state == enc_Pass1 || _state == enc_Pass2)
-    {
-      if (_state == enc_Pass1 &amp;&amp; _pass1Done)
-	vbrFinish (&amp;vbrstate);
-      _state = enc_Invalid;
-    }
-
-  return 1;
-
-}
-
-uint8_t EncoderXvid::startPass2 (void)
-{
-
-  ADM_assert (_state == enc_Pass1);
-  printf (&quot;\n Starting pass 2\n&quot;);
-
-  // update xvid internal 2 pass engine
-  if (_pass1Done)
-    {
-      vbrFinish (&amp;vbrstate);	// ???
-      if (fd)
-	{
-	  fclose (fd);
-	  fd = NULL;
-	}
-    }
-  encparam.lumi = 0;		// we reset it after first pass                    
-  // switch to pass 2
-  vbrstate.mode = VBR_MODE_2PASS_2;
-  vbrstate.desired_size = _param.finalsize * 1024 * 1024;
-
-  float
-    br;
-
-  br = vbrstate.desired_size * 8;
-  br = br / _totalframe;	// bit / frame
-  br = br * vbrstate.fps;
-
-  vbrstate.desired_bitrate = (int) floor (br);
-  vbrstate.debug = 0;
-  vbrstate.filename = _logname;	//XvidInternal2pass_statfile;
-  setAdvancedOptions ();
-
-  vbrInit (&amp;vbrstate);
-
-  printf (&quot;\n start 2 extra paramaters\n&quot;);
-
-  // now read and compute
-  _frametogo = _totalframe;
-/*  if (!computeParameters ())
-    return 0;
-*/
-  printf (&quot;\n VBR paramaters computed\n&quot;);
-  _state = enc_Pass2;
-  old_bits = 0;
-  // Delete codec and start new one
-  if (_codec)
-    {
-      delete _codec;
-      _codec = NULL;
-    }
-  _codec = new xvidEncoderVBR (_w, _h);
-  printf (&quot;\n ready to encode in 2pass\n&quot;);
-  _codec-&gt;initExtented (2, &amp;encparam);
-  _frametogo = 0;
-  return 1;
-
-}
-
-EncoderXvid::~EncoderXvid ()
-{
-  stop ();
-
-};
-	 // can be called twice if needed ..
-uint8_t
-EncoderXvid::updateStats (uint32_t len)
-{
-
-  myENC_RESULT enc;
-  XVID_ENC_STATS *stat;
-  // Update bits
-  _codec-&gt;getResult (&amp;enc);
-
-  // update Xvid                                                                                                                  
-  stat = (XVID_ENC_STATS *) _codec-&gt;getXvidStat ();
-  vbrUpdate (&amp;vbrstate,
-	     stat-&gt;quant,
-	     enc.is_key_frame,
-	     stat-&gt;hlength, len, stat-&gt;kblks, stat-&gt;mblks, stat-&gt;ublks);
-
-  return 1;
-}
-/*
-  	Set Xvid 2 pass advanced options
-    __________________________________
-*/
-void
-EncoderXvid::setAdvancedOptions (void)
-{
-
-  // disable cred
-  //***************************
-  //***************************
-  //***************************          
-  //encparam.cred_rate=0;
-  //***************************
-  //***************************
-  //***************************
-
-  vbrstate.min_iquant = encparam.imin;
-  vbrstate.max_iquant = encparam.imax;
-  vbrstate.min_pquant = encparam.pmin;
-  vbrstate.max_pquant = encparam.pmax;
-  vbrstate.keyframe_boost = encparam.kfboost;
-
-  printf (&quot; I : %d/%d P : %d/%d\n&quot;,
-	  vbrstate.min_iquant,
-	  vbrstate.max_iquant, vbrstate.min_pquant, vbrstate.max_pquant);
-
-  // allow specific credit handling 
-  if (encparam.cred_rate)
-    {
-      if (encparam.startcred_end)
-	{
-	  vbrstate.credits_start_begin = encparam.startcred_start;
-	  vbrstate.credits_start_end = encparam.startcred_end;
-
-	  vbrstate.credits_quant_ratio = encparam.cred_rate;
-
-	  vbrstate.credits_mode = VBR_CREDITS_MODE_RATE;
-	  printf (&quot;\n Start credit activated : From %d to %d rate %d\n&quot;,
-		  encparam.startcred_start,
-		  encparam.startcred_end, encparam.cred_rate);
-	  vbrstate.credits_start = 1;
-	}
-
-      if (encparam.endcred_end)
-	{
-	  vbrstate.credits_end_begin = encparam.endcred_start;
-	  vbrstate.credits_end_end = encparam.endcred_end;
-
-	  vbrstate.credits_quant_ratio = encparam.cred_rate;
-
-	  vbrstate.credits_mode = VBR_CREDITS_MODE_RATE;
-	  printf (&quot;\n End credit activated : From %d to %d rate %d\n&quot;,
-		  encparam.endcred_start,
-		  encparam.endcred_end, encparam.cred_rate);
-	  vbrstate.credits_end = 1;
-
-	}
-    }
-
-#define SETIDEM(x) {vbrstate.x=encparam.x; printf( #x&quot;: %d\n&quot;,vbrstate.x);}
-  SETIDEM (min_key_interval);
-  SETIDEM (bitrate_payback_delay);
-  SETIDEM (curve_compression_high);
-  SETIDEM (curve_compression_low);
-  SETIDEM (use_alt_curve);
-  SETIDEM (alt_curve_low_dist);
-  SETIDEM (alt_curve_high_dist);
-  SETIDEM (alt_curve_auto_str);
-  SETIDEM (alt_curve_type);
-  SETIDEM (bitrate_payback_method);
-#undef SETIDEM
-  vbrstate.alt_curve_use_auto = 1;
-  vbrstate.alt_curve_use_auto_bonus_bias = 1;
-  vbrstate.alt_curve_bonus_bias = 50;
-
-
-}
-#endif

Deleted: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_encoder/adm_encxvid.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_encoder/adm_encxvid.h	2009-07-03 08:55:54 UTC (rev 4990)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_encoder/adm_encxvid.h	2009-07-03 10:11:38 UTC (rev 4991)
@@ -1,66 +0,0 @@
-/***************************************************************************
-                          adm_encxvid.h  -  description
-                             -------------------
-    begin                : Sun Jul 14 2002
-    copyright            : (C) 2002 by mean
-    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#ifndef __ADM_encoder_xvid__
-#define __ADM_encoder_xvid__
-
-typedef struct XVIDconfig
-{
-  COMPRES_PARAMS generic;
-  xvidEncParam specific;
-} XVIDconfig;
-
-
-class EncoderXvid:public Encoder
-{
-
-protected:
-
-  xvidEncoder * _codec;
-  xvidEncParam encparam;
-  uint8_t updateStats (uint32_t len);
-  void setAdvancedOptions (void);
-  uint32_t _totalframe;
-  uint8_t _pass1Done;
-//  char                                        *_logFile;
-
-public:
-    EncoderXvid (XVIDconfig * codecconfig);
-   ~EncoderXvid ();		// can be called twice if needed ..
-  virtual uint8_t isDualPass (void);
-  virtual uint8_t configure (AVDMGenericVideoStream * instream, int useExistingLogFile);
-  virtual uint8_t encode (uint32_t frame, uint32_t * len, uint8_t * out,
-			  uint32_t * flags);
-  virtual uint8_t setLogFile (const char *p, uint32_t fr);
-  virtual uint8_t stop (void);
-  virtual uint8_t startPass2 (void);
-  virtual uint8_t startPass1 (void);
-  virtual const char *getCodecName (void)
-  {
-    return &quot;XVID&quot;;
-  }
-  virtual const char *getFCCHandler (void)
-  {
-    return &quot;xvid&quot;;
-  }
-  virtual const char *getDisplayName (void)
-  {
-    return QT_TR_NOOP(&quot;Xvid&quot;);
-  }
-};
-
-
-#endif

Deleted: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_encoder/xvid_vbr.c
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_encoder/xvid_vbr.c	2009-07-03 08:55:54 UTC (rev 4990)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_encoder/xvid_vbr.c	2009-07-03 10:11:38 UTC (rev 4991)
@@ -1,2173 +0,0 @@
-/******************************************************************************
- *
- *   XviD VBR Library
- *   
- *   Copyright (C) 2002 Edouard Gomez &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">ed.gomez at wanadoo.fr</A>&gt;
- *
- *   The curve treatment algorithm is based on work done by Foxer &lt;email?&gt; and
- *   Dirk Knop &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">dknop at gwdg.de</A>&gt; for the XviD vfw dynamic library.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- *****************************************************************************/
-
-/* Standard Headers */
-#include &lt;stdio.h&gt;
-#include &lt;string.h&gt;
-#include &lt;fcntl.h&gt;
-#include &lt;stdlib.h&gt;
-#include &lt;math.h&gt;
-#include &quot;ADM_assert.h&quot;
-
-#include &quot;config.h&quot;
-/* Local headers */
-#include &quot;xvid_vbr.h&quot;
-
-/******************************************************************************
- * Build time constants
- *****************************************************************************/
-
-/*
- * Portability note
- * Perhaps the msvc headers define Pi with another constant name
- */
-#define DEG2RAD (M_PI / 180.0)
-
-/* Defaults settings will be computed with the help of these constants */
-#define DEFAULT_DESIRED_SIZE    700
-#define DEFAULT_AUDIO_BITRATE   128
-#define DEFAULT_MOVIE_LENGTH      2
-#define DEFAULT_TWOPASS_BOOST  1000
-#define DEFAULT_FPS           25.0f
-#define DEFAULT_CREDITS_SIZE      0
-
-#define DEFAULT_XVID_DBG_FILE   &quot;xvid.dbg&quot;
-#define DEFAULT_XVID_STATS_FILE &quot;xvid.stats&quot;
-
-#define aprintf printf
-/*#include &quot;ADM_osSupport/ADM_debugID.h&quot;
-#define MODULE_NAME 0
-#include &quot;ADM_osSupport/ADM_debug.h&quot;*/
-/******************************************************************************
- * Local prototypes
- *****************************************************************************/
-
-/* Sub vbrInit cases functions */
-static vbr_init_function vbr_init_dummy;
-static vbr_init_function vbr_init_2pass1;
-static vbr_init_function vbr_init_2pass2;
-static vbr_init_function vbr_init_fixedquant;
-
-/* Sub vbrGetQuant cases functions */
-static vbr_get_quant_function vbr_getquant_1pass;
-static vbr_get_quant_function vbr_getquant_2pass1;
-static vbr_get_quant_function vbr_getquant_2pass2;
-static vbr_get_quant_function vbr_getquant_fixedquant;
-
-/* Sub vbrGetIntra cases functions */
-static vbr_get_intra_function vbr_getintra_1pass;
-static vbr_get_intra_function vbr_getintra_2pass1;
-static vbr_get_intra_function vbr_getintra_2pass2;
-static vbr_get_intra_function vbr_getintra_fixedquant;
-
-/* Sub vbrUpdate prototypes */
-static vbr_update_function vbr_update_dummy;
-static vbr_update_function vbr_update_2pass1;
-static vbr_update_function vbr_update_2pass2;
-
-/* Sub vbrFinish cases functions */
-static vbr_finish_function vbr_finish_dummy;
-static vbr_finish_function vbr_finish_2pass1;
-static vbr_finish_function vbr_finish_2pass2;
-
-/*------------MEANX------------------*/
-/*
-	This table gives more strength to I frame
-	The average I frame should be around 10
-
-
-*/
-static int vbr_predict(vbr_control_t *state,int original_size,int qp);
-static float vbr_get_comp(int oldbits, int qporg, int newbits, int qpused);
-static int  vbr_make_variance(vbr_control_t *state, float compression,  int *variance,int *bitrate);
-static int vbr_getstuff(vbr_control_t *state, int dbytes,double diff);
-static int  vbr_make_clipping(vbr_control_t *state, float compression);
-static const int quant_I_modifier[32]=
-{
-	2,	2,	2,	3,	//00--33
-	4,	5,	6,	6,	//4--7
-	7, 	7, 	8,	8,   	//8--11
-	9,	9, 	10,	10, 	//12--15
-	11,	12, 	12,	13,	//16--19
-	13,	14, 	14,	14,	//20--23
-	15,	15,	15, 	16,	//24--27
-	16,	16,	17,	17  //28--31
-};
-/*
-	That one gives less to B frame
-*/
-static const int quant_B_modifier[32]=
-{
-	3,	3,	3,	3,	//00--33
-	5,	6,	8,	9,	//4--7
-	10, 	11, 	12,	13,   	//8--11
-	14,	16, 	17,	18, 	//12--15
-	20,	21, 	23,	24,	//16--19
-	25,	26, 	28,	29,	//20--23
-	30,	30,	31, 	31,	//24--27
-	31,	31,	31,	31  //28--31
-};
-
-/*------------MEANX------------------*/
-
-/* Is the encoder in the credits */
-#define FRAME_TYPE_NORMAL_MOVIE     0x00
-#define FRAME_TYPE_STARTING_CREDITS 0x01
-#define FRAME_TYPE_ENDING_CREDITS   0x02
-
-/******************************************************************************
- * Inline utility functions
- *****************************************************************************/
-
-static __inline int util_frametype(vbr_control_t *state)
-{
-
-	if(state-&gt;credits_start) {
-
-		if(state-&gt;cur_frame &gt;= state-&gt;credits_start_begin &amp;&amp;
-		   state-&gt;cur_frame &lt; state-&gt;credits_start_end)
-			return(FRAME_TYPE_STARTING_CREDITS);
-
-	}
-
-	if(state-&gt;credits_end) {
-
-		if(state-&gt;cur_frame &gt;= state-&gt;credits_end_begin &amp;&amp;
-		   state-&gt;cur_frame &lt; state-&gt;credits_end_end)
-			return(FRAME_TYPE_STARTING_CREDITS);
-
-	}
-
-	return(FRAME_TYPE_NORMAL_MOVIE);
-
-
-}
-
-static __inline int util_creditsframes(vbr_control_t *state)
-{
-
-	int frames = 0;
-
-	if(state-&gt;credits_start)
-		frames += state-&gt;credits_start_end - state-&gt;credits_start_begin;
-	if(state-&gt;credits_end)
-		frames += state-&gt;credits_end_end - state-&gt;credits_end_begin;
-
-	return(frames);
-
-}
-
-/******************************************************************************
- * Functions
- *****************************************************************************/
-
-/*****************************************************************************
- * Function description :
- *
- * This function initialiazes the vbr_control_t with safe defaults for all
- * modes.
- *
- * Return Values :
- *   = 0
- ****************************************************************************/
-
-int vbrSetDefaults(vbr_control_t *state)
-{
-
-	/* Set all the structure to zero */
-	memset(state, 0, sizeof(state));
-
-	/* Default mode is CBR */
-	state-&gt;mode = VBR_MODE_1PASS;
-
-	/* Default statistic filename */
-	state-&gt;filename = DEFAULT_XVID_STATS_FILE;
-
-	/*
-	 * Default is a 2hour movie on 700Mo CD-ROM + 128kbit sound track
-	 * This represents a target bitrate of 687kbit/s
-	 */
-	state-&gt;desired_size = DEFAULT_DESIRED_SIZE*1024*1024 -
-		DEFAULT_MOVIE_LENGTH*3600*DEFAULT_AUDIO_BITRATE*1000/8;
-	state-&gt;desired_bitrate = state-&gt;desired_size*8/(DEFAULT_MOVIE_LENGTH*3600);
-
-	/* Credits */
-	state-&gt;credits_mode = VBR_CREDITS_MODE_RATE;
-	state-&gt;credits_start = 0;
-	state-&gt;credits_start_begin = 0;
-	state-&gt;credits_start_end = 0;
-	state-&gt;credits_end = 0;
-	state-&gt;credits_end_begin = 0;
-	state-&gt;credits_end_end = 0;
-	state-&gt;credits_quant_ratio = 20;
-	state-&gt;credits_fixed_quant = 20;
-	state-&gt;credits_quant_i = 20;
-	state-&gt;credits_quant_p = 20;
-	state-&gt;credits_start_size = DEFAULT_CREDITS_SIZE*1024*1024;
-	state-&gt;credits_end_size = DEFAULT_CREDITS_SIZE*1024*1024;
-
-	/* Keyframe boost */
-	state-&gt;keyframe_boost = 0;
-	state-&gt;kftreshold = 10;
-	state-&gt;kfreduction = 30;
-	state-&gt;min_key_interval = 1;
-	state-&gt;max_key_interval = (int)DEFAULT_FPS*10;
-
-	/* Normal curve treatment */
-	state-&gt;curve_compression_high = 25;
-	state-&gt;curve_compression_low = 10;
-
-	/* Alt curve */
-	state-&gt;use_alt_curve = 1;
-	state-&gt;alt_curve_type = VBR_ALT_CURVE_LINEAR;
-	state-&gt;alt_curve_low_dist = 90;
-	state-&gt;alt_curve_high_dist = 500;
-	state-&gt;alt_curve_min_rel_qual = 50;
-	state-&gt;alt_curve_use_auto = 1;
-	state-&gt;alt_curve_auto_str = 30;
-	state-&gt;alt_curve_use_auto_bonus_bias = 1;
-	state-&gt;alt_curve_bonus_bias = 50;
-	state-&gt;bitrate_payback_method = VBR_PAYBACK_BIAS;
-	state-&gt;bitrate_payback_delay = 250;
-	state-&gt;twopass_max_bitrate = DEFAULT_TWOPASS_BOOST*state-&gt;desired_bitrate;
-	state-&gt;twopass_max_overflow_improvement = 60;
-	state-&gt;twopass_max_overflow_degradation = 60;
-	state-&gt;max_iquant = 31;
-	state-&gt;min_iquant = 2;
-	state-&gt;max_pquant = 31;
-	state-&gt;min_pquant = 2;
-	state-&gt;fixed_quant = 3;
-
-	state-&gt;max_framesize = (1.0/(float)DEFAULT_FPS) * state-&gt;twopass_max_bitrate / 8;
-
-	state-&gt;fps = (float)DEFAULT_FPS;
-
-	state-&gt;maxAllowedBitrate=0;
-
-	return(0);
-
-}
-
-/*****************************************************************************
- * Function description :
- *
- * This function initialiaze the vbr_control_t state passed in parameter.
- *
- * The initialization depends on state-&gt;mode, there are 4 modes allowed.
- * Each mode description is done in the README file shipped with the lib.
- *
- * Return values :
- *
- *    =  0 on success
- *    = -1 on error
- *****************************************************************************/
-
-int vbrInit(vbr_control_t *state)
-{
-
-	if(state == NULL) return(-1);
-
-	/* Function pointers safe initialization */
-	state-&gt;init     = NULL;
-	state-&gt;getquant = NULL;
-	state-&gt;getintra = NULL;
-	state-&gt;update   = NULL;
-	state-&gt;finish   = NULL;
-
-// MeanX
-	state-&gt;roundup=(int)floor(state-&gt;fps+0.99);
-
-	state-&gt;size   = NULL;
-	state-&gt;kf   = NULL;
-	state-&gt;type   = NULL;
-	printf(&quot;\n Roundup : %d\n&quot;,state-&gt;roundup);
-// MeanX
-	if(state-&gt;debug) {
-
-		state-&gt;debug_file = fopen(DEFAULT_XVID_DBG_FILE, &quot;w+&quot;);
-
-		if(state-&gt;debug_file == NULL)
-			return(-1);
-
-		fprintf(state-&gt;debug_file, &quot;# XviD Debug output\n&quot;);
-		fprintf(state-&gt;debug_file, &quot;# quant | intra | header bytes&quot;
-			&quot;| total bytes | kblocks | mblocks | ublocks&quot;
-			&quot;| vbr overflow | vbr kf overflow&quot;
-			&quot;| vbr kf partial overflow\n\n&quot;);
-	}
-
-	/* Function pointers sub case initialization */
-	switch(state-&gt;mode) {
-	case VBR_MODE_1PASS:
-		state-&gt;init     = vbr_init_dummy;
-		state-&gt;getquant = vbr_getquant_1pass;
-		state-&gt;getintra = vbr_getintra_1pass;
-		state-&gt;update   = vbr_update_dummy;
-		state-&gt;finish   = vbr_finish_dummy;
-		break;
-	case VBR_MODE_2PASS_1:
-		state-&gt;init     = vbr_init_2pass1;
-		state-&gt;getquant = vbr_getquant_2pass1;
-		state-&gt;getintra = vbr_getintra_2pass1;
-		state-&gt;update   = vbr_update_2pass1;
-		state-&gt;finish   = vbr_finish_2pass1;
-		break;
-	case VBR_MODE_FIXED_QUANT:
-		state-&gt;init     = vbr_init_fixedquant;
-		state-&gt;getquant = vbr_getquant_fixedquant;
-		state-&gt;getintra = vbr_getintra_fixedquant;
-		state-&gt;update   = vbr_update_dummy;
-		state-&gt;finish   = vbr_finish_dummy;
-		break;
-	case VBR_MODE_2PASS_2:
-		state-&gt;init     = vbr_init_2pass2;
-		state-&gt;getintra = vbr_getintra_2pass2;
-		state-&gt;getquant = vbr_getquant_2pass2;
-		state-&gt;update   = vbr_update_2pass2;
-		state-&gt;finish   = vbr_finish_2pass2;
-		break;
-	default:
-		return(-1);
-	}
-	
-	return(state-&gt;init(state));
-
-}
-
-/******************************************************************************
- * Function description :
- *
- * This function returns an adapted quantizer according to the current vbr
- * controler state
- *
- * Return values :
- *  the quantizer value (0 &lt;= value &lt;= 31)
- *  (0 is a special case, means : let XviD decide)
- *
- *****************************************************************************/
-
-int vbrGetQuant(vbr_control_t *state)
-{
-
-	/* Returns Zero, so XviD decides alone */
-	if(state == NULL || state-&gt;getquant == NULL) return(0);
-
-	return(state-&gt;getquant(state));
-
-}
-
-/******************************************************************************
- * Function description :
- *
- * This function returns the type of the frame to be encoded next (I or P/B)
- *
- * Return values :
- *  = -1 let the XviD encoder decide wether or not the next frame is I
- *  =  0 no I frame
- *  =  1 force keyframe
- *
- *****************************************************************************/
-
-int vbrGetIntra(vbr_control_t *state)
-{
-
-	/* Returns -1, means let XviD decide */
-	if(state == NULL || state-&gt;getintra == NULL) return(-1);
-
-	return(state-&gt;getintra(state));
-
-}
-
-/******************************************************************************
- * Function description :
- *
- * This function updates the vbr control state according to collected statistics
- * from XviD core
- *
- * Return values :
- *
- *    =  0 on success
- *    = -1 on error
- *****************************************************************************/
-
-int vbrUpdate(vbr_control_t *state,
-	      int quant,
-	      int intra,
-	      int header_bytes,
-	      int total_bytes,
-	      int kblocks,
-	      int mblocks,
-	      int ublocks)
-{
-
-	if(state == NULL || state-&gt;update == NULL) return(-1);
-
-	if(state-&gt;debug &amp;&amp; state-&gt;debug_file != NULL) {
-		int idx;
-
-		fprintf(state-&gt;debug_file, &quot;%d %d %d %d %d %d %d %d %d %d\n&quot;,
-			quant, intra, header_bytes, total_bytes, kblocks,
-			mblocks, ublocks, state-&gt;overflow, state-&gt;KFoverflow,
-			state-&gt;KFoverflow_partial);
-
-		idx = quant;
-
-		if(quant &lt; 1)
-			idx = 1;
-		if(quant &gt; 31)
-			idx = 31;
-
-		idx--;
-
-		state-&gt;debug_quant_count[idx]++;
-
-	}
-
-	return(state-&gt;update(state, quant, intra, header_bytes, total_bytes,
-			     kblocks, mblocks, ublocks));
-
-}
-
-/******************************************************************************
- * Function description :
- *
- * This function stops the vbr controller
- *
- * Return values :
- *
- *    =  0 on success
- *    = -1 on error
- *****************************************************************************/
-
-int vbrFinish(vbr_control_t *state)
-{
-
-	if(state == NULL || state-&gt;finish == NULL) return(-1);
-
-	if(state-&gt;debug &amp;&amp; state-&gt;debug_file != NULL) {
-
-		int i;
-
-		fprintf(state-&gt;debug_file, &quot;\n\n&quot;);
-
-		for(i=0; i&lt;79; i++)
-			fprintf(state-&gt;debug_file, &quot;#&quot;);
-
-		fprintf(state-&gt;debug_file, &quot;\n# Quantizer distribution :\n\n&quot;);
-
-		for(i=0;i&lt;32; i++) {
-
-			fprintf(state-&gt;debug_file, &quot;# quant %d : %d\n&quot;,
-				i+1,
-				state-&gt;debug_quant_count[i]);
-
-		}
-
-		fclose(state-&gt;debug_file);
-
-	}
-
-	return(state-&gt;finish(state));
-
-}
-
-/******************************************************************************
- * Dummy functions - Used when a mode does not need such a function
- *****************************************************************************/
-
-static int vbr_init_dummy(void *sstate)
-{
-
-	vbr_control_t *state = sstate;
-
-	state-&gt;cur_frame = 0;
-
-	return(0);
-
-}
-
-static int vbr_update_dummy(void *state,
-			    int quant,
-			    int intra,
-			    int header_bytes,
-			    int total_bytes,
-			    int kblocks,
-			    int mblocks,
-			    int ublocks)
-{
-	quant=intra+header_bytes+total_bytes+kblocks+mblocks+ublocks; // MEANX : No warning
-	((vbr_control_t*)state)-&gt;cur_frame++;
-
-	return(0);
-
-}
-
-static int vbr_finish_dummy(void *state)
-{
-	if(state)
-	{
-
-	}
-	return(0);
-
-}
-
-/******************************************************************************
- * 1 pass mode - XviD will do its job alone.
- *****************************************************************************/
-
-static int vbr_getquant_1pass(void *state)
-{
-if(state)
-	{
-
-	}
-
-	return(0);
-
-}
-
-static int vbr_getintra_1pass(void *state)
-{
-if(state)
-	{
-
-	}
-	return(-1);
-
-}
-
-/******************************************************************************
- * 2 pass mode - first pass functions
- *****************************************************************************/
-
-static int vbr_init_2pass1(void *sstate)
-{
-
-	FILE *f;
-	vbr_control_t *state = sstate;
-
-	/* Check the filename */
-	if(state-&gt;filename == NULL || state-&gt;filename[0] == '\0')
-		return(-1);
-
-	printf(&quot;XvidVBR: initialized with file :%s, pass 1\n&quot;,state-&gt;filename);
-	/* Initialize safe defaults for 2pass 1 */ 
-	state-&gt;pass1_file = NULL;
-	state-&gt;nb_frames = 0;
-	state-&gt;nb_keyframes = 0;
-	state-&gt;cur_frame = 0;
-
-	/* Open the 1st pass file */
-	if((f = fopen(state-&gt;filename, &quot;w+&quot;)) == NULL)
-		return(-1);
-
-	/*
-	 * The File Header
-	 *
-	 * The extra white spaces will be used during the vbrFinish to write
-	 * the resulting number of frames and keyframes (10 spaces == maximum
-	 * string length of an int on 32bit machines, i don't think anyone is
-	 * encoding more than 4 billion frames :-)
-	 */
-	fprintf(f, &quot;# ASCII XviD vbr stat file version %d\n#\n&quot;, VBR_VERSION);
-	fprintf(f, &quot;# frames    :           \n&quot;);
-	fprintf(f, &quot;# keyframes :           \n&quot;);
-	fprintf(f, &quot;#\n# quant | intra | header bytes | total bytes | kblocks |&quot;
-		&quot; mblocks | ublocks\n\n&quot;);
-
-	/* Save file pointer */
-	state-&gt;pass1_file   = f;
-
-	return(0);
-
-}
-
-static int vbr_getquant_2pass1(void *state)
-{
-
-if(state)
-{
-}
-	return(2);
-
-}
-
-static int vbr_getintra_2pass1(void *state)
-{
-if(state)
-{
-}
-
-	return(-1);
-
-}
-
-static int vbr_update_2pass1(void *sstate,
-			     int quant,
-			     int intra,
-			     int header_bytes,
-			     int total_bytes,
-			     int kblocks,
-			     int mblocks,
-			     int ublocks)
-			     
-
-{
-
-	vbr_control_t *state = sstate;
-
-	if(state-&gt;pass1_file == NULL)
-		return(-1);
-
-	/* Writes the resulting statistics */
-	fprintf(state-&gt;pass1_file, &quot;%d %d %d %d %d %d %d\n&quot;,
-		quant,
-		intra,
-		header_bytes,
-		total_bytes,
-		kblocks,
-		mblocks,
-		ublocks);
-
-	/* Update vbr control state */
-	if(intra) state-&gt;nb_keyframes++;
-	state-&gt;nb_frames++;
-	state-&gt;cur_frame++;
-
-	return(0);
-	
-}
-
-static int vbr_finish_2pass1(void *sstate)
-{
-
-	int c, i;
-	vbr_control_t *state = sstate;
-
-	if(state-&gt;pass1_file == NULL)
-		return(-1);
-
-	/* Goto to the file beginning */
-	fseek(state-&gt;pass1_file, 0, SEEK_SET);
-
-	/* Skip the version line  and the empty line */
-	c = i = 0;
-	do {
-		c = fgetc(state-&gt;pass1_file);
-
-		if(c == EOF) return(-1);
-		if(c == '\n') i++;
-
-	}while(i &lt; 2);
-
-	fseek(state-&gt;pass1_file,0,SEEK_CUR);	// Needed for win32/Mingw
-	
-	/* Overwrite the frame field - safe as we have written extra spaces */
-	fprintf(state-&gt;pass1_file, &quot;# frames    : %.10d\n&quot;, state-&gt;nb_frames);
-
-	/* Overwrite the keyframe field */
-	fprintf(state-&gt;pass1_file, &quot;# keyframes : %.10d\n&quot;,
-		state-&gt;nb_keyframes);
-
-	/* Close the file */
-	if(fclose(state-&gt;pass1_file) != 0)
-		return(-1);
-
-	return(0);
-
-}
-
-/******************************************************************************
- * 2 pass mode - 2nd pass functions (Need to be finished)
- *****************************************************************************/
-
-static int vbr_init_2pass2(void *sstate)
-{
-
-	FILE *f;
-	int c, n, pos_firstframe, credits_frames;
-	long long credits1_bytes;
-	long long credits2_bytes;
-	long long desired;
-	long long total_bytes;
-	long long itotal_bytes;
-	long long start_curved;
-	long long end_curved;
-	double total1;
-	double total2;
-	int precalced=0;
-
-
-	vbr_control_t *state = sstate;
-
-	/* Check the filename */
-	if(state-&gt;filename == NULL || state-&gt;filename[0] == '\0')
-		return(-1);
-
-	/* Initialize safe defaults for 2pass 2 */ 
-	state-&gt;pass1_file = NULL;
-	state-&gt;nb_frames = 0;
-	state-&gt;nb_keyframes = 0;
-
-	/* Open the 1st pass file */
-	if((f = fopen(state-&gt;filename, &quot;r&quot;)) == NULL)
-		return(-1);
-
-	printf(&quot;XvidVBR: initialized with file :%s, pass 2\n&quot;,state-&gt;filename);
-	state-&gt;pass1_file = f;
-
-	/* Get the file version and check against current version */
-	fscanf(state-&gt;pass1_file, &quot;# ASCII XviD vbr stat file version %d\n&quot;, &amp;n);
-
-	if(n != VBR_VERSION) {
-		fclose(state-&gt;pass1_file);
-		state-&gt;pass1_file = NULL;
-		return(-1);
-	}
-
-	/* Skip the blank commented line */
-	c = n = 0;
-	do {
-
-		c = fgetc(state-&gt;pass1_file);
-
-		if(c == EOF) {
-			fclose(state-&gt;pass1_file);
-			state-&gt;pass1_file = NULL;
-			return(-1);
-		}
-
-		if(c == '\n') n++;
-
-	}while(n &lt; 1);
-
-
-	/* Get the number of frames */
-	fscanf(state-&gt;pass1_file, &quot;# frames : %d\n&quot;, &amp;state-&gt;nb_frames);
-
-	/* Compute the desired size */
-	state-&gt;desired_size = (long long)
-		(((long long)state-&gt;nb_frames * (long long)state-&gt;desired_bitrate) /
-		 (state-&gt;fps * 8.0));
-
-	/* Get the number of keyframes */
-	fscanf(state-&gt;pass1_file, &quot;# keyframes : %d\n&quot;, &amp;state-&gt;nb_keyframes);
-
-	/* Allocate memory space for the keyframe_location array */
-	if((state-&gt;keyframe_locations
-	    = (int*)ADM_alloc((state-&gt;nb_keyframes+1)*sizeof(int))) == NULL) {
-		fclose(state-&gt;pass1_file);
-		state-&gt;pass1_file = NULL;
-		return(-1);
-	}
-
-	/* Skip the blank commented line and the colum description */
-	c = n = 0;
-	do {
-
-		c = fgetc(state-&gt;pass1_file);
-
-		if(c == EOF) {
-			fclose(state-&gt;pass1_file);
-			state-&gt;pass1_file = NULL;
-			return(-1);
-		}
-
-		if(c == '\n') n++;
-
-	}while(n &lt; 2);
-
-	/* Save position for future use */
-	pos_firstframe = ftell(state-&gt;pass1_file);
-_AGAIN_:
-	/* Read and initialize some variables */
-	credits1_bytes = credits2_bytes = 0;
-	total_bytes = itotal_bytes = 0;
-	start_curved = end_curved = 0;
-	credits_frames = 0;
-	// MeanX
-	//---------------------------------MeanX----------------------------------
-	if(!precalced)
-	{
-		printf(&quot;nb_frames : %d\n&quot;,state-&gt;nb_frames);
-		state-&gt;size=(int *)ADM_alloc(sizeof(int)*state-&gt;nb_frames);
-		state-&gt;kf=(int *)ADM_alloc(sizeof(int)*state-&gt;nb_frames);
-		state-&gt;type=(int *)ADM_alloc(sizeof(int)*state-&gt;nb_frames);
-
-	// 1 read the whole file in memory
-	//-----------------------------------------------------
-
-		for(state-&gt;cur_frame=0; state-&gt;cur_frame&lt;state-&gt;nb_frames; state-&gt;cur_frame++)
-		{
-
-			int quant, keyframe, frame_hbytes, frame_bytes;
-			int kblocks, mblocks, ublocks;
-
-			fscanf(state-&gt;pass1_file, &quot;%d %d %d %d %d %d %d\n&quot;,
-		       	&amp;quant, &amp;keyframe, &amp;frame_hbytes, &amp;frame_bytes,
-			       &amp;kblocks, &amp;mblocks, &amp;ublocks);
-
-			//
-			// rescale
-			frame_bytes=(frame_bytes*quant)&gt;&gt;1;
-			// In case of max allowed byterate we caps the size to avoid
-			// having a ridiculously high ratio between in quant and out quant
-
-			// ublocks is the frame type : 1 -&gt; I / 2-&gt; P/ 3-&gt; B
-			state-&gt;size[state-&gt;cur_frame]=frame_bytes;
-			state-&gt;type[state-&gt;cur_frame]=ublocks;
-			state-&gt;kf[state-&gt;cur_frame]=keyframe;
-		}
-	} // /precalced
-
-	// 2- compute size
-
-
-/*---------------------------------------------------------------------------------------------------------------------------*/
-	for(state-&gt;cur_frame = c = 0; state-&gt;cur_frame&lt;state-&gt;nb_frames; state-&gt;cur_frame++)
-	{
-
-		int  keyframe,  frame_bytes;
-
-		keyframe=state-&gt;kf[state-&gt;cur_frame];
-		frame_bytes=state-&gt;size[state-&gt;cur_frame];
-
-		/* Is the frame in the beginning credits */
-		if(util_frametype(state) == FRAME_TYPE_STARTING_CREDITS) {
-			credits1_bytes += frame_bytes;
-			credits_frames++;
-			continue;
-		}
-
-		/* Is the frame in the eding credits */
-		if(util_frametype(state) == FRAME_TYPE_ENDING_CREDITS) {
-			credits2_bytes += frame_bytes;
-			credits_frames++;
-			continue;
-		}
-
-		//
-		//
-		/* We only care about Keyframes when not in credits */
-		if(keyframe) {
-			itotal_bytes +=	frame_bytes + frame_bytes *
-				state-&gt;keyframe_boost / 100;
-			total_bytes  += frame_bytes *
-				state-&gt;keyframe_boost / 100;
-			state-&gt;keyframe_locations[c++] = state-&gt;cur_frame;
-		}
-
-		total_bytes += frame_bytes;
-
-	}
-
-	/*-----------------------------------------------------------------------------------------*/
-		printf(&quot;__________________\n&quot;);
-		printf(&quot;desired size : %09lld\n&quot;,state-&gt;desired_size);
-		printf(&quot;pass1   size : %09lld\n&quot;,total_bytes);
-		printf(&quot;__________________\n&quot;);
-	// 3- lookup cap
-/*-----------------------------------------------------------------------------------
----------------------------------------------------------------------------------------*/
-/* Meanx*/
-	/* Here we check if there is a cap influence */
-#if 0
-	if(state-&gt;maxAllowedBitrate &amp;&amp; !precalced) // maxAllowedBitrte is in BYTE/second not bit/s
-	{
-		float var;
-		int bitrate;
-		int out_bitrate[32];
-		int i;
-		int error,index;
-		
-		printf(&quot;Desired bitrate : %d\n&quot;,state-&gt;desired_bitrate);
-		
-		for(i=2;i&lt;32;i++)
-		{		
-		vbr_make_variance(state,i,&amp;var,&amp;bitrate);
-		out_bitrate[i]=bitrate;
-		printf(&quot;Qz : %d Size: %d Ratio:%f\n&quot;,i,out_bitrate[i],(float)out_bitrate[i]/(float)state-&gt;desired_bitrate);
-		}
-		// search best match
-		// 20% margin
-		index=0;
-		error=30*1000*1000;
-		
-		for(i=2;i&lt;32;i++)
-		{
-			if(abs(out_bitrate[i]-state-&gt;desired_bitrate)&lt;error)
-			{
-				error=abs(out_bitrate[i]-state-&gt;desired_bitrate);
-				//printf(&quot;For quant : %d, error is %d\n&quot;,i,error);
-				index=i;
-			}	
-		}
-		printf(&quot;Best match found : Quantizer scale = %d\n&quot;,index);
-		if(index)
-		{
-			vbr_make_clipping(state,index);
-		}
-		precalced=1;
-		goto _AGAIN_;		
-	}
-		
-#endif
-	/*
-	 * Last frame is treated like an I Frame so we can dispatch overflow
-	 * all other the last film segment
-	 */
-	state-&gt;keyframe_locations[c] = state-&gt;cur_frame;
-
-	/* Compensate AVI overhead */
-	desired = state-&gt;desired_size -  state-&gt;nb_frames*24;
-
-	switch(state-&gt;credits_mode) {
-	case VBR_CREDITS_MODE_QUANT :
-
-		state-&gt;movie_curve = (double)
-			(total_bytes - credits1_bytes - credits2_bytes) /
-			(desired  - credits1_bytes - credits2_bytes);
-
-		start_curved = credits1_bytes;
-		end_curved   = credits2_bytes;
-
-		break;
-	case VBR_CREDITS_MODE_SIZE:
-
-		/* start curve = (start / start desired size) */
-		state-&gt;credits_start_curve = (double)
-			(credits1_bytes / state-&gt;credits_start_size);
-
-		/* end curve = (end / end desired size) */
-		state-&gt;credits_end_curve = (double)
-			(credits2_bytes / state-&gt;credits_end_size);
-
-		start_curved = (long long)
-			(credits1_bytes / state-&gt;credits_start_curve);
-
-		end_curved   = (long long)
-			(credits2_bytes / state-&gt;credits_end_curve);
-
-		/* movie curve=(total-credits)/(desired_size-curved credits) */
-		state-&gt;movie_curve = (double)
-			(total_bytes - credits1_bytes - credits2_bytes) /
-			(desired - start_curved - end_curved);
-
-		break;
-	case VBR_CREDITS_MODE_RATE:
-	default:
-
-		/* credits curve = (total/desired_size)*(100/credits_rate) */
-		state-&gt;credits_start_curve = state-&gt;credits_end_curve =
-			((double)total_bytes / desired) *
-			((double)100 / state-&gt;credits_quant_ratio);
-
-		start_curved =
-			(long long)(credits1_bytes/state-&gt;credits_start_curve);
-
-		end_curved   =
-			(long long)(credits2_bytes/state-&gt;credits_end_curve);
-
-		state-&gt;movie_curve = (double)
-			(total_bytes - credits1_bytes - credits2_bytes) /
-			(desired - start_curved - end_curved);
-
-		break;
-	}
-
-	/*
-	 * average frame size = (desired - curved credits - curved keyframes) /
-	 *                      (frames - credits frames - keyframes)
-	 */
-	state-&gt;average_frame = (double)
-		(desired - start_curved - end_curved -
-		 (itotal_bytes / state-&gt;movie_curve)) /
-		(state-&gt;nb_frames - util_creditsframes(state) -
-		 state-&gt;nb_keyframes);
-
-	/* Initialize alt curve parameters */
-	if (state-&gt;use_alt_curve) {
-
-		state-&gt;alt_curve_low =
-			state-&gt;average_frame - state-&gt;average_frame *
-			(double)(state-&gt;alt_curve_low_dist / 100.0);
-
-		state-&gt;alt_curve_low_diff =
-			state-&gt;average_frame - state-&gt;alt_curve_low;
-
-		state-&gt;alt_curve_high =
-			state-&gt;average_frame + state-&gt;average_frame *
-			(double)(state-&gt;alt_curve_high_dist / 100.0);
-
-		state-&gt;alt_curve_high_diff =
-			state-&gt;alt_curve_high - state-&gt;average_frame;
-
-		if (state-&gt;alt_curve_use_auto) {
-
-			if (state-&gt;movie_curve &gt; 1.0)	{
-
-				state-&gt;alt_curve_min_rel_qual =
-					(int)(100.0 - (100.0 - 100.0 / state-&gt;movie_curve) *
-					      (double)state-&gt;alt_curve_auto_str / 100.0);
-
-				if (state-&gt;alt_curve_min_rel_qual &lt; 20)
-					state-&gt;alt_curve_min_rel_qual = 20;
-			}
-			else {
-				state-&gt;alt_curve_min_rel_qual = 100;
-			}
-
-		}
-
-		state-&gt;alt_curve_mid_qual =
-		(1.0 + (double)state-&gt;alt_curve_min_rel_qual / 100.0) / 2.0;
-
-		state-&gt;alt_curve_qual_dev = 1.0 - state-&gt;alt_curve_mid_qual;
-
-		if (state-&gt;alt_curve_low_dist &gt; 100) {
-
-			switch(state-&gt;alt_curve_type) {
-			case VBR_ALT_CURVE_AGGRESIVE:
-				/* Sine Curve (high aggressiveness) */
-				state-&gt;alt_curve_qual_dev *=
-					2.0 /
-					(1.0 +  sin(DEG2RAD * (state-&gt;average_frame * 90.0 / state-&gt;alt_curve_low_diff)));
-
-				state-&gt;alt_curve_mid_qual =
-					1.0 - state-&gt;alt_curve_qual_dev *
-					sin(DEG2RAD * (state-&gt;average_frame * 90.0 / state-&gt;alt_curve_low_diff));
-				break;
-
-			default:
-			case VBR_ALT_CURVE_LINEAR:
-				/* Linear (medium aggressiveness) */
-				state-&gt;alt_curve_qual_dev *=
-					2.0 /
-					(1.0 + state-&gt;average_frame / state-&gt;alt_curve_low_diff);
-
-				state-&gt;alt_curve_mid_qual =
-					1.0 - state-&gt;alt_curve_qual_dev *
-					state-&gt;average_frame / state-&gt;alt_curve_low_diff;
-
-				break;
-
-			case VBR_ALT_CURVE_SOFT:
-				/* Cosine Curve (low aggressiveness) */
-				state-&gt;alt_curve_qual_dev *=
-					2.0 /
-					(1.0 + (1.0 - cos(DEG2RAD * (state-&gt;average_frame * 90.0 / state-&gt;alt_curve_low_diff))));
-
-				state-&gt;alt_curve_mid_qual =
-					1.0 - state-&gt;alt_curve_qual_dev *
-					(1.0 - cos(DEG2RAD * (state-&gt;average_frame * 90.0 / state-&gt;alt_curve_low_diff)));
-
-				break;
-			}
-		}
-	}
-
-	/* Go to the first non credits frame stats line into file */
-	fseek(state-&gt;pass1_file, pos_firstframe, SEEK_SET);
-
-/*-------------------------------------------------------------------------
----------------------------------------------------------------------------*/
-	/* Perform prepass to compensate for over/undersizing */
-	total1 = total2 = 0.0;
-
-	for(state-&gt;cur_frame=0; state-&gt;cur_frame&lt;state-&gt;nb_frames; state-&gt;cur_frame++)
-	{
-
-		int quant, keyframe, frame_hbytes, frame_bytes;
-		int kblocks, mblocks, ublocks;
-
-		fscanf(state-&gt;pass1_file, &quot;%d %d %d %d %d %d %d\n&quot;,
-		       &amp;quant, &amp;keyframe, &amp;frame_hbytes, &amp;frame_bytes,
-		       &amp;kblocks, &amp;mblocks, &amp;ublocks);
-		//
-		// rescale
-		frame_bytes=state-&gt;size[state-&gt;cur_frame];
-		keyframe=state-&gt;kf[state-&gt;cur_frame];
-
-		if(util_frametype(state) != FRAME_TYPE_NORMAL_MOVIE)
-			continue;
-
-		if(!keyframe) {
-
-			double dbytes = frame_bytes / state-&gt;movie_curve;
-			total1 += dbytes;
-
-			if (state-&gt;use_alt_curve) {
-
-				if (dbytes &gt; state-&gt;average_frame) {
-
-					if (dbytes &gt;= state-&gt;alt_curve_high) {
-						total2 += dbytes * (state-&gt;alt_curve_mid_qual - state-&gt;alt_curve_qual_dev);
-					}
-					else {
-						total2+=vbr_getstuff(state,dbytes, state-&gt;alt_curve_high_diff);
-					}
-				}
-				else {
-
-					if (dbytes &lt;= state-&gt;alt_curve_low) {
-						total2 += dbytes;
-					}
-					else {
-						total2+=vbr_getstuff(state,dbytes, state-&gt;alt_curve_high_diff);
-					}
-				}
-			}
-			else {
-				if (dbytes &gt; state-&gt;average_frame) {
-					total2 +=
-						((double)dbytes +
-						 (state-&gt;average_frame - dbytes) *
-						 state-&gt;curve_compression_high / 100.0);
-				}
-				else {
-					total2 +=
-						((double)dbytes +
-						 (state-&gt;average_frame - dbytes) *
-						 state-&gt;curve_compression_low / 100.0);
-				}
-			}
-		}
-	}
-
-	state-&gt;curve_comp_scale= total1 / total2;
-
-
-
-	printf(&quot;Average comp ratio : %f\n&quot;,state-&gt;curve_comp_scale);
-	if (state-&gt;use_alt_curve) {
-
-		double curve_temp, dbytes;
-		int newquant, percent;
-		int oldquant = 1;
-
-		if (state-&gt;alt_curve_use_auto_bonus_bias)
-			state-&gt;alt_curve_bonus_bias = state-&gt;alt_curve_min_rel_qual;
-
-		state-&gt;curve_bias_bonus =
-			(total1 - total2) * (double)state-&gt;alt_curve_bonus_bias /
-			(100.0 * (double)(state-&gt;nb_frames - util_creditsframes(state) - state-&gt;nb_keyframes));
-		state-&gt;curve_comp_scale =
-			((total1 - total2) * (1.0 - (double)state-&gt;alt_curve_bonus_bias / 100.0) + total2) /
-			total2;
-
-
-		for (n=1; n &lt;= (int)(state-&gt;alt_curve_high*2) + 1; n++) {
-			dbytes = n;
-			if (dbytes &gt; state-&gt;average_frame)
-			{
-				if (dbytes &gt;= state-&gt;alt_curve_high) {
-					curve_temp = dbytes * (state-&gt;alt_curve_mid_qual - state-&gt;alt_curve_qual_dev);
-				}
-				else {
-					curve_temp=vbr_getstuff(state,dbytes, state-&gt;alt_curve_high_diff);
-					}
-			}
-			else {
-				if (dbytes &lt;= state-&gt;alt_curve_low) {
-					curve_temp = dbytes;
-				}
-				else {
-				curve_temp=vbr_getstuff(state,dbytes,state-&gt;alt_curve_low_diff);
-
-				}
-			}
-
-			if (state-&gt;movie_curve &gt; 1.0)
-				dbytes *= state-&gt;movie_curve;
-
-			newquant = (int)(dbytes * 2.0 / (curve_temp * state-&gt;curve_comp_scale + state-&gt;curve_bias_bonus));
-			if (newquant &gt; 1)
-			{
-				if (newquant != oldquant)
-				{
-					oldquant = newquant;
-					percent = (int)((n - state-&gt;average_frame) * 100.0 / state-&gt;average_frame);
-				}
-
-			}
-
-		}
-
-	}
-
-	state-&gt;overflow = 0;
-	state-&gt;KFoverflow = 0;
-	state-&gt;KFoverflow_partial = 0;
-	state-&gt;KF_idx = 1;
-
-	for (n=0 ; n &lt; 32 ; n++) {
-		state-&gt;quant_error[n] = 0.0;
-		state-&gt;quant_count[n] = 0;
-	}
-
-	state-&gt;curve_comp_error = 0.0;
-	state-&gt;last_quant = 0;
-
-	/*
-	 * Above this frame size limit, normal vbr rules will not apply
-	 * This means :
-	 *      1 - Quant can de/increase more than -/+2 between 2 frames
-	 *      2 - Leads to artifacts because of 1
-	 */
-	state-&gt;max_framesize = state-&gt;twopass_max_bitrate/state-&gt;fps;
-
-	/* Get back to the beginning of frame statistics */
-	fseek(state-&gt;pass1_file, pos_firstframe, SEEK_SET);
-
-	/*
-	 * Small hack : We have to get next frame stats before the
-	 * getintra/quant calls
-	 * User clients update the data when they call vbrUpdate
-	 * we are just bypassing this because we don't have to update
-	 * the overflow and so on...
-	 */
-	{
-
-		/* Fake vars */
-		int next_hbytes, next_kblocks, next_mblocks, next_ublocks;
-
-		fscanf(state-&gt;pass1_file, &quot;%d %d %d %d %d %d %d\n&quot;,
-		       &amp;state-&gt;pass1_quant, &amp;state-&gt;pass1_intra, &amp;next_hbytes,
-		       &amp;state-&gt;pass1_bytes, &amp;next_kblocks, &amp;next_mblocks,
-		       &amp;next_ublocks);
-
-	}
-	/* MeanX same as before, scale it to 2 */
-		state-&gt;pass1_bytes=state-&gt;size[0];;
-		state-&gt;pass1_quant=2;
-
-	/* /MeanX*/
-
-	/* Initialize the frame counter */
-	state-&gt;cur_frame = 0;
-	state-&gt;last_keyframe = 0;
-	/* Reset compressibility to 0 = linear scale */
-	{
-		int j;
-		for(j=0;j&lt;AVG_LOOKUP;j++)
-			state-&gt;compr[j]=0;
-	}
-
-	// VBV buffer init
-	state-&gt;vbv_fullness=state-&gt;vbv_buffer_size;
-	state-&gt;bits_per_image=(state-&gt;maxAllowedBitrate*8)/state-&gt;roundup; // Fixme, small error here
-	printf(&quot;Xvid 2 pass Bitrate enforcement\n&quot;);
-	printf(&quot;===============================\n&quot;);
-	printf(&quot;Xvid:Using a buffer of %d kByte\n&quot;,state-&gt;vbv_buffer_size/(8*1024));
-	printf(&quot;Xvid:Using a bitrate   %d kbps\n&quot;,state-&gt;maxAllowedBitrate*8/1000);
-	printf(&quot;Xvid:Bits per image    %d bits\n&quot;,state-&gt;bits_per_image);
-	return(0);
-
-}
-
-static int vbr_getquant_2pass2(void *sstate)
-{
-	int quant;
-	int intra;
-	int bytes1, bytes2;
-	int overflow;
-	int capped_to_max_framesize = 0;
-	int KFdistance, KF_min_size;
-	vbr_control_t *state;
-	int i;
-	int sum=0;
-	int ratio;
-	int target;
-	int projected ;
-	double r;
-	int projected_vbv;
-	
-	int tryme,ok,orgquant;
-
-	 state= (vbr_control_t	* )sstate;
-	 target=state-&gt;cur_frame%state-&gt;roundup;
-
-	bytes1 = state-&gt;pass1_bytes;
-	overflow = state-&gt;overflow / 8;
-	/* To shut up gcc warning */
-	bytes2 = bytes1;
-
-
-	if (state-&gt;pass1_intra)
-	{
-		overflow = 0;
-	}
-
-	if (util_frametype(state) != FRAME_TYPE_NORMAL_MOVIE)
-	{
-
-
-		switch (state-&gt;credits_mode) {
-		case VBR_CREDITS_MODE_QUANT :
-			if (state-&gt;credits_quant_i != state-&gt;credits_quant_p) {
-				quant = state-&gt;pass1_intra ?
-					state-&gt;credits_quant_i:
-					state-&gt;credits_quant_p;
-			}
-			else {
-				quant = state-&gt;credits_quant_p;
-			}
-
-			state-&gt;bytes1 = bytes1;
-			state-&gt;bytes2 = bytes1;
-			state-&gt;desired_bytes2 = bytes1;
-			return(quant);
-		default:
-		case VBR_CREDITS_MODE_RATE :
-		case VBR_CREDITS_MODE_SIZE :
-			if(util_frametype(state) == FRAME_TYPE_STARTING_CREDITS)
-				bytes2 = (int)(bytes1 / state-&gt;credits_start_curve);
-			else
-				bytes2 = (int)(bytes1 / state-&gt;credits_end_curve);
-			break;
-		}
-	}
-	else {
-		/* Foxer: apply curve compression outside credits */
-		double dbytes, curve_temp;
-
-		bytes2 = bytes1;
-
-		if (state-&gt;pass1_intra)
-			dbytes = ((int)(bytes2 + bytes2 * state-&gt;keyframe_boost / 100)) /
-				state-&gt;movie_curve;
-		else
-			dbytes = bytes2 / state-&gt;movie_curve;
-
-		/* spread the compression error accross payback_delay frames */
-		if (state-&gt;bitrate_payback_method == VBR_PAYBACK_BIAS)	{
-			bytes2 = (int)(state-&gt;curve_comp_error / state-&gt;bitrate_payback_delay);
-		}
-		else {
-			bytes2 = (int)(state-&gt;curve_comp_error * dbytes /
-				state-&gt;average_frame / state-&gt;bitrate_payback_delay);
-
-			if (labs(bytes2) &gt; fabs(state-&gt;curve_comp_error))
-				bytes2 = (int)state-&gt;curve_comp_error;
-		}
-
-		state-&gt;curve_comp_error -= bytes2;
-
-		if (state-&gt;use_alt_curve) {
-
-			if (!state-&gt;pass1_intra) {
-
-				if (dbytes &gt; state-&gt;average_frame) {
-					if (dbytes &gt;= state-&gt;alt_curve_high)
-						curve_temp = dbytes * (state-&gt;alt_curve_mid_qual - state-&gt;alt_curve_qual_dev);
-					else
-					{
-						curve_temp = vbr_getstuff(state,dbytes,state-&gt;alt_curve_high_diff);
-					}
-				}
-				else {
-					if (dbytes &lt;= state-&gt;alt_curve_low)
-						curve_temp = dbytes;
-					else
-					{
-						curve_temp = vbr_getstuff(state,dbytes,state-&gt;alt_curve_low_diff);
-					}
-				}
-
-				curve_temp = curve_temp * state-&gt;curve_comp_scale + state-&gt;curve_bias_bonus;
-
-				bytes2 += ((int)curve_temp);
-				state-&gt;curve_comp_error += curve_temp - ((int)curve_temp);
-
-			}
-			else {
-				state-&gt;curve_comp_error += dbytes - ((int)dbytes);
-				bytes2 += ((int)dbytes);
-			}
-		}
-		else if ((state-&gt;curve_compression_high + state-&gt;curve_compression_low) &amp;&amp;
-			!state-&gt;pass1_intra) {
-
-			if (dbytes &gt; state-&gt;average_frame) {
-				curve_temp = state-&gt;curve_comp_scale *
-					((double)dbytes + (state-&gt;average_frame - dbytes) *
-					state-&gt;curve_compression_high / 100.0);
-			}
-			else {
-				curve_temp = state-&gt;curve_comp_scale *
-					((double)dbytes + (state-&gt;average_frame - dbytes) *
-					state-&gt;curve_compression_low / 100.0);
-			}
-
-			bytes2 += ((int)curve_temp);
-			state-&gt;curve_comp_error += curve_temp - ((int)curve_temp);
-		}
-		else {
-			state-&gt;curve_comp_error += dbytes - ((int)dbytes);
-			bytes2 += ((int)dbytes);
-		}
-
-		/* cap bytes2 to first pass size, lowers number of quant=1 frames */
-		if (bytes2 &gt; bytes1) {
-			state-&gt;curve_comp_error += bytes2 - bytes1;
-			bytes2 = bytes1;
-		}
-		else if (bytes2 &lt; 1) {
-			state-&gt;curve_comp_error += --bytes2;
-			bytes2 = 1;
-		}
-	}
-
-	state-&gt;desired_bytes2 = bytes2;
-
-	/* Ugly dependance between getquant and getintra */
-	intra = state-&gt;getintra(state);
-
-	if(intra) {
-
-		KFdistance = state-&gt;keyframe_locations[state-&gt;KF_idx] -
-			state-&gt;keyframe_locations[state-&gt;KF_idx - 1];
-
-		if (KFdistance &lt; state-&gt;kftreshold) {
-			KFdistance = KFdistance - state-&gt;min_key_interval;
-
-			if (KFdistance &gt;= 0) {
-
-				KF_min_size = bytes2 * (100 - state-&gt;kfreduction) / 100;
-				if (KF_min_size &lt; 1)
-					KF_min_size = 1;
-
-				bytes2 = KF_min_size + (bytes2 - KF_min_size) * KFdistance /
-					(state-&gt;kftreshold - state-&gt;min_key_interval);
-
-				if (bytes2 &lt; 1)
-					bytes2 = 1;
-			}
-		}
-	}
-
-	/*
-	 * Foxer: scale overflow in relation to average size, so smaller frames don't get
-	 * too much/little bitrate
-	 */
-	overflow = (int)((double)overflow * bytes2 / state-&gt;average_frame);
-
-	/* Foxer: reign in overflow with huge frames */
-	if (labs(overflow) &gt; labs(state-&gt;overflow)) {
-		overflow = state-&gt;overflow;
-	}
-
-	/* Foxer: make sure overflow doesn't run away */
-	if(overflow &gt; bytes2 * state-&gt;twopass_max_overflow_improvement / 100) {
-		bytes2 += (overflow &lt;= bytes2) ? bytes2 * state-&gt;twopass_max_overflow_improvement / 100 :
-			overflow * state-&gt;twopass_max_overflow_improvement / 100;
-	}
-	else if(overflow &lt; bytes2 * state-&gt;twopass_max_overflow_degradation / -100) {
-		bytes2 += bytes2 * state-&gt;twopass_max_overflow_degradation / -100;
-	}
-	else {
-		bytes2 += overflow;
-	}
-
-	if(bytes2 &gt; state-&gt;max_framesize) {
-		capped_to_max_framesize = 1;
-		bytes2 = state-&gt;max_framesize;
-	}
-
-	if(bytes2 &lt; 1) {
-		bytes2 = 1;
-	}
-
-	state-&gt;bytes1 = bytes1;
-	state-&gt;bytes2 = bytes2;
-
-	/*printf(&quot;Pass 1 : %d \n&quot;,bytes1);
-	printf(&quot;Pass 2 : %d \n&quot;,bytes2);
-	printf(&quot;Quant1 : %d \n&quot;,state-&gt;pass1_quant);
-*/
-	/* very 'simple' quant&lt;-&gt;filesize relationship */
-	quant = state-&gt;pass1_quant * bytes1 / bytes2;
-//	printf(&quot;Quant2 : %d \n&quot;,quant);
-	if(quant &lt; 1)
-		quant = 1;
-	else if(quant &gt; 31)
-		quant = 31;
-	else if(!state-&gt;pass1_intra) {
-
-		/* Foxer: aid desired quantizer precision by accumulating decision error */
-		state-&gt;quant_error[quant] += ((double)(state-&gt;pass1_quant * bytes1) / bytes2) - quant;
-
-		if (state-&gt;quant_error[quant] &gt;= 1.0) {
-			state-&gt;quant_error[quant] -= 1.0;
-			quant++;
-		}
-	}
-
-	/* we're done with credits */
-	if(util_frametype(state) != FRAME_TYPE_NORMAL_MOVIE) {
-		return(quant);
-	}
-
-	if(intra) {
-
-		if (quant &lt; state-&gt;min_iquant)
-			quant = state-&gt;min_iquant;
-		if (quant &gt; state-&gt;max_iquant)
-			quant = state-&gt;max_iquant;
-	}
-	else {
-
-		if(quant &gt; state-&gt;max_pquant)
-			quant = state-&gt;max_pquant;
-		if(quant &lt; state-&gt;min_pquant)
-			quant = state-&gt;min_pquant;
-
-		/* subsequent frame quants can only be +- 2 */
-		if(state-&gt;last_quant &amp;&amp; capped_to_max_framesize == 0) {
-			if (quant &gt; state-&gt;last_quant + 2)
-				quant = state-&gt;last_quant + 2;
-			if (quant &lt; state-&gt;last_quant - 2)
-				quant = state-&gt;last_quant - 2;
-		}
-	}
-
-	
-
-	// we make a rough estimation of the size this frame will be...
-	
-
-	if(state-&gt;maxAllowedBitrate &amp;&amp; state-&gt;cur_frame+state-&gt;roundup&lt;state-&gt;nb_frames)
-	{
-	//*******************************************************************************	
-	// meanX
-	//*******************************************************************************
-	tryme=20;
-	ok=0;
-	
-	//quant+=state-&gt;qinc;	
-	orgquant=quant;
-_requant:
-	while(tryme &amp;&amp; !ok)
-	{
-		int frame;
-		
-		projected_vbv=state-&gt;vbv_fullness;
- 		for( i=0;i&lt;state-&gt;roundup&gt;&gt;1;i++)
-		{
-			frame=vbr_predict(state,state-&gt;size[state-&gt;cur_frame+i]*2,quant);
-			frame*=8;
-			projected_vbv-=frame;
-			if(projected_vbv&lt;0)
-			{
-				aprintf(&quot;underflow at %d + %d\n&quot;,state-&gt;cur_frame,i);
-				quant++;
-				if(quant&gt;31)
-				{
-					 quant=31;
-					 tryme=1;
-				}
-				tryme--;
-				goto _requant;
-			}
-			projected_vbv+=state-&gt;bits_per_image;
-			if(projected_vbv&gt;state-&gt;vbv_buffer_size)
-			{
-				projected_vbv=state-&gt;vbv_buffer_size;
-			}
-		}
-		ok=1;
-	}
-	if(!ok)
-	{
-		printf(&quot;Could not compensate underflow!\n&quot;);
-	}
-	aprintf(&quot;Predicted size : %d\n&quot;,vbr_predict(state,state-&gt;size[state-&gt;cur_frame]*2,quant));
-	aprintf(&quot;Orgquant:%d finalQuant:%d\n&quot;,orgquant,quant);
-	if(quant-orgquant&gt;2) state-&gt;qinc+=1+(quant-orgquant)&gt;&gt;1;
-	if(state-&gt;qinc) state-&gt;qinc--;	
-	if(quant&gt;31) quant=31;
-	}
-	
-	// MEANX
-	return(quant);
-
-}
-
-static int vbr_getintra_2pass2(void *sstate)
-{
-
-	int intra=0;
-	vbr_control_t *state = sstate;
-
-
-	/* Get next intra state (fetched by update) */
-	intra = state-&gt;pass1_intra;
-	//printf(&quot;1st pass: %d \n&quot;,intra);
-	/* During credits, XviD will decide itself */
-	if(util_frametype(state) != FRAME_TYPE_NORMAL_MOVIE) {
-
-
-		switch(state-&gt;credits_mode) {
-		default:
-		case VBR_CREDITS_MODE_RATE :
-		case VBR_CREDITS_MODE_SIZE :
-			intra = -1;
-			break;
-		case VBR_CREDITS_MODE_QUANT :
-			/* Except in this case */
-			if (state-&gt;credits_quant_i == state-&gt;credits_quant_p)
-				intra = -1;
-			break;
-		}
-
-	}
-
-	/* Force I Frame when max_key_interval is reached */
-	if((state-&gt;cur_frame - state-&gt;last_keyframe) &gt; state-&gt;max_key_interval)
-	{
-	//	printf(&quot;Too far away -&gt; intra cur : %d last : %d\n&quot;, 
-	//		state-&gt;cur_frame,state-&gt;last_keyframe);		
-		intra = 1;
-	}
-
-	/*
-	 * Force P or B Frames for frames whose distance is less than the
-	 * requested minimum
-	 */
-	if((state-&gt;cur_frame - state-&gt;last_keyframe) &lt; state-&gt;min_key_interval)
-	{
-		intra = 0;
-	}
-	//printf(&quot;cur : %d / last %d intra  : %d min: %d max: %d\n&quot;,state-&gt;cur_frame,state-&gt;last_keyframe,intra,
-	//		 state-&gt;min_key_interval, state-&gt;max_key_interval			);
-
-	/* Return the given intra mode except for first frame */
-	return((state-&gt;cur_frame==0)?1:intra);
-
-}
-
-static int vbr_update_2pass2(void *sstate,
-			     int quant,
-			     int intra,
-			     int header_bytes,
-			     int total_bytes,
-			     int kblocks,
-			     int mblocks,
-			     int ublocks)
-
-
-{
-
-
-//	int next_hbytes, next_kblocks, next_mblocks, next_ublocks;
-	int tempdiv;
-	int target;
-	vbr_control_t *state = sstate;
-
-	header_bytes=total_bytes+kblocks+mblocks+ublocks; // MEAN: Remove warning
-	/*
-	 * We do not depend on getintra/quant because we have the real results
-	 * from the xvid core
-	 */
-
-	if (util_frametype(state) == FRAME_TYPE_NORMAL_MOVIE) {
-
-		state-&gt;quant_count[quant]++;
-
-		if (state-&gt;pass1_intra) {
-
-			state-&gt;overflow += state-&gt;KFoverflow;
-			state-&gt;KFoverflow = state-&gt;desired_bytes2 - total_bytes;
-
-			tempdiv = (state-&gt;keyframe_locations[state-&gt;KF_idx] -
-				   state-&gt;keyframe_locations[state-&gt;KF_idx - 1]);
-
-			/* redistribute correctly (by koepi) */
-			if (tempdiv &gt; 1) {
-				/* non-consecutive keyframes */
-				state-&gt;KFoverflow_partial = state-&gt;KFoverflow /
-					(tempdiv - 1);
-			}
-			else {
-				state-&gt;overflow  += state-&gt;KFoverflow;
-				state-&gt;KFoverflow = 0;
-				state-&gt;KFoverflow_partial = 0;
-			}
-			state-&gt;KF_idx++;
-
-		}
-		else {
-			state-&gt;overflow += state-&gt;desired_bytes2 - total_bytes +
-				state-&gt;KFoverflow_partial;
-			state-&gt;KFoverflow -= state-&gt;KFoverflow_partial;
-		}
-	}
-	else {
-
-		state-&gt;overflow += state-&gt;desired_bytes2 - total_bytes;
-		state-&gt;overflow += state-&gt;KFoverflow;
-		state-&gt;KFoverflow = 0;
-		state-&gt;KFoverflow_partial = 0;
-	}
-
-	/* Save old quant */
-	state-&gt;last_quant = quant;
-	/* Save the last Keyframe pos */
-	if(intra)
-		state-&gt;last_keyframe = state-&gt;cur_frame;
-
-		target=state-&gt;cur_frame%state-&gt;roundup;
-		
-
-		if(ublocks!=state-&gt;type[state-&gt;cur_frame])
-		{
-				//aprintf(&quot;\n************************* GOP CHANGE******************\n&quot;);
-		}
-
-/* Ok next frame */
-
-		state-&gt;cur_frame++;
-		state-&gt;pass1_bytes=state-&gt;size[state-&gt;cur_frame];;
-		state-&gt;pass1_intra=state-&gt;kf[state-&gt;cur_frame];
-		state-&gt;pass1_quant=2;
-/* Update vbv */
-	if(state-&gt;maxAllowedBitrate &amp;&amp; state-&gt;cur_frame&lt;state-&gt;nb_frames-state-&gt;roundup)
-	{
-		int rank,old;
-		float comp;
-			state-&gt;vbv_fullness-=total_bytes*8;
-			state-&gt;vbv_fullness+=state-&gt;bits_per_image;
-			if(state-&gt;vbv_fullness&gt;state-&gt;vbv_buffer_size)
-			{
-				state-&gt;vbv_fullness=state-&gt;vbv_buffer_size;
-			}
-			if(state-&gt;vbv_fullness&lt;0)
-			{
-				printf(&quot;** Buffer undeflow: %d at frame :%d **\n&quot;,state-&gt;vbv_fullness,state-&gt;cur_frame);
-				state-&gt;vbv_fullness=0;
-			}
-			// Update compressility
-			old=state-&gt;cur_frame-1;
-			rank=old%AVG_LOOKUP;
-			state-&gt;compr[rank]=vbr_get_comp(state-&gt;size[old],2,total_bytes,quant);
-			aprintf(&quot;&gt;&gt;Size : %d\n&quot;,total_bytes);
-			aprintf(&quot;Buffer fullness:%d\n&quot;,100*state-&gt;vbv_fullness/state-&gt;vbv_buffer_size);
-	}		
-
-	return(0);
-
-}
-
-static int vbr_finish_2pass2(void *sstate)
-{
-
-	vbr_control_t *state = sstate;
-
-	if(state-&gt;pass1_file == NULL)
-		return(-1);
-
-	/* Close the file */
-	if(fclose(state-&gt;pass1_file) != 0)
-		return(-1);
-
-	/* Free the memory */
-	if(state-&gt;keyframe_locations)
-		ADM_dealloc(state-&gt;keyframe_locations);
-
-	{ // meanX
-		if(state-&gt;size)
-			{
-				ADM_dealloc(state-&gt;size);
-				state-&gt;size=NULL;
-			}
-		if(state-&gt;kf)
-			{
-				ADM_dealloc(state-&gt;kf);
-				state-&gt;kf=NULL;
-			}
-		if(state-&gt;type)
-			{
-				ADM_dealloc(state-&gt;type);
-				state-&gt;type=NULL;
-			}
-
-
-	}
-
-	return(0);
-
-}
-
-
-/******************************************************************************
- * Fixed quant mode - Most of the functions will be dummy functions
- *****************************************************************************/
-
-static int vbr_init_fixedquant(void *sstate)
-{
-
-	vbr_control_t *state = sstate;
-
-	if(state-&gt;fixed_quant &lt; 1)
-		state-&gt;fixed_quant = 1;
-
-	if(state-&gt;fixed_quant &gt; 31)
-		state-&gt;fixed_quant = 31;
-
-	state-&gt;cur_frame = 0;
-
-	return(0);
-
-}
-
-static int vbr_getquant_fixedquant(void *sstate)
-{
-
-	vbr_control_t *state = sstate;
-
-	/* Credits' frame ? */
-	if(util_frametype(state) != FRAME_TYPE_NORMAL_MOVIE) {
-
-		int quant;
-
-		switch(state-&gt;credits_mode) {
-		case VBR_CREDITS_MODE_RATE:
-			quant = state-&gt;fixed_quant * state-&gt;credits_quant_ratio;
-			break;
-		case VBR_CREDITS_MODE_QUANT:
-			quant = state-&gt;credits_fixed_quant;
-			break;
-		default:
-			quant = state-&gt;fixed_quant;
-
-		}
-
-		return(quant);
-
-	}
-		
-	/* No credit frame - return fixed quant */
-	return(state-&gt;fixed_quant);
-
-}
-/*__________________________________________________________________
-
-	Reverse the below formula
-	newbits/oldbuts=newquang^ -comp
-	log(newq^ -comp)=log(newbit/oldbits)
-	comp=-log(newbits/oldbits)/log(newq/oldq)
-*/
-float vbr_get_comp(int oldbits, int qporg, int newbits, int qpused)
-{
-	float comp;
-	
-	comp=newbits;
-	comp/=oldbits;
-	comp=log(comp);
-	comp/=log(qpused/qporg);
-	aprintf(&quot;Old q:%d new q : %d oldBits:%d newbits:%d comp:%f\n&quot;,
-			qporg,qpused,oldbits,newbits,-comp);
-	return -comp;
-}
-/*_______________________________________________________________
-	Predict the size of the image
-	Using a exp(-comp) formula instead of linear formula
-	
-	Idea by Peter Cheat
-__________________________________________________________________
-*/
-int vbr_predict(vbr_control_t *state,int original_size,int qp)
-{
- // Peter Cheat formula :Pridicted Bits Frame 10 Will Use = (Bits Used At Quantiser 1) * (New Quantiser ^ -Compressibility)
- // avg lookup compressibility
- 	int start;
-	int pred,i;
-	float comp=0;
-		
-	start=state-&gt;cur_frame;
-	start+=state-&gt;roundup;
-	start-=AVG_LOOKUP;
-	start%=state-&gt;roundup;
-	
-	for(i=0;i&lt;AVG_LOOKUP;i++)
-	{
-		comp+=state-&gt;compr[start];
-		start++;
-		start%=AVG_LOOKUP;
-	}
-	comp=comp/AVG_LOOKUP;
-	
-	pred=original_size;
-	pred=pred*pow(qp/2,-comp);
-	aprintf(&quot;Avg comp: %f initial size : %d predicted size:%d\n&quot;,comp,original_size,pred);
-	return pred;
-
-}
-/*
-	Return if next frame is intra
-*/
-int vbr_next_intra( void *sstate)
-{
-
-	vbr_control_t *state = sstate;
-
-	if(state-&gt;cur_frame&gt;state-&gt;nb_frames -2) return 0;
-	return state-&gt;kf[state-&gt;cur_frame+1];
-
-}
-static int vbr_getintra_fixedquant(void *state)
-{
-	if(state)
-	{
-	}
-	return(-1);
-
-}
-int vbr_getstuff(vbr_control_t *state, int dbytes,double diff)
-{
-	int total2=0;
-	switch(state-&gt;alt_curve_type)
-						{
-						case VBR_ALT_CURVE_AGGRESIVE:
-							total2 +=
-								dbytes *
-								(state-&gt;alt_curve_mid_qual - state-&gt;alt_curve_qual_dev *
-								 sin(DEG2RAD * ((dbytes - state-&gt;average_frame) * 90.0 / diff)));
-							break;
-						default:
-						case VBR_ALT_CURVE_LINEAR:
-							total2 +=
-								dbytes *
-								(state-&gt;alt_curve_mid_qual - state-&gt;alt_curve_qual_dev *
-								 (dbytes - state-&gt;average_frame) / diff);
-							break;
-						case VBR_ALT_CURVE_SOFT:
-							total2 +=
-								dbytes *
-								(state-&gt;alt_curve_mid_qual + state-&gt;alt_curve_qual_dev *
-								 (1.0 - cos(DEG2RAD * ((dbytes - state-&gt;average_frame) * 90.0 / diff))));
-						}
-	return total2;
-}
-/*---------------------------------------------------------------------------------------------------------------------
-	
-	For each quantizer given we clip size until it does not reach maxiumu
-	bitrate, that way we got an good average size value to decide
-	which quantizer is good depending on the max bitrate
-	
------------------------------------------------------------------------------------------------------------------------
-*/
-int  vbr_make_variance(vbr_control_t *state, float compression, int *variance, int *bitrate)
-{
-		
-		float *cur_mod=NULL;
-		float *final_mod=NULL;
-		int roundup;
-		int nb_maxxed;
-		
-		int i,tmp;
-		double ibitrate, instant;
-		int try;
-		double d_average,d_variance,v;
-		long long int in_sum, out_sum;
-		
-		float compr_out;
-					
-		roundup=state-&gt;roundup;	
-		cur_mod=ADM_alloc(sizeof(float)*state-&gt;nb_frames);
-		final_mod=ADM_alloc(sizeof(float)*state-&gt;nb_frames);
-		
-		
-		for(i=0;i&lt;state-&gt;nb_frames;i++)
-		{						
-			final_mod[i]=2/compression;			
-		}
-		
-		// Calculate bitrate
-		for(try=0;try&lt;5;try++)
-		{		
-		ibitrate=0;
-		nb_maxxed=0;
-		
-		// Reset
-		for(tmp=0;tmp&lt;state-&gt;nb_frames;tmp++)
-		{
-			cur_mod[tmp]=1.;			
-		}
-		
-		for(i=roundup;i&lt;(state-&gt;nb_frames-roundup);i++)
-		{
-			instant=state-&gt;size[i-(roundup&gt;&gt;1)];
-			instant*=final_mod[i-(roundup&gt;&gt;1)];
-			ibitrate-=instant;
-			
-			instant=state-&gt;size[i+(roundup&gt;&gt;1)];
-			instant*=final_mod[i+(roundup&gt;&gt;1)];
-			ibitrate+=instant;
-			
-			if(ibitrate&lt;10.) ibitrate=10.;			
-			//printf(&quot;Iteration %0d Bitrate at %d : %03.0f&quot;,try,i,(ibitrate*8)/1000);			
-			if(ibitrate&gt; state-&gt;maxAllowedBitrate)
-			{
-				nb_maxxed++;				
-			//	printf(&quot; Maxx!&quot;);
-				for(tmp=-(roundup&gt;&gt;1);tmp&lt;(roundup&gt;&gt;1);tmp++)
-				{
-					cur_mod[i+tmp]=0.8;
-				}
-			}
-			//printf(&quot;\n&quot;);
-		}
-		for(i=roundup;i&lt;(state-&gt;nb_frames-roundup);i++)
-		{
-			final_mod[i]*=cur_mod[i];
-		}
-		} // end try
-		/*for(i=roundup;i&lt;(state-&gt;nb_frames-roundup);i++)
-		{
-			tmp=(int)floor(final_mod[i]*compression*100.);	
-			printf(&quot;Final mod  %d %d %%\n&quot;,
-					i,tmp);
-			
-		}*/
-		d_average=0;
-		d_variance=0;
-		in_sum=0;
-		out_sum=0;
-		//___________________________
-		// compute average  &amp;&amp; variance
-		//___________________________
-		for(i=0;i&lt;state-&gt;nb_frames;i++)
-		{
-			in_sum+=state-&gt;size[i];
-			out_sum+=(state-&gt;size[i]*final_mod[i]);			
-		}		
-		d_average=out_sum;
-		d_average/=state-&gt;nb_frames;
-		//printf(&quot;Average bitrate out : %f\n&quot;,(d_average*state-&gt;fps*8)/1000);
-		*bitrate=floor(d_average*state-&gt;fps*8);
-//		printf(&quot;Average bitrate out : %d\n&quot;,*bitrate);
-		
-		for(i=0;i&lt;(state-&gt;nb_frames);i++)
-		{
-			v=state-&gt;size[i]*final_mod[i]-d_average;
-			d_variance+=abs(v);	
-		}		
-		d_variance/=state-&gt;nb_frames;			
-		*variance=floor(d_variance);
-				
-		//printf(&quot;in : %lld		\n&quot;,in_sum);
-		//printf(&quot;out : %lld		\n&quot;,out_sum);
-		compr_out=in_sum;
-		compr_out/=out_sum;
-		
-		//printf(&quot;Compression in /out : %f /  %f\n&quot;,compression, compr_out);
-		//printf(&quot;Variance : %f\n&quot;,d_variance);
-		ADM_dealloc(cur_mod);		
-		ADM_dealloc(final_mod);		
-		return 0;
-}	
-/*
-	Same as above except this time we alter the size to reflect the
-	max bitrate (on the original size)
-
-*/	
-int  vbr_make_clipping(vbr_control_t *state, float compression)
-{
-		
-		float *cur_mod=NULL;
-		float *final_mod=NULL;
-		int roundup;
-		int nb_maxxed;
-		
-		int i,tmp;
-		double ibitrate, instant;
-		int try;
-		int before,after;
-					
-		roundup=state-&gt;roundup;	
-		cur_mod=ADM_alloc(sizeof(float)*state-&gt;nb_frames);
-		final_mod=ADM_alloc(sizeof(float)*state-&gt;nb_frames);
-		
-		
-		for(i=0;i&lt;state-&gt;nb_frames;i++)
-		{			
-			
-			final_mod[i]=2./compression;			
-		}
-		
-		// Calculate bitrate
-		for(try=0;try&lt;5;try++)
-		{		
-		ibitrate=0;
-		nb_maxxed=0;
-		
-		// Reset
-		for(tmp=0;tmp&lt;state-&gt;nb_frames;tmp++)
-		{
-			cur_mod[tmp]=1.;			
-		}
-		
-		for(i=roundup;i&lt;(state-&gt;nb_frames-roundup);i++)
-		{
-			instant=state-&gt;size[i-(roundup&gt;&gt;1)];
-			instant*=final_mod[i-(roundup&gt;&gt;1)];
-			ibitrate-=instant;
-			
-			instant=state-&gt;size[i+(roundup&gt;&gt;1)];
-			instant*=final_mod[i+(roundup&gt;&gt;1)];
-			ibitrate+=instant;
-			
-			if(ibitrate&lt;10.) ibitrate=10.;			
-			//printf(&quot;Iteration %0d Bitrate at %d : %03.0f&quot;,try,i,(ibitrate*8)/1000);			
-			if(ibitrate&gt; state-&gt;maxAllowedBitrate)
-			{
-				nb_maxxed++;				
-			//	printf(&quot; Maxx!&quot;);
-				for(tmp=-(roundup&gt;&gt;1);tmp&lt;(roundup&gt;&gt;1);tmp++)
-				{
-					cur_mod[i+tmp]=0.8;
-				}
-			}
-			//printf(&quot;\n&quot;);
-		}
-		for(i=roundup;i&lt;(state-&gt;nb_frames-roundup);i++)
-		{
-			final_mod[i]*=cur_mod[i];
-		}
-		} // end try
-		for(i=roundup;i&lt;(state-&gt;nb_frames-roundup);i++)
-		{
-			before=state-&gt;size[i];
-			state-&gt;size[i]=state-&gt;size[i]*final_mod[i]*compression/2;
-			after=state-&gt;size[i];
-			//printf(&quot;%d --&gt; %d (%f)\n&quot;,before,after,final_mod[i]*50);
-		}
-		ADM_dealloc(cur_mod);		
-		ADM_dealloc(final_mod);	
-		//exit(0);	
-		return 0;		
-}		

Deleted: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_encoder/xvid_vbr.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_encoder/xvid_vbr.h	2009-07-03 08:55:54 UTC (rev 4990)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_encoder/xvid_vbr.h	2009-07-03 10:11:38 UTC (rev 4991)
@@ -1,250 +0,0 @@
-/******************************************************************************
- *
- *   XviD VBR Library
- *   
- *   Copyright (C) 2002 Edouard Gomez &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">ed.gomez at wanadoo.fr</A>&gt;
- *
- *   The curve treatment algorithm is based on work done by Foxer &lt;email?&gt; and
- *   Dirk Knop &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">dknop at gwdg.de</A>&gt; for the XviD vfw dynamic library.
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- *****************************************************************************/
-
-#ifndef __XVID_VBR_H__
-#define __XVID_VBR_H__
-
-#define VBR_VERSION 0
-#define AVG_LOOKUP 5
-/******************************************************************************
- * Function types used in the vbr controler
- *****************************************************************************/
-
-typedef int (vbr_init_function) (void *state);
-typedef vbr_init_function *vbr_init_function_ptr;
-
-typedef int (vbr_get_quant_function) (void *state);
-typedef vbr_get_quant_function *vbr_get_quant_function_ptr;
-
-typedef int (vbr_get_intra_function) (void *state);
-typedef vbr_get_intra_function *vbr_get_intra_function_ptr;
-
-typedef int (vbr_update_function) (void *state,
-				   int quant,
-				   int intra,
-				   int header_bytes,
-				   int total_bytes,
-				   int kblocks, int mblocks, int ublocks);
-typedef vbr_update_function *vbr_update_function_ptr;
-
-typedef int (vbr_finish_function) (void *state);
-typedef vbr_finish_function *vbr_finish_function_ptr;
-
-/******************************************************************************
- * The VBR CONTROLER structure - the spin of the library
- *****************************************************************************/
-
-typedef struct _vbr_control_t
-{
-
-  /* All modes - specifies what VBR algorithm has to be used */
-  int mode;
-
-  /* All modes - specifies what fps the movie uses */
-  float fps;
-
-  /* All modes */
-  int debug;
-
-  /*
-   * For VBR_MODE_2PASS_1/2 - specifies from/to what file the vbr
-   * controller has to write/read stats
-   */
-  char *filename;
-
-  /* For VBR_MODE_2PASS_2 - Target size */
-  int desired_bitrate;
-
-  /* For VBR_MODE_2PASS_2 - Credits parameters */
-  int credits_mode;
-  int credits_start;
-  int credits_start_begin;
-  int credits_start_end;
-  int credits_end;
-  int credits_end_begin;
-  int credits_end_end;
-  int credits_quant_ratio;
-  int credits_fixed_quant;
-  int credits_quant_i;
-  int credits_quant_p;
-  int credits_start_size;
-  int credits_end_size;
-
-  /* For VBR_MODE_2PASS_2 - keyframe parameters */
-  int keyframe_boost;
-  int kftreshold;
-  int kfreduction;
-  int min_key_interval;
-  int max_key_interval;
-
-  /* For VBR_MODE_2PASS_2 - Normal curve */
-  int curve_compression_high;
-  int curve_compression_low;
-
-  /* For VBR_MODE_2PASS_2 - Alternate curve parameters */
-  int use_alt_curve;
-  int alt_curve_type;
-  int alt_curve_low_dist;
-  int alt_curve_high_dist;
-  int alt_curve_min_rel_qual;
-  int alt_curve_use_auto;
-  int alt_curve_auto_str;
-  int alt_curve_use_auto_bonus_bias;
-  int alt_curve_bonus_bias;
-  int bitrate_payback_method;
-  int bitrate_payback_delay;
-  int max_iquant;
-  int min_iquant;
-  int max_pquant;
-  int min_pquant;
-  int twopass_max_bitrate;
-  int twopass_max_overflow_improvement;
-  int twopass_max_overflow_degradation;
-
-  /*
-   * For VBR_MODE_FIXED_QUANT - the quantizer that has to be used for all
-   * frames
-   */
-  int fixed_quant;
-
-  /* ----------- Internal data - Do not modify ----------- */
-  void *debug_file;
-  void *pass1_file;
-
-  long long desired_size;
-
-  int cur_frame;
-  int nb_frames;
-  int nb_keyframes;
-
-  int *keyframe_locations;
-  int last_keyframe;
-
-  double credits_start_curve;
-  double credits_end_curve;
-  double movie_curve;
-  double average_frame;
-  double alt_curve_low;
-  double alt_curve_low_diff;
-  double alt_curve_high;
-  double alt_curve_high_diff;
-  double alt_curve_mid_qual;
-  double alt_curve_qual_dev;
-  double curve_bias_bonus;
-  double curve_comp_scale;
-  double curve_comp_error;
-
-  int pass1_quant;
-  int pass1_intra;
-  int pass1_bytes;
-
-  int bytes1;
-  int bytes2;
-  int desired_bytes2;
-  int max_framesize;
-  int last_quant;
-  int quant_count[32];
-  double quant_error[32];
-
-  int overflow;
-  int KFoverflow;
-  int KFoverflow_partial;
-  int KF_idx;
-
-  int debug_quant_count[32];
-
-  /* ----------- Internal data - do not modify ----------- */
-  vbr_init_function_ptr init;
-  vbr_get_quant_function_ptr getquant;
-  vbr_get_intra_function_ptr getintra;
-  vbr_update_function_ptr update;
-  vbr_finish_function_ptr finish;
-
-	/*------------ Meanx Bitrate clipping ---------------------*/
-  int roundup;			// round-up of fps : 24/25/30
-  int maxAllowedBitrate;	// max allowed bitrate in byte / sec
-  //int b_per_sec[60];                            //
-  int *size;			// we will store size of frames here
-  int *kf;
-  int *type;			// I=1 P =2 B=3
-  int qinc;
-  //int underflow_warning;                        // Means we get under thresh underflow
-  //int  thresh_underflow;                        // Level in byte to underflow (~ 700 kbytes/s for SVCD)
-  //int allow_quant_skew;                 // allow diff between I / P / B quant mods
-  //int avg_br;                                   // average bitrate
-  int vbv_buffer_size;		// &lt;- MUST BE FILLED BY USER
-  int vbv_fullness;		//
-  int bits_per_image;		//
-  float compr[AVG_LOOKUP];
-} vbr_control_t;
-#define THRESH_UNDERFLOW ((700*1000)&gt;&gt;3)	// in BYTES ! around 600 kbits
-//#define BOOST_KF  1 // allow KF boots for mpeg1/2
-/******************************************************************************
- * Constants
- *****************************************************************************/
-/* Bitrate limiter */
-#define LIMITER_ANTICIPATING 	2
-#define LIMITER_LOW_WARNING	2
-#define LIMITER_WARNING		3
-#define LIMITER_MAX_INC		3
-
-/* Constants for the mode member */
-#define VBR_MODE_1PASS       0x01
-#define VBR_MODE_2PASS_1     0x02
-#define VBR_MODE_2PASS_2     0x04
-#define VBR_MODE_FIXED_QUANT 0x08
-
-/* Constants for the credits mode */
-#define VBR_CREDITS_MODE_RATE  0x01
-#define VBR_CREDITS_MODE_QUANT 0x02
-#define VBR_CREDITS_MODE_SIZE  0x04
-
-/* Alternate curve treatment types */
-#define VBR_ALT_CURVE_SOFT      0x01
-#define VBR_ALT_CURVE_LINEAR    0x02
-#define VBR_ALT_CURVE_AGGRESIVE 0x04
-
-/* Payback modes */
-#define VBR_PAYBACK_BIAS            0x01
-#define VBR_PAYBACK_PROPORTIONAL    0x02
-
-/******************************************************************************
- * VBR API
- *****************************************************************************/
-
-extern int vbrSetDefaults (vbr_control_t * state);
-extern int vbrInit (vbr_control_t * state);
-extern int vbrGetQuant (vbr_control_t * state);
-extern int vbrGetIntra (vbr_control_t * state);
-extern int vbrUpdate (vbr_control_t * state,
-		      int quant,
-		      int intra,
-		      int header_bytes,
-		      int total_bytes, int kblocks, int mblocks, int ublocks);
-extern int vbrFinish (vbr_control_t * state);
-/*	Meanx
-*/
-int vbr_next_intra (void *sstate);
-#endif

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_libraries/ADM_utilities/prefs.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_libraries/ADM_utilities/prefs.cpp	2009-07-03 08:55:54 UTC (rev 4990)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_libraries/ADM_utilities/prefs.cpp	2009-07-03 10:11:38 UTC (rev 4991)
@@ -76,10 +76,6 @@
 	{&quot;codecs.dvd.matrix&quot;,		UINT,	&quot;0&quot;,	NULL,	&quot;0&quot;,	&quot;99999&quot;},
 	{&quot;codecs.dvd.gopsize&quot;,		UINT,	&quot;12&quot;,	NULL,	&quot;0&quot;,	&quot;99999&quot;},
 	{&quot;codecs.dvd.maxbitrate&quot;,		UINT,	&quot;9000&quot;,	NULL,	&quot;0&quot;,	&quot;9900&quot;	},
-	{&quot;codecs.xvid.enctype&quot;,		UINT,	&quot;0&quot;,	NULL,	&quot;0&quot;,	&quot;99999&quot;},
-	{&quot;codecs.xvid.quantizer&quot;,		UINT,	&quot;4&quot;,	NULL,	&quot;2&quot;,	&quot;32&quot;	},
-	{&quot;codecs.xvid.bitrate&quot;,		UINT,	&quot;1500000&quot;,NULL,	&quot;17&quot;,	&quot;5900000&quot;},
-	{&quot;codecs.xvid.finalsize&quot;,	UINT,	&quot;700&quot;,	NULL,	&quot;0&quot;,	&quot;3999&quot;	},
 	{&quot;codecs.preferredcodec&quot;,		STRING,&quot;FFmpeg4&quot;,NULL, NULL, NULL },
 #ifdef __WIN32
 	{&quot;filters.subtitle.fontname&quot;,		FILENAME,&quot;C:\\Windows\\Fonts\\arial.ttf&quot;,NULL, NULL, NULL },
@@ -109,13 +105,6 @@
 	{&quot;lastfiles.file4&quot;,		FILENAME,&quot;&quot;,	NULL, NULL, NULL },
 	{&quot;lastdir_read&quot;,		FILENAME,&quot;&quot;,	NULL, NULL, NULL },
 	{&quot;lastdir_write&quot;,		FILENAME,&quot;&quot;,	NULL, NULL, NULL },
-	{&quot;lame_cli&quot;,		STRING,&quot;&quot;,	NULL, NULL, NULL },
-	{&quot;pipe_cmd&quot;,		STRING,&quot;&quot;,	NULL, NULL, NULL },
-	{&quot;pipe_param&quot;,		STRING,&quot;&quot;,	NULL, NULL, NULL },
-	{&quot;lame_path&quot;,		STRING,&quot;&quot;,	NULL, NULL, NULL },
-	{&quot;toolame_path&quot;,		STRING,&quot;&quot;,	NULL, NULL, NULL },
-	{&quot;lvemux_path&quot;,		STRING,&quot;&quot;,	NULL, NULL, NULL },
-	{&quot;requant_path&quot;,		STRING,&quot;&quot;,	NULL, NULL, NULL },
 	{&quot;message_level&quot;,		UINT,	&quot;2&quot;,	NULL,	&quot;0&quot;,	&quot;2&quot;	},
 	{&quot;feature.swap_if_A_greater_than_B&quot;,		UINT,	&quot;1&quot;,	NULL,	&quot;0&quot;,	&quot;1&quot;	},
 	{&quot;feature.svcdres.preferedsourceratio&quot;,		STRING,&quot;1:1&quot;,	NULL, NULL, NULL },
@@ -144,7 +133,7 @@
 	{&quot;priority.playback&quot;,		UINT,	&quot;0&quot;,	NULL,	&quot;0&quot;,	&quot;4&quot;	}
 };
 
-int num_opts = 78;
+int num_opts = 67;
 // &lt;/prefs_gen&gt;
 
 #ifdef USE_LIBXML2

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/CMakeLists.txt	2009-07-03 08:55:54 UTC (rev 4990)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/CMakeLists.txt	2009-07-03 10:11:38 UTC (rev 4991)
@@ -23,8 +23,6 @@
  TLK_filesel.cpp
 )
 SET(OBSOLETE_SRCS
- DIA_exLame.cpp
- DIA_pipe.cpp
  DIA_threshold.cpp
  DIA_SwissArmyKnife.cpp
  DIA_particle.cpp

Deleted: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_exLame.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_exLame.cpp	2009-07-03 08:55:54 UTC (rev 4990)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_exLame.cpp	2009-07-03 10:11:38 UTC (rev 4991)
@@ -1,107 +0,0 @@
-
-#include &quot;ADM_toolkitGtk.h&quot;
-#include &quot;prefs.h&quot;
-static GtkWidget	*create_dialog1 (void);
-
-uint8_t DIA_lame(char **lame)
-{
-	GtkWidget *dialog;
-
-	char *str;
-	uint8_t ret=0;
-
-	gint r;
-
-#define FILL_ENTRY(widget_name,value) {		 \
-gtk_editable_delete_text(GTK_EDITABLE(lookup_widget(dialog,#widget_name)), 0,-1);\
-gtk_editable_insert_text(GTK_EDITABLE(lookup_widget(dialog,#widget_name)), str, strlen(str), &amp;r);}
-
-	dialog=create_dialog1();
-	gtk_transient(dialog);
-	*lame=NULL;
-
-	if(!prefs-&gt;get(LAME_CLI,&amp;str)) str=NULL;
-	if(str)
-	{
-		FILL_ENTRY(entry1,left);
-	}
-	ret=0;
-	if(gtk_dialog_run(GTK_DIALOG(dialog))==GTK_RESPONSE_OK)
-	{
-
-#define READ_ENTRY(widget_name)   gtk_editable_get_chars(GTK_EDITABLE (lookup_widget(dialog,#widget_name)), 0, -1);
-
-			str=READ_ENTRY(entry1);
-			if(strlen(str))
-			{
-				*lame=ADM_strdup(str);;
-				prefs-&gt;set(LAME_CLI,str);
-			}
-			ret=1;
-	}
-
-	gtk_widget_destroy(dialog);
-
-	return ret;
-
-}
-
-
-GtkWidget*
-create_dialog1 (void)
-{
-  GtkWidget *dialog1;
-  GtkWidget *dialog_vbox1;
-  GtkWidget *vbox1;
-  GtkWidget *label1;
-  GtkWidget *entry1;
-  GtkWidget *dialog_action_area1;
-  GtkWidget *cancelbutton1;
-  GtkWidget *okbutton1;
-
-  dialog1 = gtk_dialog_new ();
-  gtk_window_set_title (GTK_WINDOW (dialog1), QT_TR_NOOP(&quot;Lame command&quot;));
-
-  dialog_vbox1 = GTK_DIALOG (dialog1)-&gt;vbox;
-  gtk_widget_show (dialog_vbox1);
-
-  vbox1 = gtk_vbox_new (FALSE, 0);
-  gtk_widget_show (vbox1);
-  gtk_box_pack_start (GTK_BOX (dialog_vbox1), vbox1, TRUE, TRUE, 0);
-
-  label1 = gtk_label_new (QT_TR_NOOP(&quot;Enter parameters (i.e. -b 192 -m s ...)&quot;));
-  gtk_widget_show (label1);
-  gtk_box_pack_start (GTK_BOX (vbox1), label1, FALSE, FALSE, 0);
-  gtk_label_set_justify (GTK_LABEL (label1), GTK_JUSTIFY_LEFT);
-
-  entry1 = gtk_entry_new ();
-  gtk_widget_show (entry1);
-  gtk_box_pack_start (GTK_BOX (vbox1), entry1, FALSE, FALSE, 0);
-
-  dialog_action_area1 = GTK_DIALOG (dialog1)-&gt;action_area;
-  gtk_widget_show (dialog_action_area1);
-  gtk_button_box_set_layout (GTK_BUTTON_BOX (dialog_action_area1), GTK_BUTTONBOX_END);
-
-  cancelbutton1 = gtk_button_new_from_stock (&quot;gtk-cancel&quot;);
-  gtk_widget_show (cancelbutton1);
-  gtk_dialog_add_action_widget (GTK_DIALOG (dialog1), cancelbutton1, GTK_RESPONSE_CANCEL);
-  GTK_WIDGET_SET_FLAGS (cancelbutton1, GTK_CAN_DEFAULT);
-
-  okbutton1 = gtk_button_new_from_stock (&quot;gtk-ok&quot;);
-  gtk_widget_show (okbutton1);
-  gtk_dialog_add_action_widget (GTK_DIALOG (dialog1), okbutton1, GTK_RESPONSE_OK);
-  GTK_WIDGET_SET_FLAGS (okbutton1, GTK_CAN_DEFAULT);
-
-  /* Store pointers to all widgets, for use by lookup_widget(). */
-  GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog1, &quot;dialog1&quot;);
-  GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog_vbox1, &quot;dialog_vbox1&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, vbox1, &quot;vbox1&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, label1, &quot;label1&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, entry1, &quot;entry1&quot;);
-  GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog_action_area1, &quot;dialog_action_area1&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, cancelbutton1, &quot;cancelbutton1&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, okbutton1, &quot;okbutton1&quot;);
-
-  return dialog1;
-}
-

Deleted: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_pipe.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_pipe.cpp	2009-07-03 08:55:54 UTC (rev 4990)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_pipe.cpp	2009-07-03 10:11:38 UTC (rev 4991)
@@ -1,133 +0,0 @@
-#include &quot;ADM_toolkitGtk.h&quot;
-#include &quot;prefs.h&quot;
-
-static GtkWidget	*create_dialog1 (void);
-
-uint8_t DIA_pipe(char **cmd,char **param)
-{
-	GtkWidget *dialog;
-
-	char *str;
-	uint8_t ret=0;
-
-	gint r;
-
-#define FILL_ENTRY(widget_name,value) {		 \
-gtk_editable_delete_text(GTK_EDITABLE(lookup_widget(dialog,#widget_name)), 0,-1);\
-gtk_editable_insert_text(GTK_EDITABLE(lookup_widget(dialog,#widget_name)), str, strlen(str), &amp;r);}
-
-	dialog=create_dialog1();
-	gtk_transient(dialog);
-	*cmd=NULL;
-	*param=NULL;
-
-	if(!prefs-&gt;get(PIPE_CMD,&amp;str)) str=NULL;
-	if(str)
-	{
-		FILL_ENTRY(entryName,left);
-	}
-	if(!prefs-&gt;get(PIPE_PARAM,&amp;str)) str=NULL;
-	if(str)
-	{
-		FILL_ENTRY(entryParam,left);
-	}
-
-	ret=0;
-	if(gtk_dialog_run(GTK_DIALOG(dialog))==GTK_RESPONSE_OK)
-	{
-
-		// gchar *s;
-		// uint32_t val1;
-#define READ_ENTRY(widget_name)   gtk_editable_get_chars(GTK_EDITABLE (lookup_widget(dialog,#widget_name)), 0, -1);
-
-			str=READ_ENTRY(entryName);
-			if(strlen(str))
-			{
-				*cmd=ADM_strdup(str);;
-				prefs-&gt;set(PIPE_CMD,str);
-			}
-			str=READ_ENTRY(entryName);
-			if(strlen(str))
-			{
-				*param=ADM_strdup(str);;
-				prefs-&gt;set(PIPE_PARAM,str);
-			}
-			ret=1;
-	}
-
-	gtk_widget_destroy(dialog);
-
-	return ret;
-
-}
-GtkWidget*
-create_dialog1 (void)
-{
-  GtkWidget *dialog1;
-  GtkWidget *dialog_vbox1;
-  GtkWidget *vbox1;
-  GtkWidget *label1;
-  GtkWidget *entryName;
-  GtkWidget *label2;
-  GtkWidget *entryParam;
-  GtkWidget *dialog_action_area1;
-  GtkWidget *cancelbutton1;
-  GtkWidget *okbutton1;
-
-  dialog1 = gtk_dialog_new ();
-  gtk_window_set_title (GTK_WINDOW (dialog1), QT_TR_NOOP(&quot;Pipe to&quot;));
-
-  dialog_vbox1 = GTK_DIALOG (dialog1)-&gt;vbox;
-  gtk_widget_show (dialog_vbox1);
-
-  vbox1 = gtk_vbox_new (FALSE, 0);
-  gtk_widget_show (vbox1);
-  gtk_box_pack_start (GTK_BOX (dialog_vbox1), vbox1, TRUE, TRUE, 0);
-
-  label1 = gtk_label_new (QT_TR_NOOP(&quot;Application path/name (/usr/bin/sox...)&quot;));
-  gtk_widget_show (label1);
-  gtk_box_pack_start (GTK_BOX (vbox1), label1, FALSE, FALSE, 0);
-  gtk_label_set_justify (GTK_LABEL (label1), GTK_JUSTIFY_LEFT);
-
-  entryName = gtk_entry_new ();
-  gtk_widget_show (entryName);
-  gtk_box_pack_start (GTK_BOX (vbox1), entryName, FALSE, FALSE, 0);
-
-  label2 = gtk_label_new (QT_TR_NOOP(&quot;Full parameter line&quot;));
-  gtk_widget_show (label2);
-  gtk_box_pack_start (GTK_BOX (vbox1), label2, FALSE, FALSE, 0);
-  gtk_label_set_justify (GTK_LABEL (label2), GTK_JUSTIFY_LEFT);
-
-  entryParam = gtk_entry_new ();
-  gtk_widget_show (entryParam);
-  gtk_box_pack_start (GTK_BOX (vbox1), entryParam, FALSE, FALSE, 0);
-
-  dialog_action_area1 = GTK_DIALOG (dialog1)-&gt;action_area;
-  gtk_widget_show (dialog_action_area1);
-  gtk_button_box_set_layout (GTK_BUTTON_BOX (dialog_action_area1), GTK_BUTTONBOX_END);
-
-  cancelbutton1 = gtk_button_new_from_stock (&quot;gtk-cancel&quot;);
-  gtk_widget_show (cancelbutton1);
-  gtk_dialog_add_action_widget (GTK_DIALOG (dialog1), cancelbutton1, GTK_RESPONSE_CANCEL);
-  GTK_WIDGET_SET_FLAGS (cancelbutton1, GTK_CAN_DEFAULT);
-
-  okbutton1 = gtk_button_new_from_stock (&quot;gtk-ok&quot;);
-  gtk_widget_show (okbutton1);
-  gtk_dialog_add_action_widget (GTK_DIALOG (dialog1), okbutton1, GTK_RESPONSE_OK);
-  GTK_WIDGET_SET_FLAGS (okbutton1, GTK_CAN_DEFAULT);
-
-  /* Store pointers to all widgets, for use by lookup_widget(). */
-  GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog1, &quot;dialog1&quot;);
-  GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog_vbox1, &quot;dialog_vbox1&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, vbox1, &quot;vbox1&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, label1, &quot;label1&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, entryName, &quot;entryName&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, label2, &quot;label2&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, entryParam, &quot;entryParam&quot;);
-  GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog_action_area1, &quot;dialog_action_area1&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, cancelbutton1, &quot;cancelbutton1&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, okbutton1, &quot;okbutton1&quot;);
-
-  return dialog1;
-}
-

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_NONE/ADM_dialog/DIA_none.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_NONE/ADM_dialog/DIA_none.cpp	2009-07-03 08:55:54 UTC (rev 4990)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_NONE/ADM_dialog/DIA_none.cpp	2009-07-03 10:11:38 UTC (rev 4991)
@@ -66,7 +66,6 @@
 uint8_t DIA_vobsub(vobSubParam *param) {return 0;}
 uint8_t DIA_XVCDParam(char *title,COMPRESSION_MODE * mode, uint32_t * qz,
 		   				   uint32_t * br,uint32_t *fsize,FFcodecSetting *conf) {return 0;}
-uint8_t DIA_xvid4(COMPRES_PARAMS *incoming) {return 0;}
 uint8_t DIA_quota(char *) {return 0;}
 const char * GUI_getCustomScript(uint32_t nb) {return 0;}
 uint8_t DIA_RecentFiles( char **name ) {return 0;}

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/prefs.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/prefs.h	2009-07-03 08:55:54 UTC (rev 4990)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/prefs.h	2009-07-03 10:11:38 UTC (rev 4991)
@@ -28,10 +28,6 @@
 	CODECS_DVD_MATRIX,
 	CODECS_DVD_GOPSIZE,
 	CODECS_DVD_MAXBITRATE,
-	CODECS_XVID_ENCTYPE,
-	CODECS_XVID_QUANTIZER,
-	CODECS_XVID_BITRATE,
-	CODECS_XVID_FINALSIZE,
 	CODECS_PREFERREDCODEC,
 	FILTERS_SUBTITLE_FONTNAME,
 	FILTERS_SUBTITLE_CHARSET,
@@ -53,13 +49,6 @@
 	LASTFILES_FILE4,
 	LASTDIR_READ,
 	LASTDIR_WRITE,
-	LAME_CLI,
-	PIPE_CMD,
-	PIPE_PARAM,
-	LAME_PATH,
-	TOOLAME_PATH,
-	LVEMUX_PATH,
-	REQUANT_PATH,
 	MESSAGE_LEVEL,
 	FEATURE_SWAP_IF_A_GREATER_THAN_B,
 	FEATURE_SVCDRES_PREFEREDSOURCERATIO,

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/prefs.in
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/prefs.in	2009-07-03 08:55:54 UTC (rev 4990)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/prefs.in	2009-07-03 10:11:38 UTC (rev 4991)
@@ -31,10 +31,6 @@
 codecs.dvd.matrix,			UINT,	0,	0,	99999
 codecs.dvd.gopsize,			UINT,	12,	0,	99999
 codecs.dvd.maxbitrate,			UINT,	9000,	0,	9900
-codecs.xvid.enctype,			UINT,	0,	0,	99999
-codecs.xvid.quantizer,			UINT,	4,	2,	32
-codecs.xvid.bitrate,			UINT,	1500000,17,	5900000
-codecs.xvid.finalsize,			UINT,	700,	0,	3999
 codecs.preferredcodec,			STRING,	FFmpeg4
 #ifdef __WIN32
 filters.subtitle.fontname,		FILENAME, &quot;C:\\Windows\\Fonts\\arial.ttf&quot;
@@ -67,14 +63,6 @@
 lastfiles.file4,			FILENAME,	&quot;&quot;
 lastdir_read,				FILENAME,	&quot;&quot;
 lastdir_write,				FILENAME,	&quot;&quot;
-# lame
-lame_cli,				STRING, &quot;&quot;
-pipe_cmd,				STRING, &quot;&quot;
-pipe_param,				STRING, &quot;&quot;
-lame_path,				STRING, &quot;&quot;
-toolame_path,				STRING, &quot;&quot;
-lvemux_path,				STRING, &quot;&quot;
-requant_path,				STRING, &quot;&quot;
 # 0 - no messages, 1 - only error messages, 2 - all messages
 message_level,				UINT,	2,	0,	2
 # feature


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="002205.html">[Avidemux-svn-commit] r4990 - in	branches/avidemux_2.5_branch_gruntster/avidemux: ADM_codecs	ADM_encoder
</A></li>
	<LI>Next message: <A HREF="002207.html">[Avidemux-svn-commit] r4992 - in	branches/avidemux_2.5_branch_gruntster/platforms/windows:	build_scripts/avidemux installer
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2206">[ date ]</a>
              <a href="thread.html#2206">[ thread ]</a>
              <a href="subject.html#2206">[ subject ]</a>
              <a href="author.html#2206">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">More information about the Avidemux-svn-commit
mailing list</a><br>
</body></html>
