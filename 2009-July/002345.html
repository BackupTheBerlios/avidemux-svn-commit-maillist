<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Avidemux-svn-commit] r5130 -	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerAvi
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/avidemux-svn-commit/2009-July/index.html" >
   <LINK REL="made" HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r5130%20-%0A%09branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerAvi&In-Reply-To=%3C200907231818.n6NIIhYS009264%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="002344.html">
   <LINK REL="Next"  HREF="002346.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Avidemux-svn-commit] r5130 -	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerAvi</H1>
    <B>mean at BerliOS</B> 
    <A HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r5130%20-%0A%09branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerAvi&In-Reply-To=%3C200907231818.n6NIIhYS009264%40sheep.berlios.de%3E"
       TITLE="[Avidemux-svn-commit] r5130 -	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerAvi">mean at mail.berlios.de
       </A><BR>
    <I>Thu Jul 23 20:18:43 CEST 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="002344.html">[Avidemux-svn-commit] r5129 -	branches/avidemux_2.6_branch_mean/avidemux/common/ADM_commonUI
</A></li>
        <LI>Next message: <A HREF="002346.html">[Avidemux-svn-commit] r5131 -	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/oplug_ogm
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2345">[ date ]</a>
              <a href="thread.html#2345">[ thread ]</a>
              <a href="subject.html#2345">[ subject ]</a>
              <a href="author.html#2345">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: mean
Date: 2009-07-23 20:18:42 +0200 (Thu, 23 Jul 2009)
New Revision: 5130

Removed:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerAvi/op_avisave.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerAvi/op_avisave.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerAvi/op_avisavecopy.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerAvi/op_avisavecopy_pack.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerAvi/op_avisavecopy_unpack.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerAvi/op_avisavedual.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerAvi/op_savecopy.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerAvi/op_saveprocess.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerAvi/op_saveprocess.h
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerAvi/op_savesmart.cpp
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerAvi/op_savesmart.hxx
Modified:
   branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerAvi/CMakeLists.txt
Log:
[avi/muxer] cleanup

Modified: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerAvi/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerAvi/CMakeLists.txt	2009-07-23 18:18:41 UTC (rev 5129)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerAvi/CMakeLists.txt	2009-07-23 18:18:42 UTC (rev 5130)
@@ -6,8 +6,6 @@
         op_aviwrite.cpp
         avilist.cpp
 
-#	avilist.cpp  op_avisavecopy_pack.cpp   op_avisave.cpp   op_aviwrite.cpp   op_savesmart.cpp
-#	op_avisavecopy.cpp  op_avisavecopy_unpack.cpp  op_avisavedual.cpp  op_saveprocess.cpp
 )
 INCLUDE_DIRECTORIES(&quot;${AVIDEMUX_SOURCE_DIR}/avidemux/ADM_coreDemuxer/include&quot;)
 

Deleted: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerAvi/op_avisave.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerAvi/op_avisave.cpp	2009-07-23 18:18:41 UTC (rev 5129)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerAvi/op_avisave.cpp	2009-07-23 18:18:42 UTC (rev 5130)
@@ -1,457 +0,0 @@
-/***************************************************************************
-                          op_avisave.cpp  -  description
-                             -------------------
-    begin                : Fri May 3 2002
-    copyright            : (C) 2002 by mean
-    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
- 
- /*
-* MODIFIED BY GMV 30.1.05: prepared for ODML
-*/
- 
-
-
-#include &quot;ADM_default.h&quot;
-#include &quot;ADM_threads.h&quot;
-
-#include &quot;fourcc.h&quot;
-
-#include &quot;DIA_coreToolkit.h&quot;
-
-//#include &quot;avilist.h&quot;
-
-#include &quot;ADM_videoFilter.h&quot;
-
-#include &quot;ADM_videoFilter.h&quot;
-
-
-
-
-#include &quot;op_aviwrite.hxx&quot;
-#include &quot;op_avisave.h&quot;
-#include &quot;GUI_mux.h&quot;
-#include &lt;math.h&gt;
-uint32_t muxSize=4090;
-extern PARAM_MUX muxMode;
-extern int muxParam;
-
-
-
-#include &quot;audioeng_buildfilters.h&quot;
-#include &quot;ADM_coreUI/include/DIA_factory.h&quot;
-const char *getStrFromAudioCodec( uint32_t codec);
-//_________________________
-uint8_t ADM_aviUISetMuxer(  void )
-{
-  
-//	return DIA_setUserMuxParam ((int *) &amp;muxMode, (int *) &amp;muxParam, (int *) &amp;muxSize);
-  uint32_t mux_n_frame=muxParam;
-  uint32_t mux_size_block=muxParam;
-  uint32_t mux_mode=(uint32_t)muxMode;
-  
-  
-  diaMenuEntry muxingType[]={
-  {MUX_REGULAR,QT_TR_NOOP(&quot;Normal&quot;)},
-  {MUX_N_FRAMES,QT_TR_NOOP(&quot;Mux every N video frames&quot;)},
-  {MUX_N_BYTES,QT_TR_NOOP(&quot;Mux by packet size&quot;)}
-  };
-  
-    diaElemMenu      mux(&amp;(mux_mode),QT_TR_NOOP(&quot;Muxing _type:&quot;),3,muxingType);
-    diaElemUInteger blockSize(&amp;(muxSize),QT_TR_NOOP(&quot;_Split every MB:&quot;),1,9000);
-    
-    diaElemUInteger n_frames(&amp;(mux_n_frame),QT_TR_NOOP(&quot;Mux _every x video frames:&quot;),1,100);
-    diaElemUInteger n_block(&amp;(mux_size_block),QT_TR_NOOP(&quot;Mux in _blocks of x bytes:&quot;),1,50000);
-    
-    
-     mux.link(&amp;(muxingType[1]),1,&amp;n_frames);
-     mux.link(&amp;(muxingType[2]),1,&amp;n_block);
-    
-     diaElem *elems[4]={&amp;mux,&amp;n_frames,&amp;n_block,&amp;blockSize};
-     if( diaFactoryRun(QT_TR_NOOP(&quot;AVI Muxer Options&quot;),4,elems))
-    {
-      muxMode=(PARAM_MUX)mux_mode;
-      switch(muxMode)
-      {
-        case MUX_REGULAR: muxParam=1;break;
-        case MUX_N_FRAMES: muxParam=mux_n_frame;break;
-        case MUX_N_BYTES: muxParam=mux_size_block;break;
-        default: ADM_assert(0);
-      }
-      return 1;
-    }
-    return 0;
-};
-
-
-//_______ set the autosplit size
-uint8_t ADM_aviSetSplitSize(uint32_t size)
-{
-	muxSize=size;
-	return 1;
-}
-
-GenericAviSave::GenericAviSave ()
-{
-
-  has_audio_track = has_audio_vbr = 0;
- vbuffer = new uint8_t[MAXIMUM_SIZE * MAXIMUM_SIZE * 3];
-//  vbuffer=new ADMImage(MAXIMUM_SIZE,MAXIMUM_SIZE);
-  abuffer = new uint8_t[96000];
-
-  ADM_assert (vbuffer);
-  ADM_assert (abuffer);
-
-  audio_filter=NULL;
-  audio_filter2=NULL;
-  _part=0;
-  dialog_work=NULL;
-  _lastIPFrameSent=0xffffff;
-  _incoming=NULL;
-  encoding_gui=NULL;
-  _videoProcess=0;
-  _audioCurrent=_audioTarget=0;
- _audioTotal=0;  
- _file=NULL;
- _pq=NULL;
- memset(&amp;_context,0,sizeof(_context));
- _context.audioDone=1;
-}
-
-GenericAviSave::~GenericAviSave ()
-{
-  cleanupAudio();
-  delete[] vbuffer;
-  delete[] abuffer;
-  _incoming=NULL;
-  ADM_assert(!_file);
-}
-uint8_t GenericAviSave::cleanupAudio (void)
-{
-  printf(&quot;[AVI] Cleaning audio\n&quot;);
-  if(_pq)
-  {
-    _pq-&gt;Abort();
-    while(!_context.audioDone)
-    {
-      printf(&quot;Waiting Audio thread\n&quot;);
-      ADM_usleep(500000); 
-    }
-    if(_pq) delete _pq;
-    _pq=NULL;
-  }
-  if(audio_filter)
-  {
-//    deleteAudioFilter (audio_filter);
-    audio_filter=NULL;
-  }
-  return 1;
-}
-//___________________________________________________________
-//      Generic Save Avi loop
-//
-//___________________________________________________________
-//
-uint8_t  GenericAviSave::saveAvi (const char *name)
-{
-uint32_t size;
-uint8_t ret=0;
-  strcpy(_name,name);
-  //frametogo = frameEnd - frameStart + 1;
-  frametogo=0;
-  
-  writter = new aviWrite ();
-    // 1- setup audio
-  guiStart();
-  if (!setupAudio ())
-    {
-      guiStop();
-      GUI_Error_HIG (QT_TR_NOOP(&quot;Error initalizing audio filters&quot;), NULL);
-      delete writter;
-      writter = NULL;
-      return 0;
-    }
-   
-   if (!setupVideo (_name))
-    {
-      guiStop();
-      GUI_Error_HIG (QT_TR_NOOP(&quot;Error initalizing video filters&quot;), NULL);
-      delete   	writter;
-      writter = NULL;
-     // guiStop();
-      return 0;
-    }
-  
-  // 3- setup video
-  frametogo=_incoming-&gt;getInfo()-&gt;nb_frames;
-  fps1000=_incoming-&gt;getInfo()-&gt;fps1000;
-  printf (&quot;\n writing %lu frames\n&quot;, frametogo);
-
-  //__________________________________
-  //   now go to main loop.....
-  //__________________________________
-  for (uint32_t cf = 0; cf &lt; frametogo; cf++) 
-    {
-			
-			
-			
-      			if (guiUpdate (cf, frametogo))
-					goto abortme;
-      			//   printf(&quot;\n %lu / %lu&quot;,cf,frametogo);
-      			writeVideoChunk (cf);
-      			writeAudioChunk (cf);
-			//writter-&gt;sync();
-     
-     
-    };				// end for
-    ret=1;
-abortme:
-  guiStop ();
-  //__________________________________
-  // and end save
-  //__________________________________
-  writter-&gt;setEnd ();
-  delete       writter;
-  writter = NULL;
-  // resync GUI
-  printf (&quot;\n Saving AVI (v_engine)... done\n&quot;);
-  return ret;
-}
-
-//_________________________________________________________________
-//
-//                                                              Set up audio system
-//_________________________________________________________________
-uint8_t
-GenericAviSave::setupAudio (void)
-{
-// 1- Prepare audio filter
-//__________________________
-
-  _audioInBuffer = 0;
-  _audioTarget=_audioCurrent=0;
-  _audioTotal=0;
-  audio_filter=NULL;
-   if(!currentaudiostream) 
-   {
-   	encoding_gui-&gt;setAudioCodec(QT_TR_NOOP(&quot;None&quot;));
-	return 1;
-   }
-  printf (&quot; mux mode : %d mux param %d\n&quot;, muxMode, muxParam);
-
-  if (audioProcessMode())	// else Raw copy mode
-    {
-//      audio_filter = buildAudioFilter (currentaudiostream,video_body-&gt;getTime (frameStart));
-      if(!audio_filter) return 0;
-      encoding_gui-&gt;setAudioCodec(getStrFromAudioCodec(audio_filter-&gt;getInfo()-&gt;encoding));
-    }
-  else // copymode
-    {
-      // else prepare the incoming raw stream
-      // audio copy mode here
-      encoding_gui-&gt;setAudioCodec(QT_TR_NOOP(&quot;Copy&quot;));
-//      audio_filter=buildAudioFilter( currentaudiostream,video_body-&gt;getTime (frameStart));
-      if(!audio_filter) return 0;
-    }
-    /* Setup audioQ */
-    pthread_t     audioThread;
-    _pq=new PacketQueue(&quot;AVI audioQ&quot;,5000,2*1024*1024);
-    memset(&amp;_context,0,sizeof(_context));
-   // _context.audioEncoder=audio_filter;
-    _context.audioTargetSample=0xFFFF0000; ; //FIXME
-    _context.packetQueue=_pq;
-    // start audio thread
-    ADM_assert(!pthread_create(&amp;audioThread,NULL,(THRINP)defaultAudioQueueSlave,&amp;_context)); 
-    ADM_usleep(4000);
-  return 1;
-}
-//---------------------------------------------------------------------------
-uint8_t
-GenericAviSave::writeAudioChunk (uint32_t frame)
-{
-  uint32_t    len;
-  // if there is no audio, we do nothing
-  if (!audio_filter)
-    return 1;
-    
-  double t;
-  
-  t=frame+1;
-  t=t/fps1000;
-  t=t*1000*audio_filter-&gt;getInfo()-&gt;frequency;
-  _audioTarget=(uint32_t )floor(t);
-
-        uint32_t sample,packetLen,packets=0;
-
-
-       
-        sample=0;
-        // _audioTarget is the # of sample we want
-        while(_audioCurrent&lt;_audioTarget)
-        {
-                if(!_pq-&gt;Pop(abuffer+_audioInBuffer,&amp;packetLen,&amp;sample))
-                  {
-                    printf(&quot;AVIWR:Could not read packet\n&quot;);
-                    break;
-                  }
-                _audioInBuffer+=packetLen;
-                _audioTotal+=packetLen;
-                _audioCurrent+=sample;		
-                packets++;
-        }
-      switch (muxMode)
-        {
-        case MUX_N_FRAMES:
-          stored_audio_frame++;
-          if (stored_audio_frame &lt; muxParam)
-            return 1;
-          stored_audio_frame = 0;
-        case MUX_REGULAR:
-          break;
-        case MUX_N_BYTES:
-                if(_audioInBuffer&lt;muxParam) return 1;
-                break;
-          break;
-        default:
-          ADM_assert (0);
-        }
-      if (_audioInBuffer)
-        {
-          writter-&gt;saveAudioFrame (_audioInBuffer, abuffer);
-          encoding_gui-&gt;setAudioSize(_audioTotal);
-          _audioInBuffer=0;
-        }
-      return 1;
-  
-}
-
-void
-GenericAviSave::guiStart (void)
-{
-      encoding_gui=new DIA_encoding(25000);
-      encoding_gui-&gt;setCodec(QT_TR_NOOP(&quot;Copy&quot;));
-      encoding_gui-&gt;setFrame (0,0,2 ,100); // FXMe
-      encoding_gui-&gt;setContainer(QT_TR_NOOP(&quot;AVI&quot;));
-
-}
-
-void
-GenericAviSave::guiStop (void)
-{
-      ADM_assert(encoding_gui);
-      delete encoding_gui;
-      encoding_gui=NULL;
-
-}
-void GenericAviSave::guiSetPhasis(const char *str)
-{
-      ADM_assert(encoding_gui);
-      encoding_gui-&gt;setPhasis(str);
-	
-}
-uint8_t
-GenericAviSave::guiUpdate (uint32_t nb, uint32_t total)
-{
-  ADM_assert(encoding_gui);
-  //encoding_gui-&gt;setFrame (nb, 0,0, total); //FXMe
-  if ( encoding_gui-&gt;isAlive () == 1)
-    return 0;
-  return 1;
-
-
-}
-//	Return 1 if we exceed the chunk limit
-//
-uint8_t  GenericAviSave::handleMuxSize ( void )
-{
-  uint32_t pos;
-  
-        pos=writter-&gt;getPos();
-        if(pos&gt;=muxSize*1024*1024)
-                {
-                          return 1  ;
-                        
-                }
-                return 0;
-  
-      
-}
-//
-//	Finish the current avi and start a new one
-//
-uint8_t   GenericAviSave::reigniteChunk( uint32_t dataLen, uint8_t *data )
-{
-	// MOD Feb 2005 by GMV: ODML exit
-	if(writter-&gt;doODML!=aviWrite::NO)return 1;	// exit if odml has to be used
-	// END MOD Feb 2005 by GMV
-	
-	    // first end up the current chunk
-	     	writter-&gt;setEnd ();
-  			delete       writter;
-  			writter = NULL;
-     	// then create a new one
-         writter = new aviWrite ();
-    
-				_part++;
-				char n[500];
-				
-				sprintf(n,&quot;%s%02d&quot;,_name,_part);
-								         
-      	 printf(&quot;\n *** writing a new avi part :%s\n&quot;,n);
-          
-	        if (!writter-&gt;saveBegin (n,
-			   &amp;_mainaviheader,
-			   frameEnd - frameStart + 1, 
-			   &amp;_videostreamheader,
-			   &amp;_bih,
-			   data,dataLen,
-			   audio_filter,
-			   audio_filter2))
-    {
-      GUI_Error_HIG (QT_TR_NOOP(&quot;Cannot initiate save&quot;), NULL);
-
-      return 0;
-    }
-    return 1;
-}
-
-/**
-	Search Forward Reference frame from the current B frame
-*/
-uint32_t GenericAviSave::searchForward(uint32_t startframe)
-{
-uint32_t fw=startframe;
-uint32_t flags;
-uint8_t r;
-
-        while(1)
-        {
-                fw++;
-                r=video_body-&gt;getFlags (fw, &amp;flags);
-                if(!(flags &amp; AVI_B_FRAME))
-                {
-                        return fw;
-
-                }
-                ADM_assert(r);
-                if(!r)
-                {
-                        printf(&quot;\n Could not locate last non B frame \n&quot;);
-                        return 0;
-                }
-
-        }
-}
-
-//---------------------------------------
-
-// EOF

Deleted: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerAvi/op_avisave.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerAvi/op_avisave.h	2009-07-23 18:18:41 UTC (rev 5129)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerAvi/op_avisave.h	2009-07-23 18:18:42 UTC (rev 5130)
@@ -1,86 +0,0 @@
-/***************************************************************************
-                          op_avisave.h  -  description
-                             -------------------
-    begin                : Fri May 3 2002
-    copyright            : (C) 2002 by mean
-    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
- #ifndef __AVI_SAVE__
- #define   __AVI_SAVE__
-
-#include &quot;ADM_default.h&quot;
-
-
-#include &quot;ADM_image.h&quot;
-#include &quot;ADM_fileio.h&quot;
-#include &quot;ADM_toolkit/ADM_audioQueue.h&quot;
-
- class GenericAviSave
- {
-     protected :
-                ADMFile                 *_file;
-                
-     		uint32_t		_audioTarget;
-		uint32_t		_audioCurrent;
-		uint64_t		_audioTotal;
-		
-     		DIA_encoding		    *encoding_gui;
-      	 	AVDMGenericVideoStream  *_incoming;
-     		DIA_working		*dialog_work;
-     		uint8_t 		has_audio_track;
-           	uint8_t			stored_audio_frame;
-           	uint8_t 		has_audio_vbr;
-                	uint32_t  	fps1000;
-                uint32_t 		frametogo;
-                char			_name[500];
-		uint32_t		_videoProcess;
-                uint8_t			_part;
-                ADM_audioStream	*audio_filter;
-                ADM_audioStream	*audio_filter2;
-
-                uint8_t 		computeAudioCBR (void)   ;
-                aviWrite		*writter;
-                uint8_t			*vbuffer;
-                uint8_t			*abuffer;
-		uint32_t		_audioInBuffer;
-                uint32_t		_videoFlag;
-		uint32_t  	 	_lastIPFrameSent;
-                PacketQueue             *_pq;
-                audioQueueMT            _context;
-                uint8_t                 cleanupAudio();
-
-                    virtual uint8_t setupAudio( void);
-                    virtual uint8_t setupVideo( char *name )=0;
-                    virtual uint8_t writeAudioChunk(uint32_t  f);
-                    virtual uint8_t writeVideoChunk(uint32_t frame )=0;
-                    virtual void guiStart(void);
-                    virtual void guiStop(void);
-                    	    void guiSetPhasis(const char *str);
-                    virtual uint8_t guiUpdate(uint32_t nb,uint32_t total);		    
-                    uint8_t	handleMuxSize(void ) ; // auto chop
-                    uint8_t reigniteChunk( uint32_t len, uint8_t *data );
-		    uint32_t searchForward(uint32_t startframe);
-
-						//
-						AVIStreamHeader 	_videostreamheader;
-						ADM_BITMAPINFOHEADER  _bih;
-						MainAVIHeader			_mainaviheader;
-     public:
-     						GenericAviSave( void );
-			           	virtual ~GenericAviSave( void );
-           				virtual uint8_t saveAvi(const char *name );
-   };
-extern uint32_t muxSize;
-uint8_t ADM_aviSetSplitSize(uint32_t size);
-uint8_t ADM_aviUISetMuxer(  void );
-  #endif
-

Deleted: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerAvi/op_avisavecopy.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerAvi/op_avisavecopy.cpp	2009-07-23 18:18:41 UTC (rev 5129)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerAvi/op_avisavecopy.cpp	2009-07-23 18:18:42 UTC (rev 5130)
@@ -1,196 +0,0 @@
-/***************************************************************************
-                          op_avisavecopy.cpp  -  description
-                             -------------------
-
-	We bypass the use of _incoming to have easy access to furure
-	frame.
-	In fact only the getflags is necessary, other stuff will be done throught
-	incoming.
-
-    begin                : Fri May 3 2002
-    copyright            : (C) 2002 by mean
-    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#include &quot;config.h&quot;
-#include &quot;ADM_default.h&quot;
-#include &quot;ADM_threads.h&quot;
-
-#include &quot;fourcc.h&quot;
-#include &quot;avi_vars.h&quot;
-#include &quot;DIA_coreToolkit.h&quot;
-
-//#include &quot;avilist.h&quot;
-
-#include &quot;ADM_videoFilter.h&quot;
-#include &quot;ADM_videoFilter_internal.h&quot;
-
-#include &quot;ADM_encoder/ADM_vidEncode.hxx&quot;
-
-#include &quot;ADM_audio/aviaudio.hxx&quot;
-#include &quot;ADM_audiofilter/audioprocess.hxx&quot;
-#include &quot;op_aviwrite.hxx&quot;
-#include &quot;op_avisave.h&quot;
-#include &quot;op_savecopy.h&quot;
-
-#include &quot;ADM_osSupport/ADM_debugID.h&quot;
-#define MODULE_NAME MODULE_SAVE_AVI
-#include &quot;ADM_osSupport/ADM_debug.h&quot;
-
-
-/**
-      \fn  ~GenericAviSaveCopyUnpack
-      \brief destructor
-*/
-GenericAviSaveCopy::~GenericAviSaveCopy ()
-{
-      if(copy) delete copy;
-      copy=NULL; 
-}
-
-uint8_t GenericAviSaveCopy::setupVideo (char *name)
-{
-  //  Setup avi file output, all is coming from original avi
-  // since we are inc copy mode
-  memcpy(&amp;_bih,video_body-&gt;getBIH (),sizeof(_bih));
-  _bih.biSize=sizeof(_bih);  //fix old version of avidemux
-  _bih.biXPelsPerMeter=_bih.biClrUsed=_bih.biYPelsPerMeter=0;
-  //
-  memcpy(&amp;_videostreamheader,video_body-&gt;getVideoStreamHeader (),sizeof( _videostreamheader));
-  memcpy(&amp;_mainaviheader,video_body-&gt;getMainHeader (),sizeof(_mainaviheader));
-  
-
-  /* update to fix earlier bug */
-   _mainaviheader.dwWidth=_bih.biWidth;
-   _mainaviheader.dwHeight=_bih.biHeight;
-
-   uint8_t *extraData;
-   uint32_t extraLen;
-  _lastIPFrameSent=0xfffffff;
-   video_body-&gt;getExtraHeaderData(&amp;extraLen,&amp;extraData);
-
-  	if (!writter-&gt;saveBegin (name,
-			   &amp;_mainaviheader,
-			   frameEnd - frameStart + 1,
-			   &amp;_videostreamheader,
-			   &amp;_bih,
-			   extraData,extraLen,
-			   audio_filter,
-			   audio_filter2
-		))
-    	{
-          GUI_Error_HIG (QT_TR_NOOP(&quot;Cannot initiate save&quot;), NULL);
-      		return 0;
-    	}
-	if(audio_filter2)
-	{
-		printf(&quot;Second audio track present\n&quot;);
-	}
-	else
-	{
-		printf(&quot;Second audio track absent\n&quot;);
-	}
- _incoming = getFirstVideoFilter (frameStart,frameEnd-frameStart);
- encoding_gui-&gt;setFps(_incoming-&gt;getInfo()-&gt;fps1000);
- encoding_gui-&gt;setPhasis(QT_TR_NOOP(&quot;Saving&quot;));
- // Set up our copy codec ...
-  copy=new EncoderCopy(NULL);
-  if(!copy-&gt;configure(_incoming, 0))
-  {
-      printf(&quot;Copy cannot [configure] \n&quot;);
-      return 0;
-  }
-  return 1;
-}
-
-
-// copy mode
-// Basically ask a video frame and send it to writter
-// If it contains b frame and frames have been re-ordered
-// reorder them back ...
-uint8_t
-GenericAviSaveCopy::writeVideoChunk (uint32_t frame)
-{
-  
-  uint8_t    ret1;
- ADMCompressedImage img;
- ADMBitstream bitstream;
- uint8_t seq;
-      img.data=vbuffer;
-      bitstream.bufferSize=_incoming-&gt;getInfo ()-&gt;width *   _incoming-&gt;getInfo ()-&gt;height * 3;
-      bitstream.data=vbuffer;
-      
-      
-       if(!video_body-&gt;isReordered(frameStart+frame))
-      {
-          ret1 = video_body-&gt;getFrame (frameStart + frame,&amp;img,&amp;seq);// vbuffer, &amp;len,      &amp;_videoFlag);
-          _videoFlag=img.flags;
-      }
-      else
-      {
-           ret1=copy-&gt;encode(frame,&amp;bitstream);
-           img.dataLength=bitstream.len;
-           _videoFlag=img.flags=bitstream.flags;
-      }
-
-  if (!ret1)
-    return 0;
-
-    // check for split
-     // check for auto split
-      // if so, we re-write the last I frame
-      if(muxSize)
-      	{
-                        // we overshot the limit and it is a key frame
-                // start a new chunk
-                if(handleMuxSize() &amp;&amp; (_videoFlag &amp; AVI_KEY_FRAME))
-                {		
-                    uint8_t *extraData;
-                    uint32_t extraLen;
-
-                  video_body-&gt;getExtraHeaderData(&amp;extraLen,&amp;extraData);
-      
-                  if(!reigniteChunk(extraLen,extraData)) return 0;
-                }
-          }
-  
-  if(_videoFlag==AVI_KEY_FRAME)
-          newFile();
-  encoding_gui-&gt;setFrame(frame,img.dataLength,0,frametogo);
-  return writter-&gt;saveVideoFrame (img.dataLength, img.flags, img.data);
-
-
-}
-/**
-      \fn newFile
-      \brief start a new file, for example if the muxer was setup to split every 700 Meg. Call only on intra!
-
-
-*/
-uint8_t          GenericAviSaveCopy::newFile(void)
-{
-        if(muxSize)
-      	{
-                        // we overshot the limit and it is a key frame
-                // start a new chunk
-                if(handleMuxSize() )
-                {		
-                    uint8_t *extraData;
-                    uint32_t extraLen;
-
-                  video_body-&gt;getExtraHeaderData(&amp;extraLen,&amp;extraData);
-      
-                  if(!reigniteChunk(extraLen,extraData)) return 0;
-                }
-          }
-    return 1;
-}
-// EOF

Deleted: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerAvi/op_avisavecopy_pack.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerAvi/op_avisavecopy_pack.cpp	2009-07-23 18:18:41 UTC (rev 5129)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerAvi/op_avisavecopy_pack.cpp	2009-07-23 18:18:42 UTC (rev 5130)
@@ -1 +0,0 @@
-// RMED

Deleted: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerAvi/op_avisavecopy_unpack.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerAvi/op_avisavecopy_unpack.cpp	2009-07-23 18:18:41 UTC (rev 5129)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerAvi/op_avisavecopy_unpack.cpp	2009-07-23 18:18:42 UTC (rev 5130)
@@ -1,217 +0,0 @@
-/***************************************************************************
-                          op_avisavecopy.cpp  -  description
-                             -------------------
-
-	We bypass the use of _incoming to have easy access to furure
-	frame.
-	In fact only the getflags is necessary, other stuff will be done throught
-	incoming.
-
-    begin                : Fri May 3 2002
-    copyright            : (C) 2002 by mean
-    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#include &quot;config.h&quot;
-#include &quot;ADM_default.h&quot;
-#include &quot;ADM_threads.h&quot;
-
-#include &quot;fourcc.h&quot;
-#include &quot;avi_vars.h&quot;
-#include &quot;DIA_coreToolkit.h&quot;
-
-//#include &quot;avilist.h&quot;
-
-#include &quot;ADM_videoFilter.h&quot;
-#include &quot;ADM_videoFilter_internal.h&quot;
-
-#include &quot;ADM_encoder/ADM_vidEncode.hxx&quot;
-
-#include &quot;ADM_audio/aviaudio.hxx&quot;
-#include &quot;ADM_audiofilter/audioprocess.hxx&quot;
-#include &quot;op_aviwrite.hxx&quot;
-#include &quot;op_avisave.h&quot;
-#include &quot;op_savecopy.h&quot;
-
-#include &quot;ADM_osSupport/ADM_debugID.h&quot;
-#define MODULE_NAME MODULE_SAVE_AVI
-#include &quot;ADM_osSupport/ADM_debug.h&quot;
-
-
-static void updateUserData(uint8_t *start, uint32_t len);
-uint8_t ADM_findMpegStartCode(uint8_t *start, uint8_t *end,uint8_t *outstartcode,uint32_t *offset);
-
-
-
-/**
-      \fn GenericAviSaveCopyUnpack::setupVideo
-      \brief init for unpacker code
-
-*/
-uint8_t GenericAviSaveCopyUnpack::setupVideo (char *name)
-{
-  //  Setup avi file output, all is coming from original avi
-  // since we are inc copy mode
-  memcpy(&amp;_bih,video_body-&gt;getBIH (),sizeof(_bih));
-  _bih.biSize=sizeof(_bih);  //fix old version of avidemux
-  _bih.biXPelsPerMeter=_bih.biClrUsed=_bih.biYPelsPerMeter=0;
-  //
-  memcpy(&amp;_videostreamheader,video_body-&gt;getVideoStreamHeader (),sizeof( _videostreamheader));
-  memcpy(&amp;_mainaviheader,video_body-&gt;getMainHeader (),sizeof(_mainaviheader));
-  
-  // Change both to divx/DX50
-  	_videostreamheader.fccHandler=fourCC::get((uint8_t *)&quot;divx&quot;);
-	_bih.biCompression=fourCC::get((uint8_t *)&quot;DX50&quot;);
-  /* update to fix earlier bug */
-   _mainaviheader.dwWidth=_bih.biWidth;
-   _mainaviheader.dwHeight=_bih.biHeight;
-
-   uint8_t *extraData;
-   uint32_t extraLen;
-  _lastIPFrameSent=0xfffffff;
-   video_body-&gt;getExtraHeaderData(&amp;extraLen,&amp;extraData);
-
-  	if (!writter-&gt;saveBegin (name,
-			   &amp;_mainaviheader,
-			   frameEnd - frameStart + 1,
-			   &amp;_videostreamheader,
-			   &amp;_bih,
-			   extraData,extraLen,
-			   audio_filter,
-			   audio_filter2
-		))
-    	{
-          GUI_Error_HIG (QT_TR_NOOP(&quot;Cannot initiate save&quot;), NULL);
-      		return 0;
-    	}
-	if(audio_filter2)
-	{
-		printf(&quot;Second audio track present\n&quot;);
-	}
-	else
-	{
-		printf(&quot;Second audio track absent\n&quot;);
-	}
- _incoming = getFirstVideoFilter (frameStart,frameEnd-frameStart);
- encoding_gui-&gt;setFps(_incoming-&gt;getInfo()-&gt;fps1000);
- encoding_gui-&gt;setPhasis(QT_TR_NOOP(&quot;Saving&quot;));
- 
- // Set up our copy codec ...
-  copy=new EncoderCopy(NULL);
-  if(!copy-&gt;configure(_incoming, 0))
-  {
-      printf(&quot;Copy cannot [configure] \n&quot;);
-      return 0;
-  }
-  return 1;
-}
-
-
-// copy mode
-// Basically ask a video frame and send it to writter
-// If it contains b frame and frames have been re-ordered
-// reorder them back ...
-/**
-      \fn GenericAviSaveCopyUnpack::setupVideo
-      \brief init for unpacker code
-
-*/
-uint8_t GenericAviSaveCopyUnpack::writeVideoChunk (uint32_t frame)
-{
-  
-  uint8_t    ret1;
- ADMCompressedImage img;
- ADMBitstream bitstream;
- uint8_t seq;
-      img.data=vbuffer;
-      bitstream.bufferSize=_incoming-&gt;getInfo ()-&gt;width *   _incoming-&gt;getInfo ()-&gt;height * 3;
-      bitstream.data=vbuffer;
-      
-      
-       if(!video_body-&gt;isReordered(frameStart+frame))
-      {
-          ret1 = video_body-&gt;getFrame (frameStart + frame,&amp;img,&amp;seq);// vbuffer, &amp;len,      &amp;_videoFlag);
-          _videoFlag=img.flags;
-      }
-      else
-      {
-           ret1=copy-&gt;encode(frame,&amp;bitstream);
-           img.dataLength=bitstream.len;
-           _videoFlag=img.flags=bitstream.flags;
-           if(bitstream.flags==AVI_KEY_FRAME)
-           {
-            updateUserData(bitstream.data,bitstream.len); 
-           }
-      }
-
-  if (!ret1)
-    return 0;
-
-      if(_videoFlag==AVI_KEY_FRAME)
-          newFile();
-
-  
-  encoding_gui-&gt;setFrame(frame,img.dataLength,0,frametogo);
-  return writter-&gt;saveVideoFrame (img.dataLength, img.flags, img.data);
-
-}
-
-//_____________________________________________________
-// Update the user data field that is used to 
-// detect in windows world if it is packed or not
-//_____________________________________________________
-void updateUserData(uint8_t *start, uint32_t len)
-{
-      // lookup startcode
-      uint32_t sync,off,rlen;
-      uint8_t code;
-      uint8_t *end=start+len;
-      while(ADM_findMpegStartCode(start, end,&amp;code,&amp;off))
-      {
-              // update
-              start+=off;
-              rlen=end-start;
-              if(code!=0xb2 || rlen&lt;4)
-                  continue;
-      
-              printf(&quot;User data found\n&quot;);
-              // looks ok ?
-              if(!strncmp((char *)start,&quot;DivX&quot;,4))
-              {
-
-                  //
-                  start+=4;
-                  rlen-=4; // skip &quot;DivX&quot;
-                              // looks for a p while not null
-                              // if there isnt we will reach a new startcode
-                              // and it will stop
-                              while((*start!='p') &amp;&amp; rlen) 
-                              {
-                                      if(!*start)
-                                      {
-                                              rlen=0;
-                                              break;
-                                      }
-                                      rlen--;
-                                      start++;
-                              }
-                              if(!rlen) 
-                                      {
-                                              printf(&quot;Unpacketizer:packed marker not found!\n&quot;);
-                                      }
-                              else	
-                                      *start='n'; // remove 'p'
-                              return;			
-              }
-      }
-}
-
-//EOF

Deleted: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerAvi/op_avisavedual.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerAvi/op_avisavedual.cpp	2009-07-23 18:18:41 UTC (rev 5129)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerAvi/op_avisavedual.cpp	2009-07-23 18:18:42 UTC (rev 5130)
@@ -1,142 +0,0 @@
-/***************************************************************************
-                          op_avisavedual.cpp  -  description
-                             -------------------
-
-		Save avi in copy mode for audio &amp; video but with 2 tracks
-
-    begin                : Wed Sep 11 2002
-    copyright            : (C) 2002 by mean
-    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#include &lt;math.h&gt;
-#include &quot;config.h&quot;
-#include &quot;ADM_default.h&quot;
-#include &quot;ADM_threads.h&quot;
-
-#include &quot;fourcc.h&quot;
-#include &quot;avi_vars.h&quot;
-
-
-//#include &quot;avilist.h&quot;
-
-#include &quot;ADM_videoFilter.h&quot;
-#include &quot;ADM_videoFilter_internal.h&quot;
-#include &quot;ADM_encoder/ADM_vidEncode.hxx&quot;
-
-#include &quot;ADM_audio/aviaudio.hxx&quot;
-#include &quot;audioprocess.hxx&quot;
-#include &quot;op_aviwrite.hxx&quot;
-#include &quot;op_avisave.h&quot;
-#include &quot;op_savecopy.h&quot;
-
-#include &quot;audioprocess.hxx&quot;
-#include &quot;ADM_audio/audioex.h&quot;
-#include &quot;audioeng_buildfilters.h&quot;
-
-GenericAviSaveCopyDualAudio::GenericAviSaveCopyDualAudio (void	*track)
-			: GenericAviSaveCopy()
-{
-   printf(&quot;**********************************\n&quot;);
-   printf(&quot;second audio track set\n&quot;);
-//    audio_filter2= track;
-    _audioCurrent2=0;
-}
-
-//
-//      Just to keep gcc happy....
-//
-
-uint8_t GenericAviSaveCopyDualAudio::setupAudio (void)
-{
-  int32_t shift=0;
-  if(!audio_filter2) return 0;
-  if(!currentaudiostream) return 0;
-  
-  audio_filter=buildAudioFilter( currentaudiostream,video_body-&gt;getTime (frameStart));
-  audio_filter2-&gt;goToTime(0);
-  return 1;
-}
-//---------------------------------------------------------------------------
-uint8_t    GenericAviSaveCopyDualAudio::doOneTrack (uint32_t index,void *stream,uint32_t target,uint32_t *current)
-{
-  uint32_t    len;
-  uint32_t sample,packetLen,packets=0;
-  
-  _audioInBuffer=0;
-  // VBR mode, one packet per frame
-#if 0
-  if(stream-&gt;packetPerFrame()     || stream-&gt;isVBR() )
-  {
-    while(*current&lt;target)
-    {
-      if(!stream-&gt;getPacket(abuffer,&amp;packetLen,&amp;sample))
-      {
-        printf(&quot;AVIWR:Could not read packet\n&quot;);
-        return 0;
-      }
-      *current+=sample;
-      if(!index)
-        writter-&gt;saveAudioFrame (packetLen,abuffer);
-      else
-        writter-&gt;saveAudioFrameDual (packetLen,abuffer);
-//      encoding_gui-&gt;feedAudioFrame(packetLen);
-    }
-	 	
-  }
-  else // CBR mode, pack them
-  {
-    sample=0;
-    // _audioTarget is the # of sample we want
-    while(*current&lt;target)
-    {
-      if(!stream-&gt;getPacket(abuffer+_audioInBuffer,&amp;packetLen,&amp;sample))
-      {
-        printf(&quot;AVIWR:Could not read packet\n&quot;);
-        break;
-      }
-      _audioInBuffer+=packetLen;
-      *current+=sample;		
-      packets++;
-    }
-    if (_audioInBuffer)
-    {
-      if(!index)
-        writter-&gt;saveAudioFrame (_audioInBuffer, abuffer);
-      else
-        writter-&gt;saveAudioFrameDual (_audioInBuffer,abuffer);
-//      encoding_gui-&gt;feedAudioFrame(_audioInBuffer);	  
-    }
-  }
-#endif
-  return 1;
-}
-// **************************************************************
-uint8_t
-GenericAviSaveCopyDualAudio::writeAudioChunk (uint32_t frame)
-{
-  uint32_t    len;
-  // if there is no audio, we do nothing
-  if (!audio_filter)
-    return 0;
-    
-  double t;
-  
-  t=frame+1;
-  t=t/fps1000;
-  t=t*1000*audio_filter-&gt;getInfo()-&gt;frequency;
-  _audioTarget=(uint32_t )floor(t);
-  
-//  if(!doOneTrack(0,audio_filter,_audioTarget,&amp;_audioCurrent)) return 0;
-//  if(!doOneTrack(1,audio_filter2,_audioTarget,&amp;_audioCurrent2)) return 0;
-  return 1;
-}
-//____________

Deleted: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerAvi/op_savecopy.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerAvi/op_savecopy.h	2009-07-23 18:18:41 UTC (rev 5129)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerAvi/op_savecopy.h	2009-07-23 18:18:42 UTC (rev 5130)
@@ -1,82 +0,0 @@
-/***************************************************************************
-                          op_savecopy.h  -  description
-                             -------------------
-    begin                : Fri May 3 2002
-    copyright            : (C) 2002 by mean
-    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
- #ifndef __AVI_SAVECPY__
- #define   __AVI_SAVECPY__
-#include &quot;ADM_encoder/adm_encCopy.h&quot;
- class GenericAviSaveCopy : public   GenericAviSave
- {
-     protected :
-		                                EncoderCopy          *copy;	
-		          virtual uint8_t 	setupVideo( char *name  );
-                          virtual uint8_t 	writeVideoChunk(uint32_t frame );
-                                  uint8_t       newFile(void);
-
-     public:
-                                              GenericAviSaveCopy()  :     GenericAviSave()
-                                                                      {
-                                                                        copy=NULL;
-                                                                      };
-                           virtual ~GenericAviSaveCopy();
-   };
-
- class GenericAviSaveCopyDualAudio : public   GenericAviSaveCopy
- {
-     protected :
-
-                        
-                        char				*_trackname;
-                        uint32_t			_audioCurrent2;
-
-                        uint8_t    doOneTrack (uint32_t index,void *stream,uint32_t target,uint32_t *current);
-                                    virtual uint8_t setupAudio( void);
-                                  virtual uint8_t writeAudioChunk(uint32_t frame );
-
-     public:
-                                     GenericAviSaveCopyDualAudio(void	*track);
-
-   };
-/*            Pack /unpack */
-class GenericAviSaveCopyUnpack : public   GenericAviSaveCopy
- {
-     protected :
-                          virtual uint8_t 	setupVideo( char *name  );
-                          virtual uint8_t 	writeVideoChunk(uint32_t frame );
-     public:
-  
- };
-class GenericAviSaveCopyPack : public   GenericAviSaveCopy
- {
-     protected :
-                          EncoderCopy          *copy;
-                          ADMBitstream         *lookAhead[2];
-                          uint32_t              curToggle;
-                          uint32_t              time_inc;
-                          virtual uint8_t 	setupVideo( char *name  );
-                          virtual uint8_t 	writeVideoChunk(uint32_t frame );
-                                  uint8_t       prefetch(uint32_t buffer,uint32_t frame);
-     public:
-                          virtual	~GenericAviSaveCopyPack();	
-                                        GenericAviSaveCopyPack()  :     GenericAviSaveCopy()
-                                        {
-                                                lookAhead[0]=NULL;
-                                                lookAhead[1]=NULL;
-                                                curToggle=0;
-                                                time_inc=0;
-                                        };
-  
- };
-  #endif

Deleted: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerAvi/op_saveprocess.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerAvi/op_saveprocess.cpp	2009-07-23 18:18:41 UTC (rev 5129)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerAvi/op_saveprocess.cpp	2009-07-23 18:18:42 UTC (rev 5130)
@@ -1,286 +0,0 @@
-/***************************************************************************
-                          op_saveprocess.cpp  -  description
-                             -------------------
-    begin                : Fri May 3 2002
-    copyright            : (C) 2002 by mean
-    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
-
-
-
-
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#include &quot;config.h&quot;
-#include &quot;ADM_default.h&quot;
-#include &quot;ADM_threads.h&quot;
-
-
-#include &quot;fourcc.h&quot;
-#include &quot;avi_vars.h&quot;
-#include &quot;DIA_coreToolkit.h&quot;
-
-//#include &quot;avilist.h&quot;
-
-#include &quot;ADM_audio/aviaudio.hxx&quot;
-#include &quot;ADM_audiofilter/audioprocess.hxx&quot;
-
-#include &quot;ADM_videoFilter.h&quot;
-//#include &quot;ADM_gui/GUI_encoder.h&quot;
-#include &quot;ADM_videoFilter_internal.h&quot;
-#include &quot;ADM_encoder/ADM_vidEncode.hxx&quot;
-
-#include &quot;op_aviwrite.hxx&quot;
-#include &quot;op_avisave.h&quot;
-
-#include &quot;ADM_encoder/adm_encoder.h&quot;
-#include &quot;op_saveprocess.h&quot;
-
-#include &quot;ADM_osSupport/ADM_debugID.h&quot;
-#define MODULE_NAME MODULE_SAVE_AVI
-#include &quot;ADM_osSupport/ADM_debug.h&quot;
-
-GenericAviSaveProcess::GenericAviSaveProcess( void ) 
-{
-	TwoPassLogFile=NULL;
-	_incoming=NULL;
-	_encode=NULL;
-	_videoProcess=1;
-};
-
-uint8_t
-GenericAviSaveProcess::setupVideo (char *name)
-{
-	_notnull=0;
-	_incoming = getLastVideoFilter (frameStart,frameEnd-frameStart);
- 	frametogo=_incoming-&gt;getInfo()-&gt;nb_frames;
-	encoding_gui-&gt;setFps(_incoming-&gt;getInfo()-&gt;fps1000);
-	// anish
- 	if(_incoming-&gt;getInfo()-&gt;width%8)
-		{
-                  if(!GUI_Question(QT_TR_NOOP(&quot;Width is not a multiple of 8\n continue anyway ?&quot;)))
-			return 0;
-
-		}
-
-  _encode = getVideoEncoder (_incoming-&gt;getInfo()-&gt;width,_incoming-&gt;getInfo()-&gt;height);
-  if (!_encode)
-    return 0;
-
-  // init compressor
-  TwoPassLogFile=new char[strlen(name)+6];
-  strcpy(TwoPassLogFile,name);
-  strcat(TwoPassLogFile,&quot;.stat&quot;);
-  _encode-&gt;setLogFile(TwoPassLogFile,frametogo);
-
-  int reuse = 0;
-
-  if (_encode-&gt;isDualPass())
-  {
-	  FILE *tmp;
-
-	  if ((tmp = fopen(TwoPassLogFile,&quot;rt&quot;)))
-	  {
-		  fclose(tmp);
-
-		  if (GUI_Question(QT_TR_NOOP(&quot;Reuse the existing log file?&quot;)))
-			  reuse = 1;
-	  }
-  }
- 
-  if (!_encode-&gt;configure (_incoming, reuse))
-    {
-      delete 	_encode;
-      _encode = NULL;
-      GUI_Error_HIG (QT_TR_NOOP(&quot;Filter init failed&quot;), NULL);
-      return 0;
-    };
- 
-  memcpy (&amp;_bih, video_body-&gt;getBIH (), sizeof (_bih));
-  _bih.biWidth = _incoming-&gt;getInfo ()-&gt;width;
-  _bih.biHeight = _incoming-&gt;getInfo ()-&gt;height;
-  _bih.biSize=sizeof(_bih);
-  _bih.biXPelsPerMeter=_bih.biClrUsed=_bih.biYPelsPerMeter=0;
-
-  _mainaviheader.dwTotalFrames= _incoming-&gt;getInfo ()-&gt;nb_frames;
-_mainaviheader.dwMicroSecPerFrame=0;
-
-  printf(&quot;\n Saved as %ld x %ld\n&quot;,_bih.biWidth,_bih.biHeight);
-  _bih.biCompression=fourCC::get((uint8_t *)_encode-&gt;getCodecName());
-   
-  encoding_gui-&gt;setCodec(_encode-&gt;getDisplayName());
-  
-  // init save avi
-//-----------------------2 Pass--------------------------------------
-  if (_encode-&gt;isDualPass ())
-    {
-      uint8_t *buffer;
-      uint32_t len, flag;
-
- 	aprintf(&quot;\n** Dual pass encoding**\n&quot;);
-
-	if(!reuse)
- 	{
-	
-      	guiSetPhasis (QT_TR_NOOP(&quot;1st Pass&quot;));
-      	aprintf(&quot;**Pass 1:%lu\n&quot;,frametogo);
-     	buffer = new uint8_t[_incoming-&gt;getInfo ()-&gt;width *
-		    _incoming-&gt;getInfo ()-&gt;height * 3];
-
-      	_encode-&gt;startPass1 ();
-      //__________________________________
-      //   now go to main loop.....
-      //__________________________________
-        bitstream.bufferSize=_incoming-&gt;getInfo ()-&gt;width *   _incoming-&gt;getInfo ()-&gt;height * 3;
-        bitstream.data=buffer;
-        for (uint32_t cf = 0; cf &lt; frametogo; cf++)
-        {
-          if (guiUpdate (cf, frametogo))
-            {
-            abt:
-                GUI_Error_HIG (QT_TR_NOOP(&quot;Aborting&quot;), NULL);
-              delete[]buffer;
-              return 0;
-            }
-            
-            bitstream.cleanup(cf);
-            if (!_encode-&gt;encode (cf, &amp;bitstream))
-                {
-                        printf(&quot;\n Encoding of frame %lu failed !\n&quot;,cf);
-                        goto abt;
-                }
-           encoding_gui-&gt;setFrame(cf,bitstream.len,bitstream.out_quantizer,frametogo);
-    
-        }
-
-	encoding_gui-&gt;reset();
-      	delete[]buffer;	
-     	aprintf(&quot;**Pass 1:done\n&quot;);
-    }// End of reuse
-
-      if(!_encode-&gt;startPass2 ())
-      {
-      	printf(&quot;Pass2 ignition failed\n&quot;);
-      	return 0;
-	}
-   }   //-------------------------/VBR-----------------------------------
-  // init save avi
-
-// now we build the new stream !
-    	aprintf(&quot;**main pass:\n&quot;);
-
-		memcpy(&amp;_videostreamheader,video_body-&gt;getVideoStreamHeader (),sizeof(_videostreamheader));
-		memcpy(&amp;_videostreamheader.fccHandler	,_encode-&gt;getFCCHandler(),4);
-		_videostreamheader.fccType	=fourCC::get((uint8_t *)&quot;vids&quot;);
-		_videostreamheader.dwScale=1000;
-		_videostreamheader.dwRate= _incoming-&gt;getInfo ()-&gt;fps1000;
-
-    		memcpy(&amp;_mainaviheader	,video_body-&gt;getMainHeader (),sizeof(_mainaviheader));
-
-
-  		  _mainaviheader.dwWidth=_bih.biWidth;
-    		_mainaviheader.dwHeight=_bih.biHeight;
-    		_videostreamheader.dwQuality=10000;
-
-    uint8_t *data;
-    uint32_t dataLen=0;
-
-    _encode-&gt;hasExtraHeaderData( &amp;dataLen,&amp;data);
-#if 0
-  	if (!writter-&gt;saveBegin (name,
-			   &amp;_mainaviheader,
-			   frameEnd - frameStart + 1,
-			   &amp;_videostreamheader,
-			   &amp;_bih,
-			   data,dataLen,
-			   (AVDMGenericAudioStream *) audio_filter,
-			   NULL))
-    	{
-      		return 0;
-    	}
-#endif
-  aprintf(&quot;Setup video done\n&quot;);
-  bitstream.data=vbuffer;
-  bitstream.bufferSize=MAXIMUM_SIZE * MAXIMUM_SIZE * 3;
-  return 1;
-  //---------------------
-}
-
-//
-//      Just to keep gcc happy....
-//
-GenericAviSaveProcess::~GenericAviSaveProcess ()
-{
-  cleanupAudio();
-  if (_encode)
-    delete      _encode;
-  	_encode=NULL;
-  if(TwoPassLogFile)
-  {
-  	delete [] TwoPassLogFile;
-  	TwoPassLogFile=NULL;
-  }
-}
-
-// copy mode
-// Basically ask a video frame and send it to writter
-uint8_t
-GenericAviSaveProcess::writeVideoChunk (uint32_t frame)
-{
-  uint8_t    	ret1;
-  // CBR or CQ
-  if (frame == 0)
-  {
-    encoding_gui-&gt;setCodec(_encode-&gt;getDisplayName())  ;
-  if (!_encode-&gt;isDualPass ())
-  {
-                          guiSetPhasis (QT_TR_NOOP(&quot;Encoding&quot;));
-        }
-  else
-          {
-                          guiSetPhasis (QT_TR_NOOP(&quot;2nd Pass&quot;));
-        }
-  }
-  // first read
-  bitstream.cleanup(frame);
-  ret1 = _encode-&gt;encode ( frame,&amp;bitstream);// &amp;len1, vbuffer, &amp;_videoFlag);
-  _videoFlag=bitstream.flags;
-  if (!ret1)
-    return 0;
-  // check for split
-     // check for auto split
-      // if so, we re-write the last I frame
-      if(muxSize)
-      {
-              // we overshot the limit and it is a key frame
-              // start a new chunk
-              if(handleMuxSize() &amp;&amp; (_videoFlag &amp; AVI_KEY_FRAME))
-              {		
-                      uint8_t *data;
-                      uint32_t dataLen=0;
-
-                      _encode-&gt;hasExtraHeaderData( &amp;dataLen,&amp;data);	   
-                      if(!reigniteChunk(dataLen,data)) return 0;
-              }
-        }
-        encoding_gui-&gt;setFrame(frame,bitstream.len,bitstream.out_quantizer,frametogo);	
-        // If we have several null B frames dont write them
-        if(bitstream.len) _notnull=1;
-	else	if( !_notnull)
-	{
-		printf(&quot;Frame : %lu dropped\n&quot;,frame);
-	 	return 1;			 
-	 }
-         return writter-&gt;saveVideoFrame (bitstream.len, _videoFlag, vbuffer);
-
-}
-
-
-// EOF

Deleted: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerAvi/op_saveprocess.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerAvi/op_saveprocess.h	2009-07-23 18:18:41 UTC (rev 5129)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerAvi/op_saveprocess.h	2009-07-23 18:18:42 UTC (rev 5130)
@@ -1,41 +0,0 @@
-/***************************************************************************
-                          op_saveprocess.h  -  description
-                             -------------------
-    begin                : Fri May 3 2002
-    copyright            : (C) 2002 by mean
-    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
- #ifndef __AVI_SAVEPRC__
- #define   __AVI_SAVEPRC__
-
-
-
-
- class GenericAviSaveProcess : public   GenericAviSave
- {
-     protected :
-					    
-			Encoder 	*_encode;
-			uint8_t		_notnull;
-                       	char 		*TwoPassLogFile;
-                        ADMBitstream    bitstream;
-
-			virtual uint8_t	setupVideo( char *name  );
-			virtual uint8_t	writeVideoChunk(uint32_t frame );
-                         
-     public:
-     					GenericAviSaveProcess( void ) ;
-                          virtual 	~GenericAviSaveProcess();
-   };
-
-
-  #endif

Deleted: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerAvi/op_savesmart.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerAvi/op_savesmart.cpp	2009-07-23 18:18:41 UTC (rev 5129)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerAvi/op_savesmart.cpp	2009-07-23 18:18:42 UTC (rev 5130)
@@ -1,436 +0,0 @@
-/***************************************************************************
-                          op_savesmart.cpp  -  description
-                             -------------------
-    begin                : Mon May 6 2002
-    copyright            : (C) 2002 by mean
-    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-#include &quot;config.h&quot;
-#include &quot;ADM_default.h&quot;
-#include &quot;ADM_threads.h&quot;
-
-#ifdef USE_FFMPEG
-extern &quot;C&quot; {
-	#include &quot;ADM_lavcodec.h&quot;
-};
-#endif
-
-#include &quot;fourcc.h&quot;
-#include &quot;avi_vars.h&quot;
-#ifdef HAVE_ENCODER
-
-
-#include &quot;ADM_audio/aviaudio.hxx&quot;
-#include &quot;ADM_audiofilter/audioprocess.hxx&quot;
-
-#include &quot;ADM_videoFilter.h&quot;
-#include &quot;ADM_videoFilter_internal.h&quot;
-
-#include &quot;ADM_encoder/ADM_vidEncode.hxx&quot;
-
-#include &quot;op_aviwrite.hxx&quot;
-#include &quot;op_avisave.h&quot;
-#include &quot;op_savesmart.hxx&quot;
-
-#ifdef USE_FFMPEG		
-#include &quot;ADM_codecs/ADM_ffmpeg.h&quot;		
-#endif
-
-#include &quot;ADM_osSupport/ADM_debugID.h&quot;
-#define MODULE_NAME MODULE_SAVE_AVI
-#include &quot;ADM_osSupport/ADM_debug.h&quot;
-
-GenericAviSaveSmart::GenericAviSaveSmart(uint32_t qf) : GenericAviSave()
-{
-	_cqReenc=qf;
-	ADM_assert(qf&gt;=2 &amp;&amp; qf&lt;32);
-	_nextip=0;
-	encoderReady=0;
-        _hasBframe=0;
-}
-uint8_t	GenericAviSaveSmart::setupVideo (char *name)
-{
-
-int value=4;;
-	 
-
-		printf(&quot;\n Q: %u&quot;,_cqReenc);
-  // init save avi
-  memcpy(&amp;_bih,video_body-&gt;getBIH (),sizeof(_bih));
-  memcpy(&amp;_videostreamheader,video_body-&gt;getVideoStreamHeader (),sizeof( _videostreamheader));
-  memcpy(&amp;_mainaviheader,video_body-&gt;getMainHeader (),sizeof(_mainaviheader));
- 
-   uint8_t *extraData;
-   uint32_t extraLen;
-  _lastIPFrameSent=0xfffffff;
-   video_body-&gt;getExtraHeaderData(&amp;extraLen,&amp;extraData);
-
-  if (!writter-&gt;saveBegin (name,
-			   &amp;_mainaviheader,
-			   frameEnd - frameStart + 1, 
-			   &amp;_videostreamheader,
-			   &amp;_bih,
-			   extraData,extraLen,
-			   audio_filter,
-			   NULL
-		))
-    {
-
-      return 0;
-    }
-  compEngaged = 0;
-  encoderReady = 0;
-  _encoder = NULL;
-  aImage=new ADMImage(_mainaviheader.dwWidth,_mainaviheader.dwHeight);
-  _incoming = getFirstVideoFilter (frameStart,frameEnd-frameStart);
-  encoding_gui-&gt;setFps(_incoming-&gt;getInfo()-&gt;fps1000);
-  encoding_gui-&gt;setPhasis(QT_TR_NOOP(&quot;Smart Copy&quot;));
-  // B frame ?
-    for(int i=frameStart;i&lt;frameEnd;i++)
-    {
-      if(!video_body-&gt;getFlags ( i, &amp;_videoFlag)) break;
-      if(_videoFlag &amp; AVI_B_FRAME) _hasBframe=1;
-    }
-    if(_hasBframe) printf(&quot;The original file has bframe, expect a shift of 1 frame\n&quot;);
-  //
-  return 1;
-  //---------------------
-}
-
-//
-//      Just to keep gcc happy....
-//
-GenericAviSaveSmart::~GenericAviSaveSmart ()
-{
-  cleanupAudio();
-  if (encoderReady &amp;&amp; _encoder)
-    {
-      _encoder-&gt;stopEncoder ();
-    }
-  if (_encoder)
-    delete      _encoder;
- if(aImage)
- {
- 	delete aImage;
-	aImage=NULL;
- }
-}
-
-// copy mode
-// Basically ask a video frame and send it to writter
-uint8_t
-GenericAviSaveSmart::writeVideoChunk (uint32_t frame)
-{
-  uint32_t    len;
-  uint8_t     ret1, seq;
-
-  frame+=frameStart;
-  if (compEngaged)		// we were re-encoding
-    {
-    	return writeVideoChunk_recode(frame);
-    }
-    return writeVideoChunk_copy(frame);
-}
-//_________________________________________________________
-uint8_t GenericAviSaveSmart::writeVideoChunk_recode (uint32_t frame)
-{
-uint32_t len;
-ADMBitstream bitstream(MAXIMUM_SIZE * MAXIMUM_SIZE * 3);
-	aprintf(&quot;Frame %lu encoding\n&quot;,frame);
-	video_body-&gt;getFlags ( frame, &amp;_videoFlag);
-	if (_videoFlag &amp; AVI_KEY_FRAME)
-	{
-	  aprintf(&quot;Smart: Stopping encoder\n&quot;);
-	  // It is a kf, go back to copy mode
-	  compEngaged = 0;
-	  stopEncoder ();	// Tobias F
-	  delete	    _encoder;
-	  _encoder = NULL;
-	  return writeVideoChunk_copy(frame,1);
-	}
-	// Else encode it ....
-	//1-Read it
-	if (! video_body-&gt;getUncompressedFrame (frame, aImage))
-		return 0;
-	// 2-encode it
-        bitstream.data=vbuffer;
-        bitstream.cleanup(frame);
-        if (!_encoder-&gt;encode (aImage, &amp;bitstream))//vbuffer, &amp;len, &amp;_videoFlag))
-		return 0;
-        _videoFlag=bitstream.flags;
-	// 3-write it
-        encoding_gui-&gt;setFrame(frame-frameStart,bitstream.len,bitstream.out_quantizer,frametogo);
-	return writter-&gt;saveVideoFrame (bitstream.len, _videoFlag, vbuffer);
-}
-//_________________________________________________________
-uint8_t GenericAviSaveSmart::writeVideoChunk_copy (uint32_t frame,uint32_t first)
-{
-  // Check flags and seq
-  uint32_t myseq=0;
-  uint32_t nextip;
-  uint8_t seq;
-  ADMCompressedImage img;
-  
-  img.data=vbuffer;
-  
-  	aprintf(&quot;Frame %lu copying\n&quot;,frame);
-        
-  	// all gop should be closed, so it should be safe to do it here
-	if(muxSize)
-      	{
-		// we overshot the limit and it is a key frame
-		// start a new chunk
-		if(handleMuxSize() &amp;&amp; (_videoFlag &amp; AVI_KEY_FRAME))
-		{		
-		 	uint8_t *extraData;
-			uint32_t extraLen;
-
-   			video_body-&gt;getExtraHeaderData(&amp;extraLen,&amp;extraData);
-					   
-			if(!reigniteChunk(extraLen,extraData)) return 0;
-		}
-	}
-  
-  	video_body-&gt;getFlags( frame,&amp;_videoFlag);	
-        if(frame==frameStart)
-        {
-          if(!(_videoFlag &amp; AVI_KEY_FRAME))
-          {
-            aprintf(&quot;1st frame is not a kef:There is a broken reference, encoding\n&quot;);
-            compEngaged = 1;
-            initEncoder (_cqReenc);
-            return writeVideoChunk_recode(frame);
-            
-          }
-        }
-	
-  	if(_videoFlag &amp; AVI_B_FRAME) // lookup next I/P frame
-	{
-		if(_nextip&lt;frame) // new forward frame
-		{
-			aprintf(&quot;Smart:New forward frame\n&quot;);
-			if(!seekNextRef(frame,&amp;nextip))
-			{
-				aprintf(&quot;Smart:B Frame without reference frame\n&quot;);
-				return 1;
-			}
-			// check if that the frame -1,....,next forward ref are all sequential
-			if(!video_body-&gt;sequentialFramesB(frame-1,nextip)&amp;&amp;!(_videoFlag &amp;AVI_KEY_FRAME )) 
-			{
-				aprintf(&quot;Smart:There is a broken reference, encoding\n&quot;);
-				compEngaged = 1;
-				initEncoder (_cqReenc);
-				return writeVideoChunk_recode(frame);
-			}
-			
-			aprintf(&quot;Smart : using %lu as next\n&quot;,nextip);
-			// Seems ok, write it and mark it
-			if (! video_body-&gt;getFrame (nextip,&amp;img,&amp;seq))// vbuffer, &amp;len,		      &amp;_videoFlag, &amp;seq))
-    				return 0;
-                        _videoFlag=img.flags;
-			_nextip=nextip;
-                        encoding_gui-&gt;setFrame(frame-frameStart,img.dataLength,0,frametogo);
-			return writter-&gt;saveVideoFrame (img.dataLength, img.flags, img.data);
-		}
-		else
-		{	// Nth B frame
-			aprintf(&quot;Smart:Next B frame\n&quot;);
-			if (!video_body-&gt;getFrame (frame-1, &amp;img, &amp;seq))
-    				return 0;
-                         _videoFlag=img.flags;
-                        encoding_gui-&gt;setFrame(frame-frameStart,img.dataLength,0,frametogo);
-			return writter-&gt;saveVideoFrame (img.dataLength, img.flags, img.data);
-		}
-	}
-	// Not a bframe
-	// Is it the frame we sent previously ?
-	if(frame==_nextip &amp;&amp; _nextip)
-	{
-		// Send the last B frame instead
-		aprintf(&quot;Smart finishing B frame %lu\n&quot;,frame-1);
-		if (! video_body-&gt;getFrame(frame-1, &amp;img, &amp;seq))// (frame-1, vbuffer, &amp;len,    &amp;_videoFlag, &amp;seq))
-    			return 0;
-                 _videoFlag=img.flags;
-                encoding_gui-&gt;setFrame(frame-frameStart,img.dataLength,0,frametogo);
-		return writter-&gt;saveVideoFrame  (img.dataLength, img.flags, img.data);;
-	
-	}
-	// Regular frame
-	// just copy it
-	if(frame)
-		if(!video_body-&gt;sequentialFramesB(_nextip,frame)&amp;&amp;!(_videoFlag &amp;AVI_KEY_FRAME ))  // Need to re-encode
-		{
-			aprintf(&quot;Seq broken..\n&quot;);
-			compEngaged = 1;
-			initEncoder (_cqReenc);
-                        encoding_gui-&gt;setFrame(frame-frameStart,img.dataLength,0,frametogo);
-			return writeVideoChunk_recode(frame);
-		}
-	_nextip=frame;
-	aprintf(&quot;Smart: regular\n&quot;);
-	if(! video_body-&gt;getFrame (frame, &amp;img, &amp;seq)) return 0;
-        _videoFlag=img.flags;
-	
-	encoding_gui-&gt;setFrame(frame-frameStart,img.dataLength,0,frametogo);
-	if(first)
-	{
-		ADM_assert(_videoFlag == AVI_KEY_FRAME);
-		// Grab extra data ..
-			uint8_t *extraData;
-			uint32_t extraLen;
-			uint8_t r;
-   			video_body-&gt;getExtraHeaderData(&amp;extraLen,&amp;extraData);
-			if(extraLen)
-			{
-			//********************************************************************
-			// If we have global headers we have to duplicate the old headers as they were replaced
-			// by the new headers from the section we re-encoded
-			//********************************************************************
-				printf(&quot;[Smart] Duplicating vop header (%d bytes)\n&quot;,extraLen);
-				uint8_t *buffer=new uint8_t[extraLen+img.dataLength];
-				memcpy(buffer,extraData,extraLen);
-				memcpy(buffer+extraLen,img.data,img.dataLength);
-				r=writter-&gt;saveVideoFrame (img.dataLength+extraLen, img.flags, buffer);;
-				delete [] buffer;
-				return r;
-				
-			}
-	}
-	return writter-&gt;saveVideoFrame (img.dataLength, img.flags, img.data);;
-}
-//_________________________________________________________
-uint8_t GenericAviSaveSmart::seekNextRef(uint32_t frame,uint32_t *nextip)
-{
-uint32_t flags;
-	for(uint32_t i=frame+1;i&lt;frameEnd;i++)
-	{
-		video_body-&gt;getFlags( i,&amp;flags);
-		if(!(flags &amp; AVI_B_FRAME)) 
-		{
-			*nextip=i;
-			return 1;
-		}
-	
-	}
-	return 0;
-}
- //
- //
-uint8_t
-GenericAviSaveSmart::initEncoder (uint32_t qz)
-{
-  aviInfo
-    info;
-  video_body-&gt;getVideoInfo (&amp;info);
-  ADM_assert (0 == encoderReady);
-  encoderReady = 1;
-  uint8_t ret=0;
-  FFcodecSetting myConfig=
-	 {
-	 ME_EPZS,//	ME
-	 0, // 		GMC	
-	 0,	// 4MV
-	 0,//		_QPEL;	 
-	 0,//		_TREILLIS_QUANT
-	 2,//		qmin;
-	 31,//		qmax;
-	 3,//		max_qdiff;
-	 1,//		max_b_frames;
-	 0, //		mpeg_quant;
-	 1, //
-	 -2, // 		luma_elim_threshold;
-	 1,//
-	 -5, 		// chroma_elim_threshold;
-	 0.05,		//lumi_masking;
-	 1,		// is lumi
-	 0.01,		//dark_masking; 
-	 1,		// is dark
- 	 0.5,		// qcompress amount of qscale change between easy &amp; hard scenes (0.0-1.0
-    	 0.5,		// qblur;    amount of qscale smoothing over time (0.0-1.0) 
-	0,		// min bitrate in kB/S
-	0,		// max bitrate
-	0, 		// default matrix
-	0, 		// no gop size
-	NULL,
-	NULL,
-	0,		// interlaced
-	0,		// WLA: bottom-field-first
-	0,		// wide screen
-	2,		// mb eval = distortion
-	8000,		// vratetol 8Meg
-	0,		// is temporal
-	0.0,		// temporal masking
-	0,		// is spatial
-	0.0,		// spatial masking
-	0,		// NAQ
-	0		// DUMMY 
- 	} ;
-
-
-  if(  isMpeg4Compatible(info.fcc) )
-  	{
-/*	
-#ifdef USE_DIVX		 
-		 	 _encoder = new divxEncoderCQ (info.width, info.height);
-	   
-#else			
-*/
-// 	uint8_t				setConfig(FFcodecSetting *set);	
-			ffmpegEncoderCQ *tmp;		
-			tmp = new ffmpegEncoderCQ (info.width, info.height,FF_MPEG4);					
-			myConfig.max_b_frames=_hasBframe; // In fact does the original have b frame ?
-			tmp-&gt;setConfig(&amp;myConfig);
-			printf(&quot;\n init qz %ld\n&quot;,qz);
-	    		ret= tmp-&gt;init (qz,25000);
-			_encoder=tmp;
-/*			
-#endif		  		  
-*/
-		
-#warning 25 fps hardcoded
-
-		 }
-		 else
-		 {
-#ifdef USE_FFMPEG			 
-			 if(isMSMpeg4Compatible(info.fcc) ) // DIV3
-			 {
-				 ffmpegEncoderCQ *tmp;
-				  tmp = new ffmpegEncoderCQ (info.width, info.height,FF_MSMP4V3);
-                                  myConfig.max_b_frames=0;
-				  tmp-&gt;setConfig(&amp;myConfig);
-			    	  ret= tmp-&gt;init (qz,25000);
-			    	  _encoder=tmp;
-				}
-				else
-					{
-				       ADM_assert(0);
-					}			
-			}
-#else
-			ADM_assert(0);
-			}			
-#endif
-
-		return ret;
-}
-
-uint8_t
-GenericAviSaveSmart::stopEncoder (void)
-{
-  ADM_assert (1 == encoderReady);
-  encoderReady = 0;
-  return (_encoder-&gt;stopEncoder ());
-}
-
-#endif

Deleted: branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerAvi/op_savesmart.hxx
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerAvi/op_savesmart.hxx	2009-07-23 18:18:41 UTC (rev 5129)
+++ branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/muxerAvi/op_savesmart.hxx	2009-07-23 18:18:42 UTC (rev 5130)
@@ -1,47 +0,0 @@
-/***************************************************************************
-                          op_savesmart.hxx  -  description
-                             -------------------
-    begin                : Mon May 6 2002
-    copyright            : (C) 2002 by mean
-    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
- #ifndef __AVI_SAVESMT__
- #define   __AVI_SAVESMT__
-
- class GenericAviSaveSmart : public   GenericAviSave
- {
-     protected :
-                                uint32_t        _hasBframe;
-     #warning HARDCODED MAX IMAGE SIZE
-     				
-				ADMImage	*aImage;
-				uint32_t	_nextip;
-				uint8_t 	initEncoder(uint32_t qz );
-				uint8_t 	stopEncoder(void  );
-       				uint32_t 	encoderReady;
-              			uint32_t 	compEngaged;
-	virtual 		uint8_t 	setupVideo( char *name  );
- 	virtual 		uint8_t 	writeVideoChunk(uint32_t frame );
-				uint8_t		 writeVideoChunk_recode (uint32_t frame);
-				uint8_t		 writeVideoChunk_copy (uint32_t frame,uint32_t first=0);
-              			encoder 	*_encoder;
-              			uint8_t 	_cqReenc          ;
-				
-     public:
-     							
-     						GenericAviSaveSmart(uint32_t qfactor);		
-                          virtual 		~GenericAviSaveSmart();
-			  uint8_t 		seekNextRef(uint32_t frame,uint32_t *nextip);
-   };
-
-
-  #endif


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="002344.html">[Avidemux-svn-commit] r5129 -	branches/avidemux_2.6_branch_mean/avidemux/common/ADM_commonUI
</A></li>
	<LI>Next message: <A HREF="002346.html">[Avidemux-svn-commit] r5131 -	branches/avidemux_2.6_branch_mean/avidemux_plugins/ADM_muxers/oplug_ogm
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2345">[ date ]</a>
              <a href="thread.html#2345">[ thread ]</a>
              <a href="subject.html#2345">[ subject ]</a>
              <a href="author.html#2345">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">More information about the Avidemux-svn-commit
mailing list</a><br>
</body></html>
