<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Avidemux-svn-commit] r4384 - in	branches/avidemux_2.5_branch_gruntster/avidemux:	ADM_libraries/ADM_ffmpeg ADM_libraries/ADM_ffmpeg/ADM_lavcodec	ADM_libraries/ADM_ffmpeg/ADM_lavformat	ADM_libraries/ADM_utilities ADM_outputs ADM_outputs/oplug_avi	ADM_outputs/oplug_mp4
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/avidemux-svn-commit/2008-September/index.html" >
   <LINK REL="made" HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r4384%20-%20in%0A%09branches/avidemux_2.5_branch_gruntster/avidemux%3A%0A%09ADM_libraries/ADM_ffmpeg%20ADM_libraries/ADM_ffmpeg/ADM_lavcodec%0A%09ADM_libraries/ADM_ffmpeg/ADM_lavformat%0A%09ADM_libraries/ADM_utilities%20ADM_outputs%20ADM_outputs/oplug_avi%0A%09ADM_outputs/oplug_mp4&In-Reply-To=%3C200809201551.m8KFpoNq020466%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001623.html">
   <LINK REL="Next"  HREF="001625.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Avidemux-svn-commit] r4384 - in	branches/avidemux_2.5_branch_gruntster/avidemux:	ADM_libraries/ADM_ffmpeg ADM_libraries/ADM_ffmpeg/ADM_lavcodec	ADM_libraries/ADM_ffmpeg/ADM_lavformat	ADM_libraries/ADM_utilities ADM_outputs ADM_outputs/oplug_avi	ADM_outputs/oplug_mp4</H1>
    <B>gruntster at mail.berlios.de</B> 
    <A HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r4384%20-%20in%0A%09branches/avidemux_2.5_branch_gruntster/avidemux%3A%0A%09ADM_libraries/ADM_ffmpeg%20ADM_libraries/ADM_ffmpeg/ADM_lavcodec%0A%09ADM_libraries/ADM_ffmpeg/ADM_lavformat%0A%09ADM_libraries/ADM_utilities%20ADM_outputs%20ADM_outputs/oplug_avi%0A%09ADM_outputs/oplug_mp4&In-Reply-To=%3C200809201551.m8KFpoNq020466%40sheep.berlios.de%3E"
       TITLE="[Avidemux-svn-commit] r4384 - in	branches/avidemux_2.5_branch_gruntster/avidemux:	ADM_libraries/ADM_ffmpeg ADM_libraries/ADM_ffmpeg/ADM_lavcodec	ADM_libraries/ADM_ffmpeg/ADM_lavformat	ADM_libraries/ADM_utilities ADM_outputs ADM_outputs/oplug_avi	ADM_outputs/oplug_mp4">gruntster at mail.berlios.de
       </A><BR>
    <I>Sat Sep 20 17:51:50 CEST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="001623.html">[Avidemux-svn-commit] r4383 - in	branches/avidemux_2.5_branch_gruntster: avidemux/ADM_UIs/ADM_QT4/src	avidemux/ADM_userInterfaces/ADM_GTK/ADM_gui2	avidemux/ADM_userInterfaces/ADM_GTK/glade	avidemux/ADM_userInterfaces/ADM_QT4/ADM_gui	avidemux/ADM_userInterfaces/ADM_commonUI	plugins/ADM_videoEncoder/ADM_vidEnc_x264	plugins/ADM_videoEncoder/ADM_vidEnc_x264/xml	plugins/ADM_videoFilters/ASharp/qt4
</A></li>
        <LI>Next message: <A HREF="001625.html">[Avidemux-svn-commit] r4385 - in	branches/avidemux_2.5_branch_gruntster: avidemux/ADM_codecs	avidemux/ADM_encoder avidemux/ADM_outputs/oplug_avi	avidemux/ADM_outputs/oplug_dummy	avidemux/ADM_outputs/oplug_flv avidemux/ADM_outputs/oplug_mp4	avidemux/ADM_outputs/oplug_ogm	avidemux/ADM_userInterfaces/ADM_QT4/ADM_filters po
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1624">[ date ]</a>
              <a href="thread.html#1624">[ thread ]</a>
              <a href="subject.html#1624">[ subject ]</a>
              <a href="author.html#1624">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: gruntster
Date: 2008-09-20 17:51:36 +0200 (Sat, 20 Sep 2008)
New Revision: 4384

Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_libraries/ADM_ffmpeg/ADM_lavcodec/avcodec.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_libraries/ADM_ffmpeg/ADM_lavformat/movenc.c
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_libraries/ADM_ffmpeg/config.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_libraries/ADM_utilities/ADM_bitstream.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_libraries/ADM_utilities/ADM_bitstream.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_outputs/ADM_lavformat.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_outputs/oplug_avi/op_saveprocess.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_outputs/oplug_avi/op_saveprocess.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_outputs/oplug_mp4/oplug_mp4.cpp
Log:
[Merge] integrate changes from 2.4 branch (r4366)

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_libraries/ADM_ffmpeg/ADM_lavcodec/avcodec.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_libraries/ADM_ffmpeg/ADM_lavcodec/avcodec.h	2008-09-20 15:21:58 UTC (rev 4383)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_libraries/ADM_ffmpeg/ADM_lavcodec/avcodec.h	2008-09-20 15:51:36 UTC (rev 4384)
@@ -177,6 +177,7 @@
     CODEC_ID_SUNRAST,
     CODEC_ID_INDEO4,
     CODEC_ID_INDEO5,
+    CODEC_ID_DIRAC,
 
     /* various PCM &quot;codecs&quot; */
     CODEC_ID_PCM_S16LE= 0x10000,

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_libraries/ADM_ffmpeg/ADM_lavformat/movenc.c
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_libraries/ADM_ffmpeg/ADM_lavformat/movenc.c	2008-09-20 15:21:58 UTC (rev 4383)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_libraries/ADM_ffmpeg/ADM_lavformat/movenc.c	2008-09-20 15:51:36 UTC (rev 4384)
@@ -24,6 +24,7 @@
 #include &quot;avio.h&quot;
 #include &quot;isom.h&quot;
 #include &quot;avc.h&quot;
+#include &quot;bitstream.h&quot;
 
 #undef NDEBUG
 #include &lt;assert.h&gt;
@@ -31,19 +32,14 @@
 #define MOV_INDEX_CLUSTER_SIZE 16384
 #define globalTimescale 1000
 
-#define MODE_MP4 0
-#define MODE_MOV 1
-#define MODE_3GP 2
-#define MODE_PSP 3 // example working PSP command line:
+#define MODE_MP4  0x01
+#define MODE_MOV  0x02
+#define MODE_3GP  0x04
+#define MODE_PSP  0x08 // example working PSP command line:
 // ffmpeg -i testinput.avi  -f psp -r 14.985 -s 320x240 -b 768 -ar 24000 -ab 32 M4V00001.MP4
-#define MODE_3G2 4
-#define MODE_IPOD 5
+#define MODE_3G2  0x10
+#define MODE_IPOD 0x20
 
-// MEANX
-//extern int ADM_useAlternateTagging(void);
-// MEANX
-
-
 typedef struct MOVIentry {
     unsigned int flags, size;
     uint64_t     pos;
@@ -86,7 +82,7 @@
 } MOVContext;
 
 //FIXME support 64 bit variant with wide placeholders
-static offset_t updateSize (ByteIOContext *pb, offset_t pos)
+static offset_t updateSize(ByteIOContext *pb, offset_t pos)
 {
     offset_t curpos = url_ftell(pb);
     url_fseek(pb, pos, SEEK_SET);
@@ -97,7 +93,7 @@
 }
 
 /* Chunk offset atom */
-static int mov_write_stco_tag(ByteIOContext *pb, MOVTrack* track)
+static int mov_write_stco_tag(ByteIOContext *pb, MOVTrack *track)
 {
     int i;
     int mode64 = 0; //   use 32 bit size variant if possible
@@ -116,11 +112,11 @@
         else
             put_be32(pb, track-&gt;cluster[i].pos);
     }
-    return updateSize (pb, pos);
+    return updateSize(pb, pos);
 }
 
 /* Sample size atom */
-static int mov_write_stsz_tag(ByteIOContext *pb, MOVTrack* track)
+static int mov_write_stsz_tag(ByteIOContext *pb, MOVTrack *track)
 {
     int equalChunks = 1;
     int i, j, entries = 0, tst = -1, oldtst = -1;
@@ -153,11 +149,11 @@
             }
         }
     }
-    return updateSize (pb, pos);
+    return updateSize(pb, pos);
 }
 
 /* Sample to chunk atom */
-static int mov_write_stsc_tag(ByteIOContext *pb, MOVTrack* track)
+static int mov_write_stsc_tag(ByteIOContext *pb, MOVTrack *track)
 {
     int index = 0, oldval = -1, i;
     offset_t entryPos, curpos;
@@ -183,11 +179,11 @@
     put_be32(pb, index); // rewrite size
     url_fseek(pb, curpos, SEEK_SET);
 
-    return updateSize (pb, pos);
+    return updateSize(pb, pos);
 }
 
 /* Sync sample atom */
-static int mov_write_stss_tag(ByteIOContext *pb, MOVTrack* track)
+static int mov_write_stss_tag(ByteIOContext *pb, MOVTrack *track)
 {
     offset_t curpos, entryPos;
     int i, index = 0;
@@ -207,7 +203,7 @@
     url_fseek(pb, entryPos, SEEK_SET);
     put_be32(pb, index); // rewrite size
     url_fseek(pb, curpos, SEEK_SET);
-    return updateSize (pb, pos);
+    return updateSize(pb, pos);
 }
 
 static int mov_write_amr_tag(ByteIOContext *pb, MOVTrack *track)
@@ -224,6 +220,60 @@
     return 0x11;
 }
 
+static int mov_write_ac3_tag(ByteIOContext *pb, MOVTrack *track)
+{
+    GetBitContext gbc;
+    PutBitContext pbc;
+    uint8_t buf[3];
+    int fscod, bsid, bsmod, acmod, lfeon, frmsizecod;
+
+    if (track-&gt;vosLen &lt; 7)
+        return -1;
+
+    put_be32(pb, 11);
+    put_tag(pb, &quot;dac3&quot;);
+
+    init_get_bits(&amp;gbc, track-&gt;vosData+4, track-&gt;vosLen-4);
+    fscod      = get_bits(&amp;gbc, 2);
+    frmsizecod = get_bits(&amp;gbc, 6);
+    bsid       = get_bits(&amp;gbc, 5);
+    bsmod      = get_bits(&amp;gbc, 3);
+    acmod      = get_bits(&amp;gbc, 3);
+    if (acmod == 2) {
+        skip_bits(&amp;gbc, 2); // dsurmod
+    } else {
+        if ((acmod &amp; 1) &amp;&amp; acmod != 1)
+            skip_bits(&amp;gbc, 2); // cmixlev
+        if (acmod &amp; 4)
+            skip_bits(&amp;gbc, 2); // surmixlev
+    }
+    lfeon = get_bits1(&amp;gbc);
+
+    init_put_bits(&amp;pbc, buf, sizeof(buf));
+    put_bits(&amp;pbc, 2, fscod);
+    put_bits(&amp;pbc, 5, bsid);
+    put_bits(&amp;pbc, 3, bsmod);
+    put_bits(&amp;pbc, 3, acmod);
+    put_bits(&amp;pbc, 1, lfeon);
+    put_bits(&amp;pbc, 5, frmsizecod&gt;&gt;1); // bit_rate_code
+    put_bits(&amp;pbc, 5, 0); // reserved
+
+    flush_put_bits(&amp;pbc);
+    put_buffer(pb, buf, sizeof(buf));
+
+    return 11;
+}
+
+/**
+ * This function writes extradata &quot;as is&quot;.
+ * Extradata must be formated like a valid atom (with size and tag)
+ */
+static int mov_write_extradata_tag(ByteIOContext *pb, MOVTrack *track)
+{
+    put_buffer(pb, track-&gt;enc-&gt;extradata, track-&gt;enc-&gt;extradata_size);
+    return track-&gt;enc-&gt;extradata_size;
+}
+
 static int mov_write_enda_tag(ByteIOContext *pb)
 {
     put_be32(pb, 10);
@@ -248,64 +298,61 @@
     put_byte(pb, size &amp; 0x7F);
 }
 
-static int mov_write_esds_tag(ByteIOContext *pb, MOVTrack* track) // Basic
+static int mov_write_esds_tag(ByteIOContext *pb, MOVTrack *track) // Basic
 {
-int codec_id; // MEANX
-
     offset_t pos = url_ftell(pb);
     int decoderSpecificInfoLen = track-&gt;vosLen ? descrLength(track-&gt;vosLen):0;
 
-    put_be32(pb, 0);               // size
+    put_be32(pb, 0); // size
     put_tag(pb, &quot;esds&quot;);
-    put_be32(pb, 0);               // Version
+    put_be32(pb, 0); // Version
 
     // ES descriptor
     putDescr(pb, 0x03, 3 + descrLength(13 + decoderSpecificInfoLen) +
              descrLength(1));
     put_be16(pb, track-&gt;trackID);
-    put_byte(pb, 0x00);            // flags (= no flags)
+    put_byte(pb, 0x00); // flags (= no flags)
 
     // DecoderConfig descriptor
     putDescr(pb, 0x04, 13 + decoderSpecificInfoLen);
 
     // Object type indication
-   //MEANX  put_byte(pb, codec_get_tag(ff_mp4_obj_type, track-&gt;enc-&gt;codec_id));
-   codec_id=track-&gt;enc-&gt;codec_id;
-    //if(ADM_useAlternateTagging() &amp;&amp; codec_id==CODEC_ID_MP3) codec_id=CODEC_ID_MP2;
-    put_byte(pb, codec_get_tag(ff_mp4_obj_type, codec_id));
-    // /MEANX
+    if ((track-&gt;enc-&gt;codec_id == CODEC_ID_MP2 ||
+         track-&gt;enc-&gt;codec_id == CODEC_ID_MP3) &amp;&amp;
+        track-&gt;enc-&gt;sample_rate &gt; 24000)
+        put_byte(pb, 0x6B); // 11172-3
+    else
+        put_byte(pb, codec_get_tag(ff_mp4_obj_type, track-&gt;enc-&gt;codec_id));
 
     // the following fields is made of 6 bits to identify the streamtype (4 for video, 5 for audio)
     // plus 1 bit to indicate upstream and 1 bit set to 1 (reserved)
     if(track-&gt;enc-&gt;codec_type == CODEC_TYPE_AUDIO)
-        put_byte(pb, 0x15);            // flags (= Audiostream)
+        put_byte(pb, 0x15); // flags (= Audiostream)
     else
-        put_byte(pb, 0x11);            // flags (= Visualstream)
+        put_byte(pb, 0x11); // flags (= Visualstream)
 
-    put_byte(pb,  track-&gt;enc-&gt;rc_buffer_size&gt;&gt;(3+16));             // Buffersize DB (24 bits)
-    put_be16(pb, (track-&gt;enc-&gt;rc_buffer_size&gt;&gt;3)&amp;0xFFFF);          // Buffersize DB
+    put_byte(pb,  track-&gt;enc-&gt;rc_buffer_size&gt;&gt;(3+16));    // Buffersize DB (24 bits)
+    put_be16(pb, (track-&gt;enc-&gt;rc_buffer_size&gt;&gt;3)&amp;0xFFFF); // Buffersize DB
 
-    put_be32(pb, FFMAX(track-&gt;enc-&gt;bit_rate, track-&gt;enc-&gt;rc_max_rate));     // maxbitrate  (FIXME should be max rate in any 1 sec window)
+    put_be32(pb, FFMAX(track-&gt;enc-&gt;bit_rate, track-&gt;enc-&gt;rc_max_rate)); // maxbitrate (FIXME should be max rate in any 1 sec window)
     if(track-&gt;enc-&gt;rc_max_rate != track-&gt;enc-&gt;rc_min_rate || track-&gt;enc-&gt;rc_min_rate==0)
-        put_be32(pb, 0);     // vbr
+        put_be32(pb, 0); // vbr
     else
-        put_be32(pb, track-&gt;enc-&gt;rc_max_rate);     // avg bitrate
+        put_be32(pb, track-&gt;enc-&gt;rc_max_rate); // avg bitrate
 
-    if (track-&gt;vosLen)
-    {
+    if (track-&gt;vosLen) {
         // DecoderSpecific info descriptor
         putDescr(pb, 0x05, track-&gt;vosLen);
         put_buffer(pb, track-&gt;vosData, track-&gt;vosLen);
     }
 
-
     // SL descriptor
     putDescr(pb, 0x06, 1);
     put_byte(pb, 0x02);
-    return updateSize (pb, pos);
+    return updateSize(pb, pos);
 }
 
-static int mov_write_wave_tag(ByteIOContext *pb, MOVTrack* track)
+static int mov_write_wave_tag(ByteIOContext *pb, MOVTrack *track)
 {
     offset_t pos = url_ftell(pb);
 
@@ -327,15 +374,19 @@
         mov_write_enda_tag(pb);
     } else if (track-&gt;enc-&gt;codec_id == CODEC_ID_AMR_NB) {
         mov_write_amr_tag(pb, track);
+    } else if (track-&gt;enc-&gt;codec_id == CODEC_ID_AC3) {
+        mov_write_ac3_tag(pb, track);
+    } else if (track-&gt;enc-&gt;codec_id == CODEC_ID_ALAC) {
+        mov_write_extradata_tag(pb, track);
     }
 
     put_be32(pb, 8);     /* size */
     put_be32(pb, 0);     /* null tag */
 
-    return updateSize (pb, pos);
+    return updateSize(pb, pos);
 }
 
-static int mov_write_glbl_tag(ByteIOContext *pb, MOVTrack* track)
+static int mov_write_glbl_tag(ByteIOContext *pb, MOVTrack *track)
 {
     put_be32(pb, track-&gt;vosLen+8);
     put_tag(pb, &quot;glbl&quot;);
@@ -343,7 +394,7 @@
     return 8+track-&gt;vosLen;
 }
 
-static int mov_write_audio_tag(ByteIOContext *pb, MOVTrack* track)
+static int mov_write_audio_tag(ByteIOContext *pb, MOVTrack *track)
 {
     offset_t pos = url_ftell(pb);
     int version = track-&gt;mode == MODE_MOV &amp;&amp;
@@ -389,18 +440,24 @@
 
     if(track-&gt;mode == MODE_MOV &amp;&amp;
        (track-&gt;enc-&gt;codec_id == CODEC_ID_AAC ||
+        track-&gt;enc-&gt;codec_id == CODEC_ID_AC3 ||
         track-&gt;enc-&gt;codec_id == CODEC_ID_AMR_NB ||
         track-&gt;enc-&gt;codec_id == CODEC_ID_PCM_S24LE ||
-        track-&gt;enc-&gt;codec_id == CODEC_ID_PCM_S32LE))
+        track-&gt;enc-&gt;codec_id == CODEC_ID_PCM_S32LE ||
+        track-&gt;enc-&gt;codec_id == CODEC_ID_ALAC))
         mov_write_wave_tag(pb, track);
-    else if(track-&gt;tag == MKTAG('m','p','4','a')) // MEANX : Not changed, AAC OR MP3 NOT SURE...
+    else if(track-&gt;tag == MKTAG('m','p','4','a'))
         mov_write_esds_tag(pb, track);
     else if(track-&gt;enc-&gt;codec_id == CODEC_ID_AMR_NB)
         mov_write_amr_tag(pb, track);
+    else if(track-&gt;enc-&gt;codec_id == CODEC_ID_AC3)
+        mov_write_ac3_tag(pb, track);
+    else if(track-&gt;enc-&gt;codec_id == CODEC_ID_ALAC)
+        mov_write_extradata_tag(pb, track);
     else if(track-&gt;vosLen &gt; 0)
         mov_write_glbl_tag(pb, track);
 
-    return updateSize (pb, pos);
+    return updateSize(pb, pos);
 }
 
 static int mov_write_d263_tag(ByteIOContext *pb)
@@ -493,6 +550,7 @@
     { CODEC_ID_AAC,    MKTAG('m','p','4','a') },
     { CODEC_ID_AMR_NB, MKTAG('s','a','m','r') },
     { CODEC_ID_AMR_WB, MKTAG('s','a','w','b') },
+    { CODEC_ID_NONE, 0 },
 };
 
 static const AVCodecTag mov_pix_fmt_tags[] = {
@@ -503,16 +561,32 @@
     { PIX_FMT_BGR32_1, MKTAG('r','a','w',' ') },
 };
 
+static const AVCodecTag codec_ipod_tags[] = {
+    { CODEC_ID_H264,   MKTAG('a','v','c','1') },
+    { CODEC_ID_MPEG4,  MKTAG('m','p','4','v') },
+    { CODEC_ID_AAC,    MKTAG('m','p','4','a') },
+    { CODEC_ID_ALAC,   MKTAG('a','l','a','c') },
+    { CODEC_ID_AC3,    MKTAG('a','c','-','3') },
+    { CODEC_ID_NONE, 0 },
+};
+
 static int mov_find_codec_tag(AVFormatContext *s, MOVTrack *track)
 {
     int tag = track-&gt;enc-&gt;codec_tag;
-    if (track-&gt;mode == MODE_MP4 || track-&gt;mode == MODE_PSP || track-&gt;mode == MODE_IPOD) {
+    if (track-&gt;mode == MODE_MP4 || track-&gt;mode == MODE_PSP) {
         if (!codec_get_tag(ff_mp4_obj_type, track-&gt;enc-&gt;codec_id))
             return 0;
-        if (track-&gt;enc-&gt;codec_id == CODEC_ID_H264)           tag = MKTAG('a','v','c','1');
+        if      (track-&gt;enc-&gt;codec_id == CODEC_ID_H264)      tag = MKTAG('a','v','c','1');
+        else if (track-&gt;enc-&gt;codec_id == CODEC_ID_AC3)       tag = MKTAG('a','c','-','3');
+        else if (track-&gt;enc-&gt;codec_id == CODEC_ID_DIRAC)     tag = MKTAG('d','r','a','c');
         else if (track-&gt;enc-&gt;codec_type == CODEC_TYPE_VIDEO) tag = MKTAG('m','p','4','v');
         else if (track-&gt;enc-&gt;codec_type == CODEC_TYPE_AUDIO) tag = MKTAG('m','p','4','a');
-    } else if (track-&gt;mode == MODE_3GP || track-&gt;mode == MODE_3G2) {
+    } else if (track-&gt;mode == MODE_IPOD) {
+        tag = codec_get_tag(codec_ipod_tags, track-&gt;enc-&gt;codec_id);
+        if (!match_ext(s-&gt;filename, &quot;m4a&quot;) &amp;&amp; !match_ext(s-&gt;filename, &quot;m4v&quot;))
+            av_log(s, AV_LOG_WARNING, &quot;Warning, extension is not .m4a nor .m4v &quot;
+                   &quot;Quicktime/Ipod might not play the file\n&quot;);
+    } else if (track-&gt;mode &amp; MODE_3GP) {
         tag = codec_get_tag(codec_3gp_tags, track-&gt;enc-&gt;codec_id);
     } else if (!tag || (track-&gt;enc-&gt;strict_std_compliance &gt;= FF_COMPLIANCE_NORMAL &amp;&amp;
                         (tag == MKTAG('d','v','c','p') ||
@@ -569,7 +643,7 @@
     return 28;
 }
 
-static int mov_write_video_tag(ByteIOContext *pb, MOVTrack* track)
+static int mov_write_video_tag(ByteIOContext *pb, MOVTrack *track)
 {
     offset_t pos = url_ftell(pb);
     char compressor_name[32];
@@ -621,20 +695,19 @@
         mov_write_d263_tag(pb);
     else if(track-&gt;enc-&gt;codec_id == CODEC_ID_SVQ3)
         mov_write_svq3_tag(pb);
+    else if(track-&gt;enc-&gt;codec_id == CODEC_ID_DNXHD)
+        mov_write_avid_tag(pb, track);
     else if(track-&gt;enc-&gt;codec_id == CODEC_ID_H264) {
         mov_write_avcc_tag(pb, track);
         if(track-&gt;mode == MODE_IPOD)
             mov_write_uuid_tag_ipod(pb);
-    }
-    else if(track-&gt;enc-&gt;codec_id == CODEC_ID_DNXHD)
-        mov_write_avid_tag(pb, track);
-    else if(track-&gt;vosLen &gt; 0)
+    } else if(track-&gt;vosLen &gt; 0)
         mov_write_glbl_tag(pb, track);
 
-    return updateSize (pb, pos);
+    return updateSize(pb, pos);
 }
 
-static int mov_write_stsd_tag(ByteIOContext *pb, MOVTrack* track)
+static int mov_write_stsd_tag(ByteIOContext *pb, MOVTrack *track)
 {
     offset_t pos = url_ftell(pb);
     put_be32(pb, 0); /* size */
@@ -648,7 +721,7 @@
     return updateSize(pb, pos);
 }
 
-static int mov_write_ctts_tag(ByteIOContext *pb, MOVTrack* track)
+static int mov_write_ctts_tag(ByteIOContext *pb, MOVTrack *track)
 {
     MOV_stts_t *ctts_entries;
     uint32_t entries = 0;
@@ -682,7 +755,7 @@
 }
 
 /* Time to sample atom */
-static int mov_write_stts_tag(ByteIOContext *pb, MOVTrack* track)
+static int mov_write_stts_tag(ByteIOContext *pb, MOVTrack *track)
 {
     MOV_stts_t *stts_entries;
     uint32_t entries = -1;
@@ -737,7 +810,7 @@
     return 28;
 }
 
-static int mov_write_stbl_tag(ByteIOContext *pb, MOVTrack* track)
+static int mov_write_stbl_tag(ByteIOContext *pb, MOVTrack *track)
 {
     offset_t pos = url_ftell(pb);
     put_be32(pb, 0); /* size */
@@ -745,7 +818,7 @@
     mov_write_stsd_tag(pb, track);
     mov_write_stts_tag(pb, track);
     if (track-&gt;enc-&gt;codec_type == CODEC_TYPE_VIDEO &amp;&amp;
-        track-&gt;hasKeyframes &lt; track-&gt;entry)
+        track-&gt;hasKeyframes &amp;&amp; track-&gt;hasKeyframes &lt; track-&gt;entry)
         mov_write_stss_tag(pb, track);
     if (track-&gt;enc-&gt;codec_type == CODEC_TYPE_VIDEO &amp;&amp;
         track-&gt;hasBframes)
@@ -784,7 +857,7 @@
     return 0x14;
 }
 
-static int mov_write_hdlr_tag(ByteIOContext *pb, MOVTrack* track)
+static int mov_write_hdlr_tag(ByteIOContext *pb, MOVTrack *track)
 {
     const char *descr, *hdlr, *hdlr_type;
     offset_t pos = url_ftell(pb);
@@ -817,7 +890,7 @@
     return updateSize(pb, pos);
 }
 
-static int mov_write_minf_tag(ByteIOContext *pb, MOVTrack* track)
+static int mov_write_minf_tag(ByteIOContext *pb, MOVTrack *track)
 {
     offset_t pos = url_ftell(pb);
     put_be32(pb, 0); /* size */
@@ -833,7 +906,7 @@
     return updateSize(pb, pos);
 }
 
-static int mov_write_mdhd_tag(ByteIOContext *pb, MOVTrack* track)
+static int mov_write_mdhd_tag(ByteIOContext *pb, MOVTrack *track)
 {
     int version = track-&gt;trackDuration &lt; INT32_MAX ? 0 : 1;
 
@@ -863,7 +936,7 @@
     return 32;
 }
 
-static int mov_write_mdia_tag(ByteIOContext *pb, MOVTrack* track)
+static int mov_write_mdia_tag(ByteIOContext *pb, MOVTrack *track)
 {
     offset_t pos = url_ftell(pb);
     put_be32(pb, 0); /* size */
@@ -874,7 +947,7 @@
     return updateSize(pb, pos);
 }
 
-static int mov_write_tkhd_tag(ByteIOContext *pb, MOVTrack* track)
+static int mov_write_tkhd_tag(ByteIOContext *pb, MOVTrack *track, AVStream *st)
 {
     int64_t duration = av_rescale_rnd(track-&gt;trackDuration, globalTimescale, track-&gt;timescale, AV_ROUND_UP);
     int version = duration &lt; INT32_MAX ? 0 : 1;
@@ -941,11 +1014,8 @@
 
     put_be32(pb, av_rescale_rnd(track-&gt;trackDuration, globalTimescale, track-&gt;timescale, AV_ROUND_UP)); /* duration   ... doesn't seem to effect psp */
 
-    // MEANX NO put_be32(pb, track-&gt;cluster[0].cts); /* first pts is cts since dts is 0 */
-    // MEANX NO put_be32(pb, 0x00010000);
- put_be32(pb, 0x00000000);
- put_be32(pb, 0x00000001);
-
+    put_be32(pb, track-&gt;cluster[0].cts); /* first pts is cts since dts is 0 */
+    put_be32(pb, 0x00010000);
     return 0x24;
 }
 
@@ -968,12 +1038,12 @@
     return 0x34;
 }
 
-static int mov_write_trak_tag(ByteIOContext *pb, MOVTrack* track)
+static int mov_write_trak_tag(ByteIOContext *pb, MOVTrack *track, AVStream *st)
 {
     offset_t pos = url_ftell(pb);
     put_be32(pb, 0); /* size */
     put_tag(pb, &quot;trak&quot;);
-    mov_write_tkhd_tag(pb, track);
+    mov_write_tkhd_tag(pb, track, st);
     if (track-&gt;mode == MODE_PSP || track-&gt;hasBframes)
         mov_write_edts_tag(pb, track);  // PSP Movies require edts box
     mov_write_mdia_tag(pb, track);
@@ -1056,7 +1126,7 @@
     return 0x6c;
 }
 
-static int mov_write_itunes_hdlr_tag(ByteIOContext *pb, MOVContext* mov,
+static int mov_write_itunes_hdlr_tag(ByteIOContext *pb, MOVContext *mov,
                                      AVFormatContext *s)
 {
     offset_t pos = url_ftell(pb);
@@ -1115,7 +1185,7 @@
 }
 
 /* iTunes track number */
-static int mov_write_trkn_tag(ByteIOContext *pb, MOVContext* mov,
+static int mov_write_trkn_tag(ByteIOContext *pb, MOVContext *mov,
                               AVFormatContext *s)
 {
     int size = 0;
@@ -1141,7 +1211,7 @@
 }
 
 /* iTunes meta data list */
-static int mov_write_ilst_tag(ByteIOContext *pb, MOVContext* mov,
+static int mov_write_ilst_tag(ByteIOContext *pb, MOVContext *mov,
                               AVFormatContext *s)
 {
     offset_t pos = url_ftell(pb);
@@ -1152,23 +1222,23 @@
     mov_write_string_tag(pb, &quot;\251wrt&quot;, s-&gt;author        , 1);
     mov_write_string_tag(pb, &quot;\251alb&quot;, s-&gt;album         , 1);
     mov_write_day_tag(pb, s-&gt;year ,1);
-    if(mov-&gt;tracks[0].enc &amp;&amp; !(mov-&gt;tracks[0].enc-&gt;flags &amp; CODEC_FLAG_BITEXACT))
-        mov_write_string_tag(pb, &quot;\251too&quot;, LIBAVFORMAT_IDENT, 1);
+    mov_write_string_tag(pb, &quot;\251too&quot;, LIBAVFORMAT_IDENT, 1);
     mov_write_string_tag(pb, &quot;\251cmt&quot;, s-&gt;comment       , 1);
     mov_write_string_tag(pb, &quot;\251gen&quot;, s-&gt;genre         , 1);
+    mov_write_string_tag(pb, &quot;\251cpy&quot;, s-&gt;copyright     , 1);
     mov_write_trkn_tag(pb, mov, s);
     return updateSize(pb, pos);
 }
 
 /* iTunes meta data tag */
-static int mov_write_meta_tag(ByteIOContext *pb, MOVContext* mov,
+static int mov_write_meta_tag(ByteIOContext *pb, MOVContext *mov,
                               AVFormatContext *s)
 {
     int size = 0;
 
     // only save meta tag if required
     if (s-&gt;title[0] || s-&gt;author[0] || s-&gt;album[0] || s-&gt;year ||
-         s-&gt;comment[0] || s-&gt;genre[0] || s-&gt;track) {
+        s-&gt;comment[0] || s-&gt;genre[0] || s-&gt;track) {
         offset_t pos = url_ftell(pb);
         put_be32(pb, 0); /* size */
         put_tag(pb, &quot;meta&quot;);
@@ -1180,86 +1250,116 @@
     return size;
 }
 
-static int mov_write_udta_tag(ByteIOContext *pb, MOVContext* mov,
+static int utf8len(const uint8_t *b)
+{
+    int len=0;
+    int val;
+    while(*b){
+        GET_UTF8(val, *b++, return -1;)
+        len++;
+    }
+    return len;
+}
+
+static int ascii_to_wc(ByteIOContext *pb, const uint8_t *b)
+{
+    int val;
+    while(*b){
+        GET_UTF8(val, *b++, return -1;)
+        put_be16(pb, val);
+    }
+    put_be16(pb, 0x00);
+    return 0;
+}
+
+static uint16_t language_code(const char *str)
+{
+    return (((str[0]-0x60) &amp; 0x1F) &lt;&lt; 10) + (((str[1]-0x60) &amp; 0x1F) &lt;&lt; 5) + ((str[2]-0x60) &amp; 0x1F);
+}
+
+static int mov_write_3gp_udta_tag(ByteIOContext *pb, AVFormatContext *s,
+                                  const char *tag, const char *str)
+{
+    offset_t pos = url_ftell(pb);
+    if (!utf8len(str))
+        return 0;
+    put_be32(pb, 0);   /* size */
+    put_tag (pb, tag); /* type */
+    put_be32(pb, 0);   /* version + flags */
+    if (!strcmp(tag, &quot;yrrc&quot;))
+        put_be16(pb, s-&gt;year);
+    else {
+        put_be16(pb, language_code(&quot;eng&quot;)); /* language */
+        ascii_to_wc(pb, str);
+        if (!strcmp(tag, &quot;albm&quot;) &amp;&amp; s-&gt;year)
+            put_byte(pb, s-&gt;year);
+    }
+    return updateSize(pb, pos);
+}
+
+static int mov_write_udta_tag(ByteIOContext *pb, MOVContext *mov,
                               AVFormatContext *s)
 {
-    int i, req = 0;
+    int i;
+    int bitexact = 0;
 
-    /* Requirements */
-    for (i=0; i&lt;mov-&gt;nb_streams; i++) {
-        if(mov-&gt;tracks[i].entry &lt;= 0) continue;
-        if (mov-&gt;tracks[i].enc-&gt;codec_id == CODEC_ID_AAC ||
-            mov-&gt;tracks[i].enc-&gt;codec_id == CODEC_ID_MPEG4) {
-            req = 1;
+    for (i = 0; i &lt; s-&gt;nb_streams; i++)
+        if (mov-&gt;tracks[i].enc-&gt;flags &amp; CODEC_FLAG_BITEXACT) {
+            bitexact = 1;
             break;
         }
-    }
 
-    if (s-&gt;title[0]   || s-&gt;author[0] || s-&gt;album[0] || s-&gt;year ||
-        s-&gt;comment[0] || s-&gt;genre[0]  || s-&gt;track ||
-       (mov-&gt;mode == MODE_MOV &amp;&amp;
-      ((mov-&gt;tracks[0].enc &amp;&amp; !mov-&gt;tracks[0].enc-&gt;flags &amp; CODEC_FLAG_BITEXACT) || req))) {
+    if (!bitexact &amp;&amp; (s-&gt;title[0] || s-&gt;author[0] || s-&gt;album[0] || s-&gt;year ||
+                      s-&gt;comment[0] || s-&gt;genre[0]  || s-&gt;track)) {
         offset_t pos = url_ftell(pb);
 
         put_be32(pb, 0); /* size */
         put_tag(pb, &quot;udta&quot;);
 
-        /* iTunes meta data */
-        mov_write_meta_tag(pb, mov, s);
-
-        if(mov-&gt;mode == MODE_MOV){ // the title field breaks gtkpod with mp4 and my suspicion is that stuff is not valid in mp4
-            /* Requirements */
-            if (req)
-                mov_write_string_tag(pb, &quot;\251req&quot;, &quot;QuickTime 6.0 or greater&quot;, 0);
-
+        if (mov-&gt;mode &amp; MODE_3GP) {
+            mov_write_3gp_udta_tag(pb, s, &quot;titl&quot;, s-&gt;title);
+            mov_write_3gp_udta_tag(pb, s, &quot;auth&quot;, s-&gt;author);
+            mov_write_3gp_udta_tag(pb, s, &quot;gnre&quot;, s-&gt;genre);
+            mov_write_3gp_udta_tag(pb, s, &quot;dscp&quot;, s-&gt;comment);
+            mov_write_3gp_udta_tag(pb, s, &quot;albm&quot;, s-&gt;album);
+            mov_write_3gp_udta_tag(pb, s, &quot;cprt&quot;, s-&gt;copyright);
+            mov_write_3gp_udta_tag(pb, s, &quot;yrrc&quot;, &quot;nil&quot;);
+        } else if (mov-&gt;mode == MODE_MOV) { // the title field breaks gtkpod with mp4 and my suspicion is that stuff is not valid in mp4
             mov_write_string_tag(pb, &quot;\251nam&quot;, s-&gt;title         , 0);
             mov_write_string_tag(pb, &quot;\251aut&quot;, s-&gt;author        , 0);
             mov_write_string_tag(pb, &quot;\251alb&quot;, s-&gt;album         , 0);
             mov_write_day_tag(pb, s-&gt;year, 0);
-            if(mov-&gt;tracks[0].enc &amp;&amp; !(mov-&gt;tracks[0].enc-&gt;flags &amp; CODEC_FLAG_BITEXACT))
-                mov_write_string_tag(pb, &quot;\251enc&quot;, LIBAVFORMAT_IDENT, 0);
+            mov_write_string_tag(pb, &quot;\251enc&quot;, LIBAVFORMAT_IDENT, 0);
             mov_write_string_tag(pb, &quot;\251des&quot;, s-&gt;comment       , 0);
             mov_write_string_tag(pb, &quot;\251gen&quot;, s-&gt;genre         , 0);
+            mov_write_string_tag(pb, &quot;\251cpy&quot;, s-&gt;copyright     , 0);
+        } else {
+            /* iTunes meta data */
+            mov_write_meta_tag(pb, mov, s);
         }
-
         return updateSize(pb, pos);
     }
 
     return 0;
 }
 
-static int utf8len(const uint8_t *b){
-    int len=0;
-    int val;
-    while(*b){
-        GET_UTF8(val, *b++, return -1;)
-        len++;
-    }
-    return len;
-}
-
-static int ascii_to_wc (ByteIOContext *pb, const uint8_t *b)
+static void mov_write_psp_udta_tag(ByteIOContext *pb,
+                                  const char *str, const char *lang, int type)
 {
-    int val;
-    while(*b){
-        GET_UTF8(val, *b++, return -1;)
-        put_be16(pb, val);
-    }
-    put_be16(pb, 0x00);
-    return 0;
+    int len = utf8len(str)+1;
+    if(len&lt;=0)
+        return;
+    put_be16(pb, len*2+10);            /* size */
+    put_be32(pb, type);                /* type */
+    put_be16(pb, language_code(lang)); /* language */
+    put_be16(pb, 0x01);                /* ? */
+    ascii_to_wc(pb, str);
 }
 
-static uint16_t language_code (const char *str)
+static int mov_write_uuidusmt_tag(ByteIOContext *pb, AVFormatContext *s)
 {
-    return ((((str[0]-0x60) &amp; 0x1F)&lt;&lt;10) + (((str[1]-0x60) &amp; 0x1F)&lt;&lt;5) + ((str[2]-0x60) &amp; 0x1F));
-}
+    offset_t pos, pos2;
 
-static int mov_write_uuidusmt_tag (ByteIOContext *pb, AVFormatContext *s)
-{
-    size_t len, size;
-    offset_t pos, curpos;
-
-    size = 0;
     if (s-&gt;title[0]) {
         pos = url_ftell(pb);
         put_be32(pb, 0); /* size placeholder*/
@@ -1268,12 +1368,11 @@
         put_be32(pb, 0x21d24fce); /* 96 bit UUID */
         put_be32(pb, 0xbb88695c);
         put_be32(pb, 0xfac9c740);
-        size += 24;
 
+        pos2 = url_ftell(pb);
         put_be32(pb, 0); /* size placeholder*/
         put_tag(pb, &quot;MTDT&quot;);
         put_be16(pb, 4);
-        size += 10;
 
         // ?
         put_be16(pb, 0x0C);                 /* size */
@@ -1281,55 +1380,17 @@
         put_be16(pb, language_code(&quot;und&quot;)); /* language */
         put_be16(pb, 0x0);                  /* ? */
         put_be16(pb, 0x021C);               /* data */
-        size += 12;
 
-        // Encoder
-        len = utf8len(LIBAVCODEC_IDENT)+1;
-        if(len&lt;=0)
-            goto not_utf8;
-        put_be16(pb, len*2+10);             /* size */
-        put_be32(pb, 0x04);                 /* type */
-        put_be16(pb, language_code(&quot;eng&quot;)); /* language */
-        put_be16(pb, 0x01);                 /* ? */
-        ascii_to_wc(pb, LIBAVCODEC_IDENT);
-        size += len*2+10;
-
-        // Title
-        len = utf8len(s-&gt;title)+1;
-        if(len&lt;=0)
-            goto not_utf8;
-        put_be16(pb, len*2+10);             /* size */
-        put_be32(pb, 0x01);                 /* type */
-        put_be16(pb, language_code(&quot;eng&quot;)); /* language */
-        put_be16(pb, 0x01);                 /* ? */
-        ascii_to_wc (pb, s-&gt;title);
-        size += len*2+10;
-
-        // Date
+        mov_write_psp_udta_tag(pb, LIBAVCODEC_IDENT,      &quot;eng&quot;, 0x04);
+        mov_write_psp_udta_tag(pb, s-&gt;title,              &quot;eng&quot;, 0x01);
 //        snprintf(dt,32,&quot;%04d/%02d/%02d %02d:%02d:%02d&quot;,t_st-&gt;tm_year+1900,t_st-&gt;tm_mon+1,t_st-&gt;tm_mday,t_st-&gt;tm_hour,t_st-&gt;tm_min,t_st-&gt;tm_sec);
-        len = utf8len(&quot;2006/04/01 11:11:11&quot;)+1;
-        if(len&lt;=0)
-            goto not_utf8;
-        put_be16(pb, len*2+10);    /* size */
-        put_be32(pb, 0x03);        /* type */
-        put_be16(pb, language_code(&quot;und&quot;)); /* language */
-        put_be16(pb, 0x01);        /* ? */
-        ascii_to_wc (pb, &quot;2006/04/01 11:11:11&quot;);
-        size += len*2+10;
+        mov_write_psp_udta_tag(pb, &quot;2006/04/01 11:11:11&quot;, &quot;und&quot;, 0x03);
 
-        // size
-        curpos = url_ftell(pb);
-        url_fseek(pb, pos, SEEK_SET);
-        put_be32(pb, size);
-        url_fseek(pb, pos+24, SEEK_SET);
-        put_be32(pb, size-24);
-        url_fseek(pb, curpos, SEEK_SET);
+        updateSize(pb, pos2);
+        return updateSize(pb, pos);
     }
 
-    return size;
-not_utf8:
-    av_log(s, AV_LOG_ERROR, &quot;not utf8\n&quot;);
-    return -1;
+    return 0;
 }
 
 static int mov_write_moov_tag(ByteIOContext *pb, MOVContext *mov,
@@ -1352,19 +1413,19 @@
     //mov_write_iods_tag(pb, mov);
     for (i=0; i&lt;mov-&gt;nb_streams; i++) {
         if(mov-&gt;tracks[i].entry &gt; 0) {
-            mov_write_trak_tag(pb, &amp;(mov-&gt;tracks[i]));
+            mov_write_trak_tag(pb, &amp;(mov-&gt;tracks[i]), s-&gt;streams[i]);
         }
     }
 
     if (mov-&gt;mode == MODE_PSP)
         mov_write_uuidusmt_tag(pb, s);
-    else if (mov-&gt;mode != MODE_3GP &amp;&amp; mov-&gt;mode != MODE_3G2)
+    else
         mov_write_udta_tag(pb, mov, s);
 
     return updateSize(pb, pos);
 }
 
-static int mov_write_mdat_tag(ByteIOContext *pb, MOVContext* mov)
+static int mov_write_mdat_tag(ByteIOContext *pb, MOVContext *mov)
 {
     put_be32(pb, 8);    // placeholder for extended size field (64 bit)
     put_tag(pb, mov-&gt;mode == MODE_MOV ? &quot;wide&quot; : &quot;free&quot;);
@@ -1376,36 +1437,60 @@
 }
 
 /* TODO: This needs to be more general */
-static void mov_write_ftyp_tag (ByteIOContext *pb, AVFormatContext *s)
+static int mov_write_ftyp_tag(ByteIOContext *pb, AVFormatContext *s)
 {
     MOVContext *mov = s-&gt;priv_data;
+    offset_t pos = url_ftell(pb);
+    int has_h264 = 0, has_video = 0;
+    int minor = 0x200;
+    int i;
 
-    put_be32(pb, 0x14); /* size */
+    for (i = 0; i &lt; s-&gt;nb_streams; i++) {
+        AVStream *st = s-&gt;streams[i];
+        if (st-&gt;codec-&gt;codec_type == CODEC_TYPE_VIDEO)
+            has_video = 1;
+        if (st-&gt;codec-&gt;codec_id == CODEC_ID_H264)
+            has_h264 = 1;
+    }
+
+    put_be32(pb, 0); /* size */
     put_tag(pb, &quot;ftyp&quot;);
 
-    if (mov-&gt;mode == MODE_3GP)
-        put_tag(pb, &quot;3gp4&quot;);
-    else if (mov-&gt;mode == MODE_3G2)
-        put_tag(pb, &quot;3g2a&quot;);
-    else if (mov-&gt;mode == MODE_PSP)
+    if (mov-&gt;mode == MODE_3GP) {
+        put_tag(pb, has_h264 ? &quot;3gp6&quot;  : &quot;3gp4&quot;);
+        minor =     has_h264 ?   0x100 :   0x200;
+    } else if (mov-&gt;mode &amp; MODE_3G2) {
+        put_tag(pb, has_h264 ? &quot;3g2b&quot;  : &quot;3g2a&quot;);
+        minor =     has_h264 ? 0x20000 : 0x10000;
+    }else if (mov-&gt;mode == MODE_PSP)
         put_tag(pb, &quot;MSNV&quot;);
-    else if (mov-&gt;mode == MODE_MP4 || mov-&gt;mode == MODE_IPOD)
+    else if (mov-&gt;mode == MODE_MP4)
         put_tag(pb, &quot;isom&quot;);
+    else if (mov-&gt;mode == MODE_IPOD)
+        put_tag(pb, has_video ? &quot;M4V &quot;:&quot;M4A &quot;);
     else
         put_tag(pb, &quot;qt  &quot;);
 
-    put_be32(pb, 0x200);
+    put_be32(pb, minor);
 
+    if(mov-&gt;mode == MODE_MOV)
+        put_tag(pb, &quot;qt  &quot;);
+    else{
+        put_tag(pb, &quot;isom&quot;);
+        put_tag(pb, &quot;iso2&quot;);
+        if(has_h264)
+            put_tag(pb, &quot;avc1&quot;);
+    }
+
     if (mov-&gt;mode == MODE_3GP)
-        put_tag(pb, &quot;3gp4&quot;);
-    else if (mov-&gt;mode == MODE_3G2)
-        put_tag(pb, &quot;3g2a&quot;);
+        put_tag(pb, has_h264 ? &quot;3gp6&quot;:&quot;3gp4&quot;);
+    else if (mov-&gt;mode &amp; MODE_3G2)
+        put_tag(pb, has_h264 ? &quot;3g2b&quot;:&quot;3g2a&quot;);
     else if (mov-&gt;mode == MODE_PSP)
         put_tag(pb, &quot;MSNV&quot;);
-    else if (mov-&gt;mode == MODE_MP4 || mov-&gt;mode == MODE_IPOD)
+    else if (mov-&gt;mode == MODE_MP4)
         put_tag(pb, &quot;mp41&quot;);
-    else
-        put_tag(pb, &quot;qt  &quot;);
+    return updateSize(pb, pos);
 }
 
 static void mov_write_uuidprof_tag(ByteIOContext *pb, AVFormatContext *s)
@@ -1485,7 +1570,7 @@
 
     if (s-&gt;oformat != NULL) {
         if (!strcmp(&quot;3gp&quot;, s-&gt;oformat-&gt;name)) mov-&gt;mode = MODE_3GP;
-        else if (!strcmp(&quot;3g2&quot;, s-&gt;oformat-&gt;name)) mov-&gt;mode = MODE_3G2;
+        else if (!strcmp(&quot;3g2&quot;, s-&gt;oformat-&gt;name)) mov-&gt;mode = MODE_3GP|MODE_3G2;
         else if (!strcmp(&quot;mov&quot;, s-&gt;oformat-&gt;name)) mov-&gt;mode = MODE_MOV;
         else if (!strcmp(&quot;psp&quot;, s-&gt;oformat-&gt;name)) mov-&gt;mode = MODE_PSP;
         else if (!strcmp(&quot;ipod&quot;,s-&gt;oformat-&gt;name)) mov-&gt;mode = MODE_IPOD;
@@ -1509,7 +1594,8 @@
         track-&gt;mode = mov-&gt;mode;
         track-&gt;tag = mov_find_codec_tag(s, track);
         if (!track-&gt;tag) {
-            av_log(s, AV_LOG_ERROR, &quot;track %d: could not find tag for codec\n&quot;, i);
+            av_log(s, AV_LOG_ERROR, &quot;track %d: could not find tag, &quot;
+                   &quot;codec not currently supported in container\n&quot;, i);
             return -1;
         }
         if(st-&gt;codec-&gt;codec_type == CODEC_TYPE_VIDEO){
@@ -1523,14 +1609,21 @@
         }else if(st-&gt;codec-&gt;codec_type == CODEC_TYPE_AUDIO){
             track-&gt;timescale = st-&gt;codec-&gt;sample_rate;
             av_set_pts_info(st, 64, 1, st-&gt;codec-&gt;sample_rate);
-            if(!st-&gt;codec-&gt;frame_size){
+            if(!st-&gt;codec-&gt;frame_size &amp;&amp; !av_get_bits_per_sample(st-&gt;codec-&gt;codec_id)) {
                 av_log(s, AV_LOG_ERROR, &quot;track %d: codec frame size is not set\n&quot;, i);
                 return -1;
             }else if(st-&gt;codec-&gt;frame_size &gt; 1){ /* assume compressed audio */
                 track-&gt;audio_vbr = 1;
             }else{
+                st-&gt;codec-&gt;frame_size = 1;
                 track-&gt;sampleSize = (av_get_bits_per_sample(st-&gt;codec-&gt;codec_id) &gt;&gt; 3) * st-&gt;codec-&gt;channels;
             }
+            if(track-&gt;mode != MODE_MOV &amp;&amp;
+               track-&gt;enc-&gt;codec_id == CODEC_ID_MP3 &amp;&amp; track-&gt;enc-&gt;sample_rate &lt; 16000){
+                av_log(s, AV_LOG_ERROR, &quot;track %d: muxing mp3 at %dhz is not supported\n&quot;,
+                       i, track-&gt;enc-&gt;sample_rate);
+                return -1;
+            }
         }
     }
 
@@ -1589,13 +1682,14 @@
             return ret;
         assert(pkt-&gt;size);
         size = pkt-&gt;size;
-    } else if (enc-&gt;codec_id == CODEC_ID_DNXHD &amp;&amp; !trk-&gt;vosLen) {
-        /* copy frame header to create needed atoms */
-        if (size &lt; 640)
-            return -1;
-        trk-&gt;vosLen = 640;
-        trk-&gt;vosData = av_malloc(trk-&gt;vosLen);
-        memcpy(trk-&gt;vosData, pkt-&gt;data, 640);
+    } else if ((enc-&gt;codec_id == CODEC_ID_DNXHD ||
+                enc-&gt;codec_id == CODEC_ID_AC3) &amp;&amp; !trk-&gt;vosLen) {
+        /* copy frame to create needed atoms */
+        trk-&gt;vosLen = size;
+        trk-&gt;vosData = av_malloc(size);
+        if (!trk-&gt;vosData)
+            return AVERROR(ENOMEM);
+        memcpy(trk-&gt;vosData, pkt-&gt;data, size);
     }
 
     if (!(trk-&gt;entry % MOV_INDEX_CLUSTER_SIZE)) {
@@ -1611,14 +1705,16 @@
     trk-&gt;cluster[trk-&gt;entry].dts = pkt-&gt;dts;
     trk-&gt;trackDuration = pkt-&gt;dts - trk-&gt;cluster[0].dts + pkt-&gt;duration;
 
-    if(enc-&gt;codec_type == CODEC_TYPE_VIDEO) {
-        if (pkt-&gt;dts != pkt-&gt;pts)
-            trk-&gt;hasBframes = 1;
-        trk-&gt;cluster[trk-&gt;entry].cts = pkt-&gt;pts - pkt-&gt;dts;
-        trk-&gt;cluster[trk-&gt;entry].key_frame = !!(pkt-&gt;flags &amp; PKT_FLAG_KEY);
-        if(trk-&gt;cluster[trk-&gt;entry].key_frame)
-            trk-&gt;hasKeyframes++;
+    if (pkt-&gt;pts == AV_NOPTS_VALUE) {
+        av_log(s, AV_LOG_WARNING, &quot;pts has no value\n&quot;);
+        pkt-&gt;pts = pkt-&gt;dts;
     }
+    if (pkt-&gt;dts != pkt-&gt;pts)
+        trk-&gt;hasBframes = 1;
+    trk-&gt;cluster[trk-&gt;entry].cts = pkt-&gt;pts - pkt-&gt;dts;
+    trk-&gt;cluster[trk-&gt;entry].key_frame = !!(pkt-&gt;flags &amp; PKT_FLAG_KEY);
+    if(trk-&gt;cluster[trk-&gt;entry].key_frame)
+        trk-&gt;hasKeyframes++;
     trk-&gt;entry++;
     trk-&gt;sampleCount += samplesInChunk;
     mov-&gt;mdat_size += size;
@@ -1668,7 +1764,7 @@
 #ifdef CONFIG_MOV_MUXER
 AVOutputFormat mov_muxer = {
     &quot;mov&quot;,
-    &quot;mov format&quot;,
+    &quot;MOV format&quot;,
     NULL,
     &quot;mov&quot;,
     sizeof(MOVContext),
@@ -1684,7 +1780,7 @@
 #ifdef CONFIG_TGP_MUXER
 AVOutputFormat tgp_muxer = {
     &quot;3gp&quot;,
-    &quot;3gp format&quot;,
+    &quot;3GP format&quot;,
     NULL,
     &quot;3gp&quot;,
     sizeof(MOVContext),
@@ -1700,9 +1796,9 @@
 #ifdef CONFIG_MP4_MUXER
 AVOutputFormat mp4_muxer = {
     &quot;mp4&quot;,
-    &quot;mp4 format&quot;,
+    &quot;MP4 format&quot;,
     &quot;application/mp4&quot;,
-    &quot;mp4,m4a&quot;,
+    &quot;mp4&quot;,
     sizeof(MOVContext),
     CODEC_ID_AAC,
     CODEC_ID_MPEG4,
@@ -1716,7 +1812,7 @@
 #ifdef CONFIG_PSP_MUXER
 AVOutputFormat psp_muxer = {
     &quot;psp&quot;,
-    &quot;psp mp4 format&quot;,
+    &quot;PSP MP4 format&quot;,
     NULL,
     &quot;mp4,psp&quot;,
     sizeof(MOVContext),
@@ -1732,7 +1828,7 @@
 #ifdef CONFIG_TG2_MUXER
 AVOutputFormat tg2_muxer = {
     &quot;3g2&quot;,
-    &quot;3gp2 format&quot;,
+    &quot;3GP2 format&quot;,
     NULL,
     &quot;3g2&quot;,
     sizeof(MOVContext),
@@ -1748,9 +1844,9 @@
 #ifdef CONFIG_IPOD_MUXER
 AVOutputFormat ipod_muxer = {
     &quot;ipod&quot;,
-    &quot;iPod H.264 mp4 format&quot;,
+    &quot;iPod H.264 MP4 format&quot;,
     &quot;application/mp4&quot;,
-    NULL,
+    &quot;m4v,m4a&quot;,
     sizeof(MOVContext),
     CODEC_ID_AAC,
     CODEC_ID_H264,
@@ -1769,7 +1865,7 @@
     av_register_output_format(&amp;mp4_muxer);
     av_register_output_format(&amp;psp_muxer);
     av_register_output_format(&amp;tg2_muxer);
-    // FIXME av_register_output_format(&amp;ipod_muxer);
+    av_register_output_format(&amp;ipod_muxer);
     return 0;
 }
 /* MEANX */

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_libraries/ADM_ffmpeg/config.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_libraries/ADM_ffmpeg/config.h	2008-09-20 15:21:58 UTC (rev 4383)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_libraries/ADM_ffmpeg/config.h	2008-09-20 15:51:36 UTC (rev 4384)
@@ -326,6 +326,7 @@
 #define CONFIG_PSP_MUXER 1
 #define CONFIG_TG2_MUXER 1
 #define CONFIG_TGP_MUXER 1
+#define CONFIG_IPOD_MUXER 1
 #define CONFIG_ENCODERS 1
 #define CONFIG_DVVIDEO_ENCODER 1
 #define CONFIG_SNOW_ENCODER 1

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_libraries/ADM_utilities/ADM_bitstream.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_libraries/ADM_utilities/ADM_bitstream.cpp	2008-09-20 15:21:58 UTC (rev 4383)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_libraries/ADM_utilities/ADM_bitstream.cpp	2008-09-20 15:51:36 UTC (rev 4384)
@@ -38,5 +38,6 @@
     flags=0;
     len=0;
     dtsFrame=framenum;
+	frameNumber=framenum;
 }
 

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_libraries/ADM_utilities/ADM_bitstream.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_libraries/ADM_utilities/ADM_bitstream.h	2008-09-20 15:21:58 UTC (rev 4383)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_libraries/ADM_utilities/ADM_bitstream.h	2008-09-20 15:51:36 UTC (rev 4384)
@@ -19,6 +19,7 @@
         uint32_t out_quantizer;         // Quantizer of the image, in case of encoding the real Q
         uint32_t ptsFrame;              // Frame number in display order
         uint32_t dtsFrame;              // Frame number in container order (decoding order)
+		uint32_t frameNumber;
         uint64_t pts;			// in ms
         uint64_t dts;			// in ms
 

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_outputs/ADM_lavformat.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_outputs/ADM_lavformat.cpp	2008-09-20 15:21:58 UTC (rev 4383)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_outputs/ADM_lavformat.cpp	2008-09-20 15:51:36 UTC (rev 4384)
@@ -18,8 +18,9 @@
  *                                                                         *
  ***************************************************************************/
 
-#include &quot;config.h&quot;
+#define __STDC_LIMIT_MACROS
 
+#include &quot;config.h&quot;
 #include &lt;stdio.h&gt;
 #include &lt;stdlib.h&gt;
 #include &lt;math.h&gt;
@@ -166,6 +167,10 @@
 	}
 
 	c = video_st-&gt;codec;
+	c-&gt;gop_size=15;
+	c-&gt;max_b_frames=2;
+	c-&gt;has_b_frames=1;
+
 	switch(_type)
 	{
 				case MUXER_FLV:
@@ -196,12 +201,11 @@
                         if(isMpeg4Compatible(info-&gt;fcc))
                         {
                                 c-&gt;codec_id = CODEC_ID_MPEG4;
-                                c-&gt;has_b_frames=1; // in doubt...
                         }else
                         {
                                 if(isH264Compatible(info-&gt;fcc))
                                 {
-                                        c-&gt;has_b_frames=1; // in doubt...
+                                        c-&gt;has_b_frames=2; // let muxer know we may have bpyramid
                                         c-&gt;codec_id = CODEC_ID_H264;
                                         c-&gt;codec=new AVCodec;
                                         memset(c-&gt;codec,0,sizeof(AVCodec));
@@ -228,7 +232,7 @@
                 {
                         // probably a memeleak here
                         char *foo=ADM_strdup(filename);
-                        
+
                         strcpy(oc-&gt;title,ADM_GetFileName(foo));
                         strcpy(oc-&gt;author,&quot;Avidemux&quot;);
                         c-&gt;sample_aspect_ratio.num=1;
@@ -236,12 +240,11 @@
                         if(isMpeg4Compatible(info-&gt;fcc))
                         {
                                 c-&gt;codec_id = CODEC_ID_MPEG4;
-                                c-&gt;has_b_frames=1; // in doubt...
                         }else
                         {
                                 if(isH264Compatible(info-&gt;fcc))
                                 {
-                                        c-&gt;has_b_frames=1; // in doubt...
+                                        c-&gt;has_b_frames=2; // let muxer know we may have bpyramid
                                         c-&gt;codec_id = CODEC_ID_H264;
                                         c-&gt;codec=new AVCodec;
                                         memset(c-&gt;codec,0,sizeof(AVCodec));
@@ -383,11 +386,6 @@
 	}
 
 
-	c-&gt;gop_size=15;
-	c-&gt;max_b_frames=2;
-	c-&gt;has_b_frames=1;
-
-
 	// Audio
 	//________
         if(audioheader)
@@ -605,54 +603,42 @@
 //___________________________________________________________________________
 uint8_t lavMuxer::writeVideoPacket(ADMBitstream *bitstream)
 {
-int ret;
+	int ret;
+	AVPacket pkt;
+	AVRational fps = {1, 1000000};
+	uint32_t ptsFrame = bitstream-&gt;ptsFrame + 1;
 
-double p,d;
-  	AVPacket pkt;
-            av_init_packet(&amp;pkt);
+	av_init_packet(&amp;pkt);
 
-        p=bitstream-&gt;ptsFrame+1;      // Pts           // Time p/fps1000=out/den  out=p*den*1000/fps1000
-        p=(p*1000*1000*1000);
-        p=p/_fps1000;                  // in us
+	_curDTS = av_rescale_q(bitstream-&gt;frameNumber, video_st-&gt;codec-&gt;time_base, fps);
 
-        d=bitstream-&gt;dtsFrame;		// dts
-	d=(d*1000*1000*1000);
-	d=d/_fps1000;
+	switch (_type)
+	{
+		case MUXER_FLV:
+		case MUXER_MATROSKA:
+		{
+			fps.den = 1000;
+			break;
+		}
+		case MUXER_MP4:
+		{
+			ptsFrame = bitstream-&gt;ptsFrame;
+			// break is missing on purpose!
+		}
+		default:
+		{
+			fps.den = video_st-&gt;codec-&gt;time_base.den;
+			break;
+		}
+	}
 
+	pkt.pts = av_rescale_q(ptsFrame, video_st-&gt;codec-&gt;time_base, fps);
 
-	_curDTS=(int64_t)floor(d);
-    aprintf(&quot;Adm video unscaled dts=:%u\n&quot;,(uint32_t)d);
-        // Rescale
-#define RESCALE(x) x=x*1000.;\
-                   x=x/_fps1000;
+	if (bitstream-&gt;dtsFrame != UINT32_MAX)
+		pkt.dts = av_rescale_q(bitstream-&gt;dtsFrame, video_st-&gt;codec-&gt;time_base, fps);
 
-        p=bitstream-&gt;ptsFrame+1;
-        RESCALE(p);
-// MP4/ TS
-        d=bitstream-&gt;dtsFrame;  // p &amp; d are now in seconds
-        RESCALE(d);
-        switch(_type)  // video_st-&gt;codec-&gt;time_base.den
-        {
-        case MUXER_FLV :
-        case MUXER_MATROSKA:
-                    {
-                        p=p*1000;
-                        d=d*1000; // in milliseconds
-                        break;
-                    }
-        
-        default:
-                    p=p*video_st-&gt;codec-&gt;time_base.den;
-                    d=d*video_st-&gt;codec-&gt;time_base.den;
-                    break;
-        }
-    	pkt.dts=(int64_t)floor(d);
-    	pkt.pts=(int64_t)floor(p);
+	pkt.stream_index = 0;
 
-       // printf(&quot;Lavformat : Pts :%u dts:%u&quot;,displayframe,frameno);
-	aprintf(&quot;Lavformat : Pts :%llu dts:%llu&quot;,pkt.pts,pkt.dts);
-	pkt.stream_index=0;
-
         pkt.data= bitstream-&gt;data;
         pkt.size= bitstream-&gt;len;
 	// Look if it is a gop start or seq start

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_outputs/oplug_avi/op_saveprocess.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_outputs/oplug_avi/op_saveprocess.cpp	2008-09-20 15:21:58 UTC (rev 4383)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_outputs/oplug_avi/op_saveprocess.cpp	2008-09-20 15:51:36 UTC (rev 4384)
@@ -53,6 +53,7 @@
 	_incoming=NULL;
 	_encode=NULL;
 	_videoProcess=1;
+	_prefill=0;
 };
 
 uint8_t
@@ -123,6 +124,7 @@
     {
       uint8_t *buffer;
       uint32_t len, flag;
+	int prefill = 0, r;
 
  	aprintf(&quot;\n** Dual pass encoding**\n&quot;);
 
@@ -135,12 +137,32 @@
 		    _incoming-&gt;getInfo ()-&gt;height * 3];
 
       	_encode-&gt;startPass1 ();
+
+        bitstream.bufferSize = _incoming-&gt;getInfo()-&gt;width * _incoming-&gt;getInfo()-&gt;height * 3;
+        bitstream.data=buffer;
+
+preFilling:
+		bitstream.cleanup(0);
+
+		if(!_encode-&gt;encode(prefill, &amp;bitstream))
+		{
+			printf(&quot;AVI: First frame error\n&quot;);
+			GUI_Error_HIG(QT_TR_NOOP(&quot;Error while encoding&quot;), NULL);
+			return 0;
+		}
+
+		if (!bitstream.len)
+		{
+			prefill++;
+			goto preFilling;
+		}
+
+		printf(&quot;Prefill: %u\n&quot;, prefill);
+
       //__________________________________
       //   now go to main loop.....
       //__________________________________
-        bitstream.bufferSize=_incoming-&gt;getInfo ()-&gt;width *   _incoming-&gt;getInfo ()-&gt;height * 3;
-        bitstream.data=buffer;
-        for (uint32_t cf = 0; cf &lt; frametogo; cf++)
+        for (uint32_t cf = 1; cf &lt; frametogo; cf++)
         {
           if (guiUpdate (cf, frametogo))
             {
@@ -151,11 +173,18 @@
             }
             
             bitstream.cleanup(cf);
-            if (!_encode-&gt;encode (cf, &amp;bitstream))
-                {
-                        printf(&quot;\n Encoding of frame %lu failed !\n&quot;,cf);
-                        goto abt;
-                }
+
+			if (!prefill || cf + prefill &lt; frametogo)
+				r = _encode-&gt;encode(prefill + cf, &amp;bitstream);
+			else
+				r = _encode-&gt;encode(frametogo - 1, &amp;bitstream);
+
+			if (!r)
+			{
+				printf(&quot;Encoding of frame %lu failed!\n&quot;, cf);
+				goto abt;
+			}
+
            encoding_gui-&gt;setFrame(cf,bitstream.len,bitstream.out_quantizer,frametogo);
     
         }
@@ -232,7 +261,7 @@
 uint8_t
 GenericAviSaveProcess::writeVideoChunk (uint32_t frame)
 {
-  uint8_t    	ret1;
+  uint8_t    	r;
   // CBR or CQ
   if (frame == 0)
   {
@@ -247,11 +276,28 @@
         }
   }
   // first read
-  bitstream.cleanup(frame);
-  ret1 = _encode-&gt;encode ( frame,&amp;bitstream);// &amp;len1, vbuffer, &amp;_videoFlag);
+
+preFilling:
+  bitstream.cleanup(0);
+
+  if (!_prefill || frame + _prefill &lt; frametogo) 
+	  r = _encode-&gt;encode(_prefill + frame, &amp;bitstream);
+  else
+	  r = _encode-&gt;encode(frametogo - 1, &amp;bitstream);
+
+  if (!r)
+	  return 0;
+
+  if (!bitstream.len &amp;&amp; frame == 0)
+  {
+	  _prefill++;
+	  goto preFilling;
+  }
+  else if (frame == 0)
+	  printf(&quot;Prefill: %u\n&quot;, _prefill);
+
   _videoFlag=bitstream.flags;
-  if (!ret1)
-    return 0;
+
   // check for split
      // check for auto split
       // if so, we re-write the last I frame

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_outputs/oplug_avi/op_saveprocess.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_outputs/oplug_avi/op_saveprocess.h	2008-09-20 15:21:58 UTC (rev 4383)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_outputs/oplug_avi/op_saveprocess.h	2008-09-20 15:51:36 UTC (rev 4384)
@@ -26,6 +26,7 @@
 					    
 			Encoder 	*_encode;
 			uint8_t		_notnull;
+			int _prefill;
                        	char 		*TwoPassLogFile;
                         ADMBitstream    bitstream;
 

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_outputs/oplug_mp4/oplug_mp4.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_outputs/oplug_mp4/oplug_mp4.cpp	2008-09-20 15:21:58 UTC (rev 4383)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_outputs/oplug_mp4/oplug_mp4.cpp	2008-09-20 15:51:36 UTC (rev 4384)
@@ -18,6 +18,10 @@
  *   (at your option) any later version.                                   *
  *                                                                         *
  ***************************************************************************/
+#ifndef __STDC_LIMIT_MACROS
+#define __STDC_LIMIT_MACROS
+#endif
+
 #include &quot;config.h&quot;
 #include &quot;ADM_default.h&quot;
 #include &quot;ADM_threads.h&quot;
@@ -213,6 +217,8 @@
              
 preFilling:
              bitstream.cleanup(0);
+			 bitstream.dtsFrame = UINT32_MAX;	// let libavformat calculate it
+
              if(!(err=_encode-&gt;encode ( prefill, &amp;bitstream)))//&amp;len, videoBuffer, &amp;flags,&amp;displayFrame))
              {
                         printf(&quot;MP4:First frame error\n&quot;);
@@ -343,6 +349,8 @@
                }
                ADM_assert(_encode);
                bitstream.cleanup(frameWrite);
+			   bitstream.dtsFrame = UINT32_MAX;	// let libavformat calculate it
+
                if(!prefill || frame+prefill&lt;total) 
                {
                   


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001623.html">[Avidemux-svn-commit] r4383 - in	branches/avidemux_2.5_branch_gruntster: avidemux/ADM_UIs/ADM_QT4/src	avidemux/ADM_userInterfaces/ADM_GTK/ADM_gui2	avidemux/ADM_userInterfaces/ADM_GTK/glade	avidemux/ADM_userInterfaces/ADM_QT4/ADM_gui	avidemux/ADM_userInterfaces/ADM_commonUI	plugins/ADM_videoEncoder/ADM_vidEnc_x264	plugins/ADM_videoEncoder/ADM_vidEnc_x264/xml	plugins/ADM_videoFilters/ASharp/qt4
</A></li>
	<LI>Next message: <A HREF="001625.html">[Avidemux-svn-commit] r4385 - in	branches/avidemux_2.5_branch_gruntster: avidemux/ADM_codecs	avidemux/ADM_encoder avidemux/ADM_outputs/oplug_avi	avidemux/ADM_outputs/oplug_dummy	avidemux/ADM_outputs/oplug_flv avidemux/ADM_outputs/oplug_mp4	avidemux/ADM_outputs/oplug_ogm	avidemux/ADM_userInterfaces/ADM_QT4/ADM_filters po
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1624">[ date ]</a>
              <a href="thread.html#1624">[ thread ]</a>
              <a href="subject.html#1624">[ subject ]</a>
              <a href="author.html#1624">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">More information about the Avidemux-svn-commit
mailing list</a><br>
</body></html>
