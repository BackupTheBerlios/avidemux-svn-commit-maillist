<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Avidemux-svn-commit] r4360 - in branches/avidemux_2.4_branch: .	avidemux/ADM_libraries/ADM_lavformat cmake
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/avidemux-svn-commit/2008-September/index.html" >
   <LINK REL="made" HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r4360%20-%20in%20branches/avidemux_2.4_branch%3A%20.%0A%09avidemux/ADM_libraries/ADM_lavformat%20cmake&In-Reply-To=%3C200809181421.m8IEL9Jv009519%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001599.html">
   <LINK REL="Next"  HREF="001601.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Avidemux-svn-commit] r4360 - in branches/avidemux_2.4_branch: .	avidemux/ADM_libraries/ADM_lavformat cmake</H1>
    <B>gruntster at mail.berlios.de</B> 
    <A HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r4360%20-%20in%20branches/avidemux_2.4_branch%3A%20.%0A%09avidemux/ADM_libraries/ADM_lavformat%20cmake&In-Reply-To=%3C200809181421.m8IEL9Jv009519%40sheep.berlios.de%3E"
       TITLE="[Avidemux-svn-commit] r4360 - in branches/avidemux_2.4_branch: .	avidemux/ADM_libraries/ADM_lavformat cmake">gruntster at mail.berlios.de
       </A><BR>
    <I>Thu Sep 18 16:21:09 CEST 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="001599.html">[Avidemux-svn-commit] r4359 -	branches/avidemux_2.4_branch/avidemux/ADM_encoder
</A></li>
        <LI>Next message: <A HREF="001601.html">[Avidemux-svn-commit] r4361 -	branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1600">[ date ]</a>
              <a href="thread.html#1600">[ thread ]</a>
              <a href="subject.html#1600">[ subject ]</a>
              <a href="author.html#1600">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: gruntster
Date: 2008-09-18 16:21:01 +0200 (Thu, 18 Sep 2008)
New Revision: 4360

Added:
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/avc.c
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/avc.h
Modified:
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/CMakeLists.txt
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/Makefile.am
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/movenc.c
   branches/avidemux_2.4_branch/cmake/lavcodec.cmake
   branches/avidemux_2.4_branch/config.h.cmake
Log:
[mp4] update mp4 muxer (ffmpeg r15276)

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/CMakeLists.txt
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/CMakeLists.txt	2008-09-18 13:38:09 UTC (rev 4359)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/CMakeLists.txt	2008-09-18 14:21:01 UTC (rev 4360)
@@ -8,7 +8,7 @@
  mpeg.c utils.c avio.c ADM_lavformat.cpp 
 aviobuf.c cutils.c img2.c file.c mpegtsenc.c ADM_muxts.cpp movenc.c 
 avienc.c wav.c mov.c matroska.c isom.c isom.h riff.c
-flvenc.c matroskaenc.c
+flvenc.c matroskaenc.c avc.c
 )
 ADD_LIBRARY(${ADM_LIB} STATIC ${${ADM_LIB}_SRCS})
 ADD_ADM_LIB(${ADM_LIB} ADM_libraries)

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/Makefile.am
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/Makefile.am	2008-09-18 13:38:09 UTC (rev 4359)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/Makefile.am	2008-09-18 14:21:01 UTC (rev 4360)
@@ -7,7 +7,7 @@
 libADM_lavformat_a_SOURCES =  mpeg.c utils.c avio.c ADM_lavformat.cpp \
 aviobuf.c cutils.c img2.c file.c mpegtsenc.c ADM_muxts.cpp movenc.c \
 avienc.c wav.c mov.c matroska.c isom.c isom.h riff.c flvenc.c \
-matroskaenc.c
+matroskaenc.c avc.c
 
 
 EXTRA_DIST = ADM_lavformat.cpp  ADM_muxts.cpp  avformat.h  avio.h   \

Added: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/avc.c
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/avc.c	2008-09-18 13:38:09 UTC (rev 4359)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/avc.c	2008-09-18 14:21:01 UTC (rev 4360)
@@ -0,0 +1,135 @@
+/*
+ * AVC helper functions for muxers
+ * Copyright (c) 2006 Baptiste Coudurier &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">baptiste.coudurier at smartjog.com</A>&gt;
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+#include &quot;avformat.h&quot;
+#include &quot;avio.h&quot;
+
+const uint8_t *ff_avc_find_startcode(const uint8_t *p, const uint8_t *end)
+{
+    const uint8_t *a = p + 4 - ((long)p &amp; 3);
+
+    for( end -= 3; p &lt; a &amp;&amp; p &lt; end; p++ ) {
+        if( p[0] == 0 &amp;&amp; p[1] == 0 &amp;&amp; p[2] == 1 )
+            return p;
+    }
+
+    for( end -= 3; p &lt; end; p += 4 ) {
+        uint32_t x = *(const uint32_t*)p;
+//      if( (x - 0x01000100) &amp; (~x) &amp; 0x80008000 ) // little endian
+//      if( (x - 0x00010001) &amp; (~x) &amp; 0x00800080 ) // big endian
+        if( (x - 0x01010101) &amp; (~x) &amp; 0x80808080 ) { // generic
+            if( p[1] == 0 ) {
+                if( p[0] == 0 &amp;&amp; p[2] == 1 )
+                    return p-1;
+                if( p[2] == 0 &amp;&amp; p[3] == 1 )
+                    return p;
+            }
+            if( p[3] == 0 ) {
+                if( p[2] == 0 &amp;&amp; p[4] == 1 )
+                    return p+1;
+                if( p[4] == 0 &amp;&amp; p[5] == 1 )
+                    return p+2;
+            }
+        }
+    }
+
+    for( end += 3; p &lt; end; p++ ) {
+        if( p[0] == 0 &amp;&amp; p[1] == 0 &amp;&amp; p[2] == 1 )
+            return p;
+    }
+
+    return end + 3;
+}
+
+int ff_avc_parse_nal_units(const uint8_t *buf_in, uint8_t **buf, int *size)
+{
+    ByteIOContext pb;
+    const uint8_t *p = buf_in;
+    const uint8_t *end = p + *size;
+    const uint8_t *nal_start, *nal_end;
+    int ret = url_open_dyn_buf(&amp;pb);
+    if(ret &lt; 0)
+        return ret;
+
+    nal_start = ff_avc_find_startcode(p, end);
+    while (nal_start &lt; end) {
+        while(!*(nal_start++));
+        nal_end = ff_avc_find_startcode(nal_start, end);
+        put_be32(&amp;pb, nal_end - nal_start);
+        put_buffer(&amp;pb, nal_start, nal_end - nal_start);
+        nal_start = nal_end;
+    }
+    av_freep(buf);
+    *size = url_close_dyn_buf(&amp;pb, buf);
+    return 0;
+}
+
+int ff_isom_write_avcc(ByteIOContext *pb, const uint8_t *data, int len)
+{
+    if (len &gt; 6) {
+        /* check for h264 start code */
+        if (AV_RB32(data) == 0x00000001) {
+            uint8_t *buf=NULL, *end, *start;
+            uint32_t sps_size=0, pps_size=0;
+            uint8_t *sps=0, *pps=0;
+
+            int ret = ff_avc_parse_nal_units(data, &amp;buf, &amp;len);
+            if (ret &lt; 0)
+                return ret;
+            start = buf;
+            end = buf + len;
+
+            /* look for sps and pps */
+            while (buf &lt; end) {
+                unsigned int size;
+                uint8_t nal_type;
+                size = AV_RB32(buf);
+                nal_type = buf[4] &amp; 0x1f;
+                if (nal_type == 7) { /* SPS */
+                    sps = buf + 4;
+                    sps_size = size;
+                } else if (nal_type == 8) { /* PPS */
+                    pps = buf + 4;
+                    pps_size = size;
+                }
+                buf += size + 4;
+            }
+            assert(sps);
+            assert(pps);
+
+            put_byte(pb, 1); /* version */
+            put_byte(pb, sps[1]); /* profile */
+            put_byte(pb, sps[2]); /* profile compat */
+            put_byte(pb, sps[3]); /* level */
+            put_byte(pb, 0xff); /* 6 bits reserved (111111) + 2 bits nal size length - 1 (11) */
+            put_byte(pb, 0xe1); /* 3 bits reserved (111) + 5 bits number of sps (00001) */
+
+            put_be16(pb, sps_size);
+            put_buffer(pb, sps, sps_size);
+            put_byte(pb, 1); /* number of pps */
+            put_be16(pb, pps_size);
+            put_buffer(pb, pps, pps_size);
+            av_free(start);
+        } else {
+            put_buffer(pb, data, len);
+        }
+    }
+    return 0;
+}

Added: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/avc.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/avc.h	2008-09-18 13:38:09 UTC (rev 4359)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/avc.h	2008-09-18 14:21:01 UTC (rev 4360)
@@ -0,0 +1,32 @@
+/*
+ * AVC helper functions for muxers
+ * Copyright (c) 2008 Aurelien Jacobs &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">aurel at gnuage.org</A>&gt;
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef AVFORMAT_AVC_H
+#define AVFORMAT_AVC_H
+
+#include &lt;stdint.h&gt;
+#include &quot;avio.h&quot;
+
+int ff_avc_parse_nal_units(const uint8_t *buf_in, uint8_t **buf, int *size);
+int ff_isom_write_avcc(ByteIOContext *pb, const uint8_t *data, int len);
+const uint8_t *ff_avc_find_startcode(const uint8_t *p, const uint8_t *end);
+
+#endif /* AVFORMAT_AVC_H */

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/movenc.c
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/movenc.c	2008-09-18 13:38:09 UTC (rev 4359)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/movenc.c	2008-09-18 14:21:01 UTC (rev 4360)
@@ -23,6 +23,8 @@
 #include &quot;riff.h&quot;
 #include &quot;avio.h&quot;
 #include &quot;isom.h&quot;
+#include &quot;avc.h&quot;
+#include &quot;bitstream.h&quot;
 
 #undef NDEBUG
 #include &lt;assert.h&gt;
@@ -30,12 +32,13 @@
 #define MOV_INDEX_CLUSTER_SIZE 16384
 #define globalTimescale 1000
 
-#define MODE_MP4 0
-#define MODE_MOV 1
-#define MODE_3GP 2
-#define MODE_PSP 3 // example working PSP command line:
+#define MODE_MP4  0x01
+#define MODE_MOV  0x02
+#define MODE_3GP  0x04
+#define MODE_PSP  0x08 // example working PSP command line:
 // ffmpeg -i testinput.avi  -f psp -r 14.985 -s 320x240 -b 768 -ar 24000 -ab 32 M4V00001.MP4
-#define MODE_3G2 4
+#define MODE_3G2  0x10
+#define MODE_IPOD 0x20
 
 // MEANX
 extern int ADM_useAlternateTagging(void);
@@ -65,7 +68,7 @@
     int         hasBframes;
     int         language;
     int         trackID;
-    int         tag;
+    int         tag; ///&lt; stsd fourcc
     AVCodecContext *enc;
 
     int         vosLen;
@@ -85,7 +88,7 @@
 } MOVContext;
 
 //FIXME support 64 bit variant with wide placeholders
-static offset_t updateSize (ByteIOContext *pb, offset_t pos)
+static offset_t updateSize(ByteIOContext *pb, offset_t pos)
 {
     offset_t curpos = url_ftell(pb);
     url_fseek(pb, pos, SEEK_SET);
@@ -96,7 +99,7 @@
 }
 
 /* Chunk offset atom */
-static int mov_write_stco_tag(ByteIOContext *pb, MOVTrack* track)
+static int mov_write_stco_tag(ByteIOContext *pb, MOVTrack *track)
 {
     int i;
     int mode64 = 0; //   use 32 bit size variant if possible
@@ -115,11 +118,11 @@
         else
             put_be32(pb, track-&gt;cluster[i].pos);
     }
-    return updateSize (pb, pos);
+    return updateSize(pb, pos);
 }
 
 /* Sample size atom */
-static int mov_write_stsz_tag(ByteIOContext *pb, MOVTrack* track)
+static int mov_write_stsz_tag(ByteIOContext *pb, MOVTrack *track)
 {
     int equalChunks = 1;
     int i, j, entries = 0, tst = -1, oldtst = -1;
@@ -146,17 +149,17 @@
         put_be32(pb, 0); // sample size
         put_be32(pb, entries); // sample count
         for (i=0; i&lt;track-&gt;entry; i++) {
-            for ( j=0; j&lt;track-&gt;cluster[i].entries; j++) {
+            for (j=0; j&lt;track-&gt;cluster[i].entries; j++) {
                 put_be32(pb, track-&gt;cluster[i].size /
                          track-&gt;cluster[i].entries);
             }
         }
     }
-    return updateSize (pb, pos);
+    return updateSize(pb, pos);
 }
 
 /* Sample to chunk atom */
-static int mov_write_stsc_tag(ByteIOContext *pb, MOVTrack* track)
+static int mov_write_stsc_tag(ByteIOContext *pb, MOVTrack *track)
 {
     int index = 0, oldval = -1, i;
     offset_t entryPos, curpos;
@@ -182,11 +185,11 @@
     put_be32(pb, index); // rewrite size
     url_fseek(pb, curpos, SEEK_SET);
 
-    return updateSize (pb, pos);
+    return updateSize(pb, pos);
 }
 
 /* Sync sample atom */
-static int mov_write_stss_tag(ByteIOContext *pb, MOVTrack* track)
+static int mov_write_stss_tag(ByteIOContext *pb, MOVTrack *track)
 {
     offset_t curpos, entryPos;
     int i, index = 0;
@@ -206,7 +209,7 @@
     url_fseek(pb, entryPos, SEEK_SET);
     put_be32(pb, index); // rewrite size
     url_fseek(pb, curpos, SEEK_SET);
-    return updateSize (pb, pos);
+    return updateSize(pb, pos);
 }
 
 static int mov_write_amr_tag(ByteIOContext *pb, MOVTrack *track)
@@ -223,6 +226,60 @@
     return 0x11;
 }
 
+static int mov_write_ac3_tag(ByteIOContext *pb, MOVTrack *track)
+{
+    GetBitContext gbc;
+    PutBitContext pbc;
+    uint8_t buf[3];
+    int fscod, bsid, bsmod, acmod, lfeon, frmsizecod;
+
+    if (track-&gt;vosLen &lt; 7)
+        return -1;
+
+    put_be32(pb, 11);
+    put_tag(pb, &quot;dac3&quot;);
+
+    init_get_bits(&amp;gbc, track-&gt;vosData+4, track-&gt;vosLen-4);
+    fscod      = get_bits(&amp;gbc, 2);
+    frmsizecod = get_bits(&amp;gbc, 6);
+    bsid       = get_bits(&amp;gbc, 5);
+    bsmod      = get_bits(&amp;gbc, 3);
+    acmod      = get_bits(&amp;gbc, 3);
+    if (acmod == 2) {
+        skip_bits(&amp;gbc, 2); // dsurmod
+    } else {
+        if ((acmod &amp; 1) &amp;&amp; acmod != 1)
+            skip_bits(&amp;gbc, 2); // cmixlev
+        if (acmod &amp; 4)
+            skip_bits(&amp;gbc, 2); // surmixlev
+    }
+    lfeon = get_bits1(&amp;gbc);
+
+    init_put_bits(&amp;pbc, buf, sizeof(buf));
+    put_bits(&amp;pbc, 2, fscod);
+    put_bits(&amp;pbc, 5, bsid);
+    put_bits(&amp;pbc, 3, bsmod);
+    put_bits(&amp;pbc, 3, acmod);
+    put_bits(&amp;pbc, 1, lfeon);
+    put_bits(&amp;pbc, 5, frmsizecod&gt;&gt;1); // bit_rate_code
+    put_bits(&amp;pbc, 5, 0); // reserved
+
+    flush_put_bits(&amp;pbc);
+    put_buffer(pb, buf, sizeof(buf));
+
+    return 11;
+}
+
+/**
+ * This function writes extradata &quot;as is&quot;.
+ * Extradata must be formated like a valid atom (with size and tag)
+ */
+static int mov_write_extradata_tag(ByteIOContext *pb, MOVTrack *track)
+{
+    put_buffer(pb, track-&gt;enc-&gt;extradata, track-&gt;enc-&gt;extradata_size);
+    return track-&gt;enc-&gt;extradata_size;
+}
+
 static int mov_write_enda_tag(ByteIOContext *pb)
 {
     put_be32(pb, 10);
@@ -247,64 +304,61 @@
     put_byte(pb, size &amp; 0x7F);
 }
 
-static int mov_write_esds_tag(ByteIOContext *pb, MOVTrack* track) // Basic
+static int mov_write_esds_tag(ByteIOContext *pb, MOVTrack *track) // Basic
 {
-int codec_id; // MEANX
     offset_t pos = url_ftell(pb);
     int decoderSpecificInfoLen = track-&gt;vosLen ? descrLength(track-&gt;vosLen):0;
 
-    put_be32(pb, 0);               // size
+    put_be32(pb, 0); // size
     put_tag(pb, &quot;esds&quot;);
-    put_be32(pb, 0);               // Version
+    put_be32(pb, 0); // Version
 
     // ES descriptor
     putDescr(pb, 0x03, 3 + descrLength(13 + decoderSpecificInfoLen) +
              descrLength(1));
     put_be16(pb, track-&gt;trackID);
-    put_byte(pb, 0x00);            // flags (= no flags)
+    put_byte(pb, 0x00); // flags (= no flags)
 
     // DecoderConfig descriptor
     putDescr(pb, 0x04, 13 + decoderSpecificInfoLen);
 
     // Object type indication
-  //MEANX  put_byte(pb, codec_get_tag(ff_mp4_obj_type, track-&gt;enc-&gt;codec_id));
- // MEANX
-    codec_id=track-&gt;enc-&gt;codec_id;
-    if(ADM_useAlternateTagging() &amp;&amp; codec_id==CODEC_ID_MP3) codec_id=CODEC_ID_MP2;
-    put_byte(pb, codec_get_tag(ff_mp4_obj_type, codec_id));
-    // /MEANX
+    if ((track-&gt;enc-&gt;codec_id == CODEC_ID_MP2 ||
+         track-&gt;enc-&gt;codec_id == CODEC_ID_MP3) &amp;&amp;
+        track-&gt;enc-&gt;sample_rate &gt; 24000)
+        put_byte(pb, 0x6B); // 11172-3
+    else
+        put_byte(pb, codec_get_tag(ff_mp4_obj_type, track-&gt;enc-&gt;codec_id));
 
     // the following fields is made of 6 bits to identify the streamtype (4 for video, 5 for audio)
     // plus 1 bit to indicate upstream and 1 bit set to 1 (reserved)
     if(track-&gt;enc-&gt;codec_type == CODEC_TYPE_AUDIO)
-        put_byte(pb, 0x15);            // flags (= Audiostream)
+        put_byte(pb, 0x15); // flags (= Audiostream)
     else
-        put_byte(pb, 0x11);            // flags (= Visualstream)
+        put_byte(pb, 0x11); // flags (= Visualstream)
 
-    put_byte(pb,  track-&gt;enc-&gt;rc_buffer_size&gt;&gt;(3+16));             // Buffersize DB (24 bits)
-    put_be16(pb, (track-&gt;enc-&gt;rc_buffer_size&gt;&gt;3)&amp;0xFFFF);          // Buffersize DB
+    put_byte(pb,  track-&gt;enc-&gt;rc_buffer_size&gt;&gt;(3+16));    // Buffersize DB (24 bits)
+    put_be16(pb, (track-&gt;enc-&gt;rc_buffer_size&gt;&gt;3)&amp;0xFFFF); // Buffersize DB
 
-    put_be32(pb, FFMAX(track-&gt;enc-&gt;bit_rate, track-&gt;enc-&gt;rc_max_rate));     // maxbitrate  (FIXME should be max rate in any 1 sec window)
+    put_be32(pb, FFMAX(track-&gt;enc-&gt;bit_rate, track-&gt;enc-&gt;rc_max_rate)); // maxbitrate (FIXME should be max rate in any 1 sec window)
     if(track-&gt;enc-&gt;rc_max_rate != track-&gt;enc-&gt;rc_min_rate || track-&gt;enc-&gt;rc_min_rate==0)
-        put_be32(pb, 0);     // vbr
+        put_be32(pb, 0); // vbr
     else
-        put_be32(pb, track-&gt;enc-&gt;rc_max_rate);     // avg bitrate
+        put_be32(pb, track-&gt;enc-&gt;rc_max_rate); // avg bitrate
 
-    if (track-&gt;vosLen)
-    {
+    if (track-&gt;vosLen) {
         // DecoderSpecific info descriptor
         putDescr(pb, 0x05, track-&gt;vosLen);
         put_buffer(pb, track-&gt;vosData, track-&gt;vosLen);
     }
 
-
     // SL descriptor
     putDescr(pb, 0x06, 1);
     put_byte(pb, 0x02);
-    return updateSize (pb, pos);
+    return updateSize(pb, pos);
 }
 
-static int mov_write_wave_tag(ByteIOContext *pb, MOVTrack* track)
+static int mov_write_wave_tag(ByteIOContext *pb, MOVTrack *track)
 {
     offset_t pos = url_ftell(pb);
 
@@ -326,16 +380,28 @@
         mov_write_enda_tag(pb);
     } else if (track-&gt;enc-&gt;codec_id == CODEC_ID_AMR_NB) {
         mov_write_amr_tag(pb, track);
+    } else if (track-&gt;enc-&gt;codec_id == CODEC_ID_AC3) {
+        mov_write_ac3_tag(pb, track);
+    } else if (track-&gt;enc-&gt;codec_id == CODEC_ID_ALAC) {
+        mov_write_extradata_tag(pb, track);
     }
 
     put_be32(pb, 8);     /* size */
     put_be32(pb, 0);     /* null tag */
 
-    return updateSize (pb, pos);
+    return updateSize(pb, pos);
 }
 
-static int mov_write_audio_tag(ByteIOContext *pb, MOVTrack* track)
+static int mov_write_glbl_tag(ByteIOContext *pb, MOVTrack *track)
 {
+    put_be32(pb, track-&gt;vosLen+8);
+    put_tag(pb, &quot;glbl&quot;);
+    put_buffer(pb, track-&gt;vosData, track-&gt;vosLen);
+    return 8+track-&gt;vosLen;
+}
+
+static int mov_write_audio_tag(ByteIOContext *pb, MOVTrack *track)
+{
     offset_t pos = url_ftell(pb);
     int version = track-&gt;mode == MODE_MOV &amp;&amp;
         (track-&gt;audio_vbr ||
@@ -380,18 +446,24 @@
 
     if(track-&gt;mode == MODE_MOV &amp;&amp;
        (track-&gt;enc-&gt;codec_id == CODEC_ID_AAC ||
+        track-&gt;enc-&gt;codec_id == CODEC_ID_AC3 ||
         track-&gt;enc-&gt;codec_id == CODEC_ID_AMR_NB ||
         track-&gt;enc-&gt;codec_id == CODEC_ID_PCM_S24LE ||
-        track-&gt;enc-&gt;codec_id == CODEC_ID_PCM_S32LE))
+        track-&gt;enc-&gt;codec_id == CODEC_ID_PCM_S32LE ||
+        track-&gt;enc-&gt;codec_id == CODEC_ID_ALAC))
         mov_write_wave_tag(pb, track);
-    else if(track-&gt;enc-&gt;codec_id == CODEC_ID_AAC // MEANX)
-       || track-&gt;enc-&gt;codec_id == CODEC_ID_MP3
-	   || track-&gt;enc-&gt;codec_id == CODEC_ID_MP2) // MEANX
+    else if(track-&gt;tag == MKTAG('m','p','4','a'))
         mov_write_esds_tag(pb, track);
     else if(track-&gt;enc-&gt;codec_id == CODEC_ID_AMR_NB)
         mov_write_amr_tag(pb, track);
+    else if(track-&gt;enc-&gt;codec_id == CODEC_ID_AC3)
+        mov_write_ac3_tag(pb, track);
+    else if(track-&gt;enc-&gt;codec_id == CODEC_ID_ALAC)
+        mov_write_extradata_tag(pb, track);
+    else if(track-&gt;vosLen &gt; 0)
+        mov_write_glbl_tag(pb, track);
 
-    return updateSize (pb, pos);
+    return updateSize(pb, pos);
 }
 
 static int mov_write_d263_tag(ByteIOContext *pb)
@@ -419,174 +491,165 @@
     return 0x15;
 }
 
-static uint8_t *avc_find_startcode( uint8_t *p, uint8_t *end )
+static int mov_write_avcc_tag(ByteIOContext *pb, MOVTrack *track)
 {
-    uint8_t *a = p + 4 - ((long)p &amp; 3);
+    offset_t pos = url_ftell(pb);
 
-    for( end -= 3; p &lt; a &amp;&amp; p &lt; end; p++ ) {
-        if( p[0] == 0 &amp;&amp; p[1] == 0 &amp;&amp; p[2] == 1 )
-            return p;
-    }
-
-    for( end -= 3; p &lt; end; p += 4 ) {
-        uint32_t x = *(uint32_t*)p;
-//      if( (x - 0x01000100) &amp; (~x) &amp; 0x80008000 ) // little endian
-//      if( (x - 0x00010001) &amp; (~x) &amp; 0x00800080 ) // big endian
-        if( (x - 0x01010101) &amp; (~x) &amp; 0x80808080 ) { // generic
-            if( p[1] == 0 ) {
-                if( p[0] == 0 &amp;&amp; p[2] == 1 )
-                    return p-1;
-                if( p[2] == 0 &amp;&amp; p[3] == 1 )
-                    return p;
-            }
-            if( p[3] == 0 ) {
-                if( p[2] == 0 &amp;&amp; p[4] == 1 )
-                    return p+1;
-                if( p[4] == 0 &amp;&amp; p[5] == 1 )
-                    return p+2;
-            }
-        }
-    }
-
-    for( end += 3; p &lt; end; p++ ) {
-        if( p[0] == 0 &amp;&amp; p[1] == 0 &amp;&amp; p[2] == 1 )
-            return p;
-    }
-
-    return end + 3;
+    put_be32(pb, 0);
+    put_tag(pb, &quot;avcC&quot;);
+    ff_isom_write_avcc(pb, track-&gt;vosData, track-&gt;vosLen);
+    return updateSize(pb, pos);
 }
 
-static void avc_parse_nal_units(uint8_t **buf, int *size)
+/* also used by all avid codecs (dv, imx, meridien) and their variants */
+static int mov_write_avid_tag(ByteIOContext *pb, MOVTrack *track)
 {
-    ByteIOContext pb;
-    uint8_t *p = *buf;
-    uint8_t *end = p + *size;
-    uint8_t *nal_start, *nal_end;
+    int i;
+    put_be32(pb, 24); /* size */
+    put_tag(pb, &quot;ACLR&quot;);
+    put_tag(pb, &quot;ACLR&quot;);
+    put_tag(pb, &quot;0001&quot;);
+    put_be32(pb, 1); /* yuv 1 / rgb 2 ? */
+    put_be32(pb, 0); /* unknown */
 
-    url_open_dyn_buf(&amp;pb);
-    nal_start = avc_find_startcode(p, end);
-    while (nal_start &lt; end) {
-        while(!*(nal_start++));
-        nal_end = avc_find_startcode(nal_start, end);
-        put_be32(&amp;pb, nal_end - nal_start);
-        put_buffer(&amp;pb, nal_start, nal_end - nal_start);
-        nal_start = nal_end;
+    put_be32(pb, 24); /* size */
+    put_tag(pb, &quot;APRG&quot;);
+    put_tag(pb, &quot;APRG&quot;);
+    put_tag(pb, &quot;0001&quot;);
+    put_be32(pb, 1); /* unknown */
+    put_be32(pb, 0); /* unknown */
+
+    put_be32(pb, 120); /* size */
+    put_tag(pb, &quot;ARES&quot;);
+    put_tag(pb, &quot;ARES&quot;);
+    put_tag(pb, &quot;0001&quot;);
+    put_be32(pb, AV_RB32(track-&gt;vosData + 0x28)); /* dnxhd cid, some id ? */
+    put_be32(pb, track-&gt;enc-&gt;width);
+    /* values below are based on samples created with quicktime and avid codecs */
+    if (track-&gt;vosData[5] &amp; 2) { // interlaced
+        put_be32(pb, track-&gt;enc-&gt;height/2);
+        put_be32(pb, 2); /* unknown */
+        put_be32(pb, 0); /* unknown */
+        put_be32(pb, 4); /* unknown */
+    } else {
+        put_be32(pb, track-&gt;enc-&gt;height);
+        put_be32(pb, 1); /* unknown */
+        put_be32(pb, 0); /* unknown */
+        if (track-&gt;enc-&gt;height == 1080)
+            put_be32(pb, 5); /* unknown */
+        else
+            put_be32(pb, 6); /* unknown */
     }
-    av_freep(buf);
-    *size = url_close_dyn_buf(&amp;pb, buf);
-}
+    /* padding */
+    for (i = 0; i &lt; 10; i++)
+        put_be64(pb, 0);
 
-static int mov_write_avcc_tag(ByteIOContext *pb, MOVTrack *track)
-{
-    offset_t pos = url_ftell(pb);
-
+    /* extra padding for stsd needed */
     put_be32(pb, 0);
-    put_tag(pb, &quot;avcC&quot;);
-    if (track-&gt;vosLen &gt; 6) {
-        /* check for h264 start code */
-        if (AV_RB32(track-&gt;vosData) == 0x00000001) {
-            uint8_t *buf, *end;
-            uint32_t sps_size=0, pps_size=0;
-            uint8_t *sps=0, *pps=0;
+    return 0;
+}
 
-            avc_parse_nal_units(&amp;track-&gt;vosData, &amp;track-&gt;vosLen);
-            buf = track-&gt;vosData;
-            end = track-&gt;vosData + track-&gt;vosLen;
+static const AVCodecTag codec_3gp_tags[] = {
+    { CODEC_ID_H263,   MKTAG('s','2','6','3') },
+    { CODEC_ID_H264,   MKTAG('a','v','c','1') },
+    { CODEC_ID_MPEG4,  MKTAG('m','p','4','v') },
+    { CODEC_ID_AAC,    MKTAG('m','p','4','a') },
+    { CODEC_ID_AMR_NB, MKTAG('s','a','m','r') },
+    { CODEC_ID_AMR_WB, MKTAG('s','a','w','b') },
+    { CODEC_ID_NONE, 0 },
+};
 
-            /* look for sps and pps */
-            while (buf &lt; end) {
-                unsigned int size;
-                uint8_t nal_type;
-                size = AV_RB32(buf);
-                nal_type = buf[4] &amp; 0x1f;
-                if (nal_type == 7) { /* SPS */
-                    sps = buf + 4;
-                    sps_size = size;
-                } else if (nal_type == 8) { /* PPS */
-                    pps = buf + 4;
-                    pps_size = size;
-                }
-                buf += size + 4;
-            }
-            assert(sps);
-            assert(pps);
+static const AVCodecTag mov_pix_fmt_tags[] = {
+    { PIX_FMT_YUYV422, MKTAG('y','u','v','s') },
+    { PIX_FMT_UYVY422, MKTAG('2','v','u','y') },
+    { PIX_FMT_BGR555,  MKTAG('r','a','w',' ') },
+    { PIX_FMT_RGB24,   MKTAG('r','a','w',' ') },
+    { PIX_FMT_BGR32_1, MKTAG('r','a','w',' ') },
+};
 
-            put_byte(pb, 1); /* version */
-            put_byte(pb, sps[1]); /* profile */
-            put_byte(pb, sps[2]); /* profile compat */
-            put_byte(pb, sps[3]); /* level */
-            put_byte(pb, 0xff); /* 6 bits reserved (111111) + 2 bits nal size length - 1 (11) */
-            put_byte(pb, 0xe1); /* 3 bits reserved (111) + 5 bits number of sps (00001) */
+static const AVCodecTag codec_ipod_tags[] = {
+    { CODEC_ID_H264,   MKTAG('a','v','c','1') },
+    { CODEC_ID_MPEG4,  MKTAG('m','p','4','v') },
+    { CODEC_ID_AAC,    MKTAG('m','p','4','a') },
+    { CODEC_ID_ALAC,   MKTAG('a','l','a','c') },
+    { CODEC_ID_AC3,    MKTAG('a','c','-','3') },
+    { CODEC_ID_NONE, 0 },
+};
 
-            put_be16(pb, sps_size);
-            put_buffer(pb, sps, sps_size);
-            put_byte(pb, 1); /* number of pps */
-            put_be16(pb, pps_size);
-            put_buffer(pb, pps, pps_size);
-        } else {
-            put_buffer(pb, track-&gt;vosData, track-&gt;vosLen);
-        }
-    }
-    return updateSize(pb, pos);
-}
-
-static int mov_find_video_codec_tag(AVFormatContext *s, MOVTrack *track)
+static int mov_find_codec_tag(AVFormatContext *s, MOVTrack *track)
 {
     int tag = track-&gt;enc-&gt;codec_tag;
-    if (!tag) {
+    if (track-&gt;mode == MODE_MP4 || track-&gt;mode == MODE_PSP) {
+        if (!codec_get_tag(ff_mp4_obj_type, track-&gt;enc-&gt;codec_id))
+            return 0;
+        if      (track-&gt;enc-&gt;codec_id == CODEC_ID_H264)      tag = MKTAG('a','v','c','1');
+        else if (track-&gt;enc-&gt;codec_id == CODEC_ID_AC3)       tag = MKTAG('a','c','-','3');
+        else if (track-&gt;enc-&gt;codec_id == CODEC_ID_DIRAC)     tag = MKTAG('d','r','a','c');
+        else if (track-&gt;enc-&gt;codec_type == CODEC_TYPE_VIDEO) tag = MKTAG('m','p','4','v');
+        else if (track-&gt;enc-&gt;codec_type == CODEC_TYPE_AUDIO) tag = MKTAG('m','p','4','a');
+    } else if (track-&gt;mode == MODE_IPOD) {
+        tag = codec_get_tag(codec_ipod_tags, track-&gt;enc-&gt;codec_id);
+        if (!match_ext(s-&gt;filename, &quot;m4a&quot;) &amp;&amp; !match_ext(s-&gt;filename, &quot;m4v&quot;))
+            av_log(s, AV_LOG_WARNING, &quot;Warning, extension is not .m4a nor .m4v &quot;
+                   &quot;Quicktime/Ipod might not play the file\n&quot;);
+    } else if (track-&gt;mode &amp; MODE_3GP) {
+        tag = codec_get_tag(codec_3gp_tags, track-&gt;enc-&gt;codec_id);
+    } else if (!tag || (track-&gt;enc-&gt;strict_std_compliance &gt;= FF_COMPLIANCE_NORMAL &amp;&amp;
+                        (tag == MKTAG('d','v','c','p') ||
+                         track-&gt;enc-&gt;codec_id == CODEC_ID_RAWVIDEO))) {
         if (track-&gt;enc-&gt;codec_id == CODEC_ID_DVVIDEO) {
-            if (track-&gt;enc-&gt;height == 480) { /* NTSC */
-                if (track-&gt;enc-&gt;pix_fmt == PIX_FMT_YUV422P)
-                    tag = MKTAG('d', 'v', '5', 'n');
-                else
-                    tag = MKTAG('d', 'v', 'c', ' ');
-            } else { /* assume PAL */
-                if (track-&gt;enc-&gt;pix_fmt == PIX_FMT_YUV422P)
-                    tag = MKTAG('d', 'v', '5', 'p');
-                else if (track-&gt;enc-&gt;pix_fmt == PIX_FMT_YUV420P)
-                    tag = MKTAG('d', 'v', 'c', 'p');
-                else
-                    tag = MKTAG('d', 'v', 'p', 'p');
+            if (track-&gt;enc-&gt;height == 480) /* NTSC */
+                if  (track-&gt;enc-&gt;pix_fmt == PIX_FMT_YUV422P) tag = MKTAG('d','v','5','n');
+                else                                         tag = MKTAG('d','v','c',' ');
+            else if (track-&gt;enc-&gt;pix_fmt == PIX_FMT_YUV422P) tag = MKTAG('d','v','5','p');
+            else if (track-&gt;enc-&gt;pix_fmt == PIX_FMT_YUV420P) tag = MKTAG('d','v','c','p');
+            else                                             tag = MKTAG('d','v','p','p');
+        } else if (track-&gt;enc-&gt;codec_id == CODEC_ID_RAWVIDEO) {
+            tag = codec_get_tag(mov_pix_fmt_tags, track-&gt;enc-&gt;pix_fmt);
+            if (!tag) // restore tag
+                tag = track-&gt;enc-&gt;codec_tag;
+        } else {
+            if (track-&gt;enc-&gt;codec_type == CODEC_TYPE_VIDEO) {
+                tag = codec_get_tag(codec_movvideo_tags, track-&gt;enc-&gt;codec_id);
+                if (!tag) { // if no mac fcc found, try with Microsoft tags
+                    tag = codec_get_tag(codec_bmp_tags, track-&gt;enc-&gt;codec_id);
+                    if (tag)
+                        av_log(s, AV_LOG_INFO, &quot;Warning, using MS style video codec tag, &quot;
+                               &quot;the file may be unplayable!\n&quot;);
+                }
+            } else if (track-&gt;enc-&gt;codec_type == CODEC_TYPE_AUDIO) {
+                tag = codec_get_tag(codec_movaudio_tags, track-&gt;enc-&gt;codec_id);
+                if (!tag) { // if no mac fcc found, try with Microsoft tags
+                    int ms_tag = codec_get_tag(codec_wav_tags, track-&gt;enc-&gt;codec_id);
+                    if (ms_tag) {
+                        tag = MKTAG('m', 's', ((ms_tag &gt;&gt; 8) &amp; 0xff), (ms_tag &amp; 0xff));
+                        av_log(s, AV_LOG_INFO, &quot;Warning, using MS style audio codec tag, &quot;
+                               &quot;the file may be unplayable!\n&quot;);
+                    }
+                }
             }
-        } else if (track-&gt;enc-&gt;codec_id == CODEC_ID_H263) {
-            if (track-&gt;mode == MODE_MOV)
-                tag = MKTAG('h', '2', '6', '3');
-            else
-                tag = MKTAG('s', '2', '6', '3');
-        } else {
-            tag = codec_get_tag(codec_movvideo_tags, track-&gt;enc-&gt;codec_id);
         }
     }
-    // if no mac fcc found, try with Microsoft tags
-    if (!tag) {
-        tag = codec_get_tag(codec_bmp_tags, track-&gt;enc-&gt;codec_id);
-        if (tag) {
-            av_log(s, AV_LOG_INFO, &quot;Warning, using MS style video codec tag, the file may be unplayable!\n&quot;);
-        }
-    }
-    assert(tag);
     return tag;
 }
 
-static int mov_find_audio_codec_tag(AVFormatContext *s, MOVTrack *track)
+/** Write uuid atom.
+ * Needed to make file play in iPods running newest firmware
+ * goes after avcC atom in moov.trak.mdia.minf.stbl.stsd.avc1
+ */
+static int mov_write_uuid_tag_ipod(ByteIOContext *pb)
 {
-    int tag = track-&gt;enc-&gt;codec_tag;
-    if (!tag) {
-        tag = codec_get_tag(codec_movaudio_tags, track-&gt;enc-&gt;codec_id);
-    }
-    // if no mac fcc found, try with Microsoft tags
-    if (!tag) {
-        int ms_tag = codec_get_tag(codec_wav_tags, track-&gt;enc-&gt;codec_id);
-        if (ms_tag) {
-            tag = MKTAG('m', 's', ((ms_tag &gt;&gt; 8) &amp; 0xff), (ms_tag &amp; 0xff));
-            av_log(s, AV_LOG_INFO, &quot;Warning, using MS style audio codec tag, the file may be unplayable!\n&quot;);
-        }
-    }
-    assert(tag);
-    return tag;
+    put_be32(pb, 28);
+    put_tag(pb, &quot;uuid&quot;);
+    put_be32(pb, 0x6b6840f2);
+    put_be32(pb, 0x5f244fc5);
+    put_be32(pb, 0xba39a51b);
+    put_be32(pb, 0xcf0323f3);
+    put_be32(pb, 0x0);
+    return 28;
 }
 
-static int mov_write_video_tag(ByteIOContext *pb, MOVTrack* track)
+static int mov_write_video_tag(ByteIOContext *pb, MOVTrack *track)
 {
     offset_t pos = url_ftell(pb);
     char compressor_name[32];
@@ -627,21 +690,30 @@
     put_byte(pb, strlen(compressor_name));
     put_buffer(pb, compressor_name, 31);
 
-    put_be16(pb, 0x18); /* Reserved */
+    if (track-&gt;mode == MODE_MOV &amp;&amp; track-&gt;enc-&gt;bits_per_sample)
+        put_be16(pb, track-&gt;enc-&gt;bits_per_sample);
+    else
+        put_be16(pb, 0x18); /* Reserved */
     put_be16(pb, 0xffff); /* Reserved */
-    if(track-&gt;enc-&gt;codec_id == CODEC_ID_MPEG4)
+    if(track-&gt;tag == MKTAG('m','p','4','v'))
         mov_write_esds_tag(pb, track);
     else if(track-&gt;enc-&gt;codec_id == CODEC_ID_H263)
         mov_write_d263_tag(pb);
     else if(track-&gt;enc-&gt;codec_id == CODEC_ID_SVQ3)
         mov_write_svq3_tag(pb);
-    else if(track-&gt;enc-&gt;codec_id == CODEC_ID_H264)
+    else if(track-&gt;enc-&gt;codec_id == CODEC_ID_DNXHD)
+        mov_write_avid_tag(pb, track);
+    else if(track-&gt;enc-&gt;codec_id == CODEC_ID_H264) {
         mov_write_avcc_tag(pb, track);
+        if(track-&gt;mode == MODE_IPOD)
+            mov_write_uuid_tag_ipod(pb);
+    } else if(track-&gt;vosLen &gt; 0)
+        mov_write_glbl_tag(pb, track);
 
-    return updateSize (pb, pos);
+    return updateSize(pb, pos);
 }
 
-static int mov_write_stsd_tag(ByteIOContext *pb, MOVTrack* track)
+static int mov_write_stsd_tag(ByteIOContext *pb, MOVTrack *track)
 {
     offset_t pos = url_ftell(pb);
     put_be32(pb, 0); /* size */
@@ -655,7 +727,7 @@
     return updateSize(pb, pos);
 }
 
-static int mov_write_ctts_tag(ByteIOContext *pb, MOVTrack* track)
+static int mov_write_ctts_tag(ByteIOContext *pb, MOVTrack *track)
 {
     MOV_stts_t *ctts_entries;
     uint32_t entries = 0;
@@ -689,7 +761,7 @@
 }
 
 /* Time to sample atom */
-static int mov_write_stts_tag(ByteIOContext *pb, MOVTrack* track)
+static int mov_write_stts_tag(ByteIOContext *pb, MOVTrack *track)
 {
     MOV_stts_t *stts_entries;
     uint32_t entries = -1;
@@ -744,7 +816,7 @@
     return 28;
 }
 
-static int mov_write_stbl_tag(ByteIOContext *pb, MOVTrack* track)
+static int mov_write_stbl_tag(ByteIOContext *pb, MOVTrack *track)
 {
     offset_t pos = url_ftell(pb);
     put_be32(pb, 0); /* size */
@@ -752,7 +824,7 @@
     mov_write_stsd_tag(pb, track);
     mov_write_stts_tag(pb, track);
     if (track-&gt;enc-&gt;codec_type == CODEC_TYPE_VIDEO &amp;&amp;
-        track-&gt;hasKeyframes &lt; track-&gt;entry)
+        track-&gt;hasKeyframes &amp;&amp; track-&gt;hasKeyframes &lt; track-&gt;entry)
         mov_write_stss_tag(pb, track);
     if (track-&gt;enc-&gt;codec_type == CODEC_TYPE_VIDEO &amp;&amp;
         track-&gt;hasBframes)
@@ -791,7 +863,7 @@
     return 0x14;
 }
 
-static int mov_write_hdlr_tag(ByteIOContext *pb, MOVTrack* track)
+static int mov_write_hdlr_tag(ByteIOContext *pb, MOVTrack *track)
 {
     const char *descr, *hdlr, *hdlr_type;
     offset_t pos = url_ftell(pb);
@@ -824,7 +896,7 @@
     return updateSize(pb, pos);
 }
 
-static int mov_write_minf_tag(ByteIOContext *pb, MOVTrack* track)
+static int mov_write_minf_tag(ByteIOContext *pb, MOVTrack *track)
 {
     offset_t pos = url_ftell(pb);
     put_be32(pb, 0); /* size */
@@ -840,7 +912,7 @@
     return updateSize(pb, pos);
 }
 
-static int mov_write_mdhd_tag(ByteIOContext *pb, MOVTrack* track)
+static int mov_write_mdhd_tag(ByteIOContext *pb, MOVTrack *track)
 {
     int version = track-&gt;trackDuration &lt; INT32_MAX ? 0 : 1;
 
@@ -870,7 +942,7 @@
     return 32;
 }
 
-static int mov_write_mdia_tag(ByteIOContext *pb, MOVTrack* track)
+static int mov_write_mdia_tag(ByteIOContext *pb, MOVTrack *track)
 {
     offset_t pos = url_ftell(pb);
     put_be32(pb, 0); /* size */
@@ -881,7 +953,7 @@
     return updateSize(pb, pos);
 }
 
-static int mov_write_tkhd_tag(ByteIOContext *pb, MOVTrack* track)
+static int mov_write_tkhd_tag(ByteIOContext *pb, MOVTrack *track, AVStream *st)
 {
     int64_t duration = av_rescale_rnd(track-&gt;trackDuration, globalTimescale, track-&gt;timescale, AV_ROUND_UP);
     int version = duration &lt; INT32_MAX ? 0 : 1;
@@ -925,7 +997,7 @@
     /* Track width and height, for visual only */
     if(track-&gt;enc-&gt;codec_type == CODEC_TYPE_VIDEO) {
         double sample_aspect_ratio = av_q2d(track-&gt;enc-&gt;sample_aspect_ratio);
-        if( !sample_aspect_ratio ) sample_aspect_ratio = 1;
+        if(!sample_aspect_ratio) sample_aspect_ratio = 1;
         put_be32(pb, sample_aspect_ratio * track-&gt;enc-&gt;width*0x10000);
         put_be32(pb, track-&gt;enc-&gt;height*0x10000);
     }
@@ -948,12 +1020,8 @@
 
     put_be32(pb, av_rescale_rnd(track-&gt;trackDuration, globalTimescale, track-&gt;timescale, AV_ROUND_UP)); /* duration   ... doesn't seem to effect psp */
 
-    // MEANX : NO put_be32(pb, track-&gt;cluster[0].cts); /* first pts is cts since dts is 0 */
-      put_be32(pb, 0x00000000);
-    // /MEANX
-
-
-    put_be32(pb, 0x0001); // MEANX put_be32(pb, 0x00010000);
+    put_be32(pb, track-&gt;cluster[0].cts); /* first pts is cts since dts is 0 */
+    put_be32(pb, 0x00010000);
     return 0x24;
 }
 
@@ -976,12 +1044,12 @@
     return 0x34;
 }
 
-static int mov_write_trak_tag(ByteIOContext *pb, MOVTrack* track)
+static int mov_write_trak_tag(ByteIOContext *pb, MOVTrack *track, AVStream *st)
 {
     offset_t pos = url_ftell(pb);
     put_be32(pb, 0); /* size */
     put_tag(pb, &quot;trak&quot;);
-    mov_write_tkhd_tag(pb, track);
+    mov_write_tkhd_tag(pb, track, st);
     if (track-&gt;mode == MODE_PSP || track-&gt;hasBframes)
         mov_write_edts_tag(pb, track);  // PSP Movies require edts box
     mov_write_mdia_tag(pb, track);
@@ -1064,7 +1132,7 @@
     return 0x6c;
 }
 
-static int mov_write_itunes_hdlr_tag(ByteIOContext *pb, MOVContext* mov,
+static int mov_write_itunes_hdlr_tag(ByteIOContext *pb, MOVContext *mov,
                                      AVFormatContext *s)
 {
     offset_t pos = url_ftell(pb);
@@ -1101,7 +1169,7 @@
 
 static int mov_write_string_tag(ByteIOContext *pb, const char *name, const char *value, int long_style){
     int size = 0;
-    if ( value &amp;&amp; value[0] ) {
+    if (value &amp;&amp; value[0]) {
         offset_t pos = url_ftell(pb);
         put_be32(pb, 0); /* size */
         put_tag(pb, name);
@@ -1123,11 +1191,11 @@
 }
 
 /* iTunes track number */
-static int mov_write_trkn_tag(ByteIOContext *pb, MOVContext* mov,
+static int mov_write_trkn_tag(ByteIOContext *pb, MOVContext *mov,
                               AVFormatContext *s)
 {
     int size = 0;
-    if ( s-&gt;track ) {
+    if (s-&gt;track) {
         offset_t pos = url_ftell(pb);
         put_be32(pb, 0); /* size */
         put_tag(pb, &quot;trkn&quot;);
@@ -1149,7 +1217,7 @@
 }
 
 /* iTunes meta data list */
-static int mov_write_ilst_tag(ByteIOContext *pb, MOVContext* mov,
+static int mov_write_ilst_tag(ByteIOContext *pb, MOVContext *mov,
                               AVFormatContext *s)
 {
     offset_t pos = url_ftell(pb);
@@ -1160,23 +1228,23 @@
     mov_write_string_tag(pb, &quot;\251wrt&quot;, s-&gt;author        , 1);
     mov_write_string_tag(pb, &quot;\251alb&quot;, s-&gt;album         , 1);
     mov_write_day_tag(pb, s-&gt;year ,1);
-    if(mov-&gt;tracks[0].enc &amp;&amp; !(mov-&gt;tracks[0].enc-&gt;flags &amp; CODEC_FLAG_BITEXACT))
-        mov_write_string_tag(pb, &quot;\251too&quot;, LIBAVFORMAT_IDENT, 1);
+    mov_write_string_tag(pb, &quot;\251too&quot;, LIBAVFORMAT_IDENT, 1);
     mov_write_string_tag(pb, &quot;\251cmt&quot;, s-&gt;comment       , 1);
     mov_write_string_tag(pb, &quot;\251gen&quot;, s-&gt;genre         , 1);
+    mov_write_string_tag(pb, &quot;\251cpy&quot;, s-&gt;copyright     , 1);
     mov_write_trkn_tag(pb, mov, s);
     return updateSize(pb, pos);
 }
 
 /* iTunes meta data tag */
-static int mov_write_meta_tag(ByteIOContext *pb, MOVContext* mov,
+static int mov_write_meta_tag(ByteIOContext *pb, MOVContext *mov,
                               AVFormatContext *s)
 {
     int size = 0;
 
     // only save meta tag if required
-    if ( s-&gt;title[0] || s-&gt;author[0] || s-&gt;album[0] || s-&gt;year ||
-         s-&gt;comment[0] || s-&gt;genre[0] || s-&gt;track ) {
+    if (s-&gt;title[0] || s-&gt;author[0] || s-&gt;album[0] || s-&gt;year ||
+        s-&gt;comment[0] || s-&gt;genre[0] || s-&gt;track) {
         offset_t pos = url_ftell(pb);
         put_be32(pb, 0); /* size */
         put_tag(pb, &quot;meta&quot;);
@@ -1188,43 +1256,8 @@
     return size;
 }
 
-static int mov_write_udta_tag(ByteIOContext *pb, MOVContext* mov,
-                              AVFormatContext *s)
+static int utf8len(const uint8_t *b)
 {
-    offset_t pos = url_ftell(pb);
-    int i;
-
-    put_be32(pb, 0); /* size */
-    put_tag(pb, &quot;udta&quot;);
-
-    /* iTunes meta data */
-    mov_write_meta_tag(pb, mov, s);
-
-  if(mov-&gt;mode == MODE_MOV){ // the title field breaks gtkpod with mp4 and my suspicion is that stuff is not valid in mp4
-    /* Requirements */
-    for (i=0; i&lt;mov-&gt;nb_streams; i++) {
-        if(mov-&gt;tracks[i].entry &lt;= 0) continue;
-        if (mov-&gt;tracks[i].enc-&gt;codec_id == CODEC_ID_AAC ||
-            mov-&gt;tracks[i].enc-&gt;codec_id == CODEC_ID_MPEG4) {
-            mov_write_string_tag(pb, &quot;\251req&quot;, &quot;QuickTime 6.0 or greater&quot;, 0);
-            break;
-        }
-    }
-
-    mov_write_string_tag(pb, &quot;\251nam&quot;, s-&gt;title         , 0);
-    mov_write_string_tag(pb, &quot;\251aut&quot;, s-&gt;author        , 0);
-    mov_write_string_tag(pb, &quot;\251alb&quot;, s-&gt;album         , 0);
-    mov_write_day_tag(pb, s-&gt;year, 0);
-    if(mov-&gt;tracks[0].enc &amp;&amp; !(mov-&gt;tracks[0].enc-&gt;flags &amp; CODEC_FLAG_BITEXACT))
-        mov_write_string_tag(pb, &quot;\251enc&quot;, LIBAVFORMAT_IDENT, 0);
-    mov_write_string_tag(pb, &quot;\251des&quot;, s-&gt;comment       , 0);
-    mov_write_string_tag(pb, &quot;\251gen&quot;, s-&gt;genre         , 0);
-  }
-
-    return updateSize(pb, pos);
-}
-
-static int utf8len(uint8_t *b){
     int len=0;
     int val;
     while(*b){
@@ -1234,7 +1267,7 @@
     return len;
 }
 
-static int ascii_to_wc (ByteIOContext *pb, uint8_t *b)
+static int ascii_to_wc(ByteIOContext *pb, const uint8_t *b)
 {
     int val;
     while(*b){
@@ -1245,31 +1278,107 @@
     return 0;
 }
 
-static uint16_t language_code (const char *str)
+static uint16_t language_code(const char *str)
 {
-    return ((((str[0]-0x60) &amp; 0x1F)&lt;&lt;10) + (((str[1]-0x60) &amp; 0x1F)&lt;&lt;5) + ((str[2]-0x60) &amp; 0x1F));
+    return (((str[0]-0x60) &amp; 0x1F) &lt;&lt; 10) + (((str[1]-0x60) &amp; 0x1F) &lt;&lt; 5) + ((str[2]-0x60) &amp; 0x1F);
 }
 
-static int mov_write_uuidusmt_tag (ByteIOContext *pb, AVFormatContext *s)
+static int mov_write_3gp_udta_tag(ByteIOContext *pb, AVFormatContext *s,
+                                  const char *tag, const char *str)
 {
-    size_t len, size;
-    offset_t pos, curpos;
+    offset_t pos = url_ftell(pb);
+    if (!utf8len(str))
+        return 0;
+    put_be32(pb, 0);   /* size */
+    put_tag (pb, tag); /* type */
+    put_be32(pb, 0);   /* version + flags */
+    if (!strcmp(tag, &quot;yrrc&quot;))
+        put_be16(pb, s-&gt;year);
+    else {
+        put_be16(pb, language_code(&quot;eng&quot;)); /* language */
+        ascii_to_wc(pb, str);
+        if (!strcmp(tag, &quot;albm&quot;) &amp;&amp; s-&gt;year)
+            put_byte(pb, s-&gt;year);
+    }
+    return updateSize(pb, pos);
+}
 
-    size = 0;
+static int mov_write_udta_tag(ByteIOContext *pb, MOVContext *mov,
+                              AVFormatContext *s)
+{
+    int i;
+    int bitexact = 0;
+
+    for (i = 0; i &lt; s-&gt;nb_streams; i++)
+        if (mov-&gt;tracks[i].enc-&gt;flags &amp; CODEC_FLAG_BITEXACT) {
+            bitexact = 1;
+            break;
+        }
+
+    if (!bitexact &amp;&amp; (s-&gt;title[0] || s-&gt;author[0] || s-&gt;album[0] || s-&gt;year ||
+                      s-&gt;comment[0] || s-&gt;genre[0]  || s-&gt;track)) {
+        offset_t pos = url_ftell(pb);
+
+        put_be32(pb, 0); /* size */
+        put_tag(pb, &quot;udta&quot;);
+
+        if (mov-&gt;mode &amp; MODE_3GP) {
+            mov_write_3gp_udta_tag(pb, s, &quot;titl&quot;, s-&gt;title);
+            mov_write_3gp_udta_tag(pb, s, &quot;auth&quot;, s-&gt;author);
+            mov_write_3gp_udta_tag(pb, s, &quot;gnre&quot;, s-&gt;genre);
+            mov_write_3gp_udta_tag(pb, s, &quot;dscp&quot;, s-&gt;comment);
+            mov_write_3gp_udta_tag(pb, s, &quot;albm&quot;, s-&gt;album);
+            mov_write_3gp_udta_tag(pb, s, &quot;cprt&quot;, s-&gt;copyright);
+            mov_write_3gp_udta_tag(pb, s, &quot;yrrc&quot;, &quot;nil&quot;);
+        } else if (mov-&gt;mode == MODE_MOV) { // the title field breaks gtkpod with mp4 and my suspicion is that stuff is not valid in mp4
+            mov_write_string_tag(pb, &quot;\251nam&quot;, s-&gt;title         , 0);
+            mov_write_string_tag(pb, &quot;\251aut&quot;, s-&gt;author        , 0);
+            mov_write_string_tag(pb, &quot;\251alb&quot;, s-&gt;album         , 0);
+            mov_write_day_tag(pb, s-&gt;year, 0);
+            mov_write_string_tag(pb, &quot;\251enc&quot;, LIBAVFORMAT_IDENT, 0);
+            mov_write_string_tag(pb, &quot;\251des&quot;, s-&gt;comment       , 0);
+            mov_write_string_tag(pb, &quot;\251gen&quot;, s-&gt;genre         , 0);
+            mov_write_string_tag(pb, &quot;\251cpy&quot;, s-&gt;copyright     , 0);
+        } else {
+            /* iTunes meta data */
+            mov_write_meta_tag(pb, mov, s);
+        }
+        return updateSize(pb, pos);
+    }
+
+    return 0;
+}
+
+static void mov_write_psp_udta_tag(ByteIOContext *pb,
+                                  const char *str, const char *lang, int type)
+{
+    int len = utf8len(str)+1;
+    if(len&lt;=0)
+        return;
+    put_be16(pb, len*2+10);            /* size */
+    put_be32(pb, type);                /* type */
+    put_be16(pb, language_code(lang)); /* language */
+    put_be16(pb, 0x01);                /* ? */
+    ascii_to_wc(pb, str);
+}
+
+static int mov_write_uuidusmt_tag(ByteIOContext *pb, AVFormatContext *s)
+{
+    offset_t pos, pos2;
+
     if (s-&gt;title[0]) {
         pos = url_ftell(pb);
         put_be32(pb, 0); /* size placeholder*/
         put_tag(pb, &quot;uuid&quot;);
         put_tag(pb, &quot;USMT&quot;);
-        put_be32(pb, 0x21d24fce ); /* 96 bit UUID */
-        put_be32(pb, 0xbb88695c );
-        put_be32(pb, 0xfac9c740 );
-        size += 24;
+        put_be32(pb, 0x21d24fce); /* 96 bit UUID */
+        put_be32(pb, 0xbb88695c);
+        put_be32(pb, 0xfac9c740);
 
+        pos2 = url_ftell(pb);
         put_be32(pb, 0); /* size placeholder*/
         put_tag(pb, &quot;MTDT&quot;);
         put_be16(pb, 4);
-        size += 10;
 
         // ?
         put_be16(pb, 0x0C);                 /* size */
@@ -1277,55 +1386,17 @@
         put_be16(pb, language_code(&quot;und&quot;)); /* language */
         put_be16(pb, 0x0);                  /* ? */
         put_be16(pb, 0x021C);               /* data */
-        size += 12;
 
-        // Encoder
-        len = utf8len(LIBAVCODEC_IDENT)+1;
-        if(len&lt;=0)
-            goto not_utf8;
-        put_be16(pb, len*2+10);             /* size */
-        put_be32(pb, 0x04);                 /* type */
-        put_be16(pb, language_code(&quot;eng&quot;)); /* language */
-        put_be16(pb, 0x01);                 /* ? */
-        ascii_to_wc(pb, LIBAVCODEC_IDENT);
-        size += len*2+10;
-
-        // Title
-        len = utf8len(s-&gt;title)+1;
-        if(len&lt;=0)
-            goto not_utf8;
-        put_be16(pb, len*2+10);             /* size */
-        put_be32(pb, 0x01);                 /* type */
-        put_be16(pb, language_code(&quot;eng&quot;)); /* language */
-        put_be16(pb, 0x01);                 /* ? */
-        ascii_to_wc (pb, s-&gt;title);
-        size += len*2+10;
-
-        // Date
+        mov_write_psp_udta_tag(pb, LIBAVCODEC_IDENT,      &quot;eng&quot;, 0x04);
+        mov_write_psp_udta_tag(pb, s-&gt;title,              &quot;eng&quot;, 0x01);
 //        snprintf(dt,32,&quot;%04d/%02d/%02d %02d:%02d:%02d&quot;,t_st-&gt;tm_year+1900,t_st-&gt;tm_mon+1,t_st-&gt;tm_mday,t_st-&gt;tm_hour,t_st-&gt;tm_min,t_st-&gt;tm_sec);
-        len = utf8len(&quot;2006/04/01 11:11:11&quot;)+1;
-        if(len&lt;=0)
-            goto not_utf8;
-        put_be16(pb, len*2+10);    /* size */
-        put_be32(pb, 0x03);        /* type */
-        put_be16(pb, language_code(&quot;und&quot;)); /* language */
-        put_be16(pb, 0x01);        /* ? */
-        ascii_to_wc (pb, &quot;2006/04/01 11:11:11&quot;);
-        size += len*2+10;
+        mov_write_psp_udta_tag(pb, &quot;2006/04/01 11:11:11&quot;, &quot;und&quot;, 0x03);
 
-        // size
-        curpos = url_ftell(pb);
-        url_fseek(pb, pos, SEEK_SET);
-        put_be32(pb, size);
-        url_fseek(pb, pos+24, SEEK_SET);
-        put_be32(pb, size-24);
-        url_fseek(pb, curpos, SEEK_SET);
+        updateSize(pb, pos2);
+        return updateSize(pb, pos);
     }
 
-    return size;
-not_utf8:
-    av_log(s, AV_LOG_ERROR, &quot;not utf8\n&quot;);
-    return -1;
+    return 0;
 }
 
 static int mov_write_moov_tag(ByteIOContext *pb, MOVContext *mov,
@@ -1348,7 +1419,7 @@
     //mov_write_iods_tag(pb, mov);
     for (i=0; i&lt;mov-&gt;nb_streams; i++) {
         if(mov-&gt;tracks[i].entry &gt; 0) {
-            mov_write_trak_tag(pb, &amp;(mov-&gt;tracks[i]));
+            mov_write_trak_tag(pb, &amp;(mov-&gt;tracks[i]), s-&gt;streams[i]);
         }
     }
 
@@ -1360,7 +1431,7 @@
     return updateSize(pb, pos);
 }
 
-static int mov_write_mdat_tag(ByteIOContext *pb, MOVContext* mov)
+static int mov_write_mdat_tag(ByteIOContext *pb, MOVContext *mov)
 {
     put_be32(pb, 8);    // placeholder for extended size field (64 bit)
     put_tag(pb, mov-&gt;mode == MODE_MOV ? &quot;wide&quot; : &quot;free&quot;);
@@ -1372,36 +1443,60 @@
 }
 
 /* TODO: This needs to be more general */
-static void mov_write_ftyp_tag (ByteIOContext *pb, AVFormatContext *s)
+static int mov_write_ftyp_tag(ByteIOContext *pb, AVFormatContext *s)
 {
     MOVContext *mov = s-&gt;priv_data;
+    offset_t pos = url_ftell(pb);
+    int has_h264 = 0, has_video = 0;
+    int minor = 0x200;
+    int i;
 
-    put_be32(pb, 0x14 ); /* size */
+    for (i = 0; i &lt; s-&gt;nb_streams; i++) {
+        AVStream *st = s-&gt;streams[i];
+        if (st-&gt;codec-&gt;codec_type == CODEC_TYPE_VIDEO)
+            has_video = 1;
+        if (st-&gt;codec-&gt;codec_id == CODEC_ID_H264)
+            has_h264 = 1;
+    }
+
+    put_be32(pb, 0); /* size */
     put_tag(pb, &quot;ftyp&quot;);
 
-    if ( mov-&gt;mode == MODE_3GP )
-        put_tag(pb, &quot;3gp4&quot;);
-    else if ( mov-&gt;mode == MODE_3G2 )
-        put_tag(pb, &quot;3g2a&quot;);
-    else if ( mov-&gt;mode == MODE_PSP )
+    if (mov-&gt;mode == MODE_3GP) {
+        put_tag(pb, has_h264 ? &quot;3gp6&quot;  : &quot;3gp4&quot;);
+        minor =     has_h264 ?   0x100 :   0x200;
+    } else if (mov-&gt;mode &amp; MODE_3G2) {
+        put_tag(pb, has_h264 ? &quot;3g2b&quot;  : &quot;3g2a&quot;);
+        minor =     has_h264 ? 0x20000 : 0x10000;
+    }else if (mov-&gt;mode == MODE_PSP)
         put_tag(pb, &quot;MSNV&quot;);
-    else if ( mov-&gt;mode == MODE_MP4 )
+    else if (mov-&gt;mode == MODE_MP4)
         put_tag(pb, &quot;isom&quot;);
+    else if (mov-&gt;mode == MODE_IPOD)
+        put_tag(pb, has_video ? &quot;M4V &quot;:&quot;M4A &quot;);
     else
         put_tag(pb, &quot;qt  &quot;);
 
-    put_be32(pb, 0x200 );
+    put_be32(pb, minor);
 
-    if ( mov-&gt;mode == MODE_3GP )
-        put_tag(pb, &quot;3gp4&quot;);
-    else if ( mov-&gt;mode == MODE_3G2 )
-        put_tag(pb, &quot;3g2a&quot;);
-    else if ( mov-&gt;mode == MODE_PSP )
+    if(mov-&gt;mode == MODE_MOV)
+        put_tag(pb, &quot;qt  &quot;);
+    else{
+        put_tag(pb, &quot;isom&quot;);
+        put_tag(pb, &quot;iso2&quot;);
+        if(has_h264)
+            put_tag(pb, &quot;avc1&quot;);
+    }
+
+    if (mov-&gt;mode == MODE_3GP)
+        put_tag(pb, has_h264 ? &quot;3gp6&quot;:&quot;3gp4&quot;);
+    else if (mov-&gt;mode &amp; MODE_3G2)
+        put_tag(pb, has_h264 ? &quot;3g2b&quot;:&quot;3g2a&quot;);
+    else if (mov-&gt;mode == MODE_PSP)
         put_tag(pb, &quot;MSNV&quot;);
-    else if ( mov-&gt;mode == MODE_MP4 )
+    else if (mov-&gt;mode == MODE_MP4)
         put_tag(pb, &quot;mp41&quot;);
-    else
-        put_tag(pb, &quot;qt  &quot;);
+    return updateSize(pb, pos);
 }
 
 static void mov_write_uuidprof_tag(ByteIOContext *pb, AVFormatContext *s)
@@ -1413,49 +1508,49 @@
     int audio_kbitrate= AudioCodec-&gt;bit_rate / 1000;
     int video_kbitrate= FFMIN(VideoCodec-&gt;bit_rate / 1000, 800 - audio_kbitrate);
 
-    put_be32(pb, 0x94 ); /* size */
+    put_be32(pb, 0x94); /* size */
     put_tag(pb, &quot;uuid&quot;);
     put_tag(pb, &quot;PROF&quot;);
 
-    put_be32(pb, 0x21d24fce ); /* 96 bit UUID */
-    put_be32(pb, 0xbb88695c );
-    put_be32(pb, 0xfac9c740 );
+    put_be32(pb, 0x21d24fce); /* 96 bit UUID */
+    put_be32(pb, 0xbb88695c);
+    put_be32(pb, 0xfac9c740);
 
-    put_be32(pb, 0x0 );  /* ? */
-    put_be32(pb, 0x3 );  /* 3 sections ? */
+    put_be32(pb, 0x0);  /* ? */
+    put_be32(pb, 0x3);  /* 3 sections ? */
 
-    put_be32(pb, 0x14 ); /* size */
+    put_be32(pb, 0x14); /* size */
     put_tag(pb, &quot;FPRF&quot;);
-    put_be32(pb, 0x0 );  /* ? */
-    put_be32(pb, 0x0 );  /* ? */
-    put_be32(pb, 0x0 );  /* ? */
+    put_be32(pb, 0x0);  /* ? */
+    put_be32(pb, 0x0);  /* ? */
+    put_be32(pb, 0x0);  /* ? */
 
-    put_be32(pb, 0x2c );  /* size */
+    put_be32(pb, 0x2c);  /* size */
     put_tag(pb, &quot;APRF&quot;);   /* audio */
-    put_be32(pb, 0x0 );
-    put_be32(pb, 0x2 );   /* TrackID */
+    put_be32(pb, 0x0);
+    put_be32(pb, 0x2);   /* TrackID */
     put_tag(pb, &quot;mp4a&quot;);
-    put_be32(pb, 0x20f );
-    put_be32(pb, 0x0 );
+    put_be32(pb, 0x20f);
+    put_be32(pb, 0x0);
     put_be32(pb, audio_kbitrate);
     put_be32(pb, audio_kbitrate);
-    put_be32(pb, AudioRate );
-    put_be32(pb, AudioCodec-&gt;channels );
+    put_be32(pb, AudioRate);
+    put_be32(pb, AudioCodec-&gt;channels);
 
-    put_be32(pb, 0x34 );  /* size */
+    put_be32(pb, 0x34);  /* size */
     put_tag(pb, &quot;VPRF&quot;);   /* video */
-    put_be32(pb, 0x0 );
-    put_be32(pb, 0x1 );    /* TrackID */
+    put_be32(pb, 0x0);
+    put_be32(pb, 0x1);    /* TrackID */
     if (VideoCodec-&gt;codec_id == CODEC_ID_H264) {
         put_tag(pb, &quot;avc1&quot;);
-        put_be16(pb, 0x014D );
-        put_be16(pb, 0x0015 );
+        put_be16(pb, 0x014D);
+        put_be16(pb, 0x0015);
     } else {
         put_tag(pb, &quot;mp4v&quot;);
-        put_be16(pb, 0x0000 );
-        put_be16(pb, 0x0103 );
+        put_be16(pb, 0x0000);
+        put_be16(pb, 0x0103);
     }
-    put_be32(pb, 0x0 );
+    put_be32(pb, 0x0);
     put_be32(pb, video_kbitrate);
     put_be32(pb, video_kbitrate);
     put_be32(pb, FrameRate);
@@ -1481,13 +1576,14 @@
 
     if (s-&gt;oformat != NULL) {
         if (!strcmp(&quot;3gp&quot;, s-&gt;oformat-&gt;name)) mov-&gt;mode = MODE_3GP;
-        else if (!strcmp(&quot;3g2&quot;, s-&gt;oformat-&gt;name)) mov-&gt;mode = MODE_3G2;
+        else if (!strcmp(&quot;3g2&quot;, s-&gt;oformat-&gt;name)) mov-&gt;mode = MODE_3GP|MODE_3G2;
         else if (!strcmp(&quot;mov&quot;, s-&gt;oformat-&gt;name)) mov-&gt;mode = MODE_MOV;
         else if (!strcmp(&quot;psp&quot;, s-&gt;oformat-&gt;name)) mov-&gt;mode = MODE_PSP;
+        else if (!strcmp(&quot;ipod&quot;,s-&gt;oformat-&gt;name)) mov-&gt;mode = MODE_IPOD;
 
         mov_write_ftyp_tag(pb,s);
-        if ( mov-&gt;mode == MODE_PSP ) {
-            if ( s-&gt;nb_streams != 2 ) {
+        if (mov-&gt;mode == MODE_PSP) {
+            if (s-&gt;nb_streams != 2) {
                 av_log(s, AV_LOG_ERROR, &quot;PSP mode need one video and one audio stream\n&quot;);
                 return -1;
             }
@@ -1502,27 +1598,38 @@
         track-&gt;enc = st-&gt;codec;
         track-&gt;language = ff_mov_iso639_to_lang(st-&gt;language, mov-&gt;mode != MODE_MOV);
         track-&gt;mode = mov-&gt;mode;
+        track-&gt;tag = mov_find_codec_tag(s, track);
+        if (!track-&gt;tag) {
+            av_log(s, AV_LOG_ERROR, &quot;track %d: could not find tag, &quot;
+                   &quot;codec not currently supported in container\n&quot;, i);
+            return -1;
+        }
         if(st-&gt;codec-&gt;codec_type == CODEC_TYPE_VIDEO){
-            track-&gt;tag = mov_find_video_codec_tag(s, track);
             track-&gt;timescale = st-&gt;codec-&gt;time_base.den;
             av_set_pts_info(st, 64, 1, st-&gt;codec-&gt;time_base.den);
-            if (track-&gt;timescale &gt; 100000)
-                av_log(NULL, AV_LOG_WARNING,
+            if (track-&gt;mode == MODE_MOV &amp;&amp; track-&gt;timescale &gt; 100000)
+                av_log(s, AV_LOG_WARNING,
                        &quot;WARNING codec timebase is very high. If duration is too long,\n&quot;
                        &quot;file may not be playable by quicktime. Specify a shorter timebase\n&quot;
                        &quot;or choose different container.\n&quot;);
         }else if(st-&gt;codec-&gt;codec_type == CODEC_TYPE_AUDIO){
-            track-&gt;tag = mov_find_audio_codec_tag(s, track);
             track-&gt;timescale = st-&gt;codec-&gt;sample_rate;
             av_set_pts_info(st, 64, 1, st-&gt;codec-&gt;sample_rate);
-            if(!st-&gt;codec-&gt;frame_size){
+            if(!st-&gt;codec-&gt;frame_size &amp;&amp; !av_get_bits_per_sample(st-&gt;codec-&gt;codec_id)) {
                 av_log(s, AV_LOG_ERROR, &quot;track %d: codec frame size is not set\n&quot;, i);
                 return -1;
             }else if(st-&gt;codec-&gt;frame_size &gt; 1){ /* assume compressed audio */
                 track-&gt;audio_vbr = 1;
             }else{
+                st-&gt;codec-&gt;frame_size = 1;
                 track-&gt;sampleSize = (av_get_bits_per_sample(st-&gt;codec-&gt;codec_id) &gt;&gt; 3) * st-&gt;codec-&gt;channels;
             }
+            if(track-&gt;mode != MODE_MOV &amp;&amp;
+               track-&gt;enc-&gt;codec_id == CODEC_ID_MP3 &amp;&amp; track-&gt;enc-&gt;sample_rate &lt; 16000){
+                av_log(s, AV_LOG_ERROR, &quot;track %d: muxing mp3 at %dhz is not supported\n&quot;,
+                       i, track-&gt;enc-&gt;sample_rate);
+                return -1;
+            }
         }
     }
 
@@ -1558,7 +1665,7 @@
             samplesInChunk++;
         }
         if(samplesInChunk &gt; 1){
-            av_log(s, AV_LOG_ERROR, &quot;fatal error, input is not a single packet, inplement a AVParser for it\n&quot;);
+            av_log(s, AV_LOG_ERROR, &quot;fatal error, input is not a single packet, implement a AVParser for it\n&quot;);
             return -1;
         }
     } else if (trk-&gt;sampleSize)
@@ -1576,9 +1683,19 @@
     if (enc-&gt;codec_id == CODEC_ID_H264 &amp;&amp; trk-&gt;vosLen &gt; 0 &amp;&amp; *(uint8_t *)trk-&gt;vosData != 1) {
         /* from x264 or from bytestream h264 */
         /* nal reformating needed */
-        avc_parse_nal_units(&amp;pkt-&gt;data, &amp;pkt-&gt;size);
+        int ret = ff_avc_parse_nal_units(pkt-&gt;data, &amp;pkt-&gt;data, &amp;pkt-&gt;size);
+        if (ret &lt; 0)
+            return ret;
         assert(pkt-&gt;size);
         size = pkt-&gt;size;
+    } else if ((enc-&gt;codec_id == CODEC_ID_DNXHD ||
+                enc-&gt;codec_id == CODEC_ID_AC3) &amp;&amp; !trk-&gt;vosLen) {
+        /* copy frame to create needed atoms */
+        trk-&gt;vosLen = size;
+        trk-&gt;vosData = av_malloc(size);
+        if (!trk-&gt;vosData)
+            return AVERROR(ENOMEM);
+        memcpy(trk-&gt;vosData, pkt-&gt;data, size);
     }
 
     if (!(trk-&gt;entry % MOV_INDEX_CLUSTER_SIZE)) {
@@ -1594,14 +1711,16 @@
     trk-&gt;cluster[trk-&gt;entry].dts = pkt-&gt;dts;
     trk-&gt;trackDuration = pkt-&gt;dts - trk-&gt;cluster[0].dts + pkt-&gt;duration;
 
-    if(enc-&gt;codec_type == CODEC_TYPE_VIDEO) {
-        if (pkt-&gt;dts != pkt-&gt;pts)
-            trk-&gt;hasBframes = 1;
-        trk-&gt;cluster[trk-&gt;entry].cts = pkt-&gt;pts - pkt-&gt;dts;
-        trk-&gt;cluster[trk-&gt;entry].key_frame = !!(pkt-&gt;flags &amp; PKT_FLAG_KEY);
-        if(trk-&gt;cluster[trk-&gt;entry].key_frame)
-            trk-&gt;hasKeyframes++;
+    if (pkt-&gt;pts == AV_NOPTS_VALUE) {
+        av_log(s, AV_LOG_WARNING, &quot;pts has no value\n&quot;);
+        pkt-&gt;pts = pkt-&gt;dts;
     }
+    if (pkt-&gt;dts != pkt-&gt;pts)
+        trk-&gt;hasBframes = 1;
+    trk-&gt;cluster[trk-&gt;entry].cts = pkt-&gt;pts - pkt-&gt;dts;
+    trk-&gt;cluster[trk-&gt;entry].key_frame = !!(pkt-&gt;flags &amp; PKT_FLAG_KEY);
+    if(trk-&gt;cluster[trk-&gt;entry].key_frame)
+        trk-&gt;hasKeyframes++;
     trk-&gt;entry++;
     trk-&gt;sampleCount += samplesInChunk;
     mov-&gt;mdat_size += size;
@@ -1639,7 +1758,7 @@
     for (i=0; i&lt;mov-&gt;nb_streams; i++) {
         av_freep(&amp;mov-&gt;tracks[i].cluster);
 
-        if( mov-&gt;tracks[i].vosLen ) av_free( mov-&gt;tracks[i].vosData );
+        if(mov-&gt;tracks[i].vosLen) av_free(mov-&gt;tracks[i].vosData);
 
     }
 
@@ -1683,7 +1802,7 @@
     &quot;mp4&quot;,
     &quot;mp4 format&quot;,
     &quot;application/mp4&quot;,
-    &quot;mp4,m4a&quot;,
+    &quot;mp4&quot;,
     sizeof(MOVContext),
     CODEC_ID_AAC,
     CODEC_ID_MPEG4,
@@ -1723,6 +1842,22 @@
     .flags = AVFMT_GLOBALHEADER,
 };
 #endif
+#ifdef CONFIG_IPOD_MUXER
+AVOutputFormat ipod_muxer = {
+    &quot;ipod&quot;,
+	&quot;iPod H.264 MP4 format&quot;,
+    &quot;application/mp4&quot;,
+    &quot;m4v,m4a&quot;,
+    sizeof(MOVContext),
+    CODEC_ID_AAC,
+    CODEC_ID_H264,
+    mov_write_header,
+    mov_write_packet,
+    mov_write_trailer,
+    .flags = AVFMT_GLOBALHEADER,
+};
+#endif
+
 /* MEANX */
 int movenc_init(void)
 {
@@ -1731,6 +1866,7 @@
     av_register_output_format(&amp;mp4_muxer);
     av_register_output_format(&amp;psp_muxer);
     av_register_output_format(&amp;tg2_muxer);
+	av_register_output_format(&amp;ipod_muxer);
     return 0;
 }
 /* MEANX */

Modified: branches/avidemux_2.4_branch/cmake/lavcodec.cmake
===================================================================
--- branches/avidemux_2.4_branch/cmake/lavcodec.cmake	2008-09-18 13:38:09 UTC (rev 4359)
+++ branches/avidemux_2.4_branch/cmake/lavcodec.cmake	2008-09-18 14:21:01 UTC (rev 4360)
@@ -14,6 +14,7 @@
 	SET(CONFIG_ZLIB 1)
 
 	SET(CONFIG_MUXERS 1)
+	SET(CONFIG_IPOD_MUXER 1)
 	SET(CONFIG_MOV_MUXER 1)
 	SET(CONFIG_MP4_MUXER 1)
 	SET(CONFIG_PSP_MUXER 1)

Modified: branches/avidemux_2.4_branch/config.h.cmake
===================================================================
--- branches/avidemux_2.4_branch/config.h.cmake	2008-09-18 13:38:09 UTC (rev 4359)
+++ branches/avidemux_2.4_branch/config.h.cmake	2008-09-18 14:21:01 UTC (rev 4360)
@@ -64,6 +64,7 @@
 #cmakedefine CONFIG_ZLIB
 
 #cmakedefine CONFIG_MUXERS
+#cmakedefine CONFIG_IPOD_MUXER
 #cmakedefine CONFIG_MOV_MUXER
 #cmakedefine CONFIG_MP4_MUXER
 #cmakedefine CONFIG_PSP_MUXER


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001599.html">[Avidemux-svn-commit] r4359 -	branches/avidemux_2.4_branch/avidemux/ADM_encoder
</A></li>
	<LI>Next message: <A HREF="001601.html">[Avidemux-svn-commit] r4361 -	branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavcodec
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1600">[ date ]</a>
              <a href="thread.html#1600">[ thread ]</a>
              <a href="subject.html#1600">[ subject ]</a>
              <a href="author.html#1600">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">More information about the Avidemux-svn-commit
mailing list</a><br>
</body></html>
