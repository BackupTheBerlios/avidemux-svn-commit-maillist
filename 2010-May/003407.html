<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Avidemux-svn-commit] r6207 - in	branches/avidemux_2.6_branch_mean/avidemux: . common	common/ADM_pyScript common/ADM_pyScript/include	common/ADM_pyScript/src common/ADM_script2	common/ADM_script2/js common/ADM_script2/py	common/ADM_script2/py/include common/ADM_script2/src
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/avidemux-svn-commit/2010-May/index.html" >
   <LINK REL="made" HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r6207%20-%20in%0A%09branches/avidemux_2.6_branch_mean/avidemux%3A%20.%20common%0A%09common/ADM_pyScript%20common/ADM_pyScript/include%0A%09common/ADM_pyScript/src%20common/ADM_script2%0A%09common/ADM_script2/js%20common/ADM_script2/py%0A%09common/ADM_script2/py/include%20common/ADM_script2/src&In-Reply-To=%3C201005201522.o4KFMrOw014324%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="003406.html">
   <LINK REL="Next"  HREF="003408.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Avidemux-svn-commit] r6207 - in	branches/avidemux_2.6_branch_mean/avidemux: . common	common/ADM_pyScript common/ADM_pyScript/include	common/ADM_pyScript/src common/ADM_script2	common/ADM_script2/js common/ADM_script2/py	common/ADM_script2/py/include common/ADM_script2/src</H1>
    <B>mean at BerliOS</B> 
    <A HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r6207%20-%20in%0A%09branches/avidemux_2.6_branch_mean/avidemux%3A%20.%20common%0A%09common/ADM_pyScript%20common/ADM_pyScript/include%0A%09common/ADM_pyScript/src%20common/ADM_script2%0A%09common/ADM_script2/js%20common/ADM_script2/py%0A%09common/ADM_script2/py/include%20common/ADM_script2/src&In-Reply-To=%3C201005201522.o4KFMrOw014324%40sheep.berlios.de%3E"
       TITLE="[Avidemux-svn-commit] r6207 - in	branches/avidemux_2.6_branch_mean/avidemux: . common	common/ADM_pyScript common/ADM_pyScript/include	common/ADM_pyScript/src common/ADM_script2	common/ADM_script2/js common/ADM_script2/py	common/ADM_script2/py/include common/ADM_script2/src">mean at mail.berlios.de
       </A><BR>
    <I>Thu May 20 17:22:53 CEST 2010</I>
    <P><UL>
        <LI>Previous message: <A HREF="003406.html">[Avidemux-svn-commit] r6206 - in branches/avidemux_2.6_branch_mean:	avidemux avidemux/common avidemux/common/ADM_pyScript	avidemux/common/ADM_pyScript/include	avidemux/common/ADM_pyScript/src avidemux/common/ADM_script2/src	avidemux/qt4/ADM_userInterfaces/ADM_gui cmake
</A></li>
        <LI>Next message: <A HREF="003408.html">[Avidemux-svn-commit] r6208 - in	branches/avidemux_2.6_branch_mean/avidemux: . common	common/ADM_editor common/ADM_script2	common/ADM_script2/include common/ADM_script2/js	common/ADM_script2/js/src_dialogFactory common/ADM_script2/py	common/ADM_script2/py/include common/ADM_script2/src	common/ADM_script2/src_dialogFactory	qt4/ADM_userInterfaces/ADM_shell
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3407">[ date ]</a>
              <a href="thread.html#3407">[ thread ]</a>
              <a href="subject.html#3407">[ subject ]</a>
              <a href="author.html#3407">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: mean
Date: 2010-05-20 17:22:52 +0200 (Thu, 20 May 2010)
New Revision: 6207

Added:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/js/
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/js/ADM_jsAudio.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/js/ADM_jsAvidemux.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/js/ADM_jsAvidemuxInfo.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/js/ADM_jsAvidemux_js.c
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/js/ADM_jsAvidemux_js.idl
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/js/ADM_jsDebug.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/js/ADM_jsEditor.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/js/ADM_jsEditor_js.c
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/js/ADM_jsEditor_js.idl
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/js/ADM_jsIf.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/js/ADM_jsIf_js.c
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/js/ADM_jsIf_js.idl
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/js/ADM_jsTestFactory.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/js/ADM_jsTestFactory_js.c
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/js/ADM_jsTestFactory_js.idl
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/js/ADM_jsUtils.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/js/ADM_jsVideo.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/js/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/js/idl.make
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/js/updateIdl.sh
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/py/
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/py/ADM_pyAdm.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/py/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/py/adm.admPy
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/py/adm_gen.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/py/adm_gen.h
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/py/include/
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/py/include/ADM_pyIf.h
Removed:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_pyScript/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_pyScript/include/ADM_pyIf.h
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_pyScript/src/ADM_pyAdm.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_pyScript/src/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_pyScript/src/adm.admPy
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_pyScript/src/adm_gen.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_pyScript/src/adm_gen.h
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsAudio.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsAvidemux.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsAvidemuxInfo.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsAvidemux_js.c
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsAvidemux_js.idl
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsDebug.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsEditor.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsEditor_js.c
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsEditor_js.idl
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsIf.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsIf_js.c
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsIf_js.idl
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsTestFactory.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsTestFactory_js.c
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsTestFactory_js.idl
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsUtils.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsVideo.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/idl.make
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/updateIdl.sh
Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/avidemux/commonCmakeApplication.cmake
Log:
[script] restructure

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_pyScript/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_pyScript/CMakeLists.txt	2010-05-20 15:22:49 UTC (rev 6206)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_pyScript/CMakeLists.txt	2010-05-20 15:22:52 UTC (rev 6207)
@@ -1,2 +0,0 @@
-subdirs (src)
-#subdirs (src_dialogFactory)

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_pyScript/include/ADM_pyIf.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_pyScript/include/ADM_pyIf.h	2010-05-20 15:22:49 UTC (rev 6206)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_pyScript/include/ADM_pyIf.h	2010-05-20 15:22:52 UTC (rev 6207)
@@ -1,21 +0,0 @@
-/**
-    \file ADM_pyIf.h
-    \brief Interface for python script 
-    \author mean <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A> 2010
-
-*/
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#ifndef ADM_PY_IF_H
-#define ADM_PY_IF_H
-
-bool parseTinyPyScript(const char *name);
-bool interactiveTinyPy(void);
-
-#endif
\ No newline at end of file

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_pyScript/src/ADM_pyAdm.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_pyScript/src/ADM_pyAdm.cpp	2010-05-20 15:22:49 UTC (rev 6206)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_pyScript/src/ADM_pyAdm.cpp	2010-05-20 15:22:52 UTC (rev 6207)
@@ -1,130 +0,0 @@
-/**
-    \file ADM_pyADM.cpp
-    \author mean <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A> 2010
-
-*/
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-#include &quot;ADM_default.h&quot;
-#include &lt;stdarg.h&gt;
-#include &lt;vector&gt;
-#include &quot;ADM_editor/ADM_edit.hxx&quot;
-#include &quot;ADM_coreTinyPy/include/tinypy.h&quot;
-#include &quot;ADM_coreTinyPy/include/ADM_tinypy.h&quot;
-#include &quot;ADM_script2/include/ADM_jsShell.h&quot;
-#include &quot;A_functions.h&quot;
-
-#include &quot;adm_gen.h&quot;
-
-#include &quot;adm_gen.cpp&quot;
-/**
-    \fn    parseTinyPyScript
-    \brief Execute a tinyPy script
-*/
-bool parseTinyPyScript(const char *name)
-{
-        tinyPy py;
-        py.init();
-        py.registerFuncs(&quot;adm&quot;,adm_functions);
-        return py.execFile(name);
-}
-
-/**
-    \fn jsEvaluate
-*/
-static tinyPy *myPy=NULL;
-static bool pyEvaluate(const char *str)
-{
-    ADM_assert(myPy);
-    return myPy-&gt;execString(str);
-}
-/**
-    \fn    interactiveTinyPy
-    \brief interprete &amp; execute python script (interactive)
-*/
-bool interactiveTinyPy(void)
-{
-    myPy=new tinyPy;
-    myPy-&gt;init();
-    myPy-&gt;registerFuncs(&quot;adm&quot;,adm_functions);
-
-    ADM_startShell(pyEvaluate);
-    delete myPy;
-    myPy=NULL;
-	A_Resync();
-    ADM_info(&quot;Ending py shell...\n&quot;);
-	return true;
-}
-
-int  py_loadVideo (char *vid )
-{
-    printf(&quot;pyLoadVideo %s\n&quot;,vid);
-    return 0;
-}
-int  py_clearSegments (void)
-{
-    printf(&quot;py_clearSegments\n&quot;);
-    return 0;
-}
-
-int  py_appendVideo (char *vid )
-{
-    printf(&quot;py_appendVideo %s\n&quot;,vid);
-    return 0;
-}
-
-int  py_addSegment (int ,float , float )
-{
-    printf(&quot;py_addSegment\n&quot;);
-    return 0;
-}
-
-int  py_setPostProc (int a,int b, int c)
-{
-    printf(&quot;py_setPostProc\n&quot;);
-    return 0;
-}
-
-int  py_getWidth (void)
-{
-    printf(&quot;py_getWidth\n&quot;);
-    return 0;
-}
-
-int  py_getHeight (void)
-{
-    printf(&quot;py_getHeight\n&quot;);
-    return 0;
-}
-
-int  py_getFps1000 (void)
-{
-    printf(&quot;py_getFps1000\n&quot;);
-    return 0;
-}
-
-int  py_audioReset (void)
-{
-    printf(&quot;py_audioReset\n&quot;);
-    return 0;
-}
-
-int  py_audioMixer (char *mixer )
-{
-    printf(&quot;py_audioMixer\n&quot;);
-    return 0;
-}
-
-int  py_clearVideoFilters (void)
-{
-    printf(&quot;py_clearVideoFilters\n&quot;);
-    return 0;
-}
-

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_pyScript/src/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_pyScript/src/CMakeLists.txt	2010-05-20 15:22:49 UTC (rev 6206)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_pyScript/src/CMakeLists.txt	2010-05-20 15:22:52 UTC (rev 6207)
@@ -1,7 +0,0 @@
-SET(ADM_script_SRCS
-        ADM_pyAdm.cpp
-)
-
-ADD_LIBRARY(ADM_pyScript6 STATIC ${ADM_script_SRCS})
-include_directories(../include)
-include_directories(${AVIDEMUX_TOP_SOURCE_DIR}/avidemux_core/ADM_coreTinyPy/include)

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_pyScript/src/adm.admPy
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_pyScript/src/adm.admPy	2010-05-20 15:22:49 UTC (rev 6206)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_pyScript/src/adm.admPy	2010-05-20 15:22:52 UTC (rev 6207)
@@ -1,13 +0,0 @@
-/* FUNC */ int loadVideo      (char * ) 
-/* FUNC */ int clearSegments  (void) 
-/* FUNC */ int appendVideo    (char * ) 
-/* FUNC */ int addSegment     (int ,float , float ) 
-/* FUNC */ int setPostProc    (int ,int , int ) 
-/* FUNC */ int getWidth       (void) 
-/* FUNC */ int getHeight      (void) 
-/* FUNC */ int getFps1000     (void) 
-#/* FUNC */ char* getVideoCodec(void) 
-/* FUNC */ int audioReset     (void) 
-/* FUNC */ int audioMixer     (char * ) 
-/* FUNC */ int clearVideoFilters   (void) 
-

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_pyScript/src/adm_gen.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_pyScript/src/adm_gen.cpp	2010-05-20 15:22:49 UTC (rev 6206)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_pyScript/src/adm_gen.cpp	2010-05-20 15:22:52 UTC (rev 6207)
@@ -1,89 +0,0 @@
-//int  loadVideo &lt;char * &gt;
-tp_obj zzpy_loadVideo(TP)
-{
-char * p0=(char *)TP_STR().string.val;
-int r=py_loadVideo(p0); 
-return tp_number(r);
-}
-//int  clearSegments &lt;void&gt;
-tp_obj zzpy_clearSegments(TP)
-{
-int r=py_clearSegments(); 
-return tp_number(r);
-}
-//int  appendVideo &lt;char * &gt;
-tp_obj zzpy_appendVideo(TP)
-{
-char * p0=(char *)TP_STR().string.val;
-int r=py_appendVideo(p0); 
-return tp_number(r);
-}
-//int  addSegment &lt;int  float   float &gt;
-tp_obj zzpy_addSegment(TP)
-{
-int p0=TP_NUM();
-float p1=TP_NUM();
-float p2=TP_NUM();
-int r=py_addSegment(p0,p1,p2); 
-return tp_number(r);
-}
-//int  setPostProc &lt;int  int   int &gt;
-tp_obj zzpy_setPostProc(TP)
-{
-int p0=TP_NUM();
-int p1=TP_NUM();
-int p2=TP_NUM();
-int r=py_setPostProc(p0,p1,p2); 
-return tp_number(r);
-}
-//int  getWidth &lt;void&gt;
-tp_obj zzpy_getWidth(TP)
-{
-int r=py_getWidth(); 
-return tp_number(r);
-}
-//int  getHeight &lt;void&gt;
-tp_obj zzpy_getHeight(TP)
-{
-int r=py_getHeight(); 
-return tp_number(r);
-}
-//int  getFps1000 &lt;void&gt;
-tp_obj zzpy_getFps1000(TP)
-{
-int r=py_getFps1000(); 
-return tp_number(r);
-}
-//int  audioReset &lt;void&gt;
-tp_obj zzpy_audioReset(TP)
-{
-int r=py_audioReset(); 
-return tp_number(r);
-}
-//int  audioMixer &lt;char * &gt;
-tp_obj zzpy_audioMixer(TP)
-{
-char * p0=(char *)TP_STR().string.val;
-int r=py_audioMixer(p0); 
-return tp_number(r);
-}
-//int  clearVideoFilters &lt;void&gt;
-tp_obj zzpy_clearVideoFilters(TP)
-{
-int r=py_clearVideoFilters(); 
-return tp_number(r);
-}
-pyFuncs adm_functions[]={
-{&quot;loadVideo&quot;,zzpy_loadVideo},
-{&quot;clearSegments&quot;,zzpy_clearSegments},
-{&quot;appendVideo&quot;,zzpy_appendVideo},
-{&quot;addSegment&quot;,zzpy_addSegment},
-{&quot;setPostProc&quot;,zzpy_setPostProc},
-{&quot;getWidth&quot;,zzpy_getWidth},
-{&quot;getHeight&quot;,zzpy_getHeight},
-{&quot;getFps1000&quot;,zzpy_getFps1000},
-{&quot;audioReset&quot;,zzpy_audioReset},
-{&quot;audioMixer&quot;,zzpy_audioMixer},
-{&quot;clearVideoFilters&quot;,zzpy_clearVideoFilters},
-{NULL,NULL}
-};

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_pyScript/src/adm_gen.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_pyScript/src/adm_gen.h	2010-05-20 15:22:49 UTC (rev 6206)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_pyScript/src/adm_gen.h	2010-05-20 15:22:52 UTC (rev 6207)
@@ -1,11 +0,0 @@
-int  py_loadVideo (char * );
-int  py_clearSegments (void);
-int  py_appendVideo (char * );
-int  py_addSegment (int ,float , float );
-int  py_setPostProc (int ,int , int );
-int  py_getWidth (void);
-int  py_getHeight (void);
-int  py_getFps1000 (void);
-int  py_audioReset (void);
-int  py_audioMixer (char * );
-int  py_clearVideoFilters (void);

Copied: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/js/ADM_jsAudio.cpp (from rev 6206, branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsAudio.cpp)
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsAudio.cpp	2010-05-20 15:22:49 UTC (rev 6206)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/js/ADM_jsAudio.cpp	2010-05-20 15:22:52 UTC (rev 6207)
@@ -0,0 +1,100 @@
+/**
+    \file ADM_jsAudio.cpp
+    \brief Audio oriented functions
+    \author mean (c) 2009 <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
+
+
+    jsapigen does not like much variable number of arguments
+    In that case, we patch the generated file to go back to native spidermonkey api
+
+
+*/
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include &quot;ADM_js.h&quot;
+#include &quot;ADM_editor/ADM_edit.hxx&quot;
+#include &quot;ADM_jsAvidemux.h&quot;
+#include &quot;A_functions.h&quot;
+#include &quot;GUI_ui.h&quot;
+#include &quot;ADM_audioFilterInterface.h&quot;
+#include &quot;audioEncoderApi.h&quot;
+extern ADM_Composer *video_body;
+/**
+    \fn int jsAudioReset(void);
+*/
+int jsAudioReset (void)
+{
+    audioFilterReset();
+    return 1;
+}
+/**
+    \fn 
+*/  
+extern &quot;C&quot; int   jsAudioCodec(const char *a,const char **b) {return 0;}
+JSBool jsAdmaudioCodec(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
+{
+        // default return value
+        *rval = BOOLEAN_TO_JSVAL(false);
+        if(argc &lt; 2)
+                return JS_FALSE;
+        if(JSVAL_IS_STRING(argv[0]) == false || JSVAL_IS_INT(argv[1]) == false )            return JS_FALSE;
+        for(int i=2;i&lt;argc;i++)  if(JSVAL_IS_STRING(argv[i]) == false) return JS_FALSE;
+
+        // Get Codec...
+        char *name = JS_GetStringBytes(JSVAL_TO_STRING(argv[0]));
+        ADM_LowerCase(name);
+        
+        // First search the codec by its name
+        if(!audioCodecSetByName(name))
+        {
+                *rval = BOOLEAN_TO_JSVAL(false);
+                jsLog(JS_LOG_ERROR,&quot;Cannot set audio codec %s\n&quot;,name);
+        }
+        else
+        {
+            // begin set bitrate
+            uint32_t bitrate=JSVAL_TO_INT(argv[1]);
+            // Construct couples
+            CONFcouple *c=NULL;
+            if(argc&gt;2)
+            {
+                int nb=argc-2;
+                jsArgToConfCouple( nb,&amp;c,  argv+2);
+            }
+            *rval = BOOLEAN_TO_JSVAL(setAudioExtraConf(bitrate,c));
+            if(c) delete c;
+        }
+
+        // end set bitrate
+        
+        return JS_TRUE;
+}
+/**
+    \fn jsAudioMixer
+*/
+int jsAudioMixer(const char *s)
+{
+    CHANNEL_CONF c=AudioMuxerStringToId(s);
+    return audioFilterSetMixer(c);
+}
+/**
+    \fn jsGetResample
+*/
+int32_t jsGetResample(void)
+{
+    return 0;
+}
+/**
+    \fn jsSetResample
+*/
+void    jsSetResample(int32_t fq)
+{
+
+}
+//EOF
\ No newline at end of file

Copied: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/js/ADM_jsAvidemux.cpp (from rev 6206, branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsAvidemux.cpp)
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsAvidemux.cpp	2010-05-20 15:22:49 UTC (rev 6206)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/js/ADM_jsAvidemux.cpp	2010-05-20 15:22:52 UTC (rev 6207)
@@ -0,0 +1,135 @@
+/**
+    \file ADM_jsLoad.cpp
+    \brief Load oriented functions
+    \author mean (c) 2009 <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
+
+
+*/
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include &quot;ADM_js.h&quot;
+#include &quot;ADM_editor/ADM_edit.hxx&quot;
+#include &quot;ADM_jsAvidemux.h&quot;
+#include &quot;A_functions.h&quot;
+#include &quot;ADM_muxerProto.h&quot;
+#include &quot;GUI_ui.h&quot;
+extern ADM_Composer *video_body;
+/**
+    \fn ADM_JSAvidemux
+    \brief Select the current container from a string
+*/
+bool A_setContainer(const char *cont)
+{
+    int idx=ADM_MuxerIndexFromName(cont);
+    if(idx==-1)
+    {
+        ADM_error(&quot;Cannot find muxer for format=%s\n&quot;,cont);
+        return false;
+    }
+    ADM_info(&quot;setting container as index %d\n&quot;,idx);
+    UI_SetCurrentFormat(idx);
+    return true;
+}
+
+/**
+    \fn jsLoadFile
+*/
+int jsLoadVideo(const char *s)
+{
+int ret=0;
+        jsLog(JS_LOG_NORMAL,&quot;[Js] Loading video %s&quot;,s);
+        if(A_openAvi(s)) 
+        {
+          ret=1;
+        }
+        
+    return ret;
+}
+
+/**
+    \fn jsAppendFile
+*/
+int jsAppendVideo(const char *s)
+{
+int ret=0;
+        
+        if(A_appendAvi(s)) 
+        {
+          ret=1;
+        }
+        
+    return ret;
+}
+
+/**
+    \fn jsClearSegments
+*/
+int jsClearSegments(void)
+{
+    video_body-&gt;clearSegment();
+    return 1;
+}
+/**
+    \fn jsAddSegment
+
+*/
+int  jsAddSegment(int ref, double start, double duration)
+{
+    if(true==video_body-&gt;addSegment(ref,(uint64_t)start,(uint64_t)duration)) 
+    {
+        if(1==video_body-&gt;getNbSegment()) // We just added our first seg...
+        {
+                ADM_info(&quot;First segment, refreshing screen\n&quot;);
+                A_Rewind();
+        }
+        return 1;
+    }
+    return 0;
+}
+
+
+/**
+    \fn Codec
+    
+*/
+extern &quot;C&quot; int   jsSetContainer(const char *a,const char **b) {return 0;}
+JSBool jsAdmsetContainer(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
+{// begin Codec
+        
+        // default return value
+        *rval = BOOLEAN_TO_JSVAL(false);
+        if(argc &lt; 1)
+        {
+            jsLog(JS_LOG_NORMAL,&quot;setContainer needs at least one arg\n&quot;);
+            return JS_FALSE;
+        }
+        
+        if(JSVAL_IS_STRING(argv[0]) == false)
+        {
+                jsLog(JS_LOG_NORMAL,&quot;setContainer needs at string arg\n&quot;);
+                return JS_FALSE;
+        }
+        char *str = JS_GetStringBytes(JSVAL_TO_STRING(argv[0]));
+         jsLog(JS_LOG_NORMAL,&quot;[JS] Selecting container :%s\n&quot;,str);
+        if(A_setContainer(str))
+        {
+            CONFcouple *c;
+            jsArgToConfCouple(argc-1,&amp;c,argv+1);
+            int idx=ADM_MuxerIndexFromName(str);
+            if(idx!=-1)
+            {
+                *rval = BOOLEAN_TO_JSVAL( ADM_mx_setExtraConf(idx,c));
+            }
+            if(c) delete c;
+        }
+        return JS_TRUE;
+}// end Codec
+
+
+// EOF
\ No newline at end of file

Copied: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/js/ADM_jsAvidemuxInfo.cpp (from rev 6206, branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsAvidemuxInfo.cpp)
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsAvidemuxInfo.cpp	2010-05-20 15:22:49 UTC (rev 6206)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/js/ADM_jsAvidemuxInfo.cpp	2010-05-20 15:22:52 UTC (rev 6207)
@@ -0,0 +1,59 @@
+/**
+    \file ADM_jsLoad.cpp
+    \brief Load oriented functions
+    \author mean (c) 2009 <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
+
+
+*/
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include &quot;ADM_js.h&quot;
+#include &quot;ADM_editor/ADM_edit.hxx&quot;
+#include &quot;ADM_jsAvidemux.h&quot;
+#include &quot;fourcc.h&quot;
+extern ADM_Composer *video_body;
+/**
+    \fn jsGetWidth
+*/
+int jsGetWidth ( void)
+{
+aviInfo info;
+        video_body-&gt;getVideoInfo(&amp;info);
+        return info.width;
+}
+/**
+    \fn jsGetHeight
+*/
+int jsGetHeight ( void)
+{
+aviInfo info;
+        video_body-&gt;getVideoInfo(&amp;info);
+        return info.height;
+}
+/**
+    \fn jsGetFps1000
+*/
+int jsGetFps1000 ( void)
+{
+aviInfo info;
+        video_body-&gt;getVideoInfo(&amp;info);
+        return info.fps1000;
+}
+/**
+    \fn jsGetVideoCodec
+*/
+char *jsGetVideoCodec ( void)
+{
+uint32_t fcc;
+aviInfo info;
+        video_body-&gt;getVideoInfo(&amp;info);
+        fcc=info.fcc;
+        return fourCC::tostring(fcc);
+}
+// EOF

Copied: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/js/ADM_jsAvidemux_js.c (from rev 6206, branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsAvidemux_js.c)
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsAvidemux_js.c	2010-05-20 15:22:49 UTC (rev 6206)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/js/ADM_jsAvidemux_js.c	2010-05-20 15:22:52 UTC (rev 6207)
@@ -0,0 +1,1317 @@
+/*
+--- DO NOT EDIT THIS FILE !!! ---
+
+This file has been generated automatically with 'jsapigen'.
+
+jsapigen is a glue-code generator for SpiderMonkey. It is distributed
+under the conditions of version 3 of the GNU General Public License.
+Please have a look at <A HREF="http://jsapigen.sourceforge.net.">http://jsapigen.sourceforge.net.</A>
+
+This file is NOT part of jsapigen and is NOT necessarily covered by
+jsapigen's license. For licensing information regarding this file,
+please refer to the software package which it is part of.
+
+*/
+
+#include &quot;stdio.h&quot;
+#include &quot;ADM_jsAvidemux.h&quot;
+void jsAvidemux(void)
+{
+        printf(&quot;Constructor invoked\n&quot;);
+}
+
+#ifdef HAVE_ALLOCA_H
+#include &lt;alloca.h&gt;
+static size_t jj_alloca_limit = 0;
+#endif
+#include &lt;stdlib.h&gt;
+#include &lt;string.h&gt;
+#include &lt;wchar.h&gt;
+#ifdef HAVE_ALLOCA_H
+#endif
+#include &lt;jsapi.h&gt;
+#ifndef JS_THREADSAFE
+#if JS_VERSION &lt;= 170
+#define jsrefcount int
+#define JS_BeginRequest(cx)
+#define JS_EndRequest(cx)
+#define JS_SuspendRequest(cx)
+#define JS_ResumeRequest(cx, saveDepth)
+#endif
+#endif
+#ifndef JS_FS
+#define JS_FS(name, call, nargs, flags, extra) {name, call, nargs, flags, extra}
+#endif
+#ifndef JS_FS_END
+#define JS_FS_END {NULL, NULL, 0, 0, 0}
+#endif
+
+static JSBool
+jjadmmarkerA_get(JSContext *cx, JSObject *obj, jsval id, jsval *val)
+{
+    double var2;
+    jsval var5;
+    JSBool var1;
+    var2 = 0.0;
+    var5 = JSVAL_NULL;
+    var1 = JS_FALSE;
+    if (!JS_EnterLocalRootScope(cx)) {
+        goto do_return;
+    }
+    var2 = jsGetMarkerA();
+    if (JS_NewNumberValue(cx, var2, &amp;var5) != JS_TRUE) {
+        goto do_return;
+    }
+    if (val) {
+        *val = var5;
+    }
+    var1 = JS_TRUE;
+    do_return:
+    JS_LeaveLocalRootScope(cx);
+    return var1;
+}
+static JSBool
+jjadmmarkerA_set(JSContext *cx, JSObject *obj, jsval id, jsval *val)
+{
+    double var7;
+    jsval var10;
+    jsdouble var11;
+    JSBool var6;
+    var7 = 0.0;
+    var10 = JSVAL_NULL;
+    var11 = 0.0;
+    var6 = JS_FALSE;
+    if (!JS_EnterLocalRootScope(cx)) {
+        goto do_return;
+    }
+    var10 = *val;
+    if (JS_ValueToNumber(cx, var10, &amp;var11) != JS_TRUE) {
+        goto do_return;
+    }
+    var7 = (double)var11;
+    jsSetMarkerA(var7);
+    var6 = JS_TRUE;
+    do_return:
+    JS_LeaveLocalRootScope(cx);
+    return var6;
+}
+static JSBool
+jjadmmarkerB_get(JSContext *cx, JSObject *obj, jsval id, jsval *val)
+{
+    double var13;
+    jsval var16;
+    JSBool var12;
+    var13 = 0.0;
+    var16 = JSVAL_NULL;
+    var12 = JS_FALSE;
+    if (!JS_EnterLocalRootScope(cx)) {
+        goto do_return;
+    }
+    var13 = jsGetMarkerB();
+    if (JS_NewNumberValue(cx, var13, &amp;var16) != JS_TRUE) {
+        goto do_return;
+    }
+    if (val) {
+        *val = var16;
+    }
+    var12 = JS_TRUE;
+    do_return:
+    JS_LeaveLocalRootScope(cx);
+    return var12;
+}
+static JSBool
+jjadmmarkerB_set(JSContext *cx, JSObject *obj, jsval id, jsval *val)
+{
+    double var18;
+    jsval var21;
+    jsdouble var22;
+    JSBool var17;
+    var18 = 0.0;
+    var21 = JSVAL_NULL;
+    var22 = 0.0;
+    var17 = JS_FALSE;
+    if (!JS_EnterLocalRootScope(cx)) {
+        goto do_return;
+    }
+    var21 = *val;
+    if (JS_ValueToNumber(cx, var21, &amp;var22) != JS_TRUE) {
+        goto do_return;
+    }
+    var18 = (double)var22;
+    jsSetMarkerB(var18);
+    var17 = JS_TRUE;
+    do_return:
+    JS_LeaveLocalRootScope(cx);
+    return var17;
+}
+static JSBool
+jjadmaudioResample_get(JSContext *cx, JSObject *obj, jsval id, jsval *val)
+{
+    int var24;
+    jsval var27;
+    JSBool var23;
+    var24 = 0;
+    var27 = JSVAL_NULL;
+    var23 = JS_FALSE;
+    if (!JS_EnterLocalRootScope(cx)) {
+        goto do_return;
+    }
+    var24 = jsGetResample();
+    if (JS_NewNumberValue(cx, var24, &amp;var27) != JS_TRUE) {
+        goto do_return;
+    }
+    if (val) {
+        *val = var27;
+    }
+    var23 = JS_TRUE;
+    do_return:
+    JS_LeaveLocalRootScope(cx);
+    return var23;
+}
+static JSBool
+jjadmaudioResample_set(JSContext *cx, JSObject *obj, jsval id, jsval *val)
+{
+    int var29;
+    jsval var32;
+    int32 var33;
+    JSBool var28;
+    var29 = 0;
+    var32 = JSVAL_NULL;
+    var33 = 0;
+    var28 = JS_FALSE;
+    if (!JS_EnterLocalRootScope(cx)) {
+        goto do_return;
+    }
+    var32 = *val;
+    if (JS_ValueToInt32(cx, var32, &amp;var33) != JS_TRUE) {
+        goto do_return;
+    }
+    var29 = (int)var33;
+    jsSetResample(var29);
+    var28 = JS_TRUE;
+    do_return:
+    JS_LeaveLocalRootScope(cx);
+    return var28;
+}
+static JSBool
+jjadmloadVideo(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
+{
+    JSObject * var35;
+    int var36;
+    int var39;
+    char * var40;
+    int var41;
+    jsval var42;
+    JSString * var43;
+    jsval var241;
+    size_t var44;
+    size_t var45;
+    int var47;
+    jschar * var48;
+    jsval var242;
+    jsval var49;
+    JSBool var34;
+    var35 = NULL;
+    var36 = 0;
+    var39 = 0;
+    var40 = NULL;
+    var41 = 0;
+    var42 = JSVAL_NULL;
+    var43 = NULL;
+    var241 = JSVAL_NULL;
+    var44 = 0;
+    var45 = 0;
+    var47 = 0;
+    var48 = NULL;
+    var242 = JSVAL_NULL;
+    var49 = JSVAL_NULL;
+    var34 = JS_FALSE;
+    var35 = obj;
+    var39 = argc;
+    var41 = 0;
+    var41 = var41 &lt; var39;
+    if (var41) {
+    var42 = argv[0];
+    var43 = JS_ValueToString(cx, var42);
+    if (!var43) {
+        goto do_return;
+    }
+    var241 = STRING_TO_JSVAL(var43);
+    argv[argc+0] = var241;
+    var44 = JS_GetStringLength(var43);
+    var45 = 1;
+    var45 += var44;
+#ifdef HAVE_ALLOCA
+    if (var45 &lt; jj_alloca_limit) {
+        var40 = alloca(var45);
+    } else {
+#endif
+        var40 = malloc(var45);
+        if (!var40) {
+            goto do_return;
+        } else {
+            var47 = 1;
+        }
+#ifdef HAVE_ALLOCA
+    }
+#endif
+    var48 = JS_GetStringChars(var43);
+    var242 = STRING_TO_JSVAL(var43);
+    argv[argc+1] = var242;
+    {
+        size_t i;
+        for (i = 0; i &lt; var44; ++i) {
+            var40[i] = var48[i];
+        }
+        var40[var44] = '\0';
+    }
+    }
+    var36 = jsLoadVideo(var40);
+    if (JS_NewNumberValue(cx, var36, &amp;var49) != JS_TRUE) {
+        goto do_return;
+    }
+    argv[argc+2] = var49;
+    if (rval) {
+        *rval = var49;
+    }
+    var34 = JS_TRUE;
+    do_return:
+    if (var47) {
+        free(var40);
+        var40 = NULL;
+        var47 = 0;
+    }
+    return var34;
+}
+static JSBool
+jjadmclearSegments(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
+{
+    JSObject * var51;
+    int var52;
+    int var55;
+    jsval var56;
+    JSBool var50;
+    var51 = NULL;
+    var52 = 0;
+    var55 = 0;
+    var56 = JSVAL_NULL;
+    var50 = JS_FALSE;
+    var51 = obj;
+    var55 = argc;
+    var52 = jsClearSegments();
+    if (JS_NewNumberValue(cx, var52, &amp;var56) != JS_TRUE) {
+        goto do_return;
+    }
+    argv[argc+0] = var56;
+    if (rval) {
+        *rval = var56;
+    }
+    var50 = JS_TRUE;
+    do_return:
+    return var50;
+}
+static JSBool
+jjadmappendVideo(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
+{
+    JSObject * var58;
+    int var59;
+    int var62;
+    char * var63;
+    int var64;
+    jsval var65;
+    JSString * var66;
+    jsval var245;
+    size_t var67;
+    size_t var68;
+    int var70;
+    jschar * var71;
+    jsval var246;
+    jsval var72;
+    JSBool var57;
+    var58 = NULL;
+    var59 = 0;
+    var62 = 0;
+    var63 = NULL;
+    var64 = 0;
+    var65 = JSVAL_NULL;
+    var66 = NULL;
+    var245 = JSVAL_NULL;
+    var67 = 0;
+    var68 = 0;
+    var70 = 0;
+    var71 = NULL;
+    var246 = JSVAL_NULL;
+    var72 = JSVAL_NULL;
+    var57 = JS_FALSE;
+    var58 = obj;
+    var62 = argc;
+    var64 = 0;
+    var64 = var64 &lt; var62;
+    if (var64) {
+    var65 = argv[0];
+    var66 = JS_ValueToString(cx, var65);
+    if (!var66) {
+        goto do_return;
+    }
+    var245 = STRING_TO_JSVAL(var66);
+    argv[argc+0] = var245;
+    var67 = JS_GetStringLength(var66);
+    var68 = 1;
+    var68 += var67;
+#ifdef HAVE_ALLOCA
+    if (var68 &lt; jj_alloca_limit) {
+        var63 = alloca(var68);
+    } else {
+#endif
+        var63 = malloc(var68);
+        if (!var63) {
+            goto do_return;
+        } else {
+            var70 = 1;
+        }
+#ifdef HAVE_ALLOCA
+    }
+#endif
+    var71 = JS_GetStringChars(var66);
+    var246 = STRING_TO_JSVAL(var66);
+    argv[argc+1] = var246;
+    {
+        size_t i;
+        for (i = 0; i &lt; var67; ++i) {
+            var63[i] = var71[i];
+        }
+        var63[var67] = '\0';
+    }
+    }
+    var59 = jsAppendVideo(var63);
+    if (JS_NewNumberValue(cx, var59, &amp;var72) != JS_TRUE) {
+        goto do_return;
+    }
+    argv[argc+2] = var72;
+    if (rval) {
+        *rval = var72;
+    }
+    var57 = JS_TRUE;
+    do_return:
+    if (var70) {
+        free(var63);
+        var63 = NULL;
+        var70 = 0;
+    }
+    return var57;
+}
+static JSBool
+jjadmaddSegment(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
+{
+    JSObject * var74;
+    int var75;
+    int var78;
+    int var79;
+    int var82;
+    jsval var83;
+    int32 var84;
+    double var80;
+    int var85;
+    jsval var86;
+    jsdouble var87;
+    double var81;
+    int var88;
+    jsval var89;
+    jsdouble var90;
+    jsval var91;
+    JSBool var73;
+    var74 = NULL;
+    var75 = 0;
+    var78 = 0;
+    var79 = 0;
+    var82 = 0;
+    var83 = JSVAL_NULL;
+    var84 = 0;
+    var80 = 0.0;
+    var85 = 0;
+    var86 = JSVAL_NULL;
+    var87 = 0.0;
+    var81 = 0.0;
+    var88 = 0;
+    var89 = JSVAL_NULL;
+    var90 = 0.0;
+    var91 = JSVAL_NULL;
+    var73 = JS_FALSE;
+    var74 = obj;
+    var78 = argc;
+    var82 = 0;
+    var82 = var82 &lt; var78;
+    if (var82) {
+    var83 = argv[0];
+    if (JS_ValueToInt32(cx, var83, &amp;var84) != JS_TRUE) {
+        goto do_return;
+    }
+    var79 = (int)var84;
+    }
+    var85 = 1;
+    var85 = var85 &lt; var78;
+    if (var85) {
+    var86 = argv[1];
+    if (JS_ValueToNumber(cx, var86, &amp;var87) != JS_TRUE) {
+        goto do_return;
+    }
+    var80 = (double)var87;
+    }
+    var88 = 2;
+    var88 = var88 &lt; var78;
+    if (var88) {
+    var89 = argv[2];
+    if (JS_ValueToNumber(cx, var89, &amp;var90) != JS_TRUE) {
+        goto do_return;
+    }
+    var81 = (double)var90;
+    }
+    var75 = jsAddSegment(var79, var80, var81);
+    if (JS_NewNumberValue(cx, var75, &amp;var91) != JS_TRUE) {
+        goto do_return;
+    }
+    argv[argc+0] = var91;
+    if (rval) {
+        *rval = var91;
+    }
+    var73 = JS_TRUE;
+    do_return:
+    return var73;
+}
+static JSBool
+jjadmsetPostProc(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
+{
+    JSObject * var93;
+    int var94;
+    int var97;
+    int var98;
+    int var101;
+    jsval var102;
+    int32 var103;
+    int var99;
+    int var104;
+    jsval var105;
+    int32 var106;
+    int var100;
+    int var107;
+    jsval var108;
+    int32 var109;
+    jsval var110;
+    JSBool var92;
+    var93 = NULL;
+    var94 = 0;
+    var97 = 0;
+    var98 = 0;
+    var101 = 0;
+    var102 = JSVAL_NULL;
+    var103 = 0;
+    var99 = 0;
+    var104 = 0;
+    var105 = JSVAL_NULL;
+    var106 = 0;
+    var100 = 0;
+    var107 = 0;
+    var108 = JSVAL_NULL;
+    var109 = 0;
+    var110 = JSVAL_NULL;
+    var92 = JS_FALSE;
+    var93 = obj;
+    var97 = argc;
+    var101 = 0;
+    var101 = var101 &lt; var97;
+    if (var101) {
+    var102 = argv[0];
+    if (JS_ValueToInt32(cx, var102, &amp;var103) != JS_TRUE) {
+        goto do_return;
+    }
+    var98 = (int)var103;
+    }
+    var104 = 1;
+    var104 = var104 &lt; var97;
+    if (var104) {
+    var105 = argv[1];
+    if (JS_ValueToInt32(cx, var105, &amp;var106) != JS_TRUE) {
+        goto do_return;
+    }
+    var99 = (int)var106;
+    }
+    var107 = 2;
+    var107 = var107 &lt; var97;
+    if (var107) {
+    var108 = argv[2];
+    if (JS_ValueToInt32(cx, var108, &amp;var109) != JS_TRUE) {
+        goto do_return;
+    }
+    var100 = (int)var109;
+    }
+    var94 = jsSetPostProc(var98, var99, var100);
+    if (JS_NewNumberValue(cx, var94, &amp;var110) != JS_TRUE) {
+        goto do_return;
+    }
+    argv[argc+0] = var110;
+    if (rval) {
+        *rval = var110;
+    }
+    var92 = JS_TRUE;
+    do_return:
+    return var92;
+}
+static JSBool
+jjadmgetWidth(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
+{
+    JSObject * var112;
+    int var113;
+    int var116;
+    jsval var117;
+    JSBool var111;
+    var112 = NULL;
+    var113 = 0;
+    var116 = 0;
+    var117 = JSVAL_NULL;
+    var111 = JS_FALSE;
+    var112 = obj;
+    var116 = argc;
+    var113 = jsGetWidth();
+    if (JS_NewNumberValue(cx, var113, &amp;var117) != JS_TRUE) {
+        goto do_return;
+    }
+    argv[argc+0] = var117;
+    if (rval) {
+        *rval = var117;
+    }
+    var111 = JS_TRUE;
+    do_return:
+    return var111;
+}
+static JSBool
+jjadmgetHeight(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
+{
+    JSObject * var119;
+    int var120;
+    int var123;
+    jsval var124;
+    JSBool var118;
+    var119 = NULL;
+    var120 = 0;
+    var123 = 0;
+    var124 = JSVAL_NULL;
+    var118 = JS_FALSE;
+    var119 = obj;
+    var123 = argc;
+    var120 = jsGetHeight();
+    if (JS_NewNumberValue(cx, var120, &amp;var124) != JS_TRUE) {
+        goto do_return;
+    }
+    argv[argc+0] = var124;
+    if (rval) {
+        *rval = var124;
+    }
+    var118 = JS_TRUE;
+    do_return:
+    return var118;
+}
+static JSBool
+jjadmgetFps1000(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
+{
+    JSObject * var126;
+    int var127;
+    int var130;
+    jsval var131;
+    JSBool var125;
+    var126 = NULL;
+    var127 = 0;
+    var130 = 0;
+    var131 = JSVAL_NULL;
+    var125 = JS_FALSE;
+    var126 = obj;
+    var130 = argc;
+    var127 = jsGetFps1000();
+    if (JS_NewNumberValue(cx, var127, &amp;var131) != JS_TRUE) {
+        goto do_return;
+    }
+    argv[argc+0] = var131;
+    if (rval) {
+        *rval = var131;
+    }
+    var125 = JS_TRUE;
+    do_return:
+    return var125;
+}
+static JSBool
+jjadmgetVideoCodec(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
+{
+    JSObject * var133;
+    char * var134;
+    int var137;
+    jsval var138;
+    JSString * var139;
+    jsval var253;
+    char * var140;
+    jsval var254;
+    JSBool var132;
+    var133 = NULL;
+    var134 = NULL;
+    var137 = 0;
+    var138 = JSVAL_NULL;
+    var139 = NULL;
+    var253 = JSVAL_NULL;
+    var140 = NULL;
+    var254 = JSVAL_NULL;
+    var132 = JS_FALSE;
+    var133 = obj;
+    var137 = argc;
+    var134 = jsGetVideoCodec();
+    if (var134) {
+    var139 = JS_NewStringCopyZ(cx, var134);
+    if (!var139) {
+        goto do_return;
+    }
+    var253 = STRING_TO_JSVAL(var139);
+    argv[argc+0] = var253;
+    } else {
+    var140 = &quot;&quot;;
+    var139 = JS_InternString(cx, var140);
+    if (!var139) {
+        goto do_return;
+    }
+    var254 = STRING_TO_JSVAL(var139);
+    argv[argc+1] = var254;
+    }
+    var138 = STRING_TO_JSVAL(var139);
+    if (rval) {
+        *rval = var138;
+    }
+    var132 = JS_TRUE;
+    do_return:
+    return var132;
+}
+static JSBool
+jjadmaudioReset(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
+{
+    JSObject * var142;
+    int var143;
+    int var146;
+    jsval var147;
+    JSBool var141;
+    var142 = NULL;
+    var143 = 0;
+    var146 = 0;
+    var147 = JSVAL_NULL;
+    var141 = JS_FALSE;
+    var142 = obj;
+    var146 = argc;
+    var143 = jsAudioReset();
+    if (JS_NewNumberValue(cx, var143, &amp;var147) != JS_TRUE) {
+        goto do_return;
+    }
+    argv[argc+0] = var147;
+    if (rval) {
+        *rval = var147;
+    }
+    var141 = JS_TRUE;
+    do_return:
+    return var141;
+}
+static JSBool
+jjadmaudioMixer(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
+{
+    JSObject * var149;
+    int var150;
+    int var153;
+    char * var154;
+    int var155;
+    jsval var156;
+    JSString * var157;
+    jsval var256;
+    size_t var158;
+    size_t var159;
+    int var161;
+    jschar * var162;
+    jsval var257;
+    jsval var163;
+    JSBool var148;
+    var149 = NULL;
+    var150 = 0;
+    var153 = 0;
+    var154 = NULL;
+    var155 = 0;
+    var156 = JSVAL_NULL;
+    var157 = NULL;
+    var256 = JSVAL_NULL;
+    var158 = 0;
+    var159 = 0;
+    var161 = 0;
+    var162 = NULL;
+    var257 = JSVAL_NULL;
+    var163 = JSVAL_NULL;
+    var148 = JS_FALSE;
+    var149 = obj;
+    var153 = argc;
+    var155 = 0;
+    var155 = var155 &lt; var153;
+    if (var155) {
+    var156 = argv[0];
+    var157 = JS_ValueToString(cx, var156);
+    if (!var157) {
+        goto do_return;
+    }
+    var256 = STRING_TO_JSVAL(var157);
+    argv[argc+0] = var256;
+    var158 = JS_GetStringLength(var157);
+    var159 = 1;
+    var159 += var158;
+#ifdef HAVE_ALLOCA
+    if (var159 &lt; jj_alloca_limit) {
+        var154 = alloca(var159);
+    } else {
+#endif
+        var154 = malloc(var159);
+        if (!var154) {
+            goto do_return;
+        } else {
+            var161 = 1;
+        }
+#ifdef HAVE_ALLOCA
+    }
+#endif
+    var162 = JS_GetStringChars(var157);
+    var257 = STRING_TO_JSVAL(var157);
+    argv[argc+1] = var257;
+    {
+        size_t i;
+        for (i = 0; i &lt; var158; ++i) {
+            var154[i] = var162[i];
+        }
+        var154[var158] = '\0';
+    }
+    }
+    var150 = jsAudioMixer(var154);
+    if (JS_NewNumberValue(cx, var150, &amp;var163) != JS_TRUE) {
+        goto do_return;
+    }
+    argv[argc+2] = var163;
+    if (rval) {
+        *rval = var163;
+    }
+    var148 = JS_TRUE;
+    do_return:
+    if (var161) {
+        free(var154);
+        var154 = NULL;
+        var161 = 0;
+    }
+    return var148;
+}
+static JSBool
+jjadmclearVideoFilters(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
+{
+    JSObject * var165;
+    int var166;
+    int var169;
+    jsval var170;
+    JSBool var164;
+    var165 = NULL;
+    var166 = 0;
+    var169 = 0;
+    var170 = JSVAL_NULL;
+    var164 = JS_FALSE;
+    var165 = obj;
+    var169 = argc;
+    var166 = jsClearVideoFilters();
+    if (JS_NewNumberValue(cx, var166, &amp;var170) != JS_TRUE) {
+        goto do_return;
+    }
+    argv[argc+0] = var170;
+    if (rval) {
+        *rval = var170;
+    }
+    var164 = JS_TRUE;
+    do_return:
+    return var164;
+}
+static JSBool
+jjadmvideoCodec_ignore(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
+{
+    JSObject * var172;
+    int var173;
+    int var176;
+    char * var177;
+    int var178;
+    jsval var179;
+    JSString * var180;
+    jsval var260;
+    size_t var181;
+    size_t var182;
+    int var184;
+    jschar * var185;
+    jsval var261;
+    jsval var186;
+    JSBool var171;
+    var172 = NULL;
+    var173 = 0;
+    var176 = 0;
+    var177 = NULL;
+    var178 = 0;
+    var179 = JSVAL_NULL;
+    var180 = NULL;
+    var260 = JSVAL_NULL;
+    var181 = 0;
+    var182 = 0;
+    var184 = 0;
+    var185 = NULL;
+    var261 = JSVAL_NULL;
+    var186 = JSVAL_NULL;
+    var171 = JS_FALSE;
+    var172 = obj;
+    var176 = argc;
+    var178 = 0;
+    var178 = var178 &lt; var176;
+    if (var178) {
+    var179 = argv[0];
+    var180 = JS_ValueToString(cx, var179);
+    if (!var180) {
+        goto do_return;
+    }
+    var260 = STRING_TO_JSVAL(var180);
+    argv[argc+0] = var260;
+    var181 = JS_GetStringLength(var180);
+    var182 = 1;
+    var182 += var181;
+#ifdef HAVE_ALLOCA
+    if (var182 &lt; jj_alloca_limit) {
+        var177 = alloca(var182);
+    } else {
+#endif
+        var177 = malloc(var182);
+        if (!var177) {
+            goto do_return;
+        } else {
+            var184 = 1;
+        }
+#ifdef HAVE_ALLOCA
+    }
+#endif
+    var185 = JS_GetStringChars(var180);
+    var261 = STRING_TO_JSVAL(var180);
+    argv[argc+1] = var261;
+    {
+        size_t i;
+        for (i = 0; i &lt; var181; ++i) {
+            var177[i] = var185[i];
+        }
+        var177[var181] = '\0';
+    }
+    }
+    var173 = jsVideoCodec(var177);
+    if (JS_NewNumberValue(cx, var173, &amp;var186) != JS_TRUE) {
+        goto do_return;
+    }
+    argv[argc+2] = var186;
+    if (rval) {
+        *rval = var186;
+    }
+    var171 = JS_TRUE;
+    do_return:
+    if (var184) {
+        free(var177);
+        var177 = NULL;
+        var184 = 0;
+    }
+    return var171;
+}
+static JSBool
+jjadmaddVideoFilter_ignore(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
+{
+    JSObject * var188;
+    int var189;
+    int var192;
+    char * var193;
+    int var194;
+    jsval var195;
+    JSString * var196;
+    jsval var263;
+    size_t var197;
+    size_t var198;
+    int var200;
+    jschar * var201;
+    jsval var264;
+    jsval var202;
+    JSBool var187;
+    var188 = NULL;
+    var189 = 0;
+    var192 = 0;
+    var193 = NULL;
+    var194 = 0;
+    var195 = JSVAL_NULL;
+    var196 = NULL;
+    var263 = JSVAL_NULL;
+    var197 = 0;
+    var198 = 0;
+    var200 = 0;
+    var201 = NULL;
+    var264 = JSVAL_NULL;
+    var202 = JSVAL_NULL;
+    var187 = JS_FALSE;
+    var188 = obj;
+    var192 = argc;
+    var194 = 0;
+    var194 = var194 &lt; var192;
+    if (var194) {
+    var195 = argv[0];
+    var196 = JS_ValueToString(cx, var195);
+    if (!var196) {
+        goto do_return;
+    }
+    var263 = STRING_TO_JSVAL(var196);
+    argv[argc+0] = var263;
+    var197 = JS_GetStringLength(var196);
+    var198 = 1;
+    var198 += var197;
+#ifdef HAVE_ALLOCA
+    if (var198 &lt; jj_alloca_limit) {
+        var193 = alloca(var198);
+    } else {
+#endif
+        var193 = malloc(var198);
+        if (!var193) {
+            goto do_return;
+        } else {
+            var200 = 1;
+        }
+#ifdef HAVE_ALLOCA
+    }
+#endif
+    var201 = JS_GetStringChars(var196);
+    var264 = STRING_TO_JSVAL(var196);
+    argv[argc+1] = var264;
+    {
+        size_t i;
+        for (i = 0; i &lt; var197; ++i) {
+            var193[i] = var201[i];
+        }
+        var193[var197] = '\0';
+    }
+    }
+    var189 = jsVideoFilter(var193);
+    if (JS_NewNumberValue(cx, var189, &amp;var202) != JS_TRUE) {
+        goto do_return;
+    }
+    argv[argc+2] = var202;
+    if (rval) {
+        *rval = var202;
+    }
+    var187 = JS_TRUE;
+    do_return:
+    if (var200) {
+        free(var193);
+        var193 = NULL;
+        var200 = 0;
+    }
+    return var187;
+}
+static JSBool
+jjadmaudioCodec_ignore(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
+{
+    JSObject * var204;
+    int var205;
+    int var208;
+    char * var209;
+    int var210;
+    jsval var211;
+    JSString * var212;
+    jsval var266;
+    size_t var213;
+    size_t var214;
+    int var216;
+    jschar * var217;
+    jsval var267;
+    jsval var218;
+    JSBool var203;
+    var204 = NULL;
+    var205 = 0;
+    var208 = 0;
+    var209 = NULL;
+    var210 = 0;
+    var211 = JSVAL_NULL;
+    var212 = NULL;
+    var266 = JSVAL_NULL;
+    var213 = 0;
+    var214 = 0;
+    var216 = 0;
+    var217 = NULL;
+    var267 = JSVAL_NULL;
+    var218 = JSVAL_NULL;
+    var203 = JS_FALSE;
+    var204 = obj;
+    var208 = argc;
+    var210 = 0;
+    var210 = var210 &lt; var208;
+    if (var210) {
+    var211 = argv[0];
+    var212 = JS_ValueToString(cx, var211);
+    if (!var212) {
+        goto do_return;
+    }
+    var266 = STRING_TO_JSVAL(var212);
+    argv[argc+0] = var266;
+    var213 = JS_GetStringLength(var212);
+    var214 = 1;
+    var214 += var213;
+#ifdef HAVE_ALLOCA
+    if (var214 &lt; jj_alloca_limit) {
+        var209 = alloca(var214);
+    } else {
+#endif
+        var209 = malloc(var214);
+        if (!var209) {
+            goto do_return;
+        } else {
+            var216 = 1;
+        }
+#ifdef HAVE_ALLOCA
+    }
+#endif
+    var217 = JS_GetStringChars(var212);
+    var267 = STRING_TO_JSVAL(var212);
+    argv[argc+1] = var267;
+    {
+        size_t i;
+        for (i = 0; i &lt; var213; ++i) {
+            var209[i] = var217[i];
+        }
+        var209[var213] = '\0';
+    }
+    }
+    var205 = jsAudioCodec(var209);
+    if (JS_NewNumberValue(cx, var205, &amp;var218) != JS_TRUE) {
+        goto do_return;
+    }
+    argv[argc+2] = var218;
+    if (rval) {
+        *rval = var218;
+    }
+    var203 = JS_TRUE;
+    do_return:
+    if (var216) {
+        free(var209);
+        var209 = NULL;
+        var216 = 0;
+    }
+    return var203;
+}
+static JSBool
+jjadmsetContainer_ignore(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
+{
+    JSObject * var220;
+    int var221;
+    int var224;
+    char * var225;
+    int var226;
+    jsval var227;
+    JSString * var228;
+    jsval var269;
+    size_t var229;
+    size_t var230;
+    int var232;
+    jschar * var233;
+    jsval var270;
+    jsval var234;
+    JSBool var219;
+    var220 = NULL;
+    var221 = 0;
+    var224 = 0;
+    var225 = NULL;
+    var226 = 0;
+    var227 = JSVAL_NULL;
+    var228 = NULL;
+    var269 = JSVAL_NULL;
+    var229 = 0;
+    var230 = 0;
+    var232 = 0;
+    var233 = NULL;
+    var270 = JSVAL_NULL;
+    var234 = JSVAL_NULL;
+    var219 = JS_FALSE;
+    var220 = obj;
+    var224 = argc;
+    var226 = 0;
+    var226 = var226 &lt; var224;
+    if (var226) {
+    var227 = argv[0];
+    var228 = JS_ValueToString(cx, var227);
+    if (!var228) {
+        goto do_return;
+    }
+    var269 = STRING_TO_JSVAL(var228);
+    argv[argc+0] = var269;
+    var229 = JS_GetStringLength(var228);
+    var230 = 1;
+    var230 += var229;
+#ifdef HAVE_ALLOCA
+    if (var230 &lt; jj_alloca_limit) {
+        var225 = alloca(var230);
+    } else {
+#endif
+        var225 = malloc(var230);
+        if (!var225) {
+            goto do_return;
+        } else {
+            var232 = 1;
+        }
+#ifdef HAVE_ALLOCA
+    }
+#endif
+    var233 = JS_GetStringChars(var228);
+    var270 = STRING_TO_JSVAL(var228);
+    argv[argc+1] = var270;
+    {
+        size_t i;
+        for (i = 0; i &lt; var229; ++i) {
+            var225[i] = var233[i];
+        }
+        var225[var229] = '\0';
+    }
+    }
+    var221 = jsSetContainer(var225);
+    if (JS_NewNumberValue(cx, var221, &amp;var234) != JS_TRUE) {
+        goto do_return;
+    }
+    argv[argc+2] = var234;
+    if (rval) {
+        *rval = var234;
+    }
+    var219 = JS_TRUE;
+    do_return:
+    if (var232) {
+        free(var225);
+        var225 = NULL;
+        var232 = 0;
+    }
+    return var219;
+}
+static JSBool
+jjadm__construct__(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
+{
+    JSObject * var236;
+    int var240;
+    JSBool var235;
+    var236 = NULL;
+    var240 = 0;
+    var235 = JS_FALSE;
+    var236 = obj;
+    var240 = argc;
+    jsAvidemux();
+    var235 = JS_TRUE;
+    return var235;
+}
+static JSPropertySpec jj_static_ps[] = {
+    {NULL, 0, 0, NULL, NULL}
+};
+static JSPropertySpec jj_ps[] = {
+    {NULL, 0, 0, NULL, NULL}
+};
+static JSFunctionSpec jj_static_fs[] = {
+    JS_FS_END
+};
+static JSFunctionSpec jj_fs[] = {
+    JS_FS_END
+};
+static JSPropertySpec jjadm_static_ps[] = {
+    {&quot;markerA&quot;, 0, 0|JSPROP_ENUMERATE, jjadmmarkerA_get, jjadmmarkerA_set},
+    {&quot;markerB&quot;, 0, 0|JSPROP_ENUMERATE, jjadmmarkerB_get, jjadmmarkerB_set},
+    {&quot;audioResample&quot;, 0, 0|JSPROP_ENUMERATE, jjadmaudioResample_get, jjadmaudioResample_set},
+    {NULL, 0, 0, NULL, NULL}
+};
+static JSPropertySpec jjadm_ps[] = {
+    {NULL, 0, 0, NULL, NULL}
+};
+static JSFunctionSpec jjadm_static_fs[] = {
+    JS_FS(&quot;loadVideo&quot;, jjadmloadVideo, 1, 0, 3),
+    JS_FS(&quot;clearSegments&quot;, jjadmclearSegments, 0, 0, 1),
+    JS_FS(&quot;appendVideo&quot;, jjadmappendVideo, 1, 0, 3),
+    JS_FS(&quot;addSegment&quot;, jjadmaddSegment, 3, 0, 1),
+    JS_FS(&quot;setPostProc&quot;, jjadmsetPostProc, 3, 0, 1),
+    JS_FS(&quot;getWidth&quot;, jjadmgetWidth, 0, 0, 1),
+    JS_FS(&quot;getHeight&quot;, jjadmgetHeight, 0, 0, 1),
+    JS_FS(&quot;getFps1000&quot;, jjadmgetFps1000, 0, 0, 1),
+    JS_FS(&quot;getVideoCodec&quot;, jjadmgetVideoCodec, 0, 0, 2),
+    JS_FS(&quot;audioReset&quot;, jjadmaudioReset, 0, 0, 1),
+    JS_FS(&quot;audioMixer&quot;, jjadmaudioMixer, 1, 0, 3),
+    JS_FS(&quot;clearVideoFilters&quot;, jjadmclearVideoFilters, 0, 0, 1),
+    JS_FS(&quot;videoCodec&quot;, jsAdmvideoCodec,  1, 0, 3),
+    JS_FS(&quot;addVideoFilter&quot;, jsAdmaddVideoFilter,  1, 0, 3),
+    JS_FS(&quot;audioCodec&quot;, jsAdmaudioCodec,  1, 0, 3),
+    JS_FS(&quot;setContainer&quot;, jsAdmsetContainer,  1, 0, 3),
+    JS_FS_END
+};
+static JSFunctionSpec jjadm_fs[] = {
+    JS_FS_END
+};
+static JSClass jjadm_class = {
+    &quot;adm&quot;,
+    0,
+    JS_PropertyStub,
+    JS_PropertyStub,
+    JS_PropertyStub,
+    JS_PropertyStub,
+    JS_EnumerateStub,
+    JS_ResolveStub,
+    JS_ConvertStub,
+    JS_FinalizeStub,
+    NULL,
+    NULL,
+    NULL,
+    jjadm__construct__,
+    NULL,
+    NULL,
+    NULL,
+    NULL
+};
+static JSObject *
+jjadm_init(JSContext *cx, JSObject *obj)
+{
+    JSObject *parent_proto, *proto;
+    JSClass *class;
+    if (!cx || !obj) {
+        JS_ReportError(cx, &quot;invalid parameter&quot;);
+        return NULL;
+    }
+    if (!JS_EnterLocalRootScope(cx)) {
+        JS_ReportError(cx, &quot;JS_EnterLocalRootScope failed&quot;);
+        return NULL;
+    }
+    parent_proto = NULL;
+    proto = NULL;
+    parent_proto = JS_NewObject(cx, NULL, NULL, NULL);
+    if (!parent_proto) {
+        JS_LeaveLocalRootScope(cx);
+        JS_ReportError(cx, &quot;failed to create prototype&quot;);
+        return NULL;
+    }
+    class = &amp;jjadm_class;
+    proto = JS_InitClass(cx, obj, parent_proto, class, jjadm__construct__, 0, jjadm_ps, jjadm_fs, jjadm_static_ps, jjadm_static_fs);
+    if (!proto) {
+        JS_LeaveLocalRootScope(cx);
+        JS_ReportError(cx, &quot;failed to init class&quot;);
+        return NULL;
+    }
+    JS_LeaveLocalRootScope(cx);
+    return proto;
+}
+
+
+JSObject *jsAvidemuxInit(JSContext *cx,JSObject *obj)
+{
+          if (JS_DefineFunctions(cx, obj, jj_static_fs) != JS_TRUE) 
+          {
+                return NULL;
+          }
+          return jjadm_init(cx,obj);
+}
+
+JSFunctionSpec  *jsGetAdmFunctions(void)
+{
+        return jjadm_static_fs;
+}
+
+

Copied: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/js/ADM_jsAvidemux_js.idl (from rev 6206, branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsAvidemux_js.idl)
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsAvidemux_js.idl	2010-05-20 15:22:49 UTC (rev 6206)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/js/ADM_jsAvidemux_js.idl	2010-05-20 15:22:52 UTC (rev 6207)
@@ -0,0 +1,55 @@
+%{
+#include &quot;stdio.h&quot;
+#include &quot;ADM_jsAvidemux.h&quot;
+void jsAvidemux(void)
+{
+        printf(&quot;Constructor invoked\n&quot;);
+}
+%}
+        /*            JSFUNC      C FUNC  PARAM     */
+class adm
+{
+        function int loadVideo      : jsLoadVideo (cstring ) &lt;static&gt;;
+        function int clearSegments  : jsClearSegments () &lt;static&gt;;
+        function int appendVideo    : jsAppendVideo (cstring ) &lt;static&gt;;
+        function int addSegment     : jsAddSegment (int ,double , double ) &lt;static&gt;;
+        function int setPostProc    : jsSetPostProc (int ,int , int ) &lt;static&gt;;
+        function int getWidth       : jsGetWidth ( ) &lt;static&gt;;
+        function int getHeight      : jsGetHeight ( ) &lt;static&gt;;
+        function int getFps1000     : jsGetFps1000 ( ) &lt;static&gt;;
+     function cstring getVideoCodec : jsGetVideoCodec ( ) &lt;static&gt;;
+        /*            JSFUNC                 C FUNC           PARAM     */
+        function int audioReset     : jsAudioReset () &lt;static&gt;;
+        function int audioMixer     : jsAudioMixer (cstring ) &lt;static&gt;;
+        /*            JSFUNC                 C FUNC           PARAM     */
+        function int clearVideoFilters   : jsClearVideoFilters() &lt;static&gt;;
+        
+/* Override as jsapigen cannot handle multiple args the way we need it to */
+        function int videoCodec_ignore     : jsVideoCodec(cstring)     &lt;static&gt;;
+        function int addVideoFilter_ignore : jsVideoFilter(cstring)    &lt;static&gt;;
+        function int audioCodec_ignore     : jsAudioCodec(cstring)     &lt;static&gt;;
+        function int setContainer_ignore   : jsSetContainer(cstring)   &lt;static&gt;;
+/* Properties */
+        property double markerA            : jsGetMarkerA,jsSetMarkerA &lt;static&gt;;
+        property double markerB            : jsGetMarkerB,jsSetMarkerB &lt;static&gt;;
+        property int    audioResample      : jsGetResample,jsSetResample &lt;static&gt;;
+        construct                          : jsAvidemux  ( ) &lt;static&gt;     ; 
+};
+
+%&lt;
+
+JSObject *jsAvidemuxInit(JSContext *cx,JSObject *obj)
+{
+          if (JS_DefineFunctions(cx, obj, jj_static_fs) != JS_TRUE) 
+          {
+                return NULL;
+          }
+          return jjadm_init(cx,obj);
+}
+
+JSFunctionSpec  *jsGetAdmFunctions(void)
+{
+        return jjadm_static_fs;
+}
+
+%&gt;

Copied: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/js/ADM_jsDebug.cpp (from rev 6206, branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsDebug.cpp)
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsDebug.cpp	2010-05-20 15:22:49 UTC (rev 6206)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/js/ADM_jsDebug.cpp	2010-05-20 15:22:52 UTC (rev 6207)
@@ -0,0 +1,106 @@
+/**
+    \file ADM_JSDebug.cpp
+    \brief Debug oriented functions for avidemux JS/JS shell
+    \author mean (c) 2009 <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
+
+
+*/
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include &quot;ADM_js.h&quot;
+#include &quot;ADM_editor/ADM_edit.hxx&quot;
+#include &quot;ADM_jsDebug.h&quot;
+#include &lt;vector&gt;
+/**/
+/**/
+extern ADM_Composer *video_body;
+void ADM_dumpJSHooks(void);
+extern vector &lt;JSFunctionSpec *&gt;listOfHooks;
+/**
+    \fn displayError
+    \brief error popup
+*/
+void jsPopupError(const char *s)
+{// begin displayError
+	
+	GUI_Verbose();
+	GUI_Error_HIG(&quot;Error&quot;,s);
+	GUI_Quiet();
+
+}// end displayError
+/**
+    \fn displayInfo
+    \brief info popup
+*/
+
+void jsPopupInfo(const char *s)
+{// begin displayInfo
+	
+	GUI_Verbose();
+	GUI_Info_HIG(ADM_LOG_IMPORTANT,&quot;Info&quot;,s);
+	GUI_Quiet();
+	
+}// end displayInfo
+ /**
+    \fn print
+*/
+void jsPrint(const char *s)
+{// begin print
+        jsLog(JS_LOG_NORMAL,&quot;%s&quot;,s);
+}// end print
+void jsPrint2(const char *s)
+{// begin print
+        jsLog(JS_LOG_NORMAL,&quot;%s&quot;,s);
+}// end print
+
+
+static void dumpFunc(JSFunctionSpec *f)
+{
+    while(f-&gt;name)
+    {
+        jsLog(JS_LOG_NORMAL,&quot;     %s(..)&quot;,f-&gt;name);
+        f++;
+    }
+}
+
+/**
+    \fn printJSError
+*/
+void  printJSError(JSContext *cx, const char *message, JSErrorReport *report)
+{// begin printJSError
+int quiet=GUI_isQuiet();
+char buf[4];
+FILE *fd = ADM_fopen(report-&gt;filename,&quot;rb&quot;);
+    if(quiet)
+            GUI_Verbose();
+	if( fd )
+    {
+		fread(buf,1,4,fd);
+		fclose(fd);
+	}
+	if( strncmp(buf,&quot;//AD&quot;,4) )
+    {
+            if (report-&gt;filename || report-&gt;lineno)
+                jsLog(JS_LOG_ERROR,&quot;%s: line %d:\nMsg: %s\n&quot;,
+                              report-&gt;filename,
+                              report-&gt;lineno,
+                              message);
+            else
+                jsLog(JS_LOG_ERROR,&quot;Error&quot;);
+    
+	}else
+    {
+            jsLog(JS_LOG_ERROR,&quot;%s: line %d:\nMsg: %s\n&quot;,report-&gt;filename,report-&gt;lineno,message);
+	}
+       
+    if(quiet)
+            GUI_Quiet();
+
+}// end printJSError
+// EOF
\ No newline at end of file

Copied: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/js/ADM_jsEditor.cpp (from rev 6206, branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsEditor.cpp)
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsEditor.cpp	2010-05-20 15:22:49 UTC (rev 6206)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/js/ADM_jsEditor.cpp	2010-05-20 15:22:52 UTC (rev 6207)
@@ -0,0 +1,77 @@
+/**
+    \file ADM_JSif.cpp
+    \brief interface to js
+*/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include &quot;ADM_js.h&quot;
+#include &lt;stdarg.h&gt;
+#include &lt;vector&gt;
+#include &quot;ADM_jsEditor.h&quot;
+#include &quot;ADM_editor/ADM_edit.hxx&quot;
+extern ADM_Composer *video_body;
+
+/**
+    \fn jsPrintTiming
+*/
+int jsPrintTiming(int framenumber )
+{
+    uint32_t flags;
+    uint64_t pts,dts;
+    if(true==video_body-&gt;getVideoPtsDts(framenumber, &amp;flags,&amp;pts,&amp;dts))
+    {
+        int64_t delta=0;
+        if(pts!=ADM_NO_PTS &amp;&amp; dts!=ADM_NO_PTS) delta=(int64_t)pts-(int64_t)dts;
+        jsLog(JS_LOG_NORMAL,&quot;Frame %&quot;LU&quot; : Flags 0x%&quot;LX&quot; pts=%&quot;LLD&quot; dts=%&quot;LLD&quot; delta=%&quot;LLD&quot; ms&quot;,framenumber,flags,pts,dts,delta/1000LL);
+    }else
+    {
+        jsLog(JS_LOG_NORMAL,&quot;Cannot get info for frame %&quot;LU,framenumber);
+    }
+    return 0;
+}
+
+/**
+    \fn    jsDumpSegments
+    \brief dump segment, video &amp; all
+*/
+int jsDumpSegments (void)
+{// begin PostProcess
+        enterLock();
+        video_body-&gt;dumpSegments();
+        leaveLock(); 
+        return 0;
+}// end PostProcess
+/**
+        \fn jsDumpRefVideos
+*/
+int jsDumpRefVideos (void)
+{
+        enterLock();
+        video_body-&gt;dumpRefVideos();
+        leaveLock(); 
+
+        return 0;
+}
+/**
+    \fn dumpTiming
+    \brief dump segment, video &amp; all
+*/
+JSBool dumpTiming(void)
+{// begin PostProcess
+        
+  
+        enterLock();
+        video_body-&gt;dumpTiming();
+        leaveLock(); 
+        
+        return 0;
+}// end PostProcess
+// EOF

Copied: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/js/ADM_jsEditor_js.c (from rev 6206, branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsEditor_js.c)
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsEditor_js.c	2010-05-20 15:22:49 UTC (rev 6206)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/js/ADM_jsEditor_js.c	2010-05-20 15:22:52 UTC (rev 6207)
@@ -0,0 +1,256 @@
+/*
+--- DO NOT EDIT THIS FILE !!! ---
+
+This file has been generated automatically with 'jsapigen'.
+
+jsapigen is a glue-code generator for SpiderMonkey. It is distributed
+under the conditions of version 3 of the GNU General Public License.
+Please have a look at <A HREF="http://jsapigen.sourceforge.net.">http://jsapigen.sourceforge.net.</A>
+
+This file is NOT part of jsapigen and is NOT necessarily covered by
+jsapigen's license. For licensing information regarding this file,
+please refer to the software package which it is part of.
+
+*/
+
+#include &quot;stdio.h&quot;
+#include &quot;ADM_jsEditor.h&quot;
+void jsEditor(void)
+{
+        printf(&quot;Constructor invoked\n&quot;);
+}
+
+#ifdef HAVE_ALLOCA_H
+#include &lt;alloca.h&gt;
+static size_t jj_alloca_limit = 0;
+#endif
+#include &lt;stdlib.h&gt;
+#include &lt;string.h&gt;
+#include &lt;wchar.h&gt;
+#ifdef HAVE_ALLOCA_H
+#endif
+#include &lt;jsapi.h&gt;
+#ifndef JS_THREADSAFE
+#if JS_VERSION &lt;= 170
+#define jsrefcount int
+#define JS_BeginRequest(cx)
+#define JS_EndRequest(cx)
+#define JS_SuspendRequest(cx)
+#define JS_ResumeRequest(cx, saveDepth)
+#endif
+#endif
+#ifndef JS_FS
+#define JS_FS(name, call, nargs, flags, extra) {name, call, nargs, flags, extra}
+#endif
+#ifndef JS_FS_END
+#define JS_FS_END {NULL, NULL, 0, 0, 0}
+#endif
+
+static JSBool
+jjeditorprintTiming(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
+{
+    JSObject * var2;
+    int var3;
+    int var6;
+    int var7;
+    int var8;
+    jsval var9;
+    int32 var10;
+    jsval var11;
+    JSBool var1;
+    var2 = NULL;
+    var3 = 0;
+    var6 = 0;
+    var7 = 0;
+    var8 = 0;
+    var9 = JSVAL_NULL;
+    var10 = 0;
+    var11 = JSVAL_NULL;
+    var1 = JS_FALSE;
+    var2 = obj;
+    var6 = argc;
+    var8 = 0;
+    var8 = var8 &lt; var6;
+    if (var8) {
+    var9 = argv[0];
+    if (JS_ValueToInt32(cx, var9, &amp;var10) != JS_TRUE) {
+        goto do_return;
+    }
+    var7 = (int)var10;
+    }
+    var3 = jsPrintTiming(var7);
+    if (JS_NewNumberValue(cx, var3, &amp;var11) != JS_TRUE) {
+        goto do_return;
+    }
+    argv[argc+0] = var11;
+    if (rval) {
+        *rval = var11;
+    }
+    var1 = JS_TRUE;
+    do_return:
+    return var1;
+}
+static JSBool
+jjeditordumpSegment(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
+{
+    JSObject * var13;
+    int var14;
+    int var17;
+    jsval var18;
+    JSBool var12;
+    var13 = NULL;
+    var14 = 0;
+    var17 = 0;
+    var18 = JSVAL_NULL;
+    var12 = JS_FALSE;
+    var13 = obj;
+    var17 = argc;
+    var14 = jsDumpSegments();
+    if (JS_NewNumberValue(cx, var14, &amp;var18) != JS_TRUE) {
+        goto do_return;
+    }
+    argv[argc+0] = var18;
+    if (rval) {
+        *rval = var18;
+    }
+    var12 = JS_TRUE;
+    do_return:
+    return var12;
+}
+static JSBool
+jjeditordumpRefVideo(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
+{
+    JSObject * var20;
+    int var21;
+    int var24;
+    jsval var25;
+    JSBool var19;
+    var20 = NULL;
+    var21 = 0;
+    var24 = 0;
+    var25 = JSVAL_NULL;
+    var19 = JS_FALSE;
+    var20 = obj;
+    var24 = argc;
+    var21 = jsDumpRefVideos();
+    if (JS_NewNumberValue(cx, var21, &amp;var25) != JS_TRUE) {
+        goto do_return;
+    }
+    argv[argc+0] = var25;
+    if (rval) {
+        *rval = var25;
+    }
+    var19 = JS_TRUE;
+    do_return:
+    return var19;
+}
+static JSBool
+jjeditor__construct__(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
+{
+    JSObject * var27;
+    int var31;
+    JSBool var26;
+    var27 = NULL;
+    var31 = 0;
+    var26 = JS_FALSE;
+    var27 = obj;
+    var31 = argc;
+    jsEditor();
+    var26 = JS_TRUE;
+    return var26;
+}
+static JSPropertySpec jj_static_ps[] = {
+    {NULL, 0, 0, NULL, NULL}
+};
+static JSPropertySpec jj_ps[] = {
+    {NULL, 0, 0, NULL, NULL}
+};
+static JSFunctionSpec jj_static_fs[] = {
+    JS_FS_END
+};
+static JSFunctionSpec jj_fs[] = {
+    JS_FS_END
+};
+static JSPropertySpec jjeditor_static_ps[] = {
+    {NULL, 0, 0, NULL, NULL}
+};
+static JSPropertySpec jjeditor_ps[] = {
+    {NULL, 0, 0, NULL, NULL}
+};
+static JSFunctionSpec jjeditor_static_fs[] = {
+    JS_FS(&quot;printTiming&quot;, jjeditorprintTiming, 1, 0, 1),
+    JS_FS(&quot;dumpSegment&quot;, jjeditordumpSegment, 0, 0, 1),
+    JS_FS(&quot;dumpRefVideo&quot;, jjeditordumpRefVideo, 0, 0, 1),
+    JS_FS_END
+};
+static JSFunctionSpec jjeditor_fs[] = {
+    JS_FS_END
+};
+static JSClass jjeditor_class = {
+    &quot;editor&quot;,
+    0,
+    JS_PropertyStub,
+    JS_PropertyStub,
+    JS_PropertyStub,
+    JS_PropertyStub,
+    JS_EnumerateStub,
+    JS_ResolveStub,
+    JS_ConvertStub,
+    JS_FinalizeStub,
+    NULL,
+    NULL,
+    NULL,
+    jjeditor__construct__,
+    NULL,
+    NULL,
+    NULL,
+    NULL
+};
+static JSObject *
+jjeditor_init(JSContext *cx, JSObject *obj)
+{
+    JSObject *parent_proto, *proto;
+    JSClass *class;
+    if (!cx || !obj) {
+        JS_ReportError(cx, &quot;invalid parameter&quot;);
+        return NULL;
+    }
+    if (!JS_EnterLocalRootScope(cx)) {
+        JS_ReportError(cx, &quot;JS_EnterLocalRootScope failed&quot;);
+        return NULL;
+    }
+    parent_proto = NULL;
+    proto = NULL;
+    parent_proto = JS_NewObject(cx, NULL, NULL, NULL);
+    if (!parent_proto) {
+        JS_LeaveLocalRootScope(cx);
+        JS_ReportError(cx, &quot;failed to create prototype&quot;);
+        return NULL;
+    }
+    class = &amp;jjeditor_class;
+    proto = JS_InitClass(cx, obj, parent_proto, class, jjeditor__construct__, 0, jjeditor_ps, jjeditor_fs, jjeditor_static_ps, jjeditor_static_fs);
+    if (!proto) {
+        JS_LeaveLocalRootScope(cx);
+        JS_ReportError(cx, &quot;failed to init class&quot;);
+        return NULL;
+    }
+    JS_LeaveLocalRootScope(cx);
+    return proto;
+}
+
+
+JSObject *jsEditorInit(JSContext *cx,JSObject *obj)
+{
+          if (JS_DefineFunctions(cx, obj, jj_static_fs) != JS_TRUE) 
+          {
+                return NULL;
+          }
+          return jjeditor_init(cx,obj);
+}
+
+JSFunctionSpec  *jsGetEditFunctions(void)
+{
+        return jjeditor_static_fs;
+}
+
+

Copied: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/js/ADM_jsEditor_js.idl (from rev 6206, branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsEditor_js.idl)
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsEditor_js.idl	2010-05-20 15:22:49 UTC (rev 6206)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/js/ADM_jsEditor_js.idl	2010-05-20 15:22:52 UTC (rev 6207)
@@ -0,0 +1,37 @@
+%{
+#include &quot;stdio.h&quot;
+#include &quot;ADM_jsEditor.h&quot;
+void jsEditor(void)
+{
+        printf(&quot;Constructor invoked\n&quot;);
+}
+%}
+        /*            JSFUNC      C FUNC  PARAM     */
+class editor
+{
+        /*            JSFUNC                 C FUNC           PARAM     */
+        function int printTiming     : jsPrintTiming(int ) &lt;static&gt;;
+        function int dumpSegment     : jsDumpSegments()    &lt;static&gt;;
+        function int dumpRefVideo    : jsDumpRefVideos()   &lt;static&gt;;
+        /*            JSFUNC                 C FUNC           PARAM     */
+        
+        construct                          : jsEditor  ( ) &lt;static&gt;     ; 
+};
+
+%&lt;
+
+JSObject *jsEditorInit(JSContext *cx,JSObject *obj)
+{
+          if (JS_DefineFunctions(cx, obj, jj_static_fs) != JS_TRUE) 
+          {
+                return NULL;
+          }
+          return jjeditor_init(cx,obj);
+}
+
+JSFunctionSpec  *jsGetEditFunctions(void)
+{
+        return jjeditor_static_fs;
+}
+
+%&gt;

Copied: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/js/ADM_jsIf.cpp (from rev 6206, branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsIf.cpp)
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsIf.cpp	2010-05-20 15:22:49 UTC (rev 6206)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/js/ADM_jsIf.cpp	2010-05-20 15:22:52 UTC (rev 6207)
@@ -0,0 +1,350 @@
+/**
+    \file ADM_JSif.cpp
+    \brief interface to js
+*/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include &quot;ADM_js.h&quot;
+#include &lt;stdarg.h&gt;
+#include &lt;vector&gt;
+#include &quot;ADM_editor/ADM_edit.hxx&quot;
+void    A_Resync(void);
+
+/* our variables */
+static jsLoggerFunc *jsLogger=NULL;
+static void *jsLoggerCookie=NULL;
+vector &lt;ADM_JS_HOOK &gt;jsHooks;
+extern ADM_Composer *video_body;
+extern bool ADM_JSDialogFactoryInit(JSContext *cx, JSObject *obj);
+#define JSVAR(a,b,c) a b=c
+
+#if defined( __MINGW32__) 
+ pthread_t g_pThreadSpidermonkey ;
+#else
+JSVAR( pthread_t, g_pThreadSpidermonkey , 0);
+#endif
+JSVAR( pthread_mutex_t, g_pSpiderMonkeyMutex , PTHREAD_MUTEX_INITIALIZER);
+// expose our main javascript context to the entire program
+static bool g_bJSSuccess=false;
+static JSObject   *g_pObject=NULL;
+static JSContext  *g_pCx=NULL;
+static JSRuntime  *g_pRt=NULL;
+
+static JSClass global_class = {
+            &quot;global&quot;, JSCLASS_GLOBAL_FLAGS,
+            JS_PropertyStub, JS_PropertyStub, JS_PropertyStub, JS_PropertyStub,
+            JS_EnumerateStub, JS_ResolveStub, JS_ConvertStub, JS_FinalizeStub,
+            JSCLASS_NO_OPTIONAL_MEMBERS
+            };
+
+extern void  printJSError(JSContext *cx, const char *message, JSErrorReport *report);
+/**
+    \fn parseECMAScript
+    \brief Compile &amp; execute ecma script
+*/
+bool parseECMAScript(const char *name)
+{// begin parseECMAScript
+	jsval rval;
+	uintN lineno = 0;
+	g_bJSSuccess = 0;
+	ADM_info(&quot;Spidermonkey compiling \&quot;%s\&quot;...&quot;,name);
+	JSScript *pJSScript = JS_CompileFile(g_pCx, g_pObject, name);
+	ADM_info(&quot;Done.\n&quot;);
+	if(pJSScript != NULL)
+	{// begin execute external file
+		printf(&quot;Spidermonkey executing \&quot;%s\&quot;...\n&quot;,name);
+		JSBool ok = JS_ExecuteScript(g_pCx, g_pObject, pJSScript, &amp;rval);
+		JS_DestroyScript(g_pCx,pJSScript);
+		ADM_info(&quot;Done.\n&quot;);
+	}// end execute external file
+        // Run garbage collector now, it is safe
+    JS_GC(g_pCx);
+	A_Resync();
+	return g_bJSSuccess;
+}// end parseECMAScript
+/**
+    \fn jsLogger
+*/
+bool isJsLogRedirected(void)
+{
+    if(jsLogger) return true;
+    return false;
+}
+/**
+    \fn jsEvaluate
+*/
+static bool jsEvaluate(const char *str)
+{
+jsval rval;
+   JS_EvaluateScript(g_pCx,g_pObject,str,strlen(str),&quot;dummy&quot;,1,&amp;rval);
+   return true; 
+}
+/**
+    \fn    interactiveECMAScript
+    \brief interprete &amp; execute ecma script (interactive)
+*/
+bool interactiveECMAScript(const char *name)
+{
+    ADM_startShell(jsEvaluate);
+    JS_GC(g_pCx);
+	A_Resync();
+    ADM_info(&quot;Ending JS shell...\n&quot;);
+	return true;
+}
+/**
+    \fn jsLog
+*/
+bool jsLog(JS_LOG_TYPE type, const char *prf,...)
+{
+ static char print_buffer[1024];
+  	
+		va_list 	list;
+		va_start(list,	prf);
+		vsnprintf(print_buffer,1023,prf,list);
+		va_end(list);
+		print_buffer[1023]=0; // ensure the string is terminated
+        if(true==isJsLogRedirected())
+            jsLogger(jsLoggerCookie,type,print_buffer);
+        else
+        {
+            if(type==JS_LOG_ERROR)
+                GUI_Error_HIG(&quot;Spidermonkey ECMAScript Error&quot;,&quot;%s&quot;,print_buffer);
+            else
+                ADM_warning(&quot;[JS]%s\n&quot;,print_buffer);
+        }
+
+        return true;
+}
+
+/**
+    \fn ADM_jsRegisterLogger
+*/
+bool ADM_jsRegisterLogger(void *cookie,jsLoggerFunc *fun)
+{
+    jsLoggerCookie=cookie;
+    jsLogger=fun;
+    return true;
+}
+/**
+    \fn ADM_jsUnregisterLogger
+*/
+bool ADM_jsUnregisterLogger(void)
+{
+    jsLogger=NULL;
+    return true;
+}
+/**
+    \fn jsRegisterAvidemux
+*/
+extern &quot;C&quot; JSFunctionSpec  *jsGetIfFunctions(void);
+extern &quot;C&quot; JSFunctionSpec  *jsGetTestFunctions(void);
+extern &quot;C&quot; JSFunctionSpec  *jsGetAdmFunctions(void);
+extern &quot;C&quot; JSFunctionSpec  *jsGetEditFunctions(void);
+extern &quot;C&quot; JSFunctionSpec  *jsGetDialogFactoryFunctions(void);
+extern &quot;C&quot; JSObject *jsEditorInit(JSContext *cx,JSObject *obj);
+extern &quot;C&quot; JSObject *jsAvidemuxInit(JSContext *cx,JSObject *obj);
+static bool registerOne(const char *name,const char *text,JSFunctionSpec *s,JSContext *cx,JSObject *obj)
+{
+    if (JS_DefineFunctions(cx, obj, s) != JS_TRUE) 
+    {
+            ADM_error(&quot;Cannot register %s functions\n&quot;,name);
+            return false;
+    }
+    ADM_info(&quot;Registered %s functions\n&quot;,name);
+    ADM_JS_HOOK h;
+    h.name=name;    
+    h.text=text;
+    h.jsFunctions=s;
+    jsHooks.push_back(h);
+    return true;
+}
+static void  dump(JSFunctionSpec *f)
+{
+    while(f-&gt;name)
+    {
+        jsLog(JS_LOG_NORMAL,&quot;    %s&quot;,f-&gt;name);
+        f++;
+    }
+}
+/**
+    \fn jsHelp
+    \brief help command
+
+*/
+extern &quot;C&quot; 
+{
+void jsHelp(const char *s)
+{
+int n=jsHooks.size();
+    if(!s) goto none;
+    {
+    for(int i=0;i&lt;n;i++)
+        if(!strcasecmp(s,jsHooks[i].name))
+        {
+            const char *t=jsHooks[i].text;
+            if(t)
+                jsLog(JS_LOG_NORMAL,&quot;%s&quot;,t);
+            return dump(jsHooks[i].jsFunctions);
+        }
+    }
+//    if(!strcasecmp(s,&quot;load&quot;)) return dump(jsGetAvidemuxFunctions());
+none:
+        jsLog(JS_LOG_NORMAL,&quot;please use help(\&quot;xxx\&quot;) with xx among&quot;);
+
+        for(int i=0;i&lt;n;i++)
+            jsLog(JS_LOG_NORMAL,&quot;    %s&quot;,jsHooks[i].name);
+
+}
+} // extern &quot;C&quot;
+/**
+    \fn jsRegisterAvidemux
+    \brief Register avidemux hookd
+*/
+static bool jsRegisterAvidemux(JSContext *cx,JSObject *obj)
+{
+ADM_JS_HOOK h;
+        registerOne(&quot;Debug&quot;,&quot;&quot;,   jsGetIfFunctions(),    cx,obj);
+        registerOne(&quot;Test&quot;,&quot;&quot;, jsGetTestFunctions(),  cx,obj);
+        
+        // Register also our class (for  help() )
+            h.name=&quot;adm&quot;;
+            h.text=&quot;Please prefix this with adm.&quot;;
+            h.jsFunctions=jsGetAdmFunctions();
+            jsHooks.push_back(h);
+            jsAvidemuxInit(cx,obj);
+        // Register also edit
+            h.name=&quot;editor&quot;;
+            h.text=&quot;Please prefix this with editor.&quot;;
+            h.jsFunctions=jsGetEditFunctions();
+            jsEditorInit(cx,obj);
+            jsHooks.push_back(h);
+        // Register dialogFactory functions
+#if 0
+            h.name=&quot;dialog&quot;;
+            h.text=&quot;.&quot;;
+            h.jsFunctions=jsGetDialogFactoryFunctions();
+            jsHooks.push_back(h);
+#endif
+            return ADM_JSDialogFactoryInit(cx,obj);
+}
+/**
+    \fn SpidermonkeyInit
+*/
+bool SpidermonkeyInit()
+{// begin SpidermonkeyInit
+	// setup JS
+	g_pCx = NULL;
+	g_pObject = NULL;
+	g_pRt = NULL;
+	JSRuntime *rt = JS_NewRuntime(1000000L);
+	g_pRt = rt;
+	if ( !rt  )
+	{
+		// Do some error reporting
+		ADM_error(&quot;Spidermonkey failed to initialize runtime!\n&quot;);
+        return false;
+	}
+	
+// begin runtime created
+    g_pCx = JS_NewContext(rt, 8192);
+    if ( !g_pCx  )
+    {
+        // Do some error reporting
+        ADM_error(&quot;Spidermonkey failed to initialize context!\n&quot;);
+        return false;
+    }
+   
+   // begin context created
+    g_pObject = JS_NewObject(g_pCx, &amp;global_class, 0, 0);
+    if(!g_pObject)
+    {
+        ADM_error(&quot;Cannot initialize object\n&quot;);
+        return false;
+    }
+    if(JS_TRUE!=JS_InitStandardClasses(g_pCx, g_pObject))
+    {
+        ADM_error(&quot;Cannot initialize standard classes\n&quot;);
+        return false;
+    }
+    // register error handler
+    JS_SetErrorReporter(g_pCx, printJSError);
+        
+    //register our functions
+    jsRegisterAvidemux(g_pCx,g_pObject);
+    ADM_info(&quot;Spidermonkey initialized\n&quot;);
+    return true;
+
+}// end SpidermonkeyInit
+/**
+    \fn SpidermonkeyDestroy
+*/
+void SpidermonkeyDestroy()
+{// begin SpidermonkeyDestroy
+#ifdef ADM_JS_THREADSAFE
+	JS_SetContextThread(g_pCx);	
+#endif
+	JS_DestroyContext(g_pCx);
+	JS_DestroyRuntime(g_pRt);
+}// end SpidermonkeyDestroy
+/**
+    \fn StartThreadSpidermonkey
+*/
+void *StartThreadSpidermonkey(void *pData)
+{// begin StartThreadSpidermonkey
+        pthread_mutex_lock(&amp;g_pSpiderMonkeyMutex);
+        /*
+        The following mailling list post describes how to CORRECTLY use
+        the threading API support with Spidermonkey
+        &quot;Thread from SpiderMonkey newsgroup&quot;
+        <A HREF="http://archive.gingerall.cz/archives/public/sablot2004/msg00117.html">http://archive.gingerall.cz/archives/public/sablot2004/msg00117.html</A>
+        */
+        // Notify the Spidermonkey that we'll be processing in a thread
+#ifdef ADM_JS_THREADSAFE
+        JS_SetContextThread(g_pCx);
+        JS_BeginRequest(g_pCx);
+#endif
+        bool ret = false;
+        const char *pScriptFile = static_cast&lt;const char *&gt;(pData);
+        ret = parseECMAScript(pScriptFile);
+        if(ret == true)
+        {
+                video_body-&gt;setProjectName(pScriptFile);
+        }
+        // Notify Spidermonkey that our thread processing has finished
+#ifdef ADM_JS_THREADSAFE
+        JS_EndRequest(g_pCx);
+        JS_ClearContextThread(g_pCx);
+#endif
+        pthread_mutex_unlock(&amp;g_pSpiderMonkeyMutex);
+
+        return NULL;
+}// end StartThreadSpidermonkey
+/**
+    \fn JS_setSuccess
+*/
+extern &quot;C&quot; void jsSetSuccess(int bSuccess)
+{// begin JS_setSuccess
+	g_bJSSuccess = bSuccess;
+	jsLog(JS_LOG_NORMAL,&quot;[ECMA] success : %d\n&quot;, g_bJSSuccess);
+}// end JS_setSuccess
+/**
+    \fn SpidermonkeyExit
+*/
+bool SpidermonkeyExit(void)
+{
+    ADM_info(&quot;Waiting for Spidermonkey to finish...\n&quot;);
+    pthread_mutex_lock(&amp;g_pSpiderMonkeyMutex);
+    ADM_info(&quot;Cleaning up Spidermonkey.\n&quot;);
+    SpidermonkeyDestroy();
+    pthread_mutex_unlock(&amp;g_pSpiderMonkeyMutex);
+    return true;
+}
+//EOF

Copied: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/js/ADM_jsIf_js.c (from rev 6206, branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsIf_js.c)
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsIf_js.c	2010-05-20 15:22:49 UTC (rev 6206)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/js/ADM_jsIf_js.c	2010-05-20 15:22:52 UTC (rev 6207)
@@ -0,0 +1,504 @@
+/*
+--- DO NOT EDIT THIS FILE !!! ---
+
+This file has been generated automatically with 'jsapigen'.
+
+jsapigen is a glue-code generator for SpiderMonkey. It is distributed
+under the conditions of version 3 of the GNU General Public License.
+Please have a look at <A HREF="http://jsapigen.sourceforge.net.">http://jsapigen.sourceforge.net.</A>
+
+This file is NOT part of jsapigen and is NOT necessarily covered by
+jsapigen's license. For licensing information regarding this file,
+please refer to the software package which it is part of.
+
+*/
+
+#include &quot;stdio.h&quot;
+#include &quot;ADM_jsAvidemux.h&quot;
+#include &quot;ADM_jsDebug.h&quot;
+
+#ifdef HAVE_ALLOCA_H
+#include &lt;alloca.h&gt;
+static size_t jj_alloca_limit = 0;
+#endif
+#include &lt;stdlib.h&gt;
+#include &lt;string.h&gt;
+#include &lt;wchar.h&gt;
+#ifdef HAVE_ALLOCA_H
+#endif
+#include &lt;jsapi.h&gt;
+#ifndef JS_THREADSAFE
+#if JS_VERSION &lt;= 170
+#define jsrefcount int
+#define JS_BeginRequest(cx)
+#define JS_EndRequest(cx)
+#define JS_SuspendRequest(cx)
+#define JS_ResumeRequest(cx, saveDepth)
+#endif
+#endif
+#ifndef JS_FS
+#define JS_FS(name, call, nargs, flags, extra) {name, call, nargs, flags, extra}
+#endif
+#ifndef JS_FS_END
+#define JS_FS_END {NULL, NULL, 0, 0, 0}
+#endif
+
+static JSBool
+jjadmPopupError(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
+{
+    JSObject * var2;
+    int var6;
+    char * var7;
+    int var8;
+    jsval var9;
+    JSString * var10;
+    jsval var86;
+    size_t var11;
+    size_t var12;
+    int var14;
+    jschar * var15;
+    jsval var87;
+    JSBool var1;
+    var2 = NULL;
+    var6 = 0;
+    var7 = NULL;
+    var8 = 0;
+    var9 = JSVAL_NULL;
+    var10 = NULL;
+    var86 = JSVAL_NULL;
+    var11 = 0;
+    var12 = 0;
+    var14 = 0;
+    var15 = NULL;
+    var87 = JSVAL_NULL;
+    var1 = JS_FALSE;
+    var2 = obj;
+    var6 = argc;
+    var8 = 0;
+    var8 = var8 &lt; var6;
+    if (var8) {
+    var9 = argv[0];
+    var10 = JS_ValueToString(cx, var9);
+    if (!var10) {
+        goto do_return;
+    }
+    var86 = STRING_TO_JSVAL(var10);
+    argv[argc+0] = var86;
+    var11 = JS_GetStringLength(var10);
+    var12 = 1;
+    var12 += var11;
+#ifdef HAVE_ALLOCA
+    if (var12 &lt; jj_alloca_limit) {
+        var7 = alloca(var12);
+    } else {
+#endif
+        var7 = malloc(var12);
+        if (!var7) {
+            goto do_return;
+        } else {
+            var14 = 1;
+        }
+#ifdef HAVE_ALLOCA
+    }
+#endif
+    var15 = JS_GetStringChars(var10);
+    var87 = STRING_TO_JSVAL(var10);
+    argv[argc+1] = var87;
+    {
+        size_t i;
+        for (i = 0; i &lt; var11; ++i) {
+            var7[i] = var15[i];
+        }
+        var7[var11] = '\0';
+    }
+    }
+    jsPopupError(var7);
+    var1 = JS_TRUE;
+    do_return:
+    if (var14) {
+        free(var7);
+        var7 = NULL;
+        var14 = 0;
+    }
+    return var1;
+}
+static JSBool
+jjadmpPopupInfo(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
+{
+    JSObject * var17;
+    int var21;
+    char * var22;
+    int var23;
+    jsval var24;
+    JSString * var25;
+    jsval var88;
+    size_t var26;
+    size_t var27;
+    int var29;
+    jschar * var30;
+    jsval var89;
+    JSBool var16;
+    var17 = NULL;
+    var21 = 0;
+    var22 = NULL;
+    var23 = 0;
+    var24 = JSVAL_NULL;
+    var25 = NULL;
+    var88 = JSVAL_NULL;
+    var26 = 0;
+    var27 = 0;
+    var29 = 0;
+    var30 = NULL;
+    var89 = JSVAL_NULL;
+    var16 = JS_FALSE;
+    var17 = obj;
+    var21 = argc;
+    var23 = 0;
+    var23 = var23 &lt; var21;
+    if (var23) {
+    var24 = argv[0];
+    var25 = JS_ValueToString(cx, var24);
+    if (!var25) {
+        goto do_return;
+    }
+    var88 = STRING_TO_JSVAL(var25);
+    argv[argc+0] = var88;
+    var26 = JS_GetStringLength(var25);
+    var27 = 1;
+    var27 += var26;
+#ifdef HAVE_ALLOCA
+    if (var27 &lt; jj_alloca_limit) {
+        var22 = alloca(var27);
+    } else {
+#endif
+        var22 = malloc(var27);
+        if (!var22) {
+            goto do_return;
+        } else {
+            var29 = 1;
+        }
+#ifdef HAVE_ALLOCA
+    }
+#endif
+    var30 = JS_GetStringChars(var25);
+    var89 = STRING_TO_JSVAL(var25);
+    argv[argc+1] = var89;
+    {
+        size_t i;
+        for (i = 0; i &lt; var26; ++i) {
+            var22[i] = var30[i];
+        }
+        var22[var26] = '\0';
+    }
+    }
+    jsPopupInfo(var22);
+    var16 = JS_TRUE;
+    do_return:
+    if (var29) {
+        free(var22);
+        var22 = NULL;
+        var29 = 0;
+    }
+    return var16;
+}
+static JSBool
+jjadmPrint(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
+{
+    JSObject * var32;
+    int var36;
+    char * var37;
+    int var38;
+    jsval var39;
+    JSString * var40;
+    jsval var90;
+    size_t var41;
+    size_t var42;
+    int var44;
+    jschar * var45;
+    jsval var91;
+    JSBool var31;
+    var32 = NULL;
+    var36 = 0;
+    var37 = NULL;
+    var38 = 0;
+    var39 = JSVAL_NULL;
+    var40 = NULL;
+    var90 = JSVAL_NULL;
+    var41 = 0;
+    var42 = 0;
+    var44 = 0;
+    var45 = NULL;
+    var91 = JSVAL_NULL;
+    var31 = JS_FALSE;
+    var32 = obj;
+    var36 = argc;
+    var38 = 0;
+    var38 = var38 &lt; var36;
+    if (var38) {
+    var39 = argv[0];
+    var40 = JS_ValueToString(cx, var39);
+    if (!var40) {
+        goto do_return;
+    }
+    var90 = STRING_TO_JSVAL(var40);
+    argv[argc+0] = var90;
+    var41 = JS_GetStringLength(var40);
+    var42 = 1;
+    var42 += var41;
+#ifdef HAVE_ALLOCA
+    if (var42 &lt; jj_alloca_limit) {
+        var37 = alloca(var42);
+    } else {
+#endif
+        var37 = malloc(var42);
+        if (!var37) {
+            goto do_return;
+        } else {
+            var44 = 1;
+        }
+#ifdef HAVE_ALLOCA
+    }
+#endif
+    var45 = JS_GetStringChars(var40);
+    var91 = STRING_TO_JSVAL(var40);
+    argv[argc+1] = var91;
+    {
+        size_t i;
+        for (i = 0; i &lt; var41; ++i) {
+            var37[i] = var45[i];
+        }
+        var37[var41] = '\0';
+    }
+    }
+    jsPrint(var37);
+    var31 = JS_TRUE;
+    do_return:
+    if (var44) {
+        free(var37);
+        var37 = NULL;
+        var44 = 0;
+    }
+    return var31;
+}
+static JSBool
+jjprint(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
+{
+    JSObject * var47;
+    int var51;
+    char * var52;
+    int var53;
+    jsval var54;
+    JSString * var55;
+    jsval var92;
+    size_t var56;
+    size_t var57;
+    int var59;
+    jschar * var60;
+    jsval var93;
+    JSBool var46;
+    var47 = NULL;
+    var51 = 0;
+    var52 = NULL;
+    var53 = 0;
+    var54 = JSVAL_NULL;
+    var55 = NULL;
+    var92 = JSVAL_NULL;
+    var56 = 0;
+    var57 = 0;
+    var59 = 0;
+    var60 = NULL;
+    var93 = JSVAL_NULL;
+    var46 = JS_FALSE;
+    var47 = obj;
+    var51 = argc;
+    var53 = 0;
+    var53 = var53 &lt; var51;
+    if (var53) {
+    var54 = argv[0];
+    var55 = JS_ValueToString(cx, var54);
+    if (!var55) {
+        goto do_return;
+    }
+    var92 = STRING_TO_JSVAL(var55);
+    argv[argc+0] = var92;
+    var56 = JS_GetStringLength(var55);
+    var57 = 1;
+    var57 += var56;
+#ifdef HAVE_ALLOCA
+    if (var57 &lt; jj_alloca_limit) {
+        var52 = alloca(var57);
+    } else {
+#endif
+        var52 = malloc(var57);
+        if (!var52) {
+            goto do_return;
+        } else {
+            var59 = 1;
+        }
+#ifdef HAVE_ALLOCA
+    }
+#endif
+    var60 = JS_GetStringChars(var55);
+    var93 = STRING_TO_JSVAL(var55);
+    argv[argc+1] = var93;
+    {
+        size_t i;
+        for (i = 0; i &lt; var56; ++i) {
+            var52[i] = var60[i];
+        }
+        var52[var56] = '\0';
+    }
+    }
+    jsPrint2(var52);
+    var46 = JS_TRUE;
+    do_return:
+    if (var59) {
+        free(var52);
+        var52 = NULL;
+        var59 = 0;
+    }
+    return var46;
+}
+static JSBool
+jjhelp(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
+{
+    JSObject * var62;
+    int var66;
+    char * var67;
+    int var68;
+    jsval var69;
+    JSString * var70;
+    jsval var94;
+    size_t var71;
+    size_t var72;
+    int var74;
+    jschar * var75;
+    jsval var95;
+    JSBool var61;
+    var62 = NULL;
+    var66 = 0;
+    var67 = NULL;
+    var68 = 0;
+    var69 = JSVAL_NULL;
+    var70 = NULL;
+    var94 = JSVAL_NULL;
+    var71 = 0;
+    var72 = 0;
+    var74 = 0;
+    var75 = NULL;
+    var95 = JSVAL_NULL;
+    var61 = JS_FALSE;
+    var62 = obj;
+    var66 = argc;
+    var68 = 0;
+    var68 = var68 &lt; var66;
+    if (var68) {
+    var69 = argv[0];
+    var70 = JS_ValueToString(cx, var69);
+    if (!var70) {
+        goto do_return;
+    }
+    var94 = STRING_TO_JSVAL(var70);
+    argv[argc+0] = var94;
+    var71 = JS_GetStringLength(var70);
+    var72 = 1;
+    var72 += var71;
+#ifdef HAVE_ALLOCA
+    if (var72 &lt; jj_alloca_limit) {
+        var67 = alloca(var72);
+    } else {
+#endif
+        var67 = malloc(var72);
+        if (!var67) {
+            goto do_return;
+        } else {
+            var74 = 1;
+        }
+#ifdef HAVE_ALLOCA
+    }
+#endif
+    var75 = JS_GetStringChars(var70);
+    var95 = STRING_TO_JSVAL(var70);
+    argv[argc+1] = var95;
+    {
+        size_t i;
+        for (i = 0; i &lt; var71; ++i) {
+            var67[i] = var75[i];
+        }
+        var67[var71] = '\0';
+    }
+    }
+    jsHelp(var67);
+    var61 = JS_TRUE;
+    do_return:
+    if (var74) {
+        free(var67);
+        var67 = NULL;
+        var74 = 0;
+    }
+    return var61;
+}
+static JSBool
+jjsetSuccess(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
+{
+    JSObject * var77;
+    int var81;
+    int var82;
+    int var83;
+    jsval var84;
+    int32 var85;
+    JSBool var76;
+    var77 = NULL;
+    var81 = 0;
+    var82 = 0;
+    var83 = 0;
+    var84 = JSVAL_NULL;
+    var85 = 0;
+    var76 = JS_FALSE;
+    var77 = obj;
+    var81 = argc;
+    var83 = 0;
+    var83 = var83 &lt; var81;
+    if (var83) {
+    var84 = argv[0];
+    if (JS_ValueToInt32(cx, var84, &amp;var85) != JS_TRUE) {
+        goto do_return;
+    }
+    var82 = (int)var85;
+    }
+    jsSetSuccess(var82);
+    var76 = JS_TRUE;
+    do_return:
+    return var76;
+}
+static JSPropertySpec jj_static_ps[] = {
+    {NULL, 0, 0, NULL, NULL}
+};
+static JSPropertySpec jj_ps[] = {
+    {NULL, 0, 0, NULL, NULL}
+};
+static JSFunctionSpec jj_static_fs[] = {
+    JS_FS(&quot;admPopupError&quot;, jjadmPopupError, 1, 0, 2),
+    JS_FS(&quot;admpPopupInfo&quot;, jjadmpPopupInfo, 1, 0, 2),
+    JS_FS(&quot;admPrint&quot;, jjadmPrint, 1, 0, 2),
+    JS_FS(&quot;print&quot;, jjprint, 1, 0, 2),
+    JS_FS(&quot;help&quot;, jjhelp, 1, 0, 2),
+    JS_FS(&quot;setSuccess&quot;, jjsetSuccess, 1, 0, 0),
+    JS_FS_END
+};
+static JSFunctionSpec jj_fs[] = {
+    JS_FS(&quot;admPopupError&quot;, jjadmPopupError, 1, 0, 2),
+    JS_FS(&quot;admpPopupInfo&quot;, jjadmpPopupInfo, 1, 0, 2),
+    JS_FS(&quot;admPrint&quot;, jjadmPrint, 1, 0, 2),
+    JS_FS(&quot;print&quot;, jjprint, 1, 0, 2),
+    JS_FS(&quot;help&quot;, jjhelp, 1, 0, 2),
+    JS_FS(&quot;setSuccess&quot;, jjsetSuccess, 1, 0, 0),
+    JS_FS_END
+};
+
+JSFunctionSpec  *jsGetIfFunctions(void)
+{
+        return jj_static_fs;
+}
+
+

Copied: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/js/ADM_jsIf_js.idl (from rev 6206, branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsIf_js.idl)
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsIf_js.idl	2010-05-20 15:22:49 UTC (rev 6206)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/js/ADM_jsIf_js.idl	2010-05-20 15:22:52 UTC (rev 6207)
@@ -0,0 +1,25 @@
+%{
+#include &quot;stdio.h&quot;
+#include &quot;ADM_jsAvidemux.h&quot;
+#include &quot;ADM_jsDebug.h&quot;
+%}
+
+/*
+###############################################################
+       return JS function     CM Function  params
+###############################################################
+*/
+function void admPopupError : jsPopupError   (cstring  ) &lt;static&gt;;
+function void admpPopupInfo : jsPopupInfo    (cstring  ) &lt;static&gt;;
+function void admPrint      : jsPrint        (cstring  ) &lt;static&gt;;
+function void print         : jsPrint2       (cstring  ) &lt;static&gt;;
+function void help          : jsHelp         (cstring  ) &lt;static&gt;;
+function void setSuccess    : jsSetSuccess   (int  )   &lt;static&gt;;
+
+%&lt;
+JSFunctionSpec  *jsGetIfFunctions(void)
+{
+        return jj_static_fs;
+}
+
+%&gt;

Copied: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/js/ADM_jsTestFactory.cpp (from rev 6206, branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsTestFactory.cpp)
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsTestFactory.cpp	2010-05-20 15:22:49 UTC (rev 6206)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/js/ADM_jsTestFactory.cpp	2010-05-20 15:22:52 UTC (rev 6207)
@@ -0,0 +1,444 @@
+/**
+    \file ADM_JSif.cpp
+    \brief interface to js
+
+ Author: Anish Mistry/mean/gruntster
+*/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include &quot;ADM_js.h&quot;
+#include &quot;ADM_editor/ADM_edit.hxx&quot;
+#include &quot;DIA_fileSel.h&quot;
+#include &quot;DIA_factory.h&quot;
+#include &quot;ADM_jsTestFactory.h&quot;
+#include &quot;DIA_encoding.h&quot;
+
+/**
+    \fn crashTest
+    \brief Force a crash
+*/
+int jsTestCrash(void)
+{
+  
+  int *foobar=NULL;
+  *foobar=0; // CRASH!
+  return true;
+}
+/**
+    \fn assertTest
+    \brief Force a crash
+*/
+int jsTestAssert(void)
+{
+  
+  ADM_assert(0);
+  return true;
+}
+
+
+/**
+    \fn jsTestFacInt
+*/
+int jsTestFacInt(void)
+{
+  uint32_t tog=0;
+   diaElemUInteger blend(&amp;tog,QT_TR_NOOP(&quot;Uinteger&quot;),0,255);
+    diaElem *elems[]={&amp;blend   };
+    
+  if(diaFactoryRun(QT_TR_NOOP(&quot;Test uinteger&quot;),1,elems))
+  {
+    jsLog(JS_LOG_NORMAL,&quot;Value : %u\n&quot;,tog);
+    return true;
+  }
+  return false;
+}
+
+/**
+    \fn jsTestFacFloat
+*/
+int jsTestFacFloat(void)
+{
+  ELEM_TYPE_FLOAT tog=0;
+   diaElemFloat blend(&amp;tog,QT_TR_NOOP(&quot;Float&quot;),0,255);
+    diaElem *elems[]={&amp;blend   };
+    
+  if(diaFactoryRun(&quot;Test float&quot;,1,elems))
+  {
+    jsLog(JS_LOG_NORMAL,&quot;Value : %f\n&quot;,(float)tog);
+    return true;
+  }
+  return false;
+}
+
+/**
+    \fn jsTestFacToggle
+*/
+int jsTestFacToggle(void)
+{
+  uint32_t tog=0;
+  uint32_t test=0;
+   diaElemToggle blend(&amp;tog,QT_TR_NOOP(&quot;Toggle&quot;));
+    diaElemUInteger     bt(&amp;test,&quot;Entry&quot;,0,10);
+    diaElemUInteger     bt2(&amp;test,&quot;Entry&quot;,0,10);
+    diaElem *elems[]={&amp;blend,&amp;bt,&amp;bt2   };
+    blend.link(1,&amp;bt);
+    blend.link(0,&amp;bt2);
+    
+  if(diaFactoryRun(&quot;Test Toggle&quot;,3,elems))
+   {
+    jsLog(JS_LOG_NORMAL,&quot;Value : %u\n&quot;,tog);
+    return true;
+  }
+  return false;
+}
+
+/**
+    \fn jsTestFacMenu
+*/
+int jsTestFacMenu(void)
+{
+   uint32_t tog=4;
+   ELEM_TYPE_FLOAT f=1; 
+   
+    diaMenuEntry menu[]={
+                             {2,   QT_TR_NOOP(&quot;No Strategy&quot;),NULL},
+                             {4,     QT_TR_NOOP(&quot;3:2 Pulldown&quot;),NULL},
+                             {6,     QT_TR_NOOP(&quot;Pal/Secam&quot;),NULL},
+                             {7,  QT_TR_NOOP(&quot;NTSC converted from PAL&quot;),NULL}
+                          };
+   diaElemMenu blend(&amp;tog,QT_TR_NOOP(&quot;menu&quot;),4,menu);
+    
+    // Link it to another
+    diaElemFloat toggle(&amp;f,&quot;Linked float&quot;,1,2);
+    blend.link(&amp;(menu[1]),1,&amp;toggle);
+    //
+diaElem *elems[]={&amp;blend,&amp;toggle   };
+  if(diaFactoryRun(&quot;Test Menu&quot;,2,elems))
+   {
+    jsLog(JS_LOG_NORMAL,&quot;Value : %&quot;LU&quot;\n&quot;,tog);
+    return true;
+  }
+  return false;
+}
+
+/**
+    \fn jsTestFacFile
+*/
+int jsTestFacFile(void)
+{
+   uint32_t tog=0;
+   char *test=ADM_strdup(&quot;Entry test1&quot;);
+    
+      diaElemFile fread(0,&amp;test,&quot;Entry&quot;);
+      diaElem *elems[]={&amp;fread   };
+  if(diaFactoryRun(&quot;Test FileRead&quot;,1,elems))
+   {
+    jsLog(JS_LOG_NORMAL,&quot;Value : %s\n&quot;,test);
+    if(test) ADM_dealloc(test);
+    return true;
+  }
+ if(test) ADM_dealloc(test);
+  return false;
+}
+
+/**
+    \fn jsTestFacDirSel
+*/
+int jsTestFacDirSel(void)
+{
+   uint32_t tog=0;
+   char *test=ADM_strdup(&quot;Entry test1&quot;);
+    
+  diaElemDirSelect fread(&amp;test,&quot;Entry&quot;);
+  diaElem *elems[]={&amp;fread   };
+  if(diaFactoryRun(&quot;Test DirSel&quot;,1,elems))
+  {
+    jsLog(JS_LOG_NORMAL,&quot;Value : %s\n&quot;,test);
+    if(test) ADM_dealloc(test);
+    return true;
+  }
+ if(test) ADM_dealloc(test);
+  return false;
+}
+
+/**
+    \fn jsTestFacBitrate
+*/
+int jsTestFacBitrate(void)
+{
+
+   COMPRES_PARAMS test={
+  COMPRESS_CQ,
+  1,
+  1500,
+  700,
+  1000,
+  ADM_ENC_CAP_CQ+ADM_ENC_CAP_2PASS+ADM_ENC_CAP_CBR+ADM_ENC_CAP_SAME
+  };
+    
+      diaElemBitrate bt(&amp;test,&quot;Entry&quot;);
+      diaElem *elems[]={&amp;bt   };
+  if(diaFactoryRun(&quot;Test BitRate&quot;,1,elems))
+   {
+    
+    return true;
+  }
+  return false;
+}
+
+/**
+    \fn jsTestFacInt
+*/
+int jsTestFacBar(void)
+{
+    
+      diaElemBar bar1(25,&quot;25&quot;);
+      diaElemBar bar2(65,&quot;65&quot;);
+      diaElem *elems[]={&amp;bar1,&amp;bar2   };
+  if(diaFactoryRun(&quot;Test FileRead&quot;,2,elems))
+  {
+   return true;
+  }
+  return false;
+}
+
+void clickMe(void *cookie)
+{
+  GUI_Error_HIG(&quot;Button&quot;,&quot;Button pressed!&quot;); 
+}
+
+/**
+    \fn jsTestFacButton
+*/
+int jsTestFacButton(void)
+{
+    
+      diaElemButton bar1(&quot;Button&quot;,clickMe,NULL);
+      diaElem *elems[]={&amp;bar1   };
+  if(diaFactoryRun(&quot;Test Button&quot;,1,elems))
+  {
+    return true;
+  }
+  return false;
+}
+
+/**
+    \fn jsTestFacSlider
+*/
+int jsTestFacSlider(void)
+{
+  int32_t val=4;
+      diaElemSlider slide(&amp;val,&quot;foo&quot;, 0,10);
+      
+      diaElem *elems[]={&amp;slide   };
+  if(diaFactoryRun(&quot;Test Slider&quot;,1,elems))
+  {
+    jsLog(JS_LOG_NORMAL,&quot;Value : %d\n&quot;,(int)val);
+    return true;
+  }
+  return false;
+}
+
+/**
+    \fn jsTestFacInt
+*/
+int jsTestFacRoText(void)
+
+{
+    
+      diaElemReadOnlyText txt(&quot;blah blah&quot;,&quot;Value:&quot;);
+      
+      diaElem *elems[]={&amp;txt   };
+  if(diaFactoryRun(&quot;Test FileRead&quot;,1,elems))
+  {
+    return true;
+  }
+  return false;
+}
+
+/**
+    \fn jsTestFacText
+*/
+int jsTestFacText(void)
+{
+    
+      char *foo=ADM_strdup(&quot;blah&quot;);
+      diaElemText txt(&amp;foo,&quot;Text&quot;,NULL);
+      
+      diaElem *elems[]={&amp;txt   };
+  if(diaFactoryRun(&quot;Test FileRead&quot;,1,elems))
+ {
+    jsLog(JS_LOG_NORMAL,&quot;Out:%s&quot;,foo);
+    if(foo) ADM_dealloc(foo);
+    return true;
+  }
+  if(foo) ADM_dealloc(foo);
+  return false;
+}
+
+/**
+    \fn jsTestFacInt
+*/
+int jsTestFacTab(void)
+{
+    
+      uint32_t test,test2;
+      
+      diaElemReadOnlyText txt(&quot;blah blah&quot;,&quot;Value:&quot;);
+      diaElemUInteger     bt(&amp;test,&quot;Entry&quot;,0,10);
+      diaElemUInteger     bt2(&amp;test2,&quot;Entry&quot;,0,10);
+      
+      
+      diaElem *elems1[]={&amp;txt   };
+      diaElem *elems2[]={&amp;bt,&amp;bt2   };
+      
+      diaElemTabs tab1(&quot;T1&quot;,1,(diaElem **)elems1);
+      diaElemTabs tab2(&quot;T2&quot;,2,(diaElem **)elems2);
+      
+      diaElemTabs *tabs[2]={&amp;tab1,&amp;tab2};
+          
+      
+  if(diaFactoryRunTabs(&quot;Test FileRead&quot;,2,tabs))
+ {
+    return true;
+  }
+  return false;
+}
+
+/**
+    \fn jsTestFacInt
+*/
+int jsTestFacFrame(void)
+{
+    
+      uint32_t test,test2;
+      
+      diaElemReadOnlyText align(&quot;*****&quot;,&quot;Value:&quot;);
+      diaElemReadOnlyText txt(&quot;blah blah&quot;,&quot;Value:&quot;);
+      diaElemUInteger     bt(&amp;test,&quot;Entry1&quot;,0,10);
+      diaElemUInteger     bt2(&amp;test2,&quot;Entry2&quot;,0,10);
+      diaElemFrame        frm(&quot;Frame1&quot;);
+      
+      frm.swallow(&amp;txt);
+      frm.swallow(&amp;bt);
+      frm.swallow(&amp;bt2);
+      
+         diaElem *elems[]={&amp;align,&amp;frm   };
+  if(diaFactoryRun(&quot;Test frame&quot;,2,elems))
+ {
+    return true;
+  }
+  return false;
+}
+
+
+/**
+    \fn jsTestFacHex
+*/
+int jsTestFacHex(void)
+{
+    
+      uint8_t data[100];
+      for(int i=0;i&lt;100;i++) data[i]=i;
+      
+      diaElemHex binhex(&quot;*****&quot;,100,data);
+      
+      
+         diaElem *elems[]={&amp;binhex   };
+  if(diaFactoryRun(&quot;Test binHex&quot;,1,elems))
+  {
+    return true;
+  }
+  return false;
+      
+}
+
+/**
+    \fn jsTestFacMatrix
+*/
+int jsTestFacMatrix(void)
+{
+    
+      uint8_t data[16];
+      for(int i=0;i&lt;100;i++) data[i]=i;
+      
+      diaElemMatrix Matrix(data,&quot;Matrix&quot;,4);
+      
+      
+         diaElem *elems[]={&amp;Matrix   };
+  if(diaFactoryRun(&quot;Test Matrix&quot;,1,elems))
+  {
+      for(int x=0;x&lt;4*4;x++)
+      {
+          if(x &amp;&amp; !(x&amp;3)) printf(&quot;\n&quot;);
+          jsLog(JS_LOG_NORMAL,&quot;%02x &quot;,data[x]);
+          
+      }
+      return true;
+  }
+  return false;
+}
+
+/**
+    \fn jsTestFacThreadcount
+*/
+int jsTestFacThreadCount(void)
+{
+	uint32_t val=1;
+	diaElemThreadCount threadcount(&amp;val,&quot;ThreadCount&quot;);
+      
+    diaElem *elems[]={&amp;threadcount   };
+    
+  if(diaFactoryRun(&quot;Test ThreadCount&quot;,1,elems))
+  {
+         jsLog(JS_LOG_NORMAL,&quot;Thread: %u &quot;,(unsigned int)val);
+        return true;
+  }
+  return false;
+}
+
+/**
+    \fn jsTestFacNotch
+*/
+int jsTestFacNotch(void)
+{
+    
+	diaElemNotch notch(1,&quot;Notch&quot;);
+      
+         diaElem *elems[]={&amp;notch   };
+  if(diaFactoryRun(&quot;Test Notch&quot;,1,elems))
+  {
+    return true;
+  }
+  return false;
+      
+}
+/**
+    \fn jsTestFacEncoding
+*/
+int jsTestFacEncoding(void)
+{
+    DIA_encodingBase *base=createEncoding(1000*1000LL);
+    base-&gt;setContainer(&quot;the container&quot;);
+    base-&gt;setAudioCodec(&quot;the audio codec&quot;);
+    base-&gt;setVideoCodec(&quot;the video codec&quot;);
+    for(int i=0;i&lt;20;i++)
+    {
+        base-&gt;refresh();
+        base-&gt;pushVideoFrame(10000,1,50*1000LL*i);
+        base-&gt;refresh();
+        printf(&quot;%d / %d\n&quot;,i,20);
+        ADM_usleep(500*1000);
+    }
+    delete base;
+    base=NULL;
+    return true;
+}
+//EOF 

Copied: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/js/ADM_jsTestFactory_js.c (from rev 6206, branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsTestFactory_js.c)
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsTestFactory_js.c	2010-05-20 15:22:49 UTC (rev 6206)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/js/ADM_jsTestFactory_js.c	2010-05-20 15:22:52 UTC (rev 6207)
@@ -0,0 +1,649 @@
+/*
+--- DO NOT EDIT THIS FILE !!! ---
+
+This file has been generated automatically with 'jsapigen'.
+
+jsapigen is a glue-code generator for SpiderMonkey. It is distributed
+under the conditions of version 3 of the GNU General Public License.
+Please have a look at <A HREF="http://jsapigen.sourceforge.net.">http://jsapigen.sourceforge.net.</A>
+
+This file is NOT part of jsapigen and is NOT necessarily covered by
+jsapigen's license. For licensing information regarding this file,
+please refer to the software package which it is part of.
+
+*/
+
+#include &quot;stdio.h&quot;
+#include &quot;ADM_jsAvidemux.h&quot;
+#include &quot;ADM_jsTestFactory.h&quot;
+
+#ifdef HAVE_ALLOCA_H
+#include &lt;alloca.h&gt;
+static size_t jj_alloca_limit = 0;
+#endif
+#include &lt;stdlib.h&gt;
+#include &lt;string.h&gt;
+#include &lt;wchar.h&gt;
+#ifdef HAVE_ALLOCA_H
+#endif
+#include &lt;jsapi.h&gt;
+#ifndef JS_THREADSAFE
+#if JS_VERSION &lt;= 170
+#define jsrefcount int
+#define JS_BeginRequest(cx)
+#define JS_EndRequest(cx)
+#define JS_SuspendRequest(cx)
+#define JS_ResumeRequest(cx, saveDepth)
+#endif
+#endif
+#ifndef JS_FS
+#define JS_FS(name, call, nargs, flags, extra) {name, call, nargs, flags, extra}
+#endif
+#ifndef JS_FS_END
+#define JS_FS_END {NULL, NULL, 0, 0, 0}
+#endif
+
+static JSBool
+jjadmTestFacInt(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
+{
+    JSObject * var2;
+    int var3;
+    int var6;
+    jsval var7;
+    JSBool var1;
+    var2 = NULL;
+    var3 = 0;
+    var6 = 0;
+    var7 = JSVAL_NULL;
+    var1 = JS_FALSE;
+    var2 = obj;
+    var6 = argc;
+    var3 = jsTestFacInt();
+    if (JS_NewNumberValue(cx, var3, &amp;var7) != JS_TRUE) {
+        goto do_return;
+    }
+    argv[argc+0] = var7;
+    if (rval) {
+        *rval = var7;
+    }
+    var1 = JS_TRUE;
+    do_return:
+    return var1;
+}
+static JSBool
+jjadmTestFacFloat(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
+{
+    JSObject * var9;
+    int var10;
+    int var13;
+    jsval var14;
+    JSBool var8;
+    var9 = NULL;
+    var10 = 0;
+    var13 = 0;
+    var14 = JSVAL_NULL;
+    var8 = JS_FALSE;
+    var9 = obj;
+    var13 = argc;
+    var10 = jsTestFacFloat();
+    if (JS_NewNumberValue(cx, var10, &amp;var14) != JS_TRUE) {
+        goto do_return;
+    }
+    argv[argc+0] = var14;
+    if (rval) {
+        *rval = var14;
+    }
+    var8 = JS_TRUE;
+    do_return:
+    return var8;
+}
+static JSBool
+jjadmTestFacToggle(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
+{
+    JSObject * var16;
+    int var17;
+    int var20;
+    jsval var21;
+    JSBool var15;
+    var16 = NULL;
+    var17 = 0;
+    var20 = 0;
+    var21 = JSVAL_NULL;
+    var15 = JS_FALSE;
+    var16 = obj;
+    var20 = argc;
+    var17 = jsTestFacToggle();
+    if (JS_NewNumberValue(cx, var17, &amp;var21) != JS_TRUE) {
+        goto do_return;
+    }
+    argv[argc+0] = var21;
+    if (rval) {
+        *rval = var21;
+    }
+    var15 = JS_TRUE;
+    do_return:
+    return var15;
+}
+static JSBool
+jjadmTestFacMenu(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
+{
+    JSObject * var23;
+    int var24;
+    int var27;
+    jsval var28;
+    JSBool var22;
+    var23 = NULL;
+    var24 = 0;
+    var27 = 0;
+    var28 = JSVAL_NULL;
+    var22 = JS_FALSE;
+    var23 = obj;
+    var27 = argc;
+    var24 = jsTestFacMenu();
+    if (JS_NewNumberValue(cx, var24, &amp;var28) != JS_TRUE) {
+        goto do_return;
+    }
+    argv[argc+0] = var28;
+    if (rval) {
+        *rval = var28;
+    }
+    var22 = JS_TRUE;
+    do_return:
+    return var22;
+}
+static JSBool
+jjadmTestFacFile(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
+{
+    JSObject * var30;
+    int var31;
+    int var34;
+    jsval var35;
+    JSBool var29;
+    var30 = NULL;
+    var31 = 0;
+    var34 = 0;
+    var35 = JSVAL_NULL;
+    var29 = JS_FALSE;
+    var30 = obj;
+    var34 = argc;
+    var31 = jsTestFacFile();
+    if (JS_NewNumberValue(cx, var31, &amp;var35) != JS_TRUE) {
+        goto do_return;
+    }
+    argv[argc+0] = var35;
+    if (rval) {
+        *rval = var35;
+    }
+    var29 = JS_TRUE;
+    do_return:
+    return var29;
+}
+static JSBool
+jjadmTestFacBitrate(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
+{
+    JSObject * var37;
+    int var38;
+    int var41;
+    jsval var42;
+    JSBool var36;
+    var37 = NULL;
+    var38 = 0;
+    var41 = 0;
+    var42 = JSVAL_NULL;
+    var36 = JS_FALSE;
+    var37 = obj;
+    var41 = argc;
+    var38 = jsTestFacBitrate();
+    if (JS_NewNumberValue(cx, var38, &amp;var42) != JS_TRUE) {
+        goto do_return;
+    }
+    argv[argc+0] = var42;
+    if (rval) {
+        *rval = var42;
+    }
+    var36 = JS_TRUE;
+    do_return:
+    return var36;
+}
+static JSBool
+jjadmTestFacBar(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
+{
+    JSObject * var44;
+    int var45;
+    int var48;
+    jsval var49;
+    JSBool var43;
+    var44 = NULL;
+    var45 = 0;
+    var48 = 0;
+    var49 = JSVAL_NULL;
+    var43 = JS_FALSE;
+    var44 = obj;
+    var48 = argc;
+    var45 = jsTestFacBar();
+    if (JS_NewNumberValue(cx, var45, &amp;var49) != JS_TRUE) {
+        goto do_return;
+    }
+    argv[argc+0] = var49;
+    if (rval) {
+        *rval = var49;
+    }
+    var43 = JS_TRUE;
+    do_return:
+    return var43;
+}
+static JSBool
+jjadmTestFacRoText(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
+{
+    JSObject * var51;
+    int var52;
+    int var55;
+    jsval var56;
+    JSBool var50;
+    var51 = NULL;
+    var52 = 0;
+    var55 = 0;
+    var56 = JSVAL_NULL;
+    var50 = JS_FALSE;
+    var51 = obj;
+    var55 = argc;
+    var52 = jsTestFacRoText();
+    if (JS_NewNumberValue(cx, var52, &amp;var56) != JS_TRUE) {
+        goto do_return;
+    }
+    argv[argc+0] = var56;
+    if (rval) {
+        *rval = var56;
+    }
+    var50 = JS_TRUE;
+    do_return:
+    return var50;
+}
+static JSBool
+jjadmTestFacText(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
+{
+    JSObject * var58;
+    int var59;
+    int var62;
+    jsval var63;
+    JSBool var57;
+    var58 = NULL;
+    var59 = 0;
+    var62 = 0;
+    var63 = JSVAL_NULL;
+    var57 = JS_FALSE;
+    var58 = obj;
+    var62 = argc;
+    var59 = jsTestFacText();
+    if (JS_NewNumberValue(cx, var59, &amp;var63) != JS_TRUE) {
+        goto do_return;
+    }
+    argv[argc+0] = var63;
+    if (rval) {
+        *rval = var63;
+    }
+    var57 = JS_TRUE;
+    do_return:
+    return var57;
+}
+static JSBool
+jjadmTestFacTab(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
+{
+    JSObject * var65;
+    int var66;
+    int var69;
+    jsval var70;
+    JSBool var64;
+    var65 = NULL;
+    var66 = 0;
+    var69 = 0;
+    var70 = JSVAL_NULL;
+    var64 = JS_FALSE;
+    var65 = obj;
+    var69 = argc;
+    var66 = jsTestFacTab();
+    if (JS_NewNumberValue(cx, var66, &amp;var70) != JS_TRUE) {
+        goto do_return;
+    }
+    argv[argc+0] = var70;
+    if (rval) {
+        *rval = var70;
+    }
+    var64 = JS_TRUE;
+    do_return:
+    return var64;
+}
+static JSBool
+jjadmTestFacFrame(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
+{
+    JSObject * var72;
+    int var73;
+    int var76;
+    jsval var77;
+    JSBool var71;
+    var72 = NULL;
+    var73 = 0;
+    var76 = 0;
+    var77 = JSVAL_NULL;
+    var71 = JS_FALSE;
+    var72 = obj;
+    var76 = argc;
+    var73 = jsTestFacFrame();
+    if (JS_NewNumberValue(cx, var73, &amp;var77) != JS_TRUE) {
+        goto do_return;
+    }
+    argv[argc+0] = var77;
+    if (rval) {
+        *rval = var77;
+    }
+    var71 = JS_TRUE;
+    do_return:
+    return var71;
+}
+static JSBool
+jjadmTestFacHex(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
+{
+    JSObject * var79;
+    int var80;
+    int var83;
+    jsval var84;
+    JSBool var78;
+    var79 = NULL;
+    var80 = 0;
+    var83 = 0;
+    var84 = JSVAL_NULL;
+    var78 = JS_FALSE;
+    var79 = obj;
+    var83 = argc;
+    var80 = jsTestFacHex();
+    if (JS_NewNumberValue(cx, var80, &amp;var84) != JS_TRUE) {
+        goto do_return;
+    }
+    argv[argc+0] = var84;
+    if (rval) {
+        *rval = var84;
+    }
+    var78 = JS_TRUE;
+    do_return:
+    return var78;
+}
+static JSBool
+jjadmTestFacDirSel(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
+{
+    JSObject * var86;
+    int var87;
+    int var90;
+    jsval var91;
+    JSBool var85;
+    var86 = NULL;
+    var87 = 0;
+    var90 = 0;
+    var91 = JSVAL_NULL;
+    var85 = JS_FALSE;
+    var86 = obj;
+    var90 = argc;
+    var87 = jsTestFacDirSel();
+    if (JS_NewNumberValue(cx, var87, &amp;var91) != JS_TRUE) {
+        goto do_return;
+    }
+    argv[argc+0] = var91;
+    if (rval) {
+        *rval = var91;
+    }
+    var85 = JS_TRUE;
+    do_return:
+    return var85;
+}
+static JSBool
+jjadmTestFacButton(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
+{
+    JSObject * var93;
+    int var94;
+    int var97;
+    jsval var98;
+    JSBool var92;
+    var93 = NULL;
+    var94 = 0;
+    var97 = 0;
+    var98 = JSVAL_NULL;
+    var92 = JS_FALSE;
+    var93 = obj;
+    var97 = argc;
+    var94 = jsTestFacButton();
+    if (JS_NewNumberValue(cx, var94, &amp;var98) != JS_TRUE) {
+        goto do_return;
+    }
+    argv[argc+0] = var98;
+    if (rval) {
+        *rval = var98;
+    }
+    var92 = JS_TRUE;
+    do_return:
+    return var92;
+}
+static JSBool
+jjadmTestFacMatrix(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
+{
+    JSObject * var100;
+    int var101;
+    int var104;
+    jsval var105;
+    JSBool var99;
+    var100 = NULL;
+    var101 = 0;
+    var104 = 0;
+    var105 = JSVAL_NULL;
+    var99 = JS_FALSE;
+    var100 = obj;
+    var104 = argc;
+    var101 = jsTestFacMatrix();
+    if (JS_NewNumberValue(cx, var101, &amp;var105) != JS_TRUE) {
+        goto do_return;
+    }
+    argv[argc+0] = var105;
+    if (rval) {
+        *rval = var105;
+    }
+    var99 = JS_TRUE;
+    do_return:
+    return var99;
+}
+static JSBool
+jjadmTestFacNotch(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
+{
+    JSObject * var107;
+    int var108;
+    int var111;
+    jsval var112;
+    JSBool var106;
+    var107 = NULL;
+    var108 = 0;
+    var111 = 0;
+    var112 = JSVAL_NULL;
+    var106 = JS_FALSE;
+    var107 = obj;
+    var111 = argc;
+    var108 = jsTestFacNotch();
+    if (JS_NewNumberValue(cx, var108, &amp;var112) != JS_TRUE) {
+        goto do_return;
+    }
+    argv[argc+0] = var112;
+    if (rval) {
+        *rval = var112;
+    }
+    var106 = JS_TRUE;
+    do_return:
+    return var106;
+}
+static JSBool
+jjadmTestFacThreadCount(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
+{
+    JSObject * var114;
+    int var115;
+    int var118;
+    jsval var119;
+    JSBool var113;
+    var114 = NULL;
+    var115 = 0;
+    var118 = 0;
+    var119 = JSVAL_NULL;
+    var113 = JS_FALSE;
+    var114 = obj;
+    var118 = argc;
+    var115 = jsTestFacThreadCount();
+    if (JS_NewNumberValue(cx, var115, &amp;var119) != JS_TRUE) {
+        goto do_return;
+    }
+    argv[argc+0] = var119;
+    if (rval) {
+        *rval = var119;
+    }
+    var113 = JS_TRUE;
+    do_return:
+    return var113;
+}
+static JSBool
+jjadmTestFacSlider(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
+{
+    JSObject * var121;
+    int var122;
+    int var125;
+    jsval var126;
+    JSBool var120;
+    var121 = NULL;
+    var122 = 0;
+    var125 = 0;
+    var126 = JSVAL_NULL;
+    var120 = JS_FALSE;
+    var121 = obj;
+    var125 = argc;
+    var122 = jsTestFacSlider();
+    if (JS_NewNumberValue(cx, var122, &amp;var126) != JS_TRUE) {
+        goto do_return;
+    }
+    argv[argc+0] = var126;
+    if (rval) {
+        *rval = var126;
+    }
+    var120 = JS_TRUE;
+    do_return:
+    return var120;
+}
+static JSBool
+jjadmTestEncoding(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
+{
+    JSObject * var128;
+    int var129;
+    int var132;
+    jsval var133;
+    JSBool var127;
+    var128 = NULL;
+    var129 = 0;
+    var132 = 0;
+    var133 = JSVAL_NULL;
+    var127 = JS_FALSE;
+    var128 = obj;
+    var132 = argc;
+    var129 = jsTestFacEncoding();
+    if (JS_NewNumberValue(cx, var129, &amp;var133) != JS_TRUE) {
+        goto do_return;
+    }
+    argv[argc+0] = var133;
+    if (rval) {
+        *rval = var133;
+    }
+    var127 = JS_TRUE;
+    do_return:
+    return var127;
+}
+static JSBool
+jjadmTestCrash(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
+{
+    JSObject * var135;
+    int var139;
+    JSBool var134;
+    var135 = NULL;
+    var139 = 0;
+    var134 = JS_FALSE;
+    var135 = obj;
+    var139 = argc;
+    jsTestCrash();
+    var134 = JS_TRUE;
+    return var134;
+}
+static JSBool
+jjadmTestAssert(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
+{
+    JSObject * var141;
+    int var145;
+    JSBool var140;
+    var141 = NULL;
+    var145 = 0;
+    var140 = JS_FALSE;
+    var141 = obj;
+    var145 = argc;
+    jsTestAssert();
+    var140 = JS_TRUE;
+    return var140;
+}
+static JSPropertySpec jj_static_ps[] = {
+    {NULL, 0, 0, NULL, NULL}
+};
+static JSPropertySpec jj_ps[] = {
+    {NULL, 0, 0, NULL, NULL}
+};
+static JSFunctionSpec jj_static_fs[] = {
+    JS_FS(&quot;admTestFacInt&quot;, jjadmTestFacInt, 0, 0, 1),
+    JS_FS(&quot;admTestFacFloat&quot;, jjadmTestFacFloat, 0, 0, 1),
+    JS_FS(&quot;admTestFacToggle&quot;, jjadmTestFacToggle, 0, 0, 1),
+    JS_FS(&quot;admTestFacMenu&quot;, jjadmTestFacMenu, 0, 0, 1),
+    JS_FS(&quot;admTestFacFile&quot;, jjadmTestFacFile, 0, 0, 1),
+    JS_FS(&quot;admTestFacBitrate&quot;, jjadmTestFacBitrate, 0, 0, 1),
+    JS_FS(&quot;admTestFacBar&quot;, jjadmTestFacBar, 0, 0, 1),
+    JS_FS(&quot;admTestFacRoText&quot;, jjadmTestFacRoText, 0, 0, 1),
+    JS_FS(&quot;admTestFacText&quot;, jjadmTestFacText, 0, 0, 1),
+    JS_FS(&quot;admTestFacTab&quot;, jjadmTestFacTab, 0, 0, 1),
+    JS_FS(&quot;admTestFacFrame&quot;, jjadmTestFacFrame, 0, 0, 1),
+    JS_FS(&quot;admTestFacHex&quot;, jjadmTestFacHex, 0, 0, 1),
+    JS_FS(&quot;admTestFacDirSel&quot;, jjadmTestFacDirSel, 0, 0, 1),
+    JS_FS(&quot;admTestFacButton&quot;, jjadmTestFacButton, 0, 0, 1),
+    JS_FS(&quot;admTestFacMatrix&quot;, jjadmTestFacMatrix, 0, 0, 1),
+    JS_FS(&quot;admTestFacNotch&quot;, jjadmTestFacNotch, 0, 0, 1),
+    JS_FS(&quot;admTestFacThreadCount&quot;, jjadmTestFacThreadCount, 0, 0, 1),
+    JS_FS(&quot;admTestFacSlider&quot;, jjadmTestFacSlider, 0, 0, 1),
+    JS_FS(&quot;admTestEncoding&quot;, jjadmTestEncoding, 0, 0, 1),
+    JS_FS(&quot;admTestCrash&quot;, jjadmTestCrash, 0, 0, 0),
+    JS_FS(&quot;admTestAssert&quot;, jjadmTestAssert, 0, 0, 0),
+    JS_FS_END
+};
+static JSFunctionSpec jj_fs[] = {
+    JS_FS(&quot;admTestFacInt&quot;, jjadmTestFacInt, 0, 0, 1),
+    JS_FS(&quot;admTestFacFloat&quot;, jjadmTestFacFloat, 0, 0, 1),
+    JS_FS(&quot;admTestFacToggle&quot;, jjadmTestFacToggle, 0, 0, 1),
+    JS_FS(&quot;admTestFacMenu&quot;, jjadmTestFacMenu, 0, 0, 1),
+    JS_FS(&quot;admTestFacFile&quot;, jjadmTestFacFile, 0, 0, 1),
+    JS_FS(&quot;admTestFacBitrate&quot;, jjadmTestFacBitrate, 0, 0, 1),
+    JS_FS(&quot;admTestFacBar&quot;, jjadmTestFacBar, 0, 0, 1),
+    JS_FS(&quot;admTestFacRoText&quot;, jjadmTestFacRoText, 0, 0, 1),
+    JS_FS(&quot;admTestFacText&quot;, jjadmTestFacText, 0, 0, 1),
+    JS_FS(&quot;admTestFacTab&quot;, jjadmTestFacTab, 0, 0, 1),
+    JS_FS(&quot;admTestFacFrame&quot;, jjadmTestFacFrame, 0, 0, 1),
+    JS_FS(&quot;admTestFacHex&quot;, jjadmTestFacHex, 0, 0, 1),
+    JS_FS(&quot;admTestFacDirSel&quot;, jjadmTestFacDirSel, 0, 0, 1),
+    JS_FS(&quot;admTestFacButton&quot;, jjadmTestFacButton, 0, 0, 1),
+    JS_FS(&quot;admTestFacMatrix&quot;, jjadmTestFacMatrix, 0, 0, 1),
+    JS_FS(&quot;admTestFacNotch&quot;, jjadmTestFacNotch, 0, 0, 1),
+    JS_FS(&quot;admTestFacThreadCount&quot;, jjadmTestFacThreadCount, 0, 0, 1),
+    JS_FS(&quot;admTestFacSlider&quot;, jjadmTestFacSlider, 0, 0, 1),
+    JS_FS(&quot;admTestEncoding&quot;, jjadmTestEncoding, 0, 0, 1),
+    JS_FS(&quot;admTestCrash&quot;, jjadmTestCrash, 0, 0, 0),
+    JS_FS(&quot;admTestAssert&quot;, jjadmTestAssert, 0, 0, 0),
+    JS_FS_END
+};
+
+JSFunctionSpec  *jsGetTestFunctions(void)
+{
+        return jj_fs;
+}
+
+

Copied: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/js/ADM_jsTestFactory_js.idl (from rev 6206, branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsTestFactory_js.idl)
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsTestFactory_js.idl	2010-05-20 15:22:49 UTC (rev 6206)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/js/ADM_jsTestFactory_js.idl	2010-05-20 15:22:52 UTC (rev 6207)
@@ -0,0 +1,40 @@
+%{
+#include &quot;stdio.h&quot;
+#include &quot;ADM_jsAvidemux.h&quot;
+#include &quot;ADM_jsTestFactory.h&quot;
+%}
+/*
+###############################################################
+       return JS function     C Function  params
+###############################################################
+*/
+function int admTestFacInt     :  jsTestFacInt     (void  ) &lt;static&gt;;
+function int admTestFacFloat   :  jsTestFacFloat   (void  ) &lt;static&gt;;
+function int admTestFacToggle  :  jsTestFacToggle  (void  ) &lt;static&gt;;
+function int admTestFacMenu    :  jsTestFacMenu    (void  ) &lt;static&gt;;
+function int admTestFacFile    :  jsTestFacFile    (void  ) &lt;static&gt;;
+function int admTestFacBitrate :  jsTestFacBitrate (void  ) &lt;static&gt;;
+function int admTestFacBar     :  jsTestFacBar     (void  ) &lt;static&gt;;
+function int admTestFacRoText  :  jsTestFacRoText  (void  ) &lt;static&gt;;
+function int admTestFacText    :  jsTestFacText    (void  ) &lt;static&gt;;
+function int admTestFacTab     :  jsTestFacTab     (void  ) &lt;static&gt;;
+function int admTestFacFrame   :  jsTestFacFrame   (void  ) &lt;static&gt;;
+function int admTestFacHex     :  jsTestFacHex     (void  ) &lt;static&gt;;
+function int admTestFacDirSel  :  jsTestFacDirSel  (void  ) &lt;static&gt;;
+function int admTestFacButton  :  jsTestFacButton  (void  ) &lt;static&gt;;
+function int admTestFacMatrix  :  jsTestFacMatrix  (void  ) &lt;static&gt;;
+function int admTestFacNotch   :  jsTestFacNotch   (void  ) &lt;static&gt;;
+function int admTestFacThreadCount:  jsTestFacThreadCount   (void  ) &lt;static&gt;;
+function int admTestFacSlider  :  jsTestFacSlider  (void  ) &lt;static&gt;;
+function int admTestEncoding   :  jsTestFacEncoding  (void  ) &lt;static&gt;;
+function void admTestCrash     :  jsTestCrash      (void  ) &lt;static&gt;;
+function void admTestAssert    :  jsTestAssert     (void  ) &lt;static&gt;;
+
+%&lt;
+JSFunctionSpec  *jsGetTestFunctions(void)
+{
+        return jj_fs;
+}
+
+%&gt;
+

Copied: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/js/ADM_jsUtils.cpp (from rev 6206, branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsUtils.cpp)
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsUtils.cpp	2010-05-20 15:22:49 UTC (rev 6206)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/js/ADM_jsUtils.cpp	2010-05-20 15:22:52 UTC (rev 6207)
@@ -0,0 +1,167 @@
+/**
+    \file ADM_jsUtils
+    \brief Simple param -&gt; type utilities
+    \author mean <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A> 2009
+*/
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include &quot;ADM_js.h&quot;
+/**
+    \fn ADM_jsArg2Vars  
+    \brief convert jsvals to native type with checking
+*/
+bool ADM_jsArg2Vars(const char *caller, int argc, jsval *argv, int paramNumber, ADM_PARAM_LIST *param)
+{
+    if(paramNumber!=argc)
+    {
+        ADM_warning(&quot;[%s]Wrong number of parameters : %d vs %d\n&quot;,caller,argc,paramNumber);
+        return false;
+    }
+    for(int i=0;i&lt;argc;i++)
+    {
+        jsval j=argv[i];
+        ADM_PARAM_LIST *p=param+i;
+        switch(p-&gt;type)
+        {
+            case ADM_JS_UINT64_T:
+            case ADM_JS_UINT32_T:
+            case ADM_JS_INT64_T:
+            case ADM_JS_INT32_T:
+                {
+                        if(!JSVAL_IS_NUMBER(j))
+                        {
+                            ADM_warning(&quot;[%s]Expected number and got %d\n&quot;,caller,j);
+                            return false;
+                        }
+                        // If it is an int...
+                        double v=0;
+                        if(JSVAL_IS_INT(j)) 
+                        {
+                            v=(int64_t)JSVAL_TO_INT(j);
+                            //ADM_warning(&quot;Value is int :%&quot;LLD&quot;\n&quot;,JSVAL_TO_INT(j));
+                        }
+                        if(JSVAL_IS_DOUBLE(j)) 
+                        {
+                            v=(int64_t)*(JSVAL_TO_DOUBLE(j));
+                            //ADM_warning(&quot;Value is float :%f\n&quot;,(float)*(JSVAL_TO_DOUBLE(j)));
+                        }
+                        // 
+                        //ADM_warning(&quot;%f\n&quot;,(float)v);
+                        // Affect
+                        switch(p-&gt;type)
+                        {
+                            case ADM_JS_UINT64_T: *(uint64_t *)p-&gt;value=(uint64_t)v;break;
+                            case ADM_JS_UINT32_T: *(uint32_t *)p-&gt;value=(uint32_t)v;break;
+                            case ADM_JS_INT64_T:  *(int64_t *)p-&gt;value=(int64_t)v;break;
+                            case ADM_JS_INT32_T:  *(int32_t *)p-&gt;value=(int32_t)v;break;
+                            default: ADM_assert(0);break;
+                        }
+                 }
+                        break;
+            case  ADM_JS_STRING:
+                {
+                        if(!JSVAL_IS_STRING(j))
+                        {
+                            ADM_warning(&quot;[%s]Expected string and got %d\n&quot;,caller,j);
+                            return false;
+                        }
+                        char *out=JS_GetStringBytes(JSVAL_TO_STRING(j));
+                        char **m=(char **)(p-&gt;value);
+                        *m=out;
+                }
+                        break;
+            case  ADM_JS_BOOL:
+                        if(!JSVAL_IS_BOOLEAN(j))
+                        {
+                            ADM_warning(&quot;[%s]Expected boolean and got %d\n&quot;,caller,j);
+                            return false;
+                        }
+                        *(bool *)p-&gt;value=JSVAL_TO_BOOLEAN(j);
+                        break;
+            default:
+                    ADM_assert(0);
+                    break;
+        }
+
+    }
+    return true;
+}
+/**
+    \fn stringsToConfCouple
+    \brief Convert js args to confcouple
+
+*/
+bool stringsToConfCouple(int nb,CONFcouple **conf,  const char **argv)
+{
+  *conf=NULL;
+  if(!nb) return true;
+  CONFcouple *c=new CONFcouple(nb);
+  *conf=c;
+    for(int i=0;i&lt;nb;i++)
+    {
+        
+        char *dupe=   ADM_strdup(argv[i]);
+        char *name,*value;
+        // dupe is in the form name=value
+        name=dupe;
+        value=name;
+        char *tail=dupe+strlen(dupe);
+        while(value&lt;tail)
+        {
+            if(*value=='=') 
+                {
+                    *value=0;
+                    value++;
+                    break;
+                }
+            value++;
+        }
+        c-&gt;setInternalName(name,value);
+        //printf(&quot;%s -&gt; [%s,%s]\n&quot;,param,name,value);
+        ADM_dezalloc(dupe);
+    }
+    return true;
+}
+/**
+    \fn jsArgToConfCouple
+    \brief Convert js args to confcouple
+
+*/
+bool jsArgToConfCouple(int nb,CONFcouple **conf,  jsval *argv)
+{
+  *conf=NULL;
+  if(!nb) return true;
+  CONFcouple *c=new CONFcouple(nb);
+  *conf=c;
+    for(int i=0;i&lt;nb;i++)
+    {
+        char *param = JS_GetStringBytes(JSVAL_TO_STRING(argv[i]));
+        char *dupe=   ADM_strdup(param);
+        char *name,*value;
+        // dupe is in the form name=value
+        name=dupe;
+        value=name;
+        char *tail=dupe+strlen(dupe);
+        while(value&lt;tail)
+        {
+            if(*value=='=') 
+                {
+                    *value=0;
+                    value++;
+                    break;
+                }
+            value++;
+        }
+        c-&gt;setInternalName(name,value);
+        //printf(&quot;%s -&gt; [%s,%s]\n&quot;,param,name,value);
+        ADM_dezalloc(dupe);
+    }
+    return true;
+}
+// EOF

Copied: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/js/ADM_jsVideo.cpp (from rev 6206, branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsVideo.cpp)
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsVideo.cpp	2010-05-20 15:22:49 UTC (rev 6206)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/js/ADM_jsVideo.cpp	2010-05-20 15:22:52 UTC (rev 6207)
@@ -0,0 +1,149 @@
+/**
+    \file ADM_jsVideo.cpp
+    \brief Video oriented functions
+    \author mean (c) 2009 <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
+
+
+    jsapigen does not like much variable number of arguments
+    In that case, we patch the generated file to go back to native spidermonkey api
+
+
+*/
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include &quot;ADM_js.h&quot;
+#include &quot;ADM_editor/ADM_edit.hxx&quot;
+#include &quot;ADM_jsAvidemux.h&quot;
+#include &quot;ADM_jsVideo.h&quot;
+#include &quot;A_functions.h&quot;
+#include &quot;ADM_videoEncoderApi.h&quot;
+#include &quot;ADM_videoFilterApi.h&quot;
+#include &quot;ADM_videoFilters.h&quot;
+#include &quot;GUI_ui.h&quot;
+extern ADM_Composer *video_body;
+bool A_setVideoCodec(const char *nm);
+/**
+    \fn jsSetPostProc
+*/
+int jsSetPostProc (int a,int b, int c)
+{
+    return video_body-&gt;setPostProc(a,b,c);
+}
+
+
+/**
+    \fn Codec
+    
+*/
+extern &quot;C&quot; int   jsVideoCodec(const char *a,const char **b) {return 0;}
+JSBool jsAdmvideoCodec(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
+{// begin Codec
+        *rval = BOOLEAN_TO_JSVAL(false);
+        if(argc &lt;1)
+                return JS_FALSE;
+        if(JSVAL_IS_STRING(argv[0]) == false )
+        {
+                jsLog(JS_LOG_ERROR,&quot;Cannot set codec, first parameter is not a string\n&quot;);
+                return JS_FALSE;
+        }
+        char *codec=JS_GetStringBytes(JSVAL_TO_STRING(argv[0]));
+        // Set codec.
+        
+        if(A_setVideoCodec(codec)==false)
+        {
+            jsLog(JS_LOG_ERROR,&quot;Could not select codec %s\n&quot;,codec);
+            return JS_FALSE;
+        }
+        CONFcouple *c;
+        jsArgToConfCouple(argc-1,&amp;c,argv+1);
+        *rval = BOOLEAN_TO_JSVAL( videoEncoder6_SetConfiguration(c));
+        jsLog(JS_LOG_NORMAL,&quot;Selected codec %s\n&quot;,codec);
+        if(c) delete c;
+        return JS_TRUE;
+}// end Codec
+
+/**
+    \fn Codec
+    
+*/
+extern &quot;C&quot; int   jsVideoFilter(const char *a,const char **b) {return 0;}
+JSBool jsAdmaddVideoFilter(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
+{// begin Codec
+   uint32_t filterTag;
+
+        // default return value
+        *rval = BOOLEAN_TO_JSVAL(false);
+        if(argc == 0)
+                return JS_FALSE;
+        char *filterName=JS_GetStringBytes(JSVAL_TO_STRING(argv[0]));
+        filterTag = ADM_vf_getTagFromInternalName(filterName);
+        jsLog(JS_LOG_NORMAL,&quot;Adding Filter %s -&gt; %&quot;LU&quot;... \n&quot;,filterName,filterTag);
+
+        
+        CONFcouple *c=NULL;
+        if(argc)
+            jsArgToConfCouple(argc-1,&amp;c,argv+1);
+        *rval=BOOLEAN_TO_JSVAL(  ADM_vf_addFilterFromTag(filterTag,c,false));
+        if(c) delete c;
+        
+        return JS_TRUE;
+}// end Codec
+/**
+    \fn A_setVideoCodec
+*/
+bool A_setVideoCodec(const char *nm)
+{
+    int idx=videoEncoder6_GetIndexFromName(nm);
+    if(idx==-1)
+    {
+        ADM_error(&quot;No such encoder :%s\n&quot;,nm);
+    }
+    // Select by index
+    videoEncoder6_SetCurrentEncoder(idx);
+    UI_setVideoCodec(idx);
+    return true;
+}
+/**
+     \fn jsClearFilters
+*/
+int jsClearVideoFilters()
+{
+    return ADM_vf_clearFilters();
+}
+/**
+    \fn jsGetMarkerA
+*/
+double jsGetMarkerA(void)
+{
+    return (double)video_body-&gt;getMarkerAPts();
+
+}
+/**
+    \fn jsGetMarkerB
+*/
+double jsGetMarkerB(void)
+{
+    return (double)video_body-&gt;getMarkerBPts();
+}
+/**
+    \fn jsSetMarkerA
+*/
+void   jsSetMarkerA(double a)
+{
+    video_body-&gt;setMarkerAPts( (uint64_t)a);
+}
+/**
+    \fn jsGetMarkerB
+*/
+void   jsSetMarkerB(double b)
+{
+    video_body-&gt;setMarkerBPts( (uint64_t)b);
+}
+
+//EOF
\ No newline at end of file

Copied: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/js/CMakeLists.txt (from rev 6206, branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/CMakeLists.txt)
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/CMakeLists.txt	2010-05-20 15:22:49 UTC (rev 6206)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/js/CMakeLists.txt	2010-05-20 15:22:52 UTC (rev 6207)
@@ -0,0 +1,27 @@
+SET(ADM_script_SRCS
+        ADM_jsIf.cpp
+        ADM_jsDebug.cpp
+        ADM_jsUtils.cpp
+# Wrapper code
+        ADM_jsIf_js.c
+# Factory test
+        ADM_jsTestFactory.cpp  
+        ADM_jsTestFactory_js.c
+# Load segment
+        ADM_jsAvidemux.cpp
+        ADM_jsAvidemuxInfo.cpp
+        ADM_jsAvidemux_js.c
+# Debug / editor class
+        ADM_jsEditor.cpp
+        ADM_jsEditor_js.c
+
+# 
+        ADM_jsVideo.cpp
+#
+        ADM_jsAudio.cpp
+)
+
+ADD_LIBRARY(ADM_script26 STATIC ${ADM_script_SRCS})
+ADD_DEFINITIONS(&quot;-DJS_THREADSAFE -DXP_UNIX&quot;)
+include_directories(${AVIDEMUX_TOP_SOURCE_DIR}/avidemux/common/ADM_script2/include)
+include_directories(${AVIDEMUX_TOP_SOURCE_DIR}/avidemux_core/ADM_smjs)

Copied: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/js/idl.make (from rev 6206, branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/idl.make)
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/idl.make	2010-05-20 15:22:49 UTC (rev 6206)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/js/idl.make	2010-05-20 15:22:52 UTC (rev 6207)
@@ -0,0 +1,7 @@
+idls:=$(shell ls *.idl)
+cs:=$(subst .idl,.c,$(idls))
+%.c : %.idl
+	echo processing $@
+	jsapigen &lt; $&lt; &gt; /tmp/xx
+	cat /tmp/xx   | sed 's/&quot;\(.*\)_ignore&quot;/&quot;\1&quot;/g'  | sed 's/, jjadm\(.*\)_ignore,/, jsAdm\1, /g' &gt; $@
+all: $(cs)

Copied: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/js/updateIdl.sh (from rev 6206, branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/updateIdl.sh)
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/updateIdl.sh	2010-05-20 15:22:49 UTC (rev 6206)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/js/updateIdl.sh	2010-05-20 15:22:52 UTC (rev 6207)
@@ -0,0 +1 @@
+jsapigen &lt; ADM_jsIf_js.idl  &gt; ADM_jsIf_js.c

Copied: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/py/ADM_pyAdm.cpp (from rev 6206, branches/avidemux_2.6_branch_mean/avidemux/common/ADM_pyScript/src/ADM_pyAdm.cpp)
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_pyScript/src/ADM_pyAdm.cpp	2010-05-20 15:22:49 UTC (rev 6206)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/py/ADM_pyAdm.cpp	2010-05-20 15:22:52 UTC (rev 6207)
@@ -0,0 +1,130 @@
+/**
+    \file ADM_pyADM.cpp
+    \author mean <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A> 2010
+
+*/
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include &quot;ADM_default.h&quot;
+#include &lt;stdarg.h&gt;
+#include &lt;vector&gt;
+#include &quot;ADM_editor/ADM_edit.hxx&quot;
+#include &quot;ADM_coreTinyPy/include/tinypy.h&quot;
+#include &quot;ADM_coreTinyPy/include/ADM_tinypy.h&quot;
+#include &quot;ADM_script2/include/ADM_jsShell.h&quot;
+#include &quot;A_functions.h&quot;
+
+#include &quot;adm_gen.h&quot;
+
+#include &quot;adm_gen.cpp&quot;
+/**
+    \fn    parseTinyPyScript
+    \brief Execute a tinyPy script
+*/
+bool parseTinyPyScript(const char *name)
+{
+        tinyPy py;
+        py.init();
+        py.registerFuncs(&quot;adm&quot;,adm_functions);
+        return py.execFile(name);
+}
+
+/**
+    \fn jsEvaluate
+*/
+static tinyPy *myPy=NULL;
+static bool pyEvaluate(const char *str)
+{
+    ADM_assert(myPy);
+    return myPy-&gt;execString(str);
+}
+/**
+    \fn    interactiveTinyPy
+    \brief interprete &amp; execute python script (interactive)
+*/
+bool interactiveTinyPy(void)
+{
+    myPy=new tinyPy;
+    myPy-&gt;init();
+    myPy-&gt;registerFuncs(&quot;adm&quot;,adm_functions);
+
+    ADM_startShell(pyEvaluate);
+    delete myPy;
+    myPy=NULL;
+	A_Resync();
+    ADM_info(&quot;Ending py shell...\n&quot;);
+	return true;
+}
+
+int  py_loadVideo (char *vid )
+{
+    printf(&quot;pyLoadVideo %s\n&quot;,vid);
+    return 0;
+}
+int  py_clearSegments (void)
+{
+    printf(&quot;py_clearSegments\n&quot;);
+    return 0;
+}
+
+int  py_appendVideo (char *vid )
+{
+    printf(&quot;py_appendVideo %s\n&quot;,vid);
+    return 0;
+}
+
+int  py_addSegment (int ,float , float )
+{
+    printf(&quot;py_addSegment\n&quot;);
+    return 0;
+}
+
+int  py_setPostProc (int a,int b, int c)
+{
+    printf(&quot;py_setPostProc\n&quot;);
+    return 0;
+}
+
+int  py_getWidth (void)
+{
+    printf(&quot;py_getWidth\n&quot;);
+    return 0;
+}
+
+int  py_getHeight (void)
+{
+    printf(&quot;py_getHeight\n&quot;);
+    return 0;
+}
+
+int  py_getFps1000 (void)
+{
+    printf(&quot;py_getFps1000\n&quot;);
+    return 0;
+}
+
+int  py_audioReset (void)
+{
+    printf(&quot;py_audioReset\n&quot;);
+    return 0;
+}
+
+int  py_audioMixer (char *mixer )
+{
+    printf(&quot;py_audioMixer\n&quot;);
+    return 0;
+}
+
+int  py_clearVideoFilters (void)
+{
+    printf(&quot;py_clearVideoFilters\n&quot;);
+    return 0;
+}
+

Copied: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/py/CMakeLists.txt (from rev 6206, branches/avidemux_2.6_branch_mean/avidemux/common/ADM_pyScript/src/CMakeLists.txt)
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_pyScript/src/CMakeLists.txt	2010-05-20 15:22:49 UTC (rev 6206)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/py/CMakeLists.txt	2010-05-20 15:22:52 UTC (rev 6207)
@@ -0,0 +1,7 @@
+SET(ADM_script_SRCS
+        ADM_pyAdm.cpp
+)
+
+ADD_LIBRARY(ADM_pyScript6 STATIC ${ADM_script_SRCS})
+include_directories(../include)
+include_directories(${AVIDEMUX_TOP_SOURCE_DIR}/avidemux_core/ADM_coreTinyPy/include)

Copied: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/py/adm.admPy (from rev 6206, branches/avidemux_2.6_branch_mean/avidemux/common/ADM_pyScript/src/adm.admPy)
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_pyScript/src/adm.admPy	2010-05-20 15:22:49 UTC (rev 6206)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/py/adm.admPy	2010-05-20 15:22:52 UTC (rev 6207)
@@ -0,0 +1,13 @@
+/* FUNC */ int loadVideo      (char * ) 
+/* FUNC */ int clearSegments  (void) 
+/* FUNC */ int appendVideo    (char * ) 
+/* FUNC */ int addSegment     (int ,float , float ) 
+/* FUNC */ int setPostProc    (int ,int , int ) 
+/* FUNC */ int getWidth       (void) 
+/* FUNC */ int getHeight      (void) 
+/* FUNC */ int getFps1000     (void) 
+#/* FUNC */ char* getVideoCodec(void) 
+/* FUNC */ int audioReset     (void) 
+/* FUNC */ int audioMixer     (char * ) 
+/* FUNC */ int clearVideoFilters   (void) 
+

Copied: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/py/adm_gen.cpp (from rev 6206, branches/avidemux_2.6_branch_mean/avidemux/common/ADM_pyScript/src/adm_gen.cpp)
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_pyScript/src/adm_gen.cpp	2010-05-20 15:22:49 UTC (rev 6206)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/py/adm_gen.cpp	2010-05-20 15:22:52 UTC (rev 6207)
@@ -0,0 +1,89 @@
+//int  loadVideo &lt;char * &gt;
+tp_obj zzpy_loadVideo(TP)
+{
+char * p0=(char *)TP_STR().string.val;
+int r=py_loadVideo(p0); 
+return tp_number(r);
+}
+//int  clearSegments &lt;void&gt;
+tp_obj zzpy_clearSegments(TP)
+{
+int r=py_clearSegments(); 
+return tp_number(r);
+}
+//int  appendVideo &lt;char * &gt;
+tp_obj zzpy_appendVideo(TP)
+{
+char * p0=(char *)TP_STR().string.val;
+int r=py_appendVideo(p0); 
+return tp_number(r);
+}
+//int  addSegment &lt;int  float   float &gt;
+tp_obj zzpy_addSegment(TP)
+{
+int p0=TP_NUM();
+float p1=TP_NUM();
+float p2=TP_NUM();
+int r=py_addSegment(p0,p1,p2); 
+return tp_number(r);
+}
+//int  setPostProc &lt;int  int   int &gt;
+tp_obj zzpy_setPostProc(TP)
+{
+int p0=TP_NUM();
+int p1=TP_NUM();
+int p2=TP_NUM();
+int r=py_setPostProc(p0,p1,p2); 
+return tp_number(r);
+}
+//int  getWidth &lt;void&gt;
+tp_obj zzpy_getWidth(TP)
+{
+int r=py_getWidth(); 
+return tp_number(r);
+}
+//int  getHeight &lt;void&gt;
+tp_obj zzpy_getHeight(TP)
+{
+int r=py_getHeight(); 
+return tp_number(r);
+}
+//int  getFps1000 &lt;void&gt;
+tp_obj zzpy_getFps1000(TP)
+{
+int r=py_getFps1000(); 
+return tp_number(r);
+}
+//int  audioReset &lt;void&gt;
+tp_obj zzpy_audioReset(TP)
+{
+int r=py_audioReset(); 
+return tp_number(r);
+}
+//int  audioMixer &lt;char * &gt;
+tp_obj zzpy_audioMixer(TP)
+{
+char * p0=(char *)TP_STR().string.val;
+int r=py_audioMixer(p0); 
+return tp_number(r);
+}
+//int  clearVideoFilters &lt;void&gt;
+tp_obj zzpy_clearVideoFilters(TP)
+{
+int r=py_clearVideoFilters(); 
+return tp_number(r);
+}
+pyFuncs adm_functions[]={
+{&quot;loadVideo&quot;,zzpy_loadVideo},
+{&quot;clearSegments&quot;,zzpy_clearSegments},
+{&quot;appendVideo&quot;,zzpy_appendVideo},
+{&quot;addSegment&quot;,zzpy_addSegment},
+{&quot;setPostProc&quot;,zzpy_setPostProc},
+{&quot;getWidth&quot;,zzpy_getWidth},
+{&quot;getHeight&quot;,zzpy_getHeight},
+{&quot;getFps1000&quot;,zzpy_getFps1000},
+{&quot;audioReset&quot;,zzpy_audioReset},
+{&quot;audioMixer&quot;,zzpy_audioMixer},
+{&quot;clearVideoFilters&quot;,zzpy_clearVideoFilters},
+{NULL,NULL}
+};

Copied: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/py/adm_gen.h (from rev 6206, branches/avidemux_2.6_branch_mean/avidemux/common/ADM_pyScript/src/adm_gen.h)
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_pyScript/src/adm_gen.h	2010-05-20 15:22:49 UTC (rev 6206)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/py/adm_gen.h	2010-05-20 15:22:52 UTC (rev 6207)
@@ -0,0 +1,11 @@
+int  py_loadVideo (char * );
+int  py_clearSegments (void);
+int  py_appendVideo (char * );
+int  py_addSegment (int ,float , float );
+int  py_setPostProc (int ,int , int );
+int  py_getWidth (void);
+int  py_getHeight (void);
+int  py_getFps1000 (void);
+int  py_audioReset (void);
+int  py_audioMixer (char * );
+int  py_clearVideoFilters (void);

Copied: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/py/include/ADM_pyIf.h (from rev 6206, branches/avidemux_2.6_branch_mean/avidemux/common/ADM_pyScript/include/ADM_pyIf.h)
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_pyScript/include/ADM_pyIf.h	2010-05-20 15:22:49 UTC (rev 6206)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/py/include/ADM_pyIf.h	2010-05-20 15:22:52 UTC (rev 6207)
@@ -0,0 +1,21 @@
+/**
+    \file ADM_pyIf.h
+    \brief Interface for python script 
+    \author mean <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A> 2010
+
+*/
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#ifndef ADM_PY_IF_H
+#define ADM_PY_IF_H
+
+bool parseTinyPyScript(const char *name);
+bool interactiveTinyPy(void);
+
+#endif
\ No newline at end of file

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsAudio.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsAudio.cpp	2010-05-20 15:22:49 UTC (rev 6206)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsAudio.cpp	2010-05-20 15:22:52 UTC (rev 6207)
@@ -1,100 +0,0 @@
-/**
-    \file ADM_jsAudio.cpp
-    \brief Audio oriented functions
-    \author mean (c) 2009 <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
-
-
-    jsapigen does not like much variable number of arguments
-    In that case, we patch the generated file to go back to native spidermonkey api
-
-
-*/
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#include &quot;ADM_js.h&quot;
-#include &quot;ADM_editor/ADM_edit.hxx&quot;
-#include &quot;ADM_jsAvidemux.h&quot;
-#include &quot;A_functions.h&quot;
-#include &quot;GUI_ui.h&quot;
-#include &quot;ADM_audioFilterInterface.h&quot;
-#include &quot;audioEncoderApi.h&quot;
-extern ADM_Composer *video_body;
-/**
-    \fn int jsAudioReset(void);
-*/
-int jsAudioReset (void)
-{
-    audioFilterReset();
-    return 1;
-}
-/**
-    \fn 
-*/  
-extern &quot;C&quot; int   jsAudioCodec(const char *a,const char **b) {return 0;}
-JSBool jsAdmaudioCodec(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
-{
-        // default return value
-        *rval = BOOLEAN_TO_JSVAL(false);
-        if(argc &lt; 2)
-                return JS_FALSE;
-        if(JSVAL_IS_STRING(argv[0]) == false || JSVAL_IS_INT(argv[1]) == false )            return JS_FALSE;
-        for(int i=2;i&lt;argc;i++)  if(JSVAL_IS_STRING(argv[i]) == false) return JS_FALSE;
-
-        // Get Codec...
-        char *name = JS_GetStringBytes(JSVAL_TO_STRING(argv[0]));
-        ADM_LowerCase(name);
-        
-        // First search the codec by its name
-        if(!audioCodecSetByName(name))
-        {
-                *rval = BOOLEAN_TO_JSVAL(false);
-                jsLog(JS_LOG_ERROR,&quot;Cannot set audio codec %s\n&quot;,name);
-        }
-        else
-        {
-            // begin set bitrate
-            uint32_t bitrate=JSVAL_TO_INT(argv[1]);
-            // Construct couples
-            CONFcouple *c=NULL;
-            if(argc&gt;2)
-            {
-                int nb=argc-2;
-                jsArgToConfCouple( nb,&amp;c,  argv+2);
-            }
-            *rval = BOOLEAN_TO_JSVAL(setAudioExtraConf(bitrate,c));
-            if(c) delete c;
-        }
-
-        // end set bitrate
-        
-        return JS_TRUE;
-}
-/**
-    \fn jsAudioMixer
-*/
-int jsAudioMixer(const char *s)
-{
-    CHANNEL_CONF c=AudioMuxerStringToId(s);
-    return audioFilterSetMixer(c);
-}
-/**
-    \fn jsGetResample
-*/
-int32_t jsGetResample(void)
-{
-    return 0;
-}
-/**
-    \fn jsSetResample
-*/
-void    jsSetResample(int32_t fq)
-{
-
-}
-//EOF
\ No newline at end of file

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsAvidemux.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsAvidemux.cpp	2010-05-20 15:22:49 UTC (rev 6206)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsAvidemux.cpp	2010-05-20 15:22:52 UTC (rev 6207)
@@ -1,135 +0,0 @@
-/**
-    \file ADM_jsLoad.cpp
-    \brief Load oriented functions
-    \author mean (c) 2009 <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
-
-
-*/
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#include &quot;ADM_js.h&quot;
-#include &quot;ADM_editor/ADM_edit.hxx&quot;
-#include &quot;ADM_jsAvidemux.h&quot;
-#include &quot;A_functions.h&quot;
-#include &quot;ADM_muxerProto.h&quot;
-#include &quot;GUI_ui.h&quot;
-extern ADM_Composer *video_body;
-/**
-    \fn ADM_JSAvidemux
-    \brief Select the current container from a string
-*/
-bool A_setContainer(const char *cont)
-{
-    int idx=ADM_MuxerIndexFromName(cont);
-    if(idx==-1)
-    {
-        ADM_error(&quot;Cannot find muxer for format=%s\n&quot;,cont);
-        return false;
-    }
-    ADM_info(&quot;setting container as index %d\n&quot;,idx);
-    UI_SetCurrentFormat(idx);
-    return true;
-}
-
-/**
-    \fn jsLoadFile
-*/
-int jsLoadVideo(const char *s)
-{
-int ret=0;
-        jsLog(JS_LOG_NORMAL,&quot;[Js] Loading video %s&quot;,s);
-        if(A_openAvi(s)) 
-        {
-          ret=1;
-        }
-        
-    return ret;
-}
-
-/**
-    \fn jsAppendFile
-*/
-int jsAppendVideo(const char *s)
-{
-int ret=0;
-        
-        if(A_appendAvi(s)) 
-        {
-          ret=1;
-        }
-        
-    return ret;
-}
-
-/**
-    \fn jsClearSegments
-*/
-int jsClearSegments(void)
-{
-    video_body-&gt;clearSegment();
-    return 1;
-}
-/**
-    \fn jsAddSegment
-
-*/
-int  jsAddSegment(int ref, double start, double duration)
-{
-    if(true==video_body-&gt;addSegment(ref,(uint64_t)start,(uint64_t)duration)) 
-    {
-        if(1==video_body-&gt;getNbSegment()) // We just added our first seg...
-        {
-                ADM_info(&quot;First segment, refreshing screen\n&quot;);
-                A_Rewind();
-        }
-        return 1;
-    }
-    return 0;
-}
-
-
-/**
-    \fn Codec
-    
-*/
-extern &quot;C&quot; int   jsSetContainer(const char *a,const char **b) {return 0;}
-JSBool jsAdmsetContainer(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
-{// begin Codec
-        
-        // default return value
-        *rval = BOOLEAN_TO_JSVAL(false);
-        if(argc &lt; 1)
-        {
-            jsLog(JS_LOG_NORMAL,&quot;setContainer needs at least one arg\n&quot;);
-            return JS_FALSE;
-        }
-        
-        if(JSVAL_IS_STRING(argv[0]) == false)
-        {
-                jsLog(JS_LOG_NORMAL,&quot;setContainer needs at string arg\n&quot;);
-                return JS_FALSE;
-        }
-        char *str = JS_GetStringBytes(JSVAL_TO_STRING(argv[0]));
-         jsLog(JS_LOG_NORMAL,&quot;[JS] Selecting container :%s\n&quot;,str);
-        if(A_setContainer(str))
-        {
-            CONFcouple *c;
-            jsArgToConfCouple(argc-1,&amp;c,argv+1);
-            int idx=ADM_MuxerIndexFromName(str);
-            if(idx!=-1)
-            {
-                *rval = BOOLEAN_TO_JSVAL( ADM_mx_setExtraConf(idx,c));
-            }
-            if(c) delete c;
-        }
-        return JS_TRUE;
-}// end Codec
-
-
-// EOF
\ No newline at end of file

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsAvidemuxInfo.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsAvidemuxInfo.cpp	2010-05-20 15:22:49 UTC (rev 6206)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsAvidemuxInfo.cpp	2010-05-20 15:22:52 UTC (rev 6207)
@@ -1,59 +0,0 @@
-/**
-    \file ADM_jsLoad.cpp
-    \brief Load oriented functions
-    \author mean (c) 2009 <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
-
-
-*/
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#include &quot;ADM_js.h&quot;
-#include &quot;ADM_editor/ADM_edit.hxx&quot;
-#include &quot;ADM_jsAvidemux.h&quot;
-#include &quot;fourcc.h&quot;
-extern ADM_Composer *video_body;
-/**
-    \fn jsGetWidth
-*/
-int jsGetWidth ( void)
-{
-aviInfo info;
-        video_body-&gt;getVideoInfo(&amp;info);
-        return info.width;
-}
-/**
-    \fn jsGetHeight
-*/
-int jsGetHeight ( void)
-{
-aviInfo info;
-        video_body-&gt;getVideoInfo(&amp;info);
-        return info.height;
-}
-/**
-    \fn jsGetFps1000
-*/
-int jsGetFps1000 ( void)
-{
-aviInfo info;
-        video_body-&gt;getVideoInfo(&amp;info);
-        return info.fps1000;
-}
-/**
-    \fn jsGetVideoCodec
-*/
-char *jsGetVideoCodec ( void)
-{
-uint32_t fcc;
-aviInfo info;
-        video_body-&gt;getVideoInfo(&amp;info);
-        fcc=info.fcc;
-        return fourCC::tostring(fcc);
-}
-// EOF

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsAvidemux_js.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsAvidemux_js.c	2010-05-20 15:22:49 UTC (rev 6206)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsAvidemux_js.c	2010-05-20 15:22:52 UTC (rev 6207)
@@ -1,1317 +0,0 @@
-/*
---- DO NOT EDIT THIS FILE !!! ---
-
-This file has been generated automatically with 'jsapigen'.
-
-jsapigen is a glue-code generator for SpiderMonkey. It is distributed
-under the conditions of version 3 of the GNU General Public License.
-Please have a look at <A HREF="http://jsapigen.sourceforge.net.">http://jsapigen.sourceforge.net.</A>
-
-This file is NOT part of jsapigen and is NOT necessarily covered by
-jsapigen's license. For licensing information regarding this file,
-please refer to the software package which it is part of.
-
-*/
-
-#include &quot;stdio.h&quot;
-#include &quot;ADM_jsAvidemux.h&quot;
-void jsAvidemux(void)
-{
-        printf(&quot;Constructor invoked\n&quot;);
-}
-
-#ifdef HAVE_ALLOCA_H
-#include &lt;alloca.h&gt;
-static size_t jj_alloca_limit = 0;
-#endif
-#include &lt;stdlib.h&gt;
-#include &lt;string.h&gt;
-#include &lt;wchar.h&gt;
-#ifdef HAVE_ALLOCA_H
-#endif
-#include &lt;jsapi.h&gt;
-#ifndef JS_THREADSAFE
-#if JS_VERSION &lt;= 170
-#define jsrefcount int
-#define JS_BeginRequest(cx)
-#define JS_EndRequest(cx)
-#define JS_SuspendRequest(cx)
-#define JS_ResumeRequest(cx, saveDepth)
-#endif
-#endif
-#ifndef JS_FS
-#define JS_FS(name, call, nargs, flags, extra) {name, call, nargs, flags, extra}
-#endif
-#ifndef JS_FS_END
-#define JS_FS_END {NULL, NULL, 0, 0, 0}
-#endif
-
-static JSBool
-jjadmmarkerA_get(JSContext *cx, JSObject *obj, jsval id, jsval *val)
-{
-    double var2;
-    jsval var5;
-    JSBool var1;
-    var2 = 0.0;
-    var5 = JSVAL_NULL;
-    var1 = JS_FALSE;
-    if (!JS_EnterLocalRootScope(cx)) {
-        goto do_return;
-    }
-    var2 = jsGetMarkerA();
-    if (JS_NewNumberValue(cx, var2, &amp;var5) != JS_TRUE) {
-        goto do_return;
-    }
-    if (val) {
-        *val = var5;
-    }
-    var1 = JS_TRUE;
-    do_return:
-    JS_LeaveLocalRootScope(cx);
-    return var1;
-}
-static JSBool
-jjadmmarkerA_set(JSContext *cx, JSObject *obj, jsval id, jsval *val)
-{
-    double var7;
-    jsval var10;
-    jsdouble var11;
-    JSBool var6;
-    var7 = 0.0;
-    var10 = JSVAL_NULL;
-    var11 = 0.0;
-    var6 = JS_FALSE;
-    if (!JS_EnterLocalRootScope(cx)) {
-        goto do_return;
-    }
-    var10 = *val;
-    if (JS_ValueToNumber(cx, var10, &amp;var11) != JS_TRUE) {
-        goto do_return;
-    }
-    var7 = (double)var11;
-    jsSetMarkerA(var7);
-    var6 = JS_TRUE;
-    do_return:
-    JS_LeaveLocalRootScope(cx);
-    return var6;
-}
-static JSBool
-jjadmmarkerB_get(JSContext *cx, JSObject *obj, jsval id, jsval *val)
-{
-    double var13;
-    jsval var16;
-    JSBool var12;
-    var13 = 0.0;
-    var16 = JSVAL_NULL;
-    var12 = JS_FALSE;
-    if (!JS_EnterLocalRootScope(cx)) {
-        goto do_return;
-    }
-    var13 = jsGetMarkerB();
-    if (JS_NewNumberValue(cx, var13, &amp;var16) != JS_TRUE) {
-        goto do_return;
-    }
-    if (val) {
-        *val = var16;
-    }
-    var12 = JS_TRUE;
-    do_return:
-    JS_LeaveLocalRootScope(cx);
-    return var12;
-}
-static JSBool
-jjadmmarkerB_set(JSContext *cx, JSObject *obj, jsval id, jsval *val)
-{
-    double var18;
-    jsval var21;
-    jsdouble var22;
-    JSBool var17;
-    var18 = 0.0;
-    var21 = JSVAL_NULL;
-    var22 = 0.0;
-    var17 = JS_FALSE;
-    if (!JS_EnterLocalRootScope(cx)) {
-        goto do_return;
-    }
-    var21 = *val;
-    if (JS_ValueToNumber(cx, var21, &amp;var22) != JS_TRUE) {
-        goto do_return;
-    }
-    var18 = (double)var22;
-    jsSetMarkerB(var18);
-    var17 = JS_TRUE;
-    do_return:
-    JS_LeaveLocalRootScope(cx);
-    return var17;
-}
-static JSBool
-jjadmaudioResample_get(JSContext *cx, JSObject *obj, jsval id, jsval *val)
-{
-    int var24;
-    jsval var27;
-    JSBool var23;
-    var24 = 0;
-    var27 = JSVAL_NULL;
-    var23 = JS_FALSE;
-    if (!JS_EnterLocalRootScope(cx)) {
-        goto do_return;
-    }
-    var24 = jsGetResample();
-    if (JS_NewNumberValue(cx, var24, &amp;var27) != JS_TRUE) {
-        goto do_return;
-    }
-    if (val) {
-        *val = var27;
-    }
-    var23 = JS_TRUE;
-    do_return:
-    JS_LeaveLocalRootScope(cx);
-    return var23;
-}
-static JSBool
-jjadmaudioResample_set(JSContext *cx, JSObject *obj, jsval id, jsval *val)
-{
-    int var29;
-    jsval var32;
-    int32 var33;
-    JSBool var28;
-    var29 = 0;
-    var32 = JSVAL_NULL;
-    var33 = 0;
-    var28 = JS_FALSE;
-    if (!JS_EnterLocalRootScope(cx)) {
-        goto do_return;
-    }
-    var32 = *val;
-    if (JS_ValueToInt32(cx, var32, &amp;var33) != JS_TRUE) {
-        goto do_return;
-    }
-    var29 = (int)var33;
-    jsSetResample(var29);
-    var28 = JS_TRUE;
-    do_return:
-    JS_LeaveLocalRootScope(cx);
-    return var28;
-}
-static JSBool
-jjadmloadVideo(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
-{
-    JSObject * var35;
-    int var36;
-    int var39;
-    char * var40;
-    int var41;
-    jsval var42;
-    JSString * var43;
-    jsval var241;
-    size_t var44;
-    size_t var45;
-    int var47;
-    jschar * var48;
-    jsval var242;
-    jsval var49;
-    JSBool var34;
-    var35 = NULL;
-    var36 = 0;
-    var39 = 0;
-    var40 = NULL;
-    var41 = 0;
-    var42 = JSVAL_NULL;
-    var43 = NULL;
-    var241 = JSVAL_NULL;
-    var44 = 0;
-    var45 = 0;
-    var47 = 0;
-    var48 = NULL;
-    var242 = JSVAL_NULL;
-    var49 = JSVAL_NULL;
-    var34 = JS_FALSE;
-    var35 = obj;
-    var39 = argc;
-    var41 = 0;
-    var41 = var41 &lt; var39;
-    if (var41) {
-    var42 = argv[0];
-    var43 = JS_ValueToString(cx, var42);
-    if (!var43) {
-        goto do_return;
-    }
-    var241 = STRING_TO_JSVAL(var43);
-    argv[argc+0] = var241;
-    var44 = JS_GetStringLength(var43);
-    var45 = 1;
-    var45 += var44;
-#ifdef HAVE_ALLOCA
-    if (var45 &lt; jj_alloca_limit) {
-        var40 = alloca(var45);
-    } else {
-#endif
-        var40 = malloc(var45);
-        if (!var40) {
-            goto do_return;
-        } else {
-            var47 = 1;
-        }
-#ifdef HAVE_ALLOCA
-    }
-#endif
-    var48 = JS_GetStringChars(var43);
-    var242 = STRING_TO_JSVAL(var43);
-    argv[argc+1] = var242;
-    {
-        size_t i;
-        for (i = 0; i &lt; var44; ++i) {
-            var40[i] = var48[i];
-        }
-        var40[var44] = '\0';
-    }
-    }
-    var36 = jsLoadVideo(var40);
-    if (JS_NewNumberValue(cx, var36, &amp;var49) != JS_TRUE) {
-        goto do_return;
-    }
-    argv[argc+2] = var49;
-    if (rval) {
-        *rval = var49;
-    }
-    var34 = JS_TRUE;
-    do_return:
-    if (var47) {
-        free(var40);
-        var40 = NULL;
-        var47 = 0;
-    }
-    return var34;
-}
-static JSBool
-jjadmclearSegments(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
-{
-    JSObject * var51;
-    int var52;
-    int var55;
-    jsval var56;
-    JSBool var50;
-    var51 = NULL;
-    var52 = 0;
-    var55 = 0;
-    var56 = JSVAL_NULL;
-    var50 = JS_FALSE;
-    var51 = obj;
-    var55 = argc;
-    var52 = jsClearSegments();
-    if (JS_NewNumberValue(cx, var52, &amp;var56) != JS_TRUE) {
-        goto do_return;
-    }
-    argv[argc+0] = var56;
-    if (rval) {
-        *rval = var56;
-    }
-    var50 = JS_TRUE;
-    do_return:
-    return var50;
-}
-static JSBool
-jjadmappendVideo(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
-{
-    JSObject * var58;
-    int var59;
-    int var62;
-    char * var63;
-    int var64;
-    jsval var65;
-    JSString * var66;
-    jsval var245;
-    size_t var67;
-    size_t var68;
-    int var70;
-    jschar * var71;
-    jsval var246;
-    jsval var72;
-    JSBool var57;
-    var58 = NULL;
-    var59 = 0;
-    var62 = 0;
-    var63 = NULL;
-    var64 = 0;
-    var65 = JSVAL_NULL;
-    var66 = NULL;
-    var245 = JSVAL_NULL;
-    var67 = 0;
-    var68 = 0;
-    var70 = 0;
-    var71 = NULL;
-    var246 = JSVAL_NULL;
-    var72 = JSVAL_NULL;
-    var57 = JS_FALSE;
-    var58 = obj;
-    var62 = argc;
-    var64 = 0;
-    var64 = var64 &lt; var62;
-    if (var64) {
-    var65 = argv[0];
-    var66 = JS_ValueToString(cx, var65);
-    if (!var66) {
-        goto do_return;
-    }
-    var245 = STRING_TO_JSVAL(var66);
-    argv[argc+0] = var245;
-    var67 = JS_GetStringLength(var66);
-    var68 = 1;
-    var68 += var67;
-#ifdef HAVE_ALLOCA
-    if (var68 &lt; jj_alloca_limit) {
-        var63 = alloca(var68);
-    } else {
-#endif
-        var63 = malloc(var68);
-        if (!var63) {
-            goto do_return;
-        } else {
-            var70 = 1;
-        }
-#ifdef HAVE_ALLOCA
-    }
-#endif
-    var71 = JS_GetStringChars(var66);
-    var246 = STRING_TO_JSVAL(var66);
-    argv[argc+1] = var246;
-    {
-        size_t i;
-        for (i = 0; i &lt; var67; ++i) {
-            var63[i] = var71[i];
-        }
-        var63[var67] = '\0';
-    }
-    }
-    var59 = jsAppendVideo(var63);
-    if (JS_NewNumberValue(cx, var59, &amp;var72) != JS_TRUE) {
-        goto do_return;
-    }
-    argv[argc+2] = var72;
-    if (rval) {
-        *rval = var72;
-    }
-    var57 = JS_TRUE;
-    do_return:
-    if (var70) {
-        free(var63);
-        var63 = NULL;
-        var70 = 0;
-    }
-    return var57;
-}
-static JSBool
-jjadmaddSegment(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
-{
-    JSObject * var74;
-    int var75;
-    int var78;
-    int var79;
-    int var82;
-    jsval var83;
-    int32 var84;
-    double var80;
-    int var85;
-    jsval var86;
-    jsdouble var87;
-    double var81;
-    int var88;
-    jsval var89;
-    jsdouble var90;
-    jsval var91;
-    JSBool var73;
-    var74 = NULL;
-    var75 = 0;
-    var78 = 0;
-    var79 = 0;
-    var82 = 0;
-    var83 = JSVAL_NULL;
-    var84 = 0;
-    var80 = 0.0;
-    var85 = 0;
-    var86 = JSVAL_NULL;
-    var87 = 0.0;
-    var81 = 0.0;
-    var88 = 0;
-    var89 = JSVAL_NULL;
-    var90 = 0.0;
-    var91 = JSVAL_NULL;
-    var73 = JS_FALSE;
-    var74 = obj;
-    var78 = argc;
-    var82 = 0;
-    var82 = var82 &lt; var78;
-    if (var82) {
-    var83 = argv[0];
-    if (JS_ValueToInt32(cx, var83, &amp;var84) != JS_TRUE) {
-        goto do_return;
-    }
-    var79 = (int)var84;
-    }
-    var85 = 1;
-    var85 = var85 &lt; var78;
-    if (var85) {
-    var86 = argv[1];
-    if (JS_ValueToNumber(cx, var86, &amp;var87) != JS_TRUE) {
-        goto do_return;
-    }
-    var80 = (double)var87;
-    }
-    var88 = 2;
-    var88 = var88 &lt; var78;
-    if (var88) {
-    var89 = argv[2];
-    if (JS_ValueToNumber(cx, var89, &amp;var90) != JS_TRUE) {
-        goto do_return;
-    }
-    var81 = (double)var90;
-    }
-    var75 = jsAddSegment(var79, var80, var81);
-    if (JS_NewNumberValue(cx, var75, &amp;var91) != JS_TRUE) {
-        goto do_return;
-    }
-    argv[argc+0] = var91;
-    if (rval) {
-        *rval = var91;
-    }
-    var73 = JS_TRUE;
-    do_return:
-    return var73;
-}
-static JSBool
-jjadmsetPostProc(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
-{
-    JSObject * var93;
-    int var94;
-    int var97;
-    int var98;
-    int var101;
-    jsval var102;
-    int32 var103;
-    int var99;
-    int var104;
-    jsval var105;
-    int32 var106;
-    int var100;
-    int var107;
-    jsval var108;
-    int32 var109;
-    jsval var110;
-    JSBool var92;
-    var93 = NULL;
-    var94 = 0;
-    var97 = 0;
-    var98 = 0;
-    var101 = 0;
-    var102 = JSVAL_NULL;
-    var103 = 0;
-    var99 = 0;
-    var104 = 0;
-    var105 = JSVAL_NULL;
-    var106 = 0;
-    var100 = 0;
-    var107 = 0;
-    var108 = JSVAL_NULL;
-    var109 = 0;
-    var110 = JSVAL_NULL;
-    var92 = JS_FALSE;
-    var93 = obj;
-    var97 = argc;
-    var101 = 0;
-    var101 = var101 &lt; var97;
-    if (var101) {
-    var102 = argv[0];
-    if (JS_ValueToInt32(cx, var102, &amp;var103) != JS_TRUE) {
-        goto do_return;
-    }
-    var98 = (int)var103;
-    }
-    var104 = 1;
-    var104 = var104 &lt; var97;
-    if (var104) {
-    var105 = argv[1];
-    if (JS_ValueToInt32(cx, var105, &amp;var106) != JS_TRUE) {
-        goto do_return;
-    }
-    var99 = (int)var106;
-    }
-    var107 = 2;
-    var107 = var107 &lt; var97;
-    if (var107) {
-    var108 = argv[2];
-    if (JS_ValueToInt32(cx, var108, &amp;var109) != JS_TRUE) {
-        goto do_return;
-    }
-    var100 = (int)var109;
-    }
-    var94 = jsSetPostProc(var98, var99, var100);
-    if (JS_NewNumberValue(cx, var94, &amp;var110) != JS_TRUE) {
-        goto do_return;
-    }
-    argv[argc+0] = var110;
-    if (rval) {
-        *rval = var110;
-    }
-    var92 = JS_TRUE;
-    do_return:
-    return var92;
-}
-static JSBool
-jjadmgetWidth(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
-{
-    JSObject * var112;
-    int var113;
-    int var116;
-    jsval var117;
-    JSBool var111;
-    var112 = NULL;
-    var113 = 0;
-    var116 = 0;
-    var117 = JSVAL_NULL;
-    var111 = JS_FALSE;
-    var112 = obj;
-    var116 = argc;
-    var113 = jsGetWidth();
-    if (JS_NewNumberValue(cx, var113, &amp;var117) != JS_TRUE) {
-        goto do_return;
-    }
-    argv[argc+0] = var117;
-    if (rval) {
-        *rval = var117;
-    }
-    var111 = JS_TRUE;
-    do_return:
-    return var111;
-}
-static JSBool
-jjadmgetHeight(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
-{
-    JSObject * var119;
-    int var120;
-    int var123;
-    jsval var124;
-    JSBool var118;
-    var119 = NULL;
-    var120 = 0;
-    var123 = 0;
-    var124 = JSVAL_NULL;
-    var118 = JS_FALSE;
-    var119 = obj;
-    var123 = argc;
-    var120 = jsGetHeight();
-    if (JS_NewNumberValue(cx, var120, &amp;var124) != JS_TRUE) {
-        goto do_return;
-    }
-    argv[argc+0] = var124;
-    if (rval) {
-        *rval = var124;
-    }
-    var118 = JS_TRUE;
-    do_return:
-    return var118;
-}
-static JSBool
-jjadmgetFps1000(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
-{
-    JSObject * var126;
-    int var127;
-    int var130;
-    jsval var131;
-    JSBool var125;
-    var126 = NULL;
-    var127 = 0;
-    var130 = 0;
-    var131 = JSVAL_NULL;
-    var125 = JS_FALSE;
-    var126 = obj;
-    var130 = argc;
-    var127 = jsGetFps1000();
-    if (JS_NewNumberValue(cx, var127, &amp;var131) != JS_TRUE) {
-        goto do_return;
-    }
-    argv[argc+0] = var131;
-    if (rval) {
-        *rval = var131;
-    }
-    var125 = JS_TRUE;
-    do_return:
-    return var125;
-}
-static JSBool
-jjadmgetVideoCodec(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
-{
-    JSObject * var133;
-    char * var134;
-    int var137;
-    jsval var138;
-    JSString * var139;
-    jsval var253;
-    char * var140;
-    jsval var254;
-    JSBool var132;
-    var133 = NULL;
-    var134 = NULL;
-    var137 = 0;
-    var138 = JSVAL_NULL;
-    var139 = NULL;
-    var253 = JSVAL_NULL;
-    var140 = NULL;
-    var254 = JSVAL_NULL;
-    var132 = JS_FALSE;
-    var133 = obj;
-    var137 = argc;
-    var134 = jsGetVideoCodec();
-    if (var134) {
-    var139 = JS_NewStringCopyZ(cx, var134);
-    if (!var139) {
-        goto do_return;
-    }
-    var253 = STRING_TO_JSVAL(var139);
-    argv[argc+0] = var253;
-    } else {
-    var140 = &quot;&quot;;
-    var139 = JS_InternString(cx, var140);
-    if (!var139) {
-        goto do_return;
-    }
-    var254 = STRING_TO_JSVAL(var139);
-    argv[argc+1] = var254;
-    }
-    var138 = STRING_TO_JSVAL(var139);
-    if (rval) {
-        *rval = var138;
-    }
-    var132 = JS_TRUE;
-    do_return:
-    return var132;
-}
-static JSBool
-jjadmaudioReset(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
-{
-    JSObject * var142;
-    int var143;
-    int var146;
-    jsval var147;
-    JSBool var141;
-    var142 = NULL;
-    var143 = 0;
-    var146 = 0;
-    var147 = JSVAL_NULL;
-    var141 = JS_FALSE;
-    var142 = obj;
-    var146 = argc;
-    var143 = jsAudioReset();
-    if (JS_NewNumberValue(cx, var143, &amp;var147) != JS_TRUE) {
-        goto do_return;
-    }
-    argv[argc+0] = var147;
-    if (rval) {
-        *rval = var147;
-    }
-    var141 = JS_TRUE;
-    do_return:
-    return var141;
-}
-static JSBool
-jjadmaudioMixer(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
-{
-    JSObject * var149;
-    int var150;
-    int var153;
-    char * var154;
-    int var155;
-    jsval var156;
-    JSString * var157;
-    jsval var256;
-    size_t var158;
-    size_t var159;
-    int var161;
-    jschar * var162;
-    jsval var257;
-    jsval var163;
-    JSBool var148;
-    var149 = NULL;
-    var150 = 0;
-    var153 = 0;
-    var154 = NULL;
-    var155 = 0;
-    var156 = JSVAL_NULL;
-    var157 = NULL;
-    var256 = JSVAL_NULL;
-    var158 = 0;
-    var159 = 0;
-    var161 = 0;
-    var162 = NULL;
-    var257 = JSVAL_NULL;
-    var163 = JSVAL_NULL;
-    var148 = JS_FALSE;
-    var149 = obj;
-    var153 = argc;
-    var155 = 0;
-    var155 = var155 &lt; var153;
-    if (var155) {
-    var156 = argv[0];
-    var157 = JS_ValueToString(cx, var156);
-    if (!var157) {
-        goto do_return;
-    }
-    var256 = STRING_TO_JSVAL(var157);
-    argv[argc+0] = var256;
-    var158 = JS_GetStringLength(var157);
-    var159 = 1;
-    var159 += var158;
-#ifdef HAVE_ALLOCA
-    if (var159 &lt; jj_alloca_limit) {
-        var154 = alloca(var159);
-    } else {
-#endif
-        var154 = malloc(var159);
-        if (!var154) {
-            goto do_return;
-        } else {
-            var161 = 1;
-        }
-#ifdef HAVE_ALLOCA
-    }
-#endif
-    var162 = JS_GetStringChars(var157);
-    var257 = STRING_TO_JSVAL(var157);
-    argv[argc+1] = var257;
-    {
-        size_t i;
-        for (i = 0; i &lt; var158; ++i) {
-            var154[i] = var162[i];
-        }
-        var154[var158] = '\0';
-    }
-    }
-    var150 = jsAudioMixer(var154);
-    if (JS_NewNumberValue(cx, var150, &amp;var163) != JS_TRUE) {
-        goto do_return;
-    }
-    argv[argc+2] = var163;
-    if (rval) {
-        *rval = var163;
-    }
-    var148 = JS_TRUE;
-    do_return:
-    if (var161) {
-        free(var154);
-        var154 = NULL;
-        var161 = 0;
-    }
-    return var148;
-}
-static JSBool
-jjadmclearVideoFilters(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
-{
-    JSObject * var165;
-    int var166;
-    int var169;
-    jsval var170;
-    JSBool var164;
-    var165 = NULL;
-    var166 = 0;
-    var169 = 0;
-    var170 = JSVAL_NULL;
-    var164 = JS_FALSE;
-    var165 = obj;
-    var169 = argc;
-    var166 = jsClearVideoFilters();
-    if (JS_NewNumberValue(cx, var166, &amp;var170) != JS_TRUE) {
-        goto do_return;
-    }
-    argv[argc+0] = var170;
-    if (rval) {
-        *rval = var170;
-    }
-    var164 = JS_TRUE;
-    do_return:
-    return var164;
-}
-static JSBool
-jjadmvideoCodec_ignore(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
-{
-    JSObject * var172;
-    int var173;
-    int var176;
-    char * var177;
-    int var178;
-    jsval var179;
-    JSString * var180;
-    jsval var260;
-    size_t var181;
-    size_t var182;
-    int var184;
-    jschar * var185;
-    jsval var261;
-    jsval var186;
-    JSBool var171;
-    var172 = NULL;
-    var173 = 0;
-    var176 = 0;
-    var177 = NULL;
-    var178 = 0;
-    var179 = JSVAL_NULL;
-    var180 = NULL;
-    var260 = JSVAL_NULL;
-    var181 = 0;
-    var182 = 0;
-    var184 = 0;
-    var185 = NULL;
-    var261 = JSVAL_NULL;
-    var186 = JSVAL_NULL;
-    var171 = JS_FALSE;
-    var172 = obj;
-    var176 = argc;
-    var178 = 0;
-    var178 = var178 &lt; var176;
-    if (var178) {
-    var179 = argv[0];
-    var180 = JS_ValueToString(cx, var179);
-    if (!var180) {
-        goto do_return;
-    }
-    var260 = STRING_TO_JSVAL(var180);
-    argv[argc+0] = var260;
-    var181 = JS_GetStringLength(var180);
-    var182 = 1;
-    var182 += var181;
-#ifdef HAVE_ALLOCA
-    if (var182 &lt; jj_alloca_limit) {
-        var177 = alloca(var182);
-    } else {
-#endif
-        var177 = malloc(var182);
-        if (!var177) {
-            goto do_return;
-        } else {
-            var184 = 1;
-        }
-#ifdef HAVE_ALLOCA
-    }
-#endif
-    var185 = JS_GetStringChars(var180);
-    var261 = STRING_TO_JSVAL(var180);
-    argv[argc+1] = var261;
-    {
-        size_t i;
-        for (i = 0; i &lt; var181; ++i) {
-            var177[i] = var185[i];
-        }
-        var177[var181] = '\0';
-    }
-    }
-    var173 = jsVideoCodec(var177);
-    if (JS_NewNumberValue(cx, var173, &amp;var186) != JS_TRUE) {
-        goto do_return;
-    }
-    argv[argc+2] = var186;
-    if (rval) {
-        *rval = var186;
-    }
-    var171 = JS_TRUE;
-    do_return:
-    if (var184) {
-        free(var177);
-        var177 = NULL;
-        var184 = 0;
-    }
-    return var171;
-}
-static JSBool
-jjadmaddVideoFilter_ignore(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
-{
-    JSObject * var188;
-    int var189;
-    int var192;
-    char * var193;
-    int var194;
-    jsval var195;
-    JSString * var196;
-    jsval var263;
-    size_t var197;
-    size_t var198;
-    int var200;
-    jschar * var201;
-    jsval var264;
-    jsval var202;
-    JSBool var187;
-    var188 = NULL;
-    var189 = 0;
-    var192 = 0;
-    var193 = NULL;
-    var194 = 0;
-    var195 = JSVAL_NULL;
-    var196 = NULL;
-    var263 = JSVAL_NULL;
-    var197 = 0;
-    var198 = 0;
-    var200 = 0;
-    var201 = NULL;
-    var264 = JSVAL_NULL;
-    var202 = JSVAL_NULL;
-    var187 = JS_FALSE;
-    var188 = obj;
-    var192 = argc;
-    var194 = 0;
-    var194 = var194 &lt; var192;
-    if (var194) {
-    var195 = argv[0];
-    var196 = JS_ValueToString(cx, var195);
-    if (!var196) {
-        goto do_return;
-    }
-    var263 = STRING_TO_JSVAL(var196);
-    argv[argc+0] = var263;
-    var197 = JS_GetStringLength(var196);
-    var198 = 1;
-    var198 += var197;
-#ifdef HAVE_ALLOCA
-    if (var198 &lt; jj_alloca_limit) {
-        var193 = alloca(var198);
-    } else {
-#endif
-        var193 = malloc(var198);
-        if (!var193) {
-            goto do_return;
-        } else {
-            var200 = 1;
-        }
-#ifdef HAVE_ALLOCA
-    }
-#endif
-    var201 = JS_GetStringChars(var196);
-    var264 = STRING_TO_JSVAL(var196);
-    argv[argc+1] = var264;
-    {
-        size_t i;
-        for (i = 0; i &lt; var197; ++i) {
-            var193[i] = var201[i];
-        }
-        var193[var197] = '\0';
-    }
-    }
-    var189 = jsVideoFilter(var193);
-    if (JS_NewNumberValue(cx, var189, &amp;var202) != JS_TRUE) {
-        goto do_return;
-    }
-    argv[argc+2] = var202;
-    if (rval) {
-        *rval = var202;
-    }
-    var187 = JS_TRUE;
-    do_return:
-    if (var200) {
-        free(var193);
-        var193 = NULL;
-        var200 = 0;
-    }
-    return var187;
-}
-static JSBool
-jjadmaudioCodec_ignore(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
-{
-    JSObject * var204;
-    int var205;
-    int var208;
-    char * var209;
-    int var210;
-    jsval var211;
-    JSString * var212;
-    jsval var266;
-    size_t var213;
-    size_t var214;
-    int var216;
-    jschar * var217;
-    jsval var267;
-    jsval var218;
-    JSBool var203;
-    var204 = NULL;
-    var205 = 0;
-    var208 = 0;
-    var209 = NULL;
-    var210 = 0;
-    var211 = JSVAL_NULL;
-    var212 = NULL;
-    var266 = JSVAL_NULL;
-    var213 = 0;
-    var214 = 0;
-    var216 = 0;
-    var217 = NULL;
-    var267 = JSVAL_NULL;
-    var218 = JSVAL_NULL;
-    var203 = JS_FALSE;
-    var204 = obj;
-    var208 = argc;
-    var210 = 0;
-    var210 = var210 &lt; var208;
-    if (var210) {
-    var211 = argv[0];
-    var212 = JS_ValueToString(cx, var211);
-    if (!var212) {
-        goto do_return;
-    }
-    var266 = STRING_TO_JSVAL(var212);
-    argv[argc+0] = var266;
-    var213 = JS_GetStringLength(var212);
-    var214 = 1;
-    var214 += var213;
-#ifdef HAVE_ALLOCA
-    if (var214 &lt; jj_alloca_limit) {
-        var209 = alloca(var214);
-    } else {
-#endif
-        var209 = malloc(var214);
-        if (!var209) {
-            goto do_return;
-        } else {
-            var216 = 1;
-        }
-#ifdef HAVE_ALLOCA
-    }
-#endif
-    var217 = JS_GetStringChars(var212);
-    var267 = STRING_TO_JSVAL(var212);
-    argv[argc+1] = var267;
-    {
-        size_t i;
-        for (i = 0; i &lt; var213; ++i) {
-            var209[i] = var217[i];
-        }
-        var209[var213] = '\0';
-    }
-    }
-    var205 = jsAudioCodec(var209);
-    if (JS_NewNumberValue(cx, var205, &amp;var218) != JS_TRUE) {
-        goto do_return;
-    }
-    argv[argc+2] = var218;
-    if (rval) {
-        *rval = var218;
-    }
-    var203 = JS_TRUE;
-    do_return:
-    if (var216) {
-        free(var209);
-        var209 = NULL;
-        var216 = 0;
-    }
-    return var203;
-}
-static JSBool
-jjadmsetContainer_ignore(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
-{
-    JSObject * var220;
-    int var221;
-    int var224;
-    char * var225;
-    int var226;
-    jsval var227;
-    JSString * var228;
-    jsval var269;
-    size_t var229;
-    size_t var230;
-    int var232;
-    jschar * var233;
-    jsval var270;
-    jsval var234;
-    JSBool var219;
-    var220 = NULL;
-    var221 = 0;
-    var224 = 0;
-    var225 = NULL;
-    var226 = 0;
-    var227 = JSVAL_NULL;
-    var228 = NULL;
-    var269 = JSVAL_NULL;
-    var229 = 0;
-    var230 = 0;
-    var232 = 0;
-    var233 = NULL;
-    var270 = JSVAL_NULL;
-    var234 = JSVAL_NULL;
-    var219 = JS_FALSE;
-    var220 = obj;
-    var224 = argc;
-    var226 = 0;
-    var226 = var226 &lt; var224;
-    if (var226) {
-    var227 = argv[0];
-    var228 = JS_ValueToString(cx, var227);
-    if (!var228) {
-        goto do_return;
-    }
-    var269 = STRING_TO_JSVAL(var228);
-    argv[argc+0] = var269;
-    var229 = JS_GetStringLength(var228);
-    var230 = 1;
-    var230 += var229;
-#ifdef HAVE_ALLOCA
-    if (var230 &lt; jj_alloca_limit) {
-        var225 = alloca(var230);
-    } else {
-#endif
-        var225 = malloc(var230);
-        if (!var225) {
-            goto do_return;
-        } else {
-            var232 = 1;
-        }
-#ifdef HAVE_ALLOCA
-    }
-#endif
-    var233 = JS_GetStringChars(var228);
-    var270 = STRING_TO_JSVAL(var228);
-    argv[argc+1] = var270;
-    {
-        size_t i;
-        for (i = 0; i &lt; var229; ++i) {
-            var225[i] = var233[i];
-        }
-        var225[var229] = '\0';
-    }
-    }
-    var221 = jsSetContainer(var225);
-    if (JS_NewNumberValue(cx, var221, &amp;var234) != JS_TRUE) {
-        goto do_return;
-    }
-    argv[argc+2] = var234;
-    if (rval) {
-        *rval = var234;
-    }
-    var219 = JS_TRUE;
-    do_return:
-    if (var232) {
-        free(var225);
-        var225 = NULL;
-        var232 = 0;
-    }
-    return var219;
-}
-static JSBool
-jjadm__construct__(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
-{
-    JSObject * var236;
-    int var240;
-    JSBool var235;
-    var236 = NULL;
-    var240 = 0;
-    var235 = JS_FALSE;
-    var236 = obj;
-    var240 = argc;
-    jsAvidemux();
-    var235 = JS_TRUE;
-    return var235;
-}
-static JSPropertySpec jj_static_ps[] = {
-    {NULL, 0, 0, NULL, NULL}
-};
-static JSPropertySpec jj_ps[] = {
-    {NULL, 0, 0, NULL, NULL}
-};
-static JSFunctionSpec jj_static_fs[] = {
-    JS_FS_END
-};
-static JSFunctionSpec jj_fs[] = {
-    JS_FS_END
-};
-static JSPropertySpec jjadm_static_ps[] = {
-    {&quot;markerA&quot;, 0, 0|JSPROP_ENUMERATE, jjadmmarkerA_get, jjadmmarkerA_set},
-    {&quot;markerB&quot;, 0, 0|JSPROP_ENUMERATE, jjadmmarkerB_get, jjadmmarkerB_set},
-    {&quot;audioResample&quot;, 0, 0|JSPROP_ENUMERATE, jjadmaudioResample_get, jjadmaudioResample_set},
-    {NULL, 0, 0, NULL, NULL}
-};
-static JSPropertySpec jjadm_ps[] = {
-    {NULL, 0, 0, NULL, NULL}
-};
-static JSFunctionSpec jjadm_static_fs[] = {
-    JS_FS(&quot;loadVideo&quot;, jjadmloadVideo, 1, 0, 3),
-    JS_FS(&quot;clearSegments&quot;, jjadmclearSegments, 0, 0, 1),
-    JS_FS(&quot;appendVideo&quot;, jjadmappendVideo, 1, 0, 3),
-    JS_FS(&quot;addSegment&quot;, jjadmaddSegment, 3, 0, 1),
-    JS_FS(&quot;setPostProc&quot;, jjadmsetPostProc, 3, 0, 1),
-    JS_FS(&quot;getWidth&quot;, jjadmgetWidth, 0, 0, 1),
-    JS_FS(&quot;getHeight&quot;, jjadmgetHeight, 0, 0, 1),
-    JS_FS(&quot;getFps1000&quot;, jjadmgetFps1000, 0, 0, 1),
-    JS_FS(&quot;getVideoCodec&quot;, jjadmgetVideoCodec, 0, 0, 2),
-    JS_FS(&quot;audioReset&quot;, jjadmaudioReset, 0, 0, 1),
-    JS_FS(&quot;audioMixer&quot;, jjadmaudioMixer, 1, 0, 3),
-    JS_FS(&quot;clearVideoFilters&quot;, jjadmclearVideoFilters, 0, 0, 1),
-    JS_FS(&quot;videoCodec&quot;, jsAdmvideoCodec,  1, 0, 3),
-    JS_FS(&quot;addVideoFilter&quot;, jsAdmaddVideoFilter,  1, 0, 3),
-    JS_FS(&quot;audioCodec&quot;, jsAdmaudioCodec,  1, 0, 3),
-    JS_FS(&quot;setContainer&quot;, jsAdmsetContainer,  1, 0, 3),
-    JS_FS_END
-};
-static JSFunctionSpec jjadm_fs[] = {
-    JS_FS_END
-};
-static JSClass jjadm_class = {
-    &quot;adm&quot;,
-    0,
-    JS_PropertyStub,
-    JS_PropertyStub,
-    JS_PropertyStub,
-    JS_PropertyStub,
-    JS_EnumerateStub,
-    JS_ResolveStub,
-    JS_ConvertStub,
-    JS_FinalizeStub,
-    NULL,
-    NULL,
-    NULL,
-    jjadm__construct__,
-    NULL,
-    NULL,
-    NULL,
-    NULL
-};
-static JSObject *
-jjadm_init(JSContext *cx, JSObject *obj)
-{
-    JSObject *parent_proto, *proto;
-    JSClass *class;
-    if (!cx || !obj) {
-        JS_ReportError(cx, &quot;invalid parameter&quot;);
-        return NULL;
-    }
-    if (!JS_EnterLocalRootScope(cx)) {
-        JS_ReportError(cx, &quot;JS_EnterLocalRootScope failed&quot;);
-        return NULL;
-    }
-    parent_proto = NULL;
-    proto = NULL;
-    parent_proto = JS_NewObject(cx, NULL, NULL, NULL);
-    if (!parent_proto) {
-        JS_LeaveLocalRootScope(cx);
-        JS_ReportError(cx, &quot;failed to create prototype&quot;);
-        return NULL;
-    }
-    class = &amp;jjadm_class;
-    proto = JS_InitClass(cx, obj, parent_proto, class, jjadm__construct__, 0, jjadm_ps, jjadm_fs, jjadm_static_ps, jjadm_static_fs);
-    if (!proto) {
-        JS_LeaveLocalRootScope(cx);
-        JS_ReportError(cx, &quot;failed to init class&quot;);
-        return NULL;
-    }
-    JS_LeaveLocalRootScope(cx);
-    return proto;
-}
-
-
-JSObject *jsAvidemuxInit(JSContext *cx,JSObject *obj)
-{
-          if (JS_DefineFunctions(cx, obj, jj_static_fs) != JS_TRUE) 
-          {
-                return NULL;
-          }
-          return jjadm_init(cx,obj);
-}
-
-JSFunctionSpec  *jsGetAdmFunctions(void)
-{
-        return jjadm_static_fs;
-}
-
-

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsAvidemux_js.idl
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsAvidemux_js.idl	2010-05-20 15:22:49 UTC (rev 6206)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsAvidemux_js.idl	2010-05-20 15:22:52 UTC (rev 6207)
@@ -1,55 +0,0 @@
-%{
-#include &quot;stdio.h&quot;
-#include &quot;ADM_jsAvidemux.h&quot;
-void jsAvidemux(void)
-{
-        printf(&quot;Constructor invoked\n&quot;);
-}
-%}
-        /*            JSFUNC      C FUNC  PARAM     */
-class adm
-{
-        function int loadVideo      : jsLoadVideo (cstring ) &lt;static&gt;;
-        function int clearSegments  : jsClearSegments () &lt;static&gt;;
-        function int appendVideo    : jsAppendVideo (cstring ) &lt;static&gt;;
-        function int addSegment     : jsAddSegment (int ,double , double ) &lt;static&gt;;
-        function int setPostProc    : jsSetPostProc (int ,int , int ) &lt;static&gt;;
-        function int getWidth       : jsGetWidth ( ) &lt;static&gt;;
-        function int getHeight      : jsGetHeight ( ) &lt;static&gt;;
-        function int getFps1000     : jsGetFps1000 ( ) &lt;static&gt;;
-     function cstring getVideoCodec : jsGetVideoCodec ( ) &lt;static&gt;;
-        /*            JSFUNC                 C FUNC           PARAM     */
-        function int audioReset     : jsAudioReset () &lt;static&gt;;
-        function int audioMixer     : jsAudioMixer (cstring ) &lt;static&gt;;
-        /*            JSFUNC                 C FUNC           PARAM     */
-        function int clearVideoFilters   : jsClearVideoFilters() &lt;static&gt;;
-        
-/* Override as jsapigen cannot handle multiple args the way we need it to */
-        function int videoCodec_ignore     : jsVideoCodec(cstring)     &lt;static&gt;;
-        function int addVideoFilter_ignore : jsVideoFilter(cstring)    &lt;static&gt;;
-        function int audioCodec_ignore     : jsAudioCodec(cstring)     &lt;static&gt;;
-        function int setContainer_ignore   : jsSetContainer(cstring)   &lt;static&gt;;
-/* Properties */
-        property double markerA            : jsGetMarkerA,jsSetMarkerA &lt;static&gt;;
-        property double markerB            : jsGetMarkerB,jsSetMarkerB &lt;static&gt;;
-        property int    audioResample      : jsGetResample,jsSetResample &lt;static&gt;;
-        construct                          : jsAvidemux  ( ) &lt;static&gt;     ; 
-};
-
-%&lt;
-
-JSObject *jsAvidemuxInit(JSContext *cx,JSObject *obj)
-{
-          if (JS_DefineFunctions(cx, obj, jj_static_fs) != JS_TRUE) 
-          {
-                return NULL;
-          }
-          return jjadm_init(cx,obj);
-}
-
-JSFunctionSpec  *jsGetAdmFunctions(void)
-{
-        return jjadm_static_fs;
-}
-
-%&gt;

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsDebug.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsDebug.cpp	2010-05-20 15:22:49 UTC (rev 6206)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsDebug.cpp	2010-05-20 15:22:52 UTC (rev 6207)
@@ -1,106 +0,0 @@
-/**
-    \file ADM_JSDebug.cpp
-    \brief Debug oriented functions for avidemux JS/JS shell
-    \author mean (c) 2009 <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
-
-
-*/
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#include &quot;ADM_js.h&quot;
-#include &quot;ADM_editor/ADM_edit.hxx&quot;
-#include &quot;ADM_jsDebug.h&quot;
-#include &lt;vector&gt;
-/**/
-/**/
-extern ADM_Composer *video_body;
-void ADM_dumpJSHooks(void);
-extern vector &lt;JSFunctionSpec *&gt;listOfHooks;
-/**
-    \fn displayError
-    \brief error popup
-*/
-void jsPopupError(const char *s)
-{// begin displayError
-	
-	GUI_Verbose();
-	GUI_Error_HIG(&quot;Error&quot;,s);
-	GUI_Quiet();
-
-}// end displayError
-/**
-    \fn displayInfo
-    \brief info popup
-*/
-
-void jsPopupInfo(const char *s)
-{// begin displayInfo
-	
-	GUI_Verbose();
-	GUI_Info_HIG(ADM_LOG_IMPORTANT,&quot;Info&quot;,s);
-	GUI_Quiet();
-	
-}// end displayInfo
- /**
-    \fn print
-*/
-void jsPrint(const char *s)
-{// begin print
-        jsLog(JS_LOG_NORMAL,&quot;%s&quot;,s);
-}// end print
-void jsPrint2(const char *s)
-{// begin print
-        jsLog(JS_LOG_NORMAL,&quot;%s&quot;,s);
-}// end print
-
-
-static void dumpFunc(JSFunctionSpec *f)
-{
-    while(f-&gt;name)
-    {
-        jsLog(JS_LOG_NORMAL,&quot;     %s(..)&quot;,f-&gt;name);
-        f++;
-    }
-}
-
-/**
-    \fn printJSError
-*/
-void  printJSError(JSContext *cx, const char *message, JSErrorReport *report)
-{// begin printJSError
-int quiet=GUI_isQuiet();
-char buf[4];
-FILE *fd = ADM_fopen(report-&gt;filename,&quot;rb&quot;);
-    if(quiet)
-            GUI_Verbose();
-	if( fd )
-    {
-		fread(buf,1,4,fd);
-		fclose(fd);
-	}
-	if( strncmp(buf,&quot;//AD&quot;,4) )
-    {
-            if (report-&gt;filename || report-&gt;lineno)
-                jsLog(JS_LOG_ERROR,&quot;%s: line %d:\nMsg: %s\n&quot;,
-                              report-&gt;filename,
-                              report-&gt;lineno,
-                              message);
-            else
-                jsLog(JS_LOG_ERROR,&quot;Error&quot;);
-    
-	}else
-    {
-            jsLog(JS_LOG_ERROR,&quot;%s: line %d:\nMsg: %s\n&quot;,report-&gt;filename,report-&gt;lineno,message);
-	}
-       
-    if(quiet)
-            GUI_Quiet();
-
-}// end printJSError
-// EOF
\ No newline at end of file

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsEditor.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsEditor.cpp	2010-05-20 15:22:49 UTC (rev 6206)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsEditor.cpp	2010-05-20 15:22:52 UTC (rev 6207)
@@ -1,77 +0,0 @@
-/**
-    \file ADM_JSif.cpp
-    \brief interface to js
-*/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-#include &quot;ADM_js.h&quot;
-#include &lt;stdarg.h&gt;
-#include &lt;vector&gt;
-#include &quot;ADM_jsEditor.h&quot;
-#include &quot;ADM_editor/ADM_edit.hxx&quot;
-extern ADM_Composer *video_body;
-
-/**
-    \fn jsPrintTiming
-*/
-int jsPrintTiming(int framenumber )
-{
-    uint32_t flags;
-    uint64_t pts,dts;
-    if(true==video_body-&gt;getVideoPtsDts(framenumber, &amp;flags,&amp;pts,&amp;dts))
-    {
-        int64_t delta=0;
-        if(pts!=ADM_NO_PTS &amp;&amp; dts!=ADM_NO_PTS) delta=(int64_t)pts-(int64_t)dts;
-        jsLog(JS_LOG_NORMAL,&quot;Frame %&quot;LU&quot; : Flags 0x%&quot;LX&quot; pts=%&quot;LLD&quot; dts=%&quot;LLD&quot; delta=%&quot;LLD&quot; ms&quot;,framenumber,flags,pts,dts,delta/1000LL);
-    }else
-    {
-        jsLog(JS_LOG_NORMAL,&quot;Cannot get info for frame %&quot;LU,framenumber);
-    }
-    return 0;
-}
-
-/**
-    \fn    jsDumpSegments
-    \brief dump segment, video &amp; all
-*/
-int jsDumpSegments (void)
-{// begin PostProcess
-        enterLock();
-        video_body-&gt;dumpSegments();
-        leaveLock(); 
-        return 0;
-}// end PostProcess
-/**
-        \fn jsDumpRefVideos
-*/
-int jsDumpRefVideos (void)
-{
-        enterLock();
-        video_body-&gt;dumpRefVideos();
-        leaveLock(); 
-
-        return 0;
-}
-/**
-    \fn dumpTiming
-    \brief dump segment, video &amp; all
-*/
-JSBool dumpTiming(void)
-{// begin PostProcess
-        
-  
-        enterLock();
-        video_body-&gt;dumpTiming();
-        leaveLock(); 
-        
-        return 0;
-}// end PostProcess
-// EOF

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsEditor_js.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsEditor_js.c	2010-05-20 15:22:49 UTC (rev 6206)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsEditor_js.c	2010-05-20 15:22:52 UTC (rev 6207)
@@ -1,256 +0,0 @@
-/*
---- DO NOT EDIT THIS FILE !!! ---
-
-This file has been generated automatically with 'jsapigen'.
-
-jsapigen is a glue-code generator for SpiderMonkey. It is distributed
-under the conditions of version 3 of the GNU General Public License.
-Please have a look at <A HREF="http://jsapigen.sourceforge.net.">http://jsapigen.sourceforge.net.</A>
-
-This file is NOT part of jsapigen and is NOT necessarily covered by
-jsapigen's license. For licensing information regarding this file,
-please refer to the software package which it is part of.
-
-*/
-
-#include &quot;stdio.h&quot;
-#include &quot;ADM_jsEditor.h&quot;
-void jsEditor(void)
-{
-        printf(&quot;Constructor invoked\n&quot;);
-}
-
-#ifdef HAVE_ALLOCA_H
-#include &lt;alloca.h&gt;
-static size_t jj_alloca_limit = 0;
-#endif
-#include &lt;stdlib.h&gt;
-#include &lt;string.h&gt;
-#include &lt;wchar.h&gt;
-#ifdef HAVE_ALLOCA_H
-#endif
-#include &lt;jsapi.h&gt;
-#ifndef JS_THREADSAFE
-#if JS_VERSION &lt;= 170
-#define jsrefcount int
-#define JS_BeginRequest(cx)
-#define JS_EndRequest(cx)
-#define JS_SuspendRequest(cx)
-#define JS_ResumeRequest(cx, saveDepth)
-#endif
-#endif
-#ifndef JS_FS
-#define JS_FS(name, call, nargs, flags, extra) {name, call, nargs, flags, extra}
-#endif
-#ifndef JS_FS_END
-#define JS_FS_END {NULL, NULL, 0, 0, 0}
-#endif
-
-static JSBool
-jjeditorprintTiming(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
-{
-    JSObject * var2;
-    int var3;
-    int var6;
-    int var7;
-    int var8;
-    jsval var9;
-    int32 var10;
-    jsval var11;
-    JSBool var1;
-    var2 = NULL;
-    var3 = 0;
-    var6 = 0;
-    var7 = 0;
-    var8 = 0;
-    var9 = JSVAL_NULL;
-    var10 = 0;
-    var11 = JSVAL_NULL;
-    var1 = JS_FALSE;
-    var2 = obj;
-    var6 = argc;
-    var8 = 0;
-    var8 = var8 &lt; var6;
-    if (var8) {
-    var9 = argv[0];
-    if (JS_ValueToInt32(cx, var9, &amp;var10) != JS_TRUE) {
-        goto do_return;
-    }
-    var7 = (int)var10;
-    }
-    var3 = jsPrintTiming(var7);
-    if (JS_NewNumberValue(cx, var3, &amp;var11) != JS_TRUE) {
-        goto do_return;
-    }
-    argv[argc+0] = var11;
-    if (rval) {
-        *rval = var11;
-    }
-    var1 = JS_TRUE;
-    do_return:
-    return var1;
-}
-static JSBool
-jjeditordumpSegment(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
-{
-    JSObject * var13;
-    int var14;
-    int var17;
-    jsval var18;
-    JSBool var12;
-    var13 = NULL;
-    var14 = 0;
-    var17 = 0;
-    var18 = JSVAL_NULL;
-    var12 = JS_FALSE;
-    var13 = obj;
-    var17 = argc;
-    var14 = jsDumpSegments();
-    if (JS_NewNumberValue(cx, var14, &amp;var18) != JS_TRUE) {
-        goto do_return;
-    }
-    argv[argc+0] = var18;
-    if (rval) {
-        *rval = var18;
-    }
-    var12 = JS_TRUE;
-    do_return:
-    return var12;
-}
-static JSBool
-jjeditordumpRefVideo(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
-{
-    JSObject * var20;
-    int var21;
-    int var24;
-    jsval var25;
-    JSBool var19;
-    var20 = NULL;
-    var21 = 0;
-    var24 = 0;
-    var25 = JSVAL_NULL;
-    var19 = JS_FALSE;
-    var20 = obj;
-    var24 = argc;
-    var21 = jsDumpRefVideos();
-    if (JS_NewNumberValue(cx, var21, &amp;var25) != JS_TRUE) {
-        goto do_return;
-    }
-    argv[argc+0] = var25;
-    if (rval) {
-        *rval = var25;
-    }
-    var19 = JS_TRUE;
-    do_return:
-    return var19;
-}
-static JSBool
-jjeditor__construct__(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
-{
-    JSObject * var27;
-    int var31;
-    JSBool var26;
-    var27 = NULL;
-    var31 = 0;
-    var26 = JS_FALSE;
-    var27 = obj;
-    var31 = argc;
-    jsEditor();
-    var26 = JS_TRUE;
-    return var26;
-}
-static JSPropertySpec jj_static_ps[] = {
-    {NULL, 0, 0, NULL, NULL}
-};
-static JSPropertySpec jj_ps[] = {
-    {NULL, 0, 0, NULL, NULL}
-};
-static JSFunctionSpec jj_static_fs[] = {
-    JS_FS_END
-};
-static JSFunctionSpec jj_fs[] = {
-    JS_FS_END
-};
-static JSPropertySpec jjeditor_static_ps[] = {
-    {NULL, 0, 0, NULL, NULL}
-};
-static JSPropertySpec jjeditor_ps[] = {
-    {NULL, 0, 0, NULL, NULL}
-};
-static JSFunctionSpec jjeditor_static_fs[] = {
-    JS_FS(&quot;printTiming&quot;, jjeditorprintTiming, 1, 0, 1),
-    JS_FS(&quot;dumpSegment&quot;, jjeditordumpSegment, 0, 0, 1),
-    JS_FS(&quot;dumpRefVideo&quot;, jjeditordumpRefVideo, 0, 0, 1),
-    JS_FS_END
-};
-static JSFunctionSpec jjeditor_fs[] = {
-    JS_FS_END
-};
-static JSClass jjeditor_class = {
-    &quot;editor&quot;,
-    0,
-    JS_PropertyStub,
-    JS_PropertyStub,
-    JS_PropertyStub,
-    JS_PropertyStub,
-    JS_EnumerateStub,
-    JS_ResolveStub,
-    JS_ConvertStub,
-    JS_FinalizeStub,
-    NULL,
-    NULL,
-    NULL,
-    jjeditor__construct__,
-    NULL,
-    NULL,
-    NULL,
-    NULL
-};
-static JSObject *
-jjeditor_init(JSContext *cx, JSObject *obj)
-{
-    JSObject *parent_proto, *proto;
-    JSClass *class;
-    if (!cx || !obj) {
-        JS_ReportError(cx, &quot;invalid parameter&quot;);
-        return NULL;
-    }
-    if (!JS_EnterLocalRootScope(cx)) {
-        JS_ReportError(cx, &quot;JS_EnterLocalRootScope failed&quot;);
-        return NULL;
-    }
-    parent_proto = NULL;
-    proto = NULL;
-    parent_proto = JS_NewObject(cx, NULL, NULL, NULL);
-    if (!parent_proto) {
-        JS_LeaveLocalRootScope(cx);
-        JS_ReportError(cx, &quot;failed to create prototype&quot;);
-        return NULL;
-    }
-    class = &amp;jjeditor_class;
-    proto = JS_InitClass(cx, obj, parent_proto, class, jjeditor__construct__, 0, jjeditor_ps, jjeditor_fs, jjeditor_static_ps, jjeditor_static_fs);
-    if (!proto) {
-        JS_LeaveLocalRootScope(cx);
-        JS_ReportError(cx, &quot;failed to init class&quot;);
-        return NULL;
-    }
-    JS_LeaveLocalRootScope(cx);
-    return proto;
-}
-
-
-JSObject *jsEditorInit(JSContext *cx,JSObject *obj)
-{
-          if (JS_DefineFunctions(cx, obj, jj_static_fs) != JS_TRUE) 
-          {
-                return NULL;
-          }
-          return jjeditor_init(cx,obj);
-}
-
-JSFunctionSpec  *jsGetEditFunctions(void)
-{
-        return jjeditor_static_fs;
-}
-
-

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsEditor_js.idl
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsEditor_js.idl	2010-05-20 15:22:49 UTC (rev 6206)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsEditor_js.idl	2010-05-20 15:22:52 UTC (rev 6207)
@@ -1,37 +0,0 @@
-%{
-#include &quot;stdio.h&quot;
-#include &quot;ADM_jsEditor.h&quot;
-void jsEditor(void)
-{
-        printf(&quot;Constructor invoked\n&quot;);
-}
-%}
-        /*            JSFUNC      C FUNC  PARAM     */
-class editor
-{
-        /*            JSFUNC                 C FUNC           PARAM     */
-        function int printTiming     : jsPrintTiming(int ) &lt;static&gt;;
-        function int dumpSegment     : jsDumpSegments()    &lt;static&gt;;
-        function int dumpRefVideo    : jsDumpRefVideos()   &lt;static&gt;;
-        /*            JSFUNC                 C FUNC           PARAM     */
-        
-        construct                          : jsEditor  ( ) &lt;static&gt;     ; 
-};
-
-%&lt;
-
-JSObject *jsEditorInit(JSContext *cx,JSObject *obj)
-{
-          if (JS_DefineFunctions(cx, obj, jj_static_fs) != JS_TRUE) 
-          {
-                return NULL;
-          }
-          return jjeditor_init(cx,obj);
-}
-
-JSFunctionSpec  *jsGetEditFunctions(void)
-{
-        return jjeditor_static_fs;
-}
-
-%&gt;

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsIf.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsIf.cpp	2010-05-20 15:22:49 UTC (rev 6206)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsIf.cpp	2010-05-20 15:22:52 UTC (rev 6207)
@@ -1,350 +0,0 @@
-/**
-    \file ADM_JSif.cpp
-    \brief interface to js
-*/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-#include &quot;ADM_js.h&quot;
-#include &lt;stdarg.h&gt;
-#include &lt;vector&gt;
-#include &quot;ADM_editor/ADM_edit.hxx&quot;
-void    A_Resync(void);
-
-/* our variables */
-static jsLoggerFunc *jsLogger=NULL;
-static void *jsLoggerCookie=NULL;
-vector &lt;ADM_JS_HOOK &gt;jsHooks;
-extern ADM_Composer *video_body;
-extern bool ADM_JSDialogFactoryInit(JSContext *cx, JSObject *obj);
-#define JSVAR(a,b,c) a b=c
-
-#if defined( __MINGW32__) 
- pthread_t g_pThreadSpidermonkey ;
-#else
-JSVAR( pthread_t, g_pThreadSpidermonkey , 0);
-#endif
-JSVAR( pthread_mutex_t, g_pSpiderMonkeyMutex , PTHREAD_MUTEX_INITIALIZER);
-// expose our main javascript context to the entire program
-static bool g_bJSSuccess=false;
-static JSObject   *g_pObject=NULL;
-static JSContext  *g_pCx=NULL;
-static JSRuntime  *g_pRt=NULL;
-
-static JSClass global_class = {
-            &quot;global&quot;, JSCLASS_GLOBAL_FLAGS,
-            JS_PropertyStub, JS_PropertyStub, JS_PropertyStub, JS_PropertyStub,
-            JS_EnumerateStub, JS_ResolveStub, JS_ConvertStub, JS_FinalizeStub,
-            JSCLASS_NO_OPTIONAL_MEMBERS
-            };
-
-extern void  printJSError(JSContext *cx, const char *message, JSErrorReport *report);
-/**
-    \fn parseECMAScript
-    \brief Compile &amp; execute ecma script
-*/
-bool parseECMAScript(const char *name)
-{// begin parseECMAScript
-	jsval rval;
-	uintN lineno = 0;
-	g_bJSSuccess = 0;
-	ADM_info(&quot;Spidermonkey compiling \&quot;%s\&quot;...&quot;,name);
-	JSScript *pJSScript = JS_CompileFile(g_pCx, g_pObject, name);
-	ADM_info(&quot;Done.\n&quot;);
-	if(pJSScript != NULL)
-	{// begin execute external file
-		printf(&quot;Spidermonkey executing \&quot;%s\&quot;...\n&quot;,name);
-		JSBool ok = JS_ExecuteScript(g_pCx, g_pObject, pJSScript, &amp;rval);
-		JS_DestroyScript(g_pCx,pJSScript);
-		ADM_info(&quot;Done.\n&quot;);
-	}// end execute external file
-        // Run garbage collector now, it is safe
-    JS_GC(g_pCx);
-	A_Resync();
-	return g_bJSSuccess;
-}// end parseECMAScript
-/**
-    \fn jsLogger
-*/
-bool isJsLogRedirected(void)
-{
-    if(jsLogger) return true;
-    return false;
-}
-/**
-    \fn jsEvaluate
-*/
-static bool jsEvaluate(const char *str)
-{
-jsval rval;
-   JS_EvaluateScript(g_pCx,g_pObject,str,strlen(str),&quot;dummy&quot;,1,&amp;rval);
-   return true; 
-}
-/**
-    \fn    interactiveECMAScript
-    \brief interprete &amp; execute ecma script (interactive)
-*/
-bool interactiveECMAScript(const char *name)
-{
-    ADM_startShell(jsEvaluate);
-    JS_GC(g_pCx);
-	A_Resync();
-    ADM_info(&quot;Ending JS shell...\n&quot;);
-	return true;
-}
-/**
-    \fn jsLog
-*/
-bool jsLog(JS_LOG_TYPE type, const char *prf,...)
-{
- static char print_buffer[1024];
-  	
-		va_list 	list;
-		va_start(list,	prf);
-		vsnprintf(print_buffer,1023,prf,list);
-		va_end(list);
-		print_buffer[1023]=0; // ensure the string is terminated
-        if(true==isJsLogRedirected())
-            jsLogger(jsLoggerCookie,type,print_buffer);
-        else
-        {
-            if(type==JS_LOG_ERROR)
-                GUI_Error_HIG(&quot;Spidermonkey ECMAScript Error&quot;,&quot;%s&quot;,print_buffer);
-            else
-                ADM_warning(&quot;[JS]%s\n&quot;,print_buffer);
-        }
-
-        return true;
-}
-
-/**
-    \fn ADM_jsRegisterLogger
-*/
-bool ADM_jsRegisterLogger(void *cookie,jsLoggerFunc *fun)
-{
-    jsLoggerCookie=cookie;
-    jsLogger=fun;
-    return true;
-}
-/**
-    \fn ADM_jsUnregisterLogger
-*/
-bool ADM_jsUnregisterLogger(void)
-{
-    jsLogger=NULL;
-    return true;
-}
-/**
-    \fn jsRegisterAvidemux
-*/
-extern &quot;C&quot; JSFunctionSpec  *jsGetIfFunctions(void);
-extern &quot;C&quot; JSFunctionSpec  *jsGetTestFunctions(void);
-extern &quot;C&quot; JSFunctionSpec  *jsGetAdmFunctions(void);
-extern &quot;C&quot; JSFunctionSpec  *jsGetEditFunctions(void);
-extern &quot;C&quot; JSFunctionSpec  *jsGetDialogFactoryFunctions(void);
-extern &quot;C&quot; JSObject *jsEditorInit(JSContext *cx,JSObject *obj);
-extern &quot;C&quot; JSObject *jsAvidemuxInit(JSContext *cx,JSObject *obj);
-static bool registerOne(const char *name,const char *text,JSFunctionSpec *s,JSContext *cx,JSObject *obj)
-{
-    if (JS_DefineFunctions(cx, obj, s) != JS_TRUE) 
-    {
-            ADM_error(&quot;Cannot register %s functions\n&quot;,name);
-            return false;
-    }
-    ADM_info(&quot;Registered %s functions\n&quot;,name);
-    ADM_JS_HOOK h;
-    h.name=name;    
-    h.text=text;
-    h.jsFunctions=s;
-    jsHooks.push_back(h);
-    return true;
-}
-static void  dump(JSFunctionSpec *f)
-{
-    while(f-&gt;name)
-    {
-        jsLog(JS_LOG_NORMAL,&quot;    %s&quot;,f-&gt;name);
-        f++;
-    }
-}
-/**
-    \fn jsHelp
-    \brief help command
-
-*/
-extern &quot;C&quot; 
-{
-void jsHelp(const char *s)
-{
-int n=jsHooks.size();
-    if(!s) goto none;
-    {
-    for(int i=0;i&lt;n;i++)
-        if(!strcasecmp(s,jsHooks[i].name))
-        {
-            const char *t=jsHooks[i].text;
-            if(t)
-                jsLog(JS_LOG_NORMAL,&quot;%s&quot;,t);
-            return dump(jsHooks[i].jsFunctions);
-        }
-    }
-//    if(!strcasecmp(s,&quot;load&quot;)) return dump(jsGetAvidemuxFunctions());
-none:
-        jsLog(JS_LOG_NORMAL,&quot;please use help(\&quot;xxx\&quot;) with xx among&quot;);
-
-        for(int i=0;i&lt;n;i++)
-            jsLog(JS_LOG_NORMAL,&quot;    %s&quot;,jsHooks[i].name);
-
-}
-} // extern &quot;C&quot;
-/**
-    \fn jsRegisterAvidemux
-    \brief Register avidemux hookd
-*/
-static bool jsRegisterAvidemux(JSContext *cx,JSObject *obj)
-{
-ADM_JS_HOOK h;
-        registerOne(&quot;Debug&quot;,&quot;&quot;,   jsGetIfFunctions(),    cx,obj);
-        registerOne(&quot;Test&quot;,&quot;&quot;, jsGetTestFunctions(),  cx,obj);
-        
-        // Register also our class (for  help() )
-            h.name=&quot;adm&quot;;
-            h.text=&quot;Please prefix this with adm.&quot;;
-            h.jsFunctions=jsGetAdmFunctions();
-            jsHooks.push_back(h);
-            jsAvidemuxInit(cx,obj);
-        // Register also edit
-            h.name=&quot;editor&quot;;
-            h.text=&quot;Please prefix this with editor.&quot;;
-            h.jsFunctions=jsGetEditFunctions();
-            jsEditorInit(cx,obj);
-            jsHooks.push_back(h);
-        // Register dialogFactory functions
-#if 0
-            h.name=&quot;dialog&quot;;
-            h.text=&quot;.&quot;;
-            h.jsFunctions=jsGetDialogFactoryFunctions();
-            jsHooks.push_back(h);
-#endif
-            return ADM_JSDialogFactoryInit(cx,obj);
-}
-/**
-    \fn SpidermonkeyInit
-*/
-bool SpidermonkeyInit()
-{// begin SpidermonkeyInit
-	// setup JS
-	g_pCx = NULL;
-	g_pObject = NULL;
-	g_pRt = NULL;
-	JSRuntime *rt = JS_NewRuntime(1000000L);
-	g_pRt = rt;
-	if ( !rt  )
-	{
-		// Do some error reporting
-		ADM_error(&quot;Spidermonkey failed to initialize runtime!\n&quot;);
-        return false;
-	}
-	
-// begin runtime created
-    g_pCx = JS_NewContext(rt, 8192);
-    if ( !g_pCx  )
-    {
-        // Do some error reporting
-        ADM_error(&quot;Spidermonkey failed to initialize context!\n&quot;);
-        return false;
-    }
-   
-   // begin context created
-    g_pObject = JS_NewObject(g_pCx, &amp;global_class, 0, 0);
-    if(!g_pObject)
-    {
-        ADM_error(&quot;Cannot initialize object\n&quot;);
-        return false;
-    }
-    if(JS_TRUE!=JS_InitStandardClasses(g_pCx, g_pObject))
-    {
-        ADM_error(&quot;Cannot initialize standard classes\n&quot;);
-        return false;
-    }
-    // register error handler
-    JS_SetErrorReporter(g_pCx, printJSError);
-        
-    //register our functions
-    jsRegisterAvidemux(g_pCx,g_pObject);
-    ADM_info(&quot;Spidermonkey initialized\n&quot;);
-    return true;
-
-}// end SpidermonkeyInit
-/**
-    \fn SpidermonkeyDestroy
-*/
-void SpidermonkeyDestroy()
-{// begin SpidermonkeyDestroy
-#ifdef ADM_JS_THREADSAFE
-	JS_SetContextThread(g_pCx);	
-#endif
-	JS_DestroyContext(g_pCx);
-	JS_DestroyRuntime(g_pRt);
-}// end SpidermonkeyDestroy
-/**
-    \fn StartThreadSpidermonkey
-*/
-void *StartThreadSpidermonkey(void *pData)
-{// begin StartThreadSpidermonkey
-        pthread_mutex_lock(&amp;g_pSpiderMonkeyMutex);
-        /*
-        The following mailling list post describes how to CORRECTLY use
-        the threading API support with Spidermonkey
-        &quot;Thread from SpiderMonkey newsgroup&quot;
-        <A HREF="http://archive.gingerall.cz/archives/public/sablot2004/msg00117.html">http://archive.gingerall.cz/archives/public/sablot2004/msg00117.html</A>
-        */
-        // Notify the Spidermonkey that we'll be processing in a thread
-#ifdef ADM_JS_THREADSAFE
-        JS_SetContextThread(g_pCx);
-        JS_BeginRequest(g_pCx);
-#endif
-        bool ret = false;
-        const char *pScriptFile = static_cast&lt;const char *&gt;(pData);
-        ret = parseECMAScript(pScriptFile);
-        if(ret == true)
-        {
-                video_body-&gt;setProjectName(pScriptFile);
-        }
-        // Notify Spidermonkey that our thread processing has finished
-#ifdef ADM_JS_THREADSAFE
-        JS_EndRequest(g_pCx);
-        JS_ClearContextThread(g_pCx);
-#endif
-        pthread_mutex_unlock(&amp;g_pSpiderMonkeyMutex);
-
-        return NULL;
-}// end StartThreadSpidermonkey
-/**
-    \fn JS_setSuccess
-*/
-extern &quot;C&quot; void jsSetSuccess(int bSuccess)
-{// begin JS_setSuccess
-	g_bJSSuccess = bSuccess;
-	jsLog(JS_LOG_NORMAL,&quot;[ECMA] success : %d\n&quot;, g_bJSSuccess);
-}// end JS_setSuccess
-/**
-    \fn SpidermonkeyExit
-*/
-bool SpidermonkeyExit(void)
-{
-    ADM_info(&quot;Waiting for Spidermonkey to finish...\n&quot;);
-    pthread_mutex_lock(&amp;g_pSpiderMonkeyMutex);
-    ADM_info(&quot;Cleaning up Spidermonkey.\n&quot;);
-    SpidermonkeyDestroy();
-    pthread_mutex_unlock(&amp;g_pSpiderMonkeyMutex);
-    return true;
-}
-//EOF

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsIf_js.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsIf_js.c	2010-05-20 15:22:49 UTC (rev 6206)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsIf_js.c	2010-05-20 15:22:52 UTC (rev 6207)
@@ -1,504 +0,0 @@
-/*
---- DO NOT EDIT THIS FILE !!! ---
-
-This file has been generated automatically with 'jsapigen'.
-
-jsapigen is a glue-code generator for SpiderMonkey. It is distributed
-under the conditions of version 3 of the GNU General Public License.
-Please have a look at <A HREF="http://jsapigen.sourceforge.net.">http://jsapigen.sourceforge.net.</A>
-
-This file is NOT part of jsapigen and is NOT necessarily covered by
-jsapigen's license. For licensing information regarding this file,
-please refer to the software package which it is part of.
-
-*/
-
-#include &quot;stdio.h&quot;
-#include &quot;ADM_jsAvidemux.h&quot;
-#include &quot;ADM_jsDebug.h&quot;
-
-#ifdef HAVE_ALLOCA_H
-#include &lt;alloca.h&gt;
-static size_t jj_alloca_limit = 0;
-#endif
-#include &lt;stdlib.h&gt;
-#include &lt;string.h&gt;
-#include &lt;wchar.h&gt;
-#ifdef HAVE_ALLOCA_H
-#endif
-#include &lt;jsapi.h&gt;
-#ifndef JS_THREADSAFE
-#if JS_VERSION &lt;= 170
-#define jsrefcount int
-#define JS_BeginRequest(cx)
-#define JS_EndRequest(cx)
-#define JS_SuspendRequest(cx)
-#define JS_ResumeRequest(cx, saveDepth)
-#endif
-#endif
-#ifndef JS_FS
-#define JS_FS(name, call, nargs, flags, extra) {name, call, nargs, flags, extra}
-#endif
-#ifndef JS_FS_END
-#define JS_FS_END {NULL, NULL, 0, 0, 0}
-#endif
-
-static JSBool
-jjadmPopupError(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
-{
-    JSObject * var2;
-    int var6;
-    char * var7;
-    int var8;
-    jsval var9;
-    JSString * var10;
-    jsval var86;
-    size_t var11;
-    size_t var12;
-    int var14;
-    jschar * var15;
-    jsval var87;
-    JSBool var1;
-    var2 = NULL;
-    var6 = 0;
-    var7 = NULL;
-    var8 = 0;
-    var9 = JSVAL_NULL;
-    var10 = NULL;
-    var86 = JSVAL_NULL;
-    var11 = 0;
-    var12 = 0;
-    var14 = 0;
-    var15 = NULL;
-    var87 = JSVAL_NULL;
-    var1 = JS_FALSE;
-    var2 = obj;
-    var6 = argc;
-    var8 = 0;
-    var8 = var8 &lt; var6;
-    if (var8) {
-    var9 = argv[0];
-    var10 = JS_ValueToString(cx, var9);
-    if (!var10) {
-        goto do_return;
-    }
-    var86 = STRING_TO_JSVAL(var10);
-    argv[argc+0] = var86;
-    var11 = JS_GetStringLength(var10);
-    var12 = 1;
-    var12 += var11;
-#ifdef HAVE_ALLOCA
-    if (var12 &lt; jj_alloca_limit) {
-        var7 = alloca(var12);
-    } else {
-#endif
-        var7 = malloc(var12);
-        if (!var7) {
-            goto do_return;
-        } else {
-            var14 = 1;
-        }
-#ifdef HAVE_ALLOCA
-    }
-#endif
-    var15 = JS_GetStringChars(var10);
-    var87 = STRING_TO_JSVAL(var10);
-    argv[argc+1] = var87;
-    {
-        size_t i;
-        for (i = 0; i &lt; var11; ++i) {
-            var7[i] = var15[i];
-        }
-        var7[var11] = '\0';
-    }
-    }
-    jsPopupError(var7);
-    var1 = JS_TRUE;
-    do_return:
-    if (var14) {
-        free(var7);
-        var7 = NULL;
-        var14 = 0;
-    }
-    return var1;
-}
-static JSBool
-jjadmpPopupInfo(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
-{
-    JSObject * var17;
-    int var21;
-    char * var22;
-    int var23;
-    jsval var24;
-    JSString * var25;
-    jsval var88;
-    size_t var26;
-    size_t var27;
-    int var29;
-    jschar * var30;
-    jsval var89;
-    JSBool var16;
-    var17 = NULL;
-    var21 = 0;
-    var22 = NULL;
-    var23 = 0;
-    var24 = JSVAL_NULL;
-    var25 = NULL;
-    var88 = JSVAL_NULL;
-    var26 = 0;
-    var27 = 0;
-    var29 = 0;
-    var30 = NULL;
-    var89 = JSVAL_NULL;
-    var16 = JS_FALSE;
-    var17 = obj;
-    var21 = argc;
-    var23 = 0;
-    var23 = var23 &lt; var21;
-    if (var23) {
-    var24 = argv[0];
-    var25 = JS_ValueToString(cx, var24);
-    if (!var25) {
-        goto do_return;
-    }
-    var88 = STRING_TO_JSVAL(var25);
-    argv[argc+0] = var88;
-    var26 = JS_GetStringLength(var25);
-    var27 = 1;
-    var27 += var26;
-#ifdef HAVE_ALLOCA
-    if (var27 &lt; jj_alloca_limit) {
-        var22 = alloca(var27);
-    } else {
-#endif
-        var22 = malloc(var27);
-        if (!var22) {
-            goto do_return;
-        } else {
-            var29 = 1;
-        }
-#ifdef HAVE_ALLOCA
-    }
-#endif
-    var30 = JS_GetStringChars(var25);
-    var89 = STRING_TO_JSVAL(var25);
-    argv[argc+1] = var89;
-    {
-        size_t i;
-        for (i = 0; i &lt; var26; ++i) {
-            var22[i] = var30[i];
-        }
-        var22[var26] = '\0';
-    }
-    }
-    jsPopupInfo(var22);
-    var16 = JS_TRUE;
-    do_return:
-    if (var29) {
-        free(var22);
-        var22 = NULL;
-        var29 = 0;
-    }
-    return var16;
-}
-static JSBool
-jjadmPrint(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
-{
-    JSObject * var32;
-    int var36;
-    char * var37;
-    int var38;
-    jsval var39;
-    JSString * var40;
-    jsval var90;
-    size_t var41;
-    size_t var42;
-    int var44;
-    jschar * var45;
-    jsval var91;
-    JSBool var31;
-    var32 = NULL;
-    var36 = 0;
-    var37 = NULL;
-    var38 = 0;
-    var39 = JSVAL_NULL;
-    var40 = NULL;
-    var90 = JSVAL_NULL;
-    var41 = 0;
-    var42 = 0;
-    var44 = 0;
-    var45 = NULL;
-    var91 = JSVAL_NULL;
-    var31 = JS_FALSE;
-    var32 = obj;
-    var36 = argc;
-    var38 = 0;
-    var38 = var38 &lt; var36;
-    if (var38) {
-    var39 = argv[0];
-    var40 = JS_ValueToString(cx, var39);
-    if (!var40) {
-        goto do_return;
-    }
-    var90 = STRING_TO_JSVAL(var40);
-    argv[argc+0] = var90;
-    var41 = JS_GetStringLength(var40);
-    var42 = 1;
-    var42 += var41;
-#ifdef HAVE_ALLOCA
-    if (var42 &lt; jj_alloca_limit) {
-        var37 = alloca(var42);
-    } else {
-#endif
-        var37 = malloc(var42);
-        if (!var37) {
-            goto do_return;
-        } else {
-            var44 = 1;
-        }
-#ifdef HAVE_ALLOCA
-    }
-#endif
-    var45 = JS_GetStringChars(var40);
-    var91 = STRING_TO_JSVAL(var40);
-    argv[argc+1] = var91;
-    {
-        size_t i;
-        for (i = 0; i &lt; var41; ++i) {
-            var37[i] = var45[i];
-        }
-        var37[var41] = '\0';
-    }
-    }
-    jsPrint(var37);
-    var31 = JS_TRUE;
-    do_return:
-    if (var44) {
-        free(var37);
-        var37 = NULL;
-        var44 = 0;
-    }
-    return var31;
-}
-static JSBool
-jjprint(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
-{
-    JSObject * var47;
-    int var51;
-    char * var52;
-    int var53;
-    jsval var54;
-    JSString * var55;
-    jsval var92;
-    size_t var56;
-    size_t var57;
-    int var59;
-    jschar * var60;
-    jsval var93;
-    JSBool var46;
-    var47 = NULL;
-    var51 = 0;
-    var52 = NULL;
-    var53 = 0;
-    var54 = JSVAL_NULL;
-    var55 = NULL;
-    var92 = JSVAL_NULL;
-    var56 = 0;
-    var57 = 0;
-    var59 = 0;
-    var60 = NULL;
-    var93 = JSVAL_NULL;
-    var46 = JS_FALSE;
-    var47 = obj;
-    var51 = argc;
-    var53 = 0;
-    var53 = var53 &lt; var51;
-    if (var53) {
-    var54 = argv[0];
-    var55 = JS_ValueToString(cx, var54);
-    if (!var55) {
-        goto do_return;
-    }
-    var92 = STRING_TO_JSVAL(var55);
-    argv[argc+0] = var92;
-    var56 = JS_GetStringLength(var55);
-    var57 = 1;
-    var57 += var56;
-#ifdef HAVE_ALLOCA
-    if (var57 &lt; jj_alloca_limit) {
-        var52 = alloca(var57);
-    } else {
-#endif
-        var52 = malloc(var57);
-        if (!var52) {
-            goto do_return;
-        } else {
-            var59 = 1;
-        }
-#ifdef HAVE_ALLOCA
-    }
-#endif
-    var60 = JS_GetStringChars(var55);
-    var93 = STRING_TO_JSVAL(var55);
-    argv[argc+1] = var93;
-    {
-        size_t i;
-        for (i = 0; i &lt; var56; ++i) {
-            var52[i] = var60[i];
-        }
-        var52[var56] = '\0';
-    }
-    }
-    jsPrint2(var52);
-    var46 = JS_TRUE;
-    do_return:
-    if (var59) {
-        free(var52);
-        var52 = NULL;
-        var59 = 0;
-    }
-    return var46;
-}
-static JSBool
-jjhelp(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
-{
-    JSObject * var62;
-    int var66;
-    char * var67;
-    int var68;
-    jsval var69;
-    JSString * var70;
-    jsval var94;
-    size_t var71;
-    size_t var72;
-    int var74;
-    jschar * var75;
-    jsval var95;
-    JSBool var61;
-    var62 = NULL;
-    var66 = 0;
-    var67 = NULL;
-    var68 = 0;
-    var69 = JSVAL_NULL;
-    var70 = NULL;
-    var94 = JSVAL_NULL;
-    var71 = 0;
-    var72 = 0;
-    var74 = 0;
-    var75 = NULL;
-    var95 = JSVAL_NULL;
-    var61 = JS_FALSE;
-    var62 = obj;
-    var66 = argc;
-    var68 = 0;
-    var68 = var68 &lt; var66;
-    if (var68) {
-    var69 = argv[0];
-    var70 = JS_ValueToString(cx, var69);
-    if (!var70) {
-        goto do_return;
-    }
-    var94 = STRING_TO_JSVAL(var70);
-    argv[argc+0] = var94;
-    var71 = JS_GetStringLength(var70);
-    var72 = 1;
-    var72 += var71;
-#ifdef HAVE_ALLOCA
-    if (var72 &lt; jj_alloca_limit) {
-        var67 = alloca(var72);
-    } else {
-#endif
-        var67 = malloc(var72);
-        if (!var67) {
-            goto do_return;
-        } else {
-            var74 = 1;
-        }
-#ifdef HAVE_ALLOCA
-    }
-#endif
-    var75 = JS_GetStringChars(var70);
-    var95 = STRING_TO_JSVAL(var70);
-    argv[argc+1] = var95;
-    {
-        size_t i;
-        for (i = 0; i &lt; var71; ++i) {
-            var67[i] = var75[i];
-        }
-        var67[var71] = '\0';
-    }
-    }
-    jsHelp(var67);
-    var61 = JS_TRUE;
-    do_return:
-    if (var74) {
-        free(var67);
-        var67 = NULL;
-        var74 = 0;
-    }
-    return var61;
-}
-static JSBool
-jjsetSuccess(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
-{
-    JSObject * var77;
-    int var81;
-    int var82;
-    int var83;
-    jsval var84;
-    int32 var85;
-    JSBool var76;
-    var77 = NULL;
-    var81 = 0;
-    var82 = 0;
-    var83 = 0;
-    var84 = JSVAL_NULL;
-    var85 = 0;
-    var76 = JS_FALSE;
-    var77 = obj;
-    var81 = argc;
-    var83 = 0;
-    var83 = var83 &lt; var81;
-    if (var83) {
-    var84 = argv[0];
-    if (JS_ValueToInt32(cx, var84, &amp;var85) != JS_TRUE) {
-        goto do_return;
-    }
-    var82 = (int)var85;
-    }
-    jsSetSuccess(var82);
-    var76 = JS_TRUE;
-    do_return:
-    return var76;
-}
-static JSPropertySpec jj_static_ps[] = {
-    {NULL, 0, 0, NULL, NULL}
-};
-static JSPropertySpec jj_ps[] = {
-    {NULL, 0, 0, NULL, NULL}
-};
-static JSFunctionSpec jj_static_fs[] = {
-    JS_FS(&quot;admPopupError&quot;, jjadmPopupError, 1, 0, 2),
-    JS_FS(&quot;admpPopupInfo&quot;, jjadmpPopupInfo, 1, 0, 2),
-    JS_FS(&quot;admPrint&quot;, jjadmPrint, 1, 0, 2),
-    JS_FS(&quot;print&quot;, jjprint, 1, 0, 2),
-    JS_FS(&quot;help&quot;, jjhelp, 1, 0, 2),
-    JS_FS(&quot;setSuccess&quot;, jjsetSuccess, 1, 0, 0),
-    JS_FS_END
-};
-static JSFunctionSpec jj_fs[] = {
-    JS_FS(&quot;admPopupError&quot;, jjadmPopupError, 1, 0, 2),
-    JS_FS(&quot;admpPopupInfo&quot;, jjadmpPopupInfo, 1, 0, 2),
-    JS_FS(&quot;admPrint&quot;, jjadmPrint, 1, 0, 2),
-    JS_FS(&quot;print&quot;, jjprint, 1, 0, 2),
-    JS_FS(&quot;help&quot;, jjhelp, 1, 0, 2),
-    JS_FS(&quot;setSuccess&quot;, jjsetSuccess, 1, 0, 0),
-    JS_FS_END
-};
-
-JSFunctionSpec  *jsGetIfFunctions(void)
-{
-        return jj_static_fs;
-}
-
-

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsIf_js.idl
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsIf_js.idl	2010-05-20 15:22:49 UTC (rev 6206)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsIf_js.idl	2010-05-20 15:22:52 UTC (rev 6207)
@@ -1,25 +0,0 @@
-%{
-#include &quot;stdio.h&quot;
-#include &quot;ADM_jsAvidemux.h&quot;
-#include &quot;ADM_jsDebug.h&quot;
-%}
-
-/*
-###############################################################
-       return JS function     CM Function  params
-###############################################################
-*/
-function void admPopupError : jsPopupError   (cstring  ) &lt;static&gt;;
-function void admpPopupInfo : jsPopupInfo    (cstring  ) &lt;static&gt;;
-function void admPrint      : jsPrint        (cstring  ) &lt;static&gt;;
-function void print         : jsPrint2       (cstring  ) &lt;static&gt;;
-function void help          : jsHelp         (cstring  ) &lt;static&gt;;
-function void setSuccess    : jsSetSuccess   (int  )   &lt;static&gt;;
-
-%&lt;
-JSFunctionSpec  *jsGetIfFunctions(void)
-{
-        return jj_static_fs;
-}
-
-%&gt;

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsTestFactory.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsTestFactory.cpp	2010-05-20 15:22:49 UTC (rev 6206)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsTestFactory.cpp	2010-05-20 15:22:52 UTC (rev 6207)
@@ -1,444 +0,0 @@
-/**
-    \file ADM_JSif.cpp
-    \brief interface to js
-
- Author: Anish Mistry/mean/gruntster
-*/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#include &quot;ADM_js.h&quot;
-#include &quot;ADM_editor/ADM_edit.hxx&quot;
-#include &quot;DIA_fileSel.h&quot;
-#include &quot;DIA_factory.h&quot;
-#include &quot;ADM_jsTestFactory.h&quot;
-#include &quot;DIA_encoding.h&quot;
-
-/**
-    \fn crashTest
-    \brief Force a crash
-*/
-int jsTestCrash(void)
-{
-  
-  int *foobar=NULL;
-  *foobar=0; // CRASH!
-  return true;
-}
-/**
-    \fn assertTest
-    \brief Force a crash
-*/
-int jsTestAssert(void)
-{
-  
-  ADM_assert(0);
-  return true;
-}
-
-
-/**
-    \fn jsTestFacInt
-*/
-int jsTestFacInt(void)
-{
-  uint32_t tog=0;
-   diaElemUInteger blend(&amp;tog,QT_TR_NOOP(&quot;Uinteger&quot;),0,255);
-    diaElem *elems[]={&amp;blend   };
-    
-  if(diaFactoryRun(QT_TR_NOOP(&quot;Test uinteger&quot;),1,elems))
-  {
-    jsLog(JS_LOG_NORMAL,&quot;Value : %u\n&quot;,tog);
-    return true;
-  }
-  return false;
-}
-
-/**
-    \fn jsTestFacFloat
-*/
-int jsTestFacFloat(void)
-{
-  ELEM_TYPE_FLOAT tog=0;
-   diaElemFloat blend(&amp;tog,QT_TR_NOOP(&quot;Float&quot;),0,255);
-    diaElem *elems[]={&amp;blend   };
-    
-  if(diaFactoryRun(&quot;Test float&quot;,1,elems))
-  {
-    jsLog(JS_LOG_NORMAL,&quot;Value : %f\n&quot;,(float)tog);
-    return true;
-  }
-  return false;
-}
-
-/**
-    \fn jsTestFacToggle
-*/
-int jsTestFacToggle(void)
-{
-  uint32_t tog=0;
-  uint32_t test=0;
-   diaElemToggle blend(&amp;tog,QT_TR_NOOP(&quot;Toggle&quot;));
-    diaElemUInteger     bt(&amp;test,&quot;Entry&quot;,0,10);
-    diaElemUInteger     bt2(&amp;test,&quot;Entry&quot;,0,10);
-    diaElem *elems[]={&amp;blend,&amp;bt,&amp;bt2   };
-    blend.link(1,&amp;bt);
-    blend.link(0,&amp;bt2);
-    
-  if(diaFactoryRun(&quot;Test Toggle&quot;,3,elems))
-   {
-    jsLog(JS_LOG_NORMAL,&quot;Value : %u\n&quot;,tog);
-    return true;
-  }
-  return false;
-}
-
-/**
-    \fn jsTestFacMenu
-*/
-int jsTestFacMenu(void)
-{
-   uint32_t tog=4;
-   ELEM_TYPE_FLOAT f=1; 
-   
-    diaMenuEntry menu[]={
-                             {2,   QT_TR_NOOP(&quot;No Strategy&quot;),NULL},
-                             {4,     QT_TR_NOOP(&quot;3:2 Pulldown&quot;),NULL},
-                             {6,     QT_TR_NOOP(&quot;Pal/Secam&quot;),NULL},
-                             {7,  QT_TR_NOOP(&quot;NTSC converted from PAL&quot;),NULL}
-                          };
-   diaElemMenu blend(&amp;tog,QT_TR_NOOP(&quot;menu&quot;),4,menu);
-    
-    // Link it to another
-    diaElemFloat toggle(&amp;f,&quot;Linked float&quot;,1,2);
-    blend.link(&amp;(menu[1]),1,&amp;toggle);
-    //
-diaElem *elems[]={&amp;blend,&amp;toggle   };
-  if(diaFactoryRun(&quot;Test Menu&quot;,2,elems))
-   {
-    jsLog(JS_LOG_NORMAL,&quot;Value : %&quot;LU&quot;\n&quot;,tog);
-    return true;
-  }
-  return false;
-}
-
-/**
-    \fn jsTestFacFile
-*/
-int jsTestFacFile(void)
-{
-   uint32_t tog=0;
-   char *test=ADM_strdup(&quot;Entry test1&quot;);
-    
-      diaElemFile fread(0,&amp;test,&quot;Entry&quot;);
-      diaElem *elems[]={&amp;fread   };
-  if(diaFactoryRun(&quot;Test FileRead&quot;,1,elems))
-   {
-    jsLog(JS_LOG_NORMAL,&quot;Value : %s\n&quot;,test);
-    if(test) ADM_dealloc(test);
-    return true;
-  }
- if(test) ADM_dealloc(test);
-  return false;
-}
-
-/**
-    \fn jsTestFacDirSel
-*/
-int jsTestFacDirSel(void)
-{
-   uint32_t tog=0;
-   char *test=ADM_strdup(&quot;Entry test1&quot;);
-    
-  diaElemDirSelect fread(&amp;test,&quot;Entry&quot;);
-  diaElem *elems[]={&amp;fread   };
-  if(diaFactoryRun(&quot;Test DirSel&quot;,1,elems))
-  {
-    jsLog(JS_LOG_NORMAL,&quot;Value : %s\n&quot;,test);
-    if(test) ADM_dealloc(test);
-    return true;
-  }
- if(test) ADM_dealloc(test);
-  return false;
-}
-
-/**
-    \fn jsTestFacBitrate
-*/
-int jsTestFacBitrate(void)
-{
-
-   COMPRES_PARAMS test={
-  COMPRESS_CQ,
-  1,
-  1500,
-  700,
-  1000,
-  ADM_ENC_CAP_CQ+ADM_ENC_CAP_2PASS+ADM_ENC_CAP_CBR+ADM_ENC_CAP_SAME
-  };
-    
-      diaElemBitrate bt(&amp;test,&quot;Entry&quot;);
-      diaElem *elems[]={&amp;bt   };
-  if(diaFactoryRun(&quot;Test BitRate&quot;,1,elems))
-   {
-    
-    return true;
-  }
-  return false;
-}
-
-/**
-    \fn jsTestFacInt
-*/
-int jsTestFacBar(void)
-{
-    
-      diaElemBar bar1(25,&quot;25&quot;);
-      diaElemBar bar2(65,&quot;65&quot;);
-      diaElem *elems[]={&amp;bar1,&amp;bar2   };
-  if(diaFactoryRun(&quot;Test FileRead&quot;,2,elems))
-  {
-   return true;
-  }
-  return false;
-}
-
-void clickMe(void *cookie)
-{
-  GUI_Error_HIG(&quot;Button&quot;,&quot;Button pressed!&quot;); 
-}
-
-/**
-    \fn jsTestFacButton
-*/
-int jsTestFacButton(void)
-{
-    
-      diaElemButton bar1(&quot;Button&quot;,clickMe,NULL);
-      diaElem *elems[]={&amp;bar1   };
-  if(diaFactoryRun(&quot;Test Button&quot;,1,elems))
-  {
-    return true;
-  }
-  return false;
-}
-
-/**
-    \fn jsTestFacSlider
-*/
-int jsTestFacSlider(void)
-{
-  int32_t val=4;
-      diaElemSlider slide(&amp;val,&quot;foo&quot;, 0,10);
-      
-      diaElem *elems[]={&amp;slide   };
-  if(diaFactoryRun(&quot;Test Slider&quot;,1,elems))
-  {
-    jsLog(JS_LOG_NORMAL,&quot;Value : %d\n&quot;,(int)val);
-    return true;
-  }
-  return false;
-}
-
-/**
-    \fn jsTestFacInt
-*/
-int jsTestFacRoText(void)
-
-{
-    
-      diaElemReadOnlyText txt(&quot;blah blah&quot;,&quot;Value:&quot;);
-      
-      diaElem *elems[]={&amp;txt   };
-  if(diaFactoryRun(&quot;Test FileRead&quot;,1,elems))
-  {
-    return true;
-  }
-  return false;
-}
-
-/**
-    \fn jsTestFacText
-*/
-int jsTestFacText(void)
-{
-    
-      char *foo=ADM_strdup(&quot;blah&quot;);
-      diaElemText txt(&amp;foo,&quot;Text&quot;,NULL);
-      
-      diaElem *elems[]={&amp;txt   };
-  if(diaFactoryRun(&quot;Test FileRead&quot;,1,elems))
- {
-    jsLog(JS_LOG_NORMAL,&quot;Out:%s&quot;,foo);
-    if(foo) ADM_dealloc(foo);
-    return true;
-  }
-  if(foo) ADM_dealloc(foo);
-  return false;
-}
-
-/**
-    \fn jsTestFacInt
-*/
-int jsTestFacTab(void)
-{
-    
-      uint32_t test,test2;
-      
-      diaElemReadOnlyText txt(&quot;blah blah&quot;,&quot;Value:&quot;);
-      diaElemUInteger     bt(&amp;test,&quot;Entry&quot;,0,10);
-      diaElemUInteger     bt2(&amp;test2,&quot;Entry&quot;,0,10);
-      
-      
-      diaElem *elems1[]={&amp;txt   };
-      diaElem *elems2[]={&amp;bt,&amp;bt2   };
-      
-      diaElemTabs tab1(&quot;T1&quot;,1,(diaElem **)elems1);
-      diaElemTabs tab2(&quot;T2&quot;,2,(diaElem **)elems2);
-      
-      diaElemTabs *tabs[2]={&amp;tab1,&amp;tab2};
-          
-      
-  if(diaFactoryRunTabs(&quot;Test FileRead&quot;,2,tabs))
- {
-    return true;
-  }
-  return false;
-}
-
-/**
-    \fn jsTestFacInt
-*/
-int jsTestFacFrame(void)
-{
-    
-      uint32_t test,test2;
-      
-      diaElemReadOnlyText align(&quot;*****&quot;,&quot;Value:&quot;);
-      diaElemReadOnlyText txt(&quot;blah blah&quot;,&quot;Value:&quot;);
-      diaElemUInteger     bt(&amp;test,&quot;Entry1&quot;,0,10);
-      diaElemUInteger     bt2(&amp;test2,&quot;Entry2&quot;,0,10);
-      diaElemFrame        frm(&quot;Frame1&quot;);
-      
-      frm.swallow(&amp;txt);
-      frm.swallow(&amp;bt);
-      frm.swallow(&amp;bt2);
-      
-         diaElem *elems[]={&amp;align,&amp;frm   };
-  if(diaFactoryRun(&quot;Test frame&quot;,2,elems))
- {
-    return true;
-  }
-  return false;
-}
-
-
-/**
-    \fn jsTestFacHex
-*/
-int jsTestFacHex(void)
-{
-    
-      uint8_t data[100];
-      for(int i=0;i&lt;100;i++) data[i]=i;
-      
-      diaElemHex binhex(&quot;*****&quot;,100,data);
-      
-      
-         diaElem *elems[]={&amp;binhex   };
-  if(diaFactoryRun(&quot;Test binHex&quot;,1,elems))
-  {
-    return true;
-  }
-  return false;
-      
-}
-
-/**
-    \fn jsTestFacMatrix
-*/
-int jsTestFacMatrix(void)
-{
-    
-      uint8_t data[16];
-      for(int i=0;i&lt;100;i++) data[i]=i;
-      
-      diaElemMatrix Matrix(data,&quot;Matrix&quot;,4);
-      
-      
-         diaElem *elems[]={&amp;Matrix   };
-  if(diaFactoryRun(&quot;Test Matrix&quot;,1,elems))
-  {
-      for(int x=0;x&lt;4*4;x++)
-      {
-          if(x &amp;&amp; !(x&amp;3)) printf(&quot;\n&quot;);
-          jsLog(JS_LOG_NORMAL,&quot;%02x &quot;,data[x]);
-          
-      }
-      return true;
-  }
-  return false;
-}
-
-/**
-    \fn jsTestFacThreadcount
-*/
-int jsTestFacThreadCount(void)
-{
-	uint32_t val=1;
-	diaElemThreadCount threadcount(&amp;val,&quot;ThreadCount&quot;);
-      
-    diaElem *elems[]={&amp;threadcount   };
-    
-  if(diaFactoryRun(&quot;Test ThreadCount&quot;,1,elems))
-  {
-         jsLog(JS_LOG_NORMAL,&quot;Thread: %u &quot;,(unsigned int)val);
-        return true;
-  }
-  return false;
-}
-
-/**
-    \fn jsTestFacNotch
-*/
-int jsTestFacNotch(void)
-{
-    
-	diaElemNotch notch(1,&quot;Notch&quot;);
-      
-         diaElem *elems[]={&amp;notch   };
-  if(diaFactoryRun(&quot;Test Notch&quot;,1,elems))
-  {
-    return true;
-  }
-  return false;
-      
-}
-/**
-    \fn jsTestFacEncoding
-*/
-int jsTestFacEncoding(void)
-{
-    DIA_encodingBase *base=createEncoding(1000*1000LL);
-    base-&gt;setContainer(&quot;the container&quot;);
-    base-&gt;setAudioCodec(&quot;the audio codec&quot;);
-    base-&gt;setVideoCodec(&quot;the video codec&quot;);
-    for(int i=0;i&lt;20;i++)
-    {
-        base-&gt;refresh();
-        base-&gt;pushVideoFrame(10000,1,50*1000LL*i);
-        base-&gt;refresh();
-        printf(&quot;%d / %d\n&quot;,i,20);
-        ADM_usleep(500*1000);
-    }
-    delete base;
-    base=NULL;
-    return true;
-}
-//EOF 

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsTestFactory_js.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsTestFactory_js.c	2010-05-20 15:22:49 UTC (rev 6206)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsTestFactory_js.c	2010-05-20 15:22:52 UTC (rev 6207)
@@ -1,649 +0,0 @@
-/*
---- DO NOT EDIT THIS FILE !!! ---
-
-This file has been generated automatically with 'jsapigen'.
-
-jsapigen is a glue-code generator for SpiderMonkey. It is distributed
-under the conditions of version 3 of the GNU General Public License.
-Please have a look at <A HREF="http://jsapigen.sourceforge.net.">http://jsapigen.sourceforge.net.</A>
-
-This file is NOT part of jsapigen and is NOT necessarily covered by
-jsapigen's license. For licensing information regarding this file,
-please refer to the software package which it is part of.
-
-*/
-
-#include &quot;stdio.h&quot;
-#include &quot;ADM_jsAvidemux.h&quot;
-#include &quot;ADM_jsTestFactory.h&quot;
-
-#ifdef HAVE_ALLOCA_H
-#include &lt;alloca.h&gt;
-static size_t jj_alloca_limit = 0;
-#endif
-#include &lt;stdlib.h&gt;
-#include &lt;string.h&gt;
-#include &lt;wchar.h&gt;
-#ifdef HAVE_ALLOCA_H
-#endif
-#include &lt;jsapi.h&gt;
-#ifndef JS_THREADSAFE
-#if JS_VERSION &lt;= 170
-#define jsrefcount int
-#define JS_BeginRequest(cx)
-#define JS_EndRequest(cx)
-#define JS_SuspendRequest(cx)
-#define JS_ResumeRequest(cx, saveDepth)
-#endif
-#endif
-#ifndef JS_FS
-#define JS_FS(name, call, nargs, flags, extra) {name, call, nargs, flags, extra}
-#endif
-#ifndef JS_FS_END
-#define JS_FS_END {NULL, NULL, 0, 0, 0}
-#endif
-
-static JSBool
-jjadmTestFacInt(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
-{
-    JSObject * var2;
-    int var3;
-    int var6;
-    jsval var7;
-    JSBool var1;
-    var2 = NULL;
-    var3 = 0;
-    var6 = 0;
-    var7 = JSVAL_NULL;
-    var1 = JS_FALSE;
-    var2 = obj;
-    var6 = argc;
-    var3 = jsTestFacInt();
-    if (JS_NewNumberValue(cx, var3, &amp;var7) != JS_TRUE) {
-        goto do_return;
-    }
-    argv[argc+0] = var7;
-    if (rval) {
-        *rval = var7;
-    }
-    var1 = JS_TRUE;
-    do_return:
-    return var1;
-}
-static JSBool
-jjadmTestFacFloat(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
-{
-    JSObject * var9;
-    int var10;
-    int var13;
-    jsval var14;
-    JSBool var8;
-    var9 = NULL;
-    var10 = 0;
-    var13 = 0;
-    var14 = JSVAL_NULL;
-    var8 = JS_FALSE;
-    var9 = obj;
-    var13 = argc;
-    var10 = jsTestFacFloat();
-    if (JS_NewNumberValue(cx, var10, &amp;var14) != JS_TRUE) {
-        goto do_return;
-    }
-    argv[argc+0] = var14;
-    if (rval) {
-        *rval = var14;
-    }
-    var8 = JS_TRUE;
-    do_return:
-    return var8;
-}
-static JSBool
-jjadmTestFacToggle(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
-{
-    JSObject * var16;
-    int var17;
-    int var20;
-    jsval var21;
-    JSBool var15;
-    var16 = NULL;
-    var17 = 0;
-    var20 = 0;
-    var21 = JSVAL_NULL;
-    var15 = JS_FALSE;
-    var16 = obj;
-    var20 = argc;
-    var17 = jsTestFacToggle();
-    if (JS_NewNumberValue(cx, var17, &amp;var21) != JS_TRUE) {
-        goto do_return;
-    }
-    argv[argc+0] = var21;
-    if (rval) {
-        *rval = var21;
-    }
-    var15 = JS_TRUE;
-    do_return:
-    return var15;
-}
-static JSBool
-jjadmTestFacMenu(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
-{
-    JSObject * var23;
-    int var24;
-    int var27;
-    jsval var28;
-    JSBool var22;
-    var23 = NULL;
-    var24 = 0;
-    var27 = 0;
-    var28 = JSVAL_NULL;
-    var22 = JS_FALSE;
-    var23 = obj;
-    var27 = argc;
-    var24 = jsTestFacMenu();
-    if (JS_NewNumberValue(cx, var24, &amp;var28) != JS_TRUE) {
-        goto do_return;
-    }
-    argv[argc+0] = var28;
-    if (rval) {
-        *rval = var28;
-    }
-    var22 = JS_TRUE;
-    do_return:
-    return var22;
-}
-static JSBool
-jjadmTestFacFile(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
-{
-    JSObject * var30;
-    int var31;
-    int var34;
-    jsval var35;
-    JSBool var29;
-    var30 = NULL;
-    var31 = 0;
-    var34 = 0;
-    var35 = JSVAL_NULL;
-    var29 = JS_FALSE;
-    var30 = obj;
-    var34 = argc;
-    var31 = jsTestFacFile();
-    if (JS_NewNumberValue(cx, var31, &amp;var35) != JS_TRUE) {
-        goto do_return;
-    }
-    argv[argc+0] = var35;
-    if (rval) {
-        *rval = var35;
-    }
-    var29 = JS_TRUE;
-    do_return:
-    return var29;
-}
-static JSBool
-jjadmTestFacBitrate(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
-{
-    JSObject * var37;
-    int var38;
-    int var41;
-    jsval var42;
-    JSBool var36;
-    var37 = NULL;
-    var38 = 0;
-    var41 = 0;
-    var42 = JSVAL_NULL;
-    var36 = JS_FALSE;
-    var37 = obj;
-    var41 = argc;
-    var38 = jsTestFacBitrate();
-    if (JS_NewNumberValue(cx, var38, &amp;var42) != JS_TRUE) {
-        goto do_return;
-    }
-    argv[argc+0] = var42;
-    if (rval) {
-        *rval = var42;
-    }
-    var36 = JS_TRUE;
-    do_return:
-    return var36;
-}
-static JSBool
-jjadmTestFacBar(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
-{
-    JSObject * var44;
-    int var45;
-    int var48;
-    jsval var49;
-    JSBool var43;
-    var44 = NULL;
-    var45 = 0;
-    var48 = 0;
-    var49 = JSVAL_NULL;
-    var43 = JS_FALSE;
-    var44 = obj;
-    var48 = argc;
-    var45 = jsTestFacBar();
-    if (JS_NewNumberValue(cx, var45, &amp;var49) != JS_TRUE) {
-        goto do_return;
-    }
-    argv[argc+0] = var49;
-    if (rval) {
-        *rval = var49;
-    }
-    var43 = JS_TRUE;
-    do_return:
-    return var43;
-}
-static JSBool
-jjadmTestFacRoText(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
-{
-    JSObject * var51;
-    int var52;
-    int var55;
-    jsval var56;
-    JSBool var50;
-    var51 = NULL;
-    var52 = 0;
-    var55 = 0;
-    var56 = JSVAL_NULL;
-    var50 = JS_FALSE;
-    var51 = obj;
-    var55 = argc;
-    var52 = jsTestFacRoText();
-    if (JS_NewNumberValue(cx, var52, &amp;var56) != JS_TRUE) {
-        goto do_return;
-    }
-    argv[argc+0] = var56;
-    if (rval) {
-        *rval = var56;
-    }
-    var50 = JS_TRUE;
-    do_return:
-    return var50;
-}
-static JSBool
-jjadmTestFacText(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
-{
-    JSObject * var58;
-    int var59;
-    int var62;
-    jsval var63;
-    JSBool var57;
-    var58 = NULL;
-    var59 = 0;
-    var62 = 0;
-    var63 = JSVAL_NULL;
-    var57 = JS_FALSE;
-    var58 = obj;
-    var62 = argc;
-    var59 = jsTestFacText();
-    if (JS_NewNumberValue(cx, var59, &amp;var63) != JS_TRUE) {
-        goto do_return;
-    }
-    argv[argc+0] = var63;
-    if (rval) {
-        *rval = var63;
-    }
-    var57 = JS_TRUE;
-    do_return:
-    return var57;
-}
-static JSBool
-jjadmTestFacTab(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
-{
-    JSObject * var65;
-    int var66;
-    int var69;
-    jsval var70;
-    JSBool var64;
-    var65 = NULL;
-    var66 = 0;
-    var69 = 0;
-    var70 = JSVAL_NULL;
-    var64 = JS_FALSE;
-    var65 = obj;
-    var69 = argc;
-    var66 = jsTestFacTab();
-    if (JS_NewNumberValue(cx, var66, &amp;var70) != JS_TRUE) {
-        goto do_return;
-    }
-    argv[argc+0] = var70;
-    if (rval) {
-        *rval = var70;
-    }
-    var64 = JS_TRUE;
-    do_return:
-    return var64;
-}
-static JSBool
-jjadmTestFacFrame(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
-{
-    JSObject * var72;
-    int var73;
-    int var76;
-    jsval var77;
-    JSBool var71;
-    var72 = NULL;
-    var73 = 0;
-    var76 = 0;
-    var77 = JSVAL_NULL;
-    var71 = JS_FALSE;
-    var72 = obj;
-    var76 = argc;
-    var73 = jsTestFacFrame();
-    if (JS_NewNumberValue(cx, var73, &amp;var77) != JS_TRUE) {
-        goto do_return;
-    }
-    argv[argc+0] = var77;
-    if (rval) {
-        *rval = var77;
-    }
-    var71 = JS_TRUE;
-    do_return:
-    return var71;
-}
-static JSBool
-jjadmTestFacHex(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
-{
-    JSObject * var79;
-    int var80;
-    int var83;
-    jsval var84;
-    JSBool var78;
-    var79 = NULL;
-    var80 = 0;
-    var83 = 0;
-    var84 = JSVAL_NULL;
-    var78 = JS_FALSE;
-    var79 = obj;
-    var83 = argc;
-    var80 = jsTestFacHex();
-    if (JS_NewNumberValue(cx, var80, &amp;var84) != JS_TRUE) {
-        goto do_return;
-    }
-    argv[argc+0] = var84;
-    if (rval) {
-        *rval = var84;
-    }
-    var78 = JS_TRUE;
-    do_return:
-    return var78;
-}
-static JSBool
-jjadmTestFacDirSel(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
-{
-    JSObject * var86;
-    int var87;
-    int var90;
-    jsval var91;
-    JSBool var85;
-    var86 = NULL;
-    var87 = 0;
-    var90 = 0;
-    var91 = JSVAL_NULL;
-    var85 = JS_FALSE;
-    var86 = obj;
-    var90 = argc;
-    var87 = jsTestFacDirSel();
-    if (JS_NewNumberValue(cx, var87, &amp;var91) != JS_TRUE) {
-        goto do_return;
-    }
-    argv[argc+0] = var91;
-    if (rval) {
-        *rval = var91;
-    }
-    var85 = JS_TRUE;
-    do_return:
-    return var85;
-}
-static JSBool
-jjadmTestFacButton(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
-{
-    JSObject * var93;
-    int var94;
-    int var97;
-    jsval var98;
-    JSBool var92;
-    var93 = NULL;
-    var94 = 0;
-    var97 = 0;
-    var98 = JSVAL_NULL;
-    var92 = JS_FALSE;
-    var93 = obj;
-    var97 = argc;
-    var94 = jsTestFacButton();
-    if (JS_NewNumberValue(cx, var94, &amp;var98) != JS_TRUE) {
-        goto do_return;
-    }
-    argv[argc+0] = var98;
-    if (rval) {
-        *rval = var98;
-    }
-    var92 = JS_TRUE;
-    do_return:
-    return var92;
-}
-static JSBool
-jjadmTestFacMatrix(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
-{
-    JSObject * var100;
-    int var101;
-    int var104;
-    jsval var105;
-    JSBool var99;
-    var100 = NULL;
-    var101 = 0;
-    var104 = 0;
-    var105 = JSVAL_NULL;
-    var99 = JS_FALSE;
-    var100 = obj;
-    var104 = argc;
-    var101 = jsTestFacMatrix();
-    if (JS_NewNumberValue(cx, var101, &amp;var105) != JS_TRUE) {
-        goto do_return;
-    }
-    argv[argc+0] = var105;
-    if (rval) {
-        *rval = var105;
-    }
-    var99 = JS_TRUE;
-    do_return:
-    return var99;
-}
-static JSBool
-jjadmTestFacNotch(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
-{
-    JSObject * var107;
-    int var108;
-    int var111;
-    jsval var112;
-    JSBool var106;
-    var107 = NULL;
-    var108 = 0;
-    var111 = 0;
-    var112 = JSVAL_NULL;
-    var106 = JS_FALSE;
-    var107 = obj;
-    var111 = argc;
-    var108 = jsTestFacNotch();
-    if (JS_NewNumberValue(cx, var108, &amp;var112) != JS_TRUE) {
-        goto do_return;
-    }
-    argv[argc+0] = var112;
-    if (rval) {
-        *rval = var112;
-    }
-    var106 = JS_TRUE;
-    do_return:
-    return var106;
-}
-static JSBool
-jjadmTestFacThreadCount(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
-{
-    JSObject * var114;
-    int var115;
-    int var118;
-    jsval var119;
-    JSBool var113;
-    var114 = NULL;
-    var115 = 0;
-    var118 = 0;
-    var119 = JSVAL_NULL;
-    var113 = JS_FALSE;
-    var114 = obj;
-    var118 = argc;
-    var115 = jsTestFacThreadCount();
-    if (JS_NewNumberValue(cx, var115, &amp;var119) != JS_TRUE) {
-        goto do_return;
-    }
-    argv[argc+0] = var119;
-    if (rval) {
-        *rval = var119;
-    }
-    var113 = JS_TRUE;
-    do_return:
-    return var113;
-}
-static JSBool
-jjadmTestFacSlider(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
-{
-    JSObject * var121;
-    int var122;
-    int var125;
-    jsval var126;
-    JSBool var120;
-    var121 = NULL;
-    var122 = 0;
-    var125 = 0;
-    var126 = JSVAL_NULL;
-    var120 = JS_FALSE;
-    var121 = obj;
-    var125 = argc;
-    var122 = jsTestFacSlider();
-    if (JS_NewNumberValue(cx, var122, &amp;var126) != JS_TRUE) {
-        goto do_return;
-    }
-    argv[argc+0] = var126;
-    if (rval) {
-        *rval = var126;
-    }
-    var120 = JS_TRUE;
-    do_return:
-    return var120;
-}
-static JSBool
-jjadmTestEncoding(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
-{
-    JSObject * var128;
-    int var129;
-    int var132;
-    jsval var133;
-    JSBool var127;
-    var128 = NULL;
-    var129 = 0;
-    var132 = 0;
-    var133 = JSVAL_NULL;
-    var127 = JS_FALSE;
-    var128 = obj;
-    var132 = argc;
-    var129 = jsTestFacEncoding();
-    if (JS_NewNumberValue(cx, var129, &amp;var133) != JS_TRUE) {
-        goto do_return;
-    }
-    argv[argc+0] = var133;
-    if (rval) {
-        *rval = var133;
-    }
-    var127 = JS_TRUE;
-    do_return:
-    return var127;
-}
-static JSBool
-jjadmTestCrash(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
-{
-    JSObject * var135;
-    int var139;
-    JSBool var134;
-    var135 = NULL;
-    var139 = 0;
-    var134 = JS_FALSE;
-    var135 = obj;
-    var139 = argc;
-    jsTestCrash();
-    var134 = JS_TRUE;
-    return var134;
-}
-static JSBool
-jjadmTestAssert(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
-{
-    JSObject * var141;
-    int var145;
-    JSBool var140;
-    var141 = NULL;
-    var145 = 0;
-    var140 = JS_FALSE;
-    var141 = obj;
-    var145 = argc;
-    jsTestAssert();
-    var140 = JS_TRUE;
-    return var140;
-}
-static JSPropertySpec jj_static_ps[] = {
-    {NULL, 0, 0, NULL, NULL}
-};
-static JSPropertySpec jj_ps[] = {
-    {NULL, 0, 0, NULL, NULL}
-};
-static JSFunctionSpec jj_static_fs[] = {
-    JS_FS(&quot;admTestFacInt&quot;, jjadmTestFacInt, 0, 0, 1),
-    JS_FS(&quot;admTestFacFloat&quot;, jjadmTestFacFloat, 0, 0, 1),
-    JS_FS(&quot;admTestFacToggle&quot;, jjadmTestFacToggle, 0, 0, 1),
-    JS_FS(&quot;admTestFacMenu&quot;, jjadmTestFacMenu, 0, 0, 1),
-    JS_FS(&quot;admTestFacFile&quot;, jjadmTestFacFile, 0, 0, 1),
-    JS_FS(&quot;admTestFacBitrate&quot;, jjadmTestFacBitrate, 0, 0, 1),
-    JS_FS(&quot;admTestFacBar&quot;, jjadmTestFacBar, 0, 0, 1),
-    JS_FS(&quot;admTestFacRoText&quot;, jjadmTestFacRoText, 0, 0, 1),
-    JS_FS(&quot;admTestFacText&quot;, jjadmTestFacText, 0, 0, 1),
-    JS_FS(&quot;admTestFacTab&quot;, jjadmTestFacTab, 0, 0, 1),
-    JS_FS(&quot;admTestFacFrame&quot;, jjadmTestFacFrame, 0, 0, 1),
-    JS_FS(&quot;admTestFacHex&quot;, jjadmTestFacHex, 0, 0, 1),
-    JS_FS(&quot;admTestFacDirSel&quot;, jjadmTestFacDirSel, 0, 0, 1),
-    JS_FS(&quot;admTestFacButton&quot;, jjadmTestFacButton, 0, 0, 1),
-    JS_FS(&quot;admTestFacMatrix&quot;, jjadmTestFacMatrix, 0, 0, 1),
-    JS_FS(&quot;admTestFacNotch&quot;, jjadmTestFacNotch, 0, 0, 1),
-    JS_FS(&quot;admTestFacThreadCount&quot;, jjadmTestFacThreadCount, 0, 0, 1),
-    JS_FS(&quot;admTestFacSlider&quot;, jjadmTestFacSlider, 0, 0, 1),
-    JS_FS(&quot;admTestEncoding&quot;, jjadmTestEncoding, 0, 0, 1),
-    JS_FS(&quot;admTestCrash&quot;, jjadmTestCrash, 0, 0, 0),
-    JS_FS(&quot;admTestAssert&quot;, jjadmTestAssert, 0, 0, 0),
-    JS_FS_END
-};
-static JSFunctionSpec jj_fs[] = {
-    JS_FS(&quot;admTestFacInt&quot;, jjadmTestFacInt, 0, 0, 1),
-    JS_FS(&quot;admTestFacFloat&quot;, jjadmTestFacFloat, 0, 0, 1),
-    JS_FS(&quot;admTestFacToggle&quot;, jjadmTestFacToggle, 0, 0, 1),
-    JS_FS(&quot;admTestFacMenu&quot;, jjadmTestFacMenu, 0, 0, 1),
-    JS_FS(&quot;admTestFacFile&quot;, jjadmTestFacFile, 0, 0, 1),
-    JS_FS(&quot;admTestFacBitrate&quot;, jjadmTestFacBitrate, 0, 0, 1),
-    JS_FS(&quot;admTestFacBar&quot;, jjadmTestFacBar, 0, 0, 1),
-    JS_FS(&quot;admTestFacRoText&quot;, jjadmTestFacRoText, 0, 0, 1),
-    JS_FS(&quot;admTestFacText&quot;, jjadmTestFacText, 0, 0, 1),
-    JS_FS(&quot;admTestFacTab&quot;, jjadmTestFacTab, 0, 0, 1),
-    JS_FS(&quot;admTestFacFrame&quot;, jjadmTestFacFrame, 0, 0, 1),
-    JS_FS(&quot;admTestFacHex&quot;, jjadmTestFacHex, 0, 0, 1),
-    JS_FS(&quot;admTestFacDirSel&quot;, jjadmTestFacDirSel, 0, 0, 1),
-    JS_FS(&quot;admTestFacButton&quot;, jjadmTestFacButton, 0, 0, 1),
-    JS_FS(&quot;admTestFacMatrix&quot;, jjadmTestFacMatrix, 0, 0, 1),
-    JS_FS(&quot;admTestFacNotch&quot;, jjadmTestFacNotch, 0, 0, 1),
-    JS_FS(&quot;admTestFacThreadCount&quot;, jjadmTestFacThreadCount, 0, 0, 1),
-    JS_FS(&quot;admTestFacSlider&quot;, jjadmTestFacSlider, 0, 0, 1),
-    JS_FS(&quot;admTestEncoding&quot;, jjadmTestEncoding, 0, 0, 1),
-    JS_FS(&quot;admTestCrash&quot;, jjadmTestCrash, 0, 0, 0),
-    JS_FS(&quot;admTestAssert&quot;, jjadmTestAssert, 0, 0, 0),
-    JS_FS_END
-};
-
-JSFunctionSpec  *jsGetTestFunctions(void)
-{
-        return jj_fs;
-}
-
-

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsTestFactory_js.idl
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsTestFactory_js.idl	2010-05-20 15:22:49 UTC (rev 6206)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsTestFactory_js.idl	2010-05-20 15:22:52 UTC (rev 6207)
@@ -1,40 +0,0 @@
-%{
-#include &quot;stdio.h&quot;
-#include &quot;ADM_jsAvidemux.h&quot;
-#include &quot;ADM_jsTestFactory.h&quot;
-%}
-/*
-###############################################################
-       return JS function     C Function  params
-###############################################################
-*/
-function int admTestFacInt     :  jsTestFacInt     (void  ) &lt;static&gt;;
-function int admTestFacFloat   :  jsTestFacFloat   (void  ) &lt;static&gt;;
-function int admTestFacToggle  :  jsTestFacToggle  (void  ) &lt;static&gt;;
-function int admTestFacMenu    :  jsTestFacMenu    (void  ) &lt;static&gt;;
-function int admTestFacFile    :  jsTestFacFile    (void  ) &lt;static&gt;;
-function int admTestFacBitrate :  jsTestFacBitrate (void  ) &lt;static&gt;;
-function int admTestFacBar     :  jsTestFacBar     (void  ) &lt;static&gt;;
-function int admTestFacRoText  :  jsTestFacRoText  (void  ) &lt;static&gt;;
-function int admTestFacText    :  jsTestFacText    (void  ) &lt;static&gt;;
-function int admTestFacTab     :  jsTestFacTab     (void  ) &lt;static&gt;;
-function int admTestFacFrame   :  jsTestFacFrame   (void  ) &lt;static&gt;;
-function int admTestFacHex     :  jsTestFacHex     (void  ) &lt;static&gt;;
-function int admTestFacDirSel  :  jsTestFacDirSel  (void  ) &lt;static&gt;;
-function int admTestFacButton  :  jsTestFacButton  (void  ) &lt;static&gt;;
-function int admTestFacMatrix  :  jsTestFacMatrix  (void  ) &lt;static&gt;;
-function int admTestFacNotch   :  jsTestFacNotch   (void  ) &lt;static&gt;;
-function int admTestFacThreadCount:  jsTestFacThreadCount   (void  ) &lt;static&gt;;
-function int admTestFacSlider  :  jsTestFacSlider  (void  ) &lt;static&gt;;
-function int admTestEncoding   :  jsTestFacEncoding  (void  ) &lt;static&gt;;
-function void admTestCrash     :  jsTestCrash      (void  ) &lt;static&gt;;
-function void admTestAssert    :  jsTestAssert     (void  ) &lt;static&gt;;
-
-%&lt;
-JSFunctionSpec  *jsGetTestFunctions(void)
-{
-        return jj_fs;
-}
-
-%&gt;
-

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsUtils.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsUtils.cpp	2010-05-20 15:22:49 UTC (rev 6206)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsUtils.cpp	2010-05-20 15:22:52 UTC (rev 6207)
@@ -1,167 +0,0 @@
-/**
-    \file ADM_jsUtils
-    \brief Simple param -&gt; type utilities
-    \author mean <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A> 2009
-*/
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#include &quot;ADM_js.h&quot;
-/**
-    \fn ADM_jsArg2Vars  
-    \brief convert jsvals to native type with checking
-*/
-bool ADM_jsArg2Vars(const char *caller, int argc, jsval *argv, int paramNumber, ADM_PARAM_LIST *param)
-{
-    if(paramNumber!=argc)
-    {
-        ADM_warning(&quot;[%s]Wrong number of parameters : %d vs %d\n&quot;,caller,argc,paramNumber);
-        return false;
-    }
-    for(int i=0;i&lt;argc;i++)
-    {
-        jsval j=argv[i];
-        ADM_PARAM_LIST *p=param+i;
-        switch(p-&gt;type)
-        {
-            case ADM_JS_UINT64_T:
-            case ADM_JS_UINT32_T:
-            case ADM_JS_INT64_T:
-            case ADM_JS_INT32_T:
-                {
-                        if(!JSVAL_IS_NUMBER(j))
-                        {
-                            ADM_warning(&quot;[%s]Expected number and got %d\n&quot;,caller,j);
-                            return false;
-                        }
-                        // If it is an int...
-                        double v=0;
-                        if(JSVAL_IS_INT(j)) 
-                        {
-                            v=(int64_t)JSVAL_TO_INT(j);
-                            //ADM_warning(&quot;Value is int :%&quot;LLD&quot;\n&quot;,JSVAL_TO_INT(j));
-                        }
-                        if(JSVAL_IS_DOUBLE(j)) 
-                        {
-                            v=(int64_t)*(JSVAL_TO_DOUBLE(j));
-                            //ADM_warning(&quot;Value is float :%f\n&quot;,(float)*(JSVAL_TO_DOUBLE(j)));
-                        }
-                        // 
-                        //ADM_warning(&quot;%f\n&quot;,(float)v);
-                        // Affect
-                        switch(p-&gt;type)
-                        {
-                            case ADM_JS_UINT64_T: *(uint64_t *)p-&gt;value=(uint64_t)v;break;
-                            case ADM_JS_UINT32_T: *(uint32_t *)p-&gt;value=(uint32_t)v;break;
-                            case ADM_JS_INT64_T:  *(int64_t *)p-&gt;value=(int64_t)v;break;
-                            case ADM_JS_INT32_T:  *(int32_t *)p-&gt;value=(int32_t)v;break;
-                            default: ADM_assert(0);break;
-                        }
-                 }
-                        break;
-            case  ADM_JS_STRING:
-                {
-                        if(!JSVAL_IS_STRING(j))
-                        {
-                            ADM_warning(&quot;[%s]Expected string and got %d\n&quot;,caller,j);
-                            return false;
-                        }
-                        char *out=JS_GetStringBytes(JSVAL_TO_STRING(j));
-                        char **m=(char **)(p-&gt;value);
-                        *m=out;
-                }
-                        break;
-            case  ADM_JS_BOOL:
-                        if(!JSVAL_IS_BOOLEAN(j))
-                        {
-                            ADM_warning(&quot;[%s]Expected boolean and got %d\n&quot;,caller,j);
-                            return false;
-                        }
-                        *(bool *)p-&gt;value=JSVAL_TO_BOOLEAN(j);
-                        break;
-            default:
-                    ADM_assert(0);
-                    break;
-        }
-
-    }
-    return true;
-}
-/**
-    \fn stringsToConfCouple
-    \brief Convert js args to confcouple
-
-*/
-bool stringsToConfCouple(int nb,CONFcouple **conf,  const char **argv)
-{
-  *conf=NULL;
-  if(!nb) return true;
-  CONFcouple *c=new CONFcouple(nb);
-  *conf=c;
-    for(int i=0;i&lt;nb;i++)
-    {
-        
-        char *dupe=   ADM_strdup(argv[i]);
-        char *name,*value;
-        // dupe is in the form name=value
-        name=dupe;
-        value=name;
-        char *tail=dupe+strlen(dupe);
-        while(value&lt;tail)
-        {
-            if(*value=='=') 
-                {
-                    *value=0;
-                    value++;
-                    break;
-                }
-            value++;
-        }
-        c-&gt;setInternalName(name,value);
-        //printf(&quot;%s -&gt; [%s,%s]\n&quot;,param,name,value);
-        ADM_dezalloc(dupe);
-    }
-    return true;
-}
-/**
-    \fn jsArgToConfCouple
-    \brief Convert js args to confcouple
-
-*/
-bool jsArgToConfCouple(int nb,CONFcouple **conf,  jsval *argv)
-{
-  *conf=NULL;
-  if(!nb) return true;
-  CONFcouple *c=new CONFcouple(nb);
-  *conf=c;
-    for(int i=0;i&lt;nb;i++)
-    {
-        char *param = JS_GetStringBytes(JSVAL_TO_STRING(argv[i]));
-        char *dupe=   ADM_strdup(param);
-        char *name,*value;
-        // dupe is in the form name=value
-        name=dupe;
-        value=name;
-        char *tail=dupe+strlen(dupe);
-        while(value&lt;tail)
-        {
-            if(*value=='=') 
-                {
-                    *value=0;
-                    value++;
-                    break;
-                }
-            value++;
-        }
-        c-&gt;setInternalName(name,value);
-        //printf(&quot;%s -&gt; [%s,%s]\n&quot;,param,name,value);
-        ADM_dezalloc(dupe);
-    }
-    return true;
-}
-// EOF

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsVideo.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsVideo.cpp	2010-05-20 15:22:49 UTC (rev 6206)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/ADM_jsVideo.cpp	2010-05-20 15:22:52 UTC (rev 6207)
@@ -1,149 +0,0 @@
-/**
-    \file ADM_jsVideo.cpp
-    \brief Video oriented functions
-    \author mean (c) 2009 <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
-
-
-    jsapigen does not like much variable number of arguments
-    In that case, we patch the generated file to go back to native spidermonkey api
-
-
-*/
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#include &quot;ADM_js.h&quot;
-#include &quot;ADM_editor/ADM_edit.hxx&quot;
-#include &quot;ADM_jsAvidemux.h&quot;
-#include &quot;ADM_jsVideo.h&quot;
-#include &quot;A_functions.h&quot;
-#include &quot;ADM_videoEncoderApi.h&quot;
-#include &quot;ADM_videoFilterApi.h&quot;
-#include &quot;ADM_videoFilters.h&quot;
-#include &quot;GUI_ui.h&quot;
-extern ADM_Composer *video_body;
-bool A_setVideoCodec(const char *nm);
-/**
-    \fn jsSetPostProc
-*/
-int jsSetPostProc (int a,int b, int c)
-{
-    return video_body-&gt;setPostProc(a,b,c);
-}
-
-
-/**
-    \fn Codec
-    
-*/
-extern &quot;C&quot; int   jsVideoCodec(const char *a,const char **b) {return 0;}
-JSBool jsAdmvideoCodec(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
-{// begin Codec
-        *rval = BOOLEAN_TO_JSVAL(false);
-        if(argc &lt;1)
-                return JS_FALSE;
-        if(JSVAL_IS_STRING(argv[0]) == false )
-        {
-                jsLog(JS_LOG_ERROR,&quot;Cannot set codec, first parameter is not a string\n&quot;);
-                return JS_FALSE;
-        }
-        char *codec=JS_GetStringBytes(JSVAL_TO_STRING(argv[0]));
-        // Set codec.
-        
-        if(A_setVideoCodec(codec)==false)
-        {
-            jsLog(JS_LOG_ERROR,&quot;Could not select codec %s\n&quot;,codec);
-            return JS_FALSE;
-        }
-        CONFcouple *c;
-        jsArgToConfCouple(argc-1,&amp;c,argv+1);
-        *rval = BOOLEAN_TO_JSVAL( videoEncoder6_SetConfiguration(c));
-        jsLog(JS_LOG_NORMAL,&quot;Selected codec %s\n&quot;,codec);
-        if(c) delete c;
-        return JS_TRUE;
-}// end Codec
-
-/**
-    \fn Codec
-    
-*/
-extern &quot;C&quot; int   jsVideoFilter(const char *a,const char **b) {return 0;}
-JSBool jsAdmaddVideoFilter(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
-{// begin Codec
-   uint32_t filterTag;
-
-        // default return value
-        *rval = BOOLEAN_TO_JSVAL(false);
-        if(argc == 0)
-                return JS_FALSE;
-        char *filterName=JS_GetStringBytes(JSVAL_TO_STRING(argv[0]));
-        filterTag = ADM_vf_getTagFromInternalName(filterName);
-        jsLog(JS_LOG_NORMAL,&quot;Adding Filter %s -&gt; %&quot;LU&quot;... \n&quot;,filterName,filterTag);
-
-        
-        CONFcouple *c=NULL;
-        if(argc)
-            jsArgToConfCouple(argc-1,&amp;c,argv+1);
-        *rval=BOOLEAN_TO_JSVAL(  ADM_vf_addFilterFromTag(filterTag,c,false));
-        if(c) delete c;
-        
-        return JS_TRUE;
-}// end Codec
-/**
-    \fn A_setVideoCodec
-*/
-bool A_setVideoCodec(const char *nm)
-{
-    int idx=videoEncoder6_GetIndexFromName(nm);
-    if(idx==-1)
-    {
-        ADM_error(&quot;No such encoder :%s\n&quot;,nm);
-    }
-    // Select by index
-    videoEncoder6_SetCurrentEncoder(idx);
-    UI_setVideoCodec(idx);
-    return true;
-}
-/**
-     \fn jsClearFilters
-*/
-int jsClearVideoFilters()
-{
-    return ADM_vf_clearFilters();
-}
-/**
-    \fn jsGetMarkerA
-*/
-double jsGetMarkerA(void)
-{
-    return (double)video_body-&gt;getMarkerAPts();
-
-}
-/**
-    \fn jsGetMarkerB
-*/
-double jsGetMarkerB(void)
-{
-    return (double)video_body-&gt;getMarkerBPts();
-}
-/**
-    \fn jsSetMarkerA
-*/
-void   jsSetMarkerA(double a)
-{
-    video_body-&gt;setMarkerAPts( (uint64_t)a);
-}
-/**
-    \fn jsGetMarkerB
-*/
-void   jsSetMarkerB(double b)
-{
-    video_body-&gt;setMarkerBPts( (uint64_t)b);
-}
-
-//EOF
\ No newline at end of file

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/CMakeLists.txt	2010-05-20 15:22:49 UTC (rev 6206)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/CMakeLists.txt	2010-05-20 15:22:52 UTC (rev 6207)
@@ -1,27 +0,0 @@
-SET(ADM_script_SRCS
-        ADM_jsIf.cpp
-        ADM_jsDebug.cpp
-        ADM_jsUtils.cpp
-# Wrapper code
-        ADM_jsIf_js.c
-# Factory test
-        ADM_jsTestFactory.cpp  
-        ADM_jsTestFactory_js.c
-# Load segment
-        ADM_jsAvidemux.cpp
-        ADM_jsAvidemuxInfo.cpp
-        ADM_jsAvidemux_js.c
-# Debug / editor class
-        ADM_jsEditor.cpp
-        ADM_jsEditor_js.c
-
-# 
-        ADM_jsVideo.cpp
-#
-        ADM_jsAudio.cpp
-)
-
-ADD_LIBRARY(ADM_script26 STATIC ${ADM_script_SRCS})
-ADD_DEFINITIONS(&quot;-DJS_THREADSAFE -DXP_UNIX&quot;)
-include_directories(${AVIDEMUX_TOP_SOURCE_DIR}/avidemux/common/ADM_script2/include)
-include_directories(${AVIDEMUX_TOP_SOURCE_DIR}/avidemux_core/ADM_smjs)

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/idl.make
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/idl.make	2010-05-20 15:22:49 UTC (rev 6206)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/idl.make	2010-05-20 15:22:52 UTC (rev 6207)
@@ -1,7 +0,0 @@
-idls:=$(shell ls *.idl)
-cs:=$(subst .idl,.c,$(idls))
-%.c : %.idl
-	echo processing $@
-	jsapigen &lt; $&lt; &gt; /tmp/xx
-	cat /tmp/xx   | sed 's/&quot;\(.*\)_ignore&quot;/&quot;\1&quot;/g'  | sed 's/, jjadm\(.*\)_ignore,/, jsAdm\1, /g' &gt; $@
-all: $(cs)

Deleted: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/updateIdl.sh
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/updateIdl.sh	2010-05-20 15:22:49 UTC (rev 6206)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/src/updateIdl.sh	2010-05-20 15:22:52 UTC (rev 6207)
@@ -1 +0,0 @@
-jsapigen &lt; ADM_jsIf_js.idl  &gt; ADM_jsIf_js.c

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/CMakeLists.txt	2010-05-20 15:22:49 UTC (rev 6206)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/CMakeLists.txt	2010-05-20 15:22:52 UTC (rev 6207)
@@ -16,7 +16,6 @@
 ADD_SUBDIRECTORY(ADM_requant)
 #ADD_SUBDIRECTORY(ADM_script)
 ADD_SUBDIRECTORY(ADM_script2)
-ADD_SUBDIRECTORY(ADM_pyScript)
 ADD_SUBDIRECTORY(ADM_toolkit)
 #ADD_SUBDIRECTORY(ADM_video)
 #ADD_SUBDIRECTORY(ADM_videoFilter)

Modified: branches/avidemux_2.6_branch_mean/avidemux/commonCmakeApplication.cmake
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/commonCmakeApplication.cmake	2010-05-20 15:22:49 UTC (rev 6206)
+++ branches/avidemux_2.6_branch_mean/avidemux/commonCmakeApplication.cmake	2010-05-20 15:22:52 UTC (rev 6207)
@@ -99,7 +99,6 @@
 ADM_requant6 
 #ADM_script6 
 ADM_script26 
-ADM_pyScript6 
 ADM_scriptDF
 ADM_videoEncoder6 
 ADM_internalVideoFilter6


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="003406.html">[Avidemux-svn-commit] r6206 - in branches/avidemux_2.6_branch_mean:	avidemux avidemux/common avidemux/common/ADM_pyScript	avidemux/common/ADM_pyScript/include	avidemux/common/ADM_pyScript/src avidemux/common/ADM_script2/src	avidemux/qt4/ADM_userInterfaces/ADM_gui cmake
</A></li>
	<LI>Next message: <A HREF="003408.html">[Avidemux-svn-commit] r6208 - in	branches/avidemux_2.6_branch_mean/avidemux: . common	common/ADM_editor common/ADM_script2	common/ADM_script2/include common/ADM_script2/js	common/ADM_script2/js/src_dialogFactory common/ADM_script2/py	common/ADM_script2/py/include common/ADM_script2/src	common/ADM_script2/src_dialogFactory	qt4/ADM_userInterfaces/ADM_shell
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3407">[ date ]</a>
              <a href="thread.html#3407">[ thread ]</a>
              <a href="subject.html#3407">[ subject ]</a>
              <a href="author.html#3407">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">More information about the Avidemux-svn-commit
mailing list</a><br>
</body></html>
