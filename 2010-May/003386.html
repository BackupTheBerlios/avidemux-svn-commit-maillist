<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Avidemux-svn-commit] r6183 - in branches/avidemux_2.6_branch_mean:	avidemux/common avidemux/common/ADM_editor	avidemux/common/ADM_render avidemux/common/ADM_videoCodec/src	avidemux/common/ADM_videoFilter2/src	avidemux_core/ADM_coreImage/include avidemux_core/ADM_coreImage/src	avidemux_core/ADM_coreImageLoader/src	avidemux_core/ADM_coreVideoCodec/include	avidemux_core/ADM_coreVideoCodec/src	avidemux_core/ADM_coreVideoEncoder/include	avidemux_core/ADM_coreVideoEncoder/src	avidemux_core/ADM_coreVideoFilter/include	avidemux_core/ADM_coreVideoFilter/src
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/avidemux-svn-commit/2010-May/index.html" >
   <LINK REL="made" HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r6183%20-%20in%20branches/avidemux_2.6_branch_mean%3A%0A%09avidemux/common%20avidemux/common/ADM_editor%0A%09avidemux/common/ADM_render%20avidemux/common/ADM_videoCodec/src%0A%09avidemux/common/ADM_videoFilter2/src%0A%09avidemux_core/ADM_coreImage/include%20avidemux_core/ADM_coreImage/src%0A%09avidemux_core/ADM_coreImageLoader/src%0A%09avidemux_core/ADM_coreVideoCodec/include%0A%09avidemux_core/ADM_coreVideoCodec/src%0A%09avidemux_core/ADM_coreVideoEncoder/include%0A%09avidemux_core/ADM_coreVideoEncoder/src%0A%09avidemux_core/ADM_coreVideoFilter/include%0A%09avidemux_core/ADM_coreVideoFilter/src&In-Reply-To=%3C201005141534.o4EFYKj3026567%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="003385.html">
   <LINK REL="Next"  HREF="003387.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Avidemux-svn-commit] r6183 - in branches/avidemux_2.6_branch_mean:	avidemux/common avidemux/common/ADM_editor	avidemux/common/ADM_render avidemux/common/ADM_videoCodec/src	avidemux/common/ADM_videoFilter2/src	avidemux_core/ADM_coreImage/include avidemux_core/ADM_coreImage/src	avidemux_core/ADM_coreImageLoader/src	avidemux_core/ADM_coreVideoCodec/include	avidemux_core/ADM_coreVideoCodec/src	avidemux_core/ADM_coreVideoEncoder/include	avidemux_core/ADM_coreVideoEncoder/src	avidemux_core/ADM_coreVideoFilter/include	avidemux_core/ADM_coreVideoFilter/src</H1>
    <B>mean at BerliOS</B> 
    <A HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r6183%20-%20in%20branches/avidemux_2.6_branch_mean%3A%0A%09avidemux/common%20avidemux/common/ADM_editor%0A%09avidemux/common/ADM_render%20avidemux/common/ADM_videoCodec/src%0A%09avidemux/common/ADM_videoFilter2/src%0A%09avidemux_core/ADM_coreImage/include%20avidemux_core/ADM_coreImage/src%0A%09avidemux_core/ADM_coreImageLoader/src%0A%09avidemux_core/ADM_coreVideoCodec/include%0A%09avidemux_core/ADM_coreVideoCodec/src%0A%09avidemux_core/ADM_coreVideoEncoder/include%0A%09avidemux_core/ADM_coreVideoEncoder/src%0A%09avidemux_core/ADM_coreVideoFilter/include%0A%09avidemux_core/ADM_coreVideoFilter/src&In-Reply-To=%3C201005141534.o4EFYKj3026567%40sheep.berlios.de%3E"
       TITLE="[Avidemux-svn-commit] r6183 - in branches/avidemux_2.6_branch_mean:	avidemux/common avidemux/common/ADM_editor	avidemux/common/ADM_render avidemux/common/ADM_videoCodec/src	avidemux/common/ADM_videoFilter2/src	avidemux_core/ADM_coreImage/include avidemux_core/ADM_coreImage/src	avidemux_core/ADM_coreImageLoader/src	avidemux_core/ADM_coreVideoCodec/include	avidemux_core/ADM_coreVideoCodec/src	avidemux_core/ADM_coreVideoEncoder/include	avidemux_core/ADM_coreVideoEncoder/src	avidemux_core/ADM_coreVideoFilter/include	avidemux_core/ADM_coreVideoFilter/src">mean at mail.berlios.de
       </A><BR>
    <I>Fri May 14 17:34:20 CEST 2010</I>
    <P><UL>
        <LI>Previous message: <A HREF="003385.html">[Avidemux-svn-commit] r6182 - in branches/avidemux_2.6_branch_mean:	avidemux/common/ADM_editor avidemux/common/ADM_videoCodec/src	avidemux_core/ADM_coreImage/include avidemux_core/ADM_coreImage/src	avidemux_core/ADM_coreImageLoader/include	avidemux_core/ADM_coreImageLoader/src	avidemux_core/ADM_coreVideoCodec/src
</A></li>
        <LI>Next message: <A HREF="003387.html">[Avidemux-svn-commit] r6184 -	branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImage/src
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3386">[ date ]</a>
              <a href="thread.html#3386">[ thread ]</a>
              <a href="subject.html#3386">[ subject ]</a>
              <a href="author.html#3386">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: mean
Date: 2010-05-14 17:34:19 +0200 (Fri, 14 May 2010)
New Revision: 6183

Added:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImage/include/ADM_imageResizer.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImage/src/ADM_imageOperation.cpp
Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edCache.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRender.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRenderInternal.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_preview.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_render/GUI_sdlRender.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_render/GUI_simpleRender.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_render/GUI_xvRender.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoCodec/src/ADM_ffmpeg_vdpau.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter2/src/ADM_filterThread.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/gui_blackframes.cpp
   branches/avidemux_2.6_branch_mean/avidemux/common/gui_save.cpp
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImage/include/ADM_colorspace.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImage/include/ADM_image.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImage/src/ADM_colorspace.cpp
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImage/src/ADM_image.cpp
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImage/src/ADM_imageResizer.cpp
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImage/src/ADM_imageSave.cpp
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImage/src/ADM_imageUtils.cpp
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImage/src/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImageLoader/src/ADM_imageLoader.cpp
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_codecNull.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_ffmp43.cpp
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_png.cpp
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_rgb16.cpp
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_uyvy.cpp
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoEncoder/include/ADM_coreVideoEncoderFFmpeg.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoEncoder/src/ADM_coreVideoEncoderFFmpeg.cpp
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/include/DIA_flyDialog.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/src/ADM_videoFilterCache.cpp
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/src/DIA_flyDialog.cpp
Log:
[core] Split coreImage into default, ref and later vdpau

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edCache.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edCache.cpp	2010-05-14 15:34:12 UTC (rev 6182)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edCache.cpp	2010-05-14 15:34:19 UTC (rev 6183)
@@ -35,7 +35,7 @@
 	_elem=new cacheElem[size];
 	for(uint32_t i=0;i&lt;size;i++)
 	{
-		_elem[i].image=new ADMImage(w,h);
+		_elem[i].image=new ADMImageDefault(w,h);
 		_elem[i].pts=ADM_NO_PTS;
 	}
 	_nbImage=size;

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRender.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRender.cpp	2010-05-14 15:34:12 UTC (rev 6182)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRender.cpp	2010-05-14 15:34:19 UTC (rev 6183)
@@ -487,16 +487,24 @@
                         }
                         // Since it is not YV12 it MUST be a ref
                         ADM_assert(src-&gt;isRef());
-                        uint32_t strides[3]={src-&gt;_width,src-&gt;_width/2,src-&gt;_width/2};
-                        uint8_t  *Planes[3]={YPLANE(dst),UPLANE(dst),VPLANE(dst)};
-                        vid-&gt;color-&gt;convertPlanes(src-&gt;_planeStride,strides,src-&gt;_planes,Planes);
+                        
+                        uint32_t srcStrides[3];
+                        uint8_t  *srcPlanes[3];
+                        uint32_t dstStrides[3];
+                        uint8_t  *dstPlanes[3];
+
+                        src-&gt;GetPitches(srcStrides);
+                        src-&gt;GetReadPlanes(srcPlanes);
+                        dst-&gt;GetPitches(dstStrides);
+                        dst-&gt;GetWritePlanes(dstPlanes);
+
+                        vid-&gt;color-&gt;convertPlanes(srcStrides,dstStrides,srcPlanes,dstPlanes);
                         return 1;
                 }
                 // nothing to do
-                if(_pp.swapuv)
-                      dst-&gt;duplicateSwapUV(src);
-                else
-                        dst-&gt;duplicate(src);
+//                if(_pp.swapuv)
+#warning handle swap uv
+                dst-&gt;duplicate(src);
                 return 1;
 }
 /**

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRenderInternal.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRenderInternal.cpp	2010-05-14 15:34:12 UTC (rev 6182)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edRenderInternal.cpp	2010-05-14 15:34:19 UTC (rev 6183)
@@ -290,7 +290,7 @@
                 }
                 if(!_scratch)
                 {
-                  _scratch=new ADMImage(_imageBuffer-&gt;_width,_imageBuffer-&gt;_height,ADM_IMAGE_REF);
+                  _scratch=new ADMImageRef(_imageBuffer-&gt;_width,_imageBuffer-&gt;_height);
                 }
                 tmpImage=_scratch;
                 ww=_imageBuffer-&gt;_width &amp; 0xfffff0;
@@ -370,54 +370,35 @@
 	// we do postproc !
 	// keep
 	uint8_t *oBuff[3];
-	const uint8_t *iBuff[3];
-	int	strideTab[3];
-	int	strideTab2[3];
+    const uint8_t *xBuff[3];
+	uint8_t *iBuff[3];
+	uint32_t	strideTab[3];
+	uint32_t	strideTab2[3];
 	aviInfo _info;
 
         getVideoInfo(&amp;_info);
-        if(refOnly)
+        tmpImage-&gt;GetReadPlanes(iBuff);
+        tmpImage-&gt;GetPitches(strideTab);
+        out-&gt;GetPitches(strideTab2);
+        out-&gt;GetWritePlanes(oBuff);
+        if(_pp.swapuv)
         {
-                iBuff[0]= tmpImage-&gt;_planes[0];
-                iBuff[1]= tmpImage-&gt;_planes[1];
-                iBuff[2]= tmpImage-&gt;_planes[2];
-
-                strideTab2[0]=_info.width;
-                strideTab2[1]=_info.width&gt;&gt;1;
-                strideTab2[2]=_info.width&gt;&gt;1;
-
-                strideTab[0]=tmpImage-&gt;_planeStride[0];
-                strideTab[1]=tmpImage-&gt;_planeStride[1];
-                strideTab[2]=tmpImage-&gt;_planeStride[2];
-
+                uint8_t *s=oBuff[1];
+                oBuff[1]=oBuff[2];
+                oBuff[2]=s;
         }
-        else
+        int iStrideTab2[3],iStrideTab[3];
+        for(int i=0;i&lt;3;i++) 
         {
-                iBuff[0]= YPLANE((tmpImage));
-                iBuff[1]= UPLANE((tmpImage));
-                iBuff[2]= VPLANE((tmpImage));
-
-                strideTab[0]=strideTab2[0]=_info.width;
-                strideTab[1]=strideTab2[1]=_info.width&gt;&gt;1;
-                strideTab[2]=strideTab2[2]=_info.width&gt;&gt;1;
+            iStrideTab[i]=strideTab[i];
+            iStrideTab2[i]=strideTab2[i];
+            xBuff[i]=iBuff[i];
         }
-        if(_pp.swapuv)
-        {
-                oBuff[0]= YPLANE(out);
-                oBuff[1]= VPLANE(out);
-                oBuff[2]= UPLANE(out);
-        }else
-        {
-
-                oBuff[0]= YPLANE(out);
-                oBuff[1]= UPLANE(out);
-                oBuff[2]= VPLANE(out);
-        }
         pp_postprocess(
-            iBuff,
-            strideTab,
+            xBuff,
+            iStrideTab,
             oBuff,
-            strideTab2,
+            iStrideTab2,
             ww,
             _info.height,
             (int8_t *)(tmpImage-&gt;quant),
@@ -438,8 +419,8 @@
                 right=_info.width-left;
                 // Luma
                 dst=YPLANE(out)+right;
-                src=tmpImage-&gt;_planes[0]+right;
-                stridein=tmpImage-&gt;_planeStride[0];
+                src=tmpImage-&gt;GetReadPtr(PLANAR_Y)+right;
+                stridein=tmpImage-&gt;GetPitch(PLANAR_Y);
                 strideout=_info.width;
                 for(uint32_t y=_info.height;y&gt;0;y--)
                 {
@@ -452,8 +433,9 @@
                 right&gt;&gt;=1;
                 //
                 dst=UPLANE(out)+right;
-                src=tmpImage-&gt;_planes[1]+right;
-                stridein=tmpImage-&gt;_planeStride[1];
+                src=tmpImage-&gt;GetReadPtr(PLANAR_U)+right;
+                stridein=tmpImage-&gt;GetPitch(PLANAR_U);
+
                 strideout=_info.width&gt;&gt;1;
                 for(uint32_t y=_info.height&gt;&gt;1;y&gt;0;y--)
                 {
@@ -463,8 +445,8 @@
                 }
                 //
                 dst=VPLANE(out)+right;
-                src=tmpImage-&gt;_planes[2]+right;
-                stridein=tmpImage-&gt;_planeStride[2];
+                src=tmpImage-&gt;GetReadPtr(PLANAR_V)+right;
+                stridein=tmpImage-&gt;GetPitch(PLANAR_V);
                 strideout=_info.width&gt;&gt;1;
                 for(uint32_t y=_info.height&gt;&gt;1;y&gt;0;y--)
                 {

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.cpp	2010-05-14 15:34:12 UTC (rev 6182)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_editor/ADM_edit.cpp	2010-05-14 15:34:19 UTC (rev 6183)
@@ -244,7 +244,7 @@
         updatePostProc(&amp;_pp);
 
         if(_imageBuffer) delete _imageBuffer;
-        _imageBuffer=new ADMImage(info.width,info.height);
+        _imageBuffer=new ADMImageDefault(info.width,info.height);
         _imageBuffer-&gt;_qSize= ((info.width+15)&gt;&gt;4)*((info.height+15)&gt;&gt;4);
         _imageBuffer-&gt;quant=new uint8_t[_imageBuffer-&gt;_qSize];
         memset(_imageBuffer-&gt;quant,0,_imageBuffer-&gt;_qSize);

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_preview.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_preview.cpp	2010-05-14 15:34:12 UTC (rev 6182)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_preview.cpp	2010-05-14 15:34:19 UTC (rev 6183)
@@ -38,7 +38,7 @@
 #include &quot;ADM_render/GUI_render.h&quot;
 #include &quot;ADM_commonUI/GUI_ui.h&quot;
 #include &quot;ADM_preview.h&quot;
-
+#include &quot;ADM_imageResizer.h&quot;
 #include &quot;DIA_coreToolkit.h&quot;
 
 
@@ -79,7 +79,7 @@
 {
   
   if(rdrImage) delete rdrImage;
-  rdrImage=new ADMImage(w,h);
+  rdrImage=new ADMImageDefault(w,h);
   rdrPhysicalW=w;
   rdrPhysicalH=h;
   renderDisplayResize(rdrPhysicalW,rdrPhysicalH,zoom);

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_render/GUI_sdlRender.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_render/GUI_sdlRender.cpp	2010-05-14 15:34:12 UTC (rev 6182)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_render/GUI_sdlRender.cpp	2010-05-14 15:34:19 UTC (rev 6183)
@@ -284,7 +284,8 @@
 		}
 	}
 #endif
-
+#warning FIXME
+#if 0
 int pitch;
 int w=imageWidth;
 int h=imageHeight;
@@ -313,7 +314,8 @@
 	            memcpy(sdl_overlay-&gt;pixels[2],ptr+(page*5)/4,(w*h)&gt;&gt;2);
 	        else
 	            interleave(sdl_overlay-&gt;pixels[2],ptr+(page*5)/4,w&gt;&gt;1,pitch,h&gt;&gt;1);
-        }else
+        }else
+#endif
         {
 #if 0
 	        color-&gt;changeWidthHeight(w,h);

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_render/GUI_simpleRender.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_render/GUI_simpleRender.cpp	2010-05-14 15:34:12 UTC (rev 6182)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_render/GUI_simpleRender.cpp	2010-05-14 15:34:19 UTC (rev 6183)
@@ -59,7 +59,7 @@
 */
 bool simpleRender::displayImage(ADMImage *pic)
 {
-    scaler-&gt;convert(pic-&gt;data,videoBuffer);
+    scaler-&gt;convertImage(pic,videoBuffer);
     // Display RGB data
     MUI_rgbDraw(MUI_getDrawWidget(),displayWidth,displayHeight,videoBuffer);
     return true;

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_render/GUI_xvRender.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_render/GUI_xvRender.cpp	2010-05-14 15:34:12 UTC (rev 6182)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_render/GUI_xvRender.cpp	2010-05-14 15:34:19 UTC (rev 6183)
@@ -41,7 +41,7 @@
 static uint8_t 	GUI_XvList(Display * dis, uint32_t port, uint32_t * fmt);
 static uint8_t 	GUI_XvInit(GUI_WindowInfo * window, uint32_t w, uint32_t h);
 static void 	GUI_XvEnd( void );
-static uint8_t  GUI_XvDisplay(uint8_t * src, uint32_t w, uint32_t h,uint32_t destW,uint32_t destH);
+static uint8_t  GUI_XvDisplay(ADMImage *src, uint32_t w, uint32_t h,uint32_t destW,uint32_t destH);
 static uint8_t  GUI_XvRedraw( void );
 static uint8_t  getAtom(const char *string);
 //________________Wrapper around Xv_______________
@@ -76,7 +76,7 @@
 */
 bool XvRender::displayImage(ADMImage *pic)
 {
-	return GUI_XvDisplay(pic-&gt;data, imageWidth, imageHeight,displayWidth,displayHeight);
+	return GUI_XvDisplay(pic, imageWidth, imageHeight,displayWidth,displayHeight);
 }
 
 /**
@@ -136,7 +136,7 @@
 /**
     \fn GUI_XvList
 */
-uint8_t GUI_XvDisplay(uint8_t * src, uint32_t w, uint32_t h,uint32_t destW,uint32_t destH)
+uint8_t GUI_XvDisplay(ADMImage * src, uint32_t w, uint32_t h,uint32_t destW,uint32_t destH)
 {
     
     if (xvimage)
@@ -147,7 +147,12 @@
 	  // for YV12, 4 bits for Y 4 bits for u, 4 bits for v
 	  // total 1.5*
           XLockDisplay (xv_display);
-          memcpy(xvimage-&gt;data, src, (w*h*3)&gt;&gt;1);
+          // Pack src into xvimage-&gt;data
+            int plane=w*h;
+          BitBlit((uint8_t *)xvimage-&gt;data, w,src-&gt;GetReadPtr(PLANAR_Y),src-&gt;GetPitch(PLANAR_Y),w,h);
+          BitBlit((uint8_t *)xvimage-&gt;data+plane, w/2,src-&gt;GetReadPtr(PLANAR_U),src-&gt;GetPitch(PLANAR_U),w/2,h/2);
+          BitBlit((uint8_t *)xvimage-&gt;data+(plane*5)/4, w/2,src-&gt;GetReadPtr(PLANAR_V),src-&gt;GetPitch(PLANAR_V),w/2,h/2);
+          
         //printf(&quot;%u x %u =&gt; %u x %u\n&quot;,w,h,destW,destH);
         // And display it !
 #if 1

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoCodec/src/ADM_ffmpeg_vdpau.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoCodec/src/ADM_ffmpeg_vdpau.cpp	2010-05-14 15:34:12 UTC (rev 6182)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoCodec/src/ADM_ffmpeg_vdpau.cpp	2010-05-14 15:34:19 UTC (rev 6183)
@@ -244,7 +244,7 @@
             }
             VDPAU-&gt;freeQueue.push_back(VDPAU-&gt;renders[i]);
         }
-        scratch=new ADMImage(w,h,ADM_IMAGE_REF);
+        scratch=new ADMImageRef(w,h);
         b_age = ip_age[0] = ip_age[1] = 256*256*256*64;
 
 }
@@ -295,7 +295,7 @@
         return 0;
     }
     // other part will be done in goOn
-  struct vdpau_render_state *rndr = (struct vdpau_render_state *)scratch-&gt;_planes[0];
+  struct vdpau_render_state *rndr = (struct vdpau_render_state *)scratch-&gt;GetWritePtr(PLANAR_Y);
    VdpVideoSurface  surface;
 
     surface=rndr-&gt;surface;

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter2/src/ADM_filterThread.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter2/src/ADM_filterThread.cpp	2010-05-14 15:34:12 UTC (rev 6182)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_videoFilter2/src/ADM_filterThread.cpp	2010-05-14 15:34:19 UTC (rev 6183)
@@ -29,7 +29,7 @@
     for(int i=0;i&lt;ADM_THREAD_QUEUE_SIZE;i++)
     {
         ADM_queuePacket item;
-        item.data=(uint8_t *)new ADMImage(info.width,info.height);
+        item.data=(uint8_t *)new ADMImageDefault(info.width,info.height);
         freeList.push_back(item);
     }
 }

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/gui_blackframes.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/gui_blackframes.cpp	2010-05-14 15:34:12 UTC (rev 6182)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/gui_blackframes.cpp	2010-05-14 15:34:19 UTC (rev 6183)
@@ -96,7 +96,7 @@
 
     int cnt4=0;
 
-    start=img-&gt;data+ sz*sliceNum;
+    start=img-&gt;GetReadPtr(PLANAR_Y)+ sz*sliceNum;
     buff=start+sz;
 
     while(--buff&gt;start)

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/gui_save.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/gui_save.cpp	2010-05-14 15:34:12 UTC (rev 6182)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/gui_save.cpp	2010-05-14 15:34:19 UTC (rev 6183)
@@ -389,7 +389,7 @@
         // Split name into base + extension
         ADM_PathSplit(name,&amp;baseName,&amp;ext);
 
-        src=new ADMImage(avifileinfo-&gt;width,avifileinfo-&gt;height);
+        src=new ADMImageDefault(avifileinfo-&gt;width,avifileinfo-&gt;height);
         ADM_assert(src);
 
         working=createWorking(QT_TR_NOOP(&quot;Saving as set of jpegs&quot;));

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImage/include/ADM_colorspace.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImage/include/ADM_colorspace.h	2010-05-14 15:34:12 UTC (rev 6182)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImage/include/ADM_colorspace.h	2010-05-14 15:34:19 UTC (rev 6183)
@@ -12,10 +12,10 @@
  *   (at your option) any later version.                                   *
  *                                                                         *
  ***************************************************************************/
- #ifndef ADM_COLORSPACE_H
- #define ADM_COLORSPACE_H
+#ifndef ADM_COLORSPACE_H
+#define ADM_COLORSPACE_H
 #include &quot;ADM_rgb.h&quot; // To have colors
-
+class ADMImage;
 typedef enum 
 {
     ADM_CS_BILINEAR,
@@ -46,6 +46,7 @@
     
 
     bool            convert(uint8_t  *from, uint8_t *to);
+    bool            convertImage(ADMImage *img, uint8_t *to);
     bool            convertPlanes(uint32_t  sourceStride[3],uint32_t destStride[3],     
                                   uint8_t   *sourceData[3], uint8_t *destData[3]);
                     ~ADMColorScalerFull();
@@ -63,6 +64,7 @@
                      {
 
                      }
+                    
 };
 
 // Some misc functions

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImage/include/ADM_image.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImage/include/ADM_image.h	2010-05-14 15:34:12 UTC (rev 6182)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImage/include/ADM_image.h	2010-05-14 15:34:19 UTC (rev 6183)
@@ -37,14 +37,14 @@
 
 //#define vi.num_frames _info.nb_frames
 //#define vi.IsYV12()   1
-#define GetReadPtr GetWritePtr
 #define GetRowSize GetPitch
 
 typedef enum 
 {
-        PLANAR_Y=1,
-        PLANAR_U=2,
-        PLANAR_V=3
+        PLANAR_Y=0,
+        PLANAR_U=1,
+        PLANAR_V=2,
+        PLANAR_LAST=3
         
 } ADM_PLANE;
 
@@ -54,7 +54,11 @@
     ADM_IMAGE_REF,
     ADM_IMAGE_VDPAU
 }ADM_IMAGE_TYPE;
-
+#define YPLANE(x) ((x)-&gt;GetReadPtr(PLANAR_Y))
+#define UPLANE(x) ((x)-&gt;GetReadPtr(PLANAR_U))
+#define VPLANE(x) ((x)-&gt;GetReadPtr(PLANAR_V))
+class ADMImageRef;
+class ADMImageDefault;
 /**
     \class ADMImage
     \brief Stores image
@@ -63,135 +67,106 @@
 class ADMImage
 {
 public:
-        uint32_t        demuxerFrameno;
-  
-        //*****************
-        uint8_t		*data;		/// Pointer to actual image data
-        uint32_t	_width;		/// Width of image
-        uint32_t	_height;	/// Height of image
-        uint32_t	_qStride;	/// Stride of Q infos, usually about width/8 &lt;- ***if 0 means no quant usable***
-        uint8_t		*quant;		/// Byte representing quantize used for this block
-        uint32_t	_Qp;		/// Average quantizer for this image, Default=2
-        uint32_t	_qSize;		/// Size of the *quant field
-        ADM_ASPECT	_aspect;	/// Aspect ratio
-        uint32_t	flags;		/// Flags for this image (AVI_KEY_FRAME/AVI_B_FRAME)
-        uint64_t    Pts;        /// Presentation time in us
-        uint64_t    *_cookie;   /// Used whith vdpau &amp; friends
-// This 3 fields are only used to convery container (reference to other datas)
-// Between codec &amp; editor
+        uint32_t	    _width;		/// Width of image
+        uint32_t	    _height;	/// Height of image
+        uint32_t	    _Qp;		/// Average quantizer for this image, Default=2
+        uint32_t	    flags;		/// Flags for this image (AVI_KEY_FRAME/AVI_B_FRAME)
+        uint64_t        Pts;        /// Presentation time in us
         ADM_IMAGE_TYPE  _imageType;     /// Plain image or reference or vdpau wrapper
         ADM_colorspace  _colorspace;    /// Colorspace we are moving, default is YV12
         uint8_t         _noPicture;     /// No picture to display
+        ADM_ASPECT	    _aspect;	/// Aspect ratio
+        // Quant info
+        uint8_t         *quant;
+        int             _qStride;
+        int             _qSize;
+        bool            GetPitches(uint32_t *pitches) {pitches[0]=GetPitch(PLANAR_Y);
+                                                       pitches[1]=GetPitch(PLANAR_U);
+                                                       pitches[2]=GetPitch(PLANAR_V);}
+        bool            GetWritePlanes(uint8_t **planes) {planes[0]=GetWritePtr(PLANAR_Y);
+                                                        planes[1]=GetWritePtr(PLANAR_U);
+                                                        planes[2]=GetWritePtr(PLANAR_V);}
+        bool            GetReadPlanes(uint8_t **planes) {planes[0]=GetReadPtr(PLANAR_Y);
+                                                         planes[1]=GetReadPtr(PLANAR_U);
+                                                         planes[2]=GetReadPtr(PLANAR_V);}
 
-// End of section dedicated to codec/editor transfer
-
-        void            commonInit(uint32_t w,uint32_t h); /// sub constructor
+virtual                 ~ADMImage();        
         
-        uint32_t        GetPitch(ADM_PLANE plane)
-                                {
-                                        switch(plane)
-                                        {
-                                                case PLANAR_Y:return _width;break;
-                                                case PLANAR_U:
-                                                case PLANAR_V:return _width&gt;&gt;1;break;
-                                                default: ADM_assert(0);
-                                        }
-                                        return 0;
-                                };
-        uint8_t         *GetWritePtr(ADM_PLANE plane)
-                        {       
-                                uint32_t plan=_width*_height;
-                                switch(plane)
-                                        {
-                                                case PLANAR_Y:return data;break;
-                                                case PLANAR_U:return data+plan;break;
-                                                case PLANAR_V:return data+((plan*5)&gt;&gt;2);break;
-                                                default: ADM_assert(0);
-                                        }
-                                return NULL;
-                        };
-   
-        uint32_t GetHeight(ADM_PLANE plane)
-                                {
-                                        switch(plane)
-                                        {
-                                                case PLANAR_Y:return _height;break;
-                                                case PLANAR_U:
-                                                case PLANAR_V:return _height&gt;&gt;1;break;
-                                                default: ADM_assert(0);
-                                        }
-                                        return 0;
-                                };
-        uint8_t duplicateMacro(ADMImage *src,uint32_t swap);       /// copy an image to ourself, including info
+
+protected:
+        ADMImage(uint32_t width, uint32_t height,ADM_IMAGE_TYPE type);
 public:
+        virtual      uint32_t        GetPitch(ADM_PLANE plane)=0;
+        virtual      uint8_t        *GetWritePtr(ADM_PLANE plane)=0;
+        virtual      uint8_t        *GetReadPtr(ADM_PLANE plane)=0;
+        virtual      bool           isWrittable(void)=0;
+        virtual      ADMImageRef    *castToRef(void) {return NULL;};
+        
+        virtual      bool           duplicateMacro(ADMImage *src,bool swap);       /// copy an image to ourself, including info 
 
-        uint8_t         *_planes[3];     /// In case of linked data store y/u/v pointers
-        uint32_t        _planeStride[3]; /// Same story
-
-                ADMImage(uint32_t width, uint32_t height,ADM_IMAGE_TYPE type=ADM_IMAGE_DEFAULT);
-                
-
-        uint8_t   LumaReduceBy2(void);
-                ~ADMImage();
-        uint8_t getWidthHeight(uint32_t *w,uint32_t *h)
-                    {
-                          *w=_width;
-                          *h=_height;
-                          return 1;
-                    }
-        uint8_t duplicate(ADMImage *src);	/// copy an image to ourself, including info
-        uint8_t duplicateSwapUV(ADMImage *src); /// copy an image to ourself, including info
-        uint8_t duplicateFull(ADMImage *src);	/// copy an image to ourself, including info
-        uint8_t copyInfo(ADMImage *src);	/// copy all the flags, not the data themselves
-        uint8_t copyQuantInfo(ADMImage *src);	/// copy quant table if any
+                     uint8_t        getWidthHeight(uint32_t *w,uint32_t *h)
+                                    {
+                                          *w=_width;
+                                          *h=_height;
+                                          return 1;
+                                    }
+        bool    duplicate(ADMImage *src);	/// copy an image to ourself, including info
+        bool    duplicateFull(ADMImage *src);	/// copy an image to ourself, including info
+        bool    copyInfo(ADMImage *src);	/// copy all the flags, not the data themselves
+        bool    copyQuantInfo(ADMImage *src);	/// copy quant table if any
         bool    isRef(void) { if(_imageType==ADM_IMAGE_REF) return true;return false;};
-        uint8_t setLinkInfos(uint8_t *y,        /// To fill in infos for linked image
-                        uint8_t *u,uint8_t *v,uint32_t stridey,
-                        uint32_t strideu, uint32_t stridev);
-        uint8_t merge(ADMImage *src1,ADMImage *src2);
-        uint8_t substract(ADMImage *src1,ADMImage *src2);
-        uint8_t blacken(void);
-        uint8_t copyTo(ADMImage *target, uint32_t x, uint32_t y);
-        uint8_t copyToAlpha(ADMImage *target, uint32_t x, uint32_t y,uint32_t alpha);
-        uint8_t pack(uint8_t invertChroma);     /// Transfer data from planes to regular packed space
-        uint8_t copyLeftSideTo(ADMImage *dest);
+        bool    merge(ADMImage *src1,ADMImage *src2);
+        bool    substract(ADMImage *src1,ADMImage *src2);
+        bool    blacken(void);
+        bool    copyTo(ADMImage *target, uint32_t x, uint32_t y);
+        bool    copyToAlpha(ADMImage *target, uint32_t x, uint32_t y,uint32_t alpha);
+        bool    copyLeftSideTo(ADMImage *dest);
         /* Some utilitarian functions */
-        uint8_t  saveAsBmp(const char *filename);
-        uint8_t  saveAsJpg(const char *filename);
-        bool     printString(uint32_t x,uint32_t y, const char *strng);
+        bool    saveAsBmp(const char *filename);
+        bool    saveAsJpg(const char *filename);
+        bool    printString(uint32_t x,uint32_t y, const char *strng);
         
 static uint32_t lumaDiff(ADMImage *src1,ADMImage *src2,uint32_t noise);
 };
-void drawString(ADMImage *dst, int x, int y, const char *s) ;
-#define YPLANE(x) ((x)-&gt;data)
-#define UPLANE(x) ((x)-&gt;data+((x)-&gt;_width*(x)-&gt;_height))
-#define VPLANE(x) ((x)-&gt;data+(5*((x)-&gt;_width*(x)-&gt;_height)&gt;&gt;2))
 
 /**
-        \class ADMImageResizer
-        \brief Simple image resizer
+    \class ADMImageDefault
 */
-class ADMImageResizer
+class ADMImageDefault: public ADMImage
 {
-	private:
-		ADMColorScalerFull   *resizer;
-        ADM_colorspace orgFormat, destFormat;
-		uint32_t orgWidth, orgHeight;
-		uint32_t destWidth, destHeight;
-        void        init(uint32_t ow, uint32_t oh, uint32_t dw, uint32_t dh, ADM_colorspace srcFormat, ADM_colorspace dstFormat);
-	public:
-		ADMImageResizer(uint32_t ow,uint32_t oh, uint32_t dw, uint32_t dh);
-		ADMImageResizer(uint32_t ow, uint32_t oh, uint32_t dw, uint32_t dh, ADM_colorspace srcFormat, ADM_colorspace dstFormat);
-		~ADMImageResizer();
-		
-		uint8_t resize(ADMImage *src, ADMImage *dest);
-		uint8_t resize(uint8_t *src, ADMImage *dest);
-		uint8_t resize(ADMImage *src, uint8_t *dest);
-		uint8_t resize(uint8_t *src, uint8_t *dest);
+protected:
+                    uint8_t         *data;
+public:
+                                    ADMImageDefault(uint32_t w, uint32_t h);
+        virtual      ~ADMImageDefault();
+        virtual      uint32_t        GetPitch(ADM_PLANE plane);
+        virtual      uint8_t        *GetWritePtr(ADM_PLANE plane);
+        virtual      uint8_t        *GetReadPtr(ADM_PLANE plane);
+        virtual      bool           isWrittable(void);
 };
+/**
+    \class ADMImageRef
+*/
+class ADMImageRef: public ADMImage
+{
+public:
+        uint8_t         *_planes[3];     /// In case of linked data store y/u/v pointers
+        uint32_t        _planeStride[3]; /// Same story
 
+public:
+                        ADMImageRef(uint32_t w, uint32_t h);
+        virtual      ~ADMImageRef();
+        virtual      uint32_t        GetPitch(ADM_PLANE plane);
+        virtual      uint8_t        *GetWritePtr(ADM_PLANE plane);
+        virtual      uint8_t        *GetReadPtr(ADM_PLANE plane);
+        virtual      bool           isWrittable(void);
+        virtual      ADMImageRef    *castToRef(void) {return this;};
+};
+
+void drawString(ADMImage *dst, int x, int y, const char *s) ;
+
 // Misc utilities
-uint8_t BitBlit(uint8_t *dst, uint32_t pitchDest,uint8_t *src,uint32_t pitchSrc,uint32_t width, uint32_t height);
-uint8_t BitBlitAlpha(uint8_t *dst, uint32_t pitchDst,uint8_t *src,uint32_t pitchSrc,uint32_t width, uint32_t height,uint32_t alpha);
+bool BitBlit(uint8_t *dst, uint32_t pitchDest,uint8_t *src,uint32_t pitchSrc,uint32_t width, uint32_t height);
+bool BitBlitAlpha(uint8_t *dst, uint32_t pitchDst,uint8_t *src,uint32_t pitchSrc,uint32_t width, uint32_t height,uint32_t alpha);
 
 #endif

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImage/include/ADM_imageResizer.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImage/include/ADM_imageResizer.h	2010-05-14 15:34:12 UTC (rev 6182)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImage/include/ADM_imageResizer.h	2010-05-14 15:34:19 UTC (rev 6183)
@@ -0,0 +1,50 @@
+//
+// C++ Interface: %{MODULE}
+//
+// Description: 
+//
+//
+// Author: %{AUTHOR} &lt;%{EMAIL}&gt;, (C) %{YEAR}
+//
+// Copyright: See COPYING file that comes with this distribution
+//
+//
+//	This is the base time for image exchanged between codec/filters/...
+//
+//	We (optionnally) can carry extra informations
+//		- aspect ratio
+//		- frame type
+//		- quantizer for each macroblock (16x16 pixels)
+//      - PTS : Presentation time in us of the image
+//	For the latter 3 infos are used
+//		quant which leads to the int8 quant array
+//		qstride = stride of array. Usually width+15)/16. 0 MEANS NOT USABLE
+//		qsize = size of the array (needed to be able to copy it)
+//
+#ifndef ADM_IMAGE_RESIZER_H
+#define ADM_IMAGE_RESIZER_H
+#include &quot;ADM_image.h&quot;
+/**
+        \class ADMImageResizer
+        \brief Simple image resizer
+*/
+class ADMImageResizer
+{
+	private:
+		ADMColorScalerFull   *resizer;
+        ADM_colorspace orgFormat, destFormat;
+		uint32_t orgWidth, orgHeight;
+		uint32_t destWidth, destHeight;
+        void        init(uint32_t ow, uint32_t oh, uint32_t dw, uint32_t dh, ADM_colorspace srcFormat, ADM_colorspace dstFormat);
+	public:
+		ADMImageResizer(uint32_t ow,uint32_t oh, uint32_t dw, uint32_t dh);
+		ADMImageResizer(uint32_t ow, uint32_t oh, uint32_t dw, uint32_t dh, ADM_colorspace srcFormat, ADM_colorspace dstFormat);
+		~ADMImageResizer();
+		
+		uint8_t resize(ADMImage *src, ADMImage *dest);
+		uint8_t resize(uint8_t *src, ADMImage *dest);
+		uint8_t resize(ADMImage *src, uint8_t *dest);
+		uint8_t resize(uint8_t *src, uint8_t *dest);
+};
+
+#endif

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImage/src/ADM_colorspace.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImage/src/ADM_colorspace.cpp	2010-05-14 15:34:12 UTC (rev 6182)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImage/src/ADM_colorspace.cpp	2010-05-14 15:34:19 UTC (rev 6183)
@@ -17,8 +17,8 @@
 
 #include &quot;ADM_default.h&quot;
 #include &quot;ADM_colorspace.h&quot;
+#include &quot;ADM_image.h&quot;
 
-
 extern &quot;C&quot; {
 #include &quot;ADM_ffmpeg/libavcodec/avcodec.h&quot;
 #include &quot;ADM_ffmpeg/libavutil/avutil.h&quot;
@@ -272,4 +272,26 @@
     return true;
 }
 
+/**
+    \fn convertColorSpace
+*/
+bool ADMColorScalerFull::convertImage(ADMImage *img, uint8_t *to)
+{
+    uint8_t *srcPlanes[3];
+    uint8_t *dstPlanes[3];
+    uint32_t srcPitch[3];
+    uint32_t dstPitch[3];
+    img-&gt;GetPitches(srcPitch);
+    img-&gt;GetReadPlanes(srcPlanes);
+    int w=img-&gt;_width;
+    int h=img-&gt;_height;
+    int plane=w*h;
+    dstPitch[0]=w;
+    dstPitch[1]=w/2;
+    dstPitch[2]=w/2;
+    dstPlanes[0]=to;
+    dstPlanes[1]=to+plane;
+    dstPlanes[2]=to+(plane*5)/4;;
+    return  convertPlanes(srcPitch,dstPitch,srcPlanes,dstPlanes);
+}
 //EOF

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImage/src/ADM_image.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImage/src/ADM_image.cpp	2010-05-14 15:34:12 UTC (rev 6182)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImage/src/ADM_image.cpp	2010-05-14 15:34:19 UTC (rev 6183)
@@ -1,8 +1,6 @@
 /***************************************************************************
-    copyright            : (C) 2003-2005 by mean
-    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
+    \author  MEan (C) 2003-20010 by mean <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
  ***************************************************************************/
-
 /***************************************************************************
  *                                                                         *
  *   This program is free software; you can redistribute it and/or modify  *
@@ -34,345 +32,43 @@
 	printf(&quot;Cur image used               : %&quot;LU&quot;\n&quot;,imgCurNb);
 
 }
-//
-//	Allocate and initialize everything to default values
-//
-void    ADMImage::commonInit(uint32_t w,uint32_t h)
+/**
+    \fn ADMImage
+    \brief ctor
+*/
+ADMImage::ADMImage(uint32_t width, uint32_t height,ADM_IMAGE_TYPE type)
 {
-        _width=w;
-        _height=h;
-        quant=NULL;
-        _qStride=0;
+        _width=width;
+        _height=height;
         _Qp=2;
         flags=0;
-        _qSize=0;
         _aspect=ADM_ASPECT_1_1;
-
         imgCurNb++;
-        _planes[0]=_planes[1]=_planes[2]=NULL;
         _noPicture=0;
         _colorspace=ADM_COLOR_YV12;
         Pts=0;
-
-}
-/**
-    \fn ADMImage
-    \brief ctor
-*/
-ADMImage::ADMImage(uint32_t width, uint32_t height,ADM_IMAGE_TYPE type)
-{
-        commonInit(width,height);
         _imageType=type;
-        data=NULL;
-        _cookie=NULL;
-        _planes[0]=_planes[1]=_planes[2]=NULL;
-        switch(_imageType)
-        {
-            case ADM_IMAGE_DEFAULT:
-                data=new uint8_t [ ((width+15)&amp;0xffffff0)*((height+15)&amp;0xfffffff0)*2];
-                ADM_assert(data);
-                imgCurMem+=(width*height*3)&gt;&gt;1;
-                if(imgCurMem&gt;imgMaxMem) imgMaxMem=imgCurMem;
-                if(imgCurNb&gt;imgMaxNb) imgMaxNb=imgCurNb;
-                break;
-            case ADM_IMAGE_REF:
-                break;
-            case ADM_IMAGE_VDPAU:
-                break;
-            default:
-                ADM_assert(0);
-
-        }
-};
-//
-//	Deallocate
-//
-ADMImage::~ADMImage()
-{
-    if(_imageType==ADM_IMAGE_DEFAULT)
-    {
-       if(quant) delete [] quant;
-       quant=NULL;
-       if(data) delete [] data;
-       data=NULL;
-       imgCurMem-=(_width*_height*3)&gt;&gt;1;
-	}
-	imgCurNb--;
-
-}
-
-//
-//	Duplicate
-//
-uint8_t ADMImage::duplicateMacro(ADMImage *src,uint32_t swap)
-{
-        // Sanity check
-        ADM_assert(src-&gt;_width==_width);
-        ADM_assert(src-&gt;_height==_height);
-
-        ADM_assert(_imageType==ADM_IMAGE_DEFAULT); // could not duplicate to a linked data image
-
-        // cleanup if needed
-        if(quant) delete [] quant;
         quant=NULL;
-
-       _qStride=0;
+        _qStride=0;
         _qSize=0;
-
-        copyInfo(src);
-        if(src-&gt;_imageType==ADM_IMAGE_DEFAULT)
-        {
-               memcpy(YPLANE(this),YPLANE(src),_width*_height);
-                if(swap)
-                {
-                        memcpy(UPLANE(this),VPLANE(src),(_width*_height)&gt;&gt;2);
-                        memcpy(VPLANE(this),UPLANE(src),(_width*_height)&gt;&gt;2);
-                }
-                else
-                {
-                        memcpy(UPLANE(this),UPLANE(src),(_width*_height)&gt;&gt;2);
-                        memcpy(VPLANE(this),VPLANE(src),(_width*_height)&gt;&gt;2);
-                }
-        }
-        else
-        {
-                if(src-&gt;_imageType!=ADM_IMAGE_REF) ADM_assert(0);
-                if(src-&gt;_noPicture)
-                {
-                        // no pic available, blacken it
-                        memset(YPLANE(this),0,_width*_height);
-                        memset(UPLANE(this),128,(_width*_height)&gt;&gt;2);
-                        memset(VPLANE(this),128,(_width*_height)&gt;&gt;2);
-                        return 1;
-
-                }
-               // The source is a reference
-                // We have to use the alternate informations
-                // to copy &amp; compact at the same time
-                //
-
-                ADM_assert(src-&gt;_planeStride[0]);
-                ADM_assert(src-&gt;_planeStride[1]);
-                ADM_assert(src-&gt;_planeStride[2]);
-
-                ADM_assert(src-&gt;_planes[0]);
-                ADM_assert(src-&gt;_planes[1]);
-                ADM_assert(src-&gt;_planes[2]);
-
-                uint8_t *in,*out;
-                uint32_t w,h,stride;
-
-                w=src-&gt;_width;
-                h=src-&gt;_height;
-                stride=src-&gt;_planeStride[0];
-                out=YPLANE(this);
-                in=src-&gt;_planes[0];
-#define PLANE_CPY(h) \
-                for(uint32_t y=0;y&lt;h;y++)  \
-                { \
-                        memcpy(out,in,w); \
-                        in+=stride;       \
-                        out+=w;           \
-                }
-                PLANE_CPY(h);
-
-                w&gt;&gt;=1;
-                h&gt;&gt;=1;
-                in=src-&gt;_planes[1];
-                if(swap)
-                        out=VPLANE(this);
-                else
-                        out=UPLANE(this);
-                stride=src-&gt;_planeStride[1];
-                PLANE_CPY(h);
-
-                in=src-&gt;_planes[2];
-                if(swap)
-                        out=UPLANE(this);
-                else
-                        out=VPLANE(this);
-                stride=src-&gt;_planeStride[2];
-                PLANE_CPY(h);
-
-
-        }
-        return 1;
-}
-uint8_t ADMImage::duplicate(ADMImage *src)
-{
-	return duplicateMacro(src,0);
-}
-uint8_t ADMImage::duplicateSwapUV(ADMImage *src)
-{
-        return duplicateMacro(src,0);
-}
-uint8_t ADMImage::pack(uint8_t invertChroma)
-{
-int u=1,v=2;
-    if(invertChroma) {u=2;v=1;}
-    ADM_assert(_planeStride[0]&gt;=_width);
-    // Pack luma
-    uint8_t *src,*dest;
-
-    src=_planes[0];
-    dest=YPLANE(this);
-    BitBlit(dest,_width,src,_planeStride[0],_width,_height);
-
-    src=_planes[u];
-    dest=UPLANE(this);
-    BitBlit(dest,_width&gt;&gt;1,src,_planeStride[u],_width&gt;&gt;1,_height&gt;&gt;1);
-
-    src=_planes[v];
-    dest=VPLANE(this);
-    BitBlit(dest,_width&gt;&gt;1,src,_planeStride[v],_width&gt;&gt;1,_height&gt;&gt;1);
-
-    return 1;
-}
-uint8_t ADMImage::duplicateFull(ADMImage *src)
-{
-	// Sanity check
-	ADM_assert(src-&gt;_width==_width);
-	ADM_assert(src-&gt;_height==_height);
-
-
-	copyInfo(src);
-    ADM_assert(_imageType==ADM_IMAGE_DEFAULT);
-
-	memcpy(YPLANE(this),YPLANE(src),_width*_height);
-	memcpy(UPLANE(this),UPLANE(src),(_width*_height)&gt;&gt;2);
-	memcpy(VPLANE(this),VPLANE(src),(_width*_height)&gt;&gt;2);
-	copyQuantInfo(src);
-
-	return 1;
-}
+};
 /**
-    \fn copyInfo
-    \brief Copy the additionnal infos attached to an image (flags/aspect ration/PTS)
-*/
-uint8_t ADMImage::copyInfo(ADMImage *src)
-{
-	_Qp=src-&gt;_Qp;
-	flags=src-&gt;flags;
-	_aspect=src-&gt;_aspect;
-    Pts=src-&gt;Pts;
-    return 1;
-}
-//
-//	By design the reallocation of quant should happen at startup
-//	but not in processing itself (reuse already allocated quant)
-//	It may seem shoddy, but it adds flexibility
-//
-uint8_t ADMImage::copyQuantInfo(ADMImage *src)
-{
-	if(!src-&gt;_qStride || !src-&gt;_qSize)  // No (usable) quant
-	{
-		_qStride=0;
-		return 1;
-	}
-	// Reuse Quant memory ?
-	if(!quant)
-	{	// need a new quant
-		quant=new uint8_t[src-&gt;_qSize];
-		_qSize=src-&gt;_qSize;
+    \fn ADMImage
+    \brief dtor
 
-	}
-
-	// Same size ?
-	ADM_assert(_qSize==src-&gt;_qSize);
-	_qStride=src-&gt;_qStride;
-	memcpy(quant,src-&gt;quant,_qSize);
-
-	return 1;
-}
-uint8_t ADMImage::blacken(void)
-{
-        memset(YPLANE(this),0,_width*_height);
-        memset(UPLANE(this),128,(_width*_height)&gt;&gt;2);
-        memset(VPLANE(this),128,(_width*_height)&gt;&gt;2);
-        return 1;
-
-}
-/*
-    Copy &quot;this&quot; image into dest image at x,y position
-
 */
-uint8_t ADMImage::copyTo(ADMImage *dest, uint32_t x,uint32_t y)
+ADMImage::~ADMImage()
 {
+	imgCurNb--;
 
-    uint32_t box_w=_width, box_h=_height;
-    // Clip if needed
-    if(y&gt;dest-&gt;_height)
-    {
-        printf(&quot;Y out : %u %u\n&quot;,y,dest-&gt;_height);
-         return 1;
-    }
-    if(x&gt;dest-&gt;_width)
-    {
-        printf(&quot;X out : %u %u\n&quot;,x,dest-&gt;_width);
-         return 1;
-    }
-
-    if(x+box_w&gt;dest-&gt;_width) box_w=dest-&gt;_width-x;
-    if(y+box_h&gt;dest-&gt;_height) box_h=dest-&gt;_height-y;
-
-    // do y
-    BitBlit(YPLANE(dest)+x+dest-&gt;_width*y,dest-&gt;_width,
-            data,_width,
-            box_w,box_h);
-    // Do u
-    BitBlit(UPLANE(dest)+x/2+(dest-&gt;_width*y)/4,dest-&gt;_width/2,
-            UPLANE(this),_width&gt;&gt;1,
-            box_w&gt;&gt;1,box_h&gt;&gt;1);
-
-    BitBlit(VPLANE(dest)+x/2+(dest-&gt;_width*y)/4,dest-&gt;_width/2,
-            VPLANE(this),_width&gt;&gt;1,
-            box_w&gt;&gt;1,box_h&gt;&gt;1);
-
-
-    return 1;
-
 }
-/*
-    \fn    copyToAlpha
-    \brief Copy &quot;this&quot; image into dest image at x,y position using alpha alpha
-    @param alpha alpha value (0--255)
 
-*/
-uint8_t ADMImage::copyToAlpha(ADMImage *dest, uint32_t x,uint32_t y,uint32_t alpha)
-{
 
-    uint32_t box_w=_width, box_h=_height;
-    // Clip if needed
-    if(y&gt;dest-&gt;_height)
-    {
-        printf(&quot;Y out : %u %u\n&quot;,y,dest-&gt;_height);
-         return 1;
-    }
-    if(x&gt;dest-&gt;_width)
-    {
-        printf(&quot;X out : %u %u\n&quot;,x,dest-&gt;_width);
-         return 1;
-    }
-
-    if(x+box_w&gt;dest-&gt;_width) box_w=dest-&gt;_width-x;
-    if(y+box_h&gt;dest-&gt;_height) box_h=dest-&gt;_height-y;
-
-    // do y
-    BitBlitAlpha(YPLANE(dest)+x+dest-&gt;_width*y,dest-&gt;_width,         data,_width,            box_w,box_h,alpha);
-    // Do u
-    BitBlitAlpha(UPLANE(dest)+x/2+(dest-&gt;_width*y)/4,dest-&gt;_width/2,   UPLANE(this),_width&gt;&gt;1,  box_w&gt;&gt;1,box_h&gt;&gt;1,alpha);
-    // and V
-    BitBlitAlpha(VPLANE(dest)+x/2+(dest-&gt;_width*y)/4,dest-&gt;_width/2, VPLANE(this),_width&gt;&gt;1, box_w&gt;&gt;1,box_h&gt;&gt;1,alpha);
-
-
-    return 1;
-
-}
 /**
  * 		\fn BitBlitAlpha
  * 		\brief Alpha blit from dst to src
  */
-uint8_t BitBlitAlpha(uint8_t *dst, uint32_t pitchDst,uint8_t *src,uint32_t pitchSrc,
+bool BitBlitAlpha(uint8_t *dst, uint32_t pitchDst,uint8_t *src,uint32_t pitchSrc,
 		uint32_t width, uint32_t height,uint32_t alpha)
 {
 
@@ -392,7 +88,7 @@
     return 1;
 }
 
-uint8_t BitBlit(uint8_t *dst, uint32_t pitchDst,uint8_t *src,uint32_t pitchSrc,uint32_t width, uint32_t height)
+bool BitBlit(uint8_t *dst, uint32_t pitchDst,uint8_t *src,uint32_t pitchSrc,uint32_t width, uint32_t height)
 {
 
     for(int y=0;y&lt;height;y++)
@@ -403,4 +99,68 @@
     }
     return 1;
 }
+//****************************************
+/**
+    \fn ADMImageDefault
+    \brief ctor
+
+*/
+ADMImageDefault::ADMImageDefault(uint32_t w, uint32_t h) : ADMImage(w,h,ADM_IMAGE_DEFAULT)
+{
+    data=new uint8_t [(w*h*3)/2];
+}
+/**
+    \fn ADMImageDefault
+    \brief dtor
+*/
+ADMImageDefault::~ADMImageDefault()
+{
+    if(data) delete [] data;
+    data=NULL;
+}
+bool           ADMImageDefault::isWrittable(void) {return true;}
+uint32_t       ADMImageDefault::GetPitch(ADM_PLANE plane)
+                    {
+                            if(plane==PLANAR_Y) return _width;
+                            return _width/2;
+                        }
+uint8_t        *ADMImageDefault::GetWritePtr(ADM_PLANE plane) {return GetReadPtr(plane);}
+uint8_t        *ADMImageDefault::GetReadPtr(ADM_PLANE plane)
+{
+    int xplane=_width*_height;
+    switch(plane)
+    {
+        case PLANAR_Y: return data;
+        case PLANAR_U: return data+xplane;
+        case PLANAR_V: return data+(5*xplane)/4;
+    }
+}
+//****************************************
+/**
+    \fn ADMImageRef
+    \brief ctor
+
+*/
+ADMImageRef::ADMImageRef(uint32_t w, uint32_t h) : ADMImage(w,h,ADM_IMAGE_REF)
+{
+    _planes[0]=_planes[1]=_planes[2]=NULL;
+    _planeStride[0]=_planeStride[1]=_planeStride[2]=0;
+}
+/**
+    \fn ADMImageRef
+    \brief dtor
+*/
+ADMImageRef::~ADMImageRef()
+{
+}
+bool           ADMImageRef::isWrittable(void) {return false;}
+uint32_t       ADMImageRef::GetPitch(ADM_PLANE plane)
+                    {
+                          return _planeStride[plane];
+                        }
+uint8_t        *ADMImageRef::GetWritePtr(ADM_PLANE plane) {return NULL;}
+uint8_t        *ADMImageRef::GetReadPtr(ADM_PLANE plane)
+{
+    return _planes[plane];
+}
 //EOF

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImage/src/ADM_imageOperation.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImage/src/ADM_imageOperation.cpp	2010-05-14 15:34:12 UTC (rev 6182)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImage/src/ADM_imageOperation.cpp	2010-05-14 15:34:19 UTC (rev 6183)
@@ -0,0 +1,195 @@
+/***************************************************************************
+    copyright            : (C) 2003-2005 by mean
+    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+
+#include &quot;ADM_default.h&quot;
+#include &quot;ADM_image.h&quot;
+/**
+    \fn duplicateMacro
+    \brief copy src to this, swapping u&amp;v possibly
+*/
+bool ADMImage::duplicateMacro(ADMImage *src,bool swap)
+{
+#warning handle swap
+        // Sanity check
+        ADM_assert(src-&gt;_width==_width);
+        ADM_assert(src-&gt;_height==_height);
+        ADM_assert(isWrittable()==true); // could not duplicate to a linked data image
+        copyInfo(src);
+        uint32_t sourceStride,destStride;
+        uint8_t  *source,*dest;
+
+        for(int plane=PLANAR_Y;plane&lt;PLANAR_LAST;plane++)
+        {
+            source=src-&gt;GetReadPtr((ADM_PLANE)plane);
+            dest=this-&gt;GetWritePtr((ADM_PLANE)plane);
+            sourceStride=src-&gt;GetPitch((ADM_PLANE)plane);
+            destStride=this-&gt;GetPitch((ADM_PLANE)plane);
+            int opHeight=_height;
+            int opWidth=_width;
+            if(plane!=PLANAR_Y) 
+            {
+                opHeight&gt;&gt;=1;
+                opWidth&gt;&gt;=1;
+            }
+            BitBlit(dest, destStride,source,sourceStride,opWidth, opHeight);
+        }
+        return true;
+}
+/**
+    \fn duplicate
+*/
+bool ADMImage::duplicate(ADMImage *src)
+{
+	return duplicateMacro(src,false);
+}
+/**
+    \fn duplicateFull
+    \brief copy data + info (pts...)
+*/
+bool ADMImage::duplicateFull(ADMImage *src)
+{
+	// Sanity check
+	ADM_assert(src-&gt;_width==_width);
+	ADM_assert(src-&gt;_height==_height);
+
+
+	copyInfo(src);
+    duplicate(src);
+	return 1;
+}
+/**
+    \fn copyInfo
+    \brief Copy the additionnal infos attached to an image (flags/aspect ration/PTS)
+*/
+bool ADMImage::copyInfo(ADMImage *src)
+{
+	_Qp=src-&gt;_Qp;
+	flags=src-&gt;flags;
+	_aspect=src-&gt;_aspect;
+    Pts=src-&gt;Pts;
+    return 1;
+}
+/**
+    \fn blacken
+*/
+bool ADMImage::blacken(void)
+{
+        ADM_assert(isWrittable()==true); // could not duplicate to a linked data image
+        uint32_t sourceStride,destStride;
+        uint8_t  *source,*dest;
+
+        for(int plane=PLANAR_Y;plane&lt;PLANAR_LAST;plane++)
+        {
+            dest=this-&gt;GetWritePtr((ADM_PLANE)plane);
+            destStride=this-&gt;GetPitch((ADM_PLANE)plane);
+            int opHeight=_height;
+            int opWidth=_width;
+            uint8_t color=0;
+            if(plane!=PLANAR_Y) 
+            {
+                opHeight&gt;&gt;=1;
+                opWidth&gt;&gt;=1;
+                color=128;
+            }
+            for(int y=0;y&lt;opHeight;y++)
+            {
+                memset(dest,color,opWidth);
+                dest+=destStride;
+            }
+        }
+        return true;
+}
+/**
+    \fn copyTo
+    \brief  Copy &quot;this&quot; image into dest image at x,y position
+
+*/
+bool ADMImage::copyTo(ADMImage *dest, uint32_t x,uint32_t y)
+{
+    ADM_assert(0);
+#warning not implemented
+#if 0    
+    uint32_t box_w=_width, box_h=_height;
+    // Clip if needed
+    if(y&gt;dest-&gt;_height)
+    {
+        printf(&quot;Y out : %u %u\n&quot;,y,dest-&gt;_height);
+         return 1;
+    }
+    if(x&gt;dest-&gt;_width)
+    {
+        printf(&quot;X out : %u %u\n&quot;,x,dest-&gt;_width);
+         return 1;
+    }
+
+    if(x+box_w&gt;dest-&gt;_width) box_w=dest-&gt;_width-x;
+    if(y+box_h&gt;dest-&gt;_height) box_h=dest-&gt;_height-y;
+
+    // do y
+    BitBlit(YPLANE(dest)+x+dest-&gt;_width*y,dest-&gt;_width,
+            data,_width,
+            box_w,box_h);
+    // Do u
+    BitBlit(UPLANE(dest)+x/2+(dest-&gt;_width*y)/4,dest-&gt;_width/2,
+            UPLANE(this),_width&gt;&gt;1,
+            box_w&gt;&gt;1,box_h&gt;&gt;1);
+
+    BitBlit(VPLANE(dest)+x/2+(dest-&gt;_width*y)/4,dest-&gt;_width/2,
+            VPLANE(this),_width&gt;&gt;1,
+            box_w&gt;&gt;1,box_h&gt;&gt;1);
+
+#endif
+    return 1;
+
+}
+/**
+    \fn    copyToAlpha
+    \brief Copy &quot;this&quot; image into dest image at x,y position using alpha alpha
+    @param alpha alpha value (0--255)
+
+*/
+bool ADMImage::copyToAlpha(ADMImage *dest, uint32_t x,uint32_t y,uint32_t alpha)
+{
+#warning not implemented
+    ADM_assert(0);
+#if 0
+    uint32_t box_w=_width, box_h=_height;
+    // Clip if needed
+    if(y&gt;dest-&gt;_height)
+    {
+        printf(&quot;Y out : %u %u\n&quot;,y,dest-&gt;_height);
+         return 1;
+    }
+    if(x&gt;dest-&gt;_width)
+    {
+        printf(&quot;X out : %u %u\n&quot;,x,dest-&gt;_width);
+         return 1;
+    }
+
+    if(x+box_w&gt;dest-&gt;_width) box_w=dest-&gt;_width-x;
+    if(y+box_h&gt;dest-&gt;_height) box_h=dest-&gt;_height-y;
+
+    // do y
+    BitBlitAlpha(YPLANE(dest)+x+dest-&gt;_width*y,dest-&gt;_width,         data,_width,            box_w,box_h,alpha);
+    // Do u
+    BitBlitAlpha(UPLANE(dest)+x/2+(dest-&gt;_width*y)/4,dest-&gt;_width/2,   UPLANE(this),_width&gt;&gt;1,  box_w&gt;&gt;1,box_h&gt;&gt;1,alpha);
+    // and V
+    BitBlitAlpha(VPLANE(dest)+x/2+(dest-&gt;_width*y)/4,dest-&gt;_width/2, VPLANE(this),_width&gt;&gt;1, box_w&gt;&gt;1,box_h&gt;&gt;1,alpha);
+
+#endif
+    return 1;
+}
+
+//EOF

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImage/src/ADM_imageResizer.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImage/src/ADM_imageResizer.cpp	2010-05-14 15:34:12 UTC (rev 6182)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImage/src/ADM_imageResizer.cpp	2010-05-14 15:34:19 UTC (rev 6183)
@@ -13,7 +13,7 @@
  ***************************************************************************/
 #include &quot;ADM_default.h&quot;
 
-#include &quot;ADM_image.h&quot;
+#include &quot;ADM_imageResizer.h&quot;
 
 extern &quot;C&quot; {
 #include &quot;ADM_ffmpeg/libavcodec/avcodec.h&quot;
@@ -59,24 +59,69 @@
     ADM_assert(source-&gt;_height == orgHeight);
     ADM_assert(dest-&gt;_width == destWidth);
     ADM_assert(dest-&gt;_height == destHeight);
+    ADM_assert(dest-&gt;isWrittable()==true)
+    uint32_t srcStride[3];
+    uint32_t dstStride[3];
+    uint8_t  *srcPtr[3];
+    uint8_t  *dstPtr[3];
+    for(int i=PLANAR_Y;i&lt;PLANAR_LAST;i++)
+    {
+        srcStride[i]=source-&gt;GetPitch((ADM_PLANE)i);
+        dstStride[i]=dest-&gt;GetPitch((ADM_PLANE)i);
+        srcPtr[i]=source-&gt;GetReadPtr((ADM_PLANE)i);
+        dstPtr[i]=dest-&gt;GetWritePtr((ADM_PLANE)i);
+     }
 
-	return resizer-&gt;convert(source-&gt;data, dest-&gt;data);
+     return resizer-&gt;convertPlanes(srcStride,dstStride,srcPtr,dstPtr);
 }
 
 uint8_t ADMImageResizer::resize(ADMImage *source, uint8_t *dest)
 {
     ADM_assert(source-&gt;_width == orgWidth);
     ADM_assert(source-&gt;_height == orgHeight);
+    uint32_t srcStride[3];
+    uint32_t dstStride[3];
+    uint8_t  *srcPtr[3];
+    uint8_t  *dstPtr[3];
+    for(int i=PLANAR_Y;i&lt;PLANAR_LAST;i++)
+    {
+        srcStride[i]=source-&gt;GetPitch((ADM_PLANE)i);
+        srcPtr[i]=source-&gt;GetReadPtr((ADM_PLANE)i);
+     }
+        dstStride[0]=destWidth;
+        dstStride[1]=destWidth&gt;&gt;1;
+        dstStride[2]=destWidth&gt;&gt;1;
+        uint32_t plane=destWidth*destHeight;
+        dstPtr[0]=dest;
+        dstPtr[1]=dest+plane;
+        dstPtr[2]=dest+((5*plane)&gt;&gt;2);
 
-	return resizer-&gt;convert(source-&gt;data, dest);
+	return resizer-&gt;convertPlanes(srcStride,dstStride,srcPtr,dstPtr);
 }
 
 uint8_t ADMImageResizer::resize(uint8_t *source, ADMImage *dest)
 {
     ADM_assert(dest-&gt;_width == destWidth);
     ADM_assert(dest-&gt;_height == destHeight);
+    ADM_assert(dest-&gt;isWrittable()==true)
+    uint32_t srcStride[3];
+    uint32_t dstStride[3];
+    uint8_t  *srcPtr[3];
+    uint8_t  *dstPtr[3];
+    for(int i=PLANAR_Y;i&lt;PLANAR_LAST;i++)
+    {
+        dstStride[i]=dest-&gt;GetPitch((ADM_PLANE)i);
+        dstPtr[i]=dest-&gt;GetWritePtr((ADM_PLANE)i);
+     }
+        srcStride[0]=orgWidth;
+        srcStride[1]=orgWidth&gt;&gt;1;
+        srcStride[2]=orgWidth&gt;&gt;1;
+        uint32_t plane=orgWidth*orgHeight;
+        srcPtr[0]=source;
+        srcPtr[1]=source+plane;
+        srcPtr[2]=source+((5*plane)&gt;&gt;2);
 
-	return resizer-&gt;convert(source, dest-&gt;data);
+	return resizer-&gt;convertPlanes(srcStride,dstStride,srcPtr,dstPtr);
 }
 
 

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImage/src/ADM_imageSave.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImage/src/ADM_imageSave.cpp	2010-05-14 15:34:12 UTC (rev 6182)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImage/src/ADM_imageSave.cpp	2010-05-14 15:34:19 UTC (rev 6183)
@@ -37,7 +37,7 @@
     \fn saveAsBmp
     \brief save current image into filename, into bmp format
 */
-uint8_t  ADMImage::saveAsBmp(const char *filename)
+bool  ADMImage::saveAsBmp(const char *filename)
 {
   ADM_BITMAPFILEHEADER bmfh;
   ADM_BITMAPINFOHEADER bmph;
@@ -68,7 +68,7 @@
 	bmph.colorEncoding=0;
 */
 
-  ADMImage image(_width,_height);
+  ADMImageDefault image(_width,_height);
 
 
   printf (&quot;\n %u x %u=%u\n&quot;, bmph.biWidth, bmph.biHeight, sz);
@@ -142,7 +142,7 @@
     \fn saveAsJpg
     \brief save current image into filename, into jpg format
 */
-uint8_t  ADMImage::saveAsJpg(const char *filename)
+bool  ADMImage::saveAsJpg(const char *filename)
 {
 
 AVCodecContext   *context=NULL;   

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImage/src/ADM_imageUtils.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImage/src/ADM_imageUtils.cpp	2010-05-14 15:34:12 UTC (rev 6182)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImage/src/ADM_imageUtils.cpp	2010-05-14 15:34:19 UTC (rev 6183)
@@ -112,7 +112,7 @@
 
 #endif
 
-uint8_t ADMImage::merge(ADMImage *src1,ADMImage *src2)
+bool ADMImage::merge(ADMImage *src1,ADMImage *src2)
 {
 #ifdef ADM_CPU_X86
         if(CpuCaps::hasMMX())
@@ -331,7 +331,7 @@
 }
 #endif
 
-uint8_t ADMImage::substract(ADMImage *src1,ADMImage *src2)
+bool ADMImage::substract(ADMImage *src1,ADMImage *src2)
 {
 
 #ifdef ADM_CPU_X86
@@ -344,39 +344,12 @@
         return tinySubstract(YPLANE(this),YPLANE(src1),YPLANE(src2),src1-&gt;_width*src1-&gt;_height);
 }
   
-/**
-      \fn LumaReduceBy2
-      \brief Very simple reduce by 2 both hz &amp; vz for luma plane only.
-*/
- uint8_t   ADMImage::LumaReduceBy2(void)
-{
-  uint8_t *ptr1,*ptr2,*outptr;
-  for(int y=0;y&lt;_height&gt;&gt;1;y++)
-  {
-    
-    ptr1=data+y*_width*2;
-    ptr2=ptr1+_width;
-    outptr=data+(_width&gt;&gt;1)*y;
-    for(int x=0;x&lt;_width&gt;&gt;1;x++)
-    {
-      uint32_t a,b,c,d;  
-          a=ptr1[0]+ptr1[1];
-          b=ptr2[0]+ptr2[1];
-          ptr1+=2;
-          ptr2+=2;
-          a=(a+b)&gt;&gt;2;
-          *outptr++=a;
-    }
-  }
-  return 1;
-  
-}
  /**
   *		\fn  copyLeftSideTo
   * 	\brief Copy half the image (left part) to dest
   * 	@param dest : Image to copy to 
   */
- uint8_t ADMImage::copyLeftSideTo(ADMImage *dest)
+ bool ADMImage::copyLeftSideTo(ADMImage *dest)
  {
 		uint8_t *src,*dst;
 		uint32_t stride;

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImage/src/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImage/src/CMakeLists.txt	2010-05-14 15:34:12 UTC (rev 6182)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImage/src/CMakeLists.txt	2010-05-14 15:34:19 UTC (rev 6183)
@@ -16,6 +16,7 @@
 #        ADM_interlaceUtil.cpp
 #        DIA_flyDialog.cpp
         ADM_imageSave.cpp
+        ADM_imageOperation.cpp
 )
 
 ADD_LIBRARY(ADM_coreImage6 SHARED ${ADM_coreImage_SRCS})

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImageLoader/src/ADM_imageLoader.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImageLoader/src/ADM_imageLoader.cpp	2010-05-14 15:34:12 UTC (rev 6182)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImageLoader/src/ADM_imageLoader.cpp	2010-05-14 15:34:19 UTC (rev 6183)
@@ -148,7 +148,7 @@
 		    fclose(fd);
 		  //
 		    
-		    ADMImage tmpImage(w,h,ADM_IMAGE_REF); // It is a reference image
+		    ADMImageRef tmpImage(w,h); // It is a reference image
 		    // Now unpack it ...
             decoders *dec=ADM_coreCodecGetDecoder (fourCC::get((uint8_t *)&quot;MJPG&quot;),   w,   h, 0 , NULL,0);
             if(!dec)
@@ -168,14 +168,14 @@
 		    case ADM_COLOR_YV12:
 		    {
 		    	ADM_info(&quot;[imageLoader] YV12\n&quot;);
-	    		image=new ADMImage(w,h);
+	    		image=new ADMImageDefault(w,h);
 	    		image-&gt;duplicate(&amp;tmpImage);
 	    		break;
 		    }
 		    case ADM_COLOR_YUV422:
 		    {
 		    	ADM_info(&quot;[imageLoader] YUY2\n&quot;);
-		    	image=new ADMImage(w,h);
+		    	image=new ADMImageDefault(w,h);
                 ADMColorScalerSimple convert(w,h,ADM_COLOR_YUV422,ADM_COLOR_YV12);
                 uint32_t dstStride[3]={w,w/2,w/2};
                 uint8_t  *dstData[3]={YPLANE(image),UPLANE(image),VPLANE(image)};
@@ -244,8 +244,8 @@
 		    
 		  // Colorconversion
 		    
-            ADMImage *image=new ADMImage(w,h);
-            ADM_ConvertRgb24ToYV12(false,w,h,data,image-&gt;data);
+            ADMImage *image=new ADMImageDefault(w,h);
+            ADM_ConvertRgb24ToYV12(false,w,h,data,YPLANE(image));
             
 		    
 		    delete [] data;
@@ -294,8 +294,8 @@
     
   // Colorconversion
     
-    	ADMImage *image=new ADMImage(w,h);
-        ADM_ConvertRgb24ToYV12(true,w,h,data,image-&gt;data);
+    	ADMImage *image=new ADMImageDefault(w,h);
+        ADM_ConvertRgb24ToYV12(true,w,h,data,YPLANE(image));
     	
     
     	delete [] data;
@@ -328,7 +328,7 @@
  	   uint8_t *data=new uint8_t[size];
  	   fread(data,size,1,fd);
  	   fclose(fd);
- 	   ADMImage tmpImage(w,h,ADM_IMAGE_REF);
+ 	   ADMImageRef tmpImage(w,h);
     	// Decode PNG
         decoders *dec=ADM_coreCodecGetDecoder (fourCC::get((uint8_t *)&quot;PNG &quot;),   w,   h, 0 , NULL,0);
     	if(!dec)
@@ -342,8 +342,8 @@
     			    
     	dec-&gt;uncompress (&amp;bin, &amp;tmpImage);
     	
-    	ADMImage *image=new ADMImage(w,h);
-        ADM_ConvertRgb24ToYV12(true,w,h,tmpImage._planes[0],image-&gt;data);
+    	ADMImage *image=new ADMImageDefault(w,h);
+        ADM_ConvertRgb24ToYV12(true,w,h,tmpImage._planes[0],YPLANE(image));
     
     	delete [] data;
         delete dec;

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_codecNull.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_codecNull.h	2010-05-14 15:34:12 UTC (rev 6182)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/include/ADM_codecNull.h	2010-05-14 15:34:19 UTC (rev 6183)
@@ -28,7 +28,27 @@
   };
   virtual bool uncompress (ADMCompressedImage * in, ADMImage * out)
   {
-    memcpy (out-&gt;data, in-&gt;data, in-&gt;dataLength);
+    for(int i=PLANAR_Y;i&lt;PLANAR_LAST;i++)
+    {
+        uint32_t pitch=out-&gt;GetPitch((ADM_PLANE)i);
+        uint32_t line=_w;
+        uint32_t colmn=_h;
+        uint8_t *dest=out-&gt;GetWritePtr((ADM_PLANE)i);
+        if(i!=PLANAR_Y)
+        {
+            line&gt;&gt;=1;
+            colmn&gt;&gt;=1;
+        }
+        uint8_t *src;
+        int plane=_w*_h;
+        switch(i)
+        {
+             case PLANAR_Y: src=in-&gt;data;break;
+             case PLANAR_U: src=in-&gt;data+plane;break;
+             case PLANAR_V: src=in-&gt;data+((plane*5)&gt;&gt;2);break;
+        }
+        BitBlit(dest, pitch,src,line,line,colmn);
+    }
     uint64_t pts,dts;
     pts=in-&gt;demuxerPts;
     dts=in-&gt;demuxerDts;

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_ffmp43.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_ffmp43.cpp	2010-05-14 15:34:12 UTC (rev 6182)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_ffmp43.cpp	2010-05-14 15:34:19 UTC (rev 6183)
@@ -70,8 +70,9 @@
 {
   uint32_t    u,v;
   ADM_assert(out-&gt;isRef());
-  out-&gt;_planes[0] = (uint8_t *) src-&gt;data[0];
-  out-&gt;_planeStride[0] = src-&gt;linesize[0];
+  ADMImageRef *ref=out-&gt;castToRef();
+  ref-&gt;_planes[0] = (uint8_t *) src-&gt;data[0];
+  ref-&gt;_planeStride[0] = src-&gt;linesize[0];
   if (_swapUV)
     {
       u = 1;
@@ -82,11 +83,11 @@
       u = 2;
       v = 1;
     }
-  out-&gt;_planes[1] = (uint8_t *) src-&gt;data[u];
-  out-&gt;_planeStride[1] = src-&gt;linesize[u];
+  ref-&gt;_planes[1] = (uint8_t *) src-&gt;data[u];
+  ref-&gt;_planeStride[1] = src-&gt;linesize[u];
 
-  out-&gt;_planes[2] = (uint8_t *) src-&gt;data[v];
-  out-&gt;_planeStride[2] = src-&gt;linesize[v];
+  ref-&gt;_planes[2] = (uint8_t *) src-&gt;data[v];
+  ref-&gt;_planeStride[2] = src-&gt;linesize[v];
 
   _lastQ = 0;			//_context-&gt;quality;
   out-&gt;_Qp = (src-&gt;quality * 32) / FF_LAMBDA_MAX;
@@ -384,8 +385,7 @@
 	  out-&gt;flags = AVI_KEY_FRAME;
 	  if (!_refCopy)
 	    {
-	      memset (out-&gt;data, 0, _w * _h);
-	      memset (out-&gt;data + _w * _h, 128, (_w * _h) &gt;&gt; 1);
+            out-&gt;blacken();
 	    }
 	  else
 	    {

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_png.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_png.cpp	2010-05-14 15:34:12 UTC (rev 6182)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_png.cpp	2010-05-14 15:34:19 UTC (rev 6183)
@@ -146,17 +146,18 @@
       goto gain2;
     }
   ADM_assert (out-&gt;isRef());
-  out-&gt;_planes[0] = decoded;
-  out-&gt;_planes[1] = NULL;
-  out-&gt;_planes[2] = NULL;
+  ADMImageRef *ref=out-&gt;castToRef();
+  ref-&gt;_planes[0] = decoded;
+  ref-&gt;_planes[1] = NULL;
+  ref-&gt;_planes[2] = NULL;
   if (colorspace == ADM_COLOR_RGB32A)
-    out-&gt;_planeStride[0] = _w * 4;
+    ref-&gt;_planeStride[0] = _w * 4;
 
   else
-    out-&gt;_planeStride[0] = _w * 3;
-  out-&gt;_planeStride[1] = 0;
-  out-&gt;_planeStride[2] = 0;
-  out-&gt;_colorspace = colorspace;
+    ref-&gt;_planeStride[0] = _w * 3;
+  ref-&gt;_planeStride[1] = 0;
+  ref-&gt;_planeStride[2] = 0;
+  ref-&gt;_colorspace = colorspace;
   Cleanup ();
   return true;
 }

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_rgb16.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_rgb16.cpp	2010-05-14 15:34:12 UTC (rev 6182)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_rgb16.cpp	2010-05-14 15:34:19 UTC (rev 6183)
@@ -103,17 +103,17 @@
 	}
 
 	ADM_assert(out-&gt;isRef());
-
+    ADMImageRef *ref=out-&gt;castToRef();
 	out-&gt;flags = AVI_KEY_FRAME;
 	out-&gt;_colorspace = (ADM_colorspace)(colorspace | ADM_COLOR_BACKWARD);
 
-	out-&gt;_planes[0] = decoded;
-	out-&gt;_planes[1] = NULL;
-	out-&gt;_planes[2] = NULL;
+	ref-&gt;_planes[0] = decoded;
+	ref-&gt;_planes[1] = NULL;
+	ref-&gt;_planes[2] = NULL;
 
-	out-&gt;_planeStride[0] = (_bpp / 8) * _w;
-	out-&gt;_planeStride[1] = 0;
-	out-&gt;_planeStride[2] = 0;
+	ref-&gt;_planeStride[0] = (_bpp / 8) * _w;
+	ref-&gt;_planeStride[1] = 0;
+	ref-&gt;_planeStride[2] = 0;
 
 	return 1;
 }

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_uyvy.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_uyvy.cpp	2010-05-14 15:34:12 UTC (rev 6182)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoCodec/src/ADM_uyvy.cpp	2010-05-14 15:34:19 UTC (rev 6183)
@@ -17,7 +17,9 @@
 #include &quot;avifmt2.h&quot;
 #include &quot;fourcc.h&quot;
 #include &quot;ADM_uyvy.h&quot;
-
+/**
+    \fn uncompress
+*/
 bool   decoderUYVY::uncompress (ADMCompressedImage * in, ADMImage * out)
 {
 
@@ -52,6 +54,9 @@
     return 1;
 
 }
+/**
+    \fn uncompress
+*/
 bool   decoderYUY2::uncompress  (ADMCompressedImage * in, ADMImage * out)
 {
 
@@ -61,13 +66,13 @@
       return 1;
     }
   uint8_t *ptrY, *ptrU, *ptrV, *ptr;
-
+  ADM_assert(out-&gt;_imageType=ADM_IMAGE_DEFAULT);
   ptr = in-&gt;data;
-  ptrY = out-&gt;data;
-  ptrV = out-&gt;data + _w * _h;
-  ptrU = out-&gt;data + ((_w * _h * 5) &gt;&gt; 2);
-
-
+  ptrY = YPLANE(out);
+  ptrV = VPLANE(out);
+  ptrU = UPLANE(out);
+  ADM_assert(_w==out-&gt;GetPitch(PLANAR_Y));
+  ADM_assert(_w/2==out-&gt;GetPitch(PLANAR_U));
   for (uint32_t y = 0; y &lt; _h; y++)
     for (uint32_t x = 0; x &lt; (_w &gt;&gt; 1); x++)
       {

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoEncoder/include/ADM_coreVideoEncoderFFmpeg.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoEncoder/include/ADM_coreVideoEncoderFFmpeg.h	2010-05-14 15:34:12 UTC (rev 6182)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoEncoder/include/ADM_coreVideoEncoderFFmpeg.h	2010-05-14 15:34:19 UTC (rev 6183)
@@ -47,6 +47,7 @@
                float            timeScaler;
               
 protected:
+
     virtual               bool             prolog(void); 
     virtual               bool             preEncode(void); 
     virtual               bool             setup(CodecID codecId);

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoEncoder/src/ADM_coreVideoEncoderFFmpeg.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoEncoder/src/ADM_coreVideoEncoderFFmpeg.cpp	2010-05-14 15:34:12 UTC (rev 6182)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoEncoder/src/ADM_coreVideoEncoderFFmpeg.cpp	2010-05-14 15:34:19 UTC (rev 6183)
@@ -44,7 +44,7 @@
     w=getWidth();
     h=getHeight();
 
-    image=new ADMImage(w,h);
+    image=new ADMImageDefault(w,h);
     _context = avcodec_alloc_context2 (CODEC_TYPE_VIDEO);
     ADM_assert (_context);
     memset (&amp;_frame, 0, sizeof (_frame));
@@ -223,7 +223,7 @@
               int w=getWidth();
               int h=getHeight();
 
-                if(!colorSpace-&gt;convert(image-&gt;data,rgbBuffer))
+                if(!colorSpace-&gt;convertImage(image,rgbBuffer))
                 {
                     printf(&quot;[ADM_jpegEncoder::encode] Colorconversion failed\n&quot;);
                     return false;
@@ -234,7 +234,7 @@
                 break;
         }
         case ADM_COLOR_RGB32A:
-                if(!colorSpace-&gt;convert(image-&gt;data,rgbBuffer))
+                if(!colorSpace-&gt;convertImage(image,rgbBuffer))
                 {
                     printf(&quot;[ADM_jpegEncoder::encode] Colorconversion failed\n&quot;);
                     return false;

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/include/DIA_flyDialog.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/include/DIA_flyDialog.h	2010-05-14 15:34:12 UTC (rev 6182)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/include/DIA_flyDialog.h	2010-05-14 15:34:19 UTC (rev 6183)
@@ -41,7 +41,7 @@
 #include &quot;ADM_rgb.h&quot;
 #include &quot;ADM_colorspace.h&quot;
 #include &quot;ADM_coreVideoFilter.h&quot;
-
+#include &quot;ADM_imageResizer.h&quot;
 #define ADM_FLY_SLIDER_MAX 1000
 
 enum ResizeMethod {

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/src/ADM_videoFilterCache.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/src/ADM_videoFilterCache.cpp	2010-05-14 15:34:12 UTC (rev 6182)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/src/ADM_videoFilterCache.cpp	2010-05-14 15:34:19 UTC (rev 6183)
@@ -38,7 +38,7 @@
 	sz=(w*h*3)&gt;&gt;1;
 	for(uint32_t i=0;i&lt;nbEntry;i++)
 	{
-		entry[i].image	=new ADMImage(w,h);	
+		entry[i].image	=new ADMImageDefault(w,h);	
 		entry[i].frameNum	=0xffff0000;
 		entry[i].frameLock	=0;
         entry[i].freeEntry=true;

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/src/DIA_flyDialog.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/src/DIA_flyDialog.cpp	2010-05-14 15:34:12 UTC (rev 6182)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreVideoFilter/src/DIA_flyDialog.cpp	2010-05-14 15:34:19 UTC (rev 6183)
@@ -48,11 +48,11 @@
 
 	_rgb=NULL;
 
-	_yuvBuffer=new ADMImage(_w,_h);
+	_yuvBuffer=new ADMImageDefault(_w,_h);
 
 	if(_isYuvProcessing)
 	{
-		_yuvBufferOut=new ADMImage(_w,_h);
+		_yuvBufferOut=new ADMImageDefault(_w,_h);
 		_rgbBuffer=NULL;
 	}
 	else
@@ -270,9 +270,9 @@
 void ADM_flyDialog::copyYuvFinalToRgb(void)
 {
 	if (_resizeMethod == RESIZE_AUTO || _resizeMethod == RESIZE_LAST)
-		_resizer-&gt;resize(_yuvBufferOut-&gt;data, _rgbBufferOut);
+		_resizer-&gt;resize(_yuvBufferOut, _rgbBufferOut);
 	else
-		_rgb-&gt;convert(_yuvBufferOut-&gt;data, _rgbBufferOut);
+		_rgb-&gt;convertImage(_yuvBufferOut, _rgbBufferOut);
 }
 /**
     \fn    copyYuvScratchToRgb
@@ -282,9 +282,9 @@
 void ADM_flyDialog::copyYuvScratchToRgb(void)
 {
 	if (_resizeMethod == RESIZE_AUTO)
-		_resizer-&gt;resize(_yuvBuffer-&gt;data,_rgbBuffer);
+		_resizer-&gt;resize(_yuvBuffer,_rgbBuffer);
 	else
-		_rgb-&gt;convert(_yuvBuffer-&gt;data,_rgbBuffer);
+		_rgb-&gt;convertImage(_yuvBuffer,_rgbBuffer);
 }
 /**
     \fn    copyRgbFinalToDisplay


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="003385.html">[Avidemux-svn-commit] r6182 - in branches/avidemux_2.6_branch_mean:	avidemux/common/ADM_editor avidemux/common/ADM_videoCodec/src	avidemux_core/ADM_coreImage/include avidemux_core/ADM_coreImage/src	avidemux_core/ADM_coreImageLoader/include	avidemux_core/ADM_coreImageLoader/src	avidemux_core/ADM_coreVideoCodec/src
</A></li>
	<LI>Next message: <A HREF="003387.html">[Avidemux-svn-commit] r6184 -	branches/avidemux_2.6_branch_mean/avidemux_core/ADM_coreImage/src
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3386">[ date ]</a>
              <a href="thread.html#3386">[ thread ]</a>
              <a href="subject.html#3386">[ subject ]</a>
              <a href="author.html#3386">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">More information about the Avidemux-svn-commit
mailing list</a><br>
</body></html>
