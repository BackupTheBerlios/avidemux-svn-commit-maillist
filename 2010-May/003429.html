<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Avidemux-svn-commit] r6233 -	branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/avidemux-svn-commit/2010-May/index.html" >
   <LINK REL="made" HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r6233%20-%0A%09branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat&In-Reply-To=%3C201005260526.o4Q5QU6L028278%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="003428.html">
   <LINK REL="Next"  HREF="003430.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Avidemux-svn-commit] r6233 -	branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat</H1>
    <B>mean at BerliOS</B> 
    <A HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r6233%20-%0A%09branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat&In-Reply-To=%3C201005260526.o4Q5QU6L028278%40sheep.berlios.de%3E"
       TITLE="[Avidemux-svn-commit] r6233 -	branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat">mean at mail.berlios.de
       </A><BR>
    <I>Wed May 26 07:26:30 CEST 2010</I>
    <P><UL>
        <LI>Previous message: <A HREF="003428.html">[Avidemux-svn-commit] r6232 - in	branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil:	. arm sh4 tomi x86
</A></li>
        <LI>Next message: <A HREF="003430.html">[Avidemux-svn-commit] r6234 - in	branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil:	. x86
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3429">[ date ]</a>
              <a href="thread.html#3429">[ thread ]</a>
              <a href="subject.html#3429">[ subject ]</a>
              <a href="author.html#3429">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: mean
Date: 2010-05-26 07:26:29 +0200 (Wed, 26 May 2010)
New Revision: 6233

Modified:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/file.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/flvenc.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/isom.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/matroskaenc.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/movenc.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/movenc.c.orig
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/mpegenc.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/mpegtsenc.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/utils.c
Log:
 [libavformat] Merge

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/CMakeLists.txt	2010-05-26 05:26:23 UTC (rev 6232)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/CMakeLists.txt	2010-05-26 05:26:29 UTC (rev 6233)
@@ -2,11 +2,12 @@
 
 SET(${ADM_LIB}_SRCS 
 	mpeg.c  utils.c  avio.c  aviobuf.c  cutils.c  img2.c  file.c  mpegtsenc.c
-	movenc.c  avienc.c  wav.c  mov.c  matroska.c  isom.c  isom.h  
+	movenc.c  avi.c avienc.c  wav.c  mov.c  matroska.c  isom.c  isom.h  
 	flvenc.c  matroskaenc.c metadata.c metadata_compat.c options.c
         flacenc.c
 	avc.c raw.c  riff.c
         mpegenc.c
+        movenchint.c sdp.c adtsenc.c flacenc.c flacenc_header.c vorbiscomment.c
 )
 
 ADD_LIBRARY(${ADM_LIB} SHARED ${${ADM_LIB}_SRCS})

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/file.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/file.c	2010-05-26 05:26:23 UTC (rev 6232)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/file.c	2010-05-26 05:26:29 UTC (rev 6233)
@@ -31,7 +31,73 @@
 #include &lt;stdlib.h&gt;
 #include &quot;os_support.h&quot;
 
+// GRUNTSTER start
+#ifdef __WIN32
+#include &lt;windows.h&gt;
 
+int utf8StringToWideChar(const char *utf8String, int utf8StringLength, wchar_t *wideCharString)
+{
+	int wideCharStringLength = MultiByteToWideChar(CP_UTF8, 0, utf8String, utf8StringLength, NULL, 0);
+
+	if (wideCharString)
+		MultiByteToWideChar(CP_UTF8, 0, utf8String, utf8StringLength, wideCharString, wideCharStringLength);
+
+	return wideCharStringLength;
+}
+
+int ADM_open(const char *path, int oflag, ...)
+{
+	int fileNameLength = utf8StringToWideChar(path, -1, NULL);
+	wchar_t wcFile[fileNameLength];
+	int creation = 0, access = 0;
+	HANDLE hFile;
+
+	utf8StringToWideChar(path, -1, wcFile);
+
+	if (oflag &amp; O_WRONLY || oflag &amp; O_RDWR)
+	{
+		access = GENERIC_WRITE;
+
+		if (oflag &amp; O_RDWR)
+			access |= GENERIC_READ;
+
+		if (oflag &amp; O_CREAT)
+		{
+			if (oflag &amp; O_EXCL)
+				creation = CREATE_NEW;
+			else if (oflag &amp; O_TRUNC)
+				creation = CREATE_ALWAYS;
+			else
+				creation = OPEN_ALWAYS;
+		}
+		else if (oflag &amp; O_TRUNC)
+			creation = TRUNCATE_EXISTING;
+	}
+	else if (oflag &amp; O_RDONLY)
+		creation = OPEN_EXISTING;
+
+	if (creation &amp; GENERIC_WRITE)
+	{
+		hFile = CreateFileW(wcFile, access, 0, NULL, creation, 0, NULL);
+
+		if (hFile == INVALID_HANDLE_VALUE)
+			return -1;
+		else
+			CloseHandle(hFile);
+	}
+
+	hFile = CreateFileW(wcFile, access, FILE_SHARE_READ, NULL, creation, 0, NULL);
+
+	if (hFile == INVALID_HANDLE_VALUE)
+		return -1;
+	else
+		return _open_osfhandle((intptr_t)hFile, oflag);
+}
+
+#define open ADM_open
+#endif
+// GRUNTSTER end
+
 /* standard file protocol */
 
 static int file_open(URLContext *h, const char *filename, int flags)

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/flvenc.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/flvenc.c	2010-05-26 05:26:23 UTC (rev 6232)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/flvenc.c	2010-05-26 05:26:29 UTC (rev 6233)
@@ -406,7 +406,8 @@
     &quot;video/x-flv&quot;,
     &quot;flv&quot;,
     sizeof(FLVContext),
-#if CONFIG_LIBMP3LAME
+//MEANX #if CONFIG_LIBMP3LAME
+#ifdef HAVE_LIBMP3LAME
     CODEC_ID_MP3,
 #else // CONFIG_LIBMP3LAME
     CODEC_ID_ADPCM_SWF,
@@ -418,3 +419,9 @@
     .codec_tag= (const AVCodecTag* const []){flv_video_codec_ids, flv_audio_codec_ids, 0},
     .flags= AVFMT_GLOBALHEADER | AVFMT_VARIABLE_FPS,
 };
+// MEANX
+int flvenc_init(void)
+{
+    av_register_output_format(&amp;flv_muxer);
+    return 0;
+}
\ No newline at end of file

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/isom.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/isom.c	2010-05-26 05:26:23 UTC (rev 6232)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/isom.c	2010-05-26 05:26:29 UTC (rev 6233)
@@ -205,7 +205,10 @@
     { CODEC_ID_MP1, MKTAG('.', 'm', 'p', '1') }, /* MPEG layer 1 */
     { CODEC_ID_MP2, MKTAG('.', 'm', 'p', '2') }, /* MPEG layer 2 */
 
-    { CODEC_ID_MP3, MKTAG('.', 'm', 'p', '3') }, /* MPEG layer 3 */ /* sample files at <A HREF="http://www.3ivx.com/showcase.html">http://www.3ivx.com/showcase.html</A> use this tag */
+    //MEANX { CODEC_ID_MP3, MKTAG('.', 'm', 'p', '3') }, /* MPEG layer 3 */ /* sample files at <A HREF="http://www.3ivx.com/showcase.html">http://www.3ivx.com/showcase.html</A> use this tag */
+     { CODEC_ID_MP3, MKTAG( 'm', 'p', '4','a') },
+     { CODEC_ID_MP2, MKTAG( 'm', 'p', '4', 'a') },
+    // /MEANX
     { CODEC_ID_MP3, 0x6D730055 }, /* MPEG layer 3 */
 
 /*  { CODEC_ID_OGG_VORBIS, MKTAG('O', 'g', 'g', 'S') }, *//* sample files at <A HREF="http://heroinewarrior.com/xmovie.php3">http://heroinewarrior.com/xmovie.php3</A> use this tag */

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/matroskaenc.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/matroskaenc.c	2010-05-26 05:26:23 UTC (rev 6232)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/matroskaenc.c	2010-05-26 05:26:29 UTC (rev 6233)
@@ -403,6 +403,7 @@
 
 static int put_xiph_codecpriv(AVFormatContext *s, ByteIOContext *pb, AVCodecContext *codec)
 {
+#if 0 // MEANX avidemux does thing differently
     uint8_t *header_start[3];
     int header_len[3];
     int first_header_size;
@@ -427,6 +428,28 @@
         put_buffer(pb, header_start[j], header_len[j]);
 
     return 0;
+#else
+   // Not endian safe....
+      uint32_t packetLen[3],*ptr=(uint32_t *)codec-&gt;extradata;
+      uint8_t *data[3],i,j;
+      if( 3*4+ptr[0]+ptr[1]+ptr[2]!=codec-&gt;extradata_size)
+      {
+        av_log(s, AV_LOG_ERROR, &quot;Broken avidemux xiph header.\n&quot;);
+        return -1;
+      }
+      data[0]=codec-&gt;extradata+3*4;
+      data[1]=data[0]+ptr[0];
+      data[2]=data[1]+ptr[1];
+      put_byte(pb, 2);                    // number packets - 1
+      for (j = 0; j &lt; 2; j++) 
+      {
+          put_xiph_size(pb, ptr[j]);
+      }
+      for (j = 0; j &lt; 3; j++)
+        put_buffer(pb, data[j], ptr[j]);
+      
+      return 0; // /MEANX
+#endif
 }
 
 static void get_aac_sample_rates(AVFormatContext *s, AVCodecContext *codec, int *sample_rate, int *output_sample_rate)
@@ -544,6 +567,23 @@
         put_ebml_uint (pb, MATROSKA_ID_TRACKNUMBER     , i + 1);
         put_ebml_uint (pb, MATROSKA_ID_TRACKUID        , i + 1);
         put_ebml_uint (pb, MATROSKA_ID_TRACKFLAGLACING , 0);    // no lacing (yet)
+/**  MEANX : Add a default duration for video **/
+        if(codec-&gt;codec_type==CODEC_TYPE_VIDEO)
+        {
+          if(codec-&gt;time_base.den &amp;&amp; codec-&gt;time_base.num)
+          {
+            int num=codec-&gt;time_base.num;
+            int den=codec-&gt;time_base.den;
+            unsigned int default_duration;
+            float period=num;
+                  period/=den;
+                  period*=1000*1000*1000; // in ns
+                  default_duration=(unsigned int)floor(period);
+                  put_ebml_uint (pb, MATROSKA_ID_TRACKDEFAULTDURATION ,default_duration);
+          }
+        }
+        
+/**  MEANX : Add a default duration for video **/
 
         if ((tag = av_metadata_get(st-&gt;metadata, &quot;title&quot;, NULL, 0)))
             put_ebml_string(pb, MATROSKA_ID_TRACKNAME, tag-&gt;value);
@@ -1004,3 +1044,13 @@
     .flags = AVFMT_GLOBALHEADER,
     .codec_tag = (const AVCodecTag* const []){ff_codec_wav_tags, 0},
 };
+// MEANX
+//
+int matroskaenc_init(void)
+{
+    av_register_output_format(&amp;matroska_muxer);
+    return 0;
+}
+// /MEANX
+
+

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/movenc.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/movenc.c	2010-05-26 05:26:23 UTC (rev 6232)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/movenc.c	2010-05-26 05:26:29 UTC (rev 6233)
@@ -2276,3 +2276,15 @@
     .codec_tag = (const AVCodecTag* const []){codec_ipod_tags, 0},
 };
 #endif
+/* MEANX */
+int movenc_init(void)
+{
+    av_register_output_format(&amp;mov_muxer);
+    av_register_output_format(&amp;tgp_muxer);
+    av_register_output_format(&amp;mp4_muxer);
+    av_register_output_format(&amp;psp_muxer);
+    av_register_output_format(&amp;tg2_muxer);
+    av_register_output_format(&amp;ipod_muxer);
+    return 0;
+}
+/* MEANX */

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/movenc.c.orig
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/movenc.c.orig	2010-05-26 05:26:23 UTC (rev 6232)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/movenc.c.orig	2010-05-26 05:26:29 UTC (rev 6233)
@@ -21,6 +21,7 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
+#include &quot;movenc.h&quot;
 #include &quot;avformat.h&quot;
 #include &quot;riff.h&quot;
 #include &quot;avio.h&quot;
@@ -28,67 +29,12 @@
 #include &quot;avc.h&quot;
 #include &quot;libavcodec/get_bits.h&quot;
 #include &quot;libavcodec/put_bits.h&quot;
+#include &quot;internal.h&quot;
+#include &quot;libavutil/avstring.h&quot;
 
 #undef NDEBUG
 #include &lt;assert.h&gt;
 
-#define MOV_INDEX_CLUSTER_SIZE 16384
-#define globalTimescale 1000
-
-#define MODE_MP4  0x01
-#define MODE_MOV  0x02
-#define MODE_3GP  0x04
-#define MODE_PSP  0x08 // example working PSP command line:
-// ffmpeg -i testinput.avi  -f psp -r 14.985 -s 320x240 -b 768 -ar 24000 -ab 32 M4V00001.MP4
-#define MODE_3G2  0x10
-#define MODE_IPOD 0x20
-
-typedef struct MOVIentry {
-    unsigned int size;
-    uint64_t     pos;
-    unsigned int samplesInChunk;
-    unsigned int entries;
-    int          cts;
-    int64_t      dts;
-#define MOV_SYNC_SAMPLE         0x0001
-#define MOV_PARTIAL_SYNC_SAMPLE 0x0002
-    uint32_t     flags;
-} MOVIentry;
-
-typedef struct MOVIndex {
-    int         mode;
-    int         entry;
-    long        timescale;
-    long        time;
-    int64_t     trackDuration;
-    long        sampleCount;
-    long        sampleSize;
-    int         hasKeyframes;
-#define MOV_TRACK_CTTS         0x0001
-#define MOV_TRACK_STPS         0x0002
-    uint32_t    flags;
-    int         language;
-    int         trackID;
-    int         tag; ///&lt; stsd fourcc
-    AVCodecContext *enc;
-
-    int         vosLen;
-    uint8_t     *vosData;
-    MOVIentry   *cluster;
-    int         audio_vbr;
-    int         height; ///&lt; active picture (w/o VBI) height for D-10/IMX
-} MOVTrack;
-
-typedef struct MOVMuxContext {
-    int     mode;
-    int64_t time;
-    int     nb_streams;
-    int64_t mdat_pos;
-    uint64_t mdat_size;
-    long    timescale;
-    MOVTrack *tracks;
-} MOVMuxContext;
-
 //FIXME support 64 bit variant with wide placeholders
 static int64_t updateSize(ByteIOContext *pb, int64_t pos)
 {
@@ -334,7 +280,7 @@
 
     // the following fields is made of 6 bits to identify the streamtype (4 for video, 5 for audio)
     // plus 1 bit to indicate upstream and 1 bit set to 1 (reserved)
-    if(track-&gt;enc-&gt;codec_type == CODEC_TYPE_AUDIO)
+    if(track-&gt;enc-&gt;codec_type == AVMEDIA_TYPE_AUDIO)
         put_byte(pb, 0x15); // flags (= Audiostream)
     else
         put_byte(pb, 0x11); // flags (= Visualstream)
@@ -360,6 +306,14 @@
     return updateSize(pb, pos);
 }
 
+static int mov_pcm_le_gt16(enum CodecID codec_id)
+{
+    return codec_id == CODEC_ID_PCM_S24LE ||
+           codec_id == CODEC_ID_PCM_S32LE ||
+           codec_id == CODEC_ID_PCM_F32LE ||
+           codec_id == CODEC_ID_PCM_F64LE;
+}
+
 static int mov_write_wave_tag(ByteIOContext *pb, MOVTrack *track)
 {
     int64_t pos = url_ftell(pb);
@@ -377,8 +331,7 @@
         put_tag(pb, &quot;mp4a&quot;);
         put_be32(pb, 0);
         mov_write_esds_tag(pb, track);
-    } else if (track-&gt;enc-&gt;codec_id == CODEC_ID_PCM_S24LE ||
-               track-&gt;enc-&gt;codec_id == CODEC_ID_PCM_S32LE) {
+    } else if (mov_pcm_le_gt16(track-&gt;enc-&gt;codec_id)) {
         mov_write_enda_tag(pb);
     } else if (track-&gt;enc-&gt;codec_id == CODEC_ID_AMR_NB) {
         mov_write_amr_tag(pb, track);
@@ -402,16 +355,53 @@
     return 8+track-&gt;vosLen;
 }
 
+/**
+ * Compute flags for 'lpcm' tag.
+ * See CoreAudioTypes and AudioStreamBasicDescription at Apple.
+ */
+static int mov_get_lpcm_flags(enum CodecID codec_id)
+{
+    switch (codec_id) {
+    case CODEC_ID_PCM_F32BE:
+    case CODEC_ID_PCM_F64BE:
+        return 11;
+    case CODEC_ID_PCM_F32LE:
+    case CODEC_ID_PCM_F64LE:
+        return 9;
+    case CODEC_ID_PCM_U8:
+        return 10;
+    case CODEC_ID_PCM_S16BE:
+    case CODEC_ID_PCM_S24BE:
+    case CODEC_ID_PCM_S32BE:
+        return 14;
+    case CODEC_ID_PCM_S8:
+    case CODEC_ID_PCM_S16LE:
+    case CODEC_ID_PCM_S24LE:
+    case CODEC_ID_PCM_S32LE:
+        return 12;
+    default:
+        return 0;
+    }
+}
+
 static int mov_write_audio_tag(ByteIOContext *pb, MOVTrack *track)
 {
     int64_t pos = url_ftell(pb);
-    int version = track-&gt;mode == MODE_MOV &amp;&amp;
-        (track-&gt;audio_vbr ||
-         track-&gt;enc-&gt;codec_id == CODEC_ID_PCM_S32LE ||
-         track-&gt;enc-&gt;codec_id == CODEC_ID_PCM_S24LE);
+    int version = 0;
+    uint32_t tag = track-&gt;tag;
 
+    if (track-&gt;mode == MODE_MOV) {
+        if (track-&gt;timescale &gt; UINT16_MAX) {
+            if (mov_get_lpcm_flags(track-&gt;enc-&gt;codec_id))
+                tag = AV_RL32(&quot;lpcm&quot;);
+            version = 2;
+        } else if (track-&gt;audio_vbr || mov_pcm_le_gt16(track-&gt;enc-&gt;codec_id)) {
+            version = 1;
+        }
+    }
+
     put_be32(pb, 0); /* size */
-    put_le32(pb, track-&gt;tag); // store it byteswapped
+    put_le32(pb, tag); // store it byteswapped
     put_be32(pb, 0); /* Reserved */
     put_be16(pb, 0); /* Reserved */
     put_be16(pb, 1); /* Data-reference index, XXX  == 1 */
@@ -421,24 +411,40 @@
     put_be16(pb, 0); /* Revision level */
     put_be32(pb, 0); /* Reserved */
 
-    if (track-&gt;mode == MODE_MOV) {
-        put_be16(pb, track-&gt;enc-&gt;channels);
-        if (track-&gt;enc-&gt;codec_id == CODEC_ID_PCM_U8 ||
-            track-&gt;enc-&gt;codec_id == CODEC_ID_PCM_S8)
-            put_be16(pb, 8); /* bits per sample */
-        else
-            put_be16(pb, 16);
-        put_be16(pb, track-&gt;audio_vbr ? -2 : 0); /* compression ID */
-    } else { /* reserved for mp4/3gp */
-        put_be16(pb, 2);
+    if (version == 2) {
+        put_be16(pb, 3);
         put_be16(pb, 16);
+        put_be16(pb, 0xfffe);
         put_be16(pb, 0);
+        put_be32(pb, 0x00010000);
+        put_be32(pb, 72);
+        put_be64(pb, av_dbl2int(track-&gt;timescale));
+        put_be32(pb, track-&gt;enc-&gt;channels);
+        put_be32(pb, 0x7F000000);
+        put_be32(pb, av_get_bits_per_sample(track-&gt;enc-&gt;codec_id));
+        put_be32(pb, mov_get_lpcm_flags(track-&gt;enc-&gt;codec_id));
+        put_be32(pb, track-&gt;sampleSize);
+        put_be32(pb, track-&gt;enc-&gt;frame_size);
+    } else {
+        if (track-&gt;mode == MODE_MOV) {
+            put_be16(pb, track-&gt;enc-&gt;channels);
+            if (track-&gt;enc-&gt;codec_id == CODEC_ID_PCM_U8 ||
+                track-&gt;enc-&gt;codec_id == CODEC_ID_PCM_S8)
+                put_be16(pb, 8); /* bits per sample */
+            else
+                put_be16(pb, 16);
+            put_be16(pb, track-&gt;audio_vbr ? -2 : 0); /* compression ID */
+        } else { /* reserved for mp4/3gp */
+            put_be16(pb, 2);
+            put_be16(pb, 16);
+            put_be16(pb, 0);
+        }
+
+        put_be16(pb, 0); /* packet size (= 0) */
+        put_be16(pb, track-&gt;timescale); /* Time scale */
+        put_be16(pb, 0); /* Reserved */
     }
 
-    put_be16(pb, 0); /* packet size (= 0) */
-    put_be16(pb, track-&gt;timescale); /* Time scale */
-    put_be16(pb, 0); /* Reserved */
-
     if(version == 1) { /* SoundDescription V1 extended info */
         put_be32(pb, track-&gt;enc-&gt;frame_size); /* Samples per packet */
         put_be32(pb, track-&gt;sampleSize / track-&gt;enc-&gt;channels); /* Bytes per packet */
@@ -450,9 +456,8 @@
        (track-&gt;enc-&gt;codec_id == CODEC_ID_AAC ||
         track-&gt;enc-&gt;codec_id == CODEC_ID_AC3 ||
         track-&gt;enc-&gt;codec_id == CODEC_ID_AMR_NB ||
-        track-&gt;enc-&gt;codec_id == CODEC_ID_PCM_S24LE ||
-        track-&gt;enc-&gt;codec_id == CODEC_ID_PCM_S32LE ||
-        track-&gt;enc-&gt;codec_id == CODEC_ID_ALAC))
+        track-&gt;enc-&gt;codec_id == CODEC_ID_ALAC ||
+        mov_pcm_le_gt16(track-&gt;enc-&gt;codec_id)))
         mov_write_wave_tag(pb, track);
     else if(track-&gt;tag == MKTAG('m','p','4','a'))
         mov_write_esds_tag(pb, track);
@@ -562,8 +567,8 @@
     else if (track-&gt;enc-&gt;codec_id == CODEC_ID_AC3)       tag = MKTAG('a','c','-','3');
     else if (track-&gt;enc-&gt;codec_id == CODEC_ID_DIRAC)     tag = MKTAG('d','r','a','c');
     else if (track-&gt;enc-&gt;codec_id == CODEC_ID_MOV_TEXT)  tag = MKTAG('t','x','3','g');
-    else if (track-&gt;enc-&gt;codec_type == CODEC_TYPE_VIDEO) tag = MKTAG('m','p','4','v');
-    else if (track-&gt;enc-&gt;codec_type == CODEC_TYPE_AUDIO) tag = MKTAG('m','p','4','a');
+    else if (track-&gt;enc-&gt;codec_type == AVMEDIA_TYPE_VIDEO) tag = MKTAG('m','p','4','v');
+    else if (track-&gt;enc-&gt;codec_type == AVMEDIA_TYPE_AUDIO) tag = MKTAG('m','p','4','a');
 
     return tag;
 }
@@ -584,12 +589,12 @@
     int tag = track-&gt;enc-&gt;codec_tag;
 
     // keep original tag for subs, ipod supports both formats
-    if (!(track-&gt;enc-&gt;codec_type == CODEC_TYPE_SUBTITLE &amp;&amp;
+    if (!(track-&gt;enc-&gt;codec_type == AVMEDIA_TYPE_SUBTITLE &amp;&amp;
         (tag == MKTAG('t','x','3','g') ||
          tag == MKTAG('t','e','x','t'))))
         tag = ff_codec_get_tag(codec_ipod_tags, track-&gt;enc-&gt;codec_id);
 
-    if (!match_ext(s-&gt;filename, &quot;m4a&quot;) &amp;&amp; !match_ext(s-&gt;filename, &quot;m4v&quot;))
+    if (!av_match_ext(s-&gt;filename, &quot;m4a&quot;) &amp;&amp; !av_match_ext(s-&gt;filename, &quot;m4v&quot;))
         av_log(s, AV_LOG_WARNING, &quot;Warning, extension is not .m4a nor .m4v &quot;
                &quot;Quicktime/Ipod might not play the file\n&quot;);
 
@@ -656,7 +661,7 @@
             tag = mov_get_dv_codec_tag(s, track);
         else if (track-&gt;enc-&gt;codec_id == CODEC_ID_RAWVIDEO)
             tag = mov_get_rawvideo_codec_tag(s, track);
-        else if (track-&gt;enc-&gt;codec_type == CODEC_TYPE_VIDEO) {
+        else if (track-&gt;enc-&gt;codec_type == AVMEDIA_TYPE_VIDEO) {
             tag = ff_codec_get_tag(codec_movvideo_tags, track-&gt;enc-&gt;codec_id);
             if (!tag) { // if no mac fcc found, try with Microsoft tags
                 tag = ff_codec_get_tag(ff_codec_bmp_tags, track-&gt;enc-&gt;codec_id);
@@ -664,7 +669,7 @@
                     av_log(s, AV_LOG_INFO, &quot;Warning, using MS style video codec tag, &quot;
                            &quot;the file may be unplayable!\n&quot;);
             }
-        } else if (track-&gt;enc-&gt;codec_type == CODEC_TYPE_AUDIO) {
+        } else if (track-&gt;enc-&gt;codec_type == AVMEDIA_TYPE_AUDIO) {
             tag = ff_codec_get_tag(codec_movaudio_tags, track-&gt;enc-&gt;codec_id);
             if (!tag) { // if no mac fcc found, try with Microsoft tags
                 int ms_tag = ff_codec_get_tag(ff_codec_wav_tags, track-&gt;enc-&gt;codec_id);
@@ -674,7 +679,7 @@
                            &quot;the file may be unplayable!\n&quot;);
                 }
             }
-        } else if (track-&gt;enc-&gt;codec_type == CODEC_TYPE_SUBTITLE)
+        } else if (track-&gt;enc-&gt;codec_type == AVMEDIA_TYPE_SUBTITLE)
             tag = ff_codec_get_tag(ff_codec_movsubtitle_tags, track-&gt;enc-&gt;codec_id);
     }
 
@@ -803,6 +808,26 @@
     return updateSize(pb, pos);
 }
 
+static int mov_write_rtp_tag(ByteIOContext *pb, MOVTrack *track)
+{
+    int64_t pos = url_ftell(pb);
+    put_be32(pb, 0); /* size */
+    put_tag(pb, &quot;rtp &quot;);
+    put_be32(pb, 0); /* Reserved */
+    put_be16(pb, 0); /* Reserved */
+    put_be16(pb, 1); /* Data-reference index */
+
+    put_be16(pb, 1); /* Hint track version */
+    put_be16(pb, 1); /* Highest compatible version */
+    put_be32(pb, track-&gt;max_packet_size); /* Max packet size */
+
+    put_be32(pb, 12); /* size */
+    put_tag(pb, &quot;tims&quot;);
+    put_be32(pb, track-&gt;timescale);
+
+    return updateSize(pb, pos);
+}
+
 static int mov_write_stsd_tag(ByteIOContext *pb, MOVTrack *track)
 {
     int64_t pos = url_ftell(pb);
@@ -810,12 +835,14 @@
     put_tag(pb, &quot;stsd&quot;);
     put_be32(pb, 0); /* version &amp; flags */
     put_be32(pb, 1); /* entry count */
-    if (track-&gt;enc-&gt;codec_type == CODEC_TYPE_VIDEO)
+    if (track-&gt;enc-&gt;codec_type == AVMEDIA_TYPE_VIDEO)
         mov_write_video_tag(pb, track);
-    else if (track-&gt;enc-&gt;codec_type == CODEC_TYPE_AUDIO)
+    else if (track-&gt;enc-&gt;codec_type == AVMEDIA_TYPE_AUDIO)
         mov_write_audio_tag(pb, track);
-    else if (track-&gt;enc-&gt;codec_type == CODEC_TYPE_SUBTITLE)
+    else if (track-&gt;enc-&gt;codec_type == AVMEDIA_TYPE_SUBTITLE)
         mov_write_subtitle_tag(pb, track);
+    else if (track-&gt;enc-&gt;codec_tag == MKTAG('r','t','p',' '))
+        mov_write_rtp_tag(pb, track);
     return updateSize(pb, pos);
 }
 
@@ -860,7 +887,7 @@
     uint32_t atom_size;
     int i;
 
-    if (track-&gt;enc-&gt;codec_type == CODEC_TYPE_AUDIO &amp;&amp; !track-&gt;audio_vbr) {
+    if (track-&gt;enc-&gt;codec_type == AVMEDIA_TYPE_AUDIO &amp;&amp; !track-&gt;audio_vbr) {
         stts_entries = av_malloc(sizeof(*stts_entries)); /* one entry */
         stts_entries[0].count = track-&gt;sampleCount;
         stts_entries[0].duration = 1;
@@ -915,12 +942,13 @@
     put_tag(pb, &quot;stbl&quot;);
     mov_write_stsd_tag(pb, track);
     mov_write_stts_tag(pb, track);
-    if (track-&gt;enc-&gt;codec_type == CODEC_TYPE_VIDEO &amp;&amp;
+    if ((track-&gt;enc-&gt;codec_type == AVMEDIA_TYPE_VIDEO ||
+         track-&gt;enc-&gt;codec_tag == MKTAG('r','t','p',' ')) &amp;&amp;
         track-&gt;hasKeyframes &amp;&amp; track-&gt;hasKeyframes &lt; track-&gt;entry)
         mov_write_stss_tag(pb, track, MOV_SYNC_SAMPLE);
     if (track-&gt;mode == MODE_MOV &amp;&amp; track-&gt;flags &amp; MOV_TRACK_STPS)
         mov_write_stss_tag(pb, track, MOV_PARTIAL_SYNC_SAMPLE);
-    if (track-&gt;enc-&gt;codec_type == CODEC_TYPE_VIDEO &amp;&amp;
+    if (track-&gt;enc-&gt;codec_type == AVMEDIA_TYPE_VIDEO &amp;&amp;
         track-&gt;flags &amp; MOV_TRACK_CTTS)
         mov_write_ctts_tag(pb, track);
     mov_write_stsc_tag(pb, track);
@@ -992,16 +1020,19 @@
         descr = &quot;DataHandler&quot;;
     } else {
         hdlr = (track-&gt;mode == MODE_MOV) ? &quot;mhlr&quot; : &quot;\0\0\0\0&quot;;
-        if (track-&gt;enc-&gt;codec_type == CODEC_TYPE_VIDEO) {
+        if (track-&gt;enc-&gt;codec_type == AVMEDIA_TYPE_VIDEO) {
             hdlr_type = &quot;vide&quot;;
             descr = &quot;VideoHandler&quot;;
-        } else if (track-&gt;enc-&gt;codec_type == CODEC_TYPE_AUDIO) {
+        } else if (track-&gt;enc-&gt;codec_type == AVMEDIA_TYPE_AUDIO) {
             hdlr_type = &quot;soun&quot;;
             descr = &quot;SoundHandler&quot;;
-        } else if (track-&gt;enc-&gt;codec_type == CODEC_TYPE_SUBTITLE) {
+        } else if (track-&gt;enc-&gt;codec_type == AVMEDIA_TYPE_SUBTITLE) {
             if (track-&gt;tag == MKTAG('t','x','3','g')) hdlr_type = &quot;sbtl&quot;;
             else                                      hdlr_type = &quot;text&quot;;
             descr = &quot;SubtitleHandler&quot;;
+        } else if (track-&gt;enc-&gt;codec_tag == MKTAG('r','t','p',' ')) {
+            hdlr_type = &quot;hint&quot;;
+            descr = &quot;HintHandler&quot;;
         }
     }
 
@@ -1021,18 +1052,35 @@
     return updateSize(pb, pos);
 }
 
+static int mov_write_hmhd_tag(ByteIOContext *pb)
+{
+    /* This atom must be present, but leaving the values at zero
+     * seems harmless. */
+    put_be32(pb, 28); /* size */
+    put_tag(pb, &quot;hmhd&quot;);
+    put_be32(pb, 0); /* version, flags */
+    put_be16(pb, 0); /* maxPDUsize */
+    put_be16(pb, 0); /* avgPDUsize */
+    put_be32(pb, 0); /* maxbitrate */
+    put_be32(pb, 0); /* avgbitrate */
+    put_be32(pb, 0); /* reserved */
+    return 28;
+}
+
 static int mov_write_minf_tag(ByteIOContext *pb, MOVTrack *track)
 {
     int64_t pos = url_ftell(pb);
     put_be32(pb, 0); /* size */
     put_tag(pb, &quot;minf&quot;);
-    if(track-&gt;enc-&gt;codec_type == CODEC_TYPE_VIDEO)
+    if(track-&gt;enc-&gt;codec_type == AVMEDIA_TYPE_VIDEO)
         mov_write_vmhd_tag(pb);
-    else if (track-&gt;enc-&gt;codec_type == CODEC_TYPE_AUDIO)
+    else if (track-&gt;enc-&gt;codec_type == AVMEDIA_TYPE_AUDIO)
         mov_write_smhd_tag(pb);
-    else if (track-&gt;enc-&gt;codec_type == CODEC_TYPE_SUBTITLE) {
+    else if (track-&gt;enc-&gt;codec_type == AVMEDIA_TYPE_SUBTITLE) {
         if (track-&gt;tag == MKTAG('t','e','x','t')) mov_write_gmhd_tag(pb);
         else                                      mov_write_nmhd_tag(pb);
+    } else if (track-&gt;tag == MKTAG('r','t','p',' ')) {
+        mov_write_hmhd_tag(pb);
     }
     if (track-&gt;mode == MODE_MOV) /* FIXME: Why do it for MODE_MOV only ? */
         mov_write_hdlr_tag(pb, NULL);
@@ -1084,7 +1132,8 @@
 
 static int mov_write_tkhd_tag(ByteIOContext *pb, MOVTrack *track, AVStream *st)
 {
-    int64_t duration = av_rescale_rnd(track-&gt;trackDuration, globalTimescale, track-&gt;timescale, AV_ROUND_UP);
+    int64_t duration = av_rescale_rnd(track-&gt;trackDuration, MOV_TIMESCALE,
+                                      track-&gt;timescale, AV_ROUND_UP);
     int version = duration &lt; INT32_MAX ? 0 : 1;
 
     (version == 1) ? put_be32(pb, 104) : put_be32(pb, 92); /* size */
@@ -1106,7 +1155,7 @@
     put_be32(pb, 0); /* reserved */
     put_be32(pb, 0x0); /* reserved (Layer &amp; Alternate group) */
     /* Volume, only for audio */
-    if(track-&gt;enc-&gt;codec_type == CODEC_TYPE_AUDIO)
+    if(track-&gt;enc-&gt;codec_type == AVMEDIA_TYPE_AUDIO)
         put_be16(pb, 0x0100);
     else
         put_be16(pb, 0);
@@ -1124,8 +1173,8 @@
     put_be32(pb, 0x40000000); /* reserved */
 
     /* Track width and height, for visual only */
-    if(track-&gt;enc-&gt;codec_type == CODEC_TYPE_VIDEO ||
-       track-&gt;enc-&gt;codec_type == CODEC_TYPE_SUBTITLE) {
+    if(st &amp;&amp; (track-&gt;enc-&gt;codec_type == AVMEDIA_TYPE_VIDEO ||
+              track-&gt;enc-&gt;codec_type == AVMEDIA_TYPE_SUBTITLE)) {
         double sample_aspect_ratio = av_q2d(st-&gt;sample_aspect_ratio);
         if(!sample_aspect_ratio || track-&gt;height != track-&gt;enc-&gt;height)
             sample_aspect_ratio = 1;
@@ -1149,13 +1198,25 @@
     put_be32(pb, 0x0);
     put_be32(pb, 0x1);
 
-    put_be32(pb, av_rescale_rnd(track-&gt;trackDuration, globalTimescale, track-&gt;timescale, AV_ROUND_UP)); /* duration   ... doesn't seem to effect psp */
+    /* duration   ... doesn't seem to effect psp */
+    put_be32(pb, av_rescale_rnd(track-&gt;trackDuration, MOV_TIMESCALE,
+                                track-&gt;timescale, AV_ROUND_UP));
 
     put_be32(pb, track-&gt;cluster[0].cts); /* first pts is cts since dts is 0 */
     put_be32(pb, 0x00010000);
     return 0x24;
 }
 
+static int mov_write_tref_tag(ByteIOContext *pb, MOVTrack *track)
+{
+    put_be32(pb, 20);   // size
+    put_tag(pb, &quot;tref&quot;);
+    put_be32(pb, 12);   // size (subatom)
+    put_le32(pb, track-&gt;tref_tag);
+    put_be32(pb, track-&gt;tref_id);
+    return 20;
+}
+
 // goes at the end of each track!  ... Critical for PSP playback (&quot;Incompatible data&quot; without it)
 static int mov_write_uuid_tag_psp(ByteIOContext *pb, MOVTrack *mov)
 {
@@ -1175,6 +1236,25 @@
     return 0x34;
 }
 
+static int mov_write_udta_sdp(ByteIOContext *pb, AVCodecContext *ctx, int index)
+{
+    char buf[1000] = &quot;&quot;;
+    int len;
+
+    ff_sdp_write_media(buf, sizeof(buf), ctx, NULL, 0, 0);
+    av_strlcatf(buf, sizeof(buf), &quot;a=control:streamid=%d\r\n&quot;, index);
+    len = strlen(buf);
+
+    put_be32(pb, len + 24);
+    put_tag (pb, &quot;udta&quot;);
+    put_be32(pb, len + 16);
+    put_tag (pb, &quot;hnti&quot;);
+    put_be32(pb, len + 8);
+    put_tag (pb, &quot;sdp &quot;);
+    put_buffer(pb, buf, len);
+    return len + 24;
+}
+
 static int mov_write_trak_tag(ByteIOContext *pb, MOVTrack *track, AVStream *st)
 {
     int64_t pos = url_ftell(pb);
@@ -1183,9 +1263,13 @@
     mov_write_tkhd_tag(pb, track, st);
     if (track-&gt;mode == MODE_PSP || track-&gt;flags &amp; MOV_TRACK_CTTS)
         mov_write_edts_tag(pb, track);  // PSP Movies require edts box
+    if (track-&gt;tref_tag)
+        mov_write_tref_tag(pb, track);
     mov_write_mdia_tag(pb, track);
     if (track-&gt;mode == MODE_PSP)
         mov_write_uuid_tag_psp(pb,track);  // PSP Movies require this uuid box
+    if (track-&gt;tag == MKTAG('r','t','p',' '))
+        mov_write_udta_sdp(pb, track-&gt;rtp_ctx-&gt;streams[0]-&gt;codec, track-&gt;trackID);
     return updateSize(pb, pos);
 }
 
@@ -1213,7 +1297,10 @@
 
     for (i=0; i&lt;mov-&gt;nb_streams; i++) {
         if(mov-&gt;tracks[i].entry &gt; 0) {
-            maxTrackLenTemp = av_rescale_rnd(mov-&gt;tracks[i].trackDuration, globalTimescale, mov-&gt;tracks[i].timescale, AV_ROUND_UP);
+            maxTrackLenTemp = av_rescale_rnd(mov-&gt;tracks[i].trackDuration,
+                                             MOV_TIMESCALE,
+                                             mov-&gt;tracks[i].timescale,
+                                             AV_ROUND_UP);
             if(maxTrackLen &lt; maxTrackLenTemp)
                 maxTrackLen = maxTrackLenTemp;
             if(maxTrackID &lt; mov-&gt;tracks[i].trackID)
@@ -1233,7 +1320,7 @@
         put_be32(pb, mov-&gt;time); /* creation time */
         put_be32(pb, mov-&gt;time); /* modification time */
     }
-    put_be32(pb, mov-&gt;timescale); /* timescale */
+    put_be32(pb, MOV_TIMESCALE);
     (version == 1) ? put_be64(pb, maxTrackLen) : put_be32(pb, maxTrackLen); /* duration of longest track */
 
     put_be32(pb, 0x00010000); /* reserved (preferred rate) 1.0 = normal */
@@ -1266,8 +1353,7 @@
 static int mov_write_itunes_hdlr_tag(ByteIOContext *pb, MOVMuxContext *mov,
                                      AVFormatContext *s)
 {
-    int64_t pos = url_ftell(pb);
-    put_be32(pb, 0); /* size */
+    put_be32(pb, 33); /* size */
     put_tag(pb, &quot;hdlr&quot;);
     put_be32(pb, 0);
     put_be32(pb, 0);
@@ -1275,22 +1361,24 @@
     put_tag(pb, &quot;appl&quot;);
     put_be32(pb, 0);
     put_be32(pb, 0);
-    put_be16(pb, 0);
-    return updateSize(pb, pos);
+    put_byte(pb, 0);
+    return 33;
 }
 
 /* helper function to write a data tag with the specified string as data */
 static int mov_write_string_data_tag(ByteIOContext *pb, const char *data, int lang, int long_style)
 {
     if(long_style){
-        int64_t pos = url_ftell(pb);
-        put_be32(pb, 0); /* size */
+        int size = 16 + strlen(data);
+        put_be32(pb, size); /* size */
         put_tag(pb, &quot;data&quot;);
         put_be32(pb, 1);
         put_be32(pb, 0);
         put_buffer(pb, data, strlen(data));
-        return updateSize(pb, pos);
+        return size;
     }else{
+        if (!lang)
+            lang = ff_mov_iso639_to_lang(&quot;und&quot;, 1);
         put_be16(pb, strlen(data)); /* string length */
         put_be16(pb, lang);
         put_buffer(pb, data, strlen(data));
@@ -1326,7 +1414,7 @@
     while ((t2 = av_metadata_get(s-&gt;metadata, tag2, t2, AV_METADATA_IGNORE_SUFFIX))) {
         len2 = strlen(t2-&gt;key);
         if (len2 == len+4 &amp;&amp; !strcmp(t-&gt;value, t2-&gt;value)
-            &amp;&amp; (l=ff_mov_iso639_to_lang(&amp;t2-&gt;key[len2-3], 0)) &gt;= 0) {
+            &amp;&amp; (l=ff_mov_iso639_to_lang(&amp;t2-&gt;key[len2-3], 1)) &gt;= 0) {
             lang = l;
             break;
         }
@@ -1341,12 +1429,9 @@
     AVMetadataTag *t = av_metadata_get(s-&gt;metadata, &quot;track&quot;, NULL, 0);
     int size = 0, track = t ? atoi(t-&gt;value) : 0;
     if (track) {
-        int64_t pos = url_ftell(pb);
-        put_be32(pb, 0); /* size */
+        put_be32(pb, 32); /* size */
         put_tag(pb, &quot;trkn&quot;);
-        {
-            int64_t pos = url_ftell(pb);
-            put_be32(pb, 0); /* size */
+            put_be32(pb, 24); /* size */
             put_tag(pb, &quot;data&quot;);
             put_be32(pb, 0);        // 8 bytes empty
             put_be32(pb, 0);
@@ -1354,9 +1439,7 @@
             put_be16(pb, track);    // track number
             put_be16(pb, 0);        // total track number
             put_be16(pb, 0);        // empty
-            updateSize(pb, pos);
-        }
-        size = updateSize(pb, pos);
+        size = 32;
     }
     return size;
 }
@@ -1369,14 +1452,22 @@
     put_be32(pb, 0); /* size */
     put_tag(pb, &quot;ilst&quot;);
     mov_write_string_metadata(s, pb, &quot;\251nam&quot;, &quot;title&quot;    , 1);
-    mov_write_string_metadata(s, pb, &quot;\251ART&quot;, &quot;author&quot;   , 1);
-    mov_write_string_metadata(s, pb, &quot;\251wrt&quot;, &quot;author&quot;   , 1);
+    mov_write_string_metadata(s, pb, &quot;\251ART&quot;, &quot;artist&quot;   , 1);
+    mov_write_string_metadata(s, pb, &quot;aART&quot;, &quot;album_artist&quot;, 1);
+    mov_write_string_metadata(s, pb, &quot;\251wrt&quot;, &quot;composer&quot; , 1);
     mov_write_string_metadata(s, pb, &quot;\251alb&quot;, &quot;album&quot;    , 1);
-    mov_write_string_metadata(s, pb, &quot;\251day&quot;, &quot;year&quot;     , 1);
+    mov_write_string_metadata(s, pb, &quot;\251day&quot;, &quot;date&quot;     , 1);
     mov_write_string_tag(pb, &quot;\251too&quot;, LIBAVFORMAT_IDENT, 0, 1);
     mov_write_string_metadata(s, pb, &quot;\251cmt&quot;, &quot;comment&quot;  , 1);
     mov_write_string_metadata(s, pb, &quot;\251gen&quot;, &quot;genre&quot;    , 1);
     mov_write_string_metadata(s, pb, &quot;\251cpy&quot;, &quot;copyright&quot;, 1);
+    mov_write_string_metadata(s, pb, &quot;\251grp&quot;, &quot;grouping&quot; , 1);
+    mov_write_string_metadata(s, pb, &quot;\251lyr&quot;, &quot;lyrics&quot;   , 1);
+    mov_write_string_metadata(s, pb, &quot;desc&quot;,    &quot;description&quot;,1);
+    mov_write_string_metadata(s, pb, &quot;ldes&quot;,    &quot;synopsis&quot; , 1);
+    mov_write_string_metadata(s, pb, &quot;tvsh&quot;,    &quot;show&quot;     , 1);
+    mov_write_string_metadata(s, pb, &quot;tven&quot;,    &quot;episode_id&quot;,1);
+    mov_write_string_metadata(s, pb, &quot;tvnn&quot;,    &quot;network&quot;  , 1);
     mov_write_trkn_tag(pb, mov, s);
     return updateSize(pb, pos);
 }
@@ -1439,12 +1530,38 @@
         put_be16(pb, language_code(&quot;eng&quot;)); /* language */
         put_buffer(pb, t-&gt;value, strlen(t-&gt;value)+1); /* UTF8 string value */
         if (!strcmp(tag, &quot;albm&quot;) &amp;&amp;
-            (t = av_metadata_get(s-&gt;metadata, &quot;year&quot;, NULL, 0)))
+            (t = av_metadata_get(s-&gt;metadata, &quot;track&quot;, NULL, 0)))
             put_byte(pb, atoi(t-&gt;value));
     }
     return updateSize(pb, pos);
 }
 
+static int mov_write_chpl_tag(ByteIOContext *pb, AVFormatContext *s)
+{
+    int64_t pos = url_ftell(pb);
+    int i, nb_chapters = FFMIN(s-&gt;nb_chapters, 255);
+
+    put_be32(pb, 0);            // size
+    put_tag (pb, &quot;chpl&quot;);
+    put_be32(pb, 0x01000000);   // version + flags
+    put_be32(pb, 0);            // unknown
+    put_byte(pb, nb_chapters);
+
+    for (i = 0; i &lt; nb_chapters; i++) {
+        AVChapter *c = s-&gt;chapters[i];
+        AVMetadataTag *t;
+        put_be64(pb, av_rescale_q(c-&gt;start, c-&gt;time_base, (AVRational){1,10000000}));
+
+        if ((t = av_metadata_get(c-&gt;metadata, &quot;title&quot;, NULL, 0))) {
+            int len = FFMIN(strlen(t-&gt;value), 255);
+            put_byte(pb, len);
+            put_buffer(pb, t-&gt;value, len);
+        } else
+            put_byte(pb, 0);
+    }
+    return updateSize(pb, pos);
+}
+
 static int mov_write_udta_tag(ByteIOContext *pb, MOVMuxContext *mov,
                               AVFormatContext *s)
 {
@@ -1462,18 +1579,19 @@
         return ret;
 
         if (mov-&gt;mode &amp; MODE_3GP) {
+            mov_write_3gp_udta_tag(pb_buf, s, &quot;perf&quot;, &quot;artist&quot;);
             mov_write_3gp_udta_tag(pb_buf, s, &quot;titl&quot;, &quot;title&quot;);
             mov_write_3gp_udta_tag(pb_buf, s, &quot;auth&quot;, &quot;author&quot;);
             mov_write_3gp_udta_tag(pb_buf, s, &quot;gnre&quot;, &quot;genre&quot;);
             mov_write_3gp_udta_tag(pb_buf, s, &quot;dscp&quot;, &quot;comment&quot;);
             mov_write_3gp_udta_tag(pb_buf, s, &quot;albm&quot;, &quot;album&quot;);
             mov_write_3gp_udta_tag(pb_buf, s, &quot;cprt&quot;, &quot;copyright&quot;);
-            mov_write_3gp_udta_tag(pb_buf, s, &quot;yrrc&quot;, &quot;year&quot;);
+            mov_write_3gp_udta_tag(pb_buf, s, &quot;yrrc&quot;, &quot;date&quot;);
         } else if (mov-&gt;mode == MODE_MOV) { // the title field breaks gtkpod with mp4 and my suspicion is that stuff is not valid in mp4
             mov_write_string_metadata(s, pb_buf, &quot;\251nam&quot;, &quot;title&quot;      , 0);
             mov_write_string_metadata(s, pb_buf, &quot;\251aut&quot;, &quot;author&quot;     , 0);
             mov_write_string_metadata(s, pb_buf, &quot;\251alb&quot;, &quot;album&quot;      , 0);
-            mov_write_string_metadata(s, pb_buf, &quot;\251day&quot;, &quot;year&quot;       , 0);
+            mov_write_string_metadata(s, pb_buf, &quot;\251day&quot;, &quot;date&quot;       , 0);
             mov_write_string_tag(pb_buf, &quot;\251enc&quot;, LIBAVFORMAT_IDENT, 0, 0);
             mov_write_string_metadata(s, pb_buf, &quot;\251des&quot;, &quot;comment&quot;    , 0);
             mov_write_string_metadata(s, pb_buf, &quot;\251gen&quot;, &quot;genre&quot;      , 0);
@@ -1483,6 +1601,9 @@
             mov_write_meta_tag(pb_buf, mov, s);
         }
 
+        if (s-&gt;nb_chapters)
+            mov_write_chpl_tag(pb_buf, s);
+
     if ((size = url_close_dyn_buf(pb_buf, &amp;buf)) &gt; 0) {
         put_be32(pb, size+8);
         put_tag(pb, &quot;udta&quot;);
@@ -1551,7 +1672,6 @@
     int64_t pos = url_ftell(pb);
     put_be32(pb, 0); /* size placeholder*/
     put_tag(pb, &quot;moov&quot;);
-    mov-&gt;timescale = globalTimescale;
 
     for (i=0; i&lt;mov-&gt;nb_streams; i++) {
         if(mov-&gt;tracks[i].entry &lt;= 0) continue;
@@ -1560,11 +1680,24 @@
         mov-&gt;tracks[i].trackID = i+1;
     }
 
+    if (mov-&gt;chapter_track)
+        for (i=0; i&lt;s-&gt;nb_streams; i++) {
+            mov-&gt;tracks[i].tref_tag = MKTAG('c','h','a','p');
+            mov-&gt;tracks[i].tref_id = mov-&gt;tracks[mov-&gt;chapter_track].trackID;
+        }
+    for (i = 0; i &lt; mov-&gt;nb_streams; i++) {
+        if (mov-&gt;tracks[i].tag == MKTAG('r','t','p',' ')) {
+            mov-&gt;tracks[i].tref_tag = MKTAG('h','i','n','t');
+            mov-&gt;tracks[i].tref_id =
+                mov-&gt;tracks[mov-&gt;tracks[i].src_track].trackID;
+        }
+    }
+
     mov_write_mvhd_tag(pb, mov);
     //mov_write_iods_tag(pb, mov);
     for (i=0; i&lt;mov-&gt;nb_streams; i++) {
         if(mov-&gt;tracks[i].entry &gt; 0) {
-            mov_write_trak_tag(pb, &amp;(mov-&gt;tracks[i]), s-&gt;streams[i]);
+            mov_write_trak_tag(pb, &amp;(mov-&gt;tracks[i]), i &lt; s-&gt;nb_streams ? s-&gt;streams[i] : NULL);
         }
     }
 
@@ -1598,7 +1731,7 @@
 
     for (i = 0; i &lt; s-&gt;nb_streams; i++) {
         AVStream *st = s-&gt;streams[i];
-        if (st-&gt;codec-&gt;codec_type == CODEC_TYPE_VIDEO)
+        if (st-&gt;codec-&gt;codec_type == AVMEDIA_TYPE_VIDEO)
             has_video = 1;
         if (st-&gt;codec-&gt;codec_id == CODEC_ID_H264)
             has_h264 = 1;
@@ -1705,111 +1838,6 @@
     put_be32(pb, 0x010001); /* ? */
 }
 
-static int mov_write_header(AVFormatContext *s)
-{
-    ByteIOContext *pb = s-&gt;pb;
-    MOVMuxContext *mov = s-&gt;priv_data;
-    int i;
-
-    if (url_is_streamed(s-&gt;pb)) {
-        av_log(s, AV_LOG_ERROR, &quot;muxer does not support non seekable output\n&quot;);
-        return -1;
-    }
-
-    /* Default mode == MP4 */
-    mov-&gt;mode = MODE_MP4;
-
-    if (s-&gt;oformat != NULL) {
-        if (!strcmp(&quot;3gp&quot;, s-&gt;oformat-&gt;name)) mov-&gt;mode = MODE_3GP;
-        else if (!strcmp(&quot;3g2&quot;, s-&gt;oformat-&gt;name)) mov-&gt;mode = MODE_3GP|MODE_3G2;
-        else if (!strcmp(&quot;mov&quot;, s-&gt;oformat-&gt;name)) mov-&gt;mode = MODE_MOV;
-        else if (!strcmp(&quot;psp&quot;, s-&gt;oformat-&gt;name)) mov-&gt;mode = MODE_PSP;
-        else if (!strcmp(&quot;ipod&quot;,s-&gt;oformat-&gt;name)) mov-&gt;mode = MODE_IPOD;
-
-        mov_write_ftyp_tag(pb,s);
-        if (mov-&gt;mode == MODE_PSP) {
-            if (s-&gt;nb_streams != 2) {
-                av_log(s, AV_LOG_ERROR, &quot;PSP mode need one video and one audio stream\n&quot;);
-                return -1;
-            }
-            mov_write_uuidprof_tag(pb,s);
-        }
-    }
-
-    mov-&gt;tracks = av_mallocz(s-&gt;nb_streams*sizeof(*mov-&gt;tracks));
-    if (!mov-&gt;tracks)
-        return AVERROR(ENOMEM);
-
-    for(i=0; i&lt;s-&gt;nb_streams; i++){
-        AVStream *st= s-&gt;streams[i];
-        MOVTrack *track= &amp;mov-&gt;tracks[i];
-        AVMetadataTag *lang = av_metadata_get(st-&gt;metadata, &quot;language&quot;, NULL,0);
-
-        track-&gt;enc = st-&gt;codec;
-        track-&gt;language = ff_mov_iso639_to_lang(lang?lang-&gt;value:&quot;und&quot;, mov-&gt;mode!=MODE_MOV);
-        if (track-&gt;language &lt; 0)
-            track-&gt;language = 0;
-        track-&gt;mode = mov-&gt;mode;
-        track-&gt;tag = mov_find_codec_tag(s, track);
-        if (!track-&gt;tag) {
-            av_log(s, AV_LOG_ERROR, &quot;track %d: could not find tag, &quot;
-                   &quot;codec not currently supported in container\n&quot;, i);
-            goto error;
-        }
-        if(st-&gt;codec-&gt;codec_type == CODEC_TYPE_VIDEO){
-            if (track-&gt;tag == MKTAG('m','x','3','p') || track-&gt;tag == MKTAG('m','x','3','n') ||
-                track-&gt;tag == MKTAG('m','x','4','p') || track-&gt;tag == MKTAG('m','x','4','n') ||
-                track-&gt;tag == MKTAG('m','x','5','p') || track-&gt;tag == MKTAG('m','x','5','n')) {
-                if (st-&gt;codec-&gt;width != 720 || (st-&gt;codec-&gt;height != 608 &amp;&amp; st-&gt;codec-&gt;height != 512)) {
-                    av_log(s, AV_LOG_ERROR, &quot;D-10/IMX must use 720x608 or 720x512 video resolution\n&quot;);
-                    goto error;
-                }
-                track-&gt;height = track-&gt;tag&gt;&gt;24 == 'n' ? 486 : 576;
-            }
-            track-&gt;timescale = st-&gt;codec-&gt;time_base.den;
-            if (track-&gt;mode == MODE_MOV &amp;&amp; track-&gt;timescale &gt; 100000)
-                av_log(s, AV_LOG_WARNING,
-                       &quot;WARNING codec timebase is very high. If duration is too long,\n&quot;
-                       &quot;file may not be playable by quicktime. Specify a shorter timebase\n&quot;
-                       &quot;or choose different container.\n&quot;);
-        }else if(st-&gt;codec-&gt;codec_type == CODEC_TYPE_AUDIO){
-            track-&gt;timescale = st-&gt;codec-&gt;sample_rate;
-            if(!st-&gt;codec-&gt;frame_size &amp;&amp; !av_get_bits_per_sample(st-&gt;codec-&gt;codec_id)) {
-                av_log(s, AV_LOG_ERROR, &quot;track %d: codec frame size is not set\n&quot;, i);
-                goto error;
-            }else if(st-&gt;codec-&gt;frame_size &gt; 1){ /* assume compressed audio */
-                track-&gt;audio_vbr = 1;
-            }else{
-                st-&gt;codec-&gt;frame_size = 1;
-                track-&gt;sampleSize = (av_get_bits_per_sample(st-&gt;codec-&gt;codec_id) &gt;&gt; 3) * st-&gt;codec-&gt;channels;
-            }
-            if(track-&gt;mode != MODE_MOV &amp;&amp;
-               track-&gt;enc-&gt;codec_id == CODEC_ID_MP3 &amp;&amp; track-&gt;enc-&gt;sample_rate &lt; 16000){
-                av_log(s, AV_LOG_ERROR, &quot;track %d: muxing mp3 at %dhz is not supported\n&quot;,
-                       i, track-&gt;enc-&gt;sample_rate);
-                goto error;
-            }
-        }else if(st-&gt;codec-&gt;codec_type == CODEC_TYPE_SUBTITLE){
-            track-&gt;timescale = st-&gt;codec-&gt;time_base.den;
-        }
-        if (!track-&gt;height)
-            track-&gt;height = st-&gt;codec-&gt;height;
-
-        av_set_pts_info(st, 64, 1, track-&gt;timescale);
-    }
-
-    mov_write_mdat_tag(pb, mov);
-    mov-&gt;time = s-&gt;timestamp + 0x7C25B080; //1970 based -&gt; 1904 based
-    mov-&gt;nb_streams = s-&gt;nb_streams;
-
-    put_flush_packet(pb);
-
-    return 0;
- error:
-    av_freep(&amp;mov-&gt;tracks);
-    return -1;
-}
-
 static int mov_parse_mpeg2_frame(AVPacket *pkt, uint32_t *flags)
 {
     uint32_t c = -1;
@@ -1831,7 +1859,7 @@
     return 0;
 }
 
-static int mov_write_packet(AVFormatContext *s, AVPacket *pkt)
+int ff_mov_write_packet(AVFormatContext *s, AVPacket *pkt)
 {
     MOVMuxContext *mov = s-&gt;priv_data;
     ByteIOContext *pb = s-&gt;pb;
@@ -1908,7 +1936,7 @@
         trk-&gt;flags |= MOV_TRACK_CTTS;
     trk-&gt;cluster[trk-&gt;entry].cts = pkt-&gt;pts - pkt-&gt;dts;
     trk-&gt;cluster[trk-&gt;entry].flags = 0;
-    if (pkt-&gt;flags &amp; PKT_FLAG_KEY) {
+    if (pkt-&gt;flags &amp; AV_PKT_FLAG_KEY) {
         if (mov-&gt;mode == MODE_MOV &amp;&amp; enc-&gt;codec_id == CODEC_ID_MPEG2VIDEO) {
             mov_parse_mpeg2_frame(pkt, &amp;trk-&gt;cluster[trk-&gt;entry].flags);
             if (trk-&gt;cluster[trk-&gt;entry].flags &amp; MOV_PARTIAL_SYNC_SAMPLE)
@@ -1924,9 +1952,191 @@
     mov-&gt;mdat_size += size;
 
     put_flush_packet(pb);
+
+    if (trk-&gt;hint_track &gt;= 0 &amp;&amp; trk-&gt;hint_track &lt; mov-&gt;nb_streams)
+        ff_mov_add_hinted_packet(s, pkt, trk-&gt;hint_track, trk-&gt;entry);
     return 0;
 }
 
+// QuickTime chapters involve an additional text track with the chapter names
+// as samples, and a tref pointing from the other tracks to the chapter one.
+static void mov_create_chapter_track(AVFormatContext *s, int tracknum)
+{
+    MOVMuxContext *mov = s-&gt;priv_data;
+    MOVTrack *track = &amp;mov-&gt;tracks[tracknum];
+    AVPacket pkt = { .stream_index = tracknum, .flags = AV_PKT_FLAG_KEY };
+    int i, len;
+
+    track-&gt;mode = mov-&gt;mode;
+    track-&gt;tag = MKTAG('t','e','x','t');
+    track-&gt;timescale = MOV_TIMESCALE;
+    track-&gt;enc = avcodec_alloc_context();
+    track-&gt;enc-&gt;codec_type = AVMEDIA_TYPE_SUBTITLE;
+
+    for (i = 0; i &lt; s-&gt;nb_chapters; i++) {
+        AVChapter *c = s-&gt;chapters[i];
+        AVMetadataTag *t;
+
+        int64_t end = av_rescale_q(c-&gt;end, c-&gt;time_base, (AVRational){1,MOV_TIMESCALE});
+        pkt.pts = pkt.dts = av_rescale_q(c-&gt;start, c-&gt;time_base, (AVRational){1,MOV_TIMESCALE});
+        pkt.duration = end - pkt.dts;
+
+        if ((t = av_metadata_get(c-&gt;metadata, &quot;title&quot;, NULL, 0))) {
+            len = strlen(t-&gt;value);
+            pkt.size = len+2;
+            pkt.data = av_malloc(pkt.size);
+            AV_WB16(pkt.data, len);
+            memcpy(pkt.data+2, t-&gt;value, len);
+            ff_mov_write_packet(s, &amp;pkt);
+            av_freep(&amp;pkt.data);
+        }
+    }
+}
+
+static int mov_write_header(AVFormatContext *s)
+{
+    ByteIOContext *pb = s-&gt;pb;
+    MOVMuxContext *mov = s-&gt;priv_data;
+    int i, hint_track = 0;
+
+    if (url_is_streamed(s-&gt;pb)) {
+        av_log(s, AV_LOG_ERROR, &quot;muxer does not support non seekable output\n&quot;);
+        return -1;
+    }
+
+    /* Default mode == MP4 */
+    mov-&gt;mode = MODE_MP4;
+
+    if (s-&gt;oformat != NULL) {
+        if (!strcmp(&quot;3gp&quot;, s-&gt;oformat-&gt;name)) mov-&gt;mode = MODE_3GP;
+        else if (!strcmp(&quot;3g2&quot;, s-&gt;oformat-&gt;name)) mov-&gt;mode = MODE_3GP|MODE_3G2;
+        else if (!strcmp(&quot;mov&quot;, s-&gt;oformat-&gt;name)) mov-&gt;mode = MODE_MOV;
+        else if (!strcmp(&quot;psp&quot;, s-&gt;oformat-&gt;name)) mov-&gt;mode = MODE_PSP;
+        else if (!strcmp(&quot;ipod&quot;,s-&gt;oformat-&gt;name)) mov-&gt;mode = MODE_IPOD;
+
+        mov_write_ftyp_tag(pb,s);
+        if (mov-&gt;mode == MODE_PSP) {
+            if (s-&gt;nb_streams != 2) {
+                av_log(s, AV_LOG_ERROR, &quot;PSP mode need one video and one audio stream\n&quot;);
+                return -1;
+            }
+            mov_write_uuidprof_tag(pb,s);
+        }
+    }
+
+    mov-&gt;nb_streams = s-&gt;nb_streams;
+    if (mov-&gt;mode &amp; (MODE_MOV|MODE_IPOD) &amp;&amp; s-&gt;nb_chapters)
+        mov-&gt;chapter_track = mov-&gt;nb_streams++;
+
+    if (s-&gt;flags &amp; AVFMT_FLAG_RTP_HINT) {
+        /* Add hint tracks for each audio and video stream */
+        hint_track = mov-&gt;nb_streams;
+        for (i = 0; i &lt; s-&gt;nb_streams; i++) {
+            AVStream *st = s-&gt;streams[i];
+            if (st-&gt;codec-&gt;codec_type == AVMEDIA_TYPE_VIDEO ||
+                st-&gt;codec-&gt;codec_type == AVMEDIA_TYPE_AUDIO) {
+                mov-&gt;nb_streams++;
+            }
+        }
+    }
+
+    mov-&gt;tracks = av_mallocz(mov-&gt;nb_streams*sizeof(*mov-&gt;tracks));
+    if (!mov-&gt;tracks)
+        return AVERROR(ENOMEM);
+
+    for(i=0; i&lt;s-&gt;nb_streams; i++){
+        AVStream *st= s-&gt;streams[i];
+        MOVTrack *track= &amp;mov-&gt;tracks[i];
+        AVMetadataTag *lang = av_metadata_get(st-&gt;metadata, &quot;language&quot;, NULL,0);
+
+        track-&gt;enc = st-&gt;codec;
+        track-&gt;language = ff_mov_iso639_to_lang(lang?lang-&gt;value:&quot;und&quot;, mov-&gt;mode!=MODE_MOV);
+        if (track-&gt;language &lt; 0)
+            track-&gt;language = 0;
+        track-&gt;mode = mov-&gt;mode;
+        track-&gt;tag = mov_find_codec_tag(s, track);
+        if (!track-&gt;tag) {
+            av_log(s, AV_LOG_ERROR, &quot;track %d: could not find tag, &quot;
+                   &quot;codec not currently supported in container\n&quot;, i);
+            goto error;
+        }
+        /* If hinting of this track is enabled by a later hint track,
+         * this is updated. */
+        track-&gt;hint_track = -1;
+        if(st-&gt;codec-&gt;codec_type == AVMEDIA_TYPE_VIDEO){
+            if (track-&gt;tag == MKTAG('m','x','3','p') || track-&gt;tag == MKTAG('m','x','3','n') ||
+                track-&gt;tag == MKTAG('m','x','4','p') || track-&gt;tag == MKTAG('m','x','4','n') ||
+                track-&gt;tag == MKTAG('m','x','5','p') || track-&gt;tag == MKTAG('m','x','5','n')) {
+                if (st-&gt;codec-&gt;width != 720 || (st-&gt;codec-&gt;height != 608 &amp;&amp; st-&gt;codec-&gt;height != 512)) {
+                    av_log(s, AV_LOG_ERROR, &quot;D-10/IMX must use 720x608 or 720x512 video resolution\n&quot;);
+                    goto error;
+                }
+                track-&gt;height = track-&gt;tag&gt;&gt;24 == 'n' ? 486 : 576;
+            }
+            track-&gt;timescale = st-&gt;codec-&gt;time_base.den;
+            if (track-&gt;mode == MODE_MOV &amp;&amp; track-&gt;timescale &gt; 100000)
+                av_log(s, AV_LOG_WARNING,
+                       &quot;WARNING codec timebase is very high. If duration is too long,\n&quot;
+                       &quot;file may not be playable by quicktime. Specify a shorter timebase\n&quot;
+                       &quot;or choose different container.\n&quot;);
+        }else if(st-&gt;codec-&gt;codec_type == AVMEDIA_TYPE_AUDIO){
+            track-&gt;timescale = st-&gt;codec-&gt;sample_rate;
+            if(!st-&gt;codec-&gt;frame_size &amp;&amp; !av_get_bits_per_sample(st-&gt;codec-&gt;codec_id)) {
+                av_log(s, AV_LOG_ERROR, &quot;track %d: codec frame size is not set\n&quot;, i);
+                goto error;
+            }else if(st-&gt;codec-&gt;frame_size &gt; 1){ /* assume compressed audio */
+                track-&gt;audio_vbr = 1;
+            }else{
+                st-&gt;codec-&gt;frame_size = 1;
+                track-&gt;sampleSize = (av_get_bits_per_sample(st-&gt;codec-&gt;codec_id) &gt;&gt; 3) * st-&gt;codec-&gt;channels;
+            }
+            if (track-&gt;mode != MODE_MOV) {
+                if (track-&gt;timescale &gt; UINT16_MAX) {
+                    av_log(s, AV_LOG_ERROR, &quot;track %d: output format does not support &quot;
+                           &quot;sample rate %dhz\n&quot;, i, track-&gt;timescale);
+                    goto error;
+                }
+                if (track-&gt;enc-&gt;codec_id == CODEC_ID_MP3 &amp;&amp; track-&gt;timescale &lt; 16000) {
+                    av_log(s, AV_LOG_ERROR, &quot;track %d: muxing mp3 at %dhz is not supported\n&quot;,
+                           i, track-&gt;enc-&gt;sample_rate);
+                    goto error;
+                }
+            }
+        }else if(st-&gt;codec-&gt;codec_type == AVMEDIA_TYPE_SUBTITLE){
+            track-&gt;timescale = st-&gt;codec-&gt;time_base.den;
+        }
+        if (!track-&gt;height)
+            track-&gt;height = st-&gt;codec-&gt;height;
+
+        av_set_pts_info(st, 64, 1, track-&gt;timescale);
+    }
+
+    mov_write_mdat_tag(pb, mov);
+    mov-&gt;time = s-&gt;timestamp + 0x7C25B080; //1970 based -&gt; 1904 based
+
+    if (mov-&gt;chapter_track)
+        mov_create_chapter_track(s, mov-&gt;chapter_track);
+
+    if (s-&gt;flags &amp; AVFMT_FLAG_RTP_HINT) {
+        /* Initialize the hint tracks for each audio and video stream */
+        for (i = 0; i &lt; s-&gt;nb_streams; i++) {
+            AVStream *st = s-&gt;streams[i];
+            if (st-&gt;codec-&gt;codec_type == AVMEDIA_TYPE_VIDEO ||
+                st-&gt;codec-&gt;codec_type == AVMEDIA_TYPE_AUDIO) {
+                ff_mov_init_hinting(s, hint_track, i);
+                hint_track++;
+            }
+        }
+    }
+
+    put_flush_packet(pb);
+
+    return 0;
+ error:
+    av_freep(&amp;mov-&gt;tracks);
+    return -1;
+}
+
 static int mov_write_trailer(AVFormatContext *s)
 {
     MOVMuxContext *mov = s-&gt;priv_data;
@@ -1951,7 +2161,12 @@
 
     mov_write_moov_tag(pb, mov, s);
 
+    if (mov-&gt;chapter_track)
+        av_freep(&amp;mov-&gt;tracks[mov-&gt;chapter_track].enc);
+
     for (i=0; i&lt;mov-&gt;nb_streams; i++) {
+        if (mov-&gt;tracks[i].tag == MKTAG('r','t','p',' '))
+            ff_mov_close_hinting(&amp;mov-&gt;tracks[i]);
         av_freep(&amp;mov-&gt;tracks[i].cluster);
 
         if(mov-&gt;tracks[i].vosLen) av_free(mov-&gt;tracks[i].vosData);
@@ -1975,7 +2190,7 @@
     CODEC_ID_AAC,
     CODEC_ID_MPEG4,
     mov_write_header,
-    mov_write_packet,
+    ff_mov_write_packet,
     mov_write_trailer,
     .flags = AVFMT_GLOBALHEADER | AVFMT_VARIABLE_FPS,
     .codec_tag = (const AVCodecTag* const []){codec_movvideo_tags, codec_movaudio_tags, 0},
@@ -1991,7 +2206,7 @@
     CODEC_ID_AMR_NB,
     CODEC_ID_H263,
     mov_write_header,
-    mov_write_packet,
+    ff_mov_write_packet,
     mov_write_trailer,
     .flags = AVFMT_GLOBALHEADER,
     .codec_tag = (const AVCodecTag* const []){codec_3gp_tags, 0},
@@ -2007,7 +2222,7 @@
     CODEC_ID_AAC,
     CODEC_ID_MPEG4,
     mov_write_header,
-    mov_write_packet,
+    ff_mov_write_packet,
     mov_write_trailer,
     .flags = AVFMT_GLOBALHEADER | AVFMT_VARIABLE_FPS,
     .codec_tag = (const AVCodecTag* const []){ff_mp4_obj_type, 0},
@@ -2023,7 +2238,7 @@
     CODEC_ID_AAC,
     CODEC_ID_MPEG4,
     mov_write_header,
-    mov_write_packet,
+    ff_mov_write_packet,
     mov_write_trailer,
     .flags = AVFMT_GLOBALHEADER,
     .codec_tag = (const AVCodecTag* const []){ff_mp4_obj_type, 0},
@@ -2039,7 +2254,7 @@
     CODEC_ID_AMR_NB,
     CODEC_ID_H263,
     mov_write_header,
-    mov_write_packet,
+    ff_mov_write_packet,
     mov_write_trailer,
     .flags = AVFMT_GLOBALHEADER,
     .codec_tag = (const AVCodecTag* const []){codec_3gp_tags, 0},
@@ -2055,7 +2270,7 @@
     CODEC_ID_AAC,
     CODEC_ID_H264,
     mov_write_header,
-    mov_write_packet,
+    ff_mov_write_packet,
     mov_write_trailer,
     .flags = AVFMT_GLOBALHEADER,
     .codec_tag = (const AVCodecTag* const []){codec_ipod_tags, 0},

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/mpegenc.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/mpegenc.c	2010-05-26 05:26:23 UTC (rev 6232)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/mpegenc.c	2010-05-26 05:26:29 UTC (rev 6233)
@@ -1300,3 +1300,13 @@
     mpeg_mux_end,
 };
 #endif
+// MEANX
+//
+int mpegenc_init(void)
+{
+    av_register_output_format(&amp;mpeg2dvd_muxer);
+    av_register_output_format(&amp;mpeg2svcd_muxer);
+    av_register_output_format(&amp;mpeg2vob_muxer);
+    av_register_output_format(&amp;mpeg1vcd_muxer);
+    return 0;
+}
\ No newline at end of file

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/mpegtsenc.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/mpegtsenc.c	2010-05-26 05:26:23 UTC (rev 6232)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/mpegtsenc.c	2010-05-26 05:26:29 UTC (rev 6233)
@@ -918,3 +918,8 @@
     mpegts_write_packet,
     mpegts_write_end,
 };
+int mpegtsenc_init(void)
+{
+    av_register_output_format(&amp;mpegts_muxer);
+    return 0;
+}
\ No newline at end of file

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/utils.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/utils.c	2010-05-26 05:26:23 UTC (rev 6232)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat/utils.c	2010-05-26 05:26:29 UTC (rev 6233)
@@ -49,13 +49,14 @@
 
 const char *avformat_configuration(void)
 {
-    return FFMPEG_CONFIGURATION;
+    return &quot;avidemux&quot;; //FFMPEG_CONFIGURATION;
 }
 
 const char *avformat_license(void)
 {
 #define LICENSE_PREFIX &quot;libavformat license: &quot;
-    return LICENSE_PREFIX FFMPEG_LICENSE + sizeof(LICENSE_PREFIX) - 1;
+    //return LICENSE_PREFIX FFMPEG_LICENSE + sizeof(LICENSE_PREFIX) - 1;
+        return LICENSE_PREFIX &quot;GPL&quot;;
 }
 
 /* fraction handling */


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="003428.html">[Avidemux-svn-commit] r6232 - in	branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil:	. arm sh4 tomi x86
</A></li>
	<LI>Next message: <A HREF="003430.html">[Avidemux-svn-commit] r6234 - in	branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil:	. x86
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3429">[ date ]</a>
              <a href="thread.html#3429">[ thread ]</a>
              <a href="subject.html#3429">[ subject ]</a>
              <a href="author.html#3429">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">More information about the Avidemux-svn-commit
mailing list</a><br>
</body></html>
