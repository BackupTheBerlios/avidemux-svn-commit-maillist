<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Avidemux-svn-commit] r6232 - in	branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil:	. arm sh4 tomi x86
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/avidemux-svn-commit/2010-May/index.html" >
   <LINK REL="made" HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r6232%20-%20in%0A%09branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil%3A%0A%09.%20arm%20sh4%20tomi%20x86&In-Reply-To=%3C201005260526.o4Q5QPE9028071%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="003427.html">
   <LINK REL="Next"  HREF="003429.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Avidemux-svn-commit] r6232 - in	branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil:	. arm sh4 tomi x86</H1>
    <B>mean at BerliOS</B> 
    <A HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r6232%20-%20in%0A%09branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil%3A%0A%09.%20arm%20sh4%20tomi%20x86&In-Reply-To=%3C201005260526.o4Q5QPE9028071%40sheep.berlios.de%3E"
       TITLE="[Avidemux-svn-commit] r6232 - in	branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil:	. arm sh4 tomi x86">mean at mail.berlios.de
       </A><BR>
    <I>Wed May 26 07:26:26 CEST 2010</I>
    <P><UL>
        <LI>Previous message: <A HREF="003427.html">[Avidemux-svn-commit] r6229 - in	branches/avidemux_2.5_branch_gruntster: avidemux	plugins/ADM_audioEncoders plugins/ADM_audioEncoders/aften
</A></li>
        <LI>Next message: <A HREF="003429.html">[Avidemux-svn-commit] r6233 -	branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3428">[ date ]</a>
              <a href="thread.html#3428">[ thread ]</a>
              <a href="subject.html#3428">[ subject ]</a>
              <a href="author.html#3428">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: mean
Date: 2010-05-26 07:26:23 +0200 (Wed, 26 May 2010)
New Revision: 6232

Added:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/attributes.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/avconfig.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/error.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/error.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/intmath.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/libm.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/pixdesc.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/pixdesc.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/tomi/
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/tomi/intreadwrite.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/x86/intmath.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/x86/intreadwrite.h
Modified:
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/adler32.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/adler32.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/arm/bswap.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/arm/intreadwrite.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/arm/timer.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/avstring.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/avstring.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/avutil.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/base64.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/bswap.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/common.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/crc.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/crc.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/des.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/fifo.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/fifo.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/integer.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/integer.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/internal.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/intfloat_readwrite.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/intfloat_readwrite.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/intreadwrite.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/lfg.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/lfg.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/lls.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/log.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/log.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/mathematics.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/mathematics.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/md5.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/mem.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/mem.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/pca.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/pca.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/pixfmt.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/random_seed.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/random_seed.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/rational.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/rational.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/sh4/bswap.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/sha.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/timer.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/tree.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/tree.h
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/utils.c
   branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/x86/bswap.h
Log:
[import lavutil] 24 05 2010

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/adler32.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/adler32.c	2010-05-26 05:26:02 UTC (rev 6231)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/adler32.c	2010-05-26 05:26:23 UTC (rev 6232)
@@ -21,7 +21,7 @@
  * 3. This notice may not be removed or altered from any source distribution.
  */
 
-#include &quot;common.h&quot;
+#include &quot;config.h&quot;
 #include &quot;adler32.h&quot;
 
 #define BASE 65521L /* largest prime smaller than 65536 */
@@ -53,6 +53,7 @@
 
 #ifdef TEST
 #include &quot;log.h&quot;
+#include &quot;timer.h&quot;
 #define LEN 7001
 volatile int checksum;
 int main(void){

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/adler32.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/adler32.h	2010-05-26 05:26:02 UTC (rev 6231)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/adler32.h	2010-05-26 05:26:23 UTC (rev 6232)
@@ -22,7 +22,7 @@
 #define AVUTIL_ADLER32_H
 
 #include &lt;stdint.h&gt;
-#include &quot;common.h&quot;
+#include &quot;attributes.h&quot;
 
 unsigned long av_adler32_update(unsigned long adler, const uint8_t *buf,
                                 unsigned int len) av_pure;

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/arm/bswap.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/arm/bswap.h	2010-05-26 05:26:02 UTC (rev 6231)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/arm/bswap.h	2010-05-26 05:26:23 UTC (rev 6232)
@@ -21,13 +21,13 @@
 
 #include &lt;stdint.h&gt;
 #include &quot;config.h&quot;
-#include &quot;libavutil/common.h&quot;
+#include &quot;libavutil/attributes.h&quot;
 
 #ifdef __ARMCC_VERSION
 
 #if HAVE_ARMV6
 #define bswap_16 bswap_16
-static av_always_inline av_const uint16_t bswap_16(uint16_t x)
+static av_always_inline av_const unsigned bswap_16(unsigned x)
 {
     __asm { rev16 x, x }
     return x;
@@ -44,7 +44,7 @@
 
 #if HAVE_ARMV6
 #define bswap_16 bswap_16
-static av_always_inline av_const uint16_t bswap_16(uint16_t x)
+static av_always_inline av_const unsigned bswap_16(unsigned x)
 {
     __asm__(&quot;rev16 %0, %0&quot; : &quot;+r&quot;(x));
     return x;

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/arm/intreadwrite.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/arm/intreadwrite.h	2010-05-26 05:26:02 UTC (rev 6231)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/arm/intreadwrite.h	2010-05-26 05:26:23 UTC (rev 6232)
@@ -25,7 +25,7 @@
 #if HAVE_FAST_UNALIGNED &amp;&amp; HAVE_INLINE_ASM
 
 #define AV_RN16 AV_RN16
-static inline uint16_t AV_RN16(const void *p)
+static av_always_inline uint16_t AV_RN16(const void *p)
 {
     uint16_t v;
     __asm__ (&quot;ldrh %0, %1&quot; : &quot;=r&quot;(v) : &quot;m&quot;(*(const uint16_t *)p));
@@ -33,13 +33,13 @@
 }
 
 #define AV_WN16 AV_WN16
-static inline void AV_WN16(void *p, uint16_t v)
+static av_always_inline void AV_WN16(void *p, uint16_t v)
 {
     __asm__ (&quot;strh %1, %0&quot; : &quot;=m&quot;(*(uint16_t *)p) : &quot;r&quot;(v));
 }
 
 #define AV_RN32 AV_RN32
-static inline uint32_t AV_RN32(const void *p)
+static av_always_inline uint32_t AV_RN32(const void *p)
 {
     uint32_t v;
     __asm__ (&quot;ldr  %0, %1&quot; : &quot;=r&quot;(v) : &quot;m&quot;(*(const uint32_t *)p));
@@ -47,13 +47,13 @@
 }
 
 #define AV_WN32 AV_WN32
-static inline void AV_WN32(void *p, uint32_t v)
+static av_always_inline void AV_WN32(void *p, uint32_t v)
 {
     __asm__ (&quot;str  %1, %0&quot; : &quot;=m&quot;(*(uint32_t *)p) : &quot;r&quot;(v));
 }
 
 #define AV_RN64 AV_RN64
-static inline uint64_t AV_RN64(const void *p)
+static av_always_inline uint64_t AV_RN64(const void *p)
 {
     union { uint64_t v; uint32_t hl[2]; } v;
     __asm__ (&quot;ldr   %0, %2  \n\t&quot;
@@ -64,7 +64,7 @@
 }
 
 #define AV_WN64 AV_WN64
-static inline void AV_WN64(void *p, uint64_t v)
+static av_always_inline void AV_WN64(void *p, uint64_t v)
 {
     union { uint64_t v; uint32_t hl[2]; } vv = { v };
     __asm__ (&quot;str  %2, %0  \n\t&quot;

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/arm/timer.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/arm/timer.h	2010-05-26 05:26:02 UTC (rev 6231)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/arm/timer.h	2010-05-26 05:26:23 UTC (rev 6232)
@@ -22,6 +22,7 @@
 #define AVUTIL_ARM_TIMER_H
 
 #include &lt;stdint.h&gt;
+#include &quot;config.h&quot;
 
 #if HAVE_INLINE_ASM &amp;&amp; defined(__ARM_ARCH_7A__)
 

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/attributes.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/attributes.h	2010-05-26 05:26:02 UTC (rev 6231)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/attributes.h	2010-05-26 05:26:23 UTC (rev 6232)
@@ -0,0 +1,121 @@
+/*
+ * copyright (c) 2006 Michael Niedermayer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">michaelni at gmx.at</A>&gt;
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+/**
+ * @file
+ * Macro definitions for various function/variable attributes
+ */
+
+#ifndef AVUTIL_ATTRIBUTES_H
+#define AVUTIL_ATTRIBUTES_H
+
+#ifdef __GNUC__
+#    define AV_GCC_VERSION_AT_LEAST(x,y) (__GNUC__ &gt; x || __GNUC__ == x &amp;&amp; __GNUC_MINOR__ &gt;= y)
+#else
+#    define AV_GCC_VERSION_AT_LEAST(x,y) 0
+#endif
+
+#ifndef av_always_inline
+#if AV_GCC_VERSION_AT_LEAST(3,1)
+#    define av_always_inline __attribute__((always_inline)) inline
+#else
+#    define av_always_inline inline
+#endif
+#endif
+
+#ifndef av_noinline
+#if AV_GCC_VERSION_AT_LEAST(3,1)
+#    define av_noinline __attribute__((noinline))
+#else
+#    define av_noinline
+#endif
+#endif
+
+#ifndef av_pure
+#if AV_GCC_VERSION_AT_LEAST(3,1)
+#    define av_pure __attribute__((pure))
+#else
+#    define av_pure
+#endif
+#endif
+
+#ifndef av_const
+#if AV_GCC_VERSION_AT_LEAST(2,6)
+#    define av_const __attribute__((const))
+#else
+#    define av_const
+#endif
+#endif
+
+#ifndef av_cold
+#if (!defined(__ICC) || __ICC &gt; 1110) &amp;&amp; AV_GCC_VERSION_AT_LEAST(4,3)
+#    define av_cold __attribute__((cold))
+#else
+#    define av_cold
+#endif
+#endif
+
+#ifndef av_flatten
+#if (!defined(__ICC) || __ICC &gt; 1110) &amp;&amp; AV_GCC_VERSION_AT_LEAST(4,1)
+#    define av_flatten __attribute__((flatten))
+#else
+#    define av_flatten
+#endif
+#endif
+
+#ifndef attribute_deprecated
+#if AV_GCC_VERSION_AT_LEAST(3,1)
+#    define attribute_deprecated __attribute__((deprecated))
+#else
+#    define attribute_deprecated
+#endif
+#endif
+
+#ifndef av_unused
+#if defined(__GNUC__)
+#    define av_unused __attribute__((unused))
+#else
+#    define av_unused
+#endif
+#endif
+
+#ifndef av_alias
+#if (!defined(__ICC) || __ICC &gt; 1110) &amp;&amp; AV_GCC_VERSION_AT_LEAST(3,3)
+#   define av_alias __attribute__((may_alias))
+#else
+#   define av_alias
+#endif
+#endif
+
+#ifndef av_uninit
+#if defined(__GNUC__) &amp;&amp; !defined(__ICC)
+#    define av_uninit(x) x=x
+#else
+#    define av_uninit(x) x
+#endif
+#endif
+
+#ifdef __GNUC__
+#    define av_builtin_constant_p __builtin_constant_p
+#else
+#    define av_builtin_constant_p(x) 0
+#endif
+
+#endif /* AVUTIL_ATTRIBUTES_H */

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/avconfig.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/avconfig.h	2010-05-26 05:26:02 UTC (rev 6231)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/avconfig.h	2010-05-26 05:26:23 UTC (rev 6232)
@@ -0,0 +1,5 @@
+/* Generated by ffconf */
+#ifndef AVUTIL_AVCONFIG_H
+#define AVUTIL_AVCONFIG_H
+#define AV_HAVE_BIGENDIAN 0
+#endif /* AVUTIL_AVCONFIG_H */

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/avstring.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/avstring.c	2010-05-26 05:26:02 UTC (rev 6231)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/avstring.c	2010-05-26 05:26:23 UTC (rev 6232)
@@ -24,6 +24,7 @@
 #include &lt;string.h&gt;
 #include &lt;ctype.h&gt;
 #include &quot;avstring.h&quot;
+#include &quot;mem.h&quot;
 
 int av_strstart(const char *str, const char *pfx, const char **ptr)
 {
@@ -47,6 +48,19 @@
     return !*pfx;
 }
 
+char *av_stristr(const char *s1, const char *s2)
+{
+    if (!*s2)
+        return s1;
+
+    do {
+        if (av_stristart(s1, s2, NULL))
+            return s1;
+    } while (*s1++);
+
+    return NULL;
+}
+
 size_t av_strlcpy(char *dst, const char *src, size_t size)
 {
     size_t len = 0;
@@ -76,3 +90,10 @@
 
     return len;
 }
+
+char *av_d2str(double d)
+{
+    char *str= av_malloc(16);
+    if(str) snprintf(str, 16, &quot;%f&quot;, d);
+    return str;
+}

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/avstring.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/avstring.h	2010-05-26 05:26:02 UTC (rev 6231)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/avstring.h	2010-05-26 05:26:23 UTC (rev 6232)
@@ -47,6 +47,20 @@
 int av_stristart(const char *str, const char *pfx, const char **ptr);
 
 /**
+ * Locate the first case-independent occurrence in the string haystack
+ * of the string needle.  A zero-length string needle is considered to
+ * match at the start of haystack.
+ *
+ * This function is a case-insensitive version of the standard strstr().
+ *
+ * @param haystack string to search in
+ * @param needle   string to search for
+ * @return         pointer to the located match within haystack
+ *                 or a null pointer if no match
+ */
+char *av_stristr(const char *haystack, const char *needle);
+
+/**
  * Copy the string src to dst, but no more than size - 1 bytes, and
  * null-terminate dst.
  *
@@ -56,6 +70,10 @@
  * @param src source string
  * @param size size of destination buffer
  * @return the length of src
+ *
+ * WARNING: since the return value is the length of src, src absolutely
+ * _must_ be a properly 0-terminated string, otherwise this will read beyond
+ * the end of the buffer and possibly crash.
  */
 size_t av_strlcpy(char *dst, const char *src, size_t size);
 
@@ -70,12 +88,16 @@
  * @param src source string
  * @param size size of destination buffer
  * @return the total length of src and dst
+ *
+ * WARNING: since the return value use the length of src and dst, these absolutely
+ * _must_ be a properly 0-terminated strings, otherwise this will read beyond
+ * the end of the buffer and possibly crash.
  */
 size_t av_strlcat(char *dst, const char *src, size_t size);
 
 /**
  * Append output to a string, according to a format. Never write out of
- * the destination buffer, and and always put a terminating 0 within
+ * the destination buffer, and always put a terminating 0 within
  * the buffer.
  * @param dst destination buffer (string to which the output is
  *  appended)
@@ -87,4 +109,9 @@
  */
 size_t av_strlcatf(char *dst, size_t size, const char *fmt, ...);
 
+/**
+ * Convert a number to a av_malloced string.
+ */
+char *av_d2str(double d);
+
 #endif /* AVUTIL_AVSTRING_H */

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/avutil.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/avutil.h	2010-05-26 05:26:02 UTC (rev 6231)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/avutil.h	2010-05-26 05:26:23 UTC (rev 6232)
@@ -22,27 +22,25 @@
 #define AVUTIL_AVUTIL_H
 
 /**
- * @file libavutil/avutil.h
+ * @file
  * external API header
  */
 
-/* MEANX
- * - */
-#define ASMALIGN(ZEROBITS) &quot;.p2align &quot; #ZEROBITS &quot;\n\t&quot;
-/* /MEANX
- */
 
-
-
 #define AV_STRINGIFY(s)         AV_TOSTRING(s)
 #define AV_TOSTRING(s) #s
 
+#define AV_GLUE(a, b) a ## b
+#define AV_JOIN(a, b) AV_GLUE(a, b)
+
+#define AV_PRAGMA(s) _Pragma(#s)
+
 #define AV_VERSION_INT(a, b, c) (a&lt;&lt;16 | b&lt;&lt;8 | c)
 #define AV_VERSION_DOT(a, b, c) a ##.## b ##.## c
 #define AV_VERSION(a, b, c) AV_VERSION_DOT(a, b, c)
 
 #define LIBAVUTIL_VERSION_MAJOR 50
-#define LIBAVUTIL_VERSION_MINOR  3
+#define LIBAVUTIL_VERSION_MINOR 16
 #define LIBAVUTIL_VERSION_MICRO  0
 
 #define LIBAVUTIL_VERSION_INT   AV_VERSION_INT(LIBAVUTIL_VERSION_MAJOR, \
@@ -60,7 +58,28 @@
  */
 unsigned avutil_version(void);
 
+/**
+ * Returns the libavutil build-time configuration.
+ */
+const char *avutil_configuration(void);
+
+/**
+ * Returns the libavutil license.
+ */
+const char *avutil_license(void);
+
+enum AVMediaType {
+    AVMEDIA_TYPE_UNKNOWN = -1,
+    AVMEDIA_TYPE_VIDEO,
+    AVMEDIA_TYPE_AUDIO,
+    AVMEDIA_TYPE_DATA,
+    AVMEDIA_TYPE_SUBTITLE,
+    AVMEDIA_TYPE_ATTACHMENT,
+    AVMEDIA_TYPE_NB
+};
+
 #include &quot;common.h&quot;
+#include &quot;error.h&quot;
 #include &quot;mathematics.h&quot;
 #include &quot;rational.h&quot;
 #include &quot;intfloat_readwrite.h&quot;

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/base64.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/base64.c	2010-05-26 05:26:02 UTC (rev 6231)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/base64.c	2010-05-26 05:26:23 UTC (rev 6232)
@@ -19,7 +19,7 @@
  */
 
 /**
- * @file libavutil/base64.c
+ * @file
  * @brief Base64 encode/decode
  * @author Ryan Martell &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">rdm4 at martellventures.com</A>&gt; (with lots of Michael)
  */

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/bswap.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/bswap.h	2010-05-26 05:26:02 UTC (rev 6231)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/bswap.h	2010-05-26 05:26:23 UTC (rev 6232)
@@ -19,7 +19,7 @@
  */
 
 /**
- * @file libavutil/bswap.h
+ * @file
  * byte swapping routines
  */
 
@@ -27,14 +27,9 @@
 #define AVUTIL_BSWAP_H
 
 #include &lt;stdint.h&gt;
-// MEANX
-#ifndef ADM_NO_CONFIG_H
 #include &quot;config.h&quot;
-#endif
-// MEANX
+#include &quot;attributes.h&quot;
 
-#include &quot;common.h&quot;
-
 #if   ARCH_ARM
 #   include &quot;arm/bswap.h&quot;
 #elif ARCH_AVR32
@@ -47,6 +42,12 @@
 #   include &quot;x86/bswap.h&quot;
 #endif
 
+#define AV_BSWAP16C(x) (((x) &lt;&lt; 8 &amp; 0xff00)  | ((x) &gt;&gt; 8 &amp; 0x00ff))
+#define AV_BSWAP32C(x) (AV_BSWAP16C(x) &lt;&lt; 16 | AV_BSWAP16C((x) &gt;&gt; 16))
+#define AV_BSWAP64C(x) (AV_BSWAP32C(x) &lt;&lt; 32 | AV_BSWAP32C((x) &gt;&gt; 32))
+
+#define AV_BSWAPC(s, x) AV_BSWAP##s##C(x)
+
 #ifndef bswap_16
 static av_always_inline av_const uint16_t bswap_16(uint16_t x)
 {
@@ -94,6 +95,8 @@
 #define le2me_16(x) bswap_16(x)
 #define le2me_32(x) bswap_32(x)
 #define le2me_64(x) bswap_64(x)
+#define AV_BE2MEC(s, x) (x)
+#define AV_LE2MEC(s, x) AV_BSWAPC(s, x)
 #else
 #define be2me_16(x) bswap_16(x)
 #define be2me_32(x) bswap_32(x)
@@ -101,6 +104,15 @@
 #define le2me_16(x) (x)
 #define le2me_32(x) (x)
 #define le2me_64(x) (x)
+#define AV_BE2MEC(s, x) AV_BSWAPC(s, x)
+#define AV_LE2MEC(s, x) (x)
 #endif
 
+#define AV_BE2ME16C(x) AV_BE2MEC(16, x)
+#define AV_BE2ME32C(x) AV_BE2MEC(32, x)
+#define AV_BE2ME64C(x) AV_BE2MEC(64, x)
+#define AV_LE2ME16C(x) AV_LE2MEC(16, x)
+#define AV_LE2ME32C(x) AV_LE2MEC(32, x)
+#define AV_LE2ME64C(x) AV_LE2MEC(64, x)
+
 #endif /* AVUTIL_BSWAP_H */

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/common.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/common.h	2010-05-26 05:26:02 UTC (rev 6231)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/common.h	2010-05-26 05:26:23 UTC (rev 6232)
@@ -19,7 +19,7 @@
  */
 
 /**
- * @file libavutil/common.h
+ * @file
  * common internal and external API header
  */
 
@@ -34,89 +34,8 @@
 #include &lt;stdio.h&gt;
 #include &lt;stdlib.h&gt;
 #include &lt;string.h&gt;
+#include &quot;attributes.h&quot;
 
-#ifdef HAVE_AV_CONFIG_H
-#include &quot;config.h&quot;
-#endif
-
-#ifdef __GNUC__
-#    define AV_GCC_VERSION_AT_LEAST(x,y) (__GNUC__ &gt; x || __GNUC__ == x &amp;&amp; __GNUC_MINOR__ &gt;= y)
-#else
-#    define AV_GCC_VERSION_AT_LEAST(x,y) 0
-#endif
-
-#ifndef av_always_inline
-#if AV_GCC_VERSION_AT_LEAST(3,1)
-#    define av_always_inline __attribute__((always_inline)) inline
-#else
-#    define av_always_inline inline
-#endif
-#endif
-
-#ifndef av_noinline
-#if AV_GCC_VERSION_AT_LEAST(3,1)
-#    define av_noinline __attribute__((noinline))
-#else
-#    define av_noinline
-#endif
-#endif
-
-#ifndef av_pure
-#if AV_GCC_VERSION_AT_LEAST(3,1)
-#    define av_pure __attribute__((pure))
-#else
-#    define av_pure
-#endif
-#endif
-
-#ifndef av_const
-#if AV_GCC_VERSION_AT_LEAST(2,6)
-#    define av_const __attribute__((const))
-#else
-#    define av_const
-#endif
-#endif
-
-#ifndef av_cold
-#if (!defined(__ICC) || __ICC &gt; 1110) &amp;&amp; AV_GCC_VERSION_AT_LEAST(4,3)
-#    define av_cold __attribute__((cold))
-#else
-#    define av_cold
-#endif
-#endif
-
-#ifndef av_flatten
-#if (!defined(__ICC) || __ICC &gt; 1110) &amp;&amp; AV_GCC_VERSION_AT_LEAST(4,1)
-#    define av_flatten __attribute__((flatten))
-#else
-#    define av_flatten
-#endif
-#endif
-
-#ifndef attribute_deprecated
-#if AV_GCC_VERSION_AT_LEAST(3,1)
-#    define attribute_deprecated __attribute__((deprecated))
-#else
-#    define attribute_deprecated
-#endif
-#endif
-
-#ifndef av_unused
-#if defined(__GNUC__)
-#    define av_unused __attribute__((unused))
-#else
-#    define av_unused
-#endif
-#endif
-
-#ifndef av_uninit
-#if defined(__GNUC__) &amp;&amp; !defined(__ICC)
-#    define av_uninit(x) x=x
-#else
-#    define av_uninit(x) x
-#endif
-#endif
-
 //rounded division &amp; shift
 #define RSHIFT(a,b) ((a) &gt; 0 ? ((a) + ((1&lt;&lt;(b))&gt;&gt;1))&gt;&gt;(b) : ((a) + ((1&lt;&lt;(b))&gt;&gt;1)-1)&gt;&gt;(b))
 /* assume b&gt;0 */
@@ -136,7 +55,9 @@
 /* misc math functions */
 extern const uint8_t ff_log2_tab[256];
 
-static inline av_const int av_log2(unsigned int v)
+extern const uint8_t av_reverse[256];
+
+static inline av_const int av_log2_c(unsigned int v)
 {
     int n = 0;
     if (v &amp; 0xffff0000) {
@@ -152,7 +73,7 @@
     return n;
 }
 
-static inline av_const int av_log2_16bit(unsigned int v)
+static inline av_const int av_log2_16bit_c(unsigned int v)
 {
     int n = 0;
     if (v &amp; 0xff00) {
@@ -164,6 +85,18 @@
     return n;
 }
 
+#ifdef HAVE_AV_CONFIG_H
+#   include &quot;config.h&quot;
+#   include &quot;intmath.h&quot;
+#endif
+
+#ifndef av_log2
+#   define av_log2       av_log2_c
+#endif
+#ifndef av_log2_16bit
+#   define av_log2_16bit av_log2_16bit_c
+#endif
+
 /**
  * Clips a signed integer value into the amin-amax range.
  * @param a value to clip
@@ -185,8 +118,8 @@
  */
 static inline av_const uint8_t av_clip_uint8(int a)
 {
-    if (a&amp;(~255)) return (-a)&gt;&gt;31;
-    else          return a;
+    if (a&amp;(~0xFF)) return (-a)&gt;&gt;31;
+    else           return a;
 }
 
 /**
@@ -196,8 +129,8 @@
  */
 static inline av_const uint16_t av_clip_uint16(int a)
 {
-    if (a&amp;(~65535)) return (-a)&gt;&gt;31;
-    else            return a;
+    if (a&amp;(~0xFFFF)) return (-a)&gt;&gt;31;
+    else             return a;
 }
 
 /**
@@ -207,11 +140,22 @@
  */
 static inline av_const int16_t av_clip_int16(int a)
 {
-    if ((a+32768) &amp; ~65535) return (a&gt;&gt;31) ^ 32767;
-    else                    return a;
+    if ((a+0x8000) &amp; ~0xFFFF) return (a&gt;&gt;31) ^ 0x7FFF;
+    else                      return a;
 }
 
 /**
+ * Clips a signed 64-bit integer value into the -2147483648,2147483647 range.
+ * @param a value to clip
+ * @return clipped value
+ */
+static inline av_const int32_t av_clipl_int32(int64_t a)
+{
+    if ((a+0x80000000u) &amp; ~UINT64_C(0xFFFFFFFF)) return (a&gt;&gt;63) ^ 0x7FFFFFFF;
+    else                                         return a;
+}
+
+/**
  * Clips a float value into the amin-amax range.
  * @param a value to clip
  * @param amin minimum value of the clip range
@@ -225,6 +169,15 @@
     else               return a;
 }
 
+/** Computes ceil(log2(x)).
+ * @param x value used to compute ceil(log2(x))
+ * @return computed ceiling of log2(x)
+ */
+static inline av_const int av_ceil_log2(int x)
+{
+    return av_log2((x - 1) &lt;&lt; 1);
+}
+
 #define MKTAG(a,b,c,d) (a | (b &lt;&lt; 8) | (c &lt;&lt; 16) | (d &lt;&lt; 24))
 #define MKBETAG(a,b,c,d) (d | (c &lt;&lt; 8) | (b &lt;&lt; 16) | (a &lt;&lt; 24))
 
@@ -257,6 +210,30 @@
     }
 
 /*!
+ * \def GET_UTF16(val, GET_16BIT, ERROR)
+ * Converts a UTF-16 character (2 or 4 bytes) to its 32-bit UCS-4 encoded form
+ * \param val is the output and should be of type uint32_t. It holds the converted
+ * UCS-4 character and should be a left value.
+ * \param GET_16BIT gets two bytes of UTF-16 encoded data converted to native endianness.
+ * It can be a function or a statement whose return value or evaluated value is of type
+ * uint16_t. It will be executed up to 2 times.
+ * \param ERROR action that should be taken when an invalid UTF-16 surrogate is
+ * returned from GET_BYTE. It should be a statement that jumps out of the macro,
+ * like exit(), goto, return, break, or continue.
+ */
+#define GET_UTF16(val, GET_16BIT, ERROR)\
+    val = GET_16BIT;\
+    {\
+        unsigned int hi = val - 0xD800;\
+        if (hi &lt; 0x800) {\
+            val = GET_16BIT - 0xDC00;\
+            if (val &gt; 0x3FFU || hi &gt; 0x3FFU)\
+                ERROR\
+            val += (hi&lt;&lt;10) + 0x10000;\
+        }\
+    }\
+
+/*!
  * \def PUT_UTF8(val, tmp, PUT_BYTE)
  * Converts a 32-bit Unicode character to its UTF-8 encoded form (up to 4 bytes long).
  * \param val is an input-only argument and should be of type uint32_t. It holds
@@ -292,6 +269,36 @@
         }\
     }
 
+/*!
+ * \def PUT_UTF16(val, tmp, PUT_16BIT)
+ * Converts a 32-bit Unicode character to its UTF-16 encoded form (2 or 4 bytes).
+ * \param val is an input-only argument and should be of type uint32_t. It holds
+ * a UCS-4 encoded Unicode character that is to be converted to UTF-16. If
+ * val is given as a function it is executed only once.
+ * \param tmp is a temporary variable and should be of type uint16_t. It
+ * represents an intermediate value during conversion that is to be
+ * output by PUT_16BIT.
+ * \param PUT_16BIT writes the converted UTF-16 data to any proper destination
+ * in desired endianness. It could be a function or a statement, and uses tmp
+ * as the input byte.  For example, PUT_BYTE could be &quot;*output++ = tmp;&quot;
+ * PUT_BYTE will be executed 1 or 2 times depending on input character.
+ */
+#define PUT_UTF16(val, tmp, PUT_16BIT)\
+    {\
+        uint32_t in = val;\
+        if (in &lt; 0x10000) {\
+            tmp = in;\
+            PUT_16BIT\
+        } else {\
+            tmp = 0xD800 | ((in - 0x10000) &gt;&gt; 10);\
+            PUT_16BIT\
+            tmp = 0xDC00 | ((in - 0x10000) &amp; 0x3FF);\
+            PUT_16BIT\
+        }\
+    }\
+
+
+
 #include &quot;mem.h&quot;
 
 #ifdef HAVE_AV_CONFIG_H

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/crc.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/crc.c	2010-05-26 05:26:02 UTC (rev 6231)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/crc.c	2010-05-26 05:26:23 UTC (rev 6232)
@@ -19,6 +19,7 @@
  */
 
 #include &quot;config.h&quot;
+#include &quot;common.h&quot;
 #include &quot;bswap.h&quot;
 #include &quot;crc.h&quot;
 

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/crc.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/crc.h	2010-05-26 05:26:02 UTC (rev 6231)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/crc.h	2010-05-26 05:26:23 UTC (rev 6232)
@@ -23,7 +23,7 @@
 
 #include &lt;stdint.h&gt;
 #include &lt;stddef.h&gt;
-#include &quot;common.h&quot;
+#include &quot;attributes.h&quot;
 
 typedef uint32_t AVCRC;
 

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/des.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/des.c	2010-05-26 05:26:02 UTC (rev 6231)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/des.c	2010-05-26 05:26:23 UTC (rev 6232)
@@ -339,10 +339,10 @@
 }
 
 static const uint8_t test_key[] = {0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0};
-static const DECLARE_ALIGNED(8, uint8_t, plain[]) = {0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10};
-static const DECLARE_ALIGNED(8, uint8_t, crypt[]) = {0x4a, 0xb6, 0x5b, 0x3d, 0x4b, 0x06, 0x15, 0x18};
-static DECLARE_ALIGNED(8, uint8_t, tmp[8]);
-static DECLARE_ALIGNED(8, uint8_t, large_buffer[10002][8]);
+static const DECLARE_ALIGNED(8, uint8_t, plain)[] = {0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10};
+static const DECLARE_ALIGNED(8, uint8_t, crypt)[] = {0x4a, 0xb6, 0x5b, 0x3d, 0x4b, 0x06, 0x15, 0x18};
+static DECLARE_ALIGNED(8, uint8_t, tmp)[8];
+static DECLARE_ALIGNED(8, uint8_t, large_buffer)[10002][8];
 static const uint8_t cbc_key[] = {
     0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
     0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0x01,

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/error.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/error.c	2010-05-26 05:26:02 UTC (rev 6231)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/error.c	2010-05-26 05:26:23 UTC (rev 6232)
@@ -0,0 +1,47 @@
+/*
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include &quot;avutil.h&quot;
+#include &quot;avstring.h&quot;
+
+int av_strerror(int errnum, char *errbuf, size_t errbuf_size)
+{
+    int ret = 0;
+    const char *errstr = NULL;
+
+    switch (errnum) {
+    case AVERROR_EOF:               errstr = &quot;End of file&quot;; break;
+    case AVERROR_INVALIDDATA:       errstr = &quot;Invalid data found when processing input&quot;; break;
+    case AVERROR_NUMEXPECTED:       errstr = &quot;Number syntax expected in filename&quot;; break;
+    case AVERROR_PATCHWELCOME:      errstr = &quot;Not yet implemented in FFmpeg, patches welcome&quot;; break;
+    }
+
+    if (errstr) {
+        av_strlcpy(errbuf, errstr, errbuf_size);
+    } else {
+#if HAVE_STRERROR_R
+        ret = strerror_r(AVUNERROR(errnum), errbuf, errbuf_size);
+#else
+        ret = -1;
+#endif
+        if (ret &lt; 0)
+            snprintf(errbuf, errbuf_size, &quot;Error number %d occurred&quot;, errnum);
+    }
+
+    return ret;
+}

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/error.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/error.h	2010-05-26 05:26:02 UTC (rev 6231)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/error.h	2010-05-26 05:26:23 UTC (rev 6232)
@@ -0,0 +1,72 @@
+/*
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+/**
+ * @file
+ * error code definitions
+ */
+
+#ifndef AVUTIL_ERROR_H
+#define AVUTIL_ERROR_H
+
+#include &lt;errno.h&gt;
+#include &quot;avutil.h&quot;
+
+/* error handling */
+#if EDOM &gt; 0
+#define AVERROR(e) (-(e))   ///&lt; Returns a negative error code from a POSIX error code, to return from library functions.
+#define AVUNERROR(e) (-(e)) ///&lt; Returns a POSIX error code from a library function error return value.
+#else
+/* Some platforms have E* and errno already negated. */
+#define AVERROR(e) (e)
+#define AVUNERROR(e) (e)
+#endif
+
+#if LIBAVUTIL_VERSION_MAJOR &lt; 51
+#define AVERROR_INVALIDDATA AVERROR(EINVAL)  ///&lt; Invalid data found when processing input
+#define AVERROR_IO          AVERROR(EIO)     ///&lt; I/O error
+#define AVERROR_NOENT       AVERROR(ENOENT)  ///&lt; No such file or directory
+#define AVERROR_NOFMT       AVERROR(EILSEQ)  ///&lt; Unknown format
+#define AVERROR_NOMEM       AVERROR(ENOMEM)  ///&lt; Not enough memory
+#define AVERROR_NOTSUPP     AVERROR(ENOSYS)  ///&lt; Operation not supported
+#define AVERROR_NUMEXPECTED AVERROR(EDOM)    ///&lt; Number syntax expected in filename
+#define AVERROR_UNKNOWN     AVERROR(EINVAL)  ///&lt; Unknown error
+#endif
+
+#define AVERROR_EOF         AVERROR(EPIPE)   ///&lt; End of file
+
+#define AVERROR_PATCHWELCOME    (-MKTAG('P','A','W','E')) ///&lt; Not yet implemented in FFmpeg, patches welcome
+
+#if LIBAVUTIL_VERSION_MAJOR &gt; 50
+#define AVERROR_INVALIDDATA     (-MKTAG('I','N','D','A')) ///&lt; Invalid data found when processing input
+#define AVERROR_NUMEXPECTED     (-MKTAG('N','U','E','X')) ///&lt; Number syntax expected in filename
+#endif
+
+/**
+ * Puts a description of the AVERROR code errnum in errbuf.
+ * In case of failure the global variable errno is set to indicate the
+ * error. Even in case of failure av_strerror() will print a generic
+ * error message indicating the errnum provided to errbuf.
+ *
+ * @param errbuf_size the size in bytes of errbuf
+ * @return 0 on success, a negative value if a description for errnum
+ * cannot be found
+ */
+int av_strerror(int errnum, char *errbuf, size_t errbuf_size);
+
+#endif /* AVUTIL_ERROR_H */

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/fifo.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/fifo.c	2010-05-26 05:26:02 UTC (rev 6231)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/fifo.c	2010-05-26 05:26:23 UTC (rev 6232)
@@ -78,6 +78,7 @@
     return 0;
 }
 
+// src must NOT be const as it can be a context for func that may need updating (like a pointer or byte counter)
 int av_fifo_generic_write(AVFifoBuffer *f, void *src, int size, int (*func)(void*, void*, int))
 {
     int total = size;

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/fifo.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/fifo.h	2010-05-26 05:26:02 UTC (rev 6231)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/fifo.h	2010-05-26 05:26:23 UTC (rev 6232)
@@ -17,7 +17,7 @@
  */
 
 /**
- * @file libavutil/fifo.h
+ * @file
  * a very simple circular buffer FIFO implementation
  */
 
@@ -25,8 +25,6 @@
 #define AVUTIL_FIFO_H
 
 #include &lt;stdint.h&gt;
-#include &quot;avutil.h&quot;
-#include &quot;common.h&quot;
 
 typedef struct AVFifoBuffer {
     uint8_t *buffer;
@@ -37,7 +35,7 @@
 /**
  * Initializes an AVFifoBuffer.
  * @param size of FIFO
- * @return AVFifoBuffer or NULL if mem allocation failure
+ * @return AVFifoBuffer or NULL in case of memory allocation failure
  */
 AVFifoBuffer *av_fifo_alloc(unsigned int size);
 
@@ -81,7 +79,8 @@
 /**
  * Feeds data from a user-supplied callback to an AVFifoBuffer.
  * @param *f AVFifoBuffer to write to
- * @param *src data source
+ * @param *src data source; non-const since it may be used as a
+ * modifiable context by the function defined in func
  * @param size number of bytes to write
  * @param *func generic write function; the first parameter is src,
  * the second is dest_buf, the third is dest_buf_size.

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/integer.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/integer.c	2010-05-26 05:26:02 UTC (rev 6231)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/integer.c	2010-05-26 05:26:23 UTC (rev 6232)
@@ -20,7 +20,7 @@
  */
 
 /**
- * @file libavutil/integer.c
+ * @file
  * arbitrary precision integers
  * @author Michael Niedermayer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">michaelni at gmx.at</A>&gt;
  */

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/integer.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/integer.h	2010-05-26 05:26:02 UTC (rev 6231)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/integer.h	2010-05-26 05:26:23 UTC (rev 6232)
@@ -20,7 +20,7 @@
  */
 
 /**
- * @file libavutil/integer.h
+ * @file
  * arbitrary precision integers
  * @author Michael Niedermayer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">michaelni at gmx.at</A>&gt;
  */

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/internal.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/internal.h	2010-05-26 05:26:02 UTC (rev 6231)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/internal.h	2010-05-26 05:26:23 UTC (rev 6232)
@@ -19,7 +19,7 @@
  */
 
 /**
- * @file libavutil/internal.h
+ * @file
  * common internal API header
  */
 
@@ -34,13 +34,8 @@
 #include &lt;stdint.h&gt;
 #include &lt;stddef.h&gt;
 #include &lt;assert.h&gt;
-// MEANX
-#ifndef ADM_NO_CONFIG_H
 #include &quot;config.h&quot;
-#endif
-// MEANX
-#include &quot;common.h&quot;
-#include &quot;mem.h&quot;
+#include &quot;attributes.h&quot;
 #include &quot;timer.h&quot;
 
 #ifndef attribute_align_arg
@@ -60,7 +55,7 @@
 #endif
 
 #ifndef INT16_MIN
-#define INT16_MIN       (-0x7fff-1)
+#define INT16_MIN       (-0x7fff - 1)
 #endif
 
 #ifndef INT16_MAX
@@ -68,7 +63,7 @@
 #endif
 
 #ifndef INT32_MIN
-#define INT32_MIN       (-0x7fffffff-1)
+#define INT32_MIN       (-0x7fffffff - 1)
 #endif
 
 #ifndef INT32_MAX
@@ -80,7 +75,7 @@
 #endif
 
 #ifndef INT64_MIN
-#define INT64_MIN       (-0x7fffffffffffffffLL-1)
+#define INT64_MIN       (-0x7fffffffffffffffLL - 1)
 #endif
 
 #ifndef INT64_MAX
@@ -95,12 +90,8 @@
 #    define INT_BIT (CHAR_BIT * sizeof(int))
 #endif
 
-#if ( defined(__PIC__) || defined(__pic__) ) &amp;&amp; ! defined(PIC)
-#    define PIC
-#endif
-
 #ifndef offsetof
-#    define offsetof(T,F) ((unsigned int)((char *)&amp;((T *)0)-&gt;F))
+#    define offsetof(T, F) ((unsigned int)((char *)&amp;((T *)0)-&gt;F))
 #endif
 
 /* Use to export labels from asm. */
@@ -128,67 +119,7 @@
 
 /* math */
 
-extern const uint32_t ff_inverse[256];
-
 #if ARCH_X86
-#    define FASTDIV(a,b) \
-    ({\
-        int ret,dmy;\
-        __asm__ volatile(\
-            &quot;mull %3&quot;\
-            :&quot;=d&quot;(ret),&quot;=a&quot;(dmy)\
-            :&quot;1&quot;(a),&quot;g&quot;(ff_inverse[b])\
-            );\
-        ret;\
-    })
-#elif HAVE_ARMV6 &amp;&amp; HAVE_INLINE_ASM
-static inline av_const int FASTDIV(int a, int b)
-{
-    int r, t;
-    __asm__ volatile(&quot;cmp     %3, #2               \n\t&quot;
-                     &quot;ldr     %1, [%4, %3, lsl #2] \n\t&quot;
-                     &quot;lsrle   %0, %2, #1           \n\t&quot;
-                     &quot;smmulgt %0, %1, %2           \n\t&quot;
-                     : &quot;=&amp;r&quot;(r), &quot;=&amp;r&quot;(t) : &quot;r&quot;(a), &quot;r&quot;(b), &quot;r&quot;(ff_inverse));
-    return r;
-}
-#elif ARCH_ARM &amp;&amp; HAVE_INLINE_ASM
-static inline av_const int FASTDIV(int a, int b)
-{
-    int r, t;
-    __asm__ volatile (&quot;umull %1, %0, %2, %3&quot;
-                      : &quot;=&amp;r&quot;(r), &quot;=&amp;r&quot;(t) : &quot;r&quot;(a), &quot;r&quot;(ff_inverse[b]));
-    return r;
-}
-#elif CONFIG_FASTDIV
-#    define FASTDIV(a,b)   ((uint32_t)((((uint64_t)a)*ff_inverse[b])&gt;&gt;32))
-#else
-#    define FASTDIV(a,b)   ((a)/(b))
-#endif
-
-extern const uint8_t ff_sqrt_tab[256];
-
-static inline av_const unsigned int ff_sqrt(unsigned int a)
-{
-    unsigned int b;
-
-    if(a&lt;255) return (ff_sqrt_tab[a+1]-1)&gt;&gt;4;
-    else if(a&lt;(1&lt;&lt;12)) b= ff_sqrt_tab[a&gt;&gt;4 ]&gt;&gt;2;
-#if !CONFIG_SMALL
-    else if(a&lt;(1&lt;&lt;14)) b= ff_sqrt_tab[a&gt;&gt;6 ]&gt;&gt;1;
-    else if(a&lt;(1&lt;&lt;16)) b= ff_sqrt_tab[a&gt;&gt;8 ]   ;
-#endif
-    else{
-        int s= av_log2_16bit(a&gt;&gt;16)&gt;&gt;1;
-        unsigned int c= a&gt;&gt;(s+2);
-        b= ff_sqrt_tab[c&gt;&gt;(s+8)];
-        b= FASTDIV(c,b) + (b&lt;&lt;s);
-    }
-
-    return b - (a&lt;b*b);
-}
-
-#if ARCH_X86
 #define MASK_ABS(mask, level)\
             __asm__ volatile(\
                 &quot;cltd                   \n\t&quot;\
@@ -198,38 +129,17 @@
             );
 #else
 #define MASK_ABS(mask, level)\
-            mask= level&gt;&gt;31;\
-            level= (level^mask)-mask;
+            mask  = level &gt;&gt; 31;\
+            level = (level ^ mask) - mask;
 #endif
 
-#if HAVE_CMOV
-#define COPY3_IF_LT(x,y,a,b,c,d)\
-__asm__ volatile (\
-    &quot;cmpl %0, %3        \n\t&quot;\
-    &quot;cmovl %3, %0       \n\t&quot;\
-    &quot;cmovl %4, %1       \n\t&quot;\
-    &quot;cmovl %5, %2       \n\t&quot;\
-    : &quot;+&amp;r&quot; (x), &quot;+&amp;r&quot; (a), &quot;+r&quot; (c)\
-    : &quot;r&quot; (y), &quot;r&quot; (b), &quot;r&quot; (d)\
-);
-#else
-#define COPY3_IF_LT(x,y,a,b,c,d)\
-if((y)&lt;(x)){\
-     (x)=(y);\
-     (a)=(b);\
-     (c)=(d);\
-}
-#endif
-
 /* avoid usage of dangerous/inappropriate system functions */
-#if 0 //MEANX
 #undef  malloc
 #define malloc please_use_av_malloc
 #undef  free
 #define free please_use_av_free
 #undef  realloc
 #define realloc please_use_av_realloc
-#endif
 #undef  time
 #define time time_is_forbidden_due_to_security_issues
 #undef  rand
@@ -255,64 +165,26 @@
 #define perror please_use_av_log_instead_of_perror
 #endif
 
-#define CHECKED_ALLOCZ(p, size)\
+#define FF_ALLOC_OR_GOTO(ctx, p, size, label)\
 {\
-    p= av_mallocz(size);\
-    if(p==NULL &amp;&amp; (size)!=0){\
-        av_log(NULL, AV_LOG_ERROR, &quot;Cannot allocate memory.&quot;);\
-        goto fail;\
+    p = av_malloc(size);\
+    if (p == NULL &amp;&amp; (size) != 0) {\
+        av_log(ctx, AV_LOG_ERROR, &quot;Cannot allocate memory.\n&quot;);\
+        goto label;\
     }\
 }
 
-#if !HAVE_LLRINT
-static av_always_inline av_const long long llrint(double x)
-{
-    return rint(x);
+#define FF_ALLOCZ_OR_GOTO(ctx, p, size, label)\
+{\
+    p = av_mallocz(size);\
+    if (p == NULL &amp;&amp; (size) != 0) {\
+        av_log(ctx, AV_LOG_ERROR, &quot;Cannot allocate memory.\n&quot;);\
+        goto label;\
+    }\
 }
-#endif /* HAVE_LLRINT */
 
-#if !HAVE_LOG2
-static av_always_inline av_const double log2(double x)
-{
-    return log(x) * 1.44269504088896340736;
-}
-#endif /* HAVE_LOG2 */
+#include &quot;libm.h&quot;
 
-#if !HAVE_LRINT
-static av_always_inline av_const long int lrint(double x)
-{
-    return rint(x);
-}
-#endif /* HAVE_LRINT */
-
-#if !HAVE_LRINTF
-static av_always_inline av_const long int lrintf(float x)
-{
-    return (int)(rint(x));
-}
-#endif /* HAVE_LRINTF */
-
-#if !HAVE_ROUND
-static av_always_inline av_const double round(double x)
-{
-    return (x &gt; 0) ? floor(x + 0.5) : ceil(x - 0.5);
-}
-#endif /* HAVE_ROUND */
-
-#if !HAVE_ROUNDF
-static av_always_inline av_const float roundf(float x)
-{
-    return (x &gt; 0) ? floor(x + 0.5) : ceil(x - 0.5);
-}
-#endif /* HAVE_ROUNDF */
-
-#if !HAVE_TRUNCF
-static av_always_inline av_const float truncf(float x)
-{
-    return (x &gt; 0) ? floor(x) : ceil(x);
-}
-#endif /* HAVE_TRUNCF */
-
 /**
  * Returns NULL if CONFIG_SMALL is true, otherwise the argument
  * without modification. Used to disable the definition of strings

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/intfloat_readwrite.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/intfloat_readwrite.c	2010-05-26 05:26:02 UTC (rev 6231)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/intfloat_readwrite.c	2010-05-26 05:26:23 UTC (rev 6232)
@@ -21,11 +21,12 @@
  */
 
 /**
- * @file libavutil/intfloat_readwrite.c
+ * @file
  * portable IEEE float/double read/write functions
  */
 
-#include &quot;common.h&quot;
+#include &lt;stdint.h&gt;
+#include &lt;math.h&gt;
 #include &quot;intfloat_readwrite.h&quot;
 
 double av_int2dbl(int64_t v){

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/intfloat_readwrite.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/intfloat_readwrite.h	2010-05-26 05:26:02 UTC (rev 6231)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/intfloat_readwrite.h	2010-05-26 05:26:23 UTC (rev 6232)
@@ -22,7 +22,7 @@
 #define AVUTIL_INTFLOAT_READWRITE_H
 
 #include &lt;stdint.h&gt;
-#include &quot;common.h&quot;
+#include &quot;attributes.h&quot;
 
 /* IEEE 80 bits extended float */
 typedef struct AVExtFloat  {

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/intmath.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/intmath.h	2010-05-26 05:26:02 UTC (rev 6231)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/intmath.h	2010-05-26 05:26:23 UTC (rev 6232)
@@ -0,0 +1,98 @@
+/*
+ * Copyright (c) 2010 Mans Rullgard &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">mans at mansr.com</A>&gt;
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef AVUTIL_INTMATH_H
+#define AVUTIL_INTMATH_H
+
+#include &lt;stdint.h&gt;
+#include &quot;config.h&quot;
+#include &quot;attributes.h&quot;
+
+extern const uint32_t ff_inverse[257];
+
+#if   ARCH_ARM
+#   include &quot;arm/intmath.h&quot;
+#elif ARCH_X86
+#   include &quot;x86/intmath.h&quot;
+#endif
+
+#if HAVE_FAST_CLZ &amp;&amp; AV_GCC_VERSION_AT_LEAST(3,4)
+
+#ifndef av_log2
+
+#define av_log2(x) (31 - __builtin_clz((x)|1))
+
+#ifndef av_log2_16bit
+#define av_log2_16bit av_log2
+#endif
+
+#endif /* av_log2 */
+
+#endif /* AV_GCC_VERSION_AT_LEAST(3,4) */
+
+#ifndef FASTDIV
+
+#if CONFIG_FASTDIV
+#    define FASTDIV(a,b)   ((uint32_t)((((uint64_t)a) * ff_inverse[b]) &gt;&gt; 32))
+#else
+#    define FASTDIV(a,b)   ((a) / (b))
+#endif
+
+#endif /* FASTDIV */
+
+/*
+ * Get definition of av_log2_c from common.h.  In the event we got
+ * here through common.h including this file, including it again will
+ * be a no-op due to multi-inclusion guards, so we must duplicate the
+ * fallback defines here.
+ */
+
+#include &quot;common.h&quot;
+
+#ifndef av_log2
+#   define av_log2       av_log2_c
+#endif
+#ifndef av_log2_16bit
+#   define av_log2_16bit av_log2_16bit_c
+#endif
+
+extern const uint8_t ff_sqrt_tab[256];
+
+static inline av_const unsigned int ff_sqrt(unsigned int a)
+{
+    unsigned int b;
+
+    if (a &lt; 255) return (ff_sqrt_tab[a + 1] - 1) &gt;&gt; 4;
+    else if (a &lt; (1 &lt;&lt; 12)) b = ff_sqrt_tab[a &gt;&gt; 4] &gt;&gt; 2;
+#if !CONFIG_SMALL
+    else if (a &lt; (1 &lt;&lt; 14)) b = ff_sqrt_tab[a &gt;&gt; 6] &gt;&gt; 1;
+    else if (a &lt; (1 &lt;&lt; 16)) b = ff_sqrt_tab[a &gt;&gt; 8]   ;
+#endif
+    else {
+        int s = av_log2_16bit(a &gt;&gt; 16) &gt;&gt; 1;
+        unsigned int c = a &gt;&gt; (s + 2);
+        b = ff_sqrt_tab[c &gt;&gt; (s + 8)];
+        b = FASTDIV(c,b) + (b &lt;&lt; s);
+    }
+
+    return b - (a &lt; b * b);
+}
+
+#endif /* AVUTIL_INTMATH_H */

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/intreadwrite.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/intreadwrite.h	2010-05-26 05:26:02 UTC (rev 6231)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/intreadwrite.h	2010-05-26 05:26:23 UTC (rev 6232)
@@ -20,18 +20,36 @@
 #define AVUTIL_INTREADWRITE_H
 
 #include &lt;stdint.h&gt;
-// MEANX
-#ifndef ADM_NO_CONFIG_H
 #include &quot;config.h&quot;
-#endif
-// MEANX
-
 #include &quot;bswap.h&quot;
+#include &quot;common.h&quot;
 
+typedef union {
+    uint64_t u64;
+    uint32_t u32[2];
+    uint16_t u16[4];
+    uint8_t  u8 [8];
+    double   f64;
+    float    f32[2];
+} av_alias av_alias64;
+
+typedef union {
+    uint32_t u32;
+    uint16_t u16[2];
+    uint8_t  u8 [4];
+    float    f32;
+} av_alias av_alias32;
+
+typedef union {
+    uint16_t u16;
+    uint8_t  u8 [2];
+} av_alias av_alias16;
+
 /*
  * Arch-specific headers can provide any combination of
- * AV_[RW][BLN](16|24|32|64) macros.  Preprocessor symbols must be
- * defined, even if these are implemented as inline functions.
+ * AV_[RW][BLN](16|24|32|64) and AV_(COPY|SWAP|ZERO)(64|128) macros.
+ * Preprocessor symbols must be defined, even if these are implemented
+ * as inline functions.
  */
 
 #if   ARCH_ARM
@@ -42,6 +60,10 @@
 #   include &quot;mips/intreadwrite.h&quot;
 #elif ARCH_PPC
 #   include &quot;ppc/intreadwrite.h&quot;
+#elif ARCH_TOMI
+#   include &quot;tomi/intreadwrite.h&quot;
+#elif ARCH_X86
+#   include &quot;x86/intreadwrite.h&quot;
 #endif
 
 /*
@@ -157,22 +179,22 @@
 
 #if   HAVE_ATTRIBUTE_PACKED
 
-struct unaligned_64 { uint64_t l; } __attribute__((packed));
-struct unaligned_32 { uint32_t l; } __attribute__((packed));
-struct unaligned_16 { uint16_t l; } __attribute__((packed));
+union unaligned_64 { uint64_t l; } __attribute__((packed)) av_alias;
+union unaligned_32 { uint32_t l; } __attribute__((packed)) av_alias;
+union unaligned_16 { uint16_t l; } __attribute__((packed)) av_alias;
 
-#   define AV_RN(s, p) (((const struct unaligned_##s *) (p))-&gt;l)
-#   define AV_WN(s, p, v) (((struct unaligned_##s *) (p))-&gt;l) = (v)
+#   define AV_RN(s, p) (((const union unaligned_##s *) (p))-&gt;l)
+#   define AV_WN(s, p, v) ((((union unaligned_##s *) (p))-&gt;l) = (v))
 
 #elif defined(__DECC)
 
 #   define AV_RN(s, p) (*((const __unaligned uint##s##_t*)(p)))
-#   define AV_WN(s, p, v) *((__unaligned uint##s##_t*)(p)) = (v)
+#   define AV_WN(s, p, v) (*((__unaligned uint##s##_t*)(p)) = (v))
 
 #elif HAVE_FAST_UNALIGNED
 
-#   define AV_RN(s, p) (*((const uint##s##_t*)(p)))
-#   define AV_WN(s, p, v) *((uint##s##_t*)(p)) = (v)
+#   define AV_RN(s, p) (((const av_alias##s*)(p))-&gt;u##s)
+#   define AV_WN(s, p, v) (((av_alias##s*)(p))-&gt;u##s = (v))
 
 #else
 
@@ -402,4 +424,93 @@
     } while(0)
 #endif
 
+/*
+ * The AV_[RW]NA macros access naturally aligned data
+ * in a type-safe way.
+ */
+
+#define AV_RNA(s, p)    (((const av_alias##s*)(p))-&gt;u##s)
+#define AV_WNA(s, p, v) (((av_alias##s*)(p))-&gt;u##s = (v))
+
+#ifndef AV_RN16A
+#   define AV_RN16A(p) AV_RNA(16, p)
+#endif
+
+#ifndef AV_RN32A
+#   define AV_RN32A(p) AV_RNA(32, p)
+#endif
+
+#ifndef AV_RN64A
+#   define AV_RN64A(p) AV_RNA(64, p)
+#endif
+
+#ifndef AV_WN16A
+#   define AV_WN16A(p, v) AV_WNA(16, p, v)
+#endif
+
+#ifndef AV_WN32A
+#   define AV_WN32A(p, v) AV_WNA(32, p, v)
+#endif
+
+#ifndef AV_WN64A
+#   define AV_WN64A(p, v) AV_WNA(64, p, v)
+#endif
+
+/* Parameters for AV_COPY*, AV_SWAP*, AV_ZERO* must be
+ * naturally aligned. They may be implemented using MMX,
+ * so emms_c() must be called before using any float code
+ * afterwards.
+ */
+
+#define AV_COPY(n, d, s) \
+    (((av_alias##n*)(d))-&gt;u##n = ((const av_alias##n*)(s))-&gt;u##n)
+
+#ifndef AV_COPY16
+#   define AV_COPY16(d, s) AV_COPY(16, d, s)
+#endif
+
+#ifndef AV_COPY32
+#   define AV_COPY32(d, s) AV_COPY(32, d, s)
+#endif
+
+#ifndef AV_COPY64
+#   define AV_COPY64(d, s) AV_COPY(64, d, s)
+#endif
+
+#ifndef AV_COPY128
+#   define AV_COPY128(d, s)                    \
+    do {                                       \
+        AV_COPY64(d, s);                       \
+        AV_COPY64((char*)(d)+8, (char*)(s)+8); \
+    } while(0)
+#endif
+
+#define AV_SWAP(n, a, b) FFSWAP(av_alias##n, *(av_alias##n*)(a), *(av_alias##n*)(b))
+
+#ifndef AV_SWAP64
+#   define AV_SWAP64(a, b) AV_SWAP(64, a, b)
+#endif
+
+#define AV_ZERO(n, d) (((av_alias##n*)(d))-&gt;u##n = 0)
+
+#ifndef AV_ZERO16
+#   define AV_ZERO16(d) AV_ZERO(16, d)
+#endif
+
+#ifndef AV_ZERO32
+#   define AV_ZERO32(d) AV_ZERO(32, d)
+#endif
+
+#ifndef AV_ZERO64
+#   define AV_ZERO64(d) AV_ZERO(64, d)
+#endif
+
+#ifndef AV_ZERO128
+#   define AV_ZERO128(d)         \
+    do {                         \
+        AV_ZERO64(d);            \
+        AV_ZERO64((char*)(d)+8); \
+    } while(0)
+#endif
+
 #endif /* AVUTIL_INTREADWRITE_H */

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/lfg.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/lfg.c	2010-05-26 05:26:02 UTC (rev 6231)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/lfg.c	2010-05-26 05:26:23 UTC (rev 6232)
@@ -23,7 +23,8 @@
 #include &quot;lfg.h&quot;
 #include &quot;md5.h&quot;
 #include &quot;intreadwrite.h&quot;
-#undef index //MEANS
+#include &quot;attributes.h&quot;
+
 void av_cold av_lfg_init(AVLFG *c, unsigned int seed){
     uint8_t tmp[16]={0};
     int i;
@@ -39,9 +40,24 @@
     c-&gt;index=0;
 }
 
+void av_bmg_get(AVLFG *lfg, double out[2])
+{
+    double x1, x2, w;
+
+    do {
+        x1 = 2.0/UINT_MAX*av_lfg_get(lfg) - 1.0;
+        x2 = 2.0/UINT_MAX*av_lfg_get(lfg) - 1.0;
+        w = x1*x1 + x2*x2;
+    } while (w &gt;= 1.0);
+
+    w = sqrt((-2.0 * log(w)) / w);
+    out[0] = x1 * w;
+    out[1] = x2 * w;
+}
+
 #ifdef TEST
 #include &quot;log.h&quot;
-#include &quot;common.h&quot;
+#include &quot;timer.h&quot;
 
 int main(void)
 {
@@ -59,6 +75,24 @@
         STOP_TIMER(&quot;624 calls of av_lfg_get&quot;);
     }
     av_log(NULL, AV_LOG_ERROR, &quot;final value:%X\n&quot;, x);
+
+    /* BMG usage example */
+    {
+        double mean   = 1000;
+        double stddev = 53;
+
+        av_lfg_init(&amp;state, 42);
+
+        for (i = 0; i &lt; 1000; i += 2) {
+            double bmg_out[2];
+            av_bmg_get(&amp;state, bmg_out);
+            av_log(NULL, AV_LOG_INFO,
+                   &quot;%f\n%f\n&quot;,
+                   bmg_out[0] * stddev + mean,
+                   bmg_out[1] * stddev + mean);
+        }
+    }
+
     return 0;
 }
 #endif

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/lfg.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/lfg.h	2010-05-26 05:26:02 UTC (rev 6231)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/lfg.h	2010-05-26 05:26:23 UTC (rev 6232)
@@ -51,4 +51,12 @@
     return c-&gt;state[c-&gt;index++ &amp; 63] = 2*a*b+a+b;
 }
 
+/**
+ * Gets the next two numbers generated by a Box-Muller Gaussian
+ * generator using the random numbers issued by lfg.
+ *
+ * @param out[2] array where are placed the two generated numbers
+ */
+void av_bmg_get(AVLFG *lfg, double out[2]);
+
 #endif /* AVUTIL_LFG_H */

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/libm.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/libm.h	2010-05-26 05:26:02 UTC (rev 6231)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/libm.h	2010-05-26 05:26:23 UTC (rev 6232)
@@ -0,0 +1,96 @@
+/*
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+/**
+ * @file
+ * Replacements for frequently missing libm functions
+ */
+
+#ifndef AVUTIL_LIBM_H
+#define AVUTIL_LIBM_H
+
+#include &lt;math.h&gt;
+#include &quot;config.h&quot;
+#include &quot;attributes.h&quot;
+
+#if !HAVE_EXP2
+#undef exp2
+#define exp2(x) exp((x) * 0.693147180559945)
+#endif /* HAVE_EXP2 */
+
+#if !HAVE_EXP2F
+#undef exp2f
+#define exp2f(x) ((float)exp2(x))
+#endif /* HAVE_EXP2F */
+
+#if !HAVE_LLRINT
+#undef llrint
+#define llrint(x) ((long long)rint(x))
+#endif /* HAVE_LLRINT */
+
+#if !HAVE_LLRINTF
+#undef llrintf
+#define llrintf(x) ((long long)rint(x))
+#endif /* HAVE_LLRINT */
+
+#if !HAVE_LOG2
+#undef log2
+#define log2(x) (log(x) * 1.44269504088896340736)
+#endif /* HAVE_LOG2 */
+
+#if !HAVE_LOG2F
+#undef log2f
+#define log2f(x) ((float)log2(x))
+#endif /* HAVE_LOG2F */
+
+#if !HAVE_LRINT
+static av_always_inline av_const long int lrint(double x)
+{
+    return rint(x);
+}
+#endif /* HAVE_LRINT */
+
+#if !HAVE_LRINTF
+static av_always_inline av_const long int lrintf(float x)
+{
+    return (int)(rint(x));
+}
+#endif /* HAVE_LRINTF */
+
+#if !HAVE_ROUND
+static av_always_inline av_const double round(double x)
+{
+    return (x &gt; 0) ? floor(x + 0.5) : ceil(x - 0.5);
+}
+#endif /* HAVE_ROUND */
+
+#if !HAVE_ROUNDF
+static av_always_inline av_const float roundf(float x)
+{
+    return (x &gt; 0) ? floor(x + 0.5) : ceil(x - 0.5);
+}
+#endif /* HAVE_ROUNDF */
+
+#if !HAVE_TRUNCF
+static av_always_inline av_const float truncf(float x)
+{
+    return (x &gt; 0) ? floor(x) : ceil(x);
+}
+#endif /* HAVE_TRUNCF */
+
+#endif /* AVUTIL_LIBM_H */

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/lls.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/lls.c	2010-05-26 05:26:02 UTC (rev 6231)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/lls.c	2010-05-26 05:26:23 UTC (rev 6232)
@@ -21,7 +21,7 @@
  */
 
 /**
- * @file libavutil/lls.c
+ * @file
  * linear least squares model
  */
 

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/log.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/log.c	2010-05-26 05:26:02 UTC (rev 6231)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/log.c	2010-05-26 05:26:23 UTC (rev 6232)
@@ -20,28 +20,65 @@
  */
 
 /**
- * @file libavutil/log.c
+ * @file
  * logging functions
  */
 
+#include &lt;unistd.h&gt;
+#include &lt;stdlib.h&gt;
 #include &quot;avutil.h&quot;
 #include &quot;log.h&quot;
 
+#if LIBAVUTIL_VERSION_MAJOR &gt; 50
+static
+#endif
 int av_log_level = AV_LOG_INFO;
 
+static int use_ansi_color=-1;
+
+#undef fprintf
+static void colored_fputs(int color, const char *str){
+    if(use_ansi_color&lt;0){
+#if HAVE_ISATTY &amp;&amp; !defined(_WIN32)
+        use_ansi_color= getenv(&quot;TERM&quot;) &amp;&amp; !getenv(&quot;NO_COLOR&quot;) &amp;&amp; isatty(2);
+#else
+        use_ansi_color= 0;
+#endif
+    }
+
+    if(use_ansi_color){
+        fprintf(stderr, &quot;\033[%d;3%dm&quot;, color&gt;&gt;4, color&amp;15);
+    }
+    fputs(str, stderr);
+    if(use_ansi_color){
+        fprintf(stderr, &quot;\033[0m&quot;);
+    }
+}
+
+const char* av_default_item_name(void* ptr){
+    return (*(AVClass**)ptr)-&gt;class_name;
+}
+
 void av_log_default_callback(void* ptr, int level, const char* fmt, va_list vl)
 {
     static int print_prefix=1;
     static int count;
     static char line[1024], prev[1024];
+    static const uint8_t color[]={0x41,0x41,0x11,0x03,9,9,9};
     AVClass* avc= ptr ? *(AVClass**)ptr : NULL;
     if(level&gt;av_log_level)
         return;
+    line[0]=0;
 #undef fprintf
     if(print_prefix &amp;&amp; avc) {
-        snprintf(line, sizeof(line), &quot;[%s @ %p]&quot;, avc-&gt;item_name(ptr), ptr);
-    }else
-        line[0]=0;
+        if(avc-&gt;version &gt;= (50&lt;&lt;16 | 15&lt;&lt;8 | 3) &amp;&amp; avc-&gt;parent_log_context_offset){
+            AVClass** parent= *(AVClass***)(((uint8_t*)ptr) + avc-&gt;parent_log_context_offset);
+            if(parent &amp;&amp; *parent){
+                snprintf(line, sizeof(line), &quot;[%s @ %p]&quot;, (*parent)-&gt;item_name(parent), parent);
+            }
+        }
+        snprintf(line + strlen(line), sizeof(line) - strlen(line), &quot;[%s @ %p]&quot;, avc-&gt;item_name(ptr), ptr);
+    }
 
     vsnprintf(line + strlen(line), sizeof(line) - strlen(line), fmt, vl);
 
@@ -54,7 +91,7 @@
         fprintf(stderr, &quot;    Last message repeated %d times\n&quot;, count);
         count=0;
     }
-    fputs(line, stderr);
+    colored_fputs(color[av_clip(level&gt;&gt;3, 0, 6)], line);
     strcpy(prev, line);
 }
 
@@ -62,8 +99,11 @@
 
 void av_log(void* avcl, int level, const char *fmt, ...)
 {
+    AVClass* avc= avcl ? *(AVClass**)avcl : NULL;
     va_list vl;
     va_start(vl, fmt);
+    if(avc &amp;&amp; avc-&gt;version &gt;= (50&lt;&lt;16 | 15&lt;&lt;8 | 2) &amp;&amp; avc-&gt;log_level_offset_offset &amp;&amp; level&gt;=AV_LOG_FATAL)
+        level += *(int*)(((uint8_t*)avcl) + avc-&gt;log_level_offset_offset);
     av_vlog(avcl, level, fmt, vl);
     va_end(vl);
 }

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/log.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/log.h	2010-05-26 05:26:02 UTC (rev 6231)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/log.h	2010-05-26 05:26:23 UTC (rev 6232)
@@ -48,6 +48,28 @@
      * @see av_set_default_options()
      */
     const struct AVOption *option;
+
+    /**
+     * LIBAVUTIL_VERSION with which this structure was created.
+     * This is used to allow fields to be added without requiring major
+     * version bumps everywhere.
+     */
+
+    int version;
+
+    /**
+     * Offset in the structure where log_level_offset is stored.
+     * 0 means there is no such variable
+     */
+    int log_level_offset_offset;
+
+    /**
+     * Offset in the structure where a pointer to the parent context for loging is stored.
+     * for example a decoder that uses eval.c could pass its AVCodecContext to eval as such
+     * parent context. And a av_log() implementation could then display the parent context
+     * can be NULL of course
+     */
+    int parent_log_context_offset;
 } AVClass;
 
 /* av_log API */
@@ -111,5 +133,6 @@
 void av_log_set_level(int);
 void av_log_set_callback(void (*)(void*, int, const char*, va_list));
 void av_log_default_callback(void* ptr, int level, const char* fmt, va_list vl);
+const char* av_default_item_name(void* ctx);
 
 #endif /* AVUTIL_LOG_H */

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/mathematics.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/mathematics.c	2010-05-26 05:26:02 UTC (rev 6231)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/mathematics.c	2010-05-26 05:26:23 UTC (rev 6232)
@@ -19,13 +19,13 @@
  */
 
 /**
- * @file libavutil/mathematics.c
+ * @file
  * miscellaneous math routines and tables
  */
 
 #include &lt;assert.h&gt;
-#include &quot;avutil.h&quot;
-#include &quot;common.h&quot;
+#include &lt;stdint.h&gt;
+#include &lt;limits.h&gt;
 #include &quot;mathematics.h&quot;
 
 const uint8_t ff_sqrt_tab[256]={
@@ -50,6 +50,25 @@
         7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7
 };
 
+const uint8_t av_reverse[256]={
+0x00,0x80,0x40,0xC0,0x20,0xA0,0x60,0xE0,0x10,0x90,0x50,0xD0,0x30,0xB0,0x70,0xF0,
+0x08,0x88,0x48,0xC8,0x28,0xA8,0x68,0xE8,0x18,0x98,0x58,0xD8,0x38,0xB8,0x78,0xF8,
+0x04,0x84,0x44,0xC4,0x24,0xA4,0x64,0xE4,0x14,0x94,0x54,0xD4,0x34,0xB4,0x74,0xF4,
+0x0C,0x8C,0x4C,0xCC,0x2C,0xAC,0x6C,0xEC,0x1C,0x9C,0x5C,0xDC,0x3C,0xBC,0x7C,0xFC,
+0x02,0x82,0x42,0xC2,0x22,0xA2,0x62,0xE2,0x12,0x92,0x52,0xD2,0x32,0xB2,0x72,0xF2,
+0x0A,0x8A,0x4A,0xCA,0x2A,0xAA,0x6A,0xEA,0x1A,0x9A,0x5A,0xDA,0x3A,0xBA,0x7A,0xFA,
+0x06,0x86,0x46,0xC6,0x26,0xA6,0x66,0xE6,0x16,0x96,0x56,0xD6,0x36,0xB6,0x76,0xF6,
+0x0E,0x8E,0x4E,0xCE,0x2E,0xAE,0x6E,0xEE,0x1E,0x9E,0x5E,0xDE,0x3E,0xBE,0x7E,0xFE,
+0x01,0x81,0x41,0xC1,0x21,0xA1,0x61,0xE1,0x11,0x91,0x51,0xD1,0x31,0xB1,0x71,0xF1,
+0x09,0x89,0x49,0xC9,0x29,0xA9,0x69,0xE9,0x19,0x99,0x59,0xD9,0x39,0xB9,0x79,0xF9,
+0x05,0x85,0x45,0xC5,0x25,0xA5,0x65,0xE5,0x15,0x95,0x55,0xD5,0x35,0xB5,0x75,0xF5,
+0x0D,0x8D,0x4D,0xCD,0x2D,0xAD,0x6D,0xED,0x1D,0x9D,0x5D,0xDD,0x3D,0xBD,0x7D,0xFD,
+0x03,0x83,0x43,0xC3,0x23,0xA3,0x63,0xE3,0x13,0x93,0x53,0xD3,0x33,0xB3,0x73,0xF3,
+0x0B,0x8B,0x4B,0xCB,0x2B,0xAB,0x6B,0xEB,0x1B,0x9B,0x5B,0xDB,0x3B,0xBB,0x7B,0xFB,
+0x07,0x87,0x47,0xC7,0x27,0xA7,0x67,0xE7,0x17,0x97,0x57,0xD7,0x37,0xB7,0x77,0xF7,
+0x0F,0x8F,0x4F,0xCF,0x2F,0xAF,0x6F,0xEF,0x1F,0x9F,0x5F,0xDF,0x3F,0xBF,0x7F,0xFF,
+};
+
 int64_t av_gcd(int64_t a, int64_t b){
     if(b) return av_gcd(b, a%b);
     else  return a;
@@ -117,6 +136,14 @@
     return av_rescale_rnd(a, b, c, AV_ROUND_NEAR_INF);
 }
 
+int av_compare_ts(int64_t ts_a, AVRational tb_a, int64_t ts_b, AVRational tb_b){
+    int64_t a= tb_a.num * (int64_t)tb_b.den;
+    int64_t b= tb_b.num * (int64_t)tb_a.den;
+    if (av_rescale_rnd(ts_a, a, b, AV_ROUND_DOWN) &lt; ts_b) return -1;
+    if (av_rescale_rnd(ts_b, b, a, AV_ROUND_DOWN) &lt; ts_a) return  1;
+    return 0;
+}
+
 #ifdef TEST
 #include &quot;integer.h&quot;
 #undef printf

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/mathematics.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/mathematics.h	2010-05-26 05:26:02 UTC (rev 6231)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/mathematics.h	2010-05-26 05:26:23 UTC (rev 6232)
@@ -23,7 +23,7 @@
 
 #include &lt;stdint.h&gt;
 #include &lt;math.h&gt;
-#include &quot;common.h&quot;
+#include &quot;attributes.h&quot;
 #include &quot;rational.h&quot;
 
 #ifndef M_E
@@ -35,12 +35,18 @@
 #ifndef M_LN10
 #define M_LN10         2.30258509299404568402  /* log_e 10 */
 #endif
+#ifndef M_LOG2_10
+#define M_LOG2_10      3.32192809488736234787  /* log_2 10 */
+#endif
 #ifndef M_PI
 #define M_PI           3.14159265358979323846  /* pi */
 #endif
 #ifndef M_SQRT1_2
 #define M_SQRT1_2      0.70710678118654752440  /* 1/sqrt(2) */
 #endif
+#ifndef M_SQRT2
+#define M_SQRT2        1.41421356237309504880  /* sqrt(2) */
+#endif
 #ifndef NAN
 #define NAN            (0.0/0.0)
 #endif
@@ -56,6 +62,11 @@
     AV_ROUND_NEAR_INF = 5, ///&lt; Round to nearest and halfway cases away from zero.
 };
 
+/**
+ * Returns the greatest common divisor of a and b.
+ * If both a and b are 0 or either or both are &lt;0 then behavior is
+ * undefined.
+ */
 int64_t av_const av_gcd(int64_t a, int64_t b);
 
 /**
@@ -75,4 +86,13 @@
  */
 int64_t av_rescale_q(int64_t a, AVRational bq, AVRational cq) av_const;
 
+/**
+ * Compares 2 timestamps each in its own timebases.
+ * The result of the function is undefined if one of the timestamps
+ * is outside the int64_t range when represented in the others timebase.
+ * @return -1 if ts_a is before ts_b, 1 if ts_a is after ts_b or 0 if they represent the same position
+ */
+int av_compare_ts(int64_t ts_a, AVRational tb_a, int64_t ts_b, AVRational tb_b);
+
+
 #endif /* AVUTIL_MATHEMATICS_H */

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/md5.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/md5.c	2010-05-26 05:26:02 UTC (rev 6231)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/md5.c	2010-05-26 05:26:23 UTC (rev 6232)
@@ -163,6 +163,7 @@
 
 #ifdef TEST
 #include &lt;stdio.h&gt;
+#include &lt;inttypes.h&gt;
 #undef printf
 int main(void){
     uint64_t md5val;

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/mem.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/mem.c	2010-05-26 05:26:02 UTC (rev 6231)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/mem.c	2010-05-26 05:26:23 UTC (rev 6232)
@@ -20,7 +20,7 @@
  */
 
 /**
- * @file libavutil/mem.c
+ * @file
  * default memory allocator for libavutil
  */
 
@@ -29,10 +29,11 @@
 #include &lt;limits.h&gt;
 #include &lt;stdlib.h&gt;
 #include &lt;string.h&gt;
-#ifdef HAVE_MALLOC_H
+#if HAVE_MALLOC_H
 #include &lt;malloc.h&gt;
 #endif
 
+#include &quot;avutil.h&quot;
 #include &quot;mem.h&quot;
 
 /* here we can use OS-dependent allocation functions */
@@ -40,116 +41,109 @@
 #undef malloc
 #undef realloc
 
+#ifdef MALLOC_PREFIX
+
+#define malloc         AV_JOIN(MALLOC_PREFIX, malloc)
+#define memalign       AV_JOIN(MALLOC_PREFIX, memalign)
+#define posix_memalign AV_JOIN(MALLOC_PREFIX, posix_memalign)
+#define realloc        AV_JOIN(MALLOC_PREFIX, realloc)
+#define free           AV_JOIN(MALLOC_PREFIX, free)
+
+void *malloc(size_t size);
+void *memalign(size_t align, size_t size);
+int   posix_memalign(void **ptr, size_t align, size_t size);
+void *realloc(void *ptr, size_t size);
+void  free(void *ptr);
+
+#endif /* MALLOC_PREFIX */
+
 /* You can redefine av_malloc and av_free in your project to use your
    memory allocator. You do not need to suppress this file because the
    linker will do it automatically. */
 
 void *av_malloc(unsigned int size)
 {
-#ifdef __APPLE__
-	return malloc(size);
-#else
-	char *c;
+    void *ptr = NULL;
+#if CONFIG_MEMALIGN_HACK
+    long diff;
+#endif
 
-	uint64_t l, lorg;
-	uint32_t *backdoor;
+    /* let's disallow possible ambiguous cases */
+    if(size &gt; (INT_MAX-16) )
+        return NULL;
 
-	l = (uint64_t)malloc(size + 32);
+#if CONFIG_MEMALIGN_HACK
+    ptr = malloc(size+16);
+    if(!ptr)
+        return ptr;
+    diff= ((-(long)ptr - 1)&amp;15) + 1;
+    ptr = (char*)ptr + diff;
+    ((char*)ptr)[-1]= diff;
+#elif HAVE_POSIX_MEMALIGN
+    if (posix_memalign(&amp;ptr,16,size))
+        ptr = NULL;
+#elif HAVE_MEMALIGN
+    ptr = memalign(16,size);
+    /* Why 64?
+       Indeed, we should align it:
+         on 4 for 386
+         on 16 for 486
+         on 32 for 586, PPro - K6-III
+         on 64 for K7 (maybe for P3 too).
+       Because L1 and L2 caches are aligned on those values.
+       But I don't want to code such logic here!
+     */
+     /* Why 16?
+        Because some CPUs need alignment, for example SSE2 on P4, &amp; most RISC CPUs
+        it will just trigger an exception and the unaligned load will be done in the
+        exception handler or it will just segfault (SSE2 on P4).
+        Why not larger? Because I did not see a difference in benchmarks ...
+     */
+     /* benchmarks with P3
+        memalign(64)+1          3071,3051,3032
+        memalign(64)+2          3051,3032,3041
+        memalign(64)+4          2911,2896,2915
+        memalign(64)+8          2545,2554,2550
+        memalign(64)+16         2543,2572,2563
+        memalign(64)+32         2546,2545,2571
+        memalign(64)+64         2570,2533,2558
 
-	// Get next boundary
-	lorg = l;
-	l = (l + 15) &amp; 0xfffffffffffffff0LL;
-	l += 16;
-	c = (char*)l;
-	backdoor = (uint32_t*)(c - 8);
-	*backdoor = (0xdead &lt;&lt; 16) + l - lorg;
-	backdoor[1] = size;
-
-	return c;
+        BTW, malloc seems to do 8-byte alignment by default here.
+     */
+#else
+    ptr = malloc(size);
 #endif
+    return ptr;
 }
 
-void *av_realloc(void *ptr, unsigned int newsize)
+void *av_realloc(void *ptr, unsigned int size)
 {
-#ifdef __APPLE__
-	if (!ptr)
-		return av_malloc(newsize);
+#if CONFIG_MEMALIGN_HACK
+    int diff;
+#endif
 
-	if (!newsize)
-	{
-		av_free(ptr);
-		return NULL;
-	}
+    /* let's disallow possible ambiguous cases */
+    if(size &gt; (INT_MAX-16) )
+        return NULL;
 
-	return realloc(ptr, newsize);
+#if CONFIG_MEMALIGN_HACK
+    //FIXME this isn't aligned correctly, though it probably isn't needed
+    if(!ptr) return av_malloc(size);
+    diff= ((char*)ptr)[-1];
+    return (char*)realloc((char*)ptr - diff, size + diff) + diff;
 #else
-	void *nalloc;
-
-	if (!ptr)
-		return av_malloc(newsize);
-
-	if (!newsize) 
-	{
-		av_free(ptr);
-		return NULL;
-	}
-
-	// now we either shrink them or expand them
-	// in case of shrink, we do nothing
-	// in case of expand we have to copy
-	// Do copy everytime (slower)
-	uint32_t *backdoor;
-	uint32_t size, offset;
-	char *c = (char*)ptr;
-
-	backdoor = (uint32_t*)ptr;
-	backdoor -= 2;
-
-	assert(((*backdoor) &gt;&gt; 16) == 0xdead);
-
-	offset = backdoor[0] &amp; 0xffff;
-	size = backdoor[1];
-
-	if(size &gt;= newsize) // do nothing
-		return ptr;
-
-	// Allocate a new one
-	nalloc = av_malloc(newsize);
-	memcpy(nalloc, ptr, size);
-	av_free(ptr);
-
-	return nalloc;
+    return realloc(ptr, size);
 #endif
 }
 
 void av_free(void *ptr)
 {
-#ifdef __APPLE__
-	if (!ptr)
-		return;
-
-	free(ptr);
+    /* XXX: this test should not be needed on most libcs */
+    if (ptr)
+#if CONFIG_MEMALIGN_HACK
+        free((char*)ptr - ((char*)ptr)[-1]);
 #else
-	uint32_t *backdoor;
-	uint32_t size, offset;
-	char *c = (char*)ptr;
-
-	if (!ptr)
-		return;
-
-	backdoor = (uint32_t*)ptr;
-	backdoor -= 2;
-
-	if (*backdoor == 0xbeefbeef)
-		assert(0);
-
-	assert(((*backdoor) &gt;&gt; 16) == 0xdead);
-
-	offset = backdoor[0] &amp; 0xffff;
-	size = backdoor[1];
-	*backdoor = 0xbeefbeef; // Scratch sig
-
-	free(c - offset);
+        free(ptr);
 #endif
 }
 

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/mem.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/mem.h	2010-05-26 05:26:02 UTC (rev 6231)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/mem.h	2010-05-26 05:26:23 UTC (rev 6232)
@@ -19,21 +19,28 @@
  */
 
 /**
- * @file libavutil/mem.h
+ * @file
  * memory handling functions
  */
 
 #ifndef AVUTIL_MEM_H
 #define AVUTIL_MEM_H
 
-#include &quot;common.h&quot;
+#include &quot;attributes.h&quot;
 
 #if defined(__ICC) || defined(__SUNPRO_C)
-    #define DECLARE_ALIGNED(n,t,v)      t v __attribute__ ((aligned (n)))
+    #define DECLARE_ALIGNED(n,t,v)      t __attribute__ ((aligned (n))) v
     #define DECLARE_ASM_CONST(n,t,v)    const t __attribute__ ((aligned (n))) v
+#elif defined(__TI_COMPILER_VERSION__)
+    #define DECLARE_ALIGNED(n,t,v)                      \
+        AV_PRAGMA(DATA_ALIGN(v,n))                      \
+        t __attribute__((aligned(n))) v
+    #define DECLARE_ASM_CONST(n,t,v)                    \
+        AV_PRAGMA(DATA_ALIGN(v,n))                      \
+        static const t __attribute__((aligned(n))) v
 #elif defined(__GNUC__)
-    #define DECLARE_ALIGNED(n,t,v)      t v __attribute__ ((aligned (n)))
-    #define DECLARE_ASM_CONST(n,t,v)    static const t v attribute_used __attribute__ ((aligned (n)))
+    #define DECLARE_ALIGNED(n,t,v)      t __attribute__ ((aligned (n))) v
+    #define DECLARE_ASM_CONST(n,t,v)    static const t attribute_used __attribute__ ((aligned (n))) v
 #elif defined(_MSC_VER)
     #define DECLARE_ALIGNED(n,t,v)      __declspec(align(n)) t v
     #define DECLARE_ASM_CONST(n,t,v)    __declspec(align(n)) static const t v
@@ -42,7 +49,6 @@
     #define DECLARE_ASM_CONST(n,t,v)    static const t v
 #endif
 
-
 #if AV_GCC_VERSION_AT_LEAST(3,1)
     #define av_malloc_attrib __attribute__((__malloc__))
 #else
@@ -67,7 +73,7 @@
 
 /**
  * Allocates or reallocates a block of memory.
- * If ptr is NULL and size &gt; 0, allocates a new block. If \p
+ * If ptr is NULL and size &gt; 0, allocates a new block. If
  * size is zero, frees the memory block pointed to by ptr.
  * @param size Size in bytes for the memory block to be allocated or
  * reallocated.

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/pca.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/pca.c	2010-05-26 05:26:02 UTC (rev 6231)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/pca.c	2010-05-26 05:26:23 UTC (rev 6232)
@@ -20,7 +20,7 @@
  */
 
 /**
- * @file libavutil/pca.c
+ * @file
  * principal component analysis (PCA)
  */
 

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/pca.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/pca.h	2010-05-26 05:26:02 UTC (rev 6231)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/pca.h	2010-05-26 05:26:23 UTC (rev 6232)
@@ -20,7 +20,7 @@
  */
 
 /**
- * @file libavutil/pca.h
+ * @file
  * principal component analysis (PCA)
  */
 

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/pixdesc.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/pixdesc.c	2010-05-26 05:26:02 UTC (rev 6231)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/pixdesc.c	2010-05-26 05:26:23 UTC (rev 6232)
@@ -0,0 +1,840 @@
+/*
+ * pixel format descriptor
+ * Copyright (c) 2009 Michael Niedermayer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">michaelni at gmx.at</A>&gt;
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include &quot;pixfmt.h&quot;
+#include &quot;pixdesc.h&quot;
+
+#include &quot;intreadwrite.h&quot;
+
+void read_line(uint16_t *dst, const uint8_t *data[4], const int linesize[4],
+               const AVPixFmtDescriptor *desc, int x, int y, int c, int w, int read_pal_component)
+{
+    AVComponentDescriptor comp= desc-&gt;comp[c];
+    int plane= comp.plane;
+    int depth= comp.depth_minus1+1;
+    int mask = (1&lt;&lt;depth)-1;
+    int shift= comp.shift;
+    int step = comp.step_minus1+1;
+    int flags= desc-&gt;flags;
+
+    if (flags &amp; PIX_FMT_BITSTREAM){
+        int skip = x*step + comp.offset_plus1-1;
+        const uint8_t *p = data[plane] + y*linesize[plane] + (skip&gt;&gt;3);
+        int shift = 8 - depth - (skip&amp;7);
+
+        while(w--){
+            int val = (*p &gt;&gt; shift) &amp; mask;
+            if(read_pal_component)
+                val= data[1][4*val + c];
+            shift -= step;
+            p -= shift&gt;&gt;3;
+            shift &amp;= 7;
+            *dst++= val;
+        }
+    } else {
+        const uint8_t *p = data[plane]+ y*linesize[plane] + x*step + comp.offset_plus1-1;
+
+        while(w--){
+            int val;
+            if(flags &amp; PIX_FMT_BE) val= AV_RB16(p);
+            else                   val= AV_RL16(p);
+            val = (val&gt;&gt;shift) &amp; mask;
+            if(read_pal_component)
+                val= data[1][4*val + c];
+            p+= step;
+            *dst++= val;
+        }
+    }
+}
+
+void write_line(const uint16_t *src, uint8_t *data[4], const int linesize[4],
+                const AVPixFmtDescriptor *desc, int x, int y, int c, int w)
+{
+    AVComponentDescriptor comp = desc-&gt;comp[c];
+    int plane = comp.plane;
+    int depth = comp.depth_minus1+1;
+    int step  = comp.step_minus1+1;
+    int flags = desc-&gt;flags;
+
+    if (flags &amp; PIX_FMT_BITSTREAM) {
+        int skip = x*step + comp.offset_plus1-1;
+        uint8_t *p = data[plane] + y*linesize[plane] + (skip&gt;&gt;3);
+        int shift = 8 - depth - (skip&amp;7);
+
+        while (w--) {
+            *p |= *src++ &lt;&lt; shift;
+            shift -= step;
+            p -= shift&gt;&gt;3;
+            shift &amp;= 7;
+        }
+    } else {
+        int shift = comp.shift;
+        uint8_t *p = data[plane]+ y*linesize[plane] + x*step + comp.offset_plus1-1;
+
+        while (w--) {
+            if (flags &amp; PIX_FMT_BE) {
+                uint16_t val = AV_RB16(p) | (*src++&lt;&lt;shift);
+                AV_WB16(p, val);
+            } else {
+                uint16_t val = AV_RL16(p) | (*src++&lt;&lt;shift);
+                AV_WL16(p, val);
+            }
+            p+= step;
+        }
+    }
+}
+
+const AVPixFmtDescriptor av_pix_fmt_descriptors[PIX_FMT_NB] = {
+    [PIX_FMT_YUV420P] = {
+        .name = &quot;yuv420p&quot;,
+        .nb_components= 3,
+        .log2_chroma_w= 1,
+        .log2_chroma_h= 1,
+        .comp = {
+            {0,0,1,0,7},        /* Y */
+            {1,0,1,0,7},        /* U */
+            {2,0,1,0,7},        /* V */
+        },
+    },
+    [PIX_FMT_YUYV422] = {
+        .name = &quot;yuyv422&quot;,
+        .nb_components= 3,
+        .log2_chroma_w= 1,
+        .log2_chroma_h= 0,
+        .comp = {
+            {0,1,1,0,7},        /* Y */
+            {0,3,2,0,7},        /* U */
+            {0,3,4,0,7},        /* V */
+        },
+    },
+    [PIX_FMT_RGB24] = {
+        .name = &quot;rgb24&quot;,
+        .nb_components= 3,
+        .log2_chroma_w= 0,
+        .log2_chroma_h= 0,
+        .comp = {
+            {0,2,1,0,7},        /* R */
+            {0,2,2,0,7},        /* G */
+            {0,2,3,0,7},        /* B */
+        },
+    },
+    [PIX_FMT_BGR24] = {
+        .name = &quot;bgr24&quot;,
+        .nb_components= 3,
+        .log2_chroma_w= 0,
+        .log2_chroma_h= 0,
+        .comp = {
+            {0,2,1,0,7},        /* B */
+            {0,2,2,0,7},        /* G */
+            {0,2,3,0,7},        /* R */
+        },
+    },
+    [PIX_FMT_YUV422P] = {
+        .name = &quot;yuv422p&quot;,
+        .nb_components= 3,
+        .log2_chroma_w= 1,
+        .log2_chroma_h= 0,
+        .comp = {
+            {0,0,1,0,7},        /* Y */
+            {1,0,1,0,7},        /* U */
+            {2,0,1,0,7},        /* V */
+        },
+    },
+    [PIX_FMT_YUV444P] = {
+        .name = &quot;yuv444p&quot;,
+        .nb_components= 3,
+        .log2_chroma_w= 0,
+        .log2_chroma_h= 0,
+        .comp = {
+            {0,0,1,0,7},        /* Y */
+            {1,0,1,0,7},        /* U */
+            {2,0,1,0,7},        /* V */
+        },
+    },
+    [PIX_FMT_YUV410P] = {
+        .name = &quot;yuv410p&quot;,
+        .nb_components= 3,
+        .log2_chroma_w= 2,
+        .log2_chroma_h= 2,
+        .comp = {
+            {0,0,1,0,7},        /* Y */
+            {1,0,1,0,7},        /* U */
+            {2,0,1,0,7},        /* V */
+        },
+    },
+    [PIX_FMT_YUV411P] = {
+        .name = &quot;yuv411p&quot;,
+        .nb_components= 3,
+        .log2_chroma_w= 2,
+        .log2_chroma_h= 0,
+        .comp = {
+            {0,0,1,0,7},        /* Y */
+            {1,0,1,0,7},        /* U */
+            {2,0,1,0,7},        /* V */
+        },
+    },
+    [PIX_FMT_GRAY8] = {
+        .name = &quot;gray&quot;,
+        .nb_components= 1,
+        .log2_chroma_w= 0,
+        .log2_chroma_h= 0,
+        .comp = {
+            {0,0,1,0,7},        /* Y */
+        },
+        .flags = PIX_FMT_PAL,
+    },
+    [PIX_FMT_MONOWHITE] = {
+        .name = &quot;monow&quot;,
+        .nb_components= 1,
+        .log2_chroma_w= 0,
+        .log2_chroma_h= 0,
+        .comp = {
+            {0,0,1,0,0},        /* Y */
+        },
+        .flags = PIX_FMT_BITSTREAM,
+    },
+    [PIX_FMT_MONOBLACK] = {
+        .name = &quot;monob&quot;,
+        .nb_components= 1,
+        .log2_chroma_w= 0,
+        .log2_chroma_h= 0,
+        .comp = {
+            {0,0,1,7,0},        /* Y */
+        },
+        .flags = PIX_FMT_BITSTREAM,
+    },
+    [PIX_FMT_PAL8] = {
+        .name = &quot;pal8&quot;,
+        .nb_components= 1,
+        .log2_chroma_w= 0,
+        .log2_chroma_h= 0,
+        .comp = {
+            {0,0,1,0,7},
+        },
+        .flags = PIX_FMT_PAL,
+    },
+    [PIX_FMT_YUVJ420P] = {
+        .name = &quot;yuvj420p&quot;,
+        .nb_components= 3,
+        .log2_chroma_w= 1,
+        .log2_chroma_h= 1,
+        .comp = {
+            {0,0,1,0,7},        /* Y */
+            {1,0,1,0,7},        /* U */
+            {2,0,1,0,7},        /* V */
+        },
+    },
+    [PIX_FMT_YUVJ422P] = {
+        .name = &quot;yuvj422p&quot;,
+        .nb_components= 3,
+        .log2_chroma_w= 1,
+        .log2_chroma_h= 0,
+        .comp = {
+            {0,0,1,0,7},        /* Y */
+            {1,0,1,0,7},        /* U */
+            {2,0,1,0,7},        /* V */
+        },
+    },
+    [PIX_FMT_YUVJ444P] = {
+        .name = &quot;yuvj444p&quot;,
+        .nb_components= 3,
+        .log2_chroma_w= 0,
+        .log2_chroma_h= 0,
+        .comp = {
+            {0,0,1,0,7},        /* Y */
+            {1,0,1,0,7},        /* U */
+            {2,0,1,0,7},        /* V */
+        },
+    },
+    [PIX_FMT_XVMC_MPEG2_MC] = {
+        .name = &quot;xvmcmc&quot;,
+        .flags = PIX_FMT_HWACCEL,
+    },
+    [PIX_FMT_XVMC_MPEG2_IDCT] = {
+        .name = &quot;xvmcidct&quot;,
+        .flags = PIX_FMT_HWACCEL,
+    },
+    [PIX_FMT_UYVY422] = {
+        .name = &quot;uyvy422&quot;,
+        .nb_components= 3,
+        .log2_chroma_w= 1,
+        .log2_chroma_h= 0,
+        .comp = {
+            {0,1,2,0,7},        /* Y */
+            {0,3,1,0,7},        /* U */
+            {0,3,3,0,7},        /* V */
+        },
+    },
+    [PIX_FMT_UYYVYY411] = {
+        .name = &quot;uyyvyy411&quot;,
+        .nb_components= 3,
+        .log2_chroma_w= 2,
+        .log2_chroma_h= 0,
+        .comp = {
+            {0,3,2,0,7},        /* Y */
+            {0,5,1,0,7},        /* U */
+            {0,5,4,0,7},        /* V */
+        },
+    },
+    [PIX_FMT_BGR8] = {
+        .name = &quot;bgr8&quot;,
+        .nb_components= 3,
+        .log2_chroma_w= 0,
+        .log2_chroma_h= 0,
+        .comp = {
+            {0,0,1,6,1},        /* B */
+            {0,0,1,3,2},        /* G */
+            {0,0,1,0,2},        /* R */
+        },
+        .flags = PIX_FMT_PAL,
+    },
+    [PIX_FMT_BGR4] = {
+        .name = &quot;bgr4&quot;,
+        .nb_components= 3,
+        .log2_chroma_w= 0,
+        .log2_chroma_h= 0,
+        .comp = {
+            {0,3,1,0,0},        /* B */
+            {0,3,2,0,1},        /* G */
+            {0,3,4,0,0},        /* R */
+        },
+        .flags = PIX_FMT_BITSTREAM,
+    },
+    [PIX_FMT_BGR4_BYTE] = {
+        .name = &quot;bgr4_byte&quot;,
+        .nb_components= 3,
+        .log2_chroma_w= 0,
+        .log2_chroma_h= 0,
+        .comp = {
+            {0,0,1,3,0},        /* B */
+            {0,0,1,1,1},        /* G */
+            {0,0,1,0,0},        /* R */
+        },
+        .flags = PIX_FMT_PAL,
+    },
+    [PIX_FMT_RGB8] = {
+        .name = &quot;rgb8&quot;,
+        .nb_components= 3,
+        .log2_chroma_w= 0,
+        .log2_chroma_h= 0,
+        .comp = {
+            {0,0,1,6,1},        /* R */
+            {0,0,1,3,2},        /* G */
+            {0,0,1,0,2},        /* B */
+        },
+        .flags = PIX_FMT_PAL,
+    },
+    [PIX_FMT_RGB4] = {
+        .name = &quot;rgb4&quot;,
+        .nb_components= 3,
+        .log2_chroma_w= 0,
+        .log2_chroma_h= 0,
+        .comp = {
+            {0,3,1,0,0},       /* R */
+            {0,3,2,0,1},       /* G */
+            {0,3,4,0,0},       /* B */
+        },
+        .flags = PIX_FMT_BITSTREAM,
+    },
+    [PIX_FMT_RGB4_BYTE] = {
+        .name = &quot;rgb4_byte&quot;,
+        .nb_components= 3,
+        .log2_chroma_w= 0,
+        .log2_chroma_h= 0,
+        .comp = {
+            {0,0,1,3,0},        /* R */
+            {0,0,1,1,1},        /* G */
+            {0,0,1,0,0},        /* B */
+        },
+        .flags = PIX_FMT_PAL,
+    },
+    [PIX_FMT_NV12] = {
+        .name = &quot;nv12&quot;,
+        .nb_components= 3,
+        .log2_chroma_w= 1,
+        .log2_chroma_h= 1,
+        .comp = {
+            {0,0,1,0,7},        /* Y */
+            {1,1,1,0,7},        /* U */
+            {1,1,2,0,7},        /* V */
+        },
+    },
+    [PIX_FMT_NV21] = {
+        .name = &quot;nv21&quot;,
+        .nb_components= 3,
+        .log2_chroma_w= 1,
+        .log2_chroma_h= 1,
+        .comp = {
+            {0,0,1,0,7},        /* Y */
+            {1,1,1,0,7},        /* V */
+            {1,1,2,0,7},        /* U */
+        },
+    },
+    [PIX_FMT_ARGB] = {
+        .name = &quot;argb&quot;,
+        .nb_components= 4,
+        .log2_chroma_w= 0,
+        .log2_chroma_h= 0,
+        .comp = {
+            {0,3,1,0,7},        /* A */
+            {0,3,2,0,7},        /* R */
+            {0,3,3,0,7},        /* G */
+            {0,3,4,0,7},        /* B */
+        },
+    },
+    [PIX_FMT_RGBA] = {
+        .name = &quot;rgba&quot;,
+        .nb_components= 4,
+        .log2_chroma_w= 0,
+        .log2_chroma_h= 0,
+        .comp = {
+            {0,3,1,0,7},        /* R */
+            {0,3,2,0,7},        /* G */
+            {0,3,3,0,7},        /* B */
+            {0,3,4,0,7},        /* A */
+        },
+    },
+    [PIX_FMT_ABGR] = {
+        .name = &quot;abgr&quot;,
+        .nb_components= 4,
+        .log2_chroma_w= 0,
+        .log2_chroma_h= 0,
+        .comp = {
+            {0,3,1,0,7},        /* A */
+            {0,3,2,0,7},        /* B */
+            {0,3,3,0,7},        /* G */
+            {0,3,4,0,7},        /* R */
+        },
+    },
+    [PIX_FMT_BGRA] = {
+        .name = &quot;bgra&quot;,
+        .nb_components= 4,
+        .log2_chroma_w= 0,
+        .log2_chroma_h= 0,
+        .comp = {
+            {0,3,1,0,7},        /* B */
+            {0,3,2,0,7},        /* G */
+            {0,3,3,0,7},        /* R */
+            {0,3,4,0,7},        /* A */
+        },
+    },
+    [PIX_FMT_GRAY16BE] = {
+        .name = &quot;gray16be&quot;,
+        .nb_components= 1,
+        .log2_chroma_w= 0,
+        .log2_chroma_h= 0,
+        .comp = {
+            {0,1,1,0,15},       /* Y */
+        },
+        .flags = PIX_FMT_BE,
+    },
+    [PIX_FMT_GRAY16LE] = {
+        .name = &quot;gray16le&quot;,
+        .nb_components= 1,
+        .log2_chroma_w= 0,
+        .log2_chroma_h= 0,
+        .comp = {
+            {0,1,1,0,15},       /* Y */
+        },
+    },
+    [PIX_FMT_YUV440P] = {
+        .name = &quot;yuv440p&quot;,
+        .nb_components= 3,
+        .log2_chroma_w= 0,
+        .log2_chroma_h= 1,
+        .comp = {
+            {0,0,1,0,7},        /* Y */
+            {1,0,1,0,7},        /* U */
+            {2,0,1,0,7},        /* V */
+        },
+    },
+    [PIX_FMT_YUVJ440P] = {
+        .name = &quot;yuvj440p&quot;,
+        .nb_components= 3,
+        .log2_chroma_w= 0,
+        .log2_chroma_h= 1,
+        .comp = {
+            {0,0,1,0,7},        /* Y */
+            {1,0,1,0,7},        /* U */
+            {2,0,1,0,7},        /* V */
+        },
+    },
+    [PIX_FMT_YUVA420P] = {
+        .name = &quot;yuva420p&quot;,
+        .nb_components= 4,
+        .log2_chroma_w= 1,
+        .log2_chroma_h= 1,
+        .comp = {
+            {0,0,1,0,7},        /* Y */
+            {1,0,1,0,7},        /* U */
+            {2,0,1,0,7},        /* V */
+            {3,0,1,0,7},        /* A */
+        },
+    },
+    [PIX_FMT_VDPAU_H264] = {
+        .name = &quot;vdpau_h264&quot;,
+        .log2_chroma_w = 1,
+        .log2_chroma_h = 1,
+        .flags = PIX_FMT_HWACCEL,
+    },
+    [PIX_FMT_VDPAU_MPEG1] = {
+        .name = &quot;vdpau_mpeg1&quot;,
+        .log2_chroma_w = 1,
+        .log2_chroma_h = 1,
+        .flags = PIX_FMT_HWACCEL,
+    },
+    [PIX_FMT_VDPAU_MPEG2] = {
+        .name = &quot;vdpau_mpeg2&quot;,
+        .log2_chroma_w = 1,
+        .log2_chroma_h = 1,
+        .flags = PIX_FMT_HWACCEL,
+    },
+    [PIX_FMT_VDPAU_WMV3] = {
+        .name = &quot;vdpau_wmv3&quot;,
+        .log2_chroma_w = 1,
+        .log2_chroma_h = 1,
+        .flags = PIX_FMT_HWACCEL,
+    },
+    [PIX_FMT_VDPAU_VC1] = {
+        .name = &quot;vdpau_vc1&quot;,
+        .log2_chroma_w = 1,
+        .log2_chroma_h = 1,
+        .flags = PIX_FMT_HWACCEL,
+    },
+    [PIX_FMT_VDPAU_MPEG4] = {
+        .name = &quot;vdpau_mpeg4&quot;,
+        .log2_chroma_w = 1,
+        .log2_chroma_h = 1,
+        .flags = PIX_FMT_HWACCEL,
+    },
+    [PIX_FMT_RGB48BE] = {
+        .name = &quot;rgb48be&quot;,
+        .nb_components= 3,
+        .log2_chroma_w= 0,
+        .log2_chroma_h= 0,
+        .comp = {
+            {0,5,1,0,15},       /* R */
+            {0,5,3,0,15},       /* G */
+            {0,5,5,0,15},       /* B */
+        },
+        .flags = PIX_FMT_BE,
+    },
+    [PIX_FMT_RGB48LE] = {
+        .name = &quot;rgb48le&quot;,
+        .nb_components= 3,
+        .log2_chroma_w= 0,
+        .log2_chroma_h= 0,
+        .comp = {
+            {0,5,1,0,15},       /* R */
+            {0,5,3,0,15},       /* G */
+            {0,5,5,0,15},       /* B */
+        },
+    },
+    [PIX_FMT_RGB565BE] = {
+        .name = &quot;rgb565be&quot;,
+        .nb_components= 3,
+        .log2_chroma_w= 0,
+        .log2_chroma_h= 0,
+        .comp = {
+            {0,1,0,3,4},        /* R */
+            {0,1,1,5,5},        /* G */
+            {0,1,1,0,4},        /* B */
+        },
+        .flags = PIX_FMT_BE,
+    },
+    [PIX_FMT_RGB565LE] = {
+        .name = &quot;rgb565le&quot;,
+        .nb_components= 3,
+        .log2_chroma_w= 0,
+        .log2_chroma_h= 0,
+        .comp = {
+            {0,1,2,3,4},        /* R */
+            {0,1,1,5,5},        /* G */
+            {0,1,1,0,4},        /* B */
+        },
+    },
+    [PIX_FMT_RGB555BE] = {
+        .name = &quot;rgb555be&quot;,
+        .nb_components= 3,
+        .log2_chroma_w= 0,
+        .log2_chroma_h= 0,
+        .comp = {
+            {0,1,0,2,4},        /* R */
+            {0,1,1,5,4},        /* G */
+            {0,1,1,0,4},        /* B */
+        },
+        .flags = PIX_FMT_BE,
+    },
+    [PIX_FMT_RGB555LE] = {
+        .name = &quot;rgb555le&quot;,
+        .nb_components= 3,
+        .log2_chroma_w= 0,
+        .log2_chroma_h= 0,
+        .comp = {
+            {0,1,2,2,4},        /* R */
+            {0,1,1,5,4},        /* G */
+            {0,1,1,0,4},        /* B */
+        },
+    },
+    [PIX_FMT_RGB444BE] = {
+        .name = &quot;rgb444be&quot;,
+        .nb_components= 3,
+        .log2_chroma_w= 0,
+        .log2_chroma_h= 0,
+        .comp = {
+            {0,1,0,0,3},        /* R */
+            {0,1,1,4,3},        /* G */
+            {0,1,1,0,3},        /* B */
+        },
+        .flags = PIX_FMT_BE,
+    },
+    [PIX_FMT_RGB444LE] = {
+        .name = &quot;rgb444le&quot;,
+        .nb_components= 3,
+        .log2_chroma_w= 0,
+        .log2_chroma_h= 0,
+        .comp = {
+            {0,1,2,0,3},        /* R */
+            {0,1,1,4,3},        /* G */
+            {0,1,1,0,3},        /* B */
+        },
+    },
+    [PIX_FMT_BGR565BE] = {
+        .name = &quot;bgr565be&quot;,
+        .nb_components= 3,
+        .log2_chroma_w= 0,
+        .log2_chroma_h= 0,
+        .comp = {
+            {0,1,0,3,4},        /* B */
+            {0,1,1,5,5},        /* G */
+            {0,1,1,0,4},        /* R */
+        },
+        .flags = PIX_FMT_BE,
+    },
+    [PIX_FMT_BGR565LE] = {
+        .name = &quot;bgr565le&quot;,
+        .nb_components= 3,
+        .log2_chroma_w= 0,
+        .log2_chroma_h= 0,
+        .comp = {
+            {0,1,2,3,4},        /* B */
+            {0,1,1,5,5},        /* G */
+            {0,1,1,0,4},        /* R */
+        },
+    },
+    [PIX_FMT_BGR555BE] = {
+        .name = &quot;bgr555be&quot;,
+        .nb_components= 3,
+        .log2_chroma_w= 0,
+        .log2_chroma_h= 0,
+        .comp = {
+            {0,1,0,2,4},       /* B */
+            {0,1,1,5,4},       /* G */
+            {0,1,1,0,4},       /* R */
+        },
+        .flags = PIX_FMT_BE,
+     },
+    [PIX_FMT_BGR555LE] = {
+        .name = &quot;bgr555le&quot;,
+        .nb_components= 3,
+        .log2_chroma_w= 0,
+        .log2_chroma_h= 0,
+        .comp = {
+            {0,1,2,2,4},        /* B */
+            {0,1,1,5,4},        /* G */
+            {0,1,1,0,4},        /* R */
+        },
+    },
+    [PIX_FMT_BGR444BE] = {
+        .name = &quot;bgr444be&quot;,
+        .nb_components= 3,
+        .log2_chroma_w= 0,
+        .log2_chroma_h= 0,
+        .comp = {
+            {0,1,0,0,3},       /* B */
+            {0,1,1,4,3},       /* G */
+            {0,1,1,0,3},       /* R */
+        },
+        .flags = PIX_FMT_BE,
+     },
+    [PIX_FMT_BGR444LE] = {
+        .name = &quot;bgr444le&quot;,
+        .nb_components= 3,
+        .log2_chroma_w= 0,
+        .log2_chroma_h= 0,
+        .comp = {
+            {0,1,2,0,3},        /* B */
+            {0,1,1,4,3},        /* G */
+            {0,1,1,0,3},        /* R */
+        },
+    },
+    [PIX_FMT_VAAPI_MOCO] = {
+        .name = &quot;vaapi_moco&quot;,
+        .log2_chroma_w = 1,
+        .log2_chroma_h = 1,
+        .flags = PIX_FMT_HWACCEL,
+    },
+    [PIX_FMT_VAAPI_IDCT] = {
+        .name = &quot;vaapi_idct&quot;,
+        .log2_chroma_w = 1,
+        .log2_chroma_h = 1,
+        .flags = PIX_FMT_HWACCEL,
+    },
+    [PIX_FMT_VAAPI_VLD] = {
+        .name = &quot;vaapi_vld&quot;,
+        .log2_chroma_w = 1,
+        .log2_chroma_h = 1,
+        .flags = PIX_FMT_HWACCEL,
+    },
+    [PIX_FMT_YUV420P16LE] = {
+        .name = &quot;yuv420p16le&quot;,
+        .nb_components= 3,
+        .log2_chroma_w= 1,
+        .log2_chroma_h= 1,
+        .comp = {
+            {0,1,1,0,15},        /* Y */
+            {1,1,1,0,15},        /* U */
+            {2,1,1,0,15},        /* V */
+        },
+    },
+    [PIX_FMT_YUV420P16BE] = {
+        .name = &quot;yuv420p16be&quot;,
+        .nb_components= 3,
+        .log2_chroma_w= 1,
+        .log2_chroma_h= 1,
+        .comp = {
+            {0,1,1,0,15},        /* Y */
+            {1,1,1,0,15},        /* U */
+            {2,1,1,0,15},        /* V */
+        },
+        .flags = PIX_FMT_BE,
+    },
+    [PIX_FMT_YUV422P16LE] = {
+        .name = &quot;yuv422p16le&quot;,
+        .nb_components= 3,
+        .log2_chroma_w= 1,
+        .log2_chroma_h= 0,
+        .comp = {
+            {0,1,1,0,15},        /* Y */
+            {1,1,1,0,15},        /* U */
+            {2,1,1,0,15},        /* V */
+        },
+    },
+    [PIX_FMT_YUV422P16BE] = {
+        .name = &quot;yuv422p16be&quot;,
+        .nb_components= 3,
+        .log2_chroma_w= 1,
+        .log2_chroma_h= 0,
+        .comp = {
+            {0,1,1,0,15},        /* Y */
+            {1,1,1,0,15},        /* U */
+            {2,1,1,0,15},        /* V */
+        },
+        .flags = PIX_FMT_BE,
+    },
+    [PIX_FMT_YUV444P16LE] = {
+        .name = &quot;yuv444p16le&quot;,
+        .nb_components= 3,
+        .log2_chroma_w= 0,
+        .log2_chroma_h= 0,
+        .comp = {
+            {0,1,1,0,15},        /* Y */
+            {1,1,1,0,15},        /* U */
+            {2,1,1,0,15},        /* V */
+        },
+    },
+    [PIX_FMT_YUV444P16BE] = {
+        .name = &quot;yuv444p16be&quot;,
+        .nb_components= 3,
+        .log2_chroma_w= 0,
+        .log2_chroma_h= 0,
+        .comp = {
+            {0,1,1,0,15},        /* Y */
+            {1,1,1,0,15},        /* U */
+            {2,1,1,0,15},        /* V */
+        },
+        .flags = PIX_FMT_BE,
+    },
+    [PIX_FMT_DXVA2_VLD] = {
+        .name = &quot;dxva2_vld&quot;,
+        .log2_chroma_w = 1,
+        .log2_chroma_h = 1,
+        .flags = PIX_FMT_HWACCEL,
+    },
+    [PIX_FMT_Y400A] = {
+        .name = &quot;y400a&quot;,
+        .nb_components= 2,
+        .comp = {
+            {0,1,1,0,7},        /* Y */
+            {0,1,2,0,7},        /* A */
+        },
+    },
+};
+
+static enum PixelFormat get_pix_fmt_internal(const char *name)
+{
+    enum PixelFormat pix_fmt;
+
+    for (pix_fmt = 0; pix_fmt &lt; PIX_FMT_NB; pix_fmt++)
+        if (av_pix_fmt_descriptors[pix_fmt].name &amp;&amp;
+            !strcmp(av_pix_fmt_descriptors[pix_fmt].name, name))
+            return pix_fmt;
+
+    return PIX_FMT_NONE;
+}
+
+#if HAVE_BIGENDIAN
+#   define X_NE(be, le) be
+#else
+#   define X_NE(be, le) le
+#endif
+
+enum PixelFormat av_get_pix_fmt(const char *name)
+{
+    enum PixelFormat pix_fmt;
+
+    if (!strcmp(name, &quot;rgb32&quot;))
+        name = X_NE(&quot;argb&quot;, &quot;bgra&quot;);
+    else if (!strcmp(name, &quot;bgr32&quot;))
+        name = X_NE(&quot;abgr&quot;, &quot;rgba&quot;);
+
+    pix_fmt = get_pix_fmt_internal(name);
+    if (pix_fmt == PIX_FMT_NONE) {
+        char name2[32];
+
+        snprintf(name2, sizeof(name2), &quot;%s%s&quot;, name, X_NE(&quot;be&quot;, &quot;le&quot;));
+        pix_fmt = get_pix_fmt_internal(name2);
+    }
+    return pix_fmt;
+}
+
+int av_get_bits_per_pixel(const AVPixFmtDescriptor *pixdesc)
+{
+    int c, bits = 0;
+    int log2_pixels = pixdesc-&gt;log2_chroma_w + pixdesc-&gt;log2_chroma_h;
+
+    for (c = 0; c &lt; pixdesc-&gt;nb_components; c++) {
+        int s = c==1 || c==2 ? 0 : log2_pixels;
+        bits += (pixdesc-&gt;comp[c].depth_minus1+1) &lt;&lt; s;
+    }
+
+    return bits &gt;&gt; log2_pixels;
+}

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/pixdesc.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/pixdesc.h	2010-05-26 05:26:02 UTC (rev 6231)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/pixdesc.h	2010-05-26 05:26:23 UTC (rev 6232)
@@ -0,0 +1,154 @@
+/*
+ * pixel format descriptor
+ * Copyright (c) 2009 Michael Niedermayer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">michaelni at gmx.at</A>&gt;
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef AVUTIL_PIXDESC_H
+#define AVUTIL_PIXDESC_H
+
+#include &lt;inttypes.h&gt;
+
+typedef struct AVComponentDescriptor{
+    uint16_t plane        :2;            ///&lt; which of the 4 planes contains the component
+
+    /**
+     * Number of elements between 2 horizontally consecutive pixels minus 1.
+     * Elements are bits for bitstream formats, bytes otherwise.
+     */
+    uint16_t step_minus1  :3;
+
+    /**
+     * Number of elements before the component of the first pixel plus 1.
+     * Elements are bits for bitstream formats, bytes otherwise.
+     */
+    uint16_t offset_plus1 :3;
+    uint16_t shift        :3;            ///&lt; number of least significant bits that must be shifted away to get the value
+    uint16_t depth_minus1 :4;            ///&lt; number of bits in the component minus 1
+}AVComponentDescriptor;
+
+/**
+ * Descriptor that unambiguously describes how the bits of a pixel are
+ * stored in the up to 4 data planes of an image. It also stores the
+ * subsampling factors and number of components.
+ *
+ * @note This is separate of the colorspace (RGB, YCbCr, YPbPr, JPEG-style YUV
+ *       and all the YUV variants) AVPixFmtDescriptor just stores how values
+ *       are stored not what these values represent.
+ */
+typedef struct AVPixFmtDescriptor{
+    const char *name;
+    uint8_t nb_components;      ///&lt; The number of components each pixel has, (1-4)
+
+    /**
+     * Amount to shift the luma width right to find the chroma width.
+     * For YV12 this is 1 for example.
+     * chroma_width = -((-luma_width) &gt;&gt; log2_chroma_w)
+     * The note above is needed to ensure rounding up.
+     * This value only refers to the chroma components.
+     */
+    uint8_t log2_chroma_w;      ///&lt; chroma_width = -((-luma_width )&gt;&gt;log2_chroma_w)
+
+    /**
+     * Amount to shift the luma height right to find the chroma height.
+     * For YV12 this is 1 for example.
+     * chroma_height= -((-luma_height) &gt;&gt; log2_chroma_h)
+     * The note above is needed to ensure rounding up.
+     * This value only refers to the chroma components.
+     */
+    uint8_t log2_chroma_h;
+    uint8_t flags;
+
+    /**
+     * Parameters that describe how pixels are packed. If the format
+     * has chroma components, they must be stored in comp[1] and
+     * comp[2].
+     */
+    AVComponentDescriptor comp[4];
+}AVPixFmtDescriptor;
+
+#define PIX_FMT_BE        1 ///&lt; Pixel format is big-endian.
+#define PIX_FMT_PAL       2 ///&lt; Pixel format has a palette in data[1], values are indexes in this palette.
+#define PIX_FMT_BITSTREAM 4 ///&lt; All values of a component are bit-wise packed end to end.
+#define PIX_FMT_HWACCEL   8 ///&lt; Pixel format is an HW accelerated format.
+
+/**
+ * The array of all the pixel format descriptors.
+ */
+extern const AVPixFmtDescriptor av_pix_fmt_descriptors[];
+
+/**
+ * Reads a line from an image, and writes the values of the
+ * pixel format component c to dst.
+ *
+ * @param data the array containing the pointers to the planes of the image
+ * @param linesizes the array containing the linesizes of the image
+ * @param desc the pixel format descriptor for the image
+ * @param x the horizontal coordinate of the first pixel to read
+ * @param y the vertical coordinate of the first pixel to read
+ * @param w the width of the line to read, that is the number of
+ * values to write to dst
+ * @param read_pal_component if not zero and the format is a paletted
+ * format writes the values corresponding to the palette
+ * component c in data[1] to dst, rather than the palette indexes in
+ * data[0]. The behavior is undefined if the format is not paletted.
+ */
+void read_line(uint16_t *dst, const uint8_t *data[4], const int linesize[4],
+               const AVPixFmtDescriptor *desc, int x, int y, int c, int w, int read_pal_component);
+
+/**
+ * Writes the values from src to the pixel format component c of an
+ * image line.
+ *
+ * @param src array containing the values to write
+ * @param data the array containing the pointers to the planes of the
+ * image to write into. It is supposed to be zeroed.
+ * @param linesizes the array containing the linesizes of the image
+ * @param desc the pixel format descriptor for the image
+ * @param x the horizontal coordinate of the first pixel to write
+ * @param y the vertical coordinate of the first pixel to write
+ * @param w the width of the line to write, that is the number of
+ * values to write to the image line
+ */
+void write_line(const uint16_t *src, uint8_t *data[4], const int linesize[4],
+                const AVPixFmtDescriptor *desc, int x, int y, int c, int w);
+
+/**
+ * Returns the pixel format corresponding to name.
+ *
+ * If there is no pixel format with name name, then looks for a
+ * pixel format with the name corresponding to the native endian
+ * format of name.
+ * For example in a little-endian system, first looks for &quot;gray16&quot;,
+ * then for &quot;gray16le&quot;.
+ *
+ * Finally if no pixel format has been found, returns PIX_FMT_NONE.
+ */
+enum PixelFormat av_get_pix_fmt(const char *name);
+
+/**
+ * Returns the number of bits per pixel used by the pixel format
+ * described by pixdesc.
+ *
+ * The returned number of bits refers to the number of bits actually
+ * used for storing the pixel information, that is padding bits are
+ * not counted.
+ */
+int av_get_bits_per_pixel(const AVPixFmtDescriptor *pixdesc);
+
+#endif /* AVUTIL_PIXDESC_H */

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/pixfmt.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/pixfmt.h	2010-05-26 05:26:02 UTC (rev 6231)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/pixfmt.h	2010-05-26 05:26:23 UTC (rev 6232)
@@ -22,13 +22,15 @@
 #define AVUTIL_PIXFMT_H
 
 /**
- * @file libavutil/pixfmt.h
+ * @file
  * pixel format definitions
  *
  * @warning This file has to be considered an internal but installed
  * header, so it should not be directly included in your projects.
  */
 
+#include &quot;libavutil/avconfig.h&quot;
+
 /**
  * Pixel format. Notes:
  *
@@ -66,8 +68,8 @@
     PIX_FMT_YUV410P,   ///&lt; planar YUV 4:1:0,  9bpp, (1 Cr &amp; Cb sample per 4x4 Y samples)
     PIX_FMT_YUV411P,   ///&lt; planar YUV 4:1:1, 12bpp, (1 Cr &amp; Cb sample per 4x1 Y samples)
     PIX_FMT_GRAY8,     ///&lt;        Y        ,  8bpp
-    PIX_FMT_MONOWHITE, ///&lt;        Y        ,  1bpp, 0 is white, 1 is black
-    PIX_FMT_MONOBLACK, ///&lt;        Y        ,  1bpp, 0 is black, 1 is white
+    PIX_FMT_MONOWHITE, ///&lt;        Y        ,  1bpp, 0 is white, 1 is black, in each byte pixels are ordered from the msb to the lsb
+    PIX_FMT_MONOBLACK, ///&lt;        Y        ,  1bpp, 0 is black, 1 is white, in each byte pixels are ordered from the msb to the lsb
     PIX_FMT_PAL8,      ///&lt; 8 bit with PIX_FMT_RGB32 palette
     PIX_FMT_YUVJ420P,  ///&lt; planar YUV 4:2:0, 12bpp, full scale (JPEG)
     PIX_FMT_YUVJ422P,  ///&lt; planar YUV 4:2:2, 16bpp, full scale (JPEG)
@@ -77,12 +79,12 @@
     PIX_FMT_UYVY422,   ///&lt; packed YUV 4:2:2, 16bpp, Cb Y0 Cr Y1
     PIX_FMT_UYYVYY411, ///&lt; packed YUV 4:1:1, 12bpp, Cb Y0 Y1 Cr Y2 Y3
     PIX_FMT_BGR8,      ///&lt; packed RGB 3:3:2,  8bpp, (msb)2B 3G 3R(lsb)
-    PIX_FMT_BGR4,      ///&lt; packed RGB 1:2:1,  4bpp, (msb)1B 2G 1R(lsb)
+    PIX_FMT_BGR4,      ///&lt; packed RGB 1:2:1 bitstream,  4bpp, (msb)1B 2G 1R(lsb), a byte contains two pixels, the first pixel in the byte is the one composed by the 4 msb bits
     PIX_FMT_BGR4_BYTE, ///&lt; packed RGB 1:2:1,  8bpp, (msb)1B 2G 1R(lsb)
     PIX_FMT_RGB8,      ///&lt; packed RGB 3:3:2,  8bpp, (msb)2R 3G 3B(lsb)
-    PIX_FMT_RGB4,      ///&lt; packed RGB 1:2:1,  4bpp, (msb)1R 2G 1B(lsb)
+    PIX_FMT_RGB4,      ///&lt; packed RGB 1:2:1 bitstream,  4bpp, (msb)1R 2G 1B(lsb), a byte contains two pixels, the first pixel in the byte is the one composed by the 4 msb bits
     PIX_FMT_RGB4_BYTE, ///&lt; packed RGB 1:2:1,  8bpp, (msb)1R 2G 1B(lsb)
-    PIX_FMT_NV12,      ///&lt; planar YUV 4:2:0, 12bpp, 1 plane for Y and 1 for UV
+    PIX_FMT_NV12,      ///&lt; planar YUV 4:2:0, 12bpp, 1 plane for Y and 1 plane for the UV components, which are interleaved (first byte U and the following byte V)
     PIX_FMT_NV21,      ///&lt; as above, but U and V bytes are swapped
 
     PIX_FMT_ARGB,      ///&lt; packed ARGB 8:8:8:8, 32bpp, ARGBARGB...
@@ -100,8 +102,8 @@
     PIX_FMT_VDPAU_MPEG2,///&lt; MPEG-2 HW decoding with VDPAU, data[0] contains a vdpau_render_state struct which contains the bitstream of the slices as well as various fields extracted from headers
     PIX_FMT_VDPAU_WMV3,///&lt; WMV3 HW decoding with VDPAU, data[0] contains a vdpau_render_state struct which contains the bitstream of the slices as well as various fields extracted from headers
     PIX_FMT_VDPAU_VC1, ///&lt; VC-1 HW decoding with VDPAU, data[0] contains a vdpau_render_state struct which contains the bitstream of the slices as well as various fields extracted from headers
-    PIX_FMT_RGB48BE,   ///&lt; packed RGB 16:16:16, 48bpp, 16R, 16G, 16B, big-endian
-    PIX_FMT_RGB48LE,   ///&lt; packed RGB 16:16:16, 48bpp, 16R, 16G, 16B, little-endian
+    PIX_FMT_RGB48BE,   ///&lt; packed RGB 16:16:16, 48bpp, 16R, 16G, 16B, the 2-byte value for each R/G/B component is stored as big-endian
+    PIX_FMT_RGB48LE,   ///&lt; packed RGB 16:16:16, 48bpp, 16R, 16G, 16B, the 2-byte value for each R/G/B component is stored as little-endian
 
     PIX_FMT_RGB565BE,  ///&lt; packed RGB 5:6:5, 16bpp, (msb)   5R 6G 5B(lsb), big-endian
     PIX_FMT_RGB565LE,  ///&lt; packed RGB 5:6:5, 16bpp, (msb)   5R 6G 5B(lsb), little-endian
@@ -117,16 +119,24 @@
     PIX_FMT_VAAPI_IDCT, ///&lt; HW acceleration through VA API at IDCT entry-point, Picture.data[3] contains a vaapi_render_state struct which contains fields extracted from headers
     PIX_FMT_VAAPI_VLD,  ///&lt; HW decoding through VA API, Picture.data[3] contains a vaapi_render_state struct which contains the bitstream of the slices as well as various fields extracted from headers
 
-    PIX_FMT_YUV420PLE,  ///&lt; planar YUV 4:2:0, 24bpp, (1 Cr &amp; Cb sample per 2x2 Y samples), little-endian
-    PIX_FMT_YUV420PBE,  ///&lt; planar YUV 4:2:0, 24bpp, (1 Cr &amp; Cb sample per 2x2 Y samples), big-endian
-    PIX_FMT_YUV422PLE,  ///&lt; planar YUV 4:2:2, 32bpp, (1 Cr &amp; Cb sample per 2x1 Y samples), little-endian
-    PIX_FMT_YUV422PBE,  ///&lt; planar YUV 4:2:2, 32bpp, (1 Cr &amp; Cb sample per 2x1 Y samples), big-endian
-    PIX_FMT_YUV444PLE,  ///&lt; planar YUV 4:4:4, 48bpp, (1 Cr &amp; Cb sample per 1x1 Y samples), little-endian
-    PIX_FMT_YUV444PBE,  ///&lt; planar YUV 4:4:4, 48bpp, (1 Cr &amp; Cb sample per 1x1 Y samples), big-endian
+    PIX_FMT_YUV420P16LE,  ///&lt; planar YUV 4:2:0, 24bpp, (1 Cr &amp; Cb sample per 2x2 Y samples), little-endian
+    PIX_FMT_YUV420P16BE,  ///&lt; planar YUV 4:2:0, 24bpp, (1 Cr &amp; Cb sample per 2x2 Y samples), big-endian
+    PIX_FMT_YUV422P16LE,  ///&lt; planar YUV 4:2:2, 32bpp, (1 Cr &amp; Cb sample per 2x1 Y samples), little-endian
+    PIX_FMT_YUV422P16BE,  ///&lt; planar YUV 4:2:2, 32bpp, (1 Cr &amp; Cb sample per 2x1 Y samples), big-endian
+    PIX_FMT_YUV444P16LE,  ///&lt; planar YUV 4:4:4, 48bpp, (1 Cr &amp; Cb sample per 1x1 Y samples), little-endian
+    PIX_FMT_YUV444P16BE,  ///&lt; planar YUV 4:4:4, 48bpp, (1 Cr &amp; Cb sample per 1x1 Y samples), big-endian
+    PIX_FMT_VDPAU_MPEG4,  ///&lt; MPEG4 HW decoding with VDPAU, data[0] contains a vdpau_render_state struct which contains the bitstream of the slices as well as various fields extracted from headers
+    PIX_FMT_DXVA2_VLD,    ///&lt; HW decoding through DXVA2, Picture.data[3] contains a LPDIRECT3DSURFACE9 pointer
+
+    PIX_FMT_RGB444BE,  ///&lt; packed RGB 4:4:4, 16bpp, (msb)4A 4R 4G 4B(lsb), big-endian, most significant bits to 0
+    PIX_FMT_RGB444LE,  ///&lt; packed RGB 4:4:4, 16bpp, (msb)4A 4R 4G 4B(lsb), little-endian, most significant bits to 0
+    PIX_FMT_BGR444BE,  ///&lt; packed BGR 4:4:4, 16bpp, (msb)4A 4B 4G 4R(lsb), big-endian, most significant bits to 1
+    PIX_FMT_BGR444LE,  ///&lt; packed BGR 4:4:4, 16bpp, (msb)4A 4B 4G 4R(lsb), little-endian, most significant bits to 1
+    PIX_FMT_Y400A,     ///&lt; 8bit gray, 8bit alpha
     PIX_FMT_NB,        ///&lt; number of pixel formats, DO NOT USE THIS if you want to link with shared libav* because the number of formats might differ between versions
 };
 
-#if HAVE_BIGENDIAN
+#if AV_HAVE_BIGENDIAN
 #   define PIX_FMT_NE(be, le) PIX_FMT_##be
 #else
 #   define PIX_FMT_NE(be, le) PIX_FMT_##le
@@ -141,11 +151,13 @@
 #define PIX_FMT_RGB48  PIX_FMT_NE(RGB48BE,  RGB48LE)
 #define PIX_FMT_RGB565 PIX_FMT_NE(RGB565BE, RGB565LE)
 #define PIX_FMT_RGB555 PIX_FMT_NE(RGB555BE, RGB555LE)
+#define PIX_FMT_RGB444 PIX_FMT_NE(RGB444BE, RGB444LE)
 #define PIX_FMT_BGR565 PIX_FMT_NE(BGR565BE, BGR565LE)
 #define PIX_FMT_BGR555 PIX_FMT_NE(BGR555BE, BGR555LE)
+#define PIX_FMT_BGR444 PIX_FMT_NE(BGR444BE, BGR444LE)
 
-#define PIX_FMT_YUV420P16 PIX_FMT_NE(YUV420PBE, YUV420PLE)
-#define PIX_FMT_YUV422P16 PIX_FMT_NE(YUV422PBE, YUV422PLE)
-#define PIX_FMT_YUV444P16 PIX_FMT_NE(YUV444PBE, YUV444PLE)
+#define PIX_FMT_YUV420P16 PIX_FMT_NE(YUV420P16BE, YUV420P16LE)
+#define PIX_FMT_YUV422P16 PIX_FMT_NE(YUV422P16BE, YUV422P16LE)
+#define PIX_FMT_YUV444P16 PIX_FMT_NE(YUV444P16BE, YUV444P16LE)
 
 #endif /* AVUTIL_PIXFMT_H */

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/random_seed.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/random_seed.c	2010-05-26 05:26:02 UTC (rev 6231)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/random_seed.c	2010-05-26 05:26:23 UTC (rev 6232)
@@ -22,8 +22,9 @@
 #include &lt;fcntl.h&gt;
 #include &quot;timer.h&quot;
 #include &quot;random_seed.h&quot;
+#include &quot;avutil.h&quot;
 
-uint32_t ff_random_get_seed(void)
+uint32_t av_get_random_seed(void)
 {
     uint32_t seed;
     int fd;
@@ -31,9 +32,10 @@
     if ((fd = open(&quot;/dev/random&quot;, O_RDONLY)) == -1)
         fd = open(&quot;/dev/urandom&quot;, O_RDONLY);
     if (fd != -1){
-        read(fd, &amp;seed, 4);
+        int err = read(fd, &amp;seed, 4);
         close(fd);
-        return seed;
+        if (err == 4)
+            return seed;
     }
 #ifdef AV_READ_TIME
     seed = AV_READ_TIME();
@@ -41,3 +43,11 @@
     // XXX what to do ?
     return seed;
 }
+
+#if LIBAVUTIL_VERSION_MAJOR &lt; 51
+attribute_deprecated uint32_t ff_random_get_seed(void);
+uint32_t ff_random_get_seed(void)
+{
+    return av_get_random_seed();
+}
+#endif

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/random_seed.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/random_seed.h	2010-05-26 05:26:02 UTC (rev 6231)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/random_seed.h	2010-05-26 05:26:23 UTC (rev 6232)
@@ -26,6 +26,6 @@
 /**
  * Gets a seed to use in conjunction with random functions.
  */
-uint32_t ff_random_get_seed(void);
+uint32_t av_get_random_seed(void);
 
 #endif /* AVUTIL_RANDOM_SEED_H */

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/rational.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/rational.c	2010-05-26 05:26:02 UTC (rev 6231)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/rational.c	2010-05-26 05:26:23 UTC (rev 6232)
@@ -20,7 +20,7 @@
  */
 
 /**
- * @file libavutil/rational.c
+ * @file
  * rational numbers
  * @author Michael Niedermayer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">michaelni at gmx.at</A>&gt;
  */
@@ -98,6 +98,8 @@
 #define LOG2  0.69314718055994530941723212145817656807550013436025
     int exponent= FFMAX( (int)(log(fabs(d) + 1e-20)/LOG2), 0);
     int64_t den= 1LL &lt;&lt; (61 - exponent);
+    if (isnan(d))
+        return (AVRational){0,0};
     av_reduce(&amp;a.num, &amp;a.den, (int64_t)(d * den + 0.5), den, max);
 
     return a;

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/rational.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/rational.h	2010-05-26 05:26:02 UTC (rev 6231)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/rational.h	2010-05-26 05:26:23 UTC (rev 6232)
@@ -20,7 +20,7 @@
  */
 
 /**
- * @file libavutil/rational.h
+ * @file
  * rational numbers
  * @author Michael Niedermayer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">michaelni at gmx.at</A>&gt;
  */
@@ -29,7 +29,7 @@
 #define AVUTIL_RATIONAL_H
 
 #include &lt;stdint.h&gt;
-#include &quot;common.h&quot;
+#include &quot;attributes.h&quot;
 
 /**
  * rational number numerator/denominator

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/sh4/bswap.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/sh4/bswap.h	2010-05-26 05:26:02 UTC (rev 6231)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/sh4/bswap.h	2010-05-26 05:26:23 UTC (rev 6232)
@@ -17,7 +17,7 @@
  */
 
 /**
- * @file libavutil/sh4/bswap.h
+ * @file
  * byte swapping routines
  */
 
@@ -26,7 +26,7 @@
 
 #include &lt;stdint.h&gt;
 #include &quot;config.h&quot;
-#include &quot;libavutil/common.h&quot;
+#include &quot;libavutil/attributes.h&quot;
 
 #define bswap_16 bswap_16
 static av_always_inline av_const uint16_t bswap_16(uint16_t x)

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/sha.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/sha.c	2010-05-26 05:26:02 UTC (rev 6231)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/sha.c	2010-05-26 05:26:23 UTC (rev 6232)
@@ -21,10 +21,12 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
-#include &quot;common.h&quot;
+#include &lt;string.h&gt;
 #include &quot;avutil.h&quot;
 #include &quot;bswap.h&quot;
 #include &quot;sha.h&quot;
+#include &quot;sha1.h&quot;
+#include &quot;intreadwrite.h&quot;
 
 /** hash context */
 typedef struct AVSHA {
@@ -319,7 +321,7 @@
         av_sha_update(ctx, &quot;&quot;, 1);
     av_sha_update(ctx, (uint8_t *)&amp;finalcount, 8); /* Should cause a transform() */
     for (i = 0; i &lt; ctx-&gt;digest_len; i++)
-        ((uint32_t*)digest)[i] = be2me_32(ctx-&gt;state[i]);
+        AV_WB32(digest + i*4, ctx-&gt;state[i]);
 }
 
 #if LIBAVUTIL_VERSION_MAJOR &lt; 51

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/timer.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/timer.h	2010-05-26 05:26:02 UTC (rev 6231)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/timer.h	2010-05-26 05:26:23 UTC (rev 6232)
@@ -1,5 +1,5 @@
 /**
- * @file libavutil/timer.h
+ * @file
  * high precision timer, useful to profile code
  *
  * copyright (c) 2006 Michael Niedermayer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">michaelni at gmx.at</A>&gt;
@@ -26,13 +26,8 @@
 
 #include &lt;stdlib.h&gt;
 #include &lt;stdint.h&gt;
-// MEANX
-#ifndef ADM_NO_CONFIG_H
 #include &quot;config.h&quot;
-#endif
-// MEANX
 
-
 #if   ARCH_ARM
 #   include &quot;arm/timer.h&quot;
 #elif ARCH_BFIN

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/tomi/intreadwrite.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/tomi/intreadwrite.h	2010-05-26 05:26:02 UTC (rev 6231)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/tomi/intreadwrite.h	2010-05-26 05:26:23 UTC (rev 6232)
@@ -0,0 +1,148 @@
+/*
+ * Copyright (c) 2010 Mans Rullgard &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">mans at mansr.com</A>&gt;
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef AVUTIL_TOMI_INTREADWRITE_H
+#define AVUTIL_TOMI_INTREADWRITE_H
+
+#include &lt;stdint.h&gt;
+#include &quot;config.h&quot;
+
+#define AV_RB16 AV_RB16
+static av_always_inline uint16_t AV_RB16(const void *p)
+{
+    uint16_t v;
+    __asm__ (&quot;loadacc,   (%1+) \n\t&quot;
+             &quot;rol8             \n\t&quot;
+             &quot;storeacc,  %0    \n\t&quot;
+             &quot;loadacc,   (%1+) \n\t&quot;
+             &quot;add,       %0    \n\t&quot;
+             : &quot;=r&quot;(v), &quot;+a&quot;(p));
+    return v;
+}
+
+#define AV_WB16 AV_WB16
+static av_always_inline void AV_WB16(void *p, uint16_t v)
+{
+    __asm__ volatile (&quot;loadacc,   %1    \n\t&quot;
+                      &quot;lsr8             \n\t&quot;
+                      &quot;storeacc,  (%0+) \n\t&quot;
+                      &quot;loadacc,   %1    \n\t&quot;
+                      &quot;storeacc,  (%0+) \n\t&quot;
+                      : &quot;+&amp;a&quot;(p) : &quot;r&quot;(v));
+}
+
+#define AV_RL16 AV_RL16
+static av_always_inline uint16_t AV_RL16(const void *p)
+{
+    uint16_t v;
+    __asm__ (&quot;loadacc,   (%1+) \n\t&quot;
+             &quot;storeacc,  %0    \n\t&quot;
+             &quot;loadacc,   (%1+) \n\t&quot;
+             &quot;rol8             \n\t&quot;
+             &quot;add,       %0    \n\t&quot;
+             : &quot;=r&quot;(v), &quot;+a&quot;(p));
+    return v;
+}
+
+#define AV_WL16 AV_WL16
+static av_always_inline void AV_WL16(void *p, uint16_t v)
+{
+    __asm__ volatile (&quot;loadacc,   %1    \n\t&quot;
+                      &quot;storeacc,  (%0+) \n\t&quot;
+                      &quot;lsr8             \n\t&quot;
+                      &quot;storeacc,  (%0+) \n\t&quot;
+                      : &quot;+&amp;a&quot;(p) : &quot;r&quot;(v));
+}
+
+#define AV_RB32 AV_RB32
+static av_always_inline uint32_t AV_RB32(const void *p)
+{
+    uint32_t v;
+    __asm__ (&quot;loadacc,   (%1+) \n\t&quot;
+             &quot;rol8             \n\t&quot;
+             &quot;rol8             \n\t&quot;
+             &quot;rol8             \n\t&quot;
+             &quot;storeacc,  %0    \n\t&quot;
+             &quot;loadacc,   (%1+) \n\t&quot;
+             &quot;rol8             \n\t&quot;
+             &quot;rol8             \n\t&quot;
+             &quot;add,       %0    \n\t&quot;
+             &quot;loadacc,   (%1+) \n\t&quot;
+             &quot;rol8             \n\t&quot;
+             &quot;add,       %0    \n\t&quot;
+             &quot;loadacc,   (%1+) \n\t&quot;
+             &quot;add,       %0    \n\t&quot;
+             : &quot;=r&quot;(v), &quot;+a&quot;(p));
+    return v;
+}
+
+#define AV_WB32 AV_WB32
+static av_always_inline void AV_WB32(void *p, uint32_t v)
+{
+    __asm__ volatile (&quot;loadacc,   #4    \n\t&quot;
+                      &quot;add,       %0    \n\t&quot;
+                      &quot;loadacc,   %1    \n\t&quot;
+                      &quot;storeacc,  (-%0) \n\t&quot;
+                      &quot;lsr8             \n\t&quot;
+                      &quot;storeacc,  (-%0) \n\t&quot;
+                      &quot;lsr8             \n\t&quot;
+                      &quot;storeacc,  (-%0) \n\t&quot;
+                      &quot;lsr8             \n\t&quot;
+                      &quot;storeacc,  (-%0) \n\t&quot;
+                      : &quot;+&amp;a&quot;(p) : &quot;r&quot;(v));
+}
+
+#define AV_RL32 AV_RL32
+static av_always_inline uint32_t AV_RL32(const void *p)
+{
+    uint32_t v;
+    __asm__ (&quot;loadacc,   (%1+) \n\t&quot;
+             &quot;storeacc,  %0    \n\t&quot;
+             &quot;loadacc,   (%1+) \n\t&quot;
+             &quot;rol8             \n\t&quot;
+             &quot;add,       %0    \n\t&quot;
+             &quot;loadacc,   (%1+) \n\t&quot;
+             &quot;rol8             \n\t&quot;
+             &quot;rol8             \n\t&quot;
+             &quot;add,       %0    \n\t&quot;
+             &quot;loadacc,   (%1+) \n\t&quot;
+             &quot;rol8             \n\t&quot;
+             &quot;rol8             \n\t&quot;
+             &quot;rol8             \n\t&quot;
+             &quot;add,       %0    \n\t&quot;
+             : &quot;=r&quot;(v), &quot;+a&quot;(p));
+    return v;
+}
+
+#define AV_WL32 AV_WL32
+static av_always_inline void AV_WL32(void *p, uint32_t v)
+{
+    __asm__ volatile (&quot;loadacc,   %1    \n\t&quot;
+                      &quot;storeacc,  (%0+) \n\t&quot;
+                      &quot;lsr8             \n\t&quot;
+                      &quot;storeacc,  (%0+) \n\t&quot;
+                      &quot;lsr8             \n\t&quot;
+                      &quot;storeacc,  (%0+) \n\t&quot;
+                      &quot;lsr8             \n\t&quot;
+                      &quot;storeacc,  (%0+) \n\t&quot;
+                      : &quot;+&amp;a&quot;(p) : &quot;r&quot;(v));
+}
+
+#endif /* AVUTIL_TOMI_INTREADWRITE_H */

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/tree.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/tree.c	2010-05-26 05:26:02 UTC (rev 6231)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/tree.c	2010-05-26 05:26:23 UTC (rev 6232)
@@ -18,7 +18,6 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
-#include &quot;common.h&quot;
 #include &quot;log.h&quot;
 #include &quot;tree.h&quot;
 
@@ -135,13 +134,14 @@
     }
 }
 
-#if 0
-void av_tree_enumerate(AVTreeNode *t, void *opaque, int (*f)(void *opaque, void *elem)){
-    int v= f(opaque, t-&gt;elem);
-    if(v&gt;=0) av_tree_enumerate(t-&gt;child[0], opaque, f);
-    if(v&lt;=0) av_tree_enumerate(t-&gt;child[1], opaque, f);
+void av_tree_enumerate(AVTreeNode *t, void *opaque, int (*cmp)(void *opaque, void *elem), int (*enu)(void *opaque, void *elem)){
+    if(t){
+        int v= cmp ? cmp(opaque, t-&gt;elem) : 0;
+        if(v&gt;=0) av_tree_enumerate(t-&gt;child[0], opaque, cmp, enu);
+        if(v==0) enu(opaque, t-&gt;elem);
+        if(v&lt;=0) av_tree_enumerate(t-&gt;child[1], opaque, cmp, enu);
+    }
 }
-#endif
 
 #ifdef TEST
 

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/tree.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/tree.h	2010-05-26 05:26:02 UTC (rev 6231)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/tree.h	2010-05-26 05:26:23 UTC (rev 6232)
@@ -19,7 +19,7 @@
  */
 
 /**
- * @file libavutil/tree.h
+ * @file
  * A tree container.
  * Insertion, removal, finding equal, largest which is smaller than and
  * smallest which is larger than, all have O(log n) worst case complexity.
@@ -79,4 +79,17 @@
 void *av_tree_insert(struct AVTreeNode **rootp, void *key, int (*cmp)(void *key, const void *b), struct AVTreeNode **next);
 void av_tree_destroy(struct AVTreeNode *t);
 
+/**
+ * Applies enu(opaque, &amp;elem) to all the elements in the tree in a given range.
+ *
+ * @param cmp a comparison function that returns &lt; 0 for a element below the
+ *            range, &gt; 0 for a element above the range and == 0 for a
+ *            element inside the range
+ *
+ * @note The cmp function should use the same ordering used to construct the
+ *       tree.
+ */
+void av_tree_enumerate(struct AVTreeNode *t, void *opaque, int (*cmp)(void *opaque, void *elem), int (*enu)(void *opaque, void *elem));
+
+
 #endif /* AVUTIL_TREE_H */

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/utils.c
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/utils.c	2010-05-26 05:26:02 UTC (rev 6231)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/utils.c	2010-05-26 05:26:23 UTC (rev 6232)
@@ -16,10 +16,11 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
+#include &quot;config.h&quot;
 #include &quot;avutil.h&quot;
 
 /**
- * @file libavutil/utils.c
+ * @file
  * various utility functions
  */
 
@@ -27,3 +28,14 @@
 {
     return LIBAVUTIL_VERSION_INT;
 }
+
+const char *avutil_configuration(void)
+{
+    return FFMPEG_CONFIGURATION;
+}
+
+const char *avutil_license(void)
+{
+#define LICENSE_PREFIX &quot;libavutil license: &quot;
+    return LICENSE_PREFIX FFMPEG_LICENSE + sizeof(LICENSE_PREFIX) - 1;
+}

Modified: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/x86/bswap.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/x86/bswap.h	2010-05-26 05:26:02 UTC (rev 6231)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/x86/bswap.h	2010-05-26 05:26:23 UTC (rev 6232)
@@ -17,7 +17,7 @@
  */
 
 /**
- * @file libavutil/x86/bswap.h
+ * @file
  * byte swapping routines
  */
 
@@ -25,14 +25,9 @@
 #define AVUTIL_X86_BSWAP_H
 
 #include &lt;stdint.h&gt;
-// MEANX
-#ifndef ADM_NO_CONFIG_H
 #include &quot;config.h&quot;
-#endif
-// MEANX
+#include &quot;libavutil/attributes.h&quot;
 
-#include &quot;libavutil/common.h&quot;
-
 #define bswap_16 bswap_16
 static av_always_inline av_const uint16_t bswap_16(uint16_t x)
 {

Copied: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/x86/intmath.h (from rev 6231, branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/adler32.h)
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/adler32.h	2010-05-26 05:26:02 UTC (rev 6231)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/x86/intmath.h	2010-05-26 05:26:23 UTC (rev 6232)
@@ -0,0 +1,35 @@
+/*
+ * Copyright (c) 2010 Mans Rullgard &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">mans at mansr.com</A>&gt;
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef AVUTIL_X86_INTMATH_H
+#define AVUTIL_X86_INTMATH_H
+
+#define FASTDIV(a,b) \
+    ({\
+        int ret, dmy;\
+        __asm__ volatile(\
+            &quot;mull %3&quot;\
+            :&quot;=d&quot;(ret), &quot;=a&quot;(dmy)\
+            :&quot;1&quot;(a), &quot;g&quot;(ff_inverse[b])\
+            );\
+        ret;\
+    })
+
+#endif /* AVUTIL_X86_INTMATH_H */

Added: branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/x86/intreadwrite.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/x86/intreadwrite.h	2010-05-26 05:26:02 UTC (rev 6231)
+++ branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavutil/x86/intreadwrite.h	2010-05-26 05:26:23 UTC (rev 6232)
@@ -0,0 +1,97 @@
+/*
+ * Copyright (c) 2010 Alexander Strange &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">astrange at ithinksw.com</A>&gt;
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef AVUTIL_X86_INTREADWRITE_H
+#define AVUTIL_X86_INTREADWRITE_H
+
+#include &lt;stdint.h&gt;
+#include &quot;config.h&quot;
+#include &quot;libavutil/attributes.h&quot;
+
+#if HAVE_MMX
+
+#if !HAVE_FAST_64BIT &amp;&amp; defined(__MMX__)
+
+#define AV_COPY64 AV_COPY64
+static av_always_inline void AV_COPY64(void *d, const void *s)
+{
+    __asm__(&quot;movq   %1, %%mm0  \n\t&quot;
+            &quot;movq   %%mm0, %0  \n\t&quot;
+            : &quot;=m&quot;(*(uint64_t*)d)
+            : &quot;m&quot; (*(const uint64_t*)s)
+            : &quot;mm0&quot;);
+}
+
+#define AV_SWAP64 AV_SWAP64
+static av_always_inline void AV_SWAP64(void *a, void *b)
+{
+    __asm__(&quot;movq   %1, %%mm0  \n\t&quot;
+            &quot;movq   %0, %%mm1  \n\t&quot;
+            &quot;movq   %%mm0, %0  \n\t&quot;
+            &quot;movq   %%mm1, %1  \n\t&quot;
+            : &quot;+m&quot;(*(uint64_t*)a), &quot;+m&quot;(*(uint64_t*)b)
+            ::&quot;mm0&quot;, &quot;mm1&quot;);
+}
+
+#define AV_ZERO64 AV_ZERO64
+static av_always_inline void AV_ZERO64(void *d)
+{
+    __asm__(&quot;pxor %%mm0, %%mm0  \n\t&quot;
+            &quot;movq %%mm0, %0     \n\t&quot;
+            : &quot;=m&quot;(*(uint64_t*)d)
+            :: &quot;mm0&quot;);
+}
+
+#endif /* !HAVE_FAST_64BIT &amp;&amp; defined(__MMX__) */
+
+#ifdef __SSE__
+
+#define AV_COPY128 AV_COPY128
+static av_always_inline void AV_COPY128(void *d, const void *s)
+{
+    struct v {uint64_t v[2];};
+
+    __asm__(&quot;movaps   %1, %%xmm0  \n\t&quot;
+            &quot;movaps   %%xmm0, %0  \n\t&quot;
+            : &quot;=m&quot;(*(struct v*)d)
+            : &quot;m&quot; (*(const struct v*)s)
+            : &quot;xmm0&quot;);
+}
+
+#endif /* __SSE__ */
+
+#ifdef __SSE2__
+
+#define AV_ZERO128 AV_ZERO128
+static av_always_inline void AV_ZERO128(void *d)
+{
+    struct v {uint64_t v[2];};
+
+    __asm__(&quot;pxor %%xmm0, %%xmm0  \n\t&quot;
+            &quot;movdqa   %%xmm0, %0  \n\t&quot;
+            : &quot;=m&quot;(*(struct v*)d)
+            :: &quot;xmm0&quot;);
+}
+
+#endif /* __SSE2__ */
+
+#endif /* HAVE_MMX */
+
+#endif /* AVUTIL_X86_INTREADWRITE_H */


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="003427.html">[Avidemux-svn-commit] r6229 - in	branches/avidemux_2.5_branch_gruntster: avidemux	plugins/ADM_audioEncoders plugins/ADM_audioEncoders/aften
</A></li>
	<LI>Next message: <A HREF="003429.html">[Avidemux-svn-commit] r6233 -	branches/avidemux_2.6_branch_mean/avidemux_core/ADM_ffmpeg/libavformat
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3428">[ date ]</a>
              <a href="thread.html#3428">[ thread ]</a>
              <a href="subject.html#3428">[ subject ]</a>
              <a href="author.html#3428">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">More information about the Avidemux-svn-commit
mailing list</a><br>
</body></html>
