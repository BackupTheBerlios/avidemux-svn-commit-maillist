<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Avidemux-svn-commit] r2705 - in	branches/avidemux_2.4_branch/avidemux:	ADM_userInterfaces/ADM_GTK/ADM_dialog	ADM_userInterfaces/ADM_NONE/ADM_dialog	ADM_userInterfaces/ADM_QT4/ADM_dialog ADM_video ADM_videoFilter
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/avidemux-svn-commit/2007-January/index.html" >
   <LINK REL="made" HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r2705%20-%20in%0A%09branches/avidemux_2.4_branch/avidemux%3A%0A%09ADM_userInterfaces/ADM_GTK/ADM_dialog%0A%09ADM_userInterfaces/ADM_NONE/ADM_dialog%0A%09ADM_userInterfaces/ADM_QT4/ADM_dialog%20ADM_video%20ADM_videoFilter&In-Reply-To=%3C200701112041.l0BKfKgj003752%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000032.html">
   <LINK REL="Next"  HREF="000034.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Avidemux-svn-commit] r2705 - in	branches/avidemux_2.4_branch/avidemux:	ADM_userInterfaces/ADM_GTK/ADM_dialog	ADM_userInterfaces/ADM_NONE/ADM_dialog	ADM_userInterfaces/ADM_QT4/ADM_dialog ADM_video ADM_videoFilter</H1>
    <B>mean at BerliOS</B> 
    <A HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r2705%20-%20in%0A%09branches/avidemux_2.4_branch/avidemux%3A%0A%09ADM_userInterfaces/ADM_GTK/ADM_dialog%0A%09ADM_userInterfaces/ADM_NONE/ADM_dialog%0A%09ADM_userInterfaces/ADM_QT4/ADM_dialog%20ADM_video%20ADM_videoFilter&In-Reply-To=%3C200701112041.l0BKfKgj003752%40sheep.berlios.de%3E"
       TITLE="[Avidemux-svn-commit] r2705 - in	branches/avidemux_2.4_branch/avidemux:	ADM_userInterfaces/ADM_GTK/ADM_dialog	ADM_userInterfaces/ADM_NONE/ADM_dialog	ADM_userInterfaces/ADM_QT4/ADM_dialog ADM_video ADM_videoFilter">mean at mail.berlios.de
       </A><BR>
    <I>Thu Jan 11 21:41:20 CET 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="000032.html">[Avidemux-svn-commit] r2704 - in	branches/avidemux_2.4_branch/avidemux:	ADM_userInterfaces/ADM_GTK/ADM_dialog	ADM_userInterfaces/ADM_GTK/ADM_dialogFactory	ADM_userInterfaces/ADM_NONE/ADM_dialog	ADM_userInterfaces/ADM_QT4/ADM_dialog ADM_video ADM_videoFilter
</A></li>
        <LI>Next message: <A HREF="000034.html">[Avidemux-svn-commit] r2706 -	branches/avidemux_2.4_branch/avidemux/ADM_codecs
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#33">[ date ]</a>
              <a href="thread.html#33">[ thread ]</a>
              <a href="subject.html#33">[ subject ]</a>
              <a href="author.html#33">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: mean
Date: 2007-01-11 21:41:19 +0100 (Thu, 11 Jan 2007)
New Revision: 2705

Added:
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidDenoise.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidDenoise.h
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidForcedPP.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidForcedPP.h
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidMSharpen.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidMSharpen_param.h
Removed:
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_dnr.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_msharpen.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidDenoise.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidDenoise.h
   branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidForcedPP.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidForcedPP.h
   branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidMSharpen.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidMSharpen_param.h
Modified:
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/Makefile.am
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_NONE/ADM_dialog/DIA_none.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/DIA_none.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_video/Makefile.am
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/Makefile.am
Log:
more dialogFactory

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_dnr.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_dnr.cpp	2007-01-11 19:18:08 UTC (rev 2704)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_dnr.cpp	2007-01-11 20:41:19 UTC (rev 2705)
@@ -1,211 +0,0 @@
-
-#include &lt;sys/types.h&gt;
-#include &lt;sys/stat.h&gt;
-#include &lt;unistd.h&gt;
-#include &lt;string.h&gt;
-#include &lt;stdio.h&gt;
-
-#include &lt;gdk/gdkkeysyms.h&gt;
-#include &lt;gtk/gtk.h&gt;
-
-
-#include &lt;gdk/gdkkeysyms.h&gt;
-#include &lt;gtk/gtk.h&gt;
-# include &lt;config.h&gt;
-
-#include &quot;default.h&quot;
-
-#include &quot;ADM_toolkit_gtk/ADM_gladeSupport.h&quot;
-#include &quot;ADM_toolkit_gtk/toolkit_gtk.h&quot;
-#include &quot;ADM_toolkit_gtk/toolkit_gtk_include.h&quot;
-
-
-static GtkWidget	*create_dialog1 (void);
-
-#define GETSPIN(x,y)  y= gtk_spin_button_get_value_as_int(GTK_SPIN_BUTTON(lookup_widget(dialog,#x)))
-#define SETSPIN(x,y)  gtk_spin_button_set_value(GTK_SPIN_BUTTON((lookup_widget(dialog,#x))),(gfloat)y)
-
-uint8_t DIA_dnr(uint32_t *llock,uint32_t *lthresh, uint32_t *clock,
-			uint32_t *cthresh, uint32_t *scene)
-{
-GtkWidget *dialog;
-
-	uint8_t ret=0;
-
-	dialog=create_dialog1();
-	gtk_register_dialog(dialog);
-	//gtk_transient(dialog);
-	SETSPIN(spin_lumalock,*llock);
-	SETSPIN(spin_lumathresh,*lthresh);
-	SETSPIN(spin_chromalock,*clock);
-	SETSPIN(spin_chromathresh,*cthresh);
-	SETSPIN(spin_scene,*scene);
-
-	ret=0;
-	if(gtk_dialog_run(GTK_DIALOG(dialog))==GTK_RESPONSE_OK)
-	{
-		GETSPIN(spin_lumalock,*llock);
-		GETSPIN(spin_lumathresh,*lthresh);
-		GETSPIN(spin_chromalock,*clock);
-		GETSPIN(spin_chromathresh,*cthresh);
-		GETSPIN(spin_scene,*scene);
-			ret=1;
-	}
-	gtk_unregister_dialog(dialog);
-	gtk_widget_destroy(dialog);
-
-	return ret;
-
-}
-
-GtkWidget*
-create_dialog1 (void)
-{
-  GtkWidget *dialog1;
-  GtkWidget *dialog_vbox1;
-  GtkWidget *table1;
-  GtkWidget *label1;
-  GtkWidget *label2;
-  GtkWidget *label3;
-  GtkWidget *label4;
-  GtkWidget *label5;
-  GtkObject *spin_lumalock_adj;
-  GtkWidget *spin_lumalock;
-  GtkObject *spin_lumathresh_adj;
-  GtkWidget *spin_lumathresh;
-  GtkObject *spin_chromalock_adj;
-  GtkWidget *spin_chromalock;
-  GtkObject *spin_chromathresh_adj;
-  GtkWidget *spin_chromathresh;
-  GtkObject *spin_scene_adj;
-  GtkWidget *spin_scene;
-  GtkWidget *dialog_action_area1;
-  GtkWidget *cancelbutton1;
-  GtkWidget *okbutton1;
-
-  dialog1 = gtk_dialog_new ();
-  gtk_window_set_title (GTK_WINDOW (dialog1), _(&quot;Dynamic Noise Reduction&quot;));
-
-  dialog_vbox1 = GTK_DIALOG (dialog1)-&gt;vbox;
-  gtk_widget_show (dialog_vbox1);
-
-  table1 = gtk_table_new (5, 2, FALSE);
-  gtk_widget_show (table1);
-  gtk_box_pack_start (GTK_BOX (dialog_vbox1), table1, TRUE, TRUE, 0);
-
-  label1 = gtk_label_new (_(&quot;Luma Lock&quot;));
-  gtk_widget_show (label1);
-  gtk_table_attach (GTK_TABLE (table1), label1, 0, 1, 0, 1,
-                    (GtkAttachOptions) (GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-  gtk_label_set_justify (GTK_LABEL (label1), GTK_JUSTIFY_LEFT);
-  gtk_misc_set_alignment (GTK_MISC (label1), 0, 0.5);
-
-  label2 = gtk_label_new (_(&quot;Luma Threshold&quot;));
-  gtk_widget_show (label2);
-  gtk_table_attach (GTK_TABLE (table1), label2, 0, 1, 1, 2,
-                    (GtkAttachOptions) (GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-  gtk_label_set_justify (GTK_LABEL (label2), GTK_JUSTIFY_LEFT);
-  gtk_misc_set_alignment (GTK_MISC (label2), 0, 0.5);
-
-  label3 = gtk_label_new (_(&quot;Chroma Lock&quot;));
-  gtk_widget_show (label3);
-  gtk_table_attach (GTK_TABLE (table1), label3, 0, 1, 2, 3,
-                    (GtkAttachOptions) (GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-  gtk_label_set_justify (GTK_LABEL (label3), GTK_JUSTIFY_LEFT);
-  gtk_misc_set_alignment (GTK_MISC (label3), 0, 0.5);
-
-  label4 = gtk_label_new (_(&quot;Chroma Threshold&quot;));
-  gtk_widget_show (label4);
-  gtk_table_attach (GTK_TABLE (table1), label4, 0, 1, 3, 4,
-                    (GtkAttachOptions) (GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-  gtk_label_set_justify (GTK_LABEL (label4), GTK_JUSTIFY_LEFT);
-  gtk_misc_set_alignment (GTK_MISC (label4), 0, 0.5);
-
-  label5 = gtk_label_new (_(&quot;Scene change detect&quot;));
-  gtk_widget_show (label5);
-  gtk_table_attach (GTK_TABLE (table1), label5, 0, 1, 4, 5,
-                    (GtkAttachOptions) (GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-  gtk_label_set_justify (GTK_LABEL (label5), GTK_JUSTIFY_LEFT);
-  gtk_misc_set_alignment (GTK_MISC (label5), 0, 0.5);
-
-  spin_lumalock_adj = gtk_adjustment_new (1, 0, 255, 1, 10, 10);
-  spin_lumalock = gtk_spin_button_new (GTK_ADJUSTMENT (spin_lumalock_adj), 1, 0);
-  gtk_widget_show (spin_lumalock);
-  gtk_table_attach (GTK_TABLE (table1), spin_lumalock, 1, 2, 0, 1,
-                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-  gtk_spin_button_set_numeric (GTK_SPIN_BUTTON (spin_lumalock), TRUE);
-
-  spin_lumathresh_adj = gtk_adjustment_new (1, 0, 255, 1, 10, 10);
-  spin_lumathresh = gtk_spin_button_new (GTK_ADJUSTMENT (spin_lumathresh_adj), 1, 0);
-  gtk_widget_show (spin_lumathresh);
-  gtk_table_attach (GTK_TABLE (table1), spin_lumathresh, 1, 2, 1, 2,
-                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-  gtk_spin_button_set_numeric (GTK_SPIN_BUTTON (spin_lumathresh), TRUE);
-
-  spin_chromalock_adj = gtk_adjustment_new (1, 0, 255, 1, 10, 10);
-  spin_chromalock = gtk_spin_button_new (GTK_ADJUSTMENT (spin_chromalock_adj), 1, 0);
-  gtk_widget_show (spin_chromalock);
-  gtk_table_attach (GTK_TABLE (table1), spin_chromalock, 1, 2, 2, 3,
-                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-  gtk_spin_button_set_numeric (GTK_SPIN_BUTTON (spin_chromalock), TRUE);
-
-  spin_chromathresh_adj = gtk_adjustment_new (1, 0, 255, 1, 10, 10);
-  spin_chromathresh = gtk_spin_button_new (GTK_ADJUSTMENT (spin_chromathresh_adj), 1, 0);
-  gtk_widget_show (spin_chromathresh);
-  gtk_table_attach (GTK_TABLE (table1), spin_chromathresh, 1, 2, 3, 4,
-                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-  gtk_spin_button_set_numeric (GTK_SPIN_BUTTON (spin_chromathresh), TRUE);
-
-  spin_scene_adj = gtk_adjustment_new (1, 0, 100, 1, 10, 10);
-  spin_scene = gtk_spin_button_new (GTK_ADJUSTMENT (spin_scene_adj), 1, 0);
-  gtk_widget_show (spin_scene);
-  gtk_table_attach (GTK_TABLE (table1), spin_scene, 1, 2, 4, 5,
-                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-  gtk_spin_button_set_numeric (GTK_SPIN_BUTTON (spin_scene), TRUE);
-
-  dialog_action_area1 = GTK_DIALOG (dialog1)-&gt;action_area;
-  gtk_widget_show (dialog_action_area1);
-  gtk_button_box_set_layout (GTK_BUTTON_BOX (dialog_action_area1), GTK_BUTTONBOX_END);
-
-  cancelbutton1 = gtk_button_new_from_stock (&quot;gtk-cancel&quot;);
-  gtk_widget_show (cancelbutton1);
-  gtk_dialog_add_action_widget (GTK_DIALOG (dialog1), cancelbutton1, GTK_RESPONSE_CANCEL);
-  GTK_WIDGET_SET_FLAGS (cancelbutton1, GTK_CAN_DEFAULT);
-
-  okbutton1 = gtk_button_new_from_stock (&quot;gtk-ok&quot;);
-  gtk_widget_show (okbutton1);
-  gtk_dialog_add_action_widget (GTK_DIALOG (dialog1), okbutton1, GTK_RESPONSE_OK);
-  GTK_WIDGET_SET_FLAGS (okbutton1, GTK_CAN_DEFAULT);
-
-  /* Store pointers to all widgets, for use by lookup_widget(). */
-  GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog1, &quot;dialog1&quot;);
-  GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog_vbox1, &quot;dialog_vbox1&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, table1, &quot;table1&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, label1, &quot;label1&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, label2, &quot;label2&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, label3, &quot;label3&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, label4, &quot;label4&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, label5, &quot;label5&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, spin_lumalock, &quot;spin_lumalock&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, spin_lumathresh, &quot;spin_lumathresh&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, spin_chromalock, &quot;spin_chromalock&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, spin_chromathresh, &quot;spin_chromathresh&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, spin_scene, &quot;spin_scene&quot;);
-  GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog_action_area1, &quot;dialog_action_area1&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, cancelbutton1, &quot;cancelbutton1&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, okbutton1, &quot;okbutton1&quot;);
-
-  return dialog1;
-}
-
-

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_msharpen.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_msharpen.cpp	2007-01-11 19:18:08 UTC (rev 2704)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_msharpen.cpp	2007-01-11 20:41:19 UTC (rev 2705)
@@ -1,202 +0,0 @@
-//
-// C++ Implementation: DIA_Msmooth
-//
-// Description: 
-//
-//
-// Author: mean &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>&gt;, (C) 2004
-//
-// Copyright: See COPYING file that comes with this distribution
-//
-//
-//
-// C++ Implementation: DIA_decimate
-//
-// Description: 
-//
-//
-// Author: mean &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>&gt;, (C) 2004
-//
-// Copyright: See COPYING file that comes with this distribution
-//
-//
-//
-// C++ Implementation: DIA_dectel
-//
-// Description: 
-//
-//
-// Author: mean &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>&gt;, (C) 2004
-//
-// Copyright: See COPYING file that comes with this distribution
-//
-//
-
-
-#include &lt;config.h&gt;
-
-
-#include &lt;string.h&gt;
-#include &lt;stdio.h&gt;
-
-#include &lt;gdk/gdkkeysyms.h&gt;
-#include &lt;gtk/gtk.h&gt;
-
-
-#include &lt;gdk/gdkkeysyms.h&gt;
-#include &lt;gtk/gtk.h&gt;
-# include &lt;math.h&gt;
-
-#include &quot;default.h&quot;
-#include &quot;ADM_toolkit_gtk/ADM_gladeSupport.h&quot;
-#include &quot;ADM_toolkit_gtk/toolkit_gtk.h&quot;
-#include &quot;ADM_toolkit_gtk/toolkit_gtk_include.h&quot;
-#include &quot;ADM_toolkit/toolkit.hxx&quot;
-#include &quot;default.h&quot;
-
-#include &quot;ADM_video/ADM_vidMSharpen_param.h&quot;
-static GtkWidget        *create_dialog1 (void);
-
-#define CHECK_GET(x,y) {param-&gt;y=gtk_toggle_button_get_active( GTK_TOGGLE_BUTTON(WID(x)));}
-#define CHECK_SET(x,y) {gtk_toggle_button_set_active( GTK_TOGGLE_BUTTON(WID(x)),param-&gt;y);}     
-uint8_t DIA_getMSharpen(MSHARPEN_PARAM *param);
-uint8_t DIA_getMSharpen(MSHARPEN_PARAM *param)
-{
-GtkWidget *dialog;
-int ret=0;
-        dialog=create_dialog1();
-        
-        // Update
-        
-        CHECK_SET(checkbuttonMask,mask);
-        CHECK_SET(checkbuttonHQ,highq);
-        
-        gtk_range_set_value (GTK_RANGE(WID(hscaleThresh)),(gdouble)param-&gt;threshold);
-        gtk_range_set_value (GTK_RANGE(WID(hscaleStrength)),(gdouble)param-&gt;strength);
-        
-        gtk_register_dialog(dialog);
-        if(gtk_dialog_run(GTK_DIALOG(dialog))==GTK_RESPONSE_OK)
-        {
-          GtkAdjustment *adj;   
-
-                adj=gtk_range_get_adjustment (GTK_RANGE(WID(hscaleThresh)));
-                param-&gt;threshold=(uint32_t)GTK_ADJUSTMENT(adj)-&gt;value;
-        
-                adj=gtk_range_get_adjustment (GTK_RANGE(WID(hscaleStrength)));
-                param-&gt;strength=(uint32_t)GTK_ADJUSTMENT(adj)-&gt;value;
-
-                CHECK_GET(checkbuttonHQ,highq);
-                CHECK_GET(checkbuttonMask,mask);
-               
-
-                ret=1;
-        
-        }
-        gtk_unregister_dialog(dialog);
-        gtk_widget_destroy(dialog);
-        return ret;
-
-}
-
-//__________________________________
-
-GtkWidget*
-create_dialog1 (void)
-{
-  GtkWidget *dialog1;
-  GtkWidget *dialog_vbox1;
-  GtkWidget *table1;
-  GtkWidget *checkbuttonMask;
-  GtkWidget *checkbuttonHQ;
-  GtkWidget *label1;
-  GtkWidget *label2;
-  GtkWidget *hscaleThresh;
-  GtkWidget *hscaleStrength;
-  GtkWidget *dialog_action_area1;
-  GtkWidget *cancelbutton1;
-  GtkWidget *okbutton1;
-
-  dialog1 = gtk_dialog_new ();
-  gtk_window_set_title (GTK_WINDOW (dialog1), _(&quot;Donal Graft MSharpen&quot;));
-
-  dialog_vbox1 = GTK_DIALOG (dialog1)-&gt;vbox;
-  gtk_widget_show (dialog_vbox1);
-
-  table1 = gtk_table_new (3, 2, FALSE);
-  gtk_widget_show (table1);
-  gtk_box_pack_start (GTK_BOX (dialog_vbox1), table1, TRUE, TRUE, 0);
-
-  checkbuttonMask = gtk_check_button_new_with_mnemonic (_(&quot;Show Mask&quot;));
-  gtk_widget_show (checkbuttonMask);
-  gtk_table_attach (GTK_TABLE (table1), checkbuttonMask, 1, 2, 0, 1,
-                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-
-  checkbuttonHQ = gtk_check_button_new_with_mnemonic (_(&quot;HighQ&quot;));
-  gtk_widget_show (checkbuttonHQ);
-  gtk_table_attach (GTK_TABLE (table1), checkbuttonHQ, 0, 1, 0, 1,
-                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-
-  label1 = gtk_label_new (_(&quot;Threshold&quot;));
-  gtk_widget_show (label1);
-  gtk_table_attach (GTK_TABLE (table1), label1, 0, 1, 1, 2,
-                    (GtkAttachOptions) (GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-  gtk_label_set_justify (GTK_LABEL (label1), GTK_JUSTIFY_LEFT);
-  gtk_misc_set_alignment (GTK_MISC (label1), 0, 0.5);
-
-  label2 = gtk_label_new (_(&quot;Strength&quot;));
-  gtk_widget_show (label2);
-  gtk_table_attach (GTK_TABLE (table1), label2, 0, 1, 2, 3,
-                    (GtkAttachOptions) (GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-  gtk_label_set_justify (GTK_LABEL (label2), GTK_JUSTIFY_LEFT);
-  gtk_misc_set_alignment (GTK_MISC (label2), 0, 0.5);
-
-  hscaleThresh = gtk_hscale_new (GTK_ADJUSTMENT (gtk_adjustment_new (1, 1, 255, 1, 1, 0)));
-  gtk_widget_show (hscaleThresh);
-  gtk_table_attach (GTK_TABLE (table1), hscaleThresh, 1, 2, 1, 2,
-                    (GtkAttachOptions) (GTK_FILL),
-                    (GtkAttachOptions) (GTK_FILL), 0, 0);
-  gtk_scale_set_digits (GTK_SCALE (hscaleThresh), 0);
-
-  hscaleStrength = gtk_hscale_new (GTK_ADJUSTMENT (gtk_adjustment_new (1, 1, 255, 1, 1, 0)));
-  gtk_widget_show (hscaleStrength);
-  gtk_table_attach (GTK_TABLE (table1), hscaleStrength, 1, 2, 2, 3,
-                    (GtkAttachOptions) (GTK_FILL),
-                    (GtkAttachOptions) (GTK_FILL), 0, 0);
-  gtk_scale_set_digits (GTK_SCALE (hscaleStrength), 0);
-
-  dialog_action_area1 = GTK_DIALOG (dialog1)-&gt;action_area;
-  gtk_widget_show (dialog_action_area1);
-  gtk_button_box_set_layout (GTK_BUTTON_BOX (dialog_action_area1), GTK_BUTTONBOX_END);
-
-  cancelbutton1 = gtk_button_new_from_stock (&quot;gtk-cancel&quot;);
-  gtk_widget_show (cancelbutton1);
-  gtk_dialog_add_action_widget (GTK_DIALOG (dialog1), cancelbutton1, GTK_RESPONSE_CANCEL);
-  GTK_WIDGET_SET_FLAGS (cancelbutton1, GTK_CAN_DEFAULT);
-
-  okbutton1 = gtk_button_new_from_stock (&quot;gtk-ok&quot;);
-  gtk_widget_show (okbutton1);
-  gtk_dialog_add_action_widget (GTK_DIALOG (dialog1), okbutton1, GTK_RESPONSE_OK);
-  GTK_WIDGET_SET_FLAGS (okbutton1, GTK_CAN_DEFAULT);
-
-  /* Store pointers to all widgets, for use by lookup_widget(). */
-  GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog1, &quot;dialog1&quot;);
-  GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog_vbox1, &quot;dialog_vbox1&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, table1, &quot;table1&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, checkbuttonMask, &quot;checkbuttonMask&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, checkbuttonHQ, &quot;checkbuttonHQ&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, label1, &quot;label1&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, label2, &quot;label2&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, hscaleThresh, &quot;hscaleThresh&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, hscaleStrength, &quot;hscaleStrength&quot;);
-  GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog_action_area1, &quot;dialog_action_area1&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, cancelbutton1, &quot;cancelbutton1&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, okbutton1, &quot;okbutton1&quot;);
-
-  return dialog1;
-}
-
-

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/Makefile.am
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/Makefile.am	2007-01-11 19:18:08 UTC (rev 2704)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/Makefile.am	2007-01-11 20:41:19 UTC (rev 2705)
@@ -10,7 +10,7 @@
 
 libADM_dialog_a_SOURCES = DIA_audio.cpp DIA_vcodec.cpp DIA_acodec.cpp \
 	DIA_audiocodec.cpp DIA_properties.cpp DIA_mjpeg.cpp DIA_about.cpp DIA_recent.cpp \
-	DIA_indexer.cpp DIA_resize.cpp DIA_dnr.cpp DIA_working.cpp \
+	DIA_indexer.cpp DIA_resize.cpp DIA_working.cpp \
 	DIA_working.h DIA_busy.cpp DIA_busy.h DIA_exLame.cpp DIA_pipe.cpp DIA_mpeg2opt.cpp \
 	DIA_d3d.cpp DIA_postproc.cpp DIA_enter.cpp DIA_enter.h DIA_xvcd.cpp DIA_muxer.cpp \
 	DIA_xvid.cpp DIA_crop.cpp DIA_color.cpp DIA_encoding.cpp DIA_SVCD.cpp DIA_prefs.cpp \
@@ -18,7 +18,7 @@
 	DIA_dectel.cpp DIA_decimate.cpp DIA_pause.cpp \
 	DIA_DVDff.cpp DIA_lavdecoder.cpp DIA_lame.cpp DIA_calculator.cpp DIA_equalizer.cpp \
 	DIA_vobsub.cpp DIA_x264.cpp DIA_ocr.cpp  DIA_hue.cpp DIA_eq2.cpp \
-	DIA_dgbob.cpp DIA_msharpen.cpp DIA_asharp.cpp DIA_dmx.cpp DIA_idx_pg.cpp DIA_gototime.cpp \
+	DIA_dgbob.cpp DIA_asharp.cpp DIA_dmx.cpp DIA_idx_pg.cpp DIA_gototime.cpp \
 	DIA_audioTrack.cpp DIA_cnr2.cpp DIA_resizeWiz.cpp DIA_jobs.cpp DIA_jobs_save.cpp DIA_mosaic.cpp \
 	DIA_deblend.cpp DIA_v2v.cpp DIA_tdeint.cpp DIA_builtin.cpp DIA_mpdelogo.cpp DIA_vorbis.cpp \
         DIA_chromaShift.cpp \
@@ -44,7 +44,7 @@
 DIA_DVDff.cpp        DIA_color.cpp         DIA_eq2.cpp          DIA_mosaic.cpp      DIA_resizeWiz.h \
 DIA_coloryuv.cpp      DIA_equalizer.cpp    DIA_mpdelogo.cpp    DIA_rotate.cpp \
 DIA_SVCD.cpp         DIA_contrast.cpp      DIA_exLame.cpp       DIA_mpeg2opt.cpp    DIA_srt.cpp \
-DIA_about.cpp        DIA_conv.cpp          DIA_msharpen.cpp    DIA_tdeint.cpp \
+DIA_about.cpp        DIA_conv.cpp          DIA_tdeint.cpp \
 DIA_acodec.cpp       DIA_crop.cpp          DIA_gototime.cpp     DIA_muxer.cpp       DIA_v2v.cpp \
 DIA_animated.cpp     DIA_d3d.cpp           DIA_hue.cpp          DIA_ocr.cpp         DIA_vcodec.cpp \
 DIA_asharp.cpp       DIA_deblend.cpp       DIA_idx_pg.cpp       DIA_partial.cpp     DIA_vobsub.cpp \
@@ -54,7 +54,7 @@
 DIA_jobs_save.cpp    DIA_prefs.cpp       DIA_x264.cpp \
 DIA_builtin.cpp      DIA_dgbob.cpp         DIA_preview.cpp     DIA_xvcd.cpp \
 DIA_busy.cpp         DIA_dmx.cpp           DIA_lame.cpp         DIA_properties.cpp  DIA_xvid.cpp \
-DIA_busy.h           DIA_dnr.cpp           DIA_lavcodec.cpp     DIA_quota.cpp       DIA_xvid4.cpp \
+DIA_busy.h           DIA_lavcodec.cpp     DIA_quota.cpp       DIA_xvid4.cpp \
 DIA_calculator.cpp   DIA_encoding.cpp      DIA_lavdecoder.cpp   DIA_recent.cpp \
 DIA_chromaShift.cpp  DIA_encoding.h        DIA_lavpp_deint.cpp  DIA_requant.cpp DIA_ass.cpp
 

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_NONE/ADM_dialog/DIA_none.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_NONE/ADM_dialog/DIA_none.cpp	2007-01-11 19:18:08 UTC (rev 2704)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_NONE/ADM_dialog/DIA_none.cpp	2007-01-11 20:41:19 UTC (rev 2705)
@@ -46,7 +46,6 @@
 #include &quot;ADM_audiofilter/audioencoder_lame_param.h&quot;
 #include &quot;ADM_encoder/adm_encmjpeg_param.h&quot;
 #include &quot;ADM_video/ADM_vidMosaic_param.h&quot;
-#include &quot;ADM_video/ADM_vidMSharpen_param.h&quot;
 #include &quot;ADM_video/ADM_vidMSmooth_param.h&quot;
 #include &quot;ADM_video/ADM_vidPartial_param.h&quot;
 #include &quot;ADM_video/ADM_vidTDeint_param.h&quot;
@@ -106,7 +105,6 @@
 uint8_t DIA_getHue(Hue_Param *param, ADMImage *image){return 0;}
 uint8_t DIA_getHue(Hue_Param *param, AVDMGenericVideoStream *in){return 0;}
 uint8_t DIA_getMPdelogo(MPDELOGO_PARAM *param,AVDMGenericVideoStream *in){return 0;}
-uint8_t DIA_getMSharpen(MSHARPEN_PARAM *param){return 0;}
 uint8_t DIA_getMSmooth(MSMOOTH_PARAM *param){return 0;}
 uint8_t DIA_getPartial(PARTIAL_CONFIG *param,AVDMGenericVideoStream *son,AVDMGenericVideoStream *previous){return 0;}
 uint8_t DIA_mjpegCodecSetting(COMPRES_PARAMS *param){return 0;}

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/DIA_none.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/DIA_none.cpp	2007-01-11 19:18:08 UTC (rev 2704)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/DIA_none.cpp	2007-01-11 20:41:19 UTC (rev 2705)
@@ -46,7 +46,6 @@
 #include &quot;ADM_audiofilter/audioencoder_lame_param.h&quot;
 #include &quot;ADM_encoder/adm_encmjpeg_param.h&quot;
 #include &quot;ADM_video/ADM_vidMosaic_param.h&quot;
-#include &quot;ADM_video/ADM_vidMSharpen_param.h&quot;
 #include &quot;ADM_video/ADM_vidMSmooth_param.h&quot;
 #include &quot;ADM_video/ADM_vidPartial_param.h&quot;
 #include &quot;ADM_video/ADM_vidTDeint_param.h&quot;
@@ -106,7 +105,6 @@
 uint8_t DIA_getHue(Hue_Param *param, ADMImage *image){return 0;}
 uint8_t DIA_getHue(Hue_Param *param, AVDMGenericVideoStream *in){return 0;}
 uint8_t DIA_getMPdelogo(MPDELOGO_PARAM *param,AVDMGenericVideoStream *in){return 0;}
-uint8_t DIA_getMSharpen(MSHARPEN_PARAM *param){return 0;}
 uint8_t DIA_getMSmooth(MSMOOTH_PARAM *param){return 0;}
 uint8_t DIA_getPartial(PARTIAL_CONFIG *param,AVDMGenericVideoStream *son,AVDMGenericVideoStream *previous){return 0;}
 uint8_t DIA_mjpegCodecSetting(COMPRES_PARAMS *param){return 0;}

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidDenoise.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidDenoise.cpp	2007-01-11 19:18:08 UTC (rev 2704)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidDenoise.cpp	2007-01-11 20:41:19 UTC (rev 2705)
@@ -1,394 +0,0 @@
-/***************************************************************************
-                          ADM_vidDenoise.cpp  -  description
-                             -------------------
-    begin                : Mon Nov 25 2002
-    copyright            : (C) 2002 by mean
-    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
-    
-    Denoiser inspired from DNR in transcode
-    Ported to YV12 and simplified
-    
-   Original code  Copyright (C) Gerhard Monzel - November 2001
- 
-    
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#include &lt;stdio.h&gt;
-#include &lt;stdlib.h&gt;
-#include &lt;string.h&gt;
-#include &lt;ADM_assert.h&gt;
-#include &lt;math.h&gt;
-
-#include &quot;config.h&quot;
-#include &quot;fourcc.h&quot;
-#include &quot;avio.hxx&quot;
-#include &quot;config.h&quot;
-#include &quot;avi_vars.h&quot;
-
-
-#include &quot;ADM_toolkit/toolkit.hxx&quot;
-#include &quot;ADM_editor/ADM_edit.hxx&quot;
-#include &quot;ADM_video/ADM_genvideo.hxx&quot;
-#include &quot;ADM_video/ADM_vidDenoise.h&quot;
-#include &quot;ADM_filter/video_filters.h&quot;
-
-
-static FILTER_PARAM denoiseParam={5,{&quot;lumaLock&quot;,&quot;lumaThreshold&quot;,&quot;chromaLock&quot;,&quot;chromaThreshold&quot;,
-					&quot;sceneChange&quot;}};
-
-
-SCRIPT_CREATE(denoise_script,ADMVideoDenoise,denoiseParam);
-
-uint8_t distMatrix[256][256];
-uint32_t fixMul[16];
-
-//static uint8_t matrixReady=0;
-//static uint8_t doOnePix(uint8_t *in,uint8_t *out,uint8_t *lock,uint8_t *nb);
-
-BUILD_CREATE(denoise_create,ADMVideoDenoise);
-char *ADMVideoDenoise::printConf( void )
-{
- 	static char buf[50];
-
-  ADM_assert(_param); 	
- 	sprintf((char *)buf,&quot; Denoise : Lum :%02ld/:%02ld / Chm :%02ld/%02ld&quot;,
-  								_param-&gt;lumaLock,
-          				_param-&gt;lumaThreshold,
-              		_param-&gt;chromaLock,
-                	_param-&gt;chromaThreshold);
-        return buf;
-}
-void buildDistMatrix( void );
-void buildDistMatrix( void )
-{
-int d;	
-	for(uint32_t y=255;y&gt;0;y--)
-	for(uint32_t x=255;x&gt;0;x--)
-	{
-		  d=x-y;
-		  if(d&lt;0) d=-d;
-		  distMatrix[x][y]=d;
-		
-	}
-
-	 for(int i=1;i&lt;16;i++)
-                        {
-                                        fixMul[i]=(1&lt;&lt;16)/i;
-                        }
-
-}
-
-//_______________________________________________________________
-
-ADMVideoDenoise::ADMVideoDenoise(
-									AVDMGenericVideoStream *in,CONFcouple *couples)
-{
-
-
-  	_in=in;		
-   	memcpy(&amp;_info,_in-&gt;getInfo(),sizeof(_info));  			 	
-    uint32_t page;
-    
-  _info.encoding=1;
-  
-  page= _in-&gt;getInfo()-&gt;width*_in-&gt;getInfo()-&gt;height;
-  
-//  _uncompressed=new uint8_t [page];
-  _uncompressed=new ADMImage(_in-&gt;getInfo()-&gt;width,_in-&gt;getInfo()-&gt;height);
-  ADM_assert(_uncompressed);
-  
- // _locked=new uint8_t [page];
-  _locked=new ADMImage(_in-&gt;getInfo()-&gt;width,_in-&gt;getInfo()-&gt;height);
-  ADM_assert(_locked);
- 
-//	_lockcount=new uint8_t [page];
-
-
-  
-   _lockcount=new ADMImage(_in-&gt;getInfo()-&gt;width,_in-&gt;getInfo()-&gt;height);
-  memset(YPLANE(_lockcount),0,page);  
-  memset(UPLANE(_lockcount),0,page&gt;&gt;2);  
-  memset(VPLANE(_lockcount),0,page&gt;&gt;2);  
-        
-  _param=NULL;
-  
-  if(couples)
-  	{
-			_param=NEW(NOISE_PARAM);
-			GET(lumaLock);
-			GET(lumaThreshold);
-			GET(chromaLock);
-			GET(chromaThreshold);
-			GET(sceneChange);
-		 }
-	else
-		{
-			  #define XXX 1
-			  _param=NEW(NOISE_PARAM);
-			  _param-&gt;lumaLock=  4*XXX;
-			  _param-&gt;lumaThreshold= 10*XXX;
-			  _param-&gt;chromaLock=  8*XXX;
-			  _param-&gt;chromaThreshold= 16*XXX;
-        _param-&gt;sceneChange=  30*XXX;
-			}
-  	  _lastFrame=0xfffffff0;	
-}
-
-
-uint8_t	ADMVideoDenoise::getCoupledConf( CONFcouple **couples)
-{
-
-			ADM_assert(_param);
-			*couples=new CONFcouple(5);
-
-#define CSET(x)  (*couples)-&gt;setCouple((char *)#x,(_param-&gt;x))
-	CSET(lumaLock);
-	CSET(lumaThreshold);
-	CSET(chromaLock);
-	CSET(chromaThreshold);
-	CSET(sceneChange);
-
-	return 1;
-
-}
-ADMVideoDenoise::~ADMVideoDenoise()
-{
- 	
-	delete  _uncompressed;
- 	delete  _locked;
-  	delete  _lockcount;
-  DELETE(_param);
-  
-  _uncompressed=_locked=_lockcount=NULL;
-}
-
-//
-//	Remove y and v just keep U and expand it
-//
-uint8_t ADMVideoDenoise::getFrameNumberNoAlloc(uint32_t frame,
-				uint32_t *len,
-   				ADMImage *data,
-				uint32_t *flags)
-{
-   //uint32_t x,w;
-  	uint32_t page; 
-   		ADM_assert(_param);
-		ADM_assert(frame&lt;_info.nb_frames);
-								
-			
-       		if(!_in-&gt;getFrameNumberNoAlloc(frame, len,_uncompressed,flags)) return 0;
-
-		
-		page=_info.width*_info.height;  
-		*len=(page*3)&gt;&gt;1;           
-
-	if((_lastFrame+1)!=frame) // async jump
-	{
-			// just copy it 
-			memcpy(YPLANE(data),YPLANE(_uncompressed),page);
-			memcpy(UPLANE(data),UPLANE(_uncompressed),page&gt;&gt;2);
-			memcpy(VPLANE(data),VPLANE(_uncompressed),page&gt;&gt;2);
-			
-			memcpy(YPLANE(_locked),YPLANE(_uncompressed),page);
-			memcpy(UPLANE(_locked),UPLANE(_uncompressed),page&gt;&gt;2);
-			memcpy(VPLANE(_locked),VPLANE(_uncompressed),page&gt;&gt;2);
-			
-			_lastFrame=frame;
-			return 1;
-	}          
-	_lastFrame=frame;
-          
-          // copy chroma for now
-        
-         
-          
-          //
-          //uint32_t count=0;
-          //uint32_t cell=page*4; // size of luma
-          uint8_t *in,*out,*lock,*nb;
-          uint8_t *uin,*uout,*ulock,*unb;
-          uint8_t *vin,*vout,*vlock,*vnb;
-          
-          
-          //uint32_t d;
-          // init all
-          
-          // luma
-          nb=YPLANE(_lockcount);
-          lock=YPLANE(_locked);
-          in=YPLANE(_uncompressed);
-          out=YPLANE(data);
-          // u
-          unb=UPLANE(_lockcount);
-          ulock=UPLANE(_locked);
-          uin=UPLANE(_uncompressed);
-          uout=UPLANE(data);
-          // v
-          vnb=VPLANE(_lockcount);
-          vlock=VPLANE(_locked);
-          vin=VPLANE(_uncompressed);
-          vout=VPLANE(data);
-          
-          
-          uint32_t xx,yy/*,dl*/,du,dv;
-          uint32_t locked=0;
-          for(yy=_info.height&gt;&gt;1;yy&gt;0;yy--)
-          {
-	          for(xx=_info.width&gt;&gt;1;xx&gt;0;xx--)          
-  	        {
-			du=distMatrix[*uin][*ulock];	
-			dv=distMatrix[*vin][*vlock];		
-						
-			// if chroma is locked , we try to lock luma
-			if( (du&lt;_param-&gt;chromaLock)
-				 &amp;&amp; (dv&lt;_param-&gt;chromaLock))
-			 {  
-				*uout=*ulock;
- 				*vout=*vlock;
-
-#define PIX(z) 		doOnePix(in+z,out+z,lock+z,nb+z) 
-				locked+=PIX(0)+	PIX(1)+ PIX(_info.width)+PIX(_info.width+1);
-			}
-			else
-			 // if chroma is blended, we blend luma
-#undef PIX								  
-#define PIX(z) 		doBlend(in+z,out+z,lock+z,nb+z)									 
-				if( (du&lt;_param-&gt;chromaThreshold)
-					 &amp;&amp; (dv&lt;_param-&gt;chromaThreshold))
-				{
-			 		PIX(0);
-				    	PIX(1);
-				     	PIX(_info.width);
-				     	PIX(_info.width+1);	
-				      *uout=*ulock=(*uin+*uin)&gt;&gt;1;
- 					*vout=*vlock=(*vin+*vin)&gt;&gt;1;
-				}
-#undef PIX											
-										
-			else
-			{
-#define PIX(z) *(out+z)=*(lock+z)=*(in+z);*(nb+z)=0			
-											
-				PIX(0);
-				PIX(1);
-				PIX(_info.width);
-				PIX(_info.width+1);		
-				*uout=*ulock=*uin;
- 				*vout=*vlock=*vin;
-				
-#undef PIX		
-			}
-								  
-											                        				                        
-			uin++;uout++;ulock++;unb++;   
-			vin++;vout++;vlock++;vnb++;   
-			in++;out++;lock++;nb++;   
-			in++;out++;lock++;nb++;   
-							
-		}
-            // 
-            in+=_info.width;
-            out+=_info.width;
-            lock+=_info.width;
-            nb+=_info.width;            						
-	};
-          
-          if(locked&gt;((page*3)&gt;&gt;2)) // if more than 75% pixel not locked -&gt; scene change
-          {
-			memcpy(YPLANE(data),YPLANE(_uncompressed),page);
-			memcpy(UPLANE(data),UPLANE(_uncompressed),page&gt;&gt;2);
-			memcpy(VPLANE(data),VPLANE(_uncompressed),page&gt;&gt;2);
-			
-			memcpy(YPLANE(_locked),YPLANE(_uncompressed),page);
-			memcpy(UPLANE(_locked),UPLANE(_uncompressed),page&gt;&gt;2);
-			memcpy(VPLANE(_locked),VPLANE(_uncompressed),page&gt;&gt;2);
-	}
-      data-&gt;copyInfo(_uncompressed);  
-      return 1;
-}
-
-//
-//	0 copy
-//  1 lock
-//  2 threshold
-//
-uint8_t ADMVideoDenoise::doOnePix(uint8_t *in,uint8_t *out,uint8_t *lock,uint8_t *nb)
-{
-unsigned int d;
-		d=distMatrix[*(in)][*(lock)]; 
-		if(d&lt;_param-&gt;lumaLock)         
-		{								                
-			if(*(nb)&gt;30)  // out of scope -&gt; copy new                   
-			{  	// too much copy -&gt;                              
-				*(nb)=0;                       
-				*(out)=(*(in)+*(lock))&gt;&gt;1;
-				*(lock)=*(out);    	
-				return DN_COPY;      
-			}                                 
-			else                               
-			{                                   
-				*(out)=*(lock);		
-				*nb += 1; // *(nb)++;	
-				return DN_LOCK;		
-			}                  
-		}                     
-		else if(d&lt; _param-&gt;lumaThreshold) 
-			{                                  
-				 *(nb)=0;                           
-				*(out)=(*(in)+*(lock))&gt;&gt;1;	
-				return DN_BLEND;
-			}
-			else   // too big delta
-			{    
-				 *(nb)=0; 
-				*(out)=*(in);	  
-				*(lock)=*(in);    
-				return DN_COPY;
-			}                     
-					                           
-			ADM_assert(0);
-			return 0;
-
-}
-uint8_t ADMVideoDenoise::doBlend(uint8_t *in,uint8_t *out,uint8_t *lock,uint8_t *nb)
-{
-unsigned int d;
-		   d=distMatrix[*(in)][*(lock)]; 
-		   *nb=0;
-		   
-			if(d&lt;_param-&gt;lumaThreshold)         
-			{
-					*(out)=(*(in)+*(lock))&gt;&gt;1;					
-			}
-			else
-			*out=*in;
-			return 0;
-	
-}
-extern uint8_t DIA_dnr(uint32_t *llock,uint32_t *lthresh, uint32_t *clock,
-			uint32_t *cthresh, uint32_t *scene);
-
-
-uint8_t ADMVideoDenoise::configure(AVDMGenericVideoStream * instream)
-{
-  UNUSED_ARG(instream);
-
-    if(DIA_dnr(	&amp;(_param-&gt;lumaThreshold),
-    				&amp;(_param-&gt;lumaLock),
-				&amp;(_param-&gt;chromaThreshold),
-				&amp;(_param-&gt;chromaLock),
-				&amp;(_param-&gt;sceneChange)
-               						)) return 1;
-
-	return 0;
-}
-
-// EOF

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidDenoise.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidDenoise.h	2007-01-11 19:18:08 UTC (rev 2704)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidDenoise.h	2007-01-11 20:41:19 UTC (rev 2705)
@@ -1,55 +0,0 @@
-/***************************************************************************
-                          ADM_vidDenoise.h  -  description
-                             -------------------
-    begin                : Mon Nov 25 2002
-    copyright            : (C) 2002 by mean
-    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
- #define DN_COPY 3
- #define DN_LOCK 0
- #define DN_BLEND 1
-  
- typedef struct
- {
-	  uint32_t lumaThreshold,lumaLock;
-	  uint32_t chromaThreshold,chromaLock;
-	  uint32_t sceneChange;
-	}NOISE_PARAM;
- 
-  class  ADMVideoDenoise:public AVDMGenericVideoStream
- {
-
- protected:
-
-      					ADMImage	*_locked;
-        				ADMImage	*_lockcount;
-   			virtual 	char 		*printConf(void);
-        				NOISE_PARAM	*_param;
-        				uint32_t	_lastFrame;
-        				uint8_t 	doOnePix(uint8_t *in,uint8_t *out,
-        							uint8_t *lock,uint8_t *nb);
-         				uint8_t 	doBlend(uint8_t *in,uint8_t *out,
-        							uint8_t *lock,uint8_t *nb);
-
- public:
-
-
-							ADMVideoDenoise(  AVDMGenericVideoStream *in,CONFcouple *setup);
-  			virtual 			~ADMVideoDenoise();
-		        virtual uint8_t 		getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
-          								ADMImage *data,uint32_t *flags);
-			virtual uint8_t 		configure( AVDMGenericVideoStream *instream) ;
-
-			virtual uint8_t			getCoupledConf( CONFcouple **couples);
- }     ;
-

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidForcedPP.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidForcedPP.cpp	2007-01-11 19:18:08 UTC (rev 2704)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidForcedPP.cpp	2007-01-11 20:41:19 UTC (rev 2705)
@@ -1,213 +0,0 @@
-//
-// C++ Implementation: ADM_vidForcedPP
-//
-// Description: 
-//
-//	Force postprocessing assuming constant quant &amp; image type
-//	Uselefull on some badly authored DVD for example
-//
-// Author: mean &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>&gt;, (C) 2004
-//
-// Copyright: See COPYING file that comes with this distribution
-//
-//
-
-#include &lt;stdio.h&gt;
-#include &lt;stdlib.h&gt;
-#include &lt;string.h&gt;
-#include &lt;ADM_assert.h&gt;
-#include &lt;math.h&gt;
-#include &lt;math.h&gt;
-#include &lt;iconv.h&gt;
-#include &quot;config.h&quot;
-
-
-#include &quot;fourcc.h&quot;
-#include &quot;avio.hxx&quot;
-
-#include &quot;avi_vars.h&quot;
-
-#include &quot;ADM_toolkit/toolkit.hxx&quot;
-#include &quot;ADM_editor/ADM_edit.hxx&quot;
-#include &quot;ADM_video/ADM_genvideo.hxx&quot;
-
-#include &quot;ADM_osSupport/ADM_debugID.h&quot;
-#define MODULE_NAME MODULE_FILTER
-#include &quot;ADM_osSupport/ADM_debug.h&quot;
-
-
-
-#include &quot;ADM_vidForcedPP.h&quot;
-#include &quot;DIA_enter.h&quot;
-#include &quot;ADM_filter/video_filters.h&quot;
-
-
-static FILTER_PARAM ppParam={3,{&quot;postProcType&quot;,&quot;postProcStrength&quot;,&quot;forcedQuant&quot;}};
-
-
-SCRIPT_CREATE(forcedpp_script,ADMVideoForcedPP,ppParam);
-BUILD_CREATE(forcedpp_create,ADMVideoForcedPP);
-
-extern int DIA_getMPParams( uint32_t *pplevel, uint32_t *ppstrength,uint32_t *swap);
-
-uint8_t ADMVideoForcedPP::configure( AVDMGenericVideoStream *instream)
-{
-	_in=instream;
-	uint32_t postproc, strength,uv;
-	int forced;
-		postproc=_param-&gt;postProcType;
-		strength=_param-&gt;postProcStrength;
-		forced=_param-&gt;forcedQuant;
-		uv=0;
-		if( DIA_getMPParams( &amp;postproc,&amp;strength,&amp;uv))
-		{
-
-				if( DIA_GetIntegerValue(&amp;forced,2,31, &quot;Quant Value&quot;,&quot;Enter forced Q:&quot;))
-				{
-					_param-&gt;postProcType=postproc;
-					_param-&gt;postProcStrength=strength;
-					_param-&gt;forcedQuant=forced;
-					updatePostProc(&amp;_postproc );				
-					return 1;
-				}
-		}
-	return 0;	
- 	
-}
-uint8_t	ADMVideoForcedPP::getCoupledConf( CONFcouple **couples)
-{
-
-			*couples=new CONFcouple(3);
-
-			CSET(postProcType);
-			CSET(postProcStrength);
-			CSET(forcedQuant);
-
-		return 1;	
-}
-char *ADMVideoForcedPP::printConf( void )
-{
- 	static char buf[50];
- 	
- 	sprintf((char *)buf,&quot; Forced pp : %lu %lu&quot;,_param-&gt;postProcType,_param-&gt;postProcStrength);
-        return buf;
-}
-
-ADMVideoForcedPP::~ADMVideoForcedPP()
-{
-	if(_uncompressed)
- 		delete _uncompressed;
-	if(_postproc.ppContext)
-		deletePostProc(&amp;_postproc);
-
- 	_uncompressed=NULL;
-}
-
-
- ADMVideoForcedPP::ADMVideoForcedPP( AVDMGenericVideoStream *in,CONFcouple *couples)
-{
-		printf(&quot;Adding forced PP filter\n&quot;);
-		_uncompressed=NULL;
-		_in=in;
-		ADM_assert(in);
-		if(!couples)
-		{
-			
-			_param=NEW(PP_CONF);
-	    		_param-&gt;postProcType=5; // Bff=0 / 1=tff
-	    		_param-&gt;postProcStrength=5;
-			_param-&gt;forcedQuant=10;
-			
-	    	}
-		else
-		{
-			_param=NEW(PP_CONF);
-			GET(postProcType);
-			GET(postProcStrength);
-			GET(forcedQuant);
-			
-						
-		}
-		ADM_assert(in);
-		
-		memcpy(&amp;_info,_in-&gt;getInfo(),sizeof(_info));	
-		
-	    	initPostProc(&amp;_postproc,_info.width,_info.height);
-		_postproc.postProcType=_param-&gt;postProcType;
-		_postproc.postProcStrength=_param-&gt;postProcStrength;
-		_postproc.forcedQuant=_param-&gt;forcedQuant;
-		updatePostProc(&amp;_postproc);	    	
-	    	
-	    	//_uncompressed=new uint8_t[3*_info.width*_info.height];	
-		_uncompressed=new ADMImage(_info.width,_info.height);	
-		
-
-}
-uint8_t ADMVideoForcedPP::getFrameNumberNoAlloc(uint32_t frame,
-							uint32_t *len,
-							ADMImage *data,
-							uint32_t *flags)
-{
-		uint32_t page=_info.width*_info.height;
-		
-		*len=(page*3)&gt;&gt;1;
-		if(frame&gt;=_info.nb_frames) return 0;		
-		
-		if(!(_postproc.postProcType &amp;&amp; _postproc.postProcStrength) )
-		{
-			// disabled
-			if(!_in-&gt;getFrameNumberNoAlloc(frame, len,data,flags)) return 0;
-				
-			return 1;
-		
-		}
-			// we do postproc !
-			// keep
-			uint8_t *iBuff[3],*oBuff[3];
-			int strideTab[3],strideTab2[3];			
-				
-				
-			if(!_in-&gt;getFrameNumberNoAlloc(frame, len,_uncompressed,flags))
-			 		return 0;
-
-			oBuff[0]=YPLANE(data);
-                        oBuff[1]=VPLANE(data);
-                        oBuff[2]=UPLANE(data);
-
-				
-			iBuff[0]=YPLANE(_uncompressed);
-		 	iBuff[1]=VPLANE(_uncompressed);
- 		 	iBuff[2]=UPLANE(_uncompressed);
-				
-				
-		        strideTab[0]=strideTab2[0]=_info.width;
-			strideTab[1]=strideTab2[1]=_info.width&gt;&gt;1;
-			strideTab[2]=strideTab2[2]=_info.width&gt;&gt;1;
-	
-			int type;
-			if(_uncompressed-&gt;flags&amp;AVI_KEY_FRAME)
-					type=1;
-			else if(_uncompressed-&gt;flags &amp; AVI_B_FRAME)
-					type=3;
-				else
-					type=2;
-		 	pp_postprocess(
-		      		iBuff,
-		        	strideTab,
-		        	oBuff,
-		        	strideTab2,
-				_info.width,
-		        	_info.height,
-		        	NULL,
-		          	0,
-		         	_postproc.ppMode,
-		          	_postproc.ppContext,
-		          	type); // I ?
-			  	
-			
-		
-			data-&gt;copyInfo(_uncompressed);	
-			//printf(&quot;Type:%d\n&quot;,type);
-	return 1;
-}
-

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidForcedPP.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidForcedPP.h	2007-01-11 19:18:08 UTC (rev 2704)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidForcedPP.h	2007-01-11 20:41:19 UTC (rev 2705)
@@ -1,44 +0,0 @@
-//
-// C++ Interface: ADM_vidForcedPP
-//
-// Description: 
-//
-//
-// Author: mean &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>&gt;, (C) 2004
-//
-// Copyright: See COPYING file that comes with this distribution
-//
-//
-
-#ifndef ADM_FORCEDPP
-#define ADM_FORCEDPP
-#include &quot;ADM_pp.h&quot;
-
-typedef struct  PP_CONF
-{
-	uint32_t			postProcType;
-	uint32_t			postProcStrength;
-	uint32_t			forcedQuant;
-}PP_CONF;
-
-class  ADMVideoForcedPP:public AVDMGenericVideoStream
- {
-
- protected:
-        virtual char 		*printConf(void) ;
-	PP_CONF			*_param;
-	ADM_PP			_postproc;
-           
-
- public:
- 		
-  			ADMVideoForcedPP(  AVDMGenericVideoStream *in,CONFcouple *setup);
-  			~ADMVideoForcedPP();
-	virtual uint8_t getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
-						ADMImage *data,uint32_t *flags);
-	virtual uint8_t	getCoupledConf( CONFcouple **couples)		;
-	virtual uint8_t configure( AVDMGenericVideoStream *instream);
-							
-};
-
-#endif

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidMSharpen.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidMSharpen.cpp	2007-01-11 19:18:08 UTC (rev 2704)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidMSharpen.cpp	2007-01-11 20:41:19 UTC (rev 2705)
@@ -1,779 +0,0 @@
-/***************************************************************************
-                          ADM_vidMSharpen  -  description
-                             -------------------
-    
-    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
-
-    Port of Donal Graft Msharpen which is (c) Donald Graft
-    <A HREF="http://www.neuron2.net">http://www.neuron2.net</A>
-    <A HREF="http://puschpull.org/avisynth/decomb_reference_manual.html">http://puschpull.org/avisynth/decomb_reference_manual.html</A>
-
-        It is a bit less efficient as we do hz &amp; vz blur separately
-        The formula has been changed a bit from 1 1 1 to 1 2 1
-        for speed aspect &amp; MMX  
-        Mean
-
- ***************************************************************************/
-/*
-	Msharpen plugin for Avisynth -- performs detail-preserving smoothing.
-
-	Copyright (C) 2003 Donald A. Graft
-
-	This program is free software; you can redistribute it and/or modify
-	it under the terms of the GNU General Public License as published by
-	the Free Software Foundation.
-
-	This program is distributed in the hope that it will be useful,
-	but WITHOUT ANY WARRANTY; without even the implied warranty of
-	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-	GNU General Public License for more details.
-
-	You should have received a copy of the GNU General Public License
-	along with this program; if not, write to the Free Software
-	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
-*/
-
-#include &quot;config.h&quot;
-#include &lt;stdio.h&gt;
-#include &lt;stdlib.h&gt;
-#include &lt;string.h&gt;
-#include &lt;ADM_assert.h&gt;
-
-#include &quot;config.h&quot;
-#include &quot;fourcc.h&quot;
-#include &quot;avio.hxx&quot;
-#include &quot;avi_vars.h&quot;
-
-#include &quot;ADM_toolkit/toolkit.hxx&quot;
-#include &quot;ADM_editor/ADM_edit.hxx&quot;
-#include &quot;ADM_video/ADM_genvideo.hxx&quot;
-#include&quot;ADM_video/ADM_vidField.h&quot;
-#include&quot;ADM_video/ADM_cache.h&quot;
-
-#include &quot;ADM_osSupport/ADM_debugID.h&quot;
-#define MODULE_NAME MODULE_FILTER
-#include &quot;ADM_osSupport/ADM_debug.h&quot;
-
-#include &quot;ADM_osSupport/ADM_cpuCap.h&quot;
-#include &quot;ADM_filter/video_filters.h&quot;
-
-#include &quot;ADM_video/ADM_vidMSharpen_param.h&quot;
-
-class Msharpen : public AVDMGenericVideoStream
-{
-private:
-	MSHARPEN_PARAM	*_param;
-	VideoCache	*vidCache;
-        ADMImage        *blurrImg,*work;
-
-        uint32_t        invstrength;
-
-        void detect_edges(ADMImage *src, ADMImage *dst, unsigned char *dstp, int plane);
-        void blur_plane(ADMImage *src, ADMImage *blur, unsigned char *blurp, int plane) ;
-        void detect_edges_HiQ(ADMImage *src, ADMImage *dst, unsigned char *dstp, int plane);
-        void apply_filter(ADMImage *src,ADMImage *blur, ADMImage *dst, unsigned char *dstp, int plane) ;
-public:    
-
-			Msharpen(AVDMGenericVideoStream *in,CONFcouple *couples)   ;
-			~Msharpen();
-
-
-				 
-	char 		*printConf( void );
-	uint8_t 	configure(AVDMGenericVideoStream *in);
-	uint8_t		getCoupledConf( CONFcouple **couples);
-	uint8_t 	getFrameNumberNoAlloc(uint32_t frame, uint32_t *len, ADMImage *data,uint32_t *flags);
-};
-
-BUILD_CREATE(msharpen_create,Msharpen);
-static FILTER_PARAM msharpenParam={4,{&quot;mask&quot;, &quot;highq&quot;,&quot;threshold&quot;, &quot;strength&quot;}};
-
-
-SCRIPT_CREATE(msharpen_script,Msharpen,msharpenParam);
-//_______________________________________________
-
-Msharpen::Msharpen(AVDMGenericVideoStream *in,CONFcouple *couples)
-
-{
-	_in=in;		
-   	memcpy(&amp;_info,_in-&gt;getInfo(),sizeof(_info));    
-  	_info.encoding=1;
-	_uncompressed=NULL;		
-  	_info.encoding=1;
-
-
-	_param=new MSHARPEN_PARAM;
-	//
-	if(couples)
-		{
-			GET(mask);
-			GET(highq);
-			GET(strength);	
-			GET(threshold);	
-		}
-		else // Default
-  		{
-			_param-&gt;mask=0;       // Show mask
-			_param-&gt;highq=1;
-			_param-&gt;strength=100;	
-			_param-&gt;threshold=15;	
-		}
-                
-		invstrength=255-_param-&gt;strength;	
-		blurrImg=new ADMImage(_info.width,_info.height);
-                work=new ADMImage(_info.width,_info.height);
-    		vidCache=new VideoCache(5,in);
-}
-//________________________________________________________
-uint8_t	Msharpen::getCoupledConf( CONFcouple **couples)
-{
-	*couples=NULL;
-	*couples=new CONFcouple(4);
-#define CSET(x)  (*couples)-&gt;setCouple((char *)#x,(_param-&gt;x))
-		CSET(mask);
-		CSET(highq);
-		CSET(strength);	
-		CSET(threshold);	
-	return 1;
-}
-//________________________________________________________
-Msharpen::~Msharpen(void)
-{
-
-	if(vidCache) delete vidCache;
-	if(_param) delete _param;
-	if(blurrImg) delete blurrImg;
-        if(work) delete work;
-	vidCache=NULL;
-	_param=NULL;
-	blurrImg=NULL;
-        work=NULL;
-}
-extern uint8_t DIA_getMSharpen(MSHARPEN_PARAM *param);
-//________________________________________________________
-uint8_t Msharpen::configure(AVDMGenericVideoStream *in)
-{
-uint8_t r=0;
-	_in=in;
-	ADM_assert(_param);
-	if(r= DIA_getMSharpen(_param))
-        invstrength=255-_param-&gt;strength;       
-	return r;
-}
-
-//________________________________________________________
-char *Msharpen::printConf( void )
-{
- 	static char buf[50];
-
-	ADM_assert(_param);
- 	sprintf((char *)buf,&quot; Donald Graft Msharpen Strength:%d Threshold:%d&quot;,_param-&gt;strength,_param-&gt;threshold);
-        return buf;
-}
-	
-//________________________________________________________
-uint8_t Msharpen::getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
-				ADMImage *data,uint32_t *flags)
-{
-ADMImage *src,*blur,*dst;
-/*
-	PVideoFrame src = child-&gt;GetFrame(n, env);
-	PVideoFrame blur = env-&gt;NewVideoFrame(vi);
-	PVideoFrame dst = env-&gt;NewVideoFrame(vi);
-*/
-unsigned char *blurp;
-unsigned char *dstp;
-	dst=data;
-	if(frame&gt;=_info.nb_frames) return 0;
-	src=vidCache-&gt;getImage(frame);
-	blur=blurrImg;
-	{
-		for (int i=0;i&lt;3;i++)
-		{
-		
-			//unsigned char *blurp = blur-&gt;GetWritePtr(plane);
-			switch(i)
-			{
-				case 0:blurp=YPLANE(blur);break;
-				case 1:blurp=UPLANE(blur);break;
-				case 2:blurp=VPLANE(blur);break;
-			}
-			blur_plane(src, blur, blurp ,i);
-
-		//	unsigned char *dstp = dst-&gt;GetWritePtr(plane);
-			switch(i)
-			{
-				case 0:dstp=YPLANE(dst);break;
-				case 1:dstp=UPLANE(dst);break;
-				case 2:dstp=VPLANE(dst);break;
-			}
-
-			detect_edges(blur, dst, dstp, i);
-			if (_param-&gt;highq == true)
-				detect_edges_HiQ(blur, dst, dstp, i);
-
-			if (!_param-&gt;mask) apply_filter(src, blur, dst, dstp, i);
-		}
-	}
-
-	vidCache-&gt;unlockAll();
-	return 1;
-}
-
-/**********************************
- * MMX / ISSE by Klaus Post and Milan Cutka.
- *
- * Delivers same result as YUY2, except planes
- *  are processed independently.
- *********************************/
-
-void Msharpen::blur_plane(ADMImage *src, ADMImage *blur, unsigned char *blurp, int plane) 
-{
-/*
-  uint64_t mask1 = 0x00001C711C711C71LL;
-  uint64_t mask2 = 0x1C711C711C710000LL;
-  uint64_t mask3 = 0x0000200000002000LL;
-  uint64_t mask4 = 0x0000000000ff0000LL;
-
-  const unsigned char *srcp = src-&gt;GetReadPtr(plane);
-	const unsigned char *srcp_saved = srcp;
-	unsigned char *blurp_saved = blurp;
-  int src_pitch = src-&gt;GetPitch(plane);
-  int blur_pitch = blur-&gt;GetPitch(plane);
-  int h = src-&gt;GetHeight(plane);
-  int w = src-&gt;GetRowSize(plane);
-*/
-const unsigned char *srcp,*srcpn,*srcpp; 
-const unsigned char *srcp_saved ;
-unsigned char *wk,*wk_saved;
-unsigned char *blurp_saved ;
-int src_pitch;
-int blur_pitch;
-int h;
-int w ;
-int wh ,ww,hh;
- 	blurp_saved=blurp;
-	switch(plane)
-		{
-			case 0:
-				srcp_saved=srcp=YPLANE(src);        
-                                wk_saved=wk=YPLANE(work);
-				ww=_info.width;
-				hh=_info.height;
-				break;
-			case 1:
-				srcp_saved=srcp=UPLANE(src);
-                                wk_saved=wk=UPLANE(work);
-				ww=_info.width&gt;&gt;1;
-				hh=_info.height&gt;&gt;1;
-				break;
-			case 2:
-				srcp_saved=srcp=VPLANE(src);
-                                wk_saved=wk=VPLANE(work);
-				ww=_info.width&gt;&gt;1;
-				hh=_info.height&gt;&gt;1;
-				break;
-		}
-		src_pitch=ww;
-		blur_pitch=ww;
-		w=ww;
-		h=hh;
- 
-  
-  wk+=blur_pitch;
-  srcpp=srcp;
-  srcp+=src_pitch,
-  srcpn=srcp+src_pitch;
-  int val;
-
-  // Vertical only for now      
-#if (defined( ARCH_X86)  || defined(ARCH_X86_64))
-  if(CpuCaps::hasMMX())
-  {
-  int off;
-#ifdef GCC_2_95_X
-        __asm__(
-                        &quot;.align 16\n&quot;
-                        &quot;pxor  %mm7,%mm7\n&quot;
-                : : );
-#else
-        __asm__(
-                        &quot;.align 16\n&quot;
-                        &quot;pxor  %%mm7,%%mm7\n&quot;
-                : : );
-#endif
-                        
-  for (int y=1; y&lt;h-1 ;y++) 
-  {               
-        for (int x =  (w&gt;&gt;3);x&gt;0; x--)
-                {
-                        off=x&lt;&lt;3;                        
-                        __asm__(
-                        &quot;.align 16\n&quot;                      
-                        &quot;movq  (%0),%%mm0\n&quot;
-                        &quot;movq  %%mm0,%%mm6\n&quot;
-                        &quot;punpckhbw %%mm7,%%mm0\n&quot; // High part extended to 16 bits
-                        &quot;punpcklbw %%mm7,%%mm6\n&quot; // low part ditto
-                        
-                        &quot;movq  (%1),%%mm1\n&quot;
-                        &quot;movq  %%mm1,%%mm5\n&quot;
-                        &quot;punpckhbw %%mm7,%%mm1\n&quot;
-                        &quot;punpcklbw %%mm7,%%mm5\n&quot;
-                        
-                        &quot;movq  (%2),%%mm2\n&quot;
-                        &quot;movq  %%mm2,%%mm4\n&quot;
-                        &quot;punpckhbw %%mm7,%%mm2\n&quot;
-                        &quot;punpcklbw %%mm7,%%mm4\n&quot;
-                        
-                        &quot;paddw %%mm1,%%mm0\n&quot;
-                        &quot;paddw %%mm5,%%mm6\n&quot;
-                        
-                        &quot;paddw %%mm1,%%mm2\n&quot;
-                        &quot;paddw %%mm5,%%mm4\n&quot;
-                        
-                        &quot;paddw %%mm0,%%mm2\n&quot;
-                        &quot;paddw %%mm6,%%mm4\n&quot;
-                        &quot;psrlw $2, %%mm4\n&quot;
-                        &quot;psrlw $2, %%mm2\n&quot;
-                        &quot;packuswb %%mm2,%%mm4\n&quot;
-                        &quot;movq %%mm4,(%3)\n&quot; //
-                        
-                        : : &quot;r&quot; (srcpn+off),
-                           &quot;r&quot; (srcp+off), &quot;r&quot; (srcpp+off), &quot;r&quot; (wk+off)
-                        );
-                }                        
-        srcp+=src_pitch;
-        srcpp+=src_pitch;
-        srcpn+=src_pitch;
-        wk+=src_pitch;     
-  }
-  __asm__(&quot;emms\n&quot;);
- }
- else
-#endif      
-  {
-  for (int y=1; y&lt;h-1 ;y++) 
-  {       
-
-        for(int x=0;x&lt;w;x++)
-        {
-                val=srcp[x]+srcpn[x]+srcpp[x]+srcp[x];
-                wk[x]=(val)&gt;&gt;2;
-        } 
-        srcp+=src_pitch;
-        srcpp+=src_pitch;
-        srcpn+=src_pitch;
-        wk+=src_pitch;     
-  }
-  }
-  //************ Horizontal****************
-  blurp=blurp_saved;
-  srcp=wk_saved;
-  for (int y=1; y&lt;h-1 ;y++) 
-  {         
-        for(int x=1;x&lt;w-1;x++)
-        {
-                val=srcp[x-1]+srcp[x]+srcp[x+1]+srcp[x];
-                blurp[x]=val&gt;&gt;2;
-        } 
-        srcp+=src_pitch;
-        srcpp+=src_pitch;
-        srcpn+=src_pitch;
-        blurp+=src_pitch;     
-  }
-  //******************
-        /* Fix up blur frame borders. */
-        srcp = srcp_saved;
-        blurp = blurp_saved;
-        memcpy(blurp, srcp, w);
-        memcpy(blurp + (h-1)*blur_pitch, srcp + (h-1)*src_pitch, w);
-        for (int y = 0; y &lt; h; y++)
-        {
-                blurp[0] = srcp[0];
-                blurp[w-1] = srcp[w-1];
-                srcp += src_pitch;
-                blurp += blur_pitch;
-        }
-
-}
-#if 0
-    __asm {
-      mov esi, srcp  // esi=srcpp
-      mov ecx, blurp
-      mov ebx, src_pitch
-      mov edi, esi 
-      mov edx, esi 
-      add edi, ebx // edi=srcp+pitch=srcp
-      add edx, ebx 
-      add edx, ebx  //edx=srcp+2*pitch=srcpn
-      xor eax, eax
-      movq mm7,mask1 // mm7 mask1
-      movq mm6,mask2 // mm6 mask2
-     align 16
-xloop:
-      movd mm0,[esi+eax]  //srcpp[x}
-      pxor mm5,mm5
-       movd mm1,[edi+eax] //srcp[x}
-      movd mm2,[edx+eax]  // srcpn   
-      punpcklbw mm0,mm5  // mm0 low srcpp
-      punpcklbw mm1,mm5   // mm1 low srcp
-      movq mm3, mm0
-      punpcklbw mm2,mm5   // mm2 low srcn
-      movq mm4, mm1
-      movq mm5, mm2
-      paddw mm0,mm1     // srcp+srcpp
-      paddw mm3,mm4   // 2*srcp+srcpp
-      paddw mm0,mm2    // 2*srcp+srcpp+srcn
-      paddw mm3,mm5   // idem
-      pmaddwd mm0,mm7
-       movq mm5,[mask3]
-      pmaddwd mm3,mm6
-       pshufw mm1,mm0, 11101110b  // Move upper to lower
-      pshufw mm4,mm3, 11101110b   
-       paddd mm0,mm1
-      paddd mm3,mm4
-       paddd mm0, mm5
-      paddd mm3, mm5
-       psrld mm0,16
-      pand mm3,[mask4]
-      psrld mm3,8
-      por mm0,mm3
-      movd [eax+ecx],mm0  // blurp[i]
-      add eax,2
-      cmp eax,[w]
-      jle xloop;
-    }
-    srcp += src_pitch;
-    blurp += blur_pitch;
-//      __asm emms;
-#endif
- 
-
-//***************************************************
-void Msharpen::detect_edges(ADMImage *src, ADMImage *dst, unsigned char *dstp, int plane) 
-{
-  static uint64_t m255=0xffffffffffffffffLL;
-  static uint64_t threshold64;
-  int ww,hh;
-
-  threshold64=_param-&gt;threshold;
-  if(!threshold64) threshold64=1;
-  threshold64=threshold64+(threshold64&lt;&lt;8)+(threshold64&lt;&lt;16)+(threshold64&lt;&lt;24)+(threshold64&lt;&lt;32)+(threshold64&lt;&lt;40)+(threshold64&lt;&lt;48)+(threshold64&lt;&lt;56);
-/*
-  const unsigned char *srcp = src-&gt;GetReadPtr(plane);
-  int src_pitch = src-&gt;GetPitch(plane);
-  int dst_pitch = dst-&gt;GetPitch(plane);
-  const unsigned char *srcpn = srcp+src_pitch;
-  int h = src-&gt;GetHeight(plane);
-  int w = src-&gt;GetRowSize(plane);
-*/
-  const unsigned char *srcp,*srcp_saved; 
-  int src_pitch ;
-  int dst_pitch ; 
-  const unsigned char *srcpn; 
-  int h ;
-  int w ;
-  unsigned char *dstp_saved = dstp;
-
-  switch(plane)
-	{
-		case 0: srcp=YPLANE(src);
-			ww=_info.width;
-			hh=_info.height;
-			break;
-		case 2:
-		case 1:
-			if(plane==1) 	
-				srcp=UPLANE(src);
-			else
-				srcp=VPLANE(src);
-			ww=_info.width&gt;&gt;1;
-			hh=_info.height&gt;&gt;1;
-			break;
-		default:
-			ADM_assert(0);
-	}
-	src_pitch=ww;
-	dst_pitch=ww;
-	w=ww;
-	h=hh;
-	srcpn=srcp+src_pitch;
-	srcp_saved=srcp;
-
- int p,n,c;
- for (int y=0;y&lt;h-1;y++)
-  {
-   for(int xx=1;xx&lt;w-1;xx++)
-        {
-                p=srcp[xx+1];
-                n=srcpn[xx+1];
-                c=srcpn[xx-1];
-                
-                if(abs(n-p)&gt;_param-&gt;threshold || abs(c-p)&gt;_param-&gt;threshold) dstp[xx+1]=0xff;
-                                else dstp[xx+1]=0;
-                
-        }
-   srcp+=src_pitch;
-   srcpn+=src_pitch;
-   dstp+=dst_pitch;
-  }
-  if (_param-&gt;mask) {
-    dstp=dstp_saved;
-    memset(dstp_saved+(h-1)*dst_pitch,0,w);  // Not used, if not returning mask
-    for (int y=0;y&lt;h;dstp+=dst_pitch,y++) {
-      dstp[0]=0;
-      dstp[1]=0;
-      dstp[w-1]=0;
-      dstp[w-2]=0;
-    }
-  }
-}
-#if 0
-unsigned char *dstpend=dstp+w-1;
-   __asm 
-    {
-     mov esi,[srcp]
-     inc esi
-     mov ecx,[srcpn]
-     inc ecx
-     mov edx,[srcpn]
-     dec edx
-     mov edi,[dstp]
-     inc edi
-     mov eax,[dstpend]
-     movq mm6,[threshold64]
-     pxor mm5,mm5
-     movq mm4,[m255]
-     align 16
-    diag1:
-     movq mm2,[ecx]
-      movq mm1,[esi]
-     movq mm3,[edx]
-
-     //abs(mm1-mm2)
-      movq mm7,mm1
-     pminub mm1,mm2  //srcpn+1 - srcp+1
-      pmaxub mm2,mm7
-     psubusb mm2,mm1
-      movq mm1,[esi]
-     psubusb mm2,mm6
-     
-     //abs(mm1-mm3)
-      movq mm7,mm1
-     pminub mm1,mm3 // srcp+1 srcp-1
-      pmaxub mm3,mm7
-     psubusb mm3,mm1
-     psubusb mm3,mm6
-
-     por     mm2,mm3
-     pcmpeqb mm2,mm5
-     pxor    mm2,mm4
-     movq    [edi],mm2
-     
-     add esi,8
-     add ecx,8
-     add edx,8
-     add edi,8
-     cmp edi,eax
-     jl  diag1
-
-   }
-__asm emms;
-#endif
-//***************************************************
-void Msharpen::detect_edges_HiQ(ADMImage *src, ADMImage *dst, unsigned char *dstp, int plane) 
-{
-  // Vertical detail detection
-/*
-  const unsigned char *srcp = src-&gt;GetReadPtr(plane);
-	const unsigned char *srcp_saved = srcp;
-  const unsigned char *srcpn;
-	unsigned char *dstp_saved = dstp;
-  int src_pitch = src-&gt;GetPitch(plane);
-  int dst_pitch = dst-&gt;GetPitch(plane);
-  int h = src-&gt;GetHeight(plane);
-  int w = src-&gt;GetRowSize(plane);
-*/
-
-  int b1,b2;
-  int ww,hh;
- const unsigned char *srcp,*srcp_saved; 
-  int src_pitch ;
-  int dst_pitch ; 
-  const unsigned char *srcpn; 
-  int h ;
-  int w ;
-  unsigned char *dstp_saved = dstp;
-
-  switch(plane)
-	{
-		case 0: srcp=YPLANE(src);
-			ww=_info.width;
-			hh=_info.height;
-			break;
-		case 2:
-		case 1:
-			if(plane==1) 	
-				srcp=UPLANE(src);
-			else
-				srcp=VPLANE(src);
-			ww=_info.width&gt;&gt;1;
-			hh=_info.height&gt;&gt;1;
-			break;
-		default:
-			ADM_assert(0);
-	}
-	src_pitch=ww;
-	dst_pitch=ww;
-	w=ww;
-	h=hh;
-	srcpn=srcp+src_pitch;
-	srcp_saved=srcp;
-
-  for (int x=0;x&lt;w;x++)
-  {
-    srcp=srcp_saved;
-    srcpn=srcp+src_pitch;
-    dstp=dstp_saved;
-    b1=srcp[x];
-    for (int y=0;y&lt;h-1;dstp+=dst_pitch,srcp+=src_pitch,srcpn+=src_pitch,y++)
-    {
-      b2=srcpn[x];
-      if (abs(b1-b2)&gt;=_param-&gt;threshold)
-        dstp[x]=255;
-      b1=b2;
-    }
-  }
-  
-  // Horizontal detail detection
-  srcp=srcp_saved;
-  dstp=dstp_saved;
-  for (int y=0;y&lt;h;dstp+=dst_pitch,srcp+=src_pitch,y++)
-  {
-    b1=srcp[0]; //MEANX srcp[x]
-    for (int x=0;x&lt;w-1;x++)
-    {
-      b2=srcp[x+1];
-      if (abs(b1-b2)&gt;=_param-&gt;threshold)
-        dstp[x]=255;
-      b1=b2;
-    }
-  }
-  // Fix up detail map borders
-  dstp = dstp_saved;
-  memset(dstp,0,w);
-  memset(dstp+dst_pitch,0,w);
-  memset(dstp+(h-2)*dst_pitch,0,w);
-  memset(dstp+(h-1)*dst_pitch,0,w);
-  for (int y=0;y&lt;h;dstp+=dst_pitch,y++)
-  {
-    dstp[0]=0;
-    dstp[1]=0;
-    dstp[w-1]=0;
-    dstp[w-2]=0;
-  }
-}
-//***************************************************
-void Msharpen::apply_filter(ADMImage *src,ADMImage *blur, ADMImage *dst, unsigned char *dstp, int plane) 
-{
-  // TODO: MMX / ISSE
-/*
-  const unsigned char *srcp = src-&gt;GetReadPtr(plane);
-  const unsigned char *blurp = blur-&gt;GetReadPtr(plane);
-  const unsigned char *srcp_saved = srcp;
-  unsigned char *dstp_saved = dstp;
-  const unsigned char *blurp_saved = blurp;
-  int src_pitch = src-&gt;GetPitch(plane);
-  int blur_pitch = blur-&gt;GetPitch(plane);
-  int dst_pitch = dst-&gt;GetPitch(plane);
-  int h = src-&gt;GetHeight(plane);
-  int w = src-&gt;GetRowSize(plane);
- */
-  const unsigned char *srcp ;
-  const unsigned char *blurp ;
-  const unsigned char *srcp_saved; 
-  unsigned char *dstp_saved ;
-  const unsigned char *blurp_saved ;
-  int src_pitch;
-  int blur_pitch;
-  int dst_pitch;
-  int h;
-  int w;
-  int ww,hh; 
-
-  switch(plane)
-	{
-		case 0:
-			 srcp=YPLANE(src);
-			 blurp=YPLANE(blur);
-			 ww=_info.width;
-			 hh=_info.height;
-			 break;
-		case 1:
-		case 2:
-			if(plane==1)
-			{
-			 srcp=UPLANE(src);
-			 blurp=UPLANE(blur);
-			}
-			else
-			{
-			 srcp=VPLANE(src);
-			 blurp=VPLANE(blur);
-			}
-			 ww=_info.width&gt;&gt;1;
-			 hh=_info.height&gt;&gt;1;
-			break;
-	}
-
-	w=ww;
-	h=hh;
-	blur_pitch=ww;
-	dst_pitch=ww;
-	src_pitch=ww;
-	srcp_saved=srcp;
-	blurp_saved=blurp;
-	dstp_saved=dstp;
-	
-  memcpy(dstp,srcp,w);
-  memcpy(dstp+(h-1)*dst_pitch,srcp+(h-1)*src_pitch,w);
-  for (int y=0;y&lt;h;srcp+=src_pitch,dstp+=dst_pitch,y++)
-  {
-    dstp[0]=srcp[0];
-    dstp[w-1]=srcp[w-1];
-  }
-  
-  // Now sharpen the edge areas and we're done
-  srcp=srcp_saved+src_pitch;
-  dstp=dstp_saved+dst_pitch;
-  blurp=blurp+dst_pitch;
-  int b4;
-  for (int y=1;y&lt;h-1;srcp+=src_pitch,dstp+=dst_pitch,blurp+=blur_pitch,y++)
-  {
-    for (int x=1;x&lt;w-1;)
-    {
-      if (*(int*)(dstp+x)==0) 
-      {
-        *(int*)(dstp+x)=*(int*)(srcp+x);
-        x+=4;
-        continue;
-      }
-      if (dstp[x])
-      {                                     
-        b4=4*int(srcp[x])-3*int(blurp[x]);
-        if (b4&lt;0) b4=0; else if (b4&gt;255) b4=255;
-        dstp[x]=(_param-&gt;strength*b4+invstrength*srcp[x])&gt;&gt;8;
-      }
-      else
-        dstp[x]=srcp[x];
-      x++; 
-    }  
-    dstp[w-1]=srcp[w-1]; 
-  }   
-}
-//***************************************************
-
-
-
-
-

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidMSharpen_param.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidMSharpen_param.h	2007-01-11 19:18:08 UTC (rev 2704)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidMSharpen_param.h	2007-01-11 20:41:19 UTC (rev 2705)
@@ -1,7 +0,0 @@
-typedef struct MSHARPEN_PARAM
-{
-	uint32_t  mask;
-	uint32_t  highq;
-	uint32_t  threshold;
-        uint32_t  strength;
-};

Modified: branches/avidemux_2.4_branch/avidemux/ADM_video/Makefile.am
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/Makefile.am	2007-01-11 19:18:08 UTC (rev 2704)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/Makefile.am	2007-01-11 20:41:19 UTC (rev 2705)
@@ -15,7 +15,6 @@
  ADM_vidPartial.cpp \
  ADM_vidFont.cpp \
  ADM_vidSRT.cpp \
- ADM_vidDenoise.cpp \
 	ADM_vidFlipV.cpp \
  ADM_vidStabilize.cpp \
  ADM_vidContrast.cpp \
@@ -57,7 +56,6 @@
  ADM_vidSRTload.cpp \
  ADM_vidlavdeint.cpp \
 	ADM_mpdetc.cpp \
- ADM_vidForcedPP.cpp \
  ADM_vidDecTelecide.cpp \
  ADM_vidDecTelecide.h ADM_cache.cpp \
  ADM_vidDecDec.cpp \
@@ -70,7 +68,6 @@
  ADM_vidHue.cpp \
  ADM_vidEq2.cpp \
  ADM_vidDGbob.cpp \
- ADM_vidMSharpen.cpp \
  ADM_vidAsharp.cpp \
  ADM_vidCNR2.cpp \
   ADM_vidDelta.cpp \
@@ -98,8 +95,8 @@
 ADM_genvideo.hxx ADM_vidDeinterlace.cpp  ADM_vidPartial.cpp \
 ADM_vidDeinterlace.h  ADM_vidPartial.h \
 ADM_vidDelta.cpp  ADM_vidPartial_param.h \
-ADM_guiCrop.cpp  ADM_vidDenoise.cpp  ADM_vidPulldown.cpp \
-ADM_vidDenoise.h  ADM_vidPulldown.h \
+ADM_guiCrop.cpp    ADM_vidPulldown.cpp \
+ ADM_vidPulldown.h \
 ADM_guiResize.cpp  ADM_vidDropOut.cpp  ADM_vidRaw.cpp \
 ADM_interlaced.cpp ADM_vidDropOut.h  \
 ADM_interlaced.h ADM_vidEq2.cpp  ADM_vidResize.cpp \
@@ -120,8 +117,8 @@
 ADM_vidAsharp.cpp   ADM_vidStabilize.cpp \
 ADM_vidFont.cpp ADM_vidStabilize.h \
 ADM_vidBlend.cpp ADM_vidFont.h ADM_vidSwapFields.cpp \
-ADM_vidBlendRemoval.cpp  ADM_vidForcedPP.cpp ADM_vidSwapFields.h \
-ADM_vidBlendRemoval_param.h  ADM_vidForcedPP.h ADM_vidSwapSmart.cpp \
+ADM_vidBlendRemoval.cpp  ADM_vidSwapFields.h \
+ADM_vidBlendRemoval_param.h  ADM_vidSwapSmart.cpp \
 ADM_vidCNR2.cpp  ADM_vidHardIvtcRemoval.cpp  ADM_vidSwapSmart.h \
 ADM_vidCNR2_param.h  ADM_vidHue.cpp  ADM_vidTDeint_param.h \
 ADM_vidCached.cpp  ADM_vidHue.h  ADM_vidTdeint.cpp \
@@ -140,8 +137,8 @@
 ADM_vidCommonFilter.h  ADM_vidMPLResize.cpp  ADM_vidVobsub.cpp \
 ADM_vidContrast.cpp  ADM_vidMPdelogo.cpp ADM_vidWirl.cpp \
 ADM_vidContrast.h  ADM_vidMPdelogo.h ADM_vidlavdeint.cpp \
-ADM_vidConvolution.cpp ADM_vidMSharpen.cpp ADM_vidlavdeint.h \
-ADM_vidConvolution.hxx ADM_vidMSharpen_param.h ADM_vobsubinfo.cpp \
+ADM_vidConvolution.cpp  ADM_vidlavdeint.h \
+ADM_vidConvolution.hxx  ADM_vobsubinfo.cpp \
 ADM_vidCrop.cpp  ADM_vidMSmooth_param.h  ADM_vobsubinfo.h \
 ADM_vidDGbob.cpp ASM_vidDenoise.cpp \
 ADM_vidDGbob_param.h   \
@@ -153,6 +150,6 @@
 INCLUDES = $(all_includes) -I../ADM_libraries -I../ADM_libraries/ADM_utilities -I../ADM_libraries/ADM_lavutil \
 			 $(FREETYPE_CFLAGS) $(ALTIVEC_SWITCH) -I../ADM_userInterfaces/ADM_commonUI -I../ADM_inputs
 noinst_HEADERS = ADM_vidlavdeint.h ADM_mpdetc.h \
-					ADM_vidForcedPP.h  ADM_cache.h ADM_vidDecTel_param.h ADM_vidDecDec_param.h \
+					  ADM_cache.h ADM_vidDecTel_param.h ADM_vidDecDec_param.h \
 					ADM_vidMSmooth_param.h ADM_vidEqualizer.h ADM_vobsubinfo.h ADM_vidVobSub.h \
 		ADM_vidEq2.h ADM_vidASS.h

Copied: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidDenoise.cpp (from rev 2545, branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidDenoise.cpp)
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidDenoise.cpp	2006-11-04 15:58:52 UTC (rev 2545)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidDenoise.cpp	2007-01-11 20:41:19 UTC (rev 2705)
@@ -0,0 +1,402 @@
+/***************************************************************************
+                          ADM_vidDenoise.cpp  -  description
+                             -------------------
+    begin                : Mon Nov 25 2002
+    copyright            : (C) 2002 by mean
+    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
+    
+    Denoiser inspired from DNR in transcode
+    Ported to YV12 and simplified
+    
+   Original code  Copyright (C) Gerhard Monzel - November 2001
+ 
+    
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include &lt;stdio.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;string.h&gt;
+#include &lt;ADM_assert.h&gt;
+#include &lt;math.h&gt;
+
+#include &quot;config.h&quot;
+#include &quot;fourcc.h&quot;
+#include &quot;avio.hxx&quot;
+#include &quot;config.h&quot;
+#include &quot;avi_vars.h&quot;
+
+
+#include &quot;ADM_toolkit/toolkit.hxx&quot;
+#include &quot;ADM_editor/ADM_edit.hxx&quot;
+#include &quot;ADM_video/ADM_genvideo.hxx&quot;
+#include &quot;ADM_vidDenoise.h&quot;
+#include &quot;ADM_filter/video_filters.h&quot;
+
+
+#include &quot;ADM_userInterfaces/ADM_commonUI/DIA_factory.h&quot;
+
+static FILTER_PARAM denoiseParam={5,{&quot;lumaLock&quot;,&quot;lumaThreshold&quot;,&quot;chromaLock&quot;,&quot;chromaThreshold&quot;,
+					&quot;sceneChange&quot;}};
+
+
+SCRIPT_CREATE(denoise_script,ADMVideoDenoise,denoiseParam);
+
+uint8_t distMatrix[256][256];
+uint32_t fixMul[16];
+
+//static uint8_t matrixReady=0;
+//static uint8_t doOnePix(uint8_t *in,uint8_t *out,uint8_t *lock,uint8_t *nb);
+
+BUILD_CREATE(denoise_create,ADMVideoDenoise);
+char *ADMVideoDenoise::printConf( void )
+{
+ 	static char buf[50];
+
+  ADM_assert(_param); 	
+ 	sprintf((char *)buf,&quot; Denoise : Lum :%02ld/:%02ld / Chm :%02ld/%02ld&quot;,
+  								_param-&gt;lumaLock,
+          				_param-&gt;lumaThreshold,
+              		_param-&gt;chromaLock,
+                	_param-&gt;chromaThreshold);
+        return buf;
+}
+void buildDistMatrix( void );
+void buildDistMatrix( void )
+{
+int d;	
+	for(uint32_t y=255;y&gt;0;y--)
+	for(uint32_t x=255;x&gt;0;x--)
+	{
+		  d=x-y;
+		  if(d&lt;0) d=-d;
+		  distMatrix[x][y]=d;
+		
+	}
+
+	 for(int i=1;i&lt;16;i++)
+                        {
+                                        fixMul[i]=(1&lt;&lt;16)/i;
+                        }
+
+}
+
+//_______________________________________________________________
+
+ADMVideoDenoise::ADMVideoDenoise(
+									AVDMGenericVideoStream *in,CONFcouple *couples)
+{
+
+
+  	_in=in;		
+   	memcpy(&amp;_info,_in-&gt;getInfo(),sizeof(_info));  			 	
+    uint32_t page;
+    
+  _info.encoding=1;
+  
+  page= _in-&gt;getInfo()-&gt;width*_in-&gt;getInfo()-&gt;height;
+  
+//  _uncompressed=new uint8_t [page];
+  _uncompressed=new ADMImage(_in-&gt;getInfo()-&gt;width,_in-&gt;getInfo()-&gt;height);
+  ADM_assert(_uncompressed);
+  
+ // _locked=new uint8_t [page];
+  _locked=new ADMImage(_in-&gt;getInfo()-&gt;width,_in-&gt;getInfo()-&gt;height);
+  ADM_assert(_locked);
+ 
+//	_lockcount=new uint8_t [page];
+
+
+  
+   _lockcount=new ADMImage(_in-&gt;getInfo()-&gt;width,_in-&gt;getInfo()-&gt;height);
+  memset(YPLANE(_lockcount),0,page);  
+  memset(UPLANE(_lockcount),0,page&gt;&gt;2);  
+  memset(VPLANE(_lockcount),0,page&gt;&gt;2);  
+        
+  _param=NULL;
+  
+  if(couples)
+  	{
+			_param=NEW(NOISE_PARAM);
+			GET(lumaLock);
+			GET(lumaThreshold);
+			GET(chromaLock);
+			GET(chromaThreshold);
+			GET(sceneChange);
+		 }
+	else
+		{
+			  #define XXX 1
+			  _param=NEW(NOISE_PARAM);
+			  _param-&gt;lumaLock=  4*XXX;
+			  _param-&gt;lumaThreshold= 10*XXX;
+			  _param-&gt;chromaLock=  8*XXX;
+			  _param-&gt;chromaThreshold= 16*XXX;
+        _param-&gt;sceneChange=  30*XXX;
+			}
+  	  _lastFrame=0xfffffff0;	
+}
+
+
+uint8_t	ADMVideoDenoise::getCoupledConf( CONFcouple **couples)
+{
+
+			ADM_assert(_param);
+			*couples=new CONFcouple(5);
+
+#define CSET(x)  (*couples)-&gt;setCouple((char *)#x,(_param-&gt;x))
+	CSET(lumaLock);
+	CSET(lumaThreshold);
+	CSET(chromaLock);
+	CSET(chromaThreshold);
+	CSET(sceneChange);
+
+	return 1;
+
+}
+ADMVideoDenoise::~ADMVideoDenoise()
+{
+ 	
+	delete  _uncompressed;
+ 	delete  _locked;
+  	delete  _lockcount;
+  DELETE(_param);
+  
+  _uncompressed=_locked=_lockcount=NULL;
+}
+
+//
+//	Remove y and v just keep U and expand it
+//
+uint8_t ADMVideoDenoise::getFrameNumberNoAlloc(uint32_t frame,
+				uint32_t *len,
+   				ADMImage *data,
+				uint32_t *flags)
+{
+   //uint32_t x,w;
+  	uint32_t page; 
+   		ADM_assert(_param);
+		ADM_assert(frame&lt;_info.nb_frames);
+								
+			
+       		if(!_in-&gt;getFrameNumberNoAlloc(frame, len,_uncompressed,flags)) return 0;
+
+		
+		page=_info.width*_info.height;  
+		*len=(page*3)&gt;&gt;1;           
+
+	if((_lastFrame+1)!=frame) // async jump
+	{
+			// just copy it 
+			memcpy(YPLANE(data),YPLANE(_uncompressed),page);
+			memcpy(UPLANE(data),UPLANE(_uncompressed),page&gt;&gt;2);
+			memcpy(VPLANE(data),VPLANE(_uncompressed),page&gt;&gt;2);
+			
+			memcpy(YPLANE(_locked),YPLANE(_uncompressed),page);
+			memcpy(UPLANE(_locked),UPLANE(_uncompressed),page&gt;&gt;2);
+			memcpy(VPLANE(_locked),VPLANE(_uncompressed),page&gt;&gt;2);
+			
+			_lastFrame=frame;
+			return 1;
+	}          
+	_lastFrame=frame;
+          
+          // copy chroma for now
+        
+         
+          
+          //
+          //uint32_t count=0;
+          //uint32_t cell=page*4; // size of luma
+          uint8_t *in,*out,*lock,*nb;
+          uint8_t *uin,*uout,*ulock,*unb;
+          uint8_t *vin,*vout,*vlock,*vnb;
+          
+          
+          //uint32_t d;
+          // init all
+          
+          // luma
+          nb=YPLANE(_lockcount);
+          lock=YPLANE(_locked);
+          in=YPLANE(_uncompressed);
+          out=YPLANE(data);
+          // u
+          unb=UPLANE(_lockcount);
+          ulock=UPLANE(_locked);
+          uin=UPLANE(_uncompressed);
+          uout=UPLANE(data);
+          // v
+          vnb=VPLANE(_lockcount);
+          vlock=VPLANE(_locked);
+          vin=VPLANE(_uncompressed);
+          vout=VPLANE(data);
+          
+          
+          uint32_t xx,yy/*,dl*/,du,dv;
+          uint32_t locked=0;
+          for(yy=_info.height&gt;&gt;1;yy&gt;0;yy--)
+          {
+	          for(xx=_info.width&gt;&gt;1;xx&gt;0;xx--)          
+  	        {
+			du=distMatrix[*uin][*ulock];	
+			dv=distMatrix[*vin][*vlock];		
+						
+			// if chroma is locked , we try to lock luma
+			if( (du&lt;_param-&gt;chromaLock)
+				 &amp;&amp; (dv&lt;_param-&gt;chromaLock))
+			 {  
+				*uout=*ulock;
+ 				*vout=*vlock;
+
+#define PIX(z) 		doOnePix(in+z,out+z,lock+z,nb+z) 
+				locked+=PIX(0)+	PIX(1)+ PIX(_info.width)+PIX(_info.width+1);
+			}
+			else
+			 // if chroma is blended, we blend luma
+#undef PIX								  
+#define PIX(z) 		doBlend(in+z,out+z,lock+z,nb+z)									 
+				if( (du&lt;_param-&gt;chromaThreshold)
+					 &amp;&amp; (dv&lt;_param-&gt;chromaThreshold))
+				{
+			 		PIX(0);
+				    	PIX(1);
+				     	PIX(_info.width);
+				     	PIX(_info.width+1);	
+				      *uout=*ulock=(*uin+*uin)&gt;&gt;1;
+ 					*vout=*vlock=(*vin+*vin)&gt;&gt;1;
+				}
+#undef PIX											
+										
+			else
+			{
+#define PIX(z) *(out+z)=*(lock+z)=*(in+z);*(nb+z)=0			
+											
+				PIX(0);
+				PIX(1);
+				PIX(_info.width);
+				PIX(_info.width+1);		
+				*uout=*ulock=*uin;
+ 				*vout=*vlock=*vin;
+				
+#undef PIX		
+			}
+								  
+											                        				                        
+			uin++;uout++;ulock++;unb++;   
+			vin++;vout++;vlock++;vnb++;   
+			in++;out++;lock++;nb++;   
+			in++;out++;lock++;nb++;   
+							
+		}
+            // 
+            in+=_info.width;
+            out+=_info.width;
+            lock+=_info.width;
+            nb+=_info.width;            						
+	};
+          
+          if(locked&gt;((page*3)&gt;&gt;2)) // if more than 75% pixel not locked -&gt; scene change
+          {
+			memcpy(YPLANE(data),YPLANE(_uncompressed),page);
+			memcpy(UPLANE(data),UPLANE(_uncompressed),page&gt;&gt;2);
+			memcpy(VPLANE(data),VPLANE(_uncompressed),page&gt;&gt;2);
+			
+			memcpy(YPLANE(_locked),YPLANE(_uncompressed),page);
+			memcpy(UPLANE(_locked),UPLANE(_uncompressed),page&gt;&gt;2);
+			memcpy(VPLANE(_locked),VPLANE(_uncompressed),page&gt;&gt;2);
+	}
+      data-&gt;copyInfo(_uncompressed);  
+      return 1;
+}
+
+//
+//	0 copy
+//  1 lock
+//  2 threshold
+//
+uint8_t ADMVideoDenoise::doOnePix(uint8_t *in,uint8_t *out,uint8_t *lock,uint8_t *nb)
+{
+unsigned int d;
+		d=distMatrix[*(in)][*(lock)]; 
+		if(d&lt;_param-&gt;lumaLock)         
+		{								                
+			if(*(nb)&gt;30)  // out of scope -&gt; copy new                   
+			{  	// too much copy -&gt;                              
+				*(nb)=0;                       
+				*(out)=(*(in)+*(lock))&gt;&gt;1;
+				*(lock)=*(out);    	
+				return DN_COPY;      
+			}                                 
+			else                               
+			{                                   
+				*(out)=*(lock);		
+				*nb += 1; // *(nb)++;	
+				return DN_LOCK;		
+			}                  
+		}                     
+		else if(d&lt; _param-&gt;lumaThreshold) 
+			{                                  
+				 *(nb)=0;                           
+				*(out)=(*(in)+*(lock))&gt;&gt;1;	
+				return DN_BLEND;
+			}
+			else   // too big delta
+			{    
+				 *(nb)=0; 
+				*(out)=*(in);	  
+				*(lock)=*(in);    
+				return DN_COPY;
+			}                     
+					                           
+			ADM_assert(0);
+			return 0;
+
+}
+uint8_t ADMVideoDenoise::doBlend(uint8_t *in,uint8_t *out,uint8_t *lock,uint8_t *nb)
+{
+unsigned int d;
+		   d=distMatrix[*(in)][*(lock)]; 
+		   *nb=0;
+		   
+			if(d&lt;_param-&gt;lumaThreshold)         
+			{
+					*(out)=(*(in)+*(lock))&gt;&gt;1;					
+			}
+			else
+			*out=*in;
+			return 0;
+	
+}
+extern uint8_t DIA_dnr(uint32_t *llock,uint32_t *lthresh, uint32_t *clock,
+			uint32_t *cthresh, uint32_t *scene);
+
+
+uint8_t ADMVideoDenoise::configure(AVDMGenericVideoStream * instream)
+{
+  UNUSED_ARG(instream);
+  
+#define PX(x) &amp;(_param-&gt;x)
+  
+    diaElemUInteger   lumaLock(PX(lumaLock),_(&quot;Luma Lock&quot;),0,255);
+    diaElemUInteger   chromaLock(PX(chromaLock),_(&quot;Chroma  Lock&quot;),0,255);
+    diaElemUInteger   lumaThreshold(PX(lumaThreshold),_(&quot;Luma Threshold&quot;),0,255);
+    diaElemUInteger   chromaThreshold(PX(chromaThreshold),_(&quot;Chroma Threshold&quot;),0,255);
+    
+    diaElemUInteger   sceneChange(PX(sceneChange),_(&quot;Scene Change&quot;),0,100);
+    
+    
+    
+       diaElem *elems[5]={&amp;lumaLock,&amp;chromaLock,&amp;lumaThreshold,&amp;chromaThreshold,&amp;sceneChange};
+  
+   return diaFactoryRun(&quot;Denoise&quot;,5,elems);
+}
+
+// EOF

Copied: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidDenoise.h (from rev 2489, branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidDenoise.h)

Copied: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidForcedPP.cpp (from rev 2530, branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidForcedPP.cpp)
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidForcedPP.cpp	2006-11-01 11:17:21 UTC (rev 2530)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidForcedPP.cpp	2007-01-11 20:41:19 UTC (rev 2705)
@@ -0,0 +1,232 @@
+//
+// C++ Implementation: ADM_vidForcedPP
+//
+// Description: 
+//
+//	Force postprocessing assuming constant quant &amp; image type
+//	Uselefull on some badly authored DVD for example
+//
+// Author: mean &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>&gt;, (C) 2004
+//
+// Copyright: See COPYING file that comes with this distribution
+//
+//
+
+#include &lt;stdio.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;string.h&gt;
+#include &lt;ADM_assert.h&gt;
+#include &lt;math.h&gt;
+#include &lt;math.h&gt;
+#include &lt;iconv.h&gt;
+#include &quot;config.h&quot;
+
+
+#include &quot;fourcc.h&quot;
+#include &quot;avio.hxx&quot;
+
+#include &quot;avi_vars.h&quot;
+
+#include &quot;ADM_toolkit/toolkit.hxx&quot;
+#include &quot;ADM_editor/ADM_edit.hxx&quot;
+#include &quot;ADM_video/ADM_genvideo.hxx&quot;
+
+#include &quot;ADM_osSupport/ADM_debugID.h&quot;
+#define MODULE_NAME MODULE_FILTER
+#include &quot;ADM_osSupport/ADM_debug.h&quot;
+
+
+
+#include &quot;ADM_vidForcedPP.h&quot;
+#include &quot;DIA_enter.h&quot;
+#include &quot;ADM_filter/video_filters.h&quot;
+
+#include &quot;ADM_userInterfaces/ADM_commonUI/DIA_factory.h&quot;
+
+static FILTER_PARAM ppParam={3,{&quot;postProcType&quot;,&quot;postProcStrength&quot;,&quot;forcedQuant&quot;}};
+
+
+SCRIPT_CREATE(forcedpp_script,ADMVideoForcedPP,ppParam);
+BUILD_CREATE(forcedpp_create,ADMVideoForcedPP);
+
+extern int DIA_getMPParams( uint32_t *pplevel, uint32_t *ppstrength,uint32_t *swap);
+
+uint8_t ADMVideoForcedPP::configure( AVDMGenericVideoStream *instream)
+{
+	_in=instream;
+        
+        #define PX(x) &amp;(_param-&gt;x)
+  
+        
+    diaElemUInteger   postProcStrength(PX(postProcStrength),_(&quot;Filter Strength&quot;),0,5);
+    diaElemUInteger   quant(PX(forcedQuant),_(&quot;Quantizer&quot;),1,31);
+    //diaElemToggle     swapuv(PX(swapuv),_(&quot;Swap U&amp;V&quot;));
+    
+    uint32_t hzd,vzd,dring;
+    
+#define DOME(x,y) if(_param-&gt;postProcType &amp; x) y=1;else y=0;
+    
+    DOME(1,hzd);
+    DOME(2,vzd);
+    DOME(4,dring);
+    
+     diaElemToggle     fhzd(&amp;hzd,_(&quot;Horizontal Deblocking&quot;));
+     diaElemToggle     fvzd(&amp;vzd,_(&quot;Vertical Deblocking&quot;));
+     diaElemToggle     fdring(&amp;dring,_(&quot;Deringing&quot;));
+    
+    
+    
+      diaElem *elems[5]={&amp;postProcStrength,&amp;quant,&amp;fhzd
+                        ,&amp;fvzd,&amp;fdring};
+
+   if(diaFactoryRun(&quot;Forced PostProcessing&quot;,5,elems))
+  {
+#undef DOME
+#define DOME(x,y) if(y) _param-&gt;postProcType |=x;
+    _param-&gt;postProcType =0;
+    DOME(1,hzd);
+    DOME(2,vzd);
+    DOME(4,dring);
+    updatePostProc(&amp;_postproc );	
+    return 1;
+  }
+  return 0;	
+ 	
+}
+uint8_t	ADMVideoForcedPP::getCoupledConf( CONFcouple **couples)
+{
+
+			*couples=new CONFcouple(3);
+
+			CSET(postProcType);
+			CSET(postProcStrength);
+			CSET(forcedQuant);
+
+		return 1;	
+}
+char *ADMVideoForcedPP::printConf( void )
+{
+ 	static char buf[50];
+ 	
+ 	sprintf((char *)buf,&quot; Forced pp : %lu %lu&quot;,_param-&gt;postProcType,_param-&gt;postProcStrength);
+        return buf;
+}
+
+ADMVideoForcedPP::~ADMVideoForcedPP()
+{
+	if(_uncompressed)
+ 		delete _uncompressed;
+	if(_postproc.ppContext)
+		deletePostProc(&amp;_postproc);
+
+ 	_uncompressed=NULL;
+}
+
+
+ ADMVideoForcedPP::ADMVideoForcedPP( AVDMGenericVideoStream *in,CONFcouple *couples)
+{
+		printf(&quot;Adding forced PP filter\n&quot;);
+		_uncompressed=NULL;
+		_in=in;
+		ADM_assert(in);
+		if(!couples)
+		{
+			
+			_param=NEW(PP_CONF);
+	    		_param-&gt;postProcType=7; // all
+	    		_param-&gt;postProcStrength=5;
+			_param-&gt;forcedQuant=10;
+			
+	    	}
+		else
+		{
+			_param=NEW(PP_CONF);
+			GET(postProcType);
+			GET(postProcStrength);
+			GET(forcedQuant);
+			
+						
+		}
+		ADM_assert(in);
+		
+		memcpy(&amp;_info,_in-&gt;getInfo(),sizeof(_info));	
+		
+	    	initPostProc(&amp;_postproc,_info.width,_info.height);
+		_postproc.postProcType=_param-&gt;postProcType;
+		_postproc.postProcStrength=_param-&gt;postProcStrength;
+		_postproc.forcedQuant=_param-&gt;forcedQuant;
+		updatePostProc(&amp;_postproc);	    	
+	    	
+	    	//_uncompressed=new uint8_t[3*_info.width*_info.height];	
+		_uncompressed=new ADMImage(_info.width,_info.height);	
+		
+
+}
+uint8_t ADMVideoForcedPP::getFrameNumberNoAlloc(uint32_t frame,
+							uint32_t *len,
+							ADMImage *data,
+							uint32_t *flags)
+{
+		uint32_t page=_info.width*_info.height;
+		
+		*len=(page*3)&gt;&gt;1;
+		if(frame&gt;=_info.nb_frames) return 0;		
+		
+		if(!(_postproc.postProcType &amp;&amp; _postproc.postProcStrength) )
+		{
+			// disabled
+			if(!_in-&gt;getFrameNumberNoAlloc(frame, len,data,flags)) return 0;
+				
+			return 1;
+		
+		}
+			// we do postproc !
+			// keep
+			uint8_t *iBuff[3],*oBuff[3];
+			int strideTab[3],strideTab2[3];			
+				
+				
+			if(!_in-&gt;getFrameNumberNoAlloc(frame, len,_uncompressed,flags))
+			 		return 0;
+
+			oBuff[0]=YPLANE(data);
+                        oBuff[1]=VPLANE(data);
+                        oBuff[2]=UPLANE(data);
+
+				
+			iBuff[0]=YPLANE(_uncompressed);
+		 	iBuff[1]=VPLANE(_uncompressed);
+ 		 	iBuff[2]=UPLANE(_uncompressed);
+				
+				
+		        strideTab[0]=strideTab2[0]=_info.width;
+			strideTab[1]=strideTab2[1]=_info.width&gt;&gt;1;
+			strideTab[2]=strideTab2[2]=_info.width&gt;&gt;1;
+	
+			int type;
+			if(_uncompressed-&gt;flags&amp;AVI_KEY_FRAME)
+					type=1;
+			else if(_uncompressed-&gt;flags &amp; AVI_B_FRAME)
+					type=3;
+				else
+					type=2;
+		 	pp_postprocess(
+		      		iBuff,
+		        	strideTab,
+		        	oBuff,
+		        	strideTab2,
+				_info.width,
+		        	_info.height,
+		        	NULL,
+		          	0,
+		         	_postproc.ppMode,
+		          	_postproc.ppContext,
+		          	type); // I ?
+			  	
+			
+		
+			data-&gt;copyInfo(_uncompressed);	
+			//printf(&quot;Type:%d\n&quot;,type);
+	return 1;
+}
+

Copied: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidForcedPP.h (from rev 2489, branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidForcedPP.h)

Copied: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidMSharpen.cpp (from rev 2489, branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidMSharpen.cpp)
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidMSharpen.cpp	2006-10-31 15:59:58 UTC (rev 2489)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidMSharpen.cpp	2007-01-11 20:41:19 UTC (rev 2705)
@@ -0,0 +1,797 @@
+/***************************************************************************
+                          ADM_vidMSharpen  -  description
+                             -------------------
+    
+    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
+
+    Port of Donal Graft Msharpen which is (c) Donald Graft
+    <A HREF="http://www.neuron2.net">http://www.neuron2.net</A>
+    <A HREF="http://puschpull.org/avisynth/decomb_reference_manual.html">http://puschpull.org/avisynth/decomb_reference_manual.html</A>
+
+        It is a bit less efficient as we do hz &amp; vz blur separately
+        The formula has been changed a bit from 1 1 1 to 1 2 1
+        for speed aspect &amp; MMX  
+        Mean
+
+ ***************************************************************************/
+/*
+	Msharpen plugin for Avisynth -- performs detail-preserving smoothing.
+
+	Copyright (C) 2003 Donald A. Graft
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program; if not, write to the Free Software
+	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*/
+
+#include &quot;config.h&quot;
+#include &lt;stdio.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;string.h&gt;
+#include &lt;ADM_assert.h&gt;
+
+#include &quot;config.h&quot;
+#include &quot;fourcc.h&quot;
+#include &quot;avio.hxx&quot;
+#include &quot;avi_vars.h&quot;
+
+#include &quot;ADM_toolkit/toolkit.hxx&quot;
+#include &quot;ADM_editor/ADM_edit.hxx&quot;
+#include &quot;ADM_video/ADM_genvideo.hxx&quot;
+#include&quot;ADM_video/ADM_vidField.h&quot;
+#include&quot;ADM_video/ADM_cache.h&quot;
+
+#include &quot;ADM_osSupport/ADM_debugID.h&quot;
+#define MODULE_NAME MODULE_FILTER
+#include &quot;ADM_osSupport/ADM_debug.h&quot;
+
+#include &quot;ADM_osSupport/ADM_cpuCap.h&quot;
+#include &quot;ADM_filter/video_filters.h&quot;
+
+#include &quot;ADM_vidMSharpen_param.h&quot;
+
+#include &quot;ADM_userInterfaces/ADM_commonUI/DIA_factory.h&quot;
+
+class Msharpen : public AVDMGenericVideoStream
+{
+private:
+	MSHARPEN_PARAM	*_param;
+	VideoCache	*vidCache;
+        ADMImage        *blurrImg,*work;
+
+        uint32_t        invstrength;
+
+        void detect_edges(ADMImage *src, ADMImage *dst, unsigned char *dstp, int plane);
+        void blur_plane(ADMImage *src, ADMImage *blur, unsigned char *blurp, int plane) ;
+        void detect_edges_HiQ(ADMImage *src, ADMImage *dst, unsigned char *dstp, int plane);
+        void apply_filter(ADMImage *src,ADMImage *blur, ADMImage *dst, unsigned char *dstp, int plane) ;
+public:    
+
+			Msharpen(AVDMGenericVideoStream *in,CONFcouple *couples)   ;
+			~Msharpen();
+
+
+				 
+	char 		*printConf( void );
+	uint8_t 	configure(AVDMGenericVideoStream *in);
+	uint8_t		getCoupledConf( CONFcouple **couples);
+	uint8_t 	getFrameNumberNoAlloc(uint32_t frame, uint32_t *len, ADMImage *data,uint32_t *flags);
+};
+
+BUILD_CREATE(msharpen_create,Msharpen);
+static FILTER_PARAM msharpenParam={4,{&quot;mask&quot;, &quot;highq&quot;,&quot;threshold&quot;, &quot;strength&quot;}};
+
+
+SCRIPT_CREATE(msharpen_script,Msharpen,msharpenParam);
+//_______________________________________________
+
+Msharpen::Msharpen(AVDMGenericVideoStream *in,CONFcouple *couples)
+
+{
+	_in=in;		
+   	memcpy(&amp;_info,_in-&gt;getInfo(),sizeof(_info));    
+  	_info.encoding=1;
+	_uncompressed=NULL;		
+  	_info.encoding=1;
+
+
+	_param=new MSHARPEN_PARAM;
+	//
+	if(couples)
+		{
+			GET(mask);
+			GET(highq);
+			GET(strength);	
+			GET(threshold);	
+		}
+		else // Default
+  		{
+			_param-&gt;mask=0;       // Show mask
+			_param-&gt;highq=1;
+			_param-&gt;strength=100;	
+			_param-&gt;threshold=15;	
+		}
+                
+		invstrength=255-_param-&gt;strength;	
+		blurrImg=new ADMImage(_info.width,_info.height);
+                work=new ADMImage(_info.width,_info.height);
+    		vidCache=new VideoCache(5,in);
+}
+//________________________________________________________
+uint8_t	Msharpen::getCoupledConf( CONFcouple **couples)
+{
+	*couples=NULL;
+	*couples=new CONFcouple(4);
+#define CSET(x)  (*couples)-&gt;setCouple((char *)#x,(_param-&gt;x))
+		CSET(mask);
+		CSET(highq);
+		CSET(strength);	
+		CSET(threshold);	
+	return 1;
+}
+//________________________________________________________
+Msharpen::~Msharpen(void)
+{
+
+	if(vidCache) delete vidCache;
+	if(_param) delete _param;
+	if(blurrImg) delete blurrImg;
+        if(work) delete work;
+	vidCache=NULL;
+	_param=NULL;
+	blurrImg=NULL;
+        work=NULL;
+}
+extern uint8_t DIA_getMSharpen(MSHARPEN_PARAM *param);
+//________________________________________________________
+uint8_t Msharpen::configure(AVDMGenericVideoStream *in)
+{
+uint8_t r=0;
+	_in=in;
+	ADM_assert(_param);
+
+#define PX(x) &amp;(_param-&gt;x)
+  
+        
+    diaElemToggle    mask(PX(mask),_(&quot;Mask&quot;));
+    diaElemToggle    highq(PX(highq),_(&quot;High Q&quot;));
+    
+    diaElemUInteger   threshold(PX(threshold),_(&quot;Threshold&quot;),1,255);
+    diaElemUInteger   strength(PX(strength),_(&quot;Strength&quot;),1,255);
+    
+    
+  diaElem *elems[4]={&amp;mask,&amp;highq,&amp;threshold,&amp;strength};
+
+  if(diaFactoryRun(&quot;MSharpen&quot;,4,elems))
+  {
+         invstrength=255-_param-&gt;strength;
+         return 1;
+  }
+  return 0;
+}
+
+//________________________________________________________
+char *Msharpen::printConf( void )
+{
+ 	static char buf[50];
+
+	ADM_assert(_param);
+ 	sprintf((char *)buf,&quot; Donald Graft Msharpen Strength:%d Threshold:%d&quot;,_param-&gt;strength,_param-&gt;threshold);
+        return buf;
+}
+	
+//________________________________________________________
+uint8_t Msharpen::getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
+				ADMImage *data,uint32_t *flags)
+{
+ADMImage *src,*blur,*dst;
+/*
+	PVideoFrame src = child-&gt;GetFrame(n, env);
+	PVideoFrame blur = env-&gt;NewVideoFrame(vi);
+	PVideoFrame dst = env-&gt;NewVideoFrame(vi);
+*/
+unsigned char *blurp;
+unsigned char *dstp;
+	dst=data;
+	if(frame&gt;=_info.nb_frames) return 0;
+	src=vidCache-&gt;getImage(frame);
+	blur=blurrImg;
+	{
+		for (int i=0;i&lt;3;i++)
+		{
+		
+			//unsigned char *blurp = blur-&gt;GetWritePtr(plane);
+			switch(i)
+			{
+				case 0:blurp=YPLANE(blur);break;
+				case 1:blurp=UPLANE(blur);break;
+				case 2:blurp=VPLANE(blur);break;
+			}
+			blur_plane(src, blur, blurp ,i);
+
+		//	unsigned char *dstp = dst-&gt;GetWritePtr(plane);
+			switch(i)
+			{
+				case 0:dstp=YPLANE(dst);break;
+				case 1:dstp=UPLANE(dst);break;
+				case 2:dstp=VPLANE(dst);break;
+			}
+
+			detect_edges(blur, dst, dstp, i);
+			if (_param-&gt;highq == true)
+				detect_edges_HiQ(blur, dst, dstp, i);
+
+			if (!_param-&gt;mask) apply_filter(src, blur, dst, dstp, i);
+		}
+	}
+
+	vidCache-&gt;unlockAll();
+	return 1;
+}
+
+/**********************************
+ * MMX / ISSE by Klaus Post and Milan Cutka.
+ *
+ * Delivers same result as YUY2, except planes
+ *  are processed independently.
+ *********************************/
+
+void Msharpen::blur_plane(ADMImage *src, ADMImage *blur, unsigned char *blurp, int plane) 
+{
+/*
+  uint64_t mask1 = 0x00001C711C711C71LL;
+  uint64_t mask2 = 0x1C711C711C710000LL;
+  uint64_t mask3 = 0x0000200000002000LL;
+  uint64_t mask4 = 0x0000000000ff0000LL;
+
+  const unsigned char *srcp = src-&gt;GetReadPtr(plane);
+	const unsigned char *srcp_saved = srcp;
+	unsigned char *blurp_saved = blurp;
+  int src_pitch = src-&gt;GetPitch(plane);
+  int blur_pitch = blur-&gt;GetPitch(plane);
+  int h = src-&gt;GetHeight(plane);
+  int w = src-&gt;GetRowSize(plane);
+*/
+const unsigned char *srcp,*srcpn,*srcpp; 
+const unsigned char *srcp_saved ;
+unsigned char *wk,*wk_saved;
+unsigned char *blurp_saved ;
+int src_pitch;
+int blur_pitch;
+int h;
+int w ;
+int wh ,ww,hh;
+ 	blurp_saved=blurp;
+	switch(plane)
+		{
+			case 0:
+				srcp_saved=srcp=YPLANE(src);        
+                                wk_saved=wk=YPLANE(work);
+				ww=_info.width;
+				hh=_info.height;
+				break;
+			case 1:
+				srcp_saved=srcp=UPLANE(src);
+                                wk_saved=wk=UPLANE(work);
+				ww=_info.width&gt;&gt;1;
+				hh=_info.height&gt;&gt;1;
+				break;
+			case 2:
+				srcp_saved=srcp=VPLANE(src);
+                                wk_saved=wk=VPLANE(work);
+				ww=_info.width&gt;&gt;1;
+				hh=_info.height&gt;&gt;1;
+				break;
+		}
+		src_pitch=ww;
+		blur_pitch=ww;
+		w=ww;
+		h=hh;
+ 
+  
+  wk+=blur_pitch;
+  srcpp=srcp;
+  srcp+=src_pitch,
+  srcpn=srcp+src_pitch;
+  int val;
+
+  // Vertical only for now      
+#if (defined( ARCH_X86)  || defined(ARCH_X86_64))
+  if(CpuCaps::hasMMX())
+  {
+  int off;
+#ifdef GCC_2_95_X
+        __asm__(
+                        &quot;.align 16\n&quot;
+                        &quot;pxor  %mm7,%mm7\n&quot;
+                : : );
+#else
+        __asm__(
+                        &quot;.align 16\n&quot;
+                        &quot;pxor  %%mm7,%%mm7\n&quot;
+                : : );
+#endif
+                        
+  for (int y=1; y&lt;h-1 ;y++) 
+  {               
+        for (int x =  (w&gt;&gt;3);x&gt;0; x--)
+                {
+                        off=x&lt;&lt;3;                        
+                        __asm__(
+                        &quot;.align 16\n&quot;                      
+                        &quot;movq  (%0),%%mm0\n&quot;
+                        &quot;movq  %%mm0,%%mm6\n&quot;
+                        &quot;punpckhbw %%mm7,%%mm0\n&quot; // High part extended to 16 bits
+                        &quot;punpcklbw %%mm7,%%mm6\n&quot; // low part ditto
+                        
+                        &quot;movq  (%1),%%mm1\n&quot;
+                        &quot;movq  %%mm1,%%mm5\n&quot;
+                        &quot;punpckhbw %%mm7,%%mm1\n&quot;
+                        &quot;punpcklbw %%mm7,%%mm5\n&quot;
+                        
+                        &quot;movq  (%2),%%mm2\n&quot;
+                        &quot;movq  %%mm2,%%mm4\n&quot;
+                        &quot;punpckhbw %%mm7,%%mm2\n&quot;
+                        &quot;punpcklbw %%mm7,%%mm4\n&quot;
+                        
+                        &quot;paddw %%mm1,%%mm0\n&quot;
+                        &quot;paddw %%mm5,%%mm6\n&quot;
+                        
+                        &quot;paddw %%mm1,%%mm2\n&quot;
+                        &quot;paddw %%mm5,%%mm4\n&quot;
+                        
+                        &quot;paddw %%mm0,%%mm2\n&quot;
+                        &quot;paddw %%mm6,%%mm4\n&quot;
+                        &quot;psrlw $2, %%mm4\n&quot;
+                        &quot;psrlw $2, %%mm2\n&quot;
+                        &quot;packuswb %%mm2,%%mm4\n&quot;
+                        &quot;movq %%mm4,(%3)\n&quot; //
+                        
+                        : : &quot;r&quot; (srcpn+off),
+                           &quot;r&quot; (srcp+off), &quot;r&quot; (srcpp+off), &quot;r&quot; (wk+off)
+                        );
+                }                        
+        srcp+=src_pitch;
+        srcpp+=src_pitch;
+        srcpn+=src_pitch;
+        wk+=src_pitch;     
+  }
+  __asm__(&quot;emms\n&quot;);
+ }
+ else
+#endif      
+  {
+  for (int y=1; y&lt;h-1 ;y++) 
+  {       
+
+        for(int x=0;x&lt;w;x++)
+        {
+                val=srcp[x]+srcpn[x]+srcpp[x]+srcp[x];
+                wk[x]=(val)&gt;&gt;2;
+        } 
+        srcp+=src_pitch;
+        srcpp+=src_pitch;
+        srcpn+=src_pitch;
+        wk+=src_pitch;     
+  }
+  }
+  //************ Horizontal****************
+  blurp=blurp_saved;
+  srcp=wk_saved;
+  for (int y=1; y&lt;h-1 ;y++) 
+  {         
+        for(int x=1;x&lt;w-1;x++)
+        {
+                val=srcp[x-1]+srcp[x]+srcp[x+1]+srcp[x];
+                blurp[x]=val&gt;&gt;2;
+        } 
+        srcp+=src_pitch;
+        srcpp+=src_pitch;
+        srcpn+=src_pitch;
+        blurp+=src_pitch;     
+  }
+  //******************
+        /* Fix up blur frame borders. */
+        srcp = srcp_saved;
+        blurp = blurp_saved;
+        memcpy(blurp, srcp, w);
+        memcpy(blurp + (h-1)*blur_pitch, srcp + (h-1)*src_pitch, w);
+        for (int y = 0; y &lt; h; y++)
+        {
+                blurp[0] = srcp[0];
+                blurp[w-1] = srcp[w-1];
+                srcp += src_pitch;
+                blurp += blur_pitch;
+        }
+
+}
+#if 0
+    __asm {
+      mov esi, srcp  // esi=srcpp
+      mov ecx, blurp
+      mov ebx, src_pitch
+      mov edi, esi 
+      mov edx, esi 
+      add edi, ebx // edi=srcp+pitch=srcp
+      add edx, ebx 
+      add edx, ebx  //edx=srcp+2*pitch=srcpn
+      xor eax, eax
+      movq mm7,mask1 // mm7 mask1
+      movq mm6,mask2 // mm6 mask2
+     align 16
+xloop:
+      movd mm0,[esi+eax]  //srcpp[x}
+      pxor mm5,mm5
+       movd mm1,[edi+eax] //srcp[x}
+      movd mm2,[edx+eax]  // srcpn   
+      punpcklbw mm0,mm5  // mm0 low srcpp
+      punpcklbw mm1,mm5   // mm1 low srcp
+      movq mm3, mm0
+      punpcklbw mm2,mm5   // mm2 low srcn
+      movq mm4, mm1
+      movq mm5, mm2
+      paddw mm0,mm1     // srcp+srcpp
+      paddw mm3,mm4   // 2*srcp+srcpp
+      paddw mm0,mm2    // 2*srcp+srcpp+srcn
+      paddw mm3,mm5   // idem
+      pmaddwd mm0,mm7
+       movq mm5,[mask3]
+      pmaddwd mm3,mm6
+       pshufw mm1,mm0, 11101110b  // Move upper to lower
+      pshufw mm4,mm3, 11101110b   
+       paddd mm0,mm1
+      paddd mm3,mm4
+       paddd mm0, mm5
+      paddd mm3, mm5
+       psrld mm0,16
+      pand mm3,[mask4]
+      psrld mm3,8
+      por mm0,mm3
+      movd [eax+ecx],mm0  // blurp[i]
+      add eax,2
+      cmp eax,[w]
+      jle xloop;
+    }
+    srcp += src_pitch;
+    blurp += blur_pitch;
+//      __asm emms;
+#endif
+ 
+
+//***************************************************
+void Msharpen::detect_edges(ADMImage *src, ADMImage *dst, unsigned char *dstp, int plane) 
+{
+  static uint64_t m255=0xffffffffffffffffLL;
+  static uint64_t threshold64;
+  int ww,hh;
+
+  threshold64=_param-&gt;threshold;
+  if(!threshold64) threshold64=1;
+  threshold64=threshold64+(threshold64&lt;&lt;8)+(threshold64&lt;&lt;16)+(threshold64&lt;&lt;24)+(threshold64&lt;&lt;32)+(threshold64&lt;&lt;40)+(threshold64&lt;&lt;48)+(threshold64&lt;&lt;56);
+/*
+  const unsigned char *srcp = src-&gt;GetReadPtr(plane);
+  int src_pitch = src-&gt;GetPitch(plane);
+  int dst_pitch = dst-&gt;GetPitch(plane);
+  const unsigned char *srcpn = srcp+src_pitch;
+  int h = src-&gt;GetHeight(plane);
+  int w = src-&gt;GetRowSize(plane);
+*/
+  const unsigned char *srcp,*srcp_saved; 
+  int src_pitch ;
+  int dst_pitch ; 
+  const unsigned char *srcpn; 
+  int h ;
+  int w ;
+  unsigned char *dstp_saved = dstp;
+
+  switch(plane)
+	{
+		case 0: srcp=YPLANE(src);
+			ww=_info.width;
+			hh=_info.height;
+			break;
+		case 2:
+		case 1:
+			if(plane==1) 	
+				srcp=UPLANE(src);
+			else
+				srcp=VPLANE(src);
+			ww=_info.width&gt;&gt;1;
+			hh=_info.height&gt;&gt;1;
+			break;
+		default:
+			ADM_assert(0);
+	}
+	src_pitch=ww;
+	dst_pitch=ww;
+	w=ww;
+	h=hh;
+	srcpn=srcp+src_pitch;
+	srcp_saved=srcp;
+
+ int p,n,c;
+ for (int y=0;y&lt;h-1;y++)
+  {
+   for(int xx=1;xx&lt;w-1;xx++)
+        {
+                p=srcp[xx+1];
+                n=srcpn[xx+1];
+                c=srcpn[xx-1];
+                
+                if(abs(n-p)&gt;_param-&gt;threshold || abs(c-p)&gt;_param-&gt;threshold) dstp[xx+1]=0xff;
+                                else dstp[xx+1]=0;
+                
+        }
+   srcp+=src_pitch;
+   srcpn+=src_pitch;
+   dstp+=dst_pitch;
+  }
+  if (_param-&gt;mask) {
+    dstp=dstp_saved;
+    memset(dstp_saved+(h-1)*dst_pitch,0,w);  // Not used, if not returning mask
+    for (int y=0;y&lt;h;dstp+=dst_pitch,y++) {
+      dstp[0]=0;
+      dstp[1]=0;
+      dstp[w-1]=0;
+      dstp[w-2]=0;
+    }
+  }
+}
+#if 0
+unsigned char *dstpend=dstp+w-1;
+   __asm 
+    {
+     mov esi,[srcp]
+     inc esi
+     mov ecx,[srcpn]
+     inc ecx
+     mov edx,[srcpn]
+     dec edx
+     mov edi,[dstp]
+     inc edi
+     mov eax,[dstpend]
+     movq mm6,[threshold64]
+     pxor mm5,mm5
+     movq mm4,[m255]
+     align 16
+    diag1:
+     movq mm2,[ecx]
+      movq mm1,[esi]
+     movq mm3,[edx]
+
+     //abs(mm1-mm2)
+      movq mm7,mm1
+     pminub mm1,mm2  //srcpn+1 - srcp+1
+      pmaxub mm2,mm7
+     psubusb mm2,mm1
+      movq mm1,[esi]
+     psubusb mm2,mm6
+     
+     //abs(mm1-mm3)
+      movq mm7,mm1
+     pminub mm1,mm3 // srcp+1 srcp-1
+      pmaxub mm3,mm7
+     psubusb mm3,mm1
+     psubusb mm3,mm6
+
+     por     mm2,mm3
+     pcmpeqb mm2,mm5
+     pxor    mm2,mm4
+     movq    [edi],mm2
+     
+     add esi,8
+     add ecx,8
+     add edx,8
+     add edi,8
+     cmp edi,eax
+     jl  diag1
+
+   }
+__asm emms;
+#endif
+//***************************************************
+void Msharpen::detect_edges_HiQ(ADMImage *src, ADMImage *dst, unsigned char *dstp, int plane) 
+{
+  // Vertical detail detection
+/*
+  const unsigned char *srcp = src-&gt;GetReadPtr(plane);
+	const unsigned char *srcp_saved = srcp;
+  const unsigned char *srcpn;
+	unsigned char *dstp_saved = dstp;
+  int src_pitch = src-&gt;GetPitch(plane);
+  int dst_pitch = dst-&gt;GetPitch(plane);
+  int h = src-&gt;GetHeight(plane);
+  int w = src-&gt;GetRowSize(plane);
+*/
+
+  int b1,b2;
+  int ww,hh;
+ const unsigned char *srcp,*srcp_saved; 
+  int src_pitch ;
+  int dst_pitch ; 
+  const unsigned char *srcpn; 
+  int h ;
+  int w ;
+  unsigned char *dstp_saved = dstp;
+
+  switch(plane)
+	{
+		case 0: srcp=YPLANE(src);
+			ww=_info.width;
+			hh=_info.height;
+			break;
+		case 2:
+		case 1:
+			if(plane==1) 	
+				srcp=UPLANE(src);
+			else
+				srcp=VPLANE(src);
+			ww=_info.width&gt;&gt;1;
+			hh=_info.height&gt;&gt;1;
+			break;
+		default:
+			ADM_assert(0);
+	}
+	src_pitch=ww;
+	dst_pitch=ww;
+	w=ww;
+	h=hh;
+	srcpn=srcp+src_pitch;
+	srcp_saved=srcp;
+
+  for (int x=0;x&lt;w;x++)
+  {
+    srcp=srcp_saved;
+    srcpn=srcp+src_pitch;
+    dstp=dstp_saved;
+    b1=srcp[x];
+    for (int y=0;y&lt;h-1;dstp+=dst_pitch,srcp+=src_pitch,srcpn+=src_pitch,y++)
+    {
+      b2=srcpn[x];
+      if (abs(b1-b2)&gt;=_param-&gt;threshold)
+        dstp[x]=255;
+      b1=b2;
+    }
+  }
+  
+  // Horizontal detail detection
+  srcp=srcp_saved;
+  dstp=dstp_saved;
+  for (int y=0;y&lt;h;dstp+=dst_pitch,srcp+=src_pitch,y++)
+  {
+    b1=srcp[0]; //MEANX srcp[x]
+    for (int x=0;x&lt;w-1;x++)
+    {
+      b2=srcp[x+1];
+      if (abs(b1-b2)&gt;=_param-&gt;threshold)
+        dstp[x]=255;
+      b1=b2;
+    }
+  }
+  // Fix up detail map borders
+  dstp = dstp_saved;
+  memset(dstp,0,w);
+  memset(dstp+dst_pitch,0,w);
+  memset(dstp+(h-2)*dst_pitch,0,w);
+  memset(dstp+(h-1)*dst_pitch,0,w);
+  for (int y=0;y&lt;h;dstp+=dst_pitch,y++)
+  {
+    dstp[0]=0;
+    dstp[1]=0;
+    dstp[w-1]=0;
+    dstp[w-2]=0;
+  }
+}
+//***************************************************
+void Msharpen::apply_filter(ADMImage *src,ADMImage *blur, ADMImage *dst, unsigned char *dstp, int plane) 
+{
+  // TODO: MMX / ISSE
+/*
+  const unsigned char *srcp = src-&gt;GetReadPtr(plane);
+  const unsigned char *blurp = blur-&gt;GetReadPtr(plane);
+  const unsigned char *srcp_saved = srcp;
+  unsigned char *dstp_saved = dstp;
+  const unsigned char *blurp_saved = blurp;
+  int src_pitch = src-&gt;GetPitch(plane);
+  int blur_pitch = blur-&gt;GetPitch(plane);
+  int dst_pitch = dst-&gt;GetPitch(plane);
+  int h = src-&gt;GetHeight(plane);
+  int w = src-&gt;GetRowSize(plane);
+ */
+  const unsigned char *srcp ;
+  const unsigned char *blurp ;
+  const unsigned char *srcp_saved; 
+  unsigned char *dstp_saved ;
+  const unsigned char *blurp_saved ;
+  int src_pitch;
+  int blur_pitch;
+  int dst_pitch;
+  int h;
+  int w;
+  int ww,hh; 
+
+  switch(plane)
+	{
+		case 0:
+			 srcp=YPLANE(src);
+			 blurp=YPLANE(blur);
+			 ww=_info.width;
+			 hh=_info.height;
+			 break;
+		case 1:
+		case 2:
+			if(plane==1)
+			{
+			 srcp=UPLANE(src);
+			 blurp=UPLANE(blur);
+			}
+			else
+			{
+			 srcp=VPLANE(src);
+			 blurp=VPLANE(blur);
+			}
+			 ww=_info.width&gt;&gt;1;
+			 hh=_info.height&gt;&gt;1;
+			break;
+	}
+
+	w=ww;
+	h=hh;
+	blur_pitch=ww;
+	dst_pitch=ww;
+	src_pitch=ww;
+	srcp_saved=srcp;
+	blurp_saved=blurp;
+	dstp_saved=dstp;
+	
+  memcpy(dstp,srcp,w);
+  memcpy(dstp+(h-1)*dst_pitch,srcp+(h-1)*src_pitch,w);
+  for (int y=0;y&lt;h;srcp+=src_pitch,dstp+=dst_pitch,y++)
+  {
+    dstp[0]=srcp[0];
+    dstp[w-1]=srcp[w-1];
+  }
+  
+  // Now sharpen the edge areas and we're done
+  srcp=srcp_saved+src_pitch;
+  dstp=dstp_saved+dst_pitch;
+  blurp=blurp+dst_pitch;
+  int b4;
+  for (int y=1;y&lt;h-1;srcp+=src_pitch,dstp+=dst_pitch,blurp+=blur_pitch,y++)
+  {
+    for (int x=1;x&lt;w-1;)
+    {
+      if (*(int*)(dstp+x)==0) 
+      {
+        *(int*)(dstp+x)=*(int*)(srcp+x);
+        x+=4;
+        continue;
+      }
+      if (dstp[x])
+      {                                     
+        b4=4*int(srcp[x])-3*int(blurp[x]);
+        if (b4&lt;0) b4=0; else if (b4&gt;255) b4=255;
+        dstp[x]=(_param-&gt;strength*b4+invstrength*srcp[x])&gt;&gt;8;
+      }
+      else
+        dstp[x]=srcp[x];
+      x++; 
+    }  
+    dstp[w-1]=srcp[w-1]; 
+  }   
+}
+//***************************************************
+
+
+
+
+

Copied: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidMSharpen_param.h (from rev 2489, branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidMSharpen_param.h)

Modified: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/Makefile.am
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/Makefile.am	2007-01-11 19:18:08 UTC (rev 2704)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/Makefile.am	2007-01-11 20:41:19 UTC (rev 2705)
@@ -7,6 +7,9 @@
 #INCLUDES = $(all_includes) 
 
 libADM_videoFilter_a_SOURCES =  \
+ ADM_vidForcedPP.cpp \
+ ADM_vidMSharpen.cpp \
+ ADM_vidDenoise.cpp \
  ADM_vidMPLD3D.cpp \
  ADM_vidMPLD3Dlow.cpp \
  ADM_lavpp_deint.cpp \


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000032.html">[Avidemux-svn-commit] r2704 - in	branches/avidemux_2.4_branch/avidemux:	ADM_userInterfaces/ADM_GTK/ADM_dialog	ADM_userInterfaces/ADM_GTK/ADM_dialogFactory	ADM_userInterfaces/ADM_NONE/ADM_dialog	ADM_userInterfaces/ADM_QT4/ADM_dialog ADM_video ADM_videoFilter
</A></li>
	<LI>Next message: <A HREF="000034.html">[Avidemux-svn-commit] r2706 -	branches/avidemux_2.4_branch/avidemux/ADM_codecs
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#33">[ date ]</a>
              <a href="thread.html#33">[ thread ]</a>
              <a href="subject.html#33">[ subject ]</a>
              <a href="author.html#33">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">More information about the Avidemux-svn-commit
mailing list</a><br>
</body></html>
