<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Avidemux-svn-commit] r2746 - in	branches/avidemux_2.4_branch/avidemux:	ADM_inputs/ADM_mpegdemuxer ADM_toolkit	ADM_userInterfaces/ADM_GTK/ADM_dialog	ADM_userInterfaces/ADM_NONE/ADM_dialog	ADM_userInterfaces/ADM_QT4/ADM_dialog	ADM_userInterfaces/ADM_commonUI
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/avidemux-svn-commit/2007-January/index.html" >
   <LINK REL="made" HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r2746%20-%20in%0A%09branches/avidemux_2.4_branch/avidemux%3A%0A%09ADM_inputs/ADM_mpegdemuxer%20ADM_toolkit%0A%09ADM_userInterfaces/ADM_GTK/ADM_dialog%0A%09ADM_userInterfaces/ADM_NONE/ADM_dialog%0A%09ADM_userInterfaces/ADM_QT4/ADM_dialog%0A%09ADM_userInterfaces/ADM_commonUI&In-Reply-To=%3C200701201516.l0KFG25k003038%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000072.html">
   <LINK REL="Next"  HREF="000074.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Avidemux-svn-commit] r2746 - in	branches/avidemux_2.4_branch/avidemux:	ADM_inputs/ADM_mpegdemuxer ADM_toolkit	ADM_userInterfaces/ADM_GTK/ADM_dialog	ADM_userInterfaces/ADM_NONE/ADM_dialog	ADM_userInterfaces/ADM_QT4/ADM_dialog	ADM_userInterfaces/ADM_commonUI</H1>
    <B>mean at BerliOS</B> 
    <A HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r2746%20-%20in%0A%09branches/avidemux_2.4_branch/avidemux%3A%0A%09ADM_inputs/ADM_mpegdemuxer%20ADM_toolkit%0A%09ADM_userInterfaces/ADM_GTK/ADM_dialog%0A%09ADM_userInterfaces/ADM_NONE/ADM_dialog%0A%09ADM_userInterfaces/ADM_QT4/ADM_dialog%0A%09ADM_userInterfaces/ADM_commonUI&In-Reply-To=%3C200701201516.l0KFG25k003038%40sheep.berlios.de%3E"
       TITLE="[Avidemux-svn-commit] r2746 - in	branches/avidemux_2.4_branch/avidemux:	ADM_inputs/ADM_mpegdemuxer ADM_toolkit	ADM_userInterfaces/ADM_GTK/ADM_dialog	ADM_userInterfaces/ADM_NONE/ADM_dialog	ADM_userInterfaces/ADM_QT4/ADM_dialog	ADM_userInterfaces/ADM_commonUI">mean at mail.berlios.de
       </A><BR>
    <I>Sat Jan 20 16:16:02 CET 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="000072.html">[Avidemux-svn-commit] r2745 -	branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer
</A></li>
        <LI>Next message: <A HREF="000074.html">[Avidemux-svn-commit] r2747 -	branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#73">[ date ]</a>
              <a href="thread.html#73">[ thread ]</a>
              <a href="subject.html#73">[ subject ]</a>
              <a href="author.html#73">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: mean
Date: 2007-01-20 16:15:58 +0100 (Sat, 20 Jan 2007)
New Revision: 2746

Added:
   branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_probeTS.cpp
Modified:
   branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/Makefile.am
   branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_demuxer.h
   branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_demuxerES.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_demuxerEs.h
   branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_demuxerMSDVR.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_demuxerMSDVR.h
   branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_demuxerPS.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_demuxerPS.h
   branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_demuxerTS.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_demuxerTS.h
   branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_identify.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_identify.h
   branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_indexer.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_indexer.h
   branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_io.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_io.h
   branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_probe.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_probe.h
   branches/avidemux_2.4_branch/avidemux/ADM_toolkit/automation.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_idx_pg.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_NONE/ADM_dialog/DIA_indexing.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/DIA_indexing.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_idx_pg.h
Log:
use PAT/PMT

Modified: branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/Makefile.am
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/Makefile.am	2007-01-20 10:44:43 UTC (rev 2745)
+++ branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/Makefile.am	2007-01-20 15:15:58 UTC (rev 2746)
@@ -6,7 +6,7 @@
 
 libADM_mpegdemuxer_a_METASOURCES = AUTO
 
-libADM_mpegdemuxer_a_SOURCES = dmx_io.cpp dmx_demuxer.cpp dmx_indexer.cpp dmx_demuxerES.cpp dmx_video.cpp dmx_demuxerPS.cpp dmx_identify.cpp dmx_audio.cpp dmx_probe.cpp dmx_demuxerTS.cpp dmx_demuxerMSDVR.cpp dmx_demuxerMSDVR.h
+libADM_mpegdemuxer_a_SOURCES = dmx_io.cpp dmx_demuxer.cpp dmx_indexer.cpp dmx_demuxerES.cpp dmx_video.cpp dmx_demuxerPS.cpp dmx_identify.cpp dmx_audio.cpp dmx_probe.cpp dmx_probeTS.cpp dmx_demuxerTS.cpp dmx_demuxerMSDVR.cpp dmx_demuxerMSDVR.h
 
 
 EXTRA_DIST = dmx_audio.cpp      dmx_demuxerEs.h  \

Modified: branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_demuxer.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_demuxer.h	2007-01-20 10:44:43 UTC (rev 2745)
+++ branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_demuxer.h	2007-01-20 15:15:58 UTC (rev 2746)
@@ -33,7 +33,7 @@
 	  		   dmx_demuxer();
 		virtual    ~dmx_demuxer();	       
 		
-		virtual    uint8_t   	open(char *name)=0;
+		virtual    uint8_t   	open(const char *name)=0;
 	        virtual    uint8_t      hasAudio(void) { return 0;}                
 		
 		virtual uint8_t 	forward(uint32_t f)=0;

Modified: branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_demuxerES.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_demuxerES.cpp	2007-01-20 10:44:43 UTC (rev 2745)
+++ branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_demuxerES.cpp	2007-01-20 15:15:58 UTC (rev 2746)
@@ -40,7 +40,7 @@
         if(parser) delete parser;
         parser=NULL;
 }
-uint8_t dmx_demuxerES::open(char *name)
+uint8_t dmx_demuxerES::open(const char *name)
 {
 FP_TYPE fp=FP_DONT_APPEND;
         if(! parser-&gt;open(name,&amp;fp)) return 0;

Modified: branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_demuxerEs.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_demuxerEs.h	2007-01-20 10:44:43 UTC (rev 2745)
+++ branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_demuxerEs.h	2007-01-20 15:15:58 UTC (rev 2746)
@@ -33,7 +33,7 @@
                            dmx_demuxerES() ;
                 virtual    ~dmx_demuxerES();             
                 
-                     uint8_t      open(char *name);
+                     uint8_t      open(const char *name);
                  
                 
                   uint8_t         forward(uint32_t f);

Modified: branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_demuxerMSDVR.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_demuxerMSDVR.cpp	2007-01-20 10:44:43 UTC (rev 2745)
+++ branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_demuxerMSDVR.cpp	2007-01-20 15:15:58 UTC (rev 2746)
@@ -373,7 +373,7 @@
           return 0;
 }
 /***********************************************/
-uint8_t dmx_demuxerMSDVR::open(char *name)
+uint8_t dmx_demuxerMSDVR::open(const char *name)
 {
   int r=5;
   const chunky *id=NULL;

Modified: branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_demuxerMSDVR.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_demuxerMSDVR.h	2007-01-20 10:44:43 UTC (rev 2745)
+++ branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_demuxerMSDVR.h	2007-01-20 15:15:58 UTC (rev 2746)
@@ -65,7 +65,7 @@
                 dmx_demuxerMSDVR(uint32_t nb,MPEG_TRACK *tracks,uint32_t multi) ;
     virtual    ~dmx_demuxerMSDVR();             
                 
-    uint8_t      open(char *name);
+    uint8_t      open(const char *name);
                  
                 
     uint8_t         forward(uint32_t f);

Modified: branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_demuxerPS.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_demuxerPS.cpp	2007-01-20 10:44:43 UTC (rev 2745)
+++ branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_demuxerPS.cpp	2007-01-20 15:15:58 UTC (rev 2746)
@@ -138,7 +138,7 @@
 		_probeSize=sz;
 		return 1;
 }
-uint8_t dmx_demuxerPS::open(char *name)
+uint8_t dmx_demuxerPS::open(const char *name)
 {
 FP_TYPE fp=FP_DONT_APPEND;
         if(_multi) fp=FP_APPEND;

Modified: branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_demuxerPS.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_demuxerPS.h	2007-01-20 10:44:43 UTC (rev 2745)
+++ branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_demuxerPS.h	2007-01-20 15:15:58 UTC (rev 2746)
@@ -60,7 +60,7 @@
                            dmx_demuxerPS(uint32_t nb,MPEG_TRACK *tracks,uint32_t multi) ;
                 virtual    ~dmx_demuxerPS();             
                 
-                     uint8_t      open(char *name);
+                     uint8_t      open(const char *name);
                  
                 
                   uint8_t         forward(uint32_t f);

Modified: branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_demuxerTS.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_demuxerTS.cpp	2007-01-20 10:44:43 UTC (rev 2745)
+++ branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_demuxerTS.cpp	2007-01-20 15:15:58 UTC (rev 2746)
@@ -112,7 +112,7 @@
 		_probeSize=sz;
 		return 1;
 }
-uint8_t dmx_demuxerTS::open(char *name)
+uint8_t dmx_demuxerTS::open(const char *name)
 {
 FP_TYPE fp=FP_DONT_APPEND;
         

Modified: branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_demuxerTS.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_demuxerTS.h	2007-01-20 10:44:43 UTC (rev 2745)
+++ branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_demuxerTS.h	2007-01-20 15:15:58 UTC (rev 2746)
@@ -70,7 +70,7 @@
                            dmx_demuxerTS(uint32_t nb,MPEG_TRACK *tracks,uint32_t psi) ;
                 virtual    ~dmx_demuxerTS();             
                 
-                     uint8_t      open(char *name);
+                     uint8_t      open(const char *name);
                  
                   fileParser      *getParser(void) {return parser;}
                   uint8_t         forward(uint32_t f);

Modified: branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_identify.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_identify.cpp	2007-01-20 10:44:43 UTC (rev 2745)
+++ branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_identify.cpp	2007-01-20 15:15:58 UTC (rev 2746)
@@ -36,7 +36,7 @@
 
 static uint8_t probeTs(fileParser *parser);
 
-DMX_TYPE dmxIdentify(char *name)
+DMX_TYPE dmxIdentify(const char *name)
 {
 DMX_TYPE ret=DMX_MPG_UNKNOWN;
 uint64_t pos;

Modified: branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_identify.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_identify.h	2007-01-20 10:44:43 UTC (rev 2745)
+++ branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_identify.h	2007-01-20 15:15:58 UTC (rev 2746)
@@ -13,5 +13,5 @@
         DMX_MPG_TS,
         DMX_MPG_MSDVR
 }DMX_TYPE;
-DMX_TYPE dmxIdentify(char *name);
+DMX_TYPE dmxIdentify(const char *name);
 #endif

Modified: branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_indexer.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_indexer.cpp	2007-01-20 10:44:43 UTC (rev 2745)
+++ branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_indexer.cpp	2007-01-20 15:15:58 UTC (rev 2746)
@@ -52,7 +52,7 @@
 static uint8_t gopDump(FILE *fd,dmx_demuxer *demuxer,uint64_t abs,uint64_t rel,uint32_t nbTracks);
 static uint8_t gopUpdate(dmx_demuxer *demuxer);
 uint8_t dumpPts(FILE *fd,dmx_demuxer *demuxer,uint64_t firstPts,uint32_t nbTracks);
-uint8_t dmx_indexer(char *mpeg,char *file);
+uint8_t dmx_indexer(const char *mpeg,char *file);
 
 static const uint32_t FPS[16]={
                 0,                      // 0
@@ -99,7 +99,7 @@
         Index the incoming mpeg file
 
 */
-uint8_t dmx_indexer(char *mpeg,char *file,uint32_t preferedAudio,uint8_t autosync,uint32_t nbTracks,MPEG_TRACK *tracks)
+uint8_t dmx_indexer(const char *mpeg,const char *file,uint32_t preferedAudio,uint8_t autosync,uint32_t nbTracks,MPEG_TRACK *tracks)
 {
         DIA_progressIndexing *work;
         dmx_demuxer *demuxer;

Modified: branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_indexer.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_indexer.h	2007-01-20 10:44:43 UTC (rev 2745)
+++ branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_indexer.h	2007-01-20 15:15:58 UTC (rev 2746)
@@ -18,6 +18,17 @@
  #ifndef DMX_INDX
  #define DMX_INDX
  
+typedef enum ADM_STREAM_TYPE
+{
+  ADM_STREAM_UNKNOWN=0,
+  ADM_STREAM_MPEG_VIDEO, 
+  ADM_STREAM_MPEG_AUDIO,
+  ADM_STREAM_AC3,
+  ADM_STREAM_DTS,
+  ADM_STREAM_H264,
+  ADM_STREAM_MPEG4
+};
+
 typedef struct MPEG_TRACK
 {
         uint16_t pid;
@@ -25,9 +36,11 @@
         // Only for audio...
         uint32_t channels;
         uint32_t bitrate;
+        // for Both
+        ADM_STREAM_TYPE streamType;
 }MPEG_TRACK;
 
-uint8_t dmx_indexer(char *mpeg,char *file,uint32_t preferedAudio,uint8_t autosync,uint32_t nbTracks,MPEG_TRACK *tracks);
+uint8_t dmx_indexer(const char *mpeg,const char *file,uint32_t preferedAudio,uint8_t autosync,uint32_t nbTracks,MPEG_TRACK *tracks);
         
 
 #endif

Modified: branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_io.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_io.cpp	2007-01-20 10:44:43 UTC (rev 2745)
+++ branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_io.cpp	2007-01-20 15:15:58 UTC (rev 2746)
@@ -69,7 +69,7 @@
         If multi is set to probe, return value will be APPEND if there is several files, dont_append if one
         if multi is set to dont_append, file won't be auto appended even if they exist
 */
-uint8_t fileParser::open( char *filename,FP_TYPE *multi )
+uint8_t fileParser::open( const char *filename,FP_TYPE *multi )
 {
         char *dot = NULL;                   // pointer to the last dot in filename
         uint8_t decimals = 0;               // number of decimals

Modified: branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_io.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_io.h	2007-01-20 10:44:43 UTC (rev 2745)
+++ branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_io.h	2007-01-20 15:15:58 UTC (rev 2746)
@@ -49,7 +49,7 @@
         public:
                                 fileParser(void);
                                 ~fileParser();                                         
-                        uint8_t  open(char *name,FP_TYPE *multi);
+                        uint8_t  open(const char *name,FP_TYPE *multi);
                         uint8_t  forward(uint64_t u);
                         uint8_t  sync(uint8_t *t );
                         uint8_t  getpos(uint64_t *o);

Modified: branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_probe.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_probe.cpp	2007-01-20 10:44:43 UTC (rev 2745)
+++ branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_probe.cpp	2007-01-20 15:15:58 UTC (rev 2746)
@@ -49,29 +49,21 @@
 
 #define MAX_PROBE (10*1024*1024LL) // Scans the 4 first meg
 #define MIN_DETECT (10*1024) // Need this to say the stream is present
-#define MAX_NB_PMT 50
 //****************************************************************************************
 typedef struct MPEG_PMT
 {
-   uint32_t programNumber;
-   uint32_t tid;
+   uint32_t         programNumber;
+   uint32_t         tid;
 }MPEG_PMT;
 //****************************************************************************************
 
-static uint8_t dmx_probePS(char *file,  uint32_t *nbTracks,MPEG_TRACK **tracks);
-static uint8_t dmx_probeTS(char *file,  uint32_t *nbTracks,MPEG_TRACK **tracks);
-static uint8_t dmx_probeTSBruteForce(char *file,  uint32_t *nbTracks,MPEG_TRACK **tracks);
-static uint8_t dmx_probeMSDVR(char *file, uint32_t *nbTracks,MPEG_TRACK **tracks);
-/* For mpeg TS with PSI only */
-static uint8_t dmx_probePat(dmx_demuxerTS *demuxer, uint32_t *nbPmt,MPEG_PMT *pmts,uint32_t maxPmt);
-static uint8_t dmx_probePMT(dmx_demuxerTS *demuxer, uint32_t pmtId);
+static uint8_t dmx_probePS(const char *file,  uint32_t *nbTracks,MPEG_TRACK **tracks);
+extern uint8_t dmx_probeTS(const char *file,  uint32_t *nbTracks,MPEG_TRACK **tracks);
+static uint8_t dmx_probeMSDVR(const char *file, uint32_t *nbTracks,MPEG_TRACK **tracks);
 
- uint8_t dmx_probeTSPat(const char *file, uint32_t *nbTracks,MPEG_TRACK **tracks);
- 
-extern uint32_t mpegTsCRC(uint8_t *data, uint32_t len);
 
 //****************************************************************************************
-uint8_t dmx_probe(char *file, DMX_TYPE  *type, uint32_t *nbTracks,MPEG_TRACK **tracks)
+uint8_t dmx_probe(const char *file, DMX_TYPE  *type, uint32_t *nbTracks,MPEG_TRACK **tracks)
 {
 
         printf(&quot;Probing %s for streams...\n&quot;,file);
@@ -105,7 +97,7 @@
         }
         return 0;
 }
-uint8_t dmx_probePS(char *file,  uint32_t *nbTracks,MPEG_TRACK **tracks)
+uint8_t dmx_probePS(const char *file,  uint32_t *nbTracks,MPEG_TRACK **tracks)
 {
 uint8_t dummy[10];
 uint64_t seen[256],abs,rel;
@@ -170,6 +162,7 @@
         
         memset(*tracks,0,(audio+1)*sizeof(MPEG_TRACK));
         (*tracks)[0].pes=video;
+        (*tracks)[0].streamType=ADM_STREAM_MPEG_VIDEO;
         audio=1;
 #define DOME {(*tracks)[audio].pes=i;audio++;}
         for(int i=0;i&lt;9;i++) if(seen[i]&gt;MIN_DETECT) DOME;
@@ -178,8 +171,8 @@
         for(int i=0x40;i&lt;0x49;i++) if(seen[i]&gt;MIN_DETECT) DOME;
 
         // Now go a bit deeper and try to extract infos
-        #define BUFFER_SIZE (10*1024)
 
+
         uint8_t buffer[BUFFER_SIZE];
         uint32_t read;
         uint32_t br,fq,offset,pes,chan;
@@ -204,6 +197,7 @@
                                         {
                                                 (*tracks)[i].channels=chan;
                                                 (*tracks)[i].bitrate=(8*br)/1000;
+                                                (*tracks)[i].streamType=ADM_STREAM_AC3;
                                         }
                                 }else
                                 {
@@ -215,6 +209,7 @@
                                         {
                                                 (*tracks)[i].channels=chan;
                                                 (*tracks)[i].bitrate=bitrate;
+                                                (*tracks)[i].streamType=ADM_STREAM_DTS;
                                                 if(syncoff) printf(&quot;[probe] There are some %u heading bytes\n&quot;,syncoff);
                                         }
 
@@ -226,6 +221,7 @@
                                                          else  (*tracks)[i].channels=1;
                                                 
                                                 (*tracks)[i].bitrate=mpegInfo.bitrate;
+                                                (*tracks)[i].streamType=ADM_STREAM_MPEG_AUDIO;
                                         }
                                 }                
 
@@ -239,159 +235,6 @@
         printf(&quot;Found video as %x, and %d audio tracks\n&quot;,video,audio-1);
         return 1;
 }
-uint8_t dmx_probeTS(char *file,  uint32_t *nbTracks,MPEG_TRACK **tracks)
-{
-        return dmx_probeTSBruteForce(file,nbTracks,tracks);
-}
-/**************************************
-****************************************************************
-    Brute force pid scanning in mpeg TS file
-    We seek all PES packets and store their PID and PES id
-*****************************************************************/
-#define MAX_FOUND_PID 100
-#define CHECK(x) val=parser-&gt;read8i(); left--;if(val!=x) goto _next;
-typedef struct myPid
-{
-  uint32_t pid;
-  uint32_t pes;
-
-}myPid;
-uint8_t dmx_probeTSBruteForce(char *file, uint32_t *nbTracks,MPEG_TRACK **tracks)
-{
-
-  // Brute force indexing
-  //
-  // Build a dummy track
-MPEG_TRACK dummy[TS_ALL_PID];
-fileParser *parser;
-uint32_t   foundPid=0;
-myPid      allPid[MAX_FOUND_PID];
-uint8_t    buffer[BUFFER_SIZE];
-MpegAudioInfo mpegInfo; 
-
-    dummy[0].pid=0x1; // should no be in use
-    dummy[0].pes=0xE0;
-
-        dmx_demuxerTS demuxer(TS_ALL_PID,dummy,0);
-        if(!demuxer.open(file))
-        {
-          return 0;
-        }
-    // Set probe to 10 Meg
-      demuxer.setProbeSize(10*1024*1024L);
-      parser=demuxer.getParser();
-      // And run
-
-      uint32_t pid,left,isPayloadStart,cc,val;
-      uint64_t abs;
-      while(demuxer.readPacket(&amp;pid,&amp;left, &amp;isPayloadStart,&amp;abs,&amp;cc))
-      {
-        if(isPayloadStart)
-        {
-            // Is it a PES type packet
-            // it should then start by 0x0 0x0 0x1 PID
-
-            CHECK(0);
-            CHECK(0);
-            CHECK(1);
-            val=parser-&gt;read8i();
-            left--;
-            // Check it does not exist already
-            int present=0;
-            for(int i=0;i&lt;foundPid;i++) if(pid==allPid[i].pid) {present=1;break;}
-            if(!present)
-            {
-              allPid[foundPid].pes=val;
-              allPid[foundPid].pid=pid;
-              foundPid++;
-            }
-            ADM_assert(foundPid&lt;MAX_FOUND_PID);
-        } 
-_next:
-        parser-&gt;forward(left);
-      }
-      if(!foundPid)
-      {
-         printf(&quot;ProbeTS: No PES packet header found\n&quot;);
-         return 0;
-      }
-      //****************************************
-      // Build information from the found Pid
-      //****************************************
-      for(int i=0;i&lt;foundPid;i++) printf(&quot;Pid : %04x Pes :%02x \n&quot;,allPid[i].pid,allPid[i].pes);
-
-      // Search for a pid for video track
-      //
-      *tracks=new MPEG_TRACK[foundPid];
-      MPEG_TRACK *trk=*tracks;
-      uint32_t vPid=0,vIdx;
-      uint32_t offset,fq,br,chan;
-
-      for(int i=0;i&lt;foundPid;i++)
-      {
-        if(allPid[i].pes&gt;=0xE0 &amp;&amp; allPid[i].pes&lt;=0xEA)
-        {
-            vPid=trk[0].pes=allPid[i].pes;
-            trk[0].pid=allPid[i].pid;
-            vIdx=i;
-            break;
-        }
-      }
-      if(!vPid)
-      {
-        delete [] trk;
-        *tracks=0;
-        printf(&quot;probeTs: No video track\n&quot;);
-        return 0;
-      }
-      // Now build the other audio (?) tracks
-      allPid[vIdx].pid=0;
-      uint32_t start=1,code,id,read;
-      for(int i=0;i&lt;foundPid;i++)
-      {
-        code=allPid[i].pes;
-        id=allPid[i].pid;
-
-        if(!id) continue;
-
-        if((code&gt;=0xC0 &amp;&amp; code &lt;= 0xC9) || code==0xbd)
-        {
-            demuxer.changePid(id,code);
-            demuxer.setPos(0,0);
-            read=demuxer.read(buffer,BUFFER_SIZE);
-            if(read!=BUFFER_SIZE) continue;
-            if(code&gt;=0xC0 &amp;&amp; code &lt;= 0xC9) // Mpeg audio
-            {
-              if(getMpegFrameInfo(buffer,read,&amp;mpegInfo,NULL,&amp;offset))
-                   {
-                      if(mpegInfo.mode!=3)  trk[start].channels=2;
-                          else  trk[start].channels=1;
- 
-                      trk[start].bitrate=mpegInfo.bitrate;
-                      trk[start].pid=id;
-                      trk[start].pes=code;
-                      start++;
-
-                    }
-            }
-            else // AC3
-            {
-                  if(ADM_AC3GetInfo(buffer,read,&amp;fq,&amp;br,&amp;chan,&amp;offset))
-                  {
-                          trk[start].channels=chan;
-                          trk[start].bitrate=(8*br)/1000;
-                          trk[start].pid=id;
-                          trk[start].pes=0;
-                          start++;
-                  }
-
-            }
-
-        }
-      }
-      *nbTracks=start;
-      return 1;
-}
 /* ****************************************************** */
 #include &quot;ADM_asf/ADM_asfPacket.h&quot;
 #include &quot;ADM_asf/ADM_asf.h&quot;
@@ -401,7 +244,7 @@
 #define MAX_PACKET_PROBE 2000;   // assuming a packet is 8kB we will probe around 15 Meg
 #define DETECT_MIN 7000
 
-uint8_t dmx_probeMSDVR(char *file, uint32_t *nbTracks,MPEG_TRACK **ztracks)
+uint8_t dmx_probeMSDVR(const char *file, uint32_t *nbTracks,MPEG_TRACK **ztracks)
 {
   int r=5;
   const chunky *id=NULL;
@@ -420,6 +263,8 @@
       *ztracks=tracks;
       tracks[0].pes=0xE0;
       tracks[0].pid=1;
+      tracks[0].pid=1;
+      tracks[0].streamType=ADM_STREAM_MPEG_VIDEO;
       // Now check for track up to 5
       
       FILE *fd=NULL;
@@ -510,6 +355,7 @@
           if(getMpegFrameInfo(buffer[i],streamlen[i],&amp;mpegInfo,NULL,&amp;sync))
           {
             tracks[*nbTracks].channels=2;
+            tracks[*nbTracks].streamType=ADM_STREAM_MPEG_AUDIO;
             if(mpegInfo.mode==3) 
               tracks[*nbTracks].channels=1;
             tracks[*nbTracks].bitrate=mpegInfo.bitrate;
@@ -527,6 +373,7 @@
             tracks[*nbTracks].bitrate=(8*br)/1000;
             tracks[*nbTracks].pid=i;
             tracks[*nbTracks].pes=0;
+            tracks[*nbTracks].streamType=ADM_STREAM_AC3;
             *nbTracks=*nbTracks+1;
             continue;
           }
@@ -539,266 +386,4 @@
       fclose(fd);
       return 1;
 }
-/**
-      \fn     dmx_probeTSPat(char *file, uint32_t *nbTracks,MPEG_TRACK **tracks)
-      \brief  Try to extract info from a Mpeg TS file using PAT, PMT etc..
-      @return 1 on success, 0 on failure
-      @param file: File to scan
-      @param *nbTrack : number of track found (out)
-      @param **tracks : contains info about the tracks found (out)
-
-*/
-uint8_t dmx_probeTSPat(char *file, uint32_t *nbTracks,MPEG_TRACK **tracks)
-{
-MPEG_TRACK dummy[TS_ALL_PID];
-fileParser *parser;
-uint32_t   foundPid=0;
-myPid      allPid[MAX_FOUND_PID];
-uint8_t    buffer[BUFFER_SIZE];
-MpegAudioInfo mpegInfo; 
-
-    dummy[0].pid=0x00; // should no be in use
-    dummy[0].pes=0xE0;
-
-        dmx_demuxerTS demuxer(1,dummy,1);
-        if(!demuxer.open(file))
-        {
-          return 0;
-        }
-    // Set probe to 10 Meg
-      demuxer.setProbeSize(10*1024*1024L);
-      uint32_t nbPmt;
-      MPEG_PMT pmts[MAX_NB_PMT];
-
-      
-      if(!dmx_probePat(&amp;demuxer,&amp;nbPmt,pmts,MAX_NB_PMT))
-      {
-        printf(&quot;[PSI Probe]Cannot find Pat\n&quot;); 
-        parser=NULL;
-        return 0;
-      }
-      printf(&quot;Found %d PMT..\n&quot;,nbPmt);
-      demuxer.setProbeSize(40*1024*1024L); // We can can increase the probe size
-      for(int i=0;i&lt;nbPmt;i++)
-      {
-         dmx_probePMT(&amp;demuxer, pmts[i].tid);
-      }
-}
-uint8_t runProbe(char *file)
-{
-  uint32_t nb;
-  return  dmx_probeTSPat(file, &amp;nb,NULL);
-  
-}
-/**
-      \fn     dmx_searchAndSkipHeader
-      \brief  Search for a given PSI and skip header
-      @return 1 on success, 0 on failure
-      @param myPid : Pid of the looked for psi
-      @param demuxer: mpegTS demuxer *(input)
-      @param *currentSec : current section (output)
-      @param *maxSec : #of sections (output)
-      @param *leftbyte : Total #of bytes left in the packet
-      @param *payloadSize : #of bytes of usable payload
-
-*/
-uint8_t dmx_searchAndSkipHeader(uint32_t myPid,dmx_demuxerTS *demuxer,uint32_t *currentSec, uint32_t *maxSec,
-                                    uint32_t *leftbyte,uint32_t *payloadSize)
-{
-  
-  uint8_t packet[TS_PACKET_SIZE];
-  uint32_t tableId;
-  uint32_t misc;
-  uint32_t sectionLength;
-  uint32_t tId,pid,left,cc,nbPmt;
-  uint32_t version,isPayloadStart;
-  uint32_t sectionNumber;
-  uint32_t lastSectionNumber;
-  uint32_t programInfoLength;
-  uint32_t crc,crccomputed;
-  uint64_t startPos,endPos,abso;
-  fileParser *parser;
-      demuxer-&gt;changePid(myPid,myPid); // Search PAT
-      parser=demuxer-&gt;getParser();
-      
-        while(demuxer-&gt;readPacket(&amp;pid,&amp;left, &amp;isPayloadStart,&amp;abso,&amp;cc))
-        {
-          if(pid!=myPid)
-          {
-            printf(&quot;Wrong Pid %x/%x\n&quot;,pid,myPid);
-            parser-&gt;forward(left);
-            continue;
-          }
-          if(!isPayloadStart || left &lt;= (9+4))
-          {
-            parser-&gt;forward(left);
-            continue;
-          }
-
-          /* Found something that looks good...*/
-            
-            /* Decode PSI header */
-            parser-&gt;read8i(); /* Pointer field, can be ignored (?) */
-              
-              parser-&gt;getpos(&amp;startPos); /* Memorize beginning */
-              tableId=parser-&gt;read8i();
-              misc=parser-&gt;read16i(); // +3
-              tId=parser-&gt;read16i();  
-              version=parser-&gt;read8i(); // +6
-              sectionNumber=parser-&gt;read8i();
-              lastSectionNumber=parser-&gt;read8i(); // +8
-              
-              sectionLength=misc&amp;0xFFF;
-              
-              if(sectionLength&lt;=9 || left &lt;=9)
-              {
-                printf(&quot;SectionLength too short :%d\n&quot;, sectionLength);
-                 parser-&gt;setpos(startPos-1+left); // skip packet
-                 continue;
-              }
-              
-#ifdef PROBE_TS_VERBOSE
-              printf(&quot;******************************************\n&quot;);
-              printf(&quot;tableId        : %d\n&quot;,tableId);
-              
-              printf(&quot;sectionLength  : %d\n&quot;,sectionLength);
-              printf(&quot;0              : %x\n&quot;,misc&amp;0x40);
-              printf(&quot;section syntax : %x\n&quot;,misc&amp;0x80);
-              printf(&quot;Transport ID   : 0x%x\n&quot;,tId);
-              printf(&quot;Version Number : 0x%x\n&quot;,(version&gt;&gt;1)&amp;0x1F);
-              printf(&quot;CurrentNext    : 0x%x\n&quot;,version&amp;1);
-              
-              printf(&quot;Section        : %d\n&quot;,sectionNumber);
-              printf(&quot;LastSection    : %d\n&quot;,lastSectionNumber);
-              
-#endif
-              // Check for error FIXME TODO
-              
-              // Check CRC
-              parser-&gt;getpos(&amp;endPos); // Here payload begins
-              parser-&gt;setpos(startPos);
-              parser-&gt;read32(sectionLength-1,packet); // Go back &amp; Read Whole packet +3 for header -4 CRC
-              crc=parser-&gt;read32i();
-              crccomputed=mpegTsCRC(packet,sectionLength-1);
-              if(crc!=crccomputed) // Bad CRC, skip packet
-              {
-                printf(&quot;Bad CRC\n&quot;);
-                parser-&gt;setpos( startPos+left-1); // skip
-                continue;
-              }
-              // CRC is ok, go back to interesting place
-              printf(&quot;CRC OK\n&quot;);
-              parser-&gt;setpos(endPos);
-              *currentSec=sectionNumber;
-              *maxSec=lastSectionNumber;
-              
-              *leftbyte=left-9;               // Total bytes left in packet
-              *payloadSize=sectionLength-9; // No CRC, No header
-              return 1;
-          } // /while
-      return 0;
-}
-/**
-      \fn     dmx_probePat(dmx_demuxerTS *demuxer, uint32_t *nbPmt,MPEG_PMT *pmts,uint32_t maxPMT)
-      \brief  Search for PAT and returns PMT info if found
-      @return 1 on success, 0 on failure
-      @param demuxer: mpegTS demuxer (input)
-      @param *nbPmt : number of PMTS found (output)
-      @param *pmts : contains info about the PMT found (out but must be allocated by caller)
-      @param maxPMT : Maximum # of PMT we accept in pmts (in)
-
-*/
-uint8_t dmx_probePat(dmx_demuxerTS *demuxer, uint32_t *nbPmt,MPEG_PMT *pmts,uint32_t maxPmt)
-{
-  
-  fileParser *parser;
-  uint32_t curSection,maxSection;
-  uint32_t left,toScan;
-  
-      parser=demuxer-&gt;getParser();
-      *nbPmt=0;
-      if(dmx_searchAndSkipHeader(0,demuxer,&amp;curSection, &amp;maxSection,&amp;left,&amp;toScan))
-      {
-        
-              while(toScan &gt;=4 &amp;&amp; left&gt;=8)
-              {
-                  printf(&quot;**\n&quot;);
-                  pmts[*nbPmt].programNumber=parser-&gt;read16i()&amp;0xFFFF;
-                  pmts[*nbPmt].tid=parser-&gt;read16i()&amp;0x1FFF;
-                  printf(&quot; [PAT]Program Number :%03x\n&quot;,pmts[*nbPmt].programNumber);
-                  printf(&quot; [PAT]PID for this   :%03x\n&quot;,pmts[*nbPmt].tid);
-                  if((*nbPmt)&lt;maxPmt)
-                      (*nbPmt)++;
-                  left-=4;
-                  toScan-=4;
-              }
-              return 1;
-        
-      }
-      return 0;
-}
-const char *toString(uint32_t type)
-{
- switch(type)
- {
-   case 1:case 2: return &quot;Mpeg Video&quot;;
-   case 3:case 4: return &quot;Mpeg Audio&quot;;
-   case 0x1B: return &quot;H264&quot;;
-   case 0x81: return &quot;Private (AC3?)&quot;;
-   
-   default: return &quot;???&quot;; 
- }
-  return &quot;???&quot;;
-}
-/**
-      \fn     dmx_probePat(dmx_demuxerTS *demuxer, uint32_t *nbPmt,MPEG_PMT *pmts,uint32_t maxPMT)
-      \brief  Search for PAT and returns PMT info if found
-      @return 1 on success, 0 on failure
-      @param demuxer: mpegTS demuxer (input)
-      @param *nbPmt : number of PMTS found (output)
-      @param *pmts : contains info about the PMT found (out but must be allocated by caller)
-      @param maxPMT : Maximum # of PMT we accept in pmts (in)
-
-*/
-uint8_t dmx_probePMT(dmx_demuxerTS *demuxer, uint32_t pmtId)
-{
-  
-  fileParser *parser;
-  uint32_t curSection,maxSection;
-  uint32_t left,toScan,programInfo;
-  
-      printf(&quot;Searching for PMT, pid=0x%x\n&quot;,pmtId);
-      demuxer-&gt;changePid(pmtId,pmtId); // change pid as setPos will seek for them
-      demuxer-&gt;setPos(0,0);
-      parser=demuxer-&gt;getParser();
-      if(dmx_searchAndSkipHeader(pmtId,demuxer,&amp;curSection, &amp;maxSection,&amp;left,&amp;toScan))
-      {
-               printf(&quot;[PMT]PCR for it    :x%x\n&quot;,parser-&gt;read16i()&amp;0x1FFF);
-               programInfo=parser-&gt;read16i() &amp; 0x0FFF;
-               printf(&quot;[PMT]Program Info  :%d\n&quot;,programInfo);
-               parser-&gt;forward(programInfo);
-               toScan-=(2+programInfo);
-               left-=(2+programInfo);
-               while(toScan &gt;=5 )
-              {
-                  uint8_t streamType;
-                  uint32_t pid,esDescLen;
-                  printf(&quot;**\n&quot;);
-                  streamType=parser-&gt;read8i();
-                  pid       =parser-&gt;read16i()&amp;0x1FFF;
-                  esDescLen =parser-&gt;read16i()&amp;0x0FFF;
-                  printf(&quot;[PMT]Stream Type :0x%x (%s)\n&quot;,streamType,toString(streamType));
-                  printf(&quot;[PMT]Pid         :0x%x\n&quot;,pid);
-                  printf(&quot;[PMT]ES Len      :%d\n&quot;,esDescLen);
-                  
-                  parser-&gt;forward(esDescLen);
-                  left-=(5+esDescLen);
-                  toScan-=(5+esDescLen);
-                  printf(&quot;[PMT]left %u toscan %u\n&quot;,left,toScan);
-              }
-              
-      }
-      return 0;
-}
-
 /****EOF**/

Modified: branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_probe.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_probe.h	2007-01-20 10:44:43 UTC (rev 2745)
+++ branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_probe.h	2007-01-20 15:15:58 UTC (rev 2746)
@@ -18,7 +18,8 @@
 
 #ifndef DMX_PROBE
 #define DMX_PROBE
-uint8_t dmx_probe(char *file, DMX_TYPE  *type, uint32_t *nbTracks,MPEG_TRACK **tracks);
+#define BUFFER_SIZE (10*1024)
+uint8_t dmx_probe(const char *file, DMX_TYPE  *type, uint32_t *nbTracks,MPEG_TRACK **tracks);
 // For test
 uint8_t runProbe(char *f);
 #endif

Copied: branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_probeTS.cpp (from rev 2745, branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_probe.cpp)
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_probe.cpp	2007-01-20 10:44:43 UTC (rev 2745)
+++ branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer/dmx_probeTS.cpp	2007-01-20 15:15:58 UTC (rev 2746)
@@ -0,0 +1,573 @@
+/***************************************************************************
+                        Probe for a stream                                              
+                             
+    
+    copyright            : (C) 2005 by mean
+    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include &quot;config.h&quot;
+
+#include &lt;stdio.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;string.h&gt;
+#include &lt;math.h&gt;
+
+#include &quot;default.h&quot;
+#include &lt;ADM_assert.h&gt;
+
+
+#include &quot;ADM_toolkit/toolkit.hxx&quot;
+#include &quot;ADM_toolkit/filesel.h&quot;
+#include &quot;fourcc.h&quot;
+#include &quot;DIA_working.h&quot;
+
+
+
+#include &quot;ADM_osSupport/ADM_debugID.h&quot;
+#define MODULE_NAME MODULE_MPEG
+#include &quot;ADM_osSupport/ADM_debug.h&quot;
+
+#include &quot;dmx_demuxerPS.h&quot;
+#include &quot;dmx_demuxerTS.h&quot;
+#include &quot;dmx_identify.h&quot;
+#include &quot;dmx_probe.h&quot;
+#include &quot;DIA_busy.h&quot;
+#include &quot;ADM_audio/ADM_mp3info.h&quot;
+#include &quot;ADM_audio/ADM_a52info.h&quot;
+#include &quot;ADM_audio/ADM_dcainfo.h&quot;
+
+
+
+#define MAX_PROBE (10*1024*1024LL) // Scans the 4 first meg
+#define MIN_DETECT (10*1024) // Need this to say the stream is present
+#define MAX_NB_PMT 50
+
+//****************************************************************************************
+typedef struct MPEG_PMT
+{
+   uint32_t         programNumber;
+   uint32_t         tid;
+}MPEG_PMT;
+//****************************************************************************************
+
+uint8_t dmx_probeTS(const char *file,  uint32_t *nbTracks,MPEG_TRACK **tracks);
+//****************************************************************************************
+static uint8_t dmx_probeTSBruteForce(const char *file,  uint32_t *nbTracks,MPEG_TRACK **tracks);
+static uint8_t dmx_probeTSPat(const char *file, uint32_t *nbTracks,MPEG_TRACK **tracks);
+static uint8_t dmx_probePat(dmx_demuxerTS *demuxer, uint32_t *nbPmt,MPEG_PMT *pmts,uint32_t maxPmt);
+static uint8_t dmx_probePMT(dmx_demuxerTS *demuxer, uint32_t pmtId,MPEG_TRACK *pmts,uint32_t *cur, uint32_t max);
+
+
+ 
+extern uint32_t mpegTsCRC(uint8_t *data, uint32_t len);
+
+
+uint8_t dmx_probeTS(const char *file,  uint32_t *nbTracks,MPEG_TRACK **tracks)
+{
+    // Try through PMT/PAT first
+      if(! dmx_probeTSPat(file,nbTracks,tracks))
+      {
+        
+        printf(&quot;PAT/PMT Failed, using brute force\n&quot;);
+        return dmx_probeTSBruteForce(file,nbTracks,tracks);
+      }
+      return 1;
+}
+/**************************************
+****************************************************************
+    Brute force pid scanning in mpeg TS file
+    We seek all PES packets and store their PID and PES id
+*****************************************************************/
+#define MAX_FOUND_PID 100
+#define CHECK(x) val=parser-&gt;read8i(); left--;if(val!=x) goto _next;
+typedef struct myPid
+{
+  uint32_t pid;
+  uint32_t pes;
+
+}myPid;
+uint8_t dmx_probeTSBruteForce(const char *file, uint32_t *nbTracks,MPEG_TRACK **tracks)
+{
+
+  // Brute force indexing
+  //
+  // Build a dummy track
+MPEG_TRACK dummy[TS_ALL_PID];
+fileParser *parser;
+uint32_t   foundPid=0;
+myPid      allPid[MAX_FOUND_PID];
+uint8_t    buffer[BUFFER_SIZE];
+MpegAudioInfo mpegInfo; 
+
+    dummy[0].pid=0x1; // should no be in use
+    dummy[0].pes=0xE0;
+
+        dmx_demuxerTS demuxer(TS_ALL_PID,dummy,0);
+        if(!demuxer.open(file))
+        {
+          return 0;
+        }
+    // Set probe to 10 Meg
+      demuxer.setProbeSize(10*1024*1024L);
+      parser=demuxer.getParser();
+      // And run
+
+      uint32_t pid,left,isPayloadStart,cc,val;
+      uint64_t abs;
+      while(demuxer.readPacket(&amp;pid,&amp;left, &amp;isPayloadStart,&amp;abs,&amp;cc))
+      {
+        if(isPayloadStart)
+        {
+            // Is it a PES type packet
+            // it should then start by 0x0 0x0 0x1 PID
+
+            CHECK(0);
+            CHECK(0);
+            CHECK(1);
+            val=parser-&gt;read8i();
+            left--;
+            // Check it does not exist already
+            int present=0;
+            for(int i=0;i&lt;foundPid;i++) if(pid==allPid[i].pid) {present=1;break;}
+            if(!present)
+            {
+              allPid[foundPid].pes=val;
+              allPid[foundPid].pid=pid;
+              foundPid++;
+            }
+            ADM_assert(foundPid&lt;MAX_FOUND_PID);
+        } 
+_next:
+        parser-&gt;forward(left);
+      }
+      if(!foundPid)
+      {
+         printf(&quot;ProbeTS: No PES packet header found\n&quot;);
+         return 0;
+      }
+      //****************************************
+      // Build information from the found Pid
+      //****************************************
+      for(int i=0;i&lt;foundPid;i++) printf(&quot;Pid : %04x Pes :%02x \n&quot;,allPid[i].pid,allPid[i].pes);
+
+      // Search for a pid for video track
+      //
+      *tracks=new MPEG_TRACK[foundPid];
+      MPEG_TRACK *trk=*tracks;
+      uint32_t vPid=0,vIdx;
+      uint32_t offset,fq,br,chan;
+
+      for(int i=0;i&lt;foundPid;i++)
+      {
+        if(allPid[i].pes&gt;=0xE0 &amp;&amp; allPid[i].pes&lt;=0xEA)
+        {
+            vPid=trk[0].pes=allPid[i].pes;
+            trk[0].pid=allPid[i].pid;
+            trk[0].streamType=ADM_STREAM_MPEG_VIDEO;
+            vIdx=i;
+            break;
+        }
+      }
+      if(!vPid)
+      {
+        delete [] trk;
+        *tracks=0;
+        printf(&quot;probeTs: No video track\n&quot;);
+        return 0;
+      }
+      // Now build the other audio (?) tracks
+      allPid[vIdx].pid=0;
+      uint32_t start=1,code,id,read;
+      for(int i=0;i&lt;foundPid;i++)
+      {
+        code=allPid[i].pes;
+        id=allPid[i].pid;
+
+        if(!id) continue;
+
+        if((code&gt;=0xC0 &amp;&amp; code &lt;= 0xC9) || code==0xbd)
+        {
+            demuxer.changePid(id,code);
+            demuxer.setPos(0,0);
+            read=demuxer.read(buffer,BUFFER_SIZE);
+            if(read!=BUFFER_SIZE) continue;
+            if(code&gt;=0xC0 &amp;&amp; code &lt;= 0xC9) // Mpeg audio
+            {
+              if(getMpegFrameInfo(buffer,read,&amp;mpegInfo,NULL,&amp;offset))
+                   {
+                      if(mpegInfo.mode!=3)  trk[start].channels=2;
+                          else  trk[start].channels=1;
+ 
+                      trk[start].bitrate=mpegInfo.bitrate;
+                      trk[start].pid=id;
+                      trk[start].pes=code;
+                      trk[start].streamType=ADM_STREAM_MPEG_AUDIO;
+                      start++;
+
+                    }
+            }
+            else // AC3
+            {
+                  if(ADM_AC3GetInfo(buffer,read,&amp;fq,&amp;br,&amp;chan,&amp;offset))
+                  {
+                          trk[start].channels=chan;
+                          trk[start].bitrate=(8*br)/1000;
+                          trk[start].pid=id;
+                          trk[start].pes=0;
+                          trk[start].streamType=ADM_STREAM_AC3;
+                          start++;
+                  }
+
+            }
+
+        }
+      }
+      *nbTracks=start;
+      return 1;
+}
+
+/**
+      \fn     dmx_probeTSPat(char *file, uint32_t *nbTracks,MPEG_TRACK **tracks)
+      \brief  Try to extract info from a Mpeg TS file using PAT, PMT etc..
+      @return 1 on success, 0 on failure
+      @param file: File to scan
+      @param *nbTrack : number of track found (out)
+      @param **tracks : contains info about the tracks found (out)
+
+*/
+uint8_t dmx_probeTSPat(const char *file, uint32_t *nbTracks,MPEG_TRACK **tracks)
+{
+MPEG_TRACK dummy[TS_ALL_PID];
+fileParser *parser;
+uint32_t   foundPid=0;
+myPid      allPid[MAX_FOUND_PID];
+uint8_t    buffer[BUFFER_SIZE];
+MpegAudioInfo mpegInfo; 
+#define MAX_STREAM 50
+#define MAX_NB_TRACK 50
+    dummy[0].pid=0x00; // should no be in use
+    dummy[0].pes=0xE0;
+
+        dmx_demuxerTS demuxer(1,dummy,1);
+        if(!demuxer.open(file))
+        {
+          return 0;
+        }
+    // Set probe to 10 Meg
+      demuxer.setProbeSize(10*1024*1024L);
+      uint32_t nbPmt;
+      MPEG_PMT pmts[MAX_NB_PMT];
+      MPEG_TRACK xtracks[MAX_NB_TRACK];
+      
+      if(!dmx_probePat(&amp;demuxer,&amp;nbPmt,pmts,MAX_NB_PMT))
+      {
+        aprintf(&quot;[PSI Probe]Cannot find Pat\n&quot;); 
+        parser=NULL;
+        return 0;
+      }
+      printf(&quot;Found %d PMT..\n&quot;,nbPmt);
+      demuxer.setProbeSize(40*1024*1024L); // We can can increase the probe size
+      uint32_t cur=0;
+      for(int i=0;i&lt;nbPmt;i++)
+      {
+         dmx_probePMT(&amp;demuxer, pmts[i].tid,xtracks,&amp;cur,MAX_NB_TRACK);
+      }
+      printf(&quot;***********************\n&quot;);
+      printf(&quot;***********************\n&quot;);
+      printf(&quot;Summary of stream found\n&quot;);
+      printf(&quot;***********************\n&quot;);
+      printf(&quot;***********************\n&quot;);
+      for(int i=0;i&lt;cur;i++)
+      {
+        printf(&quot;Tid : %04x Type :%d %s\n&quot;, xtracks[i].pid,xtracks[i].streamType,&quot;?&quot;);
+      }
+      printf(&quot;******************************\n&quot;);
+      printf(&quot;******************************\n&quot;);
+      printf(&quot;End of summary of stream found\n&quot;);
+      printf(&quot;******************************\n&quot;);
+      printf(&quot;******************************\n&quot;);
+      
+      if(!cur)        return 0;
+      
+      // Search first video track
+      *tracks=new MPEG_TRACK[cur];
+      int found=-1;
+      for(int j=0;j&lt;cur;j++)
+      {
+        ADM_STREAM_TYPE type=xtracks[j].streamType;
+        if(type==ADM_STREAM_MPEG_VIDEO ||  type==ADM_STREAM_MPEG4 || type==ADM_STREAM_H264)
+        {
+          found=j;
+          break;  
+        }
+      }
+      if(found&lt;0)
+      {
+        printf(&quot;No video track\n&quot;);
+        delete [] *tracks;
+        return 0; 
+      }
+      memcpy(*tracks,&amp;(xtracks[found]),sizeof(MPEG_TRACK));
+      *nbTracks=1;
+      // Now do audio
+      for(int j=0;j&lt;cur;j++)
+      {
+         MPEG_TRACK *t=&amp;(xtracks[j]);
+         ADM_STREAM_TYPE type=t-&gt;streamType;
+          if(type!=ADM_STREAM_MPEG_AUDIO &amp;&amp; type!=ADM_STREAM_AC3) continue; // Only mpega &amp; AC3 for now
+          switch(type)
+          {
+            case ADM_STREAM_MPEG_AUDIO:
+            case ADM_STREAM_AC3:
+              memcpy(&amp;((*tracks)[*nbTracks]),t,sizeof(MPEG_TRACK));
+              ADM_assert(*nbTracks&lt;cur);
+              (*nbTracks)++;
+              break;
+            
+            default: ADM_assert(0); 
+          }
+      }
+      printf(&quot;Found %u tracks\n&quot;,*nbTracks);
+      //
+      return 1;
+      
+}
+uint8_t runProbe(const char *file)
+{
+  uint32_t nb;
+  return  dmx_probeTSPat(file, &amp;nb,NULL);
+  
+}
+/**
+      \fn     dmx_searchAndSkipHeader
+      \brief  Search for a given PSI and skip header
+      @return 1 on success, 0 on failure
+      @param myPid : Pid of the looked for psi
+      @param demuxer: mpegTS demuxer *(input)
+      @param *currentSec : current section (output)
+      @param *maxSec : #of sections (output)
+      @param *leftbyte : Total #of bytes left in the packet
+      @param *payloadSize : #of bytes of usable payload
+
+*/
+uint8_t dmx_searchAndSkipHeader(uint32_t myPid,dmx_demuxerTS *demuxer,uint32_t *currentSec, uint32_t *maxSec,
+                                    uint32_t *leftbyte,uint32_t *payloadSize)
+{
+  
+  uint8_t packet[TS_PACKET_SIZE];
+  uint32_t tableId;
+  uint32_t misc;
+  uint32_t sectionLength;
+  uint32_t tId,pid,left,cc,nbPmt;
+  uint32_t version,isPayloadStart;
+  uint32_t sectionNumber;
+  uint32_t lastSectionNumber;
+  uint32_t programInfoLength;
+  uint32_t crc,crccomputed;
+  uint64_t startPos,endPos,abso;
+  fileParser *parser;
+      demuxer-&gt;changePid(myPid,myPid); // Search PAT
+      parser=demuxer-&gt;getParser();
+      
+        while(demuxer-&gt;readPacket(&amp;pid,&amp;left, &amp;isPayloadStart,&amp;abso,&amp;cc))
+        {
+          if(pid!=myPid)
+          {
+            printf(&quot;Wrong Pid %x/%x\n&quot;,pid,myPid);
+            parser-&gt;forward(left);
+            continue;
+          }
+          if(!isPayloadStart || left &lt;= (9+4))
+          {
+            parser-&gt;forward(left);
+            continue;
+          }
+
+          /* Found something that looks good...*/
+            
+            /* Decode PSI header */
+            parser-&gt;read8i(); /* Pointer field, can be ignored (?) */
+              
+              parser-&gt;getpos(&amp;startPos); /* Memorize beginning */
+              tableId=parser-&gt;read8i();
+              misc=parser-&gt;read16i(); // +3
+              tId=parser-&gt;read16i();  
+              version=parser-&gt;read8i(); // +6
+              sectionNumber=parser-&gt;read8i();
+              lastSectionNumber=parser-&gt;read8i(); // +8
+              
+              sectionLength=misc&amp;0xFFF;
+              
+              if(sectionLength&lt;=9 || left &lt;=9)
+              {
+                printf(&quot;SectionLength too short :%d\n&quot;, sectionLength);
+                 parser-&gt;setpos(startPos-1+left); // skip packet
+                 continue;
+              }
+              
+#ifdef PROBE_TS_VERBOSE
+              printf(&quot;******************************************\n&quot;);
+              printf(&quot;tableId        : %d\n&quot;,tableId);
+              
+              printf(&quot;sectionLength  : %d\n&quot;,sectionLength);
+              printf(&quot;0              : %x\n&quot;,misc&amp;0x40);
+              printf(&quot;section syntax : %x\n&quot;,misc&amp;0x80);
+              printf(&quot;Transport ID   : 0x%x\n&quot;,tId);
+              printf(&quot;Version Number : 0x%x\n&quot;,(version&gt;&gt;1)&amp;0x1F);
+              printf(&quot;CurrentNext    : 0x%x\n&quot;,version&amp;1);
+              
+              printf(&quot;Section        : %d\n&quot;,sectionNumber);
+              printf(&quot;LastSection    : %d\n&quot;,lastSectionNumber);
+              
+#endif
+              // Check for error FIXME TODO
+              
+              // Check CRC
+              parser-&gt;getpos(&amp;endPos); // Here payload begins
+              parser-&gt;setpos(startPos);
+              parser-&gt;read32(sectionLength-1,packet); // Go back &amp; Read Whole packet +3 for header -4 CRC
+              crc=parser-&gt;read32i();
+              crccomputed=mpegTsCRC(packet,sectionLength-1);
+              if(crc!=crccomputed) // Bad CRC, skip packet
+              {
+                aprintf(&quot;Bad CRC\n&quot;);
+                parser-&gt;setpos( startPos+left-1); // skip
+                continue;
+              }
+              // CRC is ok, go back to interesting place
+              aprintf(&quot;CRC OK\n&quot;);
+              parser-&gt;setpos(endPos);
+              *currentSec=sectionNumber;
+              *maxSec=lastSectionNumber;
+              
+              *leftbyte=left-9;               // Total bytes left in packet
+              *payloadSize=sectionLength-9; // No CRC, No header
+              return 1;
+          } // /while
+      return 0;
+}
+/**
+      \fn     dmx_probePat(dmx_demuxerTS *demuxer, uint32_t *nbPmt,MPEG_PMT *pmts,uint32_t maxPMT)
+      \brief  Search for PAT and returns PMT info if found
+      @return 1 on success, 0 on failure
+      @param demuxer: mpegTS demuxer (input)
+      @param *nbPmt : number of PMTS found (output)
+      @param *pmts : contains info about the PMT found (out but must be allocated by caller)
+      @param maxPMT : Maximum # of PMT we accept in pmts (in)
+
+*/
+uint8_t dmx_probePat(dmx_demuxerTS *demuxer, uint32_t *nbPmt,MPEG_PMT *pmts,uint32_t maxPmt)
+{
+  
+  fileParser *parser;
+  uint32_t curSection,maxSection;
+  uint32_t left,toScan;
+  
+      parser=demuxer-&gt;getParser();
+      *nbPmt=0;
+      if(dmx_searchAndSkipHeader(0,demuxer,&amp;curSection, &amp;maxSection,&amp;left,&amp;toScan))
+      {
+        
+              while(toScan &gt;=4 &amp;&amp; left&gt;=8)
+              {
+                  printf(&quot;**\n&quot;);
+                  pmts[*nbPmt].programNumber=parser-&gt;read16i()&amp;0xFFFF;
+                  pmts[*nbPmt].tid=parser-&gt;read16i()&amp;0x1FFF;
+                  aprintf(&quot; [PAT]Program Number :%03x\n&quot;,pmts[*nbPmt].programNumber);
+                  aprintf(&quot; [PAT]PID for this   :%03x\n&quot;,pmts[*nbPmt].tid);
+                  if((*nbPmt)&lt;maxPmt)
+                      (*nbPmt)++;
+                  left-=4;
+                  toScan-=4;
+              }
+              return 1;
+        
+      }
+      return 0;
+}
+const char *dmx_streamType(uint32_t type,ADM_STREAM_TYPE *streamType)
+{
+ switch(type)
+ {
+   case 1:case 2: *streamType=ADM_STREAM_MPEG_VIDEO;return &quot;Mpeg Video&quot;;
+   case 3:case 4: *streamType=ADM_STREAM_MPEG_AUDIO;return &quot;Mpeg Audio&quot;;
+   case 0x1B: *streamType=ADM_STREAM_H264;return &quot;H264&quot;;
+   case 0x81: *streamType=ADM_STREAM_AC3;return &quot;Private (AC3?)&quot;;
+ }
+ *streamType=ADM_STREAM_UNKNOWN;
+  return &quot;???&quot;;
+}
+/**
+      \fn     dmx_probePat(dmx_demuxerTS *demuxer, uint32_t *nbPmt,MPEG_PMT *pmts,uint32_t maxPMT)
+      \brief  Search for PAT and returns PMT info if found
+      @return 1 on success, 0 on failure
+      @param demuxer: mpegTS demuxer (input)
+      @param *nbPmt : number of PMTS found (output)
+      @param *pmts : contains info about the PMT found (out but must be allocated by caller)
+      @param maxPMT : Maximum # of PMT we accept in pmts (in)
+
+*/
+uint8_t dmx_probePMT(dmx_demuxerTS *demuxer, uint32_t pmtId,MPEG_TRACK *pmts,uint32_t *cur, uint32_t max)
+{
+  
+  fileParser *parser;
+  uint32_t curSection,maxSection;
+  uint32_t left,toScan,programInfo;
+  
+      printf(&quot;Searching for PMT, pid=0x%x\n&quot;,pmtId);
+      demuxer-&gt;changePid(pmtId,pmtId); // change pid as setPos will seek for them
+      demuxer-&gt;setPos(0,0);
+      parser=demuxer-&gt;getParser();
+      if(dmx_searchAndSkipHeader(pmtId,demuxer,&amp;curSection, &amp;maxSection,&amp;left,&amp;toScan))
+      {
+               aprintf(&quot;[PMT]PCR for it    :x%x\n&quot;,parser-&gt;read16i()&amp;0x1FFF);
+               programInfo=parser-&gt;read16i() &amp; 0x0FFF;
+               aprintf(&quot;[PMT]Program Info  :%d\n&quot;,programInfo);
+               parser-&gt;forward(programInfo);
+               toScan-=(2+programInfo);
+               left-=(2+programInfo);
+               while(toScan &gt;=5 )
+              {
+                  uint8_t stream;
+                  uint32_t pid,esDescLen;
+                  const char *idString;
+                  ADM_STREAM_TYPE streamType;
+                  aprintf(&quot;**\n&quot;);
+                  stream    =parser-&gt;read8i();
+                  pid       =parser-&gt;read16i()&amp;0x1FFF;
+                  esDescLen =parser-&gt;read16i()&amp;0x0FFF;
+                  idString=dmx_streamType(stream,&amp;streamType);
+                  aprintf(&quot;[PMT]Stream Type :0x%x (%s)\n&quot;,stream,idString);
+                  aprintf(&quot;[PMT]Pid         :0x%x\n&quot;,pid);
+                  aprintf(&quot;[PMT]ES Len      :%d\n&quot;,esDescLen);
+                  
+                  parser-&gt;forward(esDescLen);
+                  left-=(5+esDescLen);
+                  toScan-=(5+esDescLen);
+                  if(*cur&lt;max)
+                  {
+                    pmts[*cur].pid=pid;
+                    pmts[*cur].streamType=streamType;
+                    pmts[*cur].pes=0x0;
+                    if(streamType==ADM_STREAM_MPEG_AUDIO) pmts[*cur].pes=0xC0;
+                    if(streamType==ADM_STREAM_MPEG_VIDEO) pmts[*cur].pes=0xE0;
+                    
+                    (*cur)++;
+                  }
+                  aprintf(&quot;[PMT]left %u toscan %u\n&quot;,left,toScan);
+              }
+              
+      }
+      return 0;
+}
+
+/****EOF**/

Modified: branches/avidemux_2.4_branch/avidemux/ADM_toolkit/automation.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_toolkit/automation.cpp	2007-01-20 10:44:43 UTC (rev 2745)
+++ branches/avidemux_2.4_branch/avidemux/ADM_toolkit/automation.cpp	2007-01-20 15:15:58 UTC (rev 2746)
@@ -114,7 +114,7 @@
 static void setVar(char *in);
 //
 uint8_t trueFalse(char *p);
-extern uint8_t runProbe(char *file);
+extern uint8_t runProbe(const char *file);
 //_________________________________________________________________________
 
 

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_idx_pg.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_idx_pg.cpp	2007-01-20 10:44:43 UTC (rev 2745)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_idx_pg.cpp	2007-01-20 15:15:58 UTC (rev 2746)
@@ -59,7 +59,7 @@
 };
 
 
-DIA_progressIndexing::DIA_progressIndexing(char *name)
+DIA_progressIndexing::DIA_progressIndexing(const char *name)
 {
         dialog=create_dialog1();
         gtk_register_dialog(dialog);

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_NONE/ADM_dialog/DIA_indexing.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_NONE/ADM_dialog/DIA_indexing.cpp	2007-01-20 10:44:43 UTC (rev 2745)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_NONE/ADM_dialog/DIA_indexing.cpp	2007-01-20 15:15:58 UTC (rev 2746)
@@ -15,7 +15,7 @@
 #include &quot;ADM_assert.h&quot; 
 #include &quot;DIA_idx_pg.h&quot;
 
-DIA_progressIndexing::DIA_progressIndexing(char *name)
+DIA_progressIndexing::DIA_progressIndexing(const char *name)
 {}
 DIA_progressIndexing::~DIA_progressIndexing()
 {}

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/DIA_indexing.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/DIA_indexing.cpp	2007-01-20 10:44:43 UTC (rev 2745)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/DIA_indexing.cpp	2007-01-20 15:15:58 UTC (rev 2746)
@@ -15,7 +15,7 @@
 #include &quot;ADM_assert.h&quot; 
 #include &quot;DIA_idx_pg.h&quot;
 
-DIA_progressIndexing::DIA_progressIndexing(char *name)
+DIA_progressIndexing::DIA_progressIndexing(const char *name)
 {}
 DIA_progressIndexing::~DIA_progressIndexing()
 {}

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_idx_pg.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_idx_pg.h	2007-01-20 10:44:43 UTC (rev 2745)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_idx_pg.h	2007-01-20 15:15:58 UTC (rev 2746)
@@ -10,7 +10,7 @@
 		uint32_t	_nextUpdate;
         
 public:
-                        DIA_progressIndexing(char *name);
+                        DIA_progressIndexing(const char *name);
                         ~DIA_progressIndexing();
           uint8_t       update(uint32_t done,uint32_t total, uint32_t nbImage, uint32_t hh, uint32_t mm, uint32_t ss);
           uint8_t        abortRequest(void);


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000072.html">[Avidemux-svn-commit] r2745 -	branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_mpegdemuxer
</A></li>
	<LI>Next message: <A HREF="000074.html">[Avidemux-svn-commit] r2747 -	branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#73">[ date ]</a>
              <a href="thread.html#73">[ thread ]</a>
              <a href="subject.html#73">[ subject ]</a>
              <a href="author.html#73">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">More information about the Avidemux-svn-commit
mailing list</a><br>
</body></html>
