<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Avidemux-svn-commit] r2697 - in	branches/avidemux_2.4_branch/avidemux: .	ADM_userInterfaces/ADM_GTK/ADM_dialog	ADM_userInterfaces/ADM_GTK/ADM_dialogFactory	ADM_userInterfaces/ADM_NONE/ADM_dialogFactory	ADM_userInterfaces/ADM_QT4/ADM_dialogFactory	ADM_userInterfaces/ADM_commonUI ADM_video ADM_videoFilter
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/avidemux-svn-commit/2007-January/index.html" >
   <LINK REL="made" HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r2697%20-%20in%0A%09branches/avidemux_2.4_branch/avidemux%3A%20.%0A%09ADM_userInterfaces/ADM_GTK/ADM_dialog%0A%09ADM_userInterfaces/ADM_GTK/ADM_dialogFactory%0A%09ADM_userInterfaces/ADM_NONE/ADM_dialogFactory%0A%09ADM_userInterfaces/ADM_QT4/ADM_dialogFactory%0A%09ADM_userInterfaces/ADM_commonUI%20ADM_video%20ADM_videoFilter&In-Reply-To=%3C200701091954.l09Jshjm014040%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000024.html">
   <LINK REL="Next"  HREF="000026.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Avidemux-svn-commit] r2697 - in	branches/avidemux_2.4_branch/avidemux: .	ADM_userInterfaces/ADM_GTK/ADM_dialog	ADM_userInterfaces/ADM_GTK/ADM_dialogFactory	ADM_userInterfaces/ADM_NONE/ADM_dialogFactory	ADM_userInterfaces/ADM_QT4/ADM_dialogFactory	ADM_userInterfaces/ADM_commonUI ADM_video ADM_videoFilter</H1>
    <B>mean at BerliOS</B> 
    <A HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r2697%20-%20in%0A%09branches/avidemux_2.4_branch/avidemux%3A%20.%0A%09ADM_userInterfaces/ADM_GTK/ADM_dialog%0A%09ADM_userInterfaces/ADM_GTK/ADM_dialogFactory%0A%09ADM_userInterfaces/ADM_NONE/ADM_dialogFactory%0A%09ADM_userInterfaces/ADM_QT4/ADM_dialogFactory%0A%09ADM_userInterfaces/ADM_commonUI%20ADM_video%20ADM_videoFilter&In-Reply-To=%3C200701091954.l09Jshjm014040%40sheep.berlios.de%3E"
       TITLE="[Avidemux-svn-commit] r2697 - in	branches/avidemux_2.4_branch/avidemux: .	ADM_userInterfaces/ADM_GTK/ADM_dialog	ADM_userInterfaces/ADM_GTK/ADM_dialogFactory	ADM_userInterfaces/ADM_NONE/ADM_dialogFactory	ADM_userInterfaces/ADM_QT4/ADM_dialogFactory	ADM_userInterfaces/ADM_commonUI ADM_video ADM_videoFilter">mean at mail.berlios.de
       </A><BR>
    <I>Tue Jan  9 20:54:43 CET 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="000024.html">[Avidemux-svn-commit] r2696 - in	branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces:	ADM_NONE ADM_NONE/ADM_dialogFactory ADM_QT4	ADM_QT4/ADM_dialogFactory
</A></li>
        <LI>Next message: <A HREF="000026.html">[Avidemux-svn-commit] r2698 -	branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialogFactory
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#25">[ date ]</a>
              <a href="thread.html#25">[ thread ]</a>
              <a href="subject.html#25">[ subject ]</a>
              <a href="author.html#25">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: mean
Date: 2007-01-09 20:54:42 +0100 (Tue, 09 Jan 2007)
New Revision: 2697

Added:
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialogFactory/FAC_float.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidAddBorder.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidAddBorder.h
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidBSmear.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidFastConvolution.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidFlux.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidFlux.h
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidMsmooth.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/Makefile.am
Removed:
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_BSMear.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_Msmooth.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_clean.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_guiAddBorder.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_guiBSMear.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidAddBorder.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidAddBorder.h
   branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidBSmear.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidFastConvolution.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidFlux.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidFlux.h
   branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidMsmooth.cpp
Modified:
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/Makefile.am
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialogFactory/DIA_dialogFactory.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialogFactory/FAC_toggle.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialogFactory/Makefile.am
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_NONE/ADM_dialogFactory/FAC_toggle.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialogFactory/FAC_toggle.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_factory.h
   branches/avidemux_2.4_branch/avidemux/ADM_video/Makefile.am
   branches/avidemux_2.4_branch/avidemux/Makefile.am
Log:
enhance dialogFactory

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_BSMear.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_BSMear.cpp	2007-01-08 21:29:24 UTC (rev 2696)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_BSMear.cpp	2007-01-09 19:54:42 UTC (rev 2697)
@@ -1,28 +0,0 @@
-/***************************************************************************
-                          DIA_BSMear.cpp  -  description
-                             -------------------
-
-			    GUI for cropping including autocrop
-			    +Revisted the Gtk2 way
-			     +Autocrop now in RGB space (more accurate)
-
-    begin                : Fri May 3 2002
-    copyright            : (C) 2002 by mean
-    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-
-// Empty
-void dummy_empty_bs( void )
-{
-
-}
\ No newline at end of file

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_Msmooth.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_Msmooth.cpp	2007-01-08 21:29:24 UTC (rev 2696)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_Msmooth.cpp	2007-01-09 19:54:42 UTC (rev 2697)
@@ -1,210 +0,0 @@
-//
-// C++ Implementation: DIA_Msmooth
-//
-// Description: 
-//
-//
-// Author: mean &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>&gt;, (C) 2004
-//
-// Copyright: See COPYING file that comes with this distribution
-//
-//
-//
-// C++ Implementation: DIA_decimate
-//
-// Description: 
-//
-//
-// Author: mean &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>&gt;, (C) 2004
-//
-// Copyright: See COPYING file that comes with this distribution
-//
-//
-//
-// C++ Implementation: DIA_dectel
-//
-// Description: 
-//
-//
-// Author: mean &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>&gt;, (C) 2004
-//
-// Copyright: See COPYING file that comes with this distribution
-//
-//
-
-
-#include &lt;config.h&gt;
-
-
-#include &lt;string.h&gt;
-#include &lt;stdio.h&gt;
-
-# include &lt;math.h&gt;
-
-#include &quot;default.h&quot;
-#include &quot;ADM_toolkit_gtk/toolkit_gtk_include.h&quot;
-#include &quot;ADM_toolkit_gtk/ADM_gladeSupport.h&quot;
-#include &quot;ADM_toolkit_gtk/toolkit_gtk.h&quot;
-
-#include &quot;ADM_video/ADM_vidMSmooth_param.h&quot;
-static GtkWidget	*create_dialog1 (void);
-#define SPIN_GET(x,y) {param-&gt;y= gtk_spin_button_get_value_as_int(GTK_SPIN_BUTTON(WID(x))) ;}
-#define SPIN_SET(x,y)  {gtk_spin_button_set_value(GTK_SPIN_BUTTON(WID(x)),(gfloat)param-&gt;y) ;}
-#define CHECK_GET(x,y) {param-&gt;y=gtk_toggle_button_get_active( GTK_TOGGLE_BUTTON(WID(x)));}
-#define CHECK_SET(x,y) {gtk_toggle_button_set_active( GTK_TOGGLE_BUTTON(WID(x)),param-&gt;y);}	
-uint8_t DIA_getMSmooth(MSMOOTH_PARAM *param);
-uint8_t DIA_getMSmooth(MSMOOTH_PARAM *param)
-{
-GtkWidget *dialog;
-int ret=0;
-	dialog=create_dialog1();
-	
-	// Update
-	
-	CHECK_SET(checkbuttonHQ,highq);
-	CHECK_SET(checkbuttonShowMask,showmask);
-	
-	SPIN_SET(spinbuttonThresh,threshold);
-	SPIN_SET(spinbuttonStrength,strength);
-	gtk_register_dialog(dialog);
-	
-	if(gtk_dialog_run(GTK_DIALOG(dialog))==GTK_RESPONSE_OK)
-	{
-		CHECK_GET(checkbuttonHQ,highq);
-		CHECK_GET(checkbuttonShowMask,showmask);
-		SPIN_GET(spinbuttonThresh,threshold);
-		SPIN_GET(spinbuttonStrength,strength);		
-		ret=1;
-	
-	}
-        gtk_unregister_dialog(dialog);
-	gtk_widget_destroy(dialog);
-	return ret;
-
-}
-
-//__________________________________
-
-GtkWidget*
-create_dialog1 (void)
-{
-  GtkWidget *dialog1;
-  GtkWidget *dialog_vbox1;
-  GtkWidget *table1;
-  GtkWidget *label1;
-  GtkWidget *label2;
-  GtkWidget *label3;
-  GtkWidget *label4;
-  GtkWidget *checkbuttonHQ;
-  GtkWidget *checkbuttonShowMask;
-  GtkObject *spinbuttonThresh_adj;
-  GtkWidget *spinbuttonThresh;
-  GtkObject *spinbuttonStrength_adj;
-  GtkWidget *spinbuttonStrength;
-  GtkWidget *dialog_action_area1;
-  GtkWidget *cancelbutton1;
-  GtkWidget *okbutton1;
-
-  dialog1 = gtk_dialog_new ();
-  gtk_window_set_title (GTK_WINDOW (dialog1), _(&quot;MSmooth settings&quot;));
-
-  dialog_vbox1 = GTK_DIALOG (dialog1)-&gt;vbox;
-  gtk_widget_show (dialog_vbox1);
-
-  table1 = gtk_table_new (4, 2, FALSE);
-  gtk_widget_show (table1);
-  gtk_box_pack_start (GTK_BOX (dialog_vbox1), table1, TRUE, TRUE, 0);
-
-  label1 = gtk_label_new (_(&quot;High Quality :&quot;));
-  gtk_widget_show (label1);
-  gtk_table_attach (GTK_TABLE (table1), label1, 0, 1, 0, 1,
-                    (GtkAttachOptions) (GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-  gtk_label_set_justify (GTK_LABEL (label1), GTK_JUSTIFY_LEFT);
-  gtk_misc_set_alignment (GTK_MISC (label1), 0, 0.5);
-
-  label2 = gtk_label_new (_(&quot;Show Mask :&quot;));
-  gtk_widget_show (label2);
-  gtk_table_attach (GTK_TABLE (table1), label2, 0, 1, 1, 2,
-                    (GtkAttachOptions) (GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-  gtk_label_set_justify (GTK_LABEL (label2), GTK_JUSTIFY_LEFT);
-  gtk_misc_set_alignment (GTK_MISC (label2), 0, 0.5);
-
-  label3 = gtk_label_new (_(&quot;Threshold :&quot;));
-  gtk_widget_show (label3);
-  gtk_table_attach (GTK_TABLE (table1), label3, 0, 1, 2, 3,
-                    (GtkAttachOptions) (GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-  gtk_label_set_justify (GTK_LABEL (label3), GTK_JUSTIFY_LEFT);
-  gtk_misc_set_alignment (GTK_MISC (label3), 0, 0.5);
-
-  label4 = gtk_label_new (_(&quot;Filter Strength :&quot;));
-  gtk_widget_show (label4);
-  gtk_table_attach (GTK_TABLE (table1), label4, 0, 1, 3, 4,
-                    (GtkAttachOptions) (GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-  gtk_label_set_justify (GTK_LABEL (label4), GTK_JUSTIFY_LEFT);
-  gtk_misc_set_alignment (GTK_MISC (label4), 0, 0.5);
-
-  checkbuttonHQ = gtk_check_button_new_with_mnemonic (&quot;&quot;);
-  gtk_widget_show (checkbuttonHQ);
-  gtk_table_attach (GTK_TABLE (table1), checkbuttonHQ, 1, 2, 0, 1,
-                    (GtkAttachOptions) (GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-
-  checkbuttonShowMask = gtk_check_button_new_with_mnemonic (&quot;&quot;);
-  gtk_widget_show (checkbuttonShowMask);
-  gtk_table_attach (GTK_TABLE (table1), checkbuttonShowMask, 1, 2, 1, 2,
-                    (GtkAttachOptions) (GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-
-  spinbuttonThresh_adj = gtk_adjustment_new (1, 0, 100, 1, 10, 10);
-  spinbuttonThresh = gtk_spin_button_new (GTK_ADJUSTMENT (spinbuttonThresh_adj), 1, 0);
-  gtk_widget_show (spinbuttonThresh);
-  gtk_table_attach (GTK_TABLE (table1), spinbuttonThresh, 1, 2, 2, 3,
-                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-  gtk_spin_button_set_numeric (GTK_SPIN_BUTTON (spinbuttonThresh), TRUE);
-
-  spinbuttonStrength_adj = gtk_adjustment_new (1, 0, 100, 1, 10, 10);
-  spinbuttonStrength = gtk_spin_button_new (GTK_ADJUSTMENT (spinbuttonStrength_adj), 1, 0);
-  gtk_widget_show (spinbuttonStrength);
-  gtk_table_attach (GTK_TABLE (table1), spinbuttonStrength, 1, 2, 3, 4,
-                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-  gtk_spin_button_set_numeric (GTK_SPIN_BUTTON (spinbuttonStrength), TRUE);
-
-  dialog_action_area1 = GTK_DIALOG (dialog1)-&gt;action_area;
-  gtk_widget_show (dialog_action_area1);
-  gtk_button_box_set_layout (GTK_BUTTON_BOX (dialog_action_area1), GTK_BUTTONBOX_END);
-
-  cancelbutton1 = gtk_button_new_from_stock (&quot;gtk-cancel&quot;);
-  gtk_widget_show (cancelbutton1);
-  gtk_dialog_add_action_widget (GTK_DIALOG (dialog1), cancelbutton1, GTK_RESPONSE_CANCEL);
-  GTK_WIDGET_SET_FLAGS (cancelbutton1, GTK_CAN_DEFAULT);
-
-  okbutton1 = gtk_button_new_from_stock (&quot;gtk-ok&quot;);
-  gtk_widget_show (okbutton1);
-  gtk_dialog_add_action_widget (GTK_DIALOG (dialog1), okbutton1, GTK_RESPONSE_OK);
-  GTK_WIDGET_SET_FLAGS (okbutton1, GTK_CAN_DEFAULT);
-
-  /* Store pointers to all widgets, for use by lookup_widget(). */
-  GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog1, &quot;dialog1&quot;);
-  GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog_vbox1, &quot;dialog_vbox1&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, table1, &quot;table1&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, label1, &quot;label1&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, label2, &quot;label2&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, label3, &quot;label3&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, label4, &quot;label4&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, checkbuttonHQ, &quot;checkbuttonHQ&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, checkbuttonShowMask, &quot;checkbuttonShowMask&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, spinbuttonThresh, &quot;spinbuttonThresh&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, spinbuttonStrength, &quot;spinbuttonStrength&quot;);
-  GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog_action_area1, &quot;dialog_action_area1&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, cancelbutton1, &quot;cancelbutton1&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, okbutton1, &quot;okbutton1&quot;);
-
-  return dialog1;
-}
-

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_clean.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_clean.cpp	2007-01-08 21:29:24 UTC (rev 2696)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_clean.cpp	2007-01-09 19:54:42 UTC (rev 2697)
@@ -1,207 +0,0 @@
-/***************************************************************************
-                          ADM_guiClean.cpp  -  description
-                             -------------------
-    begin                : Sun Apr 14 2002
-    copyright            : (C) 2002 by mean
-    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#include &quot;config.h&quot;
-
- /*
- * DO NOT EDIT THIS FILE - it is generated by Glade.
- */
-#include &lt;stdio.h&gt;
-#include &lt;stdlib.h&gt;
-#include &lt;string.h&gt;
-
-#include &lt;math.h&gt;
-
-#include &lt;gtk/gtk.h&gt;
-#include &lt;time.h&gt;
-#include &lt;sys/time.h&gt;
-
-#include &lt;ADM_assert.h&gt;
-#include &quot;fourcc.h&quot;
-#include &quot;avio.hxx&quot;
-#include &quot;avi_vars.h&quot;
-#ifdef HAVE_ENCODER
-
-
-#include &quot;ADM_editor/ADM_edit.hxx&quot;
-#include &quot;ADM_video/ADM_genvideo.hxx&quot;
-#include &quot;ADM_video/ADM_vidClean.h&quot;
-
-
-
-static int getSmoothParams(	uint32_t *w,uint32_t 	*w2);
-static GtkWidget  *create_dialog1 (void);
-
-static GtkObject *blend_adj;
-static GtkObject *radius_adj;
-
-
-
-
-#if 0
-//
-//      Get crop parameters from GUI
-//                         left, right, top, down , initial size
-//
-int getSmoothParams(	uint32_t *radius,uint32_t 	*stre)
-{
-static 	GtkWidget *resi;
-uint32_t 	ir,is;
-int             r=0;
-
-                ir=*radius;
-                is=*stre;
-
-                resi=create_dialog1();
-                gtk_widget_show(resi);
-                gtk_adjustment_set_value( GTK_ADJUSTMENT(blend_adj),(  gdouble  ) is );
-                gtk_adjustment_set_value( GTK_ADJUSTMENT(radius_adj),(  gdouble  ) ir*2 );
-
-                int response;
-                response=gtk_dialog_run(GTK_DIALOG(dialog));
-
-                if(response==GTK_REPLY_OK)
-                {
-                        *radius= (uint32_t)floor(GTK_ADJUSTMENT(radius_adj)-&gt;value);
-                        *radius=*radius/2;
-                        *stre=is;
-                        r=1;
-                }
-                gtk_widget_destroy(resi);
-                return r;
-}
-//
-//
-//
-//
-
-
-GtkWidget*
-create_dialog1 (void)
-{
-  GtkWidget *dialog1;
-  GtkWidget *dialog_vbox1;
-  GtkWidget *vbox1;
-  GtkWidget *accellabel1;
-  GtkWidget *hscale1;
-  GtkWidget *label1;
-  GtkWidget *hscale2;
-  GtkWidget *dialog_action_area1;
-  GtkWidget *hbox1;
-  GtkWidget *button_ok;
-  GtkWidget *button_ko;
-  GtkWidget *button_preview;
-
-  dialog1 = gtk_dialog_new ();
-  gtk_object_set_data (GTK_OBJECT (dialog1), &quot;dialog1&quot;, dialog1);
-  gtk_window_set_title (GTK_WINDOW (dialog1), &quot;Clean smoother&quot;);
-  gtk_window_set_policy (GTK_WINDOW (dialog1), TRUE, TRUE, FALSE);
-   gtk_window_set_modal(GTK_WINDOW(dialog1), TRUE);
-  dialog_vbox1 = GTK_DIALOG (dialog1)-&gt;vbox;
-  gtk_object_set_data (GTK_OBJECT (dialog1), &quot;dialog_vbox1&quot;, dialog_vbox1);
-
-  gtk_widget_show (dialog_vbox1);
-
-  vbox1 = gtk_vbox_new (FALSE, 0);
-  gtk_widget_ref (vbox1);
-  gtk_object_set_data_full (GTK_OBJECT (dialog1), &quot;vbox1&quot;, vbox1,
-                            (GtkDestroyNotify) gtk_widget_unref);
-  gtk_widget_show (vbox1);
-  gtk_box_pack_start (GTK_BOX (dialog_vbox1), vbox1, TRUE, TRUE, 0);
-
-  accellabel1 = gtk_accel_label_new (&quot;Diameter&quot;);
-  gtk_widget_ref (accellabel1);
-  gtk_object_set_data_full (GTK_OBJECT (dialog1), &quot;accellabel1&quot;, accellabel1,
-                            (GtkDestroyNotify) gtk_widget_unref);
-  gtk_widget_show (accellabel1);
-  gtk_box_pack_start (GTK_BOX (vbox1), accellabel1, FALSE, FALSE, 0);
-
-  radius_adj=gtk_adjustment_new (2, 2, 10, 1, 1, 1);
-
-  hscale1 = gtk_hscale_new (GTK_ADJUSTMENT (radius_adj));
-  gtk_widget_ref (hscale1);
-  gtk_object_set_data_full (GTK_OBJECT (dialog1), &quot;hscale1&quot;, hscale1,
-                            (GtkDestroyNotify) gtk_widget_unref);
-  gtk_widget_show (hscale1);
-  gtk_box_pack_start (GTK_BOX (vbox1), hscale1, TRUE, TRUE, 0);
-
-  gtk_scale_set_digits(GTK_SCALE(hscale1),0);
-
-  label1 = gtk_label_new (&quot;Blend amount&quot;);
-  gtk_widget_ref (label1);
-  gtk_object_set_data_full (GTK_OBJECT (dialog1), &quot;label1&quot;, label1,
-                            (GtkDestroyNotify) gtk_widget_unref);
-  gtk_widget_show (label1);
-  gtk_box_pack_start (GTK_BOX (vbox1), label1, FALSE, FALSE, 0);
-
-  blend_adj= gtk_adjustment_new (1, 1, 10, 1, 1, 1);
-  hscale2 = gtk_hscale_new (GTK_ADJUSTMENT (blend_adj));
-  gtk_widget_ref (hscale2);
-  gtk_object_set_data_full (GTK_OBJECT (dialog1), &quot;hscale2&quot;, hscale2,
-                            (GtkDestroyNotify) gtk_widget_unref);
-   gtk_scale_set_digits(GTK_SCALE(hscale2),0);
-
-  gtk_widget_show (hscale2);
-  gtk_box_pack_start (GTK_BOX (vbox1), hscale2, TRUE, TRUE, 0);
-
-  dialog_action_area1 = GTK_DIALOG (dialog1)-&gt;action_area;
-  gtk_object_set_data (GTK_OBJECT (dialog1), &quot;dialog_action_area1&quot;, dialog_action_area1);
-  gtk_widget_show (dialog_action_area1);
-  gtk_container_set_border_width (GTK_CONTAINER (dialog_action_area1), 10);
-
-  hbox1 = gtk_hbox_new (FALSE, 0);
-  gtk_widget_ref (hbox1);
-  gtk_object_set_data_full (GTK_OBJECT (dialog1), &quot;hbox1&quot;, hbox1,
-                            (GtkDestroyNotify) gtk_widget_unref);
-  gtk_widget_show (hbox1);
-  gtk_box_pack_start (GTK_BOX (dialog_action_area1), hbox1, TRUE, TRUE, 0);
-
-  button_ok = gtk_button_new_with_label (&quot;OK&quot;);
-  gtk_widget_ref (button_ok);
-  gtk_object_set_data_full (GTK_OBJECT (dialog1), &quot;button_ok&quot;, button_ok,
-                            (GtkDestroyNotify) gtk_widget_unref);
-  gtk_widget_show (button_ok);
-  gtk_box_pack_start (GTK_BOX (hbox1), button_ok, FALSE, FALSE, 0);
-
-  button_ko = gtk_button_new_with_label (&quot;Cancel&quot;);
-  gtk_widget_ref (button_ko);
-  gtk_object_set_data_full (GTK_OBJECT (dialog1), &quot;button_ko&quot;, button_ko,
-                            (GtkDestroyNotify) gtk_widget_unref);
-  gtk_widget_show (button_ko);
-  gtk_box_pack_start (GTK_BOX (hbox1), button_ko, FALSE, FALSE, 0);
-
-  button_preview = gtk_button_new_with_label (&quot;Preview&quot;);
-  gtk_widget_ref (button_preview);
-  gtk_object_set_data_full (GTK_OBJECT (dialog1), &quot;button_preview&quot;, button_preview,
-                            (GtkDestroyNotify) gtk_widget_unref);
-  gtk_widget_show (button_preview);
-  gtk_box_pack_start (GTK_BOX (hbox1), button_preview, TRUE, FALSE, 0);
-
-  gtk_signal_connect (GTK_OBJECT (button_ok), &quot;clicked&quot;,
-                      GTK_SIGNAL_FUNC (gui_ok),
-                      (void *)1);
-  gtk_signal_connect (GTK_OBJECT (button_ko), &quot;clicked&quot;,
-                      GTK_SIGNAL_FUNC (gui_ok),
-                      (void *)0);
-
-
-
-  return dialog1;
-}
-
-#endif
-#endif 
-

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/Makefile.am
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/Makefile.am	2007-01-08 21:29:24 UTC (rev 2696)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/Makefile.am	2007-01-09 19:54:42 UTC (rev 2697)
@@ -14,14 +14,13 @@
 	DIA_working.h DIA_busy.cpp DIA_busy.h DIA_exLame.cpp DIA_pipe.cpp DIA_mpeg2opt.cpp \
 	DIA_d3d.cpp DIA_postproc.cpp DIA_enter.cpp DIA_enter.h DIA_xvcd.cpp DIA_muxer.cpp \
 	DIA_xvid.cpp DIA_crop.cpp DIA_color.cpp DIA_encoding.cpp DIA_SVCD.cpp DIA_prefs.cpp \
-	DIA_requant.cpp DIA_xvid4.cpp DIA_lavcodec.cpp DIA_kerneldeint.cpp DIA_BSMear.cpp \
-	DIA_audiodevice.cpp DIA_dectel.cpp DIA_decimate.cpp DIA_Msmooth.cpp DIA_pause.cpp \
+	DIA_requant.cpp DIA_xvid4.cpp DIA_lavcodec.cpp DIA_kerneldeint.cpp \
+	DIA_audiodevice.cpp DIA_dectel.cpp DIA_decimate.cpp DIA_pause.cpp \
 	DIA_DVDff.cpp DIA_lavdecoder.cpp DIA_lame.cpp DIA_calculator.cpp DIA_equalizer.cpp \
 	DIA_vobsub.cpp DIA_x264.cpp DIA_ocr.cpp DIA_lavpp_deint.cpp DIA_hue.cpp DIA_eq2.cpp \
 	DIA_dgbob.cpp DIA_msharpen.cpp DIA_asharp.cpp DIA_dmx.cpp DIA_idx_pg.cpp DIA_gototime.cpp \
 	DIA_audioTrack.cpp DIA_cnr2.cpp DIA_resizeWiz.cpp DIA_jobs.cpp DIA_jobs_save.cpp DIA_mosaic.cpp \
 	DIA_deblend.cpp DIA_v2v.cpp DIA_tdeint.cpp DIA_builtin.cpp DIA_mpdelogo.cpp DIA_vorbis.cpp \
-	DIA_clean.cpp \
         DIA_chromaShift.cpp \
         DIA_denoise.cpp \
         DIA_preview.cpp \
@@ -41,11 +40,11 @@
 
 
 
-EXTRA_DIST =  DIA_4entries.cpp     DIA_clean.cpp         DIA_enter.cpp     \
+EXTRA_DIST =  DIA_4entries.cpp              DIA_enter.cpp     \
 DIA_mcdeint.cpp     DIA_resize.cpp \
-DIA_BSMear.cpp       DIA_cnr2.cpp          DIA_enter.h          DIA_mjpeg.cpp       DIA_resizeWiz.cpp \
+DIA_cnr2.cpp          DIA_enter.h          DIA_mjpeg.cpp       DIA_resizeWiz.cpp \
 DIA_DVDff.cpp        DIA_color.cpp         DIA_eq2.cpp          DIA_mosaic.cpp      DIA_resizeWiz.h \
-DIA_Msmooth.cpp      DIA_coloryuv.cpp      DIA_equalizer.cpp    DIA_mpdelogo.cpp    DIA_rotate.cpp \
+DIA_coloryuv.cpp      DIA_equalizer.cpp    DIA_mpdelogo.cpp    DIA_rotate.cpp \
 DIA_SVCD.cpp         DIA_contrast.cpp      DIA_exLame.cpp       DIA_mpeg2opt.cpp    DIA_srt.cpp \
 DIA_about.cpp        DIA_conv.cpp          DIA_fade.cpp         DIA_msharpen.cpp    DIA_tdeint.cpp \
 DIA_acodec.cpp       DIA_crop.cpp          DIA_gototime.cpp     DIA_muxer.cpp       DIA_v2v.cpp \

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialogFactory/DIA_dialogFactory.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialogFactory/DIA_dialogFactory.cpp	2007-01-08 21:29:24 UTC (rev 2696)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialogFactory/DIA_dialogFactory.cpp	2007-01-09 19:54:42 UTC (rev 2697)
@@ -33,19 +33,10 @@
     @return nothing
 
 */
-void addLine(diaElem *elem, GtkWidget *dialog, GtkWidget *vbox)
+void addLine(diaElem *elem, GtkWidget *dialog, GtkWidget *vbox,uint32_t line)
 {
-  switch(elem-&gt;mySelf)
-  {
-    case ELEM_TOGGLE:
-        {
-            diaElemToggle *toggle=(diaElemToggle *)elem;
-            toggle-&gt;setMe( (void *)dialog,(void *)vbox);
-        }
-        break;
-    default:
-        ADM_assert(0);  
-  }
+            elem-&gt;setMe( (void *)dialog,(void *)vbox,line);
+  
 }
 /**
     \fn getLine(diaElem *elem, GtkDialog *dialog, GtkWidget *vbox)
@@ -53,19 +44,11 @@
     @return nothing
 
 */
-void getLine(diaElem *elem, GtkWidget *dialog, GtkWidget *vbox)
+void getLine(diaElem *elem, GtkWidget *dialog, GtkWidget *vbox,uint32_t line)
 {
-  switch(elem-&gt;mySelf)
-  {
-    case ELEM_TOGGLE:
-        {
-            diaElemToggle *toggle=(diaElemToggle *)elem;
-            toggle-&gt;getMe();
-        }
-        break;
-    default:
-        ADM_assert(0);  
-  }
+  
+             elem-&gt;getMe();
+  
 }
 /**
     \fn diaFactoryRun(const char *title,uint32_t nb,diaElem **elems)
@@ -83,19 +66,19 @@
   /* First there was a dialog ...*/
   GtkWidget *dialog=gtk_dialog_new ();
   GtkWidget *dialog_vbox1;
-  GtkWidget *vbox1;
+  GtkWidget *table1;
   
   gtk_window_set_title (GTK_WINDOW (dialog),title );
   dialog_vbox1 = GTK_DIALOG (dialog)-&gt;vbox;
   gtk_widget_show (dialog_vbox1);
   
-  vbox1 = gtk_vbox_new (FALSE, 0);
-  gtk_widget_show (vbox1);
-  gtk_box_pack_start (GTK_BOX (dialog_vbox1), vbox1, TRUE, TRUE, 0);
-
+  table1 = gtk_table_new (nb, 2, FALSE);
+  gtk_widget_show (table1);
+  gtk_box_pack_start (GTK_BOX (dialog_vbox1), table1, TRUE, TRUE, 0);
+  
   for(int i=0;i&lt;nb;i++)
   {
-    addLine(elems[i],dialog,vbox1);
+    addLine(elems[i],dialog,table1,i);
     
   }
   // Add ok &amp; cancel button
@@ -117,7 +100,7 @@
   {
     for(int i=0;i&lt;nb;i++)
       {
-        getLine(elems[i],dialog,vbox1);
+        getLine(elems[i],dialog,table1,i);
         
       }
     ret=1;  

Added: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialogFactory/FAC_float.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialogFactory/FAC_float.cpp	2007-01-08 21:29:24 UTC (rev 2696)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialogFactory/FAC_float.cpp	2007-01-09 19:54:42 UTC (rev 2697)
@@ -0,0 +1,86 @@
+/***************************************************************************
+  FAC_float.cpp
+  Handle dialog factory element : Toggle
+  (C) 2006 Mean <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">Fixounet at free.fr</A> 
+***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include &lt;config.h&gt;
+
+
+#include &lt;string.h&gt;
+#include &lt;stdio.h&gt;
+#include &lt;math.h&gt;
+
+#include &quot;default.h&quot;
+#include &quot;ADM_toolkit_gtk/ADM_gladeSupport.h&quot;
+#include &quot;ADM_toolkit_gtk/toolkit_gtk.h&quot;
+#include &quot;ADM_toolkit_gtk/toolkit_gtk_include.h&quot;
+#include &quot;ADM_commonUI/DIA_factory.h&quot;
+#include &quot;ADM_assert.h&quot;
+
+
+
+
+diaElemFloat::diaElemFloat(ELEM_TYPE_FLOAT *intValue,const char *toggleTitle, 
+                            ELEM_TYPE_FLOAT min, ELEM_TYPE_FLOAT max,const char *tip)
+  : diaElem(ELEM_FLOAT)
+{
+  param=(void *)intValue;
+  paramTitle=toggleTitle;
+  this-&gt;min=min;
+  this-&gt;max=max;
+  this-&gt;tip=tip;
+}
+
+diaElemFloat::~diaElemFloat()
+{
+  
+}
+void diaElemFloat::setMe(void *dialog, void *opaque,uint32_t line)
+{
+  GtkWidget *widget;
+  GtkObject *adj;
+  GtkWidget *label;
+  
+  label = gtk_label_new (paramTitle);
+  gtk_widget_show(label);
+  
+  gtk_table_attach (GTK_TABLE (opaque), label, 0, 1, line, line+1,
+                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
+                    (GtkAttachOptions) (0), 0, 0);
+  
+  ELEM_TYPE_FLOAT val=*(ELEM_TYPE_FLOAT *)param;
+  widget = gtk_spin_button_new_with_range(min,max,0.1);
+  gtk_spin_button_set_numeric (GTK_SPIN_BUTTON(widget),TRUE);
+  gtk_spin_button_set_digits  (GTK_SPIN_BUTTON(widget),2);
+  
+  
+  gtk_widget_show (widget);
+  
+  gtk_table_attach (GTK_TABLE (opaque), widget, 1, 2, line, line+1,
+                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
+                    (GtkAttachOptions) (0), 0, 0);
+  
+  
+  
+  myWidget=(void *)widget;
+  
+}
+void diaElemFloat::getMe(void)
+{
+  GtkWidget *widget=(GtkWidget *)myWidget;
+  ELEM_TYPE_FLOAT *val=(ELEM_TYPE_FLOAT *)param;
+  ADM_assert(widget);
+  *(ELEM_TYPE_FLOAT *)param=gtk_spin_button_get_value_as_int (GTK_SPIN_BUTTON (widget));
+}
+
+//EOF

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialogFactory/FAC_toggle.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialogFactory/FAC_toggle.cpp	2007-01-08 21:29:24 UTC (rev 2696)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialogFactory/FAC_toggle.cpp	2007-01-09 19:54:42 UTC (rev 2697)
@@ -42,14 +42,26 @@
 {
   
 }
-void diaElemToggle::setMe(void *dialog, void *opaque)
+void diaElemToggle::setMe(void *dialog, void *opaque,uint32_t line)
 {
   GtkWidget *widget;
+  GtkWidget *label;
   
-  widget = gtk_check_button_new_with_mnemonic (paramTitle);
+  
+  label = gtk_label_new (paramTitle);
+  gtk_widget_show(label);
+  
+  gtk_table_attach (GTK_TABLE (opaque), label, 0, 1, line, line+1,
+                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
+                    (GtkAttachOptions) (0), 0, 0);
+  
+  widget = gtk_check_button_new_with_mnemonic (&quot;&quot;);
   gtk_widget_show (widget);
   myWidget=(void *)widget;
-  gtk_box_pack_start (GTK_BOX (opaque), widget, FALSE, FALSE, 0);
+  
+  gtk_table_attach (GTK_TABLE (opaque), widget, 1, 2, line, line+1,
+                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
+                    (GtkAttachOptions) (0), 0, 0);
   gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (widget), *(uint32_t *)param);
 }
 void diaElemToggle::getMe(void)

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialogFactory/Makefile.am
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialogFactory/Makefile.am	2007-01-08 21:29:24 UTC (rev 2696)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialogFactory/Makefile.am	2007-01-09 19:54:42 UTC (rev 2697)
@@ -8,6 +8,6 @@
 
 libADM_dialogFactory_a_METASOURCES = AUTO
 
-libADM_dialogFactory_a_SOURCES = DIA_dialogFactory.cpp FAC_toggle.cpp
+libADM_dialogFactory_a_SOURCES = DIA_dialogFactory.cpp FAC_toggle.cpp FAC_integer.cpp FAC_float.cpp
 
 

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_NONE/ADM_dialogFactory/FAC_toggle.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_NONE/ADM_dialogFactory/FAC_toggle.cpp	2007-01-08 21:29:24 UTC (rev 2696)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_NONE/ADM_dialogFactory/FAC_toggle.cpp	2007-01-09 19:54:42 UTC (rev 2697)
@@ -36,11 +36,73 @@
 {
   
 }
-void diaElemToggle::setMe(void *dialog, void *opaque)
+void diaElemToggle::setMe(void *dialog, void *opaque,uint32_t l)
 {
 }
 void diaElemToggle::getMe(void)
 {
 }
 
+//******************************************************
+diaElemInteger::diaElemInteger(int32_t *intValue,const char *toggleTitle, int32_t min, int32_t max,const char *tip)
+  : diaElem(ELEM_TOGGLE)
+{
+ }
+
+diaElemInteger::~diaElemInteger()
+{
+  
+}
+void diaElemInteger::setMe(void *dialog, void *opaque,uint32_t line)
+{
+ 
+}
+void diaElemInteger::getMe(void)
+{
+ 
+}
+
+//******************************************************
+diaElemUInteger::diaElemUInteger(uint32_t *intValue,const char *toggleTitle, uint32_t min, uint32_t max,const char *tip)
+  : diaElem(ELEM_TOGGLE)
+{
+ }
+
+diaElemUInteger::~diaElemUInteger()
+{
+  
+}
+void diaElemUInteger::setMe(void *dialog, void *opaque,uint32_t line)
+{
+ 
+}
+void diaElemUInteger::getMe(void)
+{
+ 
+}
+
+//******************************************************
+
+diaElemFloat::diaElemFloat(ELEM_TYPE_FLOAT *intValue,const char *toggleTitle, 
+                            ELEM_TYPE_FLOAT min, ELEM_TYPE_FLOAT max,const char *tip)
+  : diaElem(ELEM_FLOAT)
+{
+}
+
+diaElemFloat::~diaElemFloat()
+{
+  
+}
+void diaElemFloat::setMe(void *dialog, void *opaque,uint32_t line)
+{
+  
+}
+void diaElemFloat::getMe(void)
+{
+ 
+}
+
+
+
+//******************************************************
 //EOF

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialogFactory/FAC_toggle.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialogFactory/FAC_toggle.cpp	2007-01-08 21:29:24 UTC (rev 2696)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialogFactory/FAC_toggle.cpp	2007-01-09 19:54:42 UTC (rev 2697)
@@ -36,11 +36,71 @@
 {
   
 }
-void diaElemToggle::setMe(void *dialog, void *opaque)
+void diaElemToggle::setMe(void *dialog, void *opaque,uint32_t l)
 {
 }
 void diaElemToggle::getMe(void)
 {
 }
 
+
+
+//********************************************************************
+diaElemInteger::diaElemInteger(int32_t *intValue,const char *toggleTitle, int32_t min, int32_t max,const char *tip)
+  : diaElem(ELEM_TOGGLE)
+{
+ }
+
+diaElemInteger::~diaElemInteger()
+{
+  
+}
+void diaElemInteger::setMe(void *dialog, void *opaque,uint32_t line)
+{
+ 
+}
+void diaElemInteger::getMe(void)
+{
+ 
+}
+//******************************************************
+diaElemUInteger::diaElemUInteger(uint32_t *intValue,const char *toggleTitle, uint32_t min, uint32_t max,const char *tip)
+  : diaElem(ELEM_TOGGLE)
+{
+ }
+
+diaElemUInteger::~diaElemUInteger()
+{
+  
+}
+void diaElemUInteger::setMe(void *dialog, void *opaque,uint32_t line)
+{
+ 
+}
+void diaElemUInteger::getMe(void)
+{
+ 
+}
+
+//********************************************************************
+
+diaElemFloat::diaElemFloat(ELEM_TYPE_FLOAT *intValue,const char *toggleTitle, 
+                            ELEM_TYPE_FLOAT min, ELEM_TYPE_FLOAT max,const char *tip)
+  : diaElem(ELEM_FLOAT)
+{
+}
+
+diaElemFloat::~diaElemFloat()
+{
+  
+}
+void diaElemFloat::setMe(void *dialog, void *opaque,uint32_t line)
+{
+  
+}
+void diaElemFloat::getMe(void)
+{
+ 
+}
+
 //EOF

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_factory.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_factory.h	2007-01-08 21:29:24 UTC (rev 2696)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_factory.h	2007-01-09 19:54:42 UTC (rev 2697)
@@ -20,9 +20,11 @@
 {
   ELEM_INVALID=0,
   ELEM_TOGGLE,
+  ELEM_INTEGER,
+  ELEM_FLOAT,
   ELEM_MAX=ELEM_TOGGLE
 };
-
+/*********************************************/
 class diaElem
 {
 
@@ -35,20 +37,56 @@
 
   diaElem(elemEnum num) {param=NULL;mySelf=num;myWidget=NULL;};
   virtual ~diaElem() {};
-  virtual void setMe(void *dialog, void *opaque)=0;
+  virtual void setMe(void *dialog, void *opaque,uint32_t line)=0;
   virtual void getMe(void)=0;
 };
-
+/*********************************************/
 class diaElemToggle : public diaElem
 {
 
 public:
   diaElemToggle(uint32_t *toggleValue,const char *toggleTitle, const char *tip=NULL);
   virtual ~diaElemToggle() ;
-  void setMe(void *dialog, void *opaque);
+  void setMe(void *dialog, void *opaque,uint32_t line);
   void getMe(void);
 };
+/*********************************************/
+class diaElemInteger : public diaElem
+{
 
+public:
+  int32_t min,max;
+  diaElemInteger(int32_t *intValue,const char *toggleTitle, int32_t min, int32_t max,const char *tip=NULL);
+  virtual ~diaElemInteger() ;
+  void setMe(void *dialog, void *opaque,uint32_t line);
+  void getMe(void);
+};
+/* Same but unsigned */
+class diaElemUInteger : public diaElem
+{
+
+public:
+  uint32_t min,max;
+  diaElemUInteger(uint32_t *intValue,const char *toggleTitle, uint32_t min, uint32_t max,const char *tip=NULL);
+  virtual ~diaElemUInteger() ;
+  void setMe(void *dialog, void *opaque,uint32_t line);
+  void getMe(void);
+};
+
+/*********************************************/
+#define ELEM_TYPE_FLOAT float
+class diaElemFloat : public diaElem
+{
+
+public:
+  ELEM_TYPE_FLOAT min,max;
+  diaElemFloat(ELEM_TYPE_FLOAT *intValue,const char *toggleTitle, ELEM_TYPE_FLOAT min, 
+               ELEM_TYPE_FLOAT max,const char *tip=NULL);
+  virtual ~diaElemFloat() ;
+  void setMe(void *dialog, void *opaque,uint32_t line);
+  void getMe(void);
+};
+/*********************************************/
 uint8_t diaFactoryRun(const char *title,uint32_t nb,diaElem **elems);
 
 #endif

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_guiAddBorder.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_guiAddBorder.cpp	2007-01-08 21:29:24 UTC (rev 2696)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_guiAddBorder.cpp	2007-01-09 19:54:42 UTC (rev 2697)
@@ -1,61 +0,0 @@
-/***************************************************************************
-                          ADM_guiAddBorder.cpp  -  description
-                             -------------------
-    begin                : Sun Aug 11 2002
-    copyright            : (C) 2002 by mean
-    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#include &quot;config.h&quot;
-
-#include &lt;stdio.h&gt;
-#include &lt;stdlib.h&gt;
-#include &lt;string.h&gt;
-
-
-#include &lt;time.h&gt;
-#include &lt;sys/time.h&gt;
-
-
-#include &quot;fourcc.h&quot;
-#include &quot;avio.hxx&quot;
-#include &quot;config.h&quot;
-#include &quot;avi_vars.h&quot;
-#ifdef HAVE_ENCODER
-
-#include &lt;ADM_assert.h&gt;
-#include &quot;ADM_editor/ADM_edit.hxx&quot;
-#include &quot;ADM_video/ADM_genvideo.hxx&quot;
-//#include &quot;ADM_video/ADM_resizebis.hxx&quot;
-#include &quot;ADM_video/ADM_vidAddBorder.h&quot;
-
-extern uint8_t DIA_4entries(char *title,uint32_t *left,uint32_t *right,uint32_t *top,uint32_t *bottom);
-
-
-uint8_t AVDMVideoAddBorder::configure( AVDMGenericVideoStream *instream)
-{
-UNUSED_ARG(instream);
-
-CROP_PARAMS *par;
-
-     	par=_param;
-
-	 if(DIA_4entries((char *)&quot;Add black borders&quot;,&amp;par-&gt;left,&amp;par-&gt;right,&amp;par-&gt;top,&amp;par-&gt;bottom))
-	 {
-	 		memcpy(&amp;_info,_in-&gt;getInfo(),sizeof(_info));
-			_info.width+=_param-&gt;right+_param-&gt;left;
-			_info.height+=_param-&gt;bottom+_param-&gt;top;
-			return 1;
-	 }
-	 return 0;
-}
-
-#endif

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_guiBSMear.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_guiBSMear.cpp	2007-01-08 21:29:24 UTC (rev 2696)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_guiBSMear.cpp	2007-01-09 19:54:42 UTC (rev 2697)
@@ -1,54 +0,0 @@
-/***************************************************************************
-                          ADM_guiBSMear.cpp  -  description
-                             -------------------
- 			Actually it is the same as crop
- 			Blacken borders to remove for example, vhs parasites at bottom
-
-    begin                : Fri Mar 29 2002
-    copyright            : (C) 2002 by mean
-    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#include &quot;config.h&quot;
- 
-#include &lt;stdio.h&gt;
-#include &lt;stdlib.h&gt;
-#include &lt;string.h&gt;
-
-
-#include &lt;time.h&gt;
-#include &lt;sys/time.h&gt;
-
-
-#include &lt;ADM_assert.h&gt;
-#include &quot;fourcc.h&quot;
-#include &quot;avio.hxx&quot;
-#include &quot;config.h&quot;
-#include &quot;avi_vars.h&quot;
-#ifdef HAVE_ENCODER
-
-
-#include &quot;ADM_editor/ADM_edit.hxx&quot;
-#include &quot;ADM_video/ADM_genvideo.hxx&quot;
-#include &quot;ADM_video/ADM_vidCommonFilter.h&quot;
-
-#include &quot;ADM_colorspace/colorspace.h&quot;
-extern int DIA_getCropParams(	char *name,CROP_PARAMS *param,AVDMGenericVideoStream *in);
-
-uint8_t AVDMVideoStreamBSMear::configure( AVDMGenericVideoStream *instream)
-{
-UNUSED_ARG(instream);
-
-	return (DIA_getCropParams(&quot;Blacken Borders&quot;,_param,instream ));
-
-}
-
-#endif

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidAddBorder.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidAddBorder.cpp	2007-01-08 21:29:24 UTC (rev 2696)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidAddBorder.cpp	2007-01-09 19:54:42 UTC (rev 2697)
@@ -1,210 +0,0 @@
-/***************************************************************************
-                          ADM_vidAddBorder.cpp  -  description
-                             -------------------
-    begin                : Sun Aug 11 2002
-    copyright            : (C) 2002 by mean
-    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#include &lt;stdio.h&gt;
-#include &lt;stdlib.h&gt;
-#include &lt;string.h&gt;
-#include &lt;ADM_assert.h&gt;
-
-#include &quot;config.h&quot;
-#include &quot;fourcc.h&quot;
-#include &quot;avio.hxx&quot;
-#include &quot;config.h&quot;
-#include &quot;avi_vars.h&quot;
-#ifdef HAVE_ENCODER
-
-
-#include &quot;ADM_toolkit/toolkit.hxx&quot;
-#include &quot;ADM_editor/ADM_edit.hxx&quot;
-#include &quot;ADM_video/ADM_genvideo.hxx&quot;
-#include &quot;ADM_video/ADM_vidAddBorder.h&quot;
-#include &quot;ADM_video/ADM_vidCommonFilter.h&quot;
-#include &quot;ADM_filter/video_filters.h&quot;
-
-
-static FILTER_PARAM cropParam={4,{&quot;left&quot;,&quot;right&quot;,&quot;top&quot;,&quot;bottom&quot;}};
-
-
-SCRIPT_CREATE(addBorder_script,AVDMVideoAddBorder,cropParam);
-BUILD_CREATE(addBorder_create,AVDMVideoAddBorder);
-
-char *AVDMVideoAddBorder::printConf( void )
-{
- 	static char buf[50];
-
- 	sprintf((char *)buf,&quot; Add Borders %lu x %lu --&gt; %lu x %lu&quot;,
- 				_in-&gt;getInfo()-&gt;width,
- 				_in-&gt;getInfo()-&gt;height,
- 				_info.width,
- 				_info.height);
-        return buf;
-}
-
-AVDMVideoAddBorder::AVDMVideoAddBorder(  AVDMGenericVideoStream *in,CONFcouple *couples)
-{
-
- 	_in=in;		
-   	memcpy(&amp;_info,_in-&gt;getInfo(),sizeof(_info));  		
-	
-		if(couples)
-		{
-
-			 _param=NEW(CROP_PARAMS);
-
-				GET(left);
-				GET(right);
-				GET(top);
-				GET(bottom);
-				_info.width+=_param-&gt;right+_param-&gt;left;
-				_info.height+=_param-&gt;bottom+_param-&gt;top;
-		}	
-			else 			
-		{	// default parameter	
-				_param=NEW(CROP_PARAMS);
-				_param-&gt;left=_param-&gt;top=
-				_param-&gt;right=_param-&gt;bottom=0;
-		}				
-					
- 	//_uncompressed=(uint8_t *)malloc(3*_in-&gt;getInfo()-&gt;width*_in-&gt;getInfo()-&gt;height);
- 	//_uncompressed=new uint8_t [3*_in-&gt;getInfo()-&gt;width*_in-&gt;getInfo()-&gt;height];
-	_uncompressed=new ADMImage(_in-&gt;getInfo()-&gt;width,_in-&gt;getInfo()-&gt;height);
-  ADM_assert(_uncompressed);
-  _info.encoding=1;
-
-  	  	
-}
-AVDMGenericVideoStream *create_addBorder(AVDMGenericVideoStream *in,uint32_t x,uint32_t x2,uint32_t y,uint32_t y2)
-{
-	return new AVDMVideoAddBorder(in,x,x2,y,y2);
-}
-AVDMVideoAddBorder::AVDMVideoAddBorder(  AVDMGenericVideoStream *in,uint32_t x,uint32_t x2,uint32_t y,uint32_t y2)
-{
-
- 	_in=in;		
-   	memcpy(&amp;_info,_in-&gt;getInfo(),sizeof(_info));  		
-
-				_param=NEW(CROP_PARAMS);
-				_param-&gt;left=x;
-				_param-&gt;top=y;
-				_param-&gt;right=x2;
-				_param-&gt;bottom=y2;
-	_info.width+=_param-&gt;right+_param-&gt;left;
-	_info.height+=_param-&gt;bottom+_param-&gt;top;
- 	//_uncompressed=(uint8_t *)malloc(3*_in-&gt;getInfo()-&gt;width*_in-&gt;getInfo()-&gt;height);
- 	//_uncompressed=new uint8_t [3*_in-&gt;getInfo()-&gt;width*_in-&gt;getInfo()-&gt;height];
-	_uncompressed=new ADMImage(_in-&gt;getInfo()-&gt;width,_in-&gt;getInfo()-&gt;height);
-  ADM_assert(_uncompressed);
-  _info.encoding=1;
-
-
-}
-
-uint8_t	AVDMVideoAddBorder::getCoupledConf( CONFcouple **couples)
-{
-
-			ADM_assert(_param);
-			*couples=new CONFcouple(4);
-
-
-	CSET(left);
-	CSET(right);
-	CSET(top);
-	CSET(bottom);
-			return 1;
-
-}
-AVDMVideoAddBorder::~AVDMVideoAddBorder()
-{
- 	delete _uncompressed;
-	DELETE(_param);
-	_uncompressed=NULL;
- 	
-}
-uint8_t AVDMVideoAddBorder::getFrameNumberNoAlloc(uint32_t frame,
-				uint32_t *len,
-   				ADMImage *data,
-				uint32_t *flags)
-{
-
-		if(frame&gt;=_info.nb_frames) 
-		{
-			printf(&quot;Filter : out of bound!\n&quot;);
-			return 0;
-		}
-	
-		ADM_assert(_param);									
-								
-			// read uncompressed frame
-       		if(!_in-&gt;getFrameNumberNoAlloc(frame, len,_uncompressed,flags)) return 0;
-       		
-				// blacken screen
-				memset(YPLANE(data),16,_info.width*_info.height);
-				memset(UPLANE(data),128,(_info.width*_info.height)&gt;&gt;2);
-				memset(VPLANE(data),128,(_info.width*_info.height)&gt;&gt;2);
-
-				// do luma
-				uint8_t *src,*dest;
-       		uint32_t y,x,line,lineout;
-       		
-       		y=_in-&gt;getInfo()-&gt;height;
-       		x=_in-&gt;getInfo()-&gt;width;
-       		line=x;
-		lineout=_info.width;
-		
-		// copy Luma
-       		src=YPLANE(_uncompressed);
-       		dest=YPLANE(data)+_param-&gt;left+_info.width*_param-&gt;top;
-       		
-       		for(uint32_t k=y;k&gt;0;k--)
-       		{
-       		 	    memcpy(dest,src,line);
-       		 	    src+=line;
-       		 	    dest+=lineout;
-       		}
-       		 
-		// U and V now
-		uint8_t *src_u,*src_v;
-		uint8_t *dst_u,*dst_v;
-
-       		src_u=UPLANE(_uncompressed);
-       		src_v=VPLANE(_uncompressed);
-       		line&gt;&gt;=1;
-       		lineout&gt;&gt;=1;       		       		 	
-		dst_u=UPLANE( data)+(_info.width*_param-&gt;top&gt;&gt;2)+
-						(_param-&gt;left&gt;&gt;1);;
-		dst_v= VPLANE( data)+(_info.width*_param-&gt;top&gt;&gt;2)+
-						(_param-&gt;left&gt;&gt;1);;
-
-       		 for(uint32_t k=y&gt;&gt;1;k&gt;0;k--)
-       		 {
-       		 	memcpy(dst_u,src_u,line);
-       		 	memcpy(dst_v,src_v,line);
-
-       			src_u+=line;
-       			src_v+=line;
-
-       			dst_u+=lineout;
-       		    	dst_v+=lineout;
-
-       		 }
-       		  *len= _info.width*_info.height+(_info.width*_info.height&gt;&gt;1);
-		  data-&gt;copyInfo(_uncompressed);
-      return 1;
-}
-
-
-
-#endif

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidAddBorder.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidAddBorder.h	2007-01-08 21:29:24 UTC (rev 2696)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidAddBorder.h	2007-01-09 19:54:42 UTC (rev 2697)
@@ -1,36 +0,0 @@
-/***************************************************************************
-                          ADM_vidAddBorder.h  -  description
-                             -------------------
-    begin                : Sun Aug 11 2002
-    copyright            : (C) 2002 by mean
-    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#ifndef __ADDBORDER__
-#define     __ADDBORDER__
-  class  AVDMVideoAddBorder:public AVDMGenericVideoStream
- {
-
- protected:
-    		virtual char					*printConf(void);
-    		CROP_PARAMS			*_param;
- public:
-
-  							AVDMVideoAddBorder(  AVDMGenericVideoStream *in,CONFcouple *setup);
-							AVDMVideoAddBorder(  AVDMGenericVideoStream *in,uint32_t x,uint32_t x2,uint32_t y,uint32_t y2);
-  			virtual 			~AVDMVideoAddBorder();
-		        virtual 	uint8_t 	getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
-          																	ADMImage *data,uint32_t *flags);
-         				uint8_t 	configure( AVDMGenericVideoStream *instream) ;
-					uint8_t	getCoupledConf( CONFcouple **couples)		;
- }     ;
-
-#endif

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidBSmear.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidBSmear.cpp	2007-01-08 21:29:24 UTC (rev 2696)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidBSmear.cpp	2007-01-09 19:54:42 UTC (rev 2697)
@@ -1,185 +0,0 @@
-/***************************************************************************
-                          ADM_vidBSMear.cpp  -  description
-                             -------------------
-         change part of video into black borders
-
-          Each one ,must be even
-
-          Copy / Paste from crop,almost the same thing
-
-
-    begin                : Sun Mar 24 2002
-    copyright            : (C) 2002 by mean
-    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-#include &lt;stdio.h&gt;
-#include &lt;stdlib.h&gt;
-#include &lt;string.h&gt;
-#include &lt;ADM_assert.h&gt;
-
-#include &quot;config.h&quot;
-#include &quot;fourcc.h&quot;
-#include &quot;avio.hxx&quot;
-#include &quot;config.h&quot;
-#include &quot;avi_vars.h&quot;
-#ifdef HAVE_ENCODER
-
-
-#include &quot;ADM_toolkit/toolkit.hxx&quot;
-#include &quot;ADM_editor/ADM_edit.hxx&quot;
-#include &quot;ADM_video/ADM_genvideo.hxx&quot;
-#include &quot;ADM_video/ADM_vidCommonFilter.h&quot;
-#include &quot;ADM_filter/video_filters.h&quot;
-
-
-static FILTER_PARAM cropParam={4,{&quot;left&quot;,&quot;right&quot;,&quot;top&quot;,&quot;bottom&quot;}};
-
-
-SCRIPT_CREATE(bsmear_script,AVDMVideoStreamBSMear,cropParam);
-
-char *AVDMVideoStreamBSMear::printConf( void )
-{
- 	static char buf[50];
- 	
- 	sprintf((char *)buf,&quot; Black l:%lu  r:%lu  u:%lu x d:%lu&quot;,
- 				_param-&gt;left,
- 					_param-&gt;right,
- 					_param-&gt;top,
- 					_param-&gt;bottom);
-        return buf;
-}
-
-//_______________________________________________________________
-
-AVDMVideoStreamBSMear::AVDMVideoStreamBSMear(  	AVDMGenericVideoStream *in,CONFcouple *couples)
-{
-
-
-  	_in=in;		
-   	memcpy(&amp;_info,_in-&gt;getInfo(),sizeof(_info));  		
-
-		if(couples)
-		{
-			_param=NEW(CROP_PARAMS);
-			GET(left);
-			GET(right);
-			GET(top);
-			GET(bottom);
-		}	
-			else 	
-		{	// default parameter	
-				_param=NEW(CROP_PARAMS);
-				_param-&gt;left=_param-&gt;top=
-						_param-&gt;right=_param-&gt;bottom=0;
-		}										
- 	
-  _info.encoding=1;
-
-  	  	
-}
-
-uint8_t	AVDMVideoStreamBSMear::getCoupledConf( CONFcouple **couples)
-{
-
-			ADM_assert(_param);
-			*couples=new CONFcouple(4);
-
-#define CSET(x)  (*couples)-&gt;setCouple((char *)#x,(_param-&gt;x))
-	CSET(left);
-	CSET(right);
-	CSET(top);
-	CSET(bottom);
-			return 1;
-
-}
-AVDMVideoStreamBSMear::~AVDMVideoStreamBSMear()
-{
- 	DELETE(_param);
- 	
-}
-
-//
-//	Blacken borders, just setting luma to null should be enough
-//
-
-uint8_t AVDMVideoStreamBSMear::getFrameNumberNoAlloc(uint32_t frame,
-				uint32_t *len,
-   				ADMImage *data,
-				uint32_t *flags)
-{
-
-			if(frame&gt;=_info.nb_frames) 
-			{
-				printf(&quot;Filter : out of bound!\n&quot;);
-				return 0;
-			}
-	
-			ADM_assert(_param);									
-								
-			// read uncompressed frame directly into follower
-			// and blacken there
-			
-       		if(!_in-&gt;getFrameNumberNoAlloc(frame, len,data,flags)) return 0;
-       		  *len= _info.width*_info.height+(_info.width*_info.height&gt;&gt;1);       			
-       		  // blacken top
-       		  uint8_t *srcY=YPLANE(data);
-		  uint8_t *srcU=UPLANE(data);
-		  uint8_t *srcV=VPLANE(data);
-       		  uint32_t bytes=_info.width*_param-&gt;top;
-		  uint32_t page=_info.width*_info.height;
-       		
-       		  memset(srcY,0x10,bytes);
-		  memset(srcU,0x80,bytes&gt;&gt;2);
-		  memset(srcV,0x80,bytes&gt;&gt;2);
-       		  // left &amp; right
-       		  uint32_t stride=_info.width;
-		  
-       		  for(uint32_t y=_info.height;y&gt;0;y--)
-       		  {
-       		        memset(srcY,0x10,_param-&gt;left);
-       		        memset(srcY+stride-_param-&gt;right,0,_param-&gt;right);       		
-       		        srcY+=stride;       		
-		 }
-		 for(uint32_t y=_info.height&gt;&gt;1;y&gt;0;y--)
-       		  {
-       		        
-			memset(srcU,0x80,_param-&gt;left&gt;&gt;1);
-			memset(srcV,0x80,_param-&gt;left&gt;&gt;1);
-			memset(srcU+((stride-_param-&gt;right)&gt;&gt;1),0x80,_param-&gt;right&gt;&gt;1);
-			memset(srcV+((stride-_param-&gt;right)&gt;&gt;1),0x80,_param-&gt;right&gt;&gt;1);
-			srcU+=stride&gt;&gt;1;
-			srcV+=stride&gt;&gt;1;
-       		  }
-       		
-       		  // backen bottom
-       		  srcY=YPLANE(data)+_info.width*_info.height-1;
-       		
-       		 bytes=_info.width*_param-&gt;bottom;
-       	 	 srcY-=bytes;
-       		 memset(srcY,0x10,bytes);
-		// chroma
-		 srcU=UPLANE(data)+(page&gt;&gt;2)-1;
-		 srcU-=bytes&gt;&gt;2;
-       		 memset(srcU,0x80,bytes&gt;&gt;2);
-		 
-		 srcV=VPLANE(data)+(page&gt;&gt;2)-1;
-		 srcV-=bytes&gt;&gt;2;
-       		 memset(srcV,0x80,bytes&gt;&gt;2);
-		 
-		  
-       		  	
-       		         		       		
-      return 1;
-}
-
-#endif

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidFastConvolution.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidFastConvolution.cpp	2007-01-08 21:29:24 UTC (rev 2696)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidFastConvolution.cpp	2007-01-09 19:54:42 UTC (rev 2697)
@@ -1,468 +0,0 @@
-/***************************************************************************
-                          ADM_vidFastConvolution.cpp  -  description
-                             -------------------
-    begin                : Sat Nov 23 2002
-    copyright            : (C) 2002 by mean
-    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#include &quot;config.h&quot;
-    
-#include &lt;stdio.h&gt;
-#include &lt;stdlib.h&gt;
-#include &lt;string.h&gt;
-#include &quot;default.h&quot;
-
-#include &quot;ADM_toolkit/toolkit.hxx&quot;
-#include &quot;ADM_editor/ADM_edit.hxx&quot;
-#include &quot;ADM_video/ADM_genvideo.hxx&quot;
-
-#include&quot;ADM_video/ADM_vidConvolution.hxx&quot;
-#include &quot;ADM_userInterfaces/ADM_commonUI/DIA_factory.h&quot;
-#include &lt;ADM_assert.h&gt;
-
-
-BUILD_CREATE(mean_create,AVDMFastVideoMean);
-BUILD_CREATE(sharpen_create,AVDMFastVideoSharpen);
-BUILD_CREATE(Gaussian_create,AVDMFastVideoGauss);
-
-
-
-uint8_t	AVDMFastVideoConvolution::getCoupledConf( CONFcouple **couples)
-{
-
-	ADM_assert(_param);
-	
-	*couples=new CONFcouple(2);
-
-#define CSET(x)  (*couples)-&gt;setCouple((char *)#x,(_param-&gt;x))
-	CSET(chroma);
-	CSET(luma);
-	return 1;
-
-}
-
-//_______________________________________________________________
-
-AVDMFastVideoConvolution::AVDMFastVideoConvolution(
-			AVDMGenericVideoStream *in,CONFcouple *couples)
-{
-
-
-	_in=in;		
-	memcpy(&amp;_info,_in-&gt;getInfo(),sizeof(_info));
-	_uncompressed=new ADMImage(_in-&gt;getInfo()-&gt;width,_in-&gt;getInfo()-&gt;height);	
-	ADM_assert(_uncompressed); 
-	_info.encoding=1;
-	if(couples==NULL)
-	{
-		_param=NEW( CONV_PARAM);
-		_param-&gt;chroma=1;
-		_param-&gt;luma=1;	
-		printf(&quot;\n Creating from null\n&quot;);				
-	}
-	else
-	{
-		_param=NEW(CONV_PARAM);
-		GET(luma);
-		GET(chroma);
-	}
-
-  	  	
-}
-AVDMFastVideoConvolution::~AVDMFastVideoConvolution()
-{
-	if(_uncompressed)
- 		delete _uncompressed;
-	_uncompressed=NULL;
- 	DELETE(_param);
-}
-
-//
-//	Basically ask a uncompressed frame from editor and ask
-//		GUI to decompress it .
-//
-
-uint8_t AVDMFastVideoConvolution::getFrameNumberNoAlloc(uint32_t frame,
-				uint32_t *len,
-   				ADMImage *data,
-				uint32_t *flags)
-{
-//uint8_t *dst,*dstu,*dstv,*srcu,*srcv;
-uint8_t *x1,*x2,*x3,*o1;
-uint32_t stride,page;
-
-	ADM_assert(frame&lt;_info.nb_frames);
-	ADM_assert(_uncompressed);					
-	stride=_info.width;
-	page=(stride*_info.height)&gt;&gt;2;
-	
-
-	
-	// read uncompressed frame
-	if(!_in-&gt;getFrameNumberNoAlloc(frame, len,_uncompressed,flags)) return 0;               
-         
-	if(!_param-&gt;luma)
-	{
-		memcpy(YPLANE(data),YPLANE(_uncompressed),page*4);
-	}
-	else
-	{
-		o1=YPLANE(data)+stride;
-		x1=YPLANE(_uncompressed);
-		x2=x1+stride;
-		x3=x2+stride;
-
-		// first and last line
-		memcpy(YPLANE(data),YPLANE(_uncompressed),stride);
-		memcpy(YPLANE(data)+page*4-stride,YPLANE(_uncompressed)+page*4-stride,stride);          
-		// Luma
-		for(int32_t y=1;y&lt;(int32_t)_info.height-1;y++)
-		{
-			doLine(x1,x2,x3,o1,stride);
-			x1=x2;
-			x2=x3;
-			x3+=stride; 
-			o1+=stride;                 
-		}
-	}
-      	// chroma u &amp; v
-	if(!_param-&gt;chroma)
-	{
-		memcpy(UPLANE(data),UPLANE(_uncompressed),page);
-		memcpy(VPLANE(data),VPLANE(_uncompressed),page);
-	}
-	else
-	{
-		stride&gt;&gt;=1;
-		// chroma u
-		o1=UPLANE(data)+stride;
-		x1=UPLANE(_uncompressed);
-		x2=x1+stride;
-		x3=x2+stride;
-		// first and last line
-		memcpy(UPLANE(data),UPLANE(_uncompressed),stride);
-		memcpy(UPLANE(data)+page-stride,UPLANE(_uncompressed)+page-stride,stride);          
-		// Luma
-		for(int32_t y=1;y&lt;(int32_t)(_info.height&gt;&gt;1)-1;y++)
-		{
-			doLine(x1,x2,x3,o1,stride);
-			x1=x2;
-			x2=x3;
-			x3+=stride; 
-			o1+=stride;                 
-		}
-		
-		// chroma V
-		o1=VPLANE(data)+stride;
-		x1=VPLANE(_uncompressed);
-		x2=x1+stride;
-		x3=x2+stride;
-		// first and last line
-		memcpy(VPLANE(data),VPLANE(_uncompressed),stride);
-		memcpy(VPLANE(data)+page-stride,VPLANE(_uncompressed)+page-stride,stride);          
-		// Luma
-		for(int32_t y=1;y&lt;(int32_t)(_info.height&gt;&gt;1)-1;y++)
-		{
-			doLine(x1,x2,x3,o1,stride);
-			x1=x2;
-			x2=x3;
-			x3+=stride; 
-			o1+=stride;                 
-		}
-	}
-	data-&gt;copyInfo(_uncompressed);
-      return 1;
-}
-//
-//	Run the convolution kernel on a whole line
-//	to speed up things (cache effect + locality of datas)
-//
-//----------------------------------------------------------------
-//----------------------------------------------------------------
-//-----------------------MEAN---------------------
-//----------------------------------------------------------------
-//----------------------------------------------------------------
-
-char 	*AVDMFastVideoMean::printConf(void)
-{
-		static char str[]=&quot;Mean(fast)&quot;;
-		return (char *)str;
-	
-}
-uint8_t AVDMFastVideoMean::doLine(uint8_t  *pred,
-																					uint8_t *cur,
-   																				uint8_t *next,
-   																				uint8_t *out,
-                       										uint32_t w)
-                                 
-{
-	uint8_t a1,a2,a3;
-	uint8_t b1,b2,b3;
-	uint8_t c1,c2,c3;
-	int32_t o;
-	
-	a2=*pred++;a3=*pred++;
-	b2=*cur++;b3=*cur++;
-	c2=*next++;c3=*next++;
-	
-	*out++=b2;
-	w--;
-	
-	while(w&gt;1)
-	{
-			a1=a2;
-			a2=a3;
-			a3=*pred++;
-			b1=b2;
-			b2=b3;
-			b3=*cur++;
-			c1=c2;
-			c2=c3;
-			c3=*next++;
-		
-		  //
-		  o=a1+a2+a3+b1+b2+b3+c1+c2+c3;
-		  o/=9;
-		  
-		  *out++=o;
-		  w--;
-	}	
-		*out++=b3;
-		return 1;
-}
-
-//----------------------------------------------------------------
-//----------------------------------------------------------------
-//-----------------------GAUSS---------------------
-//----------------------------------------------------------------
-//----------------------------------------------------------------
-
-//          6 10 6
-//         10 16 10 *1/80
-//		    6 10 6
-char 							*AVDMFastVideoGauss::printConf(void)
-{
-		static char str[]=&quot;Gauss(fast)&quot;;
-		return (char *)str;
-	
-}
- uint8_t AVDMFastVideoGauss::doLine(uint8_t  *pred,
-																					uint8_t *cur,
-   																				uint8_t *next,
-   																				uint8_t *out,
-                       										uint32_t w)
-                                 
-{
-	uint8_t a1,a2,a3;
-	uint8_t b1,b2,b3;
-	uint8_t c1,c2,c3;
-	int32_t o;
-//#define MASKED__	
-#define threshold 80
-	int v,r;
-	
-	a2=*pred++;a3=*pred++;
-	b2=*cur++;b3=*cur++;
-	c2=*next++;c3=*next++;
-	
-	*out++=b2;
-	w--;
-	
-	while(w&gt;1)
-	{
-			a1=a2;
-			a2=a3;
-			a3=*pred++;
-			b1=b2;
-			b2=b3;
-			b3=*cur++;
-			c1=c2;
-			c2=c3;
-			c3=*next++;
-		
-		  //
-#ifdef MASKED__
-		v=b2;
-		r=16;
-		o=b2*16;
-		#define MORE(x,coef) if(abs(x-v)&lt;=threshold) {o+=x*coef;r+=coef;}
-		MORE(a1,6);
-		MORE(a2,10);
-		MORE(a3,6);
-		
-		MORE(b1,10);
-		MORE(b3,10);
-		
-		MORE(c1,6);
-		MORE(c2,10);
-		MORE(c3,6);
-		
-		o=(o+r-1)/r;		
-		
-#else		  
-		  o=6*a1+10*a2+6*a3+10*b1+16*b2+10*b3+6*c1+10*c2+6*c3;		  
-		  o/=80;
-#endif		  
-		  
-		  *out++=o;
-		  w--;
-	}	
-	*out++=b3;
-		return 1;
-}
-//----------------------------------------------------------------
-//----------------------------------------------------------------
-//-----------------------SHARPEN---------------------
-//----------------------------------------------------------------
-//----------------------------------------------------------------
-
-//         -1 -2 -1
- 	//         -2 16 -2 *1/16
-  	//		    -1 -2 -1
-char 							*AVDMFastVideoSharpen::printConf(void)
-{
-		static char str[]=&quot;Sharpen(fast)&quot;;
-		return (char *)str;
-	
-}
- uint8_t AVDMFastVideoSharpen::doLine(uint8_t  *pred,
-																					uint8_t *cur,
-   																				uint8_t *next,
-   																				uint8_t *out,
-                       										uint32_t w)
-                                 
-{
-	uint8_t a1,a2,a3;
-	uint8_t b1,b2,b3;
-	uint8_t c1,c2,c3;
-	int32_t o;
-	
-	a2=*pred++;a3=*pred++;
-	b2=*cur++;b3=*cur++;
-	c2=*next++;c3=*next++;
-	
-	*out++=b2;
-	w--;
-	
-	while(w&gt;1)
-	{
-			a1=a2;
-			a2=a3;
-			a3=*pred++;
-			b1=b2;
-			b2=b3;
-			b3=*cur++;
-			c1=c2;
-			c2=c3;
-			c3=*next++;
-		
-		  //
-		  //         -1 -2 -1
- 	//         -2 16 -2 *1/16
-  	//		    -1 -2 -1
-		  //o=-a1+-2*a2+-a3+-2*b1+16*b2+-2*b3+-1*c1+-2*c2+-1*c3;
-		  //o/=16;
-		  o=4*b2-a2-c2-b1-b3;
-		  o&gt;&gt;=2;
-		  o+=3*a2;
-		  o=o/3;
-		  if(o&lt;0) o=0;
-		  if(o&gt;255) o=255;
-		  
-		  *out++=o;
-		  w--;
-	}	
-	*out++=b3;
-		return 1;
-}
-//----------------------------------------------------------------
-//----------------------------------------------------------------
-//-----------------------Median---------------------
-//----------------------------------------------------------------
-//----------------------------------------------------------------
-
-//         -1 -2 -1
- 	//         -2 16 -2 *1/16
-  	//		    -1 -2 -1
-char 							*AVDMFastVideoMedian::printConf(void)
-{
-		static char str[]=&quot;Median(fast)&quot;;
-		return (char *)str;
-	
-}
- uint8_t AVDMFastVideoMedian::doLine(uint8_t  *pred,
-																					uint8_t *cur,
-   																				uint8_t *next,
-   																				uint8_t *out,
-                       										uint32_t w)
-                                 
-{
-	uint8_t a1,a2,a3;
-	uint8_t b1,b2,b3;
-	uint8_t c1,c2,c3; //,i;
-	//int32_t o;
-	uint8_t temp;
-	
-	static uint8_t tab[9];
-	a2=*pred++;a3=*pred++;
-	b2=*cur++;b3=*cur++;
-	c2=*next++;c3=*next++;
-	
-	*out++=b2;
-	w--;
-	
-	while(w&gt;1)
-	{
-			tab[0]=a1=a2;
-			tab[1]=a2=a3;
-			tab[2]=a3=*pred++;
-			tab[3]=b1=b2;
-			tab[4]=b2=b3;
-			tab[5]=b3=*cur++;
-			tab[6]=c1=c2;
-			tab[7]=c2=c3;
-			tab[8]=c3=*next++;
-		
-#define PIX_SORT(a,b) { if ((a)&gt;(b)) PIX_SWAP((a),(b)); }
-#define PIX_SWAP(a,b) { temp=(a);(a)=(b);(b)=temp; }
-
-   uint8_t *p=(uint8_t *)tab;
-								
-    PIX_SORT(p[1], p[2]) ; PIX_SORT(p[4], p[5]) ; PIX_SORT(p[7], p[8]) ;
-    PIX_SORT(p[0], p[1]) ; PIX_SORT(p[3], p[4]) ; PIX_SORT(p[6], p[7]) ;
-    PIX_SORT(p[1], p[2]) ; PIX_SORT(p[4], p[5]) ; PIX_SORT(p[7], p[8]) ;
-    PIX_SORT(p[0], p[3]) ; PIX_SORT(p[5], p[8]) ; PIX_SORT(p[4], p[7]) ;
-    PIX_SORT(p[3], p[6]) ; PIX_SORT(p[1], p[4]) ; PIX_SORT(p[2], p[5]) ;
-    PIX_SORT(p[4], p[7]) ; PIX_SORT(p[4], p[2]) ; PIX_SORT(p[6], p[4]) ;
-    PIX_SORT(p[4], p[2]) ; 
-		  
-		  *out++=tab[4];
-		  w--;
-	}	
-	*out++=b3;
-	return 1;
-}
-uint8_t  DIA_getLumaChroma(uint32_t *doLuma, uint32_t *doChroma);
-uint8_t AVDMFastVideoConvolution::configure(AVDMGenericVideoStream * instream)
-{
-  
-  //return DIA_getLumaChroma(&amp;(_param-&gt;luma),&amp;(_param-&gt;chroma)) ; 
-  diaElemToggle luma(&amp;(_param-&gt;luma),&quot;Process luma&quot;,&quot;Process luma plane&quot;);
-  diaElemToggle chroma(&amp;(_param-&gt;chroma),&quot;Process chroma&quot;);
-  
-  diaElem *elems[2]={&amp;luma,&amp;chroma};
-  
-  return diaFactoryRun(&quot;Fast Convolution&quot;,2,elems);
-}
-
-
-

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidFlux.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidFlux.cpp	2007-01-08 21:29:24 UTC (rev 2696)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidFlux.cpp	2007-01-09 19:54:42 UTC (rev 2697)
@@ -1,649 +0,0 @@
-/***************************************************************************
-                          ADM_vidFlux.cpp  -  description
-                             -------------------
-    begin                : Tue Dec 31 2002
-    copyright            : (C) 2002 by mean
-    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
-    
-    Ported from FluxSmooth
-    (c)  Ross Thomas &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">ross at grinfinity.com</A>&gt;
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
- 
- 
-#include &lt;stdio.h&gt;
-#include &lt;stdlib.h&gt;
-#include &lt;string.h&gt;
-#include &lt;ADM_assert.h&gt;
-#include &lt;math.h&gt;
-
-#include &quot;config.h&quot;
-#include &quot;fourcc.h&quot;
-#include &quot;avio.hxx&quot;
-#include &quot;config.h&quot;
-#include &quot;avi_vars.h&quot;
-
-
-#include &quot;ADM_toolkit/toolkit.hxx&quot;
-#include &quot;ADM_editor/ADM_edit.hxx&quot;
-#include &quot;ADM_video/ADM_genvideo.hxx&quot;
-#include &quot;admmangle.h&quot;
-
-static int16_t scaletab[16];
-static uint64_t scaletab_MMX[65536];
-
-void initScaleTab( void )
-{
-//uint32_t i;
-
-		scaletab[1] = 32767;
-		for(int i = 2; i &lt; 16; ++i)
-				scaletab[i] = (int)(32768.0 / i + 0.5);
-		for(uint32_t  i = 0; i &lt; 65536; ++i)
-		{
-			scaletab_MMX[i] = ( (uint64_t)scaletab[ i        &amp; 15]       ) |
-							  (((uint64_t)scaletab[(i &gt;&gt;  4) &amp; 15]) &lt;&lt; 16) |
-							  (((uint64_t)scaletab[(i &gt;&gt;  8) &amp; 15]) &lt;&lt; 32) |
-							  (((uint64_t)scaletab[(i &gt;&gt; 12) &amp; 15]) &lt;&lt; 48);
-		}
-}
- 
-#include &quot;ADM_video/ADM_vidFlux.h&quot;
-#include &quot;ADM_filter/video_filters.h&quot;
-
-static FILTER_PARAM fluxParam={2,{&quot;temporal_threshold&quot;,&quot;spatial_threshold&quot;}};
-
-
-SCRIPT_CREATE(fluxsmooth_script,ADMVideoFlux,fluxParam);
-
-//#define ASM_FLUX
-BUILD_CREATE(fluxsmooth_create,ADMVideoFlux);
-
-static uint64_t spat_thresh ASM_CONST =0LL;
-static uint64_t temp_thresh ASM_CONST =0LL;
-static uint64_t ASM_CONST _l_counter_init,_l_indexer,_l_prev_pels,_l_next_pels;
-static long int _l_src_pitch ASM_CONST =0;
-static long int _l_dst_pitch ASM_CONST =0;
-static int _l_xmax ASM_CONST=0;
-
-static int ycnt;
-static	uint8_t * _l_currp; 
-static	 uint8_t * _l_prevp;								  								  
-static	 uint8_t * _l_nextp; 
-static	 uint8_t * _l_destp; 
-
-
-static uint32_t size;
-
-ADMVideoFlux::ADMVideoFlux(AVDMGenericVideoStream *in,CONFcouple *couples)
-			
-{
-  
-	_in=in;
-	memcpy(&amp;_info,in-&gt;getInfo(),sizeof(_info));
-	if(couples)
-	{
-		_param=NEW( FLUX_PARAM );
-		GET(temporal_threshold);
-		GET(spatial_threshold);
-	}
-	else
-	{
-		 _param=NEW( FLUX_PARAM );
-		 _param-&gt;spatial_threshold=7;
-		 _param-&gt;temporal_threshold=7;
-	}
-  	num_frame=0xffff0000;
-	vidCache=new VideoCache(5,in);
-}
-
-uint8_t	ADMVideoFlux::getCoupledConf( CONFcouple **couples)
-{
-
-			ADM_assert(_param);
-			*couples=new CONFcouple(2);
-
-#define CSET(x)  (*couples)-&gt;setCouple((char *)#x,(_param-&gt;x))
-	CSET(temporal_threshold);
-	CSET(spatial_threshold);
-		return 1;
-
-}
-uint8_t ADMVideoFlux::configure(AVDMGenericVideoStream *in)
-{
-UNUSED_ARG(in);
-int i,j;
-		i=_param-&gt;temporal_threshold;
-		j=_param-&gt;spatial_threshold;
-	  if(GUI_getIntegerValue(&amp;i,0,255,&quot;Temporal  Threshold&quot;))
-			{
-					if(GUI_getIntegerValue(&amp;j,0,255,&quot;Spatial  Threshold&quot;))
-					{
-						_param-&gt;temporal_threshold=(uint32_t)i;						
-						_param-&gt;spatial_threshold=(uint32_t)j;
-					}	
-					return 1;
-			}		
-			return 0;	
-}
-ADMVideoFlux::~ADMVideoFlux()
-{
-	DELETE(_param);
-	if(vidCache)
-		delete vidCache;
-	vidCache=NULL;
-}
-
-char	*ADMVideoFlux::printConf( void) 
-{
-	static char conf[100];
-
-		sprintf(conf,&quot;FluxSmooth: Spatial :%02lu Temporal:%02lu&quot;,
-						_param-&gt;spatial_threshold,
-						_param-&gt;temporal_threshold);
-		return conf;
-	
-}
-uint8_t ADMVideoFlux::getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
-          			ADMImage *data,uint32_t *flags)
-{
-UNUSED_ARG(flags);
-uint32_t dlen,dflags;
-uint32_t plane=_info.width*_info.height;
-ADMImage	*image,*next,*prev;
-
-
-			*len=(plane*3)&gt;&gt;1;
-			
-			size=(_info.width*_info.height*3)&gt;&gt;1;
-			if(frame&gt;_info.nb_frames-1) return 0;
-			
-			image=vidCache-&gt;getImage(frame);
-			if(!image) return 0;
-			
-			if(!frame || (frame==_info.nb_frames-1))
-			{
-
-				data-&gt;duplicate(image);
-				data-&gt;copyInfo(image);
-				vidCache-&gt;unlockAll();
-				return 1;
-			}
-			next=vidCache-&gt;getImage(frame+1);
-			if(!next)
-			{
-				vidCache-&gt;unlockAll();
-				return 0;
-			}
-			prev=vidCache-&gt;getImage(frame-1);
-			if(!prev)
-			{
-				vidCache-&gt;unlockAll();
-				return 0;
-			}	    
-				
-
-		   			
-// now we have everything
-		int dst_pitch = _info.width,
-		src_pitch = _info.width,
-		row_size  = _info.width,
-		height    = _info.height;
-		
- uint8_t   		*currp = YPLANE(image),
-			*prevp = YPLANE(prev),
-			*nextp = YPLANE(next);;
-	uint8_t		*destp = YPLANE(data);
-
-	// line 1 and last
-	memcpy(destp, currp, row_size);
-	memcpy(destp + dst_pitch * (height - 1),
-		currp + src_pitch * (height - 1), row_size);
-
-	// skip one line		
-	currp += src_pitch;
-	prevp += src_pitch;
-	nextp += src_pitch;
-	destp += dst_pitch;
-	
-	DoFilter_C(currp, prevp, nextp, src_pitch,
-			destp, dst_pitch, row_size, height - 2);
-	// U
- 
-	
-	dst_pitch = _info.width&gt;&gt;1;
-	src_pitch = _info.width&gt;&gt;1;
-  row_size  = _info.width&gt;&gt;1;
-	height = _info.height&gt;&gt;1;
-	
-	currp = UPLANE(image);
-	prevp = UPLANE(prev);
-	nextp = UPLANE(next);
-	destp = UPLANE(data);;
-
-	memcpy(destp, currp, row_size);
-	memcpy(destp + dst_pitch * (height - 1),
-		currp + src_pitch * (height - 1), row_size);
-
-	currp += src_pitch;
-	prevp += src_pitch;
-	nextp += src_pitch;
-	destp += dst_pitch;
-
-		DoFilter_C(currp, prevp, nextp, src_pitch,
-			destp, dst_pitch, row_size, height - 2);
-
-	// V
-
-  plane=(_info.width*_info.height*5)&gt;&gt;2;
-	
-	dst_pitch = _info.width&gt;&gt;1;
-	src_pitch = _info.width&gt;&gt;1;
-  row_size  = _info.width&gt;&gt;1;
-	height = _info.height&gt;&gt;1;
-	
-	currp = VPLANE(image);
-	prevp = VPLANE(prev);
-	nextp = VPLANE(next);
-	destp = VPLANE(data);;
-
-	memcpy(destp, currp, row_size);
-	memcpy(destp + dst_pitch * (height - 1),
-		currp + src_pitch * (height - 1), row_size);
-
-	currp += src_pitch;
-	prevp += src_pitch;
-	nextp += src_pitch;
-	destp += dst_pitch;
-
-	#if (defined( ARCH_X86)  || defined(ARCH_X86_64)) &amp;&amp; defined(ASM_FLUX)
-        if(CpuCaps::hasMMX())
-        {
-		DoFilter_MMX(currp, prevp, nextp, src_pitch,
-			destp, dst_pitch, row_size, height - 2);
-	}else
-	#endif
-        {
-		DoFilter_C(currp, prevp, nextp, src_pitch,
-			destp, dst_pitch, row_size, height - 2);
-        }
-	
-	data-&gt;copyInfo(image);
-	vidCache-&gt;unlockAll();
-	return 1;
-}	                           
-
-
-void ADMVideoFlux::DoFilter_C(
- uint8_t * currp, 
- uint8_t * prevp,								  								  
- uint8_t * nextp, 
- int src_pitch,
- uint8_t * destp, 
- int dst_pitch,
- int row_size, 
- int height)
-{
-
-	 int skip = src_pitch - row_size + 1,
-		dskip = dst_pitch - row_size + 1;
-	int ycnt = height;
-
-	do
-	{
-		*destp = *currp; // Copy left edge
-
-		++currp;
-		++prevp;
-		++nextp;
-		++destp;
-
-		int xcnt = row_size - 2;
-
-		do
-		{
-			int pbt = *prevp++, b = *currp, nbt = *nextp++;
-			int pdiff = pbt - b, ndiff = nbt - b;
-			if((pdiff &lt; 0 &amp;&amp; ndiff &lt; 0) || (pdiff &gt; 0 &amp;&amp; ndiff &gt; 0))
-			{
-				int pb1 = currp[-src_pitch - 1], pb2 = currp[-src_pitch],
-					pb3 = currp[-src_pitch + 1], b1 = currp[-1], b2 = currp[1],
-					nb1 = currp[src_pitch - 1], nb2 = currp[src_pitch],
-					nb3 = currp[src_pitch + 1], sum = b, cnt = 1;
-
-				if(abs(pbt - b) &lt;= _param-&gt;temporal_threshold)
-				{
-					sum += pbt;
-					++cnt;
-				}
-				if(abs(nbt - b) &lt;= _param-&gt;temporal_threshold)
-				{
-					sum += nbt;
-					++cnt;
-				}
-				if(abs(pb1 - b) &lt;= _param-&gt;spatial_threshold)
-				{
-					sum += pb1;
-					++cnt;
-				}
-				if(abs(pb2 - b) &lt;= _param-&gt;spatial_threshold)
-				{
-					sum += pb2;
-					++cnt;
-				}
-				if(abs(pb3 - b) &lt;= _param-&gt;spatial_threshold)
-				{
-					sum += pb3;
-					++cnt;
-				}
-				if(abs(b1 - b) &lt;= _param-&gt;spatial_threshold)
-				{
-					sum += b1;
-					++cnt;
-				}
-				if(abs(b2 - b) &lt;= _param-&gt;spatial_threshold)
-				{
-					sum += b2;
-					++cnt;
-				}
-				if(abs(nb1 - b) &lt;= _param-&gt;spatial_threshold)
-				{
-					sum += nb1;
-					++cnt;
-				}
-				if(abs(nb2 - b) &lt;= _param-&gt;spatial_threshold)
-				{
-					sum += nb2;
-					++cnt;
-				}
-				if(abs(nb3 - b) &lt;= _param-&gt;spatial_threshold)
-				{
-					sum += nb3;
-					++cnt;
-				}
-
-				ADM_assert(sum &gt;= 0);
-				ADM_assert(sum &lt; 2806);
-				ADM_assert(cnt &gt; 0);
-				ADM_assert(cnt &lt; 12);
-
-				*destp++ = (uint8_t )(((sum * 2 + cnt) * scaletab[cnt]) &gt;&gt; 16);
-				++currp;
-			} else
-				*destp++ = *currp++;
-		} while(--xcnt);
-		ADM_assert(xcnt == 0);
-
-		*destp = *currp; // Copy right edge
-
-		currp += skip;
-		prevp += skip;
-		nextp += skip;
-		destp += dskip;
-	} while(--ycnt);
-	ADM_assert(ycnt == 0);
-
-}
-#if (defined( ARCH_X86)  || defined(ARCH_X86_64))
-/*
-	__asm movq mm2, mm0 \
-	__asm movq mm3, mm1 \
-	__asm psubusw mm2, mm1 \
-	__asm psubusw mm3, mm0 \
-	__asm por mm2, mm3				/  mm2 = abs diff  / \
-	__asm pcmpgtw mm2, threshold	/  Compare with threshold  / \
-	__asm paddw mm6, mm2			/  -1 from counter if not within  / \
-	__asm pandn mm2, mm1 \
-	__asm paddw mm5, mm2			/  Add to sum  / \
-*/
-#define CHECK_AND_ADD(threshold) &quot; movq %%mm0, %%mm2 \n\t&quot; \
-&quot;movq    %%mm1, %%mm3 \n\t&quot; \
-&quot;psubusw %%mm1, %%mm2 \n\t&quot; \
-&quot;psubusw %%mm0, %%mm3 \n\t&quot; \
-&quot;por     %%mm3, %%mm2				\n\t&quot; /* mm2 = abs diff */ \
-&quot;pcmpgtw &quot;Mangle(threshold)&quot;, %%mm2	\n\t &quot;/* Compare with threshold */ \
-&quot;paddw   %%mm2, %%mm6	\n\t	&quot;/* -1 from counter if not within */ \
-&quot;pandn   %%mm1, %%mm2 \n\t&quot; \
-&quot;paddw   %%mm2, %%mm5	\n\t&quot; /* Add to sum */ 
-
-#define EXPAND(x) { x=x+(x&lt;&lt;8)+(x&lt;&lt;16)+(x&lt;&lt;24)+(x&lt;&lt;32)+(x&lt;&lt;40) \
-										+(x&lt;&lt;48);}
-
-
-void ADMVideoFlux::DoFilter_MMX(
-uint8_t * currp, 
- uint8_t * prevp,
- uint8_t * nextp, 
- int src_pitch,
- uint8_t * destp, 
- int dst_pitch,
- int row_size, 
- int height)
-{
-	  _l_xmax = row_size - 4;
-	 	ycnt 		= height;
-	
-	
-	_l_currp = currp;
-  _l_prevp = prevp;								  								  
-  _l_nextp = nextp;  
-  _l_destp = destp; 
- 	_l_src_pitch =src_pitch;
-  _l_dst_pitch =dst_pitch;
- 
-		_l_counter_init = 0x000b000b000b000bLL,
-		_l_indexer = 0x1000010000100001LL;
-		
-		spat_thresh = _param-&gt;spatial_threshold;
-		temp_thresh = _param-&gt;temporal_threshold;
-		EXPAND( spat_thresh);
-		EXPAND( temp_thresh);
-
-UNUSED_ARG(_l_prev_pels);
-UNUSED_ARG(_l_next_pels);
-asm(
-&quot;								 mov (%0),&quot;REG_si&quot; \n\t&quot;
-&quot;                mov &quot;Mangle(_l_currp)&quot;, &quot;REG_si&quot; \n\t&quot;
-&quot;                mov &quot;Mangle(_l_destp)&quot;, &quot;REG_di&quot; \n\t&quot;
-&quot;                pxor %%mm7,%%mm7 \n\t&quot;
-&quot; \n\t&quot;
-&quot;yloop%=:  \n\t&quot;
-&quot;                # Copy first dword \n\t&quot;
-&quot; \n\t&quot;
-&quot;                mov (&quot;REG_si&quot;),&quot;REG_ax&quot; \n\t&quot;
-&quot;                mov &quot;REG_ax&quot;,(&quot;REG_di&quot;) \n\t&quot;
-&quot; \n\t&quot;
-&quot;                mov $4,&quot;REG_cx&quot; \n\t&quot;
-&quot; \n\t&quot;
-&quot;xloop%=:  \n\t&quot;
-&quot;                # Get current pels, init sum and counter \n\t&quot;
-&quot; \n\t&quot;
-&quot;                movd (&quot;REG_si&quot;,&quot;REG_cx&quot;),%%mm0 \n\t&quot;
-&quot;                punpcklbw %%mm7,%%mm0 \n\t&quot;
-&quot;                movq %%mm0,%%mm5 \n\t&quot;
-&quot;                movq &quot;Mangle(_l_counter_init)&quot;,%%mm6 \n\t&quot;
-&quot; \n\t&quot;
-&quot;                # Middle left \n\t&quot;
-&quot; \n\t&quot;
-&quot;                movq %%mm0,%%mm1 \n\t&quot;
-&quot;                psllq $16,%%mm1 \n\t&quot;
-&quot;                movd -4(&quot;REG_si&quot;,&quot;REG_cx&quot;),%%mm2 \n\t&quot;
-&quot;                punpcklbw %%mm7,%%mm2 \n\t&quot;
-&quot;                psrlq $48,%%mm2 \n\t&quot;
-&quot;                por %%mm2,%%mm1 \n\t&quot;
-&quot; \n\t&quot;
-CHECK_AND_ADD(spat_thresh)
-&quot; \n\t&quot;
-&quot;                # Middle right \n\t&quot;
-&quot; \n\t&quot;
-&quot;                movq %%mm0,%%mm1 \n\t&quot;
-&quot;                psrlq $16,%%mm1 \n\t&quot;
-&quot;                movd 4(&quot;REG_si&quot;,&quot;REG_cx&quot;),%%mm2 \n\t&quot;
-&quot;                punpcklbw %%mm7,%%mm2 \n\t&quot;
-&quot;                psllq $48,%%mm2 \n\t&quot;
-&quot;                por %%mm2,%%mm1 \n\t&quot;
-&quot; \n\t&quot;
-CHECK_AND_ADD(spat_thresh)
-&quot; \n\t&quot;
-&quot;                # Top left \n\t&quot;
-&quot; \n\t&quot;
-&quot;                mov &quot;REG_si&quot;,&quot;REG_ax&quot; \n\t&quot;
-&quot;                sub &quot;Mangle(_l_src_pitch)&quot;, &quot;REG_ax&quot; \n\t&quot;
-&quot;                movd (&quot;REG_ax&quot;,&quot;REG_cx&quot;),%%mm1 \n\t&quot;
-&quot;                punpcklbw %%mm7,%%mm1 \n\t&quot;
-&quot;                psllq $16,%%mm1 \n\t&quot;
-&quot;                movd -4(&quot;REG_ax&quot;,&quot;REG_cx&quot;),%%mm2 \n\t&quot;
-&quot;                punpcklbw %%mm7,%%mm2 \n\t&quot;
-&quot;                psrlq $48,%%mm2 \n\t&quot;
-&quot;                por %%mm2,%%mm1 \n\t&quot;
-&quot; \n\t&quot;
-CHECK_AND_ADD(spat_thresh)
-&quot; \n\t&quot;
-&quot;                # Top centre \n\t&quot;
-&quot; \n\t&quot;
-&quot;                movd (&quot;REG_ax&quot;,&quot;REG_cx&quot;),%%mm1 \n\t&quot;
-&quot;                punpcklbw %%mm7,%%mm1 \n\t&quot;
-&quot; \n\t&quot;
-CHECK_AND_ADD(spat_thresh)
-&quot; \n\t&quot;
-&quot;                # Top right \n\t&quot;
-&quot; \n\t&quot;
-&quot;                psrlq $16,%%mm1 \n\t&quot;
-&quot;                movd 4(&quot;REG_ax&quot;,&quot;REG_cx&quot;),%%mm2 \n\t&quot;
-&quot;                punpcklbw %%mm7,%%mm2 \n\t&quot;
-&quot;                psllq $48,%%mm2 \n\t&quot;
-&quot;                por %%mm2,%%mm1 \n\t&quot;
-&quot; \n\t&quot;
-CHECK_AND_ADD(spat_thresh)
-&quot; \n\t&quot;
-&quot;                # Bottom left \n\t&quot;
-&quot; \n\t&quot;
-&quot;                mov &quot;REG_si&quot;,&quot;REG_ax&quot; \n\t&quot;
-&quot;                add &quot;Mangle(_l_src_pitch)&quot;, &quot;REG_ax&quot; \n\t&quot;
-&quot;                movd (&quot;REG_ax&quot;,&quot;REG_cx&quot;),%%mm1 \n\t&quot;
-&quot;                punpcklbw %%mm7,%%mm1 \n\t&quot;
-&quot;                psllq $16,%%mm1 \n\t&quot;
-&quot;                movd -4(&quot;REG_ax&quot;,&quot;REG_cx&quot;),%%mm2 \n\t&quot;
-&quot;                punpcklbw %%mm7,%%mm2 \n\t&quot;
-&quot;                psrlq $48,%%mm2 \n\t&quot;
-&quot;                por %%mm2,%%mm1 \n\t&quot;
-&quot; \n\t&quot;
-CHECK_AND_ADD(spat_thresh)
-&quot; \n\t&quot;
-&quot;                # Bottom centre \n\t&quot;
-&quot; \n\t&quot;
-&quot;                movd (&quot;REG_ax&quot;,&quot;REG_cx&quot;),%%mm1 \n\t&quot;
-&quot;                punpcklbw %%mm7,%%mm1 \n\t&quot;
-&quot; \n\t&quot;
-CHECK_AND_ADD(spat_thresh)
-&quot; \n\t&quot;
-&quot;                # Bottom right \n\t&quot;
-&quot; \n\t&quot;
-&quot;                psrlq $16,%%mm1 \n\t&quot;
-&quot;                movd 4(&quot;REG_ax&quot;,&quot;REG_cx&quot;),%%mm2 \n\t&quot;
-&quot;                punpcklbw %%mm7,%%mm2 \n\t&quot;
-&quot;                psllq $48,%%mm2 \n\t&quot;
-&quot;                por %%mm2,%%mm1 \n\t&quot;
-&quot; \n\t&quot;
-CHECK_AND_ADD(spat_thresh)
-&quot; \n\t&quot;
-&quot;                # Previous frame \n\t&quot;
-&quot; \n\t&quot;
-&quot;                mov &quot;Mangle(_l_prevp)&quot;, &quot;REG_ax&quot; \n\t&quot;
-&quot;                movd (&quot;REG_ax&quot;,&quot;REG_cx&quot;),%%mm1 \n\t&quot;
-&quot;                punpcklbw %%mm7,%%mm1 \n\t&quot;
-&quot;                movq %%mm1, &quot;Mangle(_l_prev_pels)&quot; \n\t&quot;
-&quot; \n\t&quot;
-CHECK_AND_ADD(temp_thresh)
-&quot; \n\t&quot;
-&quot;                # Next frame \n\t&quot;
-&quot; \n\t&quot;
-&quot;                mov &quot;Mangle(_l_nextp)&quot;, &quot;REG_ax&quot; \n\t&quot;
-&quot;                movd (&quot;REG_ax&quot;,&quot;REG_cx&quot;),%%mm1 \n\t&quot;
-&quot;                punpcklbw %%mm7,%%mm1 \n\t&quot;
-&quot;                movq %%mm1, &quot;Mangle(_l_next_pels)&quot; \n\t&quot;
-&quot; \n\t&quot;
-CHECK_AND_ADD(temp_thresh)
-&quot; \n\t&quot;
-&quot;                # Average \n\t&quot;
-&quot; \n\t&quot;
-&quot;                psllw $1,%%mm5                                  # sum *= 2 \n\t&quot;
-&quot;                paddw %%mm6,%%mm5                               # sum += count \n\t&quot;
-&quot; \n\t&quot;
-&quot;                pmaddwd &quot;Mangle(_l_indexer)&quot;,%%mm6                  # Make index into lookup \n\t&quot;
-&quot;                movq %%mm6,%%mm1 \n\t&quot;
-&quot;                punpckhdq %%mm6,%%mm6 \n\t&quot;
-&quot;                mov &quot;Mangle(scaletab_MMX)&quot;, &quot;REG_ax&quot; \n\t&quot;
-&quot;                paddd %%mm6,%%mm1 \n\t&quot;
-&quot;                movd %%mm1,&quot;REG_bx&quot; \n\t&quot;
-&quot; \n\t&quot;
-&quot;            movq (&quot;REG_ax&quot;,&quot;REG_bx&quot;,8),%%mm2          # Do lookup \n\t&quot;
-&quot;            pmulhw %%mm2,%%mm5                                  # mm5 = average \n\t&quot;
-&quot; \n\t&quot;
-&quot;                # Apply smoothing only to fluctuating pels \n\t&quot;
-&quot; \n\t&quot;
-&quot;                movq %%mm0,%%mm1 \n\t&quot;
-&quot;                movq &quot;Mangle(_l_prev_pels)&quot;,%%mm2 \n\t&quot;
-&quot;                movq %%mm0,%%mm3 \n\t&quot;
-&quot;                movq &quot;Mangle(_l_next_pels)&quot;,%%mm4 \n\t&quot;
-&quot; \n\t&quot;
-&quot;                pcmpgtw %%mm2,%%mm1                             # curr &gt; prev \n\t&quot;
-&quot;                pcmpgtw %%mm4,%%mm3                             # curr &gt; next \n\t&quot;
-&quot;                pcmpgtw %%mm0,%%mm2                             # prev &gt; curr \n\t&quot;
-&quot;                pcmpgtw %%mm0,%%mm4                             # next &gt; curr \n\t&quot;
-&quot; \n\t&quot;
-&quot;                pand %%mm3,%%mm1                                # (curr &gt; prev) and (curr &gt; next) \n\t&quot;
-&quot;                pand %%mm4,%%mm2                                # (prev &gt; curr) and (next &gt; curr) \n\t&quot;
-&quot;                por %%mm2,%%mm1                                 # mm1 = FFh if fluctuating, else 00h \n\t&quot;
-&quot; \n\t&quot;
-&quot;                movq %%mm1,%%mm2 \n\t&quot;
-&quot;                pand %%mm5,%%mm1                                # mm1 = smoothed pels \n\t&quot;
-&quot;                pandn %%mm0,%%mm2                               # mm2 = unsmoothed pels \n\t&quot;
-&quot;                por %%mm2,%%mm1                                 # mm1 = result \n\t&quot;
-&quot; \n\t&quot;
-&quot;                # Store \n\t&quot;
-&quot; \n\t&quot;
-&quot;                packuswb %%mm7,%%mm1 \n\t&quot;
-&quot;                movntq %%mm1,(&quot;REG_di&quot;,&quot;REG_cx&quot;) \n\t&quot;
-&quot; \n\t&quot;
-&quot;                # Advance \n\t&quot;
-&quot; \n\t&quot;
-&quot;                add $4,&quot;REG_cx&quot; \n\t&quot;
-&quot;                cmp &quot;Mangle(_l_xmax)&quot;, &quot;REG_cx&quot; \n\t&quot;
-&quot;                jl xloop%= \n\t&quot;
-&quot; \n\t&quot;
-&quot;                # Copy last dword \n\t&quot;
-&quot; \n\t&quot;
-&quot;                mov (&quot;REG_si&quot;,&quot;REG_cx&quot;),&quot;REG_ax&quot; \n\t&quot;
-&quot;                mov &quot;REG_ax&quot;,(&quot;REG_di&quot;,&quot;REG_cx&quot;) \n\t&quot;
-&quot; \n\t&quot;
-&quot;                # Next row \n\t&quot;
-&quot; \n\t&quot;
-&quot;                add &quot;Mangle(_l_src_pitch)&quot;, &quot;REG_si&quot; \n\t&quot;
-&quot;                mov &quot;Mangle(_l_prevp)&quot;, &quot;REG_ax&quot; \n\t&quot;
-&quot;                add &quot;Mangle(_l_src_pitch)&quot;, &quot;REG_ax&quot; \n\t&quot;
-&quot;                mov &quot;REG_ax&quot;, &quot;Mangle(_l_prevp)&quot; \n\t&quot;
-&quot;                mov &quot;Mangle(_l_nextp)&quot;, &quot;REG_bx&quot; \n\t&quot;
-&quot;                add &quot;Mangle(_l_src_pitch)&quot;, &quot;REG_bx&quot; \n\t&quot;
-&quot;                mov &quot;REG_bx&quot;, &quot;Mangle(_l_nextp)&quot; \n\t&quot;
-&quot;                add &quot;Mangle(_l_dst_pitch)&quot;, &quot;REG_di&quot; \n\t&quot;
-&quot; \n\t&quot;
-&quot;                sub $1, &quot;Mangle(ycnt)&quot; \n\t&quot;
-&quot;                jnz yloop%= \n\t&quot;
-&quot; \n\t&quot;
-//&quot;MISMATCH: &quot;                sfence&quot; \n\t&quot;
-&quot;                emms \n\t&quot;
-&quot; \n\t&quot;
-
- : : &quot;r&quot;(_l_src_pitch) );
-}
-#endif
-//

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidFlux.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidFlux.h	2007-01-08 21:29:24 UTC (rev 2696)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidFlux.h	2007-01-09 19:54:42 UTC (rev 2697)
@@ -1,58 +0,0 @@
-/***************************************************************************
-                          ADM_vidFlux.h  -  description
-                             -------------------
-    begin                : Tue Dec 31 2002
-    copyright            : (C) 2002 by mean
-    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
- 
-#ifndef __FLUX__
-#define __FLUX__   
-#include &quot;ADM_video/ADM_cache.h&quot;
-typedef struct FLUX_PARAM
-{
-	uint32_t temporal_threshold;
-	uint32_t spatial_threshold;
-	
-}FLUX_PARAM;
-
-class  ADMVideoFlux:public AVDMGenericVideoStream
- {
-
- protected:
-    	
-        			FLUX_PARAM		*_param;
-
-				void DoFilter_C( uint8_t * currp,  uint8_t * prevp, uint8_t * nextp, 
-							 int src_pitch, uint8_t * destp,  int dst_pitch,
-							 int row_size,  int height);
-				void DoFilter_MMX( uint8_t * currp,  uint8_t * prevp, uint8_t * nextp, 
-							 int src_pitch, uint8_t * destp,  int dst_pitch,
-							 int row_size,  int height);	 
-				int32_t num_frame;
-		 		VideoCache		*vidCache;
-			
- public:
- 		
-
-						ADMVideoFlux(  AVDMGenericVideoStream *in,CONFcouple *setup);
-
-  						 ~ADMVideoFlux();
-		        virtual uint8_t 	getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
-          						ADMImage *data,uint32_t *flags);
-
-			virtual uint8_t 	configure( AVDMGenericVideoStream *instream);
-     			virtual char 		*printConf(void);
-			virtual uint8_t 	getCoupledConf( CONFcouple **couples);
-							
- }     ;
-#endif

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidMsmooth.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidMsmooth.cpp	2007-01-08 21:29:24 UTC (rev 2696)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidMsmooth.cpp	2007-01-09 19:54:42 UTC (rev 2697)
@@ -1,816 +0,0 @@
-/***************************************************************************
-                          ADM_vidMsmooth  -  description
-                             -------------------
-    
-    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
-
-    Port of Donal Graft MSMooth which is (c) Donald Graft
-    <A HREF="http://www.neuron2.net">http://www.neuron2.net</A>
-    <A HREF="http://puschpull.org/avisynth/decomb_reference_manual.html">http://puschpull.org/avisynth/decomb_reference_manual.html</A>
-
- ***************************************************************************/
-/*
-	MSmooth plugin for Avisynth -- performs detail-preserving smoothing.
-
-	Copyright (C) 2003 Donald A. Graft
-
-	This program is free software; you can redistribute it and/or modify
-	it under the terms of the GNU General Public License as published by
-	the Free Software Foundation.
-
-	This program is distributed in the hope that it will be useful,
-	but WITHOUT ANY WARRANTY; without even the implied warranty of
-	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-	GNU General Public License for more details.
-
-	You should have received a copy of the GNU General Public License
-	along with this program; if not, write to the Free Software
-	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
-*/
-
-#include &quot;config.h&quot;
-#include &lt;stdio.h&gt;
-#include &lt;stdlib.h&gt;
-#include &lt;string.h&gt;
-#include &lt;ADM_assert.h&gt;
-
-#include &quot;config.h&quot;
-#include &quot;fourcc.h&quot;
-#include &quot;avio.hxx&quot;
-#include &quot;avi_vars.h&quot;
-
-#include &quot;ADM_toolkit/toolkit.hxx&quot;
-#include &quot;ADM_editor/ADM_edit.hxx&quot;
-#include &quot;ADM_video/ADM_genvideo.hxx&quot;
-#include&quot;ADM_video/ADM_vidField.h&quot;
-#include&quot;ADM_video/ADM_cache.h&quot;
-
-#include &quot;ADM_osSupport/ADM_debugID.h&quot;
-#define MODULE_NAME MODULE_FILTER
-#include &quot;ADM_osSupport/ADM_debug.h&quot;
-
-#include &quot;ADM_osSupport/ADM_cpuCap.h&quot;
-#include &quot;ADM_filter/video_filters.h&quot;
-#ifdef HAVE_ALTIVEC_H
-#include &quot;altivec.h&quot;
-#endif
-#if 0
-#undef aprintf
-#define aprintf printf
-#endif
-#define GETFRAME(g, fp) \
-{ \
-	int GETFRAMEf; \
-	GETFRAMEf = (g); \
-	if (GETFRAMEf &lt; 0) GETFRAMEf = 0; \
-	if (GETFRAMEf &gt; num_frames_hi - 1) GETFRAMEf = num_frames_hi - 1; \
-	(fp) = vidCache-&gt;getImage(GETFRAMEf); \
-}
-
-#include &quot;ADM_video/ADM_vidMSmooth_param.h&quot;
-
-extern uint8_t DIA_getMSmooth(MSMOOTH_PARAM *param);
-extern uint8_t 	PutHintingData(unsigned char *video, unsigned int hint);
-extern uint8_t 	GetHintingData(unsigned char *video, unsigned int *hint);
-extern void 	BitBlt(uint8_t * dstp, int dst_pitch, const uint8_t* srcp,
-            		int src_pitch, int row_size, int height);
-//extern  void 	DrawString(uint8_t *dst, int x, int y, const char *s);
-//extern  void    DrawString(ADMImage *dst, int x, int y, const char *s);
-//#define DrawString(a,b,c,d) DrawString(NULL,b,c,d)
-#define DrawString drawString
-
-extern  void 	DrawStringYUY2(uint8_t *dst, int x, int y, const char *s); 
-
-static void Blur_C(uint8_t *in, uint8_t *out, uint32_t w, uint32_t h) ;
-#ifdef HAVE_ALTIVEC
-void Blur_Altivec(uint8_t *in, uint8_t *out, uint32_t w, uint32_t h);
-#endif
-#if (defined( ARCH_X86)  || defined(ARCH_X86_64))
-void Blur_MMX(uint8_t *in, uint8_t *out, uint32_t w, uint32_t h);
-#endif
-class Msmooth : public AVDMGenericVideoStream
-{
-private:
-	MSMOOTH_PARAM	*_param;
-	VideoCache	*vidCache;
-	uint8_t		show, debug;
-	ADMImage 	*blur,*work,*mask,*final,*final2;
-public:    
-
-			Msmooth(AVDMGenericVideoStream *in,CONFcouple *couples)   ;
-			~Msmooth();
-    	uint8_t 	*GetFrameYV12(int n);
-	void  		SmoothingPassYV12(const unsigned char *srcp, unsigned char *maskp, unsigned char *workp,
-				unsigned char *finalp,int row_size, int height, int spitch, int dpitch);
-	void 		EdgeMaskYV12(const unsigned char *srcp, unsigned char *blurp, unsigned char *workp,
-				 unsigned char *maskp,int row_size, int height, int src_pitch, int blur_pitch);
-				 
-	char 		*printConf( void );
-	uint8_t 	configure(AVDMGenericVideoStream *in);
-	uint8_t		getCoupledConf( CONFcouple **couples);
-	uint8_t 	getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
-				ADMImage *data,uint32_t *flags);
-};
-
-BUILD_CREATE(create_msmooth,Msmooth);
-static FILTER_PARAM msmoothParam={4,{&quot;showmask&quot;, &quot;highq&quot;,&quot;threshold&quot;, &quot;strength&quot;}};
-
-
-SCRIPT_CREATE(msmooth_script,Msmooth,msmoothParam);
-//_______________________________________________
-
-Msmooth::Msmooth(AVDMGenericVideoStream *in,CONFcouple *couples)
-
-{
-	_in=in;		
-   	memcpy(&amp;_info,_in-&gt;getInfo(),sizeof(_info));    
-  	_info.encoding=1;
-	_uncompressed=NULL;		
-  	_info.encoding=1;
-	show=0;
-	debug=0;
-	_param=new MSMOOTH_PARAM;
-	//
-	if(couples)
-		{
-			GET(showmask);
-			GET(threshold);
-			GET(highq);
-			GET(strength);	
-		}
-		else // Default
-  		{
-			_param-&gt;showmask=0;
-			_param-&gt;threshold=15;
-			_param-&gt;strength=3;
-			_param-&gt;highq=1;			
-		}
-		
-	uint32_t sz=(_info.width*_info.height*3)&gt;&gt;1;
-	#define NW(x) x=new ADMImage(_info.width,_info.height);ADM_assert(x);
-	NW(blur);
-	NW(work);
-	NW(mask);
-	NW(final);
-	NW(final2);
-	
-    	vidCache=new VideoCache(5,in);
-}
-//________________________________________________________
-uint8_t	Msmooth::getCoupledConf( CONFcouple **couples)
-{
-	*couples=NULL;
-	*couples=new CONFcouple(4);
-#define CSET(x)  (*couples)-&gt;setCouple((char *)#x,(_param-&gt;x))
-	CSET(showmask);
-	CSET(threshold);
-	CSET(highq);
-	CSET(strength);	
-	
-	return 1;
-}
-//________________________________________________________
-Msmooth::~Msmooth(void)
-{
-
-	if(vidCache) delete vidCache;
-	if(_param) delete _param;
-#undef NW
-#define NW(x) if(x) {delete  x;x=NULL;}
-	NW(blur);
-	NW(work);
-	NW(mask);
-	NW(final);
-	NW(final2);
-}
-//________________________________________________________
-uint8_t Msmooth::configure(AVDMGenericVideoStream *in)
-{
-	_in=in;
-	ADM_assert(_param);
-	//return  DIA_getDecombDecimate(_param);
-	//return 1;
-	return DIA_getMSmooth(_param);
-	
-}
-
-//________________________________________________________
-char *Msmooth::printConf( void )
-{
- 	static char buf[50];
-
-	ADM_assert(_param);
- 	sprintf((char *)buf,&quot; Donald Graft MSmooth&quot;);
-        return buf;
-}
-	
-//________________________________________________________
-uint8_t Msmooth::getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
-				ADMImage *data,uint32_t *flags)
-{
-    ADMImage *src = vidCache-&gt;getImage(frame);
-   
-    ADMImage * deliver;
-
-	const unsigned char *srcpY = YPLANE(src) ;
-	const unsigned char *srcp_savedY = srcpY;
-    	int src_pitchY = _info.width;
-	
-	const unsigned char *srcpU =UPLANE(src);
-	const unsigned char *srcp_savedU = srcpU;
-    	int src_pitchUV = _info.width&gt;&gt;1;
-	const unsigned char *srcpV =VPLANE(src);
-	const unsigned char *srcp_savedV = srcpV;
-
-    	unsigned char *blurpY = YPLANE(blur);//
-	unsigned char *blurp_savedY = blurpY;
-    	int blur_pitchY =  _info.width;
-    	unsigned char *blurpU = UPLANE(blur);
-	unsigned char *blurp_savedU = blurpU;
-    	int blur_pitchUV = _info.width&gt;&gt;1;
-    	unsigned char *blurpV = VPLANE(blur);
-	unsigned char *blurp_savedV = blurpV;
-
-    unsigned char *workpY = YPLANE(work); //-&gt;GetWritePtr(PLANAR_Y);
-	unsigned char *workp_savedY = workpY;
-    unsigned char *workpU = UPLANE(work);
-	unsigned char *workp_savedU = workpU;
-    unsigned char *workpV = VPLANE(work);
-	unsigned char *workp_savedV = workpV;
-
-    unsigned char *maskpY = YPLANE(mask); //-&gt;GetWritePtr(PLANAR_Y);
-	unsigned char *maskp_savedY = maskpY;
-    unsigned char *maskpU = UPLANE(mask);
-	unsigned char *maskp_savedU = maskpU;
-    unsigned char *maskpV = VPLANE(mask);
-	unsigned char *maskp_savedV = maskpV;
-
-    unsigned char *finalpY = YPLANE(final);//-&gt;GetWritePtr(PLANAR_Y);
-	unsigned char *finalp_savedY = finalpY;
-    unsigned char *finalpU = UPLANE(final);
-	unsigned char *finalp_savedU = finalpU;
-    unsigned char *finalpV = VPLANE(final);
-	unsigned char *finalp_savedV = finalpV;
-
-    unsigned char *finalp2Y = YPLANE(final2); //-&gt;GetWritePtr(PLANAR_Y);
-	unsigned char *finalp2_savedY = finalp2Y;
-    unsigned char *finalp2U = UPLANE(final2);
-	unsigned char *finalp2_savedU = finalp2U;
-    unsigned char *finalp2V = VPLANE(final2);
-	unsigned char *finalp2_savedV = finalp2V;
-
-    int row_sizeY = _info.width;//blur-&gt;GetRowSize(PLANAR_Y);
-    int row_sizeUV = _info.width&gt;&gt;1;//blur-&gt;GetRowSize(PLANAR_U);
-    int heightY = _info.height;//blur-&gt;GetHeight(PLANAR_Y);
-    int heightUV = _info.height&gt;&gt;1;//blur-&gt;GetHeight(PLANAR_U);
-	int y, reps;
-
-	/* Create the detail mask. */
-	EdgeMaskYV12(srcpY, blurpY, workpY, maskpY, row_sizeY, heightY, src_pitchY, blur_pitchY);
-	EdgeMaskYV12(srcpU, blurpU, workpU, maskpU, row_sizeUV, heightUV, src_pitchUV, blur_pitchUV);
-	EdgeMaskYV12(srcpV, blurpV, workpV, maskpV, row_sizeUV, heightUV, src_pitchUV, blur_pitchUV);
-
-	if (_param-&gt;showmask == true)
-	{
-		if (show == true)
-		{
-			char buf[80];
-			//env-&gt;MakeWritable(&amp;mask);
-			sprintf(buf, &quot;0.2 beta&quot;);
-			DrawString(mask, 0, 0, buf);
-			sprintf(buf, &quot;From Donald Graft&quot;);
-			DrawString(mask, 0, 1, buf);
-		}
-		//return mask;
-		memcpy(data-&gt;data,mask-&gt;data,(_info.width*_info.height*3)&gt;&gt;1);
-		data-&gt;copyInfo(src);
-		vidCache-&gt;unlockAll();
-		return 1;
-	}
-
-	/* Fix up output frame borders. */
-	srcpY = srcp_savedY;
-	finalpY = finalp_savedY;
-	finalp2Y = finalp2_savedY;
-	memcpy(finalpY, srcpY, row_sizeY);
-	memcpy(finalpY + (heightY-1)*blur_pitchY, srcpY + (heightY-1)*blur_pitchY, row_sizeY);
-	memcpy(finalp2Y, srcpY, row_sizeY);
-	memcpy(finalp2Y + (heightY-1)*blur_pitchY, srcpY + (heightY-1)*blur_pitchY, row_sizeY);
-	for (y = 0; y &lt; heightY; y++)
-	{
-		finalpY[0] = finalp2Y[0] = srcpY[0];
-		finalpY[row_sizeY-1] = finalp2Y[row_sizeY-1] = srcpY[row_sizeY-1];
-		srcpY += src_pitchY;
-		finalpY += blur_pitchY;
-		finalp2Y += blur_pitchY;
-	}
-	srcpU = srcp_savedU;
-	finalpU = finalp_savedU;
-	finalp2U = finalp2_savedU;
-	memcpy(finalpU, srcpU, row_sizeUV);
-	memcpy(finalpU + (heightUV-1)*blur_pitchUV, srcpU + (heightUV-1)*blur_pitchUV, row_sizeUV);
-	memcpy(finalp2U, srcpU, row_sizeUV);
-	memcpy(finalp2U + (heightUV-1)*blur_pitchUV, srcpU + (heightUV-1)*blur_pitchUV, row_sizeUV);
-	for (y = 0; y &lt; heightUV; y++)
-	{
-		finalpU[0] = finalp2U[0] = srcpU[0];
-		finalpU[row_sizeUV-1] = finalp2U[row_sizeUV-1] = srcpU[row_sizeUV-1];
-		srcpU += src_pitchUV;
-		finalpU += blur_pitchUV;
-		finalp2U += blur_pitchUV;
-	}
-	srcpV = srcp_savedV;
-	finalpV = finalp_savedV;
-	finalp2V = finalp2_savedV;
-	memcpy(finalpV, srcpV, row_sizeUV);
-	memcpy(finalpV + (heightUV-1)*blur_pitchUV, srcpV + (heightUV-1)*blur_pitchUV, row_sizeUV);
-	memcpy(finalp2V, srcpV, row_sizeUV);
-	memcpy(finalp2V + (heightUV-1)*blur_pitchUV, srcpV + (heightUV-1)*blur_pitchUV, row_sizeUV);
-	for (y = 0; y &lt; heightUV; y++)
-	{
-		finalpV[0] = finalp2V[0] = srcpV[0];
-		finalpV[row_sizeUV-1] = finalp2V[row_sizeUV-1] = srcpV[row_sizeUV-1];
-		srcpV += src_pitchUV;
-		finalpV += blur_pitchUV;
-		finalp2V += blur_pitchUV;
-	}
-
-	/* Masked smoothing. */
-	reps = 0;
-	SmoothingPassYV12(srcp_savedY, maskp_savedY, workp_savedY, finalp_savedY, row_sizeY, heightY, src_pitchY, blur_pitchY);
-//	env-&gt;BitBlt(finalp_savedU, blur_pitchUV, srcp_savedU, src_pitchUV, row_sizeUV, heightUV);
-//	env-&gt;BitBlt(finalp_savedV, blur_pitchUV, srcp_savedV, src_pitchUV, row_sizeUV, heightUV);
-	SmoothingPassYV12(srcp_savedU, maskp_savedU, workp_savedU, finalp_savedU, row_sizeUV, heightUV, src_pitchUV, blur_pitchUV);
-	SmoothingPassYV12(srcp_savedV, maskp_savedV, workp_savedV, finalp_savedV, row_sizeUV, heightUV, src_pitchUV, blur_pitchUV);
-	if (++reps &gt;= _param-&gt;strength)
-	{
-		deliver = final;
-		goto done;
-	}
-	while (1)
-	{
-		SmoothingPassYV12(finalp_savedY, maskp_savedY, workp_savedY, finalp2_savedY, row_sizeY, heightY, blur_pitchY, blur_pitchY);
-		SmoothingPassYV12(finalp_savedU, maskp_savedU, workp_savedU, finalp2_savedU, row_sizeUV, heightUV, blur_pitchUV, blur_pitchUV);
-		SmoothingPassYV12(finalp_savedV, maskp_savedV, workp_savedV, finalp2_savedV, row_sizeUV, heightUV, blur_pitchUV, blur_pitchUV);
-		if (++reps &gt;=  _param-&gt;strength)
-		{
-			deliver = final2;
-			goto done;
-		}
-		SmoothingPassYV12(finalp2_savedY, maskp_savedY, workp_savedY, finalp_savedY, row_sizeY, heightY, blur_pitchY, blur_pitchY);
-		SmoothingPassYV12(finalp2_savedU, maskp_savedU, workp_savedU, finalp_savedU, row_sizeUV, heightUV, blur_pitchUV, blur_pitchUV);
-		SmoothingPassYV12(finalp2_savedV, maskp_savedV, workp_savedV, finalp_savedV, row_sizeUV, heightUV, blur_pitchUV, blur_pitchUV);
-		if (++reps &gt;=  _param-&gt;strength)
-		{
-			deliver = final;
-			goto done;
-		}
-	}
-
-done:
-	if (show == true)
-	{
-		char buf[80];
-		//env-&gt;MakeWritable(&amp;deliver);
-		sprintf(buf, &quot;0.2beta&quot;);
-		DrawString(deliver, 0, 0, buf);
-		sprintf(buf, &quot;Donald Graft&quot;);
-		DrawString(deliver, 0, 1, buf);
-	}
-	memcpy(data-&gt;data,deliver-&gt;data,(_info.width*_info.height*3)&gt;&gt;1);
-	//return(deliver);
-	data-&gt;copyInfo(src);
-	vidCache-&gt;unlockAll();
-	return 1;
-}
-
-
-#ifdef HAVE_ALTIVEC
-#define vecbyte vector unsigned char
-#define vect16 vector unsigned short
-
-#define LOAD_ALIGN(dest,src) \
-		dest = (vect16)vec_ld(0, src); 
-
-//______________________
-void Blur_Altivec(uint8_t *in, uint8_t *out, uint32_t w, uint32_t h)
-{
-uint8_t *srcp,*srcpn,*srcpp;
-uint8_t *workp;
-uint32_t x,y;
-int16_t  v16[8];
-
-    vect16 pp,pc,pn,res,res2;
-	vect16 rp,rc,rn,resl;
-	vect16 zero,deux;
-	
-	uint32_t off;
-	vector unsigned char MSQ,mask;
-	zero=vec_splat_u16(0);
-	deux=vec_splat_u16(2);
-
-	srcpp = in;
-	srcp  = srcpp + w;
-	srcpn = srcp + w;
-	workp = out + w;
-	for (y = 1; y &lt; h - 1; y++)
-	{
-		for (x = 0; x &lt; (w&gt;&gt;4); x++)
-		{
-			off=x&lt;&lt;4;
-			LOAD_ALIGN(pp,srcpp+off);
-			LOAD_ALIGN(pc,srcp+off);
-			LOAD_ALIGN(pn,srcpn+off);
-			
-			aprintf(&quot;sn %vd\n&quot;,pn); 
-			aprintf(&quot;sp %vd\n&quot;,pp);
-			aprintf(&quot;sc %vd\n&quot;,pc);
-		
-			
-			rp=(vect16)vec_mergel( (vecbyte)zero,(vecbyte)pp);
-			rn=(vect16)vec_mergel( (vecbyte)zero,(vecbyte)pn);
-			rc=(vect16)vec_mergel( (vecbyte)zero,(vecbyte)pc);
-			
-			aprintf(&quot;rn %vd\n&quot;,rn); 
-			aprintf(&quot;rp %vd\n&quot;,rp);
-			aprintf(&quot;rc %vd\n&quot;,rc);
-		
-			res=vec_add(rp,rc);
-			res2=vec_add(rc,rn);
-			
-			aprintf(&quot;re %vd\n&quot;,res);
-			aprintf(&quot;r2 %vd\n&quot;,res2);
-			
-			res=vec_add(res,res2);
-			
-			resl=vec_sr(res,deux);
-			aprintf(&quot;rS %vd\n&quot;,res);
-			aprintf(&quot;r2 %vd\n&quot;,res2);
-			aprintf(&quot;rl %vd\n&quot;,resl);
-									
-			pp=(vect16)vec_mergeh( (vecbyte)zero,(vecbyte)pp);
-			pn=(vect16)vec_mergeh( (vecbyte)zero,(vecbyte)pn);
-			pc=(vect16)vec_mergeh( (vecbyte)zero,(vecbyte)pc);
-			
-			res=vec_add(pp,pc);
-			res2=vec_add(pc,pn);
-			res=vec_add(res,res2);
-			res=vec_sr(res,deux);
-			
-			aprintf(&quot;rH %vd\n&quot;,res);
-			
-			res=(vect16)vec_pack(res,resl);
-			aprintf(&quot;rF %vd\n&quot;,res);
-			
-			vec_st((vecbyte)res,0,(vector unsigned char *)(workp+off));
-			
-		}
-		srcpp += w;
-        srcp += w;
-        srcpn += w;
-        workp += w;
-    }
-	// Do it at the end as it may have been scratched
-	// due to 16 byte alignment
-	memcpy(out, in, w);
-	memcpy(out + (h-1)*w, in + (h-1)*w, w);
-	
-}
-#endif
-
-#if (defined( ARCH_X86)  || defined(ARCH_X86_64))
-//______________________
-void Blur_MMX(uint8_t *in, uint8_t *out, uint32_t w, uint32_t h)
-{
-uint8_t *srcp,*srcpn,*srcpp;
-uint8_t *workp;
-uint32_t x,y;
-uint32_t off;
-	
-	srcpp = in;
-	srcp  = srcpp + w;
-	srcpn = srcp + w;
-	workp = out + w;
-	for (y = 1; y &lt; h - 1; y++)
-	{
-		for (x =  (w&gt;&gt;3);x&gt;0; x--)
-		{
-			off=x&lt;&lt;3;
-			
-			__asm__(
-			&quot;.align 16\n&quot;
-			&quot;pxor  %%mm7,%%mm7\n&quot;
-			&quot;movq  (%0),%%mm0\n&quot;
-			&quot;movq  %%mm0,%%mm6\n&quot;
-			&quot;punpckhbw %%mm7,%%mm0\n&quot; // High part extended to 16 bits
-			&quot;punpcklbw %%mm7,%%mm6\n&quot; // low part ditto
-			
-			&quot;movq  (%1),%%mm1\n&quot;
-			&quot;movq  %%mm1,%%mm5\n&quot;
-			&quot;punpckhbw %%mm7,%%mm1\n&quot;
-			&quot;punpcklbw %%mm7,%%mm5\n&quot;
-			
-			&quot;movq  (%2),%%mm2\n&quot;
-			&quot;movq  %%mm2,%%mm4\n&quot;
-			&quot;punpckhbw %%mm7,%%mm2\n&quot;
-			&quot;punpcklbw %%mm7,%%mm4\n&quot;
-			
-			&quot;paddw %%mm1,%%mm0\n&quot;
-			&quot;paddw %%mm5,%%mm6\n&quot;
-			
-			&quot;paddw %%mm1,%%mm2\n&quot;
-			&quot;paddw %%mm5,%%mm4\n&quot;
-			
-			&quot;paddw %%mm0,%%mm2\n&quot;
-			&quot;paddw %%mm6,%%mm4\n&quot;
-			&quot;psrlw $2, %%mm4\n&quot;
-			&quot;psrlw $2, %%mm2\n&quot;
-			&quot;packuswb %%mm2,%%mm4\n&quot;
-			&quot;movq %%mm4,(%3)\n&quot; //
-			
-			: : &quot;r&quot; (srcpn+off),
-			   &quot;r&quot; (srcp+off), &quot;r&quot; (srcpp+off), &quot;r&quot; (workp+off)
-			);
-			
-		}
-		workp[0]=srcp[0];
-		workp[w-1]=srcp[w-1];
-		srcpp += w;
-        	srcp += w;
-        	srcpn += w;
-        	workp += w;
-    }
-	// Do it at the end as it may have been scratched
-	// due to 16 byte alignment
-	memcpy(out, in, w);
-	memcpy(out + (h-1)*w, in + (h-1)*w, w);
-	__asm__ (&quot;emms\n&quot; : :);
-	
-}
-#endif
-
-//______________________
-void Blur_C(uint8_t *in, uint8_t *out, uint32_t w, uint32_t h)
-{
-uint8_t *srcp,*srcpn,*srcpp;
-uint8_t *workp;
-uint32_t x,y;
-	srcpp = in;
-	srcp  = srcpp + w;
-	srcpn = srcp + w;
-	workp = out + w;
-	memcpy(out, in, w);
-	memcpy(out + (h-1)*w, in + (h-1)*w, w);
-	for (y = 1; y &lt; h - 1; y++)
-	{
-		workp[0] = srcp[0];
-		workp[w-1] = srcp[w-1];
-        for (x = 1; x &lt; w - 1; x++)
-		{
-			workp[x] = (srcpp[x] + srcp[x] + srcpn[x]) /3;
-		}
-        srcpp += w;
-        srcp += w;
-        srcpn += w;
-        workp += w;
-    }
-
-}
-//_______________________________
-void  Msmooth::EdgeMaskYV12(const unsigned char *srcp, unsigned char *blurp, unsigned char *workp, unsigned char *maskp,
-                        int row_size, int height, int src_pitch, int blur_pitch)
-{
-	const unsigned char *srcp_saved = srcp;
-	const unsigned char *srcpp;
-	const unsigned char *srcpn;
-
-	unsigned char *blurp_saved = blurp;
-	const unsigned char *blurpn;
-
-	unsigned char *workp_saved = workp;
-	unsigned char *workpp;
-	unsigned char *workpn;
-
-	unsigned char *maskp_saved = maskp;
-	int x, y;
-	int y1, y2, y3, y4;
-
-	/* Blur the source image prior to detail detection. */
-#if (defined( ARCH_X86)  || defined(ARCH_X86_64))
-		//printf(&quot;MMX\n&quot;);
-	if(CpuCaps::hasMMX())
-	{
-		Blur_MMX((uint8_t *)srcp,(uint8_t *)workp,row_size,height);
-		Blur_MMX((uint8_t *)workp,(uint8_t *)blurp,row_size,height);
-	}
-	else
-	#endif
-	#ifdef HAVE_ALTIVEC
-	#define ISALIGNED(x) (!( ((long long)x)&amp;15 ))
-		if( ISALIGNED(srcp) &amp;&amp; ISALIGNED(blurp) &amp;&amp; ISALIGNED(workp) &amp;&amp; ISALIGNED(maskp) &amp;&amp; !(src_pitch&amp;15))
-		{
-			Blur_Altivec((uint8_t *)srcp,(uint8_t *)workp,row_size,height);
-			Blur_Altivec((uint8_t *)workp,(uint8_t *)blurp,row_size,height);
-		}
-		else
-	#endif
-	{
-		Blur_C((uint8_t *)srcp,(uint8_t *)workp,row_size,height);
-		Blur_C((uint8_t *)workp,(uint8_t *)blurp,row_size,height);
-	}
-	/* Diagonal detail detection. */
-	blurp = (unsigned char *) workp_saved;
-	blurpn = blurp + blur_pitch;
-	maskp = maskp_saved;
-	y1 = blurp[0];
-	y3 = blurpn[0];
-	for (y = 0; y &lt; height - 1; y++) 
-	{
-		for (x = 0; x &lt; row_size - 1; x++)
-		{
-			y2 = blurp[x+1];
-			y4 = blurpn[x+1];
-			if ((abs(y1 - y4) &gt;= _param-&gt;threshold) || (abs(y2 - y3) &gt;= _param-&gt;threshold))
-			{
-				maskp[x] = 0xff;
-			}
-			else
-			{
-				maskp[x] = 0x0;
-			}
-			y1 = y2; y3 = y4;
-		}
-		maskp += blur_pitch;
-		blurp += blur_pitch;
-		blurpn += blur_pitch;
-	}
-
-	/* If set for high quality, also do horizontal and vertical
-	   detail detection. */
-	if ( _param-&gt;highq == true)
-	{
-		/* Msmooth convolve vertical. */
-		for (x = 0; x &lt; row_size; x++)
-		{
- 			blurp = blurp_saved;
-			blurpn = blurp + blur_pitch;
-			maskp = maskp_saved;
-			y1 = blurp[x];
-			for (y = 0; y &lt; height - 1; y++)
-			{
-				y2 = blurpn[x];
-				if (abs(y1 - y2) &gt;= _param-&gt;threshold)
-				{
-					maskp[x] = 0xff;
-				}
-				y1 = y2;
-				maskp += blur_pitch;
-				blurp += blur_pitch;
-				blurpn += blur_pitch;
-			}
-		}
-
-		/* Msmooth convolve horizontal. */
-		blurp = blurp_saved;
-		maskp = maskp_saved;
-		for (y = 0; y &lt; height; y++)
-		{
-			y1 = blurp[0];
-			for (x = 0; x &lt; row_size - 1; x++)
-			{
-				y2 = blurp[x+1];
-				if (abs(y1 - y2) &gt;= _param-&gt;threshold)
-				{
-					maskp[x] = 0xff;
-				}
-				y1 = y2;
-			}
-			maskp += blur_pitch;
-			blurp += blur_pitch;
-		}
-
-	}
-	/* Fix up detail map borders. */
-	maskp = maskp_saved;
-	memset(maskp, 0xff, row_size);
-	memset(maskp + (height-1)*blur_pitch, 0xff, row_size);
-	for (y = 0; y &lt; height; y++)
-	{
-//		*((unsigned int *)(&amp;maskp[0])) = 0xffffffff;
-//		*((unsigned int *)(&amp;maskp[row_size-1])) = 0xffffffff;
-		maskp[0] = 0xff;
-		maskp[row_size-1] = 0xff;
-		maskp += blur_pitch;
-	}
-}
-
-void  Msmooth::SmoothingPassYV12(const unsigned char *srcp, unsigned char *maskp,
-									  unsigned char *workp, unsigned char *finalp,
-									  int row_size, int height, int spitch, int dpitch)
-{
-	const unsigned char *srcp_saved = srcp;
-	const unsigned char *srcpp;
-	const unsigned char *srcpn;
-
-	unsigned char *workp_saved = workp;
-	unsigned char *workpp;
-	unsigned char *workpn;
-
-	unsigned char *maskp_saved = maskp;
-	unsigned char *maskpp;
-	unsigned char *maskpn;
-
-	unsigned char *finalp_saved = finalp;
-
-	int x, y, ysum;
-
-	srcpp = srcp_saved;
- 	srcp = srcpp + spitch;
-	srcpn = srcp + spitch;
-	maskpp = maskp_saved;
- 	maskp = maskpp + dpitch;
-	maskpn = maskp + dpitch;
-	workp = workp_saved + dpitch;
-	memcpy(workp_saved, srcp_saved, row_size);
-	memcpy(workp_saved + (height-1)*dpitch, srcp_saved + (height-1)*spitch, row_size);
-	for (y = 1; y &lt; height - 1; y++)
-	{
-		workp[0] = srcp[0];
-		workp[row_size-1] = srcp[row_size-1];
-        for (x = 1; x &lt; row_size - 1; x++)
-		{
-			int count = 1;
-
-			if (!maskp[x])
-			{
-				ysum = srcp[x];
-				if (!maskpp[x])
-				{
-					ysum += srcpp[x];
-					count++;
-				}
-				if (!maskpn[x])
-				{
-					ysum += srcpn[x];
-					count++;
-				}
-				workp[x] = ysum / count;
-			}
-		}
-        srcpp += spitch;
-        srcp += spitch;
-        srcpn += spitch;
- 		maskpp += dpitch;
-		maskp += dpitch;
-		maskpn += dpitch;
-        workp += dpitch;
-    }
-	srcpp = srcp_saved;
- 	srcp = srcpp + spitch;
-	srcpn = srcp + spitch;
-	workpp = workp_saved;
- 	workp = workpp + dpitch;
-	workpn = workp + dpitch;
-	maskpp = maskp_saved;
- 	maskp = maskpp + dpitch;
-	maskpn = maskp + dpitch;
-	finalp = finalp_saved + dpitch;
-	for (y = 1; y &lt; height - 1; y++)
-	{
-        for (x = 1; x &lt; row_size - 1; x++)
-		{
-			int count = 1;
-
-			if (!maskp[x])
-			{
-				ysum = workp[x];
-				if (!maskp[x-1])
-				{
-					ysum += workp[x-1];
-					count++;
-				}
-				if (!maskp[x+1])
-				{
-					ysum += workp[x+1];
-					count++;
-				}
-				finalp[x] = ysum / count;
-			}
-			else
-			{
-				finalp[x] = srcp[x];
-			}
-		}
-        srcpp += spitch;
-        srcp += spitch;
-        srcpn += spitch;
-        workpp += dpitch;
-        workp += dpitch;
-        workpn += dpitch;
- 		maskpp += dpitch;
-		maskp += dpitch;
-		maskpn += dpitch;
-        finalp += dpitch;
-    }
-}
-

Modified: branches/avidemux_2.4_branch/avidemux/ADM_video/Makefile.am
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/Makefile.am	2007-01-08 21:29:24 UTC (rev 2696)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/Makefile.am	2007-01-09 19:54:42 UTC (rev 2697)
@@ -13,12 +13,10 @@
  ADM_vidLargeMedian.cpp \
  ADM_vidSalt.cpp \
  ADM_vidCached.cpp \
- ADM_vidFlux.cpp \
  ADM_vidPartial.cpp \
  ADM_vidFont.cpp \
  ADM_vidSRT.cpp \
  ADM_vidDenoise.cpp \
- ADM_vidFastConvolution.cpp \
 	ADM_vidFlipV.cpp \
  ADM_vidStabilize.cpp \
  ADM_vidContrast.cpp \
@@ -35,11 +33,7 @@
  ADM_vidUVSwap.cpp \
 	ADM_vidClean.cpp \
  ADM_vidChroma.cpp \
- ADM_vidBSmear.cpp \
- ADM_vidAddBorder.cpp \
 	ADM_resizebis.cpp \
- ADM_guiBSMear.cpp \
-	ADM_guiAddBorder.cpp \
  ADM_genvideo.cpp \
  ADM_vidRotate.cpp \
  ADM_vidRotate.h \
@@ -73,7 +67,6 @@
  ADM_vidDecTelecide.cpp \
  ADM_vidDecTelecide.h ADM_cache.cpp \
  ADM_vidDecDec.cpp \
- ADM_vidMsmooth.cpp \
  ADM_vidWirl.cpp \
  ADM_vidEqualizer.cpp \
  ADM_vidVobsub.cpp \
@@ -107,13 +100,13 @@
 
 
 EXTRA_DIST =  ADM_cache.cpp  ADM_vidDecDec_param.h ADM_vidMosaic_param.h \
-ADM_cache.h  ADM_vidDecTel_param.h ADM_vidMsmooth.cpp \
+ADM_cache.h  ADM_vidDecTel_param.h \
 ADM_confCouple.h ADM_vidDecTelecide.cpp  ADM_vidNull.cpp \
 ADM_confCouples.cpp  ADM_vidDecTelecide.h  ADM_vidPalShift.cpp \
 ADM_genvideo.cpp ADM_vidDeintASM.cpp ADM_vidPalShift.h \
 ADM_genvideo.hxx ADM_vidDeinterlace.cpp  ADM_vidPartial.cpp \
-ADM_guiAddBorder.cpp ADM_vidDeinterlace.h  ADM_vidPartial.h \
-ADM_guiBSMear.cpp  ADM_vidDelta.cpp  ADM_vidPartial_param.h \
+ADM_vidDeinterlace.h  ADM_vidPartial.h \
+ADM_vidDelta.cpp  ADM_vidPartial_param.h \
 ADM_guiCrop.cpp  ADM_vidDenoise.cpp  ADM_vidPulldown.cpp \
 ADM_guiMedianBig.cpp ADM_vidDenoise.h  ADM_vidPulldown.h \
 ADM_guiResize.cpp  ADM_vidDropOut.cpp  ADM_vidRaw.cpp \
@@ -124,17 +117,17 @@
 ADM_mpdetc.cpp ADM_vidEqualizer.h  ADM_vidRotate.cpp \
 ADM_mpdetc.h ADM_vidFade.cpp ADM_vidRotate.h \
 ADM_resizebis.cpp  ADM_vidFade_param.h ADM_vidSRT.cpp \
-ADM_resizebis.hxx  ADM_vidFastConvolution.cpp  ADM_vidSRT.h \
+ADM_resizebis.hxx    ADM_vidSRT.h \
 ADM_resizeter.cpp  ADM_vidField.h  ADM_vidSRTRender.cpp \
 ADM_separateField.cpp  ADM_vidFieldUnblend.cpp ADM_vidSRTload.cpp \
 ADM_vidASharp_param.h  ADM_vidFieldUtil.cpp  ADM_vidSalt.cpp \
-ADM_vidAddBorder.cpp ADM_vidFieldUtil.h  ADM_vidSalt.h \
-ADM_vidAddBorder.h ADM_vidFields.cpp ADM_vidSeparateField.cpp \
+ADM_vidFieldUtil.h  ADM_vidSalt.h \
+ADM_vidFields.cpp ADM_vidSeparateField.cpp \
 ADM_vidAnimated.cpp  ADM_vidFlipV.cpp  ADM_vidSeparateField.h \
 ADM_vidAnimated.h  ADM_vidFlipV.h  ADM_vidSoften.cpp \
-ADM_vidAnimated_param.h  ADM_vidFlux.cpp ADM_vidSoften.h \
-ADM_vidAsharp.cpp  ADM_vidFlux.h ADM_vidStabilize.cpp \
-ADM_vidBSmear.cpp  ADM_vidFont.cpp ADM_vidStabilize.h \
+ADM_vidAnimated_param.h   ADM_vidSoften.h \
+ADM_vidAsharp.cpp   ADM_vidStabilize.cpp \
+ADM_vidFont.cpp ADM_vidStabilize.h \
 ADM_vidBlend.cpp ADM_vidFont.h ADM_vidSwapFields.cpp \
 ADM_vidBlendRemoval.cpp  ADM_vidForcedPP.cpp ADM_vidSwapFields.h \
 ADM_vidBlendRemoval_param.h  ADM_vidForcedPP.h ADM_vidSwapSmart.cpp \

Copied: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidAddBorder.cpp (from rev 2489, branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidAddBorder.cpp)
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidAddBorder.cpp	2006-10-31 15:59:58 UTC (rev 2489)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidAddBorder.cpp	2007-01-09 19:54:42 UTC (rev 2697)
@@ -0,0 +1,256 @@
+/***************************************************************************
+                          ADM_vidAddBorder.cpp  -  description
+                             -------------------
+    begin                : Sun Aug 11 2002
+    copyright            : (C) 2002 by mean
+    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include &lt;stdio.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;string.h&gt;
+#include &lt;ADM_assert.h&gt;
+
+#include &quot;config.h&quot;
+#include &quot;fourcc.h&quot;
+#include &quot;avio.hxx&quot;
+#include &quot;config.h&quot;
+#include &quot;avi_vars.h&quot;
+#ifdef HAVE_ENCODER
+
+
+#include &quot;ADM_toolkit/toolkit.hxx&quot;
+#include &quot;ADM_editor/ADM_edit.hxx&quot;
+#include &quot;ADM_video/ADM_genvideo.hxx&quot;
+#include &quot;ADM_vidAddBorder.h&quot;
+#include &quot;ADM_video/ADM_vidCommonFilter.h&quot;
+#include &quot;ADM_filter/video_filters.h&quot;
+
+#include &quot;ADM_userInterfaces/ADM_commonUI/DIA_factory.h&quot;
+
+static FILTER_PARAM cropParam={4,{&quot;left&quot;,&quot;right&quot;,&quot;top&quot;,&quot;bottom&quot;}};
+
+
+SCRIPT_CREATE(addBorder_script,AVDMVideoAddBorder,cropParam);
+BUILD_CREATE(addBorder_create,AVDMVideoAddBorder);
+
+char *AVDMVideoAddBorder::printConf( void )
+{
+ 	static char buf[50];
+
+ 	sprintf((char *)buf,&quot; Add Borders %lu x %lu --&gt; %lu x %lu&quot;,
+ 				_in-&gt;getInfo()-&gt;width,
+ 				_in-&gt;getInfo()-&gt;height,
+ 				_info.width,
+ 				_info.height);
+        return buf;
+}
+
+AVDMVideoAddBorder::AVDMVideoAddBorder(  AVDMGenericVideoStream *in,CONFcouple *couples)
+{
+
+ 	_in=in;		
+   	memcpy(&amp;_info,_in-&gt;getInfo(),sizeof(_info));  		
+	
+		if(couples)
+		{
+
+			 _param=NEW(CROP_PARAMS);
+
+				GET(left);
+				GET(right);
+				GET(top);
+				GET(bottom);
+				_info.width+=_param-&gt;right+_param-&gt;left;
+				_info.height+=_param-&gt;bottom+_param-&gt;top;
+		}	
+			else 			
+		{	// default parameter	
+				_param=NEW(CROP_PARAMS);
+				_param-&gt;left=_param-&gt;top=
+				_param-&gt;right=_param-&gt;bottom=0;
+		}				
+					
+ 	//_uncompressed=(uint8_t *)malloc(3*_in-&gt;getInfo()-&gt;width*_in-&gt;getInfo()-&gt;height);
+ 	//_uncompressed=new uint8_t [3*_in-&gt;getInfo()-&gt;width*_in-&gt;getInfo()-&gt;height];
+	_uncompressed=new ADMImage(_in-&gt;getInfo()-&gt;width,_in-&gt;getInfo()-&gt;height);
+  ADM_assert(_uncompressed);
+  _info.encoding=1;
+
+  	  	
+}
+AVDMGenericVideoStream *create_addBorder(AVDMGenericVideoStream *in,uint32_t x,uint32_t x2,uint32_t y,uint32_t y2)
+{
+	return new AVDMVideoAddBorder(in,x,x2,y,y2);
+}
+AVDMVideoAddBorder::AVDMVideoAddBorder(  AVDMGenericVideoStream *in,uint32_t x,uint32_t x2,uint32_t y,uint32_t y2)
+{
+
+ 	_in=in;		
+   	memcpy(&amp;_info,_in-&gt;getInfo(),sizeof(_info));  		
+
+				_param=NEW(CROP_PARAMS);
+				_param-&gt;left=x;
+				_param-&gt;top=y;
+				_param-&gt;right=x2;
+				_param-&gt;bottom=y2;
+	_info.width+=_param-&gt;right+_param-&gt;left;
+	_info.height+=_param-&gt;bottom+_param-&gt;top;
+ 	//_uncompressed=(uint8_t *)malloc(3*_in-&gt;getInfo()-&gt;width*_in-&gt;getInfo()-&gt;height);
+ 	//_uncompressed=new uint8_t [3*_in-&gt;getInfo()-&gt;width*_in-&gt;getInfo()-&gt;height];
+	_uncompressed=new ADMImage(_in-&gt;getInfo()-&gt;width,_in-&gt;getInfo()-&gt;height);
+  ADM_assert(_uncompressed);
+  _info.encoding=1;
+
+
+}
+
+uint8_t	AVDMVideoAddBorder::getCoupledConf( CONFcouple **couples)
+{
+
+			ADM_assert(_param);
+			*couples=new CONFcouple(4);
+
+
+	CSET(left);
+	CSET(right);
+	CSET(top);
+	CSET(bottom);
+			return 1;
+
+}
+AVDMVideoAddBorder::~AVDMVideoAddBorder()
+{
+ 	delete _uncompressed;
+	DELETE(_param);
+	_uncompressed=NULL;
+ 	
+}
+uint8_t AVDMVideoAddBorder::getFrameNumberNoAlloc(uint32_t frame,
+				uint32_t *len,
+   				ADMImage *data,
+				uint32_t *flags)
+{
+
+		if(frame&gt;=_info.nb_frames) 
+		{
+			printf(&quot;Filter : out of bound!\n&quot;);
+			return 0;
+		}
+	
+		ADM_assert(_param);									
+								
+			// read uncompressed frame
+       		if(!_in-&gt;getFrameNumberNoAlloc(frame, len,_uncompressed,flags)) return 0;
+       		
+				// blacken screen
+				memset(YPLANE(data),16,_info.width*_info.height);
+				memset(UPLANE(data),128,(_info.width*_info.height)&gt;&gt;2);
+				memset(VPLANE(data),128,(_info.width*_info.height)&gt;&gt;2);
+
+				// do luma
+				uint8_t *src,*dest;
+       		uint32_t y,x,line,lineout;
+       		
+       		y=_in-&gt;getInfo()-&gt;height;
+       		x=_in-&gt;getInfo()-&gt;width;
+       		line=x;
+		lineout=_info.width;
+		
+		// copy Luma
+       		src=YPLANE(_uncompressed);
+       		dest=YPLANE(data)+_param-&gt;left+_info.width*_param-&gt;top;
+       		
+       		for(uint32_t k=y;k&gt;0;k--)
+       		{
+       		 	    memcpy(dest,src,line);
+       		 	    src+=line;
+       		 	    dest+=lineout;
+       		}
+       		 
+		// U and V now
+		uint8_t *src_u,*src_v;
+		uint8_t *dst_u,*dst_v;
+
+       		src_u=UPLANE(_uncompressed);
+       		src_v=VPLANE(_uncompressed);
+       		line&gt;&gt;=1;
+       		lineout&gt;&gt;=1;       		       		 	
+		dst_u=UPLANE( data)+(_info.width*_param-&gt;top&gt;&gt;2)+
+						(_param-&gt;left&gt;&gt;1);;
+		dst_v= VPLANE( data)+(_info.width*_param-&gt;top&gt;&gt;2)+
+						(_param-&gt;left&gt;&gt;1);;
+
+       		 for(uint32_t k=y&gt;&gt;1;k&gt;0;k--)
+       		 {
+       		 	memcpy(dst_u,src_u,line);
+       		 	memcpy(dst_v,src_v,line);
+
+       			src_u+=line;
+       			src_v+=line;
+
+       			dst_u+=lineout;
+       		    	dst_v+=lineout;
+
+       		 }
+       		  *len= _info.width*_info.height+(_info.width*_info.height&gt;&gt;1);
+		  data-&gt;copyInfo(_uncompressed);
+      return 1;
+}
+uint8_t AVDMVideoAddBorder::configure(AVDMGenericVideoStream *in)
+{
+	_in=in;
+	ADM_assert(_param);
+        uint32_t width,height;
+#define MAKEME(x) uint32_t x=_param-&gt;x;
+        while(1)
+        {
+          MAKEME(left);
+          MAKEME(right);
+          MAKEME(top);
+          MAKEME(bottom);
+          
+          width=_in-&gt;getInfo()-&gt;width;
+          height=_in-&gt;getInfo()-&gt;height;
+          
+          diaElemUInteger dleft(&amp;left,&quot;Left&quot;,       0,width);
+          diaElemUInteger dright(&amp;right,&quot;Right&quot;,    0,width);
+          diaElemUInteger dtop(&amp;(top),&quot;Top&quot;,          0,height);
+          diaElemUInteger dbottom(&amp;(bottom),&quot;Bottom&quot;, 0,height);
+            
+          diaElem *elems[4]={&amp;dleft,&amp;dright,&amp;dtop,&amp;dbottom};
+          if(diaFactoryRun(&quot;Add border&quot;,4,elems))
+          {
+            if((left&amp;1) || (right&amp;1)|| (top&amp;1) || (bottom&amp;1))
+            {
+              GUI_Error_HIG(&quot;Incorrect parameters&quot;,&quot;All parameters must be even and within range&quot;); 
+              continue;
+            }
+            else
+            {
+  #undef MAKEME
+  #define MAKEME(x) _param-&gt;x=x;
+                MAKEME(left);
+                MAKEME(right);
+                MAKEME(top);
+                MAKEME(bottom);
+                _info.width=width+left+right;
+                _info.height=height+top+bottom;
+                return 1;
+            }
+          }
+          return 0;
+      }
+}
+
+
+
+#endif

Copied: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidAddBorder.h (from rev 2489, branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidAddBorder.h)
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidAddBorder.h	2006-10-31 15:59:58 UTC (rev 2489)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidAddBorder.h	2007-01-09 19:54:42 UTC (rev 2697)
@@ -0,0 +1,37 @@
+/***************************************************************************
+                          ADM_vidAddBorder.h  -  description
+                             -------------------
+    begin                : Sun Aug 11 2002
+    copyright            : (C) 2002 by mean
+    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#ifndef __ADDBORDER__
+#define     __ADDBORDER__
+  class  AVDMVideoAddBorder:public AVDMGenericVideoStream
+ {
+
+ protected:
+              virtual char        *printConf(void);
+              CROP_PARAMS         *_param;
+ public:
+
+                                    AVDMVideoAddBorder(  AVDMGenericVideoStream *in,CONFcouple *setup);
+                                    AVDMVideoAddBorder(  AVDMGenericVideoStream *in,uint32_t x,uint32_t x2,
+                                                              uint32_t y,uint32_t y2);
+            virtual                 ~AVDMVideoAddBorder();
+            virtual 	uint8_t     getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
+                                            ADMImage *data,uint32_t *flags);
+                        uint8_t     configure( AVDMGenericVideoStream *instream) ;
+                        uint8_t     getCoupledConf( CONFcouple **couples);
+ }     ;
+
+#endif

Copied: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidBSmear.cpp (from rev 2489, branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidBSmear.cpp)
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidBSmear.cpp	2006-10-31 15:59:58 UTC (rev 2489)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidBSmear.cpp	2007-01-09 19:54:42 UTC (rev 2697)
@@ -0,0 +1,232 @@
+/***************************************************************************
+                          ADM_vidBSMear.cpp  -  description
+                             -------------------
+         change part of video into black borders
+
+          Each one ,must be even
+
+          Copy / Paste from crop,almost the same thing
+
+
+    begin                : Sun Mar 24 2002
+    copyright            : (C) 2002 by mean
+    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include &lt;stdio.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;string.h&gt;
+#include &lt;ADM_assert.h&gt;
+
+#include &quot;config.h&quot;
+#include &quot;fourcc.h&quot;
+#include &quot;avio.hxx&quot;
+#include &quot;config.h&quot;
+#include &quot;avi_vars.h&quot;
+#ifdef HAVE_ENCODER
+
+
+#include &quot;ADM_toolkit/toolkit.hxx&quot;
+#include &quot;ADM_editor/ADM_edit.hxx&quot;
+#include &quot;ADM_video/ADM_genvideo.hxx&quot;
+#include &quot;ADM_video/ADM_vidCommonFilter.h&quot;
+#include &quot;ADM_filter/video_filters.h&quot;
+
+#include &quot;ADM_userInterfaces/ADM_commonUI/DIA_factory.h&quot;
+
+static FILTER_PARAM cropParam={4,{&quot;left&quot;,&quot;right&quot;,&quot;top&quot;,&quot;bottom&quot;}};
+
+
+SCRIPT_CREATE(bsmear_script,AVDMVideoStreamBSMear,cropParam);
+
+char *AVDMVideoStreamBSMear::printConf( void )
+{
+ 	static char buf[50];
+ 	
+ 	sprintf((char *)buf,&quot; Black l:%lu  r:%lu  u:%lu x d:%lu&quot;,
+ 				_param-&gt;left,
+ 					_param-&gt;right,
+ 					_param-&gt;top,
+ 					_param-&gt;bottom);
+        return buf;
+}
+
+//_______________________________________________________________
+
+AVDMVideoStreamBSMear::AVDMVideoStreamBSMear(  	AVDMGenericVideoStream *in,CONFcouple *couples)
+{
+
+
+  	_in=in;		
+   	memcpy(&amp;_info,_in-&gt;getInfo(),sizeof(_info));  		
+
+		if(couples)
+		{
+			_param=NEW(CROP_PARAMS);
+			GET(left);
+			GET(right);
+			GET(top);
+			GET(bottom);
+		}	
+			else 	
+		{	// default parameter	
+				_param=NEW(CROP_PARAMS);
+				_param-&gt;left=_param-&gt;top=
+						_param-&gt;right=_param-&gt;bottom=0;
+		}										
+ 	
+  _info.encoding=1;
+
+  	  	
+}
+
+uint8_t	AVDMVideoStreamBSMear::getCoupledConf( CONFcouple **couples)
+{
+
+			ADM_assert(_param);
+			*couples=new CONFcouple(4);
+
+#define CSET(x)  (*couples)-&gt;setCouple((char *)#x,(_param-&gt;x))
+	CSET(left);
+	CSET(right);
+	CSET(top);
+	CSET(bottom);
+			return 1;
+
+}
+AVDMVideoStreamBSMear::~AVDMVideoStreamBSMear()
+{
+ 	DELETE(_param);
+ 	
+}
+
+//
+//	Blacken borders, just setting luma to null should be enough
+//
+
+uint8_t AVDMVideoStreamBSMear::getFrameNumberNoAlloc(uint32_t frame,
+				uint32_t *len,
+   				ADMImage *data,
+				uint32_t *flags)
+{
+
+			if(frame&gt;=_info.nb_frames) 
+			{
+				printf(&quot;Filter : out of bound!\n&quot;);
+				return 0;
+			}
+	
+			ADM_assert(_param);									
+								
+			// read uncompressed frame directly into follower
+			// and blacken there
+			
+       		if(!_in-&gt;getFrameNumberNoAlloc(frame, len,data,flags)) return 0;
+       		  *len= _info.width*_info.height+(_info.width*_info.height&gt;&gt;1);       			
+       		  // blacken top
+       		  uint8_t *srcY=YPLANE(data);
+		  uint8_t *srcU=UPLANE(data);
+		  uint8_t *srcV=VPLANE(data);
+       		  uint32_t bytes=_info.width*_param-&gt;top;
+		  uint32_t page=_info.width*_info.height;
+       		
+       		  memset(srcY,0x10,bytes);
+		  memset(srcU,0x80,bytes&gt;&gt;2);
+		  memset(srcV,0x80,bytes&gt;&gt;2);
+       		  // left &amp; right
+       		  uint32_t stride=_info.width;
+		  
+       		  for(uint32_t y=_info.height;y&gt;0;y--)
+       		  {
+       		        memset(srcY,0x10,_param-&gt;left);
+       		        memset(srcY+stride-_param-&gt;right,0,_param-&gt;right);       		
+       		        srcY+=stride;       		
+		 }
+		 for(uint32_t y=_info.height&gt;&gt;1;y&gt;0;y--)
+       		  {
+       		        
+			memset(srcU,0x80,_param-&gt;left&gt;&gt;1);
+			memset(srcV,0x80,_param-&gt;left&gt;&gt;1);
+			memset(srcU+((stride-_param-&gt;right)&gt;&gt;1),0x80,_param-&gt;right&gt;&gt;1);
+			memset(srcV+((stride-_param-&gt;right)&gt;&gt;1),0x80,_param-&gt;right&gt;&gt;1);
+			srcU+=stride&gt;&gt;1;
+			srcV+=stride&gt;&gt;1;
+       		  }
+       		
+       		  // backen bottom
+       		  srcY=YPLANE(data)+_info.width*_info.height-1;
+       		
+       		 bytes=_info.width*_param-&gt;bottom;
+       	 	 srcY-=bytes;
+       		 memset(srcY,0x10,bytes);
+		// chroma
+		 srcU=UPLANE(data)+(page&gt;&gt;2)-1;
+		 srcU-=bytes&gt;&gt;2;
+       		 memset(srcU,0x80,bytes&gt;&gt;2);
+		 
+		 srcV=VPLANE(data)+(page&gt;&gt;2)-1;
+		 srcV-=bytes&gt;&gt;2;
+       		 memset(srcV,0x80,bytes&gt;&gt;2);
+		 
+		  
+       		  	
+       		         		       		
+      return 1;
+}
+uint8_t AVDMVideoStreamBSMear::configure(AVDMGenericVideoStream *in)
+{
+	_in=in;
+	ADM_assert(_param);
+        uint32_t width,height;
+#define MAKEME(x) uint32_t x=_param-&gt;x;
+        while(1)
+        {
+          MAKEME(left);
+          MAKEME(right);
+          MAKEME(top);
+          MAKEME(bottom);
+          
+          width=_in-&gt;getInfo()-&gt;width;
+          height=_in-&gt;getInfo()-&gt;height;
+          
+          diaElemUInteger dleft(&amp;left,&quot;Left&quot;,       0,width);
+          diaElemUInteger dright(&amp;right,&quot;Right&quot;,    0,width);
+          diaElemUInteger dtop(&amp;(top),&quot;Top&quot;,          0,height);
+          diaElemUInteger dbottom(&amp;(bottom),&quot;Bottom&quot;, 0,height);
+            
+          diaElem *elems[4]={&amp;dleft,&amp;dright,&amp;dtop,&amp;dbottom};
+          if(diaFactoryRun(&quot;Blacken Borders&quot;,4,elems))
+          {
+            if((left&amp;1) || (right&amp;1)|| (top&amp;1) || (bottom&amp;1) ||
+                     (top+bottom&gt;=height)|| (left+right&gt;width))
+            {
+              GUI_Error_HIG(&quot;Incorrect parameters&quot;,&quot;All parameters must be even and within range&quot;); 
+              continue;
+            }
+            else
+            {
+  #undef MAKEME
+  #define MAKEME(x) _param-&gt;x=x;
+                MAKEME(left);
+                MAKEME(right);
+                MAKEME(top);
+                MAKEME(bottom);
+                _info.width=width+left+right;
+                _info.height=height+top+bottom;
+                return 1;
+            }
+          }
+          return 0;
+      }
+}
+
+#endif

Copied: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidFastConvolution.cpp (from rev 2693, branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidFastConvolution.cpp)

Copied: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidFlux.cpp (from rev 2489, branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidFlux.cpp)
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidFlux.cpp	2006-10-31 15:59:58 UTC (rev 2489)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidFlux.cpp	2007-01-09 19:54:42 UTC (rev 2697)
@@ -0,0 +1,659 @@
+/***************************************************************************
+                          ADM_vidFlux.cpp  -  description
+                             -------------------
+    begin                : Tue Dec 31 2002
+    copyright            : (C) 2002 by mean
+    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
+    
+    Ported from FluxSmooth
+    (c)  Ross Thomas &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">ross at grinfinity.com</A>&gt;
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include &quot;config.h&quot; 
+ 
+#include &lt;stdio.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;string.h&gt;
+#include &lt;ADM_assert.h&gt;
+#include &lt;math.h&gt;
+
+#include &quot;default.h&quot;
+#include &quot;fourcc.h&quot;
+#include &quot;avio.hxx&quot;
+#include &quot;config.h&quot;
+
+
+
+//#include &quot;ADM_toolkit/toolkit.hxx&quot;
+#include &quot;ADM_editor/ADM_edit.hxx&quot;
+#include &quot;ADM_video/ADM_genvideo.hxx&quot;
+#include &quot;admmangle.h&quot;
+
+#include &quot;ADM_userInterfaces/ADM_commonUI/DIA_factory.h&quot;
+#include &quot;ADM_vidFlux.h&quot;
+#include &quot;ADM_filter/video_filters.h&quot;
+
+
+#include &quot;ADM_assert.h&quot;
+
+static int16_t scaletab[16];
+static uint64_t scaletab_MMX[65536];
+
+void initScaleTab( void )
+{
+//uint32_t i;
+
+		scaletab[1] = 32767;
+		for(int i = 2; i &lt; 16; ++i)
+				scaletab[i] = (int)(32768.0 / i + 0.5);
+		for(uint32_t  i = 0; i &lt; 65536; ++i)
+		{
+			scaletab_MMX[i] = ( (uint64_t)scaletab[ i        &amp; 15]       ) |
+							  (((uint64_t)scaletab[(i &gt;&gt;  4) &amp; 15]) &lt;&lt; 16) |
+							  (((uint64_t)scaletab[(i &gt;&gt;  8) &amp; 15]) &lt;&lt; 32) |
+							  (((uint64_t)scaletab[(i &gt;&gt; 12) &amp; 15]) &lt;&lt; 48);
+		}
+}
+ 
+
+static FILTER_PARAM fluxParam={2,{&quot;temporal_threshold&quot;,&quot;spatial_threshold&quot;}};
+
+
+SCRIPT_CREATE(fluxsmooth_script,ADMVideoFlux,fluxParam);
+
+//#define ASM_FLUX
+BUILD_CREATE(fluxsmooth_create,ADMVideoFlux);
+
+static uint64_t spat_thresh ASM_CONST =0LL;
+static uint64_t temp_thresh ASM_CONST =0LL;
+static uint64_t ASM_CONST _l_counter_init,_l_indexer,_l_prev_pels,_l_next_pels;
+static long int _l_src_pitch ASM_CONST =0;
+static long int _l_dst_pitch ASM_CONST =0;
+static int _l_xmax ASM_CONST=0;
+
+static int ycnt;
+static	uint8_t * _l_currp; 
+static	 uint8_t * _l_prevp;								  								  
+static	 uint8_t * _l_nextp; 
+static	 uint8_t * _l_destp; 
+
+
+static uint32_t size;
+
+ADMVideoFlux::ADMVideoFlux(AVDMGenericVideoStream *in,CONFcouple *couples)
+			
+{
+  
+	_in=in;
+	memcpy(&amp;_info,in-&gt;getInfo(),sizeof(_info));
+	if(couples)
+	{
+		_param=NEW( FLUX_PARAM );
+		GET(temporal_threshold);
+		GET(spatial_threshold);
+	}
+	else
+	{
+		 _param=NEW( FLUX_PARAM );
+		 _param-&gt;spatial_threshold=7;
+		 _param-&gt;temporal_threshold=7;
+	}
+  	num_frame=0xffff0000;
+	vidCache=new VideoCache(5,in);
+}
+
+uint8_t	ADMVideoFlux::getCoupledConf( CONFcouple **couples)
+{
+
+			ADM_assert(_param);
+			*couples=new CONFcouple(2);
+
+#define CSET(x)  (*couples)-&gt;setCouple((char *)#x,(_param-&gt;x))
+	CSET(temporal_threshold);
+	CSET(spatial_threshold);
+		return 1;
+
+}
+uint8_t ADMVideoFlux::configure(AVDMGenericVideoStream *in)
+{
+UNUSED_ARG(in);
+int32_t temporal,spatial; // diaElem wants int32 not uint32
+uint8_t r;
+    temporal=_param-&gt;temporal_threshold;
+    spatial=_param-&gt;spatial_threshold;
+
+    diaElemInteger Gtemporal(&amp;temporal,&quot;Temporal  Threshold&quot;,0,255);
+    diaElemInteger Gspatial(&amp;spatial,&quot;Spatial  Threshold&quot;,0,255);
+	  
+    diaElem *elems[2]={&amp;Gtemporal,&amp;Gspatial};
+  
+    r=diaFactoryRun(&quot;Flux Smooth&quot;,2,elems);
+    if(r)
+    {
+       _param-&gt;temporal_threshold=temporal;
+       _param-&gt;spatial_threshold=spatial;
+    }
+    return r;
+    
+}
+ADMVideoFlux::~ADMVideoFlux()
+{
+	DELETE(_param);
+	if(vidCache)
+		delete vidCache;
+	vidCache=NULL;
+}
+
+char	*ADMVideoFlux::printConf( void) 
+{
+	static char conf[100];
+
+		sprintf(conf,&quot;FluxSmooth: Spatial :%02lu Temporal:%02lu&quot;,
+						_param-&gt;spatial_threshold,
+						_param-&gt;temporal_threshold);
+		return conf;
+	
+}
+uint8_t ADMVideoFlux::getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
+          			ADMImage *data,uint32_t *flags)
+{
+UNUSED_ARG(flags);
+uint32_t dlen,dflags;
+uint32_t plane=_info.width*_info.height;
+ADMImage	*image,*next,*prev;
+
+
+			*len=(plane*3)&gt;&gt;1;
+			
+			size=(_info.width*_info.height*3)&gt;&gt;1;
+			if(frame&gt;_info.nb_frames-1) return 0;
+			
+			image=vidCache-&gt;getImage(frame);
+			if(!image) return 0;
+			
+			if(!frame || (frame==_info.nb_frames-1))
+			{
+
+				data-&gt;duplicate(image);
+				data-&gt;copyInfo(image);
+				vidCache-&gt;unlockAll();
+				return 1;
+			}
+			next=vidCache-&gt;getImage(frame+1);
+			if(!next)
+			{
+				vidCache-&gt;unlockAll();
+				return 0;
+			}
+			prev=vidCache-&gt;getImage(frame-1);
+			if(!prev)
+			{
+				vidCache-&gt;unlockAll();
+				return 0;
+			}	    
+				
+
+		   			
+// now we have everything
+		int dst_pitch = _info.width,
+		src_pitch = _info.width,
+		row_size  = _info.width,
+		height    = _info.height;
+		
+ uint8_t   		*currp = YPLANE(image),
+			*prevp = YPLANE(prev),
+			*nextp = YPLANE(next);;
+	uint8_t		*destp = YPLANE(data);
+
+	// line 1 and last
+	memcpy(destp, currp, row_size);
+	memcpy(destp + dst_pitch * (height - 1),
+		currp + src_pitch * (height - 1), row_size);
+
+	// skip one line		
+	currp += src_pitch;
+	prevp += src_pitch;
+	nextp += src_pitch;
+	destp += dst_pitch;
+	
+	DoFilter_C(currp, prevp, nextp, src_pitch,
+			destp, dst_pitch, row_size, height - 2);
+	// U
+ 
+	
+	dst_pitch = _info.width&gt;&gt;1;
+	src_pitch = _info.width&gt;&gt;1;
+  row_size  = _info.width&gt;&gt;1;
+	height = _info.height&gt;&gt;1;
+	
+	currp = UPLANE(image);
+	prevp = UPLANE(prev);
+	nextp = UPLANE(next);
+	destp = UPLANE(data);;
+
+	memcpy(destp, currp, row_size);
+	memcpy(destp + dst_pitch * (height - 1),
+		currp + src_pitch * (height - 1), row_size);
+
+	currp += src_pitch;
+	prevp += src_pitch;
+	nextp += src_pitch;
+	destp += dst_pitch;
+
+		DoFilter_C(currp, prevp, nextp, src_pitch,
+			destp, dst_pitch, row_size, height - 2);
+
+	// V
+
+  plane=(_info.width*_info.height*5)&gt;&gt;2;
+	
+	dst_pitch = _info.width&gt;&gt;1;
+	src_pitch = _info.width&gt;&gt;1;
+  row_size  = _info.width&gt;&gt;1;
+	height = _info.height&gt;&gt;1;
+	
+	currp = VPLANE(image);
+	prevp = VPLANE(prev);
+	nextp = VPLANE(next);
+	destp = VPLANE(data);;
+
+	memcpy(destp, currp, row_size);
+	memcpy(destp + dst_pitch * (height - 1),
+		currp + src_pitch * (height - 1), row_size);
+
+	currp += src_pitch;
+	prevp += src_pitch;
+	nextp += src_pitch;
+	destp += dst_pitch;
+
+	#if (defined( ARCH_X86)  || defined(ARCH_X86_64)) &amp;&amp; defined(ASM_FLUX)
+        if(CpuCaps::hasMMX())
+        {
+		DoFilter_MMX(currp, prevp, nextp, src_pitch,
+			destp, dst_pitch, row_size, height - 2);
+	}else
+	#endif
+        {
+		DoFilter_C(currp, prevp, nextp, src_pitch,
+			destp, dst_pitch, row_size, height - 2);
+        }
+	
+	data-&gt;copyInfo(image);
+	vidCache-&gt;unlockAll();
+	return 1;
+}	                           
+
+
+void ADMVideoFlux::DoFilter_C(
+ uint8_t * currp, 
+ uint8_t * prevp,								  								  
+ uint8_t * nextp, 
+ int src_pitch,
+ uint8_t * destp, 
+ int dst_pitch,
+ int row_size, 
+ int height)
+{
+
+	 int skip = src_pitch - row_size + 1,
+		dskip = dst_pitch - row_size + 1;
+	int ycnt = height;
+
+	do
+	{
+		*destp = *currp; // Copy left edge
+
+		++currp;
+		++prevp;
+		++nextp;
+		++destp;
+
+		int xcnt = row_size - 2;
+
+		do
+		{
+			int pbt = *prevp++, b = *currp, nbt = *nextp++;
+			int pdiff = pbt - b, ndiff = nbt - b;
+			if((pdiff &lt; 0 &amp;&amp; ndiff &lt; 0) || (pdiff &gt; 0 &amp;&amp; ndiff &gt; 0))
+			{
+				int pb1 = currp[-src_pitch - 1], pb2 = currp[-src_pitch],
+					pb3 = currp[-src_pitch + 1], b1 = currp[-1], b2 = currp[1],
+					nb1 = currp[src_pitch - 1], nb2 = currp[src_pitch],
+					nb3 = currp[src_pitch + 1], sum = b, cnt = 1;
+
+				if(abs(pbt - b) &lt;= _param-&gt;temporal_threshold)
+				{
+					sum += pbt;
+					++cnt;
+				}
+				if(abs(nbt - b) &lt;= _param-&gt;temporal_threshold)
+				{
+					sum += nbt;
+					++cnt;
+				}
+				if(abs(pb1 - b) &lt;= _param-&gt;spatial_threshold)
+				{
+					sum += pb1;
+					++cnt;
+				}
+				if(abs(pb2 - b) &lt;= _param-&gt;spatial_threshold)
+				{
+					sum += pb2;
+					++cnt;
+				}
+				if(abs(pb3 - b) &lt;= _param-&gt;spatial_threshold)
+				{
+					sum += pb3;
+					++cnt;
+				}
+				if(abs(b1 - b) &lt;= _param-&gt;spatial_threshold)
+				{
+					sum += b1;
+					++cnt;
+				}
+				if(abs(b2 - b) &lt;= _param-&gt;spatial_threshold)
+				{
+					sum += b2;
+					++cnt;
+				}
+				if(abs(nb1 - b) &lt;= _param-&gt;spatial_threshold)
+				{
+					sum += nb1;
+					++cnt;
+				}
+				if(abs(nb2 - b) &lt;= _param-&gt;spatial_threshold)
+				{
+					sum += nb2;
+					++cnt;
+				}
+				if(abs(nb3 - b) &lt;= _param-&gt;spatial_threshold)
+				{
+					sum += nb3;
+					++cnt;
+				}
+
+				ADM_assert(sum &gt;= 0);
+				ADM_assert(sum &lt; 2806);
+				ADM_assert(cnt &gt; 0);
+				ADM_assert(cnt &lt; 12);
+
+				*destp++ = (uint8_t )(((sum * 2 + cnt) * scaletab[cnt]) &gt;&gt; 16);
+				++currp;
+			} else
+				*destp++ = *currp++;
+		} while(--xcnt);
+		ADM_assert(xcnt == 0);
+
+		*destp = *currp; // Copy right edge
+
+		currp += skip;
+		prevp += skip;
+		nextp += skip;
+		destp += dskip;
+	} while(--ycnt);
+	ADM_assert(ycnt == 0);
+
+}
+#if (defined( ARCH_X86)  || defined(ARCH_X86_64))
+/*
+	__asm movq mm2, mm0 \
+	__asm movq mm3, mm1 \
+	__asm psubusw mm2, mm1 \
+	__asm psubusw mm3, mm0 \
+	__asm por mm2, mm3				/  mm2 = abs diff  / \
+	__asm pcmpgtw mm2, threshold	/  Compare with threshold  / \
+	__asm paddw mm6, mm2			/  -1 from counter if not within  / \
+	__asm pandn mm2, mm1 \
+	__asm paddw mm5, mm2			/  Add to sum  / \
+*/
+#define CHECK_AND_ADD(threshold) &quot; movq %%mm0, %%mm2 \n\t&quot; \
+&quot;movq    %%mm1, %%mm3 \n\t&quot; \
+&quot;psubusw %%mm1, %%mm2 \n\t&quot; \
+&quot;psubusw %%mm0, %%mm3 \n\t&quot; \
+&quot;por     %%mm3, %%mm2				\n\t&quot; /* mm2 = abs diff */ \
+&quot;pcmpgtw &quot;Mangle(threshold)&quot;, %%mm2	\n\t &quot;/* Compare with threshold */ \
+&quot;paddw   %%mm2, %%mm6	\n\t	&quot;/* -1 from counter if not within */ \
+&quot;pandn   %%mm1, %%mm2 \n\t&quot; \
+&quot;paddw   %%mm2, %%mm5	\n\t&quot; /* Add to sum */ 
+
+#define EXPAND(x) { x=x+(x&lt;&lt;8)+(x&lt;&lt;16)+(x&lt;&lt;24)+(x&lt;&lt;32)+(x&lt;&lt;40) \
+										+(x&lt;&lt;48);}
+
+
+void ADMVideoFlux::DoFilter_MMX(
+uint8_t * currp, 
+ uint8_t * prevp,
+ uint8_t * nextp, 
+ int src_pitch,
+ uint8_t * destp, 
+ int dst_pitch,
+ int row_size, 
+ int height)
+{
+	  _l_xmax = row_size - 4;
+	 	ycnt 		= height;
+	
+	
+	_l_currp = currp;
+  _l_prevp = prevp;								  								  
+  _l_nextp = nextp;  
+  _l_destp = destp; 
+ 	_l_src_pitch =src_pitch;
+  _l_dst_pitch =dst_pitch;
+ 
+		_l_counter_init = 0x000b000b000b000bLL,
+		_l_indexer = 0x1000010000100001LL;
+		
+		spat_thresh = _param-&gt;spatial_threshold;
+		temp_thresh = _param-&gt;temporal_threshold;
+		EXPAND( spat_thresh);
+		EXPAND( temp_thresh);
+
+UNUSED_ARG(_l_prev_pels);
+UNUSED_ARG(_l_next_pels);
+asm(
+&quot;								 mov (%0),&quot;REG_si&quot; \n\t&quot;
+&quot;                mov &quot;Mangle(_l_currp)&quot;, &quot;REG_si&quot; \n\t&quot;
+&quot;                mov &quot;Mangle(_l_destp)&quot;, &quot;REG_di&quot; \n\t&quot;
+&quot;                pxor %%mm7,%%mm7 \n\t&quot;
+&quot; \n\t&quot;
+&quot;yloop%=:  \n\t&quot;
+&quot;                # Copy first dword \n\t&quot;
+&quot; \n\t&quot;
+&quot;                mov (&quot;REG_si&quot;),&quot;REG_ax&quot; \n\t&quot;
+&quot;                mov &quot;REG_ax&quot;,(&quot;REG_di&quot;) \n\t&quot;
+&quot; \n\t&quot;
+&quot;                mov $4,&quot;REG_cx&quot; \n\t&quot;
+&quot; \n\t&quot;
+&quot;xloop%=:  \n\t&quot;
+&quot;                # Get current pels, init sum and counter \n\t&quot;
+&quot; \n\t&quot;
+&quot;                movd (&quot;REG_si&quot;,&quot;REG_cx&quot;),%%mm0 \n\t&quot;
+&quot;                punpcklbw %%mm7,%%mm0 \n\t&quot;
+&quot;                movq %%mm0,%%mm5 \n\t&quot;
+&quot;                movq &quot;Mangle(_l_counter_init)&quot;,%%mm6 \n\t&quot;
+&quot; \n\t&quot;
+&quot;                # Middle left \n\t&quot;
+&quot; \n\t&quot;
+&quot;                movq %%mm0,%%mm1 \n\t&quot;
+&quot;                psllq $16,%%mm1 \n\t&quot;
+&quot;                movd -4(&quot;REG_si&quot;,&quot;REG_cx&quot;),%%mm2 \n\t&quot;
+&quot;                punpcklbw %%mm7,%%mm2 \n\t&quot;
+&quot;                psrlq $48,%%mm2 \n\t&quot;
+&quot;                por %%mm2,%%mm1 \n\t&quot;
+&quot; \n\t&quot;
+CHECK_AND_ADD(spat_thresh)
+&quot; \n\t&quot;
+&quot;                # Middle right \n\t&quot;
+&quot; \n\t&quot;
+&quot;                movq %%mm0,%%mm1 \n\t&quot;
+&quot;                psrlq $16,%%mm1 \n\t&quot;
+&quot;                movd 4(&quot;REG_si&quot;,&quot;REG_cx&quot;),%%mm2 \n\t&quot;
+&quot;                punpcklbw %%mm7,%%mm2 \n\t&quot;
+&quot;                psllq $48,%%mm2 \n\t&quot;
+&quot;                por %%mm2,%%mm1 \n\t&quot;
+&quot; \n\t&quot;
+CHECK_AND_ADD(spat_thresh)
+&quot; \n\t&quot;
+&quot;                # Top left \n\t&quot;
+&quot; \n\t&quot;
+&quot;                mov &quot;REG_si&quot;,&quot;REG_ax&quot; \n\t&quot;
+&quot;                sub &quot;Mangle(_l_src_pitch)&quot;, &quot;REG_ax&quot; \n\t&quot;
+&quot;                movd (&quot;REG_ax&quot;,&quot;REG_cx&quot;),%%mm1 \n\t&quot;
+&quot;                punpcklbw %%mm7,%%mm1 \n\t&quot;
+&quot;                psllq $16,%%mm1 \n\t&quot;
+&quot;                movd -4(&quot;REG_ax&quot;,&quot;REG_cx&quot;),%%mm2 \n\t&quot;
+&quot;                punpcklbw %%mm7,%%mm2 \n\t&quot;
+&quot;                psrlq $48,%%mm2 \n\t&quot;
+&quot;                por %%mm2,%%mm1 \n\t&quot;
+&quot; \n\t&quot;
+CHECK_AND_ADD(spat_thresh)
+&quot; \n\t&quot;
+&quot;                # Top centre \n\t&quot;
+&quot; \n\t&quot;
+&quot;                movd (&quot;REG_ax&quot;,&quot;REG_cx&quot;),%%mm1 \n\t&quot;
+&quot;                punpcklbw %%mm7,%%mm1 \n\t&quot;
+&quot; \n\t&quot;
+CHECK_AND_ADD(spat_thresh)
+&quot; \n\t&quot;
+&quot;                # Top right \n\t&quot;
+&quot; \n\t&quot;
+&quot;                psrlq $16,%%mm1 \n\t&quot;
+&quot;                movd 4(&quot;REG_ax&quot;,&quot;REG_cx&quot;),%%mm2 \n\t&quot;
+&quot;                punpcklbw %%mm7,%%mm2 \n\t&quot;
+&quot;                psllq $48,%%mm2 \n\t&quot;
+&quot;                por %%mm2,%%mm1 \n\t&quot;
+&quot; \n\t&quot;
+CHECK_AND_ADD(spat_thresh)
+&quot; \n\t&quot;
+&quot;                # Bottom left \n\t&quot;
+&quot; \n\t&quot;
+&quot;                mov &quot;REG_si&quot;,&quot;REG_ax&quot; \n\t&quot;
+&quot;                add &quot;Mangle(_l_src_pitch)&quot;, &quot;REG_ax&quot; \n\t&quot;
+&quot;                movd (&quot;REG_ax&quot;,&quot;REG_cx&quot;),%%mm1 \n\t&quot;
+&quot;                punpcklbw %%mm7,%%mm1 \n\t&quot;
+&quot;                psllq $16,%%mm1 \n\t&quot;
+&quot;                movd -4(&quot;REG_ax&quot;,&quot;REG_cx&quot;),%%mm2 \n\t&quot;
+&quot;                punpcklbw %%mm7,%%mm2 \n\t&quot;
+&quot;                psrlq $48,%%mm2 \n\t&quot;
+&quot;                por %%mm2,%%mm1 \n\t&quot;
+&quot; \n\t&quot;
+CHECK_AND_ADD(spat_thresh)
+&quot; \n\t&quot;
+&quot;                # Bottom centre \n\t&quot;
+&quot; \n\t&quot;
+&quot;                movd (&quot;REG_ax&quot;,&quot;REG_cx&quot;),%%mm1 \n\t&quot;
+&quot;                punpcklbw %%mm7,%%mm1 \n\t&quot;
+&quot; \n\t&quot;
+CHECK_AND_ADD(spat_thresh)
+&quot; \n\t&quot;
+&quot;                # Bottom right \n\t&quot;
+&quot; \n\t&quot;
+&quot;                psrlq $16,%%mm1 \n\t&quot;
+&quot;                movd 4(&quot;REG_ax&quot;,&quot;REG_cx&quot;),%%mm2 \n\t&quot;
+&quot;                punpcklbw %%mm7,%%mm2 \n\t&quot;
+&quot;                psllq $48,%%mm2 \n\t&quot;
+&quot;                por %%mm2,%%mm1 \n\t&quot;
+&quot; \n\t&quot;
+CHECK_AND_ADD(spat_thresh)
+&quot; \n\t&quot;
+&quot;                # Previous frame \n\t&quot;
+&quot; \n\t&quot;
+&quot;                mov &quot;Mangle(_l_prevp)&quot;, &quot;REG_ax&quot; \n\t&quot;
+&quot;                movd (&quot;REG_ax&quot;,&quot;REG_cx&quot;),%%mm1 \n\t&quot;
+&quot;                punpcklbw %%mm7,%%mm1 \n\t&quot;
+&quot;                movq %%mm1, &quot;Mangle(_l_prev_pels)&quot; \n\t&quot;
+&quot; \n\t&quot;
+CHECK_AND_ADD(temp_thresh)
+&quot; \n\t&quot;
+&quot;                # Next frame \n\t&quot;
+&quot; \n\t&quot;
+&quot;                mov &quot;Mangle(_l_nextp)&quot;, &quot;REG_ax&quot; \n\t&quot;
+&quot;                movd (&quot;REG_ax&quot;,&quot;REG_cx&quot;),%%mm1 \n\t&quot;
+&quot;                punpcklbw %%mm7,%%mm1 \n\t&quot;
+&quot;                movq %%mm1, &quot;Mangle(_l_next_pels)&quot; \n\t&quot;
+&quot; \n\t&quot;
+CHECK_AND_ADD(temp_thresh)
+&quot; \n\t&quot;
+&quot;                # Average \n\t&quot;
+&quot; \n\t&quot;
+&quot;                psllw $1,%%mm5                                  # sum *= 2 \n\t&quot;
+&quot;                paddw %%mm6,%%mm5                               # sum += count \n\t&quot;
+&quot; \n\t&quot;
+&quot;                pmaddwd &quot;Mangle(_l_indexer)&quot;,%%mm6                  # Make index into lookup \n\t&quot;
+&quot;                movq %%mm6,%%mm1 \n\t&quot;
+&quot;                punpckhdq %%mm6,%%mm6 \n\t&quot;
+&quot;                mov &quot;Mangle(scaletab_MMX)&quot;, &quot;REG_ax&quot; \n\t&quot;
+&quot;                paddd %%mm6,%%mm1 \n\t&quot;
+&quot;                movd %%mm1,&quot;REG_bx&quot; \n\t&quot;
+&quot; \n\t&quot;
+&quot;            movq (&quot;REG_ax&quot;,&quot;REG_bx&quot;,8),%%mm2          # Do lookup \n\t&quot;
+&quot;            pmulhw %%mm2,%%mm5                                  # mm5 = average \n\t&quot;
+&quot; \n\t&quot;
+&quot;                # Apply smoothing only to fluctuating pels \n\t&quot;
+&quot; \n\t&quot;
+&quot;                movq %%mm0,%%mm1 \n\t&quot;
+&quot;                movq &quot;Mangle(_l_prev_pels)&quot;,%%mm2 \n\t&quot;
+&quot;                movq %%mm0,%%mm3 \n\t&quot;
+&quot;                movq &quot;Mangle(_l_next_pels)&quot;,%%mm4 \n\t&quot;
+&quot; \n\t&quot;
+&quot;                pcmpgtw %%mm2,%%mm1                             # curr &gt; prev \n\t&quot;
+&quot;                pcmpgtw %%mm4,%%mm3                             # curr &gt; next \n\t&quot;
+&quot;                pcmpgtw %%mm0,%%mm2                             # prev &gt; curr \n\t&quot;
+&quot;                pcmpgtw %%mm0,%%mm4                             # next &gt; curr \n\t&quot;
+&quot; \n\t&quot;
+&quot;                pand %%mm3,%%mm1                                # (curr &gt; prev) and (curr &gt; next) \n\t&quot;
+&quot;                pand %%mm4,%%mm2                                # (prev &gt; curr) and (next &gt; curr) \n\t&quot;
+&quot;                por %%mm2,%%mm1                                 # mm1 = FFh if fluctuating, else 00h \n\t&quot;
+&quot; \n\t&quot;
+&quot;                movq %%mm1,%%mm2 \n\t&quot;
+&quot;                pand %%mm5,%%mm1                                # mm1 = smoothed pels \n\t&quot;
+&quot;                pandn %%mm0,%%mm2                               # mm2 = unsmoothed pels \n\t&quot;
+&quot;                por %%mm2,%%mm1                                 # mm1 = result \n\t&quot;
+&quot; \n\t&quot;
+&quot;                # Store \n\t&quot;
+&quot; \n\t&quot;
+&quot;                packuswb %%mm7,%%mm1 \n\t&quot;
+&quot;                movntq %%mm1,(&quot;REG_di&quot;,&quot;REG_cx&quot;) \n\t&quot;
+&quot; \n\t&quot;
+&quot;                # Advance \n\t&quot;
+&quot; \n\t&quot;
+&quot;                add $4,&quot;REG_cx&quot; \n\t&quot;
+&quot;                cmp &quot;Mangle(_l_xmax)&quot;, &quot;REG_cx&quot; \n\t&quot;
+&quot;                jl xloop%= \n\t&quot;
+&quot; \n\t&quot;
+&quot;                # Copy last dword \n\t&quot;
+&quot; \n\t&quot;
+&quot;                mov (&quot;REG_si&quot;,&quot;REG_cx&quot;),&quot;REG_ax&quot; \n\t&quot;
+&quot;                mov &quot;REG_ax&quot;,(&quot;REG_di&quot;,&quot;REG_cx&quot;) \n\t&quot;
+&quot; \n\t&quot;
+&quot;                # Next row \n\t&quot;
+&quot; \n\t&quot;
+&quot;                add &quot;Mangle(_l_src_pitch)&quot;, &quot;REG_si&quot; \n\t&quot;
+&quot;                mov &quot;Mangle(_l_prevp)&quot;, &quot;REG_ax&quot; \n\t&quot;
+&quot;                add &quot;Mangle(_l_src_pitch)&quot;, &quot;REG_ax&quot; \n\t&quot;
+&quot;                mov &quot;REG_ax&quot;, &quot;Mangle(_l_prevp)&quot; \n\t&quot;
+&quot;                mov &quot;Mangle(_l_nextp)&quot;, &quot;REG_bx&quot; \n\t&quot;
+&quot;                add &quot;Mangle(_l_src_pitch)&quot;, &quot;REG_bx&quot; \n\t&quot;
+&quot;                mov &quot;REG_bx&quot;, &quot;Mangle(_l_nextp)&quot; \n\t&quot;
+&quot;                add &quot;Mangle(_l_dst_pitch)&quot;, &quot;REG_di&quot; \n\t&quot;
+&quot; \n\t&quot;
+&quot;                sub $1, &quot;Mangle(ycnt)&quot; \n\t&quot;
+&quot;                jnz yloop%= \n\t&quot;
+&quot; \n\t&quot;
+//&quot;MISMATCH: &quot;                sfence&quot; \n\t&quot;
+&quot;                emms \n\t&quot;
+&quot; \n\t&quot;
+
+ : : &quot;r&quot;(_l_src_pitch) );
+}
+#endif
+//

Copied: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidFlux.h (from rev 2489, branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidFlux.h)

Copied: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidMsmooth.cpp (from rev 2489, branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidMsmooth.cpp)
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidMsmooth.cpp	2006-10-31 15:59:58 UTC (rev 2489)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidMsmooth.cpp	2007-01-09 19:54:42 UTC (rev 2697)
@@ -0,0 +1,824 @@
+/***************************************************************************
+                          ADM_vidMsmooth  -  description
+                             -------------------
+    
+    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
+
+    Port of Donal Graft MSMooth which is (c) Donald Graft
+    <A HREF="http://www.neuron2.net">http://www.neuron2.net</A>
+    <A HREF="http://puschpull.org/avisynth/decomb_reference_manual.html">http://puschpull.org/avisynth/decomb_reference_manual.html</A>
+
+ ***************************************************************************/
+/*
+	MSmooth plugin for Avisynth -- performs detail-preserving smoothing.
+
+	Copyright (C) 2003 Donald A. Graft
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program; if not, write to the Free Software
+	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*/
+
+#include &quot;config.h&quot;
+#include &lt;stdio.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;string.h&gt;
+#include &lt;ADM_assert.h&gt;
+
+#include &quot;config.h&quot;
+#include &quot;fourcc.h&quot;
+#include &quot;avio.hxx&quot;
+#include &quot;avi_vars.h&quot;
+
+#include &quot;ADM_toolkit/toolkit.hxx&quot;
+#include &quot;ADM_editor/ADM_edit.hxx&quot;
+#include &quot;ADM_video/ADM_genvideo.hxx&quot;
+#include&quot;ADM_video/ADM_vidField.h&quot;
+#include&quot;ADM_video/ADM_cache.h&quot;
+
+#include &quot;ADM_osSupport/ADM_debugID.h&quot;
+#define MODULE_NAME MODULE_FILTER
+#include &quot;ADM_osSupport/ADM_debug.h&quot;
+
+#include &quot;ADM_osSupport/ADM_cpuCap.h&quot;
+#include &quot;ADM_filter/video_filters.h&quot;
+
+#include &quot;ADM_userInterfaces/ADM_commonUI/DIA_factory.h&quot;
+
+#ifdef HAVE_ALTIVEC_H
+#include &quot;altivec.h&quot;
+#endif
+#if 0
+#undef aprintf
+#define aprintf printf
+#endif
+#define GETFRAME(g, fp) \
+{ \
+	int GETFRAMEf; \
+	GETFRAMEf = (g); \
+	if (GETFRAMEf &lt; 0) GETFRAMEf = 0; \
+	if (GETFRAMEf &gt; num_frames_hi - 1) GETFRAMEf = num_frames_hi - 1; \
+	(fp) = vidCache-&gt;getImage(GETFRAMEf); \
+}
+
+#include &quot;ADM_video/ADM_vidMSmooth_param.h&quot;
+
+extern uint8_t DIA_getMSmooth(MSMOOTH_PARAM *param);
+extern uint8_t 	PutHintingData(unsigned char *video, unsigned int hint);
+extern uint8_t 	GetHintingData(unsigned char *video, unsigned int *hint);
+extern void 	BitBlt(uint8_t * dstp, int dst_pitch, const uint8_t* srcp,
+            		int src_pitch, int row_size, int height);
+//extern  void 	DrawString(uint8_t *dst, int x, int y, const char *s);
+//extern  void    DrawString(ADMImage *dst, int x, int y, const char *s);
+//#define DrawString(a,b,c,d) DrawString(NULL,b,c,d)
+#define DrawString drawString
+
+extern  void 	DrawStringYUY2(uint8_t *dst, int x, int y, const char *s); 
+
+static void Blur_C(uint8_t *in, uint8_t *out, uint32_t w, uint32_t h) ;
+#ifdef HAVE_ALTIVEC
+void Blur_Altivec(uint8_t *in, uint8_t *out, uint32_t w, uint32_t h);
+#endif
+#if (defined( ARCH_X86)  || defined(ARCH_X86_64))
+void Blur_MMX(uint8_t *in, uint8_t *out, uint32_t w, uint32_t h);
+#endif
+class Msmooth : public AVDMGenericVideoStream
+{
+private:
+	MSMOOTH_PARAM	*_param;
+	VideoCache	*vidCache;
+	uint8_t		show, debug;
+	ADMImage 	*blur,*work,*mask,*final,*final2;
+public:    
+
+			Msmooth(AVDMGenericVideoStream *in,CONFcouple *couples)   ;
+			~Msmooth();
+    	uint8_t 	*GetFrameYV12(int n);
+	void  		SmoothingPassYV12(const unsigned char *srcp, unsigned char *maskp, unsigned char *workp,
+				unsigned char *finalp,int row_size, int height, int spitch, int dpitch);
+	void 		EdgeMaskYV12(const unsigned char *srcp, unsigned char *blurp, unsigned char *workp,
+				 unsigned char *maskp,int row_size, int height, int src_pitch, int blur_pitch);
+				 
+	char 		*printConf( void );
+	uint8_t 	configure(AVDMGenericVideoStream *in);
+	uint8_t		getCoupledConf( CONFcouple **couples);
+	uint8_t 	getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
+				ADMImage *data,uint32_t *flags);
+};
+
+BUILD_CREATE(create_msmooth,Msmooth);
+static FILTER_PARAM msmoothParam={4,{&quot;showmask&quot;, &quot;highq&quot;,&quot;threshold&quot;, &quot;strength&quot;}};
+
+
+SCRIPT_CREATE(msmooth_script,Msmooth,msmoothParam);
+//_______________________________________________
+
+Msmooth::Msmooth(AVDMGenericVideoStream *in,CONFcouple *couples)
+
+{
+	_in=in;		
+   	memcpy(&amp;_info,_in-&gt;getInfo(),sizeof(_info));    
+  	_info.encoding=1;
+	_uncompressed=NULL;		
+  	_info.encoding=1;
+	show=0;
+	debug=0;
+	_param=new MSMOOTH_PARAM;
+	//
+	if(couples)
+		{
+			GET(showmask);
+			GET(threshold);
+			GET(highq);
+			GET(strength);	
+		}
+		else // Default
+  		{
+			_param-&gt;showmask=0;
+			_param-&gt;threshold=15;
+			_param-&gt;strength=3;
+			_param-&gt;highq=1;			
+		}
+		
+	uint32_t sz=(_info.width*_info.height*3)&gt;&gt;1;
+	#define NW(x) x=new ADMImage(_info.width,_info.height);ADM_assert(x);
+	NW(blur);
+	NW(work);
+	NW(mask);
+	NW(final);
+	NW(final2);
+	
+    	vidCache=new VideoCache(5,in);
+}
+//________________________________________________________
+uint8_t	Msmooth::getCoupledConf( CONFcouple **couples)
+{
+	*couples=NULL;
+	*couples=new CONFcouple(4);
+#define CSET(x)  (*couples)-&gt;setCouple((char *)#x,(_param-&gt;x))
+	CSET(showmask);
+	CSET(threshold);
+	CSET(highq);
+	CSET(strength);	
+	
+	return 1;
+}
+//________________________________________________________
+Msmooth::~Msmooth(void)
+{
+
+	if(vidCache) delete vidCache;
+	if(_param) delete _param;
+#undef NW
+#define NW(x) if(x) {delete  x;x=NULL;}
+	NW(blur);
+	NW(work);
+	NW(mask);
+	NW(final);
+	NW(final2);
+}
+//________________________________________________________
+uint8_t Msmooth::configure(AVDMGenericVideoStream *in)
+{
+	_in=in;
+	ADM_assert(_param);
+        
+        diaElemToggle toggle(&amp;(_param-&gt;highq),&quot;High Quality&quot;);
+        diaElemToggle mask(&amp;(_param-&gt;showmask),&quot;Show Mask&quot;);
+        diaElemUInteger threshold(&amp;(_param-&gt;threshold),&quot;Threshold&quot;,0,100);
+        diaElemUInteger strength(&amp;(_param-&gt;strength),&quot;Filter Strength&quot;,0,100);
+	  
+    diaElem *elems[4]={&amp;toggle,&amp;mask,&amp;threshold,&amp;strength};
+  
+    return diaFactoryRun(&quot;MSmooth by Donald Graft&quot;,4,elems);
+}
+
+//________________________________________________________
+char *Msmooth::printConf( void )
+{
+ 	static char buf[50];
+
+	ADM_assert(_param);
+ 	sprintf((char *)buf,&quot; Donald Graft MSmooth&quot;);
+        return buf;
+}
+	
+//________________________________________________________
+uint8_t Msmooth::getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
+				ADMImage *data,uint32_t *flags)
+{
+    ADMImage *src = vidCache-&gt;getImage(frame);
+   
+    ADMImage * deliver;
+
+	const unsigned char *srcpY = YPLANE(src) ;
+	const unsigned char *srcp_savedY = srcpY;
+    	int src_pitchY = _info.width;
+	
+	const unsigned char *srcpU =UPLANE(src);
+	const unsigned char *srcp_savedU = srcpU;
+    	int src_pitchUV = _info.width&gt;&gt;1;
+	const unsigned char *srcpV =VPLANE(src);
+	const unsigned char *srcp_savedV = srcpV;
+
+    	unsigned char *blurpY = YPLANE(blur);//
+	unsigned char *blurp_savedY = blurpY;
+    	int blur_pitchY =  _info.width;
+    	unsigned char *blurpU = UPLANE(blur);
+	unsigned char *blurp_savedU = blurpU;
+    	int blur_pitchUV = _info.width&gt;&gt;1;
+    	unsigned char *blurpV = VPLANE(blur);
+	unsigned char *blurp_savedV = blurpV;
+
+    unsigned char *workpY = YPLANE(work); //-&gt;GetWritePtr(PLANAR_Y);
+	unsigned char *workp_savedY = workpY;
+    unsigned char *workpU = UPLANE(work);
+	unsigned char *workp_savedU = workpU;
+    unsigned char *workpV = VPLANE(work);
+	unsigned char *workp_savedV = workpV;
+
+    unsigned char *maskpY = YPLANE(mask); //-&gt;GetWritePtr(PLANAR_Y);
+	unsigned char *maskp_savedY = maskpY;
+    unsigned char *maskpU = UPLANE(mask);
+	unsigned char *maskp_savedU = maskpU;
+    unsigned char *maskpV = VPLANE(mask);
+	unsigned char *maskp_savedV = maskpV;
+
+    unsigned char *finalpY = YPLANE(final);//-&gt;GetWritePtr(PLANAR_Y);
+	unsigned char *finalp_savedY = finalpY;
+    unsigned char *finalpU = UPLANE(final);
+	unsigned char *finalp_savedU = finalpU;
+    unsigned char *finalpV = VPLANE(final);
+	unsigned char *finalp_savedV = finalpV;
+
+    unsigned char *finalp2Y = YPLANE(final2); //-&gt;GetWritePtr(PLANAR_Y);
+	unsigned char *finalp2_savedY = finalp2Y;
+    unsigned char *finalp2U = UPLANE(final2);
+	unsigned char *finalp2_savedU = finalp2U;
+    unsigned char *finalp2V = VPLANE(final2);
+	unsigned char *finalp2_savedV = finalp2V;
+
+    int row_sizeY = _info.width;//blur-&gt;GetRowSize(PLANAR_Y);
+    int row_sizeUV = _info.width&gt;&gt;1;//blur-&gt;GetRowSize(PLANAR_U);
+    int heightY = _info.height;//blur-&gt;GetHeight(PLANAR_Y);
+    int heightUV = _info.height&gt;&gt;1;//blur-&gt;GetHeight(PLANAR_U);
+	int y, reps;
+
+	/* Create the detail mask. */
+	EdgeMaskYV12(srcpY, blurpY, workpY, maskpY, row_sizeY, heightY, src_pitchY, blur_pitchY);
+	EdgeMaskYV12(srcpU, blurpU, workpU, maskpU, row_sizeUV, heightUV, src_pitchUV, blur_pitchUV);
+	EdgeMaskYV12(srcpV, blurpV, workpV, maskpV, row_sizeUV, heightUV, src_pitchUV, blur_pitchUV);
+
+	if (_param-&gt;showmask == true)
+	{
+		if (show == true)
+		{
+			char buf[80];
+			//env-&gt;MakeWritable(&amp;mask);
+			sprintf(buf, &quot;0.2 beta&quot;);
+			DrawString(mask, 0, 0, buf);
+			sprintf(buf, &quot;From Donald Graft&quot;);
+			DrawString(mask, 0, 1, buf);
+		}
+		//return mask;
+		memcpy(data-&gt;data,mask-&gt;data,(_info.width*_info.height*3)&gt;&gt;1);
+		data-&gt;copyInfo(src);
+		vidCache-&gt;unlockAll();
+		return 1;
+	}
+
+	/* Fix up output frame borders. */
+	srcpY = srcp_savedY;
+	finalpY = finalp_savedY;
+	finalp2Y = finalp2_savedY;
+	memcpy(finalpY, srcpY, row_sizeY);
+	memcpy(finalpY + (heightY-1)*blur_pitchY, srcpY + (heightY-1)*blur_pitchY, row_sizeY);
+	memcpy(finalp2Y, srcpY, row_sizeY);
+	memcpy(finalp2Y + (heightY-1)*blur_pitchY, srcpY + (heightY-1)*blur_pitchY, row_sizeY);
+	for (y = 0; y &lt; heightY; y++)
+	{
+		finalpY[0] = finalp2Y[0] = srcpY[0];
+		finalpY[row_sizeY-1] = finalp2Y[row_sizeY-1] = srcpY[row_sizeY-1];
+		srcpY += src_pitchY;
+		finalpY += blur_pitchY;
+		finalp2Y += blur_pitchY;
+	}
+	srcpU = srcp_savedU;
+	finalpU = finalp_savedU;
+	finalp2U = finalp2_savedU;
+	memcpy(finalpU, srcpU, row_sizeUV);
+	memcpy(finalpU + (heightUV-1)*blur_pitchUV, srcpU + (heightUV-1)*blur_pitchUV, row_sizeUV);
+	memcpy(finalp2U, srcpU, row_sizeUV);
+	memcpy(finalp2U + (heightUV-1)*blur_pitchUV, srcpU + (heightUV-1)*blur_pitchUV, row_sizeUV);
+	for (y = 0; y &lt; heightUV; y++)
+	{
+		finalpU[0] = finalp2U[0] = srcpU[0];
+		finalpU[row_sizeUV-1] = finalp2U[row_sizeUV-1] = srcpU[row_sizeUV-1];
+		srcpU += src_pitchUV;
+		finalpU += blur_pitchUV;
+		finalp2U += blur_pitchUV;
+	}
+	srcpV = srcp_savedV;
+	finalpV = finalp_savedV;
+	finalp2V = finalp2_savedV;
+	memcpy(finalpV, srcpV, row_sizeUV);
+	memcpy(finalpV + (heightUV-1)*blur_pitchUV, srcpV + (heightUV-1)*blur_pitchUV, row_sizeUV);
+	memcpy(finalp2V, srcpV, row_sizeUV);
+	memcpy(finalp2V + (heightUV-1)*blur_pitchUV, srcpV + (heightUV-1)*blur_pitchUV, row_sizeUV);
+	for (y = 0; y &lt; heightUV; y++)
+	{
+		finalpV[0] = finalp2V[0] = srcpV[0];
+		finalpV[row_sizeUV-1] = finalp2V[row_sizeUV-1] = srcpV[row_sizeUV-1];
+		srcpV += src_pitchUV;
+		finalpV += blur_pitchUV;
+		finalp2V += blur_pitchUV;
+	}
+
+	/* Masked smoothing. */
+	reps = 0;
+	SmoothingPassYV12(srcp_savedY, maskp_savedY, workp_savedY, finalp_savedY, row_sizeY, heightY, src_pitchY, blur_pitchY);
+//	env-&gt;BitBlt(finalp_savedU, blur_pitchUV, srcp_savedU, src_pitchUV, row_sizeUV, heightUV);
+//	env-&gt;BitBlt(finalp_savedV, blur_pitchUV, srcp_savedV, src_pitchUV, row_sizeUV, heightUV);
+	SmoothingPassYV12(srcp_savedU, maskp_savedU, workp_savedU, finalp_savedU, row_sizeUV, heightUV, src_pitchUV, blur_pitchUV);
+	SmoothingPassYV12(srcp_savedV, maskp_savedV, workp_savedV, finalp_savedV, row_sizeUV, heightUV, src_pitchUV, blur_pitchUV);
+	if (++reps &gt;= _param-&gt;strength)
+	{
+		deliver = final;
+		goto done;
+	}
+	while (1)
+	{
+		SmoothingPassYV12(finalp_savedY, maskp_savedY, workp_savedY, finalp2_savedY, row_sizeY, heightY, blur_pitchY, blur_pitchY);
+		SmoothingPassYV12(finalp_savedU, maskp_savedU, workp_savedU, finalp2_savedU, row_sizeUV, heightUV, blur_pitchUV, blur_pitchUV);
+		SmoothingPassYV12(finalp_savedV, maskp_savedV, workp_savedV, finalp2_savedV, row_sizeUV, heightUV, blur_pitchUV, blur_pitchUV);
+		if (++reps &gt;=  _param-&gt;strength)
+		{
+			deliver = final2;
+			goto done;
+		}
+		SmoothingPassYV12(finalp2_savedY, maskp_savedY, workp_savedY, finalp_savedY, row_sizeY, heightY, blur_pitchY, blur_pitchY);
+		SmoothingPassYV12(finalp2_savedU, maskp_savedU, workp_savedU, finalp_savedU, row_sizeUV, heightUV, blur_pitchUV, blur_pitchUV);
+		SmoothingPassYV12(finalp2_savedV, maskp_savedV, workp_savedV, finalp_savedV, row_sizeUV, heightUV, blur_pitchUV, blur_pitchUV);
+		if (++reps &gt;=  _param-&gt;strength)
+		{
+			deliver = final;
+			goto done;
+		}
+	}
+
+done:
+	if (show == true)
+	{
+		char buf[80];
+		//env-&gt;MakeWritable(&amp;deliver);
+		sprintf(buf, &quot;0.2beta&quot;);
+		DrawString(deliver, 0, 0, buf);
+		sprintf(buf, &quot;Donald Graft&quot;);
+		DrawString(deliver, 0, 1, buf);
+	}
+	memcpy(data-&gt;data,deliver-&gt;data,(_info.width*_info.height*3)&gt;&gt;1);
+	//return(deliver);
+	data-&gt;copyInfo(src);
+	vidCache-&gt;unlockAll();
+	return 1;
+}
+
+
+#ifdef HAVE_ALTIVEC
+#define vecbyte vector unsigned char
+#define vect16 vector unsigned short
+
+#define LOAD_ALIGN(dest,src) \
+		dest = (vect16)vec_ld(0, src); 
+
+//______________________
+void Blur_Altivec(uint8_t *in, uint8_t *out, uint32_t w, uint32_t h)
+{
+uint8_t *srcp,*srcpn,*srcpp;
+uint8_t *workp;
+uint32_t x,y;
+int16_t  v16[8];
+
+    vect16 pp,pc,pn,res,res2;
+	vect16 rp,rc,rn,resl;
+	vect16 zero,deux;
+	
+	uint32_t off;
+	vector unsigned char MSQ,mask;
+	zero=vec_splat_u16(0);
+	deux=vec_splat_u16(2);
+
+	srcpp = in;
+	srcp  = srcpp + w;
+	srcpn = srcp + w;
+	workp = out + w;
+	for (y = 1; y &lt; h - 1; y++)
+	{
+		for (x = 0; x &lt; (w&gt;&gt;4); x++)
+		{
+			off=x&lt;&lt;4;
+			LOAD_ALIGN(pp,srcpp+off);
+			LOAD_ALIGN(pc,srcp+off);
+			LOAD_ALIGN(pn,srcpn+off);
+			
+			aprintf(&quot;sn %vd\n&quot;,pn); 
+			aprintf(&quot;sp %vd\n&quot;,pp);
+			aprintf(&quot;sc %vd\n&quot;,pc);
+		
+			
+			rp=(vect16)vec_mergel( (vecbyte)zero,(vecbyte)pp);
+			rn=(vect16)vec_mergel( (vecbyte)zero,(vecbyte)pn);
+			rc=(vect16)vec_mergel( (vecbyte)zero,(vecbyte)pc);
+			
+			aprintf(&quot;rn %vd\n&quot;,rn); 
+			aprintf(&quot;rp %vd\n&quot;,rp);
+			aprintf(&quot;rc %vd\n&quot;,rc);
+		
+			res=vec_add(rp,rc);
+			res2=vec_add(rc,rn);
+			
+			aprintf(&quot;re %vd\n&quot;,res);
+			aprintf(&quot;r2 %vd\n&quot;,res2);
+			
+			res=vec_add(res,res2);
+			
+			resl=vec_sr(res,deux);
+			aprintf(&quot;rS %vd\n&quot;,res);
+			aprintf(&quot;r2 %vd\n&quot;,res2);
+			aprintf(&quot;rl %vd\n&quot;,resl);
+									
+			pp=(vect16)vec_mergeh( (vecbyte)zero,(vecbyte)pp);
+			pn=(vect16)vec_mergeh( (vecbyte)zero,(vecbyte)pn);
+			pc=(vect16)vec_mergeh( (vecbyte)zero,(vecbyte)pc);
+			
+			res=vec_add(pp,pc);
+			res2=vec_add(pc,pn);
+			res=vec_add(res,res2);
+			res=vec_sr(res,deux);
+			
+			aprintf(&quot;rH %vd\n&quot;,res);
+			
+			res=(vect16)vec_pack(res,resl);
+			aprintf(&quot;rF %vd\n&quot;,res);
+			
+			vec_st((vecbyte)res,0,(vector unsigned char *)(workp+off));
+			
+		}
+		srcpp += w;
+        srcp += w;
+        srcpn += w;
+        workp += w;
+    }
+	// Do it at the end as it may have been scratched
+	// due to 16 byte alignment
+	memcpy(out, in, w);
+	memcpy(out + (h-1)*w, in + (h-1)*w, w);
+	
+}
+#endif
+
+#if (defined( ARCH_X86)  || defined(ARCH_X86_64))
+//______________________
+void Blur_MMX(uint8_t *in, uint8_t *out, uint32_t w, uint32_t h)
+{
+uint8_t *srcp,*srcpn,*srcpp;
+uint8_t *workp;
+uint32_t x,y;
+uint32_t off;
+	
+	srcpp = in;
+	srcp  = srcpp + w;
+	srcpn = srcp + w;
+	workp = out + w;
+	for (y = 1; y &lt; h - 1; y++)
+	{
+		for (x =  (w&gt;&gt;3);x&gt;0; x--)
+		{
+			off=x&lt;&lt;3;
+			
+			__asm__(
+			&quot;.align 16\n&quot;
+			&quot;pxor  %%mm7,%%mm7\n&quot;
+			&quot;movq  (%0),%%mm0\n&quot;
+			&quot;movq  %%mm0,%%mm6\n&quot;
+			&quot;punpckhbw %%mm7,%%mm0\n&quot; // High part extended to 16 bits
+			&quot;punpcklbw %%mm7,%%mm6\n&quot; // low part ditto
+			
+			&quot;movq  (%1),%%mm1\n&quot;
+			&quot;movq  %%mm1,%%mm5\n&quot;
+			&quot;punpckhbw %%mm7,%%mm1\n&quot;
+			&quot;punpcklbw %%mm7,%%mm5\n&quot;
+			
+			&quot;movq  (%2),%%mm2\n&quot;
+			&quot;movq  %%mm2,%%mm4\n&quot;
+			&quot;punpckhbw %%mm7,%%mm2\n&quot;
+			&quot;punpcklbw %%mm7,%%mm4\n&quot;
+			
+			&quot;paddw %%mm1,%%mm0\n&quot;
+			&quot;paddw %%mm5,%%mm6\n&quot;
+			
+			&quot;paddw %%mm1,%%mm2\n&quot;
+			&quot;paddw %%mm5,%%mm4\n&quot;
+			
+			&quot;paddw %%mm0,%%mm2\n&quot;
+			&quot;paddw %%mm6,%%mm4\n&quot;
+			&quot;psrlw $2, %%mm4\n&quot;
+			&quot;psrlw $2, %%mm2\n&quot;
+			&quot;packuswb %%mm2,%%mm4\n&quot;
+			&quot;movq %%mm4,(%3)\n&quot; //
+			
+			: : &quot;r&quot; (srcpn+off),
+			   &quot;r&quot; (srcp+off), &quot;r&quot; (srcpp+off), &quot;r&quot; (workp+off)
+			);
+			
+		}
+		workp[0]=srcp[0];
+		workp[w-1]=srcp[w-1];
+		srcpp += w;
+        	srcp += w;
+        	srcpn += w;
+        	workp += w;
+    }
+	// Do it at the end as it may have been scratched
+	// due to 16 byte alignment
+	memcpy(out, in, w);
+	memcpy(out + (h-1)*w, in + (h-1)*w, w);
+	__asm__ (&quot;emms\n&quot; : :);
+	
+}
+#endif
+
+//______________________
+void Blur_C(uint8_t *in, uint8_t *out, uint32_t w, uint32_t h)
+{
+uint8_t *srcp,*srcpn,*srcpp;
+uint8_t *workp;
+uint32_t x,y;
+	srcpp = in;
+	srcp  = srcpp + w;
+	srcpn = srcp + w;
+	workp = out + w;
+	memcpy(out, in, w);
+	memcpy(out + (h-1)*w, in + (h-1)*w, w);
+	for (y = 1; y &lt; h - 1; y++)
+	{
+		workp[0] = srcp[0];
+		workp[w-1] = srcp[w-1];
+        for (x = 1; x &lt; w - 1; x++)
+		{
+			workp[x] = (srcpp[x] + srcp[x] + srcpn[x]) /3;
+		}
+        srcpp += w;
+        srcp += w;
+        srcpn += w;
+        workp += w;
+    }
+
+}
+//_______________________________
+void  Msmooth::EdgeMaskYV12(const unsigned char *srcp, unsigned char *blurp, unsigned char *workp, unsigned char *maskp,
+                        int row_size, int height, int src_pitch, int blur_pitch)
+{
+	const unsigned char *srcp_saved = srcp;
+	const unsigned char *srcpp;
+	const unsigned char *srcpn;
+
+	unsigned char *blurp_saved = blurp;
+	const unsigned char *blurpn;
+
+	unsigned char *workp_saved = workp;
+	unsigned char *workpp;
+	unsigned char *workpn;
+
+	unsigned char *maskp_saved = maskp;
+	int x, y;
+	int y1, y2, y3, y4;
+
+	/* Blur the source image prior to detail detection. */
+#if (defined( ARCH_X86)  || defined(ARCH_X86_64))
+		//printf(&quot;MMX\n&quot;);
+	if(CpuCaps::hasMMX())
+	{
+		Blur_MMX((uint8_t *)srcp,(uint8_t *)workp,row_size,height);
+		Blur_MMX((uint8_t *)workp,(uint8_t *)blurp,row_size,height);
+	}
+	else
+	#endif
+	#ifdef HAVE_ALTIVEC
+	#define ISALIGNED(x) (!( ((long long)x)&amp;15 ))
+		if( ISALIGNED(srcp) &amp;&amp; ISALIGNED(blurp) &amp;&amp; ISALIGNED(workp) &amp;&amp; ISALIGNED(maskp) &amp;&amp; !(src_pitch&amp;15))
+		{
+			Blur_Altivec((uint8_t *)srcp,(uint8_t *)workp,row_size,height);
+			Blur_Altivec((uint8_t *)workp,(uint8_t *)blurp,row_size,height);
+		}
+		else
+	#endif
+	{
+		Blur_C((uint8_t *)srcp,(uint8_t *)workp,row_size,height);
+		Blur_C((uint8_t *)workp,(uint8_t *)blurp,row_size,height);
+	}
+	/* Diagonal detail detection. */
+	blurp = (unsigned char *) workp_saved;
+	blurpn = blurp + blur_pitch;
+	maskp = maskp_saved;
+	y1 = blurp[0];
+	y3 = blurpn[0];
+	for (y = 0; y &lt; height - 1; y++) 
+	{
+		for (x = 0; x &lt; row_size - 1; x++)
+		{
+			y2 = blurp[x+1];
+			y4 = blurpn[x+1];
+			if ((abs(y1 - y4) &gt;= _param-&gt;threshold) || (abs(y2 - y3) &gt;= _param-&gt;threshold))
+			{
+				maskp[x] = 0xff;
+			}
+			else
+			{
+				maskp[x] = 0x0;
+			}
+			y1 = y2; y3 = y4;
+		}
+		maskp += blur_pitch;
+		blurp += blur_pitch;
+		blurpn += blur_pitch;
+	}
+
+	/* If set for high quality, also do horizontal and vertical
+	   detail detection. */
+	if ( _param-&gt;highq == true)
+	{
+		/* Msmooth convolve vertical. */
+		for (x = 0; x &lt; row_size; x++)
+		{
+ 			blurp = blurp_saved;
+			blurpn = blurp + blur_pitch;
+			maskp = maskp_saved;
+			y1 = blurp[x];
+			for (y = 0; y &lt; height - 1; y++)
+			{
+				y2 = blurpn[x];
+				if (abs(y1 - y2) &gt;= _param-&gt;threshold)
+				{
+					maskp[x] = 0xff;
+				}
+				y1 = y2;
+				maskp += blur_pitch;
+				blurp += blur_pitch;
+				blurpn += blur_pitch;
+			}
+		}
+
+		/* Msmooth convolve horizontal. */
+		blurp = blurp_saved;
+		maskp = maskp_saved;
+		for (y = 0; y &lt; height; y++)
+		{
+			y1 = blurp[0];
+			for (x = 0; x &lt; row_size - 1; x++)
+			{
+				y2 = blurp[x+1];
+				if (abs(y1 - y2) &gt;= _param-&gt;threshold)
+				{
+					maskp[x] = 0xff;
+				}
+				y1 = y2;
+			}
+			maskp += blur_pitch;
+			blurp += blur_pitch;
+		}
+
+	}
+	/* Fix up detail map borders. */
+	maskp = maskp_saved;
+	memset(maskp, 0xff, row_size);
+	memset(maskp + (height-1)*blur_pitch, 0xff, row_size);
+	for (y = 0; y &lt; height; y++)
+	{
+//		*((unsigned int *)(&amp;maskp[0])) = 0xffffffff;
+//		*((unsigned int *)(&amp;maskp[row_size-1])) = 0xffffffff;
+		maskp[0] = 0xff;
+		maskp[row_size-1] = 0xff;
+		maskp += blur_pitch;
+	}
+}
+
+void  Msmooth::SmoothingPassYV12(const unsigned char *srcp, unsigned char *maskp,
+									  unsigned char *workp, unsigned char *finalp,
+									  int row_size, int height, int spitch, int dpitch)
+{
+	const unsigned char *srcp_saved = srcp;
+	const unsigned char *srcpp;
+	const unsigned char *srcpn;
+
+	unsigned char *workp_saved = workp;
+	unsigned char *workpp;
+	unsigned char *workpn;
+
+	unsigned char *maskp_saved = maskp;
+	unsigned char *maskpp;
+	unsigned char *maskpn;
+
+	unsigned char *finalp_saved = finalp;
+
+	int x, y, ysum;
+
+	srcpp = srcp_saved;
+ 	srcp = srcpp + spitch;
+	srcpn = srcp + spitch;
+	maskpp = maskp_saved;
+ 	maskp = maskpp + dpitch;
+	maskpn = maskp + dpitch;
+	workp = workp_saved + dpitch;
+	memcpy(workp_saved, srcp_saved, row_size);
+	memcpy(workp_saved + (height-1)*dpitch, srcp_saved + (height-1)*spitch, row_size);
+	for (y = 1; y &lt; height - 1; y++)
+	{
+		workp[0] = srcp[0];
+		workp[row_size-1] = srcp[row_size-1];
+        for (x = 1; x &lt; row_size - 1; x++)
+		{
+			int count = 1;
+
+			if (!maskp[x])
+			{
+				ysum = srcp[x];
+				if (!maskpp[x])
+				{
+					ysum += srcpp[x];
+					count++;
+				}
+				if (!maskpn[x])
+				{
+					ysum += srcpn[x];
+					count++;
+				}
+				workp[x] = ysum / count;
+			}
+		}
+        srcpp += spitch;
+        srcp += spitch;
+        srcpn += spitch;
+ 		maskpp += dpitch;
+		maskp += dpitch;
+		maskpn += dpitch;
+        workp += dpitch;
+    }
+	srcpp = srcp_saved;
+ 	srcp = srcpp + spitch;
+	srcpn = srcp + spitch;
+	workpp = workp_saved;
+ 	workp = workpp + dpitch;
+	workpn = workp + dpitch;
+	maskpp = maskp_saved;
+ 	maskp = maskpp + dpitch;
+	maskpn = maskp + dpitch;
+	finalp = finalp_saved + dpitch;
+	for (y = 1; y &lt; height - 1; y++)
+	{
+        for (x = 1; x &lt; row_size - 1; x++)
+		{
+			int count = 1;
+
+			if (!maskp[x])
+			{
+				ysum = workp[x];
+				if (!maskp[x-1])
+				{
+					ysum += workp[x-1];
+					count++;
+				}
+				if (!maskp[x+1])
+				{
+					ysum += workp[x+1];
+					count++;
+				}
+				finalp[x] = ysum / count;
+			}
+			else
+			{
+				finalp[x] = srcp[x];
+			}
+		}
+        srcpp += spitch;
+        srcp += spitch;
+        srcpn += spitch;
+        workpp += dpitch;
+        workp += dpitch;
+        workpn += dpitch;
+ 		maskpp += dpitch;
+		maskp += dpitch;
+		maskpn += dpitch;
+        finalp += dpitch;
+    }
+}
+

Added: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/Makefile.am
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/Makefile.am	2007-01-08 21:29:24 UTC (rev 2696)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/Makefile.am	2007-01-09 19:54:42 UTC (rev 2697)
@@ -0,0 +1,20 @@
+####### kdevelop will overwrite this part!!! (begin)##########
+noinst_LIBRARIES = libADM_videoFilter.a
+
+## INCLUDES were found outside kdevelop specific part
+
+libADM_videoFilter_a_METASOURCES = AUTO
+#INCLUDES = $(all_includes) 
+
+libADM_videoFilter_a_SOURCES =  \
+ ADM_vidBSmear.cpp \
+ ADM_vidAddBorder.cpp \
+ ADM_vidFlux.cpp \
+ ADM_vidMsmooth.cpp \
+ ADM_vidFastConvolution.cpp 
+			
+
+
+####### kdevelop will overwrite this part!!! (end)############
+INCLUDES = $(all_includes) -I../ADM_libraries -I../ADM_libraries/ADM_utilities -I../ADM_libraries/ADM_lavutil \
+			 $(FREETYPE_CFLAGS) $(ALTIVEC_SWITCH) -I../ADM_userInterfaces/ADM_commonUI -I../ADM_inputs -I../ADM_video

Modified: branches/avidemux_2.4_branch/avidemux/Makefile.am
===================================================================
--- branches/avidemux_2.4_branch/avidemux/Makefile.am	2007-01-08 21:29:24 UTC (rev 2696)
+++ branches/avidemux_2.4_branch/avidemux/Makefile.am	2007-01-09 19:54:42 UTC (rev 2697)
@@ -27,11 +27,13 @@
 		
 user_interface_cli = ./ADM_userInterfaces/ADM_NONE/ADM_gui2/libADM_gui2.a	\
 		./ADM_userInterfaces/ADM_NONE/ADM_dialog/libADM_dialog.a	\
+		./ADM_userInterfaces/ADM_NONE/ADM_dialogFactory/libADM_dialogFactory.a	\
 		./ADM_userInterfaces/ADM_NONE/ADM_filters/libADM_filters.a 
 		
 		
 user_interface_qt4 = 	./ADM_userInterfaces/ADM_QT4/ADM_gui/libADM_gui2.a	\
 			./ADM_userInterfaces/ADM_QT4/ADM_dialog/libADM_dialog.a	\
+			./ADM_userInterfaces/ADM_QT4/ADM_dialogFactory/libADM_dialogFactory.a	\
 			./ADM_userInterfaces/ADM_commonUI/libADM_CommonUI.a	\
 			./ADM_userInterfaces/ADM_QT4/ADM_filters/libADM_filters.a 
 
@@ -51,7 +53,7 @@
 
 SUBDIRS = ADM_libraries ADM_audio ADM_audiocodec ADM_audiofilter ADM_codecs \
 	ADM_colorspace ADM_editor ADM_encoder ADM_filter  \
-	ADM_toolkit xpm ADM_video ADM_audiodevice \
+	ADM_toolkit xpm ADM_video ADM_videoFilter ADM_audiodevice \
 	\
 	ADM_requant \
 	ADM_script ADM_ocr \
@@ -79,6 +81,7 @@
 ./ADM_audio/libADM_audio.a				\
 ./ADM_script/libADM_script.a				\
 ./ADM_video/libADM_video.a				\
+./ADM_videoFilter/libADM_videoFilter.a			\
 ./ADM_colorspace/libADM_colorspace.a			\
 ./ADM_audiodevice/libADM_audiodevice.a			\
 ./ADM_ocr/libADM_ocr.a					\


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000024.html">[Avidemux-svn-commit] r2696 - in	branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces:	ADM_NONE ADM_NONE/ADM_dialogFactory ADM_QT4	ADM_QT4/ADM_dialogFactory
</A></li>
	<LI>Next message: <A HREF="000026.html">[Avidemux-svn-commit] r2698 -	branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialogFactory
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#25">[ date ]</a>
              <a href="thread.html#25">[ thread ]</a>
              <a href="subject.html#25">[ subject ]</a>
              <a href="author.html#25">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">More information about the Avidemux-svn-commit
mailing list</a><br>
</body></html>
