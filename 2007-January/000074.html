<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Avidemux-svn-commit] r2747 -	branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/avidemux-svn-commit/2007-January/index.html" >
   <LINK REL="made" HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r2747%20-%0A%09branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat&In-Reply-To=%3C200701211804.l0LI4UkP030166%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000073.html">
   <LINK REL="Next"  HREF="000075.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Avidemux-svn-commit] r2747 -	branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat</H1>
    <B>mean at BerliOS</B> 
    <A HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r2747%20-%0A%09branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat&In-Reply-To=%3C200701211804.l0LI4UkP030166%40sheep.berlios.de%3E"
       TITLE="[Avidemux-svn-commit] r2747 -	branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat">mean at mail.berlios.de
       </A><BR>
    <I>Sun Jan 21 19:04:30 CET 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="000073.html">[Avidemux-svn-commit] r2746 - in	branches/avidemux_2.4_branch/avidemux:	ADM_inputs/ADM_mpegdemuxer ADM_toolkit	ADM_userInterfaces/ADM_GTK/ADM_dialog	ADM_userInterfaces/ADM_NONE/ADM_dialog	ADM_userInterfaces/ADM_QT4/ADM_dialog	ADM_userInterfaces/ADM_commonUI
</A></li>
        <LI>Next message: <A HREF="000075.html">[Avidemux-svn-commit] r2748 -	branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#74">[ date ]</a>
              <a href="thread.html#74">[ thread ]</a>
              <a href="subject.html#74">[ subject ]</a>
              <a href="author.html#74">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: mean
Date: 2007-01-21 19:04:24 +0100 (Sun, 21 Jan 2007)
New Revision: 2747

Modified:
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/ADM_lavformat.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/Makefile.am
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/avformat.h
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/avi.h
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/avienc.c
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/avio.c
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/avio.h
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/aviobuf.c
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/cutils.c
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/file.c
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/img2.c
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/isom.c
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/isom.h
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/matroska.c
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/mov.c
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/movenc.c
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/mpeg.c
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/mpegts.h
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/mpegtsenc.c
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/riff.h
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/rtp.h
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/rtsp.h
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/rtspcodes.h
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/utils.c
   branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/wav.c
Log:
update to ffmpeg svn

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/ADM_lavformat.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/ADM_lavformat.cpp	2007-01-20 15:15:58 UTC (rev 2746)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/ADM_lavformat.cpp	2007-01-21 18:04:24 UTC (rev 2747)
@@ -159,8 +159,8 @@
                 case MUXER_PSP:
                         strcpy(oc-&gt;title,&quot;Avidemux&quot;);
                         strcpy(oc-&gt;author,&quot;Avidemux&quot;);
-                        c-&gt;sample_aspect_ratio.num=4;
-                        c-&gt;sample_aspect_ratio.den=3;
+                        c-&gt;sample_aspect_ratio.num=1;
+                        c-&gt;sample_aspect_ratio.den=1;
                         if(isMpeg4Compatible(info-&gt;fcc))
                         {
                                 c-&gt;codec_id = CODEC_ID_MPEG4;
@@ -191,8 +191,8 @@
                         }
                         if(MUXER_PSP==_type)
                         {
-                            c-&gt;rc_buffer_size=8*1024*224;
-                            c-&gt;rc_max_rate=768*1000;
+                            c-&gt;rc_buffer_size=0; //8*1024*224;
+                            c-&gt;rc_max_rate=0; //768*1000;
                             c-&gt;rc_min_rate=0;
                             c-&gt;bit_rate=768*1000;
                         }
@@ -438,7 +438,7 @@
             pkt.data= buf;
             pkt.size= len;
             pkt.stream_index=1;
-
+            //pkt.duration=pkt.dts-_lastAudioDts; // Duration
             aprintf(&quot;A: sample: %d frame_pts: %d fq: %d\n&quot;,(int32_t )sample,(int32_t )pkt.dts,audio_st-&gt;codec-&gt;sample_rate); 
 
             ret = av_write_frame(oc, &amp;pkt);
@@ -589,7 +589,7 @@
 extern AVInputFormat matroska_demuxer;
 uint8_t lavformat_init(void)
 {
-                mpegps_init();
+//                mpegps_init();
                 movenc_init();
                 av_register_input_format(&amp;matroska_demuxer);
                 register_protocol(&amp;file_protocol);

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/Makefile.am
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/Makefile.am	2007-01-20 15:15:58 UTC (rev 2746)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/Makefile.am	2007-01-21 18:04:24 UTC (rev 2747)
@@ -6,13 +6,13 @@
 
 libADM_lavformat_a_SOURCES =  mpeg.c utils.c avio.c ADM_lavformat.cpp \
 aviobuf.c cutils.c img2.c file.c mpegtsenc.c ADM_muxts.cpp movenc.c \
-avienc.c wav.c mov.c matroska.c isom.c isom.h
+avienc.c wav.c mov.c matroska.c isom.c isom.h riff.c
 
 
 EXTRA_DIST = ADM_lavformat.cpp  ADM_muxts.cpp  avformat.h  avio.h   \
 mpegts.h  rtp.h   rtspcodes.h \
 ADM_lavformat.h    ADM_tscrc.h    avi.h       mov.h   riff.h    rtsp.h \
-isom.c isom.h
+isom.c isom.h riff.c
 
 
 ####### kdevelop will overwrite this part!!! (end)############

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/avformat.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/avformat.h	2007-01-20 15:15:58 UTC (rev 2746)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/avformat.h	2007-01-21 18:04:24 UTC (rev 2747)
@@ -1,3 +1,23 @@
+/*
+ * copyright (c) 2001 Fabrice Bellard
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
 #ifndef AVFORMAT_H
 #define AVFORMAT_H
 
@@ -5,28 +25,20 @@
 extern &quot;C&quot; {
 #endif
 
-#define LIBAVFORMAT_VERSION_INT ((50&lt;&lt;16)+(4&lt;&lt;8)+0)
-#define LIBAVFORMAT_VERSION     50.4.0
+#define LIBAVFORMAT_VERSION_INT ((51&lt;&lt;16)+(8&lt;&lt;8)+0)
+#define LIBAVFORMAT_VERSION     51.8.0
 #define LIBAVFORMAT_BUILD       LIBAVFORMAT_VERSION_INT
 
 #define LIBAVFORMAT_IDENT       &quot;Lavf&quot; AV_STRINGIFY(LIBAVFORMAT_VERSION)
 
 #include &lt;time.h&gt;
 #include &lt;stdio.h&gt;  /* FILE */
-#include &quot;../ADM_lavcodec/avcodec.h&quot;
+#include &quot;avcodec.h&quot;
 
 #include &quot;avio.h&quot;
 
 /* packet functions */
 
-#ifndef MAXINT64
-#define MAXINT64 int64_t_C(0x7fffffffffffffff)
-#endif
-
-#ifndef MININT64
-#define MININT64 int64_t_C(0x8000000000000000)
-#endif
-
 typedef struct AVPacket {
     int64_t pts;                            ///&lt; presentation time stamp in time_base units
     int64_t dts;                            ///&lt; decompression time stamp in time_base units
@@ -79,15 +91,13 @@
    is assumed to be such as 0 &lt;= num &lt; den */
 typedef struct AVFrac {
     int64_t val, num, den;
-} AVFrac;
+} AVFrac attribute_deprecated;
 
-void av_frac_init(AVFrac *f, int64_t val, int64_t num, int64_t den);
-void av_frac_add(AVFrac *f, int64_t incr);
-void av_frac_set(AVFrac *f, int64_t val);
-
 /*************************************************/
 /* input/output formats */
 
+struct AVCodecTag;
+
 struct AVFormatContext;
 
 /* this structure contains the data a format has to probe a file */
@@ -97,7 +107,7 @@
     int buf_size;
 } AVProbeData;
 
-#define AVPROBE_SCORE_MAX 100
+#define AVPROBE_SCORE_MAX 100               ///&lt; max score, half of that is used for file extension based detection
 
 typedef struct AVFormatParameters {
     AVRational time_base;
@@ -106,7 +116,6 @@
     int width;
     int height;
     enum PixelFormat pix_fmt;
-    struct AVImageFormat *image_format;
     int channel; /* used to select dv channel */
     const char *device; /* video, audio or DV device */
     const char *standard; /* tv standard, NTSC, PAL, SECAM */
@@ -116,16 +125,19 @@
                                   mpeg2ts_raw is TRUE */
     int initial_pause:1;       /* do not begin to play the stream
                                   immediately (RTSP only) */
+    int prealloced_context:1;
     enum CodecID video_codec_id;
     enum CodecID audio_codec_id;
 } AVFormatParameters;
 
-#define AVFMT_NOFILE        0x0001 /* no file should be opened */
+//! demuxer will use url_fopen, no opened file should be provided by the caller
+#define AVFMT_NOFILE        0x0001
 #define AVFMT_NEEDNUMBER    0x0002 /* needs '%d' in filename */
 #define AVFMT_SHOW_IDS      0x0008 /* show format stream IDs numbers */
 #define AVFMT_RAWPICTURE    0x0020 /* format wants AVPicture structure for
                                       raw picture data */
 #define AVFMT_GLOBALHEADER  0x0040 /* format wants global header */
+#define AVFMT_NOTIMESTAMPS  0x0080 /* format doesnt need / has any timestamps */
 
 typedef struct AVOutputFormat {
     const char *name;
@@ -145,6 +157,13 @@
     /* currently only used to set pixel format if not YUV420P */
     int (*set_parameters)(struct AVFormatContext *, AVFormatParameters *);
     int (*interleave_packet)(struct AVFormatContext *, AVPacket *out, AVPacket *in, int flush);
+
+    /**
+     * list of supported codec_id-codec_tag pairs, ordered by &quot;better choice first&quot;
+     * the arrays are all CODEC_ID_NONE terminated
+     */
+    const struct AVCodecTag *codec_tag[4];
+
     /* private fields */
     struct AVOutputFormat *next;
 } AVOutputFormat;
@@ -200,6 +219,8 @@
        (RTSP) */
     int (*read_pause)(struct AVFormatContext *);
 
+    const struct AVCodecTag *codec_tag[4];
+
     /* private fields */
     struct AVInputFormat *next;
 } AVInputFormat;
@@ -219,6 +240,9 @@
     AVCodecContext *codec; /* codec context */
     /**
      * real base frame rate of the stream.
+     * this is the lowest framerate with which all timestamps can be
+     * represented accurately (its the least common multiple of all
+     * framerates in the stream), Note, this value is just a guess!
      * for example if the timebase is 1/90000 and all frames have either
      * approximately 3600 or 1800 timer ticks then r_frame_rate will be 50/1
      */
@@ -265,9 +289,12 @@
     AVIndexEntry *index_entries; /* only used if the format does not
                                     support seeking natively */
     int nb_index_entries;
-    int index_entries_allocated_size;
+    unsigned int index_entries_allocated_size;
 
     int64_t nb_frames;                 ///&lt; number of frames in this stream if known or 0
+
+#define MAX_REORDER_DELAY 4
+    int64_t pts_buffer[MAX_REORDER_DELAY+1];
 } AVStream;
 
 #define AVFMTCTX_NOHEADER      0x0001 /* signal that no header is present
@@ -283,7 +310,7 @@
     struct AVOutputFormat *oformat;
     void *priv_data;
     ByteIOContext pb;
-    int nb_streams;
+    unsigned int nb_streams;
     AVStream *streams[MAX_STREAMS];
     char filename[1024]; /* input or output filename */
     /* stream info */
@@ -341,6 +368,11 @@
 
     int flags;
 #define AVFMT_FLAG_GENPTS       0x0001 ///&lt; generate pts if missing even if it requires parsing future frames
+#define AVFMT_FLAG_IGNIDX       0x0002 ///&lt; ignore index
+
+    int loop_input;
+    /* decoding: size of data to probe; encoding unused */
+    unsigned int probesize;
 } AVFormatContext;
 
 typedef struct AVPacketList {
@@ -351,235 +383,15 @@
 extern AVInputFormat *first_iformat;
 extern AVOutputFormat *first_oformat;
 
-/* still image support */
-struct AVInputImageContext;
-typedef struct AVInputImageContext AVInputImageContext;
-
-typedef struct AVImageInfo {
-    enum PixelFormat pix_fmt; /* requested pixel format */
-    int width; /* requested width */
-    int height; /* requested height */
-    int interleaved; /* image is interleaved (e.g. interleaved GIF) */
-    AVPicture pict; /* returned allocated image */
-} AVImageInfo;
-
-/* AVImageFormat.flags field constants */
-#define AVIMAGE_INTERLEAVED 0x0001 /* image format support interleaved output */
-
-typedef struct AVImageFormat {
-    const char *name;
-    const char *extensions;
-    /* tell if a given file has a chance of being parsing by this format */
-    int (*img_probe)(AVProbeData *);
-    /* read a whole image. 'alloc_cb' is called when the image size is
-       known so that the caller can allocate the image. If 'allo_cb'
-       returns non zero, then the parsing is aborted. Return '0' if
-       OK. */
-    int (*img_read)(ByteIOContext *,
-                    int (*alloc_cb)(void *, AVImageInfo *info), void *);
-    /* write the image */
-    int supported_pixel_formats; /* mask of supported formats for output */
-    int (*img_write)(ByteIOContext *, AVImageInfo *);
-    int flags;
-    struct AVImageFormat *next;
-} AVImageFormat;
-
-void av_register_image_format(AVImageFormat *img_fmt);
-AVImageFormat *av_probe_image_format(AVProbeData *pd);
-AVImageFormat *guess_image_format(const char *filename);
 enum CodecID av_guess_image2_codec(const char *filename);
-int av_read_image(ByteIOContext *pb, const char *filename,
-                  AVImageFormat *fmt,
-                  int (*alloc_cb)(void *, AVImageInfo *info), void *opaque);
-int av_write_image(ByteIOContext *pb, AVImageFormat *fmt, AVImageInfo *img);
 
-extern AVImageFormat *first_image_format;
-
-extern AVImageFormat pnm_image_format;
-extern AVImageFormat pbm_image_format;
-extern AVImageFormat pgm_image_format;
-extern AVImageFormat ppm_image_format;
-extern AVImageFormat pam_image_format;
-extern AVImageFormat pgmyuv_image_format;
-extern AVImageFormat yuv_image_format;
-#ifdef CONFIG_ZLIB
-extern AVImageFormat png_image_format;
-#endif
-extern AVImageFormat jpeg_image_format;
-extern AVImageFormat gif_image_format;
-extern AVImageFormat sgi_image_format;
-
 /* XXX: use automatic init with either ELF sections or C file parser */
 /* modules */
 
-/* mpeg.c */
-extern AVInputFormat mpegps_demux;
-int mpegps_init(void);
-
-/* mpegts.c */
-extern AVInputFormat mpegts_demux;
-int mpegts_init(void);
-
-/* rm.c */
-int rm_init(void);
-
-/* crc.c */
-int crc_init(void);
-
-/* img.c */
-int img_init(void);
-
-/* img2.c */
-int img2_init(void);
-
-/* asf.c */
-int asf_init(void);
-
-/* avienc.c */
-int avienc_init(void);
-
-/* avidec.c */
-int avidec_init(void);
-
-/* swf.c */
-int swf_init(void);
-
-/* mov.c */
-int mov_init(void);
-
-/* movenc.c */
-int movenc_init(void);
-
-/* flvenc.c */
-int flvenc_init(void);
-
-/* flvdec.c */
-int flvdec_init(void);
-
-/* jpeg.c */
-int jpeg_init(void);
-
-/* gif.c */
-int gif_init(void);
-
-/* au.c */
-int au_init(void);
-
-/* amr.c */
-int amr_init(void);
-
-/* wav.c */
-int ff_wav_init(void);
-
-/* mmf.c */
-int ff_mmf_init(void);
-
-/* raw.c */
-int pcm_read_seek(AVFormatContext *s,
-                  int stream_index, int64_t timestamp, int flags);
-int raw_init(void);
-
-/* mp3.c */
-int mp3_init(void);
-
-/* yuv4mpeg.c */
-int yuv4mpeg_init(void);
-
-/* ogg2.c */
-int ogg_init(void);
-
-/* ogg.c */
-int libogg_init(void);
-
-/* dv.c */
-int ff_dv_init(void);
-
-/* ffm.c */
-int ffm_init(void);
-
-/* rtsp.c */
-extern AVInputFormat redir_demux;
-int redir_open(AVFormatContext **ic_ptr, ByteIOContext *f);
-
-/* 4xm.c */
-int fourxm_init(void);
-
-/* psxstr.c */
-int str_init(void);
-
-/* idroq.c */
-int roq_init(void);
-
-/* ipmovie.c */
-int ipmovie_init(void);
-
-/* nut.c */
-int nut_init(void);
-
-/* wc3movie.c */
-int wc3_init(void);
-
-/* westwood.c */
-int westwood_init(void);
-
-/* segafilm.c */
-int film_init(void);
-
-/* idcin.c */
-int idcin_init(void);
-
-/* flic.c */
-int flic_init(void);
-
-/* sierravmd.c */
-int vmd_init(void);
-
-/* matroska.c */
-int matroska_init(void);
-
-/* sol.c */
-int sol_init(void);
-
-/* electronicarts.c */
-int ea_init(void);
-
-/* nsvdec.c */
-int nsvdec_init(void);
-
-/* daud.c */
-int daud_init(void);
-
-/* nuv.c */
-int nuv_init(void);
-
-/* aiff.c */
-int ff_aiff_init(void);
-
-/* voc.c */
-int voc_init(void);
-
-/* tta.c */
-int tta_init(void);
-
-/* adts.c */
-int ff_adts_init(void);
-
-/* mm.c */
-int mm_init(void);
-
-/* avs.c */
-int avs_init(void);
-
-/* smacker.c */
-int smacker_init(void);
-
 #include &quot;rtp.h&quot;
 
 #include &quot;rtsp.h&quot;
 
-/* yuv4mpeg.c */
-extern AVOutputFormat yuv4mpegpipe_oformat;
-
 /* utils.c */
 void av_register_input_format(AVInputFormat *format);
 void av_register_output_format(AVOutputFormat *format);
@@ -595,19 +407,10 @@
 
 void av_register_all(void);
 
-typedef struct FifoBuffer {
-    uint8_t *buffer;
-    uint8_t *rptr, *wptr, *end;
-} FifoBuffer;
+/* codec tag &lt;-&gt; codec id */
+enum CodecID av_codec_get_id(const struct AVCodecTag *tags[4], unsigned int tag);
+unsigned int av_codec_get_tag(const struct AVCodecTag *tags[4], enum CodecID id);
 
-int fifo_init(FifoBuffer *f, int size);
-void fifo_free(FifoBuffer *f);
-int fifo_size(FifoBuffer *f, uint8_t *rptr);
-int fifo_read(FifoBuffer *f, uint8_t *buf, int buf_size, uint8_t **rptr_ptr);
-void fifo_write(FifoBuffer *f, uint8_t *buf, int size, uint8_t **wptr_ptr);
-int put_fifo(ByteIOContext *pb, FifoBuffer *f, int buf_size, uint8_t **rptr_ptr);
-void fifo_realloc(FifoBuffer *f, unsigned int size);
-
 /* media file input */
 AVInputFormat *av_find_input_format(const char *short_name);
 AVInputFormat *av_probe_input_format(AVProbeData *pd, int is_opened);
@@ -649,12 +452,15 @@
 int av_add_index_entry(AVStream *st,
                        int64_t pos, int64_t timestamp, int size, int distance, int flags);
 int av_seek_frame_binary(AVFormatContext *s, int stream_index, int64_t target_ts, int flags);
+void av_update_cur_dts(AVFormatContext *s, AVStream *ref_st, int64_t timestamp);
+int64_t av_gen_search(AVFormatContext *s, int stream_index, int64_t target_ts, int64_t pos_min, int64_t pos_max, int64_t pos_limit, int64_t ts_min, int64_t ts_max, int flags, int64_t *ts_ret, int64_t (*read_timestamp)(struct AVFormatContext *, int , int64_t *, int64_t ));
 
 /* media file output */
 int av_set_parameters(AVFormatContext *s, AVFormatParameters *ap);
 int av_write_header(AVFormatContext *s);
 int av_write_frame(AVFormatContext *s, AVPacket *pkt);
 int av_interleaved_write_frame(AVFormatContext *s, AVPacket *pkt);
+int av_interleave_packet_per_dts(AVFormatContext *s, AVPacket *out, AVPacket *pkt, int flush);
 
 int av_write_trailer(AVFormatContext *s);
 
@@ -676,9 +482,9 @@
 
 int find_info_tag(char *arg, int arg_size, const char *tag1, const char *info);
 
-int get_frame_filename(char *buf, int buf_size,
-                       const char *path, int number);
-int filename_number_test(const char *filename);
+int av_get_frame_filename(char *buf, int buf_size,
+                          const char *path, int number);
+int av_filename_number_test(const char *filename);
 
 /* grab specific */
 int video_grab_init(void);
@@ -690,7 +496,7 @@
 
 #ifdef HAVE_AV_CONFIG_H
 
-//#include &quot;os_support.h&quot;
+#include &quot;os_support.h&quot;
 
 int strstart(const char *str, const char *val, const char **ptr);
 int stristart(const char *str, const char *val, const char **ptr);

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/avi.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/avi.h	2007-01-20 15:15:58 UTC (rev 2746)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/avi.h	2007-01-21 18:04:24 UTC (rev 2747)
@@ -1,3 +1,23 @@
+/*
+ * copyright (c) 2001 Fabrice Bellard
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
 #ifndef FFMPEG_AVI_H
 #define FFMPEG_AVI_H
 
@@ -16,28 +36,4 @@
 /* index flags */
 #define AVIIF_INDEX             0x10
 
-offset_t start_tag(ByteIOContext *pb, const char *tag);
-void end_tag(ByteIOContext *pb, offset_t start);
-
-typedef struct CodecTag {
-    int id;
-    unsigned int tag;
-    unsigned int invalid_asf : 1;
-} CodecTag;
-
-void put_bmp_header(ByteIOContext *pb, AVCodecContext *enc, const CodecTag *tags, int for_asf);
-int put_wav_header(ByteIOContext *pb, AVCodecContext *enc);
-int wav_codec_get_id(unsigned int tag, int bps);
-void get_wav_header(ByteIOContext *pb, AVCodecContext *codec, int size);
-
-extern const CodecTag codec_bmp_tags[];
-extern const CodecTag codec_wav_tags[];
-
-unsigned int codec_get_tag(const CodecTag *tags, int id);
-enum CodecID codec_get_id(const CodecTag *tags, unsigned int tag);
-unsigned int codec_get_bmp_tag(int id);
-unsigned int codec_get_wav_tag(int id);
-enum CodecID codec_get_bmp_id(unsigned int tag);
-enum CodecID codec_get_wav_id(unsigned int tag);
-
 #endif /* FFMPEG_AVI_H */

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/avienc.c
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/avienc.c	2007-01-20 15:15:58 UTC (rev 2746)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/avienc.c	2007-01-21 18:04:24 UTC (rev 2747)
@@ -1,30 +1,33 @@
 /*
- * AVI encoder.
+ * AVI muxer
  * Copyright (c) 2000 Fabrice Bellard.
  *
- * This library is free software; you can redistribute it and/or
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
  * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
+ * version 2.1 of the License, or (at your option) any later version.
  *
- * This library is distributed in the hope that it will be useful,
+ * FFmpeg is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  * Lesser General Public License for more details.
  *
  * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 #include &quot;avformat.h&quot;
 #include &quot;avi.h&quot;
+#include &quot;riff.h&quot;
 
 /*
  * TODO:
  *  - fill all fields if non streamed (nb_frames for example)
  */
 
-#ifdef CONFIG_MUXERS
+#ifdef CONFIG_AVI_MUXER
 typedef struct AVIIentry {
     unsigned int flags, pos, len;
 } AVIIentry;
@@ -55,245 +58,6 @@
     return &amp;idx-&gt;cluster[cl][id];
 }
 
-offset_t start_tag(ByteIOContext *pb, const char *tag)
-{
-    put_tag(pb, tag);
-    put_le32(pb, 0);
-    return url_ftell(pb);
-}
-
-void end_tag(ByteIOContext *pb, offset_t start)
-{
-    offset_t pos;
-
-    pos = url_ftell(pb);
-    url_fseek(pb, start - 4, SEEK_SET);
-    put_le32(pb, (uint32_t)(pos - start));
-    url_fseek(pb, pos, SEEK_SET);
-}
-#endif //CONFIG_MUXERS
-
-/* Note: when encoding, the first matching tag is used, so order is
-   important if multiple tags possible for a given codec. */
-const CodecTag codec_bmp_tags[] = {
-    { CODEC_ID_H264, MKTAG('H', '2', '6', '4') },
-    { CODEC_ID_H264, MKTAG('h', '2', '6', '4') },
-    { CODEC_ID_H264, MKTAG('X', '2', '6', '4') },
-    { CODEC_ID_H264, MKTAG('x', '2', '6', '4') },
-    { CODEC_ID_H264, MKTAG('a', 'v', 'c', '1') },
-    { CODEC_ID_H264, MKTAG('V', 'S', 'S', 'H') },
-
-    { CODEC_ID_H263, MKTAG('H', '2', '6', '3') },
-    { CODEC_ID_H263P, MKTAG('H', '2', '6', '3') },
-    { CODEC_ID_H263I, MKTAG('I', '2', '6', '3') }, /* intel h263 */
-    { CODEC_ID_H261, MKTAG('H', '2', '6', '1') },
-
-    /* added based on MPlayer */
-    { CODEC_ID_H263P, MKTAG('U', '2', '6', '3') },
-    { CODEC_ID_H263P, MKTAG('v', 'i', 'v', '1') },
-
-    { CODEC_ID_MPEG4, MKTAG('F', 'M', 'P', '4')},
-    { CODEC_ID_MPEG4, MKTAG('D', 'I', 'V', 'X'), .invalid_asf = 1 },
-    { CODEC_ID_MPEG4, MKTAG('D', 'X', '5', '0'), .invalid_asf = 1 },
-    { CODEC_ID_MPEG4, MKTAG('X', 'V', 'I', 'D'), .invalid_asf = 1 },
-    { CODEC_ID_MPEG4, MKTAG('M', 'P', '4', 'S') },
-    { CODEC_ID_MPEG4, MKTAG('M', '4', 'S', '2') },
-    { CODEC_ID_MPEG4, MKTAG(0x04, 0, 0, 0) }, /* some broken avi use this */
-
-    /* added based on MPlayer */
-    { CODEC_ID_MPEG4, MKTAG('D', 'I', 'V', '1') },
-    { CODEC_ID_MPEG4, MKTAG('B', 'L', 'Z', '0') },
-    { CODEC_ID_MPEG4, MKTAG('m', 'p', '4', 'v') },
-    { CODEC_ID_MPEG4, MKTAG('U', 'M', 'P', '4') },
-    { CODEC_ID_MPEG4, MKTAG('W', 'V', '1', 'F') },
-
-    { CODEC_ID_MSMPEG4V3, MKTAG('D', 'I', 'V', '3'), .invalid_asf = 1 }, /* default signature when using MSMPEG4 */
-    { CODEC_ID_MSMPEG4V3, MKTAG('M', 'P', '4', '3') },
-
-    /* added based on MPlayer */
-    { CODEC_ID_MSMPEG4V3, MKTAG('M', 'P', 'G', '3') },
-    { CODEC_ID_MSMPEG4V3, MKTAG('D', 'I', 'V', '5') },
-    { CODEC_ID_MSMPEG4V3, MKTAG('D', 'I', 'V', '6') },
-    { CODEC_ID_MSMPEG4V3, MKTAG('D', 'I', 'V', '4') },
-    { CODEC_ID_MSMPEG4V3, MKTAG('A', 'P', '4', '1') },
-    { CODEC_ID_MSMPEG4V3, MKTAG('C', 'O', 'L', '1') },
-    { CODEC_ID_MSMPEG4V3, MKTAG('C', 'O', 'L', '0') },
-
-    { CODEC_ID_MSMPEG4V2, MKTAG('M', 'P', '4', '2') },
-
-    /* added based on MPlayer */
-    { CODEC_ID_MSMPEG4V2, MKTAG('D', 'I', 'V', '2') },
-
-    { CODEC_ID_MSMPEG4V1, MKTAG('M', 'P', 'G', '4') },
-
-    { CODEC_ID_WMV1, MKTAG('W', 'M', 'V', '1') },
-
-    /* added based on MPlayer */
-    { CODEC_ID_WMV2, MKTAG('W', 'M', 'V', '2') },
-    { CODEC_ID_DVVIDEO, MKTAG('d', 'v', 's', 'd') },
-    { CODEC_ID_DVVIDEO, MKTAG('d', 'v', 'h', 'd') },
-    { CODEC_ID_DVVIDEO, MKTAG('d', 'v', 's', 'l') },
-    { CODEC_ID_DVVIDEO, MKTAG('d', 'v', '2', '5') },
-    { CODEC_ID_MPEG1VIDEO, MKTAG('m', 'p', 'g', '1') },
-    { CODEC_ID_MPEG1VIDEO, MKTAG('m', 'p', 'g', '2') },
-    { CODEC_ID_MPEG2VIDEO, MKTAG('m', 'p', 'g', '2') },
-    { CODEC_ID_MPEG1VIDEO, MKTAG('P', 'I', 'M', '1') },
-    { CODEC_ID_MPEG1VIDEO, MKTAG('V', 'C', 'R', '2') },
-    { CODEC_ID_MPEG1VIDEO, 0x10000001 },
-    { CODEC_ID_MPEG2VIDEO, 0x10000002 },
-    { CODEC_ID_MPEG2VIDEO, MKTAG('D', 'V', 'R', ' ') },
-    { CODEC_ID_MJPEG, MKTAG('M', 'J', 'P', 'G') },
-    { CODEC_ID_MJPEG, MKTAG('L', 'J', 'P', 'G') },
-    { CODEC_ID_LJPEG, MKTAG('L', 'J', 'P', 'G') },
-    { CODEC_ID_MJPEG, MKTAG('J', 'P', 'G', 'L') }, /* Pegasus lossless JPEG */
-    { CODEC_ID_HUFFYUV, MKTAG('H', 'F', 'Y', 'U') },
-    { CODEC_ID_FFVHUFF, MKTAG('F', 'F', 'V', 'H') },
-    { CODEC_ID_CYUV, MKTAG('C', 'Y', 'U', 'V') },
-    { CODEC_ID_RAWVIDEO, MKTAG('I', '4', '2', '0') },
-    { CODEC_ID_RAWVIDEO, MKTAG('Y', 'U', 'Y', '2') },
-    { CODEC_ID_RAWVIDEO, MKTAG('Y', '4', '2', '2') },
-    { CODEC_ID_RAWVIDEO, MKTAG('U', 'Y', 'V', 'Y') },
-    { CODEC_ID_RAWVIDEO, MKTAG('I', 'Y', 'U', 'V') },
-    { CODEC_ID_INDEO3, MKTAG('I', 'V', '3', '1') },
-    { CODEC_ID_INDEO3, MKTAG('I', 'V', '3', '2') },
-    { CODEC_ID_VP3, MKTAG('V', 'P', '3', '1') },
-    { CODEC_ID_VP3, MKTAG('V', 'P', '3', '0') },
-    { CODEC_ID_ASV1, MKTAG('A', 'S', 'V', '1') },
-    { CODEC_ID_ASV2, MKTAG('A', 'S', 'V', '2') },
-    { CODEC_ID_VCR1, MKTAG('V', 'C', 'R', '1') },
-    { CODEC_ID_FFV1, MKTAG('F', 'F', 'V', '1') },
-    { CODEC_ID_XAN_WC4, MKTAG('X', 'x', 'a', 'n') },
-    { CODEC_ID_MSRLE, MKTAG('m', 'r', 'l', 'e') },
-    { CODEC_ID_MSRLE, MKTAG(0x1, 0x0, 0x0, 0x0) },
-    { CODEC_ID_MSVIDEO1, MKTAG('M', 'S', 'V', 'C') },
-    { CODEC_ID_MSVIDEO1, MKTAG('m', 's', 'v', 'c') },
-    { CODEC_ID_MSVIDEO1, MKTAG('C', 'R', 'A', 'M') },
-    { CODEC_ID_MSVIDEO1, MKTAG('c', 'r', 'a', 'm') },
-    { CODEC_ID_MSVIDEO1, MKTAG('W', 'H', 'A', 'M') },
-    { CODEC_ID_MSVIDEO1, MKTAG('w', 'h', 'a', 'm') },
-    { CODEC_ID_CINEPAK, MKTAG('c', 'v', 'i', 'd') },
-    { CODEC_ID_TRUEMOTION1, MKTAG('D', 'U', 'C', 'K') },
-    { CODEC_ID_MSZH, MKTAG('M', 'S', 'Z', 'H') },
-    { CODEC_ID_ZLIB, MKTAG('Z', 'L', 'I', 'B') },
-    { CODEC_ID_SNOW, MKTAG('S', 'N', 'O', 'W') },
-    { CODEC_ID_4XM, MKTAG('4', 'X', 'M', 'V') },
-    { CODEC_ID_FLV1, MKTAG('F', 'L', 'V', '1') },
-    { CODEC_ID_SVQ1, MKTAG('s', 'v', 'q', '1') },
-    { CODEC_ID_TSCC, MKTAG('t', 's', 'c', 'c') },
-    { CODEC_ID_ULTI, MKTAG('U', 'L', 'T', 'I') },
-    { CODEC_ID_VIXL, MKTAG('V', 'I', 'X', 'L') },
-    { CODEC_ID_QPEG, MKTAG('Q', 'P', 'E', 'G') },
-    { CODEC_ID_QPEG, MKTAG('Q', '1', '.', '0') },
-    { CODEC_ID_QPEG, MKTAG('Q', '1', '.', '1') },
-    { CODEC_ID_WMV3, MKTAG('W', 'M', 'V', '3') },
-    { CODEC_ID_LOCO, MKTAG('L', 'O', 'C', 'O') },
-    { CODEC_ID_WNV1, MKTAG('W', 'N', 'V', '1') },
-    { CODEC_ID_AASC, MKTAG('A', 'A', 'S', 'C') },
-    { CODEC_ID_INDEO2, MKTAG('R', 'T', '2', '1') },
-    { CODEC_ID_FRAPS, MKTAG('F', 'P', 'S', '1') },
-    { CODEC_ID_THEORA, MKTAG('t', 'h', 'e', 'o') },
-    { CODEC_ID_TRUEMOTION2, MKTAG('T', 'M', '2', '0') },
-    { CODEC_ID_RAWVIDEO, 0 },
-    { 0, 0 },
-};
-
-unsigned int codec_get_tag(const CodecTag *tags, int id)
-{
-    while (tags-&gt;id != 0) {
-        if (tags-&gt;id == id)
-            return tags-&gt;tag;
-        tags++;
-    }
-    return 0;
-}
-
-static unsigned int codec_get_asf_tag(const CodecTag *tags, unsigned int id)
-{
-    while (tags-&gt;id != 0) {
-        if (!tags-&gt;invalid_asf &amp;&amp; tags-&gt;id == id)
-            return tags-&gt;tag;
-        tags++;
-    }
-    return 0;
-}
-
-enum CodecID codec_get_id(const CodecTag *tags, unsigned int tag)
-{
-    while (tags-&gt;id != 0) {
-        if(   toupper((tag &gt;&gt; 0)&amp;0xFF) == toupper((tags-&gt;tag &gt;&gt; 0)&amp;0xFF)
-           &amp;&amp; toupper((tag &gt;&gt; 8)&amp;0xFF) == toupper((tags-&gt;tag &gt;&gt; 8)&amp;0xFF)
-           &amp;&amp; toupper((tag &gt;&gt;16)&amp;0xFF) == toupper((tags-&gt;tag &gt;&gt;16)&amp;0xFF)
-           &amp;&amp; toupper((tag &gt;&gt;24)&amp;0xFF) == toupper((tags-&gt;tag &gt;&gt;24)&amp;0xFF))
-            return tags-&gt;id;
-        tags++;
-    }
-    return CODEC_ID_NONE;
-}
-
-unsigned int codec_get_bmp_tag(int id)
-{
-    return codec_get_tag(codec_bmp_tags, id);
-}
-
-unsigned int codec_get_wav_tag(int id)
-{
-    return codec_get_tag(codec_wav_tags, id);
-}
-
-enum CodecID codec_get_bmp_id(unsigned int tag)
-{
-    return codec_get_id(codec_bmp_tags, tag);
-}
-
-enum CodecID codec_get_wav_id(unsigned int tag)
-{
-    return codec_get_id(codec_wav_tags, tag);
-}
-
-#ifdef CONFIG_MUXERS
-/* BITMAPINFOHEADER header */
-void put_bmp_header(ByteIOContext *pb, AVCodecContext *enc, const CodecTag *tags, int for_asf)
-{
-    put_le32(pb, 40 + enc-&gt;extradata_size); /* size */
-    put_le32(pb, enc-&gt;width);
-    put_le32(pb, enc-&gt;height);
-    put_le16(pb, 1); /* planes */
-
-    put_le16(pb, enc-&gt;bits_per_sample ? enc-&gt;bits_per_sample : 24); /* depth */
-    /* compression type */
-    put_le32(pb, for_asf ? (enc-&gt;codec_tag ? enc-&gt;codec_tag : codec_get_asf_tag(tags, enc-&gt;codec_id)) : enc-&gt;codec_tag); //
-    put_le32(pb, enc-&gt;width * enc-&gt;height * 3);
-    put_le32(pb, 0);
-    put_le32(pb, 0);
-    put_le32(pb, 0);
-    put_le32(pb, 0);
-
-    put_buffer(pb, enc-&gt;extradata, enc-&gt;extradata_size);
-
-    if (enc-&gt;extradata_size &amp; 1)
-        put_byte(pb, 0);
-}
-
-void ff_parse_specific_params(AVCodecContext *stream, int *au_rate, int *au_ssize, int *au_scale)
-{
-    int gcd;
-
-    *au_ssize= stream-&gt;block_align;
-    if(stream-&gt;frame_size &amp;&amp; stream-&gt;sample_rate){
-        *au_scale=stream-&gt;frame_size;
-        *au_rate= stream-&gt;sample_rate;
-    }else if(stream-&gt;codec_type == CODEC_TYPE_VIDEO){
-        *au_scale= stream-&gt;time_base.num;
-        *au_rate = stream-&gt;time_base.den;
-    }else{
-        *au_scale= stream-&gt;block_align ? stream-&gt;block_align*8 : 8;
-        *au_rate = stream-&gt;bit_rate;
-    }
-    gcd= ff_gcd(*au_scale, *au_rate);
-    *au_scale /= gcd;
-    *au_rate /= gcd;
-}
-
 static offset_t avi_start_new_riff(AVIContext *avi, ByteIOContext *pb,
                                    const char* riff_tag, const char* list_tag)
 {
@@ -311,8 +75,7 @@
     return loff;
 }
 
-static unsigned char* avi_stream2fourcc(unsigned char* tag, int index,
-                                        enum CodecType type)
+static char* avi_stream2fourcc(char* tag, int index, enum CodecType type)
 {
     tag[0] = '0';
     tag[1] = '0' + index;
@@ -327,6 +90,51 @@
     return tag;
 }
 
+static void avi_write_info_tag(ByteIOContext *pb, const char *tag, const char *str)
+{
+    int len = strlen(str);
+    if (len &gt; 0) {
+        len++;
+        put_tag(pb, tag);
+        put_le32(pb, len);
+        put_strz(pb, str);
+        if (len &amp; 1)
+            put_byte(pb, 0);
+    }
+}
+
+static int avi_write_counters(AVFormatContext* s, int riff_id)
+{
+    ByteIOContext *pb = &amp;s-&gt;pb;
+    AVIContext *avi = s-&gt;priv_data;
+    int n, au_byterate, au_ssize, au_scale, nb_frames = 0;
+    offset_t file_size;
+    AVCodecContext* stream;
+
+    file_size = url_ftell(pb);
+    for(n = 0; n &lt; s-&gt;nb_streams; n++) {
+        assert(avi-&gt;frames_hdr_strm[n]);
+        stream = s-&gt;streams[n]-&gt;codec;
+        url_fseek(pb, avi-&gt;frames_hdr_strm[n], SEEK_SET);
+        ff_parse_specific_params(stream, &amp;au_byterate, &amp;au_ssize, &amp;au_scale);
+        if(au_ssize == 0) {
+            put_le32(pb, avi-&gt;packet_count[n]);
+        } else {
+            put_le32(pb, avi-&gt;audio_strm_length[n] / au_ssize);
+        }
+        if(stream-&gt;codec_type == CODEC_TYPE_VIDEO)
+            nb_frames = FFMAX(nb_frames, avi-&gt;packet_count[n]);
+    }
+    if(riff_id == 1) {
+        assert(avi-&gt;frames_hdr_all);
+        url_fseek(pb, avi-&gt;frames_hdr_all, SEEK_SET);
+        put_le32(pb, nb_frames);
+    }
+    url_fseek(pb, file_size, SEEK_SET);
+
+    return 0;
+}
+
 static int avi_write_header(AVFormatContext *s)
 {
     AVIContext *avi = s-&gt;priv_data;
@@ -355,7 +163,7 @@
     nb_frames = 0;
 
     if(video_enc){
-        put_le32(pb, (uint32_t)(int64_t_C(1000000) * video_enc-&gt;time_base.num / video_enc-&gt;time_base.den));
+        put_le32(pb, (uint32_t)(INT64_C(1000000) * video_enc-&gt;time_base.num / video_enc-&gt;time_base.den));
     } else {
         put_le32(pb, 0);
     }
@@ -371,8 +179,8 @@
     put_le32(pb, s-&gt;nb_streams); /* nb streams */
     put_le32(pb, 1024 * 1024); /* suggested buffer size */
     if(video_enc){
-    put_le32(pb, video_enc-&gt;width);
-    put_le32(pb, video_enc-&gt;height);
+        put_le32(pb, video_enc-&gt;width);
+        put_le32(pb, video_enc-&gt;height);
     } else {
         put_le32(pb, 0);
         put_le32(pb, 0);
@@ -496,6 +304,29 @@
 
     end_tag(pb, list1);
 
+    list2 = start_tag(pb, &quot;LIST&quot;);
+    put_tag(pb, &quot;INFO&quot;);
+    avi_write_info_tag(pb, &quot;INAM&quot;, s-&gt;title);
+    avi_write_info_tag(pb, &quot;IART&quot;, s-&gt;author);
+    avi_write_info_tag(pb, &quot;ICOP&quot;, s-&gt;copyright);
+    avi_write_info_tag(pb, &quot;ICMT&quot;, s-&gt;comment);
+    avi_write_info_tag(pb, &quot;IPRD&quot;, s-&gt;album);
+    avi_write_info_tag(pb, &quot;IGNR&quot;, s-&gt;genre);
+    if (s-&gt;track) {
+        char str_track[4];
+        snprintf(str_track, 4, &quot;%d&quot;, s-&gt;track);
+        avi_write_info_tag(pb, &quot;IPRT&quot;, str_track);
+    }
+    if(!(s-&gt;streams[0]-&gt;codec-&gt;flags &amp; CODEC_FLAG_BITEXACT))
+        avi_write_info_tag(pb, &quot;ISFT&quot;, LIBAVFORMAT_IDENT);
+    end_tag(pb, list2);
+
+    /* some padding for easier tag editing */
+    list2 = start_tag(pb, &quot;JUNK&quot;);
+    for (i = 0; i &lt; 1016; i += 4)
+        put_le32(pb, 0);
+    end_tag(pb, list2);
+
     avi-&gt;movi_list = start_tag(pb, &quot;LIST&quot;);
     put_tag(pb, &quot;movi&quot;);
 
@@ -508,12 +339,11 @@
 {
     ByteIOContext *pb = &amp;s-&gt;pb;
     AVIContext *avi = s-&gt;priv_data;
-    unsigned char tag[5];
-    unsigned char ix_tag[] = &quot;ix00&quot;;
+    char tag[5];
+    char ix_tag[] = &quot;ix00&quot;;
     int i, j;
 
-    if (url_is_streamed(pb))
-        return -1;
+    assert(!url_is_streamed(pb));
 
     if (avi-&gt;riff_id &gt; AVI_MASTER_INDEX_SIZE)
         return -1;
@@ -566,10 +396,9 @@
 {
     ByteIOContext *pb = &amp;s-&gt;pb;
     AVIContext *avi = s-&gt;priv_data;
-    offset_t file_size, idx_chunk;
-    int i, n, nb_frames, au_byterate, au_ssize, au_scale;
-    AVCodecContext *stream;
-    unsigned char tag[5];
+    offset_t idx_chunk;
+    int i;
+    char tag[5];
 
     if (!url_is_streamed(pb)) {
         AVIIentry* ie = 0, *tie;
@@ -603,27 +432,7 @@
         } while (!empty);
         end_tag(pb, idx_chunk);
 
-        /* Fill in frame/sample counters */
-        file_size = url_ftell(pb);
-        nb_frames = 0;
-        for(n=0;n&lt;s-&gt;nb_streams;n++) {
-            if (avi-&gt;frames_hdr_strm[n] != 0) {
-                stream = s-&gt;streams[n]-&gt;codec;
-                url_fseek(pb, avi-&gt;frames_hdr_strm[n], SEEK_SET);
-                ff_parse_specific_params(stream, &amp;au_byterate, &amp;au_ssize, &amp;au_scale);
-                if (au_ssize == 0) {
-                    put_le32(pb, stream-&gt;frame_number);
-                    nb_frames += stream-&gt;frame_number;
-                } else {
-                    put_le32(pb, avi-&gt;audio_strm_length[n] / au_ssize);
-                }
-            }
-       }
-       if (avi-&gt;frames_hdr_all != 0) {
-           url_fseek(pb, avi-&gt;frames_hdr_all, SEEK_SET);
-           put_le32(pb, nb_frames);
-       }
-       url_fseek(pb, file_size, SEEK_SET);
+        avi_write_counters(s, avi-&gt;riff_id);
     }
     return 0;
 }
@@ -638,7 +447,7 @@
     AVCodecContext *enc= s-&gt;streams[stream_index]-&gt;codec;
     int size= pkt-&gt;size;
 
-//    av_log(s, AV_LOG_DEBUG, &quot;%lld %d %d\n&quot;, pkt-&gt;dts, avi-&gt;packet_count[stream_index], stream_index);
+//    av_log(s, AV_LOG_DEBUG, &quot;%&quot;PRId64&quot; %d %d\n&quot;, pkt-&gt;dts, avi-&gt;packet_count[stream_index], stream_index);
     while(enc-&gt;block_align==0 &amp;&amp; pkt-&gt;dts != AV_NOPTS_VALUE &amp;&amp; pkt-&gt;dts &gt; avi-&gt;packet_count[stream_index]){
         AVPacket empty_packet;
 
@@ -647,7 +456,7 @@
         empty_packet.data= NULL;
         empty_packet.stream_index= stream_index;
         avi_write_packet(s, &amp;empty_packet);
-//        av_log(s, AV_LOG_DEBUG, &quot;dup %lld %d\n&quot;, pkt-&gt;dts, avi-&gt;packet_count[stream_index]);
+//        av_log(s, AV_LOG_DEBUG, &quot;dup %&quot;PRId64&quot; %d\n&quot;, pkt-&gt;dts, avi-&gt;packet_count[stream_index]);
     }
     avi-&gt;packet_count[stream_index]++;
 
@@ -710,37 +519,38 @@
     int i, j, n, nb_frames;
     offset_t file_size;
 
-    if (!url_is_streamed(pb))
-    {
-    if (avi-&gt;riff_id == 1) {
-        end_tag(pb, avi-&gt;movi_list);
-        res = avi_write_idx1(s);
-        end_tag(pb, avi-&gt;riff_start);
-    } else {
-        avi_write_ix(s);
-        end_tag(pb, avi-&gt;movi_list);
-        end_tag(pb, avi-&gt;riff_start);
+    if (!url_is_streamed(pb)){
+        if (avi-&gt;riff_id == 1) {
+            end_tag(pb, avi-&gt;movi_list);
+            res = avi_write_idx1(s);
+            end_tag(pb, avi-&gt;riff_start);
+        } else {
+            avi_write_ix(s);
+            end_tag(pb, avi-&gt;movi_list);
+            end_tag(pb, avi-&gt;riff_start);
 
-        file_size = url_ftell(pb);
-        url_fseek(pb, avi-&gt;odml_list - 8, SEEK_SET);
-        put_tag(pb, &quot;LIST&quot;); /* Making this AVI OpenDML one */
-        url_fskip(pb, 16);
+            file_size = url_ftell(pb);
+            url_fseek(pb, avi-&gt;odml_list - 8, SEEK_SET);
+            put_tag(pb, &quot;LIST&quot;); /* Making this AVI OpenDML one */
+            url_fskip(pb, 16);
 
-        for (n=nb_frames=0;n&lt;s-&gt;nb_streams;n++) {
-             AVCodecContext *stream = s-&gt;streams[n]-&gt;codec;
-             if (stream-&gt;codec_type == CODEC_TYPE_VIDEO) {
-                 if (nb_frames &lt; stream-&gt;frame_number)
-                     nb_frames = stream-&gt;frame_number;
-             } else {
-                 if (stream-&gt;codec_id == CODEC_ID_MP2 || stream-&gt;codec_id == CODEC_ID_MP3) {
-                     nb_frames += stream-&gt;frame_number;
+            for (n=nb_frames=0;n&lt;s-&gt;nb_streams;n++) {
+                AVCodecContext *stream = s-&gt;streams[n]-&gt;codec;
+                if (stream-&gt;codec_type == CODEC_TYPE_VIDEO) {
+                    if (nb_frames &lt; avi-&gt;packet_count[n])
+                        nb_frames = avi-&gt;packet_count[n];
+                } else {
+                    if (stream-&gt;codec_id == CODEC_ID_MP2 || stream-&gt;codec_id == CODEC_ID_MP3) {
+                        nb_frames += avi-&gt;packet_count[n];
+                    }
                 }
             }
+            put_le32(pb, nb_frames);
+            url_fseek(pb, file_size, SEEK_SET);
+
+            avi_write_counters(s, avi-&gt;riff_id);
         }
-        put_le32(pb, nb_frames);
-        url_fseek(pb, file_size, SEEK_SET);
     }
-    }
     put_flush_packet(pb);
 
     for (i=0; i&lt;MAX_STREAMS; i++) {
@@ -754,7 +564,7 @@
     return res;
 }
 
-static AVOutputFormat avi_oformat = {
+AVOutputFormat avi_muxer = {
     &quot;avi&quot;,
     &quot;avi format&quot;,
     &quot;video/x-msvideo&quot;,
@@ -765,11 +575,6 @@
     avi_write_header,
     avi_write_packet,
     avi_write_trailer,
+    .codec_tag= {codec_bmp_tags, codec_wav_tags},
 };
-
-int avienc_init(void)
-{
-    av_register_output_format(&amp;avi_oformat);
-    return 0;
-}
-#endif //CONFIG_MUXERS
+#endif //CONFIG_AVI_MUXER

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/avio.c
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/avio.c	2007-01-20 15:15:58 UTC (rev 2746)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/avio.c	2007-01-21 18:04:24 UTC (rev 2747)
@@ -2,19 +2,21 @@
  * Unbuffered io for ffmpeg system
  * Copyright (c) 2001 Fabrice Bellard
  *
- * This library is free software; you can redistribute it and/or
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
  * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
+ * version 2.1 of the License, or (at your option) any later version.
  *
- * This library is distributed in the hope that it will be useful,
+ * FFmpeg is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  * Lesser General Public License for more details.
  *
  * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 #include &quot;avformat.h&quot;
 
@@ -58,7 +60,7 @@
     } else {
         *q = '\0';
     }
-    
+
     up = first_protocol;
     while (up != NULL) {
         if (!strcmp(proto_str, up-&gt;name))
@@ -68,11 +70,14 @@
     err = -ENOENT;
     goto fail;
  found:
-    uc = av_malloc(sizeof(URLContext) + strlen(filename));
+    uc = av_malloc(sizeof(URLContext) + strlen(filename) + 1);
     if (!uc) {
         err = -ENOMEM;
         goto fail;
     }
+#if LIBAVFORMAT_VERSION_INT &gt;= (52&lt;&lt;16)
+    uc-&gt;filename = (char *) &amp;uc[1];
+#endif
     strcpy(uc-&gt;filename, filename);
     uc-&gt;prot = up;
     uc-&gt;flags = flags;
@@ -100,7 +105,7 @@
     return ret;
 }
 
-#ifdef CONFIG_ENCODERS
+#if defined(CONFIG_MUXERS) || defined(CONFIG_PROTOCOLS)
 int url_write(URLContext *h, unsigned char *buf, int size)
 {
     int ret;
@@ -108,11 +113,11 @@
         return AVERROR_IO;
     /* avoid sending too big packets */
     if (h-&gt;max_packet_size &amp;&amp; size &gt; h-&gt;max_packet_size)
-        return AVERROR_IO; 
+        return AVERROR_IO;
     ret = h-&gt;prot-&gt;url_write(h, buf, size);
     return ret;
 }
-#endif //CONFIG_ENCODERS
+#endif //CONFIG_MUXERS || CONFIG_PROTOCOLS
 
 offset_t url_seek(URLContext *h, offset_t pos, int whence)
 {
@@ -145,18 +150,21 @@
 offset_t url_filesize(URLContext *h)
 {
     offset_t pos, size;
-    
-    pos = url_seek(h, 0, SEEK_CUR);
-    size = url_seek(h, -1, SEEK_END)+1;
-    url_seek(h, pos, SEEK_SET);
+
+    size= url_seek(h, 0, AVSEEK_SIZE);
+    if(size&lt;0){
+        pos = url_seek(h, 0, SEEK_CUR);
+        size = url_seek(h, -1, SEEK_END)+1;
+        url_seek(h, pos, SEEK_SET);
+    }
     return size;
 }
 
-/* 
+/*
  * Return the maximum packet size associated to packetized file
  * handle. If the file is not packetized (stream like http or file on
  * disk), then 0 is returned.
- * 
+ *
  * @param h file handle
  * @return maximum packet size in bytes
  */
@@ -176,11 +184,11 @@
     return 0;
 }
 
-/** 
+/**
  * The callback is called in blocking functions to test regulary if
  * asynchronous interruption is needed. -EINTR is returned in this
  * case by the interrupted function. 'NULL' means no interrupt
- * callback is given.  
+ * callback is given.
  */
 void url_set_interrupt_cb(URLInterruptCB *interrupt_cb)
 {

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/avio.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/avio.h	2007-01-20 15:15:58 UTC (rev 2746)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/avio.h	2007-01-21 18:04:24 UTC (rev 2747)
@@ -1,3 +1,23 @@
+/*
+ * unbuffered io for ffmpeg system
+ * copyright (c) 2001 Fabrice Bellard
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
 #ifndef AVIO_H
 #define AVIO_H
 
@@ -13,7 +33,11 @@
     int is_streamed;  /* true if streamed (no seek possible), default = false */
     int max_packet_size;  /* if non zero, the stream is packetized with this max packet size */
     void *priv_data;
+#if LIBAVFORMAT_VERSION_INT &gt;= (52&lt;&lt;16)
+    char *filename; /* specified filename */
+#else
     char filename[1]; /* specified filename */
+#endif
 };
 
 typedef struct URLContext URLContext;
@@ -49,6 +73,13 @@
 /* not implemented */
 int url_poll(URLPollEntry *poll_table, int n, int timeout);
 
+/**
+ * passing this as the &quot;whence&quot; parameter to a seek function causes it to
+ * return the filesize without seeking anywhere, supporting this is optional
+ * if its not supprted then the seek function will return &lt;0
+ */
+#define AVSEEK_SIZE 0x10000
+
 typedef struct URLProtocol {
     const char *name;
     int (*url_open)(URLContext *h, const char *filename, int flags);
@@ -99,6 +130,7 @@
 void put_be64(ByteIOContext *s, uint64_t val);
 void put_le32(ByteIOContext *s, unsigned int val);
 void put_be32(ByteIOContext *s, unsigned int val);
+void put_le24(ByteIOContext *s, unsigned int val);
 void put_be24(ByteIOContext *s, unsigned int val);
 void put_le16(ByteIOContext *s, unsigned int val);
 void put_be16(ByteIOContext *s, unsigned int val);
@@ -127,6 +159,7 @@
 int get_buffer(ByteIOContext *s, unsigned char *buf, int size);
 int get_partial_buffer(ByteIOContext *s, unsigned char *buf, int size);
 int get_byte(ByteIOContext *s);
+unsigned int get_le24(ByteIOContext *s);
 unsigned int get_le32(ByteIOContext *s);
 uint64_t get_le64(ByteIOContext *s);
 unsigned int get_le16(ByteIOContext *s);
@@ -158,7 +191,6 @@
 
 unsigned long get_checksum(ByteIOContext *s);
 void init_checksum(ByteIOContext *s, unsigned long (*update_checksum)(unsigned long c, const uint8_t *p, unsigned int len), unsigned long checksum);
-unsigned long update_adler32(unsigned long adler, const uint8_t *buf, unsigned int len);
 
 /* file.c */
 extern URLProtocol file_protocol;

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/aviobuf.c
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/aviobuf.c	2007-01-20 15:15:58 UTC (rev 2746)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/aviobuf.c	2007-01-21 18:04:24 UTC (rev 2747)
@@ -2,19 +2,21 @@
  * Buffered I/O for ffmpeg system
  * Copyright (c) 2000,2001 Fabrice Bellard
  *
- * This library is free software; you can redistribute it and/or
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
  * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
+ * version 2.1 of the License, or (at your option) any later version.
  *
- * This library is distributed in the hope that it will be useful,
+ * FFmpeg is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  * Lesser General Public License for more details.
  *
  * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 #include &quot;avformat.h&quot;
 #include &quot;avio.h&quot;
@@ -22,6 +24,8 @@
 
 #define IO_BUFFER_SIZE 32768
 
+static void fill_buffer(ByteIOContext *s);
+
 int init_put_byte(ByteIOContext *s,
                   unsigned char *buffer,
                   int buffer_size,
@@ -50,11 +54,13 @@
     s-&gt;is_streamed = 0;
     s-&gt;max_packet_size = 0;
     s-&gt;update_checksum= NULL;
+    if(!read_packet &amp;&amp; !write_flag){
+        s-&gt;pos = buffer_size;
+        s-&gt;buf_end = s-&gt;buffer + buffer_size;
+    }
     return 0;
 }
 
-
-#ifdef CONFIG_MUXERS
 static void flush_buffer(ByteIOContext *s)
 {
     if (s-&gt;buf_ptr &gt; s-&gt;buffer) {
@@ -104,61 +110,47 @@
     flush_buffer(s);
     s-&gt;must_flush = 0;
 }
-#endif //CONFIG_MUXERS
 
 offset_t url_fseek(ByteIOContext *s, offset_t offset, int whence)
 {
     offset_t offset1;
+    offset_t pos= s-&gt;pos - (s-&gt;write_flag ? 0 : (s-&gt;buf_end - s-&gt;buffer));
 
     if (whence != SEEK_CUR &amp;&amp; whence != SEEK_SET)
         return -EINVAL;
 
-#ifdef CONFIG_MUXERS
-    if (s-&gt;write_flag) {
-        if (whence == SEEK_CUR) {
-            offset1 = s-&gt;pos + (s-&gt;buf_ptr - s-&gt;buffer);
-            if (offset == 0)
-                return offset1;
-            offset += offset1;
-        }
-        offset1 = offset - s-&gt;pos;
-        if (!s-&gt;must_flush &amp;&amp;
-            offset1 &gt;= 0 &amp;&amp; offset1 &lt; (s-&gt;buf_end - s-&gt;buffer)) {
-            /* can do the seek inside the buffer */
-            s-&gt;buf_ptr = s-&gt;buffer + offset1;
-        } else {
-            if (!s-&gt;seek)
-                return -EPIPE;
+    if (whence == SEEK_CUR) {
+        offset1 = pos + (s-&gt;buf_ptr - s-&gt;buffer);
+        if (offset == 0)
+            return offset1;
+        offset += offset1;
+    }
+    offset1 = offset - pos;
+    if (!s-&gt;must_flush &amp;&amp;
+        offset1 &gt;= 0 &amp;&amp; offset1 &lt; (s-&gt;buf_end - s-&gt;buffer)) {
+        /* can do the seek inside the buffer */
+        s-&gt;buf_ptr = s-&gt;buffer + offset1;
+    } else if(s-&gt;is_streamed &amp;&amp; !s-&gt;write_flag &amp;&amp;
+              offset1 &gt;= 0 &amp;&amp; offset1 &lt; (s-&gt;buf_end - s-&gt;buffer) + (1&lt;&lt;16)){
+        while(s-&gt;pos &lt; offset &amp;&amp; !s-&gt;eof_reached)
+            fill_buffer(s);
+        s-&gt;buf_ptr = s-&gt;buf_end + offset - s-&gt;pos;
+    } else {
+#if defined(CONFIG_MUXERS) || defined(CONFIG_NETWORK)
+        if (s-&gt;write_flag) {
             flush_buffer(s);
             s-&gt;must_flush = 1;
-            s-&gt;buf_ptr = s-&gt;buffer;
-            s-&gt;seek(s-&gt;opaque, offset, SEEK_SET);
-            s-&gt;pos = offset;
-        }
-    } else
-#endif //CONFIG_MUXERS
-    {
-        if (whence == SEEK_CUR) {
-            offset1 = s-&gt;pos - (s-&gt;buf_end - s-&gt;buffer) + (s-&gt;buf_ptr - s-&gt;buffer);
-            if (offset == 0)
-                return offset1;
-            offset += offset1;
-        }
-        offset1 = offset - (s-&gt;pos - (s-&gt;buf_end - s-&gt;buffer));
-        if (offset1 &gt;= 0 &amp;&amp; offset1 &lt;= (s-&gt;buf_end - s-&gt;buffer)) {
-            /* can do the seek inside the buffer */
-            s-&gt;buf_ptr = s-&gt;buffer + offset1;
-        } else {
-            if (!s-&gt;seek)
-                return -EPIPE;
-            s-&gt;buf_ptr = s-&gt;buffer;
+        } else
+#endif /* defined(CONFIG_MUXERS) || defined(CONFIG_NETWORK) */
+        {
             s-&gt;buf_end = s-&gt;buffer;
-            if (s-&gt;seek(s-&gt;opaque, offset, SEEK_SET) == (offset_t)-EPIPE)
-                return -EPIPE;
-            s-&gt;pos = offset;
         }
-        s-&gt;eof_reached = 0;
+        s-&gt;buf_ptr = s-&gt;buffer;
+        if (!s-&gt;seek || s-&gt;seek(s-&gt;opaque, offset, SEEK_SET) == (offset_t)-EPIPE)
+            return -EPIPE;
+        s-&gt;pos = offset;
     }
+    s-&gt;eof_reached = 0;
     return offset;
 }
 
@@ -178,8 +170,11 @@
 
     if (!s-&gt;seek)
         return -EPIPE;
-    size = s-&gt;seek(s-&gt;opaque, -1, SEEK_END) + 1;
-    s-&gt;seek(s-&gt;opaque, s-&gt;pos, SEEK_SET);
+    size = s-&gt;seek(s-&gt;opaque, 0, AVSEEK_SIZE);
+    if(size&lt;0){
+        size = s-&gt;seek(s-&gt;opaque, -1, SEEK_END) + 1;
+        s-&gt;seek(s-&gt;opaque, s-&gt;pos, SEEK_SET);
+    }
     return size;
 }
 
@@ -193,7 +188,6 @@
     return s-&gt;error;
 }
 
-#ifdef CONFIG_MUXERS
 void put_le32(ByteIOContext *s, unsigned int val)
 {
     put_byte(s, val);
@@ -242,6 +236,12 @@
     put_byte(s, val);
 }
 
+void put_le24(ByteIOContext *s, unsigned int val)
+{
+    put_le16(s, val &amp; 0xffff);
+    put_byte(s, val &gt;&gt; 16);
+}
+
 void put_be24(ByteIOContext *s, unsigned int val)
 {
     put_be16(s, val &gt;&gt; 8);
@@ -254,7 +254,6 @@
         put_byte(s, *tag++);
     }
 }
-#endif //CONFIG_MUXERS
 
 /* Input stream */
 
@@ -295,7 +294,7 @@
 void init_checksum(ByteIOContext *s, unsigned long (*update_checksum)(unsigned long c, const uint8_t *p, unsigned int len), unsigned long checksum){
     s-&gt;update_checksum= update_checksum;
     if(s-&gt;update_checksum){
-        s-&gt;checksum= s-&gt;update_checksum(checksum, NULL, 0);
+        s-&gt;checksum= checksum;
         s-&gt;checksum_ptr= s-&gt;buf_ptr;
     }
 }
@@ -399,6 +398,14 @@
     return val;
 }
 
+unsigned int get_le24(ByteIOContext *s)
+{
+    unsigned int val;
+    val = get_le16(s);
+    val |= get_byte(s) &lt;&lt; 16;
+    return val;
+}
+
 unsigned int get_le32(ByteIOContext *s)
 {
     unsigned int val;
@@ -616,7 +623,9 @@
     return s-&gt;max_packet_size;
 }
 
-#ifdef CONFIG_MUXERS
+/* url_open_dyn_buf and url_close_dyn_buf are used in rtp.c to send a response
+ * back to the server even if CONFIG_MUXERS is not set. */
+#if defined(CONFIG_MUXERS) || defined(CONFIG_NETWORK)
 /* buffer handling */
 int url_open_buf(ByteIOContext *s, uint8_t *buf, int buf_size, int flags)
 {
@@ -779,4 +788,4 @@
     av_free(d);
     return size;
 }
-#endif //CONFIG_MUXERS
+#endif /* CONFIG_MUXERS || CONFIG_NETWORK */

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/cutils.c
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/cutils.c	2007-01-20 15:15:58 UTC (rev 2746)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/cutils.c	2007-01-21 18:04:24 UTC (rev 2747)
@@ -2,19 +2,21 @@
  * Various simple utilities for ffmpeg system
  * Copyright (c) 2000, 2001, 2002 Fabrice Bellard
  *
- * This library is free software; you can redistribute it and/or
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
  * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
+ * version 2.1 of the License, or (at your option) any later version.
  *
- * This library is distributed in the hope that it will be useful,
+ * FFmpeg is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  * Lesser General Public License for more details.
  *
  * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 #include &quot;avformat.h&quot;
 
@@ -59,7 +61,7 @@
     p = str;
     q = val;
     while (*q != '\0') {
-	if (toupper(*(const unsigned char *)p) != toupper(*(const unsigned char *)q))
+        if (toupper(*(const unsigned char *)p) != toupper(*(const unsigned char *)q))
             return 0;
         p++;
         q++;
@@ -74,7 +76,7 @@
  * 1 then it is clamped to buf_size - 1.
  * NOTE: this function does what strncpy should have done to be
  * useful. NEVER use strncpy.
- * 
+ *
  * @param buf destination buffer
  * @param buf_size size of destination buffer
  * @param str source string
@@ -101,7 +103,7 @@
 {
     int len;
     len = strlen(buf);
-    if (len &lt; buf_size) 
+    if (len &lt; buf_size)
         pstrcpy(buf + len, buf_size - len, s);
     return buf;
 }
@@ -139,7 +141,7 @@
         y--;
     }
 
-    t = 86400 * 
+    t = 86400 *
         (d + (153 * m - 457) / 5 + 365 * y + y / 4 - y / 100 + y / 400 - 719469);
 
     t += 3600 * tm-&gt;tm_hour + 60 * tm-&gt;tm_min + tm-&gt;tm_sec;
@@ -150,10 +152,10 @@
 #define ISLEAP(y) (((y) % 4 == 0) &amp;&amp; (((y) % 100) != 0 || ((y) % 400) == 0))
 #define LEAPS_COUNT(y) ((y)/4 - (y)/100 + (y)/400)
 
-/* this is our own gmtime_r. it differs from its POSIX counterpart in a 
+/* this is our own gmtime_r. it differs from its POSIX counterpart in a
    couple of places, though. */
 struct tm *brktimegm(time_t secs, struct tm *tm)
-{   
+{
     int days, y, ny, m;
     int md[] = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };
 
@@ -166,13 +168,13 @@
     /* oh well, may be someone some day will invent a formula for this stuff */
     y = 1970; /* start &quot;guessing&quot; */
     while (days &gt;= (ISLEAP(y)?366:365)) {
-	ny = (y + days/366);
-	days -= (ny - y) * 365 + LEAPS_COUNT(ny - 1) - LEAPS_COUNT(y - 1);
-	y = ny;
+        ny = (y + days/366);
+        days -= (ny - y) * 365 + LEAPS_COUNT(ny - 1) - LEAPS_COUNT(y - 1);
+        y = ny;
     }
     md[1] = ISLEAP(y)?29:28;
     for (m=0; days &gt;= md[m]; m++)
-	 days -= md[m];
+         days -= md[m];
 
     tm-&gt;tm_year = y;  /* unlike gmtime_r we store complete year here */
     tm-&gt;tm_mon = m+1; /* unlike gmtime_r tm_mon is from 1 to 12 */
@@ -208,7 +210,7 @@
 }
 
 /* small strptime for ffmpeg */
-const char *small_strptime(const char *p, const char *fmt, 
+const char *small_strptime(const char *p, const char *fmt,
                            struct tm *dt)
 {
     int c, val;

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/file.c
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/file.c	2007-01-20 15:15:58 UTC (rev 2746)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/file.c	2007-01-21 18:04:24 UTC (rev 2747)
@@ -2,33 +2,26 @@
  * Buffered file io for ffmpeg system
  * Copyright (c) 2001 Fabrice Bellard
  *
- * This library is free software; you can redistribute it and/or
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
  * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
+ * version 2.1 of the License, or (at your option) any later version.
  *
- * This library is distributed in the hope that it will be useful,
+ * FFmpeg is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  * Lesser General Public License for more details.
  *
  * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 #include &quot;avformat.h&quot;
 #include &lt;fcntl.h&gt;
-#ifdef CYG_MANGLING
-#define CONFIG_WIN32
-#endif
-#ifndef CONFIG_WIN32
 #include &lt;unistd.h&gt;
-#include &lt;sys/ioctl.h&gt;
 #include &lt;sys/time.h&gt;
-#else
-#include &lt;io.h&gt;
-#define open(fname,oflag,pmode) _open(fname,oflag,pmode)
-#endif /* CONFIG_WIN32 */
 
 
 /* standard file protocol */
@@ -47,7 +40,7 @@
     } else {
         access = O_RDONLY;
     }
-#if defined(CONFIG_WIN32) || defined(CONFIG_OS2) || defined(__CYGWIN__)
+#if defined(__MINGW32__) || defined(CONFIG_OS2) || defined(__CYGWIN__)
     access |= O_BINARY;
 #endif
     fd = open(filename, access, 0666);
@@ -73,11 +66,7 @@
 static offset_t file_seek(URLContext *h, offset_t pos, int whence)
 {
     int fd = (size_t)h-&gt;priv_data;
-#if defined(CONFIG_WIN32) &amp;&amp; !defined(__CYGWIN__) 
-    return _lseeki64(fd, pos, whence);
-#else
     return lseek(fd, pos, whence);
-#endif
 }
 
 static int file_close(URLContext *h)
@@ -106,7 +95,7 @@
     } else {
         fd = 0;
     }
-#if defined(CONFIG_WIN32) || defined(CONFIG_OS2) || defined(__CYGWIN__)
+#if defined(__MINGW32__) || defined(CONFIG_OS2) || defined(__CYGWIN__)
     setmode(fd, O_BINARY);
 #endif
     h-&gt;priv_data = (void *)(size_t)fd;

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/img2.c
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/img2.c	2007-01-20 15:15:58 UTC (rev 2746)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/img2.c	2007-01-21 18:04:24 UTC (rev 2747)
@@ -3,25 +3,24 @@
  * Copyright (c) 2000, 2001, 2002 Fabrice Bellard.
  * Copyright (c) 2004 Michael Niedermayer
  *
- * This library is free software; you can redistribute it and/or
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
  * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
+ * version 2.1 of the License, or (at your option) any later version.
  *
- * This library is distributed in the hope that it will be useful,
+ * FFmpeg is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  * Lesser General Public License for more details.
  *
  * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 #include &quot;avformat.h&quot;
 
-/* XXX: this is a hack */
-int loop_input; //MEANX
-
 typedef struct {
     int img_first;
     int img_last;
@@ -51,6 +50,10 @@
     { CODEC_ID_MPEG4     , &quot;mpg4-img&quot;},
     { CODEC_ID_FFV1      , &quot;ffv1-img&quot;},
     { CODEC_ID_RAWVIDEO  , &quot;y&quot;},
+    { CODEC_ID_BMP       , &quot;bmp&quot;},
+    { CODEC_ID_GIF       , &quot;gif&quot;},
+    { CODEC_ID_TARGA     , &quot;tga&quot;},
+    { CODEC_ID_TIFF      , &quot;tiff&quot;},
     {0, NULL}
 };
 
@@ -98,7 +101,7 @@
 }
 
 /* return -1 if no image found */
-static int find_image_range(int *pfirst_index, int *plast_index, 
+static int find_image_range(int *pfirst_index, int *plast_index,
                             const char *path)
 {
     char buf[1024];
@@ -106,8 +109,8 @@
 
     /* find the first image */
     for(first_index = 0; first_index &lt; 5; first_index++) {
-        if (get_frame_filename(buf, sizeof(buf), path, first_index) &lt; 0){
-            *pfirst_index = 
+        if (av_get_frame_filename(buf, sizeof(buf), path, first_index) &lt; 0){
+            *pfirst_index =
             *plast_index = 1;
             return 0;
         }
@@ -116,7 +119,7 @@
     }
     if (first_index == 5)
         goto fail;
-    
+
     /* find the last image */
     last_index = first_index;
     for(;;) {
@@ -126,8 +129,8 @@
                 range1 = 1;
             else
                 range1 = 2 * range;
-            if (get_frame_filename(buf, sizeof(buf), path, 
-                                   last_index + range1) &lt; 0)
+            if (av_get_frame_filename(buf, sizeof(buf), path,
+                                      last_index + range1) &lt; 0)
                 goto fail;
             if (!url_exist(buf))
                 break;
@@ -151,10 +154,13 @@
 
 static int image_probe(AVProbeData *p)
 {
-    if (filename_number_test(p-&gt;filename) &gt;= 0 &amp;&amp; av_str2id(img_tags, p-&gt;filename))
-        return AVPROBE_SCORE_MAX;
-    else
-        return 0;
+    if (p-&gt;filename &amp;&amp; av_str2id(img_tags, p-&gt;filename)) {
+        if (av_filename_number_test(p-&gt;filename))
+            return AVPROBE_SCORE_MAX;
+        else
+            return AVPROBE_SCORE_MAX/2;
+    }
+    return 0;
 }
 
 enum CodecID av_guess_image2_codec(const char *filename){
@@ -177,7 +183,7 @@
     pstrcpy(s-&gt;path, sizeof(s-&gt;path), s1-&gt;filename);
     s-&gt;img_number = 0;
     s-&gt;img_count = 0;
-    
+
     /* find format */
     if (s1-&gt;iformat-&gt;flags &amp; AVFMT_NOFILE)
         s-&gt;is_pipe = 0;
@@ -185,28 +191,18 @@
         s-&gt;is_pipe = 1;
         st-&gt;need_parsing= 1;
     }
-        
-    if (!ap || !ap-&gt;time_base.num) {
+
+    if (!ap-&gt;time_base.num) {
         av_set_pts_info(st, 60, 1, 25);
     } else {
         av_set_pts_info(st, 60, ap-&gt;time_base.num, ap-&gt;time_base.den);
     }
-#if 0 
-#warning BROKEN
-#warning BROKEN
-#warning BROKEN
-#warning BROKEN
-#warning BROKEN
-#warning BROKEN
-#warning BROKEN
-#warning BROKEN
-#warning BROKEN
-#warning BROKEN
-    if(ap &amp;&amp; ap-&gt;width &amp;&amp; ap-&gt;height){
-        st-&gt;codec.width = ap-&gt;width;
-        st-&gt;codec.height= ap-&gt;height;
+
+    if(ap-&gt;width &amp;&amp; ap-&gt;height){
+        st-&gt;codec-&gt;width = ap-&gt;width;
+        st-&gt;codec-&gt;height= ap-&gt;height;
     }
-    
+
     if (!s-&gt;is_pipe) {
         if (find_image_range(&amp;first_index, &amp;last_index, s-&gt;path) &lt; 0)
             return AVERROR_IO;
@@ -217,20 +213,20 @@
         st-&gt;start_time = 0;
         st-&gt;duration = last_index - first_index + 1;
     }
-    
+
     if(ap-&gt;video_codec_id){
-        st-&gt;codec.codec_type = CODEC_TYPE_VIDEO;
-        st-&gt;codec.codec_id = ap-&gt;video_codec_id;
+        st-&gt;codec-&gt;codec_type = CODEC_TYPE_VIDEO;
+        st-&gt;codec-&gt;codec_id = ap-&gt;video_codec_id;
     }else if(ap-&gt;audio_codec_id){
-        st-&gt;codec.codec_type = CODEC_TYPE_AUDIO;
-        st-&gt;codec.codec_id = ap-&gt;audio_codec_id;
+        st-&gt;codec-&gt;codec_type = CODEC_TYPE_AUDIO;
+        st-&gt;codec-&gt;codec_id = ap-&gt;audio_codec_id;
     }else{
-        st-&gt;codec.codec_type = CODEC_TYPE_VIDEO;
-        st-&gt;codec.codec_id = av_str2id(img_tags, s-&gt;path);
+        st-&gt;codec-&gt;codec_type = CODEC_TYPE_VIDEO;
+        st-&gt;codec-&gt;codec_id = av_str2id(img_tags, s-&gt;path);
     }
-    if(st-&gt;codec.codec_type == CODEC_TYPE_VIDEO &amp;&amp; ap-&gt;pix_fmt != PIX_FMT_NONE)
-        st-&gt;codec.pix_fmt = ap-&gt;pix_fmt;
-#endif
+    if(st-&gt;codec-&gt;codec_type == CODEC_TYPE_VIDEO &amp;&amp; ap-&gt;pix_fmt != PIX_FMT_NONE)
+        st-&gt;codec-&gt;pix_fmt = ap-&gt;pix_fmt;
+
     return 0;
 }
 
@@ -241,26 +237,26 @@
     int i;
     int size[3]={0}, ret[3]={0};
     ByteIOContext f1[3], *f[3]= {&amp;f1[0], &amp;f1[1], &amp;f1[2]};
-    AVCodecContext *codec= &amp;s1-&gt;streams[0]-&gt;codec;
+    AVCodecContext *codec= s1-&gt;streams[0]-&gt;codec;
 
     if (!s-&gt;is_pipe) {
         /* loop over input */
-        if (loop_input &amp;&amp; s-&gt;img_number &gt; s-&gt;img_last) {
+        if (s1-&gt;loop_input &amp;&amp; s-&gt;img_number &gt; s-&gt;img_last) {
             s-&gt;img_number = s-&gt;img_first;
         }
-        if (get_frame_filename(filename, sizeof(filename),
-                               s-&gt;path, s-&gt;img_number)&lt;0 &amp;&amp; s-&gt;img_number &gt; 1)
+        if (av_get_frame_filename(filename, sizeof(filename),
+                                  s-&gt;path, s-&gt;img_number)&lt;0 &amp;&amp; s-&gt;img_number &gt; 1)
             return AVERROR_IO;
         for(i=0; i&lt;3; i++){
             if (url_fopen(f[i], filename, URL_RDONLY) &lt; 0)
                 return AVERROR_IO;
-            size[i]= url_filesize(url_fileno(f[i]));
-            
+            size[i]= url_fsize(f[i]);
+
             if(codec-&gt;codec_id != CODEC_ID_RAWVIDEO)
                 break;
             filename[ strlen(filename) - 1 ]= 'U' + i;
         }
-        
+
         if(codec-&gt;codec_id == CODEC_ID_RAWVIDEO &amp;&amp; !codec-&gt;width)
             infer_size(&amp;codec-&gt;width, &amp;codec-&gt;height, size[0]);
     } else {
@@ -300,6 +296,7 @@
     return 0;
 }
 
+#ifdef CONFIG_MUXERS
 /******************************************************/
 /* image output */
 
@@ -315,7 +312,7 @@
         img-&gt;is_pipe = 0;
     else
         img-&gt;is_pipe = 1;
-        
+
     return 0;
 }
 
@@ -324,17 +321,17 @@
     VideoData *img = s-&gt;priv_data;
     ByteIOContext pb1[3], *pb[3]= {&amp;pb1[0], &amp;pb1[1], &amp;pb1[2]};
     char filename[1024];
-    AVCodecContext *codec= &amp;s-&gt;streams[ pkt-&gt;stream_index ]-&gt;codec;
+    AVCodecContext *codec= s-&gt;streams[ pkt-&gt;stream_index ]-&gt;codec;
     int i;
 
     if (!img-&gt;is_pipe) {
-        if (get_frame_filename(filename, sizeof(filename), 
-                               img-&gt;path, img-&gt;img_number) &lt; 0 &amp;&amp; img-&gt;img_number&gt;1)
+        if (av_get_frame_filename(filename, sizeof(filename),
+                                  img-&gt;path, img-&gt;img_number) &lt; 0 &amp;&amp; img-&gt;img_number&gt;1)
             return AVERROR_IO;
         for(i=0; i&lt;3; i++){
             if (url_fopen(pb[i], filename, URL_WRONLY) &lt; 0)
                 return AVERROR_IO;
-        
+
             if(codec-&gt;codec_id != CODEC_ID_RAWVIDEO)
                 break;
             filename[ strlen(filename) - 1 ]= 'U' + i;
@@ -342,7 +339,7 @@
     } else {
         pb[0] = &amp;s-&gt;pb;
     }
-    
+
     if(codec-&gt;codec_id == CODEC_ID_RAWVIDEO){
         int ysize = codec-&gt;width * codec-&gt;height;
         put_buffer(pb[0], pkt-&gt;data        , ysize);
@@ -369,9 +366,11 @@
     return 0;
 }
 
-/* input */
+#endif /* CONFIG_MUXERS */
 
-static AVInputFormat image2_iformat = {
+/* input */
+#ifdef CONFIG_IMAGE2_DEMUXER
+AVInputFormat image2_demuxer = {
     &quot;image2&quot;,
     &quot;image2 sequence&quot;,
     sizeof(VideoData),
@@ -383,8 +382,9 @@
     NULL,
     AVFMT_NOFILE,
 };
-
-static AVInputFormat image2pipe_iformat = {
+#endif
+#ifdef CONFIG_IMAGE2PIPE_DEMUXER
+AVInputFormat image2pipe_demuxer = {
     &quot;image2pipe&quot;,
     &quot;piped image2 sequence&quot;,
     sizeof(VideoData),
@@ -394,11 +394,11 @@
     img_read_close,
     NULL,
 };
+#endif
 
-
 /* output */
-
-static AVOutputFormat image2_oformat = {
+#ifdef CONFIG_IMAGE2_MUXER
+AVOutputFormat image2_muxer = {
     &quot;image2&quot;,
     &quot;image2 sequence&quot;,
     &quot;&quot;,
@@ -411,8 +411,9 @@
     img_write_trailer,
     AVFMT_NOFILE,
 };
-
-static AVOutputFormat image2pipe_oformat = {
+#endif
+#ifdef CONFIG_IMAGE2PIPE_MUXER
+AVOutputFormat image2pipe_muxer = {
     &quot;image2pipe&quot;,
     &quot;piped image2 sequence&quot;,
     &quot;&quot;,
@@ -424,14 +425,4 @@
     img_write_packet,
     img_write_trailer,
 };
-
-int img2_init(void)
-{
-    av_register_input_format(&amp;image2_iformat);
-    av_register_output_format(&amp;image2_oformat);
-
-    av_register_input_format(&amp;image2pipe_iformat);
-    av_register_output_format(&amp;image2pipe_oformat);
-    
-    return 0;
-}
+#endif

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/isom.c
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/isom.c	2007-01-20 15:15:58 UTC (rev 2746)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/isom.c	2007-01-21 18:04:24 UTC (rev 2747)
@@ -4,18 +4,20 @@
  * Copyright (c) 2002 Francois Revol &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">revol at free.fr</A>&gt;
  * Copyright (c) 2006 Baptiste Coudurier &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">baptiste.coudurier at free.fr</A>&gt;
  *
- * This library is free software; you can redistribute it and/or
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
  * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
+ * version 2.1 of the License, or (at your option) any later version.
  *
- * This library is distributed in the hope that it will be useful,
+ * FFmpeg is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  * Lesser General Public License for more details.
  *
  * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
+ * License along with FFmpeg; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
@@ -24,7 +26,7 @@
 #include &quot;isom.h&quot;
 
 /* <A HREF="http://gpac.sourceforge.net/tutorial/mediatypes.htm">http://gpac.sourceforge.net/tutorial/mediatypes.htm</A> */
-const CodecTag ff_mov_obj_type[] = {
+const AVCodecTag ff_mov_obj_type[] = {
     { CODEC_ID_MPEG4     ,  32 },
     { CODEC_ID_H264      ,  33 },
     { CODEC_ID_AAC       ,  64 },
@@ -37,13 +39,13 @@
     { CODEC_ID_AAC       , 102 }, /* MPEG2 AAC Main */
     { CODEC_ID_AAC       , 103 }, /* MPEG2 AAC Low */
     { CODEC_ID_AAC       , 104 }, /* MPEG2 AAC SSR */
-    { CODEC_ID_MP3       , 107 }, // MEANX Compatibility with xine was 105
+    { CODEC_ID_MP3       , 105 },
     { CODEC_ID_MPEG1VIDEO, 106 },
     { CODEC_ID_MP2       , 107 },
     { CODEC_ID_MJPEG     , 108 },
     { CODEC_ID_PCM_S16LE , 224 },
     { CODEC_ID_VORBIS    , 221 },
-//MEANX    { CODEC_ID_QCELP     , 225 },
+    { CODEC_ID_QCELP     , 225 },
     { CODEC_ID_AC3       , 226 },
     { CODEC_ID_PCM_ALAW  , 227 },
     { CODEC_ID_PCM_MULAW , 228 },

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/isom.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/isom.h	2007-01-20 15:15:58 UTC (rev 2746)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/isom.h	2007-01-21 18:04:24 UTC (rev 2747)
@@ -1,3 +1,26 @@
+/*
+ * ISO Media common code
+ * copyright (c) 2001 Fabrice Bellard.
+ * copyright (c) 2002 Francois Revol &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">revol at free.fr</A>&gt;
+ * copyright (c) 2006 Baptiste Coudurier &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">baptiste.coudurier at free.fr</A>&gt;
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
 #ifndef FFMPEG_ISOM_H
 #define FFMPEG_ISOM_H
 
@@ -2,3 +25,3 @@
 /* isom.c */
-extern const CodecTag ff_mov_obj_type[];
+extern const AVCodecTag ff_mov_obj_type[];
 

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/matroska.c
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/matroska.c	2007-01-20 15:15:58 UTC (rev 2746)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/matroska.c	2007-01-21 18:04:24 UTC (rev 2747)
@@ -2,18 +2,20 @@
  * Matroska file demuxer (no muxer yet)
  * Copyright (c) 2003-2004 The ffmpeg Project
  *
- * This library is free software; you can redistribute it and/or
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
  * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
+ * version 2.1 of the License, or (at your option) any later version.
  *
- * This library is distributed in the hope that it will be useful,
+ * FFmpeg is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  * Lesser General Public License for more details.
  *
  * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
+ * License along with FFmpeg; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
@@ -67,6 +69,7 @@
 /* IDs in the info master */
 #define MATROSKA_ID_TIMECODESCALE 0x2AD7B1
 #define MATROSKA_ID_DURATION   0x4489
+#define MATROSKA_ID_TITLE      0x7BA9
 #define MATROSKA_ID_WRITINGAPP 0x5741
 #define MATROSKA_ID_MUXINGAPP  0x4D80
 #define MATROSKA_ID_DATEUTC    0x4461
@@ -107,6 +110,8 @@
 
 /* IDs in the trackaudio master */
 #define MATROSKA_ID_AUDIOSAMPLINGFREQ 0xB5
+#define MATROSKA_ID_AUDIOOUTSAMPLINGFREQ 0x78B5
+
 #define MATROSKA_ID_AUDIOBITDEPTH 0x6264
 #define MATROSKA_ID_AUDIOCHANNELS 0x9F
 
@@ -171,6 +176,7 @@
   MATROSKA_TRACK_ENABLED = (1&lt;&lt;0),
   MATROSKA_TRACK_DEFAULT = (1&lt;&lt;1),
   MATROSKA_TRACK_LACING  = (1&lt;&lt;2),
+  MATROSKA_TRACK_REAL_V  = (1&lt;&lt;4),
   MATROSKA_TRACK_SHIFT   = (1&lt;&lt;16)
 } MatroskaTrackFlags;
 
@@ -217,8 +223,10 @@
     {&quot;A_AC3&quot;            , CODEC_ID_AC3},
     {&quot;A_DTS&quot;            , CODEC_ID_DTS},
     {&quot;A_VORBIS&quot;         , CODEC_ID_VORBIS},
-    {&quot;A_AAC/MPEG2/&quot;     , CODEC_ID_AAC},
-    {&quot;A_AAC/MPEG4/&quot;     , CODEC_ID_AAC},
+    {&quot;A_AAC&quot;            , CODEC_ID_AAC},
+    {&quot;A_FLAC&quot;           , CODEC_ID_FLAC},
+    {&quot;A_WAVPACK4&quot;       , CODEC_ID_WAVPACK},
+    {&quot;A_TTA1&quot;           , CODEC_ID_TTA},
     {NULL               , CODEC_ID_NONE}
 /* TODO: AC3-9/10 (?), Real, Musepack, Quicktime */
 };
@@ -269,6 +277,7 @@
 
     int channels,
         bitdepth,
+        internal_samplerate,
         samplerate;
     //..
 } MatroskaAudioTrack;
@@ -627,10 +636,6 @@
         *num= av_int2flt(get_be32(pb));
     } else if(size==8){
         *num= av_int2dbl(get_be64(pb));
-    } else if(size==10){
-        av_log(matroska-&gt;ctx, AV_LOG_ERROR,
-               &quot;FIXME! 10-byte floats unimplemented\n&quot;);
-        return AVERROR_UNKNOWN;
     } else{
         offset_t pos = url_ftell(pb);
         av_log(matroska-&gt;ctx, AV_LOG_ERROR,
@@ -986,8 +991,7 @@
                 av_realloc(matroska-&gt;packets, (matroska-&gt;num_packets - 1) *
                            sizeof(AVPacket *));
         } else {
-            av_free(matroska-&gt;packets);
-            matroska-&gt;packets = NULL;
+            av_freep(&amp;matroska-&gt;packets);
         }
         matroska-&gt;num_packets--;
         return 0;
@@ -1097,6 +1101,16 @@
                 break;
             }
 
+            case MATROSKA_ID_TITLE: {
+                char *text;
+                if ((res = ebml_read_utf8(matroska, &amp;id, &amp;text)) &lt; 0)
+                    break;
+                strncpy(matroska-&gt;ctx-&gt;title, text,
+                        sizeof(matroska-&gt;ctx-&gt;title)-1);
+                av_free(text);
+                break;
+            }
+
             case MATROSKA_ID_WRITINGAPP: {
                 char *text;
                 if ((res = ebml_read_utf8(matroska, &amp;id, &amp;text)) &lt; 0)
@@ -1423,10 +1437,20 @@
                             if ((res = ebml_read_float(matroska, &amp;id,
                                                        &amp;num)) &lt; 0)
                                 break;
+                            audiotrack-&gt;internal_samplerate =
                             audiotrack-&gt;samplerate = num;
                             break;
                         }
 
+                        case MATROSKA_ID_AUDIOOUTSAMPLINGFREQ: {
+                            double num;
+                            if ((res = ebml_read_float(matroska, &amp;id,
+                                                       &amp;num)) &lt; 0)
+                                break;
+                            audiotrack-&gt;samplerate = num;
+                            break;
+                        }
+
                             /* bitdepth */
                         case MATROSKA_ID_AUDIOBITDEPTH: {
                             uint64_t num;
@@ -1667,7 +1691,7 @@
                     switch (id) {
                         /* one single index entry ('point') */
                         case MATROSKA_ID_CUETIME: {
-                            int64_t time;
+                            uint64_t time;
                             if ((res = ebml_read_uint(matroska, &amp;id,
                                                       &amp;time)) &lt; 0)
                                 break;
@@ -1920,7 +1944,7 @@
                         /* check ID */
                         if (!(id = ebml_peek_id (matroska,
                                                  &amp;matroska-&gt;level_up)))
-                            break;
+                            goto finish;
                         if (id != seek_id) {
                             av_log(matroska-&gt;ctx, AV_LOG_INFO,
                                    &quot;We looked for ID=0x%x but got &quot;
@@ -1932,7 +1956,7 @@
 
                         /* read master + parse */
                         if ((res = ebml_read_master(matroska, &amp;id)) &lt; 0)
-                            break;
+                            goto finish;
                         switch (id) {
                             case MATROSKA_ID_CUES:
                                 if (!(res = matroska_parse_index(matroska)) ||
@@ -1949,8 +1973,6 @@
                                 }
                                 break;
                         }
-                        if (res &lt; 0)
-                            break;
 
                     finish:
                         /* remove dummy level */
@@ -1999,7 +2021,38 @@
     return res;
 }
 
+#define ARRAY_SIZE(x)  (sizeof(x)/sizeof(*x))
+
 static int
+matroska_aac_profile (char *codec_id)
+{
+    static const char *aac_profiles[] = {
+        &quot;MAIN&quot;, &quot;LC&quot;, &quot;SSR&quot;
+    };
+    int profile;
+
+    for (profile=0; profile&lt;ARRAY_SIZE(aac_profiles); profile++)
+        if (strstr(codec_id, aac_profiles[profile]))
+            break;
+    return profile + 1;
+}
+
+static int
+matroska_aac_sri (int samplerate)
+{
+    static const int aac_sample_rates[] = {
+        96000, 88200, 64000, 48000, 44100, 32000,
+        24000, 22050, 16000, 12000, 11025,  8000,
+    };
+    int sri;
+
+    for (sri=0; sri&lt;ARRAY_SIZE(aac_sample_rates); sri++)
+        if (aac_sample_rates[sri] == samplerate)
+            break;
+    return sri;
+}
+
+static int
 matroska_read_header (AVFormatContext    *s,
                       AVFormatParameters *ap)
 {
@@ -2133,19 +2186,17 @@
         }
     }
 
-    if (res &lt; 0)
-        return res;
-
     /* Have we found a cluster? */
-    if (res == 1) {
+    if (ebml_peek_id(matroska, NULL) == MATROSKA_ID_CLUSTER) {
         int i, j;
-        enum CodecID codec_id= CODEC_ID_NONE;
         MatroskaTrack *track;
         AVStream *st;
 
         for (i = 0; i &lt; matroska-&gt;num_tracks; i++) {
-            void *extradata = NULL;
+            enum CodecID codec_id = CODEC_ID_NONE;
+            uint8_t *extradata = NULL;
             int extradata_size = 0;
+            int extradata_offset = 0;
             track = matroska-&gt;tracks[i];
 
             /* libavformat does not really support subtitles.
@@ -2155,7 +2206,8 @@
                 continue;
 
             for(j=0; codec_tags[j].str; j++){
-                if(!strcmp(codec_tags[j].str, track-&gt;codec_id)){
+                if(!strncmp(codec_tags[j].str, track-&gt;codec_id,
+                            strlen(codec_tags[j].str))){
                     codec_id= codec_tags[j].id;
                     break;
                 }
@@ -2194,6 +2246,50 @@
 
             }
 
+            else if (codec_id == CODEC_ID_AAC &amp;&amp; !track-&gt;codec_priv_size) {
+                MatroskaAudioTrack *audiotrack = (MatroskaAudioTrack *) track;
+                int profile = matroska_aac_profile(track-&gt;codec_id);
+                int sri = matroska_aac_sri(audiotrack-&gt;internal_samplerate);
+                extradata = av_malloc(5);
+                if (extradata == NULL)
+                    return AVERROR_NOMEM;
+                extradata[0] = (profile &lt;&lt; 3) | ((sri&amp;0x0E) &gt;&gt; 1);
+                extradata[1] = ((sri&amp;0x01) &lt;&lt; 7) | (audiotrack-&gt;channels&lt;&lt;3);
+                if (strstr(track-&gt;codec_id, &quot;SBR&quot;)) {
+                    sri = matroska_aac_sri(audiotrack-&gt;samplerate);
+                    extradata[2] = 0x56;
+                    extradata[3] = 0xE5;
+                    extradata[4] = 0x80 | (sri&lt;&lt;3);
+                    extradata_size = 5;
+                } else {
+                    extradata_size = 2;
+                }
+            }
+
+            else if (codec_id == CODEC_ID_TTA) {
+                MatroskaAudioTrack *audiotrack = (MatroskaAudioTrack *) track;
+                ByteIOContext b;
+                extradata_size = 30;
+                extradata = av_mallocz(extradata_size);
+                if (extradata == NULL)
+                    return AVERROR_NOMEM;
+                init_put_byte(&amp;b, extradata, extradata_size, 1,
+                              NULL, NULL, NULL, NULL);
+                put_buffer(&amp;b, (uint8_t *) &quot;TTA1&quot;, 4);
+                put_le16(&amp;b, 1);
+                put_le16(&amp;b, audiotrack-&gt;channels);
+                put_le16(&amp;b, audiotrack-&gt;bitdepth);
+                put_le32(&amp;b, audiotrack-&gt;samplerate);
+                put_le32(&amp;b, matroska-&gt;ctx-&gt;duration * audiotrack-&gt;samplerate);
+            }
+
+            else if (codec_id == CODEC_ID_RV10 || codec_id == CODEC_ID_RV20 ||
+                     codec_id == CODEC_ID_RV30 || codec_id == CODEC_ID_RV40) {
+                extradata_offset = 26;
+                track-&gt;codec_priv_size -= extradata_offset;
+                track-&gt;flags |= MATROSKA_TRACK_REAL_V;
+            }
+
             if (codec_id == CODEC_ID_NONE) {
                 av_log(matroska-&gt;ctx, AV_LOG_INFO,
                        &quot;Unknown/unsupported CodecID %s.\n&quot;,
@@ -2210,6 +2306,10 @@
 
             st-&gt;codec-&gt;codec_id = codec_id;
 
+            if (track-&gt;default_duration)
+                av_reduce(&amp;st-&gt;codec-&gt;time_base.num, &amp;st-&gt;codec-&gt;time_base.den,
+                          track-&gt;default_duration, 1000000000, 30000);
+
             if(extradata){
                 st-&gt;codec-&gt;extradata = extradata;
                 st-&gt;codec-&gt;extradata_size = extradata_size;
@@ -2218,7 +2318,7 @@
                 if(st-&gt;codec-&gt;extradata == NULL)
                     return AVERROR_NOMEM;
                 st-&gt;codec-&gt;extradata_size = track-&gt;codec_priv_size;
-                memcpy(st-&gt;codec-&gt;extradata, track-&gt;codec_priv,
+                memcpy(st-&gt;codec-&gt;extradata,track-&gt;codec_priv+extradata_offset,
                        track-&gt;codec_priv_size);
             }
 
@@ -2250,9 +2350,10 @@
 
             /* What do we do with private data? E.g. for Vorbis. */
         }
+        res = 0;
     }
 
-    return 0;
+    return res;
 }
 
 static int
@@ -2268,14 +2369,22 @@
     return -1;
 }
 
+static inline int
+rv_offset(uint8_t *data, int slice, int slices)
+{
+    return AV_RL32(data+8*slice+4) + 8*slices;
+}
+
 static int
 matroska_parse_blockgroup (MatroskaDemuxContext *matroska,
                            uint64_t              cluster_time)
 {
     int res = 0;
     uint32_t id;
-    AVPacket *pkt;
+    AVPacket *pkt = NULL;
     int is_keyframe = PKT_FLAG_KEY, last_num_packets = matroska-&gt;num_packets;
+    uint64_t duration = AV_NOPTS_VALUE;
+    int track = -1;
 
     av_log(matroska-&gt;ctx, AV_LOG_DEBUG, &quot;parsing blockgroup...\n&quot;);
 
@@ -2297,7 +2406,7 @@
                 int size;
                 int16_t block_time;
                 uint32_t *lace_size = NULL;
-                int n, track, flags, laces = 0;
+                int n, flags, laces = 0;
                 uint64_t num;
                 int64_t pos= url_ftell(&amp;matroska-&gt;ctx-&gt;pb);
 
@@ -2305,7 +2414,7 @@
                     break;
                 origdata = data;
 
-                /* first byte(s): blocknum */
+                /* first byte(s): tracknum */
                 if ((n = matroska_ebmlnum_uint(data, size, &amp;num)) &lt; 0) {
                     av_log(matroska-&gt;ctx, AV_LOG_ERROR,
                            &quot;EBML block data error\n&quot;);
@@ -2416,32 +2525,49 @@
                 }
 
                 if (res == 0) {
+                    int real_v = matroska-&gt;tracks[track]-&gt;flags &amp; MATROSKA_TRACK_REAL_V;
                     for (n = 0; n &lt; laces; n++) {
                         uint64_t timecode = AV_NOPTS_VALUE;
+                        int slice, slices = 1;
 
-                        pkt = av_mallocz(sizeof(AVPacket));
-                        /* XXX: prevent data copy... */
-                        if (av_new_packet(pkt,lace_size[n]) &lt; 0) {
-                            res = AVERROR_NOMEM;
-                            break;
+                        if (real_v) {
+                            slices = *data++ + 1;
+                            lace_size[n]--;
                         }
                         if (cluster_time != (uint64_t)-1 &amp;&amp; n == 0) {
                             if (cluster_time + block_time &gt;= 0)
-                                timecode = cluster_time + block_time;
+                                timecode = (cluster_time + block_time) * matroska-&gt;time_scale;
                         }
                         /* FIXME: duration */
 
-                        memcpy(pkt-&gt;data, data, lace_size[n]);
-                        data += lace_size[n];
-                        if (n == 0)
-                            pkt-&gt;flags = is_keyframe;
-                        pkt-&gt;stream_index =
-                            matroska-&gt;tracks[track]-&gt;stream_index;
+                        for (slice=0; slice&lt;slices; slice++) {
+                            int slice_size, slice_offset = 0;
+                            if (real_v)
+                                slice_offset = rv_offset(data, slice, slices);
+                            if (slice+1 == slices)
+                                slice_size = lace_size[n] - slice_offset;
+                            else
+                                slice_size = rv_offset(data, slice+1, slices) - slice_offset;
+                            pkt = av_mallocz(sizeof(AVPacket));
+                            /* XXX: prevent data copy... */
+                            if (av_new_packet(pkt, slice_size) &lt; 0) {
+                                res = AVERROR_NOMEM;
+                                n = laces-1;
+                                break;
+                            }
+                            memcpy (pkt-&gt;data, data+slice_offset, slice_size);
 
-                        pkt-&gt;pts = timecode;
-                        pkt-&gt;pos= pos;
+                            if (n == 0)
+                                pkt-&gt;flags = is_keyframe;
+                            pkt-&gt;stream_index =
+                                matroska-&gt;tracks[track]-&gt;stream_index;
 
-                        matroska_queue_packet(matroska, pkt);
+                            pkt-&gt;pts = timecode;
+                            pkt-&gt;pos = pos;
+
+                            matroska_queue_packet(matroska, pkt);
+                        }
+                        data += lace_size[n];
                     }
                 }
 
@@ -2451,11 +2577,8 @@
             }
 
             case MATROSKA_ID_BLOCKDURATION: {
-                uint64_t num;
-                if ((res = ebml_read_uint(matroska, &amp;id, &amp;num)) &lt; 0)
+                if ((res = ebml_read_uint(matroska, &amp;id, &amp;duration)) &lt; 0)
                     break;
-                av_log(matroska-&gt;ctx, AV_LOG_INFO,
-                       &quot;FIXME: implement support for BlockDuration\n&quot;);
                 break;
             }
 
@@ -2484,6 +2607,14 @@
         }
     }
 
+    if (pkt)
+    {
+        if (duration != AV_NOPTS_VALUE)
+            pkt-&gt;duration = duration;
+        else if (track &gt;= 0 &amp;&amp; track &lt; matroska-&gt;num_tracks)
+            pkt-&gt;duration = matroska-&gt;tracks[track]-&gt;default_duration / matroska-&gt;time_scale;
+    }
+
     return res;
 }
 
@@ -2599,12 +2730,9 @@
     MatroskaDemuxContext *matroska = s-&gt;priv_data;
     int n = 0;
 
-    if (matroska-&gt;writing_app)
-        av_free(matroska-&gt;writing_app);
-    if (matroska-&gt;muxing_app)
-        av_free(matroska-&gt;muxing_app);
-    if (matroska-&gt;index)
-        av_free(matroska-&gt;index);
+    av_free(matroska-&gt;writing_app);
+    av_free(matroska-&gt;muxing_app);
+    av_free(matroska-&gt;index);
 
     if (matroska-&gt;packets != NULL) {
         for (n = 0; n &lt; matroska-&gt;num_packets; n++) {
@@ -2616,22 +2744,15 @@
 
     for (n = 0; n &lt; matroska-&gt;num_tracks; n++) {
         MatroskaTrack *track = matroska-&gt;tracks[n];
-        if (track-&gt;codec_id)
-            av_free(track-&gt;codec_id);
-        if (track-&gt;codec_name)
-            av_free(track-&gt;codec_name);
-        if (track-&gt;codec_priv)
-            av_free(track-&gt;codec_priv);
-        if (track-&gt;name)
-            av_free(track-&gt;name);
-        if (track-&gt;language)
-            av_free(track-&gt;language);
+        av_free(track-&gt;codec_id);
+        av_free(track-&gt;codec_name);
+        av_free(track-&gt;codec_priv);
+        av_free(track-&gt;name);
+        av_free(track-&gt;language);
 
         av_free(track);
     }
 
-    memset(matroska, 0, sizeof(MatroskaDemuxContext));
-
     return 0;
 }
 

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/mov.c
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/mov.c	2007-01-20 15:15:58 UTC (rev 2746)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/mov.c	2007-01-21 18:04:24 UTC (rev 2747)
@@ -1,19 +1,21 @@
 /*
- * MOV decoder.
+ * MOV demuxer
  * Copyright (c) 2001 Fabrice Bellard.
  *
- * This library is free software; you can redistribute it and/or
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
  * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
+ * version 2.1 of the License, or (at your option) any later version.
  *
- * This library is distributed in the hope that it will be useful,
+ * FFmpeg is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  * Lesser General Public License for more details.
  *
  * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
+ * License along with FFmpeg; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
@@ -24,7 +26,7 @@
 #include &quot;avformat.h&quot;
 #include &quot;riff.h&quot;
 #include &quot;isom.h&quot;
-// MEANX #include &quot;dv.h&quot;
+#include &quot;dv.h&quot;
 
 #ifdef CONFIG_ZLIB
 #include &lt;zlib.h&gt;
@@ -58,13 +60,13 @@
  * QuickTime is a trademark of Apple (AFAIK :))
  */
 
-// MEANX #include &quot;qtpalette.h&quot;
+#include &quot;qtpalette.h&quot;
 
 
 #undef NDEBUG
 #include &lt;assert.h&gt;
 
-static const CodecTag mov_video_tags[] = {
+static const AVCodecTag mov_video_tags[] = {
 /*  { CODEC_ID_, MKTAG('c', 'v', 'i', 'd') }, *//* Cinepak */
 /*  { CODEC_ID_H263, MKTAG('r', 'a', 'w', ' ') }, *//* Uncompressed RGB */
 /*  { CODEC_ID_H263, MKTAG('Y', 'u', 'v', '2') }, *//* Uncompressed YUV422 */
@@ -79,7 +81,7 @@
     { CODEC_ID_MJPEGB, MKTAG('m', 'j', 'p', 'b') }, /* Motion-JPEG (format B) */
     { CODEC_ID_MJPEG, MKTAG('A', 'V', 'D', 'J') }, /* MJPEG with alpha-channel (AVID JFIF meridien compressed) */
 /*    { CODEC_ID_MJPEG, MKTAG('A', 'V', 'R', 'n') }, *//* MJPEG with alpha-channel (AVID ABVB/Truevision NuVista) */
-/*    { CODEC_ID_GIF, MKTAG('g', 'i', 'f', ' ') }, *//* embedded gif files as frames (usually one &quot;click to play movie&quot; frame) */
+    { CODEC_ID_GIF, MKTAG('g', 'i', 'f', ' ') }, /* embedded gif files as frames (usually one &quot;click to play movie&quot; frame) */
 /* Sorenson video */
     { CODEC_ID_SVQ1, MKTAG('S', 'V', 'Q', '1') }, /* Sorenson Video v1 */
     { CODEC_ID_SVQ1, MKTAG('s', 'v', 'q', '1') }, /* Sorenson Video v1 */
@@ -100,6 +102,7 @@
     { CODEC_ID_8BPS, MKTAG('8', 'B', 'P', 'S') }, /* Planar RGB (8BPS) */
     { CODEC_ID_SMC, MKTAG('s', 'm', 'c', ' ') }, /* Apple Graphics (SMC) */
     { CODEC_ID_QTRLE, MKTAG('r', 'l', 'e', ' ') }, /* Apple Animation (RLE) */
+    { CODEC_ID_MSRLE, MKTAG('W', 'R', 'L', 'E') },
     { CODEC_ID_QDRAW, MKTAG('q', 'd', 'r', 'w') }, /* QuickDraw */
     { CODEC_ID_H264, MKTAG('a', 'v', 'c', '1') }, /* AVC-1/H.264 */
     { CODEC_ID_MPEG2VIDEO, MKTAG('h', 'd', 'v', '2') }, /* MPEG2 produced by Sony HD camera */
@@ -115,11 +118,16 @@
     { CODEC_ID_DVVIDEO, MKTAG('d', 'v', '5', 'n') }, /* DVCPRO50 NTSC produced by FCP */
     { CODEC_ID_DVVIDEO, MKTAG('A', 'V', 'd', 'v') }, /* AVID DV */
     //{ CODEC_ID_JPEG2000, MKTAG('m', 'j', 'p', '2') }, /* JPEG 2000 produced by FCP */
+    { CODEC_ID_TARGA, MKTAG('t', 'g', 'a', ' ') }, /* Truevision Targa */
+    { CODEC_ID_TIFF, MKTAG('t', 'i', 'f', 'f') }, /* TIFF embedded in MOV */
     { CODEC_ID_RAWVIDEO, MKTAG('2', 'v', 'u', 'y') }, /* UNCOMPRESSED 8BIT 4:2:2 */
+    { CODEC_ID_VC1,  MKTAG('v', 'c', '-', '1') }, /* SMPTE RP 2025 */
+    { CODEC_ID_WMV3, MKTAG('v', 'c', '-', '1') }, /* SMPTE RP 2025 */
+    { CODEC_ID_PNG,  MKTAG('p', 'n', 'g', ' ') },
     { CODEC_ID_NONE, 0 },
 };
 
-static const CodecTag mov_audio_tags[] = {
+static const AVCodecTag mov_audio_tags[] = {
     { CODEC_ID_PCM_S32BE, MKTAG('i', 'n', '3', '2') },
     { CODEC_ID_PCM_S24BE, MKTAG('i', 'n', '2', '4') },
     { CODEC_ID_PCM_S16BE, MKTAG('N', 'O', 'N', 'E') }, /* uncompressed */
@@ -147,6 +155,7 @@
     { CODEC_ID_QDM2,MKTAG('Q', 'D', 'M', '2') }, /* QDM2 */
     { CODEC_ID_DVAUDIO, MKTAG('v', 'd', 'v', 'a') },
     { CODEC_ID_DVAUDIO, MKTAG('d', 'v', 'c', 'a') },
+    { CODEC_ID_PCM_S16LE, MKTAG('l', 'p', 'c', 'm') },
     { CODEC_ID_NONE, 0 },
 };
 
@@ -257,7 +266,6 @@
 } MOVStreamContext;
 
 typedef struct MOVContext {
-    int mp4; /* set to 1 as soon as we are sure that the file is an .mp4 file (even some header parsing depends on this) */
     AVFormatContext *fc;
     int time_scale;
     int64_t duration; /* duration of the longest track */
@@ -279,8 +287,9 @@
     AVPaletteControl palette_control;
     MOV_mdat_atom_t *mdat_list;
     int mdat_count;
-    // MEANX DVDemuxContext *dv_demux;
+    DVDemuxContext *dv_demux;
     AVFormatContext *dv_fctx;
+    int isom; /* 1 if file is ISO Media (mp4/3gp) */
 } MOVContext;
 
 
@@ -299,14 +308,6 @@
     uint32_t type;
     mov_parse_function func;
 } MOVParseTableEntry;
-#if 0 //MEANx
-static int mov_read_leaf(MOVContext *c, ByteIOContext *pb, MOV_atom_t atom)
-{
-    if (atom.size&gt;1)
-        url_fskip(pb, atom.size);
-/*        url_seek(pb, atom_offset+atom.size, SEEK_SET); */
-    return 0;
-}
 
 static int mov_read_default(MOVContext *c, ByteIOContext *pb, MOV_atom_t atom)
 {
@@ -397,7 +398,6 @@
 static int mov_read_hdlr(MOVContext *c, ByteIOContext *pb, MOV_atom_t atom)
 {
     AVStream *st = c-&gt;fc-&gt;streams[c-&gt;fc-&gt;nb_streams-1];
-    int len = 0;
     uint32_t type;
     uint32_t ctype;
 
@@ -410,32 +410,25 @@
 
     dprintf(&quot;ctype= %c%c%c%c (0x%08lx)\n&quot;, *((char *)&amp;ctype), ((char *)&amp;ctype)[1], ((char *)&amp;ctype)[2], ((char *)&amp;ctype)[3], (long) ctype);
     dprintf(&quot;stype= %c%c%c%c\n&quot;, *((char *)&amp;type), ((char *)&amp;type)[1], ((char *)&amp;type)[2], ((char *)&amp;type)[3]);
-    if(ctype == MKTAG('m', 'h', 'l', 'r')) /* MOV */
-        c-&gt;mp4 = 0;
-    else if(ctype == 0)
-        c-&gt;mp4 = 1;
+    if(!ctype)
+        c-&gt;isom = 1;
     if(type == MKTAG('v', 'i', 'd', 'e'))
         st-&gt;codec-&gt;codec_type = CODEC_TYPE_VIDEO;
     else if(type == MKTAG('s', 'o', 'u', 'n'))
         st-&gt;codec-&gt;codec_type = CODEC_TYPE_AUDIO;
+    else if(type == MKTAG('m', '1', 'a', ' '))
+        st-&gt;codec-&gt;codec_id = CODEC_ID_MP2;
+    else if(type == MKTAG('s', 'u', 'b', 'p')) {
+        st-&gt;codec-&gt;codec_type = CODEC_TYPE_SUBTITLE;
+        st-&gt;codec-&gt;codec_id = CODEC_ID_DVD_SUBTITLE;
+    }
     get_be32(pb); /* component  manufacture */
     get_be32(pb); /* component flags */
     get_be32(pb); /* component flags mask */
 
     if(atom.size &lt;= 24)
         return 0; /* nothing left to read */
-    /* XXX: MP4 uses a C string, not a pascal one */
-    /* component name */
 
-    if(c-&gt;mp4) {
-        /* .mp4: C string */
-        while(get_byte(pb) &amp;&amp; (++len &lt; (atom.size - 24)));
-    } else {
-        /* .mov: PASCAL string */
-        len = get_byte(pb);
-        url_fskip(pb, len);
-    }
-
     url_fskip(pb, atom.size - (url_ftell(pb) - atom.offset));
     return 0;
 }
@@ -490,12 +483,12 @@
         len = mov_mp4_read_descr(pb, &amp;tag);
         if (tag == MP4DecSpecificDescrTag) {
             dprintf(&quot;Specific MPEG4 header len=%d\n&quot;, len);
-            st-&gt;codec-&gt;extradata = (uint8_t*) av_mallocz(len + FF_INPUT_BUFFER_PADDING_SIZE);
+            st-&gt;codec-&gt;extradata = av_mallocz(len + FF_INPUT_BUFFER_PADDING_SIZE);
             if (st-&gt;codec-&gt;extradata) {
                 get_buffer(pb, st-&gt;codec-&gt;extradata, len);
                 st-&gt;codec-&gt;extradata_size = len;
                 /* from mplayer */
-                if ((*(uint8_t *)st-&gt;codec-&gt;extradata &gt;&gt; 3) == 29) {
+                if ((*st-&gt;codec-&gt;extradata &gt;&gt; 3) == 29) {
                     st-&gt;codec-&gt;codec_id = CODEC_ID_MP3ON4;
                 }
             }
@@ -526,26 +519,9 @@
 {
     uint32_t type = get_le32(pb);
 
-    /* from mplayer */
-    switch (type) {
-    case MKTAG('i', 's', 'o', 'm'):
-    case MKTAG('m', 'p', '4', '1'):
-    case MKTAG('m', 'p', '4', '2'):
-    case MKTAG('3', 'g', 'p', '1'):
-    case MKTAG('3', 'g', 'p', '2'):
-    case MKTAG('3', 'g', '2', 'a'):
-    case MKTAG('3', 'g', 'p', '3'):
-    case MKTAG('3', 'g', 'p', '4'):
-    case MKTAG('3', 'g', 'p', '5'):
-    case MKTAG('m', 'm', 'p', '4'): /* Mobile MP4 */
-    case MKTAG('M', '4', 'A', ' '): /* Apple iTunes AAC-LC Audio */
-    case MKTAG('M', '4', 'P', ' '): /* Apple iTunes AAC-LC Protected Audio */
-    case MKTAG('m', 'j', 'p', '2'): /* Motion Jpeg 2000 */
-        c-&gt;mp4 = 1;
-    case MKTAG('q', 't', ' ', ' '):
-    default:
-        av_log(c-&gt;fc, AV_LOG_DEBUG, &quot;ISO: File Type Major Brand: %.4s\n&quot;,(char *)&amp;type);
-    }
+    if (type != MKTAG('q','t',' ',' '))
+        c-&gt;isom = 1;
+    av_log(c-&gt;fc, AV_LOG_DEBUG, &quot;ISO: File Type Major Brand: %.4s\n&quot;,(char *)&amp;type);
     get_be32(pb); /* minor version */
     url_fskip(pb, atom.size - 8);
     return 0;
@@ -644,12 +620,12 @@
     // this should be fixed and just SMI header should be passed
     av_free(st-&gt;codec-&gt;extradata);
     st-&gt;codec-&gt;extradata_size = 0x5a + atom.size;
-    st-&gt;codec-&gt;extradata = (uint8_t*) av_mallocz(st-&gt;codec-&gt;extradata_size + FF_INPUT_BUFFER_PADDING_SIZE);
+    st-&gt;codec-&gt;extradata = av_mallocz(st-&gt;codec-&gt;extradata_size + FF_INPUT_BUFFER_PADDING_SIZE);
 
     if (st-&gt;codec-&gt;extradata) {
         strcpy(st-&gt;codec-&gt;extradata, &quot;SVQ3&quot;); // fake
         get_buffer(pb, st-&gt;codec-&gt;extradata + 0x5a, atom.size);
-        dprintf(&quot;Reading SMI %&quot;PRId64&quot;  %s\n&quot;, atom.size, (char*)st-&gt;codec-&gt;extradata + 0x5a);
+        dprintf(&quot;Reading SMI %&quot;PRId64&quot;  %s\n&quot;, atom.size, st-&gt;codec-&gt;extradata + 0x5a);
     } else
         url_fskip(pb, atom.size);
 
@@ -685,12 +661,12 @@
 
     av_free(st-&gt;codec-&gt;extradata);
     st-&gt;codec-&gt;extradata_size = 36;
-    st-&gt;codec-&gt;extradata = (uint8_t*) av_mallocz(st-&gt;codec-&gt;extradata_size + FF_INPUT_BUFFER_PADDING_SIZE);
+    st-&gt;codec-&gt;extradata = av_mallocz(st-&gt;codec-&gt;extradata_size + FF_INPUT_BUFFER_PADDING_SIZE);
 
     if (st-&gt;codec-&gt;extradata) {
         strcpy(st-&gt;codec-&gt;extradata + 4, &quot;alac&quot;); // fake
         get_buffer(pb, st-&gt;codec-&gt;extradata + 8, 36 - 8);
-        dprintf(&quot;Reading alac %d  %s\n&quot;, st-&gt;codec-&gt;extradata_size, (char*)st-&gt;codec-&gt;extradata);
+        dprintf(&quot;Reading alac %d  %s\n&quot;, st-&gt;codec-&gt;extradata_size, st-&gt;codec-&gt;extradata);
     } else
         url_fskip(pb, atom.size);
     return 0;
@@ -707,7 +683,7 @@
         // pass all frma atom to codec, needed at least for QDM2
         av_free(st-&gt;codec-&gt;extradata);
         st-&gt;codec-&gt;extradata_size = atom.size;
-        st-&gt;codec-&gt;extradata = (uint8_t*) av_mallocz(st-&gt;codec-&gt;extradata_size + FF_INPUT_BUFFER_PADDING_SIZE);
+        st-&gt;codec-&gt;extradata = av_mallocz(st-&gt;codec-&gt;extradata_size + FF_INPUT_BUFFER_PADDING_SIZE);
 
         if (st-&gt;codec-&gt;extradata) {
             get_buffer(pb, st-&gt;codec-&gt;extradata, atom.size);
@@ -730,7 +706,7 @@
     av_free(st-&gt;codec-&gt;extradata);
 
     st-&gt;codec-&gt;extradata_size = atom.size + 8;
-    st-&gt;codec-&gt;extradata = (uint8_t*) av_mallocz(st-&gt;codec-&gt;extradata_size + FF_INPUT_BUFFER_PADDING_SIZE);
+    st-&gt;codec-&gt;extradata = av_mallocz(st-&gt;codec-&gt;extradata_size + FF_INPUT_BUFFER_PADDING_SIZE);
 
     /* pass all jp2h atom to codec */
     if (st-&gt;codec-&gt;extradata) {
@@ -751,7 +727,7 @@
     av_free(st-&gt;codec-&gt;extradata);
 
     st-&gt;codec-&gt;extradata_size = atom.size;
-    st-&gt;codec-&gt;extradata = (uint8_t*) av_mallocz(st-&gt;codec-&gt;extradata_size + FF_INPUT_BUFFER_PADDING_SIZE);
+    st-&gt;codec-&gt;extradata = av_mallocz(st-&gt;codec-&gt;extradata_size + FF_INPUT_BUFFER_PADDING_SIZE);
 
     if (st-&gt;codec-&gt;extradata) {
         get_buffer(pb, st-&gt;codec-&gt;extradata, atom.size);
@@ -776,7 +752,7 @@
         return -1;
 
     sc-&gt;chunk_count = entries;
-    sc-&gt;chunk_offsets = (int64_t*) av_malloc(entries * sizeof(int64_t));
+    sc-&gt;chunk_offsets = av_malloc(entries * sizeof(int64_t));
     if (!sc-&gt;chunk_offsets)
         return -1;
     if (atom.type == MKTAG('s', 't', 'c', 'o')) {
@@ -837,9 +813,10 @@
 
         st-&gt;codec-&gt;codec_tag = format;
         id = codec_get_id(mov_audio_tags, format);
-        if (id &gt; 0) {
+        if (st-&gt;codec-&gt;codec_type != CODEC_TYPE_VIDEO &amp;&amp; id &gt; 0) {
             st-&gt;codec-&gt;codec_type = CODEC_TYPE_AUDIO;
-        } else if (format &amp;&amp; format != MKTAG('m', 'p', '4', 's')) { /* skip old asf mpeg4 tag */
+        } else if (st-&gt;codec-&gt;codec_type != CODEC_TYPE_AUDIO &amp;&amp; /* do not overwrite codec type */
+                   format &amp;&amp; format != MKTAG('m', 'p', '4', 's')) { /* skip old asf mpeg4 tag */
             id = codec_get_id(mov_video_tags, format);
             if (id &lt;= 0)
                 id = codec_get_id(codec_bmp_tags, format);
@@ -977,34 +954,38 @@
             case CODEC_ID_PCM_S16BE:
                 if (st-&gt;codec-&gt;bits_per_sample == 8)
                     st-&gt;codec-&gt;codec_id = CODEC_ID_PCM_S8;
+                else if (st-&gt;codec-&gt;bits_per_sample == 24)
+                    st-&gt;codec-&gt;codec_id = CODEC_ID_PCM_S24BE;
                 break;
             default:
                 break;
             }
 
+            //Read QT version 1 fields. In version 0 theese dont exist
+            dprintf(&quot;version =%d, isom =%d\n&quot;,version,c-&gt;isom);
+            if(!c-&gt;isom) {
+                if(version==1) {
+                    sc-&gt;sample_size_v1.den = get_be32(pb); /* samples per packet */
+                    get_be32(pb); /* bytes per packet */
+                    sc-&gt;sample_size_v1.num = get_be32(pb); /* bytes per frame */
+                    get_be32(pb); /* bytes per sample */
+                } else if(version==2) {
+                    get_be32(pb); /* sizeof struct only */
+                    st-&gt;codec-&gt;sample_rate = av_int2dbl(get_be64(pb)); /* float 64 */
+                    st-&gt;codec-&gt;channels = get_be32(pb);
+                    get_be32(pb); /* always 0x7F000000 */
+                    get_be32(pb); /* bits per channel if sound is uncompressed */
+                    get_be32(pb); /* lcpm format specific flag */
+                    get_be32(pb); /* bytes per audio packet if constant */
+                    get_be32(pb); /* lpcm frames per audio packet if constant */
+                }
+            }
+
             bits_per_sample = av_get_bits_per_sample(st-&gt;codec-&gt;codec_id);
             if (bits_per_sample) {
                 st-&gt;codec-&gt;bits_per_sample = bits_per_sample;
                 sc-&gt;sample_size = (bits_per_sample &gt;&gt; 3) * st-&gt;codec-&gt;channels;
             }
-
-            //Read QT version 1 fields. In version 0 theese dont exist
-            dprintf(&quot;version =%d mp4=%d\n&quot;,version,c-&gt;mp4);
-            if(version==1) {
-                sc-&gt;sample_size_v1.den = get_be32(pb); /* samples per packet */
-                get_be32(pb); /* bytes per packet */
-                sc-&gt;sample_size_v1.num = get_be32(pb); /* bytes per frame */
-                get_be32(pb); /* bytes per sample */
-            } else if(version==2) {
-                get_be32(pb); /* sizeof struct only */
-                st-&gt;codec-&gt;sample_rate = av_int2dbl(get_be64(pb)); /* float 64 */
-                st-&gt;codec-&gt;channels = get_be32(pb);
-                get_be32(pb); /* always 0x7F000000 */
-                get_be32(pb); /* bits per channel if sound is uncompressed */
-                get_be32(pb); /* lcpm format specific flag */
-                get_be32(pb); /* bytes per audio packet if constant */
-                get_be32(pb); /* lpcm frames per audio packet if constant */
-            }
         } else {
             /* other codec type, just skip (rtp, mp4s, tmcd ...) */
             url_fskip(pb, size - (url_ftell(pb) - start_pos));
@@ -1035,7 +1016,7 @@
         st-&gt;codec-&gt;width= 0; /* let decoder init width/height */
         st-&gt;codec-&gt;height= 0;
         break;
-#ifdef CONFIG_FAAD
+#ifdef CONFIG_LIBFAAD
     case CODEC_ID_AAC:
 #endif
 #ifdef CONFIG_VORBIS_DECODER
@@ -1065,6 +1046,10 @@
         st-&gt;codec-&gt;sample_rate= 8000;
         st-&gt;codec-&gt;channels= 1; /* really needed */
         break;
+    case CODEC_ID_MP2:
+        st-&gt;codec-&gt;codec_type = CODEC_TYPE_AUDIO; /* force type after stsd for m1a hdlr */
+        st-&gt;need_parsing = 1;
+        break;
     default:
         break;
     }
@@ -1090,7 +1075,7 @@
 av_log(NULL, AV_LOG_DEBUG, &quot;track[%i].stsc.entries = %i\n&quot;, c-&gt;fc-&gt;nb_streams-1, entries);
 #endif
     sc-&gt;sample_to_chunk_sz = entries;
-    sc-&gt;sample_to_chunk = (MOV_sample_to_chunk_tbl*) av_malloc(entries * sizeof(MOV_sample_to_chunk_tbl));
+    sc-&gt;sample_to_chunk = av_malloc(entries * sizeof(MOV_sample_to_chunk_tbl));
     if (!sc-&gt;sample_to_chunk)
         return -1;
     for(i=0; i&lt;entries; i++) {
@@ -1119,7 +1104,7 @@
 #ifdef DEBUG
     av_log(NULL, AV_LOG_DEBUG, &quot;keyframe_count = %ld\n&quot;, sc-&gt;keyframe_count);
 #endif
-    sc-&gt;keyframes = (long*) av_malloc(entries * sizeof(long));
+    sc-&gt;keyframes = av_malloc(entries * sizeof(long));
     if (!sc-&gt;keyframes)
         return -1;
     for(i=0; i&lt;entries; i++) {
@@ -1154,7 +1139,7 @@
 #ifdef DEBUG
     av_log(NULL, AV_LOG_DEBUG, &quot;sample_size = %ld sample_count = %ld\n&quot;, sc-&gt;sample_size, sc-&gt;sample_count);
 #endif
-    sc-&gt;sample_sizes = (long*) av_malloc(entries * sizeof(long));
+    sc-&gt;sample_sizes = av_malloc(entries * sizeof(long));
     if (!sc-&gt;sample_sizes)
         return -1;
     for(i=0; i&lt;entries; i++) {
@@ -1254,7 +1239,7 @@
 
     st = av_new_stream(c-&gt;fc, c-&gt;fc-&gt;nb_streams);
     if (!st) return -2;
-    sc = (MOVStreamContext*) av_mallocz(sizeof(MOVStreamContext));
+    sc = av_mallocz(sizeof(MOVStreamContext));
     if (!sc) {
         av_free(st);
         return -1;
@@ -1334,15 +1319,9 @@
     return err;
 }
 
-
-#ifdef CONFIG_ZLIB
-static int null_read_packet(void *opaque, uint8_t *buf, int buf_size)
-{
-    return -1;
-}
-
 static int mov_read_cmov(MOVContext *c, ByteIOContext *pb, MOV_atom_t atom)
 {
+#ifdef CONFIG_ZLIB
     ByteIOContext ctx;
     uint8_t *cmov_data;
     uint8_t *moov_data; /* uncompressed data */
@@ -1362,10 +1341,10 @@
     moov_len = get_be32(pb); /* uncompressed size */
     cmov_len = atom.size - 6 * 4;
 
-    cmov_data = (uint8_t *) av_malloc(cmov_len);
+    cmov_data = av_malloc(cmov_len);
     if (!cmov_data)
         return -1;
-    moov_data = (uint8_t *) av_malloc(moov_len);
+    moov_data = av_malloc(moov_len);
     if (!moov_data) {
         av_free(cmov_data);
         return -1;
@@ -1373,9 +1352,8 @@
     get_buffer(pb, cmov_data, cmov_len);
     if(uncompress (moov_data, (uLongf *) &amp;moov_len, (const Bytef *)cmov_data, cmov_len) != Z_OK)
         return -1;
-    if(init_put_byte(&amp;ctx, moov_data, moov_len, 0, NULL, null_read_packet, NULL, NULL) != 0)
+    if(init_put_byte(&amp;ctx, moov_data, moov_len, 0, NULL, NULL, NULL, NULL) != 0)
         return -1;
-    ctx.buf_end = ctx.buffer + moov_len;
     atom.type = MKTAG( 'm', 'o', 'o', 'v' );
     atom.offset = 0;
     atom.size = moov_len;
@@ -1385,10 +1363,12 @@
     ret = mov_read_default(c, &amp;ctx, atom);
     av_free(moov_data);
     av_free(cmov_data);
-
     return ret;
-}
+#else
+    av_log(c-&gt;fc, AV_LOG_ERROR, &quot;this file requires zlib support compiled in\n&quot;);
+    return -1;
 #endif
+}
 
 /* edit list atom */
 static int mov_read_elst(MOVContext *c, ByteIOContext *pb, MOV_atom_t atom)
@@ -1411,84 +1391,37 @@
 static const MOVParseTableEntry mov_default_parse_table[] = {
 /* mp4 atoms */
 { MKTAG( 'c', 'o', '6', '4' ), mov_read_stco },
-{ MKTAG( 'c', 'p', 'r', 't' ), mov_read_default },
-{ MKTAG( 'c', 'r', 'h', 'd' ), mov_read_default },
 { MKTAG( 'c', 't', 't', 's' ), mov_read_ctts }, /* composition time to sample */
-{ MKTAG( 'd', 'i', 'n', 'f' ), mov_read_default }, /* data information */
-{ MKTAG( 'd', 'p', 'n', 'd' ), mov_read_leaf },
-{ MKTAG( 'd', 'r', 'e', 'f' ), mov_read_leaf },
 { MKTAG( 'e', 'd', 't', 's' ), mov_read_default },
 { MKTAG( 'e', 'l', 's', 't' ), mov_read_elst },
 { MKTAG( 'e', 'n', 'd', 'a' ), mov_read_enda },
-{ MKTAG( 'f', 'r', 'e', 'e' ), mov_read_leaf },
 { MKTAG( 'f', 't', 'y', 'p' ), mov_read_ftyp },
 { MKTAG( 'h', 'd', 'l', 'r' ), mov_read_hdlr },
-{ MKTAG( 'h', 'i', 'n', 't' ), mov_read_leaf },
-{ MKTAG( 'h', 'm', 'h', 'd' ), mov_read_leaf },
-{ MKTAG( 'i', 'o', 'd', 's' ), mov_read_leaf },
 { MKTAG( 'j', 'p', '2', 'h' ), mov_read_jp2h },
 { MKTAG( 'm', 'd', 'a', 't' ), mov_read_mdat },
 { MKTAG( 'm', 'd', 'h', 'd' ), mov_read_mdhd },
 { MKTAG( 'm', 'd', 'i', 'a' ), mov_read_default },
 { MKTAG( 'm', 'i', 'n', 'f' ), mov_read_default },
 { MKTAG( 'm', 'o', 'o', 'v' ), mov_read_moov },
-{ MKTAG( 'm', 'p', '4', 'a' ), mov_read_default },
-{ MKTAG( 'm', 'p', '4', 's' ), mov_read_default },
-{ MKTAG( 'm', 'p', '4', 'v' ), mov_read_default },
-{ MKTAG( 'm', 'p', 'o', 'd' ), mov_read_leaf },
 { MKTAG( 'm', 'v', 'h', 'd' ), mov_read_mvhd },
-{ MKTAG( 'n', 'm', 'h', 'd' ), mov_read_leaf },
-{ MKTAG( 'o', 'd', 'h', 'd' ), mov_read_default },
-{ MKTAG( 's', 'd', 'h', 'd' ), mov_read_default },
-{ MKTAG( 's', 'k', 'i', 'p' ), mov_read_leaf },
-{ MKTAG( 's', 'm', 'h', 'd' ), mov_read_leaf }, /* sound media info header */
 { MKTAG( 'S', 'M', 'I', ' ' ), mov_read_smi }, /* Sorenson extension ??? */
 { MKTAG( 'a', 'l', 'a', 'c' ), mov_read_alac }, /* alac specific atom */
 { MKTAG( 'a', 'v', 'c', 'C' ), mov_read_avcC },
 { MKTAG( 's', 't', 'b', 'l' ), mov_read_default },
 { MKTAG( 's', 't', 'c', 'o' ), mov_read_stco },
-{ MKTAG( 's', 't', 'd', 'p' ), mov_read_default },
 { MKTAG( 's', 't', 's', 'c' ), mov_read_stsc },
 { MKTAG( 's', 't', 's', 'd' ), mov_read_stsd }, /* sample description */
-{ MKTAG( 's', 't', 's', 'h' ), mov_read_default },
 { MKTAG( 's', 't', 's', 's' ), mov_read_stss }, /* sync sample */
 { MKTAG( 's', 't', 's', 'z' ), mov_read_stsz }, /* sample size */
 { MKTAG( 's', 't', 't', 's' ), mov_read_stts },
 { MKTAG( 't', 'k', 'h', 'd' ), mov_read_tkhd }, /* track header */
 { MKTAG( 't', 'r', 'a', 'k' ), mov_read_trak },
-{ MKTAG( 't', 'r', 'e', 'f' ), mov_read_default }, /* not really */
-{ MKTAG( 'u', 'd', 't', 'a' ), mov_read_leaf },
-{ MKTAG( 'u', 'r', 'l', ' ' ), mov_read_leaf },
-{ MKTAG( 'u', 'r', 'n', ' ' ), mov_read_leaf },
-{ MKTAG( 'u', 'u', 'i', 'd' ), mov_read_leaf },
-{ MKTAG( 'v', 'm', 'h', 'd' ), mov_read_leaf }, /* video media info header */
 { MKTAG( 'w', 'a', 'v', 'e' ), mov_read_wave },
-/* extra mp4 */
-{ MKTAG( 'M', 'D', 'E', 'S' ), mov_read_leaf },
-/* QT atoms */
-{ MKTAG( 'c', 'h', 'a', 'p' ), mov_read_leaf },
-{ MKTAG( 'c', 'l', 'i', 'p' ), mov_read_default },
-{ MKTAG( 'c', 'r', 'g', 'n' ), mov_read_leaf },
 { MKTAG( 'c', 't', 'a', 'b' ), mov_read_ctab },
 { MKTAG( 'e', 's', 'd', 's' ), mov_read_esds },
-{ MKTAG( 'k', 'm', 'a', 't' ), mov_read_leaf },
-{ MKTAG( 'm', 'a', 't', 't' ), mov_read_default },
-{ MKTAG( 'r', 'd', 'r', 'f' ), mov_read_leaf },
-{ MKTAG( 'r', 'm', 'd', 'a' ), mov_read_default },
-{ MKTAG( 'r', 'm', 'd', 'r' ), mov_read_leaf },
-{ MKTAG( 'r', 'm', 'r', 'a' ), mov_read_default },
-{ MKTAG( 's', 'c', 'p', 't' ), mov_read_leaf },
-{ MKTAG( 's', 's', 'r', 'c' ), mov_read_leaf },
-{ MKTAG( 's', 'y', 'n', 'c' ), mov_read_leaf },
-{ MKTAG( 't', 'c', 'm', 'd' ), mov_read_leaf },
 { MKTAG( 'w', 'i', 'd', 'e' ), mov_read_wide }, /* place holder */
-//{ MKTAG( 'r', 'm', 'q', 'u' ), mov_read_leaf },
-#ifdef CONFIG_ZLIB
 { MKTAG( 'c', 'm', 'o', 'v' ), mov_read_cmov },
-#else
-{ MKTAG( 'c', 'm', 'o', 'v' ), mov_read_leaf },
-#endif
-{ 0L, mov_read_leaf }
+{ 0L, NULL }
 };
 
 static void mov_free_stream_context(MOVStreamContext *sc)
@@ -1514,7 +1447,7 @@
         /* ignore invalid offset */
         if ((offset + 8) &gt; (unsigned int)p-&gt;buf_size)
             return score;
-        tag = LE_32(p-&gt;buf + offset + 4);
+        tag = AV_RL32(p-&gt;buf + offset + 4);
         switch(tag) {
         /* check for obvious tags */
         case MKTAG( 'j', 'P', ' ', ' ' ): /* jpeg 2000 signature */
@@ -1532,7 +1465,7 @@
         case MKTAG( 'f', 't', 'y', 'p' ):
         case MKTAG( 's', 'k', 'i', 'p' ):
         case MKTAG( 'u', 'u', 'i', 'd' ):
-            offset = BE_32(p-&gt;buf+offset) + offset;
+            offset = AV_RB32(p-&gt;buf+offset) + offset;
             /* if we only find those cause probedata is too small at least rate them */
             score = AVPROBE_SCORE_MAX - 50;
             break;
@@ -1573,7 +1506,7 @@
                         stss_index++;
                 }
                 sample_size = sc-&gt;sample_size &gt; 0 ? sc-&gt;sample_size : sc-&gt;sample_sizes[current_sample];
-                dprintf(&quot;AVIndex stream %d, sample %d, offset %llx, dts %lld, size %d, distance %d, keyframe %d\n&quot;,
+                dprintf(&quot;AVIndex stream %d, sample %d, offset %&quot;PRIx64&quot;, dts %&quot;PRId64&quot;, size %d, distance %d, keyframe %d\n&quot;,
                         st-&gt;index, current_sample, current_offset, current_dts, sample_size, distance, keyframe);
                 av_add_index_entry(st, current_offset, current_dts, sample_size, distance, keyframe ? AVINDEX_KEYFRAME : 0);
                 current_offset += sample_size;
@@ -1618,7 +1551,7 @@
                 /* check for last chunk */
                 if (chunk_size == INT_MAX)
                     for (j = 0; j &lt; mov-&gt;mdat_count; j++) {
-                        dprintf(&quot;mdat %d, offset %llx, size %lld, current offset %llx\n&quot;,
+                        dprintf(&quot;mdat %d, offset %&quot;PRIx64&quot;, size %&quot;PRId64&quot;, current offset %&quot;PRIx64&quot;\n&quot;,
                                 j, mov-&gt;mdat_list[j].offset, mov-&gt;mdat_list[j].size, current_offset);
                         if (mov-&gt;mdat_list[j].offset &lt;= current_offset &amp;&amp; mov-&gt;mdat_list[j].offset + mov-&gt;mdat_list[j].size &gt; current_offset)
                             chunk_size = mov-&gt;mdat_list[j].offset + mov-&gt;mdat_list[j].size - current_offset;
@@ -1644,7 +1577,7 @@
                     }
                 }
             }
-            dprintf(&quot;AVIndex stream %d, chunk %d, offset %llx, dts %lld, size %d, duration %d\n&quot;,
+            dprintf(&quot;AVIndex stream %d, chunk %d, offset %&quot;PRIx64&quot;, dts %&quot;PRId64&quot;, size %d, duration %d\n&quot;,
                     st-&gt;index, i, current_offset, current_dts, chunk_size, chunk_duration);
             assert(chunk_duration % sc-&gt;time_rate == 0);
             current_dts += chunk_duration / sc-&gt;time_rate;
@@ -1728,7 +1661,7 @@
             AVIndexEntry *current_sample = &amp;s-&gt;streams[i]-&gt;index_entries[msc-&gt;current_sample];
             int64_t dts = av_rescale(current_sample-&gt;timestamp * (int64_t)msc-&gt;time_rate, AV_TIME_BASE, msc-&gt;time_scale);
 
-            dprintf(&quot;stream %d, sample %ld, dts %lld\n&quot;, i, msc-&gt;current_sample, dts);
+            dprintf(&quot;stream %d, sample %ld, dts %&quot;PRId64&quot;\n&quot;, i, msc-&gt;current_sample, dts);
             if (dts &lt; best_dts) {
                 sample = current_sample;
                 best_dts = dts;
@@ -1741,7 +1674,7 @@
     /* must be done just before reading, to avoid infinite loop on sample */
     sc-&gt;current_sample++;
     if (sample-&gt;pos &gt;= url_fsize(&amp;s-&gt;pb)) {
-        av_log(mov-&gt;fc, AV_LOG_ERROR, &quot;stream %d, offset 0x%llx: partial file\n&quot;, sc-&gt;ffindex, sample-&gt;pos);
+        av_log(mov-&gt;fc, AV_LOG_ERROR, &quot;stream %d, offset 0x%&quot;PRIx64&quot;: partial file\n&quot;, sc-&gt;ffindex, sample-&gt;pos);
         return -1;
     }
 #ifdef CONFIG_DV_DEMUXER
@@ -1776,7 +1709,7 @@
     }
     pkt-&gt;flags |= sample-&gt;flags &amp; AVINDEX_KEYFRAME ? PKT_FLAG_KEY : 0;
     pkt-&gt;pos = sample-&gt;pos;
-    dprintf(&quot;stream %d, pts %lld, dts %lld, pos 0x%llx, duration %d\n&quot;, pkt-&gt;stream_index, pkt-&gt;pts, pkt-&gt;dts, pkt-&gt;pos, pkt-&gt;duration);
+    dprintf(&quot;stream %d, pts %&quot;PRId64&quot;, dts %&quot;PRId64&quot;, pos 0x%&quot;PRIx64&quot;, duration %d\n&quot;, pkt-&gt;stream_index, pkt-&gt;pts, pkt-&gt;dts, pkt-&gt;pos, pkt-&gt;duration);
     return 0;
 }
 
@@ -1787,7 +1720,7 @@
     int i;
 
     sample = av_index_search_timestamp(st, timestamp, flags);
-    dprintf(&quot;stream %d, timestamp %lld, sample %d\n&quot;, st-&gt;index, timestamp, sample);
+    dprintf(&quot;stream %d, timestamp %&quot;PRId64&quot;, sample %d\n&quot;, st-&gt;index, timestamp, sample);
     if (sample &lt; 0) /* not sure what to do */
         return -1;
     sc-&gt;current_sample = sample;
@@ -1867,4 +1800,3 @@
     mov_read_close,
     mov_read_seek,
 };
-#endif //MEANX

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/movenc.c
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/movenc.c	2007-01-20 15:15:58 UTC (rev 2746)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/movenc.c	2007-01-21 18:04:24 UTC (rev 2747)
@@ -1,23 +1,26 @@
 /*
- * MOV, 3GP, MP4 encoder.
+ * MOV, 3GP, MP4 muxer
  * Copyright (c) 2003 Thomas Raivio.
  * Copyright (c) 2004 Gildas Bazin &lt;gbazin at videolan dot org&gt;.
  *
- * This library is free software; you can redistribute it and/or
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
  * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
+ * version 2.1 of the License, or (at your option) any later version.
  *
- * This library is distributed in the hope that it will be useful,
+ * FFmpeg is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  * Lesser General Public License for more details.
  *
  * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
+ * License along with FFmpeg; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
-#include &quot;config.h&quot; //MEANX
+#include &quot;config.h&quot; 
+#define MEANX_PUT_MP3_IN_MP4A //MEANX
 #include &quot;avformat.h&quot;
 #include &quot;riff.h&quot;
 #include &quot;avio.h&quot;
@@ -43,6 +46,7 @@
     char         key_frame;
     unsigned int entries;
     int64_t      cts;
+    int64_t      dts;
 } MOVIentry;
 
 typedef struct MOVIndex {
@@ -52,7 +56,6 @@
     long        time;
     int64_t     trackDuration;
     long        sampleCount;
-    long        sampleDuration;
     long        sampleSize;
     int         hasKeyframes;
     int         hasBframes;
@@ -64,6 +67,7 @@
     int         vosLen;
     uint8_t     *vosData;
     MOVIentry   *cluster;
+    int         audio_vbr;
 } MOVTrack;
 
 typedef struct MOVContext {
@@ -320,7 +324,7 @@
     return updateSize (pb, pos);
 }
 
-static const CodecTag codec_movaudio_tags[] = {
+static const AVCodecTag codec_movaudio_tags[] = {
     { CODEC_ID_PCM_MULAW, MKTAG('u', 'l', 'a', 'w') },
     { CODEC_ID_PCM_ALAW, MKTAG('a', 'l', 'a', 'w') },
     { CODEC_ID_ADPCM_IMA_QT, MKTAG('i', 'm', 'a', '4') },
@@ -336,7 +340,7 @@
     { CODEC_ID_PCM_S32BE, MKTAG('i', 'n', '3', '2') },
     { CODEC_ID_PCM_S32LE, MKTAG('i', 'n', '3', '2') },
     //{ CODEC_ID_MP3, MKTAG('.', 'm', 'p', '3') },
-// MEANX
+   // MEANX
 #ifdef MEANX_PUT_MP3_IN_MP4A
     { CODEC_ID_MP3, MKTAG( 'm', 'p', '4','a') },
 #else
@@ -350,13 +354,10 @@
 static int mov_write_audio_tag(ByteIOContext *pb, MOVTrack* track)
 {
     offset_t pos = url_ftell(pb);
-    int vbr=  track-&gt;mode == MODE_MOV &amp;&amp;
-        (track-&gt;enc-&gt;codec_id == CODEC_ID_AAC ||
-         track-&gt;enc-&gt;codec_id == CODEC_ID_MP3 ||
-         track-&gt;enc-&gt;codec_id == CODEC_ID_AMR_NB);
-    int version = vbr ||
-        track-&gt;enc-&gt;codec_id == CODEC_ID_PCM_S32LE ||
-        track-&gt;enc-&gt;codec_id == CODEC_ID_PCM_S24LE;
+    int version = track-&gt;mode == MODE_MOV &amp;&amp;
+        (track-&gt;audio_vbr ||
+         track-&gt;enc-&gt;codec_id == CODEC_ID_PCM_S32LE ||
+         track-&gt;enc-&gt;codec_id == CODEC_ID_PCM_S24LE);
 
     put_be32(pb, 0); /* size */
     put_le32(pb, track-&gt;tag); // store it byteswapped
@@ -373,14 +374,12 @@
     /* FIXME 8 bit for 'raw ' in mov */
     put_be16(pb, 16); /* Reserved */
 
-    put_be16(pb, vbr ? 0xfffe : 0); /* compression ID */
+    put_be16(pb, track-&gt;mode == MODE_MOV &amp;&amp; track-&gt;audio_vbr ? -2 : 0); /* compression ID */
     put_be16(pb, 0); /* packet size (= 0) */
     put_be16(pb, track-&gt;timescale); /* Time scale */
     put_be16(pb, 0); /* Reserved */
 
     if(version == 1) { /* SoundDescription V1 extended info */
-        if (vbr)
-            track-&gt;sampleSize = 0;
         put_be32(pb, track-&gt;enc-&gt;frame_size); /* Samples per packet */
         put_be32(pb, track-&gt;sampleSize / track-&gt;enc-&gt;channels); /* Bytes per packet */
         put_be32(pb, track-&gt;sampleSize); /* Bytes per frame */
@@ -394,13 +393,14 @@
         track-&gt;enc-&gt;codec_id == CODEC_ID_PCM_S32LE))
         mov_write_wave_tag(pb, track);
     else if(track-&gt;enc-&gt;codec_id == CODEC_ID_AAC
-//MEANX
+ //MEANX
 #ifdef MEANX_PUT_MP3_IN_MP4A
    || track-&gt;enc-&gt;codec_id == CODEC_ID_MP3
 #endif
 //MEANX
-	    
-		    )
+ 
+    
+    )
         mov_write_esds_tag(pb, track);
     else if(track-&gt;enc-&gt;codec_id == CODEC_ID_AMR_NB)
         mov_write_amr_tag(pb, track);
@@ -498,7 +498,7 @@
     put_tag(pb, &quot;avcC&quot;);
     if (track-&gt;vosLen &gt; 6) {
         /* check for h264 start code */
-        if (BE_32(track-&gt;vosData) == 0x00000001) {
+        if (AV_RB32(track-&gt;vosData) == 0x00000001) {
             uint8_t *buf, *end;
             uint32_t sps_size=0, pps_size=0;
             uint8_t *sps=0, *pps=0;
@@ -511,7 +511,7 @@
             while (buf &lt; end) {
                 unsigned int size;
                 uint8_t nal_type;
-                size = BE_32(buf);
+                size = AV_RB32(buf);
                 nal_type = buf[4] &amp; 0x1f;
                 if (nal_type == 7) { /* SPS */
                     sps = buf + 4;
@@ -544,7 +544,7 @@
     return updateSize(pb, pos);
 }
 
-static const CodecTag codec_movvideo_tags[] = {
+static const AVCodecTag codec_movvideo_tags[] = {
     { CODEC_ID_SVQ1, MKTAG('S', 'V', 'Q', '1') },
     { CODEC_ID_SVQ3, MKTAG('S', 'V', 'Q', '3') },
     { CODEC_ID_MPEG4, MKTAG('m', 'p', '4', 'v') },
@@ -718,18 +718,46 @@
     return atom_size;
 }
 
-/* TODO: */
 /* Time to sample atom */
 static int mov_write_stts_tag(ByteIOContext *pb, MOVTrack* track)
 {
-    put_be32(pb, 0x18); /* size */
+    Time2Sample *stts_entries;
+    uint32_t entries = -1;
+    uint32_t atom_size;
+    int i;
+
+    if (track-&gt;enc-&gt;codec_type == CODEC_TYPE_AUDIO &amp;&amp; !track-&gt;audio_vbr) {
+        stts_entries = av_malloc(sizeof(*stts_entries)); /* one entry */
+        stts_entries[0].count = track-&gt;sampleCount;
+        stts_entries[0].duration = 1;
+        entries = 1;
+    } else {
+        stts_entries = av_malloc(track-&gt;entry * sizeof(*stts_entries)); /* worst case */
+        for (i=0; i&lt;track-&gt;entry; i++) {
+            int64_t duration = i + 1 == track-&gt;entry ?
+                track-&gt;trackDuration - track-&gt;cluster[i].dts + track-&gt;cluster[0].dts : /* readjusting */
+                track-&gt;cluster[i+1].dts - track-&gt;cluster[i].dts;
+            if (i &amp;&amp; duration == stts_entries[entries].duration) {
+                stts_entries[entries].count++; /* compress */
+            } else {
+                entries++;
+                stts_entries[entries].duration = duration;
+                stts_entries[entries].count = 1;
+            }
+        }
+        entries++; /* last one */
+    }
+    atom_size = 16 + (entries * 8);
+    put_be32(pb, atom_size); /* size */
     put_tag(pb, &quot;stts&quot;);
     put_be32(pb, 0); /* version &amp; flags */
-    put_be32(pb, 1); /* entry count */
-
-    put_be32(pb, track-&gt;sampleCount); /* sample count */
-    put_be32(pb, track-&gt;sampleDuration); /* sample duration */
-    return 0x18;
+    put_be32(pb, entries); /* entry count */
+    for (i=0; i&lt;entries; i++) {
+        put_be32(pb, stts_entries[i].count);
+        put_be32(pb, stts_entries[i].duration);
+    }
+    av_free(stts_entries);
+    return atom_size;
 }
 
 static int mov_write_dref_tag(ByteIOContext *pb)
@@ -942,8 +970,7 @@
 
     put_be32(pb, av_rescale_rnd(track-&gt;trackDuration, globalTimescale, track-&gt;timescale, AV_ROUND_UP)); /* duration   ... doesn't seem to effect psp */
 
-    // MEANX NO! put_be32(pb, track-&gt;cluster[0].cts); /* first pts is cts since dts is 0 */
-
+    //MEANX NO put_be32(pb, track-&gt;cluster[0].cts); /* first pts is cts since dts is 0 */
     put_be32(pb, 0x00000000);
     // /MEANX
 
@@ -1218,19 +1245,25 @@
     return updateSize(pb, pos);
 }
 
+static int utf8len(uint8_t *b){
+    int len=0;
+    int val;
+    while(*b){
+        GET_UTF8(val, *b++, return -1;)
+        len++;
+    }
+    return len;
+}
 
-static size_t ascii_to_wc (ByteIOContext *pb, char *b, size_t n)
+static int ascii_to_wc (ByteIOContext *pb, uint8_t *b)
 {
-    size_t i;
-    unsigned char c;
-    for (i = 0; i &lt; n - 1; i++) {
-        c = b[i];
-        if (! (0x20 &lt;= c &amp;&amp; c &lt;= 0x7f ))
-            c = 0x3f;  /* '?' */
-        put_be16(pb, c);
+    int val;
+    while(*b){
+        GET_UTF8(val, *b++, return -1;)
+        put_be16(pb, val);
     }
     put_be16(pb, 0x00);
-    return 2*n;
+    return 0;
 }
 
 static uint16_t language_code (const char *str)
@@ -1268,31 +1301,37 @@
         size += 12;
 
         // Encoder
-        len = strlen(LIBAVCODEC_IDENT)+1;
+        len = utf8len(LIBAVCODEC_IDENT)+1;
+        if(len&lt;=0)
+            goto not_utf8;
         put_be16(pb, len*2+10);             /* size */
         put_be32(pb, 0x04);                 /* type */
         put_be16(pb, language_code(&quot;eng&quot;)); /* language */
         put_be16(pb, 0x01);                 /* ? */
-        ascii_to_wc(pb, LIBAVCODEC_IDENT, len);
+        ascii_to_wc(pb, LIBAVCODEC_IDENT);
         size += len*2+10;
 
         // Title
-        len = strlen(s-&gt;title)+1;
+        len = utf8len(s-&gt;title)+1;
+        if(len&lt;=0)
+            goto not_utf8;
         put_be16(pb, len*2+10);             /* size */
         put_be32(pb, 0x01);                 /* type */
         put_be16(pb, language_code(&quot;eng&quot;)); /* language */
         put_be16(pb, 0x01);                 /* ? */
-        ascii_to_wc (pb, s-&gt;title, len);
+        ascii_to_wc (pb, s-&gt;title);
         size += len*2+10;
 
         // Date
 //        snprintf(dt,32,&quot;%04d/%02d/%02d %02d:%02d:%02d&quot;,t_st-&gt;tm_year+1900,t_st-&gt;tm_mon+1,t_st-&gt;tm_mday,t_st-&gt;tm_hour,t_st-&gt;tm_min,t_st-&gt;tm_sec);
-        len = strlen(&quot;2006/04/01 11:11:11&quot;)+1;
+        len = utf8len(&quot;2006/04/01 11:11:11&quot;)+1;
+        if(len&lt;=0)
+            goto not_utf8;
         put_be16(pb, len*2+10);    /* size */
         put_be32(pb, 0x03);        /* type */
         put_be16(pb, language_code(&quot;und&quot;)); /* language */
         put_be16(pb, 0x01);        /* ? */
-        ascii_to_wc (pb, &quot;2006/04/01 11:11:11&quot;, len);
+        ascii_to_wc (pb, &quot;2006/04/01 11:11:11&quot;);
         size += len*2+10;
 
         // size
@@ -1305,6 +1344,9 @@
     }
 
     return size;
+not_utf8:
+    av_log(s, AV_LOG_ERROR, &quot;not utf8\n&quot;);
+    return -1;
 }
 
 static int mov_write_moov_tag(ByteIOContext *pb, MOVContext *mov,
@@ -1319,8 +1361,6 @@
     for (i=0; i&lt;mov-&gt;nb_streams; i++) {
         if(mov-&gt;tracks[i].entry &lt;= 0) continue;
 
-        mov-&gt;tracks[i].trackDuration =
-            (int64_t)mov-&gt;tracks[i].sampleCount * mov-&gt;tracks[i].sampleDuration;
         mov-&gt;tracks[i].time = mov-&gt;time;
         mov-&gt;tracks[i].trackID = i+1;
     }
@@ -1336,7 +1376,7 @@
     if (mov-&gt;mode == MODE_PSP)
         mov_write_uuidusmt_tag(pb, s);
     else
-    mov_write_udta_tag(pb, mov, s);
+        mov_write_udta_tag(pb, mov, s);
 
     return updateSize(pb, pos);
 }
@@ -1481,19 +1521,26 @@
         if(st-&gt;codec-&gt;codec_type == CODEC_TYPE_VIDEO){
             track-&gt;tag = mov_find_video_codec_tag(s, track);
             track-&gt;timescale = st-&gt;codec-&gt;time_base.den;
-            track-&gt;sampleDuration = st-&gt;codec-&gt;time_base.num;
             av_set_pts_info(st, 64, 1, st-&gt;codec-&gt;time_base.den);
         }else if(st-&gt;codec-&gt;codec_type == CODEC_TYPE_AUDIO){
             track-&gt;tag = mov_find_audio_codec_tag(s, track);
             track-&gt;timescale = st-&gt;codec-&gt;sample_rate;
-            track-&gt;sampleDuration = st-&gt;codec-&gt;frame_size;
             av_set_pts_info(st, 64, 1, st-&gt;codec-&gt;sample_rate);
-            track-&gt;sampleSize = (av_get_bits_per_sample(st-&gt;codec-&gt;codec_id) &gt;&gt; 3) * st-&gt;codec-&gt;channels;
+            switch(track-&gt;enc-&gt;codec_id){
+            case CODEC_ID_MP3:
+            case CODEC_ID_AAC:
+            case CODEC_ID_AMR_NB:
+            case CODEC_ID_AMR_WB:
+                track-&gt;audio_vbr = 1;
+                break;
+            default:
+                track-&gt;sampleSize = (av_get_bits_per_sample(st-&gt;codec-&gt;codec_id) &gt;&gt; 3) * st-&gt;codec-&gt;channels;
+            }
+            if (!st-&gt;codec-&gt;frame_size) {
+                av_log(s, AV_LOG_ERROR, &quot;track %d: codec frame size is not set\n&quot;, i);
+                return -1;
+            }
         }
-        if (!track-&gt;sampleDuration) {
-            av_log(s, AV_LOG_ERROR, &quot;track %d: sample duration is not set\n&quot;, i);
-            return -1;
-        }
     }
 
     mov_write_mdat_tag(pb, mov);
@@ -1561,6 +1608,9 @@
     trk-&gt;cluster[trk-&gt;entry].samplesInChunk = samplesInChunk;
     trk-&gt;cluster[trk-&gt;entry].size = size;
     trk-&gt;cluster[trk-&gt;entry].entries = samplesInChunk;
+    trk-&gt;cluster[trk-&gt;entry].dts = pkt-&gt;dts;
+    trk-&gt;trackDuration = pkt-&gt;dts - trk-&gt;cluster[0].dts + pkt-&gt;duration;
+
     if(enc-&gt;codec_type == CODEC_TYPE_VIDEO) {
         if (pkt-&gt;dts != pkt-&gt;pts)
             trk-&gt;hasBframes = 1;

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/mpeg.c
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/mpeg.c	2007-01-20 15:15:58 UTC (rev 2746)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/mpeg.c	2007-01-21 18:04:24 UTC (rev 2747)
@@ -1,23 +1,26 @@
 /*
- * MPEG1/2 mux/demux
+ * MPEG1/2 muxer and demuxer
  * Copyright (c) 2000, 2001, 2002 Fabrice Bellard.
  *
- * This library is free software; you can redistribute it and/or
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
  * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
+ * version 2.1 of the License, or (at your option) any later version.
  *
- * This library is distributed in the hope that it will be useful,
+ * FFmpeg is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  * Lesser General Public License for more details.
  *
  * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
+ * License along with FFmpeg; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 #include &quot;avformat.h&quot;
 #include &quot;bitstream.h&quot;
+#include &quot;fifo.h&quot;
 
 #define MAX_PAYLOAD_SIZE 4096
 //#define DEBUG_SEEK
@@ -35,7 +38,7 @@
 } PacketDesc;
 
 typedef struct {
-    FifoBuffer fifo;
+    AVFifoBuffer fifo;
     uint8_t id;
     int max_buffer_size; /* in bytes */
     int buffer_index;
@@ -45,7 +48,7 @@
     int packet_number;
     uint8_t lpcm_header[3];
     int lpcm_align;
-    uint8_t *fifo_iframe_ptr;
+    int bytes_to_iframe;
     int align_iframe;
     int64_t vobu_start_pts;
 } StreamInfo;
@@ -108,11 +111,11 @@
 static const int lpcm_freq_tab[4] = { 48000, 96000, 44100, 32000 };
 
 #ifdef CONFIG_MUXERS
-static AVOutputFormat mpeg1system_mux;
-static AVOutputFormat mpeg1vcd_mux;
-static AVOutputFormat mpeg2vob_mux;
-static AVOutputFormat mpeg2svcd_mux;
-static AVOutputFormat mpeg2dvd_mux;
+AVOutputFormat mpeg1system_muxer;
+AVOutputFormat mpeg1vcd_muxer;
+AVOutputFormat mpeg2vob_muxer;
+AVOutputFormat mpeg2svcd_muxer;
+AVOutputFormat mpeg2dvd_muxer;
 
 static int put_pack_header(AVFormatContext *ctx,
                            uint8_t *buf, int64_t timestamp)
@@ -330,10 +333,10 @@
     int video_bitrate;
 
     s-&gt;packet_number = 0;
-    s-&gt;is_vcd = (ctx-&gt;oformat == &amp;mpeg1vcd_mux);
-    s-&gt;is_svcd = (ctx-&gt;oformat == &amp;mpeg2svcd_mux);
-    s-&gt;is_mpeg2 = (ctx-&gt;oformat == &amp;mpeg2vob_mux || ctx-&gt;oformat == &amp;mpeg2svcd_mux || ctx-&gt;oformat == &amp;mpeg2dvd_mux);
-    s-&gt;is_dvd = (ctx-&gt;oformat == &amp;mpeg2dvd_mux);
+    s-&gt;is_vcd = (ctx-&gt;oformat == &amp;mpeg1vcd_muxer);
+    s-&gt;is_svcd = (ctx-&gt;oformat == &amp;mpeg2svcd_muxer);
+    s-&gt;is_mpeg2 = (ctx-&gt;oformat == &amp;mpeg2vob_muxer || ctx-&gt;oformat == &amp;mpeg2svcd_muxer || ctx-&gt;oformat == &amp;mpeg2dvd_muxer);
+    s-&gt;is_dvd = (ctx-&gt;oformat == &amp;mpeg2dvd_muxer);
 
     if(ctx-&gt;packet_size)
         s-&gt;packet_size = ctx-&gt;packet_size;
@@ -412,7 +415,7 @@
         default:
             return -1;
         }
-        fifo_init(&amp;stream-&gt;fifo, 16);
+        av_fifo_init(&amp;stream-&gt;fifo, 16);
     }
     bitrate = 0;
     audio_bitrate = 0;
@@ -708,14 +711,7 @@
             }
         } else if (s-&gt;is_dvd) {
             if (stream-&gt;align_iframe || s-&gt;packet_number == 0){
-                int bytes_to_iframe;
-                int PES_bytes_to_fill;
-                if (stream-&gt;fifo_iframe_ptr &gt;= stream-&gt;fifo.rptr) {
-                    bytes_to_iframe = stream-&gt;fifo_iframe_ptr - stream-&gt;fifo.rptr;
-                } else {
-                    bytes_to_iframe = (stream-&gt;fifo.end - stream-&gt;fifo.rptr) + (stream-&gt;fifo_iframe_ptr - stream-&gt;fifo.buffer);
-                }
-                PES_bytes_to_fill = s-&gt;packet_size - size - 10;
+                int PES_bytes_to_fill = s-&gt;packet_size - size - 10;
 
                 if (pts != AV_NOPTS_VALUE) {
                     if (dts != pts)
@@ -724,7 +720,7 @@
                         PES_bytes_to_fill -= 5;
                 }
 
-                if (bytes_to_iframe == 0 || s-&gt;packet_number == 0) {
+                if (stream-&gt;bytes_to_iframe == 0 || s-&gt;packet_number == 0) {
                     size = put_system_header(ctx, buf_ptr, 0);
                     buf_ptr += size;
                     size = buf_ptr - buffer;
@@ -751,8 +747,8 @@
                     s-&gt;last_scr= scr;
                     buf_ptr += size;
                     /* GOP Start */
-                } else if (bytes_to_iframe &lt; PES_bytes_to_fill) {
-                    pad_packet_bytes = PES_bytes_to_fill - bytes_to_iframe;
+                } else if (stream-&gt;bytes_to_iframe &lt; PES_bytes_to_fill) {
+                    pad_packet_bytes = PES_bytes_to_fill - stream-&gt;bytes_to_iframe;
                 }
             }
         } else {
@@ -824,7 +820,7 @@
             startcode = 0x100 + id;
         }
 
-        stuffing_size = payload_size - fifo_size(&amp;stream-&gt;fifo, stream-&gt;fifo.rptr);
+        stuffing_size = payload_size - av_fifo_size(&amp;stream-&gt;fifo);
 
         // first byte doesnt fit -&gt; reset pts/dts + stuffing
         if(payload_size &lt;= trailer_size &amp;&amp; pts != AV_NOPTS_VALUE){
@@ -951,8 +947,9 @@
         }
 
         /* output data */
-        if(put_fifo(&amp;ctx-&gt;pb, &amp;stream-&gt;fifo, payload_size - stuffing_size, &amp;stream-&gt;fifo.rptr) &lt; 0)
+        if(av_fifo_generic_read(&amp;stream-&gt;fifo, payload_size - stuffing_size, &amp;put_buffer, &amp;ctx-&gt;pb) &lt; 0)
             return -1;
+        stream-&gt;bytes_to_iframe -= payload_size - stuffing_size;
     }else{
         payload_size=
         stuffing_size= 0;
@@ -1065,7 +1062,7 @@
     for(i=0; i&lt;ctx-&gt;nb_streams; i++){
         AVStream *st = ctx-&gt;streams[i];
         StreamInfo *stream = st-&gt;priv_data;
-        const int avail_data=  fifo_size(&amp;stream-&gt;fifo, stream-&gt;fifo.rptr);
+        const int avail_data=  av_fifo_size(&amp;stream-&gt;fifo);
         const int space= stream-&gt;max_buffer_size - stream-&gt;buffer_index;
         int rel_space= 1024*space / stream-&gt;max_buffer_size;
         PacketDesc *next_pkt= stream-&gt;premux_packet;
@@ -1125,7 +1122,7 @@
     st = ctx-&gt;streams[best_i];
     stream = st-&gt;priv_data;
 
-    assert(fifo_size(&amp;stream-&gt;fifo, stream-&gt;fifo.rptr) &gt; 0);
+    assert(av_fifo_size(&amp;stream-&gt;fifo) &gt; 0);
 
     assert(avail_space &gt;= s-&gt;packet_size || ignore_constraints);
 
@@ -1141,7 +1138,7 @@
 //av_log(ctx, AV_LOG_DEBUG, &quot;dts:%f pts:%f scr:%f stream:%d\n&quot;, timestamp_packet-&gt;dts/90000.0, timestamp_packet-&gt;pts/90000.0, scr/90000.0, best_i);
         es_size= flush_packet(ctx, best_i, timestamp_packet-&gt;pts, timestamp_packet-&gt;dts, scr, trailer_size);
     }else{
-        assert(fifo_size(&amp;stream-&gt;fifo, stream-&gt;fifo.rptr) == trailer_size);
+        assert(av_fifo_size(&amp;stream-&gt;fifo) == trailer_size);
         es_size= flush_packet(ctx, best_i, AV_NOPTS_VALUE, AV_NOPTS_VALUE, scr, trailer_size);
     }
 
@@ -1204,11 +1201,11 @@
         stream-&gt;predecode_packet= pkt_desc;
     stream-&gt;next_packet= &amp;pkt_desc-&gt;next;
 
-    fifo_realloc(&amp;stream-&gt;fifo, fifo_size(&amp;stream-&gt;fifo, NULL) + size + 1);
+    av_fifo_realloc(&amp;stream-&gt;fifo, av_fifo_size(&amp;stream-&gt;fifo) + size + 1);
 
     if (s-&gt;is_dvd){
         if (is_iframe &amp;&amp; (s-&gt;packet_number == 0 || (pts - stream-&gt;vobu_start_pts &gt;= 36000))) { // min VOBU length 0.4 seconds (mpucoder)
-            stream-&gt;fifo_iframe_ptr = stream-&gt;fifo.wptr;
+            stream-&gt;bytes_to_iframe = av_fifo_size(&amp;stream-&gt;fifo);
             stream-&gt;align_iframe = 1;
             stream-&gt;vobu_start_pts = pts;
         } else {
@@ -1216,7 +1213,7 @@
         }
     }
 
-    fifo_write(&amp;stream-&gt;fifo, buf, size, &amp;stream-&gt;fifo.wptr);
+    av_fifo_write(&amp;stream-&gt;fifo, buf, size);
 
     for(;;){
         int ret= output_packet(ctx, 0);
@@ -1248,8 +1245,8 @@
     for(i=0;i&lt;ctx-&gt;nb_streams;i++) {
         stream = ctx-&gt;streams[i]-&gt;priv_data;
 
-        assert(fifo_size(&amp;stream-&gt;fifo, stream-&gt;fifo.rptr) == 0);
-        fifo_free(&amp;stream-&gt;fifo);
+        assert(av_fifo_size(&amp;stream-&gt;fifo) == 0);
+        av_fifo_free(&amp;stream-&gt;fifo);
     }
     return 0;
 }
@@ -1260,33 +1257,60 @@
 
 #define MAX_SYNC_SIZE 100000
 
+static int cdxa_probe(AVProbeData *p)
+{
+    /* check file header */
+    if (p-&gt;buf_size &lt;= 32)
+        return 0;
+    if (p-&gt;buf[0] == 'R' &amp;&amp; p-&gt;buf[1] == 'I' &amp;&amp;
+        p-&gt;buf[2] == 'F' &amp;&amp; p-&gt;buf[3] == 'F' &amp;&amp;
+        p-&gt;buf[8] == 'C' &amp;&amp; p-&gt;buf[9] == 'D' &amp;&amp;
+        p-&gt;buf[10] == 'X' &amp;&amp; p-&gt;buf[11] == 'A')
+        return AVPROBE_SCORE_MAX;
+    else
+        return 0;
+}
+
 static int mpegps_probe(AVProbeData *p)
 {
     uint32_t code= -1;
-    int sys=0, pspack=0, priv1=0, vid=0;
+    int sys=0, pspack=0, priv1=0, vid=0, audio=0;
     int i;
+    int score=0;
 
+    score = cdxa_probe(p);
+    if (score &gt; 0) return score;
+
+    /* Search for MPEG stream */
     for(i=0; i&lt;p-&gt;buf_size; i++){
         code = (code&lt;&lt;8) + p-&gt;buf[i];
         if ((code &amp; 0xffffff00) == 0x100) {
-            switch(code){
-            case SYSTEM_HEADER_START_CODE:    sys++; break;
-            case         PRIVATE_STREAM_1:  priv1++; break;
-            case          PACK_START_CODE: pspack++; break;
-            case       (VIDEO_ID + 0x100):    vid++; break;
-            }
+            if(code == SYSTEM_HEADER_START_CODE) sys++;
+            else if(code == PRIVATE_STREAM_1)    priv1++;
+            else if(code == PACK_START_CODE)     pspack++;
+            else if((code &amp; 0xf0) == VIDEO_ID)   vid++;
+            else if((code &amp; 0xe0) == AUDIO_ID)   audio++;
         }
     }
+
+    if(vid || audio)            /* invalid VDR files nd short PES streams */
+        score= AVPROBE_SCORE_MAX/4;
+
+//av_log(NULL, AV_LOG_ERROR, &quot;%d %d %d %d %d\n&quot;, sys, priv1, pspack,vid, audio);
     if(sys &amp;&amp; sys*9 &lt;= pspack*10)
         return AVPROBE_SCORE_MAX/2+2; // +1 for .mpg
-    if((priv1 || vid) &amp;&amp; (priv1+vid)*9 &lt;= pspack*10)
+    if((priv1 || vid || audio) &amp;&amp; (priv1+vid+audio)*9 &lt;= pspack*10)
         return AVPROBE_SCORE_MAX/2+2; // +1 for .mpg
-    return 0;
+    if((!!vid ^ !!audio) &amp;&amp; (audio+vid &gt; 1) &amp;&amp; !sys &amp;&amp; !pspack) /* PES stream */
+        return AVPROBE_SCORE_MAX/2+2;
+
+    //02-Penguin.flac has sys:0 priv1:0 pspack:0 vid:0 audio:1
+    return score;
 }
 
 
 typedef struct MpegDemuxContext {
-    int header_state;
+    int32_t header_state;
     unsigned char psm_es_type[256];
 } MpegDemuxContext;
 
@@ -1317,7 +1341,7 @@
 }
 
 static int find_next_start_code(ByteIOContext *pb, int *size_ptr,
-                                uint32_t *header_state)
+                                int32_t *header_state)
 {
     unsigned int state, v;
     int val, n;
@@ -1421,15 +1445,18 @@
 {
     MpegDemuxContext *m = s-&gt;priv_data;
     int len, size, startcode, c, flags, header_len;
-    int64_t pts, dts, last_pos;
+    int64_t pts, dts;
+    int64_t last_sync= url_ftell(&amp;s-&gt;pb);
 
-    last_pos = -1;
+ error_redo:
+        url_fseek(&amp;s-&gt;pb, last_sync, SEEK_SET);
  redo:
         /* next start code (should be immediately after) */
         m-&gt;header_state = 0xff;
         size = MAX_SYNC_SIZE;
         startcode = find_next_start_code(&amp;s-&gt;pb, &amp;size, &amp;m-&gt;header_state);
-    //printf(&quot;startcode=%x pos=0x%Lx\n&quot;, startcode, url_ftell(&amp;s-&gt;pb));
+        last_sync = url_ftell(&amp;s-&gt;pb);
+    //printf(&quot;startcode=%x pos=0x%&quot;PRIx64&quot;\n&quot;, startcode, url_ftell(&amp;s-&gt;pb));
     if (startcode &lt; 0)
         return AVERROR_IO;
     if (startcode == PACK_START_CODE)
@@ -1457,12 +1484,12 @@
         *ppos = url_ftell(&amp;s-&gt;pb) - 4;
     }
     len = get_be16(&amp;s-&gt;pb);
-    pts = AV_NOPTS_VALUE;
+    pts =
     dts = AV_NOPTS_VALUE;
     /* stuffing */
     for(;;) {
         if (len &lt; 1)
-            goto redo;
+            goto error_redo;
         c = get_byte(&amp;s-&gt;pb);
         len--;
         /* XXX: for mpeg1, should test only bit 7 */
@@ -1471,72 +1498,59 @@
     }
     if ((c &amp; 0xc0) == 0x40) {
         /* buffer scale &amp; size */
-        if (len &lt; 2)
-            goto redo;
         get_byte(&amp;s-&gt;pb);
         c = get_byte(&amp;s-&gt;pb);
         len -= 2;
     }
-    if ((c &amp; 0xf0) == 0x20) {
-        if (len &lt; 4)
-            goto redo;
+    if ((c &amp; 0xe0) == 0x20) {
         dts = pts = get_pts(&amp;s-&gt;pb, c);
         len -= 4;
-    } else if ((c &amp; 0xf0) == 0x30) {
-        if (len &lt; 9)
-            goto redo;
-        pts = get_pts(&amp;s-&gt;pb, c);
-        dts = get_pts(&amp;s-&gt;pb, -1);
-        len -= 9;
+        if (c &amp; 0x10){
+            dts = get_pts(&amp;s-&gt;pb, -1);
+            len -= 5;
+        }
     } else if ((c &amp; 0xc0) == 0x80) {
         /* mpeg 2 PES */
+#if 0 /* some streams have this field set for no apparent reason */
         if ((c &amp; 0x30) != 0) {
             /* Encrypted multiplex not handled */
             goto redo;
         }
+#endif
         flags = get_byte(&amp;s-&gt;pb);
         header_len = get_byte(&amp;s-&gt;pb);
         len -= 2;
         if (header_len &gt; len)
-            goto redo;
-        if ((flags &amp; 0xc0) == 0x80) {
+            goto error_redo;
+        len -= header_len;
+        if (flags &amp; 0x80) {
             dts = pts = get_pts(&amp;s-&gt;pb, -1);
-            if (header_len &lt; 5)
-                goto redo;
             header_len -= 5;
-            len -= 5;
-        } if ((flags &amp; 0xc0) == 0xc0) {
-            pts = get_pts(&amp;s-&gt;pb, -1);
-            dts = get_pts(&amp;s-&gt;pb, -1);
-            if (header_len &lt; 10)
-                goto redo;
-            header_len -= 10;
-            len -= 10;
+            if (flags &amp; 0x40) {
+                dts = get_pts(&amp;s-&gt;pb, -1);
+                header_len -= 5;
+            }
         }
-        len -= header_len;
-        while (header_len &gt; 0) {
-            get_byte(&amp;s-&gt;pb);
-            header_len--;
-        }
+        if(header_len &lt; 0)
+            goto error_redo;
+        url_fskip(&amp;s-&gt;pb, header_len);
     }
     else if( c!= 0xf )
         goto redo;
 
     if (startcode == PRIVATE_STREAM_1 &amp;&amp; !m-&gt;psm_es_type[startcode &amp; 0xff]) {
-        if (len &lt; 1)
-            goto redo;
         startcode = get_byte(&amp;s-&gt;pb);
         len--;
         if (startcode &gt;= 0x80 &amp;&amp; startcode &lt;= 0xbf) {
             /* audio: skip header */
-            if (len &lt; 3)
-                goto redo;
             get_byte(&amp;s-&gt;pb);
             get_byte(&amp;s-&gt;pb);
             get_byte(&amp;s-&gt;pb);
             len -= 3;
         }
     }
+    if(len&lt;0)
+        goto error_redo;
     if(dts != AV_NOPTS_VALUE &amp;&amp; ppos){
         int i;
         for(i=0; i&lt;s-&gt;nb_streams; i++){
@@ -1600,8 +1614,15 @@
             goto skip;
         }
     } else if (startcode &gt;= 0x1e0 &amp;&amp; startcode &lt;= 0x1ef) {
+        static const unsigned char avs_seqh[4] = { 0, 0, 1, 0xb0 };
+        unsigned char buf[8];
+        get_buffer(&amp;s-&gt;pb, buf, 8);
+        url_fseek(&amp;s-&gt;pb, -8, SEEK_CUR);
+        if(!memcmp(buf, avs_seqh, 4) &amp;&amp; (buf[6] != 0 || buf[7] != 1))
+            codec_id = CODEC_ID_CAVS;
+        else
+            codec_id = CODEC_ID_MPEG2VIDEO;
         type = CODEC_TYPE_VIDEO;
-        codec_id = CODEC_ID_MPEG2VIDEO;
     } else if (startcode &gt;= 0x1c0 &amp;&amp; startcode &lt;= 0x1df) {
         type = CODEC_TYPE_AUDIO;
         codec_id = CODEC_ID_MP2;
@@ -1676,7 +1697,7 @@
 
     pos = *ppos;
 #ifdef DEBUG_SEEK
-    printf(&quot;read_dts: pos=0x%llx next=%d -&gt; &quot;, pos, find_next);
+    printf(&quot;read_dts: pos=0x%&quot;PRIx64&quot; next=%d -&gt; &quot;, pos, find_next);
 #endif
     url_fseek(&amp;s-&gt;pb, pos, SEEK_SET);
     for(;;) {
@@ -1694,14 +1715,14 @@
         url_fskip(&amp;s-&gt;pb, len);
     }
 #ifdef DEBUG_SEEK
-    printf(&quot;pos=0x%llx dts=0x%llx %0.3f\n&quot;, pos, dts, dts / 90000.0);
+    printf(&quot;pos=0x%&quot;PRIx64&quot; dts=0x%&quot;PRIx64&quot; %0.3f\n&quot;, pos, dts, dts / 90000.0);
 #endif
     *ppos = pos;
     return dts;
 }
 
-#ifdef CONFIG_MUXERS
-static AVOutputFormat mpeg1system_mux = {
+#ifdef CONFIG_MPEG1SYSTEM_MUXER
+AVOutputFormat mpeg1system_muxer = {
     &quot;mpeg&quot;,
     &quot;MPEG1 System format&quot;,
     &quot;video/mpeg&quot;,
@@ -1713,8 +1734,9 @@
     mpeg_mux_write_packet,
     mpeg_mux_end,
 };
-
-static AVOutputFormat mpeg1vcd_mux = {
+#endif
+#ifdef CONFIG_MPEG1VCD_MUXER
+AVOutputFormat mpeg1vcd_muxer = {
     &quot;vcd&quot;,
     &quot;MPEG1 System format (VCD)&quot;,
     &quot;video/mpeg&quot;,
@@ -1726,8 +1748,9 @@
     mpeg_mux_write_packet,
     mpeg_mux_end,
 };
-
-static AVOutputFormat mpeg2vob_mux = {
+#endif
+#ifdef CONFIG_MPEG2VOB_MUXER
+AVOutputFormat mpeg2vob_muxer = {
     &quot;vob&quot;,
     &quot;MPEG2 PS format (VOB)&quot;,
     &quot;video/mpeg&quot;,
@@ -1739,9 +1762,11 @@
     mpeg_mux_write_packet,
     mpeg_mux_end,
 };
+#endif
 
 /* Same as mpeg2vob_mux except that the pack size is 2324 */
-static AVOutputFormat mpeg2svcd_mux = {
+#ifdef CONFIG_MPEG2SVCD_MUXER
+AVOutputFormat mpeg2svcd_muxer = {
     &quot;svcd&quot;,
     &quot;MPEG2 PS format (VOB)&quot;,
     &quot;video/mpeg&quot;,
@@ -1753,9 +1778,11 @@
     mpeg_mux_write_packet,
     mpeg_mux_end,
 };
+#endif
 
 /*  Same as mpeg2vob_mux except the 'is_dvd' flag is set to produce NAV pkts */
-static AVOutputFormat mpeg2dvd_mux = {
+#ifdef CONFIG_MPEG2DVD_MUXER
+AVOutputFormat mpeg2dvd_muxer = {
     &quot;dvd&quot;,
     &quot;MPEG2 PS format (DVD VOB)&quot;,
     &quot;video/mpeg&quot;,
@@ -1767,10 +1794,10 @@
     mpeg_mux_write_packet,
     mpeg_mux_end,
 };
+#endif
 
-#endif //CONFIG_MUXERS
-
-AVInputFormat mpegps_demux = {
+#ifdef CONFIG_MPEGPS_DEMUXER
+AVInputFormat mpegps_demuxer = {
     &quot;mpeg&quot;,
     &quot;MPEG PS format&quot;,
     sizeof(MpegDemuxContext),
@@ -1782,16 +1809,4 @@
     mpegps_read_dts,
     .flags = AVFMT_SHOW_IDS,
 };
-
-int mpegps_init(void)
-{
-#ifdef CONFIG_MUXERS
-    av_register_output_format(&amp;mpeg1system_mux);
-    av_register_output_format(&amp;mpeg1vcd_mux);
-    av_register_output_format(&amp;mpeg2vob_mux);
-    av_register_output_format(&amp;mpeg2svcd_mux);
-    av_register_output_format(&amp;mpeg2dvd_mux);
-#endif //CONFIG_MUXERS
-    av_register_input_format(&amp;mpegps_demux);
-    return 0;
-}
+#endif

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/mpegts.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/mpegts.h	2007-01-20 15:15:58 UTC (rev 2746)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/mpegts.h	2007-01-21 18:04:24 UTC (rev 2747)
@@ -2,22 +2,25 @@
  * MPEG2 transport stream defines
  * Copyright (c) 2003 Fabrice Bellard.
  *
- * This library is free software; you can redistribute it and/or
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
  * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
+ * version 2.1 of the License, or (at your option) any later version.
  *
- * This library is distributed in the hope that it will be useful,
+ * FFmpeg is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  * Lesser General Public License for more details.
  *
  * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
 #define TS_FEC_PACKET_SIZE 204
+#define TS_DVHS_PACKET_SIZE 192
 #define TS_PACKET_SIZE 188
 #define NB_PID_MAX 8192
 #define MAX_SECTION_SIZE 4096
@@ -28,9 +31,12 @@
 
 /* table ids */
 #define PAT_TID   0x00
-#define PMT_TID   0x02 
+#define PMT_TID   0x02
 #define SDT_TID   0x42
 
+/* descriptor ids */
+#define DVB_SUBT_DESCID             0x59
+
 #define STREAM_TYPE_VIDEO_MPEG1     0x01
 #define STREAM_TYPE_VIDEO_MPEG2     0x02
 #define STREAM_TYPE_AUDIO_MPEG1     0x03
@@ -44,8 +50,10 @@
 #define STREAM_TYPE_AUDIO_AC3       0x81
 #define STREAM_TYPE_AUDIO_DTS       0x8a
 
+#define STREAM_TYPE_SUBTITLE_DVB    0x100
+
 unsigned int mpegts_crc32(const uint8_t *data, int len);
-extern AVOutputFormat mpegts_mux;
+extern AVOutputFormat mpegts_muxer;
 
 typedef struct MpegTSContext MpegTSContext;
 

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/mpegtsenc.c
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/mpegtsenc.c	2007-01-20 15:15:58 UTC (rev 2746)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/mpegtsenc.c	2007-01-21 18:04:24 UTC (rev 2747)
@@ -1,84 +1,29 @@
 /*
- * MPEG2 transport stream (aka DVB) mux
+ * MPEG2 transport stream (aka DVB) muxer
  * Copyright (c) 2003 Fabrice Bellard.
  *
- * This library is free software; you can redistribute it and/or
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
  * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
+ * version 2.1 of the License, or (at your option) any later version.
  *
- * This library is distributed in the hope that it will be useful,
+ * FFmpeg is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  * Lesser General Public License for more details.
  *
  * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 #include &quot;avformat.h&quot;
-
+#include &quot;crc.h&quot;
 #include &quot;mpegts.h&quot;
 
 /* write DVB SI sections */
 
-static const uint32_t crc_table[256] = {
-        0x00000000, 0x04c11db7, 0x09823b6e, 0x0d4326d9, 0x130476dc, 0x17c56b6b,
-        0x1a864db2, 0x1e475005, 0x2608edb8, 0x22c9f00f, 0x2f8ad6d6, 0x2b4bcb61,
-        0x350c9b64, 0x31cd86d3, 0x3c8ea00a, 0x384fbdbd, 0x4c11db70, 0x48d0c6c7,
-        0x4593e01e, 0x4152fda9, 0x5f15adac, 0x5bd4b01b, 0x569796c2, 0x52568b75,
-        0x6a1936c8, 0x6ed82b7f, 0x639b0da6, 0x675a1011, 0x791d4014, 0x7ddc5da3,
-        0x709f7b7a, 0x745e66cd, 0x9823b6e0, 0x9ce2ab57, 0x91a18d8e, 0x95609039,
-        0x8b27c03c, 0x8fe6dd8b, 0x82a5fb52, 0x8664e6e5, 0xbe2b5b58, 0xbaea46ef,
-        0xb7a96036, 0xb3687d81, 0xad2f2d84, 0xa9ee3033, 0xa4ad16ea, 0xa06c0b5d,
-        0xd4326d90, 0xd0f37027, 0xddb056fe, 0xd9714b49, 0xc7361b4c, 0xc3f706fb,
-        0xceb42022, 0xca753d95, 0xf23a8028, 0xf6fb9d9f, 0xfbb8bb46, 0xff79a6f1,
-        0xe13ef6f4, 0xe5ffeb43, 0xe8bccd9a, 0xec7dd02d, 0x34867077, 0x30476dc0,
-        0x3d044b19, 0x39c556ae, 0x278206ab, 0x23431b1c, 0x2e003dc5, 0x2ac12072,
-        0x128e9dcf, 0x164f8078, 0x1b0ca6a1, 0x1fcdbb16, 0x018aeb13, 0x054bf6a4,
-        0x0808d07d, 0x0cc9cdca, 0x7897ab07, 0x7c56b6b0, 0x71159069, 0x75d48dde,
-        0x6b93dddb, 0x6f52c06c, 0x6211e6b5, 0x66d0fb02, 0x5e9f46bf, 0x5a5e5b08,
-        0x571d7dd1, 0x53dc6066, 0x4d9b3063, 0x495a2dd4, 0x44190b0d, 0x40d816ba,
-        0xaca5c697, 0xa864db20, 0xa527fdf9, 0xa1e6e04e, 0xbfa1b04b, 0xbb60adfc,
-        0xb6238b25, 0xb2e29692, 0x8aad2b2f, 0x8e6c3698, 0x832f1041, 0x87ee0df6,
-        0x99a95df3, 0x9d684044, 0x902b669d, 0x94ea7b2a, 0xe0b41de7, 0xe4750050,
-        0xe9362689, 0xedf73b3e, 0xf3b06b3b, 0xf771768c, 0xfa325055, 0xfef34de2,
-        0xc6bcf05f, 0xc27dede8, 0xcf3ecb31, 0xcbffd686, 0xd5b88683, 0xd1799b34,
-        0xdc3abded, 0xd8fba05a, 0x690ce0ee, 0x6dcdfd59, 0x608edb80, 0x644fc637,
-        0x7a089632, 0x7ec98b85, 0x738aad5c, 0x774bb0eb, 0x4f040d56, 0x4bc510e1,
-        0x46863638, 0x42472b8f, 0x5c007b8a, 0x58c1663d, 0x558240e4, 0x51435d53,
-        0x251d3b9e, 0x21dc2629, 0x2c9f00f0, 0x285e1d47, 0x36194d42, 0x32d850f5,
-        0x3f9b762c, 0x3b5a6b9b, 0x0315d626, 0x07d4cb91, 0x0a97ed48, 0x0e56f0ff,
-        0x1011a0fa, 0x14d0bd4d, 0x19939b94, 0x1d528623, 0xf12f560e, 0xf5ee4bb9,
-        0xf8ad6d60, 0xfc6c70d7, 0xe22b20d2, 0xe6ea3d65, 0xeba91bbc, 0xef68060b,
-        0xd727bbb6, 0xd3e6a601, 0xdea580d8, 0xda649d6f, 0xc423cd6a, 0xc0e2d0dd,
-        0xcda1f604, 0xc960ebb3, 0xbd3e8d7e, 0xb9ff90c9, 0xb4bcb610, 0xb07daba7,
-        0xae3afba2, 0xaafbe615, 0xa7b8c0cc, 0xa379dd7b, 0x9b3660c6, 0x9ff77d71,
-        0x92b45ba8, 0x9675461f, 0x8832161a, 0x8cf30bad, 0x81b02d74, 0x857130c3,
-        0x5d8a9099, 0x594b8d2e, 0x5408abf7, 0x50c9b640, 0x4e8ee645, 0x4a4ffbf2,
-        0x470cdd2b, 0x43cdc09c, 0x7b827d21, 0x7f436096, 0x7200464f, 0x76c15bf8,
-        0x68860bfd, 0x6c47164a, 0x61043093, 0x65c52d24, 0x119b4be9, 0x155a565e,
-        0x18197087, 0x1cd86d30, 0x029f3d35, 0x065e2082, 0x0b1d065b, 0x0fdc1bec,
-        0x3793a651, 0x3352bbe6, 0x3e119d3f, 0x3ad08088, 0x2497d08d, 0x2056cd3a,
-        0x2d15ebe3, 0x29d4f654, 0xc5a92679, 0xc1683bce, 0xcc2b1d17, 0xc8ea00a0,
-        0xd6ad50a5, 0xd26c4d12, 0xdf2f6bcb, 0xdbee767c, 0xe3a1cbc1, 0xe760d676,
-        0xea23f0af, 0xeee2ed18, 0xf0a5bd1d, 0xf464a0aa, 0xf9278673, 0xfde69bc4,
-        0x89b8fd09, 0x8d79e0be, 0x803ac667, 0x84fbdbd0, 0x9abc8bd5, 0x9e7d9662,
-        0x933eb0bb, 0x97ffad0c, 0xafb010b1, 0xab710d06, 0xa6322bdf, 0xa2f33668,
-        0xbcb4666d, 0xb8757bda, 0xb5365d03, 0xb1f740b4
-};
-
-unsigned int mpegts_crc32(const uint8_t *data, int len)
-{
-    register int i;
-    unsigned int crc = 0xffffffff;
-
-    for (i=0; i&lt;len; i++)
-        crc = (crc &lt;&lt; 8) ^ crc_table[((crc &gt;&gt; 24) ^ *data++) &amp; 0xff];
-
-    return crc;
-}
-
 /*********************************************/
 /* mpegts section writer */
 
@@ -90,7 +35,7 @@
 } MpegTSSection;
 
 /* NOTE: 4 bytes must be left at the end for the crc32 */
-void mpegts_write_section(MpegTSSection *s, uint8_t *buf, int len)
+static void mpegts_write_section(MpegTSSection *s, uint8_t *buf, int len)
 {
     unsigned int crc;
     unsigned char packet[TS_PACKET_SIZE];
@@ -98,7 +43,7 @@
     unsigned char *q;
     int first, b, len1, left;
 
-    crc = mpegts_crc32(buf, len - 4);
+    crc = bswap_32(av_crc(av_crc04C11DB7, -1, buf, len - 4));
     buf[len - 4] = (crc &gt;&gt; 24) &amp; 0xff;
     buf[len - 3] = (crc &gt;&gt; 16) &amp; 0xff;
     buf[len - 2] = (crc &gt;&gt; 8) &amp; 0xff;
@@ -145,7 +90,7 @@
     *q_ptr = q;
 }
 
-int mpegts_write_section1(MpegTSSection *s, int tid, int id,
+static int mpegts_write_section1(MpegTSSection *s, int tid, int id,
                           int version, int sec_num, int last_sec_num,
                           uint8_t *buf, int len)
 {
@@ -717,7 +662,7 @@
     return 0;
 }
 
-AVOutputFormat mpegts_mux = {
+AVOutputFormat mpegts_muxer = {
     &quot;mpegts&quot;,
     &quot;MPEG2 transport stream format&quot;,
     &quot;video/x-mpegts&quot;,

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/riff.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/riff.h	2007-01-20 15:15:58 UTC (rev 2746)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/riff.h	2007-01-21 18:04:24 UTC (rev 2747)
@@ -1,3 +1,30 @@
+/*
+ * RIFF codec tags
+ * copyright (c) 2000 Fabrice Bellard
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+/**
+ * @file riff.h
+ * internal header for RIFF based (de)muxers
+ * do NOT include this in end user applications
+ */
+
 #ifndef FF_RIFF_H
 #define FF_RIFF_H
 
@@ -4,27 +31,25 @@
 offset_t start_tag(ByteIOContext *pb, const char *tag);
 void end_tag(ByteIOContext *pb, offset_t start);
 
-typedef struct CodecTag {
+typedef struct AVCodecTag {
     int id;
     unsigned int tag;
-    unsigned int invalid_asf : 1;
-} CodecTag;
+} AVCodecTag;
 
-void put_bmp_header(ByteIOContext *pb, AVCodecContext *enc, const CodecTag *tags, int for_asf);
+void put_bmp_header(ByteIOContext *pb, AVCodecContext *enc, const AVCodecTag *tags, int for_asf);
 int put_wav_header(ByteIOContext *pb, AVCodecContext *enc);
 int wav_codec_get_id(unsigned int tag, int bps);
 void get_wav_header(ByteIOContext *pb, AVCodecContext *codec, int size);
 
-extern const CodecTag codec_bmp_tags[];
-extern const CodecTag codec_wav_tags[];
+extern const AVCodecTag codec_bmp_tags[];
+extern const AVCodecTag codec_wav_tags[];
 
-unsigned int codec_get_tag(const CodecTag *tags, int id);
-enum CodecID codec_get_id(const CodecTag *tags, unsigned int tag);
-unsigned int codec_get_bmp_tag(int id);
-unsigned int codec_get_wav_tag(int id);
-enum CodecID codec_get_bmp_id(unsigned int tag);
-enum CodecID codec_get_wav_id(unsigned int tag);
-unsigned int codec_get_asf_tag(const CodecTag *tags, unsigned int id);
+unsigned int codec_get_tag(const AVCodecTag *tags, int id);
+enum CodecID codec_get_id(const AVCodecTag *tags, unsigned int tag);
+unsigned int codec_get_bmp_tag(int id) attribute_deprecated; //use av_codec_get_tag
+unsigned int codec_get_wav_tag(int id) attribute_deprecated; //use av_codec_get_tag
+enum CodecID codec_get_bmp_id(unsigned int tag) attribute_deprecated; //use av_codec_get_id
+enum CodecID codec_get_wav_id(unsigned int tag) attribute_deprecated; //use av_codec_get_id
 void ff_parse_specific_params(AVCodecContext *stream, int *au_rate, int *au_ssize, int *au_scale);
 
 #endif

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/rtp.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/rtp.h	2007-01-20 15:15:58 UTC (rev 2746)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/rtp.h	2007-01-21 18:04:24 UTC (rev 2747)
@@ -2,39 +2,25 @@
  * RTP definitions
  * Copyright (c) 2002 Fabrice Bellard.
  *
- * This library is free software; you can redistribute it and/or
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
  * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
+ * version 2.1 of the License, or (at your option) any later version.
  *
- * This library is distributed in the hope that it will be useful,
+ * FFmpeg is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  * Lesser General Public License for more details.
  *
  * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 #ifndef RTP_H
 #define RTP_H
 
-enum RTPPayloadType {
-    RTP_PT_ULAW = 0,
-    RTP_PT_GSM = 3,
-    RTP_PT_G723 = 4,
-    RTP_PT_ALAW = 8,
-    RTP_PT_S16BE_STEREO = 10,
-    RTP_PT_S16BE_MONO = 11,
-    RTP_PT_MPEGAUDIO = 14,
-    RTP_PT_JPEG = 26,
-    RTP_PT_H261 = 31,
-    RTP_PT_MPEGVIDEO = 32,
-    RTP_PT_MPEG2TS = 33,
-    RTP_PT_H263 = 34, /* old H263 encapsulation */
-    RTP_PT_PRIVATE = 96,
-};
-
 #define RTP_MIN_PACKET_LENGTH 12
 #define RTP_MAX_PACKET_LENGTH 1500 /* XXX: suppress this define */
 
@@ -43,14 +29,14 @@
 int rtp_get_payload_type(AVCodecContext *codec);
 
 typedef struct RTPDemuxContext RTPDemuxContext;
-
-RTPDemuxContext *rtp_parse_open(AVFormatContext *s1, AVStream *st, int payload_type);
-int rtp_parse_packet(RTPDemuxContext *s, AVPacket *pkt, 
+typedef struct rtp_payload_data_s rtp_payload_data_s;
+RTPDemuxContext *rtp_parse_open(AVFormatContext *s1, AVStream *st, URLContext *rtpc, int payload_type, rtp_payload_data_s *rtp_payload_data);
+int rtp_parse_packet(RTPDemuxContext *s, AVPacket *pkt,
                      const uint8_t *buf, int len);
 void rtp_parse_close(RTPDemuxContext *s);
 
-extern AVOutputFormat rtp_mux;
-extern AVInputFormat rtp_demux;
+extern AVOutputFormat rtp_muxer;
+extern AVInputFormat rtp_demuxer;
 
 int rtp_get_local_port(URLContext *h);
 int rtp_set_remote_url(URLContext *h, const char *uri);
@@ -58,4 +44,75 @@
 
 extern URLProtocol rtp_protocol;
 
+#define RTP_PT_PRIVATE 96
+#define RTP_VERSION 2
+#define RTP_MAX_SDES 256   /* maximum text length for SDES */
+
+/* RTCP paquets use 0.5 % of the bandwidth */
+#define RTCP_TX_RATIO_NUM 5
+#define RTCP_TX_RATIO_DEN 1000
+
+/* Structure listing usefull vars to parse RTP packet payload*/
+typedef struct rtp_payload_data_s
+{
+    int sizelength;
+    int indexlength;
+    int indexdeltalength;
+    int profile_level_id;
+    int streamtype;
+    int objecttype;
+    char *mode;
+
+    /* mpeg 4 AU headers */
+    struct AUHeaders {
+        int size;
+        int index;
+        int cts_flag;
+        int cts;
+        int dts_flag;
+        int dts;
+        int rap_flag;
+        int streamstate;
+    } *au_headers;
+    int nb_au_headers;
+    int au_headers_length_bytes;
+    int cur_au_index;
+} rtp_payload_data_t;
+
+typedef struct AVRtpPayloadType_s
+{
+    int pt;
+    const char enc_name[50]; /* XXX: why 50 ? */
+    enum CodecType codec_type;
+    enum CodecID codec_id;
+    int clock_rate;
+    int audio_channels;
+} AVRtpPayloadType_t;
+
+#if 0
+typedef enum {
+  RTCP_SR   = 200,
+  RTCP_RR   = 201,
+  RTCP_SDES = 202,
+  RTCP_BYE  = 203,
+  RTCP_APP  = 204
+} rtcp_type_t;
+
+typedef enum {
+  RTCP_SDES_END    =  0,
+  RTCP_SDES_CNAME  =  1,
+  RTCP_SDES_NAME   =  2,
+  RTCP_SDES_EMAIL  =  3,
+  RTCP_SDES_PHONE  =  4,
+  RTCP_SDES_LOC    =  5,
+  RTCP_SDES_TOOL   =  6,
+  RTCP_SDES_NOTE   =  7,
+  RTCP_SDES_PRIV   =  8,
+  RTCP_SDES_IMG    =  9,
+  RTCP_SDES_DOOR   = 10,
+  RTCP_SDES_SOURCE = 11
+} rtcp_sdes_type_t;
+#endif
+
+extern AVRtpPayloadType_t AVRtpPayloadTypes[];
 #endif /* RTP_H */

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/rtsp.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/rtsp.h	2007-01-20 15:15:58 UTC (rev 2746)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/rtsp.h	2007-01-21 18:04:24 UTC (rev 2747)
@@ -2,19 +2,21 @@
  * RTSP definitions
  * Copyright (c) 2002 Fabrice Bellard.
  *
- * This library is free software; you can redistribute it and/or
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
  * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
+ * version 2.1 of the License, or (at your option) any later version.
  *
- * This library is distributed in the hope that it will be useful,
+ * FFmpeg is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  * Lesser General Public License for more details.
  *
  * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 #ifndef RTSP_H
 #define RTSP_H
@@ -35,6 +37,10 @@
 #define RTSP_DEFAULT_PORT   554
 #define RTSP_MAX_TRANSPORTS 8
 #define RTSP_TCP_MAX_PACKET_SIZE 1472
+#define RTSP_DEFAULT_NB_AUDIO_CHANNELS 2
+#define RTSP_DEFAULT_AUDIO_SAMPLERATE 44100
+#define RTSP_RTP_PORT_MIN 5000
+#define RTSP_RTP_PORT_MAX 10000
 
 typedef struct RTSPTransportField {
     int interleaved_min, interleaved_max;  /* interleave ids, if TCP transport */
@@ -51,7 +57,7 @@
     enum RTSPStatusCode status_code; /* response code from server */
     int nb_transports;
     /* in AV_TIME_BASE unit, AV_NOPTS_VALUE if not used */
-    int64_t range_start, range_end; 
+    int64_t range_start, range_end;
     RTSPTransportField transports[RTSP_MAX_TRANSPORTS];
     int seq; /* sequence number */
     char session_id[512];
@@ -70,7 +76,7 @@
     char transport_option[512];
 } RTSPActionServerSetup;
 
-typedef int FFRTSPCallback(enum RTSPCallbackAction action, 
+typedef int FFRTSPCallback(enum RTSPCallbackAction action,
                            const char *session_id,
                            char *buf, int buf_size,
                            void *arg);
@@ -84,7 +90,7 @@
 extern int rtsp_rtp_port_min;
 extern int rtsp_rtp_port_max;
 extern FFRTSPCallback *ff_rtsp_callback;
-extern AVInputFormat rtsp_demux;
+extern AVInputFormat rtsp_demuxer;
 
 int rtsp_pause(AVFormatContext *s);
 int rtsp_resume(AVFormatContext *s);

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/rtspcodes.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/rtspcodes.h	2007-01-20 15:15:58 UTC (rev 2746)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/rtspcodes.h	2007-01-21 18:04:24 UTC (rev 2747)
@@ -1,3 +1,23 @@
+/*
+ * RTSP definitions
+ * copyright (c) 2002 Fabrice Bellard
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
 DEF(200, RTSP_STATUS_OK, &quot;OK&quot;)
 DEF(405, RTSP_STATUS_METHOD, &quot;Method Not Allowed&quot;)
 DEF(453, RTSP_STATUS_BANDWIDTH, &quot;Not Enough Bandwidth&quot;)

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/utils.c
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/utils.c	2007-01-20 15:15:58 UTC (rev 2746)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/utils.c	2007-01-21 18:04:24 UTC (rev 2747)
@@ -2,21 +2,25 @@
  * Various utilities for ffmpeg system
  * Copyright (c) 2000, 2001, 2002 Fabrice Bellard
  *
- * This library is free software; you can redistribute it and/or
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
  * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
+ * version 2.1 of the License, or (at your option) any later version.
  *
- * This library is distributed in the hope that it will be useful,
+ * FFmpeg is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  * Lesser General Public License for more details.
  *
  * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
+ * License along with FFmpeg; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 #include &quot;avformat.h&quot;
+#include &quot;allformats.h&quot;
+#include &quot;opt.h&quot;
 
 #undef NDEBUG
 #include &lt;assert.h&gt;
@@ -26,12 +30,13 @@
  * Various utility functions for using ffmpeg library.
  */
 
+static void av_frac_init(AVFrac *f, int64_t val, int64_t num, int64_t den);
+static void av_frac_add(AVFrac *f, int64_t incr);
+
 /** head of registered input format linked list. */
 AVInputFormat *first_iformat = NULL;
 /** head of registered output format linked list. */
 AVOutputFormat *first_oformat = NULL;
-/** head of registered image format linked list. */
-AVImageFormat *first_image_format = NULL;
 
 void av_register_input_format(AVInputFormat *format)
 {
@@ -85,17 +90,13 @@
     int score_max, score;
 
     /* specific test for image sequences */
+#ifdef CONFIG_IMAGE2_MUXER
     if (!short_name &amp;&amp; filename &amp;&amp;
-        filename_number_test(filename) &gt;= 0 &amp;&amp;
+        av_filename_number_test(filename) &amp;&amp;
         av_guess_image2_codec(filename) != CODEC_ID_NONE) {
         return guess_format(&quot;image2&quot;, NULL, NULL);
     }
-    if (!short_name &amp;&amp; filename &amp;&amp;
-        filename_number_test(filename) &gt;= 0 &amp;&amp;
-        guess_image_format(filename)) {
-        return guess_format(&quot;image&quot;, NULL, NULL);
-    }
-
+#endif
     /* find the proper file type */
     fmt_found = NULL;
     score_max = 0;
@@ -146,9 +147,11 @@
     if(type == CODEC_TYPE_VIDEO){
         enum CodecID codec_id= CODEC_ID_NONE;
 
+#ifdef CONFIG_IMAGE2_MUXER
         if(!strcmp(fmt-&gt;name, &quot;image2&quot;) || !strcmp(fmt-&gt;name, &quot;image2pipe&quot;)){
             codec_id= av_guess_image2_codec(filename);
         }
+#endif
         if(codec_id == CODEC_ID_NONE)
             codec_id= fmt-&gt;video_codec;
         return codec_id;
@@ -191,7 +194,7 @@
  */
 int av_new_packet(AVPacket *pkt, int size)
 {
-    void *data;
+    uint8_t *data;
     if((unsigned)size &gt; (unsigned)size + FF_INPUT_BUFFER_PADDING_SIZE)
         return AVERROR_NOMEM;
     data = av_malloc(size + FF_INPUT_BUFFER_PADDING_SIZE);
@@ -253,156 +256,23 @@
     return 0;
 }
 
-/* fifo handling */
-
-int fifo_init(FifoBuffer *f, int size)
-{
-    f-&gt;buffer = av_malloc(size);
-    if (!f-&gt;buffer)
-        return -1;
-    f-&gt;end = f-&gt;buffer + size;
-    f-&gt;wptr = f-&gt;rptr = f-&gt;buffer;
-    return 0;
-}
-
-void fifo_free(FifoBuffer *f)
-{
-    av_free(f-&gt;buffer);
-}
-
-int fifo_size(FifoBuffer *f, uint8_t *rptr)
-{
-    int size;
-
-    if(!rptr)
-        rptr= f-&gt;rptr;
-
-    if (f-&gt;wptr &gt;= rptr) {
-        size = f-&gt;wptr - rptr;
-    } else {
-        size = (f-&gt;end - rptr) + (f-&gt;wptr - f-&gt;buffer);
-    }
-    return size;
-}
-
 /**
- * Get data from the fifo (returns -1 if not enough data).
+ * Allocate the payload of a packet and intialized its fields to default values.
+ *
+ * @param filename possible numbered sequence string
+ * @return 1 if a valid numbered sequence string, 0 otherwise.
  */
-int fifo_read(FifoBuffer *f, uint8_t *buf, int buf_size, uint8_t **rptr_ptr)
+int av_filename_number_test(const char *filename)
 {
-    uint8_t *rptr;
-    int size, len;
-
-    if(!rptr_ptr)
-        rptr_ptr= &amp;f-&gt;rptr;
-    rptr = *rptr_ptr;
-
-    if (f-&gt;wptr &gt;= rptr) {
-        size = f-&gt;wptr - rptr;
-    } else {
-        size = (f-&gt;end - rptr) + (f-&gt;wptr - f-&gt;buffer);
-    }
-
-    if (size &lt; buf_size)
-        return -1;
-    while (buf_size &gt; 0) {
-        len = f-&gt;end - rptr;
-        if (len &gt; buf_size)
-            len = buf_size;
-        memcpy(buf, rptr, len);
-        buf += len;
-        rptr += len;
-        if (rptr &gt;= f-&gt;end)
-            rptr = f-&gt;buffer;
-        buf_size -= len;
-    }
-    *rptr_ptr = rptr;
-    return 0;
-}
-
-/**
- * Resizes a FIFO.
- */
-void fifo_realloc(FifoBuffer *f, unsigned int new_size){
-    unsigned int old_size= f-&gt;end - f-&gt;buffer;
-
-    if(old_size &lt; new_size){
-        uint8_t *old= f-&gt;buffer;
-
-        f-&gt;buffer= av_realloc(f-&gt;buffer, new_size);
-
-        f-&gt;rptr += f-&gt;buffer - old;
-        f-&gt;wptr += f-&gt;buffer - old;
-
-        if(f-&gt;wptr &lt; f-&gt;rptr){
-            memmove(f-&gt;rptr + new_size - old_size, f-&gt;rptr, f-&gt;buffer + old_size - f-&gt;rptr);
-            f-&gt;rptr += new_size - old_size;
-        }
-        f-&gt;end= f-&gt;buffer + new_size;
-    }
-}
-
-void fifo_write(FifoBuffer *f, uint8_t *buf, int size, uint8_t **wptr_ptr)
-{
-    int len;
-    uint8_t *wptr;
-
-    if(!wptr_ptr)
-        wptr_ptr= &amp;f-&gt;wptr;
-    wptr = *wptr_ptr;
-
-    while (size &gt; 0) {
-        len = f-&gt;end - wptr;
-        if (len &gt; size)
-            len = size;
-        memcpy(wptr, buf, len);
-        wptr += len;
-        if (wptr &gt;= f-&gt;end)
-            wptr = f-&gt;buffer;
-        buf += len;
-        size -= len;
-    }
-    *wptr_ptr = wptr;
-}
-
-/* get data from the fifo (return -1 if not enough data) */
-int put_fifo(ByteIOContext *pb, FifoBuffer *f, int buf_size, uint8_t **rptr_ptr)
-{
-    uint8_t *rptr = *rptr_ptr;
-    int size, len;
-
-    if (f-&gt;wptr &gt;= rptr) {
-        size = f-&gt;wptr - rptr;
-    } else {
-        size = (f-&gt;end - rptr) + (f-&gt;wptr - f-&gt;buffer);
-    }
-
-    if (size &lt; buf_size)
-        return -1;
-    while (buf_size &gt; 0) {
-        len = f-&gt;end - rptr;
-        if (len &gt; buf_size)
-            len = buf_size;
-        put_buffer(pb, rptr, len);
-        rptr += len;
-        if (rptr &gt;= f-&gt;end)
-            rptr = f-&gt;buffer;
-        buf_size -= len;
-    }
-    *rptr_ptr = rptr;
-    return 0;
-}
-
-int filename_number_test(const char *filename)
-{
     char buf[1024];
-    if(!filename)
-        return -1;
-    return get_frame_filename(buf, sizeof(buf), filename, 1);
+    return filename &amp;&amp; (av_get_frame_filename(buf, sizeof(buf), filename, 1)&gt;=0);
 }
 
 /**
  * Guess file format.
+ *
+ * @param is_opened whether the file is already opened, determines whether
+ *                  demuxers with or without AVFMT_NOFILE are probed
  */
 AVInputFormat *av_probe_input_format(AVProbeData *pd, int is_opened)
 {
@@ -412,7 +282,7 @@
     fmt = NULL;
     score_max = 0;
     for(fmt1 = first_iformat; fmt1 != NULL; fmt1 = fmt1-&gt;next) {
-        if (!is_opened &amp;&amp; !(fmt1-&gt;flags &amp; AVFMT_NOFILE))
+        if (!is_opened == !(fmt1-&gt;flags &amp; AVFMT_NOFILE))
             continue;
         score = 0;
         if (fmt1-&gt;read_probe) {
@@ -444,13 +314,45 @@
     else return &quot;NULL&quot;;
 }
 
-static const AVClass av_format_context_class = { &quot;AVFormatContext&quot;, format_to_name };
+#define OFFSET(x) offsetof(AVFormatContext,x)
+#define DEFAULT 0 //should be NAN but it doesnt work as its not a constant in glibc as required by ANSI/ISO C
+//these names are too long to be readable
+#define E AV_OPT_FLAG_ENCODING_PARAM
+#define D AV_OPT_FLAG_DECODING_PARAM
 
+static const AVOption options[]={
+{&quot;probesize&quot;, NULL, OFFSET(probesize), FF_OPT_TYPE_INT, 32000, 32, INT_MAX, D}, /* 32000 from mpegts.c: 1.0 second at 24Mbit/s */
+{&quot;muxrate&quot;, &quot;set mux rate&quot;, OFFSET(mux_rate), FF_OPT_TYPE_INT, DEFAULT, 0, INT_MAX, E},
+{&quot;packetsize&quot;, &quot;set packet size&quot;, OFFSET(packet_size), FF_OPT_TYPE_INT, DEFAULT, 0, INT_MAX, E},
+{&quot;fflags&quot;, NULL, OFFSET(flags), FF_OPT_TYPE_FLAGS, DEFAULT, INT_MIN, INT_MAX, D|E, &quot;fflags&quot;},
+{&quot;ignidx&quot;, &quot;ignore index&quot;, 0, FF_OPT_TYPE_CONST, AVFMT_FLAG_IGNIDX, INT_MIN, INT_MAX, D, &quot;fflags&quot;},
+{&quot;genpts&quot;, &quot;generate pts&quot;, 0, FF_OPT_TYPE_CONST, AVFMT_FLAG_GENPTS, INT_MIN, INT_MAX, D, &quot;fflags&quot;},
+{&quot;track&quot;, &quot; set the track number&quot;, OFFSET(track), FF_OPT_TYPE_INT, DEFAULT, 0, INT_MAX, E},
+{&quot;year&quot;, &quot;set the year&quot;, OFFSET(year), FF_OPT_TYPE_INT, DEFAULT, INT_MIN, INT_MAX, E},
+{NULL},
+};
+
+#undef E
+#undef D
+#undef DEFAULT
+
+static const AVClass av_format_context_class = { &quot;AVFormatContext&quot;, format_to_name, options };
+
+static void avformat_get_context_defaults(AVFormatContext *s)
+{
+    memset(s, 0, sizeof(AVFormatContext));
+
+    s-&gt;av_class = &amp;av_format_context_class;
+
+    av_opt_set_defaults(s);
+}
+
 AVFormatContext *av_alloc_format_context(void)
 {
     AVFormatContext *ic;
-    ic = av_mallocz(sizeof(AVFormatContext));
+    ic = av_malloc(sizeof(AVFormatContext));
     if (!ic) return ic;
+    avformat_get_context_defaults(ic);
     ic-&gt;av_class = &amp;av_format_context_class;
     return ic;
 }
@@ -472,7 +374,10 @@
         memset(ap, 0, sizeof(default_ap));
     }
 
-    ic = av_alloc_format_context();
+    if(!ap-&gt;prealloced_context)
+        ic = av_alloc_format_context();
+    else
+        ic = *ic_ptr;
     if (!ic) {
         err = AVERROR_NOMEM;
         goto fail;
@@ -499,7 +404,7 @@
     if (err &lt; 0)
         goto fail;
 
-    if (pb)
+    if (pb &amp;&amp; !ic-&gt;data_offset)
         ic-&gt;data_offset = url_ftell(&amp;ic-&gt;pb);
 
     *ic_ptr = ic;
@@ -515,7 +420,7 @@
 
 /** Size of probe buffer, for guessing file type from file contents. */
 #define PROBE_BUF_MIN 2048
-#define PROBE_BUF_MAX 131072
+#define PROBE_BUF_MAX (1&lt;&lt;20)
 
 /**
  * Open a media file as input. The codec are not opened. Only the file
@@ -594,7 +499,7 @@
 
     /* XXX: suppress this hack for redirectors */
 #ifdef CONFIG_NETWORK
-    if (fmt == &amp;redir_demux) {
+    if (fmt == &amp;redir_demuxer) {
         err = redir_open(ic_ptr, pb);
         url_fclose(pb);
         return err;
@@ -603,7 +508,7 @@
 
     /* check filename in case of an image number is expected */
     if (fmt-&gt;flags &amp; AVFMT_NEEDNUMBER) {
-        if (filename_number_test(filename) &lt; 0) {
+        if (!av_filename_number_test(filename)) {
             err = AVERROR_NUMEXPECTED;
             goto fail;
         }
@@ -648,50 +553,17 @@
     int frame_size;
 
     if (enc-&gt;frame_size &lt;= 1) {
-        /* specific hack for pcm codecs because no frame size is
-           provided */
-        switch(enc-&gt;codec_id) {
-#if 0 //MEANX		
-        case CODEC_ID_PCM_S32LE:
-        case CODEC_ID_PCM_S32BE:
-        case CODEC_ID_PCM_U32LE:
-        case CODEC_ID_PCM_U32BE:
+        int bits_per_sample = av_get_bits_per_sample(enc-&gt;codec_id);
+
+        if (bits_per_sample) {
             if (enc-&gt;channels == 0)
                 return -1;
-            frame_size = size / (4 * enc-&gt;channels);
-            break;
-        case CODEC_ID_PCM_S24LE:
-        case CODEC_ID_PCM_S24BE:
-        case CODEC_ID_PCM_U24LE:
-        case CODEC_ID_PCM_U24BE:
-        case CODEC_ID_PCM_S24DAUD:
-            if (enc-&gt;channels == 0)
-                return -1;
-            frame_size = size / (3 * enc-&gt;channels);
-            break;
-#endif //MEANX	    
-        case CODEC_ID_PCM_S16LE:
-        case CODEC_ID_PCM_S16BE:
-        case CODEC_ID_PCM_U16LE:
-        case CODEC_ID_PCM_U16BE:
-            if (enc-&gt;channels == 0)
-                return -1;
-            frame_size = size / (2 * enc-&gt;channels);
-            break;
-        case CODEC_ID_PCM_S8:
-        case CODEC_ID_PCM_U8:
-        case CODEC_ID_PCM_MULAW:
-        case CODEC_ID_PCM_ALAW:
-            if (enc-&gt;channels == 0)
-                return -1;
-            frame_size = size / (enc-&gt;channels);
-            break;
-        default:
+            frame_size = (size &lt;&lt; 3) / (bits_per_sample * enc-&gt;channels);
+        } else {
             /* used for example by ADPCM codecs */
             if (enc-&gt;bit_rate == 0)
                 return -1;
             frame_size = (size * 8 * enc-&gt;sample_rate) / enc-&gt;bit_rate;
-            break;
         }
     } else {
         frame_size = enc-&gt;frame_size;
@@ -805,7 +677,7 @@
         else                     st-&gt;cur_dts = 0;
     }
 
-//    av_log(NULL, AV_LOG_DEBUG, &quot;IN delayed:%d pts:%lld, dts:%lld cur_dts:%lld st:%d pc:%p\n&quot;, presentation_delayed, pkt-&gt;pts, pkt-&gt;dts, st-&gt;cur_dts, pkt-&gt;stream_index, pc);
+//    av_log(NULL, AV_LOG_DEBUG, &quot;IN delayed:%d pts:%&quot;PRId64&quot;, dts:%&quot;PRId64&quot; cur_dts:%&quot;PRId64&quot; st:%d pc:%p\n&quot;, presentation_delayed, pkt-&gt;pts, pkt-&gt;dts, st-&gt;cur_dts, pkt-&gt;stream_index, pc);
     /* interpolate PTS and DTS if they are not present */
     if (presentation_delayed) {
         /* DTS = decompression time stamp */
@@ -831,11 +703,11 @@
            by knowing the futur */
     } else if(pkt-&gt;pts != AV_NOPTS_VALUE || pkt-&gt;dts != AV_NOPTS_VALUE || pkt-&gt;duration){
         if(pkt-&gt;pts != AV_NOPTS_VALUE &amp;&amp; pkt-&gt;duration){
-            int64_t old_diff= ABS(st-&gt;cur_dts - pkt-&gt;duration - pkt-&gt;pts);
-            int64_t new_diff= ABS(st-&gt;cur_dts - pkt-&gt;pts);
+            int64_t old_diff= FFABS(st-&gt;cur_dts - pkt-&gt;duration - pkt-&gt;pts);
+            int64_t new_diff= FFABS(st-&gt;cur_dts - pkt-&gt;pts);
             if(old_diff &lt; new_diff &amp;&amp; old_diff &lt; (pkt-&gt;duration&gt;&gt;3)){
                 pkt-&gt;pts += pkt-&gt;duration;
-//                av_log(NULL, AV_LOG_DEBUG, &quot;id:%d old:%Ld new:%Ld dur:%d cur:%Ld size:%d\n&quot;, pkt-&gt;stream_index, old_diff, new_diff, pkt-&gt;duration, st-&gt;cur_dts, pkt-&gt;size);
+//                av_log(NULL, AV_LOG_DEBUG, &quot;id:%d old:%&quot;PRId64&quot; new:%&quot;PRId64&quot; dur:%d cur:%&quot;PRId64&quot; size:%d\n&quot;, pkt-&gt;stream_index, old_diff, new_diff, pkt-&gt;duration, st-&gt;cur_dts, pkt-&gt;size);
             }
         }
 
@@ -855,7 +727,7 @@
         }
         st-&gt;cur_dts += pkt-&gt;duration;
     }
-//    av_log(NULL, AV_LOG_DEBUG, &quot;OUTdelayed:%d pts:%lld, dts:%lld cur_dts:%lld\n&quot;, presentation_delayed, pkt-&gt;pts, pkt-&gt;dts, st-&gt;cur_dts);
+//    av_log(NULL, AV_LOG_DEBUG, &quot;OUTdelayed:%d pts:%&quot;PRId64&quot;, dts:%&quot;PRId64&quot; cur_dts:%&quot;PRId64&quot;\n&quot;, presentation_delayed, pkt-&gt;pts, pkt-&gt;dts, st-&gt;cur_dts);
 
     /* update flags */
     if (pc) {
@@ -895,7 +767,7 @@
                 *pkt = s-&gt;cur_pkt;
                 compute_pkt_fields(s, st, NULL, pkt);
                 s-&gt;cur_st = NULL;
-                return 0;
+                break;
             } else if (s-&gt;cur_len &gt; 0 &amp;&amp; st-&gt;discard &lt; AVDISCARD_ALL) {
                 len = av_parser_parse(st-&gt;parser, st-&gt;codec, &amp;pkt-&gt;data, &amp;pkt-&gt;size,
                                       s-&gt;cur_ptr, s-&gt;cur_len,
@@ -915,7 +787,7 @@
                     pkt-&gt;dts = st-&gt;parser-&gt;dts;
                     pkt-&gt;destruct = av_destruct_packet_nofree;
                     compute_pkt_fields(s, st, st-&gt;parser, pkt);
-                    return 0;
+                    break;
                 }
             } else {
                 /* free packet */
@@ -945,6 +817,12 @@
             }
 
             st = s-&gt;streams[s-&gt;cur_pkt.stream_index];
+            if(st-&gt;codec-&gt;debug &amp; FF_DEBUG_PTS)
+                av_log(s, AV_LOG_DEBUG, &quot;av_read_packet stream=%d, pts=%&quot;PRId64&quot;, dts=%&quot;PRId64&quot;, size=%d\n&quot;,
+                    s-&gt;cur_pkt.stream_index,
+                    s-&gt;cur_pkt.pts,
+                    s-&gt;cur_pkt.dts,
+                    s-&gt;cur_pkt.size);
 
             s-&gt;cur_st = st;
             s-&gt;cur_ptr = s-&gt;cur_pkt.data;
@@ -960,6 +838,14 @@
             }
         }
     }
+    if(st-&gt;codec-&gt;debug &amp; FF_DEBUG_PTS)
+        av_log(s, AV_LOG_DEBUG, &quot;av_read_frame_internal stream=%d, pts=%&quot;PRId64&quot;, dts=%&quot;PRId64&quot;, size=%d\n&quot;,
+            pkt-&gt;stream_index,
+            pkt-&gt;pts,
+            pkt-&gt;dts,
+            pkt-&gt;size);
+
+    return 0;
 }
 
 /**
@@ -1121,7 +1007,7 @@
  * @param timestamp new dts expressed in time_base of param ref_st
  * @param ref_st reference stream giving time_base of param timestamp
  */
-static void av_update_cur_dts(AVFormatContext *s, AVStream *ref_st, int64_t timestamp){
+void av_update_cur_dts(AVFormatContext *s, AVStream *ref_st, int64_t timestamp){
     int i;
 
     for(i = 0; i &lt; s-&gt;nb_streams; i++) {
@@ -1277,8 +1163,7 @@
     AVInputFormat *avif= s-&gt;iformat;
     int64_t pos_min, pos_max, pos, pos_limit;
     int64_t ts_min, ts_max, ts;
-    int64_t start_pos, filesize;
-    int index, no_change;
+    int index;
     AVStream *st;
 
     if (stream_index &lt; 0)
@@ -1326,9 +1211,36 @@
         }
     }
 
+    pos= av_gen_search(s, stream_index, target_ts, pos_min, pos_max, pos_limit, ts_min, ts_max, flags, &amp;ts, avif-&gt;read_timestamp);
+    if(pos&lt;0)
+        return -1;
+
+    /* do the seek */
+    url_fseek(&amp;s-&gt;pb, pos, SEEK_SET);
+
+    av_update_cur_dts(s, st, ts);
+
+    return 0;
+}
+
+/**
+ * Does a binary search using read_timestamp().
+ * this isnt supposed to be called directly by a user application, but by demuxers
+ * @param target_ts target timestamp in the time base of the given stream
+ * @param stream_index stream number
+ */
+int64_t av_gen_search(AVFormatContext *s, int stream_index, int64_t target_ts, int64_t pos_min, int64_t pos_max, int64_t pos_limit, int64_t ts_min, int64_t ts_max, int flags, int64_t *ts_ret, int64_t (*read_timestamp)(struct AVFormatContext *, int , int64_t *, int64_t )){
+    int64_t pos, ts;
+    int64_t start_pos, filesize;
+    int no_change;
+
+#ifdef DEBUG_SEEK
+    av_log(s, AV_LOG_DEBUG, &quot;gen_seek: %d %&quot;PRId64&quot;\n&quot;, stream_index, target_ts);
+#endif
+
     if(ts_min == AV_NOPTS_VALUE){
         pos_min = s-&gt;data_offset;
-        ts_min = avif-&gt;read_timestamp(s, stream_index, &amp;pos_min, INT64_MAX);
+        ts_min = read_timestamp(s, stream_index, &amp;pos_min, INT64_MAX);
         if (ts_min == AV_NOPTS_VALUE)
             return -1;
     }
@@ -1339,7 +1251,7 @@
         pos_max = filesize - 1;
         do{
             pos_max -= step;
-            ts_max = avif-&gt;read_timestamp(s, stream_index, &amp;pos_max, pos_max + step);
+            ts_max = read_timestamp(s, stream_index, &amp;pos_max, pos_max + step);
             step += step;
         }while(ts_max == AV_NOPTS_VALUE &amp;&amp; pos_max &gt;= step);
         if (ts_max == AV_NOPTS_VALUE)
@@ -1347,7 +1259,7 @@
 
         for(;;){
             int64_t tmp_pos= pos_max + 1;
-            int64_t tmp_ts= avif-&gt;read_timestamp(s, stream_index, &amp;tmp_pos, INT64_MAX);
+            int64_t tmp_ts= read_timestamp(s, stream_index, &amp;tmp_pos, INT64_MAX);
             if(tmp_ts == AV_NOPTS_VALUE)
                 break;
             ts_max= tmp_ts;
@@ -1391,7 +1303,7 @@
             pos= pos_limit;
         start_pos= pos;
 
-        ts = avif-&gt;read_timestamp(s, stream_index, &amp;pos, INT64_MAX); //may pass pos_limit instead of -1
+        ts = read_timestamp(s, stream_index, &amp;pos, INT64_MAX); //may pass pos_limit instead of -1
         if(pos == pos_max)
             no_change++;
         else
@@ -1415,18 +1327,14 @@
     ts  = (flags &amp; AVSEEK_FLAG_BACKWARD) ?  ts_min :  ts_max;
 #ifdef DEBUG_SEEK
     pos_min = pos;
-    ts_min = avif-&gt;read_timestamp(s, stream_index, &amp;pos_min, INT64_MAX);
+    ts_min = read_timestamp(s, stream_index, &amp;pos_min, INT64_MAX);
     pos_min++;
-    ts_max = avif-&gt;read_timestamp(s, stream_index, &amp;pos_min, INT64_MAX);
+    ts_max = read_timestamp(s, stream_index, &amp;pos_min, INT64_MAX);
     av_log(s, AV_LOG_DEBUG, &quot;pos=0x%&quot;PRIx64&quot; %&quot;PRId64&quot;&lt;=%&quot;PRId64&quot;&lt;=%&quot;PRId64&quot;\n&quot;,
            pos, ts_min, target_ts, ts_max);
 #endif
-    /* do the seek */
-    url_fseek(&amp;s-&gt;pb, pos, SEEK_SET);
-
-    av_update_cur_dts(s, st, ts);
-
-    return 0;
+    *ts_ret= ts;
+    return pos;
 }
 
 static int av_seek_frame_byte(AVFormatContext *s, int stream_index, int64_t pos, int flags){
@@ -1564,8 +1472,8 @@
     int i;
     AVStream *st;
 
-    start_time = MAXINT64;
-    end_time = MININT64;
+    start_time = INT64_MAX;
+    end_time = INT64_MIN;
     for(i = 0;i &lt; ic-&gt;nb_streams; i++) {
         st = ic-&gt;streams[i];
         if (st-&gt;start_time != AV_NOPTS_VALUE) {
@@ -1580,9 +1488,9 @@
             }
         }
     }
-    if (start_time != MAXINT64) {
+    if (start_time != INT64_MAX) {
         ic-&gt;start_time = start_time;
-        if (end_time != MININT64) {
+        if (end_time != INT64_MIN) {
             ic-&gt;duration = end_time - start_time;
             if (ic-&gt;file_size &gt; 0) {
                 /* compute the bit rate */
@@ -1758,8 +1666,9 @@
     }
     ic-&gt;file_size = file_size;
 
-    //MEANX if ((ic-&gt;iformat == &amp;mpegps_demux || ic-&gt;iformat == &amp;mpegts_demux) &amp;&amp; file_size &amp;&amp; !ic-&gt;pb.is_streamed) {
-    if ((ic-&gt;iformat == &amp;mpegps_demux ) &amp;&amp; file_size &amp;&amp; !ic-&gt;pb.is_streamed) {
+    if ((!strcmp(ic-&gt;iformat-&gt;name, &quot;mpeg&quot;) ||
+         !strcmp(ic-&gt;iformat-&gt;name, &quot;mpegts&quot;)) &amp;&amp;
+        file_size &amp;&amp; !ic-&gt;pb.is_streamed) {
         /* get accurate estimate from the PTSes */
         av_estimate_timings_from_pts(ic);
     } else if (av_has_timings(ic)) {
@@ -1849,8 +1758,14 @@
 #define MAX_READ_SIZE        5000000
 
 /* maximum duration until we stop analysing the stream */
-#define MAX_STREAM_DURATION  ((int)(AV_TIME_BASE * 2.0))
+#define MAX_STREAM_DURATION  ((int)(AV_TIME_BASE * 3.0))
 
+#define MAX_STD_TIMEBASES (60*12+5)
+static int get_std_framerate(int i){
+    if(i&lt;60*12) return i*1001;
+    else        return ((int[]){24,30,60,12,15})[i-60*12]*1000*12;
+}
+
 /**
  * Read the beginning of a media file to get stream information. This
  * is useful for file formats with no headers such as MPEG. This
@@ -1868,8 +1783,8 @@
     AVPacket pkt1, *pkt;
     AVPacketList *pktl=NULL, **ppktl;
     int64_t last_dts[MAX_STREAMS];
-    int64_t duration_sum[MAX_STREAMS];
     int duration_count[MAX_STREAMS]={0};
+    double duration_error[MAX_STREAMS][MAX_STD_TIMEBASES]={{0}}; //FIXME malloc()?
 
     for(i=0;i&lt;ic-&gt;nb_streams;i++) {
         st = ic-&gt;streams[i];
@@ -1890,7 +1805,6 @@
 
     for(i=0;i&lt;MAX_STREAMS;i++){
         last_dts[i]= AV_NOPTS_VALUE;
-        duration_sum[i]= INT64_MAX;
     }
 
     count = 0;
@@ -1918,13 +1832,12 @@
                 ret = count;
                 break;
             }
-        } else {
-            /* we did not get all the codec info, but we read too much data */
-            if (read_size &gt;= MAX_READ_SIZE) {
-                ret = count;
-                break;
-            }
         }
+        /* we did not get all the codec info, but we read too much data */
+        if (read_size &gt;= MAX_READ_SIZE) {
+            ret = count;
+            break;
+        }
 
         /* NOTE: a new stream can be added there if no header in file
            (AVFMTCTX_NOHEADER) */
@@ -1938,11 +1851,10 @@
                     char buf[256];
                     avcodec_string(buf, sizeof(buf), st-&gt;codec, 0);
                     av_log(ic, AV_LOG_INFO, &quot;Could not find codec parameters (%s)\n&quot;, buf);
-                    break;
+                } else {
+                    ret = 0;
                 }
             }
-            if (i == ic-&gt;nb_streams)
-                ret = 0;
             break;
         }
 
@@ -1961,14 +1873,15 @@
 
         /* duplicate the packet */
         if (av_dup_packet(pkt) &lt; 0) {
-                ret = AVERROR_NOMEM;
-                break;
+            ret = AVERROR_NOMEM;
+            break;
         }
 
         read_size += pkt-&gt;size;
 
         st = ic-&gt;streams[pkt-&gt;stream_index];
-        st-&gt;codec_info_duration += pkt-&gt;duration;
+        if(st-&gt;codec_info_nb_frames&gt;1) //FIXME move codec_info_nb_frames and codec_info_duration from AVStream into this func
+            st-&gt;codec_info_duration += pkt-&gt;duration;
         if (pkt-&gt;duration != 0)
             st-&gt;codec_info_nb_frames++;
 
@@ -1978,25 +1891,33 @@
             int64_t duration= pkt-&gt;dts - last;
 
             if(pkt-&gt;dts != AV_NOPTS_VALUE &amp;&amp; last != AV_NOPTS_VALUE &amp;&amp; duration&gt;0){
-                if(duration*duration_count[index]*10/9 &lt; duration_sum[index]){
-                    duration_sum[index]= duration;
-                    duration_count[index]=1;
-                }else{
-                    int factor= av_rescale(duration, duration_count[index], duration_sum[index]);
-                    duration_sum[index] += duration;
-                    duration_count[index]+= factor;
+                double dur= duration * av_q2d(st-&gt;time_base);
+
+//                if(st-&gt;codec-&gt;codec_type == CODEC_TYPE_VIDEO)
+//                    av_log(NULL, AV_LOG_ERROR, &quot;%f\n&quot;, dur);
+                if(duration_count[index] &lt; 2)
+                    memset(duration_error, 0, sizeof(duration_error));
+                for(i=1; i&lt;MAX_STD_TIMEBASES; i++){
+                    int framerate= get_std_framerate(i);
+                    int ticks= lrintf(dur*framerate/(1001*12));
+                    double error= dur - ticks*1001*12/(double)framerate;
+                    duration_error[index][i] += error*error;
                 }
+                duration_count[index]++;
+
                 if(st-&gt;codec_info_nb_frames == 0 &amp;&amp; 0)
                     st-&gt;codec_info_duration += duration;
             }
-            last_dts[pkt-&gt;stream_index]= pkt-&gt;dts;
+            if(last == AV_NOPTS_VALUE || duration_count[index]&lt;=1)
+                last_dts[pkt-&gt;stream_index]= pkt-&gt;dts;
         }
         if(st-&gt;parser &amp;&amp; st-&gt;parser-&gt;parser-&gt;split &amp;&amp; !st-&gt;codec-&gt;extradata){
             int i= st-&gt;parser-&gt;parser-&gt;split(st-&gt;codec, pkt-&gt;data, pkt-&gt;size);
             if(i){
                 st-&gt;codec-&gt;extradata_size= i;
-                st-&gt;codec-&gt;extradata= av_malloc(st-&gt;codec-&gt;extradata_size);
+                st-&gt;codec-&gt;extradata= av_malloc(st-&gt;codec-&gt;extradata_size + FF_INPUT_BUFFER_PADDING_SIZE);
                 memcpy(st-&gt;codec-&gt;extradata, pkt-&gt;data, st-&gt;codec-&gt;extradata_size);
+                memset(st-&gt;codec-&gt;extradata + i, 0, FF_INPUT_BUFFER_PADDING_SIZE);
             }
         }
 
@@ -2039,58 +1960,34 @@
             if(st-&gt;codec-&gt;codec_id == CODEC_ID_RAWVIDEO &amp;&amp; !st-&gt;codec-&gt;codec_tag &amp;&amp; !st-&gt;codec-&gt;bits_per_sample)
                 st-&gt;codec-&gt;codec_tag= avcodec_pix_fmt_to_codec_tag(st-&gt;codec-&gt;pix_fmt);
 
-            if(duration_count[i] &amp;&amp; st-&gt;codec-&gt;time_base.num*101LL &lt;= st-&gt;codec-&gt;time_base.den &amp;&amp;
-               st-&gt;time_base.num*duration_sum[i]/duration_count[i]*101LL &gt; st-&gt;time_base.den){
-                int64_t num, den, error, best_error;
+            if(duration_count[i]
+               &amp;&amp; (st-&gt;codec-&gt;time_base.num*101LL &lt;= st-&gt;codec-&gt;time_base.den || st-&gt;codec-&gt;codec_id == CODEC_ID_MPEG2VIDEO) /*&amp;&amp;
+               //FIXME we should not special case mpeg2, but this needs testing with non mpeg2 ...
+               st-&gt;time_base.num*duration_sum[i]/duration_count[i]*101LL &gt; st-&gt;time_base.den*/){
+                double best_error= 2*av_q2d(st-&gt;time_base);
+                best_error= best_error*best_error*duration_count[i]*1000*12*30;
 
-                num= st-&gt;time_base.den*duration_count[i];
-                den= st-&gt;time_base.num*duration_sum[i];
-
-                best_error= INT64_MAX;
-                for(j=1; j&lt;60*12; j++){
-                    error= ABS(1001*12*num - 1001*j*den);
+                for(j=1; j&lt;MAX_STD_TIMEBASES; j++){
+                    double error= duration_error[i][j] * get_std_framerate(j);
+//                    if(st-&gt;codec-&gt;codec_type == CODEC_TYPE_VIDEO)
+//                        av_log(NULL, AV_LOG_ERROR, &quot;%f %f\n&quot;, get_std_framerate(j) / 12.0/1001, error);
                     if(error &lt; best_error){
                         best_error= error;
-                        av_reduce(&amp;st-&gt;r_frame_rate.num, &amp;st-&gt;r_frame_rate.den, j, 12, INT_MAX);
+                        av_reduce(&amp;st-&gt;r_frame_rate.num, &amp;st-&gt;r_frame_rate.den, get_std_framerate(j), 12*1001, INT_MAX);
                     }
                 }
-                for(j=24; j&lt;=30; j+=6){
-                    error= ABS(1001*12*num - 1000*12*j*den);
-                    if(error &lt; best_error){
-                        best_error= error;
-                        av_reduce(&amp;st-&gt;r_frame_rate.num, &amp;st-&gt;r_frame_rate.den, j*1000, 1001, INT_MAX);
-                    }
-                }
             }
 
-            /* set real frame rate info */
-            /* compute the real frame rate for telecine */
-            if ((st-&gt;codec-&gt;codec_id == CODEC_ID_MPEG1VIDEO ||
-                 st-&gt;codec-&gt;codec_id == CODEC_ID_MPEG2VIDEO) &amp;&amp;
-                st-&gt;codec-&gt;sub_id == 2) {
-                if (st-&gt;codec_info_nb_frames &gt;= 20) {
-                    float coded_frame_rate, est_frame_rate;
-                    est_frame_rate = ((double)st-&gt;codec_info_nb_frames * AV_TIME_BASE) /
-                        (double)st-&gt;codec_info_duration ;
-                    coded_frame_rate = 1.0/av_q2d(st-&gt;codec-&gt;time_base);
-#if 0
-                    printf(&quot;telecine: coded_frame_rate=%0.3f est_frame_rate=%0.3f\n&quot;,
-                           coded_frame_rate, est_frame_rate);
-#endif
-                    /* if we detect that it could be a telecine, we
-                       signal it. It would be better to do it at a
-                       higher level as it can change in a film */
-                    if (coded_frame_rate &gt;= 24.97 &amp;&amp;
-                        (est_frame_rate &gt;= 23.5 &amp;&amp; est_frame_rate &lt; 24.5)) {
-                        st-&gt;r_frame_rate = (AVRational){24000, 1001};
-                    }
+            if (!st-&gt;r_frame_rate.num){
+                if(    st-&gt;codec-&gt;time_base.den * (int64_t)st-&gt;time_base.num
+                    &lt;= st-&gt;codec-&gt;time_base.num * (int64_t)st-&gt;time_base.den){
+                    st-&gt;r_frame_rate.num = st-&gt;codec-&gt;time_base.den;
+                    st-&gt;r_frame_rate.den = st-&gt;codec-&gt;time_base.num;
+                }else{
+                    st-&gt;r_frame_rate.num = st-&gt;time_base.den;
+                    st-&gt;r_frame_rate.den = st-&gt;time_base.num;
                 }
             }
-            /* if no real frame rate, use the codec one */
-            if (!st-&gt;r_frame_rate.num){
-                st-&gt;r_frame_rate.num = st-&gt;codec-&gt;time_base.den;
-                st-&gt;r_frame_rate.den = st-&gt;codec-&gt;time_base.num;
-            }
         }
     }
 
@@ -2170,6 +2067,7 @@
             av_parser_close(st-&gt;parser);
         }
         av_free(st-&gt;index_entries);
+        av_free(st-&gt;codec-&gt;extradata);
         av_free(st-&gt;codec);
         av_free(st);
     }
@@ -2198,6 +2096,7 @@
 AVStream *av_new_stream(AVFormatContext *s, int id)
 {
     AVStream *st;
+    int i;
 
     if (s-&gt;nb_streams &gt;= MAX_STREAMS)
         return NULL;
@@ -2220,6 +2119,8 @@
     /* default pts settings is MPEG like */
     av_set_pts_info(st, 33, 1, 90000);
     st-&gt;last_IP_pts = AV_NOPTS_VALUE;
+    for(i=0; i&lt;MAX_REORDER_DELAY+1; i++)
+        st-&gt;pts_buffer[i]= AV_NOPTS_VALUE;
 
     s-&gt;streams[s-&gt;nb_streams++] = st;
     return st;
@@ -2283,6 +2184,12 @@
         }
     }
 
+    if (!s-&gt;priv_data &amp;&amp; s-&gt;oformat-&gt;priv_data_size &gt; 0) {
+        s-&gt;priv_data = av_mallocz(s-&gt;oformat-&gt;priv_data_size);
+        if (!s-&gt;priv_data)
+            return AVERROR_NOMEM;
+    }
+
     if(s-&gt;oformat-&gt;write_header){
         ret = s-&gt;oformat-&gt;write_header(s);
         if (ret &lt; 0)
@@ -2315,10 +2222,10 @@
 
 //FIXME merge with compute_pkt_fields
 static int compute_pkt_fields2(AVStream *st, AVPacket *pkt){
-    int b_frames = FFMAX(st-&gt;codec-&gt;has_b_frames, st-&gt;codec-&gt;max_b_frames);
-    int num, den, frame_size;
+    int delay = FFMAX(st-&gt;codec-&gt;has_b_frames, !!st-&gt;codec-&gt;max_b_frames);
+    int num, den, frame_size, i;
 
-//    av_log(NULL, AV_LOG_DEBUG, &quot;av_write_frame: pts:%lld dts:%lld cur_dts:%lld b:%d size:%d st:%d\n&quot;, pkt-&gt;pts, pkt-&gt;dts, st-&gt;cur_dts, b_frames, pkt-&gt;size, pkt-&gt;stream_index);
+//    av_log(st-&gt;codec, AV_LOG_DEBUG, &quot;av_write_frame: pts:%&quot;PRId64&quot; dts:%&quot;PRId64&quot; cur_dts:%&quot;PRId64&quot; b:%d size:%d st:%d\n&quot;, pkt-&gt;pts, pkt-&gt;dts, st-&gt;cur_dts, delay, pkt-&gt;size, pkt-&gt;stream_index);
 
 /*    if(pkt-&gt;pts == AV_NOPTS_VALUE &amp;&amp; pkt-&gt;dts == AV_NOPTS_VALUE)
         return -1;*/
@@ -2332,7 +2239,7 @@
     }
 
     //XXX/FIXME this is a temporary hack until all encoders output pts
-    if((pkt-&gt;pts == 0 || pkt-&gt;pts == AV_NOPTS_VALUE) &amp;&amp; pkt-&gt;dts == AV_NOPTS_VALUE &amp;&amp; !b_frames){
+    if((pkt-&gt;pts == 0 || pkt-&gt;pts == AV_NOPTS_VALUE) &amp;&amp; pkt-&gt;dts == AV_NOPTS_VALUE &amp;&amp; !delay){
         pkt-&gt;dts=
 //        pkt-&gt;pts= st-&gt;cur_dts;
         pkt-&gt;pts= st-&gt;pts.val;
@@ -2340,17 +2247,13 @@
 
     //calculate dts from pts
     if(pkt-&gt;pts != AV_NOPTS_VALUE &amp;&amp; pkt-&gt;dts == AV_NOPTS_VALUE){
-        if(b_frames){
-            if(st-&gt;last_IP_pts == AV_NOPTS_VALUE){
-                st-&gt;last_IP_pts= -pkt-&gt;duration;
-            }
-            if(st-&gt;last_IP_pts &lt; pkt-&gt;pts){
-                pkt-&gt;dts= st-&gt;last_IP_pts;
-                st-&gt;last_IP_pts= pkt-&gt;pts;
-            }else
-                pkt-&gt;dts= pkt-&gt;pts;
-        }else
-            pkt-&gt;dts= pkt-&gt;pts;
+        st-&gt;pts_buffer[0]= pkt-&gt;pts;
+        for(i=1; i&lt;delay+1 &amp;&amp; st-&gt;pts_buffer[i] == AV_NOPTS_VALUE; i++)
+            st-&gt;pts_buffer[i]= (i-delay-1) * pkt-&gt;duration;
+        for(i=0; i&lt;delay &amp;&amp; st-&gt;pts_buffer[i] &gt; st-&gt;pts_buffer[i+1]; i++)
+            FFSWAP(int64_t, st-&gt;pts_buffer[i], st-&gt;pts_buffer[i+1]);
+
+        pkt-&gt;dts= st-&gt;pts_buffer[0];
     }
 
     if(st-&gt;cur_dts &amp;&amp; st-&gt;cur_dts != AV_NOPTS_VALUE &amp;&amp; st-&gt;cur_dts &gt;= pkt-&gt;dts){
@@ -2362,7 +2265,7 @@
         return -1;
     }
 
-//    av_log(NULL, AV_LOG_DEBUG, &quot;av_write_frame: pts2:%lld dts2:%lld\n&quot;, pkt-&gt;pts, pkt-&gt;dts);
+//    av_log(NULL, AV_LOG_DEBUG, &quot;av_write_frame: pts2:%&quot;PRId64&quot; dts2:%&quot;PRId64&quot;\n&quot;, pkt-&gt;pts, pkt-&gt;dts);
     st-&gt;cur_dts= pkt-&gt;dts;
     st-&gt;pts.val= pkt-&gt;dts;
 
@@ -2392,8 +2295,10 @@
 //    if(pkt-&gt;dts &lt; 0)
 //        pkt-&gt;dts= 0;  //this happens for low_delay=0 and b frames, FIXME, needs further invstigation about what we should do here
 
-    pkt-&gt;pts &amp;= pts_mask;
-    pkt-&gt;dts &amp;= pts_mask;
+    if (pkt-&gt;pts != AV_NOPTS_VALUE)
+        pkt-&gt;pts &amp;= pts_mask;
+    if (pkt-&gt;dts != AV_NOPTS_VALUE)
+        pkt-&gt;dts &amp;= pts_mask;
 }
 
 /**
@@ -2410,7 +2315,7 @@
     int ret;
 
     ret=compute_pkt_fields2(s-&gt;streams[pkt-&gt;stream_index], pkt);
-    if(ret&lt;0)
+    if(ret&lt;0 &amp;&amp; !(s-&gt;oformat-&gt;flags &amp; AVFMT_NOTIMESTAMPS))
         return ret;
 
     truncate_ts(s-&gt;streams[pkt-&gt;stream_index], pkt);
@@ -2422,11 +2327,20 @@
 }
 
 /**
- * interleave_packet implementation which will interleave per DTS.
- * packets with pkt-&gt;destruct == av_destruct_packet will be freed inside this function.
- * so they cannot be used after it, note calling av_free_packet() on them is still safe
+ * Interleave a packet per DTS in an output media file.
+ *
+ * Packets with pkt-&gt;destruct == av_destruct_packet will be freed inside this function,
+ * so they cannot be used after it, note calling av_free_packet() on them is still safe.
+ *
+ * @param s media file handle
+ * @param out the interleaved packet will be output here
+ * @param in the input packet
+ * @param flush 1 if no further packets are available as input and all
+ *              remaining packets should be output
+ * @return 1 if a packet was output, 0 if no packet could be output,
+ *         &lt; 0 if an error occured
  */
-static int av_interleave_packet_per_dts(AVFormatContext *s, AVPacket *out, AVPacket *pkt, int flush){
+int av_interleave_packet_per_dts(AVFormatContext *s, AVPacket *out, AVPacket *pkt, int flush){
     AVPacketList *pktl, **next_point, *this_pktl;
     int stream_count=0;
     int streams[MAX_STREAMS];
@@ -2459,7 +2373,7 @@
     memset(streams, 0, sizeof(streams));
     pktl= s-&gt;packet_buffer;
     while(pktl){
-//av_log(s, AV_LOG_DEBUG, &quot;show st:%d dts:%lld\n&quot;, pktl-&gt;pkt.stream_index, pktl-&gt;pkt.dts);
+//av_log(s, AV_LOG_DEBUG, &quot;show st:%d dts:%&quot;PRId64&quot;\n&quot;, pktl-&gt;pkt.stream_index, pktl-&gt;pkt.dts);
         if(streams[ pktl-&gt;pkt.stream_index ] == 0)
             stream_count++;
         streams[ pktl-&gt;pkt.stream_index ]++;
@@ -2516,8 +2430,8 @@
     if(st-&gt;codec-&gt;codec_type == CODEC_TYPE_AUDIO &amp;&amp; pkt-&gt;size==0)
         return 0;
 
-//av_log(NULL, AV_LOG_DEBUG, &quot;av_interleaved_write_frame %d %Ld %Ld\n&quot;, pkt-&gt;size, pkt-&gt;dts, pkt-&gt;pts);
-    if(compute_pkt_fields2(st, pkt) &lt; 0)
+//av_log(NULL, AV_LOG_DEBUG, &quot;av_interleaved_write_frame %d %&quot;PRId64&quot; %&quot;PRId64&quot;\n&quot;, pkt-&gt;size, pkt-&gt;dts, pkt-&gt;pts);
+    if(compute_pkt_fields2(st, pkt) &lt; 0 &amp;&amp; !(s-&gt;oformat-&gt;flags &amp; AVFMT_NOTIMESTAMPS))
         return -1;
 
     if(pkt-&gt;dts == AV_NOPTS_VALUE)
@@ -2647,6 +2561,7 @@
             av_log(NULL, AV_LOG_INFO, &quot;(%s)&quot;, st-&gt;language);
         }
         av_log(NULL, AV_LOG_DEBUG, &quot;, %d/%d&quot;, st-&gt;time_base.num/g, st-&gt;time_base.den/g);
+        av_log(NULL, AV_LOG_INFO, &quot;: %s&quot;, buf);
         if(st-&gt;codec-&gt;codec_type == CODEC_TYPE_VIDEO){
             if(st-&gt;r_frame_rate.den &amp;&amp; st-&gt;r_frame_rate.num)
                 av_log(NULL, AV_LOG_INFO, &quot;, %5.2f fps(r)&quot;, av_q2d(st-&gt;r_frame_rate));
@@ -2655,7 +2570,7 @@
             else
                 av_log(NULL, AV_LOG_INFO, &quot;, %5.2f fps(c)&quot;, 1/av_q2d(st-&gt;codec-&gt;time_base));
         }
-        av_log(NULL, AV_LOG_INFO, &quot;: %s\n&quot;, buf);
+        av_log(NULL, AV_LOG_INFO, &quot;\n&quot;);
     }
 }
 
@@ -2850,7 +2765,7 @@
         if (duration)
             return 0;
         else
-            return now * int64_t_C(1000000);
+            return now * INT64_C(1000000);
     }
 
     if (duration) {
@@ -2927,12 +2842,18 @@
 
 /**
  * Returns in 'buf' the path with '%d' replaced by number.
- *
+
  * Also handles the '%0nd' format where 'n' is the total number
- * of digits and '%%'. Return 0 if OK, and -1 if format error.
+ * of digits and '%%'.
+ *
+ * @param buf destination buffer
+ * @param buf_size destination buffer size
+ * @param path numbered sequence string
+ * @number frame number
+ * @return 0 if OK, -1 if format error.
  */
-int get_frame_filename(char *buf, int buf_size,
-                       const char *path, int number)
+int av_get_frame_filename(char *buf, int buf_size,
+                          const char *path, int number)
 {
     const char *p;
     char *q, buf1[20], c;
@@ -3148,7 +3069,7 @@
  * @param num must be &gt;= 0
  * @param den must be &gt;= 1
  */
-void av_frac_init(AVFrac *f, int64_t val, int64_t num, int64_t den)
+static void av_frac_init(AVFrac *f, int64_t val, int64_t num, int64_t den)
 {
     num += (den &gt;&gt; 1);
     if (num &gt;= den) {
@@ -3161,32 +3082,17 @@
 }
 
 /**
- * Set f to (val + 0.5).
- */
-void av_frac_set(AVFrac *f, int64_t val)
-{
-    f-&gt;val = val;
-    f-&gt;num = f-&gt;den &gt;&gt; 1;
-}
-
-/**
  * Fractionnal addition to f: f = f + (incr / f-&gt;den).
  *
  * @param f fractional number
  * @param incr increment, can be positive or negative
  */
-void av_frac_add(AVFrac *f, int64_t incr)
+static void av_frac_add(AVFrac *f, int64_t incr)
 {
     int64_t num, den;
 
     num = f-&gt;num + incr;
     den = f-&gt;den;
-    ///MEANX
-    if(!den)
-    {
-		return;
-    }
-    ///MEANX
     if (num &lt; 0) {
         f-&gt;val += num / den;
         num = num % den;
@@ -3200,93 +3106,3 @@
     }
     f-&gt;num = num;
 }
-
-/**
- * register a new image format
- * @param img_fmt Image format descriptor
- */
-void av_register_image_format(AVImageFormat *img_fmt)
-{
-    AVImageFormat **p;
-
-    p = &amp;first_image_format;
-    while (*p != NULL) p = &amp;(*p)-&gt;next;
-    *p = img_fmt;
-    img_fmt-&gt;next = NULL;
-}
-
-/**
- * Guesses image format based on data in the image.
- */
-AVImageFormat *av_probe_image_format(AVProbeData *pd)
-{
-    AVImageFormat *fmt1, *fmt;
-    int score, score_max;
-
-    fmt = NULL;
-    score_max = 0;
-    for(fmt1 = first_image_format; fmt1 != NULL; fmt1 = fmt1-&gt;next) {
-        if (fmt1-&gt;img_probe) {
-            score = fmt1-&gt;img_probe(pd);
-            if (score &gt; score_max) {
-                score_max = score;
-                fmt = fmt1;
-            }
-        }
-    }
-    return fmt;
-}
-
-/**
- * Guesses image format based on file name extensions.
- */
-AVImageFormat *guess_image_format(const char *filename)
-{
-    AVImageFormat *fmt1;
-
-    for(fmt1 = first_image_format; fmt1 != NULL; fmt1 = fmt1-&gt;next) {
-        if (fmt1-&gt;extensions &amp;&amp; match_ext(filename, fmt1-&gt;extensions))
-            return fmt1;
-    }
-    return NULL;
-}
-
-/**
- * Read an image from a stream.
- * @param gb byte stream containing the image
- * @param fmt image format, NULL if probing is required
- */
-int av_read_image(ByteIOContext *pb, const char *filename,
-                  AVImageFormat *fmt,
-                  int (*alloc_cb)(void *, AVImageInfo *info), void *opaque)
-{
-    uint8_t buf[PROBE_BUF_MIN];
-    AVProbeData probe_data, *pd = &amp;probe_data;
-    offset_t pos;
-    int ret;
-
-    if (!fmt) {
-        pd-&gt;filename = filename;
-        pd-&gt;buf = buf;
-        pos = url_ftell(pb);
-        pd-&gt;buf_size = get_buffer(pb, buf, PROBE_BUF_MIN);
-        url_fseek(pb, pos, SEEK_SET);
-        fmt = av_probe_image_format(pd);
-    }
-    if (!fmt)
-        return AVERROR_NOFMT;
-    ret = fmt-&gt;img_read(pb, alloc_cb, opaque);
-    return ret;
-}
-
-/**
- * Write an image to a stream.
- * @param pb byte stream for the image output
- * @param fmt image format
- * @param img image data and informations
- */
-int av_write_image(ByteIOContext *pb, AVImageFormat *fmt, AVImageInfo *img)
-{
-    return fmt-&gt;img_write(pb, img);
-}
-

Modified: branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/wav.c
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/wav.c	2007-01-20 15:15:58 UTC (rev 2746)
+++ branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavformat/wav.c	2007-01-21 18:04:24 UTC (rev 2747)
@@ -1,205 +1,33 @@
 /*
- * WAV encoder and decoder
+ * WAV muxer and demuxer
  * Copyright (c) 2001, 2002 Fabrice Bellard.
  *
- * This library is free software; you can redistribute it and/or
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
  * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
+ * version 2.1 of the License, or (at your option) any later version.
  *
- * This library is distributed in the hope that it will be useful,
+ * FFmpeg is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  * Lesser General Public License for more details.
  *
  * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 #include &quot;avformat.h&quot;
-#include &quot;avi.h&quot;
+#include &quot;allformats.h&quot;
+#include &quot;riff.h&quot;
 
-const CodecTag codec_wav_tags[] = {
-    { CODEC_ID_MP2, 0x50 },
-    { CODEC_ID_MP3, 0x55 },
-    { CODEC_ID_AC3, 0x2000 },
-    { CODEC_ID_DTS, 0x2001 },
-    { CODEC_ID_PCM_S16LE, 0x01 },
-    { CODEC_ID_PCM_U8, 0x01 }, /* must come after s16le in this list */
-    { CODEC_ID_PCM_S24LE, 0x01 },
-    { CODEC_ID_PCM_S32LE, 0x01 },
-    { CODEC_ID_PCM_ALAW, 0x06 },
-    { CODEC_ID_PCM_MULAW, 0x07 },
-    { CODEC_ID_ADPCM_MS, 0x02 },
-    { CODEC_ID_ADPCM_IMA_WAV, 0x11 },
-    { CODEC_ID_ADPCM_YAMAHA, 0x20 },
-    { CODEC_ID_ADPCM_G726, 0x45 },
-    { CODEC_ID_ADPCM_IMA_DK4, 0x61 },  /* rogue format number */
-    { CODEC_ID_ADPCM_IMA_DK3, 0x62 },  /* rogue format number */
-    { CODEC_ID_WMAV1, 0x160 },
-    { CODEC_ID_WMAV2, 0x161 },
-    { CODEC_ID_AAC, 0x706d },
-    { CODEC_ID_VORBIS, ('V'&lt;&lt;8)+'o' }, //HACK/FIXME, does vorbis in WAV/AVI have an (in)official id?
-    { CODEC_ID_SONIC, 0x2048 },
-    { CODEC_ID_SONIC_LS, 0x2048 },
-    { CODEC_ID_ADPCM_CT, 0x200 },
-    { CODEC_ID_ADPCM_SWF, ('S'&lt;&lt;8)+'F' },
-    { 0, 0 },
-};
-
-#ifdef CONFIG_MUXERS
-/* WAVEFORMATEX header */
-/* returns the size or -1 on error */
-int put_wav_header(ByteIOContext *pb, AVCodecContext *enc)
-{
-    int bps, blkalign, bytespersec;
-    int hdrsize = 18;
-
-    if(!enc-&gt;codec_tag)
-       enc-&gt;codec_tag = codec_get_tag(codec_wav_tags, enc-&gt;codec_id);
-    if(!enc-&gt;codec_tag)
-        return -1;
-
-    put_le16(pb, enc-&gt;codec_tag);
-    put_le16(pb, enc-&gt;channels);
-    put_le32(pb, enc-&gt;sample_rate);
-    if (enc-&gt;codec_id == CODEC_ID_PCM_U8 ||
-        enc-&gt;codec_id == CODEC_ID_PCM_ALAW ||
-        enc-&gt;codec_id == CODEC_ID_PCM_MULAW) {
-        bps = 8;
-    } else if (enc-&gt;codec_id == CODEC_ID_MP2 || enc-&gt;codec_id == CODEC_ID_MP3) {
-        bps = 0;
-    } else if (enc-&gt;codec_id == CODEC_ID_ADPCM_IMA_WAV || enc-&gt;codec_id == CODEC_ID_ADPCM_MS || enc-&gt;codec_id == CODEC_ID_ADPCM_G726 || enc-&gt;codec_id == CODEC_ID_ADPCM_YAMAHA) { //
-        bps = 4;
-    } else if (enc-&gt;codec_id == CODEC_ID_PCM_S24LE) {
-        bps = 24;
-    } else if (enc-&gt;codec_id == CODEC_ID_PCM_S32LE) {
-        bps = 32;
-    } else {
-        bps = 16;
-    }
-
-    if (enc-&gt;codec_id == CODEC_ID_MP2 || enc-&gt;codec_id == CODEC_ID_MP3) {
-        blkalign = enc-&gt;frame_size; //this is wrong, but seems many demuxers dont work if this is set correctly
-        //blkalign = 144 * enc-&gt;bit_rate/enc-&gt;sample_rate;
-    } else if (enc-&gt;codec_id == CODEC_ID_ADPCM_G726) { //
-        blkalign = 1;
-    } else if (enc-&gt;block_align != 0) { /* specified by the codec */
-        blkalign = enc-&gt;block_align;
-    } else
-        blkalign = enc-&gt;channels*bps &gt;&gt; 3;
-    if (enc-&gt;codec_id == CODEC_ID_PCM_U8 ||
-        enc-&gt;codec_id == CODEC_ID_PCM_S24LE ||
-        enc-&gt;codec_id == CODEC_ID_PCM_S32LE ||
-        enc-&gt;codec_id == CODEC_ID_PCM_S16LE) {
-        bytespersec = enc-&gt;sample_rate * blkalign;
-    } else {
-        bytespersec = enc-&gt;bit_rate / 8;
-    }
-    put_le32(pb, bytespersec); /* bytes per second */
-    put_le16(pb, blkalign); /* block align */
-    put_le16(pb, bps); /* bits per sample */
-    if (enc-&gt;codec_id == CODEC_ID_MP3) {
-        put_le16(pb, 12); /* wav_extra_size */
-        hdrsize += 12;
-        put_le16(pb, 1); /* wID */
-        put_le32(pb, 2); /* fdwFlags */
-        put_le16(pb, 1152); /* nBlockSize */
-        put_le16(pb, 1); /* nFramesPerBlock */
-        put_le16(pb, 1393); /* nCodecDelay */
-    } else if (enc-&gt;codec_id == CODEC_ID_MP2) {
-        put_le16(pb, 22); /* wav_extra_size */
-        hdrsize += 22;
-        put_le16(pb, 2);  /* fwHeadLayer */
-        put_le32(pb, enc-&gt;bit_rate); /* dwHeadBitrate */
-        put_le16(pb, enc-&gt;channels == 2 ? 1 : 8); /* fwHeadMode */
-        put_le16(pb, 0);  /* fwHeadModeExt */
-        put_le16(pb, 1);  /* wHeadEmphasis */
-        put_le16(pb, 16); /* fwHeadFlags */
-        put_le32(pb, 0);  /* dwPTSLow */
-        put_le32(pb, 0);  /* dwPTSHigh */
-    } else if (enc-&gt;codec_id == CODEC_ID_ADPCM_IMA_WAV) {
-        put_le16(pb, 2); /* wav_extra_size */
-        hdrsize += 2;
-        put_le16(pb, ((enc-&gt;block_align - 4 * enc-&gt;channels) / (4 * enc-&gt;channels)) * 8 + 1); /* wSamplesPerBlock */
-    } else if(enc-&gt;extradata_size){
-        put_le16(pb, enc-&gt;extradata_size);
-        put_buffer(pb, enc-&gt;extradata, enc-&gt;extradata_size);
-        hdrsize += enc-&gt;extradata_size;
-        if(hdrsize&amp;1){
-            hdrsize++;
-            put_byte(pb, 0);
-        }
-    } else {
-        hdrsize -= 2;
-    }
-
-    return hdrsize;
-}
-#endif //CONFIG_MUXERS
-
-/* We could be given one of the three possible structures here:
- * WAVEFORMAT, PCMWAVEFORMAT or WAVEFORMATEX. Each structure
- * is an expansion of the previous one with the fields added
- * at the bottom. PCMWAVEFORMAT adds 'WORD wBitsPerSample' and
- * WAVEFORMATEX adds 'WORD  cbSize' and basically makes itself
- * an openended structure.
- */
-void get_wav_header(ByteIOContext *pb, AVCodecContext *codec, int size)
-{
-    int id;
-
-    id = get_le16(pb);
-    codec-&gt;codec_type = CODEC_TYPE_AUDIO;
-    codec-&gt;codec_tag = id;
-    codec-&gt;channels = get_le16(pb);
-    codec-&gt;sample_rate = get_le32(pb);
-    codec-&gt;bit_rate = get_le32(pb) * 8;
-    codec-&gt;block_align = get_le16(pb);
-    if (size == 14) {  /* We're dealing with plain vanilla WAVEFORMAT */
-        codec-&gt;bits_per_sample = 8;
-    }else
-        codec-&gt;bits_per_sample = get_le16(pb);
-    codec-&gt;codec_id = wav_codec_get_id(id, codec-&gt;bits_per_sample);
-
-    if (size &gt; 16) {  /* We're obviously dealing with WAVEFORMATEX */
-        codec-&gt;extradata_size = get_le16(pb);
-        if (codec-&gt;extradata_size &gt; 0) {
-            if (codec-&gt;extradata_size &gt; size - 18)
-                codec-&gt;extradata_size = size - 18;
-            codec-&gt;extradata = av_mallocz(codec-&gt;extradata_size + FF_INPUT_BUFFER_PADDING_SIZE);
-            get_buffer(pb, codec-&gt;extradata, codec-&gt;extradata_size);
-        } else
-            codec-&gt;extradata_size = 0;
-
-        /* It is possible for the chunk to contain garbage at the end */
-        if (size - codec-&gt;extradata_size - 18 &gt; 0)
-            url_fskip(pb, size - codec-&gt;extradata_size - 18);
-    }
-}
-
-
-int wav_codec_get_id(unsigned int tag, int bps)
-{
-    int id;
-    id = codec_get_id(codec_wav_tags, tag);
-    if (id &lt;= 0)
-        return id;
-    /* handle specific u8 codec */
-    if (id == CODEC_ID_PCM_S16LE &amp;&amp; bps == 8)
-        id = CODEC_ID_PCM_U8;
-    if (id == CODEC_ID_PCM_S16LE &amp;&amp; bps == 24)
-        id = CODEC_ID_PCM_S24LE;
-    if (id == CODEC_ID_PCM_S16LE &amp;&amp; bps == 32)
-        id = CODEC_ID_PCM_S32LE;
-    return id;
-}
-
-#ifdef CONFIG_MUXERS
 typedef struct {
     offset_t data;
+    offset_t data_end;
 } WAVContext;
 
+#ifdef CONFIG_MUXERS
 static int wav_write_header(AVFormatContext *s)
 {
     WAVContext *wav = s-&gt;priv_data;
@@ -299,6 +127,7 @@
     unsigned int tag;
     ByteIOContext *pb = &amp;s-&gt;pb;
     AVStream *st;
+    WAVContext *wav = s-&gt;priv_data;
 
     /* check RIFF header */
     tag = get_le32(pb);
@@ -326,6 +155,7 @@
     size = find_tag(pb, MKTAG('d', 'a', 't', 'a'));
     if (size &lt; 0)
         return -1;
+    wav-&gt;data_end= url_ftell(pb) + size;
     return 0;
 }
 
@@ -334,19 +164,30 @@
 static int wav_read_packet(AVFormatContext *s,
                            AVPacket *pkt)
 {
-    int ret, size;
+    int ret, size, left;
     AVStream *st;
+    WAVContext *wav = s-&gt;priv_data;
 
     if (url_feof(&amp;s-&gt;pb))
         return AVERROR_IO;
     st = s-&gt;streams[0];
 
+    left= wav-&gt;data_end - url_ftell(&amp;s-&gt;pb);
+    if(left &lt;= 0){
+        left = find_tag(&amp;(s-&gt;pb), MKTAG('d', 'a', 't', 'a'));
+        if (left &lt; 0) {
+            return AVERROR_IO;
+        }
+        wav-&gt;data_end= url_ftell(&amp;s-&gt;pb) + left;
+    }
+
     size = MAX_SIZE;
     if (st-&gt;codec-&gt;block_align &gt; 1) {
         if (size &lt; st-&gt;codec-&gt;block_align)
             size = st-&gt;codec-&gt;block_align;
         size = (size / st-&gt;codec-&gt;block_align) * st-&gt;codec-&gt;block_align;
     }
+    size= FFMIN(size, left);
     if (av_new_packet(pkt, size))
         return AVERROR_IO;
     pkt-&gt;stream_index = 0;
@@ -381,24 +222,24 @@
     default:
         break;
     }
-    // meanx return pcm_read_seek(s, stream_index, timestamp, flags);
-        return -1;
+    return pcm_read_seek(s, stream_index, timestamp, flags);
 }
 
-
-static AVInputFormat wav_iformat = {
+#ifdef CONFIG_WAV_DEMUXER
+AVInputFormat wav_demuxer = {
     &quot;wav&quot;,
     &quot;wav format&quot;,
-    0,
+    sizeof(WAVContext),
     wav_probe,
     wav_read_header,
     wav_read_packet,
     wav_read_close,
     wav_read_seek,
+    .codec_tag= {codec_wav_tags},
 };
-
-#ifdef CONFIG_MUXERS
-static AVOutputFormat wav_oformat = {
+#endif
+#ifdef CONFIG_WAV_MUXER
+AVOutputFormat wav_muxer = {
     &quot;wav&quot;,
     &quot;wav format&quot;,
     &quot;audio/x-wav&quot;,
@@ -409,14 +250,6 @@
     wav_write_header,
     wav_write_packet,
     wav_write_trailer,
+    .codec_tag= {codec_wav_tags},
 };
-#endif //CONFIG_MUXERS
-
-int ff_wav_init(void)
-{
-    av_register_input_format(&amp;wav_iformat);
-#ifdef CONFIG_MUXERS
-    av_register_output_format(&amp;wav_oformat);
-#endif //CONFIG_MUXERS
-    return 0;
-}
+#endif


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000073.html">[Avidemux-svn-commit] r2746 - in	branches/avidemux_2.4_branch/avidemux:	ADM_inputs/ADM_mpegdemuxer ADM_toolkit	ADM_userInterfaces/ADM_GTK/ADM_dialog	ADM_userInterfaces/ADM_NONE/ADM_dialog	ADM_userInterfaces/ADM_QT4/ADM_dialog	ADM_userInterfaces/ADM_commonUI
</A></li>
	<LI>Next message: <A HREF="000075.html">[Avidemux-svn-commit] r2748 -	branches/avidemux_2.4_branch/avidemux/ADM_libraries/ADM_lavutil
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#74">[ date ]</a>
              <a href="thread.html#74">[ thread ]</a>
              <a href="subject.html#74">[ subject ]</a>
              <a href="author.html#74">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">More information about the Avidemux-svn-commit
mailing list</a><br>
</body></html>
