<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Avidemux-svn-commit] r2721 - in	branches/avidemux_2.4_branch/avidemux: .	ADM_userInterfaces/ADM_GTK/ADM_dialog	ADM_userInterfaces/ADM_NONE/ADM_dialog	ADM_userInterfaces/ADM_QT4/ADM_dialog ADM_video ADM_videoFilter
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/avidemux-svn-commit/2007-January/index.html" >
   <LINK REL="made" HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r2721%20-%20in%0A%09branches/avidemux_2.4_branch/avidemux%3A%20.%0A%09ADM_userInterfaces/ADM_GTK/ADM_dialog%0A%09ADM_userInterfaces/ADM_NONE/ADM_dialog%0A%09ADM_userInterfaces/ADM_QT4/ADM_dialog%20ADM_video%20ADM_videoFilter&In-Reply-To=%3C200701131637.l0DGbZDr027292%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000048.html">
   <LINK REL="Next"  HREF="000050.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Avidemux-svn-commit] r2721 - in	branches/avidemux_2.4_branch/avidemux: .	ADM_userInterfaces/ADM_GTK/ADM_dialog	ADM_userInterfaces/ADM_NONE/ADM_dialog	ADM_userInterfaces/ADM_QT4/ADM_dialog ADM_video ADM_videoFilter</H1>
    <B>mean at BerliOS</B> 
    <A HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r2721%20-%20in%0A%09branches/avidemux_2.4_branch/avidemux%3A%20.%0A%09ADM_userInterfaces/ADM_GTK/ADM_dialog%0A%09ADM_userInterfaces/ADM_NONE/ADM_dialog%0A%09ADM_userInterfaces/ADM_QT4/ADM_dialog%20ADM_video%20ADM_videoFilter&In-Reply-To=%3C200701131637.l0DGbZDr027292%40sheep.berlios.de%3E"
       TITLE="[Avidemux-svn-commit] r2721 - in	branches/avidemux_2.4_branch/avidemux: .	ADM_userInterfaces/ADM_GTK/ADM_dialog	ADM_userInterfaces/ADM_NONE/ADM_dialog	ADM_userInterfaces/ADM_QT4/ADM_dialog ADM_video ADM_videoFilter">mean at mail.berlios.de
       </A><BR>
    <I>Sat Jan 13 17:37:35 CET 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="000048.html">[Avidemux-svn-commit] r2720 - in	branches/avidemux_2.4_branch/avidemux: . ADM_video ADM_videoFilter
</A></li>
        <LI>Next message: <A HREF="000050.html">[Avidemux-svn-commit] r2722 -	branches/avidemux_2.4_branch/avidemux/ADM_osSupport
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#49">[ date ]</a>
              <a href="thread.html#49">[ thread ]</a>
              <a href="subject.html#49">[ subject ]</a>
              <a href="author.html#49">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: mean
Date: 2007-01-13 17:37:32 +0100 (Sat, 13 Jan 2007)
New Revision: 2721

Added:
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidBlend.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidDecDec.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidDecDec_param.h
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidDecTel_param.h
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidDecTelecide.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidDecTelecide.h
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidDeintASM.cpp
Removed:
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_decimate.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidBlend.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidDecDec.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidDecDec_param.h
   branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidDecTel_param.h
   branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidDecTelecide.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidDecTelecide.h
   branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidDeintASM.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidDeinterlace.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidDeinterlace.h
   branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidField.h
   branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidFields.cpp
Modified:
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_dectel.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/Makefile.am
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_NONE/ADM_dialog/DIA_none.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/DIA_none.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidAsharp.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidColorYuv.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidEqualizer.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_video/Makefile.am
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidDGbob.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidFade.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidFastConvolution.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidForcedPP.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidMPLD3D.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidMSharpen.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidMcDeint.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidMosaic.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidMsmooth.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidPalSmart.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidPalSmart.h
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidReverse.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/Makefile.am
   branches/avidemux_2.4_branch/avidemux/libcheck.sh
Log:
more cleanup

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_decimate.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_decimate.cpp	2007-01-13 12:08:21 UTC (rev 2720)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_decimate.cpp	2007-01-13 16:37:32 UTC (rev 2721)
@@ -1,306 +0,0 @@
-//
-// C++ Implementation: DIA_decimate
-//
-// Description: 
-//
-//
-// Author: mean &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>&gt;, (C) 2004
-//
-// Copyright: See COPYING file that comes with this distribution
-//
-//
-//
-// C++ Implementation: DIA_dectel
-//
-// Description: 
-//
-//
-// Author: mean &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>&gt;, (C) 2004
-//
-// Copyright: See COPYING file that comes with this distribution
-//
-//
-
-
-#include &lt;config.h&gt;
-
-#include &lt;sys/types.h&gt;
-#include &lt;sys/stat.h&gt;
-
-
-#include &lt;gdk/gdkkeysyms.h&gt;
-#include &lt;gtk/gtk.h&gt;
-
-
-#include &lt;gdk/gdkkeysyms.h&gt;
-#include &lt;gtk/gtk.h&gt;
-# include &lt;math.h&gt;
-
-#include &quot;default.h&quot;
-#include &quot;ADM_toolkit_gtk/toolkit_gtk.h&quot;
-#include &quot;ADM_toolkit_gtk/toolkit_gtk_include.h&quot;
-#include &quot;ADM_toolkit/toolkit.hxx&quot;
-
-#include &quot;ADM_video/ADM_vidDecDec_param.h&quot;
-#define MENU_SET(x,y) { gtk_option_menu_set_history (GTK_OPTION_MENU(WID(x)),param-&gt;y);}
-#define MENU_GET(x,y) { param-&gt;y	= getRangeInMenu(WID(x));}
-static GtkWidget	*create_dialog1 (void);
-#define SPIN_GET(x,y) {param-&gt;y= gtk_spin_button_get_value_as_int(GTK_SPIN_BUTTON(WID(x))) ;}
-
-#define SPIN_SET(x,y)  {gtk_spin_button_set_value(GTK_SPIN_BUTTON(WID(x)),(gfloat)param-&gt;y) ;}
-
-uint8_t DIA_getDecombDecimate(DECIMATE_PARAM *param)
-{
-GtkWidget *dialog;
-int ret=0;
-	dialog=create_dialog1();
-	
-	// Update
-	
-	gtk_write_entry_float(WID(entryThresh),param-&gt;threshold);
-	gtk_write_entry_float(WID(entry2),param-&gt;threshold2);
-	
-	MENU_SET(optionmenu1,mode);
-	MENU_SET(optionmenu2,quality);
-	SPIN_SET(spinbuttonCycle,cycle);
-	
-	gtk_register_dialog(dialog);
-	if(gtk_dialog_run(GTK_DIALOG(dialog))==GTK_RESPONSE_OK)
-	{
-		MENU_GET(optionmenu1,mode);
-		MENU_GET(optionmenu2,quality);
-		SPIN_GET(spinbuttonCycle,cycle);
-		#define RD_ENTRY(x,y) {param-&gt;y=gtk_read_entry_float(WID(x));}
-		RD_ENTRY(entryThresh,threshold);
-		RD_ENTRY(entry2,threshold2);
-		ret=1;
-	
-	}
-        gtk_unregister_dialog(dialog);
-	gtk_widget_destroy(dialog);
-	return ret;
-}
-//________________________________________________
-GtkWidget*
-create_dialog1 (void)
-{
-  GtkWidget *dialog1;
-  GtkWidget *dialog_vbox1;
-  GtkWidget *table1;
-  GtkWidget *label1;
-  GtkObject *spinbuttonCycle_adj;
-  GtkWidget *spinbuttonCycle;
-  GtkWidget *label2;
-  GtkWidget *optionmenu1;
-  GtkWidget *menu1;
-  GtkWidget *discard_closer1;
-  GtkWidget *replace_by_interpolate1;
-  GtkWidget *discard_from_longest_dups__anim__s_1;
-  GtkWidget *pulldown_dups_removal1;
-  GtkWidget *label3;
-  GtkWidget *entryThresh;
-  GtkWidget *label4;
-  GtkWidget *entry2;
-  GtkWidget *label5;
-  GtkWidget *optionmenu2;
-  GtkWidget *menu2;
-  GtkWidget *fastest__no_chroma_partial_luma_1;
-  GtkWidget *fast__partial_luma_and_chroma_1;
-  GtkWidget *medium__full_luma_not_chroma_1;
-  GtkWidget *slow__full_luma_and_chroma_1;
-  GtkWidget *dialog_action_area1;
-  GtkWidget *cancelbutton1;
-  GtkWidget *okbutton1;
-
-  dialog1 = gtk_dialog_new ();
-  gtk_window_set_title (GTK_WINDOW (dialog1), _(&quot;Decomb Decimate&quot;));
-
-  dialog_vbox1 = GTK_DIALOG (dialog1)-&gt;vbox;
-  gtk_widget_show (dialog_vbox1);
-
-  table1 = gtk_table_new (5, 2, FALSE);
-  gtk_widget_show (table1);
-  gtk_box_pack_start (GTK_BOX (dialog_vbox1), table1, TRUE, TRUE, 0);
-
-  label1 = gtk_label_new (_(&quot;Cycle&quot;));
-  gtk_widget_show (label1);
-  gtk_table_attach (GTK_TABLE (table1), label1, 0, 1, 0, 1,
-                    (GtkAttachOptions) (GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-  gtk_label_set_justify (GTK_LABEL (label1), GTK_JUSTIFY_LEFT);
-  gtk_misc_set_alignment (GTK_MISC (label1), 0, 0.5);
-
-  spinbuttonCycle_adj = gtk_adjustment_new (1, 2, 40, 1, 10, 10);
-  spinbuttonCycle = gtk_spin_button_new (GTK_ADJUSTMENT (spinbuttonCycle_adj), 1, 0);
-  gtk_widget_show (spinbuttonCycle);
-  gtk_table_attach (GTK_TABLE (table1), spinbuttonCycle, 1, 2, 0, 1,
-                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-  gtk_spin_button_set_numeric (GTK_SPIN_BUTTON (spinbuttonCycle), TRUE);
-
-  label2 = gtk_label_new (_(&quot;Mode&quot;));
-  gtk_widget_show (label2);
-  gtk_table_attach (GTK_TABLE (table1), label2, 0, 1, 1, 2,
-                    (GtkAttachOptions) (GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-  gtk_label_set_justify (GTK_LABEL (label2), GTK_JUSTIFY_LEFT);
-  gtk_misc_set_alignment (GTK_MISC (label2), 0, 0.5);
-
-  optionmenu1 = gtk_option_menu_new ();
-  gtk_widget_show (optionmenu1);
-  gtk_table_attach (GTK_TABLE (table1), optionmenu1, 1, 2, 1, 2,
-                    (GtkAttachOptions) (GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-
-  menu1 = gtk_menu_new ();
-
-  discard_closer1 = gtk_menu_item_new_with_mnemonic (_(&quot;Discard Closer&quot;));
-  gtk_widget_show (discard_closer1);
-  gtk_container_add (GTK_CONTAINER (menu1), discard_closer1);
-
-  replace_by_interpolate1 = gtk_menu_item_new_with_mnemonic (_(&quot;Replace by interpolate&quot;));
-  gtk_widget_show (replace_by_interpolate1);
-  gtk_container_add (GTK_CONTAINER (menu1), replace_by_interpolate1);
-
-  discard_from_longest_dups__anim__s_1 = gtk_menu_item_new_with_mnemonic (_(&quot;Discard from longest dups (anim\303\251s)&quot;));
-  gtk_widget_show (discard_from_longest_dups__anim__s_1);
-  gtk_container_add (GTK_CONTAINER (menu1), discard_from_longest_dups__anim__s_1);
-
-  pulldown_dups_removal1 = gtk_menu_item_new_with_mnemonic (_(&quot;Pulldown dups removal&quot;));
-  gtk_widget_show (pulldown_dups_removal1);
-  gtk_container_add (GTK_CONTAINER (menu1), pulldown_dups_removal1);
-
-  gtk_option_menu_set_menu (GTK_OPTION_MENU (optionmenu1), menu1);
-
-  label3 = gtk_label_new (_(&quot;Threshold &quot;));
-  gtk_widget_show (label3);
-  gtk_table_attach (GTK_TABLE (table1), label3, 0, 1, 2, 3,
-                    (GtkAttachOptions) (GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-  gtk_label_set_justify (GTK_LABEL (label3), GTK_JUSTIFY_LEFT);
-  gtk_misc_set_alignment (GTK_MISC (label3), 0, 0.5);
-
-  entryThresh = gtk_entry_new ();
-  gtk_widget_show (entryThresh);
-  gtk_table_attach (GTK_TABLE (table1), entryThresh, 1, 2, 2, 3,
-                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-
-  label4 = gtk_label_new (_(&quot;Threshold2 &quot;));
-  gtk_widget_show (label4);
-  gtk_table_attach (GTK_TABLE (table1), label4, 0, 1, 3, 4,
-                    (GtkAttachOptions) (GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-  gtk_label_set_justify (GTK_LABEL (label4), GTK_JUSTIFY_LEFT);
-  gtk_misc_set_alignment (GTK_MISC (label4), 0, 0.5);
-
-  entry2 = gtk_entry_new ();
-  gtk_widget_show (entry2);
-  gtk_table_attach (GTK_TABLE (table1), entry2, 1, 2, 3, 4,
-                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-
-  label5 = gtk_label_new (_(&quot;Quality &quot;));
-  gtk_widget_show (label5);
-  gtk_table_attach (GTK_TABLE (table1), label5, 0, 1, 4, 5,
-                    (GtkAttachOptions) (GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-  gtk_label_set_justify (GTK_LABEL (label5), GTK_JUSTIFY_LEFT);
-  gtk_misc_set_alignment (GTK_MISC (label5), 0, 0.5);
-
-  optionmenu2 = gtk_option_menu_new ();
-  gtk_widget_show (optionmenu2);
-  gtk_table_attach (GTK_TABLE (table1), optionmenu2, 1, 2, 4, 5,
-                    (GtkAttachOptions) (GTK_FILL),
-                    (GtkAttachOptions) (0), 0, 0);
-
-  menu2 = gtk_menu_new ();
-
-  fastest__no_chroma_partial_luma_1 = gtk_menu_item_new_with_mnemonic (_(&quot;Fastest (no chroma,partial luma)&quot;));
-  gtk_widget_show (fastest__no_chroma_partial_luma_1);
-  gtk_container_add (GTK_CONTAINER (menu2), fastest__no_chroma_partial_luma_1);
-
-  fast__partial_luma_and_chroma_1 = gtk_menu_item_new_with_mnemonic (_(&quot;Fast (partial luma and chroma)&quot;));
-  gtk_widget_show (fast__partial_luma_and_chroma_1);
-  gtk_container_add (GTK_CONTAINER (menu2), fast__partial_luma_and_chroma_1);
-
-  medium__full_luma_not_chroma_1 = gtk_menu_item_new_with_mnemonic (_(&quot;Medium (full luma not chroma)&quot;));
-  gtk_widget_show (medium__full_luma_not_chroma_1);
-  gtk_container_add (GTK_CONTAINER (menu2), medium__full_luma_not_chroma_1);
-
-  slow__full_luma_and_chroma_1 = gtk_menu_item_new_with_mnemonic (_(&quot;Slow (full luma and chroma)&quot;));
-  gtk_widget_show (slow__full_luma_and_chroma_1);
-  gtk_container_add (GTK_CONTAINER (menu2), slow__full_luma_and_chroma_1);
-
-  gtk_option_menu_set_menu (GTK_OPTION_MENU (optionmenu2), menu2);
-
-  dialog_action_area1 = GTK_DIALOG (dialog1)-&gt;action_area;
-  gtk_widget_show (dialog_action_area1);
-  gtk_button_box_set_layout (GTK_BUTTON_BOX (dialog_action_area1), GTK_BUTTONBOX_END);
-
-  cancelbutton1 = gtk_button_new_from_stock (&quot;gtk-cancel&quot;);
-  gtk_widget_show (cancelbutton1);
-  gtk_dialog_add_action_widget (GTK_DIALOG (dialog1), cancelbutton1, GTK_RESPONSE_CANCEL);
-  GTK_WIDGET_SET_FLAGS (cancelbutton1, GTK_CAN_DEFAULT);
-
-  okbutton1 = gtk_button_new_from_stock (&quot;gtk-ok&quot;);
-  gtk_widget_show (okbutton1);
-  gtk_dialog_add_action_widget (GTK_DIALOG (dialog1), okbutton1, GTK_RESPONSE_OK);
-  GTK_WIDGET_SET_FLAGS (okbutton1, GTK_CAN_DEFAULT);
-/*
-  g_signal_connect ((gpointer) discard_closer1, &quot;activate&quot;,
-                    G_CALLBACK (on_discard_closer1_activate),
-                    NULL);
-  g_signal_connect ((gpointer) replace_by_interpolate1, &quot;activate&quot;,
-                    G_CALLBACK (on_replace_by_interpolate1_activate),
-                    NULL);
-  g_signal_connect ((gpointer) discard_from_longest_dups__anim__s_1, &quot;activate&quot;,
-                    G_CALLBACK (on_discard_from_longest_dups__anim__s_1_activate),
-                    NULL);
-  g_signal_connect ((gpointer) pulldown_dups_removal1, &quot;activate&quot;,
-                    G_CALLBACK (on_pulldown_dups_removal1_activate),
-                    NULL);
-  g_signal_connect ((gpointer) fastest__no_chroma_partial_luma_1, &quot;activate&quot;,
-                    G_CALLBACK (on_fastest__no_chroma_partial_luma_1_activate),
-                    NULL);
-  g_signal_connect ((gpointer) fast__partial_luma_and_chroma_1, &quot;activate&quot;,
-                    G_CALLBACK (on_fast__partial_luma_and_chroma_1_activate),
-                    NULL);
-  g_signal_connect ((gpointer) medium__full_luma_not_chroma_1, &quot;activate&quot;,
-                    G_CALLBACK (on_medium__full_luma_not_chroma_1_activate),
-                    NULL);
-  g_signal_connect ((gpointer) slow__full_luma_and_chroma_1, &quot;activate&quot;,
-                    G_CALLBACK (on_slow__full_luma_and_chroma_1_activate),
-                    NULL);
-*/
-  /* Store pointers to all widgets, for use by lookup_widget(). */
-  GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog1, &quot;dialog1&quot;);
-  GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog_vbox1, &quot;dialog_vbox1&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, table1, &quot;table1&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, label1, &quot;label1&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, spinbuttonCycle, &quot;spinbuttonCycle&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, label2, &quot;label2&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, optionmenu1, &quot;optionmenu1&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, menu1, &quot;menu1&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, discard_closer1, &quot;discard_closer1&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, replace_by_interpolate1, &quot;replace_by_interpolate1&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, discard_from_longest_dups__anim__s_1, &quot;discard_from_longest_dups__anim__s_1&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, pulldown_dups_removal1, &quot;pulldown_dups_removal1&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, label3, &quot;label3&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, entryThresh, &quot;entryThresh&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, label4, &quot;label4&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, entry2, &quot;entry2&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, label5, &quot;label5&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, optionmenu2, &quot;optionmenu2&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, menu2, &quot;menu2&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, fastest__no_chroma_partial_luma_1, &quot;fastest__no_chroma_partial_luma_1&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, fast__partial_luma_and_chroma_1, &quot;fast__partial_luma_and_chroma_1&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, medium__full_luma_not_chroma_1, &quot;medium__full_luma_not_chroma_1&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, slow__full_luma_and_chroma_1, &quot;slow__full_luma_and_chroma_1&quot;);
-  GLADE_HOOKUP_OBJECT_NO_REF (dialog1, dialog_action_area1, &quot;dialog_action_area1&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, cancelbutton1, &quot;cancelbutton1&quot;);
-  GLADE_HOOKUP_OBJECT (dialog1, okbutton1, &quot;okbutton1&quot;);
-
-  return dialog1;
-}
-

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_dectel.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_dectel.cpp	2007-01-13 12:08:21 UTC (rev 2720)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_dectel.cpp	2007-01-13 16:37:32 UTC (rev 2721)
@@ -30,7 +30,7 @@
 #include &quot;ADM_toolkit/toolkit.hxx&quot;
 
 
-#include &quot;ADM_video/ADM_vidDecTel_param.h&quot;
+#include &quot;ADM_videoFilter/ADM_vidDecTel_param.h&quot;
 #define MENU_SET(x,y) { gtk_option_menu_set_history (GTK_OPTION_MENU(WID(x)),param-&gt;y);}
 #define MENU_GET(x,y) { param-&gt;y	= getRangeInMenu(WID(x));}
 

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/Makefile.am
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/Makefile.am	2007-01-13 12:08:21 UTC (rev 2720)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/Makefile.am	2007-01-13 16:37:32 UTC (rev 2721)
@@ -15,7 +15,7 @@
 	DIA_postproc.cpp DIA_enter.cpp DIA_enter.h DIA_xvcd.cpp DIA_muxer.cpp \
 	DIA_xvid.cpp DIA_crop.cpp DIA_color.cpp DIA_encoding.cpp DIA_SVCD.cpp DIA_prefs.cpp \
 	DIA_requant.cpp DIA_xvid4.cpp DIA_lavcodec.cpp \
-	DIA_dectel.cpp DIA_decimate.cpp DIA_pause.cpp \
+	DIA_dectel.cpp DIA_pause.cpp \
 	DIA_DVDff.cpp DIA_lavdecoder.cpp DIA_lame.cpp DIA_calculator.cpp DIA_equalizer.cpp \
 	DIA_vobsub.cpp DIA_x264.cpp DIA_ocr.cpp  DIA_hue.cpp DIA_eq2.cpp \
 	DIA_asharp.cpp DIA_dmx.cpp DIA_idx_pg.cpp DIA_gototime.cpp \
@@ -48,7 +48,7 @@
 DIA_acodec.cpp       DIA_crop.cpp          DIA_gototime.cpp     DIA_muxer.cpp       DIA_v2v.cpp \
 DIA_animated.cpp     DIA_hue.cpp          DIA_ocr.cpp         DIA_vcodec.cpp \
 DIA_asharp.cpp       DIA_idx_pg.cpp       DIA_partial.cpp     DIA_vobsub.cpp \
-DIA_audio.cpp        DIA_decimate.cpp      DIA_idx_pg.h         DIA_pause.cpp       DIA_vorbis.cpp \
+DIA_audio.cpp        DIA_idx_pg.h         DIA_pause.cpp       DIA_vorbis.cpp \
 DIA_audioTrack.cpp   DIA_dectel.cpp        DIA_indexer.cpp      DIA_pipe.cpp        DIA_working.cpp \
 DIA_defaultAudio.cpp  DIA_jobs.cpp         DIA_postproc.cpp    DIA_working.h \
 DIA_jobs_save.cpp    DIA_prefs.cpp       DIA_x264.cpp \

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_NONE/ADM_dialog/DIA_none.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_NONE/ADM_dialog/DIA_none.cpp	2007-01-13 12:08:21 UTC (rev 2720)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_NONE/ADM_dialog/DIA_none.cpp	2007-01-13 16:37:32 UTC (rev 2721)
@@ -38,8 +38,6 @@
 #include &quot;ADM_audiofilter/audiofilter_normalize_param.h&quot;
 #include &quot;ADM_video/ADM_vidCNR2_param.h&quot;
 #include &quot;ADM_video/ADM_vidColorYuv_param.h&quot;
-#include &quot;ADM_video/ADM_vidDecDec_param.h&quot;
-#include &quot;ADM_video/ADM_vidDecTel_param.h&quot;
 #include &quot;ADM_audiofilter/audioencoder_lame_param.h&quot;
 #include &quot;ADM_audiofilter/audioencoder_lame_param.h&quot;
 #include &quot;ADM_encoder/adm_encmjpeg_param.h&quot;
@@ -92,8 +90,6 @@
 uint8_t DIA_cnr2(CNR2Param *param){return 0;}
 uint8_t DIA_DVDffParam(COMPRES_PARAMS *incoming){return 0;}
 uint8_t DIA_getASharp(ASHARP_PARAM *param, AVDMGenericVideoStream *in){return 0;}
-uint8_t DIA_getDecombDecimate(DECIMATE_PARAM *param){return 0;}
-uint8_t DIA_getDecombTelecide(TelecideParam *param){return 0;}
 uint8_t DIA_getEQ2Param(Eq2_Param *param, AVDMGenericVideoStream *in){return 0;}
 uint8_t DIA_getEqualizer(EqualizerParam *param, ADMImage *image){return 0;}
 uint8_t DIA_getEqualizer(EqualizerParam *param, AVDMGenericVideoStream *in){return 0;}

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/DIA_none.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/DIA_none.cpp	2007-01-13 12:08:21 UTC (rev 2720)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/DIA_none.cpp	2007-01-13 16:37:32 UTC (rev 2721)
@@ -38,8 +38,6 @@
 #include &quot;ADM_audiofilter/audiofilter_normalize_param.h&quot;
 #include &quot;ADM_video/ADM_vidCNR2_param.h&quot;
 #include &quot;ADM_video/ADM_vidColorYuv_param.h&quot;
-#include &quot;ADM_video/ADM_vidDecDec_param.h&quot;
-#include &quot;ADM_video/ADM_vidDecTel_param.h&quot;
 #include &quot;ADM_audiofilter/audioencoder_lame_param.h&quot;
 #include &quot;ADM_audiofilter/audioencoder_lame_param.h&quot;
 #include &quot;ADM_encoder/adm_encmjpeg_param.h&quot;
@@ -92,8 +90,6 @@
 uint8_t DIA_cnr2(CNR2Param *param){return 0;}
 uint8_t DIA_DVDffParam(COMPRES_PARAMS *incoming){return 0;}
 uint8_t DIA_getASharp(ASHARP_PARAM *param, AVDMGenericVideoStream *in){return 0;}
-uint8_t DIA_getDecombDecimate(DECIMATE_PARAM *param){return 0;}
-uint8_t DIA_getDecombTelecide(TelecideParam *param){return 0;}
 uint8_t DIA_getEQ2Param(Eq2_Param *param, AVDMGenericVideoStream *in){return 0;}
 uint8_t DIA_getEqualizer(EqualizerParam *param, ADMImage *image){return 0;}
 uint8_t DIA_getEqualizer(EqualizerParam *param, AVDMGenericVideoStream *in){return 0;}

Modified: branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidAsharp.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidAsharp.cpp	2007-01-13 12:08:21 UTC (rev 2720)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidAsharp.cpp	2007-01-13 16:37:32 UTC (rev 2721)
@@ -37,7 +37,6 @@
 #include &quot;ADM_toolkit/toolkit.hxx&quot;
 #include &quot;ADM_editor/ADM_edit.hxx&quot;
 #include &quot;ADM_video/ADM_genvideo.hxx&quot;
-#include&quot;ADM_video/ADM_vidField.h&quot;
 #include&quot;ADM_video/ADM_cache.h&quot;
 
 #include &quot;ADM_osSupport/ADM_debugID.h&quot;

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidBlend.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidBlend.cpp	2007-01-13 12:08:21 UTC (rev 2720)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidBlend.cpp	2007-01-13 16:37:32 UTC (rev 2721)
@@ -1,187 +0,0 @@
-/***************************************************************************
-                          ADM_vidBlend.cpp  -  description
-                             -------------------
-    begin                : Tue Jan 7 2003
-    copyright            : (C) 2003 by mean
-    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
-
-    Slighlty faster ASM deinterlace
-    Blend later
-
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#include &lt;stdio.h&gt;
-#include &lt;stdlib.h&gt;
-#include &lt;string.h&gt;
-#include &lt;ADM_assert.h&gt;
-
-#include &quot;config.h&quot;
-#include &quot;fourcc.h&quot;
-#include &quot;avio.hxx&quot;
-#include &quot;config.h&quot;
-#include &quot;avi_vars.h&quot;
-
-
-
-#include &quot;ADM_toolkit/toolkit.hxx&quot;
-#include &quot;ADM_editor/ADM_edit.hxx&quot;
-#include &quot;ADM_video/ADM_genvideo.hxx&quot;
-
-#include&quot;ADM_video/ADM_vidField.h&quot;
-
-#include &quot;admmangle.h&quot;
-
-
- static int32_t _l_w,_l_h;
- static uint8_t *_l_p,*_l_c,*_l_n;
- static uint8_t *_l_e,*_l_e2;
-#define EXPAND(x) (x)+((x)&lt;&lt;16)+((x)&lt;&lt;32) +((x)&lt;&lt;48)
-static uint64_t  __attribute__((used)) _mmTHRESH1=EXPAND((uint64_t )THRES1);
-static uint64_t  __attribute__((used)) full_ones=0xFFFFFFFFFFFFFFFFLL;
-
-
-static void myBlendASM(void);
-
-void ADMVideoFields::blend_C(uint8_t *p,uint8_t *c,
-							uint8_t *n,
-							uint8_t *e,
-							uint8_t *f
-							)
-{
-uint32_t x,y;
- for(y=_info.height-2;y&gt;0;y--)
-           	{
-              for(x=_info.width;x&gt;0;x--)
-              {
-
-                    if(*e)
-                    	{
-                       	*f=(*c&gt;&gt;1) + ((*n+*p)&gt;&gt;2);
-                       //	*f=255;
-
-                       }
-                       else
-                       		*f=*c;
-						//			*f=0;
-
-                       c++;n++;p++;e++;f++;
-                 }
-              }
-}
-#if defined( ARCH_X86)  || defined(ARCH_X86_64)
-void ADMVideoFields::blend_MMX(uint8_t *p,uint8_t *c,
-																							uint8_t *n,
-																							uint8_t *e,
-																							uint8_t *f
-																							)
-{
-      _l_h=_info.height-2;
-			_l_w=_info.width&gt;&gt;2;
-			_l_p=p;
-			_l_c=c;
-			_l_n=n;
-			_l_e=e;
-			_l_e2=f;
-			myBlendASM();
-}
-
-void myBlendASM(void)
-{
-	__asm__ (
-//&quot;StartASM4: \n\t&quot;
-&quot;push 				&quot;REG_di&quot;\n\t&quot;
-&quot;push 				&quot;REG_si&quot;\n\t&quot;
-&quot;push 				&quot;REG_ax&quot;\n\t&quot;
-
-&quot;mov (%0), &quot;REG_ax&quot; \n\t&quot;
-&quot;mov &quot;Mangle(_l_p)&quot;, &quot;REG_ax&quot; \n\t&quot;
-&quot;mov &quot;Mangle(_l_c)&quot;, &quot;REG_bx&quot; \n\t&quot;
-&quot;mov &quot;Mangle(_l_n)&quot;, &quot;REG_cx&quot; \n\t&quot;
-&quot;mov &quot;Mangle(_l_e)&quot;, &quot;REG_si&quot; \n\t&quot;
-&quot;mov &quot;Mangle(_l_e2)&quot;, &quot;REG_di&quot; \n\t&quot;
-&quot;movq &quot;Mangle(full_ones)&quot;,%%mm7 \n\t&quot;
-&quot;pxor	   %%mm6,%%mm6 \n\t&quot;
-
-&quot;DHCOLB%=: \n\t&quot; // loop
-&quot;mov &quot;Mangle(_l_w)&quot;, &quot;REG_dx&quot; \n\t&quot;                // loop one line
-
-&quot;DHLineB%=:  \n\t&quot;
-
-&quot;movd (&quot;REG_bx&quot;),%%mm0 \n\t&quot;     // mm0 &lt;- c
-&quot;movd (&quot;REG_ax&quot;),%%mm1 \n\t&quot;     // mm1 &lt;- p
-&quot;movd (&quot;REG_cx&quot;),%%mm2 \n\t&quot;     // mm2 &lt;- n
-&quot;movd (&quot;REG_si&quot;),%%mm3 \n\t&quot;     // mm2 &lt;- e
-
-
-&quot;punpcklbw %%mm6, %%mm0 \n\t&quot;
-&quot;punpcklbw %%mm6, %%mm1 \n\t&quot;
-&quot;punpcklbw %%mm6, %%mm2 \n\t&quot;
-&quot;punpcklbw %%mm6, %%mm3 \n\t&quot;
-&quot;movq      %%mm6, %%mm4 \n\t&quot;
-
-//&quot;movq %%mm3,S0 \n\t&quot;
-
-// make 16 bits mask
-&quot;psllw     $8, %%mm4 \n\t&quot;
-&quot;por	   %%mm4,%%mm3 \n\t&quot;  // mask in m3
-//&quot;movq %%mm3,S1 \n\t&quot;
-//&quot;movq %%mm2,S2 \n\t&quot;
-//&quot;movq %%mm1,S3 \n\t&quot;
-
-
-// compute average of p &amp; n in mm4
-&quot;paddw     %%mm1,%%mm2 \n\t&quot;
-&quot;paddw     %%mm0,%%mm2 \n\t&quot;
-&quot;paddw     %%mm0,%%mm2 \n\t&quot;
-//&quot;movq 	   %%mm2,S4 \n\t&quot;
-
-&quot;psrlw     $2,%%mm2 \n\t&quot;     //mm2 is averafe of p &amp; n &amp; c -&gt; replacement value
-//&quot;movq      %%mm2,S5 \n\t&quot;
-
-&quot;pand     %%mm3,%%mm2 \n\t&quot;
-//&quot;movq     %%mm2,S6 \n\t&quot;
-
-// compute inverse value
-&quot;pxor     %%mm7,%%mm3 \n\t&quot; // inverse mask in m3
-//&quot;movq     %%mm3,S7 \n\t&quot;
-
-&quot;pand     %%mm3,%%mm0 \n\t&quot; // right value in m0
-//&quot;movq     %%mm0,S8 \n\t&quot;
-
-&quot;por     %%mm2,%%mm0 \n\t&quot; // ok, now right
-//&quot;movq     %%mm0,S9 \n\t&quot;
-
-&quot;packuswb  %%mm6, %%mm0 \n\t&quot;          // pack
-//&quot;movq %%mm0,S10 \n\t&quot;
-
-&quot;movd	   %%mm0, (&quot;REG_di&quot;) \n\t&quot; // store
-
-//
-//
-// next
-&quot;add       $4,&quot;REG_ax&quot; \n\t&quot;
-&quot;add       $4,&quot;REG_bx&quot; \n\t&quot;
-&quot;add       $4,&quot;REG_cx&quot; \n\t&quot;
-&quot;add       $4,&quot;REG_si&quot; \n\t&quot;
-&quot;add       $4,&quot;REG_di&quot; \n\t&quot;
-&quot;sub       $1,&quot;REG_dx&quot;	\n\t&quot;
-&quot;jne        DHLineB%= \n\t&quot;   // next
-&quot;sub       $1,&quot;Mangle(_l_h)&quot;  \n\t&quot; // next line
-&quot;jne        DHCOLB%= \n\t&quot;
-&quot;pop 				&quot;REG_ax&quot;\n\t&quot;
-&quot;pop 				&quot;REG_si&quot;\n\t&quot;
-&quot;pop 				&quot;REG_di&quot;\n\t&quot;
-&quot; emms       \n\t&quot;
- : /* no output */
- :  &quot;r&quot;(&amp;_mmTHRESH1)
- :   &quot;ebx&quot;, &quot;ecx&quot;, &quot;edx&quot;);
-}
-#endif

Modified: branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidColorYuv.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidColorYuv.cpp	2007-01-13 12:08:21 UTC (rev 2720)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidColorYuv.cpp	2007-01-13 16:37:32 UTC (rev 2721)
@@ -59,7 +59,6 @@
 #include &quot;ADM_toolkit/toolkit.hxx&quot;
 #include &quot;ADM_editor/ADM_edit.hxx&quot;
 #include &quot;ADM_video/ADM_genvideo.hxx&quot;
-#include&quot;ADM_video/ADM_vidField.h&quot;
 
 #include &quot;ADM_osSupport/ADM_debugID.h&quot;
 #define MODULE_NAME MODULE_FILTER

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidDecDec.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidDecDec.cpp	2007-01-13 12:08:21 UTC (rev 2720)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidDecDec.cpp	2007-01-13 16:37:32 UTC (rev 2721)
@@ -1,1626 +0,0 @@
-/***************************************************************************
-                          ADM_vidDecTelecide  -  description
-                             -------------------
-    
-    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
-
-    Port of Donal Graft Decimate which is (c) Donald Graft
-    <A HREF="http://www.neuron2.net">http://www.neuron2.net</A>
-    <A HREF="http://puschpull.org/avisynth/decomb_reference_manual.html">http://puschpull.org/avisynth/decomb_reference_manual.html</A>
-
- ***************************************************************************/
-
-/*
-	Decimate plugin for Avisynth -- performs 1-in-N
-	decimation on a stream of progressive frames, which are usually
-	obtained from the output of my Telecide plugin for Avisynth.
-	For each group of N successive frames, this filter deletes the
-	frame that is most similar to its predecessor. Thus, duplicate
-	frames coming out of Telecide can be removed using Decimate. This
-	filter adjusts the frame rate of the clip as
-	appropriate. Selection of the cycle size is selected by specifying
-	a parameter to Decimate() in the Avisynth scipt.
-
-	Copyright (C) 2003 Donald A. Graft
-
-	This program is free software; you can redistribute it and/or modify
-	it under the terms of the GNU General Public License as published by
-	the Free Software Foundation.
-
-	This program is distributed in the hope that it will be useful,
-	but WITHOUT ANY WARRANTY; without even the implied warranty of
-	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-	GNU General Public License for more details.
-
-	You should have received a copy of the GNU General Public License
-	along with this program; if not, write to the Free Software
-	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
-
-	The author can be contacted at:
-	Donald Graft
-	<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">neuron2 at attbi.com.</A>
-*/
-#include &quot;config.h&quot;
-#include &lt;stdio.h&gt;
-#include &lt;stdlib.h&gt;
-#include &lt;string.h&gt;
-#include &lt;ADM_assert.h&gt;
-
-#include &quot;config.h&quot;
-#include &quot;fourcc.h&quot;
-#include &quot;avio.hxx&quot;
-#include &quot;avi_vars.h&quot;
-
-#include &quot;ADM_toolkit/toolkit.hxx&quot;
-#include &quot;ADM_editor/ADM_edit.hxx&quot;
-#include &quot;ADM_video/ADM_genvideo.hxx&quot;
-#include&quot;ADM_video/ADM_vidField.h&quot;
-#include&quot;ADM_video/ADM_cache.h&quot;
-
-#include &quot;ADM_osSupport/ADM_debugID.h&quot;
-#define MODULE_NAME MODULE_FILTER
-#include &quot;ADM_osSupport/ADM_debug.h&quot;
-
-#include &quot;ADM_osSupport/ADM_cpuCap.h&quot;
-#define PROGRESSIVE  0x00000001
-#define MAGIC_NUMBER (0xdeadbeef)
-#define IN_PATTERN   0x00000002
-
-extern uint8_t 	PutHintingData(unsigned char *video, unsigned int hint);
-extern uint8_t 	GetHintingData(unsigned char *video, unsigned int *hint);
-extern void 	BitBlt(uint8_t * dstp, int dst_pitch, const uint8_t* srcp,
-            		int src_pitch, int row_size, int height);
-
-#define DrawString drawString
-
-#ifdef USE_SSE
-	#define DECIMATE_MMX_BUILD_PLANE 1
-	#define DECIMATE_MMX_BUILD	 1
-#endif
-
-#ifdef DECIMATE_MMX_BUILD_PLANE
-static void isse_blend_decimate_plane(uint8_t * dst, uint8_t* src,  uint8_t* src_next, 
-			int w, int h);
-int isse_scenechange_32(const uint8_t *c_plane,const  uint8_t *tplane, int height, int width) ;	
-int isse_scenechange_16(const uint8_t *c_plane,const  uint8_t *tplane, int height, int width) ;
-int isse_scenechange_8(const uint8_t *c_plane,const  uint8_t *tplane, int height, int width) ;
-#endif
-
-
-#define OutputDebugString(x) aprintf(&quot;%s\n&quot;,x)
-//________________________________
-#define MAX_CYCLE_SIZE 25
-#define MAX_BLOCKS 50
-
-#define GETFRAME(g, fp) \
-{ \
-	int GETFRAMEf; \
-	GETFRAMEf = (g); \
-	if (GETFRAMEf &lt; 0) GETFRAMEf = 0; \
-	if (GETFRAMEf &gt; num_frames_hi - 1) GETFRAMEf = num_frames_hi - 1; \
-	(fp) = vidCache-&gt;getImage(GETFRAMEf); \
-}
-//________________________________
-#include &quot;ADM_vidDecDec_param.h&quot;
-#include &quot;ADM_filter/video_filters.h&quot;
-
-
-static FILTER_PARAM decdecParam={5,{&quot;cycle&quot;,&quot;mode&quot;,&quot;quality&quot;,&quot;threshold&quot;,&quot;threshold2&quot;}};
-
-
-
-
-extern uint8_t DIA_getDecombDecimate(DECIMATE_PARAM *param);
-
-#define BLKSIZE 32
-//________________________________
-/* Decimate 1-in-N implementation. */
-class Decimate : public AVDMGenericVideoStream
-{
-	int 			num_frames_hi;
-	
-	DECIMATE_PARAM 		*_param;
-	
-	int last_request, last_result;
-	bool last_forced;
-	double last_metric;
-	double metrics[MAX_CYCLE_SIZE];
-	double showmetrics[MAX_CYCLE_SIZE];
-	int Dprev[MAX_CYCLE_SIZE];
-	int Dcurr[MAX_CYCLE_SIZE];
-	int Dnext[MAX_CYCLE_SIZE];
-	int Dshow[MAX_CYCLE_SIZE];
-	unsigned int hints[MAX_CYCLE_SIZE];
-	bool hints_invalid;
-	bool all_video_cycle;
-	bool firsttime;
-	int heightY, row_sizeY, pitchY;
-	int heightUV, row_sizeUV, pitchUV;
-	int pitch, row_size, height;
-	int xblocks, yblocks;
-	unsigned int *sum, div;
-	bool debug, show;
-	
-	VideoCache	*vidCache;
-	
-public:
-				
-			Decimate(AVDMGenericVideoStream *in,CONFcouple *couples);    
-			~Decimate(void);
-	uint8_t  	getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
-				ADMImage *data,uint32_t *flags);
-
-    	uint8_t   	*GetFrame(int n);
-	void   		DrawShow(ADMImage  *src, int useframe, bool forced, int dropframe,
-		                              double metric, int inframe );
-        void   		FindDuplicate(int frame, int *chosen, double *metric, bool *forced   );
-    	void   		FindDuplicate2(int frame, int *chosen, bool *forced );
-    	void   		FindDuplicateYUY2(int frame, int *chosen, double *metric, bool *force);
-    	void   		FindDuplicate2YUY2(int frame, int *chosen, bool *forced );
-	
-	char 		*printConf( void );
-	uint8_t 	configure(AVDMGenericVideoStream *in);
-	uint8_t		getCoupledConf( CONFcouple **couples);
-};
-
-
-
-BUILD_CREATE(decimate_create,Decimate);
-
-/*
-PClip _child, int _cycle, int _mode, double _threshold, double _threshold2,
-				int _quality, const char * _ovr, bool _show, bool _debug, IScriptEnvironment* env) 
-GenericVideoFilter(_child), cycle(_cycle), mode(_mode), threshold(_threshold),
-threshold2(_threshold2), quality(_quality), ovr(_ovr), show(_show), debug(_debug)
-*/	
-SCRIPT_CREATE(decimate_script,Decimate,decdecParam);
-uint8_t Decimate::configure(AVDMGenericVideoStream *in)
-{
-	_in=in;
-	ADM_assert(_param);
-	return  DIA_getDecombDecimate(_param);
-	
-}
-
-char *Decimate::printConf( void )
-{
- 	static char buf[50];
-
-	ADM_assert(_param);
- 	sprintf((char *)buf,&quot; Decomb Decimate cycle:%d&quot;,_param-&gt;cycle);
-        return buf;
-}
-
-
-Decimate::Decimate(AVDMGenericVideoStream *in,CONFcouple *couples)		
-{
-{
-		
-		int count = 0;
-		char buf[80];
-		unsigned int *p;
-
-		_in=in;		
-   		memcpy(&amp;_info,_in-&gt;getInfo(),sizeof(_info));    
-  		_info.encoding=1;
-		_uncompressed=NULL;		
-  		_info.encoding=1;
-		
-		//		
-		// Init here
-		debug=0;
-		show=0;		
-#ifdef USE_SSE	
-		if(CpuCaps::hasSSE())
-		{
-			printf(&quot;Decimate:SSE enabled\n&quot;);
-		}
-#endif
-		//
-		_param=new DECIMATE_PARAM;
-		if(couples)
-		{
-			GET(cycle);
-			GET(mode);
-			GET(quality);
-			GET(threshold);
-			GET(threshold2);
-			
-		}
-		else // Default
-  		{
-			_param-&gt;cycle=5;
-			_param-&gt;mode=0;
-			_param-&gt;quality=2;
-			_param-&gt;threshold=0;
-			_param-&gt;threshold2=3.0;
-		}
-		
-		ADM_assert(_param-&gt;cycle);
-		vidCache=new VideoCache(_param-&gt;cycle*2+1,in);
-		
-		if (_param-&gt;mode == 0 || _param-&gt;mode == 2 || _param-&gt;mode == 3)
-		{
-			num_frames_hi = _info.nb_frames;
-			_info.nb_frames = _info.nb_frames * (_param-&gt;cycle - 1) / _param-&gt;cycle;
-			_info.fps1000=_info.fps1000*(_param-&gt;cycle-1);
-			_info.fps1000=(uint32_t)(_info.fps1000/_param-&gt;cycle);
-			
-		}
-		last_request = -1;
-		firsttime = true;
-		sum = (unsigned int *) ADM_alloc(MAX_BLOCKS * MAX_BLOCKS * sizeof(unsigned int));
-		ADM_assert(sum);		
-		all_video_cycle = true;
-
-		if (debug)
-		{
-			char b[80];
-			sprintf(b, &quot;Decimate %s by Donald Graft, Copyright 2003\n&quot;, VERSION);
-			OutputDebugString(b);
-		}
-	}
-}
-//________________________________________________________
-uint8_t	Decimate::getCoupledConf( CONFcouple **couples)
-{
-	*couples=NULL;
-	*couples=new CONFcouple(5);
-#define CSET(x)  (*couples)-&gt;setCouple((char *)#x,(_param-&gt;x))
-	
-	CSET(cycle);
-	CSET(mode);
-	CSET(quality);
-	CSET(threshold);
-	CSET(threshold2);
-
-	return 1;
-}
-//________________________________________________________
-Decimate::~Decimate(void)
-{
-		if (sum != NULL) ADM_dealloc(sum);
-		if(vidCache) delete vidCache;
-		if(_param) delete _param;
-
-		vidCache=NULL;
-		_param=NULL;
-		sum=NULL;
-}
-//________________________________________________________
-void Decimate::DrawShow(ADMImage  *src, int useframe, bool forced, int dropframe,
-						double metric, int inframe)
-{
-	char buf[80];
-	int start = (useframe / _param-&gt;cycle) * _param-&gt;cycle;
-
-	if (show == true)
-	{
-		sprintf(buf, &quot;Decimate %s&quot;, VERSION);
-		DrawString(src, 0, 0, buf);
-		sprintf(buf, &quot;Copyright 2003 Donald Graft&quot;);
-		DrawString(src, 0, 1, buf);
-		sprintf(buf,&quot;%d: %3.2f&quot;, start, showmetrics[0]);
-		DrawString(src, 0, 3, buf);
-		sprintf(buf,&quot;%d: %3.2f&quot;, start + 1, showmetrics[1]);
-		DrawString(src, 0, 4, buf);
-		sprintf(buf,&quot;%d: %3.2f&quot;, start + 2, showmetrics[2]);
-		DrawString(src, 0, 5, buf);
-		sprintf(buf,&quot;%d: %3.2f&quot;, start + 3, showmetrics[3]);
-		DrawString(src, 0, 6, buf);
-		sprintf(buf,&quot;%d: %3.2f&quot;, start + 4, showmetrics[4]);
-		DrawString(src, 0, 7, buf);
-		if (all_video_cycle == false)
-		{
-			sprintf(buf,&quot;in frm %d, use frm %d&quot;, inframe, useframe);
-			DrawString(src, 0, 8, buf);
-			if (forced == false)
-				sprintf(buf,&quot;chose %d, dropping&quot;, dropframe);
-			else
-				sprintf(buf,&quot;chose %d, dropping, forced!&quot;, dropframe);
-			DrawString(src, 0, 9, buf);
-		}
-		else
-		{
-			sprintf(buf,&quot;in frm %d&quot;, inframe);
-			DrawString(src, 0, 8, buf);
-			sprintf(buf,&quot;chose %d, decimating all-video cycle&quot;, dropframe);
-			DrawString(src, 0, 9, buf);
-		}
-	}
-	if (debug)
-	{
-		if (!(inframe%_param-&gt;cycle))
-		{
-			sprintf(buf,&quot;Decimate: %d: %3.2f\n&quot;, start, showmetrics[0]);
-			OutputDebugString(buf);
-			sprintf(buf,&quot;Decimate: %d: %3.2f\n&quot;, start + 1, showmetrics[1]);
-			OutputDebugString(buf);
-			sprintf(buf,&quot;Decimate: %d: %3.2f\n&quot;, start + 2, showmetrics[2]);
-			OutputDebugString(buf);
-			sprintf(buf,&quot;Decimate: %d: %3.2f\n&quot;, start + 3, showmetrics[3]);
-			OutputDebugString(buf);
-			sprintf(buf,&quot;Decimate: %d: %3.2f\n&quot;, start + 4, showmetrics[4]);
-			OutputDebugString(buf);
-		}
-		if (all_video_cycle == false)
-		{
-			sprintf(buf,&quot;Decimate: in frm %d useframe %d\n&quot;, inframe, useframe);
-			OutputDebugString(buf);
-			if (forced == false)
-				sprintf(buf,&quot;Decimate: chose %d, dropping\n&quot;, dropframe);
-			else
-				sprintf(buf,&quot;Decimate: chose %d, dropping, forced!\n&quot;, dropframe);
-			OutputDebugString(buf);
-		}
-		else
-		{
-			sprintf(buf,&quot;Decimate: in frm %d\n&quot;, inframe);
-			OutputDebugString(buf);
-			sprintf(buf,&quot;Decimate: chose %d, decimating all-video cycle\n&quot;, dropframe);
-			OutputDebugString(buf);
-		}
-	}
-}
-//______________________________________________________________________
-uint8_t Decimate::getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
-				ADMImage *data,uint32_t *flags)
-{
-	int dropframe, useframe, nextfrm, wY, wUV, hY, hUV, x, y, pitchY, pitchUV, dpitchY, dpitchUV;
-	ADMImage  *src, *next, *dst;
-	unsigned char *srcrpY, *nextrpY, *dstwpY;
-	unsigned char *srcrpU, *nextrpU, *dstwpU;
-	unsigned char *srcrpV, *nextrpV, *dstwpV;
-	uint32_t inframe=frame;
-	double metric;
-	char buf[255];
-
-	*len=(_info.width*_info.height*3)&gt;&gt;1;
-	num_frames_hi = _in-&gt;getInfo()-&gt;nb_frames; /* FIXME MEANX */
-	if (_param-&gt;mode == 0)
-	{
-		bool forced = false;
-		int start;
-
-		/* Normal decimation. Remove the frame most similar to its preceding frame. */
-		/* Determine the correct frame to use and get it. */
-		useframe = inframe + inframe / (_param-&gt;cycle - 1);
-		start = (useframe /  _param-&gt;cycle) * _param-&gt;cycle;
-		FindDuplicate((useframe / _param-&gt;cycle) * _param-&gt;cycle, &amp;dropframe, &amp;metric, &amp;forced);
-		if (useframe &gt;= dropframe) useframe++;
-		GETFRAME(useframe, src);
-		if (show == true)
-		{
-			sprintf(buf, &quot;Decimate %s&quot;, VERSION);
-			DrawString(src, 0, 0, buf);
-			sprintf(buf, &quot;Copyright 2003 Donald Graft&quot;);
-			DrawString(src, 0, 1, buf);
-			sprintf(buf,&quot;%d: %3.2f&quot;, start, showmetrics[0]);
-			DrawString(src, 0, 3, buf);
-			sprintf(buf,&quot;%d: %3.2f&quot;, start + 1, showmetrics[1]);
-			DrawString(src, 0, 4, buf);
-			sprintf(buf,&quot;%d: %3.2f&quot;, start + 2, showmetrics[2]);
-			DrawString(src, 0, 5, buf);
-			sprintf(buf,&quot;%d: %3.2f&quot;, start + 3, showmetrics[3]);
-			DrawString(src, 0, 6, buf);
-			sprintf(buf,&quot;%d: %3.2f&quot;, start + 4, showmetrics[4]);
-			DrawString(src, 0, 7, buf);
-			sprintf(buf,&quot;in frm %d, use frm %d&quot;, inframe, useframe);
-			DrawString(src, 0, 8, buf);
-			sprintf(buf,&quot;dropping frm %d%s&quot;, dropframe, last_forced == true ? &quot;, forced!&quot; : &quot;&quot;);
-			DrawString(src, 0, 9, buf);
-		}
-		if (debug)
-		{	
-			if (!(inframe % _param-&gt;cycle))
-			{
-				sprintf(buf,&quot;Decimate: %d: %3.2f\n&quot;, start, showmetrics[0]);
-				OutputDebugString(buf);
-				sprintf(buf,&quot;Decimate: %d: %3.2f\n&quot;, start + 1, showmetrics[1]);
-				OutputDebugString(buf);
-				sprintf(buf,&quot;Decimate: %d: %3.2f\n&quot;, start + 2, showmetrics[2]);
-				OutputDebugString(buf);
-				sprintf(buf,&quot;Decimate: %d: %3.2f\n&quot;, start + 3, showmetrics[3]);
-				OutputDebugString(buf);
-				sprintf(buf,&quot;Decimate: %d: %3.2f\n&quot;, start + 4, showmetrics[4]);
-				OutputDebugString(buf);
-			}
-			sprintf(buf,&quot;Decimate: in frm %d, use frm %d\n&quot;, inframe, useframe);
-			OutputDebugString(buf);
-			sprintf(buf,&quot;Decimate: dropping frm %d%s\n&quot;, dropframe, last_forced == true ? &quot;, forced!&quot; : &quot;&quot;);
-			OutputDebugString(buf);
-		}
-	    //return src;
-	        //memcpy(data,src,*len);
-
-		data-&gt;duplicate(src);
-		vidCache-&gt;unlockAll();
-		  
-		return 1;
-	}
-	else if (_param-&gt;mode == 1)
-	{
-		bool forced = false;
-		int start = (inframe / _param-&gt;cycle) * _param-&gt;cycle;
-		unsigned int hint, film = 1;
-
-		GETFRAME(inframe, src);
-	    	srcrpY = YPLANE(src); //(unsigned char *) src-&gt;GetReadPtr(PLANAR_Y);
-		if (GetHintingData(srcrpY, &amp;hint) == false)
-		{
-			film = hint &amp; PROGRESSIVE;
-//			if (film) OutputDebugString(&quot;film\n&quot;);
-//			else OutputDebugString(&quot;video\n&quot;);
-		}
-
-		/* Find the most similar frame as above but replace it with a blend of
-		   the preceding and following frames. */
-		num_frames_hi = _in-&gt;getInfo()-&gt;nb_frames; /* FIXME MEANX */
-		FindDuplicate((inframe / _param-&gt;cycle) * _param-&gt;cycle, &amp;dropframe, &amp;metric, &amp;forced);
-		if (!film || inframe != dropframe || (_param-&gt;threshold &amp;&amp; metric &gt; _param-&gt;threshold))
-		{
-			if (show == true)
-			{
-
-				sprintf(buf, &quot;Decimate %s&quot;, VERSION);
-				DrawString(src, 0, 0, buf);
-				sprintf(buf, &quot;Copyright 2003 Donald Graft&quot;);
-				DrawString(src, 0, 1, buf);
-				sprintf(buf,&quot;%d: %3.2f&quot;, start, showmetrics[0]);
-				DrawString(src, 0, 3, buf);
-				sprintf(buf,&quot;%d: %3.2f&quot;, start + 1, showmetrics[1]);
-				DrawString(src, 0, 4, buf);
-				sprintf(buf,&quot;%d: %3.2f&quot;, start + 2, showmetrics[2]);
-				DrawString(src, 0, 5, buf);
-				sprintf(buf,&quot;%d: %3.2f&quot;, start + 3, showmetrics[3]);
-				DrawString(src, 0, 6, buf);
-				sprintf(buf,&quot;%d: %3.2f&quot;, start + 4, showmetrics[4]);
-				DrawString(src, 0, 7, buf);
-				sprintf(buf,&quot;infrm %d&quot;, inframe);
-				DrawString(src, 0, 8, buf);
-				if (last_forced == false)
-					sprintf(buf,&quot;chose %d, passing through&quot;, dropframe);
-				else
-					sprintf(buf,&quot;chose %d, passing through, forced!&quot;, dropframe);
-				DrawString(src, 0, 9, buf);
-			}
-			if (debug)
-			{
-				if (!(inframe % _param-&gt;cycle))
-				{
-					sprintf(buf,&quot;Decimate: %d: %3.2f\n&quot;, start, showmetrics[0]);
-					OutputDebugString(buf);
-					sprintf(buf,&quot;Decimate: %d: %3.2f\n&quot;, start + 1, showmetrics[1]);
-					OutputDebugString(buf);
-					sprintf(buf,&quot;Decimate: %d: %3.2f\n&quot;, start + 2, showmetrics[2]);
-					OutputDebugString(buf);
-					sprintf(buf,&quot;Decimate: %d: %3.2f\n&quot;, start + 3, showmetrics[3]);
-					OutputDebugString(buf);
-					sprintf(buf,&quot;Decimate: %d: %3.2f\n&quot;, start + 4, showmetrics[4]);
-					OutputDebugString(buf);
-				}
-				sprintf(buf,&quot;Decimate: in frm %d\n&quot;, inframe);
-				OutputDebugString(buf);
-				if (last_forced == false)
-					sprintf(buf,&quot;Decimate: chose %d, passing through\n&quot;, dropframe);
-				else
-					sprintf(buf,&quot;Decimate: chose %d, passing through, forced!\n&quot;, dropframe);
-				OutputDebugString(buf);
-			}
-			//return src;
-			//memcpy(data,src,*len);
-
-			data-&gt;duplicate(src);
-			vidCache-&gt;unlockAll();
-			return 1;
-		}
-		if (inframe &lt; _in-&gt;getInfo()-&gt;nb_frames - 1) /* FIXME MEANX*/
-			nextfrm = inframe + 1;
-		else
-			nextfrm = _in-&gt;getInfo()-&gt;nb_frames - 1;
-		if (debug)
-		{
-			if (!(inframe % _param-&gt;cycle))
-			{
-				sprintf(buf,&quot;Decimate: %d: %3.2f\n&quot;, start, showmetrics[0]);
-				OutputDebugString(buf);
-				sprintf(buf,&quot;Decimate: %d: %3.2f\n&quot;, start + 1, showmetrics[1]);
-				OutputDebugString(buf);
-				sprintf(buf,&quot;Decimate: %d: %3.2f\n&quot;, start + 2, showmetrics[2]);
-				OutputDebugString(buf);
-				sprintf(buf,&quot;Decimate: %d: %3.2f\n&quot;, start + 3, showmetrics[3]);
-				OutputDebugString(buf);
-				sprintf(buf,&quot;Decimate: %d: %3.2f\n&quot;, start + 4, showmetrics[4]);
-				OutputDebugString(buf);
-			}
-			sprintf(buf,&quot;Decimate: in frm %d\n&quot;, inframe);
-			OutputDebugString(buf);
-			if (last_forced == false)
-				sprintf(buf,&quot;Decimate: chose %d, blending %d and %d\n&quot;, dropframe, inframe, nextfrm);
-			else
-				sprintf(buf,&quot;Decimate: chose %d, blending %d and %d, forced!\n&quot;, dropframe, inframe, nextfrm);
-			OutputDebugString(buf);
-		}
-		GETFRAME(nextfrm, next);
-		dst = data; //env-&gt;NewVideoFrame(vi);
-		pitchY = _info.width; //src-&gt;GetPitch(PLANAR_Y);
-		dpitchY = _info.width; //dst-&gt;GetPitch(PLANAR_Y);
-		wY = _info.width; //src-&gt;GetRowSize(PLANAR_Y);
-		hY = _info.height; //src-&gt;GetHeight(PLANAR_Y);
-		pitchUV = _info.width&gt;&gt;1;// src-&gt;GetPitch(PLANAR_V);
-		dpitchUV =_info.width&gt;&gt;1;// dst-&gt;GetPitch(PLANAR_V);
-		wUV = _info.width&gt;&gt;1;//src-&gt;GetRowSize(PLANAR_V);
-		hUV = _info.height&gt;&gt;1;//src-&gt;GetHeight(PLANAR_V);
-		
-		nextrpY = YPLANE(next); //next-&gt;GetReadPtr(PLANAR_Y);
-		dstwpY = YPLANE( dst); //dst-&gt;GetWritePtr(PLANAR_Y);
-#ifdef DECIMATE_MMX_BUILD_PLANE
-		if (CpuCaps::hasSSE()) 
-		{
-			isse_blend_decimate_plane(dstwpY, srcrpY, nextrpY, wY, hY);
-		} else {
-#endif
-			for (y = 0; y &lt; hY; y++)
-			{
-				for (x = 0; x &lt; wY; x++)
-				{
-					dstwpY[x] = ((int)srcrpY[x] + (int)nextrpY[x] ) &gt;&gt; 1;  
-				}
-				srcrpY += pitchY;
-				nextrpY += pitchY;
-				dstwpY += dpitchY;
-			}
-#ifdef DECIMATE_MMX_BUILD_PLANE
-		}
-#endif
-		srcrpU =   UPLANE(src);//-&gt;GetReadPtr(PLANAR_U);
-		nextrpU =   UPLANE(next);//-&gt;GetReadPtr(PLANAR_U);
-		dstwpU =  UPLANE(dst);//-&gt;GetWritePtr(PLANAR_U);
-#ifdef DECIMATE_MMX_BUILD_PLANE
-		if (CpuCaps::hasSSE()) 
-		{
-			isse_blend_decimate_plane(dstwpU, srcrpU, nextrpU, wUV, hUV);
-		} else {
-#endif
-			for (y = 0; y &lt; hUV; y++)
-			{
-				for (x = 0; x &lt; wUV; x++)
-				{
-					dstwpU[x] = ((int)srcrpU[x] + (int)nextrpU[x]) &gt;&gt; 1;
-				}
-				srcrpU += pitchUV;
-				nextrpU += pitchUV;
-				dstwpU += dpitchUV;
-			}
-#ifdef DECIMATE_MMX_BUILD_PLANE
-		}
-#endif
-		srcrpV =   VPLANE(src);//-&gt;GetReadPtr(PLANAR_V);
-		nextrpV =   VPLANE(next);//-&gt;GetReadPtr(PLANAR_V);
-		dstwpV =   VPLANE(dst);//-&gt;GetWritePtr(PLANAR_V);
-
-#ifdef DECIMATE_MMX_BUILD_PLANE
-		if (CpuCaps::hasSSE()) { 
-			isse_blend_decimate_plane(dstwpV, srcrpV, nextrpV, wUV, hUV );
-		} else {
-#endif
-			for (y = 0; y &lt; hUV; y++)
-			{
-				for (x = 0; x &lt; wUV; x++)
-				{
-					dstwpV[x] = ((int)srcrpV[x] + + (int)nextrpV[x]) &gt;&gt; 1;
-				}
-				srcrpV += pitchUV;
-				nextrpV += pitchUV;
-				dstwpV += dpitchUV;
-			}
-#ifdef DECIMATE_MMX_BUILD_PLANE
-		}
-#endif
-		if (show == true)
-		{
-
-			sprintf(buf, &quot;Decimate %s&quot;, VERSION);
-			DrawString(dst, 0, 0, buf);
-			sprintf(buf, &quot;Copyright 2003 Donald Graft&quot;);
-			DrawString(dst, 0, 1, buf);
-			sprintf(buf,&quot;%d: %3.2f&quot;, start, showmetrics[0]);
-			DrawString(dst, 0, 3, buf);
-			sprintf(buf,&quot;%d: %3.2f&quot;, start + 1, showmetrics[1]);
-			DrawString(dst, 0, 4, buf);
-			sprintf(buf,&quot;%d: %3.2f&quot;, start + 2, showmetrics[2]);
-			DrawString(dst, 0, 5, buf);
-			sprintf(buf,&quot;%d: %3.2f&quot;, start + 3, showmetrics[3]);
-			DrawString(dst, 0, 6, buf);
-			sprintf(buf,&quot;%d: %3.2f&quot;, start + 4, showmetrics[4]);
-			DrawString(dst, 0, 7, buf);
-			sprintf(buf,&quot;infrm %d&quot;, inframe);
-			DrawString(dst, 0, 8, buf);
-			if (last_forced == false)
-				sprintf(buf,&quot;chose %d, blending %d and %d&quot;,dropframe, inframe, nextfrm);
-			else
-				sprintf(buf,&quot;chose %d, blending %d and %d, forced!&quot;, dropframe, inframe, nextfrm);
-			DrawString(dst, 0, 9, buf);
-		}
-		//return dst;
-		//memcpy(data,dst,*len);
-
-		data-&gt;duplicate(dst);
-		vidCache-&gt;unlockAll();		
-		return 1;
-	}
-	else if (_param-&gt;mode == 2)
-	{
-		bool forced = false;
-
-		/* Delete the duplicate in the longest string of duplicates. */
-		useframe = inframe + inframe / (_param-&gt;cycle - 1);
-		FindDuplicate2((useframe / _param-&gt;cycle) * _param-&gt;cycle, &amp;dropframe, &amp;forced);
-		if (useframe &gt;= dropframe) useframe++;
-		GETFRAME(useframe, src);
-		if (show == true)
-		{
-			int start = (useframe / _param-&gt;cycle) * _param-&gt;cycle;
-
-
-			sprintf(buf, &quot;Decimate %s&quot;, VERSION);
-			DrawString(src, 0, 0, buf);
-			sprintf(buf, &quot;Copyright 2003 Donald Graft&quot;);
-			DrawString(src, 0, 1, buf);
-			sprintf(buf,&quot;in frm %d, use frm %d&quot;, inframe, useframe);
-			DrawString(src, 0, 3, buf);
-			sprintf(buf,&quot;%d: %3.2f (%s)&quot;, start, showmetrics[0],
-					Dshow[0] ? &quot;new&quot; : &quot;dup&quot;);
-			DrawString(src, 0, 4, buf);
-			sprintf(buf,&quot;%d: %3.2f (%s)&quot;, start + 1, showmetrics[1],
-					Dshow[1] ? &quot;new&quot; : &quot;dup&quot;);
-			DrawString(src, 0, 5, buf);
-			sprintf(buf,&quot;%d: %3.2f (%s)&quot;, start + 2, showmetrics[2],
-					Dshow[2] ? &quot;new&quot; : &quot;dup&quot;);
-			DrawString(src, 0, 6, buf);
-			sprintf(buf,&quot;%d: %3.2f (%s)&quot;, start + 3, showmetrics[3],
-					Dshow[3] ? &quot;new&quot; : &quot;dup&quot;);
-			DrawString(src, 0, 7, buf);
-			sprintf(buf,&quot;%d: %3.2f (%s)&quot;, start + 4, showmetrics[4],
-					Dshow[4] ? &quot;new&quot; : &quot;dup&quot;);
-			DrawString(src, 0, 8, buf);
-			sprintf(buf,&quot;Dropping frm %d%s&quot;, dropframe, last_forced == true ? &quot; forced!&quot; : &quot;&quot;);
-			DrawString(src, 0, 9, buf);
-		}
-		if (debug)
-		{	
-			sprintf(buf,&quot;Decimate: inframe %d useframe %d\n&quot;, inframe, useframe);
-			OutputDebugString(buf);
-		}
-	    //return src;
-	    	//memcpy(data,src,*len);
-
-		data-&gt;duplicate(src);
-		vidCache-&gt;unlockAll();
-		return 1;
-	}
-	else if (_param-&gt;mode == 3)
-	{
-		bool forced = false;
-
-		/* Decimate by removing a duplicate from film cycles and doing a
-		   blend rate conversion on the video cycles. */
-		if (_param-&gt;cycle != 5)//	env-&gt;ThrowError(&quot;Decimate: mode=3 requires cycle=5&quot;);
-		{
-			printf(&quot;Decimate: mode=3 requires cycle=5\n&quot;);
-			return 0;
-		}
-		useframe = inframe + inframe / (_param-&gt;cycle - 1);
-		FindDuplicate((useframe / _param-&gt;cycle) * _param-&gt;cycle, &amp;dropframe, &amp;metric, &amp;forced);
-		/* Use hints from Telecide about film versus video. Also use the difference
-		   metric of the most similar frame in the cycle; if it exceeds threshold,
-		   assume it's a video cycle. */
-		if (!(inframe % 4))
-		{
-			all_video_cycle = false;
-			if (_param-&gt;threshold &amp;&amp; metric &gt; _param-&gt;threshold)
-			{
-				all_video_cycle = true;
-			}
-			if ((hints_invalid == false) &amp;&amp;
-				(!(hints[0] &amp; PROGRESSIVE) ||
-				 !(hints[1] &amp; PROGRESSIVE) ||
-				 !(hints[2] &amp; PROGRESSIVE) ||
-				 !(hints[3] &amp; PROGRESSIVE) ||
-				 !(hints[4] &amp; PROGRESSIVE)))
-			{
-				all_video_cycle = true;
-			}
-		}
-		if (all_video_cycle == false)
-		{
-			/* It's film, so decimate in the normal way. */
-			if (useframe &gt;= dropframe) useframe++;
-			GETFRAME(useframe, src);
-			DrawShow(src, useframe, forced, dropframe, metric, inframe);			
-			//memcpy(data,src,*len);
-
-			data-&gt;duplicate(src);
-		
-			vidCache-&gt;unlockAll();		
-			return 1; // return src;
-		}
-		else if ((inframe % 4) == 0)
-		{
-			/* It's a video cycle. Output the first frame of the cycle. */
-			GETFRAME(useframe, src);
-			DrawShow(src, 0, forced, dropframe, metric, inframe);
-			//return src;
-			//memcpy(data,src,*len);
-
-			data-&gt;duplicate(src);
-		
-			vidCache-&gt;unlockAll();		
-			return 1; // return src;
-		}
-		else if ((inframe % 4) == 3)
-		{
-			/* It's a video cycle. Output the last frame of the cycle. */
-			GETFRAME(useframe+1, src);
-			DrawShow(src, 0, forced, dropframe, metric, inframe);
-			//return src;
-			//memcpy(data,src,*len);
-
-			data-&gt;duplicate(src);
-		
-			vidCache-&gt;unlockAll();		
-			return 1; // return src;
-		}
-		else if ((inframe % 4) == 1 || (inframe % 4) == 2)
-		{
-			/* It's a video cycle. Make blends for the remaining frames. */
-			if ((inframe % 4) == 1)
-			{
-				GETFRAME(useframe, src);
-				if (useframe &lt; num_frames_hi - 1)
-					nextfrm = useframe + 1;
-				else
-					nextfrm = _in-&gt;getInfo()-&gt;nb_frames - 1;
-				GETFRAME(nextfrm, next);
-			}
-			else
-			{
-				GETFRAME(useframe + 1, src);
-				nextfrm = useframe;
-				GETFRAME(nextfrm, next);
-			}
-			dst = data; //env-&gt;NewVideoFrame(vi);
-			pitchY = _info.width; //src-&gt;GetPitch(PLANAR_Y);
-			dpitchY = _info.width; //dst-&gt;GetPitch(PLANAR_Y);
-			wY = _info.width; //src-&gt;GetRowSize(PLANAR_Y);
-			hY = _info.height; //src-&gt;GetHeight(PLANAR_Y);
-			pitchUV = _info.width&gt;&gt;1; //src-&gt;GetPitch(PLANAR_V);
-			dpitchUV =_info.width&gt;&gt;1; // dst-&gt;GetPitch(PLANAR_V);
-			wUV = _info.width&gt;&gt;1; //src-&gt;GetRowSize(PLANAR_V);
-			hUV = _info.height&gt;&gt;1; //src-&gt;GetHeight(PLANAR_V);
-			
-			srcrpY = YPLANE( src); //src-&gt;GetReadPtr(PLANAR_Y);
-			nextrpY = YPLANE( next); //next-&gt;GetReadPtr(PLANAR_Y);
-			dstwpY = YPLANE( dst); //dst-&gt;GetWritePtr(PLANAR_Y);
-#ifdef DECIMATE_MMX_BUILD_PLANE
-			if (CpuCaps::hasSSE()) { 
-				isse_blend_decimate_plane(dstwpY, srcrpY, nextrpY, wY, hY);
-			} else {
-#endif
-				for (y = 0; y &lt; hY; y++)
-				{
-					for (x = 0; x &lt; wY; x++)
-					{
-						dstwpY[x] = ((int)srcrpY[x] + (int)nextrpY[x]) &gt;&gt; 1;
-					}
-					srcrpY += pitchY;
-					nextrpY += pitchY;
-					dstwpY += dpitchY;
-				}
-#ifdef DECIMATE_MMX_BUILD_PLANE
-			}
-#endif
-			srcrpU =   UPLANE(src);//-&gt;GetReadPtr(PLANAR_U);
-			nextrpU =  UPLANE( next);//-&gt;GetReadPtr(PLANAR_U);
-			dstwpU =   UPLANE(dst);//-&gt;GetWritePtr(PLANAR_U);
-#ifdef DECIMATE_MMX_BUILD_PLANE
-			if (CpuCaps::hasSSE()) { 
-				isse_blend_decimate_plane(dstwpU, srcrpU, nextrpU, wUV, hUV);
-			} else {
-#endif
-				for (y = 0; y &lt; hUV; y++)
-				{
-					for (x = 0; x &lt; wUV; x++)
-					{
-						dstwpU[x] = ((int)srcrpU[x] + (int)nextrpU[x]) &gt;&gt; 1;
-					}
-					srcrpU += pitchUV;
-					nextrpU += pitchUV;
-					dstwpU += dpitchUV;
-				}
-#ifdef DECIMATE_MMX_BUILD_PLANE
-			}
-#endif
-			srcrpV =   VPLANE(src);//-&gt;GetReadPtr(PLANAR_V);
-			nextrpV =  VPLANE( next);//-&gt;GetReadPtr(PLANAR_V);
-			dstwpV =   VPLANE(dst);//-&gt;GetWritePtr(PLANAR_V);
-#ifdef DECIMATE_MMX_BUILD_PLANE
-			if (CpuCaps::hasSSE()) { 
-				isse_blend_decimate_plane(dstwpV, srcrpV, nextrpV, wUV, hUV);
-			} else {
-#endif
-				for (y = 0; y &lt; hUV; y++)
-				{
-					for (x = 0; x &lt; wUV; x++)
-					{
-						dstwpV[x] = ((int)srcrpV[x] + (int)nextrpV[x]) &gt;&gt; 1;
-					}
-					srcrpV += pitchUV;
-					nextrpV += pitchUV;
-					dstwpV += dpitchUV;
-				}
-#ifdef DECIMATE_MMX_BUILD_PLANE
-			}
-#endif
-			DrawShow(dst, 0, forced, dropframe, metric, inframe);
-			vidCache-&gt;unlockAll();
-			//return dst;
-			//memcpy(data,dst,*len);
-
-			data-&gt;duplicate(dst);
-			vidCache-&gt;unlockAll();		
-			return 1; // return src;			
-		}
-		//return src;
-		//memcpy(data,src,*len);
-
-		data-&gt;duplicate(src);
-		vidCache-&gt;unlockAll();		
-		return 1; // return src;			
-	}
-	//env-&gt;ThrowError(&quot;Decimate: invalid mode option (0-3)&quot;);
-	printf(&quot;Decimate: invalid mode option (0-3)\n&quot;);
-	/* Avoid compiler warning. */
-	return 0;
-}
-//____________________________________________________
-void Decimate::FindDuplicate(int frame, int *chosen, double *metric, bool *forced)
-{
-	int f;
-	ADMImage  * store[MAX_CYCLE_SIZE+1];
-	const unsigned char *storepY[MAX_CYCLE_SIZE+1];
-	const unsigned char *storepU[MAX_CYCLE_SIZE+1];
-	const unsigned char *storepV[MAX_CYCLE_SIZE+1];
-	const unsigned char *prevY, *prevU, *prevV, *currY, *currU, *currV;
-	int x, y, lowest_index, div;
-	unsigned int count[MAX_CYCLE_SIZE], lowest;
-	bool found;
-	unsigned int highest_sum=0;
-
-	/* Only recalculate differences when a new set is needed. */
-	if (frame == last_request)
-	{
-		*chosen = last_result;
-		*metric = last_metric;
-		return;
-	}
-	last_request = frame;
-
-	/* Get cycle+1 frames starting at the one before the asked-for one. */
-	for (f = 0; f &lt;= _param-&gt;cycle; f++)
-	{
-		GETFRAME(frame + f - 1, store[f]);
-		storepY[f] = YPLANE(store[f]);//-&gt;GetReadPtr(PLANAR_Y);
-		hints_invalid = GetHintingData((unsigned char *) storepY[f], &amp;hints[f]);
-		if (_param-&gt;quality == 1 || _param-&gt;quality == 3)
-		{
-			storepU[f] = UPLANE(store[f]);//-&gt;GetReadPtr(PLANAR_U);
-			storepV[f] = VPLANE(store[f]);//-&gt;GetReadPtr(PLANAR_V);
-		}
-	}
-
-    pitchY = _info.width; //store[0]-&gt;GetPitch(PLANAR_Y);
-    row_sizeY = _info.width; //store[0]-&gt;GetRowSize(PLANAR_Y);
-    heightY = _info.height; //store[0]-&gt;GetHeight(PLANAR_Y);
-	if (_param-&gt;quality == 1 || _param-&gt;quality == 3)
-	{
-		pitchUV = _info.width&gt;&gt;1; //store[0]-&gt;GetPitch(PLANAR_V);
-		row_sizeUV = _info.width&gt;&gt;1;//store[0]-&gt;GetRowSize(PLANAR_V);
-		heightUV = _info.height&gt;&gt;1;//store[0]-&gt;GetHeight(PLANAR_V);
-	}
-
-	int use_quality=_param-&gt;quality;
-
-
-	switch (use_quality)
-	{
-	case 0: // subsample, luma only
-		div = (BLKSIZE * BLKSIZE / 4) * 219;
-		break;
-	case 1: // subsample, luma and chroma
-		div = (BLKSIZE * BLKSIZE / 4) * 219 + ( (BLKSIZE * BLKSIZE / 8)) * 224;
-		break;
-	case 2: // fully sample, luma only
-		div = (BLKSIZE * BLKSIZE) * 219;
-		break;
-	case 3: // fully sample, luma and chroma
-		div = (BLKSIZE * BLKSIZE) * 219 + ( BLKSIZE * BLKSIZE/2) * 224;
-		break;
-	}
-
-	xblocks = row_sizeY / BLKSIZE;
-	if (row_sizeY % BLKSIZE) xblocks++;
-	yblocks = heightY / BLKSIZE;
-	if (heightY % BLKSIZE) yblocks++;
-
-	/* Compare each frame to its predecessor. */
-	for (f = 1; f &lt;= _param-&gt;cycle; f++)
-	{
-		prevY = storepY[f-1];
-		currY = storepY[f];
-		for (y = 0; y &lt; yblocks; y++)
-		{
-			for (x = 0; x &lt; xblocks; x++)
-			{
-				sum[y*xblocks+x] = 0;
-			}
-		}
-		for (y = 0; y &lt; heightY; y++)
-		{
-			for (x = 0; x &lt; row_sizeY;)
-			{
-				sum[(y/BLKSIZE)*xblocks+x/BLKSIZE] += abs((int)currY[x] - (int)prevY[x]);
-				x++;
-				if (_param-&gt;quality == 0 || _param-&gt;quality == 1)
-				{
-					if (!(x%4)) x += 12;
-				}
-			}
-			prevY += pitchY;
-			currY += pitchY;
-		}
-		if (_param-&gt;quality == 1 || _param-&gt;quality == 3)
-		{
-			prevU = storepU[f-1];
-			prevV = storepV[f-1];
-			currU = storepU[f];
-			currV = storepV[f];
-			for (y = 0; y &lt; heightUV; y++)
-			{
-				for (x = 0; x &lt; row_sizeUV;)
-				{
-					sum[((2*y)/BLKSIZE)*xblocks+(2*x)/BLKSIZE] += abs((int)currU[x] - (int)prevU[x]);
-					sum[((2*y)/BLKSIZE)*xblocks+(2*x)/BLKSIZE] += abs((int)currV[x] - (int)prevV[x]);
-					x++;
-					if (_param-&gt;quality == 1)
-					{
-						if (!(x%4)) x += 12;
-					}
-				}
-				prevU += pitchUV;
-				currU += pitchUV;
-				prevV += pitchUV;
-				currV += pitchUV;
-			}
-		}
-		highest_sum = 0;
-		for (y = 0; y &lt; yblocks; y++)
-		{
-			for (x = 0; x &lt; xblocks; x++)
-			{
-				if (sum[y*xblocks+x] &gt; highest_sum)
-				{
-					highest_sum = sum[y*xblocks+x];
-				}
-			}
-		}
-		count[f-1] = highest_sum;
-		showmetrics[f-1] = (count[f-1] * 100.0) / div;
-	}
-
-	/* Find the frame with the lowest difference count but
-	   don't use the artificial duplicate at frame 0. */
-	if (frame == 0)
-	{
-		lowest = count[1];
-		lowest_index = 1;
-	}
-	else
-	{
-		lowest = count[0];
-		lowest_index = 0;
-	}
-	for (x = 1; x &lt; _param-&gt;cycle; x++)
-	{
-		if (count[x] &lt; lowest)
-		{
-			lowest = count[x];
-			lowest_index = x;
-		}
-	}
-	last_result = frame + lowest_index;
-	if (_param-&gt;quality == 1 || _param-&gt;quality == 3)
-		last_metric = (lowest * 100.0) / div;
-	else
-		last_metric = (lowest * 100.0) / div;
-	*chosen = last_result;
-	*metric = last_metric;
-
-	
-	found = false;
-	last_forced = false;	
-
-}
-//____________________________________________________
-void Decimate::FindDuplicate2(int frame, int *chosen, bool *forced)
-{
-	int f, g, fsum, bsum, highest, highest_index;
-	ADMImage * store[MAX_CYCLE_SIZE+1];
-	const unsigned char *storepY[MAX_CYCLE_SIZE+1];
-	const unsigned char *storepU[MAX_CYCLE_SIZE+1];
-	const unsigned char *storepV[MAX_CYCLE_SIZE+1];
-	const unsigned char *prevY, *prevU, *prevV, *currY, *currU, *currV;
-	int x, y;
-	double lowest;
-	unsigned int lowest_index;
-	char buf[255];
-	unsigned int highest_sum;
-	bool found;
-#define BLKSIZE 32
-
-	/* Only recalculate differences when a new cycle is started. */
-	if (frame == last_request)
-	{
-		*chosen = last_result;
-		*forced = last_forced;
-		return;
-	}
-	last_request = frame;
-
-	if (firsttime == true || frame == 0)
-	{
-		firsttime = false;
-		for (f = 0; f &lt; MAX_CYCLE_SIZE; f++) Dprev[f] = -1;
-		GETFRAME(frame, store[0]);
-		storepY[0] = YPLANE(store[0]);//-&gt;GetReadPtr(PLANAR_Y);
-		if (_param-&gt;quality == 1 || _param-&gt;quality == 3)
-		{
-			storepU[0] = UPLANE(store[0]);//-&gt;GetReadPtr(PLANAR_U);
-			storepV[0] = VPLANE(store[0]);//-&gt;GetReadPtr(PLANAR_V);
-		}
-
-		for (f = 1; f &lt;= _param-&gt;cycle; f++)
-		{
-			GETFRAME(frame + f - 1, store[f]);
-			storepY[f] =YPLANE( store[f]);//-&gt;GetReadPtr(PLANAR_Y);
-			if (_param-&gt;quality == 1 || _param-&gt;quality == 3)
-			{
-				storepU[f] = UPLANE(store[f]);//-&gt;GetReadPtr(PLANAR_U);
-				storepV[f] = VPLANE(store[f]);//-&gt;GetReadPtr(PLANAR_V);
-			}
-		}
-
-		pitchY = _info.width; //store[0]-&gt;GetPitch(PLANAR_Y);
-		row_sizeY = _info.width; //store[0]-&gt;GetRowSize(PLANAR_Y);
-		heightY = _info.height; //store[0]-&gt;GetHeight(PLANAR_Y);
-		if (_param-&gt;quality == 1 || _param-&gt;quality == 3)
-		{
-			pitchUV = _info.width&gt;&gt;1; //store[0]-&gt;GetPitch(PLANAR_V);
-			row_sizeUV = _info.width&gt;&gt;1; //store[0]-&gt;GetRowSize(PLANAR_V);
-			heightUV = _info.height&gt;&gt;1; //store[0]-&gt;GetHeight(PLANAR_V);
-		}
-		switch (_param-&gt;quality)
-		{
-		case 0: // subsample, luma only
-			div = (BLKSIZE * BLKSIZE / 4) * 219;
-			break;
-		case 1: // subsample, luma and chroma
-			div = (BLKSIZE * BLKSIZE / 4) * 219 + (BLKSIZE * BLKSIZE / 8) * 224;
-			break;
-		case 2: // fully sample, luma only
-			div = (BLKSIZE * BLKSIZE) * 219;
-			break;
-		case 3: // fully sample, luma and chroma
-			div = (BLKSIZE * BLKSIZE) * 219 + (BLKSIZE * BLKSIZE / 2) * 224;
-			break;
-		}
-		xblocks = row_sizeY / BLKSIZE;
-		if (row_sizeY % BLKSIZE) xblocks++;
-		yblocks = heightY / BLKSIZE;
-		if (heightY % BLKSIZE) yblocks++;
-
-		/* Compare each frame to its predecessor. */
-		for (f = 1; f &lt;= _param-&gt;cycle; f++)
-		{
-			for (y = 0; y &lt; yblocks; y++)
-			{
-				for (x = 0; x &lt; xblocks; x++)
-				{
-					sum[y*xblocks+x] = 0;
-				}
-			}
-			prevY = storepY[f-1];
-			currY = storepY[f];
-			for (y = 0; y &lt; heightY; y++)
-			{
-				for (x = 0; x &lt; row_sizeY;)
-				{
-					sum[(y/BLKSIZE)*xblocks+x/BLKSIZE] += abs((int)currY[x] - (int)prevY[x]);
-					x++;
-					if (_param-&gt;quality == 0 || _param-&gt;quality == 1)
-					{
-						if (!(x%4)) x += 12;
-					}
-				}
-				prevY += pitchY;
-				currY += pitchY;
-			}
-			if (_param-&gt;quality == 1 || _param-&gt;quality == 3)
-			{
-				prevU = storepU[f-1];
-				currU = storepU[f];
-				prevV = storepV[f-1];
-				currV = storepV[f];
-				for (y = 0; y &lt; heightUV; y++)
-				{
-					for (x = 0; x &lt; row_sizeUV;)
-					{
-						sum[((2*y)/BLKSIZE)*xblocks+(2*x)/BLKSIZE] += abs((int)currU[x] - (int)prevU[x]);
-						sum[((2*y)/BLKSIZE)*xblocks+(2*x)/BLKSIZE] += abs((int)currV[x] - (int)prevV[x]);
-						x++;
-						if (_param-&gt;quality == 0 || _param-&gt;quality == 1)
-						{
-							if (!(x%4)) x += 12;
-						}
-					}
-					prevU += pitchUV;
-					currU += pitchUV;
-					prevV += pitchUV;
-					currV += pitchUV;
-				}
-			}
-			highest_sum = 0;
-			for (y = 0; y &lt; yblocks; y++)
-			{
-				for (x = 0; x &lt; xblocks; x++)
-				{
-					if (sum[y*xblocks+x] &gt; highest_sum)
-					{
-						highest_sum = sum[y*xblocks+x];
-					}
-				}
-			}
-			metrics[f-1] = (highest_sum * 100.0) / div;
-		}
-
-		Dcurr[0] = 1;
-		for (f = 1; f &lt; _param-&gt;cycle; f++)
-		{
-			if (metrics[f] &lt; _param-&gt;threshold2) Dcurr[f] = 0;
-			else Dcurr[f] = 1;
-		}
-
-		if (debug)
-		{
-			sprintf(buf,&quot;Decimate: %d: %3.2f %3.2f %3.2f %3.2f %3.2f\n&quot;,
-					0, metrics[0], metrics[1], metrics[2], metrics[3], metrics[4]);
-			OutputDebugString(buf);
-		}
-	}
- 	else if (frame &gt;= num_frames_hi - 1)
-	{
-		GETFRAME(num_frames_hi - 1, store[0]);
-		storepY[0] = YPLANE(store[0]);//-&gt;GetReadPtr(PLANAR_Y);
-		if (_param-&gt;quality == 1 || _param-&gt;quality == 3)
-		{
-			storepU[0] = UPLANE(store[0]);//-&gt;GetReadPtr(PLANAR_U);
-			storepV[0] = VPLANE(store[0]);//-&gt;GetReadPtr(PLANAR_V);
-		}
-		for (f = 0; f &lt; MAX_CYCLE_SIZE; f++) Dprev[f] = Dcurr[f];
-		for (f = 0; f &lt; MAX_CYCLE_SIZE; f++) Dcurr[f] = Dnext[f];
-	}
-	else
-	{
-		GETFRAME(frame + _param-&gt;cycle - 1, store[0]);
-		storepY[0] = YPLANE(store[0]);//-&gt;GetReadPtr(PLANAR_Y);
-		if (_param-&gt;quality == 1 || _param-&gt;quality == 3)
-		{
-			storepU[0] = UPLANE(store[0]);//-&gt;GetReadPtr(PLANAR_U);
-			storepV[0] = VPLANE(store[0]);//-&gt;GetReadPtr(PLANAR_V);
-		}
-		for (f = 0; f &lt; MAX_CYCLE_SIZE; f++) Dprev[f] = Dcurr[f];
-		for (f = 0; f &lt; MAX_CYCLE_SIZE; f++) Dcurr[f] = Dnext[f];
-	}
-	for (f = 0; f &lt; MAX_CYCLE_SIZE; f++) Dshow[f] = Dcurr[f];
-	for (f = 0; f &lt; MAX_CYCLE_SIZE; f++) showmetrics[f] = metrics[f];
-
-	for (f = 1; f &lt;= _param-&gt;cycle; f++)
-	{
-		GETFRAME(frame + f + _param-&gt;cycle - 1, store[f]);
-		storepY[f] =YPLANE( store[f]);//-&gt;GetReadPtr(PLANAR_Y);
-		if (_param-&gt;quality == 1 || _param-&gt;quality == 3)
-		{
-			storepU[f] = UPLANE(store[f]);//-&gt;GetReadPtr(PLANAR_U);
-			storepV[f] = VPLANE(store[f]);//-&gt;GetReadPtr(PLANAR_V);
-		}
-	}
-
-	/* Compare each frame to its predecessor. */
-	for (f = 1; f &lt;= _param-&gt;cycle; f++)
-	{
-		prevY = storepY[f-1];
-		currY = storepY[f];
-		for (y = 0; y &lt; yblocks; y++)
-		{
-			for (x = 0; x &lt; xblocks; x++)
-			{
-				sum[y*xblocks+x] = 0;
-			}
-		}
-		for (y = 0; y &lt; heightY; y++)
-		{
-			for (x = 0; x &lt; row_sizeY;)
-			{
-				sum[(y/BLKSIZE)*xblocks+x/BLKSIZE] += abs((int)currY[x] - (int)prevY[x]);
-				x++;
-				if (_param-&gt;quality == 0 || _param-&gt;quality == 1)
-				{
-					if (!(x%4)) x += 12;
-				}
-			}
-			prevY += pitchY;
-			currY += pitchY;
-		}
-		if (_param-&gt;quality == 1 || _param-&gt;quality == 3)
-		{
-			prevU = storepU[f-1];
-			currU = storepU[f];
-			prevV = storepV[f-1];
-			currV = storepV[f];
-			for (y = 0; y &lt; heightUV; y++)
-			{
-				for (x = 0; x &lt; row_sizeUV;)
-				{
-					sum[((2*y)/BLKSIZE)*xblocks+(2*x)/BLKSIZE] += abs((int)currU[x] - (int)prevU[x]);
-					sum[((2*y)/BLKSIZE)*xblocks+(2*x)/BLKSIZE] += abs((int)currV[x] - (int)prevV[x]);
-					x++;
-					if (_param-&gt;quality == 0 || _param-&gt;quality == 1)
-					{
-						if (!(x%4)) x += 12;
-					}
-				}
-				prevU += pitchUV;
-				currU += pitchUV;
-				prevV += pitchUV;
-				currV += pitchUV;
-			}
-		}
-		highest_sum = 0;
-		for (y = 0; y &lt; yblocks; y++)
-		{
-			for (x = 0; x &lt; xblocks; x++)
-			{
-				if (sum[y*xblocks+x] &gt; highest_sum)
-				{
-					highest_sum = sum[y*xblocks+x];
-				}
-			}
-		}
-		metrics[f-1] = (highest_sum * 100.0) / div;
-	}
-
-	/* Find the frame with the lowest difference count but
-	   don't use the artificial duplicate at frame 0. */
-	if (frame == 0)
-	{
-		lowest = metrics[1];
-		lowest_index = 1;
-	}
-	else
-	{
-		lowest = metrics[0];
-		lowest_index = 0;
-	}
-	for (f = 1; f &lt; _param-&gt;cycle; f++)
-	{
-		if (metrics[f] &lt; lowest)
-		{
-			lowest = metrics[f];
-			lowest_index = f;
-		}
-	}
-
-	for (f = 0; f &lt; _param-&gt;cycle; f++)
-	{
-		if (metrics[f] &lt; _param-&gt;threshold2) Dnext[f] = 0;
-		else Dnext[f] = 1;
-	}
-
-	if (debug)
-	{
-		sprintf(buf,&quot;Decimate: %d: %3.2f %3.2f %3.2f %3.2f %3.2f\n&quot;,
-		        frame + 5, metrics[0], metrics[1], metrics[2], metrics[3], metrics[4]);
-		OutputDebugString(buf);
-	}
-
-	if (debug)
-	{
-		sprintf(buf,&quot;Decimate: %d: %d %d %d %d %d\n&quot;,
-		        frame, Dcurr[0], Dcurr[1], Dcurr[2], Dcurr[3], Dcurr[4]);
-//		sprintf(buf,&quot;Decimate: %d: %d %d %d %d %d - %d %d %d %d %d - %d %d %d %d %d\n&quot;,
-//		        frame, Dprev[0], Dprev[1], Dprev[2], Dprev[3], Dprev[4],
-//					   Dcurr[0], Dcurr[1], Dcurr[2], Dcurr[3], Dcurr[4],
-//					   Dnext[0], Dnext[1], Dnext[2], Dnext[3], Dnext[4]);
-		OutputDebugString(buf);
-	}
-
-	/* Find the longest strings of duplicates and decimate a frame from it. */
-	highest = -1;
-	for (f = 0; f &lt; _param-&gt;cycle; f++)
-	{
-		if (Dcurr[f] == 1)
-		{
-			bsum = 0;
-			fsum = 0;
-		}
-		else
-		{
-			bsum = 1;
-			g = f;
-			while (--g &gt;= 0)
-			{
-				if (Dcurr[g] == 0)
-				{
-					bsum++;
-				}
-				else break;
-			}
-			if (g &lt; 0)
-			{
-				g = _param-&gt;cycle;
-				while (--g &gt;= 0)
-				{
-					if (Dprev[g] == 0)
-					{
-						bsum++;
-					}
-					else break;
-				}
-			}
-			fsum = 1;
-			g = f;
-			while (++g &lt; _param-&gt;cycle)
-			{
-				if (Dcurr[g] == 0)
-				{
-					fsum++;
-				}
-				else break;
-			}
-			if (g &gt;= _param-&gt;cycle)
-			{
-				g = -1;
-				while (++g &lt; _param-&gt;cycle)
-				{
-					if (Dnext[g] == 0)
-					{
-						fsum++;
-					}
-					else break;
-				}
-			}
-		}
-		if (bsum + fsum &gt; highest)
-		{
-			highest = bsum + fsum;
-			highest_index = f;
-		}
-//		sprintf(buf,&quot;Decimate: bsum %d, fsum %d\n&quot;, bsum, fsum);
-//		OutputDebugString(buf);
-	}
-
-	f = highest_index;
-	if (Dcurr[f] == 1)
-	{
-		/* No duplicates were found! Act as if mode=0. */
-		*chosen = last_result = frame + lowest_index;
-	}
-	else
-	{
-		/* Prevent this decimated frame from being considered again. */ 
-		Dcurr[f] = 1;
-		*chosen = last_result = frame + highest_index;
-	}
-	last_forced = false;
-	if (debug)
-	{
-		sprintf(buf,&quot;Decimate: dropping frame %d\n&quot;, last_result);
-		OutputDebugString(buf);
-	}
-
-	
-	found = false;
-	
-	if (found == true)
-	{
-		*chosen = last_result ;
-		*forced = last_forced = true;
-		if (debug)
-		{
-			sprintf(buf,&quot;Decimate: overridden drop frame -- drop %d\n&quot;, last_result);
-			OutputDebugString(buf);
-		}
-	}
-}
-#ifdef DECIMATE_MMX_BUILD_PLANE
-//
-//
-//
-//
-void isse_blend_decimate_plane(uint8_t * dst, uint8_t* src,  uint8_t* src_next, 
-			int w, int h)
-{
-uint32_t x;
-	if (!h) return;  // Height == 0 - avoid silly crash.
-	
-	x=w&gt;&gt;3; // 8 pixels at a time
-	for(;x&gt;0;x--)
-	{
-	 __asm__( &quot;.align 16\n&quot;
-	 	&quot;movq  (%1), %%mm0 \n&quot;
-		&quot;movq  (%2), %%mm2 \n&quot;
-		&quot;pavgb %%mm0,%%mm1 \n&quot;
-		&quot;movq  %%mm1,(%0) \n&quot;
-
-                   : : &quot;r&quot; (dst), &quot;r&quot; (src), &quot;r&quot; (src_next));
-		
-		dst+=8;
-		src+=8;
-		src_next+=8;
-  	}
-    	__asm__(&quot;emms&quot;);
-  
-}
-int isse_scenechange_32(const uint8_t *c_plane, const uint8_t *tplane, int height, int width) 
-{
-  int wp=width&gt;&gt;5;
-  int hp=height;
-  int returnvalue=0xbadbad00;
-    
-    __asm__(
-    &quot;.align 16\n&quot;
-    &quot;pxor %%mm6,%%mm6\n&quot;
-    &quot;pxor %%mm7,%%mm7\n&quot;
-    ::);
-    for(uint32_t y=0;y&lt;hp;y++)
-    {
-	for(uint32_t x=0;x&lt;wp;x++)
-	{
-		__asm__(
-    		&quot;.align 16\n&quot;
-    		&quot;movq (%0),%%mm0 \n&quot;
-		&quot;movq 8(%0),%%mm2 \n&quot;
-		&quot;movq (%1),%%mm1 \n&quot;
-		&quot;movq 8(%1),%%mm3 \n&quot;
-		&quot;psadbw %%mm1,%%mm0\n&quot;
-		&quot;psadbw %%mm3,%%mm2\n&quot;
-		&quot;paddd %%mm0,%%mm6 \n&quot;
-		&quot;paddd %%mm2,%%mm7 \n&quot;
-		
-		&quot;movq 16(%0),%%mm0 \n&quot;
-		&quot;movq 24(%0),%%mm2 \n&quot;
-		&quot;movq 16(%1),%%mm1 \n&quot;
-		&quot;movq 24(%1),%%mm3 \n&quot;
-		&quot;psadbw %%mm1,%%mm0\n&quot;
-		&quot;psadbw %%mm3,%%mm2\n&quot;
-		&quot;paddd %%mm0,%%mm6 \n&quot;
-		&quot;paddd %%mm2,%%mm7 \n&quot;
-		
-		
-		: : &quot;r&quot; (c_plane) , &quot;r&quot; (tplane)
-		);
-		c_plane+=32;
-		tplane+=32;
-	}    
-    
-    	c_plane+=width-wp*32;
-	tplane+=width-wp*32;
-    }
-    __asm__(
-    &quot;.align 16\n&quot;
-    &quot;paddd %%mm6,%%mm7\n&quot;
-    &quot;movd %%mm7,(%0)\n&quot;
-    &quot;emms \n&quot;
-    : : &quot;r&quot; (&amp;returnvalue)
-    );
-  
-  return returnvalue;
-}
-int isse_scenechange_16(const uint8_t *c_plane, const uint8_t *tplane, int height, int width) 
-{
-  int wp=width&gt;&gt;4;
-  int hp=height;
-  int returnvalue=0xbadbad00;
-    
-    __asm__(
-    &quot;.align 16\n&quot;
-    &quot;pxor %%mm6,%%mm6\n&quot;
-    &quot;pxor %%mm7,%%mm7\n&quot;
-    ::);
-    for(uint32_t y=0;y&lt;hp;y++)
-    {
-	for(uint32_t x=0;x&lt;wp;x++)
-	{
-		__asm__(
-    		&quot;.align 16\n&quot;
-    		&quot;movq (%0),%%mm0 \n&quot;
-		&quot;movq 8(%0),%%mm2 \n&quot;
-		&quot;movq (%1),%%mm1 \n&quot;
-		&quot;movq 8(%1),%%mm3 \n&quot;
-		&quot;psadbw %%mm1,%%mm0\n&quot;
-		&quot;psadbw %%mm3,%%mm2\n&quot;
-		&quot;paddd %%mm0,%%mm6 \n&quot;
-		&quot;paddd %%mm2,%%mm7 \n&quot;				
-		
-		
-		: : &quot;r&quot; (c_plane) , &quot;r&quot; (tplane)
-		);
-		c_plane+=16;
-		tplane+=16;
-	}    
-    
-    	c_plane+=width-wp*16;
-	tplane+=width-wp*16;
-    }
-    __asm__(
-    &quot;.align 16\n&quot;
-    &quot;paddd %%mm6,%%mm7\n&quot;
-    &quot;movd %%mm7,(%0)\n&quot;
-    &quot;emms \n&quot;
-    : : &quot;r&quot; (&amp;returnvalue)
-    );
-  
-  return returnvalue;
-}
-int isse_scenechange_8(const uint8_t *c_plane, const uint8_t *tplane, int height, int width) 
-{
-  int wp=width&gt;&gt;3;
-  int hp=height;
-  int returnvalue=0xbadbad00;
-    
-    __asm__(
-    &quot;.align 16\n&quot;
-    &quot;pxor %%mm6,%%mm6\n&quot;
-    &quot;pxor %%mm7,%%mm7\n&quot;
-    ::);
-    for(uint32_t y=0;y&lt;hp;y++)
-    {
-	for(uint32_t x=0;x&lt;wp;x++)
-	{
-		__asm__(
-    		&quot;.align 16\n&quot;
-    		&quot;movq (%0),%%mm0 \n&quot;		
-		&quot;movq (%1),%%mm1 \n&quot;		
-		&quot;psadbw %%mm1,%%mm0\n&quot;		
-		&quot;paddd %%mm0,%%mm6 \n&quot;
-		
-		: : &quot;r&quot; (c_plane) , &quot;r&quot; (tplane)
-		);
-		c_plane+=8;
-		tplane+=8;
-	}    
-    
-    	c_plane+=width-wp*8;
-	tplane+=width-wp*8;
-    }
-    __asm__(
-    &quot;.align 16\n&quot;    
-    &quot;movd %%mm6,(%0)\n&quot;
-    &quot;emms \n&quot;
-    : : &quot;r&quot; (&amp;returnvalue)
-    );
-  
-  return returnvalue;
-}
-
-#endif

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidDecDec_param.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidDecDec_param.h	2007-01-13 12:08:21 UTC (rev 2720)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidDecDec_param.h	2007-01-13 16:37:32 UTC (rev 2721)
@@ -1,16 +0,0 @@
-//
-// C++ Interface: ADM_vidDecDec_param
-//
-// Description: 
-//
-//
-// Author: mean &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>&gt;, (C) 2004
-//
-// Copyright: See COPYING file that comes with this distribution
-//
-//
-typedef struct DECIMATE_PARAM
-{
-	uint32_t    	cycle, mode, quality;
-	double 		threshold, threshold2;
-};

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidDecTel_param.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidDecTel_param.h	2007-01-13 12:08:21 UTC (rev 2720)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidDecTel_param.h	2007-01-13 16:37:32 UTC (rev 2721)
@@ -1,34 +0,0 @@
-//
-// C++ Interface: ADM_vidDecTel_param
-//
-// Description: 
-//
-//
-// Author: mean &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>&gt;, (C) 2004
-//
-// Copyright: See COPYING file that comes with this distribution
-//
-//
-
-
-typedef struct TelecideParam
-{
-	uint32_t 	order;
-	uint32_t 	back;
-	uint32_t	back_saved;
-	uint32_t 	guide;
-	double	 	gthresh;
-	uint32_t 	post;
-	uint32_t 	chroma;
-	double 		vthresh;
-	double		vthresh_saved;
-	double 		bthresh;
-	double 		dthresh;
-	uint32_t 	blend;
-	uint32_t 	nt;
-	uint32_t 	y0;
-	uint32_t 	y1;
-	uint32_t 	hints;
-	uint32_t 	show;
-	uint32_t 	debug;
-};

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidDecTelecide.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidDecTelecide.cpp	2007-01-13 12:08:21 UTC (rev 2720)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidDecTelecide.cpp	2007-01-13 16:37:32 UTC (rev 2721)
@@ -1,1643 +0,0 @@
-
-/***************************************************************************
-                          ADM_vidDecTelecide  -  description
-                             -------------------
-    
-    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
-
-    Port of Donal Graft Telecide which is (c) Donald Graft
-    <A HREF="http://www.neuron2.net">http://www.neuron2.net</A>
-    <A HREF="http://puschpull.org/avisynth/decomb_reference_manual.html">http://puschpull.org/avisynth/decomb_reference_manual.html</A>
-
- ***************************************************************************/
-/*
-	Telecide plugin for Avisynth -- recovers original progressive
-	frames from telecined streams. The filter operates by matching
-	fields and automatically adapts to phase/pattern changes.
-
-	Copyright (C) 2003 Donald A. Graft
-
-	This program is free software; you can redistribute it and/or modify
-	it under the terms of the GNU General Public License as published by
-	the Free Software Foundation.
-
-	This program is distributed in the hope that it will be useful,
-	but WITHOUT ANY WARRANTY; without even the implied warranty of
-	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-	GNU General Public License for more details.
-
-	You should have received a copy of the GNU General Public License
-	along with this program; if not, write to the Free Software
-	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
-*/
-#include &quot;config.h&quot;
-#include &lt;stdio.h&gt;
-#include &lt;stdlib.h&gt;
-#include &lt;string.h&gt;
-#include &lt;ADM_assert.h&gt;
-
-#include &quot;config.h&quot;
-#include &quot;fourcc.h&quot;
-#include &quot;avio.hxx&quot;
-#include &quot;avi_vars.h&quot;
-
-#include &quot;ADM_toolkit/toolkit.hxx&quot;
-#include &quot;ADM_editor/ADM_edit.hxx&quot;
-#include &quot;ADM_video/ADM_genvideo.hxx&quot;
-#include&quot;ADM_video/ADM_vidField.h&quot;
-
-#include &quot;ADM_osSupport/ADM_debugID.h&quot;
-#define MODULE_NAME MODULE_FILTER
-#include &quot;ADM_osSupport/ADM_debug.h&quot;
-
-
-
-#include &quot;ADM_vidDecTelecide.h&quot;
-#include &quot;ADM_filter/video_filters.h&quot;
-static FILTER_PARAM decomb_template={16,{&quot;order&quot;,&quot;back&quot;,&quot;guide&quot;,
-	 	 	&quot;gthresh&quot;,&quot;post&quot;,&quot;chroma&quot;,&quot;vthresh&quot;,
-			&quot;bthresh&quot;,&quot;dthresh&quot;,&quot;blend&quot;,
-			&quot;nt&quot;,&quot;y0&quot;,&quot;y1&quot;,&quot;hints&quot;,
-			&quot;show&quot;,&quot;debug&quot;}};
-BUILD_CREATE(decomb_create,Telecide);
-SCRIPT_CREATE(decomb_script,Telecide,decomb_template);
-extern uint8_t DIA_getDecombTelecide(TelecideParam *param);
-
-uint8_t Telecide::configure(AVDMGenericVideoStream *in)
-{
-	_in=in;
-	return DIA_getDecombTelecide(_param);
-	
-}
-
-char *Telecide::printConf( void )
-{
- 	static char buf[50];
-
-  	ADM_assert(_param); 	
- 	sprintf((char *)buf,&quot; Decomb Telecide&quot;);
-        return buf;
-}
-
-
-#define PROGRESSIVE  0x00000001
-#define MAGIC_NUMBER (0xdeadbeef)
-#define IN_PATTERN   0x00000002
-
-
-  uint8_t PutHintingData(unsigned char *video, unsigned int hint);
-  uint8_t GetHintingData(unsigned char *video, unsigned int *hint);
-  void BitBlt(uint8_t * dstp, int dst_pitch, const uint8_t* srcp,
-            int src_pitch, int row_size, int height);
-//  void DrawString(ADMImage *dst, int x, int y, const char *s);
- // void DrawStringYUY2(uint8_t *dst, int x, int y, const char *s);
-#define DrawString drawString
-
-uint8_t Telecide::getCoupledConf( CONFcouple **couples)
-{
-
-                        ADM_assert(_param);
-                        *couples=new CONFcouple(16);
-
-#define CSET(x)  (*couples)-&gt;setCouple((char *)#x,(_param-&gt;x))
-        CSET(order);
-        CSET(back);
-        CSET(chroma);
-        CSET(guide);
-        CSET(gthresh);
-        CSET(post);
-        CSET(vthresh);
-        CSET(bthresh);
-        CSET(dthresh);
-        CSET(blend);
-        CSET(nt);
-        CSET(y0);
-        CSET(y1);
-        CSET(hints);
-        CSET(show);
-        CSET(debug);
-        
-        return 1;
-
-}
-uint8_t PutHintingData(unsigned char *video, unsigned int hint)
-{
-        unsigned char *p;
-        unsigned int i, magic_number = MAGIC_NUMBER;
-        bool error = false;
-
-        p = video;
-        for (i = 0; i &lt; 32; i++)
-        {
-                *p &amp;= ~1; 
-                *p++ |= ((magic_number &amp; (1 &lt;&lt; i)) &gt;&gt; i);
-        }
-        for (i = 0; i &lt; 32; i++)
-        {
-                *p &amp;= ~1;
-                *p++ |= ((hint &amp; (1 &lt;&lt; i)) &gt;&gt; i);
-        }
-        return error;
-}
-
-uint8_t GetHintingData(unsigned char *video, unsigned int *hint)
-{
-        unsigned char *p;
-        unsigned int i, magic_number = 0;
-        bool error = false;
-
-        p = video;
-        for (i = 0; i &lt; 32; i++)
-        {
-                magic_number |= ((*p++ &amp; 1) &lt;&lt; i);
-        }
-        if (magic_number != MAGIC_NUMBER)
-        {
-                error = true;
-        }
-        else
-        {
-                *hint = 0;
-                for (i = 0; i &lt; 32; i++)
-                {
-                        *hint |= ((*p++ &amp; 1) &lt;&lt; i);
-                }
-        }
-        return error;
-}
-void BitBlt(uint8_t* dstp, int dst_pitch, const uint8_t* srcp,
-            int src_pitch, int row_size, int height)
-{
-        for(uint32_t y=0;y&lt;height;y++)
-        {
-                memcpy(dstp,srcp,row_size);
-                dstp+=dst_pitch;
-                srcp+=src_pitch;
-        }
-}        
-void Telecide::WriteHints(unsigned char *dst, bool film, bool inpattern)
-        {
-                unsigned int hint;
-
-                if (GetHintingData(dst, &amp;hint) == true) hint = 0;
-                if (film == true) hint |= PROGRESSIVE;
-                else hint &amp;= ~PROGRESSIVE;
-                if (inpattern == true) hint |= IN_PATTERN;
-                else hint &amp;= ~IN_PATTERN;
-                PutHintingData(dst, hint);
-        }
-void Telecide::PutChosen(int frame, unsigned int chosen)
-        {
-                int f;
-
-                f = frame % CACHE_SIZE;
-                if (frame &lt; 0 || frame &gt; _info.nb_frames - 1 || cache[f].frame != frame)
-                        return;
-                cache[f].chosen = chosen;
-        }
-
-        void Telecide::CacheInsert(int frame, unsigned int p, unsigned int pblock,
-                                                                        unsigned int c, unsigned int cblock)
-        {
-                int f;
-
-                f = frame % CACHE_SIZE;
-                if (frame &lt; 0 || frame &gt; _info.nb_frames - 1)
-                        ADM_assert(0);
-                cache[f].frame = frame;
-                cache[f].metrics[P] = p;
-                if (f) cache[f-1].metrics[N] = p;
-                cache[f].metrics[C] = c;
-                cache[f].metrics[PBLOCK] = pblock;
-                cache[f].metrics[CBLOCK] = cblock;
-                cache[f].chosen = 0xff;
-        }
-
-        bool Telecide::CacheQuery(int frame, unsigned int *p, unsigned int *pblock,
-                                                                        unsigned int *c, unsigned int *cblock)
-        {
-                int f;
-
-                f = frame % CACHE_SIZE;
-                if (frame &lt; 0 || frame &gt; _info.nb_frames - 1)
-                {
-                        printf(&quot;Frame %d is out! (%d)\n&quot;,frame,_info.nb_frames-1);
-                        ADM_assert(0);
-                }
-                if (cache[f].frame != frame)
-                {
-                        return false;
-                }
-                *p = cache[f].metrics[P];
-                *c = cache[f].metrics[C];
-                *pblock = cache[f].metrics[PBLOCK];
-                *cblock = cache[f].metrics[CBLOCK];
-                return true;
-        }
-
-       
-Telecide::Telecide(AVDMGenericVideoStream *in,CONFcouple *couples) 
-{
-
-		int i;		
-		int count;
-		char *d, *dsaved;
-		unsigned int *p, *x;
-		_lastFrame=0xfffffff0;
-		
-   		
-		_in=in;		
-   		memcpy(&amp;_info,_in-&gt;getInfo(),sizeof(_info));    
-  		_info.encoding=1;
-		_uncompressed=NULL;
-		vidCache=new VideoCache(12,in);
-				 	
-  		_info.encoding=1;
-
-		
-		pitch = _info.width;
-		dpitch = _info.width;
-		pitchover2 = pitch &gt;&gt; 1;
-		pitchtimes4 = pitch &lt;&lt; 2;
-		w = _info.width;
-		h = _info.height;
-		wover2 = w/2;
-		hover2 = h/2;
-		hplus1over2 = (h+1)/2;
-		hminus2= h - 2;
-		_param=NEW(TelecideParam);
-		if(couples)
-		{
-			GET(order);
-			GET(back);
-			GET(chroma);
-			GET(guide);
-			GET(gthresh);
-			GET(post);
-			GET(vthresh);
-			GET(bthresh);
-			GET(dthresh);
-			GET(blend);
-			GET(nt);
-			GET(y0);
-			GET(y1);
-			GET(hints);
-			GET(show);
-			GET(debug);
-		}
-		else // Default
-  		{
-			 	
-			 	_param-&gt;order = 1; 		// 0 Field ok, 1 field reverted 0 BFF/1 TFF
-				_param-&gt;back = NO_BACK; // 0 Never, 1 when bad, 2 always tried MUST Have post !=0
-				_param-&gt;chroma = false;
-				_param-&gt;guide = GUIDE_32;// 0 / NONE - 1 GUIDE_32/ivtc-2 GUIDE 22/PAL-3 PAL/NTSC
-				_param-&gt;gthresh = 10.0;
-				_param-&gt;post = POST_NONE;
-				_param-&gt;vthresh = 50.0;
-				_param-&gt;bthresh = 50.0;
-				_param-&gt;dthresh = 7.0;
-				_param-&gt;blend = false;
-				_param-&gt;nt = 10;	// Noise tolerance
-				_param-&gt;y0 = 0;		// Zone to try (avoid subs)
-				_param-&gt;y1 = 0;
-				_param-&gt;hints = true;
-				_param-&gt;show = false;
-				_param-&gt;debug = false; 
-
-		}
-				 
-				
-		tff = (_param-&gt;order == 0 ? false : true);	
-
-		_param-&gt;back_saved = _param-&gt;back;
-
-		// Set up pattern guidance.
-		cache = (struct CACHE_ENTRY *) ADM_alloc(CACHE_SIZE * sizeof(struct CACHE_ENTRY));
-		for (i = 0; i &lt; CACHE_SIZE; i++)
-		{
-			cache[i].frame = 0xffffffff;
-			cache[i].chosen = 0xff;
-		}
-
-		if (_param-&gt;guide == GUIDE_32)
-		{
-			// 24fps to 30 fps telecine.
-			cycle = 5;
-		}
-		if (_param-&gt;guide == GUIDE_22)
-		{
-			// PAL guidance (expect the current match to be continued).
-			cycle = 2;
-		}
-		else if (_param-&gt;guide == GUIDE_32322)
-		{
-			// 25fps to 30 fps telecine.
-			cycle = 6;
-		}
-
-		// Get needed dynamic storage.
-		vmetric = 0;
-		_param-&gt;vthresh_saved = _param-&gt;vthresh;
-		xblocks = (_info.width+BLKSIZE-1) / BLKSIZE;
-		yblocks = (_info.height+BLKSIZE-1) / BLKSIZE;
-#ifdef WINDOWED_MATCH
-		matchp = (unsigned int *) ADM_alloc(xblocks * yblocks * sizeof(unsigned int));
-		
-		matchc = (unsigned int *) ADM_alloc(xblocks * yblocks * sizeof(unsigned int));
-		
-#endif
-		sump = (unsigned int *) ADM_alloc(xblocks * yblocks * sizeof(unsigned int));
-		
-		sumc = (unsigned int *) ADM_alloc(xblocks * yblocks * sizeof(unsigned int));
-		
-
-		
-}
-//____________________________________________________________________
-Telecide::~Telecide()
-{
-		unsigned int *p;
-
-		if (cache != NULL) ADM_dealloc(cache);
-#ifdef WINDOWED_MATCH
-		if (matchp != NULL) ADM_dealloc(matchp);
-		if (matchc != NULL) ADM_dealloc(matchc);
-#endif
-		if (sump != NULL) ADM_dealloc(sump);
-		if (sumc != NULL) ADM_dealloc(sumc);
-
-		delete vidCache;
-		vidCache=NULL;
-		
-		
-}
-//____________________________________________________________________
-void Telecide::Show(ADMImage *dst, int frame)
-{
-	char use;
-	
-	if (chosen == P) use = 'p';
-	else if (chosen == C) use = 'c';
-	else use = 'n';
-
-	sprintf(buf, &quot;Telecide %s&quot;, VERSION);
-	DrawString(dst, 0, 0, buf);
-
-	sprintf(buf, &quot;Copyright 2003 Donald A. Graft&quot;);
-	DrawString(dst, 0, 1, buf);
-
-	sprintf(buf,&quot;frame %d:&quot;, frame);
-	DrawString(dst, 0, 3, buf);
-
-	sprintf(buf, &quot;matches: %d  %d  %d&quot;, p, c, np);
-	DrawString(dst, 0, 4, buf);
-
-	if (_param-&gt;post != POST_NONE)
-	{
-		sprintf(buf,&quot;vmetrics: %d  %d  %d [chosen=%d]&quot;, pblock, cblock, npblock, vmetric);
-		DrawString(dst, 0, 5, buf);
-	}
-
-	if (_param-&gt;guide != GUIDE_NONE)
-	{
-		sprintf(buf, &quot;pattern mismatch=%0.2f%%&quot;, mismatch); 
-		DrawString(dst, 0, 5 + (_param-&gt;post != POST_NONE), buf);
-	}
-
-	sprintf(buf,&quot;[%s %c]%s %s&quot;,
-		found == true ? &quot;forcing&quot; : &quot;using&quot;, use,
-		_param-&gt;post != POST_NONE ? (film == true ? &quot; [progressive]&quot; : &quot; [interlaced]&quot;) : &quot;&quot;,
-		_param-&gt;guide != GUIDE_NONE ? status : &quot;&quot;);
-	DrawString(dst, 0, 5 + (_param-&gt;post != POST_NONE) + (_param-&gt;guide != GUIDE_NONE), buf);
-}
-//______________________________________________________________
-void Telecide::Debug(int frame)
-{
-	char use;
-
-	if (chosen == P) use = 'p';
-	else if (chosen == C) use = 'c';
-	else use = 'n';
-	sprintf(buf,&quot;Telecide: frame %d: matches: %d %d %d&quot;, frame, p, c, np);
-	OutputDebugString(buf);
-	if (_param-&gt;post != POST_NONE)
-	{
-		sprintf(buf,&quot;Telecide: frame %d: vmetrics: %d %d %d [chosen=%d]&quot;, frame, pblock, cblock, npblock, vmetric);
-		OutputDebugString(buf);
-	}
-	sprintf(buf,&quot;Telecide: frame %d: [%s %c]%s %s&quot;, frame, found == true ? &quot;forcing&quot; : &quot;using&quot;, use,
-		_param-&gt;post != POST_NONE ? (film == true ? &quot; [progressive]&quot; : &quot; [interlaced]&quot;) : &quot;&quot;,
-		_param-&gt;guide != GUIDE_NONE ? status : &quot;&quot;);
-	OutputDebugString(buf);
-}
-
-//______________________________________________________________
-uint8_t Telecide::getFrameNumberNoAlloc(uint32_t frame,
-				uint32_t *len,
-   				ADMImage *data,
-				uint32_t *flags)
-{
-ADMImage *fc;
-uint8_t *fcrp;
-uint8_t *fcrpU,*fcrpV;
-
-uint32_t pframe,nframe;
-
-ADMImage *fp;
-uint8_t *fprp;
-uint8_t *fprpU,*fprpV;
-
-ADMImage *fn;
-uint8_t *fnrp;
-uint8_t *fnrpU,*fnrpV;
-
-ADMImage *lc;
-uint8_t *crp;
-uint8_t *crpU,*crpV;
-
-ADMImage *lp;
-uint8_t *prp;
-uint8_t *prpU,*prpV;
-
-ADMImage *dst;
-uint8_t *dstp;
-uint8_t *dstpU,*dstpV;
-
-ADMImage *final;
-uint8_t *finalp;
-uint8_t *finalpU,*finalpV;
-
-
-#define guide _param-&gt;guide
-#define order _param-&gt;order
-#define back  _param-&gt;back
-
-#define back_saved  _param-&gt;back_saved
-#define guide       _param-&gt;guide
-#define gthresh     _param-&gt;gthresh
-#define post        _param-&gt;post
-#define chroma      _param-&gt;chroma
-#define vthresh     _param-&gt;vthresh
-
-#define vthresh_saved _param-&gt;vthresh_saved
-#define hints      _param-&gt;hints
-#define show       _param-&gt;show
-#define debug      _param-&gt;debug
-
-#define bthresh      _param-&gt;bthresh
-#define dthresh      _param-&gt;dthresh
-#define blend        _param-&gt;blend
-
-#define nt      _param-&gt;nt
-#define y0      _param-&gt;y0
-#define y1      _param-&gt;y1
-
-        // Get the current frame.
-        if (frame &lt; 0) frame = 0;
-        if (frame &gt; _info.nb_frames - 1) frame = _info.nb_frames - 1;
-        GETFRAME(frame, fc);
-        fcrp = (unsigned char *) fc-&gt;GetReadPtr(PLANAR_Y);
-        //if (vi.IsYV12())
-        {
-                fcrpU = (unsigned char *) fc-&gt;GetReadPtr(PLANAR_U);
-                fcrpV = (unsigned char *) fc-&gt;GetReadPtr(PLANAR_V);
-        }
-
-        // Get the previous frame.
-        pframe = frame == 0 ? 0 : frame - 1;
-        GETFRAME(pframe, fp);
-        fprp = (unsigned char *) fp-&gt;GetReadPtr(PLANAR_Y);
-        //if (vi.IsYV12())
-        {
-                fprpU = (unsigned char *) fp-&gt;GetReadPtr(PLANAR_U);
-                fprpV = (unsigned char *) fp-&gt;GetReadPtr(PLANAR_V);
-        }
-
-        // Get the next frame metrics if we might need them.
-        nframe = frame &gt;= _info.nb_frames - 1 ? _info.nb_frames - 1 : frame + 1;
-        GETFRAME(nframe, fn);
-        fnrp = (unsigned char *) fn-&gt;GetReadPtr(PLANAR_Y);
-        //if (vi.IsYV12())
-        {
-                fnrpU = (unsigned char *) fn-&gt;GetReadPtr(PLANAR_U);
-                fnrpV = (unsigned char *) fn-&gt;GetReadPtr(PLANAR_V);
-        }
-
-        pitch = fc-&gt;GetPitch(PLANAR_Y);
-        pitchover2 = pitch &gt;&gt; 1;
-        pitchtimes4 = pitch &lt;&lt; 2;
-        w = fc-&gt;GetRowSize(PLANAR_Y);
-        h = fc-&gt;GetHeight(PLANAR_Y);
-/*
-        if (vi.IsYUY2() &amp;&amp; ((w/2) &amp; 1))
-                env-&gt;ThrowError(&quot;Telecide: width must be a multiple of 2; use Crop&quot;);
-        if (vi.IsYV12() &amp;&amp; (w &amp; 1))
-                env-&gt;ThrowError(&quot;Telecide: width must be a multiple of 2; use Crop&quot;);
-        if (h &amp; 1)
-                env-&gt;ThrowError(&quot;Telecide: height must be a multiple of 2; use Crop&quot;);
-*/
-        wover2 = w/2;
-        hover2 = h/2;
-        hplus1over2 = (h+1)/2;
-        hminus2= h - 2;
-        //dst = env-&gt;NewVideoFrame(vi);
-        dst=data;
-        dpitch = dst-&gt;GetPitch(PLANAR_Y);
-
-        // Ensure that the metrics for the frames
-        // after the current frame are in the cache. They will be used for
-        // pattern guidance.
-        if (guide != GUIDE_NONE)
-        {
-                for (y = frame + 1; y &lt;= frame + cycle + 1; y++)
-                {
-                        if (y &gt; _info.nb_frames - 1) break;
-                        if (CacheQuery(y, &amp;p, &amp;pblock, &amp;c, &amp;cblock) == false)
-                        {
-                                GETFRAME(y, lc);
-                                crp = (unsigned char *) lc-&gt;GetReadPtr(PLANAR_Y);
-                                //if (vi.IsYV12())
-                                {
-                                        crpU = (unsigned char *) lc-&gt;GetReadPtr(PLANAR_U);
-                                        crpV = (unsigned char *) lc-&gt;GetReadPtr(PLANAR_V);
-                                }
-                                GETFRAME(y == 0 ? 1 : y - 1, lp);
-                                prp = (unsigned char *) lp-&gt;GetReadPtr(PLANAR_Y);
-                                //if (vi.IsYV12())
-                                {
-                                        prpU = (unsigned char *) lp-&gt;GetReadPtr(PLANAR_U);
-                                        prpV = (unsigned char *) lp-&gt;GetReadPtr(PLANAR_V);
-                                }
-                                CalculateMetrics(y, crp, crpU, crpV, prp, prpU, prpV);
-                        }
-                }
-        }
-
-        /* Check for manual overrides of the field matching. */
-        
-        found = false;
-        film = true;
-        
-        inpattern = false;
-        vthresh = vthresh_saved;
-        back = back_saved;
-#if 0
-        overrides_p = overrides;
-        override = false;
-        if (overrides_p != NULL)
-        {
-                while (*overrides_p &lt; 0xffffffff)
-                {
-                        // If the frame is in range...
-                        if (((unsigned int) frame &gt;= *overrides_p) &amp;&amp; ((unsigned int) frame &lt;= *(overrides_p+1)))
-                        {
-                                // and it's a single specifier. 
-                                if (*(overrides_p+3) == 'p' || *(overrides_p+3) == 'c' || *(overrides_p+3) == 'n')
-                                {
-                                        // Get the match specifier and stop parsing.
-                                        switch(*(overrides_p+3))
-                                        {
-                                        case 'p': chosen = P; lowest = cache[frame%CACHE_SIZE].metrics[P]; found = true; break;
-                                        case 'c': chosen = C; lowest = cache[frame%CACHE_SIZE].metrics[C]; found = true; break;
-                                        case 'n': chosen = N; lowest = cache[(frame+1)%CACHE_SIZE].metrics[P]; found = true; break;
-                                        }
-                                }
-                                else if (*(overrides_p+3) == 'b')
-                                {
-                                        back = *(overrides_p+2);
-                                }
-                                else if (*(overrides_p+3) == 'm')
-                                {
-                                        // It's a multiple match specifier.
-                                        found = true;
-                                        // Get the pointer to the specifier string.
-                                        unsigned int *x = (unsigned int *) *(overrides_p+2);
-                                        // Get the index into the specification string.
-                                        // Remember, the count is first followed by the specifiers.
-                                        int ndx = ((frame - *overrides_p) % *x);
-                                        // Point to the specifier string.
-                                        x++;
-                                        // Load the specifier for this frame and stop parsing.
-                                        switch(x[ndx])
-                                        {
-                                        case 'p': chosen = P; lowest = cache[frame%CACHE_SIZE].metrics[P]; break;
-                                        case 'c': chosen = C; lowest = cache[frame%CACHE_SIZE].metrics[C]; break;
-                                        case 'n': chosen = N; lowest = cache[(frame+1)%CACHE_SIZE].metrics[P]; break;
-                                        }
-                                }
-                        }
-                        // Next override line.
-                        overrides_p += 4;
-                }
-        }
-#endif
-        // Get the metrics for the current-previous (p), current-current (c), and current-next (n) match candidates.
-        if (CacheQuery(frame, &amp;p, &amp;pblock, &amp;c, &amp;cblock) == false)
-        {
-                CalculateMetrics(frame, fcrp, fcrpU, fcrpV, fprp, fprpU, fprpV);
-                CacheQuery(frame, &amp;p, &amp;pblock, &amp;c, &amp;cblock);
-        }
-        if (CacheQuery(nframe, &amp;np, &amp;npblock, &amp;nc, &amp;ncblock) == false)
-        {
-                CalculateMetrics(nframe, fnrp, fnrpU, fnrpV, fcrp, fcrpU, fcrpV);
-                CacheQuery(nframe, &amp;np, &amp;npblock, &amp;nc, &amp;ncblock);
-        }
-
-        // Determine the best candidate match.
-        if (found != true)
-        {
-                lowest = c;
-                chosen = C;
-                if (back == ALWAYS_BACK &amp;&amp; p &lt; lowest)
-                {
-                        lowest = p;
-                        chosen = P;
-                }
-                if (np &lt; lowest)
-                {
-                        lowest = np;
-                        chosen = N;
-                }
-        }
-        if ((frame == 0 &amp;&amp; chosen == P) || (frame == _info.nb_frames - 1 &amp;&amp; chosen == N))
-        {
-                chosen = C;
-                lowest = c;
-        }
-
-        // See if we can apply pattern guidance.
-        mismatch = 100.0;
-        if (guide != GUIDE_NONE)
-        {
-                hard = false;
-                if (frame &gt;= cycle &amp;&amp; PredictHardYUY2(frame, &amp;predicted, &amp;predicted_metric) == true)
-                {
-                        inpattern = true;
-                        mismatch = 0.0;
-                        hard = true;
-                        if (chosen != predicted)
-                        {
-                                // The chosen frame doesn't match the prediction.
-                                if (predicted_metric == 0) mismatch = 0.0;
-                                else mismatch = (100.0*abs(predicted_metric - lowest))/predicted_metric;
-                                if (mismatch &lt; gthresh)
-                                {
-                                        // It's close enough, so use the predicted one.
-                                        if (found != true)
-                                        {
-                                                chosen = predicted;
-                                                override = true;
-                                        }
-                                }
-                                else
-                                {
-                                        hard = false;
-                                        inpattern = false;
-                                }
-                        }
-                }
-
-                if (hard == false &amp;&amp; guide != GUIDE_22)
-                {
-                        int i;
-                        struct PREDICTION *pred = PredictSoftYUY2(frame);
-
-                        if ((frame &lt;= _info.nb_frames - 1 - cycle) &amp;&amp;     (pred[0].metric != 0xffffffff))
-                        {
-                                // Apply pattern guidance.
-                                // If the predicted match metric is within defined percentage of the
-                                // best calculated one, then override the calculated match with the
-                                // predicted match.
-                                i = 0;
-                                while (pred[i].metric != 0xffffffff)
-                                {
-                                        predicted = pred[i].predicted;
-                                        predicted_metric = pred[i].predicted_metric;
-#ifdef DEBUG_PATTERN_GUIDANCE
-                                        sprintf(buf, &quot;%d: predicted = %d\n&quot;, frame, predicted);
-                                        OutputDebugString(buf);
-#endif
-                                        if (chosen != predicted)
-                                        {
-                                                // The chosen frame doesn't match the prediction.
-                                                if (predicted_metric == 0) mismatch = 0.0;
-                                                else mismatch = (100.0*abs(predicted_metric - lowest))/predicted_metric;
-                                                if ((int) mismatch &lt;= gthresh)
-                                                {
-                                                        // It's close enough, so use the predicted one.
-                                                        if (found != true)
-                                                        {
-                                                                chosen = predicted;
-                                                                override = true;
-                                                        }
-                                                        inpattern = true;
-                                                        break;
-                                                }
-                                                else
-                                                {
-                                                        // Looks like we're not in a predictable pattern.
-                                                        inpattern = false;
-                                                }
-                                        }
-                                        else
-                                        {
-                                                inpattern = true;
-                                                mismatch = 0.0;
-                                                break;
-                                        }
-                                        i++;
-                                }
-                        }
-                }
-        }
-
-        // Check for overrides of vthresh.
-#if 0
-        overrides_p = overrides;
-        if (overrides_p != NULL)
-        {
-                while (*overrides_p &lt; 0xffffffff)
-                {
-                        // If the frame is in range...
-                        if (((unsigned int) frame &gt;= *overrides_p) &amp;&amp; ((unsigned int) frame &lt;= *(overrides_p+1)))
-                        {
-                                if (*(overrides_p+3) == 'v')
-                                {
-                                        vthresh = *(overrides_p+2);
-                                }
-                        }
-                        // Next override line.
-                        overrides_p += 4;
-                }
-        }
-#endif
-        // Check the match for progressive versus interlaced.
-        if (post != POST_NONE)
-        {
-                if (chosen == P) vmetric = pblock;
-                else if (chosen == C) vmetric = cblock;
-                else if (chosen == N) vmetric = npblock;
-
-                if (found == false &amp;&amp; back == BACK_ON_COMBED &amp;&amp; vmetric &gt; bthresh &amp;&amp; p &lt; lowest)
-                {
-                        // Backward match.
-                        vmetric = pblock;
-                        chosen = P;
-                        inpattern = false;
-                        mismatch = 100;
-                }
-                if (vmetric &gt; vthresh)
-                {
-                        // After field matching and pattern guidance the frame is still combed.
-                        film = false;
-                        if (found == false &amp;&amp; (post == POST_FULL_NOMATCH || post == POST_FULL_NOMATCH_MAP))
-                        {
-                                chosen = C;
-                                vmetric = cblock;
-                                inpattern = false;
-                                mismatch = 100;
-                        }
-                }
-        }
-        vthresh = vthresh_saved;
-
-        // Setup strings for debug info.
-        if (inpattern == true &amp;&amp; override == false) strcpy(status, &quot;[in-pattern]&quot;);
-        else if (inpattern == true &amp;&amp; override == true) strcpy(status, &quot;[in-pattern*]&quot;);
-        else strcpy(status, &quot;[out-of-pattern]&quot;);
-
-        // Assemble and output the reconstructed frame according to the final match.
-        dstp = dst-&gt;GetWritePtr(PLANAR_Y);
-//    if (vi.IsYV12())
-        {
-                dstpU = dst-&gt;GetWritePtr(PLANAR_U);
-                dstpV = dst-&gt;GetWritePtr(PLANAR_V);
-        }
-        if (chosen == N)
-        {
-                // The best match was with the next frame.
-                if (tff == true)
-                {
-                        BitBlt(dstp, 2 * dpitch, fnrp, 2 * pitch, w, hover2);
-                        BitBlt(dstp + dpitch, 2 * dpitch, fcrp + pitch, 2 * pitch, w, hover2);
-                        //if (vi.IsYV12())
-                        {
-                                BitBlt(dstpU, dpitch, fnrpU, pitch, w/2, h/4);
-                                BitBlt(dstpV, dpitch, fnrpV, pitch, w/2, h/4);
-                                BitBlt(dstpU + dpitch/2, dpitch, fcrpU + pitch/2, pitch, w/2, h/4);
-                                BitBlt(dstpV + dpitch/2, dpitch, fcrpV + pitch/2, pitch, w/2, h/4);
-                        }
-                }
-                else
-                {
-                        BitBlt(dstp, 2 * dpitch, fcrp, 2 * pitch, w, hplus1over2);
-                        BitBlt(dstp + dpitch, 2 * dpitch, fnrp + pitch, 2 * pitch, w, hover2);
-                        //if (vi.IsYV12())
-                        {
-                                BitBlt(dstpU, dpitch, fcrpU, pitch, w/2, h/4);
-                                BitBlt(dstpV, dpitch, fcrpV, pitch, w/2, h/4);
-                                BitBlt(dstpU + dpitch/2, dpitch, fnrpU + pitch/2, pitch, w/2, h/4);
-                                BitBlt(dstpV + dpitch/2, dpitch, fnrpV + pitch/2, pitch, w/2, h/4);
-                        }
-                }
-        }
-        else if (chosen == C)
-        {
-                // The best match was with the current frame.
-                BitBlt(dstp, 2 * dpitch, fcrp, 2 * pitch, w, hplus1over2);
-                BitBlt(dstp + dpitch, 2 * dpitch, fcrp + pitch, 2 * pitch, w, hover2);
-                //if (vi.IsYV12())
-                {
-                        BitBlt(dstpU, dpitch, fcrpU, pitch, w/2, h/4);
-                        BitBlt(dstpV, dpitch, fcrpV, pitch, w/2, h/4);
-                        BitBlt(dstpU + dpitch/2, dpitch, fcrpU + pitch/2, pitch, w/2, h/4);
-                        BitBlt(dstpV + dpitch/2, dpitch, fcrpV + pitch/2, pitch, w/2, h/4);
-                }
-        }
-        else if (tff == false)
-        {
-                // The best match was with the previous frame.
-                BitBlt(dstp, 2 * dpitch, fprp, 2 * pitch, w, hplus1over2);
-                BitBlt(dstp + dpitch, 2 * dpitch, fcrp + pitch, 2 * pitch, w, hover2);
-               // if (vi.IsYV12())
-                {
-                        BitBlt(dstpU, dpitch, fprpU, pitch, w/2, h/4);
-                        BitBlt(dstpV, dpitch, fprpV, pitch, w/2, h/4);
-                        BitBlt(dstpU + dpitch/2, dpitch, fcrpU + pitch/2, pitch, w/2, h/4);
-                        BitBlt(dstpV + dpitch/2, dpitch, fcrpV + pitch/2, pitch, w/2, h/4);
-                }
-        }
-        else
-        {
-                // The best match was with the previous frame.
-                BitBlt(dstp, 2 * dpitch, fcrp, 2 * pitch, w, hplus1over2);
-                BitBlt(dstp + dpitch, 2 * dpitch, fprp + pitch, 2 * pitch, w, hover2);
-               // if (vi.IsYV12())
-                {
-                        BitBlt(dstpU, dpitch, fcrpU, pitch, w/2, h/4);
-                        BitBlt(dstpV, dpitch, fcrpV, pitch, w/2, h/4);
-                        BitBlt(dstpU + dpitch/2, dpitch, fprpU + pitch/2, pitch, w/2, h/4);
-                        BitBlt(dstpV + dpitch/2, dpitch, fprpV + pitch/2, pitch, w/2, h/4);
-                }
-        }
-        if (guide != GUIDE_NONE) PutChosen(frame, chosen);
-
-        /* Check for manual overrides of the deinterlacing. */
-#if 0
-        overrides_p = overrides;
-        force = 0;
-        if (overrides_p != NULL)
-        {
-                while (*overrides_p &lt; 0xffffffff)
-                {
-                        // Is the frame in range...
-                        if (((unsigned int) frame &gt;= *overrides_p) &amp;&amp; ((unsigned int) frame &lt;= *(overrides_p+1)) &amp;&amp;
-                                // and is it a single specifier...
-                                (*(overrides_p+2) == 0) &amp;&amp;
-                                // and is it a deinterlacing specifier?
-                                (*(overrides_p+3) == '+' || *(overrides_p+3) == '-'))
-                        {
-                                // Yes, load the specifier and stop parsing.
-                                overrides_p += 3;
-                                force = *overrides_p;
-                                break;
-                        }
-                        // Next specification record.
-                        overrides_p += 4;
-                }
-        }
-#endif
-        // Do postprocessing if enabled and required for this frame.
-        if (post == POST_NONE || post == POST_METRICS)
-        {
-                if (force == '+') film = false;
-                else if (force == '-') film = true;
-        }
-        else if ((force == '+') ||
-                ((post == POST_FULL || post == POST_FULL_MAP || post == POST_FULL_NOMATCH || post == POST_FULL_NOMATCH_MAP)
-                         &amp;&amp; (film == false &amp;&amp; force != '-')))
-        {
-                unsigned char *dstpp, *dstpn;
-                int v1, v2, z;
-
-                if (blend == true)
-                {
-                        // Blend mode.
-                        final = data; //env-&gt;NewVideoFrame(vi);
-                        // Do first and last lines.
-                        finalp = final-&gt;GetWritePtr(PLANAR_Y);
-                        dstp = dst-&gt;GetWritePtr(PLANAR_Y);
-                        dstpn = dstp + dpitch;
-                        for (x = 0; x &lt; w; x++)
-                        {
-                                finalp[x] = (((int)dstp[x] + (int)dstpn[x]) &gt;&gt; 1);
-                        }
-                        finalp = final-&gt;GetWritePtr(PLANAR_Y) + (h-1)*dpitch;
-                        dstp = dst-&gt;GetWritePtr(PLANAR_Y) + (h-1)*dpitch;
-                        dstpp = dstp - dpitch;
-                        for (x = 0; x &lt; w; x++)
-                        {
-                                finalp[x] = (((int)dstp[x] + (int)dstpp[x]) &gt;&gt; 1);
-                        }
-                        // Now do the rest.
-                        dstp = dst-&gt;GetWritePtr(PLANAR_Y) + dpitch;
-                        dstpp = dstp - dpitch;
-                        dstpn = dstp + dpitch;
-                        finalp = final-&gt;GetWritePtr(PLANAR_Y) + dpitch;
-                        for (y = 1; y &lt; h - 1; y++)
-                        {
-                                for (x = 0; x &lt; w; x++)
-                                {
-                                        v1 = (int) dstp[x] - dthresh;
-                                        if (v1 &lt; 0) v1 = 0; 
-                                        v2 = (int) dstp[x] + dthresh;
-                                        if (v2 &gt; 235) v2 = 235; 
-                                        if ((v1 &gt; dstpp[x] &amp;&amp; v1 &gt; dstpn[x]) || (v2 &lt; dstpp[x] &amp;&amp; v2 &lt; dstpn[x]))
-                                        {
-                                                if (post == POST_FULL_MAP || post == POST_FULL_NOMATCH_MAP)
-                                                {
-                                                        if (0) //(vi.IsYUY2())
-                                                        {
-                                                                if (x &amp; 1) finalp[x] = 128;
-                                                                else finalp[x] = 235;
-                                                        }
-                                                        else
-                                                        {
-                                                                finalp[x] = 235;
-                                                        }
-                                                }
-                                                else
-                                                        finalp[x] = ((int)dstpp[x] + (int)dstpn[x] + (int)dstp[x] + (int)dstp[x]) &gt;&gt; 2;
-                                        }
-                                        else finalp[x] = dstp[x];
-                                }
-                                finalp += dpitch;
-                                dstp += dpitch;
-                                dstpp += dpitch;
-                                dstpn += dpitch;
-                        }
-
-                      //  if (vi.IsYV12())
-                        {
-                                // Chroma planes.
-                                for (z = 0; z &lt; 2; z++)
-                                {
-                                        if (z == 0)
-                                        {
-                                                // Do first and last lines.
-                                                finalp = final-&gt;GetWritePtr(PLANAR_U);
-                                                dstp = dst-&gt;GetWritePtr(PLANAR_U);
-                                                dstpn = dstp + dpitch/2;
-                                                for (x = 0; x &lt; wover2; x++)
-                                                {
-                                                        finalp[x] = (((int)dstp[x] + (int)dstpn[x]) &gt;&gt; 1);
-                                                }
-                                                finalp = final-&gt;GetWritePtr(PLANAR_U) + (hover2-1)*dpitch/2;
-                                                dstp = dst-&gt;GetWritePtr(PLANAR_U) + (hover2-1)*dpitch/2;
-                                                dstpp = dstp - dpitch/2;
-                                                for (x = 0; x &lt; wover2; x++)
-                                                {
-                                                        finalp[x] = (((int)dstp[x] + (int)dstpp[x]) &gt;&gt; 1);
-                                                }
-                                                // Now do the rest.
-                                                finalp = final-&gt;GetWritePtr(PLANAR_U) + dpitch/2;
-                                                dstp = dst-&gt;GetWritePtr(PLANAR_U) + dpitch/2;
-                                        }
-                                        else
-                                        {
-                                                // Do first and last lines.
-                                                finalp = final-&gt;GetWritePtr(PLANAR_V);
-                                                dstp = dst-&gt;GetWritePtr(PLANAR_V);
-                                                dstpn = dstp + dpitch/2;
-                                                for (x = 0; x &lt; wover2; x++)
-                                                {
-                                                        finalp[x] = (((int)dstp[x] + (int)dstpn[x]) &gt;&gt; 1);
-                                                }
-                                                finalp = final-&gt;GetWritePtr(PLANAR_V) + (hover2-1)*dpitch/2;
-                                                dstp = dst-&gt;GetWritePtr(PLANAR_V) + (hover2-1)*dpitch/2;
-                                                dstpp = dstp - dpitch/2;
-                                                for (x = 0; x &lt; wover2; x++)
-                                                {
-                                                        finalp[x] = (((int)dstp[x] + (int)dstpp[x]) &gt;&gt; 1);
-                                                }
-                                                // Now do the rest.
-                                                finalp = final-&gt;GetWritePtr(PLANAR_V) + dpitch/2;
-                                                dstp = dst-&gt;GetWritePtr(PLANAR_V) + dpitch/2;
-                                        }
-                                        dstpp = dstp - dpitch/2;
-                                        dstpn = dstp + dpitch/2;
-                                        for (y = 1; y &lt; hover2 - 1; y++)
-                                        {
-                                                for (x = 0; x &lt; wover2; x++)
-                                                {
-                                                        v1 = (int) dstp[x] - dthresh;
-                                                        if (v1 &lt; 0) v1 = 0; 
-                                                        v2 = (int) dstp[x] + dthresh;
-                                                        if (v2 &gt; 235) v2 = 235; 
-                                                        if ((v1 &gt; dstpp[x] &amp;&amp; v1 &gt; dstpn[x]) || (v2 &lt; dstpp[x] &amp;&amp; v2 &lt; dstpn[x]))
-                                                        {
-                                                                if (post == POST_FULL_MAP || post == POST_FULL_NOMATCH_MAP)
-                                                                {
-                                                                        finalp[x] = 128;
-                                                                }
-                                                                else
-                                                                        finalp[x] = ((int)dstpp[x] + (int)dstpn[x] + (int)dstp[x] + (int)dstp[x]) &gt;&gt; 2;
-                                                        }
-                                                        else finalp[x] = dstp[x];
-                                                }
-                                                finalp += dpitch/2;
-                                                dstp += dpitch/2;
-                                                dstpp += dpitch/2;
-                                                dstpn += dpitch/2;
-                                        }
-                                }
-                        }
-                        if (show == true) Show(final, frame);
-                        if (debug == true) Debug(frame);
-                        if (hints == true) WriteHints(final-&gt;GetWritePtr(PLANAR_Y), film, inpattern);
-                       // return final;
-                        vidCache-&gt;unlockAll();
-                        return 1;
-                }
-
-                // Interpolate mode.
-                // Luma plane.
-                dstp = dst-&gt;GetWritePtr(PLANAR_Y) + dpitch;
-                dstpp = dstp - dpitch;
-                dstpn = dstp + dpitch;
-                for (y = 1; y &lt; h - 1; y+=2)
-                {
-                        for (x = 0; x &lt; w; x++)
-                        {
-                                v1 = (int) dstp[x] - dthresh;
-                                if (v1 &lt; 0) v1 = 0; 
-                                v2 = (int) dstp[x] + dthresh;
-                                if (v2 &gt; 235) v2 = 235; 
-                                if ((v1 &gt; dstpp[x] &amp;&amp; v1 &gt; dstpn[x]) || (v2 &lt; dstpp[x] &amp;&amp; v2 &lt; dstpn[x]))
-                                {
-                                        if (post == POST_FULL_MAP || post == POST_FULL_NOMATCH_MAP)
-                                        {
-                                                if(0) // (vi.IsYUY2())
-                                                {
-                                                        if (x &amp; 1) dstp[x] = 128;
-                                                        else dstp[x] = 235;
-                                                }
-                                                else
-                                                {
-                                                        dstp[x] = 235;
-                                                }
-                                        }
-                                        else
-                                                dstp[x] = (dstpp[x] + dstpn[x]) &gt;&gt; 1;
-                                }
-                        }
-                        dstp += 2*dpitch;
-                        dstpp += 2*dpitch;
-                        dstpn += 2*dpitch;
-                }
-
-               // if (vi.IsYV12())
-                {
-                        // Chroma planes.
-                        for (z = 0; z &lt; 2; z++)
-                        {
-                                if (z == 0) dstp = dst-&gt;GetWritePtr(PLANAR_U) + dpitch/2;
-                                else dstp = dst-&gt;GetWritePtr(PLANAR_V) + dpitch/2;
-                                dstpp = dstp - dpitch/2;
-                                dstpn = dstp + dpitch/2;
-                                for (y = 1; y &lt; hover2 - 1; y+=2)
-                                {
-                                        for (x = 0; x &lt; wover2; x++)
-                                        {
-                                                v1 = (int) dstp[x] - dthresh;
-                                                if (v1 &lt; 0) v1 = 0; 
-                                                v2 = (int) dstp[x] + dthresh;
-                                                if (v2 &gt; 235) v2 = 235; 
-                                                if ((v1 &gt; dstpp[x] &amp;&amp; v1 &gt; dstpn[x]) || (v2 &lt; dstpp[x] &amp;&amp; v2 &lt; dstpn[x]))
-                                                {
-                                                        if (post == POST_FULL_MAP || post == POST_FULL_NOMATCH_MAP)
-                                                        {
-                                                                dstp[x] = 128;
-                                                        }
-                                                        else
-                                                                dstp[x] = (dstpp[x] + dstpn[x]) &gt;&gt; 1;
-                                                }
-                                        }
-                                        dstp += dpitch;
-                                        dstpp += dpitch;
-                                        dstpn += dpitch;
-                                }
-                        }
-                }
-        }
-
-        if (show == true) Show(dst, frame);
-        if (debug == true) Debug(frame);
-        if (hints == true) WriteHints(dst-&gt;GetWritePtr(PLANAR_Y), film, inpattern);
-        vidCache-&gt;unlockAll();
-        //return dst;
-        return 1;
-}
-void Telecide::CalculateMetrics(int frame, unsigned char *fcrp, unsigned char *fcrpU, unsigned char *fcrpV,
-                                                                        unsigned char *fprp, unsigned char *fprpU, unsigned char *fprpV)
-{
-        int x, y, p, c, tmp1, tmp2, skip;
-        bool vc;
-    unsigned char *currbot0, *currbot2, *prevbot0, *prevbot2;
-        unsigned char *prevtop0, *prevtop2, *prevtop4, *currtop0, *currtop2, *currtop4;
-        unsigned char *a0, *a2, *b0, *b2, *b4;
-        unsigned int diff, index;
-#define T 4
-
-        /* Clear the block sums. */
-        for (y = 0; y &lt; yblocks; y++)
-        {
-                for (x = 0; x &lt; xblocks; x++)
-                {
-#ifdef WINDOWED_MATCH
-                        matchp[y*xblocks+x] = 0;
-                        matchc[y*xblocks+x] = 0;
-#endif
-                        sump[y*xblocks+x] = 0;
-                        sumc[y*xblocks+x] = 0;
-                }
-        }
-
-        /* Find the best field match. Subsample the frames for speed. */
-        currbot0  = fcrp + pitch;
-        currbot2  = fcrp + 3 * pitch;
-        currtop0 = fcrp;
-        currtop2 = fcrp + 2 * pitch;
-        currtop4 = fcrp + 4 * pitch;
-        prevbot0  = fprp + pitch;
-        prevbot2  = fprp + 3 * pitch;
-        prevtop0 = fprp;
-        prevtop2 = fprp + 2 * pitch;
-        prevtop4 = fprp + 4 * pitch;
-        if (tff == true)
-        {
-                a0 = prevbot0;
-                a2 = prevbot2;
-                b0 = currtop0;
-                b2 = currtop2;
-                b4 = currtop4;
-        }
-        else
-        {
-                a0 = currbot0;
-                a2 = currbot2;
-                b0 = prevtop0;
-                b2 = prevtop2;
-                b4 = prevtop4;
-        }
-        p = c = 0;
-
-        // Calculate the field match and film/video metrics.
-        //if (vi.IsYV12()) skip = 1;
-        if(1) skip=1;
-        else skip = 1 + (chroma == false);
-        for (y = 0, index = 0; y &lt; h - 4; y+=4)
-        {
-                /* Exclusion band. Good for ignoring subtitles. */
-                if (y0 == y1 || y &lt; y0 || y &gt; y1)
-                {
-                        for (x = 0; x &lt; w;)
-                        {
-                                if (1) //vi.IsYV12())
-                                        index = (y/BLKSIZE)*xblocks + x/BLKSIZE;
-                                else
-                                        index = (y/BLKSIZE)*xblocks + x/BLKSIZE_TIMES2;
-
-                                // Test combination with current frame.
-                                tmp1 = ((long)currbot0[x] + (long)currbot2[x]);
-//                              diff = abs((long)currtop0[x] - (tmp1 &gt;&gt; 1));
-                                diff = abs((((long)currtop0[x] + (long)currtop2[x] + (long)currtop4[x])) - (tmp1 &gt;&gt; 1) - tmp1);
-                                if (diff &gt; nt)
-                                {
-                                        c += diff;
-#ifdef WINDOWED_MATCH
-                                        matchc[index] += diff;
-#endif
-                                }
-
-                                tmp1 = currbot0[x] + T;
-                                tmp2 = currbot0[x] - T;
-                                vc = (tmp1 &lt; currtop0[x] &amp;&amp; tmp1 &lt; currtop2[x]) ||
-                                         (tmp2 &gt; currtop0[x] &amp;&amp; tmp2 &gt; currtop2[x]);
-                                if (vc)
-                                {
-                                        sumc[index]++;
-                                }
-
-                                // Test combination with previous frame.
-                                tmp1 = ((long)a0[x] + (long)a2[x]);
-                                diff = abs((((long)b0[x] + (long)b2[x] + (long)b4[x])) - (tmp1 &gt;&gt; 1) - tmp1);
-                                if (diff &gt; nt)
-                                {
-                                        p += diff;
-#ifdef WINDOWED_MATCH
-                                        matchp[index] += diff;
-#endif
-                                }
-
-                                tmp1 = a0[x] + T;
-                                tmp2 = a0[x] - T;
-                                vc = (tmp1 &lt; b0[x] &amp;&amp; tmp1 &lt; b2[x]) ||
-                                         (tmp2 &gt; b0[x] &amp;&amp; tmp2 &gt; b2[x]);
-                                if (vc)
-                                {
-                                        sump[index]++;
-                                }
-
-                                x += skip;
-                                if (!(x&amp;3)) x += 4;
-                        }
-                }
-                currbot0 += pitchtimes4;
-                currbot2 += pitchtimes4;
-                currtop0 += pitchtimes4;
-                currtop2 += pitchtimes4;
-                currtop4 += pitchtimes4;
-                a0               += pitchtimes4;
-                a2               += pitchtimes4;
-                b0               += pitchtimes4;
-                b2               += pitchtimes4;
-                b4               += pitchtimes4;
-        }
-
-       // if (vi.IsYV12() &amp;&amp; chroma == true)
-        if ( chroma == true)
-        {
-                int z;
-
-                for (z = 0; z &lt; 2; z++)
-                {
-                        // Do the same for the U plane.
-                        if (z == 0)
-                        {
-                                currbot0  = fcrpU + pitchover2;
-                                currbot2  = fcrpU + 3 * pitchover2;
-                                currtop0 = fcrpU;
-                                currtop2 = fcrpU + 2 * pitchover2;
-                                currtop4 = fcrpU + 4 * pitchover2;
-                                prevbot0  = fprpU + pitchover2;
-                                prevbot2  = fprpU + 3 * pitchover2;
-                                prevtop0 = fprpU;
-                                prevtop2 = fprpU + 2 * pitchover2;
-                                prevtop4 = fprpU + 4 * pitchover2;
-                        }
-                        else
-                        {
-                                currbot0  = fcrpV + pitchover2;
-                                currbot2  = fcrpV + 3 * pitchover2;
-                                currtop0 = fcrpV;
-                                currtop2 = fcrpV + 2 * pitchover2;
-                                currtop4 = fcrpV + 4 * pitchover2;
-                                prevbot0  = fprpV + pitchover2;
-                                prevbot2  = fprpV + 3 * pitchover2;
-                                prevtop0 = fprpV;
-                                prevtop2 = fprpV + 2 * pitchover2;
-                                prevtop4 = fprpV + 4 * pitchover2;
-                        }
-                        if (tff == true)
-                        {
-                                a0 = prevbot0;
-                                a2 = prevbot2;
-                                b0 = currtop0;
-                                b2 = currtop2;
-                                b4 = currtop4;
-                        }
-                        else
-                        {
-                                a0 = currbot0;
-                                a2 = currbot2;
-                                b0 = prevtop0;
-                                b2 = prevtop2;
-                                b4 = prevtop4;
-                        }
-
-                        for (y = 0, index = 0; y &lt; hover2 - 4; y+=4)
-                        {
-                                /* Exclusion band. Good for ignoring subtitles. */
-                                if (y0 == y1 || y &lt; y0/2 || y &gt; y1/2)
-                                {
-                                        for (x = 0; x &lt; wover2;)
-                                        {
-                                                if (1) //vi.IsYV12())
-                                                        index = (y/BLKSIZE)*xblocks + x/BLKSIZE;
-                                                else
-                                                        index = (y/BLKSIZE)*xblocks + x/BLKSIZE_TIMES2;
-
-                                                // Test combination with current frame.
-                                                tmp1 = ((long)currbot0[x] + (long)currbot2[x]);
-                                                diff = abs((((long)currtop0[x] + (long)currtop2[x] + (long)currtop4[x])) - (tmp1 &gt;&gt; 1) - tmp1);
-                                                if (diff &gt; nt)
-                                                {
-                                                        c += diff;
-#ifdef WINDOWED_MATCH
-                                                        matchc[index] += diff;
-#endif
-                                                }
-
-                                                tmp1 = currbot0[x] + T;
-                                                tmp2 = currbot0[x] - T;
-                                                vc = (tmp1 &lt; currtop0[x] &amp;&amp; tmp1 &lt; currtop2[x]) ||
-                                                         (tmp2 &gt; currtop0[x] &amp;&amp; tmp2 &gt; currtop2[x]);
-                                                if (vc)
-                                                {
-                                                        sumc[index]++;
-                                                }
-
-                                                // Test combination with previous frame.
-                                                tmp1 = ((long)a0[x] + (long)a2[x]);
-                                                diff = abs((((long)b0[x] + (long)b2[x] + (long)b4[x])) - (tmp1 &gt;&gt; 1) - tmp1);
-                                                if (diff &gt; nt)
-                                                {
-                                                        p += diff;
-#ifdef WINDOWED_MATCH
-                                                        matchp[index] += diff;
-#endif
-                                                }
-
-                                                tmp1 = a0[x] + T;
-                                                tmp2 = a0[x] - T;
-                                                vc = (tmp1 &lt; b0[x] &amp;&amp; tmp1 &lt; b2[x]) ||
-                                                         (tmp2 &gt; b0[x] &amp;&amp; tmp2 &gt; b2[x]);
-                                                if (vc)
-                                                {
-                                                        sump[index]++;
-                                                }
-
-                                                x ++;
-                                                if (!(x&amp;3)) x += 4;
-                                        }
-                                }
-                                currbot0 += 4*pitchover2;
-                                currbot2 += 4*pitchover2;
-                                currtop0 += 4*pitchover2;
-                                currtop2 += 4*pitchover2;
-                                currtop4 += 4*pitchover2;
-                                a0               += 4*pitchover2;
-                                a2               += 4*pitchover2;
-                                b0               += 4*pitchover2;
-                                b2               += 4*pitchover2;
-                                b4               += 4*pitchover2;
-                        }
-                }
-        }
-
-        // Now find the blocks that have the greatest differences.
-#ifdef WINDOWED_MATCH
-        highest_matchp = 0;
-        for (y = 0; y &lt; yblocks; y++)
-        {
-                for (x = 0; x &lt; xblocks; x++)
-                {
-if (frame == 45 &amp;&amp; matchp[y * xblocks + x] &gt; 2500)
-{
-        sprintf(buf, &quot;%d/%d = %d\n&quot;, x, y, matchp[y * xblocks + x]);
-        OutputDebugString(buf);
-}
-                        if (matchp[y * xblocks + x] &gt; highest_matchp)
-                        {
-                                highest_matchp = matchp[y * xblocks + x];
-                        }
-                }
-        }
-        highest_matchc = 0;
-        for (y = 0; y &lt; yblocks; y++)
-        {
-                for (x = 0; x &lt; xblocks; x++)
-                {
-if (frame == 44 &amp;&amp; matchc[y * xblocks + x] &gt; 2500)
-{
-        sprintf(buf, &quot;%d/%d = %d\n&quot;, x, y, matchc[y * xblocks + x]);
-        OutputDebugString(buf);
-}
-                        if (matchc[y * xblocks + x] &gt; highest_matchc)
-                        {
-                                highest_matchc = matchc[y * xblocks + x];
-                        }
-                }
-        }
-#endif
-        if (post != POST_NONE)
-        {
-                highest_sump = 0;
-                for (y = 0; y &lt; yblocks; y++)
-                {
-                        for (x = 0; x &lt; xblocks; x++)
-                        {
-                                if (sump[y * xblocks + x] &gt; highest_sump)
-                                {
-                                        highest_sump = sump[y * xblocks + x];
-                                }
-                        }
-                }
-                highest_sumc = 0;
-                for (y = 0; y &lt; yblocks; y++)
-                {
-                        for (x = 0; x &lt; xblocks; x++)
-                        {
-                                if (sumc[y * xblocks + x] &gt; highest_sumc)
-                                {
-                                        highest_sumc = sumc[y * xblocks + x];
-                                }
-                        }
-                }
-        }
-#ifdef WINDOWED_MATCH
-        CacheInsert(frame, highest_matchp, highest_sump, highest_matchc, highest_sumc);
-#else
-        CacheInsert(frame, p, highest_sump, c, highest_sumc);
-#endif
-}
-bool Telecide::PredictHardYUY2(int frame, unsigned int *predicted, unsigned int *predicted_metric)
-        {
-                // Look for pattern in the actual delivered matches of the previous cycle of frames.
-                // If a pattern is found, use that to predict the current match.
-                if (guide == GUIDE_22)
-                {
-                        if (cache[(frame-cycle)%CACHE_SIZE  ].chosen == 0xff ||
-                                cache[(frame-cycle+1)%CACHE_SIZE].chosen == 0xff)
-                                return false;
-                        switch ((cache[(frame-cycle)%CACHE_SIZE  ].chosen &lt;&lt; 4) +
-                                        (cache[(frame-cycle+1)%CACHE_SIZE].chosen))
-                        {
-                        case 0x11:
-                                *predicted = C;
-                                *predicted_metric = cache[frame%CACHE_SIZE].metrics[C];
-                                break;
-                        case 0x22:
-                                *predicted = N;
-                                *predicted_metric = cache[frame%CACHE_SIZE].metrics[N];
-                                break;
-                        default: return false;
-                        }
-                }
-                else if (guide == GUIDE_32)
-                {
-                        if (cache[(frame-cycle)%CACHE_SIZE  ].chosen == 0xff ||
-                                cache[(frame-cycle+1)%CACHE_SIZE].chosen == 0xff ||
-                                cache[(frame-cycle+2)%CACHE_SIZE].chosen == 0xff ||
-                                cache[(frame-cycle+3)%CACHE_SIZE].chosen == 0xff ||
-                                cache[(frame-cycle+4)%CACHE_SIZE].chosen == 0xff)
-                                return false;
-
-                        switch ((cache[(frame-cycle)%CACHE_SIZE  ].chosen &lt;&lt; 16) +
-                                        (cache[(frame-cycle+1)%CACHE_SIZE].chosen &lt;&lt; 12) +
-                                        (cache[(frame-cycle+2)%CACHE_SIZE].chosen &lt;&lt;  8) +
-                                        (cache[(frame-cycle+3)%CACHE_SIZE].chosen &lt;&lt;  4) +
-                                        (cache[(frame-cycle+4)%CACHE_SIZE].chosen))
-                        {
-                        case 0x11122:
-                        case 0x11221:
-                        case 0x12211:
-                        case 0x12221: 
-                        case 0x21122: 
-                        case 0x11222: 
-                                *predicted = C;
-                                *predicted_metric = cache[frame%CACHE_SIZE].metrics[C];
-                                break;
-                        case 0x22111:
-                        case 0x21112:
-                        case 0x22112: 
-                        case 0x22211: 
-                                *predicted = N;
-                                *predicted_metric = cache[frame%CACHE_SIZE].metrics[N];
-                                break;
-                        default: return false;
-                        }
-                }
-                else if (guide == GUIDE_32322)
-                {
-                        if (cache[(frame-cycle)%CACHE_SIZE  ].chosen == 0xff ||
-                                cache[(frame-cycle+1)%CACHE_SIZE].chosen == 0xff ||
-                                cache[(frame-cycle+2)%CACHE_SIZE].chosen == 0xff ||
-                                cache[(frame-cycle+3)%CACHE_SIZE].chosen == 0xff ||
-                                cache[(frame-cycle+4)%CACHE_SIZE].chosen == 0xff ||
-                                cache[(frame-cycle+5)%CACHE_SIZE].chosen == 0xff)
-                                return false;
-
-                        switch ((cache[(frame-cycle)%CACHE_SIZE  ].chosen &lt;&lt; 20) +
-                                        (cache[(frame-cycle+1)%CACHE_SIZE].chosen &lt;&lt; 16) +
-                                        (cache[(frame-cycle+2)%CACHE_SIZE].chosen &lt;&lt; 12) +
-                                        (cache[(frame-cycle+3)%CACHE_SIZE].chosen &lt;&lt;  8) +
-                                        (cache[(frame-cycle+4)%CACHE_SIZE].chosen &lt;&lt;  4) +
-                                        (cache[(frame-cycle+5)%CACHE_SIZE].chosen))
-                        {
-                        case 0x111122:
-                        case 0x111221:
-                        case 0x112211:
-                        case 0x122111:
-                        case 0x111222: 
-                        case 0x112221:
-                        case 0x122211:
-                        case 0x222111: 
-                                *predicted = C;
-                                *predicted_metric = cache[frame%CACHE_SIZE].metrics[C];
-                                break;
-                        case 0x221111:
-                        case 0x211112:
-
-                        case 0x221112: 
-                        case 0x211122: 
-                                *predicted = N;
-                                *predicted_metric = cache[frame%CACHE_SIZE].metrics[N];
-                                break;
-                        default: return false;
-                        }
-                }
-#ifdef DEBUG_PATTERN_GUIDANCE
-                sprintf(buf, &quot;%d: HARD: predicted = %d\n&quot;, frame, *predicted);
-                OutputDebugString(buf);
-#endif
-                return true;
-        }
-
-struct PREDICTION *Telecide::PredictSoftYUY2(int frame)
-        {
-                // Use heuristics to look forward for a match.
-                int i, j, y, c, n, phase;
-                unsigned int metric;
-
-                pred[0].metric = 0xffffffff;
-                if (frame &lt; 0 || frame &gt; _info.nb_frames - 1 - cycle) return pred;
-
-                // Look at the next cycle of frames.
-                for (y = frame + 1; y &lt;= frame + cycle; y++)
-                {
-                        // Look for a frame where the current and next match values are
-                        // very close. Those are candidates to predict the phase, because
-                        // that condition should occur only once per cycle. Store the candidate
-                        // phases and predictions in a list sorted by goodness. The list will
-                        // be used by the caller to try the phases in order.
-                        c = cache[y%CACHE_SIZE].metrics[C]; 
-                        n = cache[y%CACHE_SIZE].metrics[N];
-                        if (c == 0) c = 1;
-                        metric = (100 * abs (c - n)) / c;
-                        phase = y % cycle;
-                        if (metric &lt; 5)
-                        {
-                                // Place the new candidate phase in sorted order in the list.
-                                // Find the insertion point.
-                                i = 0;
-                                while (metric &gt; pred[i].metric) i++;
-                                // Find the end-of-list marker.
-                                j = 0;
-                                while (pred[j].metric != 0xffffffff) j++;
-                                // Shift all items below the insertion point down by one to make
-                                // room for the insertion.
-                                j++;
-                                for (; j &gt; i; j--)
-                                {
-                                        pred[j].metric = pred[j-1].metric;
-                                        pred[j].phase = pred[j-1].phase;
-                                        pred[j].predicted = pred[j-1].predicted;
-                                        pred[j].predicted_metric = pred[j-1].predicted_metric;
-                                }
-                                // Insert the new candidate data.
-                                pred[j].metric = metric;
-                                pred[j].phase = phase;
-                                if (guide == GUIDE_32)
-                                {
-                                        switch ((frame % cycle) - phase)
-                                        {
-                                        case -4: pred[j].predicted = N; pred[j].predicted_metric = cache[frame%CACHE_SIZE].metrics[N]; break; 
-                                        case -3: pred[j].predicted = N; pred[j].predicted_metric = cache[frame%CACHE_SIZE].metrics[N]; break; 
-                                        case -2: pred[j].predicted = C; pred[j].predicted_metric = cache[frame%CACHE_SIZE].metrics[C]; break; 
-                                        case -1: pred[j].predicted = C; pred[j].predicted_metric = cache[frame%CACHE_SIZE].metrics[C]; break; 
-                                        case  0: pred[j].predicted = C; pred[j].predicted_metric = cache[frame%CACHE_SIZE].metrics[C]; break; 
-                                        case +1: pred[j].predicted = N; pred[j].predicted_metric = cache[frame%CACHE_SIZE].metrics[N]; break; 
-                                        case +2: pred[j].predicted = N; pred[j].predicted_metric = cache[frame%CACHE_SIZE].metrics[N]; break; 
-                                        case +3: pred[j].predicted = C; pred[j].predicted_metric = cache[frame%CACHE_SIZE].metrics[C]; break; 
-                                        case +4: pred[j].predicted = C; pred[j].predicted_metric = cache[frame%CACHE_SIZE].metrics[C]; break; 
-                                        }
-                                }
-                                else if (guide == GUIDE_32322)
-                                {
-                                        switch ((frame % cycle) - phase)
-                                        {
-                                        case -5: pred[j].predicted = N; pred[j].predicted_metric = cache[frame%CACHE_SIZE].metrics[N]; break; 
-                                        case -4: pred[j].predicted = N; pred[j].predicted_metric = cache[frame%CACHE_SIZE].metrics[N]; break; 
-                                        case -3: pred[j].predicted = C; pred[j].predicted_metric = cache[frame%CACHE_SIZE].metrics[C]; break; 
-                                        case -2: pred[j].predicted = C; pred[j].predicted_metric = cache[frame%CACHE_SIZE].metrics[C]; break; 
-                                        case -1: pred[j].predicted = C; pred[j].predicted_metric = cache[frame%CACHE_SIZE].metrics[C]; break; 
-                                        case  0: pred[j].predicted = C; pred[j].predicted_metric = cache[frame%CACHE_SIZE].metrics[C]; break; 
-                                        case +1: pred[j].predicted = N; pred[j].predicted_metric = cache[frame%CACHE_SIZE].metrics[N]; break; 
-                                        case +2: pred[j].predicted = N; pred[j].predicted_metric = cache[frame%CACHE_SIZE].metrics[N]; break; 
-                                        case +3: pred[j].predicted = C; pred[j].predicted_metric = cache[frame%CACHE_SIZE].metrics[C]; break; 
-                                        case +4: pred[j].predicted = C; pred[j].predicted_metric = cache[frame%CACHE_SIZE].metrics[C]; break; 
-                                        case +5: pred[j].predicted = C; pred[j].predicted_metric = cache[frame%CACHE_SIZE].metrics[C]; break; 
-                                        }
-                                }
-                        }
-#ifdef DEBUG_PATTERN_GUIDANCE
-                        sprintf(buf,&quot;%d: metric = %d phase = %d\n&quot;, frame, metric, phase);
-                        OutputDebugString(buf);
-#endif
-                }
-                return pred;
-        }
-

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidDecTelecide.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidDecTelecide.h	2007-01-13 12:08:21 UTC (rev 2720)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidDecTelecide.h	2007-01-13 16:37:32 UTC (rev 2721)
@@ -1,143 +0,0 @@
-/*
-	Telecide plugin for Avisynth -- recovers original progressive
-	frames from  telecined streams. The filter operates by matching
-	fields and automatically adapts to phase/pattern changes.
-
-	Copyright (C) 2003 Donald A. Graft
-
-	This program is free software; you can redistribute it and/or modify
-	it under the terms of the GNU General Public License as published by
-	the Free Software Foundation.
-
-	This program is distributed in the hope that it will be useful,
-	but WITHOUT ANY WARRANTY; without even the implied warranty of
-	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-	GNU General Public License for more details.
-
-	You should have received a copy of the GNU General Public License
-	along with this program; if not, write to the Free Software
-	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
-*/
-#include &quot;ADM_video/ADM_cache.h&quot;
-#undef DEBUG_PATTERN_GUIDANCE
-
-#undef WINDOWED_MATCH
-
-#define MAX_CYCLE 6
-#define BLKSIZE 24
-#define BLKSIZE_TIMES2 (2 * BLKSIZE)
-#define GUIDE_NONE 0
-#define GUIDE_32 1
-#define GUIDE_22 2
-#define GUIDE_32322 3
-#define AHEAD 0
-#define BEHIND 1
-#define POST_NONE 0
-#define POST_METRICS 1
-#define POST_FULL 2
-#define POST_FULL_MAP 3
-#define POST_FULL_NOMATCH 4
-#define POST_FULL_NOMATCH_MAP 5
-#define CACHE_SIZE 100000
-#define P 0
-#define C 1
-#define N 2
-#define PBLOCK 3
-#define CBLOCK 4
-
-#define NO_BACK 0
-#define BACK_ON_COMBED 1
-#define ALWAYS_BACK 2
-
-#define OutputDebugString(x) aprintf(&quot;%s\n&quot;,x)
-typedef uint8_t* PVideoFrame ;
-
-
-struct CACHE_ENTRY
-{
-	unsigned int frame;
-	unsigned int metrics[5];
-	unsigned int chosen;
-};
-
-struct PREDICTION
-{
-	unsigned int metric;
-	unsigned int phase;
-	unsigned int predicted;
-	unsigned int predicted_metric;
-};
-
-#define GETFRAME(g, fp) { int GETFRAMEf; uint32_t len,flags;GETFRAMEf = (g); fp=NULL;if (GETFRAMEf &lt; 0) GETFRAMEf = 0; 	else if (GETFRAMEf &gt;= _info.nb_frames) GETFRAMEf = _info.nb_frames - 1; fp=vidCache-&gt;getImage(GETFRAMEf); }
-#include &quot;ADM_video/ADM_vidDecTel_param.h&quot;
-class Telecide : public AVDMGenericVideoStream
-{
-private:
-	TelecideParam *_param;		
-	bool tff;	
-	uint32_t _lastFrame;	
-	int pitch, dpitch, pitchover2, pitchtimes4;
-	int w, h, wover2, hover2, hplus1over2, hminus2;
-	int xblocks, yblocks;
-#ifdef WINDOWED_MATCH
-	unsigned int *matchc, *matchp, highest_matchc, highest_matchp;
-#endif
-	unsigned int *sumc, *sump, highest_sumc, highest_sump;
-	int vmetric;
-	
-	bool film, override, inpattern, found;
-	int force;
-
-	
-	int chosen;
-	unsigned int p, c, pblock, cblock, lowest, predicted, predicted_metric;
-	unsigned int np, nc, npblock, ncblock;
-	float mismatch;
-	int  x, y;
-	
-	bool hard;
-	char status[80];
-
-	// Metrics cache.
-	struct CACHE_ENTRY *cache;
-
-	// Pattern guidance data.
-	int cycle;
-	struct PREDICTION pred[MAX_CYCLE+1];
-
-	// For output message formatting.
-	char buf[255];
-	
-	VideoCache	*vidCache;
-
-public:
-	
-	void CalculateMetrics(int n, unsigned char *crp, unsigned char *crpU, unsigned char *crpV, 
-				unsigned char *prp, unsigned char *prpU, unsigned char *prpV);
-	void Show(ADMImage *dst, int frame);
-	void Debug(int frame);
-
-	       Telecide(AVDMGenericVideoStream *in,CONFcouple *couples);		
-			
-	       ~Telecide();
-
-	void PutChosen(int frame, unsigned int chosen);
-	
-
-	void CacheInsert(int frame, unsigned int p, unsigned int pblock,
-				unsigned int c, unsigned int cblock);
-	
-	bool CacheQuery(int frame, unsigned int *p, unsigned int *pblock,
-				unsigned int *c, unsigned int *cblock);	
-
-	bool PredictHardYUY2(int frame, unsigned int *predicted, unsigned int *predicted_metric) ;
-	
-	struct PREDICTION *PredictSoftYUY2(int frame);
-
-	void WriteHints(unsigned char *dst, bool film, bool inpattern);
-	virtual uint8_t getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
-				ADMImage *data,uint32_t *flags);
-	char *printConf( void );
-	uint8_t configure(AVDMGenericVideoStream *in);
-	uint8_t	getCoupledConf( CONFcouple **couples);
-};

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidDeintASM.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidDeintASM.cpp	2007-01-13 12:08:21 UTC (rev 2720)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidDeintASM.cpp	2007-01-13 16:37:32 UTC (rev 2721)
@@ -1,238 +0,0 @@
-/***************************************************************************
-                          ADM_vidDeintASM.cpp  -  description
-                             -------------------
-    begin                : Tue Jan 7 2003
-    copyright            : (C) 2003 by mean
-    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
-
-    Slighlty faster ASM deinterlace
-    Blend later	
-
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#include &lt;stdio.h&gt;
-#include &lt;stdlib.h&gt;
-#include &lt;string.h&gt;
-#include &lt;ADM_assert.h&gt;
-
-#include &quot;config.h&quot;
-#include &quot;fourcc.h&quot;
-#include &quot;avio.hxx&quot;
-#include &quot;config.h&quot;
-#include &quot;avi_vars.h&quot;
-
-
-
-#include &quot;ADM_toolkit/toolkit.hxx&quot;
-#include &quot;ADM_editor/ADM_edit.hxx&quot;
-#include &quot;ADM_video/ADM_genvideo.hxx&quot;
-
-#include&quot;ADM_video/ADM_vidField.h&quot;
-
-#if defined( ARCH_X86)  || defined(ARCH_X86_64)
-//	#define DEBUG_DEINT 1
-//	#define MMX_TRACE 1
-	#include &quot;mmx_macros.h&quot;
-#include &quot;admmangle.h&quot;
-
- void myDeintASM(void);
-
- static int32_t _l_w,_l_h,_l_all;
- static uint8_t *_l_p,*_l_c,*_l_n;
- static uint8_t *_l_e,*_l_e2;
-#define EXPAND(x) (x)+((x)&lt;&lt;16)+((x)&lt;&lt;32) +((x)&lt;&lt;48)
-static mmx_t _mmTHRESH1;
-static mmx_t _mmTHRESH2;
-
-#define COMPUTE_MMX \
-punpcklbw_r2r(mm5,mm0);  /*c  expand 4 bytes -&gt; 4 word */ \
-punpcklbw_r2r(mm5,mm1);  /*p*/ \
-punpcklbw_r2r(mm5,mm2); /* n*/ \
-movq_r2r(mm0,mm3);		/* mm3 also c*/ \
-psubw_r2r(mm1,mm0) ; /* mm0=mm0-mm1 =  c-p*/ \
-psubw_r2r(mm2,mm3) ; /* mm3=mm3-mm2 =  c-n*/ \
-psraw_i2r(1,mm0); /* to protect from overflow*/ \
-psraw_i2r(1,mm3);\
-pmullw_r2r(mm0,mm3); /* mm3=(c-p)*(c-n) / 4;*/ \
-movq_r2r(mm3,mm0) ; /* mm0 also c-p*c-n */ \
-pcmpgtw_r2r(mm4,mm3); /* keep only &gt; size*/ \
-pcmpgtw_r2r(mm6,mm0); /* keep only &gt; size*/ \
-packsswb_r2r(mm5,mm0); \
-packsswb_r2r(mm5,mm3);
-
-#endif
-
-void ADMVideoFields::hasMotion_C(uint8_t *p,uint8_t *c,
-								uint8_t *n,
-								uint8_t *e,
-								uint8_t *e2
-								)
-{
-int32_t val,x,y;
-//printf(&quot;\nC \n&quot;);
-// other line
-       	for(y=_info.height-2;y&gt;0;y--)
-        	{
-               for(x=_info.width;x&gt;0;x--)
-               		{
-                   		val= (*p-*c)*(*n-*c);
-                        if(val&gt;(int32_t)(_param-&gt;motion_trigger*_param-&gt;motion_trigger))
-                        	{
-                          	*e=0xff;
-                         }
-                         if(val&gt;(int32_t)(_param-&gt;blend_trigger*_param-&gt;blend_trigger))
-                         	*e2=0xff;
-                         p++;c++;n++;e++;e2++;
-                      }
-           }
-}
-#if defined( ARCH_X86)  || defined(ARCH_X86_64)
-void ADMVideoFields::hasMotion_MMX(uint8_t *p,uint8_t *c,
-									uint8_t *n,
-									uint8_t *e,
-									uint8_t *e2
-									)
-{
-
-
-			 	_mmTHRESH1.uq=EXPAND((uint64_t ) ((_param-&gt;motion_trigger*_param-&gt;motion_trigger)&gt;&gt;2) );
-				_mmTHRESH2.uq=EXPAND((uint64_t ) ((_param-&gt;blend_trigger*_param-&gt;blend_trigger)&gt;&gt;2) );
-
-			_l_h=_info.height-2;
-			_l_w=_info.width&gt;&gt;2;
-			_l_all=_l_h*_l_w;
-			_l_p=p;
-			_l_c=c;
-			_l_n=n;
-			_l_e=e;
-			_l_e2=e2;
-//			printf(&quot;\n MMX \n&quot;);
-
-			pxor_r2r(mm5,mm5);
-			movq_m2r(_mmTHRESH1,mm4);
-			movq_m2r(_mmTHRESH2,mm6);
-			myDeintASM();
-}
-#if !defined(DEBUG_DEINT)
-void myDeintASM(void)
-{
-
-	//printf(&quot;\n using  MMX \n&quot;);
-
-
-        	{
-
-			__asm__ __volatile__ (
-				&quot;mov &quot;Mangle(_l_c)&quot;,	&quot;REG_ax&quot;\n\t&quot;
-				&quot;mov &quot;Mangle(_l_p)&quot;,	&quot;REG_bx&quot;\n\t&quot;
-				&quot;mov &quot;Mangle(_l_n)&quot;,	&quot;REG_cx&quot;\n\t&quot;
-				&quot;mov &quot;Mangle(_l_all)&quot;,	&quot;REG_si&quot;\n\t&quot;
-				&quot;7:&quot;
-				&quot;movd (&quot;REG_ax&quot;),	%%mm0\n\t&quot;
-				&quot;movd (&quot;REG_bx&quot;),	%%mm1\n\t&quot;
-				&quot;movd (&quot;REG_cx&quot;),	%%mm2\n\t&quot;
-				:
-				:
-				: &quot;eax&quot;,&quot;ebx&quot;,&quot;ecx&quot;,&quot;edx&quot;,&quot;esi&quot; 
-				);
-
-				COMPUTE_MMX;
-
-				/* store result in e, e2 */
-
-			__asm__ __volatile__(
-				&quot;mov 	&quot;Mangle(_l_e)&quot;,	&quot;REG_dx&quot;\n\t&quot;
-				&quot;movd	%%mm3,(&quot;REG_dx&quot;)\n\t&quot;
-
-				&quot;mov 	&quot;Mangle(_l_e2)&quot;,	&quot;REG_dx&quot;\n\t&quot;
-				&quot;movd	%%mm0,(&quot;REG_dx&quot;)\n\t&quot;
-
-				&quot;add 	$4,	&quot;REG_ax&quot;\n\t&quot;
-				&quot;add 	$4,	&quot;REG_bx&quot;\n\t&quot;
-				&quot;add 	$4,	&quot;REG_cx&quot;\n\t&quot;
-				&quot;add 	$4,	&quot;Mangle(_l_e)&quot;\n\t&quot;
-				&quot;add 	$4,	&quot;Mangle(_l_e2)&quot;\n\t&quot;
-				&quot;sub 	$1,	&quot;REG_si&quot;\n\t&quot;
-				&quot;jnz 7b\n\t&quot;
-
-				:
-				:
-				: &quot;eax&quot;, &quot;ebx&quot;,&quot;ecx&quot;,&quot;edx&quot;,&quot;esi&quot;
-				);
-	           	}
-	   emms();
-
-}
-#else
-/*************************************************
-***************DEBUG*************************
-**************************************************
-**************************************************/
-
-
-void myDeintASM(void)
-{
-
-int32_t x,y;
-	printf(&quot;\n using  MMX debug\n&quot;);
-
-       	for(y=_l_h;y&gt;0;y--)
-        	{
-		for(x=_l_w;x&gt;0;x--)
-               		{
-
-			__asm__ __volatile__ (
-				&quot;mov _l_c,	&quot;REG_ax&quot;\n\t&quot;
-				&quot;mov _l_p,	&quot;REG_bx&quot;\n\t&quot;
-				&quot;mov _l_n,	&quot;REG_cx&quot;\n\t&quot;
-				&quot;mov _l_w,	&quot;REG_si&quot;\n\t&quot;
-				&quot;movd (&quot;REG_ax&quot;),	%%mm0\n\t&quot;
-				&quot;movd (&quot;REG_bx&quot;),	%%mm1\n\t&quot;
-				&quot;movd (&quot;REG_cx&quot;),	%%mm2\n\t&quot;
-				:
-				:
-				: &quot;eax&quot;, &quot;ebx&quot;, &quot;ecx&quot;, &quot;edx&quot;,&quot;esi&quot;
-				);
-			emms();
-				COMPUTE_MMX;
-			emms();
-				/* store result in e, e2 */
-
-			__asm__ __volatile__(
-				&quot;mov 	_l_e,	&quot;REG_dx&quot;\n\t&quot;
-				&quot;movd	%%mm3,(&quot;REG_dx&quot;)\n\t&quot;
-				//&quot;movd	%%mm3,(%%eax)\n\t&quot;
-
-				&quot;mov 	_l_e2,	&quot;REG_dx&quot;\n\t&quot;
-				&quot;movd	%%mm0,(&quot;REG_dx&quot;)\n\t&quot;
-
-				:
-				:
-				: &quot;eax&quot;,&quot;edx&quot;,&quot;esi&quot;
-				);
-
-			emms();
-
-
-			 _l_e+=4;
-			 _l_e2+=4;
-			 _l_c+=4;
-			 _l_p+=4;
-			 _l_n+=4;
-
-           } // end for x
-	  }
-	   emms();
-}
-
-
-#endif
-#endif

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidDeinterlace.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidDeinterlace.cpp	2007-01-13 12:08:21 UTC (rev 2720)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidDeinterlace.cpp	2007-01-13 16:37:32 UTC (rev 2721)
@@ -1,114 +0,0 @@
-/***************************************************************************
-                          ADM_vidDeinterlace.cpp  -  description
-                             -------------------
-	Strongly inspired by Donal Graft deinterlacer
- 	Could be using some MMX
-  	Should be faster than the original due to YV12 colorspace
-
-20-Aug-2002 : Ported also the MMX part
-
-    begin                : Sat Apr 20 2002
-    copyright            : (C) 2002 by mean
-    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#include &lt;stdio.h&gt;
-#include &lt;stdlib.h&gt;
-#include &lt;string.h&gt;
-#include &lt;ADM_assert.h&gt;
-
-#include &quot;config.h&quot;
-#include &quot;fourcc.h&quot;
-#include &quot;avio.hxx&quot;
-#include &quot;config.h&quot;
-#include &quot;avi_vars.h&quot;
-#ifdef HAVE_ENCODER
-
-
-
-#include &quot;ADM_toolkit/toolkit.hxx&quot;
-#include &quot;ADM_editor/ADM_edit.hxx&quot;
-#include &quot;ADM_video/ADM_genvideo.hxx&quot;
-
-#include&quot;ADM_video/ADM_vidDeinterlace.h&quot;
-#include &quot;ADM_filter/video_filters.h&quot;
-
-
-static FILTER_PARAM deintParam={2,{&quot;motion_trigger&quot;,&quot;blend_trigger&quot;}};
-
-
-SCRIPT_CREATE(deinterlace_script,ADMVideoDeinterlace,deintParam);
-BUILD_CREATE(deinterlace_create,ADMVideoDeinterlace);
-//_______________________________________________________________
-
-
-ADMVideoDeinterlace::~ADMVideoDeinterlace()
-{
- 	
-	delete _uncompressed;
-	_uncompressed=NULL;
-}
-ADMVideoDeinterlace::ADMVideoDeinterlace(  AVDMGenericVideoStream *in,CONFcouple *couples)
-		:ADMVideoFields(in,couples)
-{
-
-	_uncompressed=new ADMImage(_info.width,_info.height);
-}
-
-//
-//	Basically ask a uncompressed frame from editor and ask
-//		GUI to decompress it .
-//
-
-uint8_t ADMVideoDeinterlace::getFrameNumberNoAlloc(uint32_t frame,
-				uint32_t *len,
-   				ADMImage *data,
-				uint32_t *flags)
-{
-//uint8_t *dst,*dstu,*dstv,*srcu,*srcv;
-uint32_t uvlen;
-		
-		if(frame&gt;=_info.nb_frames) return 0;
-		
-								
-		// read uncompressed frame
-       		if(!_in-&gt;getFrameNumberNoAlloc(frame, len,_uncompressed,flags)) return 0;         	
-		
-		uvlen=    _info.width*_info.height;
-		*len= (uvlen*3)&gt;&gt;1;       			
-
-		// No interleaving detected
-		if(!hasMotion(_uncompressed))
-           	{
-			data-&gt;duplicate(_uncompressed);
-			
-		}
-		else
-		{
-			//printf(&quot;Blending\n&quot;);
-			doBlend(_uncompressed,data);
-			memcpy(UPLANE(data),UPLANE(_uncompressed),uvlen&gt;&gt;2);
-			memcpy(VPLANE(data),VPLANE(_uncompressed),uvlen&gt;&gt;2);
-			data-&gt;copyInfo(_uncompressed);
-		}
-		return 1;
-}
-
-
-
-char *ADMVideoDeinterlace::printConf(void)
-{
- 		return (char *)&quot;Deinterlace&quot;;;
-}
-
-
-#endif
-

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidDeinterlace.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidDeinterlace.h	2007-01-13 12:08:21 UTC (rev 2720)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidDeinterlace.h	2007-01-13 16:37:32 UTC (rev 2721)
@@ -1,39 +0,0 @@
-/***************************************************************************
-                          ADM_vidDeinterlace.h  -  description
-                             -------------------
-    begin                : Sat Apr 20 2002
-    copyright            : (C) 2002 by mean
-    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
- #include &quot;ADM_video/ADM_vidField.h&quot;
-
- class  ADMVideoDeinterlace:public ADMVideoFields
- {
-
- protected:
-    		     							
-
- public:
- 		
-
-						ADMVideoDeinterlace(  AVDMGenericVideoStream *in,CONFcouple *setup);
-
-  			virtual 		~ADMVideoDeinterlace();
-		        virtual uint8_t 	getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
-          										ADMImage *data,uint32_t *flags);
-
-			virtual char 	*printConf(void);
-	
- }     ;
-
-
-

Modified: branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidEqualizer.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidEqualizer.cpp	2007-01-13 12:08:21 UTC (rev 2720)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidEqualizer.cpp	2007-01-13 16:37:32 UTC (rev 2721)
@@ -22,7 +22,6 @@
 #include &quot;ADM_toolkit/toolkit.hxx&quot;
 #include &quot;ADM_editor/ADM_edit.hxx&quot;
 #include &quot;ADM_video/ADM_genvideo.hxx&quot;
-#include&quot;ADM_video/ADM_vidField.h&quot;
 
 #include &quot;ADM_osSupport/ADM_debugID.h&quot;
 #define MODULE_NAME MODULE_FILTER

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidField.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidField.h	2007-01-13 12:08:21 UTC (rev 2720)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidField.h	2007-01-13 16:37:32 UTC (rev 2721)
@@ -1,83 +0,0 @@
-/***************************************************************************
-                          ADM_vidField.h  -  description
-                             -------------------
-    begin                : Sun Jan 12 2003
-    copyright            : (C) 2003 by mean
-    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#ifndef _VIDFIELD_
-#define _VIDFIELD_
- 
-#define ASM_DEINT
-#define ASM_BLEND
-
-#define THRES1 15*15
-#define THRES2 9*9
-
-typedef struct DEINT_PARAM
-{
-	  uint32_t motion_trigger;
-	  uint32_t blend_trigger;
-
-} DEINT_PARAM;
-
- class  ADMVideoFields:public AVDMGenericVideoStream
- {
-
- protected:
- 		DEINT_PARAM					*_param;
-
-      		uint8_t						*_motionmask;
-        	uint8_t						*_motionmask2;
-           	virtual char 					*printConf(void) { assert(0);return NULL;}
-           	uint8_t 						hasMotion(ADMImage *image);
-		void  							hasMotion_C(uint8_t *p,uint8_t *c,
-											uint8_t *n,
-											uint8_t *e,
-											uint8_t *e2
-											);
-		void  							  hasMotion_MMX(uint8_t *p,uint8_t *c,
-											uint8_t *n,
-											uint8_t *e,
-											uint8_t *e2
-												);
-
-           uint8_t 							doBlend(ADMImage *src,
-	   									ADMImage *dst);
-           void							blend_C(uint8_t *p,uint8_t *c,
-											uint8_t *n,
-											uint8_t *e,
-											uint8_t *f
-											);
-	  void								blend_MMX(uint8_t *p,uint8_t *c,
-													uint8_t *n,
-													uint8_t *e,
-													uint8_t *f
-											);
-
- public:
-
-
-							ADMVideoFields(  AVDMGenericVideoStream *in,CONFcouple *setup);
-  				virtual 		~ADMVideoFields();
-		     		virtual uint8_t 	getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
-          									ADMImage *data,uint32_t *flags) 
-								{
-								 UNUSED_ARG(frame); UNUSED_ARG(len); UNUSED_ARG(data);
-								 UNUSED_ARG(flags); assert(0);return 0;
-								 }
-					virtual uint8_t configure( AVDMGenericVideoStream *instream) ;
-
-					virtual uint8_t 	getCoupledConf( CONFcouple **couples);
- }     ;
-
-#endif

Deleted: branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidFields.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidFields.cpp	2007-01-13 12:08:21 UTC (rev 2720)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidFields.cpp	2007-01-13 16:37:32 UTC (rev 2721)
@@ -1,243 +0,0 @@
-/***************************************************************************
-                          ADM_vidFields.cpp  -  description
-                             -------------------
-    begin                : Sun Jan 12 2003
-    copyright            : (C) 2003 by mean
-    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#include &lt;stdio.h&gt;
-#include &lt;stdlib.h&gt;
-#include &lt;string.h&gt;
-#include &lt;ADM_assert.h&gt;
-
-#include &quot;config.h&quot;
-#include &quot;fourcc.h&quot;
-#include &quot;avio.hxx&quot;
-#include &quot;config.h&quot;
-#include &quot;avi_vars.h&quot;
-#ifdef HAVE_ENCODER
-
-
-
-#include &quot;ADM_toolkit/toolkit.hxx&quot;
-#include &quot;ADM_editor/ADM_edit.hxx&quot;
-#include &quot;ADM_video/ADM_genvideo.hxx&quot;
-
-#include&quot;ADM_video/ADM_vidField.h&quot;
-#include &quot;ADM_osSupport/ADM_cpuCap.h&quot;
-//_______________________________________________________________
-
-ADMVideoFields::ADMVideoFields(
-									AVDMGenericVideoStream *in,CONFcouple *couples)
-{
-
-
-  	_in=in;		
-   	memcpy(&amp;_info,_in-&gt;getInfo(),sizeof(_info));  		
-	
-					
-	_motionmask=new uint8_t [_in-&gt;getInfo()-&gt;width*_in-&gt;getInfo()-&gt;height];
-	ADM_assert(_motionmask);
-	_motionmask2=new uint8_t [_in-&gt;getInfo()-&gt;width*_in-&gt;getInfo()-&gt;height];
-	ADM_assert(_motionmask2);
-
-	_info.encoding=1;
-	if(couples)
-	{
-			_param=NEW(DEINT_PARAM);
-			GET(motion_trigger);
-			GET(blend_trigger);
-	}
-	else
-	{
-			_param=new( DEINT_PARAM);
-			_param-&gt;blend_trigger=9;
-			_param-&gt;motion_trigger=15;
-	}
-}
-
-uint8_t	ADMVideoFields::getCoupledConf( CONFcouple **couples)
-{
-
-			ADM_assert(_param);
-			*couples=new CONFcouple(2);
-
-#define CSET(x)  (*couples)-&gt;setCouple((char *)#x,(_param-&gt;x))
-	CSET(motion_trigger);
-	CSET(blend_trigger);
-			return 1;
-
-}
-
-ADMVideoFields::~ADMVideoFields()
-{
- 	
-	delete []_motionmask ;
-	delete []_motionmask2;
- 	DELETE(_param);
-	
-}
-//
-//	Return 1 if seen as interleaved
-//		0 is seen as progressiv
-//
-//		Check if in a 8x8 square n, n+1 , n+2 lines differ too much
-//
-uint8_t ADMVideoFields::hasMotion(ADMImage *image)
-{
-    	uint32_t w,h,x,y;
-      	uint8_t *n,*p,*c,*e,*e2;
-	uint8_t *yplane=YPLANE(image);
-       
-
-     	w=_info.width;
-     	h=_info.height;
-
-
-
-      	memset(_motionmask,0,w*h);
-      	memset(_motionmask2,0,w*h);
-
-       // First line
-       	memset(_motionmask,0xff,w);
-          	memset(_motionmask2,0xff,w);
-
-        	p=yplane;
-         	c=p+w;
-          	n=c+w;
-           e=_motionmask+w; 	
-           e2=_motionmask2+w; 	
-  //___________________ C version of motion detection ________________________
-       // other line
-#if (defined( ARCH_X86)  || defined(ARCH_X86_64)) &amp;&amp; defined(ASM_DEINT)
-       if(CpuCaps::hasMMX())  
-      	hasMotion_MMX(p,c,n,e,e2);
-       else
-#endif 
-      	 hasMotion_C(p,c,n,e,e2);
-       
-      
-      
-//_______________________________
-           // last line
-           memset(e,0xff,w);
-           memset(e2,0xff,w);
-
-           // Count    how many tagged as !=
-           p=_motionmask;
-           c=p+w;;
-           n=c+w;;
-
-           // 8x8 square
-           uint8_t *box=new uint8_t[ ((h+8)&gt;&gt;3)*((w+8)&gt;&gt;3)]; // ???
-           uint32_t boxx,boxy;
-
-           memset(box,0,  ((h+8)&gt;&gt;3)*((w+8)&gt;&gt;3));
-           for(y=h-2;y&gt;0;y--)
-           	{
-                     boxy=(y&gt;&gt;3)*(w&gt;&gt;3);
-                     for(x=w;x&gt;0;x--)
-                     	{
-                             boxx=boxy+(x&gt;&gt;3);
-                             if( *c&amp;&amp;*p&amp;&amp;*n)
-                             	{
-                                 	box[boxx]++;
-                                }
-                                c++;n++;p++;
-                        }
-              }
-
-              // reached level ?
-              for(x=   ((h+8)&gt;&gt;3)*((w+8)&gt;&gt;3);x&gt;0;x--)
-              {
-                     	if (box[x]&gt;15)
-                      	{
-                          	
-                            	delete [] box;
-                             	return 1;
-                         }
-
-
-                }
-                       	delete [] box;
-                        	return 0;
-
-}
-
-uint8_t ADMVideoFields::doBlend(ADMImage *src,ADMImage *dst)
-{
-   	uint32_t w,h,x; //,y;
-      	uint8_t *n,*p,*c,*e2;
-	uint8_t *f;
-	uint8_t *yplane;
-
-
-	
-     	w=_info.width;
-     	h=_info.height;
-
-	f=YPLANE(dst);
-	yplane=YPLANE(src);
-	p=yplane;	
-	c=yplane;
-	n=c+w;
-	e2=_motionmask2+w; 
-	
-	// First line
-	// always blend
-	for(x=w;x&gt;0;x--)
-	{
-		*f++=(*c+*n)&gt;&gt;1;
-		n++;
-		c++;
-	}
-#if (defined( ARCH_X86)  || defined(ARCH_X86_64)) &amp;&amp; defined(ASM_BLEND)
-       if(CpuCaps::hasMMX())               
-              blend_MMX(p,c,n,e2,f);
-        else
-#endif
-              blend_C(p,c,n,e2,f);
-              // Last line
-            for(x=w;x&gt;0;x--)
-            {
-               	*f++=(*c+*p)&gt;&gt;1;
-                	  p++;
-                   c++;
-
-              }
-
-              return 1;
-
-
-
-}
-uint8_t ADMVideoFields::configure( AVDMGenericVideoStream *instream)
-{
-int i,j;
-	_in=instream;
-	i=(int)_param-&gt;motion_trigger;
-	j=(int)_param-&gt;blend_trigger;
-	if(GUI_getIntegerValue(&amp;i,0,255,&quot;Motion  Threshold&quot;))
-	{
-		if(GUI_getIntegerValue(&amp;j,0,255,&quot;Blend  Threshold&quot;))
-		{
-			_param-&gt;motion_trigger=(uint8_t)i;
-			_param-&gt;blend_trigger=(uint8_t)j;
-			return 1;
-		}
-	} 
-
-	return 0;    
-}      
-
-
-#endif

Modified: branches/avidemux_2.4_branch/avidemux/ADM_video/Makefile.am
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/Makefile.am	2007-01-13 12:08:21 UTC (rev 2720)
+++ branches/avidemux_2.4_branch/avidemux/ADM_video/Makefile.am	2007-01-13 16:37:32 UTC (rev 2721)
@@ -6,8 +6,7 @@
 libADM_video_a_METASOURCES = AUTO
 #INCLUDES = $(all_includes) 
 
-libADM_video_a_SOURCES = ADM_vidFields.cpp \
- ADM_vidDeintASM.cpp \
+libADM_video_a_SOURCES = \
  ADM_vidCached.cpp \
  ADM_vidPartial.cpp \
  ADM_vidFont.cpp \
@@ -15,7 +14,6 @@
  ADM_vidContrast.cpp \
 	ADM_resizeter.cpp \
  ADM_vidCrop.cpp \
- ADM_vidDeinterlace.cpp \
  ADM_vidNull.cpp \
 	ADM_vidResize.cpp \
 	ADM_vidClean.cpp \
@@ -33,14 +31,11 @@
  ADM_vidIVTC.cpp \
  ADM_vidIVTC.h ADM_interlaced.cpp \
 	ADM_interlaced.h \
- ADM_vidBlend.cpp \
  ADM_vidRaw.cpp \
 	ADM_vidSRTRender.cpp \
  ADM_vidSRTload.cpp \
 	ADM_mpdetc.cpp \
- ADM_vidDecTelecide.cpp \
- ADM_vidDecTelecide.h ADM_cache.cpp \
- ADM_vidDecDec.cpp \
+ ADM_cache.cpp \
  ADM_vidEqualizer.cpp \
  ADM_vidVobsub.cpp \
  ADM_vobsubinfo.cpp \
@@ -61,13 +56,13 @@
 				
 
 
-EXTRA_DIST =  ADM_cache.cpp  ADM_vidDecDec_param.h \
-ADM_cache.h  ADM_vidDecTel_param.h \
-ADM_confCouple.h ADM_vidDecTelecide.cpp  ADM_vidNull.cpp \
-ADM_confCouples.cpp  ADM_vidDecTelecide.h  \
-ADM_genvideo.cpp ADM_vidDeintASM.cpp \
-ADM_genvideo.hxx ADM_vidDeinterlace.cpp  ADM_vidPartial.cpp \
-ADM_vidDeinterlace.h  ADM_vidPartial.h \
+EXTRA_DIST =  ADM_cache.cpp  \
+ADM_cache.h  \
+ADM_confCouple.h ADM_vidNull.cpp \
+ADM_confCouples.cpp  \
+ADM_genvideo.cpp \
+ADM_genvideo.hxx ADM_vidPartial.cpp \
+ADM_vidPartial.h \
 ADM_vidDelta.cpp  ADM_vidPartial_param.h \
 ADM_guiResize.cpp   ADM_vidRaw.cpp \
 ADM_interlaced.cpp  \
@@ -82,13 +77,12 @@
 ADM_vidFieldUnblend.cpp ADM_vidSRTload.cpp \
 ADM_vidASharp_param.h  ADM_vidFieldUtil.cpp  \
 ADM_vidFieldUtil.h  \
-ADM_vidFields.cpp \
 ADM_vidAnimated.cpp  \
 ADM_vidAnimated.h  \
 ADM_vidAnimated_param.h   \
 ADM_vidAsharp.cpp   \
 ADM_vidFont.cpp \
-ADM_vidBlend.cpp ADM_vidFont.h \
+ADM_vidFont.h \
 ADM_vidCNR2.cpp  \
 ADM_vidCNR2_param.h  ADM_vidHue.cpp  ADM_vidTDeint_param.h \
 ADM_vidCached.cpp  ADM_vidHue.h  ADM_vidTdeint.cpp \
@@ -106,7 +100,7 @@
 ADM_vidContrast.h  ADM_vidMPdelogo.h \
 ADM_vobsubinfo.cpp \
 ADM_vidCrop.cpp  ADM_vidMSmooth_param.h  ADM_vobsubinfo.h \
-ADM_vidDecDec.cpp  swscale_internal.h \
+swscale_internal.h \
 ADM_vidTdeint_util.txt ADM_vidASS.h ADM_vidASS.cpp \
 ADM_vidAss_Params.h mmx_macros.h
 
@@ -114,6 +108,6 @@
 INCLUDES = $(all_includes) -I../ADM_libraries -I../ADM_libraries/ADM_utilities -I../ADM_libraries/ADM_lavutil \
 			 $(FREETYPE_CFLAGS) $(ALTIVEC_SWITCH) -I../ADM_userInterfaces/ADM_commonUI -I../ADM_inputs
 noinst_HEADERS = ADM_mpdetc.h \
-					  ADM_cache.h ADM_vidDecTel_param.h ADM_vidDecDec_param.h \
+					  ADM_cache.h \
 					ADM_vidMSmooth_param.h ADM_vidEqualizer.h ADM_vobsubinfo.h ADM_vidVobSub.h \
 		ADM_vidEq2.h ADM_vidASS.h

Copied: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidBlend.cpp (from rev 2489, branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidBlend.cpp)
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidBlend.cpp	2006-10-31 15:59:58 UTC (rev 2489)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidBlend.cpp	2007-01-13 16:37:32 UTC (rev 2721)
@@ -0,0 +1,187 @@
+/***************************************************************************
+                          ADM_vidBlend.cpp  -  description
+                             -------------------
+    begin                : Tue Jan 7 2003
+    copyright            : (C) 2003 by mean
+    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
+
+    Slighlty faster ASM deinterlace
+    Blend later
+
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include &lt;stdio.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;string.h&gt;
+#include &lt;ADM_assert.h&gt;
+
+#include &quot;config.h&quot;
+#include &quot;fourcc.h&quot;
+#include &quot;avio.hxx&quot;
+#include &quot;config.h&quot;
+#include &quot;avi_vars.h&quot;
+
+
+
+#include &quot;ADM_toolkit/toolkit.hxx&quot;
+#include &quot;ADM_editor/ADM_edit.hxx&quot;
+#include &quot;ADM_video/ADM_genvideo.hxx&quot;
+
+#include&quot;ADM_vidField.h&quot;
+
+#include &quot;admmangle.h&quot;
+
+
+ static int32_t _l_w,_l_h;
+ static uint8_t *_l_p,*_l_c,*_l_n;
+ static uint8_t *_l_e,*_l_e2;
+#define EXPAND(x) (x)+((x)&lt;&lt;16)+((x)&lt;&lt;32) +((x)&lt;&lt;48)
+static uint64_t  __attribute__((used)) _mmTHRESH1=EXPAND((uint64_t )THRES1);
+static uint64_t  __attribute__((used)) full_ones=0xFFFFFFFFFFFFFFFFLL;
+
+
+static void myBlendASM(void);
+
+void ADMVideoFields::blend_C(uint8_t *p,uint8_t *c,
+							uint8_t *n,
+							uint8_t *e,
+							uint8_t *f
+							)
+{
+uint32_t x,y;
+ for(y=_info.height-2;y&gt;0;y--)
+           	{
+              for(x=_info.width;x&gt;0;x--)
+              {
+
+                    if(*e)
+                    	{
+                       	*f=(*c&gt;&gt;1) + ((*n+*p)&gt;&gt;2);
+                       //	*f=255;
+
+                       }
+                       else
+                       		*f=*c;
+						//			*f=0;
+
+                       c++;n++;p++;e++;f++;
+                 }
+              }
+}
+#if defined( ARCH_X86)  || defined(ARCH_X86_64)
+void ADMVideoFields::blend_MMX(uint8_t *p,uint8_t *c,
+																							uint8_t *n,
+																							uint8_t *e,
+																							uint8_t *f
+																							)
+{
+      _l_h=_info.height-2;
+			_l_w=_info.width&gt;&gt;2;
+			_l_p=p;
+			_l_c=c;
+			_l_n=n;
+			_l_e=e;
+			_l_e2=f;
+			myBlendASM();
+}
+
+void myBlendASM(void)
+{
+	__asm__ (
+//&quot;StartASM4: \n\t&quot;
+&quot;push 				&quot;REG_di&quot;\n\t&quot;
+&quot;push 				&quot;REG_si&quot;\n\t&quot;
+&quot;push 				&quot;REG_ax&quot;\n\t&quot;
+
+&quot;mov (%0), &quot;REG_ax&quot; \n\t&quot;
+&quot;mov &quot;Mangle(_l_p)&quot;, &quot;REG_ax&quot; \n\t&quot;
+&quot;mov &quot;Mangle(_l_c)&quot;, &quot;REG_bx&quot; \n\t&quot;
+&quot;mov &quot;Mangle(_l_n)&quot;, &quot;REG_cx&quot; \n\t&quot;
+&quot;mov &quot;Mangle(_l_e)&quot;, &quot;REG_si&quot; \n\t&quot;
+&quot;mov &quot;Mangle(_l_e2)&quot;, &quot;REG_di&quot; \n\t&quot;
+&quot;movq &quot;Mangle(full_ones)&quot;,%%mm7 \n\t&quot;
+&quot;pxor	   %%mm6,%%mm6 \n\t&quot;
+
+&quot;DHCOLB%=: \n\t&quot; // loop
+&quot;mov &quot;Mangle(_l_w)&quot;, &quot;REG_dx&quot; \n\t&quot;                // loop one line
+
+&quot;DHLineB%=:  \n\t&quot;
+
+&quot;movd (&quot;REG_bx&quot;),%%mm0 \n\t&quot;     // mm0 &lt;- c
+&quot;movd (&quot;REG_ax&quot;),%%mm1 \n\t&quot;     // mm1 &lt;- p
+&quot;movd (&quot;REG_cx&quot;),%%mm2 \n\t&quot;     // mm2 &lt;- n
+&quot;movd (&quot;REG_si&quot;),%%mm3 \n\t&quot;     // mm2 &lt;- e
+
+
+&quot;punpcklbw %%mm6, %%mm0 \n\t&quot;
+&quot;punpcklbw %%mm6, %%mm1 \n\t&quot;
+&quot;punpcklbw %%mm6, %%mm2 \n\t&quot;
+&quot;punpcklbw %%mm6, %%mm3 \n\t&quot;
+&quot;movq      %%mm6, %%mm4 \n\t&quot;
+
+//&quot;movq %%mm3,S0 \n\t&quot;
+
+// make 16 bits mask
+&quot;psllw     $8, %%mm4 \n\t&quot;
+&quot;por	   %%mm4,%%mm3 \n\t&quot;  // mask in m3
+//&quot;movq %%mm3,S1 \n\t&quot;
+//&quot;movq %%mm2,S2 \n\t&quot;
+//&quot;movq %%mm1,S3 \n\t&quot;
+
+
+// compute average of p &amp; n in mm4
+&quot;paddw     %%mm1,%%mm2 \n\t&quot;
+&quot;paddw     %%mm0,%%mm2 \n\t&quot;
+&quot;paddw     %%mm0,%%mm2 \n\t&quot;
+//&quot;movq 	   %%mm2,S4 \n\t&quot;
+
+&quot;psrlw     $2,%%mm2 \n\t&quot;     //mm2 is averafe of p &amp; n &amp; c -&gt; replacement value
+//&quot;movq      %%mm2,S5 \n\t&quot;
+
+&quot;pand     %%mm3,%%mm2 \n\t&quot;
+//&quot;movq     %%mm2,S6 \n\t&quot;
+
+// compute inverse value
+&quot;pxor     %%mm7,%%mm3 \n\t&quot; // inverse mask in m3
+//&quot;movq     %%mm3,S7 \n\t&quot;
+
+&quot;pand     %%mm3,%%mm0 \n\t&quot; // right value in m0
+//&quot;movq     %%mm0,S8 \n\t&quot;
+
+&quot;por     %%mm2,%%mm0 \n\t&quot; // ok, now right
+//&quot;movq     %%mm0,S9 \n\t&quot;
+
+&quot;packuswb  %%mm6, %%mm0 \n\t&quot;          // pack
+//&quot;movq %%mm0,S10 \n\t&quot;
+
+&quot;movd	   %%mm0, (&quot;REG_di&quot;) \n\t&quot; // store
+
+//
+//
+// next
+&quot;add       $4,&quot;REG_ax&quot; \n\t&quot;
+&quot;add       $4,&quot;REG_bx&quot; \n\t&quot;
+&quot;add       $4,&quot;REG_cx&quot; \n\t&quot;
+&quot;add       $4,&quot;REG_si&quot; \n\t&quot;
+&quot;add       $4,&quot;REG_di&quot; \n\t&quot;
+&quot;sub       $1,&quot;REG_dx&quot;	\n\t&quot;
+&quot;jne        DHLineB%= \n\t&quot;   // next
+&quot;sub       $1,&quot;Mangle(_l_h)&quot;  \n\t&quot; // next line
+&quot;jne        DHCOLB%= \n\t&quot;
+&quot;pop 				&quot;REG_ax&quot;\n\t&quot;
+&quot;pop 				&quot;REG_si&quot;\n\t&quot;
+&quot;pop 				&quot;REG_di&quot;\n\t&quot;
+&quot; emms       \n\t&quot;
+ : /* no output */
+ :  &quot;r&quot;(&amp;_mmTHRESH1)
+ :   &quot;ebx&quot;, &quot;ecx&quot;, &quot;edx&quot;);
+}
+#endif

Modified: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidDGbob.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidDGbob.cpp	2007-01-13 12:08:21 UTC (rev 2720)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidDGbob.cpp	2007-01-13 16:37:32 UTC (rev 2721)
@@ -36,7 +36,6 @@
 #include &quot;ADM_toolkit/toolkit.hxx&quot;
 #include &quot;ADM_editor/ADM_edit.hxx&quot;
 #include &quot;ADM_video/ADM_genvideo.hxx&quot;
-#include&quot;ADM_video/ADM_vidField.h&quot;
 #include&quot;ADM_video/ADM_cache.h&quot;
 
 #include &quot;ADM_osSupport/ADM_debugID.h&quot;
@@ -74,7 +73,6 @@
 SCRIPT_CREATE(dgbob_script,DGbob,dgbobParam);
 
 /*************************************/
-extern uint8_t DIA_getDGbob(DGBobparam *param);
 uint8_t DGbob::configure(AVDMGenericVideoStream *in)
 {
         _in=in;

Copied: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidDecDec.cpp (from rev 2489, branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidDecDec.cpp)
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidDecDec.cpp	2006-10-31 15:59:58 UTC (rev 2489)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidDecDec.cpp	2007-01-13 16:37:32 UTC (rev 2721)
@@ -0,0 +1,1663 @@
+/***************************************************************************
+                          ADM_vidDecTelecide  -  description
+                             -------------------
+    
+    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
+
+    Port of Donal Graft Decimate which is (c) Donald Graft
+    <A HREF="http://www.neuron2.net">http://www.neuron2.net</A>
+    <A HREF="http://puschpull.org/avisynth/decomb_reference_manual.html">http://puschpull.org/avisynth/decomb_reference_manual.html</A>
+
+ ***************************************************************************/
+
+/*
+	Decimate plugin for Avisynth -- performs 1-in-N
+	decimation on a stream of progressive frames, which are usually
+	obtained from the output of my Telecide plugin for Avisynth.
+	For each group of N successive frames, this filter deletes the
+	frame that is most similar to its predecessor. Thus, duplicate
+	frames coming out of Telecide can be removed using Decimate. This
+	filter adjusts the frame rate of the clip as
+	appropriate. Selection of the cycle size is selected by specifying
+	a parameter to Decimate() in the Avisynth scipt.
+
+	Copyright (C) 2003 Donald A. Graft
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program; if not, write to the Free Software
+	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+
+	The author can be contacted at:
+	Donald Graft
+	<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">neuron2 at attbi.com.</A>
+*/
+#include &quot;config.h&quot;
+#include &lt;stdio.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;string.h&gt;
+#include &lt;ADM_assert.h&gt;
+
+#include &quot;config.h&quot;
+#include &quot;fourcc.h&quot;
+#include &quot;avio.hxx&quot;
+#include &quot;avi_vars.h&quot;
+
+#include &quot;ADM_toolkit/toolkit.hxx&quot;
+#include &quot;ADM_editor/ADM_edit.hxx&quot;
+#include &quot;ADM_video/ADM_genvideo.hxx&quot;
+#include&quot;ADM_vidField.h&quot;
+#include&quot;ADM_video/ADM_cache.h&quot;
+
+#include &quot;ADM_osSupport/ADM_debugID.h&quot;
+#define MODULE_NAME MODULE_FILTER
+#include &quot;ADM_osSupport/ADM_debug.h&quot;
+
+#include &quot;ADM_osSupport/ADM_cpuCap.h&quot;
+#include &quot;ADM_userInterfaces/ADM_commonUI/DIA_factory.h&quot;
+
+
+#define PROGRESSIVE  0x00000001
+#define MAGIC_NUMBER (0xdeadbeef)
+#define IN_PATTERN   0x00000002
+
+extern uint8_t 	PutHintingData(unsigned char *video, unsigned int hint);
+extern uint8_t 	GetHintingData(unsigned char *video, unsigned int *hint);
+extern void 	BitBlt(uint8_t * dstp, int dst_pitch, const uint8_t* srcp,
+            		int src_pitch, int row_size, int height);
+
+#define DrawString drawString
+
+#ifdef USE_SSE
+	#define DECIMATE_MMX_BUILD_PLANE 1
+	#define DECIMATE_MMX_BUILD	 1
+#endif
+
+#ifdef DECIMATE_MMX_BUILD_PLANE
+static void isse_blend_decimate_plane(uint8_t * dst, uint8_t* src,  uint8_t* src_next, 
+			int w, int h);
+int isse_scenechange_32(const uint8_t *c_plane,const  uint8_t *tplane, int height, int width) ;	
+int isse_scenechange_16(const uint8_t *c_plane,const  uint8_t *tplane, int height, int width) ;
+int isse_scenechange_8(const uint8_t *c_plane,const  uint8_t *tplane, int height, int width) ;
+#endif
+
+
+#define OutputDebugString(x) aprintf(&quot;%s\n&quot;,x)
+//________________________________
+#define MAX_CYCLE_SIZE 25
+#define MAX_BLOCKS 50
+
+#define GETFRAME(g, fp) \
+{ \
+	int GETFRAMEf; \
+	GETFRAMEf = (g); \
+	if (GETFRAMEf &lt; 0) GETFRAMEf = 0; \
+	if (GETFRAMEf &gt; num_frames_hi - 1) GETFRAMEf = num_frames_hi - 1; \
+	(fp) = vidCache-&gt;getImage(GETFRAMEf); \
+}
+//________________________________
+#include &quot;ADM_vidDecDec_param.h&quot;
+#include &quot;ADM_filter/video_filters.h&quot;
+
+
+static FILTER_PARAM decdecParam={5,{&quot;cycle&quot;,&quot;mode&quot;,&quot;quality&quot;,&quot;threshold&quot;,&quot;threshold2&quot;}};
+
+
+
+
+extern uint8_t DIA_getDecombDecimate(DECIMATE_PARAM *param);
+
+#define BLKSIZE 32
+//________________________________
+/* Decimate 1-in-N implementation. */
+class Decimate : public AVDMGenericVideoStream
+{
+	int 			num_frames_hi;
+	
+	DECIMATE_PARAM 		*_param;
+	
+	int last_request, last_result;
+	bool last_forced;
+	double last_metric;
+	double metrics[MAX_CYCLE_SIZE];
+	double showmetrics[MAX_CYCLE_SIZE];
+	int Dprev[MAX_CYCLE_SIZE];
+	int Dcurr[MAX_CYCLE_SIZE];
+	int Dnext[MAX_CYCLE_SIZE];
+	int Dshow[MAX_CYCLE_SIZE];
+	unsigned int hints[MAX_CYCLE_SIZE];
+	bool hints_invalid;
+	bool all_video_cycle;
+	bool firsttime;
+	int heightY, row_sizeY, pitchY;
+	int heightUV, row_sizeUV, pitchUV;
+	int pitch, row_size, height;
+	int xblocks, yblocks;
+	unsigned int *sum, div;
+	bool debug, show;
+	
+	VideoCache	*vidCache;
+	
+public:
+				
+			Decimate(AVDMGenericVideoStream *in,CONFcouple *couples);    
+			~Decimate(void);
+	uint8_t  	getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
+				ADMImage *data,uint32_t *flags);
+
+    	uint8_t   	*GetFrame(int n);
+	void   		DrawShow(ADMImage  *src, int useframe, bool forced, int dropframe,
+		                              double metric, int inframe );
+        void   		FindDuplicate(int frame, int *chosen, double *metric, bool *forced   );
+    	void   		FindDuplicate2(int frame, int *chosen, bool *forced );
+    	void   		FindDuplicateYUY2(int frame, int *chosen, double *metric, bool *force);
+    	void   		FindDuplicate2YUY2(int frame, int *chosen, bool *forced );
+	
+	char 		*printConf( void );
+	uint8_t 	configure(AVDMGenericVideoStream *in);
+	uint8_t		getCoupledConf( CONFcouple **couples);
+};
+
+
+
+BUILD_CREATE(decimate_create,Decimate);
+
+/*
+PClip _child, int _cycle, int _mode, double _threshold, double _threshold2,
+				int _quality, const char * _ovr, bool _show, bool _debug, IScriptEnvironment* env) 
+GenericVideoFilter(_child), cycle(_cycle), mode(_mode), threshold(_threshold),
+threshold2(_threshold2), quality(_quality), ovr(_ovr), show(_show), debug(_debug)
+*/	
+SCRIPT_CREATE(decimate_script,Decimate,decdecParam);
+uint8_t Decimate::configure(AVDMGenericVideoStream *in)
+{
+	_in=in;
+#define PX(x) &amp;(_param-&gt;x)
+#define SZT(x) sizeof(x)/sizeof(diaMenuEntry *)
+        
+    ELEM_TYPE_FLOAT t1=(ELEM_TYPE_FLOAT)_param-&gt;threshold;
+    ELEM_TYPE_FLOAT t2=(ELEM_TYPE_FLOAT)_param-&gt;threshold2;
+
+         diaMenuEntry tMode[]={
+                             {0, _(&quot;Discard Closer&quot;),NULL},
+                             {1, _(&quot;Replace (interpolate)&quot;),NULL},
+                             {2, _(&quot;Discard longer dupe (anim&#233;s)&quot;),NULL},
+                             {3, _(&quot;PullDown dupe removal&quot;),NULL}
+                          };
+         diaMenuEntry tQuality[]={
+                             {0, _(&quot;Fastest (no chroma, partial luma)&quot;),NULL},
+                             {1, _(&quot;Fast (parial luma and chroma)&quot;),NULL},
+                             {2, _(&quot;Medium (full luma no chroma)&quot;),NULL},
+                             {3, _(&quot;Slow (full luma and chroma)&quot;),NULL}
+                          };
+  
+    
+    diaElemMenu menuMode(PX(mode),_(&quot;Mode&quot;), 4,tMode);
+    diaElemMenu menuQuality(PX(quality),_(&quot;Quality&quot;), 4,tQuality);
+    diaElemFloat menuThresh1(&amp;t1,_(&quot;Threshold 1&quot;),0,100.);
+    diaElemFloat menuThresh2(&amp;t2,_(&quot;Threshold 2&quot;),0,100.);
+    diaElemUInteger cycle(PX(cycle),&quot;Cycle&quot;,2,40);
+    
+    diaElem *elems[]={&amp;cycle,&amp;menuMode,&amp;menuQuality,&amp;menuThresh1,&amp;menuThresh2};
+    
+  if(diaFactoryRun(&quot;Decombe Decimate&quot;,5,elems))
+  {
+    _param-&gt;threshold=(double )t1;
+    _param-&gt;threshold2=(double )t2;
+    return 1; 
+  }
+  return 0;        
+        
+        
+}
+
+char *Decimate::printConf( void )
+{
+ 	static char buf[50];
+
+	ADM_assert(_param);
+ 	sprintf((char *)buf,&quot; Decomb Decimate cycle:%d&quot;,_param-&gt;cycle);
+        return buf;
+}
+
+
+Decimate::Decimate(AVDMGenericVideoStream *in,CONFcouple *couples)		
+{
+{
+		
+		int count = 0;
+		char buf[80];
+		unsigned int *p;
+
+		_in=in;		
+   		memcpy(&amp;_info,_in-&gt;getInfo(),sizeof(_info));    
+  		_info.encoding=1;
+		_uncompressed=NULL;		
+  		_info.encoding=1;
+		
+		//		
+		// Init here
+		debug=0;
+		show=0;		
+#ifdef USE_SSE	
+		if(CpuCaps::hasSSE())
+		{
+			printf(&quot;Decimate:SSE enabled\n&quot;);
+		}
+#endif
+		//
+		_param=new DECIMATE_PARAM;
+		if(couples)
+		{
+			GET(cycle);
+			GET(mode);
+			GET(quality);
+			GET(threshold);
+			GET(threshold2);
+			
+		}
+		else // Default
+  		{
+			_param-&gt;cycle=5;
+			_param-&gt;mode=0;
+			_param-&gt;quality=2;
+			_param-&gt;threshold=0;
+			_param-&gt;threshold2=3.0;
+		}
+		
+		ADM_assert(_param-&gt;cycle);
+		vidCache=new VideoCache(_param-&gt;cycle*2+1,in);
+		
+		if (_param-&gt;mode == 0 || _param-&gt;mode == 2 || _param-&gt;mode == 3)
+		{
+			num_frames_hi = _info.nb_frames;
+			_info.nb_frames = _info.nb_frames * (_param-&gt;cycle - 1) / _param-&gt;cycle;
+			_info.fps1000=_info.fps1000*(_param-&gt;cycle-1);
+			_info.fps1000=(uint32_t)(_info.fps1000/_param-&gt;cycle);
+			
+		}
+		last_request = -1;
+		firsttime = true;
+		sum = (unsigned int *) ADM_alloc(MAX_BLOCKS * MAX_BLOCKS * sizeof(unsigned int));
+		ADM_assert(sum);		
+		all_video_cycle = true;
+
+		if (debug)
+		{
+			char b[80];
+			sprintf(b, &quot;Decimate %s by Donald Graft, Copyright 2003\n&quot;, VERSION);
+			OutputDebugString(b);
+		}
+	}
+}
+//________________________________________________________
+uint8_t	Decimate::getCoupledConf( CONFcouple **couples)
+{
+	*couples=NULL;
+	*couples=new CONFcouple(5);
+#define CSET(x)  (*couples)-&gt;setCouple((char *)#x,(_param-&gt;x))
+	
+	CSET(cycle);
+	CSET(mode);
+	CSET(quality);
+	CSET(threshold);
+	CSET(threshold2);
+
+	return 1;
+}
+//________________________________________________________
+Decimate::~Decimate(void)
+{
+		if (sum != NULL) ADM_dealloc(sum);
+		if(vidCache) delete vidCache;
+		if(_param) delete _param;
+
+		vidCache=NULL;
+		_param=NULL;
+		sum=NULL;
+}
+//________________________________________________________
+void Decimate::DrawShow(ADMImage  *src, int useframe, bool forced, int dropframe,
+						double metric, int inframe)
+{
+	char buf[80];
+	int start = (useframe / _param-&gt;cycle) * _param-&gt;cycle;
+
+	if (show == true)
+	{
+		sprintf(buf, &quot;Decimate %s&quot;, VERSION);
+		DrawString(src, 0, 0, buf);
+		sprintf(buf, &quot;Copyright 2003 Donald Graft&quot;);
+		DrawString(src, 0, 1, buf);
+		sprintf(buf,&quot;%d: %3.2f&quot;, start, showmetrics[0]);
+		DrawString(src, 0, 3, buf);
+		sprintf(buf,&quot;%d: %3.2f&quot;, start + 1, showmetrics[1]);
+		DrawString(src, 0, 4, buf);
+		sprintf(buf,&quot;%d: %3.2f&quot;, start + 2, showmetrics[2]);
+		DrawString(src, 0, 5, buf);
+		sprintf(buf,&quot;%d: %3.2f&quot;, start + 3, showmetrics[3]);
+		DrawString(src, 0, 6, buf);
+		sprintf(buf,&quot;%d: %3.2f&quot;, start + 4, showmetrics[4]);
+		DrawString(src, 0, 7, buf);
+		if (all_video_cycle == false)
+		{
+			sprintf(buf,&quot;in frm %d, use frm %d&quot;, inframe, useframe);
+			DrawString(src, 0, 8, buf);
+			if (forced == false)
+				sprintf(buf,&quot;chose %d, dropping&quot;, dropframe);
+			else
+				sprintf(buf,&quot;chose %d, dropping, forced!&quot;, dropframe);
+			DrawString(src, 0, 9, buf);
+		}
+		else
+		{
+			sprintf(buf,&quot;in frm %d&quot;, inframe);
+			DrawString(src, 0, 8, buf);
+			sprintf(buf,&quot;chose %d, decimating all-video cycle&quot;, dropframe);
+			DrawString(src, 0, 9, buf);
+		}
+	}
+	if (debug)
+	{
+		if (!(inframe%_param-&gt;cycle))
+		{
+			sprintf(buf,&quot;Decimate: %d: %3.2f\n&quot;, start, showmetrics[0]);
+			OutputDebugString(buf);
+			sprintf(buf,&quot;Decimate: %d: %3.2f\n&quot;, start + 1, showmetrics[1]);
+			OutputDebugString(buf);
+			sprintf(buf,&quot;Decimate: %d: %3.2f\n&quot;, start + 2, showmetrics[2]);
+			OutputDebugString(buf);
+			sprintf(buf,&quot;Decimate: %d: %3.2f\n&quot;, start + 3, showmetrics[3]);
+			OutputDebugString(buf);
+			sprintf(buf,&quot;Decimate: %d: %3.2f\n&quot;, start + 4, showmetrics[4]);
+			OutputDebugString(buf);
+		}
+		if (all_video_cycle == false)
+		{
+			sprintf(buf,&quot;Decimate: in frm %d useframe %d\n&quot;, inframe, useframe);
+			OutputDebugString(buf);
+			if (forced == false)
+				sprintf(buf,&quot;Decimate: chose %d, dropping\n&quot;, dropframe);
+			else
+				sprintf(buf,&quot;Decimate: chose %d, dropping, forced!\n&quot;, dropframe);
+			OutputDebugString(buf);
+		}
+		else
+		{
+			sprintf(buf,&quot;Decimate: in frm %d\n&quot;, inframe);
+			OutputDebugString(buf);
+			sprintf(buf,&quot;Decimate: chose %d, decimating all-video cycle\n&quot;, dropframe);
+			OutputDebugString(buf);
+		}
+	}
+}
+//______________________________________________________________________
+uint8_t Decimate::getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
+				ADMImage *data,uint32_t *flags)
+{
+	int dropframe, useframe, nextfrm, wY, wUV, hY, hUV, x, y, pitchY, pitchUV, dpitchY, dpitchUV;
+	ADMImage  *src, *next, *dst;
+	unsigned char *srcrpY, *nextrpY, *dstwpY;
+	unsigned char *srcrpU, *nextrpU, *dstwpU;
+	unsigned char *srcrpV, *nextrpV, *dstwpV;
+	uint32_t inframe=frame;
+	double metric;
+	char buf[255];
+
+	*len=(_info.width*_info.height*3)&gt;&gt;1;
+	num_frames_hi = _in-&gt;getInfo()-&gt;nb_frames; /* FIXME MEANX */
+	if (_param-&gt;mode == 0)
+	{
+		bool forced = false;
+		int start;
+
+		/* Normal decimation. Remove the frame most similar to its preceding frame. */
+		/* Determine the correct frame to use and get it. */
+		useframe = inframe + inframe / (_param-&gt;cycle - 1);
+		start = (useframe /  _param-&gt;cycle) * _param-&gt;cycle;
+		FindDuplicate((useframe / _param-&gt;cycle) * _param-&gt;cycle, &amp;dropframe, &amp;metric, &amp;forced);
+		if (useframe &gt;= dropframe) useframe++;
+		GETFRAME(useframe, src);
+		if (show == true)
+		{
+			sprintf(buf, &quot;Decimate %s&quot;, VERSION);
+			DrawString(src, 0, 0, buf);
+			sprintf(buf, &quot;Copyright 2003 Donald Graft&quot;);
+			DrawString(src, 0, 1, buf);
+			sprintf(buf,&quot;%d: %3.2f&quot;, start, showmetrics[0]);
+			DrawString(src, 0, 3, buf);
+			sprintf(buf,&quot;%d: %3.2f&quot;, start + 1, showmetrics[1]);
+			DrawString(src, 0, 4, buf);
+			sprintf(buf,&quot;%d: %3.2f&quot;, start + 2, showmetrics[2]);
+			DrawString(src, 0, 5, buf);
+			sprintf(buf,&quot;%d: %3.2f&quot;, start + 3, showmetrics[3]);
+			DrawString(src, 0, 6, buf);
+			sprintf(buf,&quot;%d: %3.2f&quot;, start + 4, showmetrics[4]);
+			DrawString(src, 0, 7, buf);
+			sprintf(buf,&quot;in frm %d, use frm %d&quot;, inframe, useframe);
+			DrawString(src, 0, 8, buf);
+			sprintf(buf,&quot;dropping frm %d%s&quot;, dropframe, last_forced == true ? &quot;, forced!&quot; : &quot;&quot;);
+			DrawString(src, 0, 9, buf);
+		}
+		if (debug)
+		{	
+			if (!(inframe % _param-&gt;cycle))
+			{
+				sprintf(buf,&quot;Decimate: %d: %3.2f\n&quot;, start, showmetrics[0]);
+				OutputDebugString(buf);
+				sprintf(buf,&quot;Decimate: %d: %3.2f\n&quot;, start + 1, showmetrics[1]);
+				OutputDebugString(buf);
+				sprintf(buf,&quot;Decimate: %d: %3.2f\n&quot;, start + 2, showmetrics[2]);
+				OutputDebugString(buf);
+				sprintf(buf,&quot;Decimate: %d: %3.2f\n&quot;, start + 3, showmetrics[3]);
+				OutputDebugString(buf);
+				sprintf(buf,&quot;Decimate: %d: %3.2f\n&quot;, start + 4, showmetrics[4]);
+				OutputDebugString(buf);
+			}
+			sprintf(buf,&quot;Decimate: in frm %d, use frm %d\n&quot;, inframe, useframe);
+			OutputDebugString(buf);
+			sprintf(buf,&quot;Decimate: dropping frm %d%s\n&quot;, dropframe, last_forced == true ? &quot;, forced!&quot; : &quot;&quot;);
+			OutputDebugString(buf);
+		}
+	    //return src;
+	        //memcpy(data,src,*len);
+
+		data-&gt;duplicate(src);
+		vidCache-&gt;unlockAll();
+		  
+		return 1;
+	}
+	else if (_param-&gt;mode == 1)
+	{
+		bool forced = false;
+		int start = (inframe / _param-&gt;cycle) * _param-&gt;cycle;
+		unsigned int hint, film = 1;
+
+		GETFRAME(inframe, src);
+	    	srcrpY = YPLANE(src); //(unsigned char *) src-&gt;GetReadPtr(PLANAR_Y);
+		if (GetHintingData(srcrpY, &amp;hint) == false)
+		{
+			film = hint &amp; PROGRESSIVE;
+//			if (film) OutputDebugString(&quot;film\n&quot;);
+//			else OutputDebugString(&quot;video\n&quot;);
+		}
+
+		/* Find the most similar frame as above but replace it with a blend of
+		   the preceding and following frames. */
+		num_frames_hi = _in-&gt;getInfo()-&gt;nb_frames; /* FIXME MEANX */
+		FindDuplicate((inframe / _param-&gt;cycle) * _param-&gt;cycle, &amp;dropframe, &amp;metric, &amp;forced);
+		if (!film || inframe != dropframe || (_param-&gt;threshold &amp;&amp; metric &gt; _param-&gt;threshold))
+		{
+			if (show == true)
+			{
+
+				sprintf(buf, &quot;Decimate %s&quot;, VERSION);
+				DrawString(src, 0, 0, buf);
+				sprintf(buf, &quot;Copyright 2003 Donald Graft&quot;);
+				DrawString(src, 0, 1, buf);
+				sprintf(buf,&quot;%d: %3.2f&quot;, start, showmetrics[0]);
+				DrawString(src, 0, 3, buf);
+				sprintf(buf,&quot;%d: %3.2f&quot;, start + 1, showmetrics[1]);
+				DrawString(src, 0, 4, buf);
+				sprintf(buf,&quot;%d: %3.2f&quot;, start + 2, showmetrics[2]);
+				DrawString(src, 0, 5, buf);
+				sprintf(buf,&quot;%d: %3.2f&quot;, start + 3, showmetrics[3]);
+				DrawString(src, 0, 6, buf);
+				sprintf(buf,&quot;%d: %3.2f&quot;, start + 4, showmetrics[4]);
+				DrawString(src, 0, 7, buf);
+				sprintf(buf,&quot;infrm %d&quot;, inframe);
+				DrawString(src, 0, 8, buf);
+				if (last_forced == false)
+					sprintf(buf,&quot;chose %d, passing through&quot;, dropframe);
+				else
+					sprintf(buf,&quot;chose %d, passing through, forced!&quot;, dropframe);
+				DrawString(src, 0, 9, buf);
+			}
+			if (debug)
+			{
+				if (!(inframe % _param-&gt;cycle))
+				{
+					sprintf(buf,&quot;Decimate: %d: %3.2f\n&quot;, start, showmetrics[0]);
+					OutputDebugString(buf);
+					sprintf(buf,&quot;Decimate: %d: %3.2f\n&quot;, start + 1, showmetrics[1]);
+					OutputDebugString(buf);
+					sprintf(buf,&quot;Decimate: %d: %3.2f\n&quot;, start + 2, showmetrics[2]);
+					OutputDebugString(buf);
+					sprintf(buf,&quot;Decimate: %d: %3.2f\n&quot;, start + 3, showmetrics[3]);
+					OutputDebugString(buf);
+					sprintf(buf,&quot;Decimate: %d: %3.2f\n&quot;, start + 4, showmetrics[4]);
+					OutputDebugString(buf);
+				}
+				sprintf(buf,&quot;Decimate: in frm %d\n&quot;, inframe);
+				OutputDebugString(buf);
+				if (last_forced == false)
+					sprintf(buf,&quot;Decimate: chose %d, passing through\n&quot;, dropframe);
+				else
+					sprintf(buf,&quot;Decimate: chose %d, passing through, forced!\n&quot;, dropframe);
+				OutputDebugString(buf);
+			}
+			//return src;
+			//memcpy(data,src,*len);
+
+			data-&gt;duplicate(src);
+			vidCache-&gt;unlockAll();
+			return 1;
+		}
+		if (inframe &lt; _in-&gt;getInfo()-&gt;nb_frames - 1) /* FIXME MEANX*/
+			nextfrm = inframe + 1;
+		else
+			nextfrm = _in-&gt;getInfo()-&gt;nb_frames - 1;
+		if (debug)
+		{
+			if (!(inframe % _param-&gt;cycle))
+			{
+				sprintf(buf,&quot;Decimate: %d: %3.2f\n&quot;, start, showmetrics[0]);
+				OutputDebugString(buf);
+				sprintf(buf,&quot;Decimate: %d: %3.2f\n&quot;, start + 1, showmetrics[1]);
+				OutputDebugString(buf);
+				sprintf(buf,&quot;Decimate: %d: %3.2f\n&quot;, start + 2, showmetrics[2]);
+				OutputDebugString(buf);
+				sprintf(buf,&quot;Decimate: %d: %3.2f\n&quot;, start + 3, showmetrics[3]);
+				OutputDebugString(buf);
+				sprintf(buf,&quot;Decimate: %d: %3.2f\n&quot;, start + 4, showmetrics[4]);
+				OutputDebugString(buf);
+			}
+			sprintf(buf,&quot;Decimate: in frm %d\n&quot;, inframe);
+			OutputDebugString(buf);
+			if (last_forced == false)
+				sprintf(buf,&quot;Decimate: chose %d, blending %d and %d\n&quot;, dropframe, inframe, nextfrm);
+			else
+				sprintf(buf,&quot;Decimate: chose %d, blending %d and %d, forced!\n&quot;, dropframe, inframe, nextfrm);
+			OutputDebugString(buf);
+		}
+		GETFRAME(nextfrm, next);
+		dst = data; //env-&gt;NewVideoFrame(vi);
+		pitchY = _info.width; //src-&gt;GetPitch(PLANAR_Y);
+		dpitchY = _info.width; //dst-&gt;GetPitch(PLANAR_Y);
+		wY = _info.width; //src-&gt;GetRowSize(PLANAR_Y);
+		hY = _info.height; //src-&gt;GetHeight(PLANAR_Y);
+		pitchUV = _info.width&gt;&gt;1;// src-&gt;GetPitch(PLANAR_V);
+		dpitchUV =_info.width&gt;&gt;1;// dst-&gt;GetPitch(PLANAR_V);
+		wUV = _info.width&gt;&gt;1;//src-&gt;GetRowSize(PLANAR_V);
+		hUV = _info.height&gt;&gt;1;//src-&gt;GetHeight(PLANAR_V);
+		
+		nextrpY = YPLANE(next); //next-&gt;GetReadPtr(PLANAR_Y);
+		dstwpY = YPLANE( dst); //dst-&gt;GetWritePtr(PLANAR_Y);
+#ifdef DECIMATE_MMX_BUILD_PLANE
+		if (CpuCaps::hasSSE()) 
+		{
+			isse_blend_decimate_plane(dstwpY, srcrpY, nextrpY, wY, hY);
+		} else {
+#endif
+			for (y = 0; y &lt; hY; y++)
+			{
+				for (x = 0; x &lt; wY; x++)
+				{
+					dstwpY[x] = ((int)srcrpY[x] + (int)nextrpY[x] ) &gt;&gt; 1;  
+				}
+				srcrpY += pitchY;
+				nextrpY += pitchY;
+				dstwpY += dpitchY;
+			}
+#ifdef DECIMATE_MMX_BUILD_PLANE
+		}
+#endif
+		srcrpU =   UPLANE(src);//-&gt;GetReadPtr(PLANAR_U);
+		nextrpU =   UPLANE(next);//-&gt;GetReadPtr(PLANAR_U);
+		dstwpU =  UPLANE(dst);//-&gt;GetWritePtr(PLANAR_U);
+#ifdef DECIMATE_MMX_BUILD_PLANE
+		if (CpuCaps::hasSSE()) 
+		{
+			isse_blend_decimate_plane(dstwpU, srcrpU, nextrpU, wUV, hUV);
+		} else {
+#endif
+			for (y = 0; y &lt; hUV; y++)
+			{
+				for (x = 0; x &lt; wUV; x++)
+				{
+					dstwpU[x] = ((int)srcrpU[x] + (int)nextrpU[x]) &gt;&gt; 1;
+				}
+				srcrpU += pitchUV;
+				nextrpU += pitchUV;
+				dstwpU += dpitchUV;
+			}
+#ifdef DECIMATE_MMX_BUILD_PLANE
+		}
+#endif
+		srcrpV =   VPLANE(src);//-&gt;GetReadPtr(PLANAR_V);
+		nextrpV =   VPLANE(next);//-&gt;GetReadPtr(PLANAR_V);
+		dstwpV =   VPLANE(dst);//-&gt;GetWritePtr(PLANAR_V);
+
+#ifdef DECIMATE_MMX_BUILD_PLANE
+		if (CpuCaps::hasSSE()) { 
+			isse_blend_decimate_plane(dstwpV, srcrpV, nextrpV, wUV, hUV );
+		} else {
+#endif
+			for (y = 0; y &lt; hUV; y++)
+			{
+				for (x = 0; x &lt; wUV; x++)
+				{
+					dstwpV[x] = ((int)srcrpV[x] + + (int)nextrpV[x]) &gt;&gt; 1;
+				}
+				srcrpV += pitchUV;
+				nextrpV += pitchUV;
+				dstwpV += dpitchUV;
+			}
+#ifdef DECIMATE_MMX_BUILD_PLANE
+		}
+#endif
+		if (show == true)
+		{
+
+			sprintf(buf, &quot;Decimate %s&quot;, VERSION);
+			DrawString(dst, 0, 0, buf);
+			sprintf(buf, &quot;Copyright 2003 Donald Graft&quot;);
+			DrawString(dst, 0, 1, buf);
+			sprintf(buf,&quot;%d: %3.2f&quot;, start, showmetrics[0]);
+			DrawString(dst, 0, 3, buf);
+			sprintf(buf,&quot;%d: %3.2f&quot;, start + 1, showmetrics[1]);
+			DrawString(dst, 0, 4, buf);
+			sprintf(buf,&quot;%d: %3.2f&quot;, start + 2, showmetrics[2]);
+			DrawString(dst, 0, 5, buf);
+			sprintf(buf,&quot;%d: %3.2f&quot;, start + 3, showmetrics[3]);
+			DrawString(dst, 0, 6, buf);
+			sprintf(buf,&quot;%d: %3.2f&quot;, start + 4, showmetrics[4]);
+			DrawString(dst, 0, 7, buf);
+			sprintf(buf,&quot;infrm %d&quot;, inframe);
+			DrawString(dst, 0, 8, buf);
+			if (last_forced == false)
+				sprintf(buf,&quot;chose %d, blending %d and %d&quot;,dropframe, inframe, nextfrm);
+			else
+				sprintf(buf,&quot;chose %d, blending %d and %d, forced!&quot;, dropframe, inframe, nextfrm);
+			DrawString(dst, 0, 9, buf);
+		}
+		//return dst;
+		//memcpy(data,dst,*len);
+
+		data-&gt;duplicate(dst);
+		vidCache-&gt;unlockAll();		
+		return 1;
+	}
+	else if (_param-&gt;mode == 2)
+	{
+		bool forced = false;
+
+		/* Delete the duplicate in the longest string of duplicates. */
+		useframe = inframe + inframe / (_param-&gt;cycle - 1);
+		FindDuplicate2((useframe / _param-&gt;cycle) * _param-&gt;cycle, &amp;dropframe, &amp;forced);
+		if (useframe &gt;= dropframe) useframe++;
+		GETFRAME(useframe, src);
+		if (show == true)
+		{
+			int start = (useframe / _param-&gt;cycle) * _param-&gt;cycle;
+
+
+			sprintf(buf, &quot;Decimate %s&quot;, VERSION);
+			DrawString(src, 0, 0, buf);
+			sprintf(buf, &quot;Copyright 2003 Donald Graft&quot;);
+			DrawString(src, 0, 1, buf);
+			sprintf(buf,&quot;in frm %d, use frm %d&quot;, inframe, useframe);
+			DrawString(src, 0, 3, buf);
+			sprintf(buf,&quot;%d: %3.2f (%s)&quot;, start, showmetrics[0],
+					Dshow[0] ? &quot;new&quot; : &quot;dup&quot;);
+			DrawString(src, 0, 4, buf);
+			sprintf(buf,&quot;%d: %3.2f (%s)&quot;, start + 1, showmetrics[1],
+					Dshow[1] ? &quot;new&quot; : &quot;dup&quot;);
+			DrawString(src, 0, 5, buf);
+			sprintf(buf,&quot;%d: %3.2f (%s)&quot;, start + 2, showmetrics[2],
+					Dshow[2] ? &quot;new&quot; : &quot;dup&quot;);
+			DrawString(src, 0, 6, buf);
+			sprintf(buf,&quot;%d: %3.2f (%s)&quot;, start + 3, showmetrics[3],
+					Dshow[3] ? &quot;new&quot; : &quot;dup&quot;);
+			DrawString(src, 0, 7, buf);
+			sprintf(buf,&quot;%d: %3.2f (%s)&quot;, start + 4, showmetrics[4],
+					Dshow[4] ? &quot;new&quot; : &quot;dup&quot;);
+			DrawString(src, 0, 8, buf);
+			sprintf(buf,&quot;Dropping frm %d%s&quot;, dropframe, last_forced == true ? &quot; forced!&quot; : &quot;&quot;);
+			DrawString(src, 0, 9, buf);
+		}
+		if (debug)
+		{	
+			sprintf(buf,&quot;Decimate: inframe %d useframe %d\n&quot;, inframe, useframe);
+			OutputDebugString(buf);
+		}
+	    //return src;
+	    	//memcpy(data,src,*len);
+
+		data-&gt;duplicate(src);
+		vidCache-&gt;unlockAll();
+		return 1;
+	}
+	else if (_param-&gt;mode == 3)
+	{
+		bool forced = false;
+
+		/* Decimate by removing a duplicate from film cycles and doing a
+		   blend rate conversion on the video cycles. */
+		if (_param-&gt;cycle != 5)//	env-&gt;ThrowError(&quot;Decimate: mode=3 requires cycle=5&quot;);
+		{
+			printf(&quot;Decimate: mode=3 requires cycle=5\n&quot;);
+			return 0;
+		}
+		useframe = inframe + inframe / (_param-&gt;cycle - 1);
+		FindDuplicate((useframe / _param-&gt;cycle) * _param-&gt;cycle, &amp;dropframe, &amp;metric, &amp;forced);
+		/* Use hints from Telecide about film versus video. Also use the difference
+		   metric of the most similar frame in the cycle; if it exceeds threshold,
+		   assume it's a video cycle. */
+		if (!(inframe % 4))
+		{
+			all_video_cycle = false;
+			if (_param-&gt;threshold &amp;&amp; metric &gt; _param-&gt;threshold)
+			{
+				all_video_cycle = true;
+			}
+			if ((hints_invalid == false) &amp;&amp;
+				(!(hints[0] &amp; PROGRESSIVE) ||
+				 !(hints[1] &amp; PROGRESSIVE) ||
+				 !(hints[2] &amp; PROGRESSIVE) ||
+				 !(hints[3] &amp; PROGRESSIVE) ||
+				 !(hints[4] &amp; PROGRESSIVE)))
+			{
+				all_video_cycle = true;
+			}
+		}
+		if (all_video_cycle == false)
+		{
+			/* It's film, so decimate in the normal way. */
+			if (useframe &gt;= dropframe) useframe++;
+			GETFRAME(useframe, src);
+			DrawShow(src, useframe, forced, dropframe, metric, inframe);			
+			//memcpy(data,src,*len);
+
+			data-&gt;duplicate(src);
+		
+			vidCache-&gt;unlockAll();		
+			return 1; // return src;
+		}
+		else if ((inframe % 4) == 0)
+		{
+			/* It's a video cycle. Output the first frame of the cycle. */
+			GETFRAME(useframe, src);
+			DrawShow(src, 0, forced, dropframe, metric, inframe);
+			//return src;
+			//memcpy(data,src,*len);
+
+			data-&gt;duplicate(src);
+		
+			vidCache-&gt;unlockAll();		
+			return 1; // return src;
+		}
+		else if ((inframe % 4) == 3)
+		{
+			/* It's a video cycle. Output the last frame of the cycle. */
+			GETFRAME(useframe+1, src);
+			DrawShow(src, 0, forced, dropframe, metric, inframe);
+			//return src;
+			//memcpy(data,src,*len);
+
+			data-&gt;duplicate(src);
+		
+			vidCache-&gt;unlockAll();		
+			return 1; // return src;
+		}
+		else if ((inframe % 4) == 1 || (inframe % 4) == 2)
+		{
+			/* It's a video cycle. Make blends for the remaining frames. */
+			if ((inframe % 4) == 1)
+			{
+				GETFRAME(useframe, src);
+				if (useframe &lt; num_frames_hi - 1)
+					nextfrm = useframe + 1;
+				else
+					nextfrm = _in-&gt;getInfo()-&gt;nb_frames - 1;
+				GETFRAME(nextfrm, next);
+			}
+			else
+			{
+				GETFRAME(useframe + 1, src);
+				nextfrm = useframe;
+				GETFRAME(nextfrm, next);
+			}
+			dst = data; //env-&gt;NewVideoFrame(vi);
+			pitchY = _info.width; //src-&gt;GetPitch(PLANAR_Y);
+			dpitchY = _info.width; //dst-&gt;GetPitch(PLANAR_Y);
+			wY = _info.width; //src-&gt;GetRowSize(PLANAR_Y);
+			hY = _info.height; //src-&gt;GetHeight(PLANAR_Y);
+			pitchUV = _info.width&gt;&gt;1; //src-&gt;GetPitch(PLANAR_V);
+			dpitchUV =_info.width&gt;&gt;1; // dst-&gt;GetPitch(PLANAR_V);
+			wUV = _info.width&gt;&gt;1; //src-&gt;GetRowSize(PLANAR_V);
+			hUV = _info.height&gt;&gt;1; //src-&gt;GetHeight(PLANAR_V);
+			
+			srcrpY = YPLANE( src); //src-&gt;GetReadPtr(PLANAR_Y);
+			nextrpY = YPLANE( next); //next-&gt;GetReadPtr(PLANAR_Y);
+			dstwpY = YPLANE( dst); //dst-&gt;GetWritePtr(PLANAR_Y);
+#ifdef DECIMATE_MMX_BUILD_PLANE
+			if (CpuCaps::hasSSE()) { 
+				isse_blend_decimate_plane(dstwpY, srcrpY, nextrpY, wY, hY);
+			} else {
+#endif
+				for (y = 0; y &lt; hY; y++)
+				{
+					for (x = 0; x &lt; wY; x++)
+					{
+						dstwpY[x] = ((int)srcrpY[x] + (int)nextrpY[x]) &gt;&gt; 1;
+					}
+					srcrpY += pitchY;
+					nextrpY += pitchY;
+					dstwpY += dpitchY;
+				}
+#ifdef DECIMATE_MMX_BUILD_PLANE
+			}
+#endif
+			srcrpU =   UPLANE(src);//-&gt;GetReadPtr(PLANAR_U);
+			nextrpU =  UPLANE( next);//-&gt;GetReadPtr(PLANAR_U);
+			dstwpU =   UPLANE(dst);//-&gt;GetWritePtr(PLANAR_U);
+#ifdef DECIMATE_MMX_BUILD_PLANE
+			if (CpuCaps::hasSSE()) { 
+				isse_blend_decimate_plane(dstwpU, srcrpU, nextrpU, wUV, hUV);
+			} else {
+#endif
+				for (y = 0; y &lt; hUV; y++)
+				{
+					for (x = 0; x &lt; wUV; x++)
+					{
+						dstwpU[x] = ((int)srcrpU[x] + (int)nextrpU[x]) &gt;&gt; 1;
+					}
+					srcrpU += pitchUV;
+					nextrpU += pitchUV;
+					dstwpU += dpitchUV;
+				}
+#ifdef DECIMATE_MMX_BUILD_PLANE
+			}
+#endif
+			srcrpV =   VPLANE(src);//-&gt;GetReadPtr(PLANAR_V);
+			nextrpV =  VPLANE( next);//-&gt;GetReadPtr(PLANAR_V);
+			dstwpV =   VPLANE(dst);//-&gt;GetWritePtr(PLANAR_V);
+#ifdef DECIMATE_MMX_BUILD_PLANE
+			if (CpuCaps::hasSSE()) { 
+				isse_blend_decimate_plane(dstwpV, srcrpV, nextrpV, wUV, hUV);
+			} else {
+#endif
+				for (y = 0; y &lt; hUV; y++)
+				{
+					for (x = 0; x &lt; wUV; x++)
+					{
+						dstwpV[x] = ((int)srcrpV[x] + (int)nextrpV[x]) &gt;&gt; 1;
+					}
+					srcrpV += pitchUV;
+					nextrpV += pitchUV;
+					dstwpV += dpitchUV;
+				}
+#ifdef DECIMATE_MMX_BUILD_PLANE
+			}
+#endif
+			DrawShow(dst, 0, forced, dropframe, metric, inframe);
+			vidCache-&gt;unlockAll();
+			//return dst;
+			//memcpy(data,dst,*len);
+
+			data-&gt;duplicate(dst);
+			vidCache-&gt;unlockAll();		
+			return 1; // return src;			
+		}
+		//return src;
+		//memcpy(data,src,*len);
+
+		data-&gt;duplicate(src);
+		vidCache-&gt;unlockAll();		
+		return 1; // return src;			
+	}
+	//env-&gt;ThrowError(&quot;Decimate: invalid mode option (0-3)&quot;);
+	printf(&quot;Decimate: invalid mode option (0-3)\n&quot;);
+	/* Avoid compiler warning. */
+	return 0;
+}
+//____________________________________________________
+void Decimate::FindDuplicate(int frame, int *chosen, double *metric, bool *forced)
+{
+	int f;
+	ADMImage  * store[MAX_CYCLE_SIZE+1];
+	const unsigned char *storepY[MAX_CYCLE_SIZE+1];
+	const unsigned char *storepU[MAX_CYCLE_SIZE+1];
+	const unsigned char *storepV[MAX_CYCLE_SIZE+1];
+	const unsigned char *prevY, *prevU, *prevV, *currY, *currU, *currV;
+	int x, y, lowest_index, div;
+	unsigned int count[MAX_CYCLE_SIZE], lowest;
+	bool found;
+	unsigned int highest_sum=0;
+
+	/* Only recalculate differences when a new set is needed. */
+	if (frame == last_request)
+	{
+		*chosen = last_result;
+		*metric = last_metric;
+		return;
+	}
+	last_request = frame;
+
+	/* Get cycle+1 frames starting at the one before the asked-for one. */
+	for (f = 0; f &lt;= _param-&gt;cycle; f++)
+	{
+		GETFRAME(frame + f - 1, store[f]);
+		storepY[f] = YPLANE(store[f]);//-&gt;GetReadPtr(PLANAR_Y);
+		hints_invalid = GetHintingData((unsigned char *) storepY[f], &amp;hints[f]);
+		if (_param-&gt;quality == 1 || _param-&gt;quality == 3)
+		{
+			storepU[f] = UPLANE(store[f]);//-&gt;GetReadPtr(PLANAR_U);
+			storepV[f] = VPLANE(store[f]);//-&gt;GetReadPtr(PLANAR_V);
+		}
+	}
+
+    pitchY = _info.width; //store[0]-&gt;GetPitch(PLANAR_Y);
+    row_sizeY = _info.width; //store[0]-&gt;GetRowSize(PLANAR_Y);
+    heightY = _info.height; //store[0]-&gt;GetHeight(PLANAR_Y);
+	if (_param-&gt;quality == 1 || _param-&gt;quality == 3)
+	{
+		pitchUV = _info.width&gt;&gt;1; //store[0]-&gt;GetPitch(PLANAR_V);
+		row_sizeUV = _info.width&gt;&gt;1;//store[0]-&gt;GetRowSize(PLANAR_V);
+		heightUV = _info.height&gt;&gt;1;//store[0]-&gt;GetHeight(PLANAR_V);
+	}
+
+	int use_quality=_param-&gt;quality;
+
+
+	switch (use_quality)
+	{
+	case 0: // subsample, luma only
+		div = (BLKSIZE * BLKSIZE / 4) * 219;
+		break;
+	case 1: // subsample, luma and chroma
+		div = (BLKSIZE * BLKSIZE / 4) * 219 + ( (BLKSIZE * BLKSIZE / 8)) * 224;
+		break;
+	case 2: // fully sample, luma only
+		div = (BLKSIZE * BLKSIZE) * 219;
+		break;
+	case 3: // fully sample, luma and chroma
+		div = (BLKSIZE * BLKSIZE) * 219 + ( BLKSIZE * BLKSIZE/2) * 224;
+		break;
+	}
+
+	xblocks = row_sizeY / BLKSIZE;
+	if (row_sizeY % BLKSIZE) xblocks++;
+	yblocks = heightY / BLKSIZE;
+	if (heightY % BLKSIZE) yblocks++;
+
+	/* Compare each frame to its predecessor. */
+	for (f = 1; f &lt;= _param-&gt;cycle; f++)
+	{
+		prevY = storepY[f-1];
+		currY = storepY[f];
+		for (y = 0; y &lt; yblocks; y++)
+		{
+			for (x = 0; x &lt; xblocks; x++)
+			{
+				sum[y*xblocks+x] = 0;
+			}
+		}
+		for (y = 0; y &lt; heightY; y++)
+		{
+			for (x = 0; x &lt; row_sizeY;)
+			{
+				sum[(y/BLKSIZE)*xblocks+x/BLKSIZE] += abs((int)currY[x] - (int)prevY[x]);
+				x++;
+				if (_param-&gt;quality == 0 || _param-&gt;quality == 1)
+				{
+					if (!(x%4)) x += 12;
+				}
+			}
+			prevY += pitchY;
+			currY += pitchY;
+		}
+		if (_param-&gt;quality == 1 || _param-&gt;quality == 3)
+		{
+			prevU = storepU[f-1];
+			prevV = storepV[f-1];
+			currU = storepU[f];
+			currV = storepV[f];
+			for (y = 0; y &lt; heightUV; y++)
+			{
+				for (x = 0; x &lt; row_sizeUV;)
+				{
+					sum[((2*y)/BLKSIZE)*xblocks+(2*x)/BLKSIZE] += abs((int)currU[x] - (int)prevU[x]);
+					sum[((2*y)/BLKSIZE)*xblocks+(2*x)/BLKSIZE] += abs((int)currV[x] - (int)prevV[x]);
+					x++;
+					if (_param-&gt;quality == 1)
+					{
+						if (!(x%4)) x += 12;
+					}
+				}
+				prevU += pitchUV;
+				currU += pitchUV;
+				prevV += pitchUV;
+				currV += pitchUV;
+			}
+		}
+		highest_sum = 0;
+		for (y = 0; y &lt; yblocks; y++)
+		{
+			for (x = 0; x &lt; xblocks; x++)
+			{
+				if (sum[y*xblocks+x] &gt; highest_sum)
+				{
+					highest_sum = sum[y*xblocks+x];
+				}
+			}
+		}
+		count[f-1] = highest_sum;
+		showmetrics[f-1] = (count[f-1] * 100.0) / div;
+	}
+
+	/* Find the frame with the lowest difference count but
+	   don't use the artificial duplicate at frame 0. */
+	if (frame == 0)
+	{
+		lowest = count[1];
+		lowest_index = 1;
+	}
+	else
+	{
+		lowest = count[0];
+		lowest_index = 0;
+	}
+	for (x = 1; x &lt; _param-&gt;cycle; x++)
+	{
+		if (count[x] &lt; lowest)
+		{
+			lowest = count[x];
+			lowest_index = x;
+		}
+	}
+	last_result = frame + lowest_index;
+	if (_param-&gt;quality == 1 || _param-&gt;quality == 3)
+		last_metric = (lowest * 100.0) / div;
+	else
+		last_metric = (lowest * 100.0) / div;
+	*chosen = last_result;
+	*metric = last_metric;
+
+	
+	found = false;
+	last_forced = false;	
+
+}
+//____________________________________________________
+void Decimate::FindDuplicate2(int frame, int *chosen, bool *forced)
+{
+	int f, g, fsum, bsum, highest, highest_index;
+	ADMImage * store[MAX_CYCLE_SIZE+1];
+	const unsigned char *storepY[MAX_CYCLE_SIZE+1];
+	const unsigned char *storepU[MAX_CYCLE_SIZE+1];
+	const unsigned char *storepV[MAX_CYCLE_SIZE+1];
+	const unsigned char *prevY, *prevU, *prevV, *currY, *currU, *currV;
+	int x, y;
+	double lowest;
+	unsigned int lowest_index;
+	char buf[255];
+	unsigned int highest_sum;
+	bool found;
+#define BLKSIZE 32
+
+	/* Only recalculate differences when a new cycle is started. */
+	if (frame == last_request)
+	{
+		*chosen = last_result;
+		*forced = last_forced;
+		return;
+	}
+	last_request = frame;
+
+	if (firsttime == true || frame == 0)
+	{
+		firsttime = false;
+		for (f = 0; f &lt; MAX_CYCLE_SIZE; f++) Dprev[f] = -1;
+		GETFRAME(frame, store[0]);
+		storepY[0] = YPLANE(store[0]);//-&gt;GetReadPtr(PLANAR_Y);
+		if (_param-&gt;quality == 1 || _param-&gt;quality == 3)
+		{
+			storepU[0] = UPLANE(store[0]);//-&gt;GetReadPtr(PLANAR_U);
+			storepV[0] = VPLANE(store[0]);//-&gt;GetReadPtr(PLANAR_V);
+		}
+
+		for (f = 1; f &lt;= _param-&gt;cycle; f++)
+		{
+			GETFRAME(frame + f - 1, store[f]);
+			storepY[f] =YPLANE( store[f]);//-&gt;GetReadPtr(PLANAR_Y);
+			if (_param-&gt;quality == 1 || _param-&gt;quality == 3)
+			{
+				storepU[f] = UPLANE(store[f]);//-&gt;GetReadPtr(PLANAR_U);
+				storepV[f] = VPLANE(store[f]);//-&gt;GetReadPtr(PLANAR_V);
+			}
+		}
+
+		pitchY = _info.width; //store[0]-&gt;GetPitch(PLANAR_Y);
+		row_sizeY = _info.width; //store[0]-&gt;GetRowSize(PLANAR_Y);
+		heightY = _info.height; //store[0]-&gt;GetHeight(PLANAR_Y);
+		if (_param-&gt;quality == 1 || _param-&gt;quality == 3)
+		{
+			pitchUV = _info.width&gt;&gt;1; //store[0]-&gt;GetPitch(PLANAR_V);
+			row_sizeUV = _info.width&gt;&gt;1; //store[0]-&gt;GetRowSize(PLANAR_V);
+			heightUV = _info.height&gt;&gt;1; //store[0]-&gt;GetHeight(PLANAR_V);
+		}
+		switch (_param-&gt;quality)
+		{
+		case 0: // subsample, luma only
+			div = (BLKSIZE * BLKSIZE / 4) * 219;
+			break;
+		case 1: // subsample, luma and chroma
+			div = (BLKSIZE * BLKSIZE / 4) * 219 + (BLKSIZE * BLKSIZE / 8) * 224;
+			break;
+		case 2: // fully sample, luma only
+			div = (BLKSIZE * BLKSIZE) * 219;
+			break;
+		case 3: // fully sample, luma and chroma
+			div = (BLKSIZE * BLKSIZE) * 219 + (BLKSIZE * BLKSIZE / 2) * 224;
+			break;
+		}
+		xblocks = row_sizeY / BLKSIZE;
+		if (row_sizeY % BLKSIZE) xblocks++;
+		yblocks = heightY / BLKSIZE;
+		if (heightY % BLKSIZE) yblocks++;
+
+		/* Compare each frame to its predecessor. */
+		for (f = 1; f &lt;= _param-&gt;cycle; f++)
+		{
+			for (y = 0; y &lt; yblocks; y++)
+			{
+				for (x = 0; x &lt; xblocks; x++)
+				{
+					sum[y*xblocks+x] = 0;
+				}
+			}
+			prevY = storepY[f-1];
+			currY = storepY[f];
+			for (y = 0; y &lt; heightY; y++)
+			{
+				for (x = 0; x &lt; row_sizeY;)
+				{
+					sum[(y/BLKSIZE)*xblocks+x/BLKSIZE] += abs((int)currY[x] - (int)prevY[x]);
+					x++;
+					if (_param-&gt;quality == 0 || _param-&gt;quality == 1)
+					{
+						if (!(x%4)) x += 12;
+					}
+				}
+				prevY += pitchY;
+				currY += pitchY;
+			}
+			if (_param-&gt;quality == 1 || _param-&gt;quality == 3)
+			{
+				prevU = storepU[f-1];
+				currU = storepU[f];
+				prevV = storepV[f-1];
+				currV = storepV[f];
+				for (y = 0; y &lt; heightUV; y++)
+				{
+					for (x = 0; x &lt; row_sizeUV;)
+					{
+						sum[((2*y)/BLKSIZE)*xblocks+(2*x)/BLKSIZE] += abs((int)currU[x] - (int)prevU[x]);
+						sum[((2*y)/BLKSIZE)*xblocks+(2*x)/BLKSIZE] += abs((int)currV[x] - (int)prevV[x]);
+						x++;
+						if (_param-&gt;quality == 0 || _param-&gt;quality == 1)
+						{
+							if (!(x%4)) x += 12;
+						}
+					}
+					prevU += pitchUV;
+					currU += pitchUV;
+					prevV += pitchUV;
+					currV += pitchUV;
+				}
+			}
+			highest_sum = 0;
+			for (y = 0; y &lt; yblocks; y++)
+			{
+				for (x = 0; x &lt; xblocks; x++)
+				{
+					if (sum[y*xblocks+x] &gt; highest_sum)
+					{
+						highest_sum = sum[y*xblocks+x];
+					}
+				}
+			}
+			metrics[f-1] = (highest_sum * 100.0) / div;
+		}
+
+		Dcurr[0] = 1;
+		for (f = 1; f &lt; _param-&gt;cycle; f++)
+		{
+			if (metrics[f] &lt; _param-&gt;threshold2) Dcurr[f] = 0;
+			else Dcurr[f] = 1;
+		}
+
+		if (debug)
+		{
+			sprintf(buf,&quot;Decimate: %d: %3.2f %3.2f %3.2f %3.2f %3.2f\n&quot;,
+					0, metrics[0], metrics[1], metrics[2], metrics[3], metrics[4]);
+			OutputDebugString(buf);
+		}
+	}
+ 	else if (frame &gt;= num_frames_hi - 1)
+	{
+		GETFRAME(num_frames_hi - 1, store[0]);
+		storepY[0] = YPLANE(store[0]);//-&gt;GetReadPtr(PLANAR_Y);
+		if (_param-&gt;quality == 1 || _param-&gt;quality == 3)
+		{
+			storepU[0] = UPLANE(store[0]);//-&gt;GetReadPtr(PLANAR_U);
+			storepV[0] = VPLANE(store[0]);//-&gt;GetReadPtr(PLANAR_V);
+		}
+		for (f = 0; f &lt; MAX_CYCLE_SIZE; f++) Dprev[f] = Dcurr[f];
+		for (f = 0; f &lt; MAX_CYCLE_SIZE; f++) Dcurr[f] = Dnext[f];
+	}
+	else
+	{
+		GETFRAME(frame + _param-&gt;cycle - 1, store[0]);
+		storepY[0] = YPLANE(store[0]);//-&gt;GetReadPtr(PLANAR_Y);
+		if (_param-&gt;quality == 1 || _param-&gt;quality == 3)
+		{
+			storepU[0] = UPLANE(store[0]);//-&gt;GetReadPtr(PLANAR_U);
+			storepV[0] = VPLANE(store[0]);//-&gt;GetReadPtr(PLANAR_V);
+		}
+		for (f = 0; f &lt; MAX_CYCLE_SIZE; f++) Dprev[f] = Dcurr[f];
+		for (f = 0; f &lt; MAX_CYCLE_SIZE; f++) Dcurr[f] = Dnext[f];
+	}
+	for (f = 0; f &lt; MAX_CYCLE_SIZE; f++) Dshow[f] = Dcurr[f];
+	for (f = 0; f &lt; MAX_CYCLE_SIZE; f++) showmetrics[f] = metrics[f];
+
+	for (f = 1; f &lt;= _param-&gt;cycle; f++)
+	{
+		GETFRAME(frame + f + _param-&gt;cycle - 1, store[f]);
+		storepY[f] =YPLANE( store[f]);//-&gt;GetReadPtr(PLANAR_Y);
+		if (_param-&gt;quality == 1 || _param-&gt;quality == 3)
+		{
+			storepU[f] = UPLANE(store[f]);//-&gt;GetReadPtr(PLANAR_U);
+			storepV[f] = VPLANE(store[f]);//-&gt;GetReadPtr(PLANAR_V);
+		}
+	}
+
+	/* Compare each frame to its predecessor. */
+	for (f = 1; f &lt;= _param-&gt;cycle; f++)
+	{
+		prevY = storepY[f-1];
+		currY = storepY[f];
+		for (y = 0; y &lt; yblocks; y++)
+		{
+			for (x = 0; x &lt; xblocks; x++)
+			{
+				sum[y*xblocks+x] = 0;
+			}
+		}
+		for (y = 0; y &lt; heightY; y++)
+		{
+			for (x = 0; x &lt; row_sizeY;)
+			{
+				sum[(y/BLKSIZE)*xblocks+x/BLKSIZE] += abs((int)currY[x] - (int)prevY[x]);
+				x++;
+				if (_param-&gt;quality == 0 || _param-&gt;quality == 1)
+				{
+					if (!(x%4)) x += 12;
+				}
+			}
+			prevY += pitchY;
+			currY += pitchY;
+		}
+		if (_param-&gt;quality == 1 || _param-&gt;quality == 3)
+		{
+			prevU = storepU[f-1];
+			currU = storepU[f];
+			prevV = storepV[f-1];
+			currV = storepV[f];
+			for (y = 0; y &lt; heightUV; y++)
+			{
+				for (x = 0; x &lt; row_sizeUV;)
+				{
+					sum[((2*y)/BLKSIZE)*xblocks+(2*x)/BLKSIZE] += abs((int)currU[x] - (int)prevU[x]);
+					sum[((2*y)/BLKSIZE)*xblocks+(2*x)/BLKSIZE] += abs((int)currV[x] - (int)prevV[x]);
+					x++;
+					if (_param-&gt;quality == 0 || _param-&gt;quality == 1)
+					{
+						if (!(x%4)) x += 12;
+					}
+				}
+				prevU += pitchUV;
+				currU += pitchUV;
+				prevV += pitchUV;
+				currV += pitchUV;
+			}
+		}
+		highest_sum = 0;
+		for (y = 0; y &lt; yblocks; y++)
+		{
+			for (x = 0; x &lt; xblocks; x++)
+			{
+				if (sum[y*xblocks+x] &gt; highest_sum)
+				{
+					highest_sum = sum[y*xblocks+x];
+				}
+			}
+		}
+		metrics[f-1] = (highest_sum * 100.0) / div;
+	}
+
+	/* Find the frame with the lowest difference count but
+	   don't use the artificial duplicate at frame 0. */
+	if (frame == 0)
+	{
+		lowest = metrics[1];
+		lowest_index = 1;
+	}
+	else
+	{
+		lowest = metrics[0];
+		lowest_index = 0;
+	}
+	for (f = 1; f &lt; _param-&gt;cycle; f++)
+	{
+		if (metrics[f] &lt; lowest)
+		{
+			lowest = metrics[f];
+			lowest_index = f;
+		}
+	}
+
+	for (f = 0; f &lt; _param-&gt;cycle; f++)
+	{
+		if (metrics[f] &lt; _param-&gt;threshold2) Dnext[f] = 0;
+		else Dnext[f] = 1;
+	}
+
+	if (debug)
+	{
+		sprintf(buf,&quot;Decimate: %d: %3.2f %3.2f %3.2f %3.2f %3.2f\n&quot;,
+		        frame + 5, metrics[0], metrics[1], metrics[2], metrics[3], metrics[4]);
+		OutputDebugString(buf);
+	}
+
+	if (debug)
+	{
+		sprintf(buf,&quot;Decimate: %d: %d %d %d %d %d\n&quot;,
+		        frame, Dcurr[0], Dcurr[1], Dcurr[2], Dcurr[3], Dcurr[4]);
+//		sprintf(buf,&quot;Decimate: %d: %d %d %d %d %d - %d %d %d %d %d - %d %d %d %d %d\n&quot;,
+//		        frame, Dprev[0], Dprev[1], Dprev[2], Dprev[3], Dprev[4],
+//					   Dcurr[0], Dcurr[1], Dcurr[2], Dcurr[3], Dcurr[4],
+//					   Dnext[0], Dnext[1], Dnext[2], Dnext[3], Dnext[4]);
+		OutputDebugString(buf);
+	}
+
+	/* Find the longest strings of duplicates and decimate a frame from it. */
+	highest = -1;
+	for (f = 0; f &lt; _param-&gt;cycle; f++)
+	{
+		if (Dcurr[f] == 1)
+		{
+			bsum = 0;
+			fsum = 0;
+		}
+		else
+		{
+			bsum = 1;
+			g = f;
+			while (--g &gt;= 0)
+			{
+				if (Dcurr[g] == 0)
+				{
+					bsum++;
+				}
+				else break;
+			}
+			if (g &lt; 0)
+			{
+				g = _param-&gt;cycle;
+				while (--g &gt;= 0)
+				{
+					if (Dprev[g] == 0)
+					{
+						bsum++;
+					}
+					else break;
+				}
+			}
+			fsum = 1;
+			g = f;
+			while (++g &lt; _param-&gt;cycle)
+			{
+				if (Dcurr[g] == 0)
+				{
+					fsum++;
+				}
+				else break;
+			}
+			if (g &gt;= _param-&gt;cycle)
+			{
+				g = -1;
+				while (++g &lt; _param-&gt;cycle)
+				{
+					if (Dnext[g] == 0)
+					{
+						fsum++;
+					}
+					else break;
+				}
+			}
+		}
+		if (bsum + fsum &gt; highest)
+		{
+			highest = bsum + fsum;
+			highest_index = f;
+		}
+//		sprintf(buf,&quot;Decimate: bsum %d, fsum %d\n&quot;, bsum, fsum);
+//		OutputDebugString(buf);
+	}
+
+	f = highest_index;
+	if (Dcurr[f] == 1)
+	{
+		/* No duplicates were found! Act as if mode=0. */
+		*chosen = last_result = frame + lowest_index;
+	}
+	else
+	{
+		/* Prevent this decimated frame from being considered again. */ 
+		Dcurr[f] = 1;
+		*chosen = last_result = frame + highest_index;
+	}
+	last_forced = false;
+	if (debug)
+	{
+		sprintf(buf,&quot;Decimate: dropping frame %d\n&quot;, last_result);
+		OutputDebugString(buf);
+	}
+
+	
+	found = false;
+	
+	if (found == true)
+	{
+		*chosen = last_result ;
+		*forced = last_forced = true;
+		if (debug)
+		{
+			sprintf(buf,&quot;Decimate: overridden drop frame -- drop %d\n&quot;, last_result);
+			OutputDebugString(buf);
+		}
+	}
+}
+#ifdef DECIMATE_MMX_BUILD_PLANE
+//
+//
+//
+//
+void isse_blend_decimate_plane(uint8_t * dst, uint8_t* src,  uint8_t* src_next, 
+			int w, int h)
+{
+uint32_t x;
+	if (!h) return;  // Height == 0 - avoid silly crash.
+	
+	x=w&gt;&gt;3; // 8 pixels at a time
+	for(;x&gt;0;x--)
+	{
+	 __asm__( &quot;.align 16\n&quot;
+	 	&quot;movq  (%1), %%mm0 \n&quot;
+		&quot;movq  (%2), %%mm2 \n&quot;
+		&quot;pavgb %%mm0,%%mm1 \n&quot;
+		&quot;movq  %%mm1,(%0) \n&quot;
+
+                   : : &quot;r&quot; (dst), &quot;r&quot; (src), &quot;r&quot; (src_next));
+		
+		dst+=8;
+		src+=8;
+		src_next+=8;
+  	}
+    	__asm__(&quot;emms&quot;);
+  
+}
+int isse_scenechange_32(const uint8_t *c_plane, const uint8_t *tplane, int height, int width) 
+{
+  int wp=width&gt;&gt;5;
+  int hp=height;
+  int returnvalue=0xbadbad00;
+    
+    __asm__(
+    &quot;.align 16\n&quot;
+    &quot;pxor %%mm6,%%mm6\n&quot;
+    &quot;pxor %%mm7,%%mm7\n&quot;
+    ::);
+    for(uint32_t y=0;y&lt;hp;y++)
+    {
+	for(uint32_t x=0;x&lt;wp;x++)
+	{
+		__asm__(
+    		&quot;.align 16\n&quot;
+    		&quot;movq (%0),%%mm0 \n&quot;
+		&quot;movq 8(%0),%%mm2 \n&quot;
+		&quot;movq (%1),%%mm1 \n&quot;
+		&quot;movq 8(%1),%%mm3 \n&quot;
+		&quot;psadbw %%mm1,%%mm0\n&quot;
+		&quot;psadbw %%mm3,%%mm2\n&quot;
+		&quot;paddd %%mm0,%%mm6 \n&quot;
+		&quot;paddd %%mm2,%%mm7 \n&quot;
+		
+		&quot;movq 16(%0),%%mm0 \n&quot;
+		&quot;movq 24(%0),%%mm2 \n&quot;
+		&quot;movq 16(%1),%%mm1 \n&quot;
+		&quot;movq 24(%1),%%mm3 \n&quot;
+		&quot;psadbw %%mm1,%%mm0\n&quot;
+		&quot;psadbw %%mm3,%%mm2\n&quot;
+		&quot;paddd %%mm0,%%mm6 \n&quot;
+		&quot;paddd %%mm2,%%mm7 \n&quot;
+		
+		
+		: : &quot;r&quot; (c_plane) , &quot;r&quot; (tplane)
+		);
+		c_plane+=32;
+		tplane+=32;
+	}    
+    
+    	c_plane+=width-wp*32;
+	tplane+=width-wp*32;
+    }
+    __asm__(
+    &quot;.align 16\n&quot;
+    &quot;paddd %%mm6,%%mm7\n&quot;
+    &quot;movd %%mm7,(%0)\n&quot;
+    &quot;emms \n&quot;
+    : : &quot;r&quot; (&amp;returnvalue)
+    );
+  
+  return returnvalue;
+}
+int isse_scenechange_16(const uint8_t *c_plane, const uint8_t *tplane, int height, int width) 
+{
+  int wp=width&gt;&gt;4;
+  int hp=height;
+  int returnvalue=0xbadbad00;
+    
+    __asm__(
+    &quot;.align 16\n&quot;
+    &quot;pxor %%mm6,%%mm6\n&quot;
+    &quot;pxor %%mm7,%%mm7\n&quot;
+    ::);
+    for(uint32_t y=0;y&lt;hp;y++)
+    {
+	for(uint32_t x=0;x&lt;wp;x++)
+	{
+		__asm__(
+    		&quot;.align 16\n&quot;
+    		&quot;movq (%0),%%mm0 \n&quot;
+		&quot;movq 8(%0),%%mm2 \n&quot;
+		&quot;movq (%1),%%mm1 \n&quot;
+		&quot;movq 8(%1),%%mm3 \n&quot;
+		&quot;psadbw %%mm1,%%mm0\n&quot;
+		&quot;psadbw %%mm3,%%mm2\n&quot;
+		&quot;paddd %%mm0,%%mm6 \n&quot;
+		&quot;paddd %%mm2,%%mm7 \n&quot;				
+		
+		
+		: : &quot;r&quot; (c_plane) , &quot;r&quot; (tplane)
+		);
+		c_plane+=16;
+		tplane+=16;
+	}    
+    
+    	c_plane+=width-wp*16;
+	tplane+=width-wp*16;
+    }
+    __asm__(
+    &quot;.align 16\n&quot;
+    &quot;paddd %%mm6,%%mm7\n&quot;
+    &quot;movd %%mm7,(%0)\n&quot;
+    &quot;emms \n&quot;
+    : : &quot;r&quot; (&amp;returnvalue)
+    );
+  
+  return returnvalue;
+}
+int isse_scenechange_8(const uint8_t *c_plane, const uint8_t *tplane, int height, int width) 
+{
+  int wp=width&gt;&gt;3;
+  int hp=height;
+  int returnvalue=0xbadbad00;
+    
+    __asm__(
+    &quot;.align 16\n&quot;
+    &quot;pxor %%mm6,%%mm6\n&quot;
+    &quot;pxor %%mm7,%%mm7\n&quot;
+    ::);
+    for(uint32_t y=0;y&lt;hp;y++)
+    {
+	for(uint32_t x=0;x&lt;wp;x++)
+	{
+		__asm__(
+    		&quot;.align 16\n&quot;
+    		&quot;movq (%0),%%mm0 \n&quot;		
+		&quot;movq (%1),%%mm1 \n&quot;		
+		&quot;psadbw %%mm1,%%mm0\n&quot;		
+		&quot;paddd %%mm0,%%mm6 \n&quot;
+		
+		: : &quot;r&quot; (c_plane) , &quot;r&quot; (tplane)
+		);
+		c_plane+=8;
+		tplane+=8;
+	}    
+    
+    	c_plane+=width-wp*8;
+	tplane+=width-wp*8;
+    }
+    __asm__(
+    &quot;.align 16\n&quot;    
+    &quot;movd %%mm6,(%0)\n&quot;
+    &quot;emms \n&quot;
+    : : &quot;r&quot; (&amp;returnvalue)
+    );
+  
+  return returnvalue;
+}
+
+#endif

Copied: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidDecDec_param.h (from rev 2489, branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidDecDec_param.h)
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidDecDec_param.h	2006-10-31 15:59:58 UTC (rev 2489)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidDecDec_param.h	2007-01-13 16:37:32 UTC (rev 2721)
@@ -0,0 +1,19 @@
+//
+// C++ Interface: ADM_vidDecDec_param
+//
+// Description: 
+//
+//
+// Author: mean &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>&gt;, (C) 2004
+//
+// Copyright: See COPYING file that comes with this distribution
+//
+//
+typedef struct DECIMATE_PARAM
+{
+	uint32_t    cycle; // Integer 2..40
+        uint32_t    mode;  // 0..3
+        uint32_t    quality; //0..4
+	double      threshold;
+        double      threshold2;
+};

Copied: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidDecTel_param.h (from rev 2489, branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidDecTel_param.h)

Copied: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidDecTelecide.cpp (from rev 2489, branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidDecTelecide.cpp)
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidDecTelecide.cpp	2006-10-31 15:59:58 UTC (rev 2489)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidDecTelecide.cpp	2007-01-13 16:37:32 UTC (rev 2721)
@@ -0,0 +1,1644 @@
+
+/***************************************************************************
+                          ADM_vidDecTelecide  -  description
+                             -------------------
+    
+    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
+
+    Port of Donal Graft Telecide which is (c) Donald Graft
+    <A HREF="http://www.neuron2.net">http://www.neuron2.net</A>
+    <A HREF="http://puschpull.org/avisynth/decomb_reference_manual.html">http://puschpull.org/avisynth/decomb_reference_manual.html</A>
+
+ ***************************************************************************/
+/*
+	Telecide plugin for Avisynth -- recovers original progressive
+	frames from telecined streams. The filter operates by matching
+	fields and automatically adapts to phase/pattern changes.
+
+	Copyright (C) 2003 Donald A. Graft
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program; if not, write to the Free Software
+	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*/
+#include &quot;config.h&quot;
+#include &lt;stdio.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;string.h&gt;
+#include &lt;ADM_assert.h&gt;
+
+#include &quot;config.h&quot;
+#include &quot;fourcc.h&quot;
+#include &quot;avio.hxx&quot;
+#include &quot;avi_vars.h&quot;
+
+#include &quot;ADM_toolkit/toolkit.hxx&quot;
+#include &quot;ADM_editor/ADM_edit.hxx&quot;
+#include &quot;ADM_video/ADM_genvideo.hxx&quot;
+
+
+#include &quot;ADM_osSupport/ADM_debugID.h&quot;
+#define MODULE_NAME MODULE_FILTER
+#include &quot;ADM_osSupport/ADM_debug.h&quot;
+
+
+
+#include &quot;ADM_vidDecTelecide.h&quot;
+#include &quot;ADM_filter/video_filters.h&quot;
+static FILTER_PARAM decomb_template={16,{&quot;order&quot;,&quot;back&quot;,&quot;guide&quot;,
+	 	 	&quot;gthresh&quot;,&quot;post&quot;,&quot;chroma&quot;,&quot;vthresh&quot;,
+			&quot;bthresh&quot;,&quot;dthresh&quot;,&quot;blend&quot;,
+			&quot;nt&quot;,&quot;y0&quot;,&quot;y1&quot;,&quot;hints&quot;,
+			&quot;show&quot;,&quot;debug&quot;}};
+BUILD_CREATE(decomb_create,Telecide);
+SCRIPT_CREATE(decomb_script,Telecide,decomb_template);
+extern uint8_t DIA_getDecombTelecide(TelecideParam *param);
+
+uint8_t Telecide::configure(AVDMGenericVideoStream *in)
+{
+	_in=in;
+//	return DIA_getDecombTelecide(_param);
+        return 0;
+	
+}
+
+char *Telecide::printConf( void )
+{
+ 	static char buf[50];
+
+  	ADM_assert(_param); 	
+ 	sprintf((char *)buf,&quot; Decomb Telecide&quot;);
+        return buf;
+}
+
+
+#define PROGRESSIVE  0x00000001
+#define MAGIC_NUMBER (0xdeadbeef)
+#define IN_PATTERN   0x00000002
+
+
+  uint8_t PutHintingData(unsigned char *video, unsigned int hint);
+  uint8_t GetHintingData(unsigned char *video, unsigned int *hint);
+  void BitBlt(uint8_t * dstp, int dst_pitch, const uint8_t* srcp,
+            int src_pitch, int row_size, int height);
+//  void DrawString(ADMImage *dst, int x, int y, const char *s);
+ // void DrawStringYUY2(uint8_t *dst, int x, int y, const char *s);
+#define DrawString drawString
+
+uint8_t Telecide::getCoupledConf( CONFcouple **couples)
+{
+
+                        ADM_assert(_param);
+                        *couples=new CONFcouple(16);
+
+#define CSET(x)  (*couples)-&gt;setCouple((char *)#x,(_param-&gt;x))
+        CSET(order);
+        CSET(back);
+        CSET(chroma);
+        CSET(guide);
+        CSET(gthresh);
+        CSET(post);
+        CSET(vthresh);
+        CSET(bthresh);
+        CSET(dthresh);
+        CSET(blend);
+        CSET(nt);
+        CSET(y0);
+        CSET(y1);
+        CSET(hints);
+        CSET(show);
+        CSET(debug);
+        
+        return 1;
+
+}
+uint8_t PutHintingData(unsigned char *video, unsigned int hint)
+{
+        unsigned char *p;
+        unsigned int i, magic_number = MAGIC_NUMBER;
+        bool error = false;
+
+        p = video;
+        for (i = 0; i &lt; 32; i++)
+        {
+                *p &amp;= ~1; 
+                *p++ |= ((magic_number &amp; (1 &lt;&lt; i)) &gt;&gt; i);
+        }
+        for (i = 0; i &lt; 32; i++)
+        {
+                *p &amp;= ~1;
+                *p++ |= ((hint &amp; (1 &lt;&lt; i)) &gt;&gt; i);
+        }
+        return error;
+}
+
+uint8_t GetHintingData(unsigned char *video, unsigned int *hint)
+{
+        unsigned char *p;
+        unsigned int i, magic_number = 0;
+        bool error = false;
+
+        p = video;
+        for (i = 0; i &lt; 32; i++)
+        {
+                magic_number |= ((*p++ &amp; 1) &lt;&lt; i);
+        }
+        if (magic_number != MAGIC_NUMBER)
+        {
+                error = true;
+        }
+        else
+        {
+                *hint = 0;
+                for (i = 0; i &lt; 32; i++)
+                {
+                        *hint |= ((*p++ &amp; 1) &lt;&lt; i);
+                }
+        }
+        return error;
+}
+void BitBlt(uint8_t* dstp, int dst_pitch, const uint8_t* srcp,
+            int src_pitch, int row_size, int height)
+{
+        for(uint32_t y=0;y&lt;height;y++)
+        {
+                memcpy(dstp,srcp,row_size);
+                dstp+=dst_pitch;
+                srcp+=src_pitch;
+        }
+}        
+void Telecide::WriteHints(unsigned char *dst, bool film, bool inpattern)
+        {
+                unsigned int hint;
+
+                if (GetHintingData(dst, &amp;hint) == true) hint = 0;
+                if (film == true) hint |= PROGRESSIVE;
+                else hint &amp;= ~PROGRESSIVE;
+                if (inpattern == true) hint |= IN_PATTERN;
+                else hint &amp;= ~IN_PATTERN;
+                PutHintingData(dst, hint);
+        }
+void Telecide::PutChosen(int frame, unsigned int chosen)
+        {
+                int f;
+
+                f = frame % CACHE_SIZE;
+                if (frame &lt; 0 || frame &gt; _info.nb_frames - 1 || cache[f].frame != frame)
+                        return;
+                cache[f].chosen = chosen;
+        }
+
+        void Telecide::CacheInsert(int frame, unsigned int p, unsigned int pblock,
+                                                                        unsigned int c, unsigned int cblock)
+        {
+                int f;
+
+                f = frame % CACHE_SIZE;
+                if (frame &lt; 0 || frame &gt; _info.nb_frames - 1)
+                        ADM_assert(0);
+                cache[f].frame = frame;
+                cache[f].metrics[P] = p;
+                if (f) cache[f-1].metrics[N] = p;
+                cache[f].metrics[C] = c;
+                cache[f].metrics[PBLOCK] = pblock;
+                cache[f].metrics[CBLOCK] = cblock;
+                cache[f].chosen = 0xff;
+        }
+
+        bool Telecide::CacheQuery(int frame, unsigned int *p, unsigned int *pblock,
+                                                                        unsigned int *c, unsigned int *cblock)
+        {
+                int f;
+
+                f = frame % CACHE_SIZE;
+                if (frame &lt; 0 || frame &gt; _info.nb_frames - 1)
+                {
+                        printf(&quot;Frame %d is out! (%d)\n&quot;,frame,_info.nb_frames-1);
+                        ADM_assert(0);
+                }
+                if (cache[f].frame != frame)
+                {
+                        return false;
+                }
+                *p = cache[f].metrics[P];
+                *c = cache[f].metrics[C];
+                *pblock = cache[f].metrics[PBLOCK];
+                *cblock = cache[f].metrics[CBLOCK];
+                return true;
+        }
+
+       
+Telecide::Telecide(AVDMGenericVideoStream *in,CONFcouple *couples) 
+{
+
+		int i;		
+		int count;
+		char *d, *dsaved;
+		unsigned int *p, *x;
+		_lastFrame=0xfffffff0;
+		
+   		
+		_in=in;		
+   		memcpy(&amp;_info,_in-&gt;getInfo(),sizeof(_info));    
+  		_info.encoding=1;
+		_uncompressed=NULL;
+		vidCache=new VideoCache(12,in);
+				 	
+  		_info.encoding=1;
+
+		
+		pitch = _info.width;
+		dpitch = _info.width;
+		pitchover2 = pitch &gt;&gt; 1;
+		pitchtimes4 = pitch &lt;&lt; 2;
+		w = _info.width;
+		h = _info.height;
+		wover2 = w/2;
+		hover2 = h/2;
+		hplus1over2 = (h+1)/2;
+		hminus2= h - 2;
+		_param=NEW(TelecideParam);
+		if(couples)
+		{
+			GET(order);
+			GET(back);
+			GET(chroma);
+			GET(guide);
+			GET(gthresh);
+			GET(post);
+			GET(vthresh);
+			GET(bthresh);
+			GET(dthresh);
+			GET(blend);
+			GET(nt);
+			GET(y0);
+			GET(y1);
+			GET(hints);
+			GET(show);
+			GET(debug);
+		}
+		else // Default
+  		{
+			 	
+			 	_param-&gt;order = 1; 		// 0 Field ok, 1 field reverted 0 BFF/1 TFF
+				_param-&gt;back = NO_BACK; // 0 Never, 1 when bad, 2 always tried MUST Have post !=0
+				_param-&gt;chroma = false;
+				_param-&gt;guide = GUIDE_32;// 0 / NONE - 1 GUIDE_32/ivtc-2 GUIDE 22/PAL-3 PAL/NTSC
+				_param-&gt;gthresh = 10.0;
+				_param-&gt;post = POST_NONE;
+				_param-&gt;vthresh = 50.0;
+				_param-&gt;bthresh = 50.0;
+				_param-&gt;dthresh = 7.0;
+				_param-&gt;blend = false;
+				_param-&gt;nt = 10;	// Noise tolerance
+				_param-&gt;y0 = 0;		// Zone to try (avoid subs)
+				_param-&gt;y1 = 0;
+				_param-&gt;hints = true;
+				_param-&gt;show = false;
+				_param-&gt;debug = false; 
+
+		}
+				 
+				
+		tff = (_param-&gt;order == 0 ? false : true);	
+
+		_param-&gt;back_saved = _param-&gt;back;
+
+		// Set up pattern guidance.
+		cache = (struct CACHE_ENTRY *) ADM_alloc(CACHE_SIZE * sizeof(struct CACHE_ENTRY));
+		for (i = 0; i &lt; CACHE_SIZE; i++)
+		{
+			cache[i].frame = 0xffffffff;
+			cache[i].chosen = 0xff;
+		}
+
+		if (_param-&gt;guide == GUIDE_32)
+		{
+			// 24fps to 30 fps telecine.
+			cycle = 5;
+		}
+		if (_param-&gt;guide == GUIDE_22)
+		{
+			// PAL guidance (expect the current match to be continued).
+			cycle = 2;
+		}
+		else if (_param-&gt;guide == GUIDE_32322)
+		{
+			// 25fps to 30 fps telecine.
+			cycle = 6;
+		}
+
+		// Get needed dynamic storage.
+		vmetric = 0;
+		_param-&gt;vthresh_saved = _param-&gt;vthresh;
+		xblocks = (_info.width+BLKSIZE-1) / BLKSIZE;
+		yblocks = (_info.height+BLKSIZE-1) / BLKSIZE;
+#ifdef WINDOWED_MATCH
+		matchp = (unsigned int *) ADM_alloc(xblocks * yblocks * sizeof(unsigned int));
+		
+		matchc = (unsigned int *) ADM_alloc(xblocks * yblocks * sizeof(unsigned int));
+		
+#endif
+		sump = (unsigned int *) ADM_alloc(xblocks * yblocks * sizeof(unsigned int));
+		
+		sumc = (unsigned int *) ADM_alloc(xblocks * yblocks * sizeof(unsigned int));
+		
+
+		
+}
+//____________________________________________________________________
+Telecide::~Telecide()
+{
+		unsigned int *p;
+
+		if (cache != NULL) ADM_dealloc(cache);
+#ifdef WINDOWED_MATCH
+		if (matchp != NULL) ADM_dealloc(matchp);
+		if (matchc != NULL) ADM_dealloc(matchc);
+#endif
+		if (sump != NULL) ADM_dealloc(sump);
+		if (sumc != NULL) ADM_dealloc(sumc);
+
+		delete vidCache;
+		vidCache=NULL;
+		
+		
+}
+//____________________________________________________________________
+void Telecide::Show(ADMImage *dst, int frame)
+{
+	char use;
+	
+	if (chosen == P) use = 'p';
+	else if (chosen == C) use = 'c';
+	else use = 'n';
+
+	sprintf(buf, &quot;Telecide %s&quot;, VERSION);
+	DrawString(dst, 0, 0, buf);
+
+	sprintf(buf, &quot;Copyright 2003 Donald A. Graft&quot;);
+	DrawString(dst, 0, 1, buf);
+
+	sprintf(buf,&quot;frame %d:&quot;, frame);
+	DrawString(dst, 0, 3, buf);
+
+	sprintf(buf, &quot;matches: %d  %d  %d&quot;, p, c, np);
+	DrawString(dst, 0, 4, buf);
+
+	if (_param-&gt;post != POST_NONE)
+	{
+		sprintf(buf,&quot;vmetrics: %d  %d  %d [chosen=%d]&quot;, pblock, cblock, npblock, vmetric);
+		DrawString(dst, 0, 5, buf);
+	}
+
+	if (_param-&gt;guide != GUIDE_NONE)
+	{
+		sprintf(buf, &quot;pattern mismatch=%0.2f%%&quot;, mismatch); 
+		DrawString(dst, 0, 5 + (_param-&gt;post != POST_NONE), buf);
+	}
+
+	sprintf(buf,&quot;[%s %c]%s %s&quot;,
+		found == true ? &quot;forcing&quot; : &quot;using&quot;, use,
+		_param-&gt;post != POST_NONE ? (film == true ? &quot; [progressive]&quot; : &quot; [interlaced]&quot;) : &quot;&quot;,
+		_param-&gt;guide != GUIDE_NONE ? status : &quot;&quot;);
+	DrawString(dst, 0, 5 + (_param-&gt;post != POST_NONE) + (_param-&gt;guide != GUIDE_NONE), buf);
+}
+//______________________________________________________________
+void Telecide::Debug(int frame)
+{
+	char use;
+
+	if (chosen == P) use = 'p';
+	else if (chosen == C) use = 'c';
+	else use = 'n';
+	sprintf(buf,&quot;Telecide: frame %d: matches: %d %d %d&quot;, frame, p, c, np);
+	OutputDebugString(buf);
+	if (_param-&gt;post != POST_NONE)
+	{
+		sprintf(buf,&quot;Telecide: frame %d: vmetrics: %d %d %d [chosen=%d]&quot;, frame, pblock, cblock, npblock, vmetric);
+		OutputDebugString(buf);
+	}
+	sprintf(buf,&quot;Telecide: frame %d: [%s %c]%s %s&quot;, frame, found == true ? &quot;forcing&quot; : &quot;using&quot;, use,
+		_param-&gt;post != POST_NONE ? (film == true ? &quot; [progressive]&quot; : &quot; [interlaced]&quot;) : &quot;&quot;,
+		_param-&gt;guide != GUIDE_NONE ? status : &quot;&quot;);
+	OutputDebugString(buf);
+}
+
+//______________________________________________________________
+uint8_t Telecide::getFrameNumberNoAlloc(uint32_t frame,
+				uint32_t *len,
+   				ADMImage *data,
+				uint32_t *flags)
+{
+ADMImage *fc;
+uint8_t *fcrp;
+uint8_t *fcrpU,*fcrpV;
+
+uint32_t pframe,nframe;
+
+ADMImage *fp;
+uint8_t *fprp;
+uint8_t *fprpU,*fprpV;
+
+ADMImage *fn;
+uint8_t *fnrp;
+uint8_t *fnrpU,*fnrpV;
+
+ADMImage *lc;
+uint8_t *crp;
+uint8_t *crpU,*crpV;
+
+ADMImage *lp;
+uint8_t *prp;
+uint8_t *prpU,*prpV;
+
+ADMImage *dst;
+uint8_t *dstp;
+uint8_t *dstpU,*dstpV;
+
+ADMImage *final;
+uint8_t *finalp;
+uint8_t *finalpU,*finalpV;
+
+
+#define guide _param-&gt;guide
+#define order _param-&gt;order
+#define back  _param-&gt;back
+
+#define back_saved  _param-&gt;back_saved
+#define guide       _param-&gt;guide
+#define gthresh     _param-&gt;gthresh
+#define post        _param-&gt;post
+#define chroma      _param-&gt;chroma
+#define vthresh     _param-&gt;vthresh
+
+#define vthresh_saved _param-&gt;vthresh_saved
+#define hints      _param-&gt;hints
+#define show       _param-&gt;show
+#define debug      _param-&gt;debug
+
+#define bthresh      _param-&gt;bthresh
+#define dthresh      _param-&gt;dthresh
+#define blend        _param-&gt;blend
+
+#define nt      _param-&gt;nt
+#define y0      _param-&gt;y0
+#define y1      _param-&gt;y1
+
+        // Get the current frame.
+        if (frame &lt; 0) frame = 0;
+        if (frame &gt; _info.nb_frames - 1) frame = _info.nb_frames - 1;
+        GETFRAME(frame, fc);
+        fcrp = (unsigned char *) fc-&gt;GetReadPtr(PLANAR_Y);
+        //if (vi.IsYV12())
+        {
+                fcrpU = (unsigned char *) fc-&gt;GetReadPtr(PLANAR_U);
+                fcrpV = (unsigned char *) fc-&gt;GetReadPtr(PLANAR_V);
+        }
+
+        // Get the previous frame.
+        pframe = frame == 0 ? 0 : frame - 1;
+        GETFRAME(pframe, fp);
+        fprp = (unsigned char *) fp-&gt;GetReadPtr(PLANAR_Y);
+        //if (vi.IsYV12())
+        {
+                fprpU = (unsigned char *) fp-&gt;GetReadPtr(PLANAR_U);
+                fprpV = (unsigned char *) fp-&gt;GetReadPtr(PLANAR_V);
+        }
+
+        // Get the next frame metrics if we might need them.
+        nframe = frame &gt;= _info.nb_frames - 1 ? _info.nb_frames - 1 : frame + 1;
+        GETFRAME(nframe, fn);
+        fnrp = (unsigned char *) fn-&gt;GetReadPtr(PLANAR_Y);
+        //if (vi.IsYV12())
+        {
+                fnrpU = (unsigned char *) fn-&gt;GetReadPtr(PLANAR_U);
+                fnrpV = (unsigned char *) fn-&gt;GetReadPtr(PLANAR_V);
+        }
+
+        pitch = fc-&gt;GetPitch(PLANAR_Y);
+        pitchover2 = pitch &gt;&gt; 1;
+        pitchtimes4 = pitch &lt;&lt; 2;
+        w = fc-&gt;GetRowSize(PLANAR_Y);
+        h = fc-&gt;GetHeight(PLANAR_Y);
+/*
+        if (vi.IsYUY2() &amp;&amp; ((w/2) &amp; 1))
+                env-&gt;ThrowError(&quot;Telecide: width must be a multiple of 2; use Crop&quot;);
+        if (vi.IsYV12() &amp;&amp; (w &amp; 1))
+                env-&gt;ThrowError(&quot;Telecide: width must be a multiple of 2; use Crop&quot;);
+        if (h &amp; 1)
+                env-&gt;ThrowError(&quot;Telecide: height must be a multiple of 2; use Crop&quot;);
+*/
+        wover2 = w/2;
+        hover2 = h/2;
+        hplus1over2 = (h+1)/2;
+        hminus2= h - 2;
+        //dst = env-&gt;NewVideoFrame(vi);
+        dst=data;
+        dpitch = dst-&gt;GetPitch(PLANAR_Y);
+
+        // Ensure that the metrics for the frames
+        // after the current frame are in the cache. They will be used for
+        // pattern guidance.
+        if (guide != GUIDE_NONE)
+        {
+                for (y = frame + 1; y &lt;= frame + cycle + 1; y++)
+                {
+                        if (y &gt; _info.nb_frames - 1) break;
+                        if (CacheQuery(y, &amp;p, &amp;pblock, &amp;c, &amp;cblock) == false)
+                        {
+                                GETFRAME(y, lc);
+                                crp = (unsigned char *) lc-&gt;GetReadPtr(PLANAR_Y);
+                                //if (vi.IsYV12())
+                                {
+                                        crpU = (unsigned char *) lc-&gt;GetReadPtr(PLANAR_U);
+                                        crpV = (unsigned char *) lc-&gt;GetReadPtr(PLANAR_V);
+                                }
+                                GETFRAME(y == 0 ? 1 : y - 1, lp);
+                                prp = (unsigned char *) lp-&gt;GetReadPtr(PLANAR_Y);
+                                //if (vi.IsYV12())
+                                {
+                                        prpU = (unsigned char *) lp-&gt;GetReadPtr(PLANAR_U);
+                                        prpV = (unsigned char *) lp-&gt;GetReadPtr(PLANAR_V);
+                                }
+                                CalculateMetrics(y, crp, crpU, crpV, prp, prpU, prpV);
+                        }
+                }
+        }
+
+        /* Check for manual overrides of the field matching. */
+        
+        found = false;
+        film = true;
+        
+        inpattern = false;
+        vthresh = vthresh_saved;
+        back = back_saved;
+#if 0
+        overrides_p = overrides;
+        override = false;
+        if (overrides_p != NULL)
+        {
+                while (*overrides_p &lt; 0xffffffff)
+                {
+                        // If the frame is in range...
+                        if (((unsigned int) frame &gt;= *overrides_p) &amp;&amp; ((unsigned int) frame &lt;= *(overrides_p+1)))
+                        {
+                                // and it's a single specifier. 
+                                if (*(overrides_p+3) == 'p' || *(overrides_p+3) == 'c' || *(overrides_p+3) == 'n')
+                                {
+                                        // Get the match specifier and stop parsing.
+                                        switch(*(overrides_p+3))
+                                        {
+                                        case 'p': chosen = P; lowest = cache[frame%CACHE_SIZE].metrics[P]; found = true; break;
+                                        case 'c': chosen = C; lowest = cache[frame%CACHE_SIZE].metrics[C]; found = true; break;
+                                        case 'n': chosen = N; lowest = cache[(frame+1)%CACHE_SIZE].metrics[P]; found = true; break;
+                                        }
+                                }
+                                else if (*(overrides_p+3) == 'b')
+                                {
+                                        back = *(overrides_p+2);
+                                }
+                                else if (*(overrides_p+3) == 'm')
+                                {
+                                        // It's a multiple match specifier.
+                                        found = true;
+                                        // Get the pointer to the specifier string.
+                                        unsigned int *x = (unsigned int *) *(overrides_p+2);
+                                        // Get the index into the specification string.
+                                        // Remember, the count is first followed by the specifiers.
+                                        int ndx = ((frame - *overrides_p) % *x);
+                                        // Point to the specifier string.
+                                        x++;
+                                        // Load the specifier for this frame and stop parsing.
+                                        switch(x[ndx])
+                                        {
+                                        case 'p': chosen = P; lowest = cache[frame%CACHE_SIZE].metrics[P]; break;
+                                        case 'c': chosen = C; lowest = cache[frame%CACHE_SIZE].metrics[C]; break;
+                                        case 'n': chosen = N; lowest = cache[(frame+1)%CACHE_SIZE].metrics[P]; break;
+                                        }
+                                }
+                        }
+                        // Next override line.
+                        overrides_p += 4;
+                }
+        }
+#endif
+        // Get the metrics for the current-previous (p), current-current (c), and current-next (n) match candidates.
+        if (CacheQuery(frame, &amp;p, &amp;pblock, &amp;c, &amp;cblock) == false)
+        {
+                CalculateMetrics(frame, fcrp, fcrpU, fcrpV, fprp, fprpU, fprpV);
+                CacheQuery(frame, &amp;p, &amp;pblock, &amp;c, &amp;cblock);
+        }
+        if (CacheQuery(nframe, &amp;np, &amp;npblock, &amp;nc, &amp;ncblock) == false)
+        {
+                CalculateMetrics(nframe, fnrp, fnrpU, fnrpV, fcrp, fcrpU, fcrpV);
+                CacheQuery(nframe, &amp;np, &amp;npblock, &amp;nc, &amp;ncblock);
+        }
+
+        // Determine the best candidate match.
+        if (found != true)
+        {
+                lowest = c;
+                chosen = C;
+                if (back == ALWAYS_BACK &amp;&amp; p &lt; lowest)
+                {
+                        lowest = p;
+                        chosen = P;
+                }
+                if (np &lt; lowest)
+                {
+                        lowest = np;
+                        chosen = N;
+                }
+        }
+        if ((frame == 0 &amp;&amp; chosen == P) || (frame == _info.nb_frames - 1 &amp;&amp; chosen == N))
+        {
+                chosen = C;
+                lowest = c;
+        }
+
+        // See if we can apply pattern guidance.
+        mismatch = 100.0;
+        if (guide != GUIDE_NONE)
+        {
+                hard = false;
+                if (frame &gt;= cycle &amp;&amp; PredictHardYUY2(frame, &amp;predicted, &amp;predicted_metric) == true)
+                {
+                        inpattern = true;
+                        mismatch = 0.0;
+                        hard = true;
+                        if (chosen != predicted)
+                        {
+                                // The chosen frame doesn't match the prediction.
+                                if (predicted_metric == 0) mismatch = 0.0;
+                                else mismatch = (100.0*abs(predicted_metric - lowest))/predicted_metric;
+                                if (mismatch &lt; gthresh)
+                                {
+                                        // It's close enough, so use the predicted one.
+                                        if (found != true)
+                                        {
+                                                chosen = predicted;
+                                                override = true;
+                                        }
+                                }
+                                else
+                                {
+                                        hard = false;
+                                        inpattern = false;
+                                }
+                        }
+                }
+
+                if (hard == false &amp;&amp; guide != GUIDE_22)
+                {
+                        int i;
+                        struct PREDICTION *pred = PredictSoftYUY2(frame);
+
+                        if ((frame &lt;= _info.nb_frames - 1 - cycle) &amp;&amp;     (pred[0].metric != 0xffffffff))
+                        {
+                                // Apply pattern guidance.
+                                // If the predicted match metric is within defined percentage of the
+                                // best calculated one, then override the calculated match with the
+                                // predicted match.
+                                i = 0;
+                                while (pred[i].metric != 0xffffffff)
+                                {
+                                        predicted = pred[i].predicted;
+                                        predicted_metric = pred[i].predicted_metric;
+#ifdef DEBUG_PATTERN_GUIDANCE
+                                        sprintf(buf, &quot;%d: predicted = %d\n&quot;, frame, predicted);
+                                        OutputDebugString(buf);
+#endif
+                                        if (chosen != predicted)
+                                        {
+                                                // The chosen frame doesn't match the prediction.
+                                                if (predicted_metric == 0) mismatch = 0.0;
+                                                else mismatch = (100.0*abs(predicted_metric - lowest))/predicted_metric;
+                                                if ((int) mismatch &lt;= gthresh)
+                                                {
+                                                        // It's close enough, so use the predicted one.
+                                                        if (found != true)
+                                                        {
+                                                                chosen = predicted;
+                                                                override = true;
+                                                        }
+                                                        inpattern = true;
+                                                        break;
+                                                }
+                                                else
+                                                {
+                                                        // Looks like we're not in a predictable pattern.
+                                                        inpattern = false;
+                                                }
+                                        }
+                                        else
+                                        {
+                                                inpattern = true;
+                                                mismatch = 0.0;
+                                                break;
+                                        }
+                                        i++;
+                                }
+                        }
+                }
+        }
+
+        // Check for overrides of vthresh.
+#if 0
+        overrides_p = overrides;
+        if (overrides_p != NULL)
+        {
+                while (*overrides_p &lt; 0xffffffff)
+                {
+                        // If the frame is in range...
+                        if (((unsigned int) frame &gt;= *overrides_p) &amp;&amp; ((unsigned int) frame &lt;= *(overrides_p+1)))
+                        {
+                                if (*(overrides_p+3) == 'v')
+                                {
+                                        vthresh = *(overrides_p+2);
+                                }
+                        }
+                        // Next override line.
+                        overrides_p += 4;
+                }
+        }
+#endif
+        // Check the match for progressive versus interlaced.
+        if (post != POST_NONE)
+        {
+                if (chosen == P) vmetric = pblock;
+                else if (chosen == C) vmetric = cblock;
+                else if (chosen == N) vmetric = npblock;
+
+                if (found == false &amp;&amp; back == BACK_ON_COMBED &amp;&amp; vmetric &gt; bthresh &amp;&amp; p &lt; lowest)
+                {
+                        // Backward match.
+                        vmetric = pblock;
+                        chosen = P;
+                        inpattern = false;
+                        mismatch = 100;
+                }
+                if (vmetric &gt; vthresh)
+                {
+                        // After field matching and pattern guidance the frame is still combed.
+                        film = false;
+                        if (found == false &amp;&amp; (post == POST_FULL_NOMATCH || post == POST_FULL_NOMATCH_MAP))
+                        {
+                                chosen = C;
+                                vmetric = cblock;
+                                inpattern = false;
+                                mismatch = 100;
+                        }
+                }
+        }
+        vthresh = vthresh_saved;
+
+        // Setup strings for debug info.
+        if (inpattern == true &amp;&amp; override == false) strcpy(status, &quot;[in-pattern]&quot;);
+        else if (inpattern == true &amp;&amp; override == true) strcpy(status, &quot;[in-pattern*]&quot;);
+        else strcpy(status, &quot;[out-of-pattern]&quot;);
+
+        // Assemble and output the reconstructed frame according to the final match.
+        dstp = dst-&gt;GetWritePtr(PLANAR_Y);
+//    if (vi.IsYV12())
+        {
+                dstpU = dst-&gt;GetWritePtr(PLANAR_U);
+                dstpV = dst-&gt;GetWritePtr(PLANAR_V);
+        }
+        if (chosen == N)
+        {
+                // The best match was with the next frame.
+                if (tff == true)
+                {
+                        BitBlt(dstp, 2 * dpitch, fnrp, 2 * pitch, w, hover2);
+                        BitBlt(dstp + dpitch, 2 * dpitch, fcrp + pitch, 2 * pitch, w, hover2);
+                        //if (vi.IsYV12())
+                        {
+                                BitBlt(dstpU, dpitch, fnrpU, pitch, w/2, h/4);
+                                BitBlt(dstpV, dpitch, fnrpV, pitch, w/2, h/4);
+                                BitBlt(dstpU + dpitch/2, dpitch, fcrpU + pitch/2, pitch, w/2, h/4);
+                                BitBlt(dstpV + dpitch/2, dpitch, fcrpV + pitch/2, pitch, w/2, h/4);
+                        }
+                }
+                else
+                {
+                        BitBlt(dstp, 2 * dpitch, fcrp, 2 * pitch, w, hplus1over2);
+                        BitBlt(dstp + dpitch, 2 * dpitch, fnrp + pitch, 2 * pitch, w, hover2);
+                        //if (vi.IsYV12())
+                        {
+                                BitBlt(dstpU, dpitch, fcrpU, pitch, w/2, h/4);
+                                BitBlt(dstpV, dpitch, fcrpV, pitch, w/2, h/4);
+                                BitBlt(dstpU + dpitch/2, dpitch, fnrpU + pitch/2, pitch, w/2, h/4);
+                                BitBlt(dstpV + dpitch/2, dpitch, fnrpV + pitch/2, pitch, w/2, h/4);
+                        }
+                }
+        }
+        else if (chosen == C)
+        {
+                // The best match was with the current frame.
+                BitBlt(dstp, 2 * dpitch, fcrp, 2 * pitch, w, hplus1over2);
+                BitBlt(dstp + dpitch, 2 * dpitch, fcrp + pitch, 2 * pitch, w, hover2);
+                //if (vi.IsYV12())
+                {
+                        BitBlt(dstpU, dpitch, fcrpU, pitch, w/2, h/4);
+                        BitBlt(dstpV, dpitch, fcrpV, pitch, w/2, h/4);
+                        BitBlt(dstpU + dpitch/2, dpitch, fcrpU + pitch/2, pitch, w/2, h/4);
+                        BitBlt(dstpV + dpitch/2, dpitch, fcrpV + pitch/2, pitch, w/2, h/4);
+                }
+        }
+        else if (tff == false)
+        {
+                // The best match was with the previous frame.
+                BitBlt(dstp, 2 * dpitch, fprp, 2 * pitch, w, hplus1over2);
+                BitBlt(dstp + dpitch, 2 * dpitch, fcrp + pitch, 2 * pitch, w, hover2);
+               // if (vi.IsYV12())
+                {
+                        BitBlt(dstpU, dpitch, fprpU, pitch, w/2, h/4);
+                        BitBlt(dstpV, dpitch, fprpV, pitch, w/2, h/4);
+                        BitBlt(dstpU + dpitch/2, dpitch, fcrpU + pitch/2, pitch, w/2, h/4);
+                        BitBlt(dstpV + dpitch/2, dpitch, fcrpV + pitch/2, pitch, w/2, h/4);
+                }
+        }
+        else
+        {
+                // The best match was with the previous frame.
+                BitBlt(dstp, 2 * dpitch, fcrp, 2 * pitch, w, hplus1over2);
+                BitBlt(dstp + dpitch, 2 * dpitch, fprp + pitch, 2 * pitch, w, hover2);
+               // if (vi.IsYV12())
+                {
+                        BitBlt(dstpU, dpitch, fcrpU, pitch, w/2, h/4);
+                        BitBlt(dstpV, dpitch, fcrpV, pitch, w/2, h/4);
+                        BitBlt(dstpU + dpitch/2, dpitch, fprpU + pitch/2, pitch, w/2, h/4);
+                        BitBlt(dstpV + dpitch/2, dpitch, fprpV + pitch/2, pitch, w/2, h/4);
+                }
+        }
+        if (guide != GUIDE_NONE) PutChosen(frame, chosen);
+
+        /* Check for manual overrides of the deinterlacing. */
+#if 0
+        overrides_p = overrides;
+        force = 0;
+        if (overrides_p != NULL)
+        {
+                while (*overrides_p &lt; 0xffffffff)
+                {
+                        // Is the frame in range...
+                        if (((unsigned int) frame &gt;= *overrides_p) &amp;&amp; ((unsigned int) frame &lt;= *(overrides_p+1)) &amp;&amp;
+                                // and is it a single specifier...
+                                (*(overrides_p+2) == 0) &amp;&amp;
+                                // and is it a deinterlacing specifier?
+                                (*(overrides_p+3) == '+' || *(overrides_p+3) == '-'))
+                        {
+                                // Yes, load the specifier and stop parsing.
+                                overrides_p += 3;
+                                force = *overrides_p;
+                                break;
+                        }
+                        // Next specification record.
+                        overrides_p += 4;
+                }
+        }
+#endif
+        // Do postprocessing if enabled and required for this frame.
+        if (post == POST_NONE || post == POST_METRICS)
+        {
+                if (force == '+') film = false;
+                else if (force == '-') film = true;
+        }
+        else if ((force == '+') ||
+                ((post == POST_FULL || post == POST_FULL_MAP || post == POST_FULL_NOMATCH || post == POST_FULL_NOMATCH_MAP)
+                         &amp;&amp; (film == false &amp;&amp; force != '-')))
+        {
+                unsigned char *dstpp, *dstpn;
+                int v1, v2, z;
+
+                if (blend == true)
+                {
+                        // Blend mode.
+                        final = data; //env-&gt;NewVideoFrame(vi);
+                        // Do first and last lines.
+                        finalp = final-&gt;GetWritePtr(PLANAR_Y);
+                        dstp = dst-&gt;GetWritePtr(PLANAR_Y);
+                        dstpn = dstp + dpitch;
+                        for (x = 0; x &lt; w; x++)
+                        {
+                                finalp[x] = (((int)dstp[x] + (int)dstpn[x]) &gt;&gt; 1);
+                        }
+                        finalp = final-&gt;GetWritePtr(PLANAR_Y) + (h-1)*dpitch;
+                        dstp = dst-&gt;GetWritePtr(PLANAR_Y) + (h-1)*dpitch;
+                        dstpp = dstp - dpitch;
+                        for (x = 0; x &lt; w; x++)
+                        {
+                                finalp[x] = (((int)dstp[x] + (int)dstpp[x]) &gt;&gt; 1);
+                        }
+                        // Now do the rest.
+                        dstp = dst-&gt;GetWritePtr(PLANAR_Y) + dpitch;
+                        dstpp = dstp - dpitch;
+                        dstpn = dstp + dpitch;
+                        finalp = final-&gt;GetWritePtr(PLANAR_Y) + dpitch;
+                        for (y = 1; y &lt; h - 1; y++)
+                        {
+                                for (x = 0; x &lt; w; x++)
+                                {
+                                        v1 = (int) dstp[x] - dthresh;
+                                        if (v1 &lt; 0) v1 = 0; 
+                                        v2 = (int) dstp[x] + dthresh;
+                                        if (v2 &gt; 235) v2 = 235; 
+                                        if ((v1 &gt; dstpp[x] &amp;&amp; v1 &gt; dstpn[x]) || (v2 &lt; dstpp[x] &amp;&amp; v2 &lt; dstpn[x]))
+                                        {
+                                                if (post == POST_FULL_MAP || post == POST_FULL_NOMATCH_MAP)
+                                                {
+                                                        if (0) //(vi.IsYUY2())
+                                                        {
+                                                                if (x &amp; 1) finalp[x] = 128;
+                                                                else finalp[x] = 235;
+                                                        }
+                                                        else
+                                                        {
+                                                                finalp[x] = 235;
+                                                        }
+                                                }
+                                                else
+                                                        finalp[x] = ((int)dstpp[x] + (int)dstpn[x] + (int)dstp[x] + (int)dstp[x]) &gt;&gt; 2;
+                                        }
+                                        else finalp[x] = dstp[x];
+                                }
+                                finalp += dpitch;
+                                dstp += dpitch;
+                                dstpp += dpitch;
+                                dstpn += dpitch;
+                        }
+
+                      //  if (vi.IsYV12())
+                        {
+                                // Chroma planes.
+                                for (z = 0; z &lt; 2; z++)
+                                {
+                                        if (z == 0)
+                                        {
+                                                // Do first and last lines.
+                                                finalp = final-&gt;GetWritePtr(PLANAR_U);
+                                                dstp = dst-&gt;GetWritePtr(PLANAR_U);
+                                                dstpn = dstp + dpitch/2;
+                                                for (x = 0; x &lt; wover2; x++)
+                                                {
+                                                        finalp[x] = (((int)dstp[x] + (int)dstpn[x]) &gt;&gt; 1);
+                                                }
+                                                finalp = final-&gt;GetWritePtr(PLANAR_U) + (hover2-1)*dpitch/2;
+                                                dstp = dst-&gt;GetWritePtr(PLANAR_U) + (hover2-1)*dpitch/2;
+                                                dstpp = dstp - dpitch/2;
+                                                for (x = 0; x &lt; wover2; x++)
+                                                {
+                                                        finalp[x] = (((int)dstp[x] + (int)dstpp[x]) &gt;&gt; 1);
+                                                }
+                                                // Now do the rest.
+                                                finalp = final-&gt;GetWritePtr(PLANAR_U) + dpitch/2;
+                                                dstp = dst-&gt;GetWritePtr(PLANAR_U) + dpitch/2;
+                                        }
+                                        else
+                                        {
+                                                // Do first and last lines.
+                                                finalp = final-&gt;GetWritePtr(PLANAR_V);
+                                                dstp = dst-&gt;GetWritePtr(PLANAR_V);
+                                                dstpn = dstp + dpitch/2;
+                                                for (x = 0; x &lt; wover2; x++)
+                                                {
+                                                        finalp[x] = (((int)dstp[x] + (int)dstpn[x]) &gt;&gt; 1);
+                                                }
+                                                finalp = final-&gt;GetWritePtr(PLANAR_V) + (hover2-1)*dpitch/2;
+                                                dstp = dst-&gt;GetWritePtr(PLANAR_V) + (hover2-1)*dpitch/2;
+                                                dstpp = dstp - dpitch/2;
+                                                for (x = 0; x &lt; wover2; x++)
+                                                {
+                                                        finalp[x] = (((int)dstp[x] + (int)dstpp[x]) &gt;&gt; 1);
+                                                }
+                                                // Now do the rest.
+                                                finalp = final-&gt;GetWritePtr(PLANAR_V) + dpitch/2;
+                                                dstp = dst-&gt;GetWritePtr(PLANAR_V) + dpitch/2;
+                                        }
+                                        dstpp = dstp - dpitch/2;
+                                        dstpn = dstp + dpitch/2;
+                                        for (y = 1; y &lt; hover2 - 1; y++)
+                                        {
+                                                for (x = 0; x &lt; wover2; x++)
+                                                {
+                                                        v1 = (int) dstp[x] - dthresh;
+                                                        if (v1 &lt; 0) v1 = 0; 
+                                                        v2 = (int) dstp[x] + dthresh;
+                                                        if (v2 &gt; 235) v2 = 235; 
+                                                        if ((v1 &gt; dstpp[x] &amp;&amp; v1 &gt; dstpn[x]) || (v2 &lt; dstpp[x] &amp;&amp; v2 &lt; dstpn[x]))
+                                                        {
+                                                                if (post == POST_FULL_MAP || post == POST_FULL_NOMATCH_MAP)
+                                                                {
+                                                                        finalp[x] = 128;
+                                                                }
+                                                                else
+                                                                        finalp[x] = ((int)dstpp[x] + (int)dstpn[x] + (int)dstp[x] + (int)dstp[x]) &gt;&gt; 2;
+                                                        }
+                                                        else finalp[x] = dstp[x];
+                                                }
+                                                finalp += dpitch/2;
+                                                dstp += dpitch/2;
+                                                dstpp += dpitch/2;
+                                                dstpn += dpitch/2;
+                                        }
+                                }
+                        }
+                        if (show == true) Show(final, frame);
+                        if (debug == true) Debug(frame);
+                        if (hints == true) WriteHints(final-&gt;GetWritePtr(PLANAR_Y), film, inpattern);
+                       // return final;
+                        vidCache-&gt;unlockAll();
+                        return 1;
+                }
+
+                // Interpolate mode.
+                // Luma plane.
+                dstp = dst-&gt;GetWritePtr(PLANAR_Y) + dpitch;
+                dstpp = dstp - dpitch;
+                dstpn = dstp + dpitch;
+                for (y = 1; y &lt; h - 1; y+=2)
+                {
+                        for (x = 0; x &lt; w; x++)
+                        {
+                                v1 = (int) dstp[x] - dthresh;
+                                if (v1 &lt; 0) v1 = 0; 
+                                v2 = (int) dstp[x] + dthresh;
+                                if (v2 &gt; 235) v2 = 235; 
+                                if ((v1 &gt; dstpp[x] &amp;&amp; v1 &gt; dstpn[x]) || (v2 &lt; dstpp[x] &amp;&amp; v2 &lt; dstpn[x]))
+                                {
+                                        if (post == POST_FULL_MAP || post == POST_FULL_NOMATCH_MAP)
+                                        {
+                                                if(0) // (vi.IsYUY2())
+                                                {
+                                                        if (x &amp; 1) dstp[x] = 128;
+                                                        else dstp[x] = 235;
+                                                }
+                                                else
+                                                {
+                                                        dstp[x] = 235;
+                                                }
+                                        }
+                                        else
+                                                dstp[x] = (dstpp[x] + dstpn[x]) &gt;&gt; 1;
+                                }
+                        }
+                        dstp += 2*dpitch;
+                        dstpp += 2*dpitch;
+                        dstpn += 2*dpitch;
+                }
+
+               // if (vi.IsYV12())
+                {
+                        // Chroma planes.
+                        for (z = 0; z &lt; 2; z++)
+                        {
+                                if (z == 0) dstp = dst-&gt;GetWritePtr(PLANAR_U) + dpitch/2;
+                                else dstp = dst-&gt;GetWritePtr(PLANAR_V) + dpitch/2;
+                                dstpp = dstp - dpitch/2;
+                                dstpn = dstp + dpitch/2;
+                                for (y = 1; y &lt; hover2 - 1; y+=2)
+                                {
+                                        for (x = 0; x &lt; wover2; x++)
+                                        {
+                                                v1 = (int) dstp[x] - dthresh;
+                                                if (v1 &lt; 0) v1 = 0; 
+                                                v2 = (int) dstp[x] + dthresh;
+                                                if (v2 &gt; 235) v2 = 235; 
+                                                if ((v1 &gt; dstpp[x] &amp;&amp; v1 &gt; dstpn[x]) || (v2 &lt; dstpp[x] &amp;&amp; v2 &lt; dstpn[x]))
+                                                {
+                                                        if (post == POST_FULL_MAP || post == POST_FULL_NOMATCH_MAP)
+                                                        {
+                                                                dstp[x] = 128;
+                                                        }
+                                                        else
+                                                                dstp[x] = (dstpp[x] + dstpn[x]) &gt;&gt; 1;
+                                                }
+                                        }
+                                        dstp += dpitch;
+                                        dstpp += dpitch;
+                                        dstpn += dpitch;
+                                }
+                        }
+                }
+        }
+
+        if (show == true) Show(dst, frame);
+        if (debug == true) Debug(frame);
+        if (hints == true) WriteHints(dst-&gt;GetWritePtr(PLANAR_Y), film, inpattern);
+        vidCache-&gt;unlockAll();
+        //return dst;
+        return 1;
+}
+void Telecide::CalculateMetrics(int frame, unsigned char *fcrp, unsigned char *fcrpU, unsigned char *fcrpV,
+                                                                        unsigned char *fprp, unsigned char *fprpU, unsigned char *fprpV)
+{
+        int x, y, p, c, tmp1, tmp2, skip;
+        bool vc;
+    unsigned char *currbot0, *currbot2, *prevbot0, *prevbot2;
+        unsigned char *prevtop0, *prevtop2, *prevtop4, *currtop0, *currtop2, *currtop4;
+        unsigned char *a0, *a2, *b0, *b2, *b4;
+        unsigned int diff, index;
+#define T 4
+
+        /* Clear the block sums. */
+        for (y = 0; y &lt; yblocks; y++)
+        {
+                for (x = 0; x &lt; xblocks; x++)
+                {
+#ifdef WINDOWED_MATCH
+                        matchp[y*xblocks+x] = 0;
+                        matchc[y*xblocks+x] = 0;
+#endif
+                        sump[y*xblocks+x] = 0;
+                        sumc[y*xblocks+x] = 0;
+                }
+        }
+
+        /* Find the best field match. Subsample the frames for speed. */
+        currbot0  = fcrp + pitch;
+        currbot2  = fcrp + 3 * pitch;
+        currtop0 = fcrp;
+        currtop2 = fcrp + 2 * pitch;
+        currtop4 = fcrp + 4 * pitch;
+        prevbot0  = fprp + pitch;
+        prevbot2  = fprp + 3 * pitch;
+        prevtop0 = fprp;
+        prevtop2 = fprp + 2 * pitch;
+        prevtop4 = fprp + 4 * pitch;
+        if (tff == true)
+        {
+                a0 = prevbot0;
+                a2 = prevbot2;
+                b0 = currtop0;
+                b2 = currtop2;
+                b4 = currtop4;
+        }
+        else
+        {
+                a0 = currbot0;
+                a2 = currbot2;
+                b0 = prevtop0;
+                b2 = prevtop2;
+                b4 = prevtop4;
+        }
+        p = c = 0;
+
+        // Calculate the field match and film/video metrics.
+        //if (vi.IsYV12()) skip = 1;
+        if(1) skip=1;
+        else skip = 1 + (chroma == false);
+        for (y = 0, index = 0; y &lt; h - 4; y+=4)
+        {
+                /* Exclusion band. Good for ignoring subtitles. */
+                if (y0 == y1 || y &lt; y0 || y &gt; y1)
+                {
+                        for (x = 0; x &lt; w;)
+                        {
+                                if (1) //vi.IsYV12())
+                                        index = (y/BLKSIZE)*xblocks + x/BLKSIZE;
+                                else
+                                        index = (y/BLKSIZE)*xblocks + x/BLKSIZE_TIMES2;
+
+                                // Test combination with current frame.
+                                tmp1 = ((long)currbot0[x] + (long)currbot2[x]);
+//                              diff = abs((long)currtop0[x] - (tmp1 &gt;&gt; 1));
+                                diff = abs((((long)currtop0[x] + (long)currtop2[x] + (long)currtop4[x])) - (tmp1 &gt;&gt; 1) - tmp1);
+                                if (diff &gt; nt)
+                                {
+                                        c += diff;
+#ifdef WINDOWED_MATCH
+                                        matchc[index] += diff;
+#endif
+                                }
+
+                                tmp1 = currbot0[x] + T;
+                                tmp2 = currbot0[x] - T;
+                                vc = (tmp1 &lt; currtop0[x] &amp;&amp; tmp1 &lt; currtop2[x]) ||
+                                         (tmp2 &gt; currtop0[x] &amp;&amp; tmp2 &gt; currtop2[x]);
+                                if (vc)
+                                {
+                                        sumc[index]++;
+                                }
+
+                                // Test combination with previous frame.
+                                tmp1 = ((long)a0[x] + (long)a2[x]);
+                                diff = abs((((long)b0[x] + (long)b2[x] + (long)b4[x])) - (tmp1 &gt;&gt; 1) - tmp1);
+                                if (diff &gt; nt)
+                                {
+                                        p += diff;
+#ifdef WINDOWED_MATCH
+                                        matchp[index] += diff;
+#endif
+                                }
+
+                                tmp1 = a0[x] + T;
+                                tmp2 = a0[x] - T;
+                                vc = (tmp1 &lt; b0[x] &amp;&amp; tmp1 &lt; b2[x]) ||
+                                         (tmp2 &gt; b0[x] &amp;&amp; tmp2 &gt; b2[x]);
+                                if (vc)
+                                {
+                                        sump[index]++;
+                                }
+
+                                x += skip;
+                                if (!(x&amp;3)) x += 4;
+                        }
+                }
+                currbot0 += pitchtimes4;
+                currbot2 += pitchtimes4;
+                currtop0 += pitchtimes4;
+                currtop2 += pitchtimes4;
+                currtop4 += pitchtimes4;
+                a0               += pitchtimes4;
+                a2               += pitchtimes4;
+                b0               += pitchtimes4;
+                b2               += pitchtimes4;
+                b4               += pitchtimes4;
+        }
+
+       // if (vi.IsYV12() &amp;&amp; chroma == true)
+        if ( chroma == true)
+        {
+                int z;
+
+                for (z = 0; z &lt; 2; z++)
+                {
+                        // Do the same for the U plane.
+                        if (z == 0)
+                        {
+                                currbot0  = fcrpU + pitchover2;
+                                currbot2  = fcrpU + 3 * pitchover2;
+                                currtop0 = fcrpU;
+                                currtop2 = fcrpU + 2 * pitchover2;
+                                currtop4 = fcrpU + 4 * pitchover2;
+                                prevbot0  = fprpU + pitchover2;
+                                prevbot2  = fprpU + 3 * pitchover2;
+                                prevtop0 = fprpU;
+                                prevtop2 = fprpU + 2 * pitchover2;
+                                prevtop4 = fprpU + 4 * pitchover2;
+                        }
+                        else
+                        {
+                                currbot0  = fcrpV + pitchover2;
+                                currbot2  = fcrpV + 3 * pitchover2;
+                                currtop0 = fcrpV;
+                                currtop2 = fcrpV + 2 * pitchover2;
+                                currtop4 = fcrpV + 4 * pitchover2;
+                                prevbot0  = fprpV + pitchover2;
+                                prevbot2  = fprpV + 3 * pitchover2;
+                                prevtop0 = fprpV;
+                                prevtop2 = fprpV + 2 * pitchover2;
+                                prevtop4 = fprpV + 4 * pitchover2;
+                        }
+                        if (tff == true)
+                        {
+                                a0 = prevbot0;
+                                a2 = prevbot2;
+                                b0 = currtop0;
+                                b2 = currtop2;
+                                b4 = currtop4;
+                        }
+                        else
+                        {
+                                a0 = currbot0;
+                                a2 = currbot2;
+                                b0 = prevtop0;
+                                b2 = prevtop2;
+                                b4 = prevtop4;
+                        }
+
+                        for (y = 0, index = 0; y &lt; hover2 - 4; y+=4)
+                        {
+                                /* Exclusion band. Good for ignoring subtitles. */
+                                if (y0 == y1 || y &lt; y0/2 || y &gt; y1/2)
+                                {
+                                        for (x = 0; x &lt; wover2;)
+                                        {
+                                                if (1) //vi.IsYV12())
+                                                        index = (y/BLKSIZE)*xblocks + x/BLKSIZE;
+                                                else
+                                                        index = (y/BLKSIZE)*xblocks + x/BLKSIZE_TIMES2;
+
+                                                // Test combination with current frame.
+                                                tmp1 = ((long)currbot0[x] + (long)currbot2[x]);
+                                                diff = abs((((long)currtop0[x] + (long)currtop2[x] + (long)currtop4[x])) - (tmp1 &gt;&gt; 1) - tmp1);
+                                                if (diff &gt; nt)
+                                                {
+                                                        c += diff;
+#ifdef WINDOWED_MATCH
+                                                        matchc[index] += diff;
+#endif
+                                                }
+
+                                                tmp1 = currbot0[x] + T;
+                                                tmp2 = currbot0[x] - T;
+                                                vc = (tmp1 &lt; currtop0[x] &amp;&amp; tmp1 &lt; currtop2[x]) ||
+                                                         (tmp2 &gt; currtop0[x] &amp;&amp; tmp2 &gt; currtop2[x]);
+                                                if (vc)
+                                                {
+                                                        sumc[index]++;
+                                                }
+
+                                                // Test combination with previous frame.
+                                                tmp1 = ((long)a0[x] + (long)a2[x]);
+                                                diff = abs((((long)b0[x] + (long)b2[x] + (long)b4[x])) - (tmp1 &gt;&gt; 1) - tmp1);
+                                                if (diff &gt; nt)
+                                                {
+                                                        p += diff;
+#ifdef WINDOWED_MATCH
+                                                        matchp[index] += diff;
+#endif
+                                                }
+
+                                                tmp1 = a0[x] + T;
+                                                tmp2 = a0[x] - T;
+                                                vc = (tmp1 &lt; b0[x] &amp;&amp; tmp1 &lt; b2[x]) ||
+                                                         (tmp2 &gt; b0[x] &amp;&amp; tmp2 &gt; b2[x]);
+                                                if (vc)
+                                                {
+                                                        sump[index]++;
+                                                }
+
+                                                x ++;
+                                                if (!(x&amp;3)) x += 4;
+                                        }
+                                }
+                                currbot0 += 4*pitchover2;
+                                currbot2 += 4*pitchover2;
+                                currtop0 += 4*pitchover2;
+                                currtop2 += 4*pitchover2;
+                                currtop4 += 4*pitchover2;
+                                a0               += 4*pitchover2;
+                                a2               += 4*pitchover2;
+                                b0               += 4*pitchover2;
+                                b2               += 4*pitchover2;
+                                b4               += 4*pitchover2;
+                        }
+                }
+        }
+
+        // Now find the blocks that have the greatest differences.
+#ifdef WINDOWED_MATCH
+        highest_matchp = 0;
+        for (y = 0; y &lt; yblocks; y++)
+        {
+                for (x = 0; x &lt; xblocks; x++)
+                {
+if (frame == 45 &amp;&amp; matchp[y * xblocks + x] &gt; 2500)
+{
+        sprintf(buf, &quot;%d/%d = %d\n&quot;, x, y, matchp[y * xblocks + x]);
+        OutputDebugString(buf);
+}
+                        if (matchp[y * xblocks + x] &gt; highest_matchp)
+                        {
+                                highest_matchp = matchp[y * xblocks + x];
+                        }
+                }
+        }
+        highest_matchc = 0;
+        for (y = 0; y &lt; yblocks; y++)
+        {
+                for (x = 0; x &lt; xblocks; x++)
+                {
+if (frame == 44 &amp;&amp; matchc[y * xblocks + x] &gt; 2500)
+{
+        sprintf(buf, &quot;%d/%d = %d\n&quot;, x, y, matchc[y * xblocks + x]);
+        OutputDebugString(buf);
+}
+                        if (matchc[y * xblocks + x] &gt; highest_matchc)
+                        {
+                                highest_matchc = matchc[y * xblocks + x];
+                        }
+                }
+        }
+#endif
+        if (post != POST_NONE)
+        {
+                highest_sump = 0;
+                for (y = 0; y &lt; yblocks; y++)
+                {
+                        for (x = 0; x &lt; xblocks; x++)
+                        {
+                                if (sump[y * xblocks + x] &gt; highest_sump)
+                                {
+                                        highest_sump = sump[y * xblocks + x];
+                                }
+                        }
+                }
+                highest_sumc = 0;
+                for (y = 0; y &lt; yblocks; y++)
+                {
+                        for (x = 0; x &lt; xblocks; x++)
+                        {
+                                if (sumc[y * xblocks + x] &gt; highest_sumc)
+                                {
+                                        highest_sumc = sumc[y * xblocks + x];
+                                }
+                        }
+                }
+        }
+#ifdef WINDOWED_MATCH
+        CacheInsert(frame, highest_matchp, highest_sump, highest_matchc, highest_sumc);
+#else
+        CacheInsert(frame, p, highest_sump, c, highest_sumc);
+#endif
+}
+bool Telecide::PredictHardYUY2(int frame, unsigned int *predicted, unsigned int *predicted_metric)
+        {
+                // Look for pattern in the actual delivered matches of the previous cycle of frames.
+                // If a pattern is found, use that to predict the current match.
+                if (guide == GUIDE_22)
+                {
+                        if (cache[(frame-cycle)%CACHE_SIZE  ].chosen == 0xff ||
+                                cache[(frame-cycle+1)%CACHE_SIZE].chosen == 0xff)
+                                return false;
+                        switch ((cache[(frame-cycle)%CACHE_SIZE  ].chosen &lt;&lt; 4) +
+                                        (cache[(frame-cycle+1)%CACHE_SIZE].chosen))
+                        {
+                        case 0x11:
+                                *predicted = C;
+                                *predicted_metric = cache[frame%CACHE_SIZE].metrics[C];
+                                break;
+                        case 0x22:
+                                *predicted = N;
+                                *predicted_metric = cache[frame%CACHE_SIZE].metrics[N];
+                                break;
+                        default: return false;
+                        }
+                }
+                else if (guide == GUIDE_32)
+                {
+                        if (cache[(frame-cycle)%CACHE_SIZE  ].chosen == 0xff ||
+                                cache[(frame-cycle+1)%CACHE_SIZE].chosen == 0xff ||
+                                cache[(frame-cycle+2)%CACHE_SIZE].chosen == 0xff ||
+                                cache[(frame-cycle+3)%CACHE_SIZE].chosen == 0xff ||
+                                cache[(frame-cycle+4)%CACHE_SIZE].chosen == 0xff)
+                                return false;
+
+                        switch ((cache[(frame-cycle)%CACHE_SIZE  ].chosen &lt;&lt; 16) +
+                                        (cache[(frame-cycle+1)%CACHE_SIZE].chosen &lt;&lt; 12) +
+                                        (cache[(frame-cycle+2)%CACHE_SIZE].chosen &lt;&lt;  8) +
+                                        (cache[(frame-cycle+3)%CACHE_SIZE].chosen &lt;&lt;  4) +
+                                        (cache[(frame-cycle+4)%CACHE_SIZE].chosen))
+                        {
+                        case 0x11122:
+                        case 0x11221:
+                        case 0x12211:
+                        case 0x12221: 
+                        case 0x21122: 
+                        case 0x11222: 
+                                *predicted = C;
+                                *predicted_metric = cache[frame%CACHE_SIZE].metrics[C];
+                                break;
+                        case 0x22111:
+                        case 0x21112:
+                        case 0x22112: 
+                        case 0x22211: 
+                                *predicted = N;
+                                *predicted_metric = cache[frame%CACHE_SIZE].metrics[N];
+                                break;
+                        default: return false;
+                        }
+                }
+                else if (guide == GUIDE_32322)
+                {
+                        if (cache[(frame-cycle)%CACHE_SIZE  ].chosen == 0xff ||
+                                cache[(frame-cycle+1)%CACHE_SIZE].chosen == 0xff ||
+                                cache[(frame-cycle+2)%CACHE_SIZE].chosen == 0xff ||
+                                cache[(frame-cycle+3)%CACHE_SIZE].chosen == 0xff ||
+                                cache[(frame-cycle+4)%CACHE_SIZE].chosen == 0xff ||
+                                cache[(frame-cycle+5)%CACHE_SIZE].chosen == 0xff)
+                                return false;
+
+                        switch ((cache[(frame-cycle)%CACHE_SIZE  ].chosen &lt;&lt; 20) +
+                                        (cache[(frame-cycle+1)%CACHE_SIZE].chosen &lt;&lt; 16) +
+                                        (cache[(frame-cycle+2)%CACHE_SIZE].chosen &lt;&lt; 12) +
+                                        (cache[(frame-cycle+3)%CACHE_SIZE].chosen &lt;&lt;  8) +
+                                        (cache[(frame-cycle+4)%CACHE_SIZE].chosen &lt;&lt;  4) +
+                                        (cache[(frame-cycle+5)%CACHE_SIZE].chosen))
+                        {
+                        case 0x111122:
+                        case 0x111221:
+                        case 0x112211:
+                        case 0x122111:
+                        case 0x111222: 
+                        case 0x112221:
+                        case 0x122211:
+                        case 0x222111: 
+                                *predicted = C;
+                                *predicted_metric = cache[frame%CACHE_SIZE].metrics[C];
+                                break;
+                        case 0x221111:
+                        case 0x211112:
+
+                        case 0x221112: 
+                        case 0x211122: 
+                                *predicted = N;
+                                *predicted_metric = cache[frame%CACHE_SIZE].metrics[N];
+                                break;
+                        default: return false;
+                        }
+                }
+#ifdef DEBUG_PATTERN_GUIDANCE
+                sprintf(buf, &quot;%d: HARD: predicted = %d\n&quot;, frame, *predicted);
+                OutputDebugString(buf);
+#endif
+                return true;
+        }
+
+struct PREDICTION *Telecide::PredictSoftYUY2(int frame)
+        {
+                // Use heuristics to look forward for a match.
+                int i, j, y, c, n, phase;
+                unsigned int metric;
+
+                pred[0].metric = 0xffffffff;
+                if (frame &lt; 0 || frame &gt; _info.nb_frames - 1 - cycle) return pred;
+
+                // Look at the next cycle of frames.
+                for (y = frame + 1; y &lt;= frame + cycle; y++)
+                {
+                        // Look for a frame where the current and next match values are
+                        // very close. Those are candidates to predict the phase, because
+                        // that condition should occur only once per cycle. Store the candidate
+                        // phases and predictions in a list sorted by goodness. The list will
+                        // be used by the caller to try the phases in order.
+                        c = cache[y%CACHE_SIZE].metrics[C]; 
+                        n = cache[y%CACHE_SIZE].metrics[N];
+                        if (c == 0) c = 1;
+                        metric = (100 * abs (c - n)) / c;
+                        phase = y % cycle;
+                        if (metric &lt; 5)
+                        {
+                                // Place the new candidate phase in sorted order in the list.
+                                // Find the insertion point.
+                                i = 0;
+                                while (metric &gt; pred[i].metric) i++;
+                                // Find the end-of-list marker.
+                                j = 0;
+                                while (pred[j].metric != 0xffffffff) j++;
+                                // Shift all items below the insertion point down by one to make
+                                // room for the insertion.
+                                j++;
+                                for (; j &gt; i; j--)
+                                {
+                                        pred[j].metric = pred[j-1].metric;
+                                        pred[j].phase = pred[j-1].phase;
+                                        pred[j].predicted = pred[j-1].predicted;
+                                        pred[j].predicted_metric = pred[j-1].predicted_metric;
+                                }
+                                // Insert the new candidate data.
+                                pred[j].metric = metric;
+                                pred[j].phase = phase;
+                                if (guide == GUIDE_32)
+                                {
+                                        switch ((frame % cycle) - phase)
+                                        {
+                                        case -4: pred[j].predicted = N; pred[j].predicted_metric = cache[frame%CACHE_SIZE].metrics[N]; break; 
+                                        case -3: pred[j].predicted = N; pred[j].predicted_metric = cache[frame%CACHE_SIZE].metrics[N]; break; 
+                                        case -2: pred[j].predicted = C; pred[j].predicted_metric = cache[frame%CACHE_SIZE].metrics[C]; break; 
+                                        case -1: pred[j].predicted = C; pred[j].predicted_metric = cache[frame%CACHE_SIZE].metrics[C]; break; 
+                                        case  0: pred[j].predicted = C; pred[j].predicted_metric = cache[frame%CACHE_SIZE].metrics[C]; break; 
+                                        case +1: pred[j].predicted = N; pred[j].predicted_metric = cache[frame%CACHE_SIZE].metrics[N]; break; 
+                                        case +2: pred[j].predicted = N; pred[j].predicted_metric = cache[frame%CACHE_SIZE].metrics[N]; break; 
+                                        case +3: pred[j].predicted = C; pred[j].predicted_metric = cache[frame%CACHE_SIZE].metrics[C]; break; 
+                                        case +4: pred[j].predicted = C; pred[j].predicted_metric = cache[frame%CACHE_SIZE].metrics[C]; break; 
+                                        }
+                                }
+                                else if (guide == GUIDE_32322)
+                                {
+                                        switch ((frame % cycle) - phase)
+                                        {
+                                        case -5: pred[j].predicted = N; pred[j].predicted_metric = cache[frame%CACHE_SIZE].metrics[N]; break; 
+                                        case -4: pred[j].predicted = N; pred[j].predicted_metric = cache[frame%CACHE_SIZE].metrics[N]; break; 
+                                        case -3: pred[j].predicted = C; pred[j].predicted_metric = cache[frame%CACHE_SIZE].metrics[C]; break; 
+                                        case -2: pred[j].predicted = C; pred[j].predicted_metric = cache[frame%CACHE_SIZE].metrics[C]; break; 
+                                        case -1: pred[j].predicted = C; pred[j].predicted_metric = cache[frame%CACHE_SIZE].metrics[C]; break; 
+                                        case  0: pred[j].predicted = C; pred[j].predicted_metric = cache[frame%CACHE_SIZE].metrics[C]; break; 
+                                        case +1: pred[j].predicted = N; pred[j].predicted_metric = cache[frame%CACHE_SIZE].metrics[N]; break; 
+                                        case +2: pred[j].predicted = N; pred[j].predicted_metric = cache[frame%CACHE_SIZE].metrics[N]; break; 
+                                        case +3: pred[j].predicted = C; pred[j].predicted_metric = cache[frame%CACHE_SIZE].metrics[C]; break; 
+                                        case +4: pred[j].predicted = C; pred[j].predicted_metric = cache[frame%CACHE_SIZE].metrics[C]; break; 
+                                        case +5: pred[j].predicted = C; pred[j].predicted_metric = cache[frame%CACHE_SIZE].metrics[C]; break; 
+                                        }
+                                }
+                        }
+#ifdef DEBUG_PATTERN_GUIDANCE
+                        sprintf(buf,&quot;%d: metric = %d phase = %d\n&quot;, frame, metric, phase);
+                        OutputDebugString(buf);
+#endif
+                }
+                return pred;
+        }
+

Copied: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidDecTelecide.h (from rev 2489, branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidDecTelecide.h)
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidDecTelecide.h	2006-10-31 15:59:58 UTC (rev 2489)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidDecTelecide.h	2007-01-13 16:37:32 UTC (rev 2721)
@@ -0,0 +1,143 @@
+/*
+	Telecide plugin for Avisynth -- recovers original progressive
+	frames from  telecined streams. The filter operates by matching
+	fields and automatically adapts to phase/pattern changes.
+
+	Copyright (C) 2003 Donald A. Graft
+
+	This program is free software; you can redistribute it and/or modify
+	it under the terms of the GNU General Public License as published by
+	the Free Software Foundation.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program; if not, write to the Free Software
+	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*/
+#include &quot;ADM_video/ADM_cache.h&quot;
+#undef DEBUG_PATTERN_GUIDANCE
+
+#undef WINDOWED_MATCH
+
+#define MAX_CYCLE 6
+#define BLKSIZE 24
+#define BLKSIZE_TIMES2 (2 * BLKSIZE)
+#define GUIDE_NONE 0
+#define GUIDE_32 1
+#define GUIDE_22 2
+#define GUIDE_32322 3
+#define AHEAD 0
+#define BEHIND 1
+#define POST_NONE 0
+#define POST_METRICS 1
+#define POST_FULL 2
+#define POST_FULL_MAP 3
+#define POST_FULL_NOMATCH 4
+#define POST_FULL_NOMATCH_MAP 5
+#define CACHE_SIZE 100000
+#define P 0
+#define C 1
+#define N 2
+#define PBLOCK 3
+#define CBLOCK 4
+
+#define NO_BACK 0
+#define BACK_ON_COMBED 1
+#define ALWAYS_BACK 2
+
+#define OutputDebugString(x) aprintf(&quot;%s\n&quot;,x)
+typedef uint8_t* PVideoFrame ;
+
+
+struct CACHE_ENTRY
+{
+	unsigned int frame;
+	unsigned int metrics[5];
+	unsigned int chosen;
+};
+
+struct PREDICTION
+{
+	unsigned int metric;
+	unsigned int phase;
+	unsigned int predicted;
+	unsigned int predicted_metric;
+};
+
+#define GETFRAME(g, fp) { int GETFRAMEf; uint32_t len,flags;GETFRAMEf = (g); fp=NULL;if (GETFRAMEf &lt; 0) GETFRAMEf = 0; 	else if (GETFRAMEf &gt;= _info.nb_frames) GETFRAMEf = _info.nb_frames - 1; fp=vidCache-&gt;getImage(GETFRAMEf); }
+#include &quot;ADM_vidDecTel_param.h&quot;
+class Telecide : public AVDMGenericVideoStream
+{
+private:
+	TelecideParam *_param;		
+	bool tff;	
+	uint32_t _lastFrame;	
+	int pitch, dpitch, pitchover2, pitchtimes4;
+	int w, h, wover2, hover2, hplus1over2, hminus2;
+	int xblocks, yblocks;
+#ifdef WINDOWED_MATCH
+	unsigned int *matchc, *matchp, highest_matchc, highest_matchp;
+#endif
+	unsigned int *sumc, *sump, highest_sumc, highest_sump;
+	int vmetric;
+	
+	bool film, override, inpattern, found;
+	int force;
+
+	
+	int chosen;
+	unsigned int p, c, pblock, cblock, lowest, predicted, predicted_metric;
+	unsigned int np, nc, npblock, ncblock;
+	float mismatch;
+	int  x, y;
+	
+	bool hard;
+	char status[80];
+
+	// Metrics cache.
+	struct CACHE_ENTRY *cache;
+
+	// Pattern guidance data.
+	int cycle;
+	struct PREDICTION pred[MAX_CYCLE+1];
+
+	// For output message formatting.
+	char buf[255];
+	
+	VideoCache	*vidCache;
+
+public:
+	
+	void CalculateMetrics(int n, unsigned char *crp, unsigned char *crpU, unsigned char *crpV, 
+				unsigned char *prp, unsigned char *prpU, unsigned char *prpV);
+	void Show(ADMImage *dst, int frame);
+	void Debug(int frame);
+
+	       Telecide(AVDMGenericVideoStream *in,CONFcouple *couples);		
+			
+	       ~Telecide();
+
+	void PutChosen(int frame, unsigned int chosen);
+	
+
+	void CacheInsert(int frame, unsigned int p, unsigned int pblock,
+				unsigned int c, unsigned int cblock);
+	
+	bool CacheQuery(int frame, unsigned int *p, unsigned int *pblock,
+				unsigned int *c, unsigned int *cblock);	
+
+	bool PredictHardYUY2(int frame, unsigned int *predicted, unsigned int *predicted_metric) ;
+	
+	struct PREDICTION *PredictSoftYUY2(int frame);
+
+	void WriteHints(unsigned char *dst, bool film, bool inpattern);
+	virtual uint8_t getFrameNumberNoAlloc(uint32_t frame, uint32_t *len,
+				ADMImage *data,uint32_t *flags);
+	char *printConf( void );
+	uint8_t configure(AVDMGenericVideoStream *in);
+	uint8_t	getCoupledConf( CONFcouple **couples);
+};

Copied: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidDeintASM.cpp (from rev 2489, branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidDeintASM.cpp)
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_video/ADM_vidDeintASM.cpp	2006-10-31 15:59:58 UTC (rev 2489)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidDeintASM.cpp	2007-01-13 16:37:32 UTC (rev 2721)
@@ -0,0 +1,238 @@
+/***************************************************************************
+                          ADM_vidDeintASM.cpp  -  description
+                             -------------------
+    begin                : Tue Jan 7 2003
+    copyright            : (C) 2003 by mean
+    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
+
+    Slighlty faster ASM deinterlace
+    Blend later	
+
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include &lt;stdio.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;string.h&gt;
+#include &lt;ADM_assert.h&gt;
+
+#include &quot;config.h&quot;
+#include &quot;fourcc.h&quot;
+#include &quot;avio.hxx&quot;
+#include &quot;config.h&quot;
+#include &quot;avi_vars.h&quot;
+
+
+
+#include &quot;ADM_toolkit/toolkit.hxx&quot;
+#include &quot;ADM_editor/ADM_edit.hxx&quot;
+#include &quot;ADM_video/ADM_genvideo.hxx&quot;
+
+#include&quot;ADM_vidField.h&quot;
+
+#if defined( ARCH_X86)  || defined(ARCH_X86_64)
+//	#define DEBUG_DEINT 1
+//	#define MMX_TRACE 1
+	#include &quot;mmx_macros.h&quot;
+#include &quot;admmangle.h&quot;
+
+ void myDeintASM(void);
+
+ static int32_t _l_w,_l_h,_l_all;
+ static uint8_t *_l_p,*_l_c,*_l_n;
+ static uint8_t *_l_e,*_l_e2;
+#define EXPAND(x) (x)+((x)&lt;&lt;16)+((x)&lt;&lt;32) +((x)&lt;&lt;48)
+static mmx_t _mmTHRESH1;
+static mmx_t _mmTHRESH2;
+
+#define COMPUTE_MMX \
+punpcklbw_r2r(mm5,mm0);  /*c  expand 4 bytes -&gt; 4 word */ \
+punpcklbw_r2r(mm5,mm1);  /*p*/ \
+punpcklbw_r2r(mm5,mm2); /* n*/ \
+movq_r2r(mm0,mm3);		/* mm3 also c*/ \
+psubw_r2r(mm1,mm0) ; /* mm0=mm0-mm1 =  c-p*/ \
+psubw_r2r(mm2,mm3) ; /* mm3=mm3-mm2 =  c-n*/ \
+psraw_i2r(1,mm0); /* to protect from overflow*/ \
+psraw_i2r(1,mm3);\
+pmullw_r2r(mm0,mm3); /* mm3=(c-p)*(c-n) / 4;*/ \
+movq_r2r(mm3,mm0) ; /* mm0 also c-p*c-n */ \
+pcmpgtw_r2r(mm4,mm3); /* keep only &gt; size*/ \
+pcmpgtw_r2r(mm6,mm0); /* keep only &gt; size*/ \
+packsswb_r2r(mm5,mm0); \
+packsswb_r2r(mm5,mm3);
+
+#endif
+
+void ADMVideoFields::hasMotion_C(uint8_t *p,uint8_t *c,
+								uint8_t *n,
+								uint8_t *e,
+								uint8_t *e2
+								)
+{
+int32_t val,x,y;
+//printf(&quot;\nC \n&quot;);
+// other line
+       	for(y=_info.height-2;y&gt;0;y--)
+        	{
+               for(x=_info.width;x&gt;0;x--)
+               		{
+                   		val= (*p-*c)*(*n-*c);
+                        if(val&gt;(int32_t)(_param-&gt;motion_trigger*_param-&gt;motion_trigger))
+                        	{
+                          	*e=0xff;
+                         }
+                         if(val&gt;(int32_t)(_param-&gt;blend_trigger*_param-&gt;blend_trigger))
+                         	*e2=0xff;
+                         p++;c++;n++;e++;e2++;
+                      }
+           }
+}
+#if defined( ARCH_X86)  || defined(ARCH_X86_64)
+void ADMVideoFields::hasMotion_MMX(uint8_t *p,uint8_t *c,
+									uint8_t *n,
+									uint8_t *e,
+									uint8_t *e2
+									)
+{
+
+
+			 	_mmTHRESH1.uq=EXPAND((uint64_t ) ((_param-&gt;motion_trigger*_param-&gt;motion_trigger)&gt;&gt;2) );
+				_mmTHRESH2.uq=EXPAND((uint64_t ) ((_param-&gt;blend_trigger*_param-&gt;blend_trigger)&gt;&gt;2) );
+
+			_l_h=_info.height-2;
+			_l_w=_info.width&gt;&gt;2;
+			_l_all=_l_h*_l_w;
+			_l_p=p;
+			_l_c=c;
+			_l_n=n;
+			_l_e=e;
+			_l_e2=e2;
+//			printf(&quot;\n MMX \n&quot;);
+
+			pxor_r2r(mm5,mm5);
+			movq_m2r(_mmTHRESH1,mm4);
+			movq_m2r(_mmTHRESH2,mm6);
+			myDeintASM();
+}
+#if !defined(DEBUG_DEINT)
+void myDeintASM(void)
+{
+
+	//printf(&quot;\n using  MMX \n&quot;);
+
+
+        	{
+
+			__asm__ __volatile__ (
+				&quot;mov &quot;Mangle(_l_c)&quot;,	&quot;REG_ax&quot;\n\t&quot;
+				&quot;mov &quot;Mangle(_l_p)&quot;,	&quot;REG_bx&quot;\n\t&quot;
+				&quot;mov &quot;Mangle(_l_n)&quot;,	&quot;REG_cx&quot;\n\t&quot;
+				&quot;mov &quot;Mangle(_l_all)&quot;,	&quot;REG_si&quot;\n\t&quot;
+				&quot;7:&quot;
+				&quot;movd (&quot;REG_ax&quot;),	%%mm0\n\t&quot;
+				&quot;movd (&quot;REG_bx&quot;),	%%mm1\n\t&quot;
+				&quot;movd (&quot;REG_cx&quot;),	%%mm2\n\t&quot;
+				:
+				:
+				: &quot;eax&quot;,&quot;ebx&quot;,&quot;ecx&quot;,&quot;edx&quot;,&quot;esi&quot; 
+				);
+
+				COMPUTE_MMX;
+
+				/* store result in e, e2 */
+
+			__asm__ __volatile__(
+				&quot;mov 	&quot;Mangle(_l_e)&quot;,	&quot;REG_dx&quot;\n\t&quot;
+				&quot;movd	%%mm3,(&quot;REG_dx&quot;)\n\t&quot;
+
+				&quot;mov 	&quot;Mangle(_l_e2)&quot;,	&quot;REG_dx&quot;\n\t&quot;
+				&quot;movd	%%mm0,(&quot;REG_dx&quot;)\n\t&quot;
+
+				&quot;add 	$4,	&quot;REG_ax&quot;\n\t&quot;
+				&quot;add 	$4,	&quot;REG_bx&quot;\n\t&quot;
+				&quot;add 	$4,	&quot;REG_cx&quot;\n\t&quot;
+				&quot;add 	$4,	&quot;Mangle(_l_e)&quot;\n\t&quot;
+				&quot;add 	$4,	&quot;Mangle(_l_e2)&quot;\n\t&quot;
+				&quot;sub 	$1,	&quot;REG_si&quot;\n\t&quot;
+				&quot;jnz 7b\n\t&quot;
+
+				:
+				:
+				: &quot;eax&quot;, &quot;ebx&quot;,&quot;ecx&quot;,&quot;edx&quot;,&quot;esi&quot;
+				);
+	           	}
+	   emms();
+
+}
+#else
+/*************************************************
+***************DEBUG*************************
+**************************************************
+**************************************************/
+
+
+void myDeintASM(void)
+{
+
+int32_t x,y;
+	printf(&quot;\n using  MMX debug\n&quot;);
+
+       	for(y=_l_h;y&gt;0;y--)
+        	{
+		for(x=_l_w;x&gt;0;x--)
+               		{
+
+			__asm__ __volatile__ (
+				&quot;mov _l_c,	&quot;REG_ax&quot;\n\t&quot;
+				&quot;mov _l_p,	&quot;REG_bx&quot;\n\t&quot;
+				&quot;mov _l_n,	&quot;REG_cx&quot;\n\t&quot;
+				&quot;mov _l_w,	&quot;REG_si&quot;\n\t&quot;
+				&quot;movd (&quot;REG_ax&quot;),	%%mm0\n\t&quot;
+				&quot;movd (&quot;REG_bx&quot;),	%%mm1\n\t&quot;
+				&quot;movd (&quot;REG_cx&quot;),	%%mm2\n\t&quot;
+				:
+				:
+				: &quot;eax&quot;, &quot;ebx&quot;, &quot;ecx&quot;, &quot;edx&quot;,&quot;esi&quot;
+				);
+			emms();
+				COMPUTE_MMX;
+			emms();
+				/* store result in e, e2 */
+
+			__asm__ __volatile__(
+				&quot;mov 	_l_e,	&quot;REG_dx&quot;\n\t&quot;
+				&quot;movd	%%mm3,(&quot;REG_dx&quot;)\n\t&quot;
+				//&quot;movd	%%mm3,(%%eax)\n\t&quot;
+
+				&quot;mov 	_l_e2,	&quot;REG_dx&quot;\n\t&quot;
+				&quot;movd	%%mm0,(&quot;REG_dx&quot;)\n\t&quot;
+
+				:
+				:
+				: &quot;eax&quot;,&quot;edx&quot;,&quot;esi&quot;
+				);
+
+			emms();
+
+
+			 _l_e+=4;
+			 _l_e2+=4;
+			 _l_c+=4;
+			 _l_p+=4;
+			 _l_n+=4;
+
+           } // end for x
+	  }
+	   emms();
+}
+
+
+#endif
+#endif

Modified: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidFade.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidFade.cpp	2007-01-13 12:08:21 UTC (rev 2720)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidFade.cpp	2007-01-13 16:37:32 UTC (rev 2721)
@@ -22,7 +22,6 @@
 #include &quot;ADM_toolkit/toolkit.hxx&quot;
 #include &quot;ADM_editor/ADM_edit.hxx&quot;
 #include &quot;ADM_video/ADM_genvideo.hxx&quot;
-#include&quot;ADM_video/ADM_vidField.h&quot;
 #include&quot;ADM_video/ADM_cache.h&quot;
 
 #include &quot;ADM_osSupport/ADM_debugID.h&quot;

Modified: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidFastConvolution.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidFastConvolution.cpp	2007-01-13 12:08:21 UTC (rev 2720)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidFastConvolution.cpp	2007-01-13 16:37:32 UTC (rev 2721)
@@ -460,7 +460,6 @@
 	*out++=b3;
 	return 1;
 }
-uint8_t  DIA_getLumaChroma(uint32_t *doLuma, uint32_t *doChroma);
 uint8_t AVDMFastVideoConvolution::configure(AVDMGenericVideoStream * instream)
 {
   

Modified: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidForcedPP.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidForcedPP.cpp	2007-01-13 12:08:21 UTC (rev 2720)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidForcedPP.cpp	2007-01-13 16:37:32 UTC (rev 2721)
@@ -49,7 +49,6 @@
 SCRIPT_CREATE(forcedpp_script,ADMVideoForcedPP,ppParam);
 BUILD_CREATE(forcedpp_create,ADMVideoForcedPP);
 
-extern int DIA_getMPParams( uint32_t *pplevel, uint32_t *ppstrength,uint32_t *swap);
 
 uint8_t ADMVideoForcedPP::configure( AVDMGenericVideoStream *instream)
 {

Modified: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidMPLD3D.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidMPLD3D.cpp	2007-01-13 12:08:21 UTC (rev 2720)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidMPLD3D.cpp	2007-01-13 16:37:32 UTC (rev 2721)
@@ -49,7 +49,7 @@
 #define PARAM1_DEFAULT 4.0
 #define PARAM2_DEFAULT 3.0
 #define PARAM3_DEFAULT 6.0
-uint8_t DIA_d3d(double *luma,double *chroma,double *temporal);
+
  char 	*ADMVideoMPD3D::printConf(void)
  {
 	  	static char buf[50];

Modified: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidMSharpen.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidMSharpen.cpp	2007-01-13 12:08:21 UTC (rev 2720)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidMSharpen.cpp	2007-01-13 16:37:32 UTC (rev 2721)
@@ -47,7 +47,6 @@
 #include &quot;ADM_toolkit/toolkit.hxx&quot;
 #include &quot;ADM_editor/ADM_edit.hxx&quot;
 #include &quot;ADM_video/ADM_genvideo.hxx&quot;
-#include&quot;ADM_video/ADM_vidField.h&quot;
 #include&quot;ADM_video/ADM_cache.h&quot;
 
 #include &quot;ADM_osSupport/ADM_debugID.h&quot;
@@ -151,7 +150,6 @@
 	blurrImg=NULL;
         work=NULL;
 }
-extern uint8_t DIA_getMSharpen(MSHARPEN_PARAM *param);
 //________________________________________________________
 uint8_t Msharpen::configure(AVDMGenericVideoStream *in)
 {

Modified: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidMcDeint.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidMcDeint.cpp	2007-01-13 12:08:21 UTC (rev 2720)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidMcDeint.cpp	2007-01-13 16:37:32 UTC (rev 2721)
@@ -89,7 +89,6 @@
 BUILD_CREATE(mcdeint_create,AVDMVideoMCDeint);
 
 static void filter(struct vf_priv_s *p, uint8_t *dst[3], uint8_t *src[3], int dst_stride[3], int src_stride[3], int width, int height);
-uint8_t DIA_mcDeint(MCDEINT_PARAM *param);
 
 
 char *AVDMVideoMCDeint::printConf( void )

Modified: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidMosaic.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidMosaic.cpp	2007-01-13 12:08:21 UTC (rev 2720)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidMosaic.cpp	2007-01-13 16:37:32 UTC (rev 2721)
@@ -46,11 +46,9 @@
 #include &quot;ADM_filter/video_filters.h&quot;
 
 #include &quot;ADM_video/ADM_cache.h&quot;
-#include &quot;DIA_enter.h&quot;
 
 #include &quot;ADM_vidMosaic_param.h&quot;
 
-extern uint8_t  DIA_mosaic(MOSAIC_PARAMS *mosaic);
 
 class  ADMVideoMosaic:public AVDMGenericVideoStream
  {

Modified: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidMsmooth.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidMsmooth.cpp	2007-01-13 12:08:21 UTC (rev 2720)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidMsmooth.cpp	2007-01-13 16:37:32 UTC (rev 2721)
@@ -42,7 +42,6 @@
 #include &quot;ADM_toolkit/toolkit.hxx&quot;
 #include &quot;ADM_editor/ADM_edit.hxx&quot;
 #include &quot;ADM_video/ADM_genvideo.hxx&quot;
-#include&quot;ADM_video/ADM_vidField.h&quot;
 #include&quot;ADM_video/ADM_cache.h&quot;
 
 #include &quot;ADM_osSupport/ADM_debugID.h&quot;
@@ -72,7 +71,7 @@
 
 #include &quot;ADM_video/ADM_vidMSmooth_param.h&quot;
 
-extern uint8_t DIA_getMSmooth(MSMOOTH_PARAM *param);
+
 extern uint8_t 	PutHintingData(unsigned char *video, unsigned int hint);
 extern uint8_t 	GetHintingData(unsigned char *video, unsigned int *hint);
 extern void 	BitBlt(uint8_t * dstp, int dst_pitch, const uint8_t* srcp,

Modified: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidPalSmart.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidPalSmart.cpp	2007-01-13 12:08:21 UTC (rev 2720)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidPalSmart.cpp	2007-01-13 16:37:32 UTC (rev 2721)
@@ -31,7 +31,7 @@
 #include &quot;ADM_editor/ADM_edit.hxx&quot;
 #include &quot;ADM_video/ADM_genvideo.hxx&quot;
 
-#include&quot;ADM_video/ADM_vidDeinterlace.h&quot;
+#include&quot;ADM_vidDeinterlace.h&quot;
 #include&quot;ADM_vidPalSmart.h&quot;
 #include &quot;ADM_filter/video_filters.h&quot;
 

Modified: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidPalSmart.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidPalSmart.h	2007-01-13 12:08:21 UTC (rev 2720)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidPalSmart.h	2007-01-13 16:37:32 UTC (rev 2721)
@@ -14,7 +14,6 @@
  *   (at your option) any later version.                                   *
  *                                                                         *
  ***************************************************************************/
-#include &quot;ADM_video/ADM_vidField.h&quot;
 #include &quot;ADM_video/ADM_cache.h&quot;
 class  ADMVideoTelecide:public ADMVideoFields
  {

Modified: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidReverse.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidReverse.cpp	2007-01-13 12:08:21 UTC (rev 2720)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidReverse.cpp	2007-01-13 16:37:32 UTC (rev 2721)
@@ -21,7 +21,6 @@
 #include &quot;ADM_toolkit/toolkit.hxx&quot;
 #include &quot;ADM_editor/ADM_edit.hxx&quot;
 #include &quot;ADM_video/ADM_genvideo.hxx&quot;
-#include&quot;ADM_video/ADM_vidField.h&quot;
 #include&quot;ADM_video/ADM_cache.h&quot;
 
 #include &quot;ADM_osSupport/ADM_debugID.h&quot;

Modified: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/Makefile.am
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/Makefile.am	2007-01-13 12:08:21 UTC (rev 2720)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/Makefile.am	2007-01-13 16:37:32 UTC (rev 2721)
@@ -7,6 +7,12 @@
 #INCLUDES = $(all_includes) 
 
 libADM_videoFilter_a_SOURCES =  \
+ ADM_vidBlend.cpp \
+ ADM_vidDeintASM.cpp \
+ ADM_vidDecDec.cpp \
+ ADM_vidDecTelecide.cpp \
+ ADM_vidDeinterlace.cpp \
+ ADM_vidFields.cpp \
  ADM_vidPalShift.cpp \
  ADM_vidReverse.cpp \
  ADM_vidSeparateField.cpp \

Modified: branches/avidemux_2.4_branch/avidemux/libcheck.sh
===================================================================
--- branches/avidemux_2.4_branch/avidemux/libcheck.sh	2007-01-13 12:08:21 UTC (rev 2720)
+++ branches/avidemux_2.4_branch/avidemux/libcheck.sh	2007-01-13 16:37:32 UTC (rev 2721)
@@ -1,7 +1,17 @@
 #!/bin/bash
+echo  &quot;*************************&quot;
 echo &quot;Checking malloc...&quot;
-find . -name &quot;*.a&quot; | xargs nm -AC | grep &quot;malloc\|free&quot;| grep   &quot; U &quot; | grep -v &quot;.* U .*_.*&quot;
+echo  &quot;*************************&quot;
+find . -name &quot;*.a&quot; | xargs nm -AC | grep &quot;malloc\|free&quot;| grep   &quot; U &quot; | grep -v &quot;.* U .*_.*&quot; | grep -v &quot;::&quot;
+echo  &quot;*************************&quot;
 echo &quot;Checking fread/fwrite...&quot;
+echo  &quot;*************************&quot;
 find . -name &quot;*.a&quot; | xargs nm -AC | grep &quot;fread\|fwrite&quot;| grep   &quot; U &quot; | grep -v &quot;.* U .*_.*&quot;
+echo  &quot;*************************&quot;
+echo &quot;Checking fopen/close...&quot;
+echo  &quot;*************************&quot;
+find . -name &quot;*.a&quot; | xargs nm -AC | grep &quot;fopen\|fclose&quot;| grep   &quot; U &quot; | grep -v &quot;.* U .*_.*&quot; | grep -v qf
+echo  &quot;*************************&quot;
 echo &quot;Checking GTK...&quot;
+echo  &quot;*************************&quot;
 find . -name &quot;*.a&quot; | grep -vi gtk | xargs nm -AC | grep &quot;gtk_&quot;| grep   &quot; U &quot; 


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000048.html">[Avidemux-svn-commit] r2720 - in	branches/avidemux_2.4_branch/avidemux: . ADM_video ADM_videoFilter
</A></li>
	<LI>Next message: <A HREF="000050.html">[Avidemux-svn-commit] r2722 -	branches/avidemux_2.4_branch/avidemux/ADM_osSupport
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#49">[ date ]</a>
              <a href="thread.html#49">[ thread ]</a>
              <a href="subject.html#49">[ subject ]</a>
              <a href="author.html#49">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">More information about the Avidemux-svn-commit
mailing list</a><br>
</body></html>
