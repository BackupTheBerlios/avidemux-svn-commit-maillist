<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Avidemux-svn-commit] r3805 - in	branches/avidemux_2.5_branch_mean/avidemux: ADM_core	ADM_core/src ADM_osSupport
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/avidemux-svn-commit/2008-February/index.html" >
   <LINK REL="made" HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r3805%20-%20in%0A%09branches/avidemux_2.5_branch_mean/avidemux%3A%20ADM_core%0A%09ADM_core/src%20ADM_osSupport&In-Reply-To=%3C200802271950.m1RJogJb008747%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001070.html">
   <LINK REL="Next"  HREF="001072.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Avidemux-svn-commit] r3805 - in	branches/avidemux_2.5_branch_mean/avidemux: ADM_core	ADM_core/src ADM_osSupport</H1>
    <B>mean at BerliOS</B> 
    <A HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r3805%20-%20in%0A%09branches/avidemux_2.5_branch_mean/avidemux%3A%20ADM_core%0A%09ADM_core/src%20ADM_osSupport&In-Reply-To=%3C200802271950.m1RJogJb008747%40sheep.berlios.de%3E"
       TITLE="[Avidemux-svn-commit] r3805 - in	branches/avidemux_2.5_branch_mean/avidemux: ADM_core	ADM_core/src ADM_osSupport">mean at mail.berlios.de
       </A><BR>
    <I>Wed Feb 27 20:50:42 CET 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="001070.html">[Avidemux-svn-commit] r3804 - in	branches/avidemux_2.5_branch_gruntster: . cmake
</A></li>
        <LI>Next message: <A HREF="001072.html">[Avidemux-svn-commit] r3806 - in	branches/avidemux_2.5_branch_mean/avidemux: . ADM_core	ADM_core/include ADM_core/src ADM_osSupport
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1071">[ date ]</a>
              <a href="thread.html#1071">[ thread ]</a>
              <a href="subject.html#1071">[ subject ]</a>
              <a href="author.html#1071">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: mean
Date: 2008-02-27 20:50:36 +0100 (Wed, 27 Feb 2008)
New Revision: 3805

Added:
   branches/avidemux_2.5_branch_mean/avidemux/ADM_core/CMakeLists.txt
   branches/avidemux_2.5_branch_mean/avidemux/ADM_core/src/
   branches/avidemux_2.5_branch_mean/avidemux/ADM_core/src/ADM_cpuCap.cpp
   branches/avidemux_2.5_branch_mean/avidemux/ADM_core/src/ADM_crashdump.cpp
   branches/avidemux_2.5_branch_mean/avidemux/ADM_core/src/ADM_fileio.cpp
   branches/avidemux_2.5_branch_mean/avidemux/ADM_core/src/ADM_memcpy.cpp
   branches/avidemux_2.5_branch_mean/avidemux/ADM_core/src/ADM_memory.cpp
   branches/avidemux_2.5_branch_mean/avidemux/ADM_core/src/ADM_memsupport.cpp
   branches/avidemux_2.5_branch_mean/avidemux/ADM_core/src/ADM_misc.cpp
   branches/avidemux_2.5_branch_mean/avidemux/ADM_core/src/ADM_threads.cpp
   branches/avidemux_2.5_branch_mean/avidemux/ADM_core/src/ADM_win32.cpp
   branches/avidemux_2.5_branch_mean/avidemux/ADM_core/src/TLK_clock.cpp
Removed:
   branches/avidemux_2.5_branch_mean/avidemux/ADM_osSupport/ADM_cpuCap.cpp
   branches/avidemux_2.5_branch_mean/avidemux/ADM_osSupport/ADM_crashdump.cpp
   branches/avidemux_2.5_branch_mean/avidemux/ADM_osSupport/ADM_fileio.cpp
   branches/avidemux_2.5_branch_mean/avidemux/ADM_osSupport/ADM_memcpy.cpp
   branches/avidemux_2.5_branch_mean/avidemux/ADM_osSupport/ADM_memory.cpp
   branches/avidemux_2.5_branch_mean/avidemux/ADM_osSupport/ADM_memsupport.cpp
   branches/avidemux_2.5_branch_mean/avidemux/ADM_osSupport/ADM_misc.cpp
   branches/avidemux_2.5_branch_mean/avidemux/ADM_osSupport/ADM_threads.cpp
   branches/avidemux_2.5_branch_mean/avidemux/ADM_osSupport/TLK_clock.cpp
   branches/avidemux_2.5_branch_mean/avidemux/ADM_osSupport/win32.cpp
Log:
[Tree] Move source file to ADM_core/src


Added: branches/avidemux_2.5_branch_mean/avidemux/ADM_core/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_mean/avidemux/ADM_core/CMakeLists.txt	2008-02-26 21:54:51 UTC (rev 3804)
+++ branches/avidemux_2.5_branch_mean/avidemux/ADM_core/CMakeLists.txt	2008-02-27 19:50:36 UTC (rev 3805)
@@ -0,0 +1,12 @@
+subdirs(PREORDER ADM_NONE)
+subdirs(PREORDER ADM_commonUI)
+
+if(GTK_FOUND)
+subdirs(PREORDER ADM_GTK)
+endif(GTK_FOUND)
+
+if(QT4_FOUND)
+subdirs(PREORDER ADM_QT4)
+endif(QT4_FOUND)
+
+include_directories(ADM_commonUI)

Copied: branches/avidemux_2.5_branch_mean/avidemux/ADM_core/src/ADM_cpuCap.cpp (from rev 3800, branches/avidemux_2.5_branch_mean/avidemux/ADM_osSupport/ADM_cpuCap.cpp)
===================================================================
--- branches/avidemux_2.5_branch_mean/avidemux/ADM_osSupport/ADM_cpuCap.cpp	2008-02-24 17:29:52 UTC (rev 3800)
+++ branches/avidemux_2.5_branch_mean/avidemux/ADM_core/src/ADM_cpuCap.cpp	2008-02-27 19:50:36 UTC (rev 3805)
@@ -0,0 +1,213 @@
+//
+// C++ Implementation: ADM_cpuCap
+//
+// Description: 
+//
+//
+// Author: mean &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>&gt;, (C) 2004
+//
+// Copyright: See COPYING file that comes with this distribution
+//
+//
+#include &quot;config.h&quot;
+#include &lt;stdio.h&gt;
+
+#if defined(ADM_WIN32)
+#include &lt;pthread.h&gt;
+#elif !defined(__APPLE__) &amp;&amp; !defined(ADM_BSD_FAMILY)
+#include &lt;string.h&gt;
+#include &lt;sched.h&gt;
+#endif
+
+#include &quot;ADM_default.h&quot;
+
+
+#include &quot;prefs.h&quot;
+
+/* Cpu caps interface to other libs */
+extern &quot;C&quot;{ 
+	int ADM_lavcodec_mm_support(void);
+	int ADM_mpeg2dec_mm_support(void);
+	
+}
+
+
+#if defined(ARCH_X86) || defined(ARCH_X86_64)
+extern &quot;C&quot; 
+{
+#include &quot;ADM_lavcodec/dsputil_cpu.h&quot;
+}
+#endif
+
+#define cpuid(index,eax,ebx,ecx,edx)\
+    __asm __volatile\
+        (&quot;mov %%&quot;REG_b&quot;, %%&quot;REG_S&quot;\n\t&quot;\
+         &quot;cpuid\n\t&quot;\
+         &quot;xchg %%&quot;REG_b&quot;, %%&quot;REG_S\
+         : &quot;=a&quot; (eax), &quot;=S&quot; (ebx),\
+           &quot;=c&quot; (ecx), &quot;=d&quot; (edx)\
+         : &quot;0&quot; (index));
+
+
+/**
+ * 		\fn CpuCaps::init
+ * 		\brief Detect the SIM capabilities of CPU, borrowed from lavcodec
+ */
+  void 	CpuCaps::init( void)
+{
+	printf(&quot;[cpuCaps]Checking CPU capabilities\n&quot;);
+	myCpuCaps=0;
+	myCpuMask=0xffffffff;
+	prefs-&gt;get(FEATURE_CPU_CAPS,&amp;myCpuMask);
+
+#if defined(ARCH_X86) || defined(ARCH_X86_64)
+int rval = 0;
+ int eax, ebx, ecx, edx;
+ int max_std_level, max_ext_level, std_caps=0, ext_caps=0;
+ long a, c;
+
+ __asm__ __volatile__ (
+                       /* See if CPUID instruction is supported ... */
+                       /* ... Get copies of EFLAGS into eax and ecx */
+                       &quot;pushf\n\t&quot;
+                       &quot;pop %0\n\t&quot;
+                       &quot;mov %0, %1\n\t&quot;
+
+                       /* ... Toggle the ID bit in one copy and store */
+                       /*     to the EFLAGS reg */
+                       &quot;xor $0x200000, %0\n\t&quot;
+                       &quot;push %0\n\t&quot;
+                       &quot;popf\n\t&quot;
+
+                       /* ... Get the (hopefully modified) EFLAGS */
+                       &quot;pushf\n\t&quot;
+                       &quot;pop %0\n\t&quot;
+                       : &quot;=a&quot; (a), &quot;=c&quot; (c)
+                       :
+                       : &quot;cc&quot;
+                       );
+
+ if (a == c)
+     return ; /* CPUID not supported */
+
+ cpuid(0, max_std_level, ebx, ecx, edx);
+
+ if(max_std_level &gt;= 1)
+ {
+     cpuid(1, eax, ebx, ecx, std_caps);
+     if (std_caps &amp; (1&lt;&lt;23))
+    	 myCpuCaps |= ADM_CPU_MMX;
+     if (std_caps &amp; (1&lt;&lt;25))
+    	 myCpuCaps |= ADM_CPU_MMXEXT | ADM_CPU_SSE;
+     if (std_caps &amp; (1&lt;&lt;26))
+    	 myCpuCaps |= ADM_CPU_SSE2;
+     if (ecx &amp; 1)
+    	 myCpuCaps |= ADM_CPU_SSE3;
+     if (ecx &amp; 0x00000200 )
+    	 myCpuCaps |= ADM_CPU_SSSE3;
+     
+     
+     
+ }
+
+ cpuid(0x80000000, max_ext_level, ebx, ecx, edx);
+
+ if(max_ext_level &gt;= 0x80000001)
+ {
+     cpuid(0x80000001, eax, ebx, ecx, ext_caps);
+     if (ext_caps &amp; (1&lt;&lt;31))
+    	 myCpuCaps |= ADM_CPU_3DNOW;
+     if (ext_caps &amp; (1&lt;&lt;30))
+    	 myCpuCaps |= ADM_CPU_3DNOWEXT;
+     if (ext_caps &amp; (1&lt;&lt;23))
+    	 myCpuCaps |= ADM_CPU_MMX;
+     if (ext_caps &amp; (1&lt;&lt;22))
+    	 myCpuCaps |= ADM_CPU_MMXEXT;
+     
+ }
+#define CHECK(x) if(myCpuCaps &amp; ADM_CPU_##x) { printf(&quot;\t\t&quot;#x&quot; detected &quot;);\
+											if(!(myCpuMask&amp;ADM_CPU_##x)) printf(&quot;  but disabled&quot;);printf(&quot;\n&quot;);}
+	CHECK(MMX);
+	CHECK(3DNOW);
+	CHECK(MMXEXT);
+	CHECK(SSE);
+	CHECK(SSE2);
+	CHECK(SSE3);
+	CHECK(SSSE3);
+
+#endif // X86
+	printf(&quot;[cpuCaps]End of CPU capabilities check (cpuMask :%x)\n&quot;,myCpuMask);
+	return ;
+}
+
+/************************************************************************/
+#if defined(ARCH_X86) || defined(ARCH_X86_64)
+#include &quot;ADM_libraries/ADM_libMpeg2Dec/mpeg2_cpu.h&quot;
+#endif
+
+int ADM_mpeg2dec_mm_support(void)
+{
+int rval=0;
+
+#if defined(ARCH_X86) || defined(ARCH_X86_64)
+#undef MATCH
+#define MATCH(x,y) if(CpuCaps::myCpuCaps &amp; CpuCaps::myCpuMask &amp; ADM_CPU_##x) rval|=MPEG2_ACCEL_X86_##x;
+	
+	MATCH(MMX,MMX);
+	MATCH(MMXEXT,MMXEXT);
+	MATCH(3DNOW,3DNOW);
+#endif
+
+	return rval;
+}
+//******************************************************
+#if defined(ARCH_X86) || defined(ARCH_X86_64)
+#include &quot;ADM_lavcodec.h&quot;
+#endif
+/**
+ * 		\fn lavcodec_mm_support
+ * 		\brief Give lavcodec CPU supported ( FF_MM_MMX)
+ */
+int ADM_lavcodec_mm_support(void)
+{
+int rval=0;
+
+#if defined(ARCH_X86) || defined(ARCH_X86_64)
+#undef MATCH
+#define MATCH(x,y) if(CpuCaps::myCpuCaps &amp;  CpuCaps::myCpuMask &amp; ADM_CPU_##x) rval|=MM_##x;
+
+	MATCH(MMX,MMX);
+	MATCH(MMXEXT,MMXEXT);
+	MATCH(SSE,SSE);
+	MATCH(SSE2,SSE2);
+	MATCH(SSE3,SSE3);
+	MATCH(SSSE3,SSSE3);
+	MATCH(3DNOW,3DNOW);
+	MATCH(3DNOWEXT,3DNOWEXT);
+#endif
+
+	return rval;
+}
+// EOF
+
+// Stolen from x264
+int ADM_cpu_num_processors(void)
+{
+#if defined(ADM_WIN32)
+    return pthread_num_processors_np();
+#elif !defined(__APPLE__) &amp;&amp; !defined(ADM_BSD_FAMILY)
+    unsigned int bit;
+    int np;
+
+    cpu_set_t p_aff;
+    memset( &amp;p_aff, 0, sizeof(p_aff) );
+    sched_getaffinity( 0, sizeof(p_aff), &amp;p_aff );
+
+    for( np = 0, bit = 0; bit &lt; sizeof(p_aff); bit++ )
+        np += (((uint8_t *)&amp;p_aff)[bit / 8] &gt;&gt; (bit % 8)) &amp; 1;
+
+    return np;
+#else
+    return 1;
+#endif
+}

Copied: branches/avidemux_2.5_branch_mean/avidemux/ADM_core/src/ADM_crashdump.cpp (from rev 3800, branches/avidemux_2.5_branch_mean/avidemux/ADM_osSupport/ADM_crashdump.cpp)
===================================================================
--- branches/avidemux_2.5_branch_mean/avidemux/ADM_osSupport/ADM_crashdump.cpp	2008-02-24 17:29:52 UTC (rev 3800)
+++ branches/avidemux_2.5_branch_mean/avidemux/ADM_core/src/ADM_crashdump.cpp	2008-02-27 19:50:36 UTC (rev 3805)
@@ -0,0 +1,449 @@
+/***************************************************************************
+  Try to display interesting crash dump
+
+    copyright            : (C) 2007 by mean, (C) 2007 Gruntster
+    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include &quot;config.h&quot;
+
+#include &lt;stdio.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;stdarg.h&gt;
+#include &lt;string.h&gt;
+#include &quot;ADM_default.h&quot;
+#include &lt;unistd.h&gt;
+
+#include &lt;math.h&gt;
+#include &lt;ADM_assert.h&gt;
+
+#if defined(ADM_WIN32)
+#define WIN32_CLASH
+#include &lt;windows.h&gt;
+#include &lt;excpt.h&gt;
+#include &lt;imagehlp.h&gt;
+#endif
+
+
+#include &quot;ADM_toolkit/toolkit.hxx&quot;
+#include &quot;ADM_userInterfaces/ADM_commonUI/DIA_factory.h&quot;
+#include &quot;ADM_editor/ADM_edit.hxx&quot;
+extern ADM_Composer *video_body;
+
+#define CRASH_FILE &quot;crash.js&quot;
+
+static void saveCrashProject(void);
+extern char *ADM_getBaseDir(void);
+extern void A_parseECMAScript(const char *name);
+
+#ifdef __APPLE__
+void installSigHandler() {}
+
+void ADM_backTrack(int lineno,const char *file)
+{
+	char bfr[1024];
+	saveCrashProject();
+	snprintf(bfr,1024,&quot;Assert Failed at file %s, line %d\n&quot;,file,lineno);
+	GUI_Error_HIG(&quot;Fatal Error&quot;,bfr);
+	assert(0);
+}
+#elif defined(WIN32)
+typedef struct STACK_FRAME
+{
+    STACK_FRAME* ebp;	// address of the calling function frame
+    uint8_t* retAddr;	// return address
+    uint32_t param[0];	// parameter list (could be empty)
+} STACK_FRAME;
+
+static void dumpFrame(void* processId, void* frameAddr)
+{
+	MEMORY_BASIC_INFORMATION mbi;
+	char moduleName[MAX_PATH];
+	HMODULE moduleAddr;
+	DWORD symDisplacement;
+	IMAGEHLP_SYMBOL* pSymbol;
+
+	if (VirtualQuery(frameAddr, &amp;mbi, sizeof(mbi)))
+	{
+		moduleName[0] = 0;
+		moduleAddr = (HMODULE)mbi.AllocationBase;
+		
+		GetModuleFileName(moduleAddr, moduleName, MAX_PATH);
+
+		printf(&quot;%s(&quot;, moduleName);
+
+		if (SymGetSymFromAddr(processId, (uint32_t)frameAddr, &amp;symDisplacement, pSymbol))
+			printf(&quot;%s&quot;, pSymbol-&gt;Name);
+		else
+			printf(&quot;&lt;unknown&gt;&quot;);
+
+		printf(&quot;+0x%X) [0x%08X]\n&quot;, (uint32_t)frameAddr - (uint32_t)moduleAddr, frameAddr);
+
+		fflush(stdout);
+	}
+}
+	
+static void dumpExceptionInfo(void* processId, struct _EXCEPTION_RECORD* pExceptionRec, struct _CONTEXT* pContextRecord)
+{
+	printf(&quot;\n*********** EXCEPTION **************\n&quot;);
+	printf(&quot;Registers:\n&quot;);
+	printf(&quot;EAX: %08X  EBX: %08X  ECX: %08X  EDX: %08X  ESI: %08X\n&quot;, pContextRecord-&gt;Eax, pContextRecord-&gt;Ebx, pContextRecord-&gt;Ecx, pContextRecord-&gt;Edx, pContextRecord-&gt;Esi);
+	printf(&quot;EDI: %08X  ESP: %08X  EBP: %08X  EIP: %08X  EFlags: %08X\n\n&quot;, pContextRecord-&gt;Edi, pContextRecord-&gt;Esp, pContextRecord-&gt;Ebp, pContextRecord-&gt;Eip, pContextRecord-&gt;EFlags);
+
+	printf(&quot;Exception Code: &quot;);
+
+	switch (pExceptionRec-&gt;ExceptionCode)
+	{
+		case EXCEPTION_ACCESS_VIOLATION:
+			printf(&quot;EXCEPTION_ACCESS_VIOLATION&quot;);
+			break;
+		case EXCEPTION_ARRAY_BOUNDS_EXCEEDED:
+			printf(&quot;EXCEPTION_ARRAY_BOUNDS_EXCEEDED&quot;);
+			break;
+		case EXCEPTION_BREAKPOINT:
+			printf(&quot;EXCEPTION_BREAKPOINT&quot;);
+			break;
+		case EXCEPTION_DATATYPE_MISALIGNMENT:
+			printf(&quot;EXCEPTION_DATATYPE_MISALIGNMENT&quot;);
+			break;
+		case EXCEPTION_FLT_DENORMAL_OPERAND:
+			printf(&quot;EXCEPTION_FLT_DENORMAL_OPERAND&quot;);
+			break;
+		case EXCEPTION_FLT_DIVIDE_BY_ZERO:
+			printf(&quot;EXCEPTION_FLT_DIVIDE_BY_ZERO&quot;);
+			break;
+		case EXCEPTION_FLT_INEXACT_RESULT:
+			printf(&quot;EXCEPTION_FLT_INEXACT_RESULT&quot;);
+			break;
+		case EXCEPTION_FLT_INVALID_OPERATION:
+			printf(&quot;EXCEPTION_FLT_INVALID_OPERATION&quot;);
+			break;
+		case EXCEPTION_FLT_OVERFLOW:
+			printf(&quot;EXCEPTION_FLT_OVERFLOW&quot;);
+			break;
+		case EXCEPTION_FLT_STACK_CHECK:
+			printf(&quot;EXCEPTION_FLT_STACK_CHECK&quot;);
+			break;
+		case EXCEPTION_FLT_UNDERFLOW:
+			printf(&quot;EXCEPTION_FLT_UNDERFLOW&quot;);
+			break;
+		case EXCEPTION_ILLEGAL_INSTRUCTION:
+			printf(&quot;EXCEPTION_ILLEGAL_INSTRUCTION&quot;);
+			break;
+		case EXCEPTION_IN_PAGE_ERROR:
+			printf(&quot;EXCEPTION_IN_PAGE_ERROR&quot;);
+			break;
+		case EXCEPTION_INT_DIVIDE_BY_ZERO:
+			printf(&quot;EXCEPTION_INT_DIVIDE_BY_ZERO&quot;);
+			break;
+		case EXCEPTION_INT_OVERFLOW:
+			printf(&quot;EXCEPTION_INT_OVERFLOW&quot;);
+			break;
+		case EXCEPTION_INVALID_DISPOSITION:
+			printf(&quot;EXCEPTION_INVALID_DISPOSITION&quot;);
+			break;
+		case EXCEPTION_NONCONTINUABLE_EXCEPTION:
+			printf(&quot;EXCEPTION_NONCONTINUABLE_EXCEPTION&quot;);
+			break;
+		case EXCEPTION_PRIV_INSTRUCTION:
+			printf(&quot;EXCEPTION_PRIV_INSTRUCTION&quot;);
+			break;
+		case EXCEPTION_SINGLE_STEP:
+			printf(&quot;EXCEPTION_SINGLE_STEP&quot;);
+			break;
+		case EXCEPTION_STACK_OVERFLOW:
+			printf(&quot;EXCEPTION_STACK_OVERFLOW&quot;);
+			break;
+		default:
+			printf(&quot;UNKNOWN&quot;);
+	}
+	
+	printf(&quot; (%08X)\n&quot;, pExceptionRec-&gt;ExceptionCode);
+	printf(&quot;Exception Flags: %08X\n&quot;, pExceptionRec-&gt;ExceptionFlags);
+
+	printf(&quot;\nOrigin:\n&quot;);
+	dumpFrame(processId, (void*)pContextRecord-&gt;Eip);
+	printf(&quot;*********** EXCEPTION **************\n&quot;);
+	fflush(stdout);
+}
+
+extern &quot;C&quot;
+{
+void dumpBackTrace(void* processId)
+{
+	if (!processId)
+		processId = GetCurrentProcess();
+
+	const int maxAddrCount = 32;
+
+	printf(&quot;\n*********** BACKTRACE **************\n&quot;);
+
+	// Get frame address using builtin GCC function.
+	STACK_FRAME* stackFrame = (STACK_FRAME*)__builtin_frame_address(0);
+
+    for (int retAddrCount = 0; (retAddrCount &lt; maxAddrCount) &amp;&amp; !IsBadReadPtr(stackFrame, sizeof(STACK_FRAME)) &amp;&amp; !IsBadCodePtr(FARPROC(stackFrame-&gt;retAddr)); retAddrCount++, stackFrame = stackFrame-&gt;ebp)
+    {
+		printf(&quot;Frame %2d: &quot;, retAddrCount);
+		dumpFrame(processId, stackFrame-&gt;retAddr);
+		fflush(stdout);
+    }
+
+	printf(&quot;*********** BACKTRACE **************\n\n&quot;);
+}
+}
+
+void ADM_backTrack(int lineno, const char *file)
+{	
+	fflush(stderr);
+	fflush(stdout);
+	saveCrashProject();
+
+	GUI_Error_HIG(QT_TR_NOOP(&quot;Fatal Error&quot;),QT_TR_NOOP(&quot;A fatal error has occurred.\n\nClick OK to generate debug information. This may take a few minutes to complete.&quot;));
+
+	void* currentProcessId = GetCurrentProcess();
+
+	SymInitialize(currentProcessId, NULL, TRUE);
+	dumpBackTrace(currentProcessId);
+	SymCleanup(currentProcessId);
+
+	printf(&quot;Assert failed at file %s, line %d\n\n&quot;,file,lineno);
+
+	exit(1);
+}
+
+EXCEPTION_DISPOSITION exceptionHandler(struct _EXCEPTION_RECORD* pExceptionRec, void* pEstablisherFrame, struct _CONTEXT* pContextRecord, void* pDispatcherContext)
+{
+	fflush(stderr);
+	fflush(stdout);
+	static int running=0;
+
+	if(running)
+		exit(1);
+
+	running=1;
+
+	saveCrashProject();
+
+	GUI_Error_HIG(QT_TR_NOOP(&quot;Fatal Error&quot;),QT_TR_NOOP(&quot;A fatal error has occurred.\n\nClick OK to generate debug information. This may take a few minutes to complete.&quot;));
+
+	void* currentProcessId = GetCurrentProcess();
+
+	SymInitialize(currentProcessId, NULL, TRUE);
+
+	dumpExceptionInfo(currentProcessId, pExceptionRec, pContextRecord);
+	fflush(stdout);
+	dumpBackTrace(currentProcessId);
+
+	SymCleanup(currentProcessId);
+
+	exit(1);
+}
+#else
+#include &lt;signal.h&gt;
+#include &lt;execinfo.h&gt;
+void sig_segfault_handler(int signo);
+void installSigHandler()
+{
+    signal(11, sig_segfault_handler); // show stacktrace on default
+}
+extern void ADMImage_stat( void );
+
+static int lenCount(uint8_t *start,uint8_t *end,int *d)
+{
+  int val=0;
+  int digit=0;
+  *d=0;
+  while(*start&gt;='0' &amp;&amp; *start&lt;='9' &amp;&amp; start&lt;end) 
+  {
+    val=val*10+*start-'0'; 
+    start++;
+    digit++;
+  }
+  *d=digit;
+  return val;
+}
+
+static int decodeOne(uint8_t *start, uint8_t *end,int *cons)
+{
+  *cons=0;
+  int len,digit;
+  uint8_t *org=start;
+  if(start+2&gt;=end) return 0;
+  switch(*start )
+  {
+    case 'Z':
+    case 'P':  
+      
+        len=lenCount(start+1,end,&amp;digit);
+        start+=1+digit;
+        for(int z=0;z&lt;len;z++) printf(&quot;%c&quot;,*start++);
+        break;
+  }
+  return (int)((uint64_t)start-(uint64_t)org);
+}
+static int demangle(int i,  uint8_t *string)
+{
+ // Search 1st (
+  if(!string) return 0;
+  int len=strlen((char *)string);
+  if(!len) return 0;
+   
+  uint8_t *end=string+len;
+  uint8_t *start=string;
+  
+  while(*start!='(' &amp;&amp; start+3&lt;end) start++;
+  if(*start!='(') return 0;
+  start++;
+  
+  //  _qt(_Z9crashTestP9JSContextP8JSObjectjPlS3_+0) [0x4acf80]
+  
+  if(*start!='_' || start[1]!='Z')
+  {
+    return 0;
+  }
+  // Seems good !
+  start++;
+  start++;  
+  int digit;
+  // Function name..
+  int l=lenCount(start,end,&amp;digit);
+  printf(&quot;\t&lt;&quot;);
+  for(int i=0;i&lt;l;i++)
+  {
+    printf(&quot;%c&quot;,start[digit+i]); 
+  }
+  printf(&quot;&gt;(&quot;);
+  start+=digit+l;
+  
+  // Parama
+  int first=0;
+  while(start+2&lt;end &amp;&amp; *start=='P')
+  {
+    if(!first)  first=1;
+    else
+        printf(&quot;,&quot;);
+    
+      
+    start++;
+    l=lenCount(start,end,&amp;digit);
+    for(int i=0;i&lt;l;i++)
+    {
+      printf(&quot;%c&quot;,start[digit+i]); 
+    }
+    start+=digit+l;
+  }
+  printf(&quot;)\n&quot;);
+  return 1;
+}
+
+/**
+      \fn sig_segfault_handler
+      \brief our segfault handler
+
+*/
+void sig_segfault_handler(int signo)
+{
+     
+     static int running=0;
+      if(running) 
+      {
+        signo=0;
+        exit(1);
+      }
+      running=0; 
+      ADM_backTrack(0,&quot;&quot;);
+}
+void ADM_backTrack(int lineno,const char *file)
+{
+     void *stack[20];
+     char **functions;
+     int count, i;
+      
+     saveCrashProject();
+      printf(&quot;\n*********** BACKTRACK **************\n&quot;);
+      count = backtrace(stack, 20);
+      functions = backtrace_symbols(stack, count);
+      
+         for (i=0; i &lt; count; i++) 
+         {
+            printf(&quot;Frame %2d: %s \n&quot;, i, functions[i]);
+            demangle(i,(uint8_t *)functions[i]);
+            
+         }
+      printf(&quot;*********** BACKTRACK **************\n&quot;);
+     // Now use dialogFactory
+      char bfr[30];
+      snprintf(bfr,30,&quot;Line:%u&quot;,lineno);
+      diaElemReadOnlyText *txt[count+1];
+      txt[0]=new diaElemReadOnlyText(bfr,file);
+      
+      for(i=0;i&lt;count;i++)
+          txt[i+1]=new diaElemReadOnlyText(functions[i],&quot;Function:&quot;);
+      const char *title=&quot;Crash BackTrace&quot;;
+      if(lineno) title=&quot;Assert failed&quot;;
+      diaFactoryRun(title,count+1,(diaElem **)txt);
+      
+      //
+     printf(&quot;Memory stat:\n&quot;);
+     ADMImage_stat();
+
+     exit(1); // _exit(1) ???
+}
+#endif
+/**
+    \fn saveCrashProject
+    \brief Try to save the current project, useful in case of crash
+*/
+void saveCrashProject(void)
+{
+  char *baseDir=ADM_getBaseDir();
+  char *name=CRASH_FILE;
+  static int crashCount=0;
+  if(crashCount) return ; // avoid endless looping
+  crashCount++;
+  char *where=new char[strlen(baseDir)+strlen(name)+2];
+  strcpy(where,baseDir);
+  strcat(where,&quot;/&quot;);
+  strcat(where,name);
+  printf(&quot;Saving crash file to %s\n&quot;,where);
+  video_body-&gt;saveAsScript (where, NULL);
+  delete[] where;
+}
+/**
+    \fn checkCrashFile
+    \brief Check if there i a crash file
+*/
+
+void checkCrashFile(void)
+{
+  char *baseDir=ADM_getBaseDir();
+  char *name=CRASH_FILE;
+  static int crashCount=0;
+  char *where=new char[strlen(baseDir)+strlen(name)+2];
+  strcpy(where,baseDir);
+  strcat(where,&quot;/&quot;);
+  strcat(where,name);
+  if(ADM_fileExist(where))
+  {
+    if(GUI_Confirmation_HIG(QT_TR_NOOP(&quot;Load it&quot;),QT_TR_NOOP(&quot;Crash file&quot;),
+       QT_TR_NOOP(&quot;I have detected a crash file. \nDo you want to load it  ?\n(It will be deleted in all cases, you should save it if you want to keep it)&quot;)))
+    {
+       A_parseECMAScript(where);
+    }
+    unlink(where);
+  }else
+  {
+    printf(&quot;No crash file (%s)\n&quot;,where); 
+  }
+  delete [] where;
+}
+//EOF

Copied: branches/avidemux_2.5_branch_mean/avidemux/ADM_core/src/ADM_fileio.cpp (from rev 3800, branches/avidemux_2.5_branch_mean/avidemux/ADM_osSupport/ADM_fileio.cpp)
===================================================================
--- branches/avidemux_2.5_branch_mean/avidemux/ADM_osSupport/ADM_fileio.cpp	2008-02-24 17:29:52 UTC (rev 3800)
+++ branches/avidemux_2.5_branch_mean/avidemux/ADM_core/src/ADM_fileio.cpp	2008-02-27 19:50:36 UTC (rev 3805)
@@ -0,0 +1,410 @@
+/***************************************************************************
+                    
+    copyright            : (C) 2006 by mean
+    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include &quot;config.h&quot; 
+#include &lt;stdio.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;string.h&gt;
+    
+#include &lt;dirent.h&gt;
+#include &lt;errno.h&gt;
+#include &lt;sys/stat.h&gt;
+
+#include &lt;unistd.h&gt;
+
+#ifdef WIN32
+#include &lt;glib.h&gt;
+#endif
+
+#include &quot;ADM_default.h&quot;
+
+
+
+#include &quot;ADM_toolkit/filesel.h&quot;
+#include &quot;ADM_toolkit/toolkit.hxx&quot;
+
+#include &quot;ADM_assert.h&quot;
+#undef fread
+#undef fwrite
+#undef fopen
+#undef fclose
+
+size_t ADM_fread (void *ptr, size_t size, size_t n, FILE *sstream)
+{
+  return fread(ptr,size,n,sstream); 
+  
+}
+
+size_t ADM_fwrite (void *ptr, size_t size, size_t n, FILE *sstream)
+{
+  return fwrite(ptr,size,n,sstream); 
+  
+}
+FILE  *ADM_fopen (const char *file, const char *mode)
+{
+  FILE *f;
+
+#ifndef ADM_WIN32
+  return fopen(file,mode); 
+#else
+  gchar *retval = g_locale_from_utf8 (file, -1, NULL, NULL, NULL);
+  f=fopen(retval,mode);
+  g_free (retval);
+  return f;  
+#endif
+}
+
+int    ADM_fclose (FILE *file)
+{
+  return fclose(file); 
+}
+//*****************************
+static char basedir[1024]={0};
+static char jobdir[1024]={0};
+static char customdir[1024]={0};
+int baseDirDone=0;
+int jobDirDone=0;
+int customDirDone=0;
+#ifdef ADM_WIN32
+const char *ADM_DIR_NAME=&quot;\\avidemux&quot;;
+#else
+const char *ADM_DIR_NAME=&quot;/.avidemux&quot;;
+#endif
+/*
+
+*/
+/*
+      Get the  directory where jobs are stored
+******************************************************/
+
+char *ADM_getCustomDir(void)
+{
+  if(customDirDone) return customdir;
+
+  char *rootDir;
+  rootDir=ADM_getBaseDir();
+  strncpy(customdir,rootDir,1023);
+#if defined(ADM_WIN32)
+  strcat(customdir,&quot;\\custom&quot;); 
+#else
+  strcat(customdir,&quot;/custom&quot;);
+#endif
+  if(!ADM_mkdir(customdir))
+  {
+    GUI_Error_HIG(QT_TR_NOOP(&quot;Oops&quot;),QT_TR_NOOP(&quot;can't create custom directory (%s).&quot;),customdir);
+                return NULL;
+  }
+  customDirDone=1;
+  return customdir;
+}
+/*
+      Get the  directory where jobs are stored
+******************************************************/
+
+char *ADM_getJobDir(void)
+{
+  if(jobDirDone) return jobdir;
+
+  char *rootDir;
+  rootDir=ADM_getBaseDir();
+  strncpy(jobdir,rootDir,1023);
+#if defined(ADM_WIN32)
+  strcat(jobdir,&quot;\\jobs&quot;); 
+#else
+  strcat(jobdir,&quot;/jobs&quot;);
+#endif
+  if(!ADM_mkdir(jobdir))
+  {
+    GUI_Error_HIG(QT_TR_NOOP(&quot;Oops&quot;),QT_TR_NOOP(&quot;can't create job directory (%s).&quot;),jobdir);
+                return NULL;
+  }
+  jobDirDone=1;
+  return jobdir;
+}
+/*
+      Get the root directory for .avidemux stuff
+******************************************************/
+char *ADM_getBaseDir(void)
+{
+char *dirname=NULL;
+DIR *dir=NULL;
+char *home;
+//
+        if(baseDirDone) return basedir;
+// Get the base directory
+#if defined(ADM_WIN32)
+        if( ! (home=getenv(&quot;USERPROFILE&quot;)) )
+        {
+          GUI_Error_HIG(QT_TR_NOOP(&quot;Oops&quot;),QT_TR_NOOP(&quot;can't determine $USERPROFILE.&quot;));
+                    home=&quot;c:\\&quot;;
+        }
+
+#else
+        if( ! (home=getenv(&quot;HOME&quot;)) )
+        {
+          GUI_Error_HIG(QT_TR_NOOP(&quot;Oops&quot;),QT_TR_NOOP(&quot;can't determine $HOME.&quot;));
+                return NULL;
+        }
+#endif
+
+ // Try to open the .avidemux directory
+        dirname=new char[strlen(home)+strlen(ADM_DIR_NAME)+2];
+        strcpy(dirname,home);
+        strcat(dirname,ADM_DIR_NAME);
+        if(!ADM_mkdir(dirname))
+        {
+          GUI_Error_HIG(QT_TR_NOOP(&quot;Oops&quot;),QT_TR_NOOP(&quot;Cannot create the .avidemux directory&quot;), NULL);
+                        delete [] dirname;
+                        return NULL;
+        }
+        delete [] dirname;
+
+        // Now built the filename
+        strncpy(basedir,home,1023);
+        strncat(basedir,ADM_DIR_NAME,1023-strlen(basedir));
+        baseDirDone=1;
+        printf(&quot;Using %s as base directory for prefs/jobs/...\n&quot;,basedir);
+        return basedir;
+}
+/*----------------------------------------
+      Create a directory
+      If it already exists, do nothing
+------------------------------------------*/
+uint8_t ADM_mkdir(const char *dirname)
+{
+DIR *dir=NULL;
+              // Check it already exists ?
+              dir=opendir(dirname);
+              if(dir)
+              { 
+                  printf(&quot;Directory %s exists.Good.\n&quot;,dirname);
+                  closedir(dir);
+                  return 1;
+              }
+#if defined(ADM_WIN32)
+                if(mkdir(dirname))
+                {
+                    printf(&quot;Oops: mkdir failed on %s\n&quot;,dirname);   
+                    return 0;
+                }
+                
+#else    
+                char *sys=new char[strlen(dirname)+strlen(&quot;mkdir &quot;)+2];
+                strcpy(sys,&quot;mkdir &quot;);
+                strcat(sys,dirname);
+                printf(&quot;Creating dir :%s\n&quot;,sys);
+                system(sys);
+                delete [] sys;
+#endif		
+              if((dir=opendir(dirname))==NULL)
+                {
+                        return 0;
+                }
+              closedir(dir); 
+              return 1;
+}
+uint8_t buildDirectoryContent(uint32_t *outnb,const char *base, char *jobName[],int maxElems,const char *ext)
+{
+
+DIR *dir;
+struct dirent *direntry;
+int dirmax=0,len;
+int extlen=strlen(ext);
+    ADM_assert(extlen);
+    
+         dir=opendir(base);
+        if(!dir)
+        {
+                return 0;
+        }
+        while((direntry=readdir(dir)))
+        {
+                len=strlen(direntry-&gt;d_name);
+                if(len&lt;(extlen+1)) continue;
+                int xbase=len-extlen;
+                if(memcmp(direntry-&gt;d_name+xbase,ext,extlen))
+                //if(direntry-&gt;d_name[len-1]!='s' || direntry-&gt;d_name[len-2]!='j' || direntry-&gt;d_name[len-3]!='.')
+                {
+                        printf(&quot;ignored:%s\n&quot;,direntry-&gt;d_name);
+                        continue;
+                }
+                jobName[dirmax]=(char *)ADM_alloc(strlen(base)+strlen(direntry-&gt;d_name)+2);
+                strcpy(jobName[dirmax],base);
+                strcat(jobName[dirmax],&quot;/&quot;);
+                strcat(jobName[dirmax],direntry-&gt;d_name);
+                dirmax++;
+                if(dirmax&gt;=maxElems)
+                {
+                        printf(&quot;[jobs]: Max # of jobs exceeded\n&quot;);
+                         break;
+                }
+        }
+        closedir(dir);
+        *outnb=dirmax;
+        return 1;
+}
+//------------------------------------------------------------------
+
+/*
+
+** note: it modifies it's first argument
+*/
+void simplify_path(char **buf){
+   unsigned int last1slash = 0;
+   unsigned int last2slash = 0;
+	while( !strncmp(*buf,&quot;/../&quot;,4) )
+		memmove(*buf,*buf+3,strlen(*buf+3)+1);
+	for(unsigned int i=0;i&lt;strlen(*buf)-2;i++)
+		while( !strncmp(*buf+i,&quot;/./&quot;,3) )
+			memmove(*buf+i,*buf+i+2,strlen(*buf+i+2)+1);
+	for(unsigned int i=0;i&lt;strlen(*buf)-3;i++){
+		if( *(*buf+i) == '/' ){
+			last2slash = last1slash;
+			last1slash = i;
+		}
+		if( !strncmp(*buf+i,&quot;/../&quot;,4) ){
+			memmove(*buf+last2slash,*buf+i+3,strlen(*buf+i+3)+1);
+			return simplify_path(buf);
+		}
+	}
+}
+
+//
+//	Make it absolute
+//
+char *PathCanonize(const char *tmpname)
+{
+	char path[300];
+	char *out ;
+
+	if( ! getcwd(path,300) ){
+		fprintf(stderr,&quot;\ngetcwd() failed with: %s (%u)\n&quot;,
+		               strerror(errno), errno );
+		path[0] = '\0';
+	}
+	if(!tmpname || tmpname[0]==0)
+	{
+		out=new char [strlen(path)+2];
+		strcpy(out,path);
+#ifndef ADM_WIN32		
+		strcat(out,&quot;/&quot;);
+#else
+		strcat(out,&quot;\\&quot;);
+#endif	
+		printf(&quot;\n Canonizing null string ??? (%s)\n&quot;,out);
+	}else if(tmpname[0]=='/'
+#if defined(ADM_WIN32)
+		|| tmpname[1]==':'
+#endif	
+	
+	)
+	{
+		out=new char[strlen(tmpname)+1];
+		strcpy(out,tmpname);
+		return out;
+	}else{
+		out=new char[strlen(path)+strlen(tmpname)+6];
+		strcpy(out,path);
+#ifndef ADM_WIN32		
+		strcat(out,&quot;/&quot;);
+#else
+		strcat(out,&quot;\\&quot;);
+#endif		
+		strcat(out,tmpname);
+	}
+	simplify_path(&amp;out);
+	return out;
+}
+/*
+	Strip the path and only keep the name
+
+*/
+void		PathStripName(char *str)
+{
+		int len=strlen(str);
+		if(len&lt;=1) return;
+		len--;
+#ifndef ADM_WIN32		
+		while( *(str+len)!='/' &amp;&amp; len)
+#else
+	while( *(str+len)!='\\' &amp;&amp; len)
+#endif		
+		{
+			 *(str+len)=0;
+			 len--;
+		}
+}
+
+/*
+	Get the filename without path
+
+*/
+const char *GetFileName(const char *str)
+{
+	char *filename;
+        char *filename2;
+#ifndef ADM_WIN32		
+	filename = strrchr(str, '/');
+        
+#else
+	filename = strrchr(str, '\\');
+        filename2 = strrchr(str, '/');
+        if(filename2 &amp;&amp; filename)
+        {
+          if(filename2&gt;filename) filename=filename2; 
+        }
+#endif
+	if (filename)
+		return filename+1;
+	else
+		return str;
+}
+
+/*
+	Split patch into absolute path+name and extention
+
+*/
+void PathSplit(char *str, char **root, char **ext)
+{
+	char *full;
+	uint32_t l;
+
+		full=PathCanonize(str);
+		// Search the last .
+		l=strlen(full);
+		l--;
+		ADM_assert(l&gt;0);
+		while( *(full+l)!='.' &amp;&amp; l) l--;
+		if(!l || l==(strlen(full)-1))
+		{
+			if(l==(strlen(full)-1))
+			{
+				*(full+l)=0;  // remove trailing .
+			}
+			*ext=new char[2];
+			*root=full;
+			strcpy(*ext,&quot;&quot;);
+			return ;
+		}
+		// else we do get an extension
+		// starting at l+1
+		uint32_t suff;
+
+		suff=strlen(full)-l-1;
+		*ext=new char[suff+1];
+		strcpy(*ext,full+l+1);
+		*(full+l)=0;
+		*root=full;
+		return ;
+}

Copied: branches/avidemux_2.5_branch_mean/avidemux/ADM_core/src/ADM_memcpy.cpp (from rev 3800, branches/avidemux_2.5_branch_mean/avidemux/ADM_osSupport/ADM_memcpy.cpp)
===================================================================
--- branches/avidemux_2.5_branch_mean/avidemux/ADM_osSupport/ADM_memcpy.cpp	2008-02-24 17:29:52 UTC (rev 3800)
+++ branches/avidemux_2.5_branch_mean/avidemux/ADM_core/src/ADM_memcpy.cpp	2008-02-27 19:50:36 UTC (rev 3805)
@@ -0,0 +1,483 @@
+
+
+
+
+/* Adapted from Xine /Mplayer to avidemx2 */
+/*
+ * Copyright (C) 2001-2004 the xine project
+ *
+ * This file is part of xine, a free video player.
+ *
+ * xine is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * xine is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA
+ *
+ * These are the MMX/MMX2/SSE optimized versions of memcpy
+ *
+ * This code was adapted from Linux Kernel sources by Nick Kurshev to
+ * the mplayer program. (<A HREF="http://mplayer.sourceforge.net">http://mplayer.sourceforge.net</A>)
+ *
+ * Miguel Freitas split the #ifdefs into several specialized functions that
+ * are benchmarked at runtime by xine. Some original comments from Nick
+ * have been preserved documenting some MMX/SSE oddities.
+ * Also added kernel memcpy function that seems faster than libc one.
+ *
+ */
+
+
+#include &quot;config.h&quot;
+
+#include &lt;stdio.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;string.h&gt;
+
+#include &quot;ADM_default.h&quot;
+
+extern &quot;C&quot;
+{
+        #include &quot;ADM_lavcodec/dsputil_cpu.h&quot;
+
+
+
+#include &quot;ADM_assert.h&quot;
+
+adm_fast_memcpy myAdmMemcpy=NULL;
+/* Original comments from mplayer (file: aclib.c)
+ This part of code was taken by me from Linux-2.4.3 and slightly modified
+for MMX, MMX2, SSE instruction set. I have done it since linux uses page aligned
+blocks but mplayer uses weakly ordered data and original sources can not
+speedup them. Only using PREFETCHNTA and MOVNTQ together have effect!
+
+&gt;From IA-32 Intel Architecture Software Developer's Manual Volume 1,
+
+Order Number 245470:
+&quot;10.4.6. Cacheability Control, Prefetch, and Memory Ordering Instructions&quot;
+
+Data referenced by a program can be temporal (data will be used again) or
+non-temporal (data will be referenced once and not reused in the immediate
+future). To make efficient use of the processor's caches, it is generally
+desirable to cache temporal data and not cache non-temporal data. Overloading
+the processor's caches with non-temporal data is sometimes referred to as
+&quot;polluting the caches&quot;.
+The non-temporal data is written to memory with Write-Combining semantics.
+
+The PREFETCHh instructions permits a program to load data into the processor
+at a suggested cache level, so that it is closer to the processors load and
+store unit when it is needed. If the data is already present in a level of
+the cache hierarchy that is closer to the processor, the PREFETCHh instruction
+will not result in any data movement.
+But we should you PREFETCHNTA: Non-temporal data fetch data into location
+close to the processor, minimizing cache pollution.
+
+The MOVNTQ (store quadword using non-temporal hint) instruction stores
+packed integer data from an MMX register to memory, using a non-temporal hint.
+The MOVNTPS (store packed single-precision floating-point values using
+non-temporal hint) instruction stores packed floating-point data from an
+XMM register to memory, using a non-temporal hint.
+
+The SFENCE (Store Fence) instruction controls write ordering by creating a
+fence for memory store operations. This instruction guarantees that the results
+of every store instruction that precedes the store fence in program order is
+globally visible before any store instruction that follows the fence. The
+SFENCE instruction provides an efficient way of ensuring ordering between
+procedures that produce weakly-ordered data and procedures that consume that
+data.
+
+If you have questions please contact with me: Nick Kurshev: <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">nickols_k at mail.ru.</A>
+*/
+
+/*  mmx v.1 Note: Since we added alignment of destinition it speedups
+    of memory copying on PentMMX, Celeron-1 and P2 upto 12% versus
+    standard (non MMX-optimized) version.
+    Note: on K6-2+ it speedups memory copying upto 25% and
+          on K7 and P3 about 500% (5 times).
+*/
+
+/* Additional notes on gcc assembly and processors: [MF]
+prefetch is specific for AMD processors, the intel ones should be
+prefetch0, prefetch1, prefetch2 which are not recognized by my gcc.
+prefetchnta is supported both on athlon and pentium 3.
+
+therefore i will take off prefetchnta instructions from the mmx1 version
+to avoid problems on pentium mmx and k6-2.
+
+quote of the day:
+&quot;Using prefetches efficiently is more of an art than a science&quot;
+*/
+
+
+#if defined(ARCH_X86) || defined(ARCH_X86_64)
+
+
+/* for small memory blocks (&lt;256 bytes) this version is faster */
+#define small_memcpy(to,from,n)\
+{\
+register unsigned long int dummy;\
+__asm__ __volatile__(\
+  &quot;rep; movsb&quot;\
+  :&quot;=&amp;D&quot;(to), &quot;=&amp;S&quot;(from), &quot;=&amp;c&quot;(dummy)\
+  :&quot;0&quot; (to), &quot;1&quot; (from),&quot;2&quot; (n)\
+  : &quot;memory&quot;);\
+}
+
+/* linux kernel __memcpy (from: /include/asm/string.h) */
+static __inline__ void * linux_kernel_memcpy_impl (
+			       void * to,
+			       const void * from,
+			       size_t n)
+{
+int d0, d1, d2;
+
+  if( n &lt; 4 ) {
+    small_memcpy(to,from,n);
+  }
+  else
+    __asm__ __volatile__(
+    &quot;rep ; movsl\n\t&quot;
+    &quot;testb $2,%b4\n\t&quot;
+    &quot;je 1f\n\t&quot;
+    &quot;movsw\n&quot;
+    &quot;1:\ttestb $1,%b4\n\t&quot;
+    &quot;je 2f\n\t&quot;
+    &quot;movsb\n&quot;
+    &quot;2:&quot;
+    : &quot;=&amp;c&quot; (d0), &quot;=&amp;D&quot; (d1), &quot;=&amp;S&quot; (d2)
+    :&quot;0&quot; (n/4), &quot;q&quot; (n),&quot;1&quot; ((long) to),&quot;2&quot; ((long) from)
+    : &quot;memory&quot;);
+
+  return (to);
+}
+
+#define SSE_MMREG_SIZE 16
+#define MMX_MMREG_SIZE 8
+
+#define MMX1_MIN_LEN 0x800  /* 2K blocks */
+#define MIN_LEN 0x40  /* 64-byte blocks */
+
+/* SSE note: i tried to move 128 bytes a time instead of 64 but it
+didn't make any measureable difference. i'm using 64 for the sake of
+simplicity. [MF] */
+static void * sse_memcpy(void * to, const void * from, size_t len)
+{
+  void *retval;
+  uint8_t *ufrom=(uint8_t *)from;
+  uint8_t *uto=(uint8_t *)to;
+  size_t i;
+  retval = to;
+
+  /* PREFETCH has effect even for MOVSB instruction ;) */
+  __asm__ __volatile__ (
+    &quot;   prefetchnta (%0)\n&quot;
+    &quot;   prefetchnta 32(%0)\n&quot;
+    &quot;   prefetchnta 64(%0)\n&quot;
+    &quot;   prefetchnta 96(%0)\n&quot;
+    &quot;   prefetchnta 128(%0)\n&quot;
+    &quot;   prefetchnta 160(%0)\n&quot;
+    &quot;   prefetchnta 192(%0)\n&quot;
+    &quot;   prefetchnta 224(%0)\n&quot;
+    &quot;   prefetchnta 256(%0)\n&quot;
+    &quot;   prefetchnta 288(%0)\n&quot;
+    : : &quot;r&quot; (ufrom) );
+
+  if(len &gt;= MIN_LEN)
+  {
+    register unsigned long int delta;
+    /* Align destinition to MMREG_SIZE -boundary */
+    delta = ((unsigned long int)uto)&amp;(SSE_MMREG_SIZE-1);
+    if(delta)
+    {
+      delta=SSE_MMREG_SIZE-delta;
+      len -= delta;
+      small_memcpy(uto, ufrom, delta);
+    }
+    i = len &gt;&gt; 6; /* len/64 */
+    len&amp;=63;
+    if(((unsigned long)ufrom) &amp; 15)
+      /* if SRC is misaligned */
+      for(; i&gt;0; i--)
+      {
+        __asm__ __volatile__ (
+        &quot;prefetchnta 320(%0)\n&quot;
+       &quot;prefetchnta 352(%0)\n&quot;
+        &quot;movups (%0), %%xmm0\n&quot;
+        &quot;movups 16(%0), %%xmm1\n&quot;
+        &quot;movups 32(%0), %%xmm2\n&quot;
+        &quot;movups 48(%0), %%xmm3\n&quot;
+        &quot;movntps %%xmm0, (%1)\n&quot;
+        &quot;movntps %%xmm1, 16(%1)\n&quot;
+        &quot;movntps %%xmm2, 32(%1)\n&quot;
+        &quot;movntps %%xmm3, 48(%1)\n&quot;
+        :: &quot;r&quot; (ufrom), &quot;r&quot; (uto) : &quot;memory&quot;);
+         ufrom+=64;
+         uto+=64;
+      }
+    else
+      /*
+         Only if SRC is aligned on 16-byte boundary.
+         It allows to use movaps instead of movups, which required data
+         to be aligned or a general-protection exception (#GP) is generated.
+      */
+      for(; i&gt;0; i--)
+      {
+        __asm__ __volatile__ (
+        &quot;prefetchnta 320(%0)\n&quot;
+       &quot;prefetchnta 352(%0)\n&quot;
+        &quot;movaps (%0), %%xmm0\n&quot;
+        &quot;movaps 16(%0), %%xmm1\n&quot;
+        &quot;movaps 32(%0), %%xmm2\n&quot;
+        &quot;movaps 48(%0), %%xmm3\n&quot;
+        &quot;movntps %%xmm0, (%1)\n&quot;
+        &quot;movntps %%xmm1, 16(%1)\n&quot;
+        &quot;movntps %%xmm2, 32(%1)\n&quot;
+        &quot;movntps %%xmm3, 48(%1)\n&quot;
+        :: &quot;r&quot; (ufrom), &quot;r&quot; (uto) : &quot;memory&quot;);
+        ufrom+=64;
+        uto+=64;
+      }
+    /* since movntq is weakly-ordered, a &quot;sfence&quot;
+     * is needed to become ordered again. */
+    __asm__ __volatile__ (&quot;sfence&quot;:::&quot;memory&quot;);
+    /* enables to use FPU */
+    __asm__ __volatile__ (&quot;emms&quot;:::&quot;memory&quot;);
+  }
+  /*
+   *	Now do the tail of the block
+   */
+  if(len) linux_kernel_memcpy_impl(uto, ufrom, len);
+  return retval;
+}
+
+static void * mmx_memcpy(void * to, const void * from, size_t len)
+{
+  void *retval;
+  uint8_t *ufrom=(uint8_t *)from;
+  uint8_t *uto=(uint8_t *)to;
+  size_t i;
+  retval = uto;
+
+  if(len &gt;= MMX1_MIN_LEN)
+  {
+    register unsigned long int delta;
+    /* Align destinition to MMREG_SIZE -boundary */
+    delta = ((unsigned long int)uto)&amp;(MMX_MMREG_SIZE-1);
+    if(delta)
+    {
+      delta=MMX_MMREG_SIZE-delta;
+      len -= delta;
+      small_memcpy(uto, ufrom, delta);
+    }
+    i = len &gt;&gt; 6; /* len/64 */
+    len&amp;=63;
+    for(; i&gt;0; i--)
+    {
+      __asm__ __volatile__ (
+      &quot;movq (%0), %%mm0\n&quot;
+      &quot;movq 8(%0), %%mm1\n&quot;
+      &quot;movq 16(%0), %%mm2\n&quot;
+      &quot;movq 24(%0), %%mm3\n&quot;
+      &quot;movq 32(%0), %%mm4\n&quot;
+      &quot;movq 40(%0), %%mm5\n&quot;
+      &quot;movq 48(%0), %%mm6\n&quot;
+      &quot;movq 56(%0), %%mm7\n&quot;
+      &quot;movq %%mm0, (%1)\n&quot;
+      &quot;movq %%mm1, 8(%1)\n&quot;
+      &quot;movq %%mm2, 16(%1)\n&quot;
+      &quot;movq %%mm3, 24(%1)\n&quot;
+      &quot;movq %%mm4, 32(%1)\n&quot;
+      &quot;movq %%mm5, 40(%1)\n&quot;
+      &quot;movq %%mm6, 48(%1)\n&quot;
+      &quot;movq %%mm7, 56(%1)\n&quot;
+      :: &quot;r&quot; (ufrom), &quot;r&quot; (uto) : &quot;memory&quot;);
+      ufrom+=64;
+      uto+=64;
+    }
+    __asm__ __volatile__ (&quot;emms&quot;:::&quot;memory&quot;);
+  }
+  /*
+   *	Now do the tail of the block
+   */
+  if(len) linux_kernel_memcpy_impl(uto, ufrom, len);
+  return retval;
+}
+
+static void * mmx2_memcpy(void * to, const void * from, size_t len)
+{
+  void *retval;
+  uint8_t *ufrom=(uint8_t *)from;
+  uint8_t *uto=(uint8_t *)to;
+  size_t i;
+  retval = to;
+
+  /* PREFETCH has effect even for MOVSB instruction ;) */
+  __asm__ __volatile__ (
+    &quot;   prefetchnta (%0)\n&quot;
+    &quot;   prefetchnta 32(%0)\n&quot;
+    &quot;   prefetchnta 64(%0)\n&quot;
+    &quot;   prefetchnta 96(%0)\n&quot;
+    &quot;   prefetchnta 128(%0)\n&quot;
+    &quot;   prefetchnta 160(%0)\n&quot;
+    &quot;   prefetchnta 192(%0)\n&quot;
+    &quot;   prefetchnta 224(%0)\n&quot;
+    &quot;   prefetchnta 256(%0)\n&quot;
+    &quot;   prefetchnta 288(%0)\n&quot;
+    : : &quot;r&quot; (ufrom) );
+
+  if(len &gt;= MIN_LEN)
+  {
+    register unsigned long int delta;
+    /* Align destinition to MMREG_SIZE -boundary */
+    delta = ((unsigned long int)uto)&amp;(MMX_MMREG_SIZE-1);
+    if(delta)
+    {
+      delta=MMX_MMREG_SIZE-delta;
+      len -= delta;
+      small_memcpy(uto, ufrom, delta);
+    }
+    i = len &gt;&gt; 6; /* len/64 */
+    len&amp;=63;
+    for(; i&gt;0; i--)
+    {
+      __asm__ __volatile__ (
+      &quot;prefetchnta 320(%0)\n&quot;
+      &quot;prefetchnta 352(%0)\n&quot;
+      &quot;movq (%0), %%mm0\n&quot;
+      &quot;movq 8(%0), %%mm1\n&quot;
+      &quot;movq 16(%0), %%mm2\n&quot;
+      &quot;movq 24(%0), %%mm3\n&quot;
+      &quot;movq 32(%0), %%mm4\n&quot;
+      &quot;movq 40(%0), %%mm5\n&quot;
+      &quot;movq 48(%0), %%mm6\n&quot;
+      &quot;movq 56(%0), %%mm7\n&quot;
+      &quot;movntq %%mm0, (%1)\n&quot;
+      &quot;movntq %%mm1, 8(%1)\n&quot;
+      &quot;movntq %%mm2, 16(%1)\n&quot;
+      &quot;movntq %%mm3, 24(%1)\n&quot;
+      &quot;movntq %%mm4, 32(%1)\n&quot;
+      &quot;movntq %%mm5, 40(%1)\n&quot;
+      &quot;movntq %%mm6, 48(%1)\n&quot;
+      &quot;movntq %%mm7, 56(%1)\n&quot;
+      :: &quot;r&quot; (ufrom), &quot;r&quot; (uto) : &quot;memory&quot;);
+      ufrom+=64;
+      uto+=64;
+    }
+     /* since movntq is weakly-ordered, a &quot;sfence&quot;
+     * is needed to become ordered again. */
+    __asm__ __volatile__ (&quot;sfence&quot;:::&quot;memory&quot;);
+    __asm__ __volatile__ (&quot;emms&quot;:::&quot;memory&quot;);
+  }
+  /*
+   *	Now do the tail of the block
+   */
+  if(len) linux_kernel_memcpy_impl(uto, ufrom, len);
+  return retval;
+}
+
+static void *linux_kernel_memcpy(void *to, const void *from, size_t len) {
+  return linux_kernel_memcpy_impl(to,from,len);
+}
+#endif /* ARCH_X86 */
+
+static struct {
+  char *name;
+  void *(* function)(void *to, const void *from, size_t len);
+
+  uint64_t time; /* This type could be used for non-MSC build too! */
+
+  uint32_t cpu_require;
+} memcpy_method[] =
+{
+  { NULL, NULL, 0, 0 },
+  { &quot;libc memcpy()&quot;, memcpy, 0, 0 },
+#if defined( ARCH_X86)  || defined(ARCH_X86_64)
+  { &quot;linux kernel memcpy()&quot;, linux_kernel_memcpy, 0, 0 },
+#if defined( ARCH_X86)  || defined(ARCH_X86_64)
+  { &quot;MMX optimized memcpy()&quot;, mmx_memcpy, 0, MM_MMX },
+  { &quot;MMXEXT optimized memcpy()&quot;, mmx2_memcpy, 0, MM_MMXEXT },
+  { &quot;SSE optimized memcpy()&quot;, sse_memcpy, 0, MM_MMXEXT|MM_SSE },
+#endif
+#endif /* ARCH_X86 */
+#if 0 &amp;&amp; defined (ARCH_PPC) &amp;&amp; !defined (HOST_OS_DARWIN)
+  { &quot;ppcasm_memcpy()&quot;, ppcasm_memcpy, 0, 0 },
+  { &quot;ppcasm_cacheable_memcpy()&quot;, ppcasm_cacheable_memcpy, 0, MM_ACCEL_PPC_CACHE32 },
+#endif /* ARCH_PPC &amp;&amp; !HOST_OS_DARWIN */
+  { NULL, NULL, 0, 0 }
+};
+
+#if defined( ARCH_X86)  || defined(ARCH_X86_64)
+static unsigned long long int rdtsc(void)
+{
+  unsigned long long int x;
+
+  /* that should prevent us from trying cpuid with old cpus */
+ 
+    __asm__ volatile (&quot;.byte 0x0f, 0x31&quot; : &quot;=A&quot; (x));
+    return x;
+ }
+#else
+static unsigned long long int rdtsc(void)
+{
+	return 0;
+ }
+
+#endif
+
+
+
+#define BUFSIZE 1024*1024
+/*******************************************
+*/
+uint8_t probe(adm_fast_memcpy func,char *name)
+{
+	void *src,*dst;
+	uint64_t start,stop;
+
+	src=ADM_alloc(BUFSIZE);
+	dst=ADM_alloc(BUFSIZE);
+	start=rdtsc();
+	func(dst,src,BUFSIZE);
+	stop=rdtsc();
+	ADM_dealloc(src);
+	ADM_dealloc(dst);
+	printf(&quot;Method :%s \tTime:%lu\n&quot;,name,stop-start);
+	return 1;
+
+}
+/*
+
+	It seems MMX gives the best result most of the times
+	Don't bother benchmarking
+*/
+uint8_t ADM_InitMemcpy(void)
+{
+  uint64_t          t;
+  char             *buf1, *buf2;
+  int               i, j, best;
+  int               config_flags = 0;
+#undef memcpy
+        myAdmMemcpy=memcpy;
+#if defined( ARCH_X86)  || defined(ARCH_X86_64)
+        if(CpuCaps::hasMMX())
+                myAdmMemcpy=mmx_memcpy;
+#endif
+#if 0
+	probe(memcpy,&quot;libc&quot;);
+	probe(linux_kernel_memcpy,&quot;kernel&quot;);
+#if defined( ARCH_X86)  || defined(ARCH_X86_64)
+	if(CpuCaps::hasMMX()) probe(mmx_memcpy,&quot;mmx&quot;);
+	if(CpuCaps::hasMMXEXT()) probe(mmx_memcpy,&quot;mmxext&quot;);
+	if(CpuCaps::hasSSE()) probe(sse_memcpy,&quot;sse&quot;);
+#endif
+#endif
+	return 1; 
+}
+}

Copied: branches/avidemux_2.5_branch_mean/avidemux/ADM_core/src/ADM_memory.cpp (from rev 3800, branches/avidemux_2.5_branch_mean/avidemux/ADM_osSupport/ADM_memory.cpp)
===================================================================
--- branches/avidemux_2.5_branch_mean/avidemux/ADM_osSupport/ADM_memory.cpp	2008-02-24 17:29:52 UTC (rev 3800)
+++ branches/avidemux_2.5_branch_mean/avidemux/ADM_core/src/ADM_memory.cpp	2008-02-27 19:50:36 UTC (rev 3805)
@@ -0,0 +1 @@
+//

Copied: branches/avidemux_2.5_branch_mean/avidemux/ADM_core/src/ADM_memsupport.cpp (from rev 3800, branches/avidemux_2.5_branch_mean/avidemux/ADM_osSupport/ADM_memsupport.cpp)
===================================================================
--- branches/avidemux_2.5_branch_mean/avidemux/ADM_osSupport/ADM_memsupport.cpp	2008-02-24 17:29:52 UTC (rev 3800)
+++ branches/avidemux_2.5_branch_mean/avidemux/ADM_core/src/ADM_memsupport.cpp	2008-02-27 19:50:36 UTC (rev 3805)
@@ -0,0 +1,423 @@
+//
+// C++ Interface: ADM_memsupport
+//
+// Description: 
+//	Wrapper for all memory alloc/dealloc
+//
+//	Ensures 16 byte alignment for all memory allocations on Linux and Windows (to
+//  support PPC and SSE).
+//
+//  Mac OS X is exempt as it automatically ensures 16 byte alignment and overriding
+//  the new/delete operators with custom memory management clashes with Qt4.
+//
+// Author: mean &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>&gt;, (C) 2004
+//
+// Copyright: See COPYING file that comes with this distribution
+//
+//
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include &quot;ADM_default.h&quot;
+
+
+
+#undef memalign
+#undef malloc
+#undef free
+#undef realloc
+
+static uint32_t ADM_consumed = 0;
+static admMutex memAccess(&quot;MemAccess&quot;);
+static int doMemStat = 0;
+
+#if defined(ADM_DEBUG) &amp;&amp; defined(FIND_LEAKS)
+#define _DEBUG_NEW_CALLER_ADDRESS __builtin_return_address(0)
+extern void* operator new(size_t size, const char* file, int line);
+extern void operator delete(void* pointer, const char* file, int line) throw();
+extern size_t getSizeFromPointer(void* ptr);
+#endif
+
+extern &quot;C&quot;
+{
+	void *av_malloc(unsigned int size);
+	void av_free(void *ptr);
+	void *av_realloc(void *ptr, unsigned int size);
+}
+
+void ADM_memStat(void);
+void ADM_memStatInit(void);
+void ADM_memStatEnd(void);
+
+void ADM_memStatInit(void)
+{
+	ADM_consumed = 0;
+	doMemStat = 1;
+}
+
+void ADM_memStatEnd(void)
+{
+	doMemStat = 0;
+}
+
+void ADM_memStat(void)
+{
+	printf(&quot;Global mem stat\n______________\n&quot;);
+	printf(&quot;\tMemory consumed: %lu (MB)\n&quot;, ADM_consumed &gt;&gt; 20);
+}
+
+#if !defined(ADM_DEBUG) || !defined(FIND_LEAKS)
+/**
+    \fn ADM_calloc(size_t nbElm,size_t elSize);
+    \brief Replacement for system Calloc using our memory management
+    \param nbElem : # of elements to allocate
+    \param elSize : Size of one element in bytes
+    \return pointer 
+*/
+void *ADM_calloc(size_t nbElm, size_t elSize)
+{
+	void *out = ADM_alloc(nbElm * elSize);
+	memset(out, 0, nbElm * elSize);
+	return out;
+}
+
+void *ADM_alloc(size_t size)
+{
+#ifdef __APPLE__
+	return malloc(size);
+#else
+	char *c;
+
+	uint64_t l, lorg;
+	uint32_t *backdoor;
+	int dome = doMemStat;
+
+	if(dome)
+		memAccess.lock();
+
+	l = (uint64_t)malloc(size + 32);
+
+	// Get next boundary
+	lorg = l;
+	l = (l + 15) &amp; 0xfffffffffffffff0LL;
+	l += 16;
+	c = (char*)l;
+	backdoor = (uint32_t*)(c - 8);
+	*backdoor = (0xdead &lt;&lt; 16) + l - lorg;
+	backdoor[1] = size;
+
+	if(dome)
+		memAccess.unlock();
+
+	ADM_consumed += size;
+
+	return c;
+#endif
+}
+
+void ADM_dezalloc(void *ptr)
+{
+#ifdef __APPLE__
+	if (!ptr)
+		return;
+
+	free(ptr);
+#else
+	int dome = doMemStat;
+	uint32_t *backdoor;
+	uint32_t size, offset;
+	char *c = (char*)ptr;
+
+	if (!ptr)
+		return;
+
+	backdoor = (uint32_t*)ptr;
+	backdoor -= 2;
+
+	if (*backdoor == 0xbeefbeef)
+	{
+		printf(&quot;Double free gotcha!\n&quot;);
+		ADM_assert(0);
+	}
+
+	ADM_assert(((*backdoor) &gt;&gt; 16) == 0xdead);
+
+	offset = backdoor[0] &amp; 0xffff;
+	size = backdoor[1];
+	*backdoor = 0xbeefbeef; // Scratch sig
+
+	if (dome)
+		memAccess.lock();
+
+	free(c - offset);
+	ADM_consumed -= size;
+
+	if(dome)
+		memAccess.unlock();
+#endif
+}
+
+void *operator new( size_t t)
+{
+	return ADM_alloc(t);
+}
+
+void *operator new[] ( size_t t)
+{
+	return ADM_alloc(t);
+}
+
+void operator delete (void *c)
+{
+	ADM_dezalloc(c);
+}
+
+void operator delete[] (void *c)
+{
+	ADM_dezalloc(c);
+}
+//********************************
+// lavcodec wrapper
+//********************************
+extern &quot;C&quot;
+{
+	void *av_malloc(unsigned int size)
+	{
+ 		return ADM_alloc(size);
+	}
+
+	void av_freep(void *arg)
+	{
+		void **ptr= (void**)arg;
+		av_free(*ptr);
+		*ptr = NULL;
+	}
+
+	void *av_mallocz(unsigned int size)
+	{
+		void *ptr;
+
+		ptr = av_malloc(size);
+
+		if (ptr)
+			memset(ptr, 0, size);
+
+		return ptr;
+	}
+}
+
+char *av_strdup(const char *s)
+{
+    char *ptr;
+    int len;
+
+    len = strlen(s) + 1;
+    ptr = (char *)av_malloc(len);
+
+    if (ptr)
+        memcpy(ptr, s, len);
+
+    return ptr;
+}
+
+/**
+ * av_realloc semantics (same as glibc): if ptr is NULL and size &gt; 0,
+ * identical to malloc(size). If size is zero, it is identical to
+ * free(ptr) and NULL is returned.  
+ */
+void *ADM_realloc(void *ptr, size_t newsize)
+{
+#ifdef __APPLE__
+	if(!ptr)
+		return ADM_alloc(newsize);
+
+	if (!newsize)
+	{
+		ADM_dealloc(ptr);
+		return NULL;
+	}
+
+	return realloc(ptr, newsize);
+#else
+	void *nalloc;
+
+	if(!ptr)
+		return ADM_alloc(newsize);
+
+	if(!newsize) 
+	{    	
+		ADM_dealloc(ptr);
+		return NULL;
+	}
+
+	// now we either shrink them or expand them
+	// in case of shrink, we do nothing
+	// in case of expand we have to copy
+	// Do copy everytime (slower)
+	uint32_t *backdoor;
+	uint32_t size, offset;
+	char *c = (char*)ptr;
+
+	backdoor = (uint32_t*)ptr;
+	backdoor -= 2;
+
+	ADM_assert(((*backdoor) &gt;&gt; 16) == 0xdead);
+
+	offset = backdoor[0] &amp; 0xffff;
+	size = backdoor[1];
+
+	if(size &gt;= newsize) // do nothing
+		return ptr;
+
+	// Allocate a new one
+	nalloc = ADM_alloc(newsize);
+	memcpy(nalloc, ptr, size);
+	ADM_dealloc(ptr);
+
+	return nalloc;
+#endif
+}
+
+void *av_realloc(void *ptr, unsigned int newsize)
+{
+	return ADM_realloc(ptr,newsize);
+}
+
+/* NOTE: ptr = NULL is explicetly allowed */
+void av_free(void *ptr)
+{
+	if(ptr)
+		ADM_dealloc(ptr);  
+}
+
+char *ADM_strdup(const char *in)
+{
+	if(!in)
+		return NULL;
+
+	uint32_t l = strlen(in);
+	char *out;
+
+	out = (char*)ADM_alloc(l + 1);
+	memcpy(out, in, l+1);
+
+	return out;
+}
+
+#else
+
+void *ADM_alloc(size_t size)
+{
+	return operator new(size, (char*)_DEBUG_NEW_CALLER_ADDRESS, 0);
+}
+
+void *ADM_calloc(size_t nbElm,size_t elSize)
+{
+	void *out = operator new(nbElm*elSize, (char*)_DEBUG_NEW_CALLER_ADDRESS, 0);
+
+	memset(out,0,nbElm*elSize);
+	return out;
+}
+
+char *ADM_strdup(const char *in)
+{
+    if(!in)
+		return NULL;
+
+	int size = strlen(in) + 1;
+	char *out = (char *)(operator new(size, (char*)_DEBUG_NEW_CALLER_ADDRESS, 0));
+
+	memcpy(out, in, size);
+
+	return out;
+}
+
+void ADM_dezalloc(void *ptr)
+{
+	operator delete(ptr, (char*)_DEBUG_NEW_CALLER_ADDRESS, 0);
+}
+
+void *ADM_realloc(void *ptr, size_t newsize)
+{
+	void *nalloc;
+    
+    if(!ptr)
+		return operator new(newsize, (char*)_DEBUG_NEW_CALLER_ADDRESS, 0);
+
+    if(!newsize) 
+    {    
+		operator delete(ptr, (char*)_DEBUG_NEW_CALLER_ADDRESS, 0);
+		return NULL;
+    }
+
+	uint32_t size = getSizeFromPointer(ptr);
+
+	if (size &gt;= newsize)
+		return ptr;
+
+	nalloc = operator new(newsize, (char*)_DEBUG_NEW_CALLER_ADDRESS, 0);
+	memcpy(nalloc,ptr,getSizeFromPointer(ptr));
+	operator delete(ptr, (char*)_DEBUG_NEW_CALLER_ADDRESS, 0);
+
+	return nalloc;
+}
+
+extern &quot;C&quot;
+{
+	void *av_malloc(unsigned int size)
+	{
+		return operator new(size, (char*)_DEBUG_NEW_CALLER_ADDRESS, 0);
+	}
+	void av_freep(void *arg)
+	{
+		void **ptr = (void**)arg;
+		av_free(*ptr);
+		*ptr = NULL;
+	}
+
+	void *av_mallocz(unsigned int size)
+	{
+		void *ptr;
+
+		ptr = operator new(size, (char*)_DEBUG_NEW_CALLER_ADDRESS, 0);
+
+		if (ptr)
+			memset(ptr, 0, size);
+
+		return ptr;
+	}
+}
+
+char *av_strdup(const char *s)
+{
+    char *ptr;
+    int len;
+    len = strlen(s) + 1;
+	ptr = (char *)operator new(len, (char*)_DEBUG_NEW_CALLER_ADDRESS, 0);
+
+    if (ptr)
+        memcpy(ptr, s, len);
+
+    return ptr;
+}
+
+void *av_realloc(void *ptr, unsigned int newsize)
+{
+	if(!ptr)
+		return operator new(newsize, (char*)_DEBUG_NEW_CALLER_ADDRESS, 0);
+	else
+		return ADM_realloc(ptr,newsize);
+}
+
+void av_free(void *ptr)
+{
+	if(ptr)
+		operator delete(ptr, (char*)_DEBUG_NEW_CALLER_ADDRESS, 0);
+}
+#endif
+// EOF

Copied: branches/avidemux_2.5_branch_mean/avidemux/ADM_core/src/ADM_misc.cpp (from rev 3800, branches/avidemux_2.5_branch_mean/avidemux/ADM_osSupport/ADM_misc.cpp)
===================================================================
--- branches/avidemux_2.5_branch_mean/avidemux/ADM_osSupport/ADM_misc.cpp	2008-02-24 17:29:52 UTC (rev 3800)
+++ branches/avidemux_2.5_branch_mean/avidemux/ADM_core/src/ADM_misc.cpp	2008-02-27 19:50:36 UTC (rev 3805)
@@ -0,0 +1,307 @@
+/***************************************************************************
+                          toolkit.cpp  -  description
+                             -------------------
+
+
+
+    begin                : Fri Dec 14 2001
+    copyright            : (C) 2001 by mean
+    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include &quot;config.h&quot;
+#include &lt;stdio.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;time.h&gt;
+#include &lt;math.h&gt;
+#include &lt;string.h&gt;
+#ifndef ADM_WIN32
+#include &lt;unistd.h&gt;
+#endif
+//#include &lt;gtk/gtk.h&gt;
+#include &lt;ctype.h&gt;
+#include &lt;sys/time.h&gt;
+
+#include &quot;ADM_default.h&quot;
+#include &quot;ADM_assert.h&quot;
+
+#include &quot;ADM_video/ADM_vidMisc.h&quot;
+
+//
+//    Sleep for n ms
+//
+void GUI_Sleep(uint32_t ms)
+{
+    if (ms &lt; 10)
+	return;
+    ADM_usleep(ms*1000);
+}
+
+
+// Get tick (in ms)
+// Call with a 0 to initialize
+// Call with a 1 to read
+//_____________________
+uint32_t getTime(int called)
+{
+
+    static struct timeval timev_s;
+
+    static struct timeval timev;
+    static TIMZ timez;
+
+    int32_t tt;
+
+    if (!called)
+      {
+	  called = 1;
+	  gettimeofday(&amp;timev_s, &amp;timez);
+	  return 0;
+      }
+    gettimeofday(&amp;timev, &amp;timez);
+    tt = timev.tv_usec - timev_s.tv_usec;
+    tt /= 1000;
+    tt += 1000 * (timev.tv_sec - timev_s.tv_sec);
+    return (tt);
+}
+uint32_t getTimeOfTheDay(void)
+{
+  
+
+     struct timeval timev;
+     TIMZ timez;
+
+    int32_t tt;
+
+   
+    gettimeofday(&amp;timev, &amp;timez);
+    tt = timev.tv_usec;
+    tt /= 1000;
+    tt += 1000 * (timev.tv_sec);
+    return (tt&amp;0xffffff);
+
+}
+/// convert frame number and fps to hour/mn/sec/ms
+void  frame2time(	uint32_t frame, uint32_t fps, uint16_t * hh, uint16_t * mm,
+                                uint16_t * ss, uint16_t * ms)
+{
+    UNUSED_ARG(fps);
+double d;
+    uint32_t len2;
+    d=frame;
+    d=d/fps;
+    d*=1000000.;
+    
+    len2 = (uint32_t)(d); //video_body-&gt;getTime(frame);
+    ms2time(len2,hh,mm,ss,ms);
+}
+
+void ms2time(uint32_t len2,uint16_t * hh, uint16_t * mm,
+	 			uint16_t * ss, uint16_t * ms)
+{
+    *hh = (uint32_t) floor(len2 / (3600.F * 1000.F));
+    len2 -= (uint32_t) floor(*hh * 3600.F * 1000.F);
+    *mm = (uint32_t) floor(len2 / (60.F * 1000.F));
+    len2 -= (uint32_t) floor(*mm * 60.F * 1000.F);
+    *ss = (uint32_t) floor(len2 / (1000.F));
+    len2 -= (uint32_t) floor((*ss * 1000.F));
+    *ms = (uint32_t) floor(len2);
+
+}
+void            time2frame(uint32_t *frame, uint32_t fps, uint32_t hh, uint32_t mm,
+                                uint32_t ss, uint32_t ms)
+{
+// convert everything to ms : uint32_t = 1000 hours, should be plenty enough
+uint32_t count=0;
+                count+=ms;
+                count+=ss*1000;
+                count+=mm*60*1000;
+                count+=hh*3600*1000;
+double d;
+                d=count;                
+                // ms
+                d=d*fps;
+                d/=1000;
+                d/=1000;
+                *frame= (uint32_t)(floor(d+0.5));
+
+}
+
+uint64_t ADM_swap64(uint64_t in)
+{
+uint32_t low,high;
+uint64_t out;
+        high=in&gt;&gt;32;
+        low=in&amp;0xffffffff;
+        high=ADM_swap32(high);
+        low=ADM_swap32(low);
+        out=low;
+        out=(out&lt;&lt;32)+high;
+        return out;
+  
+}
+// swap BE/LE : Ugly
+uint32_t ADM_swap32( uint32_t in)
+{
+        uint8_t r[4],u;
+        memcpy(&amp;r[0],&amp;in,4);
+        u=r[0];
+        r[0]=r[3];
+        r[3]=u;
+        u=r[1];
+        r[1]=r[2];
+        r[2]=u;
+        memcpy(&amp;in,&amp;r[0],4);
+        return in;
+}
+// swap BE/LE : Ugly
+uint16_t ADM_swap16( uint16_t in)
+{
+	return ( (in&gt;&gt;8) &amp; 0xff) + ( (in&amp;0xff)&lt;&lt;8);
+}
+uint8_t 	identMovieType(uint32_t fps1000)
+{
+#define INRANGE(value,type)  \
+      {\
+              if((fps1000 &gt; value-300) &amp;&amp;( fps1000 &lt; value+300))\
+              {\
+                r=type;\
+                printf(&quot;Looks like &quot;#type&quot; \n&quot;);\
+                }\
+      }
+      uint8_t r=0;
+      INRANGE(25000,FRAME_PAL);
+      INRANGE(23976,FRAME_FILM);
+      INRANGE(29970,FRAME_NTSC);
+
+      return r;
+}
+uint8_t ms2time(uint32_t ms, uint32_t *h,uint32_t *m, uint32_t *s)
+{
+      uint32_t sectogo;
+      int  mm,ss,hh;
+
+
+                              // d is in ms, divide by 1000 to get seconds
+                              sectogo = (uint32_t) floor(ms / 1000.);
+                              hh=sectogo/3600;
+                              sectogo=sectogo-hh*3600;
+                              mm=sectogo/60;
+                              ss=sectogo%60;
+
+                              *h=hh;
+                              *m=mm;
+                              *s=ss;
+      return 1;
+}
+
+char* ms2timedisplay(uint32_t ms)
+{
+	uint32_t mm, ss;
+	static char string[20];
+
+	mm = (uint32_t)floor(ms / 60000.);
+	
+	if (mm &gt; 1)
+	{
+		sprintf(string, QT_TR_NOOP(&quot;%lu minutes&quot;), mm);
+	}
+	else if (mm == 1)
+	{
+		sprintf(string, QT_TR_NOOP(&quot;%lu minute&quot;), mm);
+	}
+	else
+	{
+		ss = (uint32_t)floor(ms / 1000.);
+
+		if (ss == 1)
+		{
+			sprintf(string, QT_TR_NOOP(&quot;%lu second&quot;), ss);
+		}
+		else
+		{
+			sprintf(string, QT_TR_NOOP(&quot;%lu seconds&quot;), ss);
+		}
+	}
+
+	return string;
+}
+
+// Convert everything to lowercase
+void  LowerCase(char *string)
+{
+  int l=strlen(string)-1;
+        for(int i=l;i&gt;=0;i--)
+        {
+                string[i]=tolower(string[i]);
+        }
+
+}
+
+uint8_t         ADM_fileExist(char *name)
+{
+FILE *file;
+                file=fopen(name,&quot;rb&quot;);
+                if(!file) return 0;
+                fclose(file);
+                return 1;
+
+}
+/*
+    In some case (e.g. javascript), the reader expects unixish path 
+    c:/foo/bar/c.c
+    and the &quot;natural&quot; path is c:\foo\bar
+    
+    This function convert the later to the former
+
+*/
+extern char *slashToBackSlash(char *in)
+{
+    char *out,*cout;
+    int n;
+    n=strlen(in);
+    cout=out=(char *)ADM_alloc(n+1);   
+    for(int i=0;i&lt;n+1;i++)
+    {
+        if(   in[i]=='\\') out[i]='/';
+        else    out[i]=in[i];
+        
+    }
+    return cout;
+    
+}
+/*
+    
+*/
+void TLK_getDate(ADM_date *date)
+{
+  time_t timez;
+  tm *t;
+  time(&amp;timez);
+  t=localtime(&amp;timez);
+  if(t)
+  {
+    date-&gt;hours=t-&gt;tm_hour;
+    date-&gt;minutes=t-&gt;tm_min;
+    date-&gt;seconds=t-&gt;tm_sec;
+  }
+  
+}
+
+bool shutdown(void)
+{
+#ifdef ADM_WIN32
+	return (shutdown_win32() == 0);
+#else
+	return (system(&quot;shutdown -P 0&quot;) == 0);
+#endif
+}
+//EOF

Copied: branches/avidemux_2.5_branch_mean/avidemux/ADM_core/src/ADM_threads.cpp (from rev 3800, branches/avidemux_2.5_branch_mean/avidemux/ADM_osSupport/ADM_threads.cpp)
===================================================================
--- branches/avidemux_2.5_branch_mean/avidemux/ADM_osSupport/ADM_threads.cpp	2008-02-24 17:29:52 UTC (rev 3800)
+++ branches/avidemux_2.5_branch_mean/avidemux/ADM_core/src/ADM_threads.cpp	2008-02-27 19:50:36 UTC (rev 3805)
@@ -0,0 +1,98 @@
+/***************************************************************************
+                    
+    copyright            : (C) 2006 by mean
+    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include &quot;config.h&quot;
+ 
+#include &lt;stdio.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;string.h&gt;
+#include &lt;ADM_assert.h&gt;
+#include &quot;ADM_default.h&quot;
+
+
+
+#define THR_CHECK(x) {int r=(x);if(r) {printf(&quot;Threading error :%d %s\n&quot;, \
+                      r,strerror(r));exit(0);}}
+//**************** Mutex *******************
+admMutex::admMutex(const char *name)
+{
+  _name=name; // Should always be const, so it is okay to not copy
+  THR_CHECK(pthread_mutex_init(&amp;_tex,NULL));
+  _locked=0;
+}
+admMutex::~admMutex()
+{
+  THR_CHECK(pthread_mutex_destroy(&amp;_tex));
+       
+}
+
+uint8_t admMutex::lock(void)
+{
+  int e;
+  THR_CHECK(pthread_mutex_lock(&amp;_tex));
+  _locked=1;
+  return 1;
+}
+uint8_t admMutex::unlock(void)
+{
+  _locked=0;      // Just informative, race possible here
+  THR_CHECK(pthread_mutex_unlock(&amp;_tex));
+  return 1;
+}
+uint8_t admMutex::isLocked(void)
+{
+  return _locked;
+}
+
+//**************** Cond *******************
+
+admCond::admCond( admMutex *tex )
+{
+  THR_CHECK(pthread_cond_init(&amp;_cond,NULL));
+  _condtex=tex;
+  waiting=0;
+  aborted=0;
+}
+admCond::~admCond()
+{
+  THR_CHECK(pthread_cond_destroy(&amp;_cond));
+
+}
+uint8_t admCond::wait(void)
+{
+  if(aborted) return 0;
+        // take sem
+  ADM_assert(_condtex-&gt;isLocked());
+  waiting=1;
+  THR_CHECK(pthread_cond_wait(&amp;_cond, &amp;(_condtex-&gt;_tex)));
+  waiting=0;
+  _condtex-&gt;unlock();
+  return 1;
+}
+uint8_t admCond::wakeup(void)
+{
+  THR_CHECK(pthread_cond_signal(&amp;_cond));
+  return 1;
+}
+uint8_t admCond::iswaiting( void)
+{
+  return waiting;
+}
+uint8_t admCond::abort( void )
+{
+  aborted=1;
+  if(waiting) wakeup();
+  return 1;
+
+}

Copied: branches/avidemux_2.5_branch_mean/avidemux/ADM_core/src/ADM_win32.cpp (from rev 3800, branches/avidemux_2.5_branch_mean/avidemux/ADM_osSupport/win32.cpp)
===================================================================
--- branches/avidemux_2.5_branch_mean/avidemux/ADM_osSupport/win32.cpp	2008-02-24 17:29:52 UTC (rev 3800)
+++ branches/avidemux_2.5_branch_mean/avidemux/ADM_core/src/ADM_win32.cpp	2008-02-27 19:50:36 UTC (rev 3805)
@@ -0,0 +1,485 @@
+#include &quot;config.h&quot;
+
+#ifdef ADM_WIN32
+#define WIN32_CLASH
+#include &lt;stdio.h&gt;
+#include &lt;stdlib.h&gt;
+
+#include &quot;ADM_default.h&quot;
+
+#include &quot;windows.h&quot;
+#include &quot;io.h&quot;
+#include &quot;winsock2.h&quot;
+#include &quot;ADM_assert.h&quot; 
+
+uint8_t win32_netInit(void);
+extern char *ADM_getBaseDir(void);
+
+void ADM_usleep(unsigned long us)
+{
+	Sleep(us/1000);
+}
+
+uint8_t win32_netInit(void)
+{
+WSADATA wsaData;
+	int iResult;
+		printf(&quot;Initializing WinSock\n&quot;);
+		iResult = WSAStartup(MAKEWORD(2,2), &amp;wsaData);
+		if (iResult != NO_ERROR)
+		{
+			printf(&quot;Error at WSAStartup()\n&quot;);
+			return 0;
+		}	
+		printf(&quot;WinSock ok\n&quot;);
+		return 1;
+}
+
+#ifndef HAVE_GETTIMEOFDAY
+extern &quot;C&quot;
+{
+void gettimeofday(struct timeval *p, void *tz);
+}
+
+void gettimeofday(struct timeval *p, void *tz)
+{
+    unsigned long int sec;
+    SYSTEMTIME  tme;
+
+    GetSystemTime(&amp;tme);
+
+    sec=tme.wSecond;
+    sec+=60*tme.wMinute;
+    sec+=60*60*tme.wHour;
+    
+	p-&gt;tv_sec=sec;
+	p-&gt;tv_usec=tme.wMilliseconds*1000;
+
+	return;
+}
+#endif
+
+int getpriority(int which, int who)
+{
+	unsigned int priorityClass;
+
+	ADM_assert(which == PRIO_PROCESS);
+	ADM_assert(who == 0);
+
+	priorityClass = GetPriorityClass(GetCurrentProcess());
+
+	switch (priorityClass)
+	{
+		case HIGH_PRIORITY_CLASS:
+			return -18;
+			break;
+		case ABOVE_NORMAL_PRIORITY_CLASS:
+			return -10;
+			break;
+		case NORMAL_PRIORITY_CLASS:
+			return 0;
+			break;
+		case BELOW_NORMAL_PRIORITY_CLASS:
+			return 10;
+			break;
+		case IDLE_PRIORITY_CLASS:
+			return 18;
+			break;
+		default:
+			ADM_assert(0);
+	}
+}
+
+int setpriority(int which, int who, int value)
+{
+	unsigned int priorityClass;
+
+	ADM_assert(which == PRIO_PROCESS);
+	ADM_assert(who == 0);
+	ADM_assert(value &gt;= PRIO_MIN &amp;&amp; value &lt;= PRIO_MAX);
+
+	if (value &gt;= -20 &amp;&amp; value &lt;= -16)
+	{
+		priorityClass = HIGH_PRIORITY_CLASS;
+	}
+	else if (value &gt;= -15 &amp;&amp; value &lt;= -6)
+	{
+		priorityClass = ABOVE_NORMAL_PRIORITY_CLASS;
+	}
+	else if (value &gt;= -5 &amp;&amp; value &lt;= 4)
+	{
+		priorityClass = NORMAL_PRIORITY_CLASS;
+	}
+	else if (value &gt;= 6 &amp;&amp; value &lt;= 15)
+	{
+		priorityClass = BELOW_NORMAL_PRIORITY_CLASS;
+	}
+	else if (value &gt;= 16 &amp;&amp; value &lt;= 20)
+	{
+		priorityClass = IDLE_PRIORITY_CLASS;
+	}
+
+	if (!SetPriorityClass(GetCurrentProcess(), priorityClass))
+	{
+		return -1;
+	}
+
+	return 0;
+}
+
+int shutdown_win32(void)
+{
+	HANDLE hToken;
+	TOKEN_PRIVILEGES tkp;
+
+	// Get a token for this process. 
+	if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &amp;hToken))
+	{
+		return -1;
+	}
+
+	// Get the LUID for the shutdown privilege.
+	LookupPrivilegeValue(NULL, SE_SHUTDOWN_NAME, &amp;tkp.Privileges[0].Luid);
+
+	tkp.PrivilegeCount = 1;  // one privilege to set
+	tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
+
+	// Get the shutdown privilege for this process.
+	AdjustTokenPrivileges(hToken, FALSE, &amp;tkp, 0, (PTOKEN_PRIVILEGES)NULL, 0);
+
+	if (GetLastError() != ERROR_SUCCESS)
+	{
+		return -1;
+	}
+
+	// Shut down the system and force all applications to close.
+	if (!ExitWindowsEx(EWX_POWEROFF | EWX_FORCE, SHTDN_REASON_FLAG_PLANNED))
+	{
+		return -1;
+	}
+
+	return 0;
+}
+
+#ifndef PRODUCT_BUSINESS
+#define PRODUCT_BUSINESS 0x00000006
+#endif
+
+#ifndef PRODUCT_BUSINESS_N
+#define PRODUCT_BUSINESS_N 0x00000010
+#endif
+
+#ifndef PRODUCT_HOME_BASIC
+#define PRODUCT_HOME_BASIC 0x00000002
+#endif
+
+#ifndef PRODUCT_HOME_BASIC_N
+#define PRODUCT_HOME_BASIC_N 0x00000005
+#endif
+
+#ifndef PRODUCT_HOME_PREMIUM
+#define PRODUCT_HOME_PREMIUM 0x00000003
+#endif 
+
+#ifndef PRODUCT_STARTER
+#define PRODUCT_STARTER 0x0000000B
+#endif
+
+#ifndef PRODUCT_ENTERPRISE
+#define PRODUCT_ENTERPRISE 0x00000004
+#endif 
+
+#ifndef PRODUCT_ULTIMATE
+#define PRODUCT_ULTIMATE 0x00000001
+#endif
+
+bool getWindowsVersion(char* version)
+{
+	int index = 0;
+	OSVERSIONINFOEX osvi = {};
+
+	osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
+
+	if (!GetVersionEx((OSVERSIONINFO*)&amp;osvi))
+		return false;
+
+	if (osvi.dwPlatformId != VER_PLATFORM_WIN32_NT)
+		return false;
+// Vista
+	if (osvi.dwMajorVersion == 6 &amp;&amp; osvi.dwMinorVersion == 0)
+	{
+		if (osvi.wProductType == VER_NT_WORKSTATION)
+		{
+			index += sprintf(version + index, &quot;Microsoft Windows Vista&quot;);
+
+			uint32_t productType = 0;
+
+			HMODULE hKernel = GetModuleHandle(&quot;KERNEL32.DLL&quot;);
+
+			if (hKernel)
+			{
+				typedef bool (*funcGetProductInfo)(uint32_t, uint32_t, uint32_t, uint32_t, uint32_t*);
+				funcGetProductInfo pGetProductInfo = (funcGetProductInfo)GetProcAddress(hKernel, &quot;GetProductInfo&quot;); 
+
+				if (pGetProductInfo)
+					pGetProductInfo(6, 0, 0, 0, &amp;productType);
+	  
+				switch (productType)
+				{
+				case PRODUCT_STARTER:
+				{
+					index += sprintf(version + index, &quot; Starter&quot;);
+					break;
+				}
+				case PRODUCT_HOME_BASIC_N:
+				{
+					index += sprintf(version + index, &quot; Home Basic N&quot;);
+					break;
+				}
+				case PRODUCT_HOME_BASIC:
+				{
+					index += sprintf(version + index, &quot; Home Basic&quot;);
+					break;
+				}
+				case PRODUCT_HOME_PREMIUM:
+				{
+					index += sprintf(version + index, &quot; Home Premium&quot;);
+					break;
+				}
+				case PRODUCT_BUSINESS_N:
+				{
+					index += sprintf(version + index, &quot; Business N&quot;);
+					break;
+				}
+				case PRODUCT_BUSINESS:
+				{
+					index += sprintf(version + index, &quot; Business&quot;);
+					break;
+				}
+				case PRODUCT_ENTERPRISE:
+				{
+					index += sprintf(version + index, &quot; Enterprise&quot;);
+					break;
+				}
+				case PRODUCT_ULTIMATE:
+				{
+					index += sprintf(version + index, &quot; Ultimate&quot;);
+					break;
+				}
+				default:
+					break;
+				}
+			}
+		}
+		else if (osvi.wProductType == VER_NT_SERVER)
+		{
+			index += sprintf(version + index, &quot;Microsoft Windows Server 2008&quot;);
+
+			if (osvi.wSuiteMask &amp; VER_SUITE_DATACENTER)
+				index += sprintf(version + index, &quot; Datacenter Edition&quot;);
+			else if (osvi.wSuiteMask &amp; VER_SUITE_ENTERPRISE)
+				index += sprintf(version + index, &quot; Enterprise Edition&quot;);
+			else if (osvi.wSuiteMask == VER_SUITE_BLADE)
+				index += sprintf(version + index, &quot; Web Edition&quot;);
+			else
+				index += sprintf(version + index, &quot; Standard Edition&quot;);
+		}
+	}
+// Windows Server 2003
+	else if (osvi.dwMajorVersion == 5 &amp;&amp; osvi.dwMinorVersion == 2)
+	{
+		index += sprintf(version + index, &quot;Microsoft Windows Server 2003&quot;);
+
+		if (GetSystemMetrics(SM_SERVERR2))
+			index += sprintf(version + index, &quot; R2&quot;);
+
+		if (osvi.wSuiteMask &amp; VER_SUITE_DATACENTER)
+			index += sprintf(version + index, &quot; Datacenter Edition&quot;);
+		else if (osvi.wSuiteMask &amp; VER_SUITE_ENTERPRISE)
+			index += sprintf(version + index, &quot; Enterprise Edition&quot;);
+		else if (osvi.wSuiteMask == VER_SUITE_BLADE)
+			index += sprintf(version + index, &quot; Web Edition&quot;);
+		else
+			index += sprintf(version + index, &quot; Standard Edition&quot;);
+	}
+// Windows XP
+	else if (osvi.dwMajorVersion == 5 &amp;&amp; osvi.dwMinorVersion == 1)
+	{
+		index += sprintf(version + index, &quot;Microsoft Windows XP&quot;);
+
+		if (GetSystemMetrics(SM_MEDIACENTER))
+			index += sprintf(version + index, &quot; Media Center Edition&quot;);
+		else if (GetSystemMetrics(SM_STARTER))
+			index += sprintf(version + index, &quot; Starter Edition&quot;);
+		else if (GetSystemMetrics(SM_TABLETPC))
+			index += sprintf(version + index, &quot; Tablet PC Edition&quot;);
+		else if (osvi.wSuiteMask &amp; VER_SUITE_PERSONAL)
+			index += sprintf(version + index, &quot; Home Edition&quot;);
+		else
+			index += sprintf(version + index, &quot; Professional&quot;);
+	}
+// Windows 2000
+	else if (osvi.dwMajorVersion == 5 &amp;&amp; osvi.dwMinorVersion == 0)
+	{
+		index += sprintf(version + index, &quot;Microsoft Windows 2000&quot;);
+
+		if (osvi.wProductType == VER_NT_WORKSTATION)
+		{
+			index += sprintf(version + index, &quot; Professional&quot;);
+		}
+		else if (osvi.wProductType == VER_NT_SERVER)
+		{
+			if (osvi.wSuiteMask &amp; VER_SUITE_DATACENTER)
+				index += sprintf(version + index, &quot; Datacenter Server&quot;);
+			else if (osvi.wSuiteMask &amp; VER_SUITE_ENTERPRISE)
+				index += sprintf(version + index, &quot; Advanced Server&quot;);
+			else
+				index += sprintf(version + index, &quot; Server&quot;);
+		}
+	}
+// Windows NT 4
+	else if (osvi.dwMajorVersion == 4)
+	{
+		index += sprintf(version + index, &quot;Microsoft Windows NT 4&quot;);
+
+		if (osvi.wProductType == VER_NT_WORKSTATION)
+		{
+			index += sprintf(version + index, &quot; Workstation&quot;);
+		}
+		else if (osvi.wProductType == VER_NT_SERVER)
+		{
+			if (osvi.wSuiteMask &amp; VER_SUITE_ENTERPRISE)
+				index += sprintf(version + index, &quot; Server, Enterprise Edition&quot;);
+			else
+				index += sprintf(version + index, &quot; Server&quot;);
+		}
+	}
+	else
+	{
+		index += sprintf(version + index, &quot;Microsoft Windows&quot;);
+	}
+
+// Service pack and full version info
+	if (strlen(osvi.szCSDVersion) &gt; 0)
+	{
+		index += sprintf(version + index, &quot; %s&quot;, osvi.szCSDVersion);
+	}
+
+	index += sprintf(version + index, &quot; (%d.%d.%d&quot;, osvi.dwMajorVersion, osvi.dwMinorVersion, osvi.dwBuildNumber &amp; 0xFFFF);
+
+// 64-bit Windows
+	bool isWow64 = false;
+	HMODULE hKernel = GetModuleHandle(&quot;kernel32.dll&quot;);
+
+	if (hKernel)
+	{
+		typedef bool (*funcIsWow64Process)(void*, bool*);  
+
+	    funcIsWow64Process pIsWow64Process = (funcIsWow64Process)GetProcAddress(hKernel, &quot;IsWow64Process&quot;); 
+
+	    if (pIsWow64Process)
+	    {
+			pIsWow64Process(GetCurrentProcess(), &amp;isWow64);
+		}
+	}
+
+	if (isWow64)
+		index += sprintf(version + index, &quot;; 64-bit&quot;);
+	else
+		index += sprintf(version + index, &quot;; 32-bit&quot;);
+
+	index += sprintf(version + index, &quot;)&quot;);
+	
+	return true;
+}
+
+#define MONITOR_DEFAULTTONEAREST    0x00000002
+
+void getWorkingArea(uint32_t *width, uint32_t *height)
+{
+	typedef void* (WINAPI *MonitorFromWindow)(HWND hwnd, uint32_t dwFlags);
+	typedef bool (WINAPI *GetMonitorInfo)(void *hMonitor, LPMONITORINFO lpmi);
+
+	static HMODULE user32 = GetModuleHandle(&quot;user32.dll&quot;);
+	static MonitorFromWindow pMonitorFromWindow = (MonitorFromWindow)GetProcAddress(user32, &quot;MonitorFromWindow&quot;);
+	static GetMonitorInfo pGetMonitorInfo = (GetMonitorInfo)GetProcAddress(user32, &quot;GetMonitorInfoA&quot;);
+
+	if (pMonitorFromWindow == NULL)
+	{
+		RECT rect;
+
+		// Required for NT4 - no multi-monitor support
+		SystemParametersInfo(SPI_GETWORKAREA, 0, &amp;rect, 0);
+
+		*width = rect.right - rect.left;
+		*height = rect.bottom - rect.top;
+	}
+	else
+	{
+		void *hMonitor = pMonitorFromWindow(GetForegroundWindow(), MONITOR_DEFAULTTONEAREST);
+
+		MONITORINFO monitorInfo;
+
+		monitorInfo.cbSize = sizeof(MONITORINFO);
+		pGetMonitorInfo(hMonitor, &amp;monitorInfo);
+
+		*width = monitorInfo.rcWork.right - monitorInfo.rcWork.left;
+		*height = monitorInfo.rcWork.bottom - monitorInfo.rcWork.top;
+	}
+}
+
+void redirectStdoutToFile(void)
+{
+	// Don't redirect stdout and stderr if SDL hasn't already hijacked it.
+	// This allows us to optionally compile all EXEs as console applications
+	// so the output can be printed to the terminal for debugging purposes.
+
+#ifdef USE_SDL
+	// Close SDL generated logs
+	fclose(stdout);
+	fclose(stderr);
+
+	// Briefly redirect to console
+	freopen(&quot;CON&quot;, &quot;w&quot;, stdout);
+	freopen(&quot;CON&quot;, &quot;w&quot;, stderr);
+
+	// Remove SDL logs to avoid confusion
+	char path[MAX_PATH];
+	char stdoutPath[MAX_PATH];
+	char stderrPath[MAX_PATH];
+	DWORD pathlen = GetModuleFileName(NULL, path, MAX_PATH);
+
+	while (pathlen &gt; 0 &amp;&amp; path[pathlen] != '\\')
+		pathlen--;
+
+	path[pathlen] = '\0';
+
+	strcpy(stdoutPath, path);
+	strcat(stdoutPath, &quot;\\stdout.txt&quot;);
+	strcpy(stderrPath, path);
+	strcat(stderrPath, &quot;\\stderr.txt&quot;);
+
+	remove(stdoutPath);
+	remove(stderrPath);
+
+	// Redirect output to log file in the user's profile directory
+	const char* logFile = &quot;admlog.txt&quot;;
+	char* baseDir = ADM_getBaseDir();
+	char *logPath = new char[strlen(baseDir) + 2 + strlen(logFile)];
+	FILE* stream;
+
+	strcpy(logPath, baseDir);
+	strcat(logPath, &quot;/&quot;);
+	strcat(logPath, logFile);
+
+	stream = freopen(logPath, &quot;w&quot;, stdout);
+	*stderr = *stream;
+
+	// Line buffering
+	setvbuf(stdout, NULL, _IOLBF, BUFSIZ); 
+	setvbuf(stderr, NULL, _IOLBF, BUFSIZ);
+
+	delete[] logPath;
+#endif
+}
+#endif

Copied: branches/avidemux_2.5_branch_mean/avidemux/ADM_core/src/TLK_clock.cpp (from rev 3800, branches/avidemux_2.5_branch_mean/avidemux/ADM_osSupport/TLK_clock.cpp)
===================================================================
--- branches/avidemux_2.5_branch_mean/avidemux/ADM_osSupport/TLK_clock.cpp	2008-02-24 17:29:52 UTC (rev 3800)
+++ branches/avidemux_2.5_branch_mean/avidemux/ADM_core/src/TLK_clock.cpp	2008-02-27 19:50:36 UTC (rev 3805)
@@ -0,0 +1,107 @@
+/***************************************************************************
+                          TLK_clock.cpp  -  description
+                             -------------------
+	Handle a simple clock/timer class
+
+	The API used returns the amound of days/hour/minute/seconds since
+		1st Jan 1970
+	As we only use part of the information (seconds and useconds) it
+	may wrap around anytime
+
+	The first time a clock is created, we store the &quot;now date&quot; and
+	do the computation with getTime-&quot;now date&quot;
+	It will wrap after 25 days, so it can be considerate safe
+
+
+    begin                : Fri Apr 20 2003
+    copyright            : (C) 2003 by mean
+    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include &lt;stdio.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;time.h&gt;
+#include &lt;math.h&gt;
+#include &lt;unistd.h&gt;
+#include &lt;sys/time.h&gt;
+
+#include &quot;config.h&quot;
+
+#include &quot;ADM_osSupport/ADM_debugID.h&quot;
+#define MODULE_NAME MODULE_CLOCKnTIMELEFT
+#include &quot;ADM_osSupport/ADM_debug.h&quot;
+
+#include &quot;avi_vars.h&quot;
+
+
+
+static uint8_t inited=0;
+static struct timeval _itimev;
+static uint32_t getAbsTime( void );
+
+#ifndef ADM_WIN32
+#include &quot;unistd.h&quot;
+void ADM_usleep(unsigned long us)
+{
+  usleep(us);
+}
+#endif
+
+Clock::Clock( void )
+{
+	reset();
+}
+Clock::~Clock(  )
+{
+
+}
+uint32_t Clock::getElapsedMS(void )
+{
+   uint32_t ret = getAbsTime()-_startTime;
+	aprintf(&quot;Clock::getElapsedMS() -&gt; %lu\n&quot;, ret);
+	return ret;
+}
+
+/** Note:
+*** * gettimeofday() returns seconds since 1.1.1970 in param1.tv_sec
+*** * because we need a AbsTime with milliseconds for benchmarking we have:
+***   max 0x7Fffffff (int32_t casted to uint32_t)
+***    =&gt; 2147483647 msec =&gt; 2147483 sec =&gt; Sun Jan 25 21:31:23 1970
+***   the return value will wrap all 25 days
+*** * workaround:
+***   1) start with an AbsTime of zero if object Clock() is created
+***   2) finish your work within 25 days ;-)
+**/
+uint32_t getAbsTime( void )
+{
+     struct timeval timev;     
+     TIMZ timez;
+
+    int32_t tt;
+
+    if(!inited)
+    {
+	gettimeofday(&amp;_itimev, &amp;timez);
+	inited=1;
+    }
+
+    gettimeofday(&amp;timev, &amp;timez);
+    tt = timev.tv_usec;
+    tt /= 1000;
+    tt += 1000 * (timev.tv_sec-_itimev.tv_sec);
+    aprintf(&quot;getAbsTime() -&gt; %lu\n&quot;, tt&amp;0x7Fffffff);
+    return (tt&amp;0x7Fffffff);
+
+}
+uint8_t Clock::reset(void)
+{
+	_startTime=getAbsTime();
+}

Deleted: branches/avidemux_2.5_branch_mean/avidemux/ADM_osSupport/ADM_cpuCap.cpp
===================================================================
--- branches/avidemux_2.5_branch_mean/avidemux/ADM_osSupport/ADM_cpuCap.cpp	2008-02-26 21:54:51 UTC (rev 3804)
+++ branches/avidemux_2.5_branch_mean/avidemux/ADM_osSupport/ADM_cpuCap.cpp	2008-02-27 19:50:36 UTC (rev 3805)
@@ -1,213 +0,0 @@
-//
-// C++ Implementation: ADM_cpuCap
-//
-// Description: 
-//
-//
-// Author: mean &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>&gt;, (C) 2004
-//
-// Copyright: See COPYING file that comes with this distribution
-//
-//
-#include &quot;config.h&quot;
-#include &lt;stdio.h&gt;
-
-#if defined(ADM_WIN32)
-#include &lt;pthread.h&gt;
-#elif !defined(__APPLE__) &amp;&amp; !defined(ADM_BSD_FAMILY)
-#include &lt;string.h&gt;
-#include &lt;sched.h&gt;
-#endif
-
-#include &quot;ADM_default.h&quot;
-
-
-#include &quot;prefs.h&quot;
-
-/* Cpu caps interface to other libs */
-extern &quot;C&quot;{ 
-	int ADM_lavcodec_mm_support(void);
-	int ADM_mpeg2dec_mm_support(void);
-	
-}
-
-
-#if defined(ARCH_X86) || defined(ARCH_X86_64)
-extern &quot;C&quot; 
-{
-#include &quot;ADM_lavcodec/dsputil_cpu.h&quot;
-}
-#endif
-
-#define cpuid(index,eax,ebx,ecx,edx)\
-    __asm __volatile\
-        (&quot;mov %%&quot;REG_b&quot;, %%&quot;REG_S&quot;\n\t&quot;\
-         &quot;cpuid\n\t&quot;\
-         &quot;xchg %%&quot;REG_b&quot;, %%&quot;REG_S\
-         : &quot;=a&quot; (eax), &quot;=S&quot; (ebx),\
-           &quot;=c&quot; (ecx), &quot;=d&quot; (edx)\
-         : &quot;0&quot; (index));
-
-
-/**
- * 		\fn CpuCaps::init
- * 		\brief Detect the SIM capabilities of CPU, borrowed from lavcodec
- */
-  void 	CpuCaps::init( void)
-{
-	printf(&quot;[cpuCaps]Checking CPU capabilities\n&quot;);
-	myCpuCaps=0;
-	myCpuMask=0xffffffff;
-	prefs-&gt;get(FEATURE_CPU_CAPS,&amp;myCpuMask);
-
-#if defined(ARCH_X86) || defined(ARCH_X86_64)
-int rval = 0;
- int eax, ebx, ecx, edx;
- int max_std_level, max_ext_level, std_caps=0, ext_caps=0;
- long a, c;
-
- __asm__ __volatile__ (
-                       /* See if CPUID instruction is supported ... */
-                       /* ... Get copies of EFLAGS into eax and ecx */
-                       &quot;pushf\n\t&quot;
-                       &quot;pop %0\n\t&quot;
-                       &quot;mov %0, %1\n\t&quot;
-
-                       /* ... Toggle the ID bit in one copy and store */
-                       /*     to the EFLAGS reg */
-                       &quot;xor $0x200000, %0\n\t&quot;
-                       &quot;push %0\n\t&quot;
-                       &quot;popf\n\t&quot;
-
-                       /* ... Get the (hopefully modified) EFLAGS */
-                       &quot;pushf\n\t&quot;
-                       &quot;pop %0\n\t&quot;
-                       : &quot;=a&quot; (a), &quot;=c&quot; (c)
-                       :
-                       : &quot;cc&quot;
-                       );
-
- if (a == c)
-     return ; /* CPUID not supported */
-
- cpuid(0, max_std_level, ebx, ecx, edx);
-
- if(max_std_level &gt;= 1)
- {
-     cpuid(1, eax, ebx, ecx, std_caps);
-     if (std_caps &amp; (1&lt;&lt;23))
-    	 myCpuCaps |= ADM_CPU_MMX;
-     if (std_caps &amp; (1&lt;&lt;25))
-    	 myCpuCaps |= ADM_CPU_MMXEXT | ADM_CPU_SSE;
-     if (std_caps &amp; (1&lt;&lt;26))
-    	 myCpuCaps |= ADM_CPU_SSE2;
-     if (ecx &amp; 1)
-    	 myCpuCaps |= ADM_CPU_SSE3;
-     if (ecx &amp; 0x00000200 )
-    	 myCpuCaps |= ADM_CPU_SSSE3;
-     
-     
-     
- }
-
- cpuid(0x80000000, max_ext_level, ebx, ecx, edx);
-
- if(max_ext_level &gt;= 0x80000001)
- {
-     cpuid(0x80000001, eax, ebx, ecx, ext_caps);
-     if (ext_caps &amp; (1&lt;&lt;31))
-    	 myCpuCaps |= ADM_CPU_3DNOW;
-     if (ext_caps &amp; (1&lt;&lt;30))
-    	 myCpuCaps |= ADM_CPU_3DNOWEXT;
-     if (ext_caps &amp; (1&lt;&lt;23))
-    	 myCpuCaps |= ADM_CPU_MMX;
-     if (ext_caps &amp; (1&lt;&lt;22))
-    	 myCpuCaps |= ADM_CPU_MMXEXT;
-     
- }
-#define CHECK(x) if(myCpuCaps &amp; ADM_CPU_##x) { printf(&quot;\t\t&quot;#x&quot; detected &quot;);\
-											if(!(myCpuMask&amp;ADM_CPU_##x)) printf(&quot;  but disabled&quot;);printf(&quot;\n&quot;);}
-	CHECK(MMX);
-	CHECK(3DNOW);
-	CHECK(MMXEXT);
-	CHECK(SSE);
-	CHECK(SSE2);
-	CHECK(SSE3);
-	CHECK(SSSE3);
-
-#endif // X86
-	printf(&quot;[cpuCaps]End of CPU capabilities check (cpuMask :%x)\n&quot;,myCpuMask);
-	return ;
-}
-
-/************************************************************************/
-#if defined(ARCH_X86) || defined(ARCH_X86_64)
-#include &quot;ADM_libraries/ADM_libMpeg2Dec/mpeg2_cpu.h&quot;
-#endif
-
-int ADM_mpeg2dec_mm_support(void)
-{
-int rval=0;
-
-#if defined(ARCH_X86) || defined(ARCH_X86_64)
-#undef MATCH
-#define MATCH(x,y) if(CpuCaps::myCpuCaps &amp; CpuCaps::myCpuMask &amp; ADM_CPU_##x) rval|=MPEG2_ACCEL_X86_##x;
-	
-	MATCH(MMX,MMX);
-	MATCH(MMXEXT,MMXEXT);
-	MATCH(3DNOW,3DNOW);
-#endif
-
-	return rval;
-}
-//******************************************************
-#if defined(ARCH_X86) || defined(ARCH_X86_64)
-#include &quot;ADM_lavcodec.h&quot;
-#endif
-/**
- * 		\fn lavcodec_mm_support
- * 		\brief Give lavcodec CPU supported ( FF_MM_MMX)
- */
-int ADM_lavcodec_mm_support(void)
-{
-int rval=0;
-
-#if defined(ARCH_X86) || defined(ARCH_X86_64)
-#undef MATCH
-#define MATCH(x,y) if(CpuCaps::myCpuCaps &amp;  CpuCaps::myCpuMask &amp; ADM_CPU_##x) rval|=MM_##x;
-
-	MATCH(MMX,MMX);
-	MATCH(MMXEXT,MMXEXT);
-	MATCH(SSE,SSE);
-	MATCH(SSE2,SSE2);
-	MATCH(SSE3,SSE3);
-	MATCH(SSSE3,SSSE3);
-	MATCH(3DNOW,3DNOW);
-	MATCH(3DNOWEXT,3DNOWEXT);
-#endif
-
-	return rval;
-}
-// EOF
-
-// Stolen from x264
-int ADM_cpu_num_processors(void)
-{
-#if defined(ADM_WIN32)
-    return pthread_num_processors_np();
-#elif !defined(__APPLE__) &amp;&amp; !defined(ADM_BSD_FAMILY)
-    unsigned int bit;
-    int np;
-
-    cpu_set_t p_aff;
-    memset( &amp;p_aff, 0, sizeof(p_aff) );
-    sched_getaffinity( 0, sizeof(p_aff), &amp;p_aff );
-
-    for( np = 0, bit = 0; bit &lt; sizeof(p_aff); bit++ )
-        np += (((uint8_t *)&amp;p_aff)[bit / 8] &gt;&gt; (bit % 8)) &amp; 1;
-
-    return np;
-#else
-    return 1;
-#endif
-}

Deleted: branches/avidemux_2.5_branch_mean/avidemux/ADM_osSupport/ADM_crashdump.cpp
===================================================================
--- branches/avidemux_2.5_branch_mean/avidemux/ADM_osSupport/ADM_crashdump.cpp	2008-02-26 21:54:51 UTC (rev 3804)
+++ branches/avidemux_2.5_branch_mean/avidemux/ADM_osSupport/ADM_crashdump.cpp	2008-02-27 19:50:36 UTC (rev 3805)
@@ -1,449 +0,0 @@
-/***************************************************************************
-  Try to display interesting crash dump
-
-    copyright            : (C) 2007 by mean, (C) 2007 Gruntster
-    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-#include &quot;config.h&quot;
-
-#include &lt;stdio.h&gt;
-#include &lt;stdlib.h&gt;
-#include &lt;stdarg.h&gt;
-#include &lt;string.h&gt;
-#include &quot;ADM_default.h&quot;
-#include &lt;unistd.h&gt;
-
-#include &lt;math.h&gt;
-#include &lt;ADM_assert.h&gt;
-
-#if defined(ADM_WIN32)
-#define WIN32_CLASH
-#include &lt;windows.h&gt;
-#include &lt;excpt.h&gt;
-#include &lt;imagehlp.h&gt;
-#endif
-
-
-#include &quot;ADM_toolkit/toolkit.hxx&quot;
-#include &quot;ADM_userInterfaces/ADM_commonUI/DIA_factory.h&quot;
-#include &quot;ADM_editor/ADM_edit.hxx&quot;
-extern ADM_Composer *video_body;
-
-#define CRASH_FILE &quot;crash.js&quot;
-
-static void saveCrashProject(void);
-extern char *ADM_getBaseDir(void);
-extern void A_parseECMAScript(const char *name);
-
-#ifdef __APPLE__
-void installSigHandler() {}
-
-void ADM_backTrack(int lineno,const char *file)
-{
-	char bfr[1024];
-	saveCrashProject();
-	snprintf(bfr,1024,&quot;Assert Failed at file %s, line %d\n&quot;,file,lineno);
-	GUI_Error_HIG(&quot;Fatal Error&quot;,bfr);
-	assert(0);
-}
-#elif defined(WIN32)
-typedef struct STACK_FRAME
-{
-    STACK_FRAME* ebp;	// address of the calling function frame
-    uint8_t* retAddr;	// return address
-    uint32_t param[0];	// parameter list (could be empty)
-} STACK_FRAME;
-
-static void dumpFrame(void* processId, void* frameAddr)
-{
-	MEMORY_BASIC_INFORMATION mbi;
-	char moduleName[MAX_PATH];
-	HMODULE moduleAddr;
-	DWORD symDisplacement;
-	IMAGEHLP_SYMBOL* pSymbol;
-
-	if (VirtualQuery(frameAddr, &amp;mbi, sizeof(mbi)))
-	{
-		moduleName[0] = 0;
-		moduleAddr = (HMODULE)mbi.AllocationBase;
-		
-		GetModuleFileName(moduleAddr, moduleName, MAX_PATH);
-
-		printf(&quot;%s(&quot;, moduleName);
-
-		if (SymGetSymFromAddr(processId, (uint32_t)frameAddr, &amp;symDisplacement, pSymbol))
-			printf(&quot;%s&quot;, pSymbol-&gt;Name);
-		else
-			printf(&quot;&lt;unknown&gt;&quot;);
-
-		printf(&quot;+0x%X) [0x%08X]\n&quot;, (uint32_t)frameAddr - (uint32_t)moduleAddr, frameAddr);
-
-		fflush(stdout);
-	}
-}
-	
-static void dumpExceptionInfo(void* processId, struct _EXCEPTION_RECORD* pExceptionRec, struct _CONTEXT* pContextRecord)
-{
-	printf(&quot;\n*********** EXCEPTION **************\n&quot;);
-	printf(&quot;Registers:\n&quot;);
-	printf(&quot;EAX: %08X  EBX: %08X  ECX: %08X  EDX: %08X  ESI: %08X\n&quot;, pContextRecord-&gt;Eax, pContextRecord-&gt;Ebx, pContextRecord-&gt;Ecx, pContextRecord-&gt;Edx, pContextRecord-&gt;Esi);
-	printf(&quot;EDI: %08X  ESP: %08X  EBP: %08X  EIP: %08X  EFlags: %08X\n\n&quot;, pContextRecord-&gt;Edi, pContextRecord-&gt;Esp, pContextRecord-&gt;Ebp, pContextRecord-&gt;Eip, pContextRecord-&gt;EFlags);
-
-	printf(&quot;Exception Code: &quot;);
-
-	switch (pExceptionRec-&gt;ExceptionCode)
-	{
-		case EXCEPTION_ACCESS_VIOLATION:
-			printf(&quot;EXCEPTION_ACCESS_VIOLATION&quot;);
-			break;
-		case EXCEPTION_ARRAY_BOUNDS_EXCEEDED:
-			printf(&quot;EXCEPTION_ARRAY_BOUNDS_EXCEEDED&quot;);
-			break;
-		case EXCEPTION_BREAKPOINT:
-			printf(&quot;EXCEPTION_BREAKPOINT&quot;);
-			break;
-		case EXCEPTION_DATATYPE_MISALIGNMENT:
-			printf(&quot;EXCEPTION_DATATYPE_MISALIGNMENT&quot;);
-			break;
-		case EXCEPTION_FLT_DENORMAL_OPERAND:
-			printf(&quot;EXCEPTION_FLT_DENORMAL_OPERAND&quot;);
-			break;
-		case EXCEPTION_FLT_DIVIDE_BY_ZERO:
-			printf(&quot;EXCEPTION_FLT_DIVIDE_BY_ZERO&quot;);
-			break;
-		case EXCEPTION_FLT_INEXACT_RESULT:
-			printf(&quot;EXCEPTION_FLT_INEXACT_RESULT&quot;);
-			break;
-		case EXCEPTION_FLT_INVALID_OPERATION:
-			printf(&quot;EXCEPTION_FLT_INVALID_OPERATION&quot;);
-			break;
-		case EXCEPTION_FLT_OVERFLOW:
-			printf(&quot;EXCEPTION_FLT_OVERFLOW&quot;);
-			break;
-		case EXCEPTION_FLT_STACK_CHECK:
-			printf(&quot;EXCEPTION_FLT_STACK_CHECK&quot;);
-			break;
-		case EXCEPTION_FLT_UNDERFLOW:
-			printf(&quot;EXCEPTION_FLT_UNDERFLOW&quot;);
-			break;
-		case EXCEPTION_ILLEGAL_INSTRUCTION:
-			printf(&quot;EXCEPTION_ILLEGAL_INSTRUCTION&quot;);
-			break;
-		case EXCEPTION_IN_PAGE_ERROR:
-			printf(&quot;EXCEPTION_IN_PAGE_ERROR&quot;);
-			break;
-		case EXCEPTION_INT_DIVIDE_BY_ZERO:
-			printf(&quot;EXCEPTION_INT_DIVIDE_BY_ZERO&quot;);
-			break;
-		case EXCEPTION_INT_OVERFLOW:
-			printf(&quot;EXCEPTION_INT_OVERFLOW&quot;);
-			break;
-		case EXCEPTION_INVALID_DISPOSITION:
-			printf(&quot;EXCEPTION_INVALID_DISPOSITION&quot;);
-			break;
-		case EXCEPTION_NONCONTINUABLE_EXCEPTION:
-			printf(&quot;EXCEPTION_NONCONTINUABLE_EXCEPTION&quot;);
-			break;
-		case EXCEPTION_PRIV_INSTRUCTION:
-			printf(&quot;EXCEPTION_PRIV_INSTRUCTION&quot;);
-			break;
-		case EXCEPTION_SINGLE_STEP:
-			printf(&quot;EXCEPTION_SINGLE_STEP&quot;);
-			break;
-		case EXCEPTION_STACK_OVERFLOW:
-			printf(&quot;EXCEPTION_STACK_OVERFLOW&quot;);
-			break;
-		default:
-			printf(&quot;UNKNOWN&quot;);
-	}
-	
-	printf(&quot; (%08X)\n&quot;, pExceptionRec-&gt;ExceptionCode);
-	printf(&quot;Exception Flags: %08X\n&quot;, pExceptionRec-&gt;ExceptionFlags);
-
-	printf(&quot;\nOrigin:\n&quot;);
-	dumpFrame(processId, (void*)pContextRecord-&gt;Eip);
-	printf(&quot;*********** EXCEPTION **************\n&quot;);
-	fflush(stdout);
-}
-
-extern &quot;C&quot;
-{
-void dumpBackTrace(void* processId)
-{
-	if (!processId)
-		processId = GetCurrentProcess();
-
-	const int maxAddrCount = 32;
-
-	printf(&quot;\n*********** BACKTRACE **************\n&quot;);
-
-	// Get frame address using builtin GCC function.
-	STACK_FRAME* stackFrame = (STACK_FRAME*)__builtin_frame_address(0);
-
-    for (int retAddrCount = 0; (retAddrCount &lt; maxAddrCount) &amp;&amp; !IsBadReadPtr(stackFrame, sizeof(STACK_FRAME)) &amp;&amp; !IsBadCodePtr(FARPROC(stackFrame-&gt;retAddr)); retAddrCount++, stackFrame = stackFrame-&gt;ebp)
-    {
-		printf(&quot;Frame %2d: &quot;, retAddrCount);
-		dumpFrame(processId, stackFrame-&gt;retAddr);
-		fflush(stdout);
-    }
-
-	printf(&quot;*********** BACKTRACE **************\n\n&quot;);
-}
-}
-
-void ADM_backTrack(int lineno, const char *file)
-{	
-	fflush(stderr);
-	fflush(stdout);
-	saveCrashProject();
-
-	GUI_Error_HIG(QT_TR_NOOP(&quot;Fatal Error&quot;),QT_TR_NOOP(&quot;A fatal error has occurred.\n\nClick OK to generate debug information. This may take a few minutes to complete.&quot;));
-
-	void* currentProcessId = GetCurrentProcess();
-
-	SymInitialize(currentProcessId, NULL, TRUE);
-	dumpBackTrace(currentProcessId);
-	SymCleanup(currentProcessId);
-
-	printf(&quot;Assert failed at file %s, line %d\n\n&quot;,file,lineno);
-
-	exit(1);
-}
-
-EXCEPTION_DISPOSITION exceptionHandler(struct _EXCEPTION_RECORD* pExceptionRec, void* pEstablisherFrame, struct _CONTEXT* pContextRecord, void* pDispatcherContext)
-{
-	fflush(stderr);
-	fflush(stdout);
-	static int running=0;
-
-	if(running)
-		exit(1);
-
-	running=1;
-
-	saveCrashProject();
-
-	GUI_Error_HIG(QT_TR_NOOP(&quot;Fatal Error&quot;),QT_TR_NOOP(&quot;A fatal error has occurred.\n\nClick OK to generate debug information. This may take a few minutes to complete.&quot;));
-
-	void* currentProcessId = GetCurrentProcess();
-
-	SymInitialize(currentProcessId, NULL, TRUE);
-
-	dumpExceptionInfo(currentProcessId, pExceptionRec, pContextRecord);
-	fflush(stdout);
-	dumpBackTrace(currentProcessId);
-
-	SymCleanup(currentProcessId);
-
-	exit(1);
-}
-#else
-#include &lt;signal.h&gt;
-#include &lt;execinfo.h&gt;
-void sig_segfault_handler(int signo);
-void installSigHandler()
-{
-    signal(11, sig_segfault_handler); // show stacktrace on default
-}
-extern void ADMImage_stat( void );
-
-static int lenCount(uint8_t *start,uint8_t *end,int *d)
-{
-  int val=0;
-  int digit=0;
-  *d=0;
-  while(*start&gt;='0' &amp;&amp; *start&lt;='9' &amp;&amp; start&lt;end) 
-  {
-    val=val*10+*start-'0'; 
-    start++;
-    digit++;
-  }
-  *d=digit;
-  return val;
-}
-
-static int decodeOne(uint8_t *start, uint8_t *end,int *cons)
-{
-  *cons=0;
-  int len,digit;
-  uint8_t *org=start;
-  if(start+2&gt;=end) return 0;
-  switch(*start )
-  {
-    case 'Z':
-    case 'P':  
-      
-        len=lenCount(start+1,end,&amp;digit);
-        start+=1+digit;
-        for(int z=0;z&lt;len;z++) printf(&quot;%c&quot;,*start++);
-        break;
-  }
-  return (int)((uint64_t)start-(uint64_t)org);
-}
-static int demangle(int i,  uint8_t *string)
-{
- // Search 1st (
-  if(!string) return 0;
-  int len=strlen((char *)string);
-  if(!len) return 0;
-   
-  uint8_t *end=string+len;
-  uint8_t *start=string;
-  
-  while(*start!='(' &amp;&amp; start+3&lt;end) start++;
-  if(*start!='(') return 0;
-  start++;
-  
-  //  _qt(_Z9crashTestP9JSContextP8JSObjectjPlS3_+0) [0x4acf80]
-  
-  if(*start!='_' || start[1]!='Z')
-  {
-    return 0;
-  }
-  // Seems good !
-  start++;
-  start++;  
-  int digit;
-  // Function name..
-  int l=lenCount(start,end,&amp;digit);
-  printf(&quot;\t&lt;&quot;);
-  for(int i=0;i&lt;l;i++)
-  {
-    printf(&quot;%c&quot;,start[digit+i]); 
-  }
-  printf(&quot;&gt;(&quot;);
-  start+=digit+l;
-  
-  // Parama
-  int first=0;
-  while(start+2&lt;end &amp;&amp; *start=='P')
-  {
-    if(!first)  first=1;
-    else
-        printf(&quot;,&quot;);
-    
-      
-    start++;
-    l=lenCount(start,end,&amp;digit);
-    for(int i=0;i&lt;l;i++)
-    {
-      printf(&quot;%c&quot;,start[digit+i]); 
-    }
-    start+=digit+l;
-  }
-  printf(&quot;)\n&quot;);
-  return 1;
-}
-
-/**
-      \fn sig_segfault_handler
-      \brief our segfault handler
-
-*/
-void sig_segfault_handler(int signo)
-{
-     
-     static int running=0;
-      if(running) 
-      {
-        signo=0;
-        exit(1);
-      }
-      running=0; 
-      ADM_backTrack(0,&quot;&quot;);
-}
-void ADM_backTrack(int lineno,const char *file)
-{
-     void *stack[20];
-     char **functions;
-     int count, i;
-      
-     saveCrashProject();
-      printf(&quot;\n*********** BACKTRACK **************\n&quot;);
-      count = backtrace(stack, 20);
-      functions = backtrace_symbols(stack, count);
-      
-         for (i=0; i &lt; count; i++) 
-         {
-            printf(&quot;Frame %2d: %s \n&quot;, i, functions[i]);
-            demangle(i,(uint8_t *)functions[i]);
-            
-         }
-      printf(&quot;*********** BACKTRACK **************\n&quot;);
-     // Now use dialogFactory
-      char bfr[30];
-      snprintf(bfr,30,&quot;Line:%u&quot;,lineno);
-      diaElemReadOnlyText *txt[count+1];
-      txt[0]=new diaElemReadOnlyText(bfr,file);
-      
-      for(i=0;i&lt;count;i++)
-          txt[i+1]=new diaElemReadOnlyText(functions[i],&quot;Function:&quot;);
-      const char *title=&quot;Crash BackTrace&quot;;
-      if(lineno) title=&quot;Assert failed&quot;;
-      diaFactoryRun(title,count+1,(diaElem **)txt);
-      
-      //
-     printf(&quot;Memory stat:\n&quot;);
-     ADMImage_stat();
-
-     exit(1); // _exit(1) ???
-}
-#endif
-/**
-    \fn saveCrashProject
-    \brief Try to save the current project, useful in case of crash
-*/
-void saveCrashProject(void)
-{
-  char *baseDir=ADM_getBaseDir();
-  char *name=CRASH_FILE;
-  static int crashCount=0;
-  if(crashCount) return ; // avoid endless looping
-  crashCount++;
-  char *where=new char[strlen(baseDir)+strlen(name)+2];
-  strcpy(where,baseDir);
-  strcat(where,&quot;/&quot;);
-  strcat(where,name);
-  printf(&quot;Saving crash file to %s\n&quot;,where);
-  video_body-&gt;saveAsScript (where, NULL);
-  delete[] where;
-}
-/**
-    \fn checkCrashFile
-    \brief Check if there i a crash file
-*/
-
-void checkCrashFile(void)
-{
-  char *baseDir=ADM_getBaseDir();
-  char *name=CRASH_FILE;
-  static int crashCount=0;
-  char *where=new char[strlen(baseDir)+strlen(name)+2];
-  strcpy(where,baseDir);
-  strcat(where,&quot;/&quot;);
-  strcat(where,name);
-  if(ADM_fileExist(where))
-  {
-    if(GUI_Confirmation_HIG(QT_TR_NOOP(&quot;Load it&quot;),QT_TR_NOOP(&quot;Crash file&quot;),
-       QT_TR_NOOP(&quot;I have detected a crash file. \nDo you want to load it  ?\n(It will be deleted in all cases, you should save it if you want to keep it)&quot;)))
-    {
-       A_parseECMAScript(where);
-    }
-    unlink(where);
-  }else
-  {
-    printf(&quot;No crash file (%s)\n&quot;,where); 
-  }
-  delete [] where;
-}
-//EOF

Deleted: branches/avidemux_2.5_branch_mean/avidemux/ADM_osSupport/ADM_fileio.cpp
===================================================================
--- branches/avidemux_2.5_branch_mean/avidemux/ADM_osSupport/ADM_fileio.cpp	2008-02-26 21:54:51 UTC (rev 3804)
+++ branches/avidemux_2.5_branch_mean/avidemux/ADM_osSupport/ADM_fileio.cpp	2008-02-27 19:50:36 UTC (rev 3805)
@@ -1,410 +0,0 @@
-/***************************************************************************
-                    
-    copyright            : (C) 2006 by mean
-    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#include &quot;config.h&quot; 
-#include &lt;stdio.h&gt;
-#include &lt;stdlib.h&gt;
-#include &lt;string.h&gt;
-    
-#include &lt;dirent.h&gt;
-#include &lt;errno.h&gt;
-#include &lt;sys/stat.h&gt;
-
-#include &lt;unistd.h&gt;
-
-#ifdef WIN32
-#include &lt;glib.h&gt;
-#endif
-
-#include &quot;ADM_default.h&quot;
-
-
-
-#include &quot;ADM_toolkit/filesel.h&quot;
-#include &quot;ADM_toolkit/toolkit.hxx&quot;
-
-#include &quot;ADM_assert.h&quot;
-#undef fread
-#undef fwrite
-#undef fopen
-#undef fclose
-
-size_t ADM_fread (void *ptr, size_t size, size_t n, FILE *sstream)
-{
-  return fread(ptr,size,n,sstream); 
-  
-}
-
-size_t ADM_fwrite (void *ptr, size_t size, size_t n, FILE *sstream)
-{
-  return fwrite(ptr,size,n,sstream); 
-  
-}
-FILE  *ADM_fopen (const char *file, const char *mode)
-{
-  FILE *f;
-
-#ifndef ADM_WIN32
-  return fopen(file,mode); 
-#else
-  gchar *retval = g_locale_from_utf8 (file, -1, NULL, NULL, NULL);
-  f=fopen(retval,mode);
-  g_free (retval);
-  return f;  
-#endif
-}
-
-int    ADM_fclose (FILE *file)
-{
-  return fclose(file); 
-}
-//*****************************
-static char basedir[1024]={0};
-static char jobdir[1024]={0};
-static char customdir[1024]={0};
-int baseDirDone=0;
-int jobDirDone=0;
-int customDirDone=0;
-#ifdef ADM_WIN32
-const char *ADM_DIR_NAME=&quot;\\avidemux&quot;;
-#else
-const char *ADM_DIR_NAME=&quot;/.avidemux&quot;;
-#endif
-/*
-
-*/
-/*
-      Get the  directory where jobs are stored
-******************************************************/
-
-char *ADM_getCustomDir(void)
-{
-  if(customDirDone) return customdir;
-
-  char *rootDir;
-  rootDir=ADM_getBaseDir();
-  strncpy(customdir,rootDir,1023);
-#if defined(ADM_WIN32)
-  strcat(customdir,&quot;\\custom&quot;); 
-#else
-  strcat(customdir,&quot;/custom&quot;);
-#endif
-  if(!ADM_mkdir(customdir))
-  {
-    GUI_Error_HIG(QT_TR_NOOP(&quot;Oops&quot;),QT_TR_NOOP(&quot;can't create custom directory (%s).&quot;),customdir);
-                return NULL;
-  }
-  customDirDone=1;
-  return customdir;
-}
-/*
-      Get the  directory where jobs are stored
-******************************************************/
-
-char *ADM_getJobDir(void)
-{
-  if(jobDirDone) return jobdir;
-
-  char *rootDir;
-  rootDir=ADM_getBaseDir();
-  strncpy(jobdir,rootDir,1023);
-#if defined(ADM_WIN32)
-  strcat(jobdir,&quot;\\jobs&quot;); 
-#else
-  strcat(jobdir,&quot;/jobs&quot;);
-#endif
-  if(!ADM_mkdir(jobdir))
-  {
-    GUI_Error_HIG(QT_TR_NOOP(&quot;Oops&quot;),QT_TR_NOOP(&quot;can't create job directory (%s).&quot;),jobdir);
-                return NULL;
-  }
-  jobDirDone=1;
-  return jobdir;
-}
-/*
-      Get the root directory for .avidemux stuff
-******************************************************/
-char *ADM_getBaseDir(void)
-{
-char *dirname=NULL;
-DIR *dir=NULL;
-char *home;
-//
-        if(baseDirDone) return basedir;
-// Get the base directory
-#if defined(ADM_WIN32)
-        if( ! (home=getenv(&quot;USERPROFILE&quot;)) )
-        {
-          GUI_Error_HIG(QT_TR_NOOP(&quot;Oops&quot;),QT_TR_NOOP(&quot;can't determine $USERPROFILE.&quot;));
-                    home=&quot;c:\\&quot;;
-        }
-
-#else
-        if( ! (home=getenv(&quot;HOME&quot;)) )
-        {
-          GUI_Error_HIG(QT_TR_NOOP(&quot;Oops&quot;),QT_TR_NOOP(&quot;can't determine $HOME.&quot;));
-                return NULL;
-        }
-#endif
-
- // Try to open the .avidemux directory
-        dirname=new char[strlen(home)+strlen(ADM_DIR_NAME)+2];
-        strcpy(dirname,home);
-        strcat(dirname,ADM_DIR_NAME);
-        if(!ADM_mkdir(dirname))
-        {
-          GUI_Error_HIG(QT_TR_NOOP(&quot;Oops&quot;),QT_TR_NOOP(&quot;Cannot create the .avidemux directory&quot;), NULL);
-                        delete [] dirname;
-                        return NULL;
-        }
-        delete [] dirname;
-
-        // Now built the filename
-        strncpy(basedir,home,1023);
-        strncat(basedir,ADM_DIR_NAME,1023-strlen(basedir));
-        baseDirDone=1;
-        printf(&quot;Using %s as base directory for prefs/jobs/...\n&quot;,basedir);
-        return basedir;
-}
-/*----------------------------------------
-      Create a directory
-      If it already exists, do nothing
-------------------------------------------*/
-uint8_t ADM_mkdir(const char *dirname)
-{
-DIR *dir=NULL;
-              // Check it already exists ?
-              dir=opendir(dirname);
-              if(dir)
-              { 
-                  printf(&quot;Directory %s exists.Good.\n&quot;,dirname);
-                  closedir(dir);
-                  return 1;
-              }
-#if defined(ADM_WIN32)
-                if(mkdir(dirname))
-                {
-                    printf(&quot;Oops: mkdir failed on %s\n&quot;,dirname);   
-                    return 0;
-                }
-                
-#else    
-                char *sys=new char[strlen(dirname)+strlen(&quot;mkdir &quot;)+2];
-                strcpy(sys,&quot;mkdir &quot;);
-                strcat(sys,dirname);
-                printf(&quot;Creating dir :%s\n&quot;,sys);
-                system(sys);
-                delete [] sys;
-#endif		
-              if((dir=opendir(dirname))==NULL)
-                {
-                        return 0;
-                }
-              closedir(dir); 
-              return 1;
-}
-uint8_t buildDirectoryContent(uint32_t *outnb,const char *base, char *jobName[],int maxElems,const char *ext)
-{
-
-DIR *dir;
-struct dirent *direntry;
-int dirmax=0,len;
-int extlen=strlen(ext);
-    ADM_assert(extlen);
-    
-         dir=opendir(base);
-        if(!dir)
-        {
-                return 0;
-        }
-        while((direntry=readdir(dir)))
-        {
-                len=strlen(direntry-&gt;d_name);
-                if(len&lt;(extlen+1)) continue;
-                int xbase=len-extlen;
-                if(memcmp(direntry-&gt;d_name+xbase,ext,extlen))
-                //if(direntry-&gt;d_name[len-1]!='s' || direntry-&gt;d_name[len-2]!='j' || direntry-&gt;d_name[len-3]!='.')
-                {
-                        printf(&quot;ignored:%s\n&quot;,direntry-&gt;d_name);
-                        continue;
-                }
-                jobName[dirmax]=(char *)ADM_alloc(strlen(base)+strlen(direntry-&gt;d_name)+2);
-                strcpy(jobName[dirmax],base);
-                strcat(jobName[dirmax],&quot;/&quot;);
-                strcat(jobName[dirmax],direntry-&gt;d_name);
-                dirmax++;
-                if(dirmax&gt;=maxElems)
-                {
-                        printf(&quot;[jobs]: Max # of jobs exceeded\n&quot;);
-                         break;
-                }
-        }
-        closedir(dir);
-        *outnb=dirmax;
-        return 1;
-}
-//------------------------------------------------------------------
-
-/*
-
-** note: it modifies it's first argument
-*/
-void simplify_path(char **buf){
-   unsigned int last1slash = 0;
-   unsigned int last2slash = 0;
-	while( !strncmp(*buf,&quot;/../&quot;,4) )
-		memmove(*buf,*buf+3,strlen(*buf+3)+1);
-	for(unsigned int i=0;i&lt;strlen(*buf)-2;i++)
-		while( !strncmp(*buf+i,&quot;/./&quot;,3) )
-			memmove(*buf+i,*buf+i+2,strlen(*buf+i+2)+1);
-	for(unsigned int i=0;i&lt;strlen(*buf)-3;i++){
-		if( *(*buf+i) == '/' ){
-			last2slash = last1slash;
-			last1slash = i;
-		}
-		if( !strncmp(*buf+i,&quot;/../&quot;,4) ){
-			memmove(*buf+last2slash,*buf+i+3,strlen(*buf+i+3)+1);
-			return simplify_path(buf);
-		}
-	}
-}
-
-//
-//	Make it absolute
-//
-char *PathCanonize(const char *tmpname)
-{
-	char path[300];
-	char *out ;
-
-	if( ! getcwd(path,300) ){
-		fprintf(stderr,&quot;\ngetcwd() failed with: %s (%u)\n&quot;,
-		               strerror(errno), errno );
-		path[0] = '\0';
-	}
-	if(!tmpname || tmpname[0]==0)
-	{
-		out=new char [strlen(path)+2];
-		strcpy(out,path);
-#ifndef ADM_WIN32		
-		strcat(out,&quot;/&quot;);
-#else
-		strcat(out,&quot;\\&quot;);
-#endif	
-		printf(&quot;\n Canonizing null string ??? (%s)\n&quot;,out);
-	}else if(tmpname[0]=='/'
-#if defined(ADM_WIN32)
-		|| tmpname[1]==':'
-#endif	
-	
-	)
-	{
-		out=new char[strlen(tmpname)+1];
-		strcpy(out,tmpname);
-		return out;
-	}else{
-		out=new char[strlen(path)+strlen(tmpname)+6];
-		strcpy(out,path);
-#ifndef ADM_WIN32		
-		strcat(out,&quot;/&quot;);
-#else
-		strcat(out,&quot;\\&quot;);
-#endif		
-		strcat(out,tmpname);
-	}
-	simplify_path(&amp;out);
-	return out;
-}
-/*
-	Strip the path and only keep the name
-
-*/
-void		PathStripName(char *str)
-{
-		int len=strlen(str);
-		if(len&lt;=1) return;
-		len--;
-#ifndef ADM_WIN32		
-		while( *(str+len)!='/' &amp;&amp; len)
-#else
-	while( *(str+len)!='\\' &amp;&amp; len)
-#endif		
-		{
-			 *(str+len)=0;
-			 len--;
-		}
-}
-
-/*
-	Get the filename without path
-
-*/
-const char *GetFileName(const char *str)
-{
-	char *filename;
-        char *filename2;
-#ifndef ADM_WIN32		
-	filename = strrchr(str, '/');
-        
-#else
-	filename = strrchr(str, '\\');
-        filename2 = strrchr(str, '/');
-        if(filename2 &amp;&amp; filename)
-        {
-          if(filename2&gt;filename) filename=filename2; 
-        }
-#endif
-	if (filename)
-		return filename+1;
-	else
-		return str;
-}
-
-/*
-	Split patch into absolute path+name and extention
-
-*/
-void PathSplit(char *str, char **root, char **ext)
-{
-	char *full;
-	uint32_t l;
-
-		full=PathCanonize(str);
-		// Search the last .
-		l=strlen(full);
-		l--;
-		ADM_assert(l&gt;0);
-		while( *(full+l)!='.' &amp;&amp; l) l--;
-		if(!l || l==(strlen(full)-1))
-		{
-			if(l==(strlen(full)-1))
-			{
-				*(full+l)=0;  // remove trailing .
-			}
-			*ext=new char[2];
-			*root=full;
-			strcpy(*ext,&quot;&quot;);
-			return ;
-		}
-		// else we do get an extension
-		// starting at l+1
-		uint32_t suff;
-
-		suff=strlen(full)-l-1;
-		*ext=new char[suff+1];
-		strcpy(*ext,full+l+1);
-		*(full+l)=0;
-		*root=full;
-		return ;
-}

Deleted: branches/avidemux_2.5_branch_mean/avidemux/ADM_osSupport/ADM_memcpy.cpp
===================================================================
--- branches/avidemux_2.5_branch_mean/avidemux/ADM_osSupport/ADM_memcpy.cpp	2008-02-26 21:54:51 UTC (rev 3804)
+++ branches/avidemux_2.5_branch_mean/avidemux/ADM_osSupport/ADM_memcpy.cpp	2008-02-27 19:50:36 UTC (rev 3805)
@@ -1,483 +0,0 @@
-
-
-
-
-/* Adapted from Xine /Mplayer to avidemx2 */
-/*
- * Copyright (C) 2001-2004 the xine project
- *
- * This file is part of xine, a free video player.
- *
- * xine is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * xine is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA
- *
- * These are the MMX/MMX2/SSE optimized versions of memcpy
- *
- * This code was adapted from Linux Kernel sources by Nick Kurshev to
- * the mplayer program. (<A HREF="http://mplayer.sourceforge.net">http://mplayer.sourceforge.net</A>)
- *
- * Miguel Freitas split the #ifdefs into several specialized functions that
- * are benchmarked at runtime by xine. Some original comments from Nick
- * have been preserved documenting some MMX/SSE oddities.
- * Also added kernel memcpy function that seems faster than libc one.
- *
- */
-
-
-#include &quot;config.h&quot;
-
-#include &lt;stdio.h&gt;
-#include &lt;stdlib.h&gt;
-#include &lt;string.h&gt;
-
-#include &quot;ADM_default.h&quot;
-
-extern &quot;C&quot;
-{
-        #include &quot;ADM_lavcodec/dsputil_cpu.h&quot;
-
-
-
-#include &quot;ADM_assert.h&quot;
-
-adm_fast_memcpy myAdmMemcpy=NULL;
-/* Original comments from mplayer (file: aclib.c)
- This part of code was taken by me from Linux-2.4.3 and slightly modified
-for MMX, MMX2, SSE instruction set. I have done it since linux uses page aligned
-blocks but mplayer uses weakly ordered data and original sources can not
-speedup them. Only using PREFETCHNTA and MOVNTQ together have effect!
-
-&gt;From IA-32 Intel Architecture Software Developer's Manual Volume 1,
-
-Order Number 245470:
-&quot;10.4.6. Cacheability Control, Prefetch, and Memory Ordering Instructions&quot;
-
-Data referenced by a program can be temporal (data will be used again) or
-non-temporal (data will be referenced once and not reused in the immediate
-future). To make efficient use of the processor's caches, it is generally
-desirable to cache temporal data and not cache non-temporal data. Overloading
-the processor's caches with non-temporal data is sometimes referred to as
-&quot;polluting the caches&quot;.
-The non-temporal data is written to memory with Write-Combining semantics.
-
-The PREFETCHh instructions permits a program to load data into the processor
-at a suggested cache level, so that it is closer to the processors load and
-store unit when it is needed. If the data is already present in a level of
-the cache hierarchy that is closer to the processor, the PREFETCHh instruction
-will not result in any data movement.
-But we should you PREFETCHNTA: Non-temporal data fetch data into location
-close to the processor, minimizing cache pollution.
-
-The MOVNTQ (store quadword using non-temporal hint) instruction stores
-packed integer data from an MMX register to memory, using a non-temporal hint.
-The MOVNTPS (store packed single-precision floating-point values using
-non-temporal hint) instruction stores packed floating-point data from an
-XMM register to memory, using a non-temporal hint.
-
-The SFENCE (Store Fence) instruction controls write ordering by creating a
-fence for memory store operations. This instruction guarantees that the results
-of every store instruction that precedes the store fence in program order is
-globally visible before any store instruction that follows the fence. The
-SFENCE instruction provides an efficient way of ensuring ordering between
-procedures that produce weakly-ordered data and procedures that consume that
-data.
-
-If you have questions please contact with me: Nick Kurshev: <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">nickols_k at mail.ru.</A>
-*/
-
-/*  mmx v.1 Note: Since we added alignment of destinition it speedups
-    of memory copying on PentMMX, Celeron-1 and P2 upto 12% versus
-    standard (non MMX-optimized) version.
-    Note: on K6-2+ it speedups memory copying upto 25% and
-          on K7 and P3 about 500% (5 times).
-*/
-
-/* Additional notes on gcc assembly and processors: [MF]
-prefetch is specific for AMD processors, the intel ones should be
-prefetch0, prefetch1, prefetch2 which are not recognized by my gcc.
-prefetchnta is supported both on athlon and pentium 3.
-
-therefore i will take off prefetchnta instructions from the mmx1 version
-to avoid problems on pentium mmx and k6-2.
-
-quote of the day:
-&quot;Using prefetches efficiently is more of an art than a science&quot;
-*/
-
-
-#if defined(ARCH_X86) || defined(ARCH_X86_64)
-
-
-/* for small memory blocks (&lt;256 bytes) this version is faster */
-#define small_memcpy(to,from,n)\
-{\
-register unsigned long int dummy;\
-__asm__ __volatile__(\
-  &quot;rep; movsb&quot;\
-  :&quot;=&amp;D&quot;(to), &quot;=&amp;S&quot;(from), &quot;=&amp;c&quot;(dummy)\
-  :&quot;0&quot; (to), &quot;1&quot; (from),&quot;2&quot; (n)\
-  : &quot;memory&quot;);\
-}
-
-/* linux kernel __memcpy (from: /include/asm/string.h) */
-static __inline__ void * linux_kernel_memcpy_impl (
-			       void * to,
-			       const void * from,
-			       size_t n)
-{
-int d0, d1, d2;
-
-  if( n &lt; 4 ) {
-    small_memcpy(to,from,n);
-  }
-  else
-    __asm__ __volatile__(
-    &quot;rep ; movsl\n\t&quot;
-    &quot;testb $2,%b4\n\t&quot;
-    &quot;je 1f\n\t&quot;
-    &quot;movsw\n&quot;
-    &quot;1:\ttestb $1,%b4\n\t&quot;
-    &quot;je 2f\n\t&quot;
-    &quot;movsb\n&quot;
-    &quot;2:&quot;
-    : &quot;=&amp;c&quot; (d0), &quot;=&amp;D&quot; (d1), &quot;=&amp;S&quot; (d2)
-    :&quot;0&quot; (n/4), &quot;q&quot; (n),&quot;1&quot; ((long) to),&quot;2&quot; ((long) from)
-    : &quot;memory&quot;);
-
-  return (to);
-}
-
-#define SSE_MMREG_SIZE 16
-#define MMX_MMREG_SIZE 8
-
-#define MMX1_MIN_LEN 0x800  /* 2K blocks */
-#define MIN_LEN 0x40  /* 64-byte blocks */
-
-/* SSE note: i tried to move 128 bytes a time instead of 64 but it
-didn't make any measureable difference. i'm using 64 for the sake of
-simplicity. [MF] */
-static void * sse_memcpy(void * to, const void * from, size_t len)
-{
-  void *retval;
-  uint8_t *ufrom=(uint8_t *)from;
-  uint8_t *uto=(uint8_t *)to;
-  size_t i;
-  retval = to;
-
-  /* PREFETCH has effect even for MOVSB instruction ;) */
-  __asm__ __volatile__ (
-    &quot;   prefetchnta (%0)\n&quot;
-    &quot;   prefetchnta 32(%0)\n&quot;
-    &quot;   prefetchnta 64(%0)\n&quot;
-    &quot;   prefetchnta 96(%0)\n&quot;
-    &quot;   prefetchnta 128(%0)\n&quot;
-    &quot;   prefetchnta 160(%0)\n&quot;
-    &quot;   prefetchnta 192(%0)\n&quot;
-    &quot;   prefetchnta 224(%0)\n&quot;
-    &quot;   prefetchnta 256(%0)\n&quot;
-    &quot;   prefetchnta 288(%0)\n&quot;
-    : : &quot;r&quot; (ufrom) );
-
-  if(len &gt;= MIN_LEN)
-  {
-    register unsigned long int delta;
-    /* Align destinition to MMREG_SIZE -boundary */
-    delta = ((unsigned long int)uto)&amp;(SSE_MMREG_SIZE-1);
-    if(delta)
-    {
-      delta=SSE_MMREG_SIZE-delta;
-      len -= delta;
-      small_memcpy(uto, ufrom, delta);
-    }
-    i = len &gt;&gt; 6; /* len/64 */
-    len&amp;=63;
-    if(((unsigned long)ufrom) &amp; 15)
-      /* if SRC is misaligned */
-      for(; i&gt;0; i--)
-      {
-        __asm__ __volatile__ (
-        &quot;prefetchnta 320(%0)\n&quot;
-       &quot;prefetchnta 352(%0)\n&quot;
-        &quot;movups (%0), %%xmm0\n&quot;
-        &quot;movups 16(%0), %%xmm1\n&quot;
-        &quot;movups 32(%0), %%xmm2\n&quot;
-        &quot;movups 48(%0), %%xmm3\n&quot;
-        &quot;movntps %%xmm0, (%1)\n&quot;
-        &quot;movntps %%xmm1, 16(%1)\n&quot;
-        &quot;movntps %%xmm2, 32(%1)\n&quot;
-        &quot;movntps %%xmm3, 48(%1)\n&quot;
-        :: &quot;r&quot; (ufrom), &quot;r&quot; (uto) : &quot;memory&quot;);
-         ufrom+=64;
-         uto+=64;
-      }
-    else
-      /*
-         Only if SRC is aligned on 16-byte boundary.
-         It allows to use movaps instead of movups, which required data
-         to be aligned or a general-protection exception (#GP) is generated.
-      */
-      for(; i&gt;0; i--)
-      {
-        __asm__ __volatile__ (
-        &quot;prefetchnta 320(%0)\n&quot;
-       &quot;prefetchnta 352(%0)\n&quot;
-        &quot;movaps (%0), %%xmm0\n&quot;
-        &quot;movaps 16(%0), %%xmm1\n&quot;
-        &quot;movaps 32(%0), %%xmm2\n&quot;
-        &quot;movaps 48(%0), %%xmm3\n&quot;
-        &quot;movntps %%xmm0, (%1)\n&quot;
-        &quot;movntps %%xmm1, 16(%1)\n&quot;
-        &quot;movntps %%xmm2, 32(%1)\n&quot;
-        &quot;movntps %%xmm3, 48(%1)\n&quot;
-        :: &quot;r&quot; (ufrom), &quot;r&quot; (uto) : &quot;memory&quot;);
-        ufrom+=64;
-        uto+=64;
-      }
-    /* since movntq is weakly-ordered, a &quot;sfence&quot;
-     * is needed to become ordered again. */
-    __asm__ __volatile__ (&quot;sfence&quot;:::&quot;memory&quot;);
-    /* enables to use FPU */
-    __asm__ __volatile__ (&quot;emms&quot;:::&quot;memory&quot;);
-  }
-  /*
-   *	Now do the tail of the block
-   */
-  if(len) linux_kernel_memcpy_impl(uto, ufrom, len);
-  return retval;
-}
-
-static void * mmx_memcpy(void * to, const void * from, size_t len)
-{
-  void *retval;
-  uint8_t *ufrom=(uint8_t *)from;
-  uint8_t *uto=(uint8_t *)to;
-  size_t i;
-  retval = uto;
-
-  if(len &gt;= MMX1_MIN_LEN)
-  {
-    register unsigned long int delta;
-    /* Align destinition to MMREG_SIZE -boundary */
-    delta = ((unsigned long int)uto)&amp;(MMX_MMREG_SIZE-1);
-    if(delta)
-    {
-      delta=MMX_MMREG_SIZE-delta;
-      len -= delta;
-      small_memcpy(uto, ufrom, delta);
-    }
-    i = len &gt;&gt; 6; /* len/64 */
-    len&amp;=63;
-    for(; i&gt;0; i--)
-    {
-      __asm__ __volatile__ (
-      &quot;movq (%0), %%mm0\n&quot;
-      &quot;movq 8(%0), %%mm1\n&quot;
-      &quot;movq 16(%0), %%mm2\n&quot;
-      &quot;movq 24(%0), %%mm3\n&quot;
-      &quot;movq 32(%0), %%mm4\n&quot;
-      &quot;movq 40(%0), %%mm5\n&quot;
-      &quot;movq 48(%0), %%mm6\n&quot;
-      &quot;movq 56(%0), %%mm7\n&quot;
-      &quot;movq %%mm0, (%1)\n&quot;
-      &quot;movq %%mm1, 8(%1)\n&quot;
-      &quot;movq %%mm2, 16(%1)\n&quot;
-      &quot;movq %%mm3, 24(%1)\n&quot;
-      &quot;movq %%mm4, 32(%1)\n&quot;
-      &quot;movq %%mm5, 40(%1)\n&quot;
-      &quot;movq %%mm6, 48(%1)\n&quot;
-      &quot;movq %%mm7, 56(%1)\n&quot;
-      :: &quot;r&quot; (ufrom), &quot;r&quot; (uto) : &quot;memory&quot;);
-      ufrom+=64;
-      uto+=64;
-    }
-    __asm__ __volatile__ (&quot;emms&quot;:::&quot;memory&quot;);
-  }
-  /*
-   *	Now do the tail of the block
-   */
-  if(len) linux_kernel_memcpy_impl(uto, ufrom, len);
-  return retval;
-}
-
-static void * mmx2_memcpy(void * to, const void * from, size_t len)
-{
-  void *retval;
-  uint8_t *ufrom=(uint8_t *)from;
-  uint8_t *uto=(uint8_t *)to;
-  size_t i;
-  retval = to;
-
-  /* PREFETCH has effect even for MOVSB instruction ;) */
-  __asm__ __volatile__ (
-    &quot;   prefetchnta (%0)\n&quot;
-    &quot;   prefetchnta 32(%0)\n&quot;
-    &quot;   prefetchnta 64(%0)\n&quot;
-    &quot;   prefetchnta 96(%0)\n&quot;
-    &quot;   prefetchnta 128(%0)\n&quot;
-    &quot;   prefetchnta 160(%0)\n&quot;
-    &quot;   prefetchnta 192(%0)\n&quot;
-    &quot;   prefetchnta 224(%0)\n&quot;
-    &quot;   prefetchnta 256(%0)\n&quot;
-    &quot;   prefetchnta 288(%0)\n&quot;
-    : : &quot;r&quot; (ufrom) );
-
-  if(len &gt;= MIN_LEN)
-  {
-    register unsigned long int delta;
-    /* Align destinition to MMREG_SIZE -boundary */
-    delta = ((unsigned long int)uto)&amp;(MMX_MMREG_SIZE-1);
-    if(delta)
-    {
-      delta=MMX_MMREG_SIZE-delta;
-      len -= delta;
-      small_memcpy(uto, ufrom, delta);
-    }
-    i = len &gt;&gt; 6; /* len/64 */
-    len&amp;=63;
-    for(; i&gt;0; i--)
-    {
-      __asm__ __volatile__ (
-      &quot;prefetchnta 320(%0)\n&quot;
-      &quot;prefetchnta 352(%0)\n&quot;
-      &quot;movq (%0), %%mm0\n&quot;
-      &quot;movq 8(%0), %%mm1\n&quot;
-      &quot;movq 16(%0), %%mm2\n&quot;
-      &quot;movq 24(%0), %%mm3\n&quot;
-      &quot;movq 32(%0), %%mm4\n&quot;
-      &quot;movq 40(%0), %%mm5\n&quot;
-      &quot;movq 48(%0), %%mm6\n&quot;
-      &quot;movq 56(%0), %%mm7\n&quot;
-      &quot;movntq %%mm0, (%1)\n&quot;
-      &quot;movntq %%mm1, 8(%1)\n&quot;
-      &quot;movntq %%mm2, 16(%1)\n&quot;
-      &quot;movntq %%mm3, 24(%1)\n&quot;
-      &quot;movntq %%mm4, 32(%1)\n&quot;
-      &quot;movntq %%mm5, 40(%1)\n&quot;
-      &quot;movntq %%mm6, 48(%1)\n&quot;
-      &quot;movntq %%mm7, 56(%1)\n&quot;
-      :: &quot;r&quot; (ufrom), &quot;r&quot; (uto) : &quot;memory&quot;);
-      ufrom+=64;
-      uto+=64;
-    }
-     /* since movntq is weakly-ordered, a &quot;sfence&quot;
-     * is needed to become ordered again. */
-    __asm__ __volatile__ (&quot;sfence&quot;:::&quot;memory&quot;);
-    __asm__ __volatile__ (&quot;emms&quot;:::&quot;memory&quot;);
-  }
-  /*
-   *	Now do the tail of the block
-   */
-  if(len) linux_kernel_memcpy_impl(uto, ufrom, len);
-  return retval;
-}
-
-static void *linux_kernel_memcpy(void *to, const void *from, size_t len) {
-  return linux_kernel_memcpy_impl(to,from,len);
-}
-#endif /* ARCH_X86 */
-
-static struct {
-  char *name;
-  void *(* function)(void *to, const void *from, size_t len);
-
-  uint64_t time; /* This type could be used for non-MSC build too! */
-
-  uint32_t cpu_require;
-} memcpy_method[] =
-{
-  { NULL, NULL, 0, 0 },
-  { &quot;libc memcpy()&quot;, memcpy, 0, 0 },
-#if defined( ARCH_X86)  || defined(ARCH_X86_64)
-  { &quot;linux kernel memcpy()&quot;, linux_kernel_memcpy, 0, 0 },
-#if defined( ARCH_X86)  || defined(ARCH_X86_64)
-  { &quot;MMX optimized memcpy()&quot;, mmx_memcpy, 0, MM_MMX },
-  { &quot;MMXEXT optimized memcpy()&quot;, mmx2_memcpy, 0, MM_MMXEXT },
-  { &quot;SSE optimized memcpy()&quot;, sse_memcpy, 0, MM_MMXEXT|MM_SSE },
-#endif
-#endif /* ARCH_X86 */
-#if 0 &amp;&amp; defined (ARCH_PPC) &amp;&amp; !defined (HOST_OS_DARWIN)
-  { &quot;ppcasm_memcpy()&quot;, ppcasm_memcpy, 0, 0 },
-  { &quot;ppcasm_cacheable_memcpy()&quot;, ppcasm_cacheable_memcpy, 0, MM_ACCEL_PPC_CACHE32 },
-#endif /* ARCH_PPC &amp;&amp; !HOST_OS_DARWIN */
-  { NULL, NULL, 0, 0 }
-};
-
-#if defined( ARCH_X86)  || defined(ARCH_X86_64)
-static unsigned long long int rdtsc(void)
-{
-  unsigned long long int x;
-
-  /* that should prevent us from trying cpuid with old cpus */
- 
-    __asm__ volatile (&quot;.byte 0x0f, 0x31&quot; : &quot;=A&quot; (x));
-    return x;
- }
-#else
-static unsigned long long int rdtsc(void)
-{
-	return 0;
- }
-
-#endif
-
-
-
-#define BUFSIZE 1024*1024
-/*******************************************
-*/
-uint8_t probe(adm_fast_memcpy func,char *name)
-{
-	void *src,*dst;
-	uint64_t start,stop;
-
-	src=ADM_alloc(BUFSIZE);
-	dst=ADM_alloc(BUFSIZE);
-	start=rdtsc();
-	func(dst,src,BUFSIZE);
-	stop=rdtsc();
-	ADM_dealloc(src);
-	ADM_dealloc(dst);
-	printf(&quot;Method :%s \tTime:%lu\n&quot;,name,stop-start);
-	return 1;
-
-}
-/*
-
-	It seems MMX gives the best result most of the times
-	Don't bother benchmarking
-*/
-uint8_t ADM_InitMemcpy(void)
-{
-  uint64_t          t;
-  char             *buf1, *buf2;
-  int               i, j, best;
-  int               config_flags = 0;
-#undef memcpy
-        myAdmMemcpy=memcpy;
-#if defined( ARCH_X86)  || defined(ARCH_X86_64)
-        if(CpuCaps::hasMMX())
-                myAdmMemcpy=mmx_memcpy;
-#endif
-#if 0
-	probe(memcpy,&quot;libc&quot;);
-	probe(linux_kernel_memcpy,&quot;kernel&quot;);
-#if defined( ARCH_X86)  || defined(ARCH_X86_64)
-	if(CpuCaps::hasMMX()) probe(mmx_memcpy,&quot;mmx&quot;);
-	if(CpuCaps::hasMMXEXT()) probe(mmx_memcpy,&quot;mmxext&quot;);
-	if(CpuCaps::hasSSE()) probe(sse_memcpy,&quot;sse&quot;);
-#endif
-#endif
-	return 1; 
-}
-}

Deleted: branches/avidemux_2.5_branch_mean/avidemux/ADM_osSupport/ADM_memory.cpp
===================================================================
--- branches/avidemux_2.5_branch_mean/avidemux/ADM_osSupport/ADM_memory.cpp	2008-02-26 21:54:51 UTC (rev 3804)
+++ branches/avidemux_2.5_branch_mean/avidemux/ADM_osSupport/ADM_memory.cpp	2008-02-27 19:50:36 UTC (rev 3805)
@@ -1 +0,0 @@
-//

Deleted: branches/avidemux_2.5_branch_mean/avidemux/ADM_osSupport/ADM_memsupport.cpp
===================================================================
--- branches/avidemux_2.5_branch_mean/avidemux/ADM_osSupport/ADM_memsupport.cpp	2008-02-26 21:54:51 UTC (rev 3804)
+++ branches/avidemux_2.5_branch_mean/avidemux/ADM_osSupport/ADM_memsupport.cpp	2008-02-27 19:50:36 UTC (rev 3805)
@@ -1,423 +0,0 @@
-//
-// C++ Interface: ADM_memsupport
-//
-// Description: 
-//	Wrapper for all memory alloc/dealloc
-//
-//	Ensures 16 byte alignment for all memory allocations on Linux and Windows (to
-//  support PPC and SSE).
-//
-//  Mac OS X is exempt as it automatically ensures 16 byte alignment and overriding
-//  the new/delete operators with custom memory management clashes with Qt4.
-//
-// Author: mean &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>&gt;, (C) 2004
-//
-// Copyright: See COPYING file that comes with this distribution
-//
-//
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#include &quot;ADM_default.h&quot;
-
-
-
-#undef memalign
-#undef malloc
-#undef free
-#undef realloc
-
-static uint32_t ADM_consumed = 0;
-static admMutex memAccess(&quot;MemAccess&quot;);
-static int doMemStat = 0;
-
-#if defined(ADM_DEBUG) &amp;&amp; defined(FIND_LEAKS)
-#define _DEBUG_NEW_CALLER_ADDRESS __builtin_return_address(0)
-extern void* operator new(size_t size, const char* file, int line);
-extern void operator delete(void* pointer, const char* file, int line) throw();
-extern size_t getSizeFromPointer(void* ptr);
-#endif
-
-extern &quot;C&quot;
-{
-	void *av_malloc(unsigned int size);
-	void av_free(void *ptr);
-	void *av_realloc(void *ptr, unsigned int size);
-}
-
-void ADM_memStat(void);
-void ADM_memStatInit(void);
-void ADM_memStatEnd(void);
-
-void ADM_memStatInit(void)
-{
-	ADM_consumed = 0;
-	doMemStat = 1;
-}
-
-void ADM_memStatEnd(void)
-{
-	doMemStat = 0;
-}
-
-void ADM_memStat(void)
-{
-	printf(&quot;Global mem stat\n______________\n&quot;);
-	printf(&quot;\tMemory consumed: %lu (MB)\n&quot;, ADM_consumed &gt;&gt; 20);
-}
-
-#if !defined(ADM_DEBUG) || !defined(FIND_LEAKS)
-/**
-    \fn ADM_calloc(size_t nbElm,size_t elSize);
-    \brief Replacement for system Calloc using our memory management
-    \param nbElem : # of elements to allocate
-    \param elSize : Size of one element in bytes
-    \return pointer 
-*/
-void *ADM_calloc(size_t nbElm, size_t elSize)
-{
-	void *out = ADM_alloc(nbElm * elSize);
-	memset(out, 0, nbElm * elSize);
-	return out;
-}
-
-void *ADM_alloc(size_t size)
-{
-#ifdef __APPLE__
-	return malloc(size);
-#else
-	char *c;
-
-	uint64_t l, lorg;
-	uint32_t *backdoor;
-	int dome = doMemStat;
-
-	if(dome)
-		memAccess.lock();
-
-	l = (uint64_t)malloc(size + 32);
-
-	// Get next boundary
-	lorg = l;
-	l = (l + 15) &amp; 0xfffffffffffffff0LL;
-	l += 16;
-	c = (char*)l;
-	backdoor = (uint32_t*)(c - 8);
-	*backdoor = (0xdead &lt;&lt; 16) + l - lorg;
-	backdoor[1] = size;
-
-	if(dome)
-		memAccess.unlock();
-
-	ADM_consumed += size;
-
-	return c;
-#endif
-}
-
-void ADM_dezalloc(void *ptr)
-{
-#ifdef __APPLE__
-	if (!ptr)
-		return;
-
-	free(ptr);
-#else
-	int dome = doMemStat;
-	uint32_t *backdoor;
-	uint32_t size, offset;
-	char *c = (char*)ptr;
-
-	if (!ptr)
-		return;
-
-	backdoor = (uint32_t*)ptr;
-	backdoor -= 2;
-
-	if (*backdoor == 0xbeefbeef)
-	{
-		printf(&quot;Double free gotcha!\n&quot;);
-		ADM_assert(0);
-	}
-
-	ADM_assert(((*backdoor) &gt;&gt; 16) == 0xdead);
-
-	offset = backdoor[0] &amp; 0xffff;
-	size = backdoor[1];
-	*backdoor = 0xbeefbeef; // Scratch sig
-
-	if (dome)
-		memAccess.lock();
-
-	free(c - offset);
-	ADM_consumed -= size;
-
-	if(dome)
-		memAccess.unlock();
-#endif
-}
-
-void *operator new( size_t t)
-{
-	return ADM_alloc(t);
-}
-
-void *operator new[] ( size_t t)
-{
-	return ADM_alloc(t);
-}
-
-void operator delete (void *c)
-{
-	ADM_dezalloc(c);
-}
-
-void operator delete[] (void *c)
-{
-	ADM_dezalloc(c);
-}
-//********************************
-// lavcodec wrapper
-//********************************
-extern &quot;C&quot;
-{
-	void *av_malloc(unsigned int size)
-	{
- 		return ADM_alloc(size);
-	}
-
-	void av_freep(void *arg)
-	{
-		void **ptr= (void**)arg;
-		av_free(*ptr);
-		*ptr = NULL;
-	}
-
-	void *av_mallocz(unsigned int size)
-	{
-		void *ptr;
-
-		ptr = av_malloc(size);
-
-		if (ptr)
-			memset(ptr, 0, size);
-
-		return ptr;
-	}
-}
-
-char *av_strdup(const char *s)
-{
-    char *ptr;
-    int len;
-
-    len = strlen(s) + 1;
-    ptr = (char *)av_malloc(len);
-
-    if (ptr)
-        memcpy(ptr, s, len);
-
-    return ptr;
-}
-
-/**
- * av_realloc semantics (same as glibc): if ptr is NULL and size &gt; 0,
- * identical to malloc(size). If size is zero, it is identical to
- * free(ptr) and NULL is returned.  
- */
-void *ADM_realloc(void *ptr, size_t newsize)
-{
-#ifdef __APPLE__
-	if(!ptr)
-		return ADM_alloc(newsize);
-
-	if (!newsize)
-	{
-		ADM_dealloc(ptr);
-		return NULL;
-	}
-
-	return realloc(ptr, newsize);
-#else
-	void *nalloc;
-
-	if(!ptr)
-		return ADM_alloc(newsize);
-
-	if(!newsize) 
-	{    	
-		ADM_dealloc(ptr);
-		return NULL;
-	}
-
-	// now we either shrink them or expand them
-	// in case of shrink, we do nothing
-	// in case of expand we have to copy
-	// Do copy everytime (slower)
-	uint32_t *backdoor;
-	uint32_t size, offset;
-	char *c = (char*)ptr;
-
-	backdoor = (uint32_t*)ptr;
-	backdoor -= 2;
-
-	ADM_assert(((*backdoor) &gt;&gt; 16) == 0xdead);
-
-	offset = backdoor[0] &amp; 0xffff;
-	size = backdoor[1];
-
-	if(size &gt;= newsize) // do nothing
-		return ptr;
-
-	// Allocate a new one
-	nalloc = ADM_alloc(newsize);
-	memcpy(nalloc, ptr, size);
-	ADM_dealloc(ptr);
-
-	return nalloc;
-#endif
-}
-
-void *av_realloc(void *ptr, unsigned int newsize)
-{
-	return ADM_realloc(ptr,newsize);
-}
-
-/* NOTE: ptr = NULL is explicetly allowed */
-void av_free(void *ptr)
-{
-	if(ptr)
-		ADM_dealloc(ptr);  
-}
-
-char *ADM_strdup(const char *in)
-{
-	if(!in)
-		return NULL;
-
-	uint32_t l = strlen(in);
-	char *out;
-
-	out = (char*)ADM_alloc(l + 1);
-	memcpy(out, in, l+1);
-
-	return out;
-}
-
-#else
-
-void *ADM_alloc(size_t size)
-{
-	return operator new(size, (char*)_DEBUG_NEW_CALLER_ADDRESS, 0);
-}
-
-void *ADM_calloc(size_t nbElm,size_t elSize)
-{
-	void *out = operator new(nbElm*elSize, (char*)_DEBUG_NEW_CALLER_ADDRESS, 0);
-
-	memset(out,0,nbElm*elSize);
-	return out;
-}
-
-char *ADM_strdup(const char *in)
-{
-    if(!in)
-		return NULL;
-
-	int size = strlen(in) + 1;
-	char *out = (char *)(operator new(size, (char*)_DEBUG_NEW_CALLER_ADDRESS, 0));
-
-	memcpy(out, in, size);
-
-	return out;
-}
-
-void ADM_dezalloc(void *ptr)
-{
-	operator delete(ptr, (char*)_DEBUG_NEW_CALLER_ADDRESS, 0);
-}
-
-void *ADM_realloc(void *ptr, size_t newsize)
-{
-	void *nalloc;
-    
-    if(!ptr)
-		return operator new(newsize, (char*)_DEBUG_NEW_CALLER_ADDRESS, 0);
-
-    if(!newsize) 
-    {    
-		operator delete(ptr, (char*)_DEBUG_NEW_CALLER_ADDRESS, 0);
-		return NULL;
-    }
-
-	uint32_t size = getSizeFromPointer(ptr);
-
-	if (size &gt;= newsize)
-		return ptr;
-
-	nalloc = operator new(newsize, (char*)_DEBUG_NEW_CALLER_ADDRESS, 0);
-	memcpy(nalloc,ptr,getSizeFromPointer(ptr));
-	operator delete(ptr, (char*)_DEBUG_NEW_CALLER_ADDRESS, 0);
-
-	return nalloc;
-}
-
-extern &quot;C&quot;
-{
-	void *av_malloc(unsigned int size)
-	{
-		return operator new(size, (char*)_DEBUG_NEW_CALLER_ADDRESS, 0);
-	}
-	void av_freep(void *arg)
-	{
-		void **ptr = (void**)arg;
-		av_free(*ptr);
-		*ptr = NULL;
-	}
-
-	void *av_mallocz(unsigned int size)
-	{
-		void *ptr;
-
-		ptr = operator new(size, (char*)_DEBUG_NEW_CALLER_ADDRESS, 0);
-
-		if (ptr)
-			memset(ptr, 0, size);
-
-		return ptr;
-	}
-}
-
-char *av_strdup(const char *s)
-{
-    char *ptr;
-    int len;
-    len = strlen(s) + 1;
-	ptr = (char *)operator new(len, (char*)_DEBUG_NEW_CALLER_ADDRESS, 0);
-
-    if (ptr)
-        memcpy(ptr, s, len);
-
-    return ptr;
-}
-
-void *av_realloc(void *ptr, unsigned int newsize)
-{
-	if(!ptr)
-		return operator new(newsize, (char*)_DEBUG_NEW_CALLER_ADDRESS, 0);
-	else
-		return ADM_realloc(ptr,newsize);
-}
-
-void av_free(void *ptr)
-{
-	if(ptr)
-		operator delete(ptr, (char*)_DEBUG_NEW_CALLER_ADDRESS, 0);
-}
-#endif
-// EOF

Deleted: branches/avidemux_2.5_branch_mean/avidemux/ADM_osSupport/ADM_misc.cpp
===================================================================
--- branches/avidemux_2.5_branch_mean/avidemux/ADM_osSupport/ADM_misc.cpp	2008-02-26 21:54:51 UTC (rev 3804)
+++ branches/avidemux_2.5_branch_mean/avidemux/ADM_osSupport/ADM_misc.cpp	2008-02-27 19:50:36 UTC (rev 3805)
@@ -1,307 +0,0 @@
-/***************************************************************************
-                          toolkit.cpp  -  description
-                             -------------------
-
-
-
-    begin                : Fri Dec 14 2001
-    copyright            : (C) 2001 by mean
-    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#include &quot;config.h&quot;
-#include &lt;stdio.h&gt;
-#include &lt;stdlib.h&gt;
-#include &lt;time.h&gt;
-#include &lt;math.h&gt;
-#include &lt;string.h&gt;
-#ifndef ADM_WIN32
-#include &lt;unistd.h&gt;
-#endif
-//#include &lt;gtk/gtk.h&gt;
-#include &lt;ctype.h&gt;
-#include &lt;sys/time.h&gt;
-
-#include &quot;ADM_default.h&quot;
-#include &quot;ADM_assert.h&quot;
-
-#include &quot;ADM_video/ADM_vidMisc.h&quot;
-
-//
-//    Sleep for n ms
-//
-void GUI_Sleep(uint32_t ms)
-{
-    if (ms &lt; 10)
-	return;
-    ADM_usleep(ms*1000);
-}
-
-
-// Get tick (in ms)
-// Call with a 0 to initialize
-// Call with a 1 to read
-//_____________________
-uint32_t getTime(int called)
-{
-
-    static struct timeval timev_s;
-
-    static struct timeval timev;
-    static TIMZ timez;
-
-    int32_t tt;
-
-    if (!called)
-      {
-	  called = 1;
-	  gettimeofday(&amp;timev_s, &amp;timez);
-	  return 0;
-      }
-    gettimeofday(&amp;timev, &amp;timez);
-    tt = timev.tv_usec - timev_s.tv_usec;
-    tt /= 1000;
-    tt += 1000 * (timev.tv_sec - timev_s.tv_sec);
-    return (tt);
-}
-uint32_t getTimeOfTheDay(void)
-{
-  
-
-     struct timeval timev;
-     TIMZ timez;
-
-    int32_t tt;
-
-   
-    gettimeofday(&amp;timev, &amp;timez);
-    tt = timev.tv_usec;
-    tt /= 1000;
-    tt += 1000 * (timev.tv_sec);
-    return (tt&amp;0xffffff);
-
-}
-/// convert frame number and fps to hour/mn/sec/ms
-void  frame2time(	uint32_t frame, uint32_t fps, uint16_t * hh, uint16_t * mm,
-                                uint16_t * ss, uint16_t * ms)
-{
-    UNUSED_ARG(fps);
-double d;
-    uint32_t len2;
-    d=frame;
-    d=d/fps;
-    d*=1000000.;
-    
-    len2 = (uint32_t)(d); //video_body-&gt;getTime(frame);
-    ms2time(len2,hh,mm,ss,ms);
-}
-
-void ms2time(uint32_t len2,uint16_t * hh, uint16_t * mm,
-	 			uint16_t * ss, uint16_t * ms)
-{
-    *hh = (uint32_t) floor(len2 / (3600.F * 1000.F));
-    len2 -= (uint32_t) floor(*hh * 3600.F * 1000.F);
-    *mm = (uint32_t) floor(len2 / (60.F * 1000.F));
-    len2 -= (uint32_t) floor(*mm * 60.F * 1000.F);
-    *ss = (uint32_t) floor(len2 / (1000.F));
-    len2 -= (uint32_t) floor((*ss * 1000.F));
-    *ms = (uint32_t) floor(len2);
-
-}
-void            time2frame(uint32_t *frame, uint32_t fps, uint32_t hh, uint32_t mm,
-                                uint32_t ss, uint32_t ms)
-{
-// convert everything to ms : uint32_t = 1000 hours, should be plenty enough
-uint32_t count=0;
-                count+=ms;
-                count+=ss*1000;
-                count+=mm*60*1000;
-                count+=hh*3600*1000;
-double d;
-                d=count;                
-                // ms
-                d=d*fps;
-                d/=1000;
-                d/=1000;
-                *frame= (uint32_t)(floor(d+0.5));
-
-}
-
-uint64_t ADM_swap64(uint64_t in)
-{
-uint32_t low,high;
-uint64_t out;
-        high=in&gt;&gt;32;
-        low=in&amp;0xffffffff;
-        high=ADM_swap32(high);
-        low=ADM_swap32(low);
-        out=low;
-        out=(out&lt;&lt;32)+high;
-        return out;
-  
-}
-// swap BE/LE : Ugly
-uint32_t ADM_swap32( uint32_t in)
-{
-        uint8_t r[4],u;
-        memcpy(&amp;r[0],&amp;in,4);
-        u=r[0];
-        r[0]=r[3];
-        r[3]=u;
-        u=r[1];
-        r[1]=r[2];
-        r[2]=u;
-        memcpy(&amp;in,&amp;r[0],4);
-        return in;
-}
-// swap BE/LE : Ugly
-uint16_t ADM_swap16( uint16_t in)
-{
-	return ( (in&gt;&gt;8) &amp; 0xff) + ( (in&amp;0xff)&lt;&lt;8);
-}
-uint8_t 	identMovieType(uint32_t fps1000)
-{
-#define INRANGE(value,type)  \
-      {\
-              if((fps1000 &gt; value-300) &amp;&amp;( fps1000 &lt; value+300))\
-              {\
-                r=type;\
-                printf(&quot;Looks like &quot;#type&quot; \n&quot;);\
-                }\
-      }
-      uint8_t r=0;
-      INRANGE(25000,FRAME_PAL);
-      INRANGE(23976,FRAME_FILM);
-      INRANGE(29970,FRAME_NTSC);
-
-      return r;
-}
-uint8_t ms2time(uint32_t ms, uint32_t *h,uint32_t *m, uint32_t *s)
-{
-      uint32_t sectogo;
-      int  mm,ss,hh;
-
-
-                              // d is in ms, divide by 1000 to get seconds
-                              sectogo = (uint32_t) floor(ms / 1000.);
-                              hh=sectogo/3600;
-                              sectogo=sectogo-hh*3600;
-                              mm=sectogo/60;
-                              ss=sectogo%60;
-
-                              *h=hh;
-                              *m=mm;
-                              *s=ss;
-      return 1;
-}
-
-char* ms2timedisplay(uint32_t ms)
-{
-	uint32_t mm, ss;
-	static char string[20];
-
-	mm = (uint32_t)floor(ms / 60000.);
-	
-	if (mm &gt; 1)
-	{
-		sprintf(string, QT_TR_NOOP(&quot;%lu minutes&quot;), mm);
-	}
-	else if (mm == 1)
-	{
-		sprintf(string, QT_TR_NOOP(&quot;%lu minute&quot;), mm);
-	}
-	else
-	{
-		ss = (uint32_t)floor(ms / 1000.);
-
-		if (ss == 1)
-		{
-			sprintf(string, QT_TR_NOOP(&quot;%lu second&quot;), ss);
-		}
-		else
-		{
-			sprintf(string, QT_TR_NOOP(&quot;%lu seconds&quot;), ss);
-		}
-	}
-
-	return string;
-}
-
-// Convert everything to lowercase
-void  LowerCase(char *string)
-{
-  int l=strlen(string)-1;
-        for(int i=l;i&gt;=0;i--)
-        {
-                string[i]=tolower(string[i]);
-        }
-
-}
-
-uint8_t         ADM_fileExist(char *name)
-{
-FILE *file;
-                file=fopen(name,&quot;rb&quot;);
-                if(!file) return 0;
-                fclose(file);
-                return 1;
-
-}
-/*
-    In some case (e.g. javascript), the reader expects unixish path 
-    c:/foo/bar/c.c
-    and the &quot;natural&quot; path is c:\foo\bar
-    
-    This function convert the later to the former
-
-*/
-extern char *slashToBackSlash(char *in)
-{
-    char *out,*cout;
-    int n;
-    n=strlen(in);
-    cout=out=(char *)ADM_alloc(n+1);   
-    for(int i=0;i&lt;n+1;i++)
-    {
-        if(   in[i]=='\\') out[i]='/';
-        else    out[i]=in[i];
-        
-    }
-    return cout;
-    
-}
-/*
-    
-*/
-void TLK_getDate(ADM_date *date)
-{
-  time_t timez;
-  tm *t;
-  time(&amp;timez);
-  t=localtime(&amp;timez);
-  if(t)
-  {
-    date-&gt;hours=t-&gt;tm_hour;
-    date-&gt;minutes=t-&gt;tm_min;
-    date-&gt;seconds=t-&gt;tm_sec;
-  }
-  
-}
-
-bool shutdown(void)
-{
-#ifdef ADM_WIN32
-	return (shutdown_win32() == 0);
-#else
-	return (system(&quot;shutdown -P 0&quot;) == 0);
-#endif
-}
-//EOF

Deleted: branches/avidemux_2.5_branch_mean/avidemux/ADM_osSupport/ADM_threads.cpp
===================================================================
--- branches/avidemux_2.5_branch_mean/avidemux/ADM_osSupport/ADM_threads.cpp	2008-02-26 21:54:51 UTC (rev 3804)
+++ branches/avidemux_2.5_branch_mean/avidemux/ADM_osSupport/ADM_threads.cpp	2008-02-27 19:50:36 UTC (rev 3805)
@@ -1,98 +0,0 @@
-/***************************************************************************
-                    
-    copyright            : (C) 2006 by mean
-    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#include &quot;config.h&quot;
- 
-#include &lt;stdio.h&gt;
-#include &lt;stdlib.h&gt;
-#include &lt;string.h&gt;
-#include &lt;ADM_assert.h&gt;
-#include &quot;ADM_default.h&quot;
-
-
-
-#define THR_CHECK(x) {int r=(x);if(r) {printf(&quot;Threading error :%d %s\n&quot;, \
-                      r,strerror(r));exit(0);}}
-//**************** Mutex *******************
-admMutex::admMutex(const char *name)
-{
-  _name=name; // Should always be const, so it is okay to not copy
-  THR_CHECK(pthread_mutex_init(&amp;_tex,NULL));
-  _locked=0;
-}
-admMutex::~admMutex()
-{
-  THR_CHECK(pthread_mutex_destroy(&amp;_tex));
-       
-}
-
-uint8_t admMutex::lock(void)
-{
-  int e;
-  THR_CHECK(pthread_mutex_lock(&amp;_tex));
-  _locked=1;
-  return 1;
-}
-uint8_t admMutex::unlock(void)
-{
-  _locked=0;      // Just informative, race possible here
-  THR_CHECK(pthread_mutex_unlock(&amp;_tex));
-  return 1;
-}
-uint8_t admMutex::isLocked(void)
-{
-  return _locked;
-}
-
-//**************** Cond *******************
-
-admCond::admCond( admMutex *tex )
-{
-  THR_CHECK(pthread_cond_init(&amp;_cond,NULL));
-  _condtex=tex;
-  waiting=0;
-  aborted=0;
-}
-admCond::~admCond()
-{
-  THR_CHECK(pthread_cond_destroy(&amp;_cond));
-
-}
-uint8_t admCond::wait(void)
-{
-  if(aborted) return 0;
-        // take sem
-  ADM_assert(_condtex-&gt;isLocked());
-  waiting=1;
-  THR_CHECK(pthread_cond_wait(&amp;_cond, &amp;(_condtex-&gt;_tex)));
-  waiting=0;
-  _condtex-&gt;unlock();
-  return 1;
-}
-uint8_t admCond::wakeup(void)
-{
-  THR_CHECK(pthread_cond_signal(&amp;_cond));
-  return 1;
-}
-uint8_t admCond::iswaiting( void)
-{
-  return waiting;
-}
-uint8_t admCond::abort( void )
-{
-  aborted=1;
-  if(waiting) wakeup();
-  return 1;
-
-}

Deleted: branches/avidemux_2.5_branch_mean/avidemux/ADM_osSupport/TLK_clock.cpp
===================================================================
--- branches/avidemux_2.5_branch_mean/avidemux/ADM_osSupport/TLK_clock.cpp	2008-02-26 21:54:51 UTC (rev 3804)
+++ branches/avidemux_2.5_branch_mean/avidemux/ADM_osSupport/TLK_clock.cpp	2008-02-27 19:50:36 UTC (rev 3805)
@@ -1,107 +0,0 @@
-/***************************************************************************
-                          TLK_clock.cpp  -  description
-                             -------------------
-	Handle a simple clock/timer class
-
-	The API used returns the amound of days/hour/minute/seconds since
-		1st Jan 1970
-	As we only use part of the information (seconds and useconds) it
-	may wrap around anytime
-
-	The first time a clock is created, we store the &quot;now date&quot; and
-	do the computation with getTime-&quot;now date&quot;
-	It will wrap after 25 days, so it can be considerate safe
-
-
-    begin                : Fri Apr 20 2003
-    copyright            : (C) 2003 by mean
-    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#include &lt;stdio.h&gt;
-#include &lt;stdlib.h&gt;
-#include &lt;time.h&gt;
-#include &lt;math.h&gt;
-#include &lt;unistd.h&gt;
-#include &lt;sys/time.h&gt;
-
-#include &quot;config.h&quot;
-
-#include &quot;ADM_osSupport/ADM_debugID.h&quot;
-#define MODULE_NAME MODULE_CLOCKnTIMELEFT
-#include &quot;ADM_osSupport/ADM_debug.h&quot;
-
-#include &quot;avi_vars.h&quot;
-
-
-
-static uint8_t inited=0;
-static struct timeval _itimev;
-static uint32_t getAbsTime( void );
-
-#ifndef ADM_WIN32
-#include &quot;unistd.h&quot;
-void ADM_usleep(unsigned long us)
-{
-  usleep(us);
-}
-#endif
-
-Clock::Clock( void )
-{
-	reset();
-}
-Clock::~Clock(  )
-{
-
-}
-uint32_t Clock::getElapsedMS(void )
-{
-   uint32_t ret = getAbsTime()-_startTime;
-	aprintf(&quot;Clock::getElapsedMS() -&gt; %lu\n&quot;, ret);
-	return ret;
-}
-
-/** Note:
-*** * gettimeofday() returns seconds since 1.1.1970 in param1.tv_sec
-*** * because we need a AbsTime with milliseconds for benchmarking we have:
-***   max 0x7Fffffff (int32_t casted to uint32_t)
-***    =&gt; 2147483647 msec =&gt; 2147483 sec =&gt; Sun Jan 25 21:31:23 1970
-***   the return value will wrap all 25 days
-*** * workaround:
-***   1) start with an AbsTime of zero if object Clock() is created
-***   2) finish your work within 25 days ;-)
-**/
-uint32_t getAbsTime( void )
-{
-     struct timeval timev;     
-     TIMZ timez;
-
-    int32_t tt;
-
-    if(!inited)
-    {
-	gettimeofday(&amp;_itimev, &amp;timez);
-	inited=1;
-    }
-
-    gettimeofday(&amp;timev, &amp;timez);
-    tt = timev.tv_usec;
-    tt /= 1000;
-    tt += 1000 * (timev.tv_sec-_itimev.tv_sec);
-    aprintf(&quot;getAbsTime() -&gt; %lu\n&quot;, tt&amp;0x7Fffffff);
-    return (tt&amp;0x7Fffffff);
-
-}
-uint8_t Clock::reset(void)
-{
-	_startTime=getAbsTime();
-}

Deleted: branches/avidemux_2.5_branch_mean/avidemux/ADM_osSupport/win32.cpp
===================================================================
--- branches/avidemux_2.5_branch_mean/avidemux/ADM_osSupport/win32.cpp	2008-02-26 21:54:51 UTC (rev 3804)
+++ branches/avidemux_2.5_branch_mean/avidemux/ADM_osSupport/win32.cpp	2008-02-27 19:50:36 UTC (rev 3805)
@@ -1,485 +0,0 @@
-#include &quot;config.h&quot;
-
-#ifdef ADM_WIN32
-#define WIN32_CLASH
-#include &lt;stdio.h&gt;
-#include &lt;stdlib.h&gt;
-
-#include &quot;ADM_default.h&quot;
-
-#include &quot;windows.h&quot;
-#include &quot;io.h&quot;
-#include &quot;winsock2.h&quot;
-#include &quot;ADM_assert.h&quot; 
-
-uint8_t win32_netInit(void);
-extern char *ADM_getBaseDir(void);
-
-void ADM_usleep(unsigned long us)
-{
-	Sleep(us/1000);
-}
-
-uint8_t win32_netInit(void)
-{
-WSADATA wsaData;
-	int iResult;
-		printf(&quot;Initializing WinSock\n&quot;);
-		iResult = WSAStartup(MAKEWORD(2,2), &amp;wsaData);
-		if (iResult != NO_ERROR)
-		{
-			printf(&quot;Error at WSAStartup()\n&quot;);
-			return 0;
-		}	
-		printf(&quot;WinSock ok\n&quot;);
-		return 1;
-}
-
-#ifndef HAVE_GETTIMEOFDAY
-extern &quot;C&quot;
-{
-void gettimeofday(struct timeval *p, void *tz);
-}
-
-void gettimeofday(struct timeval *p, void *tz)
-{
-    unsigned long int sec;
-    SYSTEMTIME  tme;
-
-    GetSystemTime(&amp;tme);
-
-    sec=tme.wSecond;
-    sec+=60*tme.wMinute;
-    sec+=60*60*tme.wHour;
-    
-	p-&gt;tv_sec=sec;
-	p-&gt;tv_usec=tme.wMilliseconds*1000;
-
-	return;
-}
-#endif
-
-int getpriority(int which, int who)
-{
-	unsigned int priorityClass;
-
-	ADM_assert(which == PRIO_PROCESS);
-	ADM_assert(who == 0);
-
-	priorityClass = GetPriorityClass(GetCurrentProcess());
-
-	switch (priorityClass)
-	{
-		case HIGH_PRIORITY_CLASS:
-			return -18;
-			break;
-		case ABOVE_NORMAL_PRIORITY_CLASS:
-			return -10;
-			break;
-		case NORMAL_PRIORITY_CLASS:
-			return 0;
-			break;
-		case BELOW_NORMAL_PRIORITY_CLASS:
-			return 10;
-			break;
-		case IDLE_PRIORITY_CLASS:
-			return 18;
-			break;
-		default:
-			ADM_assert(0);
-	}
-}
-
-int setpriority(int which, int who, int value)
-{
-	unsigned int priorityClass;
-
-	ADM_assert(which == PRIO_PROCESS);
-	ADM_assert(who == 0);
-	ADM_assert(value &gt;= PRIO_MIN &amp;&amp; value &lt;= PRIO_MAX);
-
-	if (value &gt;= -20 &amp;&amp; value &lt;= -16)
-	{
-		priorityClass = HIGH_PRIORITY_CLASS;
-	}
-	else if (value &gt;= -15 &amp;&amp; value &lt;= -6)
-	{
-		priorityClass = ABOVE_NORMAL_PRIORITY_CLASS;
-	}
-	else if (value &gt;= -5 &amp;&amp; value &lt;= 4)
-	{
-		priorityClass = NORMAL_PRIORITY_CLASS;
-	}
-	else if (value &gt;= 6 &amp;&amp; value &lt;= 15)
-	{
-		priorityClass = BELOW_NORMAL_PRIORITY_CLASS;
-	}
-	else if (value &gt;= 16 &amp;&amp; value &lt;= 20)
-	{
-		priorityClass = IDLE_PRIORITY_CLASS;
-	}
-
-	if (!SetPriorityClass(GetCurrentProcess(), priorityClass))
-	{
-		return -1;
-	}
-
-	return 0;
-}
-
-int shutdown_win32(void)
-{
-	HANDLE hToken;
-	TOKEN_PRIVILEGES tkp;
-
-	// Get a token for this process. 
-	if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &amp;hToken))
-	{
-		return -1;
-	}
-
-	// Get the LUID for the shutdown privilege.
-	LookupPrivilegeValue(NULL, SE_SHUTDOWN_NAME, &amp;tkp.Privileges[0].Luid);
-
-	tkp.PrivilegeCount = 1;  // one privilege to set
-	tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
-
-	// Get the shutdown privilege for this process.
-	AdjustTokenPrivileges(hToken, FALSE, &amp;tkp, 0, (PTOKEN_PRIVILEGES)NULL, 0);
-
-	if (GetLastError() != ERROR_SUCCESS)
-	{
-		return -1;
-	}
-
-	// Shut down the system and force all applications to close.
-	if (!ExitWindowsEx(EWX_POWEROFF | EWX_FORCE, SHTDN_REASON_FLAG_PLANNED))
-	{
-		return -1;
-	}
-
-	return 0;
-}
-
-#ifndef PRODUCT_BUSINESS
-#define PRODUCT_BUSINESS 0x00000006
-#endif
-
-#ifndef PRODUCT_BUSINESS_N
-#define PRODUCT_BUSINESS_N 0x00000010
-#endif
-
-#ifndef PRODUCT_HOME_BASIC
-#define PRODUCT_HOME_BASIC 0x00000002
-#endif
-
-#ifndef PRODUCT_HOME_BASIC_N
-#define PRODUCT_HOME_BASIC_N 0x00000005
-#endif
-
-#ifndef PRODUCT_HOME_PREMIUM
-#define PRODUCT_HOME_PREMIUM 0x00000003
-#endif 
-
-#ifndef PRODUCT_STARTER
-#define PRODUCT_STARTER 0x0000000B
-#endif
-
-#ifndef PRODUCT_ENTERPRISE
-#define PRODUCT_ENTERPRISE 0x00000004
-#endif 
-
-#ifndef PRODUCT_ULTIMATE
-#define PRODUCT_ULTIMATE 0x00000001
-#endif
-
-bool getWindowsVersion(char* version)
-{
-	int index = 0;
-	OSVERSIONINFOEX osvi = {};
-
-	osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
-
-	if (!GetVersionEx((OSVERSIONINFO*)&amp;osvi))
-		return false;
-
-	if (osvi.dwPlatformId != VER_PLATFORM_WIN32_NT)
-		return false;
-// Vista
-	if (osvi.dwMajorVersion == 6 &amp;&amp; osvi.dwMinorVersion == 0)
-	{
-		if (osvi.wProductType == VER_NT_WORKSTATION)
-		{
-			index += sprintf(version + index, &quot;Microsoft Windows Vista&quot;);
-
-			uint32_t productType = 0;
-
-			HMODULE hKernel = GetModuleHandle(&quot;KERNEL32.DLL&quot;);
-
-			if (hKernel)
-			{
-				typedef bool (*funcGetProductInfo)(uint32_t, uint32_t, uint32_t, uint32_t, uint32_t*);
-				funcGetProductInfo pGetProductInfo = (funcGetProductInfo)GetProcAddress(hKernel, &quot;GetProductInfo&quot;); 
-
-				if (pGetProductInfo)
-					pGetProductInfo(6, 0, 0, 0, &amp;productType);
-	  
-				switch (productType)
-				{
-				case PRODUCT_STARTER:
-				{
-					index += sprintf(version + index, &quot; Starter&quot;);
-					break;
-				}
-				case PRODUCT_HOME_BASIC_N:
-				{
-					index += sprintf(version + index, &quot; Home Basic N&quot;);
-					break;
-				}
-				case PRODUCT_HOME_BASIC:
-				{
-					index += sprintf(version + index, &quot; Home Basic&quot;);
-					break;
-				}
-				case PRODUCT_HOME_PREMIUM:
-				{
-					index += sprintf(version + index, &quot; Home Premium&quot;);
-					break;
-				}
-				case PRODUCT_BUSINESS_N:
-				{
-					index += sprintf(version + index, &quot; Business N&quot;);
-					break;
-				}
-				case PRODUCT_BUSINESS:
-				{
-					index += sprintf(version + index, &quot; Business&quot;);
-					break;
-				}
-				case PRODUCT_ENTERPRISE:
-				{
-					index += sprintf(version + index, &quot; Enterprise&quot;);
-					break;
-				}
-				case PRODUCT_ULTIMATE:
-				{
-					index += sprintf(version + index, &quot; Ultimate&quot;);
-					break;
-				}
-				default:
-					break;
-				}
-			}
-		}
-		else if (osvi.wProductType == VER_NT_SERVER)
-		{
-			index += sprintf(version + index, &quot;Microsoft Windows Server 2008&quot;);
-
-			if (osvi.wSuiteMask &amp; VER_SUITE_DATACENTER)
-				index += sprintf(version + index, &quot; Datacenter Edition&quot;);
-			else if (osvi.wSuiteMask &amp; VER_SUITE_ENTERPRISE)
-				index += sprintf(version + index, &quot; Enterprise Edition&quot;);
-			else if (osvi.wSuiteMask == VER_SUITE_BLADE)
-				index += sprintf(version + index, &quot; Web Edition&quot;);
-			else
-				index += sprintf(version + index, &quot; Standard Edition&quot;);
-		}
-	}
-// Windows Server 2003
-	else if (osvi.dwMajorVersion == 5 &amp;&amp; osvi.dwMinorVersion == 2)
-	{
-		index += sprintf(version + index, &quot;Microsoft Windows Server 2003&quot;);
-
-		if (GetSystemMetrics(SM_SERVERR2))
-			index += sprintf(version + index, &quot; R2&quot;);
-
-		if (osvi.wSuiteMask &amp; VER_SUITE_DATACENTER)
-			index += sprintf(version + index, &quot; Datacenter Edition&quot;);
-		else if (osvi.wSuiteMask &amp; VER_SUITE_ENTERPRISE)
-			index += sprintf(version + index, &quot; Enterprise Edition&quot;);
-		else if (osvi.wSuiteMask == VER_SUITE_BLADE)
-			index += sprintf(version + index, &quot; Web Edition&quot;);
-		else
-			index += sprintf(version + index, &quot; Standard Edition&quot;);
-	}
-// Windows XP
-	else if (osvi.dwMajorVersion == 5 &amp;&amp; osvi.dwMinorVersion == 1)
-	{
-		index += sprintf(version + index, &quot;Microsoft Windows XP&quot;);
-
-		if (GetSystemMetrics(SM_MEDIACENTER))
-			index += sprintf(version + index, &quot; Media Center Edition&quot;);
-		else if (GetSystemMetrics(SM_STARTER))
-			index += sprintf(version + index, &quot; Starter Edition&quot;);
-		else if (GetSystemMetrics(SM_TABLETPC))
-			index += sprintf(version + index, &quot; Tablet PC Edition&quot;);
-		else if (osvi.wSuiteMask &amp; VER_SUITE_PERSONAL)
-			index += sprintf(version + index, &quot; Home Edition&quot;);
-		else
-			index += sprintf(version + index, &quot; Professional&quot;);
-	}
-// Windows 2000
-	else if (osvi.dwMajorVersion == 5 &amp;&amp; osvi.dwMinorVersion == 0)
-	{
-		index += sprintf(version + index, &quot;Microsoft Windows 2000&quot;);
-
-		if (osvi.wProductType == VER_NT_WORKSTATION)
-		{
-			index += sprintf(version + index, &quot; Professional&quot;);
-		}
-		else if (osvi.wProductType == VER_NT_SERVER)
-		{
-			if (osvi.wSuiteMask &amp; VER_SUITE_DATACENTER)
-				index += sprintf(version + index, &quot; Datacenter Server&quot;);
-			else if (osvi.wSuiteMask &amp; VER_SUITE_ENTERPRISE)
-				index += sprintf(version + index, &quot; Advanced Server&quot;);
-			else
-				index += sprintf(version + index, &quot; Server&quot;);
-		}
-	}
-// Windows NT 4
-	else if (osvi.dwMajorVersion == 4)
-	{
-		index += sprintf(version + index, &quot;Microsoft Windows NT 4&quot;);
-
-		if (osvi.wProductType == VER_NT_WORKSTATION)
-		{
-			index += sprintf(version + index, &quot; Workstation&quot;);
-		}
-		else if (osvi.wProductType == VER_NT_SERVER)
-		{
-			if (osvi.wSuiteMask &amp; VER_SUITE_ENTERPRISE)
-				index += sprintf(version + index, &quot; Server, Enterprise Edition&quot;);
-			else
-				index += sprintf(version + index, &quot; Server&quot;);
-		}
-	}
-	else
-	{
-		index += sprintf(version + index, &quot;Microsoft Windows&quot;);
-	}
-
-// Service pack and full version info
-	if (strlen(osvi.szCSDVersion) &gt; 0)
-	{
-		index += sprintf(version + index, &quot; %s&quot;, osvi.szCSDVersion);
-	}
-
-	index += sprintf(version + index, &quot; (%d.%d.%d&quot;, osvi.dwMajorVersion, osvi.dwMinorVersion, osvi.dwBuildNumber &amp; 0xFFFF);
-
-// 64-bit Windows
-	bool isWow64 = false;
-	HMODULE hKernel = GetModuleHandle(&quot;kernel32.dll&quot;);
-
-	if (hKernel)
-	{
-		typedef bool (*funcIsWow64Process)(void*, bool*);  
-
-	    funcIsWow64Process pIsWow64Process = (funcIsWow64Process)GetProcAddress(hKernel, &quot;IsWow64Process&quot;); 
-
-	    if (pIsWow64Process)
-	    {
-			pIsWow64Process(GetCurrentProcess(), &amp;isWow64);
-		}
-	}
-
-	if (isWow64)
-		index += sprintf(version + index, &quot;; 64-bit&quot;);
-	else
-		index += sprintf(version + index, &quot;; 32-bit&quot;);
-
-	index += sprintf(version + index, &quot;)&quot;);
-	
-	return true;
-}
-
-#define MONITOR_DEFAULTTONEAREST    0x00000002
-
-void getWorkingArea(uint32_t *width, uint32_t *height)
-{
-	typedef void* (WINAPI *MonitorFromWindow)(HWND hwnd, uint32_t dwFlags);
-	typedef bool (WINAPI *GetMonitorInfo)(void *hMonitor, LPMONITORINFO lpmi);
-
-	static HMODULE user32 = GetModuleHandle(&quot;user32.dll&quot;);
-	static MonitorFromWindow pMonitorFromWindow = (MonitorFromWindow)GetProcAddress(user32, &quot;MonitorFromWindow&quot;);
-	static GetMonitorInfo pGetMonitorInfo = (GetMonitorInfo)GetProcAddress(user32, &quot;GetMonitorInfoA&quot;);
-
-	if (pMonitorFromWindow == NULL)
-	{
-		RECT rect;
-
-		// Required for NT4 - no multi-monitor support
-		SystemParametersInfo(SPI_GETWORKAREA, 0, &amp;rect, 0);
-
-		*width = rect.right - rect.left;
-		*height = rect.bottom - rect.top;
-	}
-	else
-	{
-		void *hMonitor = pMonitorFromWindow(GetForegroundWindow(), MONITOR_DEFAULTTONEAREST);
-
-		MONITORINFO monitorInfo;
-
-		monitorInfo.cbSize = sizeof(MONITORINFO);
-		pGetMonitorInfo(hMonitor, &amp;monitorInfo);
-
-		*width = monitorInfo.rcWork.right - monitorInfo.rcWork.left;
-		*height = monitorInfo.rcWork.bottom - monitorInfo.rcWork.top;
-	}
-}
-
-void redirectStdoutToFile(void)
-{
-	// Don't redirect stdout and stderr if SDL hasn't already hijacked it.
-	// This allows us to optionally compile all EXEs as console applications
-	// so the output can be printed to the terminal for debugging purposes.
-
-#ifdef USE_SDL
-	// Close SDL generated logs
-	fclose(stdout);
-	fclose(stderr);
-
-	// Briefly redirect to console
-	freopen(&quot;CON&quot;, &quot;w&quot;, stdout);
-	freopen(&quot;CON&quot;, &quot;w&quot;, stderr);
-
-	// Remove SDL logs to avoid confusion
-	char path[MAX_PATH];
-	char stdoutPath[MAX_PATH];
-	char stderrPath[MAX_PATH];
-	DWORD pathlen = GetModuleFileName(NULL, path, MAX_PATH);
-
-	while (pathlen &gt; 0 &amp;&amp; path[pathlen] != '\\')
-		pathlen--;
-
-	path[pathlen] = '\0';
-
-	strcpy(stdoutPath, path);
-	strcat(stdoutPath, &quot;\\stdout.txt&quot;);
-	strcpy(stderrPath, path);
-	strcat(stderrPath, &quot;\\stderr.txt&quot;);
-
-	remove(stdoutPath);
-	remove(stderrPath);
-
-	// Redirect output to log file in the user's profile directory
-	const char* logFile = &quot;admlog.txt&quot;;
-	char* baseDir = ADM_getBaseDir();
-	char *logPath = new char[strlen(baseDir) + 2 + strlen(logFile)];
-	FILE* stream;
-
-	strcpy(logPath, baseDir);
-	strcat(logPath, &quot;/&quot;);
-	strcat(logPath, logFile);
-
-	stream = freopen(logPath, &quot;w&quot;, stdout);
-	*stderr = *stream;
-
-	// Line buffering
-	setvbuf(stdout, NULL, _IOLBF, BUFSIZ); 
-	setvbuf(stderr, NULL, _IOLBF, BUFSIZ);
-
-	delete[] logPath;
-#endif
-}
-#endif


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001070.html">[Avidemux-svn-commit] r3804 - in	branches/avidemux_2.5_branch_gruntster: . cmake
</A></li>
	<LI>Next message: <A HREF="001072.html">[Avidemux-svn-commit] r3806 - in	branches/avidemux_2.5_branch_mean/avidemux: . ADM_core	ADM_core/include ADM_core/src ADM_osSupport
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1071">[ date ]</a>
              <a href="thread.html#1071">[ thread ]</a>
              <a href="subject.html#1071">[ subject ]</a>
              <a href="author.html#1071">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">More information about the Avidemux-svn-commit
mailing list</a><br>
</body></html>
