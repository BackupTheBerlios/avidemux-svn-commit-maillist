<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Avidemux-svn-commit] r3806 - in	branches/avidemux_2.5_branch_mean/avidemux: . ADM_core	ADM_core/include ADM_core/src ADM_osSupport
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/avidemux-svn-commit/2008-February/index.html" >
   <LINK REL="made" HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r3806%20-%20in%0A%09branches/avidemux_2.5_branch_mean/avidemux%3A%20.%20ADM_core%0A%09ADM_core/include%20ADM_core/src%20ADM_osSupport&In-Reply-To=%3C200802271950.m1RJoijs008763%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001071.html">
   <LINK REL="Next"  HREF="001073.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Avidemux-svn-commit] r3806 - in	branches/avidemux_2.5_branch_mean/avidemux: . ADM_core	ADM_core/include ADM_core/src ADM_osSupport</H1>
    <B>mean at BerliOS</B> 
    <A HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r3806%20-%20in%0A%09branches/avidemux_2.5_branch_mean/avidemux%3A%20.%20ADM_core%0A%09ADM_core/include%20ADM_core/src%20ADM_osSupport&In-Reply-To=%3C200802271950.m1RJoijs008763%40sheep.berlios.de%3E"
       TITLE="[Avidemux-svn-commit] r3806 - in	branches/avidemux_2.5_branch_mean/avidemux: . ADM_core	ADM_core/include ADM_core/src ADM_osSupport">mean at mail.berlios.de
       </A><BR>
    <I>Wed Feb 27 20:50:44 CET 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="001071.html">[Avidemux-svn-commit] r3805 - in	branches/avidemux_2.5_branch_mean/avidemux: ADM_core	ADM_core/src ADM_osSupport
</A></li>
        <LI>Next message: <A HREF="001073.html">[Avidemux-svn-commit] r3807 -	branches/avidemux_2.5_branch_mean/avidemux
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1072">[ date ]</a>
              <a href="thread.html#1072">[ thread ]</a>
              <a href="subject.html#1072">[ subject ]</a>
              <a href="author.html#1072">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: mean
Date: 2008-02-27 20:50:43 +0100 (Wed, 27 Feb 2008)
New Revision: 3806

Added:
   branches/avidemux_2.5_branch_mean/avidemux/ADM_osSupport/ADM_crashHook.cpp
   branches/avidemux_2.5_branch_mean/avidemux/ADM_osSupport/ADM_fileio.cpp
   branches/avidemux_2.5_branch_mean/avidemux/ADM_osSupport/ADM_misc.cpp
Removed:
   branches/avidemux_2.5_branch_mean/avidemux/ADM_core/src/ADM_fileio.cpp
Modified:
   branches/avidemux_2.5_branch_mean/avidemux/ADM_core/CMakeLists.txt
   branches/avidemux_2.5_branch_mean/avidemux/ADM_core/include/ADM_assert.h
   branches/avidemux_2.5_branch_mean/avidemux/ADM_core/src/ADM_cpuCap.cpp
   branches/avidemux_2.5_branch_mean/avidemux/ADM_core/src/ADM_crashdump.cpp
   branches/avidemux_2.5_branch_mean/avidemux/ADM_core/src/ADM_misc.cpp
   branches/avidemux_2.5_branch_mean/avidemux/ADM_core/src/TLK_clock.cpp
   branches/avidemux_2.5_branch_mean/avidemux/ADM_osSupport/ADM_quota.cpp
   branches/avidemux_2.5_branch_mean/avidemux/ADM_osSupport/CMakeLists.txt
   branches/avidemux_2.5_branch_mean/avidemux/CMakeLists.txt
   branches/avidemux_2.5_branch_mean/avidemux/main.cpp
Log:
[Core] Split ADM_core to be autonomous


Modified: branches/avidemux_2.5_branch_mean/avidemux/ADM_core/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_mean/avidemux/ADM_core/CMakeLists.txt	2008-02-27 19:50:36 UTC (rev 3805)
+++ branches/avidemux_2.5_branch_mean/avidemux/ADM_core/CMakeLists.txt	2008-02-27 19:50:43 UTC (rev 3806)
@@ -1,12 +1 @@
-subdirs(PREORDER ADM_NONE)
-subdirs(PREORDER ADM_commonUI)
-
-if(GTK_FOUND)
-subdirs(PREORDER ADM_GTK)
-endif(GTK_FOUND)
-
-if(QT4_FOUND)
-subdirs(PREORDER ADM_QT4)
-endif(QT4_FOUND)
-
-include_directories(ADM_commonUI)
+subdirs(PREORDER src)

Modified: branches/avidemux_2.5_branch_mean/avidemux/ADM_core/include/ADM_assert.h
===================================================================
--- branches/avidemux_2.5_branch_mean/avidemux/ADM_core/include/ADM_assert.h	2008-02-27 19:50:36 UTC (rev 3805)
+++ branches/avidemux_2.5_branch_mean/avidemux/ADM_core/include/ADM_assert.h	2008-02-27 19:50:43 UTC (rev 3806)
@@ -13,6 +13,12 @@
 #ifdef __cplusplus
 extern &quot;C&quot; {
 #endif
+
+typedef void *ADM_saveFunction(void);
+typedef void *ADM_fatalFunction(const char *title, const char *info);
+
+void ADM_setCrashHook(ADM_saveFunction *save, ADM_fatalFunction *fatal);
+
 void   ADM_backTrack(int lineno,const char *file);
 size_t ADM_fread (void *ptr, size_t size, size_t n, FILE *sstream);
 size_t ADM_fwrite (void *ptr, size_t size, size_t n, FILE *sstream);

Modified: branches/avidemux_2.5_branch_mean/avidemux/ADM_core/src/ADM_cpuCap.cpp
===================================================================
--- branches/avidemux_2.5_branch_mean/avidemux/ADM_core/src/ADM_cpuCap.cpp	2008-02-27 19:50:36 UTC (rev 3805)
+++ branches/avidemux_2.5_branch_mean/avidemux/ADM_core/src/ADM_cpuCap.cpp	2008-02-27 19:50:43 UTC (rev 3806)
@@ -22,8 +22,10 @@
 #include &quot;ADM_default.h&quot;
 
 
-#include &quot;prefs.h&quot;
+//#include &quot;prefs.h&quot;
 
+uint32_t CpuCaps::myCpuCaps=0;
+uint32_t CpuCaps::myCpuMask=0xffffffff;
 /* Cpu caps interface to other libs */
 extern &quot;C&quot;{ 
 	int ADM_lavcodec_mm_support(void);
@@ -58,7 +60,7 @@
 	printf(&quot;[cpuCaps]Checking CPU capabilities\n&quot;);
 	myCpuCaps=0;
 	myCpuMask=0xffffffff;
-	prefs-&gt;get(FEATURE_CPU_CAPS,&amp;myCpuMask);
+	// FIXME prefs-&gt;get(FEATURE_CPU_CAPS,&amp;myCpuMask);
 
 #if defined(ARCH_X86) || defined(ARCH_X86_64)
 int rval = 0;

Modified: branches/avidemux_2.5_branch_mean/avidemux/ADM_core/src/ADM_crashdump.cpp
===================================================================
--- branches/avidemux_2.5_branch_mean/avidemux/ADM_core/src/ADM_crashdump.cpp	2008-02-27 19:50:36 UTC (rev 3805)
+++ branches/avidemux_2.5_branch_mean/avidemux/ADM_core/src/ADM_crashdump.cpp	2008-02-27 19:50:43 UTC (rev 3806)
@@ -35,15 +35,21 @@
 
 
 #include &quot;ADM_toolkit/toolkit.hxx&quot;
-#include &quot;ADM_userInterfaces/ADM_commonUI/DIA_factory.h&quot;
-#include &quot;ADM_editor/ADM_edit.hxx&quot;
-extern ADM_Composer *video_body;
 
 #define CRASH_FILE &quot;crash.js&quot;
+// Our callback to give UI formatted informations....
 
-static void saveCrashProject(void);
-extern char *ADM_getBaseDir(void);
-extern void A_parseECMAScript(const char *name);
+static ADM_saveFunction *mysaveFunction=NULL;
+static ADM_fatalFunction *myFatalFunction=NULL;
+/**
+        \fn ADM_setCrashHook
+        \brief install crash handlers (save + display)
+*/
+void ADM_setCrashHook(ADM_saveFunction *save, ADM_fatalFunction *fatal)
+{
+        mysaveFunction=save;
+        myFatalFunction=fatal;
+}
 
 #ifdef __APPLE__
 void installSigHandler() {}
@@ -51,10 +57,10 @@
 void ADM_backTrack(int lineno,const char *file)
 {
 	char bfr[1024];
-	saveCrashProject();
+	if(mysaveFunction) mysaveFunction();
 	snprintf(bfr,1024,&quot;Assert Failed at file %s, line %d\n&quot;,file,lineno);
-	GUI_Error_HIG(&quot;Fatal Error&quot;,bfr);
-	assert(0);
+        if(myFatalFunction) myFatalFunction(&quot;Crash&quot;,bfr);
+        exit(-1);
 }
 #elif defined(WIN32)
 typedef struct STACK_FRAME
@@ -205,19 +211,17 @@
 {	
 	fflush(stderr);
 	fflush(stdout);
-	saveCrashProject();
+	if(mysaveFunction) mysaveFunction();
 
-	GUI_Error_HIG(QT_TR_NOOP(&quot;Fatal Error&quot;),QT_TR_NOOP(&quot;A fatal error has occurred.\n\nClick OK to generate debug information. This may take a few minutes to complete.&quot;));
+        if(myFatalFunction) myFatalFunction (&quot;Crash&quot;,&quot;Press ok to build crash info&quot;);
+	
 
 	void* currentProcessId = GetCurrentProcess();
 
 	SymInitialize(currentProcessId, NULL, TRUE);
 	dumpBackTrace(currentProcessId);
 	SymCleanup(currentProcessId);
-
-	printf(&quot;Assert failed at file %s, line %d\n\n&quot;,file,lineno);
-
-	exit(1);
+	exit(-11);
 }
 
 EXCEPTION_DISPOSITION exceptionHandler(struct _EXCEPTION_RECORD* pExceptionRec, void* pEstablisherFrame, struct _CONTEXT* pContextRecord, void* pDispatcherContext)
@@ -231,9 +235,9 @@
 
 	running=1;
 
-	saveCrashProject();
+	if(mysaveFunction) mysaveFunction();
 
-	GUI_Error_HIG(QT_TR_NOOP(&quot;Fatal Error&quot;),QT_TR_NOOP(&quot;A fatal error has occurred.\n\nClick OK to generate debug information. This may take a few minutes to complete.&quot;));
+        if(myFatalFunction) myFatalFunction (&quot;Crash&quot;,&quot;Press ok to build crash info&quot;);
 
 	void* currentProcessId = GetCurrentProcess();
 
@@ -248,6 +252,7 @@
 	exit(1);
 }
 #else
+// Linux
 #include &lt;signal.h&gt;
 #include &lt;execinfo.h&gt;
 void sig_segfault_handler(int signo);
@@ -255,7 +260,6 @@
 {
     signal(11, sig_segfault_handler); // show stacktrace on default
 }
-extern void ADMImage_stat( void );
 
 static int lenCount(uint8_t *start,uint8_t *end,int *d)
 {
@@ -368,7 +372,7 @@
      char **functions;
      int count, i;
       
-     saveCrashProject();
+	if(mysaveFunction) mysaveFunction();
       printf(&quot;\n*********** BACKTRACK **************\n&quot;);
       count = backtrace(stack, 20);
       functions = backtrace_symbols(stack, count);
@@ -380,70 +384,8 @@
             
          }
       printf(&quot;*********** BACKTRACK **************\n&quot;);
-     // Now use dialogFactory
-      char bfr[30];
-      snprintf(bfr,30,&quot;Line:%u&quot;,lineno);
-      diaElemReadOnlyText *txt[count+1];
-      txt[0]=new diaElemReadOnlyText(bfr,file);
-      
-      for(i=0;i&lt;count;i++)
-          txt[i+1]=new diaElemReadOnlyText(functions[i],&quot;Function:&quot;);
-      const char *title=&quot;Crash BackTrace&quot;;
-      if(lineno) title=&quot;Assert failed&quot;;
-      diaFactoryRun(title,count+1,(diaElem **)txt);
-      
-      //
-     printf(&quot;Memory stat:\n&quot;);
-     ADMImage_stat();
-
-     exit(1); // _exit(1) ???
+      if(myFatalFunction) myFatalFunction(&quot;Crash&quot;,&quot;&quot;); // FIXME
+      exit(-1); // _exit(1) ???
 }
 #endif
-/**
-    \fn saveCrashProject
-    \brief Try to save the current project, useful in case of crash
-*/
-void saveCrashProject(void)
-{
-  char *baseDir=ADM_getBaseDir();
-  char *name=CRASH_FILE;
-  static int crashCount=0;
-  if(crashCount) return ; // avoid endless looping
-  crashCount++;
-  char *where=new char[strlen(baseDir)+strlen(name)+2];
-  strcpy(where,baseDir);
-  strcat(where,&quot;/&quot;);
-  strcat(where,name);
-  printf(&quot;Saving crash file to %s\n&quot;,where);
-  video_body-&gt;saveAsScript (where, NULL);
-  delete[] where;
-}
-/**
-    \fn checkCrashFile
-    \brief Check if there i a crash file
-*/
-
-void checkCrashFile(void)
-{
-  char *baseDir=ADM_getBaseDir();
-  char *name=CRASH_FILE;
-  static int crashCount=0;
-  char *where=new char[strlen(baseDir)+strlen(name)+2];
-  strcpy(where,baseDir);
-  strcat(where,&quot;/&quot;);
-  strcat(where,name);
-  if(ADM_fileExist(where))
-  {
-    if(GUI_Confirmation_HIG(QT_TR_NOOP(&quot;Load it&quot;),QT_TR_NOOP(&quot;Crash file&quot;),
-       QT_TR_NOOP(&quot;I have detected a crash file. \nDo you want to load it  ?\n(It will be deleted in all cases, you should save it if you want to keep it)&quot;)))
-    {
-       A_parseECMAScript(where);
-    }
-    unlink(where);
-  }else
-  {
-    printf(&quot;No crash file (%s)\n&quot;,where); 
-  }
-  delete [] where;
-}
 //EOF

Deleted: branches/avidemux_2.5_branch_mean/avidemux/ADM_core/src/ADM_fileio.cpp
===================================================================
--- branches/avidemux_2.5_branch_mean/avidemux/ADM_core/src/ADM_fileio.cpp	2008-02-27 19:50:36 UTC (rev 3805)
+++ branches/avidemux_2.5_branch_mean/avidemux/ADM_core/src/ADM_fileio.cpp	2008-02-27 19:50:43 UTC (rev 3806)
@@ -1,410 +0,0 @@
-/***************************************************************************
-                    
-    copyright            : (C) 2006 by mean
-    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#include &quot;config.h&quot; 
-#include &lt;stdio.h&gt;
-#include &lt;stdlib.h&gt;
-#include &lt;string.h&gt;
-    
-#include &lt;dirent.h&gt;
-#include &lt;errno.h&gt;
-#include &lt;sys/stat.h&gt;
-
-#include &lt;unistd.h&gt;
-
-#ifdef WIN32
-#include &lt;glib.h&gt;
-#endif
-
-#include &quot;ADM_default.h&quot;
-
-
-
-#include &quot;ADM_toolkit/filesel.h&quot;
-#include &quot;ADM_toolkit/toolkit.hxx&quot;
-
-#include &quot;ADM_assert.h&quot;
-#undef fread
-#undef fwrite
-#undef fopen
-#undef fclose
-
-size_t ADM_fread (void *ptr, size_t size, size_t n, FILE *sstream)
-{
-  return fread(ptr,size,n,sstream); 
-  
-}
-
-size_t ADM_fwrite (void *ptr, size_t size, size_t n, FILE *sstream)
-{
-  return fwrite(ptr,size,n,sstream); 
-  
-}
-FILE  *ADM_fopen (const char *file, const char *mode)
-{
-  FILE *f;
-
-#ifndef ADM_WIN32
-  return fopen(file,mode); 
-#else
-  gchar *retval = g_locale_from_utf8 (file, -1, NULL, NULL, NULL);
-  f=fopen(retval,mode);
-  g_free (retval);
-  return f;  
-#endif
-}
-
-int    ADM_fclose (FILE *file)
-{
-  return fclose(file); 
-}
-//*****************************
-static char basedir[1024]={0};
-static char jobdir[1024]={0};
-static char customdir[1024]={0};
-int baseDirDone=0;
-int jobDirDone=0;
-int customDirDone=0;
-#ifdef ADM_WIN32
-const char *ADM_DIR_NAME=&quot;\\avidemux&quot;;
-#else
-const char *ADM_DIR_NAME=&quot;/.avidemux&quot;;
-#endif
-/*
-
-*/
-/*
-      Get the  directory where jobs are stored
-******************************************************/
-
-char *ADM_getCustomDir(void)
-{
-  if(customDirDone) return customdir;
-
-  char *rootDir;
-  rootDir=ADM_getBaseDir();
-  strncpy(customdir,rootDir,1023);
-#if defined(ADM_WIN32)
-  strcat(customdir,&quot;\\custom&quot;); 
-#else
-  strcat(customdir,&quot;/custom&quot;);
-#endif
-  if(!ADM_mkdir(customdir))
-  {
-    GUI_Error_HIG(QT_TR_NOOP(&quot;Oops&quot;),QT_TR_NOOP(&quot;can't create custom directory (%s).&quot;),customdir);
-                return NULL;
-  }
-  customDirDone=1;
-  return customdir;
-}
-/*
-      Get the  directory where jobs are stored
-******************************************************/
-
-char *ADM_getJobDir(void)
-{
-  if(jobDirDone) return jobdir;
-
-  char *rootDir;
-  rootDir=ADM_getBaseDir();
-  strncpy(jobdir,rootDir,1023);
-#if defined(ADM_WIN32)
-  strcat(jobdir,&quot;\\jobs&quot;); 
-#else
-  strcat(jobdir,&quot;/jobs&quot;);
-#endif
-  if(!ADM_mkdir(jobdir))
-  {
-    GUI_Error_HIG(QT_TR_NOOP(&quot;Oops&quot;),QT_TR_NOOP(&quot;can't create job directory (%s).&quot;),jobdir);
-                return NULL;
-  }
-  jobDirDone=1;
-  return jobdir;
-}
-/*
-      Get the root directory for .avidemux stuff
-******************************************************/
-char *ADM_getBaseDir(void)
-{
-char *dirname=NULL;
-DIR *dir=NULL;
-char *home;
-//
-        if(baseDirDone) return basedir;
-// Get the base directory
-#if defined(ADM_WIN32)
-        if( ! (home=getenv(&quot;USERPROFILE&quot;)) )
-        {
-          GUI_Error_HIG(QT_TR_NOOP(&quot;Oops&quot;),QT_TR_NOOP(&quot;can't determine $USERPROFILE.&quot;));
-                    home=&quot;c:\\&quot;;
-        }
-
-#else
-        if( ! (home=getenv(&quot;HOME&quot;)) )
-        {
-          GUI_Error_HIG(QT_TR_NOOP(&quot;Oops&quot;),QT_TR_NOOP(&quot;can't determine $HOME.&quot;));
-                return NULL;
-        }
-#endif
-
- // Try to open the .avidemux directory
-        dirname=new char[strlen(home)+strlen(ADM_DIR_NAME)+2];
-        strcpy(dirname,home);
-        strcat(dirname,ADM_DIR_NAME);
-        if(!ADM_mkdir(dirname))
-        {
-          GUI_Error_HIG(QT_TR_NOOP(&quot;Oops&quot;),QT_TR_NOOP(&quot;Cannot create the .avidemux directory&quot;), NULL);
-                        delete [] dirname;
-                        return NULL;
-        }
-        delete [] dirname;
-
-        // Now built the filename
-        strncpy(basedir,home,1023);
-        strncat(basedir,ADM_DIR_NAME,1023-strlen(basedir));
-        baseDirDone=1;
-        printf(&quot;Using %s as base directory for prefs/jobs/...\n&quot;,basedir);
-        return basedir;
-}
-/*----------------------------------------
-      Create a directory
-      If it already exists, do nothing
-------------------------------------------*/
-uint8_t ADM_mkdir(const char *dirname)
-{
-DIR *dir=NULL;
-              // Check it already exists ?
-              dir=opendir(dirname);
-              if(dir)
-              { 
-                  printf(&quot;Directory %s exists.Good.\n&quot;,dirname);
-                  closedir(dir);
-                  return 1;
-              }
-#if defined(ADM_WIN32)
-                if(mkdir(dirname))
-                {
-                    printf(&quot;Oops: mkdir failed on %s\n&quot;,dirname);   
-                    return 0;
-                }
-                
-#else    
-                char *sys=new char[strlen(dirname)+strlen(&quot;mkdir &quot;)+2];
-                strcpy(sys,&quot;mkdir &quot;);
-                strcat(sys,dirname);
-                printf(&quot;Creating dir :%s\n&quot;,sys);
-                system(sys);
-                delete [] sys;
-#endif		
-              if((dir=opendir(dirname))==NULL)
-                {
-                        return 0;
-                }
-              closedir(dir); 
-              return 1;
-}
-uint8_t buildDirectoryContent(uint32_t *outnb,const char *base, char *jobName[],int maxElems,const char *ext)
-{
-
-DIR *dir;
-struct dirent *direntry;
-int dirmax=0,len;
-int extlen=strlen(ext);
-    ADM_assert(extlen);
-    
-         dir=opendir(base);
-        if(!dir)
-        {
-                return 0;
-        }
-        while((direntry=readdir(dir)))
-        {
-                len=strlen(direntry-&gt;d_name);
-                if(len&lt;(extlen+1)) continue;
-                int xbase=len-extlen;
-                if(memcmp(direntry-&gt;d_name+xbase,ext,extlen))
-                //if(direntry-&gt;d_name[len-1]!='s' || direntry-&gt;d_name[len-2]!='j' || direntry-&gt;d_name[len-3]!='.')
-                {
-                        printf(&quot;ignored:%s\n&quot;,direntry-&gt;d_name);
-                        continue;
-                }
-                jobName[dirmax]=(char *)ADM_alloc(strlen(base)+strlen(direntry-&gt;d_name)+2);
-                strcpy(jobName[dirmax],base);
-                strcat(jobName[dirmax],&quot;/&quot;);
-                strcat(jobName[dirmax],direntry-&gt;d_name);
-                dirmax++;
-                if(dirmax&gt;=maxElems)
-                {
-                        printf(&quot;[jobs]: Max # of jobs exceeded\n&quot;);
-                         break;
-                }
-        }
-        closedir(dir);
-        *outnb=dirmax;
-        return 1;
-}
-//------------------------------------------------------------------
-
-/*
-
-** note: it modifies it's first argument
-*/
-void simplify_path(char **buf){
-   unsigned int last1slash = 0;
-   unsigned int last2slash = 0;
-	while( !strncmp(*buf,&quot;/../&quot;,4) )
-		memmove(*buf,*buf+3,strlen(*buf+3)+1);
-	for(unsigned int i=0;i&lt;strlen(*buf)-2;i++)
-		while( !strncmp(*buf+i,&quot;/./&quot;,3) )
-			memmove(*buf+i,*buf+i+2,strlen(*buf+i+2)+1);
-	for(unsigned int i=0;i&lt;strlen(*buf)-3;i++){
-		if( *(*buf+i) == '/' ){
-			last2slash = last1slash;
-			last1slash = i;
-		}
-		if( !strncmp(*buf+i,&quot;/../&quot;,4) ){
-			memmove(*buf+last2slash,*buf+i+3,strlen(*buf+i+3)+1);
-			return simplify_path(buf);
-		}
-	}
-}
-
-//
-//	Make it absolute
-//
-char *PathCanonize(const char *tmpname)
-{
-	char path[300];
-	char *out ;
-
-	if( ! getcwd(path,300) ){
-		fprintf(stderr,&quot;\ngetcwd() failed with: %s (%u)\n&quot;,
-		               strerror(errno), errno );
-		path[0] = '\0';
-	}
-	if(!tmpname || tmpname[0]==0)
-	{
-		out=new char [strlen(path)+2];
-		strcpy(out,path);
-#ifndef ADM_WIN32		
-		strcat(out,&quot;/&quot;);
-#else
-		strcat(out,&quot;\\&quot;);
-#endif	
-		printf(&quot;\n Canonizing null string ??? (%s)\n&quot;,out);
-	}else if(tmpname[0]=='/'
-#if defined(ADM_WIN32)
-		|| tmpname[1]==':'
-#endif	
-	
-	)
-	{
-		out=new char[strlen(tmpname)+1];
-		strcpy(out,tmpname);
-		return out;
-	}else{
-		out=new char[strlen(path)+strlen(tmpname)+6];
-		strcpy(out,path);
-#ifndef ADM_WIN32		
-		strcat(out,&quot;/&quot;);
-#else
-		strcat(out,&quot;\\&quot;);
-#endif		
-		strcat(out,tmpname);
-	}
-	simplify_path(&amp;out);
-	return out;
-}
-/*
-	Strip the path and only keep the name
-
-*/
-void		PathStripName(char *str)
-{
-		int len=strlen(str);
-		if(len&lt;=1) return;
-		len--;
-#ifndef ADM_WIN32		
-		while( *(str+len)!='/' &amp;&amp; len)
-#else
-	while( *(str+len)!='\\' &amp;&amp; len)
-#endif		
-		{
-			 *(str+len)=0;
-			 len--;
-		}
-}
-
-/*
-	Get the filename without path
-
-*/
-const char *GetFileName(const char *str)
-{
-	char *filename;
-        char *filename2;
-#ifndef ADM_WIN32		
-	filename = strrchr(str, '/');
-        
-#else
-	filename = strrchr(str, '\\');
-        filename2 = strrchr(str, '/');
-        if(filename2 &amp;&amp; filename)
-        {
-          if(filename2&gt;filename) filename=filename2; 
-        }
-#endif
-	if (filename)
-		return filename+1;
-	else
-		return str;
-}
-
-/*
-	Split patch into absolute path+name and extention
-
-*/
-void PathSplit(char *str, char **root, char **ext)
-{
-	char *full;
-	uint32_t l;
-
-		full=PathCanonize(str);
-		// Search the last .
-		l=strlen(full);
-		l--;
-		ADM_assert(l&gt;0);
-		while( *(full+l)!='.' &amp;&amp; l) l--;
-		if(!l || l==(strlen(full)-1))
-		{
-			if(l==(strlen(full)-1))
-			{
-				*(full+l)=0;  // remove trailing .
-			}
-			*ext=new char[2];
-			*root=full;
-			strcpy(*ext,&quot;&quot;);
-			return ;
-		}
-		// else we do get an extension
-		// starting at l+1
-		uint32_t suff;
-
-		suff=strlen(full)-l-1;
-		*ext=new char[suff+1];
-		strcpy(*ext,full+l+1);
-		*(full+l)=0;
-		*root=full;
-		return ;
-}

Modified: branches/avidemux_2.5_branch_mean/avidemux/ADM_core/src/ADM_misc.cpp
===================================================================
--- branches/avidemux_2.5_branch_mean/avidemux/ADM_core/src/ADM_misc.cpp	2008-02-27 19:50:36 UTC (rev 3805)
+++ branches/avidemux_2.5_branch_mean/avidemux/ADM_core/src/ADM_misc.cpp	2008-02-27 19:50:43 UTC (rev 3806)
@@ -34,7 +34,8 @@
 #include &quot;ADM_assert.h&quot;
 
 #include &quot;ADM_video/ADM_vidMisc.h&quot;
-
+#undef fopen
+#undef fclose
 //
 //    Sleep for n ms
 //
@@ -203,38 +204,7 @@
       return 1;
 }
 
-char* ms2timedisplay(uint32_t ms)
-{
-	uint32_t mm, ss;
-	static char string[20];
 
-	mm = (uint32_t)floor(ms / 60000.);
-	
-	if (mm &gt; 1)
-	{
-		sprintf(string, QT_TR_NOOP(&quot;%lu minutes&quot;), mm);
-	}
-	else if (mm == 1)
-	{
-		sprintf(string, QT_TR_NOOP(&quot;%lu minute&quot;), mm);
-	}
-	else
-	{
-		ss = (uint32_t)floor(ms / 1000.);
-
-		if (ss == 1)
-		{
-			sprintf(string, QT_TR_NOOP(&quot;%lu second&quot;), ss);
-		}
-		else
-		{
-			sprintf(string, QT_TR_NOOP(&quot;%lu seconds&quot;), ss);
-		}
-	}
-
-	return string;
-}
-
 // Convert everything to lowercase
 void  LowerCase(char *string)
 {

Modified: branches/avidemux_2.5_branch_mean/avidemux/ADM_core/src/TLK_clock.cpp
===================================================================
--- branches/avidemux_2.5_branch_mean/avidemux/ADM_core/src/TLK_clock.cpp	2008-02-27 19:50:36 UTC (rev 3805)
+++ branches/avidemux_2.5_branch_mean/avidemux/ADM_core/src/TLK_clock.cpp	2008-02-27 19:50:43 UTC (rev 3806)
@@ -66,7 +66,7 @@
 uint32_t Clock::getElapsedMS(void )
 {
    uint32_t ret = getAbsTime()-_startTime;
-	aprintf(&quot;Clock::getElapsedMS() -&gt; %lu\n&quot;, ret);
+	//aprintf(&quot;Clock::getElapsedMS() -&gt; %lu\n&quot;, ret);
 	return ret;
 }
 
@@ -97,7 +97,7 @@
     tt = timev.tv_usec;
     tt /= 1000;
     tt += 1000 * (timev.tv_sec-_itimev.tv_sec);
-    aprintf(&quot;getAbsTime() -&gt; %lu\n&quot;, tt&amp;0x7Fffffff);
+    //aprintf(&quot;getAbsTime() -&gt; %lu\n&quot;, tt&amp;0x7Fffffff);
     return (tt&amp;0x7Fffffff);
 
 }

Added: branches/avidemux_2.5_branch_mean/avidemux/ADM_osSupport/ADM_crashHook.cpp
===================================================================
--- branches/avidemux_2.5_branch_mean/avidemux/ADM_osSupport/ADM_crashHook.cpp	2008-02-27 19:50:36 UTC (rev 3805)
+++ branches/avidemux_2.5_branch_mean/avidemux/ADM_osSupport/ADM_crashHook.cpp	2008-02-27 19:50:43 UTC (rev 3806)
@@ -0,0 +1,95 @@
+/***************************************************************************
+  Try to display interesting crash dump
+
+    copyright            : (C) 2007 by mean, (C) 2007 Gruntster
+    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include &quot;config.h&quot;
+
+#include &lt;stdio.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;stdarg.h&gt;
+#include &lt;string.h&gt;
+#include &quot;ADM_default.h&quot;
+#include &lt;unistd.h&gt;
+
+#include &lt;math.h&gt;
+#include &lt;ADM_assert.h&gt;
+
+#if defined(ADM_WIN32)
+#define WIN32_CLASH
+#include &lt;windows.h&gt;
+#include &lt;excpt.h&gt;
+#include &lt;imagehlp.h&gt;
+#endif
+
+
+#include &quot;ADM_toolkit/toolkit.hxx&quot;
+#include &quot;ADM_userInterfaces/ADM_commonUI/DIA_factory.h&quot;
+#include &quot;ADM_editor/ADM_edit.hxx&quot;
+extern ADM_Composer *video_body;
+
+#define CRASH_FILE &quot;crash.js&quot;
+
+static void saveCrashProject(void);
+extern char *ADM_getBaseDir(void);
+extern void A_parseECMAScript(const char *name);
+
+/**
+    \fn saveCrashProject
+    \brief Try to save the current project, useful in case of crash
+*/
+void saveCrashProject(void)
+{
+  char *baseDir=ADM_getBaseDir();
+  char *name=CRASH_FILE;
+  static int crashCount=0;
+  if(crashCount) return ; // avoid endless looping
+  crashCount++;
+  char *where=new char[strlen(baseDir)+strlen(name)+2];
+  strcpy(where,baseDir);
+  strcat(where,&quot;/&quot;);
+  strcat(where,name);
+  printf(&quot;Saving crash file to %s\n&quot;,where);
+  video_body-&gt;saveAsScript (where, NULL);
+  delete[] where;
+}
+/**
+    \fn checkCrashFile
+    \brief Check if there i a crash file
+*/
+
+void checkCrashFile(void)
+{
+  char *baseDir=ADM_getBaseDir();
+  char *name=CRASH_FILE;
+  static int crashCount=0;
+  char *where=new char[strlen(baseDir)+strlen(name)+2];
+  strcpy(where,baseDir);
+  strcat(where,&quot;/&quot;);
+  strcat(where,name);
+  if(ADM_fileExist(where))
+  {
+    if(GUI_Confirmation_HIG(QT_TR_NOOP(&quot;Load it&quot;),QT_TR_NOOP(&quot;Crash file&quot;),
+       QT_TR_NOOP(&quot;I have detected a crash file. \nDo you want to load it  ?\n(It will be deleted in all cases, you should save it if you want to keep it)&quot;)))
+    {
+       A_parseECMAScript(where);
+    }
+    unlink(where);
+  }else
+  {
+    printf(&quot;No crash file (%s)\n&quot;,where); 
+  }
+  delete [] where;
+}
+//EOF

Copied: branches/avidemux_2.5_branch_mean/avidemux/ADM_osSupport/ADM_fileio.cpp (from rev 3805, branches/avidemux_2.5_branch_mean/avidemux/ADM_core/src/ADM_fileio.cpp)
===================================================================
--- branches/avidemux_2.5_branch_mean/avidemux/ADM_core/src/ADM_fileio.cpp	2008-02-27 19:50:36 UTC (rev 3805)
+++ branches/avidemux_2.5_branch_mean/avidemux/ADM_osSupport/ADM_fileio.cpp	2008-02-27 19:50:43 UTC (rev 3806)
@@ -0,0 +1,410 @@
+/***************************************************************************
+                    
+    copyright            : (C) 2006 by mean
+    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include &quot;config.h&quot; 
+#include &lt;stdio.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;string.h&gt;
+    
+#include &lt;dirent.h&gt;
+#include &lt;errno.h&gt;
+#include &lt;sys/stat.h&gt;
+
+#include &lt;unistd.h&gt;
+
+#ifdef WIN32
+#include &lt;glib.h&gt;
+#endif
+
+#include &quot;ADM_default.h&quot;
+
+
+
+#include &quot;ADM_toolkit/filesel.h&quot;
+#include &quot;ADM_toolkit/toolkit.hxx&quot;
+
+#include &quot;ADM_assert.h&quot;
+#undef fread
+#undef fwrite
+#undef fopen
+#undef fclose
+
+size_t ADM_fread (void *ptr, size_t size, size_t n, FILE *sstream)
+{
+  return fread(ptr,size,n,sstream); 
+  
+}
+
+size_t ADM_fwrite (void *ptr, size_t size, size_t n, FILE *sstream)
+{
+  return fwrite(ptr,size,n,sstream); 
+  
+}
+FILE  *ADM_fopen (const char *file, const char *mode)
+{
+  FILE *f;
+
+#ifndef ADM_WIN32
+  return fopen(file,mode); 
+#else
+  gchar *retval = g_locale_from_utf8 (file, -1, NULL, NULL, NULL);
+  f=fopen(retval,mode);
+  g_free (retval);
+  return f;  
+#endif
+}
+
+int    ADM_fclose (FILE *file)
+{
+  return fclose(file); 
+}
+//*****************************
+static char basedir[1024]={0};
+static char jobdir[1024]={0};
+static char customdir[1024]={0};
+int baseDirDone=0;
+int jobDirDone=0;
+int customDirDone=0;
+#ifdef ADM_WIN32
+const char *ADM_DIR_NAME=&quot;\\avidemux&quot;;
+#else
+const char *ADM_DIR_NAME=&quot;/.avidemux&quot;;
+#endif
+/*
+
+*/
+/*
+      Get the  directory where jobs are stored
+******************************************************/
+
+char *ADM_getCustomDir(void)
+{
+  if(customDirDone) return customdir;
+
+  char *rootDir;
+  rootDir=ADM_getBaseDir();
+  strncpy(customdir,rootDir,1023);
+#if defined(ADM_WIN32)
+  strcat(customdir,&quot;\\custom&quot;); 
+#else
+  strcat(customdir,&quot;/custom&quot;);
+#endif
+  if(!ADM_mkdir(customdir))
+  {
+    GUI_Error_HIG(QT_TR_NOOP(&quot;Oops&quot;),QT_TR_NOOP(&quot;can't create custom directory (%s).&quot;),customdir);
+                return NULL;
+  }
+  customDirDone=1;
+  return customdir;
+}
+/*
+      Get the  directory where jobs are stored
+******************************************************/
+
+char *ADM_getJobDir(void)
+{
+  if(jobDirDone) return jobdir;
+
+  char *rootDir;
+  rootDir=ADM_getBaseDir();
+  strncpy(jobdir,rootDir,1023);
+#if defined(ADM_WIN32)
+  strcat(jobdir,&quot;\\jobs&quot;); 
+#else
+  strcat(jobdir,&quot;/jobs&quot;);
+#endif
+  if(!ADM_mkdir(jobdir))
+  {
+    GUI_Error_HIG(QT_TR_NOOP(&quot;Oops&quot;),QT_TR_NOOP(&quot;can't create job directory (%s).&quot;),jobdir);
+                return NULL;
+  }
+  jobDirDone=1;
+  return jobdir;
+}
+/*
+      Get the root directory for .avidemux stuff
+******************************************************/
+char *ADM_getBaseDir(void)
+{
+char *dirname=NULL;
+DIR *dir=NULL;
+char *home;
+//
+        if(baseDirDone) return basedir;
+// Get the base directory
+#if defined(ADM_WIN32)
+        if( ! (home=getenv(&quot;USERPROFILE&quot;)) )
+        {
+          GUI_Error_HIG(QT_TR_NOOP(&quot;Oops&quot;),QT_TR_NOOP(&quot;can't determine $USERPROFILE.&quot;));
+                    home=&quot;c:\\&quot;;
+        }
+
+#else
+        if( ! (home=getenv(&quot;HOME&quot;)) )
+        {
+          GUI_Error_HIG(QT_TR_NOOP(&quot;Oops&quot;),QT_TR_NOOP(&quot;can't determine $HOME.&quot;));
+                return NULL;
+        }
+#endif
+
+ // Try to open the .avidemux directory
+        dirname=new char[strlen(home)+strlen(ADM_DIR_NAME)+2];
+        strcpy(dirname,home);
+        strcat(dirname,ADM_DIR_NAME);
+        if(!ADM_mkdir(dirname))
+        {
+          GUI_Error_HIG(QT_TR_NOOP(&quot;Oops&quot;),QT_TR_NOOP(&quot;Cannot create the .avidemux directory&quot;), NULL);
+                        delete [] dirname;
+                        return NULL;
+        }
+        delete [] dirname;
+
+        // Now built the filename
+        strncpy(basedir,home,1023);
+        strncat(basedir,ADM_DIR_NAME,1023-strlen(basedir));
+        baseDirDone=1;
+        printf(&quot;Using %s as base directory for prefs/jobs/...\n&quot;,basedir);
+        return basedir;
+}
+/*----------------------------------------
+      Create a directory
+      If it already exists, do nothing
+------------------------------------------*/
+uint8_t ADM_mkdir(const char *dirname)
+{
+DIR *dir=NULL;
+              // Check it already exists ?
+              dir=opendir(dirname);
+              if(dir)
+              { 
+                  printf(&quot;Directory %s exists.Good.\n&quot;,dirname);
+                  closedir(dir);
+                  return 1;
+              }
+#if defined(ADM_WIN32)
+                if(mkdir(dirname))
+                {
+                    printf(&quot;Oops: mkdir failed on %s\n&quot;,dirname);   
+                    return 0;
+                }
+                
+#else    
+                char *sys=new char[strlen(dirname)+strlen(&quot;mkdir &quot;)+2];
+                strcpy(sys,&quot;mkdir &quot;);
+                strcat(sys,dirname);
+                printf(&quot;Creating dir :%s\n&quot;,sys);
+                system(sys);
+                delete [] sys;
+#endif		
+              if((dir=opendir(dirname))==NULL)
+                {
+                        return 0;
+                }
+              closedir(dir); 
+              return 1;
+}
+uint8_t buildDirectoryContent(uint32_t *outnb,const char *base, char *jobName[],int maxElems,const char *ext)
+{
+
+DIR *dir;
+struct dirent *direntry;
+int dirmax=0,len;
+int extlen=strlen(ext);
+    ADM_assert(extlen);
+    
+         dir=opendir(base);
+        if(!dir)
+        {
+                return 0;
+        }
+        while((direntry=readdir(dir)))
+        {
+                len=strlen(direntry-&gt;d_name);
+                if(len&lt;(extlen+1)) continue;
+                int xbase=len-extlen;
+                if(memcmp(direntry-&gt;d_name+xbase,ext,extlen))
+                //if(direntry-&gt;d_name[len-1]!='s' || direntry-&gt;d_name[len-2]!='j' || direntry-&gt;d_name[len-3]!='.')
+                {
+                        printf(&quot;ignored:%s\n&quot;,direntry-&gt;d_name);
+                        continue;
+                }
+                jobName[dirmax]=(char *)ADM_alloc(strlen(base)+strlen(direntry-&gt;d_name)+2);
+                strcpy(jobName[dirmax],base);
+                strcat(jobName[dirmax],&quot;/&quot;);
+                strcat(jobName[dirmax],direntry-&gt;d_name);
+                dirmax++;
+                if(dirmax&gt;=maxElems)
+                {
+                        printf(&quot;[jobs]: Max # of jobs exceeded\n&quot;);
+                         break;
+                }
+        }
+        closedir(dir);
+        *outnb=dirmax;
+        return 1;
+}
+//------------------------------------------------------------------
+
+/*
+
+** note: it modifies it's first argument
+*/
+void simplify_path(char **buf){
+   unsigned int last1slash = 0;
+   unsigned int last2slash = 0;
+	while( !strncmp(*buf,&quot;/../&quot;,4) )
+		memmove(*buf,*buf+3,strlen(*buf+3)+1);
+	for(unsigned int i=0;i&lt;strlen(*buf)-2;i++)
+		while( !strncmp(*buf+i,&quot;/./&quot;,3) )
+			memmove(*buf+i,*buf+i+2,strlen(*buf+i+2)+1);
+	for(unsigned int i=0;i&lt;strlen(*buf)-3;i++){
+		if( *(*buf+i) == '/' ){
+			last2slash = last1slash;
+			last1slash = i;
+		}
+		if( !strncmp(*buf+i,&quot;/../&quot;,4) ){
+			memmove(*buf+last2slash,*buf+i+3,strlen(*buf+i+3)+1);
+			return simplify_path(buf);
+		}
+	}
+}
+
+//
+//	Make it absolute
+//
+char *PathCanonize(const char *tmpname)
+{
+	char path[300];
+	char *out ;
+
+	if( ! getcwd(path,300) ){
+		fprintf(stderr,&quot;\ngetcwd() failed with: %s (%u)\n&quot;,
+		               strerror(errno), errno );
+		path[0] = '\0';
+	}
+	if(!tmpname || tmpname[0]==0)
+	{
+		out=new char [strlen(path)+2];
+		strcpy(out,path);
+#ifndef ADM_WIN32		
+		strcat(out,&quot;/&quot;);
+#else
+		strcat(out,&quot;\\&quot;);
+#endif	
+		printf(&quot;\n Canonizing null string ??? (%s)\n&quot;,out);
+	}else if(tmpname[0]=='/'
+#if defined(ADM_WIN32)
+		|| tmpname[1]==':'
+#endif	
+	
+	)
+	{
+		out=new char[strlen(tmpname)+1];
+		strcpy(out,tmpname);
+		return out;
+	}else{
+		out=new char[strlen(path)+strlen(tmpname)+6];
+		strcpy(out,path);
+#ifndef ADM_WIN32		
+		strcat(out,&quot;/&quot;);
+#else
+		strcat(out,&quot;\\&quot;);
+#endif		
+		strcat(out,tmpname);
+	}
+	simplify_path(&amp;out);
+	return out;
+}
+/*
+	Strip the path and only keep the name
+
+*/
+void		PathStripName(char *str)
+{
+		int len=strlen(str);
+		if(len&lt;=1) return;
+		len--;
+#ifndef ADM_WIN32		
+		while( *(str+len)!='/' &amp;&amp; len)
+#else
+	while( *(str+len)!='\\' &amp;&amp; len)
+#endif		
+		{
+			 *(str+len)=0;
+			 len--;
+		}
+}
+
+/*
+	Get the filename without path
+
+*/
+const char *GetFileName(const char *str)
+{
+	char *filename;
+        char *filename2;
+#ifndef ADM_WIN32		
+	filename = strrchr(str, '/');
+        
+#else
+	filename = strrchr(str, '\\');
+        filename2 = strrchr(str, '/');
+        if(filename2 &amp;&amp; filename)
+        {
+          if(filename2&gt;filename) filename=filename2; 
+        }
+#endif
+	if (filename)
+		return filename+1;
+	else
+		return str;
+}
+
+/*
+	Split patch into absolute path+name and extention
+
+*/
+void PathSplit(char *str, char **root, char **ext)
+{
+	char *full;
+	uint32_t l;
+
+		full=PathCanonize(str);
+		// Search the last .
+		l=strlen(full);
+		l--;
+		ADM_assert(l&gt;0);
+		while( *(full+l)!='.' &amp;&amp; l) l--;
+		if(!l || l==(strlen(full)-1))
+		{
+			if(l==(strlen(full)-1))
+			{
+				*(full+l)=0;  // remove trailing .
+			}
+			*ext=new char[2];
+			*root=full;
+			strcpy(*ext,&quot;&quot;);
+			return ;
+		}
+		// else we do get an extension
+		// starting at l+1
+		uint32_t suff;
+
+		suff=strlen(full)-l-1;
+		*ext=new char[suff+1];
+		strcpy(*ext,full+l+1);
+		*(full+l)=0;
+		*root=full;
+		return ;
+}

Added: branches/avidemux_2.5_branch_mean/avidemux/ADM_osSupport/ADM_misc.cpp
===================================================================
--- branches/avidemux_2.5_branch_mean/avidemux/ADM_osSupport/ADM_misc.cpp	2008-02-27 19:50:36 UTC (rev 3805)
+++ branches/avidemux_2.5_branch_mean/avidemux/ADM_osSupport/ADM_misc.cpp	2008-02-27 19:50:43 UTC (rev 3806)
@@ -0,0 +1,35 @@
+
+#include &quot;ADM_default.h&quot;
+#include &quot;math.h&quot;
+char* ms2timedisplay(uint32_t ms)
+{
+	uint32_t mm, ss;
+	static char string[20];
+
+	mm = (uint32_t)floor(ms / 60000.);
+	
+	if (mm &gt; 1)
+	{
+		sprintf(string, QT_TR_NOOP(&quot;%lu minutes&quot;), mm);
+	}
+	else if (mm == 1)
+	{
+		sprintf(string, QT_TR_NOOP(&quot;%lu minute&quot;), mm);
+	}
+	else
+	{
+		ss = (uint32_t)floor(ms / 1000.);
+
+		if (ss == 1)
+		{
+			sprintf(string, QT_TR_NOOP(&quot;%lu second&quot;), ss);
+		}
+		else
+		{
+			sprintf(string, QT_TR_NOOP(&quot;%lu seconds&quot;), ss);
+		}
+	}
+
+	return string;
+}
+

Modified: branches/avidemux_2.5_branch_mean/avidemux/ADM_osSupport/ADM_quota.cpp
===================================================================
--- branches/avidemux_2.5_branch_mean/avidemux/ADM_osSupport/ADM_quota.cpp	2008-02-27 19:50:36 UTC (rev 3805)
+++ branches/avidemux_2.5_branch_mean/avidemux/ADM_osSupport/ADM_quota.cpp	2008-02-27 19:50:43 UTC (rev 3806)
@@ -1,3 +1,7 @@
+/**
+                \fn ADM_quota.cpp
+                \brief handle out of space error when writing to files
+*/
 #define ADM_LEGACY_PROGGY
 #include &quot;ADM_default.h&quot;
 #include &lt;errno.h&gt;
@@ -3,4 +7,5 @@
 #include &quot;ADM_quota.h&quot;
 
+#undef free
 
 extern uint8_t DIA_quota(char *);

Modified: branches/avidemux_2.5_branch_mean/avidemux/ADM_osSupport/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_mean/avidemux/ADM_osSupport/CMakeLists.txt	2008-02-27 19:50:36 UTC (rev 3805)
+++ branches/avidemux_2.5_branch_mean/avidemux/ADM_osSupport/CMakeLists.txt	2008-02-27 19:50:43 UTC (rev 3806)
@@ -1,8 +1,12 @@
 
 SET(ADM_osSupport_SRCS 
-ADM_cpuCap.cpp     ADM_debug.cpp   ADM_memcpy.cpp  ADM_memsupport.cpp  ADM_queue.cpp  ADM_threads.cpp  win32.cpp
-ADM_crashdump.cpp  ADM_fileio.cpp  ADM_memory.cpp  ADM_misc.cpp        ADM_quota.cpp  TLK_clock.cpp)
+ADM_debug.cpp   
+ADM_queue.cpp  
+ADM_crashHook.cpp  
+ADM_fileio.cpp 
+ADM_misc.cpp 
+ADM_quota.cpp)
 
 ADD_LIBRARY(ADM_osSupport STATIC ${ADM_osSupport_SRCS})
 add_definitions(${LIBXML2_DEFINITIONS})
-include_directories(${LIBXML2_INCLUDE_DIR})
\ No newline at end of file
+include_directories(${LIBXML2_INCLUDE_DIR})

Modified: branches/avidemux_2.5_branch_mean/avidemux/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_mean/avidemux/CMakeLists.txt	2008-02-27 19:50:36 UTC (rev 3805)
+++ branches/avidemux_2.5_branch_mean/avidemux/CMakeLists.txt	2008-02-27 19:50:43 UTC (rev 3806)
@@ -99,6 +99,7 @@
 ###########################################
 # Build Regular Subdirs
 ###########################################
+ADD_SUBDIRECTORY(ADM_core)
 ADD_SUBDIRECTORY(ADM_osSupport)
 ADD_SUBDIRECTORY(ADM_encoder)
 ADD_SUBDIRECTORY(ADM_toolkit)
@@ -152,6 +153,7 @@
 #########################################
 # Tails
 #########################################
+add_libs_all_targets(ADM_core)
 add_libs_all_targets(ADM_toolkit)
 add_libs_all_targets(ADM_osSupport)
 add_libs_all_targets(ADM_encoder)
@@ -199,7 +201,6 @@
 FOREACH(_current ${ADM_LIBRARIES})
 	add_libs_all_targets(${_current})
 ENDFOREACH(_current ${ADM_SUBDIR})
-
 ###########################################
 # Construct ADM_userInterface
 ###########################################
@@ -395,6 +396,7 @@
 ########################
 IF (ADM_OS_WINDOWS)
 	add_libs_all_targets(z)
+	add_libs_all_targets(ADM_core)
 	add_libs_all_targets(ADM_osSupport)
 	add_libs_all_targets(pthreadGC2)
 	add_libs_all_targets(winmm)
@@ -434,6 +436,7 @@
 ########################
 SDLify(main.cpp)
 add_compile_flags(main.cpp &quot;-DADM_SUBVERSION=${ADM_SUBVERSION}&quot;)
+add_libs_all_targets(ADM_core)
 
 ###############
 # INSTALL

Modified: branches/avidemux_2.5_branch_mean/avidemux/main.cpp
===================================================================
--- branches/avidemux_2.5_branch_mean/avidemux/main.cpp	2008-02-27 19:50:36 UTC (rev 3805)
+++ branches/avidemux_2.5_branch_mean/avidemux/main.cpp	2008-02-27 19:50:43 UTC (rev 3806)
@@ -96,8 +96,6 @@
 void SpidermonkeyDestroy(void);
 
 extern pthread_mutex_t g_pSpiderMonkeyMutex;
-uint32_t CpuCaps::myCpuCaps=0;
-uint32_t CpuCaps::myCpuMask=0xffffffff;
 
 #if defined(ADM_DEBUG) &amp;&amp; defined(FIND_LEAKS)
 extern const char* new_progname;


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001071.html">[Avidemux-svn-commit] r3805 - in	branches/avidemux_2.5_branch_mean/avidemux: ADM_core	ADM_core/src ADM_osSupport
</A></li>
	<LI>Next message: <A HREF="001073.html">[Avidemux-svn-commit] r3807 -	branches/avidemux_2.5_branch_mean/avidemux
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1072">[ date ]</a>
              <a href="thread.html#1072">[ thread ]</a>
              <a href="subject.html#1072">[ subject ]</a>
              <a href="author.html#1072">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">More information about the Avidemux-svn-commit
mailing list</a><br>
</body></html>
