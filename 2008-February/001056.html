<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Avidemux-svn-commit] r3788 - in	branches/avidemux_2.4_branch/avidemux: ADM_filter	ADM_userInterfaces/ADM_GTK/ADM_dialog	ADM_userInterfaces/ADM_GTK/ADM_filters	ADM_userInterfaces/ADM_GTK/ADM_toolkit_gtk	ADM_userInterfaces/ADM_GTK/glade	ADM_userInterfaces/ADM_NONE/ADM_dialog	ADM_userInterfaces/ADM_QT4/ADM_dialog	ADM_userInterfaces/ADM_commonUI ADM_videoFilter
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/avidemux-svn-commit/2008-February/index.html" >
   <LINK REL="made" HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r3788%20-%20in%0A%09branches/avidemux_2.4_branch/avidemux%3A%20ADM_filter%0A%09ADM_userInterfaces/ADM_GTK/ADM_dialog%0A%09ADM_userInterfaces/ADM_GTK/ADM_filters%0A%09ADM_userInterfaces/ADM_GTK/ADM_toolkit_gtk%0A%09ADM_userInterfaces/ADM_GTK/glade%0A%09ADM_userInterfaces/ADM_NONE/ADM_dialog%0A%09ADM_userInterfaces/ADM_QT4/ADM_dialog%0A%09ADM_userInterfaces/ADM_commonUI%20ADM_videoFilter&In-Reply-To=%3C200802031204.m13C4KUd009861%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001055.html">
   <LINK REL="Next"  HREF="001057.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Avidemux-svn-commit] r3788 - in	branches/avidemux_2.4_branch/avidemux: ADM_filter	ADM_userInterfaces/ADM_GTK/ADM_dialog	ADM_userInterfaces/ADM_GTK/ADM_filters	ADM_userInterfaces/ADM_GTK/ADM_toolkit_gtk	ADM_userInterfaces/ADM_GTK/glade	ADM_userInterfaces/ADM_NONE/ADM_dialog	ADM_userInterfaces/ADM_QT4/ADM_dialog	ADM_userInterfaces/ADM_commonUI ADM_videoFilter</H1>
    <B>mean at BerliOS</B> 
    <A HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r3788%20-%20in%0A%09branches/avidemux_2.4_branch/avidemux%3A%20ADM_filter%0A%09ADM_userInterfaces/ADM_GTK/ADM_dialog%0A%09ADM_userInterfaces/ADM_GTK/ADM_filters%0A%09ADM_userInterfaces/ADM_GTK/ADM_toolkit_gtk%0A%09ADM_userInterfaces/ADM_GTK/glade%0A%09ADM_userInterfaces/ADM_NONE/ADM_dialog%0A%09ADM_userInterfaces/ADM_QT4/ADM_dialog%0A%09ADM_userInterfaces/ADM_commonUI%20ADM_videoFilter&In-Reply-To=%3C200802031204.m13C4KUd009861%40sheep.berlios.de%3E"
       TITLE="[Avidemux-svn-commit] r3788 - in	branches/avidemux_2.4_branch/avidemux: ADM_filter	ADM_userInterfaces/ADM_GTK/ADM_dialog	ADM_userInterfaces/ADM_GTK/ADM_filters	ADM_userInterfaces/ADM_GTK/ADM_toolkit_gtk	ADM_userInterfaces/ADM_GTK/glade	ADM_userInterfaces/ADM_NONE/ADM_dialog	ADM_userInterfaces/ADM_QT4/ADM_dialog	ADM_userInterfaces/ADM_commonUI ADM_videoFilter">mean at mail.berlios.de
       </A><BR>
    <I>Sun Feb  3 13:04:20 CET 2008</I>
    <P><UL>
        <LI>Previous message: <A HREF="001055.html">[Avidemux-svn-commit] r3787 - branches/avidemux_2.4_branch/po
</A></li>
        <LI>Next message: <A HREF="001057.html">[Avidemux-svn-commit] r3790 - branches/avidemux_2.4_branch/po
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1056">[ date ]</a>
              <a href="thread.html#1056">[ thread ]</a>
              <a href="subject.html#1056">[ subject ]</a>
              <a href="author.html#1056">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: mean
Date: 2008-02-03 13:04:10 +0100 (Sun, 03 Feb 2008)
New Revision: 3788

Modified:
   branches/avidemux_2.4_branch/avidemux/ADM_filter/filter.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_filter/video_filters.h
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_SwissArmyKnife.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_eraser.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_flyDialog.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_particle.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_threshold.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_filters/gui_filtermanager.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_toolkit_gtk/ADM_jogshuttle.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_toolkit_gtk/ADM_jogshuttle.h
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_toolkit_gtk/mediactrl.c
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/glade/eraser.glade
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/glade/particle.glade
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/glade/swissarmyknife.glade
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/glade/threshold.glade
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_NONE/ADM_dialog/DIA_flyDialog.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_NONE/ADM_dialog/DIA_none.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/DIA_none.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/T_flyDialog.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_flyDialog.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_flyDialog.h
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_flyEraser.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_flyEraser.h
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_flyParticle.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_flyParticle.h
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_flySwissArmyKnife.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_flySwissArmyKnife.h
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_flyThreshold.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_flyThreshold.h
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidComputeAverage.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidEraser.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidEraser.h
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidParticle.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidParticle.h
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidSwissArmyKnife.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidSwissArmyKnife.h
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidThreshold.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidThreshold.h
Log:
[CMG] Chris Mc Gregor patch update

Modified: branches/avidemux_2.4_branch/avidemux/ADM_filter/filter.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_filter/filter.cpp	2008-02-03 09:40:17 UTC (rev 3787)
+++ branches/avidemux_2.4_branch/avidemux/ADM_filter/filter.cpp	2008-02-03 12:04:10 UTC (rev 3788)
@@ -212,6 +212,13 @@
 
 }
 
+FILTER * getCurrentVideoFilterList (uint32_t * count)
+{
+    if (count)
+        *count = nb_active_filter;
+    return videofilters;
+}
+
 //
 //	Parse the list of active filters, delete them et recreate them with (new ?) configuration
 //
@@ -288,20 +295,25 @@
 
 
 */
+const FILTER_ENTRY * filterGetEntryFromTag (VF_FILTERS tag)
+{
+    ADM_assert(tag!=VF_INVALID);
+    for(unsigned int i=0;i&lt;allfilters.size();i++)
+    {
+        if(tag==allfilters[i].tag)
+        {
+            return &amp;(allfilters[i]);
+        }
+    }
+    ADM_assert(0);
+    return NULL;                      
+}
+
 const char  *filterGetNameFromTag(VF_FILTERS tag)
 {
-
-                        ADM_assert(tag!=VF_INVALID);
-                        for(unsigned int i=0;i&lt;allfilters.size();i++)
-                                {
-                                        if(tag==allfilters[i].tag)
-                                                {
-                                                        return allfilters[i].name;
-                                                        
-                                                }
-                                }
-                        ADM_assert(0);
-                        return NULL;                      
+    const FILTER_ENTRY * entry = filterGetEntryFromTag (tag);
+    ADM_assert(entry);
+    return entry-&gt;name;
 }
 /*____________________________________
 	Save and load current set of filters

Modified: branches/avidemux_2.4_branch/avidemux/ADM_filter/video_filters.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_filter/video_filters.h	2008-02-03 09:40:17 UTC (rev 3787)
+++ branches/avidemux_2.4_branch/avidemux/ADM_filter/video_filters.h	2008-02-03 12:04:10 UTC (rev 3788)
@@ -172,7 +172,10 @@
 AVDMGenericVideoStream *getFirstVideoFilter( uint32_t frameStart, uint32_t nbFrame);
 AVDMGenericVideoStream *getFirstVideoFilter( void);
 AVDMGenericVideoStream *getFirstCurrentVideoFilter( void);
-  
+FILTER * getCurrentVideoFilterList (uint32_t * count);
+const FILTER_ENTRY * filterGetEntryFromTag (VF_FILTERS tag);
+const char * filterGetNameFromTag(VF_FILTERS tag);
+
   void	filterSetPostProc( void );
   
 #ifdef USE_LIBXML2

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_SwissArmyKnife.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_SwissArmyKnife.cpp	2008-02-03 09:40:17 UTC (rev 3787)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_SwissArmyKnife.cpp	2008-02-03 12:04:10 UTC (rev 3788)
@@ -38,8 +38,13 @@
 #include &quot;DIA_flyDialog.h&quot;
 #include &quot;DIA_flySwissArmyKnife.h&quot;
 #include &quot;ADM_userInterfaces/ADM_commonUI/DIA_factory.h&quot; // for diaElemMenu etc.
+#include &quot;ADM_filter/video_filters.h&quot;
 
+#undef _
+#define _(_s) QT_TR_NOOP(_s)
+
 /********************************************************************/
+
 static GtkWidget *create_swiss_army_knife_dialog (void);
 static GtkWidget *dialog = 0;
 
@@ -59,10 +64,23 @@
     if (event-&gt;type != GDK_BUTTON_PRESS)
         return FALSE;
 
-    uint32_t x = static_cast &lt;uint32_t&gt; (event-&gt;x);
-    uint32_t y = static_cast &lt;uint32_t&gt; (event-&gt;y);
+    flySwissArmyKnife * myFly = static_cast &lt;flySwissArmyKnife *&gt; (data);
 
-    flySwissArmyKnife * myFly = static_cast &lt;flySwissArmyKnife *&gt; (data);
+    uint32_t x, y;
+
+    float zoom = myFly-&gt;getZoom();
+    if (zoom == 1.0)
+    {
+        x = static_cast &lt;uint32_t&gt; (event-&gt;x);
+        y = static_cast &lt;uint32_t&gt; (event-&gt;y);
+    }
+    else
+    {
+        zoom = 1 / zoom;
+        x = static_cast &lt;uint32_t&gt; (event-&gt;x * zoom + .5);
+        y = static_cast &lt;uint32_t&gt; (event-&gt;y * zoom + .5);
+    }
+
     ADMImage * image = event-&gt;button == 1
         ? myFly-&gt;getInputImage() : myFly-&gt;getOutputImage();
 
@@ -117,7 +135,7 @@
 
 /********************************************************************/
 
-void alphaRecalcOther (GtkSpinButton * spinbutton, gpointer user_data)
+static void alphaRecalcOther (GtkSpinButton * spinbutton, gpointer user_data)
 {
     static int alpha_lock = 0;
 
@@ -140,6 +158,8 @@
     --alpha_lock;
 }
 
+/********************************************************************/
+
 struct PixelValueScalingInfo
 {
     GtkAdjustment * addAdjustment;
@@ -168,7 +188,9 @@
     }
 };
 
-void updateScalingStuff (GtkAdjustment * adj, gpointer user_data)
+/********************************************************************/
+
+static void updateScalingStuff (GtkAdjustment * adj, gpointer user_data)
 {
     static int scaling_lock = 0;
 
@@ -294,7 +316,9 @@
     --scaling_lock;
 }
 
-void inputTypeChange (GtkComboBox * combo, gpointer user_data)
+/********************************************************************/
+
+static void inputTypeChange (GtkComboBox * combo, gpointer user_data)
 {
     flySwissArmyKnife * myFly = static_cast &lt;flySwissArmyKnife *&gt; (user_data);
     const MenuMapping * mm = myFly-&gt;lookupMenu (&quot;inputTypeMenu&quot;);
@@ -350,10 +374,14 @@
              TRUE, 0, 0, max_x, max_y);
     }
 
+    myFly-&gt;download();
+    myFly-&gt;pushParam();
     myFly-&gt;sliderChanged();
 }
 
-void previewEnableButton (GtkToggleButton * button, gpointer user_data)
+/********************************************************************/
+
+static void previewEnableButton (GtkToggleButton * button, gpointer user_data)
 {
     flySwissArmyKnife * myFly = static_cast &lt;flySwissArmyKnife *&gt; (user_data);
     bool isActive = gtk_toggle_button_get_active (button);
@@ -366,6 +394,8 @@
     {
         gtk_widget_hide (previewDisabled);
         gtk_widget_show (previewVideo);
+        myFly-&gt;download();
+        myFly-&gt;pushParam();
         myFly-&gt;sliderChanged();
     }
     else
@@ -375,6 +405,8 @@
     }
 }
 
+/********************************************************************/
+
 void flySwissArmyKnife::updateConfigDescription (bool do_download)
 {
     if (do_download)
@@ -383,12 +415,80 @@
                         ADMVideoSwissArmyKnife::getConf (&amp;param, true));
 }
 
-void updateConfigDescription (GtkSpinButton * button, gpointer user_data)
+/********************************************************************/
+
+static void updateConfigDescription (GtkSpinButton * button,
+                                     gpointer user_data)
 {
     flySwissArmyKnife * myFly = static_cast &lt;flySwissArmyKnife *&gt; (user_data);
     myFly-&gt;updateConfigDescription (true);
 }
 
+/********************************************************************/
+
+static void previewOutputMenuChange (GtkComboBox * combo, gpointer user_data)
+{
+    flySwissArmyKnife * myFly = static_cast &lt;flySwissArmyKnife *&gt; (user_data);
+    uint32_t index = gtk_combo_box_get_active (combo);
+    uint32_t filter_count;
+    FILTER * filters = getCurrentVideoFilterList (&amp;filter_count);
+    FILTER * filter = filters + index;
+    VF_FILTERS tag = filter-&gt;tag;
+
+    gchar * activestr = gtk_combo_box_get_active_text (combo);
+
+    printf (&quot;user selected preview of #%d = %s (%d) @%p (was %p)\n&quot;,
+            index, activestr, tag, filter-&gt;filter, myFly-&gt;getSource());
+
+    if (strncmp (activestr, &quot;XX &quot;, 3) == 0)
+    {
+        printf (&quot;selected preview source has different dimensions - &quot;
+                &quot;forcing selection to current filter\n&quot;);
+        gtk_combo_box_set_active (combo, myFly-&gt;this_filter_index);
+    }
+    else
+    {
+        flySwissArmyKnife::PreviewMode mode;
+        if (index == myFly-&gt;this_filter_index)
+            mode = flySwissArmyKnife::PREVIEWMODE_THIS_FILTER;
+        else if (index &gt; myFly-&gt;this_filter_index)
+            mode = flySwissArmyKnife::PREVIEWMODE_LATER_FILTER;
+        else // if (index &lt; myFly-&gt;this_filter_index)
+            mode = flySwissArmyKnife::PREVIEWMODE_EARLIER_FILTER;
+
+        myFly-&gt;changeSource (filter-&gt;filter, mode);
+    }
+
+    g_free (activestr);
+}
+
+/********************************************************************/
+
+static gboolean preview_video_configured (GtkWidget * widget,
+                                          GdkEventConfigure * event,
+                                          gpointer user_data)
+{
+    fprintf (stderr, &quot;preview_configured: now %dx%d @ +%d+%d\n&quot;,
+             event-&gt;width, event-&gt;height, event-&gt;x, event-&gt;y);
+
+    if (event-&gt;x == 1 &amp;&amp; event-&gt;y == 1)
+        return FALSE;
+
+    flySwissArmyKnife * myFly = static_cast &lt;flySwissArmyKnife *&gt; (user_data);
+    myFly-&gt;recomputeSize();
+
+    gint scaled_width, scaled_height;
+    gtk_widget_get_size_request (widget, &amp;scaled_width, &amp;scaled_height);
+    GtkWidget * previewVideo = WID(previewVideo);
+    gtk_widget_set_size_request (widget == previewVideo ? WID(previewDisabled)
+                                 : previewVideo,
+                                 scaled_width, scaled_height);
+
+    return FALSE;
+}
+
+/********************************************************************/
+
 uint8_t DIA_SwissArmyKnife (AVDMGenericVideoStream * in,
                             ADMVideoSwissArmyKnife * sakp,
                             SWISSARMYKNIFE_PARAM * param,
@@ -403,7 +503,6 @@
     gtk_register_dialog (dialog);
     gtk_window_set_title (GTK_WINDOW (dialog),
                           QT_TR_NOOP(&quot;Swiss Army Knife Configuration&quot;));
-    gtk_widget_set_size_request (WID(previewDisabled), width, height);
 
     // Fix up a bunch of things that Glade can't do.  This is less efficient
     // than just editing the Glade output, but it's not that big a deal and
@@ -447,6 +546,20 @@
                                  WID(previewVideo), WID(previewSlider),
                                  GTK_DIALOG(dialog), sakp, param,
                                  menu_mapping, menu_mapping_count);
+
+    gint scaled_width, scaled_height;
+    gtk_widget_get_size_request (WID(previewVideo),
+                                 &amp;scaled_width, &amp;scaled_height);
+    gtk_widget_set_size_request (WID(previewDisabled),
+                                 scaled_width, scaled_height);
+
+    g_signal_connect (GTK_OBJECT (WID(previewVideo)), &quot;configure-event&quot;,
+                      GTK_SIGNAL_FUNC (preview_video_configured),
+                      gpointer (myDialog));
+    g_signal_connect (GTK_OBJECT (WID(previewDisabled)), &quot;configure-event&quot;,
+                      GTK_SIGNAL_FUNC (preview_video_configured),
+                      gpointer (myDialog));
+
     myDialog-&gt;upload();
     myDialog-&gt;sliderChanged();
 
@@ -464,6 +577,7 @@
 
     CNX (constantValueSpinButton, &quot;value_changed&quot;);
     CNX (rollingAvgAlphaDenomSpinButton, &quot;value_changed&quot;);
+    CNX (rollingAvgLookaheadSpinButton, &quot;value_changed&quot;);
     CNX (rollingAvgInitTypeMenu, &quot;changed&quot;);
     CNX (rollingAvgInitStartSpinButton, &quot;value_changed&quot;);
     CNX (rollingAvgInitEndSpinButton, &quot;value_changed&quot;);
@@ -534,8 +648,8 @@
     // Reshuffle what is and isn't displayed when the user selects a different
     // input.
 
-    g_signal_connect(GTK_OBJECT(WID(inputTypeMenu)), &quot;changed&quot;,
-                     GTK_SIGNAL_FUNC(inputTypeChange), gpointer(myDialog));
+    g_signal_connect (GTK_OBJECT(WID(inputTypeMenu)), &quot;changed&quot;,
+                      GTK_SIGNAL_FUNC(inputTypeChange), gpointer(myDialog));
     inputTypeChange (GTK_COMBO_BOX(WID(inputTypeMenu)), gpointer(myDialog));
 
     // preview stuff:
@@ -561,15 +675,67 @@
                       gpointer(myDialog));
 #endif
 
+    GtkWidget * previewOutputMenu = WID(previewOutputMenu);
+    uint32_t filter_count;
+    FILTER * filters = getCurrentVideoFilterList (&amp;filter_count);
+    int32_t active = -1;
+
+    // The &quot; + (active &lt; 0)&quot; below is a bit of a hack.  We know that in
+    // on_action() in gui_filtermanager.cpp, case A_ADD, the new filter-to-be
+    // is added to the filter list without incrementing nb_active_filter yet.
+    // So if we get to the end of the list and haven't yet found the filter
+    // that we're configuring, we know it's a new one and therefore that it is
+    // one past the apparent end of the list.  It's not a clean solution, but
+    // it seems like the cleanEST solution.
+
+    for (uint32_t i = 0; i &lt; filter_count + (active &lt; 0); i++)
+    {
+        const char * name
+            = (i == 0) ? &quot;(input)&quot; : filterGetNameFromTag (filters [i].tag);
+        bool free_name = false;
+                                   
+        FILTER * filter = filters + i;
+        AVDMGenericVideoStream * source = filter-&gt;filter;
+        uint32_t w = source-&gt;getInfo()-&gt;width;
+        uint32_t h = source-&gt;getInfo()-&gt;height;
+        if (w != width || h != height)
+        {
+            name = g_strconcat (&quot;XX &quot;, name, &quot; XX&quot;, NULL);
+            free_name = true;
+        }
+
+        printf (&quot;filter [%d] = %s (%d) @ %p; %dx%d\n&quot;,
+                i, name, filter-&gt;tag, source, w, h);
+        gtk_combo_box_append_text (GTK_COMBO_BOX (previewOutputMenu), name);
+        if (filter-&gt;filter == myDialog-&gt;getSource())
+        {
+            gtk_combo_box_set_active (GTK_COMBO_BOX (previewOutputMenu), i);
+            printf (&quot;\tfilter [%d] is being configured now\n&quot;, i);
+            active = i;
+        }
+
+        if (free_name)
+            g_free (const_cast &lt;char *&gt; (name));
+    }
+
+    ADM_assert (active &gt;= 0);
+    myDialog-&gt;this_filter_index = active;
+
+    g_signal_connect (GTK_OBJECT(previewOutputMenu), &quot;changed&quot;,
+                      GTK_SIGNAL_FUNC(previewOutputMenuChange),
+                      gpointer(myDialog));
+
     uint8_t ret = 0;
     int response = gtk_dialog_run(GTK_DIALOG(dialog));
 
     if (response == GTK_RESPONSE_OK)
     {
         myDialog-&gt;download();
-        myDialog-&gt;getParam (param);
+        myDialog-&gt;pushParam();
         ret = 1;
     }
+    else
+        myDialog-&gt;restoreParam();
 
     gtk_unregister_dialog(dialog);
     gtk_widget_destroy(dialog);
@@ -581,6 +747,8 @@
     return ret;
 }
 
+/********************************************************************/
+
 void frame_changed (GtkRange *, gpointer user_data)
 {
     flySwissArmyKnife * myDialog
@@ -589,6 +757,8 @@
     myDialog-&gt;sliderChanged();
 }
 
+/********************************************************************/
+
 void gui_update (GtkObject *, gpointer user_data)
 {
     if (lock)
@@ -600,6 +770,8 @@
     myDialog-&gt;update();
 }
 
+/********************************************************************/
+
 gboolean gui_draw (GtkWidget * widget, GdkEventExpose * event, gpointer user_data)
 {
     flySwissArmyKnife * myDialog
@@ -608,7 +780,7 @@
     return TRUE;
 }
 
-/**************************************/
+/********************************************************************/
 
 uint8_t flySwissArmyKnife::upload (void)
 {
@@ -634,6 +806,9 @@
     gtk_spin_button_set_value
         (GTK_SPIN_BUTTON(WID(rollingAvgAlphaSpinButton)),
          param.memory_constant_alpha);
+    gtk_spin_button_set_value
+        (GTK_SPIN_BUTTON(WID(rollingAvgLookaheadSpinButton)),
+         param.lookahead_n_frames);
     gtk_combo_box_set_active
         (GTK_COMBO_BOX(WID(rollingAvgInitTypeMenu)), param.init_by_rolling);
     gtk_spin_button_set_value
@@ -668,6 +843,8 @@
     return 1;
 }
 
+/********************************************************************/
+
 uint8_t flySwissArmyKnife::download (void)
 {
     getMenuValues();
@@ -702,6 +879,9 @@
     param.memory_constant_alpha
         = gtk_spin_button_get_value
         (GTK_SPIN_BUTTON(WID(rollingAvgAlphaSpinButton)));
+    param.lookahead_n_frames
+        = gtk_spin_button_get_value_as_int
+        (GTK_SPIN_BUTTON(WID(rollingAvgLookaheadSpinButton)));
     param.init_by_rolling
         = gtk_combo_box_get_active
         (GTK_COMBO_BOX(WID(rollingAvgInitTypeMenu)));
@@ -737,6 +917,8 @@
     return 1;
 }
 
+/********************************************************************/
+
 void flySwissArmyKnife::wipeOutputBuffer ()
 {
     // printf (&quot;wiping output buffer\n&quot;);
@@ -755,6 +937,8 @@
     memset (VPLANE (_yuvBufferOut), 128, pixelcount &gt;&gt; 2);
 }
 
+/********************************************************************/
+
 // The following was generated by glade from swissarmyknife.glade once upon a
 // time (in fact, many times, since it took quite a few tries to get it right!
 // :-).  Thus far, I've avoided editing it, so regenerating the code from
@@ -824,6 +1008,11 @@
   GtkWidget *rollingAvgAlphaEqualsLabel;
   GtkObject *rollingAvgAlphaDenomSpinButton_adj;
   GtkWidget *rollingAvgAlphaDenomSpinButton;
+  GtkWidget *rollingAvgLookaheadHbox;
+  GtkWidget *rollingAvgLookaheadLabel1;
+  GtkObject *rollingAvgLookaheadSpinButton_adj;
+  GtkWidget *rollingAvgLookaheadSpinButton;
+  GtkWidget *rollingAvgLookaheadLabel2;
   GtkWidget *rollingAvgInitVbox;
   GtkWidget *rollingAvgInitHbox1;
   GtkWidget *rollingAvgInitLabel1;
@@ -895,7 +1084,9 @@
   GtkWidget *okButton;
 
   swiss_army_knife_dialog = gtk_dialog_new ();
-  gtk_window_set_title (GTK_WINDOW (swiss_army_knife_dialog), QT_TR_NOOP(&quot;Swiss Army Knife&quot;));
+  //                                                NO NEED TO &quot;FIX&quot; THAT _(&quot;...&quot;)!!
+  //                                                see handy macro near top of file.
+  gtk_window_set_title (GTK_WINDOW (swiss_army_knife_dialog), _(&quot;Swiss Army Knife&quot;));
   gtk_window_set_type_hint (GTK_WINDOW (swiss_army_knife_dialog), GDK_WINDOW_TYPE_HINT_DIALOG);
 
   dialogVbox = GTK_DIALOG (swiss_army_knife_dialog)-&gt;vbox;
@@ -922,7 +1113,7 @@
   gtk_widget_show (operationHbox);
   gtk_box_pack_start (GTK_BOX (settingsOuterVbox), operationHbox, TRUE, TRUE, 0);
 
-  operationLabel = gtk_label_new_with_mnemonic (QT_TR_NOOP(&quot;Select _Operation on each pixel P and input A:   &quot;));
+  operationLabel = gtk_label_new_with_mnemonic (_(&quot;Select _Operation on each pixel P and input A:   &quot;));
   gtk_widget_show (operationLabel);
   gtk_box_pack_start (GTK_BOX (operationHbox), operationLabel, FALSE, FALSE, 0);
 
@@ -934,7 +1125,7 @@
   gtk_widget_show (inputTypeHbox);
   gtk_box_pack_start (GTK_BOX (settingsOuterVbox), inputTypeHbox, TRUE, TRUE, 0);
 
-  inputTypeLabel = gtk_label_new_with_mnemonic (QT_TR_NOOP(&quot;Input _Type:   &quot;));
+  inputTypeLabel = gtk_label_new_with_mnemonic (_(&quot;Input _Type:   &quot;));
   gtk_widget_show (inputTypeLabel);
   gtk_box_pack_start (GTK_BOX (inputTypeHbox), inputTypeLabel, FALSE, FALSE, 0);
 
@@ -953,11 +1144,11 @@
   gtk_widget_show (convolutionInputFileHbox);
   gtk_box_pack_start (GTK_BOX (convolutionSettingsVbox), convolutionInputFileHbox, TRUE, TRUE, 0);
 
-  convolutionInputFileLabel = gtk_label_new_with_mnemonic (QT_TR_NOOP(&quot;Input _File (convolution kernel):   &quot;));
+  convolutionInputFileLabel = gtk_label_new_with_mnemonic (_(&quot;Input _File (convolution kernel):   &quot;));
   gtk_widget_show (convolutionInputFileLabel);
   gtk_box_pack_start (GTK_BOX (convolutionInputFileHbox), convolutionInputFileLabel, FALSE, FALSE, 0);
 
-  convolutionInputFileChooser = gtk_file_chooser_button_new (QT_TR_NOOP(&quot;Select Convolution Kernel File&quot;), GTK_FILE_CHOOSER_ACTION_OPEN);
+  convolutionInputFileChooser = gtk_file_chooser_button_new (_(&quot;Select Convolution Kernel File&quot;), GTK_FILE_CHOOSER_ACTION_OPEN);
   gtk_widget_show (convolutionInputFileChooser);
   gtk_box_pack_start (GTK_BOX (convolutionInputFileHbox), convolutionInputFileChooser, TRUE, TRUE, 0);
 
@@ -968,11 +1159,11 @@
   gtk_widget_show (imageInputFileHbox);
   gtk_box_pack_start (GTK_BOX (imageFileSettingsVbox), imageInputFileHbox, TRUE, TRUE, 0);
 
-  imageInputFileLabel = gtk_label_new_with_mnemonic (QT_TR_NOOP(&quot;Input _File (image file):   &quot;));
+  imageInputFileLabel = gtk_label_new_with_mnemonic (_(&quot;Input _File (image file):   &quot;));
   gtk_widget_show (imageInputFileLabel);
   gtk_box_pack_start (GTK_BOX (imageInputFileHbox), imageInputFileLabel, FALSE, FALSE, 0);
 
-  imageInputFileChooser = gtk_file_chooser_button_new (QT_TR_NOOP(&quot;Select Convolution Kernel File&quot;), GTK_FILE_CHOOSER_ACTION_OPEN);
+  imageInputFileChooser = gtk_file_chooser_button_new (_(&quot;Select Convolution Kernel File&quot;), GTK_FILE_CHOOSER_ACTION_OPEN);
   gtk_widget_show (imageInputFileChooser);
   gtk_box_pack_start (GTK_BOX (imageInputFileHbox), imageInputFileChooser, TRUE, TRUE, 0);
 
@@ -994,7 +1185,7 @@
   gtk_widget_show (imageFileScalingAddHbox);
   gtk_box_pack_start (GTK_BOX (imageFileScalingVbox), imageFileScalingAddHbox, TRUE, TRUE, 0);
 
-  imageFileScalingAddLabel = gtk_label_new_with_mnemonic (QT_TR_NOOP(&quot;First, _add to each float pixel value:   &quot;));
+  imageFileScalingAddLabel = gtk_label_new_with_mnemonic (_(&quot;First, _add to each float pixel value:   &quot;));
   gtk_widget_show (imageFileScalingAddLabel);
   gtk_box_pack_start (GTK_BOX (imageFileScalingAddHbox), imageFileScalingAddLabel, FALSE, FALSE, 0);
 
@@ -1008,7 +1199,7 @@
   gtk_widget_show (imageFileScalingMultHbox);
   gtk_box_pack_start (GTK_BOX (imageFileScalingVbox), imageFileScalingMultHbox, TRUE, TRUE, 0);
 
-  imageFileScalingMultLabel = gtk_label_new_with_mnemonic (QT_TR_NOOP(&quot;Then, _multiply each float pixel value by:   &quot;));
+  imageFileScalingMultLabel = gtk_label_new_with_mnemonic (_(&quot;Then, _multiply each float pixel value by:   &quot;));
   gtk_widget_show (imageFileScalingMultLabel);
   gtk_box_pack_start (GTK_BOX (imageFileScalingMultHbox), imageFileScalingMultLabel, FALSE, FALSE, 0);
 
@@ -1022,7 +1213,7 @@
   gtk_widget_show (imageFileScalingMinVbox);
   gtk_box_pack_start (GTK_BOX (imageFileScalingVbox), imageFileScalingMinVbox, TRUE, TRUE, 0);
 
-  imageFileScalingMinLabel = gtk_label_new_with_mnemonic (QT_TR_NOOP(&quot;Mi_nimum loaded pixel value (will be scaled to 0):&quot;));
+  imageFileScalingMinLabel = gtk_label_new_with_mnemonic (_(&quot;Mi_nimum loaded pixel value (will be scaled to 0):&quot;));
   gtk_widget_show (imageFileScalingMinLabel);
   gtk_box_pack_start (GTK_BOX (imageFileScalingMinVbox), imageFileScalingMinLabel, FALSE, FALSE, 0);
   gtk_misc_set_alignment (GTK_MISC (imageFileScalingMinLabel), 0, 0.5);
@@ -1048,7 +1239,7 @@
   gtk_widget_show (imageFileScalingMaxVbox);
   gtk_box_pack_start (GTK_BOX (imageFileScalingVbox), imageFileScalingMaxVbox, TRUE, TRUE, 0);
 
-  imageFileScalingMaxLabel = gtk_label_new_with_mnemonic (QT_TR_NOOP(&quot;Ma_ximum loaded pixel value (will be scaled to 255):&quot;));
+  imageFileScalingMaxLabel = gtk_label_new_with_mnemonic (_(&quot;Ma_ximum loaded pixel value (will be scaled to 255):&quot;));
   gtk_widget_show (imageFileScalingMaxLabel);
   gtk_box_pack_start (GTK_BOX (imageFileScalingMaxVbox), imageFileScalingMaxLabel, FALSE, FALSE, 0);
   gtk_misc_set_alignment (GTK_MISC (imageFileScalingMaxLabel), 0, 0.5);
@@ -1070,7 +1261,7 @@
   gtk_box_pack_start (GTK_BOX (imageFileScalingMaxHbox), imageFileScalingMaxSpinner, FALSE, TRUE, 0);
   gtk_spin_button_set_numeric (GTK_SPIN_BUTTON (imageFileScalingMaxSpinner), TRUE);
 
-  imageFileScalingFrameLabel = gtk_label_new (QT_TR_NOOP(&quot;Pixel Value Scaling as Image File is Loaded&quot;));
+  imageFileScalingFrameLabel = gtk_label_new (_(&quot;Pixel Value Scaling as Image File is Loaded&quot;));
   gtk_widget_show (imageFileScalingFrameLabel);
   gtk_frame_set_label_widget (GTK_FRAME (imageFileScalingFrame), imageFileScalingFrameLabel);
   gtk_label_set_use_markup (GTK_LABEL (imageFileScalingFrameLabel), TRUE);
@@ -1082,7 +1273,7 @@
   gtk_widget_show (constantValueHbox);
   gtk_box_pack_start (GTK_BOX (constantSettingsVbox), constantValueHbox, TRUE, TRUE, 0);
 
-  constantValueLabel = gtk_label_new_with_mnemonic (QT_TR_NOOP(&quot;Input _Constant:      &quot;));
+  constantValueLabel = gtk_label_new_with_mnemonic (_(&quot;Input _Constant:      &quot;));
   gtk_widget_show (constantValueLabel);
   gtk_box_pack_start (GTK_BOX (constantValueHbox), constantValueLabel, FALSE, FALSE, 0);
 
@@ -1099,7 +1290,7 @@
   gtk_widget_show (rollingAvgAlphaHbox);
   gtk_box_pack_start (GTK_BOX (rollingAvgSettingsVbox), rollingAvgAlphaHbox, TRUE, TRUE, 0);
 
-  rollingAvgAlphaLabel = gtk_label_new_with_mnemonic (QT_TR_NOOP(&quot;Memory constant _alpha:   &quot;));
+  rollingAvgAlphaLabel = gtk_label_new_with_mnemonic (_(&quot;Memory constant _alpha:   &quot;));
   gtk_widget_show (rollingAvgAlphaLabel);
   gtk_box_pack_start (GTK_BOX (rollingAvgAlphaHbox), rollingAvgAlphaLabel, FALSE, TRUE, 0);
 
@@ -1109,7 +1300,7 @@
   gtk_box_pack_start (GTK_BOX (rollingAvgAlphaHbox), rollingAvgAlphaSpinButton, FALSE, TRUE, 0);
   gtk_spin_button_set_numeric (GTK_SPIN_BUTTON (rollingAvgAlphaSpinButton), TRUE);
 
-  rollingAvgAlphaEqualsLabel = gtk_label_new (QT_TR_NOOP(&quot; = 1 / &quot;));
+  rollingAvgAlphaEqualsLabel = gtk_label_new (_(&quot; = 1 / &quot;));
   gtk_widget_show (rollingAvgAlphaEqualsLabel);
   gtk_box_pack_start (GTK_BOX (rollingAvgAlphaHbox), rollingAvgAlphaEqualsLabel, FALSE, FALSE, 0);
 
@@ -1119,6 +1310,25 @@
   gtk_box_pack_start (GTK_BOX (rollingAvgAlphaHbox), rollingAvgAlphaDenomSpinButton, FALSE, TRUE, 0);
   gtk_spin_button_set_numeric (GTK_SPIN_BUTTON (rollingAvgAlphaDenomSpinButton), TRUE);
 
+  rollingAvgLookaheadHbox = gtk_hbox_new (FALSE, 0);
+  gtk_widget_show (rollingAvgLookaheadHbox);
+  gtk_box_pack_start (GTK_BOX (rollingAvgSettingsVbox), rollingAvgLookaheadHbox, TRUE, TRUE, 0);
+
+  rollingAvgLookaheadLabel1 = gtk_label_new_with_mnemonic (_(&quot;_Look ahead &quot;));
+  gtk_widget_show (rollingAvgLookaheadLabel1);
+  gtk_box_pack_start (GTK_BOX (rollingAvgLookaheadHbox), rollingAvgLookaheadLabel1, FALSE, FALSE, 0);
+  gtk_label_set_justify (GTK_LABEL (rollingAvgLookaheadLabel1), GTK_JUSTIFY_RIGHT);
+
+  rollingAvgLookaheadSpinButton_adj = gtk_adjustment_new (0, 0, 99999, 1, 1, 0);
+  rollingAvgLookaheadSpinButton = gtk_spin_button_new (GTK_ADJUSTMENT (rollingAvgLookaheadSpinButton_adj), 1, 0);
+  gtk_widget_show (rollingAvgLookaheadSpinButton);
+  gtk_box_pack_start (GTK_BOX (rollingAvgLookaheadHbox), rollingAvgLookaheadSpinButton, FALSE, TRUE, 0);
+  gtk_spin_button_set_numeric (GTK_SPIN_BUTTON (rollingAvgLookaheadSpinButton), TRUE);
+
+  rollingAvgLookaheadLabel2 = gtk_label_new_with_mnemonic (_(&quot; frames.  (Anything &gt; 0 will be slower.)&quot;));
+  gtk_widget_show (rollingAvgLookaheadLabel2);
+  gtk_box_pack_start (GTK_BOX (rollingAvgLookaheadHbox), rollingAvgLookaheadLabel2, FALSE, FALSE, 0);
+
   rollingAvgInitVbox = gtk_vbox_new (FALSE, 0);
   gtk_widget_show (rollingAvgInitVbox);
   gtk_box_pack_start (GTK_BOX (rollingAvgSettingsVbox), rollingAvgInitVbox, TRUE, TRUE, 0);
@@ -1127,17 +1337,17 @@
   gtk_widget_show (rollingAvgInitHbox1);
   gtk_box_pack_start (GTK_BOX (rollingAvgInitVbox), rollingAvgInitHbox1, TRUE, TRUE, 0);
 
-  rollingAvgInitLabel1 = gtk_label_new_with_mnemonic (QT_TR_NOOP(&quot;_Initial average (\&quot;head start\&quot;) is &quot;));
+  rollingAvgInitLabel1 = gtk_label_new_with_mnemonic (_(&quot;_Initial average (\&quot;head start\&quot;) is &quot;));
   gtk_widget_show (rollingAvgInitLabel1);
   gtk_box_pack_start (GTK_BOX (rollingAvgInitHbox1), rollingAvgInitLabel1, FALSE, FALSE, 0);
 
   rollingAvgInitTypeMenu = gtk_combo_box_new_text ();
   gtk_widget_show (rollingAvgInitTypeMenu);
   gtk_box_pack_start (GTK_BOX (rollingAvgInitHbox1), rollingAvgInitTypeMenu, FALSE, TRUE, 0);
-  gtk_combo_box_append_text (GTK_COMBO_BOX (rollingAvgInitTypeMenu), QT_TR_NOOP(&quot;straight&quot;));
-  gtk_combo_box_append_text (GTK_COMBO_BOX (rollingAvgInitTypeMenu), QT_TR_NOOP(&quot;rolling&quot;));
+  gtk_combo_box_append_text (GTK_COMBO_BOX (rollingAvgInitTypeMenu), _(&quot;straight&quot;));
+  gtk_combo_box_append_text (GTK_COMBO_BOX (rollingAvgInitTypeMenu), _(&quot;rolling&quot;));
 
-  rollingAvgInitLabel2 = gtk_label_new (QT_TR_NOOP(&quot; average&quot;));
+  rollingAvgInitLabel2 = gtk_label_new (_(&quot; average&quot;));
   gtk_widget_show (rollingAvgInitLabel2);
   gtk_box_pack_start (GTK_BOX (rollingAvgInitHbox1), rollingAvgInitLabel2, FALSE, FALSE, 0);
 
@@ -1145,21 +1355,21 @@
   gtk_widget_show (rollingAvgInitHbox2);
   gtk_box_pack_start (GTK_BOX (rollingAvgInitVbox), rollingAvgInitHbox2, TRUE, TRUE, 0);
 
-  rollingAvgInitLabel3 = gtk_label_new (QT_TR_NOOP(&quot;      of frames &quot;));
+  rollingAvgInitLabel3 = gtk_label_new (_(&quot;      of frames &quot;));
   gtk_widget_show (rollingAvgInitLabel3);
   gtk_box_pack_start (GTK_BOX (rollingAvgInitHbox2), rollingAvgInitLabel3, FALSE, FALSE, 0);
 
-  rollingAvgInitStartSpinButton_adj = gtk_adjustment_new (1, 1, 99999, 1, 1, 0);
+  rollingAvgInitStartSpinButton_adj = gtk_adjustment_new (0, 0, 9999999, 1, 1, 0);
   rollingAvgInitStartSpinButton = gtk_spin_button_new (GTK_ADJUSTMENT (rollingAvgInitStartSpinButton_adj), 1, 0);
   gtk_widget_show (rollingAvgInitStartSpinButton);
   gtk_box_pack_start (GTK_BOX (rollingAvgInitHbox2), rollingAvgInitStartSpinButton, FALSE, TRUE, 0);
   gtk_spin_button_set_numeric (GTK_SPIN_BUTTON (rollingAvgInitStartSpinButton), TRUE);
 
-  rollingAvgInitLabel4 = gtk_label_new (QT_TR_NOOP(&quot; through &quot;));
+  rollingAvgInitLabel4 = gtk_label_new (_(&quot; through &quot;));
   gtk_widget_show (rollingAvgInitLabel4);
   gtk_box_pack_start (GTK_BOX (rollingAvgInitHbox2), rollingAvgInitLabel4, FALSE, FALSE, 0);
 
-  rollingAvgInitEndSpinButton_adj = gtk_adjustment_new (100, 1, 99999, 1, 1, 0);
+  rollingAvgInitEndSpinButton_adj = gtk_adjustment_new (99, 0, 9999999, 1, 1, 0);
   rollingAvgInitEndSpinButton = gtk_spin_button_new (GTK_ADJUSTMENT (rollingAvgInitEndSpinButton_adj), 1, 0);
   gtk_widget_show (rollingAvgInitEndSpinButton);
   gtk_box_pack_start (GTK_BOX (rollingAvgInitHbox2), rollingAvgInitEndSpinButton, FALSE, TRUE, 0);
@@ -1173,7 +1383,7 @@
   gtk_widget_show (biasVbox);
   gtk_box_pack_start (GTK_BOX (settingsOuterVbox), biasVbox, TRUE, TRUE, 0);
 
-  biasLabel = gtk_label_new_with_mnemonic (QT_TR_NOOP(&quot;Integer _Bias (will be added to result of selected operation):&quot;));
+  biasLabel = gtk_label_new_with_mnemonic (_(&quot;Integer _Bias (will be added to result of selected operation):&quot;));
   gtk_widget_show (biasLabel);
   gtk_box_pack_start (GTK_BOX (biasVbox), biasLabel, FALSE, FALSE, 0);
   gtk_misc_set_alignment (GTK_MISC (biasLabel), 0, 0.5);
@@ -1213,7 +1423,7 @@
   gtk_widget_show (resultScalingAddHbox);
   gtk_box_pack_start (GTK_BOX (resultScalingVbox), resultScalingAddHbox, TRUE, TRUE, 0);
 
-  resultScalingAddLabel = gtk_label_new_with_mnemonic (QT_TR_NOOP(&quot;First, _add to each pixel result value:   &quot;));
+  resultScalingAddLabel = gtk_label_new_with_mnemonic (_(&quot;First, _add to each pixel result value:   &quot;));
   gtk_widget_show (resultScalingAddLabel);
   gtk_box_pack_start (GTK_BOX (resultScalingAddHbox), resultScalingAddLabel, FALSE, FALSE, 0);
 
@@ -1227,7 +1437,7 @@
   gtk_widget_show (resultScalingMultHbox);
   gtk_box_pack_start (GTK_BOX (resultScalingVbox), resultScalingMultHbox, TRUE, TRUE, 0);
 
-  resultScalingMultLabel = gtk_label_new_with_mnemonic (QT_TR_NOOP(&quot;Then, _multiply each pixel result value by:   &quot;));
+  resultScalingMultLabel = gtk_label_new_with_mnemonic (_(&quot;Then, _multiply each pixel result value by:   &quot;));
   gtk_widget_show (resultScalingMultLabel);
   gtk_box_pack_start (GTK_BOX (resultScalingMultHbox), resultScalingMultLabel, FALSE, FALSE, 0);
 
@@ -1241,7 +1451,7 @@
   gtk_widget_show (resultScalingMinVbox);
   gtk_box_pack_start (GTK_BOX (resultScalingVbox), resultScalingMinVbox, TRUE, TRUE, 0);
 
-  resultScalingMinLabel = gtk_label_new_with_mnemonic (QT_TR_NOOP(&quot;Mi_nimum result value (will be scaled to 0):&quot;));
+  resultScalingMinLabel = gtk_label_new_with_mnemonic (_(&quot;Mi_nimum result value (will be scaled to 0):&quot;));
   gtk_widget_show (resultScalingMinLabel);
   gtk_box_pack_start (GTK_BOX (resultScalingMinVbox), resultScalingMinLabel, FALSE, FALSE, 0);
   gtk_misc_set_alignment (GTK_MISC (resultScalingMinLabel), 0, 0.5);
@@ -1267,7 +1477,7 @@
   gtk_widget_show (resultScalingMaxVbox);
   gtk_box_pack_start (GTK_BOX (resultScalingVbox), resultScalingMaxVbox, TRUE, TRUE, 0);
 
-  resultScalingMaxLabel = gtk_label_new_with_mnemonic (QT_TR_NOOP(&quot;Ma_ximum result value (will be scaled to 255):&quot;));
+  resultScalingMaxLabel = gtk_label_new_with_mnemonic (_(&quot;Ma_ximum result value (will be scaled to 255):&quot;));
   gtk_widget_show (resultScalingMaxLabel);
   gtk_box_pack_start (GTK_BOX (resultScalingMaxVbox), resultScalingMaxLabel, FALSE, FALSE, 0);
   gtk_misc_set_alignment (GTK_MISC (resultScalingMaxLabel), 0, 0.5);
@@ -1289,7 +1499,7 @@
   gtk_box_pack_start (GTK_BOX (resultScalingMaxHbox), resultScalingMaxSpinner, FALSE, TRUE, 0);
   gtk_spin_button_set_numeric (GTK_SPIN_BUTTON (resultScalingMaxSpinner), TRUE);
 
-  resultScalingFrameLabel = gtk_label_new (QT_TR_NOOP(&quot;Pixel Value Scaling on Result of Selected Operation&quot;));
+  resultScalingFrameLabel = gtk_label_new (_(&quot;Pixel Value Scaling on Result of Selected Operation&quot;));
   gtk_widget_show (resultScalingFrameLabel);
   gtk_frame_set_label_widget (GTK_FRAME (resultScalingFrame), resultScalingFrameLabel);
   gtk_label_set_use_markup (GTK_LABEL (resultScalingFrameLabel), TRUE);
@@ -1298,7 +1508,7 @@
   gtk_widget_show (hseparator2);
   gtk_box_pack_start (GTK_BOX (settingsOuterVbox), hseparator2, TRUE, TRUE, 0);
 
-  currentConfigDescription = gtk_label_new (QT_TR_NOOP(&quot;(description of current config will go here)&quot;));
+  currentConfigDescription = gtk_label_new (_(&quot;(description of current config will go here)&quot;));
   gtk_widget_show (currentConfigDescription);
   gtk_box_pack_start (GTK_BOX (settingsOuterVbox), currentConfigDescription, FALSE, FALSE, 0);
   GTK_WIDGET_SET_FLAGS (currentConfigDescription, GTK_CAN_FOCUS);
@@ -1315,7 +1525,7 @@
   gtk_widget_show (histogramHbox);
   gtk_box_pack_start (GTK_BOX (settingsOuterVbox), histogramHbox, TRUE, TRUE, 0);
 
-  histogramLabel = gtk_label_new_with_mnemonic (QT_TR_NOOP(&quot;_Histogram every N frames (0 to disable):   &quot;));
+  histogramLabel = gtk_label_new_with_mnemonic (_(&quot;_Histogram every N frames (0 to disable):   &quot;));
   gtk_widget_show (histogramLabel);
   gtk_box_pack_start (GTK_BOX (histogramHbox), histogramLabel, FALSE, FALSE, 0);
 
@@ -1329,7 +1539,7 @@
   gtk_widget_show (debugHbox);
   gtk_box_pack_start (GTK_BOX (settingsOuterVbox), debugHbox, TRUE, TRUE, 0);
 
-  debugLabel = gtk_label_new_with_mnemonic (QT_TR_NOOP(&quot;_Debugging settings (bits):   &quot;));
+  debugLabel = gtk_label_new_with_mnemonic (_(&quot;_Debugging settings (bits):   &quot;));
   gtk_widget_show (debugLabel);
   gtk_box_pack_start (GTK_BOX (debugHbox), debugLabel, FALSE, FALSE, 0);
 
@@ -1361,9 +1571,8 @@
   gtk_box_pack_start (GTK_BOX (previewVbox), previewControlHbox, TRUE, TRUE, 0);
 
   previewOutputMenu = gtk_combo_box_new_text ();
+  gtk_widget_show (previewOutputMenu);
   gtk_box_pack_start (GTK_BOX (previewControlHbox), previewOutputMenu, FALSE, TRUE, 0);
-  gtk_combo_box_append_text (GTK_COMBO_BOX (previewOutputMenu), QT_TR_NOOP(&quot;Swiss Army Knife output&quot;));
-  gtk_combo_box_append_text (GTK_COMBO_BOX (previewOutputMenu), QT_TR_NOOP(&quot;Final output&quot;));
 
   previewSlider = gtk_hscale_new (GTK_ADJUSTMENT (gtk_adjustment_new (0, 0, 99, 1, 1, 0)));
   gtk_widget_show (previewSlider);
@@ -1373,13 +1582,13 @@
   previewVideo = gtk_drawing_area_new ();
   gtk_widget_show (previewVideo);
   gtk_box_pack_start (GTK_BOX (previewVbox), previewVideo, TRUE, TRUE, 0);
-  gtk_widget_set_size_request (previewVideo, -1, 300);
+  gtk_widget_set_size_request (previewVideo, 30, 30);
   gtk_widget_set_events (previewVideo, GDK_BUTTON1_MOTION_MASK | GDK_BUTTON_PRESS_MASK);
 
   previewDisabled = gtk_drawing_area_new ();
   gtk_box_pack_start (GTK_BOX (previewVbox), previewDisabled, TRUE, TRUE, 0);
 
-  previewLabel = gtk_label_new (QT_TR_NOOP(&quot;Preview&quot;));
+  previewLabel = gtk_label_new (_(&quot;Preview&quot;));
   gtk_widget_show (previewLabel);
   gtk_frame_set_label_widget (GTK_FRAME (previewFrame), previewLabel);
 
@@ -1387,7 +1596,7 @@
   gtk_widget_show (previewEnableButtonHbox);
   gtk_box_pack_start (GTK_BOX (previewVboxOuter), previewEnableButtonHbox, FALSE, TRUE, 5);
 
-  previewEnableButton = gtk_toggle_button_new_with_mnemonic (QT_TR_NOOP(&quot;Enable Preview&quot;));
+  previewEnableButton = gtk_toggle_button_new_with_mnemonic (_(&quot;Enable Preview&quot;));
   gtk_widget_show (previewEnableButton);
   gtk_box_pack_end (GTK_BOX (previewEnableButtonHbox), previewEnableButton, FALSE, FALSE, 0);
 
@@ -1409,6 +1618,8 @@
   gtk_label_set_mnemonic_widget (GTK_LABEL (imageFileScalingMultLabel), imageFileScalingMultSpinButton);
   gtk_label_set_mnemonic_widget (GTK_LABEL (constantValueLabel), constantValueSpinButton);
   gtk_label_set_mnemonic_widget (GTK_LABEL (rollingAvgAlphaLabel), rollingAvgAlphaSpinButton);
+  gtk_label_set_mnemonic_widget (GTK_LABEL (rollingAvgLookaheadLabel1), rollingAvgLookaheadSpinButton);
+  gtk_label_set_mnemonic_widget (GTK_LABEL (rollingAvgLookaheadLabel2), rollingAvgLookaheadSpinButton);
   gtk_label_set_mnemonic_widget (GTK_LABEL (resultScalingAddLabel), resultScalingAddSpinButton);
   gtk_label_set_mnemonic_widget (GTK_LABEL (resultScalingMultLabel), resultScalingMultSpinButton);
   gtk_label_set_mnemonic_widget (GTK_LABEL (histogramLabel), histogramSpinButton);
@@ -1466,6 +1677,10 @@
   GLADE_HOOKUP_OBJECT (swiss_army_knife_dialog, rollingAvgAlphaSpinButton, &quot;rollingAvgAlphaSpinButton&quot;);
   GLADE_HOOKUP_OBJECT (swiss_army_knife_dialog, rollingAvgAlphaEqualsLabel, &quot;rollingAvgAlphaEqualsLabel&quot;);
   GLADE_HOOKUP_OBJECT (swiss_army_knife_dialog, rollingAvgAlphaDenomSpinButton, &quot;rollingAvgAlphaDenomSpinButton&quot;);
+  GLADE_HOOKUP_OBJECT (swiss_army_knife_dialog, rollingAvgLookaheadHbox, &quot;rollingAvgLookaheadHbox&quot;);
+  GLADE_HOOKUP_OBJECT (swiss_army_knife_dialog, rollingAvgLookaheadLabel1, &quot;rollingAvgLookaheadLabel1&quot;);
+  GLADE_HOOKUP_OBJECT (swiss_army_knife_dialog, rollingAvgLookaheadSpinButton, &quot;rollingAvgLookaheadSpinButton&quot;);
+  GLADE_HOOKUP_OBJECT (swiss_army_knife_dialog, rollingAvgLookaheadLabel2, &quot;rollingAvgLookaheadLabel2&quot;);
   GLADE_HOOKUP_OBJECT (swiss_army_knife_dialog, rollingAvgInitVbox, &quot;rollingAvgInitVbox&quot;);
   GLADE_HOOKUP_OBJECT (swiss_army_knife_dialog, rollingAvgInitHbox1, &quot;rollingAvgInitHbox1&quot;);
   GLADE_HOOKUP_OBJECT (swiss_army_knife_dialog, rollingAvgInitLabel1, &quot;rollingAvgInitLabel1&quot;);

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_eraser.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_eraser.cpp	2008-02-03 09:40:17 UTC (rev 3787)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_eraser.cpp	2008-02-03 12:04:10 UTC (rev 3788)
@@ -42,6 +42,7 @@
 #include &quot;DIA_flyDialog.h&quot;
 #include &quot;DIA_flyEraser.h&quot;
 #include &quot;ADM_userInterfaces/ADM_commonUI/DIA_factory.h&quot; // for diaElemMenu etc.
+#include &quot;ADM_filter/video_filters.h&quot;
 
 using namespace std;
 
@@ -73,6 +74,7 @@
     GtkTreeView * tree_view;
 public:
     GtkTreeSelection * tree_sel;
+    bool warned_about_scaling;
 
 public:
     uint8_t    download();
@@ -83,7 +85,7 @@
     flyEraserGtk (uint32_t width, uint32_t height,
                   AVDMGenericVideoStream * in,
                   void * canvas, void * slider, GtkWidget * dialog,
-                  ADMVideoEraser * eraserp, const ERASER_PARAM * in_param,
+                  ADMVideoEraser * eraserp, ERASER_PARAM * in_param,
                   const MenuMapping * menu_mapping,
                   uint32_t menu_mapping_count)
         : flyEraser (width, height, in, canvas, slider, dialog,
@@ -93,7 +95,8 @@
           tree_model (GTK_TREE_MODEL (list_store)),
           tree_view_widget (WID (rangeListTreeview)),
           tree_view (GTK_TREE_VIEW (tree_view_widget)),
-          tree_sel (gtk_tree_view_get_selection (tree_view))
+          tree_sel (gtk_tree_view_get_selection (tree_view)),
+          warned_about_scaling (false)
     {
         // printf (&quot;flyEraserGtk::flyEraserGtk: &quot;
         //         &quot;in_param %p, &amp;param %p\n&quot;, in_param, &amp;param);
@@ -112,10 +115,34 @@
 };
 
 static gboolean previewSomeEvent (GtkWidget * widget,
-                                  uint8_t button, uint16_t x, uint16_t y,
+                                  uint8_t button, float fx, float fy,
                                   guint state, gpointer data)
 {
     flyEraserGtk * myFly = static_cast &lt;flyEraserGtk *&gt; (data);
+
+    uint32_t x, y;
+
+    float zoom = myFly-&gt;getZoom();
+    if (zoom == 1.0)
+    {
+        x = static_cast &lt;uint32_t&gt; (fx);
+        y = static_cast &lt;uint32_t&gt; (fy);
+    }
+    else
+    {
+        if (!myFly-&gt;warned_about_scaling)
+        {
+            fprintf (stderr, &quot;******* WARNING: you are erasing in a &quot;
+                     &quot;scaled-down window (%.5f) - all pixel positions are &quot;
+                     &quot;therefore APPROXIMATE!!!\n&quot;, zoom);
+            myFly-&gt;warned_about_scaling = true;
+        }
+
+        zoom = 1 / zoom;
+        x = static_cast &lt;uint32_t&gt; (fx * zoom + .5);
+        y = static_cast &lt;uint32_t&gt; (fy * zoom + .5);
+    }
+
     bool erasing = (button == 1) ? myFly-&gt;param.brush_mode
                    : !myFly-&gt;param.brush_mode;
     ADMImage * image = myFly-&gt;getOutputImage();
@@ -355,11 +382,8 @@
     if (event-&gt;type != GDK_BUTTON_PRESS)
         return FALSE;
 
-    uint16_t x = static_cast &lt;uint16_t&gt; (event-&gt;x);
-    uint16_t y = static_cast &lt;uint16_t&gt; (event-&gt;y);
-
-    return previewSomeEvent (widget, event-&gt;button, x, y,
-                             event-&gt;state, data);
+    return previewSomeEvent (widget, event-&gt;button,
+                             event-&gt;x, event-&gt;y, event-&gt;state, data);
 }
 
 /********************************************************************/
@@ -371,9 +395,6 @@
     if (event-&gt;type != GDK_MOTION_NOTIFY)
         return FALSE;
 
-    uint16_t x = static_cast &lt;uint16_t&gt; (event-&gt;x);
-    uint16_t y = static_cast &lt;uint16_t&gt; (event-&gt;y);
-
     uint8_t button;
     if (event-&gt;state &amp; GDK_BUTTON1_MASK)
         button = 1;
@@ -384,7 +405,8 @@
     else
         return FALSE;
 
-    return previewSomeEvent (widget, button, x, y, event-&gt;state, data);
+    return previewSomeEvent (widget, button, event-&gt;x, event-&gt;y,
+                             event-&gt;state, data);
 }
 
 /********************************************************************/
@@ -483,11 +505,10 @@
 
     uint32_t middle_frame = (current_mask-&gt;first_frame
                              + current_mask-&gt;last_frame) / 2;
-    // HERE: a better test might be &quot;if (middle_frame &gt; last_actual_frame)&quot;...
-    if (current_mask-&gt;last_frame &gt;= MAX_FRAME_NUM)
+    if (middle_frame &gt;= _in-&gt;getInfo()-&gt;nb_frames)
         middle_frame = current_mask-&gt;first_frame;
 
-    if (middle_frame != sliderGet())
+    if (sliderGet() != middle_frame)
     {
         sliderSet (middle_frame);
         sliderChanged();
@@ -685,6 +706,58 @@
 
 /********************************************************************/
 
+static void previewOutputMenuChange (GtkComboBox * combo, gpointer user_data)
+{
+    flyEraserGtk * myFly = static_cast &lt;flyEraserGtk *&gt; (user_data);
+    uint32_t index = gtk_combo_box_get_active (combo);
+    uint32_t filter_count;
+    FILTER * filters = getCurrentVideoFilterList (&amp;filter_count);
+    FILTER * filter = filters + index;
+    VF_FILTERS tag = filter-&gt;tag;
+
+    gchar * activestr = gtk_combo_box_get_active_text (combo);
+
+    printf (&quot;user selected preview of #%d = %s (%d) @%p (was %p)\n&quot;,
+            index, activestr, tag, filter-&gt;filter, myFly-&gt;getSource());
+
+    if (strncmp (activestr, &quot;XX &quot;, 3) == 0)
+    {
+        printf (&quot;selected preview source has different dimensions - &quot;
+                &quot;forcing selection to current filter\n&quot;);
+        gtk_combo_box_set_active (combo, myFly-&gt;this_filter_index);
+    }
+    else
+    {
+        flyEraserGtk::PreviewMode mode;
+        if (index == myFly-&gt;this_filter_index)
+            mode = flyEraserGtk::PREVIEWMODE_THIS_FILTER;
+        else if (index &gt; myFly-&gt;this_filter_index)
+            mode = flyEraserGtk::PREVIEWMODE_LATER_FILTER;
+        else // if (index &lt; myFly-&gt;this_filter_index)
+            mode = flyEraserGtk::PREVIEWMODE_EARLIER_FILTER;
+
+        myFly-&gt;changeSource (filter-&gt;filter, mode);
+    }
+
+    g_free (activestr);
+}
+
+/********************************************************************/
+
+gboolean preview_video_configured (GtkWidget * widget, GdkEventConfigure * event,
+                                   gpointer user_data)
+{
+    fprintf (stderr, &quot;preview_configured: now %dx%d @ +%d+%d\n&quot;,
+             event-&gt;width, event-&gt;height, event-&gt;x, event-&gt;y);
+
+    flyEraserGtk * myFly = static_cast &lt;flyEraserGtk *&gt; (user_data);
+    myFly-&gt;recomputeSize();
+
+    return FALSE;
+}
+
+/********************************************************************/
+
 uint8_t DIA_eraser (AVDMGenericVideoStream * in, ADMVideoEraser * eraserp,
                     ERASER_PARAM * param, const MenuMapping * menu_mapping,
                     uint32_t menu_mapping_count)
@@ -729,6 +802,11 @@
                             WID(previewVideo), WID(previewSlider),
                             dialog, eraserp, param,
                             menu_mapping, menu_mapping_count);
+
+    g_signal_connect (GTK_OBJECT (WID(previewVideo)), &quot;configure-event&quot;,
+                      GTK_SIGNAL_FUNC (preview_video_configured),
+                      gpointer (myDialog));
+
     myDialog-&gt;upload();
     myDialog-&gt;sliderChanged();
 
@@ -809,6 +887,56 @@
                       GTK_SIGNAL_FUNC(jump_last_button_clicked),
                       gpointer(myDialog));
 
+    GtkWidget * previewOutputMenu = WID(previewOutputMenu);
+    uint32_t filter_count;
+    FILTER * filters = getCurrentVideoFilterList (&amp;filter_count);
+    int32_t active = -1;
+
+    // The &quot; + (active &lt; 0)&quot; below is a bit of a hack.  We know that in
+    // on_action() in gui_filtermanager.cpp, case A_ADD, the new filter-to-be
+    // is added to the filter list without incrementing nb_active_filter yet.
+    // So if we get to the end of the list and haven't yet found the filter
+    // that we're configuring, we know it's a new one and therefore that it is
+    // one past the apparent end of the list.  It's not a clean solution, but
+    // it seems like the cleanEST solution.
+
+    for (uint32_t i = 0; i &lt; filter_count + (active &lt; 0); i++)
+    {
+        const char * name
+            = (i == 0) ? &quot;(input)&quot; : filterGetNameFromTag (filters [i].tag);
+        bool free_name = false;
+                                   
+        FILTER * filter = filters + i;
+        AVDMGenericVideoStream * source = filter-&gt;filter;
+        uint32_t w = source-&gt;getInfo()-&gt;width;
+        uint32_t h = source-&gt;getInfo()-&gt;height;
+        if (w != width || h != height)
+        {
+            name = g_strconcat (&quot;XX &quot;, name, &quot; XX&quot;, NULL);
+            free_name = true;
+        }
+
+        printf (&quot;filter [%d] = %s (%d) @ %p; %dx%d\n&quot;,
+                i, name, filter-&gt;tag, source, w, h);
+        gtk_combo_box_append_text (GTK_COMBO_BOX (previewOutputMenu), name);
+        if (filter-&gt;filter == myDialog-&gt;getSource())
+        {
+            gtk_combo_box_set_active (GTK_COMBO_BOX (previewOutputMenu), i);
+            printf (&quot;\tfilter [%d] is being configured now\n&quot;, i);
+            active = i;
+        }
+
+        if (free_name)
+            g_free (const_cast &lt;char *&gt; (name));
+    }
+
+    ADM_assert (active &gt;= 0);
+    myDialog-&gt;this_filter_index = active;
+
+    g_signal_connect (GTK_OBJECT(previewOutputMenu), &quot;changed&quot;,
+                      GTK_SIGNAL_FUNC(previewOutputMenuChange),
+                      gpointer(myDialog));
+
     uint8_t ret = 0;
     int response = gtk_dialog_run(GTK_DIALOG(dialog));
 
@@ -823,9 +951,11 @@
             browse_button_clicked (NULL, gpointer (myDialog));
 
         myDialog-&gt;download();
-        myDialog-&gt;getParam (param);
+        myDialog-&gt;pushParam();
         ret = 1;
     }
+    else
+        myDialog-&gt;restoreParam();
 
     gtk_unregister_dialog(dialog);
     gtk_widget_destroy(dialog);
@@ -922,6 +1052,8 @@
     {
         uint32_t middle_frame = (current_mask-&gt;first_frame
                                  + current_mask-&gt;last_frame) / 2;
+        if (middle_frame &gt;= _in-&gt;getInfo()-&gt;nb_frames)
+            middle_frame = current_mask-&gt;first_frame;
         sliderSet (middle_frame);
         sliderChanged();
     }
@@ -1051,7 +1183,7 @@
   tooltips = gtk_tooltips_new ();
 
   eraser_dialog = gtk_dialog_new ();
-  //                                                NO NEED TO &quot;FIX&quot; THAT _()!!
+  //                                                NO NEED TO &quot;FIX&quot; THAT _(&quot;...&quot;)!!
   //                                                see handy macros near top of file.
   gtk_window_set_title (GTK_WINDOW (eraser_dialog), _(&quot;Eraser Configuration&quot;));
   gtk_window_set_type_hint (GTK_WINDOW (eraser_dialog), GDK_WINDOW_TYPE_HINT_DIALOG);
@@ -1276,9 +1408,8 @@
   gtk_box_pack_start (GTK_BOX (previewVbox), previewControlHbox, TRUE, TRUE, 0);
 
   previewOutputMenu = gtk_combo_box_new_text ();
+  gtk_widget_show (previewOutputMenu);
   gtk_box_pack_start (GTK_BOX (previewControlHbox), previewOutputMenu, FALSE, TRUE, 0);
-  gtk_combo_box_append_text (GTK_COMBO_BOX (previewOutputMenu), _(&quot;Eraser output&quot;));
-  gtk_combo_box_append_text (GTK_COMBO_BOX (previewOutputMenu), _(&quot;Final output&quot;));
 
   previewSlider = gtk_hscale_new (GTK_ADJUSTMENT (gtk_adjustment_new (0, 0, 99, 1, 1, 0)));
   gtk_widget_show (previewSlider);
@@ -1288,7 +1419,7 @@
   previewVideo = gtk_drawing_area_new ();
   gtk_widget_show (previewVideo);
   gtk_box_pack_start (GTK_BOX (previewVbox), previewVideo, TRUE, TRUE, 0);
-  gtk_widget_set_size_request (previewVideo, -1, 300);
+  gtk_widget_set_size_request (previewVideo, 30, 30);
   gtk_widget_set_events (previewVideo, GDK_BUTTON1_MOTION_MASK | GDK_BUTTON2_MOTION_MASK | GDK_BUTTON3_MOTION_MASK | GDK_BUTTON_PRESS_MASK);
 
   previewLabel = gtk_label_new (_(&quot;Preview&quot;));

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_flyDialog.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_flyDialog.cpp	2008-02-03 09:40:17 UTC (rev 3787)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_flyDialog.cpp	2008-02-03 12:04:10 UTC (rev 3788)
@@ -23,11 +23,18 @@
 #include &quot;DIA_factory.h&quot;
 #include &quot;ADM_assert.h&quot;
 
+#ifdef USE_JOG
+#include &quot;gui_action.hxx&quot;
+#include &quot;../ADM_toolkit_gtk/ADM_jogshuttle.h&quot;
+
+extern PhysicalJogShuttle *physical_jog_shuttle;
+#endif
+
 extern void GUI_RGBDisplay(uint8_t * dis, uint32_t w, uint32_t h, void *widg);
 extern float UI_calcZoomToFitScreen(GtkWindow* window, GtkWidget* drawingArea, uint32_t imageWidth, uint32_t imageHeight);
 extern void UI_centreCanvasWindow(GtkWindow *window, GtkWidget *canvas, int newCanvasWidth, int newCanvasHeight);
 
-void ADM_flyDialog::postInit(void)
+void ADM_flyDialog::postInit(uint8_t reInit)
 {
 	if (_slider)
 	{
@@ -39,9 +46,59 @@
 
 	GtkWindow *window = (GtkWindow*)gtk_widget_get_ancestor((GtkWidget*)_canvas, GTK_TYPE_WINDOW);
 	UI_centreCanvasWindow(window, (GtkWidget*)_canvas, _zoomW, _zoomH);
-	gtk_widget_set_usize((GtkWidget*)_canvas, _zoomW, _zoomH);
+	gtk_widget_set_size_request((GtkWidget*)_canvas, _zoomW, _zoomH);
+#ifdef USE_JOG
+	physical_jog_shuttle-&gt;registerCBs (this, PhysicalJogShuttle::NoButtonCB,
+                                           jogDial, jogRing);
+#endif
 }
 
+uint8_t  ADM_flyDialog::cleanup2(void)
+{
+#ifdef USE_JOG
+	physical_jog_shuttle-&gt;deregisterCBs (this);
+#endif
+}
+
+#ifdef USE_JOG
+void ADM_flyDialog::jogDial (void * my_data, signed short offset)
+{
+    ADM_flyDialog * myFly = static_cast &lt;ADM_flyDialog *&gt; (my_data);
+    myFly-&gt;sliderSet (myFly-&gt;sliderGet() + offset);
+}
+
+static guint jogRingTimerID = 0;
+static signed short jogRingIncr = 0;
+
+static gboolean on_jogRingTimer (gpointer data)
+{
+    gdk_threads_enter();
+
+    ADM_flyDialog * myFly = static_cast &lt;ADM_flyDialog *&gt; (data);
+    myFly-&gt;sliderSet (myFly-&gt;sliderGet() + jogRingIncr);
+
+    gdk_threads_leave();
+    return TRUE;
+}
+
+void ADM_flyDialog::jogRing (void * my_data, gfloat angle)
+{
+    if (jogRingTimerID)
+    {
+        g_source_remove (jogRingTimerID);
+        jogRingTimerID = 0;
+    }
+
+    if (angle &gt; -0.0001 &amp;&amp; angle &lt; 0.0001)
+        return;
+
+    jogRingIncr = (angle &lt; 0) ? -1 : +1;
+    angle *= jogRingIncr; // absolute value
+    jogRingTimerID = g_timeout_add (guint ((1 - angle) * 500 + 10),
+                                    on_jogRingTimer, my_data);
+}
+#endif
+
 float ADM_flyDialog::calcZoomFactor(void)
 {
 	GtkWindow *window = (GtkWindow*)gtk_widget_get_ancestor((GtkWidget*)_canvas, GTK_TYPE_WINDOW);

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_particle.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_particle.cpp	2008-02-03 09:40:17 UTC (rev 3787)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_particle.cpp	2008-02-03 12:04:10 UTC (rev 3788)
@@ -39,7 +39,11 @@
 #include &quot;DIA_flyDialog.h&quot;
 #include &quot;DIA_flyParticle.h&quot;
 #include &quot;ADM_userInterfaces/ADM_commonUI/DIA_factory.h&quot; // for diaElemMenu etc.
+#include &quot;ADM_filter/video_filters.h&quot;
 
+#undef _
+#define _(_s) QT_TR_NOOP(_s)
+
 /********************************************************************/
 static GtkWidget *create_particle_dialog (void);
 static GtkWidget *dialog = 0;
@@ -55,10 +59,23 @@
     if (event-&gt;type != GDK_BUTTON_PRESS)
         return FALSE;
 
-    uint32_t x = static_cast &lt;uint32_t&gt; (event-&gt;x);
-    uint32_t y = static_cast &lt;uint32_t&gt; (event-&gt;y);
+    flyParticle * myFly = static_cast &lt;flyParticle *&gt; (data);
 
-    flyParticle * myFly = static_cast &lt;flyParticle *&gt; (data);
+    uint32_t x, y;
+
+    float zoom = myFly-&gt;getZoom();
+    if (zoom == 1.0)
+    {
+        x = static_cast &lt;uint32_t&gt; (event-&gt;x);
+        y = static_cast &lt;uint32_t&gt; (event-&gt;y);
+    }
+    else
+    {
+        zoom = 1 / zoom;
+        x = static_cast &lt;uint32_t&gt; (event-&gt;x * zoom + .5);
+        y = static_cast &lt;uint32_t&gt; (event-&gt;y * zoom + .5);
+    }
+
     ADMImage * image = event-&gt;button == 1
         ? myFly-&gt;getInputImage() : myFly-&gt;getOutputImage();
 
@@ -182,7 +199,62 @@
 
 /********************************************************************/
 
+static void previewOutputMenuChange (GtkComboBox * combo, gpointer user_data)
+{
+    flyParticle * myFly = static_cast &lt;flyParticle *&gt; (user_data);
+    uint32_t index = gtk_combo_box_get_active (combo);
+    uint32_t filter_count;
+    FILTER * filters = getCurrentVideoFilterList (&amp;filter_count);
+    FILTER * filter = filters + index;
+    VF_FILTERS tag = filter-&gt;tag;
+
+
+    gchar * activestr = gtk_combo_box_get_active_text (combo);
+
+    printf (&quot;user selected preview of #%d = %s (%d) @%p (was %p)\n&quot;,
+            index, activestr, tag, filter-&gt;filter, myFly-&gt;getSource());
+
+    if (strncmp (activestr, &quot;XX &quot;, 3) == 0)
+    {
+        printf (&quot;selected preview source has different dimensions - &quot;
+                &quot;forcing selection to current filter\n&quot;);
+        gtk_combo_box_set_active (combo, myFly-&gt;this_filter_index);
+    }
+    else
+    {
+        flyParticle::PreviewMode mode;
+        if (index == myFly-&gt;this_filter_index)
+            mode = flyParticle::PREVIEWMODE_THIS_FILTER;
+        else if (index &gt; myFly-&gt;this_filter_index)
+            mode = flyParticle::PREVIEWMODE_LATER_FILTER;
+        else // if (index &lt; myFly-&gt;this_filter_index)
+            mode = flyParticle::PREVIEWMODE_EARLIER_FILTER;
+
+        myFly-&gt;changeSource (filter-&gt;filter, mode);
+    }
+
+    g_free (activestr);
+}
+
+/********************************************************************/
+
+static gboolean preview_video_configured (GtkWidget * widget,
+                                          GdkEventConfigure * event,
+                                          gpointer user_data)
+{
+    fprintf (stderr, &quot;preview_configured: now %dx%d @ +%d+%d\n&quot;,
+             event-&gt;width, event-&gt;height, event-&gt;x, event-&gt;y);
+
+    flyParticle * myFly = static_cast &lt;flyParticle *&gt; (user_data);
+    myFly-&gt;recomputeSize();
+
+    return FALSE;
+}
+
+/********************************************************************/
+
 uint8_t DIA_particle (AVDMGenericVideoStream *in,
+                      ADMVideoParticle * particlep,
                       PARTICLE_PARAM * param,
                       const MenuMapping * menu_mapping,
                       uint32_t menu_mapping_count)
@@ -208,8 +280,13 @@
     flyParticle * myDialog
         = new flyParticle (width, height, in,
                            WID(previewVideo), WID(previewSlider),
-                           GTK_DIALOG(dialog), param,
+                           GTK_DIALOG(dialog), particlep, param,
                            menu_mapping, menu_mapping_count);
+
+    g_signal_connect (GTK_OBJECT (WID(previewVideo)), &quot;configure-event&quot;,
+                      GTK_SIGNAL_FUNC (preview_video_configured),
+                      gpointer (myDialog));
+
     myDialog-&gt;upload();
     myDialog-&gt;sliderChanged();
 
@@ -243,15 +320,67 @@
                       gpointer(myDialog));
 #endif
 
+    GtkWidget * previewOutputMenu = WID(previewOutputMenu);
+    uint32_t filter_count;
+    FILTER * filters = getCurrentVideoFilterList (&amp;filter_count);
+    int32_t active = -1;
+
+    // The &quot; + (active &lt; 0)&quot; below is a bit of a hack.  We know that in
+    // on_action() in gui_filtermanager.cpp, case A_ADD, the new filter-to-be
+    // is added to the filter list without incrementing nb_active_filter yet.
+    // So if we get to the end of the list and haven't yet found the filter
+    // that we're configuring, we know it's a new one and therefore that it is
+    // one past the apparent end of the list.  It's not a clean solution, but
+    // it seems like the cleanEST solution.
+
+    for (uint32_t i = 0; i &lt; filter_count + (active &lt; 0); i++)
+    {
+        const char * name
+            = (i == 0) ? &quot;(input)&quot; : filterGetNameFromTag (filters [i].tag);
+        bool free_name = false;
+                                   
+        FILTER * filter = filters + i;
+        AVDMGenericVideoStream * source = filter-&gt;filter;
+        uint32_t w = source-&gt;getInfo()-&gt;width;
+        uint32_t h = source-&gt;getInfo()-&gt;height;
+        if (w != width || h != height)
+        {
+            name = g_strconcat (&quot;XX &quot;, name, &quot; XX&quot;, NULL);
+            free_name = true;
+        }
+
+        printf (&quot;filter [%d] = %s (%d) @ %p; %dx%d\n&quot;,
+                i, name, filter-&gt;tag, source, w, h);
+        gtk_combo_box_append_text (GTK_COMBO_BOX (previewOutputMenu), name);
+        if (filter-&gt;filter == myDialog-&gt;getSource())
+        {
+            gtk_combo_box_set_active (GTK_COMBO_BOX (previewOutputMenu), i);
+            printf (&quot;\tfilter [%d] is being configured now\n&quot;, i);
+            active = i;
+        }
+
+        if (free_name)
+            g_free (const_cast &lt;char *&gt; (name));
+    }
+
+    ADM_assert (active &gt;= 0);
+    myDialog-&gt;this_filter_index = active;
+
+    g_signal_connect (GTK_OBJECT(previewOutputMenu), &quot;changed&quot;,
+                      GTK_SIGNAL_FUNC(previewOutputMenuChange),
+                      gpointer(myDialog));
+
     uint8_t ret = 0;
     int response = gtk_dialog_run(GTK_DIALOG(dialog));
 
     if (response == GTK_RESPONSE_OK)
     {
         myDialog-&gt;download();
-        myDialog-&gt;getParam (param);
+        myDialog-&gt;pushParam();
         ret = 1;
     }
+    else
+        myDialog-&gt;restoreParam();
 
     gtk_unregister_dialog(dialog);
     gtk_widget_destroy(dialog);
@@ -350,7 +479,7 @@
   GtkWidget *particle_dialog;
   GtkWidget *dialogVbox;
   GtkWidget *dialogHbox;
-  GtkWidget *allButButtonsVbox;
+  GtkWidget *allButButtonsHbox;
   GtkWidget *settingsOuterHbox;
   GtkWidget *settingsOuterVbox;
   GtkWidget *minAreaHbox;
@@ -402,14 +531,15 @@
   GtkWidget *previewOutputMenu;
   GtkWidget *previewSlider;
   GtkWidget *previewVideo;
-  GtkWidget *previewDisabled;
   GtkWidget *previewLabel;
   GtkWidget *dialogButtonBox;
   GtkWidget *cancelButton;
   GtkWidget *okButton;
 
   particle_dialog = gtk_dialog_new ();
-  gtk_window_set_title (GTK_WINDOW (particle_dialog), QT_TR_NOOP(&quot;Particle Detection&quot;));
+  //                                                NO NEED TO &quot;FIX&quot; THAT _(&quot;...&quot;)!!
+  //                                                see handy macro near top of file.
+  gtk_window_set_title (GTK_WINDOW (particle_dialog), _(&quot;Particle Detection&quot;));
   gtk_window_set_type_hint (GTK_WINDOW (particle_dialog), GDK_WINDOW_TYPE_HINT_DIALOG);
 
   dialogVbox = GTK_DIALOG (particle_dialog)-&gt;vbox;
@@ -419,24 +549,24 @@
   gtk_widget_show (dialogHbox);
   gtk_box_pack_start (GTK_BOX (dialogVbox), dialogHbox, TRUE, TRUE, 0);
 
-  allButButtonsVbox = gtk_vbox_new (FALSE, 12);
-  gtk_widget_show (allButButtonsVbox);
-  gtk_box_pack_start (GTK_BOX (dialogHbox), allButButtonsVbox, TRUE, TRUE, 0);
-  gtk_container_set_border_width (GTK_CONTAINER (allButButtonsVbox), 8);
+  allButButtonsHbox = gtk_hbox_new (FALSE, 12);
+  gtk_widget_show (allButButtonsHbox);
+  gtk_box_pack_start (GTK_BOX (dialogHbox), allButButtonsHbox, TRUE, TRUE, 0);
+  gtk_container_set_border_width (GTK_CONTAINER (allButButtonsHbox), 8);
 
   settingsOuterHbox = gtk_hbox_new (FALSE, 0);
   gtk_widget_show (settingsOuterHbox);
-  gtk_box_pack_start (GTK_BOX (allButButtonsVbox), settingsOuterHbox, FALSE, TRUE, 0);
+  gtk_box_pack_start (GTK_BOX (allButButtonsHbox), settingsOuterHbox, FALSE, TRUE, 0);
 
   settingsOuterVbox = gtk_vbox_new (FALSE, 12);
   gtk_widget_show (settingsOuterVbox);
-  gtk_box_pack_start (GTK_BOX (settingsOuterHbox), settingsOuterVbox, TRUE, TRUE, 0);
+  gtk_box_pack_start (GTK_BOX (settingsOuterHbox), settingsOuterVbox, FALSE, TRUE, 0);
 
   minAreaHbox = gtk_hbox_new (FALSE, 0);
   gtk_widget_show (minAreaHbox);
-  gtk_box_pack_start (GTK_BOX (settingsOuterVbox), minAreaHbox, TRUE, TRUE, 0);
+  gtk_box_pack_start (GTK_BOX (settingsOuterVbox), minAreaHbox, FALSE, TRUE, 0);
 
-  minAreaLabel = gtk_label_new_with_mnemonic (QT_TR_NOOP(&quot;Mi_nimum area for a particle to be detected:    &quot;));
+  minAreaLabel = gtk_label_new_with_mnemonic (_(&quot;Mi_nimum area for a particle to be detected:    &quot;));
   gtk_widget_show (minAreaLabel);
   gtk_box_pack_start (GTK_BOX (minAreaHbox), minAreaLabel, FALSE, FALSE, 0);
 
@@ -448,9 +578,9 @@
 
   maxAreaHbox = gtk_hbox_new (FALSE, 0);
   gtk_widget_show (maxAreaHbox);
-  gtk_box_pack_start (GTK_BOX (settingsOuterVbox), maxAreaHbox, TRUE, TRUE, 0);
+  gtk_box_pack_start (GTK_BOX (settingsOuterVbox), maxAreaHbox, FALSE, TRUE, 0);
 
-  maxAreaLabel = gtk_label_new_with_mnemonic (QT_TR_NOOP(&quot;Ma_ximum area for a particle to be detected:   &quot;));
+  maxAreaLabel = gtk_label_new_with_mnemonic (_(&quot;Ma_ximum area for a particle to be detected:   &quot;));
   gtk_widget_show (maxAreaLabel);
   gtk_box_pack_start (GTK_BOX (maxAreaHbox), maxAreaLabel, FALSE, FALSE, 0);
 
@@ -462,13 +592,13 @@
 
   aboveCropSeparator = gtk_hseparator_new ();
   gtk_widget_show (aboveCropSeparator);
-  gtk_box_pack_start (GTK_BOX (settingsOuterVbox), aboveCropSeparator, TRUE, TRUE, 0);
+  gtk_box_pack_start (GTK_BOX (settingsOuterVbox), aboveCropSeparator, FALSE, TRUE, 0);
 
   leftCropHbox = gtk_hbox_new (FALSE, 0);
   gtk_widget_show (leftCropHbox);
-  gtk_box_pack_start (GTK_BOX (settingsOuterVbox), leftCropHbox, TRUE, TRUE, 0);
+  gtk_box_pack_start (GTK_BOX (settingsOuterVbox), leftCropHbox, FALSE, TRUE, 0);
 
-  leftCropLabel = gtk_label_new_with_mnemonic (QT_TR_NOOP(&quot;_Left side crop (ignore this many pixels on the left):        &quot;));
+  leftCropLabel = gtk_label_new_with_mnemonic (_(&quot;_Left side crop (ignore this many pixels on the left):        &quot;));
   gtk_widget_show (leftCropLabel);
   gtk_box_pack_start (GTK_BOX (leftCropHbox), leftCropLabel, FALSE, FALSE, 0);
 
@@ -480,9 +610,9 @@
 
   rightCropHbox = gtk_hbox_new (FALSE, 0);
   gtk_widget_show (rightCropHbox);
-  gtk_box_pack_start (GTK_BOX (settingsOuterVbox), rightCropHbox, TRUE, TRUE, 0);
+  gtk_box_pack_start (GTK_BOX (settingsOuterVbox), rightCropHbox, FALSE, TRUE, 0);
 
-  rightCropLabel = gtk_label_new_with_mnemonic (QT_TR_NOOP(&quot;_Right side crop (ignore this many pixels on the right):     &quot;));
+  rightCropLabel = gtk_label_new_with_mnemonic (_(&quot;_Right side crop (ignore this many pixels on the right):     &quot;));
   gtk_widget_show (rightCropLabel);
   gtk_box_pack_start (GTK_BOX (rightCropHbox), rightCropLabel, FALSE, FALSE, 0);
 
@@ -494,9 +624,9 @@
 
   topCropHbox = gtk_hbox_new (FALSE, 0);
   gtk_widget_show (topCropHbox);
-  gtk_box_pack_start (GTK_BOX (settingsOuterVbox), topCropHbox, TRUE, TRUE, 0);
+  gtk_box_pack_start (GTK_BOX (settingsOuterVbox), topCropHbox, FALSE, TRUE, 0);
 
-  topCropLabel = gtk_label_new_with_mnemonic (QT_TR_NOOP(&quot;_Top crop (ignore this many pixels on the top):                  &quot;));
+  topCropLabel = gtk_label_new_with_mnemonic (_(&quot;_Top crop (ignore this many pixels on the top):                  &quot;));
   gtk_widget_show (topCropLabel);
   gtk_box_pack_start (GTK_BOX (topCropHbox), topCropLabel, FALSE, FALSE, 0);
 
@@ -508,9 +638,9 @@
 
   bottomCropHbox = gtk_hbox_new (FALSE, 0);
   gtk_widget_show (bottomCropHbox);
-  gtk_box_pack_start (GTK_BOX (settingsOuterVbox), bottomCropHbox, TRUE, TRUE, 0);
+  gtk_box_pack_start (GTK_BOX (settingsOuterVbox), bottomCropHbox, FALSE, TRUE, 0);
 
-  bottomCropLabel = gtk_label_new_with_mnemonic (QT_TR_NOOP(&quot;_Bottom crop (ignore this many pixels on the bottom):   &quot;));
+  bottomCropLabel = gtk_label_new_with_mnemonic (_(&quot;_Bottom crop (ignore this many pixels on the bottom):   &quot;));
   gtk_widget_show (bottomCropLabel);
   gtk_box_pack_start (GTK_BOX (bottomCropHbox), bottomCropLabel, FALSE, FALSE, 0);
 
@@ -522,13 +652,13 @@
 
   belowCropSeparator = gtk_hseparator_new ();
   gtk_widget_show (belowCropSeparator);
-  gtk_box_pack_start (GTK_BOX (settingsOuterVbox), belowCropSeparator, TRUE, TRUE, 0);
+  gtk_box_pack_start (GTK_BOX (settingsOuterVbox), belowCropSeparator, FALSE, TRUE, 0);
 
   outputFormatHbox = gtk_hbox_new (FALSE, 0);
   gtk_widget_show (outputFormatHbox);
-  gtk_box_pack_start (GTK_BOX (settingsOuterVbox), outputFormatHbox, TRUE, TRUE, 0);
+  gtk_box_pack_start (GTK_BOX (settingsOuterVbox), outputFormatHbox, FALSE, TRUE, 0);
 
-  outputFormatLabel = gtk_label_new_with_mnemonic (QT_TR_NOOP(&quot;Output _Format:   &quot;));
+  outputFormatLabel = gtk_label_new_with_mnemonic (_(&quot;Output _Format:   &quot;));
   gtk_widget_show (outputFormatLabel);
   gtk_box_pack_start (GTK_BOX (outputFormatHbox), outputFormatLabel, FALSE, FALSE, 0);
 
@@ -538,9 +668,9 @@
 
   outputFileHbox = gtk_hbox_new (FALSE, 5);
   gtk_widget_show (outputFileHbox);
-  gtk_box_pack_start (GTK_BOX (settingsOuterVbox), outputFileHbox, TRUE, TRUE, 0);
+  gtk_box_pack_start (GTK_BOX (settingsOuterVbox), outputFileHbox, FALSE, TRUE, 0);
 
-  outputFileLabel = gtk_label_new_with_mnemonic (QT_TR_NOOP(&quot;_Output File:&quot;));
+  outputFileLabel = gtk_label_new_with_mnemonic (_(&quot;_Output File:&quot;));
   gtk_widget_show (outputFileLabel);
   gtk_box_pack_start (GTK_BOX (outputFileHbox), outputFileLabel, FALSE, FALSE, 0);
 
@@ -550,15 +680,15 @@
   gtk_entry_set_invisible_char (GTK_ENTRY (outputFileEntry), 8226);
   gtk_entry_set_width_chars (GTK_ENTRY (outputFileEntry), 40);
 
-  outputFileBrowseButton = gtk_button_new_with_mnemonic (QT_TR_NOOP(&quot;_Browse...&quot;));
+  outputFileBrowseButton = gtk_button_new_with_mnemonic (_(&quot;_Browse...&quot;));
   gtk_widget_show (outputFileBrowseButton);
   gtk_box_pack_start (GTK_BOX (outputFileHbox), outputFileBrowseButton, FALSE, FALSE, 0);
 
   cameraNumberHbox = gtk_hbox_new (FALSE, 0);
   gtk_widget_show (cameraNumberHbox);
-  gtk_box_pack_start (GTK_BOX (settingsOuterVbox), cameraNumberHbox, TRUE, TRUE, 0);
+  gtk_box_pack_start (GTK_BOX (settingsOuterVbox), cameraNumberHbox, FALSE, TRUE, 0);
 
-  cameraNumberLabel = gtk_label_new_with_mnemonic (QT_TR_NOOP(&quot;_Camera Number for output file:      &quot;));
+  cameraNumberLabel = gtk_label_new_with_mnemonic (_(&quot;_Camera Number for output file:      &quot;));
   gtk_widget_show (cameraNumberLabel);
   gtk_box_pack_start (GTK_BOX (cameraNumberHbox), cameraNumberLabel, FALSE, FALSE, 0);
 
@@ -570,9 +700,9 @@
 
   debugHbox = gtk_hbox_new (FALSE, 0);
   gtk_widget_show (debugHbox);
-  gtk_box_pack_start (GTK_BOX (settingsOuterVbox), debugHbox, TRUE, TRUE, 0);
+  gtk_box_pack_start (GTK_BOX (settingsOuterVbox), debugHbox, FALSE, TRUE, 0);
 
-  debugLabel = gtk_label_new_with_mnemonic (QT_TR_NOOP(&quot;_Debugging settings (bits):   &quot;));
+  debugLabel = gtk_label_new_with_mnemonic (_(&quot;_Debugging settings (bits):   &quot;));
   gtk_widget_show (debugLabel);
   gtk_box_pack_start (GTK_BOX (debugHbox), debugLabel, FALSE, FALSE, 0);
 
@@ -584,7 +714,7 @@
 
   previewVboxOuter = gtk_vbox_new (FALSE, 0);
   gtk_widget_show (previewVboxOuter);
-  gtk_box_pack_start (GTK_BOX (allButButtonsVbox), previewVboxOuter, TRUE, TRUE, 0);
+  gtk_box_pack_start (GTK_BOX (allButButtonsHbox), previewVboxOuter, TRUE, TRUE, 0);
 
   previewFrame = gtk_frame_new (NULL);
   gtk_widget_show (previewFrame);
@@ -604,9 +734,8 @@
   gtk_box_pack_start (GTK_BOX (previewVbox), previewControlHbox, TRUE, TRUE, 0);
 
   previewOutputMenu = gtk_combo_box_new_text ();
+  gtk_widget_show (previewOutputMenu);
   gtk_box_pack_start (GTK_BOX (previewControlHbox), previewOutputMenu, FALSE, TRUE, 0);
-  gtk_combo_box_append_text (GTK_COMBO_BOX (previewOutputMenu), QT_TR_NOOP(&quot;Swiss Army Knife output&quot;));
-  gtk_combo_box_append_text (GTK_COMBO_BOX (previewOutputMenu), QT_TR_NOOP(&quot;Final output&quot;));
 
   previewSlider = gtk_hscale_new (GTK_ADJUSTMENT (gtk_adjustment_new (0, 0, 99, 1, 1, 0)));
   gtk_widget_show (previewSlider);
@@ -616,13 +745,10 @@
   previewVideo = gtk_drawing_area_new ();
   gtk_widget_show (previewVideo);
   gtk_box_pack_start (GTK_BOX (previewVbox), previewVideo, TRUE, TRUE, 0);
-  gtk_widget_set_size_request (previewVideo, -1, 300);
+  gtk_widget_set_size_request (previewVideo, 30, 30);
   gtk_widget_set_events (previewVideo, GDK_BUTTON1_MOTION_MASK | GDK_BUTTON_PRESS_MASK);
 
-  previewDisabled = gtk_drawing_area_new ();
-  gtk_box_pack_start (GTK_BOX (previewVbox), previewDisabled, TRUE, TRUE, 0);
-
-  previewLabel = gtk_label_new (QT_TR_NOOP(&quot;Preview&quot;));
+  previewLabel = gtk_label_new (_(&quot;Preview&quot;));
   gtk_widget_show (previewLabel);
   gtk_frame_set_label_widget (GTK_FRAME (previewFrame), previewLabel);
 
@@ -654,7 +780,7 @@
   GLADE_HOOKUP_OBJECT_NO_REF (particle_dialog, particle_dialog, &quot;particle_dialog&quot;);
   GLADE_HOOKUP_OBJECT_NO_REF (particle_dialog, dialogVbox, &quot;dialogVbox&quot;);
   GLADE_HOOKUP_OBJECT (particle_dialog, dialogHbox, &quot;dialogHbox&quot;);
-  GLADE_HOOKUP_OBJECT (particle_dialog, allButButtonsVbox, &quot;allButButtonsVbox&quot;);
+  GLADE_HOOKUP_OBJECT (particle_dialog, allButButtonsHbox, &quot;allButButtonsHbox&quot;);
   GLADE_HOOKUP_OBJECT (particle_dialog, settingsOuterHbox, &quot;settingsOuterHbox&quot;);
   GLADE_HOOKUP_OBJECT (particle_dialog, settingsOuterVbox, &quot;settingsOuterVbox&quot;);
   GLADE_HOOKUP_OBJECT (particle_dialog, minAreaHbox, &quot;minAreaHbox&quot;);
@@ -698,7 +824,6 @@
   GLADE_HOOKUP_OBJECT (particle_dialog, previewOutputMenu, &quot;previewOutputMenu&quot;);
   GLADE_HOOKUP_OBJECT (particle_dialog, previewSlider, &quot;previewSlider&quot;);
   GLADE_HOOKUP_OBJECT (particle_dialog, previewVideo, &quot;previewVideo&quot;);
-  GLADE_HOOKUP_OBJECT (particle_dialog, previewDisabled, &quot;previewDisabled&quot;);
   GLADE_HOOKUP_OBJECT (particle_dialog, previewLabel, &quot;previewLabel&quot;);
   GLADE_HOOKUP_OBJECT_NO_REF (particle_dialog, dialogButtonBox, &quot;dialogButtonBox&quot;);
   GLADE_HOOKUP_OBJECT (particle_dialog, cancelButton, &quot;cancelButton&quot;);

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_threshold.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_threshold.cpp	2008-02-03 09:40:17 UTC (rev 3787)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_threshold.cpp	2008-02-03 12:04:10 UTC (rev 3788)
@@ -36,7 +36,11 @@
 #include &quot;ADM_assert.h&quot;
 #include &quot;DIA_flyDialog.h&quot;
 #include &quot;DIA_flyThreshold.h&quot;
+#include &quot;ADM_filter/video_filters.h&quot;
 
+#undef _
+#define _(_s) QT_TR_NOOP(_s)
+
 /********************************************************************/
 static GtkWidget *create_threshold_dialog (void);
 static GtkWidget *dialog = 0;
@@ -58,10 +62,23 @@
     if (event-&gt;type != GDK_BUTTON_PRESS)
         return FALSE;
 
-    uint32_t x = static_cast &lt;uint32_t&gt; (event-&gt;x);
-    uint32_t y = static_cast &lt;uint32_t&gt; (event-&gt;y);
+    flyThreshold * myFly = static_cast &lt;flyThreshold *&gt; (data);
 
-    flyThreshold * myFly = static_cast &lt;flyThreshold *&gt; (data);
+    uint32_t x, y;
+
+    float zoom = myFly-&gt;getZoom();
+    if (zoom == 1.0)
+    {
+        x = static_cast &lt;uint32_t&gt; (event-&gt;x);
+        y = static_cast &lt;uint32_t&gt; (event-&gt;y);
+    }
+    else
+    {
+        zoom = 1 / zoom;
+        x = static_cast &lt;uint32_t&gt; (event-&gt;x * zoom + .5);
+        y = static_cast &lt;uint32_t&gt; (event-&gt;y * zoom + .5);
+    }
+
     ADMImage * image = event-&gt;button == 1
         ? myFly-&gt;getInputImage() : myFly-&gt;getOutputImage();
 
@@ -116,8 +133,63 @@
 
 /********************************************************************/
 
-uint8_t DIA_threshold (AVDMGenericVideoStream *in, THRESHOLD_PARAM * param)
+static void previewOutputMenuChange (GtkComboBox * combo, gpointer user_data)
 {
+    flyThreshold * myFly = static_cast &lt;flyThreshold *&gt; (user_data);
+    uint32_t index = gtk_combo_box_get_active (combo);
+    uint32_t filter_count;
+    FILTER * filters = getCurrentVideoFilterList (&amp;filter_count);
+    FILTER * filter = filters + index;
+    VF_FILTERS tag = filter-&gt;tag;
+
+    gchar * activestr = gtk_combo_box_get_active_text (combo);
+
+    printf (&quot;user selected preview of #%d = %s (%d) @%p (was %p)\n&quot;,
+            index, activestr, tag, filter-&gt;filter, myFly-&gt;getSource());
+
+    if (strncmp (activestr, &quot;XX &quot;, 3) == 0)
+    {
+        printf (&quot;selected preview source has different dimensions - &quot;
+                &quot;forcing selection to current filter\n&quot;);
+        gtk_combo_box_set_active (combo, myFly-&gt;this_filter_index);
+    }
+    else
+    {
+        flyThreshold::PreviewMode mode;
+        if (index == myFly-&gt;this_filter_index)
+            mode = flyThreshold::PREVIEWMODE_THIS_FILTER;
+        else if (index &gt; myFly-&gt;this_filter_index)
+            mode = flyThreshold::PREVIEWMODE_LATER_FILTER;
+        else // if (index &lt; myFly-&gt;this_filter_index)
+            mode = flyThreshold::PREVIEWMODE_EARLIER_FILTER;
+
+        myFly-&gt;changeSource (filter-&gt;filter, mode);
+    }
+
+    g_free (activestr);
+}
+
+/********************************************************************/
+
+static gboolean preview_video_configured (GtkWidget * widget,
+                                          GdkEventConfigure * event,
+                                          gpointer user_data)
+{
+    fprintf (stderr, &quot;preview_configured: now %dx%d @ +%d+%d\n&quot;,
+             event-&gt;width, event-&gt;height, event-&gt;x, event-&gt;y);
+
+    flyThreshold * myFly = static_cast &lt;flyThreshold *&gt; (user_data);
+    myFly-&gt;recomputeSize();
+
+    return FALSE;
+}
+
+/********************************************************************/
+
+uint8_t DIA_threshold (AVDMGenericVideoStream *in,
+                       ADMVideoThreshold * thresholdp,
+                       THRESHOLD_PARAM * param)
+{
     // Allocate space for preview video
     uint32_t width = in-&gt;getInfo()-&gt;width;
     uint32_t height = in-&gt;getInfo()-&gt;height;
@@ -130,7 +202,12 @@
 
     myDialog = new flyThreshold (width, height, in,
                                  WID(previewVideo), WID(previewSlider),
-                                 param);
+                                 thresholdp, param);
+
+    g_signal_connect (GTK_OBJECT (WID(previewVideo)), &quot;configure-event&quot;,
+                      GTK_SIGNAL_FUNC (preview_video_configured),
+                      gpointer (myDialog));
+
     myDialog-&gt;upload();
     myDialog-&gt;sliderChanged();
 
@@ -161,15 +238,67 @@
                      gpointer(myDialog));
 #endif
 
+    GtkWidget * previewOutputMenu = WID(previewOutputMenu);
+    uint32_t filter_count;
+    FILTER * filters = getCurrentVideoFilterList (&amp;filter_count);
+    int32_t active = -1;
+
+    // The &quot; + (active &lt; 0)&quot; below is a bit of a hack.  We know that in
+    // on_action() in gui_filtermanager.cpp, case A_ADD, the new filter-to-be
+    // is added to the filter list without incrementing nb_active_filter yet.
+    // So if we get to the end of the list and haven't yet found the filter
+    // that we're configuring, we know it's a new one and therefore that it is
+    // one past the apparent end of the list.  It's not a clean solution, but
+    // it seems like the cleanEST solution.
+
+    for (uint32_t i = 0; i &lt; filter_count + (active &lt; 0); i++)
+    {
+        const char * name
+            = (i == 0) ? &quot;(input)&quot; : filterGetNameFromTag (filters [i].tag);
+        bool free_name = false;
+                                   
+        FILTER * filter = filters + i;
+        AVDMGenericVideoStream * source = filter-&gt;filter;
+        uint32_t w = source-&gt;getInfo()-&gt;width;
+        uint32_t h = source-&gt;getInfo()-&gt;height;
+        if (w != width || h != height)
+        {
+            name = g_strconcat (&quot;XX &quot;, name, &quot; XX&quot;, NULL);
+            free_name = true;
+        }
+
+        printf (&quot;filter [%d] = %s (%d) @ %p; %dx%d\n&quot;,
+                i, name, filter-&gt;tag, source, w, h);
+        gtk_combo_box_append_text (GTK_COMBO_BOX (previewOutputMenu), name);
+        if (filter-&gt;filter == myDialog-&gt;getSource())
+        {
+            gtk_combo_box_set_active (GTK_COMBO_BOX (previewOutputMenu), i);
+            printf (&quot;\tfilter [%d] is being configured now\n&quot;, i);
+            active = i;
+        }
+
+        if (free_name)
+            g_free (const_cast &lt;char *&gt; (name));
+    }
+
+    ADM_assert (active &gt;= 0);
+    myDialog-&gt;this_filter_index = active;
+
+    g_signal_connect (GTK_OBJECT(previewOutputMenu), &quot;changed&quot;,
+                      GTK_SIGNAL_FUNC(previewOutputMenuChange),
+                      gpointer(myDialog));
+
     uint8_t ret = 0;
     int response = gtk_dialog_run(GTK_DIALOG(dialog));
 
     if (response == GTK_RESPONSE_OK)
     {
         myDialog-&gt;download();
-        myDialog-&gt;getParam (param);
+        myDialog-&gt;pushParam();
         ret = 1;
     }
+    else
+        myDialog-&gt;restoreParam();
 
     gtk_unregister_dialog(dialog);
     gtk_widget_destroy(dialog);
@@ -396,13 +525,8 @@
   gtk_box_pack_start (GTK_BOX (previewVbox), previewControlHbox, TRUE, TRUE, 0);
 
   previewOutputMenu = gtk_combo_box_new_text ();
-#ifdef ORIGINAL_CODE_GENERATED_BY_GLADE
-  // temporarily (?) disable this until it's actually implemented
   gtk_widget_show (previewOutputMenu);
-#endif
   gtk_box_pack_start (GTK_BOX (previewControlHbox), previewOutputMenu, FALSE, TRUE, 0);
-  gtk_combo_box_append_text (GTK_COMBO_BOX (previewOutputMenu), QT_TR_NOOP(&quot;Threshold output&quot;));
-  gtk_combo_box_append_text (GTK_COMBO_BOX (previewOutputMenu), QT_TR_NOOP(&quot;Final output&quot;));
 
   previewSlider = gtk_hscale_new (GTK_ADJUSTMENT (gtk_adjustment_new (0, 0, 99, 1, 1, 1)));
   gtk_widget_show (previewSlider);
@@ -412,7 +536,7 @@
   previewVideo = gtk_drawing_area_new ();
   gtk_widget_show (previewVideo);
   gtk_box_pack_start (GTK_BOX (previewVbox), previewVideo, TRUE, TRUE, 0);
-  gtk_widget_set_size_request (previewVideo, -1, 300);
+  gtk_widget_set_size_request (previewVideo, 30, 30);
   gtk_widget_set_events (previewVideo, GDK_BUTTON1_MOTION_MASK | GDK_BUTTON_PRESS_MASK);
 
   previewLabel = gtk_label_new (QT_TR_NOOP(&quot;Preview&quot;));

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_filters/gui_filtermanager.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_filters/gui_filtermanager.cpp	2008-02-03 09:40:17 UTC (rev 3787)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_filters/gui_filtermanager.cpp	2008-02-03 12:04:10 UTC (rev 3788)
@@ -181,6 +181,7 @@
         CONFcouple *coup;
         videofilters[nb_active_filter].filter =
             filterCreateFromTag (tag, NULL, videofilters[nb_active_filter - 1].filter);
+        videofilters[nb_active_filter].tag = tag;
         if(!videofilters[nb_active_filter].filter-&gt;
                     configure (videofilters[nb_active_filter - 1].filter))
         {
@@ -188,7 +189,6 @@
             break;
         }
         videofilters[nb_active_filter].filter-&gt;getCoupledConf (&amp;coup);
-        videofilters[nb_active_filter].tag = tag;
         videofilters[nb_active_filter].conf = coup;
         nb_active_filter++;
         updateFilterList ();
@@ -401,6 +401,8 @@
 #define CALLME(x,y) gtk_dialog_add_action_widget (GTK_DIALOG (dialog), WID(x), y)
 
 	//CALLME (toolbuttonAdd, A_ADD);
+        // Each of these triggers the following message:
+        // Gtk-CRITICAL **: gtk_box_pack_end: assertion `child-&gt;parent == NULL' failed
         CALLME (buttonRemove,		A_REMOVE);
         CALLME (buttonProperties,	A_CONFIGURE);
         CALLME (buttonUp, 		A_UP);

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_toolkit_gtk/ADM_jogshuttle.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_toolkit_gtk/ADM_jogshuttle.cpp	2008-02-03 09:40:17 UTC (rev 3787)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_toolkit_gtk/ADM_jogshuttle.cpp	2008-02-03 12:04:10 UTC (rev 3788)
@@ -52,10 +52,7 @@
 #include &quot;jogshuttle.h&quot;
 #include &quot;ADM_jogshuttle.h&quot;
 #include &quot;ADM_image.h&quot;
-#include &quot;gtkgui.h&quot;
 
-GtkWidget * lookup_jog_shuttle_widget (void); // GUI_bindings.cpp
-
 /// PhysicalJogShuttle
 
 /** The global PhysicalJogShuttle object.
@@ -79,7 +76,6 @@
 /** Constructor
  */
 PhysicalJogShuttle::PhysicalJogShuttle() :
-    _callback (0),
     input_ (-1),
     monitorTag_ (-1),
     _modifier_code (0),
@@ -191,6 +187,18 @@
     }
 }
 
+void PhysicalJogShuttle::NoButtonCB (void *, unsigned short, Action)
+{
+}
+
+void PhysicalJogShuttle::NoJogDialCB (void *, signed short)
+{
+}
+
+void PhysicalJogShuttle::NoShuttleRingCB (void *, gfloat)
+{
+}
+
 /// A static wrappper for the GDK input handler callback
 void PhysicalJogShuttle::inputCallback (gpointer data, gint source,
                                         GdkInputCondition condition)
@@ -234,34 +242,37 @@
         media_ctrl_close (&amp;_ctrl);
 }
 
-#if 0
 /** Register callback
  
-    Register an interest in getting notification when buttons are pressed
-    
-    \param callback Function to call
+    Register an interest in getting notification when buttons are pressed or
+    the jog dial or shuttle ring are manipulated
 */
-void PhysicalJogShuttle::registerCallback (void * user, JogShuttleCallback callback)
+void PhysicalJogShuttle::registerCBs (void * their_data,
+                                      ButtonCallback button_cb,
+                                      JogDialCallback jogdial_cb,
+                                      ShuttleRingCallback shuttlering_cb)
 {
-    if (_callback)
-        g_warning (&quot;PhysicalJogShuttle::registerCallback - already registered\n&quot;);
-    _callback = callback;
-    _callbackdata = user;
+    cbstack.push (Callbacks (their_data, button_cb, jogdial_cb, shuttlering_cb));
 }
 
 /** Deregister callback
  
     Deregister an interest in getting notification when buttons are pressed
-    
-    \param callback Function to stop calling
 */
-void PhysicalJogShuttle::deregisterCallback ()
+void PhysicalJogShuttle::deregisterCBs (void * their_data)
 {
-    if (_callback == NULL)
-        g_warning( &quot;PhysicalJogShuttle::deregisterCallback - not registered\n&quot;);
-    _callback = 0;
+    if (cbstack.empty())
+        g_warning( &quot;PhysicalJogShuttle::deregister (callback) - none registered\n&quot;);
+    else
+    {
+        // if the data doesn't match, we could in theory search down the stack
+        // to see if someone skipped a deregister() call.  But more than one
+        // may have passed NULL as the data...
+        if (their_data != cbstack.top().their_data)
+            g_warning( &quot;PhysicalJogShuttle::deregister (callback) - data doesn't match!!\n&quot;);
+        cbstack.pop();
+    }
 }
-#endif
 
 struct media_ctrl_key *PhysicalJogShuttle::getKeyset ()
 {
@@ -281,50 +292,36 @@
 {
     gdk_threads_enter();
     // printf (&quot;jog %d\n&quot;, offs);
-    if (offs &lt; 0)
-        GUI_PrevFrame (uint32_t (-offs));
-    else
-        GUI_NextFrame (uint32_t (offs));
+
+    if (!cbstack.empty())
+    {
+        Callbacks &amp; cb = cbstack.top();
+        if (cb.jogdial_cb)
+            cb.jogdial_cb (cb.their_data, offs);
+    }
+
     gdk_threads_leave();
 }
 
 /** Handle movement of the shuttle ring.
  
-    \param angle A number from -15 to +15 that specifies a direction and speed.
+    \param angle A number from -1.0 to +1.0 that specifies a direction and speed.
 */
 void PhysicalJogShuttle::shuttle (gfloat angle)
 {
     gdk_threads_enter();
     // printf (&quot;shuttle %f\n&quot;, angle);
-    GtkWidget * jsw = lookup_jog_shuttle_widget();
-    if (jsw)
-        jog_shuttle_set_value (jsw, angle);
-    gdk_threads_leave();
-}
 
-// This is part of a hack to allow the user to attach the Play and Stop
-// actions to buttons.  The problem is that once we launch the Play action,
-// HandleAction() doesn't return to its caller until avidemux stops playing,
-// so if HandleAction() is called directly from the event handler, there is no
-// way for the Stop button to be seen until something else has already stopped
-// it.  However, if we have the event handler just set up a timer, which
-// launches the play action, it's only the timer that is locked up, and since
-// we only use the timer for the Play action (and not any of the other
-// buttons), then everything (including the Stop button) works just fine.
-// A GTK expert might know of a better way to solve this problem, but I'm not
-// convinced that one exists in current GTK (2.10 on my FC7 system, but we
-// need to support older ones, too).
+    if (!cbstack.empty())
+    {
+        Callbacks &amp; cb = cbstack.top();
+        if (cb.shuttlering_cb)
+            cb.shuttlering_cb (cb.their_data, angle);
+    }
 
-gint
-on_PlayButtonHackTimer (gpointer data)
-{
-   gdk_threads_enter();
-   HandleAction (ACT_PlayAvi);
-   gdk_threads_leave();
-   return 0;
+    gdk_threads_leave();
 }
 
-
 /** Handle key press
  
     \param ev The key event
@@ -346,6 +343,15 @@
     // Note: the modifier stuff is carried over from kino, but not currently
     // in use here.  I've left it here just in case someone decides to enable
     // it some day.  However, it doesn't seem to work the way I would expect.
+    // Probably the best thing would be to implement full modifier support
+    // wherein the standard keyboard modifiers work (Shift, Control, Alt,
+    // Meta, etc.) and (ideally) you can also select buttons on the device to
+    // act as true modifiers (that is, they work like the
+    // Shift/Control/etc. keys), rather than the hackish thing that is
+    // half-implemented here.  Or maybe it's easier on the user to have it be
+    // a button-sequence thing where you hit the &quot;modifier&quot; and then the other
+    // button, and don't have to hold one down.  I suppose the best thing
+    // would be to give the user the option...
 
     /* 
        Release may need to clear a modifier key
@@ -356,63 +362,49 @@
         return;
     }
 
-    /* Do a callback or action based command */
-    if (_callback != 0)
-    {
-        /* This is a key press - if there are no modifier, make sure that
-           this is saved */
-        if (_modifier_code == 0)
-            _modifier_code = ev-&gt;index + 1;
+    /* This is a key press - if there are no modifiers, make sure that
+       this is saved */
+    if (_modifier_code == 0)
+        _modifier_code = ev-&gt;code;
 
-        if (_modifier_code != ev-&gt;index + 1)
-        {
-            first = _modifier_code - 1;
-            second = ev-&gt;index + 1;
-        }
-        else
-        {
-            first = ev-&gt;index; /* Same as modifier */
-            second = 0;
-        }
-        _callback (_callbackdata, first, second);
+    if (_modifier_code != ev-&gt;code)
+    {
+        first = _modifier_code;
+        second = ev-&gt;code;
     }
     else
     {
-        /* This is a key press - if there are no modifier, make sure that
-           this is saved */
-        if (_modifier_code == 0)
-            _modifier_code = ev-&gt;code;
-
-        if (_modifier_code != ev-&gt;code)
-        {
-            first = _modifier_code;
-            second = ev-&gt;code;
-        }
-        else
-        {
-            first = ev-&gt;code; /* Same as modifier */
-            second = 0;
-        }
+        first = ev-&gt;code; /* Same as modifier */
+        second = 0;
+    }
 		
-        gdk_threads_enter();
+    gdk_threads_enter();
 
-        ButtonActionIter it = button_action_map.find (first);
-        if (it != button_action_map.end())
-        {
-            if (show_buttons)
-                printf (&quot;button pressed: %d -&gt; %s\n&quot;,
-                        first, getActionName (it-&gt;second));
-            // hack alert: see comment for on_PlayButtonHackTimer(), above
-            if (it-&gt;second == ACT_PlayAvi)
-                g_timeout_add (10, on_PlayButtonHackTimer, NULL);
-            else
-                HandleAction (it-&gt;second);
-        }
-        else if (show_buttons)
-            printf (&quot;button pressed: %d (not mapped)\n&quot;, first);
+    ButtonActionIter it = button_action_map.find (first);
+    Action actn;
+    const char * name;
+    if (it == button_action_map.end())
+    {
+        actn = ACT_INVALID;
+        name = &quot;(not mapped)&quot;;
+    }
+    else
+    {
+        actn = it-&gt;second;
+        name = getActionName (actn);
+    }
 
-        gdk_threads_leave();
+    if (show_buttons)
+        printf (&quot;button pressed: %d -&gt; %d: %s\n&quot;, first, actn, name);
+
+    if (!cbstack.empty())
+    {
+        Callbacks &amp; cb = cbstack.top();
+        if (cb.button_cb)
+            cb.button_cb (cb.their_data, first, actn);
     }
+
+    gdk_threads_leave();
 }
 
 

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_toolkit_gtk/ADM_jogshuttle.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_toolkit_gtk/ADM_jogshuttle.h	2008-02-03 09:40:17 UTC (rev 3787)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_toolkit_gtk/ADM_jogshuttle.h	2008-02-03 12:04:10 UTC (rev 3788)
@@ -25,6 +25,8 @@
 #define JOGSHUTTLE_H
 
 #include &lt;map&gt;
+#include &lt;stack&gt;
+#include &lt;vector&gt;
 
 #include &lt;gtk/gtk.h&gt;
 #ifdef USE_JOG
@@ -42,7 +44,7 @@
 /**
  * Class to encapsulate an abstract JogShuttle device.
  * 
- * This class is used by the kino core to interact with a JogShuttle
+ * This class was used by the kino core to interact with a JogShuttle
  * device.  (Also used by the preference dialog for configuration).
  * It depends on the GDK input system, and uses the libmediactrl stuff
  * to translate different (more or less broken) devices events into
@@ -51,14 +53,45 @@
 
 class PhysicalJogShuttle
 { 
-private: 
+public:
+    typedef void (* ButtonCallback) (void * your_data,
+                                     unsigned short raw_button,
+                                     Action gui_action);
+    typedef void (* JogDialCallback) (void * your_data,
+                                      signed short offset); // typ. -1 or +1
+    typedef void (* ShuttleRingCallback) (void * your_data,
+                                          gfloat angle); // -1.0 to 0 to +1.0
+
+    static void NoButtonCB (void *, unsigned short, Action);
+    static void NoJogDialCB (void *, signed short);
+    static void NoShuttleRingCB (void *, gfloat);
+
+private:
     /** Singleton pattern. */
     static PhysicalJogShuttle *_instance; 
-    /** Placeholder for callbacks. */
-    JogShuttleCallback _callback; 
-    /** Any client supplied callbackdata is here. */
-    void * _callbackdata;
 
+    struct Callbacks
+    {
+        void * their_data;
+        ButtonCallback button_cb;
+        JogDialCallback jogdial_cb;
+        ShuttleRingCallback shuttlering_cb;
+
+        Callbacks (void * their_data,
+                   ButtonCallback button_cb,
+                   JogDialCallback jogdial_cb,
+                   ShuttleRingCallback shuttlering_cb)
+            : their_data (their_data),
+              button_cb (button_cb),
+              jogdial_cb (jogdial_cb),
+              shuttlering_cb (shuttlering_cb)
+        {
+        }
+    };
+
+    typedef std::stack &lt;Callbacks, std::vector &lt;Callbacks&gt; &gt; CallbackStack;
+    CallbackStack cbstack;
+
 protected:
     static void inputCallback (gpointer data, gint source,
                                GdkInputCondition condition);
@@ -70,8 +103,11 @@
     bool start();
     void stop();
     static PhysicalJogShuttle &amp; getInstance();
-    void registerCallback (void * user, JogShuttleCallback callback);
-    void deregisterCallback();
+    void registerCBs (void * your_data,
+                      ButtonCallback button_cb,
+                      JogDialCallback jogdial_cb,
+                      ShuttleRingCallback shuttlering_cb);
+    void deregisterCBs (void * your_data);
     struct media_ctrl_key *getKeyset();
 
 private:

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_toolkit_gtk/mediactrl.c
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_toolkit_gtk/mediactrl.c	2008-02-03 09:40:17 UTC (rev 3787)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/ADM_toolkit_gtk/mediactrl.c	2008-02-03 12:04:10 UTC (rev 3788)
@@ -212,6 +212,7 @@
                         // and 1.  But I'm going to do it in a way that leaves
                         // the remaining values proportionate.
 				
+			//printf(&quot;Shuttle raw: %d\n&quot;, cv);
 			if ( cv == ctrl-&gt;lastshu ) return;
 			ctrl-&gt;lastshu = cv;
 				
@@ -376,7 +377,7 @@
 
 int probe_device(struct media_ctrl *mc, const char * devname)
 {
-	short devinfo[4];
+	struct input_id devinfo;
 	int i = 0;
 	  
         /* suck out the name information 
@@ -396,12 +397,15 @@
 	}
 	
 	do {
-		if ( supported_devices[i].vendor == devinfo[1] 
-			&amp;&amp; supported_devices[i].product == devinfo[2] ) {
+		if ( supported_devices[i].vendor == devinfo.vendor
+			&amp;&amp; supported_devices[i].product == devinfo.product ) {
 				
 			mc-&gt;device = &amp;supported_devices[i];
-			printf(&quot;Success on %s: %s: %s\n&quot;,
-                               devname, name, mc-&gt;device-&gt;name);
+			printf(&quot;Success on %s: %s = %s (bus %04x vendor %04x &quot;
+                               &quot;product %04x version %04x)\n&quot;,
+                               devname, name, mc-&gt;device-&gt;name,
+                               devinfo.bustype, devinfo.vendor,
+                               devinfo.product, devinfo.version);
 			// mc-&gt;fd = fd;
 			// mc-&gt;translate = mc-&gt;device.translate_function;
 			// mc = malloc(sizeof(struct media_ctrl));
@@ -416,7 +420,10 @@
 	
 	} while ( supported_devices[++i].vendor != 0 );
 			
-        printf(&quot;Not interested in %s: %s\n&quot;, devname, name);
+        printf(&quot;Not interested in %s: %s (bus %04x vendor %04x &quot;
+               &quot;product %04x version %04x)\n&quot;,
+               devname, name, devinfo.bustype, devinfo.vendor,
+               devinfo.product, devinfo.version);
 	return 0;
 }
 

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/glade/eraser.glade
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/glade/eraser.glade	2008-02-03 09:40:17 UTC (rev 3787)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/glade/eraser.glade	2008-02-03 12:04:10 UTC (rev 3788)
@@ -798,8 +798,8 @@
 
 			      &lt;child&gt;
 				&lt;widget class=&quot;GtkComboBox&quot; id=&quot;previewOutputMenu&quot;&gt;
-				  &lt;property name=&quot;items&quot; translatable=&quot;yes&quot;&gt;Eraser output
-Final output&lt;/property&gt;
+				  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+				  &lt;property name=&quot;items&quot; translatable=&quot;yes&quot;&gt;&lt;/property&gt;
 				  &lt;property name=&quot;add_tearoffs&quot;&gt;False&lt;/property&gt;
 				  &lt;property name=&quot;focus_on_click&quot;&gt;True&lt;/property&gt;
 				&lt;/widget&gt;
@@ -837,7 +837,8 @@
 
 			  &lt;child&gt;
 			    &lt;widget class=&quot;GtkDrawingArea&quot; id=&quot;previewVideo&quot;&gt;
-			      &lt;property name=&quot;height_request&quot;&gt;300&lt;/property&gt;
+			      &lt;property name=&quot;width_request&quot;&gt;30&lt;/property&gt;
+			      &lt;property name=&quot;height_request&quot;&gt;30&lt;/property&gt;
 			      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
 			      &lt;property name=&quot;events&quot;&gt;GDK_BUTTON1_MOTION_MASK | GDK_BUTTON2_MOTION_MASK | GDK_BUTTON3_MOTION_MASK | GDK_BUTTON_PRESS_MASK&lt;/property&gt;
 			    &lt;/widget&gt;

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/glade/particle.glade
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/glade/particle.glade	2008-02-03 09:40:17 UTC (rev 3787)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/glade/particle.glade	2008-02-03 12:04:10 UTC (rev 3788)
@@ -72,7 +72,7 @@
 	  &lt;property name=&quot;spacing&quot;&gt;0&lt;/property&gt;
 
 	  &lt;child&gt;
-	    &lt;widget class=&quot;GtkVBox&quot; id=&quot;allButButtonsVbox&quot;&gt;
+	    &lt;widget class=&quot;GtkHBox&quot; id=&quot;allButButtonsHbox&quot;&gt;
 	      &lt;property name=&quot;border_width&quot;&gt;8&lt;/property&gt;
 	      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
 	      &lt;property name=&quot;homogeneous&quot;&gt;False&lt;/property&gt;
@@ -143,7 +143,7 @@
 			&lt;/widget&gt;
 			&lt;packing&gt;
 			  &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
-			  &lt;property name=&quot;expand&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;expand&quot;&gt;False&lt;/property&gt;
 			  &lt;property name=&quot;fill&quot;&gt;True&lt;/property&gt;
 			&lt;/packing&gt;
 		      &lt;/child&gt;
@@ -201,7 +201,7 @@
 			&lt;/widget&gt;
 			&lt;packing&gt;
 			  &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
-			  &lt;property name=&quot;expand&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;expand&quot;&gt;False&lt;/property&gt;
 			  &lt;property name=&quot;fill&quot;&gt;True&lt;/property&gt;
 			&lt;/packing&gt;
 		      &lt;/child&gt;
@@ -212,7 +212,7 @@
 			&lt;/widget&gt;
 			&lt;packing&gt;
 			  &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
-			  &lt;property name=&quot;expand&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;expand&quot;&gt;False&lt;/property&gt;
 			  &lt;property name=&quot;fill&quot;&gt;True&lt;/property&gt;
 			&lt;/packing&gt;
 		      &lt;/child&gt;
@@ -270,7 +270,7 @@
 			&lt;/widget&gt;
 			&lt;packing&gt;
 			  &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
-			  &lt;property name=&quot;expand&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;expand&quot;&gt;False&lt;/property&gt;
 			  &lt;property name=&quot;fill&quot;&gt;True&lt;/property&gt;
 			&lt;/packing&gt;
 		      &lt;/child&gt;
@@ -328,7 +328,7 @@
 			&lt;/widget&gt;
 			&lt;packing&gt;
 			  &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
-			  &lt;property name=&quot;expand&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;expand&quot;&gt;False&lt;/property&gt;
 			  &lt;property name=&quot;fill&quot;&gt;True&lt;/property&gt;
 			&lt;/packing&gt;
 		      &lt;/child&gt;
@@ -386,7 +386,7 @@
 			&lt;/widget&gt;
 			&lt;packing&gt;
 			  &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
-			  &lt;property name=&quot;expand&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;expand&quot;&gt;False&lt;/property&gt;
 			  &lt;property name=&quot;fill&quot;&gt;True&lt;/property&gt;
 			&lt;/packing&gt;
 		      &lt;/child&gt;
@@ -444,7 +444,7 @@
 			&lt;/widget&gt;
 			&lt;packing&gt;
 			  &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
-			  &lt;property name=&quot;expand&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;expand&quot;&gt;False&lt;/property&gt;
 			  &lt;property name=&quot;fill&quot;&gt;True&lt;/property&gt;
 			&lt;/packing&gt;
 		      &lt;/child&gt;
@@ -455,7 +455,7 @@
 			&lt;/widget&gt;
 			&lt;packing&gt;
 			  &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
-			  &lt;property name=&quot;expand&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;expand&quot;&gt;False&lt;/property&gt;
 			  &lt;property name=&quot;fill&quot;&gt;True&lt;/property&gt;
 			&lt;/packing&gt;
 		      &lt;/child&gt;
@@ -507,7 +507,7 @@
 			&lt;/widget&gt;
 			&lt;packing&gt;
 			  &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
-			  &lt;property name=&quot;expand&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;expand&quot;&gt;False&lt;/property&gt;
 			  &lt;property name=&quot;fill&quot;&gt;True&lt;/property&gt;
 			&lt;/packing&gt;
 		      &lt;/child&gt;
@@ -582,7 +582,7 @@
 			&lt;/widget&gt;
 			&lt;packing&gt;
 			  &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
-			  &lt;property name=&quot;expand&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;expand&quot;&gt;False&lt;/property&gt;
 			  &lt;property name=&quot;fill&quot;&gt;True&lt;/property&gt;
 			&lt;/packing&gt;
 		      &lt;/child&gt;
@@ -640,7 +640,7 @@
 			&lt;/widget&gt;
 			&lt;packing&gt;
 			  &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
-			  &lt;property name=&quot;expand&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;expand&quot;&gt;False&lt;/property&gt;
 			  &lt;property name=&quot;fill&quot;&gt;True&lt;/property&gt;
 			&lt;/packing&gt;
 		      &lt;/child&gt;
@@ -698,14 +698,14 @@
 			&lt;/widget&gt;
 			&lt;packing&gt;
 			  &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
-			  &lt;property name=&quot;expand&quot;&gt;True&lt;/property&gt;
+			  &lt;property name=&quot;expand&quot;&gt;False&lt;/property&gt;
 			  &lt;property name=&quot;fill&quot;&gt;True&lt;/property&gt;
 			&lt;/packing&gt;
 		      &lt;/child&gt;
 		    &lt;/widget&gt;
 		    &lt;packing&gt;
 		      &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
-		      &lt;property name=&quot;expand&quot;&gt;True&lt;/property&gt;
+		      &lt;property name=&quot;expand&quot;&gt;False&lt;/property&gt;
 		      &lt;property name=&quot;fill&quot;&gt;True&lt;/property&gt;
 		    &lt;/packing&gt;
 		  &lt;/child&gt;
@@ -756,8 +756,8 @@
 
 				  &lt;child&gt;
 				    &lt;widget class=&quot;GtkComboBox&quot; id=&quot;previewOutputMenu&quot;&gt;
-				      &lt;property name=&quot;items&quot; translatable=&quot;yes&quot;&gt;Swiss Army Knife output
-Final output&lt;/property&gt;
+				      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+				      &lt;property name=&quot;items&quot; translatable=&quot;yes&quot;&gt;&lt;/property&gt;
 				      &lt;property name=&quot;add_tearoffs&quot;&gt;False&lt;/property&gt;
 				      &lt;property name=&quot;focus_on_click&quot;&gt;True&lt;/property&gt;
 				    &lt;/widget&gt;
@@ -795,7 +795,8 @@
 
 			      &lt;child&gt;
 				&lt;widget class=&quot;GtkDrawingArea&quot; id=&quot;previewVideo&quot;&gt;
-				  &lt;property name=&quot;height_request&quot;&gt;300&lt;/property&gt;
+				  &lt;property name=&quot;width_request&quot;&gt;30&lt;/property&gt;
+				  &lt;property name=&quot;height_request&quot;&gt;30&lt;/property&gt;
 				  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
 				  &lt;property name=&quot;events&quot;&gt;GDK_BUTTON1_MOTION_MASK | GDK_BUTTON_PRESS_MASK&lt;/property&gt;
 				&lt;/widget&gt;
@@ -805,16 +806,6 @@
 				  &lt;property name=&quot;fill&quot;&gt;True&lt;/property&gt;
 				&lt;/packing&gt;
 			      &lt;/child&gt;
-
-			      &lt;child&gt;
-				&lt;widget class=&quot;GtkDrawingArea&quot; id=&quot;previewDisabled&quot;&gt;
-				&lt;/widget&gt;
-				&lt;packing&gt;
-				  &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
-				  &lt;property name=&quot;expand&quot;&gt;True&lt;/property&gt;
-				  &lt;property name=&quot;fill&quot;&gt;True&lt;/property&gt;
-				&lt;/packing&gt;
-			      &lt;/child&gt;
 			    &lt;/widget&gt;
 			  &lt;/child&gt;
 			&lt;/widget&gt;

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/glade/swissarmyknife.glade
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/glade/swissarmyknife.glade	2008-02-03 09:40:17 UTC (rev 3787)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/glade/swissarmyknife.glade	2008-02-03 12:04:10 UTC (rev 3788)
@@ -868,6 +868,90 @@
 			  &lt;/child&gt;
 
 			  &lt;child&gt;
+			    &lt;widget class=&quot;GtkHBox&quot; id=&quot;rollingAvgLookaheadHbox&quot;&gt;
+			      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+			      &lt;property name=&quot;homogeneous&quot;&gt;False&lt;/property&gt;
+			      &lt;property name=&quot;spacing&quot;&gt;0&lt;/property&gt;
+
+			      &lt;child&gt;
+				&lt;widget class=&quot;GtkLabel&quot; id=&quot;rollingAvgLookaheadLabel1&quot;&gt;
+				  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+				  &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt;_Look ahead &lt;/property&gt;
+				  &lt;property name=&quot;use_underline&quot;&gt;True&lt;/property&gt;
+				  &lt;property name=&quot;use_markup&quot;&gt;False&lt;/property&gt;
+				  &lt;property name=&quot;justify&quot;&gt;GTK_JUSTIFY_RIGHT&lt;/property&gt;
+				  &lt;property name=&quot;wrap&quot;&gt;False&lt;/property&gt;
+				  &lt;property name=&quot;selectable&quot;&gt;False&lt;/property&gt;
+				  &lt;property name=&quot;xalign&quot;&gt;0.5&lt;/property&gt;
+				  &lt;property name=&quot;yalign&quot;&gt;0.5&lt;/property&gt;
+				  &lt;property name=&quot;xpad&quot;&gt;0&lt;/property&gt;
+				  &lt;property name=&quot;ypad&quot;&gt;0&lt;/property&gt;
+				  &lt;property name=&quot;mnemonic_widget&quot;&gt;rollingAvgLookaheadSpinButton&lt;/property&gt;
+				  &lt;property name=&quot;ellipsize&quot;&gt;PANGO_ELLIPSIZE_NONE&lt;/property&gt;
+				  &lt;property name=&quot;width_chars&quot;&gt;-1&lt;/property&gt;
+				  &lt;property name=&quot;single_line_mode&quot;&gt;False&lt;/property&gt;
+				  &lt;property name=&quot;angle&quot;&gt;0&lt;/property&gt;
+				&lt;/widget&gt;
+				&lt;packing&gt;
+				  &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
+				  &lt;property name=&quot;expand&quot;&gt;False&lt;/property&gt;
+				  &lt;property name=&quot;fill&quot;&gt;False&lt;/property&gt;
+				&lt;/packing&gt;
+			      &lt;/child&gt;
+
+			      &lt;child&gt;
+				&lt;widget class=&quot;GtkSpinButton&quot; id=&quot;rollingAvgLookaheadSpinButton&quot;&gt;
+				  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+				  &lt;property name=&quot;can_focus&quot;&gt;True&lt;/property&gt;
+				  &lt;property name=&quot;climb_rate&quot;&gt;1&lt;/property&gt;
+				  &lt;property name=&quot;digits&quot;&gt;0&lt;/property&gt;
+				  &lt;property name=&quot;numeric&quot;&gt;True&lt;/property&gt;
+				  &lt;property name=&quot;update_policy&quot;&gt;GTK_UPDATE_ALWAYS&lt;/property&gt;
+				  &lt;property name=&quot;snap_to_ticks&quot;&gt;False&lt;/property&gt;
+				  &lt;property name=&quot;wrap&quot;&gt;False&lt;/property&gt;
+				  &lt;property name=&quot;adjustment&quot;&gt;0 0 99999 1 1 0&lt;/property&gt;
+				&lt;/widget&gt;
+				&lt;packing&gt;
+				  &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
+				  &lt;property name=&quot;expand&quot;&gt;False&lt;/property&gt;
+				  &lt;property name=&quot;fill&quot;&gt;True&lt;/property&gt;
+				&lt;/packing&gt;
+			      &lt;/child&gt;
+
+			      &lt;child&gt;
+				&lt;widget class=&quot;GtkLabel&quot; id=&quot;rollingAvgLookaheadLabel2&quot;&gt;
+				  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+				  &lt;property name=&quot;label&quot; translatable=&quot;yes&quot;&gt; frames.  (Anything &gt; 0 will be slower.)&lt;/property&gt;
+				  &lt;property name=&quot;use_underline&quot;&gt;True&lt;/property&gt;
+				  &lt;property name=&quot;use_markup&quot;&gt;False&lt;/property&gt;
+				  &lt;property name=&quot;justify&quot;&gt;GTK_JUSTIFY_LEFT&lt;/property&gt;
+				  &lt;property name=&quot;wrap&quot;&gt;False&lt;/property&gt;
+				  &lt;property name=&quot;selectable&quot;&gt;False&lt;/property&gt;
+				  &lt;property name=&quot;xalign&quot;&gt;0.5&lt;/property&gt;
+				  &lt;property name=&quot;yalign&quot;&gt;0.5&lt;/property&gt;
+				  &lt;property name=&quot;xpad&quot;&gt;0&lt;/property&gt;
+				  &lt;property name=&quot;ypad&quot;&gt;0&lt;/property&gt;
+				  &lt;property name=&quot;mnemonic_widget&quot;&gt;rollingAvgLookaheadSpinButton&lt;/property&gt;
+				  &lt;property name=&quot;ellipsize&quot;&gt;PANGO_ELLIPSIZE_NONE&lt;/property&gt;
+				  &lt;property name=&quot;width_chars&quot;&gt;-1&lt;/property&gt;
+				  &lt;property name=&quot;single_line_mode&quot;&gt;False&lt;/property&gt;
+				  &lt;property name=&quot;angle&quot;&gt;0&lt;/property&gt;
+				&lt;/widget&gt;
+				&lt;packing&gt;
+				  &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
+				  &lt;property name=&quot;expand&quot;&gt;False&lt;/property&gt;
+				  &lt;property name=&quot;fill&quot;&gt;False&lt;/property&gt;
+				&lt;/packing&gt;
+			      &lt;/child&gt;
+			    &lt;/widget&gt;
+			    &lt;packing&gt;
+			      &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
+			      &lt;property name=&quot;expand&quot;&gt;True&lt;/property&gt;
+			      &lt;property name=&quot;fill&quot;&gt;True&lt;/property&gt;
+			    &lt;/packing&gt;
+			  &lt;/child&gt;
+
+			  &lt;child&gt;
 			    &lt;widget class=&quot;GtkVBox&quot; id=&quot;rollingAvgInitVbox&quot;&gt;
 			      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
 			      &lt;property name=&quot;homogeneous&quot;&gt;False&lt;/property&gt;
@@ -992,7 +1076,7 @@
 				      &lt;property name=&quot;update_policy&quot;&gt;GTK_UPDATE_ALWAYS&lt;/property&gt;
 				      &lt;property name=&quot;snap_to_ticks&quot;&gt;False&lt;/property&gt;
 				      &lt;property name=&quot;wrap&quot;&gt;False&lt;/property&gt;
-				      &lt;property name=&quot;adjustment&quot;&gt;1 1 99999 1 1 0&lt;/property&gt;
+				      &lt;property name=&quot;adjustment&quot;&gt;0 0 9999999 1 1 0&lt;/property&gt;
 				    &lt;/widget&gt;
 				    &lt;packing&gt;
 				      &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
@@ -1036,7 +1120,7 @@
 				      &lt;property name=&quot;update_policy&quot;&gt;GTK_UPDATE_ALWAYS&lt;/property&gt;
 				      &lt;property name=&quot;snap_to_ticks&quot;&gt;False&lt;/property&gt;
 				      &lt;property name=&quot;wrap&quot;&gt;False&lt;/property&gt;
-				      &lt;property name=&quot;adjustment&quot;&gt;100 1 99999 1 1 0&lt;/property&gt;
+				      &lt;property name=&quot;adjustment&quot;&gt;99 0 9999999 1 1 0&lt;/property&gt;
 				    &lt;/widget&gt;
 				    &lt;packing&gt;
 				      &lt;property name=&quot;padding&quot;&gt;0&lt;/property&gt;
@@ -1740,8 +1824,8 @@
 
 			      &lt;child&gt;
 				&lt;widget class=&quot;GtkComboBox&quot; id=&quot;previewOutputMenu&quot;&gt;
-				  &lt;property name=&quot;items&quot; translatable=&quot;yes&quot;&gt;Swiss Army Knife output
-Final output&lt;/property&gt;
+				  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
+				  &lt;property name=&quot;items&quot; translatable=&quot;yes&quot;&gt;&lt;/property&gt;
 				  &lt;property name=&quot;add_tearoffs&quot;&gt;False&lt;/property&gt;
 				  &lt;property name=&quot;focus_on_click&quot;&gt;True&lt;/property&gt;
 				&lt;/widget&gt;
@@ -1779,7 +1863,8 @@
 
 			  &lt;child&gt;
 			    &lt;widget class=&quot;GtkDrawingArea&quot; id=&quot;previewVideo&quot;&gt;
-			      &lt;property name=&quot;height_request&quot;&gt;300&lt;/property&gt;
+			      &lt;property name=&quot;width_request&quot;&gt;30&lt;/property&gt;
+			      &lt;property name=&quot;height_request&quot;&gt;30&lt;/property&gt;
 			      &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
 			      &lt;property name=&quot;events&quot;&gt;GDK_BUTTON1_MOTION_MASK | GDK_BUTTON_PRESS_MASK&lt;/property&gt;
 			    &lt;/widget&gt;

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/glade/threshold.glade
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/glade/threshold.glade	2008-02-03 09:40:17 UTC (rev 3787)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_GTK/glade/threshold.glade	2008-02-03 12:04:10 UTC (rev 3788)
@@ -416,8 +416,7 @@
 
 			  &lt;child&gt;
 			    &lt;widget class=&quot;GtkComboBox&quot; id=&quot;previewOutputMenu&quot;&gt;
-			      &lt;property name=&quot;items&quot; translatable=&quot;yes&quot;&gt;Threshold output
-Final output&lt;/property&gt;
+			      &lt;property name=&quot;items&quot; translatable=&quot;yes&quot;&gt;&lt;/property&gt;
 			      &lt;property name=&quot;add_tearoffs&quot;&gt;False&lt;/property&gt;
 			      &lt;property name=&quot;focus_on_click&quot;&gt;True&lt;/property&gt;
 			    &lt;/widget&gt;
@@ -455,7 +454,8 @@
 
 		      &lt;child&gt;
 			&lt;widget class=&quot;GtkDrawingArea&quot; id=&quot;previewVideo&quot;&gt;
-			  &lt;property name=&quot;height_request&quot;&gt;300&lt;/property&gt;
+			  &lt;property name=&quot;width_request&quot;&gt;30&lt;/property&gt;
+			  &lt;property name=&quot;height_request&quot;&gt;30&lt;/property&gt;
 			  &lt;property name=&quot;visible&quot;&gt;True&lt;/property&gt;
 			  &lt;property name=&quot;events&quot;&gt;GDK_BUTTON1_MOTION_MASK | GDK_BUTTON_PRESS_MASK&lt;/property&gt;
 			&lt;/widget&gt;

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_NONE/ADM_dialog/DIA_flyDialog.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_NONE/ADM_dialog/DIA_flyDialog.cpp	2008-02-03 09:40:17 UTC (rev 3787)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_NONE/ADM_dialog/DIA_flyDialog.cpp	2008-02-03 12:04:10 UTC (rev 3788)
@@ -42,6 +42,10 @@
 {
   return 1; 
 }
+uint8_t ADM_flyDialog::cleanup2(void)
+{
+  return 1; 
+}
 
 
 //EOF

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_NONE/ADM_dialog/DIA_none.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_NONE/ADM_dialog/DIA_none.cpp	2008-02-03 09:40:17 UTC (rev 3787)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_NONE/ADM_dialog/DIA_none.cpp	2008-02-03 12:04:10 UTC (rev 3788)
@@ -106,7 +106,9 @@
 int DIA_colorSel(uint8_t *r, uint8_t *g, uint8_t *b) {return 0;}			
 uint8_t DIA_glyphEdit(void) {return 0;}
 struct THRESHOLD_PARAM;
+struct ADMVideoThreshold;
 uint8_t DIA_threshold(AVDMGenericVideoStream *in,
+                      ADMVideoThreshold * thresholdp,
                       THRESHOLD_PARAM * param) { return 255; }
 struct SWISSARMYKNIFE_PARAM;
 struct ADMVideoSwissArmyKnife;
@@ -124,7 +126,9 @@
                     const MenuMapping * menu_mapping,
                     uint32_t menu_mapping_count) { return 255; }
 struct PARTICLE_PARAM;
+struct ADMVideoParticle;
 uint8_t DIA_particle (AVDMGenericVideoStream *in,
+                      ADMVideoParticle * particlep,
                       PARTICLE_PARAM * param,
                       const MenuMapping * menu_mapping,
                       uint32_t menu_mapping_count) { return 255; }

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/DIA_none.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/DIA_none.cpp	2008-02-03 09:40:17 UTC (rev 3787)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/DIA_none.cpp	2008-02-03 12:04:10 UTC (rev 3788)
@@ -55,7 +55,9 @@
 uint8_t DIA_glyphEdit(void){ return 0;};
 int32_t UI_readJog(void) {return 0;}
 struct THRESHOLD_PARAM;
+struct ADMVideoThreshold;
 uint8_t DIA_threshold(AVDMGenericVideoStream *in,
+                      ADMVideoThreshold * thresholdp,
                       THRESHOLD_PARAM * param) { return 255; }
 struct SWISSARMYKNIFE_PARAM;
 struct ADMVideoSwissArmyKnife;
@@ -73,7 +75,9 @@
                     const MenuMapping * menu_mapping,
                     uint32_t menu_mapping_count) { return 255; }
 struct PARTICLE_PARAM;
+struct ADMVideoParticle;
 uint8_t DIA_particle (AVDMGenericVideoStream *in,
+                      ADMVideoParticle * particlep,
                       PARTICLE_PARAM * param,
                       const MenuMapping * menu_mapping,
                       uint32_t menu_mapping_count) { return 255; }

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/T_flyDialog.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/T_flyDialog.cpp	2008-02-03 09:40:17 UTC (rev 3787)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/T_flyDialog.cpp	2008-02-03 12:04:10 UTC (rev 3788)
@@ -23,7 +23,7 @@
 #include &quot;DIA_flyDialog.h&quot;
 #include &quot;DIA_flyDialogQt4.h&quot;
 
-void ADM_flyDialog::postInit()
+void ADM_flyDialog::postInit(uint8_t reInit)
 {
 	QWidget *graphicsView = ((ADM_QCanvas*)_canvas)-&gt;parentWidget();
 	QSlider  *slider=(QSlider *)_slider;
@@ -66,5 +66,9 @@
 {
   return 1; 
 }
+uint8_t ADM_flyDialog::cleanup2(void)
+{
+  return 1; 
+}
 
 //EOF

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_flyDialog.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_flyDialog.cpp	2008-02-03 09:40:17 UTC (rev 3787)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_flyDialog.cpp	2008-02-03 12:04:10 UTC (rev 3788)
@@ -40,6 +40,7 @@
 	_canvas = canvas;
 	_cookie = NULL;
 	_resizeMethod = resizeMethod;
+        _zoomChangeCount = 0;
 
 	if (isRgbInverted())
 		_rgb=new ColYuvRgb(_w,_h,1);
@@ -65,16 +66,18 @@
 
 	if (_resizeMethod == RESIZE_AUTO || _resizeMethod == RESIZE_LAST)
 	{
-		float zoom = calcZoomFactor();
+		_zoom = calcZoomFactor();
 
-		if (zoom == 1)
+		if (_zoom == 1)
 			_resizeMethod = RESIZE_NONE;
 		else
 		{
-			_zoomW = uint32_t (_w * zoom);
-			_zoomH = uint32_t (_h * zoom);
+			_zoomW = uint32_t (_w * _zoom);
+			_zoomH = uint32_t (_h * _zoom);
 		}
 	}
+        else
+		_zoom = 1;
 
 	if (_resizeMethod == RESIZE_AUTO || _resizeMethod == RESIZE_LAST)
 	{
@@ -97,9 +100,74 @@
 		_rgbBufferDisplay = NULL;
 	}
 
-	postInit();
+	postInit (false);
 }
 
+void ADM_flyDialog::recomputeSize(void)
+{
+    float new_zoom = calcZoomFactor();
+
+    ResizeMethod new_resizeMethod;
+    uint32_t new_zoomW;
+    uint32_t new_zoomH;
+
+    if (new_zoom == 1)
+    {
+        new_resizeMethod = RESIZE_NONE;
+        new_zoomW = _w;
+        new_zoomH = _h;
+    }
+    else
+    {
+        new_resizeMethod = RESIZE_AUTO;
+        new_zoomW = uint32_t (_w * new_zoom);
+        new_zoomH = uint32_t (_h * new_zoom);
+    }
+
+    if (new_resizeMethod == _resizeMethod &amp;&amp; new_zoom == _zoom
+        &amp;&amp; new_zoomW == _zoomW &amp;&amp; new_zoomH == _zoomH)
+        return;
+
+    if (++_zoomChangeCount &gt; 3 || new_zoomH &lt; 30 || new_zoomW &lt; 30)
+    {
+        printf (&quot;Resisting zoom size change from %dx%d (zoom %.5f) to %dx%d (zoom %.5f)\n&quot;,
+                _zoomW, _zoomH, _zoom, new_zoomW, new_zoomH, new_zoom);
+        return;
+    }
+
+    printf (&quot;Fixing zoom size from %dx%d (zoom %.5f) to correct %dx%d (zoom %.5f)\n&quot;,
+            _zoomW, _zoomH, _zoom, new_zoomW, new_zoomH, new_zoom);
+
+    _resizeMethod = new_resizeMethod;
+    _zoom = new_zoom;
+    _zoomW = new_zoomW;
+    _zoomH = new_zoomH;
+
+    delete _resizer;
+    if (_resizeMethod == RESIZE_AUTO || _resizeMethod == RESIZE_LAST)
+    {
+        PixelFormat sourceColour;
+
+        if (_resizeMethod == RESIZE_AUTO || _isYuvProcessing)
+            sourceColour = PIX_FMT_YUV420P;
+        else
+            sourceColour = PIX_FMT_RGB32;
+
+        _resizer = new ADMImageResizer(_w, _h, _zoomW, _zoomH, sourceColour, PIX_FMT_RGB32);
+        if (!_rgbBufferDisplay)
+            _rgbBufferDisplay = new uint8_t[_w * _h * 4];
+    }
+    else
+    {
+        _resizer = NULL;
+        delete _rgbBufferDisplay;
+        _rgbBufferDisplay = NULL;
+    }
+
+    postInit (true);
+    sliderChanged();
+}
+
 /**
     \fn cleanup
     \brief deallocate
@@ -123,6 +191,7 @@
 */
 ADM_flyDialog::~ADM_flyDialog(void)
 {
+  cleanup2();
   cleanup(); 
 }
 
@@ -158,7 +227,7 @@
         process();
     }
 
-    display();
+    return display();
 }
 
 void ADM_flyDialog::copyYuvFinalToRgb(void)

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_flyDialog.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_flyDialog.h	2008-02-03 09:40:17 UTC (rev 3787)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_flyDialog.h	2008-02-03 12:04:10 UTC (rev 3788)
@@ -40,10 +40,14 @@
     const diaMenuEntry * menu;
 };
 
+typedef float gfloat;
+
 class ADM_flyDialog
 {
   protected:
           uint32_t _w,_h, _zoomW, _zoomH;
+          float _zoom;
+          uint32_t _zoomChangeCount;
           AVDMGenericVideoStream *_in;
   
           ADMImage *_yuvBuffer;
@@ -55,7 +59,7 @@
 		  ResizeMethod _resizeMethod;
 		  ADMImageResizer *_resizer;
 
-  virtual void postInit(void);
+  virtual void postInit(uint8_t reInit);
 		  float calcZoomFactor(void);
           void copyYuvFinalToRgb(void);
           void copyYuvScratchToRgb(void);
@@ -67,6 +71,7 @@
                               const MenuMapping * menu_mapping,
                               uint32_t menu_mapping_count);
   public:
+          void recomputeSize(void);
           uint32_t getMenuValue (const MenuMapping * mm);
           const MenuMapping * lookupMenu (const char * widgetName,
                                           const MenuMapping * menu_mapping,
@@ -76,6 +81,7 @@
           void    *_slider; // widget
           void    *_canvas; // Drawing zone
           ColYuvRgb *_rgb;
+
           /* Filter dependant */
   virtual uint8_t    process(void)=0;
   virtual uint8_t    download(void)=0;
@@ -91,11 +97,16 @@
           uint8_t  isRgbInverted(void);
   virtual uint8_t  update(void) {};
           uint8_t  cleanup(void);
+  virtual uint8_t  cleanup2(void);
 
+#ifdef USE_JOG
+  static void jogDial (void * my_data, signed short offset);
+  static void jogRing (void * my_data, gfloat angle);
+#endif
+
           ADM_flyDialog(uint32_t width, uint32_t height, AVDMGenericVideoStream *in,
                              void *canvas, void *slider, int yuv, ResizeMethod resizeMethod);
   virtual ~ADM_flyDialog(void);
-
 };
 
 #endif

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_flyEraser.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_flyEraser.cpp	2008-02-03 09:40:17 UTC (rev 3787)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_flyEraser.cpp	2008-02-03 12:04:10 UTC (rev 3788)
@@ -29,24 +29,98 @@
 
 uint8_t flyEraser::sliderChanged ()
 {
-    return ADM_flyDialog::sliderChanged();
+    ADM_assert(_yuvBuffer);
+    ADM_assert(_rgbBufferOut);
+    ADM_assert(_in);
+    
+    if (preview_mode == PREVIEWMODE_THIS_FILTER)
+    {
+        uint32_t frame = sliderGet();
+        uint32_t len, flags;
+
+        if (!_in-&gt;getFrameNumberNoAlloc (frame, &amp;len, _yuvBuffer, &amp;flags))
+        {
+            printf (&quot;[FlyDialog] Cannot get frame %u\n&quot;, frame);
+            return 0;
+        }
+    }
+    else if (preview_mode == PREVIEWMODE_LATER_FILTER)
+    {
+        // No need to call getFrameNumberNoAlloc() here, because our process()
+        // (see below) will do it (indirectly, by calling the later filter's
+        // getFrameNumberNoAlloc(), which will call the preceding filter's
+        // getFrameNumberNoAlloc(), which in turn will call it for the filter
+        // before that, etc.):
+    }
+    else // if (preview_mode == PREVIEWMODE_EARLIER_FILTER)
+    {
+        // In this case, we just call the earlier filter's
+        // getFrameNumberNoAlloc() and send the result straight into the
+        // output buffer - we needn't do anything to it ourselves.
+
+        uint32_t frame = sliderGet();
+        uint32_t len, flags;
+
+        if (!source-&gt;getFrameNumberNoAlloc (frame, &amp;len, _yuvBufferOut,
+                                            &amp;flags))
+        {
+            printf (&quot;[FlyDialog] Cannot get frame %u\n&quot;, frame);
+            return 0;
+        }
+    }
+
+    // Process...    
+    if (_isYuvProcessing)
+    {
+        process();
+        copyYuvFinalToRgb();
+    }
+    else // RGB Processing      
+    {
+        // HERE: we are NOT set up for this to work...
+        ADM_assert(0);
+        ADM_assert(_rgbBuffer);
+        copyYuvScratchToRgb();
+        process();
+    }
+
+    return display();
 }
 
 uint8_t  flyEraser::update ()
 {
     download();
+    pushParam();
     process();
     copyYuvFinalToRgb();
-    display();
-    return 1;
+    return display();
 }
 
 uint8_t flyEraser::process ()
 {
-    uint8_t ret = ADMVideoEraser::doEraser (_yuvBuffer, _yuvBufferOut,
-                                            _in, sliderGet(), eraserp,
-                                            &amp;param, _w, _h);
-    return ret;
+    if (preview_mode == PREVIEWMODE_THIS_FILTER)
+    {
+        uint8_t ret = ADMVideoEraser::doEraser (_yuvBuffer, _yuvBufferOut,
+                                                _in, sliderGet(), eraserp,
+                                                &amp;param, _w, _h);
+        return ret;
+    }
+    else if (preview_mode == PREVIEWMODE_LATER_FILTER)
+    {
+        uint32_t len = 0;
+        uint32_t flags = 0;
+        uint32_t frame = sliderGet();
+        return source-&gt;getFrameNumberNoAlloc (frame, &amp;len, _yuvBufferOut,
+                                              &amp;flags);
+    }
+    else // if (preview_mode == PREVIEWMODE_EARLIER_FILTER)
+    {
+        // nothing to do here - we've already arranged for the earlier filter
+        // to write the result into the output buffer, and changes in our
+        // parameters can't affect the result of an earlier filter.
+
+        return 1;
+    }
 }
 
 /************* COMMON PART *********************/

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_flyEraser.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_flyEraser.h	2008-02-03 09:40:17 UTC (rev 3787)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_flyEraser.h	2008-02-03 12:04:10 UTC (rev 3788)
@@ -27,25 +27,50 @@
   private:
     const MenuMapping * menu_mapping;
     uint32_t menu_mapping_count;
+    ERASER_PARAM saved_param;
+    ERASER_PARAM * live_param;
+    AVDMGenericVideoStream * source;
 
   public:
     ERASER_PARAM param;
     Eraser::MaskVec::iterator current_mask;
 
+    // HERE: A lot of this should probably be moved up into ADM_flyDialog
+
+    uint16_t this_filter_index;
+
+    enum PreviewMode
+    {
+        PREVIEWMODE_INVALID = 0, // never use
+        PREVIEWMODE_EARLIER_FILTER,
+        PREVIEWMODE_THIS_FILTER,
+        PREVIEWMODE_LATER_FILTER
+    };
+
+  private:
+    PreviewMode preview_mode;
+
+  public:
     uint8_t    process();
     uint8_t    update();
 
     flyEraser (uint32_t width, uint32_t height,
                AVDMGenericVideoStream * in,
                void * canvas, void * slider, void * dialog,
-               ADMVideoEraser * eraserp, const ERASER_PARAM * in_param,
+               ADMVideoEraser * eraserp,
+               ERASER_PARAM * in_param,
                const MenuMapping * menu_mapping, uint32_t menu_mapping_count)
         : ADM_flyDialog (width, height, in, canvas, slider, 1, RESIZE_AUTO),
           eraserp (eraserp),
-          param (*in_param),
           menu_mapping (menu_mapping),
           menu_mapping_count (menu_mapping_count),
-          current_mask (eraserp-&gt;getMasks().begin())
+          saved_param (*in_param),
+          live_param (in_param),
+          source (eraserp),
+          param (*in_param),
+          current_mask (eraserp-&gt;getMasks().begin()),
+          this_filter_index (0),
+          preview_mode (PREVIEWMODE_THIS_FILTER)
     {
         _cookie = dialog;
         setupMenus (in_param, menu_mapping, menu_mapping_count);
@@ -55,11 +80,36 @@
 
     uint8_t sliderChanged (void);
 
+    void pushParam ()
+    {
+        *live_param = param;
+        eraserp-&gt;masksIsValid (true);
+    }
+
+    // no longer used
     void getParam (ERASER_PARAM * outputParam)
     {
         *outputParam = param;
     }
 
+    void restoreParam ()
+    {
+        *live_param = saved_param;
+        eraserp-&gt;masksIsValid (false);
+    }
+
+    AVDMGenericVideoStream * getSource () const
+    {
+        return source;
+    }
+
+    void changeSource (AVDMGenericVideoStream * in, PreviewMode mode)
+    {
+        source = in;
+        preview_mode = mode;
+        sliderChanged();
+    }
+
     ADMImage * getInputImage ()
     {
         return _yuvBuffer;
@@ -81,6 +131,11 @@
         ADM_flyDialog::getMenuValues (&amp;param, menu_mapping,
                                       menu_mapping_count);
     }
+
+    float getZoom () const
+    {
+        return _zoom;
+    }
 };
 
 #endif

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_flyParticle.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_flyParticle.cpp	2008-02-03 09:40:17 UTC (rev 3787)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_flyParticle.cpp	2008-02-03 12:04:10 UTC (rev 3788)
@@ -27,33 +27,130 @@
 
 /************* COMMON PART *********************/
 
+uint8_t flyParticle::sliderChanged ()
+{
+    ADM_assert(_yuvBuffer);
+    ADM_assert(_rgbBufferOut);
+    ADM_assert(_in);
+    
+    if (preview_mode == PREVIEWMODE_THIS_FILTER)
+    {
+        uint32_t frame = sliderGet();
+        uint32_t len, flags;
+
+        if (!_in-&gt;getFrameNumberNoAlloc (frame, &amp;len, _yuvBuffer, &amp;flags))
+        {
+            printf (&quot;[FlyDialog] Cannot get frame %u\n&quot;, frame);
+            return 0;
+        }
+    }
+    else if (preview_mode == PREVIEWMODE_LATER_FILTER)
+    {
+        // No need to call getFrameNumberNoAlloc() here, because our process()
+        // (see below) will do it (indirectly, by calling the later filter's
+        // getFrameNumberNoAlloc(), which will call the preceding filter's
+        // getFrameNumberNoAlloc(), which in turn will call it for the filter
+        // before that, etc.):
+    }
+    else // if (preview_mode == PREVIEWMODE_EARLIER_FILTER)
+    {
+#if 0
+// in this filter, process() has to always reprocess (because we draw the crop
+// lines onto the output buffer), so no point in doing it here...
+
+       // In this case, we just call the earlier filter's
+        // getFrameNumberNoAlloc() and send the result straight into the
+        // output buffer - we needn't do anything to it ourselves.
+
+        uint32_t frame = sliderGet();
+        uint32_t len, flags;
+
+        if (!source-&gt;getFrameNumberNoAlloc (frame, &amp;len, _yuvBufferOut,
+                                            &amp;flags))
+        {
+            printf (&quot;[FlyDialog] Cannot get frame %u\n&quot;, frame);
+            return 0;
+        }
+#endif
+    }
+
+    // Process...    
+    if (_isYuvProcessing)
+    {
+        process();
+        copyYuvFinalToRgb();
+    }
+    else // RGB Processing      
+    {
+        // HERE: we are NOT set up for this to work...
+        ADM_assert(0);
+        ADM_assert(_rgbBuffer);
+        copyYuvScratchToRgb();
+        process();
+    }
+
+    return display();
+}
+
 uint8_t flyParticle::update ()
 {
     download();
+    pushParam();
     process();
     copyYuvFinalToRgb();
-    display();
-    return 1;
+    return display();
 }
 
 static inline void draw_hline (uint8_t * fb, uint32_t width, uint32_t height,
                                uint32_t y)
 {
     for (uint8_t * pixp = fb + width * y; width--; pixp++)
-        *pixp ^= 0xff;
+        *pixp = ~*pixp;
 }
 
 static inline void draw_vline (uint8_t * fb, uint32_t width, uint32_t height,
                                uint32_t x)
 {
     for (uint8_t * pixp = fb + x; height--; pixp += width)
-        *pixp ^= 0xff;
+        *pixp = ~*pixp;
 }
 
 uint8_t flyParticle::process ()
 {
-    uint8_t ret = ADMVideoParticle::doParticle (_yuvBuffer, _yuvBufferOut,
-                                                _in, 0, 0, &amp;param, _w, _h);
+    uint8_t ret;
+    if (preview_mode == PREVIEWMODE_THIS_FILTER)
+    {
+        ret = ADMVideoParticle::doParticle (_yuvBuffer, _yuvBufferOut,
+                                            _in, 0, 0, &amp;param, _w, _h);
+    }
+    else if (preview_mode == PREVIEWMODE_LATER_FILTER)
+    {
+        uint32_t len = 0;
+        uint32_t flags = 0;
+        uint32_t frame = sliderGet();
+        ret = source-&gt;getFrameNumberNoAlloc (frame, &amp;len, _yuvBufferOut,
+                                             &amp;flags);
+    }
+    else // if (preview_mode == PREVIEWMODE_EARLIER_FILTER)
+    {
+#if 0
+// in this filter, process() has to always reprocess (because we draw the crop
+// lines onto the output buffer)...
+
+        // nothing to do here - we've already arranged for the earlier filter
+        // to write the result into the output buffer, and changes in our
+        // parameters can't affect the result of an earlier filter.
+
+        ret = 1;
+#else
+        uint32_t len = 0;
+        uint32_t flags = 0;
+        uint32_t frame = sliderGet();
+        ret = source-&gt;getFrameNumberNoAlloc (frame, &amp;len, _yuvBufferOut,
+                                             &amp;flags);
+#endif
+    }
+
     input_buffer_valid = false;
 
     uint8_t * fb = YPLANE(_yuvBufferOut);

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_flyParticle.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_flyParticle.h	2008-02-03 09:40:17 UTC (rev 3787)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_flyParticle.h	2008-02-03 12:04:10 UTC (rev 3788)
@@ -25,10 +25,29 @@
     const MenuMapping * menu_mapping;
     uint32_t menu_mapping_count;
     bool input_buffer_valid;
+    PARTICLE_PARAM saved_param;
+    PARTICLE_PARAM * live_param;
+    AVDMGenericVideoStream * source;
 
   public:
     PARTICLE_PARAM param;
 
+    uint16_t this_filter_index;
+
+    // HERE: This should probably be moved up into ADM_flyDialog:
+
+    enum PreviewMode
+    {
+        PREVIEWMODE_INVALID = 0, // never use
+        PREVIEWMODE_EARLIER_FILTER,
+        PREVIEWMODE_THIS_FILTER,
+        PREVIEWMODE_LATER_FILTER
+    };
+
+  private:
+    PreviewMode preview_mode;
+
+  public:
     uint8_t    process(void);
     uint8_t    download(void);
     uint8_t    upload(void);
@@ -37,24 +56,55 @@
     flyParticle (uint32_t width, uint32_t height,
                  AVDMGenericVideoStream * in,
                  void * canvas, void * slider, void * dialog,
-                 const PARTICLE_PARAM * in_param,
+                 ADMVideoParticle * particlep,
+                 PARTICLE_PARAM * in_param,
                  const MenuMapping * menu_mapping,
                  uint32_t menu_mapping_count)
         : ADM_flyDialog (width, height, in, canvas, slider, 1, RESIZE_AUTO),
           menu_mapping (menu_mapping),
           menu_mapping_count (menu_mapping_count),
           input_buffer_valid (false),
-          param (*in_param)
+          saved_param (*in_param),
+          live_param (in_param),
+          source (particlep),
+          param (*in_param),
+          this_filter_index (0),
+          preview_mode (PREVIEWMODE_THIS_FILTER)
     {
         _cookie = dialog;
         setupMenus (in_param, menu_mapping, menu_mapping_count);
     };
 
+    uint8_t sliderChanged (void);
+
+    void pushParam ()
+    {
+        *live_param = param;
+    }
+
+    // no longer used
     void getParam (PARTICLE_PARAM * outputParam)
     {
         *outputParam = param;
     }
 
+    void restoreParam ()
+    {
+        *live_param = saved_param;
+    }
+
+    AVDMGenericVideoStream * getSource () const
+    {
+        return source;
+    }
+
+    void changeSource (AVDMGenericVideoStream * in, PreviewMode mode)
+    {
+        source = in;
+        preview_mode = mode;
+        sliderChanged();
+    }
+
     ADMImage * getInputImage ()
     {
         if (!input_buffer_valid)
@@ -90,6 +140,11 @@
         ADM_flyDialog::getMenuValues (&amp;param, menu_mapping,
                                       menu_mapping_count);
     }
+
+    float getZoom () const
+    {
+        return _zoom;
+    }
 };
 
 #endif

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_flySwissArmyKnife.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_flySwissArmyKnife.cpp	2008-02-03 09:40:17 UTC (rev 3787)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_flySwissArmyKnife.cpp	2008-02-03 12:04:10 UTC (rev 3788)
@@ -29,10 +29,69 @@
 
 uint8_t flySwissArmyKnife::sliderChanged ()
 {
+    // HERE: perhaps we should replace the preview enable button with an
+    // additional selection on the preview filter selection list (&quot;Disable&quot; or
+    // some such), with a corresponding PREVIEWMODE_NO_PREVIEW.
+
     if (!param.enable_preview)
         return 0;
 
-    return ADM_flyDialog::sliderChanged();
+    ADM_assert(_yuvBuffer);
+    ADM_assert(_rgbBufferOut);
+    ADM_assert(_in);
+    
+    if (preview_mode == PREVIEWMODE_THIS_FILTER)
+    {
+        uint32_t frame = sliderGet();
+        uint32_t len, flags;
+
+        if (!_in-&gt;getFrameNumberNoAlloc (frame, &amp;len, _yuvBuffer, &amp;flags))
+        {
+            printf (&quot;[FlyDialog] Cannot get frame %u\n&quot;, frame);
+            return 0;
+        }
+    }
+    else if (preview_mode == PREVIEWMODE_LATER_FILTER)
+    {
+        // No need to call getFrameNumberNoAlloc() here, because our process()
+        // (see below) will do it (indirectly, by calling the later filter's
+        // getFrameNumberNoAlloc(), which will call the preceding filter's
+        // getFrameNumberNoAlloc(), which in turn will call it for the filter
+        // before that, etc.):
+    }
+    else // if (preview_mode == PREVIEWMODE_EARLIER_FILTER)
+    {
+        // In this case, we just call the earlier filter's
+        // getFrameNumberNoAlloc() and send the result straight into the
+        // output buffer - we needn't do anything to it ourselves.
+
+        uint32_t frame = sliderGet();
+        uint32_t len, flags;
+
+        if (!source-&gt;getFrameNumberNoAlloc (frame, &amp;len, _yuvBufferOut,
+                                            &amp;flags))
+        {
+            printf (&quot;[FlyDialog] Cannot get frame %u\n&quot;, frame);
+            return 0;
+        }
+    }
+
+    // Process...    
+    if (_isYuvProcessing)
+    {
+        process();
+        copyYuvFinalToRgb();
+    }
+    else // RGB Processing      
+    {
+        // HERE: we are NOT set up for this to work...
+        ADM_assert(0);
+        ADM_assert(_rgbBuffer);
+        copyYuvScratchToRgb();
+        process();
+    }
+
+    return display();
 }
 
 uint8_t  flySwissArmyKnife::update ()
@@ -41,10 +100,10 @@
     if (!param.enable_preview)
         return 0;
 
+    pushParam();
     process();
     copyYuvFinalToRgb();
-    display();
-    return 1;
+    return display();
 }
 
 uint8_t flySwissArmyKnife::process ()
@@ -52,10 +111,53 @@
     if (!param.enable_preview)
         return 0;
 
-    uint8_t ret =
-        ADMVideoSwissArmyKnife::doSwissArmyKnife (_yuvBuffer, _yuvBufferOut,
-                                                  _in, sakp, &amp;param, _w, _h);
-    return ret;
+    if (preview_mode == PREVIEWMODE_THIS_FILTER)
+    {
+        ADMImage * lai;
+        if (param.lookahead_n_frames)
+        {
+            if (lookaheadimage == NULL)
+                lookaheadimage = new ADMImage (_in-&gt;getInfo()-&gt;width,
+                                               _in-&gt;getInfo()-&gt;height);
+
+            uint32_t len = 0;
+            uint32_t flags = 0;
+            uint32_t frame = sliderGet();
+            if (frame + param.lookahead_n_frames &gt;= _in-&gt;getInfo()-&gt;nb_frames)
+                lai = 0;
+            else if (!_in-&gt;getFrameNumberNoAlloc (frame
+                                                  + param.lookahead_n_frames,
+                                                  &amp;len, lookaheadimage,
+                                                  &amp;flags))
+                return 0;
+            else
+                lai = lookaheadimage;
+        }
+        else
+            lai = 0;
+
+        uint8_t ret =
+            ADMVideoSwissArmyKnife::doSwissArmyKnife (_yuvBuffer, lai,
+                                                      _yuvBufferOut, _in,
+                                                      sakp, &amp;param, _w, _h);
+        return ret;
+    }
+    else if (preview_mode == PREVIEWMODE_LATER_FILTER)
+    {
+        uint32_t len = 0;
+        uint32_t flags = 0;
+        uint32_t frame = sliderGet();
+        return source-&gt;getFrameNumberNoAlloc (frame, &amp;len, _yuvBufferOut,
+                                              &amp;flags);
+    }
+    else // if (preview_mode == PREVIEWMODE_EARLIER_FILTER)
+    {
+        // nothing to do here - we've already arranged for the earlier filter
+        // to write the result into the output buffer, and changes in our
+        // parameters can't affect the result of an earlier filter.
+
+        return 1;
+    }
 }
 
 /************* COMMON PART *********************/

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_flySwissArmyKnife.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_flySwissArmyKnife.h	2008-02-03 09:40:17 UTC (rev 3787)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_flySwissArmyKnife.h	2008-02-03 12:04:10 UTC (rev 3788)
@@ -25,10 +25,30 @@
     ADMVideoSwissArmyKnife * sakp;
     const MenuMapping * menu_mapping;
     uint32_t menu_mapping_count;
+    ADMImage * lookaheadimage;
+    SWISSARMYKNIFE_PARAM saved_param;
+    SWISSARMYKNIFE_PARAM * live_param;
+    AVDMGenericVideoStream * source;
 
   public:
     SWISSARMYKNIFE_PARAM param;
 
+    // HERE: A lot of this should probably be moved up into ADM_flyDialog
+
+    uint16_t this_filter_index;
+
+    enum PreviewMode
+    {
+        PREVIEWMODE_INVALID = 0, // never use
+        PREVIEWMODE_EARLIER_FILTER,
+        PREVIEWMODE_THIS_FILTER,
+        PREVIEWMODE_LATER_FILTER
+    };
+
+  private:
+    PreviewMode preview_mode;
+
+  public:
     uint8_t    process(void);
     uint8_t    download(void);
     uint8_t    upload(void);
@@ -38,14 +58,20 @@
                        AVDMGenericVideoStream * in,
                        void * canvas, void * slider, void * dialog,
                        ADMVideoSwissArmyKnife * sakp,
-                       const SWISSARMYKNIFE_PARAM * in_param,
+                       SWISSARMYKNIFE_PARAM * in_param,
                        const MenuMapping * menu_mapping,
                        uint32_t menu_mapping_count)
         : ADM_flyDialog (width, height, in, canvas, slider, 1, RESIZE_AUTO),
           sakp (sakp),
+          menu_mapping (menu_mapping),
+          menu_mapping_count (menu_mapping_count),
+          lookaheadimage (NULL),
+          saved_param (*in_param),
+          live_param (in_param),
+          source (sakp),
           param (*in_param),
-          menu_mapping (menu_mapping),
-          menu_mapping_count (menu_mapping_count)
+          this_filter_index (0),
+          preview_mode (PREVIEWMODE_THIS_FILTER)
     {
         _cookie = dialog;
         setupMenus (in_param, menu_mapping, menu_mapping_count);
@@ -53,13 +79,41 @@
         //         &quot;in_param %p, &amp;param %p\n&quot;, in_param, &amp;param);
     };
 
+    ~flySwissArmyKnife ()
+    {
+        delete lookaheadimage;
+    }
+
     uint8_t sliderChanged (void);
 
+    void pushParam ()
+    {
+        *live_param = param;
+    }
+
+    // no longer used
     void getParam (SWISSARMYKNIFE_PARAM * outputParam)
     {
         *outputParam = param;
     }
 
+    void restoreParam ()
+    {
+        *live_param = saved_param;
+    }
+
+    AVDMGenericVideoStream * getSource () const
+    {
+        return source;
+    }
+
+    void changeSource (AVDMGenericVideoStream * in, PreviewMode mode)
+    {
+        source = in;
+        preview_mode = mode;
+        sliderChanged();
+    }
+
     ADMImage * getInputImage ()
     {
         return _yuvBuffer;
@@ -82,6 +136,11 @@
                                       menu_mapping_count);
     }
 
+    float getZoom () const
+    {
+        return _zoom;
+    }
+
     void updateConfigDescription (bool do_download);
     void wipeOutputBuffer ();
 };

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_flyThreshold.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_flyThreshold.cpp	2008-02-03 09:40:17 UTC (rev 3787)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_flyThreshold.cpp	2008-02-03 12:04:10 UTC (rev 3788)
@@ -30,24 +30,105 @@
 
 /************* COMMON PART *********************/
 
+uint8_t flyThreshold::sliderChanged ()
+{
+    ADM_assert(_yuvBuffer);
+    ADM_assert(_rgbBufferOut);
+    ADM_assert(_in);
+    
+    if (preview_mode == PREVIEWMODE_THIS_FILTER)
+    {
+        uint32_t frame = sliderGet();
+        uint32_t len, flags;
+
+        if (!_in-&gt;getFrameNumberNoAlloc (frame, &amp;len, _yuvBuffer, &amp;flags))
+        {
+            printf (&quot;[FlyDialog] Cannot get frame %u\n&quot;, frame);
+            return 0;
+        }
+    }
+    else if (preview_mode == PREVIEWMODE_LATER_FILTER)
+    {
+        // No need to call getFrameNumberNoAlloc() here, because our process()
+        // (see below) will do it (indirectly, by calling the later filter's
+        // getFrameNumberNoAlloc(), which will call the preceding filter's
+        // getFrameNumberNoAlloc(), which in turn will call it for the filter
+        // before that, etc.):
+    }
+    else // if (preview_mode == PREVIEWMODE_EARLIER_FILTER)
+    {
+        // In this case, we just call the earlier filter's
+        // getFrameNumberNoAlloc() and send the result straight into the
+        // output buffer - we needn't do anything to it ourselves.
+
+        uint32_t frame = sliderGet();
+        uint32_t len, flags;
+
+        if (!source-&gt;getFrameNumberNoAlloc (frame, &amp;len, _yuvBufferOut,
+                                            &amp;flags))
+        {
+            printf (&quot;[FlyDialog] Cannot get frame %u\n&quot;, frame);
+            return 0;
+        }
+    }
+
+    // Process...    
+    if (_isYuvProcessing)
+    {
+        process();
+        copyYuvFinalToRgb();
+    }
+    else // RGB Processing      
+    {
+        // HERE: we are NOT set up for this to work...
+        ADM_assert(0);
+        ADM_assert(_rgbBuffer);
+        copyYuvScratchToRgb();
+        process();
+    }
+
+    return display();
+}
+
 uint8_t  flyThreshold::update ()
 {
     download();
+    pushParam();
     process();
     copyYuvFinalToRgb();
-    display();
-    return 1;
+    return display();
 }
 
 uint8_t flyThreshold::process ()
 {
-    uint8_t lookup_table [256];
-    if (ADMVideoThreshold::computeLookupTable (&amp;param, lookup_table))
-        upload();
+    if (preview_mode == PREVIEWMODE_THIS_FILTER)
+    {
+        if (thresholdp-&gt;computeLookupTable (&amp;param))
+            upload();
 
-    ADMVideoThreshold::doThreshold (_yuvBuffer, _yuvBufferOut,
-                                    lookup_table, (_h * _w * 3) &gt;&gt; 1);
-    return 1;
+        ADMVideoThreshold::doThreshold (_yuvBuffer, _yuvBufferOut, thresholdp,
+                                        (_h * _w * 3) &gt;&gt; 1);
+        return 1;
+    }
+    else if (preview_mode == PREVIEWMODE_LATER_FILTER)
+    {
+        if (thresholdp-&gt;computeLookupTable (&amp;param))
+            upload();
+
+        uint32_t len = 0;
+        uint32_t flags = 0;
+        uint32_t frame = sliderGet();
+        return source-&gt;getFrameNumberNoAlloc (frame, &amp;len, _yuvBufferOut,
+                                              &amp;flags);
+    }
+    else // if (preview_mode == PREVIEWMODE_EARLIER_FILTER)
+    {
+        // nothing to do here - we've already arranged for the earlier filter
+        // to write the result into the output buffer, and changes in our
+        // parameters can't affect the result of an earlier filter.
+
+        return 1;
+    }
 }
 
 /************* COMMON PART *********************/

Modified: branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_flyThreshold.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_flyThreshold.h	2008-02-03 09:40:17 UTC (rev 3787)
+++ branches/avidemux_2.4_branch/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_flyThreshold.h	2008-02-03 12:04:10 UTC (rev 3788)
@@ -22,9 +22,30 @@
 {
   
   private:
+    ADMVideoThreshold * thresholdp;
+    THRESHOLD_PARAM saved_param;
+    THRESHOLD_PARAM * live_param;
+    AVDMGenericVideoStream * source;
     THRESHOLD_PARAM param;
 
   public:
+
+    // HERE: A lot of this should probably be moved up into ADM_flyDialog
+
+    uint16_t this_filter_index;
+
+    enum PreviewMode
+    {
+        PREVIEWMODE_INVALID = 0, // never use
+        PREVIEWMODE_EARLIER_FILTER,
+        PREVIEWMODE_THIS_FILTER,
+        PREVIEWMODE_LATER_FILTER
+    };
+
+  private:
+    PreviewMode preview_mode;
+
+  public:
     uint8_t    process(void);
     uint8_t    download(void);
     uint8_t    upload(void);
@@ -33,17 +54,49 @@
     flyThreshold (uint32_t width, uint32_t height,
                   AVDMGenericVideoStream * in,
                   void * canvas, void * slider,
-                  const THRESHOLD_PARAM * in_param)
+                  ADMVideoThreshold * thresholdp,
+                  THRESHOLD_PARAM * in_param)
         : ADM_flyDialog (width, height, in, canvas, slider, 1, RESIZE_AUTO),
-          param (*in_param)
+          thresholdp (thresholdp),
+          saved_param (*in_param),
+          live_param (in_param),
+          source (thresholdp),
+          param (*in_param),
+          this_filter_index (0),
+          preview_mode (PREVIEWMODE_THIS_FILTER)
     {
     };
 
+    uint8_t sliderChanged (void);
+
+    void pushParam ()
+    {
+        *live_param = param;
+    }
+
+    // no longer used
     void getParam (THRESHOLD_PARAM * outputParam)
     {
         *outputParam = param;
     }
 
+    void restoreParam ()
+    {
+        *live_param = saved_param;
+    }
+
+    AVDMGenericVideoStream * getSource () const
+    {
+        return source;
+    }
+
+    void changeSource (AVDMGenericVideoStream * in, PreviewMode mode)
+    {
+        source = in;
+        preview_mode = mode;
+        sliderChanged();
+    }
+
     ADMImage * getInputImage ()
     {
         return _yuvBuffer;
@@ -53,6 +106,11 @@
     {
         return _yuvBufferOut;
     }
+
+    float getZoom () const
+    {
+        return _zoom;
+    }
 };
 
 #endif

Modified: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidComputeAverage.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidComputeAverage.cpp	2008-02-03 09:40:17 UTC (rev 3787)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidComputeAverage.cpp	2008-02-03 12:04:10 UTC (rev 3788)
@@ -78,7 +78,7 @@
     }
     else
     {
-        _param-&gt;start_frame = 1;
+        _param-&gt;start_frame = 0;
         _param-&gt;end_frame = -1;
         _param-&gt;output_file = ADM_strdup (&quot;&quot;);
         _param-&gt;bias = 128;
@@ -296,12 +296,10 @@
         return 0;
     ADMImage * image = _uncompressed;
 
-    uint32_t start_frame = _param-&gt;start_frame - 1;
+    uint32_t start_frame = _param-&gt;start_frame;
     uint32_t end_frame = _param-&gt;end_frame;
     if (int32_t (end_frame) &lt; 0)
         end_frame = int32_t (num_frames) + int32_t (end_frame); // 0-based, thus -1 = last frame
-    else
-        --end_frame;
 
     if (!myInfo-&gt;sums
         || myInfo-&gt;width != _info.width || myInfo-&gt;height != _info.height
@@ -356,7 +354,7 @@
         uint32_t half_frame_count = frame_count / 2;
         if (debug &amp; 2)
             printf (&quot;Including frame %u of %u, now have %u (%u - %u)\n&quot;,
-                    curr_frame + 1, num_frames, frame_count, start_frame, end_frame);
+                    curr_frame, num_frames, frame_count, start_frame, end_frame);
 
         if (_param-&gt;display_mode == DISPLAYMODE_AVERAGE)
         {
@@ -403,7 +401,7 @@
         uint32_t half_frame_count = frame_count / 2;
         if (debug &amp; 2)
             printf (&quot;Using %u frame(s) (%u - %u) worth of average on frame %u of %u\n&quot;,
-                    frame_count, start_frame, end_frame, curr_frame + 1, num_frames);
+                    frame_count, start_frame, end_frame, curr_frame, num_frames);
 
         if (frame_count == 0)
         {

Modified: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidEraser.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidEraser.cpp	2008-02-03 09:40:17 UTC (rev 3787)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidEraser.cpp	2008-02-03 12:04:10 UTC (rev 3788)
@@ -371,11 +371,16 @@
 //    uint32_t &amp; mask_w = myInfo-&gt;mask_w;
 //    uint32_t &amp; mask_h = myInfo-&gt;mask_h;
 
-    masks.clear();
+    const char * filename = _param-&gt;data_file.c_str();
+    if (filename[0] == '\0')
+    {
+        fprintf (stderr, &quot;Eraser: no input file selected!\n&quot;);
+        return 0;
+    }
+
 //    mask_w = 0;
 //    mask_h = 0;
 
-    const char * filename = _param-&gt;data_file.c_str();
     ifstream inputStream (filename);
     if (!inputStream)
     {
@@ -385,6 +390,7 @@
         return 0;
     }
 
+    masks.clear();
     string buffer;
 
     while (inputStream)

Modified: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidEraser.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidEraser.h	2008-02-03 09:40:17 UTC (rev 3787)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidEraser.h	2008-02-03 12:04:10 UTC (rev 3788)
@@ -175,6 +175,11 @@
         return myInfo-&gt;masks;
     }
 
+    void masksIsValid (bool valid)
+    {
+        myInfo-&gt;mask_data_invalid = !valid;
+    }
+
 protected:
 
     uint8_t readDataFile (uint32_t width);

Modified: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidParticle.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidParticle.cpp	2008-02-03 09:40:17 UTC (rev 3787)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidParticle.cpp	2008-02-03 12:04:10 UTC (rev 3788)
@@ -128,7 +128,7 @@
 
 }
 
-uint8_t ADMVideoParticle::configure(AVDMGenericVideoStream *in)
+uint8_t ADMVideoParticle::configure (AVDMGenericVideoStream *in)
 {
     diaMenuEntry tOutputFmt [] = {
         { OUTPUTFMT_FORMAT_NEW,
@@ -150,7 +150,7 @@
           sizeof (tOutputFmt) / sizeof (diaMenuEntry), tOutputFmt },
     };
 
-    uint8_t ret = DIA_particle (_in, _param, menu_mapping,
+    uint8_t ret = DIA_particle (_in, this, _param, menu_mapping,
                                 sizeof (menu_mapping) / sizeof (MenuMapping));
     if (ret == 1)
     {
@@ -399,7 +399,7 @@
                 if (debug &amp; (0x02 &lt;&lt; ImageTool::SHIFT_PAST_SHOW_FLAGS))
                     printf (&quot;frame %d, particle %d (%d total), &quot;
                             &quot;%d pixels centered at (%.6f,%.6f)\n&quot;,
-                            real_frame + 1, frameParticleNum,
+                            real_frame, frameParticleNum,
                             totalParticleNum, area, centroid_x, centroid_y);
 
                 if (!do_outfp)
@@ -437,7 +437,7 @@
                                  &quot;%.5f %.5f %.5f  &quot; // minang,maxang,max/min
                                  &quot;%.5f %.5f &quot; // len, len_angle
                                  &quot;%.5f %.5f %.5f\n&quot;, // wid, wid_ang, len/wid
-                                 real_frame + 1, camera_number,
+                                 real_frame, camera_number,
                                  centroid_x, centroid_y,
                                  area, totalParticleNum,
                                  particle.maxx - particle.minx + 1,
@@ -452,7 +452,7 @@
 #ifdef OLD_PARTICLE_WEDGE_SCHEME
                         fprintf (do_outfp,
                                  &quot;%d,%d,%d,%.6f,%.6f,%d,%d,%.5f,%.5f,%.5f\n&quot;,
-                                 real_frame + 1, frameParticleNum, area,
+                                 real_frame, frameParticleNum, area,
                                  centroid_x, centroid_y, mindim, maxdim,
                                  mindimangle, maxdimangle, minmaxratio);
 #else // ! OLD_PARTICLE_WEDGE_SCHEME
@@ -462,7 +462,7 @@
                                  &quot;%.5f,%.5f, %.5f,  &quot; // minang,maxang,max/min
                                  &quot;%.5f,%.5f, &quot; // len, len_angle
                                  &quot;%.5f,%.5f, %.5f\n&quot;, // wid, wid_ang, len/wid
-                                 real_frame + 1, frameParticleNum, area,
+                                 real_frame, frameParticleNum, area,
                                  centroid_x, centroid_y, mindist, maxdist,
                                  mindistangle, maxdistangle, maxminratio,
                                  bf.length, bf.length_angle,
@@ -479,7 +479,7 @@
                     if (outfmt == OUTPUTFMT_FORMAT_NEW)
                     {
                         fprintf (do_outfp, &quot;%d %d %.6f %.6f %d %d\n&quot;,
-                                 real_frame + 1, camera_number,
+                                 real_frame, camera_number,
                                  centroid_x, centroid_y,
                                  area, totalParticleNum);
                     }
@@ -487,7 +487,7 @@
                     {
                         fprintf (do_outfp, &quot;%d %d %.6f %.6f %d\n&quot;,
                                  totalParticleNum, area,
-                                 centroid_x, centroid_y, real_frame + 1);
+                                 centroid_x, centroid_y, real_frame);
                     }
                 }
             }

Modified: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidParticle.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidParticle.h	2008-02-03 09:40:17 UTC (rev 3787)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidParticle.h	2008-02-03 12:04:10 UTC (rev 3788)
@@ -87,7 +87,8 @@
      static uint8_t doParticle (ADMImage * image, ADMImage * data,
                                 AVDMGenericVideoStream * in,
                                 uint32_t real_frame,
-                                FILE * do_outfp, PARTICLE_PARAM * param,
+                                FILE * do_outfp,
+                                PARTICLE_PARAM * param,
                                 uint32_t width, uint32_t height);
 };
 
@@ -843,6 +844,7 @@
 
 struct MenuMapping;
 uint8_t DIA_particle (AVDMGenericVideoStream *in,
+                      ADMVideoParticle * particlep,
                       PARTICLE_PARAM * param,
                       const MenuMapping * menu_mapping,
                       uint32_t menu_mapping_count);

Modified: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidSwissArmyKnife.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidSwissArmyKnife.cpp	2008-02-03 09:40:17 UTC (rev 3787)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidSwissArmyKnife.cpp	2008-02-03 12:04:10 UTC (rev 3788)
@@ -52,12 +52,12 @@
 
 static FILTER_PARAM swissArmyKnifeParam =
 {
-    15,
+    16,
     { &quot;tool&quot;, &quot;input_type&quot;, &quot;input_file&quot;, &quot;load_bias&quot;,              // 4
       &quot;load_multiplier&quot;, &quot;input_constant&quot;, &quot;memory_constant_alpha&quot;, // + 3 = 7
-      &quot;init_start_frame&quot;, &quot;init_end_frame&quot;, &quot;init_by_rolling&quot;,      // + 3 = 10
-      &quot;bias&quot;, &quot;result_bias&quot;, &quot;result_multiplier&quot;,                   // + 3 = 13
-      &quot;histogram_frame_interval&quot;, &quot;debug&quot;                           // + 2 = 15
+      &quot;lookahead_n_frames&quot;, &quot;init_start_frame&quot;, &quot;init_end_frame&quot;,   // + 3 = 10
+      &quot;init_by_rolling&quot;, &quot;bias&quot;, &quot;result_bias&quot;,                     // + 3 = 13
+      &quot;result_multiplier&quot;, &quot;histogram_frame_interval&quot;, &quot;debug&quot;      // + 3 = 16
     }
 };
 
@@ -107,7 +107,7 @@
         GET(tool);
         GET(input_type);
 
-		char* tmp;
+        char* tmp;
         GET2(input_file, tmp);
         GET(load_bias);
         GET(load_multiplier);
@@ -115,6 +115,7 @@
         GET(input_constant);
 
         GET(memory_constant_alpha);
+        GET(lookahead_n_frames);
         GET(init_start_frame);
         GET(init_end_frame);
         GET(init_by_rolling);
@@ -139,9 +140,10 @@
 
         _param-&gt;input_constant = 0;
 
-        _param-&gt;init_start_frame = 1;
-        _param-&gt;init_end_frame = 100;
         _param-&gt;memory_constant_alpha = 1.0 / _param-&gt;init_end_frame;
+        _param-&gt;lookahead_n_frames = 0;
+        _param-&gt;init_start_frame = 0;
+        _param-&gt;init_end_frame = 99;
         _param-&gt;init_by_rolling = false;
 
         _param-&gt;bias = 128;
@@ -239,6 +241,7 @@
     CSET(input_constant);
 
     CSET(memory_constant_alpha);
+    CSET(lookahead_n_frames);
     CSET(init_start_frame);
     CSET(init_end_frame);
     CSET(init_by_rolling);
@@ -314,7 +317,7 @@
         ADM_assert (ret == 255); // 255 = whizzy dialog not implemented
     }
 
-	char* file = ADM_strdup(_param-&gt;input_file.c_str());
+    char * file = ADM_strdup (_param-&gt;input_file.c_str());
 
     diaElemFile input_file
         (0, &amp;file,
@@ -337,8 +340,12 @@
     diaElemFloat memory_constant_alpha
         (&amp;(_param-&gt;memory_constant_alpha),
          QT_TR_NOOP(&quot;Memory constant _alpha\n&quot;
-           &quot;(where A = (1-alpha)*A + alpha*curr_frame):&quot;),
+           &quot;(where A = (1-alpha)*A + alpha*(curr_frame + lookahead)):&quot;),
          0, 0x7fffffff);
+    diaElemUInteger lookahead_n_frames
+        (&amp;(_param-&gt;lookahead_n_frames),
+         QT_TR_NOOP(&quot;Look ahead _N frames:&quot;),
+         0, 0x7fffffff);
     diaElemUInteger init_start_frame
         (&amp;(_param-&gt;init_start_frame),
          QT_TR_NOOP(&quot;Init _Start Frame (first frame # to use for head start):&quot;),
@@ -372,10 +379,11 @@
 
     diaElem * elems[] = { &amp;tool, &amp;input_type, &amp;input_file, &amp;load_bias,
                           &amp;load_multiplier, &amp;input_constant,
-                          &amp;memory_constant_alpha, &amp;init_start_frame,
-                          &amp;init_end_frame, &amp;init_by_rolling,
-                          &amp;bias, &amp;result_bias, &amp;result_multiplier,
-                          &amp;histogram_frame_interval, &amp;debug };
+                          &amp;memory_constant_alpha, &amp;lookahead_n_frames,
+                          &amp;init_start_frame, &amp;init_end_frame,
+                          &amp;init_by_rolling, &amp;bias, &amp;result_bias,
+                          &amp;result_multiplier, &amp;histogram_frame_interval,
+                          &amp;debug };
 
     ret = diaFactoryRun (QT_TR_NOOP(&quot;Swiss Army Knife Configuration&quot;),
                          sizeof (elems) / sizeof (diaElem *), elems);
@@ -385,8 +393,8 @@
         myInfo-&gt;histogram_data_invalid = true;
     }
 
-	_param-&gt;input_file = file;
-	delete[] file;
+    _param-&gt;input_file = file;
+    delete[] file;
 
     return ret;
 }
@@ -449,6 +457,7 @@
         input_file = &quot;**** no file selected ****&quot;;
 
     const char * space = forDialog ? &quot; &quot; : &quot;&quot;;
+    char * cptr;
 
     switch (param-&gt;input_type)
     {
@@ -482,10 +491,15 @@
         break;
     case INPUT_ROLLING_AVERAGE:
         sprintf (inputstr, &quot;A&quot;);
-        sprintf (where, &quot; (where each frame, A=(A*(1-alpha))+(P*alpha), &quot;
-                 &quot;alpha%s=%s%.6f)&quot;,
-                 space, space, param-&gt;memory_constant_alpha);
-        if (param-&gt;init_start_frame)
+        cptr = where + sprintf (where, &quot; (where each frame, &quot;
+                                &quot;A=(A*(1-alpha))+(P*alpha), alpha%s=%s%.6f&quot;,
+                                space, space, param-&gt;memory_constant_alpha);
+        if (param-&gt;lookahead_n_frames)
+            sprintf (cptr, &quot;, P = pixel from %d frames ahead)&quot;,
+                     param-&gt;lookahead_n_frames);
+        else
+            strcpy (cptr, &quot;)&quot;);
+        if (param-&gt;init_start_frame &lt;= param-&gt;init_end_frame)
             sprintf (moreinfo, &quot;, initial A = %s avg of frames %u - %u&quot;,
                      param-&gt;init_by_rolling ? &quot;rolling&quot; : &quot;straight&quot;,
                      param-&gt;init_start_frame, param-&gt;init_end_frame);
@@ -496,7 +510,7 @@
         break;
     }
 
-    char * cptr = conf;
+    cptr = conf;
 
     bool result_is_scaled
         = (param-&gt;result_bias != 0.0 || param-&gt;result_multiplier != 1.0);
@@ -945,6 +959,117 @@
 
 //============================================================================
 
+// This one is used in the lookahead case; it takes the additional parameter
+// supplying the lookahead frame.
+
+template &lt;typename Oper, typename Histo&gt;
+void ADMVideoSwissArmyKnife::computeRollingAverage (ADMImage * image,
+                                                    ADMImage * lookaheadimage,
+                                                    ADMImage * data,
+                                                    uint32_t planesize,
+                                                    SWISSARMYKNIFE_PARAM * param,
+                                                    int32_t bias,
+                                                    const Oper &amp; op_in,
+                                                    const Histo &amp; histogram_in)
+{
+    // We make local copies of the functors so that the calls below to
+    // record_input() and record_output() (for the histogram) and operator()
+    // (for the op) are accessing stack data rather than incurring yet another
+    // indirection.  When it's per-pixel, every little bit helps!
+
+    Histo histogram = histogram_in;
+    Oper op = op_in;
+
+    float alpha = param-&gt;memory_constant_alpha;
+    float oneminusalpha = 1 - alpha;
+
+    // HERE: for speed, we do luma (Y plane) only.  However, some
+    // users might want chroma, too... we should make that
+    // an option or something.
+
+    uint8_t * currp = YPLANE (image) + planesize;
+    uint8_t * destp = YPLANE (data) + planesize;
+    float * bgp = myInfo-&gt;bg + planesize;
+    uint32_t pixremaining = planesize + 1;
+
+    uint32_t sathigh = 0;
+    uint32_t satlow = 0;
+
+    if (lookaheadimage)
+    {
+        uint8_t * aheadp = YPLANE (lookaheadimage) + planesize;
+
+        while (--pixremaining)
+        {
+            int32_t P = *--currp;
+            histogram.record_input (P);
+
+            float A = *--bgp;
+            *bgp = (A * oneminusalpha) + (*--aheadp * alpha);
+
+            int32_t result = op (P, A) + bias;
+
+            histogram.record_output (result);
+
+            if (result &amp; 0xffffff00)
+            {
+                if (result &lt; 0)
+                {
+                    result = 0;
+                    satlow++;
+                }
+                else // if (result &gt; 255)
+                {
+                    result = 255;
+                    sathigh++;
+                }
+            }
+
+            *--destp = result;
+        }
+    }
+    else
+    {
+        while (--pixremaining)
+        {
+            int32_t P = *--currp;
+            histogram.record_input (P);
+
+            float A = *--bgp;
+            // no update of background - the lookahead is looking past the
+            // end of the video
+
+            int32_t result = op (P, A) + bias;
+
+            histogram.record_output (result);
+
+            if (result &amp; 0xffffff00)
+            {
+                if (result &lt; 0)
+                {
+                    result = 0;
+                    satlow++;
+                }
+                else // if (result &gt; 255)
+                {
+                    result = 255;
+                    sathigh++;
+                }
+            }
+
+            *--destp = result;
+        }
+    }
+
+    if (param-&gt;debug &amp; 2)
+    {
+        if (satlow || sathigh)
+            printf (&quot;    Saturated %d low, %d high\n&quot;, satlow, sathigh);
+    }
+}
+
+//============================================================================
+
 template &lt;typename InputImageType, typename Oper, typename Histo&gt;
 void ADMVideoSwissArmyKnife::applyImage (ADMImage * image, ADMImage * data,
                                          uint32_t planesize,
@@ -1394,15 +1519,42 @@
 
     uint32_t planesize = _info.width * _info.height;
     uint32_t size = (planesize * 3) &gt;&gt; 1;
+    ADMImage * lookaheadimage;
+
+    if (_param-&gt;lookahead_n_frames)
+    {
+        if (myInfo-&gt;bg_lab_size != planesize)
+        {
+            delete myInfo-&gt;bg_lab;
+            myInfo-&gt;bg_lab_size = planesize;
+            myInfo-&gt;bg_lab = new ADMImage (_info.width, _info.height);
+        }
+
+        if (frame + _param-&gt;lookahead_n_frames &gt;= _info.nb_frames)
+            lookaheadimage = 0;
+        else if (!_in-&gt;getFrameNumberNoAlloc (frame
+                                              + _param-&gt;lookahead_n_frames,
+                                              len, myInfo-&gt;bg_lab, flags))
+            return 0;
+        else
+            lookaheadimage = myInfo-&gt;bg_lab;
+    }
+    else
+        lookaheadimage = 0;
+
+    // printf (&quot;%s\n&quot;, getConf (_param, true));
+
     *len = size;
 
-    uint8_t ret = doSwissArmyKnife (_uncompressed, data, _in, this, _param,
+    uint8_t ret = doSwissArmyKnife (_uncompressed, lookaheadimage,
+                                    data, _in, this, _param,
                                     _info.width, _info.height);
     return ret;
 }
 
 uint8_t
 ADMVideoSwissArmyKnife::doSwissArmyKnife (ADMImage * image,
+                                          ADMImage * lookaheadimage,
                                           ADMImage * data,
                                           AVDMGenericVideoStream * in,
                                           ADMVideoSwissArmyKnife * sak,
@@ -1674,6 +1826,7 @@
         if (!myInfo-&gt;bg
             || myInfo-&gt;bg_x != width || myInfo-&gt;bg_y != height
             || myInfo-&gt;bg_mca != param-&gt;memory_constant_alpha
+            || myInfo-&gt;bg_lanf != param-&gt;lookahead_n_frames
             || myInfo-&gt;bg_isf != param-&gt;init_start_frame
             || myInfo-&gt;bg_ief != param-&gt;init_end_frame
             || myInfo-&gt;bg_ibr != param-&gt;init_by_rolling)
@@ -1689,24 +1842,25 @@
             myInfo-&gt;histogram_data_invalid = true;
 
             myInfo-&gt;bg_mca = param-&gt;memory_constant_alpha;
+            myInfo-&gt;bg_lanf = param-&gt;lookahead_n_frames;
             myInfo-&gt;bg_isf = param-&gt;init_start_frame;
             myInfo-&gt;bg_ief = param-&gt;init_end_frame;
             myInfo-&gt;bg_ibr = param-&gt;init_by_rolling;
 
-            if (myInfo-&gt;bg_isf &amp;&amp; myInfo-&gt;bg_isf &lt;= myInfo-&gt;bg_ief)
+            if (myInfo-&gt;bg_isf &lt;= myInfo-&gt;bg_ief)
             {
                 uint32_t do_frames = myInfo-&gt;bg_ief - myInfo-&gt;bg_isf + 1;
 
-                uint32_t firstframe = myInfo-&gt;bg_isf - 1;
-                uint32_t lastframe = myInfo-&gt;bg_ief - 1;
+                uint32_t firstframe = myInfo-&gt;bg_isf;
+                uint32_t lastframe = myInfo-&gt;bg_ief;
                 const ADV_Info &amp; info = sak-&gt;getInfo();
                 if (lastframe &gt;= info.nb_frames)
                 {
                     lastframe = info.nb_frames - 1;
-                    if (firstframe &gt; info.nb_frames)
+                    if (firstframe &gt;= info.nb_frames)
                     {
                         firstframe = lastframe - do_frames + 1;
-                        if (firstframe &gt; info.nb_frames)
+                        if (firstframe &gt;= info.nb_frames)
                             firstframe = 0;
                     }
                     do_frames = lastframe - firstframe + 1;
@@ -1719,7 +1873,7 @@
                         myInfo-&gt;bg_ibr ? &quot;rolling average over&quot;
                         : &quot;straight average of&quot;,
                         do_frames, myInfo-&gt;bg_x, myInfo-&gt;bg_y,
-                        firstframe + 1, lastframe + 1, myInfo-&gt;bg_mca);
+                        firstframe, lastframe, myInfo-&gt;bg_mca);
 
                 ADMImage aimage (myInfo-&gt;bg_x, myInfo-&gt;bg_y);
 
@@ -1728,6 +1882,22 @@
                 // or something.  (...in which case bg should be big enough for
                 // all three planes.)
 
+
+//***************************************************************************
+//***************************************************************************
+//***************************************************************************
+
+                // HERE: issue: if we are not starting at the first frame,
+                // then I think that &quot;in-&gt;getFrameNumberNoAlloc(framenum)&quot;
+                // will give us framenum+frame_at_which_we_are_starting!!
+                // not sure this matters a lot in practice right now, but it
+                // might matter more if users start using a start frame &gt; 1 to
+                // get a good fore/aft ratio...
+
+//***************************************************************************
+//***************************************************************************
+//***************************************************************************
+
                 if (myInfo-&gt;bg_ibr)
                 {
                     // We want to &quot;prime&quot; the rolling average with the values from
@@ -1870,6 +2040,21 @@
         tool += TOOL_ADD_SCALING;
     }
 
+    // It might look like the following switches could be collapsed
+    // significantly if we just used a pointer to the functor objects,
+    // assigning the appropriate operation, histogram functor, etc., and then
+    // using fewer cases.  The problem is that to get the fastest possible
+    // code (important since we're talking about per-pixel operations here),
+    // the tool functor object (e.g., OpPequalsAminusP) needs to be
+    // instantiated inline in the call to the operation template (e.g.,
+    // convolve(), computeRollingAverage(), etc.) so that the functor code can
+    // be inlined.  If we passed an object through a pointer or reference,
+    // we'd have much smaller code (both source and binary), but it would also
+    // be much slower because every pixel would have to traverse the pointer.
+    // So in this case we are buying performance at the cost of a bunch of big
+    // messy switches in the source plus massive template code expansion in
+    // the output.  It's worth it.
+
     if (doingConvolution)
     {
         if (kernel.empty())
@@ -2031,7 +2216,7 @@
             return 0;
         }
     }
-    else if (doingRollingAvg)
+    else if (doingRollingAvg &amp;&amp; param-&gt;lookahead_n_frames == 0)
     {
         switch (tool)
         {
@@ -2225,6 +2410,220 @@
             return 0;
         }
     }
+    else if (doingRollingAvg)
+    {
+        switch (tool)
+        {
+        case TOOL_A:
+            sak-&gt;computeRollingAverage (image, lookaheadimage, data, planesize,
+                                        param, bias, OpPequalsA(), HistogramNull());
+            break;
+        case TOOL_P: // HERE: we could optimize this if we wanted to
+            sak-&gt;computeRollingAverage (image, lookaheadimage, data, planesize,
+                                        param, bias, OpPequalsP(), HistogramNull());
+            break;
+        case TOOL_P_MINUS_A:
+            sak-&gt;computeRollingAverage (image, lookaheadimage, data, planesize,
+                                        param, bias, OpPequalsPminusA(), HistogramNull());
+            break;
+        case TOOL_A_MINUS_P:
+            sak-&gt;computeRollingAverage (image, lookaheadimage, data, planesize,
+                                        param, bias, OpPequalsAminusP(), HistogramNull());
+            break;
+        case TOOL_P_PLUS_A:
+            sak-&gt;computeRollingAverage (image, lookaheadimage, data, planesize,
+                                        param, bias, OpPequalsPplusA(), HistogramNull());
+            break;
+        case TOOL_P_TIMES_A:
+            sak-&gt;computeRollingAverage (image, lookaheadimage, data, planesize,
+                                        param, bias, OpPequalsPtimesA(), HistogramNull());
+            break;
+        case TOOL_P_DIVBY_A:
+            sak-&gt;computeRollingAverage (image, lookaheadimage, data, planesize,
+                                        param, bias, OpPequalsPdivByA(), HistogramNull());
+            break;
+        case TOOL_A_DIVBY_P:
+            sak-&gt;computeRollingAverage (image, lookaheadimage, data, planesize,
+                                        param, bias, OpPequalsAdivByP(), HistogramNull());
+            break;
+        case TOOL_MIN_P_A:
+            sak-&gt;computeRollingAverage (image, lookaheadimage, data, planesize,
+                                        param, bias, OpPequalsMinPA(), HistogramNull());
+            break;
+        case TOOL_MAX_P_A:
+            sak-&gt;computeRollingAverage (image, lookaheadimage, data, planesize,
+                                        param, bias, OpPequalsMaxPA(), HistogramNull());
+            break;
+
+        case TOOL_A_WITH_HISTOGRAM:
+            sak-&gt;computeRollingAverage (image, lookaheadimage, data, planesize,
+                                        param, bias, OpPequalsA(), *histogram);
+            break;
+        case TOOL_P_WITH_HISTOGRAM: // HERE: we could optimize this if we wanted to
+            sak-&gt;computeRollingAverage (image, lookaheadimage, data, planesize,
+                                        param, bias, OpPequalsP(), *histogram);
+            break;
+        case TOOL_P_MINUS_A_WITH_HISTOGRAM:
+            sak-&gt;computeRollingAverage (image, lookaheadimage, data, planesize,
+                                        param, bias, OpPequalsPminusA(), *histogram);
+            break;
+        case TOOL_A_MINUS_P_WITH_HISTOGRAM:
+            sak-&gt;computeRollingAverage (image, lookaheadimage, data, planesize,
+                                        param, bias, OpPequalsAminusP(), *histogram);
+            break;
+        case TOOL_P_PLUS_A_WITH_HISTOGRAM:
+            sak-&gt;computeRollingAverage (image, lookaheadimage, data, planesize,
+                                        param, bias, OpPequalsPplusA(), *histogram);
+            break;
+        case TOOL_P_TIMES_A_WITH_HISTOGRAM:
+            sak-&gt;computeRollingAverage (image, lookaheadimage, data, planesize,
+                                        param, bias, OpPequalsPtimesA(), *histogram);
+            break;
+        case TOOL_P_DIVBY_A_WITH_HISTOGRAM:
+            sak-&gt;computeRollingAverage (image, lookaheadimage, data, planesize,
+                                        param, bias, OpPequalsPdivByA(), *histogram);
+            break;
+        case TOOL_A_DIVBY_P_WITH_HISTOGRAM:
+            sak-&gt;computeRollingAverage (image, lookaheadimage, data, planesize,
+                                        param, bias, OpPequalsAdivByP(), *histogram);
+            break;
+        case TOOL_MIN_P_A_WITH_HISTOGRAM:
+            sak-&gt;computeRollingAverage (image, lookaheadimage, data, planesize,
+                                        param, bias, OpPequalsMinPA(), *histogram);
+            break;
+        case TOOL_MAX_P_A_WITH_HISTOGRAM:
+            sak-&gt;computeRollingAverage (image, lookaheadimage, data, planesize,
+                                        param, bias, OpPequalsMaxPA(), *histogram);
+            break;
+
+        case TOOL_A_SCALED:
+            sak-&gt;computeRollingAverage (image, lookaheadimage, data, planesize,
+                                        param, bias,
+                                        OpPequalsA_Scaled (rbias, rmultiplier),
+                                        HistogramNull());
+            break;
+        case TOOL_P_SCALED: // HERE_SCALED: we could optimize this if we wanted to
+            sak-&gt;computeRollingAverage (image, lookaheadimage, data, planesize,
+                                        param, bias,
+                                        OpPequalsP_Scaled (rbias, rmultiplier),
+                                        HistogramNull());
+            break;
+        case TOOL_P_MINUS_A_SCALED:
+            sak-&gt;computeRollingAverage (image, lookaheadimage, data, planesize,
+                                        param, bias,
+                                        OpPequalsPminusA_Scaled (rbias, rmultiplier),
+                                        HistogramNull());
+            break;
+        case TOOL_A_MINUS_P_SCALED:
+            sak-&gt;computeRollingAverage (image, lookaheadimage, data, planesize,
+                                        param, bias,
+                                        OpPequalsAminusP_Scaled (rbias, rmultiplier),
+                                        HistogramNull());
+            break;
+        case TOOL_P_PLUS_A_SCALED:
+            sak-&gt;computeRollingAverage (image, lookaheadimage, data, planesize,
+                                        param, bias,
+                                        OpPequalsPplusA_Scaled (rbias, rmultiplier),
+                                        HistogramNull());
+            break;
+        case TOOL_P_TIMES_A_SCALED:
+            sak-&gt;computeRollingAverage (image, lookaheadimage, data, planesize,
+                                        param, bias,
+                                        OpPequalsPtimesA_Scaled (rbias, rmultiplier),
+                                        HistogramNull());
+            break;
+        case TOOL_P_DIVBY_A_SCALED:
+            sak-&gt;computeRollingAverage (image, lookaheadimage, data, planesize,
+                                        param, bias,
+                                        OpPequalsPdivByA_Scaled (rbias, rmultiplier),
+                                        HistogramNull());
+            break;
+        case TOOL_A_DIVBY_P_SCALED:
+            sak-&gt;computeRollingAverage (image, lookaheadimage, data, planesize,
+                                        param, bias,
+                                        OpPequalsAdivByP_Scaled (rbias, rmultiplier),
+                                        HistogramNull());
+            break;
+        case TOOL_MIN_P_A_SCALED:
+            sak-&gt;computeRollingAverage (image, lookaheadimage, data, planesize,
+                                        param, bias,
+                                        OpPequalsMinPA_Scaled (rbias, rmultiplier),
+                                        HistogramNull());
+            break;
+        case TOOL_MAX_P_A_SCALED:
+            sak-&gt;computeRollingAverage (image, lookaheadimage, data, planesize,
+                                        param, bias,
+                                        OpPequalsMaxPA_Scaled (rbias, rmultiplier),
+                                        HistogramNull());
+            break;
+
+        case TOOL_A_SCALED_WITH_HISTOGRAM:
+            sak-&gt;computeRollingAverage (image, lookaheadimage, data, planesize,
+                                        param, bias,
+                                        OpPequalsA_Scaled (rbias, rmultiplier),
+                                        *histogram);
+            break;
+        case TOOL_P_SCALED_WITH_HISTOGRAM: // HERE: we could optimize this if we wanted to
+            sak-&gt;computeRollingAverage (image, lookaheadimage, data, planesize,
+                                        param, bias,
+                                        OpPequalsP_Scaled (rbias, rmultiplier),
+                                        *histogram);
+            break;
+        case TOOL_P_MINUS_A_SCALED_WITH_HISTOGRAM:
+            sak-&gt;computeRollingAverage (image, lookaheadimage, data, planesize,
+                                        param, bias,
+                                        OpPequalsPminusA_Scaled (rbias, rmultiplier),
+                                        *histogram);
+            break;
+        case TOOL_A_MINUS_P_SCALED_WITH_HISTOGRAM:
+            sak-&gt;computeRollingAverage (image, lookaheadimage, data, planesize,
+                                        param, bias,
+                                        OpPequalsAminusP_Scaled (rbias, rmultiplier),
+                                        *histogram);
+            break;
+        case TOOL_P_PLUS_A_SCALED_WITH_HISTOGRAM:
+            sak-&gt;computeRollingAverage (image, lookaheadimage, data, planesize,
+                                        param, bias,
+                                        OpPequalsPplusA_Scaled (rbias, rmultiplier),
+                                        *histogram);
+            break;
+        case TOOL_P_TIMES_A_SCALED_WITH_HISTOGRAM:
+            sak-&gt;computeRollingAverage (image, lookaheadimage, data, planesize,
+                                        param, bias,
+                                        OpPequalsPtimesA_Scaled (rbias, rmultiplier),
+                                        *histogram);
+            break;
+        case TOOL_P_DIVBY_A_SCALED_WITH_HISTOGRAM:
+            sak-&gt;computeRollingAverage (image, lookaheadimage, data, planesize,
+                                        param, bias,
+                                        OpPequalsPdivByA_Scaled (rbias, rmultiplier),
+                                        *histogram);
+            break;
+        case TOOL_A_DIVBY_P_SCALED_WITH_HISTOGRAM:
+            sak-&gt;computeRollingAverage (image, lookaheadimage, data, planesize,
+                                        param, bias,
+                                        OpPequalsAdivByP_Scaled (rbias, rmultiplier),
+                                        *histogram);
+            break;
+        case TOOL_MIN_P_A_SCALED_WITH_HISTOGRAM:
+            sak-&gt;computeRollingAverage (image, lookaheadimage, data, planesize,
+                                        param, bias,
+                                        OpPequalsMinPA_Scaled (rbias, rmultiplier),
+                                        *histogram);
+            break;
+        case TOOL_MAX_P_A_SCALED_WITH_HISTOGRAM:
+            sak-&gt;computeRollingAverage (image, lookaheadimage, data, planesize,
+                                        param, bias,
+                                        OpPequalsMaxPA_Scaled (rbias, rmultiplier),
+                                        *histogram);
+            break;
+
+        default:
+            fprintf (stderr, &quot;SwissArmyKnife: unknown operation (tool) %d!\n&quot;,
+                     param-&gt;tool);
+            return 0;
+        }
+    }
     else if (doingFileImageFloat)
     {
         if (width != myInfo-&gt;image_w || height != myInfo-&gt;image_h)

Modified: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidSwissArmyKnife.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidSwissArmyKnife.h	2008-02-03 09:40:17 UTC (rev 3787)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidSwissArmyKnife.h	2008-02-03 12:04:10 UTC (rev 3788)
@@ -39,6 +39,7 @@
     float input_constant;
 
     float    memory_constant_alpha;
+    uint32_t lookahead_n_frames;
     uint32_t init_start_frame;
     uint32_t init_end_frame;
     uint32_t init_by_rolling;
@@ -100,6 +101,9 @@
 
         float *       bg;
         float         bg_mca;
+        ADMImage *    bg_lab; // lookahead buffer
+        uint32_t      bg_lab_size;
+        uint32_t      bg_lanf;
         uint32_t      bg_isf;
         uint32_t      bg_ief;
         uint32_t      bg_x;
@@ -133,6 +137,9 @@
 
               bg (0),
               bg_mca (0),
+              bg_lab (0),
+              bg_lab_size (0),
+              bg_lanf (0),
               bg_isf (0),
               bg_ief (0),
               bg_x (0),
@@ -154,6 +161,7 @@
             delete [] image_int;
             delete [] image_float;
             delete [] bg;
+            delete bg_lab;
             delete [] histogram_input_data;
             delete [] histogram_output_data;
         }
@@ -260,6 +268,7 @@
     static char * getConf (SWISSARMYKNIFE_PARAM * param, bool forDialog);
 
     static uint8_t doSwissArmyKnife (ADMImage * from_image,
+                                     ADMImage * lookaheadimage,
                                      ADMImage * to_image,
                                      AVDMGenericVideoStream * in,
                                      ADMVideoSwissArmyKnife * sak,
@@ -276,6 +285,15 @@
                                 const Oper &amp; op_in,
                                 const Histo &amp; histogram_in);
 
+    template &lt;typename Oper, typename Histo&gt;
+    void computeRollingAverage (ADMImage * image, ADMImage * lookaheadimage,
+                                ADMImage * data,
+                                uint32_t planesize,
+                                SWISSARMYKNIFE_PARAM * param,
+                                int32_t bias,
+                                const Oper &amp; op_in,
+                                const Histo &amp; histogram_in);
+
     template &lt;typename InputImageType, typename Oper, typename Histo&gt;
     void applyImage (ADMImage * image, ADMImage * data,
                      uint32_t planesize,

Modified: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidThreshold.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidThreshold.cpp	2008-02-03 09:40:17 UTC (rev 3787)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidThreshold.cpp	2008-02-03 12:04:10 UTC (rev 3788)
@@ -39,15 +39,16 @@
 
 BUILD_CREATE(threshold_create,ADMVideoThreshold);
 
-ADMVideoThreshold::ADMVideoThreshold(AVDMGenericVideoStream *in,CONFcouple *couples)
+ADMVideoThreshold::ADMVideoThreshold (AVDMGenericVideoStream *in,
+                                      CONFcouple *couples)
 			
 {
     printf (&quot;ADMVideoThreshold ctor (%p)\n&quot;, this);
     _in = in;
-    memcpy(&amp;_info,in-&gt;getInfo(),sizeof(_info));
+    memcpy (&amp;_info,in-&gt;getInfo(),sizeof(_info));
     _info.encoding = 1;
     _uncompressed = new ADMImage(_in-&gt;getInfo()-&gt;width, _in-&gt;getInfo()-&gt;height);
-    ADM_assert(_uncompressed);
+    ADM_assert (_uncompressed);
     _param = new THRESHOLD_PARAM;
     if (couples)
     {
@@ -64,11 +65,10 @@
         _param-&gt;debug = 0;
     }
 
-    computeLookupTable (_param, lookup_table);
+    computeLookupTable (_param);
 }
 
-uint8_t ADMVideoThreshold::computeLookupTable (THRESHOLD_PARAM * param,
-                                               uint8_t lookup_table [256])
+uint8_t ADMVideoThreshold::computeLookupTable (THRESHOLD_PARAM * param)
 {
     uint8_t changed = false;
 
@@ -123,19 +123,19 @@
     CSET(debug);
 
     return 1;
-
 }
 
-uint8_t ADMVideoThreshold::configure(AVDMGenericVideoStream *in)
+uint8_t ADMVideoThreshold::configure (AVDMGenericVideoStream *in)
 {
-    uint8_t ret = DIA_threshold (_in, _param);
+    uint8_t ret = DIA_threshold (_in, this, _param);
     if (ret == 1)
     {
-        computeLookupTable (_param, lookup_table);
+        computeLookupTable (_param);
         return ret;
     }
     else if (ret == 0) // 0 = cancel
     {
+        computeLookupTable (_param);
         return ret;
     }
     else
@@ -164,7 +164,7 @@
 
     if (ret) // 0 = cancel
     {
-        computeLookupTable (_param, lookup_table);
+        computeLookupTable (_param);
     }
 
     return ret;
@@ -234,20 +234,20 @@
     memset (UPLANE (data), 128, planesize &gt;&gt; 2);
     memset (VPLANE (data), 128, planesize &gt;&gt; 2);
 
-    data-&gt;copyInfo(image);
+    data-&gt;copyInfo (image);
     return 1;
 }	                           
 
 // This is used by the preview code for the configuration dialog.
 
 void ADMVideoThreshold::doThreshold (ADMImage * from, ADMImage * to,
-                                     uint8_t * lookup_table,
+                                     ADMVideoThreshold * thresholdp,
                                      uint32_t pixelcount)
 {
     uint8_t * currp = YPLANE (from) + pixelcount;
     uint8_t * destp = YPLANE (to) + pixelcount;
     uint32_t pixremaining = pixelcount + 1;
-    uint8_t * table = lookup_table;
+    const uint8_t * table = thresholdp-&gt;lookup_table;
 
     while (--pixremaining)
     {

Modified: branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidThreshold.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidThreshold.h	2008-02-03 09:40:17 UTC (rev 3787)
+++ branches/avidemux_2.4_branch/avidemux/ADM_videoFilter/ADM_vidThreshold.h	2008-02-03 12:04:10 UTC (rev 3788)
@@ -47,16 +47,18 @@
                                                ADMImage *data,uint32_t *flags);
 
      virtual uint8_t 	configure (AVDMGenericVideoStream *instream);
-     virtual char 		   *printConf(void);
+     virtual char *     printConf(void);
      virtual uint8_t 	getCoupledConf (CONFcouple **couples);
 
-     static uint8_t computeLookupTable (THRESHOLD_PARAM * param,
-                                        uint8_t lookup_table [256]);
+     uint8_t computeLookupTable (THRESHOLD_PARAM * param);
+
      static void doThreshold (ADMImage * from, ADMImage * to,
-                              uint8_t * lookup_table, uint32_t pixelcount);
+                              ADMVideoThreshold * thresholdp,
+                              uint32_t pixelcount);
 };
 
 uint8_t DIA_threshold (AVDMGenericVideoStream *in,
+                       ADMVideoThreshold * thresholdp,
                        THRESHOLD_PARAM * param);
 
 #endif


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001055.html">[Avidemux-svn-commit] r3787 - branches/avidemux_2.4_branch/po
</A></li>
	<LI>Next message: <A HREF="001057.html">[Avidemux-svn-commit] r3790 - branches/avidemux_2.4_branch/po
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1056">[ date ]</a>
              <a href="thread.html#1056">[ thread ]</a>
              <a href="subject.html#1056">[ subject ]</a>
              <a href="author.html#1056">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">More information about the Avidemux-svn-commit
mailing list</a><br>
</body></html>
