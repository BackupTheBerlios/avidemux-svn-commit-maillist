<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Avidemux-svn-commit] r2957 -	branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_matroska
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/avidemux-svn-commit/2007-April/index.html" >
   <LINK REL="made" HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r2957%20-%0A%09branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_matroska&In-Reply-To=%3C200704231720.l3NHKwXX022344%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000274.html">
   <LINK REL="Next"  HREF="000276.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Avidemux-svn-commit] r2957 -	branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_matroska</H1>
    <B>mean at BerliOS</B> 
    <A HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r2957%20-%0A%09branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_matroska&In-Reply-To=%3C200704231720.l3NHKwXX022344%40sheep.berlios.de%3E"
       TITLE="[Avidemux-svn-commit] r2957 -	branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_matroska">mean at mail.berlios.de
       </A><BR>
    <I>Mon Apr 23 19:20:58 CEST 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="000274.html">[Avidemux-svn-commit] r2956 - in	branches/avidemux_2.4_branch/addons: . mkvscan
</A></li>
        <LI>Next message: <A HREF="000276.html">[Avidemux-svn-commit] r2958 -	branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_matroska
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#275">[ date ]</a>
              <a href="thread.html#275">[ thread ]</a>
              <a href="subject.html#275">[ subject ]</a>
              <a href="author.html#275">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: mean
Date: 2007-04-23 19:20:56 +0200 (Mon, 23 Apr 2007)
New Revision: 2957

Added:
   branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_matroska/ADM_ebml.h
   branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_matroska/ADM_mkvEntries.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_matroska/ADM_mkvTrackType.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_matroska/ebml.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_matroska/mkv_tagenum.h
   branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_matroska/mkv_tags.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_matroska/mkv_tags.h
Modified:
   branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_matroska/ADM_mkv.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_matroska/ADM_mkv.h
   branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_matroska/ADM_mkv_audio.cpp
   branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_matroska/Makefile.am
Log:
skeleton for mkv parser

Added: branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_matroska/ADM_ebml.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_matroska/ADM_ebml.h	2007-04-23 17:19:44 UTC (rev 2956)
+++ branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_matroska/ADM_ebml.h	2007-04-23 17:20:56 UTC (rev 2957)
@@ -0,0 +1,70 @@
+/*
+      EBML Reader
+      (c) Mean 2007
+      <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
+      
+      GPL v2
+      
+*/
+
+#ifndef  ADM_EBML
+#define ADM_EBML
+#include &quot;mkv_tags.h&quot;
+class ADM_ebml
+{
+  protected:
+    
+    
+  public:
+                    ADM_ebml(void);
+        virtual     ~ADM_ebml();
+        int64_t     readSignedInt(uint32_t nb);
+        uint64_t    readUnsignedInt(uint32_t nb);
+        float       readFloat(uint32_t n);
+        uint8_t     readString(char *string, uint32_t maxLen);
+        uint8_t     readUTF8(char *string, uint32_t maxLen);
+        uint8_t     readElemId(uint64_t *code,uint64_t *len);
+        uint64_t    readEBMCode(void);
+        uint64_t    readEBMCode_Full(void);
+        int64_t     readEBMCode_Signed(void);
+        
+        
+        /***********************************/
+             uint8_t readu8(void);  
+             int8_t  reads8(void);
+             uint16_t readu16(void);  
+             int16_t  reads16(void);
+             uint32_t readu32(void);  
+             int32_t  reads32(void);
+        /***********************************/
+        virtual     uint8_t  readBin(uint8_t *whereto,uint32_t len)=0;
+        virtual     uint8_t  skip(uint32_t nbBytes)=0;
+        virtual     uint64_t tell(void)=0;
+};
+
+class ADM_ebml_file : public ADM_ebml
+{
+  protected:
+                FILE *fp;
+                uint64_t  _begin;
+                uint64_t  _size;
+                uint32_t  _close;
+  public: 
+                            ADM_ebml_file();
+                            ADM_ebml_file(ADM_ebml_file *father,uint32_t size);
+                            ~ADM_ebml_file();
+                    uint8_t open(const char *fn);
+       
+        virtual     uint8_t   readBin(uint8_t *whereto,uint32_t len);
+        virtual     uint8_t   skip(uint32_t nbBytes);
+                    uint64_t  tell(void);
+                    uint8_t   seek(uint64_t pos);
+                    uint8_t   finished(void);
+                    uint8_t   find(ADM_MKV_SEARCHTYPE search,
+                                        MKV_ELEM_ID  prim,MKV_ELEM_ID second,uint32_t *len);
+                    uint8_t   simplefind(MKV_ELEM_ID  prim,uint32_t *len);
+};
+
+void bigHexPrint(uint64_t v);
+
+#endif

Modified: branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_matroska/ADM_mkv.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_matroska/ADM_mkv.cpp	2007-04-23 17:19:44 UTC (rev 2956)
+++ branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_matroska/ADM_mkv.cpp	2007-04-23 17:20:56 UTC (rev 2957)
@@ -29,17 +29,151 @@
 
 #include &quot;ADM_mkv.h&quot;
 
-extern &quot;C&quot;
+#include &quot;mkv_tags.h&quot;
+/*
+    __________________________________________________________
+*/
+
+uint8_t mkvHeader::open(char *name)
 {
-#include &quot;ADM_lavcodec/avcodec.h&quot;
-#include &quot;ADM_lavformat/avformat.h&quot;
-};
+ 
+  ADM_ebml_file ebml;
+  uint64_t id,len;
+  uint32_t alen;
+  ADM_MKV_TYPE type;
+  const char *ss;
+  
+  if(!ebml.open(name)) 
+  {
+    printf(&quot;[MKV]Failed to open file\n&quot;);
+    return 0; 
+  }
+  if(!ebml.find(ADM_MKV_PRIMARY,EBML_HEADER,(MKV_ELEM_ID)0,&amp;alen))
+  {
+    printf(&quot;[MKV] Cannot find header\n&quot;);
+    return 0;
+  }
+  if(!checkHeader(&amp;ebml,alen))
+  {
+     printf(&quot;[MKV] Incorrect Header\n&quot;);
+     return 0;
+  }
 
-#define CONTEXT ((AVFormatContext* )_context)
+  /* Now find tracks */
+  if(!ebml.find(ADM_MKV_SECONDARY,MKV_SEGMENT,MKV_TRACKS,&amp;alen))
+  {
+     printf(&quot;[MKV] Cannot find tracks\n&quot;);
+    return 0;
+  }
+  /* And analyze them */
+  if(!analyzeTracks(&amp;ebml,alen))
+  {
+      printf(&quot;[MKV] incorrect tracks\n&quot;);
+  }
+  return 0;
+}
+/**
+    \fn checkHeader
+    \brief Check that we are compatible with that version of matroska. At the moment, just dump some infos.
+*/
+uint8_t mkvHeader::checkHeader(void *head,uint32_t headlen)
+{
+  printf(&quot;[MKV] *** Header dump ***\n&quot;);
+ ADM_ebml_file father( (ADM_ebml_file *)head,headlen);
+ walk(&amp;father);
+ printf(&quot;[MKV] *** End of Header dump ***\n&quot;);
+ return 1; 
+  
+}
+/**
+    \fn analyzeTracks
+    \brief Read Tracks Info.
+*/
+uint8_t mkvHeader::analyzeTracks(void *head,uint32_t headlen)
+{
+  uint64_t id,len;
+  ADM_MKV_TYPE type;
+  const char *ss;
+ ADM_ebml_file father( (ADM_ebml_file *)head,headlen);
+ while(!father.finished())
+ {
+      father.readElemId(&amp;id,&amp;len);
+      if(!ADM_searchMkvTag( (MKV_ELEM_ID)id,&amp;ss,&amp;type))
+      {
+        printf(&quot;[MKV] Tag 0x%x not found (len %llu)\n&quot;,id,len);
+        father.skip(len);
+        continue;
+      }
+      ADM_assert(ss);
+      if(id!=MKV_TRACK_ENTRY) 
+      {
+        printf(&quot;[MKV] skipping %s\n&quot;,ss);
+        father.skip(len);
+        continue; 
+      }
+      if(!analyzeOneTrack(&amp;father,len)) return 0;
+ }
+ return 1; 
+}
 
+/**
+    \fn walk
+    \brief Walk a matroska atom and print out what is found.
+*/
+uint8_t mkvHeader::walk(void *seed)
+{
+  uint64_t id,len;
+  ADM_MKV_TYPE type;
+  const char *ss;
+  
+   ADM_ebml_file *father=(ADM_ebml_file *)seed;
+    while(!father-&gt;finished())
+   {
+      father-&gt;readElemId(&amp;id,&amp;len);
+      if(!ADM_searchMkvTag( (MKV_ELEM_ID)id,&amp;ss,&amp;type))
+      {
+        printf(&quot;[MKV] Tag 0x%x not found (len %llu)\n&quot;,id,len);
+        father-&gt;skip(len);
+        continue;
+      }
+      ADM_assert(ss);
+      switch(type)
+      {
+        case ADM_MKV_TYPE_CONTAINER:
+                  father-&gt;skip(len);
+                  printf(&quot;%s skipped\n&quot;,ss);
+                  break;
+        case ADM_MKV_TYPE_UINTEGER:
+                  printf(&quot;%s:%llu\n&quot;,ss,father-&gt;readUnsignedInt(len));
+                  break;
+        case ADM_MKV_TYPE_INTEGER:
+                  printf(&quot;%s:%lld\n&quot;,ss,father-&gt;readSignedInt(len));
+                  break;
+        case ADM_MKV_TYPE_STRING:
+        {
+                  char string[len+1];
+                  string[0]=0;
+                  father-&gt;readString(string,len);
+                  printf(&quot;%s:&lt;%s&gt;\n&quot;,ss,string);
+                  break;
+        }
+        default:
+                printf(&quot;%s skipped\n&quot;,ss);
+                father-&gt;skip(len);
+                break;
+      }
+   }
+  return 1;
+}
+/**
+
+*/
+/*
+  __________________________________________________________
+*/
 WAVHeader *mkvHeader::getAudioInfo(void )
 {
-  if(_curAudio) return _curAudio-&gt;getInfo();
+
   return NULL;
 }
 /*
@@ -48,11 +182,6 @@
 
 uint8_t mkvHeader::getAudioStream(AVDMGenericAudioStream **audio)
 {
-  if(_curAudio)
-  {
-    *audio=_curAudio;
-    return 1;
-  }
   *audio=NULL;
   return 0; 
 }
@@ -62,25 +191,7 @@
 
 void mkvHeader::Dump(void)
 {
-  printf(&quot;*********** MKV INFO***********\n&quot;);
-  printf(&quot;[MKV] %d x %d, %d frames\n&quot;,
-                 _mainaviheader.dwWidth,_mainaviheader.dwHeight,_mainaviheader.dwTotalFrames);
-  printf(&quot;[MKV] We have %u bytes of extradata for video\n&quot;,_videoExtraLen);
-  printf(&quot;[MKV] %u / %u\n&quot;,  _videostream.dwScale,  _videostream.dwRate);
-  printf(&quot;[MKV] %u frames\n&quot;,_videostream.dwLength);
-  for(int i=0;i&lt;_nbAudioTrack;i++)
-  {
-    printf(&quot;[MKV] Track:%u index:%u fq:%u channels:%u codec:%u extradatalen:%u length:%u nbchunk %u\n&quot;
-            ,i,_audioTracks[i].streamIndex ,
-            _audioTracks[i].wavHeader.frequency,
-            _audioTracks[i].wavHeader.channels,
-            _audioTracks[i].wavHeader.encoding,
-            _audioTracks[i].extraDataLen,
-            _audioTracks[i].length,
-            _audioTracks[i].nbPackets);
-    
-  }
-  printf(&quot;*********** MKV INFO***********\n&quot;);
+ 
 }
 /*
     __________________________________________________________
@@ -88,7 +199,7 @@
 
 uint32_t mkvHeader::getNbStream(void) 
 {
-  return _nbAudioTrack; 
+  return 0; 
 }
 /*
     __________________________________________________________
@@ -96,31 +207,7 @@
 
 uint8_t mkvHeader::close(void)
 {
-  if(_context)
-  {
-    av_close_input_file(CONTEXT);
-    _context=NULL;
-  }
-  if(_audioTracks)
-  {
-    for(int i=0;i&lt;_nbAudioTrack;i++)
-    { 
-      if(_audioTracks[i].extraData) delete []  _audioTracks[i].extraData;
-      
-    }
-    delete _audioTracks;
-    _audioTracks=NULL;
-  }
-  if(_videoExtraData)
-  {
-    delete [] _videoExtraData;
-    _videoExtraData=NULL; 
-  }
-  if(myName)
-  {
-    delete [] myName;
-    myName=NULL; 
-  }
+  
 }
 /*
     __________________________________________________________
@@ -137,11 +224,8 @@
  mkvHeader::mkvHeader( void ) : vidHeader()
 {
   _fd=NULL;
-  _audioIndex=_videoIndex=-1;
-  _context=NULL;
   _nbAudioTrack=0;
-  _audioTracks=NULL;
-  myName=NULL;
+  memset(_tracks,0,sizeof(_tracks));
 }
 /*
     __________________________________________________________
@@ -151,143 +235,11 @@
 {
   close();
 }
-/*
-    __________________________________________________________
-*/
 
-uint8_t mkvHeader::open(char *name)
-{
-  int err;
-  AVInputFormat *format;
-  
-  printf(&quot;[Matroska] Open\n&quot;);
-  format= av_find_input_format(&quot;matroska&quot;);
-  if(!format)
-  {
-    printf(&quot;[MKV] input format failed\n&quot;);
-    return 0;
-  }
-  err = av_open_input_file((AVFormatContext **)&amp;_context, name, format, 0, NULL);
-  if (err &lt; 0) {
-    printf(&quot;[MKV] Error in open input file %d\n&quot;,err);
-    return 0;
-  }
-  av_find_stream_info(CONTEXT);
-  
-  for(int i = 0; i &lt; CONTEXT-&gt;nb_streams; i++) {
-    AVCodecContext *enc = CONTEXT-&gt;streams[i]-&gt;codec;
-    switch(enc-&gt;codec_type) {
-      case CODEC_TYPE_AUDIO:
-        _nbAudioTrack++;
-        printf(&quot;[MKV] %d is audio\n&quot;,i,CONTEXT-&gt;nb_streams);
-        break;
-      case CODEC_TYPE_VIDEO:
-        _videoIndex=i;
-        printf(&quot;[MKV] %d is video\n&quot;,i,CONTEXT-&gt;nb_streams);
-        break;
-      default:
-        break;
-    }
-  }
-  if(_videoIndex&lt;0)
-  {
-    printf(&quot;[MKV] No video track found\n&quot;);
-    return 0; 
-  }
-  if(_nbAudioTrack)
-  {
-    int cur=0;
-    _audioTracks=new mkvAudioTrak[ _nbAudioTrack];
-    memset(_audioTracks,0,sizeof(mkvAudioTrak) *_nbAudioTrack);
-    for(int i = 0; i &lt; CONTEXT-&gt;nb_streams; i++) 
-    {
-      AVCodecContext *enc = CONTEXT-&gt;streams[i]-&gt;codec;
-      switch(enc-&gt;codec_type) 
-      {
-        case CODEC_TYPE_AUDIO:
-          _audioTracks[cur++].streamIndex=i;
-          break;
-        default:
-          break;
-      }
-    }
-    
-  }
-  
-  if(!readVideoInfo())
-  {
-    printf(&quot;[MKV] Failed reading video info\n&quot;);
-    return 0; 
-  }
-  myName=ADM_strdup(name);
-  prebuildIndex();
-
-  for(int i=0;i&lt;_nbAudioTrack;i++)
-  {
-    readAudioInfo(i); 
-  }
-  if(_nbAudioTrack)
-  {
-    printf(&quot;[MKV] Building current audio track\n&quot;);
-    _isaudiopresent=1;
-    _curAudio=new mkvAudio(name,&amp;_audioTracks[0]);
-  }
-  printf(&quot;[MKV] Successfully open\n&quot;);
-  
-  Dump();
-  return 1;
-}
 /*
     __________________________________________________________
 */
 
- uint8_t  mkvHeader::prebuildIndex(void)
-{
-  AVPacket pkt1, *pkt = &amp;pkt1;
-  int ret;
-  int nbVideo=0;
-  printf(&quot;\n[MKV]Preindexing started, that can take a while...\n&quot;);
-  while(1)
-  {
-    ret = av_read_frame(CONTEXT, pkt);
-    if (ret &lt; 0) 
-    {
-      break;
-    }
-    if(pkt-&gt;stream_index==_videoIndex) 
-    {
-      nbVideo++;
-    }
-    for(int i=0;i&lt;_nbAudioTrack;i++)
-    {
-      if( pkt-&gt;stream_index==_audioTracks[i].streamIndex)
-      {
-        _audioTracks[i].nbPackets++;
-        _audioTracks[i].length+=pkt-&gt;size;
-      }
-    }
-  }
-  printf(&quot;\n[MKV]Preindexing done\n&quot;);
-  _videostream.dwLength=_mainaviheader.dwTotalFrames=nbVideo;
-  
-  rewind();
-        
-        
-  return 1;
-}
-uint8_t mkvHeader::rewind( void )
-{
-  int err;
-  AVInputFormat *format;
-  
-  
-  format= av_find_input_format(&quot;matroska&quot;);
-  av_close_input_file(CONTEXT);
-  _context=NULL;
-  err = av_open_input_file((AVFormatContext **)&amp;_context, myName, format, 0, NULL);
-  ADM_assert(err&gt;=0);
-  return 1;
-}
 /*
     __________________________________________________________
 */
@@ -311,142 +263,9 @@
 
 uint8_t  mkvHeader::getFrameNoAlloc(uint32_t framenum,ADMCompressedImage *img)
 {
-  AVPacket pkt1, *pkt = &amp;pkt1;
-  int ret;
-  if(!framenum) rewind();
-  while(1)
-  {
-    ret = av_read_frame(CONTEXT, pkt);
-    if (ret &lt; 0) 
-    {
-      printf(&quot;[MKV] Error reading frame %d\n&quot;,framenum);
-      return 0;
-    }
-    if(pkt-&gt;stream_index!=_videoIndex) 
-    {
-      //printf(&quot;[MKV] Wrong stream %u %u\n&quot;,pkt-&gt;stream_index,_videoIndex);
-      continue;
-    }
-    memcpy(img-&gt;data,pkt-&gt;data,pkt-&gt;size);
-    img-&gt;dataLength=pkt-&gt;size;
-    
-    {
-      if(pkt-&gt;flags  &amp;  PKT_FLAG_KEY)
-        img-&gt;flags=AVI_KEY_FRAME;
-      else
-        img-&gt;flags=0;
-    }
-    break;
-  }
+ 
   return 1; 
 }
-/*
-    __________________________________________________________
-*/
-/*
-    Read info, fill in mainaviheader &amp; video streamheader
-    __________________________________________________________
-*/
-uint8_t mkvHeader::readVideoInfo( void)
-{
-  AVCodecContext *enc=CONTEXT-&gt;streams[_videoIndex]-&gt;codec;
-  uint32_t nbFrame;
-  if(!enc) 
-  {
-    printf(&quot;[MKV]Failed to get video\n&quot;);
-    return 0;
-  }
-  _isvideopresent=1;
-  memset(&amp;_mainaviheader,0,sizeof(_mainaviheader));
-  _mainaviheader.dwWidth=enc-&gt;width;
-  _mainaviheader.dwHeight=enc-&gt;height;
-  _video_bih.biWidth=enc-&gt;width;
-  _video_bih.biHeight=enc-&gt;height;
-  
- 
-  uint32_t fcc=0;
-  // Set codec
-  switch(enc-&gt;codec_id)
-  {
-    case CODEC_ID_H264:      fcc=fourCC::get((uint8_t *)&quot;H264&quot;);break; 
-    case CODEC_ID_MPEG4:     fcc=fourCC::get((uint8_t *)&quot;DIVX&quot;);break;
-    case CODEC_ID_MSMPEG4V3: fcc=fourCC::get((uint8_t *)&quot;DIV3&quot;);break;
-    default:
-      printf(&quot;[MKV] Unknown video fourcc %d\n&quot;,enc-&gt;codec_id);
-      return 0;
-  }
-  _video_bih.biCompression=_videostream.fccHandler=fcc;
-  // Extradata ?
-  if(enc-&gt;extradata &amp;&amp; enc-&gt;extradata_size )
-  {
-    _videoExtraData=new uint8_t[enc-&gt;extradata_size];
-    _videoExtraLen= enc-&gt;extradata_size;
-    memcpy(_videoExtraData,enc-&gt;extradata,_videoExtraLen);
-    
-    
-  }
-  // FrameRate, frame count
-  AVRational r=CONTEXT-&gt;streams[_videoIndex]-&gt;r_frame_rate;
-  if(r.num &amp;&amp; r.den)
-  {
-    _videostream.dwScale=r.num;
-    _videostream.dwRate=r.den;
-  }else
-  {
-    _videostream.dwScale=1000;
-    _videostream.dwRate=25000;
-   
-  }
-  //
-  _videostream.dwLength=_mainaviheader.dwTotalFrames=5;
-  printf(&quot;[MKV] Video info ok\n&quot;);
-  Dump();
-  return 1;
-}
-/*
-    __________________________________________________________
-*/
 
-uint8_t mkvHeader::readAudioInfo( uint32_t track)
-{
-  int index=_audioTracks[track].streamIndex;
-  WAVHeader *hdr=&amp;(_audioTracks[track].wavHeader);
-  AVCodecContext *enc=CONTEXT-&gt;streams[index]-&gt;codec;
-  if(!enc) 
-  {
-    printf(&quot;[MKV]Failed to get audio for track %d (track index %d)\n&quot;,track,index);
-    return 0;
-  }
-  // Set codec
-  switch(enc-&gt;codec_id)
-  {
-    case CODEC_ID_MPEG4AAC:
-    case CODEC_ID_AAC: hdr-&gt;encoding=WAV_AAC;break; 
-    case CODEC_ID_MP3: hdr-&gt;encoding=WAV_MP3;break; 
-    case CODEC_ID_AC3: hdr-&gt;encoding=WAV_AC3;break; 
-    case CODEC_ID_VORBIS: hdr-&gt;encoding=WAV_OGG;break; 
-    default:
-      printf(&quot;[MKV] Unknown audio fourcc %d\n&quot;,enc-&gt;codec_id);
-      hdr-&gt;encoding=WAV_UNKNOWN;
-      return 0;
-  }
-  // Extradata ?
-  if(enc-&gt;extradata &amp;&amp; enc-&gt;extradata_size )
-  {
-    _audioTracks[track].extraData=new uint8_t[enc-&gt;extradata_size];
-    _audioTracks[track].extraDataLen= enc-&gt;extradata_size;
-    memcpy(_audioTracks[track].extraData,enc-&gt;extradata,_audioTracks[track].extraDataLen);
-  }
-  // Channels fq etc...
-  hdr-&gt;frequency=enc-&gt;sample_rate;
-  hdr-&gt;channels=enc-&gt;channels;
-  hdr-&gt;byterate=(enc-&gt;bit_rate&gt;&gt;3);
-  if(!hdr-&gt;byterate) hdr-&gt;byterate=128000&gt;&gt;3;
 
-  
-  printf(&quot;[MKV] Video audio ok for track %d\n&quot;,track);
-
-  return 1;
-}
-
 //EOF

Modified: branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_matroska/ADM_mkv.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_matroska/ADM_mkv.h	2007-04-23 17:19:44 UTC (rev 2956)
+++ branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_matroska/ADM_mkv.h	2007-04-23 17:20:56 UTC (rev 2957)
@@ -22,54 +22,39 @@
 
 #include &quot;ADM_editor/ADM_Video.h&quot;
 #include &quot;ADM_audio/aviaudio.hxx&quot;
-typedef struct mkvAudioTrak
+#include &quot;ADM_inputs/ADM_matroska/ADM_ebml.h&quot;
+typedef struct mkvTrak
 {
+  /* Index in mkv */
   uint32_t  streamIndex;
+  
+  /* Used for audio */
   WAVHeader wavHeader;
-  uint32_t  extraDataLen;
-  uint8_t   *extraData;
   uint32_t  nbPackets;
   uint32_t  length;
-  
+  /* Used for both */
+  uint8_t    *extraData;
+  uint32_t   extraDataLen;
 };
 
-class mkvAudio : public AVDMGenericAudioStream
-{
-  protected:
-    void                    *_context;
-    uint32_t                _trackIndex;
-    WAVHeader               _wavHeader;
-    uint32_t                _extraDataLen;
-    uint8_t                 *_extraData;
-    char                    *myName;
-  public:
-                                mkvAudio(char *name,mkvAudioTrak *track);
-    virtual                     ~mkvAudio();
-    virtual uint32_t            read(uint32_t len,uint8_t *buffer);
-    virtual uint8_t             goTo(uint32_t newoffset);
-    virtual uint8_t             getPacket(uint8_t *dest, uint32_t *len, uint32_t *samples);
-    virtual uint8_t             goToTime(uint32_t mstime);
-    virtual uint8_t             extraData(uint32_t *l,uint8_t **d);
-};
+#define ADM_MKV_MAX_TRACKS 20
 
-
-
 class mkvHeader         :public vidHeader
 {
   protected:
                                 
     FILE                    *_fd;
-    int32_t                 _audioIndex;
-    int32_t                 _videoIndex;
-    uint8_t                 readVideoInfo( void);
-    uint8_t                 readAudioInfo( uint32_t track);
-    uint8_t                 prebuildIndex(void);
-    uint8_t                 rewind(void);
-    void                    *_context;
+    mkvTrak                 _tracks[ADM_MKV_MAX_TRACKS+1];
+
+    
     uint32_t                _nbAudioTrack;
-    mkvAudioTrak            *_audioTracks;
-    mkvAudio                *_curAudio;
-    char                    *myName;
+    
+    
+    uint8_t                 checkHeader(void *head,uint32_t headlen);
+    uint8_t                 analyzeTracks(void *head,uint32_t headlen);
+    uint8_t                 analyzeOneTrack(void *head,uint32_t headlen);
+    uint8_t                 walk(void *seed);
+    
   public:
 
 

Added: branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_matroska/ADM_mkvEntries.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_matroska/ADM_mkvEntries.cpp	2007-04-23 17:19:44 UTC (rev 2956)
+++ branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_matroska/ADM_mkvEntries.cpp	2007-04-23 17:20:56 UTC (rev 2957)
@@ -0,0 +1,199 @@
+/***************************************************************************
+    copyright            : (C) 2006 by mean
+    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include &quot;config.h&quot;
+
+#include &lt;stdio.h&gt;
+#include &lt;stdlib.h&gt;
+
+#include &lt;string.h&gt;
+
+#include &quot;math.h&quot;
+
+#include &quot;default.h&quot;
+#include &quot;ADM_editor/ADM_Video.h&quot;
+#include &lt;ADM_assert.h&gt;
+
+#include &quot;fourcc.h&quot;
+#include &quot;ADM_toolkit/toolkit.hxx&quot;
+
+#include &quot;ADM_mkv.h&quot;
+
+#include &quot;mkv_tags.h&quot;
+
+class entryDesc
+{
+  public:
+          uint32_t     trackNo;
+          uint32_t     trackType;
+          uint32_t     extraDataLen;
+          
+          uint32_t fcc;
+          uint32_t w,h,fps;
+          uint32_t fq,chan,bpp;
+          uint32_t defaultDuration;
+          float    trackScale;
+          uint8_t *extraData;
+         
+          
+          entryDesc(void) {memset(this,0,sizeof(entryDesc));}
+          
+          void dump(void);
+};
+/* Prototypes */
+static uint8_t entryWalk(ADM_ebml_file *head,uint32_t headlen,entryDesc *entry);
+uint32_t ADM_mkvCodecToFourcc(const char *codec);
+/**
+    \fn entryDesc::dump
+    \brief Dump the track entry
+*/
+void entryDesc::dump(void)
+{
+      printf(&quot;*** TRACK SUMMARY **\n&quot;);
+#define PRINT(x) printf(#x&quot; :%u\n&quot;,x)
+      PRINT(trackNo);
+      switch(trackType)
+      {
+        case 1: // Video
+          PRINT(trackType);
+          printf(&quot;==&gt;Video\n&quot;);
+          PRINT(extraDataLen);
+          PRINT(fcc);
+          PRINT(w);
+          PRINT(h);
+          PRINT(fps);
+          break;
+        case 2: // Video
+          printf(&quot;==&gt;Audio\n&quot;);
+          PRINT(extraDataLen);
+          PRINT(fcc);
+          PRINT(fq);
+          PRINT(chan);
+          PRINT(bpp);
+          break;
+        default:
+          printf(&quot;Unkown track type (%d)\n&quot;,trackType);
+      }
+}
+
+/**
+      \fn analyzeOneTrack
+      \brief Grab info about the track (it is a recursive function !)
+              
+*/
+uint8_t mkvHeader::analyzeOneTrack(void *head,uint32_t headlen)
+{
+
+entryDesc entry;
+
+      entryWalk(  (ADM_ebml_file *)head,headlen,&amp;entry);
+      entry.dump();
+      if(entry.trackType==1 &amp;&amp;  !_isvideopresent)
+      {
+        _isvideopresent=1; 
+        _videostream.dwScale=1000;
+        _videostream.dwRate=25000;
+    
+        _mainaviheader.dwMicroSecPerFrame=(uint32_t)floor(50);;     
+        _videostream.fccType=fourCC::get((uint8_t *)&quot;vids&quot;);
+        _video_bih.biBitCount=24;
+        _videostream.dwInitialFrames= 0;
+        _videostream.dwStart= 0;
+        _video_bih.biWidth=_mainaviheader.dwWidth=entry.w;
+        _video_bih.biHeight=_mainaviheader.dwHeight=entry.h;
+        _videostream.fccHandler=_video_bih.biCompression=entry.fcc;
+        _tracks[0].extraData=entry.extraData; 
+        _tracks[0].extraDataLen=entry.extraDataLen;       
+        _tracks[0].streamIndex=entry.trackNo;
+        return 1;
+      }
+      if(entry.trackType==2 &amp;&amp; _nbAudioTrack&lt;ADM_MKV_MAX_TRACKS)
+      {
+         uint32_t  streamIndex;
+         mkvTrak *t=&amp;(_tracks[1+_nbAudioTrack]);
+         
+         t-&gt;wavHeader.encoding=entry.fcc;
+         t-&gt;wavHeader.channels=entry.chan;
+         t-&gt;wavHeader.frequency=entry.fq;
+         t-&gt;wavHeader.bitspersample=16;
+         t-&gt;streamIndex=entry.trackNo;
+         t-&gt;extraData=entry.extraData;
+         t-&gt;extraDataLen=entry.extraDataLen;
+                  
+        _nbAudioTrack++;
+        return 1;
+      }
+      if(entry.extraData) delete [] entry.extraData;
+      return 1;
+  
+}
+  
+/**
+    \fn entryWalk
+    \brief walk a trackEntry atom and grabs all infos. Store them in entry
+*/
+uint8_t entryWalk(ADM_ebml_file *head,uint32_t headlen,entryDesc *entry)
+{
+  ADM_ebml_file father( head,headlen);
+   uint64_t id,len;
+  ADM_MKV_TYPE type;
+  const char *ss;
+  
+  while(!father.finished())
+  {
+      father.readElemId(&amp;id,&amp;len);
+      if(!ADM_searchMkvTag( (MKV_ELEM_ID)id,&amp;ss,&amp;type))
+      {
+        printf(&quot;[MKV] Tag 0x%x not found (len %llu)\n&quot;,id,len);
+        father.skip(len);
+        continue;
+      }
+      switch(id)
+      {
+        case  MKV_TRACK_NUMBER: entry-&gt;trackNo=father.readUnsignedInt(len);break;
+        case  MKV_TRACK_TYPE: entry-&gt;trackType=father.readUnsignedInt(len);break;
+        case  MKV_FRAME_DEFAULT_DURATION:entry-&gt;defaultDuration=father.readUnsignedInt(len);break;
+        // FIXME FLOAT case  MKV_AUDIO_FREQUENCY: entry-&gt;fq=father.readUnsignedInt(len);break;
+        case  MKV_VIDEO_WIDTH: entry-&gt;w=father.readUnsignedInt(len);break;
+        case  MKV_VIDEO_HEIGHT: entry-&gt;h=father.readUnsignedInt(len);break;
+        case  MKV_TRACK_TIMECODESCALE:father.skip(len);break; //FIXME
+
+        
+        case  MKV_CODEC_EXTRADATA:
+        {
+              uint8_t *data=new uint8_t[len];
+                    father.readBin(data,len);
+                    entry-&gt;extraData=data;
+                    entry-&gt;extraDataLen=len;
+                    break;
+        }
+        case  MKV_AUDIO_SETTINGS:
+        case  MKV_VIDEO_SETTINGS:
+                  entryWalk(&amp;father,len,entry);
+                  break;
+        case MKV_CODEC_ID:
+            {
+            uint8_t codec[len+1];
+                  father.readBin(codec,len);
+                  codec[len]=0;
+                  entry-&gt;fcc=ADM_mkvCodecToFourcc((char *)codec);
+                  
+            }
+                  break;
+        default: printf(&quot;[MKV]not handled %s\n&quot;,ss);
+                  father.skip(len);  
+        }
+        
+      }
+  return 1;
+}//EOF

Added: branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_matroska/ADM_mkvTrackType.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_matroska/ADM_mkvTrackType.cpp	2007-04-23 17:19:44 UTC (rev 2956)
+++ branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_matroska/ADM_mkvTrackType.cpp	2007-04-23 17:20:56 UTC (rev 2957)
@@ -0,0 +1,70 @@
+/***************************************************************************
+    copyright            : (C) 2006 by mean
+    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include &quot;config.h&quot;
+
+#include &lt;stdio.h&gt;
+#include &lt;stdlib.h&gt;
+
+#include &lt;string.h&gt;
+
+#include &quot;math.h&quot;
+
+#include &quot;default.h&quot;
+#include &quot;ADM_editor/ADM_Video.h&quot;
+#include &lt;ADM_assert.h&gt;
+
+#include &quot;fourcc.h&quot;
+#include &quot;ADM_toolkit/toolkit.hxx&quot;
+
+#include &quot;ADM_mkv.h&quot;
+
+#include &quot;mkv_tags.h&quot;
+
+typedef struct MKVCC
+{
+    const char *name;
+    uint32_t isVideo;
+    uint32_t audioCC;
+    const char *videoCC;
+};
+
+MKVCC mkvCC[]=
+{
+  {&quot;A_MPEG/L3&quot;,0,WAV_MP3,&quot;&quot;},
+  
+  // Video
+  {&quot;V_MPEG4/ISO/AVC&quot;,1,0,&quot;AVC1&quot;}, //H264
+  {&quot;V_MS/VFW/FOURCC&quot;,1,0,&quot;DIV3&quot;}, // Divx 2.
+  
+  
+  // Filler
+  {&quot;AVIDEMUX_RULES&quot;,1,0,&quot;DIV2&quot;} // DUMMY
+};
+
+uint32_t ADM_mkvCodecToFourcc(const char *codec)
+{
+int nbEntry=sizeof(mkvCC)/sizeof(MKVCC);
+    for(int i=0;i&lt;nbEntry;i++)
+    {
+      MKVCC *cur=&amp;(mkvCC[i]);
+      if(!strcmp(cur-&gt;name,codec))
+      {
+         if(cur-&gt;isVideo) return fourCC::get((uint8_t *)cur-&gt;videoCC);
+               else return cur-&gt;audioCC;
+      }
+    }
+    printf(&quot;[MKV] Warning type &lt;%s&gt; unkown!!\n&quot;,codec);
+    return 0;
+}
+  //EOF

Modified: branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_matroska/ADM_mkv_audio.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_matroska/ADM_mkv_audio.cpp	2007-04-23 17:19:44 UTC (rev 2956)
+++ branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_matroska/ADM_mkv_audio.cpp	2007-04-23 17:20:56 UTC (rev 2957)
@@ -27,122 +27,6 @@
 #include &quot;fourcc.h&quot;
 #include &quot;ADM_toolkit/toolkit.hxx&quot;
 
-#include &quot;ADM_mkv.h&quot;
 
-extern &quot;C&quot;
-{
-#include &quot;ADM_lavcodec/avcodec.h&quot;
-#include &quot;ADM_lavformat/avformat.h&quot;
-};
 
-#define CONTEXT ((AVFormatContext* )_context)
-
-/*
-    __________________________________________________________
-*/
-
-mkvAudio::~mkvAudio()
-{
-  printf(&quot;[MkvAudio] Destroying track\n&quot;);
-  if(_context)
-  {
-    av_close_input_file(CONTEXT);
-    _context=NULL;
-  }
-}
-/*
-    __________________________________________________________
-*/
-
-mkvAudio::mkvAudio(char *name,mkvAudioTrak *track)
-{
-   printf(&quot;[MkvAudio] Creating track\n&quot;);
-   _trackIndex=track-&gt;streamIndex; 
-   _wavheader=&amp;(track-&gt;wavHeader);
-  _extraDataLen=track-&gt;extraDataLen;
-  _extraData=track-&gt;extraData;
-  _length=track-&gt;length;
-  
-  // Open it
-  AVInputFormat *format;
-  
-  printf(&quot;[Matroska] Open\n&quot;);
-  format= av_find_input_format(&quot;matroska&quot;);
-  ADM_assert(format)
-  ADM_assert(0&lt;= av_open_input_file((AVFormatContext **)&amp;_context, name, format, 0, NULL));
-  av_find_stream_info(CONTEXT);
-}
-/*
-    __________________________________________________________
-*/
-
-uint32_t            mkvAudio::read(uint32_t len,uint8_t *buffer)
-{
-  uint32_t lan,samples;
-  if(!getPacket(      buffer,    &amp;lan, &amp;samples)) return 0;
-  return lan;
-}
-/*
-    __________________________________________________________
-*/
-
-uint8_t   mkvAudio::goTo(uint32_t newoffset)
-{
-  return 1; 
-}
-/*
-    __________________________________________________________
-*/
-
-uint8_t   mkvAudio::goToTime(uint32_t newoffset)
-{
-  return 1; 
-}
-/*
-    __________________________________________________________
-*/
-
-uint8_t   mkvAudio::extraData(uint32_t *l,uint8_t **d)
-{
-  if(_extraDataLen)
-  {
-    *l=_extraDataLen;
-    *d=_extraData;  
-  }
-  else
-  {
-    *l=0;
-    *d=NULL; 
-  }
-  return 1;
-}
-/*
-    __________________________________________________________
-*/
-
-uint8_t  mkvAudio::getPacket(uint8_t *dest, uint32_t *len, uint32_t *samples)
-{
-  
-  AVPacket pkt1, *pkt = &amp;pkt1;
-  int ret;
-  while(1)
-  {
-    ret = av_read_frame(CONTEXT, pkt);
-    if (ret &lt; 0) 
-    {
-      printf(&quot;[MKV] Error reading audio frame %d\n&quot;);
-      return 0;
-    }
-    if(pkt-&gt;stream_index!=_trackIndex) 
-    {
-      //printf(&quot;[MKV] Wrong stream %u %u\n&quot;,pkt-&gt;stream_index,_videoIndex);
-      continue;
-    }
-    memcpy(dest,pkt-&gt;data,pkt-&gt;size);
-    *len=pkt-&gt;size;
-    *samples=1024; // FIXME
-    break;
-  }
-  return 1; 
-}
 //EOF

Modified: branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_matroska/Makefile.am
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_matroska/Makefile.am	2007-04-23 17:19:44 UTC (rev 2956)
+++ branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_matroska/Makefile.am	2007-04-23 17:20:56 UTC (rev 2957)
@@ -6,6 +6,6 @@
 
 libADM_matroska_a_METASOURCES = AUTO
 
-libADM_matroska_a_SOURCES = ADM_mkv.cpp ADM_mkv_audio.cpp
+libADM_matroska_a_SOURCES = ADM_mkv.cpp ADM_mkv_audio.cpp ebml.cpp mkv_tags.cpp ADM_mkvEntries.cpp ADM_mkvTrackType.cpp
 
-EXTRA_DIST = ADM_mkv.cpp  ADM_mkv.h  ADM_mkv_audio.cpp
+EXTRA_DIST = ADM_mkv.cpp  ADM_mkv.h  ADM_mkv_audio.cpp 

Added: branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_matroska/ebml.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_matroska/ebml.cpp	2007-04-23 17:19:44 UTC (rev 2956)
+++ branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_matroska/ebml.cpp	2007-04-23 17:20:56 UTC (rev 2957)
@@ -0,0 +1,309 @@
+/***************************************************************************
+ *   Copyright (C) 2007 by mean,    *
+ *   <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>   *
+ *                                                                         *
+ *        EBML Handling code                                               *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+#include &quot;config.h&quot;
+#include &lt;stdio.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;stdint.h&gt;
+#include &quot;default.h&quot;
+#include &quot;ADM_ebml.h&quot;
+#define aprintf(...) {}
+
+#include &quot;ADM_assert.h&quot;
+#if 0
+#define vprintf printf
+#else
+#define vprintf(...) {}
+#endif
+/*
+  It is slow , optimize later
+*/  
+
+uint8_t    ADM_ebml::readElemId(uint64_t *code,uint64_t *len)
+{
+  *code=readEBMCode_Full(); // Keep the length-bits, easier to match with documentation
+  *len=readEBMCode();
+  return 1;
+}
+
+/**
+      \fn       readEBMCode
+      \brief    Returns unsigned integer
+*/
+
+uint64_t    ADM_ebml::readEBMCode(void)
+{
+ uint64_t start=readu8();
+  uint64_t val;      
+  uint32_t mask=0x80,outmask=0x7F,more=0;
+  
+  aprintf(&quot;Start :%x at %llx\n&quot;,start,tell()-1);
+  
+  while(!(mask&amp;start))
+  {
+    mask&gt;&gt;=1;
+    ADM_assert(mask);
+    more++; 
+  }
+  outmask=mask-1;
+  start=start&outmask;
+  for(int i=0;i&lt;more;i++)
+  {
+    start=(start&lt;&lt;8)+readu8(); 
+  }
+  aprintf(&quot;End at %llx\n&quot;,tell());
+  return start;
+}
+/**
+      \fn       readEBMCode
+      \brief    Returns unsigned integer
+*/
+
+int64_t    ADM_ebml::readEBMCode_Signed(void)
+{
+  uint8_t start=readu8();
+  int64_t val;      
+  uint32_t mask=0x80,outmask=0x7F,more=0;
+  
+  while(!(mask&amp;start))
+  {
+    mask&gt;&gt;=1;
+    ADM_assert(mask);
+    more++; 
+  }
+  outmask=mask-1;
+  val=start&outmask;
+  for(int i=0;i&lt;more;i++)
+  {
+    val=(val&lt;&lt;8)+readu8(); 
+  }
+  // Signed !
+  //FIXME
+  return val;
+}
+/**
+      \fn       readEBMCode_Full
+      \brief    Returns complete code, including size-bits (used only for EBML_ID)
+*/
+uint64_t    ADM_ebml::readEBMCode_Full(void)
+{
+  uint64_t start=readu8();
+  uint32_t mask=0x80,more=0;
+  aprintf(&quot;&gt;&gt;StartFull :%x at %llx\n&quot;,start,tell()-1);
+  while(!(mask&amp;start))
+  {
+    mask&gt;&gt;=1;
+    ADM_assert(mask);
+    more++; 
+  }
+  for(int i=0;i&lt;more;i++)
+  {
+    start=(start&lt;&lt;8)+readu8(); 
+  }
+  return start;
+}
+
+uint64_t    ADM_ebml::readUnsignedInt(uint32_t nb) 
+{
+  uint64_t val=0;
+  for(int i=0;i&lt;nb;i++)
+  {
+    val=(val&lt;&lt;8)+readu8(); 
+  }
+  return val;
+}
+int64_t    ADM_ebml::readSignedInt(uint32_t nb) 
+{
+  return 0;
+}
+uint8_t     ADM_ebml::readString(char *string, uint32_t maxLen)
+{
+  uint8_t v;
+  while(maxLen--)
+  {
+    v=*string++=readu8();
+    if(!v) return 1;
+  }
+  *string=0;
+  return 1;  
+}
+/******************
+  Low level read
+**********************/
+
+
+uint8_t ADM_ebml::readu8(void)
+{
+  uint8_t v;
+    readBin(&amp;v,1);
+    return v;
+}
+uint16_t ADM_ebml::readu16(void)
+{
+  uint8_t v[2];
+    readBin(v,2);
+    return (uint16_t)(v[0]&lt;&lt;8)+v[1];
+}
+ADM_ebml::ADM_ebml(void)
+{
+  
+}
+ADM_ebml::~ADM_ebml()
+{
+  
+}
+
+
+//*******************************************
+//***********FILE IO PART *******************
+//*******************************************
+ADM_ebml_file::ADM_ebml_file(ADM_ebml_file *father,uint32_t size)
+{
+  _close=0;
+  _size=size;
+  fp=father-&gt;fp;
+   _begin=ftello(fp);
+}
+ADM_ebml_file::ADM_ebml_file(void) : ADM_ebml()
+{
+  
+}
+ADM_ebml_file::~ADM_ebml_file()
+{
+  ADM_assert(fp);
+  if(_close) fclose(fp);
+  else fseeko(fp,_begin+_size,SEEK_SET);
+  fp=NULL; 
+}
+uint8_t ADM_ebml_file::open(const char *name)
+{
+  _close=1;
+  fp=fopen(name,&quot;rb&quot;);
+  if(!fp) 
+  {
+    aprintf(&quot;[EBML FILE] Failed to open &lt;%s&gt;\n&quot;,name);
+    return 0;
+  }
+  fseeko(fp,0,SEEK_END);
+  _begin=0;
+  _size=ftello(fp);
+  fseeko(fp,0,SEEK_SET);
+  return 1;
+}
+uint8_t  ADM_ebml_file::readBin(uint8_t *whereto,uint32_t len)
+{
+  ADM_assert(fp);
+  if(!fread(whereto,len,1,fp)) return 0;
+  return 1;
+}
+
+uint8_t ADM_ebml_file::skip(uint32_t vv)
+{
+  fseeko(fp,vv,SEEK_CUR);
+  return 1; 
+}
+uint64_t ADM_ebml_file::tell(void)
+{
+  return ftello(fp);
+}
+uint8_t ADM_ebml_file::seek(uint64_t pos)
+{
+  fseeko(fp,pos,SEEK_SET);
+  return 1;
+}
+uint8_t ADM_ebml_file::finished(void)
+{
+  if(tell()&gt;(_begin+_size-4)) return 1;
+  return 0; 
+}
+/** 
+  \fn find
+  \brief Search for the tag given and returns the corresponding atom
+*/
+ uint8_t ADM_ebml_file::find(ADM_MKV_SEARCHTYPE search,MKV_ELEM_ID  prim,MKV_ELEM_ID second,uint32_t *len)
+{
+  uint64_t id,pos;
+  ADM_MKV_TYPE type;
+  const char *ss;
+
+    vprintf(&quot;[MKV]Searching for tag %llx %llx\n&quot;,prim,second);
+    seek(_begin);
+    if(search==ADM_MKV_PRIMARY)
+    {
+          return simplefind(prim,len);
+      }
+    vprintf(&quot;[MKV]Searching primary : %llx\n&quot;,prim);
+    if(!simplefind(prim,len))
+    {
+      vprintf(&quot;[MKV] Primary find failed for %llx\n&quot;,prim);
+      return 0; 
+    }
+    // Now we have the father, go inside
+    ADM_ebml_file *son=new ADM_ebml_file(this,*len);
+    vprintf(&quot;[MKV]Searching secondary : %llx\n&quot;,second);
+    if(!son-&gt;simplefind(second,len))
+    {
+      vprintf(&quot;[MKV] secondary find failed for secondary %llx\n&quot;,second);
+      delete son;
+      return 0; 
+    }
+    pos=son-&gt;tell();
+    delete son;
+    seek(pos);
+    return 1;
+}
+
+/** 
+  \fn find
+  \brief Search for the tag given and returns the corresponding atom
+*/
+uint8_t ADM_ebml_file::simplefind(MKV_ELEM_ID  prim,uint32_t *len)
+{
+  uint64_t id,alen;
+  ADM_MKV_TYPE type;
+  const char *ss;
+  uint64_t pos;
+
+    vprintf(&quot;[MKV] Simple Searching for tag %llx\n&quot;,prim);
+    seek(_begin);
+   
+      while(!finished())
+      {
+          
+          readElemId(&amp;id,&amp;alen);
+          if(!ADM_searchMkvTag( (MKV_ELEM_ID)id,&amp;ss,&amp;type))
+          {
+              vprintf(&quot;[MKV] Tag 0x%x not found\n&quot;,id);
+              skip(alen);
+              continue;
+           }
+          vprintf(&quot;Found Tag : %x (%s)\n&quot;,id,ss);
+          if(id==prim)
+          {
+            *len=(uint32_t )alen;
+            return 1;
+          }else
+            skip(alen);
+      }
+    vprintf(&quot;[MKV] Failed to locate %llx\n&quot;,prim);
+    return 0;
+}
+
+//EOF

Added: branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_matroska/mkv_tagenum.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_matroska/mkv_tagenum.h	2007-04-23 17:19:44 UTC (rev 2956)
+++ branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_matroska/mkv_tagenum.h	2007-04-23 17:20:56 UTC (rev 2957)
@@ -0,0 +1,104 @@
+/***************************************************************************
+ *   Copyright (C) 2007 by mean,    *
+ *   <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>   *
+ *                                                                         *
+ *        EBML Handling code                                               *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+
+
+#if !defined( MKV_TAG_ENUM) || defined(ADM_BUILD_TAG)
+#define MKV_TAG_ENUM
+
+#ifndef ADM_BUILD_TAG
+#define MKTAG(a,b,c) a=b
+#else
+#define MKTAG(a,b,c) {a,c,#a}
+#endif
+  MKTAG(EBML_HEADER,0x1A45DFA3,ADM_MKV_TYPE_CONTAINER),
+  MKTAG(EBML_VERSION,0x4286,ADM_MKV_TYPE_UINTEGER),
+  MKTAG(EBML_COMPAT,0x42F7,ADM_MKV_TYPE_UINTEGER),
+  MKTAG(EBML_MAXIDLEN,0x42F2,ADM_MKV_TYPE_UINTEGER),
+  MKTAG(EBML_MAXSIZELEN,0x42F3,ADM_MKV_TYPE_UINTEGER),
+  MKTAG(EBML_DOCTYPE,0x4282,ADM_MKV_TYPE_STRING),
+  MKTAG(EBML_DOCTYPE_VERSION,0x4287,ADM_MKV_TYPE_UINTEGER),
+  MKTAG(EBML_DOCTYPE_COMPAT,0x4285,ADM_MKV_TYPE_UINTEGER),
+ 
+  MKTAG(MKV_SEGMENT, 0x18538067,ADM_MKV_TYPE_CONTAINER),
+  MKTAG(MKV_CLUSTER, 0x1f43b675,ADM_MKV_TYPE_CONTAINER),
+  
+  MKTAG(MKV_SEEK_HEAD,0x114d9b74,ADM_MKV_TYPE_CONTAINER),
+  MKTAG(MKV_SEEK,0x4dbb,ADM_MKV_TYPE_CONTAINER),
+  MKTAG(MKV_SEEK_POSITION,0x53AC,ADM_MKV_TYPE_UINTEGER),
+  MKTAG(MKV_ID,0x53AB,ADM_MKV_TYPE_BINARY),
+  
+  MKTAG(MKV_INFO,0x1549a966,ADM_MKV_TYPE_CONTAINER),
+  
+  MKTAG(MKV_CUES,0x1c53bb6b,ADM_MKV_TYPE_CONTAINER),
+  
+  MKTAG(MKV_MUXING_APP, 0x4D80,ADM_MKV_TYPE_UTF8),
+  MKTAG(MKV_WRITING_APP, 0x5741,ADM_MKV_TYPE_UTF8),
+  MKTAG(MKV_TITLE, 0x7BA9,ADM_MKV_TYPE_UTF8),
+  
+  MKTAG(MKV_TIMECODE_SCALE,0x2AD7B1,ADM_MKV_TYPE_UINTEGER),
+  
+  MKTAG(MKV_TRACKS,0x1654AE6B,ADM_MKV_TYPE_CONTAINER),
+  MKTAG(MKV_TRACK_ENTRY,0xAE,ADM_MKV_TYPE_CONTAINER),
+  MKTAG(MKV_TRACK_NUMBER,0xD7,ADM_MKV_TYPE_UINTEGER),
+  
+  MKTAG(MKV_TRACK_TYPE,0x83,ADM_MKV_TYPE_UINTEGER),
+  
+  MKTAG(MKV_TRACK_TIMECODESCALE, 0x23314F,ADM_MKV_TYPE_FLOAT),
+  
+  MKTAG(MKV_CODEC_ID,0x86,ADM_MKV_TYPE_STRING),
+  
+  MKTAG(MKV_CODEC_NAME,0x258688,ADM_MKV_TYPE_UTF8),
+   	
+  MKTAG(MKV_VIDEO_SETTINGS,0xE0,ADM_MKV_TYPE_CONTAINER),
+  MKTAG(MKV_FRAME_DEFAULT_DURATION,0x23E383,ADM_MKV_TYPE_UINTEGER),
+  
+  MKTAG(MKV_CODEC_EXTRADATA,0x63A2,ADM_MKV_TYPE_BINARY),
+  
+  MKTAG(MKV_VIDEO_WIDTH,0xB0,ADM_MKV_TYPE_UINTEGER),
+  MKTAG(MKV_VIDEO_HEIGHT,0xBA,ADM_MKV_TYPE_UINTEGER),
+  MKTAG(MKV_VIDEO_AR,0x54B3,ADM_MKV_TYPE_UINTEGER),
+
+  MKTAG(MKV_AUDIO_SETTINGS,0xE1,ADM_MKV_TYPE_CONTAINER),
+  MKTAG(MKV_AUDIO_FREQUENCY,0xB5,ADM_MKV_TYPE_FLOAT),
+  MKTAG(MKV_AUDIO_OUT_FREQUENCY,0x78B5,ADM_MKV_TYPE_FLOAT),
+  MKTAG(MKV_AUDIO_CHANNELS,0x9F,ADM_MKV_TYPE_UINTEGER),
+  MKTAG(MKV_AUDIO_BITS_PER_SAMPLE,0x6264,ADM_MKV_TYPE_UINTEGER),
+  
+  /***/
+  MKTAG(MKV_TIMECODE,0xE7,ADM_MKV_TYPE_UINTEGER),
+  MKTAG(MKV_BLOCK_GROUP,0xA0,ADM_MKV_TYPE_CONTAINER),
+  MKTAG(MKV_BLOCK,0xA1,ADM_MKV_TYPE_BINARY),
+  /** */
+  MKTAG(MKV_CUE_POINT,0xBB,ADM_MKV_TYPE_CONTAINER),
+  MKTAG(MKV_CUE_TIME,0xB3,ADM_MKV_TYPE_UINTEGER),
+  
+  MKTAG(MKV_CUE_TRACK_POSITION,0xB7,ADM_MKV_TYPE_CONTAINER),
+  MKTAG(MKV_CUE_CLUSTER_POSITION,0xF1,ADM_MKV_TYPE_UINTEGER),
+  MKTAG(MKV_CUE_TRACK,0xF7,ADM_MKV_TYPE_UINTEGER),
+  MKTAG(MKV_CUE_BLOCK_NUMBER,0x5378,ADM_MKV_TYPE_UINTEGER),
+  
+   MKTAG(MKV_VOID,0xEC,ADM_MKV_TYPE_BINARY),
+  
+         //*************************
+   MKTAG(MKV_MAX,0xFFFF,ADM_MKV_TYPE_UNKNOWN)    
+       
+#undef MKTAG
+#endif

Added: branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_matroska/mkv_tags.cpp
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_matroska/mkv_tags.cpp	2007-04-23 17:19:44 UTC (rev 2956)
+++ branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_matroska/mkv_tags.cpp	2007-04-23 17:20:56 UTC (rev 2957)
@@ -0,0 +1,80 @@
+/***************************************************************************
+ *   Copyright (C) 2007 by mean,    *
+ *   <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>   *
+ *                                                                         *
+ *        EBML Handling code                                               *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+
+#include &lt;stdio.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;stdint.h&gt;
+#include &quot;ADM_ebml.h&quot;
+#include &quot;mkv_tags.h&quot;
+
+
+typedef struct ADM_mkvTagEnum
+{
+    MKV_ELEM_ID   id;
+    ADM_MKV_TYPE  type;
+    const char    *name;
+}ADM_mkvTagEnum;
+#define ADM_BUILD_TAG
+static const ADM_mkvTagEnum mkvTags[]={
+#include &quot;mkv_tagenum.h&quot;
+};
+
+/**
+    \fn ADM_searchMkvTag
+    \brief Search the payload of this ELEM_ID
+*/
+uint8_t ADM_searchMkvTag(MKV_ELEM_ID tag,const char **asString,ADM_MKV_TYPE *type)
+{
+  int full=sizeof(mkvTags)/sizeof(ADM_mkvTagEnum);
+  
+  for(int i=0;i&lt;full;i++)
+  {
+    if(mkvTags[i].id==tag)
+    {
+      *asString=mkvTags[i].name;
+      *type  =mkvTags[i].type;
+      return 1;
+    }
+    
+  }
+  return 0;
+}
+/**
+    \fn ADM_mkvTypeAsString
+    \brief Returns the type as a string
+*/
+const char *ADM_mkvTypeAsString(ADM_MKV_TYPE type)
+{
+#define CONV(x) if(type==x) return #x;
+    CONV(ADM_MKV_TYPE_UNKNOWN)
+    CONV(ADM_MKV_TYPE_CONTAINER)
+    CONV(ADM_MKV_TYPE_STRING)
+    CONV(ADM_MKV_TYPE_UTF8)
+    CONV(ADM_MKV_TYPE_DATE)
+    CONV(ADM_MKV_TYPE_FLOAT)
+    CONV(ADM_MKV_TYPE_UINTEGER)
+    CONV(ADM_MKV_TYPE_INTEGER)
+    CONV(ADM_MKV_TYPE_BINARY)
+        return &quot;unknown type ???&quot;;
+ 
+  
+}
+// EOF

Added: branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_matroska/mkv_tags.h
===================================================================
--- branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_matroska/mkv_tags.h	2007-04-23 17:19:44 UTC (rev 2956)
+++ branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_matroska/mkv_tags.h	2007-04-23 17:20:56 UTC (rev 2957)
@@ -0,0 +1,54 @@
+/***************************************************************************
+ *   Copyright (C) 2007 by mean,    *
+ *   <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>   *
+ *                                                                         *
+ *        EBML Handling code                                               *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
+ ***************************************************************************/
+ 
+#ifndef ADM_MKV_TAGS
+#define ADM_MKV_TAGS
+
+
+typedef enum ADM_MKV_TYPE
+{
+    ADM_MKV_TYPE_UNKNOWN,
+    ADM_MKV_TYPE_CONTAINER,
+    ADM_MKV_TYPE_STRING,
+    ADM_MKV_TYPE_UTF8,
+    ADM_MKV_TYPE_DATE,
+    ADM_MKV_TYPE_FLOAT,
+    ADM_MKV_TYPE_UINTEGER,
+    ADM_MKV_TYPE_INTEGER,
+    ADM_MKV_TYPE_BINARY
+};
+
+typedef enum ADM_MKV_SEARCHTYPE
+{
+  ADM_MKV_PRIMARY, 
+  ADM_MKV_SECONDARY
+};
+
+typedef enum MKV_ELEM_ID
+{
+#include &quot;mkv_tagenum.h&quot;
+};
+
+
+uint8_t ADM_searchMkvTag(MKV_ELEM_ID tag,const char **asString,ADM_MKV_TYPE *type);
+const char *ADM_mkvTypeAsString(ADM_MKV_TYPE type);
+
+#endif


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000274.html">[Avidemux-svn-commit] r2956 - in	branches/avidemux_2.4_branch/addons: . mkvscan
</A></li>
	<LI>Next message: <A HREF="000276.html">[Avidemux-svn-commit] r2958 -	branches/avidemux_2.4_branch/avidemux/ADM_inputs/ADM_matroska
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#275">[ date ]</a>
              <a href="thread.html#275">[ thread ]</a>
              <a href="subject.html#275">[ subject ]</a>
              <a href="author.html#275">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">More information about the Avidemux-svn-commit
mailing list</a><br>
</body></html>
