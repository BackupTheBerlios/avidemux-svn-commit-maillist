From mean at mail.berlios.de  Sun Mar  1 11:30:55 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sun, 1 Mar 2009 11:30:55 +0100
Subject: [Avidemux-svn-commit] r4641 - in
	branches/avidemux_2.6_branch_mean/avidemux: . ADM_codecs
Message-ID: <200903011030.n21AUtsN023692@sheep.berlios.de>

Author: mean
Date: 2009-03-01 11:30:52 +0100 (Sun, 01 Mar 2009)
New Revision: 4641

Added:
   branches/avidemux_2.6_branch_mean/avidemux/gui_misc.cpp
Modified:
   branches/avidemux_2.6_branch_mean/avidemux/ADM_codecs/ADM_ffmpegConfig.h
   branches/avidemux_2.6_branch_mean/avidemux/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/avidemux/gtk_gui.cpp
   branches/avidemux_2.6_branch_mean/avidemux/gui_action.names
   branches/avidemux_2.6_branch_mean/avidemux/gui_save.cpp
Log:
[UI] Cleanup  main dispatch func

Modified: branches/avidemux_2.6_branch_mean/avidemux/ADM_codecs/ADM_ffmpegConfig.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_codecs/ADM_ffmpegConfig.h	2009-02-27 13:41:01 UTC (rev 4640)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_codecs/ADM_ffmpegConfig.h	2009-03-01 10:30:52 UTC (rev 4641)
@@ -21,6 +21,7 @@
  ***************************************************************************/
 #ifndef ADM_FFCONFIG
 #define ADM_FFCONFIG
+#include "avcodec.h"
 typedef struct FFcodecSetting
 {
   Motion_Est_ID me_method;

Modified: branches/avidemux_2.6_branch_mean/avidemux/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/CMakeLists.txt	2009-02-27 13:41:01 UTC (rev 4640)
+++ branches/avidemux_2.6_branch_mean/avidemux/CMakeLists.txt	2009-03-01 10:30:52 UTC (rev 4641)
@@ -140,6 +140,7 @@
 guiplay.cpp  
 gui_save.cpp  
 gui_savenew.cpp  
+gui_misc.cpp
 main.cpp  
 gui_action.cpp
 gui_blackframes.cpp

Modified: branches/avidemux_2.6_branch_mean/avidemux/gtk_gui.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/gtk_gui.cpp	2009-02-27 13:41:01 UTC (rev 4640)
+++ branches/avidemux_2.6_branch_mean/avidemux/gtk_gui.cpp	2009-03-01 10:30:52 UTC (rev 4641)
@@ -1751,138 +1751,6 @@
 // Temporary place...
 
 /**
-    \fn saveAsBmp
-    \brief save current image into filename, into bmp format
-*/
-uint8_t  ADMImage::saveAsBmp(const char *filename)
-{
-  ADM_BITMAPFILEHEADER bmfh;
-  ADM_BITMAPINFOHEADER bmph;
-  FILE *fd;
-  uint32_t sz;
-  uint16_t s16;
-  uint32_t s32;
-
-  sz = _width* _height * 3;
-
-  bmfh.bfReserved1 = bmfh.bfReserved2 = 0;
-  bmfh.bfOffBits = sizeof (bmfh) + sizeof (bmph);
-//_________________________________________
-  bmph.biSize = sizeof (bmph);
-  bmph.biWidth = _width;
-  bmph.biHeight = _height;
-  bmph.biPlanes = 1;
-  bmph.biBitCount = 24;
-  bmph.biCompression = 0;	// COMPRESSION NONE
-  bmph.biSizeImage = sz;
-  bmph.biXPelsPerMeter = 0;
-  bmph.biYPelsPerMeter = 0;
-  bmph.biClrUsed = 0;
-  bmph.biClrImportant = 0;
-/*
-	bmph.resolutionUnits=0;
-	bmph.origin=0;
-	bmph.colorEncoding=0;
-*/
-
-  ADMImage image(_width,_height);
-
-
-  printf ("\n %u x %u=%u\n", bmph.biWidth, bmph.biHeight, sz);
-
-  uint8_t *out;
-
-        out=(uint8_t *)ADM_alloc(sz);
-        if(!out)
-        {
-            GUI_Error_HIG(QT_TR_NOOP("Memory error"), NULL);
-//            ADM_dealloc(out);
-            return 0;
-        }
-
-        if(!COL_yv12rgbBMP(bmph.biWidth, bmph.biHeight,data, out))
-        {
-              GUI_Error_HIG(QT_TR_NOOP("Error converting to BMP"), NULL);
-              ADM_dealloc(out);
-              return 0;
-        }
-        fd = fopen (filename, "wb");
-        if (!fd)
-        {
-                GUI_Error_HIG (QT_TR_NOOP("Something bad happened"), NULL);
-                ADM_dealloc(out);
-                return 0;
-        }
-
-	// Bitmpap file header, not using tructure due to gcc padding it
-#ifdef ADM_BIG_ENDIAN
-	s16 = 0x424D;
-#else
-  	s16 = 0x4D42;
-#endif
-  	s32 = 14 + sizeof (bmph) + sz;
-#ifdef ADM_BIG_ENDIAN
-	#define SWAP32(x) x=R32(x)
-#else
-	#define SWAP32(x) ;
-#endif
-        SWAP32(s32);
-        fwrite (&s16, 2, 1, fd);
-        fwrite (&s32, 4, 1, fd);
-        s32 = 0;
-        fwrite (&s32, 4, 1, fd);
-        s32 = 14 + sizeof (bmph);
-        SWAP32(s32);
-        fwrite (&s32, 4, 1, fd);
-#ifdef ADM_BIG_ENDIAN
-	Endian_BitMapInfo(&bmph);
-#endif
-        fwrite (&bmph, sizeof (bmph), 1, fd);
-        fwrite (out, sz, 1, fd);
-
-        fclose(fd);
-        ADM_dealloc(out);
-        return 1;
-}
-/**
-    \fn saveAsJpg
-    \brief save current image into filename, into jpg format
-*/
-uint8_t  ADMImage::saveAsJpg(const char *filename)
-{
- ffmpegEncoderFFMjpeg *codec=NULL;
-  FILE *fd;
-  uint8_t *buffer=NULL;
-  uint32_t sz;
-
-
-        sz = _width*_height*3;
-        ADMBitstream bitstream(sz);
-        buffer=new uint8_t[sz];
-        bitstream.data=buffer;
-        codec=new  ffmpegEncoderFFMjpeg(_width,_height,FF_MJPEG)  ;
-        codec->init( 95,25000);
-        if(!codec->encode(this,&bitstream))
-        {
-                GUI_Error_HIG(QT_TR_NOOP("Cannot encode the frame"), NULL);
-                delete [] buffer;
-                delete codec;
-                return 0;
-        }
-        delete codec;
-        fd=fopen(filename,"wb");
-        if(!fd)
-        {
-                GUI_Error_HIG(QT_TR_NOOP("File error"),QT_TR_NOOP( "Cannot open \"%s\" for writing."), filename);
-                delete [] buffer;
-                return 0;
-        }
-        fwrite (buffer, bitstream.len, 1, fd);
-        fclose(fd);
-        delete [] buffer;
-        return 1;
-}
-/**
  *      \fn UI_getPreferredRender
  *      \brief Returns to render lib the user preferred rendering method
  *

Modified: branches/avidemux_2.6_branch_mean/avidemux/gui_action.names
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/gui_action.names	2009-02-27 13:41:01 UTC (rev 4640)
+++ branches/avidemux_2.6_branch_mean/avidemux/gui_action.names	2009-03-01 10:30:52 UTC (rev 4641)
@@ -13,20 +13,13 @@
 //----- SAVE -----
 ACT(SAVE_BEGIN)
 ACT(SaveImg)
-ACT(SaveOGM)
 ACT(SaveJPG)
 ACT(SaveBunchJPG)
 ACT(SaveDVDPS)
-ACT(SaveUnpackedMpeg4)
-ACT(SAVE_END)
-ACT(SaveDualAudio)
 ACT(SaveAvi)
 ACT(SaveWave)
-ACT(SaveMpeg1vcd)
-ACT(SaveMpeg2svcd)
-ACT(SaveMpeg2dvd)
 ACT(SaveRaw)
-ACT(XVCD)
+ACT(SAVE_END)
 // /SAVE
 
 //--- NAVIGATE----

Added: branches/avidemux_2.6_branch_mean/avidemux/gui_misc.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/gui_misc.cpp	2009-02-27 13:41:01 UTC (rev 4640)
+++ branches/avidemux_2.6_branch_mean/avidemux/gui_misc.cpp	2009-03-01 10:30:52 UTC (rev 4641)
@@ -0,0 +1,144 @@
+/**
+      \file gui_misc
+      \brief 2nd part of ADMImage, put here to avoid weird dependancies
+*/
+#include "ADM_default.h"
+#include "ADM_image.h"
+#include "ADM_bitmap.h"
+#include "DIA_coreToolkit.h"
+#include "ADM_colorspace.h"
+#include "ADM_bitstream.h"
+#include "ADM_codecs/ADM_codec.h"
+#include "ADM_codecs/ADM_ffmpeg.h"
+/**
+    \fn saveAsBmp
+    \brief save current image into filename, into bmp format
+*/
+uint8_t  ADMImage::saveAsBmp(const char *filename)
+{
+  ADM_BITMAPFILEHEADER bmfh;
+  ADM_BITMAPINFOHEADER bmph;
+  FILE *fd;
+  uint32_t sz;
+  uint16_t s16;
+  uint32_t s32;
+
+  sz = _width* _height * 3;
+
+  bmfh.bfReserved1 = bmfh.bfReserved2 = 0;
+  bmfh.bfOffBits = sizeof (bmfh) + sizeof (bmph);
+//_________________________________________
+  bmph.biSize = sizeof (bmph);
+  bmph.biWidth = _width;
+  bmph.biHeight = _height;
+  bmph.biPlanes = 1;
+  bmph.biBitCount = 24;
+  bmph.biCompression = 0;	// COMPRESSION NONE
+  bmph.biSizeImage = sz;
+  bmph.biXPelsPerMeter = 0;
+  bmph.biYPelsPerMeter = 0;
+  bmph.biClrUsed = 0;
+  bmph.biClrImportant = 0;
+/*
+	bmph.resolutionUnits=0;
+	bmph.origin=0;
+	bmph.colorEncoding=0;
+*/
+
+  ADMImage image(_width,_height);
+
+
+  printf ("\n %u x %u=%u\n", bmph.biWidth, bmph.biHeight, sz);
+
+  uint8_t *out;
+
+        out=(uint8_t *)ADM_alloc(sz);
+        if(!out)
+        {
+            GUI_Error_HIG(QT_TR_NOOP("Memory error"), NULL);
+//            ADM_dealloc(out);
+            return 0;
+        }
+
+        if(!COL_yv12rgbBMP(bmph.biWidth, bmph.biHeight,data, out))
+        {
+              GUI_Error_HIG(QT_TR_NOOP("Error converting to BMP"), NULL);
+              ADM_dealloc(out);
+              return 0;
+        }
+        fd = fopen (filename, "wb");
+        if (!fd)
+        {
+                GUI_Error_HIG (QT_TR_NOOP("Something bad happened"), NULL);
+                ADM_dealloc(out);
+                return 0;
+        }
+
+	// Bitmpap file header, not using tructure due to gcc padding it
+#ifdef ADM_BIG_ENDIAN
+	s16 = 0x424D;
+#else
+  	s16 = 0x4D42;
+#endif
+  	s32 = 14 + sizeof (bmph) + sz;
+#ifdef ADM_BIG_ENDIAN
+	#define SWAP32(x) x=R32(x)
+#else
+	#define SWAP32(x) ;
+#endif
+        SWAP32(s32);
+        fwrite (&s16, 2, 1, fd);
+        fwrite (&s32, 4, 1, fd);
+        s32 = 0;
+        fwrite (&s32, 4, 1, fd);
+        s32 = 14 + sizeof (bmph);
+        SWAP32(s32);
+        fwrite (&s32, 4, 1, fd);
+#ifdef ADM_BIG_ENDIAN
+	Endian_BitMapInfo(&bmph);
+#endif
+        fwrite (&bmph, sizeof (bmph), 1, fd);
+        fwrite (out, sz, 1, fd);
+
+        fclose(fd);
+        ADM_dealloc(out);
+        return 1;
+}
+/**
+    \fn saveAsJpg
+    \brief save current image into filename, into jpg format
+*/
+uint8_t  ADMImage::saveAsJpg(const char *filename)
+{
+ ffmpegEncoderFFMjpeg *codec=NULL;
+  FILE *fd;
+  uint8_t *buffer=NULL;
+  uint32_t sz;
+
+
+        sz = _width*_height*3;
+        ADMBitstream bitstream(sz);
+        buffer=new uint8_t[sz];
+        bitstream.data=buffer;
+        codec=new  ffmpegEncoderFFMjpeg(_width,_height,FF_MJPEG)  ;
+        codec->init( 95,25000);
+        if(!codec->encode(this,&bitstream))
+        {
+                GUI_Error_HIG(QT_TR_NOOP("Cannot encode the frame"), NULL);
+                delete [] buffer;
+                delete codec;
+                return 0;
+        }
+        delete codec;
+        fd=fopen(filename,"wb");
+        if(!fd)
+        {
+                GUI_Error_HIG(QT_TR_NOOP("File error"),QT_TR_NOOP( "Cannot open \"%s\" for writing."), filename);
+                delete [] buffer;
+                return 0;
+        }
+        fwrite (buffer, bitstream.len, 1, fd);
+        fclose(fd);
+        delete [] buffer;
+        return 1;
+}
\ No newline at end of file

Modified: branches/avidemux_2.6_branch_mean/avidemux/gui_save.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/gui_save.cpp	2009-02-27 13:41:01 UTC (rev 4640)
+++ branches/avidemux_2.6_branch_mean/avidemux/gui_save.cpp	2009-03-01 10:30:52 UTC (rev 4641)
@@ -1,6 +1,6 @@
 /** *************************************************************************
             \file gui_save.cpp
-            \brief handle all kind of sabe
+            \brief handle all kind of save
     
     copyright            : (C) 2002/2009 by mean
     email                : fixounet at free.fr
@@ -55,18 +55,7 @@
 {
     switch(action)
     {
-    case ACT_SaveUnpackedMpeg4:
-      if(GUI_Question(QT_TR_NOOP("This is to be used to undo packed VOP on MPEG-4.\nContinue ?")))
-			{
-                          GUI_FileSelWrite (QT_TR_NOOP("Select AVI File to Write"), (SELFILE_CB *)A_SaveUnpackedVop);
 
-			}
-    			break;
-
-    case ACT_SaveOGM:
-//                        GUI_FileSelWrite (QT_TR_NOOP("Select OGM File to Write"), (SELFILE_CB *)ogmSave);
-    			break;
-
     case ACT_SaveWork:
       GUI_FileSelWrite (QT_TR_NOOP("Select Workbench to Save"), A_saveWorkbench);
 	  UI_refreshCustomMenu();
@@ -88,15 +77,9 @@
     case ACT_SaveWave:
       	{
           GUI_FileSelWrite (QT_TR_NOOP("Select File to Save Audio"),(SELFILE_CB *)A_audioSave);
-
-	}
+        }
       break;
 
-    case ACT_SaveDualAudio:
-      //GUI_FileSelWrite ("Select AVI to save ",
-      A_SaveAudioDualAudio(NULL);
-      break;
-
     case ACT_SaveBunchJPG:
       GUI_FileSelWrite (QT_TR_NOOP("Select JPEG Sequence to Save"), A_saveBunchJpg);
     	break;
@@ -120,6 +103,157 @@
     }
 }
 /**
+    \fn A_audioSave
+    \brief Save audio track
+*/
+
+int A_audioSave(char *name)
+{
+	if (!currentaudiostream)	// yes it is checked 2 times so what ?
+	return 0;
+	if (audioProcessMode())
+	{
+		// if we get here, either not compressed
+		// or decompressable
+		A_saveAudioDecodedTest(name);
+    }
+	else			// copy mode...
+    {
+       A_saveAudio(name);
+    }
+	return 1;
+}
+
+/**
+    \fn A_saveAudioDecodedTest
+    \brief Save current stream (generally avi...)
+     in decoded mode (assuming MP3)
+*/
+void A_saveAudioDecodedTest (char *name)
+{
+#if 0
+// debug audio seek
+  uint32_t len, gauge = 0;
+  uint32_t written = 0;
+  FILE *out;
+  AVDMGenericAudioStream *saveFilter;
+
+  uint64_t sampleTarget,sampleCurrent;
+
+#undef BITT
+#define BITT 4*1152
+#define OUTCHUNK 1024*1024
+  uint8_t *outbuffer;
+
+  if (!currentaudiostream)
+    return;
+
+
+  if (!(out = fopen (name, "wb")))
+    {
+      GUI_Error_HIG (QT_TR_NOOP("File error"), QT_TR_NOOP("Cannot open \"%s\" for writing."), name);
+      return;
+    }
+
+  outbuffer = (uint8_t *) ADM_alloc (2 * OUTCHUNK);	// 1Meg cache;
+  if (!outbuffer)
+    {
+      GUI_Error_HIG (QT_TR_NOOP("Memory Error"), NULL);
+      return;
+    }
+
+
+
+// re-ignite first filter...
+
+
+
+
+  // Write Wav header
+
+  /* Sat Nov 09 06:11:52 CET 2002 Fixes from Maik Broemme <mbroemme at plusserver.de> */
+  /* If you set negative delay and save the audio stream, the saved stream was shorter than the video stream. */
+
+  /* Example: video stream is 10 minutes long, audio stream perhaps 20 minutes, you need the audio stream from */
+  /*          minute 1 until 11, so you setup an audio delay from -60 seconds, but this 60 seconds were removed */
+  /*          from begin and end of the audio stream. That was not good :) Now it runs correctly also if you use */
+  /*          audio stream with same length then video, therefore is premature ending :) */
+
+
+
+//        saveFilter =  buildAudioFilter (currentaudiostream,video_body->getTime (frameStart));
+
+		if (saveFilter == NULL)
+		{
+			fclose(out);
+			ADM_dealloc(outbuffer);
+			return;
+		}
+
+    	DIA_working *work=new DIA_working(QT_TR_NOOP("Saving audio"));
+
+
+//
+//  Create First filter that is null filter
+//
+  saveFilter->writeHeader (out);
+  uint32_t tstart,tend,samples;
+  double duration;
+  tstart=video_body->getTime(frameStart);
+  tend=video_body->getTime(frameEnd+1);
+  duration=(tend-tstart);
+  duration*=saveFilter->getInfo()->frequency;
+  duration/=1000.;
+
+  sampleTarget=(uint64_t)floor(duration);
+  sampleCurrent=0;
+  gauge=0;
+
+  if( frameStart == frameEnd ){
+     /* JSC: we will write some bytes, but nobody should expect useful data */
+    GUI_Error_HIG(QT_TR_NOOP("No frames to encode"),QT_TR_NOOP("Please check markers. Is \"A>\" == \">B\"?"));
+  }
+
+  while ((sampleCurrent<sampleTarget))
+    {
+      if(!saveFilter->getPacket(outbuffer + gauge,&len,&samples))
+      {
+        printf("Audio save:Read error\n");
+      	break;
+      }
+      //      printf("Got : %lu\n",len2);
+      gauge += len;
+      sampleCurrent+=samples;
+      // update GUI
+	// JSC: if "A>" == ">B" we will get >100% here => assert in work->update()
+	if (work->update ((sampleCurrent>>10 > sampleTarget>>10 ? sampleTarget>>10 : sampleCurrent>>10), sampleTarget>>10))	// abort request ?
+	    break;;
+      if (gauge > OUTCHUNK)	// either out buffer is full
+	{
+	  fwrite (outbuffer, 1, gauge, out);
+	  written += gauge;
+	  gauge = 0;
+	}
+    };
+// Clean up
+	if(gauge)
+	{
+		fwrite (outbuffer,  gauge,1, out);
+		written += gauge;
+		gauge = 0;
+	}
+  saveFilter->endWrite (out, written);
+  fclose (out);
+  ADM_dealloc (outbuffer);
+  delete work;
+//  deleteAudioFilter (saveFilter);
+//  currentaudiostream->endDecompress ();
+  printf ("AudioSave: actually written %u\n", written);
+  printf ("Audiosave: target sample:%llu, got :%llu\n",sampleTarget,sampleCurrent);
+
+#endif
+}
+/**
         \fn A_saveAudio
         \brief Save current stream (generally avi...)     in raw mode
 */
@@ -146,14 +280,15 @@
 
   work=createWorking(QT_TR_NOOP("Saving audio"));
 
-  uint32_t timeEnd,timeStart,sample,hold,len;
+  uint64_t timeEnd,timeStart;
+  uint32_t hold,len,sample;
   uint64_t tgt_sample,cur_sample;
   double   duration;
 
   // compute start position and duration in samples
 
-   timeStart=video_body->getTime (frameStart);
-   timeEnd=video_body->getTime (frameEnd+1);
+   timeStart=video_body->estimatePts (frameStart);
+   timeEnd=video_body->estimatePts (frameEnd+1);
 
    currentaudiostream->goToTime (timeStart);
    duration=timeEnd-timeStart;
@@ -411,28 +546,7 @@
      ADM_dealloc(actual_workbench_file);
   actual_workbench_file = ADM_strdup(name);
 }
-/**
-    \fn A_audioSave
-    \brief Save audio track
-*/
 
-int A_audioSave(char *name)
-{
-	if (!currentaudiostream)	// yes it is checked 2 times so what ?
-	return 0;
-	if (audioProcessMode())
-	{
-
-		// if we get here, either not compressed
-		// or decompressable
-		A_saveAudioDecodedTest(name);
-	    }
-	else			// copy mode...
-	    {
-	       A_saveAudio(name);
-	    }
-	return 1;
-}
 int A_SaveWrapper(char *name)
 {
 
@@ -447,134 +561,5 @@
         return 1;
 }
 
-/**
-    \fn A_saveAudioDecodedTest
-    \brief Save current stream (generally avi...)
-     in decoded mode (assuming MP3)
-*/
-void A_saveAudioDecodedTest (char *name)
-{
-#if 0
-// debug audio seek
-  uint32_t len, gauge = 0;
-  uint32_t written = 0;
-  FILE *out;
-  AVDMGenericAudioStream *saveFilter;
-
-  uint64_t sampleTarget,sampleCurrent;
-
-#undef BITT
-#define BITT 4*1152
-#define OUTCHUNK 1024*1024
-  uint8_t *outbuffer;
-
-  if (!currentaudiostream)
-    return;
-
-
-  if (!(out = fopen (name, "wb")))
-    {
-      GUI_Error_HIG (QT_TR_NOOP("File error"), QT_TR_NOOP("Cannot open \"%s\" for writing."), name);
-      return;
-    }
-
-  outbuffer = (uint8_t *) ADM_alloc (2 * OUTCHUNK);	// 1Meg cache;
-  if (!outbuffer)
-    {
-      GUI_Error_HIG (QT_TR_NOOP("Memory Error"), NULL);
-      return;
-    }
-
-
-
-// re-ignite first filter...
-
-
-
-
-  // Write Wav header
-
-  /* Sat Nov 09 06:11:52 CET 2002 Fixes from Maik Broemme <mbroemme at plusserver.de> */
-  /* If you set negative delay and save the audio stream, the saved stream was shorter than the video stream. */
-
-  /* Example: video stream is 10 minutes long, audio stream perhaps 20 minutes, you need the audio stream from */
-  /*          minute 1 until 11, so you setup an audio delay from -60 seconds, but this 60 seconds were removed */
-  /*          from begin and end of the audio stream. That was not good :) Now it runs correctly also if you use */
-  /*          audio stream with same length then video, therefore is premature ending :) */
-
-
-
-//        saveFilter =  buildAudioFilter (currentaudiostream,video_body->getTime (frameStart));
-
-		if (saveFilter == NULL)
-		{
-			fclose(out);
-			ADM_dealloc(outbuffer);
-			return;
-		}
-
-    	DIA_working *work=new DIA_working(QT_TR_NOOP("Saving audio"));
-
-
-//
-//  Create First filter that is null filter
-//
-  saveFilter->writeHeader (out);
-  uint32_t tstart,tend,samples;
-  double duration;
-  tstart=video_body->getTime(frameStart);
-  tend=video_body->getTime(frameEnd+1);
-  duration=(tend-tstart);
-  duration*=saveFilter->getInfo()->frequency;
-  duration/=1000.;
-
-  sampleTarget=(uint64_t)floor(duration);
-  sampleCurrent=0;
-  gauge=0;
-
-  if( frameStart == frameEnd ){
-     /* JSC: we will write some bytes, but nobody should expect useful data */
-    GUI_Error_HIG(QT_TR_NOOP("No frames to encode"),QT_TR_NOOP("Please check markers. Is \"A>\" == \">B\"?"));
-  }
-
-  while ((sampleCurrent<sampleTarget))
-    {
-      if(!saveFilter->getPacket(outbuffer + gauge,&len,&samples))
-      {
-        printf("Audio save:Read error\n");
-      	break;
-      }
-      //      printf("Got : %lu\n",len2);
-      gauge += len;
-      sampleCurrent+=samples;
-      // update GUI
-	// JSC: if "A>" == ">B" we will get >100% here => assert in work->update()
-	if (work->update ((sampleCurrent>>10 > sampleTarget>>10 ? sampleTarget>>10 : sampleCurrent>>10), sampleTarget>>10))	// abort request ?
-	    break;;
-      if (gauge > OUTCHUNK)	// either out buffer is full
-	{
-	  fwrite (outbuffer, 1, gauge, out);
-	  written += gauge;
-	  gauge = 0;
-	}
-    };
-// Clean up
-	if(gauge)
-	{
-		fwrite (outbuffer,  gauge,1, out);
-		written += gauge;
-		gauge = 0;
-	}
-  saveFilter->endWrite (out, written);
-  fclose (out);
-  ADM_dealloc (outbuffer);
-  delete work;
-//  deleteAudioFilter (saveFilter);
-//  currentaudiostream->endDecompress ();
-  printf ("AudioSave: actually written %u\n", written);
-  printf ("Audiosave: target sample:%llu, got :%llu\n",sampleTarget,sampleCurrent);
-
-#endif
-}
 //EOF
 



From mean at mail.berlios.de  Sun Mar  1 11:30:59 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sun, 1 Mar 2009 11:30:59 +0100
Subject: [Avidemux-svn-commit] r4642 - in
	branches/avidemux_2.6_branch_mean/avidemux: . ADM_editor
	ADM_toolkit ADM_userInterfaces/ADM_GTK/ADM_gui2
	ADM_userInterfaces/ADM_NONE/ADM_gui2
	ADM_userInterfaces/ADM_QT4/ADM_gui ADM_userInterfaces/ADM_commonUI
Message-ID: <200903011030.n21AUxPw023704@sheep.berlios.de>

Author: mean
Date: 2009-03-01 11:30:58 +0100 (Sun, 01 Mar 2009)
New Revision: 4642

Added:
   branches/avidemux_2.6_branch_mean/avidemux/ADM_editor/ADM_edMarker.cpp
Modified:
   branches/avidemux_2.6_branch_mean/avidemux/ADM_editor/ADM_edit.cpp
   branches/avidemux_2.6_branch_mean/avidemux/ADM_editor/ADM_edit.hxx
   branches/avidemux_2.6_branch_mean/avidemux/ADM_editor/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/avidemux/ADM_toolkit/automation.cpp
   branches/avidemux_2.6_branch_mean/avidemux/ADM_userInterfaces/ADM_GTK/ADM_gui2/GUI_bindings.cpp
   branches/avidemux_2.6_branch_mean/avidemux/ADM_userInterfaces/ADM_NONE/ADM_gui2/gui_none.cpp
   branches/avidemux_2.6_branch_mean/avidemux/ADM_userInterfaces/ADM_QT4/ADM_gui/Q_gui2.cpp
   branches/avidemux_2.6_branch_mean/avidemux/ADM_userInterfaces/ADM_commonUI/GUI_ui.h
   branches/avidemux_2.6_branch_mean/avidemux/gtk_gui.cpp
   branches/avidemux_2.6_branch_mean/avidemux/gui_save.cpp
Log:
[UI] Cleanup of markers + removed obsolete stuff

Added: branches/avidemux_2.6_branch_mean/avidemux/ADM_editor/ADM_edMarker.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_editor/ADM_edMarker.cpp	2009-03-01 10:30:52 UTC (rev 4641)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_editor/ADM_edMarker.cpp	2009-03-01 10:30:58 UTC (rev 4642)
@@ -0,0 +1,54 @@
+/** *************************************************************************
+     \file                     ADM_edMarker.cpp  
+     \brief  Handle Marker
+
+    copyright            : (C) 2002/2009 by mean
+    email                : fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include "ADM_default.h"
+#include "fourcc.h"
+#include "ADM_editor/ADM_edit.hxx"
+
+/**
+        \fn getMarkerAPts
+*/
+uint64_t    ADM_Composer::getMarkerAPts()
+{
+    return markerAPts;
+}
+/**
+        \fn getMarkerBPts
+*/
+
+uint64_t    ADM_Composer::getMarkerBPts()
+{
+    return markerBPts;
+}
+/**
+        \fn setMarkerAPts
+*/
+
+bool        ADM_Composer::setMarkerAPts(uint64_t pts)
+{
+        markerAPts=pts;;
+        return true;
+}
+/**
+        \fn setMarkerBPts
+*/
+
+bool        ADM_Composer::setMarkerBPts(uint64_t pts)
+{
+        markerBPts=pts;;
+        return true;
+}
+//EOF

Modified: branches/avidemux_2.6_branch_mean/avidemux/ADM_editor/ADM_edit.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_editor/ADM_edit.cpp	2009-03-01 10:30:52 UTC (rev 4641)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_editor/ADM_edit.cpp	2009-03-01 10:30:58 UTC (rev 4642)
@@ -461,6 +461,7 @@
 
 
   // next one please
+#if 0
         if(_videos[_nb_video].audioTracks)
         {
             WAVHeader *    _wavinfo=&(_videos[_nb_video].audioTracks[0]->wavheader);
@@ -474,7 +475,7 @@
                     }
             }
         }
-
+#endif
 	_nb_video++;
 	_nb_segment++;
 

Modified: branches/avidemux_2.6_branch_mean/avidemux/ADM_editor/ADM_edit.hxx
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_editor/ADM_edit.hxx	2009-03-01 10:30:52 UTC (rev 4641)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_editor/ADM_edit.hxx	2009-03-01 10:30:58 UTC (rev 4642)
@@ -206,7 +206,15 @@
   				//_____________________________
   				// navigation & frame functions
   				//_____________________________
+/************************************* Markers *****************************/
+private:        
+                        uint64_t markerAPts,markerBPts;
 public:
+                        uint64_t    getMarkerAPts();
+                        uint64_t    getMarkerBPts();
+                        bool        setMarkerAPts(uint64_t pts);
+                        bool        setMarkerBPts(uint64_t pts);
+public:
 /************************************ Public API ***************************/
 protected:
                         uint32_t    currentFrame;

Modified: branches/avidemux_2.6_branch_mean/avidemux/ADM_editor/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_editor/CMakeLists.txt	2009-03-01 10:30:52 UTC (rev 4641)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_editor/CMakeLists.txt	2009-03-01 10:30:58 UTC (rev 4642)
@@ -8,6 +8,7 @@
 ADM_edFrameType.cpp 
 ADM_edit.cpp 
 ADM_edRender.cpp 
+ADM_edMarker.cpp
 ADM_edStub.cpp)
 
 ADD_ADM_LIB_ALL_TARGETS(ADM_editor ${ADM_editor_SRCS})

Modified: branches/avidemux_2.6_branch_mean/avidemux/ADM_toolkit/automation.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_toolkit/automation.cpp	2009-03-01 10:30:52 UTC (rev 4641)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_toolkit/automation.cpp	2009-03-01 10:30:58 UTC (rev 4642)
@@ -51,9 +51,9 @@
 extern int A_saveJpg (char *name);
 extern void filterLoadXml(const char *n);
 extern int A_appendAvi (const char *name);
-extern void A_saveAudio(char *name);
+extern void A_saveAudioCopy(char *name);
 extern int A_loadNone( void );
-extern void A_saveAudioDecodedTest(char *name);
+extern void A_saveAudioProcessed(char *name);
 extern uint8_t A_SaveAudioNVideo(char *name);
 extern int A_loadMP3(char *name);
 extern int A_loadAC3(char *name);
@@ -160,9 +160,9 @@
         {"save-unpacked-vop",	1,"save avi, unpacking vop",(one_arg_type)A_SaveUnpackedVop},
         {"save-packed-vop",	1,"save avi, packing vop",(one_arg_type)A_SavePackedVop},
 //        {"save-ogm",		1,"save as ogm file ",			(one_arg_type)ogmSave},
-        {"save-raw-audio",	1,"save audio as-is ",			A_saveAudio},
+        {"save-raw-audio",	1,"save audio as-is ",			        A_saveAudioCopy},
         {"save-raw-video",	1,"save raw video stream (mpeg/... ) ",	(one_arg_type)ADM_saveRaw},
-        {"save-uncompressed-audio",1,"save uncompressed audio",A_saveAudioDecodedTest},
+        {"save-uncompressed-audio",1,"save uncompressed audio",A_saveAudioProcessed},
         {"load",		1,"load video or workbench", (one_arg_type)A_openAvi},
         {"load-workbench",	1,"load workbench file", (one_arg_type)A_openAvi},
         {"append",		1,"append video",			(one_arg_type)A_appendAvi},

Modified: branches/avidemux_2.6_branch_mean/avidemux/ADM_userInterfaces/ADM_GTK/ADM_gui2/GUI_bindings.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_userInterfaces/ADM_GTK/ADM_gui2/GUI_bindings.cpp	2009-03-01 10:30:52 UTC (rev 4641)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_userInterfaces/ADM_GTK/ADM_gui2/GUI_bindings.cpp	2009-03-01 10:30:58 UTC (rev 4642)
@@ -938,15 +938,22 @@
 /**
     \fn UI_setMarkers
 */
-void UI_setMarkers(uint32_t a, uint32_t b )
+void UI_setMarkers(uint64_t a, uint64_t b )
 {
-char string[500];
-		sprintf(string," %06"LU,a);
-        	gtk_label_set_text(GTK_LABEL(glade.getWidget("labelMarkA")),string);
-		sprintf(string," %06"LU,b);
-        	gtk_label_set_text(GTK_LABEL(glade.getWidget("labelMarkB")),string);
-			gtk_markscale_setA(guiSlider, a);
-			gtk_markscale_setB(guiSlider, b);
+char text[500];
+  uint16_t hh,mm,ss,ms,timems;
+    timems=(uint32_t)(a/1000);
+    ms2time(timems,&hh,&mm,&ss,&ms);
+	snprintf(text,79,"%02"LU":%02"LU":%02"LU".%02"LU" ms",hh,mm,ss,ms);
+	
+    gtk_label_set_text(GTK_LABEL(glade.getWidget("labelMarkA")),text);
+
+	timems=(uint32_t)(b/1000);
+    ms2time(timems,&hh,&mm,&ss,&ms);
+	snprintf(text,79,"%02"LU":%02"LU":%02"LU".%02"LU" ms",hh,mm,ss,ms);
+	gtk_label_set_text(GTK_LABEL(glade.getWidget("labelMarkB")),text);
+    //gtk_markscale_setA(guiSlider, a);
+    //gtk_markscale_setB(guiSlider, b);
 }
 
 /**

Modified: branches/avidemux_2.6_branch_mean/avidemux/ADM_userInterfaces/ADM_NONE/ADM_gui2/gui_none.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_userInterfaces/ADM_NONE/ADM_gui2/gui_none.cpp	2009-03-01 10:30:52 UTC (rev 4641)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_userInterfaces/ADM_NONE/ADM_gui2/gui_none.cpp	2009-03-01 10:30:58 UTC (rev 4642)
@@ -87,7 +87,7 @@
 {}
 void 	UI_setFrameType( uint32_t frametype,uint32_t qp)
 {}
-void 	UI_setMarkers(uint32_t a, uint32_t b )
+void 	UI_setMarkers(uint64_t a, uint64_t b )
 {}
 void 	UI_setTitle(const char *name)
 {}

Modified: branches/avidemux_2.6_branch_mean/avidemux/ADM_userInterfaces/ADM_QT4/ADM_gui/Q_gui2.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_userInterfaces/ADM_QT4/ADM_gui/Q_gui2.cpp	2009-03-01 10:30:52 UTC (rev 4641)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_userInterfaces/ADM_QT4/ADM_gui/Q_gui2.cpp	2009-03-01 10:30:58 UTC (rev 4642)
@@ -953,20 +953,24 @@
     //WIDGET(label_7)->setText(text);
 }
 /**
-    \fn     UI_setMarkers(uint32_t a, uint32_t b )
+    \fn     UI_setMarkers(uint64_t Ptsa, uint32_t Ptsb )
     \brief  Display frame # for marker A & B
 */
-void UI_setMarkers(uint32_t a, uint32_t b)
+void UI_setMarkers(uint64_t a, uint64_t b)
 {
 	char text[80];
-
-	snprintf(text,79,"%06"LU,a);
+    uint16_t hh,mm,ss,ms,timems;
+    timems=(uint32_t)(a/1000);
+    ms2time(timems,&hh,&mm,&ss,&ms);
+	snprintf(text,79,"%02"LU":%02"LU":%02"LU".%02"LU"ms",hh,mm,ss,ms);
 	WIDGET(pushButtonJumpToMarkerA)->setText(text);
 
-	snprintf(text,79,"%06"LU,b);
+	timems=(uint32_t)(b/1000);
+    ms2time(timems,&hh,&mm,&ss,&ms);
+	snprintf(text,79,"%02"LU":%02"LU":%02"LU".%02"LU"ms",hh,mm,ss,ms);
 	WIDGET(pushButtonJumpToMarkerB)->setText(text);
 
-	slider->setMarkers(a, b);
+	//slider->setMarkers(a, b);
 }
 
 /**

Modified: branches/avidemux_2.6_branch_mean/avidemux/ADM_userInterfaces/ADM_commonUI/GUI_ui.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_userInterfaces/ADM_commonUI/GUI_ui.h	2009-03-01 10:30:52 UTC (rev 4641)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_userInterfaces/ADM_commonUI/GUI_ui.h	2009-03-01 10:30:58 UTC (rev 4642)
@@ -13,7 +13,7 @@
 double 	UI_readScale( void );
 void 	UI_setScale( double  val );
 void 	UI_setFrameType( uint32_t frametype,uint32_t qp);
-void 	UI_setMarkers(uint32_t a, uint32_t b );
+void 	UI_setMarkers(uint64_t a, uint64_t b );
 void 	UI_setTitle(const char *name);
 int32_t UI_readJog(void);
 

Modified: branches/avidemux_2.6_branch_mean/avidemux/gtk_gui.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/gtk_gui.cpp	2009-03-01 10:30:52 UTC (rev 4641)
+++ branches/avidemux_2.6_branch_mean/avidemux/gtk_gui.cpp	2009-03-01 10:30:58 UTC (rev 4642)
@@ -14,20 +14,18 @@
  *   (at your option) any later version.                                   *
  *                                                                         *
  ***************************************************************************/
+#include <errno.h>
 #include "config.h"
-
-#include <stdio.h>
-#include <stdlib.h>
+#include "ADM_default.h"
 #include <math.h>
 
-#include <time.h>
-#include <sys/time.h>
-#include <errno.h>
+//#include <time.h>
+//#include <sys/time.h>
 
+
 #include "ADM_lavcodec.h"
 #include "fourcc.h"
 #include "avi_vars.h"
-#include "ADM_assert.h"
 #include "DIA_fileSel.h"
 #include "prototype.h"
 #include "DIA_coreToolkit.h"
@@ -39,8 +37,6 @@
 #include "gui_action.hxx"
 #include "gtkgui.h"
 
-//#include "ADM_outputs/oplug_avi/GUI_mux.h"
-//#include "ADM_outputs/oplug_mpegFF/oplug_vcdff.h"
 #include "ADM_audiofilter/audioeng_buildfilters.h"
 #include "prefs.h"
 #include "ADM_encoder/adm_encConfig.h"
@@ -61,120 +57,108 @@
 #include "ADM_libraries/ADM_libmpeg2enc/ADM_mpeg2enc.h"
 #include "ADM_video/ADM_vidMisc.h"
 #include "ADM_preview.h"
+
+
 static AudioSource currentAudioSource = AudioAvi;
 static AudioSource secondAudioSource = AudioNone;
+
 static char *currentAudioName = NULL;
 static char *secondAudioName = NULL;
 
-void A_handleSecondTrack (int tracktype);
+char * actual_workbench_file;
+renderZoom currentZoom=ZOOM_1_1;
+//***********************************
+//******** A Function ***************
+//***********************************
 int A_delete(uint32_t start, uint32_t end);
-void A_saveImg (const char *name);
-void A_saveBunchJpg( const char *name);
-void A_requantize(void);
-int A_saveJpg (char *name);
 int A_loadWave (char *name);
 int A_loadAC3 (char *name);
 int A_loadMP3 (char *name);
 int A_loadNone( void );
-void A_saveAudioDecodedTest (char *name);
+void A_externalAudioTrack( void );
+uint8_t A_rebuildKeyFrame (void);
 void A_openBrokenAvi (const char *name);
 int A_openAvi2 (const char *name, uint8_t mode);
 int A_appendAvi (const char *name);
-void A_externalAudioTrack( void );
+void A_saveWorkbench (const char *name);
+static void A_videoCheck( void);
+static void	A_setPostproc( void );
+void A_Resync(void);
+void A_addJob(void);
+void A_audioTrack(void);
+extern int A_Save(const char *name);
+int A_SaveWrapper( char *name);
+void A_parseECMAScript(const char *name);
+extern uint8_t A_autoDrive(Action action);
+extern int A_SaveUnpackedVop(const char *name);
+extern int A_SavePackedVop(const char *name);
+uint8_t A_TimeShift(void);
+void A_ResetMarkers(void);
+uint8_t A_setSecondAudioTrack(const AudioSource nw,char *name);
+extern void A_jog(void);
+//***********************************
+//******** GUI Function**************
+//***********************************
+
+extern uint8_t UI_getPhysicalScreenSize(void* window, uint32_t *w,uint32_t *h);
+extern uint8_t GUI_jobs(void);
+extern uint8_t GUI_getFrame(uint32_t frameno,  uint32_t *flags);
+extern const char * GUI_getCustomScript(uint32_t nb);
+
+extern void GUI_setName (char *n);
 uint8_t GUI_getFrameContent(ADMImage *image, uint32_t frame);
-void HandleAction (Action action);
-uint8_t A_rebuildKeyFrame (void);
 extern int GUI_handleVFilter (void);
+extern void GUI_setMarks (uint32_t a, uint32_t b);
+extern void  GUI_displayBitrate( void );
+void GUI_showCurrentFrameHex(void);
+void GUI_avsProxy(void);
+uint8_t GUI_close(void);
+
+//***********************************
+//******** DIA Function**************
+//***********************************
+extern uint8_t DIA_about( void );
+extern uint8_t DIA_RecentFiles( char **name );
+extern void DIA_properties( void);
+extern uint8_t DIA_Preferences(void);
+extern uint8_t DIA_gotoTime(uint16_t *hh, uint16_t *mm, uint16_t *ss);
+extern uint8_t DIA_ocrGen(void);
+extern uint8_t DIA_ocrDvb(void);
+uint8_t DIA_builtin(void);
+extern void DIA_Calculator(uint32_t *sizeInMeg, uint32_t *avgBitrate );
+extern void DIA_glyphEdit(void);
+extern uint8_t DIA_pluginsInfo(void);
 extern void filterCleanUp (void);
-int A_audioSave(char *name);
 static void ReSync (void);
 static void cleanUp (void);
-extern void GUI_setName (char *n);
-extern void DIA_properties( void);
-extern uint8_t DIA_Preferences(void);
-extern void  GUI_displayBitrate( void );
 void test_mpeg (char *name);
-uint8_t GUI_getDoubleValue (double *valye, float min, float max,
-			    const char *title);
-extern void GUI_setMarks (uint32_t a, uint32_t b);
-extern void saveMpegFile (char *name);
-//static void A_selectEncoder ( void );
-extern uint8_t A_SaveAudioDualAudio (const char *a);
-
-extern uint8_t ADM_aviUISetMuxer(  void );
-void A_Resync(void);
-void A_addJob(void);
-static void updateSecondAudioTrack (void);
-void A_audioTrack(void);
-extern int A_Save(const char *name);
-int A_SaveWrapper( char *name);
-static uint32_t getAudioByteCount( uint32_t start, uint32_t end);
-extern void mpegToIndex (char *name);
-static void A_mpegIndexer (void);
-extern uint8_t indexMpeg (char *mpeg, char *file, uint8_t aid);
 void ADM_cutWizard (void);
-uint8_t  ADM_saveRaw (const char *name);
-char * actual_workbench_file;
-void A_saveWorkbench (const char *name);
 void updateLoaded (void);
 extern void encoderSetLogFile (char *name);
 extern void videoCodecSelect (void);
-extern uint8_t DIA_about( void );
-extern uint8_t DIA_RecentFiles( char **name );
-extern uint8_t mpeg_passthrough(const char *name,ADM_OUT_FORMAT format );
-static void A_videoCheck( void);
-extern uint8_t parseScript(char *scriptname);
-static void	A_setPostproc( void );
-extern uint8_t ogmSave(const char  *name);
+
 //
-static uint8_t A_pass(char *name);
+
 uint8_t A_jumpToTime(uint32_t hh,uint32_t mm,uint32_t ss,uint32_t ms);
 //__________
-extern uint8_t DIA_gotoTime(uint16_t *hh, uint16_t *mm, uint16_t *ss);
-extern uint8_t GUI_getFrame(uint32_t frameno,  uint32_t *flags);
-extern int A_SaveUnpackedVop(const char *name);
-extern int A_SavePackedVop(const char *name);
+
+
 extern void videoCodecConfigureUI(int codecIndex = -1);
 extern void audioCodecChanged(int newcodec);
 extern void videoCodecChanged(int newcodec);
-extern void DIA_Calculator(uint32_t *sizeInMeg, uint32_t *avgBitrate );
-extern uint8_t A_autoDrive(Action action);
 
-
-extern uint8_t DIA_ocrGen(void);
-extern uint8_t DIA_ocrDvb(void);
-uint8_t A_TimeShift(void);
-//PARAM_MUX muxMode = MUX_REGULAR;
-int muxParam = 0;
-
-extern uint8_t UI_getPhysicalScreenSize(void* window, uint32_t *w,uint32_t *h);
-extern uint8_t GUI_jobs(void);
 extern bool parseECMAScript(const char *name);
-void A_parseECMAScript(const char *name);
-//static int A_vob2vobsub(void);
-uint8_t DIA_builtin(void);
-renderZoom currentZoom=ZOOM_1_1;
-uint8_t A_setSecondAudioTrack(const AudioSource nw,char *name);
-extern const char * GUI_getCustomScript(uint32_t nb);
 
-
-void GUI_showCurrentFrameHex(void);
-void GUI_avsProxy(void);
-uint8_t GUI_close(void);
-extern void A_jog(void);
-extern void DIA_glyphEdit(void);
-extern uint8_t DIA_pluginsInfo(void);
 extern bool ADM_mux_configure(int index);
 //
+void HandleAction (Action action);
 void HandleAction_Navigate(Action action);
 void HandleAction_Save(Action action);
-//___________________________________________
-// serialization of user event through gui
-//
-// Independant from the toolkit used
-// QT or other port should be easy
-//___________________________________________
+/**
+    \fn HandleAction
+    \brief  serialization of user event through gui
 
+*/
 void HandleAction (Action action)
 {
   static int recursive = 0;
@@ -531,23 +515,30 @@
 
     case ACT_MarkA:
     case ACT_MarkB:
-      uint32_t swapit;
-      if( prefs->get(FEATURE_SWAP_IF_A_GREATER_THAN_B, &swapit) != RC_OK )
-         swapit = 1;
+    {
+      uint32_t swapit=0;
+      uint64_t markA,markB;
+      uint64_t pts=admPreview::getCurrentPts();
+      if( prefs->get(FEATURE_SWAP_IF_A_GREATER_THAN_B, &swapit) != RC_OK )     swapit = 1;
+
+      markA=video_body->getMarkerAPts();
+      markB=video_body->getMarkerBPts();
       if (action == ACT_MarkA)
-            frameStart = video_body->getCurrentFrame();
+            markA=pts;
       else
-            frameEnd = video_body->getCurrentFrame();
-      if (frameStart > frameEnd && swapit )	// auto swap
-	{
-	  uint32_t y;
-	  y = frameStart;
-	  frameStart = frameEnd;
-	  frameEnd = y;
-	}
-      UI_setMarkers (frameStart, frameEnd);
+            markB=pts;
+      if (markA>markB && swapit )	// auto swap
+        {
+          uint64_t y;
+          y = markA;
+          markA=markB;
+          markB=y;
+        }
+        video_body->setMarkerAPts(markA);
+        video_body->setMarkerBPts(markB);
+        UI_setMarkers (markA, markB);
       break;
-  
+    }
     case ACT_Copy:
       		if( frameEnd < frameStart ){
                   GUI_Error_HIG(QT_TR_NOOP("Marker A > B"), QT_TR_NOOP("Cannot copy."));
@@ -581,10 +572,9 @@
 	{
 		video_body->resetSeg();
   		video_body->getVideoInfo (avifileinfo);
-		frameEnd=avifileinfo->nb_frames-1;
-      		frameStart=0;
+		
       		GUI_setAllFrameAndTime ();
-      		UI_setMarkers (frameStart, frameEnd);
+            A_ResetMarkers();
       		ReSync ();
 
 		// forget last project file
@@ -817,9 +807,9 @@
 	}
 
 	/* remember any video or workbench file to "recent" */
-	prefs->set_lastfile(longname);
+        prefs->set_lastfile(longname);
         UI_updateRecentMenu();
-	updateLoaded ();
+        updateLoaded ();
         if(currentaudiostream)
         {
             uint32_t nbAudio;
@@ -837,14 +827,18 @@
             setCurrentMixerFromString("NONE");
         }
 	for(i=strlen(longname);i>=0;i--)
+    {
 #ifdef __WIN32
-		if( longname[i] == '\\' || longname[i] == '/' ){
+		if( longname[i] == '\\' || longname[i] == '/' )
 #else
-		if( longname[i] == '/' ){
+		if( longname[i] == '/' )
 #endif
+        {
+
 			i++;
 			break;
 		}
+    }
 	UI_setTitle(longname+i);
     }
 
@@ -898,10 +892,7 @@
 
   // Draw first frame
   GUI_setAllFrameAndTime();
-
-  video_body->getMarkers(&frameStart,&frameEnd);
-  UI_setMarkers (frameStart, frameEnd);
-
+  A_ResetMarkers();
   getFirstVideoFilter(); // Rebuild filter if needed
 
   /* Zoom out if needed */
@@ -961,7 +952,8 @@
     }
 
   ReSync ();
-  UI_setMarkers (frameStart, frameEnd);
+  A_ResetMarkers();
+  
   return 1;
 }
 
@@ -1179,30 +1171,6 @@
 -------------------------------------------------------**/
 extern  void audioCodecSetcodec(AUDIOENCODER codec);
 
-/**
-	Return the # of byte to go from start frame to end frame
-
-*/
-uint32_t getAudioByteCount( uint32_t start, uint32_t end)
-{
-uint32_t max=0;
-// compute max bytes to read (with little margin)
-  max = video_body->getTime (end + 1) - video_body->getTime (start);
-  //convert time in ms to bytes
-
-  double db;
-  db = max;
-  // 01/10/2002 Fix for 5.1->stereo conversion
-  if (wavinfo->channels > 2)
-    db *= 2;
-  else
-    db *= wavinfo->channels;
-  db *= wavinfo->frequency;
-  db /= 500;			// 1000 because ms, 2 bytes / sample
-  max = (uint32_t) floor (db);
-
-  return max;
-}
 /*
 	Unpack all frames without displaying them to check for error
 
@@ -1243,11 +1211,6 @@
 	GUI_GoToFrame(curframe);
 
 }
-uint8_t A_pass(char *name)
-{
-//        mpeg_passthrough(name,ADM_PS);
-        return 1;
-}
 int A_delete(uint32_t start, uint32_t end)
 {
 uint32_t count;
@@ -1280,11 +1243,8 @@
 	}
 
 
-
-      frameEnd=avifileinfo->nb_frames-1;
-      frameStart=0;
+      A_ResetMarkers();
       GUI_setAllFrameAndTime ();
-      UI_setMarkers (frameStart, frameEnd);
       ReSync ();
      return 1;
 
@@ -1562,7 +1522,9 @@
         GUI_setAllFrameAndTime();
 
         if(curframe>avifileinfo->nb_frames) curframe=frameEnd;
-        UI_setMarkers (frameStart, frameEnd);
+        
+        UI_setMarkers (video_body->getMarkerAPts(),video_body->getMarkerBPts());
+
         GUI_GoToFrame(curframe);
 }
 uint8_t  DIA_job_select(char **jobname, char **filename);
@@ -1816,6 +1778,14 @@
       }
       return QT_TR_NOOP("Unknown codec");
 }
-
+/**
+    \fn A_ResetMarkers
+*/
+void A_ResetMarkers(void)
+{
+uint64_t duration=video_body->getDurationInUs();
+        video_body->setMarkerAPts(0);
+        video_body->setMarkerBPts(duration);
+}
 //
 // EOF

Modified: branches/avidemux_2.6_branch_mean/avidemux/gui_save.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/gui_save.cpp	2009-03-01 10:30:52 UTC (rev 4641)
+++ branches/avidemux_2.6_branch_mean/avidemux/gui_save.cpp	2009-03-01 10:30:58 UTC (rev 4642)
@@ -31,7 +31,7 @@
 #include "DIA_fileSel.h"
 #include "DIA_working.h"
 // Local prototypes
-void A_saveAudio (char *name);
+void A_saveAudioCopy (char *name);
 int  A_saveJpg (char *name);
 void A_saveBunchJpg(const char *name);
 void A_saveImg (const char *name);
@@ -39,7 +39,7 @@
 void A_saveWorkbench (const char *name);
 int  A_audioSave(char *name);
 int  A_SaveWrapper(char *name);
-void A_saveAudioDecodedTest (char *name);
+void A_saveAudioProcessed (char *name);
 // Xternal prototypes
 int      A_SaveUnpackedVop(const char *name);
 uint8_t  A_SaveAudioDualAudio(const char *inname);
@@ -115,21 +115,21 @@
 	{
 		// if we get here, either not compressed
 		// or decompressable
-		A_saveAudioDecodedTest(name);
+		A_saveAudioProcessed(name);
     }
 	else			// copy mode...
     {
-       A_saveAudio(name);
+        A_saveAudioCopy(name);
     }
 	return 1;
 }
 
 /**
-    \fn A_saveAudioDecodedTest
+    \fn A_saveAudioProcessed
     \brief Save current stream (generally avi...)
      in decoded mode (assuming MP3)
 */
-void A_saveAudioDecodedTest (char *name)
+void A_saveAudioProcessed (char *name)
 {
 #if 0
 // debug audio seek
@@ -254,10 +254,10 @@
 #endif
 }
 /**
-        \fn A_saveAudio
+        \fn A_saveAudioCopy
         \brief Save current stream (generally avi...)     in raw mode
 */
-void A_saveAudio (char *name)
+void A_saveAudioCopy (char *name)
 {
 
 // debug audio seek
@@ -273,8 +273,6 @@
   if (!currentaudiostream)
     return;
 
-
-
   out = fopen (name, "wb");
   if (!out) return;
 
@@ -289,16 +287,17 @@
 
    timeStart=video_body->estimatePts (frameStart);
    timeEnd=video_body->estimatePts (frameEnd+1);
-
    currentaudiostream->goToTime (timeStart);
    duration=timeEnd-timeStart;
-   printf("Duration:%f ms\n",duration);
    if(duration<0) duration=-duration;
 
-   duration/=1000;
    duration*=currentaudiostream->getInfo()->frequency;
-
+   duration/=1000000; // in seconds to have samples
    tgt_sample=(uint64_t)floor(duration);
+   printf("[saveAudio] Start time :%"LLU" ms\n",timeStart/1000);
+   printf("[saveAudio] End time :%"LLU" ms\n",timeEnd/1000);
+   printf("[saveAudio]Duration:%f ms\n",duration/1000);
+   printf("[saveAudio]Samples:%"LLU" ms\n",tgt_sample);
 
    cur_sample=0;
    written = 0;
@@ -306,19 +305,19 @@
    buffer=new uint8_t[ONE_STRIKE*2];
    while (1)
     {
-    	if(!currentaudiostream->getPacket(buffer+hold,&len,64*1024,&sample,&dts)) break;
-	hold+=len;
-	written+=len;
-	cur_sample+=sample;
-	if(hold>ONE_STRIKE)
-	{
-		fwrite(buffer,hold,1,out);
-		hold=0;
-	}
-	if(cur_sample>tgt_sample)
-		break;
-      work->update(cur_sample>>10, tgt_sample>>10);
-      if(!work->isAlive()) break;
+    	if(!currentaudiostream->getPacket(buffer+hold,&len,ONE_STRIKE,&sample,&dts)) break;
+        hold+=len;
+        written+=len;
+        cur_sample+=sample;
+        if(hold>ONE_STRIKE) // flush
+        {
+            fwrite(buffer,hold,1,out);
+            hold=0;
+        }
+        if(cur_sample>tgt_sample)
+            break;
+        work->update(cur_sample>>10, tgt_sample>>10);
+        if(!work->isAlive()) break;
     };
   if(hold)
   {
@@ -331,7 +330,6 @@
   delete[] buffer;
   printf ("\n wanted %"LLU" samples, goto %"LLU" samples, written %"LU" bytes\n", tgt_sample,cur_sample, written);
 
-
 }
 
 #ifndef TEST_MP2



From mean at mail.berlios.de  Sun Mar  1 11:31:02 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sun, 1 Mar 2009 11:31:02 +0100
Subject: [Avidemux-svn-commit] r4643 - in
	branches/avidemux_2.6_branch_mean/avidemux: . ADM_editor
	ADM_userInterfaces/ADM_GTK/ADM_gui2
	ADM_userInterfaces/ADM_QT4/ADM_gui
Message-ID: <200903011031.n21AV22A023714@sheep.berlios.de>

Author: mean
Date: 2009-03-01 11:31:01 +0100 (Sun, 01 Mar 2009)
New Revision: 4643

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/ADM_editor/ADM_edit.cpp
   branches/avidemux_2.6_branch_mean/avidemux/ADM_userInterfaces/ADM_GTK/ADM_gui2/GUI_bindings.cpp
   branches/avidemux_2.6_branch_mean/avidemux/ADM_userInterfaces/ADM_QT4/ADM_gui/Q_gui2.cpp
   branches/avidemux_2.6_branch_mean/avidemux/gtk_gui.cpp
   branches/avidemux_2.6_branch_mean/avidemux/gui_navigate.cpp
Log:
[UI] Change marker from framenum to Pts

Modified: branches/avidemux_2.6_branch_mean/avidemux/ADM_editor/ADM_edit.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_editor/ADM_edit.cpp	2009-03-01 10:30:58 UTC (rev 4642)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_editor/ADM_edit.cpp	2009-03-01 10:31:01 UTC (rev 4643)
@@ -504,6 +504,7 @@
 		}
 
 		GoToIntra(0);
+        durationInUs=vid->_aviheader->getVideoDuration();
 		printf(" End of B-frame check\n");
 
   return 1;

Modified: branches/avidemux_2.6_branch_mean/avidemux/ADM_userInterfaces/ADM_GTK/ADM_gui2/GUI_bindings.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_userInterfaces/ADM_GTK/ADM_gui2/GUI_bindings.cpp	2009-03-01 10:30:58 UTC (rev 4642)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_userInterfaces/ADM_GTK/ADM_gui2/GUI_bindings.cpp	2009-03-01 10:31:01 UTC (rev 4643)
@@ -941,16 +941,19 @@
 void UI_setMarkers(uint64_t a, uint64_t b )
 {
 char text[500];
-  uint16_t hh,mm,ss,ms,timems;
-    timems=(uint32_t)(a/1000);
+  uint16_t hh,mm,ss,ms;
+  uint32_t timems;
+    a/=1000;
+    b/=1000;
+    timems=(uint32_t)(a);
     ms2time(timems,&hh,&mm,&ss,&ms);
-	snprintf(text,79,"%02"LU":%02"LU":%02"LU".%02"LU" ms",hh,mm,ss,ms);
+	snprintf(text,79,"%02"LU":%02"LU":%02"LU".%02"LU,hh,mm,ss,ms);
 	
     gtk_label_set_text(GTK_LABEL(glade.getWidget("labelMarkA")),text);
 
-	timems=(uint32_t)(b/1000);
+	timems=(uint32_t)(b);
     ms2time(timems,&hh,&mm,&ss,&ms);
-	snprintf(text,79,"%02"LU":%02"LU":%02"LU".%02"LU" ms",hh,mm,ss,ms);
+	snprintf(text,79,"%02"LU":%02"LU":%02"LU".%02"LU,hh,mm,ss,ms);
 	gtk_label_set_text(GTK_LABEL(glade.getWidget("labelMarkB")),text);
     //gtk_markscale_setA(guiSlider, a);
     //gtk_markscale_setB(guiSlider, b);

Modified: branches/avidemux_2.6_branch_mean/avidemux/ADM_userInterfaces/ADM_QT4/ADM_gui/Q_gui2.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_userInterfaces/ADM_QT4/ADM_gui/Q_gui2.cpp	2009-03-01 10:30:58 UTC (rev 4642)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_userInterfaces/ADM_QT4/ADM_gui/Q_gui2.cpp	2009-03-01 10:31:01 UTC (rev 4643)
@@ -959,15 +959,19 @@
 void UI_setMarkers(uint64_t a, uint64_t b)
 {
 	char text[80];
-    uint16_t hh,mm,ss,ms,timems;
-    timems=(uint32_t)(a/1000);
+    uint16_t hh,mm,ss,ms;
+    uint32_t timems;
+    a/=1000;
+    b/=1000;
+
+    timems=(uint32_t)(a);
     ms2time(timems,&hh,&mm,&ss,&ms);
-	snprintf(text,79,"%02"LU":%02"LU":%02"LU".%02"LU"ms",hh,mm,ss,ms);
+	snprintf(text,79,"%02"LU":%02"LU":%02"LU".%02"LU,hh,mm,ss,ms);
 	WIDGET(pushButtonJumpToMarkerA)->setText(text);
 
-	timems=(uint32_t)(b/1000);
+	timems=(uint32_t)(b);
     ms2time(timems,&hh,&mm,&ss,&ms);
-	snprintf(text,79,"%02"LU":%02"LU":%02"LU".%02"LU"ms",hh,mm,ss,ms);
+	snprintf(text,79,"%02"LU":%02"LU":%02"LU".%02"LU,hh,mm,ss,ms);
 	WIDGET(pushButtonJumpToMarkerB)->setText(text);
 
 	//slider->setMarkers(a, b);

Modified: branches/avidemux_2.6_branch_mean/avidemux/gtk_gui.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/gtk_gui.cpp	2009-03-01 10:30:58 UTC (rev 4642)
+++ branches/avidemux_2.6_branch_mean/avidemux/gtk_gui.cpp	2009-03-01 10:31:01 UTC (rev 4643)
@@ -1,9 +1,8 @@
 /***************************************************************************
-                          gtk_gui.cpp  -  description
-                             -------------------
-    begin                : Mon Dec 10 2001
-    copyright            : (C) 2001 by mean
-    email                : fixounet at free.fr
+                          \file gtk_gui.cpp  
+                          \brief Main UI even loop
+                             
+    copyright            : (C) 2001-2009 by mean, fixounet at free.fr
  ***************************************************************************/
 
 /***************************************************************************
@@ -14,15 +13,12 @@
  *   (at your option) any later version.                                   *
  *                                                                         *
  ***************************************************************************/
-#include <errno.h>
+
 #include "config.h"
 #include "ADM_default.h"
 #include <math.h>
+#include <errno.h>
 
-//#include <time.h>
-//#include <sys/time.h>
-
-
 #include "ADM_lavcodec.h"
 #include "fourcc.h"
 #include "avi_vars.h"
@@ -847,6 +843,7 @@
 }
 /**
     \fn updateLoaded
+    \brief update the UI after loading a file
 
 */
 void  updateLoaded ()

Modified: branches/avidemux_2.6_branch_mean/avidemux/gui_navigate.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/gui_navigate.cpp	2009-03-01 10:30:58 UTC (rev 4642)
+++ branches/avidemux_2.6_branch_mean/avidemux/gui_navigate.cpp	2009-03-01 10:31:01 UTC (rev 4643)
@@ -63,27 +63,27 @@
       case ACT_GotoMarkA:
       case ACT_GotoMarkB:
             {
-                uint32_t nf;
-                  if (action == ACT_GotoMarkA)
-                      nf = frameStart;
-                  else
-                      nf = frameEnd;
-                  GUI_GoToFrame(nf);
+                uint64_t pts;
+                if(action==ACT_GotoMarkA) pts=video_body->getMarkerAPts();
+                        else  pts=video_body->getMarkerBPts();
+                 uint32_t frame=video_body->searchFrameBefore(pts);
+                  GUI_GoToFrame(frame);
+                 
             }
-	  break;
+            break;
       case ACT_Goto:
-	  uint32_t fn;
-	  fn = video_body->getCurrentFrame();
-	  if (DIA_GetIntegerValue
-	      ((int *) &fn, 0, avifileinfo->nb_frames,
-	       QT_TR_NOOP("Go to Frame"), QT_TR_NOOP("_Go to frame:")))
-	    {
-		if (fn < avifileinfo->nb_frames)
-		    GUI_GoToFrame(fn);
-		else
-		    GUI_Error_HIG(QT_TR_NOOP("Out of bounds"), NULL);
-	    }
-	  break;
+          uint32_t fn;
+          fn = video_body->getCurrentFrame();
+          if (DIA_GetIntegerValue
+              ((int *) &fn, 0, avifileinfo->nb_frames,
+               QT_TR_NOOP("Go to Frame"), QT_TR_NOOP("_Go to frame:")))
+            {
+            if (fn < avifileinfo->nb_frames)
+                GUI_GoToFrame(fn);
+            else
+                GUI_Error_HIG(QT_TR_NOOP("Out of bounds"), NULL);
+            }
+          break;
       case ACT_Back25Frames:
           if (video_body->getCurrentFrame() >= 25)
           {



From mean at mail.berlios.de  Sun Mar  1 20:04:00 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sun, 1 Mar 2009 20:04:00 +0100
Subject: [Avidemux-svn-commit] r4644 -
	branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_mp4
Message-ID: <200903011904.n21J40Ql012706@sheep.berlios.de>

Author: mean
Date: 2009-03-01 20:04:00 +0100 (Sun, 01 Mar 2009)
New Revision: 4644

Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_mp4/ADM_mp4Analyzer.cpp
Log:
[Mov] Correctly detect MSADPCM in mov

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_mp4/ADM_mp4Analyzer.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_mp4/ADM_mp4Analyzer.cpp	2009-03-01 10:31:01 UTC (rev 4643)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_mp4/ADM_mp4Analyzer.cpp	2009-03-01 19:04:00 UTC (rev 4644)
@@ -841,10 +841,20 @@
                                               left=0;
                                         }
                                         break;
+                                    
+                                    {
+                                            audioCodec(MSADPCM);
+                                            break;
+                                    }
+                                
                                     case MKFCCR('m','s',0,0x55): // why 55 ???
+                                    case MKFCCR('m','s',0,0x11): // why 11 ???
                                     case MKFCCR('m','p','4','a'):
                                     {
-                                              audioCodec(AAC);
+                                              if(entryName==MKFCCR('m','s',0,0x11))
+                                                        audioCodec(MSADPCM)
+                                                else
+                                                        audioCodec(AAC);
                                             if(left>10)
                                             {
                                               adm_atom wave(&son);
@@ -870,6 +880,7 @@
                                                           }
                                                           break;
                                                        case MKFCCR('m','s',0,0x55):
+                                                       case MKFCCR('m','s',0,0x11):
                                                         {
                                                           // We have a waveformat here
                                                           printf("[STSD]Found MS audio header:\n");



From mean at mail.berlios.de  Sun Mar  1 20:15:33 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sun, 1 Mar 2009 20:15:33 +0100
Subject: [Avidemux-svn-commit] r4645 -
	branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_mp4
Message-ID: <200903011915.n21JFXMW013941@sheep.berlios.de>

Author: mean
Date: 2009-03-01 20:15:33 +0100 (Sun, 01 Mar 2009)
New Revision: 4645

Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_mp4/ADM_mp4Analyzer.cpp
Log:
[Mov] Oops

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_mp4/ADM_mp4Analyzer.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_mp4/ADM_mp4Analyzer.cpp	2009-03-01 19:04:00 UTC (rev 4644)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_inputs/ADM_mp4/ADM_mp4Analyzer.cpp	2009-03-01 19:15:33 UTC (rev 4645)
@@ -842,11 +842,6 @@
                                         }
                                         break;
                                     
-                                    {
-                                            audioCodec(MSADPCM);
-                                            break;
-                                    }
-                                
                                     case MKFCCR('m','s',0,0x55): // why 55 ???
                                     case MKFCCR('m','s',0,0x11): // why 11 ???
                                     case MKFCCR('m','p','4','a'):



From gruntster at mail.berlios.de  Mon Mar  2 12:04:27 2009
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Mon, 2 Mar 2009 12:04:27 +0100
Subject: [Avidemux-svn-commit] r4646 -
	branches/avidemux_2.5_branch_gruntster/cmake
Message-ID: <200903021104.n22B4Rx6031568@sheep.berlios.de>

Author: gruntster
Date: 2009-03-02 12:04:16 +0100 (Mon, 02 Mar 2009)
New Revision: 4646

Modified:
   branches/avidemux_2.5_branch_gruntster/cmake/admConfigHelper.cmake
   branches/avidemux_2.5_branch_gruntster/cmake/config.h.cmake
Log:
[cmake] add more output to verbose mode

Modified: branches/avidemux_2.5_branch_gruntster/cmake/admConfigHelper.cmake
===================================================================
--- branches/avidemux_2.5_branch_gruntster/cmake/admConfigHelper.cmake	2009-03-01 19:15:33 UTC (rev 4645)
+++ branches/avidemux_2.5_branch_gruntster/cmake/admConfigHelper.cmake	2009-03-02 11:04:16 UTC (rev 4646)
@@ -117,11 +117,21 @@
 
 			IF (VERBOSE)
 				MESSAGE(STATUS "(${_cflags}) required")
+				MESSAGE("")
+				MESSAGE(STATUS "Output with flag:")
+				MESSAGE(STATUS "${logwith}")
+				MESSAGE(STATUS "Output without flag:")
+				MESSAGE(STATUS "${logwithout}")
 			ENDIF (VERBOSE)
 		ELSE (${_varToSet}_COMPILE_WITH AND NOT ${_varToSet}_COMPILE_WITHOUT)
 			IF (NOT ${_varToSet}_COMPILE_WITH AND ${_varToSet}_COMPILE_WITHOUT)
 				IF (VERBOSE)
 					MESSAGE (STATUS "(${_cflags}) not required")
+					MESSAGE("")
+					MESSAGE(STATUS "Output with flag:")
+					MESSAGE(STATUS "${logwith}")
+					MESSAGE(STATUS "Output without flag:")
+					MESSAGE(STATUS "${logwithout}")
 				ENDIF (VERBOSE)
 			ELSE (NOT ${_varToSet}_COMPILE_WITH AND ${_varToSet}_COMPILE_WITHOUT)
 				MESSAGE(STATUS "Inconsistent compiler output with: ${${_varToSet}_COMPILE_WITH}, without: ${${_varToSet}_COMPILE_WITHOUT}")

Modified: branches/avidemux_2.5_branch_gruntster/cmake/config.h.cmake
===================================================================
--- branches/avidemux_2.5_branch_gruntster/cmake/config.h.cmake	2009-03-01 19:15:33 UTC (rev 4645)
+++ branches/avidemux_2.5_branch_gruntster/cmake/config.h.cmake	2009-03-02 11:04:16 UTC (rev 4646)
@@ -29,9 +29,6 @@
 /* Define to 1 if you have the `mp3lame' library (-lmp3lame). */
 #cmakedefine HAVE_LIBMP3LAME
 
-/* stricter prototyping */
-#cmakedefine ICONV_NEED_CONST
-
 /* OSS detected */
 #cmakedefine OSS_SUPPORT
 



From gruntster at mail.berlios.de  Mon Mar  2 14:49:20 2009
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Mon, 2 Mar 2009 14:49:20 +0100
Subject: [Avidemux-svn-commit] r4647 -
	branches/avidemux_2.5_branch_gruntster/cmake
Message-ID: <200903021349.n22DnKQB028622@sheep.berlios.de>

Author: gruntster
Date: 2009-03-02 14:49:13 +0100 (Mon, 02 Mar 2009)
New Revision: 4647

Modified:
   branches/avidemux_2.5_branch_gruntster/cmake/admFFmpegBuild.cmake
   branches/avidemux_2.5_branch_gruntster/cmake/admFFmpegMake.cmake
Log:
[cmake] pass extra c and ld flags to ffmpeg configure

Modified: branches/avidemux_2.5_branch_gruntster/cmake/admFFmpegBuild.cmake
===================================================================
--- branches/avidemux_2.5_branch_gruntster/cmake/admFFmpegBuild.cmake	2009-03-02 11:04:16 UTC (rev 4646)
+++ branches/avidemux_2.5_branch_gruntster/cmake/admFFmpegBuild.cmake	2009-03-02 13:49:13 UTC (rev 4647)
@@ -143,6 +143,14 @@
 	set(FFMPEG_FLAGS ${FFMPEG_FLAGS} --disable-debug)
 endif (NOT ADM_DEBUG)
 
+if (CMAKE_C_FLAGS)
+	set(FFMPEG_FLAGS ${FFMPEG_FLAGS} --extra-cflags=${CMAKE_C_FLAGS})
+endif (CMAKE_C_FLAGS)
+
+if (CMAKE_LINKER_FLAGS)
+	set(FFMPEG_FLAGS ${FFMPEG_FLAGS} --extra-ldflags=${CMAKE_LINKER_FLAGS})
+endif (CMAKE_LINKER_FLAGS)
+
 if (NOT "${LAST_FFMPEG_FLAGS}" STREQUAL "${FFMPEG_FLAGS}")
 	set(FFMPEG_PERFORM_BUILD 1)
 endif (NOT "${LAST_FFMPEG_FLAGS}" STREQUAL "${FFMPEG_FLAGS}")
@@ -167,7 +175,7 @@
 
 # Build FFmpeg
 add_custom_command(OUTPUT "${FFMPEG_BINARY_DIR}/ffmpeg${CMAKE_EXECUTABLE_SUFFIX}"
-				   COMMAND ${CMAKE_COMMAND}  -DCMAKE_SHARED_LIBRARY_SUFFIX=${CMAKE_SHARED_LIBRARY_SUFFIX} -P "${CMAKE_SOURCE_DIR}/cmake/admFFmpegMake.cmake"
+				   COMMAND ${CMAKE_COMMAND} -DCMAKE_BUILD_TOOL=${CMAKE_BUILD_TOOL} -P "${CMAKE_SOURCE_DIR}/cmake/admFFmpegMake.cmake"
 				   WORKING_DIRECTORY "${FFMPEG_BINARY_DIR}")
 
 add_custom_target(ffmpeg ALL

Modified: branches/avidemux_2.5_branch_gruntster/cmake/admFFmpegMake.cmake
===================================================================
--- branches/avidemux_2.5_branch_gruntster/cmake/admFFmpegMake.cmake	2009-03-02 11:04:16 UTC (rev 4646)
+++ branches/avidemux_2.5_branch_gruntster/cmake/admFFmpegMake.cmake	2009-03-02 13:49:13 UTC (rev 4647)
@@ -1 +1 @@
-execute_process(COMMAND make)
\ No newline at end of file
+execute_process(COMMAND ${CMAKE_BUILD_TOOL})
\ No newline at end of file



From gruntster at mail.berlios.de  Mon Mar  2 21:22:03 2009
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Mon, 2 Mar 2009 21:22:03 +0100
Subject: [Avidemux-svn-commit] r4648 -
	branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_gui
Message-ID: <200903022022.n22KM3T8028316@sheep.berlios.de>

Author: gruntster
Date: 2009-03-02 21:21:54 +0100 (Mon, 02 Mar 2009)
New Revision: 4648

Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_gui/gui2.ui
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_gui/translation_table.h
Log:
[qt] add plugins menu option to Qt main window

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_gui/gui2.ui
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_gui/gui2.ui	2009-03-02 13:49:13 UTC (rev 4647)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_gui/gui2.ui	2009-03-02 20:21:54 UTC (rev 4648)
@@ -1304,13 +1304,6 @@
      <height>22</height>
     </rect>
    </property>
-   <widget class="QMenu" name="menuHelp" >
-    <property name="title" >
-     <string>&amp;Help</string>
-    </property>
-    <addaction name="actionShow_built_in_support" />
-    <addaction name="actionAbout_avidemux" />
-   </widget>
    <widget class="QMenu" name="menuVideo" >
     <property name="title" >
      <string>Vi&amp;deo</string>
@@ -1464,6 +1457,15 @@
     <addaction name="separator" />
     <addaction name="actionQuit" />
    </widget>
+   <widget class="QMenu" name="menuHelp" >
+    <property name="title" >
+     <string>&amp;Help</string>
+    </property>
+    <addaction name="actionShow_built_in_support" />
+    <addaction name="action_Plugins" />
+    <addaction name="separator" />
+    <addaction name="actionAbout_avidemux" />
+   </widget>
    <addaction name="menuFile" />
    <addaction name="menuEdit" />
    <addaction name="menuView" />
@@ -2368,6 +2370,11 @@
     <string>&amp;AVI Muxer Options...</string>
    </property>
   </action>
+  <action name="action_Plugins" >
+   <property name="text" >
+    <string>&amp;Plugins...</string>
+   </property>
+  </action>
  </widget>
  <customwidgets>
   <customwidget>

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_gui/translation_table.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_gui/translation_table.h	2009-03-02 13:49:13 UTC (rev 4647)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_gui/translation_table.h	2009-03-02 20:21:54 UTC (rev 4648)
@@ -56,6 +56,7 @@
 PROCESS(actionJump_to_Frame,ACT_Goto) \
 PROCESS(actionJump_to_Time,ACT_GotoTime) \
 PROCESS(actionShow_built_in_support,ACT_BUILT_IN) \
+PROCESS(action_Plugins, ACT_PLUGIN_INFO) \
 PROCESS(actionAbout_avidemux,ACT_About) \
 PROCESS(actionPlay,ACT_PlayAvi) \
 PROCESS(actionRecent0,ACT_RECENT0) \



From gruntster at mail.berlios.de  Tue Mar  3 12:10:15 2009
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Tue, 3 Mar 2009 12:10:15 +0100
Subject: [Avidemux-svn-commit] r4649 -
	branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_filters
Message-ID: <200903031110.n23BAF8t023942@sheep.berlios.de>

Author: gruntster
Date: 2009-03-03 12:10:10 +0100 (Tue, 03 Mar 2009)
New Revision: 4649

Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_filters/Q_mainfilter.cpp
Log:
[qt] prevent crash when clicking external filters

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_filters/Q_mainfilter.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_filters/Q_mainfilter.cpp	2009-03-02 20:21:54 UTC (rev 4648)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_filters/Q_mainfilter.cpp	2009-03-03 11:10:10 UTC (rev 4649)
@@ -437,10 +437,10 @@
 
 void filtermainWindow::displayFamily(uint32_t family)
 {
+  availableList->clear();
   printf("Family :%u\n",family);
-  ADM_assert(family<VF_MAX);
+  if (family >= VF_MAX) return;
   std::vector <FilterDescriptor *> vec=filterCategories[family];
-  availableList->clear();
   QSize sz;
   
   for (uint32_t i = 0; i < vec.size(); i++)



From gruntster at mail.berlios.de  Tue Mar  3 19:16:09 2009
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Tue, 3 Mar 2009 19:16:09 +0100
Subject: [Avidemux-svn-commit] r4650 -
	branches/avidemux_2.5_branch_gruntster/po
Message-ID: <200903031816.n23IG9IA016818@sheep.berlios.de>

Author: gruntster
Date: 2009-03-03 19:16:04 +0100 (Tue, 03 Mar 2009)
New Revision: 4650

Modified:
   branches/avidemux_2.5_branch_gruntster/po/qt_filter_context.xslt
Log:
[i18n] remove duplicate messages from ts files during build since Qt 4.5 doesn't like it

Modified: branches/avidemux_2.5_branch_gruntster/po/qt_filter_context.xslt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/po/qt_filter_context.xslt	2009-03-03 11:10:10 UTC (rev 4649)
+++ branches/avidemux_2.5_branch_gruntster/po/qt_filter_context.xslt	2009-03-03 18:16:04 UTC (rev 4650)
@@ -9,7 +9,7 @@
 		<TS>
 			<xsl:copy-of select="@*" />
 
-			<xsl:for-each select="context/message">
+			<xsl:for-each select="context/message[not(source = preceding::message/source)]">
 				<xsl:variable name="location" select="location/@filename" />
 
 				<context>



From gruntster at mail.berlios.de  Tue Mar  3 20:34:38 2009
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Tue, 3 Mar 2009 20:34:38 +0100
Subject: [Avidemux-svn-commit] r4651 -
	branches/avidemux_2.5_branch_gruntster/cmake
Message-ID: <200903031934.n23JYc3k030082@sheep.berlios.de>

Author: gruntster
Date: 2009-03-03 20:34:33 +0100 (Tue, 03 Mar 2009)
New Revision: 4651

Modified:
   branches/avidemux_2.5_branch_gruntster/cmake/admFFmpegBuild.cmake
Log:
[ffmpeg] add CMake option to instruct ffmpeg's configure to perform a cross compilation

Modified: branches/avidemux_2.5_branch_gruntster/cmake/admFFmpegBuild.cmake
===================================================================
--- branches/avidemux_2.5_branch_gruntster/cmake/admFFmpegBuild.cmake	2009-03-03 18:16:04 UTC (rev 4650)
+++ branches/avidemux_2.5_branch_gruntster/cmake/admFFmpegBuild.cmake	2009-03-03 19:34:33 UTC (rev 4651)
@@ -151,6 +151,11 @@
 	set(FFMPEG_FLAGS ${FFMPEG_FLAGS} --extra-ldflags=${CMAKE_LINKER_FLAGS})
 endif (CMAKE_LINKER_FLAGS)
 
+if (CROSS_COMPILE)
+	set(CROSS_COMPILE "${CROSS_COMPILE}" CACHE STRING "")
+	set(FFMPEG_FLAGS ${FFMPEG_FLAGS} --enable-cross-compile)
+endif (CROSS_COMPILE)
+
 if (NOT "${LAST_FFMPEG_FLAGS}" STREQUAL "${FFMPEG_FLAGS}")
 	set(FFMPEG_PERFORM_BUILD 1)
 endif (NOT "${LAST_FFMPEG_FLAGS}" STREQUAL "${FFMPEG_FLAGS}")



From gruntster at mail.berlios.de  Tue Mar  3 22:18:07 2009
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Tue, 3 Mar 2009 22:18:07 +0100
Subject: [Avidemux-svn-commit] r4652 -
	branches/avidemux_2.5_branch_gruntster/cmake
Message-ID: <200903032118.n23LI7me015283@sheep.berlios.de>

Author: gruntster
Date: 2009-03-03 22:18:00 +0100 (Tue, 03 Mar 2009)
New Revision: 4652

Modified:
   branches/avidemux_2.5_branch_gruntster/cmake/admFFmpegBuild.cmake
Log:
[cmake] correct linker flag variable

Modified: branches/avidemux_2.5_branch_gruntster/cmake/admFFmpegBuild.cmake
===================================================================
--- branches/avidemux_2.5_branch_gruntster/cmake/admFFmpegBuild.cmake	2009-03-03 19:34:33 UTC (rev 4651)
+++ branches/avidemux_2.5_branch_gruntster/cmake/admFFmpegBuild.cmake	2009-03-03 21:18:00 UTC (rev 4652)
@@ -147,9 +147,9 @@
 	set(FFMPEG_FLAGS ${FFMPEG_FLAGS} --extra-cflags=${CMAKE_C_FLAGS})
 endif (CMAKE_C_FLAGS)
 
-if (CMAKE_LINKER_FLAGS)
-	set(FFMPEG_FLAGS ${FFMPEG_FLAGS} --extra-ldflags=${CMAKE_LINKER_FLAGS})
-endif (CMAKE_LINKER_FLAGS)
+if (CMAKE_SHARED_LINKER_FLAGS)
+	set(FFMPEG_FLAGS ${FFMPEG_FLAGS} --extra-ldflags=${CMAKE_SHARED_LINKER_FLAGS})
+endif (CMAKE_SHARED_LINKER_FLAGS)
 
 if (CROSS_COMPILE)
 	set(CROSS_COMPILE "${CROSS_COMPILE}" CACHE STRING "")



From gruntster at mail.berlios.de  Wed Mar  4 10:18:26 2009
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Wed, 4 Mar 2009 10:18:26 +0100
Subject: [Avidemux-svn-commit] r4653 - in
	branches/avidemux_2.5_branch_gruntster: avidemux/ADM_encoder
	avidemux/ADM_plugin plugins/ADM_videoEncoder/ADM_vidEnc_x264
	plugins/ADM_videoEncoder/ADM_vidEnc_xvid
Message-ID: <200903040918.n249IQlf012668@sheep.berlios.de>

Author: gruntster
Date: 2009-03-04 10:18:19 +0100 (Wed, 04 Mar 2009)
New Revision: 4653

Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_encoder/ADM_externalEncoder.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_encoder/ADM_externalEncoder.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_encoder/adm_encConfig.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_plugin/ADM_vidEnc_plugin.h
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/encoder.cpp
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/encoder.h
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_xvid/encoder.cpp
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_xvid/encoder.h
Log:
[videnc] tweak video encoder plugin api to make things cleaner

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_encoder/ADM_externalEncoder.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_encoder/ADM_externalEncoder.cpp	2009-03-03 21:18:00 UTC (rev 4652)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_encoder/ADM_externalEncoder.cpp	2009-03-04 09:18:19 UTC (rev 4653)
@@ -24,6 +24,7 @@
 {
 	_plugin = getVideoEncoderPlugin(params->extra_param);
 	_openPass = false;
+	_useExistingLogFile = false;
 	_logFileName = NULL;
 	_globalHeader = globalHeader;
 }
@@ -48,6 +49,7 @@
 	ADM_assert(_vbuffer);
 
 	_in = instream;
+	_useExistingLogFile = useExistingLogFile;
 
 	vidEncVideoProperties properties;
 
@@ -59,9 +61,8 @@
 	properties.parWidth = instream->getPARWidth();
 	properties.parHeight = instream->getPARHeight();
 	properties.frameCount = info->nb_frames;
-	properties.fps1000 = info->fps1000;
-	properties.logFileName = _logFileName;
-	properties.useExistingLogFile = useExistingLogFile;
+	properties.fpsNum = info->fps1000;
+	properties.fpsDen = 1000;
 
 	if (_globalHeader)
 		properties.flags |= ADM_VIDENC_FLAG_GLOBAL_HEADER;
@@ -167,6 +168,8 @@
 
 	memset(&passParameters, 0, sizeof(vidEncPassParameters));
 	passParameters.structSize = sizeof(vidEncPassParameters);
+	passParameters.logFileName = _logFileName;
+	passParameters.useExistingLogFile = _useExistingLogFile;
 
 	_openPass = (_plugin->beginPass(_plugin->encoderId, &passParameters) == ADM_VIDENC_ERR_SUCCESS);
 

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_encoder/ADM_externalEncoder.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_encoder/ADM_externalEncoder.h	2009-03-03 21:18:00 UTC (rev 4652)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_encoder/ADM_externalEncoder.h	2009-03-04 09:18:19 UTC (rev 4653)
@@ -28,6 +28,7 @@
 private:
 	ADM_vidEnc_plugin *_plugin;
 	bool _openPass;
+	bool _useExistingLogFile;
 	char* _logFileName;
 	bool _globalHeader;
 	uint8_t *_extraData;

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_encoder/adm_encConfig.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_encoder/adm_encConfig.cpp	2009-03-03 21:18:00 UTC (rev 4652)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_encoder/adm_encConfig.cpp	2009-03-04 09:18:19 UTC (rev 4653)
@@ -486,7 +486,8 @@
 			properties.parWidth = video_body->getPARWidth();
 			properties.parHeight = video_body->getPARHeight();
 			properties.frameCount = info.nb_frames;
-			properties.fps1000 = info.fps1000;
+			properties.fpsNum = info.fps1000;
+			properties.fpsDen = 1000;
 		}
 
 		configParameters.structSize = sizeof(vidEncConfigParameters);

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_plugin/ADM_vidEnc_plugin.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_plugin/ADM_vidEnc_plugin.h	2009-03-03 21:18:00 UTC (rev 4652)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_plugin/ADM_vidEnc_plugin.h	2009-03-04 09:18:19 UTC (rev 4653)
@@ -65,9 +65,8 @@
 	unsigned int parWidth;
 	unsigned int parHeight;
 	unsigned int frameCount;
-	unsigned int fps1000;
-	const char* logFileName;
-	int useExistingLogFile;
+	unsigned int fpsNum;
+	unsigned int fpsDen;
 	unsigned int flags;
 } vidEncVideoProperties;
 
@@ -83,6 +82,8 @@
 	int structSize;
 	uint8_t *extraData;
 	int extraDataSize;
+	const char* logFileName;
+	int useExistingLogFile;
 } vidEncPassParameters;
 
 typedef struct

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/encoder.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/encoder.cpp	2009-03-03 21:18:00 UTC (rev 4652)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/encoder.cpp	2009-03-04 09:18:19 UTC (rev 4653)
@@ -55,9 +55,7 @@
 	_currentPass = 0;
 	_openPass = false;
 
-	_logFileName = NULL;
 	_buffer = NULL;
-
 	_extraData = NULL;
 	_extraDataSize = 0;
 
@@ -78,9 +76,6 @@
 	if (_loader)
 		delete _loader;
 
-	if (_logFileName)
-		delete [] _logFileName;
-
 	if (_buffer)
 		delete [] _buffer;
 
@@ -189,24 +184,12 @@
 	_buffer = new uint8_t[_bufferSize];
 
 	memcpy(&_properties, properties, sizeof(vidEncVideoProperties));
-	_properties.logFileName = NULL;
-
-	if (_logFileName)
-		delete [] _logFileName;
-
-#ifdef __WIN32
-	convertPathToAnsi(properties->logFileName, &_logFileName);
-#else
-	_logFileName = new char[strlen(properties->logFileName) + 1];
-	strcpy(_logFileName, properties->logFileName);
-#endif
-
 	updateEncodeParameters(&_properties);
 
 	_param.i_width = _properties.width;
 	_param.i_height = _properties.height;
-	_param.i_fps_num = _properties.fps1000;
-	_param.i_fps_den = 1000;
+	_param.i_fps_num = _properties.fpsNum;
+	_param.i_fps_den = _properties.fpsDen;
 
 	if (_options.getSarAsInput())
 	{
@@ -219,9 +202,6 @@
 	else
 		_param.b_repeat_headers = 1;
 
-	if (_passCount > 1 && properties->useExistingLogFile)
-		_currentPass++;
-
 	printParam(&_param);
 
 	return ADM_VIDENC_ERR_SUCCESS;
@@ -242,25 +222,37 @@
 	_currentPass++;
 	_currentFrame = 0;
 
+	char *logFileName = NULL;
+
 	printf("[x264] begin pass %d/%d\n", _currentPass, _passCount);
 
 	if (_passCount > 1)
 	{
+#ifdef __WIN32
+		convertPathToAnsi(passParameters->logFileName, &logFileName);
+#else
+		logFileName = new char[strlen(passParameters->logFileName) + 1];
+		strcpy(logFileName, passParameters->logFileName);
+#endif
+
+		if (passParameters->useExistingLogFile)
+			_currentPass++;
+
 		if (_currentPass == 1)
 		{
 			_param.rc.b_stat_write = 1;
 			_param.rc.b_stat_read = 0;
-			_param.rc.psz_stat_out = _logFileName;
+			_param.rc.psz_stat_out = logFileName;
 
-			printf("[x264] writing to %s\n", _logFileName);
+			printf("[x264] writing to %s\n", logFileName);
 		}
 		else
 		{
 			_param.rc.b_stat_write = 0;
 			_param.rc.b_stat_read = 1;
-			_param.rc.psz_stat_in = _logFileName;
+			_param.rc.psz_stat_in = logFileName;
 
-			printf("[x264] reading from %s\n", _logFileName);
+			printf("[x264] reading from %s\n", logFileName);
 		}
 	}
 	else
@@ -271,6 +263,9 @@
 
 	_handle = x264_encoder_open(&_param);
 
+	if (logFileName)
+		delete logFileName;
+
 	if (_handle)
 	{
 		if (!_param.b_repeat_headers)
@@ -537,6 +532,8 @@
 		finishPass();
 
 	_opened = false;
+	_passCount = 0;
+	_currentPass = 0;
 
 	if (_buffer)
 	{
@@ -683,7 +680,7 @@
 		case ADM_VIDENC_MODE_2PASS_SIZE:
 			_passCount = 2;
 			_param.rc.i_rc_method = X264_RC_ABR;
-			_param.rc.i_bitrate = calculateBitrate(properties->fps1000, properties->frameCount, _encodeOptions.encodeModeParameter) / 1000;
+			_param.rc.i_bitrate = calculateBitrate(properties->fpsNum, properties->fpsDen, properties->frameCount, _encodeOptions.encodeModeParameter) / 1000;
 			break;
 		case ADM_VIDENC_MODE_2PASS_ABR:
 			_passCount = 2;
@@ -693,7 +690,7 @@
 	}
 }
 
-unsigned int x264Encoder::calculateBitrate(unsigned int fps1000, unsigned int frameCount, unsigned int sizeInMb)
+unsigned int x264Encoder::calculateBitrate(unsigned int fpsNum, unsigned int fpsDen, unsigned int frameCount, unsigned int sizeInMb)
 {
 	double db, ti;
 
@@ -703,8 +700,8 @@
 
 	// compute duration
 	ti = frameCount;
-	ti *= 1000;
-	ti /= fps1000;	// nb sec
+	ti *= fpsDen;
+	ti /= fpsNum;	// nb sec
 	db = db / ti;
 
 	return (unsigned int)floor(db);

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/encoder.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/encoder.h	2009-03-03 21:18:00 UTC (rev 4652)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/encoder.h	2009-03-04 09:18:19 UTC (rev 4653)
@@ -41,7 +41,6 @@
 		x264Options _options;
 		vidEncOptions _encodeOptions;
 		vidEncVideoProperties _properties;
-		char *_logFileName;
 
 		x264_t *_handle;
 		x264_param_t _param;
@@ -62,7 +61,7 @@
 		void printParam(x264_param_t* x264Param);
 		void printCqm(const uint8_t cqm[], int size);
 		void updateEncodeParameters(vidEncVideoProperties *properties);
-		unsigned int calculateBitrate(unsigned int fps1000, unsigned int frameCount, unsigned int sizeInMb);
+		unsigned int calculateBitrate(unsigned int fpsNum, unsigned int fpsDen, unsigned int frameCount, unsigned int sizeInMb);
 		int createHeader(void);
 
 	public:

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_xvid/encoder.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_xvid/encoder.cpp	2009-03-03 21:18:00 UTC (rev 4652)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_xvid/encoder.cpp	2009-03-04 09:18:19 UTC (rev 4653)
@@ -212,18 +212,7 @@
 	_buffer = new uint8_t[_bufferSize];
 
 	memcpy(&_properties, properties, sizeof(vidEncVideoProperties));
-	_properties.logFileName = NULL;
 
-	if (_logFileName)
-		delete [] _logFileName;
-
-#ifdef __WIN32
-	convertPathToAnsi(properties->logFileName, &_logFileName);
-#else
-	_logFileName = new char[strlen(properties->logFileName) + 1];
-	strcpy(_logFileName, properties->logFileName);
-#endif
-
 	if (_options.getParAsInput())
 		_options.setPar(_properties.parWidth, _properties.parHeight);
 
@@ -231,8 +220,8 @@
 
 	_xvid_enc_create.width = _properties.width;
 	_xvid_enc_create.height = _properties.height;
-	_xvid_enc_create.fincr = 1000;
-	_xvid_enc_create.fbase = _properties.fps1000;
+	_xvid_enc_create.fincr = _properties.fpsDen;
+	_xvid_enc_create.fbase = _properties.fpsNum;
 
 	if (_options.getThreads() == 0)
 		_xvid_enc_create.num_threads = _processors;
@@ -259,6 +248,19 @@
 
 	if (_passCount > 1)
 	{
+		if (_logFileName)
+			delete [] _logFileName;
+
+#ifdef __WIN32
+		convertPathToAnsi(passParameters->logFileName, &_logFileName);
+#else
+		_logFileName = new char[strlen(passParameters->logFileName) + 1];
+		strcpy(_logFileName, passParameters->logFileName);
+#endif
+
+		if (passParameters->useExistingLogFile)
+			_currentPass++;
+
 		if (_currentPass == 1)
 		{
 			_xvid_plugin_2pass1.filename = _logFileName;
@@ -374,6 +376,8 @@
 		finishPass();
 
 	_opened = false;
+	_passCount = 0;
+	_currentPass = 0;
 
 	if (_xvid_enc_create.handle)
 	{
@@ -440,7 +444,7 @@
 			break;
 		case ADM_VIDENC_MODE_2PASS_SIZE:
 			_passCount = 2;
-			_xvid_plugin_2pass2.bitrate = calculateBitrate(properties->fps1000, properties->frameCount, _encodeOptions.encodeModeParameter);
+			_xvid_plugin_2pass2.bitrate = calculateBitrate(properties->fpsNum, properties->fpsDen, properties->frameCount, _encodeOptions.encodeModeParameter);
 
 			break;
 		case ADM_VIDENC_MODE_2PASS_ABR:
@@ -451,7 +455,7 @@
 	}
 }
 
-unsigned int XvidEncoder::calculateBitrate(unsigned int fps1000, unsigned int frameCount, unsigned int sizeInMb)
+unsigned int XvidEncoder::calculateBitrate(unsigned int fpsNum, unsigned int fpsDen, unsigned int frameCount, unsigned int sizeInMb)
 {
 	double db, ti;
 
@@ -461,8 +465,8 @@
 
 	// compute duration
 	ti = frameCount;
-	ti *= 1000;
-	ti /= fps1000;	// nb sec
+	ti *= fpsDen;
+	ti /= fpsNum;	// nb sec
 	db = db / ti;
 
 	return (unsigned int)floor(db);

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_xvid/encoder.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_xvid/encoder.h	2009-03-03 21:18:00 UTC (rev 4652)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_xvid/encoder.h	2009-03-04 09:18:19 UTC (rev 4653)
@@ -56,7 +56,7 @@
 		bool _opened, _openPass;
 
 		void updateEncodeParameters(vidEncVideoProperties *properties);
-		unsigned int calculateBitrate(unsigned int fps1000, unsigned int frameCount, unsigned int sizeInMb);
+		unsigned int calculateBitrate(unsigned int fpsNum, unsigned int fpsDen, unsigned int frameCount, unsigned int sizeInMb);
 
 		void printEncCreate(xvid_enc_create_t *xvid_enc_create);
 		void printEncFrame(xvid_enc_frame_t *xvid_enc_frame);



From gruntster at mail.berlios.de  Wed Mar  4 20:22:29 2009
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Wed, 4 Mar 2009 20:22:29 +0100
Subject: [Avidemux-svn-commit] r4654 - in
	branches/avidemux_2.5_branch_gruntster/platforms/windows:
	build_scripts/avidemux installer
Message-ID: <200903041922.n24JMTlD032534@sheep.berlios.de>

Author: gruntster
Date: 2009-03-04 20:22:23 +0100 (Wed, 04 Mar 2009)
New Revision: 4654

Modified:
   branches/avidemux_2.5_branch_gruntster/platforms/windows/build_scripts/avidemux/1. Perform Build.bat
   branches/avidemux_2.5_branch_gruntster/platforms/windows/build_scripts/avidemux/1b. Continue Build.bat
   branches/avidemux_2.5_branch_gruntster/platforms/windows/build_scripts/avidemux/Package Notes.xml
   branches/avidemux_2.5_branch_gruntster/platforms/windows/installer/avidemux.nsi
Log:
[win32] enable shared libgcc and libstdc++ to reduce size and memory usage

Modified: branches/avidemux_2.5_branch_gruntster/platforms/windows/build_scripts/avidemux/1. Perform Build.bat
===================================================================
--- branches/avidemux_2.5_branch_gruntster/platforms/windows/build_scripts/avidemux/1. Perform Build.bat	2009-03-04 09:18:19 UTC (rev 4653)
+++ branches/avidemux_2.5_branch_gruntster/platforms/windows/build_scripts/avidemux/1. Perform Build.bat	2009-03-04 19:22:23 UTC (rev 4654)
@@ -30,9 +30,9 @@
 :removalFailure
 echo ERROR - build directories could not be fully deleted.
 echo Aborting.
-pause
 
 :error
 set ERRORLEVEL=1
 
 :end
+pause
\ No newline at end of file

Modified: branches/avidemux_2.5_branch_gruntster/platforms/windows/build_scripts/avidemux/1b. Continue Build.bat
===================================================================
--- branches/avidemux_2.5_branch_gruntster/platforms/windows/build_scripts/avidemux/1b. Continue Build.bat	2009-03-04 09:18:19 UTC (rev 4653)
+++ branches/avidemux_2.5_branch_gruntster/platforms/windows/build_scripts/avidemux/1b. Continue Build.bat	2009-03-04 19:22:23 UTC (rev 4654)
@@ -4,14 +4,14 @@
 if errorlevel 1 goto error
 
 cd "%sourceDir%\build"
-cmake -G"MSYS Makefiles" -DCMAKE_INSTALL_PREFIX="%buildDir%" ..
+cmake -G"MSYS Makefiles" -DCMAKE_INSTALL_PREFIX="%buildDir%" -DCMAKE_EXE_LINKER_FLAGS="-shared-libgcc" -DCMAKE_SHARED_LINKER_FLAGS="-shared-libgcc" ..
 
 if errorlevel 1 goto error
 pause
 
 set msysSourceDir=%sourceDir:\=/%
 cd "%sourceDir%\plugins\build"
-cmake -G"MSYS Makefiles" -DCMAKE_INSTALL_PREFIX="%buildDir%" -DAVIDEMUX_CORECONFIG_DIR="%msysSourceDir%/build/config" -DAVIDEMUX_INSTALL_PREFIX="%buildDir%" -DAVIDEMUX_SOURCE_DIR="%msysSourceDir%" ..
+cmake -G"MSYS Makefiles" -DCMAKE_INSTALL_PREFIX="%buildDir%" -DAVIDEMUX_CORECONFIG_DIR="%msysSourceDir%/build/config" -DAVIDEMUX_INSTALL_PREFIX="%buildDir%" -DAVIDEMUX_SOURCE_DIR="%msysSourceDir%" -DCMAKE_EXE_LINKER_FLAGS="-shared-libgcc" -DCMAKE_SHARED_LINKER_FLAGS="-shared-libgcc" ..
 
 if errorlevel 1 goto error
 pause

Modified: branches/avidemux_2.5_branch_gruntster/platforms/windows/build_scripts/avidemux/Package Notes.xml
===================================================================
--- branches/avidemux_2.5_branch_gruntster/platforms/windows/build_scripts/avidemux/Package Notes.xml	2009-03-04 09:18:19 UTC (rev 4653)
+++ branches/avidemux_2.5_branch_gruntster/platforms/windows/build_scripts/avidemux/Package Notes.xml	2009-03-04 19:22:23 UTC (rev 4654)
@@ -1,6 +1,17 @@
 <?xml version="1.0"?>
 <log>
-  <buildentry revision="" date="">
-    <comment></comment>
+  <buildentry revision="4648" date="2009-03-02">
+    <comment>Updated x264 to r1115.</comment>
   </buildentry>
+  <buildentry revision="4629" date="2009-02-24">
+  </buildentry>
+  <buildentry revision="4618" date="2009-02-21">
+    <comment>Updated x264 to r1114.</comment>
+  </buildentry>
+  <buildentry revision="4609" date="2009-02-16">
+    <comment>Packaged using NSIS 2.43.</comment>
+    <comment>Updated Avisynth Proxy GUI to version 2.07 (2nd release).</comment>
+    <comment>Updated Libxml2 to version 2.7.3.</comment>
+    <comment>Updated x264 to r1113.</comment>
+  </buildentry>
 </log>

Modified: branches/avidemux_2.5_branch_gruntster/platforms/windows/installer/avidemux.nsi
===================================================================
--- branches/avidemux_2.5_branch_gruntster/platforms/windows/installer/avidemux.nsi	2009-03-04 09:18:19 UTC (rev 4653)
+++ branches/avidemux_2.5_branch_gruntster/platforms/windows/installer/avidemux.nsi	2009-03-04 19:22:23 UTC (rev 4654)
@@ -287,6 +287,8 @@
     ${File} avutil-*.dll
     ${File} postproc-*.dll
     ${File} swscale-*.dll
+    ${File} libgcc_sjlj_*.dll
+    ${File} libstdc++_sjlj_*.dll
     SetOutPath $INSTDIR\etc\fonts
     ${Folder} etc\fonts
 SectionEnd



From gruntster at mail.berlios.de  Wed Mar  4 22:41:25 2009
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Wed, 4 Mar 2009 22:41:25 +0100
Subject: [Avidemux-svn-commit] r4655 -
	branches/avidemux_2.5_branch_gruntster/cmake/patches
Message-ID: <200903042141.n24LfPBt015712@sheep.berlios.de>

Author: gruntster
Date: 2009-03-04 22:41:17 +0100 (Wed, 04 Mar 2009)
New Revision: 4655

Added:
   branches/avidemux_2.5_branch_gruntster/cmake/patches/libswscale_swscale_internal.h.patch
Modified:
   branches/avidemux_2.5_branch_gruntster/cmake/patches/createPatches.sh
Log:
[swscale] increase maximum width to 4096

Modified: branches/avidemux_2.5_branch_gruntster/cmake/patches/createPatches.sh
===================================================================
--- branches/avidemux_2.5_branch_gruntster/cmake/patches/createPatches.sh	2009-03-04 19:22:23 UTC (rev 4654)
+++ branches/avidemux_2.5_branch_gruntster/cmake/patches/createPatches.sh	2009-03-04 21:41:17 UTC (rev 4655)
@@ -32,4 +32,5 @@
 updatePatch libavformat movenc.c
 updatePatch libavutil avutil.h
 updatePatch libavutil internal.h
-updatePatch libavutil mem.c
\ No newline at end of file
+updatePatch libavutil mem.c
+updatePatch libswscale swscale_internal.h
\ No newline at end of file

Added: branches/avidemux_2.5_branch_gruntster/cmake/patches/libswscale_swscale_internal.h.patch
===================================================================
--- branches/avidemux_2.5_branch_gruntster/cmake/patches/libswscale_swscale_internal.h.patch	2009-03-04 19:22:23 UTC (rev 4654)
+++ branches/avidemux_2.5_branch_gruntster/cmake/patches/libswscale_swscale_internal.h.patch	2009-03-04 21:41:17 UTC (rev 4655)
@@ -0,0 +1,19 @@
+*** libswscale/swscale_internal.h.old	Wed Mar  4 20:10:31 2009
+--- libswscale/swscale_internal.h	Wed Mar  4 20:10:30 2009
+***************
+*** 33,39 ****
+  
+  #define MAX_FILTER_SIZE 256
+  
+! #define VOFW 2048
+  #define VOF  (VOFW*2)
+  
+  #ifdef WORDS_BIGENDIAN
+--- 33,39 ----
+  
+  #define MAX_FILTER_SIZE 256
+  
+! #define VOFW 4096
+  #define VOF  (VOFW*2)
+  
+  #ifdef WORDS_BIGENDIAN



From gruntster at mail.berlios.de  Wed Mar  4 23:49:48 2009
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Wed, 4 Mar 2009 23:49:48 +0100
Subject: [Avidemux-svn-commit] r4656 - in
	branches/avidemux_2.5_branch_gruntster: avidemux/ADM_encoder
	avidemux/ADM_plugin plugins/ADM_videoEncoder/ADM_vidEnc_x264
	plugins/ADM_videoEncoder/ADM_vidEnc_xvid
Message-ID: <200903042249.n24MnmIW022275@sheep.berlios.de>

Author: gruntster
Date: 2009-03-04 23:49:41 +0100 (Wed, 04 Mar 2009)
New Revision: 4656

Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_encoder/ADM_externalEncoder.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_plugin/ADM_vidEnc_plugin.h
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/encoder.cpp
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_xvid/encoder.cpp
Log:
[videnc] fix 2nd pass encoding

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_encoder/ADM_externalEncoder.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_encoder/ADM_externalEncoder.cpp	2009-03-04 21:41:17 UTC (rev 4655)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_encoder/ADM_externalEncoder.cpp	2009-03-04 22:49:41 UTC (rev 4656)
@@ -165,14 +165,27 @@
 uint8_t externalEncoder::startPass(void)
 {
 	vidEncPassParameters passParameters;
+	int ret;
 
 	memset(&passParameters, 0, sizeof(vidEncPassParameters));
 	passParameters.structSize = sizeof(vidEncPassParameters);
 	passParameters.logFileName = _logFileName;
 	passParameters.useExistingLogFile = _useExistingLogFile;
 
-	_openPass = (_plugin->beginPass(_plugin->encoderId, &passParameters) == ADM_VIDENC_ERR_SUCCESS);
+	ret = _plugin->beginPass(_plugin->encoderId, &passParameters);
 
+	if (ret == ADM_VIDENC_ERR_PASS_SKIP)
+	{
+		printf("[externalEncoder] skipping pass\n");
+
+		return 1;
+	}
+
+	if (ret != ADM_VIDENC_ERR_SUCCESS)
+		printf("[externalEncoder] begin pass failed: %d\n", ret);
+
+	_openPass = (ret == ADM_VIDENC_ERR_SUCCESS);
+
 	if (_openPass && _globalHeader)
 	{
 		_extraData = passParameters.extraData;

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_plugin/ADM_vidEnc_plugin.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_plugin/ADM_vidEnc_plugin.h	2009-03-04 21:41:17 UTC (rev 4655)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_plugin/ADM_vidEnc_plugin.h	2009-03-04 22:49:41 UTC (rev 4656)
@@ -24,9 +24,10 @@
 #define ADM_VIDENC_ERR_CLOSED -1
 #define ADM_VIDENC_ERR_ALREADY_OPEN -2
 #define ADM_VIDENC_ERR_INVALID_ENCODER_ID -3
-#define ADM_VIDENC_ERR_PASS_CLOSED -4
-#define ADM_VIDENC_ERR_PASS_ALREADY_OPEN -5
-#define ADM_VIDENC_ERR_PASS_COUNT_REACHED -6
+#define ADM_VIDENC_ERR_PASS_SKIP -4
+#define ADM_VIDENC_ERR_PASS_CLOSED -5
+#define ADM_VIDENC_ERR_PASS_ALREADY_OPEN -6
+#define ADM_VIDENC_ERR_PASS_COUNT_REACHED -7
 
 #define ADM_VIDENC_MODE_CBR 1
 #define ADM_VIDENC_MODE_CQP 2

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/encoder.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/encoder.cpp	2009-03-04 21:41:17 UTC (rev 4655)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/encoder.cpp	2009-03-04 22:49:41 UTC (rev 4656)
@@ -121,7 +121,12 @@
 	}
 
 	if (_loader->isAvailable())
-		return _loader->showX264ConfigDialog(configParameters, properties, &_encodeOptions, &_options);
+		if (_loader->showX264ConfigDialog(configParameters, properties, &_encodeOptions, &_options))
+		{
+			updateEncodeParameters(NULL);
+
+			return 1;
+		}
 	else
 		return 0;
 }
@@ -155,7 +160,10 @@
 		success = _options.fromXml(pluginOptions);
 
 	if (encodeOptions && success)
+	{
 		memcpy(&_encodeOptions, encodeOptions, sizeof(vidEncOptions));
+		updateEncodeParameters(NULL);
+	}
 
 	if (success)
 		return ADM_VIDENC_ERR_SUCCESS;
@@ -218,6 +226,12 @@
 	if (_currentPass == _passCount)
 		return ADM_VIDENC_ERR_PASS_COUNT_REACHED;
 
+	if (_passCount > 1 && _currentPass == 0 && passParameters->useExistingLogFile)
+	{
+		_currentPass++;
+		return ADM_VIDENC_ERR_PASS_SKIP;
+	}
+
 	_openPass = true;
 	_currentPass++;
 	_currentFrame = 0;
@@ -235,9 +249,6 @@
 		strcpy(logFileName, passParameters->logFileName);
 #endif
 
-		if (passParameters->useExistingLogFile)
-			_currentPass++;
-
 		if (_currentPass == 1)
 		{
 			_param.rc.b_stat_write = 1;
@@ -532,7 +543,6 @@
 		finishPass();
 
 	_opened = false;
-	_passCount = 0;
 	_currentPass = 0;
 
 	if (_buffer)
@@ -680,7 +690,12 @@
 		case ADM_VIDENC_MODE_2PASS_SIZE:
 			_passCount = 2;
 			_param.rc.i_rc_method = X264_RC_ABR;
-			_param.rc.i_bitrate = calculateBitrate(properties->fpsNum, properties->fpsDen, properties->frameCount, _encodeOptions.encodeModeParameter) / 1000;
+
+			if (properties)
+				_param.rc.i_bitrate = calculateBitrate(properties->fpsNum, properties->fpsDen, properties->frameCount, _encodeOptions.encodeModeParameter) / 1000;
+			else
+				_param.rc.i_bitrate = 1500;
+
 			break;
 		case ADM_VIDENC_MODE_2PASS_ABR:
 			_passCount = 2;

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_xvid/encoder.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_xvid/encoder.cpp	2009-03-04 21:41:17 UTC (rev 4655)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_xvid/encoder.cpp	2009-03-04 22:49:41 UTC (rev 4656)
@@ -149,7 +149,12 @@
 	}
 
 	if (_loader->isAvailable())
-		return _loader->showXvidConfigDialog(configParameters, properties, &_encodeOptions, &_options);
+		if (_loader->showXvidConfigDialog(configParameters, properties, &_encodeOptions, &_options))
+		{
+			updateEncodeParameters(NULL);
+
+			return 1;
+		}
 	else
 		return 0;
 }
@@ -183,7 +188,10 @@
 		success = _options.fromXml(pluginOptions);
 
 	if (encodeOptions && success)
+	{
 		memcpy(&_encodeOptions, encodeOptions, sizeof(vidEncOptions));
+		updateEncodeParameters(NULL);
+	}
 
 	if (success)
 		return ADM_VIDENC_ERR_SUCCESS;
@@ -240,6 +248,12 @@
 	if (_currentPass == _passCount)
 		return ADM_VIDENC_ERR_PASS_COUNT_REACHED;
 
+	if (_passCount > 1 && _currentPass == 0 && passParameters->useExistingLogFile)
+	{
+		_currentPass++;
+		return ADM_VIDENC_ERR_PASS_SKIP;
+	}
+
 	_openPass = true;
 	_currentPass++;
 	_currentFrame = 0;
@@ -258,9 +272,6 @@
 		strcpy(_logFileName, passParameters->logFileName);
 #endif
 
-		if (passParameters->useExistingLogFile)
-			_currentPass++;
-
 		if (_currentPass == 1)
 		{
 			_xvid_plugin_2pass1.filename = _logFileName;
@@ -376,7 +387,6 @@
 		finishPass();
 
 	_opened = false;
-	_passCount = 0;
 	_currentPass = 0;
 
 	if (_xvid_enc_create.handle)
@@ -444,8 +454,12 @@
 			break;
 		case ADM_VIDENC_MODE_2PASS_SIZE:
 			_passCount = 2;
-			_xvid_plugin_2pass2.bitrate = calculateBitrate(properties->fpsNum, properties->fpsDen, properties->frameCount, _encodeOptions.encodeModeParameter);
 
+			if (properties)
+				_xvid_plugin_2pass2.bitrate = calculateBitrate(properties->fpsNum, properties->fpsDen, properties->frameCount, _encodeOptions.encodeModeParameter);
+			else
+				_xvid_plugin_2pass2.bitrate = 1500;
+
 			break;
 		case ADM_VIDENC_MODE_2PASS_ABR:
 			_passCount = 2;



From gruntster at mail.berlios.de  Thu Mar  5 00:14:26 2009
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Thu, 5 Mar 2009 00:14:26 +0100
Subject: [Avidemux-svn-commit] r4657 -
	branches/avidemux_2.5_branch_gruntster/cmake
Message-ID: <200903042314.n24NEQPt024840@sheep.berlios.de>

Author: gruntster
Date: 2009-03-05 00:14:20 +0100 (Thu, 05 Mar 2009)
New Revision: 4657

Modified:
   branches/avidemux_2.5_branch_gruntster/cmake/admFFmpegBuild.cmake
Log:
[ffmpeg] change cross compilation flag to set architecture

Modified: branches/avidemux_2.5_branch_gruntster/cmake/admFFmpegBuild.cmake
===================================================================
--- branches/avidemux_2.5_branch_gruntster/cmake/admFFmpegBuild.cmake	2009-03-04 22:49:41 UTC (rev 4656)
+++ branches/avidemux_2.5_branch_gruntster/cmake/admFFmpegBuild.cmake	2009-03-04 23:14:20 UTC (rev 4657)
@@ -151,10 +151,10 @@
 	set(FFMPEG_FLAGS ${FFMPEG_FLAGS} --extra-ldflags=${CMAKE_SHARED_LINKER_FLAGS})
 endif (CMAKE_SHARED_LINKER_FLAGS)
 
-if (CROSS_COMPILE)
-	set(CROSS_COMPILE "${CROSS_COMPILE}" CACHE STRING "")
-	set(FFMPEG_FLAGS ${FFMPEG_FLAGS} --enable-cross-compile)
-endif (CROSS_COMPILE)
+if (XPLATFORM)
+	set(XPLATFORM "${XPLATFORM}" CACHE STRING "")
+	set(FFMPEG_FLAGS ${FFMPEG_FLAGS} --enable-cross-compile --arch=${XPLATFORM})
+endif (XPLATFORM)
 
 if (NOT "${LAST_FFMPEG_FLAGS}" STREQUAL "${FFMPEG_FLAGS}")
 	set(FFMPEG_PERFORM_BUILD 1)



From gruntster at mail.berlios.de  Thu Mar  5 00:25:25 2009
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Thu, 5 Mar 2009 00:25:25 +0100
Subject: [Avidemux-svn-commit] r4658 -
	branches/avidemux_2.5_branch_gruntster/avidemux/ADM_core/src
Message-ID: <200903042325.n24NPPAq027051@sheep.berlios.de>

Author: gruntster
Date: 2009-03-05 00:25:19 +0100 (Thu, 05 Mar 2009)
New Revision: 4658

Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_core/src/ADM_memcpy.cpp
Log:
[core] remove unnecessary kludge now ffmpeg is fixed

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_core/src/ADM_memcpy.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_core/src/ADM_memcpy.cpp	2009-03-04 23:14:20 UTC (rev 4657)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_core/src/ADM_memcpy.cpp	2009-03-04 23:25:19 UTC (rev 4658)
@@ -38,12 +38,6 @@
 
 extern "C"
 {
-	#define HAVE_MMX
-	#define AV_WN16
-	#define AV_WN32
-	#define AV_RN16
-	#define AV_RN32
-	#include "libavcodec/dsputil.h"
 	#include "libavcodec/avcodec.h"
 
 adm_fast_memcpy myAdmMemcpy=NULL;



From gruntster at mail.berlios.de  Thu Mar  5 21:27:53 2009
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Thu, 5 Mar 2009 21:27:53 +0100
Subject: [Avidemux-svn-commit] r4659 -
	branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script
Message-ID: <200903052027.n25KRr2I007431@sheep.berlios.de>

Author: gruntster
Date: 2009-03-05 21:27:43 +0100 (Thu, 05 Mar 2009)
New Revision: 4659

Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSAvidemuxVideo.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSAvidemuxVideo.h
Log:
[script] clean up naming of methods & props for video object

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSAvidemuxVideo.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSAvidemuxVideo.cpp	2009-03-04 23:25:19 UTC (rev 4658)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSAvidemuxVideo.cpp	2009-03-05 20:27:43 UTC (rev 4659)
@@ -39,7 +39,15 @@
 
 JSPropertySpec ADM_JSAvidemuxVideo::avidemuxvideo_properties[] = 
 { 
-        { "process", videoprocess_prop, JSPROP_ENUMERATE },        // process video when saving
+	{ "process", videoProcessProperty, JSPROP_ENUMERATE },        // process video when saving
+	{ "width", widthProperty, JSPROP_ENUMERATE },
+	{ "height", heightProperty, JSPROP_ENUMERATE },
+	{ "frameCount", frameCountProperty, JSPROP_ENUMERATE },
+	{ "vopPacked", vopPackedProperty, JSPROP_ENUMERATE },
+	{ "qPel", qPelProperty, JSPROP_ENUMERATE },
+	{ "gmc", gmcProperty, JSPROP_ENUMERATE },
+	{ "fcc", fccProperty, JSPROP_ENUMERATE },
+	{ "fps1000", fps1000Property, JSPROP_ENUMERATE },
 	{ 0 }
 };
 
@@ -47,26 +55,17 @@
 {
 	{ "clear", Clear, 0, 0, 0 },	// clear
 	{ "add", Add, 3, 0, 0 },	// add
-        { "clearFilters", ClearFilters, 0, 0, 0 }, // Delete all filters
+	{ "clearFilters", ClearFilters, 0, 0, 0 }, // Delete all filters
 	{ "addFilter", AddFilter, 10, 0, 0 },	// Add filter to filter chain
 	{ "codec", Codec, 3, 0, 0 },	// Set the video codec
-	{ "codecPlugin", codecPlugin, 4, 0, 0 },	// Set the video codec plugin
+	{ "codecPlugin", CodecPlugin, 4, 0, 0 },	// Set the video codec plugin
 	{ "codecConf", CodecConf, 1, 0, 0 },	// load video codec config
 	{ "save", Save, 1, 0, 0 },	// save video portion of the stream
 	{ "saveJpeg", SaveJPEG, 1, 0, 0 },	// save the current frame as a JPEG
 	{ "listBlackFrames", ListBlackFrames, 1, 0, 0 },	// output a list of the black frame to a file
 	{ "setPostProc", PostProcess, 3, 0, 0 },	// Postprocess
-        { "setFps1000", SetFps1000, 1, 0, 0 },        // Postprocess
-        { "getFps1000", GetFps1000, 0, 0, 0 },        // Postprocess
-        { "getNbFrames", GetNbFrames, 0, 0, 0 },        // Postprocess
-        { "getWidth", GetWidth, 0, 0, 0 },        // Postprocess
-        { "getHeight", GetHeight, 0, 0, 0 },        // Postprocess
-        { "getFCC", GetFCC, 0, 0, 0 },        // Postprocess
-        { "isVopPacked", isVopPacked, 0, 0, 0 },        // Postprocess
-        { "hasQpel", hasQpel, 0, 0, 0 },        // Postprocess
-        { "hasGmc", hasGmc, 0, 0, 0 },        // Postprocess
-        { "frameSize", getFrameSize, 1, 0, 0 },        // FrameSize
-        { "frameType", getFrameType, 1, 0, 0 },        // Postprocess
+	{ "getFrameSize", getFrameSize, 1, 0, 0 },        // FrameSize
+	{ "getFrameType", getFrameType, 1, 0, 0 },        // Postprocess
 	{ 0 }
 };
 
@@ -129,35 +128,112 @@
 
 JSBool ADM_JSAvidemuxVideo::JSGetProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp)
 {
-        if (JSVAL_IS_INT(id)) 
-        {
-                ADM_JSAvidemuxVideo *priv = (ADM_JSAvidemuxVideo *) JS_GetPrivate(cx, obj);
-                switch(JSVAL_TO_INT(id))
-                {
-                        case videoprocess_prop:
-                                *vp = BOOLEAN_TO_JSVAL(priv->getObject()->m_bVideoProcess);
-                                break;
-                }
-        }
-        return JS_TRUE;
+	if (JSVAL_IS_INT(id)) 
+	{
+		ADM_JSAvidemuxVideo *priv = (ADM_JSAvidemuxVideo *) JS_GetPrivate(cx, obj);
+		switch(JSVAL_TO_INT(id))
+		{
+			case videoProcessProperty:
+				*vp = BOOLEAN_TO_JSVAL(priv->getObject()->m_bVideoProcess);
+				break;
+			case widthProperty:
+			{
+				aviInfo info;
+
+				video_body->getVideoInfo(&info);
+				*vp = INT_TO_JSVAL(info.width);
+				break;
+			}
+			case heightProperty:
+			{
+				aviInfo info;
+
+				video_body->getVideoInfo(&info);
+				*vp = INT_TO_JSVAL(info.height);
+				break;
+			}
+			case frameCountProperty:
+			{
+				aviInfo info;
+
+				video_body->getVideoInfo(&info);
+				*vp = INT_TO_JSVAL(info.nb_frames);
+				break;
+			}
+			case vopPackedProperty:
+			{
+				*vp = ((video_body->getSpecificMpeg4Info() & ADM_VOP_ON) == ADM_VOP_ON);
+				break;
+			}
+			case qPelProperty:
+			{
+				*vp = ((video_body->getSpecificMpeg4Info() & ADM_QPEL_ON) == ADM_QPEL_ON);
+				break;
+			}
+			case gmcProperty:
+			{
+				*vp = ((video_body->getSpecificMpeg4Info() & ADM_GMC_ON) == ADM_GMC_ON);
+				break;
+			}
+			case fccProperty:
+			{
+				aviInfo info;
+
+				video_body->getVideoInfo(&info);
+				*vp = STRING_TO_JSVAL(JS_NewStringCopyZ(cx, fourCC::tostring(info.fcc)));
+				break;
+			}
+			case fps1000Property:
+			{
+				aviInfo info;
+
+				video_body->getVideoInfo(&info);
+				*vp = INT_TO_JSVAL(info.fps1000);
+				break;
+			}
+		}
+	}
+	return JS_TRUE;
 }
 
 JSBool ADM_JSAvidemuxVideo::JSSetProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp)
 {
-        if (JSVAL_IS_INT(id)) 
-        {
-                ADM_JSAvidemuxVideo *priv = (ADM_JSAvidemuxVideo *) JS_GetPrivate(cx, obj);
-                switch(JSVAL_TO_INT(id))
-                {
-                        case videoprocess_prop:
-                                if(JSVAL_IS_BOOLEAN(*vp) == false)
-                                        break;
-                                priv->getObject()->m_bVideoProcess = JSVAL_TO_BOOLEAN(*vp);
-                                UI_setVProcessToggleStatus(priv->getObject()->m_bVideoProcess);
-                                break;
-                }
-        }
-        return JS_TRUE;
+	if (JSVAL_IS_INT(id)) 
+	{
+		ADM_JSAvidemuxVideo *priv = (ADM_JSAvidemuxVideo *) JS_GetPrivate(cx, obj);
+		switch(JSVAL_TO_INT(id))
+		{
+			case videoProcessProperty:
+				if (!JSVAL_IS_BOOLEAN(*vp))
+					break;
+
+				priv->getObject()->m_bVideoProcess = JSVAL_TO_BOOLEAN(*vp);
+				UI_setVProcessToggleStatus(priv->getObject()->m_bVideoProcess);
+				break;
+			case fps1000Property:
+			{
+				if(!JSVAL_IS_INT(*vp))
+					break;
+
+				aviInfo info;
+				int fps = JSVAL_TO_INT(*vp);
+
+				if(fps > 100000 || fps < 2000)
+				{
+					printf("FPS too low\n");
+					break;
+				}
+
+				video_body->getVideoInfo(&info);
+				info.fps1000 = fps;
+				video_body->updateVideoInfo(&info);
+
+				break;
+			}
+		}
+	}
+
+	return JS_TRUE;
 }
 
 JSBool ADM_JSAvidemuxVideo::Clear(JSContext *cx, JSObject *obj, uintN argc, 
@@ -283,7 +359,7 @@
         return JS_TRUE;
 }// end Codec
 
-JSBool ADM_JSAvidemuxVideo::codecPlugin(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
+JSBool ADM_JSAvidemuxVideo::CodecPlugin(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
 {
 	*rval = BOOLEAN_TO_JSVAL(false);
 
@@ -409,166 +485,9 @@
         return JS_TRUE;
 }// end PostProcess
 
-JSBool ADM_JSAvidemuxVideo::GetFps1000(JSContext *cx, JSObject *obj, uintN argc, 
-                                       jsval *argv, jsval *rval)
-{// begin PostProcess
-aviInfo info;
-        if(argc != 0)
-          return JS_FALSE;
-        
-        enterLock();
-        video_body->getVideoInfo(&info);
-        leaveLock();
-        
-        *rval = INT_TO_JSVAL(info.fps1000);
-        return JS_TRUE;
-}// end PostProcess
-JSBool ADM_JSAvidemuxVideo::GetNbFrames(JSContext *cx, JSObject *obj, uintN argc, 
-                                       jsval *argv, jsval *rval)
-{// begin PostProcess
-aviInfo info;
-        if(argc != 0)
-          return JS_FALSE;
-        
-        enterLock();
-        video_body->getVideoInfo(&info);
-        leaveLock();
-        
-        *rval = INT_TO_JSVAL(info.nb_frames);
-        return JS_TRUE;
-}// end PostProcess
-
-JSBool ADM_JSAvidemuxVideo::SetFps1000(JSContext *cx, JSObject *obj, uintN argc, 
-                                       jsval *argv, jsval *rval)
-{// begin PostProcess
-int fps;
-aviInfo info;
-
-        if(argc != 1)
-          return JS_FALSE;
-        if(JSVAL_IS_INT(argv[0]) == false)
-          return JS_FALSE;
-
-        enterLock();
-        video_body->getVideoInfo(&info);
-        video_body->getVideoInfo (avifileinfo);
-
-
-        // default return value
-        fps=JSVAL_TO_INT(argv[0]);
-        if(fps>100000 || fps<2000)
-        {      
-                printf("Fps too low\n");
-                leaveLock();
-                return JS_FALSE;
-        }       
- 	
-       info.fps1000=fps;
-        video_body->updateVideoInfo(&info);
-        video_body->getVideoInfo (avifileinfo);
-        
-	leaveLock();
-        return JS_TRUE;
-}// end PostProcess
-
-
-JSBool ADM_JSAvidemuxVideo::GetWidth(JSContext *cx, JSObject *obj, uintN argc, 
-                                       jsval *argv, jsval *rval)
-{// begin PostProcess
-aviInfo info;
-        if(argc != 0)
-          return JS_FALSE;
-
-
-        enterLock();
-        video_body->getVideoInfo(&info);
-        leaveLock();
-        
-        *rval = INT_TO_JSVAL(info.width);
-        return JS_TRUE;
-}// end PostProcess
-JSBool ADM_JSAvidemuxVideo::GetHeight(JSContext *cx, JSObject *obj, uintN argc, 
-                                       jsval *argv, jsval *rval)
-{// begin PostProcess
-aviInfo info;
-        if(argc != 0)
-          return JS_FALSE;
-
-        enterLock();
-        video_body->getVideoInfo(&info);
-        leaveLock();
-        
-        *rval = INT_TO_JSVAL(info.height);
-        return JS_TRUE;
-}// end PostProcess
-JSBool ADM_JSAvidemuxVideo::GetFCC(JSContext *cx, JSObject *obj, uintN argc, 
-                                       jsval *argv, jsval *rval)
-{// begin PostProcess
-aviInfo info;
-
-        if(argc != 0)
-          return JS_FALSE;
-
-        enterLock();
-        video_body->getVideoInfo(&info);
-        leaveLock();
-        
-        *rval = STRING_TO_JSVAL(JS_NewStringCopyZ(cx, fourCC::tostring(info.fcc)));
-        return JS_TRUE;
-}// end PostProcess
-
-JSBool ADM_JSAvidemuxVideo::isVopPacked(JSContext *cx, JSObject *obj, uintN argc, 
-                                       jsval *argv, jsval *rval)
-{// begin PostProcess
-int32_t info;
-        if(argc != 0)
-          return JS_FALSE;
-
-      enterLock();
-       info=video_body->getSpecificMpeg4Info();
-       leaveLock();
-         
-        // default return value
-        *rval=JS_FALSE;
-        if(info & ADM_VOP_ON) *rval=JS_TRUE;
-        return JS_TRUE;
-}// end PostProcess
-JSBool ADM_JSAvidemuxVideo::hasGmc(JSContext *cx, JSObject *obj, uintN argc, 
-                                       jsval *argv, jsval *rval)
-{// begin PostProcess
-uint32_t info;
-        if(argc != 0)
-          return JS_FALSE;
-
-       enterLock();
-       info=video_body->getSpecificMpeg4Info();
-       leaveLock(); 
-        
-        // default return value
-        *rval=JS_FALSE;
-        if(info & ADM_GMC_ON) *rval=JS_TRUE;
-        return JS_TRUE;
-}// end PostProcess
-JSBool ADM_JSAvidemuxVideo::hasQpel(JSContext *cx, JSObject *obj, uintN argc, 
-                                       jsval *argv, jsval *rval)
-{// begin PostProcess
-uint32_t info;
-        if(argc != 0)
-          return JS_FALSE;
-        
-        enterLock();
-        info=video_body->getSpecificMpeg4Info();
-        leaveLock(); 
-        
-        *rval=JS_FALSE;
-        if(info & ADM_QPEL_ON) *rval=JS_TRUE;
-        return JS_TRUE;
-}// end PostProcess
-
-
 JSBool ADM_JSAvidemuxVideo::getFrameSize(JSContext *cx, JSObject *obj, uintN argc, 
                                        jsval *argv, jsval *rval)
-{// begin PostProcess
+{
 uint32_t info;
 uint32_t frame;
 uint32_t sz;
@@ -582,10 +501,11 @@
         
         *rval=INT_TO_JSVAL(sz);
         return JS_TRUE;
-}// end PostProcess
+}
+
 JSBool ADM_JSAvidemuxVideo::getFrameType(JSContext *cx, JSObject *obj, uintN argc, 
                                        jsval *argv, jsval *rval)
-{// begin PostProcess
+{
 uint32_t info;
 uint32_t frame;
 uint32_t sz;
@@ -599,5 +519,5 @@
         
         *rval=INT_TO_JSVAL(sz);
         return JS_TRUE;
-}// end PostProcess
+}
 /* EOF */

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSAvidemuxVideo.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSAvidemuxVideo.h	2009-03-04 23:25:19 UTC (rev 4658)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSAvidemuxVideo.h	2009-03-05 20:27:43 UTC (rev 4659)
@@ -25,34 +25,31 @@
 	static JSBool AddFilter(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval);
 	static JSBool IndexMPEG(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval);
 	static JSBool Codec(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval);
-	static JSBool codecPlugin(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval);
+	static JSBool CodecPlugin(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval);
 	static JSBool CodecConf(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval);
 	static JSBool Save(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval);
 	static JSBool SaveJPEG(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval);
 	static JSBool ListBlackFrames(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval);
 	static JSBool PostProcess(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval);
 	static JSBool RebuildIBFrames(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval);
-
-	static JSBool SetFps1000(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval);
-	static JSBool GetFps1000(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval);
-        static JSBool GetNbFrames(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval);
-	static JSBool GetWidth(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval);
-	static JSBool GetHeight(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval);
-	static JSBool GetFCC(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval);
-
-	static JSBool isVopPacked(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval);
-	static JSBool hasGmc(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval);
-	static JSBool hasQpel(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval);
-        static JSBool getFrameSize(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval);
+	static JSBool getFrameSize(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval);
 	static JSBool getFrameType(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval);
 
-
 	static JSPropertySpec avidemuxvideo_properties[];
 	static JSFunctionSpec avidemuxvideo_methods[];
 	enum
 	{
-                videoprocess_prop,
+		videoProcessProperty,
+		widthProperty,
+		heightProperty,
+		frameCountProperty,
+		vopPackedProperty,
+		qPelProperty,
+		gmcProperty,
+		fccProperty,
+		fps1000Property
 	};
+
 	static JSClass m_classAvidemuxVideo;
 
 //protected:



From gruntster at mail.berlios.de  Fri Mar  6 17:44:49 2009
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Fri, 6 Mar 2009 17:44:49 +0100
Subject: [Avidemux-svn-commit] r4660 -
	branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script
Message-ID: <200903061644.n26Gin9G018426@sheep.berlios.de>

Author: gruntster
Date: 2009-03-06 17:44:41 +0100 (Fri, 06 Mar 2009)
New Revision: 4660

Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_Avidemux.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSAvidemuxAudio.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSAvidemuxAudio.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSAvidemuxVideo.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSAvidemuxVideo.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSFunctions.cpp
Log:
[script] clean up video and audio classes and remove constructors

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_Avidemux.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_Avidemux.cpp	2009-03-05 20:27:43 UTC (rev 4659)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_Avidemux.cpp	2009-03-06 16:44:41 UTC (rev 4660)
@@ -10,25 +10,13 @@
 #define JSDECLARE
 #include "ADM_Avidemux.h"
 
-ADM_Avidemux::ADM_Avidemux(void) :  m_pAudio(NULL), m_pVideo(NULL), m_pContainer(NULL), m_nCurrentFrame(0), m_dFPS(0)
-{// begin ADM_Avidemux
+ADM_Avidemux::ADM_Avidemux(void) : m_pContainer(NULL), m_nCurrentFrame(0), m_dFPS(0)
+{
+	m_pAudio = ADM_JSAvidemuxAudio::JSInit(g_pCx, g_pObject);
+	m_pVideo = ADM_JSAvidemuxVideo::JSInit(g_pCx, g_pObject);
+}
 
-	// initialize audio property
-	JSObject *pTempObject = ADM_JSAvidemuxAudio::JSInit(g_pCx,g_pObject);
-	ADM_JSAvidemuxAudio *pAudio = new ADM_JSAvidemuxAudio();
-	pAudio->setObject(new ADM_AvidemuxAudio());
-	JS_SetPrivate(g_pCx,pTempObject,pAudio);
-	m_pAudio = pTempObject;
-
-	// initialize video property
-	pTempObject = ADM_JSAvidemuxVideo::JSInit(g_pCx,g_pObject);
-	ADM_JSAvidemuxVideo *pVideo = new ADM_JSAvidemuxVideo();
-	pVideo->setObject(new ADM_AvidemuxVideo());
-	JS_SetPrivate(g_pCx,pTempObject,pVideo);
-	m_pVideo = pTempObject;
-}// end ADM_Avidemux
-
 ADM_Avidemux::~ADM_Avidemux()
-{// begin ~ADM_Avidemux
+{
 
-}// end ~ADM_Avidemux
+}

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSAvidemuxAudio.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSAvidemuxAudio.cpp	2009-03-05 20:27:43 UTC (rev 4659)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSAvidemuxAudio.cpp	2009-03-06 16:44:41 UTC (rev 4660)
@@ -20,15 +20,7 @@
 #include "avi_vars.h"
 #include "gui_action.hxx"
 #include "ADM_encoder/ADM_vidEncode.hxx"
-#include "ADM_videoFilter.h"
-#include "ADM_encoder/adm_encoder.h"
-#include "ADM_encoder/adm_encConfig.h"
-#include "ADM_editor/ADM_outputfmt.h"
 
-
-
-#include "ADM_script/ADM_container.h"
-
 extern int A_audioSave(char *name);
 extern int A_loadAC3 (char *name);
 extern int A_loadMP3 (char *name);
@@ -36,9 +28,7 @@
 extern void HandleAction(Action act);
 extern uint8_t A_setSecondAudioTrack(const AudioSource nw,char *name);
 
-JSPropertySpec ADM_JSAvidemuxAudio::avidemuxaudio_properties[] = 
-{ 
-
+JSPropertySpec ADM_JSAvidemuxAudio::properties[] = {
         { "process", audioprocess_prop, JSPROP_ENUMERATE },        // process audio when saving
         { "resample", resample_prop, JSPROP_ENUMERATE },	// resample
         { "delay", delay_prop, JSPROP_ENUMERATE },	// set audio delay
@@ -50,8 +40,7 @@
         { 0 }
 };
 
-JSFunctionSpec ADM_JSAvidemuxAudio::avidemuxaudio_methods[] = 
-{
+JSFunctionSpec ADM_JSAvidemuxAudio::methods[] = {
         { "scanVBR", ScanVBR, 0, 0, 0 },	// scan variable bit rate audio
         { "save", Save, 1, 0, 0 },	// save audio stream
         { "load", Load, 2, 0, 0 },	// load audio stream
@@ -94,25 +83,14 @@
 
 JSObject *ADM_JSAvidemuxAudio::JSInit(JSContext *cx, JSObject *obj, JSObject *proto)
 {
-        JSObject *newObj = JS_InitClass(cx, obj, proto, &m_classAvidemuxAudio, 
-                                                                        ADM_JSAvidemuxAudio::JSConstructor, 0,
-                                                                        ADM_JSAvidemuxAudio::avidemuxaudio_properties, ADM_JSAvidemuxAudio::avidemuxaudio_methods,
-                                                                        NULL, NULL);
-        return newObj;
-}
+	JSObject *newObj = JS_InitClass(cx, obj, proto, &m_classAvidemuxAudio, NULL, 0,
+		ADM_JSAvidemuxAudio::properties, ADM_JSAvidemuxAudio::methods, NULL, NULL);
+	ADM_JSAvidemuxAudio *p = new ADM_JSAvidemuxAudio();
 
-JSBool ADM_JSAvidemuxAudio::JSConstructor(JSContext *cx, JSObject *obj, uintN argc, 
-                                                                jsval *argv, jsval *rval)
-{
-        if(argc != 0)
-                return JS_FALSE;
-        ADM_JSAvidemuxAudio *p = new ADM_JSAvidemuxAudio();
-        ADM_AvidemuxAudio *pObject = new ADM_AvidemuxAudio();
-        p->setObject(pObject);
-        if ( ! JS_SetPrivate(cx, obj, p) )
-                return JS_FALSE;
-        *rval = OBJECT_TO_JSVAL(obj);
-        return JS_TRUE;
+	p->setObject(new ADM_AvidemuxAudio());
+	JS_SetPrivate(cx, newObj, p);
+
+	return newObj;
 }
 
 void ADM_JSAvidemuxAudio::JSDestructor(JSContext *cx, JSObject *obj)

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSAvidemuxAudio.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSAvidemuxAudio.h	2009-03-05 20:27:43 UTC (rev 4659)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSAvidemuxAudio.h	2009-03-06 16:44:41 UTC (rev 4660)
@@ -12,52 +12,46 @@
 class ADM_JSAvidemuxAudio
 {
 public:
-	ADM_JSAvidemuxAudio(void) : m_pObject(NULL) {}
 	virtual ~ADM_JSAvidemuxAudio(void);
-
-	static JSBool JSGetProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp);
-	static JSBool JSSetProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp);
-	static JSBool JSConstructor(JSContext *cx, JSObject *obj, uintN argc, 
-								jsval *argv, jsval *rval);
-	static void JSDestructor(JSContext *cx, JSObject *obj);
 	static JSObject *JSInit(JSContext *cx, JSObject *obj, JSObject *proto = NULL);
-	static JSBool ScanVBR(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval);
-	static JSBool Save(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval);
-	static JSBool Load(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval);
-	static JSBool Reset(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval);
-	static JSBool Codec(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval);
-        static JSBool getNbTracks(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval);
-        static JSBool setTrack(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval);
-        static JSBool lamePreset(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval);
-        static JSBool mixer(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval);
-        static JSBool secondAudioTrack(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval);
-        static JSBool getNbChannels(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval);
-        static JSBool getBitrate(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval);
 
-	static JSPropertySpec avidemuxaudio_properties[];
-	static JSFunctionSpec avidemuxaudio_methods[];
 	enum
 	{
-                audioprocess_prop,
+		audioprocess_prop,
 		resample_prop,
 		delay_prop,
 		film2pal_prop,
 		pal2film_prop,
-                normalizemode_prop,
-                normalizevalue_prop,
-                drc_prop
+		normalizemode_prop,
+		normalizevalue_prop,
+		drc_prop
 	};
+
+private:
+	ADM_AvidemuxAudio *m_pObject;
+	static JSPropertySpec properties[];
+	static JSFunctionSpec methods[];
 	static JSClass m_classAvidemuxAudio;
-        
 
-
-//protected:
+	ADM_JSAvidemuxAudio(void) : m_pObject(NULL) {}
 	void setObject(ADM_AvidemuxAudio *pObject);
 	ADM_AvidemuxAudio *getObject();
 
-private:
-	ADM_AvidemuxAudio *m_pObject;
-
+	static JSBool JSGetProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp);
+	static JSBool JSSetProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp);
+	static void JSDestructor(JSContext *cx, JSObject *obj);
+	static JSBool ScanVBR(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval);
+	static JSBool Save(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval);
+	static JSBool Load(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval);
+	static JSBool Reset(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval);
+	static JSBool Codec(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval);
+	static JSBool getNbTracks(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval);
+	static JSBool setTrack(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval);
+	static JSBool lamePreset(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval);
+	static JSBool mixer(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval);
+	static JSBool secondAudioTrack(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval);
+	static JSBool getNbChannels(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval);
+	static JSBool getBitrate(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval);
 };
 
 #endif

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSAvidemuxVideo.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSAvidemuxVideo.cpp	2009-03-05 20:27:43 UTC (rev 4659)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSAvidemuxVideo.cpp	2009-03-06 16:44:41 UTC (rev 4660)
@@ -11,23 +11,15 @@
 //
 //
 #include "ADM_default.h"
-
 #include "ADM_JSAvidemuxVideo.h"
+#include "ADM_JSVideoFilterCollection.h"
 #include "ADM_JSGlobal.h"
-
-
-#include "../ADM_userInterfaces/ADM_commonUI/GUI_ui.h"
-#include "ADM_audiofilter/audioeng_buildfilters.h"
 #include "avi_vars.h"
-#include "gui_action.hxx"
 #include "ADM_encoder/ADM_vidEncode.hxx"
 #include "ADM_videoFilter.h"
 #include "ADM_videoFilter_internal.h"
-#include "ADM_encoder/adm_encoder.h"
 #include "ADM_encoder/adm_encConfig.h"
-#include "ADM_editor/ADM_outputfmt.h"
 #include "../ADM_userInterfaces/ADM_commonUI/GUI_ui.h"
-#include "ADM_script/ADM_container.h"
 
 extern VF_FILTERS filterGetTagFromName(const char *inname);
 extern uint8_t A_ListAllBlackFrames( char *file );
@@ -37,7 +29,7 @@
 extern uint8_t loadVideoCodecConf( const char *name);
 extern void filterCleanUp( void );
 
-JSPropertySpec ADM_JSAvidemuxVideo::avidemuxvideo_properties[] = 
+JSPropertySpec ADM_JSAvidemuxVideo::properties[] = 
 { 
 	{ "process", videoProcessProperty, JSPROP_ENUMERATE },        // process video when saving
 	{ "width", widthProperty, JSPROP_ENUMERATE },
@@ -51,7 +43,7 @@
 	{ 0 }
 };
 
-JSFunctionSpec ADM_JSAvidemuxVideo::avidemuxvideo_methods[] = 
+JSFunctionSpec ADM_JSAvidemuxVideo::methods[] = 
 {
 	{ "clear", Clear, 0, 0, 0 },	// clear
 	{ "add", Add, 3, 0, 0 },	// add
@@ -97,27 +89,16 @@
 
 JSObject *ADM_JSAvidemuxVideo::JSInit(JSContext *cx, JSObject *obj, JSObject *proto)
 {
-        JSObject *newObj = JS_InitClass(cx, obj, proto, &m_classAvidemuxVideo, 
-                                        ADM_JSAvidemuxVideo::JSConstructor, 0,
-                                        ADM_JSAvidemuxVideo::avidemuxvideo_properties, ADM_JSAvidemuxVideo::avidemuxvideo_methods,
-                                        NULL, NULL);
+	JSObject *newObj = JS_InitClass(cx, obj, proto, &m_classAvidemuxVideo, NULL, 0,
+		ADM_JSAvidemuxVideo::properties, ADM_JSAvidemuxVideo::methods, NULL, NULL);
+	ADM_JSAvidemuxVideo *p = new ADM_JSAvidemuxVideo();
+
+	p->setObject(new ADM_AvidemuxVideo());
+	JS_SetPrivate(cx, newObj, p);
+
 	return newObj;
 }
 
-JSBool ADM_JSAvidemuxVideo::JSConstructor(JSContext *cx, JSObject *obj, uintN argc, 
-								 jsval *argv, jsval *rval)
-{
-        if(argc != 0)
-                return JS_FALSE;
-        ADM_JSAvidemuxVideo *p = new ADM_JSAvidemuxVideo();
-        ADM_AvidemuxVideo *pObject = new ADM_AvidemuxVideo();
-        p->setObject(pObject);
-        if ( ! JS_SetPrivate(cx, obj, p) )
-                return JS_FALSE;
-        *rval = OBJECT_TO_JSVAL(obj);
-        return JS_TRUE;
-}
-
 void ADM_JSAvidemuxVideo::JSDestructor(JSContext *cx, JSObject *obj)
 {
         ADM_JSAvidemuxVideo *p = (ADM_JSAvidemuxVideo *)JS_GetPrivate(cx, obj);

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSAvidemuxVideo.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSAvidemuxVideo.h	2009-03-05 20:27:43 UTC (rev 4659)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSAvidemuxVideo.h	2009-03-06 16:44:41 UTC (rev 4660)
@@ -10,33 +10,9 @@
 class ADM_JSAvidemuxVideo
 {
 public:
-	ADM_JSAvidemuxVideo(void) : m_pObject(NULL) {}
 	virtual ~ADM_JSAvidemuxVideo(void);
-
-	static JSBool JSGetProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp);
-	static JSBool JSSetProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp);
-	static JSBool JSConstructor(JSContext *cx, JSObject *obj, uintN argc, 
-								jsval *argv, jsval *rval);
-	static void JSDestructor(JSContext *cx, JSObject *obj);
 	static JSObject *JSInit(JSContext *cx, JSObject *obj, JSObject *proto = NULL);
-	static JSBool Clear(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval);
-	static JSBool Add(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval);
-	static JSBool ClearFilters(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval);
-	static JSBool AddFilter(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval);
-	static JSBool IndexMPEG(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval);
-	static JSBool Codec(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval);
-	static JSBool CodecPlugin(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval);
-	static JSBool CodecConf(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval);
-	static JSBool Save(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval);
-	static JSBool SaveJPEG(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval);
-	static JSBool ListBlackFrames(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval);
-	static JSBool PostProcess(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval);
-	static JSBool RebuildIBFrames(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval);
-	static JSBool getFrameSize(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval);
-	static JSBool getFrameType(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval);
 
-	static JSPropertySpec avidemuxvideo_properties[];
-	static JSFunctionSpec avidemuxvideo_methods[];
 	enum
 	{
 		videoProcessProperty,
@@ -50,15 +26,34 @@
 		fps1000Property
 	};
 
+private:
+	ADM_AvidemuxVideo *m_pObject;
+	static JSPropertySpec properties[];
+	static JSFunctionSpec methods[];
 	static JSClass m_classAvidemuxVideo;
 
-//protected:
+	ADM_JSAvidemuxVideo(void) : m_pObject(NULL) {}
 	void setObject(ADM_AvidemuxVideo *pObject);
 	ADM_AvidemuxVideo *getObject();
 
-private:
-	ADM_AvidemuxVideo *m_pObject;
-
+	static JSBool JSGetProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp);
+	static JSBool JSSetProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp);
+	static void JSDestructor(JSContext *cx, JSObject *obj);
+	static JSBool Clear(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval);
+	static JSBool Add(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval);
+	static JSBool ClearFilters(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval);
+	static JSBool AddFilter(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval);
+	static JSBool IndexMPEG(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval);
+	static JSBool Codec(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval);
+	static JSBool CodecPlugin(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval);
+	static JSBool CodecConf(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval);
+	static JSBool Save(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval);
+	static JSBool SaveJPEG(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval);
+	static JSBool ListBlackFrames(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval);
+	static JSBool PostProcess(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval);
+	static JSBool RebuildIBFrames(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval);
+	static JSBool getFrameSize(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval);
+	static JSBool getFrameType(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval);
 };
 
 #endif

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSFunctions.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSFunctions.cpp	2009-03-05 20:27:43 UTC (rev 4659)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSFunctions.cpp	2009-03-06 16:44:41 UTC (rev 4660)
@@ -302,7 +302,7 @@
 
 JSBool nextFile(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
 {
-char *n;
+const char *n;
         if(argc != 0)
                 return JS_FALSE;
 



From gruntster at mail.berlios.de  Sun Mar  8 16:16:17 2009
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Sun, 8 Mar 2009 16:16:17 +0100
Subject: [Avidemux-svn-commit] r4661 - in
	branches/avidemux_2.5_branch_gruntster: avidemux/ADM_editor
	avidemux/ADM_script platforms/windows/installer
Message-ID: <200903081516.n28FGHNl011193@sheep.berlios.de>

Author: gruntster
Date: 2009-03-08 16:16:11 +0100 (Sun, 08 Mar 2009)
New Revision: 4661

Added:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSAppliedVideoFilter.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSAppliedVideoFilter.h
Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_editor/ADM_edLoadSave.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSAvidemuxVideo.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSAvidemuxVideo.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/CMakeLists.txt
   branches/avidemux_2.5_branch_gruntster/platforms/windows/installer/avidemux.nsi
Log:
[script] add AppliedVideoFilters class and appliedFilters property to Video class

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_editor/ADM_edLoadSave.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_editor/ADM_edLoadSave.cpp	2009-03-06 16:44:41 UTC (rev 4660)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_editor/ADM_edLoadSave.cpp	2009-03-08 15:16:11 UTC (rev 4661)
@@ -156,7 +156,7 @@
 	if( avifileinfo ){
 	  aviInfo info;
 		video_body->getVideoInfo(&info);
-		qfprintf(fd,"\napp.video.setFps1000(%u);\n",info.fps1000);
+		qfprintf(fd,"\napp.video.fps1000 = %u;\n",info.fps1000);
 	}
 
 // Filter

Added: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSAppliedVideoFilter.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSAppliedVideoFilter.cpp	2009-03-06 16:44:41 UTC (rev 4660)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSAppliedVideoFilter.cpp	2009-03-08 15:16:11 UTC (rev 4661)
@@ -0,0 +1,123 @@
+#include "ADM_default.h"
+#include "ADM_JSAppliedVideoFilter.h"
+#include "ADM_videoFilter.h"
+#include "ADM_videoFilter_internal.h"
+
+extern void filterCleanUp(void);
+extern uint32_t nb_active_filter;
+extern FILTER videofilters[VF_MAX_FILTER];
+
+JSPropertySpec ADM_JSAppliedVideoFilter::properties[] = 
+{ 
+	{ "arguments", argumentsProperty, JSPROP_ENUMERATE },
+	{ "width", widthProperty, JSPROP_ENUMERATE },
+	{ "height", heightProperty, JSPROP_ENUMERATE },
+	{ "fps1000", fps1000Property, JSPROP_ENUMERATE },
+	{ 0 }
+};
+
+JSClass ADM_JSAppliedVideoFilter::m_appliedVideoFilter = 
+{
+	"AppliedVideoFilter", JSCLASS_HAS_PRIVATE,
+	JS_PropertyStub, JS_PropertyStub,
+	ADM_JSAppliedVideoFilter::JSGetProperty, JS_PropertyStub,
+	JS_EnumerateStub, JS_ResolveStub, 
+	JS_ConvertStub, ADM_JSAppliedVideoFilter::JSDestructor
+};
+
+ADM_JSAppliedVideoFilter::ADM_JSAppliedVideoFilter(int filterIndex)
+{
+	ADM_assert(filterIndex < nb_active_filter);
+
+	_filterIndex = filterIndex;
+}
+
+ADM_JSAppliedVideoFilter::~ADM_JSAppliedVideoFilter(void)
+{
+
+}
+
+int ADM_JSAppliedVideoFilter::getFilterIndex(void)
+{
+	return _filterIndex;
+}
+
+JSObject *ADM_JSAppliedVideoFilter::JSInit(JSContext *cx, JSObject *obj, JSObject *proto, int filterIndex)
+{
+	JSObject *newObj = JS_InitClass(cx, obj, proto, &m_appliedVideoFilter, NULL,
+		0, ADM_JSAppliedVideoFilter::properties, NULL, NULL, NULL);
+	ADM_JSAppliedVideoFilter *p = new ADM_JSAppliedVideoFilter(filterIndex);
+
+	JS_SetPrivate(cx, newObj, p);
+
+	return newObj;
+}
+
+void ADM_JSAppliedVideoFilter::JSDestructor(JSContext *cx, JSObject *obj)
+{
+
+}
+
+JSBool ADM_JSAppliedVideoFilter::JSGetProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp)
+{
+	ADM_JSAppliedVideoFilter *p = (ADM_JSAppliedVideoFilter *)JS_GetPrivate(cx, obj);
+	FILTER filterEntry = videofilters[p->getFilterIndex()];
+
+	if (JSVAL_IS_INT(id))
+	{
+		switch(JSVAL_TO_INT(id))
+		{
+			case argumentsProperty:
+			{
+				JSObject *args = JS_NewArrayObject(cx, 0, NULL);
+				jsval arg, argString, valueString;
+				char *argName, *argValue;
+				CONFcouple *couple;
+
+				*vp = OBJECT_TO_JSVAL(args);
+
+				if (filterEntry.filter->getCoupledConf(&couple))
+				{
+					for(int j = 0; j < couple->getNumber(); j++)
+					{
+						couple->getEntry(j, &argName, &argValue);
+
+						arg = OBJECT_TO_JSVAL(JS_NewArrayObject(cx, 0, NULL));
+						argString = STRING_TO_JSVAL(JS_NewStringCopyZ(cx, argName));
+						valueString = STRING_TO_JSVAL(JS_NewStringCopyZ(cx, argValue));
+
+						JS_SetElement(cx, args, j, &arg);
+						JS_SetElement(cx, JSVAL_TO_OBJECT(arg), 0, &argString);
+						JS_SetElement(cx, JSVAL_TO_OBJECT(arg), 1, &valueString);
+					}
+
+					delete couple;
+				}
+
+				break;
+			}
+			case widthProperty:
+			{
+				ADV_Info *info = filterEntry.filter->getInfo();
+
+				*vp = INT_TO_JSVAL(info->width);
+				break;
+			}
+			case heightProperty:
+			{
+				ADV_Info *info = filterEntry.filter->getInfo();
+
+				*vp = INT_TO_JSVAL(info->height);
+				break;
+			}
+			case fps1000Property:
+			{
+				ADV_Info *info = filterEntry.filter->getInfo();
+
+				*vp = INT_TO_JSVAL(info->fps1000);
+				break;
+			}
+		}
+	}
+	return JS_TRUE;
+}

Added: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSAppliedVideoFilter.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSAppliedVideoFilter.h	2009-03-06 16:44:41 UTC (rev 4660)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSAppliedVideoFilter.h	2009-03-08 15:16:11 UTC (rev 4661)
@@ -0,0 +1,37 @@
+#ifndef _ADM_JSAVIDEMUXVIDEOFILTERCOLLECTION_H
+#define _ADM_JSAVIDEMUXVIDEOFILTERCOLLECTION_H
+
+#pragma once
+
+// Spidermonkey
+#include "ADM_libraries/ADM_smjs/jsapi.h"
+
+class ADM_JSAppliedVideoFilter
+{
+public:
+	virtual ~ADM_JSAppliedVideoFilter(void);
+	static JSObject *JSInit(JSContext *cx, JSObject *obj, JSObject *proto, int filterIndex);
+	int getFilterIndex(void);
+
+	enum
+	{
+		argumentsProperty,
+		widthProperty,
+		heightProperty,
+		fps1000Property
+	};
+
+protected:
+	ADM_JSAppliedVideoFilter(int filterIndex);
+
+private:
+	int _filterIndex;
+
+	static JSBool JSGetProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp);
+	static void JSDestructor(JSContext *cx, JSObject *obj);
+
+	static JSPropertySpec properties[];
+	static JSClass m_appliedVideoFilter;
+};
+
+#endif

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSAvidemuxVideo.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSAvidemuxVideo.cpp	2009-03-06 16:44:41 UTC (rev 4660)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSAvidemuxVideo.cpp	2009-03-08 15:16:11 UTC (rev 4661)
@@ -12,7 +12,6 @@
 //
 #include "ADM_default.h"
 #include "ADM_JSAvidemuxVideo.h"
-#include "ADM_JSVideoFilterCollection.h"
 #include "ADM_JSGlobal.h"
 #include "avi_vars.h"
 #include "ADM_encoder/ADM_vidEncode.hxx"
@@ -20,6 +19,7 @@
 #include "ADM_videoFilter_internal.h"
 #include "ADM_encoder/adm_encConfig.h"
 #include "../ADM_userInterfaces/ADM_commonUI/GUI_ui.h"
+#include "ADM_JSAppliedVideoFilter.h"
 
 extern VF_FILTERS filterGetTagFromName(const char *inname);
 extern uint8_t A_ListAllBlackFrames( char *file );
@@ -28,6 +28,7 @@
 extern int A_saveJpg (char *name);
 extern uint8_t loadVideoCodecConf( const char *name);
 extern void filterCleanUp( void );
+extern uint32_t nb_active_filter;
 
 JSPropertySpec ADM_JSAvidemuxVideo::properties[] = 
 { 
@@ -40,6 +41,7 @@
 	{ "gmc", gmcProperty, JSPROP_ENUMERATE },
 	{ "fcc", fccProperty, JSPROP_ENUMERATE },
 	{ "fps1000", fps1000Property, JSPROP_ENUMERATE },
+	{ "appliedFilters", appliedFiltersProperty, JSPROP_ENUMERATE },
 	{ 0 }
 };
 
@@ -172,6 +174,21 @@
 				*vp = INT_TO_JSVAL(info.fps1000);
 				break;
 			}
+			case appliedFiltersProperty:
+			{
+				JSObject *filters = JS_NewArrayObject(cx, 0, NULL);
+				jsval appliedFilter;
+
+				*vp = OBJECT_TO_JSVAL(filters);
+
+				for (int filterIndex = 1; filterIndex < nb_active_filter; filterIndex++)
+				{
+					appliedFilter = OBJECT_TO_JSVAL(ADM_JSAppliedVideoFilter::JSInit(cx, obj, NULL, filterIndex));
+					JS_SetElement(cx, filters, filterIndex - 1, &appliedFilter);
+				}
+
+				break;
+			}
 		}
 	}
 	return JS_TRUE;

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSAvidemuxVideo.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSAvidemuxVideo.h	2009-03-06 16:44:41 UTC (rev 4660)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSAvidemuxVideo.h	2009-03-08 15:16:11 UTC (rev 4661)
@@ -23,7 +23,8 @@
 		qPelProperty,
 		gmcProperty,
 		fccProperty,
-		fps1000Property
+		fps1000Property,
+		appliedFiltersProperty
 	};
 
 private:

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/CMakeLists.txt	2009-03-06 16:44:41 UTC (rev 4660)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/CMakeLists.txt	2009-03-08 15:16:11 UTC (rev 4661)
@@ -1,7 +1,7 @@
 SET(ADM_script_SRCS
 	ADM_AvidemuxAudio.cpp  ADM_AvidemuxVideo.cpp    ADM_JSAvidemux.cpp       ADM_JSDirectorySearch.cpp  ADM_JSGlobal.cpp
 	ADM_Avidemux.cpp       ADM_JSAvidemuxAudio.cpp  ADM_JSAvidemuxVideo.cpp  ADM_JSFunctions.cpp        DirectorySearch.cpp
-	ADM_JSDialogFactory.cpp  ADM_JSDFMenu.cpp)
+	ADM_JSDialogFactory.cpp  ADM_JSDFMenu.cpp  ADM_JSAppliedVideoFilter.cpp)
 
 ADD_ADM_LIB_ALL_TARGETS(ADM_script ${ADM_script_SRCS})
 

Modified: branches/avidemux_2.5_branch_gruntster/platforms/windows/installer/avidemux.nsi
===================================================================
--- branches/avidemux_2.5_branch_gruntster/platforms/windows/installer/avidemux.nsi	2009-03-06 16:44:41 UTC (rev 4660)
+++ branches/avidemux_2.5_branch_gruntster/platforms/windows/installer/avidemux.nsi	2009-03-08 15:16:11 UTC (rev 4661)
@@ -1220,7 +1220,7 @@
     CreateDirectory $SMPROGRAMS\$StartMenuGroup
     !insertmacro MUI_STARTMENU_WRITE_BEGIN Application
     SetOutPath $INSTDIR
-    CreateShortcut "$SMPROGRAMS\$StartMenuGroup\${INTERNALNAME} Qt.lnk" $INSTDIR\avidemux2_qt4.exe
+    CreateShortcut "$SMPROGRAMS\$StartMenuGroup\${INTERNALNAME}.lnk" $INSTDIR\avidemux2_qt4.exe
     !insertmacro MUI_STARTMENU_WRITE_END
 !endif
 ${MementoSectionEnd}
@@ -1243,7 +1243,7 @@
 ${MementoSection} "-Quick Launch Qt" SecQuickLaunchQt
 !ifdef INST_QT
     SetOutPath $INSTDIR
-    CreateShortcut "$QUICKLAUNCH\${INTERNALNAME} Qt.lnk" $INSTDIR\avidemux2_qt4.exe
+    CreateShortcut "$QUICKLAUNCH\${INTERNALNAME}.lnk" $INSTDIR\avidemux2_qt4.exe
 !endif
 ${MementoSectionEnd}
 
@@ -1257,7 +1257,7 @@
 ${MementoSection} "-Desktop Qt" SecDesktopQt
 !ifdef INST_QT
     SetOutPath $INSTDIR
-    CreateShortcut "$DESKTOP\${INTERNALNAME} Qt.lnk" $INSTDIR\avidemux2_qt4.exe
+    CreateShortcut "$DESKTOP\${INTERNALNAME}.lnk" $INSTDIR\avidemux2_qt4.exe
 !endif
 ${MementoSectionEnd}
 
@@ -1292,9 +1292,9 @@
 !endif
 
 !ifdef INST_QT
-    Delete /REBOOTOK "$QUICKLAUNCH\${INTERNALNAME} Qt.lnk"
-    Delete /REBOOTOK "$DESKTOP\${INTERNALNAME} Qt.lnk"
-    Delete /REBOOTOK "$SMPROGRAMS\$StartMenuGroup\${INTERNALNAME} Qt.lnk"
+    Delete /REBOOTOK "$QUICKLAUNCH\${INTERNALNAME}.lnk"
+    Delete /REBOOTOK "$DESKTOP\${INTERNALNAME}.lnk"
+    Delete /REBOOTOK "$SMPROGRAMS\$StartMenuGroup\${INTERNALNAME}.lnk"
 !endif
 
 	Delete /REBOOTOK "$SMPROGRAMS\$StartMenuGroup\Change Log.lnk"



From gruntster at mail.berlios.de  Sun Mar  8 16:32:06 2009
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Sun, 8 Mar 2009 16:32:06 +0100
Subject: [Avidemux-svn-commit] r4662 - in
	branches/avidemux_2.5_branch_gruntster: avidemux
	avidemux/ADM_core/src cmake cmake/Apple
Message-ID: <200903081532.n28FW6M0013180@sheep.berlios.de>

Author: gruntster
Date: 2009-03-08 16:31:58 +0100 (Sun, 08 Mar 2009)
New Revision: 4662

Added:
   branches/avidemux_2.5_branch_gruntster/cmake/Apple/
   branches/avidemux_2.5_branch_gruntster/cmake/Apple/CompleteBundle.cmake.in
   branches/avidemux_2.5_branch_gruntster/cmake/Apple/CreateBundle.sh.in
Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_core/src/ADM_fileio.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/CMakeLists.txt
   branches/avidemux_2.5_branch_gruntster/avidemux/main.cpp
   branches/avidemux_2.5_branch_gruntster/cmake/admConfigSummary.cmake
Log:
[mac] create bundle using CMake (patch by surfer)

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_core/src/ADM_fileio.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_core/src/ADM_fileio.cpp	2009-03-08 15:16:11 UTC (rev 4661)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_core/src/ADM_fileio.cpp	2009-03-08 15:31:58 UTC (rev 4662)
@@ -345,7 +345,7 @@
 	const char *pluginDir="ADM_plugins";
 
 #ifdef __APPLE__
-    const char *startDir="../Resources/lib";
+    const char *startDir="../Libraries/lib";
 #else
     const char *startDir="lib";
 #endif

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/CMakeLists.txt	2009-03-08 15:16:11 UTC (rev 4661)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/CMakeLists.txt	2009-03-08 15:31:58 UTC (rev 4662)
@@ -42,6 +42,23 @@
 ENDMACRO (ADD_LDFLAGS_ALL_TARGETS)
 
 ########################################
+# Functions
+########################################
+function(MakeOSXBundleApp target binary_dir)
+	SET (OSX_MAKE_STANDALONE_BUNDLE_CMAKE_SCRIPT "${binary_dir}/${target}_OSX_MakeStandAloneBundle.cmake")
+	SET (OSX_MAKE_STANDALONE_BUNDLE_BASH_SCRIPT "${binary_dir}/${target}_OSX_MakeStandAloneBundle.sh")
+
+	#-- Configure the cmake file and the shell script
+	CONFIGURE_FILE("${CMAKE_CURRENT_SOURCE_DIR}/../cmake/Apple/CompleteBundle.cmake.in"
+		"${OSX_MAKE_STANDALONE_BUNDLE_CMAKE_SCRIPT}" @ONLY IMMEDIATE)
+	CONFIGURE_FILE("${CMAKE_CURRENT_SOURCE_DIR}/../cmake/Apple/CreateBundle.sh.in"
+		"${OSX_MAKE_STANDALONE_BUNDLE_BASH_SCRIPT}" @ONLY IMMEDIATE)
+
+	#-- Create the installation code
+	install(SCRIPT "${OSX_MAKE_STANDALONE_BUNDLE_CMAKE_SCRIPT}")
+endfunction(MakeOSXBundleApp)
+
+########################################
 # Definitions and Includes
 ########################################
 ADD_DEFINITIONS(-D_FILE_OFFSET_BITS=64 -D_LARGE_FILES)
@@ -452,20 +469,24 @@
 ###########################################
 SET(ADM_EXES avidemux2_cli)
 
-IF (ADM_UI_GTK)
-	SET(ADM_EXES ${ADM_EXES} avidemux2_gtk)
-ENDIF (ADM_UI_GTK)
 
 IF (ADM_UI_QT4)
 	SET(ADM_EXES ${ADM_EXES} avidemux2_qt4)
+	MakeOSXBundleApp(avidemux2_qt4 ${PROJECT_BINARY_DIR})
 ENDIF (ADM_UI_QT4)
 
+IF (ADM_UI_GTK)
+	SET(ADM_EXES ${ADM_EXES} avidemux2_gtk)
+	MakeOSXBundleApp(avidemux2_gtk ${PROJECT_BINARY_DIR})
+ENDIF (ADM_UI_GTK)
+
 IF (APPLE)
-	IF (NOT MAC_BUNDLE_DIR)
+	IF (MAC_BUNDLE_DIR)
+		INSTALL(TARGETS ${ADM_EXES} RUNTIME DESTINATION ${BIN_DIR} BUNDLE DESTINATION ${MAC_BUNDLE_DIR} LIBRARY DESTINATION lib)
+	ELSE (MAC_BUNDLE_DIR)
 		INSTALL(TARGETS ${ADM_EXES} RUNTIME DESTINATION ${BIN_DIR} BUNDLE DESTINATION "/Applications" LIBRARY DESTINATION lib)
-	ELSE (NOT MAC_BUNDLE_DIR)
-		INSTALL(TARGETS ${ADM_EXES} RUNTIME DESTINATION ${BIN_DIR} BUNDLE DESTINATION ${MAC_BUNDLE_DIR} LIBRARY DESTINATION lib)
-	ENDIF (NOT MAC_BUNDLE_DIR)
+		SET (MAC_BUNDLE_DIR "/Applications")
+	ENDIF (MAC_BUNDLE_DIR)
 ELSE (APPLE)
 	INSTALL(TARGETS ${ADM_EXES} RUNTIME DESTINATION ${BIN_DIR} LIBRARY DESTINATION lib)
 ENDIF (APPLE)

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/main.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/main.cpp	2009-03-08 15:16:11 UTC (rev 4661)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/main.cpp	2009-03-08 15:31:58 UTC (rev 4662)
@@ -230,7 +230,7 @@
 	const char *pluginDir="ADM_plugins";
 
 #ifdef __APPLE__
-    const char *startDir="../Resources/lib";
+    const char *startDir="../Libraries/lib";
 #else
     const char *startDir="lib";
 #endif
@@ -334,4 +334,3 @@
 {
     checkCrashFile();
 }
-//EOF
\ No newline at end of file

Added: branches/avidemux_2.5_branch_gruntster/cmake/Apple/CompleteBundle.cmake.in
===================================================================
--- branches/avidemux_2.5_branch_gruntster/cmake/Apple/CompleteBundle.cmake.in	2009-03-08 15:16:11 UTC (rev 4661)
+++ branches/avidemux_2.5_branch_gruntster/cmake/Apple/CompleteBundle.cmake.in	2009-03-08 15:31:58 UTC (rev 4662)
@@ -0,0 +1,69 @@
+#-- Need this for link line stuff?
+if(COMMAND cmake_policy)
+  cmake_policy(SET CMP0009 NEW)
+endif(COMMAND cmake_policy)
+
+
+# gp_item_default_embedded_path item default_embedded_path_var
+#
+# Return the path that others should refer to the item by when the item
+# is embedded inside a bundle.
+#
+# Override on a per-project basis by providing a project-specific
+# gp_item_default_embedded_path_override function.
+#
+function(gp_item_default_embedded_path_override item default_embedded_path_var)
+  #
+  # The assumption here is that all executables in the bundle will be
+  # in same-level-directories inside the bundle. The parent directory
+  # of an executable inside the bundle should be MacOS or a sibling of
+  # MacOS and all embedded paths returned from here will begin with
+  # "@loader_path/../" and will work from all executables in all
+  # such same-level-directories inside the bundle.
+  #
+
+  # By default, embed things right next to the main bundle executable:
+  #
+  set (install_name_prefix "@executable_path")
+  # -------------------------------------------------------------------
+  # If your application uses plugins then you should consider using the following
+  #  instead but will limit your deployment to OS X 10.4. There is also a patch
+  #  needed for CMake that as of Sept 30, 2008 has NOT been applied to CMake.
+  #  set (install_name_prefix "@loader_path")
+  
+  set(path "${install_name_prefix}/../../Contents/MacOS")
+
+  set(overridden 0)
+
+  # Embed .dylibs in the Libraries Directory
+  #
+  if(item MATCHES "\\.dylib$")
+    set(path "${install_name_prefix}/../Libraries")
+    set(overridden 1)
+  endif(item MATCHES "\\.dylib$")
+
+  # Embed .so files in the Plugins directory
+  #
+  if(item MATCHES "\\.so$")
+    set(path "${install_name_prefix}/../Plugins")
+    set(overridden 1)
+  endif(item MATCHES "\\.so$")
+  
+  # Embed frameworks in the embedded "Frameworks" directory (sibling of MacOS):
+  #
+  if(NOT overridden)
+    if(item MATCHES "[^/]+\\.framework/")
+      set(path "${install_name_prefix}/../Frameworks")
+      set(overridden 1)
+    endif(item MATCHES "[^/]+\\.framework/")
+  endif(NOT overridden)
+
+  set(${default_embedded_path_var} "${path}" PARENT_SCOPE)
+endfunction(gp_item_default_embedded_path_override)
+
+# -- Copy the App bundle to the installation location first
+EXECUTE_PROCESS( COMMAND "@OSX_MAKE_STANDALONE_BUNDLE_BASH_SCRIPT@" )
+
+# -- Run the BundleUtilities cmake code
+include(BundleUtilities)
+fixup_bundle("@CMAKE_INSTALL_PREFIX@/@target at .app" "${PluginList}" "Plugins")

Added: branches/avidemux_2.5_branch_gruntster/cmake/Apple/CreateBundle.sh.in
===================================================================
--- branches/avidemux_2.5_branch_gruntster/cmake/Apple/CreateBundle.sh.in	2009-03-08 15:16:11 UTC (rev 4661)
+++ branches/avidemux_2.5_branch_gruntster/cmake/Apple/CreateBundle.sh.in	2009-03-08 15:31:58 UTC (rev 4662)
@@ -0,0 +1,68 @@
+#!/bin/sh
+
+# Are we using Xcode to compile. If we are then the CMake variable
+# XCODE will be '1' otherwise it will be blank
+Xcode="@XCODE at x"
+InstallPrefix="@CMAKE_INSTALL_PREFIX@"
+ProjectBinaryDir="@binary_dir@"
+OSX_App_Name="@target@"
+
+# Check for a Debug build. Note that the EXE_DEBUG_EXTENSION was set
+# in the CMakeLists.txt file
+if [[ $Xcode == "1x" ]]; then
+  if [[ $BUILD_STYLE == "Debug" ]]; then
+    OSX_App_Name="@target@@EXE_DEBUG_EXTENSION@"
+  fi
+  OSX_App="@EXECUTABLE_OUTPUT_PATH@/$BUILD_STYLE/$OSX_App_Name.app"
+else
+#  OSX_App="@EXECUTABLE_OUTPUT_PATH@/$OSX_App_Name.app"
+  OSX_App="@CMAKE_BINARY_DIR@/avidemux/$OSX_App_Name.app"
+fi
+
+# Hopefully temporary fix to softlink libraries
+rm -rf "@CMAKE_INSTALL_PREFIX@/lib/libswscale.dylib"
+rm -rf "@CMAKE_INSTALL_PREFIX@/lib/libpostproc.dylib"
+rm -rf "@CMAKE_INSTALL_PREFIX@/lib/libavutil.dylib"
+rm -rf "@CMAKE_INSTALL_PREFIX@/lib/libavcodec.dylib"
+rm -rf "@CMAKE_INSTALL_PREFIX@/lib/libavformat.dylib"
+
+ln -s "@CMAKE_INSTALL_PREFIX@/lib/libswscale.0.dylib" "@CMAKE_INSTALL_PREFIX@/lib/libswscale.dylib" 
+ln -s "@CMAKE_INSTALL_PREFIX@/lib/libpostproc.51.dylib" "@CMAKE_INSTALL_PREFIX@/lib/libpostproc.dylib"
+ln -s "@CMAKE_INSTALL_PREFIX@/lib/libavutil.49.dylib" "@CMAKE_INSTALL_PREFIX@/lib/libavutil.dylib"
+ln -s "@CMAKE_INSTALL_PREFIX@/lib/libavcodec.52.dylib" "@CMAKE_INSTALL_PREFIX@/lib/libavcodec.dylib"
+ln -s "@CMAKE_INSTALL_PREFIX@/lib/libavformat.52.dylib" "@CMAKE_INSTALL_PREFIX@/lib/libavformat.dylib" 
+
+
+
+# Remove the previous @target@ app package so we start with a clean bundle
+#echo "Removing Previous $OSX_App_Name.app bundle at $InstallPrefix/"
+#rm -rf "$InstallPrefix/$OSX_App_Name.app"
+
+# copy the @target at .app bundle to the installation location
+echo "Copying $OSX_App_Name.app from the build tree to $InstallPrefix/"
+cp -Rp "$OSX_App" "$InstallPrefix/"
+
+OSX_App="@CMAKE_INSTALL_PREFIX@/$OSX_App_Name.app"
+ContentsDir="$OSX_App/Contents"
+#SupportDir="$OSX_App/Contents/Support"
+LibrariesDir="$OSX_App/Contents/Libraries"
+FrameworksDir="$OSX_App/Contents/Frameworks"
+PluginsDir="$OSX_App/Contents/Plugins"
+
+
+# create directories in the @target at .app bundle
+#mkdir -p "$SupportDir"
+if [ ! -e $LibrariesDir ]
+  then
+  mkdir -p "$LibrariesDir"
+fi
+if [ ! -e $FrameworksDir ]
+  then
+  mkdir -p "$FrameworksDir"
+fi
+if [ ! -e $PluginsDir ]
+  then
+  mkdir -p "$PluginsDir"
+fi
+
+

Modified: branches/avidemux_2.5_branch_gruntster/cmake/admConfigSummary.cmake
===================================================================
--- branches/avidemux_2.5_branch_gruntster/cmake/admConfigSummary.cmake	2009-03-08 15:16:11 UTC (rev 4661)
+++ branches/avidemux_2.5_branch_gruntster/cmake/admConfigSummary.cmake	2009-03-08 15:31:58 UTC (rev 4662)
@@ -40,6 +40,17 @@
 ADM_DISPLAY("SDL       " "${USE_SDL}")
 ADM_DISPLAY("XVideo    " "${USE_XV}" "${XVIDEO_CAPABLE}")
 
+IF (APPLE)
+	MESSAGE("*** Apple Bundle  ***")
+	MESSAGE("    Install at")
+	
+	IF (MAC_BUNDLE_DIR)
+		MESSAGE("    ${MAC_BUNDLE_DIR}")
+	ELSE (MAC_BUNDLE_DIR)
+		ADM_DISPLAY("    /Applications")
+	ENDIF (MAC_BUNDLE_DIR) 
+ENDIF (APPLE)
+
 MESSAGE("*********************")
 
 IF (CMAKE_BUILD_TYPE STREQUAL "Debug")



From gruntster at mail.berlios.de  Sun Mar  8 23:01:51 2009
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Sun, 8 Mar 2009 23:01:51 +0100
Subject: [Avidemux-svn-commit] r4663 -
	branches/avidemux_2.5_branch_gruntster/avidemux
Message-ID: <200903082201.n28M1pLF030427@sheep.berlios.de>

Author: gruntster
Date: 2009-03-08 23:01:46 +0100 (Sun, 08 Mar 2009)
New Revision: 4663

Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/CMakeLists.txt
Log:
[mac] only build bundle on Mac

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/CMakeLists.txt	2009-03-08 15:31:58 UTC (rev 4662)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/CMakeLists.txt	2009-03-08 22:01:46 UTC (rev 4663)
@@ -472,12 +472,18 @@
 
 IF (ADM_UI_QT4)
 	SET(ADM_EXES ${ADM_EXES} avidemux2_qt4)
-	MakeOSXBundleApp(avidemux2_qt4 ${PROJECT_BINARY_DIR})
+
+	IF (APPLE)
+		MakeOSXBundleApp(avidemux2_qt4 ${PROJECT_BINARY_DIR})
+	ENDIF (APPLE)
 ENDIF (ADM_UI_QT4)
 
 IF (ADM_UI_GTK)
 	SET(ADM_EXES ${ADM_EXES} avidemux2_gtk)
-	MakeOSXBundleApp(avidemux2_gtk ${PROJECT_BINARY_DIR})
+
+	IF (APPLE)
+		MakeOSXBundleApp(avidemux2_gtk ${PROJECT_BINARY_DIR})
+	ENDIF (APPLE)
 ENDIF (ADM_UI_GTK)
 
 IF (APPLE)



From gruntster at mail.berlios.de  Sun Mar  8 23:09:02 2009
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Sun, 8 Mar 2009 23:09:02 +0100
Subject: [Avidemux-svn-commit] r4664 -
	branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script
Message-ID: <200903082209.n28M92KO031003@sheep.berlios.de>

Author: gruntster
Date: 2009-03-08 23:08:47 +0100 (Sun, 08 Mar 2009)
New Revision: 4664

Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSGlobal.cpp
Log:
[script] change directory to current executing script

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSGlobal.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSGlobal.cpp	2009-03-08 22:01:46 UTC (rev 4663)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSGlobal.cpp	2009-03-08 22:08:47 UTC (rev 4664)
@@ -164,12 +164,23 @@
 	printf("Spidermonkey compiling \"%s\"...",name);
 	JSScript *pJSScript = JS_CompileFile(g_pCx, g_pObject, name);
 	printf("Done.\n");
+
 	if(pJSScript != NULL)
 	{// begin execute external file
+		char curDir[PATH_MAX + 1];
+		char scriptPath[strlen(name) + 1];
+
+		strcpy(scriptPath, name);
+		ADM_PathStripName(scriptPath);
+		getcwd(curDir, PATH_MAX);
+		chdir(scriptPath);
+
 		printf("Spidermonkey executing \"%s\"...",name);
 		JSBool ok = JS_ExecuteScript(g_pCx, g_pObject, pJSScript, &rval);
 		JS_DestroyScript(g_pCx,pJSScript);
 		printf("Done.\n");
+
+		chdir(curDir);
 	}// end execute external file
         // Run garbage collector now, it is safe
         JS_GC(g_pCx);



From gruntster at mail.berlios.de  Mon Mar  9 20:39:33 2009
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Mon, 9 Mar 2009 20:39:33 +0100
Subject: [Avidemux-svn-commit] r4665 - in
	branches/avidemux_2.5_branch_gruntster: . scripts scripts/video
Message-ID: <200903091939.n29JdXIO018149@sheep.berlios.de>

Author: gruntster
Date: 2009-03-09 20:39:26 +0100 (Mon, 09 Mar 2009)
New Revision: 4665

Added:
   branches/avidemux_2.5_branch_gruntster/scripts/
   branches/avidemux_2.5_branch_gruntster/scripts/CMakeLists.txt
   branches/avidemux_2.5_branch_gruntster/scripts/video/
   branches/avidemux_2.5_branch_gruntster/scripts/video/autoWizard.js
   branches/avidemux_2.5_branch_gruntster/scripts/video/filter.js
   branches/avidemux_2.5_branch_gruntster/scripts/video/functions.js
Modified:
   branches/avidemux_2.5_branch_gruntster/CMakeLists.txt
Log:
[script] add reusable system scripts

Modified: branches/avidemux_2.5_branch_gruntster/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/CMakeLists.txt	2009-03-08 22:08:47 UTC (rev 4664)
+++ branches/avidemux_2.5_branch_gruntster/CMakeLists.txt	2009-03-09 19:39:26 UTC (rev 4665)
@@ -199,6 +199,7 @@
 ########################################
 ADD_SUBDIRECTORY(avidemux)
 ADD_SUBDIRECTORY(po)
+ADD_SUBDIRECTORY(scripts)
 
 ########################################
 # Config Summary

Added: branches/avidemux_2.5_branch_gruntster/scripts/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/scripts/CMakeLists.txt	2009-03-08 22:08:47 UTC (rev 4664)
+++ branches/avidemux_2.5_branch_gruntster/scripts/CMakeLists.txt	2009-03-09 19:39:26 UTC (rev 4665)
@@ -0,0 +1,7 @@
+if (WIN32)
+	SET(scriptInstallDir ${CMAKE_INSTALL_PREFIX}/scripts)
+else (WIN32)
+	SET(scriptInstallDir ${CMAKE_INSTALL_PREFIX}/share/ADM_scripts)
+endif (WIN32)
+
+install(DIRECTORY . DESTINATION "${scriptInstallDir}" FILES_MATCHING PATTERN "*.js")
\ No newline at end of file

Added: branches/avidemux_2.5_branch_gruntster/scripts/video/autoWizard.js
===================================================================
--- branches/avidemux_2.5_branch_gruntster/scripts/video/autoWizard.js	2009-03-08 22:08:47 UTC (rev 4664)
+++ branches/avidemux_2.5_branch_gruntster/scripts/video/autoWizard.js	2009-03-09 19:39:26 UTC (rev 4665)
@@ -0,0 +1,39 @@
+function videoAutoWizard(title, resolutions, codecs)
+{
+    var aspectRatios = [[1, 1], [4, 3], [16, 9]];
+    var mnuResolution = new DFMenu("Resolution:");
+    var mnuSourceRatio = new DFMenu("Source Aspect Ratio:");
+    var mnuDestinationRatio = new DFMenu("Destination Aspect Ratio:");
+    var dlgWizard = new DialogFactory(title);
+    var i;
+
+    for (i = 0; i < resolutions.length; i++)
+        mnuResolution.addItem(resolutions[i][0].toString() + " x " + resolutions[i][1].toString());
+
+    for (i = 0; i < aspectRatios.length; i++)
+    {
+        mnuSourceRatio.addItem(aspectRatios[i][0].toString() + ":" + aspectRatios[i][1].toString());
+        mnuDestinationRatio.addItem(aspectRatios[i][0].toString() + ":" + aspectRatios[i][1].toString());
+    }
+    
+    if (codecs != null)
+    {
+        var mnuCodec = new DFMenu("Codec:");
+               
+        dlgWizard.addControl(mnuCodec);
+        
+        for (i = 0; i < codecs.length; i++)
+            mnuCodec.addItem(codecs[i]);
+    }
+
+    dlgWizard.addControl(mnuResolution);
+    dlgWizard.addControl(mnuSourceRatio);
+    dlgWizard.addControl(mnuDestinationRatio);
+
+    if (dlgWizard.show())
+        return [[resolutions[mnuResolution.index][0], resolutions[mnuResolution.index][1]],
+            [aspectRatios[mnuSourceRatio.index][0], aspectRatios[mnuSourceRatio.index][1]],
+            [aspectRatios[mnuDestinationRatio.index][0], aspectRatios[mnuDestinationRatio.index][1]], codecs == null ? -1 : mnuCodec.index];
+    else
+        return null;
+}
\ No newline at end of file

Added: branches/avidemux_2.5_branch_gruntster/scripts/video/filter.js
===================================================================
--- branches/avidemux_2.5_branch_gruntster/scripts/video/filter.js	2009-03-08 22:08:47 UTC (rev 4664)
+++ branches/avidemux_2.5_branch_gruntster/scripts/video/filter.js	2009-03-09 19:39:26 UTC (rev 4665)
@@ -0,0 +1,57 @@
+include("video/functions.js");
+
+function resizeAndFillVideo(targetX, targetY, sourceRatio, destinationRatio)
+{
+    var app = new Avidemux();
+    var filters = app.video.appliedFilters;
+    var width, height, fps1000;
+
+    if (filters.length > 0)
+    {
+        var lastFilter = app.video.appliedFilters[filters.length - 1];
+
+        width = lastFilter.width;
+        height = lastFilter.height;
+        fps1000 = lastFilter.fps1000;
+    }
+    else
+    {
+        width = app.video.width;
+        height = app.video.height;
+        fps1000 = app.video.fps1000;
+    }
+
+    // Resizing
+    var width = rescaleVideoDimension(width, sourceRatio, destinationRatio, getColourEncodingSystem(fps1000));
+    var rX = width / targetX;
+    var rY = height / targetY;
+    var newX;
+    var newY;
+
+    if (rX > rY)
+    {
+        // resize by X
+        newX = targetX;
+        newY = Math.round(height / rX);
+    }
+    else
+    {
+        // resize by Y
+        newY = targetY;
+        newX = Math.round(width / rY);
+    }
+
+    // resize to multiple of 4
+    newX -= newX % 4;
+    newY -= newY % 4;
+
+    if (newX != app.video.width || newY != app.video.height)
+        app.video.addFilter("mpresize", "w=" + newX, "h=" + newY, "algo=0");
+
+    // Black bars
+    var barX = targetX - newX;
+    var barY = targetY - newY;
+
+    if (barX || barY)
+        app.video.addFilter("addblack", "left=" + (barX >> 1), "right=" + (barX >> 1), "top=" + (barY >> 1), "bottom=" + (barY >> 1));
+}
\ No newline at end of file

Added: branches/avidemux_2.5_branch_gruntster/scripts/video/functions.js
===================================================================
--- branches/avidemux_2.5_branch_gruntster/scripts/video/functions.js	2009-03-08 22:08:47 UTC (rev 4664)
+++ branches/avidemux_2.5_branch_gruntster/scripts/video/functions.js	2009-03-09 19:39:26 UTC (rev 4665)
@@ -0,0 +1,38 @@
+function rescaleVideoDimension(value, sourceRatio, destinationRatio, encodingSystem)
+{
+    return Math.round(value * getPixelAspectRatio(sourceRatio, encodingSystem) / getPixelAspectRatio(destinationRatio, encodingSystem));
+}
+
+function getPixelAspectRatio(ratio, encodingSystem)
+{
+    if (ratio == "4:3")
+    {
+        if (encodingSystem == "PAL")
+            return 16 / 15;
+        else if (encodingSystem == "NTSC" || encodingSystem == "FILM")
+            return 8 / 9;
+    }
+    else if (ratio == "16:9")
+    {
+        if (encodingSystem == "PAL")
+            return 64 / 45;
+        else if (encodingSystem == "NTSC" || encodingSystem == "FILM")
+            return 32 / 27;
+    }
+
+    return 1;
+}
+
+function getColourEncodingSystem(fps1000)
+{
+    var encodingSystem = "Unknown";
+
+    if (fps1000 > 24700 && fps1000 < 25300)
+        encodingSystem = "PAL";
+    else if (fps1000 > 23676 && fps1000 < 24276)
+        encodingSystem = "FILM";
+    else if (fps1000 > 29670 && fps1000 < 30270)
+        encodingSystem = "NTSC";
+
+    return encodingSystem;
+}
\ No newline at end of file



From gruntster at mail.berlios.de  Mon Mar  9 21:10:10 2009
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Mon, 9 Mar 2009 21:10:10 +0100
Subject: [Avidemux-svn-commit] r4666 - in
	branches/avidemux_2.5_branch_gruntster/avidemux:
	ADM_core/include ADM_core/src ADM_script
Message-ID: <200903092010.n29KAADQ023313@sheep.berlios.de>

Author: gruntster
Date: 2009-03-09 21:10:03 +0100 (Mon, 09 Mar 2009)
New Revision: 4666

Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_core/include/ADM_files.h
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_core/src/ADM_fileio.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSFunctions.cpp
Log:
[script] instruct include() to look in script dir if script can't be found in current dir

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_core/include/ADM_files.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_core/include/ADM_files.h	2009-03-09 19:39:26 UTC (rev 4665)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_core/include/ADM_files.h	2009-03-09 20:10:03 UTC (rev 4666)
@@ -28,6 +28,7 @@
 /* Returns the full path relative to .avidemux dir i.e. /home/fx/... +base1/base2 needs to be deleted []*/
 char *ADM_getHomeRelativePath(const char *base1, const char *base2=NULL,const char *base3=NULL);
 char *ADM_getPluginPath(void);
+char *ADM_getScriptPath(void);
 #endif
 uint8_t buildDirectoryContent(uint32_t *outnb,const char *base, char *jobName[],int maxElems,const char *ext);
 

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_core/src/ADM_fileio.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_core/src/ADM_fileio.cpp	2009-03-09 19:39:26 UTC (rev 4665)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_core/src/ADM_fileio.cpp	2009-03-09 20:10:03 UTC (rev 4666)
@@ -353,6 +353,20 @@
 
 	return ADM_getInstallRelativePath(startDir, pluginDir, "videoEncoder");
 }
+
+char *ADM_getScriptPath(void)
+{
+#ifdef _WIN32
+	const char *startDir = "";
+	const char *scriptPath = "scripts";
+#else
+	const char *startDir = "share";
+	const char *scriptPath = "ADM_scripts";
+#endif
+
+	return ADM_getInstallRelativePath(startDir, scriptPath, NULL);
+}
+
 /*
       Get the root directory for .avidemux stuff
 ******************************************************/

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSFunctions.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSFunctions.cpp	2009-03-09 19:39:26 UTC (rev 4665)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSFunctions.cpp	2009-03-09 20:10:03 UTC (rev 4666)
@@ -423,6 +423,7 @@
 		*rval = INT_TO_JSVAL(-1);	// failure
 	return JS_TRUE;
 }// end systemExecute
+
 JSBool systemInclude(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
 {// begin systemInclude
 	// default return value
@@ -437,22 +438,38 @@
 	// make sure we haven't included this already to avoid a recursive
 	// dependency loop
 	char *pTempStr = new char[PATH_MAX+1];
+
  #ifdef __MINGW32__
  	if(_fullpath(pTempStr,pIncludeFile,PATH_MAX) == NULL)
  #else
 	if(realpath(pIncludeFile,pTempStr) == NULL)
 #endif
-	{// begin can't resolve path
+	{
 		JS_ReportError(cx, "include() can't resolve the path of \"%s\".", pIncludeFile);
+		delete pTempStr;
+
 		return JS_FALSE;
-	}// end can't resolve path
+	}
 
+	if(stat(pTempStr, &sbFileInfo) != 0)
+	{
+		char *scriptPath = ADM_getScriptPath();
+
+		strcpy(pTempStr, scriptPath);
+		strcat(pTempStr, pIncludeFile);
+		delete scriptPath;
+
+		if(stat(pTempStr, &sbFileInfo) != 0)
+		{
+			JS_ReportError(cx, "include() Can't stat \"%s\" errno(%i).", pTempStr, errno);
+			delete pTempStr;
+
+			return JS_FALSE;
+		}
+	}
+
 	std::string sRealPath = pTempStr;
-	if(stat(sRealPath.c_str() , &sbFileInfo) != 0)
-	{// begin can't stat file
-		JS_ReportError(cx, "include() Can't stat \"%s\" errno(%i).", sRealPath.c_str(), errno);
-		return JS_FALSE;
-	}// end can't stat file
+	delete pTempStr;
 
 	for(int i = 0;i < g_vIncludes.size();i++)
 	{// begin check previous includes



From gruntster at mail.berlios.de  Tue Mar 10 23:35:14 2009
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Tue, 10 Mar 2009 23:35:14 +0100
Subject: [Avidemux-svn-commit] r4667 -
	branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_gui
Message-ID: <200903102235.n2AMZE5N031605@sheep.berlios.de>

Author: gruntster
Date: 2009-03-10 23:35:06 +0100 (Tue, 10 Mar 2009)
New Revision: 4667

Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_gui/Q_gui2.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_gui/Q_gui2.h
Log:
[script] populate auto menu with contents of script dir

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_gui/Q_gui2.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_gui/Q_gui2.cpp	2009-03-09 20:10:03 UTC (rev 4666)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_gui/Q_gui2.cpp	2009-03-10 22:35:06 UTC (rev 4667)
@@ -13,8 +13,8 @@
  ***************************************************************************/
 #include "config.h"
 
-#include <QtCore/QFileInfo>
 #include <QtCore/QUrl>
+#include <QtCore/QDir>
 #include <QtGui/QKeyEvent>
 #include <QtGui/QGraphicsView>
 
@@ -53,6 +53,7 @@
 extern int A_appendAvi(const char *name);
 extern char *actual_workbench_file;
 extern void FileSel_ReadWrite(SELFILE_CB *cb, int rw, const char *name, const char *actual_workbench_file);
+extern bool A_parseECMAScript(const char *name);
 
 int SliderIsShifted=0;
 static void setupMenus(void);
@@ -306,6 +307,7 @@
 
 	/* Build the custom menu */
 	buildCustomMenu();
+	buildAutoMenu();
 
 	this->installEventFilter(this);
 	slider->installEventFilter(this);
@@ -567,6 +569,73 @@
 	printf("Custom menu built\n");
 }
 
+void MainWindow::autoMenuHandler(void)
+{
+	QObject *obj = sender();
+	QString filePath = ((QAction*)obj)->text() + ".js";
+
+	while (obj->parent() != ui.menuAuto)
+	{
+		obj = obj->parent();
+		filePath = ((QMenu*)obj)->title() + QDir::separator() + filePath;
+	}
+
+	char *scriptDir = ADM_getScriptPath();
+
+	A_parseECMAScript((QString::fromUtf8(scriptDir) + "auto" + QDir::separator() + filePath).toUtf8().constData());
+
+	delete scriptDir;
+}
+
+void MainWindow::addDirEntryToMenu(QMenu *parentMenu, QString path)
+{
+	QFileInfo info(path);
+
+	if (info.isDir())
+	{
+		QDir dir(info.path() + QDir::separator());
+
+		dir.setSorting(QDir::DirsFirst | QDir::Name);
+
+		QFileInfoList fileList = dir.entryInfoList();
+
+		for (int x = 0; x < fileList.count(); x++)
+		{
+			if (fileList[x].fileName() != "." && fileList[x].fileName() != "..")
+			{
+				QMenu *menu = parentMenu;
+
+				if (fileList[x].isDir())
+				{
+					menu = parentMenu->addMenu(QDir(fileList[x].filePath()).dirName());
+
+					addDirEntryToMenu(menu, fileList[x].filePath() + QDir::separator());
+				}
+				else
+					addDirEntryToMenu(menu, fileList[x].filePath());
+			}
+		}
+	}
+	else
+	{
+		QAction *action = new QAction(info.baseName(), parentMenu);
+
+		parentMenu->addAction(action);
+		connect(action, SIGNAL(triggered()), this, SLOT(autoMenuHandler()));
+	}
+}
+
+void MainWindow::buildAutoMenu(void)
+{
+	char *scriptDir = ADM_getScriptPath();
+	QFileInfo autoDirInfo = QFileInfo(QString::fromUtf8(scriptDir) + QString("auto") + QDir::separator());
+
+	delete scriptDir;
+
+	if (autoDirInfo.isDir())
+		addDirEntryToMenu(ui.menuAuto, autoDirInfo.filePath());
+}
+
 void MainWindow::closeEvent(QCloseEvent *event)
 {
 	HandleAction(ACT_Exit);

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_gui/Q_gui2.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_gui/Q_gui2.h	2009-03-09 20:10:03 UTC (rev 4666)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_gui/Q_gui2.h	2009-03-10 22:35:06 UTC (rev 4667)
@@ -1,8 +1,10 @@
 #ifndef Q_gui2_h
 #define Q_gui2_h
 
+#include <QtCore/QFileInfo>
 #include <QtGui/QSlider>
 #include <QtGui/QWidget>
+#include <QtGui/QMenu>
 
 #include "ADM_qslider.h"
 #include "T_thumbSlider.h"
@@ -14,15 +16,17 @@
 
 public:
 	MainWindow();
-	virtual ~MainWindow();	
+	virtual ~MainWindow();
 	void buildCustomMenu(void);
-	
+	void buildAutoMenu(void);
+
 	Ui_MainWindow ui;
 
 public slots:
 	void timeChanged(int);
 	void buttonPressed(void);
 	void custom(void);
+	void autoMenuHandler(void);
 	void toolButtonPressed(bool z);
 
 	void comboChanged(int z);
@@ -48,5 +52,6 @@
 	void dragEnterEvent(QDragEnterEvent *event);
 	void dropEvent(QDropEvent *event);
 	void closeEvent(QCloseEvent *event);
+	void addDirEntryToMenu(QMenu *parentMenu, QString path);
 };
 #endif	// Q_gui2_h



From mean at mail.berlios.de  Wed Mar 11 19:40:46 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Wed, 11 Mar 2009 19:40:46 +0100
Subject: [Avidemux-svn-commit] r4668 -
	branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/Mp4
Message-ID: <200903111840.n2BIekOd005743@sheep.berlios.de>

Author: mean
Date: 2009-03-11 19:40:45 +0100 (Wed, 11 Mar 2009)
New Revision: 4668

Modified:
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/Mp4/ADM_mp4Analyzer.cpp
Log:
[Demuxer/mov] Fix msadpcm in mov

Modified: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/Mp4/ADM_mp4Analyzer.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/Mp4/ADM_mp4Analyzer.cpp	2009-03-10 22:35:06 UTC (rev 4667)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/Mp4/ADM_mp4Analyzer.cpp	2009-03-11 18:40:45 UTC (rev 4668)
@@ -840,10 +840,20 @@
                                               left=0;
                                         }
                                         break;
+                                    
+                                    {
+                                            audioCodec(MSADPCM);
+                                            break;
+                                    }
+                                
                                     case MKFCCR('m','s',0,0x55): // why 55 ???
+                                    case MKFCCR('m','s',0,0x11): // why 11 ???
                                     case MKFCCR('m','p','4','a'):
                                     {
-                                              audioCodec(AAC);
+                                              if(entryName==MKFCCR('m','s',0,0x11))
+                                                        audioCodec(MSADPCM)
+                                                else
+                                                        audioCodec(AAC);
                                             if(left>10)
                                             {
                                               adm_atom wave(&son);
@@ -869,6 +879,7 @@
                                                           }
                                                           break;
                                                        case MKFCCR('m','s',0,0x55):
+                                                       case MKFCCR('m','s',0,0x11):
                                                         {
                                                           // We have a waveformat here
                                                           printf("[STSD]Found MS audio header:\n");



From mean at mail.berlios.de  Wed Mar 11 19:40:49 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Wed, 11 Mar 2009 19:40:49 +0100
Subject: [Avidemux-svn-commit] r4670 -
	branches/avidemux_2.6_branch_mean/avidemux
Message-ID: <200903111840.n2BIenwX005767@sheep.berlios.de>

Author: mean
Date: 2009-03-11 19:40:49 +0100 (Wed, 11 Mar 2009)
New Revision: 4670

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/gui_save.cpp
Log:
[UI] Fix audio save in raw copy

Modified: branches/avidemux_2.6_branch_mean/avidemux/gui_save.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/gui_save.cpp	2009-03-11 18:40:47 UTC (rev 4669)
+++ branches/avidemux_2.6_branch_mean/avidemux/gui_save.cpp	2009-03-11 18:40:49 UTC (rev 4670)
@@ -221,7 +221,7 @@
         printf("Audio save:Read error\n");
       	break;
       }
-      //      printf("Got : %lu\n",len2);
+      
       gauge += len;
       sampleCurrent+=samples;
       // update GUI
@@ -258,10 +258,7 @@
         \brief Save current stream (generally avi...)     in raw mode
 */
 void A_saveAudioCopy (char *name)
-{
-
-// debug audio seek
-  uint32_t len2;
+{ 
   uint32_t written, max;
   uint64_t dts;
   DIA_workingBase *work;
@@ -285,12 +282,18 @@
 
   // compute start position and duration in samples
 
-   timeStart=video_body->estimatePts (frameStart);
-   timeEnd=video_body->estimatePts (frameEnd+1);
-   currentaudiostream->goToTime (timeStart);
+   timeStart=video_body->getMarkerAPts ();
+   timeEnd=video_body->getMarkerBPts ();
+   
    duration=timeEnd-timeStart;
-   if(duration<0) duration=-duration;
-
+   if(duration<0) 
+    {
+            currentaudiostream->goToTime (timeEnd);
+            duration=-duration;
+    }else
+    {
+            currentaudiostream->goToTime (timeStart);
+    }
    duration*=currentaudiostream->getInfo()->frequency;
    duration/=1000000; // in seconds to have samples
    tgt_sample=(uint64_t)floor(duration);
@@ -324,7 +327,6 @@
   	fwrite(buffer,hold,1,out);
 	hold=0;
   }
-
   fclose (out);
   delete work;
   delete[] buffer;



From mean at mail.berlios.de  Wed Mar 11 19:41:03 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Wed, 11 Mar 2009 19:41:03 +0100
Subject: [Avidemux-svn-commit] r4671 - in
	branches/avidemux_2.6_branch_mean/avidemux: . ADM_audioParser
	ADM_audioParser/include ADM_audioParser/src
	ADM_coreAudio/include ADM_coreAudio/src
Message-ID: <200903111841.n2BIf3CP005846@sheep.berlios.de>

Author: mean
Date: 2009-03-11 19:40:53 +0100 (Wed, 11 Mar 2009)
New Revision: 4671

Added:
   branches/avidemux_2.6_branch_mean/avidemux/ADM_audioParser/
   branches/avidemux_2.6_branch_mean/avidemux/ADM_audioParser/include/
   branches/avidemux_2.6_branch_mean/avidemux/ADM_audioParser/include/ADM_a52info.h
   branches/avidemux_2.6_branch_mean/avidemux/ADM_audioParser/include/ADM_aacinfo.h
   branches/avidemux_2.6_branch_mean/avidemux/ADM_audioParser/include/ADM_dcainfo.h
   branches/avidemux_2.6_branch_mean/avidemux/ADM_audioParser/include/ADM_mp3info.h
   branches/avidemux_2.6_branch_mean/avidemux/ADM_audioParser/src/
   branches/avidemux_2.6_branch_mean/avidemux/ADM_audioParser/src/ADM_a52info.cpp
   branches/avidemux_2.6_branch_mean/avidemux/ADM_audioParser/src/ADM_aacinfo.cpp
   branches/avidemux_2.6_branch_mean/avidemux/ADM_audioParser/src/ADM_dcainfo.cpp
   branches/avidemux_2.6_branch_mean/avidemux/ADM_audioParser/src/ADM_mp3info.cpp
   branches/avidemux_2.6_branch_mean/avidemux/ADM_audioParser/src/CMakeLists.txt
Removed:
   branches/avidemux_2.6_branch_mean/avidemux/ADM_coreAudio/include/ADM_a52info.h
   branches/avidemux_2.6_branch_mean/avidemux/ADM_coreAudio/include/ADM_aacinfo.h
   branches/avidemux_2.6_branch_mean/avidemux/ADM_coreAudio/include/ADM_dcainfo.h
   branches/avidemux_2.6_branch_mean/avidemux/ADM_coreAudio/include/ADM_mp3info.h
   branches/avidemux_2.6_branch_mean/avidemux/ADM_coreAudio/src/ADM_a52info.cpp
   branches/avidemux_2.6_branch_mean/avidemux/ADM_coreAudio/src/ADM_aacinfo.cpp
   branches/avidemux_2.6_branch_mean/avidemux/ADM_coreAudio/src/ADM_dcainfo.cpp
   branches/avidemux_2.6_branch_mean/avidemux/ADM_coreAudio/src/ADM_mp3info.cpp
Log:
[Audio] Split parser

Copied: branches/avidemux_2.6_branch_mean/avidemux/ADM_audioParser/include/ADM_a52info.h (from rev 4670, branches/avidemux_2.6_branch_mean/avidemux/ADM_coreAudio/include/ADM_a52info.h)
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_coreAudio/include/ADM_a52info.h	2009-03-11 18:40:49 UTC (rev 4670)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_audioParser/include/ADM_a52info.h	2009-03-11 18:40:53 UTC (rev 4671)
@@ -0,0 +1,13 @@
+//
+// C++ Interface: ADM_a52info
+//
+// Description: 
+//
+//
+// Author: mean <fixounet at free.fr>, (C) 2004
+//
+// Copyright: See COPYING file that comes with this distribution
+//
+//
+int 	ADM_a52_syncinfo (uint8_t * buf, int * flags, int * sample_rate, int * bit_rate);
+uint8_t ADM_AC3GetInfo(uint8_t *buf, uint32_t len, uint32_t *fq, uint32_t *br, uint32_t *chan,uint32_t *syncoff)   ;

Copied: branches/avidemux_2.6_branch_mean/avidemux/ADM_audioParser/include/ADM_aacinfo.h (from rev 4670, branches/avidemux_2.6_branch_mean/avidemux/ADM_coreAudio/include/ADM_aacinfo.h)
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_coreAudio/include/ADM_aacinfo.h	2009-03-11 18:40:49 UTC (rev 4670)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_audioParser/include/ADM_aacinfo.h	2009-03-11 18:40:53 UTC (rev 4671)
@@ -0,0 +1,27 @@
+//
+//	Used to get info on a AAC/ADTS stream
+//	Some parameters can be given to use as guideline
+//
+
+#ifndef ADM__AAC__INFO
+#define ADM__AAC__INFO
+
+typedef struct AacAudioInfo
+{
+	
+	uint32_t layer;		// 0 mpeg4, 1 mpeg2 
+	uint32_t profile;	// 0 Main/1 LC
+	uint32_t samplerate;	// i.e. Frequency
+	uint32_t channels;	// # channels
+	uint32_t nbBlock;	// Packet size including header
+	uint32_t size;		// size of complete frame
+	uint32_t samples;	// # of sample in this packet
+	
+
+}AacAudioInfo;
+
+uint8_t	getAACFrameInfo(uint8_t *stream,uint32_t maxSearch, AacAudioInfo *mpegInfo,AacAudioInfo *templ,
+			uint32_t *offset);
+
+
+#endif

Copied: branches/avidemux_2.6_branch_mean/avidemux/ADM_audioParser/include/ADM_dcainfo.h (from rev 4670, branches/avidemux_2.6_branch_mean/avidemux/ADM_coreAudio/include/ADM_dcainfo.h)
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_coreAudio/include/ADM_dcainfo.h	2009-03-11 18:40:49 UTC (rev 4670)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_audioParser/include/ADM_dcainfo.h	2009-03-11 18:40:53 UTC (rev 4671)
@@ -0,0 +1,8 @@
+#ifndef ADM_DCAINFO_H
+#define ADM_DCAINFO_H
+int ADM_DCAGetInfo(uint8_t *buf, uint32_t len, uint32_t *fq, uint32_t *br, uint32_t *chan,uint32_t *syncoff,uint32_t *flags,uint32_t *nbSample);
+
+#define DTS_HEADER_SIZE (10)
+#endif
+
+

Copied: branches/avidemux_2.6_branch_mean/avidemux/ADM_audioParser/include/ADM_mp3info.h (from rev 4670, branches/avidemux_2.6_branch_mean/avidemux/ADM_coreAudio/include/ADM_mp3info.h)
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_coreAudio/include/ADM_mp3info.h	2009-03-11 18:40:49 UTC (rev 4670)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_audioParser/include/ADM_mp3info.h	2009-03-11 18:40:53 UTC (rev 4671)
@@ -0,0 +1,30 @@
+//
+//	Used to get info on a MP3 stream
+//	Some parameters can be given to use as guideline
+//
+
+#ifndef ADM__MP3__INFO
+#define ADM__MP3__INFO
+
+typedef struct MpegAudioInfo
+{
+	
+	uint32_t level;		// Mpeg 1, 2 or 2.5 (1,2 or 3)
+	uint32_t layer;		// Layer 1,2 or 3
+	uint32_t samplerate;	// i.e. Frequency
+	uint32_t bitrate;	// Bitrate in b/s
+	uint32_t size;		// Packet size including header
+	uint32_t samples;	// # of sample in this packet
+	uint32_t protect;	// protected
+        uint32_t privatebit;    // Private bit
+	uint32_t padding;	// Padding slot
+	uint32_t mode;		// 0 /1 : stereo j sterero   10 dual mono 11 single (mono)
+        uint32_t lsf;           // Used to compute frame length
+        uint32_t mode_extension;
+}MpegAudioInfo;
+
+uint8_t	getMpegFrameInfo(uint8_t *stream,uint32_t maxSearch, MpegAudioInfo *mpegInfo,MpegAudioInfo *templ,
+			uint32_t *offset);
+
+
+#endif

Copied: branches/avidemux_2.6_branch_mean/avidemux/ADM_audioParser/src/ADM_a52info.cpp (from rev 4670, branches/avidemux_2.6_branch_mean/avidemux/ADM_coreAudio/src/ADM_a52info.cpp)
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_coreAudio/src/ADM_a52info.cpp	2009-03-11 18:40:49 UTC (rev 4670)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_audioParser/src/ADM_a52info.cpp	2009-03-11 18:40:53 UTC (rev 4671)
@@ -0,0 +1,152 @@
+//
+// C++ Implementation: ADM_a52info
+//
+// Description:
+//
+//
+// Author: mean <fixounet at free.fr>, (C) 2004
+//
+// Copyright: See COPYING file that comes with this distribution
+//
+//
+
+
+#include "ADM_default.h"
+
+#include "ADM_a52info.h"
+
+#define A52_CHANNEL 0
+#define A52_MONO 1
+#define A52_STEREO 2
+#define A52_3F 3
+#define A52_2F1R 4
+#define A52_3F1R 5
+#define A52_2F2R 6
+#define A52_3F2R 7
+#define A52_CHANNEL1 8
+#define A52_CHANNEL2 9
+#define A52_DOLBY 10
+#define A52_CHANNEL_MASK 15
+
+#define A52_LFE 16
+#define A52_ADJUST_LEVEL 32
+
+static uint8_t halfrate[12] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3};
+
+static int rate[] = { 32,  40,  48,  56,  64,  80,  96, 112,
+			 128, 160, 192, 224, 256, 320, 384, 448,
+			 512, 576, 640};
+static uint8_t lfeon[8] = {0x10, 0x10, 0x04, 0x04, 0x04, 0x01, 0x04, 0x01};
+
+// Borrowed from a52dec
+// Return packed size on success, 0 on failure
+// Need at least 6 bytes incoming
+
+int ADM_a52_syncinfo (uint8_t * buf, int * flags, int * sample_rate, int * bit_rate)
+{
+    int frmsizecod;
+    int bitrate;
+    int half;
+    int acmod;
+
+    if ((buf[0] != 0x0b) || (buf[1] != 0x77))	/* syncword */
+	return 0;
+
+    if (buf[5] >= 0x60)		/* bsid >= 12 */
+	return 0;
+    half = halfrate[buf[5] >> 3];
+
+    /* acmod, dsurmod and lfeon */
+    acmod = buf[6] >> 5;
+    *flags = ((((buf[6] & 0xf8) == 0x50) ? A52_DOLBY : acmod) |
+	      ((buf[6] & lfeon[acmod]) ? A52_LFE : 0));
+
+    frmsizecod = buf[4] & 63;
+    if (frmsizecod >= 38)
+	return 0;
+    bitrate = rate [frmsizecod >> 1];
+    *bit_rate = (bitrate * 1000) >> half;
+
+    switch (buf[4] & 0xc0) {
+    case 0:
+	*sample_rate = 48000 >> half;
+	return 4 * bitrate;
+    case 0x40:
+	*sample_rate = 44100 >> half;
+	return 2 * (320 * bitrate / 147 + (frmsizecod & 1));
+    case 0x80:
+	*sample_rate = 32000 >> half;
+	return 6 * bitrate;
+    default:
+	return 0;
+    }
+}
+//
+//	Exctract infos from AC3 stream (used when muxing with external AC3)
+//
+uint8_t ADM_AC3GetInfo(uint8_t *buf, uint32_t len, uint32_t *fq, uint32_t *br, uint32_t *chan,uint32_t *syncoff)
+{
+uint32_t l;
+int ibr,ifq,flags;
+uint32_t of=0;
+
+	*syncoff=of=0;
+     	printf("\n Syncing on %d \n",len);
+	// Search for startcode
+	// 0x0b 0x77
+	while(1)
+	{
+		 if(len<7)
+		 {
+		 	printf("Not enough info to find a52 syncword\n");
+		 	return 0;
+		 }
+		 if( *buf!=0x0b || *(buf+1)!=0x77)
+		 {
+		 	len--;
+			buf++;
+			of++;
+			continue;
+		 }
+		 // Try to get syncinfo
+	        l=ADM_a52_syncinfo (buf,&flags, &ifq, &ibr);
+		if(!l)
+		{
+			len--;
+			buf++;
+			of++;
+			printf("Sync failed..continuing\n");
+			continue;
+		}
+		printf("Sync found at offset %"LU"\n",of);
+		*syncoff=of;
+		*fq=(uint32_t)ifq;
+		*br=(uint32_t)ibr>>3;
+		switch (flags & A52_CHANNEL_MASK) {
+			case A52_MONO:
+				*chan = 1;
+			break;
+			case A52_STEREO:
+			case A52_DOLBY:
+				*chan = 2;
+			break;
+			case A52_3F:
+			case A52_2F1R:
+				*chan = 3;
+			break;
+			case A52_3F1R:
+			case A52_2F2R:
+				*chan = 4;
+			break;
+			case A52_3F2R:
+				*chan = 5;
+			break;
+			default:
+				ADM_assert(0);
+		}
+		if (flags & A52_LFE)
+			(*chan)++;
+		return 1;
+	}
+	return 0;
+}

Copied: branches/avidemux_2.6_branch_mean/avidemux/ADM_audioParser/src/ADM_aacinfo.cpp (from rev 4670, branches/avidemux_2.6_branch_mean/avidemux/ADM_coreAudio/src/ADM_aacinfo.cpp)
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_coreAudio/src/ADM_aacinfo.cpp	2009-03-11 18:40:49 UTC (rev 4670)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_audioParser/src/ADM_aacinfo.cpp	2009-03-11 18:40:53 UTC (rev 4671)
@@ -0,0 +1,138 @@
+//
+// C++ Implementation: ADM_aacInfo
+//
+// Description: 
+//		Decode an aac frame an fill the info field
+//			The second is a template to check we do not do bogus frame detection
+//
+// Author: mean <fixounet at free.fr>, (C) 2004
+//
+// Copyright: See COPYING file that comes with this distribution
+//	
+//
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+
+#include "ADM_default.h"
+#include <math.h>
+
+
+#include "ADM_default.h"
+//#include "aviaudio.hxx"
+#include "ADM_aacinfo.h"
+
+
+static 	uint32_t aacBitrate[16]=
+{
+	96000, 88200, 64000, 48000,
+	44100, 32000, 24000, 22050,
+	16000, 12000, 11025,  8000,
+	0,     0,     0,     0 
+};
+/*
+[0]
+	12 bits 111111	0xFC Sync tag
+	
+	1		layer 1 Mpeg2 0 Mpeg4
+	2		00
+	1		prot : 1 absent 0 present
+	
+[2]/16 bits	
+	2		profile  00 main/01 LC
+	4		sampling index
+	1		private
+	
+	1		channel
+[3]/24 bits
+	2               channel (cont'ed)
+	
+	1		original
+	1		Home
+-------------------------------------	
+	Sum=28 bits
+	
+	
+	1		copyriht
+	1		copyright id 
+	2               *** AAC frame length (including headers)
+[4]
+        8		*** AAC frame length (including headers)
+[5]
+        3		*** AAC frame length (including headers)
+	5		Buffer fullness 0x7FF = vbr
+[6]
+	6		Buffer fullness 0x7FF = vbr
+	2		nb raw frame
+	
+	28 bits
+	
+	-- total = 56 bits = 8 bytes
+	
+	16		crc
+	
+*/
+
+uint8_t	getAACFrameInfo(uint8_t *stream,uint32_t maxSearch, AacAudioInfo *mpegInfo,AacAudioInfo *templ,uint32_t *offset)
+{
+uint32_t start=0,found=0,part;
+uint8_t  a[8];
+uint32_t nfq,fqindex,brindex,index,nbframe=0;
+			memset(mpegInfo,0,sizeof(*mpegInfo));
+			memcpy(a+1,stream,7);
+			do
+			{
+				
+				memmove(a,a+1,7);
+				a[7]=stream[start+7];
+				if(start>=maxSearch-7) break;
+				start++;
+				if(a[0]==0xff && ((a[1]&0xF6)==0xF0))
+				{
+					// Layer
+                                        part=a[1]&0xf;
+					mpegInfo->layer=(part>>3);	
+					if(part & 0x6) continue;
+					
+					mpegInfo->profile=a[2]>>6;
+					mpegInfo->samplerate=aacBitrate[(a[2]>>2) & 0xF];
+					mpegInfo->channels=((a[2]&1)<<2)+(a[3]>>6);
+					nbframe=(a[6]>>6)&3;
+					nbframe++;
+					mpegInfo->size=((a[3]&3)<<11)
+							+((a[4])<<3)
+							+((a[5]>>5));
+						
+					if(!mpegInfo->samplerate) continue;
+					
+					found=1;
+				}
+				
+			}while(!found && start<maxSearch-4);
+			if(!found)
+				{	
+					return 0;
+				}
+			*offset=start-1;
+			printf("AAC Frame found at offset :%u layer:%u profile:%u samperate:%u channels:%u size:%u nbBlock:%u\n",
+					*offset,
+					mpegInfo->layer,
+					mpegInfo->profile, 
+					mpegInfo->samplerate,
+					mpegInfo->channels,
+					mpegInfo->size,
+					nbframe);
+			return 1;
+			
+
+	
+
+}
+//____________
+

Copied: branches/avidemux_2.6_branch_mean/avidemux/ADM_audioParser/src/ADM_dcainfo.cpp (from rev 4670, branches/avidemux_2.6_branch_mean/avidemux/ADM_coreAudio/src/ADM_dcainfo.cpp)
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_coreAudio/src/ADM_dcainfo.cpp	2009-03-11 18:40:49 UTC (rev 4670)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_audioParser/src/ADM_dcainfo.cpp	2009-03-11 18:40:53 UTC (rev 4671)
@@ -0,0 +1,109 @@
+/**
+
+        \file ADM_dcainfo
+        \brief extract info from DTS/DCA streams
+        Author: mean <fixounet at free.fr>, (C) 2004
+        Code very derived from libdca
+
+*/
+#include "ADM_default.h"
+#include "ADM_dcainfo.h"
+#define ADM_NO_CONFIG_H
+extern "C"
+{
+#include "ADM_libraries/ADM_ffmpeg/libavutil/common.h"
+#include "ADM_libraries/ADM_ffmpeg/libavutil/bswap.h"
+#include "ADM_libraries/ADM_ffmpeg/ADM_lavcodec/bitstream.h"
+
+}
+
+/*
+        Borrowed from libdca
+*/
+static const int dts_sample_rates[] =
+{
+    0, 8000, 16000, 32000, 0, 0, 11025, 22050, 44100, 0, 0,
+    12000, 24000, 48000, 96000, 192000
+};
+
+static const int dts_bit_rates[] =
+{
+    32000, 56000, 64000, 96000, 112000, 128000,
+    192000, 224000, 256000, 320000, 384000,
+    448000, 512000, 576000, 640000, 768000,
+    896000, 1024000, 1152000, 1280000, 1344000,
+    1408000, 1411200, 1472000, 1536000, 1920000,
+    2048000, 3072000, 3840000, 1/*open*/, 2/*variable*/, 3/*lossless*/
+};
+
+static const uint8_t dts_channels[] =
+{
+    1, 2, 2, 2, 2, 3, 3, 4, 4, 5, 6, 6, 6, 7, 8, 8
+};
+
+/*
+    Return frame size
+*/
+int  ADM_DCAGetInfo(uint8_t *buf, uint32_t len, uint32_t *fq, uint32_t *br, uint32_t *chan,uint32_t *syncoff,uint32_t *flagso,uint32_t *nbSample)
+{
+uint8_t *end=buf+len-4-DTS_HEADER_SIZE;
+uint8_t *cur=buf-1;
+uint32_t size,len1,len2,flags,sr,framesize=0,index,nbBlocks;
+             // Assume 16 bits big endian
+            // Search for 7F FE 80 01 as sync start
+            *syncoff=0;
+            while(cur<end)
+            {
+                cur++;
+                if(*cur!=0x7F) continue;
+                if(cur[1]!=0xfe) continue;
+                if(cur[2]!=0x80) continue;
+                if(cur[3]!=0x01) continue;
+                // ok we got a starcode
+                // State :      32 bits, already got them
+                // Frame type   1 
+                // Sample Deficit 5
+                // CRC present  1
+                // Frame length  7
+                // Frame Size 14
+                // **** Inefficient ! ****
+                GetBitContext s;
+                init_get_bits( &s,cur, (end-cur)*8);
+                skip_bits(&s,32);
+                skip_bits(&s,1);
+                skip_bits(&s,5);
+                skip_bits(&s,1);
+                //Nb Samples
+                nbBlocks=(get_bits(&s,7)+1);
+                // Frame size in bit
+                len2=get_bits(&s,14);
+                framesize=len2+1;
+                //
+                //  
+                //
+                flags=get_bits(&s,6);
+                *flagso=flags;
+                index=get_bits(&s,4); 
+                *fq=dts_sample_rates[index];
+                index=get_bits(&s,5); 
+                *br=dts_bit_rates[index];
+#if 0
+                printf("[dts]Flags  :%u\n",flags);
+                printf("[dts]Fq  :%u\n",*fq);
+                printf("[dts]br  :%u\n",*br);
+                printf("[dts]len1  :%u\n",len1);
+                printf("[dts]len2  :%u\n",len2);
+#endif
+                *syncoff=cur-buf;
+                if(*syncoff) printf("[dts] Dropped %u bytes\n",*syncoff);
+                *chan=dts_channels[flags & 0xf];
+//                if(*chan==5 && (flags & 0X80)) *chan++;
+                *nbSample=nbBlocks*32;
+                return framesize;
+                
+                
+            }
+            printf("[DTS] Cannot find sync\n");
+	      return 0;
+}
+

Copied: branches/avidemux_2.6_branch_mean/avidemux/ADM_audioParser/src/ADM_mp3info.cpp (from rev 4670, branches/avidemux_2.6_branch_mean/avidemux/ADM_coreAudio/src/ADM_mp3info.cpp)
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_coreAudio/src/ADM_mp3info.cpp	2009-03-11 18:40:49 UTC (rev 4670)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_audioParser/src/ADM_mp3info.cpp	2009-03-11 18:40:53 UTC (rev 4671)
@@ -0,0 +1,199 @@
+//
+// C++ Implementation: ADM_MP3Info
+//
+// Description:
+//		Decode an mp3 frame an fill the info field
+//			The second is a template to check we do not do bogus frame detection
+//
+// Author: mean <fixounet at free.fr>, (C) 2004
+//
+// Copyright: See COPYING file that comes with this distribution
+//
+//
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+
+#include <math.h>
+
+
+#include "ADM_default.h"
+
+#include "ADM_mp3info.h"
+
+static  uint32_t MP3Fq[4] = { 44100, 48000, 32000, 0 };
+static uint32_t MP2Fq[4] = { 22050, 24000, 16000, 0 };
+static uint32_t Bitrate[8][16]=
+{
+	// Level 1 / Layer 0
+	{0,0,0,0,0,0,0,0   ,0,0,0,0,0,0,0,0},
+	// Level 1/ Layer 1
+	{0,32,64,96,128,160,192,224   ,256,288,320,352,384,416,448,0},
+	// Level 1/Layer 2
+	{ 0, 32, 48, 56,64, 80, 96, 112,     128, 160, 192, 224,   256, 320, 384, 0},
+	//Level 1 / Layer 3
+	{ 0, 32, 40, 48, 56, 64, 80, 96,         112, 128, 160, 192,  224, 256, 320, 0},
+	// Level 2/Layer 0
+	{0,0,0,0,0,0,0,0   ,0,0,0,0,0,0,0,0},
+	// Level 2 Layer 1
+	{ 0, 32, 48, 56,64, 80, 96, 112,          128, 144, 160,176,  192, 224, 256, 0},
+	// Level 2 Layer 2
+	{ 0, 8, 16, 24,  32, 40, 48, 56,    64, 80, 96, 112,    128, 144, 160, 0 },
+	// Id for Layer 3
+	{ 0, 8, 16, 24,  32, 40, 48, 56,    64, 80, 96, 112,    128, 144, 160, 0 },
+};
+
+
+uint8_t	getMpegFrameInfo(uint8_t *stream,uint32_t maxSearch, MpegAudioInfo *mpegInfo,MpegAudioInfo *templ,uint32_t *offset)
+{
+uint32_t start=0,found=0;
+uint8_t  a[4];
+uint32_t nfq,fqindex,brindex,index;
+			memcpy(a+1,stream,3);
+			do
+			{
+
+				memmove(a,a+1,3);
+				a[3]=stream[start+3];
+				if(start>=maxSearch-3) break;
+				start++;
+				if(a[0]==0xff && ((a[1]&0xF0)==0xF0))
+				{
+					// Layer
+					mpegInfo->layer=4-(a[1]>>1)&3;
+					mpegInfo->level=4-(a[1]>>3)&3;
+					if(mpegInfo->level==3) continue;
+					if(mpegInfo->level==4) mpegInfo->level=3;
+					mpegInfo->protect=(a[1]&1)^1;
+					mpegInfo->padding=(a[2]>>1)&1;
+                                        mpegInfo->privatebit=(a[2]&1);
+					mpegInfo->mode=(a[3])>>6;
+                                        mpegInfo->mode_extension=((a[3])>>4)&3;
+
+					fqindex=(a[2]>>2)&3;
+					brindex=(a[2]>>4);
+
+					// Remove impossible case
+					if(mpegInfo->layer==0) continue;
+					// Check fq
+                                        if((a[1]>>4)&1)
+                                        {
+                                          mpegInfo->lsf=0;
+                                        }
+                                        else
+                                          mpegInfo->lsf=1;
+                                        //
+					switch(mpegInfo->level)
+					{
+						case 1: mpegInfo->samplerate=MP3Fq[fqindex];break;
+						case 2: mpegInfo->samplerate=MP2Fq[fqindex];break;
+						case 3: mpegInfo->samplerate=MP2Fq[fqindex]>>1;break;
+						default: mpegInfo->samplerate=0;break;
+					}
+					// impossible fq
+					if(!mpegInfo->samplerate) continue;
+					// Bitrate now
+
+					// Compute bitrate
+					switch(mpegInfo->level)
+					{
+						case 2:
+						case 3:
+							index=4+mpegInfo->layer;
+							break;
+						case 1:
+							index=mpegInfo->layer;
+							break;
+						default:
+							continue;
+					}
+
+					mpegInfo->bitrate=Bitrate[index][brindex];
+					if(!mpegInfo->bitrate) continue;
+
+					// Check consistency
+					if(templ)
+					{
+						if(templ->samplerate!=mpegInfo->samplerate)
+                                                {
+                                                  printf("[MP3]samplerate does not match\n");
+                                                  continue;
+                                                }
+
+					}
+					found=1;
+				}
+
+			}while(!found && start<maxSearch-4);
+			if(!found)
+				{
+					return 0;
+				}
+/*	*/
+			// Sample in the packet
+			if(mpegInfo->level==1)
+			{
+				if(1==mpegInfo->layer)
+					mpegInfo->samples=384;
+				else
+					mpegInfo->samples=1152;
+				*offset=start-1;
+			}
+			else
+			{	// Mpeg2/2.5
+				if(1==mpegInfo->layer)
+					mpegInfo->samples=384;
+				else
+					mpegInfo->samples=576;
+				*offset=start-1;
+
+			}
+
+			// Packet size
+			//L1:FrameLengthInBytes = (12 * BitRate / SampleRate + Padding) * 4
+
+			switch(mpegInfo->layer)
+			{
+				case 1:
+					mpegInfo->size=((12*1000*mpegInfo->bitrate)/mpegInfo->samplerate)
+								+mpegInfo->padding;
+					mpegInfo->size=mpegInfo->size*4;
+					break;
+				default:
+				//FrameLengthInBytes = 144 * BitRate / SampleRate + Padding
+                                  uint32_t slot_per_frame;
+                                        if(mpegInfo->layer==3 && mpegInfo->level==2)  slot_per_frame=72;
+                                                else slot_per_frame=144;
+                                        mpegInfo->size=(slot_per_frame*mpegInfo->bitrate*1000)/mpegInfo->samplerate;
+					mpegInfo->size+=mpegInfo->padding;
+			}
+			if(*offset)
+				{
+					printf("MP3: Skipped %"LU" bytes\n",*offset);
+
+				}
+#if 0
+			printf("%02x %02x %02x %02x\n",a[0],a[1],a[2],a[3]);
+			printf("Packet found : at :%d level:%d layer:%d fq:%d bitrate:%d mode:%d\n",
+					start-1,mpegInfo->level,mpegInfo->layer,mpegInfo->samplerate,
+					mpegInfo->bitrate,mpegInfo->mode);
+                        printf("Private :%d cop:%d ext:%d ",mpegInfo->privatebit,
+                               0,mpegInfo->mode_extension);
+			printf("Padd:%lu, crc on:%lu size:%lu\n",mpegInfo->padding,mpegInfo->protect,
+								mpegInfo->size);
+#endif
+
+			return 1;
+
+
+
+
+}
+//____________
+

Added: branches/avidemux_2.6_branch_mean/avidemux/ADM_audioParser/src/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_audioParser/src/CMakeLists.txt	2009-03-11 18:40:49 UTC (rev 4670)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_audioParser/src/CMakeLists.txt	2009-03-11 18:40:53 UTC (rev 4671)
@@ -0,0 +1,32 @@
+
+SET(ADMaudioCore_SRCS
+ADM_audioUtils.cpp
+audioencoder.cpp
+ADM_audioFilter.cpp
+ADM_audioResample.cpp
+ADM_audioStream.cpp
+ADM_audioStreamBuffered.cpp
+ADM_audioStreamMP3.cpp
+ADM_audioStreamAC3.cpp
+ADM_libsamplerate/samplerate.c
+ADM_libsamplerate/src_linear.c
+ADM_libsamplerate/src_sinc.c
+ADM_libsamplerate/src_zoh.c
+ADM_aacinfo.cpp 
+ADM_mp3info.cpp  
+ADM_a52info.cpp 
+ADM_dcainfo.cpp  
+)	
+#*************************************************
+ADD_DEFINITIONS( "-DADM_LEGACY_PROGGY")
+ADD_DEFINITIONS( "-DHAVE_LRINT -DHAVE_LRINTF ")
+ADD_DEFINITIONS( "-DCPU_CLIPS_POSITIVE=0 -DCPU_CLIPS_NEGATIVE=0")
+ADD_DEFINITIONS( "-I${CMAKE_CURRENT_SOURCE_DIR} ")
+ADD_DEFINITIONS( "-DPACKAGE=`"SRC`"")
+ADD_DEFINITIONS( "-DVERSION=`"0.1.4`"")
+#*************************************************
+ADD_LIBRARY(ADM_coreAudio SHARED ${ADMaudioCore_SRCS})
+INCLUDE_DIRECTORIES(${CMAKE_SOURCE_DIR}/avidemux/ADM_coreAudio/include)
+TARGET_LINK_LIBRARIES(ADM_coreAudio ADM_core ADM_coreUI)
+
+INSTALL(TARGETS ADM_coreAudio RUNTIME DESTINATION ${BIN_DIR}  LIBRARY DESTINATION lib  ARCHIVE DESTINATION lib)

Deleted: branches/avidemux_2.6_branch_mean/avidemux/ADM_coreAudio/include/ADM_a52info.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_coreAudio/include/ADM_a52info.h	2009-03-11 18:40:49 UTC (rev 4670)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_coreAudio/include/ADM_a52info.h	2009-03-11 18:40:53 UTC (rev 4671)
@@ -1,13 +0,0 @@
-//
-// C++ Interface: ADM_a52info
-//
-// Description: 
-//
-//
-// Author: mean <fixounet at free.fr>, (C) 2004
-//
-// Copyright: See COPYING file that comes with this distribution
-//
-//
-int 	ADM_a52_syncinfo (uint8_t * buf, int * flags, int * sample_rate, int * bit_rate);
-uint8_t ADM_AC3GetInfo(uint8_t *buf, uint32_t len, uint32_t *fq, uint32_t *br, uint32_t *chan,uint32_t *syncoff)   ;

Deleted: branches/avidemux_2.6_branch_mean/avidemux/ADM_coreAudio/include/ADM_aacinfo.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_coreAudio/include/ADM_aacinfo.h	2009-03-11 18:40:49 UTC (rev 4670)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_coreAudio/include/ADM_aacinfo.h	2009-03-11 18:40:53 UTC (rev 4671)
@@ -1,27 +0,0 @@
-//
-//	Used to get info on a AAC/ADTS stream
-//	Some parameters can be given to use as guideline
-//
-
-#ifndef ADM__AAC__INFO
-#define ADM__AAC__INFO
-
-typedef struct AacAudioInfo
-{
-	
-	uint32_t layer;		// 0 mpeg4, 1 mpeg2 
-	uint32_t profile;	// 0 Main/1 LC
-	uint32_t samplerate;	// i.e. Frequency
-	uint32_t channels;	// # channels
-	uint32_t nbBlock;	// Packet size including header
-	uint32_t size;		// size of complete frame
-	uint32_t samples;	// # of sample in this packet
-	
-
-}AacAudioInfo;
-
-uint8_t	getAACFrameInfo(uint8_t *stream,uint32_t maxSearch, AacAudioInfo *mpegInfo,AacAudioInfo *templ,
-			uint32_t *offset);
-
-
-#endif

Deleted: branches/avidemux_2.6_branch_mean/avidemux/ADM_coreAudio/include/ADM_dcainfo.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_coreAudio/include/ADM_dcainfo.h	2009-03-11 18:40:49 UTC (rev 4670)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_coreAudio/include/ADM_dcainfo.h	2009-03-11 18:40:53 UTC (rev 4671)
@@ -1,8 +0,0 @@
-#ifndef ADM_DCAINFO_H
-#define ADM_DCAINFO_H
-int ADM_DCAGetInfo(uint8_t *buf, uint32_t len, uint32_t *fq, uint32_t *br, uint32_t *chan,uint32_t *syncoff,uint32_t *flags,uint32_t *nbSample);
-
-#define DTS_HEADER_SIZE (10)
-#endif
-
-

Deleted: branches/avidemux_2.6_branch_mean/avidemux/ADM_coreAudio/include/ADM_mp3info.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_coreAudio/include/ADM_mp3info.h	2009-03-11 18:40:49 UTC (rev 4670)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_coreAudio/include/ADM_mp3info.h	2009-03-11 18:40:53 UTC (rev 4671)
@@ -1,30 +0,0 @@
-//
-//	Used to get info on a MP3 stream
-//	Some parameters can be given to use as guideline
-//
-
-#ifndef ADM__MP3__INFO
-#define ADM__MP3__INFO
-
-typedef struct MpegAudioInfo
-{
-	
-	uint32_t level;		// Mpeg 1, 2 or 2.5 (1,2 or 3)
-	uint32_t layer;		// Layer 1,2 or 3
-	uint32_t samplerate;	// i.e. Frequency
-	uint32_t bitrate;	// Bitrate in b/s
-	uint32_t size;		// Packet size including header
-	uint32_t samples;	// # of sample in this packet
-	uint32_t protect;	// protected
-        uint32_t privatebit;    // Private bit
-	uint32_t padding;	// Padding slot
-	uint32_t mode;		// 0 /1 : stereo j sterero   10 dual mono 11 single (mono)
-        uint32_t lsf;           // Used to compute frame length
-        uint32_t mode_extension;
-}MpegAudioInfo;
-
-uint8_t	getMpegFrameInfo(uint8_t *stream,uint32_t maxSearch, MpegAudioInfo *mpegInfo,MpegAudioInfo *templ,
-			uint32_t *offset);
-
-
-#endif

Deleted: branches/avidemux_2.6_branch_mean/avidemux/ADM_coreAudio/src/ADM_a52info.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_coreAudio/src/ADM_a52info.cpp	2009-03-11 18:40:49 UTC (rev 4670)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_coreAudio/src/ADM_a52info.cpp	2009-03-11 18:40:53 UTC (rev 4671)
@@ -1,152 +0,0 @@
-//
-// C++ Implementation: ADM_a52info
-//
-// Description:
-//
-//
-// Author: mean <fixounet at free.fr>, (C) 2004
-//
-// Copyright: See COPYING file that comes with this distribution
-//
-//
-
-
-#include "ADM_default.h"
-
-#include "ADM_a52info.h"
-
-#define A52_CHANNEL 0
-#define A52_MONO 1
-#define A52_STEREO 2
-#define A52_3F 3
-#define A52_2F1R 4
-#define A52_3F1R 5
-#define A52_2F2R 6
-#define A52_3F2R 7
-#define A52_CHANNEL1 8
-#define A52_CHANNEL2 9
-#define A52_DOLBY 10
-#define A52_CHANNEL_MASK 15
-
-#define A52_LFE 16
-#define A52_ADJUST_LEVEL 32
-
-static uint8_t halfrate[12] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3};
-
-static int rate[] = { 32,  40,  48,  56,  64,  80,  96, 112,
-			 128, 160, 192, 224, 256, 320, 384, 448,
-			 512, 576, 640};
-static uint8_t lfeon[8] = {0x10, 0x10, 0x04, 0x04, 0x04, 0x01, 0x04, 0x01};
-
-// Borrowed from a52dec
-// Return packed size on success, 0 on failure
-// Need at least 6 bytes incoming
-
-int ADM_a52_syncinfo (uint8_t * buf, int * flags, int * sample_rate, int * bit_rate)
-{
-    int frmsizecod;
-    int bitrate;
-    int half;
-    int acmod;
-
-    if ((buf[0] != 0x0b) || (buf[1] != 0x77))	/* syncword */
-	return 0;
-
-    if (buf[5] >= 0x60)		/* bsid >= 12 */
-	return 0;
-    half = halfrate[buf[5] >> 3];
-
-    /* acmod, dsurmod and lfeon */
-    acmod = buf[6] >> 5;
-    *flags = ((((buf[6] & 0xf8) == 0x50) ? A52_DOLBY : acmod) |
-	      ((buf[6] & lfeon[acmod]) ? A52_LFE : 0));
-
-    frmsizecod = buf[4] & 63;
-    if (frmsizecod >= 38)
-	return 0;
-    bitrate = rate [frmsizecod >> 1];
-    *bit_rate = (bitrate * 1000) >> half;
-
-    switch (buf[4] & 0xc0) {
-    case 0:
-	*sample_rate = 48000 >> half;
-	return 4 * bitrate;
-    case 0x40:
-	*sample_rate = 44100 >> half;
-	return 2 * (320 * bitrate / 147 + (frmsizecod & 1));
-    case 0x80:
-	*sample_rate = 32000 >> half;
-	return 6 * bitrate;
-    default:
-	return 0;
-    }
-}
-//
-//	Exctract infos from AC3 stream (used when muxing with external AC3)
-//
-uint8_t ADM_AC3GetInfo(uint8_t *buf, uint32_t len, uint32_t *fq, uint32_t *br, uint32_t *chan,uint32_t *syncoff)
-{
-uint32_t l;
-int ibr,ifq,flags;
-uint32_t of=0;
-
-	*syncoff=of=0;
-     	printf("\n Syncing on %d \n",len);
-	// Search for startcode
-	// 0x0b 0x77
-	while(1)
-	{
-		 if(len<7)
-		 {
-		 	printf("Not enough info to find a52 syncword\n");
-		 	return 0;
-		 }
-		 if( *buf!=0x0b || *(buf+1)!=0x77)
-		 {
-		 	len--;
-			buf++;
-			of++;
-			continue;
-		 }
-		 // Try to get syncinfo
-	        l=ADM_a52_syncinfo (buf,&flags, &ifq, &ibr);
-		if(!l)
-		{
-			len--;
-			buf++;
-			of++;
-			printf("Sync failed..continuing\n");
-			continue;
-		}
-		printf("Sync found at offset %"LU"\n",of);
-		*syncoff=of;
-		*fq=(uint32_t)ifq;
-		*br=(uint32_t)ibr>>3;
-		switch (flags & A52_CHANNEL_MASK) {
-			case A52_MONO:
-				*chan = 1;
-			break;
-			case A52_STEREO:
-			case A52_DOLBY:
-				*chan = 2;
-			break;
-			case A52_3F:
-			case A52_2F1R:
-				*chan = 3;
-			break;
-			case A52_3F1R:
-			case A52_2F2R:
-				*chan = 4;
-			break;
-			case A52_3F2R:
-				*chan = 5;
-			break;
-			default:
-				ADM_assert(0);
-		}
-		if (flags & A52_LFE)
-			(*chan)++;
-		return 1;
-	}
-	return 0;
-}

Deleted: branches/avidemux_2.6_branch_mean/avidemux/ADM_coreAudio/src/ADM_aacinfo.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_coreAudio/src/ADM_aacinfo.cpp	2009-03-11 18:40:49 UTC (rev 4670)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_coreAudio/src/ADM_aacinfo.cpp	2009-03-11 18:40:53 UTC (rev 4671)
@@ -1,138 +0,0 @@
-//
-// C++ Implementation: ADM_aacInfo
-//
-// Description: 
-//		Decode an aac frame an fill the info field
-//			The second is a template to check we do not do bogus frame detection
-//
-// Author: mean <fixounet at free.fr>, (C) 2004
-//
-// Copyright: See COPYING file that comes with this distribution
-//	
-//
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-
-#include "ADM_default.h"
-#include <math.h>
-
-
-#include "ADM_default.h"
-//#include "aviaudio.hxx"
-#include "ADM_aacinfo.h"
-
-
-static 	uint32_t aacBitrate[16]=
-{
-	96000, 88200, 64000, 48000,
-	44100, 32000, 24000, 22050,
-	16000, 12000, 11025,  8000,
-	0,     0,     0,     0 
-};
-/*
-[0]
-	12 bits 111111	0xFC Sync tag
-	
-	1		layer 1 Mpeg2 0 Mpeg4
-	2		00
-	1		prot : 1 absent 0 present
-	
-[2]/16 bits	
-	2		profile  00 main/01 LC
-	4		sampling index
-	1		private
-	
-	1		channel
-[3]/24 bits
-	2               channel (cont'ed)
-	
-	1		original
-	1		Home
--------------------------------------	
-	Sum=28 bits
-	
-	
-	1		copyriht
-	1		copyright id 
-	2               *** AAC frame length (including headers)
-[4]
-        8		*** AAC frame length (including headers)
-[5]
-        3		*** AAC frame length (including headers)
-	5		Buffer fullness 0x7FF = vbr
-[6]
-	6		Buffer fullness 0x7FF = vbr
-	2		nb raw frame
-	
-	28 bits
-	
-	-- total = 56 bits = 8 bytes
-	
-	16		crc
-	
-*/
-
-uint8_t	getAACFrameInfo(uint8_t *stream,uint32_t maxSearch, AacAudioInfo *mpegInfo,AacAudioInfo *templ,uint32_t *offset)
-{
-uint32_t start=0,found=0,part;
-uint8_t  a[8];
-uint32_t nfq,fqindex,brindex,index,nbframe=0;
-			memset(mpegInfo,0,sizeof(*mpegInfo));
-			memcpy(a+1,stream,7);
-			do
-			{
-				
-				memmove(a,a+1,7);
-				a[7]=stream[start+7];
-				if(start>=maxSearch-7) break;
-				start++;
-				if(a[0]==0xff && ((a[1]&0xF6)==0xF0))
-				{
-					// Layer
-                                        part=a[1]&0xf;
-					mpegInfo->layer=(part>>3);	
-					if(part & 0x6) continue;
-					
-					mpegInfo->profile=a[2]>>6;
-					mpegInfo->samplerate=aacBitrate[(a[2]>>2) & 0xF];
-					mpegInfo->channels=((a[2]&1)<<2)+(a[3]>>6);
-					nbframe=(a[6]>>6)&3;
-					nbframe++;
-					mpegInfo->size=((a[3]&3)<<11)
-							+((a[4])<<3)
-							+((a[5]>>5));
-						
-					if(!mpegInfo->samplerate) continue;
-					
-					found=1;
-				}
-				
-			}while(!found && start<maxSearch-4);
-			if(!found)
-				{	
-					return 0;
-				}
-			*offset=start-1;
-			printf("AAC Frame found at offset :%u layer:%u profile:%u samperate:%u channels:%u size:%u nbBlock:%u\n",
-					*offset,
-					mpegInfo->layer,
-					mpegInfo->profile, 
-					mpegInfo->samplerate,
-					mpegInfo->channels,
-					mpegInfo->size,
-					nbframe);
-			return 1;
-			
-
-	
-
-}
-//____________
-

Deleted: branches/avidemux_2.6_branch_mean/avidemux/ADM_coreAudio/src/ADM_dcainfo.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_coreAudio/src/ADM_dcainfo.cpp	2009-03-11 18:40:49 UTC (rev 4670)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_coreAudio/src/ADM_dcainfo.cpp	2009-03-11 18:40:53 UTC (rev 4671)
@@ -1,109 +0,0 @@
-/**
-
-        \file ADM_dcainfo
-        \brief extract info from DTS/DCA streams
-        Author: mean <fixounet at free.fr>, (C) 2004
-        Code very derived from libdca
-
-*/
-#include "ADM_default.h"
-#include "ADM_dcainfo.h"
-#define ADM_NO_CONFIG_H
-extern "C"
-{
-#include "ADM_libraries/ADM_ffmpeg/libavutil/common.h"
-#include "ADM_libraries/ADM_ffmpeg/libavutil/bswap.h"
-#include "ADM_libraries/ADM_ffmpeg/ADM_lavcodec/bitstream.h"
-
-}
-
-/*
-        Borrowed from libdca
-*/
-static const int dts_sample_rates[] =
-{
-    0, 8000, 16000, 32000, 0, 0, 11025, 22050, 44100, 0, 0,
-    12000, 24000, 48000, 96000, 192000
-};
-
-static const int dts_bit_rates[] =
-{
-    32000, 56000, 64000, 96000, 112000, 128000,
-    192000, 224000, 256000, 320000, 384000,
-    448000, 512000, 576000, 640000, 768000,
-    896000, 1024000, 1152000, 1280000, 1344000,
-    1408000, 1411200, 1472000, 1536000, 1920000,
-    2048000, 3072000, 3840000, 1/*open*/, 2/*variable*/, 3/*lossless*/
-};
-
-static const uint8_t dts_channels[] =
-{
-    1, 2, 2, 2, 2, 3, 3, 4, 4, 5, 6, 6, 6, 7, 8, 8
-};
-
-/*
-    Return frame size
-*/
-int  ADM_DCAGetInfo(uint8_t *buf, uint32_t len, uint32_t *fq, uint32_t *br, uint32_t *chan,uint32_t *syncoff,uint32_t *flagso,uint32_t *nbSample)
-{
-uint8_t *end=buf+len-4-DTS_HEADER_SIZE;
-uint8_t *cur=buf-1;
-uint32_t size,len1,len2,flags,sr,framesize=0,index,nbBlocks;
-             // Assume 16 bits big endian
-            // Search for 7F FE 80 01 as sync start
-            *syncoff=0;
-            while(cur<end)
-            {
-                cur++;
-                if(*cur!=0x7F) continue;
-                if(cur[1]!=0xfe) continue;
-                if(cur[2]!=0x80) continue;
-                if(cur[3]!=0x01) continue;
-                // ok we got a starcode
-                // State :      32 bits, already got them
-                // Frame type   1 
-                // Sample Deficit 5
-                // CRC present  1
-                // Frame length  7
-                // Frame Size 14
-                // **** Inefficient ! ****
-                GetBitContext s;
-                init_get_bits( &s,cur, (end-cur)*8);
-                skip_bits(&s,32);
-                skip_bits(&s,1);
-                skip_bits(&s,5);
-                skip_bits(&s,1);
-                //Nb Samples
-                nbBlocks=(get_bits(&s,7)+1);
-                // Frame size in bit
-                len2=get_bits(&s,14);
-                framesize=len2+1;
-                //
-                //  
-                //
-                flags=get_bits(&s,6);
-                *flagso=flags;
-                index=get_bits(&s,4); 
-                *fq=dts_sample_rates[index];
-                index=get_bits(&s,5); 
-                *br=dts_bit_rates[index];
-#if 0
-                printf("[dts]Flags  :%u\n",flags);
-                printf("[dts]Fq  :%u\n",*fq);
-                printf("[dts]br  :%u\n",*br);
-                printf("[dts]len1  :%u\n",len1);
-                printf("[dts]len2  :%u\n",len2);
-#endif
-                *syncoff=cur-buf;
-                if(*syncoff) printf("[dts] Dropped %u bytes\n",*syncoff);
-                *chan=dts_channels[flags & 0xf];
-//                if(*chan==5 && (flags & 0X80)) *chan++;
-                *nbSample=nbBlocks*32;
-                return framesize;
-                
-                
-            }
-            printf("[DTS] Cannot find sync\n");
-	      return 0;
-}
-

Deleted: branches/avidemux_2.6_branch_mean/avidemux/ADM_coreAudio/src/ADM_mp3info.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_coreAudio/src/ADM_mp3info.cpp	2009-03-11 18:40:49 UTC (rev 4670)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_coreAudio/src/ADM_mp3info.cpp	2009-03-11 18:40:53 UTC (rev 4671)
@@ -1,199 +0,0 @@
-//
-// C++ Implementation: ADM_MP3Info
-//
-// Description:
-//		Decode an mp3 frame an fill the info field
-//			The second is a template to check we do not do bogus frame detection
-//
-// Author: mean <fixounet at free.fr>, (C) 2004
-//
-// Copyright: See COPYING file that comes with this distribution
-//
-//
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-
-#include <math.h>
-
-
-#include "ADM_default.h"
-
-#include "ADM_mp3info.h"
-
-static  uint32_t MP3Fq[4] = { 44100, 48000, 32000, 0 };
-static uint32_t MP2Fq[4] = { 22050, 24000, 16000, 0 };
-static uint32_t Bitrate[8][16]=
-{
-	// Level 1 / Layer 0
-	{0,0,0,0,0,0,0,0   ,0,0,0,0,0,0,0,0},
-	// Level 1/ Layer 1
-	{0,32,64,96,128,160,192,224   ,256,288,320,352,384,416,448,0},
-	// Level 1/Layer 2
-	{ 0, 32, 48, 56,64, 80, 96, 112,     128, 160, 192, 224,   256, 320, 384, 0},
-	//Level 1 / Layer 3
-	{ 0, 32, 40, 48, 56, 64, 80, 96,         112, 128, 160, 192,  224, 256, 320, 0},
-	// Level 2/Layer 0
-	{0,0,0,0,0,0,0,0   ,0,0,0,0,0,0,0,0},
-	// Level 2 Layer 1
-	{ 0, 32, 48, 56,64, 80, 96, 112,          128, 144, 160,176,  192, 224, 256, 0},
-	// Level 2 Layer 2
-	{ 0, 8, 16, 24,  32, 40, 48, 56,    64, 80, 96, 112,    128, 144, 160, 0 },
-	// Id for Layer 3
-	{ 0, 8, 16, 24,  32, 40, 48, 56,    64, 80, 96, 112,    128, 144, 160, 0 },
-};
-
-
-uint8_t	getMpegFrameInfo(uint8_t *stream,uint32_t maxSearch, MpegAudioInfo *mpegInfo,MpegAudioInfo *templ,uint32_t *offset)
-{
-uint32_t start=0,found=0;
-uint8_t  a[4];
-uint32_t nfq,fqindex,brindex,index;
-			memcpy(a+1,stream,3);
-			do
-			{
-
-				memmove(a,a+1,3);
-				a[3]=stream[start+3];
-				if(start>=maxSearch-3) break;
-				start++;
-				if(a[0]==0xff && ((a[1]&0xF0)==0xF0))
-				{
-					// Layer
-					mpegInfo->layer=4-(a[1]>>1)&3;
-					mpegInfo->level=4-(a[1]>>3)&3;
-					if(mpegInfo->level==3) continue;
-					if(mpegInfo->level==4) mpegInfo->level=3;
-					mpegInfo->protect=(a[1]&1)^1;
-					mpegInfo->padding=(a[2]>>1)&1;
-                                        mpegInfo->privatebit=(a[2]&1);
-					mpegInfo->mode=(a[3])>>6;
-                                        mpegInfo->mode_extension=((a[3])>>4)&3;
-
-					fqindex=(a[2]>>2)&3;
-					brindex=(a[2]>>4);
-
-					// Remove impossible case
-					if(mpegInfo->layer==0) continue;
-					// Check fq
-                                        if((a[1]>>4)&1)
-                                        {
-                                          mpegInfo->lsf=0;
-                                        }
-                                        else
-                                          mpegInfo->lsf=1;
-                                        //
-					switch(mpegInfo->level)
-					{
-						case 1: mpegInfo->samplerate=MP3Fq[fqindex];break;
-						case 2: mpegInfo->samplerate=MP2Fq[fqindex];break;
-						case 3: mpegInfo->samplerate=MP2Fq[fqindex]>>1;break;
-						default: mpegInfo->samplerate=0;break;
-					}
-					// impossible fq
-					if(!mpegInfo->samplerate) continue;
-					// Bitrate now
-
-					// Compute bitrate
-					switch(mpegInfo->level)
-					{
-						case 2:
-						case 3:
-							index=4+mpegInfo->layer;
-							break;
-						case 1:
-							index=mpegInfo->layer;
-							break;
-						default:
-							continue;
-					}
-
-					mpegInfo->bitrate=Bitrate[index][brindex];
-					if(!mpegInfo->bitrate) continue;
-
-					// Check consistency
-					if(templ)
-					{
-						if(templ->samplerate!=mpegInfo->samplerate)
-                                                {
-                                                  printf("[MP3]samplerate does not match\n");
-                                                  continue;
-                                                }
-
-					}
-					found=1;
-				}
-
-			}while(!found && start<maxSearch-4);
-			if(!found)
-				{
-					return 0;
-				}
-/*	*/
-			// Sample in the packet
-			if(mpegInfo->level==1)
-			{
-				if(1==mpegInfo->layer)
-					mpegInfo->samples=384;
-				else
-					mpegInfo->samples=1152;
-				*offset=start-1;
-			}
-			else
-			{	// Mpeg2/2.5
-				if(1==mpegInfo->layer)
-					mpegInfo->samples=384;
-				else
-					mpegInfo->samples=576;
-				*offset=start-1;
-
-			}
-
-			// Packet size
-			//L1:FrameLengthInBytes = (12 * BitRate / SampleRate + Padding) * 4
-
-			switch(mpegInfo->layer)
-			{
-				case 1:
-					mpegInfo->size=((12*1000*mpegInfo->bitrate)/mpegInfo->samplerate)
-								+mpegInfo->padding;
-					mpegInfo->size=mpegInfo->size*4;
-					break;
-				default:
-				//FrameLengthInBytes = 144 * BitRate / SampleRate + Padding
-                                  uint32_t slot_per_frame;
-                                        if(mpegInfo->layer==3 && mpegInfo->level==2)  slot_per_frame=72;
-                                                else slot_per_frame=144;
-                                        mpegInfo->size=(slot_per_frame*mpegInfo->bitrate*1000)/mpegInfo->samplerate;
-					mpegInfo->size+=mpegInfo->padding;
-			}
-			if(*offset)
-				{
-					printf("MP3: Skipped %"LU" bytes\n",*offset);
-
-				}
-#if 0
-			printf("%02x %02x %02x %02x\n",a[0],a[1],a[2],a[3]);
-			printf("Packet found : at :%d level:%d layer:%d fq:%d bitrate:%d mode:%d\n",
-					start-1,mpegInfo->level,mpegInfo->layer,mpegInfo->samplerate,
-					mpegInfo->bitrate,mpegInfo->mode);
-                        printf("Private :%d cop:%d ext:%d ",mpegInfo->privatebit,
-                               0,mpegInfo->mode_extension);
-			printf("Padd:%lu, crc on:%lu size:%lu\n",mpegInfo->padding,mpegInfo->protect,
-								mpegInfo->size);
-#endif
-
-			return 1;
-
-
-
-
-}
-//____________
-



From mean at mail.berlios.de  Wed Mar 11 19:41:05 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Wed, 11 Mar 2009 19:41:05 +0100
Subject: [Avidemux-svn-commit] r4672 -
	branches/avidemux_2.6_branch_mean/avidemux/ADM_audioParser
Message-ID: <200903111841.n2BIf5Gb005863@sheep.berlios.de>

Author: mean
Date: 2009-03-11 19:41:05 +0100 (Wed, 11 Mar 2009)
New Revision: 4672

Added:
   branches/avidemux_2.6_branch_mean/avidemux/ADM_audioParser/CMakeLists.txt
Log:
[audioParser] make it a proper .so

Added: branches/avidemux_2.6_branch_mean/avidemux/ADM_audioParser/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_audioParser/CMakeLists.txt	2009-03-11 18:40:53 UTC (rev 4671)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_audioParser/CMakeLists.txt	2009-03-11 18:41:05 UTC (rev 4672)
@@ -0,0 +1 @@
+ADD_SUBDIRECTORY(src)



From mean at mail.berlios.de  Wed Mar 11 19:41:06 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Wed, 11 Mar 2009 19:41:06 +0100
Subject: [Avidemux-svn-commit] r4673 - in
	branches/avidemux_2.6_branch_mean/avidemux: .
	ADM_audioParser/src ADM_coreAudio/src
Message-ID: <200903111841.n2BIf6no005875@sheep.berlios.de>

Author: mean
Date: 2009-03-11 19:41:06 +0100 (Wed, 11 Mar 2009)
New Revision: 4673

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/ADM_audioParser/src/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/avidemux/ADM_coreAudio/src/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/avidemux/CMakeLists.txt
Log:
[audioParser] make it a proper .so

Modified: branches/avidemux_2.6_branch_mean/avidemux/ADM_audioParser/src/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_audioParser/src/CMakeLists.txt	2009-03-11 18:41:05 UTC (rev 4672)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_audioParser/src/CMakeLists.txt	2009-03-11 18:41:06 UTC (rev 4673)
@@ -1,17 +1,5 @@
 
-SET(ADMaudioCore_SRCS
-ADM_audioUtils.cpp
-audioencoder.cpp
-ADM_audioFilter.cpp
-ADM_audioResample.cpp
-ADM_audioStream.cpp
-ADM_audioStreamBuffered.cpp
-ADM_audioStreamMP3.cpp
-ADM_audioStreamAC3.cpp
-ADM_libsamplerate/samplerate.c
-ADM_libsamplerate/src_linear.c
-ADM_libsamplerate/src_sinc.c
-ADM_libsamplerate/src_zoh.c
+SET(ADMaudioParser_SRCS
 ADM_aacinfo.cpp 
 ADM_mp3info.cpp  
 ADM_a52info.cpp 
@@ -21,12 +9,10 @@
 ADD_DEFINITIONS( "-DADM_LEGACY_PROGGY")
 ADD_DEFINITIONS( "-DHAVE_LRINT -DHAVE_LRINTF ")
 ADD_DEFINITIONS( "-DCPU_CLIPS_POSITIVE=0 -DCPU_CLIPS_NEGATIVE=0")
-ADD_DEFINITIONS( "-I${CMAKE_CURRENT_SOURCE_DIR} ")
 ADD_DEFINITIONS( "-DPACKAGE=`"SRC`"")
 ADD_DEFINITIONS( "-DVERSION=`"0.1.4`"")
 #*************************************************
-ADD_LIBRARY(ADM_coreAudio SHARED ${ADMaudioCore_SRCS})
-INCLUDE_DIRECTORIES(${CMAKE_SOURCE_DIR}/avidemux/ADM_coreAudio/include)
-TARGET_LINK_LIBRARIES(ADM_coreAudio ADM_core ADM_coreUI)
+ADD_LIBRARY(ADM_audioParser SHARED ${ADMaudioParser_SRCS})
+TARGET_LINK_LIBRARIES(ADM_audioParser ADM_core ADM_coreUI)
 
-INSTALL(TARGETS ADM_coreAudio RUNTIME DESTINATION ${BIN_DIR}  LIBRARY DESTINATION lib  ARCHIVE DESTINATION lib)
+INSTALL(TARGETS ADM_audioParser RUNTIME DESTINATION ${BIN_DIR}  LIBRARY DESTINATION lib  ARCHIVE DESTINATION lib)

Modified: branches/avidemux_2.6_branch_mean/avidemux/ADM_coreAudio/src/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_coreAudio/src/CMakeLists.txt	2009-03-11 18:41:05 UTC (rev 4672)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_coreAudio/src/CMakeLists.txt	2009-03-11 18:41:06 UTC (rev 4673)
@@ -12,10 +12,6 @@
 ADM_libsamplerate/src_linear.c
 ADM_libsamplerate/src_sinc.c
 ADM_libsamplerate/src_zoh.c
-ADM_aacinfo.cpp 
-ADM_mp3info.cpp  
-ADM_a52info.cpp 
-ADM_dcainfo.cpp  
 )	
 #*************************************************
 ADD_DEFINITIONS( "-DADM_LEGACY_PROGGY")

Modified: branches/avidemux_2.6_branch_mean/avidemux/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/CMakeLists.txt	2009-03-11 18:41:05 UTC (rev 4672)
+++ branches/avidemux_2.6_branch_mean/avidemux/CMakeLists.txt	2009-03-11 18:41:06 UTC (rev 4673)
@@ -57,6 +57,7 @@
 INCLUDE_DIRECTORIES("${CMAKE_CURRENT_SOURCE_DIR}/ADM_coreUI/include")
 INCLUDE_DIRECTORIES("${CMAKE_CURRENT_SOURCE_DIR}/ADM_coreImage/include")
 INCLUDE_DIRECTORIES("${CMAKE_CURRENT_SOURCE_DIR}/ADM_coreAudio/include")
+INCLUDE_DIRECTORIES("${CMAKE_CURRENT_SOURCE_DIR}/ADM_audioParser/include")
 INCLUDE_DIRECTORIES("${CMAKE_CURRENT_SOURCE_DIR}/ADM_coreUtils/include")
 INCLUDE_DIRECTORIES("${CMAKE_CURRENT_SOURCE_DIR}/ADM_coreAudioDevice/include")
 INCLUDE_DIRECTORIES("${CMAKE_CURRENT_SOURCE_DIR}/ADM_coreDemuxer/include")
@@ -342,6 +343,8 @@
 ADD_LIB_ALL_TARGETS(ADM_coreUI)
 ADD_SUBDIRECTORY(ADM_coreImage)
 ADD_LIB_ALL_TARGETS(ADM_coreImage)
+ADD_SUBDIRECTORY(ADM_audioParser)
+ADD_LIB_ALL_TARGETS(ADM_audioParser)
 ADD_SUBDIRECTORY(ADM_coreAudio)
 ADD_LIB_ALL_TARGETS(ADM_coreAudio)
 ADD_SUBDIRECTORY(ADM_coreDemuxer)



From mean at mail.berlios.de  Wed Mar 11 19:41:08 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Wed, 11 Mar 2009 19:41:08 +0100
Subject: [Avidemux-svn-commit] r4674 - in
	branches/avidemux_2.6_branch_mean/avidemux: . ADM_audioFilter
	ADM_audioFilter/include ADM_audioFilter/src ADM_audiofilter
Message-ID: <200903111841.n2BIf86h005887@sheep.berlios.de>

Author: mean
Date: 2009-03-11 19:41:08 +0100 (Wed, 11 Mar 2009)
New Revision: 4674

Added:
   branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/
   branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/include/
   branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/include/audiofilter_access.h
   branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/include/audiofilter_bridge.h
   branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/src/
   branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/src/.CMakeLists.txt.swp
   branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/src/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/src/audiofilter_access.cpp
   branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/src/audiofilter_bridge.cpp
Removed:
   branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_bridge.cpp
   branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_bridge.h
Log:
[AudioFilter] Begin cleanup

Added: branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/CMakeLists.txt	2009-03-11 18:41:06 UTC (rev 4673)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/CMakeLists.txt	2009-03-11 18:41:08 UTC (rev 4674)
@@ -0,0 +1 @@
+ADD_SUBDIRECTORY(src)

Copied: branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/include/audiofilter_access.h (from rev 4673, branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_bridge.h)
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_bridge.h	2009-03-11 18:41:06 UTC (rev 4673)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/include/audiofilter_access.h	2009-03-11 18:41:08 UTC (rev 4674)
@@ -0,0 +1,42 @@
+/***************************************************************************
+         Bridge
+         
+         This file is a bridge from output of decoder to filter api
+         
+ ***************************************************************************/
+ 
+ 
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#ifndef AUDM_BRIDGE_H
+#include "audioencoder.h"
+#include "ADM_audio/aviaudio.hxx"
+#include "ADM_audioStream.h"
+#include "../ADM_editor/ADM_edit.hxx"
+class AUDMAudioFilter_Bridge : public AUDMAudioFilter
+{
+  protected:
+    ADM_Composer  *_incoming;
+    uint32_t _startTime; /*< Starting time in ms */
+    int32_t  _shift;  /*< Shift in Ms */
+    int32_t  _hold;   /*< Nb Sample to repeat */
+    virtual uint8_t fillIncomingBuffer(AUD_Status *status);
+  public:
+    AUDMAudioFilter_Bridge(ADM_Composer *incoming, uint32_t startInMs,int32_t shiftMS);
+    virtual                ~AUDMAudioFilter_Bridge();
+    virtual    uint32_t   fill(uint32_t max,float *output,AUD_Status *status);      // Fill buffer: incoming -> us
+                                                                                           // Output MAXIMUM max float value
+                                                                                           // Not sample! float!
+    virtual    uint8_t    rewind(void)  ;                                              // go back to the beginning
+    virtual CHANNEL_TYPE *getChannelMapping(void);
+};
+
+
+#endif
+

Copied: branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/include/audiofilter_bridge.h (from rev 4673, branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_bridge.h)
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_bridge.h	2009-03-11 18:41:06 UTC (rev 4673)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/include/audiofilter_bridge.h	2009-03-11 18:41:08 UTC (rev 4674)
@@ -0,0 +1,42 @@
+/***************************************************************************
+         Bridge
+         
+         This file is a bridge from output of decoder to filter api
+         
+ ***************************************************************************/
+ 
+ 
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#ifndef AUDM_BRIDGE_H
+#include "audioencoder.h"
+#include "ADM_audio/aviaudio.hxx"
+#include "ADM_audioStream.h"
+#include "../ADM_editor/ADM_edit.hxx"
+class AUDMAudioFilter_Bridge : public AUDMAudioFilter
+{
+  protected:
+    ADM_Composer  *_incoming;
+    uint32_t _startTime; /*< Starting time in ms */
+    int32_t  _shift;  /*< Shift in Ms */
+    int32_t  _hold;   /*< Nb Sample to repeat */
+    virtual uint8_t fillIncomingBuffer(AUD_Status *status);
+  public:
+    AUDMAudioFilter_Bridge(ADM_Composer *incoming, uint32_t startInMs,int32_t shiftMS);
+    virtual                ~AUDMAudioFilter_Bridge();
+    virtual    uint32_t   fill(uint32_t max,float *output,AUD_Status *status);      // Fill buffer: incoming -> us
+                                                                                           // Output MAXIMUM max float value
+                                                                                           // Not sample! float!
+    virtual    uint8_t    rewind(void)  ;                                              // go back to the beginning
+    virtual CHANNEL_TYPE *getChannelMapping(void);
+};
+
+
+#endif
+

Added: branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/src/.CMakeLists.txt.swp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/src/.CMakeLists.txt.swp	2009-03-11 18:41:06 UTC (rev 4673)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/src/.CMakeLists.txt.swp	2009-03-11 18:41:08 UTC (rev 4674)
@@ -0,0 +1 @@
+b0VIM 7.1





r_SRCS
\ No newline at end of file

Added: branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/src/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/src/CMakeLists.txt	2009-03-11 18:41:06 UTC (rev 4673)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/src/CMakeLists.txt	2009-03-11 18:41:08 UTC (rev 4674)
@@ -0,0 +1,6 @@
+SET(ADM_audioFilter_SRCS
+audiofilter_bridge.cpp
+audiofilter_access.cpp
+)
+ADD_LIBRARY(ADM_audioFilter STATIC ${ADM_audioFilter_SRCS})
+

Copied: branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/src/audiofilter_access.cpp (from rev 4673, branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_bridge.cpp)
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_bridge.cpp	2009-03-11 18:41:06 UTC (rev 4673)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/src/audiofilter_access.cpp	2009-03-11 18:41:08 UTC (rev 4674)
@@ -0,0 +1,176 @@
+/***************************************************************************
+              Convert output of decoder to filter api
+              (c) 2006 Mean , fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+
+#include "ADM_default.h"
+#include <math.h>
+
+#include "ADM_audioFilter.h"
+#include "audiofilter_bridge.h"
+
+#include "ADM_osSupport/ADM_debugID.h"
+#define MODULE_NAME MODULE_AUDIO_FILTER
+#include "ADM_osSupport/ADM_debug.h"
+
+/**
+    \fn AUDMAudioFilter_Bridge
+*/
+AUDMAudioFilter_Bridge::AUDMAudioFilter_Bridge(ADM_Composer *incoming,
+                          uint32_t startInMs,int32_t shiftMs) : AUDMAudioFilter(NULL)
+{
+  _incoming=incoming;
+  memcpy(&_wavHeader,_incoming->getInfo(),sizeof(_wavHeader));
+  _startTime=startInMs;
+  shiftMs=-shiftMs;
+  _shift=shiftMs;
+  _hold=0;
+  rewind();
+  
+  printf("[Bridge] Starting with time %u, shift %d\n",startInMs,-shiftMs);
+  // If shiftMS is > 0, it means we have to go in the future, just increse _startTime
+  if(shiftMs>0)
+  {
+    _startTime+=_shift;
+  }
+  else if(shiftMs<0) // In that case we have to go either in the past and/or duplicate frames
+  {
+    shiftMs=-shiftMs;
+    if(_startTime>shiftMs)  
+    {
+      _startTime-=shiftMs;
+    }else
+    {
+      double nbSample;
+      
+      shiftMs-=_startTime;
+      _startTime=0;
+      nbSample=shiftMs;
+      nbSample*=_wavHeader.frequency; 
+      nbSample/=1000.;
+      nbSample*=_wavHeader.channels;
+      _hold=(int32_t)nbSample;
+    }
+    
+  }
+  printf("[Bridge] Ending with time %u, sample %u\n",_startTime,_hold);
+  rewind();
+}
+/**
+    \fn ~AUDMAudioFilter_Bridge
+*/
+
+AUDMAudioFilter_Bridge::~AUDMAudioFilter_Bridge()
+{
+  printf("[Bridge] Destroying bridge\n");
+}
+/**
+    \fn rewind
+*/
+uint8_t AUDMAudioFilter_Bridge::rewind(void)
+{
+uint64_t ttime=_startTime;
+  ttime*=1000; // ms->us
+  printf("[Bridge] Going to time %d\n",_startTime);
+  uint8_t r= _incoming->goToTime(ttime);
+  if(!r) printf("[Bridge] Failed!\n");
+  return r;
+}
+/**
+    \fn fill
+*/
+uint32_t   AUDMAudioFilter_Bridge::fill(uint32_t max,float *output,AUD_Status *status)
+{
+  uint32_t asked,asked2,total=0;
+  //
+  ADM_assert(_tail>=_head);
+  shrink();
+  ADM_assert(_tail>=_head);
+  fillIncomingBuffer(status);
+  // Now fill output
+  // We could probably skip the buffering step
+  // one extra memcpy gained
+  uint32_t available;
+  ADM_assert(_tail>=_head);
+  available=_tail-_head;
+  if(available>max) available=max;
+  memcpy(output,&(_incomingBuffer[_head]),available*sizeof(float));
+  _head+=available;
+  if(!available)
+  {
+    printf("[bridge] No data in %u max %u out %u\n",_tail-_head,max,available);
+  }
+  return available;
+
+}
+/**
+    \fn fillIncomingBuffer
+*/
+uint8_t AUDMAudioFilter_Bridge::fillIncomingBuffer(AUD_Status *status)
+{
+  uint32_t asked,got;
+  uint64_t dts;
+  *status=AUD_OK;
+  // Hysteresis
+  if((_tail-_head)<(AUD_PROCESS_BUFFER_SIZE>>2)) // Less than 1/4 full
+  {
+
+    while ((  _tail < (3*AUD_PROCESS_BUFFER_SIZE)/5)) // Fill up to 3/5--3/4
+    {
+      // don't ask too much front.
+      asked = (3*AUD_PROCESS_BUFFER_SIZE)/4-_tail;
+      if(_hold)
+      {
+        int32_t sam;
+         
+        sam=_hold/_wavHeader.channels;
+        sam++;
+        sam*=_wavHeader.channels;
+        if(asked>sam) asked=sam;
+        
+      }
+      asked/=_wavHeader.channels; // float->samples
+      _incoming->getPCMPacket(&(_incomingBuffer[_tail]), asked, &got,&dts);
+      got*=_wavHeader.channels; // sample->float
+      if (!got )
+      {
+        *status=AUD_END_OF_STREAM;
+        printf("[Bridge] End of stream\n");
+        break;
+      }
+      _tail+=got;
+      if(_hold>0)
+      {
+        _hold-=got;
+        if(_hold<=0)
+        {
+          printf("[Bridge] Looping\n");
+          rewind();
+          //_tail=_head=0;
+          _hold=0;
+        }
+      }
+    }
+  }
+  return 1;
+}
+/**
+ * 	\fn return _incoming->getChannelMapping();
+ * \brief since it is a bridge, we translate the filter channel mapping from the audiostream channel mapping
+ */
+CHANNEL_TYPE *AUDMAudioFilter_Bridge::getChannelMapping(void) 
+{
+	ADM_assert(_incoming);
+	return _incoming->getChannelMapping();
+}
+//EOF

Copied: branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/src/audiofilter_bridge.cpp (from rev 4673, branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_bridge.cpp)
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_bridge.cpp	2009-03-11 18:41:06 UTC (rev 4673)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/src/audiofilter_bridge.cpp	2009-03-11 18:41:08 UTC (rev 4674)
@@ -0,0 +1,176 @@
+/***************************************************************************
+              Convert output of decoder to filter api
+              (c) 2006 Mean , fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+
+#include "ADM_default.h"
+#include <math.h>
+
+#include "ADM_audioFilter.h"
+#include "audiofilter_bridge.h"
+
+#include "ADM_osSupport/ADM_debugID.h"
+#define MODULE_NAME MODULE_AUDIO_FILTER
+#include "ADM_osSupport/ADM_debug.h"
+
+/**
+    \fn AUDMAudioFilter_Bridge
+*/
+AUDMAudioFilter_Bridge::AUDMAudioFilter_Bridge(ADM_Composer *incoming,
+                          uint32_t startInMs,int32_t shiftMs) : AUDMAudioFilter(NULL)
+{
+  _incoming=incoming;
+  memcpy(&_wavHeader,_incoming->getInfo(),sizeof(_wavHeader));
+  _startTime=startInMs;
+  shiftMs=-shiftMs;
+  _shift=shiftMs;
+  _hold=0;
+  rewind();
+  
+  printf("[Bridge] Starting with time %u, shift %d\n",startInMs,-shiftMs);
+  // If shiftMS is > 0, it means we have to go in the future, just increse _startTime
+  if(shiftMs>0)
+  {
+    _startTime+=_shift;
+  }
+  else if(shiftMs<0) // In that case we have to go either in the past and/or duplicate frames
+  {
+    shiftMs=-shiftMs;
+    if(_startTime>shiftMs)  
+    {
+      _startTime-=shiftMs;
+    }else
+    {
+      double nbSample;
+      
+      shiftMs-=_startTime;
+      _startTime=0;
+      nbSample=shiftMs;
+      nbSample*=_wavHeader.frequency; 
+      nbSample/=1000.;
+      nbSample*=_wavHeader.channels;
+      _hold=(int32_t)nbSample;
+    }
+    
+  }
+  printf("[Bridge] Ending with time %u, sample %u\n",_startTime,_hold);
+  rewind();
+}
+/**
+    \fn ~AUDMAudioFilter_Bridge
+*/
+
+AUDMAudioFilter_Bridge::~AUDMAudioFilter_Bridge()
+{
+  printf("[Bridge] Destroying bridge\n");
+}
+/**
+    \fn rewind
+*/
+uint8_t AUDMAudioFilter_Bridge::rewind(void)
+{
+uint64_t ttime=_startTime;
+  ttime*=1000; // ms->us
+  printf("[Bridge] Going to time %d\n",_startTime);
+  uint8_t r= _incoming->goToTime(ttime);
+  if(!r) printf("[Bridge] Failed!\n");
+  return r;
+}
+/**
+    \fn fill
+*/
+uint32_t   AUDMAudioFilter_Bridge::fill(uint32_t max,float *output,AUD_Status *status)
+{
+  uint32_t asked,asked2,total=0;
+  //
+  ADM_assert(_tail>=_head);
+  shrink();
+  ADM_assert(_tail>=_head);
+  fillIncomingBuffer(status);
+  // Now fill output
+  // We could probably skip the buffering step
+  // one extra memcpy gained
+  uint32_t available;
+  ADM_assert(_tail>=_head);
+  available=_tail-_head;
+  if(available>max) available=max;
+  memcpy(output,&(_incomingBuffer[_head]),available*sizeof(float));
+  _head+=available;
+  if(!available)
+  {
+    printf("[bridge] No data in %u max %u out %u\n",_tail-_head,max,available);
+  }
+  return available;
+
+}
+/**
+    \fn fillIncomingBuffer
+*/
+uint8_t AUDMAudioFilter_Bridge::fillIncomingBuffer(AUD_Status *status)
+{
+  uint32_t asked,got;
+  uint64_t dts;
+  *status=AUD_OK;
+  // Hysteresis
+  if((_tail-_head)<(AUD_PROCESS_BUFFER_SIZE>>2)) // Less than 1/4 full
+  {
+
+    while ((  _tail < (3*AUD_PROCESS_BUFFER_SIZE)/5)) // Fill up to 3/5--3/4
+    {
+      // don't ask too much front.
+      asked = (3*AUD_PROCESS_BUFFER_SIZE)/4-_tail;
+      if(_hold)
+      {
+        int32_t sam;
+         
+        sam=_hold/_wavHeader.channels;
+        sam++;
+        sam*=_wavHeader.channels;
+        if(asked>sam) asked=sam;
+        
+      }
+      asked/=_wavHeader.channels; // float->samples
+      _incoming->getPCMPacket(&(_incomingBuffer[_tail]), asked, &got,&dts);
+      got*=_wavHeader.channels; // sample->float
+      if (!got )
+      {
+        *status=AUD_END_OF_STREAM;
+        printf("[Bridge] End of stream\n");
+        break;
+      }
+      _tail+=got;
+      if(_hold>0)
+      {
+        _hold-=got;
+        if(_hold<=0)
+        {
+          printf("[Bridge] Looping\n");
+          rewind();
+          //_tail=_head=0;
+          _hold=0;
+        }
+      }
+    }
+  }
+  return 1;
+}
+/**
+ * 	\fn return _incoming->getChannelMapping();
+ * \brief since it is a bridge, we translate the filter channel mapping from the audiostream channel mapping
+ */
+CHANNEL_TYPE *AUDMAudioFilter_Bridge::getChannelMapping(void) 
+{
+	ADM_assert(_incoming);
+	return _incoming->getChannelMapping();
+}
+//EOF

Deleted: branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_bridge.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_bridge.cpp	2009-03-11 18:41:06 UTC (rev 4673)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_bridge.cpp	2009-03-11 18:41:08 UTC (rev 4674)
@@ -1,173 +0,0 @@
-/***************************************************************************
-              Convert output of decoder to filter api
-              (c) 2006 Mean , fixounet at free.fr
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-
-#include "ADM_default.h"
-#include <math.h>
-
-#include "ADM_audioFilter.h"
-#include "audiofilter_bridge.h"
-
-#include "ADM_osSupport/ADM_debugID.h"
-#define MODULE_NAME MODULE_AUDIO_FILTER
-#include "ADM_osSupport/ADM_debug.h"
-
-
-AUDMAudioFilter_Bridge::AUDMAudioFilter_Bridge(AUDMAudioFilter *previous,ADM_Composer *incoming,
-                          uint32_t startInMs,int32_t shiftMs) : AUDMAudioFilter(NULL)
-{
-  _incoming=incoming;
-  memcpy(&_wavHeader,_incoming->getInfo(),sizeof(_wavHeader));
-  _startTime=startInMs;
-  shiftMs=-shiftMs;
-  _shift=shiftMs;
-  _hold=0;
-  rewind();
-  /*  */
-  WAVHeader *hdr=incoming->getInfo();
-
-  printf("[Bridge] Starting with time %u, shift %d\n",startInMs,-shiftMs);
-  // If shiftMS is > 0, it means we have to go in the future, just increse _startTime
-  if(shiftMs>0)
-  {
-    _startTime+=_shift;
-  }
-  else if(shiftMs<0) // In that case we have to go either in the past and/or duplicate frames
-  {
-    shiftMs=-shiftMs;
-    if(_startTime>shiftMs)  
-    {
-      _startTime-=shiftMs;
-    }else
-    {
-      double nbSample;
-      
-      shiftMs-=_startTime;
-      _startTime=0;
-      nbSample=shiftMs;
-      nbSample*=_wavHeader.frequency; 
-      nbSample/=1000.;
-      nbSample*=_wavHeader.channels;
-      _hold=(int32_t)nbSample;
-      
-      
-    }
-    
-  }
-  printf("[Bridge] Ending with time %u, sample %u\n",_startTime,_hold);
-  rewind();
-}
-AUDMAudioFilter_Bridge::~AUDMAudioFilter_Bridge()
-{
-  printf("[Bridge] Destroying bridge\n");
-}
-/**
-    \fn rewind
-*/
-uint8_t AUDMAudioFilter_Bridge::rewind(void)
-{
-uint64_t ttime=_startTime;
-  ttime*=1000; // ms->us
-  printf("[Bridge] Going to time %d\n",_startTime);
-  uint8_t r= _incoming->goToTime(ttime);
-  if(!r) printf("[Bridge] Failed!\n");
-  return r;
-}
-/**
-    \fn fill
-*/
-uint32_t   AUDMAudioFilter_Bridge::fill(uint32_t max,float *output,AUD_Status *status)
-{
-  uint32_t asked,asked2,total=0;
-  //
-  ADM_assert(_tail>=_head);
-  shrink();
-  ADM_assert(_tail>=_head);
-  fillIncomingBuffer(status);
-  // Now fill output
-  // We could probably skip the buffering step
-  // one extra memcpy gained
-  uint32_t available;
-  ADM_assert(_tail>=_head);
-  available=_tail-_head;
-  if(available>max) available=max;
-  memcpy(output,&(_incomingBuffer[_head]),available*sizeof(float));
-  _head+=available;
-  if(!available)
-  {
-    printf("[bridge] No data in %u max %u out %u\n",_tail-_head,max,available);
-  }
-
-  return available;
-
-}
-
-uint8_t AUDMAudioFilter_Bridge::fillIncomingBuffer(AUD_Status *status)
-{
-  uint32_t asked,got;
-  uint64_t dts;
-  *status=AUD_OK;
-  // Hysteresis
-  if((_tail-_head)<(AUD_PROCESS_BUFFER_SIZE>>2)) // Less than 1/4 full
-  {
-
-    while ((  _tail < (3*AUD_PROCESS_BUFFER_SIZE)/5)) // Fill up to 3/5--3/4
-    {
-      // don't ask too much front.
-      asked = (3*AUD_PROCESS_BUFFER_SIZE)/4-_tail;
-      if(_hold)
-      {
-        int32_t sam;
-         
-        sam=_hold/_wavHeader.channels;
-        sam++;
-        sam*=_wavHeader.channels;
-        if(asked>sam) asked=sam;
-        
-      }
-      asked/=_wavHeader.channels; // float->samples
-      _incoming->getPCMPacket(&(_incomingBuffer[_tail]), asked, &got,&dts);
-      got*=_wavHeader.channels; // sample->float
-      if (!got )
-      {
-        *status=AUD_END_OF_STREAM;
-        printf("[Bridge] End of stream\n");
-        break;
-      }
-      _tail+=got;
-      if(_hold>0)
-      {
-        _hold-=got;
-        if(_hold<=0)
-        {
-          printf("[Bridge] Looping\n");
-          rewind();
-          //_tail=_head=0;
-          _hold=0;
-        }
-      }
-    }
-  }
-  return 1;
-}
-/**
- * 	\fn return _incoming->getChannelMapping();
- * \brief since it is a bridge, we translate the filter channel mapping from the audiostream channel mapping
- */
-CHANNEL_TYPE *AUDMAudioFilter_Bridge::getChannelMapping(void) 
-{
-	ADM_assert(_incoming);
-	return _incoming->getChannelMapping();
-}
-//EOF

Deleted: branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_bridge.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_bridge.h	2009-03-11 18:41:06 UTC (rev 4673)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_bridge.h	2009-03-11 18:41:08 UTC (rev 4674)
@@ -1,42 +0,0 @@
-/***************************************************************************
-         Bridge
-         
-         This file is a bridge from output of decoder to filter api
-         
- ***************************************************************************/
- 
- 
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#ifndef AUDM_BRIDGE_H
-#include "audioencoder.h"
-#include "ADM_audio/aviaudio.hxx"
-#include "ADM_audioStream.h"
-#include "../ADM_editor/ADM_edit.hxx"
-class AUDMAudioFilter_Bridge : public AUDMAudioFilter
-{
-  protected:
-    ADM_Composer  *_incoming;
-    uint32_t _startTime; /*< Starting time in ms */
-    int32_t  _shift;  /*< Shift in Ms */
-    int32_t  _hold;   /*< Nb Sample to repeat */
-    virtual uint8_t fillIncomingBuffer(AUD_Status *status);
-  public:
-    AUDMAudioFilter_Bridge(AUDMAudioFilter *previous,ADM_Composer *incoming, uint32_t startInMs,int32_t shiftMS);
-    virtual                ~AUDMAudioFilter_Bridge();
-    virtual    uint32_t   fill(uint32_t max,float *output,AUD_Status *status);      // Fill buffer: incoming -> us
-                                                                                           // Output MAXIMUM max float value
-                                                                                           // Not sample! float!
-    virtual    uint8_t    rewind(void)  ;                                              // go back to the beginning
-    virtual CHANNEL_TYPE *getChannelMapping(void);
-};
-
-
-#endif
-



From mean at mail.berlios.de  Wed Mar 11 19:41:10 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Wed, 11 Mar 2009 19:41:10 +0100
Subject: [Avidemux-svn-commit] r4675 - in
	branches/avidemux_2.6_branch_mean/avidemux: . ADM_audiofilter
	ADM_editor
Message-ID: <200903111841.n2BIfAIt005898@sheep.berlios.de>

Author: mean
Date: 2009-03-11 19:41:10 +0100 (Wed, 11 Mar 2009)
New Revision: 4675

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_buildchain.cpp
   branches/avidemux_2.6_branch_mean/avidemux/ADM_editor/ADM_edit.hxx
   branches/avidemux_2.6_branch_mean/avidemux/CMakeLists.txt
Log:
[AudioFilter] Begin cleanup

Modified: branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/CMakeLists.txt	2009-03-11 18:41:08 UTC (rev 4674)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/CMakeLists.txt	2009-03-11 18:41:10 UTC (rev 4675)
@@ -1,7 +1,7 @@
 SET(ADMaudiofilter_SRCS 
 	audiodeng_buildfilters.cpp    
 #        audiofilter_film2pal.cpp   
-	audiofilter_bridge.cpp         
+#	audiofilter_bridge.cpp         
 #        audiofilter_limiter.cpp    
 	audiofilter_buildchain.cpp     
         audiofilter_mixer.cpp

Modified: branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_buildchain.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_buildchain.cpp	2009-03-11 18:41:08 UTC (rev 4674)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_buildchain.cpp	2009-03-11 18:41:10 UTC (rev 4675)
@@ -109,7 +109,7 @@
   int32_t timeShiftMs=audioDelay*audioShift;
   
   
-  firstFilter = new AUDMAudioFilter_Bridge(NULL,video_body, starttime,timeShiftMs);
+  firstFilter = new AUDMAudioFilter_Bridge(video_body, starttime,timeShiftMs);
   filtercount = 0;
   lastFilter = firstFilter;
   filtersFloat[filtercount++] = firstFilter;
@@ -212,7 +212,7 @@
         
 //  deleteAudioFilter(NULL);
   
-  lastFilter = new AUDMAudioFilter_Bridge(NULL,video_body,sstart,timeShiftMs);
+  lastFilter = new AUDMAudioFilter_Bridge(video_body,sstart,timeShiftMs);
         filtercount = 0;
         filtersFloat[filtercount++] = lastFilter;
         

Modified: branches/avidemux_2.6_branch_mean/avidemux/ADM_editor/ADM_edit.hxx
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_editor/ADM_edit.hxx	2009-03-11 18:41:08 UTC (rev 4674)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_editor/ADM_edit.hxx	2009-03-11 18:41:10 UTC (rev 4675)
@@ -261,9 +261,7 @@
                                                 uint32_t        ptsDtsDelta(uint32_t framenum) ;
 					//*******************************************	
 						uint32_t 	getSpecificMpeg4Info( void );
-					//______________________________
-					//   audioStream
-					//______________________________
+/************************************ audioStream ******************************/
 protected:
 #define ADM_EDITOR_PACKET_BUFFER_SIZE (20*1024)
                         uint8_t  packetBuffer[ADM_EDITOR_PACKET_BUFFER_SIZE];
@@ -282,12 +280,14 @@
         uint8_t			getAudioStream(ADM_audioStream **audio);
 virtual WAVHeader       *getInfo(void);
 virtual CHANNEL_TYPE    *getChannelMapping(void );
+/************************************ /audioStream ******************************/
 					//______________________________
 					//   /audioStream
 					//______________________________
                     uint8_t         getAudioStreamsInfo(uint32_t frame,uint32_t *nbStreams, audioInfo **infos);
                     uint8_t         changeAudioStream(uint32_t frame,uint32_t newstream);
                     uint32_t        getCurrentAudioStreamNumber(uint32_t frame);
+
                     // /other audio stuff
 
 			     		uint8_t 			setDecodeParam( uint32_t frame );

Modified: branches/avidemux_2.6_branch_mean/avidemux/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/CMakeLists.txt	2009-03-11 18:41:08 UTC (rev 4674)
+++ branches/avidemux_2.6_branch_mean/avidemux/CMakeLists.txt	2009-03-11 18:41:10 UTC (rev 4675)
@@ -57,6 +57,7 @@
 INCLUDE_DIRECTORIES("${CMAKE_CURRENT_SOURCE_DIR}/ADM_coreUI/include")
 INCLUDE_DIRECTORIES("${CMAKE_CURRENT_SOURCE_DIR}/ADM_coreImage/include")
 INCLUDE_DIRECTORIES("${CMAKE_CURRENT_SOURCE_DIR}/ADM_coreAudio/include")
+INCLUDE_DIRECTORIES("${CMAKE_CURRENT_SOURCE_DIR}/ADM_audioFilter/include")
 INCLUDE_DIRECTORIES("${CMAKE_CURRENT_SOURCE_DIR}/ADM_audioParser/include")
 INCLUDE_DIRECTORIES("${CMAKE_CURRENT_SOURCE_DIR}/ADM_coreUtils/include")
 INCLUDE_DIRECTORIES("${CMAKE_CURRENT_SOURCE_DIR}/ADM_coreAudioDevice/include")
@@ -347,6 +348,8 @@
 ADD_LIB_ALL_TARGETS(ADM_audioParser)
 ADD_SUBDIRECTORY(ADM_coreAudio)
 ADD_LIB_ALL_TARGETS(ADM_coreAudio)
+ADD_SUBDIRECTORY(ADM_audioFilter)
+ADD_LIB_ALL_TARGETS(ADM_audioFilter)
 ADD_SUBDIRECTORY(ADM_coreDemuxer)
 ADD_LIB_ALL_TARGETS(ADM_coreDemuxer)
 ADD_SUBDIRECTORY(ADM_coreDemuxerMpeg)



From mean at mail.berlios.de  Wed Mar 11 19:41:12 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Wed, 11 Mar 2009 19:41:12 +0100
Subject: [Avidemux-svn-commit] r4676 - in
	branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter:
	include src
Message-ID: <200903111841.n2BIfCIt005909@sheep.berlios.de>

Author: mean
Date: 2009-03-11 19:41:11 +0100 (Wed, 11 Mar 2009)
New Revision: 4676

Removed:
   branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/src/.CMakeLists.txt.swp
Modified:
   branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/include/audiofilter_access.h
   branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/src/audiofilter_access.cpp
Log:
[audioFilter_access] Skeleton

Modified: branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/include/audiofilter_access.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/include/audiofilter_access.h	2009-03-11 18:41:10 UTC (rev 4675)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/include/audiofilter_access.h	2009-03-11 18:41:11 UTC (rev 4676)
@@ -1,11 +1,9 @@
 /***************************************************************************
-         Bridge
-         
-         This file is a bridge from output of decoder to filter api
-         
+            \file audiofilter_access.h
+            \brief convert audiofilter to audioaccess (used for playback for example)
+            (C) Mean 2009 fixounet at free.fr
  ***************************************************************************/
  
- 
 /***************************************************************************
  *                                                                         *
  *   This program is free software; you can redistribute it and/or modify  *
@@ -14,27 +12,48 @@
  *   (at your option) any later version.                                   *
  *                                                                         *
  ***************************************************************************/
-#ifndef AUDM_BRIDGE_H
-#include "audioencoder.h"
-#include "ADM_audio/aviaudio.hxx"
+#ifndef AUDM_ACCESS_H
+#define AUDM_ACCESS_H
+
 #include "ADM_audioStream.h"
-#include "../ADM_editor/ADM_edit.hxx"
-class AUDMAudioFilter_Bridge : public AUDMAudioFilter
+/**
+    \class ADMAudioFilter_Access
+    \brief Bridge audioFilter->Access
+
+*/
+class ADMAudioFilter_Access : public ADM_audioAccess
 {
   protected:
-    ADM_Composer  *_incoming;
-    uint32_t _startTime; /*< Starting time in ms */
-    int32_t  _shift;  /*< Shift in Ms */
-    int32_t  _hold;   /*< Nb Sample to repeat */
-    virtual uint8_t fillIncomingBuffer(AUD_Status *status);
+    uint64_t            startTimeUs; /*< Starting time in us */
+    AUDMAudioFilter     *filter;
+    WAVHeader           header;
   public:
-    AUDMAudioFilter_Bridge(ADM_Composer *incoming, uint32_t startInMs,int32_t shiftMS);
-    virtual                ~AUDMAudioFilter_Bridge();
-    virtual    uint32_t   fill(uint32_t max,float *output,AUD_Status *status);      // Fill buffer: incoming -> us
-                                                                                           // Output MAXIMUM max float value
-                                                                                           // Not sample! float!
-    virtual    uint8_t    rewind(void)  ;                                              // go back to the beginning
-    virtual CHANNEL_TYPE *getChannelMapping(void);
+                WAVHeader         *getWavHeader(void) {return &header;}
+
+                                    ADMAudioFilter_Access(AUDMAudioFilter *incoming,uint64_t timeUs) ;
+                virtual           ~ADMAudioFilter_Access();
+                                    /// Return true if the demuxer can seek in time
+                virtual bool      canSeekTime(void) {return false;};
+                                    /// Return true if the demuxer can seek by offser
+                virtual bool      canSeekOffset(void) {return true;};
+                                    /// Return true if we can have the audio duration
+                virtual bool      canGetDuration(void) {return false;};
+                                    /// Returns length in bytes of the audio stream
+                virtual uint32_t  getLength(void){return 0;}
+                                    /// Set position in bytes
+                virtual bool      setPos(uint64_t pos);
+                                    /// Get position in bytes
+                virtual uint64_t  getPos(void);
+                                    /// Grab extra data
+                virtual bool      getExtraData(uint32_t *l, uint8_t **d)
+                                    {
+                                            *l=extraDataLen;    
+                                            *d=extraData;
+                                            return true;
+                                    };
+
+                
+                virtual bool    getPacket(uint8_t *buffer, uint32_t *size, uint32_t maxSize,uint64_t *dts);    
 };
 
 

Deleted: branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/src/.CMakeLists.txt.swp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/src/.CMakeLists.txt.swp	2009-03-11 18:41:10 UTC (rev 4675)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/src/.CMakeLists.txt.swp	2009-03-11 18:41:11 UTC (rev 4676)
@@ -1 +0,0 @@
-b0VIM 7.1





r_SRCS
\ No newline at end of file

Modified: branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/src/audiofilter_access.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/src/audiofilter_access.cpp	2009-03-11 18:41:10 UTC (rev 4675)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/src/audiofilter_access.cpp	2009-03-11 18:41:11 UTC (rev 4676)
@@ -1,6 +1,7 @@
 /***************************************************************************
-              Convert output of decoder to filter api
-              (c) 2006 Mean , fixounet at free.fr
+            \file audiofilter_access.cpp
+            \brief convert audiofilter to audioaccess (used for playback for example)
+            (C) Mean 2009 fixounet at free.fr
  ***************************************************************************/
 
 /***************************************************************************
@@ -17,160 +18,48 @@
 #include <math.h>
 
 #include "ADM_audioFilter.h"
-#include "audiofilter_bridge.h"
-
-#include "ADM_osSupport/ADM_debugID.h"
-#define MODULE_NAME MODULE_AUDIO_FILTER
-#include "ADM_osSupport/ADM_debug.h"
-
+#include "audiofilter_access.h"
 /**
-    \fn AUDMAudioFilter_Bridge
+    \fn ADMAudioFilter_Access
 */
-AUDMAudioFilter_Bridge::AUDMAudioFilter_Bridge(ADM_Composer *incoming,
-                          uint32_t startInMs,int32_t shiftMs) : AUDMAudioFilter(NULL)
+ADMAudioFilter_Access::ADMAudioFilter_Access(AUDMAudioFilter *incoming,uint64_t timeUs)
 {
-  _incoming=incoming;
-  memcpy(&_wavHeader,_incoming->getInfo(),sizeof(_wavHeader));
-  _startTime=startInMs;
-  shiftMs=-shiftMs;
-  _shift=shiftMs;
-  _hold=0;
-  rewind();
-  
-  printf("[Bridge] Starting with time %u, shift %d\n",startInMs,-shiftMs);
-  // If shiftMS is > 0, it means we have to go in the future, just increse _startTime
-  if(shiftMs>0)
-  {
-    _startTime+=_shift;
-  }
-  else if(shiftMs<0) // In that case we have to go either in the past and/or duplicate frames
-  {
-    shiftMs=-shiftMs;
-    if(_startTime>shiftMs)  
-    {
-      _startTime-=shiftMs;
-    }else
-    {
-      double nbSample;
-      
-      shiftMs-=_startTime;
-      _startTime=0;
-      nbSample=shiftMs;
-      nbSample*=_wavHeader.frequency; 
-      nbSample/=1000.;
-      nbSample*=_wavHeader.channels;
-      _hold=(int32_t)nbSample;
-    }
+    filter=incoming;
+    ADM_assert(filter);
+    startTimeUs=timeUs;
+    memcpy(&header,incoming->getInfo(),sizeof(header));
     
-  }
-  printf("[Bridge] Ending with time %u, sample %u\n",_startTime,_hold);
-  rewind();
+    printf("[FilterAccess] Created, starting at %"LU" ms\n",(uint32_t)(timeUs/1000));
 }
 /**
-    \fn ~AUDMAudioFilter_Bridge
+    \fn ~ADMAudioFilter_Access
 */
-
-AUDMAudioFilter_Bridge::~AUDMAudioFilter_Bridge()
+ADMAudioFilter_Access::~ADMAudioFilter_Access()
 {
-  printf("[Bridge] Destroying bridge\n");
+    printf("[FilterAccess] Destroyed\n");
 }
 /**
-    \fn rewind
+    \fn setPos
+    \brief only goto 0 is allowed
 */
-uint8_t AUDMAudioFilter_Bridge::rewind(void)
+bool      ADMAudioFilter_Access::setPos(uint64_t pos)
 {
-uint64_t ttime=_startTime;
-  ttime*=1000; // ms->us
-  printf("[Bridge] Going to time %d\n",_startTime);
-  uint8_t r= _incoming->goToTime(ttime);
-  if(!r) printf("[Bridge] Failed!\n");
-  return r;
+    return filter->rewind();
 }
 /**
-    \fn fill
+    \fn getPos
 */
-uint32_t   AUDMAudioFilter_Bridge::fill(uint32_t max,float *output,AUD_Status *status)
+              
+uint64_t  ADMAudioFilter_Access::getPos(void)
 {
-  uint32_t asked,asked2,total=0;
-  //
-  ADM_assert(_tail>=_head);
-  shrink();
-  ADM_assert(_tail>=_head);
-  fillIncomingBuffer(status);
-  // Now fill output
-  // We could probably skip the buffering step
-  // one extra memcpy gained
-  uint32_t available;
-  ADM_assert(_tail>=_head);
-  available=_tail-_head;
-  if(available>max) available=max;
-  memcpy(output,&(_incomingBuffer[_head]),available*sizeof(float));
-  _head+=available;
-  if(!available)
-  {
-    printf("[bridge] No data in %u max %u out %u\n",_tail-_head,max,available);
-  }
-  return available;
-
+    return 0;
 }
+           
 /**
-    \fn fillIncomingBuffer
-*/
-uint8_t AUDMAudioFilter_Bridge::fillIncomingBuffer(AUD_Status *status)
+    \fn getPacket
+*/                
+bool    ADMAudioFilter_Access::getPacket(uint8_t *buffer, uint32_t *size, uint32_t maxSize,uint64_t *dts)
 {
-  uint32_t asked,got;
-  uint64_t dts;
-  *status=AUD_OK;
-  // Hysteresis
-  if((_tail-_head)<(AUD_PROCESS_BUFFER_SIZE>>2)) // Less than 1/4 full
-  {
 
-    while ((  _tail < (3*AUD_PROCESS_BUFFER_SIZE)/5)) // Fill up to 3/5--3/4
-    {
-      // don't ask too much front.
-      asked = (3*AUD_PROCESS_BUFFER_SIZE)/4-_tail;
-      if(_hold)
-      {
-        int32_t sam;
-         
-        sam=_hold/_wavHeader.channels;
-        sam++;
-        sam*=_wavHeader.channels;
-        if(asked>sam) asked=sam;
-        
-      }
-      asked/=_wavHeader.channels; // float->samples
-      _incoming->getPCMPacket(&(_incomingBuffer[_tail]), asked, &got,&dts);
-      got*=_wavHeader.channels; // sample->float
-      if (!got )
-      {
-        *status=AUD_END_OF_STREAM;
-        printf("[Bridge] End of stream\n");
-        break;
-      }
-      _tail+=got;
-      if(_hold>0)
-      {
-        _hold-=got;
-        if(_hold<=0)
-        {
-          printf("[Bridge] Looping\n");
-          rewind();
-          //_tail=_head=0;
-          _hold=0;
-        }
-      }
-    }
-  }
-  return 1;
 }
-/**
- * 	\fn return _incoming->getChannelMapping();
- * \brief since it is a bridge, we translate the filter channel mapping from the audiostream channel mapping
- */
-CHANNEL_TYPE *AUDMAudioFilter_Bridge::getChannelMapping(void) 
-{
-	ADM_assert(_incoming);
-	return _incoming->getChannelMapping();
-}
 //EOF



From mean at mail.berlios.de  Wed Mar 11 19:40:47 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Wed, 11 Mar 2009 19:40:47 +0100
Subject: [Avidemux-svn-commit] r4669 -
	branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/Mp4
Message-ID: <200903111840.n2BIelUJ005756@sheep.berlios.de>

Author: mean
Date: 2009-03-11 19:40:47 +0100 (Wed, 11 Mar 2009)
New Revision: 4669

Modified:
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/Mp4/ADM_mp4Analyzer.cpp
Log:
[Demuxer/mov] oops

Modified: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/Mp4/ADM_mp4Analyzer.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/Mp4/ADM_mp4Analyzer.cpp	2009-03-11 18:40:45 UTC (rev 4668)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/Mp4/ADM_mp4Analyzer.cpp	2009-03-11 18:40:47 UTC (rev 4669)
@@ -841,10 +841,6 @@
                                         }
                                         break;
                                     
-                                    {
-                                            audioCodec(MSADPCM);
-                                            break;
-                                    }
                                 
                                     case MKFCCR('m','s',0,0x55): // why 55 ???
                                     case MKFCCR('m','s',0,0x11): // why 11 ???



From gruntster at mail.berlios.de  Wed Mar 11 20:48:10 2009
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Wed, 11 Mar 2009 20:48:10 +0100
Subject: [Avidemux-svn-commit] r4677 -
	branches/avidemux_2.5_branch_gruntster/scripts
Message-ID: <200903111948.n2BJmAH5018487@sheep.berlios.de>

Author: gruntster
Date: 2009-03-11 20:48:03 +0100 (Wed, 11 Mar 2009)
New Revision: 4677

Modified:
   branches/avidemux_2.5_branch_gruntster/scripts/CMakeLists.txt
Log:
[script] exclude svn folder from installation of system scripts

Modified: branches/avidemux_2.5_branch_gruntster/scripts/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/scripts/CMakeLists.txt	2009-03-11 18:41:11 UTC (rev 4676)
+++ branches/avidemux_2.5_branch_gruntster/scripts/CMakeLists.txt	2009-03-11 19:48:03 UTC (rev 4677)
@@ -4,4 +4,4 @@
 	SET(scriptInstallDir ${CMAKE_INSTALL_PREFIX}/share/ADM_scripts)
 endif (WIN32)
 
-install(DIRECTORY . DESTINATION "${scriptInstallDir}" FILES_MATCHING PATTERN "*.js")
\ No newline at end of file
+install(DIRECTORY . DESTINATION "${scriptInstallDir}" FILES_MATCHING PATTERN "*.js" PATTERN ".svn" EXCLUDE)
\ No newline at end of file



From gruntster at mail.berlios.de  Wed Mar 11 20:53:09 2009
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Wed, 11 Mar 2009 20:53:09 +0100
Subject: [Avidemux-svn-commit] r4678 -
	branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_gui
Message-ID: <200903111953.n2BJr97d020148@sheep.berlios.de>

Author: gruntster
Date: 2009-03-11 20:53:02 +0100 (Wed, 11 Mar 2009)
New Revision: 4678

Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_gui/Q_gui2.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_gui/gui2.ui
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_gui/translation_table.h
Log:
[auto] remove internal auto wizards from Qt interface

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_gui/Q_gui2.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_gui/Q_gui2.cpp	2009-03-11 19:48:03 UTC (rev 4677)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_gui/Q_gui2.cpp	2009-03-11 19:53:02 UTC (rev 4678)
@@ -634,6 +634,9 @@
 
 	if (autoDirInfo.isDir())
 		addDirEntryToMenu(ui.menuAuto, autoDirInfo.filePath());
+
+	if (ui.menuAuto->isEmpty())
+		ui.menuAuto->setEnabled(false);
 }
 
 void MainWindow::closeEvent(QCloseEvent *event)

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_gui/gui2.ui
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_gui/gui2.ui	2009-03-11 19:48:03 UTC (rev 4677)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_gui/gui2.ui	2009-03-11 19:53:02 UTC (rev 4678)
@@ -1403,18 +1403,6 @@
     <addaction name="actionJump_to_Frame" />
     <addaction name="actionJump_to_Time" />
    </widget>
-   <widget class="QMenu" name="menuAuto" >
-    <property name="title" >
-     <string>A&amp;uto</string>
-    </property>
-    <addaction name="actionVCD" />
-    <addaction name="actionSVCD" />
-    <addaction name="actionDVD" />
-    <addaction name="actionPSP" />
-    <addaction name="actionPSP_H264" />
-    <addaction name="actionFLV" />
-    <addaction name="actionIPOD" />
-   </widget>
    <widget class="QMenu" name="menuFile" >
     <property name="title" >
      <string>&amp;File</string>
@@ -1466,6 +1454,11 @@
     <addaction name="separator" />
     <addaction name="actionAbout_avidemux" />
    </widget>
+   <widget class="QMenu" name="menuAuto" >
+    <property name="title" >
+     <string>A&amp;uto</string>
+    </property>
+   </widget>
    <addaction name="menuFile" />
    <addaction name="menuEdit" />
    <addaction name="menuView" />

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_gui/translation_table.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_gui/translation_table.h	2009-03-11 19:48:03 UTC (rev 4677)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_gui/translation_table.h	2009-03-11 19:53:02 UTC (rev 4678)
@@ -63,13 +63,6 @@
 PROCESS(actionRecent1,ACT_RECENT1) \
 PROCESS(actionRecent2,ACT_RECENT2) \
 PROCESS(actionRecent3,ACT_RECENT3) \
-PROCESS(actionVCD,ACT_AUTO_VCD) \
-PROCESS(actionSVCD,ACT_AUTO_SVCD) \
-PROCESS(actionDVD,ACT_AUTO_DVD) \
-PROCESS(actionPSP,ACT_AUTO_PSP) \
-PROCESS(actionFLV,ACT_AUTO_FLV) \
-PROCESS(actionPSP_H264,ACT_AUTO_PSP_H264)\
-PROCESS(actionIPOD,ACT_AUTO_IPOD) \
 PROCESS(actionAdd_to_joblist,ACT_ADD_JOB) \
 PROCESS(actionShow_Joblist,ACT_HANDLE_JOB)  
 



From gruntster at mail.berlios.de  Wed Mar 11 22:13:57 2009
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Wed, 11 Mar 2009 22:13:57 +0100
Subject: [Avidemux-svn-commit] r4679 -
	branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/qt4
Message-ID: <200903112113.n2BLDvL0029755@sheep.berlios.de>

Author: gruntster
Date: 2009-03-11 22:13:51 +0100 (Wed, 11 Mar 2009)
New Revision: 4679

Modified:
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/qt4/x264ConfigDialog.cpp
Log:
[x264] fix loading of idc level

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/qt4/x264ConfigDialog.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/qt4/x264ConfigDialog.cpp	2009-03-11 19:53:02 UTC (rev 4678)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/qt4/x264ConfigDialog.cpp	2009-03-11 21:13:51 UTC (rev 4679)
@@ -43,7 +43,7 @@
 	static const int _predefinedARs[aspectRatioCount][2] = {{16, 15}, {64, 45}, {8, 9}, {32, 27}};
 
 	// Mappings for x264 array index -> UI combobox index
-	static const int _idcLevel[idcLevelCount] = {-1, 1, 11, 12, 13, 2, 21, 22, 3, 31, 32, 4, 41, 42, 5, 51};
+	static const uint8_t _idcLevel[idcLevelCount] = {-1, 1, 11, 12, 13, 2, 21, 22, 3, 31, 32, 4, 41, 42, 5, 51};
 	static const uint8_t _videoFormat[videoFormatCount] = {5, 0, 1, 2, 3, 4};
 	static const uint8_t _colourPrimaries[colourPrimariesCount] = {2, 1, 4, 5, 6, 7, 8};
 	static const uint8_t _transferCharacteristics[transferCharacteristicsCount] = {2, 1, 4, 5, 8, 9, 10, 6, 7};
@@ -1000,4 +1000,4 @@
 	}
 
 	return 0;
-}
+}
\ No newline at end of file



From gruntster at mail.berlios.de  Wed Mar 11 22:25:36 2009
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Wed, 11 Mar 2009 22:25:36 +0100
Subject: [Avidemux-svn-commit] r4680 - in
	branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder:
	ADM_vidEnc_x264 ADM_vidEnc_xvid
Message-ID: <200903112125.n2BLPaca031626@sheep.berlios.de>

Author: gruntster
Date: 2009-03-11 22:25:29 +0100 (Wed, 11 Mar 2009)
New Revision: 4680

Modified:
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/x264Param.xsd
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_xvid/XvidParam.xsd
Log:
[x264/xvid] make all schema elements optional

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/x264Param.xsd
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/x264Param.xsd	2009-03-11 21:13:51 UTC (rev 4679)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/x264Param.xsd	2009-03-11 21:25:29 UTC (rev 4680)
@@ -40,9 +40,9 @@
         <xs:element name="x264Options">
           <xs:complexType>
             <xs:sequence>
-              <xs:element name="threads" type="uint"/>
-              <xs:element name="deterministic" type="xs:boolean"/>
-              <xs:element name="idcLevel">
+              <xs:element name="threads" type="uint" minOccurs="0"/>
+              <xs:element name="deterministic" type="xs:boolean" minOccurs="0"/>
+              <xs:element name="idcLevel" minOccurs="0">
                 <xs:simpleType>
                   <xs:restriction base="xs:integer">
                     <xs:enumeration value="-1"/>
@@ -64,13 +64,13 @@
                   </xs:restriction>
                 </xs:simpleType>
               </xs:element>
-              <xs:element name="vui">
+              <xs:element name="vui" minOccurs="0">
                 <xs:complexType>
                   <xs:sequence>
-                    <xs:element name="sarAsInput" type="xs:boolean"/>
-                    <xs:element name="sarHeight" type="uint"/>
-                    <xs:element name="sarWidth" type="uint"/>
-                    <xs:element name="overscan">
+                    <xs:element name="sarAsInput" type="xs:boolean" minOccurs="0"/>
+                    <xs:element name="sarHeight" type="uint" minOccurs="0"/>
+                    <xs:element name="sarWidth" type="uint" minOccurs="0"/>
+                    <xs:element name="overscan" minOccurs="0">
                       <xs:simpleType>
                         <xs:restriction base="xs:string">
                           <xs:enumeration value="undefined"/>
@@ -79,7 +79,7 @@
                         </xs:restriction>
                       </xs:simpleType>
                     </xs:element>
-                    <xs:element name="videoFormat">
+                    <xs:element name="videoFormat" minOccurs="0">
                       <xs:simpleType>
                         <xs:restriction base="xs:string">
                           <xs:enumeration value="component"/>
@@ -91,8 +91,8 @@
                         </xs:restriction>
                       </xs:simpleType>
                     </xs:element>
-                    <xs:element name="fullRangeSamples" type="xs:boolean"/>
-                    <xs:element name="colorPrimaries">
+                    <xs:element name="fullRangeSamples" type="xs:boolean" minOccurs="0"/>
+                    <xs:element name="colorPrimaries" minOccurs="0">
                       <xs:simpleType>
                         <xs:restriction base="xs:string">
                           <xs:enumeration value="undefined"/>
@@ -105,7 +105,7 @@
                         </xs:restriction>
                       </xs:simpleType>
                     </xs:element>
-                    <xs:element name="transfer">
+                    <xs:element name="transfer" minOccurs="0">
                       <xs:simpleType>
                         <xs:restriction base="xs:string">
                           <xs:enumeration value="undefined"/>
@@ -120,7 +120,7 @@
                         </xs:restriction>
                       </xs:simpleType>
                     </xs:element>
-                    <xs:element name="colorMatrix">
+                    <xs:element name="colorMatrix" minOccurs="0">
                       <xs:simpleType>
                         <xs:restriction base="xs:string">
                           <xs:enumeration value="undefined"/>
@@ -134,7 +134,7 @@
                         </xs:restriction>
                       </xs:simpleType>
                     </xs:element>
-                    <xs:element name="chromaSampleLocation">
+                    <xs:element name="chromaSampleLocation" minOccurs="0">
                       <xs:simpleType>
                         <xs:restriction base="xs:integer">
                           <xs:minInclusive value="0"/>
@@ -145,7 +145,7 @@
                   </xs:sequence>
                 </xs:complexType>
               </xs:element>
-              <xs:element name="referenceFrames">
+              <xs:element name="referenceFrames" minOccurs="0">
                 <xs:simpleType>
                   <xs:restriction base="xs:integer">
                     <xs:minInclusive value="1"/>
@@ -153,7 +153,7 @@
                   </xs:restriction>
                 </xs:simpleType>
               </xs:element>
-              <xs:element name="gopMaximumSize">
+              <xs:element name="gopMaximumSize" minOccurs="0">
                 <xs:simpleType>
                   <xs:restriction base="xs:integer">
                     <xs:minInclusive value="0"/>
@@ -161,7 +161,7 @@
                   </xs:restriction>
                 </xs:simpleType>
               </xs:element>
-              <xs:element name="gopMinimumSize">
+              <xs:element name="gopMinimumSize" minOccurs="0">
                 <xs:simpleType>
                   <xs:restriction base="xs:integer">
                     <xs:minInclusive value="0"/>
@@ -169,7 +169,7 @@
                   </xs:restriction>
                 </xs:simpleType>
               </xs:element>
-              <xs:element name="scenecutThreshold">
+              <xs:element name="scenecutThreshold" minOccurs="0">
                 <xs:simpleType>
                   <xs:restriction base="xs:integer">
                     <xs:minInclusive value="0"/>
@@ -177,8 +177,8 @@
                   </xs:restriction>
                 </xs:simpleType>
               </xs:element>
-              <xs:element name="preScenecutDetection" type="xs:boolean"/>
-              <xs:element name="bFrames">
+              <xs:element name="preScenecutDetection" type="xs:boolean" minOccurs="0"/>
+              <xs:element name="bFrames" minOccurs="0">
                 <xs:simpleType>
                   <xs:restriction base="xs:integer">
                     <xs:minInclusive value="0"/>
@@ -186,7 +186,7 @@
                   </xs:restriction>
                 </xs:simpleType>
               </xs:element>
-              <xs:element name="adaptiveBframeDecision">
+              <xs:element name="adaptiveBframeDecision" minOccurs="0">
                 <xs:simpleType>
                   <xs:restriction base="xs:integer">
                     <xs:minInclusive value="0"/>
@@ -194,7 +194,7 @@
                   </xs:restriction>
                 </xs:simpleType>
               </xs:element>
-              <xs:element name="bFrameBias">
+              <xs:element name="bFrameBias" minOccurs="0">
                 <xs:simpleType>
                   <xs:restriction base="xs:integer">
                     <xs:minInclusive value="-100"/>
@@ -202,9 +202,9 @@
                   </xs:restriction>
                 </xs:simpleType>
               </xs:element>
-              <xs:element name="bFrameReferences" type="xs:boolean"/>
-              <xs:element name="loopFilter" type="xs:boolean"/>
-              <xs:element name="loopFilterAlphaC0">
+              <xs:element name="bFrameReferences" type="xs:boolean" minOccurs="0"/>
+              <xs:element name="loopFilter" type="xs:boolean" minOccurs="0"/>
+              <xs:element name="loopFilterAlphaC0" minOccurs="0">
                 <xs:simpleType>
                   <xs:restriction base="xs:integer">
                     <xs:minInclusive value="-6"/>
@@ -212,7 +212,7 @@
                   </xs:restriction>
                 </xs:simpleType>
               </xs:element>
-              <xs:element name="loopFilterBeta">
+              <xs:element name="loopFilterBeta" minOccurs="0">
                 <xs:simpleType>
                   <xs:restriction base="xs:integer">
                     <xs:minInclusive value="-6"/>
@@ -220,9 +220,9 @@
                   </xs:restriction>
                 </xs:simpleType>
               </xs:element>
-              <xs:element name="cabac" type="xs:boolean"/>
-              <xs:element name="interlaced" type="xs:boolean"/>
-              <xs:element name="cqmPreset">
+              <xs:element name="cabac" type="xs:boolean" minOccurs="0"/>
+              <xs:element name="interlaced" type="xs:boolean" minOccurs="0"/>
+              <xs:element name="cqmPreset" minOccurs="0">
                 <xs:simpleType>
                   <xs:restriction base="xs:string">
                     <xs:enumeration value="flat"/>
@@ -231,59 +231,59 @@
                   </xs:restriction>
                 </xs:simpleType>
               </xs:element>
-              <xs:element name="intra4x4Luma">
+              <xs:element name="intra4x4Luma" minOccurs="0">
                 <xs:complexType>
                   <xs:sequence>
                     <xs:element name="value" type="uint8" minOccurs="16" maxOccurs="16"/>
                   </xs:sequence>
                 </xs:complexType>
               </xs:element>
-              <xs:element name="intraChroma">
+              <xs:element name="intraChroma" minOccurs="0">
                 <xs:complexType>
                   <xs:sequence>
                     <xs:element name="value" type="uint8" minOccurs="16" maxOccurs="16"/>
                   </xs:sequence>
                 </xs:complexType>
               </xs:element>
-              <xs:element name="inter4x4Luma">
+              <xs:element name="inter4x4Luma" minOccurs="0">
                 <xs:complexType>
                   <xs:sequence>
                     <xs:element name="value" type="uint8" minOccurs="16" maxOccurs="16"/>
                   </xs:sequence>
                 </xs:complexType>
               </xs:element>
-              <xs:element name="interChroma">
+              <xs:element name="interChroma" minOccurs="0">
                 <xs:complexType>
                   <xs:sequence>
                     <xs:element name="value" type="uint8" minOccurs="16" maxOccurs="16"/>
                   </xs:sequence>
                 </xs:complexType>
               </xs:element>
-              <xs:element name="intra8x8Luma">
+              <xs:element name="intra8x8Luma" minOccurs="0">
                 <xs:complexType>
                   <xs:sequence>
                     <xs:element name="value" type="uint8" minOccurs="64" maxOccurs="64"/>
                   </xs:sequence>
                 </xs:complexType>
               </xs:element>
-              <xs:element name="inter8x8Luma">
+              <xs:element name="inter8x8Luma" minOccurs="0">
                 <xs:complexType>
                   <xs:sequence>
                     <xs:element name="value" type="uint8" minOccurs="64" maxOccurs="64"/>
                   </xs:sequence>
                 </xs:complexType>
               </xs:element>
-              <xs:element name="analyse">
+              <xs:element name="analyse" minOccurs="0">
                 <xs:complexType>
                   <xs:sequence>
-                    <xs:element name="partitionI4x4" type="xs:boolean"/>
-                    <xs:element name="partitionI8x8" type="xs:boolean"/>
-                    <xs:element name="partitionP8x8" type="xs:boolean"/>
-                    <xs:element name="partitionP4x4" type="xs:boolean"/>
-                    <xs:element name="partitionB8x8" type="xs:boolean"/>
-                    <xs:element name="dct8x8" type="xs:boolean"/>
-                    <xs:element name="weightedPrediction" type="xs:boolean"/>
-                    <xs:element name="directPredictionMode">
+                    <xs:element name="partitionI4x4" type="xs:boolean" minOccurs="0"/>
+                    <xs:element name="partitionI8x8" type="xs:boolean" minOccurs="0"/>
+                    <xs:element name="partitionP8x8" type="xs:boolean" minOccurs="0"/>
+                    <xs:element name="partitionP4x4" type="xs:boolean" minOccurs="0"/>
+                    <xs:element name="partitionB8x8" type="xs:boolean" minOccurs="0"/>
+                    <xs:element name="dct8x8" type="xs:boolean" minOccurs="0"/>
+                    <xs:element name="weightedPrediction" type="xs:boolean" minOccurs="0"/>
+                    <xs:element name="directPredictionMode" minOccurs="0">
                       <xs:simpleType>
                         <xs:restriction base="xs:string">
                           <xs:enumeration value="none"/>
@@ -302,7 +302,7 @@
                         </xs:restriction>
                       </xs:simpleType>
                     </xs:element>
-                    <xs:element name="chromaLumaQuantiserDifference">
+                    <xs:element name="chromaLumaQuantiserDifference" minOccurs="0">
                       <xs:simpleType>
                         <xs:restriction base="xs:integer">
                           <xs:minInclusive value="-12"/>
@@ -310,7 +310,7 @@
                         </xs:restriction>
                       </xs:simpleType>
                     </xs:element>
-                    <xs:element name="motionEstimationMethod">
+                    <xs:element name="motionEstimationMethod" minOccurs="0">
                       <xs:simpleType>
                         <xs:restriction base="xs:string">
                           <xs:enumeration value="diamond"/>
@@ -321,7 +321,7 @@
                         </xs:restriction>
                       </xs:simpleType>
                     </xs:element>
-                    <xs:element name="motionVectorSearchRange">
+                    <xs:element name="motionVectorSearchRange" minOccurs="0">
                       <xs:simpleType>
                         <xs:restriction base="xs:integer">
                           <xs:minInclusive value="0"/>
@@ -329,7 +329,7 @@
                         </xs:restriction>
                       </xs:simpleType>
                     </xs:element>
-                    <xs:element name="motionVectorLength">
+                    <xs:element name="motionVectorLength" minOccurs="0">
                       <xs:simpleType>
                         <xs:restriction base="xs:integer">
                           <xs:minInclusive value="-1"/>
@@ -337,8 +337,8 @@
                         </xs:restriction>
                       </xs:simpleType>
                     </xs:element>
-                    <xs:element name="motionVectorThreadBuffer" type="xs:integer"/>
-                    <xs:element name="subpixelRefinement">
+                    <xs:element name="motionVectorThreadBuffer" type="xs:integer" minOccurs="0"/>
+                    <xs:element name="subpixelRefinement" minOccurs="0">
                       <xs:simpleType>
                         <xs:restriction base="xs:integer">
                           <xs:minInclusive value="1"/>
@@ -347,10 +347,10 @@
                       </xs:simpleType>
                     </xs:element>
                     <xs:element name="bidirectionalMotionEstimation" type="xs:boolean" minOccurs="0"/>
-                    <xs:element name="chromaMotionEstimation" type="xs:boolean"/>
+                    <xs:element name="chromaMotionEstimation" type="xs:boolean" minOccurs="0"/>
                     <xs:element name="bFrameRdo" type="xs:boolean" minOccurs="0"/>
-                    <xs:element name="mixedReferences" type="xs:boolean"/>
-                    <xs:element name="trellis">
+                    <xs:element name="mixedReferences" type="xs:boolean" minOccurs="0"/>
+                    <xs:element name="trellis" minOccurs="0">
                       <xs:simpleType>
                         <xs:restriction base="xs:string">
                           <xs:enumeration value="disabled"/>
@@ -359,9 +359,9 @@
                         </xs:restriction>
                       </xs:simpleType>
                     </xs:element>
-                    <xs:element name="fastPSkip" type="xs:boolean"/>
-                    <xs:element name="dctDecimate" type="xs:boolean"/>
-                    <xs:element name="noiseReduction">
+                    <xs:element name="fastPSkip" type="xs:boolean" minOccurs="0"/>
+                    <xs:element name="dctDecimate" type="xs:boolean" minOccurs="0"/>
+                    <xs:element name="noiseReduction" minOccurs="0">
                       <xs:simpleType>
                         <xs:restriction base="xs:integer">
                           <xs:minInclusive value="0"/>
@@ -369,7 +369,7 @@
                         </xs:restriction>
                       </xs:simpleType>
                     </xs:element>
-                    <xs:element name="interLumaDeadzone">
+                    <xs:element name="interLumaDeadzone" minOccurs="0">
                       <xs:simpleType>
                         <xs:restriction base="xs:integer">
                           <xs:minInclusive value="0"/>
@@ -377,7 +377,7 @@
                         </xs:restriction>
                       </xs:simpleType>
                     </xs:element>
-                    <xs:element name="intraLumaDeadzone">
+                    <xs:element name="intraLumaDeadzone" minOccurs="0">
                       <xs:simpleType>
                         <xs:restriction base="xs:integer">
                           <xs:minInclusive value="0"/>
@@ -388,10 +388,10 @@
                   </xs:sequence>
                 </xs:complexType>
               </xs:element>
-              <xs:element name="rateControl">
+              <xs:element name="rateControl" minOccurs="0">
                 <xs:complexType>
                   <xs:sequence>
-                    <xs:element name="quantiserMinimum">
+                    <xs:element name="quantiserMinimum" minOccurs="0">
                       <xs:simpleType>
                         <xs:restriction base="xs:integer">
                           <xs:minInclusive value="10"/>
@@ -399,7 +399,7 @@
                         </xs:restriction>
                       </xs:simpleType>
                     </xs:element>
-                    <xs:element name="quantiserMaximum">
+                    <xs:element name="quantiserMaximum" minOccurs="0">
                       <xs:simpleType>
                         <xs:restriction base="xs:integer">
                           <xs:minInclusive value="10"/>
@@ -407,7 +407,7 @@
                         </xs:restriction>
                       </xs:simpleType>
                     </xs:element>
-                    <xs:element name="quantiserStep">
+                    <xs:element name="quantiserStep" minOccurs="0">
                       <xs:simpleType>
                         <xs:restriction base="xs:integer">
                           <xs:minInclusive value="0"/>
@@ -415,7 +415,7 @@
                         </xs:restriction>
                       </xs:simpleType>
                     </xs:element>
-                    <xs:element name="averageBitrateTolerance">
+                    <xs:element name="averageBitrateTolerance" minOccurs="0">
                       <xs:simpleType>
                         <xs:restriction base="xs:float">
                           <xs:minInclusive value="0"/>
@@ -423,7 +423,7 @@
                         </xs:restriction>
                       </xs:simpleType>
                     </xs:element>
-                    <xs:element name="vbvMaximumBitrate">
+                    <xs:element name="vbvMaximumBitrate" minOccurs="0">
                       <xs:simpleType>
                         <xs:restriction base="xs:integer">
                           <xs:minInclusive value="0"/>
@@ -431,7 +431,7 @@
                         </xs:restriction>
                       </xs:simpleType>
                     </xs:element>
-                    <xs:element name="vbvBufferSize">
+                    <xs:element name="vbvBufferSize" minOccurs="0">
                       <xs:simpleType>
                         <xs:restriction base="xs:integer">
                           <xs:minInclusive value="0"/>
@@ -439,7 +439,7 @@
                         </xs:restriction>
                       </xs:simpleType>
                     </xs:element>
-                    <xs:element name="vbvInitialOccupancy">
+                    <xs:element name="vbvInitialOccupancy" minOccurs="0">
                       <xs:simpleType>
                         <xs:restriction base="xs:float">
                           <xs:minInclusive value="0"/>
@@ -447,7 +447,7 @@
                         </xs:restriction>
                       </xs:simpleType>
                     </xs:element>
-                    <xs:element name="ipFrameQuantiser">
+                    <xs:element name="ipFrameQuantiser" minOccurs="0">
                       <xs:simpleType>
                         <xs:restriction base="xs:float">
                           <xs:minInclusive value="1"/>
@@ -455,7 +455,7 @@
                         </xs:restriction>
                       </xs:simpleType>
                     </xs:element>
-                    <xs:element name="pbFrameQuantiser">
+                    <xs:element name="pbFrameQuantiser" minOccurs="0">
                       <xs:simpleType>
                         <xs:restriction base="xs:float">
                           <xs:minInclusive value="1"/>
@@ -472,7 +472,7 @@
                       </xs:simpleType>
                     </xs:element>
                     <xs:element name="adaptiveQuantiserStrength" type="xs:float" minOccurs="0"/>
-                    <xs:element name="quantiserCurveCompression">
+                    <xs:element name="quantiserCurveCompression" minOccurs="0">
                       <xs:simpleType>
                         <xs:restriction base="xs:float">
                           <xs:minInclusive value="0"/>
@@ -480,7 +480,7 @@
                         </xs:restriction>
                       </xs:simpleType>
                     </xs:element>
-                    <xs:element name="reduceFluxBeforeCurveCompression">
+                    <xs:element name="reduceFluxBeforeCurveCompression" minOccurs="0">
                       <xs:simpleType>
                         <xs:restriction base="xs:float">
                           <xs:minInclusive value="0"/>
@@ -488,7 +488,7 @@
                         </xs:restriction>
                       </xs:simpleType>
                     </xs:element>
-                    <xs:element name="reduceFluxAfterCurveCompression">
+                    <xs:element name="reduceFluxAfterCurveCompression" minOccurs="0">
                       <xs:simpleType>
                         <xs:restriction base="xs:float">
                           <xs:minInclusive value="0"/>
@@ -511,8 +511,8 @@
                   </xs:sequence>
                 </xs:complexType>
               </xs:element>
-              <xs:element name="accessUnitDelimiters" type="xs:boolean"/>
-              <xs:element name="spsIdentifier">
+              <xs:element name="accessUnitDelimiters" type="xs:boolean" minOccurs="0"/>
+              <xs:element name="spsIdentifier" minOccurs="0">
                 <xs:simpleType>
                   <xs:restriction base="xs:integer">
                     <xs:enumeration value="0"/>

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_xvid/XvidParam.xsd
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_xvid/XvidParam.xsd	2009-03-11 21:13:51 UTC (rev 4679)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_xvid/XvidParam.xsd	2009-03-11 21:25:29 UTC (rev 4680)
@@ -40,17 +40,17 @@
         <xs:element name="XvidOptions">
           <xs:complexType>
             <xs:sequence>
-              <xs:element name="threads" type="uint"/>
-              <xs:element name="vui">
+              <xs:element name="threads" type="uint" minOccurs="0"/>
+              <xs:element name="vui" minOccurs="0">
                 <xs:complexType>
                   <xs:sequence>
-                    <xs:element name="sarAsInput" type="xs:boolean"/>
-                    <xs:element name="sarHeight" type="uint"/>
-                    <xs:element name="sarWidth" type="uint"/>
+                    <xs:element name="sarAsInput" type="xs:boolean" minOccurs="0"/>
+                    <xs:element name="sarHeight" type="uint" minOccurs="0"/>
+                    <xs:element name="sarWidth" type="uint" minOccurs="0"/>
                   </xs:sequence>
                 </xs:complexType>
               </xs:element>
-              <xs:element name="motionEstimation">
+              <xs:element name="motionEstimation" minOccurs="0">
                 <xs:simpleType>
                   <xs:restriction base="xs:string">
                     <xs:enumeration value="none"/>
@@ -60,7 +60,7 @@
                   </xs:restriction>
                 </xs:simpleType>
               </xs:element>
-              <xs:element name="rdo">
+              <xs:element name="rdo" minOccurs="0">
                 <xs:simpleType>
                   <xs:restriction base="xs:string">
                     <xs:enumeration value="none"/>
@@ -71,16 +71,16 @@
                   </xs:restriction>
                 </xs:simpleType>
               </xs:element>
-              <xs:element name="bFrameRdo" type="xs:boolean"/>
-              <xs:element name="chromaMotionEstimation" type="xs:boolean"/>
-              <xs:element name="qPel" type="xs:boolean"/>
-              <xs:element name="gmc" type="xs:boolean"/>
-              <xs:element name="turboMode" type="xs:boolean"/>
-              <xs:element name="chromaOptimiser" type="xs:boolean"/>
-              <xs:element name="fourMv" type="xs:boolean"/>
-              <xs:element name="cartoon" type="xs:boolean"/>
-              <xs:element name="greyscale" type="xs:boolean"/>
-              <xs:element name="interlaced">
+              <xs:element name="bFrameRdo" type="xs:boolean" minOccurs="0"/>
+              <xs:element name="chromaMotionEstimation" type="xs:boolean" minOccurs="0"/>
+              <xs:element name="qPel" type="xs:boolean" minOccurs="0"/>
+              <xs:element name="gmc" type="xs:boolean" minOccurs="0"/>
+              <xs:element name="turboMode" type="xs:boolean" minOccurs="0"/>
+              <xs:element name="chromaOptimiser" type="xs:boolean" minOccurs="0"/>
+              <xs:element name="fourMv" type="xs:boolean" minOccurs="0"/>
+              <xs:element name="cartoon" type="xs:boolean" minOccurs="0"/>
+              <xs:element name="greyscale" type="xs:boolean" minOccurs="0"/>
+              <xs:element name="interlaced" minOccurs="0">
                 <xs:simpleType>
                   <xs:restriction base="xs:string">
                     <xs:enumeration value="none"/>
@@ -89,9 +89,9 @@
                   </xs:restriction>
                 </xs:simpleType>
               </xs:element>
-              <xs:element name="frameDropRatio" type="percentage" />
-              <xs:element name="maxIframeInterval" type="uint"/>
-              <xs:element name="maxBframes">
+              <xs:element name="frameDropRatio" type="percentage" minOccurs="0"/>
+              <xs:element name="maxIframeInterval" type="uint" minOccurs="0"/>
+              <xs:element name="maxBframes" minOccurs="0">
                 <xs:simpleType>
                   <xs:restriction base="xs:integer">
                     <xs:minInclusive value="0"/>
@@ -99,7 +99,7 @@
                   </xs:restriction>
                 </xs:simpleType>
               </xs:element>
-              <xs:element name="bFrameSensitivity">
+              <xs:element name="bFrameSensitivity" minOccurs="0">
                 <xs:simpleType>
                   <xs:restriction base="xs:integer">
                     <xs:minInclusive value="-255"/>
@@ -107,15 +107,15 @@
                   </xs:restriction>
                 </xs:simpleType>
               </xs:element>
-              <xs:element name="closedGop" type="xs:boolean"/>
-              <xs:element name="packed" type="xs:boolean"/>
-              <xs:element name="quantImin" type="quantiser"/>
-              <xs:element name="quantPmin" type="quantiser"/>
-              <xs:element name="quantBmin" type="quantiser"/>
-              <xs:element name="quantImax" type="quantiser"/>
-              <xs:element name="quantPmax" type="quantiser"/>
-              <xs:element name="quantBmax" type="quantiser"/>
-              <xs:element name="quantBratio">
+              <xs:element name="closedGop" type="xs:boolean" minOccurs="0"/>
+              <xs:element name="packed" type="xs:boolean" minOccurs="0"/>
+              <xs:element name="quantImin" type="quantiser" minOccurs="0"/>
+              <xs:element name="quantPmin" type="quantiser" minOccurs="0"/>
+              <xs:element name="quantBmin" type="quantiser" minOccurs="0"/>
+              <xs:element name="quantImax" type="quantiser" minOccurs="0"/>
+              <xs:element name="quantPmax" type="quantiser" minOccurs="0"/>
+              <xs:element name="quantBmax" type="quantiser" minOccurs="0"/>
+              <xs:element name="quantBratio" minOccurs="0">
                 <xs:simpleType>
                   <xs:restriction base="xs:integer">
                     <xs:minInclusive value="0"/>
@@ -123,7 +123,7 @@
                   </xs:restriction>
                 </xs:simpleType>
               </xs:element>
-              <xs:element name="quantBoffset">
+              <xs:element name="quantBoffset" minOccurs="0">
                 <xs:simpleType>
                   <xs:restriction base="xs:integer">
                     <xs:minInclusive value="0"/>
@@ -131,7 +131,7 @@
                   </xs:restriction>
                 </xs:simpleType>
               </xs:element>
-              <xs:element name="quantType">
+              <xs:element name="quantType" minOccurs="0">
                 <xs:simpleType>
                   <xs:restriction base="xs:string">
                     <xs:enumeration value="h.263"/>
@@ -140,42 +140,42 @@
                   </xs:restriction>
                 </xs:simpleType>
               </xs:element>
-              <xs:element name="intraMatrix">
+              <xs:element name="intraMatrix" minOccurs="0">
                 <xs:complexType>
                   <xs:sequence>
                     <xs:element name="value" type="uint8" minOccurs="64" maxOccurs="64"/>
                   </xs:sequence>
                 </xs:complexType>
               </xs:element>
-              <xs:element name="interMatrix">
+              <xs:element name="interMatrix" minOccurs="0">
                 <xs:complexType>
                   <xs:sequence>
                     <xs:element name="value" type="uint8" minOccurs="64" maxOccurs="64"/>
                   </xs:sequence>
                 </xs:complexType>
               </xs:element>
-              <xs:element name="trellis" type="xs:boolean"/>
-              <xs:element name="singlePass">
+              <xs:element name="trellis" type="xs:boolean" minOccurs="0"/>
+              <xs:element name="singlePass" minOccurs="0">
                 <xs:complexType>
                   <xs:sequence>
-                    <xs:element name="reactionDelayFactor" type="percentage" />
-                    <xs:element name="averagingQuantiserPeriod" type="uint"/>
-                    <xs:element name="smoother" type="uint"/>
+                    <xs:element name="reactionDelayFactor" type="percentage" minOccurs="0"/>
+                    <xs:element name="averagingQuantiserPeriod" type="uint" minOccurs="0"/>
+                    <xs:element name="smoother" type="uint" minOccurs="0"/>
                   </xs:sequence>
                 </xs:complexType>
               </xs:element>
-              <xs:element name="twoPass">
+              <xs:element name="twoPass" minOccurs="0">
                 <xs:complexType>
                   <xs:sequence>
-                    <xs:element name="keyFrameBoost" type="percentage" />
-                    <xs:element name="maxKeyFrameReduceBitrate" type="percentage" />
-                    <xs:element name="keyFrameBitrateThreshold" type="uint"/>
-                    <xs:element name="overflowControlStrength" type="percentage" />
-                    <xs:element name="maxOverflowImprovement" type="percentage" />
-                    <xs:element name="maxOverflowDegradation" type="percentage" />
-                    <xs:element name="aboveAverageCurveCompression" type="percentage" />
-                    <xs:element name="belowAverageCurveCompression" type="percentage" />
-                    <xs:element name="vbvBufferSize">
+                    <xs:element name="keyFrameBoost" type="percentage" minOccurs="0"/>
+                    <xs:element name="maxKeyFrameReduceBitrate" type="percentage" minOccurs="0"/>
+                    <xs:element name="keyFrameBitrateThreshold" type="uint" minOccurs="0"/>
+                    <xs:element name="overflowControlStrength" type="percentage" minOccurs="0"/>
+                    <xs:element name="maxOverflowImprovement" type="percentage" minOccurs="0"/>
+                    <xs:element name="maxOverflowDegradation" type="percentage" minOccurs="0"/>
+                    <xs:element name="aboveAverageCurveCompression" type="percentage" minOccurs="0"/>
+                    <xs:element name="belowAverageCurveCompression" type="percentage" minOccurs="0"/>
+                    <xs:element name="vbvBufferSize" minOccurs="0">
                       <xs:simpleType>
                         <xs:restriction base="xs:integer">
                           <xs:minInclusive value="0"/>
@@ -183,7 +183,7 @@
                         </xs:restriction>
                       </xs:simpleType>
                     </xs:element>
-                    <xs:element name="maxVbvBitrate">
+                    <xs:element name="maxVbvBitrate" minOccurs="0">
                       <xs:simpleType>
                         <xs:restriction base="xs:integer">
                           <xs:minInclusive value="0"/>
@@ -191,7 +191,7 @@
                         </xs:restriction>
                       </xs:simpleType>
                     </xs:element>
-                    <xs:element name="vbvPeakBitrate">
+                    <xs:element name="vbvPeakBitrate" minOccurs="0">
                       <xs:simpleType>
                         <xs:restriction base="xs:integer">
                           <xs:minInclusive value="0"/>



From gruntster at mail.berlios.de  Wed Mar 11 22:31:51 2009
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Wed, 11 Mar 2009 22:31:51 +0100
Subject: [Avidemux-svn-commit] r4681 -
	branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/xml
Message-ID: <200903112131.n2BLVpc6032428@sheep.berlios.de>

Author: gruntster
Date: 2009-03-11 22:31:46 +0100 (Wed, 11 Mar 2009)
New Revision: 4681

Modified:
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/xml/PlayStation Portable.xml
Log:
[x264] change PSP config xml to only include tags that are different to x264 default

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/xml/PlayStation Portable.xml
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/xml/PlayStation Portable.xml	2009-03-11 21:25:29 UTC (rev 4680)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/xml/PlayStation Portable.xml	2009-03-11 21:31:46 UTC (rev 4681)
@@ -1,288 +1,30 @@
 <?xml version='1.0'?>
 <x264Config>
   <encodeOptions>
-    <mode>CBR</mode>
-    <parameter>768</parameter>
+    <mode>2PASS ABR</mode>
+    <parameter>1000</parameter>
   </encodeOptions>
   <x264Options>
-    <threads>0</threads>
-    <deterministic>true</deterministic>
     <idcLevel>3</idcLevel>
-    <vui>
-      <sarAsInput>false</sarAsInput>
-      <sarHeight>1</sarHeight>
-      <sarWidth>1</sarWidth>
-      <overscan>undefined</overscan>
-      <videoFormat>undefined</videoFormat>
-      <fullRangeSamples>false</fullRangeSamples>
-      <colorPrimaries>undefined</colorPrimaries>
-      <transfer>undefined</transfer>
-      <colorMatrix>undefined</colorMatrix>
-      <chromaSampleLocation>0</chromaSampleLocation>
-    </vui>
-    <referenceFrames>2</referenceFrames>
-    <gopMaximumSize>100</gopMaximumSize>
-    <gopMinimumSize>25</gopMinimumSize>
-    <scenecutThreshold>0</scenecutThreshold>
-    <preScenecutDetection>false</preScenecutDetection>
+    <referenceFrames>3</referenceFrames>
     <bFrames>3</bFrames>
-    <adaptiveBframeDecision>1</adaptiveBframeDecision>
-    <bFrameBias>0</bFrameBias>
-    <bFrameReferences>0</bFrameReferences>
-    <loopFilter>false</loopFilter>
-    <loopFilterAlphaC0>0</loopFilterAlphaC0>
-    <loopFilterBeta>0</loopFilterBeta>
-    <cabac>true</cabac>
-    <interlaced>false</interlaced>
-    <cqmPreset>flat</cqmPreset>
-    <intra4x4Luma>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-    </intra4x4Luma>
-    <intraChroma>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-    </intraChroma>
-    <inter4x4Luma>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-    </inter4x4Luma>
-    <interChroma>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-    </interChroma>
-    <intra8x8Luma>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-    </intra8x8Luma>
-    <inter8x8Luma>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-      <value>16</value>
-    </inter8x8Luma>
+    <adaptiveBframeDecision>2</adaptiveBframeDecision>
     <analyse>
-      <partitionI4x4>false</partitionI4x4>
+      <partitionI4x4>true</partitionI4x4>
       <partitionI8x8>false</partitionI8x8>
-      <partitionP8x8>false</partitionP8x8>
+      <partitionP8x8>true</partitionP8x8>
       <partitionP4x4>false</partitionP4x4>
-      <partitionB8x8>false</partitionB8x8>
-      <dct8x8>false</dct8x8>
-      <weightedPrediction>false</weightedPrediction>
-      <directPredictionMode>spatial</directPredictionMode>
-      <directPredictionSize>smallest</directPredictionSize>
-      <chromaLumaQuantiserDifference>0</chromaLumaQuantiserDifference>
-      <motionEstimationMethod>hexagonal</motionEstimationMethod>
-      <motionVectorSearchRange>4</motionVectorSearchRange>
-      <motionVectorLength>-1</motionVectorLength>
-      <motionVectorThreadBuffer>-1</motionVectorThreadBuffer>
-      <subpixelRefinement>5</subpixelRefinement>
-      <bidirectionalMotionEstimation>false</bidirectionalMotionEstimation>
-      <chromaMotionEstimation>false</chromaMotionEstimation>
-      <bFrameRdo>false</bFrameRdo>
-      <mixedReferences>false</mixedReferences>
-      <trellis>disabled</trellis>
-      <fastPSkip>true</fastPSkip>
-      <dctDecimate>true</dctDecimate>
-      <noiseReduction>0</noiseReduction>
-      <interLumaDeadzone>21</interLumaDeadzone>
-      <intraLumaDeadzone>11</intraLumaDeadzone>
+      <partitionB8x8>true</partitionB8x8>
+      <weightedPrediction>true</weightedPrediction>
+      <directPredictionMode>auto</directPredictionMode>
+      <motionEstimationMethod>multi-hexagonal</motionEstimationMethod>
+      <subpixelRefinement>7</subpixelRefinement>
+      <mixedReferences>true</mixedReferences>
+      <trellis>finalMacroblock</trellis>
     </analyse>
     <rateControl>
-      <quantiserMinimum>10</quantiserMinimum>
-      <quantiserMaximum>51</quantiserMaximum>
-      <quantiserStep>4</quantiserStep>
-      <averageBitrateTolerance>1.000000</averageBitrateTolerance>
-      <vbvMaximumBitrate>0</vbvMaximumBitrate>
-      <vbvBufferSize>0</vbvBufferSize>
-      <vbvInitialOccupancy>0.900000</vbvInitialOccupancy>
-      <ipFrameQuantiser>1.400000</ipFrameQuantiser>
-      <pbFrameQuantiser>1.300000</pbFrameQuantiser>
-      <adaptiveQuantiserMode>variance</adaptiveQuantiserMode>
-      <adaptiveQuantiserStrength>1.000000</adaptiveQuantiserStrength>
-      <quantiserCurveCompression>0.600000</quantiserCurveCompression>
-      <reduceFluxBeforeCurveCompression>20.000000</reduceFluxBeforeCurveCompression>
-      <reduceFluxAfterCurveCompression>0.500000</reduceFluxAfterCurveCompression>
+      <vbvMaximumBitrate>10000</vbvMaximumBitrate>
+      <vbvBufferSize>10000</vbvBufferSize>
     </rateControl>
-    <accessUnitDelimiters>false</accessUnitDelimiters>
-    <spsIdentifier>0</spsIdentifier>
   </x264Options>
 </x264Config>
\ No newline at end of file



From gruntster at mail.berlios.de  Wed Mar 11 23:58:47 2009
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Wed, 11 Mar 2009 23:58:47 +0100
Subject: [Avidemux-svn-commit] r4682 -
	branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_gui
Message-ID: <200903112258.n2BMwlng010100@sheep.berlios.de>

Author: gruntster
Date: 2009-03-11 23:58:43 +0100 (Wed, 11 Mar 2009)
New Revision: 4682

Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_gui/gui2.ui
Log:
[qt] reposition Auto menu

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_gui/gui2.ui
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_gui/gui2.ui	2009-03-11 21:31:46 UTC (rev 4681)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_userInterfaces/ADM_QT4/ADM_gui/gui2.ui	2009-03-11 22:58:43 UTC (rev 4682)
@@ -1325,24 +1325,6 @@
     <addaction name="actionSave_2" />
     <addaction name="actionFilters_2" />
    </widget>
-   <widget class="QMenu" name="menuTools" >
-    <property name="title" >
-     <string>&amp;Tools</string>
-    </property>
-    <addaction name="actionCalculator" />
-    <addaction name="separator" />
-    <addaction name="actionRebuild_I_B_Frames" />
-    <addaction name="actionBitrate_histogram" />
-    <addaction name="actionScan_for_black_frames" />
-    <addaction name="separator" />
-    <addaction name="actionVob_to_vobsub" />
-    <addaction name="actionOCR" />
-    <addaction name="actionOCR_DVB_T_TS_files" />
-    <addaction name="actionGlyphs_Edit" />
-    <addaction name="separator" />
-    <addaction name="action_Preferences" />
-    <addaction name="actionAVI_Muxer_Options" />
-   </widget>
    <widget class="QMenu" name="menuEdit" >
     <property name="title" >
      <string>&amp;Edit</string>
@@ -1459,14 +1441,32 @@
      <string>A&amp;uto</string>
     </property>
    </widget>
+   <widget class="QMenu" name="menuTools" >
+    <property name="title" >
+     <string>&amp;Tools</string>
+    </property>
+    <addaction name="actionCalculator" />
+    <addaction name="separator" />
+    <addaction name="actionRebuild_I_B_Frames" />
+    <addaction name="actionBitrate_histogram" />
+    <addaction name="actionScan_for_black_frames" />
+    <addaction name="separator" />
+    <addaction name="actionVob_to_vobsub" />
+    <addaction name="actionOCR" />
+    <addaction name="actionOCR_DVB_T_TS_files" />
+    <addaction name="actionGlyphs_Edit" />
+    <addaction name="separator" />
+    <addaction name="action_Preferences" />
+    <addaction name="actionAVI_Muxer_Options" />
+   </widget>
    <addaction name="menuFile" />
    <addaction name="menuEdit" />
    <addaction name="menuView" />
    <addaction name="menuVideo" />
    <addaction name="menuAudio" />
    <addaction name="menuTools" />
+   <addaction name="menuGo" />
    <addaction name="menuAuto" />
-   <addaction name="menuGo" />
    <addaction name="menuCustom" />
    <addaction name="menuHelp" />
   </widget>



From gruntster at mail.berlios.de  Thu Mar 12 00:19:15 2009
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Thu, 12 Mar 2009 00:19:15 +0100
Subject: [Avidemux-svn-commit] r4683 - in
	branches/avidemux_2.5_branch_gruntster:
	plugins/ADM_videoEncoder/ADM_vidEnc_x264/xml scripts scripts/auto
Message-ID: <200903112319.n2BNJFpR011835@sheep.berlios.de>

Author: gruntster
Date: 2009-03-12 00:19:08 +0100 (Thu, 12 Mar 2009)
New Revision: 4683

Added:
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/xml/Sony PlayStation Portable.xml
   branches/avidemux_2.5_branch_gruntster/scripts/auto/
   branches/avidemux_2.5_branch_gruntster/scripts/auto/Sony PlayStation Portable.js
Removed:
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/xml/PlayStation Portable.xml
Modified:
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/xml/CMakeLists.txt
Log:
[script] add scripted PSP auto wizard

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/xml/CMakeLists.txt
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/xml/CMakeLists.txt	2009-03-11 22:58:43 UTC (rev 4682)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/xml/CMakeLists.txt	2009-03-11 23:19:08 UTC (rev 4683)
@@ -1 +1 @@
-INSTALL(FILES "PlayStation Portable.xml" DESTINATION "${VIDENC_INSTALL_DIR}${PLUGIN_SUBDIR}")
\ No newline at end of file
+INSTALL(DIRECTORY . DESTINATION "${VIDENC_INSTALL_DIR}${PLUGIN_SUBDIR}" FILES_MATCHING PATTERN "*.xml" PATTERN ".svn" EXCLUDE)
\ No newline at end of file

Deleted: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/xml/PlayStation Portable.xml
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/xml/PlayStation Portable.xml	2009-03-11 22:58:43 UTC (rev 4682)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/xml/PlayStation Portable.xml	2009-03-11 23:19:08 UTC (rev 4683)
@@ -1,30 +0,0 @@
-<?xml version='1.0'?>
-<x264Config>
-  <encodeOptions>
-    <mode>2PASS ABR</mode>
-    <parameter>1000</parameter>
-  </encodeOptions>
-  <x264Options>
-    <idcLevel>3</idcLevel>
-    <referenceFrames>3</referenceFrames>
-    <bFrames>3</bFrames>
-    <adaptiveBframeDecision>2</adaptiveBframeDecision>
-    <analyse>
-      <partitionI4x4>true</partitionI4x4>
-      <partitionI8x8>false</partitionI8x8>
-      <partitionP8x8>true</partitionP8x8>
-      <partitionP4x4>false</partitionP4x4>
-      <partitionB8x8>true</partitionB8x8>
-      <weightedPrediction>true</weightedPrediction>
-      <directPredictionMode>auto</directPredictionMode>
-      <motionEstimationMethod>multi-hexagonal</motionEstimationMethod>
-      <subpixelRefinement>7</subpixelRefinement>
-      <mixedReferences>true</mixedReferences>
-      <trellis>finalMacroblock</trellis>
-    </analyse>
-    <rateControl>
-      <vbvMaximumBitrate>10000</vbvMaximumBitrate>
-      <vbvBufferSize>10000</vbvBufferSize>
-    </rateControl>
-  </x264Options>
-</x264Config>
\ No newline at end of file

Copied: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/xml/Sony PlayStation Portable.xml (from rev 4681, branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_x264/xml/PlayStation Portable.xml)

Added: branches/avidemux_2.5_branch_gruntster/scripts/auto/Sony PlayStation Portable.js
===================================================================
--- branches/avidemux_2.5_branch_gruntster/scripts/auto/Sony PlayStation Portable.js	2009-03-11 22:58:43 UTC (rev 4682)
+++ branches/avidemux_2.5_branch_gruntster/scripts/auto/Sony PlayStation Portable.js	2009-03-11 23:19:08 UTC (rev 4683)
@@ -0,0 +1,24 @@
+//AD
+include("video/autoWizard.js");
+include("video/filter.js");
+
+var result = videoAutoWizard("Sony PSP Auto Wizard", [[480, 272], [720, 480]]);
+
+if (result)
+{
+    var app = new Avidemux();
+    var targetX = result[0][0];
+    var targetY = result[0][1];
+    var sourceRatio = result[1][0] + ":" + result[1][1];
+    var destinationRatio = result[2][0] + ":" + result[2][1];
+
+    resizeAndFillVideo(targetX, targetY, sourceRatio, destinationRatio);
+
+    app.video.codecPlugin("32BCB447-21C9-4210-AE9A-4FCE6C8588AE", "x264", "2PASSBITRATE=1000", "<?xml version='1.0'?><x264Config><presetConfiguration><name>Sony PlayStation Portable</name><type>system</type></presetConfiguration><x264Options></x264Options></x264Config>");
+    app.audio.codec("Faac", 128, 4, "80 00 00 00 ");
+
+    if (app.audio.getNbChannels(0) != 2)
+        app.audio.mixer("STEREO");
+
+    app.setContainer("PSP");
+}
\ No newline at end of file



From gruntster at mail.berlios.de  Sat Mar 14 13:08:31 2009
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Sat, 14 Mar 2009 13:08:31 +0100
Subject: [Avidemux-svn-commit] r4684 -
	branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_xvid
Message-ID: <200903141208.n2EC8VvJ014262@sheep.berlios.de>

Author: gruntster
Date: 2009-03-14 13:08:25 +0100 (Sat, 14 Mar 2009)
New Revision: 4684

Modified:
   branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_xvid/options.cpp
Log:
[xvid] fix saving of custom matrix type

Modified: branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_xvid/options.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_xvid/options.cpp	2009-03-11 23:19:08 UTC (rev 4683)
+++ branches/avidemux_2.5_branch_gruntster/plugins/ADM_videoEncoder/ADM_vidEnc_xvid/options.cpp	2009-03-14 12:08:25 UTC (rev 4684)
@@ -71,6 +71,8 @@
 	xvid_enc_frame.vop_flags = XVID_VOP_HALFPEL | XVID_VOP_HQACPRED;
 
 	setPar(1, 1);
+	setParAsInput(false);
+	setCqmPreset(CQM_H263);
 	setMotionEstimation(ME_LOW);
 	setRateDistortion(RD_DCT_ME);
 	setMinQuantiser(2, 2, 2);
@@ -81,8 +83,6 @@
 	setMaxOverflowImprovement(5);
 	setMaxOverflowDegradation(5);
 
-	_parAsInput = false;
-
 	setPresetConfiguration("<default>", CONFIG_DEFAULT);
 }
 
@@ -935,10 +935,13 @@
 	{
 		case CQM_H263:
 			strcpy((char*)xmlBuffer, "h.263");
+			break;
 		case CQM_MPEG:
 			strcpy((char*)xmlBuffer, "mpeg");
+			break;
 		case CQM_CUSTOM:
 			strcpy((char*)xmlBuffer, "custom");
+			break;
 	}
 
 	xmlNewChild(xmlNodeRoot, NULL, (xmlChar*)"quantType", xmlBuffer);



From gruntster at mail.berlios.de  Sat Mar 14 13:21:01 2009
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Sat, 14 Mar 2009 13:21:01 +0100
Subject: [Avidemux-svn-commit] r4685 -
	branches/avidemux_2.5_branch_gruntster/platforms/windows/installer
Message-ID: <200903141221.n2ECL1Ka026239@sheep.berlios.de>

Author: gruntster
Date: 2009-03-14 13:20:55 +0100 (Sat, 14 Mar 2009)
New Revision: 4685

Modified:
   branches/avidemux_2.5_branch_gruntster/platforms/windows/installer/avidemux.nsi
Log:
[Win32] update installer to install system scripts

Modified: branches/avidemux_2.5_branch_gruntster/platforms/windows/installer/avidemux.nsi
===================================================================
--- branches/avidemux_2.5_branch_gruntster/platforms/windows/installer/avidemux.nsi	2009-03-14 12:08:25 UTC (rev 4684)
+++ branches/avidemux_2.5_branch_gruntster/platforms/windows/installer/avidemux.nsi	2009-03-14 12:20:55 UTC (rev 4685)
@@ -291,6 +291,8 @@
     ${File} libstdc++_sjlj_*.dll
     SetOutPath $INSTDIR\etc\fonts
     ${Folder} etc\fonts
+    SetOutPath $INSTDIR\scripts
+    ${Folder} scripts
 SectionEnd
 
 SectionGroup /e "User interfaces" SecGrpUI
@@ -1635,7 +1637,7 @@
 		${EndIf}
 	${ElseIf} $PreviousVersionState == 2
 		!insertmacro MUI_HEADER_TEXT "Already Installed" "Choose how you want to install ${INTERNALNAME}."
-		nsDialogs::CreateItem /NOUNLOAD STATIC ${WS_VISIBLE}|${WS_CHILD}|${WS_CLIPSIBLINGS} 0 0 0 100% 40 "A newer version of FileZilla is already installed! It is not recommended that you downgrade to an older version. Select the operation you want to perform and click Next to continue."
+		nsDialogs::CreateItem /NOUNLOAD STATIC ${WS_VISIBLE}|${WS_CHILD}|${WS_CLIPSIBLINGS} 0 0 0 100% 40 "A newer version of Avidemux is already installed! It is not recommended that you downgrade to an older version. Select the operation you want to perform and click Next to continue."
 		Pop $R0
 		nsDialogs::CreateItem /NOUNLOAD BUTTON ${BS_AUTORADIOBUTTON}|${BS_VCENTER}|${BS_MULTILINE}|${WS_VISIBLE}|${WS_CHILD}|${WS_CLIPSIBLINGS}|${WS_GROUP}|${WS_TABSTOP} 0 10 55 100% 30 "Downgrade Avidemux using previous settings (recommended)"
 		Pop $ReinstallUninstallButton
@@ -1651,7 +1653,7 @@
 		Pop $R0
 		nsDialogs::CreateItem /NOUNLOAD BUTTON ${BS_AUTORADIOBUTTON}|${BS_VCENTER}|${BS_MULTILINE}|${WS_VISIBLE}|${WS_CHILD}|${WS_CLIPSIBLINGS}|${WS_GROUP}|${WS_TABSTOP} 0 10 55 100% 30 "Add/Remove/Reinstall components"
 		Pop $R0
-		nsDialogs::CreateItem /NOUNLOAD BUTTON ${BS_AUTORADIOBUTTON}|${BS_TOP}|${BS_MULTILINE}|${WS_VISIBLE}|${WS_CHILD}|${WS_CLIPSIBLINGS} 0 10 85 100% 50 "Uninstall FileZilla"
+		nsDialogs::CreateItem /NOUNLOAD BUTTON ${BS_AUTORADIOBUTTON}|${BS_TOP}|${BS_MULTILINE}|${WS_VISIBLE}|${WS_CHILD}|${WS_CLIPSIBLINGS} 0 10 85 100% 50 "Uninstall Avidemux"
 		Pop $ReinstallUninstallButton
 
 		${If} $ReinstallUninstall == ""



From gruntster at mail.berlios.de  Sat Mar 14 15:13:57 2009
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Sat, 14 Mar 2009 15:13:57 +0100
Subject: [Avidemux-svn-commit] r4686 - in
	branches/avidemux_2.5_branch_gruntster: avidemux/ADM_script
	scripts/auto
Message-ID: <200903141413.n2EEDv4p001345@sheep.berlios.de>

Author: gruntster
Date: 2009-03-14 15:13:50 +0100 (Sat, 14 Mar 2009)
New Revision: 4686

Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSAvidemux.cpp
   branches/avidemux_2.5_branch_gruntster/scripts/auto/Sony PlayStation Portable.js
Log:
[script] make video & audio methods return null when no video is open

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSAvidemux.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSAvidemux.cpp	2009-03-14 12:20:55 UTC (rev 4685)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSAvidemux.cpp	2009-03-14 14:13:50 UTC (rev 4686)
@@ -145,10 +145,18 @@
                                 *vp = INT_TO_JSVAL(frameEnd);
                                 break;
                         case audio_prop:
-                                *vp = OBJECT_TO_JSVAL(priv->getObject()->m_pAudio);
+								if (avifileinfo)
+									*vp = OBJECT_TO_JSVAL(priv->getObject()->m_pAudio);
+								else
+									*vp = NULL;
+
                                 break;
                         case video_prop:
-                                *vp = OBJECT_TO_JSVAL(priv->getObject()->m_pVideo);
+								if (avifileinfo)
+									*vp = OBJECT_TO_JSVAL(priv->getObject()->m_pVideo);
+								else
+									*vp = NULL;
+
                                 break;
                         case container_prop:
                                 *vp = STRING_TO_JSVAL(priv->getObject()->m_pContainer);

Modified: branches/avidemux_2.5_branch_gruntster/scripts/auto/Sony PlayStation Portable.js
===================================================================
--- branches/avidemux_2.5_branch_gruntster/scripts/auto/Sony PlayStation Portable.js	2009-03-14 12:20:55 UTC (rev 4685)
+++ branches/avidemux_2.5_branch_gruntster/scripts/auto/Sony PlayStation Portable.js	2009-03-14 14:13:50 UTC (rev 4686)
@@ -2,23 +2,29 @@
 include("video/autoWizard.js");
 include("video/filter.js");
 
-var result = videoAutoWizard("Sony PSP Auto Wizard", [[480, 272], [720, 480]]);
+var app = new Avidemux();
 
-if (result)
+if (app.video == null)
+    displayError("A video file must be open to use this Auto Wizard.");
+else
 {
-    var app = new Avidemux();
-    var targetX = result[0][0];
-    var targetY = result[0][1];
-    var sourceRatio = result[1][0] + ":" + result[1][1];
-    var destinationRatio = result[2][0] + ":" + result[2][1];
+    var result = videoAutoWizard("Sony PSP Auto Wizard", [[480, 272], [720, 480]]);
 
-    resizeAndFillVideo(targetX, targetY, sourceRatio, destinationRatio);
+    if (result)
+    {
+        var targetX = result[0][0];
+        var targetY = result[0][1];
+        var sourceRatio = result[1][0] + ":" + result[1][1];
+        var destinationRatio = result[2][0] + ":" + result[2][1];
 
-    app.video.codecPlugin("32BCB447-21C9-4210-AE9A-4FCE6C8588AE", "x264", "2PASSBITRATE=1000", "<?xml version='1.0'?><x264Config><presetConfiguration><name>Sony PlayStation Portable</name><type>system</type></presetConfiguration><x264Options></x264Options></x264Config>");
-    app.audio.codec("Faac", 128, 4, "80 00 00 00 ");
+        resizeAndFillVideo(targetX, targetY, sourceRatio, destinationRatio);
 
-    if (app.audio.getNbChannels(0) != 2)
-        app.audio.mixer("STEREO");
+        app.video.codecPlugin("32BCB447-21C9-4210-AE9A-4FCE6C8588AE", "x264", "2PASSBITRATE=1000", "<?xml version='1.0'?><x264Config><presetConfiguration><name>Sony PlayStation Portable</name><type>system</type></presetConfiguration><x264Options></x264Options></x264Config>");
+        app.audio.codec("Faac", 128, 4, "80 00 00 00 ");
 
-    app.setContainer("PSP");
+        if (app.audio.getNbChannels(0) != 2)
+            app.audio.mixer("STEREO");
+
+        app.setContainer("PSP");
+    }
 }
\ No newline at end of file



From gruntster at mail.berlios.de  Sat Mar 14 19:33:20 2009
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Sat, 14 Mar 2009 19:33:20 +0100
Subject: [Avidemux-svn-commit] r4687 - in
	branches/avidemux_2.5_branch_gruntster: avidemux/ADM_script
	scripts/auto
Message-ID: <200903141833.n2EIXKuk014546@sheep.berlios.de>

Author: gruntster
Date: 2009-03-14 19:33:12 +0100 (Sat, 14 Mar 2009)
New Revision: 4687

Modified:
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSAvidemuxAudio.cpp
   branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSAvidemuxAudio.h
   branches/avidemux_2.5_branch_gruntster/scripts/auto/Sony PlayStation Portable.js
Log:
[script] clean up naming of methods & props for audio object

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSAvidemuxAudio.cpp
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSAvidemuxAudio.cpp	2009-03-14 14:13:50 UTC (rev 4686)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSAvidemuxAudio.cpp	2009-03-14 18:33:12 UTC (rev 4687)
@@ -32,25 +32,25 @@
         { "process", audioprocess_prop, JSPROP_ENUMERATE },        // process audio when saving
         { "resample", resample_prop, JSPROP_ENUMERATE },	// resample
         { "delay", delay_prop, JSPROP_ENUMERATE },	// set audio delay
-        { "film2pal", film2pal_prop, JSPROP_ENUMERATE },	// convert film to pal
-        { "pal2film", pal2film_prop, JSPROP_ENUMERATE },	// convert pal to film
+        { "film2Pal", film2pal_prop, JSPROP_ENUMERATE },	// convert film to pal
+        { "pal2Film", pal2film_prop, JSPROP_ENUMERATE },	// convert pal to film
         { "normalizeMode", normalizemode_prop, JSPROP_ENUMERATE },	//
         { "drc", drc_prop, JSPROP_ENUMERATE },	//
         { "normalizeValue", normalizevalue_prop, JSPROP_ENUMERATE },	//
+		{ "mixer", mixerProperty, JSPROP_ENUMERATE },	//
         { 0 }
 };
 
 JSFunctionSpec ADM_JSAvidemuxAudio::methods[] = {
-        { "scanVBR", ScanVBR, 0, 0, 0 },	// scan variable bit rate audio
+        { "scanVbr", ScanVBR, 0, 0, 0 },	// scan variable bit rate audio
         { "save", Save, 1, 0, 0 },	// save audio stream
         { "load", Load, 2, 0, 0 },	// load audio stream
         { "reset", Reset, 0, 0, 0 },	// reset audio stream
         { "codec", Codec, 4, 0, 0 },	// set output codec
-        { "getNbTracks", getNbTracks, 0, 0, 0 },    // set output codec
+        { "getTrackCount", getNbTracks, 0, 0, 0 },    // set output codec
         { "setTrack", setTrack, 1, 0, 0 },    // set output codec
         { "secondAudioTrack", secondAudioTrack, 2, 0, 0 },    // set audio track
-        { "mixer", mixer, 1, 0, 0 },    // set mixer configuration
-        { "getNbChannels", getNbChannels, 1, 0, 0 },
+        { "getChannelCount", getNbChannels, 1, 0, 0 },
         { "getBitrate", getBitrate, 1, 0, 0 },
         { 0 }
 };
@@ -132,11 +132,9 @@
                         case drc_prop:
                             *vp = BOOLEAN_TO_JSVAL(priv->getObject()->m_bDRC);
                             break;
-/*
-                        case audio_prop:
-                                *vp = OBJECT_TO_JSVAL(priv->getObject()->m_pAudio);
-                                break;
-*/
+						case mixerProperty:
+							*vp = STRING_TO_JSVAL(JS_NewStringCopyZ(cx, getCurrentMixerString()));
+							break;
                 }
         }
         return JS_TRUE;
@@ -227,6 +225,13 @@
                                   leaveLock();
                                   break;
                         }
+						case mixerProperty:
+						{
+							const char *mixer = JS_GetStringBytes(JSVAL_TO_STRING(*vp));
+
+							setCurrentMixerFromString(mixer);
+							break;
+						}
                         default : printf("UNKNOWN AUDIO PROP\n");
                         return JS_FALSE;
                 }
@@ -447,29 +452,7 @@
         leaveLock();
       return JS_FALSE;
 }
-JSBool ADM_JSAvidemuxAudio::mixer(JSContext *cx, JSObject *obj, uintN argc, 
-                                      jsval *argv, jsval *rval)
-{
-uint32_t nb=0,nw=0;
-uint32_t *infos=NULL;
-        // default return value
-        ADM_JSAvidemuxAudio *p = (ADM_JSAvidemuxAudio *)JS_GetPrivate(cx, obj);
 
-        // default return value
-      if(argc != 1)
-                return JS_FALSE;
-        char *pArg0 = JS_GetStringBytes(JSVAL_TO_STRING(argv[0]));
-        enterLock();
-
-        if(setCurrentMixerFromString(pArg0))
-                *rval=BOOLEAN_TO_JSVAL(true);
-        else
-                *rval=BOOLEAN_TO_JSVAL(false);
-        leaveLock();
-        return JS_TRUE;
-
-}// end Codec
-
 JSBool ADM_JSAvidemuxAudio::getNbChannels(JSContext *cx, JSObject *obj, uintN argc, 
                                       jsval *argv, jsval *rval)
 {

Modified: branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSAvidemuxAudio.h
===================================================================
--- branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSAvidemuxAudio.h	2009-03-14 14:13:50 UTC (rev 4686)
+++ branches/avidemux_2.5_branch_gruntster/avidemux/ADM_script/ADM_JSAvidemuxAudio.h	2009-03-14 18:33:12 UTC (rev 4687)
@@ -24,7 +24,8 @@
 		pal2film_prop,
 		normalizemode_prop,
 		normalizevalue_prop,
-		drc_prop
+		drc_prop,
+		mixerProperty
 	};
 
 private:
@@ -47,8 +48,6 @@
 	static JSBool Codec(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval);
 	static JSBool getNbTracks(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval);
 	static JSBool setTrack(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval);
-	static JSBool lamePreset(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval);
-	static JSBool mixer(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval);
 	static JSBool secondAudioTrack(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval);
 	static JSBool getNbChannels(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval);
 	static JSBool getBitrate(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval);

Modified: branches/avidemux_2.5_branch_gruntster/scripts/auto/Sony PlayStation Portable.js
===================================================================
--- branches/avidemux_2.5_branch_gruntster/scripts/auto/Sony PlayStation Portable.js	2009-03-14 14:13:50 UTC (rev 4686)
+++ branches/avidemux_2.5_branch_gruntster/scripts/auto/Sony PlayStation Portable.js	2009-03-14 18:33:12 UTC (rev 4687)
@@ -22,8 +22,8 @@
         app.video.codecPlugin("32BCB447-21C9-4210-AE9A-4FCE6C8588AE", "x264", "2PASSBITRATE=1000", "<?xml version='1.0'?><x264Config><presetConfiguration><name>Sony PlayStation Portable</name><type>system</type></presetConfiguration><x264Options></x264Options></x264Config>");
         app.audio.codec("Faac", 128, 4, "80 00 00 00 ");
 
-        if (app.audio.getNbChannels(0) != 2)
-            app.audio.mixer("STEREO");
+        if (app.audio.getChannelCount(0) != 2)
+            app.audio.mixer = "STEREO";
 
         app.setContainer("PSP");
     }



From gruntster at mail.berlios.de  Sat Mar 14 19:58:38 2009
From: gruntster at mail.berlios.de (gruntster at mail.berlios.de)
Date: Sat, 14 Mar 2009 19:58:38 +0100
Subject: [Avidemux-svn-commit] r4688 -
	branches/avidemux_2.5_branch_gruntster/scripts/video
Message-ID: <200903141858.n2EIwc0R002770@sheep.berlios.de>

Author: gruntster
Date: 2009-03-14 19:58:34 +0100 (Sat, 14 Mar 2009)
New Revision: 4688

Modified:
   branches/avidemux_2.5_branch_gruntster/scripts/video/filter.js
Log:
[script] only apply resize filter when necessary when using scripted auto wizard

Modified: branches/avidemux_2.5_branch_gruntster/scripts/video/filter.js
===================================================================
--- branches/avidemux_2.5_branch_gruntster/scripts/video/filter.js	2009-03-14 18:33:12 UTC (rev 4687)
+++ branches/avidemux_2.5_branch_gruntster/scripts/video/filter.js	2009-03-14 18:58:34 UTC (rev 4688)
@@ -22,8 +22,8 @@
     }
 
     // Resizing
-    var width = rescaleVideoDimension(width, sourceRatio, destinationRatio, getColourEncodingSystem(fps1000));
-    var rX = width / targetX;
+    var scaledWidth = rescaleVideoDimension(width, sourceRatio, destinationRatio, getColourEncodingSystem(fps1000));
+    var rX = scaledWidth / targetX;
     var rY = height / targetY;
     var newX;
     var newY;
@@ -38,14 +38,14 @@
     {
         // resize by Y
         newY = targetY;
-        newX = Math.round(width / rY);
+        newX = Math.round(scaledWidth / rY);
     }
 
     // resize to multiple of 4
     newX -= newX % 4;
     newY -= newY % 4;
 
-    if (newX != app.video.width || newY != app.video.height)
+    if (newX != width || newY != height)
         app.video.addFilter("mpresize", "w=" + newX, "h=" + newY, "algo=0");
 
     // Black bars



From mean at mail.berlios.de  Sun Mar 15 10:57:21 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sun, 15 Mar 2009 10:57:21 +0100
Subject: [Avidemux-svn-commit] r4689 - in
	branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers: Flv
	Matroska Mp4 MpegPS OpenDml Pictures
Message-ID: <200903150957.n2F9vLhs029623@sheep.berlios.de>

Author: mean
Date: 2009-03-15 10:57:21 +0100 (Sun, 15 Mar 2009)
New Revision: 4689

Modified:
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/Flv/ADM_flv.h
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/Matroska/ADM_mkv.h
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/Mp4/ADM_mp4.h
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegPS/ADM_ps.h
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/OpenDml/ADM_openDML.cpp
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/OpenDml/ADM_openDML.h
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/Pictures/ADM_pics.h
Log:
[Demuxers] Add set/get api

Modified: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/Flv/ADM_flv.h
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/Flv/ADM_flv.h	2009-03-14 18:58:34 UTC (rev 4688)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/Flv/ADM_flv.h	2009-03-15 09:57:21 UTC (rev 4689)
@@ -77,6 +77,8 @@
                                     /// Go to a given time
                 virtual bool      goToTime(uint64_t timeUs);
                 virtual bool      getPacket(uint8_t *buffer, uint32_t *size, uint32_t maxSize,uint64_t *dts);
+
+
 };
 
 
@@ -147,6 +149,10 @@
             uint8_t  getExtraHeaderData(uint32_t *len, uint8_t **data);
     virtual uint64_t getVideoDuration(void);
 
+virtual   bool                    getPtsDts(uint32_t frame,uint64_t *pts,uint64_t *dts);
+virtual   bool                    setPtsDts(uint32_t frame,uint64_t pts,uint64_t dts);
+
+
 };
 #endif
 

Modified: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/Matroska/ADM_mkv.h
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/Matroska/ADM_mkv.h	2009-03-14 18:58:34 UTC (rev 4688)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/Matroska/ADM_mkv.h	2009-03-15 09:57:21 UTC (rev 4689)
@@ -178,6 +178,8 @@
     virtual uint64_t getVideoDuration(void);
     virtual	uint8_t	 getExtraHeaderData(uint32_t *len, uint8_t **data);
 
+virtual   bool       getPtsDts(uint32_t frame,uint64_t *pts,uint64_t *dts);
+virtual   bool       setPtsDts(uint32_t frame,uint64_t pts,uint64_t dts);
 
 
 };

Modified: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/Mp4/ADM_mp4.h
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/Mp4/ADM_mp4.h	2009-03-14 18:58:34 UTC (rev 4688)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/Mp4/ADM_mp4.h	2009-03-15 09:57:21 UTC (rev 4689)
@@ -186,6 +186,8 @@
 uint8_t        getAudioStreamsInfo(uint32_t *nbStreams, audioInfo **infos);
 virtual   uint64_t                   getTime(uint32_t frameNum);
 virtual   uint64_t                   getVideoDuration(void);
+virtual   bool       getPtsDts(uint32_t frame,uint64_t *pts,uint64_t *dts);
+virtual   bool       setPtsDts(uint32_t frame,uint64_t pts,uint64_t dts);
 
 };
 

Modified: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegPS/ADM_ps.h
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegPS/ADM_ps.h	2009-03-14 18:58:34 UTC (rev 4688)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegPS/ADM_ps.h	2009-03-15 09:57:21 UTC (rev 4689)
@@ -171,6 +171,8 @@
             uint8_t  getExtraHeaderData(uint32_t *len, uint8_t **data);
     virtual uint64_t getVideoDuration(void);
     virtual uint8_t  getFrameSize(uint32_t frame,uint32_t *size) ;
+virtual   bool       getPtsDts(uint32_t frame,uint64_t *pts,uint64_t *dts);
+virtual   bool       setPtsDts(uint32_t frame,uint64_t pts,uint64_t dts);
 
 };
 #endif

Modified: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/OpenDml/ADM_openDML.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/OpenDml/ADM_openDML.cpp	2009-03-14 18:58:34 UTC (rev 4688)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/OpenDml/ADM_openDML.cpp	2009-03-15 09:57:21 UTC (rev 4689)
@@ -860,4 +860,32 @@
         if(extraData) delete [] extraData;
         if(avistream) delete avistream;
 }
+/**
+    \fn getPtsDts
+*/
+bool    OpenDMLHeader::getPtsDts(uint32_t frame,uint64_t *pts,uint64_t *dts)
+{
+    if(frame>_videostream.dwLength)
+    {
+        printf("[Odml] %"LU" exceeds nb of video frames %"LU"\n",frame,_videostream.dwLength);
+        return false;
+    }
+    *dts=_idx[frame].dts; // FIXME
+    *pts=_idx[frame].pts;
+    return true;
+}
+/**
+        \fn setPtsDts
+*/
+bool    OpenDMLHeader::setPtsDts(uint32_t frame,uint64_t pts,uint64_t dts)
+{
+    if(frame>_videostream.dwLength)
+    {
+        printf("[Odml] %"LU" exceeds nb of video frames %"LU"\n",frame,_videostream.dwLength);
+        return false;
+    }
+    _idx[frame].dts=dts;
+    _idx[frame].pts=pts;
+    return true;
 
+}

Modified: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/OpenDml/ADM_openDML.h
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/OpenDml/ADM_openDML.h	2009-03-14 18:58:34 UTC (rev 4688)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/OpenDml/ADM_openDML.h	2009-03-15 09:57:21 UTC (rev 4689)
@@ -155,6 +155,9 @@
 virtual     uint64_t getTime(uint32_t frameNum);
 virtual     uint64_t getVideoDuration(void);
 virtual     bool     providePts(void) {return ptsAvailable;};
+bool                 getPtsDts(uint32_t frame,uint64_t *pts,uint64_t *dts);
+bool                 setPtsDts(uint32_t frame,uint64_t pts,uint64_t dts);
+
 };
 
 #endif

Modified: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/Pictures/ADM_pics.h
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/Pictures/ADM_pics.h	2009-03-14 18:58:34 UTC (rev 4688)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/Pictures/ADM_pics.h	2009-03-15 09:57:21 UTC (rev 4689)
@@ -89,6 +89,11 @@
 virtual   uint64_t                   getTime(uint32_t frameNum);
 virtual   uint64_t                   getVideoDuration(void);
 virtual 	uint8_t                 getFrameSize(uint32_t frame,uint32_t *size);
+
+virtual   bool       getPtsDts(uint32_t frame,uint64_t *pts,uint64_t *dts);
+virtual   bool       setPtsDts(uint32_t frame,uint64_t pts,uint64_t dts);
+
+
 };
 
 



From mean at mail.berlios.de  Sun Mar 15 10:57:24 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sun, 15 Mar 2009 10:57:24 +0100
Subject: [Avidemux-svn-commit] r4690 - in
	branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter:
	include src
Message-ID: <200903150957.n2F9vOqT029633@sheep.berlios.de>

Author: mean
Date: 2009-03-15 10:57:24 +0100 (Sun, 15 Mar 2009)
New Revision: 4690

Added:
   branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/include/audiofilter.h
   branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/include/audiofilter_internal.h
   branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/src/audiofilter.cpp
Modified:
   branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/include/audiofilter_access.h
   branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/src/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/src/audiofilter_access.cpp
Log:
[Audio] Use new filter chain for playback

Added: branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/include/audiofilter.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/include/audiofilter.h	2009-03-15 09:57:21 UTC (rev 4689)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/include/audiofilter.h	2009-03-15 09:57:24 UTC (rev 4690)
@@ -0,0 +1,33 @@
+/***************************************************************************
+            \file audiofilter.h
+            \brief Creates destroy audio filters
+              (c) 2006 Mean , fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#ifndef  ADM_audiofilter_h
+#define  ADM_audiofilter_h
+#include "ADM_audioFilter.h"
+/**
+        \fn createPlaybackFilter
+        \brief Create a float output filter for playback
+        @param startTime: Starting time of the filter in us
+        @param shift : Time Shift in ms
+*/
+AUDMAudioFilter *createPlaybackFilter(uint64_t startTime,int32_t shift);
+/**
+        \fn destroyPlaybaclFilter
+        \brief Destroy a float output filter for playback
+*/
+
+bool            destroyPlaybackFilter(void);
+
+#endif
\ No newline at end of file

Modified: branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/include/audiofilter_access.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/include/audiofilter_access.h	2009-03-15 09:57:21 UTC (rev 4689)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/include/audiofilter_access.h	2009-03-15 09:57:24 UTC (rev 4690)
@@ -27,6 +27,7 @@
     uint64_t            startTimeUs; /*< Starting time in us */
     AUDMAudioFilter     *filter;
     WAVHeader           header;
+    uint64_t            samplesSeen;
   public:
                 WAVHeader         *getWavHeader(void) {return &header;}
 

Added: branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/include/audiofilter_internal.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/include/audiofilter_internal.h	2009-03-15 09:57:21 UTC (rev 4689)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/include/audiofilter_internal.h	2009-03-15 09:57:24 UTC (rev 4690)
@@ -0,0 +1,25 @@
+/***************************************************************************
+            \file audiofilter_internal.h
+            \brief Creates destroy audio filters
+              (c) 2006 Mean , fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#ifndef  audiofilter_internal_h
+#define  audiofilter_internal_h
+#include "audiofilter.h"
+
+#include <vector>
+
+typedef std::vector <AUDMAudioFilter *>VectorOfAudioFilter;
+
+
+#endif
\ No newline at end of file

Modified: branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/src/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/src/CMakeLists.txt	2009-03-15 09:57:21 UTC (rev 4689)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/src/CMakeLists.txt	2009-03-15 09:57:24 UTC (rev 4690)
@@ -1,6 +1,7 @@
 SET(ADM_audioFilter_SRCS
 audiofilter_bridge.cpp
 audiofilter_access.cpp
+audiofilter.cpp
 )
 ADD_LIBRARY(ADM_audioFilter STATIC ${ADM_audioFilter_SRCS})
 

Added: branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/src/audiofilter.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/src/audiofilter.cpp	2009-03-15 09:57:21 UTC (rev 4689)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/src/audiofilter.cpp	2009-03-15 09:57:24 UTC (rev 4690)
@@ -0,0 +1,63 @@
+/***************************************************************************
+            \file audiofilter.h
+            \brief Creates destroy audio filters
+              (c) 2006 Mean , fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+
+#include "ADM_default.h"
+#include <math.h>
+
+#include "audiofilter_bridge.h"
+#include "audiofilter_access.h"
+#include "audiofilter_internal.h"
+
+VectorOfAudioFilter PlaybackVector;
+extern ADM_Composer *video_body;
+/**
+        \fn createPlaybackFilter
+        \brief Create a float output filter for playback
+        @param StartTime in us
+        @param shift in ms
+*/
+AUDMAudioFilter *createPlaybackFilter(uint64_t startTime,int32_t shift)
+{
+AUDMAudioFilter *nw;
+    ADM_assert(0==PlaybackVector.size());
+    // The First one is always the bridge
+    nw=new AUDMAudioFilter_Bridge(video_body,(uint32_t)( startTime/1000),shift);
+    PlaybackVector.push_back(nw);
+
+    //
+int last=PlaybackVector.size();
+    ADM_assert(last);
+    return PlaybackVector[last-1];
+}
+/**
+        \fn destroyPlaybackFilter
+        \brief Destroy a float output filter for playback
+*/
+
+bool            destroyPlaybackFilter(void)
+{
+
+    while(PlaybackVector.size())
+    {
+        delete PlaybackVector[0];
+        PlaybackVector.erase(PlaybackVector.begin());
+
+    }
+    return true;
+
+}
+
+// EOF
\ No newline at end of file

Modified: branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/src/audiofilter_access.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/src/audiofilter_access.cpp	2009-03-15 09:57:21 UTC (rev 4689)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/src/audiofilter_access.cpp	2009-03-15 09:57:24 UTC (rev 4690)
@@ -28,7 +28,7 @@
     ADM_assert(filter);
     startTimeUs=timeUs;
     memcpy(&header,incoming->getInfo(),sizeof(header));
-    
+    samplesSeen=0;
     printf("[FilterAccess] Created, starting at %"LU" ms\n",(uint32_t)(timeUs/1000));
 }
 /**
@@ -44,6 +44,7 @@
 */
 bool      ADMAudioFilter_Access::setPos(uint64_t pos)
 {
+    samplesSeen=0;
     return filter->rewind();
 }
 /**
@@ -60,6 +61,23 @@
 */                
 bool    ADMAudioFilter_Access::getPacket(uint8_t *buffer, uint32_t *size, uint32_t maxSize,uint64_t *dts)
 {
+    maxSize/=sizeof(float);
+    *size=0;
 
+    AUD_Status status;
+    uint32_t rd=filter->fill(maxSize,(float *)buffer,&status);
+    if(!rd)
+    {
+        printf("[Filter_access] Fill error!\n");
+        return false;
+    }
+    *size=rd*sizeof(float);
+
+    float d=(float)samplesSeen/(float)(rd/header.channels);
+    *dts=startTimeUs+(uint64_t)d;
+    samplesSeen+=(rd/header.channels);
+    return true;
 }
+
+
 //EOF



From mean at mail.berlios.de  Sun Mar 15 10:57:31 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sun, 15 Mar 2009 10:57:31 +0100
Subject: [Avidemux-svn-commit] r4691 -
	branches/avidemux_2.6_branch_mean/avidemux/ADM_editor
Message-ID: <200903150957.n2F9vVOm029643@sheep.berlios.de>

Author: mean
Date: 2009-03-15 10:57:30 +0100 (Sun, 15 Mar 2009)
New Revision: 4691

Added:
   branches/avidemux_2.6_branch_mean/avidemux/ADM_editor/ADM_edPtsDts.cpp
   branches/avidemux_2.6_branch_mean/avidemux/ADM_editor/ADM_edPtsDts.h
Modified:
   branches/avidemux_2.6_branch_mean/avidemux/ADM_editor/ADM_edRender.cpp
   branches/avidemux_2.6_branch_mean/avidemux/ADM_editor/ADM_edit.cpp
   branches/avidemux_2.6_branch_mean/avidemux/ADM_editor/CMakeLists.txt
Log:
[Demuxers] Add set/get api

Added: branches/avidemux_2.6_branch_mean/avidemux/ADM_editor/ADM_edPtsDts.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_editor/ADM_edPtsDts.cpp	2009-03-15 09:57:24 UTC (rev 4690)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_editor/ADM_edPtsDts.cpp	2009-03-15 09:57:30 UTC (rev 4691)
@@ -0,0 +1,73 @@
+/***************************************************************************
+
+    \file ADM_edPtsDts.h
+    \brief Try to guess Pts from Dts
+
+    copyright            : (C) 2002/2009 by mean
+    email                : fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include "ADM_default.h"
+#include "math.h"
+
+#include "ADM_edPtsDts.h"
+
+/**
+    \fn setPtsEqualDts
+*/
+bool setPtsEqualDts(vidHeader *hdr,uint64_t timeIncrementUs)
+{
+    aviInfo info;
+    hdr->getVideoInfo(&info);
+    uint64_t first=ADM_NO_PTS;
+    for(int i=0;i<info.nb_frames;i++)
+    {
+        uint64_t pts,dts;
+        if(true!=hdr->getPtsDts(i,&pts,&dts))
+        {
+            printf("[Editor] GetPtsDts failed for frame %"LU"\n",i);
+            return false;
+        }
+        if(pts==ADM_NO_PTS && dts==ADM_NO_PTS)
+        {
+            if(first!=ADM_NO_PTS)
+            {
+                first+=timeIncrementUs;
+            }
+            continue;
+        }else
+        if(dts!=ADM_NO_PTS && pts!=ADM_NO_PTS)
+        {
+            if(pts!=dts)
+            {
+                    printf("[Editor] Pts!=Dts for frame %"LU"\n",i);
+                    first=pts;
+                    continue;
+            }
+        }else
+            if(pts!=ADM_NO_PTS) first=dts=pts;
+            else
+                first=pts=dts;
+        if(true!=hdr->setPtsDts(i,pts,dts))
+        {
+            printf("[Editor] SetPtsDts failed for frame %"LU"\n",i);
+            return false;
+        }
+    }
+    return true;
+}
+/**
+    \fn setMpeg4PtsFromDts
+*/
+bool setMpeg4PtsFromDts(vidHeader *hdr,uint64_t timeIncrementUs)
+{
+    return true;
+}

Added: branches/avidemux_2.6_branch_mean/avidemux/ADM_editor/ADM_edPtsDts.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_editor/ADM_edPtsDts.h	2009-03-15 09:57:24 UTC (rev 4690)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_editor/ADM_edPtsDts.h	2009-03-15 09:57:30 UTC (rev 4691)
@@ -0,0 +1,25 @@
+/***************************************************************************
+
+    \file ADM_edPtsDts.h
+    \brief Try to guess Pts from Dts
+
+    copyright            : (C) 2002/2009 by mean
+    email                : fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#ifndef ADM_EDPTSDTS_H
+#define ADM_EDPTSDTS_H
+#include "ADM_Video.h"
+
+bool setPtsEqualDts(vidHeader *hdr,uint64_t timeIncrementUs);
+bool setMpeg4PtsFromDts(vidHeader *hdr,uint64_t timeIncrementUs);
+
+#endif

Modified: branches/avidemux_2.6_branch_mean/avidemux/ADM_editor/ADM_edRender.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_editor/ADM_edRender.cpp	2009-03-15 09:57:24 UTC (rev 4690)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_editor/ADM_edRender.cpp	2009-03-15 09:57:30 UTC (rev 4691)
@@ -127,7 +127,7 @@
     uint32_t nbFrames=vid->_nb_video_frames;
     //cache->flush();
     // The PTS associated with our frame is the one we are looking for
-    uint64_t wantedPts=vid->_aviheader->getTime(frame);
+    uint64_t wantedPts=vid->_aviheader->estimatePts(frame);
     uint32_t tries=8;
 
     while(found==false && tries--)

Modified: branches/avidemux_2.6_branch_mean/avidemux/ADM_editor/ADM_edit.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_editor/ADM_edit.cpp	2009-03-15 09:57:24 UTC (rev 4690)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_editor/ADM_edit.cpp	2009-03-15 09:57:30 UTC (rev 4691)
@@ -46,11 +46,6 @@
 #include "DIA_coreToolkit.h"
 #include "ADM_editor/ADM_edit.hxx"
 #include "ADM_videoFilter.h"
-//#include "ADM_dialog/DIA_working.h"
-
-//#include "ADM_inputs/ADM_mpegdemuxer/dmx_video.h"
-//#include "ADM_inputs/ADM_mpegdemuxer/dmx_identify.h"
-//#include "ADM_inputs/ADM_mpegdemuxer/dmx_probe.h"
 #include "prefs.h"
 
 #include "ADM_osSupport/ADM_debugID.h"
@@ -59,7 +54,7 @@
 
 #//include "ADM_inputs/ADM_mpegdemuxer/dmx_indexer.h"
 #include "ADM_outputfmt.h"
-//#include "ADM_gui2/GUI_ui.h"
+#include "ADM_edPtsDts.h"
 
 vidHeader *ADM_demuxerSpawn(uint32_t magic,const char *name);
 
@@ -323,7 +318,7 @@
     _videos[_nb_video]._aviheader->getExtraHeaderData(&l,&d);
     if(l && d)
     {
-        printf("The video codec has some extradata (%d bytes)\n",l);
+        printf("[Editor]The video codec has some extradata (%d bytes)\n",l);
         mixDump(d,l);
         printf("\n");
     }
@@ -363,7 +358,7 @@
 
   if (!nbAStream)
     {
-      printf ("\n *** NO AUDIO ***\n");
+      printf ("[Editor] *** NO AUDIO ***\n");
       _videos[_nb_video].audioTracks = NULL;
       _videos[_nb_video].nbAudioStream=0;
       _videos[_nb_video].currentAudioStream=0;
@@ -414,12 +409,12 @@
 //      printf("[Editor] Duration in seconds: %"LLU", in samples: %"LLU"\n",_videos[_nb_video]._audio_duration/_wavinfo->frequency,_videos[_nb_video]._audio_duration);
     }
 
-  printf ("\n Decoder FCC: ");
+  printf ("[Editor] Decoder FCC: ");
   fourCC::print (info.fcc);
   // ugly hack
   if (info.fps1000 > 2000 * 1000)
     {
-      printf (" FPS too high, switching to 25 fps hardcoded\n");
+      printf ("[Editor] FPS too high, switching to 25 fps hardcoded\n");
       info.fps1000 = 25 * 1000;
       updateVideoInfo (&info);
     }
@@ -490,22 +485,36 @@
 
 		vid= &(_videos[_nb_video-1]);
 		vid->_reorderReady=0;
-                vid->_unpackReady=0;
+        vid->_unpackReady=0;
 		// we only try if we got everything needed...
 		if(!vid->decoder)
 		{
-			printf("\n no decoder to check for B- frame\n");
-			return 1;
-		}
-		if(!vid->decoder->bFramePossible())
-		{
-			printf("\n no  B- frame with that codec \n");
-			return 1;
-		}
-
+			printf("[Editor] no decoder to check for B- frame\n");
+		}else
+        {
+            decoders *decoder=vid->decoder;
+            if(vid->_aviheader->providePts()==false) // Else we rely on demuxer PTS
+            {
+                printf("[Editor] This container does not provide PTS \n");
+                if(decoder->bFramePossible())
+                {
+                    printf("[Editor] B- frame possible with that codec \n");
+                    if(isMpeg4Compatible(info.fcc))
+                    {
+                        printf("[Editor] It is mpeg4-SP/ASP, try to guess all PTS\n");                        
+                        setMpeg4PtsFromDts(vid->_aviheader,vid->timeIncrementInUs);
+                    }
+                }
+                else   
+                {
+                        printf("[Editor] No B frame with that codec\n");
+                        setPtsEqualDts(vid->_aviheader,vid->timeIncrementInUs);
+                }
+            }
+        }
 		GoToIntra(0);
         durationInUs=vid->_aviheader->getVideoDuration();
-		printf(" End of B-frame check\n");
+		printf("[Editor] End of B-frame check\n");
 
   return 1;
 }

Modified: branches/avidemux_2.6_branch_mean/avidemux/ADM_editor/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_editor/CMakeLists.txt	2009-03-15 09:57:24 UTC (rev 4690)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_editor/CMakeLists.txt	2009-03-15 09:57:30 UTC (rev 4691)
@@ -9,6 +9,8 @@
 ADM_edit.cpp 
 ADM_edRender.cpp 
 ADM_edMarker.cpp
-ADM_edStub.cpp)
+ADM_edStub.cpp
+ADM_edPtsDts.cpp
+)
 
 ADD_ADM_LIB_ALL_TARGETS(ADM_editor ${ADM_editor_SRCS})



From mean at mail.berlios.de  Sun Mar 15 10:57:33 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sun, 15 Mar 2009 10:57:33 +0100
Subject: [Avidemux-svn-commit] r4692 - in branches/avidemux_2.6_branch_mean:
	avidemux avidemux/ADM_coreDemuxer/include
	avidemux/ADM_coreDemuxer/src cmake
Message-ID: <200903150957.n2F9vXPo029653@sheep.berlios.de>

Author: mean
Date: 2009-03-15 10:57:32 +0100 (Sun, 15 Mar 2009)
New Revision: 4692

Added:
   branches/avidemux_2.6_branch_mean/avidemux/gui_play.cpp
Removed:
   branches/avidemux_2.6_branch_mean/avidemux/guiplay.cpp
Modified:
   branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxer/include/ADM_Video.h
   branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxer/include/ADM_demuxerInternal.h
   branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxer/src/ADM_demuxer.cpp
   branches/avidemux_2.6_branch_mean/avidemux/ADM_preview.cpp
   branches/avidemux_2.6_branch_mean/avidemux/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/cmake/dm_plugin.cmake
Log:
[Audio] Cleanup

Modified: branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxer/include/ADM_Video.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxer/include/ADM_Video.h	2009-03-15 09:57:30 UTC (rev 4691)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxer/include/ADM_Video.h	2009-03-15 09:57:32 UTC (rev 4692)
@@ -111,7 +111,7 @@
 virtual 	uint32_t                getFlags(uint32_t frame,uint32_t *flags)=0;			
 virtual 	uint8_t                 getFrameSize(uint32_t frame,uint32_t *size)=0;
 virtual 	uint8_t                 getFrame(uint32_t framenum,ADMCompressedImage *img)=0;
-
+virtual     uint64_t                estimatePts(uint32_t frame); // Returns or guess the PTS of given frame
 // New write avi engine
           AVIStreamHeader           *getVideoStreamHeader(void ) { return &_videostream;}
           MainAVIHeader             *getMainHeader(void ) { return &_mainaviheader;}
@@ -122,5 +122,8 @@
 
 // Return true if the container provides pts informations
 virtual   bool                       providePts(void) {return false;};
+//
+virtual   bool                       getPtsDts(uint32_t frame,uint64_t *pts,uint64_t *dts)=0;
+virtual   bool                       setPtsDts(uint32_t frame,uint64_t pts,uint64_t dts)=0;
 };
 #endif

Modified: branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxer/include/ADM_demuxerInternal.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxer/include/ADM_demuxerInternal.h	2009-03-15 09:57:30 UTC (rev 4691)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxer/include/ADM_demuxerInternal.h	2009-03-15 09:57:32 UTC (rev 4692)
@@ -16,7 +16,7 @@
 #ifndef  ADM_videoInternal_H
 #define  ADM_videoInternal_H
 
-#define ADM_DEMUXER_API_VERSION 2
+#define ADM_DEMUXER_API_VERSION 3
 #include "ADM_dynamicLoading.h"
 #include "ADM_Video.h"
 class ADM_demuxer :public ADM_LibWrapper

Modified: branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxer/src/ADM_demuxer.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxer/src/ADM_demuxer.cpp	2009-03-15 09:57:30 UTC (rev 4691)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxer/src/ADM_demuxer.cpp	2009-03-15 09:57:32 UTC (rev 4692)
@@ -102,6 +102,26 @@
   UNUSED_ARG (size);
   return 0;
 }
+/**
+    \fn estimatePts
+    \brief Returns Pts of given frame or estimate if unknown
 
-
+*/
+uint64_t vidHeader::estimatePts(uint32_t frame)
+{
+    uint64_t pts=getTime(frame);
+    if(pts!=ADM_NO_PTS) return pts; // The demuxer can provide the PTS
+    // Else guesstimate...
+    uint32_t count=0;
+    while(frame && getTime(frame)==ADM_NO_PTS)
+    {
+        count++;
+        frame--;
+    }
+    float f=_videostream.dwScale;
+    f*=1000*1000;
+    f/=_videostream.dwRate;
+    f*=count;
+    pts=getTime(frame)+count*(uint32_t)f;
+}
 //

Modified: branches/avidemux_2.6_branch_mean/avidemux/ADM_preview.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_preview.cpp	2009-03-15 09:57:30 UTC (rev 4691)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_preview.cpp	2009-03-15 09:57:32 UTC (rev 4692)
@@ -625,6 +625,7 @@
     uint32_t frame=video_body->getCurrentFrame();
     if(!video_body->getNKFrame(&frame)) return false;
     if(!video_body->GoToIntra(frame)) return false;
+    video_body->setCurrentFrame(frame);
     samePicture();
     return true;
 }
@@ -637,6 +638,7 @@
     uint32_t frame=video_body->getCurrentFrame();
     if(!video_body->getPKFrame(&frame)) return false;
     if(!video_body->GoToIntra(frame)) return false;
+    video_body->setCurrentFrame(frame);
     samePicture();
     return true;
 }

Modified: branches/avidemux_2.6_branch_mean/avidemux/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/CMakeLists.txt	2009-03-15 09:57:30 UTC (rev 4691)
+++ branches/avidemux_2.6_branch_mean/avidemux/CMakeLists.txt	2009-03-15 09:57:32 UTC (rev 4692)
@@ -139,7 +139,7 @@
 gui_autodrive.cpp  
 GUI_jobs.cpp  
 gui_navigate.cpp  
-guiplay.cpp  
+gui_play.cpp  
 gui_save.cpp  
 gui_savenew.cpp  
 gui_misc.cpp

Copied: branches/avidemux_2.6_branch_mean/avidemux/gui_play.cpp (from rev 4691, branches/avidemux_2.6_branch_mean/avidemux/guiplay.cpp)
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/guiplay.cpp	2009-03-15 09:57:30 UTC (rev 4691)
+++ branches/avidemux_2.6_branch_mean/avidemux/gui_play.cpp	2009-03-15 09:57:32 UTC (rev 4692)
@@ -0,0 +1,362 @@
+
+/***************************************************************************
+    \file  gui_play.cpp
+	\brief Playback loop
+    
+    copyright            : (C) 2001/2009 by mean
+    email                : fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include "ADM_default.h" 
+#include <math.h>
+#include "prefs.h"
+#include "avi_vars.h"
+#include "audio_out.h"
+#include "DIA_coreToolkit.h"
+#include "ADM_videoFilter.h"
+#include "ADM_videoFilter_internal.h"
+#include "gtkgui.h"
+#include "ADM_userInterfaces/ADM_render/GUI_render.h"
+#include "avidemutils.h"
+#include "ADM_preview.h"
+#include "audiofilter.h"
+//___________________________________
+// In ms
+#define AUDIO_PRELOAD 200
+#define EVEN(x) (x&0xffffffe)
+//___________________________________
+
+extern void UI_purge(void);
+
+//___________________________________
+uint8_t stop_req;
+
+extern renderZoom currentZoom;
+
+
+/**
+    \class GUIPlayback
+    \brief Wrapper for the playback stuff
+*/  
+class GUIPlayback
+{
+private:
+        AUDMAudioFilter *playbackAudio;
+        Clock           ticktock;
+        uint32_t        nbSamplesSent ;        
+        float           *wavbuf ;
+        uint64_t        firstPts,lastPts;
+
+private : 
+        bool initialized;
+        bool initializeAudio();
+        bool cleanup(void);
+        bool audioPump(void);
+        bool cleanupAudio(void);
+public:
+        bool run(void);
+        bool initialize(void);
+        GUIPlayback();
+        ~GUIPlayback();
+
+};
+/**
+    \fn GUIPlayback
+*/
+GUIPlayback::GUIPlayback(void)
+{
+    playbackAudio=NULL;
+    wavbuf=NULL;
+}
+/**
+    \fn ~GUIPlayback
+*/
+
+GUIPlayback::~GUIPlayback()
+{
+    cleanup();
+}
+/**
+    \fn         GUI_PlayAvi
+    \brief      MainLoop for internal movie playback
+
+*/
+void GUI_PlayAvi(void)
+{
+    
+    uint32_t framelen,flags;
+    AVDMGenericVideoStream *filter;
+    uint32_t max,err,oldFrame;
+   
+    // check we got everything...
+    if (!avifileinfo)	return;
+    if (!avifileinfo->fps1000)        return;
+    
+    if (playing)
+      {
+        stop_req = 1;
+        return;
+      }
+    oldFrame=video_body->getCurrentFrame();
+	uint32_t priorityLevel;
+
+	originalPriority = getpriority(PRIO_PROCESS, 0);
+	prefs->get(PRIORITY_PLAYBACK,&priorityLevel);
+	setpriority(PRIO_PROCESS, 0, ADM_getNiceValue(priorityLevel));
+    
+    if(getPreviewMode()==ADM_PREVIEW_OUTPUT)
+    {
+            filter=getLastVideoFilter();
+    }
+    else
+    {
+            filter=getFirstVideoFilter( );
+    }
+    
+    stop_req = 0;
+    playing = 1;
+
+    admPreview::deferDisplay(1,curframe);
+    admPreview::samePicture();
+
+    GUIPlayback *playLoop=new GUIPlayback;
+    playLoop->initialize();
+    playLoop->run();
+    
+    delete playLoop;
+   playing = 0;
+            
+   getFirstVideoFilter( );
+
+   admPreview::deferDisplay(0,0);
+   
+   
+   UI_purge();
+   video_body->setCurrentFrame(oldFrame);
+   admPreview::samePicture();
+   GUI_setCurrentFrameAndTime();
+   UI_purge();
+      
+
+}
+/**
+    \fn cleanupAudio
+*/
+bool GUIPlayback::cleanupAudio(void)
+{
+      if (wavbuf)
+              ADM_dealloc(wavbuf);
+          wavbuf=NULL;
+    
+      AVDM_AudioClose();
+      
+      if (playbackAudio)
+       {
+            destroyPlaybackFilter();
+            playbackAudio=NULL;
+       }
+       return true;
+
+}
+/**
+    \fn cleanupAudio
+*/
+bool GUIPlayback::cleanup(void)
+{
+        cleanupAudio();
+       // done.
+	   setpriority(PRIO_PROCESS, 0, originalPriority);
+       return true;
+
+}
+
+/**
+        \fn initialize
+*/
+bool GUIPlayback::initialize(void)
+{
+    firstPts=admPreview::getCurrentPts();
+    initializeAudio();
+    return true;
+}
+/**
+        \fn run
+*/
+
+bool GUIPlayback::run(void)
+{
+   
+    uint32_t movieTime;
+    uint32_t systemTime;
+    
+    ticktock.reset();
+    do
+    {
+        
+        admPreview::displayNow();;
+        GUI_setCurrentFrameAndTime();
+        if(false==admPreview::nextPicture()) 
+        {
+            printf("[Play] Cancelling playback, nextPicture failed\n");
+            break;
+        }
+        audioPump();
+        lastPts=admPreview::getCurrentPts();
+        systemTime = ticktock.getElapsedMS();
+        movieTime=(uint32_t)((lastPts-firstPts)/1000);
+       // printf("[Playback] systemTime: %lu movieTime : %lu  \r",systemTime,movieTime);
+        if(systemTime>movieTime) // We are late, the current PTS is after current closk
+        {
+            if(movieTime>systemTime+20)
+                printf("[Playback] We are late!\n");
+        }
+	    else
+	    {
+            int32_t delta;
+                delta=movieTime-systemTime;
+                // a call to whatever sleep function will last at leat 10 ms
+                // give some time to GTK                		
+                while(delta > 10)
+                {
+                    if(delta>10)
+                    {
+                        GUI_Sleep(10);
+                        audioPump();
+                    }
+                    
+                    UI_purge();
+                    systemTime = ticktock.getElapsedMS();
+                    delta=movieTime-systemTime;                
+                }
+                
+                if(getPreviewMode()==ADM_PREVIEW_SEPARATE )
+                {
+                  UI_purge();
+                  UI_purge(); 
+                }
+        }
+      }
+    while (!stop_req);
+
+abort_play:
+        return true;
+};
+
+/**
+    \fn audioPump
+    \brief send ~ worth of one video frame of audio
+*/
+
+bool  GUIPlayback::audioPump(void)
+{
+    uint32_t oaf = 0;
+    uint32_t load = 0;
+	uint8_t channels;
+	uint32_t fq;
+
+    if (!playbackAudio)	    return false;
+
+  
+    channels= playbackAudio->getInfo()->channels;
+    fq=playbackAudio->getInfo()->frequency;  
+
+
+     while(AVDM_getMsFullness() < AUDIO_PRELOAD)
+      {
+
+             AUD_Status status;
+             if (! (oaf = playbackAudio->fill(256*16,  wavbuf,&status)))
+             {
+                  printf("[Playback] Error reading audio stream...\n");
+                  
+                  return false;
+             }
+            AVDM_AudioPlay(wavbuf, oaf);
+            nbSamplesSent += oaf/channels;
+            load+=oaf;
+    }
+    //printf("[Playback] Wrote %u bytes\n",load);
+    // finally play the filled up buffer
+    return true;
+}
+
+/**
+    \fn initializeAudio
+    \brief Initialize audio
+*/
+bool  GUIPlayback::initializeAudio(void)
+
+{
+    uint32_t state,latency, preload;
+    uint32_t small_;
+    uint32_t channels;
+
+    wavbuf = 0;
+
+//    if (!currentaudiostream)	  return;
+    
+    double db;
+    uint64_t startPts=firstPts;
+
+    playbackAudio = createPlaybackFilter(startPts,0);
+    
+    channels= playbackAudio->getInfo()->channels;
+    preload=  (wavinfo->frequency * channels)/5;	// 200 ms preload
+    // 4 sec buffer..               
+    wavbuf =  (float *)  ADM_alloc((20*sizeof(float)*preload)); // 4 secs buffers
+    ADM_assert(wavbuf);
+    // Call it twice to be sure it is properly setup
+     state = AVDM_AudioSetup(playbackAudio->getInfo()->frequency,  channels );
+     AVDM_AudioClose();
+     state = AVDM_AudioSetup(playbackAudio->getInfo()->frequency,  channels );
+     latency=AVDM_GetLayencyMs();
+     printf("[Playback] Latency : %d ms\n",latency);
+      if (!state)
+      {
+          GUI_Error_HIG(QT_TR_NOOP("Trouble initializing audio device"), NULL);
+          cleanupAudio();
+          return false;
+      }
+     
+     AUD_Status status;
+    uint32_t fill=0;
+    while(fill<preload)
+    {
+      if (!(small_ = playbackAudio->fill(preload-fill, wavbuf+fill,&status)))
+      {
+        break;
+      }
+      fill+=small_;
+    }
+    nbSamplesSent = fill/channels;  // In sample
+    AVDM_AudioPlay(wavbuf, fill);
+    // Let audio latency sets in...
+    ticktock.reset();
+    uint32_t slice=(wavinfo->frequency * channels)/100; // 10 ms
+    // pump data until latency is over
+    while(ticktock.getElapsedMS()<latency)
+    {
+        if(AVDM_getMsFullness()<AUDIO_PRELOAD)
+        {
+          if (!(small_ = playbackAudio->fill(slice, wavbuf,&status)))
+          {
+            printf("[Playback] Compensating for latency failed\n");
+            break;
+          }
+          AVDM_AudioPlay(wavbuf, slice);
+        }
+       ADM_usleep(10*1000);
+    }
+    printf("[Playback] Latency is now %u\n",ticktock.getElapsedMS());
+    return true;
+}
+
+// EOF

Deleted: branches/avidemux_2.6_branch_mean/avidemux/guiplay.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/guiplay.cpp	2009-03-15 09:57:30 UTC (rev 4691)
+++ branches/avidemux_2.6_branch_mean/avidemux/guiplay.cpp	2009-03-15 09:57:32 UTC (rev 4692)
@@ -1,314 +0,0 @@
-
-/***************************************************************************
-    \file  guiplay.cpp
-	\brief Playback loop
-    
-    copyright            : (C) 2001/2008 by mean
-    email                : fixounet at free.fr
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#include "config.h"
- 
-#include <math.h>
-#include "prefs.h"
-#include "fourcc.h"
-#include "avi_vars.h"
-#include "ADM_assert.h" 
-
-#include "DIA_fileSel.h"
-#include "prototype.h"
-#include "audio_out.h"
-
-#include "DIA_coreToolkit.h"
-#include "ADM_audio/aviaudio.hxx"
-#include "ADM_audiofilter/audioprocess.hxx"
-#include "ADM_videoFilter.h"
-#include "ADM_videoFilter_internal.h"
-#include "gtkgui.h"
-#include "ADM_userInterfaces/ADM_render/GUI_render.h"
-#include "ADM_audiofilter/audioeng_buildfilters.h"
-#include "avidemutils.h"
-#include "ADM_preview.h"
-//___________________________________
-#define AUDIO_PRELOAD 200
-//___________________________________
-
-static void resetTime(void);
-static void ADM_playPreloadAudio(void);
-static void ADM_playFillAudio(void);
-extern void UI_purge(void);
-#define EVEN(x) (x&0xffffffe)
-
-//___________________________________
-uint8_t stop_req;
-static uint32_t auds = 0, nbSamplesSent = 0;
-
-
-static uint16_t audio_available = 0;
-static uint32_t one_audio_frame = 0;
-static uint32_t one_frame;
-static float *wavbuf = NULL;
-AUDMAudioFilter *playback = NULL;
-extern renderZoom currentZoom;
-static Clock    ticktock;
-uint64_t firstPts,lastPts;
-/**
-    \fn         GUI_PlayAvi
-    \brief      MainLoop for internal movie playback
-
-*/
-void GUI_PlayAvi(void)
-{
-    
-    uint32_t framelen,flags;
-    AVDMGenericVideoStream *filter;
-    uint32_t max,err,oldFrame;
-   
-    // check we got everything...
-    if (!avifileinfo)	return;
-    if (!avifileinfo->fps1000)        return;
-    
-    if (playing)
-      {
-        stop_req = 1;
-        return;
-      }
-    oldFrame=video_body->getCurrentFrame();
-	uint32_t priorityLevel;
-
-	originalPriority = getpriority(PRIO_PROCESS, 0);
-	prefs->get(PRIORITY_PLAYBACK,&priorityLevel);
-	setpriority(PRIO_PROCESS, 0, ADM_getNiceValue(priorityLevel));
-    
-    if(getPreviewMode()==ADM_PREVIEW_OUTPUT)
-    {
-            filter=getLastVideoFilter();
-    }
-    else
-    {
-            filter=getFirstVideoFilter( );
-    }
-    
-    stop_req = 0;
-    playing = 1;
-
-
-    
-
-
-    admPreview::deferDisplay(1,curframe);
-    admPreview::samePicture();
-
-    firstPts=admPreview::getCurrentPts();
-    ADM_playPreloadAudio();
-
-    uint32_t movieTime;
-    uint32_t systemTime;
-    
-    ticktock.reset();
-    do
-    {
-        
-        admPreview::displayNow();;
-        GUI_setCurrentFrameAndTime();
-        if(false==admPreview::nextPicture()) 
-        {
-            printf("[Play] Cancelling playback, nextPicture failed\n");
-            break;
-        }
-        ADM_playFillAudio();
-        lastPts=admPreview::getCurrentPts();
-        systemTime = ticktock.getElapsedMS();
-        movieTime=(uint32_t)((lastPts-firstPts)/1000);
-       // printf("[Playback] systemTime: %lu movieTime : %lu  \r",systemTime,movieTime);
-        if(systemTime>movieTime) // We are late, the current PTS is after current closk
-        {
-            if(movieTime>systemTime+20)
-                printf("[Playback] We are late!\n");
-        }
-	    else
-	    {
-            int32_t delta;
-                delta=movieTime-systemTime;
-                // a call to whatever sleep function will last at leat 10 ms
-                // give some time to GTK                		
-                while(delta > 10)
-                {
-                    if(delta>10)
-                    {
-                        GUI_Sleep(delta - 10);
-                        ADM_playFillAudio();
-                    }
-                    
-                    UI_purge();
-                    systemTime = ticktock.getElapsedMS();
-                    delta=movieTime-systemTime;                
-                }
-                
-                if(getPreviewMode()==ADM_PREVIEW_SEPARATE )
-                {
-                  UI_purge();
-                  UI_purge(); 
-                }
-        }
-      }
-    while (!stop_req);
-
-abort_play:
-	// ___________________________________
-    // go back to normal display mode
-    //____________________________________
-       playing = 0;
-          
-	   getFirstVideoFilter( );
-
-       admPreview::deferDisplay(0,0);
-       
-       
-       UI_purge();
-       video_body->setCurrentFrame(oldFrame);
-       admPreview::samePicture();
-       GUI_setCurrentFrameAndTime();
-       UI_purge();
-       if (currentaudiostream)
-       {
-          if (wavbuf)
-              ADM_dealloc(wavbuf);
-          wavbuf=NULL;
-          AVDM_AudioClose();
-       }
-       // done.
-	   setpriority(PRIO_PROCESS, 0, originalPriority);
-};
-
-/**
-    \fn ADM_playFillAudio
-    \brief send ~ worth of one video frame of audio
-*/
-
-void ADM_playFillAudio(void)
-{
-    uint32_t oaf = 0;
-    uint32_t load = 0;
-	uint8_t channels;
-	uint32_t fq;
-
-    if (!audio_available)	    return;
-    if (!currentaudiostream)	return;			// audio ?
-
-  
-    channels= playback->getInfo()->channels;
-    fq=playback->getInfo()->frequency;  
-	double db_clock, db_wav,db_sys;
-    int32_t delta=0;
-
-    db_clock = admPreview::getCurrentPts()-firstPts;
-    db_clock /= 1000000.;  // in seconds
-
-    db_sys=ticktock.getElapsedMS();
-    db_sys/=1000;
-
-     while(AVDM_getMsFullness() < AUDIO_PRELOAD)
-      {
-          //printf("Fullness:%u\n",AVDM_getMsFullness());
-          db_wav = nbSamplesSent;	// in seconds also
-          db_wav /= fq;
-
-          delta = (long int) floor(1000. * (db_wav - db_clock));
-          int deltaSys=( int) floor(1000. * (db_sys - db_clock));
-
-           AUD_Status status;
-             if (! (oaf = playback->fill(256*16,  wavbuf,&status)))
-             {
-                  printf("[Playback] Error reading audio stream...\n");
-                  audio_available=0;
-                  return;
-             }
-            AVDM_AudioPlay(wavbuf, oaf);
-            nbSamplesSent += oaf/channels;
-            load+=oaf;
-    }
-    //printf("[Playback] Wrote %u bytes\n",load);
-    // finally play the filled up buffer
-    
-}
-
-/**
-    \fn ADM_playPreloadAudio
-    \brief Preload audio
-*/
-void ADM_playPreloadAudio(void)
-
-{
-    uint32_t state,latency, preload;
-    uint32_t small_;
-    uint32_t channels;
-
-    wavbuf = 0;
-
-    if (!currentaudiostream)	  return;
-    
-    double db;
-    uint64_t startPts=video_body->getTime(video_body->getCurrentFrame());
-
-    playback = buildPlaybackFilter(currentaudiostream,startPts/1000, 0xffffffff);
-    
-    channels= playback->getInfo()->channels;
-    preload=  (wavinfo->frequency * channels)/5;	// 200 ms preload
-    // 4 sec buffer..               
-    wavbuf =  (float *)  ADM_alloc((20*sizeof(float)*preload)); // 4 secs buffers
-    ADM_assert(wavbuf);
-    // Call it twice to be sure it is properly setup
-     state = AVDM_AudioSetup(playback->getInfo()->frequency,  channels );
-     AVDM_AudioClose();
-     state = AVDM_AudioSetup(playback->getInfo()->frequency,  channels );
-     latency=AVDM_GetLayencyMs();
-     printf("[Playback] Latency : %d ms\n",latency);
-      if (!state)
-      {
-          GUI_Error_HIG(QT_TR_NOOP("Trouble initializing audio device"), NULL);
-          return;
-      }
-     
-     AUD_Status status;
-    uint32_t fill=0;
-    while(fill<preload)
-    {
-      if (!(small_ = playback->fill(preload-fill, wavbuf+fill,&status)))
-      {
-        break;
-      }
-      fill+=small_;
-    }
-    nbSamplesSent = fill/channels;  // In sample
-    AVDM_AudioPlay(wavbuf, fill);
-    // Let audio latency sets in...
-    ticktock.reset();
-    uint32_t slice=(wavinfo->frequency * channels)/100; // 10 ms
-    // pump data until latency is over
-    while(ticktock.getElapsedMS()<latency)
-    {
-        if(AVDM_getMsFullness()<AUDIO_PRELOAD)
-        {
-          if (!(small_ = playback->fill(slice, wavbuf,&status)))
-          {
-            printf("[Playback] Compensating for latency failed\n");
-            break;
-          }
-          AVDM_AudioPlay(wavbuf, slice);
-        }
-       ADM_usleep(10*1000);
-    }
-    printf("[Playback] Latency is now %u\n",ticktock.getElapsedMS());
-    audio_available = 1;
-}
-
-// EOF

Modified: branches/avidemux_2.6_branch_mean/cmake/dm_plugin.cmake
===================================================================
--- branches/avidemux_2.6_branch_mean/cmake/dm_plugin.cmake	2009-03-15 09:57:30 UTC (rev 4691)
+++ branches/avidemux_2.6_branch_mean/cmake/dm_plugin.cmake	2009-03-15 09:57:32 UTC (rev 4692)
@@ -5,6 +5,7 @@
     INCLUDE_DIRECTORIES("${AVIDEMUX_SOURCE_DIR}/avidemux/ADM_coreUI/include")
     INCLUDE_DIRECTORIES("${AVIDEMUX_SOURCE_DIR}/avidemux/ADM_coreImage/include")
     INCLUDE_DIRECTORIES("${AVIDEMUX_SOURCE_DIR}/avidemux/ADM_coreUtils/include")
+    INCLUDE_DIRECTORIES("${AVIDEMUX_SOURCE_DIR}/avidemux/ADM_audioParser/include")
 ENDMACRO(INIT_DEMUXER)
 
 MACRO(INSTALL_DEMUXER _lib)



From mean at mail.berlios.de  Sun Mar 15 10:57:37 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sun, 15 Mar 2009 10:57:37 +0100
Subject: [Avidemux-svn-commit] r4693 - in branches/avidemux_2.6_branch_mean:
	avidemux/ADM_audio avidemux/ADM_audioFilter/include
	avidemux/ADM_audioFilter/src avidemux/ADM_audiofilter
	avidemux/ADM_editor avidemux/ADM_userInterfaces/ADM_commonUI
	plugins/ADM_demuxers/MpegPS
Message-ID: <200903150957.n2F9vbCH029668@sheep.berlios.de>

Author: mean
Date: 2009-03-15 10:57:35 +0100 (Sun, 15 Mar 2009)
New Revision: 4693

Added:
   branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/include/audiofilter_SRC.h
   branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/include/audiofilter_conf.h
   branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/include/audiofilter_dolby.h
   branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/include/audiofilter_film2pal.h
   branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/include/audiofilter_limiter.h
   branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/include/audiofilter_limiter_param.h
   branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/include/audiofilter_mixer.h
   branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/include/audiofilter_normalize.h
   branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/include/audiofilter_normalize_param.h
   branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/src/audiofilter_mixer.cpp
Removed:
   branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_SRC.h
   branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_dolby.h
   branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_film2pal.h
   branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_limiter.h
   branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_limiter_param.h
   branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_mixer.cpp
   branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_mixer.h
   branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_normalize.h
   branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_normalize_param.h
Modified:
   branches/avidemux_2.6_branch_mean/avidemux/ADM_audio/audiogen.cpp
   branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/src/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/src/audiofilter.cpp
   branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiodeng_buildfilters.cpp
   branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_buildchain.cpp
   branches/avidemux_2.6_branch_mean/avidemux/ADM_editor/ADM_edPtsDts.cpp
   branches/avidemux_2.6_branch_mean/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_audioFilter.cpp
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegPS/ADM_ps.cpp
Log:
[Audio] Begin replacing old filterChain with new

Modified: branches/avidemux_2.6_branch_mean/avidemux/ADM_audio/audiogen.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_audio/audiogen.cpp	2009-03-15 09:57:32 UTC (rev 4692)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_audio/audiogen.cpp	2009-03-15 09:57:35 UTC (rev 4693)
@@ -532,23 +532,5 @@
 
 }
 #endif
-/**
- * 	\fn ADM_audioCompareChannelMapping
- *  \brief return true if the two channel mapping are identical, false else.
- */
-bool ADM_audioCompareChannelMapping(WAVHeader *wh1, WAVHeader *wh2,CHANNEL_TYPE *map1,CHANNEL_TYPE *map2)
-{
-	if(wh1->channels != wh2->channels) return false; // cannot be identical..
-		
-			for (int j = 0; j < wh1->channels; j++)
-			{
-				if (map1[j] != map2[j]) 
-				{
-					return false;
-					
-				}
-			}
-	return true;
-}
 
 //

Copied: branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/include/audiofilter_SRC.h (from rev 4692, branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_SRC.h)
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_SRC.h	2009-03-15 09:57:32 UTC (rev 4692)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/include/audiofilter_SRC.h	2009-03-15 09:57:35 UTC (rev 4693)
@@ -0,0 +1,30 @@
+/***************************************************************************
+    copyright            : (C) 2006 by mean
+    email                : fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#ifndef AUDM_AUDIO_SRC_H
+#define AUDM_AUDIO_SRC_H
+#include "ADM_audioResample.h"
+class AUDMAudioFilterSrc : public AUDMAudioFilter
+{
+  protected:
+      uint32_t          targetFrequency;
+      uint32_t          engaged;
+      ADM_resample      resampler; 
+  public:
+
+    ~AUDMAudioFilterSrc();
+    AUDMAudioFilterSrc(AUDMAudioFilter *instream,uint32_t  tgt);
+    uint32_t   fill(uint32_t max,float *output,AUD_Status *status);
+};
+#endif

Copied: branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/include/audiofilter_conf.h (from rev 4692, branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_SRC.h)
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_SRC.h	2009-03-15 09:57:32 UTC (rev 4692)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/include/audiofilter_conf.h	2009-03-15 09:57:35 UTC (rev 4693)
@@ -0,0 +1,49 @@
+/***************************************************************************
+            \file audiofilter_conf.h
+            \brief Manage configuration
+              (c) 2006 Mean , fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#ifndef  ADM_audiofilter_conf_h
+#define  ADM_audiofilter_conf_h
+
+#include "ADM_audioFilter.h"
+#include "audiofilter.h"
+#include "audiofilter_mixer.h"
+
+/**
+    \class ADM_AUDIOFILTER_CONFIG
+*/
+class ADM_AUDIOFILTER_CONFIG
+{
+public    :
+
+    ADM_AUDIOFILTER_CONFIG(void)
+        {
+                startTimeInUs=0;
+                shiftInMs=0;
+                mixerEnabled=false;
+                mixerConf=CHANNEL_STEREO;
+
+        }
+
+    uint64_t     startTimeInUs;
+    int32_t      shiftInMs;
+    
+    bool         mixerEnabled;
+    CHANNEL_CONF mixerConf;
+
+
+
+};
+
+#endif
\ No newline at end of file

Copied: branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/include/audiofilter_dolby.h (from rev 4692, branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_dolby.h)
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_dolby.h	2009-03-15 09:57:32 UTC (rev 4692)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/include/audiofilter_dolby.h	2009-03-15 09:57:35 UTC (rev 4693)
@@ -0,0 +1,20 @@
+//
+// C++ Interface: audiofilter_dolby
+//
+// Description: 
+//
+//
+// Author: Mihail Zenkov <kreator at tut.by>, (C) 2006
+//
+// Copyright: See COPYING file that comes with this distribution
+//
+//
+#ifndef AUDM_DOLBY_H
+#define AUDM_DOLBY_H
+
+extern void DolbyInit();
+extern void DolbySkip(bool on);
+extern float DolbyShiftLeft(float isamp);
+extern float DolbyShiftRight(float isamp);
+
+#endif

Copied: branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/include/audiofilter_film2pal.h (from rev 4692, branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_film2pal.h)
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_film2pal.h	2009-03-15 09:57:32 UTC (rev 4692)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/include/audiofilter_film2pal.h	2009-03-15 09:57:35 UTC (rev 4693)
@@ -0,0 +1,45 @@
+/***************************************************************************
+   
+    copyright            : (C) 2006 by mean
+    email                : fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#ifndef AUDIO_F_FILM2PAL_H
+#define AUDIO_F_FILM2PAL_H
+
+#include "ADM_audioFilter.h"
+#include "audiofilter_SRC.h"
+#define BLK_SIZE 512
+
+class AUDMAudioFilterFilmChange : public AUDMAudioFilter
+{
+  protected:
+    ADM_resample          resampler;
+  public:
+                          AUDMAudioFilterFilmChange(AUDMAudioFilter *previous,uint32_t from, uint32_t to);
+    virtual                ~AUDMAudioFilterFilmChange();
+    virtual    uint32_t   fill(uint32_t max,float *output,AUD_Status *status);
+};
+class AUDMAudioFilterPal2Film : public AUDMAudioFilterFilmChange
+{
+  protected:
+  public:
+                            AUDMAudioFilterPal2Film(AUDMAudioFilter *previous);
+};
+class AUDMAudioFilterFilm2Pal : public AUDMAudioFilterFilmChange
+{
+  protected:
+  public:
+                            AUDMAudioFilterFilm2Pal(AUDMAudioFilter *previous);
+};
+
+#endif

Copied: branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/include/audiofilter_limiter.h (from rev 4692, branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_limiter.h)
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_limiter.h	2009-03-15 09:57:32 UTC (rev 4692)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/include/audiofilter_limiter.h	2009-03-15 09:57:35 UTC (rev 4693)
@@ -0,0 +1,51 @@
+/***************************************************************************
+   
+    copyright            : (C) 2006 by mean
+    email                : fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#ifndef AUDIO_F_LIMITER_H
+#define AUDIO_F_LIMITER_H
+
+#include "ADM_audioFilter.h"
+#include "audiofilter_limiter_param.h"
+class AUDMAudioFilterLimiter : public AUDMAudioFilter
+{
+  protected:
+    uint8_t            filled;
+    DRCparam           _param;			
+    float              mCircle[DRC_WINDOW];
+    float              mLevelCircle[DRC_WINDOW];	
+    int                mCircleSize;
+    int                mCirclePos;	
+    float              mRMSSum;
+    float              mThreshold;
+    float              mGain;
+    float              mAttackFactor;
+    float              mDecayFactor;	
+    float              mLastLevel;
+    float              mGainDB;
+    float              AvgCircle(float value);
+    void               Follow(float x, float *outEnv, int maxBack);
+    float              DoCompression(float value, float env);
+    void               drc_cleanup(void);
+#define ONE_CHUNK 1000
+#define DELIM_WINDOW_SIZE ONE_CHUNK/2		 
+    float              follow[DELIM_WINDOW_SIZE];
+    float              value[DELIM_WINDOW_SIZE];
+
+  public:
+                          AUDMAudioFilterLimiter(AUDMAudioFilter *previous, DRCparam *param);
+    virtual                ~AUDMAudioFilterLimiter();
+    virtual    uint32_t   fill(uint32_t max,float *output,AUD_Status *status);
+};
+#endif

Copied: branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/include/audiofilter_limiter_param.h (from rev 4692, branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_limiter_param.h)
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_limiter_param.h	2009-03-15 09:57:32 UTC (rev 4692)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/include/audiofilter_limiter_param.h	2009-03-15 09:57:35 UTC (rev 4693)
@@ -0,0 +1,25 @@
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+
+#ifndef LIMITER_PARAM_H
+#define LIMITER_PARAM_H
+#define DRC_WINDOW 100
+typedef struct 
+{
+  uint32_t mUseGain;
+  double   mFloor;
+  double   mAttackTime;
+  double   mDecayTime;
+  double   mRatio;
+  double   mThresholdDB;
+   // double   mGainDB;  
+}DRCparam;
+
+#endif

Copied: branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/include/audiofilter_mixer.h (from rev 4692, branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_SRC.h)
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_SRC.h	2009-03-15 09:57:32 UTC (rev 4692)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/include/audiofilter_mixer.h	2009-03-15 09:57:35 UTC (rev 4693)
@@ -0,0 +1,33 @@
+/***************************************************************************
+            \file audiofilter_mixer
+            \brief Mixer
+              (c) 2006 Mean , fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#ifndef AUDM_AUDIO_MIXER_H
+#define AUDM_AUDIO_MIXER_H
+class AUDMAudioFilterMixer : public AUDMAudioFilter
+{
+    protected:
+        CHANNEL_CONF    _output;
+        CHANNEL_CONF    _input;
+        // output channel mapping
+        CHANNEL_TYPE outputChannelMapping[MAX_CHANNELS];
+    public:
+
+      ~AUDMAudioFilterMixer();
+      AUDMAudioFilterMixer(AUDMAudioFilter *instream,CHANNEL_CONF out);
+      uint32_t   fill(uint32_t max,float *output,AUD_Status *status);
+      // That filter changes its output channel mapping...
+      virtual   CHANNEL_TYPE    *getChannelMapping(void );
+};
+#endif

Copied: branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/include/audiofilter_normalize.h (from rev 4692, branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_normalize.h)
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_normalize.h	2009-03-15 09:57:32 UTC (rev 4692)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/include/audiofilter_normalize.h	2009-03-15 09:57:35 UTC (rev 4693)
@@ -0,0 +1,18 @@
+#ifndef AUDIO_F_NORMALIZE_H
+#define AUDIO_F_NORMALIZE_H
+
+#include "ADM_audioFilter.h"
+class AUDMAudioFilterNormalize : public AUDMAudioFilter
+{
+  protected:
+              float       _ratio;
+              uint32_t    _scanned;
+              uint8_t     preprocess(void);
+  public:
+    // gainDB10 is the gain in DB multiplied by 10
+    // 0 meaning automatic
+                          AUDMAudioFilterNormalize(AUDMAudioFilter *previous,GAINparam *param);
+    virtual                ~AUDMAudioFilterNormalize();
+    virtual    uint32_t   fill(uint32_t max,float *output,AUD_Status *status);
+};
+#endif

Copied: branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/include/audiofilter_normalize_param.h (from rev 4692, branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_normalize_param.h)
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_normalize_param.h	2009-03-15 09:57:32 UTC (rev 4692)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/include/audiofilter_normalize_param.h	2009-03-15 09:57:35 UTC (rev 4693)
@@ -0,0 +1,28 @@
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+
+#ifndef GAIN_PARAM_H
+#define GAIN_PARAM_H
+
+typedef enum 
+{
+  ADM_NO_GAIN,
+  ADM_GAIN_AUTOMATIC,
+  ADM_GAIN_MANUAL
+  
+}ADM_GAINMode;
+
+typedef struct GAINparam
+{
+  ADM_GAINMode mode;
+  int32_t gain10;
+}GAINparam;
+
+#endif

Modified: branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/src/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/src/CMakeLists.txt	2009-03-15 09:57:32 UTC (rev 4692)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/src/CMakeLists.txt	2009-03-15 09:57:35 UTC (rev 4693)
@@ -1,6 +1,7 @@
 SET(ADM_audioFilter_SRCS
 audiofilter_bridge.cpp
 audiofilter_access.cpp
+audiofilter_mixer.cpp
 audiofilter.cpp
 )
 ADD_LIBRARY(ADM_audioFilter STATIC ${ADM_audioFilter_SRCS})

Modified: branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/src/audiofilter.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/src/audiofilter.cpp	2009-03-15 09:57:32 UTC (rev 4692)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/src/audiofilter.cpp	2009-03-15 09:57:35 UTC (rev 4693)
@@ -20,9 +20,14 @@
 #include "audiofilter_bridge.h"
 #include "audiofilter_access.h"
 #include "audiofilter_internal.h"
+#include "audiofilter_conf.h"
 
 VectorOfAudioFilter PlaybackVector;
 extern ADM_Composer *video_body;
+
+//
+static bool ADM_buildFilterChain(VectorOfAudioFilter *vec,ADM_AUDIOFILTER_CONFIG *config);
+static bool ADM_emptyFilterChain(VectorOfAudioFilter *vec);
 /**
         \fn createPlaybackFilter
         \brief Create a float output filter for playback
@@ -31,14 +36,16 @@
 */
 AUDMAudioFilter *createPlaybackFilter(uint64_t startTime,int32_t shift)
 {
-AUDMAudioFilter *nw;
-    ADM_assert(0==PlaybackVector.size());
-    // The First one is always the bridge
-    nw=new AUDMAudioFilter_Bridge(video_body,(uint32_t)( startTime/1000),shift);
-    PlaybackVector.push_back(nw);
-
     //
-int last=PlaybackVector.size();
+    ADM_AUDIOFILTER_CONFIG playback;
+    playback.startTimeInUs=startTime;
+    playback.shiftInMs=shift;
+    playback.mixerEnabled=true;
+    playback.mixerConf=CHANNEL_STEREO;
+    //
+    ADM_buildFilterChain(&PlaybackVector,&playback);
+    //
+    int last=PlaybackVector.size();
     ADM_assert(last);
     return PlaybackVector[last-1];
 }
@@ -50,14 +57,66 @@
 bool            destroyPlaybackFilter(void)
 {
 
-    while(PlaybackVector.size())
+    ADM_emptyFilterChain(&PlaybackVector);
+    return true;
+
+}
+/***********************************************************************/
+/**
+    \fn ADM_buildFilterChain
+    \brief Create a filterchain
+*/
+bool ADM_buildFilterChain(VectorOfAudioFilter *vec,ADM_AUDIOFILTER_CONFIG *config)
+{
+    // make sure the chain is empty...
+    AUDMAudioFilter *last=NULL;
+    ADM_emptyFilterChain(vec);
+    
+    // Bridge
+    AUDMAudioFilter_Bridge *nw=new AUDMAudioFilter_Bridge(video_body,(uint32_t)( config->startTimeInUs/1000),
+                                                                                config->shiftInMs);
+    vec->push_back(nw);
+    last=nw;
+
+    // Mixer
+    if(config->mixerEnabled)
     {
-        delete PlaybackVector[0];
-        PlaybackVector.erase(PlaybackVector.begin());
-
+        AUDMAudioFilterMixer *mixer=new AUDMAudioFilterMixer(last,config->mixerConf);
+        vec->push_back(mixer);
+        last=mixer;
     }
     return true;
-
 }
+/**
+    \fn ADM_emptyFilterChain
+    \brief Destroy a filter chain
+*/
+bool ADM_emptyFilterChain(VectorOfAudioFilter *vec)
+{
+   while(vec->size())
+    {
+        delete (*vec)[0];
+        vec->erase(vec->begin());
+    }
+    return true;
+}
+/**
+ * 	\fn ADM_audioCompareChannelMapping
+ *  \brief return true if the two channel mapping are identical, false else.
+ */
+bool ADM_audioCompareChannelMapping(WAVHeader *wh1, WAVHeader *wh2,CHANNEL_TYPE *map1,CHANNEL_TYPE *map2)
+{
+	if(wh1->channels != wh2->channels) return false; // cannot be identical..
+		
+			for (int j = 0; j < wh1->channels; j++)
+			{
+				if (map1[j] != map2[j]) 
+				{
+					return false;
+					
+				}
+			}
+	return true;
+}
 
 // EOF
\ No newline at end of file

Copied: branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/src/audiofilter_mixer.cpp (from rev 4692, branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_mixer.cpp)
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_mixer.cpp	2009-03-15 09:57:32 UTC (rev 4692)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/src/audiofilter_mixer.cpp	2009-03-15 09:57:35 UTC (rev 4693)
@@ -0,0 +1,605 @@
+/***************************************************************************
+         Downmixer
+ ***************************************************************************/
+ 
+ 
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include "ADM_default.h"
+
+#include "ADM_audioFilter.h"
+#include "audiofilter_mixer.h"
+#include "audiofilter_dolby.h"
+#include <math.h>
+
+AUDMAudioFilterMixer::AUDMAudioFilterMixer(AUDMAudioFilter *instream,CHANNEL_CONF out):AUDMAudioFilter (instream)
+{
+    _output=out;
+    _previous->rewind();     // rewind
+    ADM_assert(_output<CHANNEL_LAST);
+    
+    
+    double d;               // Update duration
+    d=_wavHeader.byterate;
+    d/=_wavHeader.channels;
+
+	switch (_output) {
+		case CHANNEL_MONO:
+			_wavHeader.channels = 1;
+			outputChannelMapping[0] = ADM_CH_MONO;
+		break;
+		case CHANNEL_STEREO:
+			_wavHeader.channels = 2;
+			outputChannelMapping[0] = ADM_CH_FRONT_LEFT;
+			outputChannelMapping[1] = ADM_CH_FRONT_RIGHT;
+		break;
+		case CHANNEL_2F_1R:
+			_wavHeader.channels = 3;
+			outputChannelMapping[0] = ADM_CH_FRONT_LEFT;
+			outputChannelMapping[1] = ADM_CH_FRONT_RIGHT;
+			outputChannelMapping[2] = ADM_CH_REAR_CENTER;
+		break;
+		case CHANNEL_3F:
+			_wavHeader.channels = 3;
+			outputChannelMapping[0] = ADM_CH_FRONT_LEFT;
+			outputChannelMapping[1] = ADM_CH_FRONT_RIGHT;
+			outputChannelMapping[2] = ADM_CH_FRONT_CENTER;
+		break;
+		case CHANNEL_3F_1R:
+			_wavHeader.channels = 4;
+			outputChannelMapping[0] = ADM_CH_FRONT_LEFT;
+			outputChannelMapping[1] = ADM_CH_FRONT_RIGHT;
+			outputChannelMapping[2] = ADM_CH_REAR_CENTER;
+			outputChannelMapping[3] = ADM_CH_FRONT_CENTER;
+		break;
+		case CHANNEL_2F_2R:
+			_wavHeader.channels = 4;
+			outputChannelMapping[0] = ADM_CH_FRONT_LEFT;
+			outputChannelMapping[1] = ADM_CH_FRONT_RIGHT;
+			outputChannelMapping[2] = ADM_CH_REAR_LEFT;
+			outputChannelMapping[3] = ADM_CH_REAR_RIGHT;
+		break;
+		case CHANNEL_3F_2R:
+			_wavHeader.channels = 5;
+			outputChannelMapping[0] = ADM_CH_FRONT_LEFT;
+			outputChannelMapping[1] = ADM_CH_FRONT_RIGHT;
+			outputChannelMapping[2] = ADM_CH_REAR_LEFT;
+			outputChannelMapping[3] = ADM_CH_REAR_RIGHT;
+			outputChannelMapping[4] = ADM_CH_FRONT_CENTER;
+		break;
+		case CHANNEL_3F_2R_LFE:
+			_wavHeader.channels = 6;
+			outputChannelMapping[0] = ADM_CH_FRONT_LEFT;
+			outputChannelMapping[1] = ADM_CH_FRONT_RIGHT;
+			outputChannelMapping[2] = ADM_CH_REAR_LEFT;
+			outputChannelMapping[3] = ADM_CH_REAR_RIGHT;
+			outputChannelMapping[4] = ADM_CH_FRONT_CENTER;
+			outputChannelMapping[5] = ADM_CH_LFE;
+		break;
+		case CHANNEL_DOLBY_PROLOGIC:
+		case CHANNEL_DOLBY_PROLOGIC2:
+			_wavHeader.channels = 2;
+			outputChannelMapping[0] = ADM_CH_FRONT_LEFT;
+			outputChannelMapping[1] = ADM_CH_FRONT_RIGHT;
+//			DolbyInit();
+		break;
+	}
+
+    d*=_wavHeader.channels;
+    _wavHeader.byterate = (uint32_t)ceil(d);
+
+
+//    printf("[mixer]Input channels : %u : %u \n",_previous->getInfo()->channels,input_channels);
+//    printf("[mixer]Out   channels : %u : %u \n",_wavHeader.channels,ADM_CH_annel_mixer[_output]);
+
+};
+/**
+ * 	\fn getChannelMapping
+ *  \brief That filter changes the channel mapping, output its own
+ */
+CHANNEL_TYPE    *AUDMAudioFilterMixer::getChannelMapping(void ) 
+{
+		return this->outputChannelMapping;
+}
+AUDMAudioFilterMixer::~AUDMAudioFilterMixer()
+{
+};
+
+static int MCOPY(float *in,float *out,uint32_t nbSample,uint32_t chan)
+{
+    memcpy(out,in,nbSample*chan*sizeof(float));
+    return nbSample*chan;
+    
+}
+
+static int MNto1(float *in,float *out,uint32_t nbSample,uint32_t chan,CHANNEL_TYPE *chanMap)
+{
+float sum;
+int den=(chan+1)&0xfe;
+    for(int i=0;i<nbSample;i++)
+    {
+        sum=0;
+        for(int j=0;j<chan;j++)
+          sum+=in[j];
+        out[0]=sum/(float)den;
+        out++;
+        in+=chan;
+    }
+    return nbSample;
+    
+}
+
+static int MStereo(float *in,float *out,uint32_t nbSample,uint32_t chan,CHANNEL_TYPE *chanMap)
+{
+	memset(out, 0, sizeof(float) * nbSample * 2);
+
+	for (int i = 0; i < nbSample; i++) {
+		for (int c = 0; c < chan; c++) {
+			switch (chanMap[c]) {
+				case ADM_CH_MONO:
+				case ADM_CH_FRONT_CENTER:
+				case ADM_CH_REAR_CENTER:
+				case ADM_CH_LFE:
+					out[0]  += *in * 0.707;
+					out[1]  += *in * 0.707;
+				break;
+				case ADM_CH_FRONT_LEFT:
+				case ADM_CH_REAR_LEFT:
+				case ADM_CH_SIDE_LEFT:
+					out[0]  += *in;
+				break;
+				case ADM_CH_FRONT_RIGHT:
+				case ADM_CH_REAR_RIGHT:
+				case ADM_CH_SIDE_RIGHT:
+					out[1]  += *in;
+				break;
+			}
+			in++;
+		}
+		out += 2;
+	}
+
+	return nbSample*2;
+}
+
+static int M2F1R(float *in,float *out,uint32_t nbSample,uint32_t chan,CHANNEL_TYPE *chanMap)
+{
+	memset(out, 0, sizeof(float) * nbSample * 3);
+
+	for (int i = 0; i < nbSample; i++) {
+		for (int c = 0; c < chan; c++) {
+			switch (chanMap[c]) {
+				case ADM_CH_MONO:
+				case ADM_CH_FRONT_CENTER:
+					out[0]  += *in * 0.707;
+					out[1]  += *in * 0.707;
+				break;
+				case ADM_CH_FRONT_LEFT:
+					out[0]  += *in;
+				break;
+				case ADM_CH_FRONT_RIGHT:
+					out[1]  += *in;
+				break;
+				case ADM_CH_REAR_LEFT:
+				case ADM_CH_REAR_RIGHT:
+				case ADM_CH_REAR_CENTER:
+					out[2]  += *in;
+				break;
+				case ADM_CH_LFE:
+					out[0]  += *in * 0.595;
+					out[1]  += *in * 0.595;
+					out[2]  += *in * 0.595;
+				break;
+				case ADM_CH_SIDE_LEFT:
+					out[0]  += *in * 0.707;
+					out[2]  += *in * 0.707;
+				break;
+				case ADM_CH_SIDE_RIGHT:
+					out[1]  += *in * 0.707;
+					out[2]  += *in * 0.707;
+				break;
+			}
+			in++;
+		}
+		out += 3;
+	}
+
+	return nbSample * 3;
+}
+
+static int M3F(float *in,float *out,uint32_t nbSample,uint32_t chan,CHANNEL_TYPE *chanMap)
+{
+	memset(out, 0, sizeof(float) * nbSample * 3);
+
+	for (int i = 0; i < nbSample; i++) {
+		for (int c = 0; c < chan; c++) {
+			switch (chanMap[c]) {
+				case ADM_CH_MONO:
+				case ADM_CH_FRONT_CENTER:
+				case ADM_CH_REAR_CENTER:
+					out[2]  += *in;
+				break;
+				case ADM_CH_FRONT_LEFT:
+				case ADM_CH_REAR_LEFT:
+				case ADM_CH_SIDE_LEFT:
+					out[0]  += *in;
+				break;
+				case ADM_CH_FRONT_RIGHT:
+				case ADM_CH_REAR_RIGHT:
+				case ADM_CH_SIDE_RIGHT:
+					out[1]  += *in;
+				break;
+				case ADM_CH_LFE:
+					out[0]  += *in * 0.595;
+					out[1]  += *in * 0.595;
+					out[2]  += *in * 0.595;
+				break;
+			}
+			in++;
+		}
+		out += 3;
+	}
+
+	return nbSample * 3;
+}
+
+static int M3F1R(float *in,float *out,uint32_t nbSample,uint32_t chan,CHANNEL_TYPE *chanMap)
+{
+	memset(out, 0, sizeof(float) * nbSample * 4);
+
+	for (int i = 0; i < nbSample; i++) {
+		for (int c = 0; c < chan; c++) {
+			switch (chanMap[c]) {
+				case ADM_CH_MONO:
+				case ADM_CH_FRONT_CENTER:
+					out[3]  += *in;
+				break;
+				case ADM_CH_REAR_CENTER:
+				case ADM_CH_REAR_LEFT:
+				case ADM_CH_REAR_RIGHT:
+					out[2]  += *in;
+				break;
+				case ADM_CH_FRONT_LEFT:
+					out[0]  += *in;
+				break;
+				case ADM_CH_FRONT_RIGHT:
+					out[1]  += *in;
+				break;
+				case ADM_CH_LFE:
+					out[0]  += *in * 0.5;
+					out[1]  += *in * 0.5;
+					out[2]  += *in * 0.5;
+					out[3]  += *in * 0.5;
+				break;
+				case ADM_CH_SIDE_LEFT:
+					out[0]  += *in * 0.707;
+					out[2]  += *in * 0.707;
+				break;
+				case ADM_CH_SIDE_RIGHT:
+					out[1]  += *in * 0.707;
+					out[2]  += *in * 0.707;
+				break;
+			}
+			in++;
+		}
+		out += 4;
+	}
+
+	return nbSample * 4;
+}
+
+static int M2F2R(float *in,float *out,uint32_t nbSample,uint32_t chan,CHANNEL_TYPE *chanMap)
+{
+	memset(out, 0, sizeof(float) * nbSample * 4);
+
+	for (int i = 0; i < nbSample; i++) {
+		for (int c = 0; c < chan; c++) {
+			switch (chanMap[c]) {
+				case ADM_CH_MONO:
+				case ADM_CH_FRONT_CENTER:
+					out[0]  += *in * 0.707;
+					out[1]  += *in * 0.707;
+				break;
+				case ADM_CH_FRONT_LEFT:
+					out[0]  += *in;
+				break;
+				case ADM_CH_FRONT_RIGHT:
+					out[1]  += *in;
+				break;
+				case ADM_CH_REAR_LEFT:
+					out[2]  += *in;
+				break;
+				case ADM_CH_REAR_RIGHT:
+					out[3]  += *in;
+				break;
+				case ADM_CH_REAR_CENTER:
+					out[2]  += *in * 0.707;
+					out[3]  += *in * 0.707;
+				break;
+				case ADM_CH_LFE:
+					out[0]  += *in * 0.5;
+					out[1]  += *in * 0.5;
+					out[2]  += *in * 0.5;
+					out[3]  += *in * 0.5;
+				break;
+				case ADM_CH_SIDE_LEFT:
+					out[0]  += *in * 0.707;
+					out[2]  += *in * 0.707;
+				break;
+				case ADM_CH_SIDE_RIGHT:
+					out[1]  += *in * 0.707;
+					out[3]  += *in * 0.707;
+				break;
+			}
+			in++;
+		}
+		out += 4;
+	}
+
+	return nbSample * 4;
+}
+
+static int M3F2R(float *in,float *out,uint32_t nbSample,uint32_t chan,CHANNEL_TYPE *chanMap)
+{
+	memset(out, 0, sizeof(float) * nbSample * 5);
+
+	for (int i = 0; i < nbSample; i++) {
+		for (int c = 0; c < chan; c++) {
+			switch (chanMap[c]) {
+				case ADM_CH_MONO:
+				case ADM_CH_FRONT_CENTER:
+					out[4]  += *in;
+				break;
+				case ADM_CH_FRONT_LEFT:
+					out[0]  += *in;
+				break;
+				case ADM_CH_FRONT_RIGHT:
+					out[1]  += *in;
+				break;
+				case ADM_CH_REAR_LEFT:
+					out[2]  += *in;
+				break;
+				case ADM_CH_REAR_RIGHT:
+					out[3]  += *in;
+				break;
+				case ADM_CH_REAR_CENTER:
+					out[2]  += *in * 0.707;
+					out[3]  += *in * 0.707;
+				break;
+				case ADM_CH_LFE:
+					out[0]  += *in * 0.459;
+					out[1]  += *in * 0.459;
+					out[2]  += *in * 0.459;
+					out[3]  += *in * 0.459;
+					out[4]  += *in * 0.459;
+				break;
+				case ADM_CH_SIDE_LEFT:
+					out[0]  += *in * 0.707;
+					out[2]  += *in * 0.707;
+				break;
+				case ADM_CH_SIDE_RIGHT:
+					out[1]  += *in * 0.707;
+					out[3]  += *in * 0.707;
+				break;
+			}
+			in++;
+		}
+		out += 5;
+	}
+
+	return nbSample * 5;
+}
+
+static int M3F2RLFE(float *in,float *out,uint32_t nbSample,uint32_t chan,CHANNEL_TYPE *chanMap)
+{
+	memset(out, 0, sizeof(float) * nbSample * 6);
+
+	for (int i = 0; i < nbSample; i++) {
+		for (int c = 0; c < chan; c++) {
+			switch (chanMap[c]) {
+				case ADM_CH_MONO:
+				case ADM_CH_FRONT_CENTER:
+					out[4]  += *in;
+				break;
+				case ADM_CH_FRONT_LEFT:
+					out[0]  += *in;
+				break;
+				case ADM_CH_FRONT_RIGHT:
+					out[1]  += *in;
+				break;
+				case ADM_CH_REAR_LEFT:
+					out[2]  += *in;
+				break;
+				case ADM_CH_REAR_RIGHT:
+					out[3]  += *in;
+				break;
+				case ADM_CH_REAR_CENTER:
+					out[2]  += *in * 0.707;
+					out[3]  += *in * 0.707;
+				break;
+				case ADM_CH_LFE:
+					out[5]  += *in;
+				break;
+				case ADM_CH_SIDE_LEFT:
+					out[0]  += *in * 0.707;
+					out[2]  += *in * 0.707;
+				break;
+				case ADM_CH_SIDE_RIGHT:
+					out[1]  += *in * 0.707;
+					out[3]  += *in * 0.707;
+				break;
+			}
+			in++;
+		}
+		out += 6;
+	}
+
+	return nbSample * 6;
+}
+
+static int MDolbyProLogic(float *in,float *out,uint32_t nbSample,uint32_t chan,CHANNEL_TYPE *chanMap)
+{
+	memset(out, 0, sizeof(float) * nbSample * 2);
+#if 0
+	for (int i = 0; i < nbSample; i++) {
+		for (int c = 0; c < chan; c++) {
+			switch (chanMap[c]) {
+				case ADM_CH_MONO:
+				case ADM_CH_FRONT_CENTER:
+				case ADM_CH_LFE:
+					out[0]  += *in * 0.707;
+					out[1]  += *in * 0.707;
+				break;
+				case ADM_CH_FRONT_LEFT:
+					out[0]  += *in;
+				break;
+				case ADM_CH_FRONT_RIGHT:
+					out[1]  += *in;
+				break;
+				case ADM_CH_REAR_CENTER:
+				case ADM_CH_REAR_LEFT:
+				case ADM_CH_REAR_RIGHT:
+					out[0]  += DolbyShiftLeft(*in) * 0.707;
+					out[1]  += DolbyShiftRight(*in) * 0.707;
+				break;
+				case ADM_CH_SIDE_LEFT:
+					out[0]  += *in * 0.707;
+					out[0]  += DolbyShiftLeft(*in) * 0.707 * 0.707;
+					out[1]  += DolbyShiftRight(*in) * 0.707 * 0.707;
+				break;
+				case ADM_CH_SIDE_RIGHT:
+					out[1]  += *in * 0.5;
+					out[0]  += DolbyShiftLeft(*in) * 0.707 * 0.707;
+					out[1]  += DolbyShiftRight(*in) * 0.707 * 0.707;
+				break;
+			}
+			in++;
+		}
+		out += 2;
+	}
+#endif
+	return nbSample*2;
+}
+
+static int MDolbyProLogic2(float *in,float *out,uint32_t nbSample,uint32_t chan,CHANNEL_TYPE *chanMap)
+{
+	memset(out, 0, sizeof(float) * nbSample * 2);
+#if 0
+	for (int i = 0; i < nbSample; i++) {
+		for (int c = 0; c < chan; c++) {
+			switch (chanMap[c]) {
+				case ADM_CH_MONO:
+				case ADM_CH_FRONT_CENTER:
+				case ADM_CH_LFE:
+					out[0]  += *in * 0.707;
+					out[1]  += *in * 0.707;
+				break;
+				case ADM_CH_FRONT_LEFT:
+					out[0]  += *in;
+				break;
+				case ADM_CH_FRONT_RIGHT:
+					out[1]  += *in;
+				break;
+				case ADM_CH_REAR_CENTER:
+					out[0]  += DolbyShiftLeft(*in) * 0.707;
+					out[1]  += DolbyShiftRight(*in) * 0.707;
+				break;
+				case ADM_CH_REAR_LEFT:
+					out[0]  += DolbyShiftLeft(*in) * 0.8165;
+					out[1]  += DolbyShiftRight(*in) * 0.5774;
+				break;
+				case ADM_CH_REAR_RIGHT:
+					out[0]  += DolbyShiftLeft(*in) * 0.5774;
+					out[1]  += DolbyShiftRight(*in) * 0.8165;
+				break;
+				case ADM_CH_SIDE_LEFT:
+					out[0]  += *in * 0.707;
+					out[0]  += DolbyShiftLeft(*in) * 0.8165 * 0.707;
+					out[1]  += DolbyShiftRight(*in) * 0.5774 * 0.707;
+				break;
+				case ADM_CH_SIDE_RIGHT:
+					out[1]  += *in * 0.707;
+					out[0]  += DolbyShiftLeft(*in) * 0.5774 * 0.707;
+					out[1]  += DolbyShiftRight(*in) * 0.8165 * 0.707;
+				break;
+			}
+			in++;
+		}
+		out += 2;
+	}
+#endif
+	return nbSample*2;
+}
+
+
+typedef int MIXER(float *in,float *out,uint32_t nbSample,uint32_t chan,CHANNEL_TYPE *chanMap)  ;
+
+static MIXER *matrixCall[CHANNEL_LAST] = {
+NULL, MNto1, MStereo, M2F1R, M3F, M3F1R, M2F2R, M3F2R, M3F2RLFE, MDolbyProLogic, MDolbyProLogic2
+};
+//_____________________________________________
+uint32_t AUDMAudioFilterMixer::fill(uint32_t max,float *output,AUD_Status *status)
+{
+
+    uint32_t rd = 0;
+    uint8_t *in,*out;
+    int nbSampleMax=max/_wavHeader.channels;
+    uint8_t input_channels = _previous->getInfo()->channels;
+
+// Fill incoming buffer
+    shrink();
+    fillIncomingBuffer(status);
+    // Block not filled ?
+    if((_tail-_head)<input_channels)
+    {
+      if(*status==AUD_END_OF_STREAM && _head)
+      {
+        memset(&_incomingBuffer[_head],0,sizeof(float) * input_channels);
+        _tail=_head+input_channels;
+        printf("[Mixer] Warning asked %u symbols\n",max);
+      }
+      else
+      {
+        return 0;
+      }
+    }
+    // How many ?
+
+    // Let's go
+    int processed=0;
+    int available=0;
+    if(!nbSampleMax)
+    {
+      printf("[Mixer] Warning max %u, channels %u\n",max,input_channels);
+    }
+    available=(_tail-_head)/input_channels; // nb Sample
+    ADM_assert(available);
+    if(available > nbSampleMax) available=nbSampleMax;
+    
+    ADM_assert(available);
+    
+
+    // Now do the downsampling
+	if (_output == CHANNEL_INVALID || true==ADM_audioCompareChannelMapping(&_wavHeader, _previous->getInfo(),
+			_previous->getChannelMapping(),outputChannelMapping))
+	{
+		
+		rd= (uint32_t)MCOPY(&_incomingBuffer[_head],output,available,input_channels);
+	} else 
+	{
+		MIXER *call=matrixCall[_output];
+		rd= (uint32_t)call(&_incomingBuffer[_head],output,available,input_channels,_previous->getChannelMapping());
+	}
+
+    _head+=available*input_channels;
+    return rd;
+    
+}
+

Modified: branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/CMakeLists.txt	2009-03-15 09:57:32 UTC (rev 4692)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/CMakeLists.txt	2009-03-15 09:57:35 UTC (rev 4693)
@@ -4,7 +4,7 @@
 #	audiofilter_bridge.cpp         
 #        audiofilter_limiter.cpp    
 	audiofilter_buildchain.cpp     
-        audiofilter_mixer.cpp
+#        audiofilter_mixer.cpp
 #	audiofilter_normalize.cpp
 #        audiofilter_dolby.cpp          
 #        audiofilter_SRC.cpp

Modified: branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiodeng_buildfilters.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiodeng_buildfilters.cpp	2009-03-15 09:57:32 UTC (rev 4692)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiodeng_buildfilters.cpp	2009-03-15 09:57:35 UTC (rev 4693)
@@ -19,8 +19,8 @@
 
 #include "ADM_default.h"
 
-#include "ADM_audiofilter/audiofilter_limiter_param.h"
-#include "ADM_audiofilter/audiofilter_normalize_param.h"
+#include "audiofilter_limiter_param.h"
+#include "audiofilter_normalize_param.h"
 
 #include "ADM_audiofilter/audioeng_buildfilters.h"
 

Deleted: branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_SRC.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_SRC.h	2009-03-15 09:57:32 UTC (rev 4692)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_SRC.h	2009-03-15 09:57:35 UTC (rev 4693)
@@ -1,30 +0,0 @@
-/***************************************************************************
-    copyright            : (C) 2006 by mean
-    email                : fixounet at free.fr
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-#ifndef AUDM_AUDIO_SRC_H
-#define AUDM_AUDIO_SRC_H
-#include "ADM_audioResample.h"
-class AUDMAudioFilterSrc : public AUDMAudioFilter
-{
-  protected:
-      uint32_t          targetFrequency;
-      uint32_t          engaged;
-      ADM_resample      resampler; 
-  public:
-
-    ~AUDMAudioFilterSrc();
-    AUDMAudioFilterSrc(AUDMAudioFilter *instream,uint32_t  tgt);
-    uint32_t   fill(uint32_t max,float *output,AUD_Status *status);
-};
-#endif

Modified: branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_buildchain.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_buildchain.cpp	2009-03-15 09:57:32 UTC (rev 4692)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_buildchain.cpp	2009-03-15 09:57:35 UTC (rev 4693)
@@ -21,7 +21,7 @@
 
 #include "audioencoder.h"
 
-#include "ADM_audiofilter/audiofilter_limiter_param.h"
+#include "audiofilter_limiter_param.h"
 #include "audiofilter_normalize_param.h"
 #include "audio_encoderWrapper.h"
 

Deleted: branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_dolby.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_dolby.h	2009-03-15 09:57:32 UTC (rev 4692)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_dolby.h	2009-03-15 09:57:35 UTC (rev 4693)
@@ -1,20 +0,0 @@
-//
-// C++ Interface: audiofilter_dolby
-//
-// Description: 
-//
-//
-// Author: Mihail Zenkov <kreator at tut.by>, (C) 2006
-//
-// Copyright: See COPYING file that comes with this distribution
-//
-//
-#ifndef AUDM_DOLBY_H
-#define AUDM_DOLBY_H
-
-extern void DolbyInit();
-extern void DolbySkip(bool on);
-extern float DolbyShiftLeft(float isamp);
-extern float DolbyShiftRight(float isamp);
-
-#endif

Deleted: branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_film2pal.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_film2pal.h	2009-03-15 09:57:32 UTC (rev 4692)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_film2pal.h	2009-03-15 09:57:35 UTC (rev 4693)
@@ -1,45 +0,0 @@
-/***************************************************************************
-   
-    copyright            : (C) 2006 by mean
-    email                : fixounet at free.fr
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-#ifndef AUDIO_F_FILM2PAL_H
-#define AUDIO_F_FILM2PAL_H
-
-#include "ADM_audioFilter.h"
-#include "audiofilter_SRC.h"
-#define BLK_SIZE 512
-
-class AUDMAudioFilterFilmChange : public AUDMAudioFilter
-{
-  protected:
-    ADM_resample          resampler;
-  public:
-                          AUDMAudioFilterFilmChange(AUDMAudioFilter *previous,uint32_t from, uint32_t to);
-    virtual                ~AUDMAudioFilterFilmChange();
-    virtual    uint32_t   fill(uint32_t max,float *output,AUD_Status *status);
-};
-class AUDMAudioFilterPal2Film : public AUDMAudioFilterFilmChange
-{
-  protected:
-  public:
-                            AUDMAudioFilterPal2Film(AUDMAudioFilter *previous);
-};
-class AUDMAudioFilterFilm2Pal : public AUDMAudioFilterFilmChange
-{
-  protected:
-  public:
-                            AUDMAudioFilterFilm2Pal(AUDMAudioFilter *previous);
-};
-
-#endif

Deleted: branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_limiter.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_limiter.h	2009-03-15 09:57:32 UTC (rev 4692)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_limiter.h	2009-03-15 09:57:35 UTC (rev 4693)
@@ -1,51 +0,0 @@
-/***************************************************************************
-   
-    copyright            : (C) 2006 by mean
-    email                : fixounet at free.fr
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-#ifndef AUDIO_F_LIMITER_H
-#define AUDIO_F_LIMITER_H
-
-#include "ADM_audioFilter.h"
-#include "audiofilter_limiter_param.h"
-class AUDMAudioFilterLimiter : public AUDMAudioFilter
-{
-  protected:
-    uint8_t            filled;
-    DRCparam           _param;			
-    float              mCircle[DRC_WINDOW];
-    float              mLevelCircle[DRC_WINDOW];	
-    int                mCircleSize;
-    int                mCirclePos;	
-    float              mRMSSum;
-    float              mThreshold;
-    float              mGain;
-    float              mAttackFactor;
-    float              mDecayFactor;	
-    float              mLastLevel;
-    float              mGainDB;
-    float              AvgCircle(float value);
-    void               Follow(float x, float *outEnv, int maxBack);
-    float              DoCompression(float value, float env);
-    void               drc_cleanup(void);
-#define ONE_CHUNK 1000
-#define DELIM_WINDOW_SIZE ONE_CHUNK/2		 
-    float              follow[DELIM_WINDOW_SIZE];
-    float              value[DELIM_WINDOW_SIZE];
-
-  public:
-                          AUDMAudioFilterLimiter(AUDMAudioFilter *previous, DRCparam *param);
-    virtual                ~AUDMAudioFilterLimiter();
-    virtual    uint32_t   fill(uint32_t max,float *output,AUD_Status *status);
-};
-#endif

Deleted: branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_limiter_param.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_limiter_param.h	2009-03-15 09:57:32 UTC (rev 4692)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_limiter_param.h	2009-03-15 09:57:35 UTC (rev 4693)
@@ -1,25 +0,0 @@
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-
-#ifndef LIMITER_PARAM_H
-#define LIMITER_PARAM_H
-#define DRC_WINDOW 100
-typedef struct 
-{
-  uint32_t mUseGain;
-  double   mFloor;
-  double   mAttackTime;
-  double   mDecayTime;
-  double   mRatio;
-  double   mThresholdDB;
-   // double   mGainDB;  
-}DRCparam;
-
-#endif

Deleted: branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_mixer.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_mixer.cpp	2009-03-15 09:57:32 UTC (rev 4692)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_mixer.cpp	2009-03-15 09:57:35 UTC (rev 4693)
@@ -1,605 +0,0 @@
-/***************************************************************************
-         Downmixer
- ***************************************************************************/
- 
- 
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-#include "ADM_default.h"
-
-#include "ADM_audioFilter.h"
-#include "audiofilter_mixer.h"
-#include "audiofilter_dolby.h"
-#include <math.h>
-
-AUDMAudioFilterMixer::AUDMAudioFilterMixer(AUDMAudioFilter *instream,CHANNEL_CONF out):AUDMAudioFilter (instream)
-{
-    _output=out;
-    _previous->rewind();     // rewind
-    ADM_assert(_output<CHANNEL_LAST);
-    
-    
-    double d;               // Update duration
-    d=_wavHeader.byterate;
-    d/=_wavHeader.channels;
-
-	switch (_output) {
-		case CHANNEL_MONO:
-			_wavHeader.channels = 1;
-			outputChannelMapping[0] = ADM_CH_MONO;
-		break;
-		case CHANNEL_STEREO:
-			_wavHeader.channels = 2;
-			outputChannelMapping[0] = ADM_CH_FRONT_LEFT;
-			outputChannelMapping[1] = ADM_CH_FRONT_RIGHT;
-		break;
-		case CHANNEL_2F_1R:
-			_wavHeader.channels = 3;
-			outputChannelMapping[0] = ADM_CH_FRONT_LEFT;
-			outputChannelMapping[1] = ADM_CH_FRONT_RIGHT;
-			outputChannelMapping[2] = ADM_CH_REAR_CENTER;
-		break;
-		case CHANNEL_3F:
-			_wavHeader.channels = 3;
-			outputChannelMapping[0] = ADM_CH_FRONT_LEFT;
-			outputChannelMapping[1] = ADM_CH_FRONT_RIGHT;
-			outputChannelMapping[2] = ADM_CH_FRONT_CENTER;
-		break;
-		case CHANNEL_3F_1R:
-			_wavHeader.channels = 4;
-			outputChannelMapping[0] = ADM_CH_FRONT_LEFT;
-			outputChannelMapping[1] = ADM_CH_FRONT_RIGHT;
-			outputChannelMapping[2] = ADM_CH_REAR_CENTER;
-			outputChannelMapping[3] = ADM_CH_FRONT_CENTER;
-		break;
-		case CHANNEL_2F_2R:
-			_wavHeader.channels = 4;
-			outputChannelMapping[0] = ADM_CH_FRONT_LEFT;
-			outputChannelMapping[1] = ADM_CH_FRONT_RIGHT;
-			outputChannelMapping[2] = ADM_CH_REAR_LEFT;
-			outputChannelMapping[3] = ADM_CH_REAR_RIGHT;
-		break;
-		case CHANNEL_3F_2R:
-			_wavHeader.channels = 5;
-			outputChannelMapping[0] = ADM_CH_FRONT_LEFT;
-			outputChannelMapping[1] = ADM_CH_FRONT_RIGHT;
-			outputChannelMapping[2] = ADM_CH_REAR_LEFT;
-			outputChannelMapping[3] = ADM_CH_REAR_RIGHT;
-			outputChannelMapping[4] = ADM_CH_FRONT_CENTER;
-		break;
-		case CHANNEL_3F_2R_LFE:
-			_wavHeader.channels = 6;
-			outputChannelMapping[0] = ADM_CH_FRONT_LEFT;
-			outputChannelMapping[1] = ADM_CH_FRONT_RIGHT;
-			outputChannelMapping[2] = ADM_CH_REAR_LEFT;
-			outputChannelMapping[3] = ADM_CH_REAR_RIGHT;
-			outputChannelMapping[4] = ADM_CH_FRONT_CENTER;
-			outputChannelMapping[5] = ADM_CH_LFE;
-		break;
-		case CHANNEL_DOLBY_PROLOGIC:
-		case CHANNEL_DOLBY_PROLOGIC2:
-			_wavHeader.channels = 2;
-			outputChannelMapping[0] = ADM_CH_FRONT_LEFT;
-			outputChannelMapping[1] = ADM_CH_FRONT_RIGHT;
-//			DolbyInit();
-		break;
-	}
-
-    d*=_wavHeader.channels;
-    _wavHeader.byterate = (uint32_t)ceil(d);
-
-
-//    printf("[mixer]Input channels : %u : %u \n",_previous->getInfo()->channels,input_channels);
-//    printf("[mixer]Out   channels : %u : %u \n",_wavHeader.channels,ADM_CH_annel_mixer[_output]);
-
-};
-/**
- * 	\fn getChannelMapping
- *  \brief That filter changes the channel mapping, output its own
- */
-CHANNEL_TYPE    *AUDMAudioFilterMixer::getChannelMapping(void ) 
-{
-		return this->outputChannelMapping;
-}
-AUDMAudioFilterMixer::~AUDMAudioFilterMixer()
-{
-};
-
-static int MCOPY(float *in,float *out,uint32_t nbSample,uint32_t chan)
-{
-    memcpy(out,in,nbSample*chan*sizeof(float));
-    return nbSample*chan;
-    
-}
-
-static int MNto1(float *in,float *out,uint32_t nbSample,uint32_t chan,CHANNEL_TYPE *chanMap)
-{
-float sum;
-int den=(chan+1)&0xfe;
-    for(int i=0;i<nbSample;i++)
-    {
-        sum=0;
-        for(int j=0;j<chan;j++)
-          sum+=in[j];
-        out[0]=sum/(float)den;
-        out++;
-        in+=chan;
-    }
-    return nbSample;
-    
-}
-
-static int MStereo(float *in,float *out,uint32_t nbSample,uint32_t chan,CHANNEL_TYPE *chanMap)
-{
-	memset(out, 0, sizeof(float) * nbSample * 2);
-
-	for (int i = 0; i < nbSample; i++) {
-		for (int c = 0; c < chan; c++) {
-			switch (chanMap[c]) {
-				case ADM_CH_MONO:
-				case ADM_CH_FRONT_CENTER:
-				case ADM_CH_REAR_CENTER:
-				case ADM_CH_LFE:
-					out[0]  += *in * 0.707;
-					out[1]  += *in * 0.707;
-				break;
-				case ADM_CH_FRONT_LEFT:
-				case ADM_CH_REAR_LEFT:
-				case ADM_CH_SIDE_LEFT:
-					out[0]  += *in;
-				break;
-				case ADM_CH_FRONT_RIGHT:
-				case ADM_CH_REAR_RIGHT:
-				case ADM_CH_SIDE_RIGHT:
-					out[1]  += *in;
-				break;
-			}
-			in++;
-		}
-		out += 2;
-	}
-
-	return nbSample*2;
-}
-
-static int M2F1R(float *in,float *out,uint32_t nbSample,uint32_t chan,CHANNEL_TYPE *chanMap)
-{
-	memset(out, 0, sizeof(float) * nbSample * 3);
-
-	for (int i = 0; i < nbSample; i++) {
-		for (int c = 0; c < chan; c++) {
-			switch (chanMap[c]) {
-				case ADM_CH_MONO:
-				case ADM_CH_FRONT_CENTER:
-					out[0]  += *in * 0.707;
-					out[1]  += *in * 0.707;
-				break;
-				case ADM_CH_FRONT_LEFT:
-					out[0]  += *in;
-				break;
-				case ADM_CH_FRONT_RIGHT:
-					out[1]  += *in;
-				break;
-				case ADM_CH_REAR_LEFT:
-				case ADM_CH_REAR_RIGHT:
-				case ADM_CH_REAR_CENTER:
-					out[2]  += *in;
-				break;
-				case ADM_CH_LFE:
-					out[0]  += *in * 0.595;
-					out[1]  += *in * 0.595;
-					out[2]  += *in * 0.595;
-				break;
-				case ADM_CH_SIDE_LEFT:
-					out[0]  += *in * 0.707;
-					out[2]  += *in * 0.707;
-				break;
-				case ADM_CH_SIDE_RIGHT:
-					out[1]  += *in * 0.707;
-					out[2]  += *in * 0.707;
-				break;
-			}
-			in++;
-		}
-		out += 3;
-	}
-
-	return nbSample * 3;
-}
-
-static int M3F(float *in,float *out,uint32_t nbSample,uint32_t chan,CHANNEL_TYPE *chanMap)
-{
-	memset(out, 0, sizeof(float) * nbSample * 3);
-
-	for (int i = 0; i < nbSample; i++) {
-		for (int c = 0; c < chan; c++) {
-			switch (chanMap[c]) {
-				case ADM_CH_MONO:
-				case ADM_CH_FRONT_CENTER:
-				case ADM_CH_REAR_CENTER:
-					out[2]  += *in;
-				break;
-				case ADM_CH_FRONT_LEFT:
-				case ADM_CH_REAR_LEFT:
-				case ADM_CH_SIDE_LEFT:
-					out[0]  += *in;
-				break;
-				case ADM_CH_FRONT_RIGHT:
-				case ADM_CH_REAR_RIGHT:
-				case ADM_CH_SIDE_RIGHT:
-					out[1]  += *in;
-				break;
-				case ADM_CH_LFE:
-					out[0]  += *in * 0.595;
-					out[1]  += *in * 0.595;
-					out[2]  += *in * 0.595;
-				break;
-			}
-			in++;
-		}
-		out += 3;
-	}
-
-	return nbSample * 3;
-}
-
-static int M3F1R(float *in,float *out,uint32_t nbSample,uint32_t chan,CHANNEL_TYPE *chanMap)
-{
-	memset(out, 0, sizeof(float) * nbSample * 4);
-
-	for (int i = 0; i < nbSample; i++) {
-		for (int c = 0; c < chan; c++) {
-			switch (chanMap[c]) {
-				case ADM_CH_MONO:
-				case ADM_CH_FRONT_CENTER:
-					out[3]  += *in;
-				break;
-				case ADM_CH_REAR_CENTER:
-				case ADM_CH_REAR_LEFT:
-				case ADM_CH_REAR_RIGHT:
-					out[2]  += *in;
-				break;
-				case ADM_CH_FRONT_LEFT:
-					out[0]  += *in;
-				break;
-				case ADM_CH_FRONT_RIGHT:
-					out[1]  += *in;
-				break;
-				case ADM_CH_LFE:
-					out[0]  += *in * 0.5;
-					out[1]  += *in * 0.5;
-					out[2]  += *in * 0.5;
-					out[3]  += *in * 0.5;
-				break;
-				case ADM_CH_SIDE_LEFT:
-					out[0]  += *in * 0.707;
-					out[2]  += *in * 0.707;
-				break;
-				case ADM_CH_SIDE_RIGHT:
-					out[1]  += *in * 0.707;
-					out[2]  += *in * 0.707;
-				break;
-			}
-			in++;
-		}
-		out += 4;
-	}
-
-	return nbSample * 4;
-}
-
-static int M2F2R(float *in,float *out,uint32_t nbSample,uint32_t chan,CHANNEL_TYPE *chanMap)
-{
-	memset(out, 0, sizeof(float) * nbSample * 4);
-
-	for (int i = 0; i < nbSample; i++) {
-		for (int c = 0; c < chan; c++) {
-			switch (chanMap[c]) {
-				case ADM_CH_MONO:
-				case ADM_CH_FRONT_CENTER:
-					out[0]  += *in * 0.707;
-					out[1]  += *in * 0.707;
-				break;
-				case ADM_CH_FRONT_LEFT:
-					out[0]  += *in;
-				break;
-				case ADM_CH_FRONT_RIGHT:
-					out[1]  += *in;
-				break;
-				case ADM_CH_REAR_LEFT:
-					out[2]  += *in;
-				break;
-				case ADM_CH_REAR_RIGHT:
-					out[3]  += *in;
-				break;
-				case ADM_CH_REAR_CENTER:
-					out[2]  += *in * 0.707;
-					out[3]  += *in * 0.707;
-				break;
-				case ADM_CH_LFE:
-					out[0]  += *in * 0.5;
-					out[1]  += *in * 0.5;
-					out[2]  += *in * 0.5;
-					out[3]  += *in * 0.5;
-				break;
-				case ADM_CH_SIDE_LEFT:
-					out[0]  += *in * 0.707;
-					out[2]  += *in * 0.707;
-				break;
-				case ADM_CH_SIDE_RIGHT:
-					out[1]  += *in * 0.707;
-					out[3]  += *in * 0.707;
-				break;
-			}
-			in++;
-		}
-		out += 4;
-	}
-
-	return nbSample * 4;
-}
-
-static int M3F2R(float *in,float *out,uint32_t nbSample,uint32_t chan,CHANNEL_TYPE *chanMap)
-{
-	memset(out, 0, sizeof(float) * nbSample * 5);
-
-	for (int i = 0; i < nbSample; i++) {
-		for (int c = 0; c < chan; c++) {
-			switch (chanMap[c]) {
-				case ADM_CH_MONO:
-				case ADM_CH_FRONT_CENTER:
-					out[4]  += *in;
-				break;
-				case ADM_CH_FRONT_LEFT:
-					out[0]  += *in;
-				break;
-				case ADM_CH_FRONT_RIGHT:
-					out[1]  += *in;
-				break;
-				case ADM_CH_REAR_LEFT:
-					out[2]  += *in;
-				break;
-				case ADM_CH_REAR_RIGHT:
-					out[3]  += *in;
-				break;
-				case ADM_CH_REAR_CENTER:
-					out[2]  += *in * 0.707;
-					out[3]  += *in * 0.707;
-				break;
-				case ADM_CH_LFE:
-					out[0]  += *in * 0.459;
-					out[1]  += *in * 0.459;
-					out[2]  += *in * 0.459;
-					out[3]  += *in * 0.459;
-					out[4]  += *in * 0.459;
-				break;
-				case ADM_CH_SIDE_LEFT:
-					out[0]  += *in * 0.707;
-					out[2]  += *in * 0.707;
-				break;
-				case ADM_CH_SIDE_RIGHT:
-					out[1]  += *in * 0.707;
-					out[3]  += *in * 0.707;
-				break;
-			}
-			in++;
-		}
-		out += 5;
-	}
-
-	return nbSample * 5;
-}
-
-static int M3F2RLFE(float *in,float *out,uint32_t nbSample,uint32_t chan,CHANNEL_TYPE *chanMap)
-{
-	memset(out, 0, sizeof(float) * nbSample * 6);
-
-	for (int i = 0; i < nbSample; i++) {
-		for (int c = 0; c < chan; c++) {
-			switch (chanMap[c]) {
-				case ADM_CH_MONO:
-				case ADM_CH_FRONT_CENTER:
-					out[4]  += *in;
-				break;
-				case ADM_CH_FRONT_LEFT:
-					out[0]  += *in;
-				break;
-				case ADM_CH_FRONT_RIGHT:
-					out[1]  += *in;
-				break;
-				case ADM_CH_REAR_LEFT:
-					out[2]  += *in;
-				break;
-				case ADM_CH_REAR_RIGHT:
-					out[3]  += *in;
-				break;
-				case ADM_CH_REAR_CENTER:
-					out[2]  += *in * 0.707;
-					out[3]  += *in * 0.707;
-				break;
-				case ADM_CH_LFE:
-					out[5]  += *in;
-				break;
-				case ADM_CH_SIDE_LEFT:
-					out[0]  += *in * 0.707;
-					out[2]  += *in * 0.707;
-				break;
-				case ADM_CH_SIDE_RIGHT:
-					out[1]  += *in * 0.707;
-					out[3]  += *in * 0.707;
-				break;
-			}
-			in++;
-		}
-		out += 6;
-	}
-
-	return nbSample * 6;
-}
-
-static int MDolbyProLogic(float *in,float *out,uint32_t nbSample,uint32_t chan,CHANNEL_TYPE *chanMap)
-{
-	memset(out, 0, sizeof(float) * nbSample * 2);
-#if 0
-	for (int i = 0; i < nbSample; i++) {
-		for (int c = 0; c < chan; c++) {
-			switch (chanMap[c]) {
-				case ADM_CH_MONO:
-				case ADM_CH_FRONT_CENTER:
-				case ADM_CH_LFE:
-					out[0]  += *in * 0.707;
-					out[1]  += *in * 0.707;
-				break;
-				case ADM_CH_FRONT_LEFT:
-					out[0]  += *in;
-				break;
-				case ADM_CH_FRONT_RIGHT:
-					out[1]  += *in;
-				break;
-				case ADM_CH_REAR_CENTER:
-				case ADM_CH_REAR_LEFT:
-				case ADM_CH_REAR_RIGHT:
-					out[0]  += DolbyShiftLeft(*in) * 0.707;
-					out[1]  += DolbyShiftRight(*in) * 0.707;
-				break;
-				case ADM_CH_SIDE_LEFT:
-					out[0]  += *in * 0.707;
-					out[0]  += DolbyShiftLeft(*in) * 0.707 * 0.707;
-					out[1]  += DolbyShiftRight(*in) * 0.707 * 0.707;
-				break;
-				case ADM_CH_SIDE_RIGHT:
-					out[1]  += *in * 0.5;
-					out[0]  += DolbyShiftLeft(*in) * 0.707 * 0.707;
-					out[1]  += DolbyShiftRight(*in) * 0.707 * 0.707;
-				break;
-			}
-			in++;
-		}
-		out += 2;
-	}
-#endif
-	return nbSample*2;
-}
-
-static int MDolbyProLogic2(float *in,float *out,uint32_t nbSample,uint32_t chan,CHANNEL_TYPE *chanMap)
-{
-	memset(out, 0, sizeof(float) * nbSample * 2);
-#if 0
-	for (int i = 0; i < nbSample; i++) {
-		for (int c = 0; c < chan; c++) {
-			switch (chanMap[c]) {
-				case ADM_CH_MONO:
-				case ADM_CH_FRONT_CENTER:
-				case ADM_CH_LFE:
-					out[0]  += *in * 0.707;
-					out[1]  += *in * 0.707;
-				break;
-				case ADM_CH_FRONT_LEFT:
-					out[0]  += *in;
-				break;
-				case ADM_CH_FRONT_RIGHT:
-					out[1]  += *in;
-				break;
-				case ADM_CH_REAR_CENTER:
-					out[0]  += DolbyShiftLeft(*in) * 0.707;
-					out[1]  += DolbyShiftRight(*in) * 0.707;
-				break;
-				case ADM_CH_REAR_LEFT:
-					out[0]  += DolbyShiftLeft(*in) * 0.8165;
-					out[1]  += DolbyShiftRight(*in) * 0.5774;
-				break;
-				case ADM_CH_REAR_RIGHT:
-					out[0]  += DolbyShiftLeft(*in) * 0.5774;
-					out[1]  += DolbyShiftRight(*in) * 0.8165;
-				break;
-				case ADM_CH_SIDE_LEFT:
-					out[0]  += *in * 0.707;
-					out[0]  += DolbyShiftLeft(*in) * 0.8165 * 0.707;
-					out[1]  += DolbyShiftRight(*in) * 0.5774 * 0.707;
-				break;
-				case ADM_CH_SIDE_RIGHT:
-					out[1]  += *in * 0.707;
-					out[0]  += DolbyShiftLeft(*in) * 0.5774 * 0.707;
-					out[1]  += DolbyShiftRight(*in) * 0.8165 * 0.707;
-				break;
-			}
-			in++;
-		}
-		out += 2;
-	}
-#endif
-	return nbSample*2;
-}
-
-
-typedef int MIXER(float *in,float *out,uint32_t nbSample,uint32_t chan,CHANNEL_TYPE *chanMap)  ;
-
-static MIXER *matrixCall[CHANNEL_LAST] = {
-NULL, MNto1, MStereo, M2F1R, M3F, M3F1R, M2F2R, M3F2R, M3F2RLFE, MDolbyProLogic, MDolbyProLogic2
-};
-//_____________________________________________
-uint32_t AUDMAudioFilterMixer::fill(uint32_t max,float *output,AUD_Status *status)
-{
-
-    uint32_t rd = 0;
-    uint8_t *in,*out;
-    int nbSampleMax=max/_wavHeader.channels;
-    uint8_t input_channels = _previous->getInfo()->channels;
-
-// Fill incoming buffer
-    shrink();
-    fillIncomingBuffer(status);
-    // Block not filled ?
-    if((_tail-_head)<input_channels)
-    {
-      if(*status==AUD_END_OF_STREAM && _head)
-      {
-        memset(&_incomingBuffer[_head],0,sizeof(float) * input_channels);
-        _tail=_head+input_channels;
-        printf("[Mixer] Warning asked %u symbols\n",max);
-      }
-      else
-      {
-        return 0;
-      }
-    }
-    // How many ?
-
-    // Let's go
-    int processed=0;
-    int available=0;
-    if(!nbSampleMax)
-    {
-      printf("[Mixer] Warning max %u, channels %u\n",max,input_channels);
-    }
-    available=(_tail-_head)/input_channels; // nb Sample
-    ADM_assert(available);
-    if(available > nbSampleMax) available=nbSampleMax;
-    
-    ADM_assert(available);
-    
-
-    // Now do the downsampling
-	if (_output == CHANNEL_INVALID || true==ADM_audioCompareChannelMapping(&_wavHeader, _previous->getInfo(),
-			_previous->getChannelMapping(),outputChannelMapping))
-	{
-		
-		rd= (uint32_t)MCOPY(&_incomingBuffer[_head],output,available,input_channels);
-	} else 
-	{
-		MIXER *call=matrixCall[_output];
-		rd= (uint32_t)call(&_incomingBuffer[_head],output,available,input_channels,_previous->getChannelMapping());
-	}
-
-    _head+=available*input_channels;
-    return rd;
-    
-}
-

Deleted: branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_mixer.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_mixer.h	2009-03-15 09:57:32 UTC (rev 4692)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_mixer.h	2009-03-15 09:57:35 UTC (rev 4693)
@@ -1,18 +0,0 @@
-#ifndef AUDM_AUDIO_MIXER_H
-#define AUDM_AUDIO_MIXER_H
-class AUDMAudioFilterMixer : public AUDMAudioFilter
-{
-    protected:
-        CHANNEL_CONF    _output;
-        CHANNEL_CONF    _input;
-        // output channel mapping
-        CHANNEL_TYPE outputChannelMapping[MAX_CHANNELS];
-    public:
-
-      ~AUDMAudioFilterMixer();
-      AUDMAudioFilterMixer(AUDMAudioFilter *instream,CHANNEL_CONF out);
-      uint32_t   fill(uint32_t max,float *output,AUD_Status *status);
-      // That filter changes its output channel mapping...
-      virtual   CHANNEL_TYPE    *getChannelMapping(void );
-};
-#endif

Deleted: branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_normalize.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_normalize.h	2009-03-15 09:57:32 UTC (rev 4692)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_normalize.h	2009-03-15 09:57:35 UTC (rev 4693)
@@ -1,18 +0,0 @@
-#ifndef AUDIO_F_NORMALIZE_H
-#define AUDIO_F_NORMALIZE_H
-
-#include "ADM_audioFilter.h"
-class AUDMAudioFilterNormalize : public AUDMAudioFilter
-{
-  protected:
-              float       _ratio;
-              uint32_t    _scanned;
-              uint8_t     preprocess(void);
-  public:
-    // gainDB10 is the gain in DB multiplied by 10
-    // 0 meaning automatic
-                          AUDMAudioFilterNormalize(AUDMAudioFilter *previous,GAINparam *param);
-    virtual                ~AUDMAudioFilterNormalize();
-    virtual    uint32_t   fill(uint32_t max,float *output,AUD_Status *status);
-};
-#endif

Deleted: branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_normalize_param.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_normalize_param.h	2009-03-15 09:57:32 UTC (rev 4692)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_normalize_param.h	2009-03-15 09:57:35 UTC (rev 4693)
@@ -1,28 +0,0 @@
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-
-#ifndef GAIN_PARAM_H
-#define GAIN_PARAM_H
-
-typedef enum 
-{
-  ADM_NO_GAIN,
-  ADM_GAIN_AUTOMATIC,
-  ADM_GAIN_MANUAL
-  
-}ADM_GAINMode;
-
-typedef struct GAINparam
-{
-  ADM_GAINMode mode;
-  int32_t gain10;
-}GAINparam;
-
-#endif

Modified: branches/avidemux_2.6_branch_mean/avidemux/ADM_editor/ADM_edPtsDts.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_editor/ADM_edPtsDts.cpp	2009-03-15 09:57:32 UTC (rev 4692)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_editor/ADM_edPtsDts.cpp	2009-03-15 09:57:35 UTC (rev 4693)
@@ -1,7 +1,7 @@
 /***************************************************************************
 
     \file ADM_edPtsDts.h
-    \brief Try to guess Pts from Dts
+    \brief Try to guess Pts from Dts. Mostly used for crappy format like avi.
 
     copyright            : (C) 2002/2009 by mean
     email                : fixounet at free.fr
@@ -22,6 +22,7 @@
 
 /**
     \fn setPtsEqualDts
+    \brief for Low delay codec, set PTS=DTS, fill the missing values
 */
 bool setPtsEqualDts(vidHeader *hdr,uint64_t timeIncrementUs)
 {
@@ -36,26 +37,40 @@
             printf("[Editor] GetPtsDts failed for frame %"LU"\n",i);
             return false;
         }
-        if(pts==ADM_NO_PTS && dts==ADM_NO_PTS)
+        int k=0;
+        if(pts==ADM_NO_PTS) k+=2;
+        if(dts==ADM_NO_PTS) k+=1;
+        switch(k)
         {
-            if(first!=ADM_NO_PTS)
-            {
-                first+=timeIncrementUs;
-            }
-            continue;
-        }else
-        if(dts!=ADM_NO_PTS && pts!=ADM_NO_PTS)
-        {
-            if(pts!=dts)
-            {
-                    printf("[Editor] Pts!=Dts for frame %"LU"\n",i);
-                    first=pts;
-                    continue;
-            }
-        }else
-            if(pts!=ADM_NO_PTS) first=dts=pts;
-            else
+            case 0 : // Got both
+                if(pts!=dts)
+                            {
+                                    printf("[Editor] Pts!=Dts for frame %"LU"\n",i);
+                            }
+                first=pts; // do nothing since we already have both...
+                continue;            
+                break;
+            case 3: // Got none
+                {
+                        if(first!=ADM_NO_PTS)
+                        {
+                            first+=timeIncrementUs; // Say this one = previous + timeIncrement
+                            pts=dts=first;
+                        }else
+                            continue;   // We dont have a previous skip that one
+                }
+                break;
+            case 2 :  // got only pts
+                    first=dts=pts;
+                    break;
+            case 1: // got only dts
                 first=pts=dts;
+                break;
+            default:
+                ADM_assert(0);
+                break;
+        }
+        // update
         if(true!=hdr->setPtsDts(i,pts,dts))
         {
             printf("[Editor] SetPtsDts failed for frame %"LU"\n",i);
@@ -66,6 +81,9 @@
 }
 /**
     \fn setMpeg4PtsFromDts
+    \brief For mpeg4 SP/ASP, recompute PTS DTS using the simple I/P/B frame reordering
+    Works also for mpeg1/2
+    It absolutely NEEDS to have the proper frame type set (PTS/DTS/...)
 */
 bool setMpeg4PtsFromDts(vidHeader *hdr,uint64_t timeIncrementUs)
 {

Modified: branches/avidemux_2.6_branch_mean/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_audioFilter.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_audioFilter.cpp	2009-03-15 09:57:32 UTC (rev 4692)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_audioFilter.cpp	2009-03-15 09:57:35 UTC (rev 4693)
@@ -17,7 +17,7 @@
 
 
 #include "DIA_factory.h"
-#include "ADM_audiofilter/audiofilter_normalize_param.h"
+#include "audiofilter_normalize_param.h"
 #include "ADM_audiofilter/audioeng_buildfilters.h"
 /**
     \fn DIA_getAudioFilter

Modified: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegPS/ADM_ps.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegPS/ADM_ps.cpp	2009-03-15 09:57:32 UTC (rev 4692)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegPS/ADM_ps.cpp	2009-03-15 09:57:35 UTC (rev 4693)
@@ -322,5 +322,32 @@
     return true;
 }
 
+/**
+    \fn getPtsDts
+*/
+bool    psHeader::getPtsDts(uint32_t frame,uint64_t *pts,uint64_t *dts)
+{
+    if(frame>=ListOfFrames.size()) return false;
+    dmxFrame *pk=ListOfFrames[frame];
 
+    *dts=pk->dts;
+    *pts=pk->pts;
+    return true;
+}
+/**
+        \fn setPtsDts
+*/
+bool    psHeader::setPtsDts(uint32_t frame,uint64_t pts,uint64_t dts)
+{
+      if(frame>=ListOfFrames.size()) return false;
+    dmxFrame *pk=ListOfFrames[frame];
+
+    pk->dts=dts;
+    pk->pts=pts;
+    return true;
+
+
+}
+
+
 //EOF



From mean at mail.berlios.de  Sun Mar 15 15:50:01 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sun, 15 Mar 2009 15:50:01 +0100
Subject: [Avidemux-svn-commit] r4694 - in
	branches/avidemux_2.6_branch_mean/avidemux:
	ADM_audioFilter/include ADM_audioFilter/src ADM_audiofilter
Message-ID: <200903151450.n2FEo1d2027071@sheep.berlios.de>

Author: mean
Date: 2009-03-15 15:50:00 +0100 (Sun, 15 Mar 2009)
New Revision: 4694

Added:
   branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/src/audiofilter_SRC.cpp
   branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/src/audiofilter_dolby.cpp
   branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/src/audiofilter_film2pal.cpp
   branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/src/audiofilter_limiter.cpp
   branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/src/audiofilter_normalize.cpp
Removed:
   branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_SRC.cpp
   branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_dolby.cpp
   branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_film2pal.cpp
   branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_limiter.cpp
   branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_normalize.cpp
Modified:
   branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/include/audiofilter_conf.h
   branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/src/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/src/audiofilter.cpp
   branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/src/audiofilter_mixer.cpp
Log:
[Audio] Move more audio filter

Modified: branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/include/audiofilter_conf.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/include/audiofilter_conf.h	2009-03-15 09:57:35 UTC (rev 4693)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/include/audiofilter_conf.h	2009-03-15 14:50:00 UTC (rev 4694)
@@ -19,6 +19,7 @@
 #include "ADM_audioFilter.h"
 #include "audiofilter.h"
 #include "audiofilter_mixer.h"
+#include "audiofilter_SRC.h"
 
 /**
     \class ADM_AUDIOFILTER_CONFIG
@@ -33,17 +34,20 @@
                 shiftInMs=0;
                 mixerEnabled=false;
                 mixerConf=CHANNEL_STEREO;
-
+                resamplerEnabled=false;
+                resamplerFrequency=44100;
         }
 
     uint64_t     startTimeInUs;
     int32_t      shiftInMs;
-    
+    // Mixer
     bool         mixerEnabled;
     CHANNEL_CONF mixerConf;
+    // Resampler
+    bool         resamplerEnabled;
+    uint32_t     resamplerFrequency;
 
 
-
 };
 
 #endif
\ No newline at end of file

Modified: branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/src/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/src/CMakeLists.txt	2009-03-15 09:57:35 UTC (rev 4693)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/src/CMakeLists.txt	2009-03-15 14:50:00 UTC (rev 4694)
@@ -2,6 +2,11 @@
 audiofilter_bridge.cpp
 audiofilter_access.cpp
 audiofilter_mixer.cpp
+audiofilter_dolby.cpp
+audiofilter_film2pal.cpp
+audiofilter_limiter.cpp
+audiofilter_normalize.cpp
+audiofilter_SRC.cpp
 audiofilter.cpp
 )
 ADD_LIBRARY(ADM_audioFilter STATIC ${ADM_audioFilter_SRCS})

Modified: branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/src/audiofilter.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/src/audiofilter.cpp	2009-03-15 09:57:35 UTC (rev 4693)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/src/audiofilter.cpp	2009-03-15 14:50:00 UTC (rev 4694)
@@ -62,9 +62,12 @@
 
 }
 /***********************************************************************/
+#define ADD_FILTER(x) { vec->push_back(x);last=x;}
 /**
     \fn ADM_buildFilterChain
     \brief Create a filterchain
+    @param vec : VectorFilter to build filters into
+    @param config: Filters configuration
 */
 bool ADM_buildFilterChain(VectorOfAudioFilter *vec,ADM_AUDIOFILTER_CONFIG *config)
 {
@@ -75,16 +78,22 @@
     // Bridge
     AUDMAudioFilter_Bridge *nw=new AUDMAudioFilter_Bridge(video_body,(uint32_t)( config->startTimeInUs/1000),
                                                                                 config->shiftInMs);
-    vec->push_back(nw);
-    last=nw;
+    ADD_FILTER(nw);
 
     // Mixer
     if(config->mixerEnabled)
     {
         AUDMAudioFilterMixer *mixer=new AUDMAudioFilterMixer(last,config->mixerConf);
-        vec->push_back(mixer);
-        last=mixer;
+        ADD_FILTER(mixer);
     }
+    // Resample
+    if(config->resamplerEnabled && config->resamplerFrequency!=last->getInfo()->frequency)
+    {
+        AUDMAudioFilterSrc *src=new AUDMAudioFilterSrc(last,config->resamplerFrequency);
+        ADD_FILTER(src);
+    }
+    // Normalize
+
     return true;
 }
 /**

Copied: branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/src/audiofilter_SRC.cpp (from rev 4693, branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_SRC.cpp)
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_SRC.cpp	2009-03-15 09:57:35 UTC (rev 4693)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/src/audiofilter_SRC.cpp	2009-03-15 14:50:00 UTC (rev 4694)
@@ -0,0 +1,113 @@
+/***************************************************************************
+        Sox
+ ***************************************************************************/
+ 
+ 
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include "ADM_default.h"
+
+#include "ADM_audioFilter.h"
+#include "audiofilter_SRC.h"
+/**
+    \fn AUDMAudioFilterSrc
+
+*/
+ AUDMAudioFilterSrc::AUDMAudioFilterSrc(AUDMAudioFilter *instream,uint32_t  tgt):AUDMAudioFilter (instream)
+{
+
+  targetFrequency=tgt;
+  _previous->rewind();     // rewind
+  printf("[FilterSrc] Creating from %d Hz to %d Hz\n",_wavHeader.frequency,targetFrequency);
+  if(_wavHeader.frequency==targetFrequency)
+  {
+    engaged=0;
+    return;
+  }
+    int org=_previous->getInfo()->frequency;
+    if(true!=resampler.init(org,tgt,_wavHeader.channels))
+    {
+        printf("[AudioFilter Resample] Init failed! \n");
+        engaged=0;
+        return;
+    }
+    engaged=1;
+    _wavHeader.frequency= targetFrequency;    
+     printf("[AudioFilter Resample] Init done. \n");
+};
+
+AUDMAudioFilterSrc::~AUDMAudioFilterSrc()
+{
+  printf("[AudioFilter Resample] Destroying\n");
+};
+
+#define BLK_SIZE 512
+//_____________________________________________
+uint32_t AUDMAudioFilterSrc::fill(uint32_t max,float *output,AUD_Status *status)
+{
+  if(!engaged)
+  {
+    return _previous->fill(max, output,status); 
+    
+  }
+    uint32_t snboutput=0;
+    // BLK_SIZE sample will generate blockOut sample*channel
+    float blockOutf=BLK_SIZE*_wavHeader.channels*_wavHeader.frequency;
+    blockOutf/=_previous->getInfo()->frequency;
+    uint32_t blockOut=(uint32_t)(blockOutf);
+
+    // Roundup to the next # channels
+    blockOut=(blockOut+_wavHeader.channels-1)/_wavHeader.channels;
+    blockOut*=_wavHeader.channels;
+
+    while(max>blockOut)
+    {
+      // Fill incoming buffer
+        shrink();
+        fillIncomingBuffer(status);
+        if(_head==_tail)
+        {
+          *status=AUD_END_OF_STREAM;
+          return snboutput;
+        }
+        ADM_assert(_tail>=_head);
+        uint32_t nb_in=(_tail-_head)/(_wavHeader.channels); // Nb Sample
+        if(nb_in>BLK_SIZE) nb_in=BLK_SIZE;
+        if(!nb_in)
+        {
+          printf("[Resampler]Not enough audio\n");
+          return snboutput;
+        }
+        // We have one BLK_SIZE incoming
+        uint32_t maxSample=BLK_SIZE*4; // FIXME!
+        uint32_t nbOut=0;
+        uint32_t nbIn=nb_in;
+        uint32_t nbInTaken=0;
+        float *from,*to;
+        from=_incomingBuffer+_head;
+        to=output;
+        if(true!=resampler.process(from,to, 
+                    nbIn,
+                    maxSample,
+                    &nbInTaken, 
+                    &nbOut))
+        {
+                *status=AUD_END_OF_STREAM;
+                return snboutput;
+        }
+        
+      _head=_head+(nbInTaken*_wavHeader.channels);
+      snboutput+=nbOut*_wavHeader.channels;
+      output+=nbOut*_wavHeader.channels;
+      max-=nbOut*_wavHeader.channels;
+    }
+    return snboutput;
+}
+//EOF

Copied: branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/src/audiofilter_dolby.cpp (from rev 4693, branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_dolby.cpp)
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_dolby.cpp	2009-03-15 09:57:35 UTC (rev 4693)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/src/audiofilter_dolby.cpp	2009-03-15 14:50:00 UTC (rev 4694)
@@ -0,0 +1,226 @@
+/**
+// \file audiofilter_dolby.cpp
+//
+// Description: 
+//
+//
+// Author: Mihail Zenkov <kreator at tut.by>, (C) 2006
+//
+// Copyright: See COPYING file that comes with this distribution
+//
+*/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include <string.h>
+
+#define NZEROS 500
+#define GAIN 1.571116176e+00
+
+static float xv_left[NZEROS+1];
+static float xv_right[NZEROS+1];
+
+static float xcoeffs[] =
+{ +0.0000000000, +0.0003214310, +0.0000000000, +0.0003252099,
++0.0000000000, +0.0003302355, +0.0000000000, +0.0003365372,
++0.0000000000, +0.0003441444, +0.0000000000, +0.0003530868,
++0.0000000000, +0.0003633944, +0.0000000000, +0.0003750973,
++0.0000000000, +0.0003882260, +0.0000000000, +0.0004028113,
++0.0000000000, +0.0004188840, +0.0000000000, +0.0004364757,
++0.0000000000, +0.0004556178, +0.0000000000, +0.0004763424,
++0.0000000000, +0.0004986818, +0.0000000000, +0.0005226689,
++0.0000000000, +0.0005483367, +0.0000000000, +0.0005757189,
++0.0000000000, +0.0006048495, +0.0000000000, +0.0006357632,
++0.0000000000, +0.0006684951, +0.0000000000, +0.0007030809,
++0.0000000000, +0.0007395569, +0.0000000000, +0.0007779600,
++0.0000000000, +0.0008183281, +0.0000000000, +0.0008606994,
++0.0000000000, +0.0009051133, +0.0000000000, +0.0009516098,
++0.0000000000, +0.0010002299, +0.0000000000, +0.0010510155,
++0.0000000000, +0.0011040098, +0.0000000000, +0.0011592568,
++0.0000000000, +0.0012168018, +0.0000000000, +0.0012766915,
++0.0000000000, +0.0013389738, +0.0000000000, +0.0014036982,
++0.0000000000, +0.0014709156, +0.0000000000, +0.0015406788,
++0.0000000000, +0.0016130421, +0.0000000000, +0.0016880620,
++0.0000000000, +0.0017657969, +0.0000000000, +0.0018463073,
++0.0000000000, +0.0019296564, +0.0000000000, +0.0020159096,
++0.0000000000, +0.0021051351, +0.0000000000, +0.0021974040,
++0.0000000000, +0.0022927905, +0.0000000000, +0.0023913723,
++0.0000000000, +0.0024932304, +0.0000000000, +0.0025984499,
++0.0000000000, +0.0027071199, +0.0000000000, +0.0028193341,
++0.0000000000, +0.0029351907, +0.0000000000, +0.0030547934,
++0.0000000000, +0.0031782511, +0.0000000000, +0.0033056791,
++0.0000000000, +0.0034371988, +0.0000000000, +0.0035729386,
++0.0000000000, +0.0037130347, +0.0000000000, +0.0038576311,
++0.0000000000, +0.0040068807, +0.0000000000, +0.0041609461,
++0.0000000000, +0.0043200000, +0.0000000000, +0.0044842264,
++0.0000000000, +0.0046538214, +0.0000000000, +0.0048289944,
++0.0000000000, +0.0050099691, +0.0000000000, +0.0051969851,
++0.0000000000, +0.0053902989, +0.0000000000, +0.0055901856,
++0.0000000000, +0.0057969412, +0.0000000000, +0.0060108836,
++0.0000000000, +0.0062323557, +0.0000000000, +0.0064617271,
++0.0000000000, +0.0066993973, +0.0000000000, +0.0069457986,
++0.0000000000, +0.0072013994, +0.0000000000, +0.0074667084,
++0.0000000000, +0.0077422784, +0.0000000000, +0.0080287117,
++0.0000000000, +0.0083266658, +0.0000000000, +0.0086368590,
++0.0000000000, +0.0089600787, +0.0000000000, +0.0092971888,
++0.0000000000, +0.0096491399, +0.0000000000, +0.0100169797,
++0.0000000000, +0.0104018664, +0.0000000000, +0.0108050829,
++0.0000000000, +0.0112280539, +0.0000000000, +0.0116723666,
++0.0000000000, +0.0121397934, +0.0000000000, +0.0126323203,
++0.0000000000, +0.0131521795, +0.0000000000, +0.0137018887,
++0.0000000000, +0.0142842976, +0.0000000000, +0.0149026446,
++0.0000000000, +0.0155606252, +0.0000000000, +0.0162624744,
++0.0000000000, +0.0170130694, +0.0000000000, +0.0178180552,
++0.0000000000, +0.0186840011, +0.0000000000, +0.0196185982,
++0.0000000000, +0.0206309077, +0.0000000000, +0.0217316805,
++0.0000000000, +0.0229337690, +0.0000000000, +0.0242526657,
++0.0000000000, +0.0257072177, +0.0000000000, +0.0273205841,
++0.0000000000, +0.0291215436, +0.0000000000, +0.0311463069,
++0.0000000000, +0.0334410798, +0.0000000000, +0.0360657647,
++0.0000000000, +0.0390994399, +0.0000000000, +0.0426486966,
++0.0000000000, +0.0468607407, +0.0000000000, +0.0519447683,
++0.0000000000, +0.0582084316, +0.0000000000, +0.0661234757,
++0.0000000000, +0.0764519642, +0.0000000000, +0.0905102051,
++0.0000000000, +0.1107845781, +0.0000000000, +0.1426030657,
++0.0000000000, +0.1998184590, +0.0000000000, +0.3332243858,
++0.0000000000, +0.9999636803, +0.0000000000, -0.9999636803,
+-0.0000000000, -0.3332243858, -0.0000000000, -0.1998184590,
+-0.0000000000, -0.1426030657, -0.0000000000, -0.1107845781,
+-0.0000000000, -0.0905102051, -0.0000000000, -0.0764519642,
+-0.0000000000, -0.0661234757, -0.0000000000, -0.0582084316,
+-0.0000000000, -0.0519447683, -0.0000000000, -0.0468607407,
+-0.0000000000, -0.0426486966, -0.0000000000, -0.0390994399,
+-0.0000000000, -0.0360657647, -0.0000000000, -0.0334410798,
+-0.0000000000, -0.0311463069, -0.0000000000, -0.0291215436,
+-0.0000000000, -0.0273205841, -0.0000000000, -0.0257072177,
+-0.0000000000, -0.0242526657, -0.0000000000, -0.0229337690,
+-0.0000000000, -0.0217316805, -0.0000000000, -0.0206309077,
+-0.0000000000, -0.0196185982, -0.0000000000, -0.0186840011,
+-0.0000000000, -0.0178180552, -0.0000000000, -0.0170130694,
+-0.0000000000, -0.0162624744, -0.0000000000, -0.0155606252,
+-0.0000000000, -0.0149026446, -0.0000000000, -0.0142842976,
+-0.0000000000, -0.0137018887, -0.0000000000, -0.0131521795,
+-0.0000000000, -0.0126323203, -0.0000000000, -0.0121397934,
+-0.0000000000, -0.0116723666, -0.0000000000, -0.0112280539,
+-0.0000000000, -0.0108050829, -0.0000000000, -0.0104018664,
+-0.0000000000, -0.0100169797, -0.0000000000, -0.0096491399,
+-0.0000000000, -0.0092971888, -0.0000000000, -0.0089600787,
+-0.0000000000, -0.0086368590, -0.0000000000, -0.0083266658,
+-0.0000000000, -0.0080287117, -0.0000000000, -0.0077422784,
+-0.0000000000, -0.0074667084, -0.0000000000, -0.0072013994,
+-0.0000000000, -0.0069457986, -0.0000000000, -0.0066993973,
+-0.0000000000, -0.0064617271, -0.0000000000, -0.0062323557,
+-0.0000000000, -0.0060108836, -0.0000000000, -0.0057969412,
+-0.0000000000, -0.0055901856, -0.0000000000, -0.0053902989,
+-0.0000000000, -0.0051969851, -0.0000000000, -0.0050099691,
+-0.0000000000, -0.0048289944, -0.0000000000, -0.0046538214,
+-0.0000000000, -0.0044842264, -0.0000000000, -0.0043200000,
+-0.0000000000, -0.0041609461, -0.0000000000, -0.0040068807,
+-0.0000000000, -0.0038576311, -0.0000000000, -0.0037130347,
+-0.0000000000, -0.0035729386, -0.0000000000, -0.0034371988,
+-0.0000000000, -0.0033056791, -0.0000000000, -0.0031782511,
+-0.0000000000, -0.0030547934, -0.0000000000, -0.0029351907,
+-0.0000000000, -0.0028193341, -0.0000000000, -0.0027071199,
+-0.0000000000, -0.0025984499, -0.0000000000, -0.0024932304,
+-0.0000000000, -0.0023913723, -0.0000000000, -0.0022927905,
+-0.0000000000, -0.0021974040, -0.0000000000, -0.0021051351,
+-0.0000000000, -0.0020159096, -0.0000000000, -0.0019296564,
+-0.0000000000, -0.0018463073, -0.0000000000, -0.0017657969,
+-0.0000000000, -0.0016880620, -0.0000000000, -0.0016130421,
+-0.0000000000, -0.0015406788, -0.0000000000, -0.0014709156,
+-0.0000000000, -0.0014036982, -0.0000000000, -0.0013389738,
+-0.0000000000, -0.0012766915, -0.0000000000, -0.0012168018,
+-0.0000000000, -0.0011592568, -0.0000000000, -0.0011040098,
+-0.0000000000, -0.0010510155, -0.0000000000, -0.0010002299,
+-0.0000000000, -0.0009516098, -0.0000000000, -0.0009051133,
+-0.0000000000, -0.0008606994, -0.0000000000, -0.0008183281,
+-0.0000000000, -0.0007779600, -0.0000000000, -0.0007395569,
+-0.0000000000, -0.0007030809, -0.0000000000, -0.0006684951,
+-0.0000000000, -0.0006357632, -0.0000000000, -0.0006048495,
+-0.0000000000, -0.0005757189, -0.0000000000, -0.0005483367,
+-0.0000000000, -0.0005226689, -0.0000000000, -0.0004986818,
+-0.0000000000, -0.0004763424, -0.0000000000, -0.0004556178,
+-0.0000000000, -0.0004364757, -0.0000000000, -0.0004188840,
+-0.0000000000, -0.0004028113, -0.0000000000, -0.0003882260,
+-0.0000000000, -0.0003750973, -0.0000000000, -0.0003633944,
+-0.0000000000, -0.0003530868, -0.0000000000, -0.0003441444,
+-0.0000000000, -0.0003365372, -0.0000000000, -0.0003302355,
+-0.0000000000, -0.0003252099, -0.0000000000, -0.0003214310,
+-0.0000000000,
+};
+
+static bool skip;
+
+void DolbySkip(bool on)
+{
+	skip = on;
+}
+
+void DolbyInit()
+{
+	memset(xv_left, 0, sizeof(float) * NZEROS);
+	memset(xv_right, 0, sizeof(float) * NZEROS);
+}
+
+float DolbyShiftLeft(float isamp)
+{
+if(!skip) {
+	float *p_xcoeffs = xcoeffs;
+	static int pos = 0;
+
+	if ((pos - 1) < 0)
+		xv_left[NZEROS] = isamp / GAIN;
+	else
+		xv_left[pos - 1] = isamp / GAIN;
+
+	float sum = 0;
+	for (int i = pos; i <= NZEROS; i++)
+		sum += (*(p_xcoeffs++) * xv_left[i]);
+
+	for (int i = 0; i < pos; i++)
+		sum += (*(p_xcoeffs++) * xv_left[i]);
+
+	pos++;
+	if (pos > NZEROS)
+		pos = 0;
+
+	return sum;
+}else{
+	return isamp;
+}
+}
+
+float DolbyShiftRight(float isamp)
+{
+if(!skip) {
+	float *p_xcoeffs = xcoeffs;
+	static int pos = 0;
+
+	if ((pos - 1) < 0)
+		xv_right[NZEROS] = isamp / GAIN;
+	else
+		xv_right[pos - 1] = isamp / GAIN;
+
+	float sum = 0;
+	for (int i = pos; i <= NZEROS; i++)
+		sum += (*(p_xcoeffs++) * xv_right[i]);
+
+	for (int i = 0; i < pos; i++)
+		sum += (*(p_xcoeffs++) * xv_right[i]);
+
+	pos++;
+	if (pos > NZEROS)
+		pos = 0;
+
+	return -sum;
+}else{
+	return isamp;
+}
+}

Copied: branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/src/audiofilter_film2pal.cpp (from rev 4693, branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_film2pal.cpp)
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_film2pal.cpp	2009-03-15 09:57:35 UTC (rev 4693)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/src/audiofilter_film2pal.cpp	2009-03-15 14:50:00 UTC (rev 4694)
@@ -0,0 +1,95 @@
+/***************************************************************************
+                   \file       audiofilterFilm2pal.cpp
+                             
+    
+    copyright            : (C) 2002/2009 by mean
+    email                : fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include <math.h>
+
+#include "ADM_default.h"
+
+#include "ADM_audioFilter.h"
+#include "audiofilter_film2pal.h"
+
+AUDMAudioFilterFilm2Pal::AUDMAudioFilterFilm2Pal(AUDMAudioFilter *previous) : 
+            AUDMAudioFilterFilmChange(previous,1001,960)
+{
+    printf("[Film2Pal] Created\n");
+}
+AUDMAudioFilterPal2Film::AUDMAudioFilterPal2Film(AUDMAudioFilter *previous) : 
+            AUDMAudioFilterFilmChange(previous,960,1001)
+{
+    printf("[Pal2Film] Created\n");
+}
+#define CONTECT ((SRC_STATE *)context))
+//__________
+
+AUDMAudioFilterFilmChange::AUDMAudioFilterFilmChange(AUDMAudioFilter * instream,uint32_t from, uint32_t to):AUDMAudioFilter (instream)
+{
+    // The parameter are in sample, we deal with fq
+    if(true!=resampler.init(from,to,_wavHeader.channels))
+    {
+        printf("[AudioFilter Resample] Init failed! \n");
+        ADM_assert(0);
+    }
+    printf("[FilmChange] Creating\n");
+};
+
+AUDMAudioFilterFilmChange::~AUDMAudioFilterFilmChange()
+{
+  
+  printf("[FilmChange] Destroying\n");
+}
+//
+//___________________________________________
+uint32_t AUDMAudioFilterFilmChange::fill( uint32_t max, float * buffer,AUD_Status *status)
+{
+  uint32_t len,i,rendered;
+  uint32_t chan=_wavHeader.channels;
+  float *start;
+  
+  shrink();
+  fillIncomingBuffer(status);
+  
+  len=_tail-_head;
+  int nbBlock=max/1001;
+  max=nbBlock*960; // Prevent overflow when slowing down
+
+  if(len>max) len=max;
+  
+  len=len/chan; // in sample
+
+        uint32_t maxSample=max/chan; // in sample
+        uint32_t nbOut=0;
+        uint32_t nbIn=len;
+        uint32_t nbInTaken=0;
+        float *from,*to;
+        from=_incomingBuffer+_head;
+        to=buffer;
+        if(true!=resampler.process(from,to, 
+                    nbIn,
+                    maxSample,
+                    &nbInTaken, 
+                    &nbOut))
+        {
+            printf("[FilmChange] EOF ??\n");
+            *status=AUD_END_OF_STREAM;
+            return 0;
+        }
+      _head=_head+(nbInTaken*chan);
+      return nbOut*chan;
+};
+
+//EOF
+

Copied: branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/src/audiofilter_limiter.cpp (from rev 4693, branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_limiter.cpp)
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_limiter.cpp	2009-03-15 09:57:35 UTC (rev 4693)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/src/audiofilter_limiter.cpp	2009-03-15 14:50:00 UTC (rev 4694)
@@ -0,0 +1,250 @@
+/***************************************************************************
+                          audioeng_6dbpress.cpp  -  description
+                             -------------------
+	Derived from audactity compressor
+	see http://audacity.sf.net
+ ***************************************************************************/
+/**********************************************************************
+
+  Audacity: A Digital Audio Editor
+
+  Compressor.cpp
+
+  Dominic Mazzoni
+
+  Steve Jolly made it inherit from EffectSimpleMono.
+  GUI added and implementation improved by Dominic Mazzoni, 5/11/2003.
+
+**********************************************************************/
+ 
+ 
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include <math.h>
+
+#include "ADM_default.h"
+
+
+#include "ADM_audioFilter.h"
+#include "audiofilter_limiter.h"
+
+
+
+AUDMAudioFilterLimiter::AUDMAudioFilterLimiter(AUDMAudioFilter *previous, DRCparam *param):AUDMAudioFilter (previous)
+{
+uint32_t nbChan=previous->getInfo()->channels;
+#define AMP 4
+    _previous->rewind();
+    memcpy(&_param,param,sizeof(_param));
+//
+// The base is 100 ms
+//
+
+    mCircleSize=DRC_WINDOW;
+    mCircleSize=mCircleSize-(mCircleSize%nbChan);
+    drc_cleanup();
+    printf("[DRC] Created DRC:%u Window:%u nbChan %u\n",mCircleSize,DRC_WINDOW,nbChan);
+
+};
+void AUDMAudioFilterLimiter::drc_cleanup(void)
+{
+  float mCurRate=(float)_wavHeader.frequency;
+   
+  for(int j=0; j<mCircleSize; j++) {
+      mCircle[j] = 0.0;
+      mLevelCircle[j] = _param.mFloor;
+   }
+   mCirclePos = 0;
+   mRMSSum = 0.0;
+
+   mGainDB = ((_param.mThresholdDB*-0.7) * (1 - 1/_param.mRatio));
+   if (mGainDB < 0)
+      mGainDB = 0;
+
+   mThreshold = pow(10.0, _param.mThresholdDB/10); // factor of 10 because it's power
+
+   if (_param.mUseGain)
+      mGain = pow(10.0, mGainDB/20); // factor of 20 because it's amplitude
+   else
+      mGain = 1.0;
+
+   mAttackFactor = exp(-log(_param.mFloor) / (mCurRate * _param.mAttackTime + 0.5));
+   mDecayFactor = exp(log(_param.mFloor) / (mCurRate * _param.mDecayTime + 0.5));
+
+   mLastLevel = 0.0;
+   
+   memset(mCircle,0,sizeof(mCircle));
+   memset(follow,0,sizeof(follow));
+   memset(mLevelCircle,0,sizeof(mLevelCircle));
+    
+}
+//
+AUDMAudioFilterLimiter::~AUDMAudioFilterLimiter()
+{
+  printf("[DRC] Destroyed\n");
+}
+
+uint32_t   AUDMAudioFilterLimiter::fill(uint32_t max,float *output,AUD_Status *status)
+{
+  uint32_t len,i;
+  
+  shrink();
+  fillIncomingBuffer(status);
+  
+  
+  len=_tail-_head;
+  if(len>max) len=max;
+  if(len>=DELIM_WINDOW_SIZE) len=DELIM_WINDOW_SIZE-1;
+  
+  // Count in full sample  i.e. all channels
+  len=len-(len%_wavHeader.channels);
+  
+  // Process..
+  if (mLastLevel == 0.0) {
+    int preSeed = mCircleSize;
+    if (preSeed > len)
+      preSeed = len;
+    for(i=0; i<preSeed; i++)
+      AvgCircle(_incomingBuffer[_head+i]);
+  }
+  
+    for (i = 0; i < len; i++) {
+      Follow(_incomingBuffer[_head+i], &follow[i], i);
+    }
+
+    for (i = 0; i < len; i++) {
+      output[i] =DoCompression(_incomingBuffer[_head+i], follow[i]);
+    }  
+    _head+=len;
+    return len;
+}
+
+float AUDMAudioFilterLimiter::AvgCircle(float value)
+{
+  float level;
+
+   // Calculate current level from root-mean-squared of
+   // circular buffer ("RMS")
+   mRMSSum -= mCircle[mCirclePos];
+   mCircle[mCirclePos] = value*value;
+   mRMSSum += mCircle[mCirclePos];
+   level = sqrt(mRMSSum/mCircleSize);
+   mLevelCircle[mCirclePos] = level;
+   mCirclePos = (mCirclePos+1)%mCircleSize;  
+   return level;
+}
+
+void AUDMAudioFilterLimiter::Follow(float x, float *outEnv, int maxBack)
+{
+   /*
+
+   "Follow"ing algorithm by Roger B. Dannenberg, taken from
+   Nyquist.  His description follows.  -DMM
+
+   Description: this is a sophisticated envelope follower.
+    The input is an envelope, e.g. something produced with
+    the AVG function. The purpose of this function is to
+    generate a smooth envelope that is generally not less
+    than the input signal. In other words, we want to "ride"
+    the peaks of the signal with a smooth function. The 
+    algorithm is as follows: keep a current output value
+    (called the "value"). The value is allowed to increase
+    by at most rise_factor and decrease by at most fall_factor.
+    Therefore, the next value should be between
+    value * rise_factor and value * fall_factor. If the input
+    is in this range, then the next value is simply the input.
+    If the input is less than value * fall_factor, then the
+    next value is just value * fall_factor, which will be greater
+    than the input signal. If the input is greater than value *
+    rise_factor, then we compute a rising envelope that meets
+    the input value by working bacwards in time, changing the
+    previous values to input / rise_factor, input / rise_factor^2,
+    input / rise_factor^3, etc. until this new envelope intersects
+    the previously computed values. There is only a limited buffer
+    in which we can work backwards, so if the new envelope does not
+    intersect the old one, then make yet another pass, this time
+    from the oldest buffered value forward, increasing on each 
+    sample by rise_factor to produce a maximal envelope. This will 
+    still be less than the input.
+    
+    The value has a lower limit of floor to make sure value has a 
+    reasonable positive value from which to begin an attack.
+   */
+
+   float level = AvgCircle(x);
+   float high = mLastLevel * mAttackFactor;
+   float low = mLastLevel * mDecayFactor;
+
+   if (low < _param.mFloor)
+      low = _param.mFloor;
+
+   if (level < low)
+      *outEnv = low;
+   else if (level < high)
+      *outEnv = level;
+   else {
+      // Backtrack
+     float attackInverse = 1.0 / mAttackFactor;
+     float temp = level * attackInverse;
+
+      int backtrack = 50;
+      if (backtrack > maxBack)
+         backtrack = maxBack;
+
+      float *ptr = &outEnv[-1];
+      int i;
+      bool ok = false;
+      for(i=0; i<backtrack-2; i++) {
+         if (*ptr < temp) {
+            *ptr-- = temp;
+            temp *= attackInverse;
+         }
+         else {
+            ok = true;
+            break;
+         }   
+      }
+
+      if (!ok && backtrack>1 && (*ptr < temp)) {
+         temp = *ptr;
+         for (i = 0; i < backtrack-1; i++) {
+            ptr++;
+            temp *= mAttackFactor;
+            *ptr = temp;
+         }
+      }
+      else
+         *outEnv = level;
+   }
+
+   mLastLevel = *outEnv;
+}
+
+float AUDMAudioFilterLimiter::DoCompression(float value, float env)
+{
+   float mult;
+   float out;
+
+   if (env > mThreshold)
+      mult = mGain * pow(mThreshold/env, 1.0/_param.mRatio);
+   else
+      mult = mGain;
+
+   out = value * mult;
+
+   if (out > 1.0)
+      out = 1.0;
+
+   if (out < -1.0)
+      out = -1.0;
+
+   return out;
+}
+//EOF

Modified: branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/src/audiofilter_mixer.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/src/audiofilter_mixer.cpp	2009-03-15 09:57:35 UTC (rev 4693)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/src/audiofilter_mixer.cpp	2009-03-15 14:50:00 UTC (rev 4694)
@@ -1,5 +1,8 @@
 /***************************************************************************
-         Downmixer
+       \file audiofilter_mixer.cpp
+       \brief Change channels configuration (down/up channels)
+
+    (C) Mihail Zenkov <kreator at tut.by> & mean
  ***************************************************************************/
  
  

Copied: branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/src/audiofilter_normalize.cpp (from rev 4693, branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_normalize.cpp)
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_normalize.cpp	2009-03-15 09:57:35 UTC (rev 4693)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/src/audiofilter_normalize.cpp	2009-03-15 14:50:00 UTC (rev 4694)
@@ -0,0 +1,183 @@
+/***************************************************************************
+                          \file  audiofilter_normalize
+                          \brief absolute or automatic gain filter
+                             -------------------
+    
+    copyright            : (C) 2002/2009 by mean
+    email                : fixounet at free.fr
+    
+    Compute the ratio so that the maximum is at -3db
+    
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+
+#include <math.h>
+
+#include "ADM_default.h"
+#include "ADM_audioFilter.h"
+#include "audiofilter_normalize_param.h"
+#include "audiofilter_normalize.h"
+#include "audiofilter_dolby.h"
+
+#include "ADM_audio/aviaudio.hxx"
+//#include "ADM_dialog/DIA_busy.h" //CANNOT USE IT! We are in another thread!
+
+extern AVDMGenericAudioStream *currentaudiostream;
+
+#ifdef __WIN32
+#define POW10(x)   pow(10,x)
+#elif defined(ADM_BSD_FAMILY)
+#define POW10(x) powf(10.0,x)
+#else
+#define POW10(x)  pow10f(x)
+#endif
+
+#define LINEAR_TO_DB(x) (20.*log10(x))
+#define DB_TO_LINEAR(x) (POW10((x/20.)))
+
+// Ctor
+//__________
+
+AUDMAudioFilterNormalize::AUDMAudioFilterNormalize(AUDMAudioFilter * instream,GAINparam *param):AUDMAudioFilter (instream)
+{
+  float db_out;
+    // nothing special here...
+  switch(param->mode)
+  {
+    case ADM_NO_GAIN: _ratio=1;_scanned=1;printf("[Gain] Gain of 1.0\n");break; 
+    case ADM_GAIN_AUTOMATIC: _ratio=1;_scanned=0;printf("[Gain] Automatic gain\n");break;
+    case ADM_GAIN_MANUAL: 
+                _scanned=1;
+                db_out =  param->gain10/10.0; // Dbout is in 10*DB (!)
+                _ratio = DB_TO_LINEAR(db_out);
+                printf("[Gain] %f db (p=%d)\n", (float)(param->gain10)/10.,param->gain10);
+                printf("[Gain] Linear ratio of : %03.3f\n", _ratio);
+  }
+    _previous->rewind();
+};
+
+AUDMAudioFilterNormalize::~AUDMAudioFilterNormalize()
+{
+
+}
+//
+// For normalize, we scan the input stream
+// to check for maximum value
+//___________________________________________
+uint8_t AUDMAudioFilterNormalize::preprocess(void)
+{
+
+    int16_t *ptr;
+    uint32_t scanned = 0, ch = 0;
+    AUD_Status status;
+    _ratio = 0;
+
+    uint32_t percent=0;
+    uint32_t current=0,llength=0;
+    float max[_wavHeader.channels];
+    _previous->rewind();
+    DolbySkip(1);
+    printf("\n Seeking for maximum value, that can take a while\n");
+
+    llength=_length ;
+    
+
+      for(int i=0;i<_wavHeader.channels;i++) max[i]=0;
+      while (1)
+      {
+          int ready=_previous->fill(AUD_PROCESS_BUFFER_SIZE>>2,_incomingBuffer,&status);
+          if(!ready)
+          {
+            if(status==AUD_END_OF_STREAM) 
+            {
+              break; 
+            }
+           else 
+            {
+              printf("Unknown cause : %d\n",status);
+              ADM_assert(0); 
+            }
+          }
+          ADM_assert(!(ready %_wavHeader.channels));
+          
+          int index=0;
+          float current;
+          
+        //  printf("*\n");
+          int sample= ready /_wavHeader.channels;
+          for(int j=0;j<sample;j++)
+            for(int chan=0;chan<_wavHeader.channels;chan++)
+          {
+            current=fabs(_incomingBuffer[index++]);
+            if(current>max[chan]) max[chan]=current;
+          }
+          scanned+=ready;
+      }
+      
+      
+      
+
+    _previous->rewind();
+    float mx=0;
+    for(int chan=0;chan<_wavHeader.channels;chan++)
+    {
+        if(max[chan]>mx) mx=max[chan];
+        printf("[Normalize] maximum found for channel %d : %f\n", chan,max[chan]);
+    }
+    printf("[Normalize] Using : %0.4f as max value \n", mx);
+    double db_in, db_out=-3;
+
+    if (mx>0.001)
+      db_in = LINEAR_TO_DB(mx);
+    else
+      db_in = -20; // We consider -20 DB to be noise
+
+    printf("--> %2.2f db / %2.2f \n", db_in, db_out);
+
+    // search ratio
+    _ratio=1;
+
+    float db_delta=db_out-db_in;
+    printf("[Normalize]Gain %f dB\n",db_delta);
+    _ratio = DB_TO_LINEAR(db_delta);
+    printf("\n Using ratio of : %f\n", _ratio);
+
+    _scanned = 1;
+    DolbySkip(0);
+    _previous->rewind();
+    return 1;
+}
+//
+//___________________________________________
+uint32_t AUDMAudioFilterNormalize::fill( uint32_t max, float * buffer,AUD_Status *status)
+{
+    uint32_t rd, i, j,rd2;
+
+    *status=AUD_OK;
+    if(!_scanned) preprocess();
+    rd = _previous->fill(max, _incomingBuffer,status);
+    if(!rd)
+    {
+      if(*status==AUD_END_OF_STREAM) return 0;
+      ADM_assert(0);
+    }
+    float *in,*out,tmp;
+    for (i = 0; i < rd; i++)
+    {
+      tmp=_incomingBuffer[i];
+      tmp*=_ratio;
+      buffer[i]=tmp;
+    }
+    return rd;
+};
+//EOF
+

Deleted: branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_SRC.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_SRC.cpp	2009-03-15 09:57:35 UTC (rev 4693)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_SRC.cpp	2009-03-15 14:50:00 UTC (rev 4694)
@@ -1,113 +0,0 @@
-/***************************************************************************
-        Sox
- ***************************************************************************/
- 
- 
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-#include "ADM_default.h"
-
-#include "ADM_audioFilter.h"
-#include "audiofilter_SRC.h"
-/**
-    \fn AUDMAudioFilterSrc
-
-*/
- AUDMAudioFilterSrc::AUDMAudioFilterSrc(AUDMAudioFilter *instream,uint32_t  tgt):AUDMAudioFilter (instream)
-{
-
-  targetFrequency=tgt;
-  _previous->rewind();     // rewind
-  printf("[FilterSrc] Creating from %d Hz to %d Hz\n",_wavHeader.frequency,targetFrequency);
-  if(_wavHeader.frequency==targetFrequency)
-  {
-    engaged=0;
-    return;
-  }
-    int org=_previous->getInfo()->frequency;
-    if(true!=resampler.init(org,tgt,_wavHeader.channels))
-    {
-        printf("[AudioFilter Resample] Init failed! \n");
-        engaged=0;
-        return;
-    }
-    engaged=1;
-    _wavHeader.frequency= targetFrequency;    
-     printf("[AudioFilter Resample] Init done. \n");
-};
-
-AUDMAudioFilterSrc::~AUDMAudioFilterSrc()
-{
-  printf("[AudioFilter Resample] Destroying\n");
-};
-
-#define BLK_SIZE 512
-//_____________________________________________
-uint32_t AUDMAudioFilterSrc::fill(uint32_t max,float *output,AUD_Status *status)
-{
-  if(!engaged)
-  {
-    return _previous->fill(max, output,status); 
-    
-  }
-    uint32_t snboutput=0;
-    // BLK_SIZE sample will generate blockOut sample*channel
-    float blockOutf=BLK_SIZE*_wavHeader.channels*_wavHeader.frequency;
-    blockOutf/=_previous->getInfo()->frequency;
-    uint32_t blockOut=(uint32_t)(blockOutf);
-
-    // Roundup to the next # channels
-    blockOut=(blockOut+_wavHeader.channels-1)/_wavHeader.channels;
-    blockOut*=_wavHeader.channels;
-
-    while(max>blockOut)
-    {
-      // Fill incoming buffer
-        shrink();
-        fillIncomingBuffer(status);
-        if(_head==_tail)
-        {
-          *status=AUD_END_OF_STREAM;
-          return snboutput;
-        }
-        ADM_assert(_tail>=_head);
-        uint32_t nb_in=(_tail-_head)/(_wavHeader.channels); // Nb Sample
-        if(nb_in>BLK_SIZE) nb_in=BLK_SIZE;
-        if(!nb_in)
-        {
-          printf("[Resampler]Not enough audio\n");
-          return snboutput;
-        }
-        // We have one BLK_SIZE incoming
-        uint32_t maxSample=BLK_SIZE*4; // FIXME!
-        uint32_t nbOut=0;
-        uint32_t nbIn=nb_in;
-        uint32_t nbInTaken=0;
-        float *from,*to;
-        from=_incomingBuffer+_head;
-        to=output;
-        if(true!=resampler.process(from,to, 
-                    nbIn,
-                    maxSample,
-                    &nbInTaken, 
-                    &nbOut))
-        {
-                *status=AUD_END_OF_STREAM;
-                return snboutput;
-        }
-        
-      _head=_head+(nbInTaken*_wavHeader.channels);
-      snboutput+=nbOut*_wavHeader.channels;
-      output+=nbOut*_wavHeader.channels;
-      max-=nbOut*_wavHeader.channels;
-    }
-    return snboutput;
-}
-//EOF

Deleted: branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_dolby.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_dolby.cpp	2009-03-15 09:57:35 UTC (rev 4693)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_dolby.cpp	2009-03-15 14:50:00 UTC (rev 4694)
@@ -1,216 +0,0 @@
-//
-// C++ Interface: audiofilter_dolby
-//
-// Description: 
-//
-//
-// Author: Mihail Zenkov <kreator at tut.by>, (C) 2006
-//
-// Copyright: See COPYING file that comes with this distribution
-//
-//
-#include <string.h>
-
-#define NZEROS 500
-#define GAIN 1.571116176e+00
-
-static float xv_left[NZEROS+1];
-static float xv_right[NZEROS+1];
-
-static float xcoeffs[] =
-{ +0.0000000000, +0.0003214310, +0.0000000000, +0.0003252099,
-+0.0000000000, +0.0003302355, +0.0000000000, +0.0003365372,
-+0.0000000000, +0.0003441444, +0.0000000000, +0.0003530868,
-+0.0000000000, +0.0003633944, +0.0000000000, +0.0003750973,
-+0.0000000000, +0.0003882260, +0.0000000000, +0.0004028113,
-+0.0000000000, +0.0004188840, +0.0000000000, +0.0004364757,
-+0.0000000000, +0.0004556178, +0.0000000000, +0.0004763424,
-+0.0000000000, +0.0004986818, +0.0000000000, +0.0005226689,
-+0.0000000000, +0.0005483367, +0.0000000000, +0.0005757189,
-+0.0000000000, +0.0006048495, +0.0000000000, +0.0006357632,
-+0.0000000000, +0.0006684951, +0.0000000000, +0.0007030809,
-+0.0000000000, +0.0007395569, +0.0000000000, +0.0007779600,
-+0.0000000000, +0.0008183281, +0.0000000000, +0.0008606994,
-+0.0000000000, +0.0009051133, +0.0000000000, +0.0009516098,
-+0.0000000000, +0.0010002299, +0.0000000000, +0.0010510155,
-+0.0000000000, +0.0011040098, +0.0000000000, +0.0011592568,
-+0.0000000000, +0.0012168018, +0.0000000000, +0.0012766915,
-+0.0000000000, +0.0013389738, +0.0000000000, +0.0014036982,
-+0.0000000000, +0.0014709156, +0.0000000000, +0.0015406788,
-+0.0000000000, +0.0016130421, +0.0000000000, +0.0016880620,
-+0.0000000000, +0.0017657969, +0.0000000000, +0.0018463073,
-+0.0000000000, +0.0019296564, +0.0000000000, +0.0020159096,
-+0.0000000000, +0.0021051351, +0.0000000000, +0.0021974040,
-+0.0000000000, +0.0022927905, +0.0000000000, +0.0023913723,
-+0.0000000000, +0.0024932304, +0.0000000000, +0.0025984499,
-+0.0000000000, +0.0027071199, +0.0000000000, +0.0028193341,
-+0.0000000000, +0.0029351907, +0.0000000000, +0.0030547934,
-+0.0000000000, +0.0031782511, +0.0000000000, +0.0033056791,
-+0.0000000000, +0.0034371988, +0.0000000000, +0.0035729386,
-+0.0000000000, +0.0037130347, +0.0000000000, +0.0038576311,
-+0.0000000000, +0.0040068807, +0.0000000000, +0.0041609461,
-+0.0000000000, +0.0043200000, +0.0000000000, +0.0044842264,
-+0.0000000000, +0.0046538214, +0.0000000000, +0.0048289944,
-+0.0000000000, +0.0050099691, +0.0000000000, +0.0051969851,
-+0.0000000000, +0.0053902989, +0.0000000000, +0.0055901856,
-+0.0000000000, +0.0057969412, +0.0000000000, +0.0060108836,
-+0.0000000000, +0.0062323557, +0.0000000000, +0.0064617271,
-+0.0000000000, +0.0066993973, +0.0000000000, +0.0069457986,
-+0.0000000000, +0.0072013994, +0.0000000000, +0.0074667084,
-+0.0000000000, +0.0077422784, +0.0000000000, +0.0080287117,
-+0.0000000000, +0.0083266658, +0.0000000000, +0.0086368590,
-+0.0000000000, +0.0089600787, +0.0000000000, +0.0092971888,
-+0.0000000000, +0.0096491399, +0.0000000000, +0.0100169797,
-+0.0000000000, +0.0104018664, +0.0000000000, +0.0108050829,
-+0.0000000000, +0.0112280539, +0.0000000000, +0.0116723666,
-+0.0000000000, +0.0121397934, +0.0000000000, +0.0126323203,
-+0.0000000000, +0.0131521795, +0.0000000000, +0.0137018887,
-+0.0000000000, +0.0142842976, +0.0000000000, +0.0149026446,
-+0.0000000000, +0.0155606252, +0.0000000000, +0.0162624744,
-+0.0000000000, +0.0170130694, +0.0000000000, +0.0178180552,
-+0.0000000000, +0.0186840011, +0.0000000000, +0.0196185982,
-+0.0000000000, +0.0206309077, +0.0000000000, +0.0217316805,
-+0.0000000000, +0.0229337690, +0.0000000000, +0.0242526657,
-+0.0000000000, +0.0257072177, +0.0000000000, +0.0273205841,
-+0.0000000000, +0.0291215436, +0.0000000000, +0.0311463069,
-+0.0000000000, +0.0334410798, +0.0000000000, +0.0360657647,
-+0.0000000000, +0.0390994399, +0.0000000000, +0.0426486966,
-+0.0000000000, +0.0468607407, +0.0000000000, +0.0519447683,
-+0.0000000000, +0.0582084316, +0.0000000000, +0.0661234757,
-+0.0000000000, +0.0764519642, +0.0000000000, +0.0905102051,
-+0.0000000000, +0.1107845781, +0.0000000000, +0.1426030657,
-+0.0000000000, +0.1998184590, +0.0000000000, +0.3332243858,
-+0.0000000000, +0.9999636803, +0.0000000000, -0.9999636803,
--0.0000000000, -0.3332243858, -0.0000000000, -0.1998184590,
--0.0000000000, -0.1426030657, -0.0000000000, -0.1107845781,
--0.0000000000, -0.0905102051, -0.0000000000, -0.0764519642,
--0.0000000000, -0.0661234757, -0.0000000000, -0.0582084316,
--0.0000000000, -0.0519447683, -0.0000000000, -0.0468607407,
--0.0000000000, -0.0426486966, -0.0000000000, -0.0390994399,
--0.0000000000, -0.0360657647, -0.0000000000, -0.0334410798,
--0.0000000000, -0.0311463069, -0.0000000000, -0.0291215436,
--0.0000000000, -0.0273205841, -0.0000000000, -0.0257072177,
--0.0000000000, -0.0242526657, -0.0000000000, -0.0229337690,
--0.0000000000, -0.0217316805, -0.0000000000, -0.0206309077,
--0.0000000000, -0.0196185982, -0.0000000000, -0.0186840011,
--0.0000000000, -0.0178180552, -0.0000000000, -0.0170130694,
--0.0000000000, -0.0162624744, -0.0000000000, -0.0155606252,
--0.0000000000, -0.0149026446, -0.0000000000, -0.0142842976,
--0.0000000000, -0.0137018887, -0.0000000000, -0.0131521795,
--0.0000000000, -0.0126323203, -0.0000000000, -0.0121397934,
--0.0000000000, -0.0116723666, -0.0000000000, -0.0112280539,
--0.0000000000, -0.0108050829, -0.0000000000, -0.0104018664,
--0.0000000000, -0.0100169797, -0.0000000000, -0.0096491399,
--0.0000000000, -0.0092971888, -0.0000000000, -0.0089600787,
--0.0000000000, -0.0086368590, -0.0000000000, -0.0083266658,
--0.0000000000, -0.0080287117, -0.0000000000, -0.0077422784,
--0.0000000000, -0.0074667084, -0.0000000000, -0.0072013994,
--0.0000000000, -0.0069457986, -0.0000000000, -0.0066993973,
--0.0000000000, -0.0064617271, -0.0000000000, -0.0062323557,
--0.0000000000, -0.0060108836, -0.0000000000, -0.0057969412,
--0.0000000000, -0.0055901856, -0.0000000000, -0.0053902989,
--0.0000000000, -0.0051969851, -0.0000000000, -0.0050099691,
--0.0000000000, -0.0048289944, -0.0000000000, -0.0046538214,
--0.0000000000, -0.0044842264, -0.0000000000, -0.0043200000,
--0.0000000000, -0.0041609461, -0.0000000000, -0.0040068807,
--0.0000000000, -0.0038576311, -0.0000000000, -0.0037130347,
--0.0000000000, -0.0035729386, -0.0000000000, -0.0034371988,
--0.0000000000, -0.0033056791, -0.0000000000, -0.0031782511,
--0.0000000000, -0.0030547934, -0.0000000000, -0.0029351907,
--0.0000000000, -0.0028193341, -0.0000000000, -0.0027071199,
--0.0000000000, -0.0025984499, -0.0000000000, -0.0024932304,
--0.0000000000, -0.0023913723, -0.0000000000, -0.0022927905,
--0.0000000000, -0.0021974040, -0.0000000000, -0.0021051351,
--0.0000000000, -0.0020159096, -0.0000000000, -0.0019296564,
--0.0000000000, -0.0018463073, -0.0000000000, -0.0017657969,
--0.0000000000, -0.0016880620, -0.0000000000, -0.0016130421,
--0.0000000000, -0.0015406788, -0.0000000000, -0.0014709156,
--0.0000000000, -0.0014036982, -0.0000000000, -0.0013389738,
--0.0000000000, -0.0012766915, -0.0000000000, -0.0012168018,
--0.0000000000, -0.0011592568, -0.0000000000, -0.0011040098,
--0.0000000000, -0.0010510155, -0.0000000000, -0.0010002299,
--0.0000000000, -0.0009516098, -0.0000000000, -0.0009051133,
--0.0000000000, -0.0008606994, -0.0000000000, -0.0008183281,
--0.0000000000, -0.0007779600, -0.0000000000, -0.0007395569,
--0.0000000000, -0.0007030809, -0.0000000000, -0.0006684951,
--0.0000000000, -0.0006357632, -0.0000000000, -0.0006048495,
--0.0000000000, -0.0005757189, -0.0000000000, -0.0005483367,
--0.0000000000, -0.0005226689, -0.0000000000, -0.0004986818,
--0.0000000000, -0.0004763424, -0.0000000000, -0.0004556178,
--0.0000000000, -0.0004364757, -0.0000000000, -0.0004188840,
--0.0000000000, -0.0004028113, -0.0000000000, -0.0003882260,
--0.0000000000, -0.0003750973, -0.0000000000, -0.0003633944,
--0.0000000000, -0.0003530868, -0.0000000000, -0.0003441444,
--0.0000000000, -0.0003365372, -0.0000000000, -0.0003302355,
--0.0000000000, -0.0003252099, -0.0000000000, -0.0003214310,
--0.0000000000,
-};
-
-static bool skip;
-
-void DolbySkip(bool on)
-{
-	skip = on;
-}
-
-void DolbyInit()
-{
-	memset(xv_left, 0, sizeof(float) * NZEROS);
-	memset(xv_right, 0, sizeof(float) * NZEROS);
-}
-
-float DolbyShiftLeft(float isamp)
-{
-if(!skip) {
-	float *p_xcoeffs = xcoeffs;
-	static int pos = 0;
-
-	if ((pos - 1) < 0)
-		xv_left[NZEROS] = isamp / GAIN;
-	else
-		xv_left[pos - 1] = isamp / GAIN;
-
-	float sum = 0;
-	for (int i = pos; i <= NZEROS; i++)
-		sum += (*(p_xcoeffs++) * xv_left[i]);
-
-	for (int i = 0; i < pos; i++)
-		sum += (*(p_xcoeffs++) * xv_left[i]);
-
-	pos++;
-	if (pos > NZEROS)
-		pos = 0;
-
-	return sum;
-}else{
-	return isamp;
-}
-}
-
-float DolbyShiftRight(float isamp)
-{
-if(!skip) {
-	float *p_xcoeffs = xcoeffs;
-	static int pos = 0;
-
-	if ((pos - 1) < 0)
-		xv_right[NZEROS] = isamp / GAIN;
-	else
-		xv_right[pos - 1] = isamp / GAIN;
-
-	float sum = 0;
-	for (int i = pos; i <= NZEROS; i++)
-		sum += (*(p_xcoeffs++) * xv_right[i]);
-
-	for (int i = 0; i < pos; i++)
-		sum += (*(p_xcoeffs++) * xv_right[i]);
-
-	pos++;
-	if (pos > NZEROS)
-		pos = 0;
-
-	return -sum;
-}else{
-	return isamp;
-}
-}

Deleted: branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_film2pal.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_film2pal.cpp	2009-03-15 09:57:35 UTC (rev 4693)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_film2pal.cpp	2009-03-15 14:50:00 UTC (rev 4694)
@@ -1,95 +0,0 @@
-/***************************************************************************
-                          audiofilterFilm2pal
-                             -------------------
-    
-    copyright            : (C) 2002/2006 by mean
-    email                : fixounet at free.fr
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-#include <math.h>
-
-#include "ADM_default.h"
-
-#include "ADM_audioFilter.h"
-#include "audiofilter_film2pal.h"
-
-AUDMAudioFilterFilm2Pal::AUDMAudioFilterFilm2Pal(AUDMAudioFilter *previous) : 
-            AUDMAudioFilterFilmChange(previous,1001,960)
-{
-    printf("[Film2Pal] Created\n");
-}
-AUDMAudioFilterPal2Film::AUDMAudioFilterPal2Film(AUDMAudioFilter *previous) : 
-            AUDMAudioFilterFilmChange(previous,960,1001)
-{
-    printf("[Pal2Film] Created\n");
-}
-#define CONTECT ((SRC_STATE *)context))
-//__________
-
-AUDMAudioFilterFilmChange::AUDMAudioFilterFilmChange(AUDMAudioFilter * instream,uint32_t from, uint32_t to):AUDMAudioFilter (instream)
-{
-    // The parameter are in sample, we deal with fq
-    if(true!=resampler.init(from,to,_wavHeader.channels))
-    {
-        printf("[AudioFilter Resample] Init failed! \n");
-        ADM_assert(0);
-    }
-    printf("[FilmChange] Creating\n");
-};
-
-AUDMAudioFilterFilmChange::~AUDMAudioFilterFilmChange()
-{
-  
-  printf("[FilmChange] Destroying\n");
-}
-//
-//___________________________________________
-uint32_t AUDMAudioFilterFilmChange::fill( uint32_t max, float * buffer,AUD_Status *status)
-{
-  uint32_t len,i,rendered;
-  uint32_t chan=_wavHeader.channels;
-  float *start;
-  
-  shrink();
-  fillIncomingBuffer(status);
-  
-  len=_tail-_head;
-  int nbBlock=max/1001;
-  max=nbBlock*960; // Prevent overflow when slowing down
-
-  if(len>max) len=max;
-  
-  len=len/chan; // in sample
-
-        uint32_t maxSample=max/chan; // in sample
-        uint32_t nbOut=0;
-        uint32_t nbIn=len;
-        uint32_t nbInTaken=0;
-        float *from,*to;
-        from=_incomingBuffer+_head;
-        to=buffer;
-        if(true!=resampler.process(from,to, 
-                    nbIn,
-                    maxSample,
-                    &nbInTaken, 
-                    &nbOut))
-        {
-            printf("[FilmChange] EOF ??\n");
-            *status=AUD_END_OF_STREAM;
-            return 0;
-        }
-      _head=_head+(nbInTaken*chan);
-      return nbOut*chan;
-};
-
-//EOF
-

Deleted: branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_limiter.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_limiter.cpp	2009-03-15 09:57:35 UTC (rev 4693)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_limiter.cpp	2009-03-15 14:50:00 UTC (rev 4694)
@@ -1,251 +0,0 @@
-/***************************************************************************
-                          audioeng_6dbpress.cpp  -  description
-                             -------------------
-	Derived from audactity compressor
-	see http://audacity.sf.net
- ***************************************************************************/
-/**********************************************************************
-
-  Audacity: A Digital Audio Editor
-
-  Compressor.cpp
-
-  Dominic Mazzoni
-
-  Steve Jolly made it inherit from EffectSimpleMono.
-  GUI added and implementation improved by Dominic Mazzoni, 5/11/2003.
-
-**********************************************************************/
- 
- 
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-#include "config.h"
-#include <math.h>
-
-#include "ADM_default.h"
-
-
-#include "ADM_audioFilter.h"
-#include "audiofilter_limiter.h"
-
-
-
-AUDMAudioFilterLimiter::AUDMAudioFilterLimiter(AUDMAudioFilter *previous, DRCparam *param):AUDMAudioFilter (previous)
-{
-uint32_t nbChan=previous->getInfo()->channels;
-#define AMP 4
-    _previous->rewind();
-    memcpy(&_param,param,sizeof(_param));
-//
-// The base is 100 ms
-//
-
-    mCircleSize=DRC_WINDOW;
-    mCircleSize=mCircleSize-(mCircleSize%nbChan);
-    drc_cleanup();
-    printf("[DRC] Created DRC:%u Window:%u nbChan %u\n",mCircleSize,DRC_WINDOW,nbChan);
-
-};
-void AUDMAudioFilterLimiter::drc_cleanup(void)
-{
-  float mCurRate=(float)_wavHeader.frequency;
-   
-  for(int j=0; j<mCircleSize; j++) {
-      mCircle[j] = 0.0;
-      mLevelCircle[j] = _param.mFloor;
-   }
-   mCirclePos = 0;
-   mRMSSum = 0.0;
-
-   mGainDB = ((_param.mThresholdDB*-0.7) * (1 - 1/_param.mRatio));
-   if (mGainDB < 0)
-      mGainDB = 0;
-
-   mThreshold = pow(10.0, _param.mThresholdDB/10); // factor of 10 because it's power
-
-   if (_param.mUseGain)
-      mGain = pow(10.0, mGainDB/20); // factor of 20 because it's amplitude
-   else
-      mGain = 1.0;
-
-   mAttackFactor = exp(-log(_param.mFloor) / (mCurRate * _param.mAttackTime + 0.5));
-   mDecayFactor = exp(log(_param.mFloor) / (mCurRate * _param.mDecayTime + 0.5));
-
-   mLastLevel = 0.0;
-   
-   memset(mCircle,0,sizeof(mCircle));
-   memset(follow,0,sizeof(follow));
-   memset(mLevelCircle,0,sizeof(mLevelCircle));
-    
-}
-//
-AUDMAudioFilterLimiter::~AUDMAudioFilterLimiter()
-{
-  printf("[DRC] Destroyed\n");
-}
-
-uint32_t   AUDMAudioFilterLimiter::fill(uint32_t max,float *output,AUD_Status *status)
-{
-  uint32_t len,i;
-  
-  shrink();
-  fillIncomingBuffer(status);
-  
-  
-  len=_tail-_head;
-  if(len>max) len=max;
-  if(len>=DELIM_WINDOW_SIZE) len=DELIM_WINDOW_SIZE-1;
-  
-  // Count in full sample  i.e. all channels
-  len=len-(len%_wavHeader.channels);
-  
-  // Process..
-  if (mLastLevel == 0.0) {
-    int preSeed = mCircleSize;
-    if (preSeed > len)
-      preSeed = len;
-    for(i=0; i<preSeed; i++)
-      AvgCircle(_incomingBuffer[_head+i]);
-  }
-  
-    for (i = 0; i < len; i++) {
-      Follow(_incomingBuffer[_head+i], &follow[i], i);
-    }
-
-    for (i = 0; i < len; i++) {
-      output[i] =DoCompression(_incomingBuffer[_head+i], follow[i]);
-    }  
-    _head+=len;
-    return len;
-}
-
-float AUDMAudioFilterLimiter::AvgCircle(float value)
-{
-  float level;
-
-   // Calculate current level from root-mean-squared of
-   // circular buffer ("RMS")
-   mRMSSum -= mCircle[mCirclePos];
-   mCircle[mCirclePos] = value*value;
-   mRMSSum += mCircle[mCirclePos];
-   level = sqrt(mRMSSum/mCircleSize);
-   mLevelCircle[mCirclePos] = level;
-   mCirclePos = (mCirclePos+1)%mCircleSize;  
-   return level;
-}
-
-void AUDMAudioFilterLimiter::Follow(float x, float *outEnv, int maxBack)
-{
-   /*
-
-   "Follow"ing algorithm by Roger B. Dannenberg, taken from
-   Nyquist.  His description follows.  -DMM
-
-   Description: this is a sophisticated envelope follower.
-    The input is an envelope, e.g. something produced with
-    the AVG function. The purpose of this function is to
-    generate a smooth envelope that is generally not less
-    than the input signal. In other words, we want to "ride"
-    the peaks of the signal with a smooth function. The 
-    algorithm is as follows: keep a current output value
-    (called the "value"). The value is allowed to increase
-    by at most rise_factor and decrease by at most fall_factor.
-    Therefore, the next value should be between
-    value * rise_factor and value * fall_factor. If the input
-    is in this range, then the next value is simply the input.
-    If the input is less than value * fall_factor, then the
-    next value is just value * fall_factor, which will be greater
-    than the input signal. If the input is greater than value *
-    rise_factor, then we compute a rising envelope that meets
-    the input value by working bacwards in time, changing the
-    previous values to input / rise_factor, input / rise_factor^2,
-    input / rise_factor^3, etc. until this new envelope intersects
-    the previously computed values. There is only a limited buffer
-    in which we can work backwards, so if the new envelope does not
-    intersect the old one, then make yet another pass, this time
-    from the oldest buffered value forward, increasing on each 
-    sample by rise_factor to produce a maximal envelope. This will 
-    still be less than the input.
-    
-    The value has a lower limit of floor to make sure value has a 
-    reasonable positive value from which to begin an attack.
-   */
-
-   float level = AvgCircle(x);
-   float high = mLastLevel * mAttackFactor;
-   float low = mLastLevel * mDecayFactor;
-
-   if (low < _param.mFloor)
-      low = _param.mFloor;
-
-   if (level < low)
-      *outEnv = low;
-   else if (level < high)
-      *outEnv = level;
-   else {
-      // Backtrack
-     float attackInverse = 1.0 / mAttackFactor;
-     float temp = level * attackInverse;
-
-      int backtrack = 50;
-      if (backtrack > maxBack)
-         backtrack = maxBack;
-
-      float *ptr = &outEnv[-1];
-      int i;
-      bool ok = false;
-      for(i=0; i<backtrack-2; i++) {
-         if (*ptr < temp) {
-            *ptr-- = temp;
-            temp *= attackInverse;
-         }
-         else {
-            ok = true;
-            break;
-         }   
-      }
-
-      if (!ok && backtrack>1 && (*ptr < temp)) {
-         temp = *ptr;
-         for (i = 0; i < backtrack-1; i++) {
-            ptr++;
-            temp *= mAttackFactor;
-            *ptr = temp;
-         }
-      }
-      else
-         *outEnv = level;
-   }
-
-   mLastLevel = *outEnv;
-}
-
-float AUDMAudioFilterLimiter::DoCompression(float value, float env)
-{
-   float mult;
-   float out;
-
-   if (env > mThreshold)
-      mult = mGain * pow(mThreshold/env, 1.0/_param.mRatio);
-   else
-      mult = mGain;
-
-   out = value * mult;
-
-   if (out > 1.0)
-      out = 1.0;
-
-   if (out < -1.0)
-      out = -1.0;
-
-   return out;
-}
-//EOF

Deleted: branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_normalize.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_normalize.cpp	2009-03-15 09:57:35 UTC (rev 4693)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_normalize.cpp	2009-03-15 14:50:00 UTC (rev 4694)
@@ -1,184 +0,0 @@
-/***************************************************************************
-                          audiofilter_normalize
-                             -------------------
-    
-    copyright            : (C) 2002/2006 by mean
-    email                : fixounet at free.fr
-    
-    Compute the ratio so that the maximum is at -3db
-    
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#include "config.h"
-#include <stdio.h>
-#include <stdlib.h>
-
-#include <math.h>
-
-#include "ADM_default.h"
-#include "ADM_audioFilter.h"
-#include "audiofilter_normalize_param.h"
-#include "audiofilter_normalize.h"
-#include "audiofilter_dolby.h"
-
-#include "ADM_audio/aviaudio.hxx"
-//#include "ADM_dialog/DIA_busy.h" //CANNOT USE IT! We are in another thread!
-
-extern AVDMGenericAudioStream *currentaudiostream;
-
-#ifdef __WIN32
-#define POW10(x)   pow(10,x)
-#elif defined(ADM_BSD_FAMILY)
-#define POW10(x) powf(10.0,x)
-#else
-#define POW10(x)  pow10f(x)
-#endif
-
-#define LINEAR_TO_DB(x) (20.*log10(x))
-#define DB_TO_LINEAR(x) (POW10((x/20.)))
-
-// Ctor
-//__________
-
-AUDMAudioFilterNormalize::AUDMAudioFilterNormalize(AUDMAudioFilter * instream,GAINparam *param):AUDMAudioFilter (instream)
-{
-  float db_out;
-    // nothing special here...
-  switch(param->mode)
-  {
-    case ADM_NO_GAIN: _ratio=1;_scanned=1;printf("[Gain] Gain of 1.0\n");break; 
-    case ADM_GAIN_AUTOMATIC: _ratio=1;_scanned=0;printf("[Gain] Automatic gain\n");break;
-    case ADM_GAIN_MANUAL: 
-                _scanned=1;
-                db_out =  param->gain10/10.0; // Dbout is in 10*DB (!)
-                _ratio = DB_TO_LINEAR(db_out);
-                printf("[Gain] %f db (p=%d)\n", (float)(param->gain10)/10.,param->gain10);
-                printf("[Gain] Linear ratio of : %03.3f\n", _ratio);
-  }
-    _previous->rewind();
-};
-
-AUDMAudioFilterNormalize::~AUDMAudioFilterNormalize()
-{
-
-}
-//
-// For normalize, we scan the input stream
-// to check for maximum value
-//___________________________________________
-uint8_t AUDMAudioFilterNormalize::preprocess(void)
-{
-
-    int16_t *ptr;
-    uint32_t scanned = 0, ch = 0;
-    AUD_Status status;
-    _ratio = 0;
-
-    uint32_t percent=0;
-    uint32_t current=0,llength=0;
-    float max[_wavHeader.channels];
-    _previous->rewind();
-    DolbySkip(1);
-    printf("\n Seeking for maximum value, that can take a while\n");
-
-    llength=_length ;
-    
-
-      for(int i=0;i<_wavHeader.channels;i++) max[i]=0;
-      while (1)
-      {
-          int ready=_previous->fill(AUD_PROCESS_BUFFER_SIZE>>2,_incomingBuffer,&status);
-          if(!ready)
-          {
-            if(status==AUD_END_OF_STREAM) 
-            {
-              break; 
-            }
-           else 
-            {
-              printf("Unknown cause : %d\n",status);
-              ADM_assert(0); 
-            }
-          }
-          ADM_assert(!(ready %_wavHeader.channels));
-          
-          int index=0;
-          float current;
-          
-        //  printf("*\n");
-          int sample= ready /_wavHeader.channels;
-          for(int j=0;j<sample;j++)
-            for(int chan=0;chan<_wavHeader.channels;chan++)
-          {
-            current=fabs(_incomingBuffer[index++]);
-            if(current>max[chan]) max[chan]=current;
-          }
-          scanned+=ready;
-      }
-      
-      
-      
-
-    _previous->rewind();
-    float mx=0;
-    for(int chan=0;chan<_wavHeader.channels;chan++)
-    {
-        if(max[chan]>mx) mx=max[chan];
-        printf("[Normalize] maximum found for channel %d : %f\n", chan,max[chan]);
-    }
-    printf("[Normalize] Using : %0.4f as max value \n", mx);
-    double db_in, db_out=-3;
-
-    if (mx>0.001)
-      db_in = LINEAR_TO_DB(mx);
-    else
-      db_in = -20; // We consider -20 DB to be noise
-
-    printf("--> %2.2f db / %2.2f \n", db_in, db_out);
-
-    // search ratio
-    _ratio=1;
-
-    float db_delta=db_out-db_in;
-    printf("[Normalize]Gain %f dB\n",db_delta);
-    _ratio = DB_TO_LINEAR(db_delta);
-    printf("\n Using ratio of : %f\n", _ratio);
-
-    _scanned = 1;
-    DolbySkip(0);
-    _previous->rewind();
-    return 1;
-}
-//
-//___________________________________________
-uint32_t AUDMAudioFilterNormalize::fill( uint32_t max, float * buffer,AUD_Status *status)
-{
-    uint32_t rd, i, j,rd2;
-
-    *status=AUD_OK;
-    if(!_scanned) preprocess();
-    rd = _previous->fill(max, _incomingBuffer,status);
-    if(!rd)
-    {
-      if(*status==AUD_END_OF_STREAM) return 0;
-      ADM_assert(0);
-    }
-    float *in,*out,tmp;
-    for (i = 0; i < rd; i++)
-    {
-      tmp=_incomingBuffer[i];
-      tmp*=_ratio;
-      buffer[i]=tmp;
-    }
-    return rd;
-};
-//EOF
-



From mean at mail.berlios.de  Sun Mar 15 15:50:03 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sun, 15 Mar 2009 15:50:03 +0100
Subject: [Avidemux-svn-commit] r4695 - in
	branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers: Flv
	Matroska Mp4
Message-ID: <200903151450.n2FEo3Mb027085@sheep.berlios.de>

Author: mean
Date: 2009-03-15 15:50:03 +0100 (Sun, 15 Mar 2009)
New Revision: 4695

Modified:
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/Flv/ADM_flv.cpp
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/Matroska/ADM_mkv.cpp
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/Mp4/ADM_mp4.cpp
Log:
[PLugins demuxer] more set/Get api

Modified: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/Flv/ADM_flv.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/Flv/ADM_flv.cpp	2009-03-15 14:50:00 UTC (rev 4694)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/Flv/ADM_flv.cpp	2009-03-15 14:50:03 UTC (rev 4695)
@@ -682,6 +682,42 @@
   *size = videoTrack->_index[frame].size;
   return 1;
 }
+//!!
 
+/**
+    \fn getPtsDts
+*/
+bool    flvHeader::getPtsDts(uint32_t frame,uint64_t *pts,uint64_t *dts)
+{
 
+    if(frame>=videoTrack->_nbIndex)
+    {
+      printf("[MKV] Frame %"LU" exceeds # of frames %"LU"\n",frame,videoTrack->_nbIndex);
+      return 0;
+    }
+
+     flvIndex *idx=&(videoTrack->_index[frame]);
+    
+    *dts=idx->timeCodeUs; // FIXME
+    *pts=idx->timeCodeUs;
+    return true;
+}
+/**
+        \fn setPtsDts
+*/
+bool    flvHeader::setPtsDts(uint32_t frame,uint64_t pts,uint64_t dts)
+{
+    if(frame>=videoTrack->_nbIndex)
+    {
+      printf("[MKV] Frame %"LU" exceeds # of frames %"LU"\n",frame,videoTrack->_nbIndex);
+      return 0;
+    }
+
+     flvIndex *idx=&(videoTrack->_index[frame]);
+    
+    idx->timeCodeUs=dts; // FIXME
+    //*pts=idx->timeCodeUs; // FIXME PTS=DTS ??
+    return true;
+}
+
 //EOF

Modified: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/Matroska/ADM_mkv.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/Matroska/ADM_mkv.cpp	2009-03-15 14:50:00 UTC (rev 4694)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/Matroska/ADM_mkv.cpp	2009-03-15 14:50:03 UTC (rev 4695)
@@ -495,5 +495,45 @@
   return 0;
 
 }
+
+
+/**
+    \fn getPtsDts
+*/
+bool    mkvHeader::getPtsDts(uint32_t frame,uint64_t *pts,uint64_t *dts)
+{
+     ADM_assert(_parser);
+     if(frame>=_tracks[0]._nbIndex) 
+     {
+            printf("[MKV] Frame %"LU" exceeds # of frames %"LU"\n",frame,_tracks[0]._nbIndex);
+            return false;
+     }
+    mkvIndex *dx=&(_tracks[0]._index[frame]);
+    
+    *dts=dx->Dts; // FIXME
+    *pts=dx->Pts;
+    return true;
+}
+/**
+        \fn setPtsDts
+*/
+bool    mkvHeader::setPtsDts(uint32_t frame,uint64_t pts,uint64_t dts)
+{
+      ADM_assert(_parser);
+     if(frame>=_tracks[0]._nbIndex) 
+     {
+            printf("[MKV] Frame %"LU" exceeds # of frames %"LU"\n",frame,_tracks[0]._nbIndex);
+            return false;
+     }
+    mkvIndex *dx=&(_tracks[0]._index[frame]);
+    
+    dx->Dts=dts; // FIXME
+    dx->Pts=pts;
+    
+
+}
+
+
+
 //****************************************
 //EOF

Modified: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/Mp4/ADM_mp4.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/Mp4/ADM_mp4.cpp	2009-03-15 14:50:00 UTC (rev 4694)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/Mp4/ADM_mp4.cpp	2009-03-15 14:50:03 UTC (rev 4695)
@@ -414,4 +414,40 @@
     return _currentAudioTrack;
 }
 
+/**
+    \fn getPtsDts
+*/
+bool    MP4Header::getPtsDts(uint32_t frame,uint64_t *pts,uint64_t *dts)
+{
+
+    if(frame>=VDEO.nbIndex)
+    {
+      printf("[MKV] Frame %"LU" exceeds # of frames %"LU"\n",frame,VDEO.nbIndex);
+      return 0;
+    }
+
+    MP4Index *idx=&(VDEO.index[frame]);
+    
+    *dts=idx->dts; // FIXME
+    *pts=idx->pts;
+    return true;
+}
+/**
+        \fn setPtsDts
+*/
+bool    MP4Header::setPtsDts(uint32_t frame,uint64_t pts,uint64_t dts)
+{
+    if(frame>=VDEO.nbIndex)
+    {
+      printf("[MKV] Frame %"LU" exceeds # of frames %"LU"\n",frame,VDEO.nbIndex);
+      return 0;
+    }
+
+    MP4Index *idx=&(VDEO.index[frame]);
+
+    idx->dts=dts; // FIXME
+    idx->pts=pts;
+    return true;
+}
+
 //EOF



From mean at mail.berlios.de  Sun Mar 15 15:50:05 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sun, 15 Mar 2009 15:50:05 +0100
Subject: [Avidemux-svn-commit] r4696 -
	branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/Matroska
Message-ID: <200903151450.n2FEo5j7027096@sheep.berlios.de>

Author: mean
Date: 2009-03-15 15:50:04 +0100 (Sun, 15 Mar 2009)
New Revision: 4696

Modified:
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/Matroska/ADM_mkv.cpp
Log:
[MkvDemuxer] Cosmetic

Modified: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/Matroska/ADM_mkv.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/Matroska/ADM_mkv.cpp	2009-03-15 14:50:03 UTC (rev 4695)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/Matroska/ADM_mkv.cpp	2009-03-15 14:50:04 UTC (rev 4696)
@@ -15,15 +15,12 @@
 
 #include "ADM_default.h"
 #include "ADM_Video.h"
-
-#include "fourcc.h"
-
-
 #include "ADM_mkv.h"
-
 #include "mkv_tags.h"
-/*
-    __________________________________________________________
+/**
+    \fn open
+    \brief Try to open the mkv file given as parameter
+    
 */
 
 uint8_t mkvHeader::open(const char *name)
@@ -289,8 +286,9 @@
     }
 
 }
-/*
-    __________________________________________________________
+/**
+    \fn mkvHeader
+    \brief constructor
 */
 
  mkvHeader::mkvHeader( void ) : vidHeader()
@@ -308,33 +306,31 @@
   _access=NULL;
   _audioStreams=NULL;
 }
-/*
-    __________________________________________________________
+/**
+    \fn ~mkvHeader
+    \brief constructor
 */
-
  mkvHeader::~mkvHeader(  )
 {
   close();
 }
 
-/*
-    __________________________________________________________
+/**
+    \fn setFlag
+    \brief setFlag
 */
 
-/*
-    __________________________________________________________
-*/
-
   uint8_t  mkvHeader::setFlag(uint32_t frame,uint32_t flags)
 {
   if(frame>=_tracks[0]._nbIndex) return 0;
   _tracks[0]._index[frame].flags=flags;
   return 1;
 }
-/*
-    __________________________________________________________
-*/
 
+/**
+    \fn getFlags
+    \brief getFlags
+*/
 uint32_t mkvHeader::getFlags(uint32_t frame,uint32_t *flags)
 {
   if(frame>=_tracks[0]._nbIndex) return 0;



From mean at mail.berlios.de  Thu Mar 19 18:02:25 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Thu, 19 Mar 2009 18:02:25 +0100
Subject: [Avidemux-svn-commit] r4698 - in
	branches/avidemux_2.6_branch_mean/avidemux: ADM_audiofilter
	ADM_coreAudioEncoder/include ADM_coreAudioEncoder/src
Message-ID: <200903191702.n2JH2PYh006326@sheep.berlios.de>

Author: mean
Date: 2009-03-19 18:02:23 +0100 (Thu, 19 Mar 2009)
New Revision: 4698

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audioEncoderApi.h
   branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audio_encoderWrapper.cpp
   branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audio_encoderWrapper.h
   branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_buildchain.cpp
   branches/avidemux_2.6_branch_mean/avidemux/ADM_coreAudioEncoder/include/audioencoder.h
   branches/avidemux_2.6_branch_mean/avidemux/ADM_coreAudioEncoder/src/audioencoder.cpp
Log:
[audio] Disable old audio encode API

Modified: branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audioEncoderApi.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audioEncoderApi.h	2009-03-19 16:57:47 UTC (rev 4697)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audioEncoderApi.h	2009-03-19 17:02:23 UTC (rev 4698)
@@ -15,7 +15,7 @@
 /// Directly set the codec, *only to be used
 uint8_t audioCodecSetByIndex(int i);
 /// Spawn a new encoder
-AUDMEncoder *audioEncoderCreate(AUDMAudioFilter *filter);
+ADM_AudioEncoder *audioEncoderCreate(AUDMAudioFilter *filter);
 /// Select a encoder by its name e.g. "lame", used only by JS. Update UI as well
 uint8_t audioCodecSetByName( const char *name);
 /// Returns the name of the currently selected codec

Modified: branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audio_encoderWrapper.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audio_encoderWrapper.cpp	2009-03-19 16:57:47 UTC (rev 4697)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audio_encoderWrapper.cpp	2009-03-19 17:02:23 UTC (rev 4698)
@@ -10,7 +10,7 @@
 #include "audioencoder.h"
 
 #include "audio_encoderWrapper.h"
-
+#if 0
 /**
     \fn ADM_audioEncoderWrapper
     \brief Constructor to wrap an encoder inside ADMgenericblah blah
@@ -81,6 +81,6 @@
     return _encoder->extraData(l,d);
 
 }
-
+#endif
 //EOF
 

Modified: branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audio_encoderWrapper.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audio_encoderWrapper.h	2009-03-19 16:57:47 UTC (rev 4697)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audio_encoderWrapper.h	2009-03-19 17:02:23 UTC (rev 4698)
@@ -6,6 +6,7 @@
 #ifndef audio_encoderWrapper_H
 #define audio_encoderWrapper_H
 #include "ADM_audioStream.h"
+#if 0
 class ADM_audioEncoderWrapper :  public ADM_audioStream
 {
 protected:
@@ -23,5 +24,5 @@
 };
 
 #endif
-
+#endif
 //EOF

Modified: branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_buildchain.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_buildchain.cpp	2009-03-19 16:57:47 UTC (rev 4697)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_buildchain.cpp	2009-03-19 17:02:23 UTC (rev 4698)
@@ -261,6 +261,7 @@
 
 ADM_audioStream *buildAudioFilter(ADM_audioStream *currentaudiostream,  uint32_t starttime)
 {
+#if 0
   AUDMAudioFilter         *lastFilter=NULL;
   ADM_audioStream         *output=NULL;
   AUDMEncoder             *tmpfilter=NULL;
@@ -310,6 +311,7 @@
 
   ADM_assert(output);
   return output;
+#endif
 }
 
 

Modified: branches/avidemux_2.6_branch_mean/avidemux/ADM_coreAudioEncoder/include/audioencoder.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_coreAudioEncoder/include/audioencoder.h	2009-03-19 16:57:47 UTC (rev 4697)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_coreAudioEncoder/include/audioencoder.h	2009-03-19 17:02:23 UTC (rev 4698)
@@ -17,68 +17,52 @@
 */
 #include "ADM_coreAudio.h"
 #include "ADM_audioCodecEnum.h"
+#include "ADM_audioFilter.h" 
 
-
 #define AUDIOENC_COPY 0
 
-class AUDMEncoder;
-class AUDMAudioFilter;
+//class AUDMAudioFilter;
 
 typedef int AUDIOENCODER;
 
-/*!
-  Base class for all audio encoder.It does the reverse of the bridge class and offers a proper GenericAudioStreamAPI
+/**
+    \class AUDMEncoder
+    \brief audio encoder base class. Combined with the audioaccess class it makes the exact opposite
+            of the bridge class, i.e. convert audioFilter to ADM_access then ADM_stream.
 
 */
-// // FIXME!!!!
-#include "ADM_audioFilter.h" // FIXME!!!
- //_____________________________________________
-class AUDMEncoder //: public AVDMGenericAudioStream
+#define ADM_AUDIO_ENCODER_BUFFER_SIZE (6*32*1024)
+class ADM_AudioEncoder 
 {
   protected:
-    
+
+    bool            eof_met;    // True if cannot encode anymore
     //
-    uint32_t grab(uint8_t *outbuffer);
-    uint32_t grab(float *outbuffer) {ADM_assert(0);return 1;}
-    uint32_t  eof_met;
-    uint32_t  _chunk;
-    //
     uint8_t         *_extraData;
     uint32_t        _extraSize;
     AUDMAudioFilter *_incoming;
     uint8_t         cleanup(void);
     
-    float          *tmpbuffer;
-    uint8_t        refillBuffer(int minimum); // Mininum is in float
+    float           tmpbuffer[ADM_AUDIO_ENCODER_BUFFER_SIZE*2];  // incoming samples are stored here before encofing
+    uint32_t        tmphead,tmptail;
 
+    bool            refillBuffer(int minimum); // Mininum is in float
     
-    void reorderChannels(float *data, uint32_t nb,CHANNEL_TYPE *input,CHANNEL_TYPE *output);
+    void            reorderChannels(float *data, uint32_t nb,CHANNEL_TYPE *input,CHANNEL_TYPE *output);
 
-    uint32_t       tmphead,tmptail;
+    
     // The encoder can remap the audio channel (or not). If so, let's store the the configuration here
-    CHANNEL_TYPE outputChannelMapping[MAX_CHANNELS];
+    CHANNEL_TYPE    outputChannelMapping[MAX_CHANNELS];
+    WAVHeader       wavheader; 
   public:
     //
-    WAVHeader       *_wavheader;
-    //
-    uint32_t read(uint32_t len,uint8_t *buffer);
-    uint32_t read(uint32_t len,float *buffer) {ADM_assert(0);return 1;}
-    //
-    virtual ~AUDMEncoder();
-    AUDMEncoder(AUDMAudioFilter *in);	
 
-    virtual uint8_t initialize(void)=0;
-    virtual uint8_t getPacket(uint8_t *dest, uint32_t *len, uint32_t *samples)=0;
-    virtual uint8_t packetPerFrame( void) {return 1;}
     virtual uint8_t extraData(uint32_t *l,uint8_t **d) {*l=_extraSize;*d=_extraData;return 1;}
-            uint8_t  goTo(uint32_t timeMS) {ADM_assert(0);return 1;}
-};
-// Used by some old code (lame/twolame) OBSOLETE   / DO NOT USE
-typedef enum  
-{
-   	ADM_STEREO=1,
-   	ADM_JSTEREO,
-   	ADM_MONO
-} ADM_mode;
+    WAVHeader       *getInfo(void) {return &wavheader;}
 
+                    ADM_AudioEncoder(AUDMAudioFilter *in);	
+                    virtual ~ADM_AudioEncoder();
+    virtual bool    initialize(void)=0; /// Returns true if init ok, false if encoding is impossible
+    virtual bool    encode(uint8_t *dest, uint32_t *len, uint32_t *samples)=0; /// returns false if eof met
+};
 #endif

Modified: branches/avidemux_2.6_branch_mean/avidemux/ADM_coreAudioEncoder/src/audioencoder.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_coreAudioEncoder/src/audioencoder.cpp	2009-03-19 16:57:47 UTC (rev 4697)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_coreAudioEncoder/src/audioencoder.cpp	2009-03-19 17:02:23 UTC (rev 4698)
@@ -18,6 +18,7 @@
 #include "ADM_audioFilter.h"
 #include "audioencoder.h"
 #include "ADM_audioCodecEnum.h"
+#if 0
 AUDMEncoder::AUDMEncoder(AUDMAudioFilter *in) // :AVDMGenericAudioStream  ()
 {
   _wavheader = new WAVHeader;
@@ -142,5 +143,5 @@
     return len;
   return MINUS_ONE;
 }
-
+#endif
 //EOF



From mean at mail.berlios.de  Thu Mar 19 18:02:29 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Thu, 19 Mar 2009 18:02:29 +0100
Subject: [Avidemux-svn-commit] r4699 - in
	branches/avidemux_2.6_branch_mean/avidemux:
	ADM_coreAudioEncoder/include ADM_coreAudioEncoder/src ADM_toolkit
Message-ID: <200903191702.n2JH2TpE006336@sheep.berlios.de>

Author: mean
Date: 2009-03-19 18:02:27 +0100 (Thu, 19 Mar 2009)
New Revision: 4699

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/ADM_coreAudioEncoder/include/audioencoder.h
   branches/avidemux_2.6_branch_mean/avidemux/ADM_coreAudioEncoder/src/audioencoder.cpp
   branches/avidemux_2.6_branch_mean/avidemux/ADM_toolkit/automation.cpp
Log:
[Audio] New audio encoder external api

Modified: branches/avidemux_2.6_branch_mean/avidemux/ADM_coreAudioEncoder/include/audioencoder.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_coreAudioEncoder/include/audioencoder.h	2009-03-19 17:02:23 UTC (rev 4698)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_coreAudioEncoder/include/audioencoder.h	2009-03-19 17:02:27 UTC (rev 4699)
@@ -1,5 +1,7 @@
 /***************************************************************************
-    copyright            : (C) 2006 by mean
+  \file audioencoder.cpp
+
+    copyright            : (C) 2002-6 by mean/gruntster/Mihail 
     email                : fixounet at free.fr
  ***************************************************************************/
 
@@ -21,7 +23,6 @@
 
 #define AUDIOENC_COPY 0
 
-//class AUDMAudioFilter;
 
 typedef int AUDIOENCODER;
 
@@ -41,19 +42,19 @@
     uint8_t         *_extraData;
     uint32_t        _extraSize;
     AUDMAudioFilter *_incoming;
-    uint8_t         cleanup(void);
+
     
     float           tmpbuffer[ADM_AUDIO_ENCODER_BUFFER_SIZE*2];  // incoming samples are stored here before encofing
     uint32_t        tmphead,tmptail;
 
     bool            refillBuffer(int minimum); // Mininum is in float
     
-    void            reorderChannels(float *data, uint32_t nb,CHANNEL_TYPE *input,CHANNEL_TYPE *output);
+    bool            reorderChannels(float *data, uint32_t nb,CHANNEL_TYPE *input,CHANNEL_TYPE *output);
 
     
     // The encoder can remap the audio channel (or not). If so, let's store the the configuration here
     CHANNEL_TYPE    outputChannelMapping[MAX_CHANNELS];
-    WAVHeader       wavheader; 
+    WAVHeader       wavheader;  /// To be filled by the encoder, especially byterate and codec Id.
   public:
     //
 
@@ -62,6 +63,8 @@
 
                     ADM_AudioEncoder(AUDMAudioFilter *in);	
                     virtual ~ADM_AudioEncoder();
+
+
     virtual bool    initialize(void)=0; /// Returns true if init ok, false if encoding is impossible
     virtual bool    encode(uint8_t *dest, uint32_t *len, uint32_t *samples)=0; /// returns false if eof met
 };

Modified: branches/avidemux_2.6_branch_mean/avidemux/ADM_coreAudioEncoder/src/audioencoder.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_coreAudioEncoder/src/audioencoder.cpp	2009-03-19 17:02:23 UTC (rev 4698)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_coreAudioEncoder/src/audioencoder.cpp	2009-03-19 17:02:27 UTC (rev 4699)
@@ -1,6 +1,7 @@
- 
 /***************************************************************************
-    copyright            : (C) 2002-6 by mean
+    \file audioencoder.cpp
+
+    copyright            : (C) 2002-6 by mean/gruntster/Mihail 
     email                : fixounet at free.fr
  ***************************************************************************/
 
@@ -18,50 +19,43 @@
 #include "ADM_audioFilter.h"
 #include "audioencoder.h"
 #include "ADM_audioCodecEnum.h"
-#if 0
-AUDMEncoder::AUDMEncoder(AUDMAudioFilter *in) // :AVDMGenericAudioStream  ()
+/**
+
+*/
+ADM_AudioEncoder::ADM_AudioEncoder(AUDMAudioFilter *in)
 {
-  _wavheader = new WAVHeader;
-  _incoming=in;
-  memcpy(_wavheader, _incoming->getInfo(), sizeof(WAVHeader));
-  _wavheader->encoding=WAV_AAC;
-  _incoming->rewind();	// rewind
-  _extraData=NULL;
-  _extraSize=0;
-  tmpbuffer=new float[_wavheader->frequency*_wavheader->channels];
-  tmphead=tmptail=0;
-  eof_met=0;
-  
-};
-/********************/
-AUDMEncoder::~AUDMEncoder()
-{
-  cleanup();
-};
-/********************/
-uint8_t AUDMEncoder::cleanup(void)
-{
-  if(_wavheader) delete(_wavheader);
-  _wavheader=NULL;
+    _extraData=NULL;
+    _extraSize=0;
+    ADM_assert(in);
+    eof_met=false;
+    _incoming=in;
+    memset(&wavheader,0,sizeof(wavheader));
+    tmphead=tmptail=0;
+}
+/**
 
-  if(_extraData) delete [] _extraData;
-  _extraData=NULL;
-  
-  if(tmpbuffer) delete [] tmpbuffer;
-  tmpbuffer=NULL;
-};
-/********************/
-
-uint8_t AUDMEncoder::refillBuffer(int minimum)
+*/
+ADM_AudioEncoder::~ADM_AudioEncoder()
 {
-  uint32_t filler=_wavheader->frequency*_wavheader->channels;
+    if(_extraData)
+    {
+        delete [] _extraData;
+        _extraData=NULL;
+    }
+}
+/**
+    \fn refillBuffer
+*/
+bool  ADM_AudioEncoder::refillBuffer(int minimum)
+{
+    uint32_t filler=wavheader.frequency*wavheader.channels;
   uint32_t nb;
   AUD_Status status;
   if(eof_met) return 0;
   while(1)
   {
-    ADM_assert(tmptail>=tmphead);
-    if((tmptail-tmphead)>=minimum) return 1;
+    ADM_assert(tmptail>=tmphead); 
+    if((tmptail-tmphead)>=minimum) return true; // already enough data
   
     if(tmphead && tmptail>filler/2)
     {
@@ -80,35 +74,36 @@
         memset(&tmpbuffer[tmptail],0,sizeof(float)*(minimum-(tmptail-tmphead)));
         tmptail=tmphead+minimum;
         eof_met=1;  
-        return minimum;
+        return true;
       }
       else continue;
     } else
       tmptail+=nb;
   }
+    return true;
 }
-
-
 /**
- * 	\fn reorderChannels
- *  \brief Reorder the channels
- */
-void AUDMEncoder::reorderChannels(float *data, uint32_t nb,CHANNEL_TYPE *input,CHANNEL_TYPE *output)
+        \fn reorderChannels
+*/
+bool   ADM_AudioEncoder::reorderChannels(float *data, uint32_t nb,CHANNEL_TYPE *input,CHANNEL_TYPE *output)
 {
-	float tmp [_wavheader->channels];
+int channels=wavheader.channels;
+
+    float tmp [channels];
 	static uint8_t reorder[MAX_CHANNELS];
 	static bool reorder_on;
 	
 	
 		reorder_on = 0;
 		int j = 0;
+        
 		// Should we reorder the channels (might be needed for encoder ?
-		if (_wavheader->channels > 2) 
+		if (channels > 2) 
 		{
 			CHANNEL_TYPE *p_ch_type;
-			for (int i = 0; i < _wavheader->channels; i++) 
+			for (int i = 0; i < channels; i++) 
 			{
-				for (int c = 0; c < _wavheader->channels; c++) 
+				for (int c = 0; c < channels; c++) 
 				{
 					if (input[c] == output[i]) 
 					{
@@ -122,26 +117,14 @@
 	
 
 	if (reorder_on)
-		for (int i = 0; i < nb; i++) {
+		for (int i = 0; i < nb; i++) 
+        {
 			memcpy(tmp, data, sizeof(tmp));
-			for (int c = 0; c < _wavheader->channels; c++)
+			for (int c = 0; c < channels; c++)
 				*data++ = tmp[reorder[c]];
 		}
 
+    return true;
 }
 
-uint32_t AUDMEncoder::read(uint32_t len,uint8_t *buffer)
-{
-  ADM_assert(0);
-  return 0; 
-}
-
-uint32_t AUDMEncoder::grab(uint8_t * obuffer)
-{
-  uint32_t len,sam;
-  if(getPacket(obuffer,&len,&sam))
-    return len;
-  return MINUS_ONE;
-}
-#endif
 //EOF

Modified: branches/avidemux_2.6_branch_mean/avidemux/ADM_toolkit/automation.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_toolkit/automation.cpp	2009-03-19 17:02:23 UTC (rev 4698)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_toolkit/automation.cpp	2009-03-19 17:02:27 UTC (rev 4699)
@@ -675,7 +675,7 @@
 
                 }
         }
-        printf("Warning: var [%s] is unknown !\n");
+        printf("Warning: var [%s] is unknown !\n",in);
         return NULL;
 
 }



From mean at mail.berlios.de  Sat Mar 21 15:55:58 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sat, 21 Mar 2009 15:55:58 +0100
Subject: [Avidemux-svn-commit] r4700 - in branches/avidemux_2.6_branch_mean:
	avidemux/ADM_audioFilter/include avidemux/ADM_audioFilter/src
	avidemux/ADM_audiofilter avidemux/ADM_coreAudioEncoder/include
	avidemux/ADM_coreAudioEncoder/src cmake
	plugins/ADM_audioEncoders plugins/ADM_audioEncoders/lame
Message-ID: <200903211455.n2LEtw0Q003453@sheep.berlios.de>

Author: mean
Date: 2009-03-21 15:55:57 +0100 (Sat, 21 Mar 2009)
New Revision: 4700

Added:
   branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/include/audio_encoderPlugin.h
   branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/src/audio_encoderPlugin.cpp
Removed:
   branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audio_encoderPlugin.cpp
   branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audio_encoderPlugin.h
Modified:
   branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/src/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/avidemux/ADM_coreAudioEncoder/include/audioencoder.h
   branches/avidemux_2.6_branch_mean/avidemux/ADM_coreAudioEncoder/include/audioencoderInternal.h
   branches/avidemux_2.6_branch_mean/avidemux/ADM_coreAudioEncoder/src/audioencoder.cpp
   branches/avidemux_2.6_branch_mean/cmake/ae_plugin.cmake
   branches/avidemux_2.6_branch_mean/plugins/ADM_audioEncoders/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/plugins/ADM_audioEncoders/lame/audioencoder_lame.cpp
   branches/avidemux_2.6_branch_mean/plugins/ADM_audioEncoders/lame/audioencoder_lame.h
   branches/avidemux_2.6_branch_mean/plugins/ADM_audioEncoders/lame/audioencoder_lame_param.h
Log:
[Audio] Lame encoder

Copied: branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/include/audio_encoderPlugin.h (from rev 4699, branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audio_encoderPlugin.h)
===================================================================

Modified: branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/src/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/src/CMakeLists.txt	2009-03-19 17:02:27 UTC (rev 4699)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/src/CMakeLists.txt	2009-03-21 14:55:57 UTC (rev 4700)
@@ -8,6 +8,7 @@
 audiofilter_limiter.cpp
 audiofilter_normalize.cpp
 audiofilter_SRC.cpp
+audio_encoderPlugin.cpp
 ADM_audioResample.cpp
 audiofilter.cpp
 ADM_libsamplerate/samplerate.c  

Copied: branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/src/audio_encoderPlugin.cpp (from rev 4699, branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audio_encoderPlugin.cpp)
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audio_encoderPlugin.cpp	2009-03-19 17:02:27 UTC (rev 4699)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/src/audio_encoderPlugin.cpp	2009-03-21 14:55:57 UTC (rev 4700)
@@ -0,0 +1,430 @@
+/***************************************************************************
+                          audio_encoderPlugin.cpp  -  description
+                             -------------------
+    
+    copyright            : (C) 2008 by mean
+    email                : fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include <vector>
+#include "ADM_default.h"
+#include "audioencoderInternal.h"
+#include "ADM_dynamicLoading.h"
+std::vector <ADM_audioEncoder *> ListOfAudioEncoder;
+
+static AUDIOENCODER  currentEncoder=0; //0 is always dummy
+
+static AUDIOENCODER ADM_encoderByName(const char *name);
+static const char *ADM_audioEncoderById(AUDIOENCODER id);
+
+/**
+    \class ADM_AudioEncoderLoader
+    \brief Helper class to load plugins
+*/
+class ADM_AudioEncoderLoader :public ADM_LibWrapper
+{
+
+public:
+        int                 initialised;
+        ADM_audioEncoder    *encoderBlock;
+        
+
+
+        ADM_AudioEncoderLoader(const char *file) : ADM_LibWrapper()
+		{
+                ADM_audioEncoder    *e;
+                ADM_audioEncoder *(*getInfo)(void);
+                initialised = loadLibrary(file) && getSymbols(1,
+				&getInfo, "getInfo"
+                );
+                encoderBlock=NULL;
+                if(initialised)
+                {
+                    e=getInfo();
+                    if(e->apiVersion!=ADM_AUDIO_ENCODER_API_VERSION)
+                    {
+                        e=NULL;
+                        initialised=0;
+                    }else
+                    {
+                        printf("[AudioEncoder] Loaded %s version %02d.%02d.%02d wavTag :0x%x\n",e->codecName,
+                                e->major,e->minor,e->patch,e->wavTag);
+                        encoderBlock=new ADM_audioEncoder;
+                        *encoderBlock=*e;
+                        encoderBlock->opaque=(void *)this;
+                    } 
+                }else
+                {
+                    printf("Symbol loading failed for %s\n",file);
+                }
+		}
+        ADM_AudioEncoderLoader(const char *name, const char *menuName) : ADM_LibWrapper()
+		{
+                    encoderBlock=new ADM_audioEncoder;
+                    encoderBlock->codecName=name;
+                    encoderBlock->menuName=menuName;                    
+                    encoderBlock->opaque=(void *)this;
+		}
+        ~ADM_AudioEncoderLoader()
+        {
+            if(encoderBlock) delete encoderBlock;
+            encoderBlock=NULL;
+            
+        }
+};
+
+/**
+        \fn ADM_ae_getPluginNbEncoders
+        \brief Returns the number of av filter plugins except one
+*/
+uint32_t ADM_ae_getPluginNbEncoders(void)
+{
+    return ListOfAudioEncoder.size()-1;
+}
+/**
+    \fn     ADM_ae_getAPluginEncoderInfo
+    \brief  Get Infos about the encoder #th plugin (plugin display)
+*/
+bool     ADM_ae_getAPluginEncoderInfo(int filter, const char **name, uint32_t *major,uint32_t *minor,uint32_t *patch)
+{
+    filter++;
+    ADM_assert(filter<ListOfAudioEncoder.size());
+    *major=ListOfAudioEncoder[filter]->major;
+    *minor=ListOfAudioEncoder[filter]->minor;
+    *patch=ListOfAudioEncoder[filter]->patch;
+    *name=ListOfAudioEncoder[filter]->description;
+    return true;
+}
+/**
+    \fn tryLoadingFilterPlugin
+    \brief Try loading the file given as argument as an audio device plugin
+
+*/
+#define Fail(x) {printf("%s:"#x"\n",file);goto er;}
+static bool tryLoadingFilterPlugin(const char *file)
+{
+	ADM_AudioEncoderLoader *dll=new ADM_AudioEncoderLoader(file);
+    if(!dll->initialised) Fail(CannotLoad);
+    
+
+    ListOfAudioEncoder.push_back(dll->encoderBlock); // Needed for cleanup. FIXME TODO Delete it.
+    printf("[AudioEncoder] Registered filter %s as  %s\n",file,dll->encoderBlock->description);
+    return true;
+	// Fail!
+er:
+	delete dll;
+	return false;
+
+}
+/**
+ * 	\fn ADM_ae_loadPlugins
+ *  \brief load all audio encoder plugins
+ */
+uint8_t ADM_ae_loadPlugins(const char *path)
+{
+#define MAX_EXTERNAL_FILTER 100
+// FIXME Factorize
+
+	char *files[MAX_EXTERNAL_FILTER];
+	uint32_t nbFile;
+    // Add the copy encoder
+    ADM_AudioEncoderLoader *copy=new ADM_AudioEncoderLoader("copy","Copy");
+    ListOfAudioEncoder.push_back(copy->encoderBlock);
+    //
+	memset(files,0,sizeof(char *)*MAX_EXTERNAL_FILTER);
+	printf("[ADM_ae_plugin] Scanning directory %s\n",path);
+
+	if(!buildDirectoryContent(&nbFile, path, files, MAX_EXTERNAL_FILTER, SHARED_LIB_EXT))
+	{
+		printf("[ADM_ae_plugin] Cannot parse plugin\n");
+		return 0;
+	}
+
+	for(int i=0;i<nbFile;i++)
+		tryLoadingFilterPlugin(files[i]);
+
+	printf("[ADM_ae_plugin] Scanning done\n");
+
+	return 1;
+}
+/**
+    \fn audioPrintCurrentCodec
+    \brief updates the UI with the current selected audio encoder
+*/
+void UI_setAudioCodec( int i);
+void audioPrintCurrentCodec(void)
+{
+			UI_setAudioCodec(currentEncoder);
+}
+
+/**
+    \fn ADM_encoderByName
+    \brief Returns the Id of the given string 
+
+*/
+AUDIOENCODER ADM_encoderByName(const char *name)
+{
+	if(!name) return (AUDIOENCODER)0;
+    if(!strcasecmp(name,"copy")) return (AUDIOENCODER)0; // copy
+	for(uint32_t i=1;i<ListOfAudioEncoder.size();i++)
+	{
+		if(!strcasecmp(name,ListOfAudioEncoder[i]->codecName))
+		{
+			return i;
+		}	
+	}
+	printf("[AudioEncoder] Encoder not found :%s\n",name);
+	return (AUDIOENCODER)0;
+
+}
+/**
+    \fn    ADM_audioEncoderById
+    \brief Returns the name of a device from its Id
+*/
+static const char *ADM_audioEncoderById(AUDIOENCODER id)
+{
+
+	ADM_assert(id<ListOfAudioEncoder.size());
+    return ListOfAudioEncoder[id]->codecName;
+}
+/**
+    \fn AVDM_getCurrentAudioEncoder
+    \brief
+*/
+AUDIOENCODER AVDM_getCurrentAudioEncoder( void)
+{
+	return currentEncoder;
+}
+/**
+    \fn audioCodecSelect
+    \brief Update UI
+*/
+uint8_t DIA_audioCodec( int *codec );
+void audioCodecSelect( void )
+{
+#warning FIXME 
+#warning FIXME 
+#warning FIXME 
+	//DIA_audioCodec( &currentEncoder );
+	audioPrintCurrentCodec();
+}
+/**
+    \fn     audioCodecSetByName
+    \brief  only called by JS, we have to update UI as well
+*/
+uint8_t audioCodecSetByName( const char *name)
+{
+		for(uint32_t i=0;i<ListOfAudioEncoder.size();i++)
+		{
+			if(!strcasecmp(name,ListOfAudioEncoder[i]->codecName))
+			{
+
+				currentEncoder=i;
+                audioPrintCurrentCodec(); // Update UI
+				return 1;
+			}
+
+		}
+		printf("\n Mmmm Select audio codec by name failed...(%s).\n",name);
+		return 0;
+}
+/**
+    \fn audioCodecSetByIndex
+    \brief To be used by UI code only!
+*/
+uint8_t audioCodecSetByIndex(int i)
+{
+    ADM_assert(i<ListOfAudioEncoder.size());
+    currentEncoder=i;
+    printf("[AudioEncoder] Selected %s for index %d, tag 0x%x \n",ListOfAudioEncoder[currentEncoder]->codecName,i,ListOfAudioEncoder[currentEncoder]->wavTag);
+    return 1;
+
+}
+/**
+    \fn audioCodecGetName
+    \brief Returns the current codec tagname
+*/
+const char *audioCodecGetName( void )
+{
+	  ADM_assert(currentEncoder<ListOfAudioEncoder.size());
+      return ListOfAudioEncoder[currentEncoder]->codecName;
+
+}
+
+/**
+    \fn audioProcessMode
+    \brief
+    @return 1 in process mode, 0 in copy mode
+*/
+uint32_t audioProcessMode(void)
+{
+        if(!currentEncoder) return 0;
+        return 1;
+}
+/**
+ * 	\fn getAudioOuputTag
+ *  \brief Return the encoding of the currently selected codec
+ *  Must be called only in process mode, else it is meaningless.
+ */
+uint32_t audioFilter_getOuputCodec(void)
+{
+	ADM_assert(!currentEncoder);
+    return ListOfAudioEncoder[currentEncoder]->wavTag;
+}
+
+/**
+ * 	\fn audioFilter_getMaxChannels
+ *  \brief Return the max # of channels a codec supports
+ */
+uint32_t audioFilter_getMaxChannels(void)
+{
+    ADM_assert(currentEncoder<ListOfAudioEncoder.size());
+	if(!currentEncoder) return 99999;
+	return ListOfAudioEncoder[currentEncoder]->maxChannels;
+}
+/**
+    \fn audioCodecConfigure
+    \brief
+*/
+void audioCodecConfigure( void )
+{
+    if(ListOfAudioEncoder[currentEncoder]->configure)
+    ListOfAudioEncoder[currentEncoder]->configure();
+}
+/**
+    \fn audioGetBitrate
+*/
+uint32_t audioGetBitrate(void)
+{
+    ADM_assert(currentEncoder<ListOfAudioEncoder.size());
+    if(ListOfAudioEncoder[currentEncoder]->getBitrate)
+        return ListOfAudioEncoder[currentEncoder]->getBitrate();
+    return 0;
+} 
+void audioFilter_SetBitrate( int i)
+{
+    ADM_assert(currentEncoder<ListOfAudioEncoder.size());
+    if(ListOfAudioEncoder[currentEncoder]->setBitrate)
+        ListOfAudioEncoder[currentEncoder]->setBitrate(i);
+    
+}
+/**
+    \fn audioEncoderGetNumberOfEncoders
+*/
+uint32_t audioEncoderGetNumberOfEncoders(void)
+{
+    return ListOfAudioEncoder.size();
+}
+/**
+    \fn audioEncoderGetDisplayName
+*/
+const char  *audioEncoderGetDisplayName(uint32_t i)
+{
+     ADM_assert(currentEncoder<ListOfAudioEncoder.size());
+     return ListOfAudioEncoder[i]->menuName;
+}
+/**
+        \fn audioEncoderCreate
+        \brief Spawn an audio encoder
+*/
+ADM_AudioEncoder *audioEncoderCreate(AUDMAudioFilter *filter)
+{
+      ADM_assert(currentEncoder<ListOfAudioEncoder.size());
+      static ADM_audioEncoder *enc=ListOfAudioEncoder[currentEncoder];
+     return enc->create(filter);
+}
+/**
+        \fn getAudioExtraConf
+        \brief 
+*/
+
+uint8_t getAudioExtraConf(uint32_t *bitrate,uint32_t *extraDataSize, uint8_t **extradata)
+{
+    if(!currentEncoder)
+    {
+        printf("[AudioEncoder] Cannot get conf on copy!\n");
+        return 0;
+    }
+     ADM_assert(currentEncoder<ListOfAudioEncoder.size());
+     ADM_audioEncoder *encoder= ListOfAudioEncoder[currentEncoder];
+     *bitrate=encoder->getBitrate();
+     if(encoder->getConfigurationData)
+        return encoder->getConfigurationData(extraDataSize,extradata);
+     else return 1;
+}
+/**
+    \fn setAudioExtraConf
+*/
+uint8_t setAudioExtraConf(uint32_t bitrate,uint32_t extraDataSize, uint8_t *extradata)
+{
+    if(!currentEncoder)
+    {
+        printf("[AudioEncoder] Cannot set conf on copy!\n");
+        return 0;
+    }
+     ADM_assert(currentEncoder<ListOfAudioEncoder.size());
+     ADM_audioEncoder *encoder= ListOfAudioEncoder[currentEncoder];
+     encoder->setBitrate(bitrate);
+     if(encoder->setConfigurationData)
+        return encoder->setConfigurationData(extraDataSize,extradata);
+    else return 1;
+}     
+/**
+        \fn audio_selectCodecByTag
+        \brief Select the "best" encoder outputing tag codec
+*/
+uint8_t audio_selectCodecByTag(uint32_t tag)
+{
+    int selected=-1,priority=-1;
+    for(int i=1;i<ListOfAudioEncoder.size();i++)
+    {
+        ADM_audioEncoder *c=ListOfAudioEncoder[i];
+        if(c->wavTag==tag)
+        {
+            if((int)c->priority>priority)
+            {
+                selected=i;
+                priority=c->priority;
+            }
+        }
+    }
+    if(selected!=-1)
+    {
+        currentEncoder=selected;
+        UI_setAudioCodec( (int)currentEncoder);
+        printf("[AudioEncoder] Selected %s for tag %d (%s)\n",ListOfAudioEncoder[currentEncoder]->codecName,tag,"");
+        return 1;
+    }
+    return 0;
+}
+/**
+         \fn audioSetOption
+         \brief Allow per codec switch
+*/
+uint8_t audioSetOption(const char *option, uint32_t value)
+{
+    ADM_audioEncoder *c=ListOfAudioEncoder[currentEncoder];
+    if(!c->setOption) return 0;
+    return c->setOption(option,value);
+
+}
+/**
+         \fn audio_setCopyCodec
+         \brief Set audio codec to copy
+*/
+uint8_t audio_setCopyCodec(void)
+{
+    currentEncoder=0;
+    return 1;
+
+}
+
+//**

Modified: branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/CMakeLists.txt	2009-03-19 17:02:27 UTC (rev 4699)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/CMakeLists.txt	2009-03-21 14:55:57 UTC (rev 4700)
@@ -10,8 +10,8 @@
 #        audiofilter_SRC.cpp
         audio_raw.cpp
 	audioeng_buff.cpp          
-        audio_encoderWrapper.cpp
-        audio_encoderPlugin.cpp
+#        audio_encoderWrapper.cpp
+#        audio_encoderPlugin.cpp
 )
 	
 ADD_ADM_LIB_ALL_TARGETS(ADM_audiofilter ${ADMaudiofilter_SRCS})

Deleted: branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audio_encoderPlugin.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audio_encoderPlugin.cpp	2009-03-19 17:02:27 UTC (rev 4699)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audio_encoderPlugin.cpp	2009-03-21 14:55:57 UTC (rev 4700)
@@ -1,428 +0,0 @@
-/***************************************************************************
-                          audio_encoderPlugin.cpp  -  description
-                             -------------------
-    
-    copyright            : (C) 2008 by mean
-    email                : fixounet at free.fr
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#include <vector>
-#include "ADM_default.h"
-#include "audioencoderInternal.h"
-#include "ADM_dynamicLoading.h"
-std::vector <ADM_audioEncoder *> ListOfAudioEncoder;
-
-static AUDIOENCODER  currentEncoder=0; //0 is always dummy
-
-static AUDIOENCODER ADM_encoderByName(const char *name);
-static const char *ADM_audioEncoderById(AUDIOENCODER id);
-
-/**
-    \class ADM_AudioEncoderLoader
-    \brief Helper class to load plugins
-*/
-class ADM_AudioEncoderLoader :public ADM_LibWrapper
-{
-
-public:
-        int                 initialised;
-        ADM_audioEncoder    *encoderBlock;
-        
-
-
-        ADM_AudioEncoderLoader(const char *file) : ADM_LibWrapper()
-		{
-                ADM_audioEncoder    *e;
-                ADM_audioEncoder *(*getInfo)(void);
-                initialised = loadLibrary(file) && getSymbols(1,
-				&getInfo, "getInfo"
-                );
-                encoderBlock=NULL;
-                if(initialised)
-                {
-                    e=getInfo();
-                    if(e->apiVersion!=ADM_AUDIO_ENCODER_API_VERSION)
-                    {
-                        e=NULL;
-                        initialised=0;
-                    }else
-                    {
-                        printf("[AudioEncoder] Loaded %s version %02d.%02d.%02d wavTag :0x%x\n",e->codecName,
-                                e->major,e->minor,e->patch,e->wavTag);
-                        encoderBlock=new ADM_audioEncoder;
-                        *encoderBlock=*e;
-                        encoderBlock->opaque=(void *)this;
-                    } 
-                }else
-                {
-                    printf("Symbol loading failed for %s\n",file);
-                }
-		}
-        ADM_AudioEncoderLoader(const char *name, const char *menuName) : ADM_LibWrapper()
-		{
-                    encoderBlock=new ADM_audioEncoder;
-                    encoderBlock->codecName=name;
-                    encoderBlock->menuName=menuName;                    
-                    encoderBlock->opaque=(void *)this;
-		}
-        ~ADM_AudioEncoderLoader()
-        {
-            if(encoderBlock) delete encoderBlock;
-            encoderBlock=NULL;
-            
-        }
-};
-
-/**
-        \fn ADM_ae_getPluginNbEncoders
-        \brief Returns the number of av filter plugins except one
-*/
-uint32_t ADM_ae_getPluginNbEncoders(void)
-{
-    return ListOfAudioEncoder.size()-1;
-}
-/**
-    \fn     ADM_ae_getAPluginEncoderInfo
-    \brief  Get Infos about the encoder #th plugin (plugin display)
-*/
-bool     ADM_ae_getAPluginEncoderInfo(int filter, const char **name, uint32_t *major,uint32_t *minor,uint32_t *patch)
-{
-    filter++;
-    ADM_assert(filter<ListOfAudioEncoder.size());
-    *major=ListOfAudioEncoder[filter]->major;
-    *minor=ListOfAudioEncoder[filter]->minor;
-    *patch=ListOfAudioEncoder[filter]->patch;
-    *name=ListOfAudioEncoder[filter]->description;
-    return true;
-}
-/**
-    \fn tryLoadingFilterPlugin
-    \brief Try loading the file given as argument as an audio device plugin
-
-*/
-#define Fail(x) {printf("%s:"#x"\n",file);goto er;}
-static bool tryLoadingFilterPlugin(const char *file)
-{
-	ADM_AudioEncoderLoader *dll=new ADM_AudioEncoderLoader(file);
-    if(!dll->initialised) Fail(CannotLoad);
-    
-
-    ListOfAudioEncoder.push_back(dll->encoderBlock); // Needed for cleanup. FIXME TODO Delete it.
-    printf("[AudioEncoder] Registered filter %s as  %s\n",file,dll->encoderBlock->description);
-    return true;
-	// Fail!
-er:
-	delete dll;
-	return false;
-
-}
-/**
- * 	\fn ADM_ae_loadPlugins
- *  \brief load all audio encoder plugins
- */
-uint8_t ADM_ae_loadPlugins(const char *path)
-{
-#define MAX_EXTERNAL_FILTER 100
-// FIXME Factorize
-
-	char *files[MAX_EXTERNAL_FILTER];
-	uint32_t nbFile;
-    // Add the copy encoder
-    ADM_AudioEncoderLoader *copy=new ADM_AudioEncoderLoader("copy","Copy");
-    ListOfAudioEncoder.push_back(copy->encoderBlock);
-    //
-	memset(files,0,sizeof(char *)*MAX_EXTERNAL_FILTER);
-	printf("[ADM_ae_plugin] Scanning directory %s\n",path);
-
-	if(!buildDirectoryContent(&nbFile, path, files, MAX_EXTERNAL_FILTER, SHARED_LIB_EXT))
-	{
-		printf("[ADM_ae_plugin] Cannot parse plugin\n");
-		return 0;
-	}
-
-	for(int i=0;i<nbFile;i++)
-		tryLoadingFilterPlugin(files[i]);
-
-	printf("[ADM_ae_plugin] Scanning done\n");
-
-	return 1;
-}
-/**
-    \fn audioPrintCurrentCodec
-    \brief updates the UI with the current selected audio encoder
-*/
-void UI_setAudioCodec( int i);
-void audioPrintCurrentCodec(void)
-{
-			UI_setAudioCodec(currentEncoder);
-}
-
-/**
-    \fn ADM_encoderByName
-    \brief Returns the Id of the given string 
-
-*/
-AUDIOENCODER ADM_encoderByName(const char *name)
-{
-	if(!name) return (AUDIOENCODER)0;
-    if(!strcasecmp(name,"copy")) return (AUDIOENCODER)0; // copy
-	for(uint32_t i=1;i<ListOfAudioEncoder.size();i++)
-	{
-		if(!strcasecmp(name,ListOfAudioEncoder[i]->codecName))
-		{
-			return i;
-		}	
-	}
-	printf("[AudioEncoder] Encoder not found :%s\n",name);
-	return (AUDIOENCODER)0;
-
-}
-/**
-    \fn    ADM_audioEncoderById
-    \brief Returns the name of a device from its Id
-*/
-static const char *ADM_audioEncoderById(AUDIOENCODER id)
-{
-
-	ADM_assert(id<ListOfAudioEncoder.size());
-    return ListOfAudioEncoder[id]->codecName;
-}
-/**
-    \fn AVDM_getCurrentAudioEncoder
-    \brief
-*/
-AUDIOENCODER AVDM_getCurrentAudioEncoder( void)
-{
-	return currentEncoder;
-}
-/**
-    \fn audioCodecSelect
-    \brief Update UI
-*/
-uint8_t DIA_audioCodec( int *codec );
-void audioCodecSelect( void )
-{
- 
-	DIA_audioCodec( &currentEncoder );
-	audioPrintCurrentCodec();
-}
-/**
-    \fn     audioCodecSetByName
-    \brief  only called by JS, we have to update UI as well
-*/
-uint8_t audioCodecSetByName( const char *name)
-{
-		for(uint32_t i=0;i<ListOfAudioEncoder.size();i++)
-		{
-			if(!strcasecmp(name,ListOfAudioEncoder[i]->codecName))
-			{
-
-				currentEncoder=i;
-                audioPrintCurrentCodec(); // Update UI
-				return 1;
-			}
-
-		}
-		printf("\n Mmmm Select audio codec by name failed...(%s).\n",name);
-		return 0;
-}
-/**
-    \fn audioCodecSetByIndex
-    \brief To be used by UI code only!
-*/
-uint8_t audioCodecSetByIndex(int i)
-{
-    ADM_assert(i<ListOfAudioEncoder.size());
-    currentEncoder=i;
-    printf("[AudioEncoder] Selected %s for index %d, tag 0x%x \n",ListOfAudioEncoder[currentEncoder]->codecName,i,ListOfAudioEncoder[currentEncoder]->wavTag);
-    return 1;
-
-}
-/**
-    \fn audioCodecGetName
-    \brief Returns the current codec tagname
-*/
-const char *audioCodecGetName( void )
-{
-	  ADM_assert(currentEncoder<ListOfAudioEncoder.size());
-      return ListOfAudioEncoder[currentEncoder]->codecName;
-
-}
-
-/**
-    \fn audioProcessMode
-    \brief
-    @return 1 in process mode, 0 in copy mode
-*/
-uint32_t audioProcessMode(void)
-{
-        if(!currentEncoder) return 0;
-        return 1;
-}
-/**
- * 	\fn getAudioOuputTag
- *  \brief Return the encoding of the currently selected codec
- *  Must be called only in process mode, else it is meaningless.
- */
-uint32_t audioFilter_getOuputCodec(void)
-{
-	ADM_assert(!currentEncoder);
-    return ListOfAudioEncoder[currentEncoder]->wavTag;
-}
-
-/**
- * 	\fn audioFilter_getMaxChannels
- *  \brief Return the max # of channels a codec supports
- */
-uint32_t audioFilter_getMaxChannels(void)
-{
-    ADM_assert(currentEncoder<ListOfAudioEncoder.size());
-	if(!currentEncoder) return 99999;
-	return ListOfAudioEncoder[currentEncoder]->maxChannels;
-}
-/**
-    \fn audioCodecConfigure
-    \brief
-*/
-void audioCodecConfigure( void )
-{
-    if(ListOfAudioEncoder[currentEncoder]->configure)
-    ListOfAudioEncoder[currentEncoder]->configure();
-}
-/**
-    \fn audioGetBitrate
-*/
-uint32_t audioGetBitrate(void)
-{
-    ADM_assert(currentEncoder<ListOfAudioEncoder.size());
-    if(ListOfAudioEncoder[currentEncoder]->getBitrate)
-        return ListOfAudioEncoder[currentEncoder]->getBitrate();
-    return 0;
-} 
-void audioFilter_SetBitrate( int i)
-{
-    ADM_assert(currentEncoder<ListOfAudioEncoder.size());
-    if(ListOfAudioEncoder[currentEncoder]->setBitrate)
-        ListOfAudioEncoder[currentEncoder]->setBitrate(i);
-    
-}
-/**
-    \fn audioEncoderGetNumberOfEncoders
-*/
-uint32_t audioEncoderGetNumberOfEncoders(void)
-{
-    return ListOfAudioEncoder.size();
-}
-/**
-    \fn audioEncoderGetDisplayName
-*/
-const char  *audioEncoderGetDisplayName(uint32_t i)
-{
-     ADM_assert(currentEncoder<ListOfAudioEncoder.size());
-     return ListOfAudioEncoder[i]->menuName;
-}
-/**
-        \fn audioEncoderCreate
-        \brief Spawn an audio encoder
-*/
-AUDMEncoder *audioEncoderCreate(AUDMAudioFilter *filter)
-{
-      ADM_assert(currentEncoder<ListOfAudioEncoder.size());
-      static ADM_audioEncoder *enc=ListOfAudioEncoder[currentEncoder];
-     return enc->create(filter);
-}
-/**
-        \fn getAudioExtraConf
-        \brief 
-*/
-
-uint8_t getAudioExtraConf(uint32_t *bitrate,uint32_t *extraDataSize, uint8_t **extradata)
-{
-    if(!currentEncoder)
-    {
-        printf("[AudioEncoder] Cannot get conf on copy!\n");
-        return 0;
-    }
-     ADM_assert(currentEncoder<ListOfAudioEncoder.size());
-     ADM_audioEncoder *encoder= ListOfAudioEncoder[currentEncoder];
-     *bitrate=encoder->getBitrate();
-     if(encoder->getConfigurationData)
-        return encoder->getConfigurationData(extraDataSize,extradata);
-     else return 1;
-}
-/**
-    \fn setAudioExtraConf
-*/
-uint8_t setAudioExtraConf(uint32_t bitrate,uint32_t extraDataSize, uint8_t *extradata)
-{
-    if(!currentEncoder)
-    {
-        printf("[AudioEncoder] Cannot set conf on copy!\n");
-        return 0;
-    }
-     ADM_assert(currentEncoder<ListOfAudioEncoder.size());
-     ADM_audioEncoder *encoder= ListOfAudioEncoder[currentEncoder];
-     encoder->setBitrate(bitrate);
-     if(encoder->setConfigurationData)
-        return encoder->setConfigurationData(extraDataSize,extradata);
-    else return 1;
-}     
-/**
-        \fn audio_selectCodecByTag
-        \brief Select the "best" encoder outputing tag codec
-*/
-uint8_t audio_selectCodecByTag(uint32_t tag)
-{
-    int selected=-1,priority=-1;
-    for(int i=1;i<ListOfAudioEncoder.size();i++)
-    {
-        ADM_audioEncoder *c=ListOfAudioEncoder[i];
-        if(c->wavTag==tag)
-        {
-            if((int)c->priority>priority)
-            {
-                selected=i;
-                priority=c->priority;
-            }
-        }
-    }
-    if(selected!=-1)
-    {
-        currentEncoder=selected;
-        UI_setAudioCodec( (int)currentEncoder);
-        printf("[AudioEncoder] Selected %s for tag %d (%s)\n",ListOfAudioEncoder[currentEncoder]->codecName,tag,"");
-        return 1;
-    }
-    return 0;
-}
-/**
-         \fn audioSetOption
-         \brief Allow per codec switch
-*/
-uint8_t audioSetOption(const char *option, uint32_t value)
-{
-    ADM_audioEncoder *c=ListOfAudioEncoder[currentEncoder];
-    if(!c->setOption) return 0;
-    return c->setOption(option,value);
-
-}
-/**
-         \fn audio_setCopyCodec
-         \brief Set audio codec to copy
-*/
-uint8_t audio_setCopyCodec(void)
-{
-    currentEncoder=0;
-    return 1;
-
-}
-
-//**

Deleted: branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audio_encoderPlugin.h
===================================================================

Modified: branches/avidemux_2.6_branch_mean/avidemux/ADM_coreAudioEncoder/include/audioencoder.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_coreAudioEncoder/include/audioencoder.h	2009-03-19 17:02:27 UTC (rev 4699)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_coreAudioEncoder/include/audioencoder.h	2009-03-21 14:55:57 UTC (rev 4700)
@@ -5,18 +5,18 @@
     email                : fixounet at free.fr
  ***************************************************************************/
 
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
 
 #ifndef AUDIO_ENCODER_H
 #define AUDIO_ENCODER_H
-/*!
-  This structure defines an audio encoder
-  \param encoder Encoder attached to this descriptor
-   \param name The name of the codec
-  \param bitrate The bitrate in kb/s
-  \param configure Function to call to configure the codec
-  \param maxChannels The maximum # of channels this codec supports
-  \param param : An opaque structure that contains the codec specific configuration datas
-*/
+
 #include "ADM_coreAudio.h"
 #include "ADM_audioCodecEnum.h"
 #include "ADM_audioFilter.h" 
@@ -64,7 +64,7 @@
                     ADM_AudioEncoder(AUDMAudioFilter *in);	
                     virtual ~ADM_AudioEncoder();
 
-
+    virtual bool    isVBR(void) {return true;}
     virtual bool    initialize(void)=0; /// Returns true if init ok, false if encoding is impossible
     virtual bool    encode(uint8_t *dest, uint32_t *len, uint32_t *samples)=0; /// returns false if eof met
 };

Modified: branches/avidemux_2.6_branch_mean/avidemux/ADM_coreAudioEncoder/include/audioencoderInternal.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_coreAudioEncoder/include/audioencoderInternal.h	2009-03-19 17:02:27 UTC (rev 4699)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_coreAudioEncoder/include/audioencoderInternal.h	2009-03-21 14:55:57 UTC (rev 4700)
@@ -3,20 +3,37 @@
     \brief interface to audio encoder plugins
 
 */
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
 #ifndef AUDIOENCODERINTERNAL_H
 #define AUDIOENCODERINTERNAL_H
 
-#define ADM_AUDIO_ENCODER_API_VERSION 1
+#define ADM_AUDIO_ENCODER_API_VERSION 2
 #include "audioencoder.h"
 class AUDMEncoder;
-class AUDMAudioFilter;
+class ADM_AudioEncoder;
 
-
+/*!
+  This structure defines an audio encoder
+  \param encoder Encoder attached to this descriptor
+   \param name The name of the codec
+  \param bitrate The bitrate in kb/s
+  \param configure Function to call to configure the codec
+  \param maxChannels The maximum # of channels this codec supports
+  \param param : An opaque structure that contains the codec specific configuration datas
+*/
 typedef struct
 {
     uint32_t     apiVersion;            // const
-    AUDMEncoder *(*create)(AUDMAudioFilter *head);  
-    void         (*destroy)(AUDMEncoder *codec);
+    ADM_AudioEncoder *(*create)(AUDMAudioFilter *head);  
+    void         (*destroy)(ADM_AudioEncoder *codec);
     uint8_t      (*configure)(void);    
     const char   *codecName;        // Internal name (tag)
     const char   *menuName;         // Displayed name (in menu)
@@ -44,11 +61,11 @@
 static uint32_t     getBitrate(void); \
 static void         setBitrate(uint32_t br); \
 \
-static AUDMEncoder * create (AUDMAudioFilter * head) \
+static ADM_AudioEncoder * create (AUDMAudioFilter * head) \
 { \
   return new Class (head); \
 } \
-static void destroy (AUDMEncoder * in) \
+static void destroy (ADM_AudioEncoder * in) \
 {\
   Class *z = (Class *) in; \
   delete z; \

Modified: branches/avidemux_2.6_branch_mean/avidemux/ADM_coreAudioEncoder/src/audioencoder.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_coreAudioEncoder/src/audioencoder.cpp	2009-03-19 17:02:27 UTC (rev 4699)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_coreAudioEncoder/src/audioencoder.cpp	2009-03-21 14:55:57 UTC (rev 4700)
@@ -43,6 +43,7 @@
         _extraData=NULL;
     }
 }
+
 /**
     \fn refillBuffer
 */

Modified: branches/avidemux_2.6_branch_mean/cmake/ae_plugin.cmake
===================================================================
--- branches/avidemux_2.6_branch_mean/cmake/ae_plugin.cmake	2009-03-19 17:02:27 UTC (rev 4699)
+++ branches/avidemux_2.6_branch_mean/cmake/ae_plugin.cmake	2009-03-21 14:55:57 UTC (rev 4700)
@@ -1,3 +1,6 @@
+#
+#  Macro to declare an audio encoder plugin
+#
 MACRO(INIT_AUDIO_ENCODER _lib)
 	INCLUDE_DIRECTORIES("${AVIDEMUX_SOURCE_DIR}/avidemux/ADM_core/include")
 	INCLUDE_DIRECTORIES("${AVIDEMUX_SOURCE_DIR}/avidemux/ADM_coreAudio/include")
@@ -2,4 +5,7 @@
 	INCLUDE_DIRECTORIES("${AVIDEMUX_SOURCE_DIR}/avidemux/ADM_coreUI/include")
-	INCLUDE_DIRECTORIES("${AVIDEMUX_SOURCE_DIR}/avidemux/ADM_audiofilter")
-        ADD_DEFINITIONS("-DADM_MINIMAL_UI_INTERFACE")
+	INCLUDE_DIRECTORIES("${AVIDEMUX_SOURCE_DIR}/avidemux/ADM_audioFilter/include")
+    INCLUDE_DIRECTORIES("${AVIDEMUX_SOURCE_DIR}/avidemux/ADM_coreAudioEncoder/include")
+
+    ADD_DEFINITIONS("-DADM_MINIMAL_UI_INTERFACE")
+
 ENDMACRO(INIT_AUDIO_ENCODER)

Modified: branches/avidemux_2.6_branch_mean/plugins/ADM_audioEncoders/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_audioEncoders/CMakeLists.txt	2009-03-19 17:02:27 UTC (rev 4699)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_audioEncoders/CMakeLists.txt	2009-03-21 14:55:57 UTC (rev 4700)
@@ -9,9 +9,9 @@
 MESSAGE("***  /Audio Codec  ***")
 
 
-ADD_SUBDIRECTORY(twolame)
-ADD_SUBDIRECTORY(pcm)
-ADD_SUBDIRECTORY(lavcodec)
+#ADD_SUBDIRECTORY(twolame)
+#ADD_SUBDIRECTORY(pcm)
+#ADD_SUBDIRECTORY(lavcodec)
 
 if(USE_LAME)
 ADD_SUBDIRECTORY(lame)
@@ -22,9 +22,9 @@
 endif(USE_AFTEN)
 
 if(USE_VORBIS)
-ADD_SUBDIRECTORY(vorbis)
+#ADD_SUBDIRECTORY(vorbis)
 endif(USE_VORBIS)
 
 if(USE_FAAC)
-ADD_SUBDIRECTORY(faac)
+#ADD_SUBDIRECTORY(faac)
 endif(USE_FAAC)

Modified: branches/avidemux_2.6_branch_mean/plugins/ADM_audioEncoders/lame/audioencoder_lame.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_audioEncoders/lame/audioencoder_lame.cpp	2009-03-19 17:02:27 UTC (rev 4699)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_audioEncoders/lame/audioencoder_lame.cpp	2009-03-21 14:55:57 UTC (rev 4700)
@@ -1,5 +1,7 @@
 /***************************************************************************
-    copyright            : (C) 2006 by mean
+        \file audioencoder_lame.cpp
+        \brief Avidemux audio encoder plugin, front end for libmp3lame
+    copyright            : (C) 2006/2009 by mean
     email                : fixounet at free.fr
  ***************************************************************************/
 
@@ -24,7 +26,6 @@
 static LAME_encoderParam myLameParam = {
   128,
   ADM_LAME_PRESET_CBR,		// preset;
-  ADM_STEREO,			//ADM_mode        mode;
   2,				//uint32_t        quality;
   0,				//uint32_t        disableReservoir; // usefull for strict CBR (FLV)
 };
@@ -43,10 +44,10 @@
   configure,		//** put your own function here**
   "Lame",
   "MP3 (lame)",
-  "Lame MP3 encoder plugin Mean 2008",
+  "Lame MP3 encoder plugin Mean 2009",
   2,                    // Max channels
   1,0,0,                // Version
-  WAV_MP3,
+  WAV_MP3,              // WavTag
   200,                  // Priority
   getConfigurationData,  // Defined by macro automatically
   setConfigurationData,  // Defined by macro automatically
@@ -66,12 +67,11 @@
     \fn AUDMEncoder_Lame Constructor
     \brief
 */
-AUDMEncoder_Lame::AUDMEncoder_Lame (AUDMAudioFilter * instream):AUDMEncoder
-  (instream)
+AUDMEncoder_Lame::AUDMEncoder_Lame (AUDMAudioFilter * instream):ADM_AudioEncoder  (instream)
 {
   printf ("[Lame] Creating lame\n");
   lameFlags = NULL;
-  _wavheader->encoding = WAV_MP3;
+  wavheader.encoding = WAV_MP3;
 };
 
 /**
@@ -88,8 +88,6 @@
       lame_close (MYFLAGS);
     }
   lameFlags = NULL;
-  cleanup ();
-
 };
 
 
@@ -99,8 +97,7 @@
     @return 1 on success, 0 on error
 */
 
-uint8_t
-AUDMEncoder_Lame::initialize (void)
+bool AUDMEncoder_Lame::initialize (void)
 {
 
   int ret;
@@ -111,43 +108,31 @@
 
   lameFlags = lame_init ();
   if (lameFlags == NULL)
-    return 0;
+    return false;
 
   if (_incoming->getInfo ()->channels > 2)
     {
       printf ("[Lame]Too many channels\n");
-      return 0;
+      return false;
     }
 
   // recompute output length
 
 
-  ret = lame_set_in_samplerate (MYFLAGS, _wavheader->frequency);
-  ret = lame_set_num_channels (MYFLAGS, _wavheader->channels);
+  ret = lame_set_in_samplerate (MYFLAGS, wavheader.frequency);
+  ret = lame_set_num_channels (MYFLAGS,  wavheader.channels);
 
 
-  frequence = _wavheader->frequency;
+  frequence = wavheader.frequency;
   printf ("[Lame] output frequency : %"LU"\n", frequence);
   ret = lame_set_out_samplerate (MYFLAGS, frequence);
 
   ret = lame_set_quality (MYFLAGS, 2);
 
-  if (_wavheader->channels == 2)
+  if (wavheader.channels == 2)
     {
-      switch (lameConf->mode)
-	{
-	case ADM_STEREO:
-	  mmode = STEREO;
-	  break;
-	case ADM_JSTEREO:
-	  mmode = JOINT_STEREO;
-	  break;
-	default:
-	  printf ("[Lame] **** unknown mode ***\n");
-	  mmode = STEREO;
-	  break;
 
-	}
+          mmode = STEREO;
     }
   else
     {
@@ -162,9 +147,12 @@
   printf ("[Lame]Using quality of %d\n", lame_get_quality (MYFLAGS));
   ret = lame_init_params (MYFLAGS);
   if (ret == -1)
-    return 0;
+    {
+        printf("[Lame] Init params failes %d\n",ret);
+        return false;
+    }
   // update bitrate in header
-  _wavheader->byterate = (lameConf->bitrate >> 3) * 1000;
+  wavheader.byterate = (lameConf->bitrate >> 3) * 1000;
 #define BLOCK_SIZE 1152
   // configure CBR/ABR/...
 
@@ -176,10 +164,10 @@
     case ADM_LAME_PRESET_ABR:
 
       lame_set_preset (MYFLAGS, lameConf->bitrate);
-      _wavheader->blockalign = BLOCK_SIZE;
+      wavheader.blockalign = BLOCK_SIZE;
       break;
     case ADM_LAME_PRESET_EXTREME:
-      _wavheader->blockalign = BLOCK_SIZE;
+      wavheader.blockalign = BLOCK_SIZE;
       lame_set_preset (MYFLAGS, EXTREME);
       break;
 
@@ -188,33 +176,32 @@
 
   lame_print_config (MYFLAGS);
   lame_print_internals (MYFLAGS);
-  _chunk = BLOCK_SIZE * _wavheader->channels;
+  _chunk = BLOCK_SIZE * wavheader.channels;
 
-  return 1;
+  return true;
 }
 /**
     \fn isVBR
     @return 1 if the stream is vbr, 0 is cbr
 
 */
-uint8_t AUDMEncoder_Lame::isVBR (void)
+bool AUDMEncoder_Lame::isVBR (void)
 {
   if (myLameParam.preset == ADM_LAME_PRESET_CBR)
-    return 0;
-  return 1;
+    return false;
+  return true;
 
 }
 /**
-    \fn getPacket
+    \fn encode
     \brief Get an encoded mp3 packet
     @param dest [in] Where to write datas
     @param len  [out] Length of encoded datas in bytes
     @param samples [out] Number of samples
-    @return 1 on success, 0 on error
+    @return true on success, false on error
 
 */
-uint8_t AUDMEncoder_Lame::getPacket (uint8_t * dest, uint32_t * len,
-			     uint32_t * samples)
+bool AUDMEncoder_Lame::encode(uint8_t *dest, uint32_t *len, uint32_t *samples)
 {
 
   int32_t nbout;
@@ -224,42 +211,38 @@
 
   if (!refillBuffer (_chunk))
     {
-      return 0;
+      return false;
     }
 
   if (tmptail - tmphead < _chunk)
     {
-      return 0;
+      return false;
     }
-  dither16 (&(tmpbuffer[tmphead]), _chunk, _wavheader->channels);
+  dither16 (&(tmpbuffer[tmphead]), _chunk, wavheader.channels);
   ADM_assert (tmptail >= tmphead);
-  if (_wavheader->channels == 1)
+  if (wavheader.channels == 1)
     {
-      nbout =
-	lame_encode_buffer (MYFLAGS, (int16_t *) & (tmpbuffer[tmphead]),
+      nbout =	lame_encode_buffer (MYFLAGS, (int16_t *) & (tmpbuffer[tmphead]),
 			    (int16_t *) & (tmpbuffer[tmphead]), _chunk, dest,
 			    16 * 1024);
 
     }
   else
     {
-      nbout =
-	lame_encode_buffer_interleaved (MYFLAGS,
+      nbout =	lame_encode_buffer_interleaved (MYFLAGS,
 					(int16_t *) & (tmpbuffer[tmphead]),
 					_chunk / 2, dest, 16 * 1024);
     }
   tmphead += _chunk;
   if (nbout < 0)
     {
-      printf ("\n Error !!! : %"LD"\n", nbout);
-      return 0;
+      printf ("[Lame] Error !!! : %"LD"\n", nbout);
+      return false;
     }
   *len = nbout;
   if (!*len)
     *samples = 0;
-  //printf("Audio packet : size %u, sample %u\n",*len,*samples);
-
-  return 1;
+  return true;
 }
 /**
       \fn configure
@@ -278,26 +261,14 @@
 #define PX(x) &(lameParam->x)
 
   LAME_encoderParam *lameParam = &myLameParam;
-  mmode = lameParam->mode;
   ppreset = lameParam->preset;
-  diaMenuEntry channelMode[] = {
-    {ADM_STEREO, QT_TR_NOOP ("Stereo"), NULL},
-    {ADM_JSTEREO, QT_TR_NOOP ("Joint stereo"), NULL},
-    {ADM_MONO, QT_TR_NOOP ("Mono"), NULL}
-  };
 
-  diaElemMenu menuMode (&mmode, QT_TR_NOOP ("C_hannel mode:"),
-			SZT (channelMode), channelMode);
-
   diaMenuEntry encodingMode[] = {
     {ADM_LAME_PRESET_CBR, QT_TR_NOOP ("CBR"), NULL},
     {ADM_LAME_PRESET_ABR, QT_TR_NOOP ("ABR"), NULL},
-#if 0
-    {ADM_LAME_PRESET_EXTREME, QT_TR_NOOP ("Extreme"), NULL}
-#endif
   };
-  diaElemMenu Mode (&ppreset, QT_TR_NOOP ("Bit_rate mode:"),
-		    SZT (encodingMode), encodingMode);
+  diaElemMenu Mode (&ppreset, QT_TR_NOOP ("Bit_rate mode:"),   SZT (encodingMode), encodingMode);
+
 #define BITRATE(x) {x,QT_TR_NOOP(#x)}
   diaMenuEntry bitrateM[] = {
     BITRATE (56),
@@ -318,9 +289,9 @@
   diaElemToggle reservoir (PX (disableReservoir),
 			   QT_TR_NOOP ("_Disable reservoir:"));
 
-  diaElem *elems[] = { &menuMode, &Mode, &quality, &bitrate, &reservoir };
+  diaElem *elems[] = { &Mode, &bitrate,&quality, &reservoir };
 
-  if (diaFactoryRun (QT_TR_NOOP ("LAME Configuration"), 5, elems))
+  if (diaFactoryRun (QT_TR_NOOP ("LAME Configuration"), 4, elems))
     {
       return 1;
     }

Modified: branches/avidemux_2.6_branch_mean/plugins/ADM_audioEncoders/lame/audioencoder_lame.h
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_audioEncoders/lame/audioencoder_lame.h	2009-03-19 17:02:27 UTC (rev 4699)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_audioEncoders/lame/audioencoder_lame.h	2009-03-21 14:55:57 UTC (rev 4700)
@@ -12,25 +12,27 @@
  *   (at your option) any later version.                                   *
  *                                                                         *
  ***************************************************************************/
-#ifndef AUDMaudioLame
-#define AUDMaudioLame
+#ifndef AUDMaudioLame_H
+#define AUDMaudioLame_H
 
- //_____________________________________________
-class AUDMEncoder_Lame : public AUDMEncoder
+ /**
+        \class AUDMEncoder_Lame
+        \brief Front end for libmp3lame
+*/
+class AUDMEncoder_Lame : public ADM_AudioEncoder
 {
   protected:
    
     void              *lameFlags;
-    
+    uint32_t          _chunk; // Nb of float we encode each time
          
   public:
-//            uint8_t     init(ADM_audioEncoderDescriptor *config);
     virtual             ~AUDMEncoder_Lame();
                         AUDMEncoder_Lame(AUDMAudioFilter *instream);	
-            uint8_t	isVBR(void );
+            bool	    isVBR(void );
             
-   virtual uint8_t	getPacket(uint8_t *dest, uint32_t *len, uint32_t *samples);
-   virtual uint8_t  initialize(void);
+   virtual bool         encode(uint8_t *dest, uint32_t *len, uint32_t *samples);
+   virtual bool         initialize(void);
 };
 
 #endif

Modified: branches/avidemux_2.6_branch_mean/plugins/ADM_audioEncoders/lame/audioencoder_lame_param.h
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_audioEncoders/lame/audioencoder_lame_param.h	2009-03-19 17:02:27 UTC (rev 4699)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_audioEncoders/lame/audioencoder_lame_param.h	2009-03-21 14:55:57 UTC (rev 4700)
@@ -26,7 +26,6 @@
 {
   uint32_t        bitrate; // in kbps
   ADM_LAME_PRESET preset;
-  ADM_mode        mode;
   uint32_t        quality;
   uint32_t        disableReservoir; // usefull for strict CBR (FLV)
 }LAME_encoderParam;



From mean at mail.berlios.de  Sat Mar 21 15:56:00 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sat, 21 Mar 2009 15:56:00 +0100
Subject: [Avidemux-svn-commit] r4701 - in branches/avidemux_2.6_branch_mean:
	avidemux/ADM_audioFilter/include avidemux/ADM_audioFilter/src
	avidemux/ADM_audiofilter avidemux/ADM_coreAudioEncoder/include
	plugins/ADM_audioEncoders plugins/ADM_audioEncoders/lame
	plugins/ADM_audioEncoders/twolame
Message-ID: <200903211456.n2LEu0nf003465@sheep.berlios.de>

Author: mean
Date: 2009-03-21 15:56:00 +0100 (Sat, 21 Mar 2009)
New Revision: 4701

Added:
   branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/include/audioEncoderApi.h
   branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/src/audiofilter_encoder.cpp
Removed:
   branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audioEncoderApi.h
Modified:
   branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/include/audiofilter_access.h
   branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/src/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/src/audiofilter.cpp
   branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/src/audiofilter_access.cpp
   branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audioeng_buildfilters.h
   branches/avidemux_2.6_branch_mean/avidemux/ADM_coreAudioEncoder/include/audioencoderInternal.h
   branches/avidemux_2.6_branch_mean/plugins/ADM_audioEncoders/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/plugins/ADM_audioEncoders/lame/audioencoder_lame.cpp
   branches/avidemux_2.6_branch_mean/plugins/ADM_audioEncoders/lame/audioencoder_lame.h
   branches/avidemux_2.6_branch_mean/plugins/ADM_audioEncoders/twolame/audioencoder_twolame.cpp
   branches/avidemux_2.6_branch_mean/plugins/ADM_audioEncoders/twolame/audioencoder_twolame.h
   branches/avidemux_2.6_branch_mean/plugins/ADM_audioEncoders/twolame/audioencoder_twolame_param.h
Log:
[Audio] Hook encoder and filter chain to create audio access when encoding

Copied: branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/include/audioEncoderApi.h (from rev 4700, branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audioEncoderApi.h)
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audioEncoderApi.h	2009-03-21 14:55:57 UTC (rev 4700)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/include/audioEncoderApi.h	2009-03-21 14:56:00 UTC (rev 4701)
@@ -0,0 +1,35 @@
+/**
+    \file audioEncoderApi.h
+    \brief Helper functions to deal with audioEncoders
+
+*/
+#ifndef AUDIOENCODERAPI_H
+#define AUDIOENCODERAPI_H
+
+/// Select the best encoder using the audio fourcc : WAV_MP3 etc...
+uint8_t audio_selectCodecByTag(uint32_t tag);
+/// Set an option for example "DISABLERESERVOIR",1
+uint8_t audioSetOption(const char *option, uint32_t value);
+/// Select the copy Codec
+uint8_t audio_setCopyCodec(void);
+/// Directly set the codec, *only to be used
+uint8_t audioCodecSetByIndex(int i);
+/// Spawn a new encoder
+ADM_AudioEncoder *audioEncoderCreate(AUDMAudioFilter *filter);
+/// Select a encoder by its name e.g. "lame", used only by JS. Update UI as well
+uint8_t audioCodecSetByName( const char *name);
+/// Returns the name of the currently selected codec
+const char *audioCodecGetName( void );
+/// Update the UI with the currently selected codec
+void audioPrintCurrentCodec(void);
+/// Returns 1 if we are in process mode, 0 if in copy mode
+uint32_t audioProcessMode(void);
+/// Retrieve current audio encoder configuration
+uint8_t getAudioExtraConf(uint32_t *bitrate,uint32_t *extraDataSize, uint8_t **extradata);
+/// Set current audio encoder configuration
+uint8_t setAudioExtraConf(uint32_t bitrate,uint32_t extraDataSize, uint8_t *extradata);
+
+
+
+#endif
+// EOF

Modified: branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/include/audiofilter_access.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/include/audiofilter_access.h	2009-03-21 14:55:57 UTC (rev 4700)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/include/audiofilter_access.h	2009-03-21 14:56:00 UTC (rev 4701)
@@ -16,6 +16,7 @@
 #define AUDM_ACCESS_H
 
 #include "ADM_audioStream.h"
+class ADM_AudioEncoder;
 /**
     \class ADMAudioFilter_Access
     \brief Bridge audioFilter->Access
@@ -28,10 +29,11 @@
     AUDMAudioFilter     *filter;
     WAVHeader           header;
     uint64_t            samplesSeen;
+    ADM_AudioEncoder    *encoder;
   public:
                 WAVHeader         *getWavHeader(void) {return &header;}
 
-                                    ADMAudioFilter_Access(AUDMAudioFilter *incoming,uint64_t timeUs) ;
+                                    ADMAudioFilter_Access(AUDMAudioFilter *incoming,ADM_AudioEncoder *encoder,uint64_t timeUs) ;
                 virtual           ~ADMAudioFilter_Access();
                                     /// Return true if the demuxer can seek in time
                 virtual bool      canSeekTime(void) {return false;};

Modified: branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/src/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/src/CMakeLists.txt	2009-03-21 14:55:57 UTC (rev 4700)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/src/CMakeLists.txt	2009-03-21 14:56:00 UTC (rev 4701)
@@ -1,5 +1,8 @@
 # Filters
 SET(ADM_audioFilter_SRCS
+
+audio_encoderPlugin.cpp
+
 audiofilter_bridge.cpp
 audiofilter_access.cpp
 audiofilter_mixer.cpp
@@ -8,7 +11,7 @@
 audiofilter_limiter.cpp
 audiofilter_normalize.cpp
 audiofilter_SRC.cpp
-audio_encoderPlugin.cpp
+audiofilter_encoder.cpp
 ADM_audioResample.cpp
 audiofilter.cpp
 ADM_libsamplerate/samplerate.c  

Modified: branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/src/audiofilter.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/src/audiofilter.cpp	2009-03-21 14:55:57 UTC (rev 4700)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/src/audiofilter.cpp	2009-03-21 14:56:00 UTC (rev 4701)
@@ -26,8 +26,8 @@
 extern ADM_Composer *video_body;
 
 //
-static bool ADM_buildFilterChain(VectorOfAudioFilter *vec,ADM_AUDIOFILTER_CONFIG *config);
-static bool ADM_emptyFilterChain(VectorOfAudioFilter *vec);
+ bool ADM_buildFilterChain(VectorOfAudioFilter *vec,ADM_AUDIOFILTER_CONFIG *config);
+ bool ADM_emptyFilterChain(VectorOfAudioFilter *vec);
 /**
         \fn createPlaybackFilter
         \brief Create a float output filter for playback

Modified: branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/src/audiofilter_access.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/src/audiofilter_access.cpp	2009-03-21 14:55:57 UTC (rev 4700)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/src/audiofilter_access.cpp	2009-03-21 14:56:00 UTC (rev 4701)
@@ -19,12 +19,17 @@
 
 #include "ADM_audioFilter.h"
 #include "audiofilter_access.h"
+#include "audioencoder.h"
+
+extern bool            destroyEncodingFilter(void);
+
 /**
     \fn ADMAudioFilter_Access
 */
-ADMAudioFilter_Access::ADMAudioFilter_Access(AUDMAudioFilter *incoming,uint64_t timeUs)
+ADMAudioFilter_Access::ADMAudioFilter_Access(AUDMAudioFilter *incoming,ADM_AudioEncoder *encoder,uint64_t timeUs)
 {
     filter=incoming;
+    this->encoder=encoder;
     ADM_assert(filter);
     startTimeUs=timeUs;
     memcpy(&header,incoming->getInfo(),sizeof(header));
@@ -37,6 +42,16 @@
 ADMAudioFilter_Access::~ADMAudioFilter_Access()
 {
     printf("[FilterAccess] Destroyed\n");
+    if(filter)
+    {
+        destroyEncodingFilter();
+        filter=NULL;
+    }
+    if(encoder)
+    {
+        delete encoder;
+        encoder=NULL;
+    }
 }
 /**
     \fn setPos
@@ -61,21 +76,18 @@
 */                
 bool    ADMAudioFilter_Access::getPacket(uint8_t *buffer, uint32_t *size, uint32_t maxSize,uint64_t *dts)
 {
-    maxSize/=sizeof(float);
-    *size=0;
-
-    AUD_Status status;
-    uint32_t rd=filter->fill(maxSize,(float *)buffer,&status);
-    if(!rd)
+    uint32_t samples;
+    bool r=encoder->encode(buffer,size,&samples);
+    if(false==r)
     {
-        printf("[Filter_access] Fill error!\n");
+        printf("[Access] getpacket failed for encoding\n");
         return false;
     }
-    *size=rd*sizeof(float);
 
-    float d=(float)samplesSeen/(float)(rd/header.channels);
+    float d=(float)samplesSeen/(float)(header.frequency);
+    d*=1000*1000;
     *dts=startTimeUs+(uint64_t)d;
-    samplesSeen+=(rd/header.channels);
+    samplesSeen+=samples;
     return true;
 }
 

Added: branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/src/audiofilter_encoder.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/src/audiofilter_encoder.cpp	2009-03-21 14:55:57 UTC (rev 4700)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/src/audiofilter_encoder.cpp	2009-03-21 14:56:00 UTC (rev 4701)
@@ -0,0 +1,95 @@
+/***************************************************************************
+            \file audiofilter_encoder.cpp
+            \brief Generate a access class = to the output of encoder + filterchain
+              (c) 2006 Mean , fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+
+#include "ADM_default.h"
+#include <math.h>
+
+#include "audiofilter_bridge.h"
+#include "audiofilter_access.h"
+#include "audiofilter_internal.h"
+#include "audiofilter_conf.h"
+#include "audioencoder.h"
+#include "audioEncoderApi.h"
+
+VectorOfAudioFilter EncodingVector;
+extern ADM_Composer *video_body;
+
+//
+ extern bool ADM_buildFilterChain(VectorOfAudioFilter *vec,ADM_AUDIOFILTER_CONFIG *config);
+ extern bool ADM_emptyFilterChain(VectorOfAudioFilter *vec);
+/**
+        \fn createPlaybackFilter
+        \brief Create a float output filter for playback
+        @param StartTime in us
+        @param shift in ms
+*/
+AUDMAudioFilter *createEncodingFilter(uint64_t startTime,int32_t shift)
+{
+    //
+    ADM_AUDIOFILTER_CONFIG playback;
+    playback.startTimeInUs=startTime;
+    playback.shiftInMs=shift;
+    playback.mixerEnabled=true;
+    playback.mixerConf=CHANNEL_STEREO;
+    //
+    ADM_buildFilterChain(&EncodingVector,&playback);
+    //
+    int last=EncodingVector.size();
+    ADM_assert(last);
+    return EncodingVector[last-1];
+}
+/**
+        \fn destroyPlaybackFilter
+        \brief Destroy a float output filter for playback
+*/
+
+bool            destroyEncodingFilter(void)
+{
+
+    ADM_emptyFilterChain(&EncodingVector);
+    return true;
+
+}
+/**
+    \fn createEncodingAccess
+*/
+ADM_audioAccess *createEncodingAccess(uint64_t startTime,int32_t shift)
+{
+    printf("[AccessFilter] Creating access filter\n");
+    // 1-Create access filter
+    AUDMAudioFilter *filter=createEncodingFilter(startTime,shift);
+    if(!filter)
+    {
+        printf("[Access] Cannot create audio filter\n");
+        return NULL;
+    }
+
+    // 2- spawn encoder
+    ADM_AudioEncoder *encoder=audioEncoderCreate(filter);
+    if(!encoder) 
+    {
+        printf("[Access] Cannot create audio encoder\n");
+        return NULL;
+    }
+    // 3- Create access
+    ADM_audioAccess *access=new ADMAudioFilter_Access(filter,encoder,0);
+    if(!access)
+    {
+        printf("[Access] Cannot create access\n");
+    }
+    return access;
+}
+// EOF
\ No newline at end of file

Deleted: branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audioEncoderApi.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audioEncoderApi.h	2009-03-21 14:55:57 UTC (rev 4700)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audioEncoderApi.h	2009-03-21 14:56:00 UTC (rev 4701)
@@ -1,35 +0,0 @@
-/**
-    \file audioEncoderApi.h
-    \brief Helper functions to deal with audioEncoders
-
-*/
-#ifndef AUDIOENCODERAPI_H
-#define AUDIOENCODERAPI_H
-
-/// Select the best encoder using the audio fourcc : WAV_MP3 etc...
-uint8_t audio_selectCodecByTag(uint32_t tag);
-/// Set an option for example "DISABLERESERVOIR",1
-uint8_t audioSetOption(const char *option, uint32_t value);
-/// Select the copy Codec
-uint8_t audio_setCopyCodec(void);
-/// Directly set the codec, *only to be used
-uint8_t audioCodecSetByIndex(int i);
-/// Spawn a new encoder
-ADM_AudioEncoder *audioEncoderCreate(AUDMAudioFilter *filter);
-/// Select a encoder by its name e.g. "lame", used only by JS. Update UI as well
-uint8_t audioCodecSetByName( const char *name);
-/// Returns the name of the currently selected codec
-const char *audioCodecGetName( void );
-/// Update the UI with the currently selected codec
-void audioPrintCurrentCodec(void);
-/// Returns 1 if we are in process mode, 0 if in copy mode
-uint32_t audioProcessMode(void);
-/// Retrieve current audio encoder configuration
-uint8_t getAudioExtraConf(uint32_t *bitrate,uint32_t *extraDataSize, uint8_t **extradata);
-/// Set current audio encoder configuration
-uint8_t setAudioExtraConf(uint32_t bitrate,uint32_t extraDataSize, uint8_t *extradata);
-
-
-
-#endif
-// EOF

Modified: branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audioeng_buildfilters.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audioeng_buildfilters.h	2009-03-21 14:55:57 UTC (rev 4700)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audioeng_buildfilters.h	2009-03-21 14:56:00 UTC (rev 4701)
@@ -20,7 +20,7 @@
 #include "audioencoder.h"
 #include "ADM_audio/aviaudio.hxx"
 
-#include "ADM_audiofilter/audioEncoderApi.h"
+#include "audioEncoderApi.h"
 #include "ADM_audioStream.h"
 
  ADM_audioStream *buildAudioFilter(ADM_audioStream *stream, uint32_t startTime);

Modified: branches/avidemux_2.6_branch_mean/avidemux/ADM_coreAudioEncoder/include/audioencoderInternal.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_coreAudioEncoder/include/audioencoderInternal.h	2009-03-21 14:55:57 UTC (rev 4700)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_coreAudioEncoder/include/audioencoderInternal.h	2009-03-21 14:56:00 UTC (rev 4701)
@@ -34,7 +34,7 @@
     uint32_t     apiVersion;            // const
     ADM_AudioEncoder *(*create)(AUDMAudioFilter *head);  
     void         (*destroy)(ADM_AudioEncoder *codec);
-    uint8_t      (*configure)(void);    
+    bool         (*configure)(void);    
     const char   *codecName;        // Internal name (tag)
     const char   *menuName;         // Displayed name (in menu)
     const char   *description;
@@ -42,13 +42,13 @@
     uint32_t     major,minor,patch;     // Const
     uint32_t     wavTag;                // const Avi fourcc
     uint32_t     priority;              // const Higher means the codec is prefered and should appear first in the list
-    uint8_t      (*getConfigurationData)(uint32_t *l, uint8_t **d); // Get the encoder private conf
-    uint8_t      (*setConfigurationData)(uint32_t l, uint8_t *d); // Get the encoder private conf
+    bool         (*getConfigurationData)(uint32_t *l, uint8_t **d); // Get the encoder private conf
+    bool         (*setConfigurationData)(uint32_t l, uint8_t *d); // Get the encoder private conf
 
     uint32_t     (*getBitrate)(void);
     void         (*setBitrate)(uint32_t br);
  
-    uint8_t      (*setOption)(const char *paramName, uint32_t value);
+    bool         (*setOption)(const char *paramName, uint32_t value);
 
     void         *opaque;               // Hide stuff in here
 }ADM_audioEncoder;
@@ -56,8 +56,8 @@
 // Macros to declare audio encoder
 /**************************************************************************/
 #define ADM_DECLARE_AUDIO_ENCODER_PREAMBLE(Class) \
-static uint8_t getConfigurationData (uint32_t * l, uint8_t ** d); \
-static uint8_t setConfigurationData (uint32_t l, uint8_t * d);\
+static bool getConfigurationData (uint32_t * l, uint8_t ** d); \
+static bool setConfigurationData (uint32_t l, uint8_t * d);\
 static uint32_t     getBitrate(void); \
 static void         setBitrate(uint32_t br); \
 \
@@ -72,13 +72,13 @@
 } 
 //******************************************************
 #define ADM_DECLARE_AUDIO_ENCODER_CONFIG(configData) \
-uint8_t getConfigurationData (uint32_t * l, uint8_t ** d)\
+bool getConfigurationData (uint32_t * l, uint8_t ** d)\
 {\
   *l = sizeof (configData); \
   *d = (uint8_t *) & configData; \
   return 1; \
 } \
-uint8_t setConfigurationData (uint32_t l, uint8_t * d)\
+bool setConfigurationData (uint32_t l, uint8_t * d)\
 {\
   if (sizeof (configData) != l) \
     {\

Modified: branches/avidemux_2.6_branch_mean/plugins/ADM_audioEncoders/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_audioEncoders/CMakeLists.txt	2009-03-21 14:55:57 UTC (rev 4700)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_audioEncoders/CMakeLists.txt	2009-03-21 14:56:00 UTC (rev 4701)
@@ -9,7 +9,7 @@
 MESSAGE("***  /Audio Codec  ***")
 
 
-#ADD_SUBDIRECTORY(twolame)
+ADD_SUBDIRECTORY(twolame)
 #ADD_SUBDIRECTORY(pcm)
 #ADD_SUBDIRECTORY(lavcodec)
 

Modified: branches/avidemux_2.6_branch_mean/plugins/ADM_audioEncoders/lame/audioencoder_lame.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_audioEncoders/lame/audioencoder_lame.cpp	2009-03-21 14:55:57 UTC (rev 4700)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_audioEncoders/lame/audioencoder_lame.cpp	2009-03-21 14:56:00 UTC (rev 4701)
@@ -31,8 +31,8 @@
 };
 extern "C"
 {
-static uint8_t configure (void);
-static uint8_t setOption(const char *paramName, uint32_t value);
+static bool configure (void);
+static bool setOption(const char *paramName, uint32_t value);
 };
 /********************* Declare Plugin *****************************************************/
 ADM_DECLARE_AUDIO_ENCODER_PREAMBLE(AUDMEncoder_Lame);
@@ -252,7 +252,7 @@
 */
 #define QT_TR_NOOP(x) x
 
-uint8_t configure (void)
+bool configure (void)
 {
   int ret = 0;
   char string[400];
@@ -301,7 +301,7 @@
      \fn setOption
      \brief Allow giving codec specific options as string+value
 */
-uint8_t setOption(const char *paramName, uint32_t value)
+bool setOption(const char *paramName, uint32_t value)
 {
     if(!strcasecmp(paramName,"MP3DisableReservoir"))
     {

Modified: branches/avidemux_2.6_branch_mean/plugins/ADM_audioEncoders/lame/audioencoder_lame.h
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_audioEncoders/lame/audioencoder_lame.h	2009-03-21 14:55:57 UTC (rev 4700)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_audioEncoders/lame/audioencoder_lame.h	2009-03-21 14:56:00 UTC (rev 4701)
@@ -1,5 +1,6 @@
 
 /***************************************************************************
+    \file audioencoder_lame.h
     copyright            : (C) 2002-6 by mean
     email                : fixounet at free.fr
  ***************************************************************************/

Modified: branches/avidemux_2.6_branch_mean/plugins/ADM_audioEncoders/twolame/audioencoder_twolame.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_audioEncoders/twolame/audioencoder_twolame.cpp	2009-03-21 14:55:57 UTC (rev 4700)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_audioEncoders/twolame/audioencoder_twolame.cpp	2009-03-21 14:56:00 UTC (rev 4701)
@@ -1,5 +1,6 @@
 /***************************************************************************
-    copyright            : (C) 2006 by mean
+    \file audioencoder_twolame.cpp
+    copyright            : (C) 2006/2009 by mean
     email                : fixounet at free.fr
  ***************************************************************************/
 
@@ -32,10 +33,9 @@
 
 static TWOLAME_encoderParam twolameParam=
 {
-    128,
-    ADM_STEREO
+    128
 };
-static uint8_t configure (void);
+static bool configure (void);
 /********************* Declare Plugin *****************************************************/
 ADM_DECLARE_AUDIO_ENCODER_PREAMBLE(AUDMEncoder_Twolame);
 
@@ -64,15 +64,19 @@
 ADM_DECLARE_AUDIO_ENCODER_CONFIG(twolameParam);
 
 /******************* / Declare plugin*******************************************************/
+/**
 
-AUDMEncoder_Twolame::AUDMEncoder_Twolame(AUDMAudioFilter * instream)  :AUDMEncoder    (instream)
+*/
+AUDMEncoder_Twolame::AUDMEncoder_Twolame(AUDMAudioFilter * instream)  :ADM_AudioEncoder    (instream)
 {
   printf("[TwoLame] Creating Twolame\n");
   _twolameOptions=NULL;
-  _wavheader->encoding=WAV_MP2;
+  wavheader.encoding=WAV_MP2;
 };
 
+/**
 
+*/
 AUDMEncoder_Twolame::~AUDMEncoder_Twolame()
 {
   printf("[TwoLame] Deleting TwoLame\n");
@@ -81,62 +85,45 @@
     twolame_close((twolame_options_struct **)&_twolameOptions);
   }
   _twolameOptions=NULL;
-  cleanup();
+
 };
 /**
     \fn initialize
 
 */
-uint8_t AUDMEncoder_Twolame::initialize(void)
+bool AUDMEncoder_Twolame::initialize(void)
 {
   int ret;
   TWOLAME_MPEG_mode mmode;
   uint32_t frequence;
   TWOLAME_encoderParam *lameConf=&twolameParam;
+    int channels=wavheader.channels;
 
-
   _twolameOptions = twolame_init();
   if (_twolameOptions == NULL)
     return 0;
 
-  if(_wavheader->channels>2)
+  if(channels>2)
   {
     printf("[TwoLame]Too many channels\n");
     return 0;
   }
-  _wavheader->byterate=(lameConf->bitrate*1000)>>3;
+  wavheader.byterate=(lameConf->bitrate*1000)>>3;
 
 
-  _chunk = 1152*_wavheader->channels;
+  _chunk = 1152*channels;
 
 
   printf("[TwoLame]Incoming :fq : %"LU", channel : %"LU" bitrate: %"LU" \n",
-        _wavheader->frequency,_wavheader->channels,lameConf->bitrate);
+        wavheader.frequency,channels,lameConf->bitrate);
 
 
-  twolame_set_in_samplerate(OPTIONS, _wavheader->frequency);
-  twolame_set_out_samplerate (OPTIONS, _wavheader->frequency);
-  twolame_set_num_channels(OPTIONS, _wavheader->channels);
-  if(_wavheader->channels==1) mmode=TWOLAME_MONO;
+  twolame_set_in_samplerate(OPTIONS, wavheader.frequency);
+  twolame_set_out_samplerate (OPTIONS, wavheader.frequency);
+  twolame_set_num_channels(OPTIONS, channels);
+  if(channels==1) mmode=TWOLAME_MONO;
   else
-    switch (lameConf->mode)
-  {
-    case ADM_STEREO:
       mmode = TWOLAME_STEREO;
-      break;
-    case ADM_JSTEREO:
-      mmode = TWOLAME_JOINT_STEREO;
-      break;
-    case ADM_MONO:
-      mmode=TWOLAME_MONO;
-      break;
-
-    default:
-      printf("\n **** unknown mode, going stereo ***\n");
-      mmode = TWOLAME_STEREO;
-      break;
-
-  }
   twolame_set_mode(OPTIONS,mmode);
   twolame_set_error_protection(OPTIONS,TRUE);
     	//toolame_setPadding (options,TRUE);
@@ -145,38 +132,35 @@
   if(twolame_init_params(OPTIONS))
   {
     printf("[TwoLame]Twolame init failed\n");
-    return 0;
+    return false;
   }
-
-
-
   printf("[TwoLame]Libtoolame successfully initialized\n");
-  return 1;
+  return true;
 }
 /**
         \fn getPacket
 */
-uint8_t	AUDMEncoder_Twolame::getPacket(uint8_t *dest, uint32_t *len, uint32_t *samples)
+bool 	AUDMEncoder_Twolame::encode(uint8_t *dest, uint32_t *len, uint32_t *samples)
 {
   int nbout;
-
+  int channels=wavheader.channels;
   *samples = 1152; //FIXME
   *len = 0;
   ADM_assert(tmptail>=tmphead);
   if(!refillBuffer(_chunk ))
   {
-    return 0;
+    return false;
   }
 
   if(tmptail-tmphead<_chunk)
   {
-    return 0;
+    return false;
   }
 
-  dither16(&(tmpbuffer[tmphead]),_chunk,_wavheader->channels);
+  dither16(&(tmpbuffer[tmphead]),_chunk,channels);
 
   ADM_assert(tmptail>=tmphead);
-  if (_wavheader->channels == 1)
+  if (channels == 1)
   {
     nbout =twolame_encode_buffer(OPTIONS, (int16_t *)&(tmpbuffer[tmphead]),(int16_t *)&(tmpbuffer[tmphead]), _chunk, dest, 16 * 1024);
   }
@@ -187,11 +171,11 @@
   tmphead+=_chunk;
   ADM_assert(tmptail>=tmphead);
   if (nbout < 0) {
-    printf("\n Error !!! : %d\n", nbout);
-    return 0;
+    printf("[TwoLame] Error !!! : %d\n", nbout);
+    return false;
   }
   *len=nbout;
-  return 1;
+  return true;
 }
 #define SZT(x) sizeof(x)/sizeof(diaMenuEntry )
 #define BITRATE(x) {x,QT_TR_NOOP(#x)}
@@ -199,18 +183,10 @@
 /**
     \fn configure
 */
-uint8_t configure (void)
+bool configure (void)
 {
  int ret=0;
 
-  uint32_t m=(uint32_t)twolameParam.mode;
-
-    diaMenuEntry channelMode[] =
-    {
-        {ADM_STEREO, QT_TR_NOOP ("Stereo"), NULL},
-        {ADM_JSTEREO, QT_TR_NOOP ("Joint stereo"), NULL},
-        {ADM_MONO, QT_TR_NOOP ("Mono"), NULL}
-    };
     diaMenuEntry bitrateM[]={
                               BITRATE(56),
                               BITRATE(64),
@@ -225,16 +201,15 @@
                           };
     diaElemMenu bitrate(&(twolameParam.bitrate),   QT_TR_NOOP("_Bitrate:"), SZT(bitrateM),bitrateM);
 
-    diaElemMenu menuMode (&m, QT_TR_NOOP ("C_hannel mode:"),SZT (channelMode), channelMode);
 
-    diaElem *elems[]={&bitrate,&menuMode};
+    diaElem *elems[]={&bitrate};
 
-    if( diaFactoryRun(QT_TR_NOOP("TwoLame Configuration"),2,elems))
+    if( diaFactoryRun(QT_TR_NOOP("TwoLame Configuration"),1,elems))
     {
-        twolameParam.mode=(ADM_mode)m;
-        return 1;
+        
+        return true;
     }
 
-    return 0;
+    return false;
 }
 // EOF

Modified: branches/avidemux_2.6_branch_mean/plugins/ADM_audioEncoders/twolame/audioencoder_twolame.h
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_audioEncoders/twolame/audioencoder_twolame.h	2009-03-21 14:55:57 UTC (rev 4700)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_audioEncoders/twolame/audioencoder_twolame.h	2009-03-21 14:56:00 UTC (rev 4701)
@@ -1,5 +1,6 @@
 /***************************************************************************
-    copyright            : (C) 2002-6 by mean
+    \file audioencoder_twolame.h
+    copyright            : (C) 2002-9 by mean
     email                : fixounet at free.fr
  ***************************************************************************/
 
@@ -15,16 +16,18 @@
 #define AUDMaudioTwoLame
 
  //_____________________________________________
-class AUDMEncoder_Twolame : public AUDMEncoder
+class AUDMEncoder_Twolame : public ADM_AudioEncoder
 {
   protected:
     void           *_twolameOptions;
+    uint32_t        _chunk;
          
   public:
-            uint8_t     initialize(void);
+            bool     initialize(void);
     virtual             ~AUDMEncoder_Twolame();
                         AUDMEncoder_Twolame(AUDMAudioFilter *instream);	
-    virtual uint8_t	    getPacket(uint8_t *dest, uint32_t *len, uint32_t *samples);
+    virtual bool    encode(uint8_t *dest, uint32_t *len, uint32_t *samples);
+    virtual bool    isVBR(void) {return false;}
 };
 
 #endif

Modified: branches/avidemux_2.6_branch_mean/plugins/ADM_audioEncoders/twolame/audioencoder_twolame_param.h
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_audioEncoders/twolame/audioencoder_twolame_param.h	2009-03-21 14:55:57 UTC (rev 4700)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_audioEncoders/twolame/audioencoder_twolame_param.h	2009-03-21 14:56:00 UTC (rev 4701)
@@ -10,7 +10,7 @@
 typedef struct 
 {
   uint32_t        bitrate;
-  ADM_mode        mode;
+
 }TWOLAME_encoderParam;
 
 #endif



From mean at mail.berlios.de  Sat Mar 21 15:56:02 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sat, 21 Mar 2009 15:56:02 +0100
Subject: [Avidemux-svn-commit] r4702 - in
	branches/avidemux_2.6_branch_mean/avidemux: .
	ADM_audioFilter/include ADM_audioFilter/src
Message-ID: <200903211456.n2LEu2AR003475@sheep.berlios.de>

Author: mean
Date: 2009-03-21 15:56:02 +0100 (Sat, 21 Mar 2009)
New Revision: 4702

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/include/audiofilter_access.h
   branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/src/audiofilter_access.cpp
   branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/src/audiofilter_encoder.cpp
   branches/avidemux_2.6_branch_mean/avidemux/gui_savenew.cpp
Log:
[Audio] Began hooking encoding access and muxers (incomplete/crash)

Modified: branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/include/audiofilter_access.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/include/audiofilter_access.h	2009-03-21 14:56:00 UTC (rev 4701)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/include/audiofilter_access.h	2009-03-21 14:56:02 UTC (rev 4702)
@@ -16,7 +16,7 @@
 #define AUDM_ACCESS_H
 
 #include "ADM_audioStream.h"
-class ADM_AudioEncoder;
+#include "audioencoder.h"
 /**
     \class ADMAudioFilter_Access
     \brief Bridge audioFilter->Access
@@ -27,11 +27,10 @@
   protected:
     uint64_t            startTimeUs; /*< Starting time in us */
     AUDMAudioFilter     *filter;
-    WAVHeader           header;
     uint64_t            samplesSeen;
     ADM_AudioEncoder    *encoder;
   public:
-                WAVHeader         *getWavHeader(void) {return &header;}
+                WAVHeader         *getWavHeader(void) {return encoder->getInfo();}
 
                                     ADMAudioFilter_Access(AUDMAudioFilter *incoming,ADM_AudioEncoder *encoder,uint64_t timeUs) ;
                 virtual           ~ADMAudioFilter_Access();

Modified: branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/src/audiofilter_access.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/src/audiofilter_access.cpp	2009-03-21 14:56:00 UTC (rev 4701)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/src/audiofilter_access.cpp	2009-03-21 14:56:02 UTC (rev 4702)
@@ -32,7 +32,6 @@
     this->encoder=encoder;
     ADM_assert(filter);
     startTimeUs=timeUs;
-    memcpy(&header,incoming->getInfo(),sizeof(header));
     samplesSeen=0;
     printf("[FilterAccess] Created, starting at %"LU" ms\n",(uint32_t)(timeUs/1000));
 }
@@ -84,7 +83,7 @@
         return false;
     }
 
-    float d=(float)samplesSeen/(float)(header.frequency);
+    float d=(float)samplesSeen/(float)(filter->getInfo()->frequency);
     d*=1000*1000;
     *dts=startTimeUs+(uint64_t)d;
     samplesSeen+=samples;

Modified: branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/src/audiofilter_encoder.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/src/audiofilter_encoder.cpp	2009-03-21 14:56:00 UTC (rev 4701)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/src/audiofilter_encoder.cpp	2009-03-21 14:56:02 UTC (rev 4702)
@@ -66,7 +66,7 @@
 /**
     \fn createEncodingAccess
 */
-ADM_audioAccess *createEncodingAccess(uint64_t startTime,int32_t shift)
+ADM_audioStream *createEncodingStream(uint64_t startTime,int32_t shift)
 {
     printf("[AccessFilter] Creating access filter\n");
     // 1-Create access filter
@@ -85,11 +85,17 @@
         return NULL;
     }
     // 3- Create access
-    ADM_audioAccess *access=new ADMAudioFilter_Access(filter,encoder,0);
+    ADMAudioFilter_Access *access=new ADMAudioFilter_Access(filter,encoder,0);
     if(!access)
     {
         printf("[Access] Cannot create access\n");
     }
-    return access;
+    // 4- Create Stream // MEMLEAK!!!!
+    ADM_audioStream *stream=ADM_audioCreateStream(access->getWavHeader(), access);
+    if(!access)
+    {
+        printf("[Access] Cannot create access\n");
+    }
+    return (ADM_audioStream *)access;
 }
 // EOF
\ No newline at end of file

Modified: branches/avidemux_2.6_branch_mean/avidemux/gui_savenew.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/gui_savenew.cpp	2009-03-21 14:56:00 UTC (rev 4701)
+++ branches/avidemux_2.6_branch_mean/avidemux/gui_savenew.cpp	2009-03-21 14:56:02 UTC (rev 4702)
@@ -47,6 +47,8 @@
  extern uint8_t mpeg_passthrough(const char *name,ADM_OUT_FORMAT format);
 ADM_muxer *ADM_MuxerSpawnFromIndex(int index);
 
+extern ADM_audioStream *createEncodingStream(uint64_t startTime,int32_t shift);
+
 /**
     \fn A_Save
 */
@@ -74,7 +76,21 @@
     // Video Stream ?
     ADM_videoStream *video=new ADM_videoStreamCopy();
     //
-    ADM_audioStream *astreams[1]={audio};
+    ADM_audioStream *astreams[1];
+    if (!audioProcessMode())
+    {
+        astreams[0]=audio;
+    }else   
+    {
+        if(audio)
+        {
+            // Access..
+            ADM_audioStream *access=createEncodingStream(0,0); // FIXME LEAK
+            astreams[0]=access;
+
+            
+        }
+    }
     if(!muxer->open(name,video,nbAStream,astreams))
     {
         GUI_Error_HIG("Muxer","Cannot open ");
@@ -87,6 +103,8 @@
     //
 
     if(muxer) delete muxer;
+    if (!audioProcessMode() && astreams[0])
+        delete astreams[0];
     return ret;
 }
 #if 0



From mean at mail.berlios.de  Sun Mar 22 16:04:54 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sun, 22 Mar 2009 16:04:54 +0100
Subject: [Avidemux-svn-commit] r4703 - in
	branches/avidemux_2.6_branch_mean/avidemux:
	ADM_audioFilter/include ADM_audioFilter/src
	ADM_coreAudioEncoder/src ADM_editor
Message-ID: <200903221504.n2MF4sjA017259@sheep.berlios.de>

Author: mean
Date: 2009-03-22 16:04:53 +0100 (Sun, 22 Mar 2009)
New Revision: 4703

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/include/audiofilter_access.h
   branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/src/audiofilter_access.cpp
   branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/src/audiofilter_encoder.cpp
   branches/avidemux_2.6_branch_mean/avidemux/ADM_coreAudioEncoder/src/audioencoder.cpp
   branches/avidemux_2.6_branch_mean/avidemux/ADM_editor/ADMedAVIAUD.cpp
Log:
[Audio] continue hooking audio to muxers

Modified: branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/include/audiofilter_access.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/include/audiofilter_access.h	2009-03-21 14:56:02 UTC (rev 4702)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/include/audiofilter_access.h	2009-03-22 15:04:53 UTC (rev 4703)
@@ -56,6 +56,7 @@
 
                 
                 virtual bool    getPacket(uint8_t *buffer, uint32_t *size, uint32_t maxSize,uint64_t *dts);    
+                virtual bool    isCBR(void);
 };
 
 

Modified: branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/src/audiofilter_access.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/src/audiofilter_access.cpp	2009-03-21 14:56:02 UTC (rev 4702)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/src/audiofilter_access.cpp	2009-03-22 15:04:53 UTC (rev 4703)
@@ -53,6 +53,14 @@
     }
 }
 /**
+    \fn isCBR
+*/
+bool      ADMAudioFilter_Access::isCBR(void)
+{
+    if(encoder->isVBR()) return false;
+    return true;
+}
+/**
     \fn setPos
     \brief only goto 0 is allowed
 */

Modified: branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/src/audiofilter_encoder.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/src/audiofilter_encoder.cpp	2009-03-21 14:56:02 UTC (rev 4702)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/src/audiofilter_encoder.cpp	2009-03-22 15:04:53 UTC (rev 4703)
@@ -82,20 +82,33 @@
     if(!encoder) 
     {
         printf("[Access] Cannot create audio encoder\n");
+        destroyEncodingFilter();
         return NULL;
     }
+    if(true!=encoder->initialize())
+    {
+        printf("[Access] Encoder initialization failed\n");
+        delete encoder;
+        destroyEncodingFilter();
+        return NULL;
+    }
     // 3- Create access
     ADMAudioFilter_Access *access=new ADMAudioFilter_Access(filter,encoder,0);
     if(!access)
     {
         printf("[Access] Cannot create access\n");
+        delete encoder;
+        destroyEncodingFilter();
+        return NULL;
     }
     // 4- Create Stream // MEMLEAK!!!!
-    ADM_audioStream *stream=ADM_audioCreateStream(access->getWavHeader(), access);
-    if(!access)
+    ADM_audioStream *stream=ADM_audioCreateStream(encoder->getInfo(), access);
+    if(!stream)
     {
-        printf("[Access] Cannot create access\n");
+        printf("[Access] Cannot create stream\n");
+        delete access; // Access will destroy filter & encoder
+        return NULL;
     }
-    return (ADM_audioStream *)access;
+    return stream;
 }
 // EOF
\ No newline at end of file

Modified: branches/avidemux_2.6_branch_mean/avidemux/ADM_coreAudioEncoder/src/audioencoder.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_coreAudioEncoder/src/audioencoder.cpp	2009-03-21 14:56:02 UTC (rev 4702)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_coreAudioEncoder/src/audioencoder.cpp	2009-03-22 15:04:53 UTC (rev 4703)
@@ -31,6 +31,10 @@
     _incoming=in;
     memset(&wavheader,0,sizeof(wavheader));
     tmphead=tmptail=0;
+    WAVHeader  *info=in->getInfo();
+    // Copy channels etc.. from incoming
+    wavheader.channels=info->channels;
+    wavheader.frequency=info->frequency;
 }
 /**
 

Modified: branches/avidemux_2.6_branch_mean/avidemux/ADM_editor/ADMedAVIAUD.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_editor/ADMedAVIAUD.cpp	2009-03-21 14:56:02 UTC (rev 4702)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_editor/ADMedAVIAUD.cpp	2009-03-22 15:04:53 UTC (rev 4703)
@@ -94,6 +94,7 @@
         if(!refillPacketBuffer())
         {
             printf("[Editor] Cannot refill audio\n");
+            return 0;
         }
     }
     // We do now



From mean at mail.berlios.de  Sun Mar 22 16:04:55 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sun, 22 Mar 2009 16:04:55 +0100
Subject: [Avidemux-svn-commit] r4704 -
	branches/avidemux_2.6_branch_mean/avidemux/ADM_coreMuxer/include
Message-ID: <200903221504.n2MF4tml017270@sheep.berlios.de>

Author: mean
Date: 2009-03-22 16:04:55 +0100 (Sun, 22 Mar 2009)
New Revision: 4704

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/ADM_coreMuxer/include/ADM_audioClock.h
Log:
[Audio] avoid overflow

Modified: branches/avidemux_2.6_branch_mean/avidemux/ADM_coreMuxer/include/ADM_audioClock.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_coreMuxer/include/ADM_audioClock.h	2009-03-22 15:04:53 UTC (rev 4703)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_coreMuxer/include/ADM_audioClock.h	2009-03-22 15:04:55 UTC (rev 4704)
@@ -10,7 +10,7 @@
 {
         protected:
                 uint32_t        _frequency;
-                uint32_t        _nbSamples;
+                uint64_t        _nbSamples;
                 uint64_t        _baseClock;
 
         public:



From mean at mail.berlios.de  Sun Mar 22 16:04:58 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sun, 22 Mar 2009 16:04:58 +0100
Subject: [Avidemux-svn-commit] r4705 -
	branches/avidemux_2.6_branch_mean/avidemux/ADM_coreAudio/src
Message-ID: <200903221504.n2MF4wRk017286@sheep.berlios.de>

Author: mean
Date: 2009-03-22 16:04:57 +0100 (Sun, 22 Mar 2009)
New Revision: 4705

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/ADM_coreAudio/src/ADM_audioStreamMP3.cpp
Log:
[StreamMP3] Say it when you are dropping bytes

Modified: branches/avidemux_2.6_branch_mean/avidemux/ADM_coreAudio/src/ADM_audioStreamMP3.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_coreAudio/src/ADM_audioStreamMP3.cpp	2009-03-22 15:04:55 UTC (rev 4704)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_coreAudio/src/ADM_audioStreamMP3.cpp	2009-03-22 15:04:57 UTC (rev 4705)
@@ -112,6 +112,7 @@
                 *size=info.size;
                 read(*size,buffer);
                 *nbSample=info.samples;
+                //if(info.samples!=1152) ADM_assert(0);
                 *dts=lastDts;
                 advanceDtsBySample(*nbSample);
                 return 1;
@@ -119,6 +120,7 @@
             
         }
         //discard one byte
+        printf("[MP3 Stream] Syncing...\n");
         read8();
     }
 }



From mean at mail.berlios.de  Sun Mar 22 16:05:01 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sun, 22 Mar 2009 16:05:01 +0100
Subject: [Avidemux-svn-commit] r4707 -
	branches/avidemux_2.6_branch_mean/plugins/ADM_muxers/muxerAvi
Message-ID: <200903221505.n2MF51gS017316@sheep.berlios.de>

Author: mean
Date: 2009-03-22 16:05:00 +0100 (Sun, 22 Mar 2009)
New Revision: 4707

Modified:
   branches/avidemux_2.6_branch_mean/plugins/ADM_muxers/muxerAvi/muxerAvi.cpp
Log:
[Muxer:Avi]Cosmetic:Display [muxerAvi]

Modified: branches/avidemux_2.6_branch_mean/plugins/ADM_muxers/muxerAvi/muxerAvi.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_muxers/muxerAvi/muxerAvi.cpp	2009-03-22 15:04:59 UTC (rev 4706)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_muxers/muxerAvi/muxerAvi.cpp	2009-03-22 15:05:00 UTC (rev 4707)
@@ -61,7 +61,7 @@
 
 muxerAvi::~muxerAvi()
 {
-    printf("[AVI] Destructing\n");
+    printf("[AviMuxer] Destructing\n");
     if(clocks)
     {
         for(int i=0;i<nbAStreams;i++)
@@ -120,7 +120,7 @@
                     if(audioDts!=ADM_NO_PTS)
                         if( abs(audioDts-clk->getTimeUs())>5000)
                         {
-                            printf("[Avi] Audio skew!");
+                            printf("[AviMuxer] Audio skew!");
                             clk->setTimeUs(audioDts);
                         }
                     nb=writter.saveAudioFrame(audioIndex,audioSize,audioBuffer) ;
@@ -131,7 +131,7 @@
                         if(audioDts>targetDts) break;
                     }
                 }
-                if(!nb) aprintf("[AVI] No audio for video frame %lu\n",targetDts);
+                if(!nb) aprintf("[AviMuxer] No audio for video frame %lu\n",targetDts);
             }
             return true;
 }
@@ -140,7 +140,7 @@
 */
 bool muxerAvi::save(void)
 {
-    printf("[AVI] Saving\n");
+    printf("[AviMuxer] Saving\n");
     uint32_t bufSize=vStream->getWidth()*vStream->getHeight()*3;
 
     uint32_t len,flags;
@@ -158,7 +158,7 @@
     audioBuffer=new uint8_t[AUDIO_BUFFER_SIZE];
     videoBuffer=new uint8_t[bufSize];
 
-    printf("[AVI]avg fps=%u\n",vStream->getAvgFps1000());
+    printf("[AviMuxer]avg fps=%u\n",vStream->getAvgFps1000());
     DIA_encodingBase  *progress=createEncoding(vStream->getAvgFps1000());
     progress->setContainer("AVI");
 
@@ -175,7 +175,7 @@
             {
                 if(!writter.saveVideoFrame( len, flags,videoBuffer))  // Put our real video
                 {
-                        printf("[AVI] Error writting video frame\n");
+                        printf("[AviMuxer] Error writting video frame\n");
                         goto abt;
                 }
                 if(false==vStream->getPacket(&len, videoBuffer, bufSize,&pts,&dts,&flags)) goto abt;
@@ -203,7 +203,7 @@
     videoBuffer=NULL;
     delete [] audioBuffer;
     audioBuffer=NULL;
-    printf("[AVI] Wrote %d frames, nb audio streams %d\n",written,nbAStreams);
+    printf("[AviMuxer] Wrote %d frames, nb audio streams %d\n",written,nbAStreams);
     delete progress;
     return true;
 }
@@ -214,7 +214,7 @@
 bool muxerAvi::close(void)
 {
 
-    printf("[AVI] Closing\n");
+    printf("[AviMuxer] Closing\n");
     return true;
 }
 //EOF



From mean at mail.berlios.de  Sun Mar 22 16:04:59 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sun, 22 Mar 2009 16:04:59 +0100
Subject: [Avidemux-svn-commit] r4706 -
	branches/avidemux_2.6_branch_mean/avidemux/ADM_coreAudio/src
Message-ID: <200903221504.n2MF4xmB017303@sheep.berlios.de>

Author: mean
Date: 2009-03-22 16:04:59 +0100 (Sun, 22 Mar 2009)
New Revision: 4706

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/ADM_coreAudio/src/ADM_audioStreamBuffered.cpp
Log:
[Audio] Fix read16/32on audioStream_buffered

Modified: branches/avidemux_2.6_branch_mean/avidemux/ADM_coreAudio/src/ADM_audioStreamBuffered.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_coreAudio/src/ADM_audioStreamBuffered.cpp	2009-03-22 15:04:57 UTC (rev 4705)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_coreAudio/src/ADM_audioStreamBuffered.cpp	2009-03-22 15:04:59 UTC (rev 4706)
@@ -6,7 +6,7 @@
 #include "ADM_default.h"
 #include "ADM_audioStreamBuffered.h"
 
-#define ADM_MAX_SKEW 30000
+#define ADM_MAX_SKEW 10000
 
 /**
     \fn ADM_audioStreamBuffered
@@ -64,10 +64,10 @@
 uint32_t   ADM_audioStreamBuffered::read16()
 {
 uint32_t r;
-    ADM_assert(start+1<=limit);
+    ADM_assert(start+1<limit);
     r=(buffer[start]<<8)+buffer[start+1];
     start+=2;
-    return start;
+    return r;
 }
 /**
     \fn read32
@@ -75,10 +75,10 @@
 uint32_t   ADM_audioStreamBuffered::read32()
 {
 uint32_t r;
-    ADM_assert(start+3<=limit);
+    ADM_assert(start+3<limit);
     r=(buffer[start]<<24)+(buffer[start+1]<<16)+(buffer[start+2]<<8)+buffer[start+3];
     start+=4;
-    return start;
+    return r;
 }
 /**
         \fn read



From mean at mail.berlios.de  Mon Mar 23 07:44:49 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Mon, 23 Mar 2009 07:44:49 +0100
Subject: [Avidemux-svn-commit] r4708 - in
	branches/avidemux_2.6_branch_mean/plugins/ADM_audioEncoders:
	. faac lavcodec pcm vorbis
Message-ID: <200903230644.n2N6inHs030840@sheep.berlios.de>

Author: mean
Date: 2009-03-23 07:44:48 +0100 (Mon, 23 Mar 2009)
New Revision: 4708

Modified:
   branches/avidemux_2.6_branch_mean/plugins/ADM_audioEncoders/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/plugins/ADM_audioEncoders/faac/audioencoder_faac.cpp
   branches/avidemux_2.6_branch_mean/plugins/ADM_audioEncoders/faac/audioencoder_faac.h
   branches/avidemux_2.6_branch_mean/plugins/ADM_audioEncoders/lavcodec/audioencoder_lavcodec.cpp
   branches/avidemux_2.6_branch_mean/plugins/ADM_audioEncoders/lavcodec/audioencoder_lavcodec.h
   branches/avidemux_2.6_branch_mean/plugins/ADM_audioEncoders/pcm/audioencoder_pcm.cpp
   branches/avidemux_2.6_branch_mean/plugins/ADM_audioEncoders/pcm/audioencoder_pcm.h
   branches/avidemux_2.6_branch_mean/plugins/ADM_audioEncoders/vorbis/audioencoder_vorbis.cpp
   branches/avidemux_2.6_branch_mean/plugins/ADM_audioEncoders/vorbis/audioencoder_vorbis.h
Log:
[Audio] Converted most of the audio encoder

Modified: branches/avidemux_2.6_branch_mean/plugins/ADM_audioEncoders/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_audioEncoders/CMakeLists.txt	2009-03-22 15:05:00 UTC (rev 4707)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_audioEncoders/CMakeLists.txt	2009-03-23 06:44:48 UTC (rev 4708)
@@ -10,8 +10,8 @@
 
 
 ADD_SUBDIRECTORY(twolame)
-#ADD_SUBDIRECTORY(pcm)
-#ADD_SUBDIRECTORY(lavcodec)
+ADD_SUBDIRECTORY(pcm)
+ADD_SUBDIRECTORY(lavcodec)
 
 if(USE_LAME)
 ADD_SUBDIRECTORY(lame)
@@ -22,9 +22,9 @@
 endif(USE_AFTEN)
 
 if(USE_VORBIS)
-#ADD_SUBDIRECTORY(vorbis)
+ADD_SUBDIRECTORY(vorbis)
 endif(USE_VORBIS)
 
 if(USE_FAAC)
-#ADD_SUBDIRECTORY(faac)
+ADD_SUBDIRECTORY(faac)
 endif(USE_FAAC)

Modified: branches/avidemux_2.6_branch_mean/plugins/ADM_audioEncoders/faac/audioencoder_faac.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_audioEncoders/faac/audioencoder_faac.cpp	2009-03-22 15:05:00 UTC (rev 4707)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_audioEncoders/faac/audioencoder_faac.cpp	2009-03-23 06:44:48 UTC (rev 4708)
@@ -28,7 +28,7 @@
 #include "audioencoder_faac.h"
 #include "audioencoder_faac_param.h"
 
-static uint8_t configure(void);
+static bool configure(void);
 
 static FAAC_encoderParam faacParm={
     128
@@ -62,7 +62,7 @@
 
 /******************* / Declare plugin*******************************************************/
 
-AUDMEncoder_Faac::AUDMEncoder_Faac(AUDMAudioFilter * instream)  :AUDMEncoder    (instream)
+AUDMEncoder_Faac::AUDMEncoder_Faac(AUDMAudioFilter * instream)  :ADM_AudioEncoder    (instream)
 {
   uint32_t channels;
   channels=instream->getInfo()->channels;
@@ -83,7 +83,9 @@
   }
 };
 
-
+/**
+    \fn ~AUDMEncoder_Faac
+*/
 AUDMEncoder_Faac::~AUDMEncoder_Faac()
 {
     if(_handle)
@@ -91,7 +93,7 @@
     _handle=NULL;
 
     printf("[FAAC] Deleting faac\n");
-    cleanup();
+
 };
 
 
@@ -99,40 +101,41 @@
     \fn initialize
 
 */
-uint8_t AUDMEncoder_Faac::initialize(void)
+bool AUDMEncoder_Faac::initialize(void)
 {
 unsigned long int samples_input, max_bytes_output;
 faacEncConfigurationPtr cfg;
 int ret=0;
+int channels=wavheader.channels;
 
-    printf("[FAAC] Incoming Fq :%u\n",_wavheader->frequency);
-     _handle = faacEncOpen(_wavheader->frequency,
-                                 _wavheader->channels,
+    printf("[FAAC] Incoming Fq :%u\n",wavheader.frequency);
+     _handle = faacEncOpen(wavheader.frequency,
+                                 channels,
                                  &samples_input,
                                 &max_bytes_output);
     if(!_handle)
     {
-          printf("Cannot open faac with fq=%"LU" chan=%"LU" br=%"LU"\n",
-          _wavheader->frequency,_wavheader->channels,faacParm.bitrate);
+          printf("[FAAC]Cannot open faac with fq=%"LU" chan=%"LU" br=%"LU"\n",
+          wavheader.frequency,channels,faacParm.bitrate);
           return 0;
     }
-    printf(" [FAAC] : Sample input:%d, max byte output%d \n",samples_input,max_bytes_output);
+    printf(" [FAAC] : Sample input:%"LU", max byte output%"LU" \n",(uint32_t)samples_input,(uint32_t)max_bytes_output);
     cfg= faacEncGetCurrentConfiguration(_handle);
     
     // Set default conf, same as ffmpeg
     cfg->aacObjectType = LOW;
     cfg->mpegVersion = MPEG4;
-    cfg->bandWidth= (_wavheader->frequency*3)/4; // Should be relevant
+    cfg->bandWidth= (wavheader.frequency*3)/4; // Should be relevant
     cfg->useTns = 0;
     cfg->allowMidside = 0;
-    cfg->bitRate = (faacParm.bitrate*1000)/_wavheader->channels; // It is per channel
+    cfg->bitRate = (faacParm.bitrate*1000)/channels; // It is per channel
     cfg->outputFormat = 0; // 0 Raw 1 ADTS
     cfg->inputFormat = FAAC_INPUT_FLOAT;
     cfg->useLfe=0;	
     if (!(ret=faacEncSetConfiguration(_handle, cfg))) 
     {
         printf("[FAAC] Cannot set conf for faac with fq=%"LU" chan=%"LU" br=%"LU" (err:%d)\n",
-				_wavheader->frequency,_wavheader->channels,faacParm.bitrate,ret);
+				wavheader.frequency,channels,faacParm.bitrate,ret);
 	return 0;
     }
      unsigned char *data=NULL;
@@ -147,11 +150,11 @@
      memcpy(_extraData,data,size);
 
     // update
-     _wavheader->byterate=(faacParm.bitrate*1000)/8;
+     wavheader.byterate=(faacParm.bitrate*1000)/8;
 //    _wavheader->dwScale=1024;
 //    _wavheader->dwSampleSize=0;
-    _wavheader->blockalign=4096;
-    _wavheader->bitspersample=0;
+    wavheader.blockalign=4096;
+    wavheader.bitspersample=0;
 
     _chunk=samples_input;
 
@@ -159,23 +162,25 @@
     printf("[Faac] Initialized :\n");
     
     printf("[Faac]Version        : %s\n",cfg->name);
-    printf("[Faac]Bitrate        : %"LU"\n",cfg->bitRate);
+    printf("[Faac]Bitrate        : %"LU"\n",(uint32_t)cfg->bitRate);
     printf("[Faac]Mpeg2 (1)/4(0) : %u\n",cfg->mpegVersion);
     printf("[Faac]Use lfe      ) : %u\n",cfg->useLfe);
-    printf("[Faac]Sample output  : %"LU"\n",_chunk / _wavheader->channels);
-    printf("[Faac]Bitrate        : %lu\n",cfg->bitRate*_wavheader->channels);
+    printf("[Faac]Sample output  : %"LU"\n",_chunk / channels);
+    printf("[Faac]Bitrate        : %lu\n",cfg->bitRate*channels);
 
     
     return 1;
 }
-
+/**
+    \fn refillBuffer
+*/
 //_____________________________________________
 //  Need to multiply the float by 32767, can't use
 //  generic fill buffer
 //----------------------------------------------
 uint8_t AUDMEncoder_Faac::refillBuffer(int minimum)
 {
-  uint32_t filler=_wavheader->frequency*_wavheader->channels;
+  uint32_t filler=wavheader.frequency*wavheader.channels;
   uint32_t nb;
   AUD_Status status;
   if(eof_met) return 0;
@@ -218,12 +223,15 @@
 }
 #define SIZE_INTERNAL 64*1024 
 #define FA_BUFFER_SIZE (SIZE_INTERNAL/4)
-//______________________________________________
-uint8_t	AUDMEncoder_Faac::getPacket(uint8_t *dest, uint32_t *len, uint32_t *samples)
+/**
+    \fn encode
+*/
+bool	AUDMEncoder_Faac::encode(uint8_t *dest, uint32_t *len, uint32_t *samples)
 {
   uint32_t count=0;
+ int channels=wavheader.channels;
 _again:
-        *samples = _chunk/_wavheader->channels;
+        *samples = _chunk/channels;
         *len = 0;
 
         if(!refillBuffer(_chunk ))
@@ -249,7 +257,7 @@
 /**
     \fn configure
 */
-uint8_t configure (void)
+bool configure (void)
 {
  int ret=0;
 

Modified: branches/avidemux_2.6_branch_mean/plugins/ADM_audioEncoders/faac/audioencoder_faac.h
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_audioEncoders/faac/audioencoder_faac.h	2009-03-22 15:05:00 UTC (rev 4707)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_audioEncoders/faac/audioencoder_faac.h	2009-03-23 06:44:48 UTC (rev 4708)
@@ -16,16 +16,17 @@
 #define AUDMaudioAAC
 
  //_____________________________________________
-class AUDMEncoder_Faac : public AUDMEncoder
+class AUDMEncoder_Faac : public ADM_AudioEncoder
 {
 protected:
          void           *_handle;
+         uint32_t        _chunk;
          uint8_t        refillBuffer(int minimum);
 public:
-                 uint8_t initialize(void);
-                virtual ~AUDMEncoder_Faac();
+                 bool   initialize(void);
+    virtual             ~AUDMEncoder_Faac();
                         AUDMEncoder_Faac(AUDMAudioFilter *instream);	
-                virtual uint8_t	getPacket(uint8_t *dest, uint32_t *len, uint32_t *samples);
+    virtual bool	    encode(uint8_t *dest, uint32_t *len, uint32_t *samples);
 };
 
 #endif

Modified: branches/avidemux_2.6_branch_mean/plugins/ADM_audioEncoders/lavcodec/audioencoder_lavcodec.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_audioEncoders/lavcodec/audioencoder_lavcodec.cpp	2009-03-22 15:05:00 UTC (rev 4707)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_audioEncoders/lavcodec/audioencoder_lavcodec.cpp	2009-03-23 06:44:48 UTC (rev 4708)
@@ -49,7 +49,7 @@
     uint32_t bitrate;
 }LavAudioEncoder_PARAM;
 static LavAudioEncoder_PARAM lavConfig={128};
-static uint8_t configure (void);
+static bool configure (void);
 /********************* Declare Plugin *****************************************************/
 ADM_DECLARE_AUDIO_ENCODER_PREAMBLE(AUDMEncoder_Lavcodec);
 
@@ -92,20 +92,23 @@
 #define CONTEXT ((AVCodecContext  	*)_context)
 
 
-// Ctor: Duplicate
-//__________
-
-AUDMEncoder_Lavcodec::AUDMEncoder_Lavcodec(AUDMAudioFilter * instream)  :AUDMEncoder    (instream)
+/**
+    \fn AUDMEncoder_Lavcodec
+*/
+AUDMEncoder_Lavcodec::AUDMEncoder_Lavcodec(AUDMAudioFilter * instream)  :ADM_AudioEncoder    (instream)
 {
   
   _context=NULL;
    printf("[Lavcodec] Creating Lavcodec audio encoder (0x%x)\n",makeName(WAV));
 
-  _wavheader->encoding=makeName(WAV);
+  wavheader.encoding=makeName(WAV);
   
   
 };
 
+/**
+    \fn ~AUDMEncoder_Lavcodec
+*/
 
 AUDMEncoder_Lavcodec::~AUDMEncoder_Lavcodec()
 {
@@ -116,17 +119,16 @@
     ADM_dealloc(_context);
   }
   _context=NULL;
-  cleanup();
 };
 
-//________________________________________________
-//   Init lame encoder
-//_______________________________________________
-uint8_t AUDMEncoder_Lavcodec::initialize(void)
+/**
+    \fn initialize
+*/
+bool AUDMEncoder_Lavcodec::initialize(void)
 {
   int ret;
   _context=( void *)avcodec_alloc_context();
-  _wavheader->byterate=(lavConfig.bitrate*1000)>>3;
+  
 
 #ifdef ADM_LAV_MP2      
   if( _incoming->getInfo()->channels>2)
@@ -135,19 +137,19 @@
     return 0; 
   }
 #endif
-  _wavheader->byterate=(lavConfig.bitrate*1000)>>3;         
+  wavheader.byterate=(lavConfig.bitrate*1000)>>3;         
       
 #ifdef ADM_LAV_MP2 
-    _chunk = 1152*_wavheader->channels;
+    _chunk = 1152*wavheader.channels;
 #else
-    _chunk = 1536*_wavheader->channels; // AC3
+    _chunk = 1536*wavheader.channels; // AC3
 #endif
   printf("[Lavcodec]Incoming : fq : %lu, channel : %lu bitrate: %lu \n",
-         _wavheader->frequency,_wavheader->channels,lavConfig.bitrate);
+         wavheader.frequency,wavheader.channels,lavConfig.bitrate);
   
   
-  CONTEXT->channels     =  _wavheader->channels;
-  CONTEXT->sample_rate  =  _wavheader->frequency;
+  CONTEXT->channels     =  wavheader.channels;
+  CONTEXT->sample_rate  =  wavheader.frequency;
   CONTEXT->bit_rate     = (lavConfig.bitrate*1000); // bits -> kbits
 
   AVCodec *codec;
@@ -169,12 +171,14 @@
   printf("[Lavcodec]Lavcodec successfully initialized,wavTag : 0x%x\n",makeName(WAV));
   return 1;       
 }
-//*********************************
-uint8_t	AUDMEncoder_Lavcodec::getPacket(uint8_t *dest, uint32_t *len, uint32_t *samples)
+/**
+    \fn encode
+*/
+bool	AUDMEncoder_Lavcodec::encode(uint8_t *dest, uint32_t *len, uint32_t *samples)
 {
   uint32_t nbout;
-  
-  *samples = _chunk/_wavheader->channels; //FIXME
+  int channels=wavheader.channels;
+  *samples = _chunk/channels; //FIXME
   *len = 0;
 
   if(!refillBuffer(_chunk ))
@@ -187,7 +191,7 @@
     return 0; 
   }
 
-  dither16(&(tmpbuffer[tmphead]),_chunk,_wavheader->channels);
+  dither16(&(tmpbuffer[tmphead]),_chunk,channels);
 
   ADM_assert(tmptail>=tmphead);
   nbout = avcodec_encode_audio(CONTEXT, dest, 5000, (short *) &(tmpbuffer[tmphead]));
@@ -199,7 +203,7 @@
     return 0;
   }
   *len=nbout;
-  return 1;
+  return true;
 }
 #define SZT(x) sizeof(x)/sizeof(diaMenuEntry )
 #define BITRATE(x) {x,QT_TR_NOOP(#x)}
@@ -207,7 +211,7 @@
 /**
     \fn configure
 */
-uint8_t configure (void)
+bool configure (void)
 {
  int ret=0;
 
@@ -232,6 +236,5 @@
     return ( diaFactoryRun(QT_TR_NOOP("Aften Configuration"),1,elems));
     
 }	
-// EOF
 
 // EOF

Modified: branches/avidemux_2.6_branch_mean/plugins/ADM_audioEncoders/lavcodec/audioencoder_lavcodec.h
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_audioEncoders/lavcodec/audioencoder_lavcodec.h	2009-03-22 15:05:00 UTC (rev 4707)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_audioEncoders/lavcodec/audioencoder_lavcodec.h	2009-03-23 06:44:48 UTC (rev 4708)
@@ -15,18 +15,19 @@
 #ifndef AUDMaudioLavcodec
 #define AUDMaudioLavcodec
  //_____________________________________________
-class AUDMEncoder_Lavcodec : public AUDMEncoder
+class AUDMEncoder_Lavcodec : public ADM_AudioEncoder
 {
   protected:
    
     void              *_context;
+    uint32_t            _chunk;
     
          
   public:
-            uint8_t     initialize(void);
+            bool        initialize(void);
    virtual             ~AUDMEncoder_Lavcodec();
                         AUDMEncoder_Lavcodec(AUDMAudioFilter *instream);	
-   virtual uint8_t	    getPacket(uint8_t *dest, uint32_t *len, uint32_t *samples);
+   virtual bool  	    encode(uint8_t *dest, uint32_t *len, uint32_t *samples);
 };
 
 #endif

Modified: branches/avidemux_2.6_branch_mean/plugins/ADM_audioEncoders/pcm/audioencoder_pcm.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_audioEncoders/pcm/audioencoder_pcm.cpp	2009-03-22 15:05:00 UTC (rev 4707)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_audioEncoders/pcm/audioencoder_pcm.cpp	2009-03-23 06:44:48 UTC (rev 4708)
@@ -61,10 +61,10 @@
 // Ctor: Duplicate
 //__________
 
-AUDMEncoder_PCM::AUDMEncoder_PCM(AUDMAudioFilter * instream)  :AUDMEncoder    (instream)
+AUDMEncoder_PCM::AUDMEncoder_PCM(AUDMAudioFilter * instream)  :ADM_AudioEncoder    (instream)
 {
   printf("[PCM] Creating PCM\n");
-  _wavheader->encoding=WAV_PCM;
+  wavheader.encoding=WAV_PCM;
 
 };
 
@@ -72,35 +72,34 @@
 AUDMEncoder_PCM::~AUDMEncoder_PCM()
 {
   printf("[PCM] Deleting PCM\n");
-  cleanup();
+
 };
 
 /**
     \fn initialize
 */
-uint8_t AUDMEncoder_PCM::initialize(void)
+bool AUDMEncoder_PCM::initialize(void)
 {
 
-  _wavheader->byterate=_wavheader->channels*_wavheader->frequency*2;
-  _chunk = (_wavheader->frequency/100)*_wavheader->channels*2;
+  wavheader.byterate=wavheader.channels*wavheader.frequency*2;
+  _chunk = (wavheader.frequency/100)*wavheader.channels*2;
 
 
 
-  printf("[PCM]Incoming :fq : %"LU", channel : %"LU" \n",_wavheader->frequency,_wavheader->channels);
+  printf("[PCM]Incoming :fq : %"LU", channel : %"LU" \n",wavheader.frequency,wavheader.channels);
   printf("[PCM]PCM successfully initialized\n");
   return 1;
 }
 /**
     \fn getPacket
 */
-
-uint8_t	AUDMEncoder_PCM::getPacket(uint8_t *dest, uint32_t *len, uint32_t *samples)
+bool         AUDMEncoder_PCM::encode(uint8_t *dest, uint32_t *len, uint32_t *samples)
 {
   uint32_t nbout;
 
   *samples = _chunk; //FIXME
   *len = 0;
-
+  uint32_t channels=wavheader.channels;
   if(!refillBuffer(_chunk ))
   {
     return 0;
@@ -111,7 +110,7 @@
     return 0;
   }
         // Do in place replace
-  dither16(&(tmpbuffer[tmphead]),_chunk,_wavheader->channels);
+  dither16(&(tmpbuffer[tmphead]),_chunk,channels);
   if(1) //!revert)
     memcpy(dest,&(tmpbuffer[tmphead]),_chunk*2);
   else
@@ -128,7 +127,7 @@
   }
   tmphead+=_chunk;
   *len=_chunk*2;
-  *samples=_chunk/_wavheader->channels;
+  *samples=_chunk/channels;
   return 1;
 }
 

Modified: branches/avidemux_2.6_branch_mean/plugins/ADM_audioEncoders/pcm/audioencoder_pcm.h
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_audioEncoders/pcm/audioencoder_pcm.h	2009-03-22 15:05:00 UTC (rev 4707)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_audioEncoders/pcm/audioencoder_pcm.h	2009-03-23 06:44:48 UTC (rev 4708)
@@ -15,22 +15,23 @@
 #define AUDMaudioPCM
 
 /*!
+    \class AUDMEncoder_PCM
     This class is the float->PCM encoder.
     It is somehow special as it can alsa be a LPCM encoder and a bigendian/littleendian swapper
 */
-class AUDMEncoder_PCM : public AUDMEncoder
+class AUDMEncoder_PCM : public ADM_AudioEncoder
 {
   protected:
     uint32_t            revert;
-         
+    uint32_t            _chunk;
   public:
-            uint8_t     initialize(void);
             virtual     ~AUDMEncoder_PCM();
                         /*! \param reverted : Should the endianness be reverted compared to system  
                             \param fourCC   : FourCC to use (WAV_PCM/WAV_LPCM)
                         */
                          AUDMEncoder_PCM(AUDMAudioFilter * instream);
-    virtual uint8_t	     getPacket(uint8_t *dest, uint32_t *len, uint32_t *samples);
+   virtual bool         encode(uint8_t *dest, uint32_t *len, uint32_t *samples);
+   virtual bool         initialize(void);
 };
 
 #endif

Modified: branches/avidemux_2.6_branch_mean/plugins/ADM_audioEncoders/vorbis/audioencoder_vorbis.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_audioEncoders/vorbis/audioencoder_vorbis.cpp	2009-03-22 15:05:00 UTC (rev 4707)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_audioEncoders/vorbis/audioencoder_vorbis.cpp	2009-03-23 06:44:48 UTC (rev 4708)
@@ -48,7 +48,7 @@
     9
 };
 
-static uint8_t configure(void);
+static bool configure(void);
 /********************* Declare Plugin *****************************************************/
 ADM_DECLARE_AUDIO_ENCODER_PREAMBLE(AUDMEncoder_Vorbis);
 
@@ -81,11 +81,11 @@
 
 //__________
 
-AUDMEncoder_Vorbis::AUDMEncoder_Vorbis(AUDMAudioFilter * instream)  :AUDMEncoder    (instream)
+AUDMEncoder_Vorbis::AUDMEncoder_Vorbis(AUDMAudioFilter * instream)  :ADM_AudioEncoder    (instream)
 {
   printf("[Vorbis] Creating Vorbis\n");
   _handle=NULL;
-  _wavheader->encoding=WAV_OGG;
+  wavheader.encoding=WAV_OGG;
   _oldpos=0;
   _handle=(void *)new  vorbisStruct;
   outputChannelMapping[0] = ADM_CH_FRONT_LEFT;
@@ -111,14 +111,13 @@
   }
   _handle=NULL;
 
-  cleanup();
 };
 
 /**
     \fn initialize
 
 */
-uint8_t AUDMEncoder_Vorbis::initialize(void)
+bool AUDMEncoder_Vorbis::initialize(void)
 {
   int ret;
   VORBIS_encoderParam *vorbisConf=&vorbisParam;
@@ -136,8 +135,8 @@
 
     case ADM_VORBIS_VBR:
                       err=vorbis_encode_init(&VI,
-                              _wavheader->channels,
-                              _wavheader->frequency,
+                              wavheader.channels,
+                              wavheader.frequency,
                               -1, // Max bitrate
                               vorbisConf->bitrate*1000, //long nominal_bitrate,
                               -1 //long min_bitrate))
@@ -145,8 +144,8 @@
                       break;
     case  ADM_VORBIS_QUALITY :
                     err=vorbis_encode_init_vbr(&VI,
-                                _wavheader->channels,
-                                _wavheader->frequency,
+                                wavheader.channels,
+                                wavheader.frequency,
                                 vorbisConf->quality/10
                               );
                     break;
@@ -204,25 +203,26 @@
       ADM_assert(0);
   }
 
-  printf("[Vorbis]Channels  :%"LU"\n",_wavheader->channels);
-  printf("[Vorbis]Frequency :%"LU"\n",_wavheader->frequency);
+  printf("[Vorbis]Channels  :%"LU"\n",wavheader.channels);
+  printf("[Vorbis]Frequency :%"LU"\n",wavheader.frequency);
   return 1;
 }
 
 #define ROUNDMAX 3000
 /**
-    \fn getPacket
+    \fn encode
 
 */
-uint8_t	AUDMEncoder_Vorbis::getPacket(uint8_t *dest, uint32_t *len, uint32_t *samples)
+bool	AUDMEncoder_Vorbis::encode(uint8_t *dest, uint32_t *len, uint32_t *samples)
 {
   uint32_t nbout;
   uint32_t consumed=0;
   float **float_samples;
+    int channels=wavheader.channels;
   ogg_packet op ;
 
   *len = 0;
-  _chunk=1024*_wavheader->channels;
+  _chunk=1024*channels;
   int count=ROUNDMAX;
 // Check that we have packet from previous pass
   while(count--)
@@ -256,21 +256,21 @@
     }
 
 
-    uint32_t nbSample=(tmptail-tmphead)/_wavheader->channels;
+    uint32_t nbSample=(tmptail-tmphead)/channels;
     if(nbSample>1024) nbSample=1024;
     float_samples=vorbis_analysis_buffer(&VD, nbSample) ;
     int index=tmphead;
     // Put our samples in incoming buffer
     reorderChannels(&(tmpbuffer[tmphead]), nbSample,_incoming->getChannelMapping(),outputChannelMapping);
     for (int i = 0; i < nbSample; i++)
-      for (int j = 0; j < _wavheader->channels; j++) {
+      for (int j = 0; j < channels; j++) {
       float_samples[j][i] = tmpbuffer[index++];
       if (float_samples[j][i] > 1) float_samples[j][i] = 1;
       if (float_samples[j][i] < -1) float_samples[j][i] = -1;
       }
       // Buffer full, go go go
       vorbis_analysis_wrote(&VD, nbSample) ;
-      tmphead+=nbSample*_wavheader->channels;
+      tmphead+=nbSample*channels;
   }
   return 0;
 
@@ -285,7 +285,7 @@
 
 */
 
-uint8_t configure(void)
+bool configure(void)
 {
 
     uint32_t mmode,ppreset;

Modified: branches/avidemux_2.6_branch_mean/plugins/ADM_audioEncoders/vorbis/audioencoder_vorbis.h
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_audioEncoders/vorbis/audioencoder_vorbis.h	2009-03-22 15:05:00 UTC (rev 4707)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_audioEncoders/vorbis/audioencoder_vorbis.h	2009-03-23 06:44:48 UTC (rev 4708)
@@ -16,20 +16,21 @@
 #define AUDMaudioVorbis
 
  //_____________________________________________
-class AUDMEncoder_Vorbis : public AUDMEncoder
+class AUDMEncoder_Vorbis : public ADM_AudioEncoder
 {
   protected:
    
     void              *_handle;
     uint64_t          _oldpos;
+    uint32_t          _chunk;
 
          
   public:
-            uint8_t     initialize(void);
+            bool     initialize(void);
             virtual     ~AUDMEncoder_Vorbis();
                         AUDMEncoder_Vorbis(AUDMAudioFilter *instream);	
             
-   virtual uint8_t	getPacket(uint8_t *dest, uint32_t *len, uint32_t *samples);
+   virtual bool	encode(uint8_t *dest, uint32_t *len, uint32_t *samples);
 };
 
 #endif



From mean at mail.berlios.de  Thu Mar 26 07:36:24 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Thu, 26 Mar 2009 07:36:24 +0100
Subject: [Avidemux-svn-commit] r4709 - in
	branches/avidemux_2.6_branch_mean/avidemux: ADM_codecs
	ADM_coreUtils/include ADM_coreUtils/src
Message-ID: <200903260636.n2Q6aOJZ006198@sheep.berlios.de>

Author: mean
Date: 2009-03-26 07:36:22 +0100 (Thu, 26 Mar 2009)
New Revision: 4709

Added:
   branches/avidemux_2.6_branch_mean/avidemux/ADM_coreUtils/include/ADM_codecType.h
   branches/avidemux_2.6_branch_mean/avidemux/ADM_coreUtils/include/ADM_frameType.h
   branches/avidemux_2.6_branch_mean/avidemux/ADM_coreUtils/src/ADM_codecType.cpp
   branches/avidemux_2.6_branch_mean/avidemux/ADM_coreUtils/src/ADM_frameType.cpp
Modified:
   branches/avidemux_2.6_branch_mean/avidemux/ADM_codecs/ADM_codec.h
   branches/avidemux_2.6_branch_mean/avidemux/ADM_coreUtils/include/avidemutils.h
   branches/avidemux_2.6_branch_mean/avidemux/ADM_coreUtils/src/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/avidemux/ADM_coreUtils/src/avidemutils.cpp
Log:
[Utils] Grunt work for frame type rederivation, clean up code also

Modified: branches/avidemux_2.6_branch_mean/avidemux/ADM_codecs/ADM_codec.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_codecs/ADM_codec.h	2009-03-23 06:44:48 UTC (rev 4708)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_codecs/ADM_codec.h	2009-03-26 06:36:22 UTC (rev 4709)
@@ -16,12 +16,11 @@
  ***************************************************************************/
 #ifndef __CODECS__
 #define __CODECS__
+
 #include "ADM_image.h"
+#include "ADM_frameType.h"
+#include "ADM_codecType.h"
 
-#define AVI_KEY_FRAME	0x10
-#define AVI_B_FRAME	0x4000	// hopefully it is not used..
-#define AVI_P_FRAME   	0x0
-
 #define ADM_QPEL_ON	1
 #define ADM_GMC_ON	2
 #define ADM_VOP_ON	4
@@ -127,12 +126,6 @@
   virtual uint8_t compress (ADMImage * in, ADMBitstream * out);
 };
 decoders *getCoder (uint32_t fcc, uint32_t w, uint32_t h);
-uint8_t isMpeg4Compatible (uint32_t fourcc);
-uint8_t isH264Compatible (uint32_t fourcc);
-uint8_t isMSMpeg4Compatible (uint32_t fourcc);
-uint8_t isDVCompatible (uint32_t fourcc);
-uint8_t isVP6Compatible (uint32_t fourcc);
-
 /*----------------------------------------------------------*/
 class encoder
 {

Added: branches/avidemux_2.6_branch_mean/avidemux/ADM_coreUtils/include/ADM_codecType.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_coreUtils/include/ADM_codecType.h	2009-03-23 06:44:48 UTC (rev 4708)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_coreUtils/include/ADM_codecType.h	2009-03-26 06:36:22 UTC (rev 4709)
@@ -0,0 +1,27 @@
+/***************************************************************************
+        \file ADM_codecType
+        \brief Identifies codec family
+    copyright            : (C) 2009 by mean
+
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#ifndef ADM_CODECTYPE_H
+#define ADM_CODECTYPE_H
+
+bool isMpeg4Compatible  (uint32_t fourcc);
+bool isH264Compatible   (uint32_t fourcc);
+bool isMSMpeg4Compatible(uint32_t fourcc);
+bool isDVCompatible     (uint32_t fourcc);
+bool isVP6Compatible    (uint32_t fourcc);
+bool isMpeg12Compatible (uint32_t fourcc);
+
+#endif
+//EOF

Added: branches/avidemux_2.6_branch_mean/avidemux/ADM_coreUtils/include/ADM_frameType.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_coreUtils/include/ADM_frameType.h	2009-03-23 06:44:48 UTC (rev 4708)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_coreUtils/include/ADM_frameType.h	2009-03-26 06:36:22 UTC (rev 4709)
@@ -0,0 +1,32 @@
+/** *************************************************************************
+    \file ADM_frameType
+    \brief Return frametype from bitstream
+                      
+    copyright            : (C) 2009 by mean
+    
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ ***************************************************************************/
+#ifndef ADM_frameType_h
+#define ADM_frameType_h
+
+#define AVI_KEY_FRAME	0x10
+#define AVI_B_FRAME	    0x4000	// hopefully it is not used..
+#define AVI_P_FRAME   	0x0
+#define AVI_ERR_FRAME   0x8888
+
+typedef int (*frameIdentifier)(uint32_t len,uint8_t *data);
+
+/// \fn    ADM_getFrameIdentifier
+/// \brief Returns a function that identify the frametype according to its bitstream
+
+frameIdentifier *ADM_getFrameIdentifier(uint32_t fourcc);
+
+
+#endif

Modified: branches/avidemux_2.6_branch_mean/avidemux/ADM_coreUtils/include/avidemutils.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_coreUtils/include/avidemutils.h	2009-03-23 06:44:48 UTC (rev 4708)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_coreUtils/include/avidemutils.h	2009-03-26 06:36:22 UTC (rev 4709)
@@ -1,29 +1,33 @@
-/*
+/** *************************************************************************
+    \file avidemutils.h
+    \brief Some misc utilities
+                      
+    copyright            : (C) 2009 by mean
+    
+ ***************************************************************************/
 
-  Some utilities 
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ ***************************************************************************/
 
-*/
 #ifndef ADM_AVIDEMUTIL_H
 #define ADM_AVIDEMUTIL_H
 
 #include "ADM_image.h"
 
-uint8_t  ADM_findMpegStartCode(uint8_t *start, uint8_t *end,uint8_t *outstartcode,uint32_t *offset);
+bool        ADM_findMpegStartCode(uint8_t *start, uint8_t *end,uint8_t *outstartcode,uint32_t *offset);
 
-uint32_t ADM_computeBitrate(uint32_t fps1000, uint32_t nbFrame, uint32_t sizeInMB);
+uint32_t    ADM_computeBitrate(uint32_t fps1000, uint32_t nbFrame, uint32_t sizeInMB);
 
-ADM_ASPECT getAspectRatioFromAR(uint32_t width, uint32_t height,const char **s);
+ADM_ASPECT  getAspectRatioFromAR(uint32_t width, uint32_t height,const char **s);
 
-char *ADM_escape(const ADM_filename *incoming);
+char        *ADM_escape(const ADM_filename *incoming);
 
-int32_t ADM_getNiceValue(uint32_t priorityLevel);
+int32_t     ADM_getNiceValue(uint32_t priorityLevel);
 
-// FourCC stuff
-uint8_t isMpeg4Compatible (uint32_t fourcc);
-uint8_t isMpeg12Compatible (uint32_t fourcc);
-uint8_t isH264Compatible (uint32_t fourcc);
-uint8_t isMSMpeg4Compatible (uint32_t fourcc);
-uint8_t isVP6Compatible (uint32_t fourcc);
-uint8_t isDVCompatible (uint32_t fourcc);
 #endif
 //EOF

Added: branches/avidemux_2.6_branch_mean/avidemux/ADM_coreUtils/src/ADM_codecType.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_coreUtils/src/ADM_codecType.cpp	2009-03-23 06:44:48 UTC (rev 4708)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_coreUtils/src/ADM_codecType.cpp	2009-03-26 06:36:22 UTC (rev 4709)
@@ -0,0 +1,154 @@
+/** *************************************************************************
+    \file ADM_codecType
+    \brief Return codec family (mpeg1/2/4/h264/DV/...) from fourcc
+                      
+    copyright            : (C) 2009 by mean
+    
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ ***************************************************************************/
+#include "ADM_default.h"
+#include "ADM_frameType.h"
+#include "ADM_codecType.h"
+#include "fourcc.h"
+
+/**
+    \fn isMpeg4Compatible
+*/
+bool  isMpeg4Compatible (uint32_t fourcc)
+{
+#define CHECK(x) if(fourCC::check(fourcc,(uint8_t *)x)) \
+						{divx4=1; }
+
+  uint8_t divx4 = 0;
+
+  CHECK ("FMP4");
+  CHECK ("fmp4");
+  CHECK ("DIVX");
+  CHECK ("divx");
+  CHECK ("DX50");
+  CHECK ("xvid");
+  CHECK ("XVID");
+  CHECK ("BLZ0");
+  CHECK ("M4S2");
+  CHECK ("3IV2");
+
+  return divx4;
+
+#undef CHECK
+}
+#ifdef ADM_BIG_ENDIAN
+#define SWAP32(x) x=R32(x)
+#else
+#define SWAP32(x) ;
+#endif
+/**
+    \fn isMpeg12Compatible
+*/
+
+bool isMpeg12Compatible (uint32_t fourcc)
+{
+#define CHECK(x) if(fourCC::check(fourcc,(uint8_t *)x)) \
+						{mpeg=1; }
+
+  uint8_t mpeg = 0;
+  CHECK ("MPEG");
+  CHECK ("mpg1");
+  CHECK ("mpg2");
+  SWAP32 (fourcc);
+  if (fourcc == 0x10000002 || fourcc==0x10000001) //Mplayer fourcc
+    mpeg = 1;
+  return mpeg;
+#undef CHECK
+}
+/**
+    \fn isH264Compatible
+*/
+
+bool isH264Compatible (uint32_t fourcc)
+{
+#define CHECK(x) if(fourCC::check(fourcc,(uint8_t *)x)) \
+                                                {h264=1; }
+
+  uint8_t h264 = 0;
+
+  CHECK ("X264");
+  CHECK ("x264");
+  CHECK ("h264");
+  CHECK ("H264");
+  CHECK ("AVC1");
+  CHECK ("avc1");
+  return h264;
+
+#undef CHECK
+}
+/**
+    \fn isMSMpeg4Compatible
+*/
+
+bool isMSMpeg4Compatible (uint32_t fourcc)
+{
+#define CHECK(x) if(fourCC::check(fourcc,(uint8_t *)x)) \
+						{divx3=1; }
+
+  uint8_t divx3 = 0;
+
+  CHECK ("MP43");
+  CHECK ("mp43");
+  CHECK ("div3");
+  CHECK ("DIV3");
+  CHECK ("DIV4");
+  CHECK ("div4");
+  CHECK ("COL1");
+
+  return divx3;
+
+#undef CHECK
+}
+/**
+    \fn isVP6Compatible
+*/
+
+bool isVP6Compatible (uint32_t fourcc)
+{
+
+#define CHECK(x) if(fourCC::check(fourcc,(uint8_t *)x)) \
+						{divx3=1; }
+
+  uint8_t divx3 = 0;
+
+  CHECK ("VP6F");
+  CHECK ("VP6 ");
+  CHECK ("VP61");
+  CHECK ("VP62");
+
+  return divx3;
+
+#undef CHECK
+}
+/**
+    \fn isDVCompatible
+*/
+
+bool isDVCompatible (uint32_t fourcc)
+{
+#define CHECK(x) if(fourCC::check(fourcc,(uint8_t *)x)) \
+						{dv=1; }
+
+  uint8_t dv = 0;
+
+  CHECK ("dvsd");
+  CHECK ("DVDS");
+  CHECK ("dvpp");
+
+  return dv;
+
+#undef CHECK
+}
+//EOF

Added: branches/avidemux_2.6_branch_mean/avidemux/ADM_coreUtils/src/ADM_frameType.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_coreUtils/src/ADM_frameType.cpp	2009-03-23 06:44:48 UTC (rev 4708)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_coreUtils/src/ADM_frameType.cpp	2009-03-26 06:36:22 UTC (rev 4709)
@@ -0,0 +1,35 @@
+/** *************************************************************************
+    \file ADM_frameType
+    \brief Return frametype from bitstream
+                      
+    copyright            : (C) 2009 by mean
+    
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ ***************************************************************************/
+#include "ADM_default.h"
+#include "ADM_frameType.h"
+#include "ADM_codecType.h"
+
+typedef int (*frameIdentifier)(uint32_t len,uint8_t *data);
+
+/// \fn    ADM_getFrameIdentifier
+/// \brief Returns a function that identify the frametype according to its bitstream
+//bool        ADM_findMpegStartCode(uint8_t *start, uint8_t *end,uint8_t *outstartcode,uint32_t *offset);
+frameIdentifier *ADM_getFrameIdentifier(uint32_t fourcc)
+{
+    //if(isMpeg4Compatible(fourcc))return frameIdMpeg4;
+    //if(isMpeg12Compatible(fourcc))return frameIdH264;
+    //if(isH264Compatible(fourcc))return frameIdH264;
+
+    return NULL;
+}
+
+
+// EOF

Modified: branches/avidemux_2.6_branch_mean/avidemux/ADM_coreUtils/src/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_coreUtils/src/CMakeLists.txt	2009-03-23 06:44:48 UTC (rev 4708)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_coreUtils/src/CMakeLists.txt	2009-03-26 06:36:22 UTC (rev 4709)
@@ -5,6 +5,8 @@
 ADM_quota.cpp
 fourcc.cpp
 ADM_infoExtractor.cpp
+ADM_frameType.cpp
+ADM_codecType.cpp
 prefs.cpp)
 
 ADD_LIBRARY(ADM_coreUtils SHARED ${ADM_coreUtils_SRCS})

Modified: branches/avidemux_2.6_branch_mean/avidemux/ADM_coreUtils/src/avidemutils.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_coreUtils/src/avidemutils.cpp	2009-03-23 06:44:48 UTC (rev 4708)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_coreUtils/src/avidemutils.cpp	2009-03-26 06:36:22 UTC (rev 4709)
@@ -29,7 +29,7 @@
 #define QT_TR_NOOP(x) x
 
 char *ADM_escape(const ADM_filename *incoming);
-uint8_t ADM_findMpegStartCode(uint8_t *start, uint8_t *end,uint8_t *outstartcode,uint32_t *offset);
+bool ADM_findMpegStartCode(uint8_t *start, uint8_t *end,uint8_t *outstartcode,uint32_t *offset);
 void memcpyswap(uint8_t *dest, uint8_t *src, uint32_t size);
 uint32_t ADM_computeBitrate(uint32_t fps1000, uint32_t nbFrame, uint32_t sizeInMB);
 uint32_t ADM_UsecFromFps1000(uint32_t fps1000);
@@ -193,14 +193,14 @@
 	}
 
 }
-/*
-
-    Find mpeg1/2/4 video startcode
+/**
+    \file ADM_findMpegStartCode
+    \brief    Find mpeg1/2/4 video startcode
     00 00 01 xx yy
     return xx + offset to yy
 
 */
-uint8_t ADM_findMpegStartCode(uint8_t *start, uint8_t *end,uint8_t *outstartcode,uint32_t *offset)
+bool ADM_findMpegStartCode(uint8_t *start, uint8_t *end,uint8_t *outstartcode,uint32_t *offset)
 {
     uint32_t startcode=0xffffffff;
     uint8_t  *ptr=start;
@@ -213,11 +213,11 @@
 		{
 			*outstartcode=*ptr;
 			*offset=ptr-start+1;
-			return 1;
+			return true;
 		}
 		ptr++;
 	}
-	return 0; // startcode not found
+	return false; // startcode not found
 }
 //**********************************************************
 // Convert \ to \\
@@ -372,117 +372,4 @@
 	}
 }
 
-uint8_t isMpeg4Compatible (uint32_t fourcc)
-{
-#define CHECK(x) if(fourCC::check(fourcc,(uint8_t *)x)) \
-						{divx4=1; }
-
-  uint8_t divx4 = 0;
-
-  CHECK ("FMP4");
-  CHECK ("fmp4");
-  CHECK ("DIVX");
-  CHECK ("divx");
-  CHECK ("DX50");
-  CHECK ("xvid");
-  CHECK ("XVID");
-  CHECK ("BLZ0");
-  CHECK ("M4S2");
-  CHECK ("3IV2");
-
-  return divx4;
-
-#undef CHECK
-}
-#ifdef ADM_BIG_ENDIAN
-#define SWAP32(x) x=R32(x)
-#else
-#define SWAP32(x) ;
-#endif
-
-uint8_t isMpeg12Compatible (uint32_t fourcc)
-{
-#define CHECK(x) if(fourCC::check(fourcc,(uint8_t *)x)) \
-						{mpeg=1; }
-
-  uint8_t mpeg = 0;
-  CHECK ("MPEG");
-  CHECK ("mpg1");
-  CHECK ("mpg2");
-  SWAP32 (fourcc);
-  if (fourcc == 0x10000002 || fourcc==0x10000001) //Mplayer fourcc
-    mpeg = 1;
-  return mpeg;
-#undef CHECK
-}
-uint8_t isH264Compatible (uint32_t fourcc)
-{
-#define CHECK(x) if(fourCC::check(fourcc,(uint8_t *)x)) \
-                                                {h264=1; }
-
-  uint8_t h264 = 0;
-
-  CHECK ("X264");
-  CHECK ("x264");
-  CHECK ("h264");
-  CHECK ("H264");
-  CHECK ("AVC1");
-  CHECK ("avc1");
-  return h264;
-
-#undef CHECK
-}
-
-uint8_t isMSMpeg4Compatible (uint32_t fourcc)
-{
-#define CHECK(x) if(fourCC::check(fourcc,(uint8_t *)x)) \
-						{divx3=1; }
-
-  uint8_t divx3 = 0;
-
-  CHECK ("MP43");
-  CHECK ("mp43");
-  CHECK ("div3");
-  CHECK ("DIV3");
-  CHECK ("DIV4");
-  CHECK ("div4");
-  CHECK ("COL1");
-
-  return divx3;
-
-#undef CHECK
-}
-uint8_t isVP6Compatible (uint32_t fourcc)
-{
-
-#define CHECK(x) if(fourCC::check(fourcc,(uint8_t *)x)) \
-						{divx3=1; }
-
-  uint8_t divx3 = 0;
-
-  CHECK ("VP6F");
-  CHECK ("VP6 ");
-  CHECK ("VP61");
-  CHECK ("VP62");
-
-  return divx3;
-
-#undef CHECK
-}
-uint8_t isDVCompatible (uint32_t fourcc)
-{
-#define CHECK(x) if(fourCC::check(fourcc,(uint8_t *)x)) \
-						{dv=1; }
-
-  uint8_t dv = 0;
-
-  CHECK ("dvsd");
-  CHECK ("DVDS");
-  CHECK ("dvpp");
-
-  return dv;
-
-#undef CHECK
-}
-
 //EOF



From mean at mail.berlios.de  Thu Mar 26 19:57:32 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Thu, 26 Mar 2009 19:57:32 +0100
Subject: [Avidemux-svn-commit] r4710 - in
	branches/avidemux_2.6_branch_mean/avidemux: .
	ADM_coreUtils/include ADM_coreUtils/src ADM_editor ADM_script
Message-ID: <200903261857.n2QIvWmB020057@sheep.berlios.de>

Author: mean
Date: 2009-03-26 19:57:31 +0100 (Thu, 26 Mar 2009)
New Revision: 4710

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/ADM_coreUtils/include/ADM_frameType.h
   branches/avidemux_2.6_branch_mean/avidemux/ADM_coreUtils/src/ADM_frameType.cpp
   branches/avidemux_2.6_branch_mean/avidemux/ADM_editor/ADM_edFrameType.cpp
   branches/avidemux_2.6_branch_mean/avidemux/ADM_editor/ADM_edit.cpp
   branches/avidemux_2.6_branch_mean/avidemux/ADM_editor/ADM_edit.hxx
   branches/avidemux_2.6_branch_mean/avidemux/ADM_script/ADM_JSAvidemux.cpp
   branches/avidemux_2.6_branch_mean/avidemux/gui_navigate.cpp
Log:
[Editor] Rederive frame type

Modified: branches/avidemux_2.6_branch_mean/avidemux/ADM_coreUtils/include/ADM_frameType.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_coreUtils/include/ADM_frameType.h	2009-03-26 06:36:22 UTC (rev 4709)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_coreUtils/include/ADM_frameType.h	2009-03-26 18:57:31 UTC (rev 4710)
@@ -26,7 +26,7 @@
 /// \fn    ADM_getFrameIdentifier
 /// \brief Returns a function that identify the frametype according to its bitstream
 
-frameIdentifier *ADM_getFrameIdentifier(uint32_t fourcc);
+frameIdentifier ADM_getFrameIdentifier(uint32_t fourcc);
 
 
 #endif

Modified: branches/avidemux_2.6_branch_mean/avidemux/ADM_coreUtils/src/ADM_frameType.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_coreUtils/src/ADM_frameType.cpp	2009-03-26 06:36:22 UTC (rev 4709)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_coreUtils/src/ADM_frameType.cpp	2009-03-26 18:57:31 UTC (rev 4710)
@@ -16,20 +16,87 @@
 #include "ADM_default.h"
 #include "ADM_frameType.h"
 #include "ADM_codecType.h"
+#include "avidemutils.h"
 
-typedef int (*frameIdentifier)(uint32_t len,uint8_t *data);
+/**
+    \fn mpeg12FrameIdentifier
+*/
+static int mpeg12FrameIdentifier(uint32_t len,uint8_t *data)
+{
+    uint8_t *start=data;
+    uint8_t *end=data+len;
+    uint32_t offset;
+    uint8_t code;
+    while(ADM_findMpegStartCode(start,end,&code,&offset) && start<end-4)
+    {
+        if(code)
+        {
+            start+=offset;
+            continue;
+        }
+        uint16_t val;
+        int type;
+        start+=offset;
+        val=*start++;
+        val=(val<<8)+*start++;
+        type=7 & (val>>3);
+        if( type<1 ||  type>3)
+          {
+                  printf("[mpeg12FrameType]Met illegal pic at offset %"LX"\n",(uint32_t)(start-data));
+                  continue;
+          }
+        switch(type)
+        {
+            case 1:return AVI_KEY_FRAME;break;
+            case 2:return AVI_P_FRAME;break;
+            case 3:return AVI_B_FRAME;break;
+        }
+    }
+    return AVI_ERR_FRAME;
+}
 
-/// \fn    ADM_getFrameIdentifier
-/// \brief Returns a function that identify the frametype according to its bitstream
-//bool        ADM_findMpegStartCode(uint8_t *start, uint8_t *end,uint8_t *outstartcode,uint32_t *offset);
-frameIdentifier *ADM_getFrameIdentifier(uint32_t fourcc)
+/**
+    \fn mpeg4FrameIdentifier
+*/
+static int mpeg4FrameIdentifier(uint32_t len,uint8_t *data)
 {
-    //if(isMpeg4Compatible(fourcc))return frameIdMpeg4;
-    //if(isMpeg12Compatible(fourcc))return frameIdH264;
+    uint8_t *start=data;
+    uint8_t *end=data+len;
+    uint32_t offset;
+    uint8_t code;
+    while(ADM_findMpegStartCode(start,end,&code,&offset) && start<end-4)
+    {
+       start+=offset;
+       if(code!=0xb6)
+        {
+            continue;
+        }
+
+        // Analyse a bit the vop header
+        uint8_t coding_type=*start;
+        coding_type>>=6;
+        switch(coding_type)
+        {
+            case 0: return AVI_KEY_FRAME;break;
+            case 1: return AVI_P_FRAME;break;
+            case 2: return AVI_B_FRAME;break;
+            default: printf("[mpeg4frame]Glouglou %d\n",coding_type);continue;break;
+
+        }
+    }
+    return AVI_ERR_FRAME;
+}
+
+/** \fn    ADM_getFrameIdentifier
+    \brief Returns a function that identify the frametype according to its bitstream
+*/
+frameIdentifier ADM_getFrameIdentifier(uint32_t fourcc)
+{
+    if(isMpeg4Compatible(fourcc))return mpeg4FrameIdentifier;
+    if(isMpeg12Compatible(fourcc))return mpeg12FrameIdentifier;
     //if(isH264Compatible(fourcc))return frameIdH264;
 
     return NULL;
 }
+// EOF
 
-
-// EOF

Modified: branches/avidemux_2.6_branch_mean/avidemux/ADM_editor/ADM_edFrameType.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_editor/ADM_edFrameType.cpp	2009-03-26 06:36:22 UTC (rev 4709)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_editor/ADM_edFrameType.cpp	2009-03-26 18:57:31 UTC (rev 4710)
@@ -1,10 +1,9 @@
 /***************************************************************************
-                          ADM_edFrameType.cpp  -  description
-                             -------------------
-  Rederive Frame type if needed
+           \file               ADM_edFrameType.cpp  -  description
+           \brief              Rederive Frame type if needed
 
-    begin                : Fri Apr 12 2002
-    copyright            : (C) 2002 by mean
+    
+    copyright            : (C) 2002/2009 by mean
     email                : fixounet at free.fr
  ***************************************************************************/
 
@@ -16,137 +15,57 @@
  *   (at your option) any later version.                                   *
  *                                                                         *
  ***************************************************************************/
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include "ADM_assert.h"
+#include "ADM_default.h"
 
-#include "config.h"
-#include "fourcc.h"
-#include "prefs.h"
 #include "ADM_editor/ADM_edit.hxx"
 #include "ADM_codecs/ADM_codec.h"
 #include "ADM_videoFilter.h"
-#include "avi_vars.h"
 #include "DIA_working.h"
 #include "DIA_coreToolkit.h"
 #include "avidemutils.h"
-
-
+#include "ADM_frameType.h"
+ 
 /**
-	Rebuild frame type by actually decoding them
-	to all videos loaded
-	Use hurry_up flag if the codec is able to do it.
-
+    \fn rederiveFrameType
+    \brief 
 */
-uint8_t   ADM_Composer::rebuildFrameType ( void)
+bool        ADM_Composer::rederiveFrameType(vidHeader *demuxer)
 {
-_VIDEOS *vi;
-uint32_t frames=0,cur=0;
-uint8_t *compBuffer=NULL;
-//uint8_t *prepBuffer=NULL;
-ADMImage *prepBuffer=NULL;
-ADMImage *prepBufferNoCopy=NULL;
-ADMImage *tmpImage=NULL;
-uint32_t bframe;
-aviInfo    info;
-						
-	if(!_nb_video)
-	{
-          GUI_Error_HIG(QT_TR_NOOP("No video loaded"), NULL);
-		return 0;
-	}
-	if(!isIndexable())
-	{
-          GUI_Error_HIG(QT_TR_NOOP("Not indexable"),QT_TR_NOOP( "DivX 5 + packed?"));
-		return 0;
-	}
+    uint32_t flags,flagsDecoded;
+    uint8_t *buffer;
+    aviInfo info;
 
-	uint32_t originalPriority = getpriority(PRIO_PROCESS, 0);
-	uint32_t priorityLevel;
+    demuxer->getVideoInfo (&info);
+    frameIdentifier id=ADM_getFrameIdentifier(info.fcc);
+    if(!id)
+    {
+        printf("[Editor]Cannot get identifer for this fourcc\n");
+        return true;
+    }
+    uint32_t size=demuxer->getMainHeader()->dwWidth;
+    size*=demuxer->getMainHeader()->dwHeight*3;
+    buffer=new uint8_t[size];
 
-	prefs->get(PRIORITY_INDEXING,&priorityLevel);
-	setpriority(PRIO_PROCESS, 0, ADM_getNiceValue(priorityLevel));
-
-	vi=&(_videos[0]);
-	vi->_aviheader->getVideoInfo (&info);
-                        
-	compBuffer=new uint8_t[(info.width * info.height * 3)>>1];
-	ADM_assert(compBuffer);
-
-	prepBuffer=new ADMImage(info.width ,info.height);            
-    prepBufferNoCopy=new ADMImage(info.width ,info.height);      
     ADMCompressedImage img;
-    img.data=compBuffer;
+    img.data=buffer;
 
-	ADM_assert(prepBuffer);
-    ADM_assert(prepBufferNoCopy);
+    int max=100;
+    if(max>info.nb_frames)max=info.nb_frames;
 
-	for(uint32_t i=0;i<_nb_video;i++)
-	{
-		frames+=_videos[i]._nb_video_frames;
-	}
-	DIA_workingBase *work;
-    uint8_t nocopy;
-	work=createWorking(QT_TR_NOOP("Rebuilding Frames"));
+    int nbOk=0,nbKo=0;
 
-
-	for(uint32_t vid=0;vid<_nb_video;vid++)
-	{
-		// set the decoder in fast mode
-			vi=&(_videos[vid]);
-			vi->_aviheader->getVideoInfo (&info);
-			nocopy=vi->decoder->dontcopy();
-                        if(nocopy) tmpImage=prepBufferNoCopy;
-                                else tmpImage=prepBuffer;
-			bframe=0;
-			if(vi->_reorderReady)
-			{
-				cur+=vi->_nb_video_frames;
-			}
-			else
-			{
-                
-				vi->decoder->decodeHeaderOnly();
-				for(uint32_t j=0;j<vi->_nb_video_frames;j++)
-				{
-	  				vi->_aviheader->getFrame (j,&img);
-					if(img.dataLength)
-                                        {
-		    				vi->decoder->uncompress (&img, tmpImage);
-                                        }
-					else
-						tmpImage->flags=0;
-	  				vi->_aviheader->setFlag(j,tmpImage->flags);
-					if(tmpImage->flags & AVI_B_FRAME)
-						bframe++;
-
-					if(work->update(cur, frames))
-	  				{
-						delete work;
-						vi->decoder->decodeFull();
-						GUI_Error_HIG(QT_TR_NOOP("Aborted"), NULL);
-						delete [] compBuffer;
-						delete  prepBuffer;
-						delete  prepBufferNoCopy;
-
-						setpriority(PRIO_PROCESS, 0, originalPriority);
-						return 0;
-       				}
-					cur++;
-				}
-				vi->decoder->decodeFull();
-				
-			}
-	}
-	delete work;
-	delete [] compBuffer;
-	delete  prepBuffer;
-    delete  prepBufferNoCopy;
-
-	setpriority(PRIO_PROCESS, 0, originalPriority);
-
-	return 1;
+    for(int i=0;i<max;i++)
+    {
+        demuxer->getFlags(i,&flags);
+        demuxer->getFrame(i,&img);
+        flagsDecoded=id(img.dataLength,img.data);
+        if(flagsDecoded==flags) nbOk++;
+            else nbKo++;
+    }
+    delete [] buffer;
+    printf("[Editor] Muxer has %d frames right, %d frames wrong\n",nbOk,nbKo);
+    if(!nbKo)     return true;
+    // Demuxer is wrong, rederive all frames...
+    return false;
 }
-
-
+// EOF

Modified: branches/avidemux_2.6_branch_mean/avidemux/ADM_editor/ADM_edit.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_editor/ADM_edit.cpp	2009-03-26 06:36:22 UTC (rev 4709)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_editor/ADM_edit.cpp	2009-03-26 18:57:31 UTC (rev 4710)
@@ -471,16 +471,24 @@
             }
         }
 #endif
-	_nb_video++;
-	_nb_segment++;
+        // B Frames check....
+        _VIDEOS 	*vid;
+        vid=&(_videos[_nb_video]);
+        decoders *decoder=vid->decoder;
+        rederiveFrameType(_videos[_nb_video]._aviheader);
 
+
+        //
+        _nb_video++;
+        _nb_segment++;
+#if 0
 //______________________________________
 // 1-  check for B _ frame  existence
 // 2- check  for consistency with reported flags
 //______________________________________
 	uint8_t count=0;
 TryAgain:
-	_VIDEOS 	*vid;
+
 	uint32_t err=0;
 
 		vid= &(_videos[_nb_video-1]);
@@ -492,7 +500,7 @@
 			printf("[Editor] no decoder to check for B- frame\n");
 		}else
         {
-            decoders *decoder=vid->decoder;
+           
             if(vid->_aviheader->providePts()==false) // Else we rely on demuxer PTS
             {
                 printf("[Editor] This container does not provide PTS \n");
@@ -512,6 +520,7 @@
                 }
             }
         }
+#endif
 		GoToIntra(0);
         durationInUs=vid->_aviheader->getVideoDuration();
 		printf("[Editor] End of B-frame check\n");

Modified: branches/avidemux_2.6_branch_mean/avidemux/ADM_editor/ADM_edit.hxx
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_editor/ADM_edit.hxx	2009-03-26 06:36:22 UTC (rev 4709)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_editor/ADM_edit.hxx	2009-03-26 18:57:31 UTC (rev 4710)
@@ -173,6 +173,7 @@
 
 						uint32_t 	searchForwardSeg(uint32_t startframe);
                         uint8_t     tryIndexing(const char *name, const char *idxname=NULL);
+                        bool        rederiveFrameType(vidHeader *demuxer);
 
   public:
                             uint8_t hasVBRVideos(void);
@@ -314,7 +315,6 @@
               				uint8_t			searchNextKeyFrame(uint32_t in,uint32_t *oseg, uint32_t * orel);
                  			uint8_t			searchPreviousKeyFrame(uint32_t in,uint32_t *oseg, uint32_t * orel);
 public:
-					uint8_t   		rebuildFrameType ( void);
                   // kludg
                   			void 			propagateBuildMap( void );
 

Modified: branches/avidemux_2.6_branch_mean/avidemux/ADM_script/ADM_JSAvidemux.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_script/ADM_JSAvidemux.cpp	2009-03-26 06:36:22 UTC (rev 4709)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_script/ADM_JSAvidemux.cpp	2009-03-26 18:57:31 UTC (rev 4710)
@@ -501,7 +501,7 @@
         enterLock();
         if(!video_body->isReordered(0)) // already done
         {
-          video_body->rebuildFrameType();
+          //video_body->rebuildFrameType();
         }
  	leaveLock();
        return JS_TRUE;

Modified: branches/avidemux_2.6_branch_mean/avidemux/gui_navigate.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/gui_navigate.cpp	2009-03-26 06:36:22 UTC (rev 4709)
+++ branches/avidemux_2.6_branch_mean/avidemux/gui_navigate.cpp	2009-03-26 18:57:31 UTC (rev 4710)
@@ -305,7 +305,7 @@
 uint8_t A_rebuildKeyFrame(void)
 {
 
-    return video_body->rebuildFrameType();
+//    return video_body->rebuildFrameType();
 }
 /**
     \fn GUI_PrevFrame



From mean at mail.berlios.de  Fri Mar 27 07:44:28 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Fri, 27 Mar 2009 07:44:28 +0100
Subject: [Avidemux-svn-commit] r4711 -
	branches/avidemux_2.6_branch_mean/avidemux/ADM_editor
Message-ID: <200903270644.n2R6iSXe020740@sheep.berlios.de>

Author: mean
Date: 2009-03-27 07:44:27 +0100 (Fri, 27 Mar 2009)
New Revision: 4711

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/ADM_editor/ADM_edFrameType.cpp
   branches/avidemux_2.6_branch_mean/avidemux/ADM_editor/ADM_edit.cpp
Log:
[Editor] Update frametype

Modified: branches/avidemux_2.6_branch_mean/avidemux/ADM_editor/ADM_edFrameType.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_editor/ADM_edFrameType.cpp	2009-03-26 18:57:31 UTC (rev 4710)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_editor/ADM_edFrameType.cpp	2009-03-27 06:44:27 UTC (rev 4711)
@@ -1,6 +1,7 @@
 /***************************************************************************
            \file               ADM_edFrameType.cpp  -  description
-           \brief              Rederive Frame type if needed
+           \brief              Rederive Frame type if needed. Works only with a few
+                                                    codecs (mpeg1/2/4)
 
     
     copyright            : (C) 2002/2009 by mean
@@ -18,12 +19,10 @@
 #include "ADM_default.h"
 
 #include "ADM_editor/ADM_edit.hxx"
-#include "ADM_codecs/ADM_codec.h"
-#include "ADM_videoFilter.h"
-#include "DIA_working.h"
 #include "DIA_coreToolkit.h"
 #include "avidemutils.h"
 #include "ADM_frameType.h"
+#include "DIA_working.h"
  
 /**
     \fn rederiveFrameType
@@ -66,6 +65,15 @@
     printf("[Editor] Muxer has %d frames right, %d frames wrong\n",nbOk,nbKo);
     if(!nbKo)     return true;
     // Demuxer is wrong, rederive all frames...
+    DIA_workingBase *work=createWorking("Updating frametype");
+    for(int i=0;i<info.nb_frames;i++)
+    {
+        work->update(i,info.nb_frames);
+        demuxer->getFrame(i,&img);
+        flagsDecoded=id(img.dataLength,img.data);
+        demuxer->setFlag(i,flagsDecoded);
+    }
+    delete work;
     return false;
 }
 // EOF

Modified: branches/avidemux_2.6_branch_mean/avidemux/ADM_editor/ADM_edit.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_editor/ADM_edit.cpp	2009-03-26 18:57:31 UTC (rev 4710)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_editor/ADM_edit.cpp	2009-03-27 06:44:27 UTC (rev 4711)
@@ -471,7 +471,7 @@
             }
         }
 #endif
-        // B Frames check....
+        // Update frametype if needed...
         _VIDEOS 	*vid;
         vid=&(_videos[_nb_video]);
         decoders *decoder=vid->decoder;
@@ -481,17 +481,8 @@
         //
         _nb_video++;
         _nb_segment++;
-#if 0
-//______________________________________
-// 1-  check for B _ frame  existence
-// 2- check  for consistency with reported flags
-//______________________________________
-	uint8_t count=0;
-TryAgain:
 
-	uint32_t err=0;
-
-		vid= &(_videos[_nb_video-1]);
+        //Update time stamps if needed....
 		vid->_reorderReady=0;
         vid->_unpackReady=0;
 		// we only try if we got everything needed...
@@ -515,12 +506,11 @@
                 }
                 else   
                 {
-                        printf("[Editor] No B frame with that codec\n");
+                        printf("[Editor] No B frame with that codec, PTS=DTS\n");
                         setPtsEqualDts(vid->_aviheader,vid->timeIncrementInUs);
                 }
             }
         }
-#endif
 		GoToIntra(0);
         durationInUs=vid->_aviheader->getVideoDuration();
 		printf("[Editor] End of B-frame check\n");



From mean at mail.berlios.de  Sat Mar 28 17:35:26 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sat, 28 Mar 2009 17:35:26 +0100
Subject: [Avidemux-svn-commit] r4712 -
	branches/avidemux_2.6_branch_mean/avidemux/ADM_editor
Message-ID: <200903281635.n2SGZQXx016719@sheep.berlios.de>

Author: mean
Date: 2009-03-28 17:35:25 +0100 (Sat, 28 Mar 2009)
New Revision: 4712

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/ADM_editor/ADM_edPtsDts.cpp
   branches/avidemux_2.6_branch_mean/avidemux/ADM_editor/ADM_edit.cpp
Log:
[Editor] Fix dts=pts

Modified: branches/avidemux_2.6_branch_mean/avidemux/ADM_editor/ADM_edPtsDts.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_editor/ADM_edPtsDts.cpp	2009-03-27 06:44:27 UTC (rev 4711)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_editor/ADM_edPtsDts.cpp	2009-03-28 16:35:25 UTC (rev 4712)
@@ -20,6 +20,10 @@
 
 #include "ADM_edPtsDts.h"
 
+#define GOT_NO_PTS 2
+#define GOT_NO_DTS 1
+#define GOT_NONE   3
+#define GOT_BOTH   0
 /**
     \fn setPtsEqualDts
     \brief for Low delay codec, set PTS=DTS, fill the missing values
@@ -38,11 +42,11 @@
             return false;
         }
         int k=0;
-        if(pts==ADM_NO_PTS) k+=2;
-        if(dts==ADM_NO_PTS) k+=1;
+        if(pts==ADM_NO_PTS) k+=GOT_NO_PTS;
+        if(dts==ADM_NO_PTS) k+=GOT_NO_DTS;
         switch(k)
         {
-            case 0 : // Got both
+            case GOT_BOTH : // Got both
                 if(pts!=dts)
                             {
                                     printf("[Editor] Pts!=Dts for frame %"LU"\n",i);
@@ -50,7 +54,7 @@
                 first=pts; // do nothing since we already have both...
                 continue;            
                 break;
-            case 3: // Got none
+            case GOT_NONE: // Got none
                 {
                         if(first!=ADM_NO_PTS)
                         {
@@ -60,10 +64,10 @@
                             continue;   // We dont have a previous skip that one
                 }
                 break;
-            case 2 :  // got only pts
-                    first=dts=pts;
-                    break;
-            case 1: // got only dts
+            case GOT_NO_DTS :  // got only pts
+                first=dts=pts;
+                break;
+            case GOT_NO_PTS: // got only dts
                 first=pts=dts;
                 break;
             default:

Modified: branches/avidemux_2.6_branch_mean/avidemux/ADM_editor/ADM_edit.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_editor/ADM_edit.cpp	2009-03-27 06:44:27 UTC (rev 4711)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_editor/ADM_edit.cpp	2009-03-28 16:35:25 UTC (rev 4712)
@@ -498,7 +498,7 @@
                 if(decoder->bFramePossible())
                 {
                     printf("[Editor] B- frame possible with that codec \n");
-                    if(isMpeg4Compatible(info.fcc))
+                    if(isMpeg4Compatible(info.fcc) || isMpeg12Compatible(info.fcc))
                     {
                         printf("[Editor] It is mpeg4-SP/ASP, try to guess all PTS\n");                        
                         setMpeg4PtsFromDts(vid->_aviheader,vid->timeIncrementInUs);



From mean at mail.berlios.de  Sat Mar 28 17:35:32 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sat, 28 Mar 2009 17:35:32 +0100
Subject: [Avidemux-svn-commit] r4713 -
	branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/OpenDml
Message-ID: <200903281635.n2SGZWHl016737@sheep.berlios.de>

Author: mean
Date: 2009-03-28 17:35:31 +0100 (Sat, 28 Mar 2009)
New Revision: 4713

Modified:
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/OpenDml/ADM_openDML.cpp
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/OpenDml/ADM_openDMLDepack.cpp
Log:
[Demuxer:Avi]Cosmetic

Modified: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/OpenDml/ADM_openDML.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/OpenDml/ADM_openDML.cpp	2009-03-28 16:35:25 UTC (rev 4712)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/OpenDml/ADM_openDML.cpp	2009-03-28 16:35:31 UTC (rev 4713)
@@ -638,7 +638,7 @@
         printf(  "Main header\n" );
         printf(  "______________________\n" );  
 
-#define X_DUMP(x) printf(#x":\t\t:%d\n",_mainaviheader.x);
+#define X_DUMP(x) printf("[Avi] "#x":\t\t:%d\n",_mainaviheader.x);
     	X_DUMP(dwStreams);
     	X_DUMP(dwMicroSecPerFrame) ;
 	X_DUMP(dwMaxBytesPerSec);
@@ -650,21 +650,22 @@
     	X_DUMP(dwHeight);
  	printf("\n");
 #undef X_DUMP
-#define X_DUMP(x) printf("\n "#x":\t\t:%d",_videostream.x);
+#define X_DUMP(x) printf("[Avi]  "#x":\t\t:%d\n",_videostream.x);
 
 				
-	printf(  "video stream attached:\n" );
-	printf(  "______________________\n" );	
-	printf(" Extra Data  : %u",_videoExtraLen);
+	printf(  "[Avi] video stream attached:\n" );
+	printf(  "[Avi] ______________________\n" );	
+	printf(  "[Avi] Extra Data  : %u",_videoExtraLen);
 	if(_videoExtraLen)
 	{
 		mixDump( _videoExtraData, _videoExtraLen);
+        printf("\n");
 	}
 
-	printf("\n fccType     :");
-	fourCC::print(_videostream.fccType);
-	printf("\n fccHandler :");
-	fourCC::print(_videostream.fccHandler);
+	printf("[Avi]  fccType     :");
+	fourCC::print(_videostream.fccType);printf("\n");
+	printf("[Avi]  fccHandler :");
+	fourCC::print(_videostream.fccHandler);printf("\n");
 
 	X_DUMP(dwFlags);
 	X_DUMP(dwInitialFrames);
@@ -686,19 +687,19 @@
         for(int i=0;i<_nbAudioTracks;i++)
      	{
 #undef X_DUMP
-#define X_DUMP(x) printf("\n "#x":\t\t:%d",_audioTracks[i].avistream->x);
+#define X_DUMP(x) printf("[Avi] "#x":\t\t:%d\n",_audioTracks[i].avistream->x);
 
 
 
-	   printf(  "\naudio stream attached:\n" );
-	   printf(  "______________________\n" );
+	   printf(  "[Avi] audio stream attached:\n" );
+	   printf(  "[Avi] ______________________\n" );
 
 
-	  printf("\n fccType     :");
-	  fourCC::print(_audioTracks[i].avistream->fccType);
-	  printf("\n fccHandler :");
-	  fourCC::print(_audioTracks[i].avistream->fccHandler);
-	  printf("\n fccHandler :0x%x", _audioTracks[i].avistream->fccHandler);
+	  printf("[Avi]  fccType     :");
+	  fourCC::print(_audioTracks[i].avistream->fccType);printf("\n");
+	  printf("[Avi]  fccHandler :");
+	  fourCC::print(_audioTracks[i].avistream->fccHandler);printf("\n");
+	  printf("[Avi]  fccHandler :0x%x\n", _audioTracks[i].avistream->fccHandler);
 
 
 	  X_DUMP(dwFlags);
@@ -716,7 +717,7 @@
 #undef X_DUMP
 
         printWavHeader(_audioTracks[i].wavHeader);
-        printf(" Extra Data  : %u\n",_audioTracks[i].extraDataLen);
+        printf("[Avi]  Extra Data  : %u\n",_audioTracks[i].extraDataLen);
 	if(_audioTracks[i].extraDataLen)
 	{
 		mixDump( _audioTracks[i].extraData, _audioTracks[i].extraDataLen);
@@ -759,11 +760,11 @@
 #ifdef ADM_BIG_ENDIAN
 			Endian_AviMainHeader(&_mainaviheader);
 #endif
-				printf("\n Main avi header :\n");				
+				printf("[Avi]  Main avi header :\n");				
 				break;
 		case MKFCC('i','d','x','1'):
                                 _regularIndex.offset=p->getPos();
-                                printf("Idx1 found at offset %lx\n",_regularIndex.offset);
+                                printf("[Avi] Idx1 found at offset %lx\n",_regularIndex.offset);
                                 _regularIndex.size=len;
 				return;
 				break;				
@@ -792,7 +793,7 @@
 					DUMP_TRACK(_nbTrack);
 					break;
 		case MKFCC('i','n','d','x'):
-					printf("Indx found for track %d\n",_nbTrack);
+					printf("[Avi] Indx found for track %d\n",_nbTrack);
 					_Tracks[_nbTrack].indx.offset=p->getPos();
 					_Tracks[_nbTrack].indx.size=len;
 					p->skip(len);
@@ -830,7 +831,7 @@
 				break;
 		default:
 			PAD;
-			aprintf("\tskipping %lu bytes\n");
+			aprintf("[Avi] \tskipping %lu bytes\n");
 			p->skip(len);
 			break;
 		

Modified: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/OpenDml/ADM_openDMLDepack.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/OpenDml/ADM_openDMLDepack.cpp	2009-03-28 16:35:25 UTC (rev 4712)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/OpenDml/ADM_openDMLDepack.cpp	2009-03-28 16:35:31 UTC (rev 4713)
@@ -96,7 +96,7 @@
 	prefs->get(PRIORITY_INDEXING,&priorityLevel);
 	setpriority(PRIO_PROCESS, 0, ADM_getNiceValue(priorityLevel));
 #endif
-	printf("Trying to unpack the stream\n");
+	printf("[Avi] Trying to unpack the stream\n");
 	DIA_workingBase *working=createWorking(QT_TR_NOOP("Unpacking bitstream"));
 	ADMCompressedImage image;
     image.data=buffer;
@@ -110,7 +110,7 @@
 		working->update(img,nbFrame);
 		if(!getFrame(img,&image))
         {
-            printf("Error could not get frame %"LU"\n",img);
+            printf("[Avi] Error could not get frame %"LU"\n",img);
             goto _abortUnpack;
         }
 		aprintf("--Frame:%lu/%lu, len %lu, nbDuped%u\n",img,nbFrame,image.dataLength,nbDuped);
@@ -136,7 +136,7 @@
                 /* Cannot find vop, corrupted or WTF ...*/
                 if(!searchVop(buffer,buffer+image.dataLength,&nbVop,myVops,&timcincbits))
                 {
-                    printf("img :%u failed to find vop!\n",img);
+                    printf("[Avi] img :%u failed to find vop!\n",img);
                     memcpy(&newIndex[targetIndex],&_idx[img],sizeof(_idx[0]));
                     targetIndex++;
                     img++;
@@ -185,7 +185,7 @@
                         {
                           if(nbDuped)
                           {
-                              printf("WARNING*************** Missing one NVOP, dropping one b frame instead  at image %u\n",img);
+                              printf("[Avi] WARNING*************** Missing one NVOP, dropping one b frame instead  at image %u\n",img);
                               nbDuped--;
                           }else
                           {
@@ -215,7 +215,7 @@
 #endif
 	if(ret==1)
 	{
-		printf("Sucessfully unpacked the bitstream\n");
+		printf("[Avi] Sucessfully unpacked the bitstream\n");
 
 		delete [] _idx;
 		_idx=newIndex;
@@ -223,9 +223,9 @@
 	else
 	{
 		delete [] newIndex;
-		printf("Could not unpack this...\n");
+		printf("[Avi] Could not unpack this...\n");
 	}
-	printf("Initial # of images : %"LU", now we have %"LU" \n",nbFrame,targetIndex);
+	printf("[Avi] Initial # of images : %"LU", now we have %"LU" \n",nbFrame,targetIndex);
 	nbFrame=targetIndex;
 
 	setpriority(PRIO_PROCESS, 0, originalPriority);
@@ -260,7 +260,7 @@
 					case 0: voptype=AVI_KEY_FRAME;break;
 					case 1: voptype=0;break;
 					case 2: voptype=AVI_B_FRAME;break;
-					case 3: printf("Glouglou\n");voptype=0;break;
+					case 3: printf("[Avi] Glouglou\n");voptype=0;break;
 
 				}
         	                vop[*nb].offset=globalOff+off-4;



From mean at mail.berlios.de  Sat Mar 28 17:35:38 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sat, 28 Mar 2009 17:35:38 +0100
Subject: [Avidemux-svn-commit] r4714 - in branches/avidemux_2.6_branch_mean:
	avidemux avidemux/ADM_audioFilter_old
	avidemux/ADM_audiofilter avidemux/ADM_editor
	avidemux/ADM_encoder avidemux/ADM_libraries/ADM_mplex
	avidemux/ADM_script avidemux/ADM_toolkit
	avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog
	avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog
	avidemux/ADM_userInterfaces/ADM_commonUI
	plugins/ADM_muxers/muxerAvi plugins/ADM_muxers/oplug_dummy
	plugins/ADM_muxers/oplug_flv plugins/ADM_muxers/oplug_mpeg
	plugins/ADM_muxers/oplug_mpegFF plugins/ADM_muxers/oplug_ogm
Message-ID: <200903281635.n2SGZcJu016767@sheep.berlios.de>

Author: mean
Date: 2009-03-28 17:35:35 +0100 (Sat, 28 Mar 2009)
New Revision: 4714

Added:
   branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter_old/
   branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter_old/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter_old/audiodeng_buildfilters.cpp
   branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter_old/audioeng_buildfilters.h
   branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter_old/audioprocess.hxx
Removed:
   branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audio_encoderWrapper.cpp
   branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audio_encoderWrapper.h
   branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audio_raw.cpp
   branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audio_raw.h
   branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiodeng_buildfilters.cpp
   branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audioeng_buff.cpp
   branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audioeng_buildfilters.h
   branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_buildchain.cpp
   branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audioprocess.hxx
Modified:
   branches/avidemux_2.6_branch_mean/avidemux/ADM_editor/ADM_edLoadSave.cpp
   branches/avidemux_2.6_branch_mean/avidemux/ADM_encoder/adm_encmpeg2enc.cpp
   branches/avidemux_2.6_branch_mean/avidemux/ADM_libraries/ADM_mplex/ADM_mthread.cpp
   branches/avidemux_2.6_branch_mean/avidemux/ADM_script/ADM_JSAvidemuxAudio.cpp
   branches/avidemux_2.6_branch_mean/avidemux/ADM_script/ADM_JSAvidemuxVideo.cpp
   branches/avidemux_2.6_branch_mean/avidemux/ADM_script/ADM_JSFunctions.cpp
   branches/avidemux_2.6_branch_mean/avidemux/ADM_script/ADM_JSFunctions.cpp.orig
   branches/avidemux_2.6_branch_mean/avidemux/ADM_toolkit/ADM_audioQueue.cpp
   branches/avidemux_2.6_branch_mean/avidemux/ADM_toolkit/automation.cpp
   branches/avidemux_2.6_branch_mean/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_acodec.cpp
   branches/avidemux_2.6_branch_mean/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_calculator.cpp
   branches/avidemux_2.6_branch_mean/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/Q_calculator.cpp
   branches/avidemux_2.6_branch_mean/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_audioFilter.cpp
   branches/avidemux_2.6_branch_mean/avidemux/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/avidemux/gtk_gui.cpp
   branches/avidemux_2.6_branch_mean/avidemux/gui_autodrive.cpp
   branches/avidemux_2.6_branch_mean/avidemux/gui_blackframes.cpp
   branches/avidemux_2.6_branch_mean/avidemux/gui_savenew.cpp
   branches/avidemux_2.6_branch_mean/plugins/ADM_muxers/muxerAvi/op_avisave.cpp
   branches/avidemux_2.6_branch_mean/plugins/ADM_muxers/muxerAvi/op_avisavedual.cpp
   branches/avidemux_2.6_branch_mean/plugins/ADM_muxers/oplug_dummy/oplug_dummy.cpp
   branches/avidemux_2.6_branch_mean/plugins/ADM_muxers/oplug_flv/oplug_flv.cpp
   branches/avidemux_2.6_branch_mean/plugins/ADM_muxers/oplug_mpeg/op_mpegpass.cpp
   branches/avidemux_2.6_branch_mean/plugins/ADM_muxers/oplug_mpegFF/oplug_vcdff.cpp
   branches/avidemux_2.6_branch_mean/plugins/ADM_muxers/oplug_ogm/op_ogaudio.cpp
Log:
[Audio] Removed unused stuff, renamed still used so that it can be checked out on win32

Added: branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter_old/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter_old/CMakeLists.txt	2009-03-28 16:35:31 UTC (rev 4713)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter_old/CMakeLists.txt	2009-03-28 16:35:35 UTC (rev 4714)
@@ -0,0 +1,7 @@
+SET(ADMaudiofilter_SRCS 
+	audiodeng_buildfilters.cpp    
+)
+	
+ADD_ADM_LIB_ALL_TARGETS(ADM_audioFilter_old ${ADMaudiofilter_SRCS})
+INCLUDE_DIRECTORIES(${CMAKE_SOURCE_DIR}/avidemux/ADM_audioEncoder/include)
+

Copied: branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter_old/audiodeng_buildfilters.cpp (from rev 4713, branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiodeng_buildfilters.cpp)
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiodeng_buildfilters.cpp	2009-03-28 16:35:31 UTC (rev 4713)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter_old/audiodeng_buildfilters.cpp	2009-03-28 16:35:35 UTC (rev 4714)
@@ -0,0 +1,371 @@
+/***************************************************************************
+                          audiodeng_buildfilters.cpp  -  description
+                             -------------------
+    begin                : Mon Dec 2 2002
+    copyright            : (C) 2002 by mean
+    email                : fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include "config.h"
+#include <math.h>
+
+#include "ADM_default.h"
+
+#include "audiofilter_limiter_param.h"
+#include "audiofilter_normalize_param.h"
+
+#include "audioeng_buildfilters.h"
+
+
+#include "audioencoder.h"
+
+#include "ADM_audiocodec/ADM_audiocodeclist.h"
+
+
+#include "audiofilter_bridge.h"
+#include "audiofilter_mixer.h"
+#include "audiofilter_normalize.h"
+#include "audiofilter_limiter.h"
+
+#include "prefs.h"
+
+#include "ADM_osSupport/ADM_debugID.h"
+#define MODULE_NAME MODULE_AUDIO_FILTER
+#include "ADM_osSupport/ADM_debug.h"
+
+extern void UI_setAProcessToggleStatus( uint8_t status );
+extern uint8_t DIA_audioCodec( int *codec );
+extern void UI_setAudioCodec( int i);
+uint32_t audioFilterGetNbEncoder(void);
+const char* audioFilterGetIndexedName(uint32_t i);
+
+
+typedef struct externalSource
+{
+ AudioSource type;
+ const char *name;
+}externalSource;
+
+static const externalSource Sources[]=
+{
+        {AudioAvi,"VIDEO"},
+        {AudioMP3,"MP3"},
+        {AudioWav,"WAV"},
+        {AudioAC3,"AC3"},
+        {AudioNone,"NONE"}
+};
+typedef struct
+{
+  const char         *name;
+  CHANNEL_CONF conf;
+}Mixer_String;
+
+#define DOME(x) {#x,CHANNEL_##x}
+static Mixer_String Mixer_strings[]=
+{
+  {"NONE",CHANNEL_INVALID},
+  DOME(MONO),
+  DOME(STEREO),
+  DOME(2F_1R),
+  DOME(3F),
+  DOME(3F_1R),
+  DOME(2F_2R),
+  DOME(3F_2R),
+  DOME(3F_2R_LFE),
+  DOME(DOLBY_PROLOGIC),
+  DOME(DOLBY_PROLOGIC2)
+
+};
+
+
+
+extern void UI_PrintCurrentACodec( const char *s);
+
+
+/*----------------------------------*/
+GAINparam audioGain;
+int  audioFreq=48000;
+int  audioDRC = 0;
+FILMCONV audioFilmConv=FILMCONV_NONE;
+RESAMPLING  audioResampleMode = RESAMPLING_NONE;
+CHANNEL_CONF audioMixing=CHANNEL_INVALID;
+// These are globals for the moment
+//************************************
+int 	   audioShift = 0;
+int	   audioDelay=0;
+//**********
+
+const char              *getCurrentMixerString(void)
+{
+        uint32_t nb=sizeof(Mixer_strings)/sizeof(Mixer_String);
+        for(uint32_t i=0;i<nb;i++)
+                if(audioMixing==Mixer_strings[i].conf) return Mixer_strings[i].name;
+        ADM_assert(0);
+
+}
+uint8_t                    setCurrentMixerFromString(const char *name)
+{
+        uint32_t nb=sizeof(Mixer_strings)/sizeof(Mixer_String);
+        for(uint32_t i=0;i<nb;i++)
+                if(!strcasecmp(name,Mixer_strings[i].name))
+                {
+                  audioMixing= Mixer_strings[i].conf;
+                  return 1;
+                }
+        return 0;
+
+}
+//**********
+
+const char              *audioSourceFromEnum(AudioSource src)
+{
+        uint32_t nb=sizeof(Sources)/sizeof(externalSource);
+        for(uint32_t i=0;i<nb;i++)
+                if(src==Sources[i].type) return Sources[i].name;
+        ADM_assert(0);
+
+}
+AudioSource             audioSourceFromString(const char *name)
+{
+        uint32_t nb=sizeof(Sources)/sizeof(externalSource);
+        for(uint32_t i=0;i<nb;i++)
+                if(!strcasecmp(name,Sources[i].name)) return Sources[i].type;
+        return (AudioSource)0;
+
+}
+
+//**********
+uint8_t audioReset(void )
+{
+  audioGain.mode=ADM_NO_GAIN;
+  audioResampleMode = RESAMPLING_NONE;
+  audioFilmConv=FILMCONV_NONE;
+  audioMixing=CHANNEL_INVALID;
+  return 1;
+}
+//************
+uint8_t audioGetNormalizeMode(void)
+{
+  return audioGain.mode;
+
+}
+int32_t  audioGetNormalizeValue(void)
+{
+  return audioGain.gain10;
+
+}
+
+uint32_t audioGetResample(void)
+{
+      return audioFreq;
+
+}
+uint32_t audioGetDrc(void)
+{
+  return audioDRC;
+}
+uint32_t audioGetDelay(void)
+{
+        if(audioShift && audioDelay)
+        {
+                return audioDelay;
+
+        }
+        return 0;
+}
+FILMCONV audioGetFpsConv(void)
+{
+        return audioFilmConv;
+}
+
+/*----------------------------------*/
+//
+
+
+
+
+void audioFilterNormalizeMode(uint8_t onoff)
+{
+  audioGain.mode=(ADM_GAINMode)onoff;
+}
+void audioFilterNormalizeValue(int v)
+{
+  audioGain.gain10=v;
+}
+
+uint8_t audioFilterDelay(int32_t delay)
+{
+	if(delay)
+	{
+		audioShift=1;
+		audioDelay=delay;
+	}
+	else
+	{
+		audioShift=audioDelay=0;
+	}
+	return 1;
+
+}
+RESAMPLING  audioGetResampling(void)
+{
+        return audioResampleMode;
+}
+uint8_t audioFilterFilm2Pal(uint8_t onoff)
+{
+	if(onoff) audioFilmConv=FILMCONV_FILM2PAL;
+	else audioFilmConv=FILMCONV_NONE;
+	return 1;
+}
+uint8_t audioFilterDrc(uint8_t onoff)
+{
+  audioDRC=onoff;
+  return 1;
+}
+uint8_t audioFilterPal2Film(uint8_t onoff)
+{
+        if(onoff) audioFilmConv=FILMCONV_PAL2FILM;
+        else audioFilmConv=FILMCONV_NONE;
+        return 1;
+}
+
+void audioFilterResample(uint32_t onoff)
+{
+	if(onoff)
+	{
+		audioResampleMode=RESAMPLING_CUSTOM;
+		audioFreq=onoff;
+	}
+	else
+		audioResampleMode=RESAMPLING_NONE;
+
+}
+//______________________________
+//#include "ADM_gui2/GUI_ui.h"
+uint8_t UI_setTimeShift(int onoff,int value);
+extern  int DIA_getAudioFilter(GAINparam *normalized, RESAMPLING *downsamplingmethod, int *tshifted,
+  			 int *shiftvalue, int *drc,int *freqvalue,FILMCONV *filmconv,CHANNEL_CONF *channel);
+
+void audioFilter_configureFilters( void )
+{
+    int olddelay=audioDelay;
+    int oldshift=audioShift;
+	 DIA_getAudioFilter(&audioGain,&audioResampleMode,&audioShift,&audioDelay,&audioDRC,&audioFreq,
+	 		&audioFilmConv,&audioMixing );
+         if(audioDelay!=olddelay ||oldshift!= audioShift)
+         {  // Refresh
+
+
+
+         }
+
+}
+
+/*
+
+*/
+
+#define Read(x) { \
+		tmp=name; \
+		if((tmp=strstr(name,#x))) \
+			{ \
+				tmp+=strlen(#x); \
+				aprintf("-- %s\n",tmp); \
+				sscanf(tmp,"=%d ",(int *)&x); \
+			} \
+			 else \
+			{ printf("*** %s not found !***\n",#x);} \
+		}
+#define Add(x) {sprintf(tmp,"%s=%d ",#x,x);strcat(conf,tmp);}
+
+uint8_t audioFilterSetByName( const char *name)
+{
+	const char *tmp;
+	aprintf("-Audio filter by name : %s\n",name);
+
+	Read(audioGain.mode);
+        Read(audioGain.gain10);
+	Read(audioResampleMode);
+	Read(audioDRC);
+	Read(audioShift);
+	Read(audioDelay);
+	Read(audioFreq);
+	Read(audioMixing);
+	return 1;
+}
+
+const char *audioFilterGetName( void )
+{
+	static char conf[400];
+	static char tmp[200];
+	conf[0]=0;
+	#undef Add
+	#define Add(x) {sprintf(tmp,"%s=%d ",#x,x);strcat(conf,tmp);}
+	Add(audioGain.mode);
+        Add(audioGain.gain10);
+	Add(audioResampleMode);
+	Add(audioDRC);
+	Add(audioShift);
+	Add(audioDelay);
+	Add(audioFreq);
+	Add(audioMixing);
+	return conf;
+
+}
+
+
+/*
+	Refresh   activeAudioEncoder value
+	depending on what's selected
+
+*/
+
+
+
+void audioSetResample(uint32_t fq)
+{
+
+	audioResampleMode=RESAMPLING_CUSTOM;
+	audioFreq=fq;
+}
+/**
+ * 	\fn getAudioOuputFrequency
+ *  \brief Return the encoding of the currently selected codec
+ */
+uint32_t audioProcessMode(void);
+uint32_t audioFilter_getOuputFrequency(uint32_t inputFrequency)
+{
+	if(!audioProcessMode()) return inputFrequency;
+	if(audioResampleMode == RESAMPLING_NONE) return inputFrequency;
+	return audioFreq;
+}
+/**
+    \fn audioCodecGetName
+    \brief Returns the current codec tagname
+*/
+
+AudioSource audioCodecGetFromName( const char *name)
+{
+                for(uint32_t i=0;i<sizeof(Sources)/sizeof(externalSource);i++)
+                {
+                        if(!strcasecmp(name,Sources[i].name))
+                        {
+
+                                return Sources[i].type;
+                        }
+
+                }
+                printf("\n Mmmm Select audio codec by name failed...(%s).\n",name);
+                return AudioNone;
+}
+
+//EOF
+

Copied: branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter_old/audioeng_buildfilters.h (from rev 4713, branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audioeng_buildfilters.h)
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audioeng_buildfilters.h	2009-03-28 16:35:31 UTC (rev 4713)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter_old/audioeng_buildfilters.h	2009-03-28 16:35:35 UTC (rev 4714)
@@ -0,0 +1,107 @@
+/**************************************************************************
+                          audioeng_buildfilters.h  -  description
+                             -------------------
+    begin                : Mon Dec 2 2002
+    copyright            : (C) 2002 by mean
+    email                : fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#ifndef ADM_AUDIO_BUILDFILTER_H
+#define  ADM_AUDIO_BUILDFILTER_H
+
+#include "audioencoder.h"
+#include "ADM_audio/aviaudio.hxx"
+
+#include "audioEncoderApi.h"
+#include "ADM_audioStream.h"
+
+ ADM_audioStream *buildAudioFilter(ADM_audioStream *stream, uint32_t startTime);
+ AUDMAudioFilter *buildPlaybackFilter(ADM_audioStream *currentaudiostream,
+				uint32_t starttime, uint32_t duration);
+
+ void deleteAudioFilter(ADM_audioStream *in);
+void audioFilter_configureFilters( void );
+
+
+
+void audioCodecConfigure( void );
+void audioCodecSelect( void );
+void audioFilter_MP3DisableReservoir(int onoff);
+uint32_t audioFilter_getOuputCodec(void);
+uint32_t audioFilter_getOuputFrequency(uint32_t inputFrequency);
+uint32_t audioFilter_getMaxChannels(void);
+
+//#include "ADM_audioEncoder/include/audioencoder_enum.h"
+
+typedef enum 
+{
+	RESAMPLING_NONE=0,
+	RESAMPLING_CUSTOM=1,
+	RESAMPLING_LAST
+}RESAMPLING;
+
+typedef enum 
+{
+	FILMCONV_NONE=0,
+	FILMCONV_FILM2PAL=1,
+	FILMCONV_PAL2FILM=2,
+	FILMCONV_LAST
+}FILMCONV;
+
+typedef enum
+{
+        AudioInvalid,
+        AudioAvi=1,
+        AudioMP3,
+        AudioWav,
+        AudioAC3,
+        AudioNone
+
+}AudioSource;
+
+//void audioCodecSetcodec(AUDIOENCODER codec);
+uint8_t audioReset(void);
+/*  for job/workspace stuff  */
+const char *audioFilterGetName( void );
+uint8_t audioFilterSetByName( const char *name);
+
+//AVDMGenericAudioStream *mpt_getAudioStream(void);
+
+/* -- Set filter --*/
+void audioFilterNormalizeMode(uint8_t onoff);
+void audioFilterNormalizeValue(int value);
+void audioFilterResample(uint32_t onoff);
+uint8_t audioFilterDelay(int32_t delay);
+uint8_t audioFilterFilm2Pal(uint8_t onoff);
+uint8_t audioFilterPal2Film(uint8_t onoff);
+uint8_t audioFilterDrc(uint8_t onoff);
+void audioFilter_SetBitrate( int i);
+/* -- Get filter -- */
+uint32_t audioGetBitrate(void);
+uint8_t audioGetNormalizeMode(void);
+int32_t audioGetNormalizeValue(void);
+uint32_t audioGetResample(void);
+uint32_t audioGetDelay(void);
+FILMCONV audioGetFpsConv(void);
+uint32_t audioGetDrc(void);
+RESAMPLING  audioGetResampling(void);
+/*-----*/
+uint8_t                 A_changeAudioStream(ADM_audioStream *newaudio,AudioSource so,char *name);
+AudioSource             getCurrentAudioSource(char **name);
+const char              *audioSourceFromEnum(AudioSource src);
+AudioSource             audioSourceFromString(const char *name);
+const char              *getCurrentMixerString(void);
+uint8_t                 setCurrentMixerFromString(const char *string);
+
+//*****
+//
+#endif
+

Copied: branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter_old/audioprocess.hxx (from rev 4713, branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audioprocess.hxx)
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audioprocess.hxx	2009-03-28 16:35:31 UTC (rev 4713)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter_old/audioprocess.hxx	2009-03-28 16:35:35 UTC (rev 4714)
@@ -0,0 +1,27 @@
+/***************************************************************************
+                          audioprocess.hxx  -  description
+                             -------------------
+    begin                : Sun Jan 13 2002
+    copyright            : (C) 2002 by mean
+    email                : fixounet at free.fr
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#ifndef __AudioProcess__
+#define __AudioProcess__
+
+#include "ADM_audio/aviaudio.hxx"
+#include "ADM_audioStream.h"
+#define PROCESS_BUFFER_SIZE 48000*4*4 // should be enougth
+#define MINIMUM_BUFFER   8192*4
+
+#endif
+// EOF

Deleted: branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/CMakeLists.txt	2009-03-28 16:35:31 UTC (rev 4713)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/CMakeLists.txt	2009-03-28 16:35:35 UTC (rev 4714)
@@ -1,19 +0,0 @@
-SET(ADMaudiofilter_SRCS 
-	audiodeng_buildfilters.cpp    
-#        audiofilter_film2pal.cpp   
-#	audiofilter_bridge.cpp         
-#        audiofilter_limiter.cpp    
-	audiofilter_buildchain.cpp     
-#        audiofilter_mixer.cpp
-#	audiofilter_normalize.cpp
-#        audiofilter_dolby.cpp          
-#        audiofilter_SRC.cpp
-        audio_raw.cpp
-	audioeng_buff.cpp          
-#        audio_encoderWrapper.cpp
-#        audio_encoderPlugin.cpp
-)
-	
-ADD_ADM_LIB_ALL_TARGETS(ADM_audiofilter ${ADMaudiofilter_SRCS})
-INCLUDE_DIRECTORIES(${CMAKE_SOURCE_DIR}/avidemux/ADM_audioEncoder/include)
-

Deleted: branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audio_encoderWrapper.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audio_encoderWrapper.cpp	2009-03-28 16:35:31 UTC (rev 4713)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audio_encoderWrapper.cpp	2009-03-28 16:35:35 UTC (rev 4714)
@@ -1,86 +0,0 @@
-/**
-        \file audio_encoderWrapper.cpp
-        \bried proxy between AUDMEncoder class and AVDMGenericAudioStream
-
-*/
-
-#include "ADM_default.h"
-#include "ADM_coreAudio.h"
-
-#include "audioencoder.h"
-
-#include "audio_encoderWrapper.h"
-#if 0
-/**
-    \fn ADM_audioEncoderWrapper
-    \brief Constructor to wrap an encoder inside ADMgenericblah blah
-
-*/
-ADM_audioEncoderWrapper::ADM_audioEncoderWrapper( AUDMEncoder *coder) : ADM_audioStream(NULL,NULL)
-{
-   
-    memcpy(&wavHeader,coder->_wavheader,sizeof(WAVHeader));
-    _encoder=coder;
-}
-/**
-    \fn ~ADM_audioEncoderWrapper
-    \brief Destructor
-
-*/
-
-ADM_audioEncoderWrapper::~ADM_audioEncoderWrapper()
-{
-    if(_encoder) delete _encoder;
-    
-    _encoder=NULL;
-    
-}
-/**
-    \fn getPacket
-    \brief Trampoline
-
-*/
-
-uint8_t		ADM_audioEncoderWrapper::getPacket(uint8_t *dest, uint32_t *len, uint32_t *samples)
-{
-    ADM_assert(_encoder);
-    return _encoder->getPacket(dest,len,samples);
-}
-
-/**
-    \fn packetPerFrame
-    \brief Trampoline
-
-*/
-uint8_t     ADM_audioEncoderWrapper::packetPerFrame( void)
-{
-//    ADM_assert(_encoder);
-//    return _encoder->packetPerFrame();
-    return 1;
-}
-
-/**
-    \fn read
-    \brief Trampoline
-
-*/
-uint32_t	ADM_audioEncoderWrapper::read(uint32_t size,uint8_t *ptr)
-{
-    ADM_assert(_encoder);
-    return _encoder->read(size,ptr);
-}
-/**
-    \fn extraData
-    \brief Trampoline
-
-*/
-uint8_t		ADM_audioEncoderWrapper::extraData(uint32_t *l,uint8_t **d)
-{
-
-    ADM_assert(_encoder);
-    return _encoder->extraData(l,d);
-
-}
-#endif
-//EOF
-

Deleted: branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audio_encoderWrapper.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audio_encoderWrapper.h	2009-03-28 16:35:31 UTC (rev 4713)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audio_encoderWrapper.h	2009-03-28 16:35:35 UTC (rev 4714)
@@ -1,28 +0,0 @@
-/**
-    \file audio_encoderWrapper.h
-    \brief Do the opposite of the bridge. Transform an ADM_audioEncoder stream to a ADMGenericVideoStream
-
-*/
-#ifndef audio_encoderWrapper_H
-#define audio_encoderWrapper_H
-#include "ADM_audioStream.h"
-#if 0
-class ADM_audioEncoderWrapper :  public ADM_audioStream
-{
-protected:
-        AUDMEncoder *_encoder;
-
-public:
-                            ADM_audioEncoderWrapper( AUDMEncoder *coder);
-        virtual             ~ADM_audioEncoderWrapper();
-        virtual	uint8_t		getPacket(uint8_t *dest, uint32_t *len, uint32_t *samples);
-		virtual uint8_t     packetPerFrame( void);
-
-        virtual uint8_t		goTo(uint32_t offset) {ADM_assert(0);return 0;} // Not supposed to seek..
-        virtual uint32_t	read(uint32_t size,uint8_t *ptr);
-        virtual uint8_t		extraData(uint32_t *l,uint8_t **d);
-};
-
-#endif
-#endif
-//EOF

Deleted: branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audio_raw.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audio_raw.cpp	2009-03-28 16:35:31 UTC (rev 4713)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audio_raw.cpp	2009-03-28 16:35:35 UTC (rev 4714)
@@ -1,145 +0,0 @@
-/***************************************************************************
-                          audioeng_rawshift.cpp  -  description
-                             -------------------
-
- 	This filter i used only in copy mode
-			     
-    begin                : Fri Jun 28 2002
-    copyright            : (C) 2002 by mean
-    email                : fixounet at free.fr
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-#include "config.h"
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <math.h>
-
-#include "ADM_default.h"
-
-#include "ADM_audioStream.h"
-#include "audioprocess.hxx"
-#include "audio_raw.h"
-#if 0
-AVDMProcessAudio_RawShift::AVDMProcessAudio_RawShift(ADM_audioStream * instream,
-      uint32_t starttime, int32_t msoff): AVDMBufferedAudioStream    (instream)
-{
-    _wavheader = new WAVHeader;
-    memcpy(_wavheader, _instream->getInfo(), sizeof(WAVHeader));
-    _starttime=starttime;
-    
-    _hold=0;
-    printf("[Raw shift] : Start:%u ms, shift  %d\n",_starttime,msoff);
-    msoff=-msoff;
-        if (msoff > 0) // just seek in the file
-        {
-                _starttime+=msoff;
-                _instream->goToTime(  _starttime);
-        }
-        else
-        {
-                // need to dupe the beginning
-                // if there is enough audio
-                msoff=-msoff;
-                if(_starttime>=msoff)
-                {
-                        _starttime-=msoff;
-                        _instream->goToTime(  _starttime); // just rewind to compensate
-                }
-                else
-                {
-                        // we have to dupe a bit
-                        msoff-=_starttime;
-                        _starttime=0;
-                        int32_t dupe;
-                        _instream->goToTime(0);
-                        _hold=(msoff*_wavheader->frequency)/1000; // in sample
-                }
-        }
-//    _length = instream->getLength();
-    printf("[Raw shift] : Start:%u ms, offset in sample  %d\n",_starttime,_hold);
-};
-
-AVDMProcessAudio_RawShift::~AVDMProcessAudio_RawShift()
-{
-  delete _wavheader;
-}
-
-//
-//	If filterOn, it means we have to dupe sampleOffset sample, going back to start
-//		and do it again
-//
-uint8_t	 AVDMProcessAudio_RawShift::getPacket(uint8_t *dest, uint32_t *len, uint32_t *samples)
-{
-        uint8_t r;
-        uint64_t dts;
-                
-                if(!_hold)
-                        return _instream->getPacket(dest,len,64*1024,samples,&dts); // BAZOOKA
-
-                // filter is still on
-                r=_instream->getPacket(dest,len,64*1024,samples,&dts); // BAZOOKA
-
-
-                if(!r)
-                {
-                        printf("[RawShift]: Readerror\n");
-                        *len=0;
-                        *samples=0;
-                        return 0;
-                }
-                if(_hold>0)
-                {
-                  _hold-=(int32_t)*samples;
-                  if(_hold<=0)
-                  {
-                    _hold=0;  
-                    _instream->goToTime(  _starttime);
-                    printf("[RawShift] Rewinding to %u ms \n",_starttime);
-                  }
-                }
-              return r;
-
-}
-
-uint32_t AVDMProcessAudio_RawShift::read(uint32_t len, uint8_t * buffer)
-{
-    return readDecompress(len, buffer);
-};
-uint32_t AVDMProcessAudio_RawShift::readDecompress(uint32_t len,
-						    uint8_t * buffer)
-{
- uint32_t l,sam;
-          if(!getPacket(buffer,&len,&sam))
-                  return 0;
-          return len;
-
-}
-uint8_t AVDMProcessAudio_RawShift::goToTime(uint32_t newoffset)
-{
-        // since we are in copy mode, the only value accepted is 0 here
-        ADM_assert(!newoffset);
-        _instream->goToTime(  _starttime);
-        return 1;
-}
-
-uint8_t AVDMProcessAudio_RawShift::goTo(uint32_t newoffset)
-{
-
-        // since we are in copy mode, the only value accepted is 0 here
-        ADM_assert(!newoffset);
-        _instream->goToTime(  _starttime);
-        return 1;
-};
-// EOF
-#endif

Deleted: branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audio_raw.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audio_raw.h	2009-03-28 16:35:31 UTC (rev 4713)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audio_raw.h	2009-03-28 16:35:35 UTC (rev 4714)
@@ -1,19 +0,0 @@
-/***************************************************************************
-    copyright            : (C) 2006 by mean
-    email                : fixounet at free.fr
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#ifndef AUDIO_RSHIFT_H
-#define AUDIO_RSHIFT_H
-#include "ADM_audioStream.h"
-
-#endif
-//EOF

Deleted: branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiodeng_buildfilters.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiodeng_buildfilters.cpp	2009-03-28 16:35:31 UTC (rev 4713)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiodeng_buildfilters.cpp	2009-03-28 16:35:35 UTC (rev 4714)
@@ -1,371 +0,0 @@
-/***************************************************************************
-                          audiodeng_buildfilters.cpp  -  description
-                             -------------------
-    begin                : Mon Dec 2 2002
-    copyright            : (C) 2002 by mean
-    email                : fixounet at free.fr
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#include "config.h"
-#include <math.h>
-
-#include "ADM_default.h"
-
-#include "audiofilter_limiter_param.h"
-#include "audiofilter_normalize_param.h"
-
-#include "ADM_audiofilter/audioeng_buildfilters.h"
-
-
-#include "audioencoder.h"
-
-#include "ADM_audiocodec/ADM_audiocodeclist.h"
-
-
-#include "audiofilter_bridge.h"
-#include "audiofilter_mixer.h"
-#include "audiofilter_normalize.h"
-#include "audiofilter_limiter.h"
-
-#include "prefs.h"
-
-#include "ADM_osSupport/ADM_debugID.h"
-#define MODULE_NAME MODULE_AUDIO_FILTER
-#include "ADM_osSupport/ADM_debug.h"
-
-extern void UI_setAProcessToggleStatus( uint8_t status );
-extern uint8_t DIA_audioCodec( int *codec );
-extern void UI_setAudioCodec( int i);
-uint32_t audioFilterGetNbEncoder(void);
-const char* audioFilterGetIndexedName(uint32_t i);
-
-
-typedef struct externalSource
-{
- AudioSource type;
- const char *name;
-}externalSource;
-
-static const externalSource Sources[]=
-{
-        {AudioAvi,"VIDEO"},
-        {AudioMP3,"MP3"},
-        {AudioWav,"WAV"},
-        {AudioAC3,"AC3"},
-        {AudioNone,"NONE"}
-};
-typedef struct
-{
-  const char         *name;
-  CHANNEL_CONF conf;
-}Mixer_String;
-
-#define DOME(x) {#x,CHANNEL_##x}
-static Mixer_String Mixer_strings[]=
-{
-  {"NONE",CHANNEL_INVALID},
-  DOME(MONO),
-  DOME(STEREO),
-  DOME(2F_1R),
-  DOME(3F),
-  DOME(3F_1R),
-  DOME(2F_2R),
-  DOME(3F_2R),
-  DOME(3F_2R_LFE),
-  DOME(DOLBY_PROLOGIC),
-  DOME(DOLBY_PROLOGIC2)
-
-};
-
-
-
-extern void UI_PrintCurrentACodec( const char *s);
-
-
-/*----------------------------------*/
-GAINparam audioGain;
-int  audioFreq=48000;
-int  audioDRC = 0;
-FILMCONV audioFilmConv=FILMCONV_NONE;
-RESAMPLING  audioResampleMode = RESAMPLING_NONE;
-CHANNEL_CONF audioMixing=CHANNEL_INVALID;
-// These are globals for the moment
-//************************************
-int 	   audioShift = 0;
-int	   audioDelay=0;
-//**********
-
-const char              *getCurrentMixerString(void)
-{
-        uint32_t nb=sizeof(Mixer_strings)/sizeof(Mixer_String);
-        for(uint32_t i=0;i<nb;i++)
-                if(audioMixing==Mixer_strings[i].conf) return Mixer_strings[i].name;
-        ADM_assert(0);
-
-}
-uint8_t                    setCurrentMixerFromString(const char *name)
-{
-        uint32_t nb=sizeof(Mixer_strings)/sizeof(Mixer_String);
-        for(uint32_t i=0;i<nb;i++)
-                if(!strcasecmp(name,Mixer_strings[i].name))
-                {
-                  audioMixing= Mixer_strings[i].conf;
-                  return 1;
-                }
-        return 0;
-
-}
-//**********
-
-const char              *audioSourceFromEnum(AudioSource src)
-{
-        uint32_t nb=sizeof(Sources)/sizeof(externalSource);
-        for(uint32_t i=0;i<nb;i++)
-                if(src==Sources[i].type) return Sources[i].name;
-        ADM_assert(0);
-
-}
-AudioSource             audioSourceFromString(const char *name)
-{
-        uint32_t nb=sizeof(Sources)/sizeof(externalSource);
-        for(uint32_t i=0;i<nb;i++)
-                if(!strcasecmp(name,Sources[i].name)) return Sources[i].type;
-        return (AudioSource)0;
-
-}
-
-//**********
-uint8_t audioReset(void )
-{
-  audioGain.mode=ADM_NO_GAIN;
-  audioResampleMode = RESAMPLING_NONE;
-  audioFilmConv=FILMCONV_NONE;
-  audioMixing=CHANNEL_INVALID;
-  return 1;
-}
-//************
-uint8_t audioGetNormalizeMode(void)
-{
-  return audioGain.mode;
-
-}
-int32_t  audioGetNormalizeValue(void)
-{
-  return audioGain.gain10;
-
-}
-
-uint32_t audioGetResample(void)
-{
-      return audioFreq;
-
-}
-uint32_t audioGetDrc(void)
-{
-  return audioDRC;
-}
-uint32_t audioGetDelay(void)
-{
-        if(audioShift && audioDelay)
-        {
-                return audioDelay;
-
-        }
-        return 0;
-}
-FILMCONV audioGetFpsConv(void)
-{
-        return audioFilmConv;
-}
-
-/*----------------------------------*/
-//
-
-
-
-
-void audioFilterNormalizeMode(uint8_t onoff)
-{
-  audioGain.mode=(ADM_GAINMode)onoff;
-}
-void audioFilterNormalizeValue(int v)
-{
-  audioGain.gain10=v;
-}
-
-uint8_t audioFilterDelay(int32_t delay)
-{
-	if(delay)
-	{
-		audioShift=1;
-		audioDelay=delay;
-	}
-	else
-	{
-		audioShift=audioDelay=0;
-	}
-	return 1;
-
-}
-RESAMPLING  audioGetResampling(void)
-{
-        return audioResampleMode;
-}
-uint8_t audioFilterFilm2Pal(uint8_t onoff)
-{
-	if(onoff) audioFilmConv=FILMCONV_FILM2PAL;
-	else audioFilmConv=FILMCONV_NONE;
-	return 1;
-}
-uint8_t audioFilterDrc(uint8_t onoff)
-{
-  audioDRC=onoff;
-  return 1;
-}
-uint8_t audioFilterPal2Film(uint8_t onoff)
-{
-        if(onoff) audioFilmConv=FILMCONV_PAL2FILM;
-        else audioFilmConv=FILMCONV_NONE;
-        return 1;
-}
-
-void audioFilterResample(uint32_t onoff)
-{
-	if(onoff)
-	{
-		audioResampleMode=RESAMPLING_CUSTOM;
-		audioFreq=onoff;
-	}
-	else
-		audioResampleMode=RESAMPLING_NONE;
-
-}
-//______________________________
-//#include "ADM_gui2/GUI_ui.h"
-uint8_t UI_setTimeShift(int onoff,int value);
-extern  int DIA_getAudioFilter(GAINparam *normalized, RESAMPLING *downsamplingmethod, int *tshifted,
-  			 int *shiftvalue, int *drc,int *freqvalue,FILMCONV *filmconv,CHANNEL_CONF *channel);
-
-void audioFilter_configureFilters( void )
-{
-    int olddelay=audioDelay;
-    int oldshift=audioShift;
-	 DIA_getAudioFilter(&audioGain,&audioResampleMode,&audioShift,&audioDelay,&audioDRC,&audioFreq,
-	 		&audioFilmConv,&audioMixing );
-         if(audioDelay!=olddelay ||oldshift!= audioShift)
-         {  // Refresh
-
-
-
-         }
-
-}
-
-/*
-
-*/
-
-#define Read(x) { \
-		tmp=name; \
-		if((tmp=strstr(name,#x))) \
-			{ \
-				tmp+=strlen(#x); \
-				aprintf("-- %s\n",tmp); \
-				sscanf(tmp,"=%d ",(int *)&x); \
-			} \
-			 else \
-			{ printf("*** %s not found !***\n",#x);} \
-		}
-#define Add(x) {sprintf(tmp,"%s=%d ",#x,x);strcat(conf,tmp);}
-
-uint8_t audioFilterSetByName( const char *name)
-{
-	const char *tmp;
-	aprintf("-Audio filter by name : %s\n",name);
-
-	Read(audioGain.mode);
-        Read(audioGain.gain10);
-	Read(audioResampleMode);
-	Read(audioDRC);
-	Read(audioShift);
-	Read(audioDelay);
-	Read(audioFreq);
-	Read(audioMixing);
-	return 1;
-}
-
-const char *audioFilterGetName( void )
-{
-	static char conf[400];
-	static char tmp[200];
-	conf[0]=0;
-	#undef Add
-	#define Add(x) {sprintf(tmp,"%s=%d ",#x,x);strcat(conf,tmp);}
-	Add(audioGain.mode);
-        Add(audioGain.gain10);
-	Add(audioResampleMode);
-	Add(audioDRC);
-	Add(audioShift);
-	Add(audioDelay);
-	Add(audioFreq);
-	Add(audioMixing);
-	return conf;
-
-}
-
-
-/*
-	Refresh   activeAudioEncoder value
-	depending on what's selected
-
-*/
-
-
-
-void audioSetResample(uint32_t fq)
-{
-
-	audioResampleMode=RESAMPLING_CUSTOM;
-	audioFreq=fq;
-}
-/**
- * 	\fn getAudioOuputFrequency
- *  \brief Return the encoding of the currently selected codec
- */
-uint32_t audioProcessMode(void);
-uint32_t audioFilter_getOuputFrequency(uint32_t inputFrequency)
-{
-	if(!audioProcessMode()) return inputFrequency;
-	if(audioResampleMode == RESAMPLING_NONE) return inputFrequency;
-	return audioFreq;
-}
-/**
-    \fn audioCodecGetName
-    \brief Returns the current codec tagname
-*/
-
-AudioSource audioCodecGetFromName( const char *name)
-{
-                for(uint32_t i=0;i<sizeof(Sources)/sizeof(externalSource);i++)
-                {
-                        if(!strcasecmp(name,Sources[i].name))
-                        {
-
-                                return Sources[i].type;
-                        }
-
-                }
-                printf("\n Mmmm Select audio codec by name failed...(%s).\n",name);
-                return AudioNone;
-}
-
-//EOF
-

Deleted: branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audioeng_buff.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audioeng_buff.cpp	2009-03-28 16:35:31 UTC (rev 4713)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audioeng_buff.cpp	2009-03-28 16:35:35 UTC (rev 4714)
@@ -1,152 +0,0 @@
-/***************************************************************************
-                          audioeng_buff.cpp  -  description
-
-  	That is a derivated class to handle generically buffered input/output
-	
-                             -------------------
-    begin                : Thu Feb 7 2002
-    copyright            : (C) 2002 by mean
-    email                : fixounet at free.fr
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#include "config.h"
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include "ADM_assert.h"
-#include <math.h>
-
-#include "ADM_default.h"
-
-#include "audioprocess.hxx"
-//
-#if 0
-AVDMBufferedAudioStream::AVDMBufferedAudioStream(ADM_audioStream * instream):AVDMGenericAudioStream()
-{
-        _instream=instream;
-        _chunk = 4096;
-        _headBuff=_tailBuff=0;
-}
-
-AVDMBufferedAudioStream::~AVDMBufferedAudioStream()
-{
-}
-
-//
-//
-uint32_t AVDMBufferedAudioStream::read(uint32_t len, uint8_t * buffer)//deprecate
-{
-	uint32_t avail = 0;
-	uint32_t got=0;
-	uint32_t grabbed;
-	uint8_t  *myBuffer;
-	myBuffer=(uint8_t *)internalBuffer;
-
-more:
-	// have we already got what's needed ?
-	avail=_tailBuff-_headBuff;
-	//    printf("\n asked : %lu, available : %lu",len,avail);
-	// got everything ?
-	if (avail >= len) {
-		memcpy(buffer, myBuffer+_headBuff, len);
-		_headBuff+=len;
-		got+=len;
-		//printf("Got : %lu\n",got);
-		return got;
-	}
-	// first empty what was available
-	memcpy(buffer, myBuffer+_headBuff, avail);
-
-	got+=avail;
-	len -= avail;
-	buffer+=avail;
-	_headBuff+=avail;
-
-	// rewind to beginning
-	_tailBuff=_headBuff=0;
-
-	//printf("\n grabing...");
-	grabbed = grab(myBuffer);
-	//  printf("grabbed :%lu\n",grabbed);
-	// Minus one means we could not get a single byte
-	if (grabbed == MINUS_ONE) {
-		printf("\n ** end stream **\n");
-		_tailBuff=_headBuff=0;	
-		return got;		// we got everything  !
-	}
-	_tailBuff+=grabbed;
-	goto more;
-};
-
-uint32_t AVDMBufferedAudioStream::read(uint32_t len, float *buffer)
-{
-    uint32_t avail = 0;
-    uint32_t got = 0;
-    uint32_t grabbed;
-    // this disable the filter
-    // return _instream->read(len,buffer);
-
-more:
-
-
-    // have we already got what's needed ?
-    avail=_tailBuff-_headBuff;
- //    printf("\n asked : %lu, available : %lu",len,avail);  
-    // got everything ?
-    if (avail >= len)
-      {	
-	  memcpy(buffer, internalBuffer_float + _headBuff, sizeof(float) * len);
-	  _headBuff+=len;
-	  got+=len;
-//	  printf("Got : %lu\n",got);
-	  return got;
-      }
-    // first empty what was available
-    memcpy(buffer, internalBuffer_float + _headBuff, sizeof(float) * avail);
-
-    got+=avail;
-    len -= avail;
-    buffer+=avail;
-    _headBuff+=avail;
-
-
-    // rewind to beginning
-    _tailBuff=_headBuff=0;
-
-    //printf("\n grabing...");
-    grabbed = grab(internalBuffer_float);
-  //  printf("grabbed :%lu\n",grabbed);
-    // Minus one means we could not get a single byte
-    if (grabbed == MINUS_ONE)
-      {
-	  printf("\n ** end stream **\n");
-	  _tailBuff=_headBuff=0;	
-	  return got;		// we got everything  !
-      }
-    _tailBuff+=grabbed;
-    goto more;
-};
-
-uint8_t AVDMBufferedAudioStream::goTo(uint32_t newoffset) {
-        ADM_assert(!newoffset);
-        goToTime(0);
-        return 1;
-}
-
-uint8_t AVDMBufferedAudioStream::goToTime(uint32_t newoffset) {
-        ADM_assert(!newoffset);
-        _instream->goToTime(0);
-        _headBuff=_tailBuff=0;
-        return 1;
-}
-#endif
-// EOF

Deleted: branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audioeng_buildfilters.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audioeng_buildfilters.h	2009-03-28 16:35:31 UTC (rev 4713)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audioeng_buildfilters.h	2009-03-28 16:35:35 UTC (rev 4714)
@@ -1,107 +0,0 @@
-/**************************************************************************
-                          audioeng_buildfilters.h  -  description
-                             -------------------
-    begin                : Mon Dec 2 2002
-    copyright            : (C) 2002 by mean
-    email                : fixounet at free.fr
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#ifndef ADM_AUDIO_BUILDFILTER_H
-#define  ADM_AUDIO_BUILDFILTER_H
-
-#include "audioencoder.h"
-#include "ADM_audio/aviaudio.hxx"
-
-#include "audioEncoderApi.h"
-#include "ADM_audioStream.h"
-
- ADM_audioStream *buildAudioFilter(ADM_audioStream *stream, uint32_t startTime);
- AUDMAudioFilter *buildPlaybackFilter(ADM_audioStream *currentaudiostream,
-				uint32_t starttime, uint32_t duration);
-
- void deleteAudioFilter(ADM_audioStream *in);
-void audioFilter_configureFilters( void );
-
-
-
-void audioCodecConfigure( void );
-void audioCodecSelect( void );
-void audioFilter_MP3DisableReservoir(int onoff);
-uint32_t audioFilter_getOuputCodec(void);
-uint32_t audioFilter_getOuputFrequency(uint32_t inputFrequency);
-uint32_t audioFilter_getMaxChannels(void);
-
-//#include "ADM_audioEncoder/include/audioencoder_enum.h"
-
-typedef enum 
-{
-	RESAMPLING_NONE=0,
-	RESAMPLING_CUSTOM=1,
-	RESAMPLING_LAST
-}RESAMPLING;
-
-typedef enum 
-{
-	FILMCONV_NONE=0,
-	FILMCONV_FILM2PAL=1,
-	FILMCONV_PAL2FILM=2,
-	FILMCONV_LAST
-}FILMCONV;
-
-typedef enum
-{
-        AudioInvalid,
-        AudioAvi=1,
-        AudioMP3,
-        AudioWav,
-        AudioAC3,
-        AudioNone
-
-}AudioSource;
-
-//void audioCodecSetcodec(AUDIOENCODER codec);
-uint8_t audioReset(void);
-/*  for job/workspace stuff  */
-const char *audioFilterGetName( void );
-uint8_t audioFilterSetByName( const char *name);
-
-//AVDMGenericAudioStream *mpt_getAudioStream(void);
-
-/* -- Set filter --*/
-void audioFilterNormalizeMode(uint8_t onoff);
-void audioFilterNormalizeValue(int value);
-void audioFilterResample(uint32_t onoff);
-uint8_t audioFilterDelay(int32_t delay);
-uint8_t audioFilterFilm2Pal(uint8_t onoff);
-uint8_t audioFilterPal2Film(uint8_t onoff);
-uint8_t audioFilterDrc(uint8_t onoff);
-void audioFilter_SetBitrate( int i);
-/* -- Get filter -- */
-uint32_t audioGetBitrate(void);
-uint8_t audioGetNormalizeMode(void);
-int32_t audioGetNormalizeValue(void);
-uint32_t audioGetResample(void);
-uint32_t audioGetDelay(void);
-FILMCONV audioGetFpsConv(void);
-uint32_t audioGetDrc(void);
-RESAMPLING  audioGetResampling(void);
-/*-----*/
-uint8_t                 A_changeAudioStream(ADM_audioStream *newaudio,AudioSource so,char *name);
-AudioSource             getCurrentAudioSource(char **name);
-const char              *audioSourceFromEnum(AudioSource src);
-AudioSource             audioSourceFromString(const char *name);
-const char              *getCurrentMixerString(void);
-uint8_t                 setCurrentMixerFromString(const char *string);
-
-//*****
-//
-#endif
-

Deleted: branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_buildchain.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_buildchain.cpp	2009-03-28 16:35:31 UTC (rev 4713)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audiofilter_buildchain.cpp	2009-03-28 16:35:35 UTC (rev 4714)
@@ -1,361 +0,0 @@
-/***************************************************************************
-                          audiodeng_buildfilters.cpp  -  description
-                             -------------------
-    begin                : Mon Dec 2 2002
-    copyright            : (C) 2002 by mean
-    email                : fixounet at free.fr
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-#include "config.h"
-#include "ADM_default.h"
-#include "DIA_coreToolkit.h"
-
-#include "audioencoder.h"
-
-#include "audiofilter_limiter_param.h"
-#include "audiofilter_normalize_param.h"
-#include "audio_encoderWrapper.h"
-
-#include "audioprocess.hxx"
-#include "ADM_audiofilter/audioeng_buildfilters.h"
-#include "ADM_audiofilter/audio_raw.h"
-#include "ADM_editor/ADM_edit.hxx"
-extern ADM_Composer *video_body;
-
-/* ************* Encoder *********** */
-
-#include "ADM_audiocodec/ADM_audiocodeclist.h"
-
-
-#include "prefs.h"
-
-
-/* ************ Filters *********** */
-#include "audiofilter_bridge.h"
-#include "audiofilter_mixer.h"
-#include "audiofilter_normalize.h"
-#include "audiofilter_limiter.h"
-#include "audiofilter_SRC.h"
-#include "audiofilter_film2pal.h"
-
-/* ************ Conf *********** */
-//#include "audioencoder_config.h"
-
-
-#include "ADM_osSupport/ADM_debugID.h"
-#define MODULE_NAME MODULE_AUDIO_FILTER
-#include "ADM_osSupport/ADM_debug.h"
-
-#define MAX_AUDIO_FILTER 10
-
-
-static AUDMAudioFilter *filtersFloat[MAX_AUDIO_FILTER];
-static uint32_t filtercount = 0;
-
-extern uint32_t audioProcessMode(void);
-
-/******************************************************
-  Configuration variables for filters
-******************************************************/
-
-extern AUDIOENCODER  activeAudioEncoder;
-
-extern GAINparam audioGain;
-extern int  audioFreq;
-extern int  audioDRC;
-extern FILMCONV audioFilmConv;
-extern CHANNEL_CONF audioMixing;
-extern int audioMP3mode;
-extern int audioMP3bitrate;
-extern RESAMPLING  audioResampleMode;
-extern int   audioShift ;
-extern int   audioDelay;
-
-static DRCparam drcSetup=
-{
-  1,
-  0.001,//double   mFloor;
-  0.2, //double   mAttackTime;
-  1.0, //double   mDecayTime;
-  2.0, //double   mRatio;
-  -12.0 ,//double   mThresholdDB;
-};
-
-
-
-//
-// Build audio filters
-// Starttime : starttime in ms
-// mode : 0 for playback,  1 for audio save
-//_______________________________________
-
-
-AUDMAudioFilter *buildInternalAudioFilter(ADM_audioStream *currentaudiostream,uint32_t starttime)
-{
-
-  AUDMAudioFilter *firstFilter = NULL;
-  AUDMAudioFilter *lastFilter = NULL;
-  
-//  deleteAudioFilter(NULL);
-  int32_t timeShiftMs=audioDelay*audioShift;
-  
-  
-  firstFilter = new AUDMAudioFilter_Bridge(video_body, starttime,timeShiftMs);
-  filtercount = 0;
-  lastFilter = firstFilter;
-  filtersFloat[filtercount++] = firstFilter;
-
-
-
-//_______________________________________________________
-      if( (audioMixing!=CHANNEL_INVALID ))
-          {
-            AUDMAudioFilter *mixer;
-            mixer=new AUDMAudioFilterMixer( lastFilter,audioMixing);
-            lastFilter = mixer;
-            filtersFloat[filtercount++] = lastFilter;
-          } 
-#if 0
-    if (audioDRC)
-          {
-            AUDMAudioFilterLimiter *pdrc = NULL;
-            printf("\n  DRC activated...\n");
-            pdrc = new AUDMAudioFilterLimiter(lastFilter,&drcSetup);
-            lastFilter = (AUDMAudioFilter *)pdrc;
-            filtersFloat[filtercount++] = lastFilter;
-          
-          }
-
-      switch(audioResampleMode)
-          {
-                  
-            case RESAMPLING_NONE: break;
-            case RESAMPLING_CUSTOM:
-            {
-                      AUDMAudioFilterSrc  *resample=NULL;
-                      resample = new AUDMAudioFilterSrc(lastFilter, audioFreq);
-                      lastFilter = resample;
-                      filtersFloat[filtercount++] = lastFilter;	
-            }
-                      break;
-
-            default:
-                      ADM_assert(0);
-          }
-
-      switch(audioFilmConv)
-        {
-          default:
-                        ADM_assert(0);
-          case FILMCONV_NONE:
-                        break;
-          case FILMCONV_PAL2FILM:		
-                  AUDMAudioFilterPal2Film *p2f;
-                        p2f = new AUDMAudioFilterPal2Film(lastFilter);
-                        lastFilter = p2f;
-                        filtersFloat[filtercount++] = lastFilter;	
-                        break;
-                        
-                
-          case FILMCONV_FILM2PAL:
-                    AUDMAudioFilterFilm2Pal *f2p;
-                        f2p = new AUDMAudioFilterFilm2Pal(lastFilter);
-                        lastFilter = f2p;
-                        filtersFloat[filtercount++] = lastFilter;	
-                        break;
-                
-                        
-        }   
-
-      if ( audioGain.mode!=ADM_NO_GAIN)	// Normalize activated ?
-      {
-        printf("\n  normalize activated..\n");
-      
-        AUDMAudioFilterNormalize *normalize = new AUDMAudioFilterNormalize(lastFilter,&audioGain);
-        lastFilter = normalize;
-        filtersFloat[filtercount++] = lastFilter;
-      
-      }
-#endif
-//_______________________________________________________
-
-
-
-
-    return lastFilter;
-}
-/**
-
-    \fn buildPlaybackFilter
-    \brief Warning : starttime is in ms, not us!
-    @param currentaudiostream : audio stream to build playback from
-    @param starttime starting time in ms
-    @param duration duration of stream in ms
-*/
-AUDMAudioFilter *buildPlaybackFilter(ADM_audioStream *currentaudiostream, uint32_t starttime, uint32_t duration)
-{
-  AUDMAudioFilter *lastFilter=NULL;
-  int32_t sstart;
-  uint32_t channels;
-        // Do we need to go back
-  sstart=(int32_t)starttime;
-  int32_t timeShiftMs=audioDelay*audioShift;
-        
-//  deleteAudioFilter(NULL);
-  
-  lastFilter = new AUDMAudioFilter_Bridge(video_body,sstart,timeShiftMs);
-        filtercount = 0;
-        filtersFloat[filtercount++] = lastFilter;
-        
-        
-        // Downmix for local playback ?
-  
-        uint32_t downmix;
-        
-        if(prefs->get(DOWNMIXING_PROLOGIC,&downmix)!=RC_OK)
-        {       
-          downmix=0;
-        }
-        channels=lastFilter->getInfo()->channels;
-        if( downmix && channels>2)
-        {
-          CHANNEL_CONF mix;
-          switch (downmix) {
-		case 1:
-			printf("Downmixing to stereo\n");
-			mix=CHANNEL_STEREO;
-		break;
-		case 2:
-			printf("Downmixing to prologic\n");
-			mix=CHANNEL_DOLBY_PROLOGIC;
-		break;
-		case 3:
-			printf("Downmixing to prologic2\n");
-			mix=CHANNEL_DOLBY_PROLOGIC2;
-		break;
-		default:
-			ADM_assert(0);
-          }
-          AUDMAudioFilterMixer *mixer;
-          mixer=new AUDMAudioFilterMixer( lastFilter,mix);
-          lastFilter = mixer;
-          filtersFloat[filtercount++] = lastFilter;
-        }	
-
-        return lastFilter;
-}
-/*
-*******************************************************************************************************************
-
-*******************************************************************************************************************
-*/
-
-ADM_audioStream *buildAudioFilter(ADM_audioStream *currentaudiostream,  uint32_t starttime)
-{
-#if 0
-  AUDMAudioFilter         *lastFilter=NULL;
-  ADM_audioStream         *output=NULL;
-  AUDMEncoder             *tmpfilter=NULL;
-	// if audio is set to copy, we just return the first filter
-  if(!audioProcessMode())
-  {
-    int32_t timeShiftMs=audioDelay*audioShift;
-//    deleteAudioFilter(NULL);
-//    output = new AVDMProcessAudio_RawShift(currentaudiostream, starttime, timeShiftMs);
-    return output;
-
-  }
-
-
-
-// else we build the full chain
-  lastFilter=buildInternalAudioFilter(currentaudiostream,starttime);
-  
-// and add encoder...
-
-
-//_______________________________________________________
-  uint8_t init;
-  
-  if(!lastFilter)
-  {
-    printf(" buildInternalAudioFilter failed\n");
-    return 0;
-  }
-  if(lastFilter->getInfo()->channels > audioFilter_getMaxChannels())
-  {
-    GUI_Error_HIG(QT_TR_NOOP("Codec Error"),QT_TR_NOOP("The number of channels is greater than what the selected audio codec can do.\n"
-        "Either change codec or use the mixer filter to have less channels."));
-//    deleteAudioFilter(NULL);
-    return 0; 
-  }
-
-  tmpfilter=audioEncoderCreate(lastFilter);
-  if(!tmpfilter || !tmpfilter->initialize())
-  {
-    if(tmpfilter) delete tmpfilter;
-    tmpfilter=NULL;
-    GUI_Error_HIG(QT_TR_NOOP("[BuildChain] Encoder initialization failed"), QT_TR_NOOP("Not activated."));
-  }
-  ADM_audioEncoderWrapper *wrapper=new ADM_audioEncoderWrapper(tmpfilter);
-//  output=wrapper;
-
-  ADM_assert(output);
-  return output;
-#endif
-}
-
-
-/*
-*******************************************************************************************************************
-     delete audio filters
-*******************************************************************************************************************
-*/
-#if 0
-void deleteAudioFilter(AVDMGenericAudioStream *in)
-{
-  for (uint32_t i = 0; i < filtercount; i++)
-  {
-    delete filtersFloat[i];
-    filtersFloat[i] = NULL;
-  }
-  if(in)
-    delete in;
-  filtercount = 0;
-  if (currentaudiostream)
-    currentaudiostream->endDecompress();
-
-}
-#endif
-/**
-    \fn     audioFilter_MP3DisableReservoir
-    \brief  Set/unset the disable reservoir bit, usefull for strict mp3 frame boundaries(FLV)
-
-*/
-void audioFilter_MP3DisableReservoir(int onoff)
-{
-#if 0
-      if(activeAudioEncoder!=AUDIOENC_MP3) return;
-      ADM_audioEncoderDescriptor *desc=getAudioDescriptor( activeAudioEncoder);
-      ADM_assert(desc);
-      LAME_encoderParam *param=(LAME_encoderParam *)desc->param;
-      ADM_assert(param);
-      param->disableReservoir=onoff;
-#endif
-}
-
-/**********************************************/
-
-
-
-
-

Deleted: branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audioprocess.hxx
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audioprocess.hxx	2009-03-28 16:35:31 UTC (rev 4713)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/audioprocess.hxx	2009-03-28 16:35:35 UTC (rev 4714)
@@ -1,27 +0,0 @@
-/***************************************************************************
-                          audioprocess.hxx  -  description
-                             -------------------
-    begin                : Sun Jan 13 2002
-    copyright            : (C) 2002 by mean
-    email                : fixounet at free.fr
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-#ifndef __AudioProcess__
-#define __AudioProcess__
-
-#include "ADM_audio/aviaudio.hxx"
-#include "ADM_audioStream.h"
-#define PROCESS_BUFFER_SIZE 48000*4*4 // should be enougth
-#define MINIMUM_BUFFER   8192*4
-
-#endif
-// EOF

Modified: branches/avidemux_2.6_branch_mean/avidemux/ADM_editor/ADM_edLoadSave.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_editor/ADM_edLoadSave.cpp	2009-03-28 16:35:31 UTC (rev 4713)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_editor/ADM_edLoadSave.cpp	2009-03-28 16:35:35 UTC (rev 4714)
@@ -40,7 +40,7 @@
 #include "ADM_videoFilter.h"
 #include "ADM_videoFilter_internal.h"
 
-#include "ADM_audiofilter/audioeng_buildfilters.h"
+#include "audioeng_buildfilters.h"
 #include "ADM_encoder/adm_encConfig.h"
 #include "prefs.h"
 #include "avi_vars.h"

Modified: branches/avidemux_2.6_branch_mean/avidemux/ADM_encoder/adm_encmpeg2enc.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_encoder/adm_encmpeg2enc.cpp	2009-03-28 16:35:31 UTC (rev 4713)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_encoder/adm_encmpeg2enc.cpp	2009-03-28 16:35:35 UTC (rev 4714)
@@ -36,10 +36,10 @@
 #include "ADM_encoder/adm_encoder.h"
 #include "ADM_encoder/adm_encConfig.h"
 
-#include "ADM_audiofilter/audioprocess.hxx"
+#include "audioprocess.hxx"
 
 #include "ADM_libraries/ADM_libmpeg2enc/ADM_mpeg2enc.h"
-#include "ADM_audiofilter/audioeng_buildfilters.h"
+#include "audioeng_buildfilters.h"
 #include "prefs.h"
 #include "adm_encmpeg2enc.h"
 #include "ADM_libraries/ADM_xvidratectl/ADM_ratecontrol.h"

Modified: branches/avidemux_2.6_branch_mean/avidemux/ADM_libraries/ADM_mplex/ADM_mthread.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_libraries/ADM_mplex/ADM_mthread.cpp	2009-03-28 16:35:31 UTC (rev 4713)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_libraries/ADM_mplex/ADM_mthread.cpp	2009-03-28 16:35:35 UTC (rev 4714)
@@ -23,8 +23,8 @@
 #include "ADM_encoder/ADM_vidEncode.hxx"
 #include "ADM_encoder/adm_encoder.h"
 #include "ADM_userInterfaces/ADM_commonUI/DIA_encoding.h"
-#include "ADM_audiofilter/audioprocess.hxx"
-#include "ADM_audiofilter/audioeng_buildfilters.h"
+#include "audioprocess.hxx"
+#include "audioeng_buildfilters.h"
 //#include "ADM_outputs/ADM_lavformat.h"
 #include "ADM_mthread.h"
 

Modified: branches/avidemux_2.6_branch_mean/avidemux/ADM_script/ADM_JSAvidemuxAudio.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_script/ADM_JSAvidemuxAudio.cpp	2009-03-28 16:35:31 UTC (rev 4713)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_script/ADM_JSAvidemuxAudio.cpp	2009-03-28 16:35:35 UTC (rev 4714)
@@ -16,7 +16,7 @@
 #include "ADM_JSAvidemuxAudio.h"
 
 #include "../ADM_userInterfaces/ADM_commonUI/GUI_ui.h"
-#include "ADM_audiofilter/audioeng_buildfilters.h"
+#include "audioeng_buildfilters.h"
 #include "avi_vars.h"
 #include "gui_action.hxx"
 #include "ADM_encoder/ADM_vidEncode.hxx"

Modified: branches/avidemux_2.6_branch_mean/avidemux/ADM_script/ADM_JSAvidemuxVideo.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_script/ADM_JSAvidemuxVideo.cpp	2009-03-28 16:35:31 UTC (rev 4713)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_script/ADM_JSAvidemuxVideo.cpp	2009-03-28 16:35:35 UTC (rev 4714)
@@ -17,7 +17,7 @@
 
 
 #include "../ADM_userInterfaces/ADM_commonUI/GUI_ui.h"
-#include "ADM_audiofilter/audioeng_buildfilters.h"
+#include "audioeng_buildfilters.h"
 #include "avi_vars.h"
 #include "gui_action.hxx"
 #include "ADM_encoder/ADM_vidEncode.hxx"

Modified: branches/avidemux_2.6_branch_mean/avidemux/ADM_script/ADM_JSFunctions.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_script/ADM_JSFunctions.cpp	2009-03-28 16:35:31 UTC (rev 4713)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_script/ADM_JSFunctions.cpp	2009-03-28 16:35:35 UTC (rev 4714)
@@ -33,7 +33,7 @@
 #include "ADM_default.h"
 #include "DIA_coreToolkit.h"
 #include "ADM_editor/ADM_outputfmt.h"
-#include "ADM_audiofilter/audioeng_buildfilters.h"
+#include "audioeng_buildfilters.h"
 #include "adm_scanner.h" 
 #include "avi_vars.h"
 #include "gui_action.hxx"

Modified: branches/avidemux_2.6_branch_mean/avidemux/ADM_script/ADM_JSFunctions.cpp.orig
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_script/ADM_JSFunctions.cpp.orig	2009-03-28 16:35:31 UTC (rev 4713)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_script/ADM_JSFunctions.cpp.orig	2009-03-28 16:35:35 UTC (rev 4714)
@@ -29,7 +29,7 @@
 #include "ADM_default.h"
 #include "DIA_coreToolkit.h"
 #include "ADM_editor/ADM_outputfmt.h"
-#include "ADM_audiofilter/audioeng_buildfilters.h"
+#include "audioeng_buildfilters.h"
 #include "adm_scanner.h" 
 #include "avi_vars.h"
 #include "gui_action.hxx"

Modified: branches/avidemux_2.6_branch_mean/avidemux/ADM_toolkit/ADM_audioQueue.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_toolkit/ADM_audioQueue.cpp	2009-03-28 16:35:31 UTC (rev 4713)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_toolkit/ADM_audioQueue.cpp	2009-03-28 16:35:35 UTC (rev 4714)
@@ -14,8 +14,8 @@
 #include "ADM_default.h"
 #include "ADM_threads.h"
 
-#include "ADM_audiofilter/audioprocess.hxx"
-#include "ADM_audiofilter/audioeng_buildfilters.h"
+#include "audioprocess.hxx"
+#include "audioeng_buildfilters.h"
 
 #include "ADM_audioQueue.h"
 

Modified: branches/avidemux_2.6_branch_mean/avidemux/ADM_toolkit/automation.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_toolkit/automation.cpp	2009-03-28 16:35:31 UTC (rev 4713)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_toolkit/automation.cpp	2009-03-28 16:35:35 UTC (rev 4714)
@@ -32,7 +32,7 @@
 
 #include "gui_action.hxx"
 #include "ADM_encoder/ADM_vidEncode.hxx"
-#include "ADM_audiofilter/audioeng_buildfilters.h"
+#include "audioeng_buildfilters.h"
 #include "prefs.h"
 #include "gtkgui.h"
 

Modified: branches/avidemux_2.6_branch_mean/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_acodec.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_acodec.cpp	2009-03-28 16:35:31 UTC (rev 4713)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_acodec.cpp	2009-03-28 16:35:35 UTC (rev 4714)
@@ -4,8 +4,8 @@
 
 #include "ADM_toolkitGtk.h"
 
-#include "ADM_audiofilter/audioprocess.hxx"
-#include "ADM_audiofilter/audioeng_buildfilters.h"
+#include "audioprocess.hxx"
+#include "audioeng_buildfilters.h"
 //#include "ADM_audiocodec/ADM_audiocodeclist.h"
 
 extern uint32_t audioEncoderGetNumberOfEncoders(void);

Modified: branches/avidemux_2.6_branch_mean/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_calculator.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_calculator.cpp	2009-03-28 16:35:31 UTC (rev 4713)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_userInterfaces/ADM_GTK/ADM_dialog/DIA_calculator.cpp	2009-03-28 16:35:35 UTC (rev 4714)
@@ -25,8 +25,8 @@
 #include "ADM_videoFilter.h"
 #include "ADM_videoFilter_internal.h"
 
-#include "ADM_audiofilter/audioprocess.hxx"
-#include "ADM_audiofilter/audioeng_buildfilters.h"
+#include "audioprocess.hxx"
+#include "audioeng_buildfilters.h"
 
 
 #include "ADM_video/ADM_vidMisc.h"

Modified: branches/avidemux_2.6_branch_mean/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/Q_calculator.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/Q_calculator.cpp	2009-03-28 16:35:31 UTC (rev 4713)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_userInterfaces/ADM_QT4/ADM_dialog/Q_calculator.cpp	2009-03-28 16:35:35 UTC (rev 4714)
@@ -21,7 +21,7 @@
 #include "avi_vars.h"
 #include "ADM_videoFilter.h"
 #include "ADM_audio/aviaudio.hxx"
-#include "ADM_audiofilter/audioeng_buildfilters.h"
+#include "audioeng_buildfilters.h"
 #include "ADM_video/ADM_vidMisc.h"
 #include "ADM_encoder/adm_encConfig.h"
 

Modified: branches/avidemux_2.6_branch_mean/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_audioFilter.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_audioFilter.cpp	2009-03-28 16:35:31 UTC (rev 4713)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_userInterfaces/ADM_commonUI/DIA_audioFilter.cpp	2009-03-28 16:35:35 UTC (rev 4714)
@@ -18,7 +18,7 @@
 
 #include "DIA_factory.h"
 #include "audiofilter_normalize_param.h"
-#include "ADM_audiofilter/audioeng_buildfilters.h"
+#include "audioeng_buildfilters.h"
 /**
     \fn DIA_getAudioFilter
     \brief Dialog to manage audio filters

Modified: branches/avidemux_2.6_branch_mean/avidemux/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/CMakeLists.txt	2009-03-28 16:35:31 UTC (rev 4713)
+++ branches/avidemux_2.6_branch_mean/avidemux/CMakeLists.txt	2009-03-28 16:35:35 UTC (rev 4714)
@@ -53,6 +53,8 @@
 
 INCLUDE_DIRECTORIES("${CMAKE_CURRENT_SOURCE_DIR}")
 INCLUDE_DIRECTORIES("${CMAKE_BINARY_DIR}/config")
+# temp
+INCLUDE_DIRECTORIES("${CMAKE_CURRENT_SOURCE_DIR}/ADM_audioFilter_old/")
 INCLUDE_DIRECTORIES("${CMAKE_CURRENT_SOURCE_DIR}/ADM_core/include")
 INCLUDE_DIRECTORIES("${CMAKE_CURRENT_SOURCE_DIR}/ADM_coreUI/include")
 INCLUDE_DIRECTORIES("${CMAKE_CURRENT_SOURCE_DIR}/ADM_coreImage/include")
@@ -174,7 +176,7 @@
 # Compile and link general subdirs
 ########################################
 SET(ADM_SUBDIR 
-	ADM_audiofilter
+	ADM_audioFilter_old
 	#ADM_audioEncoder
 	ADM_editor
 	ADM_muxerGate

Modified: branches/avidemux_2.6_branch_mean/avidemux/gtk_gui.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/gtk_gui.cpp	2009-03-28 16:35:31 UTC (rev 4713)
+++ branches/avidemux_2.6_branch_mean/avidemux/gtk_gui.cpp	2009-03-28 16:35:35 UTC (rev 4714)
@@ -29,11 +29,11 @@
 
 #include "ADM_audio/aviaudio.hxx"
 #include "ADM_audio/audioex.h"
-#include "ADM_audiofilter/audioprocess.hxx"
+#include "audioprocess.hxx"
 #include "gui_action.hxx"
 #include "gtkgui.h"
 
-#include "ADM_audiofilter/audioeng_buildfilters.h"
+#include "audioeng_buildfilters.h"
 #include "prefs.h"
 #include "ADM_encoder/adm_encConfig.h"
 #include "ADM_userInterfaces/ADM_render/GUI_render.h"

Modified: branches/avidemux_2.6_branch_mean/avidemux/gui_autodrive.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/gui_autodrive.cpp	2009-03-28 16:35:31 UTC (rev 4713)
+++ branches/avidemux_2.6_branch_mean/avidemux/gui_autodrive.cpp	2009-03-28 16:35:35 UTC (rev 4714)
@@ -29,8 +29,8 @@
 
 #include "audio_out.h"
 #include "ADM_audio/aviaudio.hxx"
-#include "ADM_audiofilter/audioprocess.hxx"
-#include "ADM_audiofilter/audioeng_buildfilters.h"
+#include "audioprocess.hxx"
+#include "audioeng_buildfilters.h"
 #include "gui_action.hxx"
 
 #include "ADM_encoder/adm_encConfig.h"

Modified: branches/avidemux_2.6_branch_mean/avidemux/gui_blackframes.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/gui_blackframes.cpp	2009-03-28 16:35:31 UTC (rev 4713)
+++ branches/avidemux_2.6_branch_mean/avidemux/gui_blackframes.cpp	2009-03-28 16:35:35 UTC (rev 4714)
@@ -28,7 +28,7 @@
 #include "prototype.h"
 #include "audio_out.h"
 #include "ADM_audio/aviaudio.hxx"
-#include "ADM_audiofilter/audioprocess.hxx"
+#include "audioprocess.hxx"
 #include "gui_action.hxx"
 #include "gtkgui.h"
 #include "DIA_coreToolkit.h"

Modified: branches/avidemux_2.6_branch_mean/avidemux/gui_savenew.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/gui_savenew.cpp	2009-03-28 16:35:31 UTC (rev 4713)
+++ branches/avidemux_2.6_branch_mean/avidemux/gui_savenew.cpp	2009-03-28 16:35:35 UTC (rev 4714)
@@ -23,7 +23,7 @@
 #include "DIA_coreToolkit.h"
 #include "DIA_enter.h"
 #include "ADM_audio/aviaudio.hxx"
-#include "ADM_audiofilter/audioprocess.hxx"
+#include "audioprocess.hxx"
 
 #include "ADM_videoFilter.h"
 #include "ADM_videoFilter_internal.h"

Modified: branches/avidemux_2.6_branch_mean/plugins/ADM_muxers/muxerAvi/op_avisave.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_muxers/muxerAvi/op_avisave.cpp	2009-03-28 16:35:31 UTC (rev 4713)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_muxers/muxerAvi/op_avisave.cpp	2009-03-28 16:35:35 UTC (rev 4714)
@@ -47,7 +47,7 @@
 
 
 
-#include "ADM_audiofilter/audioeng_buildfilters.h"
+#include "audioeng_buildfilters.h"
 #include "ADM_coreUI/include/DIA_factory.h"
 const char *getStrFromAudioCodec( uint32_t codec);
 //_________________________

Modified: branches/avidemux_2.6_branch_mean/plugins/ADM_muxers/muxerAvi/op_avisavedual.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_muxers/muxerAvi/op_avisavedual.cpp	2009-03-28 16:35:31 UTC (rev 4713)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_muxers/muxerAvi/op_avisavedual.cpp	2009-03-28 16:35:35 UTC (rev 4714)
@@ -33,14 +33,14 @@
 #include "ADM_encoder/ADM_vidEncode.hxx"
 
 #include "ADM_audio/aviaudio.hxx"
-#include "ADM_audiofilter/audioprocess.hxx"
+#include "audioprocess.hxx"
 #include "op_aviwrite.hxx"
 #include "op_avisave.h"
 #include "op_savecopy.h"
 
-#include "ADM_audiofilter/audioprocess.hxx"
+#include "audioprocess.hxx"
 #include "ADM_audio/audioex.h"
-#include "ADM_audiofilter/audioeng_buildfilters.h"
+#include "audioeng_buildfilters.h"
 
 GenericAviSaveCopyDualAudio::GenericAviSaveCopyDualAudio (void	*track)
 			: GenericAviSaveCopy()

Modified: branches/avidemux_2.6_branch_mean/plugins/ADM_muxers/oplug_dummy/oplug_dummy.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_muxers/oplug_dummy/oplug_dummy.cpp	2009-03-28 16:35:31 UTC (rev 4713)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_muxers/oplug_dummy/oplug_dummy.cpp	2009-03-28 16:35:35 UTC (rev 4714)
@@ -42,8 +42,8 @@
 #include "../oplug_mpegFF/oplug_vcdff.h"
 
 #include "ADM_userInterfaces/ADM_commonUI/DIA_encoding.h"
-#include "ADM_audiofilter/audioprocess.hxx"
-#include "ADM_audiofilter/audioeng_buildfilters.h"
+#include "audioprocess.hxx"
+#include "audioeng_buildfilters.h"
 #include "../ADM_lavformat.h"
 #include "fourcc.h"
 #include "ADM_encoder/adm_encConfig.h"

Modified: branches/avidemux_2.6_branch_mean/plugins/ADM_muxers/oplug_flv/oplug_flv.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_muxers/oplug_flv/oplug_flv.cpp	2009-03-28 16:35:31 UTC (rev 4713)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_muxers/oplug_flv/oplug_flv.cpp	2009-03-28 16:35:35 UTC (rev 4714)
@@ -41,8 +41,8 @@
 #include "../oplug_mpegFF/oplug_vcdff.h"
 
 #include "ADM_userInterfaces/ADM_commonUI/DIA_encoding.h"
-#include "ADM_audiofilter/audioprocess.hxx"
-#include "ADM_audiofilter/audioeng_buildfilters.h"
+#include "audioprocess.hxx"
+#include "audioeng_buildfilters.h"
 #include "../ADM_lavformat.h"
 #include "fourcc.h"
 #include "ADM_encoder/adm_encConfig.h"

Modified: branches/avidemux_2.6_branch_mean/plugins/ADM_muxers/oplug_mpeg/op_mpegpass.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_muxers/oplug_mpeg/op_mpegpass.cpp	2009-03-28 16:35:31 UTC (rev 4713)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_muxers/oplug_mpeg/op_mpegpass.cpp	2009-03-28 16:35:35 UTC (rev 4714)
@@ -18,11 +18,11 @@
 #include "ADM_threads.h"
 
 #include "avi_vars.h"
-#include "ADM_audiofilter/audioprocess.hxx"
+#include "audioprocess.hxx"
 
 #include "ADM_userInterfaces/ADM_commonUI/DIA_encoding.h"
 
-#include "ADM_audiofilter/audioeng_buildfilters.h"
+#include "audioeng_buildfilters.h"
 #include "prefs.h"
 #include "DIA_coreToolkit.h"
 #include "ADM_editor/ADM_outputfmt.h"

Modified: branches/avidemux_2.6_branch_mean/plugins/ADM_muxers/oplug_mpegFF/oplug_vcdff.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_muxers/oplug_mpegFF/oplug_vcdff.cpp	2009-03-28 16:35:31 UTC (rev 4713)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_muxers/oplug_mpegFF/oplug_vcdff.cpp	2009-03-28 16:35:35 UTC (rev 4714)
@@ -49,7 +49,7 @@
 #include "../oplug_mpegFF/oplug_vcdff.h"
 
 #include "ADM_userInterfaces/ADM_commonUI/DIA_encoding.h"
-#include "ADM_audiofilter/audioprocess.hxx"
+#include "audioprocess.hxx"
 #include "ADM_audiofilter/audioeng_buildfilters.h"
 #include "../ADM_lavformat.h"
 

Modified: branches/avidemux_2.6_branch_mean/plugins/ADM_muxers/oplug_ogm/op_ogaudio.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_muxers/oplug_ogm/op_ogaudio.cpp	2009-03-28 16:35:31 UTC (rev 4713)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_muxers/oplug_ogm/op_ogaudio.cpp	2009-03-28 16:35:35 UTC (rev 4714)
@@ -38,8 +38,8 @@
 #include "ADM_encoder/ADM_vidEncode.hxx"
 
 #include "ADM_audio/aviaudio.hxx"
-#include "ADM_audiofilter/audioprocess.hxx"
-#include "ADM_audiofilter/audioeng_buildfilters.h"
+#include "audioprocess.hxx"
+#include "audioeng_buildfilters.h"
 #include "ADM_audio/ADM_a52info.h"
 
 #include "op_ogsave.h"



From mean at mail.berlios.de  Sat Mar 28 17:44:35 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sat, 28 Mar 2009 17:44:35 +0100
Subject: [Avidemux-svn-commit] r4715 -
	branches/avidemux_2.6_branch_mean/avidemux
Message-ID: <200903281644.n2SGiZcM018651@sheep.berlios.de>

Author: mean
Date: 2009-03-28 17:44:35 +0100 (Sat, 28 Mar 2009)
New Revision: 4715

Removed:
   branches/avidemux_2.6_branch_mean/avidemux/ADM_audiofilter/
Log:




From mean at mail.berlios.de  Sat Mar 28 18:13:21 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sat, 28 Mar 2009 18:13:21 +0100
Subject: [Avidemux-svn-commit] r4716 -
	branches/avidemux_2.6_branch_mean/avidemux/ADM_coreAudio/src
Message-ID: <200903281713.n2SHDL4a021620@sheep.berlios.de>

Author: mean
Date: 2009-03-28 18:13:20 +0100 (Sat, 28 Mar 2009)
New Revision: 4716

Removed:
   branches/avidemux_2.6_branch_mean/avidemux/ADM_coreAudio/src/ADM_libsamplerate/
Modified:
   branches/avidemux_2.6_branch_mean/avidemux/ADM_coreAudio/src/CMakeLists.txt
Log:
[CoreAudio] Remove unused/moved stuff

Modified: branches/avidemux_2.6_branch_mean/avidemux/ADM_coreAudio/src/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_coreAudio/src/CMakeLists.txt	2009-03-28 16:44:35 UTC (rev 4715)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_coreAudio/src/CMakeLists.txt	2009-03-28 17:13:20 UTC (rev 4716)
@@ -7,12 +7,6 @@
 ADM_audioStreamAC3.cpp
 )	
 #*************************************************
-ADD_DEFINITIONS( "-DADM_LEGACY_PROGGY")
-ADD_DEFINITIONS( "-DHAVE_LRINT -DHAVE_LRINTF ")
-ADD_DEFINITIONS( "-DCPU_CLIPS_POSITIVE=0 -DCPU_CLIPS_NEGATIVE=0")
-ADD_DEFINITIONS( "-I${CMAKE_CURRENT_SOURCE_DIR} ")
-ADD_DEFINITIONS( "-DPACKAGE=`"SRC`"")
-ADD_DEFINITIONS( "-DVERSION=`"0.1.4`"")
 #*************************************************
 ADD_LIBRARY(ADM_coreAudio SHARED ${ADMaudioCore_SRCS})
 INCLUDE_DIRECTORIES(${CMAKE_SOURCE_DIR}/avidemux/ADM_coreAudio/include)



From mean at mail.berlios.de  Sat Mar 28 18:15:14 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sat, 28 Mar 2009 18:15:14 +0100
Subject: [Avidemux-svn-commit] r4717 - in branches/avidemux_2.6_branch_mean:
	avidemux/ADM_audioFilter/src avidemux/ADM_coreAudio/src cmake
Message-ID: <200903281715.n2SHFErn021935@sheep.berlios.de>

Author: mean
Date: 2009-03-28 18:15:14 +0100 (Sat, 28 Mar 2009)
New Revision: 4717

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/src/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/avidemux/ADM_coreAudio/src/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/cmake/ae_plugin.cmake
Log:
[Win32] patch

Modified: branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/src/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/src/CMakeLists.txt	2009-03-28 17:13:20 UTC (rev 4716)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_audioFilter/src/CMakeLists.txt	2009-03-28 17:15:14 UTC (rev 4717)
@@ -33,5 +33,6 @@
 ADD_LIBRARY(ADM_audioFilter STATIC ${ADM_audioFilter_SRCS})
 # For the API part, needed by coreAudioEncoder
 ADD_LIBRARY(ADM_coreAudioFilterAPI SHARED ${ADM_audioFilterAPI_SRCS})
+TARGET_LINK_LIBRARIES(ADM_coreAudioFilterAPI ADM_core ADM_coreUI  )
 INSTALL(TARGETS ADM_coreAudioFilterAPI RUNTIME DESTINATION ${BIN_DIR}  LIBRARY DESTINATION lib  ARCHIVE DESTINATION lib)
 # END

Modified: branches/avidemux_2.6_branch_mean/avidemux/ADM_coreAudio/src/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_coreAudio/src/CMakeLists.txt	2009-03-28 17:13:20 UTC (rev 4716)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_coreAudio/src/CMakeLists.txt	2009-03-28 17:15:14 UTC (rev 4717)
@@ -10,6 +10,6 @@
 #*************************************************
 ADD_LIBRARY(ADM_coreAudio SHARED ${ADMaudioCore_SRCS})
 INCLUDE_DIRECTORIES(${CMAKE_SOURCE_DIR}/avidemux/ADM_coreAudio/include)
-TARGET_LINK_LIBRARIES(ADM_coreAudio ADM_core ADM_coreUI)
+TARGET_LINK_LIBRARIES(ADM_coreAudio ADM_core ADM_coreUI ADM_audioParser)
 
 INSTALL(TARGETS ADM_coreAudio RUNTIME DESTINATION ${BIN_DIR}  LIBRARY DESTINATION lib  ARCHIVE DESTINATION lib)

Modified: branches/avidemux_2.6_branch_mean/cmake/ae_plugin.cmake
===================================================================
--- branches/avidemux_2.6_branch_mean/cmake/ae_plugin.cmake	2009-03-28 17:13:20 UTC (rev 4716)
+++ branches/avidemux_2.6_branch_mean/cmake/ae_plugin.cmake	2009-03-28 17:15:14 UTC (rev 4717)
@@ -14,4 +14,5 @@
 
 MACRO(INSTALL_AUDIOENCODER _lib)
 	INSTALL(TARGETS ${_lib} DESTINATION "${CMAKE_INSTALL_PREFIX}/lib/ADM_plugins/audioEncoders/")
+	TARGET_LINK_LIBRARIES(${_lib} ADM_core ADM_coreUI ADM_coreAudio ADM_coreAudioEncoder)
 ENDMACRO(INSTALL_AUDIOENCODER)



From mean at mail.berlios.de  Sat Mar 28 19:03:19 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sat, 28 Mar 2009 19:03:19 +0100
Subject: [Avidemux-svn-commit] r4718 -
	branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/Pictures
Message-ID: <200903281803.n2SI3Jx9020098@sheep.berlios.de>

Author: mean
Date: 2009-03-28 19:03:17 +0100 (Sat, 28 Mar 2009)
New Revision: 4718

Modified:
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/Pictures/ADM_pics.cpp
Log:
[Demuxer:pic] Add pts/dts (hardcoded/incomplete)

Modified: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/Pictures/ADM_pics.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/Pictures/ADM_pics.cpp	2009-03-28 17:15:14 UTC (rev 4717)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/Pictures/ADM_pics.cpp	2009-03-28 18:03:17 UTC (rev 4718)
@@ -98,6 +98,10 @@
 	fread(img->data, _imgSize[framenum] - _offset, 1, fd);
 	img->dataLength = _imgSize[framenum] - _offset;
 
+    uint64_t timeP=40000;
+    timeP*=framenum;
+    img->demuxerDts=timeP;
+    img->demuxerPts=timeP;
 	fclose(fd);
 
 	return 1;
@@ -475,3 +479,17 @@
 
 	return fopen(filename, "rb");
 }
+bool       picHeader::getPtsDts(uint32_t frame,uint64_t *pts,uint64_t *dts)
+{
+ uint64_t timeP=40000;
+    timeP*=frame;
+    *pts=timeP;
+    *dts=timeP;
+    return true;
+
+}
+bool       picHeader::setPtsDts(uint32_t frame,uint64_t pts,uint64_t dts)
+{
+    return false;
+}
+// EOF



From mean at mail.berlios.de  Sat Mar 28 19:09:24 2009
From: mean at mail.berlios.de (mean at BerliOS)
Date: Sat, 28 Mar 2009 19:09:24 +0100
Subject: [Avidemux-svn-commit] r4719 - in
	branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers:
	Matroska MpegPS
Message-ID: <200903281809.n2SI9ObO028746@sheep.berlios.de>

Author: mean
Date: 2009-03-28 19:09:23 +0100 (Sat, 28 Mar 2009)
New Revision: 4719

Modified:
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/Matroska/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegPS/CMakeLists.txt
Log:
[Win32] Patch3

Modified: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/Matroska/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/Matroska/CMakeLists.txt	2009-03-28 18:03:17 UTC (rev 4718)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/Matroska/CMakeLists.txt	2009-03-28 18:09:23 UTC (rev 4719)
@@ -11,7 +11,7 @@
 )
 ADD_LIBRARY(ADM_dm_matroska SHARED ${ADM_matroska_SRCS})
 
-TARGET_LINK_LIBRARIES(ADM_dm_matroska ADM_libavutil)
+TARGET_LINK_LIBRARIES(ADM_dm_matroska ADM_libavutil ADM_audioParser)
 
 INIT_DEMUXER(ADM_dm_matroska)
 INSTALL_DEMUXER(ADM_dm_matroska)

Modified: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegPS/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegPS/CMakeLists.txt	2009-03-28 18:03:17 UTC (rev 4718)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegPS/CMakeLists.txt	2009-03-28 18:09:23 UTC (rev 4719)
@@ -11,7 +11,7 @@
 )
 
 ADD_LIBRARY(ADM_dm_ps SHARED ${ADM_ps_SRCS})
-TARGET_LINK_LIBRARIES(ADM_dm_ps ADM_coreDemuxerMpeg)
+TARGET_LINK_LIBRARIES(ADM_dm_ps ADM_coreDemuxerMpeg ADM_audioParser)
 INCLUDE_DIRECTORIES("${AVIDEMUX_SOURCE_DIR}/avidemux/ADM_coreDemuxerMpeg/include")
 
 



