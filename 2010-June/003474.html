<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Avidemux-svn-commit] r6280 - in branches/avidemux_2.6_branch_mean:	avidemux/common/ADM_script2/py cmake
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/avidemux-svn-commit/2010-June/index.html" >
   <LINK REL="made" HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r6280%20-%20in%20branches/avidemux_2.6_branch_mean%3A%0A%09avidemux/common/ADM_script2/py%20cmake&In-Reply-To=%3C201006011815.o51IFBa4009833%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="003473.html">
   <LINK REL="Next"  HREF="003475.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Avidemux-svn-commit] r6280 - in branches/avidemux_2.6_branch_mean:	avidemux/common/ADM_script2/py cmake</H1>
    <B>mean at BerliOS</B> 
    <A HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r6280%20-%20in%20branches/avidemux_2.6_branch_mean%3A%0A%09avidemux/common/ADM_script2/py%20cmake&In-Reply-To=%3C201006011815.o51IFBa4009833%40sheep.berlios.de%3E"
       TITLE="[Avidemux-svn-commit] r6280 - in branches/avidemux_2.6_branch_mean:	avidemux/common/ADM_script2/py cmake">mean at mail.berlios.de
       </A><BR>
    <I>Tue Jun  1 20:15:12 CEST 2010</I>
    <P><UL>
        <LI>Previous message: <A HREF="003473.html">[Avidemux-svn-commit] r6279 -	branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/py
</A></li>
        <LI>Next message: <A HREF="003475.html">[Avidemux-svn-commit] r6281 - in branches/avidemux_2.6_branch_mean:	avidemux/common/ADM_script2/py cmake
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3474">[ date ]</a>
              <a href="thread.html#3474">[ thread ]</a>
              <a href="subject.html#3474">[ subject ]</a>
              <a href="author.html#3474">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: mean
Date: 2010-06-01 20:15:11 +0200 (Tue, 01 Jun 2010)
New Revision: 6280

Modified:
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/py/adm.admPyClass
   branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/py/adm_gen.cpp
   branches/avidemux_2.6_branch_mean/cmake/admPyClass.pl
Log:
[pyClass] Simplify

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/py/adm.admPyClass
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/py/adm.admPyClass	2010-06-01 18:15:09 UTC (rev 6279)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/py/adm.admPyClass	2010-06-01 18:15:11 UTC (rev 6280)
@@ -1,8 +1,8 @@
 #              cname:pyname
 /* CLASS */ pyAdm : void
-/* FUNC */ int scriptLoadVideo:loadVideo          (const char * ) 
+/* FUNC */ int scriptLoadVideo:loadVideo          (str ) 
 /* FUNC */ int scriptClearSegments:clearSegments  (void) 
-/* FUNC */ int scriptAppendVideo:appendVideo      (const char * ) 
+/* FUNC */ int scriptAppendVideo:appendVideo      (str ) 
 /* FUNC */ int scriptAddSegment:addSegment        (int ,float , float ) 
 /* FUNC */ int scriptSetPostProc:setPostProc      (int ,int , int ) 
 /* FUNC */ int scriptGetWidth:getWidth            (void) 
@@ -10,12 +10,12 @@
 /* FUNC */ int scriptGetFps1000:getFps1000        (void) 
 /* FUNC */ str scriptGetVideoCodec:getVideoCodec(void) 
 /* FUNC */ int scriptAudioReset:audioReset        (void) 
-/* FUNC */ int scriptAudioMixer:audioMixer        (const char * ) 
+/* FUNC */ int scriptAudioMixer:audioMixer        (str ) 
 /* FUNC */ int scriptClearVideoFilters:clearVideoFilters   (void) 
 #
 #
 #              cname:pyname
-/* FUNC */ int scriptSetVideoCodec:videoCodec(const char *,couples) 
-/* FUNC */ int scriptSetAudioCodec:audioCodec(const char *,int,couples) 
-/* FUNC */ int scriptSetContainer:setContainer(const char *,couples) 
-/* FUNC */ int scriptAddVideoFilter:addVideoFilter(const char *,couples) 
+/* FUNC */ int scriptSetVideoCodec:videoCodec(str,couples) 
+/* FUNC */ int scriptSetAudioCodec:audioCodec(str,int,couples) 
+/* FUNC */ int scriptSetContainer:setContainer(str,couples) 
+/* FUNC */ int scriptAddVideoFilter:addVideoFilter(str,couples) 

Modified: branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/py/adm_gen.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/py/adm_gen.cpp	2010-06-01 18:15:09 UTC (rev 6279)
+++ branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/py/adm_gen.cpp	2010-06-01 18:15:11 UTC (rev 6280)
@@ -1,174 +1,173 @@
 // Generated by admPyClass.pl do not edit !
-//int  scriptLoadVideo &lt;const char * &gt;
-tp_obj zzpy_loadVideo(TP)
-{
-tinyParams pm(tp);
-const char * p0=pm.asString();
-int r=scriptLoadVideo(p0); 
-return tp_number(r);
+// audioCodec -&gt; int scriptSetAudioCodec (str int couples ) 
+static tp_obj zzpy_audioCodec(TP)
+ {
+  tinyParams pm(tp);
+  const char *p0= pm.asString();
+  int p1= pm.asDouble();
+  CONFcouple *p2=NULL;
+  pm.makeCouples(&amp;p2);
+  int r=  scriptSetAudioCodec(p0,p1,p2); 
+  return tp_number(r);
 }
-//int  scriptClearSegments &lt;void&gt;
-tp_obj zzpy_clearSegments(TP)
-{
-int r=scriptClearSegments(); 
-return tp_number(r);
+// addVideoFilter -&gt; int scriptAddVideoFilter (str couples ) 
+static tp_obj zzpy_addVideoFilter(TP)
+ {
+  tinyParams pm(tp);
+  const char *p0= pm.asString();
+  CONFcouple *p1=NULL;
+  pm.makeCouples(&amp;p1);
+  int r=  scriptAddVideoFilter(p0,p1); 
+  return tp_number(r);
 }
-//int  scriptAppendVideo &lt;const char * &gt;
-tp_obj zzpy_appendVideo(TP)
-{
-tinyParams pm(tp);
-const char * p0=pm.asString();
-int r=scriptAppendVideo(p0); 
-return tp_number(r);
+// loadVideo -&gt; int scriptLoadVideo (str  ) 
+static tp_obj zzpy_loadVideo(TP)
+ {
+  tinyParams pm(tp);
+  const char *p0= pm.asString();
+  int r=  scriptLoadVideo(p0); 
+  return tp_number(r);
 }
-//int  scriptAddSegment &lt;int  float   float &gt;
-tp_obj zzpy_addSegment(TP)
-{
-tinyParams pm(tp);
-int p0=pm.asDouble();
-float p1=pm.asFloat();
-float p2=pm.asFloat();
-int r=scriptAddSegment(p0,p1,p2); 
-return tp_number(r);
+// clearSegments -&gt; int scriptClearSegments (void ) 
+static tp_obj zzpy_clearSegments(TP)
+ {
+  int r=  scriptClearSegments(); 
+  return tp_number(r);
 }
-//int  scriptSetPostProc &lt;int  int   int &gt;
-tp_obj zzpy_setPostProc(TP)
-{
-tinyParams pm(tp);
-int p0=pm.asDouble();
-int p1=pm.asDouble();
-int p2=pm.asDouble();
-int r=scriptSetPostProc(p0,p1,p2); 
-return tp_number(r);
+// getHeight -&gt; int scriptGetHeight (void ) 
+static tp_obj zzpy_getHeight(TP)
+ {
+  int r=  scriptGetHeight(); 
+  return tp_number(r);
 }
-//int  scriptGetWidth &lt;void&gt;
-tp_obj zzpy_getWidth(TP)
-{
-int r=scriptGetWidth(); 
-return tp_number(r);
+// setPostProc -&gt; int scriptSetPostProc (int  int   int  ) 
+static tp_obj zzpy_setPostProc(TP)
+ {
+  tinyParams pm(tp);
+  int p0= pm.asDouble();
+  int p1= pm.asDouble();
+  int p2= pm.asDouble();
+  int r=  scriptSetPostProc(p0,p1,p2); 
+  return tp_number(r);
 }
-//int  scriptGetHeight &lt;void&gt;
-tp_obj zzpy_getHeight(TP)
-{
-int r=scriptGetHeight(); 
-return tp_number(r);
+// appendVideo -&gt; int scriptAppendVideo (str  ) 
+static tp_obj zzpy_appendVideo(TP)
+ {
+  tinyParams pm(tp);
+  const char *p0= pm.asString();
+  int r=  scriptAppendVideo(p0); 
+  return tp_number(r);
 }
-//int  scriptGetFps1000 &lt;void&gt;
-tp_obj zzpy_getFps1000(TP)
-{
-int r=scriptGetFps1000(); 
-return tp_number(r);
+// audioMixer -&gt; int scriptAudioMixer (str  ) 
+static tp_obj zzpy_audioMixer(TP)
+ {
+  tinyParams pm(tp);
+  const char *p0= pm.asString();
+  int r=  scriptAudioMixer(p0); 
+  return tp_number(r);
 }
-//str  scriptGetVideoCodec &lt;void&gt;
-tp_obj zzpy_getVideoCodec(TP)
-{
-char *r=scriptGetVideoCodec(); 
-return tp_string(r);
+// getFps1000 -&gt; int scriptGetFps1000 (void ) 
+static tp_obj zzpy_getFps1000(TP)
+ {
+  int r=  scriptGetFps1000(); 
+  return tp_number(r);
 }
-//int  scriptAudioReset &lt;void&gt;
-tp_obj zzpy_audioReset(TP)
-{
-int r=scriptAudioReset(); 
-return tp_number(r);
+// videoCodec -&gt; int scriptSetVideoCodec (str couples ) 
+static tp_obj zzpy_videoCodec(TP)
+ {
+  tinyParams pm(tp);
+  const char *p0= pm.asString();
+  CONFcouple *p1=NULL;
+  pm.makeCouples(&amp;p1);
+  int r=  scriptSetVideoCodec(p0,p1); 
+  return tp_number(r);
 }
-//int  scriptAudioMixer &lt;const char * &gt;
-tp_obj zzpy_audioMixer(TP)
-{
-tinyParams pm(tp);
-const char * p0=pm.asString();
-int r=scriptAudioMixer(p0); 
-return tp_number(r);
+// getWidth -&gt; int scriptGetWidth (void ) 
+static tp_obj zzpy_getWidth(TP)
+ {
+  int r=  scriptGetWidth(); 
+  return tp_number(r);
 }
-//int  scriptClearVideoFilters &lt;void&gt;
-tp_obj zzpy_clearVideoFilters(TP)
-{
-int r=scriptClearVideoFilters(); 
-return tp_number(r);
+// addSegment -&gt; int scriptAddSegment (int  float   float  ) 
+static tp_obj zzpy_addSegment(TP)
+ {
+  tinyParams pm(tp);
+  int p0= pm.asDouble();
+  float p1= pm.asFloat();
+  float p2= pm.asFloat();
+  int r=  scriptAddSegment(p0,p1,p2); 
+  return tp_number(r);
 }
-//int  scriptSetVideoCodec &lt;const char * couples&gt;
-tp_obj zzpy_videoCodec(TP)
-{
-tinyParams pm(tp);
-const char * p0=pm.asString();
-CONFcouple *p1=NULL;
-pm.makeCouples(&amp;p1);
-int r=scriptSetVideoCodec(p0,p1); 
-return tp_number(r);
+// clearVideoFilters -&gt; int scriptClearVideoFilters (void ) 
+static tp_obj zzpy_clearVideoFilters(TP)
+ {
+  int r=  scriptClearVideoFilters(); 
+  return tp_number(r);
 }
-//int  scriptSetAudioCodec &lt;const char * int couples&gt;
-tp_obj zzpy_audioCodec(TP)
-{
-tinyParams pm(tp);
-const char * p0=pm.asString();
-int p1=pm.asDouble();
-CONFcouple *p2=NULL;
-pm.makeCouples(&amp;p2);
-int r=scriptSetAudioCodec(p0,p1,p2); 
-return tp_number(r);
+// setContainer -&gt; int scriptSetContainer (str couples ) 
+static tp_obj zzpy_setContainer(TP)
+ {
+  tinyParams pm(tp);
+  const char *p0= pm.asString();
+  CONFcouple *p1=NULL;
+  pm.makeCouples(&amp;p1);
+  int r=  scriptSetContainer(p0,p1); 
+  return tp_number(r);
 }
-//int  scriptSetContainer &lt;const char * couples&gt;
-tp_obj zzpy_setContainer(TP)
-{
-tinyParams pm(tp);
-const char * p0=pm.asString();
-CONFcouple *p1=NULL;
-pm.makeCouples(&amp;p1);
-int r=scriptSetContainer(p0,p1); 
-return tp_number(r);
+// audioReset -&gt; int scriptAudioReset (void ) 
+static tp_obj zzpy_audioReset(TP)
+ {
+  int r=  scriptAudioReset(); 
+  return tp_number(r);
 }
-//int  scriptAddVideoFilter &lt;const char * couples&gt;
-tp_obj zzpy_addVideoFilter(TP)
-{
-tinyParams pm(tp);
-const char * p0=pm.asString();
-CONFcouple *p1=NULL;
-pm.makeCouples(&amp;p1);
-int r=scriptAddVideoFilter(p0,p1); 
-return tp_number(r);
+// getVideoCodec -&gt; str scriptGetVideoCodec (void ) 
+static tp_obj zzpy_getVideoCodec(TP)
+ {
+  char *r=  scriptGetVideoCodec(); 
+  return tp_string(r);
 }
 static tp_obj myCtorpyAdm(tp_vm *vm)
 {
 }
-static tp_obj zzpy_pyAdm_help(tp_vm *vm)
-{
-jsLog(&quot;loadVideo&quot;);
-jsLog(&quot;clearSegments&quot;);
-jsLog(&quot;appendVideo&quot;);
-jsLog(&quot;addSegment&quot;);
-jsLog(&quot;setPostProc&quot;);
-jsLog(&quot;getWidth&quot;);
-jsLog(&quot;getHeight&quot;);
-jsLog(&quot;getFps1000&quot;);
-jsLog(&quot;getVideoCodec&quot;);
-jsLog(&quot;audioReset&quot;);
-jsLog(&quot;audioMixer&quot;);
-jsLog(&quot;clearVideoFilters&quot;);
-jsLog(&quot;videoCodec&quot;);
-jsLog(&quot;audioCodec&quot;);
-jsLog(&quot;setContainer&quot;);
-jsLog(&quot;addVideoFilter&quot;);
-return tp_None;
-}
+static tp_obj zzpy__pyAdm_help(TP)
+ {
+  jsLog(&quot;audioCodec&quot;);
+  jsLog(&quot;addVideoFilter&quot;);
+  jsLog(&quot;loadVideo&quot;);
+  jsLog(&quot;clearSegments&quot;);
+  jsLog(&quot;getHeight&quot;);
+  jsLog(&quot;setPostProc&quot;);
+  jsLog(&quot;appendVideo&quot;);
+  jsLog(&quot;audioMixer&quot;);
+  jsLog(&quot;getFps1000&quot;);
+  jsLog(&quot;videoCodec&quot;);
+  jsLog(&quot;getWidth&quot;);
+  jsLog(&quot;addSegment&quot;);
+  jsLog(&quot;clearVideoFilters&quot;);
+  jsLog(&quot;setContainer&quot;);
+  jsLog(&quot;audioReset&quot;);
+  jsLog(&quot;getVideoCodec&quot;);
+};
 tp_obj initClasspyAdm(tp_vm *vm)
 {
- tp_obj myClass=tp_class(vm);
- tp_set(vm,myClass,tp_string(&quot;__init__&quot;),tp_fnc(vm,myCtorpyAdm));
- tp_set(vm,myClass,tp_string(&quot;loadVideo&quot;),tp_fnc(vm,zzpy_loadVideo));
- tp_set(vm,myClass,tp_string(&quot;clearSegments&quot;),tp_fnc(vm,zzpy_clearSegments));
- tp_set(vm,myClass,tp_string(&quot;appendVideo&quot;),tp_fnc(vm,zzpy_appendVideo));
- tp_set(vm,myClass,tp_string(&quot;addSegment&quot;),tp_fnc(vm,zzpy_addSegment));
- tp_set(vm,myClass,tp_string(&quot;setPostProc&quot;),tp_fnc(vm,zzpy_setPostProc));
- tp_set(vm,myClass,tp_string(&quot;getWidth&quot;),tp_fnc(vm,zzpy_getWidth));
- tp_set(vm,myClass,tp_string(&quot;getHeight&quot;),tp_fnc(vm,zzpy_getHeight));
- tp_set(vm,myClass,tp_string(&quot;getFps1000&quot;),tp_fnc(vm,zzpy_getFps1000));
- tp_set(vm,myClass,tp_string(&quot;getVideoCodec&quot;),tp_fnc(vm,zzpy_getVideoCodec));
- tp_set(vm,myClass,tp_string(&quot;audioReset&quot;),tp_fnc(vm,zzpy_audioReset));
- tp_set(vm,myClass,tp_string(&quot;audioMixer&quot;),tp_fnc(vm,zzpy_audioMixer));
- tp_set(vm,myClass,tp_string(&quot;clearVideoFilters&quot;),tp_fnc(vm,zzpy_clearVideoFilters));
- tp_set(vm,myClass,tp_string(&quot;videoCodec&quot;),tp_fnc(vm,zzpy_videoCodec));
- tp_set(vm,myClass,tp_string(&quot;audioCodec&quot;),tp_fnc(vm,zzpy_audioCodec));
- tp_set(vm,myClass,tp_string(&quot;setContainer&quot;),tp_fnc(vm,zzpy_setContainer));
- tp_set(vm,myClass,tp_string(&quot;addVideoFilter&quot;),tp_fnc(vm,zzpy_addVideoFilter));
- tp_set(vm,myClass,tp_string(&quot;help&quot;),tp_fnc(vm,zzpy_pyAdm_help));
- return myClass;
+  tp_obj myClass=tp_class(vm);
+  tp_set(vm,myClass,tp_string(&quot;__init__&quot;),tp_fnc(vm,myCtorpyAdm));
+  tp_set(vm,myClass,tp_string(&quot;help&quot;),tp_fnc(vm,zzpy__pyAdm_help));
+  tp_set(vm,myClass,tp_string(&quot;audioCodec&quot;),tp_fnc(vm,zzpy_audioCodec));
+  tp_set(vm,myClass,tp_string(&quot;addVideoFilter&quot;),tp_fnc(vm,zzpy_addVideoFilter));
+  tp_set(vm,myClass,tp_string(&quot;loadVideo&quot;),tp_fnc(vm,zzpy_loadVideo));
+  tp_set(vm,myClass,tp_string(&quot;clearSegments&quot;),tp_fnc(vm,zzpy_clearSegments));
+  tp_set(vm,myClass,tp_string(&quot;getHeight&quot;),tp_fnc(vm,zzpy_getHeight));
+  tp_set(vm,myClass,tp_string(&quot;setPostProc&quot;),tp_fnc(vm,zzpy_setPostProc));
+  tp_set(vm,myClass,tp_string(&quot;appendVideo&quot;),tp_fnc(vm,zzpy_appendVideo));
+  tp_set(vm,myClass,tp_string(&quot;audioMixer&quot;),tp_fnc(vm,zzpy_audioMixer));
+  tp_set(vm,myClass,tp_string(&quot;getFps1000&quot;),tp_fnc(vm,zzpy_getFps1000));
+  tp_set(vm,myClass,tp_string(&quot;videoCodec&quot;),tp_fnc(vm,zzpy_videoCodec));
+  tp_set(vm,myClass,tp_string(&quot;getWidth&quot;),tp_fnc(vm,zzpy_getWidth));
+  tp_set(vm,myClass,tp_string(&quot;addSegment&quot;),tp_fnc(vm,zzpy_addSegment));
+  tp_set(vm,myClass,tp_string(&quot;clearVideoFilters&quot;),tp_fnc(vm,zzpy_clearVideoFilters));
+  tp_set(vm,myClass,tp_string(&quot;setContainer&quot;),tp_fnc(vm,zzpy_setContainer));
+  tp_set(vm,myClass,tp_string(&quot;audioReset&quot;),tp_fnc(vm,zzpy_audioReset));
+  tp_set(vm,myClass,tp_string(&quot;getVideoCodec&quot;),tp_fnc(vm,zzpy_getVideoCodec));
+  return myClass;
 }

Modified: branches/avidemux_2.6_branch_mean/cmake/admPyClass.pl
===================================================================
--- branches/avidemux_2.6_branch_mean/cmake/admPyClass.pl	2010-06-01 18:15:09 UTC (rev 6279)
+++ branches/avidemux_2.6_branch_mean/cmake/admPyClass.pl	2010-06-01 18:15:11 UTC (rev 6280)
@@ -5,6 +5,12 @@
 #                        str = const char *
 #                        couples =  confCouple *c
 #
+#  %funcss{funcName}
+#  %proto{funcName}
+#  %retType{funcName}
+#  %params{funcname}
+#
+#
 
 
 use strict;
@@ -14,24 +20,109 @@
 my $line;
 my $glueprefix=&quot;zzpy_&quot;;
 my $functionPrefix=&quot;&quot;;
-my @allFuncs;
 my $className;
 my $cookieName;
 my $staticClass=0;
-my $nbCouples=0;
 #
+my %cFuncs;
+my %rType;
+my %funcParams;
 #
+# processClass
 #
+sub processClass
+{
+        my $proto=shift;
+        
+        $proto=~s%.*\*/%%g;
+        $proto=~s/ //g;
+        #print &quot;**$proto**\n&quot;;
+        ($className,$cookieName)=split &quot;:&quot;,$proto; 
+        print &quot;Processing class $className (with cookie=$cookieName)\n&quot;; 
+        if($cookieName=~m/void/)
+        {
+                $staticClass=1;
+        }
+        else
+        {
+                $staticClass=0;
+        }
+
+}
+#
+# Process a function declaration and write the glue code to do tinypy&lt;-&gt;function call
+#
+sub processFunc
+{
+        my $proto=shift;
+        my $args=$proto;
+        my @params;
+        my $retType=$proto;;
+        my $pyfunc=$proto;;
+        my $cfunc;
+        $args=~s/^.*\(//g;
+        $args=~s/\).*$//g;
+        #print &quot;args =&gt; $args\n&quot;;
+        @params=split &quot;,&quot;,$args;
+        #print &quot;params -&gt; @params\n&quot;;
+        # Get return type...
+        $retType=~s/^ *//g;
+        $retType=~s/ .*$//g;
+        # get functioName
+        $pyfunc=~s/ *\(.*$//g;
+        $pyfunc=~s/^.* //g;
+        ($cfunc,$pyfunc)=split &quot;:&quot;,$pyfunc;
+        $cFuncs{$pyfunc}=$cfunc;
+        $rType{$pyfunc}=$retType;
+        push @{$funcParams{$pyfunc}}, @params ; 
+        #print &quot; $pyfunc -&gt; @params \n&quot;;
+}
+
+#
+# parsefile
+#
+sub parseFile
+{
+my $file=shift;
+open(INPUT,$file) or die(&quot;Cannot open $file&quot;);
+while($line=&lt;INPUT&gt;)
+{
+        chomp($line);
+        if($line=~m/^#/)
+        {
+        }
+        else
+        {
+            if($line=~m/\* FUNC \*/)
+            {
+                my $proto=$line;
+                # Remove header...
+                # Remove tail
+                $line=~s/^.*\*\///g;
+                $line=~s/\/\/.*$//g;
+                processFunc($line);
+
+            } elsif($line =~m/\/* CLASS \*/)
+                {
+                        processClass($line);
+                }
+        }
+}
+close(INPUT);
+}
+#
+#
+#
 sub genReturn
 {
         my $retType=shift;
         if($retType=~m/int/)
         {
-                return &quot;return tp_number(r);&quot;;
+                return &quot;  return tp_number(r);&quot;;
         }
         if($retType=~m/float/)
         {
-                return &quot;return tp_number(r);&quot;;
+                return &quot;  return tp_number(r);&quot;;
         }
         if($retType=~m/void/)
         {
@@ -39,7 +130,7 @@
         }
          if($retType=~m/str/)
         {
-                return &quot;return tp_string(r);&quot;;
+                return &quot;  return tp_string(r);&quot;;
         }
 return &quot;???? $retType&quot;;
 }
@@ -49,7 +140,7 @@
 sub castFrom
 {
         my $type=shift;
-        if($type=~m/^const char/)
+        if($type=~m/^str/)
         {
                 return &quot;pm.asString()&quot;;
         }
@@ -73,124 +164,139 @@
         my $num=shift;
         my $type=shift;
         my $r=1;
+        $type=~s/ *$//g;
+        $type=~s/^ *//g;
         if($type=~m/couples/)
         {
-                print OUTPUT &quot;CONFcouple *p&quot;.$num.&quot;=NULL;\n&quot;;
-                print OUTPUT &quot;pm.makeCouples(&amp;p&quot;.$num.&quot;);\n&quot;;
+                print OUTPUT &quot;  CONFcouple *p&quot;.$num.&quot;=NULL;\n&quot;;
+                print OUTPUT &quot;  pm.makeCouples(&amp;p&quot;.$num.&quot;);\n&quot;;
                 $r=0;
         }else
         {
-                print OUTPUT &quot;$type p&quot;.$num.&quot;=&quot;;
-                print OUTPUT castFrom($type);
+                if($type=~m/str/)
+                {
+                        print OUTPUT &quot;  const char *p&quot;.$num.&quot;=&quot;;
+                }else
+                {
+                        print OUTPUT &quot;  $type p&quot;.$num.&quot;=&quot;;
+                }
+                print OUTPUT &quot; &quot;.castFrom($type);
                 print OUTPUT &quot;;\n&quot;; 
         } 
         return $r;
 }
-sub processClass
+#
+# Gen glue
+#
+sub genGlue
 {
-        my $proto=shift;
-        
-        $proto=~s%.*\*/%%g;
-        $proto=~s/ //g;
-        #print &quot;**$proto**\n&quot;;
-        ($className,$cookieName)=split &quot;:&quot;,$proto; 
-        print &quot;Processing class $className (with cookie=$cookieName)\n&quot;; 
-        if($cookieName=~m/void/)
+        my $i; 
+        my $f;
+        foreach $f(  keys %cFuncs)
         {
-                $staticClass=1;
+                my @params=@{$funcParams{$f}};
+                my $pyFunc=$f;
+                my $cfunc=$cFuncs{$f};
+                my $ret=$rType{$f};
+                my $nb=scalar(@params);
+                
+                print &quot;Generating $pyFunc -&gt; $ret $cfunc (@params ) \n&quot;;
+                print OUTPUT &quot;// $pyFunc -&gt; $ret $cfunc (@params ) \n&quot;;
+                # start our function
+                print OUTPUT &quot;static tp_obj &quot;.$glueprefix.$f.&quot;(TP)\n {\n&quot;;
+
+
+                if($params[0]=~m/^void$/)
+                {
+                        $nb=0;
+                }
+                # unmarshall params...
+                if($nb)
+                {
+                         print OUTPUT &quot;  tinyParams pm(tp);\n&quot;;
+                         for($i=0;$i&lt;$nb;$i++)
+                         {
+                                 genParam($i,$params[$i]);
+                         }
+                }
+                # call function
+                if(!($ret=~m/^void$/))
+                {
+                        if($ret=~m/str/)
+                        {
+                                print OUTPUT &quot;  char *r=&quot;;
+                        }else
+                        {
+                                print OUTPUT &quot;  &quot;.$ret.&quot; r=&quot;;
+                        }
+                }
+                print OUTPUT &quot;  &quot;.$functionPrefix.$cfunc.&quot;(&quot;;
+                for($i=0;$i&lt;$nb;$i++)
+                {
+                        if($i)
+                        {
+                                print OUTPUT &quot;,&quot;;
+                        }
+                        print OUTPUT &quot;p&quot;.$i;
+                } 
+                print OUTPUT &quot;); \n&quot;;
+                # return value (if any)
+                print OUTPUT genReturn($ret);
+                print OUTPUT &quot;\n}\n&quot;;
+
         }
-        else
-        {
-                $staticClass=0;
-        }
 
 }
 #
-# Process a function declaration and write the glue code to do tinypy&lt;-&gt;function call
 #
-sub processFunc
+#
+sub genTables
 {
-        my $proto=shift;
-        my $args=$proto;
-        my @params;
-        my $retType=$proto;;
-        my $func=$proto;;
-        my $cfunc;
-        $args=~s/^.*\(//g;
-        $args=~s/\).*$//g;
-        #print &quot;args =&gt; $args\n&quot;;
-        @params=split &quot;,&quot;,$args;
-        #print &quot;params -&gt; @params\n&quot;;
-        # Get return type...
-        $retType=~s/^ *//g;
-        $retType=~s/ .*$//g;
-        # get functioName
-        $func=~s/ *\(.*$//g;
-        $func=~s/^.* //g;
-        ($cfunc,$func)=split &quot;:&quot;,$func;
-        print OUTPUT &quot;//$retType  $cfunc &lt;@params&gt;\n&quot;;
-        # Write glue code
-        print OUTPUT &quot;tp_obj &quot;.$glueprefix.$func.&quot;(TP)\n&quot;;
-        push(@allFuncs,$func);
+        # ctor
+        print OUTPUT &quot;static tp_obj myCtor&quot;.$className.&quot;(tp_vm *vm)\n&quot;;
         print OUTPUT &quot;{\n&quot;;
-        my $nb=scalar(@params);
-        my $i;
-
-
-        for($i=0;$i&lt;$nb;$i++)
+        if($staticClass==0)
         {
-                $params[$i]=~s/^ *//g; # Remove &quot; &quot; at the beginning if any
-                $params[$i]=~s/ *$//g; # Remove &quot; &quot; at the end if any
+                #todo allocate cookie
         }
-        if($params[0]=~m/^void$/)
-        {
-                $nb=0;
-        }
-        print &quot; New function : $retType,$func,&lt;@params&gt;\n&quot;;
-        print HEADER &quot;$retType  $functionPrefix&quot;.$func.&quot; ($args);\n&quot;;
+        print OUTPUT &quot;}\n&quot;;
+        # end
+#
+#  Generate help table
+#
+my $helpName=$glueprefix.&quot;_&quot;.$className.&quot;_help&quot;;
+my $f;
+my $cfunk;
+my $pyFunc;
+                print OUTPUT &quot;static tp_obj &quot;.$helpName.&quot;(TP)\n {\n&quot;;
+                foreach $f(  keys %cFuncs)
+                {
+                        print OUTPUT &quot;  jsLog(\&quot;$f\&quot;);\n&quot;;
+                }
+                print OUTPUT &quot;};\n&quot;;
+#
+#  Create the init function that will register our class
+#
+        print OUTPUT &quot;tp_obj initClass&quot;.$className.&quot;(tp_vm *vm)\n&quot;;
+        print OUTPUT &quot;{\n&quot;;
+        print OUTPUT &quot;  tp_obj myClass=tp_class(vm);\n&quot;;
+        print OUTPUT &quot;  tp_set(vm,myClass,tp_string(\&quot;__init__\&quot;),tp_fnc(vm,myCtor&quot;.$className.&quot;));\n&quot;;
+        print OUTPUT &quot;  tp_set(vm,myClass,tp_string(\&quot;help\&quot;),tp_fnc(vm,$helpName));\n&quot;;
         #
-        if($nb)
+        foreach $f(  keys %cFuncs)
         {
-                print OUTPUT &quot;tinyParams pm(tp);\n&quot;;
-                #print OUTPUT &quot;if(pm.getNbParams()!=$nb) pm.raise(\&quot;&quot;.$func.&quot;Bad number of parameters, wanted &quot;.$nb.&quot; and got %d\&quot;,pm.getNbParams());\n&quot;;
-        }
+                my $pyFunc=$f;
+                $cfunk=$glueprefix.$f;
 
-        for($i=0;$i&lt;$nb;$i++)
-        {
-                if(!genParam($i,$params[$i]))  # all params consumed
-                {
-                        #$i=$nb;
-                }
+                print OUTPUT &quot;  tp_set(vm,myClass,tp_string(\&quot;$pyFunc\&quot;),tp_fnc(vm,$cfunk));\n&quot;;
         }
-        # Call real function
-        if(!($retType=~m/^void$/))
-        {
-                if($retType=~m/str/)
-                {
-                print OUTPUT &quot;char *r=&quot;;
-                }else
-                {
-                print OUTPUT $retType.&quot; r=&quot;;
-                }
-        }
-        print OUTPUT $functionPrefix.$cfunc.&quot;(&quot;;
-        for($i=0;$i&lt;$nb;$i++)
-        {
-                if($i)
-                {
-                        print OUTPUT &quot;,&quot;;
-                }
-                print OUTPUT &quot;p&quot;.$i;
-        } 
-        print OUTPUT &quot;); \n&quot;;
-        # Cast r to pyobj
-        print OUTPUT genReturn($retType);
-        print OUTPUT &quot;\n}\n&quot;;
-
-
+        print OUTPUT &quot;  return myClass;\n&quot;;
+        print OUTPUT &quot;}\n&quot;;
 }
 
-
+##################################
+#  Main
+##################################
 if(scalar(@ARGV)!=1)
 {
         die(&quot;admPy inputfile\n&quot;);
@@ -202,77 +308,21 @@
 $thisfile=~s/^.*\///g;
 $headerFile=$output.&quot;_gen.h&quot;;
 $output=$output.&quot;_gen.cpp&quot;;
-print &quot;Processing $input=&gt;$output\n&quot;;
-open(OUTPUT,&quot;&gt;$output&quot;) or die(&quot;Cannot open $output&quot;);
-print OUTPUT &quot;// Generated by admPyClass.pl do not edit !\n&quot;;
 ##
 ## Main Loop
 ##
 # 1 grab all functions
-open(INPUT,$input) or die(&quot;Cannot open $input&quot;);
-close(INPUT);
-# Process them
-open(INPUT,$input) or die(&quot;Cannot open $input&quot;);
-open(HEADER,&quot;&gt;$headerFile&quot;) or die(&quot;Cannot open $headerFile&quot;);
-while($line=&lt;INPUT&gt;)
-{
-        chomp($line);
-        if($line=~m/^#/)
-        {
-        }
-        else
-        {
-            if($line=~m/\* FUNC \*/)
-            {
-                my $proto=$line;
-                # Remove header...
-                # Remove tail
-                $line=~s/^.*\*\///g;
-                $line=~s/\/\/.*$//g;
-                processFunc($line);
+parseFile($input);
+# 2 gen glue
+open(OUTPUT,&quot;&gt;$output&quot;) or die(&quot;Cannot open $output&quot;);
+print OUTPUT &quot;// Generated by admPyClass.pl do not edit !\n&quot;;
+genGlue();
+#
+# 3 gen tables (ctor, help, register)
+#
+genTables();
+close(OUTPUT);
 
-            } elsif($line =~m/\/* CLASS \*/)
-                {
-                        processClass($line);
-                }
-        }
-}
-# gen class array
-
-
-# gen class xctor
-        print OUTPUT &quot;static tp_obj myCtor&quot;.$className.&quot;(tp_vm *vm)\n&quot;;
-        print OUTPUT &quot;{\n&quot;;
-        if($staticClass==0)
-        {
-                #todo allocate cookie
-        }
-        print OUTPUT &quot;}\n&quot;;
-  
+      
 #
-my $nbFunc=scalar(@allFuncs);
-my $i;
-        print OUTPUT &quot;tp_obj initClass&quot;.$className.&quot;(tp_vm *vm)\n&quot;;
-        print OUTPUT &quot;{\n&quot;;
-        print OUTPUT &quot; tp_obj myClass=tp_class(vm);\n&quot;;
-        print OUTPUT &quot; tp_set(vm,myClass,tp_string(\&quot;__init__\&quot;),tp_fnc(vm,myCtor&quot;.$className.&quot;));\n&quot;;
-        for($i=0;$i&lt;$nbFunc;$i++)
-        {
-                my $line=$allFuncs[$i];
-                #print &quot;Function : $line\n&quot;;
-                my $funcName;
-                my $funcProto;
-                $funcName=&quot;\&quot;&quot;.$line.&quot;\&quot;&quot;;
-                $funcProto=$glueprefix.$line;
-
-                print OUTPUT &quot; tp_set(vm,myClass,tp_string($funcName),tp_fnc(vm,$funcProto));\n&quot;;
-        }
-        print OUTPUT &quot; return myClass;\n&quot;;
-        print OUTPUT &quot;}\n&quot;;
-        #print OUTPUT &quot;{$funcName,$funcProto},\n&quot;;
-
-
-close(INPUT);
-close(OUTPUT);
-close(HEADER);
 print &quot;done\n.&quot;;


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="003473.html">[Avidemux-svn-commit] r6279 -	branches/avidemux_2.6_branch_mean/avidemux/common/ADM_script2/py
</A></li>
	<LI>Next message: <A HREF="003475.html">[Avidemux-svn-commit] r6281 - in branches/avidemux_2.6_branch_mean:	avidemux/common/ADM_script2/py cmake
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#3474">[ date ]</a>
              <a href="thread.html#3474">[ thread ]</a>
              <a href="subject.html#3474">[ subject ]</a>
              <a href="author.html#3474">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">More information about the Avidemux-svn-commit
mailing list</a><br>
</body></html>
