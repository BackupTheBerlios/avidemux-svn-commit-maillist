<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Avidemux-svn-commit] r4632 - in branches/avidemux_2.6_branch_mean:	avidemux avidemux/ADM_coreDemuxerMpeg/include	avidemux/ADM_coreDemuxerMpeg/src plugins/ADM_demuxers/MpegPS
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/avidemux-svn-commit/2009-February/index.html" >
   <LINK REL="made" HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r4632%20-%20in%20branches/avidemux_2.6_branch_mean%3A%0A%09avidemux%20avidemux/ADM_coreDemuxerMpeg/include%0A%09avidemux/ADM_coreDemuxerMpeg/src%20plugins/ADM_demuxers/MpegPS&In-Reply-To=%3C200902241909.n1OJ9ApO000439%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001861.html">
   <LINK REL="Next"  HREF="001863.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Avidemux-svn-commit] r4632 - in branches/avidemux_2.6_branch_mean:	avidemux avidemux/ADM_coreDemuxerMpeg/include	avidemux/ADM_coreDemuxerMpeg/src plugins/ADM_demuxers/MpegPS</H1>
    <B>mean at BerliOS</B> 
    <A HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r4632%20-%20in%20branches/avidemux_2.6_branch_mean%3A%0A%09avidemux%20avidemux/ADM_coreDemuxerMpeg/include%0A%09avidemux/ADM_coreDemuxerMpeg/src%20plugins/ADM_demuxers/MpegPS&In-Reply-To=%3C200902241909.n1OJ9ApO000439%40sheep.berlios.de%3E"
       TITLE="[Avidemux-svn-commit] r4632 - in branches/avidemux_2.6_branch_mean:	avidemux avidemux/ADM_coreDemuxerMpeg/include	avidemux/ADM_coreDemuxerMpeg/src plugins/ADM_demuxers/MpegPS">mean at mail.berlios.de
       </A><BR>
    <I>Tue Feb 24 20:09:10 CET 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="001861.html">[Avidemux-svn-commit] r4631 -	branches/avidemux_2.6_branch_mean/avidemux/ADM_editor
</A></li>
        <LI>Next message: <A HREF="001863.html">[Avidemux-svn-commit] r4633 - in	branches/avidemux_2.5_branch_gruntster/avidemux: .	ADM_userInterfaces/ADM_render
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1862">[ date ]</a>
              <a href="thread.html#1862">[ thread ]</a>
              <a href="subject.html#1862">[ subject ]</a>
              <a href="author.html#1862">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: mean
Date: 2009-02-24 20:09:10 +0100 (Tue, 24 Feb 2009)
New Revision: 4632

Added:
   branches/avidemux_2.6_branch_mean/avidemux/gui_save.cpp
Modified:
   branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxerMpeg/include/dmxPSPacket.h
   branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxerMpeg/include/dmxPacket.h
   branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxerMpeg/src/dmxPSPacket.cpp
   branches/avidemux_2.6_branch_mean/avidemux/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/avidemux/gtk_gui.cpp
   branches/avidemux_2.6_branch_mean/avidemux/gui_action.names
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegPS/ADM_ps.cpp
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegPS/ADM_psAudio.cpp
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegPS/ADM_psAudioProbe.cpp
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegPS/ADM_psIndex.cpp
Log:
[Main] Move save oriented stuff in their own file, need cleanup

Modified: branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxerMpeg/include/dmxPSPacket.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxerMpeg/include/dmxPSPacket.h	2009-02-24 19:09:05 UTC (rev 4631)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxerMpeg/include/dmxPSPacket.h	2009-02-24 19:09:10 UTC (rev 4632)
@@ -21,7 +21,7 @@
 public:
                         psPacket(void);
     virtual            ~psPacket();
-    virtual bool        open(const char *filenames,bool dontappend);
+    virtual bool        open(const char *filenames,FP_TYPE append);
     virtual bool        close(void);
     virtual bool        getPacket(uint32_t maxSize, uint8_t *pid, uint32_t *packetSize,uint64_t *pts,uint64_t *dts,uint8_t *buffer,uint64_t *startAt);
     virtual uint64_t    getPos(void);

Modified: branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxerMpeg/include/dmxPacket.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxerMpeg/include/dmxPacket.h	2009-02-24 19:09:05 UTC (rev 4631)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxerMpeg/include/dmxPacket.h	2009-02-24 19:09:10 UTC (rev 4632)
@@ -37,7 +37,7 @@
 public:
                         ADMMpegPacket(void);
     virtual             ~ADMMpegPacket();
-    virtual bool        open(const char *filenames,bool dontappend)=0;
+    virtual bool        open(const char *filenames,FP_TYPE append)=0;
     virtual bool        close(void)=0;
     virtual bool        getPacket(uint32_t maxSize, uint8_t *pid, uint32_t *packetSize,uint64_t *pts,uint64_t *dts,uint8_t *buffer,uint64_t *startAt)=0;
     virtual bool        getPacketOfType(uint8_t pid,uint32_t maxSize, uint32_t *packetSize,uint64_t *pts,uint64_t *dts,uint8_t *buffer,uint64_t *startAt);

Modified: branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxerMpeg/src/dmxPSPacket.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxerMpeg/src/dmxPSPacket.cpp	2009-02-24 19:09:05 UTC (rev 4631)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxerMpeg/src/dmxPSPacket.cpp	2009-02-24 19:09:10 UTC (rev 4632)
@@ -39,12 +39,10 @@
     \fn open
     \brief dtor
 */
-bool psPacket::open(const char *filenames,bool dontappend)
+bool psPacket::open(const char *filenames,FP_TYPE append)
 {
-FP_TYPE opentype=FP_APPEND;
-    if(dontappend) opentype=FP_DONT_APPEND;
     _file=new fileParser();
-    if(!_file-&gt;open(filenames,&amp;opentype))
+    if(!_file-&gt;open(filenames,&amp;append))
     {
         printf(&quot;[DmxPS] cannot open %s\n&quot;,filenames);
         delete _file;

Modified: branches/avidemux_2.6_branch_mean/avidemux/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/CMakeLists.txt	2009-02-24 19:09:05 UTC (rev 4631)
+++ branches/avidemux_2.6_branch_mean/avidemux/CMakeLists.txt	2009-02-24 19:09:10 UTC (rev 4632)
@@ -138,6 +138,7 @@
 GUI_jobs.cpp  
 gui_navigate.cpp  
 guiplay.cpp  
+gui_save.cpp  
 gui_savenew.cpp  
 main.cpp  
 gui_action.cpp

Modified: branches/avidemux_2.6_branch_mean/avidemux/gtk_gui.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/gtk_gui.cpp	2009-02-24 19:09:05 UTC (rev 4631)
+++ branches/avidemux_2.6_branch_mean/avidemux/gtk_gui.cpp	2009-02-24 19:09:10 UTC (rev 4632)
@@ -165,7 +165,9 @@
 extern void DIA_glyphEdit(void);
 extern uint8_t DIA_pluginsInfo(void);
 extern bool ADM_mux_configure(int index);
+//
 void HandleAction_Navigate(Action action);
+void HandleAction_Save(Action action);
 //___________________________________________
 // serialization of user event through gui
 //
@@ -389,6 +391,11 @@
   {
     HandleAction_Navigate(action);
   }
+  else if(action&gt;ACT_SAVE_BEGIN &amp;&amp; action &lt; ACT_SAVE_END)
+  {
+    HandleAction_Save(action);
+  }
+
   else switch (action)
     {
        case ACT_JOG:
@@ -430,39 +437,11 @@
 //				DIA_Calculator(&amp;a,&amp;b );
 			}
     			break;
-    case ACT_SaveUnpackedMpeg4:
-      if(GUI_Question(QT_TR_NOOP(&quot;This is to be used to undo packed VOP on MPEG-4.\nContinue ?&quot;)))
-			{
-                          GUI_FileSelWrite (QT_TR_NOOP(&quot;Select AVI File to Write&quot;), (SELFILE_CB *)A_SaveUnpackedVop);
 
-			}
-    			break;
-
-    case ACT_SaveOGM:
-//                        GUI_FileSelWrite (QT_TR_NOOP(&quot;Select OGM File to Write&quot;), (SELFILE_CB *)ogmSave);
-    			break;
-
-    case ACT_SaveWork:
-      GUI_FileSelWrite (QT_TR_NOOP(&quot;Select Workbench to Save&quot;), A_saveWorkbench);
-	  UI_refreshCustomMenu();
-      break;
     case ACT_ADD_JOB:
         A_addJob();
         break;
-    case ACT_SaveCurrentWork:
-      if( actual_workbench_file ){
-        char *tmp = ADM_strdup(actual_workbench_file);
-         A_saveWorkbench( tmp ); // will write &quot;actual_workbench_file&quot; itself
-         ADM_dealloc(tmp);
-      }else{
-        GUI_FileSelWrite (QT_TR_NOOP(&quot;Select Workbench to Save&quot;), A_saveWorkbench);
-		UI_refreshCustomMenu();
-      }
-      break;
-      
-    case ACT_SaveRaw:
-      GUI_FileSelWrite (QT_TR_NOOP(&quot;Select Raw File to Save&quot;), (SELFILE_CB *)ADM_saveRaw);
-      break;
+ 
     case ACT_CutWizard:
       ADM_cutWizard ();
       break;
@@ -479,14 +458,7 @@
     case ACT_AppendAvi:
       GUI_FileSelRead (QT_TR_NOOP(&quot;Select AVI File to Append...&quot;),(SELFILE_CB *) A_appendAvi);
       break;
-    case ACT_SaveWave:
-      	{
-          GUI_FileSelWrite (QT_TR_NOOP(&quot;Select File to Save Audio&quot;),(SELFILE_CB *)A_audioSave);
 
-	}
-      break;
-
-
     case ACT_AviInfo:
       DIA_properties ();
       break;
@@ -501,22 +473,7 @@
       GUI_PlayAvi ();
       break;
 
-    case ACT_SaveDualAudio:
-      //GUI_FileSelWrite (&quot;Select AVI to save &quot;,
-      A_SaveAudioDualAudio(NULL);
-      break;
 
-    case ACT_SaveBunchJPG:
-      GUI_FileSelWrite (QT_TR_NOOP(&quot;Select JPEG Sequence to Save&quot;), A_saveBunchJpg);
-    	break;
-    case ACT_SaveImg:
-      GUI_FileSelWrite (QT_TR_NOOP(&quot;Select BMP to Save&quot;), A_saveImg);
-      //GUI_FileSelWrite (&quot;Select Jpg to save &quot;, A_saveJpg);
-      break;
-    case ACT_SaveJPG :
-      GUI_FileSelWrite (QT_TR_NOOP(&quot;Select JPEG to Save&quot;), (SELFILE_CB *)A_saveJpg);
-      	//GUI_FileSelWrite (&quot;Select Jpg to save &quot;, A_saveJpg);
-      	break;
 
   
 #define TOGGLE_PREVIEW ADM_PREVIEW_OUTPUT
@@ -591,11 +548,6 @@
       UI_setMarkers (frameStart, frameEnd);
       break;
   
-//----------------------test-----------------------
-    case ACT_SaveAvi:
-      GUI_FileSelWrite (QT_TR_NOOP(&quot;Select File to Save&quot;),(SELFILE_CB *)A_SaveWrapper); // A_SaveAudioNVideo);
-      break;
-//---------------------------------------------------
     case ACT_Copy:
       		if( frameEnd &lt; frameStart ){
                   GUI_Error_HIG(QT_TR_NOOP(&quot;Marker A &gt; B&quot;), QT_TR_NOOP(&quot;Cannot copy.&quot;));
@@ -1046,89 +998,10 @@
 
 }
 
-//_____________________________________________________________
-//    Save current stream (generally avi...)
-//     in raw mode
-//_____________________________________________________________
-void
-A_saveAudio (char *name)
-{
 
-// debug audio seek
-  uint32_t len2;
-  uint32_t written, max;
-  uint64_t dts;
-  DIA_workingBase *work;
-  FILE *out;
 
-#define ONE_STRIKE (64*1024)
-  uint8_t *buffer=NULL;
 
-  if (!currentaudiostream)
-    return;
 
-
-
-  out = fopen (name, &quot;wb&quot;);
-  if (!out) return;
-
-  work=createWorking(QT_TR_NOOP(&quot;Saving audio&quot;));
-
-  uint32_t timeEnd,timeStart,sample,hold,len;
-  uint64_t tgt_sample,cur_sample;
-  double   duration;
-
-  // compute start position and duration in samples
-
-   timeStart=video_body-&gt;getTime (frameStart);
-   timeEnd=video_body-&gt;getTime (frameEnd+1);
-
-   currentaudiostream-&gt;goToTime (timeStart);
-   duration=timeEnd-timeStart;
-   printf(&quot;Duration:%f ms\n&quot;,duration);
-   if(duration&lt;0) duration=-duration;
-
-   duration/=1000;
-   duration*=currentaudiostream-&gt;getInfo()-&gt;frequency;
-
-   tgt_sample=(uint64_t)floor(duration);
-
-   cur_sample=0;
-   written = 0;
-   hold=0;
-   buffer=new uint8_t[ONE_STRIKE*2];
-   while (1)
-    {
-    	if(!currentaudiostream-&gt;getPacket(buffer+hold,&amp;len,64*1024,&amp;sample,&amp;dts)) break;
-	hold+=len;
-	written+=len;
-	cur_sample+=sample;
-	if(hold&gt;ONE_STRIKE)
-	{
-		fwrite(buffer,hold,1,out);
-		hold=0;
-	}
-	if(cur_sample&gt;tgt_sample)
-		break;
-      work-&gt;update(cur_sample&gt;&gt;10, tgt_sample&gt;&gt;10);
-      if(!work-&gt;isAlive()) break;
-    };
-  if(hold)
-  {
-  	fwrite(buffer,hold,1,out);
-	hold=0;
-  }
-
-  fclose (out);
-  delete work;
-  delete[] buffer;
-  printf (&quot;\n wanted %&quot;LLU&quot; samples, goto %&quot;LLU&quot; samples, written %&quot;LU&quot; bytes\n&quot;, tgt_sample,cur_sample, written);
-
-
-}
-
-
-
 //____________________________________________________________
 //
 //      Play AVI  + Audio if possible
@@ -1139,104 +1012,6 @@
 
 }
 
-#ifndef TEST_MP2
-/**________________________________________________________
- Save a Jpg image from current display buffer
-________________________________________________________*/
-int A_saveJpg (char *name)
-{
-  uint8_t fl;
-    ADMImage image(avifileinfo-&gt;width, avifileinfo-&gt;height);
-    if(!GUI_getFrameContent(&amp;image, curframe))
-    {
-      GUI_Error_HIG(QT_TR_NOOP(&quot;Get Frame&quot;),QT_TR_NOOP(&quot;Cannot get this frame to save&quot;));
-      return 0;
-    }
-    return (int) image.saveAsJpg (name);
-}
-#else
-/**
-      \fn A_saveJpg
-      \brief Save current image as jpeg 95% qual
-
-*/
-int A_saveJpg (char *name)
-{
-static int b=1;
-         video_body-&gt;changeAudioStream(0,b);
-        b^=1;
-        return 1;
-
-}
-#endif
-
-
-/**
-      \fn A_saveBunchJpg
-      \brief Save the selection  as a bunch of jpeg 95% qual
-
-*/
-void A_saveBunchJpg(const char *name)
-{
-  ADMImage *src=NULL;
-  uint32_t curImg;
-  char	 fullName[2048],*ext;
-  char *baseName;
-  DIA_workingBase *working;
-  uint8_t success=0;
-
-        if(frameStart&gt;frameEnd)
-                {
-                  GUI_Error_HIG(QT_TR_NOOP(&quot;Mark A &gt; B&quot;), QT_TR_NOOP(&quot;Set your markers correctly.&quot;));
-                        return;
-                }
-        // Split name into base + extension
-        ADM_PathSplit(name,&amp;baseName,&amp;ext);
-
-        src=new ADMImage(avifileinfo-&gt;width,avifileinfo-&gt;height);
-        ADM_assert(src);
-
-        working=createWorking(QT_TR_NOOP(&quot;Saving as set of jpegs&quot;));
-        for(curImg=frameStart;curImg&lt;=frameEnd;curImg++)
-        {
-                working-&gt;update(curImg-frameStart,frameEnd-frameStart);
-                if (!GUI_getFrameContent (src,curImg ))
-                {
-                  GUI_Error_HIG(QT_TR_NOOP(&quot;Cannot decode frame&quot;), QT_TR_NOOP(&quot;Aborting.&quot;));
-                        goto _bunch_abort;
-                }
-                if(!working-&gt;isAlive()) goto _bunch_abort;
-                sprintf(fullName,&quot;%s%04d.jpg&quot;,baseName,curImg-frameStart);
-                if(!src-&gt;saveAsJpg(fullName)) goto _bunch_abort;
-        }
-        success=1;
-
-_bunch_abort:
-        if(success)
-            GUI_Info_HIG(ADM_LOG_INFO,QT_TR_NOOP(&quot;Done&quot;),QT_TR_NOOP( &quot;Saved %d images.&quot;), curImg-frameStart);
-        else
-            GUI_Error_HIG(QT_TR_NOOP(&quot;Error&quot;),QT_TR_NOOP( &quot;Could not save all images.&quot;));
-        delete working	;
-        delete src;
-        return ;
-
-
-}
-/**
-      \fn A_saveImg
-      \brief Save current displayed image as a BMP file
-*/
-void A_saveImg (const char *name)
-{
-
-  ADMImage image(avifileinfo-&gt;width,avifileinfo-&gt;height);
-  GUI_getFrameContent(&amp;image, video_body-&gt;getCurrentFrame());
-  if(image.saveAsBmp(name))
-        GUI_Info_HIG (ADM_LOG_INFO,QT_TR_NOOP(&quot;Done&quot;),QT_TR_NOOP( &quot;Saved \&quot;%s\&quot;.&quot;), ADM_GetFileName(name));
-  else
-        GUI_Error_HIG (QT_TR_NOOP(&quot;BMP op failed&quot;),QT_TR_NOOP( &quot;Saving %s as a BMP file failed.&quot;), ADM_GetFileName(name));
-}
-
 //_____________________________________________________________
 //
 //              Load AC3
@@ -1307,139 +1082,10 @@
   return 1;
 }
 
-//_____________________________________________________________
-//    Save current stream (generally avi...)
-//     in decoded mode (assuming MP3)
-//_____________________________________________________________
-void
-A_saveAudioDecodedTest (char *name)
-{
-#if 0
-// debug audio seek
-  uint32_t len, gauge = 0;
-  uint32_t written = 0;
-  FILE *out;
-  AVDMGenericAudioStream *saveFilter;
 
-  uint64_t sampleTarget,sampleCurrent;
 
-#undef BITT
-#define BITT 4*1152
-#define OUTCHUNK 1024*1024
-  uint8_t *outbuffer;
 
-  if (!currentaudiostream)
-    return;
 
-
-  if (!(out = fopen (name, &quot;wb&quot;)))
-    {
-      GUI_Error_HIG (QT_TR_NOOP(&quot;File error&quot;), QT_TR_NOOP(&quot;Cannot open \&quot;%s\&quot; for writing.&quot;), name);
-      return;
-    }
-
-  outbuffer = (uint8_t *) ADM_alloc (2 * OUTCHUNK);	// 1Meg cache;
-  if (!outbuffer)
-    {
-      GUI_Error_HIG (QT_TR_NOOP(&quot;Memory Error&quot;), NULL);
-      return;
-    }
-
-
-
-// re-ignite first filter...
-
-
-
-
-  // Write Wav header
-
-  /* Sat Nov 09 06:11:52 CET 2002 Fixes from Maik Broemme &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">mbroemme at plusserver.de</A>&gt; */
-  /* If you set negative delay and save the audio stream, the saved stream was shorter than the video stream. */
-
-  /* Example: video stream is 10 minutes long, audio stream perhaps 20 minutes, you need the audio stream from */
-  /*          minute 1 until 11, so you setup an audio delay from -60 seconds, but this 60 seconds were removed */
-  /*          from begin and end of the audio stream. That was not good :) Now it runs correctly also if you use */
-  /*          audio stream with same length then video, therefore is premature ending :) */
-
-
-
-//        saveFilter =  buildAudioFilter (currentaudiostream,video_body-&gt;getTime (frameStart));
-
-		if (saveFilter == NULL)
-		{
-			fclose(out);
-			ADM_dealloc(outbuffer);
-			return;
-		}
-
-    	DIA_working *work=new DIA_working(QT_TR_NOOP(&quot;Saving audio&quot;));
-
-
-//
-//  Create First filter that is null filter
-//
-  saveFilter-&gt;writeHeader (out);
-  uint32_t tstart,tend,samples;
-  double duration;
-  tstart=video_body-&gt;getTime(frameStart);
-  tend=video_body-&gt;getTime(frameEnd+1);
-  duration=(tend-tstart);
-  duration*=saveFilter-&gt;getInfo()-&gt;frequency;
-  duration/=1000.;
-
-  sampleTarget=(uint64_t)floor(duration);
-  sampleCurrent=0;
-  gauge=0;
-
-  if( frameStart == frameEnd ){
-     /* JSC: we will write some bytes, but nobody should expect useful data */
-    GUI_Error_HIG(QT_TR_NOOP(&quot;No frames to encode&quot;),QT_TR_NOOP(&quot;Please check markers. Is \&quot;A&gt;\&quot; == \&quot;&gt;B\&quot;?&quot;));
-  }
-
-  while ((sampleCurrent&lt;sampleTarget))
-    {
-      if(!saveFilter-&gt;getPacket(outbuffer + gauge,&amp;len,&amp;samples))
-      {
-        printf(&quot;Audio save:Read error\n&quot;);
-      	break;
-      }
-      //      printf(&quot;Got : %lu\n&quot;,len2);
-      gauge += len;
-      sampleCurrent+=samples;
-      // update GUI
-	// JSC: if &quot;A&gt;&quot; == &quot;&gt;B&quot; we will get &gt;100% here =&gt; assert in work-&gt;update()
-	if (work-&gt;update ((sampleCurrent&gt;&gt;10 &gt; sampleTarget&gt;&gt;10 ? sampleTarget&gt;&gt;10 : sampleCurrent&gt;&gt;10), sampleTarget&gt;&gt;10))	// abort request ?
-	    break;;
-      if (gauge &gt; OUTCHUNK)	// either out buffer is full
-	{
-	  fwrite (outbuffer, 1, gauge, out);
-	  written += gauge;
-	  gauge = 0;
-	}
-    };
-// Clean up
-	if(gauge)
-	{
-		fwrite (outbuffer,  gauge,1, out);
-		written += gauge;
-		gauge = 0;
-	}
-  saveFilter-&gt;endWrite (out, written);
-  fclose (out);
-  ADM_dealloc (outbuffer);
-  delete work;
-//  deleteAudioFilter (saveFilter);
-//  currentaudiostream-&gt;endDecompress ();
-  printf (&quot;AudioSave: actually written %u\n&quot;, written);
-  printf (&quot;Audiosave: target sample:%llu, got :%llu\n&quot;,sampleTarget,sampleCurrent);
-
-#endif
-}
-
-
-
-
 //      Clean up
 //      free all pending stuff, make leakchecker happy
 //
@@ -1513,118 +1159,6 @@
 }
 
 
-/*
-	Save a raw video stream without any container
-	Usefull to cut mpeg stream or extract raw h263/mpeg4 stream
-
-*/
-uint8_t ADM_saveRaw (const char *name)
-{
-  uint32_t len, flags;
-  FILE *fd, *fi;
-  uint8_t *buffer = new uint8_t[avifileinfo-&gt;width * avifileinfo-&gt;height * 3],ret=0;
-  char *idx;
-  DIA_workingBase *work;
-  uint8_t seq;
-  idx = new char[strlen (name) + 8];
-  strcpy (idx, name);
-  strcat (idx, &quot;.idx&quot;);
-  fd = fopen (name, &quot;wb&quot;);
-  fi = fopen (idx, &quot;wt&quot;);
-  if (!fd)
-    return 0;
-  work=createWorking(QT_TR_NOOP(&quot;Saving raw video stream&quot;));
-  ADMCompressedImage image;
-  image.data=buffer;
-  image.dataLength=avifileinfo-&gt;width * avifileinfo-&gt;height * 3;
-  // preamble
-#if 0
-  video_body-&gt;getRawStart (frameStart, buffer, &amp;len);
-  fwrite (buffer, len, 1, fd);
-#endif
-  for (uint32_t i = frameStart; i &lt; frameEnd; i++)
-    {
-      work-&gt;update (i - frameStart, frameEnd - frameStart);
-      if(!work-&gt;isAlive())
-      {
-                 ret=0;
-                 goto _abt;
-      }
-      if(!video_body-&gt;getFlags (i, &amp;flags))
-        {
-                if(i==frameEnd-1)
-                {
-                         ret=1;
-                         goto _abt;
-                }
-                ADM_assert (video_body-&gt;getFlags (i, &amp;flags));
-        }
-
-      if (flags &amp; AVI_B_FRAME)	// oops
-	{
-	  // se search for the next i /p
-	  uint32_t found = 0;
-
-	  for (uint32_t j = i + 1; j &lt; frameEnd; j++)
-	    {
-	      ADM_assert (video_body-&gt;getFlags (j, &amp;flags));
-	      if (!(flags &amp; AVI_B_FRAME))
-		{
-		  found = j;
-		  break;
-		}
-
-	    }
-	  if (!found)
-          {
-            if(abs(i-frameEnd)&gt;2)
-                ret=0;
-            else
-                ret=1;  // Good enough
-	    goto _abt;
-          }
-	  // Write the found frame
-
-	  video_body-&gt;getFrame (found, &amp;image, &amp;seq);
-	  fwrite (buffer, len, 1, fd);
-	  // and the B frames
-	  for (uint32_t j = i; j &lt; found; j++)
-	    {
-	      video_body-&gt;getFrame (j, &amp;image,&amp;seq);
-	      fwrite (buffer, len, 1, fd);
-	    }
-	  i = found;		// Will be plussed by for
-	}
-      else			// P or I frame
-	{
-	  video_body-&gt;getFrame (i, &amp;image, &amp;seq);
-	  fwrite (buffer, len, 1, fd);
-	  fprintf (fi, &quot;%u,\n&quot;, len);
-	}
-
-    }
-    ret=1;
-_abt:
-  fclose (fd);
-  fclose (fi);
-  delete work;
-  return ret;
-
-}
-
-void
-A_saveWorkbench (const char *name)
-{
-#if 0
-  video_body-&gt;saveWorbench (name);
-#else
-  video_body-&gt;saveAsScript(name,NULL);
-#endif
-  if( actual_workbench_file )
-     ADM_dealloc(actual_workbench_file);
-  actual_workbench_file = ADM_strdup(name);
-}
-
 void A_parseECMAScript(const char *name){
   bool ret;
   char *longname = ADM_PathCanonize(name);
@@ -1709,24 +1243,6 @@
 	GUI_GoToFrame(curframe);
 
 }
-//___________ save audio _____________
-int A_audioSave(char *name)
-{
-	if (!currentaudiostream)	// yes it is checked 2 times so what ?
-	return 0;
-	if (audioProcessMode())
-	{
-
-		// if we get here, either not compressed
-		// or decompressable
-		A_saveAudioDecodedTest(name);
-	    }
-	else			// copy mode...
-	    {
-	       A_saveAudio(name);
-	    }
-	return 1;
-}
 uint8_t A_pass(char *name)
 {
 //        mpeg_passthrough(name,ADM_PS);
@@ -2075,19 +1591,6 @@
         ADM_dealloc(name);
         ADM_dealloc(final);
 }
-int A_SaveWrapper(char *name)
-{
-
-        if(A_Save(name))
-        {
-          GUI_Info_HIG (ADM_LOG_INFO,QT_TR_NOOP(&quot;Done&quot;),QT_TR_NOOP( &quot;File %s has been successfully saved.&quot;),ADM_GetFileName(name));
-        }
-        else
-        {
-          GUI_Error_HIG (QT_TR_NOOP(&quot;Failed&quot;), QT_TR_NOOP(&quot;File %s was NOT saved correctly.&quot;),ADM_GetFileName(name));
-        }
-        return 1;
-}
 uint8_t  DIA_v2v(char **vobname, char **ifoname,char **vobsubname);
 uint8_t ADM_vob2vobsub(char *nameVob, char *nameVobSub, char *nameIfo);
 #if BAZOOKA
@@ -2418,7 +1921,10 @@
 
         return render;
 }
-
+/**
+        \fn getStrFromAudioCodec
+        \brief Return a plain string from the codec_id
+*/
 const char *getStrFromAudioCodec( uint32_t codec)
 {
       switch(codec)

Modified: branches/avidemux_2.6_branch_mean/avidemux/gui_action.names
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/gui_action.names	2009-02-24 19:09:05 UTC (rev 4631)
+++ branches/avidemux_2.6_branch_mean/avidemux/gui_action.names	2009-02-24 19:09:10 UTC (rev 4632)
@@ -1,3 +1,4 @@
+// 
 ACT(OpenAvi)
 ACT(AppendAvi)
 ACT(BrokenAvi)
@@ -6,30 +7,28 @@
 ACT(Exit)
 ACT(PlayAvi)
 ACT(StopAvi)
+ACT(RecentFiles)
+
+ACT(SetPostProcessing)
+//----- SAVE -----
+ACT(SAVE_BEGIN)
 ACT(SaveImg)
 ACT(SaveOGM)
 ACT(SaveJPG)
 ACT(SaveBunchJPG)
 ACT(SaveDVDPS)
 ACT(SaveUnpackedMpeg4)
-ACT(RecentFiles)
-
+ACT(SAVE_END)
 ACT(SaveDualAudio)
 ACT(SaveAvi)
 ACT(SaveWave)
-ACT(Pipe2Lame)
-ACT(PipeLame)
-ACT(Pipe2Other)
-
 ACT(SaveMpeg1vcd)
 ACT(SaveMpeg2svcd)
 ACT(SaveMpeg2dvd)
-
 ACT(SaveRaw)
-
 ACT(XVCD)
+// /SAVE
 
-ACT(SetPostProcessing)
 //--- NAVIGATE----
 ACT(NAVIGATE_BEGIN)
 ACT(NextFrame)
@@ -52,13 +51,8 @@
 ACT(GotoMarkB)
 ACT(Scale)
 ACT(NAVIGATE_END)
-//--- NAVIGATE----
+//--- /NAVIGATE----
 ACT(AllBlackFrames)
-
-
-
-
-
 ACT(AudioSourceAvi)
 ACT(AudioSourceMP3)
 ACT(AudioSourceWAV)
@@ -97,11 +91,6 @@
 
 ACT(SecondAudioTrack)
 
-ACT(SelectDevOSS)
-ACT(SelectDevDummy)
-ACT(SelectDevArts)
-ACT(SelectDevALSA)
-
 ACT(CutWizard)
 
 ACT(MpegIndex)

Added: branches/avidemux_2.6_branch_mean/avidemux/gui_save.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/gui_save.cpp	2009-02-24 19:09:05 UTC (rev 4631)
+++ branches/avidemux_2.6_branch_mean/avidemux/gui_save.cpp	2009-02-24 19:09:10 UTC (rev 4632)
@@ -0,0 +1,580 @@
+/** *************************************************************************
+            \file gui_save.cpp
+            \brief handle all kind of sabe
+    
+    copyright            : (C) 2002/2009 by mean
+    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#include &quot;ADM_default.h&quot;
+#include &quot;avi_vars.h&quot;
+
+#include &lt;math.h&gt;
+#include &quot;prototype.h&quot;
+#include &quot;gui_action.hxx&quot;
+#include &quot;gtkgui.h&quot;
+
+#include &quot;DIA_coreToolkit.h&quot;
+#include &quot;ADM_userInterfaces/ADM_commonUI/GUI_ui.h&quot;
+#include &quot;DIA_enter.h&quot;
+
+#include &quot;ADM_video/ADM_vidMisc.h&quot;
+#include &quot;DIA_fileSel.h&quot;
+#include &quot;DIA_working.h&quot;
+// Local prototypes
+void A_saveAudio (char *name);
+int  A_saveJpg (char *name);
+void A_saveBunchJpg(const char *name);
+void A_saveImg (const char *name);
+uint8_t ADM_saveRaw (const char *name);
+void A_saveWorkbench (const char *name);
+int  A_audioSave(char *name);
+int  A_SaveWrapper(char *name);
+void A_saveAudioDecodedTest (char *name);
+// Xternal prototypes
+int      A_SaveUnpackedVop(const char *name);
+uint8_t  A_SaveAudioDualAudio(const char *inname);
+int      A_Save(const char *name);
+uint8_t  GUI_getFrameContent(ADMImage *image, uint32_t frame);
+
+extern char * actual_workbench_file; // UGLY FIXME
+/**
+    \fn HandleAction_Navigate
+
+*/
+void HandleAction_Save(Action action)
+{
+    switch(action)
+    {
+    case ACT_SaveUnpackedMpeg4:
+      if(GUI_Question(QT_TR_NOOP(&quot;This is to be used to undo packed VOP on MPEG-4.\nContinue ?&quot;)))
+			{
+                          GUI_FileSelWrite (QT_TR_NOOP(&quot;Select AVI File to Write&quot;), (SELFILE_CB *)A_SaveUnpackedVop);
+
+			}
+    			break;
+
+    case ACT_SaveOGM:
+//                        GUI_FileSelWrite (QT_TR_NOOP(&quot;Select OGM File to Write&quot;), (SELFILE_CB *)ogmSave);
+    			break;
+
+    case ACT_SaveWork:
+      GUI_FileSelWrite (QT_TR_NOOP(&quot;Select Workbench to Save&quot;), A_saveWorkbench);
+	  UI_refreshCustomMenu();
+      break;
+   case ACT_SaveCurrentWork:
+      if( actual_workbench_file ){
+        char *tmp = ADM_strdup(actual_workbench_file);
+         A_saveWorkbench( tmp ); // will write &quot;actual_workbench_file&quot; itself
+         ADM_dealloc(tmp);
+      }else{
+        GUI_FileSelWrite (QT_TR_NOOP(&quot;Select Workbench to Save&quot;), A_saveWorkbench);
+		UI_refreshCustomMenu();
+      }
+      break;
+      
+    case ACT_SaveRaw:
+      GUI_FileSelWrite (QT_TR_NOOP(&quot;Select Raw File to Save&quot;), (SELFILE_CB *)ADM_saveRaw);
+      break;
+    case ACT_SaveWave:
+      	{
+          GUI_FileSelWrite (QT_TR_NOOP(&quot;Select File to Save Audio&quot;),(SELFILE_CB *)A_audioSave);
+
+	}
+      break;
+
+    case ACT_SaveDualAudio:
+      //GUI_FileSelWrite (&quot;Select AVI to save &quot;,
+      A_SaveAudioDualAudio(NULL);
+      break;
+
+    case ACT_SaveBunchJPG:
+      GUI_FileSelWrite (QT_TR_NOOP(&quot;Select JPEG Sequence to Save&quot;), A_saveBunchJpg);
+    	break;
+    case ACT_SaveImg:
+      GUI_FileSelWrite (QT_TR_NOOP(&quot;Select BMP to Save&quot;), A_saveImg);
+      //GUI_FileSelWrite (&quot;Select Jpg to save &quot;, A_saveJpg);
+      break;
+    case ACT_SaveJPG :
+      GUI_FileSelWrite (QT_TR_NOOP(&quot;Select JPEG to Save&quot;), (SELFILE_CB *)A_saveJpg);
+      	//GUI_FileSelWrite (&quot;Select Jpg to save &quot;, A_saveJpg);
+      	break;
+//----------------------test-----------------------
+    case ACT_SaveAvi:
+      GUI_FileSelWrite (QT_TR_NOOP(&quot;Select File to Save&quot;),(SELFILE_CB *)A_SaveWrapper); // A_SaveAudioNVideo);
+      break;
+//---------------------------------------------------
+
+    default:
+        ADM_assert(0);
+        break;
+    }
+}
+/**
+        \fn A_saveAudio
+        \brief Save current stream (generally avi...)     in raw mode
+*/
+void A_saveAudio (char *name)
+{
+
+// debug audio seek
+  uint32_t len2;
+  uint32_t written, max;
+  uint64_t dts;
+  DIA_workingBase *work;
+  FILE *out;
+
+#define ONE_STRIKE (64*1024)
+  uint8_t *buffer=NULL;
+
+  if (!currentaudiostream)
+    return;
+
+
+
+  out = fopen (name, &quot;wb&quot;);
+  if (!out) return;
+
+  work=createWorking(QT_TR_NOOP(&quot;Saving audio&quot;));
+
+  uint32_t timeEnd,timeStart,sample,hold,len;
+  uint64_t tgt_sample,cur_sample;
+  double   duration;
+
+  // compute start position and duration in samples
+
+   timeStart=video_body-&gt;getTime (frameStart);
+   timeEnd=video_body-&gt;getTime (frameEnd+1);
+
+   currentaudiostream-&gt;goToTime (timeStart);
+   duration=timeEnd-timeStart;
+   printf(&quot;Duration:%f ms\n&quot;,duration);
+   if(duration&lt;0) duration=-duration;
+
+   duration/=1000;
+   duration*=currentaudiostream-&gt;getInfo()-&gt;frequency;
+
+   tgt_sample=(uint64_t)floor(duration);
+
+   cur_sample=0;
+   written = 0;
+   hold=0;
+   buffer=new uint8_t[ONE_STRIKE*2];
+   while (1)
+    {
+    	if(!currentaudiostream-&gt;getPacket(buffer+hold,&amp;len,64*1024,&amp;sample,&amp;dts)) break;
+	hold+=len;
+	written+=len;
+	cur_sample+=sample;
+	if(hold&gt;ONE_STRIKE)
+	{
+		fwrite(buffer,hold,1,out);
+		hold=0;
+	}
+	if(cur_sample&gt;tgt_sample)
+		break;
+      work-&gt;update(cur_sample&gt;&gt;10, tgt_sample&gt;&gt;10);
+      if(!work-&gt;isAlive()) break;
+    };
+  if(hold)
+  {
+  	fwrite(buffer,hold,1,out);
+	hold=0;
+  }
+
+  fclose (out);
+  delete work;
+  delete[] buffer;
+  printf (&quot;\n wanted %&quot;LLU&quot; samples, goto %&quot;LLU&quot; samples, written %&quot;LU&quot; bytes\n&quot;, tgt_sample,cur_sample, written);
+
+
+}
+
+#ifndef TEST_MP2
+/**
+        \fn A_saveJpg
+        \brief Save a Jpg image from current display buffer
+*/
+int A_saveJpg (char *name)
+{
+  uint8_t fl;
+    ADMImage image(avifileinfo-&gt;width, avifileinfo-&gt;height);
+    if(!GUI_getFrameContent(&amp;image, curframe))
+    {
+      GUI_Error_HIG(QT_TR_NOOP(&quot;Get Frame&quot;),QT_TR_NOOP(&quot;Cannot get this frame to save&quot;));
+      return 0;
+    }
+    return (int) image.saveAsJpg (name);
+}
+#else
+/**
+      \fn A_saveJpg
+      \brief Save current image as jpeg 95% qual
+
+*/
+int A_saveJpg (char *name)
+{
+static int b=1;
+         video_body-&gt;changeAudioStream(0,b);
+        b^=1;
+        return 1;
+
+}
+#endif
+
+
+/**
+      \fn A_saveBunchJpg
+      \brief Save the selection  as a bunch of jpeg 95% qual
+
+*/
+void A_saveBunchJpg(const char *name)
+{
+  ADMImage *src=NULL;
+  uint32_t curImg;
+  char	 fullName[2048],*ext;
+  char *baseName;
+  DIA_workingBase *working;
+  uint8_t success=0;
+
+        if(frameStart&gt;frameEnd)
+                {
+                  GUI_Error_HIG(QT_TR_NOOP(&quot;Mark A &gt; B&quot;), QT_TR_NOOP(&quot;Set your markers correctly.&quot;));
+                        return;
+                }
+        // Split name into base + extension
+        ADM_PathSplit(name,&amp;baseName,&amp;ext);
+
+        src=new ADMImage(avifileinfo-&gt;width,avifileinfo-&gt;height);
+        ADM_assert(src);
+
+        working=createWorking(QT_TR_NOOP(&quot;Saving as set of jpegs&quot;));
+        for(curImg=frameStart;curImg&lt;=frameEnd;curImg++)
+        {
+                working-&gt;update(curImg-frameStart,frameEnd-frameStart);
+                if (!GUI_getFrameContent (src,curImg ))
+                {
+                  GUI_Error_HIG(QT_TR_NOOP(&quot;Cannot decode frame&quot;), QT_TR_NOOP(&quot;Aborting.&quot;));
+                        goto _bunch_abort;
+                }
+                if(!working-&gt;isAlive()) goto _bunch_abort;
+                sprintf(fullName,&quot;%s%04d.jpg&quot;,baseName,curImg-frameStart);
+                if(!src-&gt;saveAsJpg(fullName)) goto _bunch_abort;
+        }
+        success=1;
+
+_bunch_abort:
+        if(success)
+            GUI_Info_HIG(ADM_LOG_INFO,QT_TR_NOOP(&quot;Done&quot;),QT_TR_NOOP( &quot;Saved %d images.&quot;), curImg-frameStart);
+        else
+            GUI_Error_HIG(QT_TR_NOOP(&quot;Error&quot;),QT_TR_NOOP( &quot;Could not save all images.&quot;));
+        delete working	;
+        delete src;
+        return ;
+
+
+}
+/**
+      \fn A_saveImg
+      \brief Save current displayed image as a BMP file
+*/
+void A_saveImg (const char *name)
+{
+
+  ADMImage image(avifileinfo-&gt;width,avifileinfo-&gt;height);
+  GUI_getFrameContent(&amp;image, video_body-&gt;getCurrentFrame());
+  if(image.saveAsBmp(name))
+        GUI_Info_HIG (ADM_LOG_INFO,QT_TR_NOOP(&quot;Done&quot;),QT_TR_NOOP( &quot;Saved \&quot;%s\&quot;.&quot;), ADM_GetFileName(name));
+  else
+        GUI_Error_HIG (QT_TR_NOOP(&quot;BMP op failed&quot;),QT_TR_NOOP( &quot;Saving %s as a BMP file failed.&quot;), ADM_GetFileName(name));
+}
+
+/*
+	Save a raw video stream without any container
+	Usefull to cut mpeg stream or extract raw h263/mpeg4 stream
+
+*/
+uint8_t ADM_saveRaw (const char *name)
+{
+  uint32_t len, flags;
+  FILE *fd, *fi;
+  uint8_t *buffer = new uint8_t[avifileinfo-&gt;width * avifileinfo-&gt;height * 3],ret=0;
+  char *idx;
+  DIA_workingBase *work;
+  uint8_t seq;
+  idx = new char[strlen (name) + 8];
+  strcpy (idx, name);
+  strcat (idx, &quot;.idx&quot;);
+  fd = fopen (name, &quot;wb&quot;);
+  fi = fopen (idx, &quot;wt&quot;);
+  if (!fd)
+    return 0;
+  work=createWorking(QT_TR_NOOP(&quot;Saving raw video stream&quot;));
+  ADMCompressedImage image;
+  image.data=buffer;
+  image.dataLength=avifileinfo-&gt;width * avifileinfo-&gt;height * 3;
+  // preamble
+#if 0
+  video_body-&gt;getRawStart (frameStart, buffer, &amp;len);
+  fwrite (buffer, len, 1, fd);
+#endif
+  for (uint32_t i = frameStart; i &lt; frameEnd; i++)
+    {
+      work-&gt;update (i - frameStart, frameEnd - frameStart);
+      if(!work-&gt;isAlive())
+      {
+                 ret=0;
+                 goto _abt;
+      }
+      if(!video_body-&gt;getFlags (i, &amp;flags))
+        {
+                if(i==frameEnd-1)
+                {
+                         ret=1;
+                         goto _abt;
+                }
+                ADM_assert (video_body-&gt;getFlags (i, &amp;flags));
+        }
+
+      if (flags &amp; AVI_B_FRAME)	// oops
+	{
+	  // se search for the next i /p
+	  uint32_t found = 0;
+
+	  for (uint32_t j = i + 1; j &lt; frameEnd; j++)
+	    {
+	      ADM_assert (video_body-&gt;getFlags (j, &amp;flags));
+	      if (!(flags &amp; AVI_B_FRAME))
+		{
+		  found = j;
+		  break;
+		}
+
+	    }
+	  if (!found)
+          {
+            if(abs(i-frameEnd)&gt;2)
+                ret=0;
+            else
+                ret=1;  // Good enough
+	    goto _abt;
+          }
+	  // Write the found frame
+
+	  video_body-&gt;getFrame (found, &amp;image, &amp;seq);
+	  fwrite (buffer, len, 1, fd);
+	  // and the B frames
+	  for (uint32_t j = i; j &lt; found; j++)
+	    {
+	      video_body-&gt;getFrame (j, &amp;image,&amp;seq);
+	      fwrite (buffer, len, 1, fd);
+	    }
+	  i = found;		// Will be plussed by for
+	}
+      else			// P or I frame
+	{
+	  video_body-&gt;getFrame (i, &amp;image, &amp;seq);
+	  fwrite (buffer, len, 1, fd);
+	  fprintf (fi, &quot;%u,\n&quot;, len);
+	}
+
+    }
+    ret=1;
+_abt:
+  fclose (fd);
+  fclose (fi);
+  delete work;
+  return ret;
+
+}
+/**
+    \fn A_saveWorkbench
+    \brief Save current workbench as ecmascript
+*/
+void A_saveWorkbench (const char *name)
+{
+#if 0
+  video_body-&gt;saveWorbench (name);
+#else
+  video_body-&gt;saveAsScript(name,NULL);
+#endif
+  if( actual_workbench_file )
+     ADM_dealloc(actual_workbench_file);
+  actual_workbench_file = ADM_strdup(name);
+}
+/**
+    \fn A_audioSave
+    \brief Save audio track
+*/
+
+int A_audioSave(char *name)
+{
+	if (!currentaudiostream)	// yes it is checked 2 times so what ?
+	return 0;
+	if (audioProcessMode())
+	{
+
+		// if we get here, either not compressed
+		// or decompressable
+		A_saveAudioDecodedTest(name);
+	    }
+	else			// copy mode...
+	    {
+	       A_saveAudio(name);
+	    }
+	return 1;
+}
+int A_SaveWrapper(char *name)
+{
+
+        if(A_Save(name))
+        {
+          GUI_Info_HIG (ADM_LOG_INFO,QT_TR_NOOP(&quot;Done&quot;),QT_TR_NOOP( &quot;File %s has been successfully saved.&quot;),ADM_GetFileName(name));
+        }
+        else
+        {
+          GUI_Error_HIG (QT_TR_NOOP(&quot;Failed&quot;), QT_TR_NOOP(&quot;File %s was NOT saved correctly.&quot;),ADM_GetFileName(name));
+        }
+        return 1;
+}
+
+/**
+    \fn A_saveAudioDecodedTest
+    \brief Save current stream (generally avi...)
+     in decoded mode (assuming MP3)
+*/
+void A_saveAudioDecodedTest (char *name)
+{
+#if 0
+// debug audio seek
+  uint32_t len, gauge = 0;
+  uint32_t written = 0;
+  FILE *out;
+  AVDMGenericAudioStream *saveFilter;
+
+  uint64_t sampleTarget,sampleCurrent;
+
+#undef BITT
+#define BITT 4*1152
+#define OUTCHUNK 1024*1024
+  uint8_t *outbuffer;
+
+  if (!currentaudiostream)
+    return;
+
+
+  if (!(out = fopen (name, &quot;wb&quot;)))
+    {
+      GUI_Error_HIG (QT_TR_NOOP(&quot;File error&quot;), QT_TR_NOOP(&quot;Cannot open \&quot;%s\&quot; for writing.&quot;), name);
+      return;
+    }
+
+  outbuffer = (uint8_t *) ADM_alloc (2 * OUTCHUNK);	// 1Meg cache;
+  if (!outbuffer)
+    {
+      GUI_Error_HIG (QT_TR_NOOP(&quot;Memory Error&quot;), NULL);
+      return;
+    }
+
+
+
+// re-ignite first filter...
+
+
+
+
+  // Write Wav header
+
+  /* Sat Nov 09 06:11:52 CET 2002 Fixes from Maik Broemme &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">mbroemme at plusserver.de</A>&gt; */
+  /* If you set negative delay and save the audio stream, the saved stream was shorter than the video stream. */
+
+  /* Example: video stream is 10 minutes long, audio stream perhaps 20 minutes, you need the audio stream from */
+  /*          minute 1 until 11, so you setup an audio delay from -60 seconds, but this 60 seconds were removed */
+  /*          from begin and end of the audio stream. That was not good :) Now it runs correctly also if you use */
+  /*          audio stream with same length then video, therefore is premature ending :) */
+
+
+
+//        saveFilter =  buildAudioFilter (currentaudiostream,video_body-&gt;getTime (frameStart));
+
+		if (saveFilter == NULL)
+		{
+			fclose(out);
+			ADM_dealloc(outbuffer);
+			return;
+		}
+
+    	DIA_working *work=new DIA_working(QT_TR_NOOP(&quot;Saving audio&quot;));
+
+
+//
+//  Create First filter that is null filter
+//
+  saveFilter-&gt;writeHeader (out);
+  uint32_t tstart,tend,samples;
+  double duration;
+  tstart=video_body-&gt;getTime(frameStart);
+  tend=video_body-&gt;getTime(frameEnd+1);
+  duration=(tend-tstart);
+  duration*=saveFilter-&gt;getInfo()-&gt;frequency;
+  duration/=1000.;
+
+  sampleTarget=(uint64_t)floor(duration);
+  sampleCurrent=0;
+  gauge=0;
+
+  if( frameStart == frameEnd ){
+     /* JSC: we will write some bytes, but nobody should expect useful data */
+    GUI_Error_HIG(QT_TR_NOOP(&quot;No frames to encode&quot;),QT_TR_NOOP(&quot;Please check markers. Is \&quot;A&gt;\&quot; == \&quot;&gt;B\&quot;?&quot;));
+  }
+
+  while ((sampleCurrent&lt;sampleTarget))
+    {
+      if(!saveFilter-&gt;getPacket(outbuffer + gauge,&amp;len,&amp;samples))
+      {
+        printf(&quot;Audio save:Read error\n&quot;);
+      	break;
+      }
+      //      printf(&quot;Got : %lu\n&quot;,len2);
+      gauge += len;
+      sampleCurrent+=samples;
+      // update GUI
+	// JSC: if &quot;A&gt;&quot; == &quot;&gt;B&quot; we will get &gt;100% here =&gt; assert in work-&gt;update()
+	if (work-&gt;update ((sampleCurrent&gt;&gt;10 &gt; sampleTarget&gt;&gt;10 ? sampleTarget&gt;&gt;10 : sampleCurrent&gt;&gt;10), sampleTarget&gt;&gt;10))	// abort request ?
+	    break;;
+      if (gauge &gt; OUTCHUNK)	// either out buffer is full
+	{
+	  fwrite (outbuffer, 1, gauge, out);
+	  written += gauge;
+	  gauge = 0;
+	}
+    };
+// Clean up
+	if(gauge)
+	{
+		fwrite (outbuffer,  gauge,1, out);
+		written += gauge;
+		gauge = 0;
+	}
+  saveFilter-&gt;endWrite (out, written);
+  fclose (out);
+  ADM_dealloc (outbuffer);
+  delete work;
+//  deleteAudioFilter (saveFilter);
+//  currentaudiostream-&gt;endDecompress ();
+  printf (&quot;AudioSave: actually written %u\n&quot;, written);
+  printf (&quot;Audiosave: target sample:%llu, got :%llu\n&quot;,sampleTarget,sampleCurrent);
+
+#endif
+}
+//EOF
+

Modified: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegPS/ADM_ps.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegPS/ADM_ps.cpp	2009-02-24 19:09:05 UTC (rev 4631)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegPS/ADM_ps.cpp	2009-02-24 19:09:10 UTC (rev 4632)
@@ -57,7 +57,7 @@
         goto abt;
     }
     append=index.getAsUint32(&quot;Append&quot;);
-
+    printf(&quot;[psDemux] Append=%&quot;LU&quot;\n&quot;,append);
     if(append) appendType=FP_APPEND;
     if(!parser.open(name,&amp;appendType))
     {
@@ -85,7 +85,7 @@
 //***********
     
     psPacket=new psPacketLinear(0xE0);
-    if(psPacket-&gt;open(name,append)==false) 
+    if(psPacket-&gt;open(name,appendType)==false) 
     {
         printf(&quot;psDemux] Cannot psPacket open the file\n&quot;);
         goto abt;

Modified: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegPS/ADM_psAudio.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegPS/ADM_psAudio.cpp	2009-02-24 19:09:05 UTC (rev 4631)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegPS/ADM_psAudio.cpp	2009-02-24 19:09:10 UTC (rev 4632)
@@ -36,7 +36,7 @@
 FP_TYPE fp=FP_DONT_APPEND;
         if(append) fp=FP_APPEND;
         this-&gt;pid=pid;
-        if(!demuxer.open(name,&amp;fp)) ADM_assert(0);
+        if(!demuxer.open(name,fp)) ADM_assert(0);
 }
 
 /**

Modified: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegPS/ADM_psAudioProbe.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegPS/ADM_psAudioProbe.cpp	2009-02-24 19:09:05 UTC (rev 4631)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegPS/ADM_psAudioProbe.cpp	2009-02-24 19:09:10 UTC (rev 4632)
@@ -54,7 +54,7 @@
 
     printf(&quot;[MpegPS] Probing audio for %s\n&quot;,fileName);
 
-    if(!packet-&gt;open(fileName,1)) goto end;
+    if(!packet-&gt;open(fileName,FP_APPEND)) goto end;
     fileSize=packet-&gt;getSize();
 
     packet-&gt;setPos(fileSize/2); // Jump in the middle of the stream

Modified: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegPS/ADM_psIndex.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegPS/ADM_psIndex.cpp	2009-02-24 19:09:05 UTC (rev 4631)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegPS/ADM_psIndex.cpp	2009-02-24 19:09:10 UTC (rev 4632)
@@ -175,7 +175,9 @@
         }
 
     }
-    pkt-&gt;open(file,false);
+
+    FP_TYPE append=FP_APPEND;
+    pkt-&gt;open(file,append);
     data.pkt=pkt;
     fullSize=pkt-&gt;getSize();
       while(1)


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001861.html">[Avidemux-svn-commit] r4631 -	branches/avidemux_2.6_branch_mean/avidemux/ADM_editor
</A></li>
	<LI>Next message: <A HREF="001863.html">[Avidemux-svn-commit] r4633 - in	branches/avidemux_2.5_branch_gruntster/avidemux: .	ADM_userInterfaces/ADM_render
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1862">[ date ]</a>
              <a href="thread.html#1862">[ thread ]</a>
              <a href="subject.html#1862">[ subject ]</a>
              <a href="author.html#1862">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">More information about the Avidemux-svn-commit
mailing list</a><br>
</body></html>
