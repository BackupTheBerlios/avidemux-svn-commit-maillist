<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Avidemux-svn-commit] r4583 - in branches/avidemux_2.6_branch_mean:	avidemux avidemux/ADM_coreDemuxerMpeg/include	avidemux/ADM_coreDemuxerMpeg/src plugins/ADM_demuxers/MpegPS
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/avidemux-svn-commit/2009-February/index.html" >
   <LINK REL="made" HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r4583%20-%20in%20branches/avidemux_2.6_branch_mean%3A%0A%09avidemux%20avidemux/ADM_coreDemuxerMpeg/include%0A%09avidemux/ADM_coreDemuxerMpeg/src%20plugins/ADM_demuxers/MpegPS&In-Reply-To=%3C200902110627.n1B6RSOe007835%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="001812.html">
   <LINK REL="Next"  HREF="001814.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Avidemux-svn-commit] r4583 - in branches/avidemux_2.6_branch_mean:	avidemux avidemux/ADM_coreDemuxerMpeg/include	avidemux/ADM_coreDemuxerMpeg/src plugins/ADM_demuxers/MpegPS</H1>
    <B>mean at BerliOS</B> 
    <A HREF="mailto:avidemux-svn-commit%40lists.berlios.de?Subject=Re%3A%20%5BAvidemux-svn-commit%5D%20r4583%20-%20in%20branches/avidemux_2.6_branch_mean%3A%0A%09avidemux%20avidemux/ADM_coreDemuxerMpeg/include%0A%09avidemux/ADM_coreDemuxerMpeg/src%20plugins/ADM_demuxers/MpegPS&In-Reply-To=%3C200902110627.n1B6RSOe007835%40sheep.berlios.de%3E"
       TITLE="[Avidemux-svn-commit] r4583 - in branches/avidemux_2.6_branch_mean:	avidemux avidemux/ADM_coreDemuxerMpeg/include	avidemux/ADM_coreDemuxerMpeg/src plugins/ADM_demuxers/MpegPS">mean at mail.berlios.de
       </A><BR>
    <I>Wed Feb 11 07:27:29 CET 2009</I>
    <P><UL>
        <LI>Previous message: <A HREF="001812.html">[Avidemux-svn-commit] r4582 - in	branches/avidemux_2.5_branch_gruntster/platforms/windows:	build_scripts/avidemux installer
</A></li>
        <LI>Next message: <A HREF="001814.html">[Avidemux-svn-commit] r4584 -	branches/avidemux_2.5_branch_gruntster/platforms/windows/installer
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1813">[ date ]</a>
              <a href="thread.html#1813">[ thread ]</a>
              <a href="subject.html#1813">[ subject ]</a>
              <a href="author.html#1813">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: mean
Date: 2009-02-11 07:27:26 +0100 (Wed, 11 Feb 2009)
New Revision: 4583

Added:
   branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxerMpeg/include/ADM_indexFile.h
   branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxerMpeg/include/dmxPSPacket.h
   branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxerMpeg/src/ADM_indexFile.cpp
   branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxerMpeg/src/dmxPSPacket.cpp
Removed:
   branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxerMpeg/src/dmx_demuxer.cpp
   branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxerMpeg/src/dmx_demuxerES.cpp
   branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxerMpeg/src/dmx_demuxerMSDVR.cpp
   branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxerMpeg/src/dmx_demuxerPS.cpp
   branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxerMpeg/src/dmx_demuxerTS.cpp
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegPS/ADM_indexFile.cpp
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegPS/ADM_indexFile.h
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegPS/dmxPSPacket.cpp
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegPS/dmxPSPacket.h
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegPS/dmx_io.cpp
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegPS/dmx_io.h
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegPS/dmx_mpegstartcode.h
Modified:
   branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxerMpeg/include/dmx_io.h
   branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxerMpeg/include/dmx_mpegstartcode.h
   branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxerMpeg/src/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxerMpeg/src/dmx_io.cpp
   branches/avidemux_2.6_branch_mean/avidemux/CMakeLists.txt
   branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegPS/CMakeLists.txt
Log:
[Mpeg] Factorize mpeg/mpegps related code in codeDemuxerMpeg

Copied: branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxerMpeg/include/ADM_indexFile.h (from rev 4578, branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegPS/ADM_indexFile.h)
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegPS/ADM_indexFile.h	2009-02-07 14:34:30 UTC (rev 4578)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxerMpeg/include/ADM_indexFile.h	2009-02-11 06:27:26 UTC (rev 4583)
@@ -0,0 +1,74 @@
+/**
+    \file ADM_indexFile
+    \brief Handle index file reading
+    copyright            : (C) 2009 by mean
+    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
+        
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+
+#ifndef ADM_INDEXFILE_H
+#define ADM_INDEXFILE_H
+#include &lt;vector&gt;
+/**
+    \class indexFile
+    \brief Read a index file easily
+*/
+#define ADM_INDEX_BUFFER (20*1024)
+/**
+    \class dmxToken
+*/
+class dmxToken
+{
+protected:
+    char *name;
+    char *value;
+    FILE *file;
+    void  purgeTokens(void);
+public:
+    
+    dmxToken(const char *name,const char *value);
+    ~dmxToken();
+    char *getName(void);
+    char *getValue(void);
+    bool  isNumeric(void);
+    uint32_t getAsNumber(void);
+};
+
+/**
+    \class indexFile
+*/
+
+class indexFile
+{
+protected:
+    uint8_t         buffer[ADM_INDEX_BUFFER];
+    dmxToken        *searchToken(const char *name);
+    void            purgeTokens(void);
+
+    FILE            *file;
+    std::vector &lt;dmxToken *&gt; ListOfTokens;
+public:
+
+        indexFile();
+        ~indexFile();
+    bool open(const char *name);
+    bool close(void);
+    bool goToSection(const char *section);
+    bool readSection(const char *section);
+    uint32_t getAsUint32(const char *token);
+    uint32_t getAsHex(const char *token);
+    char *getAsString(const char *token);
+    bool  readString(uint32_t maxLen,uint8_t *buffer);
+
+};
+
+#endif
\ No newline at end of file

Copied: branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxerMpeg/include/dmxPSPacket.h (from rev 4578, branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegPS/dmxPSPacket.h)
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegPS/dmxPSPacket.h	2009-02-07 14:34:30 UTC (rev 4578)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxerMpeg/include/dmxPSPacket.h	2009-02-11 06:27:26 UTC (rev 4583)
@@ -0,0 +1,112 @@
+/**
+    dmxPSPacket.cpp
+
+*/
+
+#ifndef DMXPSPACKET_H
+#define DMXPSPACKET_H
+
+#include &quot;dmx_io.h&quot;
+#include &quot;ADM_Video.h&quot;
+
+/**
+    \struct psPacketInfo
+
+*/
+typedef struct
+{
+    uint64_t pts;
+    uint64_t dts;
+    uint64_t startAt;
+    uint32_t offset;
+
+}psPacketInfo;
+
+/**
+    \class psPacket
+*/
+class psPacket
+{
+protected:
+    int         doNoComplainAnyMore;
+    fileParser  *_file;
+    uint64_t    _size;
+    uint8_t     getPacketInfo(uint8_t stream,uint8_t *substream,uint32_t *olen,uint64_t *opts,uint64_t *odts);
+public:
+                psPacket(void);
+                ~psPacket();
+    bool        open(const char *filenames,bool dontappend);
+    bool        close(void);
+    virtual bool        getPacket(uint32_t maxSize, uint8_t *pid, uint32_t *packetSize,uint64_t *pts,uint64_t *dts,uint8_t *buffer,uint64_t *startAt);
+    virtual bool        getPacketOfType(uint8_t pid,uint32_t maxSize, uint32_t *packetSize,uint64_t *pts,uint64_t *dts,uint8_t *buffer,uint64_t *startAt);
+    uint64_t    getPos(void);
+    bool        setPos(uint64_t pos);
+    uint64_t    getSize(void) { return _file-&gt;getSize();}
+};
+/**
+    \class psPacketLinear
+*/
+#define ADM_PACKET_LINEAR 10*1024
+
+class psPacketLinear : public psPacket
+{
+protected:
+        uint8_t  myPid;
+        uint64_t startAt;
+        uint32_t bufferLen;
+        uint64_t bufferPts;
+        uint64_t bufferDts;
+        uint32_t bufferIndex;
+        uint8_t  buffer[ADM_PACKET_LINEAR];
+        bool     eof;
+        bool     refill(void);
+        uint64_t oldStartAt;
+        uint32_t oldBufferLen;
+        uint64_t oldBufferPts;
+        uint64_t oldBufferDts;
+        uint32_t consumed;
+
+public:
+                psPacketLinear(uint8_t pid);
+                ~psPacketLinear();
+        uint32_t getConsumed(void);
+        uint8_t  readi8();
+        uint16_t readi16();
+        uint32_t readi32();
+        bool     sync(uint8_t *pid);
+        bool    read(uint32_t len, uint8_t *buffer);
+        bool    forward(uint32_t v);
+        bool    stillOk(void) {return !eof;};
+        bool    getInfo(psPacketInfo *info);
+        bool    seek(uint64_t packetStart, uint32_t offset);
+        bool    changePid(uint32_t pid) ;
+};
+/**
+    \class psPacketLinearTracker
+*/
+typedef struct
+{
+    uint32_t count;
+    uint32_t size;
+    
+    uint64_t startAt;
+    uint32_t startCount;
+    uint32_t startSize;
+    uint64_t startDts;
+}packetStats;
+
+class psPacketLinearTracker : public psPacketLinear
+{
+protected:
+      packetStats stats[256];
+
+public:
+                        psPacketLinearTracker(uint8_t pid);
+                        ~psPacketLinearTracker();
+         packetStats    *getStat(int intdex);
+         bool           resetStats(void);
+virtual  bool           getPacketOfType(uint8_t pid,uint32_t maxSize, uint32_t *packetSize,uint64_t *pts,uint64_t *dts,uint8_t *buffer,uint64_t *startAt);
+};
+
+
+#endif
\ No newline at end of file

Modified: branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxerMpeg/include/dmx_io.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxerMpeg/include/dmx_io.h	2009-02-10 16:00:26 UTC (rev 4582)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxerMpeg/include/dmx_io.h	2009-02-11 06:27:26 UTC (rev 4583)
@@ -58,6 +58,7 @@
                         uint64_t getSize( void ) ;
                         uint32_t read32(uint32_t l, uint8_t *buffer);
                         uint8_t  end(void) { return _off==_size-1;};
+						void hexDump(uint8_t *buf, int size);
 #ifdef NO_INLINE_FP
                         uint32_t read32i(void );
                         uint16_t read16i(void );

Modified: branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxerMpeg/include/dmx_mpegstartcode.h
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxerMpeg/include/dmx_mpegstartcode.h	2009-02-10 16:00:26 UTC (rev 4582)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxerMpeg/include/dmx_mpegstartcode.h	2009-02-11 06:27:26 UTC (rev 4583)
@@ -13,7 +13,7 @@
 
 #define USER_DATA_START_CODE    0xb2
 #define SYSTEM_START_CODE       0xbb
-#define PADDING_CODE                                            0xbe
+#define PADDING_CODE            0xbe
 #define PRIVATE_STREAM_1        0xbd
 #define PRIVATE_STREAM_2        0xbf
 #define SYSTEM_END_CODE         0xb9

Copied: branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxerMpeg/src/ADM_indexFile.cpp (from rev 4578, branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegPS/ADM_indexFile.cpp)
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegPS/ADM_indexFile.cpp	2009-02-07 14:34:30 UTC (rev 4578)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxerMpeg/src/ADM_indexFile.cpp	2009-02-11 06:27:26 UTC (rev 4583)
@@ -0,0 +1,238 @@
+/**
+    \file ADM_indexFile
+    \brief Handle index file reading
+    copyright            : (C) 2009 by mean
+    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
+        
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include &quot;ADM_default.h&quot;
+#include &quot;ADM_indexFile.h&quot;
+#include &quot;ctype.h&quot;
+/**
+
+*/
+dmxToken::dmxToken(const char *name,const char *value)
+{
+    this-&gt;name=ADM_strdup(name);
+    this-&gt;value=ADM_strdup(value);
+}
+/**
+
+*/
+dmxToken::~dmxToken()
+{
+    if(name) ADM_dealloc(name);
+    if(value) ADM_dealloc(value);
+}
+
+char *dmxToken::getName(void) {return name;}
+char *dmxToken::getValue(void){return value;}
+/**
+
+*/
+bool  dmxToken::isNumeric(void)
+{
+bool num=true;
+int l=strlen(value);
+    for(int i=0;i&lt;l;i++)
+    {
+        char v=value[i];
+        if(!isdigit(v)&amp;&amp; v!=0x0a &amp;&amp; v!=0x0d) num=false;
+    }
+    return num;
+}   
+/**
+
+*/
+uint32_t dmxToken::getAsNumber(void)
+{
+uint32_t v;
+    v=atoi(value);
+    return v;
+}
+
+//****************************************************************************************
+
+/**
+
+*/
+
+indexFile::indexFile()
+{
+    file=NULL;
+}
+/**
+
+*/
+
+indexFile::~indexFile()
+{
+   close();
+}
+/**
+
+*/
+void  indexFile::purgeTokens(void)
+{
+    while(ListOfTokens.size())
+    {
+        delete ListOfTokens[0];
+        ListOfTokens.erase(ListOfTokens.begin());
+    }
+}
+/**
+
+*/
+dmxToken        *indexFile::searchToken(const char *name)
+{
+    for(int i=0;i&lt;ListOfTokens.size();i++)
+    {
+        dmxToken *tk=ListOfTokens[i];
+        if(!strcasecmp(name,tk-&gt;getName())) return tk;
+    }
+    printf(&quot;[indexFile] Token %s not found\n&quot;,name);
+    return NULL;
+}
+/**
+
+*/
+
+bool indexFile::open(const char *name)
+{
+    file=fopen(name,&quot;rt&quot;);
+    if(!file) return false;
+    return true;
+}
+
+/**
+
+*/
+
+bool indexFile::close(void)
+{
+    if(file)
+    {
+        fclose(file);
+        file=NULL;
+    }
+    purgeTokens();
+
+}
+
+/**
+
+*/
+
+bool indexFile::goToSection(const char *section)
+{
+char match[100];
+    sprintf(match,&quot;[%s]\n&quot;,section);
+    fseek(file,0,SEEK_SET);
+    while(1)
+    {
+        if(!fgets((char*)buffer,ADM_INDEX_BUFFER,file) )
+        {
+            printf(&quot;[indexFile] Cannot find section %s,%s*\n&quot;,section,match);
+            return false;
+        }
+        if(!strcasecmp((char*)buffer,match)) return true;
+    }
+    return false;
+}
+
+/**
+    \fn readSection
+*/
+
+bool indexFile::readSection(const char *section)
+{
+    if(false==goToSection(section)) return false;
+    // Until we reach the next section, store all couples name/value into the
+    //
+    while(1)
+    {
+        if(!readString(ADM_INDEX_BUFFER,buffer)) break;
+        if(buffer[0]=='[') break; // end of section
+        // Now search the = and replace it by a zero
+        char *head,*tail;
+        head=(char *)buffer;
+        tail=(char *)buffer;
+        tail=strstr((char *)buffer,&quot;=&quot;);
+        if(!tail) 
+        {
+            printf(&quot;[psIndexer]Weird line :%s\n&quot;,buffer);
+        }
+        *tail=0;
+        tail++;
+        dmxToken *tk=new dmxToken(head,tail);
+        ListOfTokens.push_back(tk);
+
+    }
+    return true;
+}
+
+/**
+
+*/
+
+uint32_t indexFile::getAsUint32(const char *name)
+{
+    dmxToken *token=searchToken(name);
+    if(!token) return 0;
+    if(token-&gt;isNumeric()) return token-&gt;getAsNumber();
+    printf(&quot;[psIndex] token %s is not a digit : %s\n&quot;,name,token-&gt;getValue());
+    return 0;
+}
+
+/** 
+    \fn getAsHex
+    \read entry as hex
+
+*/
+
+uint32_t indexFile::getAsHex(const char *name)
+{
+    uint32_t v;
+    dmxToken *token=searchToken(name);
+    char *s;
+    if(!token) return 0;
+    s=token-&gt;getValue();
+    sscanf(s,&quot;%x&quot;,&amp;v);
+    return v;
+}
+
+/**
+
+*/
+
+char *indexFile::getAsString(const char *name)
+{
+    dmxToken *token=searchToken(name);
+    if(!token) return NULL;
+    return token-&gt;getValue();
+
+}
+
+/**
+
+*/
+
+bool  indexFile::readString(uint32_t maxLen,uint8_t *buffer)
+{
+    if(!fgets((char *)buffer,maxLen,file)) return false;
+    buffer[maxLen-1]=0;
+    return true;
+}
+
+
+//EOF
+

Modified: branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxerMpeg/src/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxerMpeg/src/CMakeLists.txt	2009-02-10 16:00:26 UTC (rev 4582)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxerMpeg/src/CMakeLists.txt	2009-02-11 06:27:26 UTC (rev 4583)
@@ -4,12 +4,9 @@
 #
 
 SET(ADMcoreDemuxerMpeg_SRCS
-#dmx_demuxer.cpp
-#dmx_demuxerES.cpp
-#dmx_demuxerMSDVR.cpp
-#dmx_demuxerPS.cpp
-#dmx_demuxerTS.cpp
-#dmx_io.cpp
+ADM_indexFile.cpp
+dmx_io.cpp
+dmxPSPacket.cpp
 )	
 #*************************************************
 ADD_LIBRARY(ADM_coreDemuxerMpeg SHARED ${ADMcoreDemuxerMpeg_SRCS})

Copied: branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxerMpeg/src/dmxPSPacket.cpp (from rev 4578, branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegPS/dmxPSPacket.cpp)
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegPS/dmxPSPacket.cpp	2009-02-07 14:34:30 UTC (rev 4578)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxerMpeg/src/dmxPSPacket.cpp	2009-02-11 06:27:26 UTC (rev 4583)
@@ -0,0 +1,660 @@
+/**
+    \file dmxPSPacket
+    \brief Packet demuxer for mpeg PS
+    copyright            : (C) 2005-2008 by mean
+    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
+        
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+#include &quot;ADM_default.h&quot;
+
+#include &quot;dmxPSPacket.h&quot;
+#include &quot;dmx_mpegstartcode.h&quot;
+
+/**
+    \fn psPacket
+    \brief ctor
+*/
+psPacket::psPacket(void)
+{
+    doNoComplainAnyMore=0;
+    _file=NULL;
+}
+/**
+    \fn psPacket
+    \brief dtor
+*/
+psPacket::~psPacket()
+{
+    close();
+}
+/**
+    \fn open
+    \brief dtor
+*/
+bool psPacket::open(const char *filenames,bool dontappend)
+{
+FP_TYPE opentype=FP_APPEND;
+    if(dontappend) opentype=FP_DONT_APPEND;
+    _file=new fileParser();
+    if(!_file-&gt;open(filenames,&amp;opentype))
+    {
+        printf(&quot;[DmxPS] cannot open %s\n&quot;,filenames);
+        delete _file;
+        _file=NULL;
+        return false;
+    }
+    _size=_file-&gt;getSize();
+    return true;
+}
+/**
+    \fn close
+    \brief dtor
+*/
+bool psPacket::close(void)
+{
+    if(_file)
+    {
+        delete _file;
+        _file=NULL;
+    }
+    return true;
+}
+/**
+    \fn getPos
+*/
+uint64_t    psPacket::getPos(void)
+{
+    return 0;
+}
+/**
+    \fn setPos
+*/
+
+bool    psPacket::setPos(uint64_t pos)
+{
+    if(!_file-&gt;setpos(pos))
+    {
+        printf(&quot;[psPacket] Cannot seek to %&quot;LLX&quot;\n&quot;, pos);
+        return false;
+    }
+}
+
+/**
+    \fn getPacketOfType
+    \brief Only returns packet of type pid
+*/      
+
+bool        psPacket::getPacketOfType(uint8_t pid,uint32_t maxSize, uint32_t *packetSize,uint64_t *pts,uint64_t *dts,uint8_t *buffer,uint64_t *startAt)
+{
+
+    bool xit=false;
+    uint8_t tmppid;
+    while(1)
+    {
+        if(true!=getPacket(maxSize,&amp;tmppid,packetSize,pts,dts,buffer,startAt))
+                return false;
+        else
+                if(tmppid==pid) return true;
+    }
+    return false;
+}
+/**
+    \fn getPacket
+*/      
+bool        psPacket::getPacket(uint32_t maxSize, uint8_t *pid, uint32_t *packetSize,uint64_t *opts,uint64_t *odts,uint8_t *buffer,uint64_t *startAt)
+{
+uint32_t globstream,len;
+uint8_t  stream,substream;
+uint64_t pts,dts;
+        // Resync on our stream
+_again2:
+        *pid=0;
+        if(!_file-&gt;sync(&amp;stream)) 
+        {
+                uint64_t pos;
+                _file-&gt;getpos(&amp;pos);
+                printf(&quot;[DmxPS] cannot sync  at &quot;LLU&quot;/&quot;LLU&quot;\n&quot;,pos,_size);
+                return false;
+        }
+// Position of this packet just before startcode
+        _file-&gt;getpos(startAt);
+        *startAt-=4;
+// Handle out of band stuff        
+        if(stream==PACK_START_CODE) 
+        {
+        		_file-&gt;forward(8);
+        		goto _again2;
+        }
+        if( stream==PADDING_CODE ||stream==SYSTEM_START_CODE) 
+        {
+                        len=_file-&gt;read16i();
+                        //printf(&quot;\tForwarding %lu bytes\n&quot;,len);
+        		_file-&gt;forward(len);
+        		goto _again2;
+        }
+        // Only keep relevant parts
+        // i.e. a/v : C0 C9 E0 E9
+        // subs 20-29
+        // private data 1/2
+#define INSIDE(min,max) (stream&gt;=min &amp;&amp; stream&lt;max)
+        if(!(  INSIDE(0xC0,0xC9) || INSIDE(0xE0,0xE9) || INSIDE(0x20,0x29) || stream==PRIVATE_STREAM_1 || stream==PRIVATE_STREAM_2
+        			)) goto _again2;
+        // Ok we got a candidate
+        if(!getPacketInfo(stream,&amp;substream,&amp;len,&amp;pts,&amp;dts))   
+        {
+                goto _again2;
+        }
+        
+        //printf(&quot;Main Stream :%x substream :%x\n&quot;,stream,substream);
+        if(stream==PRIVATE_STREAM_1) globstream=0xFF00+substream;
+                else                 globstream=stream;
+
+        *pid=globstream;
+        *opts=pts;
+        *odts=dts;
+        *packetSize=len;
+        if(len&gt;     maxSize)
+        {
+                printf(&quot;[DmxPS] Packet too big %d vs %d\n&quot;,len,maxSize);
+        }
+        if(!_file-&gt;read32(len,buffer)) return false;
+        return true;
+       
+}
+/**
+
+    \fn getPacketInfo
+    \brief       Retrieve info about the packet we just met.It is assumed that parser is just after the packet startcode
+
+*/
+
+uint8_t psPacket::getPacketInfo(uint8_t stream,uint8_t *substream,uint32_t *olen,uint64_t *opts,uint64_t *odts)
+{
+
+//uint32_t un ,deux;
+uint64_t size=0;
+uint8_t c,d;
+uint8_t align=0;
+                        
+                *substream=0xff;
+                *opts=ADM_NO_PTS;
+                *odts=ADM_NO_PTS;
+                
+                                        
+                size=_file-&gt;read16i();
+                if((stream==PADDING_CODE) || 
+                	 (stream==PRIVATE_STREAM_2)
+                        ||(stream==SYSTEM_START_CODE) //?
+                        ) // special case, no header
+                        {
+                                *olen=size;      
+                                return 1;
+                        }
+                                
+                        //      remove padding if any                                           
+        
+                while((c=_file-&gt;read8i()) == 0xff) 
+                {
+                        size--;
+                }
+//----------------------------------------------------------------------------
+//-------------------------------MPEG-2 PES packet style----------------------
+//----------------------------------------------------------------------------
+                if(((c&amp;0xC0)==0x80))
+                {
+                        uint32_t ptsdts,len;
+                        //printf(&quot;\n mpeg2 type \n&quot;);
+                        //_muxTypeMpeg2=1;
+                        // c= copyright and stuff       
+                        //printf(&quot; %x align\n&quot;,c);      
+                        if(c &amp; 4) align=1;      
+                        c=_file-&gt;read8i();     // PTS/DTS
+                        //printf(&quot;%x ptsdts\n&quot;,c
+                        ptsdts=c&gt;&gt;6;
+                        // header len
+                        len=_file-&gt;read8i();
+                        size-=3;  
+
+                        switch(ptsdts)
+                        {
+                                case 2: // PTS=1 DTS=0
+                                        if(len&gt;=5)
+                                        {
+                                                uint64_t pts1,pts2,pts0;
+                                                //      printf(&quot;\n PTS10\n&quot;);
+                                                        pts0=_file-&gt;read8i();  
+                                                        pts1=_file-&gt;read16i(); 
+                                                        pts2=_file-&gt;read16i();                 
+                                                        len-=5;
+                                                        size-=5;
+                                                        *opts=(pts1&gt;&gt;1)&lt;&lt;15;
+                                                        *opts+=pts2&gt;&gt;1;
+                                                        *opts+=(((pts0&amp;6)&gt;&gt;1)&lt;&lt;30);
+                                        }
+                                        break;
+                                case 3: // PTS=1 DTS=1
+                                                #define PTS11_ADV 10 // nut monkey
+                                                if(len&gt;=PTS11_ADV)
+                                                {
+                                                        uint32_t skip=PTS11_ADV;
+                                                        uint64_t pts1,pts2,dts,pts0;
+                                                                //      printf(&quot;\n PTS10\n&quot;);
+                                                                pts0=_file-&gt;read8i();  
+                                                                pts1=_file-&gt;read16i(); 
+                                                                pts2=_file-&gt;read16i(); 
+                                                                                        
+                                                                *opts=(pts1&gt;&gt;1)&lt;&lt;15;
+                                                                *opts+=pts2&gt;&gt;1;
+                                                                *opts+=(((pts0&amp;6)&gt;&gt;1)&lt;&lt;30);
+                                                                pts0=_file-&gt;read8i();  
+                                                                pts1=_file-&gt;read16i(); 
+                                                                pts2=_file-&gt;read16i();                 
+                                                                dts=(pts1&gt;&gt;1)&lt;&lt;15;
+                                                                dts+=pts2&gt;&gt;1;
+                                                                dts+=(((pts0&amp;6)&gt;&gt;1)&lt;&lt;30);
+                                                                len-=skip;
+                                                                size-=skip;
+                                                                *odts=dts;
+                                                                        //printf(&quot;DTS: %lx\n&quot;,dts);                
+                                                   }
+                                                   break;               
+                                case 1:
+                                                return 0;//ADM_assert(0); // forbidden !
+                                                break;
+                                case 0: 
+                                                // printf(&quot;\n PTS00\n&quot;);
+                                                break; // no pts nor dts
+                                                                                
+                                                            
+                        }  
+// Extension bit        
+// &gt;stealthdave&lt;                                
+
+                        // Skip remaining headers if any
+                        if(len) 
+                        {
+                                _file-&gt;forward(len);
+                                size=size-len;
+                        }
+                                
+                if(stream==PRIVATE_STREAM_1)
+                {
+                        if(size&gt;5)
+                        {
+                        // read sub id
+                               *substream=_file-&gt;read8i();
+  //                    printf(&quot;\n Subid : %x&quot;,*subid);
+                                switch(*substream)
+                                {
+                                // DTS
+                                        case 0x88:case 0x89:case 0x8A:case 0x8B:
+                                        
+                                                *substream=*substream-0x48;
+                                                break;
+
+                                //AC3
+                                        case 0x80:case 0x81:case 0x82:case 0x83:
+                                        case 0x84:case 0x85:case 0x86:case 0x87:
+                                                *substream=*substream-0x80;
+                                                break;
+                                // PCM
+                                        case 0xA0:case 0xA1:case 0xa2:case 0xa3:
+                                        case 0xA4:case 0xA5:case 0xa6:case 0xa7:
+                                                // we have an additionnal header
+                                                // of 3 bytes
+                                                _file-&gt;forward(3);
+                                                size-=3;
+                                                break;
+                                // Subs
+                                case 0x20:case 0x21:case 0x22:case 0x23:
+                                case 0x24:case 0x25:case 0x26:case 0x27:
+                                                break;
+                             
+                                default:
+                                                doNoComplainAnyMore++;
+                                                if(doNoComplainAnyMore&lt;10)
+                                                    printf(&quot;[DmxPS]Unkown substream %x\n&quot;,*substream);
+                                                *substream=0xff;
+                                }
+                                // skip audio header (if not sub)
+                                if(*substream&gt;0x26 || *substream&lt;0x20)
+                                {
+                                        _file-&gt;forward(3);
+                                        size-=3;
+                                }
+                                size--;
+                        }
+                }
+               //    printf(&quot; pid %x size : %x len %x\n&quot;,sid,size,len);
+                *olen=size;
+                return 1;
+        }
+//----------------------------------------------------------------------------------------------                
+//-------------------------------MPEG-1 PES packet style----------------------                                  
+//----------------------------------------------------------------------------------------------                                        
+           if(0) //_muxTypeMpeg2)
+                {
+                        printf(&quot;[DmxPS]*** packet type 1 inside type 2 ?????*****\n&quot;);
+                        return 0; // mmmm                       
+                }
+          // now look at  STD buffer size if present
+          // 01xxxxxxxxx
+          if ((c&gt;&gt;6) == 1) 
+          {       // 01
+                        size-=2;
+                        _file-&gt;read8i();                       // skip one byte
+                        c=_file-&gt;read8i();   // then another
+           }                       
+           // PTS/DTS
+           switch(c&gt;&gt;4)
+           {
+                case 2:
+                {
+                        // 0010 xxxx PTS only
+                        uint64_t pts1,pts2,pts0;
+                                        size -= 4;
+                                        pts0=(c&gt;&gt;1) &amp;7;
+                                        pts1=_file-&gt;read16i()&gt;&gt;1;
+                                        pts2=_file-&gt;read16i()&gt;&gt;1;
+                                        *opts=pts2+(pts1&lt;&lt;15)+(pts0&lt;&lt;30);
+                                        break;
+                  }
+                  case 3:
+                  {               // 0011 xxxx
+                        uint64_t pts1,pts2,pts0;
+                                        size -= 9;
+                                                                        
+                                        pts0=(c&gt;&gt;1) &amp;7;
+                                        pts1=_file-&gt;read16i()&gt;&gt;1;
+                                        pts2=_file-&gt;read16i()&gt;&gt;1;
+                                        *opts=pts2+(pts1&lt;&lt;15)+(pts0&lt;&lt;30);
+                                        _file-&gt;forward(5);
+                   }                                                               
+                   break;
+                   
+                case 1:
+                        // 0001 xxx             
+                        // PTSDTS=01 not allowed                        
+                                return 0;
+                                break; 
+                }
+                                                                
+
+                if(!align)      
+                        size--;         
+        *olen=size;
+        return 1;
+}
+//************************************************************************************
+
+#define ADM_PACKET_LINEAR 10*1024
+/**
+    \fn psPacket
+*/
+psPacketLinear::psPacketLinear(uint8_t pid) : psPacket()
+{
+    oldStartAt=startAt=0xfffffff;
+    oldBufferLen=bufferLen=0;
+    bufferIndex=0;
+    myPid=pid;
+    eof=false;
+}
+/**
+    \fn ~psPacket
+*/
+psPacketLinear::~psPacketLinear() 
+{
+}
+/**
+    \fn refill
+*/
+bool psPacketLinear::refill(void) 
+{
+// In case a startcade spawns across 2 packets
+// we have to keep track of the old one
+        oldBufferDts=bufferDts;
+        oldBufferPts=bufferPts;
+        oldStartAt=startAt;
+        oldBufferLen=bufferLen;
+        if( false== getPacketOfType(myPid,ADM_PACKET_LINEAR, &amp;bufferLen,&amp;bufferPts,&amp;bufferDts,buffer,&amp;startAt)) return false;
+        bufferIndex=0;
+        return true;
+}
+/**
+    \fn readi8
+*/
+uint8_t psPacketLinear::readi8(void)
+{
+    consumed++;
+    if(bufferIndex&lt;bufferLen)
+    {
+        return buffer[bufferIndex++];
+    }
+    if(false==refill()) 
+    {
+        eof=1;
+        return 0;
+    }
+    ADM_assert(bufferLen);
+    bufferIndex=1;
+    return buffer[0];
+    
+}
+/**
+    \fn readi16
+*/
+uint16_t psPacketLinear::readi16(void)
+{
+    if(bufferIndex+1&lt;bufferLen)
+    {
+        uint16_t v=(buffer[bufferIndex]&lt;&lt;8)+buffer[bufferIndex+1];;
+        bufferIndex+=2;
+        consumed+=2;
+        return v;
+    }
+    return (readi8()&lt;&lt;8)+readi8();
+}
+/**
+    \fn readi32
+*/
+uint32_t psPacketLinear::readi32(void)
+{
+    if(bufferIndex+3&lt;bufferLen)
+    {
+        uint8_t *p=buffer+bufferIndex;
+        uint32_t v=(p[0]&lt;&lt;24)+(p[1]&lt;&lt;16)+(p[2]&lt;&lt;8)+p[3];
+        bufferIndex+=4;
+        consumed+=4;
+        return v;
+    }
+    return (readi16()&lt;&lt;16)+readi16();
+}
+/**
+    \fn forward
+*/
+bool psPacketLinear::forward(uint32_t v)
+{
+    if(bufferIndex+v-1&lt;bufferLen)
+    {
+        bufferIndex+=v;
+        consumed+=v;
+        return true;
+    }
+    if(!refill()) return false;
+    uint32_t delta=bufferLen-bufferIndex;
+    v-=delta;
+    consumed+=delta;
+    return forward(v);
+}
+
+/**
+    \fn bool    read(uint32_t len, uint8_t *buffer);
+    \brief
+*/
+bool    psPacketLinear::read(uint32_t len, uint8_t *out)
+{
+    // Enough already ?
+    while(len)
+    {
+        uint32_t avail=bufferLen-bufferIndex;
+        uint32_t chunk=avail;
+        if(chunk&gt;len) chunk=len;
+#if 0
+        printf(&quot;len:%ld avail:%ld chunk %ld index:%d size:%d\n&quot;,
+                len,avail,chunk,bufferIndex,bufferLen);
+#endif
+        memcpy(out,buffer+bufferIndex,chunk);
+        bufferIndex+=chunk;
+        len-=chunk;
+        out+=chunk;
+        consumed+=chunk;
+        if(bufferIndex==bufferLen)
+        {
+            //printf(&quot;Refill\n&quot;);
+            if(false==refill()) return false;
+        }
+    }
+    return true;
+}
+/**
+        \fn getInfo
+        \brief Returns info about the current (or previous if it spawns) packet.
+            It is expected that the caller will do -4 to the index to get the start of the 
+            startCode
+*/
+bool    psPacketLinear::getInfo(psPacketInfo *info)
+{
+    if(bufferIndex&lt;4)
+    {
+        info-&gt;startAt=this-&gt;oldStartAt;
+        info-&gt;offset=oldBufferLen+bufferIndex;
+        info-&gt;pts=oldBufferPts;
+        info-&gt;dts=oldBufferDts;
+
+    }else
+    {
+        info-&gt;startAt=this-&gt;startAt;
+        info-&gt;offset=bufferIndex;
+        info-&gt;pts=bufferPts;
+        info-&gt;dts=bufferDts;
+    }
+    return true;
+
+};
+/**
+    \fn seek
+    \brief Async jump
+*/
+bool    psPacketLinear::seek(uint64_t packetStart, uint32_t offset)
+{
+    if(!_file-&gt;setpos(packetStart))
+    {
+        printf(&quot;[psPacket] Cannot seek to %&quot;LLX&quot;\n&quot;,packetStart);
+        return 0;
+    }
+    refill();
+    ADM_assert(offset&lt;bufferLen);
+    bufferIndex=offset;
+    
+    return true;
+}
+/**
+    \fn getConsumed
+    \brief returns the # of bytes consumed since the last call
+*/
+uint32_t psPacketLinear::getConsumed(void)
+{
+    uint32_t c=consumed;
+    consumed=0;
+    return c;
+}
+/**
+    \fn changePid
+    \brief change the pid of the stream we read (used when probing all tracks)
+*/
+bool    psPacketLinear::changePid(uint32_t pid) 
+{
+    myPid=(pid&amp;0xff);
+    bufferLen=bufferIndex=0;
+    return true;
+}
+/* ********************************************************* */
+/**
+    \fn psPacketLinearTracker
+*/
+ psPacketLinearTracker::psPacketLinearTracker(uint8_t pid)  : psPacketLinear(pid)
+{
+   
+}
+/**
+    \fn ~psPacketLinearTracker
+*/
+psPacketLinearTracker::~psPacketLinearTracker()
+{
+
+    resetStats();
+}
+/**
+        \fn getStat
+*/
+packetStats    *psPacketLinearTracker::getStat(int index)
+{   
+    if(index&lt;0 || index&gt;=256) ADM_assert(0);
+    return stats+index;
+}
+/**
+    \fn getPacketgetPacketOfType
+    \brief Keep track of all the packets we have seen so far.
+    Usefull to detect the streams present and to look up the PTS/DTS of audio streams for the audio part of the index
+*/
+bool           psPacketLinearTracker::getPacketOfType(uint8_t pid,uint32_t maxSize, uint32_t *packetSize,uint64_t *pts,uint64_t *dts,uint8_t *buffer,uint64_t *startAt)
+{
+ bool xit=false;
+    uint8_t tmppid;
+    while(1)
+    {
+        if(true!=getPacket(maxSize,&amp;tmppid,packetSize,pts,dts,buffer,startAt))
+                return false;
+        else
+        {
+                // Update 
+                ADM_assert(tmppid&lt;0x100);
+                packetStats *p=stats+tmppid;
+                uint64_t ts=*pts;
+                if(ts==ADM_NO_PTS) ts=*dts;
+                if(ts!=ADM_NO_PTS)
+                {
+                    p-&gt;startCount=p-&gt;count;
+                    p-&gt;startAt=*startAt;
+                    p-&gt;startSize=p-&gt;size;
+                    p-&gt;startDts=ts;
+                }
+                p-&gt;count++;
+                p-&gt;size+=*packetSize;
+                if(tmppid==pid) return true;
+        }
+    }
+    return false;
+}
+/**
+    \fn resetStats
+*/
+bool           psPacketLinearTracker::resetStats(void)
+{
+    memset(stats,0,sizeof(stats));
+    for(int i=0;i&lt;256;i++)
+    {
+        packetStats *p=stats+i;
+        p-&gt;startDts=ADM_NO_PTS;
+    }
+}
+//EOF

Deleted: branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxerMpeg/src/dmx_demuxer.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxerMpeg/src/dmx_demuxer.cpp	2009-02-10 16:00:26 UTC (rev 4582)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxerMpeg/src/dmx_demuxer.cpp	2009-02-11 06:27:26 UTC (rev 4583)
@@ -1,30 +0,0 @@
-/***************************************************************************
-                         Base demuxer class
-    
-    copyright            : (C) 2002 by mean
-    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-#include &quot;ADM_default.h&quot;
-#include &lt;string.h&gt;
-#include &lt;math.h&gt;
-
-#include &quot;dmx_demuxer.h&quot;
-
-dmx_demuxer::dmx_demuxer(void)
-{
-        _size=0;
-        _lastErr=0;
-}
-dmx_demuxer::~dmx_demuxer(void)
-{
-}

Deleted: branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxerMpeg/src/dmx_demuxerES.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxerMpeg/src/dmx_demuxerES.cpp	2009-02-10 16:00:26 UTC (rev 4582)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxerMpeg/src/dmx_demuxerES.cpp	2009-02-11 06:27:26 UTC (rev 4583)
@@ -1,160 +0,0 @@
-/***************************************************************************
-                          Base class for Mpeg Demuxer
-                             -------------------
-                
-    copyright            : (C) 2005 by mean
-    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-#include &lt;string.h&gt;
-#include &lt;math.h&gt;
-
-#include &quot;ADM_default.h&quot;
-
-#include &quot;dmx_demuxerEs.h&quot;
- 
-dmx_demuxerES::dmx_demuxerES(void)
-{
-        consumed=0;
-        parser=new fileParser();
-        stampAbs=0;
-}
-dmx_demuxerES::~dmx_demuxerES()
-{
-        if(parser) delete parser;
-        parser=NULL;
-}
-uint8_t dmx_demuxerES::open(const char *name)
-{
-FP_TYPE fp=FP_DONT_APPEND;
-        if(! parser-&gt;open(name,&amp;fp)) return 0;
-        _size=parser-&gt;getSize();
-        return 1;
-}
-uint8_t dmx_demuxerES::forward(uint32_t f)
-{
-        consumed+=f;
-        return parser-&gt;forward(f);
-}
-uint8_t  dmx_demuxerES::stamp(void)
-{
-        consumed=0;
-        parser-&gt;getpos(&amp;stampAbs);
-        stampAbs-=4;
-}
-uint64_t dmx_demuxerES::elapsed(void)
-{
-        return consumed;        
-}
-uint8_t  dmx_demuxerES::getPos( uint64_t *abs,uint64_t *rel)
-{
-        *rel=0;
-        parser-&gt;getpos(abs);       
-        return 1;
-}
-uint8_t dmx_demuxerES::setPos( uint64_t abs,uint64_t  rel)
-{
-               return parser-&gt;setpos(abs);
-}
-/*
-        Sync on mpeg sync word, returns the sync point in abs/r
-*/
-uint8_t         dmx_demuxerES::sync( uint8_t *stream,uint64_t *abs,uint64_t *r,uint64_t *pts,uint64_t *dts)
-{
-uint32_t val,hnt;
-         *r=0;
-                *pts=ADM_NO_PTS;
-                *dts=ADM_NO_PTS;
-
-                val=0;
-                hnt=0;                  
-                        
-                // preload
-                hnt=(read8i()&lt;&lt;16) + (read8i()&lt;&lt;8) +read8i();
-                if(_lastErr)
-                {
-                        _lastErr=0;
-                        printf(&quot;\n io error , aborting sync\n&quot;);
-                        return 0;       
-                }
-                
-                while((hnt!=0x00001))
-                {
-                                        
-                        hnt&lt;&lt;=8;
-                        val=read8i();                                   
-                        hnt+=val;
-                        hnt&amp;=0xffffff;  
-                                        
-                        if(_lastErr)
-                        {
-                             _lastErr=0;
-                            printf(&quot;\n io error , aborting sync\n&quot;);
-                            return 0;
-                         }
-                                                                        
-                }
-                                
-                *stream=read8i();
-                parser-&gt;getpos(abs);
-                *abs-=4;
-                return 1;
-}
-
-/**
-          \fn syncH264
-          \brief search h264 startcode 00 00 00 01
-*/
-uint8_t         dmx_demuxerES::syncH264( uint8_t *stream,uint64_t *abs,uint64_t *r,uint64_t *pts,uint64_t *dts)
-{
-uint32_t val,hnt;
-         *r=0;
-                *pts=ADM_NO_PTS;
-                *dts=ADM_NO_PTS;
-
-                val=0;
-                hnt=0;                  
-                        
-                // preload
-                hnt=(read8i()&lt;&lt;24)+(read8i()&lt;&lt;16) + (read8i()&lt;&lt;8) +read8i();
-                if(_lastErr)
-                {
-                        _lastErr=0;
-                        printf(&quot;\n io error , aborting sync\n&quot;);
-                        return 0;       
-                }
-                
-                while((hnt!=1))
-                {
-                                        
-                        hnt&lt;&lt;=8;
-                        val=read8i();                                   
-                        hnt+=val;
-                        
-                                        
-                        if(_lastErr)
-                        {
-                             _lastErr=0;
-                            printf(&quot;\n io error , aborting sync\n&quot;);
-                            return 0;
-                         }
-                                                                        
-                }
-                                
-                *stream=read8i();
-                parser-&gt;getpos(abs);
-                *abs-=5;
-                return 1;
-}
-
-          
-          

Deleted: branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxerMpeg/src/dmx_demuxerMSDVR.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxerMpeg/src/dmx_demuxerMSDVR.cpp	2009-02-10 16:00:26 UTC (rev 4582)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxerMpeg/src/dmx_demuxerMSDVR.cpp	2009-02-11 06:27:26 UTC (rev 4583)
@@ -1,418 +0,0 @@
-/***************************************************************************
-       MSDVR aka mpeg ES in asf file
-       
-    copyright            : (C) 2006 by mean
-    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#if 0
-#include &lt;string.h&gt;
-#include &lt;math.h&gt;
-
-#include &quot;ADM_default.h&quot;
-
-#include &quot;dmx_demuxerMSDVR.h&quot;
-
-#include &quot;../ADM_asf/ADM_asfPacket.h&quot;
-#include &quot;../ADM_asf/ADM_asf.h&quot;
-
-#define PARSER ((asfPacket *)aParser)
-// ******************************************************
-uint8_t         dmx_demuxerMSDVR::changePid(uint32_t newpid,uint32_t newpes)
-{
-  myPid=newpid ;
-  myPes=newpes;
-  _pesBufferStart=0;  // Big value so that we read
-  _pesBufferLen=0;
-  _pesBufferIndex=0;
-}
-// ******************************************************
-dmx_demuxerMSDVR::dmx_demuxerMSDVR(uint32_t nb,MPEG_TRACK *tracks,uint32_t multi)
-{
-  consumed=0;
-  aParser=NULL;
-  stampAbs=0;
-  _pesBuffer=new uint8_t [MAX_MSDVR_BUFFER];
-
-  memset(seen,0,sizeof(seen));
-
-  _pesBufferStart=0;  // Big value so that we read
-  _pesBufferLen=0;
-  _pesBufferIndex=0;
-  ADM_assert(nb&gt;0);
-  tracked=NULL;
-
-  nbTracked=nb;
-  for(int i=0;i&lt;256;i++) trackPTS[i]=ADM_NO_PTS;
-  myPid=tracks[0].pid;
-  
-  if(nb!=256)     // Only pick one track as main, and a few as informative
-  {
-                
-    memset(mask,0,256);
-    tracked=new uint8_t[nbTracked];
-    for(int i=1;i&lt;nb;i++)
-    {
-      mask[tracks[i].pid&amp;0xff]=1;
-      tracked[i]=tracks[i].pid&amp;0xff;
-    }                
-                
-  }else
-  {
-    memset(mask,1,256); // take all tracks
-  }
-
-  _probeSize=0; 
-  memset(seen,0,255*sizeof(uint64_t));     
-  printf(&quot;Creating mpeg PS demuxer  main Pid: %X \n&quot;,myPid);
-  _multi=multi;
-  _fd=NULL;
-  _dataStart=0;
-}
-// ******************************************************
-dmx_demuxerMSDVR::~dmx_demuxerMSDVR()
-{
-  if(aParser)
-  {
-    asfPacket *p=PARSER;
-    delete p;
-    aParser=NULL;
-  }
-  if(_fd)
-  {
-    fclose(_fd);
-    _fd=NULL; 
-  }
-  if(_pesBuffer) delete [] _pesBuffer;
-  _pesBuffer=NULL;
-  if(tracked) delete [] tracked;
-  tracked=NULL;
-}
-/*
-        Get stats about the PES ids tracked in tracked order
-        if nbTracked=256 it means tracks all possible PES id
-        The 0 rank is video
-*/
-// ******************************************************
-uint8_t       dmx_demuxerMSDVR::getStats(uint64_t *oseen)
-{
-  if(nbTracked!=256)
-  {
-    oseen[0]=0;
-    for(int i=1;i&lt;nbTracked;i++)
-    {
-      oseen[i]=seen[tracked[i]];
-    }
-  }
-  else
-  {
-    for(int i=0;i&lt;nbTracked;i++)
-    {
-      oseen[i]=seen[i];
-    }
-  }
-  return 1;
-}
-// ******************************************************
-uint8_t         dmx_demuxerMSDVR::getAllPTS(uint64_t *stat)
-{
-  if(nbTracked!=256)
-  {
-    stat[0]=0;
-    for(int i=1;i&lt;nbTracked;i++)
-    {
-      stat[i]=trackPTS[tracked[i]];
-    }
-  }
-  else
-  {
-    for(int i=0;i&lt;nbTracked;i++)
-    {
-      stat[i]=trackPTS[i];
-    }
-  }
-  return 1;
-}
-// ******************************************************
-uint8_t dmx_demuxerMSDVR::setProbeSize(uint32_t sz)
-{
-  _probeSize=sz;
-  return 1;
-}
-// ******************************************************
-uint8_t dmx_demuxerMSDVR::forward(uint32_t f)
-{
-  uint32_t left;        
-  if(_pesBufferIndex+f&lt;=_pesBufferLen) 
-  {
-    _pesBufferIndex+=f;
-    consumed+=f;
-    return 1;
-  }
-        // else read another packet
-  left=_pesBufferLen-_pesBufferIndex;
-  f-=left;
-  consumed+=left;
-  if(!refill()) return 0;
-  return forward(f);
-}
-// ******************************************************
-uint8_t  dmx_demuxerMSDVR::stamp(void)
-{
-  consumed=0;        
-}
-// ******************************************************
-uint64_t dmx_demuxerMSDVR::elapsed(void)
-{
-  return consumed;        
-}
-// ******************************************************
-uint8_t  dmx_demuxerMSDVR::getPos( uint64_t *abs,uint64_t *rel)
-{
-  *rel=_pesBufferIndex;
-  *abs=_pesBufferStart;       
-  return 1;
-}
-// ******************************************************
-uint64_t dmx_demuxerMSDVR::getSize( void) 
-{
-  return (uint64_t)_nbPackets; 
-}
-// ******************************************************
-uint8_t dmx_demuxerMSDVR::setPos( uint64_t abs,uint64_t  rel)
-{
-				// Need to move ?
-  if(abs==_pesBufferStart &amp;&amp; _pesBufferLen)
-  {
-    if(_pesBufferLen&lt;rel)
-    {
-      printf(&quot;Asked setpos to go %lu whereas %lu is max\n&quot;,
-             rel,_pesBufferLen);
-      ADM_assert(rel&lt;_pesBufferLen);
-    }
-    _pesBufferIndex=rel;
-    return 1;
-  }
-  // Seek...
-  if(!PARSER-&gt;goToPacket(abs))
-  {
-    printf(&quot;[MSDVR] Seek to %u failed\n&quot;,abs); 
-  }
-  _pesBufferStart=abs;
-  PARSER-&gt;purge(); // just in case
-  if(!refill())
-  {
-    printf(&quot;DMX_PS: refill failed\n&quot;);
-    return 0;
-  }
-                
-  if(rel&gt;_pesBufferLen)
-  {
-    printf(&quot;Set pos failed : asked rel:%lu max: %lu, absPos:%llu absPosafterRefill:%llu\n&quot;,
-           rel,_pesBufferLen,abs,_pesBufferStart);
-    ADM_assert(rel&lt;_pesBufferLen);                        
-  }
-
-  _pesBufferIndex=rel;
-  return 1;
-               
-}
-/*
-        Sync on mpeg sync word, returns the sync point in abs/r
-*/
-
-
-// ******************************************************
-uint32_t         dmx_demuxerMSDVR::read(uint8_t *w,uint32_t len)
-{
-  uint32_t mx;
-                // enough in buffer ?
-  if(_pesBufferIndex+len&lt;=_pesBufferLen)
-  {
-    memcpy(w,_pesBuffer+_pesBufferIndex,len);
-    _pesBufferIndex+=len;
-    consumed+=len;
-    return len;
-  }
-                // flush
-  mx=_pesBufferLen-_pesBufferIndex;
-  if(mx)
-  {
-    memcpy(w,_pesBuffer+_pesBufferIndex,mx);
-    _pesBufferIndex+=mx;
-    consumed+=mx;
-    w+=mx;
-    len-=mx;
-  }
-  if(!refill())
-  {
-    printf(&quot;Refill failed at %d  \n&quot;,_pesBufferStart);
-    _lastErr=1;
-    return 0;
-  }
-  return mx+read(w,len);
-}
-// ******************************************************
-uint8_t         dmx_demuxerMSDVR::sync( uint8_t *stream,uint64_t *abs,uint64_t *r,uint64_t *pts,uint64_t *dts)
-{
-  uint32_t val,hnt;
-  *r=0;
-
-  val=0;
-  hnt=0;
-
-                // preload
-  hnt=read32i();
-  if(_lastErr)
-  {
-    _lastErr=0;
-    printf(&quot;\n io error , aborting sync 1\n&quot;);
-    return 0;       
-  }
-  val=hnt&amp;0xff;
-  while(((hnt&amp;0xffffff00)!=0x100))
-  {
-
-    hnt&lt;&lt;=8;
-    val=read8i();
-    hnt+=val;
-    if(_lastErr)
-    {
-      _lastErr=0;
-      printf(&quot;\n io error , aborting sync 2\n&quot;);
-      return 0;
-    }
-
-  }
-
-  *stream=val;
-                // Case 1 : assume we are still in the same packet
-  if(_pesBufferIndex&gt;=4)
-  {
-    *abs=_pesBufferStart;
-    *r=_pesBufferIndex-4;
-    *pts=_pesPTS;
-    *dts=_pesDTS;
-  }
-  else
-  {       // pick what is needed from oldPesStart etc...
-                        // since the beginning in the previous packet
-    uint32_t left=4-_pesBufferIndex;
-    left=_oldPesLen-left;
-#if 0
-                                 printf(&quot;Next packet : %I64X Len :%lu, using previous packet %I64X len:%u as pos=%lu\n&quot;,
-                                 		_pesBufferStart,_pesBufferLen,_oldPesStart,_oldPesLen,_pesBufferIndex);
-#endif
-                                 if(left&gt;_oldPesLen)
-{
-  printf(&quot;Need %lu bytes from previous packet, which len is %lu\n&quot;,left,_oldPesLen);
-  ADM_assert(0);
-}
-                                *abs=_oldPesStart;
-                                *r=left;
-                                *pts=_oldPTS;
-                                *dts=_oldDTS;
-  }
-  return 1;
-}
-// ******************************************************
-
-uint8_t dmx_demuxerMSDVR::refill(void)
-{
-  // read one packet
-                
-          _pesDTS=ADM_NO_PTS;
-          _pesPTS=ADM_NO_PTS;
-          _pesBufferStart=0;
-          _pesBufferLen=0;
-          _pesBufferIndex=0;
-          while(!_pesBufferLen)
-          {
-              if(!PARSER-&gt;nextPacket(0xff))
-              {
-                  printf(&quot;[MSDVR] Packet Error\n&quot;);
-                  return 0; 
-              }
-          
-              PARSER-&gt;skipPacket();
-              // Now fill buffer
-              if(demuxerQueue.isEmpty()) continue;
-              while(!demuxerQueue.isEmpty())
-              {
-                asfBit *bit;
-                ADM_assert(demuxerQueue.pop((void**)&amp;bit));
-                if(bit-&gt;stream!=myPid)
-                {
-                  if(bit-&gt;stream&lt;0x100 &amp;&amp; mask[bit-&gt;stream &amp;0xff])
-                  {
-                    seen[bit-&gt;stream]+=bit-&gt;len;
-                  }
-		  if (bit-&gt;data) delete[] bit-&gt;data;
-                  delete bit;
-                }else
-                {
-                  _pesBufferStart=bit-&gt;packet;
-                  memcpy(&amp;(_pesBuffer[_pesBufferLen]),bit-&gt;data,bit-&gt;len);
-                  _pesBufferLen+=bit-&gt;len;
-                  if (bit-&gt;data) delete[] bit-&gt;data;
-                  delete bit;
-                }
-              }
-              return 1;
-          }
-          return 0;
-}
-/***********************************************/
-uint8_t dmx_demuxerMSDVR::open(const char *name)
-{
-  int r=5;
-  const chunky *id=NULL;
-  //
-  _fd=fopen(name,&quot;rb&quot;);
-  if(!_fd)
-  {
-    printf(&quot;Demuxer MSDVR open failed\n&quot;);
-    return 0; 
-  }
-  // Get the data chunk and ignore others
-  asfChunk h(_fd);
-
-  printf(&quot;[MSDVR] Searching data\n&quot;);
-  while(r--)
-  {
-    h.nextChunk();    // Skip headers
-    id=h.chunkId();
-    h.dump();
-    if(id-&gt;id==ADM_CHUNK_DATA_CHUNK) break;
-    h.skipChunk();
-  }
-  if(id-&gt;id!=ADM_CHUNK_DATA_CHUNK)
-  {
-    printf(&quot;[MSDVR] Cannot find data chunk\n&quot;);
-    return 0; 
-  }
-  h.read32();
-  h.read32();
-  h.read32();
-  h.read32();
-  _nbPackets=(uint32_t) h.read64();
-  h.read16();
-  //********** Ready
-  _dataStart=ftello(_fd);
-  asfPacket *packet;
-  packet=new asfPacket(_fd,_nbPackets,0x2000,&amp;demuxerQueue,_dataStart);
-  aParser=(void *)packet;
-  printf(&quot;[MSDVR] Opened ok\n&quot;);
-  return 1;
-}
-#endif
-// ******************************************************
-// EOF

Deleted: branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxerMpeg/src/dmx_demuxerPS.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxerMpeg/src/dmx_demuxerPS.cpp	2009-02-10 16:00:26 UTC (rev 4582)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxerMpeg/src/dmx_demuxerPS.cpp	2009-02-11 06:27:26 UTC (rev 4583)
@@ -1,723 +0,0 @@
-/***************************************************************************
-                          PS demuxer
-                             -------------------
-
-    copyright            : (C) 2005 by mean
-    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-#include &lt;string.h&gt;
-#include &lt;math.h&gt;
-
-#include &quot;ADM_default.h&quot;
-
-#include &quot;dmx_demuxerPS.h&quot;
-uint8_t         dmx_demuxerPS::changePid(uint32_t newpid,uint32_t newpes)
-{
-          myPid=newpes &amp; 0xff;
-          if(myPid&lt;9 || (myPid&gt;=0xA0&amp;&amp;myPid&lt;=0xA9) || (myPid&gt;=0x20 &amp;&amp; myPid&lt;0x27) ||(myPid&gt;=0x40 &amp;&amp; myPid&lt;=0x49) ) myPid|=0xff00;
-        _pesBufferStart=0;  // Big value so that we read
-        _pesBufferLen=0;
-        _pesBufferIndex=0;
-}
-dmx_demuxerPS::dmx_demuxerPS(uint32_t nb,MPEG_TRACK *tracks,uint32_t multi)
-{
-        consumed=0;
-        parser=new fileParser();
-        stampAbs=0;
-        _pesBuffer=new uint8_t [MAX_PES_BUFFER];
-
-        memset(seen,0,sizeof(seen));
-
-        _pesBufferStart=0;  // Big value so that we read
-        _pesBufferLen=0;
-        _pesBufferIndex=0;
-        ADM_assert(nb&gt;0);
-        tracked=NULL;
-
-        nbTracked=nb;
-        for(int i=0;i&lt;256;i++) trackPTS[i]=ADM_NO_PTS;
-        myPid=tracks[0].pes;
-
-        if(nb!=256)     // Only pick one track as main, and a few as informative
-        {
-
-                memset(mask,0,256);
-                tracked=new uint8_t[nbTracked];
-                for(int i=1;i&lt;nb;i++)
-                {
-                        mask[tracks[i].pes&amp;0xff]=1;
-                        tracked[i]=tracks[i].pes&amp;0xff;
-                }
-
-        }else
-        {
-                memset(mask,1,256); // take all tracks
-        }
-
-        if(myPid&lt;9 || (myPid&gt;0xA0&amp;&amp;myPid&lt;0xA9) || (myPid&gt;=0x20 &amp;&amp; myPid&lt;0x27)) myPid|=0xff00;
-
-
-
-       	_probeSize=0;
-       	memset(seen,0,255*sizeof(uint64_t));
-        printf(&quot;Creating mpeg PS demuxer  main Pid: %X \n&quot;,myPid);
-        _multi=multi;
-}
-dmx_demuxerPS::~dmx_demuxerPS()
-{
-        if(parser) delete parser;
-        parser=NULL;
-        if(_pesBuffer) delete [] _pesBuffer;
-        _pesBuffer=NULL;
-        if(tracked) delete [] tracked;
-        tracked=NULL;
-}
-/*
-        Get stats about the PES ids tracked in tracked order
-        if nbTracked=256 it means tracks all possible PES id
-        The 0 rank is video
-*/
-uint8_t       dmx_demuxerPS::getStats(uint64_t *oseen)
-{
-        if(nbTracked!=256)
-        {
-                oseen[0]=0;
-                for(int i=1;i&lt;nbTracked;i++)
-                {
-                        oseen[i]=seen[tracked[i]];
-                }
-        }
-        else
-        {
-                 for(int i=0;i&lt;nbTracked;i++)
-                {
-                        oseen[i]=seen[i];
-                }
-        }
-        return 1;
-}
-uint8_t         dmx_demuxerPS::getAllPTS(uint64_t *stat)
-{
-        if(nbTracked!=256)
-        {
-                stat[0]=0;
-                for(int i=1;i&lt;nbTracked;i++)
-                {
-                        stat[i]=trackPTS[tracked[i]];
-                }
-        }
-        else
-        {
-                 for(int i=0;i&lt;nbTracked;i++)
-                {
-                        stat[i]=trackPTS[i];
-                }
-        }
-        return 1;
-}
-
-uint8_t dmx_demuxerPS::setProbeSize(uint32_t sz)
-{
-		_probeSize=sz;
-		return 1;
-}
-uint8_t dmx_demuxerPS::open(const char *name)
-{
-FP_TYPE fp=FP_DONT_APPEND;
-        if(_multi) fp=FP_APPEND;
-        if(! parser-&gt;open(name,&amp;fp)) return 0;
-        _size=parser-&gt;getSize();
-
-        return 1;
-}
-uint8_t dmx_demuxerPS::forward(uint32_t f)
-{
-uint32_t left;
-        if(_pesBufferIndex+f&lt;=_pesBufferLen)
-        {
-                _pesBufferIndex+=f;
-                consumed+=f;
-                return 1;
-        }
-        // else read another packet
-        left=_pesBufferLen-_pesBufferIndex;
-        f-=left;
-        consumed+=left;
-        if(!refill()) return 0;
-        return forward(f);
-}
-uint8_t  dmx_demuxerPS::stamp(void)
-{
-        consumed=0;
-}
-uint64_t dmx_demuxerPS::elapsed(void)
-{
-        return consumed;
-}
-uint8_t  dmx_demuxerPS::getPos( uint64_t *abs,uint64_t *rel)
-{
-        *rel=_pesBufferIndex;
-        *abs=_pesBufferStart;
-        return 1;
-}
-uint8_t dmx_demuxerPS::setPos( uint64_t abs,uint64_t  rel)
-{
-				// Need to move ?
-				if(abs==_pesBufferStart &amp;&amp; _pesBufferLen)
-				{
-						if(_pesBufferLen&lt;rel)
-							{
-								printf(&quot;Asked setpos to go %&quot;LLU&quot; whereas %&quot;LU&quot; is max\n&quot;,
-											rel,_pesBufferLen);
-								ADM_assert(rel&lt;_pesBufferLen);
-							}
-
-					  _pesBufferIndex=rel;
-					  return 1;
-
-				}
-               if(!parser-&gt;setpos(abs))
-                {
-                        printf(&quot;DMX_PS: setPos failed\n&quot;);
-                         return 0;
-                }
-                _pesBufferStart=abs;
-                if(!refill())
-                {
-                        printf(&quot;DMX_PS: refill failed\n&quot;);
-                        return 0;
-                }
-
-                if(rel&gt;_pesBufferLen)
-                {
-                        printf(&quot;Set pos failed : asked rel:%&quot;LLU&quot; max: %&quot;LU&quot;, absPos:%&quot;LLU&quot; absPosafterRefill:%&quot;LLU&quot;\n&quot;,
-                                        rel,_pesBufferLen,abs,_pesBufferStart);
-                        ADM_assert(rel&lt;_pesBufferLen);
-                }
-
-                _pesBufferIndex=rel;
-                return 1;
-
-}
-/*
-        Sync on mpeg sync word, returns the sync point in abs/r
-*/
-
-
-
-uint32_t         dmx_demuxerPS::read(uint8_t *w,uint32_t len)
-{
-uint32_t mx;
-                // enough in buffer ?
-                if(_pesBufferIndex+len&lt;=_pesBufferLen)
-                {
-                        memcpy(w,_pesBuffer+_pesBufferIndex,len);
-                        _pesBufferIndex+=len;
-                        consumed+=len;
-                        return len;
-                }
-                // flush
-                mx=_pesBufferLen-_pesBufferIndex;
-                if(mx)
-                {
-                        memcpy(w,_pesBuffer+_pesBufferIndex,mx);
-                        _pesBufferIndex+=mx;
-                        consumed+=mx;
-                        w+=mx;
-                        len-=mx;
-                }
-                if(!refill())
-                {
-                        printf(&quot;Refill failed at %&quot;LLD&quot;  \n&quot;,_pesBufferStart);
-                        _lastErr=1;
-                         return 0;
-                }
-                return mx+read(w,len);
-}
-uint8_t         dmx_demuxerPS::sync( uint8_t *stream,uint64_t *abs,uint64_t *r,uint64_t *pts,uint64_t *dts)
-{
-uint32_t val,hnt;
-         *r=0;
-
-                val=0;
-                hnt=0;
-
-                // preload
-                hnt=read32i();
-                if(_lastErr)
-                {
-                        _lastErr=0;
-                        printf(&quot;\n io error , aborting sync 1\n&quot;);
-                        return 0;
-                }
-                val=hnt&amp;0xff;
-                while(((hnt&amp;0xffffff00)!=0x100))
-                {
-
-                        hnt&lt;&lt;=8;
-                        val=read8i();
-                        hnt+=val;
-                        if(_lastErr)
-                        {
-                             _lastErr=0;
-                            printf(&quot;\n io error , aborting sync 2\n&quot;);
-                            return 0;
-                         }
-
-                }
-
-                *stream=val;
-                // Case 1 : assume we are still in the same packet
-                if(_pesBufferIndex&gt;=4)
-                {
-                        *abs=_pesBufferStart;
-                        *r=_pesBufferIndex-4;
-                        *pts=_pesPTS;
-                        *dts=_pesDTS;
-                }
-                else
-                {       // pick what is needed from oldPesStart etc...
-                        // since the beginning in the previous packet
-                        uint32_t left=4-_pesBufferIndex;
-                                 left=_oldPesLen-left;
-#if 0
-                                 printf(&quot;Next packet : %I64X Len :%lu, using previous packet %I64X len:%u as pos=%lu\n&quot;,
-                                 		_pesBufferStart,_pesBufferLen,_oldPesStart,_oldPesLen,_pesBufferIndex);
-#endif
-                                 if(left&gt;_oldPesLen)
-                                {
-                                        printf(&quot;Need %&quot;LU&quot; bytes from previous packet, which len is %&quot;LU&quot;\n&quot;,left,_oldPesLen);
-                                        ADM_assert(0);
-                                }
-                                *abs=_oldPesStart;
-                                *r=left;
-                                *pts=_oldPTS;
-                                *dts=_oldDTS;
-                }
-                return 1;
-}
-
-//
-//      Refill the pesBuffer
-//              Only with the pid that is of interest for us
-//              Update PTS/DTS
-//              Keep track of other pes len
-//
- uint8_t         dmx_demuxerPS::getPacketInfo(uint8_t **data, uint32_t *len, uint32_t *usableLen,uint64_t *pts)
- {
-            *data=_pesBuffer;
-            *len=_pesBufferLen;
-            *usableLen=_pesBufferLen-_pesBufferIndex;
-            *pts=_pesPTS;
-            return 1;
- }
-uint8_t dmx_demuxerPS::refill(void)
-{
-uint32_t globstream,len;
-uint8_t  stream,substream;
-uint64_t abs,pts,dts;
-        // Resync on our stream
-_again:
-        if(!parser-&gt;sync(&amp;stream))
-        {
-                uint64_t pos;
-                parser-&gt;getpos(&amp;pos);
-                printf(&quot;DmxPS: cannot sync  at %&quot;LLU&quot;/%&quot;LLU&quot;\n&quot;,pos,_size);
-                _lastErr=1;
-                return 0;
-        }
-        parser-&gt;getpos(&amp;abs);
-        if(_probeSize)
-        {
-        	uint64_t pos;
-                parser-&gt;getpos(&amp;pos);
-                if(pos&gt;_probeSize)
-                {
-                		printf(&quot;Probe exceeded\n&quot;);
-                		return 0;
-                }
-        }
-// Handle out of band stuff
-        if(stream==PACK_START_CODE)
-        {
-        		parser-&gt;forward(8);
-        		goto _again;
-        }
-        if(stream==PADDING_CODE || stream==SYSTEM_START_CODE)
-        {
-                        len=parser-&gt;read16i();
-                        //printf(&quot;\tForwarding %lu bytes\n&quot;,len);
-        		parser-&gt;forward(len);
-        		goto _again;
-        }
-        // Only keep relevant parts
-        // i.e. a/v : C0 C9 E0 E9
-        // subs 20-29
-        // private data 1/2
-#define INSIDE(min,max) (stream&gt;=min &amp;&amp; stream&lt;max)
-        if(!(  INSIDE(0xC0,0xC9) || INSIDE(0xE0,0xE9) || INSIDE(0x20,0x29) || stream==PRIVATE_STREAM_1 || stream==PRIVATE_STREAM_2
-        			)) goto _again;
-        // Ok we got a candidate
-        parser-&gt;getpos(&amp;abs);
-        abs-=4;
-        if(!getPacketInfo(stream,&amp;substream,&amp;len,&amp;pts,&amp;dts))
-        {
-                goto _again;
-        }
-        if(!len) goto _again;
-        if(len&gt;MAX_PES_BUFFER) goto _again;
-
-        if(stream==PRIVATE_STREAM_1) globstream=0xFF00+substream;
-                else                 globstream=stream;
-      //  seen[globstream &amp; 0xFF]+=len;
-        if(myPid==globstream)
-        {
-                _oldPesStart=_pesBufferStart;
-                _oldPesLen=_pesBufferLen;
-                _oldPTS=_pesPTS;
-                _oldDTS=_pesDTS;
-
-                _pesDTS=dts;
-                _pesPTS=pts;
-                _pesBufferStart=abs;
-                _pesBufferLen=len;
-                _pesBufferIndex=0;
-
-                if(!parser-&gt;read32(len,_pesBuffer))
-                {
-                        printf(&quot;Read failed dmx_demuxerPS::refill %d\n&quot;,len);
-                        return 0;
-                }
-                return 1;
-        }
-        if(mask[globstream &amp;0xff])
-        {
-                seen[globstream&amp; 0xff]+=len;
-                if(trackPTS[globstream&amp;0xff]==ADM_NO_PTS &amp;&amp; pts!=ADM_NO_PTS)
-                {
-                        trackPTS[globstream &amp; 0xff]=pts;
-                }
-
-        }
-        // Here keep track of other tracks
-         parser-&gt;forward(len);
-        goto _again;
-        return 0;
-}
-/***************************************************
-    Alternate refill, we read the whole packet
-****************************************************/
-uint8_t dmx_demuxerPS::refillFull(uint8_t *outstream)
-{
-uint32_t globstream,len;
-uint8_t  stream,substream;
-uint64_t abs,pts,dts;
-        // Resync on our stream
-_again2:
-        *outstream=0;
-        if(!parser-&gt;sync(&amp;stream))
-        {
-                uint64_t pos;
-                parser-&gt;getpos(&amp;pos);
-                printf(&quot;DmxPS: cannot sync  at %&quot;LLU&quot;/%&quot;LLU&quot;\n&quot;,pos,_size);
-                _lastErr=1;
-                return 0;
-        }
-        parser-&gt;getpos(&amp;abs);
-        if(_probeSize)
-        {
-        	uint64_t pos;
-                parser-&gt;getpos(&amp;pos);
-                if(pos&gt;_probeSize)
-                {
-                		printf(&quot;Probe exceeded\n&quot;);
-                		return 0;
-                }
-        }
-// Handle out of band stuff
-        if(stream==PACK_START_CODE)
-        {
-        		parser-&gt;forward(8);
-        		goto _again2;
-        }
-        if( stream==PADDING_CODE ||stream==SYSTEM_START_CODE)
-        {
-                        len=parser-&gt;read16i();
-                        //printf(&quot;\tForwarding %lu bytes\n&quot;,len);
-        		parser-&gt;forward(len);
-        		goto _again2;
-        }
-        // Only keep relevant parts
-        // i.e. a/v : C0 C9 E0 E9
-        // subs 20-29
-        // private data 1/2
-#define INSIDE(min,max) (stream&gt;=min &amp;&amp; stream&lt;max)
-        if(!(  INSIDE(0xC0,0xC9) || INSIDE(0xE0,0xE9) || INSIDE(0x20,0x29) || stream==PRIVATE_STREAM_1 || stream==PRIVATE_STREAM_2
-        			)) goto _again2;
-        // Ok we got a candidate
-        parser-&gt;getpos(&amp;abs);
-        abs-=4;
-        if(!getPacketInfo(stream,&amp;substream,&amp;len,&amp;pts,&amp;dts))
-        {
-                goto _again2;
-        }
-        if(len&gt;MAX_PES_BUFFER) goto _again2;
-
-        if(stream==PRIVATE_STREAM_1) globstream=0xFF00+substream;
-                else                 globstream=stream;
-      //  seen[globstream &amp; 0xFF]+=len;
-
-            uint32_t headerLen;
-            uint64_t curPos,totalLen;
-
-                 parser-&gt;getpos(&amp;curPos);
-                 headerLen=curPos-abs;
-                _oldPesStart=_pesBufferStart;
-                _oldPesLen=_pesBufferLen;
-                _oldPTS=_pesPTS;
-                _oldDTS=_pesDTS;
-
-                totalLen=headerLen+len;
-
-                _pesDTS=dts;
-                _pesPTS=pts;
-                _pesBufferStart=abs;
-                _pesBufferLen=totalLen;
-                _pesBufferIndex=headerLen;
-                parser-&gt;setpos(abs);
-                *outstream=globstream;
-                if(!parser-&gt;read32(totalLen,_pesBuffer)) return 0;
-                return 1;
-
-}
-/*
-        Retrieve info about the packet we just met
-        It is assumed that parser is just after the packet startcode
-
-*/
-
-uint8_t dmx_demuxerPS::getPacketInfo(uint8_t stream,uint8_t *substream,uint32_t *olen,uint64_t *opts,uint64_t *odts)
-{
-
-//uint32_t un ,deux;
-uint64_t size=0;
-uint8_t c,d;
-uint8_t align=0;
-
-                *substream=0xff;
-                *opts=ADM_NO_PTS;
-                *odts=ADM_NO_PTS;
-
-
-                size=parser-&gt;read16i();
-                if((stream==PADDING_CODE) ||
-                	 (stream==PRIVATE_STREAM_2)
-                        ||(stream==SYSTEM_START_CODE) //?
-                        ) // special case, no header
-                        {
-                                *olen=size;
-                                return 1;
-                        }
-
-                        //      remove padding if any
-
-                while((c=parser-&gt;read8i()) == 0xff)
-                {
-                        size--;
-                }
-//----------------------------------------------------------------------------
-//-------------------------------MPEG-2 PES packet style----------------------
-//----------------------------------------------------------------------------
-                if(((c&amp;0xC0)==0x80))
-                {
-                        uint32_t ptsdts,len;
-                        //printf(&quot;\n mpeg2 type \n&quot;);
-                        //_muxTypeMpeg2=1;
-                        // c= copyright and stuff
-                        //printf(&quot; %x align\n&quot;,c);
-                        if(c &amp; 4) align=1;
-                        c=parser-&gt;read8i();     // PTS/DTS
-                        //printf(&quot;%x ptsdts\n&quot;,c
-                        ptsdts=c&gt;&gt;6;
-                        // header len
-                        len=parser-&gt;read8i();
-                        size-=3;
-
-                        switch(ptsdts)
-                        {
-                                case 2: // PTS=1 DTS=0
-                                        if(len&gt;=5)
-                                        {
-                                                uint64_t pts1,pts2,pts0;
-                                                //      printf(&quot;\n PTS10\n&quot;);
-                                                        pts0=parser-&gt;read8i();
-                                                        pts1=parser-&gt;read16i();
-                                                        pts2=parser-&gt;read16i();
-                                                        len-=5;
-                                                        size-=5;
-                                                        *opts=(pts1&gt;&gt;1)&lt;&lt;15;
-                                                        *opts+=pts2&gt;&gt;1;
-                                                        *opts+=(((pts0&amp;6)&gt;&gt;1)&lt;&lt;30);
-                                        }
-                                        break;
-                                case 3: // PTS=1 DTS=1
-                                                #define PTS11_ADV 10 // nut monkey
-                                                if(len&gt;=PTS11_ADV)
-                                                {
-                                                        uint32_t skip=PTS11_ADV;
-                                                        uint64_t pts1,pts2,dts,pts0;
-                                                                //      printf(&quot;\n PTS10\n&quot;);
-                                                                pts0=parser-&gt;read8i();
-                                                                pts1=parser-&gt;read16i();
-                                                                pts2=parser-&gt;read16i();
-
-                                                                *opts=(pts1&gt;&gt;1)&lt;&lt;15;
-                                                                *opts+=pts2&gt;&gt;1;
-                                                                *opts+=(((pts0&amp;6)&gt;&gt;1)&lt;&lt;30);
-                                                                pts0=parser-&gt;read8i();
-                                                                pts1=parser-&gt;read16i();
-                                                                pts2=parser-&gt;read16i();
-                                                                dts=(pts1&gt;&gt;1)&lt;&lt;15;
-                                                                dts+=pts2&gt;&gt;1;
-                                                                dts+=(((pts0&amp;6)&gt;&gt;1)&lt;&lt;30);
-                                                                len-=skip;
-                                                                size-=skip;
-                                                                *odts=dts;
-                                                                        //printf(&quot;DTS: %lx\n&quot;,dts);
-                                                   }
-                                                   break;
-                                case 1:
-                                                return 0;//ADM_assert(0); // forbidden !
-                                                break;
-                                case 0:
-                                                // printf(&quot;\n PTS00\n&quot;);
-                                                break; // no pts nor dts
-
-
-                        }
-// Extension bit
-// &gt;stealthdave&lt;
-
-                        // Skip remaining headers if any
-                        if(len)
-                        {
-                                parser-&gt;forward(len);
-                                size=size-len;
-                        }
-
-                if(stream==PRIVATE_STREAM_1)
-                {
-                        if(size&gt;5)
-                        {
-                        // read sub id
-                               *substream=parser-&gt;read8i();
-  //                    printf(&quot;\n Subid : %x&quot;,*subid);
-                                switch(*substream)
-                                {
-                                // DTS
-                                        case 0x88:case 0x89:case 0x8A:case 0x8B:
-
-                                                *substream=*substream-0x48;
-                                                break;
-
-                                //AC3
-                                        case 0x80:case 0x81:case 0x82:case 0x83:
-                                        case 0x84:case 0x85:case 0x86:case 0x87:
-                                                *substream=*substream-0x80;
-                                                break;
-                                // PCM
-                                        case 0xA0:case 0xA1:case 0xa2:case 0xa3:
-                                        case 0xA4:case 0xA5:case 0xa6:case 0xa7:
-                                                // we have an additionnal header
-                                                // of 3 bytes
-                                                parser-&gt;forward(3);
-                                                size-=3;
-                                                break;
-                                // Subs
-                                case 0x20:case 0x21:case 0x22:case 0x23:
-                                case 0x24:case 0x25:case 0x26:case 0x27:
-                                                break;
-
-                                default:
-                                                printf(&quot;Unkown substream %x\n&quot;,*substream);
-                                                *substream=0xff;
-                                }
-                                // skip audio header (if not sub)
-                                if(*substream&gt;0x26 || *substream&lt;0x20)
-                                {
-                                        parser-&gt;forward(3);
-                                        size-=3;
-                                }
-                                size--;
-                        }
-                }
-               //    printf(&quot; pid %x size : %x len %x\n&quot;,sid,size,len);
-                *olen=size;
-                return 1;
-        }
-//----------------------------------------------------------------------------------------------
-//-------------------------------MPEG-1 PES packet style----------------------
-//----------------------------------------------------------------------------------------------
-           if(0) //_muxTypeMpeg2)
-                {
-                        printf(&quot;*** packet type 1 inside type 2 ?????*****\n&quot;);
-                        return 0; // mmmm
-                }
-          // now look at  STD buffer size if present
-          // 01xxxxxxxxx
-          if ((c&gt;&gt;6) == 1)
-          {       // 01
-                        size-=2;
-                        parser-&gt;read8i();                       // skip one byte
-                        c=parser-&gt;read8i();   // then another
-           }
-           // PTS/DTS
-           switch(c&gt;&gt;4)
-           {
-                case 2:
-                {
-                        // 0010 xxxx PTS only
-                        uint64_t pts1,pts2,pts0;
-                                        size -= 4;
-                                        pts0=(c&gt;&gt;1) &amp;7;
-                                        pts1=parser-&gt;read16i()&gt;&gt;1;
-                                        pts2=parser-&gt;read16i()&gt;&gt;1;
-                                        *opts=pts2+(pts1&lt;&lt;15)+(pts0&lt;&lt;30);
-                                        break;
-                  }
-                  case 3:
-                  {               // 0011 xxxx
-                        uint64_t pts1,pts2,pts0;
-                                        size -= 9;
-
-                                        pts0=(c&gt;&gt;1) &amp;7;
-                                        pts1=parser-&gt;read16i()&gt;&gt;1;
-                                        pts2=parser-&gt;read16i()&gt;&gt;1;
-                                        *opts=pts2+(pts1&lt;&lt;15)+(pts0&lt;&lt;30);
-                                        parser-&gt;forward(5);
-                   }
-                   break;
-
-                case 1:
-                        // 0001 xxx
-                        // PTSDTS=01 not allowed
-                                return 0;
-                                break;
-                }
-
-
-                if(!align)
-                        size--;
-        *olen=size;
-        return 1;
-}

Deleted: branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxerMpeg/src/dmx_demuxerTS.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxerMpeg/src/dmx_demuxerTS.cpp	2009-02-10 16:00:26 UTC (rev 4582)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxerMpeg/src/dmx_demuxerTS.cpp	2009-02-11 06:27:26 UTC (rev 4583)
@@ -1,843 +0,0 @@
-/***************************************************************************
-                          TS demuxer
-                             -------------------
-
-    copyright            : (C) 2005 by mean
-    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
-
-        Here we try to read a whole PES packet at a time...
-        So we concatenate all TS packet to get it
-        Else it is a pain to handle potentiel padding bytes
-
-        A special case, if the PES size is 0, it means it is an unbound
-        PES packet, and so the demuxer must guess the size when encountering
-        the next TS packet having the payload unit flag
-        It is a way to overcome the 64k size limit of the PES packetization
-        In that case the padding must be in the adaptation layer bytes.
-
-
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-#include &lt;string.h&gt;
-#include &lt;math.h&gt;
-
-#include &quot;ADM_default.h&quot;
-
-//#define TS_VERBOSE 1
-
-#include &quot;dmx_mpegstartcode.h&quot;
-#include &quot;dmx_demuxerTS.h&quot;
-uint8_t         dmx_demuxerTS::changePid(uint32_t newpid,uint32_t newpes)
-{
-          myPid=newpid;
-          // Be sure our new Pid is taken care of
-          allPid[newpid]=1;
-
-        _pesBufferStart=0;  // Big value so that we read
-        _pesBufferLen=0;
-        _pesBufferIndex=0;
-}
-dmx_demuxerTS::dmx_demuxerTS(uint32_t nb,MPEG_TRACK *tracks,uint32_t psi,DMX_TYPE muxType)
-{
-        consumed=0;
-        parser=new fileParser();
-        stampAbs=0;
-        _pesBuffer=new uint8_t [MAX_TS_BUFFER];
-
-        memset(seen,0,sizeof(seen));
-        memset(allPid,0,sizeof(allPid));
-        _pesBufferStart=0;  // Big value so that we read
-        _pesBufferLen=0;
-        _pesBufferIndex=0;
-        ADM_assert(nb&gt;0);
-        tracked=NULL;
-        nbTracked=nb;
-        myPid=tracks[0].pid; // For mpeg TS we use the PID field as the PES field is irrelevant
-        printf(&quot;Ts: Using %x as pid for track 0\n&quot;,myPid);
-
-        // Build reverse lookup
-        if(nb==TS_ALL_PID)
-                for(int i=0;i&lt;nb;i++)
-                    allPid[ i ]=1+i;
-        else
-                for(int i=0;i&lt;nb;i++)
-                {
-                        allPid[ tracks[i].pid ]=1+i;
-                }
-
-        _probeSize=0;
-        packMode=0;
-        packLen=0;
-        isPsi=psi;
-        switch(muxType)
-        {
-          case DMX_MPG_TS: TS_PacketSize=TS_PACKET_SIZE;break;
-          case DMX_MPG_TS2: TS_PacketSize=TS2_PACKET_SIZE;break;
-          default: ADM_assert(0);
-        }
-        printf(&quot;Creating mpeg TS demuxer  main Pid: %X , pes id :%x, packet size=%u\n&quot;,myPid,tracks[0].pes,TS_PacketSize);
-}
-dmx_demuxerTS::~dmx_demuxerTS()
-{
-        if(parser) delete parser;
-        parser=NULL;
-        if(_pesBuffer) delete [] _pesBuffer;
-        _pesBuffer=NULL;
-        if(tracked) delete [] tracked;
-        tracked=NULL;
-}
-/*
-        Get stats about the PES ids tracked in tracked order
-        if nbTracked=256 it means tracks all possible PES id
-        The 0 rank is video
-*/
-uint8_t       dmx_demuxerTS::getStats(uint64_t *oseen)
-{
-        for(int i=0;i&lt;nbTracked;i++)
-        {
-                oseen[i]=seen[i];
-        }
-        return 1;
-}
-uint8_t dmx_demuxerTS::setProbeSize(uint32_t sz)
-{
-		_probeSize=sz;
-		return 1;
-}
-uint8_t dmx_demuxerTS::open(const char *name)
-{
-FP_TYPE fp=FP_DONT_APPEND;
-
-        if(! parser-&gt;open(name,&amp;fp)) return 0;
-        _size=parser-&gt;getSize();
-        return 1;
-}
-uint8_t dmx_demuxerTS::forward(uint32_t f)
-{
-uint32_t left;
-        if(_pesBufferIndex+f&lt;=_pesBufferLen)
-        {
-                _pesBufferIndex+=f;
-                consumed+=f;
-                return 1;
-        }
-        // else read another packet
-        left=_pesBufferLen-_pesBufferIndex;
-        f-=left;
-        consumed+=left;
-        if(!refill()) return 0;
-        return forward(f);
-}
-uint8_t  dmx_demuxerTS::stamp(void)
-{
-        consumed=0;
-}
-uint64_t dmx_demuxerTS::elapsed(void)
-{
-        return consumed;
-}
-uint8_t  dmx_demuxerTS::getPos( uint64_t *abs,uint64_t *rel)
-{
-        *rel=_pesBufferIndex;
-        *abs=_pesBufferStart;
-        return 1;
-}
-uint8_t dmx_demuxerTS::setPos( uint64_t abs,uint64_t  rel)
-{
-        // Still in same packet ?
-        if(abs==_pesBufferStart &amp;&amp; _pesBufferLen)
-        {
-                if(_pesBufferLen&lt;rel)
-                {
-                        printf(&quot;Asked setpos to go %&quot;LLU&quot; whereas %&quot;LU&quot; is max\n&quot;,
-                                rel,_pesBufferLen);
-                        ADM_assert(rel&lt;_pesBufferLen);
-                }
-
-                _pesBufferIndex=rel;
-                return 1;
-        }
-        // There is a risk we don't get the PES start for that
-        //
-        packMode=0;
-        if(!parser-&gt;setpos(abs))
-        {
-                printf(&quot;DMX_TS: setPos failed\n&quot;);
-                return 0;
-        }
-        _pesBufferStart=abs;
-        if(!refill())
-        {
-                printf(&quot;DMX_TS: refill failed\n&quot;);
-                return 0;
-        }
-
-        if(rel&gt;_pesBufferLen)
-        {
-                printf(&quot;Set pos failed : asked rel:%&quot;LLU&quot; max: %&quot;LU&quot;, absPos:%&quot;LLU&quot; absPosafterRefill:%&quot;LLU&quot;\n&quot;,
-                                        rel,_pesBufferLen,abs,_pesBufferStart);
-                ADM_assert(rel&lt;_pesBufferLen);
-        }
-
-        _pesBufferIndex=rel;
-        return 1;
-}
-/*
-        Sync on mpeg sync word, returns the sync point in abs/r
-*/
-
-
-uint32_t         dmx_demuxerTS::read(uint8_t *w,uint32_t len)
-{
-uint32_t mx;
-                // enough in buffer ?
-                if(_pesBufferIndex+len&lt;=_pesBufferLen)
-                {
-                        memcpy(w,_pesBuffer+_pesBufferIndex,len);
-                        _pesBufferIndex+=len;
-                        consumed+=len;
-                        return len;
-                }
-                // flush
-                mx=_pesBufferLen-_pesBufferIndex;
-                if(mx)
-                {
-                        memcpy(w,_pesBuffer+_pesBufferIndex,mx);
-                        _pesBufferIndex+=mx;
-                        consumed+=mx;
-                        w+=mx;
-                        len-=mx;
-                }
-                if(!refill())
-                {
-                        _lastErr=1;
-                         return mx;
-                }
-                return mx+read(w,len);
-}
-uint8_t         dmx_demuxerTS::sync( uint8_t *stream,uint64_t *abs,uint64_t *r,uint64_t *pts,uint64_t *dts)
-{
-uint32_t val,hnt;
-retry:
-         *r=0;
-
-                val=0;
-                hnt=0;
-
-                // preload
-                hnt=(read8i()&lt;&lt;16) + (read8i()&lt;&lt;8) +read8i();
-                if(_lastErr)
-                {
-                        _lastErr=0;
-                        printf(&quot;\n io error , aborting sync\n&quot;);
-                        return 0;
-                }
-
-                while((hnt!=0x00001))
-                {
-
-                        hnt&lt;&lt;=8;
-                        val=read8i();
-                        hnt+=val;
-                        hnt&amp;=0xffffff;
-
-                        if(_lastErr)
-                        {
-                             _lastErr=0;
-                            printf(&quot;\n io error , aborting sync\n&quot;);
-                            return 0;
-                         }
-
-                }
-
-                *stream=read8i();
-                // Case 1 : assume we are still in the same packet
-                if(_pesBufferIndex&gt;=4)
-                {
-                        *abs=_pesBufferStart;
-                        *r=_pesBufferIndex-4;
-                        *pts=_pesPTS;
-                        *dts=_pesDTS;
-                }
-                else
-                {       // pick what is needed from oldPesStart etc...
-                        // since the beginning in the previous packet
-                        uint32_t left=4-_pesBufferIndex;
-                                 if(left&gt;_oldPesLen)
-                                 { // previous Packet which len is very shoty
-                                   // Ignore
-                                   _pesBufferIndex=0;
-                                   printf(&quot;Ignoring too short packet&quot;);
-                                   goto retry;
-                                 }
-                                 left=_oldPesLen-left;
-#if 0
-                                 printf(&quot;Next packet : %I64X Len :%&quot;LU&quot;, using previous packet %I64X len:%u as pos=%&quot;LU&quot;\n&quot;,
-                                 		_pesBufferStart,_pesBufferLen,_oldPesStart,_oldPesLen,_pesBufferIndex);
-#endif
-                                 if(left&gt;_oldPesLen)
-                                {
-                                        printf(&quot;Need %&quot;LU&quot; bytes from previous packet, which len is %&quot;LU&quot;\n&quot;,left,_oldPesLen);
-                                        ADM_assert(0);
-                                }
-                                *abs=_oldPesStart;
-                                *r=left;
-                                *pts=_oldPTS;
-                                *dts=_oldDTS;
-                }
-                return 1;
-}
-/**
-      \fn readPes
-      \brief Read a complete PES packet
-*/
-uint8_t dmx_demuxerTS::readPes(uint8_t *data, uint32_t *pesBlockLen, uint32_t *dts,uint32_t *pts)
-{
-  uint32_t total=0;
-    if(!refill())
-    {
-      printf(&quot;[DMX] Refill failed\n&quot;);
-      return 0;
-    }
-    *dts=_pesDTS;
-    *pts=_pesPTS;
-    total=_pesBufferLen;
-    memcpy(data,_pesBuffer,_pesBufferLen);
-    while(packLen)
-    {
-        if(!refill())
-        {
-          printf(&quot;[DMX] Refill failed\n&quot;);
-          return 0;
-        }
-
-        memcpy(data+total,_pesBuffer,_pesBufferLen);
-        total+=_pesBufferLen;
-
-    }
-    *pesBlockLen=total;
-    printf(&quot;[DMX] Read %d bytes, packMode %u, pesLen %u\n&quot;,*pesBlockLen,packMode,packLen);
-    return 1;
-}
-//
-//      Refill the pesBuffer
-//              Read packet of correct PID, locate a PES start and read the whole PES packet
-//              It cannot be bigger than 64 k in bound mode, in that case packMode=1, packLen is the leftover to read
-//
-//
-uint8_t dmx_demuxerTS::refill(void)
-{
-uint32_t consumed,len,pid,payload=0;
-uint8_t  stream,substream;
-uint64_t count,abs,pts,dts,first;
-uint32_t left,cc,lenPes;
-
-        _pesBufferIndex=0;
-
-
-_againBranch:
-        while(1)
-        {
-                if(!readPacket(&amp;pid,&amp;left, &amp;payload,&amp;abs,&amp;cc))
-                {
-                        printf(&quot;dmxTs: Cannot read packet (1) at %&quot;LLX&quot;\n&quot;,abs);
-                        return 0;
-                }
-                if(allPid[pid])
-                        break;
-                parser-&gt;forward(left); // Else skip packet
-        }
-
-        if(!payload) // Take as is...
-        {
-                if(pid==myPid)
-                {
-                        // No payloadStart, read it raw
-                        _oldPesStart=_pesBufferStart;
-                        _oldPesLen=_pesBufferLen;
-                        _pesBufferStart=abs;
-
-                        parser-&gt;read32(left,_pesBuffer);
-                        // FIXME HACK
-                        if(TS_PacketSize==192 &amp;&amp; left &gt;4)
-                          {
-                            left-=4; // Remove timestamp of m2ts packet
-                          }
-                       // FIXME HACK
-                        _pesBufferLen=left;
-
-
-                        _pesPTS=ADM_NO_PTS;
-                        _pesDTS=ADM_NO_PTS;
-                        // If we are in pack mode, cut padding bits
-                        if(packMode)
-                        {
-                                if(packLen&lt;left)
-                                {
-#if 1 //def 1  TS_VERBOSE
-                                        printf(&quot;Dropping some bytes : %&quot;LU&quot; / %&quot;LU&quot;\n&quot;,_pesBufferLen,packLen);
-#endif
-                                         _pesBufferLen=packLen;
-                                }
-#if 0
-                                printf(&quot;at %llx, packLen=%&quot;LU&quot; minus %&quot;LU&quot;\n&quot;,_pesBufferStart,packLen,_pesBufferLen);
-#endif
-                                packLen-=_pesBufferLen;
-
-                                if(!packLen)
-                                {
-                                  packMode=0;
-                                }
-                        }
-                        return 1;
-                }
-                // Udate info on that track
-                updateTracker(pid,left);
-                parser-&gt;forward(left);
-                goto _againBranch;
-        }
-        // Payload present, read header
-#ifdef TS_VERBOSE
-        parser-&gt;getpos(&amp;first);
-        printf(&quot;BF: left:%&quot;LU&quot; delta :%&quot;LLU&quot;\n&quot;,left,first-abs);
-#endif
-        if(pid==myPid &amp;&amp; isPsi)
-        {
-                if(!getInfoPSI(&amp;consumed,&amp;lenPes))
-                        goto _againBranch;
-                if(left&lt;consumed)
-                        goto _againBranch;
-                left-=consumed;
-                _pesBufferStart=abs;
-
-
-                _pesPTS=ADM_NO_PTS;
-                _pesDTS=ADM_NO_PTS;
-
-                parser-&gt;read32(left,_pesBuffer);
-                 // FIXME HACK
-                if(TS_PacketSize==192 &amp;&amp; left &gt;4)
-                  {
-                    left-=4; // Remove timestamp of m2ts packet
-                  }
-                _pesBufferLen=left;
-                 // FIXME HACK
-                return 1;
-        }
-
-
-        if(!getInfoPES(&amp;consumed,&amp;dts,&amp;pts,&amp;stream,&amp;substream,&amp;lenPes))
-        {
-                        printf(&quot;dmxTs: get info failed at %&quot;LLX&quot;\n&quot;,abs);
-                        goto _againBranch;
-        }
-#ifdef TS_VERBOSE
-        printf(&quot;Stream :%x found at %&quot;LLX&quot; size :%&quot;LU&quot;\n&quot;,stream,abs,lenPes);
-        parser-&gt;getpos(&amp;count);
-        printf(&quot;consumed :%&quot;LU&quot; left:%&quot;LU&quot; delta :%&quot;LLU&quot;\n&quot;,consumed,left,count-first);
-        if(count-first!=consumed) printf(&quot;*** PES header length is wrong***\n&quot;);
-
-#endif
-        if(consumed&gt;left)
-        {
-                printf(&quot;Wrong PES header at %&quot;LLX&quot; %&quot;LU&quot; / %&quot;LU&quot;\n&quot;,abs,consumed,left);
-                goto _againBranch;
-        }
-
-        left-=consumed;
-        if(myPid==pid)
-        {
-                if(lenPes)
-                {
-                        packMode=1;
-                        packLen=lenPes;
-                }
-                else
-                {
-                        packMode=0;
-                }
-
-                _oldPesStart=_pesBufferStart;
-                _oldPesLen=_pesBufferLen;
-
-                _pesBufferStart=abs;
-
-
-                _pesPTS=pts;
-                _pesDTS=dts;
-
-                parser-&gt;read32(left,_pesBuffer);
-                  // FIXME HACK
-                if(TS_PacketSize==192 &amp;&amp; left &gt;4)
-                  {
-                    left-=4; // Remove timestamp of m2ts packet
-                  }
-                _pesBufferLen=left;
-                if(packMode)
-                {
-                        if(packLen&lt;left) _pesBufferLen=packLen;
-                        packLen-=_pesBufferLen;
-                        if(!packLen) packMode=0;
-                }
-                return 1;
-        }
-        // update info
-        updateTracker(pid,left);
-        parser-&gt;forward(left);
-        goto _againBranch;
-}
-//***********************************
-// Read a Ts packet and extract
-// interesting infos
-//***********************************
-uint8_t dmx_demuxerTS::readPacket(uint32_t *opid,uint32_t *oleft, uint32_t *isPayloadStart,uint64_t *ostart,uint32_t *occ)
-{
-uint32_t consumed,len,pid,payloadunit=0,discarded;
-uint64_t count,abs;
-uint32_t left;
-uint8_t  byte1,byte2;
-        parser-&gt;getpos(&amp;count);
-#ifdef TS_VERBOSE
-        printf(&quot;Starting sync at %&quot;LLX&quot;\n&quot;,count);
-#endif
-_again:
-        payloadunit=0;
-        parser-&gt;getpos(&amp;count);
-        count=_size-count;
-        discarded=0;
-        while(parser-&gt;read8i()!=0x47 &amp;&amp; count&gt;TS_PacketSize)
-                {
-                        discarded++;
-                        count--;
-                }
-        if(count&lt;TS_PacketSize)
-        {
-                printf(&quot;DmxTS: cannot sync (EOF reached) \n&quot;);
-                _lastErr=1;
-                return 0;
-        }
-        // Check that there is a 0x47 later on...
-        parser-&gt;getpos(&amp;abs);
-        if(discarded) // We did not have a continuous sync, check 2 more packet boundaries..
-        {
-
-                parser-&gt;forward(TS_PacketSize-1);
-                byte1=parser-&gt;read8i();
-                parser-&gt;forward(TS_PacketSize-1);
-                byte2=parser-&gt;read8i();
-                parser-&gt;setpos(abs);  // The setpos/getpos is mostly free due to the parser large buffer
-                if(byte1!=0x47 || byte2!=0x47) goto _again;
-        }
-#ifdef TS_VERBOSE
-        printf(&quot;Sync at %&quot;LLX&quot;\n&quot;,abs-1);
-#endif
-        // Memorize where it starts
-        *ostart=abs-1;
-        // Read Pid etc...
-        pid=parser-&gt;read16i();
-        if((pid&gt;&gt;8) &amp; TS_UNIT_START) payloadunit=1;
-        pid&amp;=0x1fff; // remove flags
-        if(discarded)
-                printf(&quot;Ts: Discontinuity of %&quot;LU&quot; at %&quot;LLX&quot; pid:%&quot;LX&quot;\n&quot;,discarded,abs,pid);
-        // Start of packet..
-        left=TS_PacketSize-3;
-        if(_probeSize)
-        {
-                if(abs&gt;_probeSize)
-                {
-                		printf(&quot;dmxTs:Probe exceeded\n&quot;);
-                		return 0;
-                }
-        }
-        // Ok now get some informations....
-        // only interested in my Pid &amp; user data Pid
-        if(pid!=myPid &amp;&amp; pid&lt;0x10)
-        {
-                parser-&gt;forward(left);
-                goto _again;
-        }
-        // One of the stream we are looking for ?
-        if(!allPid[pid])
-        {
-                parser-&gt;forward(left);
-                goto _again; // No
-        }
-        // Remove header if any
-
-        int cc,val,adaptation;
-        // Flags : adaptation layer + continuity counter etc...
-        val=parser-&gt;read8i();
-        left--;
-        cc=val &amp; 0xf;
-        adaptation=(val &gt;&gt;4)&amp;0x3;
-        if(!(adaptation &amp; 1)) // no payload
-        {
-                parser-&gt;forward(left);
-                goto _again;
-        }
-        if(adaptation &amp; 2) // There is an adaptation field
-        {
-                val=parser-&gt;read8i();
-                left--;
-                if(val&gt;=left)
-                {
-                 printf(&quot;Wrong adaptation layer size at %&quot;LLX&quot; size=%&quot;LU&quot;, bytes left = %&quot;LU&quot; pid=%&quot;LX&quot;\n&quot;,abs,val,left,pid);
-                 goto _again; // need to search..
-                }
-                parser-&gt;forward(val); // skip adaptation field
-                left-=val;
-        }
-        // Ok now we got the raw data packet
-        *oleft=left;
-        *opid=pid;
-        *occ=cc;
-
-        if(payloadunit) // A PSI or PES packet starts here
-        {
-                *isPayloadStart=1;
-        }else
-                *isPayloadStart=0;
-        return 1;
-}
-/*
-        Retrieve info about the packet we just met
-        It is assumed that parser is just after the packet startcode
-
-*/
-uint8_t       dmx_demuxerTS::updateTracker(uint32_t trackerPid,uint32_t nbData)
-{
-        seen[(allPid[trackerPid])-1]+=nbData;
-        return 1;
-}
-
-uint8_t       dmx_demuxerTS::getInfoPES(uint32_t *oconsumed,uint64_t *odts,uint64_t *opts,
-                                        uint8_t *ostream,uint8_t *substream,
-                                        uint32_t *olen)
-{
-
-uint32_t headconsumd=0;
-int size=0,nulsize=0;
-uint8_t c,d;
-uint8_t align=0;
-                *oconsumed=0;
-
-                // Check it looks like a PES header
-                // It could be a PSI header ...
-                if(parser-&gt;read8i()) return 0;
-                if(parser-&gt;read8i()) return 0;
-                if(parser-&gt;read8i()!=1) return 0;
-                *ostream=parser-&gt;read8i(); // Stream
-                headconsumd=4;
-//
-
-                *substream=0xff;
-                *opts=ADM_NO_PTS;
-                *odts=ADM_NO_PTS;
-
-
-                size=parser-&gt;read16i();
-                headconsumd+=2;
-                if(!size) nulsize=1;
-                if((*ostream==PADDING_CODE) ||
-                	 (*ostream==PRIVATE_STREAM_2)
-                        ||(*ostream==SYSTEM_START_CODE) //?
-                        ) // special case, no header
-                        {
-                                if(nulsize) size=0;
-                                *olen=size;
-                                *oconsumed=headconsumd;
-                                return 1;
-                        }
-
-                        //      remove padding if any
-
-                while((c=parser-&gt;read8i()) == 0xff)
-                {
-                        headconsumd++;
-                        size--;
-                }
-//----------------------------------------------------------------------------
-//-------------------------------MPEG-2 PES packet style----------------------
-//----------------------------------------------------------------------------
-                if(((c&amp;0xC0)!=0x80))
-                {
-                        printf(&quot;DmxTs: Not mpeg2 PES!\n&quot;);
-                        return 0;
-                }
-
-                        uint32_t ptsdts,len;
-                        //printf(&quot;\n mpeg2 type \n&quot;);
-                        //_muxTypeMpeg2=1;
-                        // c= copyright and stuff
-                        //printf(&quot; %x align\n&quot;,c);
-                        if(c &amp; 4) align=1;
-                        c=parser-&gt;read8i();     // PTS/DTS
-                        //printf(&quot;%x ptsdts\n&quot;,c
-                        ptsdts=c&gt;&gt;6;
-                        // header len
-                        len=parser-&gt;read8i();
-                        size-=3;
-                        headconsumd+=3;
-
-                        switch(ptsdts)
-                        {
-                                case 2: // PTS=1 DTS=0
-                                        if(len&gt;=5)
-                                        {
-                                                uint64_t pts1,pts2,pts0;
-                                                //      printf(&quot;\n PTS10\n&quot;);
-                                                        pts0=parser-&gt;read8i();
-                                                        pts1=parser-&gt;read16i();
-                                                        pts2=parser-&gt;read16i();
-                                                        len-=5;
-                                                        size-=5;
-                                                        headconsumd+=5;
-                                                        *opts=(pts1&gt;&gt;1)&lt;&lt;15;
-                                                        *opts+=pts2&gt;&gt;1;
-                                                        *opts+=(((pts0&amp;6)&gt;&gt;1)&lt;&lt;30);
-                                        }
-                                        break;
-                                case 3: // PTS=1 DTS=1
-                                                #define PTS11_ADV 10 // nut monkey
-                                                if(len&gt;=PTS11_ADV)
-                                                {
-                                                        uint32_t skip=PTS11_ADV;
-                                                        uint64_t pts1,pts2,dts,pts0;
-                                                                //      printf(&quot;\n PTS10\n&quot;);
-                                                                pts0=parser-&gt;read8i();
-                                                                pts1=parser-&gt;read16i();
-                                                                pts2=parser-&gt;read16i();
-
-                                                                *opts=(pts1&gt;&gt;1)&lt;&lt;15;
-                                                                *opts+=pts2&gt;&gt;1;
-                                                                *opts+=(((pts0&amp;6)&gt;&gt;1)&lt;&lt;30);
-                                                                pts0=parser-&gt;read8i();
-                                                                pts1=parser-&gt;read16i();
-                                                                pts2=parser-&gt;read16i();
-                                                                dts=(pts1&gt;&gt;1)&lt;&lt;15;
-                                                                dts+=pts2&gt;&gt;1;
-                                                                dts+=(((pts0&amp;6)&gt;&gt;1)&lt;&lt;30);
-                                                                len-=skip;
-                                                                size-=skip;
-                                                                *odts=dts;
-                                                                headconsumd+=10;
-                                                                        //printf(&quot;DTS: %lx\n&quot;,dts);
-                                                   }
-                                                   break;
-                                case 1:
-                                                return 0;//ADM_assert(0); // forbidden !
-                                                break;
-                                case 0:
-                                                // printf(&quot;\n PTS00\n&quot;);
-                                                break; // no pts nor dts
-
-
-                        }
-// Extension bit
-// &gt;stealthdave&lt;
-
-                        // Skip remaining headers if any
-                        if(len)
-                        {
-                                parser-&gt;forward(len);
-                                size=size-len;
-                                headconsumd+=len;
-                        }
-
-
-               //    printf(&quot; pid %x size : %x len %x\n&quot;,sid,size,len);
-                if(nulsize) size=0;
-                *olen=size;
-                *oconsumed=headconsumd;
-                return 1;
-}
-uint8_t dmx_demuxerTS::getInfoPSI(uint32_t *oconsumed,uint32_t *olen)
-{
-        *oconsumed=*olen=0;
-        return 1;
-
-}
-/**
-      \fn    syncH264
-      \brief Search H264 startcode in the stream
-*/
-uint8_t         dmx_demuxerTS::syncH264( uint8_t *stream,uint64_t *abs,uint64_t *r,uint64_t *pts,uint64_t *dts)
-{
-uint32_t val,hnt;
-retry:
-         *r=0;
-
-                val=0;
-                hnt=0;
-
-                // preload
-                hnt=(read8i()&lt;&lt;24) + (read8i()&lt;&lt;16) +(read8i()&lt;&lt;8)+(read8i());
-                if(_lastErr)
-                {
-                        _lastErr=0;
-                        printf(&quot;\n io error , aborting sync\n&quot;);
-                        return 0;
-                }
-
-                while((hnt!=1))
-                {
-
-                        hnt&lt;&lt;=8;
-                        val=read8i();
-                        hnt+=val;
-
-                        if(_lastErr)
-                        {
-                             _lastErr=0;
-                            printf(&quot;\n io error , aborting sync\n&quot;);
-                            return 0;
-                         }
-
-                }
-
-                *stream=read8i();
-                // Case 1 : assume we are still in the same packet
-                if(_pesBufferIndex&gt;=5)
-                {
-                        *abs=_pesBufferStart;
-                        *r=_pesBufferIndex-5;
-                        *pts=_pesPTS;
-                        *dts=_pesDTS;
-                }
-                else
-                {       // pick what is needed from oldPesStart etc...
-                        // since the beginning in the previous packet
-                        uint32_t left=5-_pesBufferIndex;
-                                 if(left&gt;_oldPesLen)
-                                 { // previous Packet which len is very shoty
-                                   // Ignore
-                                   _pesBufferIndex=0;
-                                   printf(&quot;Ignoring too short packet&quot;);
-                                   goto retry;
-                                 }
-                                 left=_oldPesLen-left;
-#if 0
-                                 printf(&quot;Next packet : %I64X Len :%&quot;LU&quot;, using previous packet %I64X len:%u as pos=%&quot;LU&quot;\n&quot;,
-                                 		_pesBufferStart,_pesBufferLen,_oldPesStart,_oldPesLen,_pesBufferIndex);
-#endif
-                                 if(left&gt;_oldPesLen)
-                                {
-                                        printf(&quot;Need %&quot;LU&quot; bytes from previous packet, which len is %&quot;LU&quot;\n&quot;,left,_oldPesLen);
-                                        ADM_assert(0);
-                                }
-                                *abs=_oldPesStart;
-                                *r=left;
-                                *pts=_oldPTS;
-                                *dts=_oldDTS;
-                }
-                return 1;
-}

Modified: branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxerMpeg/src/dmx_io.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxerMpeg/src/dmx_io.cpp	2009-02-10 16:00:26 UTC (rev 4582)
+++ branches/avidemux_2.6_branch_mean/avidemux/ADM_coreDemuxerMpeg/src/dmx_io.cpp	2009-02-11 06:27:26 UTC (rev 4583)
@@ -22,9 +22,9 @@
 #include &lt;math.h&gt;
 
 #include &quot;ADM_default.h&quot;
-
 #include &quot;dmx_io.h&quot;
 
+#define aprintf(...) {}
 
 fileParser::fileParser( void )
 {
@@ -55,6 +55,7 @@
         }
         if(_buffer) delete [] _buffer;
         _buffer=NULL;
+        _nbFd=0;
 }
 
 /*
@@ -102,7 +103,7 @@
         // no number sequence
         if( decimals == 0 )
         {
-                printf( &quot;\nSimple loading: \n&quot; );
+                aprintf( &quot;\nSimple loading: \n&quot; );
                 delete [] followup;
                 _nbFd = 1;
                 _curFd = 0;
@@ -120,9 +121,9 @@
                 fseeko( _fd[0], 0, SEEK_SET );
                 _sizeFdCumul[0]=0;
                 _size=_sizeFd[0];
-                printf( &quot; file: %s, size: %&quot;LLU&quot;\n&quot;, filename, _sizeFd[0] );
-                printf( &quot; found 1 files \n&quot; );
-                printf( &quot;Done \n&quot; );
+                aprintf( &quot; file: %s, size: %&quot;LLU&quot;\n&quot;, filename, _sizeFd[0] );
+                aprintf( &quot; found 1 files \n&quot; );
+                aprintf( &quot;Done \n&quot; );
                 return 1;
         }
 
@@ -154,7 +155,7 @@
                 buffer_fd = new FILE * [tabSize];
                 buffer_sizeFd = new uint64_t [tabSize];
 
-                printf( &quot;\nAuto adding: \n&quot; );
+                aprintf( &quot;\nAuto adding: \n&quot; );
                 while( last_followup == 0 )
                 {
                         strcpy( followup, left );
@@ -177,7 +178,7 @@
                         buffer_sizeFd[count] = ftello( buffer_fd[count] );
                         fseeko( buffer_fd[count], 0, SEEK_SET );
 
-                        printf( &quot; file %d: %s, size: %&quot;LLU&quot;\n&quot;, (count + 1), followup, buffer_sizeFd[count] );
+                        aprintf( &quot; file %d: %s, size: %&quot;LLU&quot;\n&quot;, (count + 1), followup, buffer_sizeFd[count] );
 
                         // increase number
                         number[decimals - 1] = number[decimals - 1] + 1;
@@ -226,8 +227,8 @@
                                 *multi=FP_DONT_APPEND;
                 }
 
-                printf( &quot; found %d files \n&quot;, count );
-                printf( &quot;Done \n&quot; );
+                aprintf( &quot; found %d files \n&quot;, count );
+                aprintf( &quot;Done \n&quot; );
         } // if( decimals == 0 )
                 return 1;
 } // fileParser::open()
@@ -305,7 +306,7 @@
         // preload
         if((4+_off)&gt;=_size)
         {
-                printf(&quot;Dmx IO: End of file met (%&quot;LLU&quot; / %&quot;LLU&quot; seg%&quot;LU&quot;)\n&quot;,_off,_size,_nbFd);
+                printf(&quot;Dmx IO: End of file met (%&quot;LLU&quot; / %&quot;LLU&quot; seg:%&quot;LU&quot;)\n&quot;,_off,_size,_nbFd);
                 return 0;
         }
         hnt=(read8i()&lt;&lt;16) + (read8i()&lt;&lt;8) +read8i();
@@ -338,7 +339,7 @@
         // preload
         if((5+_off)&gt;=_size)
         {
-                printf(&quot;Dmx IO: End of file met (%&quot;LLU&quot; / %&quot;LLU&quot; seg%&quot;LU&quot;)\n&quot;,_off,_size,_nbFd);
+                printf(&quot;Dmx IO: End of file met (%&quot;LLU&quot; / %&quot;LLU&quot; seg:%&quot;LU&quot;)\n&quot;,_off,_size,_nbFd);
                 return 0;
         }
         hnt=(read8i()&lt;&lt;24)+(read8i()&lt;&lt;16) + (read8i()&lt;&lt;8) +read8i();
@@ -500,3 +501,40 @@
         return r;
 }
 #endif
+
+void fileParser::hexDump(uint8_t *buf, int size)
+{
+	int len, i, j, c;
+
+	for(i=0;i&lt;size;i+=16)
+	{
+		len = size - i;
+
+		if (len &gt; 16)
+			len = 16;
+
+		printf(&quot;%08x &quot;, i);
+
+		for(j=0;j&lt;16;j++)
+		{
+			if (j &lt; len)
+				printf(&quot; %02x&quot;, buf[i+j]);
+			else
+				printf(&quot;   &quot;);
+		}
+
+		printf(&quot; &quot;);
+
+		for(j=0;j&lt;len;j++)
+		{
+			c = buf[i+j];
+
+			if (c &lt; ' ' || c &gt; '~')
+				c = '.';
+
+			printf(&quot;%c&quot;, c);
+		}
+
+		printf(&quot;\n&quot;);
+	}
+}

Modified: branches/avidemux_2.6_branch_mean/avidemux/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/avidemux/CMakeLists.txt	2009-02-10 16:00:26 UTC (rev 4582)
+++ branches/avidemux_2.6_branch_mean/avidemux/CMakeLists.txt	2009-02-11 06:27:26 UTC (rev 4583)
@@ -344,8 +344,8 @@
 ADD_LIB_ALL_TARGETS(ADM_coreAudio)
 ADD_SUBDIRECTORY(ADM_coreDemuxer)
 ADD_LIB_ALL_TARGETS(ADM_coreDemuxer)
-#ADD_SUBDIRECTORY(ADM_coreDemuxerMpeg)
-#ADD_LIB_ALL_TARGETS(ADM_coreDemuxerMpeg)
+ADD_SUBDIRECTORY(ADM_coreDemuxerMpeg)
+ADD_LIB_ALL_TARGETS(ADM_coreDemuxerMpeg)
 ADD_SUBDIRECTORY(ADM_coreAudioDevice)
 ADD_LIB_ALL_TARGETS(ADM_coreAudioDevice)
 ADD_SUBDIRECTORY(ADM_coreUtils)

Deleted: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegPS/ADM_indexFile.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegPS/ADM_indexFile.cpp	2009-02-10 16:00:26 UTC (rev 4582)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegPS/ADM_indexFile.cpp	2009-02-11 06:27:26 UTC (rev 4583)
@@ -1,238 +0,0 @@
-/**
-    \file ADM_indexFile
-    \brief Handle index file reading
-    copyright            : (C) 2009 by mean
-    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
-        
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#include &quot;ADM_default.h&quot;
-#include &quot;ADM_indexFile.h&quot;
-#include &quot;ctype.h&quot;
-/**
-
-*/
-dmxToken::dmxToken(const char *name,const char *value)
-{
-    this-&gt;name=ADM_strdup(name);
-    this-&gt;value=ADM_strdup(value);
-}
-/**
-
-*/
-dmxToken::~dmxToken()
-{
-    if(name) ADM_dealloc(name);
-    if(value) ADM_dealloc(value);
-}
-
-char *dmxToken::getName(void) {return name;}
-char *dmxToken::getValue(void){return value;}
-/**
-
-*/
-bool  dmxToken::isNumeric(void)
-{
-bool num=true;
-int l=strlen(value);
-    for(int i=0;i&lt;l;i++)
-    {
-        char v=value[i];
-        if(!isdigit(v)&amp;&amp; v!=0x0a &amp;&amp; v!=0x0d) num=false;
-    }
-    return num;
-}   
-/**
-
-*/
-uint32_t dmxToken::getAsNumber(void)
-{
-uint32_t v;
-    v=atoi(value);
-    return v;
-}
-
-//****************************************************************************************
-
-/**
-
-*/
-
-indexFile::indexFile()
-{
-    file=NULL;
-}
-/**
-
-*/
-
-indexFile::~indexFile()
-{
-   close();
-}
-/**
-
-*/
-void  indexFile::purgeTokens(void)
-{
-    while(ListOfTokens.size())
-    {
-        delete ListOfTokens[0];
-        ListOfTokens.erase(ListOfTokens.begin());
-    }
-}
-/**
-
-*/
-dmxToken        *indexFile::searchToken(const char *name)
-{
-    for(int i=0;i&lt;ListOfTokens.size();i++)
-    {
-        dmxToken *tk=ListOfTokens[i];
-        if(!strcasecmp(name,tk-&gt;getName())) return tk;
-    }
-    printf(&quot;[indexFile] Token %s not found\n&quot;,name);
-    return NULL;
-}
-/**
-
-*/
-
-bool indexFile::open(const char *name)
-{
-    file=fopen(name,&quot;rt&quot;);
-    if(!file) return false;
-    return true;
-}
-
-/**
-
-*/
-
-bool indexFile::close(void)
-{
-    if(file)
-    {
-        fclose(file);
-        file=NULL;
-    }
-    purgeTokens();
-
-}
-
-/**
-
-*/
-
-bool indexFile::goToSection(const char *section)
-{
-char match[100];
-    sprintf(match,&quot;[%s]\n&quot;,section);
-    fseek(file,0,SEEK_SET);
-    while(1)
-    {
-        if(!fgets((char*)buffer,ADM_INDEX_BUFFER,file) )
-        {
-            printf(&quot;[indexFile] Cannot find section %s,%s*\n&quot;,section,match);
-            return false;
-        }
-        if(!strcasecmp((char*)buffer,match)) return true;
-    }
-    return false;
-}
-
-/**
-    \fn readSection
-*/
-
-bool indexFile::readSection(const char *section)
-{
-    if(false==goToSection(section)) return false;
-    // Until we reach the next section, store all couples name/value into the
-    //
-    while(1)
-    {
-        if(!readString(ADM_INDEX_BUFFER,buffer)) break;
-        if(buffer[0]=='[') break; // end of section
-        // Now search the = and replace it by a zero
-        char *head,*tail;
-        head=(char *)buffer;
-        tail=(char *)buffer;
-        tail=strstr((char *)buffer,&quot;=&quot;);
-        if(!tail) 
-        {
-            printf(&quot;[psIndexer]Weird line :%s\n&quot;,buffer);
-        }
-        *tail=0;
-        tail++;
-        dmxToken *tk=new dmxToken(head,tail);
-        ListOfTokens.push_back(tk);
-
-    }
-    return true;
-}
-
-/**
-
-*/
-
-uint32_t indexFile::getAsUint32(const char *name)
-{
-    dmxToken *token=searchToken(name);
-    if(!token) return 0;
-    if(token-&gt;isNumeric()) return token-&gt;getAsNumber();
-    printf(&quot;[psIndex] token %s is not a digit : %s\n&quot;,name,token-&gt;getValue());
-    return 0;
-}
-
-/** 
-    \fn getAsHex
-    \read entry as hex
-
-*/
-
-uint32_t indexFile::getAsHex(const char *name)
-{
-    uint32_t v;
-    dmxToken *token=searchToken(name);
-    char *s;
-    if(!token) return 0;
-    s=token-&gt;getValue();
-    sscanf(s,&quot;%x&quot;,&amp;v);
-    return v;
-}
-
-/**
-
-*/
-
-char *indexFile::getAsString(const char *name)
-{
-    dmxToken *token=searchToken(name);
-    if(!token) return NULL;
-    return token-&gt;getValue();
-
-}
-
-/**
-
-*/
-
-bool  indexFile::readString(uint32_t maxLen,uint8_t *buffer)
-{
-    if(!fgets((char *)buffer,maxLen,file)) return false;
-    buffer[maxLen-1]=0;
-    return true;
-}
-
-
-//EOF
-

Deleted: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegPS/ADM_indexFile.h
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegPS/ADM_indexFile.h	2009-02-10 16:00:26 UTC (rev 4582)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegPS/ADM_indexFile.h	2009-02-11 06:27:26 UTC (rev 4583)
@@ -1,74 +0,0 @@
-/**
-    \file ADM_indexFile
-    \brief Handle index file reading
-    copyright            : (C) 2009 by mean
-    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
-        
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-
-#ifndef ADM_INDEXFILE_H
-#define ADM_INDEXFILE_H
-#include &lt;vector&gt;
-/**
-    \class indexFile
-    \brief Read a index file easily
-*/
-#define ADM_INDEX_BUFFER (20*1024)
-/**
-    \class dmxToken
-*/
-class dmxToken
-{
-protected:
-    char *name;
-    char *value;
-    FILE *file;
-    void  purgeTokens(void);
-public:
-    
-    dmxToken(const char *name,const char *value);
-    ~dmxToken();
-    char *getName(void);
-    char *getValue(void);
-    bool  isNumeric(void);
-    uint32_t getAsNumber(void);
-};
-
-/**
-    \class indexFile
-*/
-
-class indexFile
-{
-protected:
-    uint8_t         buffer[ADM_INDEX_BUFFER];
-    dmxToken        *searchToken(const char *name);
-    void            purgeTokens(void);
-
-    FILE            *file;
-    std::vector &lt;dmxToken *&gt; ListOfTokens;
-public:
-
-        indexFile();
-        ~indexFile();
-    bool open(const char *name);
-    bool close(void);
-    bool goToSection(const char *section);
-    bool readSection(const char *section);
-    uint32_t getAsUint32(const char *token);
-    uint32_t getAsHex(const char *token);
-    char *getAsString(const char *token);
-    bool  readString(uint32_t maxLen,uint8_t *buffer);
-
-};
-
-#endif
\ No newline at end of file

Modified: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegPS/CMakeLists.txt
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegPS/CMakeLists.txt	2009-02-10 16:00:26 UTC (rev 4582)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegPS/CMakeLists.txt	2009-02-11 06:27:26 UTC (rev 4583)
@@ -7,13 +7,11 @@
 	ADM_psAudio.cpp
 	ADM_psAudioProbe.cpp
 	ADM_psAudioProbe.h
-
-    dmxPSPacket.cpp
-    dmx_io.cpp
-    ADM_indexFile.cpp
 )
 
 ADD_LIBRARY(ADM_dm_ps SHARED ${ADM_ps_SRCS})
+TARGET_LINK_LIBRARIES(ADM_dm_ps ADM_coreDemuxerMpeg)
+INCLUDE_DIRECTORIES(&quot;${AVIDEMUX_SOURCE_DIR}/avidemux/ADM_coreDemuxerMpeg/include&quot;)
 
 
 

Deleted: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegPS/dmxPSPacket.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegPS/dmxPSPacket.cpp	2009-02-10 16:00:26 UTC (rev 4582)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegPS/dmxPSPacket.cpp	2009-02-11 06:27:26 UTC (rev 4583)
@@ -1,660 +0,0 @@
-/**
-    \file dmxPSPacket
-    \brief Packet demuxer for mpeg PS
-    copyright            : (C) 2005-2008 by mean
-    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
-        
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#include &quot;ADM_default.h&quot;
-
-#include &quot;dmxPSPacket.h&quot;
-#include &quot;dmx_mpegstartcode.h&quot;
-
-/**
-    \fn psPacket
-    \brief ctor
-*/
-psPacket::psPacket(void)
-{
-    doNoComplainAnyMore=0;
-    _file=NULL;
-}
-/**
-    \fn psPacket
-    \brief dtor
-*/
-psPacket::~psPacket()
-{
-    close();
-}
-/**
-    \fn open
-    \brief dtor
-*/
-bool psPacket::open(const char *filenames,bool dontappend)
-{
-FP_TYPE opentype=FP_APPEND;
-    if(dontappend) opentype=FP_DONT_APPEND;
-    _file=new fileParser();
-    if(!_file-&gt;open(filenames,&amp;opentype))
-    {
-        printf(&quot;[DmxPS] cannot open %s\n&quot;,filenames);
-        delete _file;
-        _file=NULL;
-        return false;
-    }
-    _size=_file-&gt;getSize();
-    return true;
-}
-/**
-    \fn close
-    \brief dtor
-*/
-bool psPacket::close(void)
-{
-    if(_file)
-    {
-        delete _file;
-        _file=NULL;
-    }
-    return true;
-}
-/**
-    \fn getPos
-*/
-uint64_t    psPacket::getPos(void)
-{
-    return 0;
-}
-/**
-    \fn setPos
-*/
-
-bool    psPacket::setPos(uint64_t pos)
-{
-    if(!_file-&gt;setpos(pos))
-    {
-        printf(&quot;[psPacket] Cannot seek to %&quot;LLX&quot;\n&quot;, pos);
-        return false;
-    }
-}
-
-/**
-    \fn getPacketOfType
-    \brief Only returns packet of type pid
-*/      
-
-bool        psPacket::getPacketOfType(uint8_t pid,uint32_t maxSize, uint32_t *packetSize,uint64_t *pts,uint64_t *dts,uint8_t *buffer,uint64_t *startAt)
-{
-
-    bool xit=false;
-    uint8_t tmppid;
-    while(1)
-    {
-        if(true!=getPacket(maxSize,&amp;tmppid,packetSize,pts,dts,buffer,startAt))
-                return false;
-        else
-                if(tmppid==pid) return true;
-    }
-    return false;
-}
-/**
-    \fn getPacket
-*/      
-bool        psPacket::getPacket(uint32_t maxSize, uint8_t *pid, uint32_t *packetSize,uint64_t *opts,uint64_t *odts,uint8_t *buffer,uint64_t *startAt)
-{
-uint32_t globstream,len;
-uint8_t  stream,substream;
-uint64_t pts,dts;
-        // Resync on our stream
-_again2:
-        *pid=0;
-        if(!_file-&gt;sync(&amp;stream)) 
-        {
-                uint64_t pos;
-                _file-&gt;getpos(&amp;pos);
-                printf(&quot;[DmxPS] cannot sync  at &quot;LLU&quot;/&quot;LLU&quot;\n&quot;,pos,_size);
-                return false;
-        }
-// Position of this packet just before startcode
-        _file-&gt;getpos(startAt);
-        *startAt-=4;
-// Handle out of band stuff        
-        if(stream==PACK_START_CODE) 
-        {
-        		_file-&gt;forward(8);
-        		goto _again2;
-        }
-        if( stream==PADDING_CODE ||stream==SYSTEM_START_CODE) 
-        {
-                        len=_file-&gt;read16i();
-                        //printf(&quot;\tForwarding %lu bytes\n&quot;,len);
-        		_file-&gt;forward(len);
-        		goto _again2;
-        }
-        // Only keep relevant parts
-        // i.e. a/v : C0 C9 E0 E9
-        // subs 20-29
-        // private data 1/2
-#define INSIDE(min,max) (stream&gt;=min &amp;&amp; stream&lt;max)
-        if(!(  INSIDE(0xC0,0xC9) || INSIDE(0xE0,0xE9) || INSIDE(0x20,0x29) || stream==PRIVATE_STREAM_1 || stream==PRIVATE_STREAM_2
-        			)) goto _again2;
-        // Ok we got a candidate
-        if(!getPacketInfo(stream,&amp;substream,&amp;len,&amp;pts,&amp;dts))   
-        {
-                goto _again2;
-        }
-        
-        //printf(&quot;Main Stream :%x substream :%x\n&quot;,stream,substream);
-        if(stream==PRIVATE_STREAM_1) globstream=0xFF00+substream;
-                else                 globstream=stream;
-
-        *pid=globstream;
-        *opts=pts;
-        *odts=dts;
-        *packetSize=len;
-        if(len&gt;     maxSize)
-        {
-                printf(&quot;[DmxPS] Packet too big %d vs %d\n&quot;,len,maxSize);
-        }
-        if(!_file-&gt;read32(len,buffer)) return false;
-        return true;
-       
-}
-/**
-
-    \fn getPacketInfo
-    \brief       Retrieve info about the packet we just met.It is assumed that parser is just after the packet startcode
-
-*/
-
-uint8_t psPacket::getPacketInfo(uint8_t stream,uint8_t *substream,uint32_t *olen,uint64_t *opts,uint64_t *odts)
-{
-
-//uint32_t un ,deux;
-uint64_t size=0;
-uint8_t c,d;
-uint8_t align=0;
-                        
-                *substream=0xff;
-                *opts=ADM_NO_PTS;
-                *odts=ADM_NO_PTS;
-                
-                                        
-                size=_file-&gt;read16i();
-                if((stream==PADDING_CODE) || 
-                	 (stream==PRIVATE_STREAM_2)
-                        ||(stream==SYSTEM_START_CODE) //?
-                        ) // special case, no header
-                        {
-                                *olen=size;      
-                                return 1;
-                        }
-                                
-                        //      remove padding if any                                           
-        
-                while((c=_file-&gt;read8i()) == 0xff) 
-                {
-                        size--;
-                }
-//----------------------------------------------------------------------------
-//-------------------------------MPEG-2 PES packet style----------------------
-//----------------------------------------------------------------------------
-                if(((c&amp;0xC0)==0x80))
-                {
-                        uint32_t ptsdts,len;
-                        //printf(&quot;\n mpeg2 type \n&quot;);
-                        //_muxTypeMpeg2=1;
-                        // c= copyright and stuff       
-                        //printf(&quot; %x align\n&quot;,c);      
-                        if(c &amp; 4) align=1;      
-                        c=_file-&gt;read8i();     // PTS/DTS
-                        //printf(&quot;%x ptsdts\n&quot;,c
-                        ptsdts=c&gt;&gt;6;
-                        // header len
-                        len=_file-&gt;read8i();
-                        size-=3;  
-
-                        switch(ptsdts)
-                        {
-                                case 2: // PTS=1 DTS=0
-                                        if(len&gt;=5)
-                                        {
-                                                uint64_t pts1,pts2,pts0;
-                                                //      printf(&quot;\n PTS10\n&quot;);
-                                                        pts0=_file-&gt;read8i();  
-                                                        pts1=_file-&gt;read16i(); 
-                                                        pts2=_file-&gt;read16i();                 
-                                                        len-=5;
-                                                        size-=5;
-                                                        *opts=(pts1&gt;&gt;1)&lt;&lt;15;
-                                                        *opts+=pts2&gt;&gt;1;
-                                                        *opts+=(((pts0&amp;6)&gt;&gt;1)&lt;&lt;30);
-                                        }
-                                        break;
-                                case 3: // PTS=1 DTS=1
-                                                #define PTS11_ADV 10 // nut monkey
-                                                if(len&gt;=PTS11_ADV)
-                                                {
-                                                        uint32_t skip=PTS11_ADV;
-                                                        uint64_t pts1,pts2,dts,pts0;
-                                                                //      printf(&quot;\n PTS10\n&quot;);
-                                                                pts0=_file-&gt;read8i();  
-                                                                pts1=_file-&gt;read16i(); 
-                                                                pts2=_file-&gt;read16i(); 
-                                                                                        
-                                                                *opts=(pts1&gt;&gt;1)&lt;&lt;15;
-                                                                *opts+=pts2&gt;&gt;1;
-                                                                *opts+=(((pts0&amp;6)&gt;&gt;1)&lt;&lt;30);
-                                                                pts0=_file-&gt;read8i();  
-                                                                pts1=_file-&gt;read16i(); 
-                                                                pts2=_file-&gt;read16i();                 
-                                                                dts=(pts1&gt;&gt;1)&lt;&lt;15;
-                                                                dts+=pts2&gt;&gt;1;
-                                                                dts+=(((pts0&amp;6)&gt;&gt;1)&lt;&lt;30);
-                                                                len-=skip;
-                                                                size-=skip;
-                                                                *odts=dts;
-                                                                        //printf(&quot;DTS: %lx\n&quot;,dts);                
-                                                   }
-                                                   break;               
-                                case 1:
-                                                return 0;//ADM_assert(0); // forbidden !
-                                                break;
-                                case 0: 
-                                                // printf(&quot;\n PTS00\n&quot;);
-                                                break; // no pts nor dts
-                                                                                
-                                                            
-                        }  
-// Extension bit        
-// &gt;stealthdave&lt;                                
-
-                        // Skip remaining headers if any
-                        if(len) 
-                        {
-                                _file-&gt;forward(len);
-                                size=size-len;
-                        }
-                                
-                if(stream==PRIVATE_STREAM_1)
-                {
-                        if(size&gt;5)
-                        {
-                        // read sub id
-                               *substream=_file-&gt;read8i();
-  //                    printf(&quot;\n Subid : %x&quot;,*subid);
-                                switch(*substream)
-                                {
-                                // DTS
-                                        case 0x88:case 0x89:case 0x8A:case 0x8B:
-                                        
-                                                *substream=*substream-0x48;
-                                                break;
-
-                                //AC3
-                                        case 0x80:case 0x81:case 0x82:case 0x83:
-                                        case 0x84:case 0x85:case 0x86:case 0x87:
-                                                *substream=*substream-0x80;
-                                                break;
-                                // PCM
-                                        case 0xA0:case 0xA1:case 0xa2:case 0xa3:
-                                        case 0xA4:case 0xA5:case 0xa6:case 0xa7:
-                                                // we have an additionnal header
-                                                // of 3 bytes
-                                                _file-&gt;forward(3);
-                                                size-=3;
-                                                break;
-                                // Subs
-                                case 0x20:case 0x21:case 0x22:case 0x23:
-                                case 0x24:case 0x25:case 0x26:case 0x27:
-                                                break;
-                             
-                                default:
-                                                doNoComplainAnyMore++;
-                                                if(doNoComplainAnyMore&lt;10)
-                                                    printf(&quot;[DmxPS]Unkown substream %x\n&quot;,*substream);
-                                                *substream=0xff;
-                                }
-                                // skip audio header (if not sub)
-                                if(*substream&gt;0x26 || *substream&lt;0x20)
-                                {
-                                        _file-&gt;forward(3);
-                                        size-=3;
-                                }
-                                size--;
-                        }
-                }
-               //    printf(&quot; pid %x size : %x len %x\n&quot;,sid,size,len);
-                *olen=size;
-                return 1;
-        }
-//----------------------------------------------------------------------------------------------                
-//-------------------------------MPEG-1 PES packet style----------------------                                  
-//----------------------------------------------------------------------------------------------                                        
-           if(0) //_muxTypeMpeg2)
-                {
-                        printf(&quot;[DmxPS]*** packet type 1 inside type 2 ?????*****\n&quot;);
-                        return 0; // mmmm                       
-                }
-          // now look at  STD buffer size if present
-          // 01xxxxxxxxx
-          if ((c&gt;&gt;6) == 1) 
-          {       // 01
-                        size-=2;
-                        _file-&gt;read8i();                       // skip one byte
-                        c=_file-&gt;read8i();   // then another
-           }                       
-           // PTS/DTS
-           switch(c&gt;&gt;4)
-           {
-                case 2:
-                {
-                        // 0010 xxxx PTS only
-                        uint64_t pts1,pts2,pts0;
-                                        size -= 4;
-                                        pts0=(c&gt;&gt;1) &amp;7;
-                                        pts1=_file-&gt;read16i()&gt;&gt;1;
-                                        pts2=_file-&gt;read16i()&gt;&gt;1;
-                                        *opts=pts2+(pts1&lt;&lt;15)+(pts0&lt;&lt;30);
-                                        break;
-                  }
-                  case 3:
-                  {               // 0011 xxxx
-                        uint64_t pts1,pts2,pts0;
-                                        size -= 9;
-                                                                        
-                                        pts0=(c&gt;&gt;1) &amp;7;
-                                        pts1=_file-&gt;read16i()&gt;&gt;1;
-                                        pts2=_file-&gt;read16i()&gt;&gt;1;
-                                        *opts=pts2+(pts1&lt;&lt;15)+(pts0&lt;&lt;30);
-                                        _file-&gt;forward(5);
-                   }                                                               
-                   break;
-                   
-                case 1:
-                        // 0001 xxx             
-                        // PTSDTS=01 not allowed                        
-                                return 0;
-                                break; 
-                }
-                                                                
-
-                if(!align)      
-                        size--;         
-        *olen=size;
-        return 1;
-}
-//************************************************************************************
-
-#define ADM_PACKET_LINEAR 10*1024
-/**
-    \fn psPacket
-*/
-psPacketLinear::psPacketLinear(uint8_t pid) : psPacket()
-{
-    oldStartAt=startAt=0xfffffff;
-    oldBufferLen=bufferLen=0;
-    bufferIndex=0;
-    myPid=pid;
-    eof=false;
-}
-/**
-    \fn ~psPacket
-*/
-psPacketLinear::~psPacketLinear() 
-{
-}
-/**
-    \fn refill
-*/
-bool psPacketLinear::refill(void) 
-{
-// In case a startcade spawns across 2 packets
-// we have to keep track of the old one
-        oldBufferDts=bufferDts;
-        oldBufferPts=bufferPts;
-        oldStartAt=startAt;
-        oldBufferLen=bufferLen;
-        if( false== getPacketOfType(myPid,ADM_PACKET_LINEAR, &amp;bufferLen,&amp;bufferPts,&amp;bufferDts,buffer,&amp;startAt)) return false;
-        bufferIndex=0;
-        return true;
-}
-/**
-    \fn readi8
-*/
-uint8_t psPacketLinear::readi8(void)
-{
-    consumed++;
-    if(bufferIndex&lt;bufferLen)
-    {
-        return buffer[bufferIndex++];
-    }
-    if(false==refill()) 
-    {
-        eof=1;
-        return 0;
-    }
-    ADM_assert(bufferLen);
-    bufferIndex=1;
-    return buffer[0];
-    
-}
-/**
-    \fn readi16
-*/
-uint16_t psPacketLinear::readi16(void)
-{
-    if(bufferIndex+1&lt;bufferLen)
-    {
-        uint16_t v=(buffer[bufferIndex]&lt;&lt;8)+buffer[bufferIndex+1];;
-        bufferIndex+=2;
-        consumed+=2;
-        return v;
-    }
-    return (readi8()&lt;&lt;8)+readi8();
-}
-/**
-    \fn readi32
-*/
-uint32_t psPacketLinear::readi32(void)
-{
-    if(bufferIndex+3&lt;bufferLen)
-    {
-        uint8_t *p=buffer+bufferIndex;
-        uint32_t v=(p[0]&lt;&lt;24)+(p[1]&lt;&lt;16)+(p[2]&lt;&lt;8)+p[3];
-        bufferIndex+=4;
-        consumed+=4;
-        return v;
-    }
-    return (readi16()&lt;&lt;16)+readi16();
-}
-/**
-    \fn forward
-*/
-bool psPacketLinear::forward(uint32_t v)
-{
-    if(bufferIndex+v-1&lt;bufferLen)
-    {
-        bufferIndex+=v;
-        consumed+=v;
-        return true;
-    }
-    if(!refill()) return false;
-    uint32_t delta=bufferLen-bufferIndex;
-    v-=delta;
-    consumed+=delta;
-    return forward(v);
-}
-
-/**
-    \fn bool    read(uint32_t len, uint8_t *buffer);
-    \brief
-*/
-bool    psPacketLinear::read(uint32_t len, uint8_t *out)
-{
-    // Enough already ?
-    while(len)
-    {
-        uint32_t avail=bufferLen-bufferIndex;
-        uint32_t chunk=avail;
-        if(chunk&gt;len) chunk=len;
-#if 0
-        printf(&quot;len:%ld avail:%ld chunk %ld index:%d size:%d\n&quot;,
-                len,avail,chunk,bufferIndex,bufferLen);
-#endif
-        memcpy(out,buffer+bufferIndex,chunk);
-        bufferIndex+=chunk;
-        len-=chunk;
-        out+=chunk;
-        consumed+=chunk;
-        if(bufferIndex==bufferLen)
-        {
-            //printf(&quot;Refill\n&quot;);
-            if(false==refill()) return false;
-        }
-    }
-    return true;
-}
-/**
-        \fn getInfo
-        \brief Returns info about the current (or previous if it spawns) packet.
-            It is expected that the caller will do -4 to the index to get the start of the 
-            startCode
-*/
-bool    psPacketLinear::getInfo(psPacketInfo *info)
-{
-    if(bufferIndex&lt;4)
-    {
-        info-&gt;startAt=this-&gt;oldStartAt;
-        info-&gt;offset=oldBufferLen+bufferIndex;
-        info-&gt;pts=oldBufferPts;
-        info-&gt;dts=oldBufferDts;
-
-    }else
-    {
-        info-&gt;startAt=this-&gt;startAt;
-        info-&gt;offset=bufferIndex;
-        info-&gt;pts=bufferPts;
-        info-&gt;dts=bufferDts;
-    }
-    return true;
-
-};
-/**
-    \fn seek
-    \brief Async jump
-*/
-bool    psPacketLinear::seek(uint64_t packetStart, uint32_t offset)
-{
-    if(!_file-&gt;setpos(packetStart))
-    {
-        printf(&quot;[psPacket] Cannot seek to %&quot;LLX&quot;\n&quot;,packetStart);
-        return 0;
-    }
-    refill();
-    ADM_assert(offset&lt;bufferLen);
-    bufferIndex=offset;
-    
-    return true;
-}
-/**
-    \fn getConsumed
-    \brief returns the # of bytes consumed since the last call
-*/
-uint32_t psPacketLinear::getConsumed(void)
-{
-    uint32_t c=consumed;
-    consumed=0;
-    return c;
-}
-/**
-    \fn changePid
-    \brief change the pid of the stream we read (used when probing all tracks)
-*/
-bool    psPacketLinear::changePid(uint32_t pid) 
-{
-    myPid=(pid&amp;0xff);
-    bufferLen=bufferIndex=0;
-    return true;
-}
-/* ********************************************************* */
-/**
-    \fn psPacketLinearTracker
-*/
- psPacketLinearTracker::psPacketLinearTracker(uint8_t pid)  : psPacketLinear(pid)
-{
-   
-}
-/**
-    \fn ~psPacketLinearTracker
-*/
-psPacketLinearTracker::~psPacketLinearTracker()
-{
-
-    resetStats();
-}
-/**
-        \fn getStat
-*/
-packetStats    *psPacketLinearTracker::getStat(int index)
-{   
-    if(index&lt;0 || index&gt;=256) ADM_assert(0);
-    return stats+index;
-}
-/**
-    \fn getPacketgetPacketOfType
-    \brief Keep track of all the packets we have seen so far.
-    Usefull to detect the streams present and to look up the PTS/DTS of audio streams for the audio part of the index
-*/
-bool           psPacketLinearTracker::getPacketOfType(uint8_t pid,uint32_t maxSize, uint32_t *packetSize,uint64_t *pts,uint64_t *dts,uint8_t *buffer,uint64_t *startAt)
-{
- bool xit=false;
-    uint8_t tmppid;
-    while(1)
-    {
-        if(true!=getPacket(maxSize,&amp;tmppid,packetSize,pts,dts,buffer,startAt))
-                return false;
-        else
-        {
-                // Update 
-                ADM_assert(tmppid&lt;0x100);
-                packetStats *p=stats+tmppid;
-                uint64_t ts=*pts;
-                if(ts==ADM_NO_PTS) ts=*dts;
-                if(ts!=ADM_NO_PTS)
-                {
-                    p-&gt;startCount=p-&gt;count;
-                    p-&gt;startAt=*startAt;
-                    p-&gt;startSize=p-&gt;size;
-                    p-&gt;startDts=ts;
-                }
-                p-&gt;count++;
-                p-&gt;size+=*packetSize;
-                if(tmppid==pid) return true;
-        }
-    }
-    return false;
-}
-/**
-    \fn resetStats
-*/
-bool           psPacketLinearTracker::resetStats(void)
-{
-    memset(stats,0,sizeof(stats));
-    for(int i=0;i&lt;256;i++)
-    {
-        packetStats *p=stats+i;
-        p-&gt;startDts=ADM_NO_PTS;
-    }
-}
-//EOF

Deleted: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegPS/dmxPSPacket.h
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegPS/dmxPSPacket.h	2009-02-10 16:00:26 UTC (rev 4582)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegPS/dmxPSPacket.h	2009-02-11 06:27:26 UTC (rev 4583)
@@ -1,112 +0,0 @@
-/**
-    dmxPSPacket.cpp
-
-*/
-
-#ifndef DMXPSPACKET_H
-#define DMXPSPACKET_H
-
-#include &quot;dmx_io.h&quot;
-#include &quot;ADM_Video.h&quot;
-
-/**
-    \struct psPacketInfo
-
-*/
-typedef struct
-{
-    uint64_t pts;
-    uint64_t dts;
-    uint64_t startAt;
-    uint32_t offset;
-
-}psPacketInfo;
-
-/**
-    \class psPacket
-*/
-class psPacket
-{
-protected:
-    int         doNoComplainAnyMore;
-    fileParser  *_file;
-    uint64_t    _size;
-    uint8_t     getPacketInfo(uint8_t stream,uint8_t *substream,uint32_t *olen,uint64_t *opts,uint64_t *odts);
-public:
-                psPacket(void);
-                ~psPacket();
-    bool        open(const char *filenames,bool dontappend);
-    bool        close(void);
-    virtual bool        getPacket(uint32_t maxSize, uint8_t *pid, uint32_t *packetSize,uint64_t *pts,uint64_t *dts,uint8_t *buffer,uint64_t *startAt);
-    virtual bool        getPacketOfType(uint8_t pid,uint32_t maxSize, uint32_t *packetSize,uint64_t *pts,uint64_t *dts,uint8_t *buffer,uint64_t *startAt);
-    uint64_t    getPos(void);
-    bool        setPos(uint64_t pos);
-    uint64_t    getSize(void) { return _file-&gt;getSize();}
-};
-/**
-    \class psPacketLinear
-*/
-#define ADM_PACKET_LINEAR 10*1024
-
-class psPacketLinear : public psPacket
-{
-protected:
-        uint8_t  myPid;
-        uint64_t startAt;
-        uint32_t bufferLen;
-        uint64_t bufferPts;
-        uint64_t bufferDts;
-        uint32_t bufferIndex;
-        uint8_t  buffer[ADM_PACKET_LINEAR];
-        bool     eof;
-        bool     refill(void);
-        uint64_t oldStartAt;
-        uint32_t oldBufferLen;
-        uint64_t oldBufferPts;
-        uint64_t oldBufferDts;
-        uint32_t consumed;
-
-public:
-                psPacketLinear(uint8_t pid);
-                ~psPacketLinear();
-        uint32_t getConsumed(void);
-        uint8_t  readi8();
-        uint16_t readi16();
-        uint32_t readi32();
-        bool     sync(uint8_t *pid);
-        bool    read(uint32_t len, uint8_t *buffer);
-        bool    forward(uint32_t v);
-        bool    stillOk(void) {return !eof;};
-        bool    getInfo(psPacketInfo *info);
-        bool    seek(uint64_t packetStart, uint32_t offset);
-        bool    changePid(uint32_t pid) ;
-};
-/**
-    \class psPacketLinearTracker
-*/
-typedef struct
-{
-    uint32_t count;
-    uint32_t size;
-    
-    uint64_t startAt;
-    uint32_t startCount;
-    uint32_t startSize;
-    uint64_t startDts;
-}packetStats;
-
-class psPacketLinearTracker : public psPacketLinear
-{
-protected:
-      packetStats stats[256];
-
-public:
-                        psPacketLinearTracker(uint8_t pid);
-                        ~psPacketLinearTracker();
-         packetStats    *getStat(int intdex);
-         bool           resetStats(void);
-virtual  bool           getPacketOfType(uint8_t pid,uint32_t maxSize, uint32_t *packetSize,uint64_t *pts,uint64_t *dts,uint8_t *buffer,uint64_t *startAt);
-};
-
-
-#endif
\ No newline at end of file

Deleted: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegPS/dmx_io.cpp
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegPS/dmx_io.cpp	2009-02-10 16:00:26 UTC (rev 4582)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegPS/dmx_io.cpp	2009-02-11 06:27:26 UTC (rev 4583)
@@ -1,540 +0,0 @@
-/***************************************************************************
-                          dmx_io.cpp  -  description
-                             -------------------
-
-    copyright            : (C) 2005 by mean
-    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
-
-    This just handles mpeg sync search and little endian/big endin integer reading
-    It also handle multiple files seen as one logical file and buffering
-        to speed up ios
-
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#include &lt;math.h&gt;
-
-#include &quot;ADM_default.h&quot;
-#include &quot;dmx_io.h&quot;
-
-#define aprintf(...) {}
-
-fileParser::fileParser( void )
-{
-                _fd=NULL;
-                _sizeFd=NULL;
-                _off=0;
-                _nbFd=0;
-                _curFd=0;
-                _buffer=new uint8_t[DMX_BUFFER];
-                _head=_tail=0;
-                _size=0;
-}
-
-fileParser::~fileParser()
-{
-        if(_nbFd)
-        {
-                 for(uint32_t i=0;i&lt;_nbFd;i++)
-                 {
-                                if(_fd[i])
-                                        fclose(_fd[i]);
-                 }
-                delete [] _fd;
-                delete [] _sizeFd;
-                delete [] _sizeFdCumul;
-
-
-        }
-        if(_buffer) delete [] _buffer;
-        _buffer=NULL;
-        _nbFd=0;
-}
-
-/*
-        Open one file, probe to see if there is several file with contiguous name
-        and handle them as one big file if that's the case
-
-        If multi is set to probe, return value will be APPEND if there is several files, dont_append if one
-        if multi is set to dont_append, file won't be auto appended even if they exist
-*/
-uint8_t fileParser::open( const char *filename,FP_TYPE *multi )
-{
-        char *dot = NULL;                   // pointer to the last dot in filename
-        uint8_t decimals = 0;               // number of decimals
-        char *left = NULL, *number = NULL, *right = NULL; // parts of filename (after splitting)
-
-        char *followup = new char[ strlen(filename) + 1 ]; // possible follow-up filename
-        uint8_t first_followup = 1;         // indicates first follow-up
-        uint8_t last_followup = 0;          // indicates last follow-up (by number: 99)
-        uint8_t count = 0;                  // number of follow-ups
-
-        FILE **buffer_fd = NULL;            // _fd buffer
-        uint64_t *buffer_sizeFd = NULL;     // _sizeFd buffer
-
-        int i = 0;                          // index (general use)
-
-
-        // find the last dot
-        dot = strrchr( filename, '.' );
-
-        // count the decimals before the dot
-        decimals = 1;
-        while( (dot != NULL) &amp;&amp; ((dot - decimals) != filename) &amp;&amp;
-               (dot[0 - decimals] &gt;= '0') &amp;&amp; (dot[0 - decimals] &lt;= '9') )
-                { decimals++; }
-        decimals--;
-
-        // Nuv files can have 20 decimals
-        // Keep it down to 10000
-        if(decimals&gt;4) decimals=4;
-        if(*multi==FP_DONT_APPEND)
-        {
-                if(decimals) printf(&quot;There was several files, but dont append was forced\n&quot;);
-                decimals=0;
-        }
-        // no number sequence
-        if( decimals == 0 )
-        {
-                aprintf( &quot;\nSimple loading: \n&quot; );
-                delete [] followup;
-                _nbFd = 1;
-                _curFd = 0;
-                _fd = new FILE * [_nbFd];
-                _sizeFd = new uint64_t [_nbFd];
-                _sizeFdCumul = new uint64_t [_nbFd];
-
-                // open file
-                if(! (_fd[0] = fopen(filename, &quot;rb&quot;)) )
-                  { return 0; }
-
-                // calculate file-size
-                fseeko( _fd[0], 0, SEEK_END );
-                _sizeFd[0] = ftello( _fd[0] );
-                fseeko( _fd[0], 0, SEEK_SET );
-                _sizeFdCumul[0]=0;
-                _size=_sizeFd[0];
-                aprintf( &quot; file: %s, size: %&quot;LLU&quot;\n&quot;, filename, _sizeFd[0] );
-                aprintf( &quot; found 1 files \n&quot; );
-                aprintf( &quot;Done \n&quot; );
-                return 1;
-        }
-
-        // possible number sequence
-        else
-        {
-                // split the filename in &lt;left&gt;, &lt;number&gt; and &lt;right&gt;
-                // -----
-
-                // &lt;left&gt; part
-                left = new char[(dot - filename - decimals) + 1];
-                strncpy( left, filename, (dot - filename - decimals) );
-                left[(dot - filename - decimals)] = '\0';
-
-                // &lt;number&gt; part
-                number = new char[decimals + 1];
-                strncpy( number, (dot - decimals), decimals );
-                number[decimals] = '\0';
-
-                // &lt;right&gt; part
-                right = new char[ strlen(dot) ];
-                strcpy( right, dot );
-
-                // add the file, and all existing follow-ups
-                // -----
-                uint32_t tabSize;
-
-                tabSize=(uint32_t)pow(10,decimals);
-                buffer_fd = new FILE * [tabSize];
-                buffer_sizeFd = new uint64_t [tabSize];
-
-                aprintf( &quot;\nAuto adding: \n&quot; );
-                while( last_followup == 0 )
-                {
-                        strcpy( followup, left );
-                        strcat( followup, number );
-                        strcat( followup, right );
-
-                        // open file
-                        buffer_fd[count] = fopen(followup, &quot;rb&quot;);
-                        if(! buffer_fd[count] )
-                        {
-                                // we need at least one file!
-                                if( first_followup == 1 )
-                                  { return 0; }
-                                else
-                                  { printf( &quot; file: %s not found. \n&quot;, followup ); break; }
-                        }
-
-                        // calculate file-size
-                        fseeko( buffer_fd[count], 0, SEEK_END );
-                        buffer_sizeFd[count] = ftello( buffer_fd[count] );
-                        fseeko( buffer_fd[count], 0, SEEK_SET );
-
-                        aprintf( &quot; file %d: %s, size: %&quot;LLU&quot;\n&quot;, (count + 1), followup, buffer_sizeFd[count] );
-
-                        // increase number
-                        number[decimals - 1] = number[decimals - 1] + 1;
-                        for( i = decimals - 1; i &gt;= 0; i-- )
-                        {
-                                if( number[i] &gt; '9' )
-                                {
-                                        if( i == 0 )
-                                          { last_followup = 1; break; }
-                                        number[i] = '0';
-                                        number[i - 1] = number[i - 1] + 1;
-                                }
-                        }
-
-                        first_followup = 0;
-                        count++;
-                } // while( last_followup == 0 )
-
-                // copy from buffer
-                _nbFd = count;
-                _curFd = 0;
-                _fd = new FILE * [_nbFd];
-                _sizeFd = new uint64_t [_nbFd];
-                _sizeFdCumul = new uint64_t [_nbFd];
-                uint64_t total=0;
-                for( i = 0; i &lt; count; i++ )
-                {
-                        _fd[i] = buffer_fd[i];
-                        _sizeFd[i] = buffer_sizeFd[i];
-                        _sizeFdCumul[i]=total;
-                        total+=buffer_sizeFd[i];
-                }
-                _size=total;
-                // clean up
-                delete [] followup;
-                delete [] left;
-                delete [] number;
-                delete [] right;
-                delete [] buffer_fd;
-                delete [] buffer_sizeFd;
-                if(*multi==FP_PROBE)
-                {
-                        if(count&gt;1)
-                                *multi=FP_APPEND;       //
-                        else
-                                *multi=FP_DONT_APPEND;
-                }
-
-                aprintf( &quot; found %d files \n&quot;, count );
-                aprintf( &quot;Done \n&quot; );
-        } // if( decimals == 0 )
-                return 1;
-} // fileParser::open()
-
-
-/*----------------------------------------
-
-------------------------------------------*/
-
-uint8_t fileParser::forward(uint64_t jmp)
-{
-                // still in the buffer ?
-                if((_off+jmp)&lt;_tail)
-                {
-                        _off+=jmp;
-                        return 1;
-                }
-
-               // locate the new file
-
-               if(_off+jmp&gt;=_size)
-                        {
-                               _off=_size-1;
-                               _head=_off;
-                               _tail=_off;
-                               return 0;
-                        }
-                _off+=jmp;  // final location
-                for(uint32_t i=_curFd;i&lt;_nbFd;i++)
-                {
-                        if(_off&gt;=_sizeFdCumul[i] &amp;&amp; _off&lt;(_sizeFdCumul[i]+_sizeFd[i]))
-                        {
-                                _curFd=i;
-                                fseeko(_fd[i],_off-_sizeFdCumul[i],SEEK_SET);
-                                _head=_tail=_off;
-                                return 1;
-                        }
-
-                }
-
-                return 0;
-}
-
-uint8_t fileParser::setpos(uint64_t o)
-{
-
-                if(o&gt;=_head &amp;&amp; o&lt;_tail)
-                {
-                        _off=o;
-                        return 1;
-                }
-                for(uint32_t i=0;i&lt;_nbFd;i++)
-                        {
-                                if( (o&gt;=_sizeFdCumul[i]) &amp;&amp; o&lt;(_sizeFdCumul[i]+_sizeFd[i]))
-                                        {
-                                                        _curFd=i;
-                                                        _off=o;
-                                                        fseeko(_fd[_curFd],_off-_sizeFdCumul[i],SEEK_SET);
-                                                        _head=_tail=_off; // Flush
-                                                  return 1;
-                                        }
-                        }
-                        printf(&quot;\n cannot seek to %&quot;LLU&quot;\n&quot;,o);
-                        return 0;
-}
-//
-//      Search packet signature and return packet type
-//_______________________________________
-uint8_t fileParser::sync(uint8_t *stream)
-{
-uint32_t val,hnt;
-
-        val=0;
-        hnt=0;
-        // preload
-        if((4+_off)&gt;=_size)
-        {
-                printf(&quot;Dmx IO: End of file met (%&quot;LLU&quot; / %&quot;LLU&quot; seg:%&quot;LU&quot;)\n&quot;,_off,_size,_nbFd);
-                return 0;
-        }
-        hnt=(read8i()&lt;&lt;16) + (read8i()&lt;&lt;8) +read8i();
-
-
-        while((hnt!=0x00001))
-        {
-                hnt&lt;&lt;=8;
-                val=read8i();
-                hnt+=val;
-                hnt&amp;=0xffffff;
-                if(_curFd==_nbFd-1)
-                {
-                                if((4+_off)&gt;=_size) return 0;
-                }
-        }
-
-        *stream=read8i();
-        return 1;
-}
-//
-//      Search packet signature and return packet type
-//_______________________________________
-uint8_t fileParser::syncH264(uint8_t *stream)
-{
-uint32_t val,hnt;
-
-        val=0;
-        hnt=0;
-        // preload
-        if((5+_off)&gt;=_size)
-        {
-                printf(&quot;Dmx IO: End of file met (%&quot;LLU&quot; / %&quot;LLU&quot; seg:%&quot;LU&quot;)\n&quot;,_off,_size,_nbFd);
-                return 0;
-        }
-        hnt=(read8i()&lt;&lt;24)+(read8i()&lt;&lt;16) + (read8i()&lt;&lt;8) +read8i();
-
-
-        while((hnt!=0x1))
-        {
-                hnt&lt;&lt;=8;
-                val=read8i();
-                hnt+=val;
-                if(_curFd==_nbFd-1)
-                {
-                                if((5+_off)&gt;=_size) return 0;
-                }
-        }
-
-        *stream=read8i();
-        return 1;
-}
-
-uint8_t fileParser::getpos(uint64_t *o)
-{
-         *o=_off;
-         return 1;
-
-}
-
-
- uint64_t fileParser::getSize( void )
-{
-        return  _size;
-
-}
-/*--------------------------------------------------
-                Read l bytes from file
-----------------------------------------------------*/
-uint32_t fileParser::read32(uint32_t len, uint8_t *buffer)
-{
-uint32_t r;
-
-uint64_t remain,begin,mx,last;
-
-        ADM_assert(_off&gt;=_head);
-        ADM_assert(_off&lt;=_tail);
-
-        if(_head&gt;=_size-1) return 0;
-
-// Check we do not go out of bound
-        if(_off+len&gt;=_size)
-        {
-                len=_size-_off;
-        }
-
-        remain=_tail-_off;
-        begin=_off-_head;
-
-
-
-        // everything in cache ?
-        if(len&lt;=remain)
-        {
-                memcpy(buffer,_buffer+begin,len);
-                _off+=len;
-                return len;
-        }
-
-        // No enough data, purge cache
-        if(remain)
-        {
-                memcpy(buffer,_buffer+begin,remain);
-                _off+=remain;
-                len-=remain;
-                buffer+=remain;
-                return remain+read32(len,buffer);
-        }
-
-        // Reload ?
-        // What is left in that file ?
-        mx=_sizeFd[_curFd]+_sizeFdCumul[_curFd]-_off;
-        // Do we need more, if so jump over it
-        if(len&gt;mx)
-        {
-                fread(buffer,mx,1,_fd[_curFd]);
-                len-=mx;
-                _off+=mx;
-                buffer+=mx;
-                _head=_tail=_off;
-                _curFd++;
-                if(_curFd&gt;=_nbFd) return 0;
-                fseeko(_fd[_curFd],0,SEEK_SET);
-                return mx+read32(len,buffer);
-        }
-        // Read what is available in file, store leftover in the buffer
-        fread(buffer,len,1,_fd[_curFd]);
-        _off+=len;
-        // available in that file
-        mx-=len;
-        if(mx&gt;DMX_BUFFER) mx=DMX_BUFFER;
-        fread(_buffer,mx,1,_fd[_curFd]);
-        _head=_off;
-        _tail=_head+mx;
-
-         return len;
-
-}
-#ifdef NO_INLINE_FP
-uint32_t fileParser::read32i(void )
-{
-       uint32_t v;
-       uint8_t c[4];
-       uint8_t *p;
-        // case one, it fits in the buffer
-        //
-        if(_off+4&lt;_tail)
-        {
-                p=&amp;(_buffer[_off-_head]);
-                _off+=4;
-        }
-        else
-        {
-               read32(4,c);
-               p=c;
-        }
-       v= (p[0]&lt;&lt;24)+(p[1]&lt;&lt;16)+(p[2]&lt;&lt;8)+p[3];
-       return v;
-}
-uint16_t fileParser::read16i(void )
-{
-  uint32_t v;
-       uint8_t c[4];
-       uint8_t *p;
-        // case one, it fits in the buffer
-        //
-        if(_off+2&lt;_tail)
-        {
-                p=&amp;(_buffer[_off-_head]);
-                _off+=2;
-        }
-        else
-        {
-               read32(2,c);
-               p=c;
-        }
-       v= (p[0]&lt;&lt;8)+p[1];
-       return v;
-}
-uint8_t fileParser::read8i(void )
-{
-uint8_t r;
-        if(_off+1&lt;_tail)
-        {
-                r= _buffer[_off-_head];
-                _off++;
-        }
-        else
-        {
-                read32(1,&amp;r);
-        }
-        return r;
-}
-#endif
-
-void fileParser::hexDump(uint8_t *buf, int size)
-{
-	int len, i, j, c;
-
-	for(i=0;i&lt;size;i+=16)
-	{
-		len = size - i;
-
-		if (len &gt; 16)
-			len = 16;
-
-		printf(&quot;%08x &quot;, i);
-
-		for(j=0;j&lt;16;j++)
-		{
-			if (j &lt; len)
-				printf(&quot; %02x&quot;, buf[i+j]);
-			else
-				printf(&quot;   &quot;);
-		}
-
-		printf(&quot; &quot;);
-
-		for(j=0;j&lt;len;j++)
-		{
-			c = buf[i+j];
-
-			if (c &lt; ' ' || c &gt; '~')
-				c = '.';
-
-			printf(&quot;%c&quot;, c);
-		}
-
-		printf(&quot;\n&quot;);
-	}
-}

Deleted: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegPS/dmx_io.h
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegPS/dmx_io.h	2009-02-10 16:00:26 UTC (rev 4582)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegPS/dmx_io.h	2009-02-11 06:27:26 UTC (rev 4583)
@@ -1,129 +0,0 @@
-/***************************************************************************
-                          ADM_mpegparser.h  -  description
-                             -------------------
-    begin                : Tue Oct 15 2002
-    copyright            : (C) 2002 by mean
-    email                : <A HREF="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">fixounet at free.fr</A>
- ***************************************************************************/
-
-/***************************************************************************
- *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
- *                                                                         *
- ***************************************************************************/
-#ifndef FPARSER_
-#define FPARSER_
-#define DMX_BUFFER 1024*100
-
-/*
-        _off is the logical offset in the file
-        _head is the logical offset of the 1st byte in _buffer
-        _tail is the logical offset of the last byte in the buffer
-
-
-*/
-typedef enum 
-{
-        FP_PROBE=1,
-        FP_DONT_APPEND=2,
-        FP_APPEND=3
-}FP_TYPE;
-
- class fileParser
-{
-        private:
-         
-            uint8_t  *_buffer;
-            uint64_t _off;              // Absolute offset
-            
-            uint32_t _curFd;        
-            uint32_t _nbFd;
-            FILE      **_fd;
-            uint64_t *_sizeFd;          // Filesize for file X
-            uint64_t *_sizeFdCumul;     // Cumulative side from beginning =offset for the 1st byte in the file
-            uint64_t _head,_tail,_size;       
-           
-        public:
-                                fileParser(void);
-                                ~fileParser();                                         
-                        uint8_t  open(const char *name,FP_TYPE *multi);
-                        uint8_t  forward(uint64_t u);
-                        uint8_t  sync(uint8_t *t );
-                        uint8_t  syncH264(uint8_t *t );
-                        uint8_t  getpos(uint64_t *o);
-                        uint8_t  setpos(uint64_t o);                
-                        uint64_t getSize( void ) ;
-                        uint32_t read32(uint32_t l, uint8_t *buffer);
-                        uint8_t  end(void) { return _off==_size-1;};
-						void hexDump(uint8_t *buf, int size);
-#ifdef NO_INLINE_FP
-                        uint32_t read32i(void );
-                        uint16_t read16i(void );
-                        uint8_t  read8i(void );
-                        
-
-#else
-uint32_t read32i(void )
-{
-       uint32_t v;
-       uint8_t c[4];
-       uint8_t *p;
-        // case one, it fits in the buffer
-        //
-        if(_off+3&lt;_tail)
-        {
-                p=&amp;(_buffer[_off-_head]);
-                _off+=4;
-        }
-        else
-        {
-               read32(4,c);
-               p=c;
-        }
-       v= (p[0]&lt;&lt;24)+(p[1]&lt;&lt;16)+(p[2]&lt;&lt;8)+p[3];
-       return v;
-}
-uint16_t read16i(void )
-{
-  uint32_t v;
-       uint8_t c[4];
-       uint8_t *p;
-        // case one, it fits in the buffer
-        //
-        if(_off+1&lt;_tail)
-        {
-                p=&amp;(_buffer[_off-_head]);
-                _off+=2;
-        }
-        else
-        {
-               read32(2,c);
-               p=c;
-        }
-       v= (p[0]&lt;&lt;8)+p[1];
-       return v;
-}
-uint8_t read8i(void )
-{
-uint8_t r;
-        if(_off&lt;_tail)
-        {
-                r= _buffer[_off-_head];
-                _off++;     
-        }
-        else
-        {
-                read32(1,&amp;r);     
-        }
-        return r;
-}
-#endif
-
-
-} ;
-
-
-#endif

Deleted: branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegPS/dmx_mpegstartcode.h
===================================================================
--- branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegPS/dmx_mpegstartcode.h	2009-02-10 16:00:26 UTC (rev 4582)
+++ branches/avidemux_2.6_branch_mean/plugins/ADM_demuxers/MpegPS/dmx_mpegstartcode.h	2009-02-11 06:27:26 UTC (rev 4583)
@@ -1,22 +0,0 @@
-#ifndef DMX_STARTCODE
-#define DMX_STARTCODE
-
-#define PICTURE_START_CODE 0x00L
-#define SLICE_MIN_START    0x01L
-#define SLICE_MAX_START    0xAFL
-#define SEQ_START_CODE     0xB3L
-#define EXT_START_CODE     0xB5L
-#define SEQ_END_CODE       0xB7L
-#define GOP_START_CODE     0xB8L
-#define ISO_END_CODE       0xB9L
-#define PACK_START_CODE    0xBAL
-
-#define USER_DATA_START_CODE    0xb2
-#define SYSTEM_START_CODE       0xbb
-#define PADDING_CODE            0xbe
-#define PRIVATE_STREAM_1        0xbd
-#define PRIVATE_STREAM_2        0xbf
-#define SYSTEM_END_CODE         0xb9
-
-
-#endif


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="001812.html">[Avidemux-svn-commit] r4582 - in	branches/avidemux_2.5_branch_gruntster/platforms/windows:	build_scripts/avidemux installer
</A></li>
	<LI>Next message: <A HREF="001814.html">[Avidemux-svn-commit] r4584 -	branches/avidemux_2.5_branch_gruntster/platforms/windows/installer
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#1813">[ date ]</a>
              <a href="thread.html#1813">[ thread ]</a>
              <a href="subject.html#1813">[ subject ]</a>
              <a href="author.html#1813">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/avidemux-svn-commit">More information about the Avidemux-svn-commit
mailing list</a><br>
</body></html>
